Project Path: arc_beakthoven_TrickyStore_x81p2mzy

Source Tree:

```txt
arc_beakthoven_TrickyStore_x81p2mzy
â”œâ”€â”€ LICENSE
â”œâ”€â”€ NOTICE
â”œâ”€â”€ README.md
â”œâ”€â”€ app
â”‚   â”œâ”€â”€ build.gradle.kts
â”‚   â”œâ”€â”€ proguard-rules.pro
â”‚   â””â”€â”€ src
â”‚       â””â”€â”€ main
â”‚           â”œâ”€â”€ AndroidManifest.xml
â”‚           â”œâ”€â”€ cpp
â”‚           â”‚   â”œâ”€â”€ CMakeLists.txt
â”‚           â”‚   â”œâ”€â”€ binder_interceptor.cpp
â”‚           â”‚   â”œâ”€â”€ external
â”‚           â”‚   â”‚   â”œâ”€â”€ AOSP
â”‚           â”‚   â”‚   â”‚   â”œâ”€â”€ LICENSE
â”‚           â”‚   â”‚   â”‚   â””â”€â”€ include
â”‚           â”‚   â”‚   â”‚       â”œâ”€â”€ android-base
â”‚           â”‚   â”‚   â”‚       â”‚   â””â”€â”€ unique_fd.h
â”‚           â”‚   â”‚   â”‚       â”œâ”€â”€ binder
â”‚           â”‚   â”‚   â”‚       â”‚   â”œâ”€â”€ Binder.h
â”‚           â”‚   â”‚   â”‚       â”‚   â”œâ”€â”€ BpBinder.h
â”‚           â”‚   â”‚   â”‚       â”‚   â”œâ”€â”€ Common.h
â”‚           â”‚   â”‚   â”‚       â”‚   â”œâ”€â”€ IBinder.h
â”‚           â”‚   â”‚   â”‚       â”‚   â”œâ”€â”€ IInterface.h
â”‚           â”‚   â”‚   â”‚       â”‚   â”œâ”€â”€ IPCThreadState.h
â”‚           â”‚   â”‚   â”‚       â”‚   â”œâ”€â”€ IServiceManager.h
â”‚           â”‚   â”‚   â”‚       â”‚   â”œâ”€â”€ Parcel.h
â”‚           â”‚   â”‚   â”‚       â”‚   â”œâ”€â”€ Parcelable.h
â”‚           â”‚   â”‚   â”‚       â”‚   â”œâ”€â”€ ProcessState.h
â”‚           â”‚   â”‚   â”‚       â”‚   â”œâ”€â”€ RpcThreads.h
â”‚           â”‚   â”‚   â”‚       â”‚   â”œâ”€â”€ Status.h
â”‚           â”‚   â”‚   â”‚       â”‚   â””â”€â”€ unique_fd.h
â”‚           â”‚   â”‚   â”‚       â””â”€â”€ utils
â”‚           â”‚   â”‚   â”‚           â”œâ”€â”€ Errors.h
â”‚           â”‚   â”‚   â”‚           â”œâ”€â”€ LightRefBase.h
â”‚           â”‚   â”‚   â”‚           â”œâ”€â”€ RefBase.h
â”‚           â”‚   â”‚   â”‚           â”œâ”€â”€ String16.h
â”‚           â”‚   â”‚   â”‚           â”œâ”€â”€ String8.h
â”‚           â”‚   â”‚   â”‚           â”œâ”€â”€ StrongPointer.h
â”‚           â”‚   â”‚   â”‚           â”œâ”€â”€ TypeHelpers.h
â”‚           â”‚   â”‚   â”‚           â”œâ”€â”€ Unicode.h
â”‚           â”‚   â”‚   â”‚           â”œâ”€â”€ Vector.h
â”‚           â”‚   â”‚   â”‚           â””â”€â”€ VectorImpl.h
â”‚           â”‚   â”‚   â”œâ”€â”€ LSPlt
â”‚           â”‚   â”‚   â””â”€â”€ linux-kernel
â”‚           â”‚   â”‚       â””â”€â”€ include
â”‚           â”‚   â”‚           â””â”€â”€ android
â”‚           â”‚   â”‚               â””â”€â”€ binder.h
â”‚           â”‚   â”œâ”€â”€ inject
â”‚           â”‚   â”‚   â”œâ”€â”€ main.cpp
â”‚           â”‚   â”‚   â”œâ”€â”€ utils.cpp
â”‚           â”‚   â”‚   â””â”€â”€ utils.hpp
â”‚           â”‚   â”œâ”€â”€ logging
â”‚           â”‚   â”‚   â”œâ”€â”€ include
â”‚           â”‚   â”‚   â”‚   â””â”€â”€ logging.hpp
â”‚           â”‚   â”‚   â””â”€â”€ logging.cpp
â”‚           â”‚   â””â”€â”€ stub
â”‚           â”‚       â”œâ”€â”€ stub_binder.cpp
â”‚           â”‚       â””â”€â”€ stub_utils.cpp
â”‚           â””â”€â”€ java
â”‚               â””â”€â”€ io
â”‚                   â””â”€â”€ github
â”‚                       â””â”€â”€ beakthoven
â”‚                           â””â”€â”€ TrickyStoreOSS
â”‚                               â”œâ”€â”€ AndroidUtils.kt
â”‚                               â”œâ”€â”€ AttestUtils.kt
â”‚                               â”œâ”€â”€ CertificateGen.kt
â”‚                               â”œâ”€â”€ CertificateHack.kt
â”‚                               â”œâ”€â”€ CertificateUtils.kt
â”‚                               â”œâ”€â”€ Main.kt
â”‚                               â”œâ”€â”€ XmlParser.kt
â”‚                               â”œâ”€â”€ config
â”‚                               â”‚   â””â”€â”€ Config.kt
â”‚                               â”œâ”€â”€ interceptors
â”‚                               â”‚   â”œâ”€â”€ BinderInterceptor.kt
â”‚                               â”‚   â”œâ”€â”€ InterceptorUtils.kt
â”‚                               â”‚   â”œâ”€â”€ Keystore2Interceptor.kt
â”‚                               â”‚   â”œâ”€â”€ KeystoreInterceptor.kt
â”‚                               â”‚   â””â”€â”€ SecurityLevelInterceptor.kt
â”‚                               â””â”€â”€ logging
â”‚                                   â””â”€â”€ Logger.kt
â”œâ”€â”€ build.gradle.kts
â”œâ”€â”€ docs
â”‚   â””â”€â”€ 5ec1cff-violations.md
â”œâ”€â”€ gradle
â”‚   â”œâ”€â”€ libs.versions.toml
â”‚   â””â”€â”€ wrapper
â”‚       â”œâ”€â”€ gradle-wrapper.jar
â”‚       â””â”€â”€ gradle-wrapper.properties
â”œâ”€â”€ gradle.properties
â”œâ”€â”€ gradlew
â”œâ”€â”€ gradlew.bat
â”œâ”€â”€ module
â”‚   â”œâ”€â”€ META-INF
â”‚   â”‚   â””â”€â”€ com
â”‚   â”‚       â””â”€â”€ google
â”‚   â”‚           â””â”€â”€ android
â”‚   â”‚               â”œâ”€â”€ update-binary
â”‚   â”‚               â””â”€â”€ updater-script
â”‚   â”œâ”€â”€ customize.sh
â”‚   â”œâ”€â”€ daemon
â”‚   â”œâ”€â”€ keybox.xml
â”‚   â”œâ”€â”€ module.prop
â”‚   â”œâ”€â”€ post-fs-data.sh
â”‚   â”œâ”€â”€ sepolicy.rule
â”‚   â”œâ”€â”€ service.sh
â”‚   â””â”€â”€ target.txt
â”œâ”€â”€ settings.gradle.kts
â””â”€â”€ stub
    â”œâ”€â”€ build.gradle.kts
    â””â”€â”€ src
        â””â”€â”€ main
            â”œâ”€â”€ AndroidManifest.xml
            â””â”€â”€ java
                â””â”€â”€ android
                    â”œâ”€â”€ app
                    â”‚   â””â”€â”€ ActivityThread.java
                    â”œâ”€â”€ content
                    â”‚   â””â”€â”€ pm
                    â”‚       â”œâ”€â”€ BaseParceledListSlice.java
                    â”‚       â”œâ”€â”€ IPackageManager.java
                    â”‚       â””â”€â”€ ParceledListSlice.java
                    â”œâ”€â”€ hardware
                    â”‚   â””â”€â”€ security
                    â”‚       â””â”€â”€ keymint
                    â”‚           â”œâ”€â”€ Algorithm.java
                    â”‚           â”œâ”€â”€ EcCurve.java
                    â”‚           â”œâ”€â”€ KeyParameter.java
                    â”‚           â”œâ”€â”€ KeyParameterValue.java
                    â”‚           â”œâ”€â”€ KeyPurpose.java
                    â”‚           â”œâ”€â”€ SecurityLevel.java
                    â”‚           â””â”€â”€ Tag.java
                    â”œâ”€â”€ os
                    â”‚   â”œâ”€â”€ ServiceManager.java
                    â”‚   â””â”€â”€ SystemProperties.java
                    â”œâ”€â”€ security
                    â”‚   â”œâ”€â”€ Credentials.java
                    â”‚   â”œâ”€â”€ KeyStore.java
                    â”‚   â”œâ”€â”€ keymaster
                    â”‚   â”‚   â”œâ”€â”€ ExportResult.java
                    â”‚   â”‚   â”œâ”€â”€ KeyCharacteristics.java
                    â”‚   â”‚   â”œâ”€â”€ KeymasterArgument.java
                    â”‚   â”‚   â”œâ”€â”€ KeymasterArguments.java
                    â”‚   â”‚   â”œâ”€â”€ KeymasterCertificateChain.java
                    â”‚   â”‚   â””â”€â”€ KeymasterDefs.java
                    â”‚   â”œâ”€â”€ keystore
                    â”‚   â”‚   â”œâ”€â”€ AndroidKeyStoreProvider.java
                    â”‚   â”‚   â”œâ”€â”€ IKeystoreCertificateChainCallback.java
                    â”‚   â”‚   â”œâ”€â”€ IKeystoreExportKeyCallback.java
                    â”‚   â”‚   â”œâ”€â”€ IKeystoreKeyCharacteristicsCallback.java
                    â”‚   â”‚   â”œâ”€â”€ IKeystoreService.java
                    â”‚   â”‚   â””â”€â”€ KeystoreResponse.java
                    â”‚   â””â”€â”€ keystore2
                    â”‚       â””â”€â”€ AndroidKeyStoreProvider.java
                    â””â”€â”€ system
                        â””â”€â”€ keystore2
                            â”œâ”€â”€ Authorization.java
                            â”œâ”€â”€ IKeystoreSecurityLevel.java
                            â”œâ”€â”€ IKeystoreService.java
                            â”œâ”€â”€ KeyDescriptor.java
                            â”œâ”€â”€ KeyEntryResponse.java
                            â””â”€â”€ KeyMetadata.java

```

`LICENSE`:

```
                    GNU GENERAL PUBLIC LICENSE
                       Version 3, 29 June 2007

 Copyright (C) 2007 Free Software Foundation, Inc. <https://fsf.org/>
 Everyone is permitted to copy and distribute verbatim copies
 of this license document, but changing it is not allowed.

                            Preamble

  The GNU General Public License is a free, copyleft license for
software and other kinds of works.

  The licenses for most software and other practical works are designed
to take away your freedom to share and change the works.  By contrast,
the GNU General Public License is intended to guarantee your freedom to
share and change all versions of a program--to make sure it remains free
software for all its users.  We, the Free Software Foundation, use the
GNU General Public License for most of our software; it applies also to
any other work released this way by its authors.  You can apply it to
your programs, too.

  When we speak of free software, we are referring to freedom, not
price.  Our General Public Licenses are designed to make sure that you
have the freedom to distribute copies of free software (and charge for
them if you wish), that you receive source code or can get it if you
want it, that you can change the software or use pieces of it in new
free programs, and that you know you can do these things.

  To protect your rights, we need to prevent others from denying you
these rights or asking you to surrender the rights.  Therefore, you have
certain responsibilities if you distribute copies of the software, or if
you modify it: responsibilities to respect the freedom of others.

  For example, if you distribute copies of such a program, whether
gratis or for a fee, you must pass on to the recipients the same
freedoms that you received.  You must make sure that they, too, receive
or can get the source code.  And you must show them these terms so they
know their rights.

  Developers that use the GNU GPL protect your rights with two steps:
(1) assert copyright on the software, and (2) offer you this License
giving you legal permission to copy, distribute and/or modify it.

  For the developers' and authors' protection, the GPL clearly explains
that there is no warranty for this free software.  For both users' and
authors' sake, the GPL requires that modified versions be marked as
changed, so that their problems will not be attributed erroneously to
authors of previous versions.

  Some devices are designed to deny users access to install or run
modified versions of the software inside them, although the manufacturer
can do so.  This is fundamentally incompatible with the aim of
protecting users' freedom to change the software.  The systematic
pattern of such abuse occurs in the area of products for individuals to
use, which is precisely where it is most unacceptable.  Therefore, we
have designed this version of the GPL to prohibit the practice for those
products.  If such problems arise substantially in other domains, we
stand ready to extend this provision to those domains in future versions
of the GPL, as needed to protect the freedom of users.

  Finally, every program is threatened constantly by software patents.
States should not allow patents to restrict development and use of
software on general-purpose computers, but in those that do, we wish to
avoid the special danger that patents applied to a free program could
make it effectively proprietary.  To prevent this, the GPL assures that
patents cannot be used to render the program non-free.

  The precise terms and conditions for copying, distribution and
modification follow.

                       TERMS AND CONDITIONS

  0. Definitions.

  "This License" refers to version 3 of the GNU General Public License.

  "Copyright" also means copyright-like laws that apply to other kinds of
works, such as semiconductor masks.

  "The Program" refers to any copyrightable work licensed under this
License.  Each licensee is addressed as "you".  "Licensees" and
"recipients" may be individuals or organizations.

  To "modify" a work means to copy from or adapt all or part of the work
in a fashion requiring copyright permission, other than the making of an
exact copy.  The resulting work is called a "modified version" of the
earlier work or a work "based on" the earlier work.

  A "covered work" means either the unmodified Program or a work based
on the Program.

  To "propagate" a work means to do anything with it that, without
permission, would make you directly or secondarily liable for
infringement under applicable copyright law, except executing it on a
computer or modifying a private copy.  Propagation includes copying,
distribution (with or without modification), making available to the
public, and in some countries other activities as well.

  To "convey" a work means any kind of propagation that enables other
parties to make or receive copies.  Mere interaction with a user through
a computer network, with no transfer of a copy, is not conveying.

  An interactive user interface displays "Appropriate Legal Notices"
to the extent that it includes a convenient and prominently visible
feature that (1) displays an appropriate copyright notice, and (2)
tells the user that there is no warranty for the work (except to the
extent that warranties are provided), that licensees may convey the
work under this License, and how to view a copy of this License.  If
the interface presents a list of user commands or options, such as a
menu, a prominent item in the list meets this criterion.

  1. Source Code.

  The "source code" for a work means the preferred form of the work
for making modifications to it.  "Object code" means any non-source
form of a work.

  A "Standard Interface" means an interface that either is an official
standard defined by a recognized standards body, or, in the case of
interfaces specified for a particular programming language, one that
is widely used among developers working in that language.

  The "System Libraries" of an executable work include anything, other
than the work as a whole, that (a) is included in the normal form of
packaging a Major Component, but which is not part of that Major
Component, and (b) serves only to enable use of the work with that
Major Component, or to implement a Standard Interface for which an
implementation is available to the public in source code form.  A
"Major Component", in this context, means a major essential component
(kernel, window system, and so on) of the specific operating system
(if any) on which the executable work runs, or a compiler used to
produce the work, or an object code interpreter used to run it.

  The "Corresponding Source" for a work in object code form means all
the source code needed to generate, install, and (for an executable
work) run the object code and to modify the work, including scripts to
control those activities.  However, it does not include the work's
System Libraries, or general-purpose tools or generally available free
programs which are used unmodified in performing those activities but
which are not part of the work.  For example, Corresponding Source
includes interface definition files associated with source files for
the work, and the source code for shared libraries and dynamically
linked subprograms that the work is specifically designed to require,
such as by intimate data communication or control flow between those
subprograms and other parts of the work.

  The Corresponding Source need not include anything that users
can regenerate automatically from other parts of the Corresponding
Source.

  The Corresponding Source for a work in source code form is that
same work.

  2. Basic Permissions.

  All rights granted under this License are granted for the term of
copyright on the Program, and are irrevocable provided the stated
conditions are met.  This License explicitly affirms your unlimited
permission to run the unmodified Program.  The output from running a
covered work is covered by this License only if the output, given its
content, constitutes a covered work.  This License acknowledges your
rights of fair use or other equivalent, as provided by copyright law.

  You may make, run and propagate covered works that you do not
convey, without conditions so long as your license otherwise remains
in force.  You may convey covered works to others for the sole purpose
of having them make modifications exclusively for you, or provide you
with facilities for running those works, provided that you comply with
the terms of this License in conveying all material for which you do
not control copyright.  Those thus making or running the covered works
for you must do so exclusively on your behalf, under your direction
and control, on terms that prohibit them from making any copies of
your copyrighted material outside their relationship with you.

  Conveying under any other circumstances is permitted solely under
the conditions stated below.  Sublicensing is not allowed; section 10
makes it unnecessary.

  3. Protecting Users' Legal Rights From Anti-Circumvention Law.

  No covered work shall be deemed part of an effective technological
measure under any applicable law fulfilling obligations under article
11 of the WIPO copyright treaty adopted on 20 December 1996, or
similar laws prohibiting or restricting circumvention of such
measures.

  When you convey a covered work, you waive any legal power to forbid
circumvention of technological measures to the extent such circumvention
is effected by exercising rights under this License with respect to
the covered work, and you disclaim any intention to limit operation or
modification of the work as a means of enforcing, against the work's
users, your or third parties' legal rights to forbid circumvention of
technological measures.

  4. Conveying Verbatim Copies.

  You may convey verbatim copies of the Program's source code as you
receive it, in any medium, provided that you conspicuously and
appropriately publish on each copy an appropriate copyright notice;
keep intact all notices stating that this License and any
non-permissive terms added in accord with section 7 apply to the code;
keep intact all notices of the absence of any warranty; and give all
recipients a copy of this License along with the Program.

  You may charge any price or no price for each copy that you convey,
and you may offer support or warranty protection for a fee.

  5. Conveying Modified Source Versions.

  You may convey a work based on the Program, or the modifications to
produce it from the Program, in the form of source code under the
terms of section 4, provided that you also meet all of these conditions:

    a) The work must carry prominent notices stating that you modified
    it, and giving a relevant date.

    b) The work must carry prominent notices stating that it is
    released under this License and any conditions added under section
    7.  This requirement modifies the requirement in section 4 to
    "keep intact all notices".

    c) You must license the entire work, as a whole, under this
    License to anyone who comes into possession of a copy.  This
    License will therefore apply, along with any applicable section 7
    additional terms, to the whole of the work, and all its parts,
    regardless of how they are packaged.  This License gives no
    permission to license the work in any other way, but it does not
    invalidate such permission if you have separately received it.

    d) If the work has interactive user interfaces, each must display
    Appropriate Legal Notices; however, if the Program has interactive
    interfaces that do not display Appropriate Legal Notices, your
    work need not make them do so.

  A compilation of a covered work with other separate and independent
works, which are not by their nature extensions of the covered work,
and which are not combined with it such as to form a larger program,
in or on a volume of a storage or distribution medium, is called an
"aggregate" if the compilation and its resulting copyright are not
used to limit the access or legal rights of the compilation's users
beyond what the individual works permit.  Inclusion of a covered work
in an aggregate does not cause this License to apply to the other
parts of the aggregate.

  6. Conveying Non-Source Forms.

  You may convey a covered work in object code form under the terms
of sections 4 and 5, provided that you also convey the
machine-readable Corresponding Source under the terms of this License,
in one of these ways:

    a) Convey the object code in, or embodied in, a physical product
    (including a physical distribution medium), accompanied by the
    Corresponding Source fixed on a durable physical medium
    customarily used for software interchange.

    b) Convey the object code in, or embodied in, a physical product
    (including a physical distribution medium), accompanied by a
    written offer, valid for at least three years and valid for as
    long as you offer spare parts or customer support for that product
    model, to give anyone who possesses the object code either (1) a
    copy of the Corresponding Source for all the software in the
    product that is covered by this License, on a durable physical
    medium customarily used for software interchange, for a price no
    more than your reasonable cost of physically performing this
    conveying of source, or (2) access to copy the
    Corresponding Source from a network server at no charge.

    c) Convey individual copies of the object code with a copy of the
    written offer to provide the Corresponding Source.  This
    alternative is allowed only occasionally and noncommercially, and
    only if you received the object code with such an offer, in accord
    with subsection 6b.

    d) Convey the object code by offering access from a designated
    place (gratis or for a charge), and offer equivalent access to the
    Corresponding Source in the same way through the same place at no
    further charge.  You need not require recipients to copy the
    Corresponding Source along with the object code.  If the place to
    copy the object code is a network server, the Corresponding Source
    may be on a different server (operated by you or a third party)
    that supports equivalent copying facilities, provided you maintain
    clear directions next to the object code saying where to find the
    Corresponding Source.  Regardless of what server hosts the
    Corresponding Source, you remain obligated to ensure that it is
    available for as long as needed to satisfy these requirements.

    e) Convey the object code using peer-to-peer transmission, provided
    you inform other peers where the object code and Corresponding
    Source of the work are being offered to the general public at no
    charge under subsection 6d.

  A separable portion of the object code, whose source code is excluded
from the Corresponding Source as a System Library, need not be
included in conveying the object code work.

  A "User Product" is either (1) a "consumer product", which means any
tangible personal property which is normally used for personal, family,
or household purposes, or (2) anything designed or sold for incorporation
into a dwelling.  In determining whether a product is a consumer product,
doubtful cases shall be resolved in favor of coverage.  For a particular
product received by a particular user, "normally used" refers to a
typical or common use of that class of product, regardless of the status
of the particular user or of the way in which the particular user
actually uses, or expects or is expected to use, the product.  A product
is a consumer product regardless of whether the product has substantial
commercial, industrial or non-consumer uses, unless such uses represent
the only significant mode of use of the product.

  "Installation Information" for a User Product means any methods,
procedures, authorization keys, or other information required to install
and execute modified versions of a covered work in that User Product from
a modified version of its Corresponding Source.  The information must
suffice to ensure that the continued functioning of the modified object
code is in no case prevented or interfered with solely because
modification has been made.

  If you convey an object code work under this section in, or with, or
specifically for use in, a User Product, and the conveying occurs as
part of a transaction in which the right of possession and use of the
User Product is transferred to the recipient in perpetuity or for a
fixed term (regardless of how the transaction is characterized), the
Corresponding Source conveyed under this section must be accompanied
by the Installation Information.  But this requirement does not apply
if neither you nor any third party retains the ability to install
modified object code on the User Product (for example, the work has
been installed in ROM).

  The requirement to provide Installation Information does not include a
requirement to continue to provide support service, warranty, or updates
for a work that has been modified or installed by the recipient, or for
the User Product in which it has been modified or installed.  Access to a
network may be denied when the modification itself materially and
adversely affects the operation of the network or violates the rules and
protocols for communication across the network.

  Corresponding Source conveyed, and Installation Information provided,
in accord with this section must be in a format that is publicly
documented (and with an implementation available to the public in
source code form), and must require no special password or key for
unpacking, reading or copying.

  7. Additional Terms.

  "Additional permissions" are terms that supplement the terms of this
License by making exceptions from one or more of its conditions.
Additional permissions that are applicable to the entire Program shall
be treated as though they were included in this License, to the extent
that they are valid under applicable law.  If additional permissions
apply only to part of the Program, that part may be used separately
under those permissions, but the entire Program remains governed by
this License without regard to the additional permissions.

  When you convey a copy of a covered work, you may at your option
remove any additional permissions from that copy, or from any part of
it.  (Additional permissions may be written to require their own
removal in certain cases when you modify the work.)  You may place
additional permissions on material, added by you to a covered work,
for which you have or can give appropriate copyright permission.

  Notwithstanding any other provision of this License, for material you
add to a covered work, you may (if authorized by the copyright holders of
that material) supplement the terms of this License with terms:

    a) Disclaiming warranty or limiting liability differently from the
    terms of sections 15 and 16 of this License; or

    b) Requiring preservation of specified reasonable legal notices or
    author attributions in that material or in the Appropriate Legal
    Notices displayed by works containing it; or

    c) Prohibiting misrepresentation of the origin of that material, or
    requiring that modified versions of such material be marked in
    reasonable ways as different from the original version; or

    d) Limiting the use for publicity purposes of names of licensors or
    authors of the material; or

    e) Declining to grant rights under trademark law for use of some
    trade names, trademarks, or service marks; or

    f) Requiring indemnification of licensors and authors of that
    material by anyone who conveys the material (or modified versions of
    it) with contractual assumptions of liability to the recipient, for
    any liability that these contractual assumptions directly impose on
    those licensors and authors.

  All other non-permissive additional terms are considered "further
restrictions" within the meaning of section 10.  If the Program as you
received it, or any part of it, contains a notice stating that it is
governed by this License along with a term that is a further
restriction, you may remove that term.  If a license document contains
a further restriction but permits relicensing or conveying under this
License, you may add to a covered work material governed by the terms
of that license document, provided that the further restriction does
not survive such relicensing or conveying.

  If you add terms to a covered work in accord with this section, you
must place, in the relevant source files, a statement of the
additional terms that apply to those files, or a notice indicating
where to find the applicable terms.

  Additional terms, permissive or non-permissive, may be stated in the
form of a separately written license, or stated as exceptions;
the above requirements apply either way.

  8. Termination.

  You may not propagate or modify a covered work except as expressly
provided under this License.  Any attempt otherwise to propagate or
modify it is void, and will automatically terminate your rights under
this License (including any patent licenses granted under the third
paragraph of section 11).

  However, if you cease all violation of this License, then your
license from a particular copyright holder is reinstated (a)
provisionally, unless and until the copyright holder explicitly and
finally terminates your license, and (b) permanently, if the copyright
holder fails to notify you of the violation by some reasonable means
prior to 60 days after the cessation.

  Moreover, your license from a particular copyright holder is
reinstated permanently if the copyright holder notifies you of the
violation by some reasonable means, this is the first time you have
received notice of violation of this License (for any work) from that
copyright holder, and you cure the violation prior to 30 days after
your receipt of the notice.

  Termination of your rights under this section does not terminate the
licenses of parties who have received copies or rights from you under
this License.  If your rights have been terminated and not permanently
reinstated, you do not qualify to receive new licenses for the same
material under section 10.

  9. Acceptance Not Required for Having Copies.

  You are not required to accept this License in order to receive or
run a copy of the Program.  Ancillary propagation of a covered work
occurring solely as a consequence of using peer-to-peer transmission
to receive a copy likewise does not require acceptance.  However,
nothing other than this License grants you permission to propagate or
modify any covered work.  These actions infringe copyright if you do
not accept this License.  Therefore, by modifying or propagating a
covered work, you indicate your acceptance of this License to do so.

  10. Automatic Licensing of Downstream Recipients.

  Each time you convey a covered work, the recipient automatically
receives a license from the original licensors, to run, modify and
propagate that work, subject to this License.  You are not responsible
for enforcing compliance by third parties with this License.

  An "entity transaction" is a transaction transferring control of an
organization, or substantially all assets of one, or subdividing an
organization, or merging organizations.  If propagation of a covered
work results from an entity transaction, each party to that
transaction who receives a copy of the work also receives whatever
licenses to the work the party's predecessor in interest had or could
give under the previous paragraph, plus a right to possession of the
Corresponding Source of the work from the predecessor in interest, if
the predecessor has it or can get it with reasonable efforts.

  You may not impose any further restrictions on the exercise of the
rights granted or affirmed under this License.  For example, you may
not impose a license fee, royalty, or other charge for exercise of
rights granted under this License, and you may not initiate litigation
(including a cross-claim or counterclaim in a lawsuit) alleging that
any patent claim is infringed by making, using, selling, offering for
sale, or importing the Program or any portion of it.

  11. Patents.

  A "contributor" is a copyright holder who authorizes use under this
License of the Program or a work on which the Program is based.  The
work thus licensed is called the contributor's "contributor version".

  A contributor's "essential patent claims" are all patent claims
owned or controlled by the contributor, whether already acquired or
hereafter acquired, that would be infringed by some manner, permitted
by this License, of making, using, or selling its contributor version,
but do not include claims that would be infringed only as a
consequence of further modification of the contributor version.  For
purposes of this definition, "control" includes the right to grant
patent sublicenses in a manner consistent with the requirements of
this License.

  Each contributor grants you a non-exclusive, worldwide, royalty-free
patent license under the contributor's essential patent claims, to
make, use, sell, offer for sale, import and otherwise run, modify and
propagate the contents of its contributor version.

  In the following three paragraphs, a "patent license" is any express
agreement or commitment, however denominated, not to enforce a patent
(such as an express permission to practice a patent or covenant not to
sue for patent infringement).  To "grant" such a patent license to a
party means to make such an agreement or commitment not to enforce a
patent against the party.

  If you convey a covered work, knowingly relying on a patent license,
and the Corresponding Source of the work is not available for anyone
to copy, free of charge and under the terms of this License, through a
publicly available network server or other readily accessible means,
then you must either (1) cause the Corresponding Source to be so
available, or (2) arrange to deprive yourself of the benefit of the
patent license for this particular work, or (3) arrange, in a manner
consistent with the requirements of this License, to extend the patent
license to downstream recipients.  "Knowingly relying" means you have
actual knowledge that, but for the patent license, your conveying the
covered work in a country, or your recipient's use of the covered work
in a country, would infringe one or more identifiable patents in that
country that you have reason to believe are valid.

  If, pursuant to or in connection with a single transaction or
arrangement, you convey, or propagate by procuring conveyance of, a
covered work, and grant a patent license to some of the parties
receiving the covered work authorizing them to use, propagate, modify
or convey a specific copy of the covered work, then the patent license
you grant is automatically extended to all recipients of the covered
work and works based on it.

  A patent license is "discriminatory" if it does not include within
the scope of its coverage, prohibits the exercise of, or is
conditioned on the non-exercise of one or more of the rights that are
specifically granted under this License.  You may not convey a covered
work if you are a party to an arrangement with a third party that is
in the business of distributing software, under which you make payment
to the third party based on the extent of your activity of conveying
the work, and under which the third party grants, to any of the
parties who would receive the covered work from you, a discriminatory
patent license (a) in connection with copies of the covered work
conveyed by you (or copies made from those copies), or (b) primarily
for and in connection with specific products or compilations that
contain the covered work, unless you entered into that arrangement,
or that patent license was granted, prior to 28 March 2007.

  Nothing in this License shall be construed as excluding or limiting
any implied license or other defenses to infringement that may
otherwise be available to you under applicable patent law.

  12. No Surrender of Others' Freedom.

  If conditions are imposed on you (whether by court order, agreement or
otherwise) that contradict the conditions of this License, they do not
excuse you from the conditions of this License.  If you cannot convey a
covered work so as to satisfy simultaneously your obligations under this
License and any other pertinent obligations, then as a consequence you may
not convey it at all.  For example, if you agree to terms that obligate you
to collect a royalty for further conveying from those to whom you convey
the Program, the only way you could satisfy both those terms and this
License would be to refrain entirely from conveying the Program.

  13. Use with the GNU Affero General Public License.

  Notwithstanding any other provision of this License, you have
permission to link or combine any covered work with a work licensed
under version 3 of the GNU Affero General Public License into a single
combined work, and to convey the resulting work.  The terms of this
License will continue to apply to the part which is the covered work,
but the special requirements of the GNU Affero General Public License,
section 13, concerning interaction through a network will apply to the
combination as such.

  14. Revised Versions of this License.

  The Free Software Foundation may publish revised and/or new versions of
the GNU General Public License from time to time.  Such new versions will
be similar in spirit to the present version, but may differ in detail to
address new problems or concerns.

  Each version is given a distinguishing version number.  If the
Program specifies that a certain numbered version of the GNU General
Public License "or any later version" applies to it, you have the
option of following the terms and conditions either of that numbered
version or of any later version published by the Free Software
Foundation.  If the Program does not specify a version number of the
GNU General Public License, you may choose any version ever published
by the Free Software Foundation.

  If the Program specifies that a proxy can decide which future
versions of the GNU General Public License can be used, that proxy's
public statement of acceptance of a version permanently authorizes you
to choose that version for the Program.

  Later license versions may give you additional or different
permissions.  However, no additional obligations are imposed on any
author or copyright holder as a result of your choosing to follow a
later version.

  15. Disclaimer of Warranty.

  THERE IS NO WARRANTY FOR THE PROGRAM, TO THE EXTENT PERMITTED BY
APPLICABLE LAW.  EXCEPT WHEN OTHERWISE STATED IN WRITING THE COPYRIGHT
HOLDERS AND/OR OTHER PARTIES PROVIDE THE PROGRAM "AS IS" WITHOUT WARRANTY
OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING, BUT NOT LIMITED TO,
THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
PURPOSE.  THE ENTIRE RISK AS TO THE QUALITY AND PERFORMANCE OF THE PROGRAM
IS WITH YOU.  SHOULD THE PROGRAM PROVE DEFECTIVE, YOU ASSUME THE COST OF
ALL NECESSARY SERVICING, REPAIR OR CORRECTION.

  16. Limitation of Liability.

  IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING
WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MODIFIES AND/OR CONVEYS
THE PROGRAM AS PERMITTED ABOVE, BE LIABLE TO YOU FOR DAMAGES, INCLUDING ANY
GENERAL, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING OUT OF THE
USE OR INABILITY TO USE THE PROGRAM (INCLUDING BUT NOT LIMITED TO LOSS OF
DATA OR DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY YOU OR THIRD
PARTIES OR A FAILURE OF THE PROGRAM TO OPERATE WITH ANY OTHER PROGRAMS),
EVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE POSSIBILITY OF
SUCH DAMAGES.

  17. Interpretation of Sections 15 and 16.

  If the disclaimer of warranty and limitation of liability provided
above cannot be given local legal effect according to their terms,
reviewing courts shall apply local law that most closely approximates
an absolute waiver of all civil liability in connection with the
Program, unless a warranty or assumption of liability accompanies a
copy of the Program in return for a fee.

                     END OF TERMS AND CONDITIONS

            How to Apply These Terms to Your New Programs

  If you develop a new program, and you want it to be of the greatest
possible use to the public, the best way to achieve this is to make it
free software which everyone can redistribute and change under these terms.

  To do so, attach the following notices to the program.  It is safest
to attach them to the start of each source file to most effectively
state the exclusion of warranty; and each file should have at least
the "copyright" line and a pointer to where the full notice is found.

    <one line to give the program's name and a brief idea of what it does.>
    Copyright (C) <year>  <name of author>

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <https://www.gnu.org/licenses/>.

Also add information on how to contact you by electronic and paper mail.

  If the program does terminal interaction, make it output a short
notice like this when it starts in an interactive mode:

    <program>  Copyright (C) <year>  <name of author>
    This program comes with ABSOLUTELY NO WARRANTY; for details type `show w'.
    This is free software, and you are welcome to redistribute it
    under certain conditions; type `show c' for details.

The hypothetical commands `show w' and `show c' should show the appropriate
parts of the General Public License.  Of course, your program's commands
might be different; for a GUI interface, you would use an "about box".

  You should also get your employer (if you work as a programmer) or school,
if any, to sign a "copyright disclaimer" for the program, if necessary.
For more information on this, and how to apply and follow the GNU GPL, see
<https://www.gnu.org/licenses/>.

  The GNU General Public License does not permit incorporating your program
into proprietary programs.  If your program is a subroutine library, you
may consider it more useful to permit linking proprietary applications with
the library.  If this is what you want to do, use the GNU Lesser General
Public License instead of this License.  But first, please read
<https://www.gnu.org/licenses/why-not-lgpl.html>.

```

`NOTICE`:

```
This project is licensed under the GNU General Public License v3.0
(see LICENSE file).

Third-party components:
-----------------------

1. Portions of this project include code from the Android Open Source Project (AOSP) located in:
       app/src/main/cpp/external/AOSP/
   The corresponding Apache License 2.0 is provided in:
       app/src/main/cpp/external/AOSP/LICENSE

2. This project includes the LSPlt library as a Git submodule located in:
       app/src/main/cpp/external/LSPlt/
   This submodule now uses a fork maintained at:
        https://github.com/JingMatrix/LSPlt
   LSPlt is licensed under the GNU Lesser General Public License v3.0 (LGPLv3).
   The license can be viewed at:
       https://github.com/JingMatrix/LSPlt/blob/master/LICENSE

3. Portions of this project include binder header file from the Linux kernel UAPI,
   located in:
       app/src/main/cpp/external/linux-kernel/include/android/binder.h
   The file is licensed under:
       GNU General Public License v2.0 WITH Linux-syscall-note exception.
   Information about the exception:
       https://spdx.org/licenses/Linux-syscall-note.html
```

`README.md`:

```md
# Tricky Store OSS â€“ A Trick of Keystore They Forgot to Hide

A **FOSS** alternative to the proprietary [TrickyStore](https://github.com/5ec1cff/TrickyStore) Magisk module.  

## â“ Why?

We all know about the [multiple violations and questionable practices by the author of TrickyStore](docs/5ec1cff-violations.md).  
Because of this, I decided to create a **complete rewrite from scratch**, based on:  

- Various projects mentioned in [Acknowledgement](https://github.com/beakthoven/TrickyStoreOSS?tab=readme-ov-file#%EF%B8%8F-acknowledgement) section
- Official changelogs and expected behavior of newer releases  
- My own feature additions and fixes that were part of an earlier fork of the older codebase  

Tricky Store OSS is **rightfully licensed under GPLv3**, ensuring it stays free and compliant with open-source laws.

## âœ¨ Features

- 100% **FOSS**
- Developed to match the proprietary implementationâ€™s behavior and feature set as closely as possible

## ğŸ“± Requirements
- Android 10 or above

## ğŸ“¦ Installtion

1. Flash this module and reboot
2. (Optional) Place an unrevoked hardware keybox.xml at `/data/adb/tricky_store/keybox.xml` for extended integrity
3. (Optional) Customize target packages in `/data/adb/tricky_store/target.txt`
4. (Optional) Customize security patch in `/data/adb/tricky_store/security_patch.txt`
5. Enjoy!


**All configuration files will take effect immediately.**

### keybox.xml

format:

```xml
<?xml version="1.0"?>
<AndroidAttestation>
    <NumberOfKeyboxes>1</NumberOfKeyboxes>
    <Keybox DeviceID="...">
        <Key algorithm="ecdsa|rsa">
            <PrivateKey format="pem">
-----BEGIN EC PRIVATE KEY-----
...
-----END EC PRIVATE KEY-----
            </PrivateKey>
            <CertificateChain>
                <NumberOfCertificates>...</NumberOfCertificates>
                    <Certificate format="pem">
-----BEGIN CERTIFICATE-----
...
-----END CERTIFICATE-----
                    </Certificate>
                ... more certificates
            </CertificateChain>
        </Key>...
    </Keybox>
</AndroidAttestation>
```

### Mode configuration

Tricky Store OSS supports two modes: leaf certificate hacking and certificate generation.
On TEE-broken devices, leaf hacking wonâ€™t work since the leaf certificate canâ€™t be retrieved from TEE. The module automatically selects the appropriate mode for your device.

You can override this behavior per package:
- Add ! â†’ Force certificate generation mode
- Add ? â†’ Force leaf hacking mode
- No symbol â†’ Automatic mode

For example:

```
# target.txt
# use automatic mode for gsf
com.google.android.gsf
# use leaf certificate hacking mode for key attestation App
io.github.vvb2060.keyattestation?
# use certificate generating mode for gms
com.google.android.gms!
```

### Customize security patch level 

Create the file `/data/adb/tricky_store/security_patch.txt`.

Simple:

```
# Hack os/vendor/boot security patch level
20241101
```

Advanced:

```
# os security patch level is 202411
system=202411
# do not hack boot patch level
boot=no
# vendor patch level is 20241101 (another format)
vendor=2024-11-01
# default value
# all=20241101
# keep consistent with system prop
# system=prop
```

Note: This only affects KeyAttestation results.
It does not change system properties; use resetprop separately if needed.

## ğŸ¤ Contributions
PRs are welcome. Thank you for supporting true open-source development.

## â¤ï¸ Acknowledgement

- [BootloaderSpoofer](https://github.com/chiteroman/BootloaderSpoofer) (dead, relied on forks and mirrors)
- [FrameworkPatch](https://github.com/chiteroman/FrameworkPatch) (dead, relied on forks and mirrors)
- [KeyAttestation](https://github.com/vvb2060/KeyAttestation)
- [KeystoreInjection](https://github.com/aviraxp/Zygisk-KeystoreInjection)
- [LSPlt-JingMatrix](https://github.com/JingMatrix/LSPlt)
- [LSPosed](https://github.com/LSPosed/LSPosed)
- [PlayIntegrityFork](https://github.com/osm0sis/PlayIntegrityFork)

```

`app/build.gradle.kts`:

```kts
/*
 * Copyright 2025 Dakkshesh <beakthoven@gmail.com>
 * SPDX-License-Identifier: GPL-3.0-or-later
 */

import java.io.ByteArrayOutputStream

plugins {
    alias(libs.plugins.android.application)
    alias(libs.plugins.kotlin.android)
}

fun String.execute(currentWorkingDir: File = File("./")): String {
    val parts = this.split("\\s+".toRegex())
    val process = ProcessBuilder(parts)
        .directory(currentWorkingDir)
        .redirectErrorStream(true)
        .start()

    val output = process.inputStream.bufferedReader().readText()
    process.waitFor()
    return output.trim()
}


val gitCommitCount = "git rev-list HEAD --count".execute().toInt()
val gitCommitHash = "git rev-parse --verify --short HEAD".execute()
val verName = "v2.1.0"

android {
    namespace = "io.github.beakthoven.TrickyStoreOSS"
    compileSdk = 36
    ndkVersion = "28.2.13676358"
    buildToolsVersion = "36.0.0"

    defaultConfig {
        applicationId = "io.github.beakthoven.TrickyStoreOSS"
        minSdk = 29
        targetSdk = 36
        versionCode = gitCommitCount
        versionName = verName

        externalNativeBuild {
            cmake {
                arguments += "-DANDROID_STL=none"
                arguments += "-DCMAKE_BUILD_TYPE=Release"
                arguments += "-DANDROID_SUPPORT_FLEXIBLE_PAGE_SIZES=ON"
                arguments += "-DANDROID_ALLOW_UNDEFINED_SYMBOLS=ON"
                arguments += "-DCMAKE_CXX_STANDARD=23"
                arguments += "-DCMAKE_C_STANDARD=23"
                arguments += "-DCMAKE_INTERPROCEDURAL_OPTIMIZATION=ON"
                arguments += "-DLSPLT_BUILD_SHARED=OFF"
                arguments += "-DLSPLT_STANDALONE=ON"

                cppFlags += "-std=c++23"
                cppFlags += "-fno-exceptions"
                cppFlags += "-fno-rtti"
                cppFlags += "-fvisibility=hidden"
                cppFlags += "-fvisibility-inlines-hidden"
            }
        }
    }

    buildFeatures {
        prefab = true
    }

    buildTypes {
        release {
            isMinifyEnabled = true
            proguardFiles(
                getDefaultProguardFile("proguard-android-optimize.txt"),
                "proguard-rules.pro"
            )
        }
    }
    compileOptions {
        sourceCompatibility = JavaVersion.VERSION_21
        targetCompatibility = JavaVersion.VERSION_21
    }
    externalNativeBuild {
        cmake {
            path = file("src/main/cpp/CMakeLists.txt")
            version = "3.28.0+"
        }
    }
    buildFeatures {
        viewBinding = false
    }
}

dependencies {
    compileOnly(project(":stub"))
    compileOnly(libs.annotation)
    implementation(libs.org.bouncycastle.bcpkix.jdk18on)
    implementation(libs.org.lsposed.libcxx.libcxx)
}

afterEvaluate {
    android.applicationVariants.forEach { variant ->
        val variantName = variant.name
        val capitalized = variantName.replaceFirstChar { it.uppercase() }
        val tempModuleDir = project.layout.buildDirectory.dir("tmp/module-${variantName}")
        
        tasks.register("copyFiles${capitalized}") {
            val moduleFolder = project.rootDir.resolve("module")
            val buildDir = project.layout.buildDirectory
            
            doLast {
                val isDebug = variantName.contains("debug", ignoreCase = true)
                //val apkFile = variant.outputs.first().outputFile

                listOf("service.apk", "classes.dex").forEach { fileName ->
                    val oldFile = moduleFolder.resolve(fileName)
                    if (oldFile.exists()) oldFile.delete()
                }

                // Select source file based on build type
                val sourceFile = if (isDebug) {
                    variant.outputs.first().outputFile
                } else {
                    buildDir.get().asFile.resolve("intermediates/dex/release/minifyReleaseWithR8/classes.dex")
                }

                val destFileName = if (isDebug) "service.apk" else "classes.dex"
                sourceFile.copyTo(moduleFolder.resolve(destFileName), overwrite = true)

                val soDir = buildDir.get()
                    .asFile
                    .resolve("intermediates/stripped_native_libs/$variantName/strip${capitalized}DebugSymbols/out/lib")
                
                //apkFile.copyTo(moduleFolder.resolve("service.apk"), overwrite = true)
                
                val allowedLibs = setOf("libinject.so", "libTrickyStoreOSS.so")
                soDir.walk()
                    .filter { it.isFile && it.name in allowedLibs }
                    .forEach { soFile ->
                        val abiFolder = soFile.parentFile.name
                        val destination = moduleFolder.resolve("lib/$abiFolder/${soFile.name}")
                        soFile.copyTo(destination, overwrite = true)
                    }
            }
        }
        
        // Prepare temp directory with all files
        tasks.register("prepareModuleFiles${capitalized}") {
            dependsOn("copyFiles${capitalized}")
            val sourceDir = project.rootDir.resolve("module")
            
            doLast {
                val tempDir = tempModuleDir.get().asFile
                
                // Clean and create temp directory
                tempDir.deleteRecursively()
                tempDir.mkdirs()
                
                // Copy all files except module.prop
                sourceDir.walkTopDown()
                    .filter { it.isFile && it.name != "module.prop" }
                    .forEach { sourceFile ->
                        val relativePath = sourceFile.relativeTo(sourceDir)
                        val destFile = tempDir.resolve(relativePath)
                        destFile.parentFile.mkdirs()
                        sourceFile.copyTo(destFile, overwrite = true)
                    }
                
                // Process module.prop
                val sourceProp = sourceDir.resolve("module.prop")
                val destProp = tempDir.resolve("module.prop")
                val content = sourceProp.readText()
                val processedContent = content
                    .replace("REPLACEMEVERCODE", gitCommitCount.toString())
                    .replace("REPLACEMEVER", "$verName ($gitCommitCount-$gitCommitHash-$variantName)")
                destProp.writeText(processedContent)
            }
        }
        
        // Zip task uses the temp directory
        tasks.register<Zip>("zip${capitalized}") {
            dependsOn("prepareModuleFiles${capitalized}")
            archiveFileName.set("Tricky-Store-OSS-$verName-$gitCommitCount-$gitCommitHash-${capitalized}.zip")
            destinationDirectory.set(project.rootDir.resolve("out"))
            from(tempModuleDir)
        }
        
        tasks["assemble${capitalized}"].finalizedBy("zip${capitalized}")
    }
}
```

`app/proguard-rules.pro`:

```pro
# Add project specific ProGuard rules here.
# You can control the set of applied configuration files using the
# proguardFiles setting in build.gradle.
#
# For more details, see
#   http://developer.android.com/guide/developing/tools/proguard.html

# If your project uses WebView with JS, uncomment the following
# and specify the fully qualified class name to the JavaScript interface
# class:
#-keepclassmembers class fqcn.of.javascript.interface.for.webview {
#   public *;
#}

# Uncomment this to preserve the line number information for
# debugging stack traces.
#-keepattributes SourceFile,LineNumberTable

# If you keep the line number information, uncomment this to
# hide the original source file name.
#-renamesourcefileattribute SourceFile

-keepclasseswithmembers class io.github.beakthoven.TrickyStoreOSS.MainKt {
    public static void main(java.lang.String[]);
}

-assumenosideeffects class io.github.beakthoven.TrickyStoreOSS.logging.Logger {
    public static void d(java.lang.String);
    public static void dd(java.lang.String);
    public static void v(java.lang.String);
}

-assumenosideeffects class android.util.Log {
    public static int v(...);
    public static int d(...);
}

# keep these or bouncycastle will not work
-keep class org.bouncycastle.jcajce.provider.** { *; }
-keep class org.bouncycastle.jce.provider.** { *; }
-dontwarn javax.naming.**

# Keep `Companion` object fields of serializable classes.
# This avoids serializer lookup through `getDeclaredClasses` as done for named companion objects.
-if @kotlinx.serialization.Serializable class **
-keepclassmembers class <1> {
   static <1>$Companion Companion;
}

# Keep `serializer()` on companion objects (both default and named) of serializable classes.
-if @kotlinx.serialization.Serializable class ** {
   static **$* *;
}
-keepclassmembers class <2>$<3> {
   kotlinx.serialization.KSerializer serializer(...);
}

# Keep `INSTANCE.serializer()` of serializable objects.
-if @kotlinx.serialization.Serializable class ** {
   public static ** INSTANCE;
}
-keepclassmembers class <1> {
   public static <1> INSTANCE;
   kotlinx.serialization.KSerializer serializer(...);
}

# Keep all interceptor classes and their methods - used via reflection and JNI
-keep class io.github.beakthoven.TrickyStoreOSS.interceptors.** {
    *;
}

# Keep SecurityLevelInterceptor and its inner classes
-keep class io.github.beakthoven.TrickyStoreOSS.interceptors.SecurityLevelInterceptor {
    *;
}

# Keep Key and Info inner classes used in maps - critical for runtime
-keepclassmembers class io.github.beakthoven.TrickyStoreOSS.interceptors.SecurityLevelInterceptor$Key {
    *;
}
-keepclassmembers class io.github.beakthoven.TrickyStoreOSS.interceptors.SecurityLevelInterceptor$Info {
    *;
}

# Keep Parcelable CREATOR fields
-keepclassmembers class * implements android.os.Parcelable {
    public static final ** CREATOR;
}

-repackageclasses
-allowaccessmodification
-overloadaggressively
-keepattributes SourceFile,LineNumberTable,LocalVariableTable
-renamesourcefileattribute
```

`app/src/main/AndroidManifest.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<!--
 Copyright 2025 Dakkshesh <beakthoven@gmail.com>
 SPDX-License-Identifier: GPL-3.0-or-later
-->

<manifest/>
```

`app/src/main/cpp/CMakeLists.txt`:

```txt
# Copyright 2025 Dakkshesh <beakthoven@gmail.com>
# SPDX-License-Identifier: GPL-3.0-or-later
cmake_minimum_required(VERSION 3.28)
project(TrickyStoreOSS)

find_package(cxx REQUIRED CONFIG)
link_libraries(cxx::cxx)

add_library(my_logging STATIC logging/logging.cpp)
target_include_directories(my_logging PUBLIC logging/include)
target_link_libraries(my_logging log)

# LSPlt configuration
add_subdirectory(external/LSPlt/lsplt/src/main/jni)

# libutils stub
add_library(utils SHARED stub/stub_utils.cpp)
target_include_directories(utils PUBLIC external/AOSP/include)

# libbinder stub
add_library(binder SHARED stub/stub_binder.cpp)
target_include_directories(binder PUBLIC external/AOSP/include)
target_link_libraries(binder PRIVATE utils)

add_executable(libinject.so inject/main.cpp inject/utils.cpp)
target_link_libraries(libinject.so PRIVATE lsplt_static my_logging)

add_library(${CMAKE_PROJECT_NAME} SHARED binder_interceptor.cpp)
target_include_directories(${CMAKE_PROJECT_NAME} PUBLIC external/linux-kernel/include)
target_link_libraries(${CMAKE_PROJECT_NAME} PRIVATE log binder utils lsplt_static my_logging)

```

`app/src/main/cpp/binder_interceptor.cpp`:

```cpp
// Copyright 2025 Dakkshesh <beakthoven@gmail.com>
// SPDX-License-Identifier: GPL-3.0-or-later

#include <android/binder.h>
#include <binder/Binder.h>
#include <binder/Common.h>
#include <binder/IPCThreadState.h>
#include <binder/IServiceManager.h>
#include <binder/Parcel.h>
#include <sys/ioctl.h>
#include <utils/StrongPointer.h>

#include <map>
#include <memory>
#include <queue>
#include <shared_mutex>
#include <span>
#include <string_view>
#include <utility>
#include <vector>

#include "logging.hpp"
#include "lsplt.hpp"

using namespace android;

namespace {
namespace intercept_constants {
constexpr uint32_t kRegisterInterceptor = 1;
constexpr uint32_t kUnregisterInterceptor = 2;

constexpr uint32_t kPreTransact = 1;
constexpr uint32_t kPostTransact = 2;

constexpr uint32_t kActionSkip = 1;
constexpr uint32_t kActionContinue = 2;
constexpr uint32_t kActionOverrideReply = 3;
constexpr uint32_t kActionOverrideData = 4;

constexpr uint32_t kBackdoorCode = 0xdeadbeef;
} // namespace intercept_constants
} // namespace

class BinderInterceptor : public BBinder {
    struct InterceptorRegistration {
        wp<IBinder> target_binder{};
        sp<IBinder> interceptor_binder;

        InterceptorRegistration() = default;
        InterceptorRegistration(wp<IBinder> target, sp<IBinder> interceptor)
            : target_binder(std::move(target)), interceptor_binder(std::move(interceptor)) {}
    };
    using RwLock = std::shared_mutex;
    using WriteGuard = std::unique_lock<RwLock>;
    using ReadGuard = std::shared_lock<RwLock>;

    mutable RwLock interceptor_registry_lock_;
    std::map<wp<IBinder>, InterceptorRegistration> interceptor_registry_{};

public:
    status_t onTransact(uint32_t code, const android::Parcel &data, android::Parcel *reply, uint32_t flags) override;

    bool handleInterceptedTransaction(sp<BBinder> target_binder, uint32_t transaction_code, const Parcel &request_data,
                                      Parcel *reply_data, uint32_t transaction_flags, status_t &result);

    bool shouldInterceptBinder(const wp<BBinder> &target_binder) const;

private:
    status_t handleRegisterInterceptor(const android::Parcel &data);
    status_t handleUnregisterInterceptor(const android::Parcel &data);

    template <typename ParcelWriter>
    status_t writeInterceptorCallData(ParcelWriter &writer, sp<BBinder> target_binder, uint32_t transaction_code,
                                      uint32_t transaction_flags, const Parcel &data) const;

    status_t validateInterceptorResponse(const Parcel &response, int32_t &action_type) const;
};

static sp<BinderInterceptor> g_binder_interceptor = nullptr;

struct ThreadTransactionInfo {
    uint32_t transaction_code;
    wp<BBinder> target_binder;

    ThreadTransactionInfo() = default;
    ThreadTransactionInfo(uint32_t code, wp<BBinder> target) : transaction_code(code), target_binder(std::move(target)) {}
};

thread_local std::queue<ThreadTransactionInfo> g_thread_transaction_queue;

class BinderStub : public BBinder {
    status_t onTransact(uint32_t code, const android::Parcel &data, android::Parcel *reply, uint32_t flags) override {
        LOGD("BinderStub transaction: %u", code);

        if (g_thread_transaction_queue.empty()) {
            LOGW("No pending transaction info for stub");
            return UNKNOWN_TRANSACTION;
        }

        auto transaction_info = g_thread_transaction_queue.front();
        g_thread_transaction_queue.pop();

        if (transaction_info.target_binder == nullptr && transaction_info.transaction_code == intercept_constants::kBackdoorCode &&
            reply != nullptr) {
            LOGD("Backdoor access requested - providing interceptor reference");
            reply->writeStrongBinder(g_binder_interceptor);
            return OK;
        }

        if (auto promoted_target = transaction_info.target_binder.promote()) {
            LOGD("Processing intercepted transaction");
            status_t result;
            if (!g_binder_interceptor->handleInterceptedTransaction(promoted_target, transaction_info.transaction_code, data, reply,
                                                                    flags, result)) {
                LOGD("Forwarding to original binder");
                result = promoted_target->transact(transaction_info.transaction_code, data, reply, flags);
            }
            return result;
        } else {
            LOGE("Failed to promote weak reference to target binder");
            return DEAD_OBJECT;
        }
    }
};

static sp<BinderStub> g_binder_stub = nullptr;

int (*original_ioctl_function)(int fd, int request, ...) = nullptr;

namespace {
bool processBinderTransaction(binder_transaction_data *transaction_data) {
    if (!transaction_data || transaction_data->target.ptr == 0) {
        return false;
    }

    bool should_intercept = false;
    ThreadTransactionInfo transaction_info{};

    if (transaction_data->code == intercept_constants::kBackdoorCode && transaction_data->sender_euid == 0) {
        transaction_info.transaction_code = intercept_constants::kBackdoorCode;
        transaction_info.target_binder = nullptr;
        should_intercept = true;
        LOGD("Backdoor transaction detected from root user");
    } else {
        auto *weak_ref = reinterpret_cast<RefBase::weakref_type *>(transaction_data->target.ptr);
        if (weak_ref->attemptIncStrong(nullptr)) {
            auto *target_binder = reinterpret_cast<BBinder *>(transaction_data->cookie);
            auto weak_binder = wp<BBinder>::fromExisting(target_binder);

            if (g_binder_interceptor->shouldInterceptBinder(weak_binder)) {
                transaction_info.transaction_code = transaction_data->code;
                transaction_info.target_binder = weak_binder;
                should_intercept = true;
                LOGD("Interception required for transaction code=%u target=%p", transaction_data->code, target_binder);
            }
            target_binder->decStrong(nullptr);
        }
    }

    if (should_intercept) {
        LOGD("Redirecting transaction through stub");
        transaction_data->target.ptr = reinterpret_cast<uintptr_t>(g_binder_stub->getWeakRefs());
        transaction_data->cookie = reinterpret_cast<uintptr_t>(g_binder_stub.get());
        transaction_data->code = intercept_constants::kBackdoorCode;
        g_thread_transaction_queue.push(std::move(transaction_info));
    }

    return should_intercept;
}

void processBinderWriteRead(const binder_write_read &write_read_data) {
    if (write_read_data.read_buffer == 0 || write_read_data.read_size == 0 || write_read_data.read_consumed <= sizeof(uint32_t)) {
        return;
    }

    LOGD("Processing binder read buffer: ptr=%p size=%zu consumed=%zu", reinterpret_cast<void *>(write_read_data.read_buffer),
         write_read_data.read_size, write_read_data.read_consumed);

    auto buffer_ptr = write_read_data.read_buffer;
    auto remaining_bytes = write_read_data.read_consumed;

    while (remaining_bytes > 0) {
        if (remaining_bytes < sizeof(uint32_t)) {
            LOGE("Insufficient bytes for command header: %llu", static_cast<unsigned long long>(remaining_bytes));
            break;
        }

        auto command = *reinterpret_cast<const uint32_t *>(buffer_ptr);
        buffer_ptr += sizeof(uint32_t);
        remaining_bytes -= sizeof(uint32_t);

        auto command_size = _IOC_SIZE(command);
        LOGD("Processing binder command: %u (size: %u)", command, command_size);

        if (remaining_bytes < command_size) {
            LOGE("Insufficient bytes for command data: %llu < %u", static_cast<unsigned long long>(remaining_bytes), command_size);
            break;
        }

        if (command == BR_TRANSACTION_SEC_CTX || command == BR_TRANSACTION) {
            binder_transaction_data *transaction_data = nullptr;

            if (command == BR_TRANSACTION_SEC_CTX) {
                LOGD("Processing BR_TRANSACTION_SEC_CTX");
                auto *secctx_data = reinterpret_cast<const binder_transaction_data_secctx *>(buffer_ptr);
                transaction_data = const_cast<binder_transaction_data *>(&secctx_data->transaction_data);
            } else {
                LOGD("Processing BR_TRANSACTION");
                transaction_data = reinterpret_cast<binder_transaction_data *>(buffer_ptr);
            }

            if (transaction_data) {
                processBinderTransaction(transaction_data);
            } else {
                LOGE("Failed to extract transaction data");
            }
        }

        buffer_ptr += command_size;
        remaining_bytes -= command_size;
    }
}
} // namespace

int intercepted_ioctl_function(int fd, int request, ...) {
    va_list args;
    va_start(args, request);
    auto *argument = va_arg(args, void *);
    va_end(args);

    auto result = original_ioctl_function(fd, request, argument);

    if (result >= 0 && request == BINDER_WRITE_READ && argument) {
        const auto &write_read_data = *static_cast<const binder_write_read *>(argument);
        processBinderWriteRead(write_read_data);
    }

    return result;
}

bool BinderInterceptor::shouldInterceptBinder(const wp<BBinder> &target_binder) const {
    ReadGuard guard{interceptor_registry_lock_};
    return interceptor_registry_.find(target_binder) != interceptor_registry_.end();
}

status_t BinderInterceptor::onTransact(uint32_t code, const android::Parcel &data, android::Parcel *reply, uint32_t flags) {
    switch (code) {
    case intercept_constants::kRegisterInterceptor:
        return handleRegisterInterceptor(data);
    case intercept_constants::kUnregisterInterceptor:
        return handleUnregisterInterceptor(data);
    default:
        return UNKNOWN_TRANSACTION;
    }
}

status_t BinderInterceptor::handleRegisterInterceptor(const android::Parcel &data) {
    sp<IBinder> target_binder, interceptor_binder;

    if (data.readStrongBinder(&target_binder) != OK) {
        LOGE("Failed to read target binder from registration data");
        return BAD_VALUE;
    }

    if (!target_binder->localBinder()) {
        LOGE("Target binder is not a local binder");
        return BAD_VALUE;
    }

    if (data.readStrongBinder(&interceptor_binder) != OK) {
        LOGE("Failed to read interceptor binder from registration data");
        return BAD_VALUE;
    }

    {
        WriteGuard write_guard{interceptor_registry_lock_};
        wp<IBinder> weak_target = target_binder;

        auto iterator = interceptor_registry_.lower_bound(weak_target);
        if (iterator == interceptor_registry_.end() || iterator->first != weak_target) {
            iterator =
                interceptor_registry_.emplace_hint(iterator, weak_target, InterceptorRegistration{weak_target, interceptor_binder});
        } else {
            iterator->second.interceptor_binder = interceptor_binder;
        }

        LOGI("Registered interceptor for binder %p", target_binder.get());
        return OK;
    }
}

status_t BinderInterceptor::handleUnregisterInterceptor(const android::Parcel &data) {
    sp<IBinder> target_binder, interceptor_binder;

    if (data.readStrongBinder(&target_binder) != OK) {
        LOGE("Failed to read target binder from unregistration data");
        return BAD_VALUE;
    }

    if (!target_binder->localBinder()) {
        LOGE("Target binder is not a local binder");
        return BAD_VALUE;
    }

    if (data.readStrongBinder(&interceptor_binder) != OK) {
        LOGE("Failed to read interceptor binder from unregistration data");
        return BAD_VALUE;
    }

    {
        WriteGuard write_guard{interceptor_registry_lock_};
        wp<IBinder> weak_target = target_binder;

        auto iterator = interceptor_registry_.find(weak_target);
        if (iterator != interceptor_registry_.end()) {
            if (iterator->second.interceptor_binder != interceptor_binder) {
                LOGE("Interceptor mismatch during unregistration");
                return BAD_VALUE;
            }
            interceptor_registry_.erase(iterator);
            LOGI("Unregistered interceptor for binder %p", target_binder.get());
            return OK;
        }

        LOGW("Attempted to unregister non-existent interceptor");
        return BAD_VALUE;
    }
}

bool BinderInterceptor::handleInterceptedTransaction(sp<BBinder> target_binder, uint32_t transaction_code, const Parcel &request_data,
                                                     Parcel *reply_data, uint32_t transaction_flags, status_t &result) {
#define VALIDATE_STATUS(expr)                                   \
    do {                                                        \
        auto __result = (expr);                                 \
        if (__result != OK) {                                   \
            LOGE("Operation failed: " #expr " = %d", __result); \
            return false;                                       \
        }                                                       \
    } while (0)

    sp<IBinder> interceptor_binder;
    {
        ReadGuard read_guard{interceptor_registry_lock_};
        auto iterator = interceptor_registry_.find(target_binder);
        if (iterator == interceptor_registry_.end()) {
            LOGE("No interceptor found for target binder %p", target_binder.get());
            return false;
        }
        interceptor_binder = iterator->second.interceptor_binder;
    }

    LOGD("Intercepting transaction: binder=%p code=%u flags=%u reply=%s", target_binder.get(), transaction_code, transaction_flags,
         reply_data ? "true" : "false");

    Parcel pre_request_data, pre_response_data, modified_request_data;

    VALIDATE_STATUS(writeInterceptorCallData(pre_request_data, target_binder, transaction_code, transaction_flags, request_data));
    VALIDATE_STATUS(interceptor_binder->transact(intercept_constants::kPreTransact, pre_request_data, &pre_response_data));

    int32_t pre_action_type;
    VALIDATE_STATUS(validateInterceptorResponse(pre_response_data, pre_action_type));

    LOGD("Pre-transaction action type: %d", pre_action_type);

    switch (pre_action_type) {
    case intercept_constants::kActionSkip:
        return false;

    case intercept_constants::kActionOverrideReply:
        result = pre_response_data.readInt32();
        if (reply_data) {
            size_t reply_size = pre_response_data.readUint64();
            VALIDATE_STATUS(reply_data->appendFrom(&pre_response_data, pre_response_data.dataPosition(), reply_size));
        }
        return true;

    case intercept_constants::kActionOverrideData: {
        size_t data_size = pre_response_data.readUint64();
        VALIDATE_STATUS(modified_request_data.appendFrom(&pre_response_data, pre_response_data.dataPosition(), data_size));
        break;
    }

    case intercept_constants::kActionContinue:
    default:
        VALIDATE_STATUS(modified_request_data.appendFrom(&request_data, 0, request_data.dataSize()));
        break;
    }

    result = target_binder->transact(transaction_code, modified_request_data, reply_data, transaction_flags);

    Parcel post_request_data, post_response_data;

    VALIDATE_STATUS(post_request_data.writeStrongBinder(target_binder));
    VALIDATE_STATUS(post_request_data.writeUint32(transaction_code));
    VALIDATE_STATUS(post_request_data.writeUint32(transaction_flags));
    VALIDATE_STATUS(post_request_data.writeInt32(IPCThreadState::self()->getCallingUid()));
    VALIDATE_STATUS(post_request_data.writeInt32(IPCThreadState::self()->getCallingPid()));
    VALIDATE_STATUS(post_request_data.writeInt32(result));
    VALIDATE_STATUS(post_request_data.writeUint64(request_data.dataSize()));
    VALIDATE_STATUS(post_request_data.appendFrom(&request_data, 0, request_data.dataSize()));

    size_t reply_size = reply_data ? reply_data->dataSize() : 0;
    VALIDATE_STATUS(post_request_data.writeUint64(reply_size));
    LOGD("Transaction sizes: request=%zu reply=%zu", request_data.dataSize(), reply_size);

    if (reply_data && reply_size > 0) {
        VALIDATE_STATUS(post_request_data.appendFrom(reply_data, 0, reply_size));
    }

    VALIDATE_STATUS(interceptor_binder->transact(intercept_constants::kPostTransact, post_request_data, &post_response_data));

    int32_t post_action_type;
    VALIDATE_STATUS(validateInterceptorResponse(post_response_data, post_action_type));

    LOGD("Post-transaction action type: %d", post_action_type);

    if (post_action_type == intercept_constants::kActionOverrideReply) {
        result = post_response_data.readInt32();
        if (reply_data) {
            size_t new_reply_size = post_response_data.readUint64();
            reply_data->freeData();
            VALIDATE_STATUS(reply_data->appendFrom(&post_response_data, post_response_data.dataPosition(), new_reply_size));
            LOGD("Reply overridden: original_size=%zu new_size=%zu", reply_size, new_reply_size);
        }
    }

    return true;

#undef VALIDATE_STATUS
}

template <typename ParcelWriter>
status_t BinderInterceptor::writeInterceptorCallData(ParcelWriter &writer, sp<BBinder> target_binder, uint32_t transaction_code,
                                                     uint32_t transaction_flags, const Parcel &data) const {
    auto status = writer.writeStrongBinder(target_binder);
    if (status != OK)
        return status;

    status = writer.writeUint32(transaction_code);
    if (status != OK)
        return status;

    status = writer.writeUint32(transaction_flags);
    if (status != OK)
        return status;

    status = writer.writeInt32(IPCThreadState::self()->getCallingUid());
    if (status != OK)
        return status;

    status = writer.writeInt32(IPCThreadState::self()->getCallingPid());
    if (status != OK)
        return status;

    status = writer.writeUint64(data.dataSize());
    if (status != OK)
        return status;

    return writer.appendFrom(&data, 0, data.dataSize());
}

status_t BinderInterceptor::validateInterceptorResponse(const Parcel &response, int32_t &action_type) const {
    auto status = response.readInt32(&action_type);
    if (status != OK) {
        LOGE("Failed to read action type from interceptor response");
        return status;
    }

    switch (action_type) {
    case intercept_constants::kActionSkip:
    case intercept_constants::kActionContinue:
    case intercept_constants::kActionOverrideReply:
    case intercept_constants::kActionOverrideData:
        return OK;
    default:
        LOGE("Invalid action type from interceptor: %d", action_type);
        return BAD_VALUE;
    }
}

namespace {
constexpr std::string_view kBinderLibraryName = "/libbinder.so";
constexpr std::string_view kIoctlFunctionName = "ioctl";
} // namespace

bool initializeBinderInterception() {
    auto memory_maps = lsplt::MapInfo::Scan();

    dev_t binder_device_id;
    ino_t binder_inode;
    bool binder_library_found = false;

    for (const auto &memory_map : memory_maps) {
        if (memory_map.path.ends_with(kBinderLibraryName)) {
            binder_device_id = memory_map.dev;
            binder_inode = memory_map.inode;
            binder_library_found = true;
            LOGD("Found binder library: %s (dev=0x%lx, inode=%lu)", memory_map.path.c_str(),
                 static_cast<unsigned long>(binder_device_id), static_cast<unsigned long>(binder_inode));
            break;
        }
    }

    if (!binder_library_found) {
        LOGE("Failed to locate libbinder.so in process memory maps");
        return false;
    }

    g_binder_interceptor = sp<BinderInterceptor>::make();
    g_binder_stub = sp<BinderStub>::make();

    if (!g_binder_interceptor || !g_binder_stub) {
        LOGE("Failed to create binder interceptor components");
        return false;
    }

    lsplt::RegisterHook(binder_device_id, binder_inode, kIoctlFunctionName.data(),
                        reinterpret_cast<void *>(intercepted_ioctl_function), reinterpret_cast<void **>(&original_ioctl_function));

    if (!lsplt::CommitHook()) {
        LOGE("Failed to commit binder ioctl hook");
        g_binder_interceptor.clear();
        g_binder_stub.clear();
        return false;
    }

    LOGI("Binder interception initialized successfully");
    return true;
}

extern "C" [[gnu::visibility("default")]] [[gnu::used]]
bool entry(void *library_handle) {
    LOGI("TrickyStore binder interceptor loaded (handle: %p)", library_handle);

    bool success = initializeBinderInterception();
    if (success) {
        LOGI("Binder interception entry point completed successfully");
    } else {
        LOGE("Binder interception initialization failed");
    }

    return success;
}

```

`app/src/main/cpp/external/AOSP/LICENSE`:

```

                                 Apache License
                           Version 2.0, January 2004
                        http://www.apache.org/licenses/

   TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION

   1. Definitions.

      "License" shall mean the terms and conditions for use, reproduction,
      and distribution as defined by Sections 1 through 9 of this document.

      "Licensor" shall mean the copyright owner or entity authorized by
      the copyright owner that is granting the License.

      "Legal Entity" shall mean the union of the acting entity and all
      other entities that control, are controlled by, or are under common
      control with that entity. For the purposes of this definition,
      "control" means (i) the power, direct or indirect, to cause the
      direction or management of such entity, whether by contract or
      otherwise, or (ii) ownership of fifty percent (50%) or more of the
      outstanding shares, or (iii) beneficial ownership of such entity.

      "You" (or "Your") shall mean an individual or Legal Entity
      exercising permissions granted by this License.

      "Source" form shall mean the preferred form for making modifications,
      including but not limited to software source code, documentation
      source, and configuration files.

      "Object" form shall mean any form resulting from mechanical
      transformation or translation of a Source form, including but
      not limited to compiled object code, generated documentation,
      and conversions to other media types.

      "Work" shall mean the work of authorship, whether in Source or
      Object form, made available under the License, as indicated by a
      copyright notice that is included in or attached to the work
      (an example is provided in the Appendix below).

      "Derivative Works" shall mean any work, whether in Source or Object
      form, that is based on (or derived from) the Work and for which the
      editorial revisions, annotations, elaborations, or other modifications
      represent, as a whole, an original work of authorship. For the purposes
      of this License, Derivative Works shall not include works that remain
      separable from, or merely link (or bind by name) to the interfaces of,
      the Work and Derivative Works thereof.

      "Contribution" shall mean any work of authorship, including
      the original version of the Work and any modifications or additions
      to that Work or Derivative Works thereof, that is intentionally
      submitted to Licensor for inclusion in the Work by the copyright owner
      or by an individual or Legal Entity authorized to submit on behalf of
      the copyright owner. For the purposes of this definition, "submitted"
      means any form of electronic, verbal, or written communication sent
      to the Licensor or its representatives, including but not limited to
      communication on electronic mailing lists, source code control systems,
      and issue tracking systems that are managed by, or on behalf of, the
      Licensor for the purpose of discussing and improving the Work, but
      excluding communication that is conspicuously marked or otherwise
      designated in writing by the copyright owner as "Not a Contribution."

      "Contributor" shall mean Licensor and any individual or Legal Entity
      on behalf of whom a Contribution has been received by Licensor and
      subsequently incorporated within the Work.

   2. Grant of Copyright License. Subject to the terms and conditions of
      this License, each Contributor hereby grants to You a perpetual,
      worldwide, non-exclusive, no-charge, royalty-free, irrevocable
      copyright license to reproduce, prepare Derivative Works of,
      publicly display, publicly perform, sublicense, and distribute the
      Work and such Derivative Works in Source or Object form.

   3. Grant of Patent License. Subject to the terms and conditions of
      this License, each Contributor hereby grants to You a perpetual,
      worldwide, non-exclusive, no-charge, royalty-free, irrevocable
      (except as stated in this section) patent license to make, have made,
      use, offer to sell, sell, import, and otherwise transfer the Work,
      where such license applies only to those patent claims licensable
      by such Contributor that are necessarily infringed by their
      Contribution(s) alone or by combination of their Contribution(s)
      with the Work to which such Contribution(s) was submitted. If You
      institute patent litigation against any entity (including a
      cross-claim or counterclaim in a lawsuit) alleging that the Work
      or a Contribution incorporated within the Work constitutes direct
      or contributory patent infringement, then any patent licenses
      granted to You under this License for that Work shall terminate
      as of the date such litigation is filed.

   4. Redistribution. You may reproduce and distribute copies of the
      Work or Derivative Works thereof in any medium, with or without
      modifications, and in Source or Object form, provided that You
      meet the following conditions:

      (a) You must give any other recipients of the Work or
          Derivative Works a copy of this License; and

      (b) You must cause any modified files to carry prominent notices
          stating that You changed the files; and

      (c) You must retain, in the Source form of any Derivative Works
          that You distribute, all copyright, patent, trademark, and
          attribution notices from the Source form of the Work,
          excluding those notices that do not pertain to any part of
          the Derivative Works; and

      (d) If the Work includes a "NOTICE" text file as part of its
          distribution, then any Derivative Works that You distribute must
          include a readable copy of the attribution notices contained
          within such NOTICE file, excluding those notices that do not
          pertain to any part of the Derivative Works, in at least one
          of the following places: within a NOTICE text file distributed
          as part of the Derivative Works; within the Source form or
          documentation, if provided along with the Derivative Works; or,
          within a display generated by the Derivative Works, if and
          wherever such third-party notices normally appear. The contents
          of the NOTICE file are for informational purposes only and
          do not modify the License. You may add Your own attribution
          notices within Derivative Works that You distribute, alongside
          or as an addendum to the NOTICE text from the Work, provided
          that such additional attribution notices cannot be construed
          as modifying the License.

      You may add Your own copyright statement to Your modifications and
      may provide additional or different license terms and conditions
      for use, reproduction, or distribution of Your modifications, or
      for any such Derivative Works as a whole, provided Your use,
      reproduction, and distribution of the Work otherwise complies with
      the conditions stated in this License.

   5. Submission of Contributions. Unless You explicitly state otherwise,
      any Contribution intentionally submitted for inclusion in the Work
      by You to the Licensor shall be under the terms and conditions of
      this License, without any additional terms or conditions.
      Notwithstanding the above, nothing herein shall supersede or modify
      the terms of any separate license agreement you may have executed
      with Licensor regarding such Contributions.

   6. Trademarks. This License does not grant permission to use the trade
      names, trademarks, service marks, or product names of the Licensor,
      except as required for reasonable and customary use in describing the
      origin of the Work and reproducing the content of the NOTICE file.

   7. Disclaimer of Warranty. Unless required by applicable law or
      agreed to in writing, Licensor provides the Work (and each
      Contributor provides its Contributions) on an "AS IS" BASIS,
      WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
      implied, including, without limitation, any warranties or conditions
      of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A
      PARTICULAR PURPOSE. You are solely responsible for determining the
      appropriateness of using or redistributing the Work and assume any
      risks associated with Your exercise of permissions under this License.

   8. Limitation of Liability. In no event and under no legal theory,
      whether in tort (including negligence), contract, or otherwise,
      unless required by applicable law (such as deliberate and grossly
      negligent acts) or agreed to in writing, shall any Contributor be
      liable to You for damages, including any direct, indirect, special,
      incidental, or consequential damages of any character arising as a
      result of this License or out of the use or inability to use the
      Work (including but not limited to damages for loss of goodwill,
      work stoppage, computer failure or malfunction, or any and all
      other commercial damages or losses), even if such Contributor
      has been advised of the possibility of such damages.

   9. Accepting Warranty or Additional Liability. While redistributing
      the Work or Derivative Works thereof, You may choose to offer,
      and charge a fee for, acceptance of support, warranty, indemnity,
      or other liability obligations and/or rights consistent with this
      License. However, in accepting such obligations, You may act only
      on Your own behalf and on Your sole responsibility, not on behalf
      of any other Contributor, and only if You agree to indemnify,
      defend, and hold each Contributor harmless for any liability
      incurred by, or claims asserted against, such Contributor by reason
      of your accepting any such warranty or additional liability.

   END OF TERMS AND CONDITIONS

   APPENDIX: How to apply the Apache License to your work.

      To apply the Apache License to your work, attach the following
      boilerplate notice, with the fields enclosed by brackets "[]"
      replaced with your own identifying information. (Don't include
      the brackets!)  The text should be enclosed in the appropriate
      comment syntax for the file format. We also recommend that a
      file or class name and description of purpose be included on the
      same "printed page" as the copyright notice for easier
      identification within third-party archives.

   Copyright [yyyy] [name of copyright owner]

   Licensed under the Apache License, Version 2.0 (the "License");
   you may not use this file except in compliance with the License.
   You may obtain a copy of the License at

       http://www.apache.org/licenses/LICENSE-2.0

   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an "AS IS" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License.
```

`app/src/main/cpp/external/AOSP/include/android-base/unique_fd.h`:

```h
/*
 * Copyright (C) 2015 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#pragma once

#include <dirent.h>
#include <errno.h>
#include <fcntl.h>

#include <stdio.h>
#include <sys/types.h>
#include <unistd.h>

// DO NOT INCLUDE OTHER LIBBASE HEADERS HERE!
// This file gets used in libbinder, and libbinder is used everywhere.
// Including other headers from libbase frequently results in inclusion of
// android-base/macros.h, which causes macro collisions.

#if defined(__BIONIC__)
#include <android/fdsan.h>
#endif
#if !defined(_WIN32) && !defined(__TRUSTY__)
#include <sys/socket.h>
#endif

namespace android {
namespace base {

// Container for a file descriptor that automatically closes the descriptor as
// it goes out of scope.
//
//      unique_fd ufd(open("/some/path", "r"));
//      if (ufd.get() == -1) return error;
//
//      // Do something useful, possibly including 'return'.
//
//      return 0; // Descriptor is closed for you.
//
// See also the Pipe()/Socketpair()/Fdopen()/Fdopendir() functions in this file
// that provide interoperability with the libc functions with the same (but
// lowercase) names.
//
// unique_fd is also known as ScopedFd/ScopedFD/scoped_fd; mentioned here to help
// you find this class if you're searching for one of those names.
//
// unique_fd itself is a specialization of unique_fd_impl with a default closer.
template <typename Closer>
class unique_fd_impl final {
 public:
  unique_fd_impl() {}

  explicit unique_fd_impl(int fd) { reset(fd); }
  ~unique_fd_impl() { reset(); }

  unique_fd_impl(const unique_fd_impl&) = delete;
  void operator=(const unique_fd_impl&) = delete;
  unique_fd_impl(unique_fd_impl&& other) noexcept { reset(other.release()); }
  unique_fd_impl& operator=(unique_fd_impl&& s) noexcept {
    int fd = s.fd_;
    s.fd_ = -1;
    reset(fd, &s);
    return *this;
  }

  [[clang::reinitializes]] void reset(int new_value = -1) { reset(new_value, nullptr); }

  int get() const { return fd_; }

#if !defined(ANDROID_BASE_UNIQUE_FD_DISABLE_IMPLICIT_CONVERSION)
  // unique_fd's operator int is dangerous, but we have way too much code that
  // depends on it, so make this opt-in at first.
  operator int() const { return get(); }  // NOLINT
#endif

  bool operator>=(int rhs) const { return get() >= rhs; }
  bool operator<(int rhs) const { return get() < rhs; }
  bool operator==(int rhs) const { return get() == rhs; }
  bool operator!=(int rhs) const { return get() != rhs; }
  bool operator==(const unique_fd_impl& rhs) const { return get() == rhs.get(); }
  bool operator!=(const unique_fd_impl& rhs) const { return get() != rhs.get(); }

  // Catch bogus error checks (i.e.: "!fd" instead of "fd != -1").
  bool operator!() const = delete;

  bool ok() const { return get() >= 0; }

  int release() __attribute__((warn_unused_result)) {
    tag(fd_, this, nullptr);
    int ret = fd_;
    fd_ = -1;
    return ret;
  }

 private:
  void reset(int new_value, void* previous_tag) {
    int previous_errno = errno;

    if (fd_ != -1) {
      close(fd_, this);
    }

    fd_ = new_value;
    if (new_value != -1) {
      tag(new_value, previous_tag, this);
    }

    errno = previous_errno;
  }

  int fd_ = -1;

  // Template magic to use Closer::Tag if available, and do nothing if not.
  // If Closer::Tag exists, this implementation is preferred, because int is a better match.
  // If not, this implementation is SFINAEd away, and the no-op below is the only one that exists.
  template <typename T = Closer>
  static auto tag(int fd, void* old_tag, void* new_tag)
      -> decltype(T::Tag(fd, old_tag, new_tag), void()) {
    T::Tag(fd, old_tag, new_tag);
  }

  template <typename T = Closer>
  static void tag(long, void*, void*) {
    // No-op.
  }

  // Same as above, to select between Closer::Close(int) and Closer::Close(int, void*).
  template <typename T = Closer>
  static auto close(int fd, void* tag_value) -> decltype(T::Close(fd, tag_value), void()) {
    T::Close(fd, tag_value);
  }

  template <typename T = Closer>
  static auto close(int fd, void*) -> decltype(T::Close(fd), void()) {
    T::Close(fd);
  }
};

// The actual details of closing are factored out to support unusual cases.
// Almost everyone will want this DefaultCloser, which handles fdsan on bionic.
struct DefaultCloser {
#if defined(__BIONIC__)
  static void Tag(int fd, void* old_addr, void* new_addr) {
    if (android_fdsan_exchange_owner_tag) {
      uint64_t old_tag = android_fdsan_create_owner_tag(ANDROID_FDSAN_OWNER_TYPE_UNIQUE_FD,
                                                        reinterpret_cast<uint64_t>(old_addr));
      uint64_t new_tag = android_fdsan_create_owner_tag(ANDROID_FDSAN_OWNER_TYPE_UNIQUE_FD,
                                                        reinterpret_cast<uint64_t>(new_addr));
      android_fdsan_exchange_owner_tag(fd, old_tag, new_tag);
    }
  }
  static void Close(int fd, void* addr) {
    if (android_fdsan_close_with_tag) {
      uint64_t tag = android_fdsan_create_owner_tag(ANDROID_FDSAN_OWNER_TYPE_UNIQUE_FD,
                                                    reinterpret_cast<uint64_t>(addr));
      android_fdsan_close_with_tag(fd, tag);
    } else {
      close(fd);
    }
  }
#else
  static void Close(int fd) {
    // Even if close(2) fails with EINTR, the fd will have been closed.
    // Using TEMP_FAILURE_RETRY will either lead to EBADF or closing someone
    // else's fd.
    // http://lkml.indiana.edu/hypermail/linux/kernel/0509.1/0877.html
    ::close(fd);
  }
#endif
};

using unique_fd = unique_fd_impl<DefaultCloser>;

#if !defined(_WIN32) && !defined(__TRUSTY__)

// Inline functions, so that they can be used header-only.

// See pipe(2).
// This helper hides the details of converting to unique_fd, and also hides the
// fact that macOS doesn't support O_CLOEXEC or O_NONBLOCK directly.
template <typename Closer>
inline bool Pipe(unique_fd_impl<Closer>* read, unique_fd_impl<Closer>* write,
                 int flags = O_CLOEXEC) {
  int pipefd[2];

#if defined(__linux__)
  if (pipe2(pipefd, flags) != 0) {
    return false;
  }
#else  // defined(__APPLE__)
  if (flags & ~(O_CLOEXEC | O_NONBLOCK)) {
    return false;
  }
  if (pipe(pipefd) != 0) {
    return false;
  }

  if (flags & O_CLOEXEC) {
    if (fcntl(pipefd[0], F_SETFD, FD_CLOEXEC) != 0 || fcntl(pipefd[1], F_SETFD, FD_CLOEXEC) != 0) {
      close(pipefd[0]);
      close(pipefd[1]);
      return false;
    }
  }
  if (flags & O_NONBLOCK) {
    if (fcntl(pipefd[0], F_SETFL, O_NONBLOCK) != 0 || fcntl(pipefd[1], F_SETFL, O_NONBLOCK) != 0) {
      close(pipefd[0]);
      close(pipefd[1]);
      return false;
    }
  }
#endif

  read->reset(pipefd[0]);
  write->reset(pipefd[1]);
  return true;
}

// See socketpair(2).
// This helper hides the details of converting to unique_fd.
template <typename Closer>
inline bool Socketpair(int domain, int type, int protocol, unique_fd_impl<Closer>* left,
                       unique_fd_impl<Closer>* right) {
  int sockfd[2];
  if (socketpair(domain, type, protocol, sockfd) != 0) {
    return false;
  }
  left->reset(sockfd[0]);
  right->reset(sockfd[1]);
  return true;
}

// See socketpair(2).
// This helper hides the details of converting to unique_fd.
template <typename Closer>
inline bool Socketpair(int type, unique_fd_impl<Closer>* left, unique_fd_impl<Closer>* right) {
  return Socketpair(AF_UNIX, type, 0, left, right);
}

// See fdopen(3).
// Using fdopen with unique_fd correctly is more annoying than it should be,
// because fdopen doesn't close the file descriptor received upon failure.
inline FILE* Fdopen(unique_fd&& ufd, const char* mode) {
  int fd = ufd.release();
  FILE* file = fdopen(fd, mode);
  if (!file) {
    close(fd);
  }
  return file;
}

// See fdopendir(3).
// Using fdopendir with unique_fd correctly is more annoying than it should be,
// because fdopen doesn't close the file descriptor received upon failure.
inline DIR* Fdopendir(unique_fd&& ufd) {
  int fd = ufd.release();
  DIR* dir = fdopendir(fd);
  if (dir == nullptr) {
    close(fd);
  }
  return dir;
}

#endif  // !defined(_WIN32) && !defined(__TRUSTY__)

// A wrapper type that can be implicitly constructed from either int or
// unique_fd. This supports cases where you don't actually own the file
// descriptor, and can't take ownership, but are temporarily acting as if
// you're the owner.
//
// One example would be a function that needs to also allow
// STDERR_FILENO, not just a newly-opened fd. Another example would be JNI code
// that's using a file descriptor that's actually owned by a
// ParcelFileDescriptor or whatever on the Java side, but where the JNI code
// would like to enforce this weaker sense of "temporary ownership".
//
// If you think of unique_fd as being like std::string in that represents
// ownership, borrowed_fd is like std::string_view (and int is like const
// char*).
struct borrowed_fd {
  /* implicit */ borrowed_fd(int fd) : fd_(fd) {}  // NOLINT
  template <typename T>
  /* implicit */ borrowed_fd(const unique_fd_impl<T>& ufd) : fd_(ufd.get()) {}  // NOLINT

  int get() const { return fd_; }

  bool operator>=(int rhs) const { return get() >= rhs; }
  bool operator<(int rhs) const { return get() < rhs; }
  bool operator==(int rhs) const { return get() == rhs; }
  bool operator!=(int rhs) const { return get() != rhs; }

 private:
  int fd_ = -1;
};
}  // namespace base
}  // namespace android

template <typename T>
int close(const android::base::unique_fd_impl<T>&)
    __attribute__((__unavailable__("close called on unique_fd")));

template <typename T>
FILE* fdopen(const android::base::unique_fd_impl<T>&, const char* mode)
    __attribute__((__unavailable__("fdopen takes ownership of the fd passed in; either dup the "
                                   "unique_fd, or use android::base::Fdopen to pass ownership")));

template <typename T>
DIR* fdopendir(const android::base::unique_fd_impl<T>&) __attribute__((
    __unavailable__("fdopendir takes ownership of the fd passed in; either dup the "
                    "unique_fd, or use android::base::Fdopendir to pass ownership")));

```

`app/src/main/cpp/external/AOSP/include/binder/Binder.h`:

```h
/*
 * Copyright (C) 2008 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#pragma once

#include <atomic>
#include <stdint.h>
#include <binder/Common.h>
#include <binder/IBinder.h>

// ---------------------------------------------------------------------------
namespace android {

namespace internal {
class Stability;
}

class BBinder : public IBinder {
public:
    LIBBINDER_EXPORTED BBinder();

    LIBBINDER_EXPORTED virtual const String16& getInterfaceDescriptor() const;
    LIBBINDER_EXPORTED virtual bool isBinderAlive() const;
    LIBBINDER_EXPORTED virtual status_t pingBinder();
    LIBBINDER_EXPORTED virtual status_t dump(int fd, const Vector<String16>& args);

    // NOLINTNEXTLINE(google-default-arguments)
    LIBBINDER_EXPORTED virtual status_t transact(uint32_t code, const Parcel& data, Parcel* reply,
                                                 uint32_t flags = 0) final;

    // NOLINTNEXTLINE(google-default-arguments)
    LIBBINDER_EXPORTED virtual status_t linkToDeath(const sp<DeathRecipient>& recipient,
                                                    void* cookie = nullptr, uint32_t flags = 0);

    // NOLINTNEXTLINE(google-default-arguments)
    LIBBINDER_EXPORTED virtual status_t unlinkToDeath(const wp<DeathRecipient>& recipient,
                                                      void* cookie = nullptr, uint32_t flags = 0,
                                                      wp<DeathRecipient>* outRecipient = nullptr);

    LIBBINDER_EXPORTED virtual void* attachObject(const void* objectID, void* object,
                                                  void* cleanupCookie,
                                                  object_cleanup_func func) final;
    LIBBINDER_EXPORTED virtual void* findObject(const void* objectID) const final;
    LIBBINDER_EXPORTED virtual void* detachObject(const void* objectID) final;
    LIBBINDER_EXPORTED void withLock(const std::function<void()>& doWithLock);
    LIBBINDER_EXPORTED sp<IBinder> lookupOrCreateWeak(const void* objectID,
                                                      IBinder::object_make_func make,
                                                      const void* makeArgs);

    LIBBINDER_EXPORTED virtual BBinder* localBinder();

    LIBBINDER_EXPORTED bool isRequestingSid();
    // This must be called before the object is sent to another process. Not thread safe.
    LIBBINDER_EXPORTED void setRequestingSid(bool requestSid);

    LIBBINDER_EXPORTED sp<IBinder> getExtension();
    // This must be called before the object is sent to another process. Not thread safe.
    LIBBINDER_EXPORTED void setExtension(const sp<IBinder>& extension);

    // This must be called before the object is sent to another process. Not thread safe.
    //
    // This function will abort if improper parameters are set. This is like
    // sched_setscheduler. However, it sets the minimum scheduling policy
    // only for the duration that this specific binder object is handling the
    // call in a threadpool. By default, this API is set to SCHED_NORMAL/0. In
    // this case, the scheduling priority will not actually be modified from
    // binder defaults. See also IPCThreadState::disableBackgroundScheduling.
    //
    // Appropriate values are:
    // SCHED_NORMAL: -20 <= priority <= 19
    // SCHED_RR/SCHED_FIFO: 1 <= priority <= 99
    LIBBINDER_EXPORTED void setMinSchedulerPolicy(int policy, int priority);
    LIBBINDER_EXPORTED int getMinSchedulerPolicy();
    LIBBINDER_EXPORTED int getMinSchedulerPriority();

    // Whether realtime scheduling policies are inherited.
    LIBBINDER_EXPORTED bool isInheritRt();
    // This must be called before the object is sent to another process. Not thread safe.
    LIBBINDER_EXPORTED void setInheritRt(bool inheritRt);

    LIBBINDER_EXPORTED pid_t getDebugPid();

    // Whether this binder has been sent to another process.
    LIBBINDER_EXPORTED bool wasParceled();
    // Consider this binder as parceled (setup/init-related calls should no
    // longer by called. This is automatically set by when this binder is sent
    // to another process.
    LIBBINDER_EXPORTED void setParceled();

    [[nodiscard]] LIBBINDER_EXPORTED status_t setRpcClientDebug(binder::unique_fd clientFd,
                                                                const sp<IBinder>& keepAliveBinder);

protected:
    LIBBINDER_EXPORTED virtual ~BBinder();

    // NOLINTNEXTLINE(google-default-arguments)
    LIBBINDER_EXPORTED virtual status_t onTransact(uint32_t code, const Parcel& data, Parcel* reply,
                                                   uint32_t flags = 0);

private:
                        BBinder(const BBinder& o);
            BBinder&    operator=(const BBinder& o);

    class RpcServerLink;
    class Extras;

    Extras*             getOrCreateExtras();

    [[nodiscard]] status_t setRpcClientDebug(const Parcel& data);
    void removeRpcServerLink(const sp<RpcServerLink>& link);
    [[nodiscard]] status_t startRecordingTransactions(const Parcel& data);
    [[nodiscard]] status_t stopRecordingTransactions();

    std::atomic<Extras*> mExtras;

    friend ::android::internal::Stability;
    int16_t mStability;
    bool mParceled;
    bool mRecordingOn;

#ifdef __LP64__
    int32_t mReserved1;
#endif
};

// ---------------------------------------------------------------------------

class BpRefBase : public virtual RefBase {
protected:
    LIBBINDER_EXPORTED explicit BpRefBase(const sp<IBinder>& o);
    LIBBINDER_EXPORTED virtual ~BpRefBase();
    LIBBINDER_EXPORTED virtual void onFirstRef();
    LIBBINDER_EXPORTED virtual void onLastStrongRef(const void* id);
    LIBBINDER_EXPORTED virtual bool onIncStrongAttempted(uint32_t flags, const void* id);

    LIBBINDER_EXPORTED inline IBinder* remote() const { return mRemote; }
    LIBBINDER_EXPORTED inline sp<IBinder> remoteStrong() const {
        return sp<IBinder>::fromExisting(mRemote);
    }

private:
                            BpRefBase(const BpRefBase& o);
    BpRefBase&              operator=(const BpRefBase& o);

    IBinder* const          mRemote;
    RefBase::weakref_type*  mRefs;
    std::atomic<int32_t>    mState;
};

} // namespace android

// ---------------------------------------------------------------------------

```

`app/src/main/cpp/external/AOSP/include/binder/BpBinder.h`:

```h
/*
 * Copyright (C) 2005 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#pragma once

#include <binder/Common.h>
#include <binder/IBinder.h>
#include <binder/RpcThreads.h>
#include <binder/unique_fd.h>

#include <map>
#include <optional>
#include <unordered_map>
#include <variant>

// ---------------------------------------------------------------------------
namespace android {

class IPCThreadState;
class RpcSession;
class RpcState;
namespace internal {
class Stability;
}
class ProcessState;

using binder_proxy_limit_callback = std::function<void(int)>;
using binder_proxy_warning_callback = std::function<void(int)>;

class BpBinder : public IBinder {
public:
    /**
     * Return value:
     * true - this is associated with a socket RpcSession
     * false - (usual) binder over e.g. /dev/binder
     */
    LIBBINDER_EXPORTED bool isRpcBinder() const;

    LIBBINDER_EXPORTED virtual const String16& getInterfaceDescriptor() const;
    LIBBINDER_EXPORTED virtual bool isBinderAlive() const;
    LIBBINDER_EXPORTED virtual status_t pingBinder();
    LIBBINDER_EXPORTED virtual status_t dump(int fd, const Vector<String16>& args);

    // NOLINTNEXTLINE(google-default-arguments)
    LIBBINDER_EXPORTED virtual status_t transact(uint32_t code, const Parcel& data, Parcel* reply,
                                                 uint32_t flags = 0) final;

    // NOLINTNEXTLINE(google-default-arguments)
    LIBBINDER_EXPORTED virtual status_t linkToDeath(const sp<DeathRecipient>& recipient,
                                                    void* cookie = nullptr, uint32_t flags = 0);

    // NOLINTNEXTLINE(google-default-arguments)
    LIBBINDER_EXPORTED virtual status_t unlinkToDeath(const wp<DeathRecipient>& recipient,
                                                      void* cookie = nullptr, uint32_t flags = 0,
                                                      wp<DeathRecipient>* outRecipient = nullptr);

    [[nodiscard]] status_t addFrozenStateChangeCallback(
            const wp<FrozenStateChangeCallback>& recipient);

    [[nodiscard]] status_t removeFrozenStateChangeCallback(
            const wp<FrozenStateChangeCallback>& recipient);

    LIBBINDER_EXPORTED virtual void* attachObject(const void* objectID, void* object,
                                                  void* cleanupCookie,
                                                  object_cleanup_func func) final;
    LIBBINDER_EXPORTED virtual void* findObject(const void* objectID) const final;
    LIBBINDER_EXPORTED virtual void* detachObject(const void* objectID) final;
    LIBBINDER_EXPORTED void withLock(const std::function<void()>& doWithLock);
    LIBBINDER_EXPORTED sp<IBinder> lookupOrCreateWeak(const void* objectID,
                                                      IBinder::object_make_func make,
                                                      const void* makeArgs);
    LIBBINDER_EXPORTED virtual BpBinder* remoteBinder();

    LIBBINDER_EXPORTED void sendObituary();

    LIBBINDER_EXPORTED static uint32_t getBinderProxyCount(uint32_t uid);
    LIBBINDER_EXPORTED static void getCountByUid(Vector<uint32_t>& uids, Vector<uint32_t>& counts);
    LIBBINDER_EXPORTED static void enableCountByUid();
    LIBBINDER_EXPORTED static void disableCountByUid();
    LIBBINDER_EXPORTED static void setCountByUidEnabled(bool enable);
    LIBBINDER_EXPORTED static void setBinderProxyCountEventCallback(
            binder_proxy_limit_callback cbl, binder_proxy_warning_callback cbw);
    LIBBINDER_EXPORTED static void setBinderProxyCountWatermarks(int high, int low, int warning);
    LIBBINDER_EXPORTED static uint32_t getBinderProxyCount();

    LIBBINDER_EXPORTED std::optional<int32_t> getDebugBinderHandle() const;

    // Start recording transactions to the unique_fd.
    // See RecordedTransaction.h for more details.
    LIBBINDER_EXPORTED status_t startRecordingBinder(const binder::unique_fd& fd);
    // Stop the current recording.
    LIBBINDER_EXPORTED status_t stopRecordingBinder();

    // Note: This class is not thread safe so protect uses of it when necessary
    class ObjectManager {
    public:
        ObjectManager();
        ~ObjectManager();

        void* attach(const void* objectID, void* object, void* cleanupCookie,
                     IBinder::object_cleanup_func func);
        void* find(const void* objectID) const;
        void* detach(const void* objectID);
        sp<IBinder> lookupOrCreateWeak(const void* objectID, IBinder::object_make_func make,
                                       const void* makeArgs);

    private:
        ObjectManager(const ObjectManager&);
        ObjectManager& operator=(const ObjectManager&);

        struct entry_t {
            void* object = nullptr;
            void* cleanupCookie = nullptr;
            IBinder::object_cleanup_func func = nullptr;
        };

        std::map<const void*, entry_t> mObjects;
    };

    class PrivateAccessor {
    private:
        friend class BpBinder;
        friend class ::android::Parcel;
        friend class ::android::ProcessState;
        friend class ::android::RpcSession;
        friend class ::android::RpcState;
        friend class ::android::IPCThreadState;
        explicit PrivateAccessor(const BpBinder* binder)
              : mBinder(binder), mMutableBinder(nullptr) {}
        explicit PrivateAccessor(BpBinder* binder) : mBinder(binder), mMutableBinder(binder) {}

        static sp<BpBinder> create(int32_t handle, std::function<void()>* postTask) {
            return BpBinder::create(handle, postTask);
        }
        static sp<BpBinder> create(const sp<RpcSession>& session, uint64_t address) {
            return BpBinder::create(session, address);
        }

        // valid if !isRpcBinder
        int32_t binderHandle() const { return mBinder->binderHandle(); }

        // valid if isRpcBinder
        uint64_t rpcAddress() const { return mBinder->rpcAddress(); }
        const sp<RpcSession>& rpcSession() const { return mBinder->rpcSession(); }

        void onFrozenStateChanged(bool isFrozen) { mMutableBinder->onFrozenStateChanged(isFrozen); }
        const BpBinder* mBinder;
        BpBinder* mMutableBinder;
    };

    LIBBINDER_EXPORTED const PrivateAccessor getPrivateAccessor() const {
        return PrivateAccessor(this);
    }

    PrivateAccessor getPrivateAccessor() { return PrivateAccessor(this); }

private:
    friend PrivateAccessor;
    friend class sp<BpBinder>;

    static sp<BpBinder> create(int32_t handle, std::function<void()>* postTask);
    static sp<BpBinder> create(const sp<RpcSession>& session, uint64_t address);

    struct BinderHandle {
        int32_t handle;
    };
    struct RpcHandle {
        sp<RpcSession> session;
        uint64_t address;
    };
    using Handle = std::variant<BinderHandle, RpcHandle>;

    int32_t binderHandle() const;
    uint64_t rpcAddress() const;
    const sp<RpcSession>& rpcSession() const;

    explicit BpBinder(Handle&& handle);
    BpBinder(BinderHandle&& handle, int32_t trackedUid);
    explicit BpBinder(RpcHandle&& handle);

    virtual ~BpBinder();
    virtual void onFirstRef();
    virtual void onLastStrongRef(const void* id);
    virtual bool onIncStrongAttempted(uint32_t flags, const void* id);

    friend ::android::internal::Stability;

    int32_t mStability;
    Handle mHandle;

    struct Obituary {
        wp<DeathRecipient> recipient;
        void* cookie;
        uint32_t flags;
    };

    void onFrozenStateChanged(bool isFrozen);

    struct FrozenStateChange {
        bool isFrozen = false;
        Vector<wp<FrozenStateChangeCallback>> callbacks;
        bool initialStateReceived = false;
    };

    void reportOneDeath(const Obituary& obit);
    bool isDescriptorCached() const;

    mutable RpcMutex mLock;
    volatile int32_t mAlive;
    volatile int32_t mObitsSent;
    Vector<Obituary>* mObituaries;
    std::unique_ptr<FrozenStateChange> mFrozen;
    ObjectManager mObjectMgr;
    mutable String16 mDescriptorCache;
    int32_t mTrackedUid;

    static RpcMutex sTrackingLock;
    static std::unordered_map<int32_t, uint32_t> sTrackingMap;
    static int sNumTrackedUids;
    static std::atomic_bool sCountByUidEnabled;
    static binder_proxy_limit_callback sLimitCallback;
    static uint32_t sBinderProxyCountHighWatermark;
    static uint32_t sBinderProxyCountLowWatermark;
    static bool sBinderProxyThrottleCreate;
    static std::unordered_map<int32_t, uint32_t> sLastLimitCallbackMap;
    static std::atomic<uint32_t> sBinderProxyCount;
    static std::atomic<uint32_t> sBinderProxyCountWarned;
    static binder_proxy_warning_callback sWarningCallback;
    static uint32_t sBinderProxyCountWarningWatermark;
};

} // namespace android

// ---------------------------------------------------------------------------

```

`app/src/main/cpp/external/AOSP/include/binder/Common.h`:

```h
/*
 * Copyright (C) 2024 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#pragma once

// libbinder is built with symbol hidden by default. To add a new symbol to the
// ABI, you must annotate it with this LIBBINDER_EXPORTED macro. When not
// building libbinder (e.g. when another binary includes a libbinder header),
// this macro is a no-op.
//
// Examples:
//
//     // Export a function.
//     LIBBINDER_EXPORTED void someFunction();
//
//     // Export a subset of the symbols for a class.
//     class SomeClassA {
//       public:
//         LIBBINDER_EXPORTED SomeClassA();
//
//         LIBBINDER_EXPORTED SomeMethod();
//     }
//
//     // Export all the symbols for a class, even private symbols.
//     class LIBBINDER_EXPORTED SomeClassB {};
//
// For a more detailed explanation of this strategy, see
// https://www.gnu.org/software/gnulib/manual/html_node/Exported-Symbols-of-Shared-Libraries.html

#define LIBBINDER_EXPORTED __attribute__((__visibility__("default")))

// For stuff that is exported but probably shouldn't be. It behaves the exact
// same way as LIBBINDER_EXPORTED, only exists to help track what we want
// eventually remove.
//
// Needed, at least in part, because the test binaries are using internal
// headers and accessing these symbols directly.
#define LIBBINDER_INTERNAL_EXPORTED LIBBINDER_EXPORTED

```

`app/src/main/cpp/external/AOSP/include/binder/IBinder.h`:

```h
/*
 * Copyright (C) 2008 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#pragma once

#include <binder/Common.h>
#include <binder/unique_fd.h>
#include <utils/Errors.h>
#include <utils/RefBase.h>
#include <utils/String16.h>
#include <utils/Vector.h>

#include <functional>

// linux/binder.h defines this, but we don't want to include it here in order to
// avoid exporting the kernel headers
#ifndef B_PACK_CHARS
#define B_PACK_CHARS(c1, c2, c3, c4) \
    ((((c1)<<24)) | (((c2)<<16)) | (((c3)<<8)) | (c4))
#endif  // B_PACK_CHARS

// ---------------------------------------------------------------------------
namespace android {

class BBinder;
class BpBinder;
class IInterface;
class Parcel;
class IResultReceiver;
class IShellCallback;

/**
 * Base class and low-level protocol for a remotable object.
 * You can derive from this class to create an object for which other
 * processes can hold references to it.  Communication between processes
 * (method calls, property get and set) is down through a low-level
 * protocol implemented on top of the transact() API.
 */
class [[clang::lto_visibility_public]] LIBBINDER_EXPORTED IBinder : public virtual RefBase {
public:
    enum {
        FIRST_CALL_TRANSACTION = 0x00000001,
        LAST_CALL_TRANSACTION = 0x00ffffff,

        PING_TRANSACTION = B_PACK_CHARS('_', 'P', 'N', 'G'),
        START_RECORDING_TRANSACTION = B_PACK_CHARS('_', 'S', 'R', 'D'),
        STOP_RECORDING_TRANSACTION = B_PACK_CHARS('_', 'E', 'R', 'D'),
        DUMP_TRANSACTION = B_PACK_CHARS('_', 'D', 'M', 'P'),
        SHELL_COMMAND_TRANSACTION = B_PACK_CHARS('_', 'C', 'M', 'D'),
        INTERFACE_TRANSACTION = B_PACK_CHARS('_', 'N', 'T', 'F'),
        SYSPROPS_TRANSACTION = B_PACK_CHARS('_', 'S', 'P', 'R'),
        EXTENSION_TRANSACTION = B_PACK_CHARS('_', 'E', 'X', 'T'),
        DEBUG_PID_TRANSACTION = B_PACK_CHARS('_', 'P', 'I', 'D'),
        SET_RPC_CLIENT_TRANSACTION = B_PACK_CHARS('_', 'R', 'P', 'C'),

        // See android.os.IBinder.TWEET_TRANSACTION
        // Most importantly, messages can be anything not exceeding 130 UTF-8
        // characters, and callees should exclaim "jolly good message old boy!"
        TWEET_TRANSACTION = B_PACK_CHARS('_', 'T', 'W', 'T'),

        // See android.os.IBinder.LIKE_TRANSACTION
        // Improve binder self-esteem.
        LIKE_TRANSACTION = B_PACK_CHARS('_', 'L', 'I', 'K'),

        // Corresponds to TF_ONE_WAY -- an asynchronous call.
        FLAG_ONEWAY = 0x00000001,

        // Corresponds to TF_CLEAR_BUF -- clear transaction buffers after call
        // is made
        FLAG_CLEAR_BUF = 0x00000020,

        // Private userspace flag for transaction which is being requested from
        // a vendor context.
        FLAG_PRIVATE_VENDOR = 0x10000000,
    };

    IBinder();

    /**
     * Check if this IBinder implements the interface named by
     * @a descriptor.  If it does, the base pointer to it is returned,
     * which you can safely static_cast<> to the concrete C++ interface.
     */
    virtual sp<IInterface>  queryLocalInterface(const String16& descriptor);

    /**
     * Return the canonical name of the interface provided by this IBinder
     * object.
     */
    virtual const String16& getInterfaceDescriptor() const = 0;

    /**
     * Last known alive status, from last call. May be arbitrarily stale.
     * May be incorrect if a service returns an incorrect status code.
     */
    virtual bool            isBinderAlive() const = 0;
    virtual status_t        pingBinder() = 0;
    virtual status_t        dump(int fd, const Vector<String16>& args) = 0;
    static  status_t        shellCommand(const sp<IBinder>& target, int in, int out, int err,
                                         Vector<String16>& args, const sp<IShellCallback>& callback,
                                         const sp<IResultReceiver>& resultReceiver);

    /**
     * This allows someone to add their own additions to an interface without
     * having to modify the original interface.
     *
     * For instance, imagine if we have this interface:
     *     interface IFoo { void doFoo(); }
     *
     * If an unrelated owner (perhaps in a downstream codebase) wants to make a
     * change to the interface, they have two options:
     *
     * A). Historical option that has proven to be BAD! Only the original
     *     author of an interface should change an interface. If someone
     *     downstream wants additional functionality, they should not ever
     *     change the interface or use this method.
     *
     *    BAD TO DO:  interface IFoo {                       BAD TO DO
     *    BAD TO DO:      void doFoo();                      BAD TO DO
     *    BAD TO DO: +    void doBar(); // adding a method   BAD TO DO
     *    BAD TO DO:  }                                      BAD TO DO
     *
     * B). Option that this method enables!
     *     Leave the original interface unchanged (do not change IFoo!).
     *     Instead, create a new interface in a downstream package:
     *
     *         package com.<name>; // new functionality in a new package
     *         interface IBar { void doBar(); }
     *
     *     When registering the interface, add:
     *         sp<MyFoo> foo = new MyFoo; // class in AOSP codebase
     *         sp<MyBar> bar = new MyBar; // custom extension class
     *         foo->setExtension(bar);    // use method in BBinder
     *
     *     Then, clients of IFoo can get this extension:
     *         sp<IBinder> binder = ...;
     *         sp<IFoo> foo = interface_cast<IFoo>(binder); // handle if null
     *         sp<IBinder> barBinder;
     *         ... handle error ... = binder->getExtension(&barBinder);
     *         sp<IBar> bar = interface_cast<IBar>(barBinder);
     *         // if bar is null, then there is no extension or a different
     *         // type of extension
     */
    status_t                getExtension(sp<IBinder>* out);

    /**
     * Dump PID for a binder, for debugging.
     */
    status_t                getDebugPid(pid_t* outPid);

    /**
     * Set the RPC client fd to this binder service, for debugging. This is only available on
     * debuggable builds.
     *
     * When this is called on a binder service, the service:
     * 1. sets up RPC server
     * 2. spawns 1 new thread that calls RpcServer::join()
     *    - join() spawns some number of threads that accept() connections; see RpcServer
     *
     * setRpcClientDebug() may be called multiple times. Each call will add a new RpcServer
     * and opens up a TCP port.
     *
     * Note: A thread is spawned for each accept()'ed fd, which may call into functions of the
     * interface freely. See RpcServer::join(). To avoid such race conditions, implement the service
     * functions with multithreading support.
     *
     * On death of @a keepAliveBinder, the RpcServer shuts down.
     */
    [[nodiscard]] status_t setRpcClientDebug(binder::unique_fd socketFd,
                                             const sp<IBinder>& keepAliveBinder);

    // NOLINTNEXTLINE(google-default-arguments)
    virtual status_t        transact(   uint32_t code,
                                        const Parcel& data,
                                        Parcel* reply,
                                        uint32_t flags = 0) = 0;

    // DeathRecipient is pure abstract, there is no virtual method
    // implementation to put in a translation unit in order to silence the
    // weak vtables warning.
    #if defined(__clang__)
    #pragma clang diagnostic push
    #pragma clang diagnostic ignored "-Wweak-vtables"
    #endif

    class DeathRecipient : public virtual RefBase
    {
    public:
        virtual void binderDied(const wp<IBinder>& who) = 0;
    };

    class FrozenStateChangeCallback : public virtual RefBase {
    public:
        enum class State {
            FROZEN,
            UNFROZEN,
        };
        virtual void onStateChanged(const wp<IBinder>& who, State state) = 0;
    };

#if defined(__clang__)
#pragma clang diagnostic pop
#endif

    /**
     * Register the @a recipient for a notification if this binder
     * goes away.  If this binder object unexpectedly goes away
     * (typically because its hosting process has been killed),
     * then DeathRecipient::binderDied() will be called with a reference
     * to this.
     *
     * The @a cookie is optional -- if non-NULL, it should be a
     * memory address that you own (that is, you know it is unique).
     *
     * @note When all references to the binder being linked to are dropped, the
     * recipient is automatically unlinked. So, you must hold onto a binder in
     * order to receive death notifications about it.
     *
     * @note You will only receive death notifications for remote binders,
     * as local binders by definition can't die without you dying as well.
     * Trying to use this function on a local binder will result in an
     * INVALID_OPERATION code being returned and nothing happening.
     *
     * @note This link always holds a weak reference to its recipient.
     *
     * @note You will only receive a weak reference to the dead
     * binder.  You should not try to promote this to a strong reference.
     * (Nor should you need to, as there is nothing useful you can
     * directly do with it now that it has passed on.)
     */
    // NOLINTNEXTLINE(google-default-arguments)
    virtual status_t        linkToDeath(const sp<DeathRecipient>& recipient,
                                        void* cookie = nullptr,
                                        uint32_t flags = 0) = 0;

    /**
     * Remove a previously registered death notification.
     * The @a recipient will no longer be called if this object
     * dies.  The @a cookie is optional.  If non-NULL, you can
     * supply a NULL @a recipient, and the recipient previously
     * added with that cookie will be unlinked.
     *
     * If the binder is dead, this will return DEAD_OBJECT. Deleting
     * the object will also unlink all death recipients.
     */
    // NOLINTNEXTLINE(google-default-arguments)
    virtual status_t        unlinkToDeath(  const wp<DeathRecipient>& recipient,
                                            void* cookie = nullptr,
                                            uint32_t flags = 0,
                                            wp<DeathRecipient>* outRecipient = nullptr) = 0;

    /**
     * addFrozenStateChangeCallback provides a callback mechanism to notify
     * about process frozen/unfrozen events. Upon registration and any
     * subsequent state changes, the callback is invoked with the latest process
     * frozen state.
     *
     * If the listener process (the one using this API) is itself frozen, state
     * change events might be combined into a single one with the latest state.
     * (meaning 'frozen, unfrozen' might just be 'unfrozen'). This single event
     * would then be delivered when the listener process becomes unfrozen.
     * Similarly, if an event happens before the previous event is consumed,
     * they might be combined. This means the callback might not be called for
     * every single state change, so don't rely on this API to count how many
     * times the state has changed.
     *
     * @note When all references to the binder are dropped, the callback is
     * automatically removed. So, you must hold onto a binder in order to
     * receive notifications about it.
     *
     * @note You will only receive freeze notifications for remote binders, as
     * local binders by definition can't be frozen without you being frozen as
     * well. Trying to use this function on a local binder will result in an
     * INVALID_OPERATION code being returned and nothing happening.
     *
     * @note This binder always holds a weak reference to the callback.
     *
     * @note You will only receive a weak reference to the binder object. You
     * should not try to promote this to a strong reference. (Nor should you
     * need to, as there is nothing useful you can directly do with it now that
     * it has passed on.)
     */
    [[nodiscard]] status_t addFrozenStateChangeCallback(
            const wp<FrozenStateChangeCallback>& callback);

    /**
     * Remove a previously registered freeze callback.
     * The @a callback will no longer be called if this object
     * changes its frozen state.
     */
    [[nodiscard]] status_t removeFrozenStateChangeCallback(
            const wp<FrozenStateChangeCallback>& callback);

    virtual bool            checkSubclass(const void* subclassID) const;

    typedef void (*object_cleanup_func)(const void* id, void* obj, void* cleanupCookie);

    /**
     * This object is attached for the lifetime of this binder object. When
     * this binder object is destructed, the cleanup function of all attached
     * objects are invoked with their respective objectID, object, and
     * cleanupCookie. Access to these APIs can be made from multiple threads,
     * but calls from different threads are allowed to be interleaved.
     *
     * This returns the object which is already attached. If this returns a
     * non-null value, it means that attachObject failed (a given objectID can
     * only be used once).
     */
    [[nodiscard]] virtual void* attachObject(const void* objectID, void* object,
                                             void* cleanupCookie, object_cleanup_func func) = 0;
    /**
     * Returns object attached with attachObject.
     */
    [[nodiscard]] virtual void* findObject(const void* objectID) const = 0;
    /**
     * Returns object attached with attachObject, and detaches it. This does not
     * delete the object.
     */
    [[nodiscard]] virtual void* detachObject(const void* objectID) = 0;

    /**
     * Use the lock that this binder contains internally. For instance, this can
     * be used to modify an attached object without needing to add an additional
     * lock (though, that attached object must be retrieved before calling this
     * method). Calling (most) IBinder methods inside this will deadlock.
     */
    void withLock(const std::function<void()>& doWithLock);

    virtual BBinder*        localBinder();
    virtual BpBinder*       remoteBinder();
    typedef sp<IBinder> (*object_make_func)(const void* makeArgs);
    sp<IBinder> lookupOrCreateWeak(const void* objectID, object_make_func make,
                                   const void* makeArgs);

protected:
    virtual          ~IBinder();

private:
};

} // namespace android

// ---------------------------------------------------------------------------

```

`app/src/main/cpp/external/AOSP/include/binder/IInterface.h`:

```h
/*
 * Copyright (C) 2005 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#pragma once

#include <binder/Binder.h>
#include <binder/Common.h>

#include <assert.h>

namespace android {

// ----------------------------------------------------------------------

class LIBBINDER_EXPORTED IInterface : public virtual RefBase {
public:
            IInterface();
            static sp<IBinder>  asBinder(const IInterface*);
            static sp<IBinder>  asBinder(const sp<IInterface>&);

protected:
    virtual                     ~IInterface();
    virtual IBinder*            onAsBinder() = 0;
};

// ----------------------------------------------------------------------

/**
 * If this is a local object and the descriptor matches, this will return the
 * actual local object which is implementing the interface. Otherwise, this will
 * return a proxy to the interface without checking the interface descriptor.
 * This means that subsequent calls may fail with BAD_TYPE.
 */
template<typename INTERFACE>
inline sp<INTERFACE> interface_cast(const sp<IBinder>& obj)
{
    return INTERFACE::asInterface(obj);
}

/**
 * This is the same as interface_cast, except that it always checks to make sure
 * the descriptor matches, and if it doesn't match, it will return nullptr.
 */
template<typename INTERFACE>
inline sp<INTERFACE> checked_interface_cast(const sp<IBinder>& obj)
{
    if (obj->getInterfaceDescriptor() != INTERFACE::descriptor) {
        return nullptr;
    }

    return interface_cast<INTERFACE>(obj);
}

// ----------------------------------------------------------------------

template <typename INTERFACE>
class LIBBINDER_EXPORTED BnInterface : public INTERFACE, public BBinder {
public:
    virtual sp<IInterface>      queryLocalInterface(const String16& _descriptor);
    virtual const String16&     getInterfaceDescriptor() const;
    typedef INTERFACE BaseInterface;

protected:
    virtual IBinder*            onAsBinder();
};

// ----------------------------------------------------------------------

template <typename INTERFACE>
class LIBBINDER_EXPORTED BpInterface : public INTERFACE, public BpRefBase {
public:
    explicit                    BpInterface(const sp<IBinder>& remote);
    typedef INTERFACE BaseInterface;

protected:
    virtual IBinder*            onAsBinder();
};

// ----------------------------------------------------------------------

#define DECLARE_META_INTERFACE(INTERFACE)                                                         \
public:                                                                                           \
    static const ::android::String16 descriptor;                                                  \
    static ::android::sp<I##INTERFACE> asInterface(const ::android::sp<::android::IBinder>& obj); \
    virtual const ::android::String16& getInterfaceDescriptor() const;                            \
    I##INTERFACE();                                                                               \
    virtual ~I##INTERFACE();                                                                      \
    static bool setDefaultImpl(::android::sp<I##INTERFACE> impl);                                 \
    static const ::android::sp<I##INTERFACE>& getDefaultImpl();                                   \
                                                                                                  \
private:                                                                                          \
    static ::android::sp<I##INTERFACE> default_impl;                                              \
                                                                                                  \
public:

#define __IINTF_CONCAT(x, y) (x ## y)

#ifndef DO_NOT_CHECK_MANUAL_BINDER_INTERFACES

#define IMPLEMENT_META_INTERFACE(INTERFACE, NAME)                       \
    static_assert(internal::allowedManualInterface(NAME),               \
                  "b/64223827: Manually written binder interfaces are " \
                  "considered error prone and frequently have bugs. "   \
                  "The preferred way to add interfaces is to define "   \
                  "an .aidl file to auto-generate the interface. If "   \
                  "an interface must be manually written, add its "     \
                  "name to the allowlist.");                            \
    DO_NOT_DIRECTLY_USE_ME_IMPLEMENT_META_INTERFACE(INTERFACE, NAME)

#else

#define IMPLEMENT_META_INTERFACE(INTERFACE, NAME)                       \
    DO_NOT_DIRECTLY_USE_ME_IMPLEMENT_META_INTERFACE(INTERFACE, NAME)    \

#endif

// Macro to be used by both IMPLEMENT_META_INTERFACE and IMPLEMENT_META_NESTED_INTERFACE
#define DO_NOT_DIRECTLY_USE_ME_IMPLEMENT_META_INTERFACE0(ITYPE, INAME, BPTYPE)                     \
    const ::android::String16& ITYPE::getInterfaceDescriptor() const { return ITYPE::descriptor; } \
    ::android::sp<ITYPE> ITYPE::asInterface(const ::android::sp<::android::IBinder>& obj) {        \
        ::android::sp<ITYPE> intr;                                                                 \
        if (obj != nullptr) {                                                                      \
            intr = ::android::sp<ITYPE>::cast(obj->queryLocalInterface(ITYPE::descriptor));        \
            if (intr == nullptr) {                                                                 \
                intr = ::android::sp<BPTYPE>::make(obj);                                           \
            }                                                                                      \
        }                                                                                          \
        return intr;                                                                               \
    }                                                                                              \
    ::android::sp<ITYPE> ITYPE::default_impl;                                                      \
    bool ITYPE::setDefaultImpl(::android::sp<ITYPE> impl) {                                        \
        /* Only one user of this interface can use this function     */                            \
        /* at a time. This is a heuristic to detect if two different */                            \
        /* users in the same process use this function.              */                            \
        assert(!ITYPE::default_impl);                                                              \
        if (impl) {                                                                                \
            ITYPE::default_impl = std::move(impl);                                                 \
            return true;                                                                           \
        }                                                                                          \
        return false;                                                                              \
    }                                                                                              \
    const ::android::sp<ITYPE>& ITYPE::getDefaultImpl() { return ITYPE::default_impl; }            \
    ITYPE::INAME() {}                                                                              \
    ITYPE::~INAME() {}

// Macro for an interface type.
#define DO_NOT_DIRECTLY_USE_ME_IMPLEMENT_META_INTERFACE(INTERFACE, NAME)                        \
    const ::android::StaticString16 I##INTERFACE##_descriptor_static_str16(                     \
            __IINTF_CONCAT(u, NAME));                                                           \
    const ::android::String16 I##INTERFACE::descriptor(I##INTERFACE##_descriptor_static_str16); \
    DO_NOT_DIRECTLY_USE_ME_IMPLEMENT_META_INTERFACE0(I##INTERFACE, I##INTERFACE, Bp##INTERFACE)

// Macro for "nested" interface type.
// For example,
//   class Parent .. { class INested .. { }; };
// DO_NOT_DIRECTLY_USE_ME_IMPLEMENT_META_NESTED_INTERFACE(Parent, Nested, "Parent.INested")
#define DO_NOT_DIRECTLY_USE_ME_IMPLEMENT_META_NESTED_INTERFACE(PARENT, INTERFACE, NAME)  \
    const ::android::String16 PARENT::I##INTERFACE::descriptor(NAME);                    \
    DO_NOT_DIRECTLY_USE_ME_IMPLEMENT_META_INTERFACE0(PARENT::I##INTERFACE, I##INTERFACE, \
                                                     PARENT::Bp##INTERFACE)

#define CHECK_INTERFACE(interface, data, reply)                         \
    do {                                                                \
      if (!(data).checkInterface(this)) { return PERMISSION_DENIED; }   \
    } while (false)                                                     \


// ----------------------------------------------------------------------
// No user-serviceable parts after this...

template<typename INTERFACE>
inline sp<IInterface> BnInterface<INTERFACE>::queryLocalInterface(
        const String16& _descriptor)
{
    if (_descriptor == INTERFACE::descriptor) return sp<IInterface>::fromExisting(this);
    return nullptr;
}

template<typename INTERFACE>
inline const String16& BnInterface<INTERFACE>::getInterfaceDescriptor() const
{
    return INTERFACE::getInterfaceDescriptor();
}

template<typename INTERFACE>
IBinder* BnInterface<INTERFACE>::onAsBinder()
{
    return this;
}

template<typename INTERFACE>
inline BpInterface<INTERFACE>::BpInterface(const sp<IBinder>& remote)
    : BpRefBase(remote)
{
}

template<typename INTERFACE>
inline IBinder* BpInterface<INTERFACE>::onAsBinder()
{
    return remote();
}

// ----------------------------------------------------------------------

namespace internal {
constexpr const char* const kManualInterfaces[] = {
        "android.app.IActivityManager",
        "android.app.IUidObserver",
        "android.gfx.tests.ICallback",
        "android.gfx.tests.IIPCTest",
        "android.gfx.tests.ISafeInterfaceTest",
        "android.graphicsenv.IGpuService",
        "android.gui.IConsumerListener",
        "android.gui.IGraphicBufferConsumer",
        "android.gui.ITransactionComposerListener",
        "android.gui.SensorEventConnection",
        "android.gui.SensorServer",
        "android.hardware.ICamera",
        "android.hardware.ICameraClient",
        "android.hardware.ICameraRecordingProxy",
        "android.hardware.ICameraRecordingProxyListener",
        "android.hardware.IOMXObserver",
        "android.hardware.IStreamListener",
        "android.hardware.IStreamSource",
        "android.media.IAudioService",
        "android.media.IDataSource",
        "android.media.IMediaCodecList",
        "android.media.IMediaExtractor",
        "android.media.IMediaHTTPConnection",
        "android.media.IMediaHTTPService",
        "android.media.IMediaLogService",
        "android.media.IMediaMetadataRetriever",
        "android.media.IMediaPlayer",
        "android.media.IMediaPlayerClient",
        "android.media.IMediaPlayerService",
        "android.media.IMediaRecorder",
        "android.media.IMediaRecorderClient",
        "android.media.IMediaResourceMonitor",
        "android.media.IMediaSource",
        "android.media.IRemoteDisplay",
        "android.media.IRemoteDisplayClient",
        "android.os.IPermissionController",
        "android.os.IProcessInfoService",
        "android.os.ISchedulingPolicyService",
        "android.os.storage.IObbActionListener",
        "android.os.storage.IStorageEventListener",
        "android.os.storage.IStorageManager",
        "android.os.storage.IStorageShutdownObserver",
        "android.ui.ISurfaceComposer",
        "android.utils.IMemory",
        "android.utils.IMemoryHeap",
        "com.android.car.procfsinspector.IProcfsInspector",
        "com.android.internal.app.IAppOpsService",
        "com.android.internal.app.IBatteryStats",
        "com.android.internal.os.IResultReceiver",
        "com.android.internal.os.IShellCallback",
        "drm.IDrmManagerService",
        "drm.IDrmServiceListener",
        nullptr,
};

constexpr const char* const kDownstreamManualInterfaces[] = {
  // Add downstream interfaces here.
  nullptr,
};

constexpr bool equals(const char* a, const char* b) {
  if (*a != *b) return false;
  if (*a == '\0') return true;
  return equals(a + 1, b + 1);
}

constexpr bool inList(const char* a, const char* const* allowlist) {
  if (*allowlist == nullptr) return false;
  if (equals(a, *allowlist)) return true;
  return inList(a, allowlist + 1);
}

constexpr bool allowedManualInterface(const char* name) {
  return inList(name, kManualInterfaces) ||
         inList(name, kDownstreamManualInterfaces);
}

} // namespace internal
} // namespace android

```

`app/src/main/cpp/external/AOSP/include/binder/IPCThreadState.h`:

```h
/*
 * Copyright (C) 2005 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#pragma once

#include <binder/Common.h>
#include <binder/Parcel.h>
#include <binder/ProcessState.h>
#include <utils/Errors.h>
#include <utils/Vector.h>

#if defined(_WIN32)
typedef  int  uid_t;
#endif

// ---------------------------------------------------------------------------
namespace android {

/**
 * Kernel binder thread state. All operations here refer to kernel binder. This
 * object is allocated per-thread.
 */
class IPCThreadState {
public:
    using CallRestriction = ProcessState::CallRestriction;

    LIBBINDER_EXPORTED static IPCThreadState* self();
    LIBBINDER_EXPORTED static IPCThreadState* selfOrNull(); // self(), but won't instantiate

    // Freeze or unfreeze the binder interface to a specific process. When freezing, this method
    // will block up to timeout_ms to process pending transactions directed to pid. Unfreeze
    // is immediate. Transactions to processes frozen via this method won't be delivered and the
    // driver will return BR_FROZEN_REPLY to the client sending them. After unfreeze,
    // transactions will be delivered normally.
    //
    // pid: id for the process for which the binder interface is to be frozen
    // enable: freeze (true) or unfreeze (false)
    // timeout_ms: maximum time this function is allowed to block the caller waiting for pending
    // binder transactions to be processed.
    //
    // returns: 0 in case of success, a value < 0 in case of error
    LIBBINDER_EXPORTED static status_t freeze(pid_t pid, bool enabled, uint32_t timeout_ms);

    // Provide information about the state of a frozen process
    LIBBINDER_EXPORTED static status_t getProcessFreezeInfo(pid_t pid, uint32_t* sync_received,
                                                            uint32_t* async_received);

    LIBBINDER_EXPORTED status_t clearLastError();

    /**
     * Returns the PID of the process which has made the current binder
     * call. If not in a binder call, this will return getpid.
     *
     * Warning do not use this as a security identifier! PID is unreliable
     * as it may be re-used. This should mostly be used for debugging.
     *
     * oneway transactions do not receive PID. Even if you expect
     * a transaction to be synchronous, a misbehaving client could send it
     * as an asynchronous call and result in a 0 PID here. Additionally, if
     * there is a race and the calling process dies, the PID may still be
     * 0 for a synchronous call.
     */
    [[nodiscard]] LIBBINDER_EXPORTED pid_t getCallingPid() const;

    /**
     * Returns the SELinux security identifier of the process which has
     * made the current binder call. If not in a binder call this will
     * return nullptr. If this isn't requested with
     * Binder::setRequestingSid, it will also return nullptr.
     *
     * This can't be restored once it's cleared, and it does not return the
     * context of the current process when not in a binder call.
     */
    [[nodiscard]] LIBBINDER_EXPORTED const char* getCallingSid() const;

    /**
     * Returns the UID of the process which has made the current binder
     * call. If not in a binder call, this will return 0.
     */
    [[nodiscard]] LIBBINDER_EXPORTED uid_t getCallingUid() const;

    /**
     * Make it an abort to rely on getCalling* for a section of
     * execution.
     *
     * Usage:
     *     IPCThreadState::SpGuard guard {
     *        .address = __builtin_frame_address(0),
     *        .context = "...",
     *     };
     *     const auto* orig = pushGetCallingSpGuard(&guard);
     *     {
     *         // will abort if you call getCalling*, unless you are
     *         // serving a nested binder transaction
     *     }
     *     restoreCallingSpGuard(orig);
     */
    struct SpGuard {
        const void* address;
        const char* context;
    };
    LIBBINDER_EXPORTED const SpGuard* pushGetCallingSpGuard(const SpGuard* guard);
    LIBBINDER_EXPORTED void restoreGetCallingSpGuard(const SpGuard* guard);
    /**
     * Used internally by getCalling*. Can also be used to assert that
     * you are in a binder context (getCalling* is valid). This is
     * intentionally not exposed as a boolean API since code should be
     * written to know its environment.
     */
    LIBBINDER_EXPORTED void checkContextIsBinderForUse(const char* use) const;

    LIBBINDER_EXPORTED void setStrictModePolicy(int32_t policy);
    LIBBINDER_EXPORTED int32_t getStrictModePolicy() const;

    // See Binder#setCallingWorkSourceUid in Binder.java.
    LIBBINDER_EXPORTED int64_t setCallingWorkSourceUid(uid_t uid);
    // Internal only. Use setCallingWorkSourceUid(uid) instead.
    LIBBINDER_EXPORTED int64_t setCallingWorkSourceUidWithoutPropagation(uid_t uid);
    // See Binder#getCallingWorkSourceUid in Binder.java.
    LIBBINDER_EXPORTED uid_t getCallingWorkSourceUid() const;
    // See Binder#clearCallingWorkSource in Binder.java.
    LIBBINDER_EXPORTED int64_t clearCallingWorkSource();
    // See Binder#restoreCallingWorkSource in Binder.java.
    LIBBINDER_EXPORTED void restoreCallingWorkSource(int64_t token);
    LIBBINDER_EXPORTED void clearPropagateWorkSource();
    LIBBINDER_EXPORTED bool shouldPropagateWorkSource() const;

    LIBBINDER_EXPORTED void setLastTransactionBinderFlags(int32_t flags);
    LIBBINDER_EXPORTED int32_t getLastTransactionBinderFlags() const;

    LIBBINDER_EXPORTED void setCallRestriction(CallRestriction restriction);
    LIBBINDER_EXPORTED CallRestriction getCallRestriction() const;

    LIBBINDER_EXPORTED int64_t clearCallingIdentity();
    // Restores PID/UID (not SID)
    LIBBINDER_EXPORTED void restoreCallingIdentity(int64_t token);
    LIBBINDER_EXPORTED bool hasExplicitIdentity();

    // For main functions - dangerous for libraries to use
    LIBBINDER_EXPORTED status_t setupPolling(int* fd);
    LIBBINDER_EXPORTED status_t handlePolledCommands();
    LIBBINDER_EXPORTED void flushCommands();
    LIBBINDER_EXPORTED bool flushIfNeeded();

    // Adds the current thread into the binder threadpool.
    //
    // This is in addition to any threads which are started
    // with startThreadPool. Libraries should not call this
    // function, as they may be loaded into processes which
    // try to configure the threadpool differently.
    LIBBINDER_EXPORTED void joinThreadPool(bool isMain = true);

    // Stop the local process.
    LIBBINDER_EXPORTED void stopProcess(bool immediate = true);

    LIBBINDER_EXPORTED status_t transact(int32_t handle, uint32_t code, const Parcel& data,
                                         Parcel* reply, uint32_t flags);

    LIBBINDER_EXPORTED void incStrongHandle(int32_t handle, BpBinder* proxy);
    LIBBINDER_EXPORTED void decStrongHandle(int32_t handle);
    LIBBINDER_EXPORTED void incWeakHandle(int32_t handle, BpBinder* proxy);
    LIBBINDER_EXPORTED void decWeakHandle(int32_t handle);
    LIBBINDER_EXPORTED status_t attemptIncStrongHandle(int32_t handle);
    LIBBINDER_EXPORTED static void expungeHandle(int32_t handle, IBinder* binder);
    LIBBINDER_EXPORTED status_t requestDeathNotification(int32_t handle, BpBinder* proxy);
    LIBBINDER_EXPORTED status_t clearDeathNotification(int32_t handle, BpBinder* proxy);
    [[nodiscard]] status_t addFrozenStateChangeCallback(int32_t handle, BpBinder* proxy);
    [[nodiscard]] status_t removeFrozenStateChangeCallback(int32_t handle, BpBinder* proxy);

    LIBBINDER_EXPORTED static void shutdown();

    // Call this to disable switching threads to background scheduling when
    // receiving incoming IPC calls.  This is specifically here for the
    // Android system process, since it expects to have background apps calling
    // in to it but doesn't want to acquire locks in its services while in
    // the background.
    LIBBINDER_EXPORTED static void disableBackgroundScheduling(bool disable);
    LIBBINDER_EXPORTED bool backgroundSchedulingDisabled();

    // Call blocks until the number of executing binder threads is less than
    // the maximum number of binder threads threads allowed for this process.
    LIBBINDER_EXPORTED void blockUntilThreadAvailable();

    // Service manager registration
    LIBBINDER_EXPORTED void setTheContextObject(const sp<BBinder>& obj);

    // WARNING: DO NOT USE THIS API
    //
    // Returns a pointer to the stack from the last time a transaction
    // was initiated by the kernel. Used to compare when making nested
    // calls between multiple different transports.
    LIBBINDER_EXPORTED const void* getServingStackPointer() const;

    // The work source represents the UID of the process we should attribute the transaction
    // to. We use -1 to specify that the work source was not set using #setWorkSource.
    //
    // This constant needs to be kept in sync with Binder.UNSET_WORKSOURCE from the Java
    // side.
    LIBBINDER_EXPORTED static const int32_t kUnsetWorkSource = -1;

private:
    IPCThreadState();
    ~IPCThreadState();

    [[nodiscard]] status_t sendReply(const Parcel& reply, uint32_t flags);
    [[nodiscard]] status_t waitForResponse(Parcel* reply, status_t* acquireResult = nullptr);
    [[nodiscard]] status_t talkWithDriver(bool doReceive = true);
    [[nodiscard]] status_t writeTransactionData(int32_t cmd, uint32_t binderFlags, int32_t handle,
                                                uint32_t code, const Parcel& data,
                                                status_t* statusBuffer);
    [[nodiscard]] status_t getAndExecuteCommand();
    [[nodiscard]] status_t executeCommand(int32_t command);
    void processPendingDerefs();
    void processPostWriteDerefs();

    void clearCaller();

    static  void                threadDestructor(void *st);
    static void freeBuffer(const uint8_t* data, size_t dataSize, const binder_size_t* objects,
                           size_t objectsSize);
    static  void                logExtendedError();

    const   sp<ProcessState>    mProcess;
            Vector<BBinder*>    mPendingStrongDerefs;
            Vector<RefBase::weakref_type*> mPendingWeakDerefs;
            Vector<RefBase*>    mPostWriteStrongDerefs;
            Vector<RefBase::weakref_type*> mPostWriteWeakDerefs;
            Parcel              mIn;
            Parcel              mOut;
            status_t            mLastError;
            const void*         mServingStackPointer;
            const SpGuard* mServingStackPointerGuard;
            pid_t               mCallingPid;
            const char*         mCallingSid;
            uid_t               mCallingUid;
            // The UID of the process who is responsible for this transaction.
            // This is used for resource attribution.
            int32_t             mWorkSource;
            // Whether the work source should be propagated.
            bool                mPropagateWorkSource;
            bool                mIsLooper;
            bool mIsFlushing;
            bool mHasExplicitIdentity;
            int32_t             mStrictModePolicy;
            int32_t             mLastTransactionBinderFlags;
            CallRestriction     mCallRestriction;
};

} // namespace android

// ---------------------------------------------------------------------------

```

`app/src/main/cpp/external/AOSP/include/binder/IServiceManager.h`:

```h
/*
 * Copyright (C) 2005 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#pragma once
#include <binder/Common.h>
#include <binder/IInterface.h>
// Trusty has its own definition of socket APIs from trusty_ipc.h
#ifndef __TRUSTY__
#include <sys/socket.h>
#endif // __TRUSTY__
#include <utils/String16.h>
#include <utils/Vector.h>
#include <optional>
#include <set>

namespace android {

/**
 * Service manager for C++ services.
 *
 * IInterface is only for legacy ABI compatibility
 */
class LIBBINDER_EXPORTED IServiceManager : public IInterface {
public:
    // for ABI compatibility
    virtual const String16& getInterfaceDescriptor() const;

    IServiceManager();
    virtual ~IServiceManager();

    /**
     * Must match values in IServiceManager.aidl
     */
    /* Allows services to dump sections according to priorities. */
    static const int DUMP_FLAG_PRIORITY_CRITICAL = 1 << 0;
    static const int DUMP_FLAG_PRIORITY_HIGH = 1 << 1;
    static const int DUMP_FLAG_PRIORITY_NORMAL = 1 << 2;
    /**
     * Services are by default registered with a DEFAULT dump priority. DEFAULT priority has the
     * same priority as NORMAL priority but the services are not called with dump priority
     * arguments.
     */
    static const int DUMP_FLAG_PRIORITY_DEFAULT = 1 << 3;
    static const int DUMP_FLAG_PRIORITY_ALL = DUMP_FLAG_PRIORITY_CRITICAL |
            DUMP_FLAG_PRIORITY_HIGH | DUMP_FLAG_PRIORITY_NORMAL | DUMP_FLAG_PRIORITY_DEFAULT;
    static const int DUMP_FLAG_PROTO = 1 << 4;

    /**
     * Retrieve an existing service, blocking for a few seconds if it doesn't yet exist. This
     * does polling. A more efficient way to make sure you unblock as soon as the service is
     * available is to use waitForService or to use service notifications.
     *
     * Warning: when using this API, typically, you should call it in a loop. It's dangerous to
     * assume that nullptr could mean that the service is not available. The service could just
     * be starting. Generally, whether a service exists, this information should be declared
     * externally (for instance, an Android feature might imply the existence of a service,
     * a system property, or in the case of services in the VINTF manifest, it can be checked
     * with isDeclared).
     */
    [[deprecated("this polls for 5s, prefer waitForService or checkService")]]
    virtual sp<IBinder> getService(const String16& name) const = 0;

    /**
     * Retrieve an existing service, non-blocking.
     */
    virtual sp<IBinder>         checkService( const String16& name) const = 0;

    /**
     * Register a service.
     *
     * Note:
     * This status_t return value may be an exception code from an underlying
     * Status type that doesn't have a representive error code in
     * utils/Errors.h.
     * One example of this is a return value of -7
     * (Status::Exception::EX_UNSUPPORTED_OPERATION) when the service manager
     * process is not installed on the device when addService is called.
     */
    // NOLINTNEXTLINE(google-default-arguments)
    virtual status_t addService(const String16& name, const sp<IBinder>& service,
                                bool allowIsolated = false,
                                int dumpsysFlags = DUMP_FLAG_PRIORITY_DEFAULT) = 0;

    /**
     * Return list of all existing services.
     */
    // NOLINTNEXTLINE(google-default-arguments)
    virtual Vector<String16> listServices(int dumpsysFlags = DUMP_FLAG_PRIORITY_ALL) = 0;

    /**
     * Efficiently wait for a service.
     *
     * Returns nullptr only for permission problem or fatal error.
     */
    virtual sp<IBinder> waitForService(const String16& name) = 0;

    /**
     * Check if a service is declared (e.g. VINTF manifest).
     *
     * If this returns true, waitForService should always be able to return the
     * service.
     */
    virtual bool isDeclared(const String16& name) = 0;

    /**
     * Get all instances of a service as declared in the VINTF manifest
     */
    virtual Vector<String16> getDeclaredInstances(const String16& interface) = 0;

    /**
     * If this instance is updatable via an APEX, returns the APEX with which
     * this can be updated.
     */
    virtual std::optional<String16> updatableViaApex(const String16& name) = 0;

    /**
     * Returns all instances which are updatable via the APEX. Instance names are fully qualified
     * like `pack.age.IFoo/default`.
     */
    virtual Vector<String16> getUpdatableNames(const String16& apexName) = 0;

    /**
     * If this instance has declared remote connection information, returns
     * the ConnectionInfo.
     */
    struct ConnectionInfo {
        std::string ipAddress;
        unsigned int port;
    };
    virtual std::optional<ConnectionInfo> getConnectionInfo(const String16& name) = 0;

    struct LocalRegistrationCallback : public virtual RefBase {
        virtual void onServiceRegistration(const String16& instance, const sp<IBinder>& binder) = 0;
        virtual ~LocalRegistrationCallback() {}
    };

    virtual status_t registerForNotifications(const String16& name,
                                              const sp<LocalRegistrationCallback>& callback) = 0;

    virtual status_t unregisterForNotifications(const String16& name,
                                                const sp<LocalRegistrationCallback>& callback) = 0;

    struct ServiceDebugInfo {
        std::string name;
        int pid;
    };
    virtual std::vector<ServiceDebugInfo> getServiceDebugInfo() = 0;

    /**
     * Directly enable or disable caching binder during addService calls.
     * Only used for testing. This is enabled by default.
     */
    virtual void enableAddServiceCache(bool value) = 0;
};

LIBBINDER_EXPORTED sp<IServiceManager> defaultServiceManager();

/**
 * Directly set the default service manager. Only used for testing.
 * Note that the caller is responsible for caling this method
 * *before* any call to defaultServiceManager(); if the latter is
 * called first, setDefaultServiceManager() will abort.
 */
LIBBINDER_EXPORTED void setDefaultServiceManager(const sp<IServiceManager>& sm);

template<typename INTERFACE>
sp<INTERFACE> waitForService(const String16& name) {
    const sp<IServiceManager> sm = defaultServiceManager();
    return interface_cast<INTERFACE>(sm->waitForService(name));
}

template<typename INTERFACE>
sp<INTERFACE> waitForDeclaredService(const String16& name) {
    const sp<IServiceManager> sm = defaultServiceManager();
    if (!sm->isDeclared(name)) return nullptr;
    return interface_cast<INTERFACE>(sm->waitForService(name));
}

template <typename INTERFACE>
sp<INTERFACE> checkDeclaredService(const String16& name) {
    const sp<IServiceManager> sm = defaultServiceManager();
    if (!sm->isDeclared(name)) return nullptr;
    return interface_cast<INTERFACE>(sm->checkService(name));
}

template<typename INTERFACE>
sp<INTERFACE> waitForVintfService(
        const String16& instance = String16("default")) {
    return waitForDeclaredService<INTERFACE>(
        INTERFACE::descriptor + String16("/") + instance);
}

template<typename INTERFACE>
sp<INTERFACE> checkVintfService(
        const String16& instance = String16("default")) {
    return checkDeclaredService<INTERFACE>(
        INTERFACE::descriptor + String16("/") + instance);
}

template<typename INTERFACE>
status_t getService(const String16& name, sp<INTERFACE>* outService)
{
    const sp<IServiceManager> sm = defaultServiceManager();
    if (sm != nullptr) {
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
        *outService = interface_cast<INTERFACE>(sm->getService(name));
#pragma clang diagnostic pop // getService deprecation
        if ((*outService) != nullptr) return NO_ERROR;
    }
    return NAME_NOT_FOUND;
}

LIBBINDER_EXPORTED void* openDeclaredPassthroughHal(const String16& interface,
                                                    const String16& instance, int flag);

LIBBINDER_EXPORTED bool checkCallingPermission(const String16& permission);
LIBBINDER_EXPORTED bool checkCallingPermission(const String16& permission, int32_t* outPid,
                                               int32_t* outUid);
LIBBINDER_EXPORTED bool checkPermission(const String16& permission, pid_t pid, uid_t uid,
                                        bool logPermissionFailure = true);

// ----------------------------------------------------------------------
// Trusty's definition of the socket APIs does not include sockaddr types
#ifndef __TRUSTY__
typedef std::function<status_t(const String16& name, sockaddr* outAddr, socklen_t addrSize)>
        RpcSocketAddressProvider;

/**
 * This callback provides a way for clients to get access to remote services by
 * providing an Accessor object from libbinder that can connect to the remote
 * service over sockets.
 *
 * \param instance name of the service that the callback will provide an
 *        Accessor for. The provided accessor will be used to set up a client
 *        RPC connection in libbinder in order to return a binder for the
 *        associated remote service.
 *
 * \return IBinder of the Accessor object that libbinder implements.
 *         nullptr if the provider callback doesn't know how to reach the
 *         service or doesn't want to provide access for any other reason.
 */
typedef std::function<sp<IBinder>(const String16& instance)> RpcAccessorProvider;

class AccessorProvider;

/**
 * Register a RpcAccessorProvider for the service manager APIs.
 *
 * \param instances that the RpcAccessorProvider knows about and can provide an
 *        Accessor for.
 * \param provider callback that generates Accessors.
 *
 * \return A pointer used as a recept for the successful addition of the
 *         AccessorProvider. This is needed to unregister it later.
 */
[[nodiscard]] LIBBINDER_EXPORTED std::weak_ptr<AccessorProvider> addAccessorProvider(
        std::set<std::string>&& instances, RpcAccessorProvider&& providerCallback);

/**
 * Remove an accessor provider using the pointer provided by addAccessorProvider
 * along with the cookie pointer that was used.
 *
 * \param provider cookie that was returned by addAccessorProvider to keep track
 *        of this instance.
 */
[[nodiscard]] LIBBINDER_EXPORTED status_t
removeAccessorProvider(std::weak_ptr<AccessorProvider> provider);

/**
 * Create an Accessor associated with a service that can create a socket connection based
 * on the connection info from the supplied RpcSocketAddressProvider.
 *
 * \param instance name of the service that this Accessor is associated with
 * \param connectionInfoProvider a callback that returns connection info for
 *        connecting to the service.
 * \return the binder of the IAccessor implementation from libbinder
 */
LIBBINDER_EXPORTED sp<IBinder> createAccessor(const String16& instance,
                                              RpcSocketAddressProvider&& connectionInfoProvider);

/**
 * Check to make sure this binder is the expected binder that is an IAccessor
 * associated with a specific instance.
 *
 * This helper function exists to avoid adding the IAccessor type to
 * libbinder_ndk.
 *
 * \param instance name of the service that this Accessor should be associated with
 * \param binder to validate
 *
 * \return OK if the binder is an IAccessor for `instance`
 */
LIBBINDER_EXPORTED status_t validateAccessor(const String16& instance, const sp<IBinder>& binder);

/**
 * Have libbinder wrap this IAccessor binder in an IAccessorDelegator and return
 * it.
 *
 * This is required only in very specific situations when the process that has
 * permissions to connect the to RPC service's socket and create the FD for it
 * is in a separate process from this process that wants to service the Accessor
 * binder and the communication between these two processes is binder RPC. This
 * is needed because the binder passed over the binder RPC connection can not be
 * used as a kernel binder, and needs to be wrapped by a kernel binder that can
 * then be registered with service manager.
 *
 * \param instance name of the Accessor.
 * \param binder to wrap in a Delegator and register with service manager.
 * \param outDelegator the wrapped kernel binder for IAccessorDelegator
 *
 * \return OK if the binder is an IAccessor for `instance` and the delegator was
 * successfully created.
 */
LIBBINDER_EXPORTED status_t delegateAccessor(const String16& name, const sp<IBinder>& accessor,
                                             sp<IBinder>* delegator);
#endif // __TRUSTY__

#ifndef __ANDROID__
// Create an IServiceManager that delegates the service manager on the device via adb.
// This is can be set as the default service manager at program start, so that
// defaultServiceManager() returns it:
//    int main() {
//        setDefaultServiceManager(createRpcDelegateServiceManager());
//        auto sm = defaultServiceManager();
//        // ...
//    }
// Resources are cleaned up when the object is destroyed.
//
// For each returned binder object, at most |maxOutgoingConnections| outgoing connections are
// instantiated, depending on how many the service on the device is configured with.
// Hence, only |maxOutgoingConnections| calls can be made simultaneously.
// See also RpcSession::setMaxOutgoingConnections.
struct RpcDelegateServiceManagerOptions {
    std::optional<size_t> maxOutgoingConnections;
};
LIBBINDER_EXPORTED sp<IServiceManager> createRpcDelegateServiceManager(
        const RpcDelegateServiceManagerOptions& options);
#endif

} // namespace android

```

`app/src/main/cpp/external/AOSP/include/binder/Parcel.h`:

```h
/*
 * Copyright (C) 2005 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#pragma once

#include <array>
#include <limits>
#include <map> // for legacy reasons
#include <optional>
#include <string>
#include <type_traits>
#include <variant>
#include <vector>

#include <binder/unique_fd.h>
#include <utils/Errors.h>
#include <utils/RefBase.h>
#include <utils/String16.h>
#include <utils/Vector.h>

#include <binder/Common.h>
#include <binder/IInterface.h>
#include <binder/Parcelable.h>

//NOLINTNEXTLINE(google-runtime-int) b/173188702
typedef unsigned long long binder_size_t;

struct flat_binder_object;

// ---------------------------------------------------------------------------
namespace android {

template <typename T> class Flattenable;
template <typename T> class LightFlattenable;
class IBinder;
class IPCThreadState;
class ProcessState;
class String8;
class TextOutput;
namespace binder {
class Status;
namespace debug {
class RecordedTransaction;
}
}

class Parcel {
    friend class IPCThreadState;

public:
    class ReadableBlob;
    class WritableBlob;

    LIBBINDER_EXPORTED Parcel();
    LIBBINDER_EXPORTED ~Parcel();

    LIBBINDER_EXPORTED const uint8_t* data() const;
    LIBBINDER_EXPORTED size_t dataSize() const;
    LIBBINDER_EXPORTED size_t dataAvail() const;
    LIBBINDER_EXPORTED size_t dataPosition() const;
    LIBBINDER_EXPORTED size_t dataCapacity() const;
    LIBBINDER_EXPORTED size_t dataBufferSize() const;

    LIBBINDER_EXPORTED status_t setDataSize(size_t size);

    // this must only be used to set a data position that was previously returned from
    // dataPosition(). If writes are made, the exact same types of writes must be made (e.g.
    // auto i = p.dataPosition(); p.writeInt32(0); p.setDataPosition(i); p.writeInt32(1);).
    // Writing over objects, such as file descriptors and binders, is not supported.
    LIBBINDER_EXPORTED void setDataPosition(size_t pos) const;
    LIBBINDER_EXPORTED status_t setDataCapacity(size_t size);

    LIBBINDER_EXPORTED status_t setData(const uint8_t* buffer, size_t len);

    LIBBINDER_EXPORTED status_t appendFrom(const Parcel* parcel, size_t start, size_t len);

    LIBBINDER_EXPORTED int compareData(const Parcel& other) const;
    LIBBINDER_EXPORTED status_t compareDataInRange(size_t thisOffset, const Parcel& other,
                                                   size_t otherOffset, size_t length,
                                                   int* result) const;

    LIBBINDER_EXPORTED bool allowFds() const;
    LIBBINDER_EXPORTED bool pushAllowFds(bool allowFds);
    LIBBINDER_EXPORTED void restoreAllowFds(bool lastValue);

    LIBBINDER_EXPORTED bool hasFileDescriptors() const;
    LIBBINDER_EXPORTED status_t hasBinders(bool* result) const;
    LIBBINDER_EXPORTED status_t hasFileDescriptorsInRange(size_t offset, size_t length,
                                                          bool* result) const;
    LIBBINDER_EXPORTED status_t hasBindersInRange(size_t offset, size_t length, bool* result) const;

    // returns all binder objects in the Parcel
    LIBBINDER_EXPORTED std::vector<sp<IBinder>> debugReadAllStrongBinders() const;
    // returns all file descriptors in the Parcel
    // does not dup
    LIBBINDER_EXPORTED std::vector<int> debugReadAllFileDescriptors() const;

    // Zeros data when reallocating. Other mitigations may be added
    // in the future.
    //
    // WARNING: some read methods may make additional copies of data.
    // In order to verify this, heap dumps should be used.
    LIBBINDER_EXPORTED void markSensitive() const;

    // For a 'data' Parcel, this should mark the Parcel as being prepared for a
    // transaction on this specific binder object. Based on this, the format of
    // the wire binder protocol may change (data is written differently when it
    // is for an RPC transaction).
    LIBBINDER_EXPORTED void markForBinder(const sp<IBinder>& binder);

    // Whether this Parcel is written for RPC transactions (after calls to
    // markForBinder or markForRpc).
    LIBBINDER_EXPORTED bool isForRpc() const;

    // Writes the IPC/RPC header.
    LIBBINDER_EXPORTED status_t writeInterfaceToken(const String16& interface);
    LIBBINDER_EXPORTED status_t writeInterfaceToken(const char16_t* str, size_t len);

    // Parses the RPC header, returning true if the interface name
    // in the header matches the expected interface from the caller.
    //
    // Additionally, enforceInterface does part of the work of
    // propagating the StrictMode policy mask, populating the current
    // IPCThreadState, which as an optimization may optionally be
    // passed in.
    LIBBINDER_EXPORTED bool enforceInterface(const String16& interface,
                                             IPCThreadState* threadState = nullptr) const;
    LIBBINDER_EXPORTED bool enforceInterface(const char16_t* interface, size_t len,
                                             IPCThreadState* threadState = nullptr) const;
    LIBBINDER_EXPORTED bool checkInterface(IBinder*) const;

    // Verify there are no bytes left to be read on the Parcel.
    // Returns Status(EX_BAD_PARCELABLE) when the Parcel is not consumed.
    LIBBINDER_EXPORTED binder::Status enforceNoDataAvail() const;

    // This Api is used by fuzzers to skip dataAvail checks.
    LIBBINDER_EXPORTED void setEnforceNoDataAvail(bool enforceNoDataAvail);

    // When fuzzing, we want to remove certain ABI checks that cause significant
    // lost coverage, and we also want to avoid logs that cost too much to write.
    LIBBINDER_EXPORTED void setServiceFuzzing();
    LIBBINDER_EXPORTED bool isServiceFuzzing() const;

    LIBBINDER_EXPORTED void freeData();

    LIBBINDER_EXPORTED size_t objectsCount() const;

    LIBBINDER_EXPORTED status_t errorCheck() const;
    LIBBINDER_EXPORTED void setError(status_t err);

    LIBBINDER_EXPORTED status_t write(const void* data, size_t len);
    LIBBINDER_EXPORTED void* writeInplace(size_t len);
    LIBBINDER_EXPORTED status_t writeInt32(int32_t val);
    LIBBINDER_EXPORTED status_t writeUint32(uint32_t val);
    LIBBINDER_EXPORTED status_t writeInt64(int64_t val);
    LIBBINDER_EXPORTED status_t writeUint64(uint64_t val);
    LIBBINDER_EXPORTED status_t writeFloat(float val);
    LIBBINDER_EXPORTED status_t writeDouble(double val);
    LIBBINDER_EXPORTED status_t writeCString(const char* str)
            __attribute__((deprecated("use AIDL, writeString* instead")));
    LIBBINDER_EXPORTED status_t writeString8(const String8& str);
    LIBBINDER_EXPORTED status_t writeString8(const char* str, size_t len);
    LIBBINDER_EXPORTED status_t writeString16(const String16& str);
    LIBBINDER_EXPORTED status_t writeString16(const std::optional<String16>& str);
    LIBBINDER_EXPORTED status_t writeString16(const std::unique_ptr<String16>& str)
            __attribute__((deprecated("use std::optional version instead")));
    LIBBINDER_EXPORTED status_t writeString16(const char16_t* str, size_t len);
    LIBBINDER_EXPORTED status_t writeStrongBinder(const sp<IBinder>& val);
    LIBBINDER_EXPORTED status_t writeInt32Array(size_t len, const int32_t* val);
    LIBBINDER_EXPORTED status_t writeByteArray(size_t len, const uint8_t* val);
    LIBBINDER_EXPORTED status_t writeBool(bool val);
    LIBBINDER_EXPORTED status_t writeChar(char16_t val);
    LIBBINDER_EXPORTED status_t writeByte(int8_t val);

    // Take a UTF8 encoded string, convert to UTF16, write it to the parcel.
    LIBBINDER_EXPORTED status_t writeUtf8AsUtf16(const std::string& str);
    LIBBINDER_EXPORTED status_t writeUtf8AsUtf16(const std::optional<std::string>& str);
    LIBBINDER_EXPORTED status_t writeUtf8AsUtf16(const std::unique_ptr<std::string>& str)
            __attribute__((deprecated("use std::optional version instead")));

    LIBBINDER_EXPORTED status_t writeByteVector(const std::optional<std::vector<int8_t>>& val);
    LIBBINDER_EXPORTED status_t writeByteVector(const std::unique_ptr<std::vector<int8_t>>& val)
            __attribute__((deprecated("use std::optional version instead")));
    LIBBINDER_EXPORTED status_t writeByteVector(const std::vector<int8_t>& val);
    LIBBINDER_EXPORTED status_t writeByteVector(const std::optional<std::vector<uint8_t>>& val);
    LIBBINDER_EXPORTED status_t writeByteVector(const std::unique_ptr<std::vector<uint8_t>>& val)
            __attribute__((deprecated("use std::optional version instead")));
    LIBBINDER_EXPORTED status_t writeByteVector(const std::vector<uint8_t>& val);
    LIBBINDER_EXPORTED status_t writeInt32Vector(const std::optional<std::vector<int32_t>>& val);
    LIBBINDER_EXPORTED status_t writeInt32Vector(const std::unique_ptr<std::vector<int32_t>>& val)
            __attribute__((deprecated("use std::optional version instead")));
    LIBBINDER_EXPORTED status_t writeInt32Vector(const std::vector<int32_t>& val);
    LIBBINDER_EXPORTED status_t writeInt64Vector(const std::optional<std::vector<int64_t>>& val);
    LIBBINDER_EXPORTED status_t writeInt64Vector(const std::unique_ptr<std::vector<int64_t>>& val)
            __attribute__((deprecated("use std::optional version instead")));
    LIBBINDER_EXPORTED status_t writeInt64Vector(const std::vector<int64_t>& val);
    LIBBINDER_EXPORTED status_t writeUint64Vector(const std::optional<std::vector<uint64_t>>& val);
    LIBBINDER_EXPORTED status_t writeUint64Vector(const std::unique_ptr<std::vector<uint64_t>>& val)
            __attribute__((deprecated("use std::optional version instead")));
    LIBBINDER_EXPORTED status_t writeUint64Vector(const std::vector<uint64_t>& val);
    LIBBINDER_EXPORTED status_t writeFloatVector(const std::optional<std::vector<float>>& val);
    LIBBINDER_EXPORTED status_t writeFloatVector(const std::unique_ptr<std::vector<float>>& val)
            __attribute__((deprecated("use std::optional version instead")));
    LIBBINDER_EXPORTED status_t writeFloatVector(const std::vector<float>& val);
    LIBBINDER_EXPORTED status_t writeDoubleVector(const std::optional<std::vector<double>>& val);
    LIBBINDER_EXPORTED status_t writeDoubleVector(const std::unique_ptr<std::vector<double>>& val)
            __attribute__((deprecated("use std::optional version instead")));
    LIBBINDER_EXPORTED status_t writeDoubleVector(const std::vector<double>& val);
    LIBBINDER_EXPORTED status_t writeBoolVector(const std::optional<std::vector<bool>>& val);
    LIBBINDER_EXPORTED status_t writeBoolVector(const std::unique_ptr<std::vector<bool>>& val)
            __attribute__((deprecated("use std::optional version instead")));
    LIBBINDER_EXPORTED status_t writeBoolVector(const std::vector<bool>& val);
    LIBBINDER_EXPORTED status_t writeCharVector(const std::optional<std::vector<char16_t>>& val);
    LIBBINDER_EXPORTED status_t writeCharVector(const std::unique_ptr<std::vector<char16_t>>& val)
            __attribute__((deprecated("use std::optional version instead")));
    LIBBINDER_EXPORTED status_t writeCharVector(const std::vector<char16_t>& val);
    LIBBINDER_EXPORTED status_t
    writeString16Vector(const std::optional<std::vector<std::optional<String16>>>& val);
    LIBBINDER_EXPORTED status_t
    writeString16Vector(const std::unique_ptr<std::vector<std::unique_ptr<String16>>>& val)
            __attribute__((deprecated("use std::optional version instead")));
    LIBBINDER_EXPORTED status_t writeString16Vector(const std::vector<String16>& val);
    LIBBINDER_EXPORTED status_t
    writeUtf8VectorAsUtf16Vector(const std::optional<std::vector<std::optional<std::string>>>& val);
    LIBBINDER_EXPORTED status_t writeUtf8VectorAsUtf16Vector(
            const std::unique_ptr<std::vector<std::unique_ptr<std::string>>>& val)
            __attribute__((deprecated("use std::optional version instead")));
    LIBBINDER_EXPORTED status_t writeUtf8VectorAsUtf16Vector(const std::vector<std::string>& val);

    LIBBINDER_EXPORTED status_t
    writeStrongBinderVector(const std::optional<std::vector<sp<IBinder>>>& val);
    LIBBINDER_EXPORTED status_t
    writeStrongBinderVector(const std::unique_ptr<std::vector<sp<IBinder>>>& val)
            __attribute__((deprecated("use std::optional version instead")));
    LIBBINDER_EXPORTED status_t writeStrongBinderVector(const std::vector<sp<IBinder>>& val);

    // Write an IInterface or a vector of IInterface's
    template <typename T,
              std::enable_if_t<std::is_base_of_v<::android::IInterface, T>, bool> = true>
    status_t writeStrongBinder(const sp<T>& val) {
        return writeStrongBinder(T::asBinder(val));
    }
    template <typename T,
              std::enable_if_t<std::is_base_of_v<::android::IInterface, T>, bool> = true>
    status_t writeStrongBinderVector(const std::vector<sp<T>>& val) {
        return writeData(val);
    }
    template <typename T,
              std::enable_if_t<std::is_base_of_v<::android::IInterface, T>, bool> = true>
    status_t writeStrongBinderVector(const std::optional<std::vector<sp<T>>>& val) {
        return writeData(val);
    }

    template <typename T, size_t N>
    status_t writeFixedArray(const std::array<T, N>& val) {
        return writeData(val);
    }
    template <typename T, size_t N>
    status_t writeFixedArray(const std::optional<std::array<T, N>>& val) {
        return writeData(val);
    }

    // Write an Enum vector with underlying type int8_t.
    // Does not use padding; each byte is contiguous.
    template<typename T, std::enable_if_t<std::is_enum_v<T> && std::is_same_v<typename std::underlying_type_t<T>,int8_t>, bool> = 0>
    status_t            writeEnumVector(const std::vector<T>& val)
            { return writeData(val); }
    template<typename T, std::enable_if_t<std::is_enum_v<T> && std::is_same_v<typename std::underlying_type_t<T>,int8_t>, bool> = 0>
    status_t            writeEnumVector(const std::optional<std::vector<T>>& val)
            { return writeData(val); }
    template<typename T, std::enable_if_t<std::is_enum_v<T> && std::is_same_v<typename std::underlying_type_t<T>,int8_t>, bool> = 0>
    [[deprecated("use std::optional version instead")]] //
    status_t            writeEnumVector(const std::unique_ptr<std::vector<T>>& val)
            { return writeData(val); }
    // Write an Enum vector with underlying type != int8_t.
    template<typename T, std::enable_if_t<std::is_enum_v<T> && !std::is_same_v<typename std::underlying_type_t<T>,int8_t>, bool> = 0>
    status_t            writeEnumVector(const std::vector<T>& val)
            { return writeData(val); }
    template<typename T, std::enable_if_t<std::is_enum_v<T> && !std::is_same_v<typename std::underlying_type_t<T>,int8_t>, bool> = 0>
    status_t            writeEnumVector(const std::optional<std::vector<T>>& val)
            { return writeData(val); }
    template<typename T, std::enable_if_t<std::is_enum_v<T> && !std::is_same_v<typename std::underlying_type_t<T>,int8_t>, bool> = 0>
    [[deprecated("use std::optional version instead")]] //
    status_t            writeEnumVector(const std::unique_ptr<std::vector<T>>& val)
            { return writeData(val); }

    template<typename T>
    status_t            writeParcelableVector(const std::optional<std::vector<std::optional<T>>>& val)
            { return writeData(val); }
    template<typename T>
    [[deprecated("use std::optional version instead")]] //
    status_t            writeParcelableVector(const std::unique_ptr<std::vector<std::unique_ptr<T>>>& val)
            { return writeData(val); }
    template<typename T>
    [[deprecated("use std::optional version instead")]] //
    status_t            writeParcelableVector(const std::shared_ptr<std::vector<std::unique_ptr<T>>>& val)
            { return writeData(val); }
    template<typename T>
    status_t            writeParcelableVector(const std::shared_ptr<std::vector<std::optional<T>>>& val)
            { return writeData(val); }
    template<typename T>
    status_t            writeParcelableVector(const std::vector<T>& val)
            { return writeData(val); }

    template<typename T>
    status_t            writeNullableParcelable(const std::optional<T>& parcelable)
            { return writeData(parcelable); }
    template <typename T>
    status_t writeNullableParcelable(const std::unique_ptr<T>& parcelable) {
        return writeData(parcelable);
    }

    LIBBINDER_EXPORTED status_t writeParcelable(const Parcelable& parcelable);

    template<typename T>
    status_t            write(const Flattenable<T>& val);

    template<typename T>
    status_t            write(const LightFlattenable<T>& val);

    template<typename T>
    status_t            writeVectorSize(const std::vector<T>& val);
    template<typename T>
    status_t            writeVectorSize(const std::optional<std::vector<T>>& val);
    template<typename T>
    status_t            writeVectorSize(const std::unique_ptr<std::vector<T>>& val) __attribute__((deprecated("use std::optional version instead")));

    // Place a file descriptor into the parcel.  The given fd must remain
    // valid for the lifetime of the parcel.
    // The Parcel does not take ownership of the given fd unless you ask it to.
    LIBBINDER_EXPORTED status_t writeFileDescriptor(int fd, bool takeOwnership = false);

    // Place a file descriptor into the parcel.  A dup of the fd is made, which
    // will be closed once the parcel is destroyed.
    LIBBINDER_EXPORTED status_t writeDupFileDescriptor(int fd);

    // Place a Java "parcel file descriptor" into the parcel.  The given fd must remain
    // valid for the lifetime of the parcel.
    // The Parcel does not take ownership of the given fd unless you ask it to.
    LIBBINDER_EXPORTED status_t writeParcelFileDescriptor(int fd, bool takeOwnership = false);

    // Place a Java "parcel file descriptor" into the parcel.  A dup of the fd is made, which will
    // be closed once the parcel is destroyed.
    LIBBINDER_EXPORTED status_t writeDupParcelFileDescriptor(int fd);

    // Place a file descriptor into the parcel.  This will not affect the
    // semantics of the smart file descriptor. A new descriptor will be
    // created, and will be closed when the parcel is destroyed.
    LIBBINDER_EXPORTED status_t writeUniqueFileDescriptor(const binder::unique_fd& fd);

    // Place a vector of file desciptors into the parcel. Each descriptor is
    // dup'd as in writeDupFileDescriptor
    LIBBINDER_EXPORTED status_t
    writeUniqueFileDescriptorVector(const std::optional<std::vector<binder::unique_fd>>& val);
    LIBBINDER_EXPORTED status_t
    writeUniqueFileDescriptorVector(const std::vector<binder::unique_fd>& val);

    // WARNING: deprecated and incompatible with AIDL. You should use Parcelable
    // definitions outside of Parcel to represent shared memory, such as
    // IMemory or with ParcelFileDescriptor. We should remove this, or move it to be
    // external to Parcel, it's not a very encapsulated API.
    //
    // Writes a blob to the parcel.
    // If the blob is small, then it is stored in-place, otherwise it is
    // transferred by way of an anonymous shared memory region.  Prefer sending
    // immutable blobs if possible since they may be subsequently transferred between
    // processes without further copying whereas mutable blobs always need to be copied.
    // The caller should call release() on the blob after writing its contents.
    LIBBINDER_EXPORTED status_t writeBlob(size_t len, bool mutableCopy, WritableBlob* outBlob);

    // Write an existing immutable blob file descriptor to the parcel.
    // This allows the client to send the same blob to multiple processes
    // as long as it keeps a dup of the blob file descriptor handy for later.
    LIBBINDER_EXPORTED status_t writeDupImmutableBlobFileDescriptor(int fd);

    // Like Parcel.java's writeNoException().  Just writes a zero int32.
    // Currently the native implementation doesn't do any of the StrictMode
    // stack gathering and serialization that the Java implementation does.
    LIBBINDER_EXPORTED status_t writeNoException();

    LIBBINDER_EXPORTED status_t read(void* outData, size_t len) const;
    LIBBINDER_EXPORTED const void* readInplace(size_t len) const;
    LIBBINDER_EXPORTED int32_t readInt32() const;
    LIBBINDER_EXPORTED status_t readInt32(int32_t* pArg) const;
    LIBBINDER_EXPORTED uint32_t readUint32() const;
    LIBBINDER_EXPORTED status_t readUint32(uint32_t* pArg) const;
    LIBBINDER_EXPORTED int64_t readInt64() const;
    LIBBINDER_EXPORTED status_t readInt64(int64_t* pArg) const;
    LIBBINDER_EXPORTED uint64_t readUint64() const;
    LIBBINDER_EXPORTED status_t readUint64(uint64_t* pArg) const;
    LIBBINDER_EXPORTED float readFloat() const;
    LIBBINDER_EXPORTED status_t readFloat(float* pArg) const;
    LIBBINDER_EXPORTED double readDouble() const;
    LIBBINDER_EXPORTED status_t readDouble(double* pArg) const;
    LIBBINDER_EXPORTED bool readBool() const;
    LIBBINDER_EXPORTED status_t readBool(bool* pArg) const;
    LIBBINDER_EXPORTED char16_t readChar() const;
    LIBBINDER_EXPORTED status_t readChar(char16_t* pArg) const;
    LIBBINDER_EXPORTED int8_t readByte() const;
    LIBBINDER_EXPORTED status_t readByte(int8_t* pArg) const;

    // Read a UTF16 encoded string, convert to UTF8
    LIBBINDER_EXPORTED status_t readUtf8FromUtf16(std::string* str) const;
    LIBBINDER_EXPORTED status_t readUtf8FromUtf16(std::optional<std::string>* str) const;
    LIBBINDER_EXPORTED status_t readUtf8FromUtf16(std::unique_ptr<std::string>* str) const
            __attribute__((deprecated("use std::optional version instead")));

    LIBBINDER_EXPORTED const char* readCString() const
            __attribute__((deprecated("use AIDL, use readString*")));
    LIBBINDER_EXPORTED String8 readString8() const;
    LIBBINDER_EXPORTED status_t readString8(String8* pArg) const;
    LIBBINDER_EXPORTED const char* readString8Inplace(size_t* outLen) const;
    LIBBINDER_EXPORTED String16 readString16() const;
    LIBBINDER_EXPORTED status_t readString16(String16* pArg) const;
    LIBBINDER_EXPORTED status_t readString16(std::optional<String16>* pArg) const;
    LIBBINDER_EXPORTED status_t readString16(std::unique_ptr<String16>* pArg) const
            __attribute__((deprecated("use std::optional version instead")));
    LIBBINDER_EXPORTED const char16_t* readString16Inplace(size_t* outLen) const;
    LIBBINDER_EXPORTED sp<IBinder> readStrongBinder() const;
    LIBBINDER_EXPORTED status_t readStrongBinder(sp<IBinder>* val) const;
    LIBBINDER_EXPORTED status_t readNullableStrongBinder(sp<IBinder>* val) const;

    // Read an Enum vector with underlying type int8_t.
    // Does not use padding; each byte is contiguous.
    template<typename T, std::enable_if_t<std::is_enum_v<T> && std::is_same_v<typename std::underlying_type_t<T>,int8_t>, bool> = 0>
    status_t            readEnumVector(std::vector<T>* val) const
            { return readData(val); }
    template<typename T, std::enable_if_t<std::is_enum_v<T> && std::is_same_v<typename std::underlying_type_t<T>,int8_t>, bool> = 0>
    [[deprecated("use std::optional version instead")]] //
    status_t            readEnumVector(std::unique_ptr<std::vector<T>>* val) const
            { return readData(val); }
    template<typename T, std::enable_if_t<std::is_enum_v<T> && std::is_same_v<typename std::underlying_type_t<T>,int8_t>, bool> = 0>
    status_t            readEnumVector(std::optional<std::vector<T>>* val) const
            { return readData(val); }
    // Read an Enum vector with underlying type != int8_t.
    template<typename T, std::enable_if_t<std::is_enum_v<T> && !std::is_same_v<typename std::underlying_type_t<T>,int8_t>, bool> = 0>
    status_t            readEnumVector(std::vector<T>* val) const
            { return readData(val); }
    template<typename T, std::enable_if_t<std::is_enum_v<T> && !std::is_same_v<typename std::underlying_type_t<T>,int8_t>, bool> = 0>
    [[deprecated("use std::optional version instead")]] //
    status_t            readEnumVector(std::unique_ptr<std::vector<T>>* val) const
            { return readData(val); }
    template<typename T, std::enable_if_t<std::is_enum_v<T> && !std::is_same_v<typename std::underlying_type_t<T>,int8_t>, bool> = 0>
    status_t            readEnumVector(std::optional<std::vector<T>>* val) const
            { return readData(val); }

    template<typename T>
    status_t            readParcelableVector(
                            std::optional<std::vector<std::optional<T>>>* val) const
            { return readData(val); }
    template<typename T>
    [[deprecated("use std::optional version instead")]] //
    status_t            readParcelableVector(
                            std::unique_ptr<std::vector<std::unique_ptr<T>>>* val) const
            { return readData(val); }
    template<typename T>
    status_t            readParcelableVector(std::vector<T>* val) const
            { return readData(val); }

    LIBBINDER_EXPORTED status_t readParcelable(Parcelable* parcelable) const;

    template<typename T>
    status_t            readParcelable(std::optional<T>* parcelable) const
            { return readData(parcelable); }
    template <typename T>
    status_t readParcelable(std::unique_ptr<T>* parcelable) const {
        return readData(parcelable);
    }

    // If strong binder would be nullptr, readStrongBinder() returns an error.
    // TODO: T must be derived from IInterface, fix for clarity.
    template<typename T>
    status_t            readStrongBinder(sp<T>* val) const;

    template<typename T>
    status_t            readNullableStrongBinder(sp<T>* val) const;

    LIBBINDER_EXPORTED status_t
    readStrongBinderVector(std::optional<std::vector<sp<IBinder>>>* val) const;
    LIBBINDER_EXPORTED status_t
    readStrongBinderVector(std::unique_ptr<std::vector<sp<IBinder>>>* val) const
            __attribute__((deprecated("use std::optional version instead")));
    LIBBINDER_EXPORTED status_t readStrongBinderVector(std::vector<sp<IBinder>>* val) const;
    template <typename T,
              std::enable_if_t<std::is_base_of_v<::android::IInterface, T>, bool> = true>
    status_t readStrongBinderVector(std::vector<sp<T>>* val) const {
        return readData(val);
    }
    template <typename T,
              std::enable_if_t<std::is_base_of_v<::android::IInterface, T>, bool> = true>
    status_t readStrongBinderVector(std::optional<std::vector<sp<T>>>* val) const {
        return readData(val);
    }

    LIBBINDER_EXPORTED status_t readByteVector(std::optional<std::vector<int8_t>>* val) const;
    LIBBINDER_EXPORTED status_t readByteVector(std::unique_ptr<std::vector<int8_t>>* val) const
            __attribute__((deprecated("use std::optional version instead")));
    LIBBINDER_EXPORTED status_t readByteVector(std::vector<int8_t>* val) const;
    LIBBINDER_EXPORTED status_t readByteVector(std::optional<std::vector<uint8_t>>* val) const;
    LIBBINDER_EXPORTED status_t readByteVector(std::unique_ptr<std::vector<uint8_t>>* val) const
            __attribute__((deprecated("use std::optional version instead")));
    LIBBINDER_EXPORTED status_t readByteVector(std::vector<uint8_t>* val) const;
    LIBBINDER_EXPORTED status_t readInt32Vector(std::optional<std::vector<int32_t>>* val) const;
    LIBBINDER_EXPORTED status_t readInt32Vector(std::unique_ptr<std::vector<int32_t>>* val) const
            __attribute__((deprecated("use std::optional version instead")));
    LIBBINDER_EXPORTED status_t readInt32Vector(std::vector<int32_t>* val) const;
    LIBBINDER_EXPORTED status_t readInt64Vector(std::optional<std::vector<int64_t>>* val) const;
    LIBBINDER_EXPORTED status_t readInt64Vector(std::unique_ptr<std::vector<int64_t>>* val) const
            __attribute__((deprecated("use std::optional version instead")));
    LIBBINDER_EXPORTED status_t readInt64Vector(std::vector<int64_t>* val) const;
    LIBBINDER_EXPORTED status_t readUint64Vector(std::optional<std::vector<uint64_t>>* val) const;
    LIBBINDER_EXPORTED status_t readUint64Vector(std::unique_ptr<std::vector<uint64_t>>* val) const
            __attribute__((deprecated("use std::optional version instead")));
    LIBBINDER_EXPORTED status_t readUint64Vector(std::vector<uint64_t>* val) const;
    LIBBINDER_EXPORTED status_t readFloatVector(std::optional<std::vector<float>>* val) const;
    LIBBINDER_EXPORTED status_t readFloatVector(std::unique_ptr<std::vector<float>>* val) const
            __attribute__((deprecated("use std::optional version instead")));
    LIBBINDER_EXPORTED status_t readFloatVector(std::vector<float>* val) const;
    LIBBINDER_EXPORTED status_t readDoubleVector(std::optional<std::vector<double>>* val) const;
    LIBBINDER_EXPORTED status_t readDoubleVector(std::unique_ptr<std::vector<double>>* val) const
            __attribute__((deprecated("use std::optional version instead")));
    LIBBINDER_EXPORTED status_t readDoubleVector(std::vector<double>* val) const;
    LIBBINDER_EXPORTED status_t readBoolVector(std::optional<std::vector<bool>>* val) const;
    LIBBINDER_EXPORTED status_t readBoolVector(std::unique_ptr<std::vector<bool>>* val) const
            __attribute__((deprecated("use std::optional version instead")));
    LIBBINDER_EXPORTED status_t readBoolVector(std::vector<bool>* val) const;
    LIBBINDER_EXPORTED status_t readCharVector(std::optional<std::vector<char16_t>>* val) const;
    LIBBINDER_EXPORTED status_t readCharVector(std::unique_ptr<std::vector<char16_t>>* val) const
            __attribute__((deprecated("use std::optional version instead")));
    LIBBINDER_EXPORTED status_t readCharVector(std::vector<char16_t>* val) const;
    LIBBINDER_EXPORTED status_t
    readString16Vector(std::optional<std::vector<std::optional<String16>>>* val) const;
    LIBBINDER_EXPORTED status_t
    readString16Vector(std::unique_ptr<std::vector<std::unique_ptr<String16>>>* val) const
            __attribute__((deprecated("use std::optional version instead")));
    LIBBINDER_EXPORTED status_t readString16Vector(std::vector<String16>* val) const;
    LIBBINDER_EXPORTED status_t readUtf8VectorFromUtf16Vector(
            std::optional<std::vector<std::optional<std::string>>>* val) const;
    LIBBINDER_EXPORTED status_t readUtf8VectorFromUtf16Vector(
            std::unique_ptr<std::vector<std::unique_ptr<std::string>>>* val) const
            __attribute__((deprecated("use std::optional version instead")));
    LIBBINDER_EXPORTED status_t readUtf8VectorFromUtf16Vector(std::vector<std::string>* val) const;

    template <typename T, size_t N>
    status_t readFixedArray(std::array<T, N>* val) const {
        return readData(val);
    }
    template <typename T, size_t N>
    status_t readFixedArray(std::optional<std::array<T, N>>* val) const {
        return readData(val);
    }

    template<typename T>
    status_t            read(Flattenable<T>& val) const;

    template<typename T>
    status_t            read(LightFlattenable<T>& val) const;

    // resizeOutVector is used to resize AIDL out vector parameters.
    template<typename T>
    status_t            resizeOutVector(std::vector<T>* val) const;
    template<typename T>
    status_t            resizeOutVector(std::optional<std::vector<T>>* val) const;
    template<typename T>
    status_t            resizeOutVector(std::unique_ptr<std::vector<T>>* val) const __attribute__((deprecated("use std::optional version instead")));

    // Like Parcel.java's readExceptionCode().  Reads the first int32
    // off of a Parcel's header, returning 0 or the negative error
    // code on exceptions, but also deals with skipping over rich
    // response headers.  Callers should use this to read & parse the
    // response headers rather than doing it by hand.
    LIBBINDER_EXPORTED int32_t readExceptionCode() const;

    // Retrieve a file descriptor from the parcel.  This returns the raw fd
    // in the parcel, which you do not own -- use dup() to get your own copy.
    LIBBINDER_EXPORTED int readFileDescriptor() const;

    // Retrieve a Java "parcel file descriptor" from the parcel.  This returns the raw fd
    // in the parcel, which you do not own -- use dup() to get your own copy.
    LIBBINDER_EXPORTED int readParcelFileDescriptor() const;

    // Retrieve a smart file descriptor from the parcel.
    LIBBINDER_EXPORTED status_t readUniqueFileDescriptor(binder::unique_fd* val) const;

    // Retrieve a Java "parcel file descriptor" from the parcel.
    LIBBINDER_EXPORTED status_t readUniqueParcelFileDescriptor(binder::unique_fd* val) const;

    // Retrieve a vector of smart file descriptors from the parcel.
    LIBBINDER_EXPORTED status_t
    readUniqueFileDescriptorVector(std::optional<std::vector<binder::unique_fd>>* val) const;
    LIBBINDER_EXPORTED status_t
    readUniqueFileDescriptorVector(std::vector<binder::unique_fd>* val) const;

    // WARNING: deprecated and incompatible with AIDL. You should use Parcelable
    // definitions outside of Parcel to represent shared memory, such as
    // IMemory or with ParcelFileDescriptor. We should remove this, or move it to be
    // external to Parcel, it's not a very encapsulated API.
    //
    // Reads a blob from the parcel.
    // The caller should call release() on the blob after reading its contents.
    LIBBINDER_EXPORTED status_t readBlob(size_t len, ReadableBlob* outBlob) const;

    LIBBINDER_EXPORTED const flat_binder_object* readObject(bool nullMetaData) const;

    // Debugging: get metrics on current allocations.
    LIBBINDER_EXPORTED static size_t getGlobalAllocSize();
    LIBBINDER_EXPORTED static size_t getGlobalAllocCount();

    LIBBINDER_EXPORTED bool replaceCallingWorkSourceUid(uid_t uid);
    // Returns the work source provided by the caller. This can only be trusted for trusted calling
    // uid.
    LIBBINDER_EXPORTED uid_t readCallingWorkSourceUid() const;

    LIBBINDER_EXPORTED void print(std::ostream& to, uint32_t flags = 0) const;

    // This API is to quickly become a view of another Parcel, so that we can also
    // test 'owner' paths quickly. It's extremely dangerous to use this API in
    // practice, and you should never ever do it.
    LIBBINDER_EXPORTED void makeDangerousViewOf(Parcel* p);

private:
    // Close all file descriptors in the parcel at object positions >= newObjectsSize.
    void closeFileDescriptors(size_t newObjectsSize);

    // `objects` and `objectsSize` always 0 for RPC Parcels.
    typedef void (*release_func)(const uint8_t* data, size_t dataSize, const binder_size_t* objects,
                                 size_t objectsSize);

    uintptr_t           ipcData() const;
    size_t              ipcDataSize() const;
    uintptr_t           ipcObjects() const;
    size_t              ipcObjectsCount() const;
    void ipcSetDataReference(const uint8_t* data, size_t dataSize, const binder_size_t* objects,
                             size_t objectsCount, release_func relFunc);

    status_t            finishWrite(size_t len);
    void                releaseObjects();
    void reacquireObjects(size_t objectSize);
    status_t            growData(size_t len);
    // Clear the Parcel and set the capacity to `desired`.
    // Doesn't reset the RPC session association.
    status_t            restartWrite(size_t desired);
    // Set the capacity to `desired`, truncating the Parcel if necessary.
    status_t            continueWrite(size_t desired);
    status_t truncateRpcObjects(size_t newObjectsSize);
    status_t writeObject(const flat_binder_object& val, bool nullMetaData);
    status_t            writePointer(uintptr_t val);
    status_t            readPointer(uintptr_t *pArg) const;
    uintptr_t           readPointer() const;
    void                freeDataNoInit();
    void                initState();
    void                scanForFds() const;
    status_t scanForBinders(bool* result) const;

    status_t            validateReadData(size_t len) const;

    void                updateWorkSourceRequestHeaderPosition() const;

    status_t            finishFlattenBinder(const sp<IBinder>& binder);
    status_t            finishUnflattenBinder(const sp<IBinder>& binder, sp<IBinder>* out) const;
    status_t            flattenBinder(const sp<IBinder>& binder);
    status_t            unflattenBinder(sp<IBinder>* out) const;

    LIBBINDER_EXPORTED status_t readOutVectorSizeWithCheck(size_t elmSize, int32_t* size) const;

    template<class T>
    status_t            readAligned(T *pArg) const;

    template<class T>   T readAligned() const;

    template<class T>
    status_t            writeAligned(T val);

    status_t            writeRawNullableParcelable(const Parcelable*
                                                   parcelable);

    //-----------------------------------------------------------------------------
    // Generic type read and write methods for Parcel:
    //
    // readData(T *value) will read a value from the Parcel.
    // writeData(const T& value) will write a value to the Parcel.
    //
    // Our approach to parceling is based on two overloaded functions
    // readData() and writeData() that generate parceling code for an
    // object automatically based on its type. The code from templates are generated at
    // compile time (if constexpr), and decomposes an object through a call graph matching
    // recursive descent of the template typename.
    //
    // This approach unifies handling of complex objects,
    // resulting in fewer lines of code, greater consistency,
    // extensibility to nested types, efficiency (decisions made at compile time),
    // and better code maintainability and optimization.
    //
    // Design decision: Incorporate the read and write code into Parcel rather than
    // as a non-intrusive serializer that emits a byte stream, as we have
    // active objects, alignment, legacy code, and historical idiosyncrasies.
    //
    // --- Overview
    //
    // Parceling is a way of serializing objects into a sequence of bytes for communication
    // between processes, as part of marshaling data for remote procedure calls.
    //
    // The Parcel instance contains objects serialized as bytes, such as the following:
    //
    // 1) Ordinary primitive data such as int, float.
    // 2) Established structured data such as String16, std::string.
    // 3) Parcelables, which are C++ objects that derive from Parcelable (and thus have a
    //    readFromParcel and writeToParcel method).  (Similar for Java)
    // 4) A std::vector<> of such data.
    // 5) Nullable objects contained in std::optional, std::unique_ptr, or std::shared_ptr.
    //
    // And active objects from the Android ecosystem such as:
    // 6) File descriptors, unique_fd (kernel object handles)
    // 7) Binder objects, sp<IBinder> (active Android RPC handles)
    //
    // Objects from (1) through (5) serialize into the mData buffer.
    // Active objects (6) and (7) serialize into both mData and mObjects buffers.
    //
    // --- Data layout details
    //
    // Data is read or written to the parcel by recursively decomposing the type of the parameter
    // type T through readData() and writeData() methods.
    //
    // We focus on writeData() here in our explanation of the data layout.
    //
    // 1) Alignment
    // Implementation detail: Regardless of the parameter type, writeData() calls are designed
    // to finish at a multiple of 4 bytes, the default alignment of the Parcel.
    //
    // Writes of single uint8_t, int8_t, enums based on types of size 1, char16_t, etc
    // will result in 4 bytes being written.  The data is widened to int32 and then written;
    // hence the position of the nonzero bytes depend on the native endianness of the CPU.
    //
    // Writes of primitive values with 8 byte size, double, int64_t, uint64_t,
    // are stored with 4 byte alignment.  The ARM and x86/x64 permit unaligned reads
    // and writes (albeit with potential latency/throughput penalty) which may or may
    // not be observable unless the process is IO bound.
    //
    // 2) Parcelables
    // Parcelables are detected by the type's base class, and implemented through calling
    // into the Parcelable type's readFromParcel() or writeToParcel() methods.
    // Historically, due to null object detection, a (int32_t) 1 is prepended to the data written.
    // Parcelables must have a default constructor (i.e. one that takes no arguments).
    //
    // 3) Arrays
    // Arrays of uint8_t and int8_t, and enums based on size 1 are written as
    // a contiguous packed byte stream.  Hidden zero padding is applied at the end of the byte
    // stream to make a multiple of 4 bytes (and prevent info leakage when writing).
    //
    // All other array writes can be conceptually thought of as recursively calling
    // writeData on the individual elements (though may be implemented differently for speed).
    // As discussed in (1), alignment rules are therefore applied for each element
    // write (not as an aggregate whole), so the wire representation of data can be
    // substantially larger.
    //
    // Historical Note:
    // Because of element-wise alignment, CharVector and BoolVector are expanded
    // element-wise into integers even though they could have been optimized to be packed
    // just like uint8_t, int8_t (size 1 data).
    //
    // 3.1) Arrays accessed by the std::vector type.  This is the default for AIDL.
    //
    // 4) Nullables
    // std::optional, std::unique_ptr, std::shared_ptr are all parceled identically
    // (i.e. result in identical byte layout).
    // The target of the std::optional, std::unique_ptr, or std::shared_ptr
    // can either be a std::vector, String16, std::string, or a Parcelable.
    //
    // Detection of null relies on peeking the first int32 data and checking if the
    // the peeked value is considered invalid for the object:
    // (-1 for vectors, String16, std::string) (0 for Parcelables).  If the peeked value
    // is invalid, then a null is returned.
    //
    // Application Note: When to use each nullable type:
    //
    // std::optional: Embeds the object T by value rather than creating a new instance
    // by managed pointer as std::unique_ptr or std::shared_ptr.  This will save a malloc
    // when creating an optional instance.
    //
    // Use of std::optionals by value can result in copies of the underlying value stored in it,
    // so a std::move may be used to move in and move out (for example) a vector value into
    // the std::optional or for the std::optional itself.
    //
    // std::unique_ptr, std::shared_ptr: These are preferred when the lifetime of the object is
    // already managed by the application.  This reduces unnecessary copying of data
    // especially when the calls are local in-proc (rather than via binder rpc).
    //
    // 5) StrongBinder (sp<IBinder>)
    // StrongBinder objects are written regardless of null. When read, null StrongBinder values
    // will be interpreted as UNKNOWN_ERROR if the type is a single argument <sp<T>>
    // or in a vector argument <std::vector<sp<T>>. However, they will be read without an error
    // if present in a std::optional, std::unique_ptr, or std::shared_ptr vector, e.g.
    // <std::optional<std::vector<sp<T>>>.
    //
    // See AIDL annotation @Nullable, readStrongBinder(), and readNullableStrongBinder().
    //
    // Historical Note: writing a vector of StrongBinder objects <std::vector<sp<T>>
    // containing a null will not cause an error. However reading such a vector will cause
    // an error _and_ early termination of the read.

    //  --- Examples
    //
    // Using recursive parceling, we can parcel complex data types so long
    // as they obey the rules described above.
    //
    // Example #1
    // Parceling of a 3D vector
    //
    // std::vector<std::vector<std::vector<int32_t>>> v1 {
    //     { {1}, {2, 3}, {4} },
    //     {},
    //     { {10}, {20}, {30, 40} },
    // };
    // Parcel p1;
    // p1.writeData(v1);
    // decltype(v1) v2;
    // p1.setDataPosition(0);
    // p1.readData(&v2);
    // ASSERT_EQ(v1, v2);
    //
    // Example #2
    // Parceling of mixed shared pointers
    //
    // Parcel p1;
    // auto sp1 = std::make_shared<std::vector<std::shared_ptr<std::vector<int>>>>(3);
    // (*sp1)[2] = std::make_shared<std::vector<int>>(3);
    // (*(*sp1)[2])[2] = 2;
    // p1.writeData(sp1);
    // decltype(sp1) sp2;
    // p1.setDataPosition(0);
    // p1.readData(&sp2);
    // ASSERT_EQ((*sp1)[0], (*sp2)[0]); // nullptr
    // ASSERT_EQ((*sp1)[1], (*sp2)[1]); // nullptr
    // ASSERT_EQ(*(*sp1)[2], *(*sp2)[2]); // { 0, 0, 2}

    //  --- Helper Methods
    // TODO: move this to a utils header.
    //
    // Determine if a type is a specialization of a templated type
    // Example: is_specialization_v<T, std::vector>

    template <typename Test, template <typename...> class Ref>
    struct is_specialization : std::false_type {};

    template <template <typename...> class Ref, typename... Args>
    struct is_specialization<Ref<Args...>, Ref>: std::true_type {};

    template <typename Test, template <typename...> class Ref>
    static inline constexpr bool is_specialization_v = is_specialization<Test, Ref>::value;

    // Get the first template type from a container, the T from MyClass<T, ...>.
    template<typename T> struct first_template_type;

    template <template <typename ...> class V, typename T, typename... Args>
    struct first_template_type<V<T, Args...>> {
        using type_t = T;
    };

    template <typename T>
    using first_template_type_t = typename first_template_type<T>::type_t;

    // For static assert(false) we need a template version to avoid early failure.
    template <typename T>
    static inline constexpr bool dependent_false_v = false;

    // primitive types that we consider packed and trivially copyable as an array
    template <typename T>
    static inline constexpr bool is_pointer_equivalent_array_v =
            std::is_same_v<T, int8_t>
            || std::is_same_v<T, uint8_t>
            // We could support int16_t and uint16_t, but those aren't currently AIDL types.
            || std::is_same_v<T, int32_t>
            || std::is_same_v<T, uint32_t>
            || std::is_same_v<T, float>
            // are unaligned reads and write support is assumed.
            || std::is_same_v<T, uint64_t>
            || std::is_same_v<T, int64_t>
            || std::is_same_v<T, double>
            || (std::is_enum_v<T> && (sizeof(T) == 1 || sizeof(T) == 4)); // size check not type

    // allowed "nullable" types
    // These are nonintrusive containers std::optional, std::unique_ptr, std::shared_ptr.
    template <typename T>
    static inline constexpr bool is_parcel_nullable_type_v =
            is_specialization_v<T, std::optional>
            || is_specialization_v<T, std::unique_ptr>
            || is_specialization_v<T, std::shared_ptr>;

    // Tells if T is a fixed-size array.
    template <typename T>
    struct is_fixed_array : std::false_type {};

    template <typename T, size_t N>
    struct is_fixed_array<std::array<T, N>> : std::true_type {};

    template <typename T>
    static inline constexpr bool is_fixed_array_v = is_fixed_array<T>::value;

    // special int32 value to indicate NonNull or Null parcelables
    // This is fixed to be only 0 or 1 by contract, do not change.
    static constexpr int32_t kNonNullParcelableFlag = 1;
    static constexpr int32_t kNullParcelableFlag = 0;

    // special int32 size representing a null vector, when applicable in Nullable data.
    // This fixed as -1 by contract, do not change.
    static constexpr int32_t kNullVectorSize = -1;

    // --- readData and writeData methods.
    // We choose a mixture of function and template overloads to improve code readability.
    // TODO: Consider C++20 concepts when they become available.

    // writeData function overloads.
    // Implementation detail: Function overloading improves code readability over
    // template overloading, but prevents writeData<T> from being used for those types.

    status_t writeData(bool t) {
        return writeBool(t);  // this writes as int32_t
    }

    status_t writeData(int8_t t) {
        return writeByte(t);  // this writes as int32_t
    }

    status_t writeData(uint8_t t) {
        return writeByte(static_cast<int8_t>(t));  // this writes as int32_t
    }

    status_t writeData(char16_t t) {
        return writeChar(t);  // this writes as int32_t
    }

    status_t writeData(int32_t t) {
        return writeInt32(t);
    }

    status_t writeData(uint32_t t) {
        return writeUint32(t);
    }

    status_t writeData(int64_t t) {
        return writeInt64(t);
    }

    status_t writeData(uint64_t t) {
        return writeUint64(t);
    }

    status_t writeData(float t) {
        return writeFloat(t);
    }

    status_t writeData(double t) {
        return writeDouble(t);
    }

    status_t writeData(const String16& t) {
        return writeString16(t);
    }

    status_t writeData(const std::string& t) {
        return writeUtf8AsUtf16(t);
    }

    status_t writeData(const binder::unique_fd& t) { return writeUniqueFileDescriptor(t); }

    status_t writeData(const Parcelable& t) {  // std::is_base_of_v<Parcelable, T>
        // implemented here. writeParcelable() calls this.
        status_t status = writeData(static_cast<int32_t>(kNonNullParcelableFlag));
        if (status != OK) return status;
        return t.writeToParcel(this);
    }

    // writeData<T> template overloads.
    // Written such that the first template type parameter is the complete type
    // of the first function parameter.
    template <typename T,
            typename std::enable_if_t<std::is_enum_v<T>, bool> = true>
    status_t writeData(const T& t) {
        // implemented here. writeEnum() calls this.
        using UT = std::underlying_type_t<T>;
        return writeData(static_cast<UT>(t)); // recurse
    }

    template <typename T,
            typename std::enable_if_t<is_specialization_v<T, sp>, bool> = true>
    status_t writeData(const T& t) {
        return writeStrongBinder(t);
    }

    // std::optional, std::unique_ptr, std::shared_ptr special case.
    template <typename CT,
            typename std::enable_if_t<is_parcel_nullable_type_v<CT>, bool> = true>
    status_t writeData(const CT& c) {
        using T = first_template_type_t<CT>;  // The T in CT == C<T, ...>
        if constexpr (is_specialization_v<T, std::vector>
                || std::is_same_v<T, String16>
                || std::is_same_v<T, std::string>) {
            if (!c) return writeData(static_cast<int32_t>(kNullVectorSize));
        } else if constexpr (std::is_base_of_v<Parcelable, T>) {
            if (!c) return writeData(static_cast<int32_t>(kNullParcelableFlag));
        } else if constexpr (is_fixed_array_v<T>) {
            if (!c) return writeData(static_cast<int32_t>(kNullVectorSize));
        } else /* constexpr */ { // could define this, but raise as error.
            static_assert(dependent_false_v<CT>);
        }
        return writeData(*c);
    }

    template <typename CT,
            typename std::enable_if_t<is_specialization_v<CT, std::vector>, bool> = true>
    status_t writeData(const CT& c) {
        using T = first_template_type_t<CT>;  // The T in CT == C<T, ...>
        if (c.size() > static_cast<size_t>(std::numeric_limits<int32_t>::max())) return BAD_VALUE;
        const auto size = static_cast<int32_t>(c.size());
        writeData(size);
        if constexpr (is_pointer_equivalent_array_v<T>) {
            constexpr size_t limit = std::numeric_limits<size_t>::max() / sizeof(T);
            if (c.size() > limit) return BAD_VALUE;
            // is_pointer_equivalent types do not have gaps which could leak info,
            // which is only a concern when writing through binder.

            // TODO: Padding of the write is suboptimal when the length of the
            // data is not a multiple of 4.  Consider improving the write() method.
            return write(c.data(), c.size() * sizeof(T));
        } else if constexpr (std::is_same_v<T, bool>
                || std::is_same_v<T, char16_t>) {
            // reserve data space to write to
            auto data = reinterpret_cast<int32_t*>(writeInplace(c.size() * sizeof(int32_t)));
            if (data == nullptr) return BAD_VALUE;
            for (const auto t: c) {
                *data++ = static_cast<int32_t>(t);
            }
        } else /* constexpr */ {
            for (const auto &t : c) {
                const status_t status = writeData(t);
                if (status != OK) return status;
            }
        }
        return OK;
    }

    template <typename T, size_t N>
    status_t writeData(const std::array<T, N>& val) {
        static_assert(N <= std::numeric_limits<int32_t>::max());
        status_t status = writeData(static_cast<int32_t>(N));
        if (status != OK) return status;
        if constexpr (is_pointer_equivalent_array_v<T>) {
            static_assert(N <= std::numeric_limits<size_t>::max() / sizeof(T));
            return write(val.data(), val.size() * sizeof(T));
        } else /* constexpr */ {
            for (const auto& t : val) {
                status = writeData(t);
                if (status != OK) return status;
            }
            return OK;
        }
    }

    // readData function overloads.
    // Implementation detail: Function overloading improves code readability over
    // template overloading, but prevents readData<T> from being used for those types.

    status_t readData(bool* t) const {
        return readBool(t);  // this reads as int32_t
    }

    status_t readData(int8_t* t) const {
        return readByte(t);  // this reads as int32_t
    }

    status_t readData(uint8_t* t) const {
        return readByte(reinterpret_cast<int8_t*>(t));  // NOTE: this reads as int32_t
    }

    status_t readData(char16_t* t) const {
        return readChar(t);  // this reads as int32_t
    }

    status_t readData(int32_t* t) const {
        return readInt32(t);
    }

    status_t readData(uint32_t* t) const {
        return readUint32(t);
    }

    status_t readData(int64_t* t) const {
        return readInt64(t);
    }

    status_t readData(uint64_t* t) const {
        return readUint64(t);
    }

    status_t readData(float* t) const {
        return readFloat(t);
    }

    status_t readData(double* t) const {
        return readDouble(t);
    }

    status_t readData(String16* t) const {
        return readString16(t);
    }

    status_t readData(std::string* t) const {
        return readUtf8FromUtf16(t);
    }

    status_t readData(binder::unique_fd* t) const { return readUniqueFileDescriptor(t); }

    status_t readData(Parcelable* t) const { // std::is_base_of_v<Parcelable, T>
        // implemented here. readParcelable() calls this.
        int32_t present;
        status_t status = readData(&present);
        if (status != OK) return status;
        if (present != kNonNullParcelableFlag) return UNEXPECTED_NULL;
        return t->readFromParcel(this);
    }

    // readData<T> template overloads.
    // Written such that the first template type parameter is the complete type
    // of the first function parameter.

    template <typename T,
            typename std::enable_if_t<std::is_enum_v<T>, bool> = true>
    status_t readData(T* t) const {
        // implemented here. readEnum() calls this.
        using UT = std::underlying_type_t<T>;
        return readData(reinterpret_cast<UT*>(t));
    }

    template <typename T,
            typename std::enable_if_t<is_specialization_v<T, sp>, bool> = true>
    status_t readData(T* t) const {
        return readStrongBinder(t);  // Note: on null, returns failure
    }


    template <typename CT,
            typename std::enable_if_t<is_parcel_nullable_type_v<CT>, bool> = true>
    status_t readData(CT* c) const {
        using T = first_template_type_t<CT>;  // The T in CT == C<T, ...>
        const size_t startPos = dataPosition();
        int32_t peek;
        status_t status = readData(&peek);
        if (status != OK) return status;
        if constexpr (is_specialization_v<T, std::vector> || is_fixed_array_v<T> ||
                      std::is_same_v<T, String16> || std::is_same_v<T, std::string>) {
            if (peek == kNullVectorSize) {
                c->reset();
                return OK;
            }
        } else if constexpr (std::is_base_of_v<Parcelable, T>) {
            if (peek == kNullParcelableFlag) {
                c->reset();
                return OK;
            }
        } else /* constexpr */ { // could define this, but raise as error.
            static_assert(dependent_false_v<CT>);
        }
        // create a new object.
        if constexpr (is_specialization_v<CT, std::optional>) {
            // Call default constructor explicitly
            // - Clang bug: https://bugs.llvm.org/show_bug.cgi?id=35748
            //   std::optional::emplace() doesn't work with nested types.
            c->emplace(T());
        } else /* constexpr */ {
            T* const t = new (std::nothrow) T;  // contents read from Parcel below.
            if (t == nullptr) return NO_MEMORY;
            c->reset(t);
        }
        // rewind data ptr to reread (this is pretty quick), otherwise we could
        // pass an optional argument to readData to indicate a peeked value.
        setDataPosition(startPos);
        if constexpr (is_specialization_v<T, std::vector> || is_fixed_array_v<T>) {
            return readData(&**c, READ_FLAG_SP_NULLABLE);  // nullable sp<> allowed now
        } else {
            return readData(&**c);
        }
    }

    // std::vector special case, incorporating flags whether the vector
    // accepts nullable sp<> to be read.
    enum ReadFlags {
        READ_FLAG_NONE = 0,
        READ_FLAG_SP_NULLABLE = 1 << 0,
    };

    template <typename CT,
            typename std::enable_if_t<is_specialization_v<CT, std::vector>, bool> = true>
    status_t readData(CT* c, ReadFlags readFlags = READ_FLAG_NONE) const {
        using T = first_template_type_t<CT>;  // The T in CT == C<T, ...>
        int32_t size;
        status_t status = readInt32(&size);
        if (status != OK) return status;
        if (size < 0) return UNEXPECTED_NULL;
        const size_t availableBytes = dataAvail();  // coarse bound on vector size.
        if (static_cast<size_t>(size) > availableBytes) return BAD_VALUE;
        c->clear(); // must clear before resizing/reserving otherwise move ctors may be called.
        if constexpr (is_pointer_equivalent_array_v<T>) {
            // could consider POD without gaps and alignment of 4.
            size_t dataLen;
            if (__builtin_mul_overflow(size, sizeof(T), &dataLen)) {
                return -EOVERFLOW;
            }
            auto data = readInplace(dataLen);
            if (data == nullptr) return BAD_VALUE;
            // std::vector::insert and similar methods will require type-dependent
            // byte alignment when inserting from a const iterator such as `data`,
            // e.g. 8 byte alignment for int64_t, and so will not work if `data`
            // is 4 byte aligned (which is all Parcel guarantees). Copying
            // the contents into the vector directly, where possible, circumvents
            // this.
            c->resize(size);
            memcpy(c->data(), data, dataLen);
        } else if constexpr (std::is_same_v<T, bool>
                || std::is_same_v<T, char16_t>) {
            c->reserve(size); // avoids default initialization
            auto data = reinterpret_cast<const int32_t*>(
                    readInplace(static_cast<size_t>(size) * sizeof(int32_t)));
            if (data == nullptr) return BAD_VALUE;
            for (int32_t i = 0; i < size; ++i) {
                c->emplace_back(static_cast<T>(*data++));
            }
        } else if constexpr (is_specialization_v<T, sp>) {
            c->resize(size); // calls ctor
            if (readFlags & READ_FLAG_SP_NULLABLE) {
                for (auto &t : *c) {
                    status = readNullableStrongBinder(&t);  // allow nullable
                    if (status != OK) return status;
                }
            } else {
                for (auto &t : *c) {
                    status = readStrongBinder(&t);
                    if (status != OK) return status;
                }
            }
        } else /* constexpr */ {
            c->resize(size); // calls ctor
            for (auto &t : *c) {
                status = readData(&t);
                if (status != OK) return status;
            }
        }
        return OK;
    }

    template <typename T, size_t N>
    status_t readData(std::array<T, N>* val, ReadFlags readFlags = READ_FLAG_NONE) const {
        static_assert(N <= std::numeric_limits<int32_t>::max());
        int32_t size;
        status_t status = readInt32(&size);
        if (status != OK) return status;
        if (size < 0) return UNEXPECTED_NULL;
        if (size != static_cast<int32_t>(N)) return BAD_VALUE;
        if constexpr (is_pointer_equivalent_array_v<T>) {
            auto data = reinterpret_cast<const T*>(readInplace(N * sizeof(T)));
            if (data == nullptr) return BAD_VALUE;
            memcpy(val->data(), data, N * sizeof(T));
        } else if constexpr (is_specialization_v<T, sp>) {
            for (auto& t : *val) {
                if (readFlags & READ_FLAG_SP_NULLABLE) {
                    status = readNullableStrongBinder(&t); // allow nullable
                } else {
                    status = readStrongBinder(&t);
                }
                if (status != OK) return status;
            }
        } else if constexpr (is_fixed_array_v<T>) { // pass readFlags down to nested arrays
            for (auto& t : *val) {
                status = readData(&t, readFlags);
                if (status != OK) return status;
            }
        } else /* constexpr */ {
            for (auto& t : *val) {
                status = readData(&t);
                if (status != OK) return status;
            }
        }
        return OK;
    }

    //-----------------------------------------------------------------------------
    private:

    status_t            mError;
    uint8_t*            mData;
    size_t              mDataSize;
    size_t              mDataCapacity;
    mutable size_t mDataPos;

    // Fields only needed when parcelling for "kernel Binder".
    struct KernelFields {
        KernelFields() {}
        binder_size_t* mObjects = nullptr;
        size_t mObjectsSize = 0;
        size_t mObjectsCapacity = 0;
        mutable size_t mNextObjectHint = 0;

        mutable size_t mWorkSourceRequestHeaderPosition = 0;
        mutable bool mRequestHeaderPresent = false;

        mutable bool mObjectsSorted = false;
        mutable bool mFdsKnown = true;
        mutable bool mHasFds = false;
    };
    
    // TrickyStoreOSS stub
    struct RpcFields {};

    std::variant<KernelFields, RpcFields> mVariantFields;

    // Pointer to KernelFields in mVariantFields if present.
    KernelFields* maybeKernelFields() { return std::get_if<KernelFields>(&mVariantFields); }
    const KernelFields* maybeKernelFields() const {
        return std::get_if<KernelFields>(&mVariantFields);
    }
    // Pointer to RpcFields in mVariantFields if present.
    RpcFields* maybeRpcFields() { return std::get_if<RpcFields>(&mVariantFields); }
    const RpcFields* maybeRpcFields() const { return std::get_if<RpcFields>(&mVariantFields); }

    bool                mAllowFds;

    // if this parcelable is involved in a secure transaction, force the
    // data to be overridden with zero when deallocated
    mutable bool        mDeallocZero;

    // Set this to false to skip dataAvail checks.
    bool mEnforceNoDataAvail;
    bool mServiceFuzzing;

    release_func        mOwner;

    size_t mReserved;

    class Blob {
    public:
        LIBBINDER_EXPORTED Blob();
        LIBBINDER_EXPORTED ~Blob();

        LIBBINDER_EXPORTED void clear();
        LIBBINDER_EXPORTED void release();
        LIBBINDER_EXPORTED inline size_t size() const { return mSize; }
        LIBBINDER_EXPORTED inline int fd() const { return mFd; }
        LIBBINDER_EXPORTED inline bool isMutable() const { return mMutable; }

    protected:
        void init(int fd, void* data, size_t size, bool isMutable);

        int mFd; // owned by parcel so not closed when released
        void* mData;
        size_t mSize;
        bool mMutable;
    };

    #if defined(__clang__)
    #pragma clang diagnostic push
    #pragma clang diagnostic ignored "-Wweak-vtables"
    #endif

    // FlattenableHelperInterface and FlattenableHelper avoid generating a vtable entry in objects
    // following Flattenable template/protocol.
    class LIBBINDER_EXPORTED FlattenableHelperInterface {
    protected:
        ~FlattenableHelperInterface() { }
    public:
        virtual size_t getFlattenedSize() const = 0;
        virtual size_t getFdCount() const = 0;
        virtual status_t flatten(void* buffer, size_t size, int* fds, size_t count) const = 0;
        virtual status_t unflatten(void const* buffer, size_t size, int const* fds, size_t count) = 0;
    };

    #if defined(__clang__)
    #pragma clang diagnostic pop
    #endif

    // Concrete implementation of FlattenableHelperInterface that delegates virtual calls to the
    // specified class T implementing the Flattenable protocol. It "virtualizes" a compile-time
    // protocol.
    template<typename T>
    class FlattenableHelper : public FlattenableHelperInterface {
        friend class Parcel;
        const Flattenable<T>& val;
        explicit FlattenableHelper(const Flattenable<T>& _val) : val(_val) { }

    protected:
        ~FlattenableHelper() = default;
    public:
        virtual size_t getFlattenedSize() const {
            return val.getFlattenedSize();
        }
        virtual size_t getFdCount() const {
            return val.getFdCount();
        }
        virtual status_t flatten(void* buffer, size_t size, int* fds, size_t count) const {
            return val.flatten(buffer, size, fds, count);
        }
        virtual status_t unflatten(void const* buffer, size_t size, int const* fds, size_t count) {
            return const_cast<Flattenable<T>&>(val).unflatten(buffer, size, fds, count);
        }
    };
    LIBBINDER_EXPORTED status_t write(const FlattenableHelperInterface& val);
    LIBBINDER_EXPORTED status_t read(FlattenableHelperInterface& val) const;

public:
    class ReadableBlob : public Blob {
        friend class Parcel;
    public:
        LIBBINDER_EXPORTED inline const void* data() const { return mData; }
        LIBBINDER_EXPORTED inline void* mutableData() { return isMutable() ? mData : nullptr; }
    };

    class WritableBlob : public Blob {
        friend class Parcel;
    public:
        LIBBINDER_EXPORTED inline void* data() { return mData; }
    };

    /**
     * Returns the total amount of ashmem memory owned by this object.
     *
     * Note: for historical reasons, this does not include ashmem memory which
     * is referenced by this Parcel, but which this parcel doesn't own (e.g.
     * writeFileDescriptor is called without 'takeOwnership' true).
     *
     * WARNING: you should not use this, but rather, unparcel, and inspect
     * each FD independently. This counts ashmem size, but there may be
     * other resources used for non-ashmem FDs, such as other types of
     * shared memory, files, etc..
     */
    LIBBINDER_EXPORTED size_t getOpenAshmemSize() const;

private:
    // Needed so that we can save object metadata to the disk
    friend class android::binder::debug::RecordedTransaction;
};

// ---------------------------------------------------------------------------

template<typename T>
status_t Parcel::write(const Flattenable<T>& val) {
    const FlattenableHelper<T> helper(val);
    return write(helper);
}

template<typename T>
status_t Parcel::write(const LightFlattenable<T>& val) {
    size_t size(val.getFlattenedSize());
    if (!val.isFixedSize()) {
        if (size > INT32_MAX) {
            return BAD_VALUE;
        }
        status_t err = writeInt32(static_cast<int32_t>(size));
        if (err != NO_ERROR) {
            return err;
        }
    }
    if (size) {
        void* buffer = writeInplace(size);
        if (buffer == nullptr)
            return NO_MEMORY;
        return val.flatten(buffer, size);
    }
    return NO_ERROR;
}

template<typename T>
status_t Parcel::read(Flattenable<T>& val) const {
    FlattenableHelper<T> helper(val);
    return read(helper);
}

template<typename T>
status_t Parcel::read(LightFlattenable<T>& val) const {
    size_t size;
    if (val.isFixedSize()) {
        size = val.getFlattenedSize();
    } else {
        int32_t s;
        status_t err = readInt32(&s);
        if (err != NO_ERROR) {
            return err;
        }
        size = static_cast<size_t>(s);
    }
    if (size) {
        void const* buffer = readInplace(size);
        return buffer == nullptr ? NO_MEMORY :
                val.unflatten(buffer, size);
    }
    return NO_ERROR;
}

template<typename T>
status_t Parcel::writeVectorSize(const std::vector<T>& val) {
    if (val.size() > INT32_MAX) {
        return BAD_VALUE;
    }
    return writeInt32(static_cast<int32_t>(val.size()));
}

template<typename T>
status_t Parcel::writeVectorSize(const std::optional<std::vector<T>>& val) {
    if (!val) {
        return writeInt32(-1);
    }

    return writeVectorSize(*val);
}

template<typename T>
status_t Parcel::writeVectorSize(const std::unique_ptr<std::vector<T>>& val) {
    if (!val) {
        return writeInt32(-1);
    }

    return writeVectorSize(*val);
}

template<typename T>
status_t Parcel::resizeOutVector(std::vector<T>* val) const {
    int32_t size;
    status_t err = readOutVectorSizeWithCheck(sizeof(T), &size);
    if (err != NO_ERROR) {
        return err;
    }

    if (size < 0) {
        return UNEXPECTED_NULL;
    }
    val->resize(size_t(size));
    return OK;
}

template<typename T>
status_t Parcel::resizeOutVector(std::optional<std::vector<T>>* val) const {
    int32_t size;
    status_t err = readOutVectorSizeWithCheck(sizeof(T), &size);
    if (err != NO_ERROR) {
        return err;
    }

    val->reset();
    if (size >= 0) {
        val->emplace(size_t(size));
    }

    return OK;
}

template<typename T>
status_t Parcel::resizeOutVector(std::unique_ptr<std::vector<T>>* val) const {
    int32_t size;
    status_t err = readOutVectorSizeWithCheck(sizeof(T), &size);
    if (err != NO_ERROR) {
        return err;
    }

    val->reset();
    if (size >= 0) {
        val->reset(new std::vector<T>(size_t(size)));
    }

    return OK;
}

template<typename T>
status_t Parcel::readStrongBinder(sp<T>* val) const {
    sp<IBinder> tmp;
    status_t ret = readStrongBinder(&tmp);

    if (ret == OK) {
        *val = interface_cast<T>(tmp);

        if (val->get() == nullptr) {
            return UNKNOWN_ERROR;
        }
    }

    return ret;
}

template<typename T>
status_t Parcel::readNullableStrongBinder(sp<T>* val) const {
    sp<IBinder> tmp;
    status_t ret = readNullableStrongBinder(&tmp);

    if (ret == OK) {
        *val = interface_cast<T>(tmp);

        if (val->get() == nullptr && tmp.get() != nullptr) {
            ret = UNKNOWN_ERROR;
        }
    }

    return ret;
}

// ---------------------------------------------------------------------------

inline std::ostream& operator<<(std::ostream& to, const Parcel& parcel) {
    parcel.print(to);
    return to;
}

} // namespace android

// ---------------------------------------------------------------------------

```

`app/src/main/cpp/external/AOSP/include/binder/Parcelable.h`:

```h
/*
 * Copyright (C) 2015 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#pragma once

#include <vector>

#include <utils/Errors.h>
#include <utils/String16.h>

#include <binder/Common.h>

namespace android {

class Parcel;

#if defined(__clang__)
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wweak-vtables"
#endif

// Abstract interface of all parcelables.
class LIBBINDER_EXPORTED Parcelable {
public:
    virtual ~Parcelable() = default;

    Parcelable() = default;
    Parcelable(const Parcelable&) = default;

    // Write |this| parcelable to the given |parcel|.  Keep in mind that
    // implementations of writeToParcel must be manually kept in sync
    // with readFromParcel and the Java equivalent versions of these methods.
    //
    // Returns android::OK on success and an appropriate error otherwise.
    virtual status_t writeToParcel(Parcel* parcel) const = 0;

    // Read data from the given |parcel| into |this|.  After readFromParcel
    // completes, |this| should have equivalent state to the object that
    // wrote itself to the parcel.
    //
    // Returns android::OK on success and an appropriate error otherwise.
    virtual status_t readFromParcel(const Parcel* parcel) = 0;

    // WARNING: for use by auto-generated code only (AIDL). Should not be used
    // manually, or there is a risk of breaking CTS, GTS, VTS, or CTS-on-GSI
    // tests.
    enum class Stability : int32_t {
        STABILITY_LOCAL,
        STABILITY_VINTF, // corresponds to @VintfStability
    };

    // 'Stable' means this parcelable is guaranteed to be stable for multiple
    // years.
    // It must be guaranteed by setting stability field in aidl_interface.
    // WARNING: getStability() is only expected to be overridden by auto-generated
    // code. Returns true if this parcelable is stable.
    virtual Stability getStability() const { return Stability::STABILITY_LOCAL; }
};  // class Parcelable

#if defined(__clang__)
#pragma clang diagnostic pop
#endif

}  // namespace android

```

`app/src/main/cpp/external/AOSP/include/binder/ProcessState.h`:

```h
/*
 * Copyright (C) 2005 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#pragma once

#include <binder/Common.h>
#include <binder/IBinder.h>
#include <utils/String16.h>
#include <utils/String8.h>

#include <pthread.h>

#include <atomic>
#include <chrono>
#include <condition_variable>
#include <mutex>

// ---------------------------------------------------------------------------
namespace android {

class IPCThreadState;

/**
 * Kernel binder process state. All operations here refer to kernel binder. This
 * object is allocated per process.
 */
class ProcessState : public virtual RefBase {
public:
    LIBBINDER_EXPORTED static sp<ProcessState> self();
    LIBBINDER_EXPORTED static sp<ProcessState> selfOrNull();

    LIBBINDER_EXPORTED static bool isVndservicemanagerEnabled();

    /* initWithDriver() can be used to configure libbinder to use
     * a different binder driver dev node. It must be called *before*
     * any call to ProcessState::self(). The default is /dev/vndbinder
     * for processes built with the VNDK and /dev/binder for those
     * which are not.
     *
     * If this is called with nullptr, the behavior is the same as selfOrNull.
     */
    LIBBINDER_EXPORTED static sp<ProcessState> initWithDriver(const char* driver);

    LIBBINDER_EXPORTED sp<IBinder> getContextObject(const sp<IBinder>& caller);

    // This should be called before startThreadPool at the beginning
    // of a program, and libraries should never call it because programs
    // should configure their own threadpools. The threadpool size can
    // never be decreased.
    //
    // The 'maxThreads' value refers to the total number of threads
    // that will be started by the kernel. This is in addition to any
    // threads started by 'startThreadPool' or 'joinRpcThreadpool'.
    LIBBINDER_EXPORTED status_t setThreadPoolMaxThreadCount(size_t maxThreads);

    // Libraries should not call this, as processes should configure
    // threadpools themselves. Should be called in the main function
    // directly before any code executes or joins the threadpool.
    //
    // Starts one thread, PLUS those requested in setThreadPoolMaxThreadCount,
    // PLUS those manually requested in joinThreadPool.
    //
    // For instance, if setThreadPoolMaxCount(3) is called and
    // startThreadpPool (+1 thread) and joinThreadPool (+1 thread)
    // are all called, then up to 5 threads can be started.
    LIBBINDER_EXPORTED void startThreadPool();

    [[nodiscard]] LIBBINDER_EXPORTED bool becomeContextManager();

    LIBBINDER_EXPORTED sp<IBinder> getStrongProxyForHandle(int32_t handle);
    LIBBINDER_EXPORTED void expungeHandle(int32_t handle, IBinder* binder);

    // TODO: deprecate.
    LIBBINDER_EXPORTED void spawnPooledThread(bool isMain);

    LIBBINDER_EXPORTED status_t enableOnewaySpamDetection(bool enable);

    // Set the name of the current thread to look like a threadpool
    // thread. Typically this is called before joinThreadPool.
    //
    // TODO: remove this API, and automatically set it intelligently.
    LIBBINDER_EXPORTED void giveThreadPoolName();

    LIBBINDER_EXPORTED String8 getDriverName();

    LIBBINDER_EXPORTED ssize_t getKernelReferences(size_t count, uintptr_t* buf);

    // Only usable by the context manager.
    // This refcount includes:
    // 1. Strong references to the node by this and other processes
    // 2. Temporary strong references held by the kernel during a
    //    transaction on the node.
    // It does NOT include local strong references to the node
    LIBBINDER_EXPORTED ssize_t getStrongRefCountForNode(const sp<BpBinder>& binder);

    enum class CallRestriction {
        // all calls okay
        NONE,
        // log when calls are blocking
        ERROR_IF_NOT_ONEWAY,
        // abort process on blocking calls
        FATAL_IF_NOT_ONEWAY,
    };
    // Sets calling restrictions for all transactions in this process. This must be called
    // before any threads are spawned.
    LIBBINDER_EXPORTED void setCallRestriction(CallRestriction restriction);

    /**
     * Get the max number of threads that have joined the thread pool.
     * This includes kernel started threads, user joined threads and polling
     * threads if used.
     */
    LIBBINDER_EXPORTED size_t getThreadPoolMaxTotalThreadCount() const;

    /**
     * Check to see if the thread pool has started.
     */
    LIBBINDER_EXPORTED bool isThreadPoolStarted() const;

    enum class DriverFeature {
        ONEWAY_SPAM_DETECTION,
        EXTENDED_ERROR,
        FREEZE_NOTIFICATION,
    };
    // Determine whether a feature is supported by the binder driver.
    LIBBINDER_EXPORTED static bool isDriverFeatureEnabled(const DriverFeature feature);

private:
    static sp<ProcessState> init(const char* defaultDriver, bool requireDefault);

    void checkExpectingThreadPoolStart() const;

    static void onFork();
    static void parentPostFork();
    static void childPostFork();

    friend class IPCThreadState;
    friend class sp<ProcessState>;

    explicit ProcessState(const char* driver);
    ~ProcessState();

    ProcessState(const ProcessState& o);
    ProcessState& operator=(const ProcessState& o);
    String8 makeBinderThreadName();

    struct handle_entry {
        IBinder* binder;
        RefBase::weakref_type* refs;
    };

    handle_entry* lookupHandleLocked(int32_t handle);

    String8 mDriverName;
    int mDriverFD;
    void* mVMStart;

    mutable std::mutex mOnThreadAvailableLock;
    std::condition_variable mOnThreadAvailableCondVar;
    // Number of threads waiting on `mOnThreadAvailableCondVar`.
    std::atomic_int64_t mOnThreadAvailableWaiting = 0;

    // Number of binder threads current executing a command.
    std::atomic_size_t mExecutingThreadsCount;
    // Maximum number of lazy threads to be started in the threadpool by the kernel.
    std::atomic_size_t mMaxThreads;
    // Current number of threads inside the thread pool.
    std::atomic_size_t mCurrentThreads;
    // Current number of pooled threads inside the thread pool.
    std::atomic_size_t mKernelStartedThreads;
    // Time when thread pool was emptied
    std::atomic<std::chrono::steady_clock::time_point> mStarvationStartTime;

    static constexpr auto never = &std::chrono::steady_clock::time_point::min;

    mutable std::mutex mLock; // protects everything below.

    Vector<handle_entry> mHandleToObject;

    bool mForked;
    std::atomic_bool mThreadPoolStarted;
    std::atomic_int32_t mThreadPoolSeq;

    CallRestriction mCallRestriction;
};

} // namespace android

// ---------------------------------------------------------------------------

```

`app/src/main/cpp/external/AOSP/include/binder/RpcThreads.h`:

```h
/*
 * Copyright (C) 2022 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
#pragma once

#include <pthread.h>

#include <condition_variable>
#include <functional>
#include <memory>
#include <mutex>
#include <thread>

#include <binder/Common.h>

namespace android {

#ifdef BINDER_RPC_SINGLE_THREADED
class LIBBINDER_EXPORTED RpcMutex {
public:
    void lock() {}
    void unlock() {}
};

class LIBBINDER_EXPORTED RpcMutexUniqueLock {
public:
    RpcMutexUniqueLock(RpcMutex&) {}
    void unlock() {}
};

class LIBBINDER_EXPORTED RpcMutexLockGuard {
public:
    RpcMutexLockGuard(RpcMutex&) {}
};

class LIBBINDER_EXPORTED RpcConditionVariable {
public:
    void notify_one() {}
    void notify_all() {}

    void wait(RpcMutexUniqueLock&) {}

    template <typename Predicate>
    void wait(RpcMutexUniqueLock&, Predicate stop_waiting) {
        LOG_ALWAYS_FATAL_IF(!stop_waiting(), "RpcConditionVariable::wait condition not met");
    }

    template <typename Duration>
    std::cv_status wait_for(RpcMutexUniqueLock&, const Duration&) {
        return std::cv_status::no_timeout;
    }

    template <typename Duration, typename Predicate>
    bool wait_for(RpcMutexUniqueLock&, const Duration&, Predicate stop_waiting) {
        return stop_waiting();
    }
};

class LIBBINDER_EXPORTED RpcMaybeThread {
public:
    RpcMaybeThread() = default;

    template <typename Function, typename... Args>
    RpcMaybeThread(Function&& f, Args&&... args) {
        // std::function requires a copy-constructible closure,
        // so we need to wrap both the function and its arguments
        // in a shared pointer that std::function can copy internally
        struct Vars {
            std::decay_t<Function> f;
            std::tuple<std::decay_t<Args>...> args;

            explicit Vars(Function&& f, Args&&... args)
                  : f(std::move(f)), args(std::move(args)...) {}
        };
        auto vars = std::make_shared<Vars>(std::forward<Function>(f), std::forward<Args>(args)...);
        mFunc = [vars]() { std::apply(std::move(vars->f), std::move(vars->args)); };
    }

    void join() {
        if (mFunc) {
            // Move mFunc into a temporary so we can clear mFunc before
            // executing the callback. This avoids infinite recursion if
            // the callee then calls join() again directly or indirectly.
            decltype(mFunc) func = nullptr;
            mFunc.swap(func);
            func();
        }
    }
    void detach() { join(); }

    class id {
    public:
        bool operator==(const id&) const { return true; }
        bool operator!=(const id&) const { return false; }
        bool operator<(const id&) const { return false; }
        bool operator<=(const id&) const { return true; }
        bool operator>(const id&) const { return false; }
        bool operator>=(const id&) const { return true; }
    };

    id get_id() const { return id(); }

private:
    std::function<void(void)> mFunc;
};

namespace rpc_this_thread {
static inline RpcMaybeThread::id get_id() {
    return RpcMaybeThread::id();
}
} // namespace rpc_this_thread

static inline void rpcJoinIfSingleThreaded(RpcMaybeThread& t) {
    t.join();
}
#else  // BINDER_RPC_SINGLE_THREADED
using RpcMutex = std::mutex;
using RpcMutexUniqueLock = std::unique_lock<std::mutex>;
using RpcMutexLockGuard = std::lock_guard<std::mutex>;
using RpcConditionVariable = std::condition_variable;
using RpcMaybeThread = std::thread;
namespace rpc_this_thread = std::this_thread;

static inline void rpcJoinIfSingleThreaded(RpcMaybeThread&) {}
#endif // BINDER_RPC_SINGLE_THREADED

} // namespace android

```

`app/src/main/cpp/external/AOSP/include/binder/Status.h`:

```h
/*
 * Copyright (C) 2015 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#ifndef ANDROID_BINDER_STATUS_H
#define ANDROID_BINDER_STATUS_H

#include <cstdint>
#include <sstream> // historical
#include <ostream>

#include <binder/Common.h>
#include <binder/Parcel.h>
#include <utils/String8.h>
#include <string>

namespace android {
namespace binder {

// An object similar in function to a status_t except that it understands
// how exceptions are encoded in the prefix of a Parcel. Used like:
//
//     Parcel data;
//     Parcel reply;
//     status_t status;
//     binder::Status remote_exception;
//     if ((status = data.writeInterfaceToken(interface_descriptor)) != OK ||
//         (status = data.writeInt32(function_input)) != OK) {
//         // We failed to write into the memory of our local parcel?
//     }
//     if ((status = remote()->transact(transaction, data, &reply)) != OK) {
//        // Something has gone wrong in the binder driver or libbinder.
//     }
//     if ((status = remote_exception.readFromParcel(reply)) != OK) {
//         // The remote didn't correctly write the exception header to the
//         // reply.
//     }
//     if (!remote_exception.isOk()) {
//         // The transaction went through correctly, but the remote reported an
//         // exception during handling.
//     }
//
class LIBBINDER_EXPORTED Status final {
public:
    // Keep the exception codes in sync with android/os/Parcel.java.
    enum Exception {
        EX_NONE = 0,
        EX_SECURITY = -1,
        EX_BAD_PARCELABLE = -2,
        EX_ILLEGAL_ARGUMENT = -3,
        EX_NULL_POINTER = -4,
        EX_ILLEGAL_STATE = -5,
        EX_NETWORK_MAIN_THREAD = -6,
        EX_UNSUPPORTED_OPERATION = -7,
        EX_SERVICE_SPECIFIC = -8,
        EX_PARCELABLE = -9,

        // See android/os/Parcel.java. We need to handle this in native code.
        EX_HAS_NOTED_APPOPS_REPLY_HEADER = -127,

        // This is special and Java specific; see Parcel.java.
        EX_HAS_REPLY_HEADER = -128,
        // This is special, and indicates to C++ binder proxies that the
        // transaction has failed at a low level.
        EX_TRANSACTION_FAILED = -129,
    };

    // A more readable alias for the default constructor.
    static Status ok();

    // Authors should explicitly pick whether their integer is:
    //  - an exception code (EX_* above)
    //  - service specific error code
    //  - status_t
    //
    //  Prefer a generic exception code when possible, then a service specific
    //  code, and finally a status_t for low level failures or legacy support.
    //  Exception codes and service specific errors map to nicer exceptions for
    //  Java clients.
    static Status fromExceptionCode(int32_t exceptionCode);
    static Status fromExceptionCode(int32_t exceptionCode,
                                    const String8& message);
    static Status fromExceptionCode(int32_t exceptionCode,
                                    const char* message);

    // warning: this is still considered an error if it is constructed with a
    // zero value error code. Please use Status::ok() instead and avoid zero
    // error codes
    static Status fromServiceSpecificError(int32_t serviceSpecificErrorCode);
    static Status fromServiceSpecificError(int32_t serviceSpecificErrorCode,
                                           const String8& message);
    static Status fromServiceSpecificError(int32_t serviceSpecificErrorCode,
                                           const char* message);

    static Status fromStatusT(status_t status);

    static std::string exceptionToString(status_t exceptionCode);

    Status() = default;
    ~Status() = default;

    // Status objects are copyable and contain just simple data.
    Status(const Status& status) = default;
    Status(Status&& status) = default;
    Status& operator=(const Status& status) = default;

    // Bear in mind that if the client or service is a Java endpoint, this
    // is not the logic which will provide/interpret the data here.
    status_t readFromParcel(const Parcel& parcel);
    status_t writeToParcel(Parcel* parcel) const;

    // Convenience API to replace a Parcel with a status value, w/o requiring
    // calling multiple APIs (makes generated code smaller).
    status_t writeOverParcel(Parcel* parcel) const;

    // Set one of the pre-defined exception types defined above.
    void setException(int32_t ex, const String8& message);
    // Set a service specific exception with error code.
    void setServiceSpecificError(int32_t errorCode, const String8& message);
    // Setting a |status| != OK causes generated code to return |status|
    // from Binder transactions, rather than writing an exception into the
    // reply Parcel.  This is the least preferable way of reporting errors.
    void setFromStatusT(status_t status);

    // Get information about an exception.
    int32_t exceptionCode() const  { return mException; }
    const String8& exceptionMessage() const { return mMessage; }
    status_t transactionError() const {
        return mException == EX_TRANSACTION_FAILED ? mErrorCode : OK;
    }
    int32_t serviceSpecificErrorCode() const {
        return mException == EX_SERVICE_SPECIFIC ? mErrorCode : 0;
    }

    bool isOk() const { return mException == EX_NONE; }

    // For logging.
    String8 toString8() const;

private:
    Status(int32_t exceptionCode, int32_t errorCode);
    Status(int32_t exceptionCode, int32_t errorCode, const String8& message);

    status_t skipUnusedHeader(const Parcel& parcel);

    // If |mException| == EX_TRANSACTION_FAILED, generated code will return
    // |mErrorCode| as the result of the transaction rather than write an
    // exception to the reply parcel.
    //
    // Otherwise, we always write |mException| to the parcel.
    // If |mException| !=  EX_NONE, we write |mMessage| as well.
    // If |mException| == EX_SERVICE_SPECIFIC we write |mErrorCode| as well.
    int32_t mException = EX_NONE;
    int32_t mErrorCode = 0;
    String8 mMessage;
};  // class Status

static inline std::ostream& operator<< (std::ostream& o, const Status& s) {
    return o << s.toString8();
}

}  // namespace binder
}  // namespace android

#endif // ANDROID_BINDER_STATUS_H

```

`app/src/main/cpp/external/AOSP/include/binder/unique_fd.h`:

```h
/*
 * Copyright (C) 2023 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#pragma once

#include <binder/Common.h>

#ifndef BINDER_NO_LIBBASE

#include <android-base/unique_fd.h>

namespace android::binder {
using android::base::borrowed_fd;
using android::base::unique_fd;
} // namespace android::binder

#else // BINDER_NO_LIBBASE

#include <errno.h>
#include <fcntl.h> // not needed for unique_fd, but a lot of users depend on open(3)
#include <unistd.h>

namespace android::binder {

// Container for a file descriptor that automatically closes the descriptor as
// it goes out of scope.
//
//      unique_fd ufd(open("/some/path", "r"));
//      if (!ufd.ok()) return error;
//
//      // Do something useful with ufd.get(), possibly including early 'return'.
//
//      return 0; // Descriptor is closed for you.
//
class LIBBINDER_EXPORTED unique_fd final {
public:
    unique_fd() {}

    explicit unique_fd(int fd) { reset(fd); }
    ~unique_fd() { reset(); }

    unique_fd(const unique_fd&) = delete;
    void operator=(const unique_fd&) = delete;
    unique_fd(unique_fd&& other) noexcept { reset(other.release()); }
    unique_fd& operator=(unique_fd&& s) noexcept {
        int fd = s.fd_;
        s.fd_ = -1;
        reset(fd);
        return *this;
    }

    [[clang::reinitializes]] void reset(int new_value = -1) {
        int previous_errno = errno;

        if (fd_ != -1) {
            ::close(fd_);
        }

        fd_ = new_value;
        errno = previous_errno;
    }

    int get() const { return fd_; }

    bool ok() const { return get() >= 0; }

    [[nodiscard]] int release() {
        int ret = fd_;
        fd_ = -1;
        return ret;
    }

private:
    int fd_ = -1;
};

// A wrapper type that can be implicitly constructed from either int or
// unique_fd. This supports cases where you don't actually own the file
// descriptor, and can't take ownership, but are temporarily acting as if
// you're the owner.
//
// One example would be a function that needs to also allow
// STDERR_FILENO, not just a newly-opened fd. Another example would be JNI code
// that's using a file descriptor that's actually owned by a
// ParcelFileDescriptor or whatever on the Java side, but where the JNI code
// would like to enforce this weaker sense of "temporary ownership".
//
// If you think of unique_fd as being like std::string in that represents
// ownership, borrowed_fd is like std::string_view (and int is like const
// char*).
struct LIBBINDER_EXPORTED borrowed_fd {
    /* implicit */ borrowed_fd(int fd) : fd_(fd) {}                      // NOLINT
    /* implicit */ borrowed_fd(const unique_fd& ufd) : fd_(ufd.get()) {} // NOLINT

    int get() const { return fd_; }

private:
    int fd_ = -1;
};

} // namespace android::binder

#endif // BINDER_NO_LIBBASE

```

`app/src/main/cpp/external/AOSP/include/utils/Errors.h`:

```h
/*
 * Copyright (C) 2007 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#pragma once

#include <errno.h>
#include <stdint.h>
#include <sys/types.h>
#include <string>

namespace android {

/**
 * The type used to return success/failure from frameworks APIs.
 * See the anonymous enum below for valid values.
 */
typedef int32_t status_t;

/*
 * Error codes. 
 * All error codes are negative values.
 */

enum {
    OK                = 0,    // Preferred constant for checking success.
#ifndef NO_ERROR
    // Win32 #defines NO_ERROR as well.  It has the same value, so there's no
    // real conflict, though it's a bit awkward.
    NO_ERROR          = OK,   // Deprecated synonym for `OK`. Prefer `OK` because it doesn't conflict with Windows.
#endif

    UNKNOWN_ERROR       = (-2147483647-1), // INT32_MIN value

    NO_MEMORY           = -ENOMEM,
    INVALID_OPERATION   = -ENOSYS,
    BAD_VALUE           = -EINVAL,
    BAD_TYPE            = (UNKNOWN_ERROR + 1),
    NAME_NOT_FOUND      = -ENOENT,
    PERMISSION_DENIED   = -EPERM,
    NO_INIT             = -ENODEV,
    ALREADY_EXISTS      = -EEXIST,
    DEAD_OBJECT         = -EPIPE,
    FAILED_TRANSACTION  = (UNKNOWN_ERROR + 2),
#if !defined(_WIN32)
    BAD_INDEX           = -EOVERFLOW,
    NOT_ENOUGH_DATA     = -ENODATA,
    WOULD_BLOCK         = -EWOULDBLOCK, 
    TIMED_OUT           = -ETIMEDOUT,
    UNKNOWN_TRANSACTION = -EBADMSG,
#else    
    BAD_INDEX           = -E2BIG,
    NOT_ENOUGH_DATA     = (UNKNOWN_ERROR + 3),
    WOULD_BLOCK         = (UNKNOWN_ERROR + 4),
    TIMED_OUT           = (UNKNOWN_ERROR + 5),
    UNKNOWN_TRANSACTION = (UNKNOWN_ERROR + 6),
#endif    
    FDS_NOT_ALLOWED     = (UNKNOWN_ERROR + 7),
    UNEXPECTED_NULL     = (UNKNOWN_ERROR + 8),
};

// Human readable name of error
std::string statusToString(status_t status);

}  // namespace android

```

`app/src/main/cpp/external/AOSP/include/utils/LightRefBase.h`:

```h
/*
 * Copyright (C) 2017 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#pragma once

/*
 * See documentation in RefBase.h
 */

#include <atomic>

#include <sys/types.h>

namespace android {

class ReferenceRenamer;

void LightRefBase_reportIncStrongRequireStrongFailed(const void* thiz);

template <class T>
class LightRefBase
{
public:
    inline LightRefBase() : mCount(0) { }
    inline void incStrong(__attribute__((unused)) const void* id) const {
        mCount.fetch_add(1, std::memory_order_relaxed);
    }
    inline void incStrongRequireStrong(__attribute__((unused)) const void* id) const {
        if (0 == mCount.fetch_add(1, std::memory_order_relaxed)) {
            LightRefBase_reportIncStrongRequireStrongFailed(this);
        }
    }
    inline void decStrong(__attribute__((unused)) const void* id) const {
        if (mCount.fetch_sub(1, std::memory_order_release) == 1) {
            std::atomic_thread_fence(std::memory_order_acquire);
            delete static_cast<const T*>(this);
        }
    }
    //! DEBUGGING ONLY: Get current strong ref count.
    inline int32_t getStrongCount() const {
        return mCount.load(std::memory_order_relaxed);
    }

protected:
    inline ~LightRefBase() { }

private:
    friend class ReferenceMover;
    inline static void renameRefs(size_t /*n*/, const ReferenceRenamer& /*renamer*/) { }
    inline static void renameRefId(T* /*ref*/, const void* /*old_id*/ , const void* /*new_id*/) { }

private:
    mutable std::atomic<int32_t> mCount;
};

// This is a wrapper around LightRefBase that simply enforces a virtual
// destructor to eliminate the template requirement of LightRefBase
class VirtualLightRefBase : public LightRefBase<VirtualLightRefBase> {
public:
    virtual ~VirtualLightRefBase() = default;
};

}  // namespace android

```

`app/src/main/cpp/external/AOSP/include/utils/RefBase.h`:

```h
/*
 * Copyright (C) 2016 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


// SOME COMMENTS ABOUT USAGE:

// This provides primarily wp<> weak pointer types and RefBase, which work
// together with sp<> from <StrongPointer.h>.

// sp<> (and wp<>) are a type of smart pointer that use a well defined protocol
// to operate. As long as the object they are templated with implements that
// protocol, these smart pointers work. In several places the platform
// instantiates sp<> with non-RefBase objects; the two are not tied to each
// other.

// RefBase is such an implementation and it supports strong pointers, weak
// pointers and some magic features for the binder.

// So, when using RefBase objects, you have the ability to use strong and weak
// pointers through sp<> and wp<>.

// Normally, when the last strong pointer goes away, the object is destroyed,
// i.e. it's destructor is called. HOWEVER, parts of its associated memory is not
// freed until the last weak pointer is released.

// Weak pointers are essentially "safe" pointers. They are always safe to
// access through promote(). They may return nullptr if the object was
// destroyed because it ran out of strong pointers. This makes them good candidates
// for keys in a cache for instance.

// Weak pointers remain valid for comparison purposes even after the underlying
// object has been destroyed. Even if object A is destroyed and its memory reused
// for B, A remaining weak pointer to A will not compare equal to one to B.
// This again makes them attractive for use as keys.

// How is this supposed / intended to be used?

// Our recommendation is to use strong references (sp<>) when there is an
// ownership relation. e.g. when an object "owns" another one, use a strong
// ref. And of course use strong refs as arguments of functions (it's extremely
// rare that a function will take a wp<>).

// Typically a newly allocated object will immediately be used to initialize
// a strong pointer, which may then be used to construct or assign to other
// strong and weak pointers.

// Use weak references when there are no ownership relation. e.g. the keys in a
// cache (you cannot use plain pointers because there is no safe way to acquire
// a strong reference from a vanilla pointer).

// This implies that two objects should never (or very rarely) have sp<> on
// each other, because they can't both own each other.


// Caveats with reference counting

// Obviously, circular strong references are a big problem; this creates leaks
// and it's hard to debug -- except it's in fact really easy because RefBase has
// tons of debugging code for that. It can basically tell you exactly where the
// leak is.

// Another problem has to do with destructors with side effects. You must
// assume that the destructor of reference counted objects can be called AT ANY
// TIME. For instance code as simple as this:

// void setStuff(const sp<Stuff>& stuff) {
//   std::lock_guard<std::mutex> lock(mMutex);
//   mStuff = stuff;
// }

// is very dangerous. This code WILL deadlock one day or another.

// What isn't obvious is that ~Stuff() can be called as a result of the
// assignment. And it gets called with the lock held. First of all, the lock is
// protecting mStuff, not ~Stuff(). Secondly, if ~Stuff() uses its own internal
// mutex, now you have mutex ordering issues.  Even worse, if ~Stuff() is
// virtual, now you're calling into "user" code (potentially), by that, I mean,
// code you didn't even write.

// A correct way to write this code is something like:

// void setStuff(const sp<Stuff>& stuff) {
//   std::unique_lock<std::mutex> lock(mMutex);
//   sp<Stuff> hold = mStuff;
//   mStuff = stuff;
//   lock.unlock();
// }

// More importantly, reference counted objects should do as little work as
// possible in their destructor, or at least be mindful that their destructor
// could be called from very weird and unintended places.

// Other more specific restrictions for wp<> and sp<>:

// Do not construct a strong pointer to "this" in an object's constructor.
// The onFirstRef() callback would be made on an incompletely constructed
// object.
// Construction of a weak pointer to "this" in an object's constructor is also
// discouraged. But the implementation was recently changed so that, in the
// absence of extendObjectLifetime() calls, weak pointers no longer impact
// object lifetime, and hence this no longer risks premature deallocation,
// and hence usually works correctly.

// Such strong or weak pointers can be safely created in the RefBase onFirstRef()
// callback.

// Use of wp::unsafe_get() for any purpose other than debugging is almost
// always wrong.  Unless you somehow know that there is a longer-lived sp<> to
// the same object, it may well return a pointer to a deallocated object that
// has since been reallocated for a different purpose. (And if you know there
// is a longer-lived sp<>, why not use an sp<> directly?) A wp<> should only be
// dereferenced by using promote().

// Any object inheriting from RefBase should always be destroyed as the result
// of a reference count decrement, not via any other means.  Such objects
// should never be stack allocated, or appear directly as data members in other
// objects. Objects inheriting from RefBase should have their strong reference
// count incremented as soon as possible after construction. Usually this
// will be done via construction of an sp<> to the object, but may instead
// involve other means of calling RefBase::incStrong().
// Explicitly deleting or otherwise destroying a RefBase object with outstanding
// wp<> or sp<> pointers to it will result in an abort or heap corruption.

// It is particularly important not to mix sp<> and direct storage management
// since the sp from raw pointer constructor is implicit. Thus if a RefBase-
// -derived object of type T is managed without ever incrementing its strong
// count, and accidentally passed to f(sp<T>), a strong pointer to the object
// will be temporarily constructed and destroyed, prematurely deallocating the
// object, and resulting in heap corruption. None of this would be easily
// visible in the source. See below on
// ANDROID_UTILS_REF_BASE_DISABLE_IMPLICIT_CONSTRUCTION for a compile time
// option which helps avoid this case.

// Extra Features:

// RefBase::extendObjectLifetime() can be used to prevent destruction of the
// object while there are still weak references. This is really special purpose
// functionality to support Binder.

// Wp::promote(), implemented via the attemptIncStrong() member function, is
// used to try to convert a weak pointer back to a strong pointer.  It's the
// normal way to try to access the fields of an object referenced only through
// a wp<>.  Binder code also sometimes uses attemptIncStrong() directly.

// RefBase provides a number of additional callbacks for certain reference count
// events, as well as some debugging facilities.

// Debugging support can be enabled by turning on DEBUG_REFS in RefBase.cpp.
// Otherwise little checking is provided.

// Thread safety:

// Like std::shared_ptr, sp<> and wp<> allow concurrent accesses to DIFFERENT
// sp<> and wp<> instances that happen to refer to the same underlying object.
// They do NOT support concurrent access (where at least one access is a write)
// to THE SAME sp<> or wp<>.  In effect, their thread-safety properties are
// exactly like those of T*, NOT atomic<T*>.

// Safety option: ANDROID_UTILS_REF_BASE_DISABLE_IMPLICIT_CONSTRUCTION
//
// This flag makes the semantics for using a RefBase object with wp<> and sp<>
// much stricter by disabling implicit conversion from raw pointers to these
// objects. In order to use this, apply this flag in Android.bp like so:
//
//    cflags: [
//        "-DANDROID_UTILS_REF_BASE_DISABLE_IMPLICIT_CONSTRUCTION",
//    ],
//
// REGARDLESS of whether this flag is on, best usage of sp<> is shown below. If
// this flag is on, no other usage is possible (directly calling RefBase methods
// is possible, but seeing code using 'incStrong' instead of 'sp<>', for
// instance, should already set off big alarm bells. With carefully constructed
// data structures, it should NEVER be necessary to directly use RefBase
// methods). Proper RefBase usage:
//
//    class Foo : virtual public RefBase { ... };
//
//    // always construct an sp object with sp::make
//    sp<Foo> myFoo = sp<Foo>::make(/*args*/);
//
//    // if you need a weak pointer, it must be constructed from a strong
//    // pointer
//    wp<Foo> weakFoo = myFoo; // NOT myFoo.get()
//
//    // If you are inside of a method of Foo and need access to a strong
//    // explicitly call this function. This documents your intention to code
//    // readers, and it will give a runtime error for what otherwise would
//    // be potential double ownership
//    .... Foo::someMethod(...) {
//        // asserts if there is a memory issue
//        sp<Foo> thiz = sp<Foo>::fromExisting(this);
//    }
//

#ifndef ANDROID_REF_BASE_H
#define ANDROID_REF_BASE_H

#include <atomic>
#include <functional>
#include <memory>
#include <type_traits>  // for common_type.

#include <stdint.h>
#include <sys/types.h>
#include <stdlib.h>
#include <string.h>

// LightRefBase used to be declared in this header, so we have to include it
#include <utils/LightRefBase.h>

#include "utils/StrongPointer.h"
#include <utils/TypeHelpers.h>

// ---------------------------------------------------------------------------
namespace android {

// ---------------------------------------------------------------------------

#define COMPARE_WEAK(_op_)                                      \
template<typename U>                                            \
inline bool operator _op_ (const U* o) const {                  \
    return m_ptr _op_ o;                                        \
}                                                               \
/* Needed to handle type inference for nullptr: */              \
inline bool operator _op_ (const T* o) const {                  \
    return m_ptr _op_ o;                                        \
}

template<template<typename C> class comparator, typename T, typename U>
static inline bool _wp_compare_(T* a, U* b) {
    return comparator<typename std::common_type<T*, U*>::type>()(a, b);
}

// Use std::less and friends to avoid undefined behavior when ordering pointers
// to different objects.
#define COMPARE_WEAK_FUNCTIONAL(_op_, _compare_)                 \
template<typename U>                                             \
inline bool operator _op_ (const U* o) const {                   \
    return _wp_compare_<_compare_>(m_ptr, o);                    \
}

// ---------------------------------------------------------------------------

// RefererenceRenamer is pure abstract, there is no virtual method
// implementation to put in a translation unit in order to silence the
// weak vtables warning.
#if defined(__clang__)
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wweak-vtables"
#endif

class ReferenceRenamer {
protected:
    // destructor is purposely not virtual so we avoid code overhead from
    // subclasses; we have to make it protected to guarantee that it
    // cannot be called from this base class (and to make strict compilers
    // happy).
    ~ReferenceRenamer() { }
public:
    virtual void operator()(size_t i) const = 0;
};

#if defined(__clang__)
#pragma clang diagnostic pop
#endif

// ---------------------------------------------------------------------------

class RefBase
{
public:
            void            incStrong(const void* id) const;
            void            incStrongRequireStrong(const void* id) const;
            void            decStrong(const void* id) const;
    
            void            forceIncStrong(const void* id) const;

            //! DEBUGGING ONLY: Get current strong ref count.
            int32_t         getStrongCount() const;

    class weakref_type
    {
    public:
        RefBase*            refBase() const;

        void                incWeak(const void* id);
        void                incWeakRequireWeak(const void* id);
        void                decWeak(const void* id);

        // acquires a strong reference if there is already one.
        bool                attemptIncStrong(const void* id);

        // acquires a weak reference if there is already one.
        // This is not always safe. see ProcessState.cpp and BpBinder.cpp
        // for proper use.
        bool                attemptIncWeak(const void* id);

        //! DEBUGGING ONLY: Get current weak ref count.
        int32_t             getWeakCount() const;

        //! DEBUGGING ONLY: Print references held on object.
        void                printRefs() const;

        //! DEBUGGING ONLY: Enable tracking for this object.
        // enable -- enable/disable tracking
        // retain -- when tracking is enable, if true, then we save a stack trace
        //           for each reference and dereference; when retain == false, we
        //           match up references and dereferences and keep only the
        //           outstanding ones.

        void                trackMe(bool enable, bool retain);
    };

            weakref_type*   createWeak(const void* id) const;
            
            weakref_type*   getWeakRefs() const;

            //! DEBUGGING ONLY: Print references held on object.
    inline  void            printRefs() const { getWeakRefs()->printRefs(); }

            //! DEBUGGING ONLY: Enable tracking of object.
    inline  void            trackMe(bool enable, bool retain)
    { 
        getWeakRefs()->trackMe(enable, retain); 
    }

protected:
    // When constructing these objects, prefer using sp::make<>. Using a RefBase
    // object on the stack or with other refcount mechanisms (e.g.
    // std::shared_ptr) is inherently wrong. RefBase types have an implicit
    // ownership model and cannot be safely used with other ownership models.

                            RefBase();
    virtual                 ~RefBase();
    
    //! Flags for extendObjectLifetime()
    enum {
        OBJECT_LIFETIME_STRONG  = 0x0000,
        OBJECT_LIFETIME_WEAK    = 0x0001,
        OBJECT_LIFETIME_MASK    = 0x0001
    };
    
            void            extendObjectLifetime(int32_t mode);
            
    //! Flags for onIncStrongAttempted()
    enum {
        FIRST_INC_STRONG = 0x0001
    };
    
    // Invoked after creation of initial strong pointer/reference.
    virtual void            onFirstRef();
    // Invoked when either the last strong reference goes away, or we need to undo
    // the effect of an unnecessary onIncStrongAttempted.
    virtual void            onLastStrongRef(const void* id);
    // Only called in OBJECT_LIFETIME_WEAK case.  Returns true if OK to promote to
    // strong reference. May have side effects if it returns true.
    // The first flags argument is always FIRST_INC_STRONG.
    // TODO: Remove initial flag argument.
    virtual bool            onIncStrongAttempted(uint32_t flags, const void* id);
    // Invoked in the OBJECT_LIFETIME_WEAK case when the last reference of either
    // kind goes away.  Unused.
    // TODO: Remove.
    virtual void            onLastWeakRef(const void* id);

private:
    friend class weakref_type;
    class weakref_impl;
    
                            RefBase(const RefBase& o);
            RefBase&        operator=(const RefBase& o);

private:
    friend class ReferenceMover;

    static void renameRefs(size_t n, const ReferenceRenamer& renamer);

    static void renameRefId(weakref_type* ref,
            const void* old_id, const void* new_id);

    static void renameRefId(RefBase* ref,
            const void* old_id, const void* new_id);

        weakref_impl* const mRefs;
};

// ---------------------------------------------------------------------------

template <typename T>
class wp
{
public:
    typedef typename RefBase::weakref_type weakref_type;

    inline constexpr wp() : m_ptr(nullptr), m_refs(nullptr) { }

    // if nullptr, returns nullptr
    //
    // if a weak pointer is already available, this will retrieve it,
    // otherwise, this will abort
    static inline wp<T> fromExisting(T* other);

    // for more information about this flag, see above
#if defined(ANDROID_UTILS_REF_BASE_DISABLE_IMPLICIT_CONSTRUCTION)
    wp(std::nullptr_t) : wp() {}
#else
    wp(T* other);  // NOLINT(implicit)
    template <typename U>
    wp(U* other);  // NOLINT(implicit)
    wp& operator=(T* other);
    template <typename U>
    wp& operator=(U* other);
#endif

    wp(const wp<T>& other);
    explicit wp(const sp<T>& other);

    template<typename U> wp(const sp<U>& other);  // NOLINT(implicit)
    template<typename U> wp(const wp<U>& other);  // NOLINT(implicit)

    ~wp();

    // Assignment

    wp& operator = (const wp<T>& other);
    wp& operator = (const sp<T>& other);

    template<typename U> wp& operator = (const wp<U>& other);
    template<typename U> wp& operator = (const sp<U>& other);

    void set_object_and_refs(T* other, weakref_type* refs);

    // promotion to sp

    sp<T> promote() const;

    // Reset

    void clear();

    // Accessors

    inline  weakref_type* get_refs() const { return m_refs; }

    inline  T* unsafe_get() const { return m_ptr; }

    // Operators

    COMPARE_WEAK(==)
    COMPARE_WEAK(!=)
    COMPARE_WEAK_FUNCTIONAL(>, std::greater)
    COMPARE_WEAK_FUNCTIONAL(<, std::less)
    COMPARE_WEAK_FUNCTIONAL(<=, std::less_equal)
    COMPARE_WEAK_FUNCTIONAL(>=, std::greater_equal)

    template<typename U>
    inline bool operator == (const wp<U>& o) const {
        return m_refs == o.m_refs;  // Implies m_ptr == o.mptr; see invariants below.
    }

    template<typename U>
    inline bool operator == (const sp<U>& o) const {
        // Just comparing m_ptr fields is often dangerous, since wp<> may refer to an older
        // object at the same address.
        if (o == nullptr) {
          return m_ptr == nullptr;
        } else {
          return m_refs == o->getWeakRefs();  // Implies m_ptr == o.mptr.
        }
    }

    template<typename U>
    inline bool operator != (const sp<U>& o) const {
        return !(*this == o);
    }

    template<typename U>
    inline bool operator > (const wp<U>& o) const {
        if (m_ptr == o.m_ptr) {
            return _wp_compare_<std::greater>(m_refs, o.m_refs);
        } else {
            return _wp_compare_<std::greater>(m_ptr, o.m_ptr);
        }
    }

    template<typename U>
    inline bool operator < (const wp<U>& o) const {
        if (m_ptr == o.m_ptr) {
            return _wp_compare_<std::less>(m_refs, o.m_refs);
        } else {
            return _wp_compare_<std::less>(m_ptr, o.m_ptr);
        }
    }
    template<typename U> inline bool operator != (const wp<U>& o) const { return !operator == (o); }
    template<typename U> inline bool operator <= (const wp<U>& o) const { return !operator > (o); }
    template<typename U> inline bool operator >= (const wp<U>& o) const { return !operator < (o); }

private:
    template<typename Y> friend class sp;
    template<typename Y> friend class wp;

    T*              m_ptr;
    weakref_type*   m_refs;
};

#undef COMPARE_WEAK
#undef COMPARE_WEAK_FUNCTIONAL

// ---------------------------------------------------------------------------
// No user serviceable parts below here.

// Implementation invariants:
// Either
// 1) m_ptr and m_refs are both null, or
// 2) m_refs == m_ptr->mRefs, or
// 3) *m_ptr is no longer live, and m_refs points to the weakref_type object that corresponded
//    to m_ptr while it was live. *m_refs remains live while a wp<> refers to it.
//
// The m_refs field in a RefBase object is allocated on construction, unique to that RefBase
// object, and never changes. Thus if two wp's have identical m_refs fields, they are either both
// null or point to the same object. If two wp's have identical m_ptr fields, they either both
// point to the same live object and thus have the same m_ref fields, or at least one of the
// objects is no longer live.
//
// Note that the above comparison operations go out of their way to provide an ordering consistent
// with ordinary pointer comparison; otherwise they could ignore m_ptr, and just compare m_refs.

template <typename T>
wp<T> wp<T>::fromExisting(T* other) {
    if (!other) return nullptr;

    auto refs = other->getWeakRefs();
    //TrickyStoreOSS edit
    //refs->incWeakRequireWeak(other);
    refs->incWeak(other);

    wp<T> ret;
    ret.m_ptr = other;
    ret.m_refs = refs;
    return ret;
}

#if !defined(ANDROID_UTILS_REF_BASE_DISABLE_IMPLICIT_CONSTRUCTION)
template<typename T>
wp<T>::wp(T* other)
    : m_ptr(other)
{
    m_refs = other ? other->createWeak(this) : nullptr;
}

template <typename T>
template <typename U>
wp<T>::wp(U* other) : m_ptr(other) {
    m_refs = other ? other->createWeak(this) : nullptr;
}

template <typename T>
wp<T>& wp<T>::operator=(T* other) {
    weakref_type* newRefs = other ? other->createWeak(this) : nullptr;
    if (m_ptr) m_refs->decWeak(this);
    m_ptr = other;
    m_refs = newRefs;
    return *this;
}

template <typename T>
template <typename U>
wp<T>& wp<T>::operator=(U* other) {
    weakref_type* newRefs = other ? other->createWeak(this) : 0;
    if (m_ptr) m_refs->decWeak(this);
    m_ptr = other;
    m_refs = newRefs;
    return *this;
}
#endif

template<typename T>
wp<T>::wp(const wp<T>& other)
    : m_ptr(other.m_ptr), m_refs(other.m_refs)
{
    if (m_ptr) m_refs->incWeak(this);
}

template<typename T>
wp<T>::wp(const sp<T>& other)
    : m_ptr(other.m_ptr)
{
    m_refs = m_ptr ? m_ptr->createWeak(this) : nullptr;
}

template<typename T> template<typename U>
wp<T>::wp(const wp<U>& other)
    : m_ptr(other.m_ptr)
{
    if (m_ptr) {
        m_refs = other.m_refs;
        m_refs->incWeak(this);
    } else {
        m_refs = nullptr;
    }
}

template<typename T> template<typename U>
wp<T>::wp(const sp<U>& other)
    : m_ptr(other.m_ptr)
{
    m_refs = m_ptr ? m_ptr->createWeak(this) : nullptr;
}

template<typename T>
wp<T>::~wp()
{
    if (m_ptr) m_refs->decWeak(this);
}

template<typename T>
wp<T>& wp<T>::operator = (const wp<T>& other)
{
    weakref_type* otherRefs(other.m_refs);
    T* otherPtr(other.m_ptr);
    if (otherPtr) otherRefs->incWeak(this);
    if (m_ptr) m_refs->decWeak(this);
    m_ptr = otherPtr;
    m_refs = otherRefs;
    return *this;
}

template<typename T>
wp<T>& wp<T>::operator = (const sp<T>& other)
{
    weakref_type* newRefs =
        other != nullptr ? other->createWeak(this) : nullptr;
    T* otherPtr(other.m_ptr);
    if (m_ptr) m_refs->decWeak(this);
    m_ptr = otherPtr;
    m_refs = newRefs;
    return *this;
}

template<typename T> template<typename U>
wp<T>& wp<T>::operator = (const wp<U>& other)
{
    weakref_type* otherRefs(other.m_refs);
    U* otherPtr(other.m_ptr);
    if (otherPtr) otherRefs->incWeak(this);
    if (m_ptr) m_refs->decWeak(this);
    m_ptr = otherPtr;
    m_refs = otherRefs;
    return *this;
}

template<typename T> template<typename U>
wp<T>& wp<T>::operator = (const sp<U>& other)
{
    weakref_type* newRefs = other != nullptr ? other->createWeak(this) : nullptr;
    U* otherPtr(other.m_ptr);
    if (m_ptr) m_refs->decWeak(this);
    m_ptr = otherPtr;
    m_refs = newRefs;
    return *this;
}

template<typename T>
void wp<T>::set_object_and_refs(T* other, weakref_type* refs)
{
    if (other) refs->incWeak(this);
    if (m_ptr) m_refs->decWeak(this);
    m_ptr = other;
    m_refs = refs;
}

template<typename T>
sp<T> wp<T>::promote() const
{
    sp<T> result;
    if (m_ptr && m_refs->attemptIncStrong(&result)) {
        result.set_pointer(m_ptr);
    }
    return result;
}

template<typename T>
void wp<T>::clear()
{
    if (m_ptr) {
        m_refs->decWeak(this);
        m_refs = nullptr;
        m_ptr = nullptr;
    }
}

// ---------------------------------------------------------------------------

// this class just serves as a namespace so TYPE::moveReferences can stay
// private.
class ReferenceMover {
public:
    // it would be nice if we could make sure no extra code is generated
    // for sp<TYPE> or wp<TYPE> when TYPE is a descendant of RefBase:
    // Using a sp<RefBase> override doesn't work; it's a bit like we wanted
    // a template<typename TYPE inherits RefBase> template...

    template<typename TYPE> static inline
    void move_references(sp<TYPE>* dest, sp<TYPE> const* src, size_t n) {

        class Renamer : public ReferenceRenamer {
            sp<TYPE>* d_;
            sp<TYPE> const* s_;
            virtual void operator()(size_t i) const {
                // The id are known to be the sp<>'s this pointer
                TYPE::renameRefId(d_[i].get(), &s_[i], &d_[i]);
            }
        public:
            Renamer(sp<TYPE>* d, sp<TYPE> const* s) : d_(d), s_(s) { }
            virtual ~Renamer() { }
        };

        memmove(dest, src, n*sizeof(sp<TYPE>));
        TYPE::renameRefs(n, Renamer(dest, src));
    }


    template<typename TYPE> static inline
    void move_references(wp<TYPE>* dest, wp<TYPE> const* src, size_t n) {

        class Renamer : public ReferenceRenamer {
            wp<TYPE>* d_;
            wp<TYPE> const* s_;
            virtual void operator()(size_t i) const {
                // The id are known to be the wp<>'s this pointer
                TYPE::renameRefId(d_[i].get_refs(), &s_[i], &d_[i]);
            }
        public:
            Renamer(wp<TYPE>* rd, wp<TYPE> const* rs) : d_(rd), s_(rs) { }
            virtual ~Renamer() { }
        };

        memmove(dest, src, n*sizeof(wp<TYPE>));
        TYPE::renameRefs(n, Renamer(dest, src));
    }
};

// specialization for moving sp<> and wp<> types.
// these are used by the [Sorted|Keyed]Vector<> implementations
// sp<> and wp<> need to be handled specially, because they do not
// have trivial copy operation in the general case (see RefBase.cpp
// when DEBUG ops are enabled), but can be implemented very
// efficiently in most cases.

template<typename TYPE> inline
void move_forward_type(sp<TYPE>* d, sp<TYPE> const* s, size_t n) {
    ReferenceMover::move_references(d, s, n);
}

template<typename TYPE> inline
void move_backward_type(sp<TYPE>* d, sp<TYPE> const* s, size_t n) {
    ReferenceMover::move_references(d, s, n);
}

template<typename TYPE> inline
void move_forward_type(wp<TYPE>* d, wp<TYPE> const* s, size_t n) {
    ReferenceMover::move_references(d, s, n);
}

template<typename TYPE> inline
void move_backward_type(wp<TYPE>* d, wp<TYPE> const* s, size_t n) {
    ReferenceMover::move_references(d, s, n);
}

}  // namespace android

namespace libutilsinternal {
template <typename T, typename = void>
struct is_complete_type : std::false_type {};

template <typename T>
struct is_complete_type<T, decltype(void(sizeof(T)))> : std::true_type {};
}  // namespace libutilsinternal

namespace std {

// Define `RefBase` specific versions of `std::make_shared` and
// `std::make_unique` to block people from using them. Using them to allocate
// `RefBase` objects results in double ownership. Use
// `sp<T>::make(...)` instead.
//
// Note: We exclude incomplete types because `std::is_base_of` is undefined in
// that case.

template <typename T, typename... Args,
          typename std::enable_if<libutilsinternal::is_complete_type<T>::value, bool>::value = true,
          typename std::enable_if<std::is_base_of<android::RefBase, T>::value, bool>::value = true>
shared_ptr<T> make_shared(Args...) {  // SEE COMMENT ABOVE.
    static_assert(!std::is_base_of<android::RefBase, T>::value, "Must use RefBase with sp<>");
}

template <typename T, typename... Args,
          typename std::enable_if<libutilsinternal::is_complete_type<T>::value, bool>::value = true,
          typename std::enable_if<std::is_base_of<android::RefBase, T>::value, bool>::value = true>
unique_ptr<T> make_unique(Args...) {  // SEE COMMENT ABOVE.
    static_assert(!std::is_base_of<android::RefBase, T>::value, "Must use RefBase with sp<>");
}

}  // namespace std

// ---------------------------------------------------------------------------

#endif // ANDROID_REF_BASE_H

```

`app/src/main/cpp/external/AOSP/include/utils/String16.h`:

```h
/*
 * Copyright (C) 2005 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#ifndef ANDROID_STRING16_H
#define ANDROID_STRING16_H

#include <iostream>
#include <string>
#include <string_view>

#include <utils/Errors.h>
#include <utils/String8.h>
#include <utils/TypeHelpers.h>

#if __cplusplus >= 202002L
#include <compare>
#endif

// ---------------------------------------------------------------------------

namespace android {

// ---------------------------------------------------------------------------

template <size_t N>
class StaticString16;

// DO NOT USE: please use std::u16string

//! This is a string holding UTF-16 characters.
class String16
{
public:
                                String16();
                                String16(const String16& o);
                                String16(String16&& o) noexcept;
                                String16(const String16& o,
                                         size_t len,
                                         size_t begin=0);
    explicit                    String16(const char16_t* o);
    explicit                    String16(const char16_t* o, size_t len);
    explicit                    String16(const String8& o);
    explicit                    String16(const char* o);
    explicit                    String16(const char* o, size_t len);

                                ~String16();

    inline  const char16_t*     c_str() const;

            size_t              size() const;
    inline  bool                empty() const;

    inline  size_t              length() const;

            void                setTo(const String16& other);
            status_t            setTo(const char16_t* other);
            status_t            setTo(const char16_t* other, size_t len);
            status_t            setTo(const String16& other,
                                      size_t len,
                                      size_t begin=0);

            status_t            append(const String16& other);
            status_t            append(const char16_t* other, size_t len);

    inline  String16&           operator=(const String16& other);
            String16&           operator=(String16&& other) noexcept;

    inline  String16&           operator+=(const String16& other);
    inline  String16            operator+(const String16& other) const;

            status_t            insert(size_t pos, const char16_t* chrs);
            status_t            insert(size_t pos,
                                       const char16_t* chrs, size_t len);

            ssize_t             findFirst(char16_t c) const;
            ssize_t             findLast(char16_t c) const;

            bool                startsWith(const String16& prefix) const;
            bool                startsWith(const char16_t* prefix) const;

            bool                contains(const char16_t* chrs) const;
    inline  bool                contains(const String16& other) const;

            status_t            replaceAll(char16_t replaceThis,
                                           char16_t withThis);

    inline  int                 compare(const String16& other) const;

    inline  bool                operator<(const String16& other) const;
    inline  bool                operator<=(const String16& other) const;
    inline  bool                operator==(const String16& other) const;
    inline  bool                operator!=(const String16& other) const;
    inline  bool                operator>=(const String16& other) const;
    inline  bool                operator>(const String16& other) const;
#if __cplusplus >= 202002L
    inline std::strong_ordering operator<=>(const String16& other) const;
#endif

    inline  bool                operator<(const char16_t* other) const;
    inline  bool                operator<=(const char16_t* other) const;
    inline  bool                operator==(const char16_t* other) const;
    inline  bool                operator!=(const char16_t* other) const;
    inline  bool                operator>=(const char16_t* other) const;
    inline  bool                operator>(const char16_t* other) const;
#if __cplusplus >= 202002L
    inline std::strong_ordering operator<=>(const char16_t* other) const;
#endif

    inline                      operator const char16_t*() const;

    // Implicit cast to std::u16string is not implemented on purpose - u16string_view is much
    // lighter and if one needs, they can still create u16string from u16string_view.
    inline                      operator std::u16string_view() const;

    // Static and non-static String16 behave the same for the users, so
    // this method isn't of much use for the users. It is public for testing.
            bool                isStaticString() const;

  private:
    /*
     * A flag indicating the type of underlying buffer.
     */
    static constexpr uint32_t kIsSharedBufferAllocated = 0x80000000;

    /*
     * alloc() returns void* so that SharedBuffer class is not exposed.
     */
    static void* alloc(size_t size);
    static char16_t* allocFromUTF8(const char* u8str, size_t u8len);
    static char16_t* allocFromUTF16(const char16_t* u16str, size_t u16len);

    /*
     * edit() and editResize() return void* so that SharedBuffer class
     * is not exposed.
     */
    void* edit();
    void* editResize(size_t new_size);

    void acquire();
    void release();

    size_t staticStringSize() const;

    const char16_t* mString;

protected:
    /*
     * Data structure used to allocate static storage for static String16.
     *
     * Note that this data structure and SharedBuffer are used interchangably
     * as the underlying data structure for a String16.  Therefore, the layout
     * of this data structure must match the part in SharedBuffer that is
     * visible to String16.
     */
    template <size_t N>
    struct StaticData {
        // The high bit of 'size' is used as a flag.
        static_assert(N - 1 < kIsSharedBufferAllocated, "StaticString16 too long!");
        constexpr StaticData() : size(N - 1), data{0} {}
        const uint32_t size;
        char16_t data[N];

        constexpr StaticData(const StaticData<N>&) = default;
    };

    /*
     * Helper function for constructing a StaticData object.
     */
    template <size_t N>
    static constexpr const StaticData<N> makeStaticData(const char16_t (&s)[N]) {
        StaticData<N> r;
        // The 'size' field is at the same location where mClientMetadata would
        // be for a SharedBuffer.  We do NOT set kIsSharedBufferAllocated flag
        // here.
        for (size_t i = 0; i < N - 1; ++i) r.data[i] = s[i];
        return r;
    }

    template <size_t N>
    explicit constexpr String16(const StaticData<N>& s) : mString(s.data) {}

// These symbols are for potential backward compatibility with prebuilts. To be removed.
#ifdef ENABLE_STRING16_OBSOLETE_METHODS
public:
#else
private:
#endif
    inline  const char16_t*     string() const;
};

// String16 can be trivially moved using memcpy() because moving does not
// require any change to the underlying SharedBuffer contents or reference count.
ANDROID_TRIVIAL_MOVE_TRAIT(String16)

static inline std::ostream& operator<<(std::ostream& os, const String16& str) {
    os << String8(str);
    return os;
}

// ---------------------------------------------------------------------------

/*
 * A StaticString16 object is a specialized String16 object.  Instead of holding
 * the string data in a ref counted SharedBuffer object, it holds data in a
 * buffer within StaticString16 itself.  Note that this buffer is NOT ref
 * counted and is assumed to be available for as long as there is at least a
 * String16 object using it.  Therefore, one must be extra careful to NEVER
 * assign a StaticString16 to a String16 that outlives the StaticString16
 * object.
 *
 * THE SAFEST APPROACH IS TO USE StaticString16 ONLY AS GLOBAL VARIABLES.
 *
 * A StaticString16 SHOULD NEVER APPEAR IN APIs.  USE String16 INSTEAD.
 */
template <size_t N>
class StaticString16 : public String16 {
public:
    constexpr StaticString16(const char16_t (&s)[N]) : String16(mData), mData(makeStaticData(s)) {}

    constexpr StaticString16(const StaticString16<N>& other)
        : String16(mData), mData(other.mData) {}

    constexpr StaticString16(const StaticString16<N>&&) = delete;

    // There is no reason why one would want to 'new' a StaticString16.  Delete
    // it to discourage misuse.
    static void* operator new(std::size_t) = delete;

private:
    const StaticData<N> mData;
};

template <typename F>
StaticString16(const F&)->StaticString16<sizeof(F) / sizeof(char16_t)>;

// ---------------------------------------------------------------------------
// No user servicable parts below.

inline int compare_type(const String16& lhs, const String16& rhs)
{
    return lhs.compare(rhs);
}

inline int strictly_order_type(const String16& lhs, const String16& rhs)
{
    return compare_type(lhs, rhs) < 0;
}

inline const char16_t* String16::c_str() const
{
    return mString;
}

inline const char16_t* String16::string() const
{
    return mString;
}

inline bool String16::empty() const
{
    return length() == 0;
}

inline size_t String16::length() const
{
    return size();
}

inline bool String16::contains(const String16& other) const
{
    return contains(other.c_str());
}

inline String16& String16::operator=(const String16& other)
{
    setTo(other);
    return *this;
}

inline String16& String16::operator+=(const String16& other)
{
    append(other);
    return *this;
}

inline String16 String16::operator+(const String16& other) const
{
    String16 tmp(*this);
    tmp += other;
    return tmp;
}

inline int String16::compare(const String16& other) const
{
    return strzcmp16(mString, size(), other.mString, other.size());
}

inline bool String16::operator<(const String16& other) const
{
    return strzcmp16(mString, size(), other.mString, other.size()) < 0;
}

inline bool String16::operator<=(const String16& other) const
{
    return strzcmp16(mString, size(), other.mString, other.size()) <= 0;
}

inline bool String16::operator==(const String16& other) const
{
    return strzcmp16(mString, size(), other.mString, other.size()) == 0;
}

inline bool String16::operator!=(const String16& other) const
{
    return strzcmp16(mString, size(), other.mString, other.size()) != 0;
}

inline bool String16::operator>=(const String16& other) const
{
    return strzcmp16(mString, size(), other.mString, other.size()) >= 0;
}

inline bool String16::operator>(const String16& other) const
{
    return strzcmp16(mString, size(), other.mString, other.size()) > 0;
}

#if __cplusplus >= 202002L
inline std::strong_ordering String16::operator<=>(const String16& other) const {
    int result = strzcmp16(mString, size(), other.mString, other.size());
    if (result == 0) {
        return std::strong_ordering::equal;
    } else if (result < 0) {
        return std::strong_ordering::less;
    } else {
        return std::strong_ordering::greater;
    }
}
#endif

inline bool String16::operator<(const char16_t* other) const
{
    return strcmp16(mString, other) < 0;
}

inline bool String16::operator<=(const char16_t* other) const
{
    return strcmp16(mString, other) <= 0;
}

inline bool String16::operator==(const char16_t* other) const
{
    return strcmp16(mString, other) == 0;
}

inline bool String16::operator!=(const char16_t* other) const
{
    return strcmp16(mString, other) != 0;
}

inline bool String16::operator>=(const char16_t* other) const
{
    return strcmp16(mString, other) >= 0;
}

inline bool String16::operator>(const char16_t* other) const
{
    return strcmp16(mString, other) > 0;
}

#if __cplusplus >= 202002L
inline std::strong_ordering String16::operator<=>(const char16_t* other) const {
    int result = strcmp16(mString, other);
    if (result == 0) {
        return std::strong_ordering::equal;
    } else if (result < 0) {
        return std::strong_ordering::less;
    } else {
        return std::strong_ordering::greater;
    }
}
#endif

inline String16::operator const char16_t*() const
{
    return mString;
}

inline String16::operator std::u16string_view() const
{
    return {mString, length()};
}

}  // namespace android

// ---------------------------------------------------------------------------

#endif // ANDROID_STRING16_H

```

`app/src/main/cpp/external/AOSP/include/utils/String8.h`:

```h
/*
 * Copyright (C) 2005 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#ifndef ANDROID_STRING8_H
#define ANDROID_STRING8_H

#include <iostream>
#include <string>
#include <string_view>

#include <utils/Errors.h>
#include <utils/Unicode.h>
#include <utils/TypeHelpers.h>

#include <string.h> // for strcmp
#include <stdarg.h>

#if __cplusplus >= 202002L
#include <compare>
#endif

// ---------------------------------------------------------------------------

namespace android {

class String16;

// DO NOT USE: please use std::string

//! This is a string holding UTF-8 characters. Does not allow the value more
// than 0x10FFFF, which is not valid unicode codepoint.
class String8
{
public:
                                String8();
                                String8(const String8& o);
    explicit                    String8(const char* o);
    explicit                    String8(const char* o, size_t numChars);
    explicit                    String8(std::string_view o);

    explicit                    String8(const String16& o);
    explicit                    String8(const char16_t* o);
    explicit                    String8(const char16_t* o, size_t numChars);
    explicit                    String8(const char32_t* o);
    explicit                    String8(const char32_t* o, size_t numChars);
                                ~String8();

    static String8              format(const char* fmt, ...) __attribute__((format (printf, 1, 2)));
    static String8              formatV(const char* fmt, va_list args);

    inline  const char*         c_str() const;

    inline  size_t              size() const;
    inline  size_t              bytes() const;
    inline  bool                empty() const;

            size_t              length() const;

            void                clear();

            void                setTo(const String8& other);
            status_t            setTo(const char* other);
            status_t            setTo(const char* other, size_t numChars);
            status_t            setTo(const char16_t* other, size_t numChars);
            status_t            setTo(const char32_t* other,
                                      size_t length);

            status_t            append(const String8& other);
            status_t            append(const char* other);
            status_t            append(const char* other, size_t numChars);

            status_t            appendFormat(const char* fmt, ...)
                    __attribute__((format (printf, 2, 3)));
            status_t            appendFormatV(const char* fmt, va_list args);

    inline  String8&            operator=(const String8& other);
    inline  String8&            operator=(const char* other);

    inline  String8&            operator+=(const String8& other);
    inline  String8             operator+(const String8& other) const;

    inline  String8&            operator+=(const char* other);
    inline  String8             operator+(const char* other) const;

    inline  int                 compare(const String8& other) const;

    inline  bool                operator<(const String8& other) const;
    inline  bool                operator<=(const String8& other) const;
    inline  bool                operator==(const String8& other) const;
    inline  bool                operator!=(const String8& other) const;
    inline  bool                operator>=(const String8& other) const;
    inline  bool                operator>(const String8& other) const;
#if __cplusplus >= 202002L
    inline std::strong_ordering operator<=>(const String8& other) const;
#endif

    inline  bool                operator<(const char* other) const;
    inline  bool                operator<=(const char* other) const;
    inline  bool                operator==(const char* other) const;
    inline  bool                operator!=(const char* other) const;
    inline  bool                operator>=(const char* other) const;
    inline  bool                operator>(const char* other) const;
#if __cplusplus >= 202002L
    inline std::strong_ordering operator<=>(const char* other) const;
#endif

    inline                      operator const char*() const;

    inline explicit             operator std::string_view() const;

            char*               lockBuffer(size_t size);
            void                unlockBuffer();
            status_t            unlockBuffer(size_t size);

            // return the index of the first byte of other in this at or after
            // start, or -1 if not found
            ssize_t             find(const char* other, size_t start = 0) const;
    inline  ssize_t             find(const String8& other, size_t start = 0) const;

            // return true if this string contains the specified substring
    inline  bool                contains(const char* other) const;
    inline  bool                contains(const String8& other) const;

            // removes all occurrence of the specified substring
            // returns true if any were found and removed
            bool                removeAll(const char* other);
    inline  bool                removeAll(const String8& other);

            void                toLower();

private:
            String8 getPathDir(void) const;
            String8 getPathExtension(void) const;

            status_t            real_append(const char* other, size_t numChars);

            const char* mString;

// These symbols are for potential backward compatibility with prebuilts. To be removed.
#ifdef ENABLE_STRING8_OBSOLETE_METHODS
public:
#else
private:
#endif
    inline  const char*         string() const;
    inline  bool                isEmpty() const;
};

// String8 can be trivially moved using memcpy() because moving does not
// require any change to the underlying SharedBuffer contents or reference count.
ANDROID_TRIVIAL_MOVE_TRAIT(String8)

static inline std::ostream& operator<<(std::ostream& os, const String8& str) {
    os << str.c_str();
    return os;
}

// ---------------------------------------------------------------------------
// No user servicable parts below.

inline int compare_type(const String8& lhs, const String8& rhs)
{
    return lhs.compare(rhs);
}

inline int strictly_order_type(const String8& lhs, const String8& rhs)
{
    return compare_type(lhs, rhs) < 0;
}

inline const char* String8::c_str() const
{
    return mString;
}
inline const char* String8::string() const
{
    return mString;
}

inline size_t String8::size() const
{
    return length();
}

inline bool String8::empty() const
{
    return length() == 0;
}

inline bool String8::isEmpty() const
{
    return length() == 0;
}

inline size_t String8::bytes() const
{
    return length();
}

inline ssize_t String8::find(const String8& other, size_t start) const
{
    return find(other.c_str(), start);
}

inline bool String8::contains(const char* other) const
{
    return find(other) >= 0;
}

inline bool String8::contains(const String8& other) const
{
    return contains(other.c_str());
}

inline bool String8::removeAll(const String8& other)
{
    return removeAll(other.c_str());
}

inline String8& String8::operator=(const String8& other)
{
    setTo(other);
    return *this;
}

inline String8& String8::operator=(const char* other)
{
    setTo(other);
    return *this;
}

inline String8& String8::operator+=(const String8& other)
{
    append(other);
    return *this;
}

inline String8 String8::operator+(const String8& other) const
{
    String8 tmp(*this);
    tmp += other;
    return tmp;
}

inline String8& String8::operator+=(const char* other)
{
    append(other);
    return *this;
}

inline String8 String8::operator+(const char* other) const
{
    String8 tmp(*this);
    tmp += other;
    return tmp;
}

inline int String8::compare(const String8& other) const
{
    return strcmp(mString, other.mString);
}

inline bool String8::operator<(const String8& other) const
{
    return strcmp(mString, other.mString) < 0;
}

inline bool String8::operator<=(const String8& other) const
{
    return strcmp(mString, other.mString) <= 0;
}

inline bool String8::operator==(const String8& other) const
{
    return strcmp(mString, other.mString) == 0;
}

inline bool String8::operator!=(const String8& other) const
{
    return strcmp(mString, other.mString) != 0;
}

inline bool String8::operator>=(const String8& other) const
{
    return strcmp(mString, other.mString) >= 0;
}

inline bool String8::operator>(const String8& other) const
{
    return strcmp(mString, other.mString) > 0;
}

#if __cplusplus >= 202002L
inline std::strong_ordering String8::operator<=>(const String8& other) const {
    int result = strcmp(mString, other.mString);
    if (result == 0) {
        return std::strong_ordering::equal;
    } else if (result < 0) {
        return std::strong_ordering::less;
    } else {
        return std::strong_ordering::greater;
    }
}
#endif

inline bool String8::operator<(const char* other) const
{
    return strcmp(mString, other) < 0;
}

inline bool String8::operator<=(const char* other) const
{
    return strcmp(mString, other) <= 0;
}

inline bool String8::operator==(const char* other) const
{
    return strcmp(mString, other) == 0;
}

inline bool String8::operator!=(const char* other) const
{
    return strcmp(mString, other) != 0;
}

inline bool String8::operator>=(const char* other) const
{
    return strcmp(mString, other) >= 0;
}

inline bool String8::operator>(const char* other) const
{
    return strcmp(mString, other) > 0;
}

#if __cplusplus >= 202002L
inline std::strong_ordering String8::operator<=>(const char* other) const {
    int result = strcmp(mString, other);
    if (result == 0) {
        return std::strong_ordering::equal;
    } else if (result < 0) {
        return std::strong_ordering::less;
    } else {
        return std::strong_ordering::greater;
    }
}
#endif

inline String8::operator const char*() const
{
    return mString;
}

inline String8::String8(std::string_view o) : String8(o.data(), o.length()) { }

inline String8::operator std::string_view() const
{
    return {mString, length()};
}

}  // namespace android

// ---------------------------------------------------------------------------

#endif // ANDROID_STRING8_H

```

`app/src/main/cpp/external/AOSP/include/utils/StrongPointer.h`:

```h
/*
 * Copyright (C) 2005 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#ifndef ANDROID_STRONG_POINTER_H
#define ANDROID_STRONG_POINTER_H

#include <functional>
#include <type_traits>  // for common_type.

// ---------------------------------------------------------------------------
namespace android {

template<typename T> class wp;

// ---------------------------------------------------------------------------

template<typename T>
class sp {
public:
    inline sp() : m_ptr(nullptr) { }

    // The old way of using sp<> was like this. This is bad because it relies
    // on implicit conversion to sp<>, which we would like to remove (if an
    // object is being managed some other way, this is double-ownership). We
    // want to move away from this:
    //
    //     sp<Foo> foo = new Foo(...); // DO NOT DO THIS
    //
    // Instead, prefer to do this:
    //
    //     sp<Foo> foo = sp<Foo>::make(...); // DO THIS
    //
    // Sometimes, in order to use this, when a constructor is marked as private,
    // you may need to add this to your class:
    //
    //     friend class sp<Foo>;
    template <typename... Args>
    static inline sp<T> make(Args&&... args);

    // if nullptr, returns nullptr
    //
    // if a strong pointer is already available, this will retrieve it,
    // otherwise, this will abort
    static inline sp<T> fromExisting(T* other);

    // for more information about this macro and correct RefBase usage, see
    // the comment at the top of utils/RefBase.h
#if defined(ANDROID_UTILS_REF_BASE_DISABLE_IMPLICIT_CONSTRUCTION)
    sp(std::nullptr_t) : sp() {}
#else
    sp(T* other);  // NOLINT(implicit)
    template <typename U>
    sp(U* other);  // NOLINT(implicit)
    sp& operator=(T* other);
    template <typename U>
    sp& operator=(U* other);
#endif

    sp(const sp<T>& other);
    sp(sp<T>&& other) noexcept;

    template<typename U> sp(const sp<U>& other);  // NOLINT(implicit)
    template<typename U> sp(sp<U>&& other);  // NOLINT(implicit)

    // Cast a strong pointer directly from one type to another. Constructors
    // allow changing types, but only if they are pointer-compatible. This does
    // a static_cast internally.
    template <typename U>
    static inline sp<T> cast(const sp<U>& other);

    ~sp();

    // Assignment

    sp& operator = (const sp<T>& other);
    sp& operator=(sp<T>&& other) noexcept;

    template<typename U> sp& operator = (const sp<U>& other);
    template<typename U> sp& operator = (sp<U>&& other);

    //! Special optimization for use by ProcessState (and nobody else).
    void force_set(T* other);

    // Reset

    void clear();

    // Releases the ownership of the object managed by this instance of sp, if any.
    // The caller is now responsible for managing it. That is, the caller must ensure
    // decStrong() is called when the pointer is no longer used.
    [[nodiscard]] inline T* release() noexcept {
        auto ret = m_ptr;
        m_ptr = nullptr;
        return ret;
    }

    // Accessors

    inline T&       operator* () const     { return *m_ptr; }
    inline T*       operator-> () const    { return m_ptr;  }
    inline T*       get() const            { return m_ptr; }
    inline explicit operator bool () const { return m_ptr != nullptr; }

    // Punt these to the wp<> implementation.
    template<typename U>
    inline bool operator == (const wp<U>& o) const {
        return o == *this;
    }

    template<typename U>
    inline bool operator != (const wp<U>& o) const {
        return o != *this;
    }

private:
    template<typename Y> friend class sp;
    template<typename Y> friend class wp;
    void set_pointer(T* ptr);
    T* m_ptr;
};

#define COMPARE_STRONG(_op_)                                           \
    template <typename T, typename U>                                  \
    static inline bool operator _op_(const sp<T>& t, const sp<U>& u) { \
        return t.get() _op_ u.get();                                   \
    }                                                                  \
    template <typename T, typename U>                                  \
    static inline bool operator _op_(const T* t, const sp<U>& u) {     \
        return t _op_ u.get();                                         \
    }                                                                  \
    template <typename T, typename U>                                  \
    static inline bool operator _op_(const sp<T>& t, const U* u) {     \
        return t.get() _op_ u;                                         \
    }                                                                  \
    template <typename T>                                              \
    static inline bool operator _op_(const sp<T>& t, std::nullptr_t) { \
        return t.get() _op_ nullptr;                                   \
    }                                                                  \
    template <typename T>                                              \
    static inline bool operator _op_(std::nullptr_t, const sp<T>& t) { \
        return nullptr _op_ t.get();                                   \
    }

template <template <typename C> class comparator, typename T, typename U>
static inline bool _sp_compare_(T* a, U* b) {
    return comparator<typename std::common_type<T*, U*>::type>()(a, b);
}

#define COMPARE_STRONG_FUNCTIONAL(_op_, _compare_)                     \
    template <typename T, typename U>                                  \
    static inline bool operator _op_(const sp<T>& t, const sp<U>& u) { \
        return _sp_compare_<_compare_>(t.get(), u.get());              \
    }                                                                  \
    template <typename T, typename U>                                  \
    static inline bool operator _op_(const T* t, const sp<U>& u) {     \
        return _sp_compare_<_compare_>(t, u.get());                    \
    }                                                                  \
    template <typename T, typename U>                                  \
    static inline bool operator _op_(const sp<T>& t, const U* u) {     \
        return _sp_compare_<_compare_>(t.get(), u);                    \
    }                                                                  \
    template <typename T>                                              \
    static inline bool operator _op_(const sp<T>& t, std::nullptr_t) { \
        return _sp_compare_<_compare_>(t.get(), nullptr);              \
    }                                                                  \
    template <typename T>                                              \
    static inline bool operator _op_(std::nullptr_t, const sp<T>& t) { \
        return _sp_compare_<_compare_>(nullptr, t.get());              \
    }

COMPARE_STRONG(==)
COMPARE_STRONG(!=)
COMPARE_STRONG_FUNCTIONAL(>, std::greater)
COMPARE_STRONG_FUNCTIONAL(<, std::less)
COMPARE_STRONG_FUNCTIONAL(<=, std::less_equal)
COMPARE_STRONG_FUNCTIONAL(>=, std::greater_equal)

#undef COMPARE_STRONG
#undef COMPARE_STRONG_FUNCTIONAL

// For code size reasons, we do not want these inlined or templated.
void sp_report_race();

// ---------------------------------------------------------------------------
// No user serviceable parts below here.

// TODO: Ideally we should find a way to increment the reference count before running the
// constructor, so that generating an sp<> to this in the constructor is no longer dangerous.
template <typename T>
template <typename... Args>
sp<T> sp<T>::make(Args&&... args) {
    T* t = new T(std::forward<Args>(args)...);
    sp<T> result;
    result.m_ptr = t;
    t->incStrong(t);
    return result;
}

template <typename T>
sp<T> sp<T>::fromExisting(T* other) {
    if (other) {
        other->incStrongRequireStrong(other);
        sp<T> result;
        result.m_ptr = other;
        return result;
    }
    return nullptr;
}

#if !defined(ANDROID_UTILS_REF_BASE_DISABLE_IMPLICIT_CONSTRUCTION)
template<typename T>
sp<T>::sp(T* other)
        : m_ptr(other) {
    if (other) {
        other->incStrong(this);
    }
}

template <typename T>
template <typename U>
sp<T>::sp(U* other) : m_ptr(other) {
    if (other) {
        (static_cast<T*>(other))->incStrong(this);
    }
}

template <typename T>
sp<T>& sp<T>::operator=(T* other) {
    T* oldPtr(*const_cast<T* volatile*>(&m_ptr));
    if (other) {
        other->incStrong(this);
    }
    if (oldPtr) oldPtr->decStrong(this);
    if (oldPtr != *const_cast<T* volatile*>(&m_ptr)) sp_report_race();
    m_ptr = other;
    return *this;
}
#endif

template<typename T>
sp<T>::sp(const sp<T>& other)
        : m_ptr(other.m_ptr) {
    if (m_ptr)
        m_ptr->incStrong(this);
}

template <typename T>
sp<T>::sp(sp<T>&& other) noexcept : m_ptr(other.m_ptr) {
    other.m_ptr = nullptr;
}

template<typename T> template<typename U>
sp<T>::sp(const sp<U>& other)
        : m_ptr(other.m_ptr) {
    if (m_ptr)
        m_ptr->incStrong(this);
}

template<typename T> template<typename U>
sp<T>::sp(sp<U>&& other)
        : m_ptr(other.m_ptr) {
    other.m_ptr = nullptr;
}

template <typename T>
template <typename U>
sp<T> sp<T>::cast(const sp<U>& other) {
    return sp<T>::fromExisting(static_cast<T*>(other.get()));
}

template<typename T>
sp<T>::~sp() {
    if (m_ptr)
        m_ptr->decStrong(this);
}

template<typename T>
sp<T>& sp<T>::operator =(const sp<T>& other) {
    // Force m_ptr to be read twice, to heuristically check for data races.
    T* oldPtr(*const_cast<T* volatile*>(&m_ptr));
    T* otherPtr(other.m_ptr);
    if (otherPtr) otherPtr->incStrong(this);
    if (oldPtr) oldPtr->decStrong(this);
    if (oldPtr != *const_cast<T* volatile*>(&m_ptr)) sp_report_race();
    m_ptr = otherPtr;
    return *this;
}

template <typename T>
sp<T>& sp<T>::operator=(sp<T>&& other) noexcept {
    T* oldPtr(*const_cast<T* volatile*>(&m_ptr));
    if (oldPtr) oldPtr->decStrong(this);
    if (oldPtr != *const_cast<T* volatile*>(&m_ptr)) sp_report_race();
    m_ptr = other.m_ptr;
    other.m_ptr = nullptr;
    return *this;
}

template<typename T> template<typename U>
sp<T>& sp<T>::operator =(const sp<U>& other) {
    T* oldPtr(*const_cast<T* volatile*>(&m_ptr));
    T* otherPtr(other.m_ptr);
    if (otherPtr) otherPtr->incStrong(this);
    if (oldPtr) oldPtr->decStrong(this);
    if (oldPtr != *const_cast<T* volatile*>(&m_ptr)) sp_report_race();
    m_ptr = otherPtr;
    return *this;
}

template<typename T> template<typename U>
sp<T>& sp<T>::operator =(sp<U>&& other) {
    T* oldPtr(*const_cast<T* volatile*>(&m_ptr));
    if (m_ptr) m_ptr->decStrong(this);
    if (oldPtr != *const_cast<T* volatile*>(&m_ptr)) sp_report_race();
    m_ptr = other.m_ptr;
    other.m_ptr = nullptr;
    return *this;
}

#if !defined(ANDROID_UTILS_REF_BASE_DISABLE_IMPLICIT_CONSTRUCTION)
template<typename T> template<typename U>
sp<T>& sp<T>::operator =(U* other) {
    T* oldPtr(*const_cast<T* volatile*>(&m_ptr));
    if (other) (static_cast<T*>(other))->incStrong(this);
    if (oldPtr) oldPtr->decStrong(this);
    if (oldPtr != *const_cast<T* volatile*>(&m_ptr)) sp_report_race();
    m_ptr = other;
    return *this;
}
#endif

template<typename T>
void sp<T>::force_set(T* other) {
    other->forceIncStrong(this);
    m_ptr = other;
}

template<typename T>
void sp<T>::clear() {
    T* oldPtr(*const_cast<T* volatile*>(&m_ptr));
    if (oldPtr) {
        oldPtr->decStrong(this);
        if (oldPtr != *const_cast<T* volatile*>(&m_ptr)) sp_report_race();
        m_ptr = nullptr;
    }
}

template<typename T>
void sp<T>::set_pointer(T* ptr) {
    m_ptr = ptr;
}

}  // namespace android

// ---------------------------------------------------------------------------

#endif // ANDROID_STRONG_POINTER_H

```

`app/src/main/cpp/external/AOSP/include/utils/TypeHelpers.h`:

```h
/*
 * Copyright (C) 2005 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#ifndef ANDROID_TYPE_HELPERS_H
#define ANDROID_TYPE_HELPERS_H

#include <new>
#include <type_traits>

#include <stdint.h>
#include <string.h>
#include <sys/types.h>

// ---------------------------------------------------------------------------

namespace android {

/*
 * Types traits
 */

template <typename T> struct trait_trivial_ctor { enum { value = false }; };
template <typename T> struct trait_trivial_dtor { enum { value = false }; };
template <typename T> struct trait_trivial_copy { enum { value = false }; };
template <typename T> struct trait_trivial_move { enum { value = false }; };
template <typename T> struct trait_pointer      { enum { value = false }; };
template <typename T> struct trait_pointer<T*>  { enum { value = true }; };

template <typename TYPE>
struct traits {
    enum {
        // whether this type is a pointer
        is_pointer          = trait_pointer<TYPE>::value,
        // whether this type's constructor is a no-op
        has_trivial_ctor    = is_pointer || trait_trivial_ctor<TYPE>::value,
        // whether this type's destructor is a no-op
        has_trivial_dtor    = is_pointer || trait_trivial_dtor<TYPE>::value,
        // whether this type type can be copy-constructed with memcpy
        has_trivial_copy    = is_pointer || trait_trivial_copy<TYPE>::value,
        // whether this type can be moved with memmove
        has_trivial_move    = is_pointer || trait_trivial_move<TYPE>::value
    };
};

template <typename T, typename U>
struct aggregate_traits {
    enum {
        is_pointer          = false,
        has_trivial_ctor    =
            traits<T>::has_trivial_ctor && traits<U>::has_trivial_ctor,
        has_trivial_dtor    =
            traits<T>::has_trivial_dtor && traits<U>::has_trivial_dtor,
        has_trivial_copy    =
            traits<T>::has_trivial_copy && traits<U>::has_trivial_copy,
        has_trivial_move    =
            traits<T>::has_trivial_move && traits<U>::has_trivial_move
    };
};

#define ANDROID_TRIVIAL_CTOR_TRAIT( T ) \
    template<> struct trait_trivial_ctor< T >   { enum { value = true }; };

#define ANDROID_TRIVIAL_DTOR_TRAIT( T ) \
    template<> struct trait_trivial_dtor< T >   { enum { value = true }; };

#define ANDROID_TRIVIAL_COPY_TRAIT( T ) \
    template<> struct trait_trivial_copy< T >   { enum { value = true }; };

#define ANDROID_TRIVIAL_MOVE_TRAIT( T ) \
    template<> struct trait_trivial_move< T >   { enum { value = true }; };

#define ANDROID_BASIC_TYPES_TRAITS( T ) \
    ANDROID_TRIVIAL_CTOR_TRAIT( T ) \
    ANDROID_TRIVIAL_DTOR_TRAIT( T ) \
    ANDROID_TRIVIAL_COPY_TRAIT( T ) \
    ANDROID_TRIVIAL_MOVE_TRAIT( T )

// ---------------------------------------------------------------------------

/*
 * basic types traits
 */

ANDROID_BASIC_TYPES_TRAITS( void )
ANDROID_BASIC_TYPES_TRAITS( bool )
ANDROID_BASIC_TYPES_TRAITS( char )
ANDROID_BASIC_TYPES_TRAITS( unsigned char )
ANDROID_BASIC_TYPES_TRAITS( short )
ANDROID_BASIC_TYPES_TRAITS( unsigned short )
ANDROID_BASIC_TYPES_TRAITS( int )
ANDROID_BASIC_TYPES_TRAITS( unsigned int )
ANDROID_BASIC_TYPES_TRAITS( long )
ANDROID_BASIC_TYPES_TRAITS( unsigned long )
ANDROID_BASIC_TYPES_TRAITS( long long )
ANDROID_BASIC_TYPES_TRAITS( unsigned long long )
ANDROID_BASIC_TYPES_TRAITS( float )
ANDROID_BASIC_TYPES_TRAITS( double )

template<typename T> struct trait_trivial_ctor<T*>   { enum { value = true }; };
template<typename T> struct trait_trivial_dtor<T*>   { enum { value = true }; };
template<typename T> struct trait_trivial_copy<T*>   { enum { value = true }; };
template<typename T> struct trait_trivial_move<T*>   { enum { value = true }; };

// ---------------------------------------------------------------------------


/*
 * compare and order types
 */

template<typename TYPE> inline
int strictly_order_type(const TYPE& lhs, const TYPE& rhs) {
    return (lhs < rhs) ? 1 : 0;
}

template<typename TYPE> inline
int compare_type(const TYPE& lhs, const TYPE& rhs) {
    return strictly_order_type(rhs, lhs) - strictly_order_type(lhs, rhs);
}

/*
 * create, destroy, copy and move types...
 */

template<typename TYPE> inline
void construct_type(TYPE* p, size_t n) {
    if (!traits<TYPE>::has_trivial_ctor) {
        while (n > 0) {
            n--;
            new(p++) TYPE;
        }
    }
}

template<typename TYPE> inline
void destroy_type(TYPE* p, size_t n) {
    if (!traits<TYPE>::has_trivial_dtor) {
        while (n > 0) {
            n--;
            p->~TYPE();
            p++;
        }
    }
}

template<typename TYPE>
typename std::enable_if<traits<TYPE>::has_trivial_copy>::type
inline
copy_type(TYPE* d, const TYPE* s, size_t n) {
    memcpy(d,s,n*sizeof(TYPE));
}

template<typename TYPE>
typename std::enable_if<!traits<TYPE>::has_trivial_copy>::type
inline
copy_type(TYPE* d, const TYPE* s, size_t n) {
    while (n > 0) {
        n--;
        new(d) TYPE(*s);
        d++, s++;
    }
}

template<typename TYPE> inline
void splat_type(TYPE* where, const TYPE* what, size_t n) {
    if (!traits<TYPE>::has_trivial_copy) {
        while (n > 0) {
            n--;
            new(where) TYPE(*what);
            where++;
        }
    } else {
        while (n > 0) {
            n--;
            *where++ = *what;
        }
    }
}

template<typename TYPE>
struct use_trivial_move : public std::integral_constant<bool,
    (traits<TYPE>::has_trivial_dtor && traits<TYPE>::has_trivial_copy)
    || traits<TYPE>::has_trivial_move
> {};

template<typename TYPE>
typename std::enable_if<use_trivial_move<TYPE>::value>::type
inline
move_forward_type(TYPE* d, const TYPE* s, size_t n = 1) {
    memmove(reinterpret_cast<void*>(d), s, n * sizeof(TYPE));
}

template<typename TYPE>
typename std::enable_if<!use_trivial_move<TYPE>::value>::type
inline
move_forward_type(TYPE* d, const TYPE* s, size_t n = 1) {
    d += n;
    s += n;
    while (n > 0) {
        n--;
        --d, --s;
        if (!traits<TYPE>::has_trivial_copy) {
            new(d) TYPE(*s);
        } else {
            *d = *s;
        }
        if (!traits<TYPE>::has_trivial_dtor) {
            s->~TYPE();
        }
    }
}

template<typename TYPE>
typename std::enable_if<use_trivial_move<TYPE>::value>::type
inline
move_backward_type(TYPE* d, const TYPE* s, size_t n = 1) {
    memmove(reinterpret_cast<void*>(d), s, n * sizeof(TYPE));
}

template<typename TYPE>
typename std::enable_if<!use_trivial_move<TYPE>::value>::type
inline
move_backward_type(TYPE* d, const TYPE* s, size_t n = 1) {
    while (n > 0) {
        n--;
        if (!traits<TYPE>::has_trivial_copy) {
            new(d) TYPE(*s);
        } else {
            *d = *s;
        }
        if (!traits<TYPE>::has_trivial_dtor) {
            s->~TYPE();
        }
        d++, s++;
    }
}

// ---------------------------------------------------------------------------

/*
 * a key/value pair
 */

template <typename KEY, typename VALUE>
struct key_value_pair_t {
    typedef KEY key_t;
    typedef VALUE value_t;

    KEY     key;
    VALUE   value;
    key_value_pair_t() { }
    key_value_pair_t(const key_value_pair_t& o) : key(o.key), value(o.value) { }
    key_value_pair_t& operator=(const key_value_pair_t& o) {
        key = o.key;
        value = o.value;
        return *this;
    }
    key_value_pair_t(const KEY& k, const VALUE& v) : key(k), value(v)  { }
    explicit key_value_pair_t(const KEY& k) : key(k) { }
    inline bool operator < (const key_value_pair_t& o) const {
        return strictly_order_type(key, o.key);
    }
    inline const KEY& getKey() const {
        return key;
    }
    inline const VALUE& getValue() const {
        return value;
    }
};

template <typename K, typename V>
struct trait_trivial_ctor< key_value_pair_t<K, V> >
{ enum { value = aggregate_traits<K,V>::has_trivial_ctor }; };
template <typename K, typename V>
struct trait_trivial_dtor< key_value_pair_t<K, V> >
{ enum { value = aggregate_traits<K,V>::has_trivial_dtor }; };
template <typename K, typename V>
struct trait_trivial_copy< key_value_pair_t<K, V> >
{ enum { value = aggregate_traits<K,V>::has_trivial_copy }; };
template <typename K, typename V>
struct trait_trivial_move< key_value_pair_t<K, V> >
{ enum { value = aggregate_traits<K,V>::has_trivial_move }; };

// ---------------------------------------------------------------------------

/*
 * Hash codes.
 */
typedef uint32_t hash_t;

template <typename TKey>
hash_t hash_type(const TKey& key);

/* Built-in hash code specializations */
#define ANDROID_INT32_HASH(T) \
        template <> inline hash_t hash_type(const T& value) { return hash_t(value); }
#define ANDROID_INT64_HASH(T) \
        template <> inline hash_t hash_type(const T& value) { \
                return hash_t((value >> 32) ^ value); }
#define ANDROID_REINTERPRET_HASH(T, R) \
        template <> inline hash_t hash_type(const T& value) { \
            R newValue; \
            static_assert(sizeof(newValue) == sizeof(value), "size mismatch"); \
            memcpy(&newValue, &value, sizeof(newValue)); \
            return hash_type(newValue); \
        }

ANDROID_INT32_HASH(bool)
ANDROID_INT32_HASH(int8_t)
ANDROID_INT32_HASH(uint8_t)
ANDROID_INT32_HASH(int16_t)
ANDROID_INT32_HASH(uint16_t)
ANDROID_INT32_HASH(int32_t)
ANDROID_INT32_HASH(uint32_t)
ANDROID_INT64_HASH(int64_t)
ANDROID_INT64_HASH(uint64_t)
ANDROID_REINTERPRET_HASH(float, uint32_t)
ANDROID_REINTERPRET_HASH(double, uint64_t)

template <typename T> inline hash_t hash_type(T* const & value) {
    return hash_type(uintptr_t(value));
}

}  // namespace android

// ---------------------------------------------------------------------------

#endif // ANDROID_TYPE_HELPERS_H

```

`app/src/main/cpp/external/AOSP/include/utils/Unicode.h`:

```h
/*
 * Copyright (C) 2005 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#ifndef ANDROID_UNICODE_H
#define ANDROID_UNICODE_H

#include <sys/types.h>
#include <stdint.h>

extern "C" {

// Standard string functions on char16_t strings.
int strcmp16(const char16_t *, const char16_t *);
int strncmp16(const char16_t *s1, const char16_t *s2, size_t n);
size_t strlen16(const char16_t *);
size_t strnlen16(const char16_t *, size_t);
char16_t *strstr16(const char16_t*, const char16_t*);

// Version of comparison that supports embedded NULs.
// This is different than strncmp() because we don't stop
// at a nul character and consider the strings to be different
// if the lengths are different (thus we need to supply the
// lengths of both strings).  This can also be used when
// your string is not nul-terminated as it will have the
// equivalent result as strcmp16 (unlike strncmp16).
int strzcmp16(const char16_t *s1, size_t n1, const char16_t *s2, size_t n2);

/**
 * Measure the length of a UTF-32 string in UTF-8. If the string is invalid
 * such as containing a surrogate character, -1 will be returned.
 */
ssize_t utf32_to_utf8_length(const char32_t *src, size_t src_len);

/**
 * Stores a UTF-8 string converted from "src" in "dst", if "dst_length" is not
 * large enough to store the string, the part of the "src" string is stored
 * into "dst" as much as possible. See the examples for more detail.
 * Returns the size actually used for storing the string.
 * dst" is not nul-terminated when dst_len is fully used (like strncpy).
 *
 * \code
 * Example 1
 * "src" == \u3042\u3044 (\xE3\x81\x82\xE3\x81\x84)
 * "src_len" == 2
 * "dst_len" >= 7
 * ->
 * Returned value == 6
 * "dst" becomes \xE3\x81\x82\xE3\x81\x84\0
 * (note that "dst" is nul-terminated)
 *
 * Example 2
 * "src" == \u3042\u3044 (\xE3\x81\x82\xE3\x81\x84)
 * "src_len" == 2
 * "dst_len" == 5
 * ->
 * Returned value == 3
 * "dst" becomes \xE3\x81\x82\0
 * (note that "dst" is nul-terminated, but \u3044 is not stored in "dst"
 * since "dst" does not have enough size to store the character)
 *
 * Example 3
 * "src" == \u3042\u3044 (\xE3\x81\x82\xE3\x81\x84)
 * "src_len" == 2
 * "dst_len" == 6
 * ->
 * Returned value == 6
 * "dst" becomes \xE3\x81\x82\xE3\x81\x84
 * (note that "dst" is NOT nul-terminated, like strncpy)
 * \endcode
 */
void utf32_to_utf8(const char32_t* src, size_t src_len, char* dst, size_t dst_len);

/**
 * Returns the unicode value at "index".
 * Returns -1 when the index is invalid (equals to or more than "src_len").
 * If returned value is positive, it is able to be converted to char32_t, which
 * is unsigned. Then, if "next_index" is not NULL, the next index to be used is
 * stored in "next_index". "next_index" can be NULL.
 */
int32_t utf32_from_utf8_at(const char *src, size_t src_len, size_t index, size_t *next_index);


/**
 * Returns the UTF-8 length of UTF-16 string "src".
 */
ssize_t utf16_to_utf8_length(const char16_t *src, size_t src_len);

/**
 * Converts a UTF-16 string to UTF-8. The destination buffer must be large
 * enough to fit the UTF-16 as measured by utf16_to_utf8_length with an added
 * NUL terminator.
 */
void utf16_to_utf8(const char16_t* src, size_t src_len, char* dst, size_t dst_len);

/**
 * Returns the UTF-16 length of UTF-8 string "src". Returns -1 in case
 * it's invalid utf8. No buffer over-read occurs because of bound checks. Using overreadIsFatal you
 * can ask to log a message and fail in case the invalid utf8 could have caused an override if no
 * bound checks were used (otherwise -1 is returned).
 */
ssize_t utf8_to_utf16_length(const uint8_t* src, size_t srcLen, bool overreadIsFatal = false);

/**
 * Convert UTF-8 to UTF-16 including surrogate pairs.
 * Returns a pointer to the end of the string (where a NUL terminator might go
 * if you wanted to add one). At most dstLen characters are written; it won't emit half a surrogate
 * pair. If dstLen == 0 nothing is written and dst is returned. If dstLen > SSIZE_MAX it aborts
 * (this being probably a negative number returned as an error and casted to unsigned).
 */
char16_t* utf8_to_utf16_no_null_terminator(
        const uint8_t* src, size_t srcLen, char16_t* dst, size_t dstLen);

/**
 * Convert UTF-8 to UTF-16 including surrogate pairs. At most dstLen - 1
 * characters are written; it won't emit half a surrogate pair; and a NUL terminator is appended
 * after. dstLen - 1 can be measured beforehand using utf8_to_utf16_length. Aborts if dstLen == 0
 * (at least one character is needed for the NUL terminator) or dstLen > SSIZE_MAX (the latter
 * case being likely a negative number returned as an error and casted to unsigned) . Returns a
 * pointer to the NUL terminator.
 */
char16_t *utf8_to_utf16(
        const uint8_t* src, size_t srcLen, char16_t* dst, size_t dstLen);

}

#endif

```

`app/src/main/cpp/external/AOSP/include/utils/Vector.h`:

```h
/*
 * Copyright (C) 2005 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#ifndef ANDROID_VECTOR_H
#define ANDROID_VECTOR_H

#include <stdint.h>
#include <sys/types.h>

#include <utils/TypeHelpers.h>
#include <utils/VectorImpl.h>
#ifndef __has_attribute
#define __has_attribute(x) 0
#endif

/*
 * Used to exclude some functions from CFI.
 */
#if __has_attribute(no_sanitize)
#define UTILS_VECTOR_NO_CFI __attribute__((no_sanitize("cfi")))
#else
#define UTILS_VECTOR_NO_CFI
#endif

// ---------------------------------------------------------------------------

namespace android {

template <typename TYPE>
class SortedVector;

/*!
 * The main templated vector class ensuring type safety
 * while making use of VectorImpl.
 * This is the class users want to use.
 *
 * DO NOT USE: please use std::vector
 */

template <class TYPE>
class Vector : private VectorImpl
{
public:
            typedef TYPE    value_type;

    /*!
     * Constructors and destructors
     */

                            Vector();
                            Vector(const Vector<TYPE>& rhs);
    explicit                Vector(const SortedVector<TYPE>& rhs);
    virtual                 ~Vector();

    /*! copy operator */
    Vector<TYPE>& operator=(const Vector<TYPE>& rhs);        // NOLINT(cert-oop54-cpp)
    Vector<TYPE>& operator=(const SortedVector<TYPE>& rhs);  // NOLINT(cert-oop54-cpp)

    /*
     * empty the vector
     */

    inline  void            clear()             { VectorImpl::clear(); }

    /*!
     * vector stats
     */

    //! returns number of items in the vector
    inline  size_t          size() const                { return VectorImpl::size(); }
    //! returns whether or not the vector is empty
    inline  bool            isEmpty() const             { return VectorImpl::isEmpty(); }
    //! returns how many items can be stored without reallocating the backing store
    inline  size_t          capacity() const            { return VectorImpl::capacity(); }
    //! sets the capacity. capacity can never be reduced less than size()
    inline  ssize_t         setCapacity(size_t size)    { return VectorImpl::setCapacity(size); }

    /*!
     * set the size of the vector. items are appended with the default
     * constructor, or removed from the end as needed.
     */
    inline  ssize_t         resize(size_t size)         { return VectorImpl::resize(size); }

    /*!
     * C-style array access
     */

    //! read-only C-style access
    inline  const TYPE*     array() const;
    //! read-write C-style access
            TYPE*           editArray();

    /*!
     * accessors
     */

    //! read-only access to an item at a given index
    inline  const TYPE&     operator [] (size_t index) const;
    //! alternate name for operator []
    inline  const TYPE&     itemAt(size_t index) const;
    //! stack-usage of the vector. returns the top of the stack (last element)
            const TYPE&     top() const;

    /*!
     * modifying the array
     */

    //! copy-on write support, grants write access to an item
            TYPE&           editItemAt(size_t index);
    //! grants right access to the top of the stack (last element)
            TYPE&           editTop();

            /*!
             * append/insert another vector
             */

    //! insert another vector at a given index
            ssize_t         insertVectorAt(const Vector<TYPE>& vector, size_t index);

    //! append another vector at the end of this one
            ssize_t         appendVector(const Vector<TYPE>& vector);


    //! insert an array at a given index
            ssize_t         insertArrayAt(const TYPE* array, size_t index, size_t length);

    //! append an array at the end of this vector
            ssize_t         appendArray(const TYPE* array, size_t length);

            /*!
             * add/insert/replace items
             */

    //! insert one or several items initialized with their default constructor
    inline  ssize_t         insertAt(size_t index, size_t numItems = 1);
    //! insert one or several items initialized from a prototype item
            ssize_t         insertAt(const TYPE& prototype_item, size_t index, size_t numItems = 1);
    //! pop the top of the stack (removes the last element). No-op if the stack's empty
    inline  void            pop();
    //! pushes an item initialized with its default constructor
    inline  void            push();
    //! pushes an item on the top of the stack
            void            push(const TYPE& item);
    //! same as push() but returns the index the item was added at (or an error)
    inline  ssize_t         add();
    //! same as push() but returns the index the item was added at (or an error)
            ssize_t         add(const TYPE& item);
    //! replace an item with a new one initialized with its default constructor
    inline  ssize_t         replaceAt(size_t index);
    //! replace an item with a new one
            ssize_t         replaceAt(const TYPE& item, size_t index);

    /*!
     * remove items
     */

    //! remove several items
    inline  ssize_t         removeItemsAt(size_t index, size_t count = 1);
    //! remove one item
    inline  ssize_t         removeAt(size_t index)  { return removeItemsAt(index); }

    /*!
     * sort (stable) the array
     */

     typedef int (*compar_t)(const TYPE* lhs, const TYPE* rhs);
     typedef int (*compar_r_t)(const TYPE* lhs, const TYPE* rhs, void* state);

     inline status_t        sort(compar_t cmp);
     inline status_t        sort(compar_r_t cmp, void* state);

     // for debugging only
     inline size_t getItemSize() const { return itemSize(); }


     /*
      * these inlines add some level of compatibility with STL. eventually
      * we should probably turn things around.
      */
     typedef TYPE* iterator;
     typedef TYPE const* const_iterator;

     inline iterator begin() { return editArray(); }
     inline iterator end()   { return editArray() + size(); }
     inline const_iterator begin() const { return array(); }
     inline const_iterator end() const   { return array() + size(); }
     inline void reserve(size_t n) { setCapacity(n); }
     inline bool empty() const{ return isEmpty(); }
     inline void push_back(const TYPE& item)  { insertAt(item, size(), 1); }
     inline void push_front(const TYPE& item) { insertAt(item, 0, 1); }
     inline iterator erase(iterator pos) {
         ssize_t index = removeItemsAt(static_cast<size_t>(pos-array()));
         return begin() + index;
     }

protected:
    virtual void    do_construct(void* storage, size_t num) const;
    virtual void    do_destroy(void* storage, size_t num) const;
    virtual void    do_copy(void* dest, const void* from, size_t num) const;
    virtual void    do_splat(void* dest, const void* item, size_t num) const;
    virtual void    do_move_forward(void* dest, const void* from, size_t num) const;
    virtual void    do_move_backward(void* dest, const void* from, size_t num) const;
};

// ---------------------------------------------------------------------------
// No user serviceable parts from here...
// ---------------------------------------------------------------------------

template<class TYPE> inline
Vector<TYPE>::Vector()
    : VectorImpl(sizeof(TYPE),
                ((traits<TYPE>::has_trivial_ctor   ? HAS_TRIVIAL_CTOR   : 0)
                |(traits<TYPE>::has_trivial_dtor   ? HAS_TRIVIAL_DTOR   : 0)
                |(traits<TYPE>::has_trivial_copy   ? HAS_TRIVIAL_COPY   : 0))
                )
{
}

template<class TYPE> inline
Vector<TYPE>::Vector(const Vector<TYPE>& rhs)
    : VectorImpl(rhs) {
}

template<class TYPE> inline
Vector<TYPE>::Vector(const SortedVector<TYPE>& rhs)
    : VectorImpl(static_cast<const VectorImpl&>(rhs)) {
}

template<class TYPE> inline
Vector<TYPE>::~Vector() {
    finish_vector();
}

template <class TYPE>
inline Vector<TYPE>& Vector<TYPE>::operator=(const Vector<TYPE>& rhs)  // NOLINT(cert-oop54-cpp)
{
    VectorImpl::operator=(rhs);
    return *this;
}

template <class TYPE>
inline Vector<TYPE>& Vector<TYPE>::operator=(
        const SortedVector<TYPE>& rhs)  // NOLINT(cert-oop54-cpp)
{
    VectorImpl::operator=(static_cast<const VectorImpl&>(rhs));
    return *this;
}

template<class TYPE> inline
const TYPE* Vector<TYPE>::array() const {
    return static_cast<const TYPE *>(arrayImpl());
}

template<class TYPE> inline
TYPE* Vector<TYPE>::editArray() {
    return static_cast<TYPE *>(editArrayImpl());
}


template<class TYPE> inline
const TYPE& Vector<TYPE>::operator[](size_t index) const {
    return *(array() + index);
}

template<class TYPE> inline
const TYPE& Vector<TYPE>::itemAt(size_t index) const {
    return operator[](index);
}

template<class TYPE> inline
const TYPE& Vector<TYPE>::top() const {
    return *(array() + size() - 1);
}

template<class TYPE> inline
TYPE& Vector<TYPE>::editItemAt(size_t index) {
    return *( static_cast<TYPE *>(editItemLocation(index)) );
}

template<class TYPE> inline
TYPE& Vector<TYPE>::editTop() {
    return *( static_cast<TYPE *>(editItemLocation(size()-1)) );
}

template<class TYPE> inline
ssize_t Vector<TYPE>::insertVectorAt(const Vector<TYPE>& vector, size_t index) {
    return VectorImpl::insertVectorAt(reinterpret_cast<const VectorImpl&>(vector), index);
}

template<class TYPE> inline
ssize_t Vector<TYPE>::appendVector(const Vector<TYPE>& vector) {
    return VectorImpl::appendVector(reinterpret_cast<const VectorImpl&>(vector));
}

template<class TYPE> inline
ssize_t Vector<TYPE>::insertArrayAt(const TYPE* array, size_t index, size_t length) {
    return VectorImpl::insertArrayAt(array, index, length);
}

template<class TYPE> inline
ssize_t Vector<TYPE>::appendArray(const TYPE* array, size_t length) {
    return VectorImpl::appendArray(array, length);
}

template<class TYPE> inline
ssize_t Vector<TYPE>::insertAt(const TYPE& item, size_t index, size_t numItems) {
    return VectorImpl::insertAt(&item, index, numItems);
}

template<class TYPE> inline
void Vector<TYPE>::push(const TYPE& item) {
    return VectorImpl::push(&item);
}

template<class TYPE> inline
ssize_t Vector<TYPE>::add(const TYPE& item) {
    return VectorImpl::add(&item);
}

template<class TYPE> inline
ssize_t Vector<TYPE>::replaceAt(const TYPE& item, size_t index) {
    return VectorImpl::replaceAt(&item, index);
}

template<class TYPE> inline
ssize_t Vector<TYPE>::insertAt(size_t index, size_t numItems) {
    return VectorImpl::insertAt(index, numItems);
}

template<class TYPE> inline
void Vector<TYPE>::pop() {
    VectorImpl::pop();
}

template<class TYPE> inline
void Vector<TYPE>::push() {
    VectorImpl::push();
}

template<class TYPE> inline
ssize_t Vector<TYPE>::add() {
    return VectorImpl::add();
}

template<class TYPE> inline
ssize_t Vector<TYPE>::replaceAt(size_t index) {
    return VectorImpl::replaceAt(index);
}

template<class TYPE> inline
ssize_t Vector<TYPE>::removeItemsAt(size_t index, size_t count) {
    return VectorImpl::removeItemsAt(index, count);
}

template<class TYPE> inline
status_t Vector<TYPE>::sort(Vector<TYPE>::compar_t cmp) {
    return VectorImpl::sort(reinterpret_cast<VectorImpl::compar_t>(cmp));
}

template<class TYPE> inline
status_t Vector<TYPE>::sort(Vector<TYPE>::compar_r_t cmp, void* state) {
    return VectorImpl::sort(reinterpret_cast<VectorImpl::compar_r_t>(cmp), state);
}

// ---------------------------------------------------------------------------

template<class TYPE>
UTILS_VECTOR_NO_CFI void Vector<TYPE>::do_construct(void* storage, size_t num) const {
    construct_type( reinterpret_cast<TYPE*>(storage), num );
}

template<class TYPE>
void Vector<TYPE>::do_destroy(void* storage, size_t num) const {
    destroy_type( reinterpret_cast<TYPE*>(storage), num );
}

template<class TYPE>
UTILS_VECTOR_NO_CFI void Vector<TYPE>::do_copy(void* dest, const void* from, size_t num) const {
    copy_type( reinterpret_cast<TYPE*>(dest), reinterpret_cast<const TYPE*>(from), num );
}

template<class TYPE>
UTILS_VECTOR_NO_CFI void Vector<TYPE>::do_splat(void* dest, const void* item, size_t num) const {
    splat_type( reinterpret_cast<TYPE*>(dest), reinterpret_cast<const TYPE*>(item), num );
}

template<class TYPE>
UTILS_VECTOR_NO_CFI void Vector<TYPE>::do_move_forward(void* dest, const void* from, size_t num) const {
    move_forward_type( reinterpret_cast<TYPE*>(dest), reinterpret_cast<const TYPE*>(from), num );
}

template<class TYPE>
UTILS_VECTOR_NO_CFI void Vector<TYPE>::do_move_backward(void* dest, const void* from, size_t num) const {
    move_backward_type( reinterpret_cast<TYPE*>(dest), reinterpret_cast<const TYPE*>(from), num );
}

}  // namespace android

// ---------------------------------------------------------------------------

#endif // ANDROID_VECTOR_H

```

`app/src/main/cpp/external/AOSP/include/utils/VectorImpl.h`:

```h
/*
 * Copyright (C) 2005 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#ifndef ANDROID_VECTOR_IMPL_H
#define ANDROID_VECTOR_IMPL_H

#include <assert.h>
#include <stdint.h>
#include <sys/types.h>
#include <utils/Errors.h>

// ---------------------------------------------------------------------------
// No user serviceable parts in here...
// ---------------------------------------------------------------------------

namespace android {

/*!
 * Implementation of the guts of the vector<> class
 * this ensures backward binary compatibility and
 * reduces code size.
 * For performance reasons, we expose mStorage and mCount
 * so these fields are set in stone.
 *
 */

class VectorImpl
{
public:
    enum { // flags passed to the ctor
        HAS_TRIVIAL_CTOR    = 0x00000001,
        HAS_TRIVIAL_DTOR    = 0x00000002,
        HAS_TRIVIAL_COPY    = 0x00000004,
    };

                            VectorImpl(size_t itemSize, uint32_t flags);
                            VectorImpl(const VectorImpl& rhs);
    virtual                 ~VectorImpl();

    /*! must be called from subclasses destructor */
            void            finish_vector();

            VectorImpl&     operator = (const VectorImpl& rhs);    
            
    /*! C-style array access */
    inline  const void*     arrayImpl() const       { return mStorage; }
            void*           editArrayImpl();
            
    /*! vector stats */
    inline  size_t          size() const        { return mCount; }
    inline  bool            isEmpty() const     { return mCount == 0; }
            size_t          capacity() const;
            ssize_t         setCapacity(size_t size);
            ssize_t         resize(size_t size);

            /*! append/insert another vector or array */
            ssize_t         insertVectorAt(const VectorImpl& vector, size_t index);
            ssize_t         appendVector(const VectorImpl& vector);
            ssize_t         insertArrayAt(const void* array, size_t index, size_t length);
            ssize_t         appendArray(const void* array, size_t length);
            
            /*! add/insert/replace items */
            ssize_t         insertAt(size_t where, size_t numItems = 1);
            ssize_t         insertAt(const void* item, size_t where, size_t numItems = 1);
            void            pop();
            void            push();
            void            push(const void* item);
            ssize_t         add();
            ssize_t         add(const void* item);
            ssize_t         replaceAt(size_t index);
            ssize_t         replaceAt(const void* item, size_t index);

            /*! remove items */
            ssize_t         removeItemsAt(size_t index, size_t count = 1);
            void            clear();

            const void*     itemLocation(size_t index) const;
            void*           editItemLocation(size_t index);

            typedef int (*compar_t)(const void* lhs, const void* rhs);
            typedef int (*compar_r_t)(const void* lhs, const void* rhs, void* state);
            status_t        sort(compar_t cmp);
            status_t        sort(compar_r_t cmp, void* state);

protected:
            size_t          itemSize() const;
            void            release_storage();

    virtual void            do_construct(void* storage, size_t num) const = 0;
    virtual void            do_destroy(void* storage, size_t num) const = 0;
    virtual void            do_copy(void* dest, const void* from, size_t num) const = 0;
    virtual void            do_splat(void* dest, const void* item, size_t num) const = 0;
    virtual void            do_move_forward(void* dest, const void* from, size_t num) const = 0;
    virtual void            do_move_backward(void* dest, const void* from, size_t num) const = 0;
    
private:
        void* _grow(size_t where, size_t amount);
        void  _shrink(size_t where, size_t amount);

        inline void _do_construct(void* storage, size_t num) const;
        inline void _do_destroy(void* storage, size_t num) const;
        inline void _do_copy(void* dest, const void* from, size_t num) const;
        inline void _do_splat(void* dest, const void* item, size_t num) const;
        inline void _do_move_forward(void* dest, const void* from, size_t num) const;
        inline void _do_move_backward(void* dest, const void* from, size_t num) const;

            // These 2 fields are exposed in the inlines below,
            // so they're set in stone.
            void *      mStorage;   // base address of the vector
            size_t      mCount;     // number of items

    const   uint32_t    mFlags;
    const   size_t      mItemSize;
};



class SortedVectorImpl : public VectorImpl
{
public:
                            SortedVectorImpl(size_t itemSize, uint32_t flags);
    explicit                SortedVectorImpl(const VectorImpl& rhs);
    virtual                 ~SortedVectorImpl();
    
    SortedVectorImpl&     operator = (const SortedVectorImpl& rhs);    

    //! finds the index of an item
            ssize_t         indexOf(const void* item) const;

    //! finds where this item should be inserted
            size_t          orderOf(const void* item) const;

    //! add an item in the right place (or replaces it if there is one)
            ssize_t         add(const void* item);

    //! merges a vector into this one
            ssize_t         merge(const VectorImpl& vector);
            ssize_t         merge(const SortedVectorImpl& vector);
             
    //! removes an item
            ssize_t         remove(const void* item);
        
protected:
    virtual int             do_compare(const void* lhs, const void* rhs) const = 0;

private:
            ssize_t         _indexOrderOf(const void* item, size_t* order = nullptr) const;

            // these are made private, because they can't be used on a SortedVector
            // (they don't have an implementation either)
            ssize_t         add();
            void            pop();
            void            push();
            void            push(const void* item);
            ssize_t         insertVectorAt(const VectorImpl& vector, size_t index);
            ssize_t         appendVector(const VectorImpl& vector);
            ssize_t         insertArrayAt(const void* array, size_t index, size_t length);
            ssize_t         appendArray(const void* array, size_t length);
            ssize_t         insertAt(size_t where, size_t numItems = 1);
            ssize_t         insertAt(const void* item, size_t where, size_t numItems = 1);
            ssize_t         replaceAt(size_t index);
            ssize_t         replaceAt(const void* item, size_t index);
};

}  // namespace android

// ---------------------------------------------------------------------------

#endif // ANDROID_VECTOR_IMPL_H

```

`app/src/main/cpp/external/linux-kernel/include/android/binder.h`:

```h
/* SPDX-License-Identifier: GPL-2.0 WITH Linux-syscall-note */
/*
 * Copyright (C) 2008 Google, Inc.
 *
 * Based on, but no longer compatible with, the original
 * OpenBinder.org binder driver interface, which is:
 *
 * Copyright (c) 2005 Palmsource, Inc.
 *
 * This software is licensed under the terms of the GNU General Public
 * License version 2, as published by the Free Software Foundation, and
 * may be copied, distributed, and modified under those terms.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 */

#ifndef _UAPI_LINUX_BINDER_H
#define _UAPI_LINUX_BINDER_H

#include <linux/types.h>
#include <linux/ioctl.h>

#define B_PACK_CHARS(c1, c2, c3, c4) \
	((((c1)<<24)) | (((c2)<<16)) | (((c3)<<8)) | (c4))
#define B_TYPE_LARGE 0x85

enum {
	BINDER_TYPE_BINDER	= B_PACK_CHARS('s', 'b', '*', B_TYPE_LARGE),
	BINDER_TYPE_WEAK_BINDER	= B_PACK_CHARS('w', 'b', '*', B_TYPE_LARGE),
	BINDER_TYPE_HANDLE	= B_PACK_CHARS('s', 'h', '*', B_TYPE_LARGE),
	BINDER_TYPE_WEAK_HANDLE	= B_PACK_CHARS('w', 'h', '*', B_TYPE_LARGE),
	BINDER_TYPE_FD		= B_PACK_CHARS('f', 'd', '*', B_TYPE_LARGE),
	BINDER_TYPE_FDA		= B_PACK_CHARS('f', 'd', 'a', B_TYPE_LARGE),
	BINDER_TYPE_PTR		= B_PACK_CHARS('p', 't', '*', B_TYPE_LARGE),
};

enum {
	FLAT_BINDER_FLAG_PRIORITY_MASK = 0xff,
	FLAT_BINDER_FLAG_ACCEPTS_FDS = 0x100,

	/**
	 * @FLAT_BINDER_FLAG_TXN_SECURITY_CTX: request security contexts
	 *
	 * Only when set, causes senders to include their security
	 * context
	 */
	FLAT_BINDER_FLAG_TXN_SECURITY_CTX = 0x1000,
};

#ifdef BINDER_IPC_32BIT
typedef __u32 binder_size_t;
typedef __u32 binder_uintptr_t;
#else
typedef __u64 binder_size_t;
typedef __u64 binder_uintptr_t;
#endif

/**
 * struct binder_object_header - header shared by all binder metadata objects.
 * @type:	type of the object
 */
struct binder_object_header {
	__u32        type;
};

/*
 * This is the flattened representation of a Binder object for transfer
 * between processes.  The 'offsets' supplied as part of a binder transaction
 * contains offsets into the data where these structures occur.  The Binder
 * driver takes care of re-writing the structure type and data as it moves
 * between processes.
 */
struct flat_binder_object {
	struct binder_object_header	hdr;
	__u32				flags;

	/* 8 bytes of data. */
	union {
		binder_uintptr_t	binder;	/* local object */
		__u32			handle;	/* remote object */
	};

	/* extra data associated with local object */
	binder_uintptr_t	cookie;
};

/**
 * struct binder_fd_object - describes a filedescriptor to be fixed up.
 * @hdr:	common header structure
 * @pad_flags:	padding to remain compatible with old userspace code
 * @pad_binder:	padding to remain compatible with old userspace code
 * @fd:		file descriptor
 * @cookie:	opaque data, used by user-space
 */
struct binder_fd_object {
	struct binder_object_header	hdr;
	__u32				pad_flags;
	union {
		binder_uintptr_t	pad_binder;
		__u32			fd;
	};

	binder_uintptr_t		cookie;
};

/* struct binder_buffer_object - object describing a userspace buffer
 * @hdr:		common header structure
 * @flags:		one or more BINDER_BUFFER_* flags
 * @buffer:		address of the buffer
 * @length:		length of the buffer
 * @parent:		index in offset array pointing to parent buffer
 * @parent_offset:	offset in @parent pointing to this buffer
 *
 * A binder_buffer object represents an object that the
 * binder kernel driver can copy verbatim to the target
 * address space. A buffer itself may be pointed to from
 * within another buffer, meaning that the pointer inside
 * that other buffer needs to be fixed up as well. This
 * can be done by setting the BINDER_BUFFER_FLAG_HAS_PARENT
 * flag in @flags, by setting @parent buffer to the index
 * in the offset array pointing to the parent binder_buffer_object,
 * and by setting @parent_offset to the offset in the parent buffer
 * at which the pointer to this buffer is located.
 */
struct binder_buffer_object {
	struct binder_object_header	hdr;
	__u32				flags;
	binder_uintptr_t		buffer;
	binder_size_t			length;
	binder_size_t			parent;
	binder_size_t			parent_offset;
};

enum {
	BINDER_BUFFER_FLAG_HAS_PARENT = 0x01,
};

/* struct binder_fd_array_object - object describing an array of fds in a buffer
 * @hdr:		common header structure
 * @pad:		padding to ensure correct alignment
 * @num_fds:		number of file descriptors in the buffer
 * @parent:		index in offset array to buffer holding the fd array
 * @parent_offset:	start offset of fd array in the buffer
 *
 * A binder_fd_array object represents an array of file
 * descriptors embedded in a binder_buffer_object. It is
 * different from a regular binder_buffer_object because it
 * describes a list of file descriptors to fix up, not an opaque
 * blob of memory, and hence the kernel needs to treat it differently.
 *
 * An example of how this would be used is with Android's
 * native_handle_t object, which is a struct with a list of integers
 * and a list of file descriptors. The native_handle_t struct itself
 * will be represented by a struct binder_buffer_objct, whereas the
 * embedded list of file descriptors is represented by a
 * struct binder_fd_array_object with that binder_buffer_object as
 * a parent.
 */
struct binder_fd_array_object {
	struct binder_object_header	hdr;
	__u32				pad;
	binder_size_t			num_fds;
	binder_size_t			parent;
	binder_size_t			parent_offset;
};

/*
 * On 64-bit platforms where user code may run in 32-bits the driver must
 * translate the buffer (and local binder) addresses appropriately.
 */

struct binder_write_read {
	binder_size_t		write_size;	/* bytes to write */
	binder_size_t		write_consumed;	/* bytes consumed by driver */
	binder_uintptr_t	write_buffer;
	binder_size_t		read_size;	/* bytes to read */
	binder_size_t		read_consumed;	/* bytes consumed by driver */
	binder_uintptr_t	read_buffer;
};

/* Use with BINDER_VERSION, driver fills in fields. */
struct binder_version {
	/* driver protocol version -- increment with incompatible change */
	__s32       protocol_version;
};

/* This is the current protocol version. */
#ifdef BINDER_IPC_32BIT
#define BINDER_CURRENT_PROTOCOL_VERSION 7
#else
#define BINDER_CURRENT_PROTOCOL_VERSION 8
#endif

/*
 * Use with BINDER_GET_NODE_DEBUG_INFO, driver reads ptr, writes to all fields.
 * Set ptr to NULL for the first call to get the info for the first node, and
 * then repeat the call passing the previously returned value to get the next
 * nodes.  ptr will be 0 when there are no more nodes.
 */
struct binder_node_debug_info {
	binder_uintptr_t ptr;
	binder_uintptr_t cookie;
	__u32            has_strong_ref;
	__u32            has_weak_ref;
};

struct binder_node_info_for_ref {
	__u32            handle;
	__u32            strong_count;
	__u32            weak_count;
	__u32            reserved1;
	__u32            reserved2;
	__u32            reserved3;
};

struct binder_freeze_info {
	__u32            pid;
	__u32            enable;
	__u32            timeout_ms;
};

struct binder_frozen_status_info {
	__u32            pid;

	/* process received sync transactions since last frozen
	 * bit 0: received sync transaction after being frozen
	 * bit 1: new pending sync transaction during freezing
	 */
	__u32            sync_recv;

	/* process received async transactions since last frozen */
	__u32            async_recv;
};

struct binder_frozen_state_info {
	binder_uintptr_t cookie;
	__u32            is_frozen;
	__u32            reserved;
};

/* struct binder_extened_error - extended error information
 * @id:		identifier for the failed operation
 * @command:	command as defined by binder_driver_return_protocol
 * @param:	parameter holding a negative errno value
 *
 * Used with BINDER_GET_EXTENDED_ERROR. This extends the error information
 * returned by the driver upon a failed operation. Userspace can pull this
 * data to properly handle specific error scenarios.
 */
struct binder_extended_error {
	__u32	id;
	__u32	command;
	__s32	param;
};

enum {
	BINDER_WRITE_READ		= _IOWR('b', 1, struct binder_write_read),
	BINDER_SET_IDLE_TIMEOUT		= _IOW('b', 3, __s64),
	BINDER_SET_MAX_THREADS		= _IOW('b', 5, __u32),
	BINDER_SET_IDLE_PRIORITY	= _IOW('b', 6, __s32),
	BINDER_SET_CONTEXT_MGR		= _IOW('b', 7, __s32),
	BINDER_THREAD_EXIT		= _IOW('b', 8, __s32),
	BINDER_VERSION			= _IOWR('b', 9, struct binder_version),
	BINDER_GET_NODE_DEBUG_INFO	= _IOWR('b', 11, struct binder_node_debug_info),
	BINDER_GET_NODE_INFO_FOR_REF	= _IOWR('b', 12, struct binder_node_info_for_ref),
	BINDER_SET_CONTEXT_MGR_EXT	= _IOW('b', 13, struct flat_binder_object),
	BINDER_FREEZE			= _IOW('b', 14, struct binder_freeze_info),
	BINDER_GET_FROZEN_INFO		= _IOWR('b', 15, struct binder_frozen_status_info),
	BINDER_ENABLE_ONEWAY_SPAM_DETECTION	= _IOW('b', 16, __u32),
	BINDER_GET_EXTENDED_ERROR	= _IOWR('b', 17, struct binder_extended_error),
};

/*
 * NOTE: Two special error codes you should check for when calling
 * in to the driver are:
 *
 * EINTR -- The operation has been interupted.  This should be
 * handled by retrying the ioctl() until a different error code
 * is returned.
 *
 * ECONNREFUSED -- The driver is no longer accepting operations
 * from your process.  That is, the process is being destroyed.
 * You should handle this by exiting from your process.  Note
 * that once this error code is returned, all further calls to
 * the driver from any thread will return this same code.
 */

enum transaction_flags {
	TF_ONE_WAY	= 0x01,	/* this is a one-way call: async, no return */
	TF_ROOT_OBJECT	= 0x04,	/* contents are the component's root object */
	TF_STATUS_CODE	= 0x08,	/* contents are a 32-bit status code */
	TF_ACCEPT_FDS	= 0x10,	/* allow replies with file descriptors */
	TF_CLEAR_BUF	= 0x20,	/* clear buffer on txn complete */
	TF_UPDATE_TXN	= 0x40,	/* update the outdated pending async txn */
};

struct binder_transaction_data {
	/* The first two are only used for bcTRANSACTION and brTRANSACTION,
	 * identifying the target and contents of the transaction.
	 */
	union {
		/* target descriptor of command transaction */
		__u32	handle;
		/* target descriptor of return transaction */
		binder_uintptr_t ptr;
	} target;
	binder_uintptr_t	cookie;	/* target object cookie */
	__u32		code;		/* transaction command */

	/* General information about the transaction. */
	__u32	        flags;
	__kernel_pid_t	sender_pid;
	__kernel_uid32_t	sender_euid;
	binder_size_t	data_size;	/* number of bytes of data */
	binder_size_t	offsets_size;	/* number of bytes of offsets */

	/* If this transaction is inline, the data immediately
	 * follows here; otherwise, it ends with a pointer to
	 * the data buffer.
	 */
	union {
		struct {
			/* transaction data */
			binder_uintptr_t	buffer;
			/* offsets from buffer to flat_binder_object structs */
			binder_uintptr_t	offsets;
		} ptr;
		__u8	buf[8];
	} data;
};

struct binder_transaction_data_secctx {
	struct binder_transaction_data transaction_data;
	binder_uintptr_t secctx;
};

struct binder_transaction_data_sg {
	struct binder_transaction_data transaction_data;
	binder_size_t buffers_size;
};

struct binder_ptr_cookie {
	binder_uintptr_t ptr;
	binder_uintptr_t cookie;
};

struct binder_handle_cookie {
	__u32 handle;
	binder_uintptr_t cookie;
} __packed;

struct binder_pri_desc {
	__s32 priority;
	__u32 desc;
};

struct binder_pri_ptr_cookie {
	__s32 priority;
	binder_uintptr_t ptr;
	binder_uintptr_t cookie;
};

enum binder_driver_return_protocol {
	BR_ERROR = _IOR('r', 0, __s32),
	/*
	 * int: error code
	 */

	BR_OK = _IO('r', 1),
	/* No parameters! */

	BR_TRANSACTION_SEC_CTX = _IOR('r', 2,
				      struct binder_transaction_data_secctx),
	/*
	 * binder_transaction_data_secctx: the received command.
	 */
	BR_TRANSACTION = _IOR('r', 2, struct binder_transaction_data),
	BR_REPLY = _IOR('r', 3, struct binder_transaction_data),
	/*
	 * binder_transaction_data: the received command.
	 */

	BR_ACQUIRE_RESULT = _IOR('r', 4, __s32),
	/*
	 * not currently supported
	 * int: 0 if the last bcATTEMPT_ACQUIRE was not successful.
	 * Else the remote object has acquired a primary reference.
	 */

	BR_DEAD_REPLY = _IO('r', 5),
	/*
	 * The target of the last transaction (either a bcTRANSACTION or
	 * a bcATTEMPT_ACQUIRE) is no longer with us.  No parameters.
	 */

	BR_TRANSACTION_COMPLETE = _IO('r', 6),
	/*
	 * No parameters... always refers to the last transaction requested
	 * (including replies).  Note that this will be sent even for
	 * asynchronous transactions.
	 */

	BR_INCREFS = _IOR('r', 7, struct binder_ptr_cookie),
	BR_ACQUIRE = _IOR('r', 8, struct binder_ptr_cookie),
	BR_RELEASE = _IOR('r', 9, struct binder_ptr_cookie),
	BR_DECREFS = _IOR('r', 10, struct binder_ptr_cookie),
	/*
	 * void *:	ptr to binder
	 * void *: cookie for binder
	 */

	BR_ATTEMPT_ACQUIRE = _IOR('r', 11, struct binder_pri_ptr_cookie),
	/*
	 * not currently supported
	 * int:	priority
	 * void *: ptr to binder
	 * void *: cookie for binder
	 */

	BR_NOOP = _IO('r', 12),
	/*
	 * No parameters.  Do nothing and examine the next command.  It exists
	 * primarily so that we can replace it with a BR_SPAWN_LOOPER command.
	 */

	BR_SPAWN_LOOPER = _IO('r', 13),
	/*
	 * No parameters.  The driver has determined that a process has no
	 * threads waiting to service incoming transactions.  When a process
	 * receives this command, it must spawn a new service thread and
	 * register it via bcENTER_LOOPER.
	 */

	BR_FINISHED = _IO('r', 14),
	/*
	 * not currently supported
	 * stop threadpool thread
	 */

	BR_DEAD_BINDER = _IOR('r', 15, binder_uintptr_t),
	/*
	 * void *: cookie
	 */
	BR_CLEAR_DEATH_NOTIFICATION_DONE = _IOR('r', 16, binder_uintptr_t),
	/*
	 * void *: cookie
	 */

	BR_FAILED_REPLY = _IO('r', 17),
	/*
	 * The last transaction (either a bcTRANSACTION or
	 * a bcATTEMPT_ACQUIRE) failed (e.g. out of memory).  No parameters.
	 */

	BR_FROZEN_REPLY = _IO('r', 18),
	/*
	 * The target of the last sync transaction (either a bcTRANSACTION or
	 * a bcATTEMPT_ACQUIRE) is frozen.  No parameters.
	 */

	BR_ONEWAY_SPAM_SUSPECT = _IO('r', 19),
	/*
	 * Current process sent too many oneway calls to target, and the last
	 * asynchronous transaction makes the allocated async buffer size exceed
	 * detection threshold.  No parameters.
	 */

	BR_TRANSACTION_PENDING_FROZEN = _IO('r', 20),
	/*
	 * The target of the last async transaction is frozen.  No parameters.
	 */

	BR_FROZEN_BINDER = _IOR('r', 21, struct binder_frozen_state_info),
	/*
	 * The cookie and a boolean (is_frozen) that indicates whether the process
	 * transitioned into a frozen or an unfrozen state.
	 */

	BR_CLEAR_FREEZE_NOTIFICATION_DONE = _IOR('r', 22, binder_uintptr_t),
	/*
	 * void *: cookie
	 */
};

enum binder_driver_command_protocol {
	BC_TRANSACTION = _IOW('c', 0, struct binder_transaction_data),
	BC_REPLY = _IOW('c', 1, struct binder_transaction_data),
	/*
	 * binder_transaction_data: the sent command.
	 */

	BC_ACQUIRE_RESULT = _IOW('c', 2, __s32),
	/*
	 * not currently supported
	 * int:  0 if the last BR_ATTEMPT_ACQUIRE was not successful.
	 * Else you have acquired a primary reference on the object.
	 */

	BC_FREE_BUFFER = _IOW('c', 3, binder_uintptr_t),
	/*
	 * void *: ptr to transaction data received on a read
	 */

	BC_INCREFS = _IOW('c', 4, __u32),
	BC_ACQUIRE = _IOW('c', 5, __u32),
	BC_RELEASE = _IOW('c', 6, __u32),
	BC_DECREFS = _IOW('c', 7, __u32),
	/*
	 * int:	descriptor
	 */

	BC_INCREFS_DONE = _IOW('c', 8, struct binder_ptr_cookie),
	BC_ACQUIRE_DONE = _IOW('c', 9, struct binder_ptr_cookie),
	/*
	 * void *: ptr to binder
	 * void *: cookie for binder
	 */

	BC_ATTEMPT_ACQUIRE = _IOW('c', 10, struct binder_pri_desc),
	/*
	 * not currently supported
	 * int: priority
	 * int: descriptor
	 */

	BC_REGISTER_LOOPER = _IO('c', 11),
	/*
	 * No parameters.
	 * Register a spawned looper thread with the device.
	 */

	BC_ENTER_LOOPER = _IO('c', 12),
	BC_EXIT_LOOPER = _IO('c', 13),
	/*
	 * No parameters.
	 * These two commands are sent as an application-level thread
	 * enters and exits the binder loop, respectively.  They are
	 * used so the binder can have an accurate count of the number
	 * of looping threads it has available.
	 */

	BC_REQUEST_DEATH_NOTIFICATION = _IOW('c', 14,
						struct binder_handle_cookie),
	/*
	 * int: handle
	 * void *: cookie
	 */

	BC_CLEAR_DEATH_NOTIFICATION = _IOW('c', 15,
						struct binder_handle_cookie),
	/*
	 * int: handle
	 * void *: cookie
	 */

	BC_DEAD_BINDER_DONE = _IOW('c', 16, binder_uintptr_t),
	/*
	 * void *: cookie
	 */

	BC_TRANSACTION_SG = _IOW('c', 17, struct binder_transaction_data_sg),
	BC_REPLY_SG = _IOW('c', 18, struct binder_transaction_data_sg),
	/*
	 * binder_transaction_data_sg: the sent command.
	 */

	BC_REQUEST_FREEZE_NOTIFICATION =
			_IOW('c', 19, struct binder_handle_cookie),
	/*
	 * int: handle
	 * void *: cookie
	 */

	BC_CLEAR_FREEZE_NOTIFICATION = _IOW('c', 20,
					    struct binder_handle_cookie),
	/*
	 * int: handle
	 * void *: cookie
	 */

	BC_FREEZE_NOTIFICATION_DONE = _IOW('c', 21, binder_uintptr_t),
	/*
	 * void *: cookie
	 */
};

#endif /* _UAPI_LINUX_BINDER_H */


```

`app/src/main/cpp/inject/main.cpp`:

```cpp
// Copyright 2025 Dakkshesh <beakthoven@gmail.com>
// SPDX-License-Identifier: GPL-3.0-or-later

#include <android/dlext.h>
#include <dlfcn.h>
#include <elf.h>
#include <fcntl.h>
#include <link.h>
#include <sys/auxv.h>
#include <sys/mman.h>
#include <sys/ptrace.h>
#include <sys/socket.h>
#include <sys/system_properties.h>
#include <sys/uio.h>
#include <sys/un.h>
#include <sys/wait.h>
#include <unistd.h>

#include <cinttypes>
#include <climits>
#include <csignal>
#include <cstdio>
#include <cstdlib>
#include <memory>
#include <optional>
#include <string>
#include <vector>

#include "logging.hpp"
#include "lsplt.hpp"
#include "utils.hpp"

using namespace std::string_literals;

namespace inject {

namespace constants {
constexpr size_t kMagicLength = 16;
constexpr size_t kMaxPathLength = 4096;
constexpr const char *kSystemFileContext = "u:object_r:system_file:s0";
constexpr const char *kLibcModule = "libc.so";
constexpr const char *kLibdlModule = "libdl.so";
constexpr const char *kEntrySymbol = "entry";
} // namespace constants

class RemoteLibraryHandle {
public:
    RemoteLibraryHandle(int pid, int fd, uintptr_t handle) : pid_(pid), fd_(fd), handle_(handle) {}

    ~RemoteLibraryHandle() {
        if (fd_ != -1) {
            struct user_regs_struct regs{};
            std::vector<lsplt::MapInfo> local_map, remote_map;
            if (get_regs(pid_, regs)) {
                local_map = lsplt::MapInfo::Scan();
                remote_map = lsplt::MapInfo::Scan(std::to_string(pid_));
                if (auto close_addr = find_func_addr(local_map, remote_map, constants::kLibcModule, "close")) {
                    std::vector<uintptr_t> args = {static_cast<uintptr_t>(fd_)};
                    remote_call(pid_, regs, reinterpret_cast<uintptr_t>(close_addr), 0, args);
                }
            }
        }
    }

    RemoteLibraryHandle(const RemoteLibraryHandle &) = delete;
    RemoteLibraryHandle &operator=(const RemoteLibraryHandle &) = delete;
    RemoteLibraryHandle(RemoteLibraryHandle &&other) noexcept : pid_(other.pid_), fd_(other.fd_), handle_(other.handle_) {
        other.fd_ = -1;
        other.handle_ = 0;
    }

    uintptr_t handle() const {
        return handle_;
    }
    int fd() const {
        return fd_;
    }

private:
    int pid_;
    int fd_;
    uintptr_t handle_;
};

static std::optional<int> transfer_fd_to_remote(int pid, const char *lib_path, struct user_regs_struct &regs,
                                                const std::vector<lsplt::MapInfo> &local_map,
                                                const std::vector<lsplt::MapInfo> &remote_map) {
    if (!set_sockcreate_con(constants::kSystemFileContext)) {
        LOGE("Failed to set socket creation context");
        return std::nullopt;
    }

    UniqueFd local_socket = socket(AF_UNIX, SOCK_DGRAM | SOCK_CLOEXEC, 0);
    if (local_socket == -1) {
        PLOGE("create local socket");
        return std::nullopt;
    }

    if (setfilecon(lib_path, constants::kSystemFileContext) == -1) {
        PLOGE("set context of lib");
    }

    UniqueFd local_lib_fd = open(lib_path, O_RDONLY | O_CLOEXEC);
    if (local_lib_fd == -1) {
        PLOGE("open lib: %s", lib_path);
        return std::nullopt;
    }

    struct RemoteFunctions {
        void *socket_addr;
        void *bind_addr;
        void *recvmsg_addr;
        void *close_addr;
        void *errno_addr;
    } funcs{};

    funcs.socket_addr = find_func_addr(local_map, remote_map, constants::kLibcModule, "socket");
    funcs.bind_addr = find_func_addr(local_map, remote_map, constants::kLibcModule, "bind");
    funcs.recvmsg_addr = find_func_addr(local_map, remote_map, constants::kLibcModule, "recvmsg");
    funcs.close_addr = find_func_addr(local_map, remote_map, constants::kLibcModule, "close");
    funcs.errno_addr = find_func_addr(local_map, remote_map, constants::kLibcModule, "__errno");

    if (!funcs.socket_addr || !funcs.bind_addr || !funcs.recvmsg_addr || !funcs.close_addr) {
        LOGE("Failed to resolve required libc functions");
        return std::nullopt;
    }
    std::vector<uintptr_t> args;
    auto get_remote_errno = [&]() -> int {
        if (!funcs.errno_addr)
            return 0;
        args.clear();
        auto addr = remote_call(pid, regs, reinterpret_cast<uintptr_t>(funcs.errno_addr), 0, args);
        int err = 0;
        if (!read_proc(pid, addr, &err, sizeof(err)))
            return 0;
        return err;
    };

    auto close_remote = [&](int fd) {
        args = {static_cast<uintptr_t>(fd)};
        if (remote_call(pid, regs, reinterpret_cast<uintptr_t>(funcs.close_addr), 0, args) != 0) {
            LOGE("Failed to close remote fd: %d", fd);
        }
    };

    args = {AF_UNIX, SOCK_DGRAM | SOCK_CLOEXEC, 0};
    int remote_fd = static_cast<int>(remote_call(pid, regs, reinterpret_cast<uintptr_t>(funcs.socket_addr), 0, args));
    if (remote_fd == -1) {
        errno = get_remote_errno();
        PLOGE("remote socket creation failed");
        return std::nullopt;
    }

    auto magic = generateMagic(constants::kMagicLength);
    struct sockaddr_un sock_addr{.sun_family = AF_UNIX, .sun_path = {0}};
    memcpy(sock_addr.sun_path + 1, magic.c_str(), magic.size());
    socklen_t addr_len = sizeof(sock_addr.sun_family) + 1 + magic.size();

    auto remote_addr = push_memory(pid, regs, &sock_addr, sizeof(sock_addr));
    args = {static_cast<uintptr_t>(remote_fd), remote_addr, static_cast<uintptr_t>(addr_len)};
    auto bind_result = remote_call(pid, regs, reinterpret_cast<uintptr_t>(funcs.bind_addr), 0, args);
    if (bind_result == static_cast<uintptr_t>(-1)) {
        errno = get_remote_errno();
        PLOGE("remote bind failed");
        close_remote(remote_fd);
        return std::nullopt;
    }
    char cmsgbuf[CMSG_SPACE(sizeof(int))] = {0};
    auto remote_cmsgbuf = push_memory(pid, regs, &cmsgbuf, sizeof(cmsgbuf));

    struct msghdr msg_hdr{};
    msg_hdr.msg_control = reinterpret_cast<void *>(remote_cmsgbuf);
    msg_hdr.msg_controllen = sizeof(cmsgbuf);
    auto remote_hdr = push_memory(pid, regs, &msg_hdr, sizeof(msg_hdr));

    args = {static_cast<uintptr_t>(remote_fd), remote_hdr, MSG_WAITALL};
    if (!remote_pre_call(pid, regs, reinterpret_cast<uintptr_t>(funcs.recvmsg_addr), 0, args)) {
        LOGE("Failed to start remote recvmsg call");
        close_remote(remote_fd);
        return std::nullopt;
    }

    msg_hdr.msg_control = &cmsgbuf;
    msg_hdr.msg_name = &sock_addr;
    msg_hdr.msg_namelen = addr_len;

    {
        auto *cmsg = CMSG_FIRSTHDR(&msg_hdr);
        cmsg->cmsg_len = CMSG_LEN(sizeof(int));
        cmsg->cmsg_level = SOL_SOCKET;
        cmsg->cmsg_type = SCM_RIGHTS;
        *reinterpret_cast<int *>(CMSG_DATA(cmsg)) = local_lib_fd;
    }

    if (sendmsg(local_socket, &msg_hdr, 0) == -1) {
        PLOGE("Failed to send fd to remote process");
        close_remote(remote_fd);
        return std::nullopt;
    }

    auto recvmsg_result = static_cast<ssize_t>(remote_post_call(pid, regs, 0));
    if (recvmsg_result == -1) {
        errno = get_remote_errno();
        PLOGE("Remote recvmsg failed");
        close_remote(remote_fd);
        return std::nullopt;
    }

    if (read_proc(pid, remote_cmsgbuf, &cmsgbuf, sizeof(cmsgbuf)) != sizeof(cmsgbuf)) {
        LOGE("Failed to read control message from remote process");
        close_remote(remote_fd);
        return std::nullopt;
    }

    auto *cmsg = CMSG_FIRSTHDR(&msg_hdr);
    if (!cmsg || cmsg->cmsg_len != CMSG_LEN(sizeof(int)) || cmsg->cmsg_level != SOL_SOCKET || cmsg->cmsg_type != SCM_RIGHTS) {
        LOGE("Invalid control message received from remote process");
        close_remote(remote_fd);
        return std::nullopt;
    }

    int transferred_fd = *reinterpret_cast<int *>(CMSG_DATA(cmsg));
    LOGD("Successfully transferred fd %d to remote process", transferred_fd);
    close_remote(remote_fd);
    return transferred_fd;
}

static std::string get_remote_dlerror(int pid, struct user_regs_struct &regs, const std::vector<lsplt::MapInfo> &local_map,
                                     const std::vector<lsplt::MapInfo> &remote_map, uintptr_t libc_return_addr) {
    auto dlerror_addr = find_func_addr(local_map, remote_map, constants::kLibdlModule, "dlerror");
    if (!dlerror_addr) {
        return "Failed to find dlerror function";
    }

    std::vector<uintptr_t> args;
    auto dlerror_str_addr = remote_call(pid, regs, reinterpret_cast<uintptr_t>(dlerror_addr), libc_return_addr, args);
    if (dlerror_str_addr == 0) {
        return "dlerror returned null";
    }

    auto strlen_addr = find_func_addr(local_map, remote_map, constants::kLibcModule, "strlen");
    if (!strlen_addr) {
        return "Failed to find strlen function";
    }

    args.clear();
    args.push_back(dlerror_str_addr);
    auto dlerror_len = remote_call(pid, regs, reinterpret_cast<uintptr_t>(strlen_addr), libc_return_addr, args);
    if (dlerror_len <= 0 || dlerror_len > 1024) {
        return "Invalid dlerror string length";
    }

    std::string err;
    err.resize(dlerror_len + 1, 0);
    if (read_proc(pid, dlerror_str_addr, err.data(), dlerror_len) != dlerror_len) {
        return "Failed to read dlerror string";
    }
    err.resize(dlerror_len);
    return err;
}

static std::optional<uintptr_t> remote_dlopen(int pid, struct user_regs_struct &regs, const std::vector<lsplt::MapInfo> &local_map,
                                              const std::vector<lsplt::MapInfo> &remote_map, int lib_fd, const char *lib_path,
                                              uintptr_t libc_return_addr) {
    auto dlopen_addr = find_func_addr(local_map, remote_map, constants::kLibdlModule, "android_dlopen_ext");
    if (!dlopen_addr) {
        LOGW("Failed to find android_dlopen_ext in %s,", constants::kLibdlModule);
        return std::nullopt;
    }

    android_dlextinfo dlext_info{};
    dlext_info.flags = ANDROID_DLEXT_USE_LIBRARY_FD;
    dlext_info.library_fd = lib_fd;

    uintptr_t remote_info = push_memory(pid, regs, &dlext_info, sizeof(dlext_info));
    uintptr_t remote_path = push_string(pid, regs, lib_path);

    std::vector<uintptr_t> args = {remote_path, RTLD_NOW, remote_info};
    uintptr_t remote_handle = remote_call(pid, regs, reinterpret_cast<uintptr_t>(dlopen_addr), libc_return_addr, args);

    if (remote_handle == 0) {
        std::string error_msg = get_remote_dlerror(pid, regs, local_map, remote_map, libc_return_addr);
        LOGW("Primary dlopen failed for library: %s, dlerror: %s", lib_path, error_msg.c_str());
        return std::nullopt;
    }

    LOGD("Successfully loaded library with handle: %p", reinterpret_cast<void *>(remote_handle));
    return remote_handle;
}

static std::optional<uintptr_t> remote_find_entry(int pid, struct user_regs_struct &regs, const std::vector<lsplt::MapInfo> &local_map,
                                                  const std::vector<lsplt::MapInfo> &remote_map, uintptr_t remote_handle,
                                                  uintptr_t libc_return_addr) {
    auto dlsym_addr = find_func_addr(local_map, remote_map, constants::kLibdlModule, "dlsym");
    if (!dlsym_addr) {
        LOGE("Failed to find dlsym in %s", constants::kLibdlModule);
        return std::nullopt;
    }

    uintptr_t remote_symbol = push_string(pid, regs, constants::kEntrySymbol);

    std::vector<uintptr_t> args = {remote_handle, remote_symbol};
    uintptr_t entry_addr = remote_call(pid, regs, reinterpret_cast<uintptr_t>(dlsym_addr), libc_return_addr, args);

    if (entry_addr == 0) {
        std::string error_msg = get_remote_dlerror(pid, regs, local_map, remote_map, libc_return_addr);
        LOGE("Failed to find entry symbol '%s' in remote library, dlerror: %s", constants::kEntrySymbol, error_msg.c_str());
        return std::nullopt;
    }

    LOGD("Found entry point at: %p", reinterpret_cast<void *>(entry_addr));
    return entry_addr;
}

static bool remote_call_entry(int pid, struct user_regs_struct &regs, uintptr_t entry_addr, uintptr_t remote_handle,
                              uintptr_t libc_return_addr) {
    std::vector<uintptr_t> args = {remote_handle};
    uintptr_t result = remote_call(pid, regs, entry_addr, libc_return_addr, args);

    LOGD("Entry point called with result: %p", reinterpret_cast<void *>(result));
    return true;
}

class PtraceAttachment {
public:
    explicit PtraceAttachment(int target_pid) : pid_(target_pid), attached_(false) {
        if (ptrace(PTRACE_ATTACH, pid_, 0, 0) == -1) {
            PLOGE("Failed to attach to process %d", pid_);
            return;
        }
        attached_ = true;
        LOGD("Successfully attached to process %d", pid_);
    }

    ~PtraceAttachment() {
        if (attached_) {
            if (ptrace(PTRACE_DETACH, pid_, 0, 0) == -1) {
                PLOGE("Failed to detach from process %d", pid_);
            } else {
                LOGD("Successfully detached from process %d", pid_);
            }
        }
    }

    bool is_attached() const {
        return attached_;
    }

    PtraceAttachment(const PtraceAttachment &) = delete;
    PtraceAttachment &operator=(const PtraceAttachment &) = delete;

private:
    int pid_;
    bool attached_;
};

bool inject_library(int pid, const char *lib_path, const char *entry_name) {
    LOGI("Starting injection of %s (entry: %s) into process %d", lib_path, entry_name, pid);

    PtraceAttachment ptrace_guard(pid);
    if (!ptrace_guard.is_attached()) {
        return false;
    }

    int status;
    if (!wait_for_trace(pid, &status, __WALL)) {
        LOGE("Failed to wait for trace");
        return false;
    }

    if (!WIFSTOPPED(status) || WSTOPSIG(status) != SIGSTOP) {
        LOGE("Process stopped for unexpected reason: %s", parse_status(status).c_str());
        return false;
    }

    struct user_regs_struct current_regs{}, backup_regs{};
    if (!get_regs(pid, current_regs)) {
        LOGE("Failed to get process registers");
        return false;
    }
    backup_regs = current_regs;
    LOGD("Process stopped and registers backed up");

    auto remote_map = lsplt::MapInfo::Scan(std::to_string(pid));
    auto local_map = lsplt::MapInfo::Scan();

    auto libc_return_addr = find_module_return_addr(remote_map, constants::kLibcModule);
    if (!libc_return_addr) {
        LOGE("Failed to find return address for %s", constants::kLibcModule);
        return false;
    }
    LOGD("Found libc return address: %p", libc_return_addr);

    auto lib_fd_opt = transfer_fd_to_remote(pid, lib_path, current_regs, local_map, remote_map);
    if (!lib_fd_opt) {
        LOGE("Failed to transfer library fd to remote process");
        return false;
    }
    int lib_fd = *lib_fd_opt;

    auto handle_opt =
        remote_dlopen(pid, current_regs, local_map, remote_map, lib_fd, lib_path, reinterpret_cast<uintptr_t>(libc_return_addr));
    if (!handle_opt) {
        LOGE("Failed to load library in remote process");
        return false;
    }
    uintptr_t remote_handle = *handle_opt;

    auto close_addr = find_func_addr(local_map, remote_map, constants::kLibcModule, "close");
    if (close_addr) {
        std::vector<uintptr_t> args = {static_cast<uintptr_t>(lib_fd)};
        if (remote_call(pid, current_regs, reinterpret_cast<uintptr_t>(close_addr), 0, args) != 0) {
            LOGW("Failed to close remote library fd: %d", lib_fd);
        }
    }

    auto entry_opt =
        remote_find_entry(pid, current_regs, local_map, remote_map, remote_handle, reinterpret_cast<uintptr_t>(libc_return_addr));
    if (!entry_opt) {
        LOGE("Failed to find entry point in remote library");
        return false;
    }
    uintptr_t entry_addr = *entry_opt;

    if (!remote_call_entry(pid, current_regs, entry_addr, remote_handle, reinterpret_cast<uintptr_t>(libc_return_addr))) {
        LOGE("Failed to call entry point");
        return false;
    }

    if (!set_regs(pid, backup_regs)) {
        LOGE("Failed to restore original registers");
        return false;
    }

    LOGI("Library injection completed successfully");
    return true;
}

} // namespace inject

int main(int argc, char **argv) {
#ifndef NDEBUG
    logging::setPrintEnabled(true);
#endif

    if (argc < 4) {
        fprintf(stderr, "Usage: %s <pid> <lib_path> <entry_name>\n", argv[0]);
        fprintf(stderr, "  pid       - Target process ID\n");
        fprintf(stderr, "  lib_path  - Path to shared library to inject\n");
        fprintf(stderr, "  entry_name - Entry point symbol name in library\n");
        return EXIT_FAILURE;
    }

    char *endptr;
    long pid_long = strtol(argv[1], &endptr, 10);
    if (*endptr != '\0' || pid_long <= 0 || pid_long > INT_MAX) {
        fprintf(stderr, "Error: Invalid PID '%s'\n", argv[1]);
        return EXIT_FAILURE;
    }
    int pid = static_cast<int>(pid_long);

    char resolved_path[inject::constants::kMaxPathLength];
    if (realpath(argv[2], resolved_path) == nullptr) {
        fprintf(stderr, "Error: Failed to resolve library path '%s': %s\n", argv[2], strerror(errno));
        return EXIT_FAILURE;
    }

    if (access(resolved_path, R_OK) != 0) {
        fprintf(stderr, "Error: Library file '%s' is not readable: %s\n", resolved_path, strerror(errno));
        return EXIT_FAILURE;
    }

    const char *entry_name = argv[3];
    if (strlen(entry_name) == 0) {
        fprintf(stderr, "Error: Entry name cannot be empty\n");
        return EXIT_FAILURE;
    }

    LOGI("TrickyStore injector starting...");
    bool success = inject::inject_library(pid, resolved_path, entry_name);

    if (success) {
        LOGI("Injection completed successfully");
        return EXIT_SUCCESS;
    } else {
        LOGE("Injection failed");
        return EXIT_FAILURE;
    }
}

```

`app/src/main/cpp/inject/utils.cpp`:

```cpp
// Copyright 2025 Dakkshesh <beakthoven@gmail.com>
// SPDX-License-Identifier: GPL-3.0-or-later

#include "utils.hpp"

#include <dlfcn.h>
#include <elf.h>
#include <fcntl.h>
#include <link.h>
#include <sched.h>
#include <sys/auxv.h>
#include <sys/mman.h>
#include <sys/ptrace.h>
#include <sys/stat.h>
#include <sys/syscall.h>
#include <sys/sysmacros.h>
#include <sys/uio.h>
#include <sys/wait.h>
#include <sys/xattr.h>
#include <unistd.h>

#include <array>
#include <cinttypes>
#include <csignal>
#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <optional>
#include <random>
#include <string>
#include <string_view>
#include <vector>

#include "logging.hpp"

namespace {
constexpr size_t kMaxPathLength = 256;
constexpr size_t kMsgBufferSize = 64;
constexpr size_t kStatusBufferSize = 128;
constexpr int kInvalidFd = -1;
constexpr uintptr_t kStackAlignment = 0xf;
constexpr int kMaxArguments = 8;

constexpr char kReadPerm = 'r';
constexpr char kWritePerm = 'w';
constexpr char kExecPerm = 'x';
constexpr char kNoPerm = '-';

constexpr std::string_view kRandomChars = "0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ";
} // namespace

bool switch_mnt_ns(int pid, int *fd) {
    if (pid == 0) {
        if (!fd || *fd == kInvalidFd) {
            LOGE("Invalid file descriptor for namespace switch");
            return false;
        }

        UniqueFd nsfd(*fd);
        *fd = kInvalidFd;

        std::string path = "/proc/self/fd/" + std::to_string(nsfd);
        if (setns(nsfd, CLONE_NEWNS) == -1) {
            PLOGE("Failed to switch to namespace: %s", path.c_str());
            return false;
        }

        LOGD("Successfully switched back to original namespace");
        return true;
    } else {
        int old_nsfd = kInvalidFd;

        if (fd) {
            old_nsfd = open("/proc/self/ns/mnt", O_RDONLY | O_CLOEXEC);
            if (old_nsfd == kInvalidFd) {
                PLOGE("Failed to open current namespace");
                return false;
            }
            *fd = old_nsfd;
        }

        std::string target_path = "/proc/" + std::to_string(pid) + "/ns/mnt";
        UniqueFd target_nsfd = open(target_path.c_str(), O_RDONLY | O_CLOEXEC);
        if (target_nsfd == kInvalidFd) {
            PLOGE("Failed to open target namespace: %s", target_path.c_str());
            if (fd)
                *fd = kInvalidFd;
            return false;
        }

        if (setns(target_nsfd, CLONE_NEWNS) == -1) {
            PLOGE("Failed to switch to target namespace: %s", target_path.c_str());
            if (fd)
                *fd = kInvalidFd;
            return false;
        }

        LOGD("Successfully switched to namespace for PID %d", pid);
        return true;
    }
}

ssize_t write_proc(int pid, uintptr_t remote_addr, const void *buf, size_t len, bool use_proc_mem) {
    if (!buf || len == 0) {
        LOGE("Invalid parameters for write_proc");
        return -1;
    }

    LOGV("Writing %zu bytes to PID %d at address %" PRIxPTR " (use_proc_mem=%s)", len, pid, remote_addr,
         use_proc_mem ? "true" : "false");

    ssize_t bytes_written;

    if (use_proc_mem) {
        char proc_path[kMaxPathLength];
        snprintf(proc_path, sizeof(proc_path), "/proc/%d/mem", pid);

        UniqueFd proc_fd = open(proc_path, O_WRONLY | O_CLOEXEC);
        if (proc_fd == kInvalidFd) {
            PLOGE("Failed to open %s", proc_path);
            return -1;
        }

        bytes_written = pwrite(proc_fd, buf, len, static_cast<off_t>(remote_addr));
        if (bytes_written == -1) {
            PLOGE("pwrite failed for address %" PRIxPTR, remote_addr);
        }
    } else {
        struct iovec local_iov = {.iov_base = const_cast<void *>(buf), .iov_len = len};
        struct iovec remote_iov = {.iov_base = reinterpret_cast<void *>(remote_addr), .iov_len = len};

        bytes_written = process_vm_writev(pid, &local_iov, 1, &remote_iov, 1, 0);
        if (bytes_written == -1) {
            PLOGE("process_vm_writev failed for address %" PRIxPTR, remote_addr);
        }
    }

    if (bytes_written != -1 && static_cast<size_t>(bytes_written) != len) {
        LOGW("Partial write: %zd bytes written, %zu expected", bytes_written, len);
    }

    return bytes_written;
}

ssize_t read_proc(int pid, uintptr_t remote_addr, void *buf, size_t len) {
    if (!buf || len == 0) {
        LOGE("Invalid parameters for read_proc");
        return -1;
    }

    LOGV("Reading %zu bytes from PID %d at address %" PRIxPTR, len, pid, remote_addr);

    struct iovec local_iov = {.iov_base = buf, .iov_len = len};
    struct iovec remote_iov = {.iov_base = reinterpret_cast<void *>(remote_addr), .iov_len = len};

    ssize_t bytes_read = process_vm_readv(pid, &local_iov, 1, &remote_iov, 1, 0);
    if (bytes_read == -1) {
        PLOGE("process_vm_readv failed for address %" PRIxPTR, remote_addr);
    } else if (static_cast<size_t>(bytes_read) != len) {
        LOGW("Partial read: %zd bytes read, %zu expected", bytes_read, len);
    }

    return bytes_read;
}

bool get_regs(int pid, struct user_regs_struct &regs) {
    LOGV("Getting registers for PID %d", pid);

#if defined(__x86_64__) || defined(__i386__)
    if (ptrace(PTRACE_GETREGS, pid, 0, &regs) == -1) {
        PLOGE("Failed to get registers for PID %d", pid);
        return false;
    }
#elif defined(__aarch64__) || defined(__arm__)
    struct iovec reg_iov = {.iov_base = &regs, .iov_len = sizeof(struct user_regs_struct)};
    if (ptrace(PTRACE_GETREGSET, pid, NT_PRSTATUS, &reg_iov) == -1) {
        PLOGE("Failed to get register set for PID %d", pid);
        return false;
    }
#else
#    error "Unsupported architecture for register access"
#endif

    LOGV("Successfully retrieved registers for PID %d", pid);
    return true;
}

bool set_regs(int pid, struct user_regs_struct &regs) {
    LOGV("Setting registers for PID %d", pid);

#if defined(__x86_64__) || defined(__i386__)
    if (ptrace(PTRACE_SETREGS, pid, 0, &regs) == -1) {
        PLOGE("Failed to set registers for PID %d", pid);
        return false;
    }
#elif defined(__aarch64__) || defined(__arm__)
    struct iovec reg_iov = {.iov_base = &regs, .iov_len = sizeof(struct user_regs_struct)};
    if (ptrace(PTRACE_SETREGSET, pid, NT_PRSTATUS, &reg_iov) == -1) {
        PLOGE("Failed to set register set for PID %d", pid);
        return false;
    }
#else
#    error "Unsupported architecture for register access"
#endif

    LOGV("Successfully set registers for PID %d", pid);
    return true;
}

std::string get_addr_mem_region(const std::vector<lsplt::MapInfo> &map_info, uintptr_t addr) {
    for (const auto &map : map_info) {
        if (map.start <= addr && map.end > addr) {
            std::string perms_str;
            perms_str.reserve(4);

            perms_str += (map.perms & PROT_READ) ? kReadPerm : kNoPerm;
            perms_str += (map.perms & PROT_WRITE) ? kWritePerm : kNoPerm;
            perms_str += (map.perms & PROT_EXEC) ? kExecPerm : kNoPerm;

            return map.path + ' ' + perms_str;
        }
    }
    return "<unknown>";
}

void *find_module_base(const std::vector<lsplt::MapInfo> &map_info, std::string_view module_suffix) {
    for (const auto &map : map_info) {
        if (map.offset == 0 && map.path.ends_with(module_suffix)) {
            LOGV("Found module base for '%.*s' at %p", static_cast<int>(module_suffix.length()), module_suffix.data(),
                 reinterpret_cast<void *>(map.start));
            return reinterpret_cast<void *>(map.start);
        }
    }

    LOGV("Module base not found for suffix '%.*s'", static_cast<int>(module_suffix.length()), module_suffix.data());
    return nullptr;
}

void *find_func_addr(const std::vector<lsplt::MapInfo> &local_map_info, const std::vector<lsplt::MapInfo> &remote_map_info,
                     std::string_view module_name, std::string_view function_name) {
    LOGV("Resolving function '%.*s' in module '%.*s'", static_cast<int>(function_name.length()), function_name.data(),
         static_cast<int>(module_name.length()), module_name.data());

    void *lib_handle = dlopen(module_name.data(), RTLD_NOW);
    if (!lib_handle) {
        LOGE("Failed to open library '%.*s': %s", static_cast<int>(module_name.length()), module_name.data(), dlerror());
        return nullptr;
    }

    auto lib_closer = [lib_handle]() {
        dlclose(lib_handle);
    };

    auto *symbol_addr = reinterpret_cast<uint8_t *>(dlsym(lib_handle, function_name.data()));
    if (!symbol_addr) {
        LOGE("Failed to find symbol '%.*s' in library '%.*s': %s", static_cast<int>(function_name.length()), function_name.data(),
             static_cast<int>(module_name.length()), module_name.data(), dlerror());
        lib_closer();
        return nullptr;
    }

    LOGV("Found symbol '%.*s' at local address %p", static_cast<int>(function_name.length()), function_name.data(), symbol_addr);
    lib_closer();

    auto *local_base = reinterpret_cast<uint8_t *>(find_module_base(local_map_info, module_name));
    if (!local_base) {
        LOGE("Failed to find local base address for module '%.*s'", static_cast<int>(module_name.length()), module_name.data());
        return nullptr;
    }

    auto *remote_base = reinterpret_cast<uint8_t *>(find_module_base(remote_map_info, module_name));
    if (!remote_base) {
        LOGE("Failed to find remote base address for module '%.*s'", static_cast<int>(module_name.length()), module_name.data());
        return nullptr;
    }

    ptrdiff_t symbol_offset = symbol_addr - local_base;
    auto *remote_symbol_addr = remote_base + symbol_offset;

    LOGV("Address translation: local_base=%p remote_base=%p offset=%td -> "
         "remote_addr=%p",
         local_base, remote_base, symbol_offset, remote_symbol_addr);

    return remote_symbol_addr;
}

void align_stack(struct user_regs_struct &regs, uintptr_t preserve_bytes) {
    regs.REG_SP = (regs.REG_SP - preserve_bytes) & ~kStackAlignment;
    LOGV("Stack aligned to %" PRIxPTR " (preserved %zu bytes)", static_cast<uintptr_t>(regs.REG_SP), preserve_bytes);
}

uintptr_t push_memory(int pid, struct user_regs_struct &regs, const void *data, size_t length) {
    if (!data || length == 0) {
        LOGE("Invalid parameters for push_memory: data=%p, length=%zu", data, length);
        return 0;
    }

    regs.REG_SP -= length;
    align_stack(regs);

    auto stack_addr = static_cast<uintptr_t>(regs.REG_SP);

    if (write_proc(pid, stack_addr, data, length) != static_cast<ssize_t>(length)) {
        LOGE("Failed to push %zu bytes to remote stack at %" PRIxPTR, length, stack_addr);
        return 0;
    }

    LOGV("Pushed %zu bytes to remote stack at %" PRIxPTR, length, stack_addr);
    return stack_addr;
}

uintptr_t push_string(int pid, struct user_regs_struct &regs, const char *str) {
    if (!str) {
        LOGE("Null string pointer passed to push_string");
        return 0;
    }

    size_t str_length = strlen(str) + 1;

    regs.REG_SP -= str_length;
    align_stack(regs);

    auto stack_addr = static_cast<uintptr_t>(regs.REG_SP);

    if (write_proc(pid, stack_addr, str, str_length) != static_cast<ssize_t>(str_length)) {
        LOGE("Failed to push string '%s' to remote stack", str);
        return 0;
    }

    LOGV("Pushed string '%s' (%zu bytes) to remote stack at %" PRIxPTR, str, str_length, stack_addr);
    return stack_addr;
}

namespace {
#if defined(__x86_64__)
constexpr size_t kMaxRegisterArgs = 6;
void setup_x86_64_args(struct user_regs_struct &regs, const std::vector<uintptr_t> &args) {
    if (args.size() >= 1)
        regs.rdi = args[0];
    if (args.size() >= 2)
        regs.rsi = args[1];
    if (args.size() >= 3)
        regs.rdx = args[2];
    if (args.size() >= 4)
        regs.rcx = args[3];
    if (args.size() >= 5)
        regs.r8 = args[4];
    if (args.size() >= 6)
        regs.r9 = args[5];
}
#elif defined(__i386__)
constexpr size_t kMaxRegisterArgs = 0;
#elif defined(__aarch64__)
constexpr size_t kMaxRegisterArgs = 8;
void setup_aarch64_args(struct user_regs_struct &regs, const std::vector<uintptr_t> &args) {
    for (size_t i = 0; i < std::min(args.size(), kMaxRegisterArgs); i++) {
        regs.regs[i] = args[i];
    }
}
#elif defined(__arm__)
constexpr size_t kMaxRegisterArgs = 4;
void setup_arm_args(struct user_regs_struct &regs, const std::vector<uintptr_t> &args) {
    for (size_t i = 0; i < std::min(args.size(), kMaxRegisterArgs); i++) {
        regs.uregs[i] = args[i];
    }
}
#endif
} // namespace

bool remote_pre_call(int pid, struct user_regs_struct &regs, uintptr_t func_addr, uintptr_t return_addr,
                     std::vector<uintptr_t> &args) {
    align_stack(regs);

    LOGV("Setting up remote function call to %" PRIxPTR " with %zu arguments", func_addr, args.size());
    for (size_t i = 0; i < args.size(); i++) {
        LOGV("  arg[%zu] = %p", i, reinterpret_cast<void *>(args[i]));
    }

#if defined(__x86_64__)
    setup_x86_64_args(regs, args);

    if (args.size() > kMaxRegisterArgs) {
        size_t stack_args_size = (args.size() - kMaxRegisterArgs) * sizeof(uintptr_t);
        align_stack(regs, stack_args_size);

        if (write_proc(pid, static_cast<uintptr_t>(regs.REG_SP), args.data() + kMaxRegisterArgs, stack_args_size) !=
            static_cast<ssize_t>(stack_args_size)) {
            LOGE("Failed to push stack arguments for x86_64");
            return false;
        }
    }

    regs.REG_SP -= sizeof(uintptr_t);
    if (write_proc(pid, static_cast<uintptr_t>(regs.REG_SP), &return_addr, sizeof(return_addr)) != sizeof(return_addr)) {
        LOGE("Failed to write return address");
        return false;
    }

    regs.REG_IP = func_addr;

#elif defined(__i386__)
    if (args.size() > 0) {
        size_t stack_args_size = args.size() * sizeof(uintptr_t);
        align_stack(regs, stack_args_size);

        if (write_proc(pid, static_cast<uintptr_t>(regs.REG_SP), args.data(), stack_args_size) !=
            static_cast<ssize_t>(stack_args_size)) {
            LOGE("Failed to push arguments for i386");
            return false;
        }
    }

    regs.REG_SP -= sizeof(uintptr_t);
    if (write_proc(pid, static_cast<uintptr_t>(regs.REG_SP), &return_addr, sizeof(return_addr)) != sizeof(return_addr)) {
        LOGE("Failed to write return address for i386");
        return false;
    }

    regs.REG_IP = func_addr;

#elif defined(__aarch64__)
    setup_aarch64_args(regs, args);

    if (args.size() > kMaxRegisterArgs) {
        size_t stack_args_size = (args.size() - kMaxRegisterArgs) * sizeof(uintptr_t);
        align_stack(regs, stack_args_size);

        if (write_proc(pid, static_cast<uintptr_t>(regs.REG_SP), args.data() + kMaxRegisterArgs, stack_args_size) !=
            static_cast<ssize_t>(stack_args_size)) {
            LOGE("Failed to push stack arguments for aarch64");
            return false;
        }
    }

    regs.regs[30] = return_addr;
    regs.REG_IP = func_addr;

#elif defined(__arm__)
    setup_arm_args(regs, args);

    if (args.size() > kMaxRegisterArgs) {
        size_t stack_args_size = (args.size() - kMaxRegisterArgs) * sizeof(uintptr_t);
        align_stack(regs, stack_args_size);

        if (write_proc(pid, static_cast<uintptr_t>(regs.REG_SP), args.data() + kMaxRegisterArgs, stack_args_size) !=
            static_cast<ssize_t>(stack_args_size)) {
            LOGE("Failed to push stack arguments for ARM");
            return false;
        }
    }

    regs.uregs[14] = return_addr;
    regs.REG_IP = func_addr;

    constexpr auto CPSR_T_MASK = 1lu << 5;
    if ((regs.REG_IP & 1) != 0) {
        regs.REG_IP = regs.REG_IP & ~1;
        regs.uregs[16] = regs.uregs[16] | CPSR_T_MASK;
    } else {
        regs.uregs[16] = regs.uregs[16] & ~CPSR_T_MASK;
    }

#else
#    error "Unsupported architecture for remote function calls"
#endif

    if (!set_regs(pid, regs)) {
        LOGE("Failed to set registers for remote function call");
        return false;
    }

    if (ptrace(PTRACE_CONT, pid, 0, 0) == -1) {
        PLOGE("Failed to continue remote process execution");
        return false;
    }

    LOGV("Remote function call initiated successfully");
    return true;
}

uintptr_t remote_post_call(int pid, struct user_regs_struct &regs, uintptr_t expected_return_addr) {
    LOGV("Waiting for remote function call completion");

    int status;
    if (!wait_for_trace(pid, &status, __WALL)) {
        LOGE("Failed to wait for remote function completion");
        return 0;
    }

    if (!get_regs(pid, regs)) {
        LOGE("Failed to get registers after remote call");
        return 0;
    }

    int stop_signal = WSTOPSIG(status);
    LOGV("Remote function stopped with signal: %s(%d) at address %p", sigabbrev_np(stop_signal), stop_signal,
         reinterpret_cast<void *>(regs.REG_IP));

    if (stop_signal == SIGSEGV) {
        if (static_cast<uintptr_t>(regs.REG_IP) != expected_return_addr) {
            LOGE("Function returned to unexpected address %p (expected %p)", reinterpret_cast<void *>(regs.REG_IP),
                 reinterpret_cast<void *>(expected_return_addr));

            siginfo_t crash_info;
            if (ptrace(PTRACE_GETSIGINFO, pid, 0, &crash_info) == 0) {
                LOGE("Crash details: si_code=%d si_addr=%p", crash_info.si_code, crash_info.si_addr);
            } else {
                PLOGE("Failed to get crash signal info");
            }
            return 0;
        }

        uintptr_t return_value = regs.REG_RET;
        LOGV("Remote function completed with return value: %p", reinterpret_cast<void *>(return_value));
        return return_value;
    } else {
        LOGE("Remote function stopped unexpectedly: %s at address %p", parse_status(status).c_str(),
             reinterpret_cast<void *>(regs.REG_IP));
        return 0;
    }
}

uintptr_t remote_call(int pid, struct user_regs_struct &regs, uintptr_t func_addr, uintptr_t return_addr,
                      std::vector<uintptr_t> &args) {
    if (!remote_pre_call(pid, regs, func_addr, return_addr, args)) {
        LOGE("Failed to prepare remote function call");
        return 0;
    }
    return remote_post_call(pid, regs, return_addr);
}

int fork_dont_care() {
    int first_pid = fork();
    if (first_pid < 0) {
        PLOGE("Failed first fork for daemon process");
        return first_pid;
    }

    if (first_pid == 0) {
        int second_pid = fork();
        if (second_pid < 0) {
            PLOGE("Failed second fork for daemon process");
            exit(EXIT_FAILURE);
        } else if (second_pid > 0) {
            exit(EXIT_SUCCESS);
        }
        return 0;
    } else {
        int status;
        waitpid(first_pid, &status, __WALL);
        return first_pid;
    }
}

bool wait_for_trace(int pid, int *status, int flags) {
    if (!status) {
        LOGE("Null status pointer passed to wait_for_trace");
        return false;
    }

    while (true) {
        pid_t result = waitpid(pid, status, flags);
        if (result == -1) {
            if (errno == EINTR) {
                LOGV("waitpid interrupted, retrying");
                continue;
            } else {
                PLOGE("waitpid failed for PID %d", pid);
                return false;
            }
        }

        if (!WIFSTOPPED(*status)) {
            LOGE("Process %d not stopped for trace: %s", pid, parse_status(*status).c_str());
            return false;
        }

        LOGV("Process %d stopped for trace with status: %s", pid, parse_status(*status).c_str());
        return true;
    }
}

std::string parse_status(int status) {
    char status_buf[kStatusBufferSize];

    if (WIFEXITED(status)) {
        snprintf(status_buf, sizeof(status_buf), "0x%x exited with code %d", status, WEXITSTATUS(status));
    } else if (WIFSIGNALED(status)) {
        snprintf(status_buf, sizeof(status_buf), "0x%x terminated by signal %s(%d)", status, sigabbrev_np(WTERMSIG(status)),
                 WTERMSIG(status));
    } else if (WIFSTOPPED(status)) {
        int stop_signal = WSTOPSIG(status);
        snprintf(status_buf, sizeof(status_buf), "0x%x stopped by signal=%s(%d), event=%s", status, sigabbrev_np(stop_signal),
                 stop_signal, parse_ptrace_event(status));
    } else {
        snprintf(status_buf, sizeof(status_buf), "0x%x unknown status", status);
    }

    return std::string(status_buf);
}

std::string get_program(int pid) {
    std::string exe_path = "/proc/" + std::to_string(pid) + "/exe";
    char resolved_path[kMaxPathLength + 1];

    ssize_t link_size = readlink(exe_path.c_str(), resolved_path, kMaxPathLength);
    if (link_size == -1) {
        PLOGE("Failed to read executable path for PID %d", pid);
        return "";
    }

    resolved_path[link_size] = '\0';
    return std::string(resolved_path);
}

void *find_module_return_addr(const std::vector<lsplt::MapInfo> &map_info, std::string_view module_suffix) {
    for (const auto &map : map_info) {
        if ((map.perms & PROT_EXEC) == 0 && map.path.ends_with(module_suffix)) {
            LOGV("Found return address region for '%.*s' at %p", static_cast<int>(module_suffix.length()), module_suffix.data(),
                 reinterpret_cast<void *>(map.start));
            return reinterpret_cast<void *>(map.start);
        }
    }

    LOGV("No return address region found for module suffix '%.*s'", static_cast<int>(module_suffix.length()), module_suffix.data());
    return nullptr;
}

std::string generateMagic(size_t length) {
    if (length == 0) {
        LOGW("Zero length requested for magic string");
        return "";
    }

    std::mt19937 random_generator{std::random_device{}()};
    std::uniform_int_distribution<size_t> char_distribution(0, kRandomChars.length() - 1);

    std::string magic_string;
    magic_string.reserve(length);

    for (size_t i = 0; i < length; i++) {
        magic_string += kRandomChars[char_distribution(random_generator)];
    }

    LOGV("Generated magic string of length %zu", length);
    return magic_string;
}

int setfilecon(const char *file_path, const char *security_context) {
    if (!file_path || !security_context) {
        LOGE("Invalid parameters for setfilecon: path=%p, context=%p", file_path, security_context);
        return -1;
    }

    size_t context_len = strlen(security_context) + 1;
    int result = syscall(__NR_setxattr, file_path, XATTR_NAME_SELINUX, security_context, context_len, 0);

    if (result == 0) {
        LOGV("Successfully set SELinux context '%s' for file '%s'", security_context, file_path);
    } else {
        PLOGE("Failed to set SELinux context '%s' for file '%s'", security_context, file_path);
    }

    return result;
}

bool set_sockcreate_con(const char *security_context) {
    if (!security_context) {
        LOGE("Null security context passed to set_sockcreate_con");
        return false;
    }

    size_t context_size = strlen(security_context) + 1;

    UniqueFd sockcreate_fd = open("/proc/thread-self/attr/sockcreate", O_WRONLY | O_CLOEXEC);
    if (sockcreate_fd != kInvalidFd && write(sockcreate_fd, security_context, context_size) == static_cast<ssize_t>(context_size)) {
        LOGV("Successfully set socket creation context via thread-self: '%s'", security_context);
        return true;
    }

    LOGV("Thread-self sockcreate failed, trying process-specific fallback");
    char process_path[kMaxPathLength];
    snprintf(process_path, sizeof(process_path), "/proc/%d/attr/sockcreate", gettid());

    sockcreate_fd = open(process_path, O_WRONLY | O_CLOEXEC);
    if (sockcreate_fd == kInvalidFd || write(sockcreate_fd, security_context, context_size) != static_cast<ssize_t>(context_size)) {
        PLOGE("Failed to set socket creation context via fallback path '%s'", process_path);
        return false;
    }

    LOGV("Successfully set socket creation context via fallback: '%s'", security_context);
    return true;
}

```

`app/src/main/cpp/inject/utils.hpp`:

```hpp
// Copyright 2025 Dakkshesh <beakthoven@gmail.com>
// SPDX-License-Identifier: GPL-3.0-or-later

#pragma once
#include <sys/ptrace.h>
#include <unistd.h>

#include <map>
#include <string>

#include "lsplt.hpp"

#define LOG_TAG "TrickyStoreOSS"

#define SYSCALL_IS_ERR(e) (((unsigned long)e) > -4096UL)
#define SYSCALL_ERR(e) (-(int)(e))

#if defined(__x86_64__)
#    define REG_SP rsp
#    define REG_IP rip
#    define REG_RET rax
#    define REG_NR orig_rax
#    define REG_SYS_ARG0 rdi
#elif defined(__i386__)
#    define REG_SP esp
#    define REG_IP eip
#    define REG_RET eax
#    define REG_NR orig_eax
#    define REG_SYS_ARG0 ebx
#elif defined(__aarch64__)
#    define REG_SP sp
#    define REG_IP pc
#    define REG_RET regs[0]
#    define REG_NR regs[8]
#    define REG_SYS_ARG0 regs[0]
#elif defined(__arm__)
#    define REG_SP uregs[13]
#    define REG_IP uregs[15]
#    define REG_RET uregs[0]
#    define REG_NR uregs[7]
#    define REG_SYS_ARG0 uregs[0]
#    define user_regs_struct user_regs
#    define SYS_mmap SYS_mmap2
#endif

ssize_t write_proc(int pid, uintptr_t remote_addr, const void *buf, size_t len, bool use_proc_mem = false);
ssize_t read_proc(int pid, uintptr_t remote_addr, void *buf, size_t len);

bool get_regs(int pid, struct user_regs_struct &regs);
bool set_regs(int pid, struct user_regs_struct &regs);

std::string get_addr_mem_region(const std::vector<lsplt::MapInfo> &map_info, uintptr_t addr);
void *find_module_base(const std::vector<lsplt::MapInfo> &map_info, std::string_view module_suffix);
void *find_func_addr(const std::vector<lsplt::MapInfo> &local_map_info, const std::vector<lsplt::MapInfo> &remote_map_info,
                     std::string_view module_name, std::string_view function_name);
void align_stack(struct user_regs_struct &regs, uintptr_t preserve_bytes = 0);
uintptr_t push_memory(int pid, struct user_regs_struct &regs, const void *data, size_t length);
uintptr_t push_string(int pid, struct user_regs_struct &regs, const char *str);

uintptr_t remote_call(int pid, struct user_regs_struct &regs, uintptr_t func_addr, uintptr_t return_addr,
                      std::vector<uintptr_t> &args);
bool remote_pre_call(int pid, struct user_regs_struct &regs, uintptr_t func_addr, uintptr_t return_addr, std::vector<uintptr_t> &args);
uintptr_t remote_post_call(int pid, struct user_regs_struct &regs, uintptr_t expected_return_addr);

int fork_dont_care();
bool wait_for_trace(int pid, int *status, int flags);
std::string parse_status(int status);
std::string get_program(int pid);
void *find_module_return_addr(const std::vector<lsplt::MapInfo> &map_info, std::string_view module_suffix);
bool switch_mnt_ns(int pid, int *fd);
std::vector<std::string> get_cmdline(int pid);
std::string parse_exec(int pid);
bool skip_syscall(int pid);
bool do_syscall(int pid, uintptr_t &ret, int nr, uintptr_t arg0 = 0, uintptr_t arg1 = 0, uintptr_t arg2 = 0, uintptr_t arg3 = 0,
                uintptr_t arg4 = 0, uintptr_t arg5 = 0);

uintptr_t remote_mmap(int pid, uintptr_t addr, size_t size, int prot, int flags, int fd, off_t offset);
bool remote_munmap(int pid, uintptr_t addr, size_t size);
int remote_open(int pid, uintptr_t path_addr, int flags);
bool remote_close(int pid, int fd);
int wait_for_child(int pid);
int get_elf_class(std::string_view path);

constexpr size_t kMainMagicLength = 16;
std::string generateMagic(size_t length);
int setfilecon(const char *file_path, const char *security_context);

class UniqueFd {
    using Fd = int;

public:
    UniqueFd() = default;
    UniqueFd(Fd fd) : fd_(fd) {}
    ~UniqueFd() {
        if (fd_ >= 0)
            close(fd_);
    }
    UniqueFd(const UniqueFd &) = delete;
    UniqueFd &operator=(const UniqueFd &) = delete;
    UniqueFd(UniqueFd &&other) {
        std::swap(fd_, other.fd_);
    }
    UniqueFd &operator=(UniqueFd &&other) {
        std::swap(fd_, other.fd_);
        return *this;
    }
    operator const Fd &() const {
        return fd_;
    }

private:
    Fd fd_ = -1;
};

bool set_sockcreate_con(const char *security_context);

#define WPTEVENT(x) (x >> 16)
#define CASE_CONST_RETURN(x) \
    case x:                  \
        return #x;
inline const char *parse_ptrace_event(int status) {
    status = status >> 16;
    switch (status) {
        CASE_CONST_RETURN(PTRACE_EVENT_FORK)
        CASE_CONST_RETURN(PTRACE_EVENT_VFORK)
        CASE_CONST_RETURN(PTRACE_EVENT_CLONE)
        CASE_CONST_RETURN(PTRACE_EVENT_EXEC)
        CASE_CONST_RETURN(PTRACE_EVENT_VFORK_DONE)
        CASE_CONST_RETURN(PTRACE_EVENT_EXIT)
        CASE_CONST_RETURN(PTRACE_EVENT_SECCOMP)
        CASE_CONST_RETURN(PTRACE_EVENT_STOP)
    default:
        return "(no event)";
    }
}
inline const char *sigabbrev_np(int sig) {
    if (sig > 0 && sig < NSIG)
        return sys_signame[sig];
    return "(unknown)";
}

```

`app/src/main/cpp/logging/include/logging.hpp`:

```hpp
// Copyright 2025 Dakkshesh <beakthoven@gmail.com>
// SPDX-License-Identifier: GPL-3.0-or-later

#pragma once

#include <android/log.h>
#include <cerrno>
#include <cstring>
#include <string>

#ifndef LOG_TAG
#    define LOG_TAG "TrickyStoreOSS"
#endif

#ifndef NDEBUG
#    define LOGD(...) logging::log(ANDROID_LOG_DEBUG, LOG_TAG, __VA_ARGS__)
#    define LOGV(...) logging::log(ANDROID_LOG_VERBOSE, LOG_TAG, __VA_ARGS__)
#else
#    define LOGD(...) (void)0
#    define LOGV(...) (void)0
#endif
#define LOGI(...) logging::log(ANDROID_LOG_INFO, LOG_TAG, __VA_ARGS__)
#define LOGW(...) logging::log(ANDROID_LOG_WARN, LOG_TAG, __VA_ARGS__)
#define LOGE(...) logging::log(ANDROID_LOG_ERROR, LOG_TAG, __VA_ARGS__)
#define LOGF(...) logging::log(ANDROID_LOG_FATAL, LOG_TAG, __VA_ARGS__)
#define PLOGE(fmt, args...) LOGE(fmt " failed with %d: %s", ##args, errno, strerror(errno))

namespace logging {
void setPrintEnabled(bool print);

[[gnu::format(printf, 3, 4)]]
void log(int prio, const char *tag, const char *fmt, ...);
} // namespace logging

```

`app/src/main/cpp/logging/logging.cpp`:

```cpp
// Copyright 2025 Dakkshesh <beakthoven@gmail.com>
// SPDX-License-Identifier: GPL-3.0-or-later

#include <android/log.h>
#include <cstdio>
#include <string>
#include <unistd.h>

#include "logging.hpp"

namespace logging {
static bool use_print = false;
static char prio_str[] = {'V', 'D', 'I', 'W', 'E', 'F'};

void setPrintEnabled(bool print) {
    use_print = print;
}

void log(int prio, const char *tag, const char *fmt, ...) {
    {
        va_list ap;
        va_start(ap, fmt);
        __android_log_vprint(prio, tag, fmt, ap);
        va_end(ap);
    }
    if (use_print) {
        char buf[BUFSIZ];
        va_list ap;
        va_start(ap, fmt);
        vsnprintf(buf, sizeof(buf), fmt, ap);
        va_end(ap);
        auto prio_char = (prio > ANDROID_LOG_DEFAULT && prio <= ANDROID_LOG_FATAL) ? prio_str[prio - ANDROID_LOG_VERBOSE] : '?';
        printf("[%c][%d:%d][%s]:%s\n", prio_char, getpid(), gettid(), tag, buf);
    }
}
} // namespace logging
```

`app/src/main/cpp/stub/stub_binder.cpp`:

```cpp
// Copyright 2025 Dakkshesh <beakthoven@gmail.com>
// SPDX-License-Identifier: GPL-3.0-or-later

#include "binder/Binder.h"
#include "binder/BpBinder.h"
#include "binder/IPCThreadState.h"
#include "binder/IServiceManager.h"
#include "binder/Status.h"

namespace android {

IBinder::IBinder() {}
IBinder::~IBinder() {}
sp<IInterface> IBinder::queryLocalInterface(const String16 &) {
    return nullptr;
}
BBinder *IBinder::localBinder() {
    return nullptr;
}
BpBinder *IBinder::remoteBinder() {
    return nullptr;
}
bool IBinder::checkSubclass(const void *) const {
    return false;
}
void IBinder::withLock(const std::function<void()> &) {}

#ifdef __LP64__
static_assert(sizeof(IBinder) == 24);
static_assert(sizeof(BBinder) == 40);
#else
static_assert(sizeof(IBinder) == 12);
static_assert(sizeof(BBinder) == 20);
#endif

BBinder::BBinder() {}
BBinder::~BBinder() {}

const String16 &BBinder::getInterfaceDescriptor() const {
    __builtin_unreachable();
}
bool BBinder::isBinderAlive() const {
    return false;
}
status_t BBinder::pingBinder() {
    return 0;
}
status_t BBinder::dump(int, const Vector<String16> &) {
    return 0;
}
status_t BBinder::transact(uint32_t, const Parcel &, Parcel *, uint32_t) {
    return 0;
}
status_t BBinder::linkToDeath(const sp<DeathRecipient> &, void *, uint32_t) {
    return 0;
}
status_t BBinder::unlinkToDeath(const wp<DeathRecipient> &, void *, uint32_t, wp<DeathRecipient> *) {
    return 0;
}
void *BBinder::attachObject(const void *, void *, void *, object_cleanup_func) {
    return nullptr;
}
void *BBinder::findObject(const void *) const {
    return nullptr;
}
void *BBinder::detachObject(const void *) {
    return nullptr;
}
void BBinder::withLock(const std::function<void()> &) {}
BBinder *BBinder::localBinder() {
    return nullptr;
}
status_t BBinder::onTransact(uint32_t, const Parcel &, Parcel *, uint32_t) {
    return 0;
}

IPCThreadState *IPCThreadState::self() {
    return nullptr;
}
IPCThreadState *IPCThreadState::selfOrNull() {
    return nullptr;
}
pid_t IPCThreadState::getCallingPid() const {
    return 0;
}
const char *IPCThreadState::getCallingSid() const {
    return nullptr;
}
uid_t IPCThreadState::getCallingUid() const {
    return 0;
}

#ifdef __LP64__
static_assert(sizeof(Parcel) == 120);
#else
static_assert(sizeof(Parcel) == 60);
#endif

Parcel::Parcel() {}
Parcel::~Parcel() {}
const uint8_t *Parcel::data() const {
    return nullptr;
}
size_t Parcel::dataSize() const {
    return 0;
}
size_t Parcel::dataAvail() const {
    return 0;
}
size_t Parcel::dataPosition() const {
    return 0;
}
size_t Parcel::dataCapacity() const {
    return 0;
}
size_t Parcel::dataBufferSize() const {
    return 0;
}
status_t Parcel::setDataSize(size_t) {
    return 0;
}
void Parcel::setDataPosition(size_t) const {}
status_t Parcel::setDataCapacity(size_t) {
    return 0;
}
status_t Parcel::setData(const uint8_t *, size_t) {
    return 0;
}
status_t Parcel::appendFrom(const Parcel *, size_t, size_t) {
    return 0;
}
binder::Status Parcel::enforceNoDataAvail() const {
    return {};
}
void Parcel::setEnforceNoDataAvail(bool) {}
void Parcel::freeData() {}
status_t Parcel::write(const void *, size_t) {
    return 0;
}
void *Parcel::writeInplace(size_t) {
    return nullptr;
}
status_t Parcel::writeInt32(int32_t) {
    return 0;
}
status_t Parcel::writeUint32(uint32_t) {
    return 0;
}
status_t Parcel::writeInt64(int64_t) {
    return 0;
}
status_t Parcel::writeUint64(uint64_t) {
    return 0;
}
status_t Parcel::writeFloat(float) {
    return 0;
}
status_t Parcel::writeDouble(double) {
    return 0;
}
status_t Parcel::writeCString(const char *) {
    return 0;
}
status_t Parcel::writeString8(const char *, size_t) {
    return 0;
}
status_t Parcel::writeStrongBinder(const sp<IBinder> &) {
    return 0;
}
status_t Parcel::writeBool(bool) {
    return 0;
}
status_t Parcel::writeChar(char16_t) {
    return 0;
}
status_t Parcel::writeByte(int8_t) {
    return 0;
}
status_t Parcel::writeNoException() {
    return 0;
}
status_t Parcel::read(void *, size_t) const {
    return 0;
}
const void *Parcel::readInplace(size_t) const {
    return nullptr;
}
int32_t Parcel::readInt32() const {
    return 0;
}
status_t Parcel::readInt32(int32_t *) const {
    return 0;
}
uint32_t Parcel::readUint32() const {
    return 0;
}
status_t Parcel::readUint32(uint32_t *) const {
    return 0;
}
int64_t Parcel::readInt64() const {
    return 0;
}
status_t Parcel::readInt64(int64_t *) const {
    return 0;
}
uint64_t Parcel::readUint64() const {
    return 0;
}
status_t Parcel::readUint64(uint64_t *) const {
    return 0;
}
float Parcel::readFloat() const {
    return 0;
}
status_t Parcel::readFloat(float *) const {
    return 0;
}
double Parcel::readDouble() const {
    return 0;
}
status_t Parcel::readDouble(double *) const {
    return 0;
}
bool Parcel::readBool() const {
    return 0;
}
status_t Parcel::readBool(bool *) const {
    return 0;
}
char16_t Parcel::readChar() const {
    return 0;
}
status_t Parcel::readChar(char16_t *) const {
    return 0;
}
int8_t Parcel::readByte() const {
    return 0;
}
status_t Parcel::readByte(int8_t *) const {
    return 0;
}
sp<IBinder> Parcel::readStrongBinder() const {
    return nullptr;
}
status_t Parcel::readStrongBinder(sp<IBinder> *) const {
    return 0;
}
status_t Parcel::readNullableStrongBinder(sp<IBinder> *) const {
    return 0;
}
int32_t Parcel::readExceptionCode() const {
    return 0;
}
int Parcel::readFileDescriptor() const {
    return 0;
}

IServiceManager::IServiceManager() {}
IServiceManager::~IServiceManager() {}
const String16 &IServiceManager::getInterfaceDescriptor() const {
    __builtin_unreachable();
}
sp<IServiceManager> defaultServiceManager() {
    return nullptr;
}
void setDefaultServiceManager(const sp<IServiceManager> &) {}

} // namespace android

```

`app/src/main/cpp/stub/stub_utils.cpp`:

```cpp
// Copyright 2025 Dakkshesh <beakthoven@gmail.com>
// SPDX-License-Identifier: GPL-3.0-or-later

#include "utils/RefBase.h"
#include "utils/String16.h"
#include "utils/StrongPointer.h"

namespace android {
void RefBase::incStrong(const void *id) const {}

void RefBase::incStrongRequireStrong(const void *id) const {}

void RefBase::decStrong(const void *id) const {}

void RefBase::forceIncStrong(const void *id) const {}

RefBase::weakref_type *RefBase::createWeak(const void *id) const {
    return nullptr;
}

RefBase::weakref_type *RefBase::getWeakRefs() const {
    return nullptr;
}

RefBase::RefBase() : mRefs(nullptr) {}
RefBase::~RefBase() {}

void RefBase::onFirstRef() {}
void RefBase::onLastStrongRef(const void *id) {}
bool RefBase::onIncStrongAttempted(uint32_t flags, const void *id) {
    return false;
}
void RefBase::onLastWeakRef(const void *id) {}

RefBase *RefBase::weakref_type::refBase() const {
    return nullptr;
}

void RefBase::weakref_type::incWeak(const void *id) {}
void RefBase::weakref_type::incWeakRequireWeak(const void *id) {}
void RefBase::weakref_type::decWeak(const void *id) {}

bool RefBase::weakref_type::attemptIncStrong(const void *id) {
    return false;
}

bool RefBase::weakref_type::attemptIncWeak(const void *id) {
    return false;
}

void sp_report_race() {}

String16::String16() {}

String16::String16(const String16 &o) {}

String16::String16(String16 &&o) noexcept {}

String16::String16(const char *o) {}

String16::~String16() {}
} // namespace android

```

`app/src/main/java/io/github/beakthoven/TrickyStoreOSS/AndroidUtils.kt`:

```kt
/*
 * Copyright 2025 Dakkshesh <beakthoven@gmail.com>
 * SPDX-License-Identifier: GPL-3.0-or-later
 */

package io.github.beakthoven.TrickyStoreOSS

import android.content.pm.IPackageManager
import android.content.pm.PackageManager
import android.os.Build
import android.os.ServiceManager
import android.os.SystemProperties
import io.github.beakthoven.TrickyStoreOSS.AttestUtils.CachedAttestData
import io.github.beakthoven.TrickyStoreOSS.config.CustomPatchLevel
import io.github.beakthoven.TrickyStoreOSS.config.PkgConfig
import io.github.beakthoven.TrickyStoreOSS.logging.Logger
import org.bouncycastle.asn1.ASN1Integer
import org.bouncycastle.asn1.DEROctetString
import org.bouncycastle.asn1.DERSequence
import java.security.MessageDigest
import java.util.concurrent.ThreadLocalRandom

object AndroidUtils {

    val bootKey: ByteArray by lazy {
        randomBytes()
    }

    fun setupBootHash() {
        getBootHashFromProp()?.also { 
            Logger.d("Using boot hash from system property: ${it.toHex()}")
        }
        ?: getBootHashFromAttestation()?.also { 
            Logger.d("Using boot hash from attestation: ${it.toHex()}")
            setBootHashProp(it)
        }
        ?: randomBytes().also { 
            Logger.d("Generating random boot hash: ${it.toHex()}")
            setBootHashProp(it)
        }
    }

    @OptIn(ExperimentalStdlibApi::class)
    fun getBootHashFromProp(): ByteArray? {
        val digest = SystemProperties.get("ro.boot.vbmeta.digest", null) ?: return null
        Logger.d("System property ro.boot.vbmeta.digest: $digest")
        
        if (digest.isBlank()) {
            Logger.d("Property is blank")
            return null
        }
        
        return if (digest.length == 64) digest.hexToByteArray() else null
    }

    private fun getBootHashFromAttestation(): ByteArray? {
        return try {
            CachedAttestData?.verifiedBootHash
        } catch (e: Exception) {
            Logger.e("Failed to get boot hash from attestation: ${e.message}")
            null
        }
    }

    private fun setBootHashProp(bytes: ByteArray) {
        val hex = bytes.toHex()
        try {
            Logger.d("Setting ro.boot.vbmeta.digest to: $hex")
            SystemProperties.set("ro.boot.vbmeta.digest", hex)
        } catch (e: Exception) {
            Logger.e("Exception setting vbmeta digest: ${e.message}")
        }
    }

    private fun randomBytes(): ByteArray = ByteArray(32).also { 
        ThreadLocalRandom.current().nextBytes(it) 
    }

    val patchLevel: Int
        get() = getCustomPatchLevel("system", false) 
            ?: Build.VERSION.SECURITY_PATCH.convertPatchLevel(false)

    val patchLevelLong: Int
        get() = getCustomPatchLevel("system", true) 
            ?: Build.VERSION.SECURITY_PATCH.convertPatchLevel(true)

    val vendorPatchLevel: Int
        get() = getCustomPatchLevel("vendor", false) 
            ?: Build.VERSION.SECURITY_PATCH.convertPatchLevel(false)

    val vendorPatchLevelLong: Int
        get() = getCustomPatchLevel("vendor", true) 
            ?: Build.VERSION.SECURITY_PATCH.convertPatchLevel(true)

    val bootPatchLevel: Int
        get() = getCustomPatchLevel("boot", false) 
            ?: Build.VERSION.SECURITY_PATCH.convertPatchLevel(false)

    val bootPatchLevelLong: Int
        get() = getCustomPatchLevel("boot", true) 
            ?: Build.VERSION.SECURITY_PATCH.convertPatchLevel(true)

    private val customPatchLevel: CustomPatchLevel?
        get() = PkgConfig._customPatchLevel

    private fun getCustomPatchLevel(component: String, isLong: Boolean): Int? {
        val config = customPatchLevel ?: return null
        val value = when (component) {
            "system" -> config.system ?: config.all
            "vendor" -> config.vendor ?: config.all
            "boot" -> config.boot ?: config.all
            else -> config.all
        } ?: return null

        when {
            value.equals("no", ignoreCase = true) -> return null
            value.equals("prop", ignoreCase = true) -> return null
        }

        return parsePatchLevelValue(value, component, isLong)
    }

    private fun parsePatchLevelValue(value: String, component: String, isLong: Boolean): Int? {
        val normalized = value.replace("-", "")
        
        return try {
            when (normalized.length) {
                8 -> {
                    val year = normalized.substring(0, 4).toInt()
                    val month = normalized.substring(4, 6).toInt()
                    val day = normalized.substring(6, 8).toInt()
                    if (isLong) year * 10000 + month * 100 + day
                    else year * 100 + month
                }
                6 -> {
                    val year = normalized.substring(0, 4).toInt()
                    val month = normalized.substring(4, 6).toInt()
                    if (isLong) year * 10000 + month * 100
                    else year * 100 + month
                }
                else -> {
                    Logger.e("Invalid patch level length for $component: $normalized")
                    null
                }
            }
        } catch (e: NumberFormatException) {
            Logger.e("Patch level parse error for $component=$value", e)
            null
        }
    }

    private val osVersionMap = mapOf(
        Build.VERSION_CODES.BAKLAVA to 160000,
        Build.VERSION_CODES.VANILLA_ICE_CREAM to 150000,
        Build.VERSION_CODES.UPSIDE_DOWN_CAKE to 140000,
        Build.VERSION_CODES.TIRAMISU to 130000,
        Build.VERSION_CODES.S_V2 to 120100,
        Build.VERSION_CODES.S to 120000,
        Build.VERSION_CODES.R to 110000,
        Build.VERSION_CODES.Q to 100000
    )

    val osVersion: Int
        get() = CachedAttestData?.osVersion ?: osVersionMap[Build.VERSION.SDK_INT] ?: 160000

    private val attestVersionMap = mapOf(
        Build.VERSION_CODES.Q to 4,                   // Keymaster 4.1
        Build.VERSION_CODES.R to 4,                   // Keymaster 4.1
        Build.VERSION_CODES.S to 100,                 // KeyMint 1.0
        Build.VERSION_CODES.S_V2 to 100,              // KeyMint 1.0
        Build.VERSION_CODES.TIRAMISU to 200,          // KeyMint 2.0
        Build.VERSION_CODES.UPSIDE_DOWN_CAKE to 300,  // KeyMint 3.0
        Build.VERSION_CODES.VANILLA_ICE_CREAM to 300, // KeyMint 3.0
        Build.VERSION_CODES.BAKLAVA to 400            // KeyMint 4.0
    )

    val attestVersion: Int
        get() = CachedAttestData?.attestVersion ?: attestVersionMap[Build.VERSION.SDK_INT] ?: 400

    val keymasterVersion: Int
        get() = CachedAttestData?.keymasterVersion ?: if (attestVersion == 4) 41 else attestVersion

    fun String.convertPatchLevel(isLong: Boolean): Int = runCatching {
        val parts = split("-")
        when {
            isLong && parts.size >= 3 -> parts[0].toInt() * 10000 + parts[1].toInt() * 100 + parts[2].toInt()
            parts.size >= 2 -> parts[0].toInt() * 100 + parts[1].toInt()
            else -> throw IllegalArgumentException("Invalid patch level format: $this")
        }
    }.onFailure { 
        Logger.e("Invalid patch level format: $this", it) 
    }.getOrDefault(202404)

    val apexInfos: List<Pair<String, Long>> by lazy {
        runCatching {
            val packageManager = IPackageManager.Stub.asInterface(ServiceManager.getService("package"))
            val packages = if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.TIRAMISU) {
                packageManager.getInstalledPackages(PackageManager.MATCH_APEX.toLong(), 0)
            } else {
                @Suppress("DEPRECATION")
                packageManager.getInstalledPackages(PackageManager.MATCH_APEX, 0)
            }
            
            packages.list
                .map { it.packageName to it.longVersionCode }
                .sortedBy { it.first }
        }.getOrElse { 
            Logger.e("Failed to get APEX package information")
            emptyList() 
        }
    }

    val moduleHash: ByteArray by lazy {
        runCatching {
            val encodables = apexInfos.flatMap { (packageName, versionCode) ->
                listOf(
                    DEROctetString(packageName.toByteArray()),
                    ASN1Integer(versionCode)
                )
            }
            
            val sequence = DERSequence(encodables.toTypedArray())
            MessageDigest.getInstance("SHA-256").digest(sequence.encoded)
        }.getOrElse {
            Logger.e("Failed to compute module hash", it)
            ByteArray(32)
        }
    }

}

fun String.trimLine(): String = trim().split("\n").joinToString("\n") { it.trim() }
fun ByteArray.toHex(): String = joinToString("") { "%02x".format(it) }
```

`app/src/main/java/io/github/beakthoven/TrickyStoreOSS/AttestUtils.kt`:

```kt
/*
 * Copyright 2025 Dakkshesh <beakthoven@gmail.com>
 * SPDX-License-Identifier: GPL-3.0-or-later
 */

package io.github.beakthoven.TrickyStoreOSS

import android.os.Build
import android.security.keystore.KeyGenParameterSpec
import android.security.keystore.KeyProperties
import io.github.beakthoven.TrickyStoreOSS.logging.Logger
import org.bouncycastle.asn1.ASN1Integer
import org.bouncycastle.asn1.ASN1ObjectIdentifier
import org.bouncycastle.asn1.ASN1OctetString
import org.bouncycastle.asn1.ASN1Sequence
import org.bouncycastle.asn1.ASN1TaggedObject
import org.bouncycastle.asn1.x509.Extension
import org.bouncycastle.cert.X509CertificateHolder
import java.security.KeyPairGenerator
import java.security.KeyStore
import java.security.SecureRandom
import java.security.cert.X509Certificate
import java.security.spec.ECGenParameterSpec

val ATTESTATION_OID = ASN1ObjectIdentifier("1.3.6.1.4.1.11129.2.1.17")

object AttestUtils {
    data class AttestationData(
        val verifiedBootHash: ByteArray?,
        val attestVersion: Int?,
        val keymasterVersion: Int?,
        val osVersion: Int?,
    )

    val TEEStatus: Boolean by lazy { isTEEWorking() }
    val CachedAttestData: AttestationData? by lazy { getAttestData()}

    private val keygen_alias = "TrickyStoreOSS_attest"

    private fun isTEEWorking(): Boolean {
        return try {
            if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.R) {
                android.app.ActivityThread.initializeMainlineModules()
            }

            if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.S) {
                android.security.keystore2.AndroidKeyStoreProvider.install()
            } else {
                android.security.keystore.AndroidKeyStoreProvider.install()
            }

            val keyStore = KeyStore.getInstance("AndroidKeyStore")
            keyStore.load(null)

            val keyPairGenerator = KeyPairGenerator.getInstance(
                KeyProperties.KEY_ALGORITHM_EC, "AndroidKeyStore")

            val challenge = ByteArray(16).apply {
                SecureRandom().nextBytes(this)
            }

            val parameterSpec = KeyGenParameterSpec.Builder(
                keygen_alias,
                KeyProperties.PURPOSE_SIGN
            )
                .setAlgorithmParameterSpec(ECGenParameterSpec("secp256r1"))
                .setDigests(KeyProperties.DIGEST_SHA256)
                .setAttestationChallenge(challenge)
                .setIsStrongBoxBacked(false)
                .build()

            keyPairGenerator.initialize(parameterSpec)
            keyPairGenerator.generateKeyPair()

            Logger.d("TEE check: successful")

            // keyStore.deleteEntry(keygen_alias)
            true
        } catch (e: Exception) {
            Logger.w("TEE check failure: ${e.message}")
            false
        }
    }

    private fun getAttestCert(): X509Certificate? {
        return if (TEEStatus) {
            val keyStore = KeyStore.getInstance("AndroidKeyStore")
            keyStore.load(null)
            
            val certChain = keyStore.getCertificateChain(keygen_alias)
            if (certChain == null || certChain.isEmpty()) {
                null
            } else {
                keyStore.deleteEntry(keygen_alias)
                certChain[0] as X509Certificate
            }
        } else {
            null
        }
    }

    private fun getAttestData(): AttestationData? {
        val leaf: X509Certificate = getAttestCert() ?: return null

        return try {
            val leafHolder = X509CertificateHolder(leaf.encoded)
            val ext: Extension = leafHolder.getExtension(ATTESTATION_OID) ?: run {
                Logger.i("No attestation extension found on certificate")
                return null
            }

            val keyDescriptionSeq = ASN1Sequence.getInstance(ext.extnValue.octets)
            val encodables = keyDescriptionSeq.toArray()

            val attestVersion = ASN1Integer.getInstance(encodables[0]).value.intValueExact()
            val keymasterVersion = ASN1Integer.getInstance(encodables[2]).value.intValueExact()
            var attestVerifiedBootHash: ByteArray? = null
            var attestOSVersion: Int? = null

            val teeEnforced = ASN1Sequence.getInstance(encodables[7])

            teeEnforced.forEach { element ->
                val tagged = element as ASN1TaggedObject
                when (tagged.tagNo) {
                    704 -> { // Parse Root of Trust
                        val rootOfTrustSeq = ASN1Sequence.getInstance(tagged.baseObject.toASN1Primitive())
                        if (rootOfTrustSeq.size() >= 4) {
                            attestVerifiedBootHash = ASN1OctetString.getInstance(rootOfTrustSeq.getObjectAt(3)).octets
                        }
                    }
                    705 -> { // Parse OS Version
                        attestOSVersion = ASN1Integer.getInstance(tagged.baseObject.toASN1Primitive()).value.intValueExact()
                    }
                }
            }

            Logger.i("Extracted attestationVersion: $attestVersion")
            Logger.i("Extracted keymasterVersion: $keymasterVersion")
            Logger.i("Extracted verifiedBootHash: ${attestVerifiedBootHash?.toHex() ?: 0}")
            Logger.i("Extracted osVersion: $attestOSVersion")

            AttestationData(
                verifiedBootHash = attestVerifiedBootHash,
                attestVersion = attestVersion,
                keymasterVersion = keymasterVersion,
                osVersion = attestOSVersion
            )
        } catch (e: Exception) {
            Logger.e("Failed to parse attestation data", e)
            null
        }
    }
}
```

`app/src/main/java/io/github/beakthoven/TrickyStoreOSS/CertificateGen.kt`:

```kt
/*
 * Copyright 2025 Dakkshesh <beakthoven@gmail.com>
 * SPDX-License-Identifier: GPL-3.0-or-later
 */

package io.github.beakthoven.TrickyStoreOSS

import android.content.pm.PackageManager
import android.hardware.security.keymint.Algorithm
import android.hardware.security.keymint.EcCurve
import android.hardware.security.keymint.KeyParameter
import android.hardware.security.keymint.Tag
import android.os.Build
import android.security.keystore.KeyProperties
import android.system.keystore2.KeyDescriptor
import android.util.Pair
import io.github.beakthoven.TrickyStoreOSS.config.PkgConfig
import io.github.beakthoven.TrickyStoreOSS.interceptors.SecurityLevelInterceptor
import io.github.beakthoven.TrickyStoreOSS.logging.Logger
import org.bouncycastle.asn1.ASN1Boolean
import org.bouncycastle.asn1.ASN1Encodable
import org.bouncycastle.asn1.ASN1Enumerated
import org.bouncycastle.asn1.ASN1Integer
import org.bouncycastle.asn1.ASN1OctetString
import org.bouncycastle.asn1.DERNull
import org.bouncycastle.asn1.DEROctetString
import org.bouncycastle.asn1.DERSequence
import org.bouncycastle.asn1.DERSet
import org.bouncycastle.asn1.DERTaggedObject
import org.bouncycastle.asn1.x500.X500Name
import org.bouncycastle.asn1.x509.Extension
import org.bouncycastle.asn1.x509.KeyUsage
import org.bouncycastle.cert.X509CertificateHolder
import org.bouncycastle.cert.jcajce.JcaX509CertificateConverter
import org.bouncycastle.cert.jcajce.JcaX509v3CertificateBuilder
import org.bouncycastle.jce.provider.BouncyCastleProvider
import org.bouncycastle.openssl.PEMKeyPair
import org.bouncycastle.operator.jcajce.JcaContentSignerBuilder
import java.math.BigInteger
import java.nio.charset.StandardCharsets
import java.security.KeyPair
import java.security.KeyPairGenerator
import java.security.MessageDigest
import java.security.Security
import java.security.cert.Certificate
import java.security.cert.X509Certificate
import java.security.spec.ECGenParameterSpec
import java.security.spec.RSAKeyGenParameterSpec
import java.util.Date
import javax.security.auth.x500.X500Principal

object CertificateGen {
    data class KeyBox(
        val pemKeyPair: PEMKeyPair,
        val keyPair: KeyPair,
        val certificates: List<Certificate>
    )

    private data class Digest(val digest: ByteArray) {
        override fun equals(other: Any?): Boolean {
            if (this === other) return true
            if (javaClass != other?.javaClass) return false
            other as Digest
            return digest.contentEquals(other.digest)
        }
        
        override fun hashCode(): Int = digest.contentHashCode()
    }

    data class KeyGenParameters(
        var keySize: Int = 0,
        var algorithm: Int = 0,
        var certificateSerial: BigInteger? = null,
        var certificateNotBefore: Date? = null,
        var certificateNotAfter: Date? = null,
        var certificateSubject: X500Name? = null,
        var rsaPublicExponent: BigInteger? = null,
        var ecCurve: Int = 0,
        var ecCurveName: String? = null,
        var purpose: MutableList<Int> = mutableListOf(),
        var digest: MutableList<Int> = mutableListOf(),
        var attestationChallenge: ByteArray? = null,
        var brand: ByteArray? = null,
        var device: ByteArray? = null,
        var product: ByteArray? = null,
        var manufacturer: ByteArray? = null,
        var model: ByteArray? = null,
        var imei1: ByteArray? = null,
        var imei2: ByteArray? = null,
        var meid: ByteArray? = null,
        var serialno: ByteArray? = null
    ) {
        
        constructor(params: Array<KeyParameter>) : this() {
            params.forEach { param ->
                Logger.d("Processing key parameter: ${param.tag}")
                val value = param.value
                
                when (param.tag) {
                    Tag.KEY_SIZE -> keySize = value.integer
                    Tag.ALGORITHM -> algorithm = value.algorithm
                    Tag.CERTIFICATE_SERIAL -> certificateSerial = BigInteger(value.blob)
                    Tag.CERTIFICATE_NOT_BEFORE -> certificateNotBefore = Date(value.dateTime)
                    Tag.CERTIFICATE_NOT_AFTER -> certificateNotAfter = Date(value.dateTime)
                    Tag.CERTIFICATE_SUBJECT -> certificateSubject = X500Name(X500Principal(value.blob).name)
                    Tag.RSA_PUBLIC_EXPONENT -> rsaPublicExponent = BigInteger(value.blob)
                    Tag.EC_CURVE -> {
                        ecCurve = value.ecCurve
                        ecCurveName = getEcCurveName(ecCurve)
                    }
                    Tag.PURPOSE -> purpose.add(value.keyPurpose)
                    Tag.DIGEST -> digest.add(value.digest)
                    Tag.ATTESTATION_CHALLENGE -> attestationChallenge = value.blob
                    Tag.ATTESTATION_ID_BRAND -> brand = value.blob
                    Tag.ATTESTATION_ID_DEVICE -> device = value.blob
                    Tag.ATTESTATION_ID_PRODUCT -> product = value.blob
                    Tag.ATTESTATION_ID_MANUFACTURER -> manufacturer = value.blob
                    Tag.ATTESTATION_ID_MODEL -> model = value.blob
                    Tag.ATTESTATION_ID_IMEI -> imei1 = value.blob
                    Tag.ATTESTATION_ID_SECOND_IMEI -> imei2 = value.blob
                    Tag.ATTESTATION_ID_MEID -> meid = value.blob
                }
            }
            // Fallback: if no EC curve tag but we know key size
            if (ecCurveName == null && keySize != 0) {
                ecCurveName = ecCurveMapKeySize(keySize)
            }
        }
        
        private fun ecCurveMapKeySize(curveSize: Int): String = when (curveSize) {
            224 -> "secp224r1"
            256 -> "secp256r1"
            384 -> "secp384r1"
            521 -> "secp521r1"
            else -> "secp256r1" // default fallback
        }

        
        private fun getEcCurveName(curve: Int): String = when (curve) {
            EcCurve.CURVE_25519 -> "CURVE_25519"
            EcCurve.P_224 -> "secp224r1"
            EcCurve.P_256 -> "secp256r1"
            EcCurve.P_384 -> "secp384r1"
            EcCurve.P_521 -> "secp521r1"
            else -> throw IllegalArgumentException("Unknown EC curve: $curve")
        }
        
        override fun equals(other: Any?): Boolean {
            if (this === other) return true
            if (javaClass != other?.javaClass) return false
            
            other as KeyGenParameters
            
            return keySize == other.keySize &&
                    algorithm == other.algorithm &&
                    certificateSerial == other.certificateSerial &&
                    certificateNotBefore == other.certificateNotBefore &&
                    certificateNotAfter == other.certificateNotAfter &&
                    certificateSubject == other.certificateSubject &&
                    rsaPublicExponent == other.rsaPublicExponent &&
                    ecCurve == other.ecCurve &&
                    ecCurveName == other.ecCurveName &&
                    purpose == other.purpose &&
                    digest == other.digest &&
                    attestationChallenge.contentEquals(other.attestationChallenge) &&
                    brand.contentEquals(other.brand) &&
                    device.contentEquals(other.device) &&
                    product.contentEquals(other.product) &&
                    manufacturer.contentEquals(other.manufacturer) &&
                    model.contentEquals(other.model) &&
                    imei1.contentEquals(other.imei1) &&
                    imei2.contentEquals(other.imei2) &&
                    meid.contentEquals(other.meid) &&
                    serialno.contentEquals(other.serialno)
        }
    }
    
    fun generateChain(uid: Int, params: KeyGenParameters, keyPair: KeyPair, securityLevel: Int = 1): List<ByteArray>? = runCatching {
        val keybox = getKeyboxForAlgorithm(params.algorithm) ?: return null

        val issuer = X509CertificateHolder(keybox.certificates[0].encoded).subject
        val leaf = buildCertificate(keyPair, keybox, params, issuer, uid, securityLevel)
        
        val chain = buildList {
            add(leaf)
            addAll(keybox.certificates)
        }
        
        CertificateUtils.run { chain.toByteArrayList() }
    }.onFailure { 
        Logger.e("Failed to generate certificate chain", it) 
    }.getOrNull()

    fun generateKeyPair(params: KeyGenParameters): KeyPair? = runCatching {
        Security.removeProvider(BouncyCastleProvider.PROVIDER_NAME)
        Security.addProvider(BouncyCastleProvider())

        val (keyPairGenerator, spec) = when (params.algorithm) {
            Algorithm.EC -> {
                Logger.d("Generating EC keypair of size ${params.keySize}")
                val spec = ECGenParameterSpec(params.ecCurveName)
                val kpg = KeyPairGenerator.getInstance("EC", BouncyCastleProvider.PROVIDER_NAME)
                kpg to spec
            }
            Algorithm.RSA -> {
                Logger.d("Generating RSA keypair of size ${params.keySize}")
                val spec = RSAKeyGenParameterSpec(params.keySize, params.rsaPublicExponent)
                val kpg = KeyPairGenerator.getInstance("RSA", BouncyCastleProvider.PROVIDER_NAME)
                kpg to spec
            }
            else -> {
                throw IllegalArgumentException("Unsupported algorithm: ${params.algorithm}")
            }
        }

        keyPairGenerator.initialize(spec)
        keyPairGenerator.generateKeyPair()
    }.onFailure { 
        Logger.e("Failed to generate key pair", it) 
    }.getOrNull()
    
    fun generateKeyPair(
        uid: Int,
        descriptor: KeyDescriptor,
        attestKeyDescriptor: KeyDescriptor?,
        params: KeyGenParameters,
        securityLevel: Int = 1
    ): Pair<KeyPair, List<Certificate>>? = runCatching {
        Logger.i("Requested KeyPair with alias: ${descriptor.alias}")
        
        val hasAttestKey = attestKeyDescriptor != null
        if (hasAttestKey) {
            Logger.i("Requested KeyPair with attestKey: ${attestKeyDescriptor?.alias}")
        }
        
        val keyPair = generateKeyPair(params) ?: return null
        val keybox = getKeyboxForAlgorithm(params.algorithm) ?: return null
        
        val (signingKeyPair, issuer) = if (hasAttestKey) {
            getAttestationKeyInfo(uid, attestKeyDescriptor!!)?.let { 
                it.first to it.second 
            } ?: (keybox.keyPair to X509CertificateHolder(keybox.certificates[0].encoded).subject)
        } else {
            keybox.keyPair to X509CertificateHolder(keybox.certificates[0].encoded).subject
        }
        
        val leaf = buildCertificate(keyPair, keybox, params, issuer, uid, securityLevel, signingKeyPair)
        val chain = buildList {
            add(leaf)
            if (!hasAttestKey) {
                addAll(keybox.certificates)
            }
        }
        
        Logger.d("Successfully generated certificate for alias: ${descriptor.alias}")
        Pair(keyPair, chain)
    }.onFailure { 
        Logger.e("Failed to generate key pair with certificates", it) 
    }.getOrNull()
    
    private fun mapAlgorithmToName(algorithm: Int): String? = when (algorithm) {
        Algorithm.EC -> KeyProperties.KEY_ALGORITHM_EC
        Algorithm.RSA -> KeyProperties.KEY_ALGORITHM_RSA
        else -> {
            Logger.e("Unsupported algorithm: $algorithm")
            null
        }
    }

    private fun getKeyboxForAlgorithm(algorithm: Int): KeyBox? {
        val algorithmName = mapAlgorithmToName(algorithm) ?: return null
        return KeyBoxUtils.keyboxes[algorithmName]
    }

    private fun getAttestationKeyInfo(uid: Int, attestKeyDescriptor: KeyDescriptor): Pair<KeyPair, X500Name>? {
        Logger.d("Looking for attestation key: uid=$uid alias=${attestKeyDescriptor.alias}")
        
        val keyInfo = SecurityLevelInterceptor.getKeyPairs(uid, attestKeyDescriptor.alias)
        return if (keyInfo != null) {
            val issuer = X509CertificateHolder(keyInfo.second[0].encoded).subject
            Pair(keyInfo.first, issuer)
        } else {
            Logger.e("Attestation key info not found, falling back to default keybox")
            null
        }
    }

    private fun buildCertificate(
        keyPair: KeyPair,
        keybox: KeyBox,
        params: KeyGenParameters,
        issuer: X500Name,
        uid: Int,
        securityLevel: Int = 1,
        signingKeyPair: KeyPair = keybox.keyPair
    ): Certificate {
        val builder = JcaX509v3CertificateBuilder(
            issuer,
            params.certificateSerial ?: BigInteger.ONE,
            params.certificateNotBefore ?: Date(),
            params.certificateNotAfter ?: (keybox.certificates[0] as X509Certificate).notAfter,
            params.certificateSubject ?: X500Name("CN=Android KeyStore Key"),
            keyPair.public
        )
        
        builder.addExtension(Extension.keyUsage, true, KeyUsage(KeyUsage.keyCertSign))
        builder.addExtension(buildAttestExtension(params, uid, securityLevel))
        
        val signerAlgorithm = when (params.algorithm) {
            Algorithm.EC -> "SHA256withECDSA"
            Algorithm.RSA -> "SHA256withRSA"
            else -> throw IllegalArgumentException("Unsupported algorithm: ${params.algorithm}")
        }
        val contentSigner = JcaContentSignerBuilder(signerAlgorithm).build(signingKeyPair.private)
        
        return JcaX509CertificateConverter().getCertificate(builder.build(contentSigner))
    }

    private fun buildAttestExtension(params: KeyGenParameters, uid: Int, securityLevel: Int = 1): Extension {
        try {
            val key = AndroidUtils.bootKey
            val hash = AndroidUtils.getBootHashFromProp()

            Logger.d("Using boothash ${hash?.toHex() ?: 0}")
            
            val rootOfTrustEncodables = arrayOf(
                DEROctetString(key),
                ASN1Boolean.TRUE,
                ASN1Enumerated(0),
                DEROctetString(hash)
            )
            val rootOfTrustSeq = DERSequence(rootOfTrustEncodables)
            
            val purpose = DERSet(params.purpose.map { ASN1Integer(it.toLong()) }.toTypedArray())
            val algorithm = ASN1Integer(params.algorithm.toLong())
            val keySize = ASN1Integer(params.keySize.toLong())
            val digest = DERSet(params.digest.map { ASN1Integer(it.toLong()) }.toTypedArray())
            val ecCurve = ASN1Integer(params.ecCurve.toLong())
            val noAuthRequired = DERNull.INSTANCE
            
            val osVersion = ASN1Integer(AndroidUtils.osVersion.toLong())
            val osPatchLevel = ASN1Integer(AndroidUtils.patchLevel.toLong())
            val applicationID = createApplicationId(uid)
            val bootPatchLevel = ASN1Integer(AndroidUtils.bootPatchLevelLong.toLong())
            val vendorPatchLevel = ASN1Integer(AndroidUtils.vendorPatchLevelLong.toLong())
            val creationDateTime = ASN1Integer(System.currentTimeMillis())
            val origin = ASN1Integer(0L)
            val moduleHash = DEROctetString(AndroidUtils.moduleHash)
            
            val teeEnforcedObjects = mutableListOf(
                DERTaggedObject(true, 1, purpose),
                DERTaggedObject(true, 2, algorithm),
                DERTaggedObject(true, 3, keySize),
                DERTaggedObject(true, 5, digest),
                DERTaggedObject(true, 10, ecCurve),
                DERTaggedObject(true, 503, noAuthRequired),
                DERTaggedObject(true, 702, origin),
                DERTaggedObject(true, 704, rootOfTrustSeq),
                DERTaggedObject(true, 705, osVersion),
                DERTaggedObject(true, 706, osPatchLevel),
                DERTaggedObject(true, 718, vendorPatchLevel),
                DERTaggedObject(true, 719, bootPatchLevel),
            )

            if (AndroidUtils.attestVersion >= 400) {
                teeEnforcedObjects.add(DERTaggedObject(true, 724, moduleHash))
            }
            
            params.brand?.let { teeEnforcedObjects.add(DERTaggedObject(true, 710, DEROctetString(it))) }
            params.device?.let { teeEnforcedObjects.add(DERTaggedObject(true, 711, DEROctetString(it))) }
            params.product?.let { teeEnforcedObjects.add(DERTaggedObject(true, 712, DEROctetString(it))) }
            params.manufacturer?.let { teeEnforcedObjects.add(DERTaggedObject(true, 716, DEROctetString(it))) }
            params.model?.let { teeEnforcedObjects.add(DERTaggedObject(true, 717, DEROctetString(it))) }
            
            params.serialno?.let { teeEnforcedObjects.add(DERTaggedObject(true, 713, DEROctetString(it))) }
            params.imei1?.let { teeEnforcedObjects.add(DERTaggedObject(true, 714, DEROctetString(it))) }
            params.meid?.let { teeEnforcedObjects.add(DERTaggedObject(true, 715, DEROctetString(it))) }

            if (AndroidUtils.attestVersion >= 300) {
                params.imei2?.let { teeEnforcedObjects.add(DERTaggedObject(true, 723, DEROctetString(it))) }
            }

            teeEnforcedObjects.sortBy { it.tagNo }
            
            val softwareEnforcedObjects = arrayOf<ASN1Encodable>(
                DERTaggedObject(true, 709, applicationID),
                DERTaggedObject(true, 701, creationDateTime)
            )
            
            return Extension(
                ATTESTATION_OID,
                false,
                buildKeyDescriptionOctet(teeEnforcedObjects.toTypedArray(), softwareEnforcedObjects, params, securityLevel)
            )
        } catch (t: Throwable) {
            Logger.e("Failed to create attestation extension", t)
            throw t
        }
    }

    private fun buildKeyDescriptionOctet(
        teeEnforcedEncodables: Array<ASN1Encodable>,
        softwareEnforcedEncodables: Array<ASN1Encodable>,
        params: KeyGenParameters,
        securityLevel: Int = 1
    ): ASN1OctetString {
        val attestationVersion = ASN1Integer(AndroidUtils.attestVersion.toLong())
        val attestationSecurityLevel = ASN1Enumerated(securityLevel)
        val keymasterVersion = ASN1Integer(AndroidUtils.keymasterVersion.toLong())
        val keymasterSecurityLevel = ASN1Enumerated(securityLevel)
        val attestationChallenge = DEROctetString(params.attestationChallenge ?: ByteArray(0))
        val uniqueId = DEROctetString(ByteArray(0))
        val softwareEnforced = DERSequence(softwareEnforcedEncodables)
        val teeEnforced = DERSequence(teeEnforcedEncodables)
        
        val keyDescriptionEncodables = arrayOf(
            attestationVersion,
            attestationSecurityLevel,
            keymasterVersion,
            keymasterSecurityLevel,
            attestationChallenge,
            uniqueId,
            softwareEnforced,
            teeEnforced
        )
        
        val keyDescriptionSeq = DERSequence(keyDescriptionEncodables)
        return DEROctetString(keyDescriptionSeq.encoded)
    }

    @Throws(Throwable::class)
    private fun createApplicationId(uid: Int): DEROctetString {
        val pm = PkgConfig.getPm() ?: throw IllegalStateException("PackageManager not found!")
        val packages = pm.getPackagesForUid(uid) ?: throw IllegalStateException("No packages for UID $uid")

        val messageDigest = MessageDigest.getInstance("SHA-256")
        val signatures = mutableSetOf<Digest>()

        val packageInfos = packages.map { packageName ->
            val info = if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.TIRAMISU) {
                pm.getPackageInfo(packageName, PackageManager.GET_SIGNING_CERTIFICATES.toLong(), uid / 100000)
            } else {
                pm.getPackageInfo(packageName, PackageManager.GET_SIGNING_CERTIFICATES, uid / 100000)
            }

            info.signingInfo?.signingCertificateHistory?.forEach { signature ->
                signatures.add(Digest(messageDigest.digest(signature.toByteArray())))
            }

            info
        }

        val packageInfoArray = packageInfos.map { info ->
            DERSequence(
                arrayOf(
                    DEROctetString(info.packageName.toByteArray(StandardCharsets.UTF_8)),
                    ASN1Integer(info.longVersionCode)
                )
            )
        }.toTypedArray()

        val signaturesArray = signatures.map { DEROctetString(it.digest) }.toTypedArray()

        val applicationIdArray = arrayOf(
            DERSet(packageInfoArray),
            DERSet(signaturesArray)
        )

        return DEROctetString(DERSequence(applicationIdArray).encoded)
    }
}
```

`app/src/main/java/io/github/beakthoven/TrickyStoreOSS/CertificateHack.kt`:

```kt
/*
 * Copyright 2025 Dakkshesh <beakthoven@gmail.com>
 * SPDX-License-Identifier: GPL-3.0-or-later
 */

package io.github.beakthoven.TrickyStoreOSS

import io.github.beakthoven.TrickyStoreOSS.logging.Logger
import org.bouncycastle.asn1.ASN1Boolean
import org.bouncycastle.asn1.ASN1Encodable
import org.bouncycastle.asn1.ASN1EncodableVector
import org.bouncycastle.asn1.ASN1Enumerated
import org.bouncycastle.asn1.ASN1Integer
import org.bouncycastle.asn1.ASN1Sequence
import org.bouncycastle.asn1.ASN1TaggedObject
import org.bouncycastle.asn1.DEROctetString
import org.bouncycastle.asn1.DERSequence
import org.bouncycastle.asn1.DERTaggedObject
import org.bouncycastle.asn1.x509.Extension
import org.bouncycastle.cert.X509CertificateHolder
import org.bouncycastle.cert.X509v3CertificateBuilder
import org.bouncycastle.cert.jcajce.JcaX509CertificateConverter
import org.bouncycastle.operator.jcajce.JcaContentSignerBuilder
import java.io.ByteArrayInputStream
import java.security.cert.Certificate
import java.security.cert.CertificateFactory
import java.security.cert.X509Certificate
import java.util.LinkedList
import java.util.concurrent.ConcurrentHashMap

object CertificateHack {    
    private val certificateFactory: CertificateFactory by lazy {
        try {
            CertificateFactory.getInstance("X.509")
        } catch (t: Throwable) {
            Logger.e("Failed to initialize certificate factory", t)
            throw RuntimeException("Cannot initialize certificate factory", t)
        }
    }
    
    data class KeyIdentifier(
        val alias: String,
        val uid: Int
    )

    val leafAlgorithms = ConcurrentHashMap<KeyIdentifier, String>()
    
    fun clearLeafAlgorithms() {
        leafAlgorithms.clear()
    }
    
    fun hackCertificateChain(certificateChain: Array<Certificate>?): Array<Certificate> {
        if (certificateChain == null) {
            throw UnsupportedOperationException("Certificate chain is null!")
        }
        
        return try {
            val leaf = certificateFactory.generateCertificate(
                ByteArrayInputStream(certificateChain[0].encoded)
            ) as X509Certificate
            
            val extensionBytes = leaf.getExtensionValue(ATTESTATION_OID.id)
                ?: return certificateChain // No attestation extension, return original

            val leafHolder = X509CertificateHolder(leaf.encoded)
            val extension = leafHolder.getExtension(ATTESTATION_OID)
            val sequence = ASN1Sequence.getInstance(extension.extnValue.octets)
            val encodables = sequence.toArray()
            val teeEnforced = encodables[7] as ASN1Sequence
            
            val vector = ASN1EncodableVector()
            var rootOfTrust: ASN1Encodable? = null
            
            teeEnforced.forEach { element ->
                val taggedObject = element as ASN1TaggedObject
                if (taggedObject.tagNo == 704) {
                    rootOfTrust = taggedObject.baseObject.toASN1Primitive()
                } else {
                    vector.add(taggedObject)
                }
            }
            
            val keybox = KeyBoxUtils.keyboxes[leaf.publicKey.algorithm]
                ?: throw UnsupportedOperationException("Unsupported algorithm: ${leaf.publicKey.algorithm}")
            
            val certificates = LinkedList(keybox.certificates)
            val builder = X509v3CertificateBuilder(
                X509CertificateHolder(certificates[0].encoded).subject,
                leafHolder.serialNumber,
                leafHolder.notBefore,
                leafHolder.notAfter,
                leafHolder.subject,
                leafHolder.subjectPublicKeyInfo
            )
            
            val signer = JcaContentSignerBuilder(leaf.sigAlgName).build(keybox.keyPair.private)
            
            val hackedExtension = hackAttestExtension(rootOfTrust, vector, encodables)
            builder.addExtension(hackedExtension)
            
            leafHolder.extensions.extensionOIDs.forEach { oid ->
                if (oid.id != ATTESTATION_OID.id) {
                    builder.addExtension(leafHolder.getExtension(oid))
                }
            }
            
            certificates.addFirst(JcaX509CertificateConverter().getCertificate(builder.build(signer)))
            certificates.toTypedArray()
        } catch (t: Throwable) {
            Logger.e("Failed to hack certificate chain", t)
            certificateChain
        }
    }
    
    fun hackCACertificateChain(caList: ByteArray?, alias: String, uid: Int): ByteArray {
        if (caList == null) {
            throw UnsupportedOperationException("CA list is null!")
        }
        
        return try {
            val key = KeyIdentifier(alias, uid)
            val algorithm = leafAlgorithms.remove(key)
                ?: throw UnsupportedOperationException("No algorithm found for key $key")
            
            val keybox = KeyBoxUtils.keyboxes[algorithm]
                ?: throw UnsupportedOperationException("Unsupported algorithm: $algorithm")
            
            CertificateUtils.run { keybox.certificates.toByteArray() } ?: caList
        } catch (t: Throwable) {
            Logger.e("Failed to hack CA certificate chain", t)
            caList
        }
    }
    
    fun hackUserCertificate(certificate: ByteArray?, alias: String, uid: Int): ByteArray {
        if (certificate == null) {
            throw UnsupportedOperationException("Leaf certificate is null!")
        }
        
        return try {
            val leaf = certificateFactory.generateCertificate(
                ByteArrayInputStream(certificate)
            ) as X509Certificate
            
            val extensionBytes = leaf.getExtensionValue(ATTESTATION_OID.id)
                ?: return certificate // No attestation extension, return original
            
            val keyIdentifier = KeyIdentifier(alias, uid)
            leafAlgorithms[keyIdentifier] = leaf.publicKey.algorithm
            
            val leafHolder = X509CertificateHolder(leaf.encoded)
            val extension = leafHolder.getExtension(ATTESTATION_OID)
            val sequence = ASN1Sequence.getInstance(extension.extnValue.octets)
            val encodables = sequence.toArray()
            val teeEnforced = encodables[7] as ASN1Sequence
            
            val vector = ASN1EncodableVector()
            var rootOfTrust: ASN1Encodable? = null
            
            teeEnforced.forEach { element ->
                val taggedObject = element as ASN1TaggedObject
                if (taggedObject.tagNo == 704) {
                    rootOfTrust = taggedObject.baseObject.toASN1Primitive()
                } else {
                    vector.add(taggedObject)
                }
            }
            
            val keybox = KeyBoxUtils.keyboxes[leaf.publicKey.algorithm]
                ?: throw UnsupportedOperationException("Unsupported algorithm: ${leaf.publicKey.algorithm}")
            
            val builder = X509v3CertificateBuilder(
                X509CertificateHolder(keybox.certificates[0].encoded).subject,
                leafHolder.serialNumber,
                leafHolder.notBefore,
                leafHolder.notAfter,
                leafHolder.subject,
                leafHolder.subjectPublicKeyInfo
            )
            
            val signer = JcaContentSignerBuilder(leaf.sigAlgName).build(keybox.keyPair.private)
            
            val hackedExtension = hackAttestExtension(rootOfTrust, vector, encodables)
            builder.addExtension(hackedExtension)
            
            leafHolder.extensions.extensionOIDs.forEach { oid ->
                if (oid.id != ATTESTATION_OID.id) {
                    builder.addExtension(leafHolder.getExtension(oid))
                }
            }

            JcaX509CertificateConverter().getCertificate(builder.build(signer)).encoded
        } catch (t: Throwable) {
            Logger.e("Failed to hack user certificate", t)
            certificate
        }
    }
    
    private fun hackAttestExtension(
        originalRootOfTrust: ASN1Encodable?,
        vector: ASN1EncodableVector,
        originalEncodables: Array<ASN1Encodable>
    ): Extension {
        val verifiedBootKey = AndroidUtils.bootKey
        var verifiedBootHash: ByteArray? = null
        
        try {
            if (originalRootOfTrust is ASN1Sequence) {
                verifiedBootHash = CertificateUtils.getByteArrayFromAsn1(originalRootOfTrust.getObjectAt(3))
            }
        } catch (t: Throwable) {
            Logger.e("Failed to get verified boot hash from original, using generated", t)
        }
        
        if (verifiedBootHash == null) {
            verifiedBootHash = AndroidUtils.getBootHashFromProp()
        }
        
        val rootOfTrustElements = arrayOf(
            DEROctetString(verifiedBootKey),
            ASN1Boolean.TRUE,
            ASN1Enumerated(0),
            DEROctetString(verifiedBootHash)
        )
        val hackedRootOfTrust = DERSequence(rootOfTrustElements)
        
        vector.add(DERTaggedObject(true, 718, ASN1Integer(AndroidUtils.vendorPatchLevelLong.toLong())))
        vector.add(DERTaggedObject(true, 719, ASN1Integer(AndroidUtils.bootPatchLevelLong.toLong())))
        vector.add(DERTaggedObject(true, 706, ASN1Integer(AndroidUtils.patchLevel.toLong())))
        vector.add(DERTaggedObject(true, 705, ASN1Integer(AndroidUtils.osVersion.toLong())))
        vector.add(DERTaggedObject(704, hackedRootOfTrust))
        
        val hackEnforced = DERSequence(vector)
        originalEncodables[7] = hackEnforced
        val hackedSequence = DERSequence(originalEncodables)
        val hackedSequenceOctets = DEROctetString(hackedSequence)
        
        return Extension(ATTESTATION_OID, false, hackedSequenceOctets)
    }

}
```

`app/src/main/java/io/github/beakthoven/TrickyStoreOSS/CertificateUtils.kt`:

```kt
/*
 * Copyright 2025 Dakkshesh <beakthoven@gmail.com>
 * SPDX-License-Identifier: GPL-3.0-or-later
 */

package io.github.beakthoven.TrickyStoreOSS

import android.system.keystore2.KeyEntryResponse
import android.system.keystore2.KeyMetadata
import android.util.Log
import io.github.beakthoven.TrickyStoreOSS.CertificateUtils.putCertificateChain
import org.bouncycastle.asn1.ASN1Encodable
import org.bouncycastle.asn1.DEROctetString
import org.bouncycastle.openssl.PEMKeyPair
import org.bouncycastle.openssl.PEMParser
import org.bouncycastle.openssl.jcajce.JcaPEMKeyConverter
import org.bouncycastle.util.io.pem.PemReader
import java.io.ByteArrayInputStream
import java.io.ByteArrayOutputStream
import java.io.StringReader
import java.security.KeyPair
import java.security.cert.Certificate
import java.security.cert.CertificateException
import java.security.cert.CertificateFactory
import java.security.cert.CertificateParsingException
import java.security.cert.X509Certificate

object CertificateUtils {
    private const val TAG = "TrickyStoreOSS"
    
    sealed class CertificateResult<out T> {
        data class Success<T>(val data: T) : CertificateResult<T>()
        data class Error(val message: String, val cause: Throwable? = null) : CertificateResult<Nothing>()
        
        inline fun <R> map(transform: (T) -> R): CertificateResult<R> = when (this) {
            is Success -> Success(transform(data))
            is Error -> this
        }
        
        fun getOrNull(): T? = when (this) {
            is Success -> data
            is Error -> null
        }
    }
    
    sealed class ParseResult<out T> {
        data class Success<T>(val data: T) : ParseResult<T>()
        data class Error(val message: String, val cause: Throwable? = null) : ParseResult<Nothing>()
    }
    
    fun ByteArray?.toCertificate(): X509Certificate? {
        return this?.let { bytes ->
            try {
                val certFactory = CertificateFactory.getInstance("X.509")
                certFactory.generateCertificate(ByteArrayInputStream(bytes)) as? X509Certificate
            } catch (e: CertificateException) {
                Log.w(TAG, "Couldn't parse certificate in keystore", e)
                null
            }
        }
    }
    
    fun ByteArray.toCertificateResult(): CertificateResult<X509Certificate> {
        return try {
            val certFactory = CertificateFactory.getInstance("X.509")
            val certificate = certFactory.generateCertificate(ByteArrayInputStream(this)) as X509Certificate
            CertificateResult.Success(certificate)
        } catch (e: CertificateException) {
            CertificateResult.Error("Failed to parse certificate", e)
        }
    }
    
    @Suppress("UNCHECKED_CAST")
    fun ByteArray?.toCertificates(): Collection<X509Certificate> {
        return this?.let { bytes ->
            try {
                val certFactory = CertificateFactory.getInstance("X.509")
                certFactory.generateCertificates(ByteArrayInputStream(bytes)) as Collection<X509Certificate>
            } catch (e: CertificateException) {
                Log.w(TAG, "Couldn't parse certificates in keystore", e)
                emptyList()
            }
        } ?: emptyList()
    }
    
    fun Collection<Certificate>.toByteArray(): ByteArray? = runCatching {
        ByteArrayOutputStream().use { outputStream ->
            forEach { cert -> outputStream.write(cert.encoded) }
            outputStream.toByteArray()
        }
    }.onFailure { 
        Log.w(TAG, "Failed to convert certificates to byte array", it) 
    }.getOrNull()
    
    fun Collection<Certificate>.toByteArrayList(): List<ByteArray>? = runCatching {
        map { it.encoded }
    }.onFailure { 
        Log.w(TAG, "Failed to convert certificates to byte array list", it) 
    }.getOrNull()
    
    fun KeyEntryResponse?.getCertificateChain(): Array<Certificate>? {
        val metadata = this?.metadata ?: return null
        val leafCert = metadata.certificate?.toCertificate() ?: return null
        
        return when (val chainBytes = metadata.certificateChain) {
            null -> arrayOf(leafCert)
            else -> {
                val additionalCerts = chainBytes.toCertificates()
                buildList {
                    add(leafCert)
                    addAll(additionalCerts)
                }.toTypedArray()
            }
        }
    }
    
    fun KeyEntryResponse.putCertificateChain(chain: Array<Certificate>): Result<Unit> {
        return runCatching {
            metadata.putCertificateChain(chain)
        }
    }
    
    fun KeyMetadata.putCertificateChain(chain: Array<Certificate>): Result<Unit> {
        return runCatching {
            if (chain.isEmpty()) return@runCatching
            
            certificate = chain[0].encoded
            
            if (chain.size > 1) {
                ByteArrayOutputStream().use { output ->
                    for (i in 1 until chain.size) {
                        output.write(chain[i].encoded)
                    }
                    certificateChain = output.toByteArray()
                }
            } else {
                certificateChain = null
            }
        }
    }
    
    // Certificate parsing utilities
    fun parseKeyPair(keyContent: String): ParseResult<PEMKeyPair> {
        return try {
            PEMParser(StringReader(keyContent.trimLine())).use { parser ->
                val pemObject = parser.readObject()
                if (pemObject is PEMKeyPair) {
                    ParseResult.Success(pemObject)
                } else {
                    ParseResult.Error("Invalid PEM key pair format")
                }
            }
        } catch (t: Throwable) {
            ParseResult.Error("Failed to parse PEM key pair", t)
        }
    }
    
    fun parseCertificate(certContent: String): ParseResult<Certificate> {
        return try {
            PemReader(StringReader(certContent.trimLine())).use { reader ->
                val pemObject = reader.readPemObject()
                val certificate = CertificateFactory.getInstance("X.509").generateCertificate(
                    ByteArrayInputStream(pemObject.content)
                )
                ParseResult.Success(certificate)
            }
        } catch (t: Throwable) {
            ParseResult.Error("Failed to parse certificate", t)
        }
    }
    
    fun convertPemToKeyPair(pemKeyPair: PEMKeyPair): KeyPair {
        return JcaPEMKeyConverter().getKeyPair(pemKeyPair)
    }
    
    @Throws(CertificateParsingException::class)
    fun getByteArrayFromAsn1(asn1Encodable: ASN1Encodable): ByteArray {
        return when (asn1Encodable) {
            is DEROctetString -> asn1Encodable.octets
            else -> throw CertificateParsingException("Expected DEROctetString, got ${asn1Encodable::class.simpleName}")
        }
    }
}

fun ByteArray?.toX509Certificate(): X509Certificate? = CertificateUtils.run { this@toX509Certificate.toCertificate() }

fun ByteArray?.toX509Certificates(): Collection<X509Certificate> = CertificateUtils.run { this@toX509Certificates.toCertificates() }

fun Collection<Certificate>.encodedBytes(): ByteArray? = CertificateUtils.run { this@encodedBytes.toByteArray() }

fun Collection<Certificate>.encodedBytesList(): List<ByteArray>? = CertificateUtils.run { this@encodedBytesList.toByteArrayList() }

fun KeyEntryResponse.putCertificateChain(chain: Array<Certificate>): Result<Unit> {
    return runCatching {
        metadata.putCertificateChain(chain).getOrThrow()
    }
}

fun KeyMetadata.putCertificateChain(chain: Array<Certificate>): Result<Unit> {
    return runCatching {
        if (chain.isEmpty()) return@runCatching
        
        certificate = chain[0].encoded
        
        if (chain.size > 1) {
            ByteArrayOutputStream().use { output ->
                for (i in 1 until chain.size) {
                    output.write(chain[i].encoded)
                }
                certificateChain = output.toByteArray()
            }
        } else {
            certificateChain = null
        }
    }
}
```

`app/src/main/java/io/github/beakthoven/TrickyStoreOSS/Main.kt`:

```kt
/*
 * Copyright 2025 Dakkshesh <beakthoven@gmail.com>
 * SPDX-License-Identifier: GPL-3.0-or-later
 */

package io.github.beakthoven.TrickyStoreOSS

import android.os.Build
import io.github.beakthoven.TrickyStoreOSS.config.PkgConfig
import io.github.beakthoven.TrickyStoreOSS.interceptors.Keystore2Interceptor
import io.github.beakthoven.TrickyStoreOSS.interceptors.KeystoreInterceptor
import io.github.beakthoven.TrickyStoreOSS.logging.Logger

private const val RETRY_DELAY_MS = 1000L
private const val SERVICE_SLEEP_MS = 1000000L

fun main(args: Array<String>) {
    Logger.i("Welcome to TrickyStoreOSS!")
    
    try {
        AndroidUtils.setupBootHash()
        initializeInterceptors()
        maintainService()
    } catch (e: Exception) {
        Logger.e("Fatal error in main", e)
        throw e
    }
}

private fun initializeInterceptors() {
    val interceptor = selectKeystoreInterceptor()
    
    while (!interceptor.tryRunKeystoreInterceptor()) {
        Logger.d("Retrying interceptor initialization...")
        Thread.sleep(RETRY_DELAY_MS)
    }
    
    PkgConfig.initialize()
    Logger.i("Interceptors initialized successfully")
}

private fun selectKeystoreInterceptor() = when {
    Build.VERSION.SDK_INT in Build.VERSION_CODES.Q..Build.VERSION_CODES.R -> {
        Logger.i("Using KeystoreInterceptor for Android Q/R (SDK ${Build.VERSION.SDK_INT})")
        KeystoreInterceptor
    }
    else -> {
        Logger.i("Using Keystore2Interceptor for Android S+ (SDK ${Build.VERSION.SDK_INT})")
        Keystore2Interceptor
    }
}

private fun maintainService() {
    Logger.i("Service started, entering maintenance mode")
    while (true) {
        Thread.sleep(SERVICE_SLEEP_MS)
    }
}

```

`app/src/main/java/io/github/beakthoven/TrickyStoreOSS/XmlParser.kt`:

```kt
/*
 * Copyright 2025 Dakkshesh <beakthoven@gmail.com>
 * SPDX-License-Identifier: GPL-3.0-or-later
 */

package io.github.beakthoven.TrickyStoreOSS

import android.security.keystore.KeyProperties
import io.github.beakthoven.TrickyStoreOSS.CertificateGen.KeyBox
import io.github.beakthoven.TrickyStoreOSS.CertificateHack.clearLeafAlgorithms
import io.github.beakthoven.TrickyStoreOSS.logging.Logger
import org.xmlpull.v1.XmlPullParser
import org.xmlpull.v1.XmlPullParserException
import org.xmlpull.v1.XmlPullParserFactory
import java.io.IOException
import java.io.StringReader
import java.security.cert.Certificate
import java.util.concurrent.ConcurrentHashMap

class XmlParser(private val xmlContent: String) {
    
    sealed class ParseResult {
        data class Success(val attributes: Map<String, String>) : ParseResult()
        data class Error(val message: String, val cause: Throwable? = null) : ParseResult()
    }
    
    fun obtainPath(path: String): ParseResult {
        return try {
            val factory = XmlPullParserFactory.newInstance()
            val parser = factory.newPullParser()
            parser.setFeature(XmlPullParser.FEATURE_PROCESS_NAMESPACES, false)
            parser.setInput(StringReader(xmlContent))
            
            val tags = path.split(".").toTypedArray()
            val result = readData(parser, tags, 0, mutableMapOf())
            ParseResult.Success(result)
        } catch (e: XmlPullParserException) {
            ParseResult.Error("XML parsing error: ${e.message}", e)
        } catch (e: IOException) {
            ParseResult.Error("IO error while parsing XML: ${e.message}", e)
        } catch (e: Exception) {
            ParseResult.Error("Unexpected error: ${e.message}", e)
        }
    }
    
    @Throws(Exception::class)
    fun obtainPathLegacy(path: String): Map<String, String> {
        when (val result = obtainPath(path)) {
            is ParseResult.Success -> return result.attributes
            is ParseResult.Error -> throw result.cause ?: Exception(result.message)
        }
    }
    
    @Throws(IOException::class, XmlPullParserException::class)
    private fun readData(
        parser: XmlPullParser,
        tags: Array<String>,
        index: Int,
        tagCounts: MutableMap<String, Int>
    ): Map<String, String> {
        while (parser.next() != XmlPullParser.END_DOCUMENT) {
            if (parser.eventType != XmlPullParser.START_TAG) {
                continue
            }
            
            val currentTag = parser.name ?: continue
            val targetTag = tags[index]
            val tagParts = targetTag.split("[")
            val baseTagName = tagParts[0]
            
            if (currentTag == baseTagName) {
                return if (tagParts.size > 1) {
                    handleIndexedTag(parser, tags, index, tagCounts, currentTag, tagParts[1])
                } else {
                    handleRegularTag(parser, tags, index)
                }
            } else {
                skipCurrentElement(parser)
            }
        }
        
        throw XmlPullParserException("Path not found: ${tags.joinToString(".")}")
    }
    
    @Throws(IOException::class, XmlPullParserException::class)
    private fun handleIndexedTag(
        parser: XmlPullParser,
        tags: Array<String>,
        index: Int,
        tagCounts: MutableMap<String, Int>,
        currentTag: String,
        indexPart: String
    ): Map<String, String> {
        val targetIndex = indexPart.replace("]", "").toIntOrNull()
            ?: throw XmlPullParserException("Invalid index in tag: $indexPart")
        
        val currentCount = tagCounts.getOrDefault(currentTag, 0)
        
        return if (currentCount < targetIndex) {
            tagCounts[currentTag] = currentCount + 1
            readData(parser, tags, index, tagCounts)
        } else {
            if (index == tags.size - 1) {
                readAttributes(parser)
            } else {
                readData(parser, tags, index + 1, tagCounts)
            }
        }
    }
    
    @Throws(IOException::class, XmlPullParserException::class)
    private fun handleRegularTag(
        parser: XmlPullParser,
        tags: Array<String>,
        index: Int
    ): Map<String, String> {
        return if (index == tags.size - 1) {
            readAttributes(parser)
        } else {
            readData(parser, tags, index + 1, mutableMapOf())
        }
    }
    
    @Throws(IOException::class, XmlPullParserException::class)
    private fun readAttributes(parser: XmlPullParser): Map<String, String> {
        val attributes = mutableMapOf<String, String>()
        
        for (i in 0 until parser.attributeCount) {
            val name = parser.getAttributeName(i)
            val value = parser.getAttributeValue(i)
            if (name != null && value != null) {
                attributes[name] = value
            }
        }
        
        if (parser.next() == XmlPullParser.TEXT) {
            parser.text?.let { text ->
                attributes["text"] = text
            }
        }
        
        return attributes
    }
    
    @Throws(XmlPullParserException::class, IOException::class)
    private fun skipCurrentElement(parser: XmlPullParser) {
        if (parser.eventType != XmlPullParser.START_TAG) {
            throw IllegalStateException("Parser must be positioned at START_TAG")
        }
        
        var depth = 1
        while (depth != 0) {
            when (parser.next()) {
                XmlPullParser.END_TAG -> depth--
                XmlPullParser.START_TAG -> depth++
            }
        }
    }
}

object KeyBoxUtils {
    val keyboxes = ConcurrentHashMap<String, KeyBox>()

    fun hasKeyboxes(): Boolean = keyboxes.isNotEmpty()

    fun readFromXml(xmlData: String?) {
        keyboxes.clear()
        clearLeafAlgorithms()
        
        if (xmlData == null) {
            Logger.i("Clearing all keyboxes")
            return
        }
        
        try {
            val xmlParser = XmlParser(xmlData.sanitizeXml())
            
            val numberOfKeyboxesResult = xmlParser.obtainPath("AndroidAttestation.NumberOfKeyboxes")
            val numberOfKeyboxes = when (numberOfKeyboxesResult) {
                is XmlParser.ParseResult.Success -> numberOfKeyboxesResult.attributes["text"]?.toIntOrNull()
                    ?: throw IllegalArgumentException("Invalid number of keyboxes")
                is XmlParser.ParseResult.Error -> throw Exception(numberOfKeyboxesResult.message, numberOfKeyboxesResult.cause)
            }
            
            repeat(numberOfKeyboxes) { i ->
                processKeybox(xmlParser, i)
            }
            
            Logger.i("Successfully updated $numberOfKeyboxes keyboxes")
        } catch (t: Throwable) {
            Logger.e("Error loading XML file (keyboxes cleared)", t)
        }
    }

    private fun String.sanitizeXml(): String {
        var content = this

        val boms = listOf(
            "\uFEFF",
            "\uFFFE",
            "\u0000\uFEFF"
        )
        content = content.trimStart()
        for (bom in boms) {
            content = content.removePrefix(bom)
        }
        content = content.trimStart()

        return content.trimEnd()
    }

    private fun processKeybox(xmlParser: XmlParser, index: Int) {
        try {
            val algorithmResult = xmlParser.obtainPath("AndroidAttestation.Keybox.Key[$index]")
            val keyboxAlgorithm = when (algorithmResult) {
                is XmlParser.ParseResult.Success -> algorithmResult.attributes["algorithm"]
                    ?: throw IllegalArgumentException("Missing algorithm attribute")
                is XmlParser.ParseResult.Error -> throw Exception(algorithmResult.message, algorithmResult.cause)
            }
            
            val privateKeyResult = xmlParser.obtainPath("AndroidAttestation.Keybox.Key[$index].PrivateKey")
            val privateKeyContent = when (privateKeyResult) {
                is XmlParser.ParseResult.Success -> privateKeyResult.attributes["text"]
                    ?: throw IllegalArgumentException("Missing private key text")
                is XmlParser.ParseResult.Error -> throw Exception(privateKeyResult.message, privateKeyResult.cause)
            }
            
            val numberOfCertificatesResult = xmlParser.obtainPath(
                "AndroidAttestation.Keybox.Key[$index].CertificateChain.NumberOfCertificates"
            )
            val numberOfCertificates = when (numberOfCertificatesResult) {
                is XmlParser.ParseResult.Success -> numberOfCertificatesResult.attributes["text"]?.toIntOrNull()
                    ?: throw IllegalArgumentException("Invalid number of certificates")
                is XmlParser.ParseResult.Error -> throw Exception(numberOfCertificatesResult.message, numberOfCertificatesResult.cause)
            }
            
            val certificateChain = mutableListOf<Certificate>()
            repeat(numberOfCertificates) { j ->
                val certResult = xmlParser.obtainPath(
                    "AndroidAttestation.Keybox.Key[$index].CertificateChain.Certificate[$j]"
                )
                val certContent = when (certResult) {
                    is XmlParser.ParseResult.Success -> certResult.attributes["text"]
                        ?: throw IllegalArgumentException("Missing certificate text")
                    is XmlParser.ParseResult.Error -> throw Exception(certResult.message, certResult.cause)
                }
                
                when (val certParseResult = CertificateUtils.parseCertificate(certContent)) {
                    is CertificateUtils.ParseResult.Success -> certificateChain.add(certParseResult.data)
                    is CertificateUtils.ParseResult.Error -> throw Exception(certParseResult.message, certParseResult.cause)
                }
            }
            
            val pemKeyPair = when (val keyParseResult = CertificateUtils.parseKeyPair(privateKeyContent)) {
                is CertificateUtils.ParseResult.Success -> keyParseResult.data
                is CertificateUtils.ParseResult.Error -> throw Exception(keyParseResult.message, keyParseResult.cause)
            }
            
            val keyPair = CertificateUtils.convertPemToKeyPair(pemKeyPair)
            
            val algorithmName = when (keyboxAlgorithm.lowercase()) {
                "ecdsa" -> KeyProperties.KEY_ALGORITHM_EC
                "rsa" -> KeyProperties.KEY_ALGORITHM_RSA
                else -> keyboxAlgorithm
            }
            
            keyboxes[algorithmName] = KeyBox(pemKeyPair, keyPair, certificateChain)
            
        } catch (t: Throwable) {
            Logger.e("Error processing keybox $index", t)
            throw t
        }
    }
}
```

`app/src/main/java/io/github/beakthoven/TrickyStoreOSS/config/Config.kt`:

```kt
/*
 * Copyright 2025 Dakkshesh <beakthoven@gmail.com>
 * SPDX-License-Identifier: GPL-3.0-or-later
 */

package io.github.beakthoven.TrickyStoreOSS.config

import android.content.pm.IPackageManager
import android.os.Build
import android.os.FileObserver
import android.os.IBinder
import android.os.IInterface
import android.os.ServiceManager
import io.github.beakthoven.TrickyStoreOSS.AttestUtils.TEEStatus
import io.github.beakthoven.TrickyStoreOSS.KeyBoxUtils
import io.github.beakthoven.TrickyStoreOSS.logging.Logger
import java.io.File

object PkgConfig {
    private val hackPackages = mutableSetOf<String>()
    private val generatePackages = mutableSetOf<String>()
    private val packageModes = mutableMapOf<String, Mode>()

    enum class Mode {
        AUTO, LEAF_HACK, GENERATE
    }

    private fun updateTargetPackages(f: File?) = runCatching {
        hackPackages.clear()
        generatePackages.clear()
        packageModes.clear()
        f?.readLines()?.forEach {
            if (it.isNotBlank() && !it.startsWith("#")) {
                val n = it.trim()
                when {
                    n.endsWith("!") -> {
                        val pkg = n.removeSuffix("!").trim()
                        generatePackages.add(pkg)
                        packageModes[pkg] = Mode.GENERATE
                    }
                    n.endsWith("?") -> {
                        val pkg = n.removeSuffix("?").trim()
                        hackPackages.add(pkg)
                        packageModes[pkg] = Mode.LEAF_HACK
                    }
                    else -> {
                        // Auto mode
                        packageModes[n] = Mode.AUTO
                    }
                }
            }
        }
        Logger.i("update hack packages: $hackPackages, generate packages=$generatePackages, packageModes=$packageModes")
    }.onFailure {
        Logger.e("failed to update target files", it)
    }

    private fun updateKeyBox(f: File?) = runCatching {
        KeyBoxUtils.readFromXml(f?.readText())
    }.onFailure {
        Logger.e("failed to update keybox", it)
    }

    private const val CONFIG_PATH = "/data/adb/tricky_store"
    private const val TARGET_FILE = "target.txt"
    private const val KEYBOX_FILE = "keybox.xml"
    private const val TEE_STATUS_FILE = "tee_status"
    private const val PATCHLEVEL_FILE = "security_patch.txt"
    private val root = File(CONFIG_PATH)

    @Volatile
    private var teeBroken: Boolean? = null

    private fun storeTEEStatus(root: File) {
        val statusFile = File(root, TEE_STATUS_FILE)
        teeBroken = !TEEStatus
        try {
            statusFile.writeText("teeBroken=${teeBroken}")
            Logger.i("TEE status written to $statusFile: teeBroken=$teeBroken") 
        } catch (e: Exception) {
            Logger.e("Failed to write TEE status: ${e.message}")
        }
    }

    private fun loadTEEStatus(root: File) {
        val statusFile = File(root, TEE_STATUS_FILE)
        if (statusFile.exists()) {
            val line = statusFile.readText().trim()
            teeBroken = line == "teeBroken=true"
        } else {
            teeBroken = null
        }
    }

    object ConfigObserver : FileObserver(root, CLOSE_WRITE or DELETE or MOVED_FROM or MOVED_TO) {
        override fun onEvent(event: Int, path: String?) {
            path ?: return
            val f = when (event) {
                CLOSE_WRITE, MOVED_TO -> File(root, path)
                DELETE, MOVED_FROM -> null
                else -> return
            }
            when (path) {
                TARGET_FILE -> updateTargetPackages(f)
                KEYBOX_FILE -> updateKeyBox(f)
                PATCHLEVEL_FILE -> updatePatchLevel(f)
            }
        }
    }

    fun initialize() {
        root.mkdirs()
        val scope = File(root, TARGET_FILE)
        if (scope.exists()) {
            updateTargetPackages(scope)
        } else {
            Logger.e("target.txt file not found, please put it to $scope !")
        }
        val keybox = File(root, KEYBOX_FILE)
        if (!keybox.exists()) {
            Logger.e("keybox file not found, please put it to $keybox !")
        } else {
            updateKeyBox(keybox)
        }
        storeTEEStatus(root)
        val patchFile = File(root, PATCHLEVEL_FILE)
        updatePatchLevel(if (patchFile.exists()) patchFile else null)
        ConfigObserver.startWatching()
    }

    private var iPm: IPackageManager? = null
    private val packageManagerDeathRecipient = object : IBinder.DeathRecipient {
        override fun binderDied() {
            (iPm as? IInterface)?.asBinder()?.unlinkToDeath(this, 0)
            iPm = null
        }
    }

    fun getPm(): IPackageManager? {
        if (iPm == null) {
            val binder = waitAndGetSystemService("package") ?: return null
            binder.linkToDeath(packageManagerDeathRecipient, 0)
            iPm = IPackageManager.Stub.asInterface(binder)
        }
        return iPm
    }

    fun needHack(callingUid: Int): Boolean = kotlin.runCatching {
        val ps = getPm()?.getPackagesForUid(callingUid) ?: return false
        if (teeBroken == null) loadTEEStatus(root)
        for (pkg in ps) {
            when (packageModes[pkg]) {
                Mode.LEAF_HACK -> return true
                Mode.AUTO -> {
                    if (teeBroken == false) return true
                }
                else -> {}
            }
        }
        return false
    }.onFailure { Logger.e("failed to get packages", it) }.getOrNull() ?: false

    fun needGenerate(callingUid: Int): Boolean = kotlin.runCatching {
        val ps = getPm()?.getPackagesForUid(callingUid) ?: return false
        if (teeBroken == null) loadTEEStatus(root)
        for (pkg in ps) {
            when (packageModes[pkg]) {
                Mode.GENERATE -> return true
                Mode.AUTO -> {
                    if (teeBroken == true) return true
                }
                else -> {}
            }
        }
        return false
    }.onFailure { Logger.e("failed to get packages", it) }.getOrNull() ?: false

    @Volatile
    var _customPatchLevel: CustomPatchLevel? = null

    fun updatePatchLevel(f: File?) = runCatching {
        if (f == null || !f.exists()) {
            _customPatchLevel = null
            return@runCatching
        }
        val lines = f.readLines().map { it.trim() }.filter { it.isNotEmpty() && !it.startsWith("#") }
        if (lines.isEmpty()) {
            _customPatchLevel = null
            return@runCatching
        }
        if (lines.size == 1 && !lines[0].contains("=")) {
            _customPatchLevel = CustomPatchLevel(all = lines[0])
            return@runCatching
        }
        val map = mutableMapOf<String, String>()
        for (line in lines) {
            val idx = line.indexOf('=')
            if (idx > 0) {
                val key = line.substring(0, idx).trim().lowercase()
                val value = line.substring(idx + 1).trim()
                map[key] = value
            }
        }
        val all = map["all"]
        _customPatchLevel = CustomPatchLevel(
            system = map["system"] ?: all,
            vendor = map["vendor"] ?: all,
            boot = map["boot"] ?: all,
            all = all
        )
    }.onFailure {
        Logger.e("failed to update patch level", it)
    }

    private fun waitAndGetSystemService(name: String): IBinder? {
        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.R) {
            return ServiceManager.waitForService(name)
        }

        var tryCount = 0
        while (tryCount++ < 70) {
            val service = ServiceManager.getService(name)
            if (service != null) {
                Logger.d("Got $name service after $tryCount tries")
                return service
            }
            Thread.sleep(500)
        }

        Logger.e("Failed to get $name service")
        return null
    }
}

data class CustomPatchLevel(
    val system: String? = null,
    val vendor: String? = null,
    val boot: String? = null,
    val all: String? = null
)

```

`app/src/main/java/io/github/beakthoven/TrickyStoreOSS/interceptors/BinderInterceptor.kt`:

```kt
/*
 * Copyright 2025 Dakkshesh <beakthoven@gmail.com>
 * SPDX-License-Identifier: GPL-3.0-or-later
 */

package io.github.beakthoven.TrickyStoreOSS.interceptors

import android.os.Binder
import android.os.IBinder
import android.os.Parcel
import io.github.beakthoven.TrickyStoreOSS.logging.Logger

open class BinderInterceptor : Binder() {
    
    sealed class Result
    
    data object Skip : Result()
    
    data object Continue : Result()
    
    data class OverrideData(val data: Parcel) : Result()
    
    data class OverrideReply(val code: Int = 0, val reply: Parcel) : Result()

    companion object {
        private const val BACKDOOR_TRANSACTION_CODE = 0xdeadbeef.toInt()
        
        private const val REGISTER_INTERCEPTOR_CODE = 1
        
        private const val PRE_TRANSACT_CODE = 1
        private const val POST_TRANSACT_CODE = 2
        
        private const val RESULT_SKIP = 1
        private const val RESULT_CONTINUE = 2
        private const val RESULT_OVERRIDE_REPLY = 3
        private const val RESULT_OVERRIDE_DATA = 4
        
        fun getBinderBackdoor(binder: IBinder): IBinder? {
            val data = Parcel.obtain()
            val reply = Parcel.obtain()
            
            return try {
                val success = binder.transact(BACKDOOR_TRANSACTION_CODE, data, reply, 0)
                if (success) {
                    Logger.d("Backdoor access granted for binder: $binder")
                    reply.readStrongBinder()
                } else {
                    Logger.d("Backdoor access denied for binder: $binder")
                    null
                }
            } catch (e: Exception) {
                Logger.e("Failed to access binder backdoor", e)
                null
            } finally {
                data.recycle()
                reply.recycle()
            }
        }

        fun registerBinderInterceptor(
            backdoor: IBinder, 
            target: IBinder, 
            interceptor: BinderInterceptor
        ) {
            val data = Parcel.obtain()
            val reply = Parcel.obtain()
            
            try {
                data.writeStrongBinder(target)
                data.writeStrongBinder(interceptor)
                backdoor.transact(REGISTER_INTERCEPTOR_CODE, data, reply, 0)
                Logger.d("Registered interceptor for target: $target")
            } catch (e: Exception) {
                Logger.e("Failed to register binder interceptor", e)
            } finally {
                data.recycle()
                reply.recycle()
            }
        }
    }

    open fun onPreTransact(
        target: IBinder, 
        code: Int, 
        flags: Int, 
        callingUid: Int, 
        callingPid: Int, 
        data: Parcel
    ): Result = Skip
    
    open fun onPostTransact(
        target: IBinder, 
        code: Int, 
        flags: Int, 
        callingUid: Int, 
        callingPid: Int, 
        data: Parcel, 
        reply: Parcel?, 
        resultCode: Int
    ): Result = Skip

    override fun onTransact(code: Int, data: Parcel, reply: Parcel?, flags: Int): Boolean {
        val result = when (code) {
            PRE_TRANSACT_CODE -> handlePreTransact(data)
            POST_TRANSACT_CODE -> handlePostTransact(data)
            else -> return super.onTransact(code, data, reply, flags)
        }
        
        writeResultToReply(result, reply!!)
        return true
    }
    
    private fun handlePreTransact(data: Parcel): Result {
        val target = data.readStrongBinder()
        val transactionCode = data.readInt()
        val transactionFlags = data.readInt()
        val callingUid = data.readInt()
        val callingPid = data.readInt()
        val dataSize = data.readLong()
        
        val transactionData = Parcel.obtain()
        return try {
            transactionData.appendFrom(data, data.dataPosition(), dataSize.toInt())
            transactionData.setDataPosition(0)
            onPreTransact(target, transactionCode, transactionFlags, callingUid, callingPid, transactionData)
        } finally {
            transactionData.recycle()
        }
    }
    
    private fun handlePostTransact(data: Parcel): Result {
        val target = data.readStrongBinder()
        val transactionCode = data.readInt()
        val transactionFlags = data.readInt()
        val callingUid = data.readInt()
        val callingPid = data.readInt()
        val resultCode = data.readInt()
        
        val transactionData = Parcel.obtain()
        val transactionReply = Parcel.obtain()
        
        return try {
            val dataSize = data.readLong().toInt()
            transactionData.appendFrom(data, data.dataPosition(), dataSize)
            transactionData.setDataPosition(0)
            data.setDataPosition(data.dataPosition() + dataSize)
            
            val replySize = data.readLong().toInt()
            val reply = if (replySize > 0) {
                transactionReply.appendFrom(data, data.dataPosition(), replySize)
                transactionReply.setDataPosition(0)
                transactionReply
            } else null
            
            onPostTransact(target, transactionCode, transactionFlags, callingUid, callingPid, transactionData, reply, resultCode)
        } finally {
            transactionData.recycle()
            transactionReply.recycle()
        }
    }
    
    private fun writeResultToReply(result: Result, reply: Parcel) {
        when (result) {
            Skip -> reply.writeInt(RESULT_SKIP)
            Continue -> reply.writeInt(RESULT_CONTINUE)
            is OverrideReply -> {
                reply.writeInt(RESULT_OVERRIDE_REPLY)
                reply.writeInt(result.code)
                reply.writeLong(result.reply.dataSize().toLong())
                reply.appendFrom(result.reply, 0, result.reply.dataSize())
                result.reply.recycle()
            }
            is OverrideData -> {
                reply.writeInt(RESULT_OVERRIDE_DATA)
                reply.writeLong(result.data.dataSize().toLong())
                reply.appendFrom(result.data, 0, result.data.dataSize())
                result.data.recycle()
            }
        }
    }
}
```

`app/src/main/java/io/github/beakthoven/TrickyStoreOSS/interceptors/InterceptorUtils.kt`:

```kt
/*
 * Copyright 2025 Dakkshesh <beakthoven@gmail.com>
 * SPDX-License-Identifier: GPL-3.0-or-later
 */

package io.github.beakthoven.TrickyStoreOSS.interceptors

import android.os.IBinder
import android.os.Parcel
import android.os.Parcelable
import android.os.ServiceManager
import android.security.KeyStore
import android.security.keystore.KeystoreResponse
import io.github.beakthoven.TrickyStoreOSS.logging.Logger
import kotlin.system.exitProcess

abstract class BaseKeystoreInterceptor : BinderInterceptor() {
    
    protected lateinit var keystore: IBinder
    protected var triedCount = 0
    protected var injected = false
    protected open val maxRetries: Int = 3
    
    protected abstract val serviceName: String
    protected abstract val injectionCommand: String
    protected abstract val processName: String
    
    fun tryRunKeystoreInterceptor(): Boolean {
        Logger.i("Trying to register ${this::class.simpleName} (attempt $triedCount)...")
        
        val service = getService() ?: return false
        val backdoor = getBinderBackdoor(service)
        
        return if (backdoor != null) {
            setupInterceptor(service, backdoor)
        } else {
            handleMissingBackdoor()
        }
    }
    
    protected open fun getService(): IBinder? = ServiceManager.getService(serviceName)
    
    protected open fun setupInterceptor(service: IBinder, backdoor: IBinder): Boolean {
        keystore = service
        Logger.i("Registering for $serviceName: $keystore")
        
        registerBinderInterceptor(backdoor, service, this)
        service.linkToDeath(createDeathRecipient(), 0)
        onInterceptorSetup(service, backdoor)
        
        return true
    }
    
    private fun handleMissingBackdoor(): Boolean {
        if (triedCount >= maxRetries) {
            Logger.e("Tried injection $maxRetries times but still no backdoor, exiting")
            exitProcess(1)
        }
        
        if (!injected) {
            performInjection()
            injected = true
        }
        
        triedCount++
        return false
    }
    
    protected open fun performInjection() {
        Logger.i("Attempting to inject into $processName...")
        
        val command = arrayOf("/system/bin/sh", "-c", injectionCommand)
        Logger.d("Injection command: ${command.joinToString(" ")}")
        
        val process = Runtime.getRuntime().exec(command)
        
        if (process.waitFor() != 0) {
            Logger.e("Injection failed! Daemon will exit")
            exitProcess(1)
        }
        
        Logger.i("Injection completed successfully")
    }
    
    protected open fun createDeathRecipient(): IBinder.DeathRecipient = object : IBinder.DeathRecipient {
        override fun binderDied() {
            Logger.d("$serviceName died, daemon restarting")
            exitProcess(0)
        }
    }
    
    protected open fun onInterceptorSetup(service: IBinder, backdoor: IBinder) {
        // Default implementation does nothing
    }
}

object InterceptorUtils {
    
    fun getTransactCode(clazz: Class<*>, method: String): Int =
        clazz.getDeclaredField("TRANSACTION_$method").apply { isAccessible = true }
            .getInt(null)
    
    fun createSuccessKeystoreResponse(): KeystoreResponse {
        val parcel = Parcel.obtain()
        try {
            parcel.writeInt(KeyStore.NO_ERROR)
            parcel.writeString("")
            parcel.setDataPosition(0)
            return KeystoreResponse.CREATOR.createFromParcel(parcel)
        } finally {
            parcel.recycle()
        }
    }
    
    fun createSuccessReply(resultCode: Int = KeyStore.NO_ERROR): BinderInterceptor.OverrideReply {
        val parcel = Parcel.obtain()
        parcel.writeNoException()
        parcel.writeInt(resultCode)
        return BinderInterceptor.OverrideReply(0, parcel)
    }
    
    fun createByteArrayReply(data: ByteArray, resultCode: Int = KeyStore.NO_ERROR): BinderInterceptor.OverrideReply {
        val parcel = Parcel.obtain()
        parcel.writeNoException()
        parcel.writeByteArray(data)
        return BinderInterceptor.OverrideReply(resultCode, parcel)
    }
    
    fun <T : Parcelable?> createTypedObjectReply(obj: T, flags: Int = 0, resultCode: Int = 0): BinderInterceptor.OverrideReply {
        val parcel = Parcel.obtain()
        parcel.writeNoException()
        parcel.writeTypedObject(obj, flags)
        return BinderInterceptor.OverrideReply(resultCode, parcel)
    }
    
    fun String.extractAlias(): String {
        return when {
            contains("_") -> split("_")[1] 
            else -> this
        }
    }
    
    fun Parcel.hasException(): Boolean {
        return kotlin.runCatching { readException() }.exceptionOrNull() != null
    }
}
```

`app/src/main/java/io/github/beakthoven/TrickyStoreOSS/interceptors/Keystore2Interceptor.kt`:

```kt
/*
 * Copyright 2025 Dakkshesh <beakthoven@gmail.com>
 * SPDX-License-Identifier: GPL-3.0-or-later
 */

package io.github.beakthoven.TrickyStoreOSS.interceptors

import android.annotation.SuppressLint
import android.hardware.security.keymint.SecurityLevel
import android.os.IBinder
import android.os.Parcel
import android.system.keystore2.IKeystoreService
import android.system.keystore2.KeyDescriptor
import android.system.keystore2.KeyEntryResponse
import io.github.beakthoven.TrickyStoreOSS.CertificateHack
import io.github.beakthoven.TrickyStoreOSS.CertificateUtils
import io.github.beakthoven.TrickyStoreOSS.KeyBoxUtils
import io.github.beakthoven.TrickyStoreOSS.config.PkgConfig
import io.github.beakthoven.TrickyStoreOSS.interceptors.InterceptorUtils.createTypedObjectReply
import io.github.beakthoven.TrickyStoreOSS.interceptors.InterceptorUtils.getTransactCode
import io.github.beakthoven.TrickyStoreOSS.interceptors.InterceptorUtils.hasException
import io.github.beakthoven.TrickyStoreOSS.logging.Logger
import io.github.beakthoven.TrickyStoreOSS.putCertificateChain

@SuppressLint("BlockedPrivateApi")
object Keystore2Interceptor : BaseKeystoreInterceptor() {
    private val getKeyEntryTransaction =
        getTransactCode(IKeystoreService.Stub::class.java, "getKeyEntry")
    private val deleteKeyTransaction =
        getTransactCode(IKeystoreService.Stub::class.java, "deleteKey")
    
    override val serviceName = "android.system.keystore2.IKeystoreService/default"
    override val processName = "keystore2"
    override val injectionCommand = "exec ./inject `pidof keystore2` libTrickyStoreOSS.so entry"

    private var teeInterceptor: SecurityLevelInterceptor? = null
    private var strongBoxInterceptor: SecurityLevelInterceptor? = null
    
    override fun onInterceptorSetup(service: IBinder, backdoor: IBinder) {
        setupSecurityLevelInterceptors(service, backdoor)
    }
    
    private fun setupSecurityLevelInterceptors(service: IBinder, backdoor: IBinder) {
        val ks = IKeystoreService.Stub.asInterface(service)
        
        val tee = kotlin.runCatching { ks.getSecurityLevel(SecurityLevel.TRUSTED_ENVIRONMENT) }
            .getOrNull()
        if (tee != null) {
            Logger.i("Registering for TEE SecurityLevel: $tee")
            val interceptor = SecurityLevelInterceptor(tee, SecurityLevel.TRUSTED_ENVIRONMENT)
            registerBinderInterceptor(backdoor, tee.asBinder(), interceptor)
            teeInterceptor = interceptor
        } else {
            Logger.i("No TEE SecurityLevel found")
        }
        
        val strongBox = kotlin.runCatching { ks.getSecurityLevel(SecurityLevel.STRONGBOX) }
            .getOrNull()
        if (strongBox != null) {
            Logger.i("Registering for StrongBox SecurityLevel: $strongBox")
            val interceptor = SecurityLevelInterceptor(strongBox, SecurityLevel.STRONGBOX)
            registerBinderInterceptor(backdoor, strongBox.asBinder(), interceptor)
            strongBoxInterceptor = interceptor
        } else {
            Logger.i("No StrongBox SecurityLevel found")
        }
    }

    override fun onPreTransact(
        target: IBinder,
        code: Int,
        flags: Int,
        callingUid: Int,
        callingPid: Int,
        data: Parcel
    ): Result {
        if (code == getKeyEntryTransaction) {
            if (KeyBoxUtils.hasKeyboxes()) {
                Logger.d("intercept pre  $target uid=$callingUid pid=$callingPid dataSz=${data.dataSize()}")
                try {
                    data.enforceInterface(IKeystoreService.DESCRIPTOR)
                    val descriptor = data.readTypedObject(KeyDescriptor.CREATOR) ?: return Skip
                    if (PkgConfig.needGenerate(callingUid)) {
                        val response = SecurityLevelInterceptor.getKeyResponse(callingUid, descriptor.alias)
                        if (response != null) {
                            Logger.i("Found generated response for uid=$callingUid alias=${descriptor.alias}")
                            return createTypedObjectReply(response)
                        } else {
                            Logger.e("No generated response found for uid=$callingUid alias=${descriptor.alias}")
                            val nullParcel = Parcel.obtain()
                            nullParcel.writeTypedObject(null as KeyEntryResponse?, 0)
                            return OverrideReply(0, nullParcel)
                        }
                    } else if (PkgConfig.needHack(callingUid)) {
                        if (SecurityLevelInterceptor.shouldSkipLeafHack(callingUid, descriptor.alias)) {
                            Logger.i("skip leaf hack for uid=$callingUid alias=${descriptor.alias}")
                            val response = SecurityLevelInterceptor.getKeyResponse(callingUid, descriptor.alias)
                            if (response != null) {
                                Logger.i("Found generated response for uid=$callingUid alias=${descriptor.alias}")
                                return createTypedObjectReply(response)
                            } else {
                                Logger.e("No generated response found for uid=$callingUid alias=${descriptor.alias}")
                                val nullParcel = Parcel.obtain()
                                nullParcel.writeTypedObject(null as KeyEntryResponse?, 0)
                                return OverrideReply(0, nullParcel)
                            }
                        } else {
                            Logger.i("proceeding with leaf hack for uid=$callingUid alias=${descriptor.alias}")
                            return Continue
                        }
                    }
                    return Skip
                } catch (e: Exception) {
                    Logger.e("Exception in onPreTransact uid=$callingUid pid=$callingPid!", e)
                    return Skip
                }
            }
        }
        return Skip
    }

    override fun onPostTransact(
        target: IBinder,
        code: Int,
        flags: Int,
        callingUid: Int,
        callingPid: Int,
        data: Parcel,
        reply: Parcel?,
        resultCode: Int
    ): Result {
        if (target != keystore || reply == null) return Skip
        if (reply.hasException()) return Skip
        val p = Parcel.obtain()
        Logger.d("intercept post $target uid=$callingUid pid=$callingPid dataSz=${data.dataSize()} replySz=${reply.dataSize()}")

        if (code == deleteKeyTransaction && resultCode == 0) {
            data.enforceInterface("android.system.keystore2.IKeystoreService")

            val keyDescriptor = data.readTypedObject(KeyDescriptor.CREATOR)
            if (keyDescriptor == null || keyDescriptor.domain == 0) return Skip

            SecurityLevelInterceptor.keys.remove(SecurityLevelInterceptor.Key(callingUid, keyDescriptor.alias))

            return Skip
        } else if (code == getKeyEntryTransaction) {
            try {
                data.enforceInterface("android.system.keystore2.IKeystoreService")
                val response = reply.readTypedObject(KeyEntryResponse.CREATOR)
                if (response != null) {
                    val chain = CertificateUtils.run { response.getCertificateChain() }
                if (chain != null) {
                        val newChain = CertificateHack.hackCertificateChain(chain)
                        response.putCertificateChain(newChain).getOrThrow()
                        Logger.i("Hacked certificate for uid=$callingUid")
                        return createTypedObjectReply(response)
                    } else {
                        p.recycle()
                    }
                } else {
                    p.recycle()
                }
            } catch (t: Throwable) {
                Logger.e("failed to hack certificate chain of uid=$callingUid pid=$callingPid!", t)
                p.recycle()
            }
        }
        return Skip
    }
}
```

`app/src/main/java/io/github/beakthoven/TrickyStoreOSS/interceptors/KeystoreInterceptor.kt`:

```kt
/*
 * Copyright 2025 Dakkshesh <beakthoven@gmail.com>
 * SPDX-License-Identifier: GPL-3.0-or-later
 */

package io.github.beakthoven.TrickyStoreOSS.interceptors

import android.annotation.SuppressLint
import android.os.IBinder
import android.os.Parcel
import android.security.Credentials
import android.security.KeyStore
import android.security.keymaster.ExportResult
import android.security.keymaster.KeyCharacteristics
import android.security.keymaster.KeymasterArguments
import android.security.keymaster.KeymasterCertificateChain
import android.security.keymaster.KeymasterDefs
import android.security.keystore.IKeystoreCertificateChainCallback
import android.security.keystore.IKeystoreExportKeyCallback
import android.security.keystore.IKeystoreKeyCharacteristicsCallback
import android.security.keystore.IKeystoreService
import io.github.beakthoven.TrickyStoreOSS.CertificateGen
import io.github.beakthoven.TrickyStoreOSS.CertificateHack
import io.github.beakthoven.TrickyStoreOSS.KeyBoxUtils
import io.github.beakthoven.TrickyStoreOSS.config.PkgConfig
import io.github.beakthoven.TrickyStoreOSS.interceptors.InterceptorUtils.createByteArrayReply
import io.github.beakthoven.TrickyStoreOSS.interceptors.InterceptorUtils.createSuccessKeystoreResponse
import io.github.beakthoven.TrickyStoreOSS.interceptors.InterceptorUtils.createSuccessReply
import io.github.beakthoven.TrickyStoreOSS.interceptors.InterceptorUtils.extractAlias
import io.github.beakthoven.TrickyStoreOSS.interceptors.InterceptorUtils.getTransactCode
import io.github.beakthoven.TrickyStoreOSS.interceptors.InterceptorUtils.hasException
import io.github.beakthoven.TrickyStoreOSS.logging.Logger
import java.math.BigInteger
import java.security.KeyPair
import java.util.Date

@SuppressLint("BlockedPrivateApi")
object KeystoreInterceptor : BaseKeystoreInterceptor() {
    private val getTransaction =
        getTransactCode(IKeystoreService.Stub::class.java, "get")
    private val generateKeyTransaction =
        getTransactCode(IKeystoreService.Stub::class.java, "generateKey")
    private val getKeyCharacteristicsTransaction =
        getTransactCode(IKeystoreService.Stub::class.java, "getKeyCharacteristics")
    private val exportKeyTransaction =
        getTransactCode(IKeystoreService.Stub::class.java, "exportKey")
    private val attestKeyTransaction =
        getTransactCode(IKeystoreService.Stub::class.java, "attestKey")
    
    override val serviceName = "android.security.keystore"
    override val processName = "keystore"
    override val injectionCommand = "exec ./inject `pidof keystore` libTrickyStoreOSS.so entry"

    private const val DESCRIPTOR = "android.security.keystore.IKeystoreService"

    private val keyArguments = HashMap<Key, CertificateGen.KeyGenParameters>()
    private val keyPairs = HashMap<Key, KeyPair>()

    data class Key(val uid: Int, val alias: String)

    override fun onPreTransact(
        target: IBinder,
        code: Int,
        flags: Int,
        callingUid: Int,
        callingPid: Int,
        data: Parcel
    ): Result {
        if (KeyBoxUtils.hasKeyboxes()) {
            if (code == getTransaction) {
                if (PkgConfig.needHack(callingUid)) {
                    return Continue
                } else if (PkgConfig.needGenerate(callingUid)) {
                    return Skip
                }
            } else if (PkgConfig.needGenerate(callingUid)) {
                when (code) {
                    generateKeyTransaction -> {
                        kotlin.runCatching {
                            data.enforceInterface(DESCRIPTOR)
                            val callback = IKeystoreKeyCharacteristicsCallback.Stub.asInterface(data.readStrongBinder())
                            val alias = data.readString()!!.extractAlias()
                            Logger.i("generateKeyTransaction uid $callingUid alias $alias")
                            val check = data.readInt()
                            val kma = KeymasterArguments()
                            val kgp = CertificateGen.KeyGenParameters()
                            if (check == 1) {
                                kma.readFromParcel(data)
                                kgp.algorithm = kma.getEnum(KeymasterDefs.KM_TAG_ALGORITHM, 0)
                                kgp.keySize = kma.getUnsignedInt(KeymasterDefs.KM_TAG_KEY_SIZE, 0).toInt()
                                //kgp.setEcCurveName(kgp.keySize)
                                kgp.purpose = kma.getEnums(KeymasterDefs.KM_TAG_PURPOSE)
                                kgp.digest = kma.getEnums(KeymasterDefs.KM_TAG_DIGEST)
                                kgp.certificateNotBefore = kma.getDate(KeymasterDefs.KM_TAG_ACTIVE_DATETIME, Date())
                                if (kgp.algorithm == KeymasterDefs.KM_ALGORITHM_RSA) {
                                    try {
                                        val getArgumentByTag = KeymasterArguments::class.java.getDeclaredMethods().first { it.name == "getArgumentByTag" }
                                        getArgumentByTag.isAccessible = true
                                        val rsaArgument = getArgumentByTag.invoke(kma, KeymasterDefs.KM_TAG_RSA_PUBLIC_EXPONENT)

                                        val getLongTagValue = KeymasterArguments::class.java.getDeclaredMethods().first { it.name == "getLongTagValue" }
                                        getLongTagValue.isAccessible = true
                                        kgp.rsaPublicExponent = getLongTagValue.invoke(kma, rsaArgument) as BigInteger
                                    } catch (ex: Exception) {
                                        Logger.e("Read rsaPublicExponent error", ex)
                                    }
                                }
                                keyArguments[Key(callingUid, alias)] = kgp
                            }

                            val kc = KeyCharacteristics()
                            kc.swEnforced = KeymasterArguments()
                            kc.hwEnforced = kma

                            val ksr = createSuccessKeystoreResponse()
                            callback.onFinished(ksr, kc)

                            return createSuccessReply()
                        }.onFailure {
                            Logger.e("generateKeyTransaction error", it)
                        }
                    }

                    getKeyCharacteristicsTransaction -> {
                        kotlin.runCatching {
                            data.enforceInterface(DESCRIPTOR)
                            val callback = IKeystoreKeyCharacteristicsCallback.Stub.asInterface(data.readStrongBinder())
                            val alias = data.readString()!!.extractAlias()
                            Logger.i("getKeyCharacteristicsTransaction uid $callingUid alias $alias")
                            val kc = KeyCharacteristics()
                            val kma = KeymasterArguments()
                            kma.addEnum(KeymasterDefs.KM_TAG_ALGORITHM, keyArguments[Key(callingUid, alias)]!!.algorithm)
                            kc.swEnforced = KeymasterArguments()
                            kc.hwEnforced = kma

                            val ksr = createSuccessKeystoreResponse()
                            callback.onFinished(ksr, kc)

                            return createSuccessReply()
                        }.onFailure {
                            Logger.e("getKeyCharacteristicsTransaction error", it)
                        }
                    }

                    exportKeyTransaction -> {
                        kotlin.runCatching {
                            data.enforceInterface(DESCRIPTOR)
                            val callback = IKeystoreExportKeyCallback.Stub.asInterface(data.readStrongBinder())
                            val alias = data.readString()!!.extractAlias()
                            Logger.i("exportKeyTransaction uid $callingUid alias $alias")
                            val kp = CertificateGen.generateKeyPair(keyArguments[Key(callingUid, alias)]!!)
                            keyPairs[Key(callingUid, alias)] = kp!!

                            val erP = Parcel.obtain()
                            erP.writeInt(KeyStore.NO_ERROR)
                            erP.writeByteArray(kp.public.encoded)
                            erP.setDataPosition(0)
                            val er = ExportResult.CREATOR.createFromParcel(erP)
                            erP.recycle()

                            callback.onFinished(er)

                            return createSuccessReply()
                        }.onFailure {
                            Logger.e("exportKeyTransaction error", it)
                        }
                    }

                    attestKeyTransaction -> {
                        kotlin.runCatching {
                            data.enforceInterface(DESCRIPTOR)
                            val callback = IKeystoreCertificateChainCallback.Stub.asInterface(data.readStrongBinder())
                            val alias = data.readString()!!.extractAlias()
                            Logger.i("attestKeyTransaction uid $callingUid alias $alias")
                            val check = data.readInt()
                            val kma = KeymasterArguments()
                            if (check == 1) {
                                kma.readFromParcel(data)
                                val attestationChallenge = kma.getBytes(KeymasterDefs.KM_TAG_ATTESTATION_CHALLENGE, ByteArray(0))

                                val ksr = createSuccessKeystoreResponse()

                                val key = Key(callingUid, alias)
                                val ka = keyArguments[key]!!
                                ka.attestationChallenge = attestationChallenge
                                val chain = CertificateGen.generateChain(callingUid, ka, keyPairs[key]!!)

                                val kcc = KeymasterCertificateChain(chain)
                                callback.onFinished(ksr, kcc)
                            }

                            return createSuccessReply()
                        }.onFailure {
                            Logger.e("attestKeyTransaction error", it)
                        }
                    }
                }
            }
        }
        return Skip
    }

    override fun onPostTransact(
        target: IBinder,
        code: Int,
        flags: Int,
        callingUid: Int,
        callingPid: Int,
        data: Parcel,
        reply: Parcel?,
        resultCode: Int
    ): Result {
        if (target != keystore || code != getTransaction || reply == null) return Skip
        if (reply.hasException()) return Skip
        val p = Parcel.obtain()
        Logger.d("intercept post $target uid=$callingUid pid=$callingPid dataSz=${data.dataSize()} replySz=${reply.dataSize()}")
        try {
            data.enforceInterface(DESCRIPTOR)
            val alias = data.readString() ?: ""
            var response = reply.createByteArray()
            when {
                alias.startsWith(Credentials.USER_CERTIFICATE) -> {
                    response = CertificateHack.hackUserCertificate(response!!, alias.extractAlias(), callingUid)
                    Logger.i("Hacked leaf certificate for uid=$callingUid")
                    return createByteArrayReply(response)
                }
                alias.startsWith(Credentials.CA_CERTIFICATE) -> {
                    response = CertificateHack.hackCACertificateChain(response!!, alias.extractAlias(), callingUid)
                    Logger.i("Hacked CA certificate chain for uid=$callingUid")
                    return createByteArrayReply(response)
                }
                else -> p.recycle()
            }
        } catch (t: Throwable) {
            Logger.e("failed to hack certificate chain of uid=$callingUid pid=$callingPid!", t)
            p.recycle()
        }
        return Skip
    }
}
```

`app/src/main/java/io/github/beakthoven/TrickyStoreOSS/interceptors/SecurityLevelInterceptor.kt`:

```kt
/*
 * Copyright 2025 Dakkshesh <beakthoven@gmail.com>
 * SPDX-License-Identifier: GPL-3.0-or-later
 */

package io.github.beakthoven.TrickyStoreOSS.interceptors

import android.hardware.security.keymint.KeyParameter
import android.hardware.security.keymint.KeyParameterValue
import android.hardware.security.keymint.Tag
import android.os.IBinder
import android.os.Parcel
import android.system.keystore2.Authorization
import android.system.keystore2.IKeystoreSecurityLevel
import android.system.keystore2.KeyDescriptor
import android.system.keystore2.KeyEntryResponse
import android.system.keystore2.KeyMetadata
import androidx.annotation.Keep
import io.github.beakthoven.TrickyStoreOSS.CertificateGen
import io.github.beakthoven.TrickyStoreOSS.config.PkgConfig
import io.github.beakthoven.TrickyStoreOSS.interceptors.InterceptorUtils.getTransactCode
import io.github.beakthoven.TrickyStoreOSS.logging.Logger
import io.github.beakthoven.TrickyStoreOSS.putCertificateChain
import java.security.KeyPair
import java.security.cert.Certificate
import java.util.concurrent.ConcurrentHashMap

class SecurityLevelInterceptor(
    private val original: IKeystoreSecurityLevel,
    private val level: Int
) : BinderInterceptor() {
    companion object {
        private val generateKeyTransaction =
            getTransactCode(IKeystoreSecurityLevel.Stub::class.java, "generateKey")
        private val deleteKeyTransaction =
            getTransactCode(IKeystoreSecurityLevel.Stub::class.java, "deleteKey")
        private val createOperationTransaction =
            getTransactCode(IKeystoreSecurityLevel.Stub::class.java, "createOperation")

        @Keep
        val keys = ConcurrentHashMap<Key, Info>()

        @Keep
        val keyPairs = ConcurrentHashMap<Key, Pair<KeyPair, List<Certificate>>>()

        @Keep
        val skipLeafHacks = ConcurrentHashMap<Key, Boolean>()

        @Keep
        fun getKeyResponse(uid: Int, alias: String): KeyEntryResponse? =
            keys[Key(uid, alias)]?.response

        @Keep
        fun getKeyPairs(uid: Int, alias: String): Pair<KeyPair, List<Certificate>>? =
            keyPairs[Key(uid, alias)]

        @Keep
        fun shouldSkipLeafHack(uid: Int, alias: String): Boolean =
            skipLeafHacks[Key(uid, alias)] ?: false
    }

    data class Key(val uid: Int, val alias: String)
    data class Info(val keyPair: KeyPair, val response: KeyEntryResponse)

    override fun onPreTransact(
        target: IBinder,
        code: Int,
        flags: Int,
        callingUid: Int,
        callingPid: Int,
        data: Parcel
    ): Result {
        if (code == generateKeyTransaction) {
            Logger.i("intercept key gen uid=$callingUid pid=$callingPid")
            kotlin.runCatching {
                data.enforceInterface(IKeystoreSecurityLevel.DESCRIPTOR)
                val keyDescriptor =
                    data.readTypedObject(KeyDescriptor.CREATOR) ?: return@runCatching
                val attestationKeyDescriptor = data.readTypedObject(KeyDescriptor.CREATOR)
                val params = data.createTypedArray(KeyParameter.CREATOR)!!
                val aFlags = data.readInt()
                val entropy = data.createByteArray()
                val kgp = CertificateGen.KeyGenParameters(params)
                if (PkgConfig.needGenerate(callingUid)) {
                    val pair = CertificateGen.generateKeyPair(callingUid, keyDescriptor, attestationKeyDescriptor, kgp, level)
                        ?: return@runCatching
                    keyPairs[Key(callingUid, keyDescriptor.alias)] = Pair(pair.first, pair.second)
                    val response = buildResponse(pair.second, kgp, attestationKeyDescriptor ?: keyDescriptor)
                    keys[Key(callingUid, keyDescriptor.alias)] = Info(pair.first, response)
                    val p = Parcel.obtain()
                    p.writeNoException()
                    p.writeTypedObject(response.metadata, 0)
                    return OverrideReply(0, p)
                } else if (PkgConfig.needHack(callingUid)) {
                    if ((kgp.purpose.contains(7)) || (attestationKeyDescriptor != null)) {
                        Logger.i("Generating key in generation mode for attestation: uid=$callingUid alias=${keyDescriptor.alias}")
                        val pair = CertificateGen.generateKeyPair(callingUid, keyDescriptor, attestationKeyDescriptor, kgp, level)
                            ?: return@runCatching
                        keyPairs[Key(callingUid, keyDescriptor.alias)] = Pair(pair.first, pair.second)
                        val response = buildResponse(pair.second, kgp, attestationKeyDescriptor ?: keyDescriptor)
                        keys[Key(callingUid, keyDescriptor.alias)] = Info(pair.first, response)
                        SecurityLevelInterceptor.skipLeafHacks[Key(callingUid, keyDescriptor.alias)] = true
                        val p = Parcel.obtain()
                        p.writeNoException()
                        p.writeTypedObject(response.metadata, 0)
                        return OverrideReply(0, p)
                    } else {
                        skipLeafHacks.remove(Key(callingUid, keyDescriptor.alias))
                        Logger.i("Cleared skip flag for non-attestation key: uid=$callingUid alias=${keyDescriptor.alias}")
                        return Skip
                    }
                }
            }.onFailure {
                Logger.e("parse key gen request", it)
            }
        }
        return Skip
    }

    private fun buildResponse(
        chain: List<Certificate>,
        params: CertificateGen.KeyGenParameters,
        descriptor: KeyDescriptor
    ): KeyEntryResponse {
        val response = KeyEntryResponse()
        val metadata = KeyMetadata()
        metadata.keySecurityLevel = level
        metadata.putCertificateChain(chain.toTypedArray()).getOrThrow()
        val d = KeyDescriptor()
        d.domain = descriptor.domain
        d.nspace = descriptor.nspace
        metadata.key = d
        val authorizations = ArrayList<Authorization>()
        var a: Authorization
        for (i in params.purpose.toList()) {
            a = Authorization()
            a.keyParameter = KeyParameter()
            a.keyParameter.tag = Tag.PURPOSE
            a.keyParameter.value = KeyParameterValue.keyPurpose(i)
            a.securityLevel = level
            authorizations.add(a)
        }
        for (i in params.digest.toList()) {
            a = Authorization()
            a.keyParameter = KeyParameter()
            a.keyParameter.tag = Tag.DIGEST
            a.keyParameter.value = KeyParameterValue.digest(i)
            a.securityLevel = level
            authorizations.add(a)
        }
        a = Authorization()
        a.keyParameter = KeyParameter()
        a.keyParameter.tag = Tag.ALGORITHM
        a.keyParameter.value = KeyParameterValue.algorithm(params.algorithm)
        a.securityLevel = level
        authorizations.add(a)
        a = Authorization()
        a.keyParameter = KeyParameter()
        a.keyParameter.tag = Tag.KEY_SIZE
        a.keyParameter.value = KeyParameterValue.integer(params.keySize)
        a.securityLevel = level
        authorizations.add(a)
        a = Authorization()
        a.keyParameter = KeyParameter()
        a.keyParameter.tag = Tag.EC_CURVE
        a.keyParameter.value = KeyParameterValue.ecCurve(params.ecCurve)
        a.securityLevel = level
        authorizations.add(a)
        a = Authorization()
        a.keyParameter = KeyParameter()
        a.keyParameter.tag = Tag.NO_AUTH_REQUIRED
        a.keyParameter.value = KeyParameterValue.boolValue(true)
        a.securityLevel = level
        authorizations.add(a)
        metadata.authorizations = authorizations.toTypedArray<Authorization>()
        response.metadata = metadata
        response.iSecurityLevel = original
        return response
    }
}
```

`app/src/main/java/io/github/beakthoven/TrickyStoreOSS/logging/Logger.kt`:

```kt
/*
 * Copyright 2025 Dakkshesh <beakthoven@gmail.com>
 * SPDX-License-Identifier: GPL-3.0-or-later
 */

package io.github.beakthoven.TrickyStoreOSS.logging

import android.util.Log

object Logger {
    const val TAG = "TrickyStoreOSS"
    
    sealed class LogLevel(val priority: Int) {
        object Debug : LogLevel(Log.DEBUG)
        object Info : LogLevel(Log.INFO)
        object Warning : LogLevel(Log.WARN)
        object Error : LogLevel(Log.ERROR)
        object Verbose : LogLevel(Log.VERBOSE)
    }
    
    fun d(message: String) {
        Log.d(TAG, message)
    }
    
    fun e(message: String) {
        Log.e(TAG, message)
    }
    
    fun e(message: String, throwable: Throwable) {
        Log.e(TAG, "fatal: $message", throwable)
    }
    
    fun i(message: String) {
        Log.i(TAG, message)
    }
    
    fun w(message: String) {
        Log.w(TAG, message)
    }
    
    fun w(message: String, throwable: Throwable) {
        Log.w(TAG, message, throwable)
    }
    
    fun v(message: String) {
        Log.v(TAG, message)
    }
    
    fun log(level: LogLevel, message: String, throwable: Throwable? = null) {
        when (level) {
            is LogLevel.Debug -> if (throwable != null) Log.d(TAG, message, throwable) else Log.d(TAG, message)
            is LogLevel.Info -> if (throwable != null) Log.i(TAG, message, throwable) else Log.i(TAG, message)
            is LogLevel.Warning -> if (throwable != null) Log.w(TAG, message, throwable) else Log.w(TAG, message)
            is LogLevel.Error -> if (throwable != null) Log.e(TAG, message, throwable) else Log.e(TAG, message)
            is LogLevel.Verbose -> if (throwable != null) Log.v(TAG, message, throwable) else Log.v(TAG, message)
        }
    }
    
    fun logIf(level: LogLevel, condition: Boolean = true, messageProvider: () -> String) {
        if (condition && Log.isLoggable(TAG, level.priority)) {
            log(level, messageProvider())
        }
    }
}
```

`build.gradle.kts`:

```kts
/*
 * Copyright 2025 Dakkshesh <beakthoven@gmail.com>
 * SPDX-License-Identifier: GPL-3.0-or-later
 */

// Top-level build file where you can add configuration options common to all sub-projects/modules.
plugins {
    alias(libs.plugins.android.application) apply false
    alias(libs.plugins.android.library) apply false
    alias(libs.plugins.kotlin.android) apply false
}
```

`docs/5ec1cff-violations.md`:

```md
# Violations and Practices of TrickyStore Author

## ğŸ“¦ Use of Open-Source Code Without Proper Licensing

- Took headers from AOSP for stubbing without providing proper attribution or respecting licensing norms [Â¹](#references).
- Statically linked an LGPLv3 library into their binary but failed to release their source or comply with LGPL requirements [Â²](#references).

## ğŸš« "All Rights Reserved"

- Initially published code with **no license**, making it "all rights reserved" despite using open-source components [Â³](#references).
- Invited pull requests (â€œPRs welcomeâ€) while keeping the code legally closed â€“ **taking from the community without giving back** [â´](#references).

## ğŸ”’ Shift to Fully Closed-Source

- After releasing a few open-source versions, decided to fully close-source the project with:
  - Encrypted module binaries
  - Obfuscated APKs
- Claimed:  
  > â€œDue to rampant misuse and fewer contributions than expected, this module will be closed-source starting from version 1.1.0.â€ [âµ](#references)

---

## References

1. https://github.com/5ec1cff/TrickyStore/tree/master/module/src/main/cpp/binder/include/binder
2. https://github.com/5ec1cff/TrickyStore/blob/master/module/src/main/cpp/CMakeLists.txt#L28  
3. https://github.com/5ec1cff/TrickyStore/pull/84  
4. https://github.com/5ec1cff/TrickyStore/blob/master/README.md?plain=1#L91  
5. https://github.com/5ec1cff/TrickyStore/blob/release/README.md?plain=1#L11 

```

`gradle.properties`:

```properties
# Project-wide Gradle settings.
# IDE (e.g. Android Studio) users:
# Gradle settings configured through the IDE *will override*
# any settings specified in this file.
# For more details on how to configure your build environment visit
# http://www.gradle.org/docs/current/userguide/build_environment.html
# Specifies the JVM arguments used for the daemon process.
# The setting is particularly useful for tweaking memory settings.
org.gradle.jvmargs=-Xmx2048m -Dfile.encoding=UTF-8
# When configured, Gradle will run in incubating parallel mode.
# This option should only be used with decoupled projects. For more details, visit
# https://developer.android.com/r/tools/gradle-multi-project-decoupled-projects
# org.gradle.parallel=true
# AndroidX package structure to make it clearer which packages are bundled with the
# Android operating system, and which are packaged with your app's APK
# https://developer.android.com/topic/libraries/support-library/androidx-rn
android.useAndroidX=true
# Kotlin code style for this project: "official" or "obsolete":
kotlin.code.style=official
# Enables namespacing of each library's R class so that its R class includes only the
# resources declared in the library itself and none from the library's dependencies,
# thereby reducing the size of the R class for that library
android.nonTransitiveRClass=true
```

`gradle/libs.versions.toml`:

```toml
[versions]
agp = "8.13.0"
annotation = "1.9.1"
jdk18on = "1.81"
kotlin = "2.2.10"
libcxx = "28.1.13356709"

[libraries]
annotation = { module = "androidx.annotation:annotation", version.ref = "annotation" }
org-bouncycastle-bcpkix-jdk18on = { module = "org.bouncycastle:bcpkix-jdk18on", version.ref = "jdk18on" }
org-lsposed-libcxx-libcxx = { module = "org.lsposed.libcxx:libcxx", version.ref = "libcxx" }

[plugins]
android-application = { id = "com.android.application", version.ref = "agp" }
android-library = { id = "com.android.library", version.ref = "agp" }
kotlin-android = { id = "org.jetbrains.kotlin.android", version.ref = "kotlin" }


```

`gradle/wrapper/gradle-wrapper.properties`:

```properties
distributionBase=GRADLE_USER_HOME
distributionPath=wrapper/dists
distributionUrl=https\://services.gradle.org/distributions/gradle-9.0.0-bin.zip
networkTimeout=10000
validateDistributionUrl=true
zipStoreBase=GRADLE_USER_HOME
zipStorePath=wrapper/dists

```

`gradlew`:

```
#!/bin/sh

#
# Copyright Â© 2015 the original authors.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#      https://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
#
# SPDX-License-Identifier: Apache-2.0
#

##############################################################################
#
#   Gradle start up script for POSIX generated by Gradle.
#
#   Important for running:
#
#   (1) You need a POSIX-compliant shell to run this script. If your /bin/sh is
#       noncompliant, but you have some other compliant shell such as ksh or
#       bash, then to run this script, type that shell name before the whole
#       command line, like:
#
#           ksh Gradle
#
#       Busybox and similar reduced shells will NOT work, because this script
#       requires all of these POSIX shell features:
#         * functions;
#         * expansions Â«$varÂ», Â«${var}Â», Â«${var:-default}Â», Â«${var+SET}Â»,
#           Â«${var#prefix}Â», Â«${var%suffix}Â», and Â«$( cmd )Â»;
#         * compound commands having a testable exit status, especially Â«caseÂ»;
#         * various built-in commands including Â«commandÂ», Â«setÂ», and Â«ulimitÂ».
#
#   Important for patching:
#
#   (2) This script targets any POSIX shell, so it avoids extensions provided
#       by Bash, Ksh, etc; in particular arrays are avoided.
#
#       The "traditional" practice of packing multiple parameters into a
#       space-separated string is a well documented source of bugs and security
#       problems, so this is (mostly) avoided, by progressively accumulating
#       options in "$@", and eventually passing that to Java.
#
#       Where the inherited environment variables (DEFAULT_JVM_OPTS, JAVA_OPTS,
#       and GRADLE_OPTS) rely on word-splitting, this is performed explicitly;
#       see the in-line comments for details.
#
#       There are tweaks for specific operating systems such as AIX, CygWin,
#       Darwin, MinGW, and NonStop.
#
#   (3) This script is generated from the Groovy template
#       https://github.com/gradle/gradle/blob/HEAD/platforms/jvm/plugins-application/src/main/resources/org/gradle/api/internal/plugins/unixStartScript.txt
#       within the Gradle project.
#
#       You can find Gradle at https://github.com/gradle/gradle/.
#
##############################################################################

# Attempt to set APP_HOME

# Resolve links: $0 may be a link
app_path=$0

# Need this for daisy-chained symlinks.
while
    APP_HOME=${app_path%"${app_path##*/}"}  # leaves a trailing /; empty if no leading path
    [ -h "$app_path" ]
do
    ls=$( ls -ld "$app_path" )
    link=${ls#*' -> '}
    case $link in             #(
      /*)   app_path=$link ;; #(
      *)    app_path=$APP_HOME$link ;;
    esac
done

# This is normally unused
# shellcheck disable=SC2034
APP_BASE_NAME=${0##*/}
# Discard cd standard output in case $CDPATH is set (https://github.com/gradle/gradle/issues/25036)
APP_HOME=$( cd -P "${APP_HOME:-./}" > /dev/null && printf '%s\n' "$PWD" ) || exit

# Use the maximum available, or set MAX_FD != -1 to use that value.
MAX_FD=maximum

warn () {
    echo "$*"
} >&2

die () {
    echo
    echo "$*"
    echo
    exit 1
} >&2

# OS specific support (must be 'true' or 'false').
cygwin=false
msys=false
darwin=false
nonstop=false
case "$( uname )" in                #(
  CYGWIN* )         cygwin=true  ;; #(
  Darwin* )         darwin=true  ;; #(
  MSYS* | MINGW* )  msys=true    ;; #(
  NONSTOP* )        nonstop=true ;;
esac

CLASSPATH="\\\"\\\""


# Determine the Java command to use to start the JVM.
if [ -n "$JAVA_HOME" ] ; then
    if [ -x "$JAVA_HOME/jre/sh/java" ] ; then
        # IBM's JDK on AIX uses strange locations for the executables
        JAVACMD=$JAVA_HOME/jre/sh/java
    else
        JAVACMD=$JAVA_HOME/bin/java
    fi
    if [ ! -x "$JAVACMD" ] ; then
        die "ERROR: JAVA_HOME is set to an invalid directory: $JAVA_HOME

Please set the JAVA_HOME variable in your environment to match the
location of your Java installation."
    fi
else
    JAVACMD=java
    if ! command -v java >/dev/null 2>&1
    then
        die "ERROR: JAVA_HOME is not set and no 'java' command could be found in your PATH.

Please set the JAVA_HOME variable in your environment to match the
location of your Java installation."
    fi
fi

# Increase the maximum file descriptors if we can.
if ! "$cygwin" && ! "$darwin" && ! "$nonstop" ; then
    case $MAX_FD in #(
      max*)
        # In POSIX sh, ulimit -H is undefined. That's why the result is checked to see if it worked.
        # shellcheck disable=SC2039,SC3045
        MAX_FD=$( ulimit -H -n ) ||
            warn "Could not query maximum file descriptor limit"
    esac
    case $MAX_FD in  #(
      '' | soft) :;; #(
      *)
        # In POSIX sh, ulimit -n is undefined. That's why the result is checked to see if it worked.
        # shellcheck disable=SC2039,SC3045
        ulimit -n "$MAX_FD" ||
            warn "Could not set maximum file descriptor limit to $MAX_FD"
    esac
fi

# Collect all arguments for the java command, stacking in reverse order:
#   * args from the command line
#   * the main class name
#   * -classpath
#   * -D...appname settings
#   * --module-path (only if needed)
#   * DEFAULT_JVM_OPTS, JAVA_OPTS, and GRADLE_OPTS environment variables.

# For Cygwin or MSYS, switch paths to Windows format before running java
if "$cygwin" || "$msys" ; then
    APP_HOME=$( cygpath --path --mixed "$APP_HOME" )
    CLASSPATH=$( cygpath --path --mixed "$CLASSPATH" )

    JAVACMD=$( cygpath --unix "$JAVACMD" )

    # Now convert the arguments - kludge to limit ourselves to /bin/sh
    for arg do
        if
            case $arg in                                #(
              -*)   false ;;                            # don't mess with options #(
              /?*)  t=${arg#/} t=/${t%%/*}              # looks like a POSIX filepath
                    [ -e "$t" ] ;;                      #(
              *)    false ;;
            esac
        then
            arg=$( cygpath --path --ignore --mixed "$arg" )
        fi
        # Roll the args list around exactly as many times as the number of
        # args, so each arg winds up back in the position where it started, but
        # possibly modified.
        #
        # NB: a `for` loop captures its iteration list before it begins, so
        # changing the positional parameters here affects neither the number of
        # iterations, nor the values presented in `arg`.
        shift                   # remove old arg
        set -- "$@" "$arg"      # push replacement arg
    done
fi


# Add default JVM options here. You can also use JAVA_OPTS and GRADLE_OPTS to pass JVM options to this script.
DEFAULT_JVM_OPTS='"-Xmx64m" "-Xms64m"'

# Collect all arguments for the java command:
#   * DEFAULT_JVM_OPTS, JAVA_OPTS, and optsEnvironmentVar are not allowed to contain shell fragments,
#     and any embedded shellness will be escaped.
#   * For example: A user cannot expect ${Hostname} to be expanded, as it is an environment variable and will be
#     treated as '${Hostname}' itself on the command line.

set -- \
        "-Dorg.gradle.appname=$APP_BASE_NAME" \
        -classpath "$CLASSPATH" \
        -jar "$APP_HOME/gradle/wrapper/gradle-wrapper.jar" \
        "$@"

# Stop when "xargs" is not available.
if ! command -v xargs >/dev/null 2>&1
then
    die "xargs is not available"
fi

# Use "xargs" to parse quoted args.
#
# With -n1 it outputs one arg per line, with the quotes and backslashes removed.
#
# In Bash we could simply go:
#
#   readarray ARGS < <( xargs -n1 <<<"$var" ) &&
#   set -- "${ARGS[@]}" "$@"
#
# but POSIX shell has neither arrays nor command substitution, so instead we
# post-process each arg (as a line of input to sed) to backslash-escape any
# character that might be a shell metacharacter, then use eval to reverse
# that process (while maintaining the separation between arguments), and wrap
# the whole thing up as a single "set" statement.
#
# This will of course break if any of these variables contains a newline or
# an unmatched quote.
#

eval "set -- $(
        printf '%s\n' "$DEFAULT_JVM_OPTS $JAVA_OPTS $GRADLE_OPTS" |
        xargs -n1 |
        sed ' s~[^-[:alnum:]+,./:=@_]~\\&~g; ' |
        tr '\n' ' '
    )" '"$@"'

exec "$JAVACMD" "$@"

```

`gradlew.bat`:

```bat
@rem
@rem Copyright 2015 the original author or authors.
@rem
@rem Licensed under the Apache License, Version 2.0 (the "License");
@rem you may not use this file except in compliance with the License.
@rem You may obtain a copy of the License at
@rem
@rem      https://www.apache.org/licenses/LICENSE-2.0
@rem
@rem Unless required by applicable law or agreed to in writing, software
@rem distributed under the License is distributed on an "AS IS" BASIS,
@rem WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
@rem See the License for the specific language governing permissions and
@rem limitations under the License.
@rem
@rem SPDX-License-Identifier: Apache-2.0
@rem

@if "%DEBUG%"=="" @echo off
@rem ##########################################################################
@rem
@rem  Gradle startup script for Windows
@rem
@rem ##########################################################################

@rem Set local scope for the variables with windows NT shell
if "%OS%"=="Windows_NT" setlocal

set DIRNAME=%~dp0
if "%DIRNAME%"=="" set DIRNAME=.
@rem This is normally unused
set APP_BASE_NAME=%~n0
set APP_HOME=%DIRNAME%

@rem Resolve any "." and ".." in APP_HOME to make it shorter.
for %%i in ("%APP_HOME%") do set APP_HOME=%%~fi

@rem Add default JVM options here. You can also use JAVA_OPTS and GRADLE_OPTS to pass JVM options to this script.
set DEFAULT_JVM_OPTS="-Xmx64m" "-Xms64m"

@rem Find java.exe
if defined JAVA_HOME goto findJavaFromJavaHome

set JAVA_EXE=java.exe
%JAVA_EXE% -version >NUL 2>&1
if %ERRORLEVEL% equ 0 goto execute

echo. 1>&2
echo ERROR: JAVA_HOME is not set and no 'java' command could be found in your PATH. 1>&2
echo. 1>&2
echo Please set the JAVA_HOME variable in your environment to match the 1>&2
echo location of your Java installation. 1>&2

goto fail

:findJavaFromJavaHome
set JAVA_HOME=%JAVA_HOME:"=%
set JAVA_EXE=%JAVA_HOME%/bin/java.exe

if exist "%JAVA_EXE%" goto execute

echo. 1>&2
echo ERROR: JAVA_HOME is set to an invalid directory: %JAVA_HOME% 1>&2
echo. 1>&2
echo Please set the JAVA_HOME variable in your environment to match the 1>&2
echo location of your Java installation. 1>&2

goto fail

:execute
@rem Setup the command line

set CLASSPATH=


@rem Execute Gradle
"%JAVA_EXE%" %DEFAULT_JVM_OPTS% %JAVA_OPTS% %GRADLE_OPTS% "-Dorg.gradle.appname=%APP_BASE_NAME%" -classpath "%CLASSPATH%" -jar "%APP_HOME%\gradle\wrapper\gradle-wrapper.jar" %*

:end
@rem End local scope for the variables with windows NT shell
if %ERRORLEVEL% equ 0 goto mainEnd

:fail
rem Set variable GRADLE_EXIT_CONSOLE if you need the _script_ return code instead of
rem the _cmd.exe /c_ return code!
set EXIT_CODE=%ERRORLEVEL%
if %EXIT_CODE% equ 0 set EXIT_CODE=1
if not ""=="%GRADLE_EXIT_CONSOLE%" exit %EXIT_CODE%
exit /b %EXIT_CODE%

:mainEnd
if "%OS%"=="Windows_NT" endlocal

:omega

```

`module/META-INF/com/google/android/update-binary`:

```
#!/sbin/sh

#################
# Initialization
#################

umask 022

# echo before loading util_functions
ui_print() { echo "$1"; }

require_new_magisk() {
  ui_print "*******************************"
  ui_print " Please install Magisk v20.4+! "
  ui_print "*******************************"
  exit 1
}

#########################
# Load util_functions.sh
#########################

OUTFD=$2
ZIPFILE=$3

mount /data 2>/dev/null

[ -f /data/adb/magisk/util_functions.sh ] || require_new_magisk
. /data/adb/magisk/util_functions.sh
[ $MAGISK_VER_CODE -lt 20400 ] && require_new_magisk

install_module
exit 0

```

`module/META-INF/com/google/android/updater-script`:

```
#MAGISK

```

`module/customize.sh`:

```sh
# shellcheck disable=SC2034
SKIPUNZIP=1
MIN_SDK=29
CONFIG_DIR=/data/adb/tricky_store

# --- Installation Context Check ---
if [ "$BOOTMODE" != true ]; then
  ui_print "! Please install in Magisk Manager or KernelSU Manager"
  abort "! Install from recovery is NOT supported"
fi

if [ "$KSU" = true ] && [ "$KSU_VER_CODE" -lt 10670 ]; then
  abort "! Please update your KernelSU and KernelSU Manager"
fi

# --- Version Info ---
VERSION=$(grep_prop version "${TMPDIR}/module.prop")
ui_print "- Installing Tricky Store OSS $VERSION"
ui_print ""

# --- Architecture Handling ---
case "$ARCH" in
  arm64) ABI_DIR="arm64-v8a" ;;
  arm)   ABI_DIR="armeabi-v7a" ;;
  x64)   ABI_DIR="x86_64" ;;
  x86)   ABI_DIR="x86" ;;
  *)     abort "! Unsupported architecture: $ARCH" ;;
esac

ui_print "- Device platform: $ARCH"
ui_print "- Using ABI dir: $ABI_DIR"

# --- SDK Check ---
if [ "$API" -lt "$MIN_SDK" ]; then
  abort "! Unsupported SDK: $API. Minimum required is $MIN_SDK"
else
  ui_print "- Device SDK: $API"
fi
ui_print ""

# --- Helper to install files ---
install_file() {
  if ! unzip -qqjo "$ZIPFILE" "$1" -d "$2"; then
    abort "! Failed to extract $1"
  fi
  ui_print "- Extracted $1"
}

# --- Installation ---
ui_print "- Extracting module files"
for file in customize.sh module.prop post-fs-data.sh service.sh sepolicy.rule daemon; do
  install_file "$file" "$MODPATH"
done

# Handle service.apk or classes.dex
if unzip -l "$ZIPFILE" | grep -q "service.apk"; then
  install_file "service.apk" "$MODPATH"
elif unzip -l "$ZIPFILE" | grep -q "classes.dex"; then
  install_file "classes.dex" "$MODPATH"
else
  abort "! Neither service.apk nor classes.dex found"
fi

chmod 755 "$MODPATH/daemon"
ui_print ""


ui_print "- Extracting $ARCH libraries"
install_file "lib/$ABI_DIR/libTrickyStoreOSS.so" "$MODPATH"
install_file "lib/$ABI_DIR/libinject.so" "$MODPATH"
ui_print ""

mv "$MODPATH/libinject.so" "$MODPATH/inject"
chmod 755 "$MODPATH/inject"

# --- Configuration Files ---
if [ ! -d "$CONFIG_DIR" ]; then
  ui_print "- Creating configuration directory"
  mkdir -p "$CONFIG_DIR"
fi

if [ ! -f "$CONFIG_DIR/keybox.xml" ]; then
  ui_print "- Adding AOSP software keybox"
  install_file "keybox.xml" "$CONFIG_DIR"
fi

if [ ! -f "$CONFIG_DIR/target.txt" ]; then
  ui_print "- Adding default target scope"
  install_file "target.txt" "$CONFIG_DIR"
fi
```

`module/daemon`:

```
#!/system/bin/sh

MODDIR=$1

# Determine classpath
if [ -f "$MODDIR/classes.dex" ]; then
    CLASSPATH="$MODDIR/classes.dex"
elif [ -f "$MODDIR/service.apk" ]; then
    CLASSPATH="$MODDIR/service.apk"
else
    echo "Error: Neither classes.dex nor service.apk found in $MODDIR"
    exit 1
fi

exec /system/bin/app_process -Djava.class.path="$CLASSPATH" "$MODDIR" --nice-name=TrickyStoreOSS io.github.beakthoven.TrickyStoreOSS.MainKt

```

`module/keybox.xml`:

```xml
<?xml version="1.0"?>
<AndroidAttestation>
    <NumberOfKeyboxes>1</NumberOfKeyboxes>
    <Keybox DeviceID="sw">
        <Key algorithm="ecdsa">
            <PrivateKey format="pem">
                -----BEGIN EC PRIVATE KEY-----
                MHcCAQEEICHghkMqFRmEWc82OlD8FMnarfk19SfC39ceTW28QuVEoAoGCCqGSM49
                AwEHoUQDQgAE6555+EJjWazLKpFMiYbMcK2QZpOCqXMmE/6sy/ghJ0whdJdKKv6l
                uU1/ZtTgZRBmNbxTt6CjpnFYPts+Ea4QFA==
                -----END EC PRIVATE KEY-----
            </PrivateKey>
            <CertificateChain>
                <NumberOfCertificates>2</NumberOfCertificates>
                <Certificate format="pem">
                    -----BEGIN CERTIFICATE-----
                    MIICeDCCAh6gAwIBAgICEAEwCgYIKoZIzj0EAwIwgZgxCzAJBgNVBAYTAlVTMRMw
                    EQYDVQQIDApDYWxpZm9ybmlhMRYwFAYDVQQHDA1Nb3VudGFpbiBWaWV3MRUwEwYD
                    VQQKDAxHb29nbGUsIEluYy4xEDAOBgNVBAsMB0FuZHJvaWQxMzAxBgNVBAMMKkFu
                    ZHJvaWQgS2V5c3RvcmUgU29mdHdhcmUgQXR0ZXN0YXRpb24gUm9vdDAeFw0xNjAx
                    MTEwMDQ2MDlaFw0yNjAxMDgwMDQ2MDlaMIGIMQswCQYDVQQGEwJVUzETMBEGA1UE
                    CAwKQ2FsaWZvcm5pYTEVMBMGA1UECgwMR29vZ2xlLCBJbmMuMRAwDgYDVQQLDAdB
                    bmRyb2lkMTswOQYDVQQDDDJBbmRyb2lkIEtleXN0b3JlIFNvZnR3YXJlIEF0dGVz
                    dGF0aW9uIEludGVybWVkaWF0ZTBZMBMGByqGSM49AgEGCCqGSM49AwEHA0IABOue
                    efhCY1msyyqRTImGzHCtkGaTgqlzJhP+rMv4ISdMIXSXSir+pblNf2bU4GUQZjW8
                    U7ego6ZxWD7bPhGuEBSjZjBkMB0GA1UdDgQWBBQ//KzWGrE6noEguNUlHMVlux6R
                    qTAfBgNVHSMEGDAWgBTIrel3TEXDo88NFhDkeUM6IVowzzASBgNVHRMBAf8ECDAG
                    AQH/AgEAMA4GA1UdDwEB/wQEAwIChDAKBggqhkjOPQQDAgNIADBFAiBLipt77oK8
                    wDOHri/AiZi03cONqycqRZ9pDMfDktQPjgIhAO7aAV229DLp1IQ7YkyUBO86fMy9
                    Xvsiu+f+uXc/WT/7
                    -----END CERTIFICATE-----
                </Certificate>
                <Certificate format="pem">
                    -----BEGIN CERTIFICATE-----
                    MIICizCCAjKgAwIBAgIJAKIFntEOQ1tXMAoGCCqGSM49BAMCMIGYMQswCQYDVQQG
                    EwJVUzETMBEGA1UECAwKQ2FsaWZvcm5pYTEWMBQGA1UEBwwNTW91bnRhaW4gVmll
                    dzEVMBMGA1UECgwMR29vZ2xlLCBJbmMuMRAwDgYDVQQLDAdBbmRyb2lkMTMwMQYD
                    VQQDDCpBbmRyb2lkIEtleXN0b3JlIFNvZnR3YXJlIEF0dGVzdGF0aW9uIFJvb3Qw
                    HhcNMTYwMTExMDA0MzUwWhcNMzYwMTA2MDA0MzUwWjCBmDELMAkGA1UEBhMCVVMx
                    EzARBgNVBAgMCkNhbGlmb3JuaWExFjAUBgNVBAcMDU1vdW50YWluIFZpZXcxFTAT
                    BgNVBAoMDEdvb2dsZSwgSW5jLjEQMA4GA1UECwwHQW5kcm9pZDEzMDEGA1UEAwwq
                    QW5kcm9pZCBLZXlzdG9yZSBTb2Z0d2FyZSBBdHRlc3RhdGlvbiBSb290MFkwEwYH
                    KoZIzj0CAQYIKoZIzj0DAQcDQgAE7l1ex+HA220Dpn7mthvsTWpdamguD/9/SQ59
                    dx9EIm29sa/6FsvHrcV30lacqrewLVQBXT5DKyqO107sSHVBpKNjMGEwHQYDVR0O
                    BBYEFMit6XdMRcOjzw0WEOR5QzohWjDPMB8GA1UdIwQYMBaAFMit6XdMRcOjzw0W
                    EOR5QzohWjDPMA8GA1UdEwEB/wQFMAMBAf8wDgYDVR0PAQH/BAQDAgKEMAoGCCqG
                    SM49BAMCA0cAMEQCIDUho++LNEYenNVg8x1YiSBq3KNlQfYNns6KGYxmSGB7AiBN
                    C/NR2TB8fVvaNTQdqEcbY6WFZTytTySn502vQX3xvw==
                    -----END CERTIFICATE-----
                </Certificate>
            </CertificateChain>
        </Key>
        <Key algorithm="rsa">
            <PrivateKey format="pem">
                -----BEGIN RSA PRIVATE KEY-----
                MIICXQIBAAKBgQDAgyPcVogbuDAgafWwhWHG7r5/BeL1qEIEir6LR752/q7yXPKb
                KvoyABQWAUKZiaFfz8aBXrNjWDwv0vIL5Jgyg92BSxbX4YVBeuVKvClqOm21wAQI
                O2jFVsHwIzmRZBmGTVC3TUCuykhMdzVsiVoMJ1q/rEmdXX0jYvKcXgLocQIDAQAB
                AoGBAL6GCwuZqAKm+xpZQ4p7txUGWwmjbcbpysxr88AsNNfXnpTGYGQo2Ix7f2V3
                wc3qZAdKvo5yht8fCBHclygmCGjeldMu/Ja20IT/JxpfYN78xwPno45uKbqaPF/C
                woB2tqiWrx0014gozpvdsfNPnJQEQweBKY4gExZyW728mTpBAkEA4cbZJ2RsCRbs
                NoJtWUmDdAwh8bB0xKGlmGfGaXlchdPcRkxbkp6Uv7NODcxQFLEPEzQat/3V9gQU
                0qMmytQcxQJBANpIWZd4XNVjD7D9jFJU+Y5TjhiYOq6ea35qWntdNDdVuSGOvUAy
                DSg4fXifdvohi8wti2il9kGPu+ylF5qzr70CQFD+/DJklVlhbtZTThVFCTKdk6PY
                ENvlvbmCKSz3i9i624Agro1X9LcdBThv/p6dsnHKNHejSZnbdvjl7OnA1J0CQBW3
                TPJ8zv+Ls2vwTZ2DRrCaL3DS9EObDyasfgP36dH3fUuRX9KbKCPwOstdUgDghX/y
                qAPpPu6W1iNc6VRCvCECQQCQp0XaiXCyzWSWYDJCKMX4KFb/1mW6moXI1g8bi+5x
                fs0scurgHa2GunZU1M9FrbXx8rMdn4Eiz6XxpVcPmy0l
                -----END RSA PRIVATE KEY-----
            </PrivateKey>
            <CertificateChain>
                <NumberOfCertificates>2</NumberOfCertificates>
                <Certificate format="pem">
                    -----BEGIN CERTIFICATE-----
                    MIICtjCCAh+gAwIBAgICEAAwDQYJKoZIhvcNAQELBQAwYzELMAkGA1UEBhMCVVMx
                    EzARBgNVBAgMCkNhbGlmb3JuaWExFjAUBgNVBAcMDU1vdW50YWluIFZpZXcxFTAT
                    BgNVBAoMDEdvb2dsZSwgSW5jLjEQMA4GA1UECwwHQW5kcm9pZDAeFw0xNjAxMDQx
                    MjQwNTNaFw0zNTEyMzAxMjQwNTNaMHYxCzAJBgNVBAYTAlVTMRMwEQYDVQQIDApD
                    YWxpZm9ybmlhMRUwEwYDVQQKDAxHb29nbGUsIEluYy4xEDAOBgNVBAsMB0FuZHJv
                    aWQxKTAnBgNVBAMMIEFuZHJvaWQgU29mdHdhcmUgQXR0ZXN0YXRpb24gS2V5MIGf
                    MA0GCSqGSIb3DQEBAQUAA4GNADCBiQKBgQDAgyPcVogbuDAgafWwhWHG7r5/BeL1
                    qEIEir6LR752/q7yXPKbKvoyABQWAUKZiaFfz8aBXrNjWDwv0vIL5Jgyg92BSxbX
                    4YVBeuVKvClqOm21wAQIO2jFVsHwIzmRZBmGTVC3TUCuykhMdzVsiVoMJ1q/rEmd
                    XX0jYvKcXgLocQIDAQABo2YwZDAdBgNVHQ4EFgQU1AwQG/jNY7n3OVK1DhNcpteZ
                    k4YwHwYDVR0jBBgwFoAUKfrxrMxN0kyWQCd1trDpMuUH/i4wEgYDVR0TAQH/BAgw
                    BgEB/wIBADAOBgNVHQ8BAf8EBAMCAoQwDQYJKoZIhvcNAQELBQADgYEAni1IX4xn
                    M9waha2Z11Aj6hTsQ7DhnerCI0YecrUZ3GAi5KVoMWwLVcTmnKItnzpPk2sxixZ4
                    Fg2Iy9mLzICdhPDCJ+NrOPH90ecXcjFZNX2W88V/q52PlmEmT7K+gbsNSQQiis6f
                    9/VCLiVE+iEHElqDtVWtGIL4QBSbnCBjBH8=
                    -----END CERTIFICATE-----
                </Certificate>
                <Certificate format="pem">
                    -----BEGIN CERTIFICATE-----
                    MIICpzCCAhCgAwIBAgIJAP+U2d2fB8gMMA0GCSqGSIb3DQEBCwUAMGMxCzAJBgNV
                    BAYTAlVTMRMwEQYDVQQIDApDYWxpZm9ybmlhMRYwFAYDVQQHDA1Nb3VudGFpbiBW
                    aWV3MRUwEwYDVQQKDAxHb29nbGUsIEluYy4xEDAOBgNVBAsMB0FuZHJvaWQwHhcN
                    MTYwMTA0MTIzMTA4WhcNMzUxMjMwMTIzMTA4WjBjMQswCQYDVQQGEwJVUzETMBEG
                    A1UECAwKQ2FsaWZvcm5pYTEWMBQGA1UEBwwNTW91bnRhaW4gVmlldzEVMBMGA1UE
                    CgwMR29vZ2xlLCBJbmMuMRAwDgYDVQQLDAdBbmRyb2lkMIGfMA0GCSqGSIb3DQEB
                    AQUAA4GNADCBiQKBgQCia63rbi5EYe/VDoLmt5TRdSMfd5tjkWP/96r/C3JHTsAs
                    Q+wzfNes7UA+jCigZtX3hwszl94OuE4TQKuvpSe/lWmgMdsGUmX4RFlXYfC78hdL
                    t0GAZMAoDo9Sd47b0ke2RekZyOmLw9vCkT/X11DEHTVm+Vfkl5YLCazOkjWFmwID
                    AQABo2MwYTAdBgNVHQ4EFgQUKfrxrMxN0kyWQCd1trDpMuUH/i4wHwYDVR0jBBgw
                    FoAUKfrxrMxN0kyWQCd1trDpMuUH/i4wDwYDVR0TAQH/BAUwAwEB/zAOBgNVHQ8B
                    Af8EBAMCAoQwDQYJKoZIhvcNAQELBQADgYEAT3LzNlmNDsG5dFsxWfbwjSVJMJ6j
                    HBwp0kUtILlNX2S06IDHeHqcOd6os/W/L3BfRxBcxebrTQaZYdKumgf/93y4q+uc
                    DyQHXrF/unlx/U1bnt8Uqf7f7XzAiF343ZtkMlbVNZriE/mPzsF83O+kqrJVw4Op
                    Lvtc9mL1J1IXvmM=
                    -----END CERTIFICATE-----
                </Certificate>
            </CertificateChain>
        </Key>
    </Keybox>
</AndroidAttestation>

```

`module/module.prop`:

```prop
id=tricky_store
name=Tricky Store OSS
version=REPLACEMEVER
versionCode=REPLACEMEVERCODE
author=beakthoven
description=A trick of keystore but open source.
updateJson=https://raw.githubusercontent.com/beakthoven/TrickyStoreOSS/changelog/update.json

```

`module/post-fs-data.sh`:

```sh
MODDIR=${0%/*}

```

`module/sepolicy.rule`:

```rule
allow keystore system_file unix_dgram_socket *
allow system_file keystore unix_dgram_socket *
allow keystore system_file file *
allow crash_dump keystore process *

```

`module/service.sh`:

```sh
DEBUG=false

MODDIR=${0%/*}

cd $MODDIR

while true; do
  ./daemon "$MODDIR" || exit 1
  # ensure keystore initialized
  sleep 2
done &

```

`module/target.txt`:

```txt
com.android.vending
com.google.android.gms
io.github.vvb2060.keyattestation
io.github.vvb2060.mahoshojo
icu.nullptr.nativetest
com.reveny.nativecheck
com.zhenxi.hunter
io.github.qwq233.keyattestation
com.android.nativetest
io.liankong.riskdetector
luna.safe.luna

```

`settings.gradle.kts`:

```kts
/*
 * Copyright 2025 Dakkshesh <beakthoven@gmail.com>
 * SPDX-License-Identifier: GPL-3.0-or-later
 */

pluginManagement {
    repositories {
        google {
            content {
                includeGroupByRegex("com\\.android.*")
                includeGroupByRegex("com\\.google.*")
                includeGroupByRegex("androidx.*")
            }
        }
        mavenCentral()
        gradlePluginPortal()
    }
}
dependencyResolutionManagement {
    repositoriesMode.set(RepositoriesMode.FAIL_ON_PROJECT_REPOS)
    repositories {
        google()
        mavenCentral()
    }
}

rootProject.name = "Tricky Store OSS"
include(":app", ":stub")

```

`stub/build.gradle.kts`:

```kts
/*
 * Copyright 2025 Dakkshesh <beakthoven@gmail.com>
 * SPDX-License-Identifier: GPL-3.0-or-later
 */

plugins {
    alias(libs.plugins.android.library)
}


android {
    namespace = "io.github.beakthoven.stub"
    compileSdk = 36
    buildToolsVersion = "36.0.0"
    defaultConfig {
        minSdk = 29
    }

    buildTypes {
        release {
            isMinifyEnabled = false
        }
    }

    lint {
        checkReleaseBuilds = false
        abortOnError = true
    }
    compileOptions {
        sourceCompatibility = JavaVersion.VERSION_21
        targetCompatibility = JavaVersion.VERSION_21
    }
}

dependencies {
    compileOnly(libs.annotation)
}
```

`stub/src/main/AndroidManifest.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<!--
 Copyright 2025 Dakkshesh <beakthoven@gmail.com>
 SPDX-License-Identifier: GPL-3.0-or-later
-->

<manifest/>
```

`stub/src/main/java/android/app/ActivityThread.java`:

```java
/*
 * Copyright 2025 Dakkshesh <beakthoven@gmail.com>
 * SPDX-License-Identifier: GPL-3.0-or-later
 */

package android.app;

public class ActivityThread {
    public static void initializeMainlineModules() {
        throw new RuntimeException("");
    }
}
```

`stub/src/main/java/android/content/pm/BaseParceledListSlice.java`:

```java
/*
 * Copyright 2025 Dakkshesh <beakthoven@gmail.com>
 * SPDX-License-Identifier: GPL-3.0-or-later
 */

package android.content.pm;

import java.util.List;

abstract class BaseParceledListSlice<T> {

    public List<T> getList() {
        throw new RuntimeException("");
    }
}
```

`stub/src/main/java/android/content/pm/IPackageManager.java`:

```java
/*
 * Copyright 2025 Dakkshesh <beakthoven@gmail.com>
 * SPDX-License-Identifier: GPL-3.0-or-later
 */

package android.content.pm;

import android.os.IBinder;

public interface IPackageManager {
    String[] getPackagesForUid(int uid);

    PackageInfo getPackageInfo(String packageName, long flags, int userId);

    PackageInfo getPackageInfo(String packageName, int flags, int userId);

    ParceledListSlice<PackageInfo> getInstalledPackages(int flags, int userId);

    ParceledListSlice<PackageInfo> getInstalledPackages(long flags, int userId);

    class Stub {
        public static IPackageManager asInterface(IBinder binder) {
            throw new RuntimeException("");
        }
    }
}

```

`stub/src/main/java/android/content/pm/ParceledListSlice.java`:

```java
/*
 * Copyright 2025 Dakkshesh <beakthoven@gmail.com>
 * SPDX-License-Identifier: GPL-3.0-or-later
 */

package android.content.pm;

import java.util.List;

public class ParceledListSlice<T> extends BaseParceledListSlice<T> {

    public ParceledListSlice(List<T> list) {
        throw new RuntimeException("");
    }
}
```

`stub/src/main/java/android/hardware/security/keymint/Algorithm.java`:

```java
/*
 * Copyright 2025 Dakkshesh <beakthoven@gmail.com>
 * SPDX-License-Identifier: GPL-3.0-or-later
 */

package android.hardware.security.keymint;

public @interface Algorithm {
    int AES = 32;
    int EC = 3;
    int HMAC = 128;
    int RSA = 1;
    int TRIPLE_DES = 33;
}

```

`stub/src/main/java/android/hardware/security/keymint/EcCurve.java`:

```java
/*
 * Copyright 2025 Dakkshesh <beakthoven@gmail.com>
 * SPDX-License-Identifier: GPL-3.0-or-later
 */

package android.hardware.security.keymint;

/* loaded from: classes2.dex */
public @interface EcCurve {
    public static final int CURVE_25519 = 4;
    public static final int P_224 = 0;
    public static final int P_256 = 1;
    public static final int P_384 = 2;
    public static final int P_521 = 3;
}

```

`stub/src/main/java/android/hardware/security/keymint/KeyParameter.java`:

```java
/*
 * Copyright 2025 Dakkshesh <beakthoven@gmail.com>
 * SPDX-License-Identifier: GPL-3.0-or-later
 */

package android.hardware.security.keymint;

import android.os.Parcel;
import android.os.Parcelable;

import androidx.annotation.NonNull;

public class KeyParameter implements Parcelable {
    public static final Creator<KeyParameter> CREATOR = new Creator<>() {
        @Override
        public KeyParameter createFromParcel(Parcel in) {
            throw new RuntimeException();
        }

        @Override
        public KeyParameter[] newArray(int size) {
            throw new RuntimeException();
        }
    };
    public int tag = 0;
    public KeyParameterValue value;

    @Override
    public int describeContents() {
        throw new RuntimeException();
    }

    @Override
    public void writeToParcel(@NonNull Parcel parcel, int i) {
        throw new RuntimeException();
    }
}

```

`stub/src/main/java/android/hardware/security/keymint/KeyParameterValue.java`:

```java
/*
 * Copyright 2025 Dakkshesh <beakthoven@gmail.com>
 * SPDX-License-Identifier: GPL-3.0-or-later
 */

package android.hardware.security.keymint;

import android.os.Parcel;
import android.os.Parcelable;

import androidx.annotation.NonNull;

/* loaded from: classes2.dex */
public final class KeyParameterValue implements Parcelable {
    public static final int algorithm = 1;
    public static final int blob = 14;
    public static final int blockMode = 2;
    public static final int boolValue = 10;
    public static final int dateTime = 13;
    public static final int digest = 4;
    public static final int ecCurve = 5;
    public static final int hardwareAuthenticatorType = 8;
    public static final int integer = 11;
    public static final int invalid = 0;
    public static final int keyPurpose = 7;
    public static final int longInteger = 12;
    public static final int origin = 6;
    public static final int paddingMode = 3;
    public static final int securityLevel = 9;
    public static final Creator<KeyParameterValue> CREATOR = new Creator<KeyParameterValue>() {
        @Override
        public KeyParameterValue createFromParcel(Parcel in) {
            throw new RuntimeException();
        }

        @Override
        public KeyParameterValue[] newArray(int size) {
            throw new RuntimeException();
        }
    };

    public KeyParameterValue() {
        throw new RuntimeException();
    }

    protected KeyParameterValue(Parcel in) {
        throw new RuntimeException();
    }

    public static KeyParameterValue invalid(int _value) {
        throw new RuntimeException();
    }

    public static KeyParameterValue algorithm(int _value) {
        throw new RuntimeException();
    }

    public static KeyParameterValue blockMode(int _value) {
        throw new RuntimeException();
    }

    public static KeyParameterValue paddingMode(int _value) {
        throw new RuntimeException();
    }

    public static KeyParameterValue digest(int _value) {
        throw new RuntimeException();
    }

    public static KeyParameterValue ecCurve(int _value) {
        throw new RuntimeException();
    }

    public static KeyParameterValue origin(int _value) {
        throw new RuntimeException();
    }

    public static KeyParameterValue keyPurpose(int _value) {
        throw new RuntimeException();
    }

    public static KeyParameterValue hardwareAuthenticatorType(int _value) {
        throw new RuntimeException();
    }

    public static KeyParameterValue securityLevel(int _value) {
        throw new RuntimeException();
    }

    public static KeyParameterValue boolValue(boolean _value) {
        throw new RuntimeException();
    }

    public static KeyParameterValue integer(int _value) {
        throw new RuntimeException();
    }

    public static KeyParameterValue longInteger(long _value) {
        throw new RuntimeException();
    }

    public static KeyParameterValue dateTime(long _value) {
        throw new RuntimeException();
    }

    public static KeyParameterValue blob(byte[] _value) {
        throw new RuntimeException();
    }

    public int getTag() {
        throw new RuntimeException();
    }

    public int getInvalid() {
        throw new RuntimeException();
    }

    public void setInvalid(int _value) {
        throw new RuntimeException();
    }

    public int getAlgorithm() {
        throw new RuntimeException();
    }

    public void setAlgorithm(int _value) {
        throw new RuntimeException();
    }

    public int getBlockMode() {
        throw new RuntimeException();
    }

    public void setBlockMode(int _value) {
        throw new RuntimeException();
    }

    public int getPaddingMode() {
        throw new RuntimeException();
    }

    public void setPaddingMode(int _value) {
        throw new RuntimeException();
    }

    public int getDigest() {
        throw new RuntimeException();
    }

    public void setDigest(int _value) {
        throw new RuntimeException();
    }

    public int getEcCurve() {
        throw new RuntimeException();
    }

    public void setEcCurve(int _value) {
        throw new RuntimeException();
    }

    public int getOrigin() {
        throw new RuntimeException();
    }

    public void setOrigin(int _value) {
        throw new RuntimeException();
    }

    public int getKeyPurpose() {
        throw new RuntimeException();
    }

    public void setKeyPurpose(int _value) {
        throw new RuntimeException();
    }

    public int getHardwareAuthenticatorType() {
        throw new RuntimeException();
    }

    public void setHardwareAuthenticatorType(int _value) {
        throw new RuntimeException();
    }

    public int getSecurityLevel() {
        throw new RuntimeException();
    }

    public void setSecurityLevel(int _value) {
        throw new RuntimeException();
    }

    public boolean getBoolValue() {
        throw new RuntimeException();
    }

    public void setBoolValue(boolean _value) {
        throw new RuntimeException();
    }

    public int getInteger() {
        throw new RuntimeException();
    }

    public void setInteger(int _value) {
        throw new RuntimeException();
    }

    public long getLongInteger() {
        throw new RuntimeException();
    }

    public void setLongInteger(long _value) {
        throw new RuntimeException();
    }

    public long getDateTime() {
        throw new RuntimeException();
    }

    public void setDateTime(long _value) {
        throw new RuntimeException();
    }

    public byte[] getBlob() {
        throw new RuntimeException();
    }

    public void setBlob(byte[] _value) {
        throw new RuntimeException();
    }

    @Override
    public int describeContents() {
        throw new RuntimeException();
    }

    @Override
    public void writeToParcel(@NonNull Parcel parcel, int i) {
        throw new RuntimeException();
    }
}

```

`stub/src/main/java/android/hardware/security/keymint/KeyPurpose.java`:

```java
/*
 * Copyright 2025 Dakkshesh <beakthoven@gmail.com>
 * SPDX-License-Identifier: GPL-3.0-or-later
 */

package android.hardware.security.keymint;

public @interface KeyPurpose {
    int AGREE_KEY = 6;
    int ATTEST_KEY = 7;
    int DECRYPT = 1;
    int ENCRYPT = 0;
    int SIGN = 2;
    int VERIFY = 3;
    int WRAP_KEY = 5;
}

```

`stub/src/main/java/android/hardware/security/keymint/SecurityLevel.java`:

```java
/*
 * Copyright 2025 Dakkshesh <beakthoven@gmail.com>
 * SPDX-License-Identifier: GPL-3.0-or-later
 */

package android.hardware.security.keymint;

public @interface SecurityLevel {
    int KEYSTORE = 100;
    int SOFTWARE = 0;
    int STRONGBOX = 2;
    int TRUSTED_ENVIRONMENT = 1;
}

```

`stub/src/main/java/android/hardware/security/keymint/Tag.java`:

```java
/*
 * Copyright 2025 Dakkshesh <beakthoven@gmail.com>
 * SPDX-License-Identifier: GPL-3.0-or-later
 */

package android.hardware.security.keymint;

public @interface Tag {
    int INVALID = 0;
    int PURPOSE = 536870913;
    int ALGORITHM = 268435458;
    int KEY_SIZE = 805306371;
    int BLOCK_MODE = 536870916;
    int DIGEST = 536870917;
    int PADDING = 536870918;
    int CALLER_NONCE = 1879048199;
    int MIN_MAC_LENGTH = 805306376;
    int EC_CURVE = 268435466;
    int RSA_PUBLIC_EXPONENT = 1342177480;
    int INCLUDE_UNIQUE_ID = 1879048394;
    int RSA_OAEP_MGF_DIGEST = 536871115;
    int BOOTLOADER_ONLY = 1879048494;
    int ROLLBACK_RESISTANCE = 1879048495;
    int HARDWARE_TYPE = 268435760;
    int EARLY_BOOT_ONLY = 1879048497;
    int ACTIVE_DATETIME = 1610613136;
    int ORIGINATION_EXPIRE_DATETIME = 1610613137;
    int USAGE_EXPIRE_DATETIME = 1610613138;
    int MIN_SECONDS_BETWEEN_OPS = 805306771;
    int MAX_USES_PER_BOOT = 805306772;
    int USAGE_COUNT_LIMIT = 805306773;
    int USER_ID = 805306869;
    int USER_SECURE_ID = -1610612234;
    int NO_AUTH_REQUIRED = 1879048695;
    int USER_AUTH_TYPE = 268435960;
    int AUTH_TIMEOUT = 805306873;
    int ALLOW_WHILE_ON_BODY = 1879048698;
    int TRUSTED_USER_PRESENCE_REQUIRED = 1879048699;
    int TRUSTED_CONFIRMATION_REQUIRED = 1879048700;
    int UNLOCKED_DEVICE_REQUIRED = 1879048701;
    int APPLICATION_ID = -1879047591;
    int APPLICATION_DATA = -1879047492;
    int CREATION_DATETIME = 1610613437;
    int ORIGIN = 268436158;
    int ROOT_OF_TRUST = -1879047488;
    int OS_VERSION = 805307073;
    int OS_PATCHLEVEL = 805307074;
    int UNIQUE_ID = -1879047485;
    int ATTESTATION_CHALLENGE = -1879047484;
    int ATTESTATION_APPLICATION_ID = -1879047483;
    int ATTESTATION_ID_BRAND = -1879047482;
    int ATTESTATION_ID_DEVICE = -1879047481;
    int ATTESTATION_ID_PRODUCT = -1879047480;
    int ATTESTATION_ID_SERIAL = -1879047479;
    int ATTESTATION_ID_IMEI = -1879047478;
    int ATTESTATION_ID_MEID = -1879047477;
    int ATTESTATION_ID_MANUFACTURER = -1879047476;
    int ATTESTATION_ID_MODEL = -1879047475;
    int VENDOR_PATCHLEVEL = 805307086;
    int BOOT_PATCHLEVEL = 805307087;
    int DEVICE_UNIQUE_ATTESTATION = 1879048912;
    int IDENTITY_CREDENTIAL_KEY = 1879048913;
    int STORAGE_KEY = 1879048914;
    int ATTESTATION_ID_SECOND_IMEI = -1879047469;
    int ASSOCIATED_DATA = -1879047192;
    int NONCE = -1879047191;
    int MAC_LENGTH = 805307371;
    int RESET_SINCE_ID_ROTATION = 1879049196;
    int CONFIRMATION_TOKEN = -1879047187;
    int CERTIFICATE_SERIAL = -2147482642;
    int CERTIFICATE_SUBJECT = -1879047185;
    int CERTIFICATE_NOT_BEFORE = 1610613744;
    int CERTIFICATE_NOT_AFTER = 1610613745;
    int MAX_BOOT_LEVEL = 805307378;
}
```

`stub/src/main/java/android/os/ServiceManager.java`:

```java
/*
 * Copyright 2025 Dakkshesh <beakthoven@gmail.com>
 * SPDX-License-Identifier: GPL-3.0-or-later
 */

package android.os;

public class ServiceManager {
    public static IBinder getService(String name) {
        throw new UnsupportedOperationException("");
    }

    public static IBinder waitForService(String name) {
        throw new UnsupportedOperationException("");
    }

    public static void addService(String name, IBinder binder) {
        throw new UnsupportedOperationException("");
    }

    public static IBinder checkService(String name) {
        throw new UnsupportedOperationException("");
    }

    public static String[] listServices() {
        throw new UnsupportedOperationException("");
    }
}

```

`stub/src/main/java/android/os/SystemProperties.java`:

```java
/*
 * Copyright 2025 Dakkshesh <beakthoven@gmail.com>
 * SPDX-License-Identifier: GPL-3.0-or-later
 */

package android.os;

public class SystemProperties {
    public static String get(String key, String def) {
        throw new RuntimeException("");
    }

    public static void set(String key, String val) {
        throw new RuntimeException("");
    }
}

```

`stub/src/main/java/android/security/Credentials.java`:

```java
/*
 * Copyright 2025 Dakkshesh <beakthoven@gmail.com>
 * SPDX-License-Identifier: GPL-3.0-or-later
 */

package android.security;

public class Credentials {
    public static final String APP_SOURCE_CERTIFICATE = "FSV_";
    public static final String CA_CERTIFICATE = "CACERT_";
    public static final String CERTIFICATE_USAGE_APP_SOURCE = "appsrc";
    public static final String CERTIFICATE_USAGE_CA = "ca";
    public static final String CERTIFICATE_USAGE_USER = "user";
    public static final String CERTIFICATE_USAGE_WIFI = "wifi";
    public static final String EXTENSION_CER = ".cer";
    public static final String EXTENSION_CRT = ".crt";
    public static final String EXTENSION_P12 = ".p12";
    public static final String EXTENSION_PFX = ".pfx";
    public static final String EXTRA_CA_CERTIFICATES_DATA = "ca_certificates_data";
    public static final String EXTRA_CERTIFICATE_USAGE = "certificate_install_usage";
    public static final String EXTRA_INSTALL_AS_UID = "install_as_uid";
    public static final String EXTRA_PRIVATE_KEY = "PKEY";
    public static final String EXTRA_PUBLIC_KEY = "KEY";
    public static final String EXTRA_USER_CERTIFICATE_DATA = "user_certificate_data";
    public static final String EXTRA_USER_KEY_ALIAS = "user_key_pair_name";
    public static final String EXTRA_USER_PRIVATE_KEY_DATA = "user_private_key_data";
    public static final String INSTALL_ACTION = "android.credentials.INSTALL";
    public static final String INSTALL_AS_USER_ACTION = "android.credentials.INSTALL_AS_USER";
    public static final String LOCKDOWN_VPN = "LOCKDOWN_VPN";
    private static final String LOGTAG = "Credentials";
    public static final String PLATFORM_VPN = "PLATFORM_VPN_";
    public static final String USER_CERTIFICATE = "USRCERT_";
    public static final String USER_PRIVATE_KEY = "USRPKEY_";
    public static final String USER_SECRET_KEY = "USRSKEY_";
    public static final String VPN = "VPN_";
    public static final String WIFI = "WIFI_";

}

```

`stub/src/main/java/android/security/KeyStore.java`:

```java
/*
 * Copyright 2025 Dakkshesh <beakthoven@gmail.com>
 * SPDX-License-Identifier: GPL-3.0-or-later
 */

package android.security;

public class KeyStore {
    public static final int CANNOT_ATTEST_IDS = -66;
    public static final int CONFIRMATIONUI_ABORTED = 2;
    public static final int CONFIRMATIONUI_CANCELED = 1;
    public static final int CONFIRMATIONUI_IGNORED = 4;
    public static final int CONFIRMATIONUI_OK = 0;
    public static final int CONFIRMATIONUI_OPERATION_PENDING = 3;
    public static final int CONFIRMATIONUI_SYSTEM_ERROR = 5;
    public static final int CONFIRMATIONUI_UIERROR = 65536;
    public static final int CONFIRMATIONUI_UIERROR_MALFORMED_UTF8_ENCODING = 65539;
    public static final int CONFIRMATIONUI_UIERROR_MESSAGE_TOO_LONG = 65538;
    public static final int CONFIRMATIONUI_UIERROR_MISSING_GLYPH = 65537;
    public static final int CONFIRMATIONUI_UNEXPECTED = 7;
    public static final int CONFIRMATIONUI_UNIMPLEMENTED = 6;
    public static final int FLAG_CRITICAL_TO_DEVICE_ENCRYPTION = 8;
    public static final int FLAG_ENCRYPTED = 1;
    public static final int FLAG_NONE = 0;
    public static final int FLAG_SOFTWARE = 2;
    public static final int FLAG_STRONGBOX = 16;
    public static final int HARDWARE_TYPE_UNAVAILABLE = -68;
    public static final int KEY_ALREADY_EXISTS = 16;
    public static final int KEY_NOT_FOUND = 7;
    public static final int KEY_PERMANENTLY_INVALIDATED = 17;
    public static final int LOCKED = 2;
    public static final int NO_ERROR = 1;
    public static final int OP_AUTH_NEEDED = 15;
    public static final int PERMISSION_DENIED = 6;
    public static final int PROTOCOL_ERROR = 5;
    public static final int SYSTEM_ERROR = 4;
    private static final String TAG = "KeyStore";
    public static final int UID_SELF = -1;
    public static final int UNDEFINED_ACTION = 9;
    public static final int UNINITIALIZED = 3;
    public static final int VALUE_CORRUPTED = 8;
    public static final int WRONG_PASSWORD = 10;
}

```

`stub/src/main/java/android/security/keymaster/ExportResult.java`:

```java
/*
 * Copyright 2025 Dakkshesh <beakthoven@gmail.com>
 * SPDX-License-Identifier: GPL-3.0-or-later
 */

package android.security.keymaster;

import android.os.Parcel;
import android.os.Parcelable;

import androidx.annotation.NonNull;

public class ExportResult implements Parcelable {
    public final byte[] exportData;
    public final int resultCode;

    public ExportResult(int resultCode) {
        this.resultCode = resultCode;
        this.exportData = new byte[0];
    }

    @Override
    public void writeToParcel(@NonNull Parcel dest, int flags) {
        throw new RuntimeException("");
    }

    @Override
    public int describeContents() {
        throw new RuntimeException("");
    }

    public static final Creator<ExportResult> CREATOR = new Creator<ExportResult>() {
        @Override
        public ExportResult createFromParcel(Parcel in) {
            throw new RuntimeException("");
        }

        @Override
        public ExportResult[] newArray(int size) {
            throw new RuntimeException("");
        }
    };
}

```

`stub/src/main/java/android/security/keymaster/KeyCharacteristics.java`:

```java
/*
 * Copyright 2025 Dakkshesh <beakthoven@gmail.com>
 * SPDX-License-Identifier: GPL-3.0-or-later
 */

package android.security.keymaster;

import android.os.Parcel;
import android.os.Parcelable;

import androidx.annotation.NonNull;

public class KeyCharacteristics implements Parcelable {
    public KeymasterArguments hwEnforced;
    public KeymasterArguments swEnforced;

    @Override
    public void writeToParcel(@NonNull Parcel dest, int flags) {
        throw new RuntimeException("");
    }

    @Override
    public int describeContents() {
        throw new RuntimeException("");
    }

    public static final Creator<KeyCharacteristics> CREATOR = new Creator<KeyCharacteristics>() {
        @Override
        public KeyCharacteristics createFromParcel(Parcel in) {
            throw new RuntimeException("");
        }

        @Override
        public KeyCharacteristics[] newArray(int size) {
            throw new RuntimeException("");
        }
    };
}

```

`stub/src/main/java/android/security/keymaster/KeymasterArgument.java`:

```java
/*
 * Copyright 2025 Dakkshesh <beakthoven@gmail.com>
 * SPDX-License-Identifier: GPL-3.0-or-later
 */

package android.security.keymaster;

import android.os.Parcel;
import android.os.Parcelable;

import androidx.annotation.NonNull;

abstract class KeymasterArgument implements Parcelable {
    public final int tag;

    protected KeymasterArgument(int tag) {
        this.tag = tag;
    }

    @Override
    public void writeToParcel(@NonNull Parcel dest, int flags) {
        throw new RuntimeException("");
    }

    @Override
    public int describeContents() {
        throw new RuntimeException("");
    }

    public static final Creator<KeymasterArgument> CREATOR = new Creator<KeymasterArgument>() {
        @Override
        public KeymasterArgument createFromParcel(Parcel in) {
            throw new RuntimeException("");
        }

        @Override
        public KeymasterArgument[] newArray(int size) {
            throw new RuntimeException("");
        }
    };
}

```

`stub/src/main/java/android/security/keymaster/KeymasterArguments.java`:

```java
/*
 * Copyright 2025 Dakkshesh <beakthoven@gmail.com>
 * SPDX-License-Identifier: GPL-3.0-or-later
 */

package android.security.keymaster;

import android.os.Parcel;
import android.os.Parcelable;

import androidx.annotation.NonNull;

import java.math.BigInteger;
import java.util.Date;
import java.util.List;

public class KeymasterArguments implements Parcelable {

    private static final long UINT32_RANGE = 1L << 32;
    public static final long UINT32_MAX_VALUE = UINT32_RANGE - 1;

    private static final BigInteger UINT64_RANGE = BigInteger.ONE.shiftLeft(64);
    public static final BigInteger UINT64_MAX_VALUE = UINT64_RANGE.subtract(BigInteger.ONE);

    private List<KeymasterArgument> mArguments;

    public static final @NonNull Parcelable.Creator<KeymasterArguments> CREATOR = new Parcelable.Creator<KeymasterArguments>() {
        @Override
        public KeymasterArguments createFromParcel(Parcel in) {
            throw new RuntimeException("");
        }

        @Override
        public KeymasterArguments[] newArray(int size) {
            throw new RuntimeException("");
        }
    };

    public KeymasterArguments() {
        throw new RuntimeException("");
    }

    private KeymasterArguments(Parcel in) {
        throw new RuntimeException("");
    }

    public void addEnum(int tag, int value) {
        throw new RuntimeException("");
    }

    public void addEnums(int tag, int... values) {
        throw new RuntimeException("");
    }

    public int getEnum(int tag, int defaultValue) {
        throw new RuntimeException("");
    }

    public List<Integer> getEnums(int tag) {
        throw new RuntimeException("");
    }

    private void addEnumTag(int tag, int value) {
        throw new RuntimeException("");
    }

    private int getEnumTagValue(KeymasterArgument arg) {
        throw new RuntimeException("");
    }

    public void addUnsignedInt(int tag, long value) {
        throw new RuntimeException("");
    }

    public long getUnsignedInt(int tag, long defaultValue) {
        throw new RuntimeException("");
    }

    public void addUnsignedLong(int tag, BigInteger value) {
        throw new RuntimeException("");
    }

    public List<BigInteger> getUnsignedLongs(int tag) {
        throw new RuntimeException("");
    }

    private void addLongTag(int tag, BigInteger value) {
        throw new RuntimeException("");
    }

    private BigInteger getLongTagValue(KeymasterArgument arg) {
        throw new RuntimeException("");
    }

    public void addBoolean(int tag) {
        throw new RuntimeException("");
    }

    public boolean getBoolean(int tag) {
        throw new RuntimeException("");
    }

    public void addBytes(int tag, byte[] value) {
        throw new RuntimeException("");
    }

    public byte[] getBytes(int tag, byte[] defaultValue) {
        throw new RuntimeException("");
    }

    public void addDate(int tag, Date value) {
        throw new RuntimeException("");
    }

    public void addDateIfNotNull(int tag, Date value) {
        throw new RuntimeException("");
    }

    public Date getDate(int tag, Date defaultValue) {
        throw new RuntimeException("");
    }

    private KeymasterArgument getArgumentByTag(int tag) {
        throw new RuntimeException("");
    }

    public boolean containsTag(int tag) {
        throw new RuntimeException("");
    }

    public int size() {
        throw new RuntimeException("");
    }

    @Override
    public void writeToParcel(Parcel out, int flags) {
        throw new RuntimeException("");
    }

    public void readFromParcel(Parcel in) {
        throw new RuntimeException("");
    }

    @Override
    public int describeContents() {
        throw new RuntimeException("");
    }

    public static BigInteger toUint64(long value) {
        throw new RuntimeException("");
    }
}
```

`stub/src/main/java/android/security/keymaster/KeymasterCertificateChain.java`:

```java
/*
 * Copyright 2025 Dakkshesh <beakthoven@gmail.com>
 * SPDX-License-Identifier: GPL-3.0-or-later
 */

package android.security.keymaster;

import android.os.Parcel;
import android.os.Parcelable;

import androidx.annotation.NonNull;

import java.util.List;

public class KeymasterCertificateChain implements Parcelable {
    private List<byte[]> mCertificates;

    public KeymasterCertificateChain() {
        this.mCertificates = null;
    }

    public KeymasterCertificateChain(List<byte[]> mCertificates) {
        this.mCertificates = mCertificates;
    }

    @Override
    public void writeToParcel(@NonNull Parcel dest, int flags) {
        throw new RuntimeException("");
    }

    @Override
    public int describeContents() {
        throw new RuntimeException("");
    }

    public static final Creator<KeymasterCertificateChain> CREATOR = new Creator<KeymasterCertificateChain>() {
        @Override
        public KeymasterCertificateChain createFromParcel(Parcel in) {
            throw new RuntimeException("");
        }

        @Override
        public KeymasterCertificateChain[] newArray(int size) {
            throw new RuntimeException("");
        }
    };
}

```

`stub/src/main/java/android/security/keymaster/KeymasterDefs.java`:

```java
/*
 * Copyright 2025 Dakkshesh <beakthoven@gmail.com>
 * SPDX-License-Identifier: GPL-3.0-or-later
 */

package android.security.keymaster;

import java.util.HashMap;
import java.util.Map;

public final class KeymasterDefs {

    private KeymasterDefs() {
    }

    // Tag types.
    public static final int KM_INVALID = 0 << 28;
    public static final int KM_ENUM = 1 << 28;
    public static final int KM_ENUM_REP = 2 << 28;
    public static final int KM_UINT = 3 << 28;
    public static final int KM_UINT_REP = 4 << 28;
    public static final int KM_ULONG = 5 << 28;
    public static final int KM_DATE = 6 << 28;
    public static final int KM_BOOL = 7 << 28;
    public static final int KM_BIGNUM = 8 << 28;
    public static final int KM_BYTES = 9 << 28;
    public static final int KM_ULONG_REP = 10 << 28;

    // Tag values.
    public static final int KM_TAG_INVALID = KM_INVALID | 0;
    public static final int KM_TAG_PURPOSE = KM_ENUM_REP | 1;
    public static final int KM_TAG_ALGORITHM = KM_ENUM | 2;
    public static final int KM_TAG_KEY_SIZE = KM_UINT | 3;
    public static final int KM_TAG_BLOCK_MODE = KM_ENUM_REP | 4;
    public static final int KM_TAG_DIGEST = KM_ENUM_REP | 5;
    public static final int KM_TAG_PADDING = KM_ENUM_REP | 6;
    public static final int KM_TAG_CALLER_NONCE = KM_BOOL | 7;
    public static final int KM_TAG_MIN_MAC_LENGTH = KM_UINT | 8;

    public static final int KM_TAG_RESCOPING_ADD = KM_ENUM_REP | 101;
    public static final int KM_TAG_RESCOPING_DEL = KM_ENUM_REP | 102;
    public static final int KM_TAG_BLOB_USAGE_REQUIREMENTS = KM_ENUM | 705;

    public static final int KM_TAG_RSA_PUBLIC_EXPONENT = KM_ULONG | 200;
    public static final int KM_TAG_INCLUDE_UNIQUE_ID = KM_BOOL | 202;

    public static final int KM_TAG_ACTIVE_DATETIME = KM_DATE | 400;
    public static final int KM_TAG_ORIGINATION_EXPIRE_DATETIME = KM_DATE | 401;
    public static final int KM_TAG_USAGE_EXPIRE_DATETIME = KM_DATE | 402;
    public static final int KM_TAG_MIN_SECONDS_BETWEEN_OPS = KM_UINT | 403;
    public static final int KM_TAG_MAX_USES_PER_BOOT = KM_UINT | 404;

    public static final int KM_TAG_ALL_USERS = KM_BOOL | 500;
    public static final int KM_TAG_USER_ID = KM_UINT | 501;
    public static final int KM_TAG_USER_SECURE_ID = KM_ULONG_REP | 502;
    public static final int KM_TAG_NO_AUTH_REQUIRED = KM_BOOL | 503;
    public static final int KM_TAG_USER_AUTH_TYPE = KM_ENUM | 504;
    public static final int KM_TAG_AUTH_TIMEOUT = KM_UINT | 505;
    public static final int KM_TAG_ALLOW_WHILE_ON_BODY = KM_BOOL | 506;
    public static final int KM_TAG_TRUSTED_USER_PRESENCE_REQUIRED = KM_BOOL | 507;
    public static final int KM_TAG_TRUSTED_CONFIRMATION_REQUIRED = KM_BOOL | 508;
    public static final int KM_TAG_UNLOCKED_DEVICE_REQUIRED = KM_BOOL | 509;

    public static final int KM_TAG_ALL_APPLICATIONS = KM_BOOL | 600;
    public static final int KM_TAG_APPLICATION_ID = KM_BYTES | 601;

    public static final int KM_TAG_CREATION_DATETIME = KM_DATE | 701;
    public static final int KM_TAG_ORIGIN = KM_ENUM | 702;
    public static final int KM_TAG_ROLLBACK_RESISTANT = KM_BOOL | 703;
    public static final int KM_TAG_ROOT_OF_TRUST = KM_BYTES | 704;
    public static final int KM_TAG_UNIQUE_ID = KM_BYTES | 707;
    public static final int KM_TAG_ATTESTATION_CHALLENGE = KM_BYTES | 708;
    public static final int KM_TAG_ATTESTATION_ID_BRAND = KM_BYTES | 710;
    public static final int KM_TAG_ATTESTATION_ID_DEVICE = KM_BYTES | 711;
    public static final int KM_TAG_ATTESTATION_ID_PRODUCT = KM_BYTES | 712;
    public static final int KM_TAG_ATTESTATION_ID_SERIAL = KM_BYTES | 713;
    public static final int KM_TAG_ATTESTATION_ID_IMEI = KM_BYTES | 714;
    public static final int KM_TAG_ATTESTATION_ID_MEID = KM_BYTES | 715;
    public static final int KM_TAG_ATTESTATION_ID_MANUFACTURER = KM_BYTES | 716;
    public static final int KM_TAG_ATTESTATION_ID_MODEL = KM_BYTES | 717;
    public static final int KM_TAG_DEVICE_UNIQUE_ATTESTATION = KM_BOOL | 720;

    public static final int KM_TAG_ASSOCIATED_DATA = KM_BYTES | 1000;
    public static final int KM_TAG_NONCE = KM_BYTES | 1001;
    public static final int KM_TAG_AUTH_TOKEN = KM_BYTES | 1002;
    public static final int KM_TAG_MAC_LENGTH = KM_UINT | 1003;

    // Algorithm values.
    public static final int KM_ALGORITHM_RSA = 1;
    public static final int KM_ALGORITHM_EC = 3;
    public static final int KM_ALGORITHM_AES = 32;
    public static final int KM_ALGORITHM_3DES = 33;
    public static final int KM_ALGORITHM_HMAC = 128;

    // Block modes.
    public static final int KM_MODE_ECB = 1;
    public static final int KM_MODE_CBC = 2;
    public static final int KM_MODE_CTR = 3;
    public static final int KM_MODE_GCM = 32;

    // Padding modes.
    public static final int KM_PAD_NONE = 1;
    public static final int KM_PAD_RSA_OAEP = 2;
    public static final int KM_PAD_RSA_PSS = 3;
    public static final int KM_PAD_RSA_PKCS1_1_5_ENCRYPT = 4;
    public static final int KM_PAD_RSA_PKCS1_1_5_SIGN = 5;
    public static final int KM_PAD_PKCS7 = 64;

    // Digest modes.
    public static final int KM_DIGEST_NONE = 0;
    public static final int KM_DIGEST_MD5 = 1;
    public static final int KM_DIGEST_SHA1 = 2;
    public static final int KM_DIGEST_SHA_2_224 = 3;
    public static final int KM_DIGEST_SHA_2_256 = 4;
    public static final int KM_DIGEST_SHA_2_384 = 5;
    public static final int KM_DIGEST_SHA_2_512 = 6;

    // Key origins.
    public static final int KM_ORIGIN_GENERATED = 0;
    public static final int KM_ORIGIN_IMPORTED = 2;
    public static final int KM_ORIGIN_UNKNOWN = 3;
    public static final int KM_ORIGIN_SECURELY_IMPORTED = 4;

    // Key usability requirements.
    public static final int KM_BLOB_STANDALONE = 0;
    public static final int KM_BLOB_REQUIRES_FILE_SYSTEM = 1;

    // Operation Purposes.
    public static final int KM_PURPOSE_ENCRYPT = 0;
    public static final int KM_PURPOSE_DECRYPT = 1;
    public static final int KM_PURPOSE_SIGN = 2;
    public static final int KM_PURPOSE_VERIFY = 3;
    public static final int KM_PURPOSE_WRAP = 5;

    // Key formats.
    public static final int KM_KEY_FORMAT_X509 = 0;
    public static final int KM_KEY_FORMAT_PKCS8 = 1;
    public static final int KM_KEY_FORMAT_RAW = 3;

    // User authenticators.
    public static final int HW_AUTH_PASSWORD = 1 << 0;
    public static final int HW_AUTH_BIOMETRIC = 1 << 1;

    // Error codes.
    public static final int KM_ERROR_OK = 0;
    public static final int KM_ERROR_ROOT_OF_TRUST_ALREADY_SET = -1;
    public static final int KM_ERROR_UNSUPPORTED_PURPOSE = -2;
    public static final int KM_ERROR_INCOMPATIBLE_PURPOSE = -3;
    public static final int KM_ERROR_UNSUPPORTED_ALGORITHM = -4;
    public static final int KM_ERROR_INCOMPATIBLE_ALGORITHM = -5;
    public static final int KM_ERROR_UNSUPPORTED_KEY_SIZE = -6;
    public static final int KM_ERROR_UNSUPPORTED_BLOCK_MODE = -7;
    public static final int KM_ERROR_INCOMPATIBLE_BLOCK_MODE = -8;
    public static final int KM_ERROR_UNSUPPORTED_MAC_LENGTH = -9;
    public static final int KM_ERROR_UNSUPPORTED_PADDING_MODE = -10;
    public static final int KM_ERROR_INCOMPATIBLE_PADDING_MODE = -11;
    public static final int KM_ERROR_UNSUPPORTED_DIGEST = -12;
    public static final int KM_ERROR_INCOMPATIBLE_DIGEST = -13;
    public static final int KM_ERROR_INVALID_EXPIRATION_TIME = -14;
    public static final int KM_ERROR_INVALID_USER_ID = -15;
    public static final int KM_ERROR_INVALID_AUTHORIZATION_TIMEOUT = -16;
    public static final int KM_ERROR_UNSUPPORTED_KEY_FORMAT = -17;
    public static final int KM_ERROR_INCOMPATIBLE_KEY_FORMAT = -18;
    public static final int KM_ERROR_UNSUPPORTED_KEY_ENCRYPTION_ALGORITHM = -19;
    public static final int KM_ERROR_UNSUPPORTED_KEY_VERIFICATION_ALGORITHM = -20;
    public static final int KM_ERROR_INVALID_INPUT_LENGTH = -21;
    public static final int KM_ERROR_KEY_EXPORT_OPTIONS_INVALID = -22;
    public static final int KM_ERROR_DELEGATION_NOT_ALLOWED = -23;
    public static final int KM_ERROR_KEY_NOT_YET_VALID = -24;
    public static final int KM_ERROR_KEY_EXPIRED = -25;
    public static final int KM_ERROR_KEY_USER_NOT_AUTHENTICATED = -26;
    public static final int KM_ERROR_OUTPUT_PARAMETER_NULL = -27;
    public static final int KM_ERROR_INVALID_OPERATION_HANDLE = -28;
    public static final int KM_ERROR_INSUFFICIENT_BUFFER_SPACE = -29;
    public static final int KM_ERROR_VERIFICATION_FAILED = -30;
    public static final int KM_ERROR_TOO_MANY_OPERATIONS = -31;
    public static final int KM_ERROR_UNEXPECTED_NULL_POINTER = -32;
    public static final int KM_ERROR_INVALID_KEY_BLOB = -33;
    public static final int KM_ERROR_IMPORTED_KEY_NOT_ENCRYPTED = -34;
    public static final int KM_ERROR_IMPORTED_KEY_DECRYPTION_FAILED = -35;
    public static final int KM_ERROR_IMPORTED_KEY_NOT_SIGNED = -36;
    public static final int KM_ERROR_IMPORTED_KEY_VERIFICATION_FAILED = -37;
    public static final int KM_ERROR_INVALID_ARGUMENT = -38;
    public static final int KM_ERROR_UNSUPPORTED_TAG = -39;
    public static final int KM_ERROR_INVALID_TAG = -40;
    public static final int KM_ERROR_MEMORY_ALLOCATION_FAILED = -41;
    public static final int KM_ERROR_INVALID_RESCOPING = -42;
    public static final int KM_ERROR_IMPORT_PARAMETER_MISMATCH = -44;
    public static final int KM_ERROR_SECURE_HW_ACCESS_DENIED = -45;
    public static final int KM_ERROR_OPERATION_CANCELLED = -46;
    public static final int KM_ERROR_CONCURRENT_ACCESS_CONFLICT = -47;
    public static final int KM_ERROR_SECURE_HW_BUSY = -48;
    public static final int KM_ERROR_SECURE_HW_COMMUNICATION_FAILED = -49;
    public static final int KM_ERROR_UNSUPPORTED_EC_FIELD = -50;
    public static final int KM_ERROR_MISSING_NONCE = -51;
    public static final int KM_ERROR_INVALID_NONCE = -52;
    public static final int KM_ERROR_MISSING_MAC_LENGTH = -53;
    public static final int KM_ERROR_KEY_RATE_LIMIT_EXCEEDED = -54;
    public static final int KM_ERROR_CALLER_NONCE_PROHIBITED = -55;
    public static final int KM_ERROR_KEY_MAX_OPS_EXCEEDED = -56;
    public static final int KM_ERROR_INVALID_MAC_LENGTH = -57;
    public static final int KM_ERROR_MISSING_MIN_MAC_LENGTH = -58;
    public static final int KM_ERROR_UNSUPPORTED_MIN_MAC_LENGTH = -59;
    public static final int KM_ERROR_CANNOT_ATTEST_IDS = -66;
    public static final int KM_ERROR_DEVICE_LOCKED = -72;
    public static final int KM_ERROR_UNIMPLEMENTED = -100;
    public static final int KM_ERROR_VERSION_MISMATCH = -101;
    public static final int KM_ERROR_UNKNOWN_ERROR = -1000;

    public static final Map<Integer, String> sErrorCodeToString = new HashMap<Integer, String>();
    static {
        sErrorCodeToString.put(KM_ERROR_OK, "OK");
        sErrorCodeToString.put(KM_ERROR_UNSUPPORTED_PURPOSE, "Unsupported purpose");
        sErrorCodeToString.put(KM_ERROR_INCOMPATIBLE_PURPOSE, "Incompatible purpose");
        sErrorCodeToString.put(KM_ERROR_UNSUPPORTED_ALGORITHM, "Unsupported algorithm");
        sErrorCodeToString.put(KM_ERROR_INCOMPATIBLE_ALGORITHM, "Incompatible algorithm");
        sErrorCodeToString.put(KM_ERROR_UNSUPPORTED_KEY_SIZE, "Unsupported key size");
        sErrorCodeToString.put(KM_ERROR_UNSUPPORTED_BLOCK_MODE, "Unsupported block mode");
        sErrorCodeToString.put(KM_ERROR_INCOMPATIBLE_BLOCK_MODE, "Incompatible block mode");
        sErrorCodeToString.put(KM_ERROR_UNSUPPORTED_MAC_LENGTH,
                "Unsupported MAC or authentication tag length");
        sErrorCodeToString.put(KM_ERROR_UNSUPPORTED_PADDING_MODE, "Unsupported padding mode");
        sErrorCodeToString.put(KM_ERROR_INCOMPATIBLE_PADDING_MODE, "Incompatible padding mode");
        sErrorCodeToString.put(KM_ERROR_UNSUPPORTED_DIGEST, "Unsupported digest");
        sErrorCodeToString.put(KM_ERROR_INCOMPATIBLE_DIGEST, "Incompatible digest");
        sErrorCodeToString.put(KM_ERROR_INVALID_EXPIRATION_TIME, "Invalid expiration time");
        sErrorCodeToString.put(KM_ERROR_INVALID_USER_ID, "Invalid user ID");
        sErrorCodeToString.put(KM_ERROR_INVALID_AUTHORIZATION_TIMEOUT,
                "Invalid user authorization timeout");
        sErrorCodeToString.put(KM_ERROR_UNSUPPORTED_KEY_FORMAT, "Unsupported key format");
        sErrorCodeToString.put(KM_ERROR_INCOMPATIBLE_KEY_FORMAT, "Incompatible key format");
        sErrorCodeToString.put(KM_ERROR_INVALID_INPUT_LENGTH, "Invalid input length");
        sErrorCodeToString.put(KM_ERROR_KEY_NOT_YET_VALID, "Key not yet valid");
        sErrorCodeToString.put(KM_ERROR_KEY_EXPIRED, "Key expired");
        sErrorCodeToString.put(KM_ERROR_KEY_USER_NOT_AUTHENTICATED, "Key user not authenticated");
        sErrorCodeToString.put(KM_ERROR_INVALID_OPERATION_HANDLE, "Invalid operation handle");
        sErrorCodeToString.put(KM_ERROR_VERIFICATION_FAILED, "Signature/MAC verification failed");
        sErrorCodeToString.put(KM_ERROR_TOO_MANY_OPERATIONS, "Too many operations");
        sErrorCodeToString.put(KM_ERROR_INVALID_KEY_BLOB, "Invalid key blob");
        sErrorCodeToString.put(KM_ERROR_INVALID_ARGUMENT, "Invalid argument");
        sErrorCodeToString.put(KM_ERROR_UNSUPPORTED_TAG, "Unsupported tag");
        sErrorCodeToString.put(KM_ERROR_INVALID_TAG, "Invalid tag");
        sErrorCodeToString.put(KM_ERROR_MEMORY_ALLOCATION_FAILED, "Memory allocation failed");
        sErrorCodeToString.put(KM_ERROR_UNSUPPORTED_EC_FIELD, "Unsupported EC field");
        sErrorCodeToString.put(KM_ERROR_MISSING_NONCE, "Required IV missing");
        sErrorCodeToString.put(KM_ERROR_INVALID_NONCE, "Invalid IV");
        sErrorCodeToString.put(KM_ERROR_CALLER_NONCE_PROHIBITED,
                "Caller-provided IV not permitted");
        sErrorCodeToString.put(KM_ERROR_INVALID_MAC_LENGTH,
                "Invalid MAC or authentication tag length");
        sErrorCodeToString.put(KM_ERROR_CANNOT_ATTEST_IDS, "Unable to attest device ids");
        sErrorCodeToString.put(KM_ERROR_DEVICE_LOCKED, "Device locked");
        sErrorCodeToString.put(KM_ERROR_UNIMPLEMENTED, "Not implemented");
        sErrorCodeToString.put(KM_ERROR_UNKNOWN_ERROR, "Unknown error");
    }

    public static int getTagType(int tag) {
        return tag & (0xF << 28);
    }

    public static String getErrorMessage(int errorCode) {
        String result = sErrorCodeToString.get(errorCode);
        if (result != null) {
            return result;
        }
        return String.valueOf(errorCode);
    }
}
```

`stub/src/main/java/android/security/keystore/AndroidKeyStoreProvider.java`:

```java
/*
 * Copyright 2025 Dakkshesh <beakthoven@gmail.com>
 * SPDX-License-Identifier: GPL-3.0-or-later
 */

package android.security.keystore;

public class AndroidKeyStoreProvider {
    public static void install() {
        throw new RuntimeException("");
    }
}
```

`stub/src/main/java/android/security/keystore/IKeystoreCertificateChainCallback.java`:

```java
/*
 * Copyright 2025 Dakkshesh <beakthoven@gmail.com>
 * SPDX-License-Identifier: GPL-3.0-or-later
 */

package android.security.keystore;

import android.os.IBinder;
import android.os.RemoteException;
import android.security.keymaster.KeymasterCertificateChain;

public interface IKeystoreCertificateChainCallback {
    void onFinished(KeystoreResponse keystoreResponse, KeymasterCertificateChain keymasterCertificateChain)
            throws RemoteException;

    public static abstract class Stub {
        public static IKeystoreCertificateChainCallback asInterface(IBinder b) {
            throw new RuntimeException("");
        }
    }
}

```

`stub/src/main/java/android/security/keystore/IKeystoreExportKeyCallback.java`:

```java
/*
 * Copyright 2025 Dakkshesh <beakthoven@gmail.com>
 * SPDX-License-Identifier: GPL-3.0-or-later
 */

package android.security.keystore;

import android.os.IBinder;
import android.os.RemoteException;
import android.security.keymaster.ExportResult;

public interface IKeystoreExportKeyCallback {
    void onFinished(ExportResult exportResult) throws RemoteException;

    public static abstract class Stub {
        public static IKeystoreExportKeyCallback asInterface(IBinder b) {
            throw new RuntimeException("");
        }
    }
}

```

`stub/src/main/java/android/security/keystore/IKeystoreKeyCharacteristicsCallback.java`:

```java
/*
 * Copyright 2025 Dakkshesh <beakthoven@gmail.com>
 * SPDX-License-Identifier: GPL-3.0-or-later
 */

package android.security.keystore;

import android.os.IBinder;
import android.os.IInterface;
import android.os.RemoteException;
import android.security.keymaster.KeyCharacteristics;

public interface IKeystoreKeyCharacteristicsCallback extends IInterface {
    void onFinished(KeystoreResponse keystoreResponse, KeyCharacteristics keyCharacteristics) throws RemoteException;

    public static abstract class Stub {
        public static IKeystoreKeyCharacteristicsCallback asInterface(IBinder b) {
            throw new RuntimeException("");
        }
    }
}

```

`stub/src/main/java/android/security/keystore/IKeystoreService.java`:

```java
/*
 * Copyright 2025 Dakkshesh <beakthoven@gmail.com>
 * SPDX-License-Identifier: GPL-3.0-or-later
 */

package android.security.keystore;

public interface IKeystoreService {
    class Stub {
    }
}
```

`stub/src/main/java/android/security/keystore/KeystoreResponse.java`:

```java
/*
 * Copyright 2025 Dakkshesh <beakthoven@gmail.com>
 * SPDX-License-Identifier: GPL-3.0-or-later
 */

package android.security.keystore;

import android.os.Parcel;
import android.os.Parcelable;

import androidx.annotation.NonNull;

public class KeystoreResponse implements Parcelable {
    public final int error_code_;
    public final String error_msg_;

    protected KeystoreResponse(int error_code, String error_msg) {
        this.error_code_ = error_code;
        this.error_msg_ = error_msg;
    }

    @Override
    public void writeToParcel(@NonNull Parcel dest, int flags) {
        throw new RuntimeException("");
    }

    @Override
    public int describeContents() {
        throw new RuntimeException("");
    }

    public static final Creator<KeystoreResponse> CREATOR = new Creator<KeystoreResponse>() {
        @Override
        public KeystoreResponse createFromParcel(Parcel in) {
            throw new RuntimeException("");
        }

        @Override
        public KeystoreResponse[] newArray(int size) {
            throw new RuntimeException("");
        }
    };
}

```

`stub/src/main/java/android/security/keystore2/AndroidKeyStoreProvider.java`:

```java
/*
 * Copyright 2025 Dakkshesh <beakthoven@gmail.com>
 * SPDX-License-Identifier: GPL-3.0-or-later
 */

package android.security.keystore2;

public class AndroidKeyStoreProvider {
    public static void install() {
        throw new RuntimeException("");
    }
}
```

`stub/src/main/java/android/system/keystore2/Authorization.java`:

```java
/*
 * Copyright 2025 Dakkshesh <beakthoven@gmail.com>
 * SPDX-License-Identifier: GPL-3.0-or-later
 */

package android.system.keystore2;

import android.hardware.security.keymint.KeyParameter;

public class Authorization {
    public KeyParameter keyParameter;
    public int securityLevel = 0;
}

```

`stub/src/main/java/android/system/keystore2/IKeystoreSecurityLevel.java`:

```java
/*
 * Copyright 2025 Dakkshesh <beakthoven@gmail.com>
 * SPDX-License-Identifier: GPL-3.0-or-later
 */

package android.system.keystore2;

import android.hardware.security.keymint.KeyParameter;
import android.os.IBinder;
import android.os.IInterface;

import androidx.annotation.Nullable;

public interface IKeystoreSecurityLevel extends IInterface {
    String DESCRIPTOR = "android.system.keystore2.IKeystoreSecurityLevel";

    KeyMetadata generateKey(KeyDescriptor key, @Nullable KeyDescriptor attestationKey,
            KeyParameter[] params, int flags, byte[] entropy);

    class Stub {
        public static IKeystoreSecurityLevel asInterface(IBinder b) {
            throw new RuntimeException();
        }
    }
}

```

`stub/src/main/java/android/system/keystore2/IKeystoreService.java`:

```java
/*
 * Copyright 2025 Dakkshesh <beakthoven@gmail.com>
 * SPDX-License-Identifier: GPL-3.0-or-later
 */

package android.system.keystore2;

import android.os.IBinder;

public interface IKeystoreService {
    String DESCRIPTOR = "android.system.keystore2.IKeystoreService";

    IKeystoreSecurityLevel getSecurityLevel(int securityLevel);

    class Stub {
        public static IKeystoreService asInterface(IBinder b) {
            throw new RuntimeException("");
        }
    }
}

```

`stub/src/main/java/android/system/keystore2/KeyDescriptor.java`:

```java
/*
 * Copyright 2025 Dakkshesh <beakthoven@gmail.com>
 * SPDX-License-Identifier: GPL-3.0-or-later
 */

package android.system.keystore2;

import android.os.Parcel;
import android.os.Parcelable;

import androidx.annotation.NonNull;

public class KeyDescriptor implements Parcelable {
    public String alias;
    public byte[] blob;
    public int domain = 0;
    public long nspace = 0;

    public static final Creator<KeyDescriptor> CREATOR = new Creator<KeyDescriptor>() {
        @Override
        public KeyDescriptor createFromParcel(Parcel in) {
            throw new RuntimeException();
        }

        @Override
        public KeyDescriptor[] newArray(int size) {
            throw new RuntimeException();
        }
    };

    @Override
    public int describeContents() {
        throw new RuntimeException("");
    }

    @Override
    public void writeToParcel(@NonNull Parcel parcel, int i) {
        throw new RuntimeException("");
    }
}

```

`stub/src/main/java/android/system/keystore2/KeyEntryResponse.java`:

```java
/*
 * Copyright 2025 Dakkshesh <beakthoven@gmail.com>
 * SPDX-License-Identifier: GPL-3.0-or-later
 */

package android.system.keystore2;

import android.os.Parcel;
import android.os.Parcelable;

import androidx.annotation.NonNull;

public class KeyEntryResponse implements Parcelable {
    public IKeystoreSecurityLevel iSecurityLevel;
    public KeyMetadata metadata;

    public static final Creator<KeyEntryResponse> CREATOR = new Creator<KeyEntryResponse>() {
        @Override
        public KeyEntryResponse createFromParcel(Parcel in) {
            throw new RuntimeException("");
        }

        @Override
        public KeyEntryResponse[] newArray(int size) {
            throw new RuntimeException("");
        }
    };

    @Override
    public int describeContents() {
        throw new RuntimeException("");
    }

    @Override
    public void writeToParcel(@NonNull Parcel parcel, int i) {
        throw new RuntimeException("");
    }
}

```

`stub/src/main/java/android/system/keystore2/KeyMetadata.java`:

```java
/*
 * Copyright 2025 Dakkshesh <beakthoven@gmail.com>
 * SPDX-License-Identifier: GPL-3.0-or-later
 */

package android.system.keystore2;

import android.os.Parcel;
import android.os.Parcelable;

import androidx.annotation.NonNull;

public class KeyMetadata implements Parcelable {
    public Authorization[] authorizations;
    public byte[] certificate;
    public byte[] certificateChain;
    public KeyDescriptor key;
    public int keySecurityLevel = 0;
    public long modificationTimeMs = 0;

    public static final Creator<KeyMetadata> CREATOR = new Creator<KeyMetadata>() {
        @Override
        public KeyMetadata createFromParcel(Parcel in) {
            throw new RuntimeException("");
        }

        @Override
        public KeyMetadata[] newArray(int size) {
            throw new RuntimeException("");
        }
    };

    @Override
    public int describeContents() {
        throw new RuntimeException("");
    }

    @Override
    public void writeToParcel(@NonNull Parcel parcel, int i) {
        throw new RuntimeException("");
    }
}

```