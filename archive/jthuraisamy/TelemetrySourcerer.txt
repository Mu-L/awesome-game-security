Project Path: arc_jthuraisamy_TelemetrySourcerer_86wxe6z9

Source Tree:

```txt
arc_jthuraisamy_TelemetrySourcerer_86wxe6z9
├── CHANGELOG.md
├── LICENSE
├── README.md
├── TelemetrySourcerer
│   ├── KmCallbacks.cpp
│   ├── KmCallbacks.h
│   ├── Resource.h
│   ├── TelemetrySourcerer.cpp
│   ├── TelemetrySourcerer.h
│   ├── TelemetrySourcerer.rc
│   ├── TelemetrySourcerer.vcxproj
│   ├── TelemetrySourcerer.vcxproj.filters
│   ├── UmETW.cpp
│   ├── UmETW.h
│   ├── UmHooks.cpp
│   └── UmHooks.h
├── TelemetrySourcerer.sln
└── TelemetrySourcererDriver
    ├── Callbacks.cpp
    ├── Callbacks.h
    ├── Common.h
    ├── Memory.cpp
    ├── Memory.h
    ├── Modules.cpp
    ├── Modules.h
    ├── TelemetrySourcererDriver.cpp
    ├── TelemetrySourcererDriver.h
    ├── TelemetrySourcererDriver.vcxproj
    └── TelemetrySourcererDriver.vcxproj.filters

```

`CHANGELOG.md`:

```md
# Changelog

All notable changes to this project will be documented in this file.

The format is based on [Keep a Changelog](https://keepachangelog.com/en/1.0.0/),
and this project adheres to [Semantic Versioning](https://semver.org/spec/v2.0.0.html).

## [0.11.0] - 2021-03-10

### Added

- Added support for Windows 10 20H2.

### Changed

- Fixed code correctness issues (h/t to [@JohnLaTwC](https://twitter.com/JohnLaTwC)).

## [0.10.0] - 2020-08-31

### Added

- Added column sorting for tables.
- Added highlighting for more ETW providers.

### Changed

- Notable list items will appear on top by default.
- Fixed bug where device handles were not closed after usage (h/t to [@DanShaqFu](https://twitter.com/DanShaqFu/status/1299322813640253442)).

## [0.9.1] - 2020-07-31

### Changed

- Fixed elevation check so the driver loads when the SYSTEM account is used.

## [0.9.0] - 2020-07-31

### Added

- Initial release.

[0.11.0]: https://github.com/jthuraisamy/TelemetrySourcerer/compare/v0.10.0...v0.11.0
[0.10.0]: https://github.com/jthuraisamy/TelemetrySourcerer/compare/v0.9.1...v0.10.0
[0.9.1]: https://github.com/jthuraisamy/TelemetrySourcerer/compare/v0.9.0...v0.9.1
[0.9.0]: https://github.com/jthuraisamy/TelemetrySourcerer/releases/tag/v0.9.0

```

`LICENSE`:

```
                                 Apache License
                           Version 2.0, January 2004
                        http://www.apache.org/licenses/

   TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION

   1. Definitions.

      "License" shall mean the terms and conditions for use, reproduction,
      and distribution as defined by Sections 1 through 9 of this document.

      "Licensor" shall mean the copyright owner or entity authorized by
      the copyright owner that is granting the License.

      "Legal Entity" shall mean the union of the acting entity and all
      other entities that control, are controlled by, or are under common
      control with that entity. For the purposes of this definition,
      "control" means (i) the power, direct or indirect, to cause the
      direction or management of such entity, whether by contract or
      otherwise, or (ii) ownership of fifty percent (50%) or more of the
      outstanding shares, or (iii) beneficial ownership of such entity.

      "You" (or "Your") shall mean an individual or Legal Entity
      exercising permissions granted by this License.

      "Source" form shall mean the preferred form for making modifications,
      including but not limited to software source code, documentation
      source, and configuration files.

      "Object" form shall mean any form resulting from mechanical
      transformation or translation of a Source form, including but
      not limited to compiled object code, generated documentation,
      and conversions to other media types.

      "Work" shall mean the work of authorship, whether in Source or
      Object form, made available under the License, as indicated by a
      copyright notice that is included in or attached to the work
      (an example is provided in the Appendix below).

      "Derivative Works" shall mean any work, whether in Source or Object
      form, that is based on (or derived from) the Work and for which the
      editorial revisions, annotations, elaborations, or other modifications
      represent, as a whole, an original work of authorship. For the purposes
      of this License, Derivative Works shall not include works that remain
      separable from, or merely link (or bind by name) to the interfaces of,
      the Work and Derivative Works thereof.

      "Contribution" shall mean any work of authorship, including
      the original version of the Work and any modifications or additions
      to that Work or Derivative Works thereof, that is intentionally
      submitted to Licensor for inclusion in the Work by the copyright owner
      or by an individual or Legal Entity authorized to submit on behalf of
      the copyright owner. For the purposes of this definition, "submitted"
      means any form of electronic, verbal, or written communication sent
      to the Licensor or its representatives, including but not limited to
      communication on electronic mailing lists, source code control systems,
      and issue tracking systems that are managed by, or on behalf of, the
      Licensor for the purpose of discussing and improving the Work, but
      excluding communication that is conspicuously marked or otherwise
      designated in writing by the copyright owner as "Not a Contribution."

      "Contributor" shall mean Licensor and any individual or Legal Entity
      on behalf of whom a Contribution has been received by Licensor and
      subsequently incorporated within the Work.

   2. Grant of Copyright License. Subject to the terms and conditions of
      this License, each Contributor hereby grants to You a perpetual,
      worldwide, non-exclusive, no-charge, royalty-free, irrevocable
      copyright license to reproduce, prepare Derivative Works of,
      publicly display, publicly perform, sublicense, and distribute the
      Work and such Derivative Works in Source or Object form.

   3. Grant of Patent License. Subject to the terms and conditions of
      this License, each Contributor hereby grants to You a perpetual,
      worldwide, non-exclusive, no-charge, royalty-free, irrevocable
      (except as stated in this section) patent license to make, have made,
      use, offer to sell, sell, import, and otherwise transfer the Work,
      where such license applies only to those patent claims licensable
      by such Contributor that are necessarily infringed by their
      Contribution(s) alone or by combination of their Contribution(s)
      with the Work to which such Contribution(s) was submitted. If You
      institute patent litigation against any entity (including a
      cross-claim or counterclaim in a lawsuit) alleging that the Work
      or a Contribution incorporated within the Work constitutes direct
      or contributory patent infringement, then any patent licenses
      granted to You under this License for that Work shall terminate
      as of the date such litigation is filed.

   4. Redistribution. You may reproduce and distribute copies of the
      Work or Derivative Works thereof in any medium, with or without
      modifications, and in Source or Object form, provided that You
      meet the following conditions:

      (a) You must give any other recipients of the Work or
          Derivative Works a copy of this License; and

      (b) You must cause any modified files to carry prominent notices
          stating that You changed the files; and

      (c) You must retain, in the Source form of any Derivative Works
          that You distribute, all copyright, patent, trademark, and
          attribution notices from the Source form of the Work,
          excluding those notices that do not pertain to any part of
          the Derivative Works; and

      (d) If the Work includes a "NOTICE" text file as part of its
          distribution, then any Derivative Works that You distribute must
          include a readable copy of the attribution notices contained
          within such NOTICE file, excluding those notices that do not
          pertain to any part of the Derivative Works, in at least one
          of the following places: within a NOTICE text file distributed
          as part of the Derivative Works; within the Source form or
          documentation, if provided along with the Derivative Works; or,
          within a display generated by the Derivative Works, if and
          wherever such third-party notices normally appear. The contents
          of the NOTICE file are for informational purposes only and
          do not modify the License. You may add Your own attribution
          notices within Derivative Works that You distribute, alongside
          or as an addendum to the NOTICE text from the Work, provided
          that such additional attribution notices cannot be construed
          as modifying the License.

      You may add Your own copyright statement to Your modifications and
      may provide additional or different license terms and conditions
      for use, reproduction, or distribution of Your modifications, or
      for any such Derivative Works as a whole, provided Your use,
      reproduction, and distribution of the Work otherwise complies with
      the conditions stated in this License.

   5. Submission of Contributions. Unless You explicitly state otherwise,
      any Contribution intentionally submitted for inclusion in the Work
      by You to the Licensor shall be under the terms and conditions of
      this License, without any additional terms or conditions.
      Notwithstanding the above, nothing herein shall supersede or modify
      the terms of any separate license agreement you may have executed
      with Licensor regarding such Contributions.

   6. Trademarks. This License does not grant permission to use the trade
      names, trademarks, service marks, or product names of the Licensor,
      except as required for reasonable and customary use in describing the
      origin of the Work and reproducing the content of the NOTICE file.

   7. Disclaimer of Warranty. Unless required by applicable law or
      agreed to in writing, Licensor provides the Work (and each
      Contributor provides its Contributions) on an "AS IS" BASIS,
      WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
      implied, including, without limitation, any warranties or conditions
      of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A
      PARTICULAR PURPOSE. You are solely responsible for determining the
      appropriateness of using or redistributing the Work and assume any
      risks associated with Your exercise of permissions under this License.

   8. Limitation of Liability. In no event and under no legal theory,
      whether in tort (including negligence), contract, or otherwise,
      unless required by applicable law (such as deliberate and grossly
      negligent acts) or agreed to in writing, shall any Contributor be
      liable to You for damages, including any direct, indirect, special,
      incidental, or consequential damages of any character arising as a
      result of this License or out of the use or inability to use the
      Work (including but not limited to damages for loss of goodwill,
      work stoppage, computer failure or malfunction, or any and all
      other commercial damages or losses), even if such Contributor
      has been advised of the possibility of such damages.

   9. Accepting Warranty or Additional Liability. While redistributing
      the Work or Derivative Works thereof, You may choose to offer,
      and charge a fee for, acceptance of support, warranty, indemnity,
      or other liability obligations and/or rights consistent with this
      License. However, in accepting such obligations, You may act only
      on Your own behalf and on Your sole responsibility, not on behalf
      of any other Contributor, and only if You agree to indemnify,
      defend, and hold each Contributor harmless for any liability
      incurred by, or claims asserted against, such Contributor by reason
      of your accepting any such warranty or additional liability.

   END OF TERMS AND CONDITIONS

   APPENDIX: How to apply the Apache License to your work.

      To apply the Apache License to your work, attach the following
      boilerplate notice, with the fields enclosed by brackets "[]"
      replaced with your own identifying information. (Don't include
      the brackets!)  The text should be enclosed in the appropriate
      comment syntax for the file format. We also recommend that a
      file or class name and description of purpose be included on the
      same "printed page" as the copyright notice for easier
      identification within third-party archives.

   Copyright [yyyy] [name of copyright owner]

   Licensed under the Apache License, Version 2.0 (the "License");
   you may not use this file except in compliance with the License.
   You may obtain a copy of the License at

       http://www.apache.org/licenses/LICENSE-2.0

   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an "AS IS" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License.

```

`README.md`:

```md
# Telemetry Sourcerer

<p align="center">
  <img src="https://www.publicdomainpictures.net/pictures/180000/nahled/wizard-with-wand.jpg" height="250" />
</p>

## Introduction

Telemetry Sourcerer can enumerate and disable common sources of telemetry used by AV/EDR on Windows.

Red teamers and security enthusiasts can use this tool in a lab environment to:

- Identify collection-based blind spots in the products they're up against.
- Determine which sources of telemetry generate particular types of events.
- Validate whether using the tool's tampering capabilities can lead to detection.

For details on building a private lab, consider reading my post on [Diverting EDR Telemetry to Private Infrastructure](http://jackson-t.ca/edr-reversing-evading-03.html). 

> **OPSEC WARNING**: Although it's possible to use this in targeted environments, there are OPSEC risks when using any offensive security tool _as is_. You can instead leverage the code from this project into your own tooling for operational use and combine with other techniques to reduce the footprint it creates.

## Features

- Enumerates various kernel-mode callbacks with the ability to suppress them.
- Detects inline user-mode hooks within the process, with the ability to unhook them.
- Lists ETW sessions and providers while highlighting potentially relevant ones to disable.

## Screenshots

<p align="center">
  <img src="https://i.imgur.com/W6EODwb.png" />
  <br><br>
  <img src="https://i.imgur.com/WzjTNnP.png" />
  <br><br>
  <img src="https://i.imgur.com/dqwidfM.png" />
</p>

## Usage Instructions

1. Download the [latest release](https://github.com/jthuraisamy/TelemetrySourcerer/releases).
1. Extract files.
1. Launch the executable (run elevated for kernel-mode callbacks or more ETW sessions).

### Kernel-mode Callbacks

To view kernel-mode callbacks, the tool needs to be run with elevated privileges to load a driver. The driver does not come signed, so consider enabling test signing mode, temporarily disabling driver signature enforcement (DSE), or signing the driver with a valid certificate:

#### Test Signing Mode

1. Disable BitLocker and Secure Boot.
1. Open an elevated Command Prompt window.
1. Enter `bcdedit.exe -set TESTSIGNING ON`.
1. Reboot system.
1. Launch Telemetry Sourcerer with elevated privileges.

#### Disable DSE with [KDU](https://github.com/hfiref0x/KDU)

1. `git clone https://github.com/hfiref0x/KDU.git`
1. Open an elevated Command Prompt window.
1. Enter `kdu -dse 0` to disable DSE.
1. Launch Telemetry Sourcerer with elevated privileges.
1. Enter `kdu -dse 6` to enable DSE.

> This option may be [incompatible](https://github.com/hfiref0x/DSEFix#patchguard-incompatibility) with [KPP](https://en.wikipedia.org/wiki/Kernel_Patch_Protection) on Windows 8.1+.

#### Sign Driver

1. Get [SignTool](https://docs.microsoft.com/en-us/windows/win32/seccrypto/signtool) from the Windows SDK and an appropriate [cross-certificate](https://docs.microsoft.com/en-us/windows-hardware/drivers/install/cross-certificates-for-kernel-mode-code-signing) from Microsoft Docs.
1. `signtool sign /a /ac "cross-cert.cer" /f "cert.pfx" /p "password" TelemetrySourcererDriver.sys` 
1. Launch Telemetry Sourcerer with elevated privileges.

## Caveats and Limitations

- This tool is meant for research purposes only and is not OPSEC-safe for production use.
- Compiled with Visual Studio 2019 using the Windows 10 SDK (10.0.19041.0) and WDK (2004).
- Currently does not look for IAT/EAT user-mode hooks, or kernel-mode hooks.
- The driver has not been thoroughly tested for abuse cases.
- Tested on Windows 7 and 10 (x64) only.

## Credits

This tool was developed by [@Jackson_T](https://twitter.com/Jackson_T) but builds upon the work of others:

- [@gentilkiwi](https://twitter.com/gentilkiwi) and [@fdiskyou](https://twitter.com/fdiskyou) for driver code that enumerates callback functions.
- [@0x00dtm](https://twitter.com/0x00dtm) for the inline user-mode hook comparison logic.

## Related Articles and Projects

- [@matterpreter](https://twitter.com/matterpreter): [Mimidrv In Depth: Exploring Mimikatz’s Kernel Driver](https://posts.specterops.io/mimidrv-in-depth-4d273d19e148)
- [@fdiskyou](https://twitter.com/fdiskyou): [Windows Kernel Ps Callbacks Experiments](http://deniable.org/windows/windows-callbacks)
- [@matteomalvica](https://twitter.com/matteomalvica): [Silencing the EDR. How to disable process, threads and image-loading detection callbacks.](https://www.matteomalvica.com/blog/2020/07/15/silencing-the-edr/)
- [@0x00dtm](https://twitter.com/0x00dtm): [Defeating Userland Hooks (ft. Bitdefender)](https://0x00sec.org/t/defeating-userland-hooks-ft-bitdefender/12496) ([Code](https://github.com/NtRaiseHardError/Antimalware-Research/tree/master/Generic/Userland%20Hooking/AntiHook))
- [@palantir](https://medium.com/palantir): [Tampering with Windows Event Tracing: Background, Offense, and Defense](https://medium.com/palantir/tampering-with-windows-event-tracing-background-offense-and-defense-4be7ac62ac63)

## Licence

This project is licensed under the Apache License 2.0.

```

`TelemetrySourcerer.sln`:

```sln

Microsoft Visual Studio Solution File, Format Version 12.00
# Visual Studio Version 16
VisualStudioVersion = 16.0.30309.148
MinimumVisualStudioVersion = 10.0.40219.1
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "TelemetrySourcerer", "TelemetrySourcerer\TelemetrySourcerer.vcxproj", "{3CE834D0-F529-4A79-9218-383FA30E7EDA}"
EndProject
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "TelemetrySourcererDriver", "TelemetrySourcererDriver\TelemetrySourcererDriver.vcxproj", "{8920075B-A372-47F3-A391-DBCACE851E28}"
EndProject
Global
	GlobalSection(SolutionConfigurationPlatforms) = preSolution
		Debug|ARM = Debug|ARM
		Debug|ARM64 = Debug|ARM64
		Debug|x64 = Debug|x64
		Debug|x86 = Debug|x86
		Release|ARM = Release|ARM
		Release|ARM64 = Release|ARM64
		Release|x64 = Release|x64
		Release|x86 = Release|x86
	EndGlobalSection
	GlobalSection(ProjectConfigurationPlatforms) = postSolution
		{3CE834D0-F529-4A79-9218-383FA30E7EDA}.Debug|ARM.ActiveCfg = Debug|Win32
		{3CE834D0-F529-4A79-9218-383FA30E7EDA}.Debug|ARM64.ActiveCfg = Debug|Win32
		{3CE834D0-F529-4A79-9218-383FA30E7EDA}.Debug|x64.ActiveCfg = Debug|x64
		{3CE834D0-F529-4A79-9218-383FA30E7EDA}.Debug|x64.Build.0 = Debug|x64
		{3CE834D0-F529-4A79-9218-383FA30E7EDA}.Debug|x86.ActiveCfg = Debug|Win32
		{3CE834D0-F529-4A79-9218-383FA30E7EDA}.Debug|x86.Build.0 = Debug|Win32
		{3CE834D0-F529-4A79-9218-383FA30E7EDA}.Release|ARM.ActiveCfg = Release|Win32
		{3CE834D0-F529-4A79-9218-383FA30E7EDA}.Release|ARM64.ActiveCfg = Release|Win32
		{3CE834D0-F529-4A79-9218-383FA30E7EDA}.Release|x64.ActiveCfg = Release|x64
		{3CE834D0-F529-4A79-9218-383FA30E7EDA}.Release|x64.Build.0 = Release|x64
		{3CE834D0-F529-4A79-9218-383FA30E7EDA}.Release|x86.ActiveCfg = Release|Win32
		{3CE834D0-F529-4A79-9218-383FA30E7EDA}.Release|x86.Build.0 = Release|Win32
		{8920075B-A372-47F3-A391-DBCACE851E28}.Debug|ARM.ActiveCfg = Debug|ARM
		{8920075B-A372-47F3-A391-DBCACE851E28}.Debug|ARM.Build.0 = Debug|ARM
		{8920075B-A372-47F3-A391-DBCACE851E28}.Debug|ARM.Deploy.0 = Debug|ARM
		{8920075B-A372-47F3-A391-DBCACE851E28}.Debug|ARM64.ActiveCfg = Debug|ARM64
		{8920075B-A372-47F3-A391-DBCACE851E28}.Debug|ARM64.Build.0 = Debug|ARM64
		{8920075B-A372-47F3-A391-DBCACE851E28}.Debug|ARM64.Deploy.0 = Debug|ARM64
		{8920075B-A372-47F3-A391-DBCACE851E28}.Debug|x64.ActiveCfg = Debug|x64
		{8920075B-A372-47F3-A391-DBCACE851E28}.Debug|x64.Build.0 = Debug|x64
		{8920075B-A372-47F3-A391-DBCACE851E28}.Debug|x64.Deploy.0 = Debug|x64
		{8920075B-A372-47F3-A391-DBCACE851E28}.Debug|x86.ActiveCfg = Debug|Win32
		{8920075B-A372-47F3-A391-DBCACE851E28}.Debug|x86.Build.0 = Debug|Win32
		{8920075B-A372-47F3-A391-DBCACE851E28}.Debug|x86.Deploy.0 = Debug|Win32
		{8920075B-A372-47F3-A391-DBCACE851E28}.Release|ARM.ActiveCfg = Release|ARM
		{8920075B-A372-47F3-A391-DBCACE851E28}.Release|ARM.Build.0 = Release|ARM
		{8920075B-A372-47F3-A391-DBCACE851E28}.Release|ARM.Deploy.0 = Release|ARM
		{8920075B-A372-47F3-A391-DBCACE851E28}.Release|ARM64.ActiveCfg = Release|ARM64
		{8920075B-A372-47F3-A391-DBCACE851E28}.Release|ARM64.Build.0 = Release|ARM64
		{8920075B-A372-47F3-A391-DBCACE851E28}.Release|ARM64.Deploy.0 = Release|ARM64
		{8920075B-A372-47F3-A391-DBCACE851E28}.Release|x64.ActiveCfg = Release|x64
		{8920075B-A372-47F3-A391-DBCACE851E28}.Release|x64.Build.0 = Release|x64
		{8920075B-A372-47F3-A391-DBCACE851E28}.Release|x64.Deploy.0 = Release|x64
		{8920075B-A372-47F3-A391-DBCACE851E28}.Release|x86.ActiveCfg = Release|Win32
		{8920075B-A372-47F3-A391-DBCACE851E28}.Release|x86.Build.0 = Release|Win32
		{8920075B-A372-47F3-A391-DBCACE851E28}.Release|x86.Deploy.0 = Release|Win32
	EndGlobalSection
	GlobalSection(SolutionProperties) = preSolution
		HideSolutionNode = FALSE
	EndGlobalSection
	GlobalSection(ExtensibilityGlobals) = postSolution
		SolutionGuid = {318D94B5-BBAD-495C-853C-862E28E93787}
	EndGlobalSection
EndGlobal

```

`TelemetrySourcerer/KmCallbacks.cpp`:

```cpp
#include <Windows.h>
#include <Shlwapi.h>
#include <strsafe.h>

#include <set>
#include <string>

#include "KmCallbacks.h"
#include "../TelemetrySourcererDriver/Common.h"

#pragma comment(lib, "Shlwapi.lib")

using namespace std;

std::set<wstring> CommonModules;

// Function:    LoadDriver
// Description: Checks if the driver is loaded, and loads it if not.
// Called from: KmcLoadResults before requesting results.
DWORD LoadDriver()
{
	// Driver is already loaded if can create a handle.
	HANDLE DeviceHandle = GetDeviceHandle();
	if (DeviceHandle != (HANDLE)-1)
	{
		CloseHandle(DeviceHandle);
		return ERROR_SUCCESS;
	}

	// Cannot load the driver if the process is not elevated.
	if (!IsProcessElevated())
		return ERROR_PRIVILEGE_NOT_HELD;

	// Check if the driver is in the same directory.
	WCHAR ExecutableDirectory[MAX_PATH] = { 0 };
	GetModuleFileNameW(GetModuleHandle(NULL), (LPWSTR)&ExecutableDirectory, MAX_PATH - 1);
	PathRemoveFileSpecW((LPWSTR)&ExecutableDirectory);
	WCHAR DriverPath[MAX_PATH] = { 0 };
	StringCchPrintfW(DriverPath, MAX_PATH, LR"(\??\%ls\TelemetrySourcererDriver.sys)", ExecutableDirectory);
	if (!PathFileExistsW(DriverPath))
		return ERROR_FILE_NOT_FOUND;

	// Check if the service exists.
	SC_HANDLE ScmHandle = OpenSCManagerW(nullptr, nullptr, SC_MANAGER_ALL_ACCESS);
	SC_HANDLE SvcHandle = OpenServiceW(ScmHandle, L"TelemetrySourcererDriver", SERVICE_ALL_ACCESS);

	// If it does not exist, create one.
	if (!SvcHandle)
	{
		if (GetLastError() == ERROR_SERVICE_DOES_NOT_EXIST)
			SvcHandle = CreateServiceW(
				ScmHandle,
				L"TelemetrySourcererDriver",
				L"TelemetrySourcererDriver",
				SERVICE_ALL_ACCESS,
				SERVICE_KERNEL_DRIVER,
				SERVICE_DEMAND_START,
				SERVICE_ERROR_NORMAL,
				DriverPath,
				NULL, NULL, NULL, NULL, NULL);
	}
	// If it does exist, set the correct path of the driver.
	else
	{
		ChangeServiceConfigW(
			SvcHandle,
			SERVICE_NO_CHANGE, SERVICE_NO_CHANGE, SERVICE_NO_CHANGE,
			DriverPath,
			NULL, NULL, NULL, NULL, NULL, NULL);
	}

	// Start the service.
	BOOL ServiceStarted = StartServiceW(SvcHandle, NULL, nullptr);
	
	// Release resources.
	CloseServiceHandle(SvcHandle);
	CloseHandle(DeviceHandle);

	if (ServiceStarted)
		return ERROR_SUCCESS;
	else
		return GetLastError();
}

// Function:    UnloadDriver
// Description: Unloads the driver and deletes the service.
// Called from: MainWndProc when the window is closed.
DWORD UnloadDriver()
{
	// Cannot unload the driver if the process is not elevated.
	if (!IsProcessElevated())
		return ERROR_PRIVILEGE_NOT_HELD;

	// Check if the service exists.
	SC_HANDLE ScmHandle = OpenSCManagerW(nullptr, nullptr, SC_MANAGER_ALL_ACCESS);
	SC_HANDLE SvcHandle = OpenServiceW(ScmHandle, L"TelemetrySourcererDriver", SERVICE_ALL_ACCESS);

	// Unload, if so.
	if (SvcHandle)
	{
		SERVICE_STATUS ServiceStatus = { 0 };
		if (!ControlService(SvcHandle, SERVICE_CONTROL_STOP, &ServiceStatus))
			return GetLastError();

		if (!DeleteService(SvcHandle))
			return GetLastError();
	}
	else
	{
		return GetLastError();
	}

	return ERROR_SUCCESS;
}

// Function:    IsProcessElevated
// Description: Checks if process is running elevated or is running as SYSTEM.
// Called from: LoadDriver to check eligibility.
BOOL IsProcessElevated()
{
	HANDLE TokenHandle;
	DWORD ReturnLength;
	TOKEN_ELEVATION_TYPE ElevationType;
	if (OpenProcessToken(GetCurrentProcess(), TOKEN_READ, &TokenHandle))
	{
		if (GetTokenInformation(TokenHandle, TokenElevationType, &ElevationType, sizeof(TOKEN_ELEVATION_TYPE), &ReturnLength))
		{
			CloseHandle(TokenHandle);

			if (ElevationType == TokenElevationTypeFull)
			{
				return TRUE;
			}
			else
			{
				BOOL IsSystem = FALSE;
				PSID SystemSid = nullptr;
				SID_IDENTIFIER_AUTHORITY NtAuthority = SECURITY_NT_AUTHORITY;
				if (AllocateAndInitializeSid(&NtAuthority, 1, SECURITY_LOCAL_SYSTEM_RID, 0, 0, 0, 0, 0, 0, 0, &SystemSid))
				{
					if (CheckTokenMembership(NULL, SystemSid, &IsSystem))
					{
						FreeSid(SystemSid);

						if (IsSystem)
						{
							return TRUE;
						}
					}
				}
			}
		}
	}
	
	return FALSE;
}

// Function:    GetDeviceHandle
// Description: Returns a handle to the TelemetrySourcerDriver device.
// Called from: Various functions that interact with the driver.
HANDLE GetDeviceHandle()
{
	HANDLE DeviceHandle = CreateFileW(
		LR"(\\.\TelemetrySourcererDriver)",
		GENERIC_WRITE,
		FILE_SHARE_WRITE,
		nullptr,
		OPEN_EXISTING,
		0,
		nullptr);

	return DeviceHandle;
}

// Function:    PopulateKmcModules
// Description: Populates a list of known modules so they aren't highlighted.
// Called from: GetCallbacks as a one-time call if not populated.
VOID PopulateKmcModules()
{
	CommonModules.insert(L"ntoskrnl.exe");
	CommonModules.insert(L"ksecdd.sys");
	CommonModules.insert(L"cng.sys");
	CommonModules.insert(L"tcpip.sys");
	CommonModules.insert(L"dxgkrnl.sys");
	CommonModules.insert(L"peauth.sys");
	CommonModules.insert(L"iorate.sys");
	CommonModules.insert(L"mmcss.sys");
	CommonModules.insert(L"ahcache.sys");
	CommonModules.insert(L"CI.dll");
	CommonModules.insert(L"luafv.sys");
	CommonModules.insert(L"npsvctrig.sys");
	CommonModules.insert(L"Wof.sys");
	CommonModules.insert(L"fileinfo.sys");
	CommonModules.insert(L"wcifs.sys");
	CommonModules.insert(L"bindflt.sys");
}

// Function:    GetCallbackModule
// Description: Returns the module associated with a given callback address.
// Called from: GetCallbacks
PMODULE_INFO GetCallbackModule(PMODULE_INFO Modules, PVOID CallbackAddress)
{
	for (int i = 0; i < MAX_CALLBACKS; i++)
	{
		ULONG64 StartAddress = (ULONG64)Modules[i].Address;
		ULONG64 EndAddress = StartAddress + Modules[i].Size;

		if ((StartAddress <= (ULONG64)CallbackAddress) && ((ULONG64)CallbackAddress <= EndAddress))
			return &Modules[i];
	}

	return nullptr;
}

// Function:    GetQword
// Description: Calls the driver and returns the QWORD value at a given pointer.
// Called from: GetCallbacks when getting the original first bytes of a callback.
// Remarks:     This can be abused as a read primitive.
ULONG64 GetQword(PVOID Address)
{
	// Get a handle to the device.
	HANDLE DeviceHandle = GetDeviceHandle();
	if (DeviceHandle == (HANDLE)ERROR_INVALID_HANDLE)
		return NULL;

	// Get pointer.
	DWORD BytesReturned = 0;
	QWORD_INFO InputBuffer = { (PULONG64)Address, NULL };
	BOOL Status = DeviceIoControl(
		DeviceHandle,
		IOCTL_GET_QWORD,
		&InputBuffer, sizeof(QWORD_INFO),
		&InputBuffer, sizeof(QWORD_INFO),
		&BytesReturned, nullptr);
	CloseHandle(DeviceHandle);

	// Return pointer.
	return InputBuffer.Value;
}

// Function:    SetQword
// Description: Calls the driver and sets the QWORD value at a given pointer.
// Called from: SuppressCallback and RevertCallback.
// Remarks:     This can be abused as a write primitive.
BOOL SetQword(PVOID Address, ULONG64 Value)
{
	// Get a handle to the device.
	HANDLE DeviceHandle = GetDeviceHandle();
	if (DeviceHandle == (HANDLE)ERROR_INVALID_HANDLE)
		return FALSE;

	// Set byte.
	DWORD BytesReturned = 0;
	QWORD_INFO InputBuffer = { (PULONG64)Address, Value };
	BOOL Status = DeviceIoControl(
		DeviceHandle,
		IOCTL_SET_QWORD,
		&InputBuffer, sizeof(QWORD_INFO),
		nullptr, 0,
		&BytesReturned, nullptr);
	CloseHandle(DeviceHandle);

	// Return status.
	return Status;
}

// Function:    GetCallbacks
// Description: Returns a list of callback entries to be displayed in the list view.
// Called from: KmcLoadResults
std::vector<PCALLBACK_ENTRY> GetCallbacks(std::vector<PCALLBACK_ENTRY> OldCallbackEntries)
{
	std::vector<PCALLBACK_ENTRY> CallbackEntries;

	// Populate hashes.
	if (!CommonModules.size())
		PopulateKmcModules();

	// Get a handle to the device.
	HANDLE DeviceHandle = GetDeviceHandle();
	if (DeviceHandle == (HANDLE)ERROR_INVALID_HANDLE)
		return CallbackEntries;

	// Get module information.
	BOOL Status = 0;
	DWORD BytesReturned = 0;
	PMODULE_INFO ModuleInfos = (PMODULE_INFO)HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, sizeof(MODULE_INFO) * MAX_MODULES);
	Status = DeviceIoControl(
		DeviceHandle,
		IOCTL_GET_MODULES,
		ModuleInfos, sizeof(MODULE_INFO) * MAX_MODULES,
		ModuleInfos, sizeof(MODULE_INFO) * MAX_MODULES,
		&BytesReturned, nullptr);

	// Get callback information.
	PCALLBACK_INFO CallbackInfos = (PCALLBACK_INFO)HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, sizeof(CALLBACK_INFO) * MAX_CALLBACKS);
	Status = DeviceIoControl(
		DeviceHandle,
		IOCTL_GET_CALLBACKS,
		CallbackInfos, sizeof(CALLBACK_INFO) * MAX_CALLBACKS,
		CallbackInfos, sizeof(CALLBACK_INFO) * MAX_CALLBACKS,
		&BytesReturned, nullptr);
	CloseHandle(DeviceHandle);

	if (!BytesReturned)
	{
		HeapFree(GetProcessHeap(), NULL, ModuleInfos);
		HeapFree(GetProcessHeap(), NULL, CallbackInfos);
		return CallbackEntries;
	}

	for (int i = 0; i < MAX_CALLBACKS; i++)
	{
		if (CallbackInfos[i].Address)
		{
			// Populate callback information.
			PCALLBACK_ENTRY CallbackEntry = new CALLBACK_ENTRY;
			CallbackEntry->Type = CallbackInfos[i].Type;
			CallbackEntry->Address = CallbackInfos[i].Address;

			// Populate module information.
			PMODULE_INFO CallbackModule = GetCallbackModule(ModuleInfos, CallbackEntry->Address);
			if (CallbackModule)
			{
				MultiByteToWideChar(CP_ACP, MB_PRECOMPOSED, (PCCH)CallbackModule->Name, -1, (LPWSTR)CallbackEntry->ModuleName, MAX_PATH - 1);
				CallbackEntry->ModuleOffset = (ULONG64)CallbackEntry->Address - (ULONG64)CallbackModule->Address;
				if (!CommonModules.count(CallbackEntry->ModuleName))
					CallbackEntry->Notable = TRUE;
			}

			// Populate suppression information.
			ULONG64 SuppressionValue = GetSuppressionValue(CallbackEntry->Type);
			CallbackEntry->OriginalQword = GetQword(CallbackEntry->Address);
			CallbackEntry->Suppressed = (CallbackEntry->OriginalQword == SuppressionValue) ? TRUE : FALSE;
			if (CallbackEntry->OriginalQword == SuppressionValue) // Correct if there's an original non-ret byte.
				if (OldCallbackEntries.size())
					for (PCALLBACK_ENTRY OldEntry : OldCallbackEntries)
						if (CallbackEntry->Address == OldEntry->Address)
							if (OldEntry->OriginalQword != SuppressionValue)
								CallbackEntry->OriginalQword = OldEntry->OriginalQword;

			CallbackEntries.push_back(CallbackEntry);
		}
	}

	HeapFree(GetProcessHeap(), NULL, ModuleInfos);
	HeapFree(GetProcessHeap(), NULL, CallbackInfos);
	return CallbackEntries;
}

// Function:    GetSuppressionValue
// Description: Returns the appropriate patch value for the given callback type.
// Called from: GetCallbacks, SuppressCallback, and KmcRevertCallback.
ULONG64 GetSuppressionValue(CALLBACK_TYPE CallbackType)
{
	switch (CallbackType)
	{
	case CALLBACK_TYPE::PsLoadImage:
	case CALLBACK_TYPE::PsProcessCreation:
	case CALLBACK_TYPE::PsThreadCreation:
		return 0xC3;           // return; (ret)
	case CALLBACK_TYPE::CmRegistry:
	case CALLBACK_TYPE::ObProcessHandlePre:
	case CALLBACK_TYPE::ObProcessHandlePost:
	case CALLBACK_TYPE::ObThreadHandlePre:
	case CALLBACK_TYPE::ObThreadHandlePost:
	case CALLBACK_TYPE::ObDesktopHandlePre:
	case CALLBACK_TYPE::ObDesktopHandlePost:
	case CALLBACK_TYPE::MfCreatePost:
	case CALLBACK_TYPE::MfCreateNamedPipePost:
	case CALLBACK_TYPE::MfClosePost:
	case CALLBACK_TYPE::MfReadPost:
	case CALLBACK_TYPE::MfWritePost:
	case CALLBACK_TYPE::MfQueryInformationPost:
	case CALLBACK_TYPE::MfSetInformationPost:
	case CALLBACK_TYPE::MfQueryEaPost:
	case CALLBACK_TYPE::MfSetEaPost:
	case CALLBACK_TYPE::MfFlushBuffersPost:
	case CALLBACK_TYPE::MfQueryVolumeInformationPost:
	case CALLBACK_TYPE::MfSetVolumeInformationPost:
	case CALLBACK_TYPE::MfDirectoryControlPost:
	case CALLBACK_TYPE::MfFileSystemControlPost:
	case CALLBACK_TYPE::MfDeviceControlPost:
	case CALLBACK_TYPE::MfInternalDeviceControlPost:
	case CALLBACK_TYPE::MfShutdownPost:
	case CALLBACK_TYPE::MfLockControlPost:
	case CALLBACK_TYPE::MfCleanupPost:
	case CALLBACK_TYPE::MfCreateMailslotPost:
	case CALLBACK_TYPE::MfQuerySecurityPost:
	case CALLBACK_TYPE::MfSetSecurityPost:
	case CALLBACK_TYPE::MfPowerPost:
	case CALLBACK_TYPE::MfSystemControlPost:
	case CALLBACK_TYPE::MfDeviceChangePost:
	case CALLBACK_TYPE::MfQueryQuotaPost:
	case CALLBACK_TYPE::MfSetQuotaPost:
	case CALLBACK_TYPE::MfPnpPost:
		return 0xC3C033;       // return STATUS_SUCCESS; (xor eax, eax; ret)
	case CALLBACK_TYPE::MfCreatePre:
	case CALLBACK_TYPE::MfCreateNamedPipePre:
	case CALLBACK_TYPE::MfClosePre:
	case CALLBACK_TYPE::MfReadPre:
	case CALLBACK_TYPE::MfWritePre:
	case CALLBACK_TYPE::MfQueryInformationPre:
	case CALLBACK_TYPE::MfSetInformationPre:
	case CALLBACK_TYPE::MfQueryEaPre:
	case CALLBACK_TYPE::MfSetEaPre:
	case CALLBACK_TYPE::MfFlushBuffersPre:
	case CALLBACK_TYPE::MfQueryVolumeInformationPre:
	case CALLBACK_TYPE::MfSetVolumeInformationPre:
	case CALLBACK_TYPE::MfDirectoryControlPre:
	case CALLBACK_TYPE::MfFileSystemControlPre:
	case CALLBACK_TYPE::MfDeviceControlPre:
	case CALLBACK_TYPE::MfInternalDeviceControlPre:
	case CALLBACK_TYPE::MfShutdownPre:
	case CALLBACK_TYPE::MfLockControlPre:
	case CALLBACK_TYPE::MfCleanupPre:
	case CALLBACK_TYPE::MfCreateMailslotPre:
	case CALLBACK_TYPE::MfQuerySecurityPre:
	case CALLBACK_TYPE::MfSetSecurityPre:
	case CALLBACK_TYPE::MfPowerPre:
	case CALLBACK_TYPE::MfSystemControlPre:
	case CALLBACK_TYPE::MfDeviceChangePre:
	case CALLBACK_TYPE::MfQueryQuotaPre:
	case CALLBACK_TYPE::MfSetQuotaPre:
	case CALLBACK_TYPE::MfPnpPre:
		return 0xC300000001B8; // return FLT_PREOP_SUCCESS_NO_CALLBACK; (mov eax, 1; ret)
	default:
		return 0xC3;           // return; (ret)
	}
}

// Function:    SuppressCallback
// Description: Suppresses a given callback.
// Called from: KmcSuppressCallback
BOOL SuppressCallback(PCALLBACK_ENTRY Callback)
{
	return SetQword(Callback->Address, GetSuppressionValue(Callback->Type));
}

// Function:    RevertCallback
// Description: Reverts a given callback.
// Called from: KmcRevertCallback
// Remarks:     KmcRevertCallback checks for eligibility.
BOOL RevertCallback(PCALLBACK_ENTRY Callback)
{
	return SetQword(Callback->Address, Callback->OriginalQword);
}
```

`TelemetrySourcerer/KmCallbacks.h`:

```h
#pragma once

#include <vector>

#include "../TelemetrySourcererDriver/Common.h"

using namespace std;

// Struct:    CALLBACK_ENTRY
// Describes: A kernel-mode callback.
// Members:
// - Type:          The type of callback.
// - Address:       The address of the callback.
// - ModuleName:    The name of the module hosting the callback.
// - ModuleOffset:  The offset of the callback from the module's base address.
// - OriginalQword: The first 8 bytes of the callback.
// - Suppressed:    Whether the callback has been suppressed.
// - Notable:       Whether the callback should be highlighted.
typedef struct _CALLBACK_ENTRY
{
	CALLBACK_TYPE Type                 = CALLBACK_TYPE::Unknown;
	PVOID         Address              = nullptr;
	WCHAR         ModuleName[MAX_PATH] = { 0 };
	SIZE_T        ModuleOffset         = 0;
	ULONG64       OriginalQword        = 0;
	BOOL          Suppressed           = FALSE;
	BOOL          Notable              = FALSE;
} CALLBACK_ENTRY, *PCALLBACK_ENTRY;

DWORD LoadDriver();
DWORD UnloadDriver();
BOOL IsProcessElevated();
HANDLE GetDeviceHandle();
VOID PopulateKmcModules();
PMODULE_INFO GetCallbackModule(PMODULE_INFO Modules, PVOID CallbackAddress);
ULONG64 GetQword(PVOID Address);
BOOL SetQword(PVOID Address, ULONG64 Value);
std::vector<PCALLBACK_ENTRY> GetCallbacks(std::vector<PCALLBACK_ENTRY> OldCallbackEntries);
ULONG64 GetSuppressionValue(CALLBACK_TYPE CallbackType);
BOOL SuppressCallback(PCALLBACK_ENTRY Callback);
BOOL RevertCallback(PCALLBACK_ENTRY Callback);
```

`TelemetrySourcerer/Resource.h`:

```h
//{{NO_DEPENDENCIES}}
// Microsoft Visual C++ generated include file.
// Used by TelemetrySourcerer.rc

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        101
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1001
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif

```

`TelemetrySourcerer/TelemetrySourcerer.cpp`:

```cpp
#include <Windows.h>
#include <stdlib.h>
#include <string.h>
#include <tchar.h>
#include <commctrl.h>
#include <windowsx.h>
#include <strsafe.h>
#include <TlHelp32.h>

#include <string>

#include "TelemetrySourcerer.h"
#include "KmCallbacks.h"
#include "UmHooks.h"
#include "UmETW.h"

// ToDo: review visual styles before enabling.
//#pragma comment(linker,"\"/manifestdependency:type='win32' name='Microsoft.Windows.Common-Controls' version='6.0.0.0' processorArchitecture='*' publicKeyToken='6595b64144ccf1df' language='*'\"")

using namespace std;

// Global variables
HINSTANCE g_hInst;

struct WINDOW_HANDLES {
    HWND Main;
    HWND StatusBar;
    HWND TabControl;

    // Kernel-mode Callbacks
    HWND KmcPage;
    HWND KmcRefreshButton;
    HWND KmcSuppressButton;
    HWND KmcRevertButton;
    HWND KmcCountLabel;
    HWND KmcTipLabel;
    HWND KmcListView;

    // User-mode Hooks
    HWND UmhPage;
    HWND UmhRefreshButton;
    HWND UmhRestoreButton;
    HWND UmhLoadButton;
    HWND UmhCountLabel;
    HWND UmhTipLabel;
    HWND UmhListView;

    // User-mode ETW Traces
    HWND UmePage;
    HWND UmeRefreshButton;
    HWND UmeDisableButton;
    HWND UmeStopButton;
    HWND UmeCountLabel;
    HWND UmeTipLabel;
    HWND UmeListView;

    // About
    HWND AbtPage;
    HWND AbtLabel;
} wh;

struct WINDOW_DATA {
    std::vector<PCALLBACK_ENTRY> KmcCallbacks;
    std::vector<PLOADED_MODULE> UmhModules;
    std::vector<PTRACING_SESSION> UmeSessions;
} wd;

// Function:    WinMain
// Description: Entry point for the application.
int CALLBACK WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow)
{
    // The main window class name.
    static TCHAR szWindowClass[] = _T("DesktopApp");

    // The string that appears in the application's title bar.
    WCHAR szTitle[MAX_PATH] = { 0 };
    StringCbPrintfW(szTitle, MAX_PATH, L"%s v%s by @Jackson_T (%s %s)", TOOL_NAME, VERSION, _T(__DATE__), _T(__TIME__));

    WNDCLASSEX wcex;
    wcex.cbSize = sizeof(WNDCLASSEX);
    wcex.style = CS_HREDRAW | CS_VREDRAW;
    wcex.lpfnWndProc = MainWndProc;
    wcex.cbClsExtra = 0;
    wcex.cbWndExtra = 0;
    wcex.hInstance = hInstance;
    wcex.hIcon = LoadIcon(hInstance, IDI_APPLICATION);
    wcex.hCursor = LoadCursor(NULL, IDC_ARROW);
    wcex.hbrBackground = (HBRUSH)(COLOR_WINDOW + 1);
    wcex.lpszMenuName = NULL;
    wcex.lpszClassName = szWindowClass;
    wcex.hIconSm = LoadIcon(wcex.hInstance, IDI_APPLICATION);
    RegisterClassEx(&wcex);

    // Store instance handle in our global variable.
    g_hInst = hInstance;

    // Create the main window and show it.
    wh.Main = CreateWindowEx(
        NULL,
        szWindowClass,
        szTitle,
        WS_OVERLAPPEDWINDOW,
        CW_USEDEFAULT, CW_USEDEFAULT,
        900, 500,
        NULL,
        NULL,
        hInstance,
        NULL
    );
    ShowWindow(wh.Main, nCmdShow);
    UpdateWindow(wh.Main);

    // Main message loop:
    MSG msg;
    while (GetMessage(&msg, NULL, 0, 0))
    {
        TranslateMessage(&msg);
        DispatchMessage(&msg);
    }

    return (int)msg.wParam;
}

// Function:    MainWndProc
// Description: Processes messages for the main window.
LRESULT CALLBACK MainWndProc(HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam)
{
    LPMINMAXINFO lpMMI = (LPMINMAXINFO)lParam;

    switch (message)
    {
    case WM_CREATE:
    {
        PaintWindow(hWnd);

        KmcLoadResults();
        UmhLoadResults();
        UmeLoadResults();
        
        ShowWindow(wh.KmcPage, SW_SHOW);
        break;
    }
    case WM_DESTROY:
    {
        PostQuitMessage(0);
        break;
    }
    case WM_GETMINMAXINFO:
    {
        lpMMI->ptMinTrackSize.x = 900; // Set minimum dimensions to 900x500.
        lpMMI->ptMinTrackSize.y = 500;
        lpMMI->ptMaxTrackSize.x = 900; // Set maximum dimensions to 900x500.
        lpMMI->ptMaxTrackSize.y = 500;
        break;
    }
    case WM_SIZE:
    {
        ResizeWindow(hWnd);
        break;
    }
    case WM_NOTIFY:
    {
        switch (((LPNMHDR)lParam)->code)
        {
        case TCN_SELCHANGE:
        {
            DWORD TabIndex = TabCtrl_GetCurSel(wh.TabControl);
            ShowWindow(wh.KmcPage, (TabIndex == 0) ? SW_SHOW : SW_HIDE);
            ShowWindow(wh.UmhPage, (TabIndex == 1) ? SW_SHOW : SW_HIDE);
            ShowWindow(wh.UmePage, (TabIndex == 2) ? SW_SHOW : SW_HIDE);
            ShowWindow(wh.AbtPage, (TabIndex == 3) ? SW_SHOW : SW_HIDE);
            break;
        }
        }
        break;
    }
    case WM_CLOSE:
        UnloadDriver();
    default:
        return DefWindowProc(hWnd, message, wParam, lParam);
        break;
    }

    return 0;
}

// Function:    KmcWndProc
// Description: Processes messages for the kernel-mode callbacks tab.
LRESULT CALLBACK KmcWndProc(HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam)
{
    switch (message)
    {
    case WM_COMMAND:
    {
        switch (HIWORD(wParam))
        {
        case BN_CLICKED:
        {
            if (wh.KmcRefreshButton == (HWND)lParam)
                KmcLoadResults();
            else if (wh.KmcSuppressButton == (HWND)lParam)
                KmcSuppressCallback();
            else if (wh.KmcRevertButton == (HWND)lParam)
                KmcRevertCallback();
            break;
        }
        }
        break;
    }
    case WM_NOTIFY:
    {
        NMLVDISPINFO* plvdi;

        switch (((LPNMHDR)lParam)->code)
        {
        case LVN_GETDISPINFO:
        {
            plvdi = (NMLVDISPINFO*)lParam;
            PCALLBACK_ENTRY Callback = wd.KmcCallbacks.at(plvdi->item.lParam);
            LPWSTR Module = (LPWSTR)HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, MAX_PATH);
            StringCbPrintfW(Module, MAX_PATH, L"%ls + 0x%x", Callback->ModuleName, Callback->ModuleOffset);

            switch (plvdi->item.iSubItem)
            {
            case 0:
            {
                switch (Callback->Type)
                {
                case CALLBACK_TYPE::PsLoadImage:
                    plvdi->item.pszText = (LPWSTR)L"Image Load";
                    break;
                case CALLBACK_TYPE::PsProcessCreation:
                    plvdi->item.pszText = (LPWSTR)L"Process Creation";
                    break;
                case CALLBACK_TYPE::PsThreadCreation:
                    plvdi->item.pszText = (LPWSTR)L"Thread Creation";
                    break;
                case CALLBACK_TYPE::CmRegistry:
                    plvdi->item.pszText = (LPWSTR)L"Registry";
                    break;
                case CALLBACK_TYPE::ObProcessHandlePre:
                case CALLBACK_TYPE::ObProcessHandlePost:
                case CALLBACK_TYPE::ObThreadHandlePre:
                case CALLBACK_TYPE::ObThreadHandlePost:
                case CALLBACK_TYPE::ObDesktopHandlePre:
                case CALLBACK_TYPE::ObDesktopHandlePost:
                    plvdi->item.pszText = (LPWSTR)L"Object Handle";
                    break;
                case CALLBACK_TYPE::MfCreatePre:
                case CALLBACK_TYPE::MfCreatePost:
                case CALLBACK_TYPE::MfCreateNamedPipePre:
                case CALLBACK_TYPE::MfCreateNamedPipePost:
                case CALLBACK_TYPE::MfClosePre:
                case CALLBACK_TYPE::MfClosePost:
                case CALLBACK_TYPE::MfReadPre:
                case CALLBACK_TYPE::MfReadPost:
                case CALLBACK_TYPE::MfWritePre:
                case CALLBACK_TYPE::MfWritePost:
                case CALLBACK_TYPE::MfQueryInformationPre:
                case CALLBACK_TYPE::MfQueryInformationPost:
                case CALLBACK_TYPE::MfSetInformationPre:
                case CALLBACK_TYPE::MfSetInformationPost:
                case CALLBACK_TYPE::MfQueryEaPre:
                case CALLBACK_TYPE::MfQueryEaPost:
                case CALLBACK_TYPE::MfSetEaPre:
                case CALLBACK_TYPE::MfSetEaPost:
                case CALLBACK_TYPE::MfFlushBuffersPre:
                case CALLBACK_TYPE::MfFlushBuffersPost:
                case CALLBACK_TYPE::MfQueryVolumeInformationPre:
                case CALLBACK_TYPE::MfQueryVolumeInformationPost:
                case CALLBACK_TYPE::MfSetVolumeInformationPre:
                case CALLBACK_TYPE::MfSetVolumeInformationPost:
                case CALLBACK_TYPE::MfDirectoryControlPre:
                case CALLBACK_TYPE::MfDirectoryControlPost:
                case CALLBACK_TYPE::MfFileSystemControlPre:
                case CALLBACK_TYPE::MfFileSystemControlPost:
                case CALLBACK_TYPE::MfDeviceControlPre:
                case CALLBACK_TYPE::MfDeviceControlPost:
                case CALLBACK_TYPE::MfInternalDeviceControlPre:
                case CALLBACK_TYPE::MfInternalDeviceControlPost:
                case CALLBACK_TYPE::MfShutdownPre:
                case CALLBACK_TYPE::MfShutdownPost:
                case CALLBACK_TYPE::MfLockControlPre:
                case CALLBACK_TYPE::MfLockControlPost:
                case CALLBACK_TYPE::MfCleanupPre:
                case CALLBACK_TYPE::MfCleanupPost:
                case CALLBACK_TYPE::MfCreateMailslotPre:
                case CALLBACK_TYPE::MfCreateMailslotPost:
                case CALLBACK_TYPE::MfQuerySecurityPre:
                case CALLBACK_TYPE::MfQuerySecurityPost:
                case CALLBACK_TYPE::MfSetSecurityPre:
                case CALLBACK_TYPE::MfSetSecurityPost:
                case CALLBACK_TYPE::MfPowerPre:
                case CALLBACK_TYPE::MfPowerPost:
                case CALLBACK_TYPE::MfSystemControlPre:
                case CALLBACK_TYPE::MfSystemControlPost:
                case CALLBACK_TYPE::MfDeviceChangePre:
                case CALLBACK_TYPE::MfDeviceChangePost:
                case CALLBACK_TYPE::MfQueryQuotaPre:
                case CALLBACK_TYPE::MfQueryQuotaPost:
                case CALLBACK_TYPE::MfSetQuotaPre:
                case CALLBACK_TYPE::MfSetQuotaPost:
                case CALLBACK_TYPE::MfPnpPre:
                case CALLBACK_TYPE::MfPnpPost:
                    plvdi->item.pszText = (LPWSTR)L"File System";
                    break;
                default:
                    plvdi->item.pszText = (LPWSTR)L"Unknown";
                    break;
                }
                break;
            }
            case 1:
            {
                switch (Callback->Type)
                {
                case CALLBACK_TYPE::PsLoadImage:
                    plvdi->item.pszText = (LPWSTR)L"PsSetLoadImageNotifyRoutine";
                    break;
                case CALLBACK_TYPE::PsProcessCreation:
                    plvdi->item.pszText = (LPWSTR)L"PsSetCreateProcessNotifyRoutine";
                    break;
                case CALLBACK_TYPE::PsThreadCreation:
                    plvdi->item.pszText = (LPWSTR)L"PsSetCreateThreadNotifyRoutine";
                    break;
                case CALLBACK_TYPE::CmRegistry:
                    plvdi->item.pszText = (LPWSTR)L"CmRegisterCallbackEx";
                    break;
                case CALLBACK_TYPE::ObProcessHandlePre:
                    plvdi->item.pszText = (LPWSTR)L"PsProcessType (pre)";
                    break;
                case CALLBACK_TYPE::ObProcessHandlePost:
                    plvdi->item.pszText = (LPWSTR)L"PsProcessType (post)";
                    break;
                case CALLBACK_TYPE::ObThreadHandlePre:
                    plvdi->item.pszText = (LPWSTR)L"PsThreadType (pre)";
                    break;
                case CALLBACK_TYPE::ObThreadHandlePost:
                    plvdi->item.pszText = (LPWSTR)L"PsThreadType (post)";
                    break;
                case CALLBACK_TYPE::ObDesktopHandlePre:
                    plvdi->item.pszText = (LPWSTR)L"ExDesktopObjectType (pre)";
                    break;
                case CALLBACK_TYPE::ObDesktopHandlePost:
                    plvdi->item.pszText = (LPWSTR)L"ExDesktopObjectType (post)";
                    break;
                case CALLBACK_TYPE::MfCreatePre:
                    plvdi->item.pszText = (LPWSTR)L"IRP_MJ_CREATE (pre)";
                    break;
                case CALLBACK_TYPE::MfCreatePost:
                    plvdi->item.pszText = (LPWSTR)L"IRP_MJ_CREATE (post)";
                    break;
                case CALLBACK_TYPE::MfCreateNamedPipePre:
                    plvdi->item.pszText = (LPWSTR)L"IRP_MJ_CREATE_NAMED_PIPE (pre)";
                    break;
                case CALLBACK_TYPE::MfCreateNamedPipePost:
                    plvdi->item.pszText = (LPWSTR)L"IRP_MJ_CREATE_NAMED_PIPE (post)";
                    break;
                case CALLBACK_TYPE::MfClosePre:
                    plvdi->item.pszText = (LPWSTR)L"IRP_MJ_CLOSE (pre)";
                    break;
                case CALLBACK_TYPE::MfClosePost:
                    plvdi->item.pszText = (LPWSTR)L"IRP_MJ_CLOSE (post)";
                    break;
                case CALLBACK_TYPE::MfReadPre:
                    plvdi->item.pszText = (LPWSTR)L"IRP_MJ_READ (pre)";
                    break;
                case CALLBACK_TYPE::MfReadPost:
                    plvdi->item.pszText = (LPWSTR)L"IRP_MJ_READ (post)";
                    break;
                case CALLBACK_TYPE::MfWritePre:
                    plvdi->item.pszText = (LPWSTR)L"IRP_MJ_WRITE (pre)";
                    break;
                case CALLBACK_TYPE::MfWritePost:
                    plvdi->item.pszText = (LPWSTR)L"IRP_MJ_WRITE (post)";
                    break;
                case CALLBACK_TYPE::MfQueryInformationPre:
                    plvdi->item.pszText = (LPWSTR)L"IRP_MJ_QUERY_INFORMATION (pre)";
                    break;
                case CALLBACK_TYPE::MfQueryInformationPost:
                    plvdi->item.pszText = (LPWSTR)L"IRP_MJ_QUERY_INFORMATION (post)";
                    break;
                case CALLBACK_TYPE::MfSetInformationPre:
                    plvdi->item.pszText = (LPWSTR)L"IRP_MJ_SET_INFORMATION (pre)";
                    break;
                case CALLBACK_TYPE::MfSetInformationPost:
                    plvdi->item.pszText = (LPWSTR)L"IRP_MJ_SET_INFORMATION (post)";
                    break;
                case CALLBACK_TYPE::MfQueryEaPre:
                    plvdi->item.pszText = (LPWSTR)L"IRP_MJ_QUERY_EA (pre)";
                    break;
                case CALLBACK_TYPE::MfQueryEaPost:
                    plvdi->item.pszText = (LPWSTR)L"IRP_MJ_QUERY_EA (post)";
                    break;
                case CALLBACK_TYPE::MfSetEaPre:
                    plvdi->item.pszText = (LPWSTR)L"IRP_MJ_SET_EA (pre)";
                    break;
                case CALLBACK_TYPE::MfSetEaPost:
                    plvdi->item.pszText = (LPWSTR)L"IRP_MJ_SET_EA (post)";
                    break;
                case CALLBACK_TYPE::MfFlushBuffersPre:
                    plvdi->item.pszText = (LPWSTR)L"IRP_MJ_FLUSH_BUFFERS (pre)";
                    break;
                case CALLBACK_TYPE::MfFlushBuffersPost:
                    plvdi->item.pszText = (LPWSTR)L"IRP_MJ_FLUSH_BUFFERS (post)";
                    break;
                case CALLBACK_TYPE::MfQueryVolumeInformationPre:
                    plvdi->item.pszText = (LPWSTR)L"IRP_MJ_QUERY_VOLUME_INFORMATION (pre)";
                    break;
                case CALLBACK_TYPE::MfQueryVolumeInformationPost:
                    plvdi->item.pszText = (LPWSTR)L"IRP_MJ_QUERY_VOLUME_INFORMATION (post)";
                    break;
                case CALLBACK_TYPE::MfSetVolumeInformationPre:
                    plvdi->item.pszText = (LPWSTR)L"IRP_MJ_SET_VOLUME_INFORMATION (pre)";
                    break;
                case CALLBACK_TYPE::MfSetVolumeInformationPost:
                    plvdi->item.pszText = (LPWSTR)L"IRP_MJ_SET_VOLUME_INFORMATION (post)";
                    break;
                case CALLBACK_TYPE::MfDirectoryControlPre:
                    plvdi->item.pszText = (LPWSTR)L"IRP_MJ_DIRECTORY_CONTROL (pre)";
                    break;
                case CALLBACK_TYPE::MfDirectoryControlPost:
                    plvdi->item.pszText = (LPWSTR)L"IRP_MJ_DIRECTORY_CONTROL (post)";
                    break;
                case CALLBACK_TYPE::MfFileSystemControlPre:
                    plvdi->item.pszText = (LPWSTR)L"IRP_MJ_FILE_SYSTEM_CONTROL (pre)";
                    break;
                case CALLBACK_TYPE::MfFileSystemControlPost:
                    plvdi->item.pszText = (LPWSTR)L"IRP_MJ_FILE_SYSTEM_CONTROL (post)";
                    break;
                case CALLBACK_TYPE::MfDeviceControlPre:
                    plvdi->item.pszText = (LPWSTR)L"IRP_MJ_DEVICE_CONTROL (pre)";
                    break;
                case CALLBACK_TYPE::MfDeviceControlPost:
                    plvdi->item.pszText = (LPWSTR)L"IRP_MJ_DEVICE_CONTROL (post)";
                    break;
                case CALLBACK_TYPE::MfInternalDeviceControlPre:
                    plvdi->item.pszText = (LPWSTR)L"IRP_MJ_INTERNAL_DEVICE_CONTROL (pre)";
                    break;
                case CALLBACK_TYPE::MfInternalDeviceControlPost:
                    plvdi->item.pszText = (LPWSTR)L"IRP_MJ_INTERNAL_DEVICE_CONTROL (post)";
                    break;
                case CALLBACK_TYPE::MfShutdownPre:
                    plvdi->item.pszText = (LPWSTR)L"IRP_MJ_SHUTDOWN (pre)";
                    break;
                case CALLBACK_TYPE::MfShutdownPost:
                    plvdi->item.pszText = (LPWSTR)L"IRP_MJ_SHUTDOWN (post)";
                    break;
                case CALLBACK_TYPE::MfLockControlPre:
                    plvdi->item.pszText = (LPWSTR)L"IRP_MJ_LOCK_CONTROL (pre)";
                    break;
                case CALLBACK_TYPE::MfLockControlPost:
                    plvdi->item.pszText = (LPWSTR)L"IRP_MJ_LOCK_CONTROL (post)";
                    break;
                case CALLBACK_TYPE::MfCleanupPre:
                    plvdi->item.pszText = (LPWSTR)L"IRP_MJ_CLEANUP (pre)";
                    break;
                case CALLBACK_TYPE::MfCleanupPost:
                    plvdi->item.pszText = (LPWSTR)L"IRP_MJ_CLEANUP (post)";
                    break;
                case CALLBACK_TYPE::MfCreateMailslotPre:
                    plvdi->item.pszText = (LPWSTR)L"IRP_MJ_CREATE_MAILSLOT (pre)";
                    break;
                case CALLBACK_TYPE::MfCreateMailslotPost:
                    plvdi->item.pszText = (LPWSTR)L"IRP_MJ_CREATE_MAILSLOT (post)";
                    break;
                case CALLBACK_TYPE::MfQuerySecurityPre:
                    plvdi->item.pszText = (LPWSTR)L"IRP_MJ_QUERY_SECURITY (pre)";
                    break;
                case CALLBACK_TYPE::MfQuerySecurityPost:
                    plvdi->item.pszText = (LPWSTR)L"IRP_MJ_QUERY_SECURITY (post)";
                    break;
                case CALLBACK_TYPE::MfSetSecurityPre:
                    plvdi->item.pszText = (LPWSTR)L"IRP_MJ_SET_SECURITY (pre)";
                    break;
                case CALLBACK_TYPE::MfSetSecurityPost:
                    plvdi->item.pszText = (LPWSTR)L"IRP_MJ_SET_SECURITY (post)";
                    break;
                case CALLBACK_TYPE::MfPowerPre:
                    plvdi->item.pszText = (LPWSTR)L"IRP_MJ_POWER (pre)";
                    break;
                case CALLBACK_TYPE::MfPowerPost:
                    plvdi->item.pszText = (LPWSTR)L"IRP_MJ_POWER (post)";
                    break;
                case CALLBACK_TYPE::MfSystemControlPre:
                    plvdi->item.pszText = (LPWSTR)L"IRP_MJ_SYSTEM_CONTROL (pre)";
                    break;
                case CALLBACK_TYPE::MfSystemControlPost:
                    plvdi->item.pszText = (LPWSTR)L"IRP_MJ_SYSTEM_CONTROL (post)";
                    break;
                case CALLBACK_TYPE::MfDeviceChangePre:
                    plvdi->item.pszText = (LPWSTR)L"IRP_MJ_DEVICE_CHANGE (pre)";
                    break;
                case CALLBACK_TYPE::MfDeviceChangePost:
                    plvdi->item.pszText = (LPWSTR)L"IRP_MJ_DEVICE_CHANGE (post)";
                    break;
                case CALLBACK_TYPE::MfQueryQuotaPre:
                    plvdi->item.pszText = (LPWSTR)L"IRP_MJ_QUERY_QUOTA (pre)";
                    break;
                case CALLBACK_TYPE::MfQueryQuotaPost:
                    plvdi->item.pszText = (LPWSTR)L"IRP_MJ_QUERY_QUOTA (post)";
                    break;
                case CALLBACK_TYPE::MfSetQuotaPre:
                    plvdi->item.pszText = (LPWSTR)L"IRP_MJ_SET_QUOTA (pre)";
                    break;
                case CALLBACK_TYPE::MfSetQuotaPost:
                    plvdi->item.pszText = (LPWSTR)L"IRP_MJ_SET_QUOTA (post)";
                    break;
                case CALLBACK_TYPE::MfPnpPre:
                    plvdi->item.pszText = (LPWSTR)L"IRP_MJ_PNP (pre)";
                    break;
                case CALLBACK_TYPE::MfPnpPost:
                    plvdi->item.pszText = (LPWSTR)L"IRP_MJ_PNP (post)";
                    break;
                default:
                    plvdi->item.pszText = (LPWSTR)L"Unknown";
                    break;
                }
                break;
            }
            case 2:
            {
                plvdi->item.pszText = Module;
                break;
            }
            case 3:
            {
                plvdi->item.pszText = (Callback->Suppressed) ? (LPWSTR)L"Yes" : (LPWSTR)L"No";
                break;
            }
            case 4:
            {
                plvdi->item.pszText = (Callback->Notable) ? (LPWSTR)L"Yes" : (LPWSTR)L"No";
                break;
            }
            default:
                plvdi->item.pszText = (LPWSTR)L"N/A";
                break;
            }
        }
        case NM_CUSTOMDRAW:
        {
            LPNMLVCUSTOMDRAW lplvcd = (LPNMLVCUSTOMDRAW)lParam;

            BOOL IsNotable = FALSE;
            BOOL IsSuppressed = FALSE;
            ULONG CallbackIndex = lplvcd->nmcd.lItemlParam;

            if (wd.KmcCallbacks.size())
            {
                PCALLBACK_ENTRY Callback = wd.KmcCallbacks.at(CallbackIndex);
                
                if (Callback->Notable)
                    IsNotable = TRUE;

                if (Callback->Suppressed)
                    IsSuppressed = TRUE;
            }

            switch (lplvcd->nmcd.dwDrawStage)
            {
            case CDDS_PREPAINT:
                return CDRF_NOTIFYITEMDRAW;
            case CDDS_ITEMPREPAINT:
            {
                if (IsSuppressed)
                {
                    lplvcd->clrText = RGB(255, 255, 255);
                    lplvcd->clrTextBk = RGB(128, 128, 128);
                }
                else if (IsNotable)
                {
                    lplvcd->clrText = RGB(0, 0, 0);
                    lplvcd->clrTextBk = RGB(255, 255, 200);
                }
                else
                {
                    lplvcd->clrText = RGB(0, 0, 0);
                    lplvcd->clrTextBk = RGB(255, 255, 255);
                }
                return CDRF_NEWFONT;
            }
            case CDDS_SUBITEM | CDDS_ITEMPREPAINT:
                return CDRF_NEWFONT;
            }
            break;
        }
        case LVN_COLUMNCLICK:
        {
            LPNMLISTVIEW pnmv = (LPNMLISTVIEW)lParam;
            ListView_SortItems(wh.KmcListView, KmcCompareFunc, pnmv->iSubItem);
            break;
        }
        }
        break;
    }
    default:
        return DefWindowProc(hWnd, message, wParam, lParam);
        break;
    }

    return 0;
}

// Function:    UmhWndProc
// Description: Processes messages for the user-mode hooks tab.
LRESULT CALLBACK UmhWndProc(HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam)
{
    switch (message)
    {
    case WM_COMMAND:
    {
        switch (HIWORD(wParam))
        {
        case BN_CLICKED:
        {
            if (wh.UmhRefreshButton == (HWND)lParam)
                UmhLoadResults();
            else if (wh.UmhRestoreButton == (HWND)lParam)
                UmhRestoreFunction();
            else if (wh.UmhLoadButton == (HWND)lParam)
                UmhLoadDll();
            break;
        }
        }
        break;
    }
    case WM_NOTIFY:
    {
        NMLVDISPINFO* plvdi;

        switch (((LPNMHDR)lParam)->code)
        {
        case LVN_GETDISPINFO:
        {
            plvdi = (NMLVDISPINFO*)lParam;

            int ModuleIndex = HIWORD(plvdi->item.lParam);
            int FunctionIndex = LOWORD(plvdi->item.lParam);
            PLOADED_MODULE lm = wd.UmhModules.at(ModuleIndex);
            PHOOKED_FUNCTION hf = lm->HookedFunctions.at(FunctionIndex);

            LPWSTR Ordinal = (LPWSTR)HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, MAX_PATH);
            StringCbPrintfW(Ordinal, MAX_PATH, L"%d", hf->Ordinal);
            LPWSTR Address = (LPWSTR)HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, MAX_PATH);
            StringCbPrintfW(Address, MAX_PATH, L"0x%p", (ULONG64)hf->Address);

            switch (plvdi->item.iSubItem)
            {
            case 0:
                plvdi->item.pszText = (LPWSTR)lm->Path;
                break;
            case 1:
                plvdi->item.pszText = (LPWSTR)hf->Name;
                break;
            case 2:
                plvdi->item.pszText = Ordinal;
                break;
            case 3:
                plvdi->item.pszText = Address;
                break;
            default:
                plvdi->item.pszText = (LPWSTR)L"N/A";
                break;
            }
            break;
        }
        case LVN_COLUMNCLICK:
        {
            LPNMLISTVIEW pnmv = (LPNMLISTVIEW)lParam;
            ListView_SortItems(wh.UmhListView, UmhCompareFunc, pnmv->iSubItem);
            break;
        }
        }
        break;
    }
    default:
        return DefWindowProc(hWnd, message, wParam, lParam);
        break;
    }

    return 0;
}

// Function:    UmeWndProc
// Description: Processes messages for the ETW sessions tab.
LRESULT CALLBACK UmeWndProc(HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam)
{
    switch (message)
    {
    case WM_COMMAND:
    {
        switch (HIWORD(wParam))
        {
        case BN_CLICKED:
        {
            if (wh.UmeRefreshButton == (HWND)lParam)
                UmeLoadResults();
            else if (wh.UmeDisableButton == (HWND)lParam)
                UmeDisableSelectedProvider();
            else if (wh.UmeStopButton == (HWND)lParam)
                UmeStopTracingSession();
            break;
        }
        }
        break;
    }
    case WM_NOTIFY:
    {
        NMLVDISPINFO* plvdi;

        switch (((LPNMHDR)lParam)->code)
        {
        case LVN_GETDISPINFO:
        {
            plvdi = (NMLVDISPINFO*)lParam;

            int SessionIndex = HIWORD(plvdi->item.lParam);
            int ProviderIndex = LOWORD(plvdi->item.lParam);
            PTRACING_SESSION ts = wd.UmeSessions.at(SessionIndex);
            PTRACE_PROVIDER tp = ts->EnabledProviders.at(ProviderIndex);

            switch (plvdi->item.iSubItem)
            {
            case 0:
                plvdi->item.pszText = (LPWSTR)ts->InstanceName;
                break;
            case 1:
                plvdi->item.pszText = (LPWSTR)tp->ProviderName;
                break;
            case 2:
                plvdi->item.pszText = (ts->Notable || tp->Notable) ? (LPWSTR)L"Yes" : (LPWSTR)L"No";
                break;
            default:
                plvdi->item.pszText = (LPWSTR)L"N/A";
                break;
            }
            break;
        }
        case NM_CUSTOMDRAW:
        {
            LPNMLVCUSTOMDRAW lplvcd = (LPNMLVCUSTOMDRAW)lParam;

            BOOL IsNotable = FALSE;
            int SessionIndex = HIWORD(lplvcd->nmcd.lItemlParam);
            int ProviderIndex = LOWORD(lplvcd->nmcd.lItemlParam);

            if (wd.UmeSessions.size())
            {
                PTRACING_SESSION ts = wd.UmeSessions.at(SessionIndex);

                if (ts->Notable)
                    IsNotable = TRUE;
                else if (ts->EnabledProviders.size())
                    IsNotable = ts->EnabledProviders.at(ProviderIndex)->Notable;
            }

            switch (lplvcd->nmcd.dwDrawStage)
            {
            case CDDS_PREPAINT:
                return CDRF_NOTIFYITEMDRAW;
            case CDDS_ITEMPREPAINT:
            {
                if (IsNotable)
                {
                    lplvcd->clrText = RGB(0, 0, 0);
                    lplvcd->clrTextBk = RGB(255, 255, 200);
                }
                else
                {
                    lplvcd->clrText = RGB(0, 0, 0);
                    lplvcd->clrTextBk = RGB(255, 255, 255);
                }
                return CDRF_NEWFONT;
            }
            case CDDS_SUBITEM | CDDS_ITEMPREPAINT:
                return CDRF_NEWFONT;
            }
            break;
        }
        case LVN_COLUMNCLICK:
        {
            LPNMLISTVIEW pnmv = (LPNMLISTVIEW)lParam;
            ListView_SortItems(wh.UmeListView, UmeCompareFunc, pnmv->iSubItem);
            break;
        }
        }
        break;
    }
    default:
        return DefWindowProc(hWnd, message, wParam, lParam);
        break;
    }

    return 0;
}

// Function:    PaintWindow
// Description: Paints the main window.
// Called from: MainWndProc
VOID PaintWindow(HWND hWnd)
{
    // Get global instance.
    g_hInst = (HINSTANCE)GetWindowLongPtr(hWnd, GWLP_HINSTANCE);

    // Get bounding box for window.
    RECT rcMain;
    GetClientRect(hWnd, &rcMain);

    // Set font to default GUI font.
    LOGFONT lf;
    GetObject(GetStockObject(DEFAULT_GUI_FONT), sizeof(LOGFONT), &lf);
    HFONT hFont = CreateFont(
        lf.lfHeight, lf.lfWidth,
        lf.lfEscapement, lf.lfOrientation, lf.lfWeight,
        lf.lfItalic, lf.lfUnderline, lf.lfStrikeOut,
        lf.lfCharSet, lf.lfOutPrecision, lf.lfClipPrecision,
        lf.lfQuality, lf.lfPitchAndFamily, lf.lfFaceName);
    SendMessage(hWnd, WM_SETFONT, (WPARAM)hFont, TRUE);

    // Begin painting.
    PAINTSTRUCT ps;
    HDC hdc = BeginPaint(hWnd, &ps);

    // Status bar.
    wh.StatusBar = CreateWindowEx(
        NULL,                                   // no extended styles
        STATUSCLASSNAME,                        // name of status bar class
        (PCTSTR)NULL,                           // no text when first created
        WS_CHILD | WS_VISIBLE,                  // creates a visible child window
        0, 0, 0, 0,                             // ignores size and position
        hWnd,                                   // handle to parent window
        (HMENU)0,                               // child window identifier
        g_hInst,                                // handle to application instance
        NULL);                                  // no window creation data
    SendMessage(wh.StatusBar, SB_SETTEXT, (WPARAM)0, (LPARAM)L"Ready");

    // Tab control.
    wh.TabControl = CreateWindowEx(
        NULL,                                    // Extended styles
        WC_TABCONTROL,                           // Predefined class; Unicode assumed 
        L"",                                     // Control text 
        WS_CHILD | WS_CLIPSIBLINGS | WS_VISIBLE, // Styles 
        0,                                       // X position 
        0,                                       // Y position 
        rcMain.right,                            // Control width
        rcMain.bottom - 22,                      // Control height
        hWnd,                                    // Parent window
        NULL,                                    // No menu.
        g_hInst,                                 // Global instance handle
        NULL);                                   // Pointer not needed
    SendMessage(wh.TabControl, WM_SETFONT, (WPARAM)hFont, TRUE);

    /**
     * Kernel-mode Callbacks
     */

    TCITEM tie;
    tie.mask = TCIF_TEXT;
    tie.pszText = (LPWSTR)L"Kernel-mode Callbacks";
    TabCtrl_InsertItem(wh.TabControl, 0, &tie);
    wh.KmcPage = CreateWindowEx(
        NULL,
        WC_STATIC,
        L"",
        WS_CHILD | WS_VISIBLE,
        0,
        25,
        rcMain.right - 5,
        rcMain.bottom - 55,
        wh.TabControl,
        NULL,
        g_hInst,
        NULL);
    SetWindowLongPtr(wh.KmcPage, GWLP_WNDPROC, (LONG_PTR)KmcWndProc);

    wh.KmcRefreshButton = CreateWindowEx(
        NULL,
        L"BUTTON",
        L"Refresh Results",
        WS_TABSTOP | WS_VISIBLE | WS_CHILD | BS_DEFPUSHBUTTON,
        5,
        5,
        100,
        30,
        wh.KmcPage,
        (HMENU)1,
        g_hInst,
        NULL);
    SendMessage(wh.KmcRefreshButton, WM_SETFONT, (WPARAM)hFont, TRUE);

    wh.KmcSuppressButton = CreateWindowEx(
        NULL,
        L"BUTTON",
        L"Suppress Callback",
        WS_TABSTOP | WS_VISIBLE | WS_CHILD | BS_DEFPUSHBUTTON,
        110,
        5,
        100,
        30,
        wh.KmcPage,
        NULL,
        g_hInst,
        NULL);
    SendMessage(wh.KmcSuppressButton, WM_SETFONT, (WPARAM)hFont, TRUE);

    wh.KmcRevertButton = CreateWindowEx(
        NULL,
        L"BUTTON",
        L"Revert Callback",
        WS_TABSTOP | WS_VISIBLE | WS_CHILD | BS_DEFPUSHBUTTON,
        215,
        5,
        100,
        30,
        wh.KmcPage,
        NULL,
        g_hInst,
        NULL);
    SendMessage(wh.KmcRevertButton, WM_SETFONT, (WPARAM)hFont, TRUE);

    wh.KmcCountLabel = CreateWindowEx(
        NULL,
        WC_STATIC,
        L"Count: 0 callbacks.",
        WS_CHILD | WS_VISIBLE,
        320,
        5,
        350,
        15,
        wh.KmcPage,
        NULL,
        g_hInst,
        NULL);
    SendMessage(wh.KmcCountLabel, WM_SETFONT, (WPARAM)hFont, TRUE);

    wh.KmcTipLabel = CreateWindowEx(
        NULL,
        WC_STATIC,
        L"Tip: No results? Run elevated to load the driver.",
        WS_CHILD | WS_VISIBLE,
        320,
        20,
        250,
        15,
        wh.KmcPage,
        NULL,
        g_hInst,
        NULL);
    SendMessage(wh.KmcTipLabel, WM_SETFONT, (WPARAM)hFont, TRUE);

    wh.KmcListView = CreateWindowEx(
        NULL,
        WC_LISTVIEW,
        L"",
        WS_CHILD | WS_VISIBLE | WS_BORDER | LVS_REPORT | LVS_SINGLESEL,
        5,
        40,
        rcMain.right - 15,
        rcMain.bottom - 100,
        wh.KmcPage,
        (HMENU)0,
        g_hInst,
        NULL);
    ListView_SetExtendedListViewStyle(wh.KmcListView, LVS_EX_FULLROWSELECT);

    LVCOLUMN lvc = { 0 };
    lvc.mask = LVCF_FMT | LVCF_WIDTH | LVCF_TEXT | LVCF_SUBITEM;
    lvc.iSubItem = 0;
    lvc.pszText = (LPWSTR)L"Collection Type";
    lvc.cx = 150;
    ListView_InsertColumn(wh.KmcListView, 0, &lvc);

    lvc.iSubItem = 1;
    lvc.pszText = (LPWSTR)L"Callback Type";
    lvc.cx = 300;
    ListView_InsertColumn(wh.KmcListView, 1, &lvc);

    lvc.iSubItem = 2;
    lvc.pszText = (LPWSTR)L"Module";
    lvc.cx = 200;
    ListView_InsertColumn(wh.KmcListView, 2, &lvc);

    lvc.iSubItem = 3;
    lvc.pszText = (LPWSTR)L"Is Suppressed?";
    lvc.cx = 100;
    ListView_InsertColumn(wh.KmcListView, 3, &lvc);

    lvc.iSubItem = 4;
    lvc.pszText = (LPWSTR)L"Is Notable?";
    lvc.cx = 100;
    ListView_InsertColumn(wh.KmcListView, 4, &lvc);

    /**
     * User-mode Hooks
     */

    tie.pszText = (LPWSTR)L"User-mode Hooks";
    TabCtrl_InsertItem(wh.TabControl, 1, &tie);
    wh.UmhPage = CreateWindowEx(
        NULL,
        WC_STATIC,
        L"",
        WS_CHILD | WS_VISIBLE,
        0,
        25,
        rcMain.right - 5,
        rcMain.bottom - 55,
        wh.TabControl,
        NULL,
        g_hInst,
        NULL);
    SetWindowLongPtr(wh.UmhPage, GWLP_WNDPROC, (LONG_PTR)UmhWndProc);

    wh.UmhRefreshButton = CreateWindowEx(
        NULL,
        L"BUTTON",
        L"Refresh Results",
        WS_TABSTOP | WS_VISIBLE | WS_CHILD | BS_DEFPUSHBUTTON,
        5,
        5,
        100,
        30,
        wh.UmhPage,
        NULL,
        g_hInst,
        NULL);
    SendMessage(wh.UmhRefreshButton, WM_SETFONT, (WPARAM)hFont, TRUE);

    wh.UmhRestoreButton = CreateWindowEx(
        NULL,
        L"BUTTON",
        L"Restore Function",
        WS_TABSTOP | WS_VISIBLE | WS_CHILD | BS_DEFPUSHBUTTON,
        110,
        5,
        100,
        30,
        wh.UmhPage,
        NULL,
        g_hInst,
        NULL);
    SendMessage(wh.UmhRestoreButton, WM_SETFONT, (WPARAM)hFont, TRUE);

    wh.UmhLoadButton = CreateWindowEx(
        NULL,
        L"BUTTON",
        L"Load Testing DLL",
        WS_TABSTOP | WS_VISIBLE | WS_CHILD | BS_DEFPUSHBUTTON,
        215,
        5,
        100,
        30,
        wh.UmhPage,
        NULL,
        g_hInst,
        NULL);
    SendMessage(wh.UmhLoadButton, WM_SETFONT, (WPARAM)hFont, TRUE);

    wh.UmhCountLabel = CreateWindowEx(
        NULL,
        WC_STATIC,
        L"Count: 0 hooked functions.",
        WS_CHILD | WS_VISIBLE,
        320,
        5,
        350,
        15,
        wh.UmhPage,
        NULL,
        g_hInst,
        NULL);
    SendMessage(wh.UmhCountLabel, WM_SETFONT, (WPARAM)hFont, TRUE);

    wh.UmhTipLabel = CreateWindowEx(
        NULL,
        WC_STATIC,
        L"Tip: Validate unhooking by loading a test DLL.",
        WS_CHILD | WS_VISIBLE,
        320,
        20,
        250,
        15,
        wh.UmhPage,
        NULL,
        g_hInst,
        NULL);
    SendMessage(wh.UmhTipLabel, WM_SETFONT, (WPARAM)hFont, TRUE);

    wh.UmhListView = CreateWindowEx(
        NULL,
        WC_LISTVIEW,
        L"",
        WS_CHILD | WS_VISIBLE | WS_BORDER | LVS_REPORT | LVS_SINGLESEL,
        5,
        40,
        rcMain.right - 15,
        rcMain.bottom - 100,
        wh.UmhPage,
        (HMENU)0,
        g_hInst,
        NULL);
    ListView_SetExtendedListViewStyle(wh.UmhListView, LVS_EX_FULLROWSELECT);

    lvc.iSubItem = 0;
    lvc.pszText = (LPWSTR)L"Module";
    lvc.cx = 250;
    ListView_InsertColumn(wh.UmhListView, 0, &lvc);

    lvc.iSubItem = 1;
    lvc.pszText = (LPWSTR)L"Function Name";
    lvc.cx = 300;
    ListView_InsertColumn(wh.UmhListView, 1, &lvc);

    lvc.iSubItem = 2;
    lvc.pszText = (LPWSTR)L"Ordinal";
    lvc.cx = 100;
    ListView_InsertColumn(wh.UmhListView, 2, &lvc);

    lvc.iSubItem = 3;
    lvc.pszText = (LPWSTR)L"Virtual Address";
    lvc.cx = 200;
    ListView_InsertColumn(wh.UmhListView, 3, &lvc);

    /**
     * ETW Trace Sessions
     */

    tie.pszText = (LPWSTR)L"ETW Trace Sessions";
    TabCtrl_InsertItem(wh.TabControl, 2, &tie);
    wh.UmePage = CreateWindowEx(
        NULL,
        WC_STATIC,
        L"",
        WS_CHILD | WS_VISIBLE,
        0,
        25,
        rcMain.right - 5,
        rcMain.bottom - 55,
        wh.TabControl,
        NULL,
        g_hInst,
        NULL);
    SetWindowLongPtr(wh.UmePage, GWLP_WNDPROC, (LONG_PTR)UmeWndProc);

    wh.UmeRefreshButton = CreateWindowEx(
        NULL,
        L"BUTTON",
        L"Refresh Results",
        WS_TABSTOP | WS_VISIBLE | WS_CHILD | BS_DEFPUSHBUTTON,
        5,
        5,
        100,
        30,
        wh.UmePage,
        NULL,
        g_hInst,
        NULL);
    SendMessage(wh.UmeRefreshButton, WM_SETFONT, (WPARAM)hFont, TRUE);

    wh.UmeDisableButton = CreateWindowEx(
        NULL,
        L"BUTTON",
        L"Disable Provider",
        WS_TABSTOP | WS_VISIBLE | WS_CHILD | BS_DEFPUSHBUTTON,
        110,
        5,
        100,
        30,
        wh.UmePage,
        NULL,
        g_hInst,
        NULL);
    SendMessage(wh.UmeDisableButton, WM_SETFONT, (WPARAM)hFont, TRUE);

    wh.UmeStopButton = CreateWindowEx(
        NULL,
        L"BUTTON",
        L"Stop Session",
        WS_TABSTOP | WS_VISIBLE | WS_CHILD | BS_DEFPUSHBUTTON,
        215,
        5,
        100,
        30,
        wh.UmePage,
        NULL,
        g_hInst,
        NULL);
    SendMessage(wh.UmeStopButton, WM_SETFONT, (WPARAM)hFont, TRUE);

    wh.UmeCountLabel = CreateWindowEx(
        NULL,
        WC_STATIC,
        L"Count: 0 sessions.",
        WS_CHILD | WS_VISIBLE,
        320,
        5,
        350,
        15,
        wh.UmePage,
        NULL,
        g_hInst,
        NULL);
    SendMessage(wh.UmeCountLabel, WM_SETFONT, (WPARAM)hFont, TRUE);

    wh.UmeTipLabel = CreateWindowEx(
        NULL,
        WC_STATIC,
        L"Tip: Missing results? Run as SYSTEM to view more sessions.",
        WS_CHILD | WS_VISIBLE,
        320,
        20,
        300,
        15,
        wh.UmePage,
        NULL,
        g_hInst,
        NULL);
    SendMessage(wh.UmeTipLabel, WM_SETFONT, (WPARAM)hFont, TRUE);

    wh.UmeListView = CreateWindowEx(
        NULL,
        WC_LISTVIEW,
        L"",
        WS_CHILD | WS_VISIBLE | WS_BORDER | LVS_REPORT | LVS_SINGLESEL,
        5,
        40,
        rcMain.right - 15,
        rcMain.bottom - 100,
        wh.UmePage,
        (HMENU)0,
        g_hInst,
        NULL);
    ListView_SetExtendedListViewStyle(wh.UmeListView, LVS_EX_FULLROWSELECT);

    lvc.iSubItem = 0;
    lvc.pszText = (LPWSTR)L"Session";
    lvc.cx = 300;
    ListView_InsertColumn(wh.UmeListView, 0, &lvc);

    lvc.iSubItem = 1;
    lvc.pszText = (LPWSTR)L"Enabled Provider";
    lvc.cx = 300;
    ListView_InsertColumn(wh.UmeListView, 1, &lvc);

    lvc.iSubItem = 2;
    lvc.pszText = (LPWSTR)L"Is Notable?";
    lvc.cx = 100;
    ListView_InsertColumn(wh.UmeListView, 2, &lvc);

    /**
     * About Page
     */

    tie.pszText = (LPWSTR)L"About";
    TabCtrl_InsertItem(wh.TabControl, 3, &tie);
    wh.AbtPage = CreateWindowEx(
        NULL,
        WC_STATIC,
        L"",
        WS_CHILD | WS_VISIBLE, // | WS_BORDER,
        0,
        25,
        rcMain.right - 5,
        rcMain.bottom - 55,
        wh.TabControl,
        NULL,
        g_hInst,
        NULL);

    wh.AbtLabel = CreateWindowEx(
        NULL,
        WC_STATIC,
        L"Telemetry Sourcerer is a utility that can be used to enumerate "
        L"and disable common sources of events used by endpoint security "
        L"products (AV/EDR).\n\n"
        L"Developed by @Jackson_T (2020), leveraging code from @gentilkiwi, "
        L"@fdiskyou, and @0x00dtm. Licenced under the Apache License v2.0.\n\n"
        L"Use of this tool is intended for research purposes only and does "
        L"not attempt to be OPSEC-safe.\n\n"
        L"Code: github.com/jthuraisamy/TelemetrySourcerer\n"
        L"Methodology: jackson-t.ca/edr-reversing-evading-01.html\n",
        WS_CHILD | WS_VISIBLE | SS_CENTER,
        5,
        150,
        rcMain.right - 10,
        rcMain.bottom - 60,
        wh.AbtPage,
        NULL,
        g_hInst,
        NULL);
    SendMessage(wh.AbtLabel, WM_SETFONT, (WPARAM)hFont, TRUE);

    // END PAINTING
    ShowWindow(wh.UmhPage, SW_HIDE);
    ShowWindow(wh.UmePage, SW_HIDE);
    ShowWindow(wh.AbtPage, SW_HIDE);
    ShowWindow(wh.KmcPage, SW_HIDE);
    EndPaint(hWnd, &ps);
}

// Function:    ResizeWindow
// Description: Handles window resizes (currently not supported).
// Called from: MainWndProc
VOID ResizeWindow(HWND hWnd)
{
    RECT rcClient;
    GetClientRect(hWnd, &rcClient);

    SetWindowPos(wh.TabControl, HWND_TOP, 0, 0, rcClient.right, rcClient.bottom - 22, SWP_SHOWWINDOW);
    SetWindowPos(wh.KmcPage, HWND_TOP, 0, 25, rcClient.right - 5, rcClient.bottom - 40, SWP_SHOWWINDOW);
    SetWindowPos(wh.StatusBar, NULL, 0, rcClient.bottom - 10, rcClient.right, 10, SWP_NOZORDER);
}

// Function:    KmcLoadResults
// Description: Loads kernel-mode callback results.
// Called from: MainWndProc after painting, and KmcWndProc when clicking the refresh button.
VOID KmcLoadResults()
{
    DWORD DriverStatus = LoadDriver();
    switch (DriverStatus)
    {
    case ERROR_FILE_NOT_FOUND:
        MessageBox(
            NULL,
            L"Could not find TelemetrySourcererDriver.sys.\n\n"
            L"Please ensure it is in the same directory as the executable.",
            TOOL_NAME,
            MB_ICONERROR);
        break;
    case ERROR_INVALID_IMAGE_HASH:
        MessageBox(
            NULL,
            L"The signature for the driver failed verification.\n\n"
            L"To load kernel-mode callback results, either enable test signing, "
            L"or sign this driver with a valid certificate.",
            TOOL_NAME,
            MB_ICONERROR);
        break;
    default:
        break;
    }

    SendMessage(wh.StatusBar, SB_SETTEXT, (WPARAM)0, (LPARAM)L"Loading kernel-mode callbacks...");

    // Delete rows and fetch latest results.
    ListView_DeleteAllItems(wh.KmcListView);
    wd.KmcCallbacks = GetCallbacks(wd.KmcCallbacks);
    DWORD ListItemCount = 0;

    for (int CallbackIndex = 0; CallbackIndex < wd.KmcCallbacks.size(); CallbackIndex++)
    {
        
        LVITEM lvi = { 0 };
        lvi.pszText = LPSTR_TEXTCALLBACK; // Sends an LVN_GETDISPINFO message.
        lvi.mask = LVIF_TEXT | LVIF_STATE | LVIF_PARAM;
        lvi.stateMask = 0;
        lvi.iSubItem = 0;
        lvi.state = 0;
        lvi.iItem = ListItemCount++;
        lvi.lParam = CallbackIndex;

        ListView_InsertItem(wh.KmcListView, &lvi);
    }

    LPWSTR CountText = (LPWSTR)HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, MAX_PATH);
    StringCbPrintfW(CountText, MAX_PATH, L"Count: %d callbacks.", wd.KmcCallbacks.size());
    Static_SetText(wh.KmcCountLabel, CountText);

    // Default sort by notable items.
    ListView_SortItems(wh.KmcListView, KmcCompareFunc, 4);

    SendMessage(wh.StatusBar, SB_SETTEXT, (WPARAM)0, (LPARAM)L"Ready");
}

// Function:    KmcCompareFunc
// Description: Sorts the kernel-mode callbacks list view depending on the column.
// Called from: KmcWndProc when clicking a column header of the callbacks list view.
int CALLBACK KmcCompareFunc(LPARAM lParam1, LPARAM lParam2, LPARAM lParamSort)
{
    int nRetVal = 0;

    PCALLBACK_ENTRY Item1Callback = wd.KmcCallbacks.at(lParam1);
    PCALLBACK_ENTRY Item2Callback = wd.KmcCallbacks.at(lParam2);

    switch (lParamSort)
    {
    case 0: // Collection Type
    case 1: // Callback Type
        if (Item1Callback->Type > Item2Callback->Type)
            nRetVal = 1;
        else if (Item1Callback->Type < Item2Callback->Type)
            nRetVal = -1;
        else
            nRetVal = 0;
        break;

    case 2: // Module
        nRetVal = wcscmp(Item1Callback->ModuleName, Item2Callback->ModuleName);
        break;

    case 3: // Is Suppressed?
        nRetVal = (Item1Callback->Suppressed == Item2Callback->Suppressed) ? 0 : (Item1Callback->Suppressed) ? -1 : (Item2Callback->Suppressed) ? 1 : 0;
        break;

    case 4: // Is Notable?
        nRetVal = (Item1Callback->Notable == Item2Callback->Notable) ? 0 : (Item1Callback->Notable) ? -1 : (Item2Callback->Notable) ? 1 : 0;
        break;

    default:
        break;
    }

    return nRetVal;
}

// Function:    KmcSuppressCallback
// Description: Suppresses the selected callback (if eligible).
// Called from: KmcWndProc when clicking the suppress button.
VOID KmcSuppressCallback()
{
    int SelectedIndex = ListView_GetNextItem(wh.KmcListView, -1, LVNI_SELECTED);

    if (SelectedIndex != -1)
    {
        LVITEM lvi = { 0 };
        lvi.mask = LVIF_PARAM;
        lvi.iItem = SelectedIndex;
        lvi.iSubItem = 0;
        ListView_GetItem(wh.KmcListView, &lvi);

        PCALLBACK_ENTRY Callback = wd.KmcCallbacks.at(lvi.lParam);
        WCHAR MessageTitle[MAX_PATH] = { 0 };
        StringCbPrintfW(MessageTitle, MAX_PATH, L"%ls + 0x%x", Callback->ModuleName, Callback->ModuleOffset);

        if (SuppressCallback(Callback))
        {
            Callback->Suppressed = TRUE;
            MessageBox(NULL, L"Successfully suppressed callback!", MessageTitle, MB_OK | MB_ICONINFORMATION);
            KmcLoadResults();
            ListView_EnsureVisible(wh.KmcListView, SelectedIndex, FALSE);
        }
        else
        {
            MessageBox(NULL, L"Callback could not be suppressed for unspecified reason.", MessageTitle, MB_OK | MB_ICONERROR);
        }
    }
}

// Function:    KmcRevertCallback
// Description: Reverts the selected callback (if suppressed/eligible).
// Called from: KmcWndProc when clicking the revert button.
VOID KmcRevertCallback()
{
    int SelectedIndex = ListView_GetNextItem(wh.KmcListView, -1, LVNI_SELECTED);

    if (SelectedIndex != -1)
    {
        LVITEM lvi = { 0 };
        lvi.mask = LVIF_PARAM;
        lvi.iItem = SelectedIndex;
        lvi.iSubItem = 0;
        ListView_GetItem(wh.KmcListView, &lvi);

        PCALLBACK_ENTRY Callback = wd.KmcCallbacks.at(lvi.lParam);
        WCHAR MessageTitle[MAX_PATH] = { 0 };
        StringCbPrintfW(MessageTitle, MAX_PATH, L"%ls + 0x%x", &Callback->ModuleName, Callback->ModuleOffset);

        if (Callback->Suppressed)
        {
            if (Callback->OriginalQword == GetSuppressionValue(Callback->Type))
            {
                MessageBox(NULL, L"The callback could not be reverted because the function's original first bytes are unknown.", MessageTitle, MB_OK | MB_ICONERROR);
            }
            else if (RevertCallback(Callback))
            {
                Callback->Suppressed = FALSE;
                MessageBox(NULL, L"Successfully reverted callback!", MessageTitle, MB_OK | MB_ICONINFORMATION);
                KmcLoadResults();
                ListView_EnsureVisible(wh.KmcListView, SelectedIndex, FALSE);
            }
            else
            {
                MessageBox(NULL, L"Callback could not be reverted for unspecified reason.", MessageTitle, MB_OK | MB_ICONERROR);
            }
        }
        else
        {
            MessageBox(NULL, L"The selected callback is currently not suppressed.", MessageTitle, MB_OK | MB_ICONERROR);
        }
    }
}

// Function:    UmhLoadResults
// Description: Loads user-mode inline hook results.
// Called from: MainWndProc after painting, and UmhWndProc when clicking the refresh button.
VOID UmhLoadResults()
{
    SendMessage(wh.StatusBar, SB_SETTEXT, (WPARAM)0, (LPARAM)L"Loading user-mode hooks...");

    // Delete rows and fetch latest results.
    ListView_DeleteAllItems(wh.UmhListView);
    wd.UmhModules = CheckAllModulesForHooks();
    DWORD ListItemCount = 0;

    for (int ModuleIndex = 0; ModuleIndex < wd.UmhModules.size(); ModuleIndex++)
    {
        PLOADED_MODULE lm = wd.UmhModules.at(ModuleIndex);

        for (int FunctionIndex = 0; FunctionIndex < lm->HookedFunctions.size(); FunctionIndex++)
        {
            LVITEM lvi = { 0 };
            lvi.pszText = LPSTR_TEXTCALLBACK; // Sends an LVN_GETDISPINFO message.
            lvi.mask = LVIF_TEXT | LVIF_STATE | LVIF_PARAM;
            lvi.stateMask = 0;
            lvi.iSubItem = 0;
            lvi.state = 0;
            lvi.iItem = ListItemCount++;
            lvi.lParam = (ModuleIndex << 16) | FunctionIndex;

            ListView_InsertItem(wh.UmhListView, &lvi);
        }
    }

    LPWSTR CountText = (LPWSTR)HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, MAX_PATH);
    StringCbPrintfW(CountText, MAX_PATH, L"Count: %d hooked functions.", ListItemCount);
    Static_SetText(wh.UmhCountLabel, CountText);

    SendMessage(wh.StatusBar, SB_SETTEXT, (WPARAM)0, (LPARAM)L"Ready");
}

// Function:    UmhCompareFunc
// Description: Sorts the hooked function list view depending on the column.
// Called from: UmhWndProc when clicking a column header of the hooked function list view.
int CALLBACK UmhCompareFunc(LPARAM lParam1, LPARAM lParam2, LPARAM lParamSort)
{
    int nRetVal = 0;

    PLOADED_MODULE Item1Module = wd.UmhModules.at(HIWORD(lParam1));
    PLOADED_MODULE Item2Module = wd.UmhModules.at(HIWORD(lParam2));
    PHOOKED_FUNCTION Item1Function = Item1Module->HookedFunctions.at(LOWORD(lParam1));
    PHOOKED_FUNCTION Item2Function = Item2Module->HookedFunctions.at(LOWORD(lParam2));

    switch (lParamSort)
    {
    case 0:	// Module
        nRetVal = wcscmp(Item1Module->Path, Item2Module->Path);
        break;

    case 1:	// Function Name
        nRetVal = wcscmp(Item1Function->Name, Item2Function->Name);
        break;

    default:
        break;
    }

    return nRetVal;
}

// Function:    UmhRestoreFunction
// Description: Unhooks the selected function.
// Called from: UmhWndProc when clicking the restore button.
VOID UmhRestoreFunction()
{
    int SelectedIndex = ListView_GetNextItem(wh.UmhListView, -1, LVNI_SELECTED);

    if (SelectedIndex != -1)
    {
        LVITEM lvi = { 0 };
        lvi.mask = LVIF_PARAM;
        lvi.iItem = SelectedIndex;
        lvi.iSubItem = 0;
        ListView_GetItem(wh.UmhListView, &lvi);

        int ModuleIndex = HIWORD(lvi.lParam);
        int FunctionIndex = LOWORD(lvi.lParam);

        PLOADED_MODULE Module = wd.UmhModules.at(ModuleIndex);
        PHOOKED_FUNCTION Function = Module->HookedFunctions.at(FunctionIndex);

        WCHAR MessageTitle[MAX_PATH] = { 0 };
        StringCbPrintfW(MessageTitle, MAX_PATH, L"%ls: %ls", Module->Path, Function->Name);
        if (RestoreHookedFunction(Function))
            MessageBox(NULL, L"Successfully unhooked function!", MessageTitle, MB_OK | MB_ICONINFORMATION);
        else
            MessageBox(NULL, L"Function could not be unhooked for unspecified reason.", MessageTitle, MB_OK | MB_ICONERROR);

        UmhLoadResults();
        ListView_EnsureVisible(wh.UmhListView, SelectedIndex, FALSE);
    }
}

// Function:    UmhLoadDll
// Description: Loads a testing DLL to validate unhooking efficacy.
// Called from: UmhWndProc when clicking the load DLL button.
VOID UmhLoadDll()
{
    SendMessage(wh.StatusBar, SB_SETTEXT, (WPARAM)0, (LPARAM)L"Loading test DLL...");

    WCHAR DllPath[MAX_PATH] = { 0 };
    OPENFILENAMEW OpenFileName = { 0 };
    OpenFileName.lStructSize = sizeof(OpenFileName);
    OpenFileName.hwndOwner = wh.Main;
    OpenFileName.lpstrFilter = L"DLL Files (*.dll)\0*.DLL\0";
    OpenFileName.lpstrFile = DllPath;
    OpenFileName.nMaxFile = MAX_PATH;

    GetOpenFileNameW(&OpenFileName);
    LoadLibraryW(DllPath); // ToDo validation.

    SendMessage(wh.StatusBar, SB_SETTEXT, (WPARAM)0, (LPARAM)L"Ready");
}

// Function:    UmeLoadResults
// Description: Load ETW trace session results.
// Called from: MainWndProc after painting, and UmeWndProc when clicking the refresh button.
VOID UmeLoadResults()
{
    SendMessage(wh.StatusBar, SB_SETTEXT, (WPARAM)0, (LPARAM)L"Loading ETW sessions...");

    // Delete rows and fetch latest results.
    ListView_DeleteAllItems(wh.UmeListView);
    wd.UmeSessions = GetSessions();
    DWORD ListItemCount = 0;

    for (int SessionIndex = 0; SessionIndex < wd.UmeSessions.size(); SessionIndex++)
    {
        PTRACING_SESSION ts = wd.UmeSessions.at(SessionIndex);

        for (int ProviderIndex = 0; ProviderIndex < ts->EnabledProviders.size(); ProviderIndex++)
        {
            LVITEM lvi = { 0 };
            lvi.pszText = LPSTR_TEXTCALLBACK; // Sends an LVN_GETDISPINFO message.
            lvi.mask = LVIF_TEXT | LVIF_STATE | LVIF_PARAM;
            lvi.stateMask = 0;
            lvi.iSubItem = 0;
            lvi.state = 0;
            lvi.iItem = ListItemCount++;
            lvi.lParam = ((ULONG)SessionIndex << 16) | ProviderIndex;

            ListView_InsertItem(wh.UmeListView, &lvi);
        }
    }

    LPWSTR CountText = (LPWSTR)HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, MAX_PATH);
    StringCbPrintfW(CountText, MAX_PATH, L"Count: %d sessions.", wd.UmeSessions.size());
    Static_SetText(wh.UmeCountLabel, CountText);

    // Default sort by notable items.
    ListView_SortItems(wh.UmeListView, UmeCompareFunc, 2);

    SendMessage(wh.StatusBar, SB_SETTEXT, (WPARAM)0, (LPARAM)L"Ready");
}

// Function:    UmeCompareFunc
// Description: Sorts the ETW list view depending on the column.
// Called from: UmeWndProc when clicking a column header of the ETW list view.
int CALLBACK UmeCompareFunc(LPARAM lParam1, LPARAM lParam2, LPARAM lParamSort)
{
    int nRetVal = 0;

    PTRACING_SESSION Item1Session = wd.UmeSessions.at(HIWORD(lParam1));
    PTRACING_SESSION Item2Session = wd.UmeSessions.at(HIWORD(lParam2));
    PTRACE_PROVIDER Item1Provider = Item1Session->EnabledProviders.at(LOWORD(lParam1));
    PTRACE_PROVIDER Item2Provider = Item2Session->EnabledProviders.at(LOWORD(lParam2));
    BOOL Item1Notable = FALSE;
    BOOL Item2Notable = FALSE;

    switch (lParamSort)
    {
    case 0:	// Session
        nRetVal = wcscmp(Item1Session->InstanceName, Item2Session->InstanceName);
        break;

    case 1:	// Provider Name
        nRetVal = wcscmp(Item1Provider->ProviderName, Item2Provider->ProviderName);
        break;

    case 2: // Is Notable?
        Item1Notable = Item1Session->Notable || Item1Provider->Notable;
        Item2Notable = Item2Session->Notable || Item2Provider->Notable;
        nRetVal = (Item1Notable == Item2Notable) ? 0 : (Item1Notable) ? -1 : (Item2Notable) ? 1 : 0;
        break;

    default:
        break;
    }

    return nRetVal;
}

// Function:    UmeDisableSelectedProvider
// Description: Disables the selected provider for the session (if eligible).
// Called from: UmeWndProc when clicking the disable provider button.
VOID UmeDisableSelectedProvider()
{
    int SelectedIndex = ListView_GetNextItem(wh.UmeListView, -1, LVNI_SELECTED);

    if (SelectedIndex != -1)
    {
        LVITEM lvi = { 0 };
        lvi.mask = LVIF_PARAM;
        lvi.iItem = SelectedIndex;
        lvi.iSubItem = 0;
        ListView_GetItem(wh.UmeListView, &lvi);

        int SessionIndex = HIWORD(lvi.lParam);
        int ProviderIndex = LOWORD(lvi.lParam);

        PTRACING_SESSION Session = wd.UmeSessions.at(SessionIndex);
        PTRACE_PROVIDER Provider = Session->EnabledProviders.at(ProviderIndex);

        WCHAR MessageTitle[MAX_PATH] = { 0 };
        StringCbPrintfW(MessageTitle, MAX_PATH, L"%ls: %ls", Session->InstanceName, Provider->ProviderName);
        DWORD Status = DisableProvider(Session->LoggerId, &Provider->ProviderId);
        switch (Status)
        {
        case ERROR_SUCCESS:
            MessageBox(NULL, L"Successfully disabled provider!", MessageTitle, MB_OK | MB_ICONINFORMATION);
            break;
        case ERROR_ACCESS_DENIED:
            MessageBox(NULL, L"Denied. Administrative privileges required.", MessageTitle, MB_OK | MB_ICONERROR);
            break;
        default:
            MessageBox(NULL, L"Provider could not be disabled for unspecified reason.", MessageTitle, MB_OK | MB_ICONERROR);
            break;
        }

        UmeLoadResults();
        ListView_EnsureVisible(wh.UmeListView, SelectedIndex, FALSE);
    }
}

// Function:    UmeDisableSelectedProvider
// Description: Stops the selected session (if eligible).
// Called from: UmeWndProc when clicking the stop session button.
VOID UmeStopTracingSession()
{
    int SelectedIndex = ListView_GetNextItem(wh.UmeListView, -1, LVNI_SELECTED);

    if (SelectedIndex != -1)
    {
        LVITEM lvi = { 0 };
        lvi.mask = LVIF_PARAM;
        lvi.iItem = SelectedIndex;
        lvi.iSubItem = 0;
        ListView_GetItem(wh.UmeListView, &lvi);

        int SessionIndex = HIWORD(lvi.lParam);
        int ProviderIndex = LOWORD(lvi.lParam);

        PTRACING_SESSION Session = wd.UmeSessions.at(SessionIndex);
        PTRACE_PROVIDER Provider = Session->EnabledProviders.at(ProviderIndex);

        DWORD Status = StopTracingSession(Session->LoggerId);
        switch (Status)
        {
        case ERROR_SUCCESS:
            MessageBox(NULL, L"Successfully stopped tracing session!", Session->InstanceName, MB_OK | MB_ICONINFORMATION);
            break;
        case ERROR_ACCESS_DENIED:
            MessageBox(NULL, L"Denied. Administrative privileges required.", Session->InstanceName, MB_OK | MB_ICONERROR);
            break;
        default:
            MessageBox(NULL, L"Session could not be stopped for unspecified reason.", Session->InstanceName, MB_OK | MB_ICONERROR);
            break;
        }

        UmeLoadResults();
        ListView_EnsureVisible(wh.UmeListView, SelectedIndex, FALSE);
    }
}
```

`TelemetrySourcerer/TelemetrySourcerer.h`:

```h
#pragma once

#include <Windows.h>

#define TOOL_NAME L"Telemetry Sourcerer"
#define VERSION   L"0.10.0"

LRESULT CALLBACK MainWndProc(HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam);
LRESULT CALLBACK KmcWndProc(HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam);
LRESULT CALLBACK UmhWndProc(HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam);
LRESULT CALLBACK UmeWndProc(HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam);

VOID PaintWindow(HWND);
VOID ResizeWindow(HWND);

VOID KmcLoadResults();
VOID KmcSuppressCallback();
VOID KmcRevertCallback();
int CALLBACK KmcCompareFunc(LPARAM lParam1, LPARAM lParam2, LPARAM lParamSort);

VOID UmhLoadResults();
VOID UmhRestoreFunction();
VOID UmhLoadDll();
int CALLBACK UmhCompareFunc(LPARAM lParam1, LPARAM lParam2, LPARAM lParamSort);

VOID UmeLoadResults();
VOID UmeDisableSelectedProvider();
VOID UmeStopTracingSession();
int CALLBACK UmeCompareFunc(LPARAM lParam1, LPARAM lParam2, LPARAM lParamSort);

```

`TelemetrySourcerer/TelemetrySourcerer.rc`:

```rc
// Microsoft Visual C++ generated resource script.
//

#include "resource.h"

#define APSTUDIO_READONLY_SYMBOLS
/////////////////////////////////////////////////////////////////////////////
//
// Generated from the TEXTINCLUDE 2 resource.
//
#include "winres.h"

/////////////////////////////////////////////////////////////////////////////
#undef APSTUDIO_READONLY_SYMBOLS

/////////////////////////////////////////////////////////////////////////////
// English (United States) resources

#if !defined(AFX_RESOURCE_DLL) || defined(AFX_TARG_ENU)
LANGUAGE 9, 1

#ifdef APSTUDIO_INVOKED
/////////////////////////////////////////////////////////////////////////////
//
// TEXTINCLUDE
//

1 TEXTINCLUDE
BEGIN
    "resource.h\0"
END

2 TEXTINCLUDE  
BEGIN
    "#include ""winres.h""\r\n"
    "\0"
END

3 TEXTINCLUDE  
BEGIN
    "\r\n"
    "\0"
END

#endif    // APSTUDIO_INVOKED

#endif    // English (United States) resources
/////////////////////////////////////////////////////////////////////////////



#ifndef APSTUDIO_INVOKED
/////////////////////////////////////////////////////////////////////////////
//
// Generated from the TEXTINCLUDE 3 resource.
//


/////////////////////////////////////////////////////////////////////////////
#endif    // not APSTUDIO_INVOKED

```

`TelemetrySourcerer/TelemetrySourcerer.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|Win32">
      <Configuration>Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <VCProjectVersion>16.0</VCProjectVersion>
    <Keyword>Win32Proj</Keyword>
    <ProjectGuid>{3ce834d0-f529-4a79-9218-383fa30e7eda}</ProjectGuid>
    <RootNamespace>TelemetrySourcerer</RootNamespace>
    <WindowsTargetPlatformVersion>10.0</WindowsTargetPlatformVersion>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="Shared">
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <LinkIncremental>true</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <LinkIncremental>false</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <LinkIncremental>true</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <LinkIncremental>false</LinkIncremental>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>WIN32;_DEBUG;_WINDOWS;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>WIN32;NDEBUG;_WINDOWS;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>_DEBUG;_WINDOWS;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <RuntimeLibrary>MultiThreadedDebug</RuntimeLibrary>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>NDEBUG;_WINDOWS;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <RuntimeLibrary>MultiThreaded</RuntimeLibrary>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemGroup>
    <ClCompile Include="KmCallbacks.cpp" />
    <ClCompile Include="TelemetrySourcerer.cpp" />
    <ClCompile Include="UmETW.cpp" />
    <ClCompile Include="UmHooks.cpp" />
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="KmCallbacks.h" />
    <ClInclude Include="resource.h" />
    <ClInclude Include="TelemetrySourcerer.h" />
    <ClInclude Include="UmETW.h" />
    <ClInclude Include="UmHooks.h" />
  </ItemGroup>
  <ItemGroup>
    <ResourceCompile Include="TelemetrySourcerer.rc" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>
```

`TelemetrySourcerer/TelemetrySourcerer.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="Source Files">
      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
      <Extensions>cpp;c;cc;cxx;c++;def;odl;idl;hpj;bat;asm;asmx</Extensions>
    </Filter>
    <Filter Include="Header Files">
      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
      <Extensions>h;hh;hpp;hxx;h++;hm;inl;inc;ipp;xsd</Extensions>
    </Filter>
    <Filter Include="Resource Files">
      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav;mfcribbon-ms</Extensions>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="TelemetrySourcerer.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="UmETW.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="UmHooks.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="KmCallbacks.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="UmETW.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="UmHooks.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="TelemetrySourcerer.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="KmCallbacks.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="resource.h">
      <Filter>Header Files</Filter>
    </ClInclude>
  </ItemGroup>
  <ItemGroup>
    <ResourceCompile Include="TelemetrySourcerer.rc">
      <Filter>Resource Files</Filter>
    </ResourceCompile>
  </ItemGroup>
</Project>
```

`TelemetrySourcerer/UmETW.cpp`:

```cpp
#include <Windows.h>
#include <evntrace.h>
#include <tdh.h>

#include <set>
#include <string>
#include <vector>

#include "UmETW.h"

#pragma comment(lib, "Tdh.lib")

std::hash<std::wstring> HashString;
std::set<SIZE_T> NotableSessionHashes;
std::set<SIZE_T> NotableProviderHashes;

// Function:    PopulateUmeHashes
// Description: Populates a list of notable provider and session hashes so they are highlighted.
// Called from: GetSessions as a one-time call if not populated.
VOID PopulateUmeHashes()
{
	NotableProviderHashes.insert(HashString(wstring(L"Microsoft-Windows-Audit-CVE")));
	NotableProviderHashes.insert(HashString(wstring(L"Microsoft-Windows-Threat-Intelligence")));
	NotableProviderHashes.insert(HashString(wstring(L"Microsoft-Windows-Kernel-Process")));
	NotableProviderHashes.insert(HashString(wstring(L"Microsoft-Windows-Kernel-Network")));
	NotableProviderHashes.insert(HashString(wstring(L"Microsoft-Windows-Kernel-Registry")));
	NotableProviderHashes.insert(HashString(wstring(L"Microsoft-Windows-Kernel-File")));
	NotableProviderHashes.insert(HashString(wstring(L"Microsoft-Windows-WinINet")));
	NotableProviderHashes.insert(HashString(wstring(L"Microsoft-Windows-WinINet-Capture")));
	NotableProviderHashes.insert(HashString(wstring(L"Microsoft-Windows-DNS-Client")));
	NotableProviderHashes.insert(HashString(wstring(L"Microsoft-Windows-SMBClient")));
	NotableProviderHashes.insert(HashString(wstring(L"Microsoft-Windows-SMBServer")));
	NotableProviderHashes.insert(HashString(wstring(L"Microsoft-Windows-WMI-Activity")));
	NotableProviderHashes.insert(HashString(wstring(L"Microsoft-Windows-Sysmon")));
	NotableProviderHashes.insert(HashString(wstring(L"Microsoft-Windows-PowerShell")));
	NotableProviderHashes.insert(HashString(wstring(L"Microsoft-Windows-Security-Auditing")));
	NotableProviderHashes.insert(HashString(wstring(L"Microsoft-Windows-Kernel-Audit-API-Calls")));

	NotableSessionHashes.insert(0x7CB510BA9B40BEEC);
	NotableSessionHashes.insert(0x0DD1D51CF3AADD14);
	NotableSessionHashes.insert(0x2199DD129071BD5A);
	NotableSessionHashes.insert(0x0EE38A4714DEDC86);
	NotableSessionHashes.insert(0xCD53ED4761EBB7B4);
	NotableSessionHashes.insert(0x301E4178666A34DB);
	NotableSessionHashes.insert(0x40B6B7B240F291E6);
	NotableSessionHashes.insert(0x8CAB419C02FF68DD);
	NotableSessionHashes.insert(0x1F5E4F79416EBBDF);
	NotableSessionHashes.insert(0x2D4F43EC18BBA6C4);
	NotableSessionHashes.insert(0xCF6C704DE84749C6);
}

// Function:    GetSessions
// Description: Returns a list of ETW tracing sessions.
// Called from: UmeLoadResults
std::vector<PTRACING_SESSION> GetSessions()
{
	if (!NotableSessionHashes.size())
		PopulateUmeHashes();

	std::vector<PTRACING_SESSION> Sessions;

	// Allocate memory for EVENT_TRACE_PROPERTIES.
	ULONG PropertiesSize = sizeof(EVENT_TRACE_PROPERTIES) + (MAX_SESSION_NAME_LEN * sizeof(WCHAR)) + (MAX_LOGFILE_PATH_LEN * sizeof(WCHAR));
	ULONG BufferSize = PropertiesSize * MAX_SESSIONS;
	PEVENT_TRACE_PROPERTIES EtpBuffer = (PEVENT_TRACE_PROPERTIES)HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, BufferSize);
	PEVENT_TRACE_PROPERTIES EtpSessions[MAX_SESSIONS];

	for (USHORT i = 0; i < MAX_SESSIONS; i++)
	{
		EtpSessions[i] = (EVENT_TRACE_PROPERTIES*)((BYTE*)EtpBuffer + (i * PropertiesSize));
		EtpSessions[i]->Wnode.BufferSize = PropertiesSize;
		EtpSessions[i]->LoggerNameOffset = sizeof(EVENT_TRACE_PROPERTIES);
		EtpSessions[i]->LogFileNameOffset = sizeof(EVENT_TRACE_PROPERTIES) + (MAX_SESSION_NAME_LEN * sizeof(WCHAR));
	}

	ULONG SessionCount = 0;
	QueryAllTraces(EtpSessions, (ULONG)MAX_SESSIONS, &SessionCount);

	// Create TRACING_SESSION objects.
	for (USHORT i = 0; i < SessionCount; i++)
	{
		PTRACING_SESSION Session = new TRACING_SESSION;

		Session->LoggerId = (USHORT)EtpSessions[i]->Wnode.HistoricalContext;
		CopyMemory(Session->InstanceName, (LPWSTR)((char*)EtpSessions[i] + EtpSessions[i]->LoggerNameOffset), MAX_SESSION_NAME_LEN);

		if (NotableSessionHashes.count(HashString(std::wstring(Session->InstanceName))))
			Session->Notable = TRUE;

		Sessions.push_back(Session);
	}

	// Populate the TRACING_SESSION objects with providers enabled for them.
	PopulateSessionProviders(Sessions);

	HeapFree(GetProcessHeap(), NULL, EtpBuffer);
	return Sessions;
}

// Function:    PopulateSessionProviders
// Description: Populates a TRACING_SESSION object with its enabled providers.
// Called from: GetSessions
// Remarks:     Adapted from https://docs.microsoft.com/en-us/windows/win32/api/evntrace/nf-evntrace-enumeratetraceguidsex.
VOID PopulateSessionProviders(std::vector<PTRACING_SESSION> Sessions)
{
	PPROVIDER_ENUMERATION_INFO PeiBuffer = nullptr;
	ULONG PeiBufferSize = 0;

	// Get information on each provider (incl. name) used for querying later.
	if (TdhEnumerateProviders(PeiBuffer, &PeiBufferSize) == ERROR_INSUFFICIENT_BUFFER)
	{
		PeiBuffer = (PPROVIDER_ENUMERATION_INFO)HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, PeiBufferSize);

		if (!PeiBuffer)
			return;

		if (TdhEnumerateProviders(PeiBuffer, &PeiBufferSize) != ERROR_SUCCESS)
			return;
	}

	// Query an array of GUIDs of the providers that are registered on the computer.
	LPGUID ProviderGuidList = (LPGUID)HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, BUFSIZ);
	DWORD ProviderGuidListSize = BUFSIZ;
	DWORD RequiredListSize = 0;
	while (EnumerateTraceGuidsEx(TraceGuidQueryList, nullptr, 0, ProviderGuidList, ProviderGuidListSize, &RequiredListSize) == ERROR_INSUFFICIENT_BUFFER)
	{
		ProviderGuidListSize = RequiredListSize;
		ProviderGuidList = (LPGUID)HeapReAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, ProviderGuidList, RequiredListSize);
	}

	// Iterate through each provider to associate them with sessions.
	DWORD ProviderGuidCount = ProviderGuidListSize / sizeof(GUID);
	for (unsigned int i = 0; i < ProviderGuidCount; i++)
	{
		GUID ProviderGuid = ProviderGuidList[i];

		// Get information about trace providers using EnumerateTraceGuidsEx.
		PTRACE_GUID_INFO TraceGuidInfo = (PTRACE_GUID_INFO)HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, BUFSIZ);
		DWORD InfoListSize = BUFSIZ;
		DWORD RequiredListSize = 0;
		while (EnumerateTraceGuidsEx(TraceGuidQueryInfo, &ProviderGuid, sizeof(GUID), TraceGuidInfo, InfoListSize, &RequiredListSize) == ERROR_INSUFFICIENT_BUFFER)
		{
			InfoListSize = RequiredListSize;
			TraceGuidInfo = (PTRACE_GUID_INFO)HeapReAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, TraceGuidInfo, RequiredListSize);
		}

		PTRACE_PROVIDER_INSTANCE_INFO TraceProviderInstanceInfo = (PTRACE_PROVIDER_INSTANCE_INFO)((PBYTE)TraceGuidInfo + sizeof(TRACE_GUID_INFO));
		for (unsigned int j = 0; j < TraceGuidInfo->InstanceCount; j++)
		{
			if (TraceProviderInstanceInfo->EnableCount > 0)
			{
				PTRACE_ENABLE_INFO TraceEnableInfo = (PTRACE_ENABLE_INFO)((PBYTE)TraceProviderInstanceInfo + sizeof(TRACE_PROVIDER_INSTANCE_INFO));
				for (unsigned int k = 0; k < TraceProviderInstanceInfo->EnableCount; k++)
				{
					USHORT LoggerId = TraceEnableInfo->LoggerId;

					for (PTRACING_SESSION TracingSession : Sessions)
					{
						if (TracingSession->LoggerId == LoggerId)
						{
							// There tends to be duplicates, so the logic below ensures that only
							// unique providers are added to the session.
							BOOL ShouldAddProvider = TRUE;
							for (PTRACE_PROVIDER TraceProvider : TracingSession->EnabledProviders)
								if (TraceProvider->ProviderId == ProviderGuid)
									ShouldAddProvider = FALSE;

							if (ShouldAddProvider)
							{
								PTRACE_PROVIDER tp = new TRACE_PROVIDER;

								tp->ProviderId = ProviderGuid;

								// Get the provider name.
								LPWSTR ProviderName = nullptr;
								for (unsigned int l = 0; l < PeiBuffer->NumberOfProviders; l++)
								{
									if (ProviderGuid == PeiBuffer->TraceProviderInfoArray[l].ProviderGuid)
									{
										ProviderName = (LPWSTR)((DWORD_PTR)PeiBuffer + PeiBuffer->TraceProviderInfoArray[l].ProviderNameOffset);
										CopyMemory(tp->ProviderName, ProviderName, MAX_PATH);
									}
								}

								// If provider name is not defined, use the GUID.
								if (!ProviderName)
									StringFromGUID2(ProviderGuid, tp->ProviderName, MAX_PATH);

								// Check if the provider name is notable (i.e. should be highlighted).
								if (NotableProviderHashes.count(HashString(std::wstring(tp->ProviderName))))
									tp->Notable = TRUE;

								TracingSession->EnabledProviders.push_back(tp);
							}
						}
					}

					TraceEnableInfo++;
				}
			}

			TraceProviderInstanceInfo = (PTRACE_PROVIDER_INSTANCE_INFO)((PBYTE)TraceProviderInstanceInfo + TraceProviderInstanceInfo->NextOffset);
		}
	}

	HeapFree(GetProcessHeap(), NULL, PeiBuffer);
	return;
}

// Function:    DisableProvider
// Description: Disables the provider for a session, given its logger ID and the provider's GUID.
// Called from: UmeDisableSelectedProvider
DWORD DisableProvider(USHORT LoggerId, LPCGUID ProviderGuid)
{
	return EnableTraceEx2(
		(TRACEHANDLE)LoggerId,
		ProviderGuid,
		EVENT_CONTROL_CODE_DISABLE_PROVIDER,
		TRACE_LEVEL_VERBOSE,
		NULL,
		NULL,
		NULL,
		nullptr);
}

// Function:    StopTracingSession
// Description: Stops a tracing session, given its logger ID.
// Called from: UmeStopTracingSession
DWORD StopTracingSession(USHORT LoggerId)
{
	ULONG PropertiesSize = sizeof(EVENT_TRACE_PROPERTIES) + (MAX_SESSION_NAME_LEN * sizeof(WCHAR)) + (MAX_LOGFILE_PATH_LEN * sizeof(WCHAR));
	PEVENT_TRACE_PROPERTIES EventTraceProperties = (PEVENT_TRACE_PROPERTIES)HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, PropertiesSize);
	EventTraceProperties->Wnode.BufferSize = PropertiesSize;
	EventTraceProperties->LoggerNameOffset = sizeof(EVENT_TRACE_PROPERTIES);
	EventTraceProperties->LogFileNameOffset = sizeof(EVENT_TRACE_PROPERTIES) + (MAX_SESSION_NAME_LEN * sizeof(WCHAR));

	DWORD Status = StopTraceW((TRACEHANDLE)LoggerId, nullptr, EventTraceProperties);

	HeapFree(GetProcessHeap(), NULL, EventTraceProperties);
	return Status;
}
```

`TelemetrySourcerer/UmETW.h`:

```h
#pragma once

#include <Windows.h>
#include <evntrace.h>

#include <vector>

using namespace std;

#define MAX_SESSIONS 64
#define MAX_SESSION_NAME_LEN 1024
#define MAX_LOGFILE_PATH_LEN 1024

// Struct:    TRACE_PROVIDER
// Describes: An ETW trace provider.
// Members:
// - ProviderId:   GUID of the provider.
// - ProviderName: Name of the provider.
// - Notable:      Whether the provider should be highlighted.
typedef struct _TRACE_PROVIDER
{
	GUID  ProviderId             = { 0 };
	WCHAR ProviderName[MAX_PATH] = { 0 };
	BOOL  Notable                = FALSE;
} TRACE_PROVIDER, *PTRACE_PROVIDER;

// Struct:    TRACING_SESSION
// Describes: An ETW tracing session.
// Members:
// - LoggerId:         GUID of the session.
// - InstanceName:     Name of the session.
// - EnabledProviders: List of providers enabled for the session.
// - Notable:          Whether the session should be highlighted.
typedef struct _TRACING_SESSION
{
	USHORT                       LoggerId                           = 0;
	WCHAR                        InstanceName[MAX_SESSION_NAME_LEN] = { 0 };
	std::vector<PTRACE_PROVIDER> EnabledProviders;
	BOOL                         Notable                            = FALSE;
} TRACING_SESSION, *PTRACING_SESSION;

VOID PopulateUmeHashes();
std::vector<PTRACING_SESSION> GetSessions();
VOID PopulateSessionProviders(std::vector<PTRACING_SESSION> Sessions);
DWORD DisableProvider(USHORT LoggerId, LPCGUID ProviderGuid);
DWORD StopTracingSession(USHORT LoggerId);

```

`TelemetrySourcerer/UmHooks.cpp`:

```cpp
#include <Windows.h>
#include <Psapi.h>
#include <Shlwapi.h>

#include <string>
#include <vector>

#include "UmHooks.h"

using namespace std;

// Function:    CheckAllModulesForHooks
// Description: Returns a list of all loaded modules with any hooks.
// Called from: UmhLoadResults
std::vector<PLOADED_MODULE> CheckAllModulesForHooks()
{
	// Get all modules.
	std::vector<PLOADED_MODULE> Modules = GetModules();

	// Check each module for hooks.
	for (PLOADED_MODULE Module : Modules)
		CheckModuleForHooks(Module);

	return Modules;
}

// Function:    GetModules
// Description: Returns a list of all loaded modules for this process.
// Called from: CheckAllModulesForHooks
std::vector<PLOADED_MODULE> GetModules()
{
	std::vector<PLOADED_MODULE> Modules;

	DWORD RequredBytes = 0;
	DWORD ModuleCount = 0;
	HMODULE* ModuleHandles = (HMODULE*)HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, sizeof(HMODULE) * 1024);
	DWORD ModuleHandlesSize = sizeof(HMODULE) * 1024;
	BOOL Status = EnumProcessModulesEx(GetCurrentProcess(), ModuleHandles, ModuleHandlesSize, &RequredBytes, LIST_MODULES_DEFAULT);

	// Fail silently if the call was not successful or enough memory wasn't allocated.
	if ((Status == FALSE) || (RequredBytes > ModuleHandlesSize))
	{
		return Modules;
	}

	ModuleCount = RequredBytes / sizeof(HMODULE);
	for (int i = 0; i < ModuleCount; i++)
	{
		PLOADED_MODULE Module = new LOADED_MODULE;

		Module->Handle = ModuleHandles[i];
		GetModuleFileNameExW(GetCurrentProcess(), Module->Handle, Module->Path, MAX_PATH);

		Modules.push_back(Module);
	}

	HeapFree(GetProcessHeap(), NULL, ModuleHandles);
	return Modules;
}

// Function:    CheckModuleForHooks
// Description: Checks a given module for hooked functions by comparing against a fresh copy.
// Called from: CheckAllModulesForHooks
// Remarks:     Adapted from https://github.com/NtRaiseHardError/Antimalware-Research.
VOID CheckModuleForHooks(PLOADED_MODULE Module)
{
	// Load a fresh copy in memory.
	HANDLE FmFileHandle = CreateFileW(Module->Path, GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_EXISTING, 0, NULL);
	HANDLE FmMappingHandle = CreateFileMapping(FmFileHandle, NULL, PAGE_READONLY | SEC_IMAGE, 0, 0, NULL);
	HMODULE FmHandle = (HMODULE)MapViewOfFile(FmMappingHandle, FILE_MAP_READ, 0, 0, 0);
	HMODULE LmHandle = Module->Handle;

	// Parse the original module's PE headers.
	PIMAGE_DOS_HEADER LmDosHeader = (PIMAGE_DOS_HEADER)LmHandle;
	PIMAGE_NT_HEADERS LmNtHeaders = (PIMAGE_NT_HEADERS)((DWORD_PTR)LmHandle + LmDosHeader->e_lfanew);

	// Parse the fresh module's PE headers.
	PIMAGE_DOS_HEADER FmDosHeader = (PIMAGE_DOS_HEADER)FmHandle;
	PIMAGE_NT_HEADERS FmNtHeaders = (PIMAGE_NT_HEADERS)((DWORD_PTR)FmHandle + FmDosHeader->e_lfanew);

	// Check if the export table exists.
	if (LmNtHeaders->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].VirtualAddress != 0) {
		// Get the export table for the loaded module.
		PIMAGE_EXPORT_DIRECTORY LmExportDirectory = (PIMAGE_EXPORT_DIRECTORY)((DWORD_PTR)LmHandle + LmNtHeaders->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].VirtualAddress);
		LPDWORD LmFunctionTable = (LPDWORD)((DWORD_PTR)LmHandle + LmExportDirectory->AddressOfFunctions);
		LPDWORD LmNameTable = (LPDWORD)((DWORD_PTR)LmHandle + LmExportDirectory->AddressOfNames);
		LPWORD LmOrdinalTable = (LPWORD)((DWORD_PTR)LmHandle + LmExportDirectory->AddressOfNameOrdinals);

		// Get the export table for the fresh module.
		PIMAGE_EXPORT_DIRECTORY FmExportDirectory = (PIMAGE_EXPORT_DIRECTORY)((DWORD_PTR)FmHandle + FmNtHeaders->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].VirtualAddress);
		LPDWORD FmFunctionTable = (LPDWORD)((DWORD_PTR)FmHandle + FmExportDirectory->AddressOfFunctions);
		LPDWORD FmNameTable = (LPDWORD)((DWORD_PTR)FmHandle + FmExportDirectory->AddressOfNames);
		LPWORD FmOrdinalTable = (LPWORD)((DWORD_PTR)FmHandle + FmExportDirectory->AddressOfNameOrdinals);

		// Walk the export table.
		for (DWORD i = 0; i < LmExportDirectory->NumberOfNames; i++) {
			// Get the address of the export (loaded + fresh).
			FARPROC LmFunction = (FARPROC)((DWORD_PTR)LmHandle + LmFunctionTable[LmOrdinalTable[i]]);
			FARPROC FmFunction = (FARPROC)((DWORD_PTR)FmHandle + FmFunctionTable[FmOrdinalTable[i]]);

			// Check if the address of the loaded export is executable. Skip if not.
			MEMORY_BASIC_INFORMATION mbi = { 0 };
			VirtualQuery(LmFunction, &mbi, sizeof(mbi));
			if ((mbi.Protect & PAGE_EXECUTE_READ) == 0)
				continue;

			// Check if the function is hooked by comparing memory between the loaded module and the fresh copy.
			if (memcmp(LmFunction, FmFunction, 16))
			{
				PHOOKED_FUNCTION HookedFunction = new HOOKED_FUNCTION;

				HookedFunction->ModuleHandle = Module->Handle;
				HookedFunction->Ordinal = LmOrdinalTable[i];
				HookedFunction->Address = LmFunction;
				MultiByteToWideChar(CP_UTF8, MB_PRECOMPOSED, (LPCCH)((DWORD_PTR)LmHandle + LmNameTable[i]), -1, (LPWSTR)HookedFunction->Name, MAX_PATH - 1);
				CopyMemory(HookedFunction->FreshBytes, FmFunction, 16);

				Module->HookedFunctions.push_back(HookedFunction);
			}
		}
	}

	// Unmap fresh module.
	UnmapViewOfFile(FmHandle);
	CloseHandle(FmMappingHandle);
	CloseHandle(FmFileHandle);
}

// Function:    RestoreHookedFunction
// Description: Unhooks a function using bytes collected from a fresh copy.
// Called from: UmhRestoreFunction
// Remarks:     Adapted from https://github.com/NtRaiseHardError/Antimalware-Research.
BOOL RestoreHookedFunction(PHOOKED_FUNCTION HookedFunction)
{
	DWORD OldProtection = 0;
	
	if (!VirtualProtect(HookedFunction->Address, 16, PAGE_EXECUTE_READWRITE, &OldProtection))
		return FALSE;
	
	CopyMemory(HookedFunction->Address, HookedFunction->FreshBytes, 16);
	
	if (!VirtualProtect(HookedFunction->Address, 16, OldProtection, &OldProtection))
		return FALSE;

	return TRUE;
}
```

`TelemetrySourcerer/UmHooks.h`:

```h
#pragma once

#include <Windows.h>

#include <vector>

using namespace std;

// Struct:    HOOKED_FUNCTION
// Describes: A hooked function.
// Members:
// - ModuleHandle: Handle to the function's module.
// - Ordinal:      The ordinal number of the function.
// - Address:      The address of the function.
// - Name:         Name of the function, if it exists.
typedef struct _HOOKED_FUNCTION {
	HMODULE ModuleHandle   = 0;
	DWORD   Ordinal        = 0;
	LPVOID  Address        = nullptr;
	WCHAR   Name[MAX_PATH] = { 0 };
	UCHAR   FreshBytes[16] = { 0 };
} HOOKED_FUNCTION, *PHOOKED_FUNCTION;

// Struct:    LOADED_MODULE
// Describes: A loaded module.
// Members:
// - Handle:          Handle to the function's module.
// - Path:            File path of module.
// - HookedFunctions: Array of hooked functions.
typedef struct _LOADED_MODULE {
	HMODULE Handle = 0;
	WCHAR Path[MAX_PATH] = { 0 };
	std::vector<PHOOKED_FUNCTION> HookedFunctions;
} LOADED_MODULE, *PLOADED_MODULE;

std::vector<PLOADED_MODULE> CheckAllModulesForHooks();
std::vector<PLOADED_MODULE> GetModules();
VOID CheckModuleForHooks(PLOADED_MODULE Module);
BOOL RestoreHookedFunction(PHOOKED_FUNCTION HookedFunction);
```

`TelemetrySourcererDriver/Callbacks.cpp`:

```cpp
#include <fltKernel.h>

#include "TelemetrySourcererDriver.h"
#include "Callbacks.h"
#include "Memory.h"

#pragma comment(lib, "FltMgr.lib")

UCHAR LI_PATTERN_W7_07600[] = { 0x41, 0x0f, 0xba, 0x6d, 0x00, 0x0a, 0xbb, 0x01, 0x00, 0x00, 0x00, 0x4c, 0x8b, 0xf2, 0x4c, 0x8b, 0xf9 };
UCHAR LI_PATTERN_W8_08102[] = { 0xbf, 0x08, 0x00, 0x00, 0x00, 0x41, 0x89, 0x06, 0x0f, 0x1f, 0x04, 0x00, 0x48, 0x8b, 0xcb, 0xe8 };
UCHAR LI_PATTERN_W8_09431[] = { 0x45, 0x33, 0xc0, 0x48, 0x8b, 0xd7, 0x48, 0x8d, 0x0c, 0xd9, 0xe8 };
UCHAR LI_PATTERN_WX_10240[] = { 0x45, 0x33, 0xC0, 0x48, 0x8D, 0x0C, 0xD9, 0x48, 0x8B, 0xD7, 0xE8 };
CALLBACK_SEARCH_QUERY LoadImageCallbackQueries[14] = {
	{ WINDOWS_INDEX::W7_07600, RTL_CONSTANT_STRING(L"FsRtlReleaseFile"),                    RTL_CONSTANT_STRING(L"IoSetPartitionInformationEx"),               LI_PATTERN_W7_07600, sizeof(LI_PATTERN_W7_07600), -4 },
	{ WINDOWS_INDEX::W8_08102, RTL_CONSTANT_STRING(L"ExSizeOfRundownProtectionCacheAware"), RTL_CONSTANT_STRING(L"MmProbeAndLockProcessPages"),                LI_PATTERN_W8_08102, sizeof(LI_PATTERN_W8_08102), -4 },
	{ WINDOWS_INDEX::W8_09431, RTL_CONSTANT_STRING(L"PsSetLoadImageNotifyRoutine"),         RTL_CONSTANT_STRING(L"PsSetCreateThreadNotifyRoutine"),            LI_PATTERN_W8_09431, sizeof(LI_PATTERN_W8_09431), -4 },
	{ WINDOWS_INDEX::WX_10240, RTL_CONSTANT_STRING(L"PsSetLoadImageNotifyRoutine"),         RTL_CONSTANT_STRING(L"PsSetCreateProcessNotifyRoutine"),           LI_PATTERN_WX_10240, sizeof(LI_PATTERN_WX_10240), -4 },
	{ WINDOWS_INDEX::WX_10586, RTL_CONSTANT_STRING(L"PsSetLoadImageNotifyRoutine"),         RTL_CONSTANT_STRING(L"PsSetCreateProcessNotifyRoutine"),           LI_PATTERN_WX_10240, sizeof(LI_PATTERN_WX_10240), -4 },
	{ WINDOWS_INDEX::WX_14393, RTL_CONSTANT_STRING(L"PsSetLoadImageNotifyRoutine"),         RTL_CONSTANT_STRING(L"SeRegisterLogonSessionTerminatedRoutineEx"), LI_PATTERN_WX_10240, sizeof(LI_PATTERN_WX_10240), -4 },
	{ WINDOWS_INDEX::WX_15063, RTL_CONSTANT_STRING(L"PsSetLoadImageNotifyRoutine"),         RTL_CONSTANT_STRING(L"PsSetCreateProcessNotifyRoutine"),           LI_PATTERN_WX_10240, sizeof(LI_PATTERN_WX_10240), -4 },
	{ WINDOWS_INDEX::WX_16299, RTL_CONSTANT_STRING(L"PsSetLoadImageNotifyRoutine"),         RTL_CONSTANT_STRING(L"PsSetCreateProcessNotifyRoutine"),           LI_PATTERN_WX_10240, sizeof(LI_PATTERN_WX_10240), -4 },
	{ WINDOWS_INDEX::WX_17134, RTL_CONSTANT_STRING(L"PsSetLoadImageNotifyRoutine"),         RTL_CONSTANT_STRING(L"PsSetCreateProcessNotifyRoutine"),           LI_PATTERN_WX_10240, sizeof(LI_PATTERN_WX_10240), -4 },
	{ WINDOWS_INDEX::WX_17763, RTL_CONSTANT_STRING(L"PsSetLoadImageNotifyRoutineEx"),       RTL_CONSTANT_STRING(L"PsSetCreateProcessNotifyRoutine"),           LI_PATTERN_WX_10240, sizeof(LI_PATTERN_WX_10240), -4 },
	{ WINDOWS_INDEX::WX_18362, RTL_CONSTANT_STRING(L"PsSetLoadImageNotifyRoutineEx"),       RTL_CONSTANT_STRING(L"PsSetCreateProcessNotifyRoutine"),           LI_PATTERN_WX_10240, sizeof(LI_PATTERN_WX_10240), -4 },
	{ WINDOWS_INDEX::WX_18363, RTL_CONSTANT_STRING(L"PsSetLoadImageNotifyRoutineEx"),       RTL_CONSTANT_STRING(L"PsSetCreateProcessNotifyRoutine"),           LI_PATTERN_WX_10240, sizeof(LI_PATTERN_WX_10240), -4 },
	{ WINDOWS_INDEX::WX_19041, RTL_CONSTANT_STRING(L"PsSetLoadImageNotifyRoutineEx"),       RTL_CONSTANT_STRING(L"PsSetCreateProcessNotifyRoutine"),           LI_PATTERN_WX_10240, sizeof(LI_PATTERN_WX_10240), -4 },
	{ WINDOWS_INDEX::WX_19042, RTL_CONSTANT_STRING(L"PsSetLoadImageNotifyRoutineEx"),       RTL_CONSTANT_STRING(L"PsSetCreateProcessNotifyRoutine"),           LI_PATTERN_WX_10240, sizeof(LI_PATTERN_WX_10240), -4 },
};

UCHAR CP_PATTERN_W7_07600[] = { 0x4c, 0x8b, 0xf9, 0x48, 0x8d, 0x0c, 0xc1, 0xe8 };
UCHAR CP_PATTERN_W8_08102[] = { 0x8b, 0xc3, 0x48, 0x8d, 0x34, 0xc1, 0x48, 0x8b, 0xce, 0xe8 };
UCHAR CP_PATTERN_W8_09431[] = { 0x48, 0x8d, 0x04, 0xc1, 0x48, 0x89, 0x45, 0x70, 0x48, 0x8b, 0xc8, 0xe8 };
UCHAR CP_PATTERN_WX_10240[] = { 0x8b, 0xc3, 0x45, 0x33, 0xc0, 0x48, 0x8b, 0xd6, 0x49, 0x8d, 0x0c, 0xc7, 0xe8 };
UCHAR CP_PATTERN_WX_10586[] = { 0x49, 0x8d, 0x0c, 0xff, 0x45, 0x33, 0xc0, 0x48, 0x8b, 0xd6, 0xe8 };
UCHAR CP_PATTERN_WX_14393[] = { 0x49, 0x8d, 0x0c, 0xfc, 0x45, 0x33, 0xc0, 0x48, 0x8b, 0xd6, 0xe8 };
UCHAR CP_PATTERN_WX_15063[] = { 0x49, 0x8d, 0x0c, 0xdc, 0x45, 0x33, 0xc0, 0x48, 0x8b, 0xd6, 0xe8 };
UCHAR CP_PATTERN_WX_16299[] = { 0x48, 0x8d, 0x0c, 0xdd, 0x00, 0x00, 0x00, 0x00, 0x45, 0x33, 0xc0, 0x49, 0x03, 0xcd, 0x48, 0x8b };
CALLBACK_SEARCH_QUERY CreateProcessCallbackQueries[14] = {
	{ WINDOWS_INDEX::W7_07600, RTL_CONSTANT_STRING(L"RtlAreAllAccessesGranted"),            RTL_CONSTANT_STRING(L"RtlGetIntegerAtom"),                         CP_PATTERN_W7_07600, sizeof(CP_PATTERN_W7_07600), -4 },
	{ WINDOWS_INDEX::W8_08102, RTL_CONSTANT_STRING(L"PsAcquireProcessExitSynchronization"), RTL_CONSTANT_STRING(L"FsRtlAddToTunnelCache"),                     CP_PATTERN_W8_08102, sizeof(CP_PATTERN_W8_08102), -4 },
	{ WINDOWS_INDEX::W8_09431, RTL_CONSTANT_STRING(L"ObCreateObject"),                      RTL_CONSTANT_STRING(L"NtFindAtom"),                                CP_PATTERN_W8_09431, sizeof(CP_PATTERN_W8_09431), -4 },
	{ WINDOWS_INDEX::WX_10240, RTL_CONSTANT_STRING(L"PsSetCreateProcessNotifyRoutine"),     RTL_CONSTANT_STRING(L"KeRegisterProcessorChangeCallback"),         CP_PATTERN_WX_10240, sizeof(CP_PATTERN_WX_10240), -4 },
	{ WINDOWS_INDEX::WX_10586, RTL_CONSTANT_STRING(L"PsSetCreateProcessNotifyRoutine"),     RTL_CONSTANT_STRING(L"KeRegisterProcessorChangeCallback"),         CP_PATTERN_WX_10586, sizeof(CP_PATTERN_WX_10586), -4 },
	{ WINDOWS_INDEX::WX_14393, RTL_CONSTANT_STRING(L"PsSetCreateProcessNotifyRoutine"),     RTL_CONSTANT_STRING(L"KeRegisterProcessorChangeCallback"),         CP_PATTERN_WX_14393, sizeof(CP_PATTERN_WX_14393), -4 },
	{ WINDOWS_INDEX::WX_15063, RTL_CONSTANT_STRING(L"PsSetCreateProcessNotifyRoutine"),     RTL_CONSTANT_STRING(L"KeRegisterProcessorChangeCallback"),         CP_PATTERN_WX_15063, sizeof(CP_PATTERN_WX_15063), -4 },
	{ WINDOWS_INDEX::WX_16299, RTL_CONSTANT_STRING(L"PsSetCreateProcessNotifyRoutine"),     RTL_CONSTANT_STRING(L"RtlGetSystemBootStatus"),                    CP_PATTERN_WX_16299, sizeof(CP_PATTERN_WX_16299), -4 },
	{ WINDOWS_INDEX::WX_17134, RTL_CONSTANT_STRING(L"PsSetCreateProcessNotifyRoutine"),     RTL_CONSTANT_STRING(L"EtwEnableTrace"),                            CP_PATTERN_WX_16299, sizeof(CP_PATTERN_WX_16299), -4 },
	{ WINDOWS_INDEX::WX_17763, RTL_CONSTANT_STRING(L"PsSetCreateProcessNotifyRoutine"),     RTL_CONSTANT_STRING(L"IoCreateDriver"),                            CP_PATTERN_WX_16299, sizeof(CP_PATTERN_WX_16299), -4 },
	{ WINDOWS_INDEX::WX_18362, RTL_CONSTANT_STRING(L"PsSetCreateProcessNotifyRoutine"),     RTL_CONSTANT_STRING(L"IoCreateDriver"),                            CP_PATTERN_WX_16299, sizeof(CP_PATTERN_WX_16299), -4 },
	{ WINDOWS_INDEX::WX_18363, RTL_CONSTANT_STRING(L"PsSetCreateProcessNotifyRoutine"),     RTL_CONSTANT_STRING(L"IoCreateDriver"),                            CP_PATTERN_WX_16299, sizeof(CP_PATTERN_WX_16299), -4 },
	{ WINDOWS_INDEX::WX_19041, RTL_CONSTANT_STRING(L"PsSetCreateProcessNotifyRoutine"),     RTL_CONSTANT_STRING(L"IoCreateDriver"),                            CP_PATTERN_WX_16299, sizeof(CP_PATTERN_WX_16299), -4 },
	{ WINDOWS_INDEX::WX_19042, RTL_CONSTANT_STRING(L"PsSetCreateProcessNotifyRoutine"),     RTL_CONSTANT_STRING(L"IoCreateDriver"),                            CP_PATTERN_WX_16299, sizeof(CP_PATTERN_WX_16299), -4 },
};

UCHAR CT_PATTERN_W7_07600[] = { 0xbf, 0x40, 0x00, 0x00, 0x00, 0x48, 0x8b, 0xcb, 0xe8 };
UCHAR CT_PATTERN_WX_10240[] = { 0x48, 0x8b, 0xcd, 0xe8 };
CALLBACK_SEARCH_QUERY CreateThreadCallbackQueries[14] = {
	{ WINDOWS_INDEX::W7_07600, RTL_CONSTANT_STRING(L"RtlUnicodeToMultiByteSize"),           RTL_CONSTANT_STRING(L"MmLockPagableSectionByHandle"),              CT_PATTERN_W7_07600, sizeof(CT_PATTERN_W7_07600), -5 },
	{ WINDOWS_INDEX::W8_08102, RTL_CONSTANT_STRING(L"PsAcquireProcessExitSynchronization"), RTL_CONSTANT_STRING(L"FsRtlAddToTunnelCache"),                     CT_PATTERN_W7_07600, sizeof(CT_PATTERN_W7_07600), -4 },
	{ WINDOWS_INDEX::W8_09431, RTL_CONSTANT_STRING(L"ObCreateObject"),                      RTL_CONSTANT_STRING(L"NtFindAtom"),                                CT_PATTERN_W7_07600, sizeof(CT_PATTERN_W7_07600), -5 },
	{ WINDOWS_INDEX::WX_10240, RTL_CONSTANT_STRING(L"PsRemoveCreateThreadNotifyRoutine"),   RTL_CONSTANT_STRING(L"PsRemoveLoadImageNotifyRoutine"),            CT_PATTERN_WX_10240, sizeof(CT_PATTERN_WX_10240), -8 },
	{ WINDOWS_INDEX::WX_10586, RTL_CONSTANT_STRING(L"PsRemoveCreateThreadNotifyRoutine"),   RTL_CONSTANT_STRING(L"PsRemoveLoadImageNotifyRoutine"),            CT_PATTERN_WX_10240, sizeof(CT_PATTERN_WX_10240), -8 },
	{ WINDOWS_INDEX::WX_14393, RTL_CONSTANT_STRING(L"PsRemoveCreateThreadNotifyRoutine"),   RTL_CONSTANT_STRING(L"PsRemoveLoadImageNotifyRoutine"),            CT_PATTERN_WX_10240, sizeof(CT_PATTERN_WX_10240), -8 },
	{ WINDOWS_INDEX::WX_15063, RTL_CONSTANT_STRING(L"PsRemoveCreateThreadNotifyRoutine"),   RTL_CONSTANT_STRING(L"PsRemoveLoadImageNotifyRoutine"),            CT_PATTERN_WX_10240, sizeof(CT_PATTERN_WX_10240), -8 },
	{ WINDOWS_INDEX::WX_16299, RTL_CONSTANT_STRING(L"PsRemoveCreateThreadNotifyRoutine"),   RTL_CONSTANT_STRING(L"PsRemoveLoadImageNotifyRoutine"),            CT_PATTERN_WX_10240, sizeof(CT_PATTERN_WX_10240), -8 },
	{ WINDOWS_INDEX::WX_17134, RTL_CONSTANT_STRING(L"PsRemoveCreateThreadNotifyRoutine"),   RTL_CONSTANT_STRING(L"PsRemoveLoadImageNotifyRoutine"),            CT_PATTERN_WX_10240, sizeof(CT_PATTERN_WX_10240), -8 },
	{ WINDOWS_INDEX::WX_17763, RTL_CONSTANT_STRING(L"PsRemoveCreateThreadNotifyRoutine"),   RTL_CONSTANT_STRING(L"PsRemoveLoadImageNotifyRoutine"),            CT_PATTERN_WX_10240, sizeof(CT_PATTERN_WX_10240), -8 },
	{ WINDOWS_INDEX::WX_18362, RTL_CONSTANT_STRING(L"PsRemoveCreateThreadNotifyRoutine"),   RTL_CONSTANT_STRING(L"PsRemoveLoadImageNotifyRoutine"),            CT_PATTERN_WX_10240, sizeof(CT_PATTERN_WX_10240), -8 },
	{ WINDOWS_INDEX::WX_18363, RTL_CONSTANT_STRING(L"PsRemoveCreateThreadNotifyRoutine"),   RTL_CONSTANT_STRING(L"PsRemoveLoadImageNotifyRoutine"),            CT_PATTERN_WX_10240, sizeof(CT_PATTERN_WX_10240), -8 },
	{ WINDOWS_INDEX::WX_19041, RTL_CONSTANT_STRING(L"PsRemoveCreateThreadNotifyRoutine"),   RTL_CONSTANT_STRING(L"PsRemoveLoadImageNotifyRoutine"),            CT_PATTERN_WX_10240, sizeof(CT_PATTERN_WX_10240), -8 },
	{ WINDOWS_INDEX::WX_19042, RTL_CONSTANT_STRING(L"PsRemoveCreateThreadNotifyRoutine"),   RTL_CONSTANT_STRING(L"PsRemoveLoadImageNotifyRoutine"),            CT_PATTERN_WX_10240, sizeof(CT_PATTERN_WX_10240), -8 },
};

UCHAR RG_PATTERN_W7_07600[] = { 0x48, 0x8b, 0xf8, 0x48, 0x89, 0x44, 0x24, 0x28, 0x48, 0x3b, 0xc3, 0x0f, 0x84 };
UCHAR RG_PATTERN_W8_08102[] = { 0x49, 0x8b, 0x04, 0x24, 0x48, 0x3b, 0x43, 0x18, 0x74 };
UCHAR RG_PATTERN_WX_10240[] = { 0x48, 0x8b, 0xf8, 0x48, 0x89, 0x44, 0x24, 0x40, 0x48, 0x85, 0xc0, 0x0f, 0x84 };
CALLBACK_SEARCH_QUERY RegistryCallbackQueries[14] = {
	{ WINDOWS_INDEX::W7_07600, RTL_CONSTANT_STRING(L"CmUnRegisterCallback"),                RTL_CONSTANT_STRING(L"CmRegisterCallback"),                        RG_PATTERN_W7_07600, sizeof(RG_PATTERN_W7_07600), -9 },
	{ WINDOWS_INDEX::W8_08102, RTL_CONSTANT_STRING(L"CmSetCallbackObjectContext"),          RTL_CONSTANT_STRING(L"CmGetCallbackVersion"),                      RG_PATTERN_W8_08102, sizeof(RG_PATTERN_W8_08102), -9 },
	{ WINDOWS_INDEX::W8_09431, RTL_CONSTANT_STRING(L"CmSetCallbackObjectContext"),          RTL_CONSTANT_STRING(L"DbgkLkmdUnregisterCallback"),                RG_PATTERN_W8_08102, sizeof(RG_PATTERN_W8_08102), -9 },
	{ WINDOWS_INDEX::WX_10240, RTL_CONSTANT_STRING(L"CmUnRegisterCallback"),                RTL_CONSTANT_STRING(L"FsRtlAllocateResource"),                     RG_PATTERN_WX_10240, sizeof(RG_PATTERN_WX_10240), -9 },
	{ WINDOWS_INDEX::WX_10586, RTL_CONSTANT_STRING(L"CmUnRegisterCallback"),                RTL_CONSTANT_STRING(L"FsRtlAllocateResource"),                     RG_PATTERN_WX_10240, sizeof(RG_PATTERN_WX_10240), -9 },
	{ WINDOWS_INDEX::WX_14393, RTL_CONSTANT_STRING(L"CmUnRegisterCallback"),                RTL_CONSTANT_STRING(L"FsRtlAllocateResource"),                     RG_PATTERN_WX_10240, sizeof(RG_PATTERN_WX_10240), -9 },
	{ WINDOWS_INDEX::WX_15063, RTL_CONSTANT_STRING(L"CmUnRegisterCallback"),                RTL_CONSTANT_STRING(L"DbgkLkmdUnregisterCallback"),                RG_PATTERN_WX_10240, sizeof(RG_PATTERN_WX_10240), -9 },
	{ WINDOWS_INDEX::WX_16299, RTL_CONSTANT_STRING(L"CmUnRegisterCallback"),                RTL_CONSTANT_STRING(L"DbgkLkmdUnregisterCallback"),                RG_PATTERN_WX_10240, sizeof(RG_PATTERN_WX_10240), -9 },
	{ WINDOWS_INDEX::WX_17134, RTL_CONSTANT_STRING(L"CmUnRegisterCallback"),                RTL_CONSTANT_STRING(L"DbgkLkmdUnregisterCallback"),                RG_PATTERN_WX_10240, sizeof(RG_PATTERN_WX_10240), -9 },
	{ WINDOWS_INDEX::WX_17763, RTL_CONSTANT_STRING(L"CmUnRegisterCallback"),                RTL_CONSTANT_STRING(L"DbgkLkmdUnregisterCallback"),                RG_PATTERN_WX_10240, sizeof(RG_PATTERN_WX_10240), -9 },
	{ WINDOWS_INDEX::WX_18362, RTL_CONSTANT_STRING(L"CmUnRegisterCallback"),                RTL_CONSTANT_STRING(L"DbgkLkmdUnregisterCallback"),                RG_PATTERN_WX_10240, sizeof(RG_PATTERN_WX_10240), -9 },
	{ WINDOWS_INDEX::WX_18363, RTL_CONSTANT_STRING(L"CmUnRegisterCallback"),                RTL_CONSTANT_STRING(L"DbgkLkmdUnregisterCallback"),                RG_PATTERN_WX_10240, sizeof(RG_PATTERN_WX_10240), -9 },
	{ WINDOWS_INDEX::WX_19041, RTL_CONSTANT_STRING(L"CmUnRegisterCallback"),                RTL_CONSTANT_STRING(L"DbgkLkmdUnregisterCallback"),                RG_PATTERN_WX_10240, sizeof(RG_PATTERN_WX_10240), -9 },
	{ WINDOWS_INDEX::WX_19042, RTL_CONSTANT_STRING(L"CmUnRegisterCallback"),                RTL_CONSTANT_STRING(L"DbgkLkmdUnregisterCallback"),                RG_PATTERN_WX_10240, sizeof(RG_PATTERN_WX_10240), -9 },
};

UCHAR OB_PATTERN_W7_07600[] = { 0x41, 0x8a, 0xde, 0x44, 0x88, 0x74, 0x24, 0x47, 0x88, 0x5c, 0x24, 0x46, 0x4c, 0x89, 0x74, 0x24, 0x38, 0x4c, 0x89, 0x74, 0x24, 0x30, 0x49, 0x8b, 0xee, 0xc7, 0x44, 0x24, 0x48 };
UCHAR OB_PATTERN_W8_08102[] = { 0x41, 0x8a, 0xd8, 0x44, 0x88, 0x44, 0x24, 0x4f, 0x88, 0x5c, 0x24, 0x4e, 0x4c, 0x89, 0x44, 0x24, 0x38, 0x4d, 0x8b, 0xf0, 0x4c, 0x89, 0x44, 0x24, 0x30, 0xc7, 0x44, 0x24, 0x50 };
UCHAR OB_PATTERN_WX_10240[] = { 0x0f, 0xb7, 0x02, 0xff, 0xc9, 0x49, 0x03 };
CALLBACK_SEARCH_QUERY ObjectCallbackQueries[14] = {
	{ WINDOWS_INDEX::W7_07600, RTL_CONSTANT_STRING(L"ObUnRegisterCallbacks"),               RTL_CONSTANT_STRING(L"ObCreateObjectType"),                        OB_PATTERN_W7_07600, sizeof(OB_PATTERN_W7_07600), -4 },
	{ WINDOWS_INDEX::W8_08102, RTL_CONSTANT_STRING(L"ObCreateObjectType"),                  RTL_CONSTANT_STRING(L"IoCreateController"),                        OB_PATTERN_W8_08102, sizeof(OB_PATTERN_W8_08102), -4 },
	{ WINDOWS_INDEX::W8_09431, RTL_CONSTANT_STRING(L"ObCreateObjectType"),                  RTL_CONSTANT_STRING(L"RtlRunOnceInitialize"),                      OB_PATTERN_W8_08102, sizeof(OB_PATTERN_W8_08102), -4 },
	{ WINDOWS_INDEX::WX_10240, RTL_CONSTANT_STRING(L"ObCreateObjectType"),                  RTL_CONSTANT_STRING(L"RtlRunOnceInitialize"),                      OB_PATTERN_WX_10240, sizeof(OB_PATTERN_WX_10240), 25 },
	{ WINDOWS_INDEX::WX_10586, RTL_CONSTANT_STRING(L"ObCreateObjectType"),                  RTL_CONSTANT_STRING(L"RtlRunOnceInitialize"),                      OB_PATTERN_WX_10240, sizeof(OB_PATTERN_WX_10240), 25 },
	{ WINDOWS_INDEX::WX_14393, RTL_CONSTANT_STRING(L"ObCreateObjectType"),                  RTL_CONSTANT_STRING(L"KseRegisterShim"),                           OB_PATTERN_WX_10240, sizeof(OB_PATTERN_WX_10240), 25 },
	{ WINDOWS_INDEX::WX_15063, RTL_CONSTANT_STRING(L"ObCreateObjectType"),                  RTL_CONSTANT_STRING(L"IoCreateDriver"),                            OB_PATTERN_WX_10240, sizeof(OB_PATTERN_WX_10240), 25 },
	{ WINDOWS_INDEX::WX_16299, RTL_CONSTANT_STRING(L"ObCreateObjectType"),                  RTL_CONSTANT_STRING(L"IoCreateDriver"),                            OB_PATTERN_WX_10240, sizeof(OB_PATTERN_WX_10240), 25 },
	{ WINDOWS_INDEX::WX_17134, RTL_CONSTANT_STRING(L"ObCreateObjectType"),                  RTL_CONSTANT_STRING(L"IoCreateDriver"),                            OB_PATTERN_WX_10240, sizeof(OB_PATTERN_WX_10240), 25 },
	{ WINDOWS_INDEX::WX_17763, RTL_CONSTANT_STRING(L"ObCreateObjectType"),                  RTL_CONSTANT_STRING(L"IoCreateDriver"),                            OB_PATTERN_WX_10240, sizeof(OB_PATTERN_WX_10240), 25 },
	{ WINDOWS_INDEX::WX_18362, RTL_CONSTANT_STRING(L"ObCreateObjectType"),                  RTL_CONSTANT_STRING(L"IoCreateDriver"),                            OB_PATTERN_WX_10240, sizeof(OB_PATTERN_WX_10240), 25 },
	{ WINDOWS_INDEX::WX_18363, RTL_CONSTANT_STRING(L"ObCreateObjectType"),                  RTL_CONSTANT_STRING(L"PoCreateThermalRequest"),                    OB_PATTERN_WX_10240, sizeof(OB_PATTERN_WX_10240), 25 },
	{ WINDOWS_INDEX::WX_19041, RTL_CONSTANT_STRING(L"ObCreateObjectType"),                  RTL_CONSTANT_STRING(L"IoCreateDriver"),                            OB_PATTERN_WX_10240, sizeof(OB_PATTERN_WX_10240), 25 },
	{ WINDOWS_INDEX::WX_19042, RTL_CONSTANT_STRING(L"ObCreateObjectType"),                  RTL_CONSTANT_STRING(L"IoCreateDriver"),                            OB_PATTERN_WX_10240, sizeof(OB_PATTERN_WX_10240), 25 },
};

FLT_POSTOP_CALLBACK_STATUS
PfltPostOperationCallback(
	PFLT_CALLBACK_DATA Data,
	PCFLT_RELATED_OBJECTS FltObjects,
	PVOID CompletionContext,
	FLT_POST_OPERATION_FLAGS Flags
)
{
	UNREFERENCED_PARAMETER(Data);
	UNREFERENCED_PARAMETER(FltObjects);
	UNREFERENCED_PARAMETER(CompletionContext);
	UNREFERENCED_PARAMETER(Flags);

	return FLT_POSTOP_FINISHED_PROCESSING;
}

FLT_PREOP_CALLBACK_STATUS
PfltPreOperationCallback(
	PFLT_CALLBACK_DATA Data,
	PCFLT_RELATED_OBJECTS FltObjects,
	PVOID* CompletionContext
)
{
	UNREFERENCED_PARAMETER(Data);
	UNREFERENCED_PARAMETER(FltObjects);
	UNREFERENCED_PARAMETER(CompletionContext);

	return FLT_PREOP_SUCCESS_NO_CALLBACK;
}

WINDOWS_INDEX GetWindowsIndex()
{
	PfltPreOperationCallback(nullptr, nullptr, nullptr);
	PfltPostOperationCallback(nullptr, nullptr, nullptr, NULL);

	OSVERSIONINFOEXW OsVersionInfo;
	OsVersionInfo.dwOSVersionInfoSize = sizeof(OSVERSIONINFOEXW);
	RtlGetVersion((POSVERSIONINFOW)&OsVersionInfo);
	
	switch (OsVersionInfo.dwBuildNumber)
	{
	case 7600:
	case 7601:
		return WINDOWS_INDEX::W7_07600;
		break;
	case 8102:
	case 8250:
	case 9200:
		return WINDOWS_INDEX::W8_08102;
	case 9431:
	case 9600:
		return WINDOWS_INDEX::W8_09431;
		break;
	case 10240: // 1507
		return WINDOWS_INDEX::WX_10240;
		break;
	case 10586: // 1511
		return WINDOWS_INDEX::WX_10586;
		break;
	case 14393: // 1607
		return WINDOWS_INDEX::WX_14393;
		break;
	case 15063: // 1703
		return WINDOWS_INDEX::WX_15063;
		break;
	case 16299: // 1709
		return WINDOWS_INDEX::WX_16299;
		break;
	case 17134: // 1803
		return WINDOWS_INDEX::WX_17134;
		break;
	case 17763: // 1809
		return WINDOWS_INDEX::WX_17763;
		break;
	case 18362: // 1903
		return WINDOWS_INDEX::WX_18362;
		break;
	case 18363: // 1909
		return WINDOWS_INDEX::WX_18363;
		break;
	case 19041: // 2004
		return WINDOWS_INDEX::WX_19041;
		break;
	case 19042: // 20H2
		return WINDOWS_INDEX::WX_19042;
		break;
	default:
		return WINDOWS_INDEX::Unsupported;
	}
}

NTSTATUS GetLoadImageNotifyCallbacks(OUT CALLBACK_INFO* CallbackArray, OUT ULONG* CallbackCount)
{
	// Check if supported for this version of Windows.
	WINDOWS_INDEX WindowsIndex = GetWindowsIndex();
	if (WindowsIndex == WINDOWS_INDEX::Unsupported)
		return STATUS_NOT_SUPPORTED;

	// Get search query.
	CALLBACK_SEARCH_QUERY Query = LoadImageCallbackQueries[(ULONG)WindowsIndex];

	// Resolve function addresses to get the start and end of the search space.
	PUCHAR StartAddress = (PUCHAR)MmGetSystemRoutineAddress(&Query.StartFunction);
	PUCHAR EndAddress = (PUCHAR)MmGetSystemRoutineAddress(&Query.EndFunction);

	// Search for an offset to the PspLoadImageNotifyRoutine array.
	// This array contains the registered load image notification callbacks.
	PUCHAR PspLoadImageNotifyRoutine = nullptr;
	NTSTATUS Status = MemorySearch(StartAddress, EndAddress, Query.PatternBuffer, Query.PatternSize, &PspLoadImageNotifyRoutine);

	if (!NT_SUCCESS(Status))
		return STATUS_NOT_FOUND;

	// Resolve the offset to get the address of PspLoadImageNotifyRoutine.
	PspLoadImageNotifyRoutine += Query.PatternOffset;
	PspLoadImageNotifyRoutine += *(PLONG)(PspLoadImageNotifyRoutine);
	PspLoadImageNotifyRoutine += sizeof(LONG);

	// Copy the callback addresses to the provided array.
	for (int i = 0; i < MAX_CALLBACKS_LOAD_IMAGE; i++)
	{
		// Check if a pointer to the callback exists at this index of the registered callbacks array.
		PVOID PointerToCallback = (PVOID)(*(PULONG64)((ULONG64)PspLoadImageNotifyRoutine + i * 8LL));
		
		// If so, copy the callback address to the output array.
		if (PointerToCallback)
		{
			CallbackArray[i].Type = CALLBACK_TYPE::PsLoadImage;
			CallbackArray[i].Address = (PVOID)(*(PULONG64)((ULONG64)PointerToCallback & 0xFFFFFFFFFFFFFFF8));
		}

		// Otherwise, exit the loop as there are no more callbacks left.
		else
		{
			*CallbackCount = i;
			break;
		}
	}

	return STATUS_SUCCESS;
}

NTSTATUS GetCreateProcessNotifyCallbacks(OUT CALLBACK_INFO* CallbackArray, OUT ULONG* CallbackCount)
{
	// Check if supported for this version of Windows.
	WINDOWS_INDEX WindowsIndex = GetWindowsIndex();
	if (WindowsIndex == WINDOWS_INDEX::Unsupported)
		return STATUS_NOT_SUPPORTED;

	// Get search query.
	CALLBACK_SEARCH_QUERY Query = CreateProcessCallbackQueries[(ULONG)WindowsIndex];

	// Resolve function addresses to get the start and end of the search space.
	PUCHAR StartAddress = (PUCHAR)MmGetSystemRoutineAddress(&Query.StartFunction);
	PUCHAR EndAddress = (PUCHAR)MmGetSystemRoutineAddress(&Query.EndFunction);

	// Search for an offset to the PspCreateProcessNotifyRoutine array.
	PUCHAR PspSetCreateProcessNotifyRoutine = nullptr;
	NTSTATUS Status = MemorySearch(StartAddress, EndAddress, Query.PatternBuffer, Query.PatternSize, &PspSetCreateProcessNotifyRoutine);

	if (!NT_SUCCESS(Status))
		return STATUS_NOT_FOUND;

	// Resolve the offset to get the address of PspCreateProcessNotifyRoutine.
	PspSetCreateProcessNotifyRoutine += Query.PatternOffset;
	PspSetCreateProcessNotifyRoutine += *(PLONG)(PspSetCreateProcessNotifyRoutine);
	PspSetCreateProcessNotifyRoutine += sizeof(LONG);

	// Copy the callback addresses to the provided array.
	for (int i = 0; i < MAX_CALLBACKS_CREATE_PROCESS; i++)
	{
		// Check if a pointer to the callback exists at this index of the registered callbacks array.
		PVOID PointerToCallback = (PVOID)(*(PULONG64)((ULONG64)PspSetCreateProcessNotifyRoutine + i * 8LL));

		// If so, copy the callback address to the output array.
		if (PointerToCallback)
		{
			CallbackArray[i].Type = CALLBACK_TYPE::PsProcessCreation;
			CallbackArray[i].Address = (PVOID)(*(PULONG64)((ULONG64)PointerToCallback & 0xFFFFFFFFFFFFFFF8));
		}

		// Otherwise, exit the loop as there are no more callbacks left.
		else
		{
			*CallbackCount = i;
			break;
		}
	}

	return STATUS_SUCCESS;
}

NTSTATUS GetCreateThreadNotifyCallbacks(OUT CALLBACK_INFO* CallbackArray, OUT ULONG* CallbackCount)
{
	// Check if supported for this version of Windows.
	WINDOWS_INDEX WindowsIndex = GetWindowsIndex();
	if (WindowsIndex == WINDOWS_INDEX::Unsupported)
		return STATUS_NOT_SUPPORTED;

	// Get search query.
	CALLBACK_SEARCH_QUERY Query = CreateThreadCallbackQueries[(ULONG)WindowsIndex];

	// Resolve function addresses to get the start and end of the search space.
	PUCHAR StartAddress = (PUCHAR)MmGetSystemRoutineAddress(&Query.StartFunction);
	PUCHAR EndAddress = (PUCHAR)MmGetSystemRoutineAddress(&Query.EndFunction);

	// Search for an offset to the PspCreateThreadNotifyRoutine array.
	PUCHAR PspCreateThreadNotifyRoutine = nullptr;
	NTSTATUS Status = MemorySearch(StartAddress, EndAddress, Query.PatternBuffer, Query.PatternSize, &PspCreateThreadNotifyRoutine);

	if (!NT_SUCCESS(Status))
		return STATUS_NOT_FOUND;

	// Resolve the offset to get the address of PspCreateThreadNotifyRoutine.
	PspCreateThreadNotifyRoutine += Query.PatternOffset;
	PspCreateThreadNotifyRoutine += *(PLONG)(PspCreateThreadNotifyRoutine);
	PspCreateThreadNotifyRoutine += sizeof(LONG);

	// Copy the callback addresses to the provided array.
	for (int i = 0; i < MAX_CALLBACKS_CREATE_THREAD; i++)
	{
		// Check if a pointer to the callback exists at this index of the registered callbacks array.
		PVOID PointerToCallback = (PVOID)(*(PULONG64)((ULONG64)PspCreateThreadNotifyRoutine + i * 8LL));

		// If so, copy the callback address to the output array.
		if (PointerToCallback)
		{
			CallbackArray[i].Type = CALLBACK_TYPE::PsThreadCreation;
			CallbackArray[i].Address = (PVOID)(*(PULONG64)((ULONG64)PointerToCallback & 0xFFFFFFFFFFFFFFF8));
		}

		// Otherwise, exit the loop as there are no more callbacks left.
		else
		{
			*CallbackCount = i;
			break;
		}
	}

	return STATUS_SUCCESS;
}

NTSTATUS GetRegistryCallbacks(OUT CALLBACK_INFO* CallbackArray, OUT ULONG* CallbackCount)
{
	// Check if supported for this version of Windows.
	WINDOWS_INDEX WindowsIndex = GetWindowsIndex();
	if (WindowsIndex == WINDOWS_INDEX::Unsupported)
		return STATUS_NOT_SUPPORTED;

	// Get search query.
	CALLBACK_SEARCH_QUERY Query = RegistryCallbackQueries[(ULONG)WindowsIndex];

	// Resolve function addresses to get the start and end of the search space.
	PUCHAR StartAddress = (PUCHAR)MmGetSystemRoutineAddress(&Query.StartFunction);
	PUCHAR EndAddress = (PUCHAR)MmGetSystemRoutineAddress(&Query.EndFunction);

	// Search for an offset to the CallbackListHeadOrCmpCallBackVector linked-list head.
	PUCHAR CallbackListHeadOrCmpCallBackVector = nullptr;
	NTSTATUS Status = MemorySearch(StartAddress, EndAddress, Query.PatternBuffer, Query.PatternSize, &CallbackListHeadOrCmpCallBackVector);

	if (!NT_SUCCESS(Status))
		return STATUS_NOT_FOUND;

	// Resolve the offset to get the address of CallbackListHeadOrCmpCallBackVector.
	CallbackListHeadOrCmpCallBackVector += Query.PatternOffset;
	CallbackListHeadOrCmpCallBackVector += *(PLONG)(CallbackListHeadOrCmpCallBackVector);
	CallbackListHeadOrCmpCallBackVector += sizeof(LONG);

	// Iterate through the linked list to populate the provided array.
	int i = 0;
	PLIST_ENTRY ListEntry = (PLIST_ENTRY)CallbackListHeadOrCmpCallBackVector;
	while (1)
	{
		PVOID CallbackFunction = *(PVOID*)((ULONG64)ListEntry + 0x28);
		CallbackArray[i].Type = CALLBACK_TYPE::CmRegistry;
		CallbackArray[i++].Address = CallbackFunction;
		ListEntry = ListEntry->Flink;

		// Break when back to first entry or array limit reached.
		if (((PVOID)ListEntry == (PVOID)CallbackListHeadOrCmpCallBackVector) || (i == MAX_CALLBACKS_REGISTRY))
		{
			*CallbackCount = i;
			break;
		}
	};

	return STATUS_SUCCESS;
}

NTSTATUS GetObjectCallbacks(OUT CALLBACK_INFO* CallbackArray, OUT ULONG* CallbackCount)
{
	// Reset callback count to 0.
	*CallbackCount = 0;

	// Check if supported for this version of Windows.
	WINDOWS_INDEX WindowsIndex = GetWindowsIndex();
	if (WindowsIndex == WINDOWS_INDEX::Unsupported)
		return STATUS_NOT_SUPPORTED;

	// Get search query.
	CALLBACK_SEARCH_QUERY Query = ObjectCallbackQueries[(ULONG)WindowsIndex];

	// Resolve function addresses to get the start and end of the search space.
	PUCHAR StartAddress = (PUCHAR)MmGetSystemRoutineAddress(&Query.StartFunction);
	PUCHAR EndAddress = (PUCHAR)MmGetSystemRoutineAddress(&Query.EndFunction);

	// Search for an offset to the ObpTypeDirectoryObject linked-list head.
	PUCHAR ObpTypeDirectoryObject = nullptr;
	NTSTATUS Status = MemorySearch(StartAddress, EndAddress, Query.PatternBuffer, Query.PatternSize, &ObpTypeDirectoryObject);
	
	if (!NT_SUCCESS(Status))
		return STATUS_NOT_FOUND;

	// Resolve the offset to get the address of CallbackListHeadOrCmpCallBackVector.
	ObpTypeDirectoryObject += Query.PatternOffset;
	ObpTypeDirectoryObject += *(PLONG)(ObpTypeDirectoryObject);
	ObpTypeDirectoryObject += sizeof(LONG);

	UNICODE_STRING TypesWhitelist[3] = {
		RTL_CONSTANT_STRING(L"Process"),
		RTL_CONSTANT_STRING(L"Thread"),
		RTL_CONSTANT_STRING(L"Desktop")};

	POBJECT_DIRECTORY ObjectDirectory = (POBJECT_DIRECTORY)ObpTypeDirectoryObject;
	POBJECT_DIRECTORY_ENTRY* ObjectDirectoryEntries = (POBJECT_DIRECTORY_ENTRY*)ObjectDirectory->HashBuckets[0];

	for (int i = 0; i < OBJECT_HASH_TABLE_SIZE; i++)
	{
		POBJECT_DIRECTORY_ENTRY ObjectDirectoryEntry = ObjectDirectoryEntries[i];

		while (ObjectDirectoryEntry)
		{
			PVOID ObjectType = ObjectDirectoryEntry->ObjectType;
			PUNICODE_STRING ObjectName = (PUNICODE_STRING)((ULONG64)ObjectType + 0x10);
			UCHAR Offset = (GetWindowsIndex() == WINDOWS_INDEX::W7_07600) ? 0xC0 : 0xC8;
			POBJECT_CALLBACK_ENTRY ObjectCallbackEntry = (POBJECT_CALLBACK_ENTRY)((ULONG64)ObjectType + Offset);
			
			OBJECT_CALLBACK_TYPE ObjectCallbackType;
			if (!RtlCompareUnicodeString(ObjectName, &TypesWhitelist[0], TRUE))
				ObjectCallbackType = OBJECT_CALLBACK_TYPE::Process;
			else if (!RtlCompareUnicodeString(ObjectName, &TypesWhitelist[1], TRUE))
				ObjectCallbackType = OBJECT_CALLBACK_TYPE::Thread;
			else if (!RtlCompareUnicodeString(ObjectName, &TypesWhitelist[2], TRUE))
				ObjectCallbackType = OBJECT_CALLBACK_TYPE::Desktop;
			else
				ObjectCallbackType = OBJECT_CALLBACK_TYPE::Unknown;

			if (ObjectCallbackType != OBJECT_CALLBACK_TYPE::Unknown)
			{
				do
				{
					if ((ObjectCallbackEntry->Active == 1) && (ObjectCallbackEntry->ObjectType))
					{
						if (ObjectCallbackEntry->PreOperation)
						{
							switch (ObjectCallbackType)
							{
							case OBJECT_CALLBACK_TYPE::Process:
								CallbackArray[*CallbackCount].Type = CALLBACK_TYPE::ObProcessHandlePre;
								break;
							case OBJECT_CALLBACK_TYPE::Thread:
								CallbackArray[*CallbackCount].Type = CALLBACK_TYPE::ObThreadHandlePre;
								break;
							case OBJECT_CALLBACK_TYPE::Desktop:
								CallbackArray[*CallbackCount].Type = CALLBACK_TYPE::ObDesktopHandlePre;
								break;
							default:
								CallbackArray[*CallbackCount].Type = CALLBACK_TYPE::Unknown;
								break;
							}

							CallbackArray[*CallbackCount].Address = ObjectCallbackEntry->PreOperation;
							*CallbackCount += 1;
						}

						if (ObjectCallbackEntry->PostOperation)
						{
							switch (ObjectCallbackType)
							{
							case OBJECT_CALLBACK_TYPE::Process:
								CallbackArray[*CallbackCount].Type = CALLBACK_TYPE::ObProcessHandlePost;
								break;
							case OBJECT_CALLBACK_TYPE::Thread:
								CallbackArray[*CallbackCount].Type = CALLBACK_TYPE::ObThreadHandlePost;
								break;
							case OBJECT_CALLBACK_TYPE::Desktop:
								CallbackArray[*CallbackCount].Type = CALLBACK_TYPE::ObDesktopHandlePost;
								break;
							default:
								CallbackArray[*CallbackCount].Type = CALLBACK_TYPE::Unknown;
								break;
							}

							CallbackArray[*CallbackCount].Address = ObjectCallbackEntry->PostOperation;
							*CallbackCount += 1;
						}
					}

					ObjectCallbackEntry = (POBJECT_CALLBACK_ENTRY)ObjectCallbackEntry->CallbackList.Flink;
				} while (ObjectCallbackEntry != (POBJECT_CALLBACK_ENTRY)((ULONG64)ObjectType + Offset));
			}
			
			ObjectDirectoryEntry = ObjectDirectoryEntry->ChainLink;
		}
	}

	return STATUS_SUCCESS;
}

NTSTATUS GetMinifilterCallbacks(OUT CALLBACK_INFO* CallbackArray, OUT ULONG* CallbackCount)
{
	UNREFERENCED_PARAMETER(CallbackArray);
	UNREFERENCED_PARAMETER(CallbackCount);

	NTSTATUS Status = STATUS_SUCCESS;

	// Reset callback count to 0.
	*CallbackCount = 0;

	ULONG NumberFiltersReturned = 0;
	Status = FltEnumerateFilters(nullptr, 0, &NumberFiltersReturned);
	if (Status != STATUS_BUFFER_TOO_SMALL)
		return Status;

	SIZE_T BufferSize = sizeof(PFLT_FILTER) * NumberFiltersReturned;
	PFLT_FILTER* FilterList = (PFLT_FILTER*)ExAllocatePoolWithTag(NonPagedPool, BufferSize, DRIVER_TAG);
	if (!FilterList)
		return STATUS_INSUFFICIENT_RESOURCES;

	Status = FltEnumerateFilters(FilterList, (ULONG)BufferSize, &NumberFiltersReturned);
	if (!NT_SUCCESS(Status))
		return Status;

	for (ULONG i = 0; i < NumberFiltersReturned; i++)
	{
		ULONG BytesReturned = 0;
		Status = FltGetFilterInformation(FilterList[i], FilterFullInformation, nullptr, 0, &BytesReturned);
		if (Status != STATUS_BUFFER_TOO_SMALL)
			continue;

		PFILTER_FULL_INFORMATION FullFilterInfo = (PFILTER_FULL_INFORMATION)ExAllocatePoolWithTag(NonPagedPool, BytesReturned, DRIVER_TAG);
		if (!FullFilterInfo)
			continue;

		Status = FltGetFilterInformation(FilterList[i], FilterFullInformation, FullFilterInfo, BytesReturned, &BytesReturned);
		if (!NT_SUCCESS(Status))
			continue;

		ULONG NumberInstancesReturned = 0;
		Status = FltEnumerateInstances(nullptr, FilterList[i], nullptr, 0, &NumberInstancesReturned);
		if (Status != STATUS_BUFFER_TOO_SMALL)
			continue;

		BufferSize = sizeof(PFLT_INSTANCE) * NumberInstancesReturned;
		PFLT_INSTANCE* InstanceList = (PFLT_INSTANCE*)ExAllocatePoolWithTag(NonPagedPool, BufferSize, DRIVER_TAG);
		if (!InstanceList)
			continue;

		Status = FltEnumerateInstances(nullptr, FilterList[i], InstanceList, NumberInstancesReturned, &NumberInstancesReturned);
		if (!NT_SUCCESS(Status))
			continue;

		if (!NumberInstancesReturned)
			continue;

		for (ULONG j = 0x16; j < 0x32; j++)
		{
			// Hardcoding the offsets from https://github.com/gentilkiwi/mimikatz/blob/master/mimidrv/kkll_m_filters.c#L34.
			// This should probably be changed in the future.
			PVOID Callback = (PVOID)*(PULONG_PTR)((((ULONG_PTR)InstanceList[0]) + 0x90) + sizeof(PVOID) * j);

			if (Callback)
			{
				PVOID PreCallback = (PVOID) * (PULONG_PTR)(((ULONG_PTR)Callback) + 0x18);
				PVOID PostCallback = (PVOID) * (PULONG_PTR)(((ULONG_PTR)Callback) + 0x20);

				if (PreCallback)
				{
					CallbackArray[*CallbackCount].Type = (CALLBACK_TYPE)((j - 0x16) * 2 + 11);
					CallbackArray[*CallbackCount].Address = PreCallback;
					*CallbackCount += 1;
				}

				if (PostCallback)
				{
					CallbackArray[*CallbackCount].Type = (CALLBACK_TYPE)((j - 0x16) * 2 + 12);
					CallbackArray[*CallbackCount].Address = PostCallback;
					*CallbackCount += 1;
				}
			}
		}
	}

	return STATUS_SUCCESS;
}
```

`TelemetrySourcererDriver/Callbacks.h`:

```h
#pragma once

#include "Common.h"

#define MAX_CALLBACKS_LOAD_IMAGE     64
#define MAX_CALLBACKS_CREATE_PROCESS 64
#define MAX_CALLBACKS_CREATE_THREAD  64
#define MAX_CALLBACKS_REGISTRY       100
#define OBJECT_HASH_TABLE_SIZE	     37

enum class WINDOWS_INDEX
{
	W7_07600 = 0,
	W8_08102,
	W8_09431,
	WX_10240, // Win10 1507
	WX_10586, // Win10 1511
	WX_14393, // Win10 1607
	WX_15063, // Win10 1703
	WX_16299, // Win10 1709
	WX_17134, // Win10 1803
	WX_17763, // Win10 1809
	WX_18362, // Win10 1903
	WX_18363, // Win10 1909
	WX_19041, // Win10 2004
	WX_19042, // Win10 20H2
	Unsupported
};

enum class OBJECT_CALLBACK_TYPE
{
	Unknown = 0,
	Process,
	Thread,
	Desktop
};

typedef struct _OBJECT_DIRECTORY_ENTRY
{
	struct _OBJECT_DIRECTORY_ENTRY* ChainLink;
	PVOID                           ObjectType;
} OBJECT_DIRECTORY_ENTRY, *POBJECT_DIRECTORY_ENTRY;

typedef struct _OBJECT_DIRECTORY
{
	POBJECT_DIRECTORY_ENTRY HashBuckets[OBJECT_HASH_TABLE_SIZE];
	/* ... */
} OBJECT_DIRECTORY, *POBJECT_DIRECTORY;

typedef struct _OBJECT_CALLBACK_ENTRY
{
	LIST_ENTRY                  CallbackList;
	OB_OPERATION                Operations;
	ULONG                       Active;
	PVOID                       Handle;
	POBJECT_TYPE                ObjectType;
	POB_PRE_OPERATION_CALLBACK  PreOperation;
	POB_POST_OPERATION_CALLBACK PostOperation;
	/* ... */
} OBJECT_CALLBACK_ENTRY, *POBJECT_CALLBACK_ENTRY;

typedef struct _CALLBACK_SEARCH_QUERY
{
	WINDOWS_INDEX  WindowsIndex;
	UNICODE_STRING StartFunction;
	UNICODE_STRING EndFunction;
	PUCHAR         PatternBuffer;
	SIZE_T         PatternSize;
	LONG           PatternOffset;
} CALLBACK_SEARCH_QUERY, *PCALLBACK_SEARCH_QUERY;

NTSTATUS GetLoadImageNotifyCallbacks(OUT CALLBACK_INFO* CallbackArray, OUT ULONG* CallbackCount);
NTSTATUS GetCreateProcessNotifyCallbacks(OUT CALLBACK_INFO* CallbackArray, OUT ULONG* CallbackCount);
NTSTATUS GetCreateThreadNotifyCallbacks(OUT CALLBACK_INFO* CallbackArray, OUT ULONG* CallbackCount);
NTSTATUS GetRegistryCallbacks(OUT CALLBACK_INFO* CallbackArray, OUT ULONG* CallbackCount);
NTSTATUS GetObjectCallbacks(OUT CALLBACK_INFO* CallbackArray, OUT ULONG* CallbackCount);
NTSTATUS GetMinifilterCallbacks(OUT CALLBACK_INFO* CallbackArray, OUT ULONG* CallbackCount);

```

`TelemetrySourcererDriver/Common.h`:

```h
#pragma once

#define TELEMETRY_SOURCERER_DEVICE 0x8000
#define IOCTL_SANDBOX              CTL_CODE(TELEMETRY_SOURCERER_DEVICE, 0x800, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define IOCTL_GET_MODULES          CTL_CODE(TELEMETRY_SOURCERER_DEVICE, 0x801, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define IOCTL_GET_CALLBACKS        CTL_CODE(TELEMETRY_SOURCERER_DEVICE, 0x802, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define IOCTL_GET_QWORD            CTL_CODE(TELEMETRY_SOURCERER_DEVICE, 0x803, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define IOCTL_SET_QWORD            CTL_CODE(TELEMETRY_SOURCERER_DEVICE, 0x804, METHOD_BUFFERED, FILE_ANY_ACCESS)

#define MAX_MODULES   512
#define MAX_CALLBACKS 512

typedef struct _MODULE_INFO
{
	UCHAR Name[256];
	PVOID Address;
	ULONG Size;
} MODULE_INFO, *PMODULE_INFO;

enum class CALLBACK_TYPE
{
	Unknown = 0,
	PsLoadImage,
	PsProcessCreation,
	PsThreadCreation,
	CmRegistry,
	ObProcessHandlePre,
	ObProcessHandlePost,
	ObThreadHandlePre,
	ObThreadHandlePost,
	ObDesktopHandlePre,
	ObDesktopHandlePost,
	MfCreatePre,
	MfCreatePost,
	MfCreateNamedPipePre,
	MfCreateNamedPipePost,
	MfClosePre,
	MfClosePost,
	MfReadPre,
	MfReadPost,
	MfWritePre,
	MfWritePost,
	MfQueryInformationPre,
	MfQueryInformationPost,
	MfSetInformationPre,
	MfSetInformationPost,
	MfQueryEaPre,
	MfQueryEaPost,
	MfSetEaPre,
	MfSetEaPost,
	MfFlushBuffersPre,
	MfFlushBuffersPost,
	MfQueryVolumeInformationPre,
	MfQueryVolumeInformationPost,
	MfSetVolumeInformationPre,
	MfSetVolumeInformationPost,
	MfDirectoryControlPre,
	MfDirectoryControlPost,
	MfFileSystemControlPre,
	MfFileSystemControlPost,
	MfDeviceControlPre,
	MfDeviceControlPost,
	MfInternalDeviceControlPre,
	MfInternalDeviceControlPost,
	MfShutdownPre,
	MfShutdownPost,
	MfLockControlPre,
	MfLockControlPost,
	MfCleanupPre,
	MfCleanupPost,
	MfCreateMailslotPre,
	MfCreateMailslotPost,
	MfQuerySecurityPre,
	MfQuerySecurityPost,
	MfSetSecurityPre,
	MfSetSecurityPost,
	MfPowerPre,
	MfPowerPost,
	MfSystemControlPre,
	MfSystemControlPost,
	MfDeviceChangePre,
	MfDeviceChangePost,
	MfQueryQuotaPre,
	MfQueryQuotaPost,
	MfSetQuotaPre,
	MfSetQuotaPost,
	MfPnpPre,
	MfPnpPost,
};

typedef struct _CALLBACK_INFO
{
	CALLBACK_TYPE Type    = CALLBACK_TYPE::Unknown;
	PVOID         Address = nullptr;
} CALLBACK_INFO, *PCALLBACK_INFO;

typedef struct _QWORD_INFO
{
	PULONG64 Address = nullptr;
	ULONG64  Value   = 0;
} QWORD_INFO, *PQWORD_INFO;
```

`TelemetrySourcererDriver/Memory.cpp`:

```cpp
#include <ntddk.h>
#include <intrin.h>

#include "Memory.h"

#pragma intrinsic(__readmsr)

NTSTATUS MemorySearch(PCUCHAR StartAddress, PCUCHAR EndAddress, PCUCHAR PatternBuffer, SIZE_T PatternLength, PUCHAR* FoundAddress)
{
	*FoundAddress = (PUCHAR)StartAddress;

	while (*FoundAddress < EndAddress)
	{
		if (RtlEqualMemory(PatternBuffer, *FoundAddress, PatternLength))
			return STATUS_SUCCESS;
		else
			*FoundAddress += 1;
	}

	return STATUS_NOT_FOUND;
}

NTSTATUS SetWriteProtect(ULONG Enable)
{
	for (ULONG i = 0; i < KeQueryActiveProcessorCount(0); i++)
	{
		KAFFINITY OldAffinity = KeSetSystemAffinityThreadEx((KAFFINITY)(1i64 << i));

		CR0 cr0;
		cr0.flags = __readcr0();
		cr0.write_protect = (Enable) ? 1 : 0;
		__writecr0(cr0.flags);

		KeRevertToUserAffinityThreadEx(OldAffinity);
	}

	return STATUS_SUCCESS;
}

NTSTATUS WriteVirtualMemory(PVOID Destination, PVOID Source, SIZE_T Length)
{
	PHYSICAL_ADDRESS PhysicalAddress = MmGetPhysicalAddress(Destination);
	PVOID MappedDestination = MmMapIoSpace(PhysicalAddress, Length, MmNonCached);
	RtlCopyMemory(MappedDestination, Source, Length);
	MmUnmapIoSpace(MappedDestination, Length);

	return STATUS_SUCCESS;
}
```

`TelemetrySourcererDriver/Memory.h`:

```h
#pragma once

#pragma warning(disable:4201)
typedef union {
	struct {
		UINT64 protection_enable   : 1;
		UINT64 monitor_coprocessor : 1;
		UINT64 emulate_fpu         : 1;
		UINT64 task_switched       : 1;
		UINT64 extension_type      : 1;
		UINT64 numeric_error       : 1;
		UINT64 reserved_1          : 10;
		UINT64 write_protect       : 1;
		UINT64 reserved_2          : 1;
		UINT64 alignment_mask      : 1;
		UINT64 reserved_3          : 10;
		UINT64 not_write_through   : 1;
		UINT64 cache_disable       : 1;
		UINT64 paging_enable       : 1;
	};

	UINT64 flags;
} CR0;

NTSTATUS MemorySearch(PCUCHAR StartAddress, PCUCHAR EndAddress, PCUCHAR PatternBuffer, SIZE_T PatternLength, PUCHAR* FoundAddress);
NTSTATUS SetWriteProtect(ULONG Enable);
NTSTATUS WriteVirtualMemory(PVOID Destination, PVOID Source, SIZE_T Length);
```

`TelemetrySourcererDriver/Modules.cpp`:

```cpp
#include <ntddk.h>
#include <aux_klib.h>

#include "TelemetrySourcererDriver.h"
#include "Modules.h"

#pragma comment(lib, "Aux_Klib.lib")

NTSTATUS GetModules(OUT MODULE_INFO* ModuleArray)
{
	NTSTATUS Status = STATUS_SUCCESS;

	Status = AuxKlibInitialize();
	if (!NT_SUCCESS(Status))
		return Status;

	ULONG ModulesBufferSize = 0;
	Status = AuxKlibQueryModuleInformation(&ModulesBufferSize, sizeof(AUX_MODULE_EXTENDED_INFO), nullptr);
	if (!NT_SUCCESS(Status))
		return Status;

	PAUX_MODULE_EXTENDED_INFO ModuleExtendedInfo = (PAUX_MODULE_EXTENDED_INFO)ExAllocatePoolWithTag(PagedPool, ModulesBufferSize, DRIVER_TAG);
	if (!ModuleExtendedInfo)
		return STATUS_INSUFFICIENT_RESOURCES;

	Status = AuxKlibQueryModuleInformation(&ModulesBufferSize, sizeof(AUX_MODULE_EXTENDED_INFO), ModuleExtendedInfo);
	if (!NT_SUCCESS(Status))
	{
		ExFreePoolWithTag(ModuleExtendedInfo, DRIVER_TAG);
		return Status;
	}

	ULONG ModuleCount = ModulesBufferSize / sizeof(AUX_MODULE_EXTENDED_INFO);
	for (unsigned long i = 0; i < ModuleCount; i++)
	{
		ModuleArray[i].Address = ModuleExtendedInfo[i].BasicInfo.ImageBase;
		ModuleArray[i].Size = ModuleExtendedInfo[i].ImageSize;
		RtlCopyMemory(ModuleArray[i].Name, ModuleExtendedInfo[i].FullPathName + ModuleExtendedInfo[i].FileNameOffset, MAXIMUM_FILENAME_LENGTH);
		KdPrint(("> TelemetrySourcererDriver: Getting modules... -> %s (0x%p; 0x%p)\n", ModuleArray[i].Name, ModuleArray[i].Address, ModuleArray[i].Size));
	}
	
	ExFreePoolWithTag(ModuleExtendedInfo, DRIVER_TAG);
	return Status;
}
```

`TelemetrySourcererDriver/Modules.h`:

```h
#pragma once

#include "Common.h"

NTSTATUS GetModules(OUT MODULE_INFO* ModuleArray);
```

`TelemetrySourcererDriver/TelemetrySourcererDriver.cpp`:

```cpp
#include <ntddk.h>
#include <wdmsec.h>

#include "TelemetrySourcererDriver.h"
#include "Common.h"
#include "Memory.h"
#include "Modules.h"
#include "Callbacks.h"

extern "C" NTSTATUS DriverEntry(_In_ PDRIVER_OBJECT DriverObject, _In_ PUNICODE_STRING RegistryPath)
{
	NTSTATUS Status = STATUS_SUCCESS;
	UNREFERENCED_PARAMETER(RegistryPath);

	DriverObject->DriverUnload = UnloadDriver;
	DriverObject->MajorFunction[IRP_MJ_CREATE] = DispatchCreateClose;
	DriverObject->MajorFunction[IRP_MJ_CLOSE] = DispatchCreateClose;
	DriverObject->MajorFunction[IRP_MJ_DEVICE_CONTROL] = DispatchDeviceControl;

	// Create device.
	PDEVICE_OBJECT DeviceObject;
	UNICODE_STRING DeviceName = RTL_CONSTANT_STRING(LR"(\Device\TelemetrySourcererDriver)");
	UNICODE_STRING DefaultSDDLString = RTL_CONSTANT_STRING(L"D:P(A;;GA;;;SY)(A;;GA;;;BA)");
	Status = IoCreateDeviceSecure(DriverObject, 0, &DeviceName, FILE_DEVICE_UNKNOWN, 0, FALSE, &DefaultSDDLString, nullptr, &DeviceObject);
	if (NT_SUCCESS(Status))
	{
		DeviceObject->Flags |= DO_BUFFERED_IO;
	}
	else
	{
		DbgPrint("> TelemetrySourcererDriver: Failed to create device (0x%08X).\n", Status);
		return Status;
	}

	// Create symbolic link for device.
	UNICODE_STRING SymbolicLink = RTL_CONSTANT_STRING(LR"(\??\TelemetrySourcererDriver)");
	Status = IoCreateSymbolicLink(&SymbolicLink, &DeviceName);
	if (!NT_SUCCESS(Status))
	{
		DbgPrint("> TelemetrySourcererDriver: Failed to create symbolic link (0x%08X).\n", Status);
		IoDeleteDevice(DeviceObject);
		return Status;
	}

	DbgPrint("> TelemetrySourcererDriver: Compiled on %s %s.\n", __DATE__, __TIME__);
	DbgPrint("> TelemetrySourcererDriver: Initialized successfully.\n");
	return Status;
}

void UnloadDriver(_In_ PDRIVER_OBJECT DriverObject)
{
	// Delete symbolic link and device.
	UNICODE_STRING SymbolicLink = RTL_CONSTANT_STRING(LR"(\??\TelemetrySourcererDriver)");
	IoDeleteSymbolicLink(&SymbolicLink);
	IoDeleteDevice(DriverObject->DeviceObject);

	DbgPrint("> TelemetrySourcererDriver: Unloaded successfully.\n");
}

_Use_decl_annotations_
NTSTATUS DispatchCreateClose(PDEVICE_OBJECT DeviceObject, PIRP Irp)
{
	UNREFERENCED_PARAMETER(DeviceObject);

	Irp->IoStatus.Status = STATUS_SUCCESS;
	Irp->IoStatus.Information = 0;
	IoCompleteRequest(Irp, IO_NO_INCREMENT);
	return STATUS_SUCCESS;
}

_Use_decl_annotations_
NTSTATUS DispatchDeviceControl(PDEVICE_OBJECT, PIRP Irp)
{
	NTSTATUS Status = STATUS_SUCCESS;
	ULONG OutBufferSize = 0;
	
	PIO_STACK_LOCATION Stack = IoGetCurrentIrpStackLocation(Irp);

	switch ((int)Stack->Parameters.DeviceIoControl.IoControlCode)
	{
	case IOCTL_SANDBOX:
	{
		DbgPrint("> TelemetrySourcererDriver: Hello, world!\n");
		break;
	}
	case IOCTL_GET_MODULES:
	{
		DbgPrint("> TelemetrySourcererDriver: Getting modules...\n");
		OutBufferSize = Stack->Parameters.DeviceIoControl.InputBufferLength;
		MODULE_INFO* Modules = (MODULE_INFO*)Irp->AssociatedIrp.SystemBuffer;
		Status = GetModules(Modules);
		break;
	}
	case IOCTL_GET_CALLBACKS:
	{
		ULONG i = 0;
		ULONG n = 0;
		CALLBACK_INFO* Callbacks = (CALLBACK_INFO*)Irp->AssociatedIrp.SystemBuffer;
		OutBufferSize = Stack->Parameters.DeviceIoControl.InputBufferLength;

		// Get load image notification callbacks and update the output index.
		DbgPrint("> TelemetrySourcererDriver: Getting load image notification callbacks...\n");
		if (NT_SUCCESS(GetLoadImageNotifyCallbacks(&Callbacks[i], &n)))
			i += n;				

		// Get create process notification callbacks and update the output index.
		DbgPrint("> TelemetrySourcererDriver: Getting create process notification callbacks...\n");
		if (NT_SUCCESS(GetCreateProcessNotifyCallbacks(&Callbacks[i], &n)))
			i += n;

		// Get create thread notification callbacks and update the output index.
		DbgPrint("> TelemetrySourcererDriver: Getting create thread notification callbacks...\n");
		if (NT_SUCCESS(GetCreateThreadNotifyCallbacks(&Callbacks[i], &n)))
			i += n;

		// Get registry callbacks and and update the output index.
		DbgPrint("> TelemetrySourcererDriver: Getting registry notification callbacks...\n");
		if (NT_SUCCESS(GetRegistryCallbacks(&Callbacks[i], &n)))
			i += n;

		// Get object callbacks and and update the output index.
		DbgPrint("> TelemetrySourcererDriver: Getting object notification callbacks...\n");
		if (NT_SUCCESS(GetObjectCallbacks(&Callbacks[i], &n)))
			i += n;

		// Get minifilter callbacks and and update the output index.
		DbgPrint("> TelemetrySourcererDriver: Getting minifilter notification callbacks...\n");
		if (NT_SUCCESS(GetMinifilterCallbacks(&Callbacks[i], &n)))
			i += n;

		break;
	}
	case IOCTL_GET_QWORD:
	{
		OutBufferSize = Stack->Parameters.DeviceIoControl.InputBufferLength;
		QWORD_INFO* Buffer = (QWORD_INFO*)Irp->AssociatedIrp.SystemBuffer;
		KdPrint(("> TelemetrySourcererDriver: Getting QWORD at 0x%p...\n", Buffer->Address));
		Buffer->Value = *Buffer->Address;
		break;
	}
	case IOCTL_SET_QWORD:
	{
		QWORD_INFO* Buffer = (QWORD_INFO*)Irp->AssociatedIrp.SystemBuffer;
		KdPrint(("> TelemetrySourcererDriver: Setting QWORD at 0x%p...\n", Buffer->Address));
		WriteVirtualMemory(Buffer->Address, &Buffer->Value, sizeof(ULONG64));
		break;
	}
	default:
	{
		Status = STATUS_INVALID_DEVICE_REQUEST;
		break;
	}
	}

	Irp->IoStatus.Status = Status;
	Irp->IoStatus.Information = OutBufferSize;
	IoCompleteRequest(Irp, IO_NO_INCREMENT);
	return Status;
}
```

`TelemetrySourcererDriver/TelemetrySourcererDriver.h`:

```h
#pragma once

#define DRIVER_TAG 'DSMT'

extern "C" NTSTATUS DriverEntry(_In_ PDRIVER_OBJECT DriverObject, _In_ PUNICODE_STRING RegistryPath);
void UnloadDriver(_In_ PDRIVER_OBJECT DriverObject);
NTSTATUS DispatchCreateClose(PDEVICE_OBJECT DeviceObject, PIRP Irp);
NTSTATUS DispatchDeviceControl(PDEVICE_OBJECT, PIRP Irp);
```

`TelemetrySourcererDriver/TelemetrySourcererDriver.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" ToolsVersion="12.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|Win32">
      <Configuration>Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|ARM">
      <Configuration>Debug</Configuration>
      <Platform>ARM</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|ARM">
      <Configuration>Release</Configuration>
      <Platform>ARM</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|ARM64">
      <Configuration>Debug</Configuration>
      <Platform>ARM64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|ARM64">
      <Configuration>Release</Configuration>
      <Platform>ARM64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <ProjectGuid>{8920075B-A372-47F3-A391-DBCACE851E28}</ProjectGuid>
    <TemplateGuid>{dd38f7fc-d7bd-488b-9242-7d8754cde80d}</TemplateGuid>
    <TargetFrameworkVersion>v4.5</TargetFrameworkVersion>
    <MinimumVisualStudioVersion>12.0</MinimumVisualStudioVersion>
    <Configuration>Debug</Configuration>
    <Platform Condition="'$(Platform)' == ''">Win32</Platform>
    <RootNamespace>TelemetrySourcererDriver</RootNamespace>
    <WindowsTargetPlatformVersion>10.0.19041.0</WindowsTargetPlatformVersion>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>WDM</DriverType>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>WDM</DriverType>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <TargetVersion>Windows7</TargetVersion>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>WDM</DriverType>
    <Driver_SpectreMitigation>Spectre</Driver_SpectreMitigation>
    <ALLOW_DATE_TIME>1</ALLOW_DATE_TIME>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <TargetVersion>Windows7</TargetVersion>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>WDM</DriverType>
    <Driver_SpectreMitigation>Spectre</Driver_SpectreMitigation>
    <ALLOW_DATE_TIME>1</ALLOW_DATE_TIME>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>WDM</DriverType>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>WDM</DriverType>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM64'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>WDM</DriverType>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM64'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>WDM</DriverType>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM64'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM64'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <Link>
      <AdditionalDependencies>$(DDK_LIB_PATH)Wdmsec.lib;$(DDK_LIB_PATH)aux_klib.lib;$(DDK_LIB_PATH)FltMgr.lib;%(AdditionalDependencies)</AdditionalDependencies>
    </Link>
    <ClCompile>
      <BufferSecurityCheck>true</BufferSecurityCheck>
    </ClCompile>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <Link>
      <AdditionalDependencies>$(DDK_LIB_PATH)Wdmsec.lib;$(DDK_LIB_PATH)aux_klib.lib;$(DDK_LIB_PATH)FltMgr.lib;%(AdditionalDependencies)</AdditionalDependencies>
      <GenerateDebugInformation>DebugFull</GenerateDebugInformation>
    </Link>
    <ClCompile>
      <BufferSecurityCheck>true</BufferSecurityCheck>
    </ClCompile>
  </ItemDefinitionGroup>
  <ItemGroup>
    <FilesToPackage Include="$(TargetPath)" />
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="Memory.cpp" />
    <ClCompile Include="Callbacks.cpp" />
    <ClCompile Include="Modules.cpp" />
    <ClCompile Include="TelemetrySourcererDriver.cpp" />
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="Memory.h" />
    <ClInclude Include="Callbacks.h" />
    <ClInclude Include="Common.h" />
    <ClInclude Include="Modules.h" />
    <ClInclude Include="TelemetrySourcererDriver.h" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>
```

`TelemetrySourcererDriver/TelemetrySourcererDriver.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="Source Files">
      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
      <Extensions>cpp;c;cc;cxx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
    </Filter>
    <Filter Include="Header Files">
      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
      <Extensions>h;hpp;hxx;hm;inl;inc;xsd</Extensions>
    </Filter>
    <Filter Include="Resource Files">
      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav;mfcribbon-ms</Extensions>
    </Filter>
    <Filter Include="Driver Files">
      <UniqueIdentifier>{8E41214B-6785-4CFE-B992-037D68949A14}</UniqueIdentifier>
      <Extensions>inf;inv;inx;mof;mc;</Extensions>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="TelemetrySourcererDriver.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="Memory.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="Callbacks.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="Modules.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="TelemetrySourcererDriver.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="Memory.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="Callbacks.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="Common.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="Modules.h">
      <Filter>Header Files</Filter>
    </ClInclude>
  </ItemGroup>
</Project>
```