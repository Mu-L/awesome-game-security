Project Path: arc_whereisr0da_Lumina-Cheat_jj_hx6dx

Source Tree:

```txt
arc_whereisr0da_Lumina-Cheat_jj_hx6dx
├── Build
│   ├── ripsign.bat
│   ├── sign.bat
│   └── sigthief.py
├── Lumina
│   ├── Lumina
│   │   ├── Lumina.vcxproj
│   │   ├── Lumina.vcxproj.filters
│   │   ├── common
│   │   │   ├── common.cpp
│   │   │   ├── common.h
│   │   │   ├── config.cpp
│   │   │   ├── config.h
│   │   │   ├── events.cpp
│   │   │   ├── events.h
│   │   │   ├── game.cpp
│   │   │   ├── game.h
│   │   │   ├── includes.h
│   │   │   ├── input.cpp
│   │   │   ├── input.h
│   │   │   ├── json
│   │   │   │   ├── json-forwards.h
│   │   │   │   ├── json.cpp
│   │   │   │   └── json.h
│   │   │   ├── utils.cpp
│   │   │   ├── utils.h
│   │   │   └── vfunc.h
│   │   ├── exportOrdinals.def
│   │   ├── features
│   │   │   ├── backtrack
│   │   │   │   ├── backtrack.cpp
│   │   │   │   └── backtrack.h
│   │   │   ├── misc
│   │   │   │   ├── bypasses.cpp
│   │   │   │   ├── bypasses.h
│   │   │   │   ├── misc.cpp
│   │   │   │   ├── misc.h
│   │   │   │   ├── soundEsp.cpp
│   │   │   │   ├── soundEsp.h
│   │   │   │   ├── voice.cpp
│   │   │   │   └── voice.h
│   │   │   └── visuals
│   │   │       ├── animationfix.cpp
│   │   │       ├── animationfix.h
│   │   │       ├── chams.cpp
│   │   │       ├── chams.h
│   │   │       ├── esp.cpp
│   │   │       ├── esp.h
│   │   │       ├── glow.cpp
│   │   │       ├── glow.h
│   │   │       ├── skinchanger.cpp
│   │   │       ├── skinchanger.h
│   │   │       ├── visualMisc.cpp
│   │   │       ├── visualMisc.h
│   │   │       ├── world.cpp
│   │   │       └── world.h
│   │   ├── hook
│   │   │   ├── functions
│   │   │   │   ├── createMove.cpp
│   │   │   │   ├── createMove.h
│   │   │   │   ├── doPostScreenEffects.cpp
│   │   │   │   ├── doPostScreenEffects.h
│   │   │   │   ├── drawModelExecute.cpp
│   │   │   │   ├── drawModelExecute.h
│   │   │   │   ├── fireEventClientSide.cpp
│   │   │   │   ├── fireEventClientSide.h
│   │   │   │   ├── frameStageNotify.cpp
│   │   │   │   ├── frameStageNotify.h
│   │   │   │   ├── levelInitPostEntity.cpp
│   │   │   │   ├── levelInitPostEntity.h
│   │   │   │   ├── lockCursor.cpp
│   │   │   │   ├── lockCursor.h
│   │   │   │   ├── paintTraverse.cpp
│   │   │   │   ├── paintTraverse.h
│   │   │   │   ├── serverSideChecks.cpp
│   │   │   │   ├── serverSideChecks.h
│   │   │   │   ├── shouldDrawFog.cpp
│   │   │   │   ├── shouldDrawFog.h
│   │   │   │   ├── shutdown.cpp
│   │   │   │   └── shutdown.h
│   │   │   ├── hook.cpp
│   │   │   ├── hook.h
│   │   │   ├── vtableHook.cpp
│   │   │   └── vtableHook.h
│   │   ├── main.cpp
│   │   ├── resource.h
│   │   ├── resource.rc
│   │   ├── sdk
│   │   │   ├── defines.h
│   │   │   ├── interfaces
│   │   │   │   ├── CGlowObjectManager.cpp
│   │   │   │   ├── CGlowObjectManager.h
│   │   │   │   ├── CHud.h
│   │   │   │   ├── CSPlayerResource.h
│   │   │   │   ├── IBaseClientDll.h
│   │   │   │   ├── ICVar.h
│   │   │   │   ├── IClientEntityList.h
│   │   │   │   ├── IClientModeShared.h
│   │   │   │   ├── IClientState.h
│   │   │   │   ├── IConsole.h
│   │   │   │   ├── IEngineClient.h
│   │   │   │   ├── IEngineTrace.h
│   │   │   │   ├── IGameEventManager.h
│   │   │   │   ├── IGlobalVarsBase.h
│   │   │   │   ├── IInput.h
│   │   │   │   ├── ILocalize.h
│   │   │   │   ├── IMatRenderContext.h
│   │   │   │   ├── IMaterialSystem.h
│   │   │   │   ├── IMemAlloc.h
│   │   │   │   ├── IMoveHelper.h
│   │   │   │   ├── IPhysicsSurfaceProps.h
│   │   │   │   ├── IPrediction.h
│   │   │   │   ├── ISteamGameServer.h
│   │   │   │   ├── IStudioRender.h
│   │   │   │   ├── ISurface.h
│   │   │   │   ├── IVDebugOverlay.h
│   │   │   │   ├── IVModelInfo.h
│   │   │   │   ├── IVModelRender.h
│   │   │   │   ├── IVPanel.h
│   │   │   │   ├── IVRenderView.h
│   │   │   │   ├── IViewRender.h
│   │   │   │   ├── IViewRenderBeams.h
│   │   │   │   └── IWeaponSystem.h
│   │   │   ├── interfaces.cpp
│   │   │   ├── interfaces.h
│   │   │   ├── math
│   │   │   │   ├── CUtlVector.h
│   │   │   │   ├── Color.h
│   │   │   │   ├── QAngle.h
│   │   │   │   ├── VMatrix.h
│   │   │   │   ├── Vector.h
│   │   │   │   ├── Vector2D.h
│   │   │   │   ├── Vector4D.h
│   │   │   │   ├── math.h
│   │   │   │   └── matrix3x4_t.h
│   │   │   ├── netvars.cpp
│   │   │   ├── netvars.h
│   │   │   ├── offsets.cpp
│   │   │   ├── offsets.h
│   │   │   └── structs
│   │   │       ├── CBoneChache.h
│   │   │       ├── CCSGOPlayerAnimState.h
│   │   │       ├── CCSGameRulesProxy.h
│   │   │       ├── CNetChannel.h
│   │   │       ├── ClientClass.cpp
│   │   │       ├── ClientClass.h
│   │   │       ├── ConVar.h
│   │   │       ├── Entity.cpp
│   │   │       ├── Entity.h
│   │   │       ├── IClientEntity.h
│   │   │       ├── IMaterial.h
│   │   │       ├── IMaterialVar.h
│   │   │       ├── INetChannelInfo.h
│   │   │       ├── IRefCounted.h
│   │   │       ├── datamap.h
│   │   │       ├── misc.h
│   │   │       ├── mystructs.h
│   │   │       ├── structs.h
│   │   │       └── trace_ray.h
│   │   ├── security
│   │   │   ├── eraser.hpp
│   │   │   ├── hash.h
│   │   │   ├── instr.h
│   │   │   ├── lazy.hpp
│   │   │   └── xorstr.hpp
│   │   └── ui
│   │       ├── fgui_
│   │       │   ├── FGUI.hpp
│   │       │   ├── dependencies
│   │       │   │   ├── aliases.hpp
│   │       │   │   ├── builder.hpp
│   │       │   │   ├── definitions.hpp
│   │       │   │   ├── external
│   │       │   │   │   ├── tinyxml2.cpp
│   │       │   │   │   └── tinyxml2.hpp
│   │       │   │   └── helpers.hpp
│   │       │   ├── input.hpp
│   │       │   ├── render.hpp
│   │       │   └── widgets
│   │       │       ├── button.cpp
│   │       │       ├── button.hpp
│   │       │       ├── checkbox.cpp
│   │       │       ├── checkbox.hpp
│   │       │       ├── colorlist.cpp
│   │       │       ├── colorlist.hpp
│   │       │       ├── form.cpp
│   │       │       ├── form.hpp
│   │       │       ├── groupbox.cpp
│   │       │       ├── groupbox.hpp
│   │       │       ├── keybinder.cpp
│   │       │       ├── keybinder.hpp
│   │       │       ├── label.cpp
│   │       │       ├── label.hpp
│   │       │       ├── listbox.cpp
│   │       │       ├── listbox.hpp
│   │       │       ├── multibox.cpp
│   │       │       ├── multibox.hpp
│   │       │       ├── slider.cpp
│   │       │       ├── slider.hpp
│   │       │       ├── tabs.cpp
│   │       │       ├── tabs.hpp
│   │       │       ├── textbox.cpp
│   │       │       ├── textbox.hpp
│   │       │       ├── widgets.cpp
│   │       │       └── widgets.hpp
│   │       ├── image.cpp
│   │       ├── image.h
│   │       ├── menu.cpp
│   │       ├── menu.h
│   │       ├── render.cpp
│   │       ├── render.h
│   │       ├── sound.cpp
│   │       ├── sound.h
│   │       ├── texture.cpp
│   │       ├── texture.h
│   │       └── zgui
│   │           ├── LICENSE.md
│   │           ├── README.md
│   │           └── dist
│   │               ├── zgui.cc
│   │               └── zgui.hh
│   └── Lumina.sln
├── README.md
└── Resources
    ├── AdditivePad_004_Short_01.wav
    ├── DT_BaseAttributableItem.log
    ├── DT_BaseCombatWeapon.log
    ├── DT_BasePlayer.log
    ├── DT_CSPlayer.log
    ├── DigiPadE_AdditivePad_007.wav
    ├── flashed.psd
    ├── flashed.raw
    ├── logo.png
    ├── logo.psd
    ├── logo.raw
    ├── models.zip
    ├── preview_0.jpg
    ├── preview_1.png
    ├── reload.psd
    ├── reload.raw
    ├── scoping.psd
    ├── scoping.raw
    ├── skybox.zip
    └── sound.zip

```

`Build/ripsign.bat`:

```bat
python sigthief.py -i crashhandler.original.dll -r -o crashhandler.original.sig
```

`Build/sign.bat`:

```bat
del crashhandler.vanilla.msvc.dll & copy crashhandler.vanilla.dll crashhandler.vanilla.msvc.dll && "I:\Software\VMProtect 3.5\VMProtect_Con.exe" crashhandler.vanilla.msvc.dll crashhandler.muted.dll -pf "E:\Projects\Lumina\Build\crashhandler.vanilla.dll.vmp" && python sigthief.py -s crashhandler.original.sig -t crashhandler.muted.dll & del crashhandler.dll && ren crashhandler.muted.dll_signed crashhandler.dll && powershell (Get-ChildItem 'crashhandler.dll').CreationTime = (Get-ChildItem 'crashhandler.original.dll').CreationTime; (Get-ChildItem 'crashhandler.dll').LastAccessTime = (Get-ChildItem 'crashhandler.original.dll').LastAccessTime; (Get-ChildItem 'crashhandler.dll').LastWriteTime = (Get-ChildItem 'crashhandler.original.dll').LastWriteTime
```

`Build/sigthief.py`:

```py
#!/usr/bin/env python3
# LICENSE: BSD-3
# Copyright: Josh Pitts @midnite_runr

import sys
import struct
import shutil
import io
from optparse import OptionParser


def gather_file_info_win(binary):
        """
        Borrowed from BDF...
        I could just skip to certLOC... *shrug*
        """
        flItms = {}
        binary = open(binary, 'rb')
        binary.seek(int('3C', 16))
        flItms['buffer'] = 0
        flItms['JMPtoCodeAddress'] = 0
        flItms['dis_frm_pehdrs_sectble'] = 248
        flItms['pe_header_location'] = struct.unpack('<i', binary.read(4))[0]
        # Start of COFF
        flItms['COFF_Start'] = flItms['pe_header_location'] + 4
        binary.seek(flItms['COFF_Start'])
        flItms['MachineType'] = struct.unpack('<H', binary.read(2))[0]
        binary.seek(flItms['COFF_Start'] + 2, 0)
        flItms['NumberOfSections'] = struct.unpack('<H', binary.read(2))[0]
        flItms['TimeDateStamp'] = struct.unpack('<I', binary.read(4))[0]
        binary.seek(flItms['COFF_Start'] + 16, 0)
        flItms['SizeOfOptionalHeader'] = struct.unpack('<H', binary.read(2))[0]
        flItms['Characteristics'] = struct.unpack('<H', binary.read(2))[0]
        #End of COFF
        flItms['OptionalHeader_start'] = flItms['COFF_Start'] + 20

        #if flItms['SizeOfOptionalHeader']:
            #Begin Standard Fields section of Optional Header
        binary.seek(flItms['OptionalHeader_start'])
        flItms['Magic'] = struct.unpack('<H', binary.read(2))[0]
        flItms['MajorLinkerVersion'] = struct.unpack("!B", binary.read(1))[0]
        flItms['MinorLinkerVersion'] = struct.unpack("!B", binary.read(1))[0]
        flItms['SizeOfCode'] = struct.unpack("<I", binary.read(4))[0]
        flItms['SizeOfInitializedData'] = struct.unpack("<I", binary.read(4))[0]
        flItms['SizeOfUninitializedData'] = struct.unpack("<I",
                                                               binary.read(4))[0]
        flItms['AddressOfEntryPoint'] = struct.unpack('<I', binary.read(4))[0]
        flItms['PatchLocation'] = flItms['AddressOfEntryPoint']
        flItms['BaseOfCode'] = struct.unpack('<I', binary.read(4))[0]
        if flItms['Magic'] != 0x20B:
            flItms['BaseOfData'] = struct.unpack('<I', binary.read(4))[0]
        # End Standard Fields section of Optional Header
        # Begin Windows-Specific Fields of Optional Header
        if flItms['Magic'] == 0x20B:
            flItms['ImageBase'] = struct.unpack('<Q', binary.read(8))[0]
        else:
            flItms['ImageBase'] = struct.unpack('<I', binary.read(4))[0]
        flItms['SectionAlignment'] = struct.unpack('<I', binary.read(4))[0]
        flItms['FileAlignment'] = struct.unpack('<I', binary.read(4))[0]
        flItms['MajorOperatingSystemVersion'] = struct.unpack('<H',
                                                                   binary.read(2))[0]
        flItms['MinorOperatingSystemVersion'] = struct.unpack('<H',
                                                                   binary.read(2))[0]
        flItms['MajorImageVersion'] = struct.unpack('<H', binary.read(2))[0]
        flItms['MinorImageVersion'] = struct.unpack('<H', binary.read(2))[0]
        flItms['MajorSubsystemVersion'] = struct.unpack('<H', binary.read(2))[0]
        flItms['MinorSubsystemVersion'] = struct.unpack('<H', binary.read(2))[0]
        flItms['Win32VersionValue'] = struct.unpack('<I', binary.read(4))[0]
        flItms['SizeOfImageLoc'] = binary.tell()
        flItms['SizeOfImage'] = struct.unpack('<I', binary.read(4))[0]
        flItms['SizeOfHeaders'] = struct.unpack('<I', binary.read(4))[0]
        flItms['CheckSum'] = struct.unpack('<I', binary.read(4))[0]
        flItms['Subsystem'] = struct.unpack('<H', binary.read(2))[0]
        flItms['DllCharacteristics'] = struct.unpack('<H', binary.read(2))[0]
        if flItms['Magic'] == 0x20B:
            flItms['SizeOfStackReserve'] = struct.unpack('<Q', binary.read(8))[0]
            flItms['SizeOfStackCommit'] = struct.unpack('<Q', binary.read(8))[0]
            flItms['SizeOfHeapReserve'] = struct.unpack('<Q', binary.read(8))[0]
            flItms['SizeOfHeapCommit'] = struct.unpack('<Q', binary.read(8))[0]

        else:
            flItms['SizeOfStackReserve'] = struct.unpack('<I', binary.read(4))[0]
            flItms['SizeOfStackCommit'] = struct.unpack('<I', binary.read(4))[0]
            flItms['SizeOfHeapReserve'] = struct.unpack('<I', binary.read(4))[0]
            flItms['SizeOfHeapCommit'] = struct.unpack('<I', binary.read(4))[0]
        flItms['LoaderFlags'] = struct.unpack('<I', binary.read(4))[0]  # zero
        flItms['NumberofRvaAndSizes'] = struct.unpack('<I', binary.read(4))[0]
        # End Windows-Specific Fields of Optional Header
        # Begin Data Directories of Optional Header
        flItms['ExportTableRVA'] = struct.unpack('<I', binary.read(4))[0]
        flItms['ExportTableSize'] = struct.unpack('<I', binary.read(4))[0]
        flItms['ImportTableLOCInPEOptHdrs'] = binary.tell()
        #ImportTable SIZE|LOC
        flItms['ImportTableRVA'] = struct.unpack('<I', binary.read(4))[0]
        flItms['ImportTableSize'] = struct.unpack('<I', binary.read(4))[0]
        flItms['ResourceTable'] = struct.unpack('<Q', binary.read(8))[0]
        flItms['ExceptionTable'] = struct.unpack('<Q', binary.read(8))[0]
        flItms['CertTableLOC'] = binary.tell()
        flItms['CertLOC'] = struct.unpack("<I", binary.read(4))[0]
        flItms['CertSize'] = struct.unpack("<I", binary.read(4))[0]
        binary.close()
        return flItms


def copyCert(exe):
    flItms = gather_file_info_win(exe)

    if flItms['CertLOC'] == 0 or flItms['CertSize'] == 0:
        # not signed
        print("Input file Not signed!")
        sys.exit(-1)

    with open(exe, 'rb') as f:
        f.seek(flItms['CertLOC'], 0)
        cert = f.read(flItms['CertSize'])
    return cert


def writeCert(cert, exe, output):
    flItms = gather_file_info_win(exe)
    
    if not output: 
        output = output = str(exe) + "_signed"

    shutil.copy2(exe, output)
    
    print("Output file: {0}".format(output))

    with open(exe, 'rb') as g:
        with open(output, 'wb') as f:
            f.write(g.read())
            f.seek(0)
            f.seek(flItms['CertTableLOC'], 0)
            f.write(struct.pack("<I", len(open(exe, 'rb').read())))
            f.write(struct.pack("<I", len(cert)))
            f.seek(0, io.SEEK_END)
            f.write(cert)

    print("Signature appended. \nFIN.")


def outputCert(exe, output):
    cert = copyCert(exe)
    if not output:
        output = str(exe) + "_sig"

    print("Output file: {0}".format(output))

    open(output, 'wb').write(cert)

    print("Signature ripped. \nFIN.")


def check_sig(exe):
    flItms = gather_file_info_win(exe)
 
    if flItms['CertLOC'] == 0 or flItms['CertSize'] == 0:
        # not signed
        print("Inputfile Not signed!")
    else:
        print("Inputfile is signed!")


def truncate(exe, output):
    flItms = gather_file_info_win(exe)
 
    if flItms['CertLOC'] == 0 or flItms['CertSize'] == 0:
        # not signed
        print("Inputfile Not signed!")
        sys.exit(-1)
    else:
        print( "Inputfile is signed!")

    if not output:
        output = str(exe) + "_nosig"

    print("Output file: {0}".format(output))

    shutil.copy2(exe, output)

    with open(output, "r+b") as binary:
        print('Overwriting certificate table pointer and truncating binary')
        binary.seek(-flItms['CertSize'], io.SEEK_END)
        binary.truncate()
        binary.seek(flItms['CertTableLOC'], 0)
        binary.write(b"\x00\x00\x00\x00\x00\x00\x00\x00")

    print("Signature removed. \nFIN.")


def signfile(exe, sigfile, output):
    flItms = gather_file_info_win(exe)
    
    cert = open(sigfile, 'rb').read()

    if not output: 
        output = output = str(exe) + "_signed"

    shutil.copy2(exe, output)
    
    print("Output file: {0}".format(output))
    
    with open(exe, 'rb') as g:
        with open(output, 'wb') as f:
            f.write(g.read())
            f.seek(0)
            f.seek(flItms['CertTableLOC'], 0)
            f.write(struct.pack("<I", len(open(exe, 'rb').read())))
            f.write(struct.pack("<I", len(cert)))
            f.seek(0, io.SEEK_END)
            f.write(cert)
    print("Signature appended. \nFIN.")


if __name__ == "__main__":
    usage = 'usage: %prog [options]'
    print("\n!! Like the software? Sponsor here: https://github.com/sponsors/secretsquirrel\n\n")
    parser = OptionParser()
    parser.add_option("-i", "--file", dest="inputfile", 
                  help="input file", metavar="FILE")
    parser.add_option('-r', '--rip', dest='ripsig', action='store_true',
                  help='rip signature off inputfile')
    parser.add_option('-a', '--add', dest='addsig', action='store_true',
                  help='add signautre to targetfile')
    parser.add_option('-o', '--output', dest='outputfile',
                  help='output file')
    parser.add_option('-s', '--sig', dest='sigfile',
                  help='binary signature from disk')
    parser.add_option('-t', '--target', dest='targetfile',
                  help='file to append signature to')
    parser.add_option('-c', '--checksig', dest='checksig', action='store_true',
                  help='file to check if signed; does not verify signature')
    parser.add_option('-T', '--truncate', dest="truncate", action='store_true',
                  help='truncate signature (i.e. remove sig)')
    (options, args) = parser.parse_args()
    
    # rip signature
    # inputfile and rip to outputfile
    if options.inputfile and options.ripsig:
        print("Ripping signature to file!")
        outputCert(options.inputfile, options.outputfile)
        sys.exit()    

    # copy from one to another
    # inputfile and rip to targetfile to outputfile    
    if options.inputfile and options.targetfile:
        cert = copyCert(options.inputfile)
        writeCert(cert, options.targetfile, options.outputfile)
        sys.exit()

    # check signature
    # inputfile 
    if options.inputfile and options.checksig:
        check_sig(options.inputfile) 
        sys.exit()

    # add sig to target file
    if options.targetfile and options.sigfile:
        signfile(options.targetfile, options.sigfile, options.outputfile)
        sys.exit()
        
    # truncate
    if options.inputfile and options.truncate:
        truncate(options.inputfile, options.outputfile)
        sys.exit()

    parser.print_help()
    parser.error("You must do something!")


```

`Lumina/Lumina.sln`:

```sln

Microsoft Visual Studio Solution File, Format Version 12.00
# Visual Studio Version 16
VisualStudioVersion = 16.0.30804.86
MinimumVisualStudioVersion = 10.0.40219.1
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "Lumina", "Lumina\Lumina.vcxproj", "{3857B898-29FC-4DCB-B467-FF332A0D6665}"
EndProject
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "LuminaLoader", "LuminaLoader\LuminaLoader.vcxproj", "{268C73A1-C7ED-43A7-9907-D5D99DE6BDAC}"
EndProject
Project("{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}") = "LuminaInjector", "LuminaInjector\LuminaInjector.csproj", "{2835EB45-6916-4D75-B197-3A0F4C86FF04}"
EndProject
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "LuminaOffsetDumper", "LuminaOffsetDumper\LuminaOffsetDumper.vcxproj", "{30546A4D-7177-4669-A367-2EE87D10BC70}"
EndProject
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "LuminaVacModule", "LuminaVacModule\LuminaVacModule.vcxproj", "{7CFCFB18-734C-4B36-BD66-337506145FE8}"
EndProject
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "LuminaVacFilter", "LuminaVacFilter\LuminaVacFilter.vcxproj", "{0FA76490-0381-430B-8AB9-DAE301E0B00D}"
EndProject
Global
	GlobalSection(SolutionConfigurationPlatforms) = preSolution
		Debug|Any CPU = Debug|Any CPU
		Debug|x64 = Debug|x64
		Debug|x86 = Debug|x86
		Release|Any CPU = Release|Any CPU
		Release|x64 = Release|x64
		Release|x86 = Release|x86
	EndGlobalSection
	GlobalSection(ProjectConfigurationPlatforms) = postSolution
		{3857B898-29FC-4DCB-B467-FF332A0D6665}.Debug|Any CPU.ActiveCfg = Debug|Win32
		{3857B898-29FC-4DCB-B467-FF332A0D6665}.Debug|x64.ActiveCfg = Debug|x64
		{3857B898-29FC-4DCB-B467-FF332A0D6665}.Debug|x64.Build.0 = Debug|x64
		{3857B898-29FC-4DCB-B467-FF332A0D6665}.Debug|x86.ActiveCfg = Debug|Win32
		{3857B898-29FC-4DCB-B467-FF332A0D6665}.Debug|x86.Build.0 = Debug|Win32
		{3857B898-29FC-4DCB-B467-FF332A0D6665}.Release|Any CPU.ActiveCfg = Release|Win32
		{3857B898-29FC-4DCB-B467-FF332A0D6665}.Release|x64.ActiveCfg = Release|x64
		{3857B898-29FC-4DCB-B467-FF332A0D6665}.Release|x64.Build.0 = Release|x64
		{3857B898-29FC-4DCB-B467-FF332A0D6665}.Release|x86.ActiveCfg = Release|Win32
		{3857B898-29FC-4DCB-B467-FF332A0D6665}.Release|x86.Build.0 = Release|Win32
		{268C73A1-C7ED-43A7-9907-D5D99DE6BDAC}.Debug|Any CPU.ActiveCfg = Debug|Win32
		{268C73A1-C7ED-43A7-9907-D5D99DE6BDAC}.Debug|x64.ActiveCfg = Debug|Win32
		{268C73A1-C7ED-43A7-9907-D5D99DE6BDAC}.Debug|x86.ActiveCfg = Debug|Win32
		{268C73A1-C7ED-43A7-9907-D5D99DE6BDAC}.Debug|x86.Build.0 = Debug|Win32
		{268C73A1-C7ED-43A7-9907-D5D99DE6BDAC}.Release|Any CPU.ActiveCfg = Release|Win32
		{268C73A1-C7ED-43A7-9907-D5D99DE6BDAC}.Release|x64.ActiveCfg = Release|Win32
		{268C73A1-C7ED-43A7-9907-D5D99DE6BDAC}.Release|x86.ActiveCfg = Release|Win32
		{268C73A1-C7ED-43A7-9907-D5D99DE6BDAC}.Release|x86.Build.0 = Release|Win32
		{2835EB45-6916-4D75-B197-3A0F4C86FF04}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
		{2835EB45-6916-4D75-B197-3A0F4C86FF04}.Debug|Any CPU.Build.0 = Debug|Any CPU
		{2835EB45-6916-4D75-B197-3A0F4C86FF04}.Debug|x64.ActiveCfg = Debug|Any CPU
		{2835EB45-6916-4D75-B197-3A0F4C86FF04}.Debug|x64.Build.0 = Debug|Any CPU
		{2835EB45-6916-4D75-B197-3A0F4C86FF04}.Debug|x86.ActiveCfg = Debug|Any CPU
		{2835EB45-6916-4D75-B197-3A0F4C86FF04}.Debug|x86.Build.0 = Debug|Any CPU
		{2835EB45-6916-4D75-B197-3A0F4C86FF04}.Release|Any CPU.ActiveCfg = Release|Any CPU
		{2835EB45-6916-4D75-B197-3A0F4C86FF04}.Release|Any CPU.Build.0 = Release|Any CPU
		{2835EB45-6916-4D75-B197-3A0F4C86FF04}.Release|x64.ActiveCfg = Release|Any CPU
		{2835EB45-6916-4D75-B197-3A0F4C86FF04}.Release|x64.Build.0 = Release|Any CPU
		{2835EB45-6916-4D75-B197-3A0F4C86FF04}.Release|x86.ActiveCfg = Release|Any CPU
		{2835EB45-6916-4D75-B197-3A0F4C86FF04}.Release|x86.Build.0 = Release|Any CPU
		{30546A4D-7177-4669-A367-2EE87D10BC70}.Debug|Any CPU.ActiveCfg = Debug|Win32
		{30546A4D-7177-4669-A367-2EE87D10BC70}.Debug|x64.ActiveCfg = Debug|x64
		{30546A4D-7177-4669-A367-2EE87D10BC70}.Debug|x64.Build.0 = Debug|x64
		{30546A4D-7177-4669-A367-2EE87D10BC70}.Debug|x86.ActiveCfg = Debug|Win32
		{30546A4D-7177-4669-A367-2EE87D10BC70}.Debug|x86.Build.0 = Debug|Win32
		{30546A4D-7177-4669-A367-2EE87D10BC70}.Release|Any CPU.ActiveCfg = Release|Win32
		{30546A4D-7177-4669-A367-2EE87D10BC70}.Release|x64.ActiveCfg = Release|x64
		{30546A4D-7177-4669-A367-2EE87D10BC70}.Release|x64.Build.0 = Release|x64
		{30546A4D-7177-4669-A367-2EE87D10BC70}.Release|x86.ActiveCfg = Release|Win32
		{30546A4D-7177-4669-A367-2EE87D10BC70}.Release|x86.Build.0 = Release|Win32
		{7CFCFB18-734C-4B36-BD66-337506145FE8}.Debug|Any CPU.ActiveCfg = Debug|Win32
		{7CFCFB18-734C-4B36-BD66-337506145FE8}.Debug|x64.ActiveCfg = Debug|x64
		{7CFCFB18-734C-4B36-BD66-337506145FE8}.Debug|x64.Build.0 = Debug|x64
		{7CFCFB18-734C-4B36-BD66-337506145FE8}.Debug|x86.ActiveCfg = Debug|Win32
		{7CFCFB18-734C-4B36-BD66-337506145FE8}.Debug|x86.Build.0 = Debug|Win32
		{7CFCFB18-734C-4B36-BD66-337506145FE8}.Release|Any CPU.ActiveCfg = Release|Win32
		{7CFCFB18-734C-4B36-BD66-337506145FE8}.Release|x64.ActiveCfg = Release|x64
		{7CFCFB18-734C-4B36-BD66-337506145FE8}.Release|x64.Build.0 = Release|x64
		{7CFCFB18-734C-4B36-BD66-337506145FE8}.Release|x86.ActiveCfg = Release|Win32
		{7CFCFB18-734C-4B36-BD66-337506145FE8}.Release|x86.Build.0 = Release|Win32
		{0FA76490-0381-430B-8AB9-DAE301E0B00D}.Debug|Any CPU.ActiveCfg = Debug|Win32
		{0FA76490-0381-430B-8AB9-DAE301E0B00D}.Debug|x64.ActiveCfg = Debug|x64
		{0FA76490-0381-430B-8AB9-DAE301E0B00D}.Debug|x64.Build.0 = Debug|x64
		{0FA76490-0381-430B-8AB9-DAE301E0B00D}.Debug|x86.ActiveCfg = Debug|Win32
		{0FA76490-0381-430B-8AB9-DAE301E0B00D}.Debug|x86.Build.0 = Debug|Win32
		{0FA76490-0381-430B-8AB9-DAE301E0B00D}.Release|Any CPU.ActiveCfg = Release|Win32
		{0FA76490-0381-430B-8AB9-DAE301E0B00D}.Release|x64.ActiveCfg = Release|x64
		{0FA76490-0381-430B-8AB9-DAE301E0B00D}.Release|x64.Build.0 = Release|x64
		{0FA76490-0381-430B-8AB9-DAE301E0B00D}.Release|x86.ActiveCfg = Release|Win32
		{0FA76490-0381-430B-8AB9-DAE301E0B00D}.Release|x86.Build.0 = Release|Win32
	EndGlobalSection
	GlobalSection(SolutionProperties) = preSolution
		HideSolutionNode = FALSE
	EndGlobalSection
	GlobalSection(ExtensibilityGlobals) = postSolution
		SolutionGuid = {26E07932-CB0E-495C-802F-A3B4000A6F5F}
	EndGlobalSection
EndGlobal

```

`Lumina/Lumina/Lumina.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" ToolsVersion="15.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|Win32">
      <Configuration>Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <VCProjectVersion>15.0</VCProjectVersion>
    <ProjectGuid>{3857B898-29FC-4DCB-B467-FF332A0D6665}</ProjectGuid>
    <Keyword>Win32Proj</Keyword>
    <RootNamespace>Lumina</RootNamespace>
    <WindowsTargetPlatformVersion>10.0</WindowsTargetPlatformVersion>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
    <ConfigurationType>DynamicLibrary</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <CharacterSet>MultiByte</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
    <ConfigurationType>DynamicLibrary</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <CharacterSet>MultiByte</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="Shared">
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <LinkIncremental>true</LinkIncremental>
    <OutDir>$(SolutionDir)$(Configuration)\..\..\Build</OutDir>
    <TargetName>crashhandler.vanilla</TargetName>
    <IncludePath>I:\Software\VMProtect 3.5\Include\C;C:\Program Files %28x86%29\Microsoft DirectX SDK %28June 2010%29\Include;$(IncludePath)</IncludePath>
    <LibraryPath>I:\Software\VMProtect 3.5\Lib\Windows;C:\Program Files %28x86%29\Microsoft DirectX SDK %28June 2010%29\Lib\x86;$(LibraryPath)</LibraryPath>
    <IntDir>$(Configuration)\..\..\..\Build\Objects</IntDir>
    <PostBuildEventUseInBuild>true</PostBuildEventUseInBuild>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <LinkIncremental>true</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <OutDir>$(SolutionDir)$(Configuration)\..\..\Build</OutDir>
    <TargetName>crashhandler.vanilla</TargetName>
    <IncludePath>I:\Software\VMProtect 3.5\Include\C;C:\Program Files %28x86%29\Microsoft DirectX SDK %28June 2010%29\Include;$(IncludePath)</IncludePath>
    <LibraryPath>I:\Software\VMProtect 3.5\Lib\Windows;C:\Program Files %28x86%29\Microsoft DirectX SDK %28June 2010%29\Lib\x86;$(LibraryPath)</LibraryPath>
    <IntDir>$(Configuration)\..\..\..\Build\Objects</IntDir>
    <PostBuildEventUseInBuild>true</PostBuildEventUseInBuild>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <LinkIncremental>false</LinkIncremental>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <ClCompile>
      <PrecompiledHeader>
      </PrecompiledHeader>
      <WarningLevel>Level1</WarningLevel>
      <Optimization>Disabled</Optimization>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>WIN32;_CRT_SECURE_NO_WARNINGS;_DEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <LanguageStandard>stdcpp17</LanguageStandard>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <ModuleDefinitionFile>exportOrdinals.def</ModuleDefinitionFile>
    </Link>
    <PostBuildEvent>
      <Command>cmd.exe /c "cd $(SolutionDir)$(Configuration)\..\..\Build\ &amp;&amp; sign.bat"</Command>
    </PostBuildEvent>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <ClCompile>
      <PrecompiledHeader>
      </PrecompiledHeader>
      <WarningLevel>Level3</WarningLevel>
      <Optimization>Disabled</Optimization>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>_DEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <ModuleDefinitionFile>exportOrdinals.def</ModuleDefinitionFile>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <ClCompile>
      <PrecompiledHeader>
      </PrecompiledHeader>
      <PreprocessorDefinitions>WIN32;_CRT_SECURE_NO_WARNINGS;NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <LanguageStandard>stdcpp17</LanguageStandard>
      <Optimization>Disabled</Optimization>
    </ClCompile>
    <Link>
      <GenerateDebugInformation>DebugFull</GenerateDebugInformation>
      <ModuleDefinitionFile>exportOrdinals.def</ModuleDefinitionFile>
    </Link>
    <PostBuildEvent>
      <Command>cmd.exe /c "cd $(SolutionDir)$(Configuration)\..\..\Build\ &amp;&amp; sign.bat"</Command>
    </PostBuildEvent>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <ClCompile>
      <PrecompiledHeader>
      </PrecompiledHeader>
      <WarningLevel>Level3</WarningLevel>
      <Optimization>MaxSpeed</Optimization>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <ModuleDefinitionFile>exportOrdinals.def</ModuleDefinitionFile>
    </Link>
  </ItemDefinitionGroup>
  <ItemGroup>
    <ClCompile Include="common\common.cpp" />
    <ClCompile Include="common\config.cpp" />
    <ClCompile Include="common\events.cpp" />
    <ClCompile Include="common\game.cpp" />
    <ClCompile Include="common\input.cpp" />
    <ClCompile Include="common\json\json.cpp" />
    <ClCompile Include="common\utils.cpp" />
    <ClCompile Include="features\backtrack\backtrack.cpp" />
    <ClCompile Include="features\misc\bypasses.cpp" />
    <ClCompile Include="features\misc\misc.cpp" />
    <ClCompile Include="features\misc\soundEsp.cpp" />
    <ClCompile Include="features\misc\voice.cpp" />
    <ClCompile Include="features\visuals\animationfix.cpp" />
    <ClCompile Include="features\visuals\chams.cpp" />
    <ClCompile Include="features\visuals\esp.cpp" />
    <ClCompile Include="features\visuals\glow.cpp" />
    <ClCompile Include="features\visuals\visualMisc.cpp" />
    <ClCompile Include="features\visuals\skinchanger.cpp" />
    <ClCompile Include="features\visuals\world.cpp" />
    <ClCompile Include="hook\functions\createMove.cpp" />
    <ClCompile Include="hook\functions\doPostScreenEffects.cpp" />
    <ClCompile Include="hook\functions\drawModelExecute.cpp" />
    <ClCompile Include="hook\functions\fireEventClientSide.cpp" />
    <ClCompile Include="hook\functions\frameStageNotify.cpp" />
    <ClCompile Include="hook\functions\levelInitPostEntity.cpp" />
    <ClCompile Include="hook\functions\lockCursor.cpp" />
    <ClCompile Include="hook\functions\paintTraverse.cpp" />
    <ClCompile Include="hook\functions\serverSideChecks.cpp" />
    <ClCompile Include="hook\functions\shouldDrawFog.cpp" />
    <ClCompile Include="hook\functions\shutdown.cpp" />
    <ClCompile Include="hook\hook.cpp" />
    <ClCompile Include="hook\vtableHook.cpp" />
    <ClCompile Include="main.cpp" />
    <ClCompile Include="sdk\interfaces.cpp" />
    <ClCompile Include="sdk\interfaces\CGlowObjectManager.cpp" />
    <ClCompile Include="sdk\netvars.cpp" />
    <ClCompile Include="sdk\offsets.cpp" />
    <ClCompile Include="sdk\structs\ClientClass.cpp" />
    <ClCompile Include="sdk\structs\Entity.cpp" />
    <ClCompile Include="ui\image.cpp" />
    <ClCompile Include="ui\menu.cpp" />
    <ClCompile Include="ui\render.cpp" />
    <ClCompile Include="ui\sound.cpp" />
    <ClCompile Include="ui\texture.cpp" />
    <ClCompile Include="ui\zgui\dist\zgui.cc" />
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="common\common.h" />
    <ClInclude Include="common\config.h" />
    <ClInclude Include="common\events.h" />
    <ClInclude Include="common\game.h" />
    <ClInclude Include="common\includes.h" />
    <ClInclude Include="common\input.h" />
    <ClInclude Include="common\json\json-forwards.h" />
    <ClInclude Include="common\json\json.h" />
    <ClInclude Include="common\utils.h" />
    <ClInclude Include="common\vfunc.h" />
    <ClInclude Include="features\backtrack\backtrack.h" />
    <ClInclude Include="features\misc\bypasses.h" />
    <ClInclude Include="features\misc\misc.h" />
    <ClInclude Include="features\misc\soundEsp.h" />
    <ClInclude Include="features\misc\voice.h" />
    <ClInclude Include="features\visuals\animationfix.h" />
    <ClInclude Include="features\visuals\chams.h" />
    <ClInclude Include="features\visuals\esp.h" />
    <ClInclude Include="features\visuals\glow.h" />
    <ClInclude Include="features\visuals\visualMisc.h" />
    <ClInclude Include="features\visuals\skinchanger.h" />
    <ClInclude Include="features\visuals\world.h" />
    <ClInclude Include="hook\functions\createMove.h" />
    <ClInclude Include="hook\functions\doPostScreenEffects.h" />
    <ClInclude Include="hook\functions\drawModelExecute.h" />
    <ClInclude Include="hook\functions\fireEventClientSide.h" />
    <ClInclude Include="hook\functions\frameStageNotify.h" />
    <ClInclude Include="hook\functions\levelInitPostEntity.h" />
    <ClInclude Include="hook\functions\lockCursor.h" />
    <ClInclude Include="hook\functions\paintTraverse.h" />
    <ClInclude Include="hook\functions\serverSideChecks.h" />
    <ClInclude Include="hook\functions\shouldDrawFog.h" />
    <ClInclude Include="hook\functions\shutdown.h" />
    <ClInclude Include="hook\hook.h" />
    <ClInclude Include="hook\vtableHook.h" />
    <ClInclude Include="resource.h" />
    <ClInclude Include="sdk\defines.h" />
    <ClInclude Include="sdk\interfaces.h" />
    <ClInclude Include="sdk\interfaces\CGlowObjectManager.h" />
    <ClInclude Include="sdk\interfaces\CHud.h" />
    <ClInclude Include="sdk\interfaces\CSPlayerResource.h" />
    <ClInclude Include="sdk\interfaces\IBaseClientDll.h" />
    <ClInclude Include="sdk\interfaces\IClientEntityList.h" />
    <ClInclude Include="sdk\interfaces\IClientModeShared.h" />
    <ClInclude Include="sdk\interfaces\IClientState.h" />
    <ClInclude Include="sdk\interfaces\IConsole.h" />
    <ClInclude Include="sdk\interfaces\ICVar.h" />
    <ClInclude Include="sdk\interfaces\IEngineClient.h" />
    <ClInclude Include="sdk\interfaces\IEngineTrace.h" />
    <ClInclude Include="sdk\interfaces\IGameEventManager.h" />
    <ClInclude Include="sdk\interfaces\IGlobalVarsBase.h" />
    <ClInclude Include="sdk\interfaces\IInput.h" />
    <ClInclude Include="sdk\interfaces\ILocalize.h" />
    <ClInclude Include="sdk\interfaces\IMaterialSystem.h" />
    <ClInclude Include="sdk\interfaces\IMatRenderContext.h" />
    <ClInclude Include="sdk\interfaces\IMemAlloc.h" />
    <ClInclude Include="sdk\interfaces\IMoveHelper.h" />
    <ClInclude Include="sdk\interfaces\IPhysicsSurfaceProps.h" />
    <ClInclude Include="sdk\interfaces\IPrediction.h" />
    <ClInclude Include="sdk\interfaces\ISteamGameServer.h" />
    <ClInclude Include="sdk\interfaces\IStudioRender.h" />
    <ClInclude Include="sdk\interfaces\ISurface.h" />
    <ClInclude Include="sdk\interfaces\IVDebugOverlay.h" />
    <ClInclude Include="sdk\interfaces\IViewRender.h" />
    <ClInclude Include="sdk\interfaces\IViewRenderBeams.h" />
    <ClInclude Include="sdk\interfaces\IVModelInfo.h" />
    <ClInclude Include="sdk\interfaces\IVModelRender.h" />
    <ClInclude Include="sdk\interfaces\IVPanel.h" />
    <ClInclude Include="sdk\interfaces\IVRenderView.h" />
    <ClInclude Include="sdk\interfaces\IWeaponSystem.h" />
    <ClInclude Include="sdk\math\Color.h" />
    <ClInclude Include="sdk\math\CUtlVector.h" />
    <ClInclude Include="sdk\math\math.h" />
    <ClInclude Include="sdk\math\matrix3x4_t.h" />
    <ClInclude Include="sdk\math\QAngle.h" />
    <ClInclude Include="sdk\math\Vector.h" />
    <ClInclude Include="sdk\math\Vector2D.h" />
    <ClInclude Include="sdk\math\Vector4D.h" />
    <ClInclude Include="sdk\math\VMatrix.h" />
    <ClInclude Include="sdk\netvars.h" />
    <ClInclude Include="sdk\offsets.h" />
    <ClInclude Include="sdk\structs\CBoneChache.h" />
    <ClInclude Include="sdk\structs\CCSGameRulesProxy.h" />
    <ClInclude Include="sdk\structs\CCSGOPlayerAnimState.h" />
    <ClInclude Include="sdk\structs\ClientClass.h" />
    <ClInclude Include="sdk\structs\CNetChannel.h" />
    <ClInclude Include="sdk\structs\ConVar.h" />
    <ClInclude Include="sdk\structs\datamap.h" />
    <ClInclude Include="sdk\structs\Entity.h" />
    <ClInclude Include="sdk\structs\IClientEntity.h" />
    <ClInclude Include="sdk\structs\IMaterial.h" />
    <ClInclude Include="sdk\structs\IMaterialVar.h" />
    <ClInclude Include="sdk\structs\INetChannelInfo.h" />
    <ClInclude Include="sdk\structs\IRefCounted.h" />
    <ClInclude Include="sdk\structs\misc.h" />
    <ClInclude Include="sdk\structs\mystructs.h" />
    <ClInclude Include="sdk\structs\structs.h" />
    <ClInclude Include="sdk\structs\trace_ray.h" />
    <ClInclude Include="security\eraser.hpp" />
    <ClInclude Include="security\hash.h" />
    <ClInclude Include="security\instr.h" />
    <ClInclude Include="security\lazy.hpp" />
    <ClInclude Include="security\xorstr.hpp" />
    <ClInclude Include="ui\image.h" />
    <ClInclude Include="ui\menu.h" />
    <ClInclude Include="ui\render.h" />
    <ClInclude Include="ui\sound.h" />
    <ClInclude Include="ui\texture.h" />
    <ClInclude Include="ui\zgui\dist\zgui.hh" />
  </ItemGroup>
  <ItemGroup>
    <None Include="exportOrdinals.def" />
  </ItemGroup>
  <ItemGroup>
    <ResourceCompile Include="resource.rc" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>
```

`Lumina/Lumina/Lumina.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="Fichiers sources">
      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
      <Extensions>cpp;c;cc;cxx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
    </Filter>
    <Filter Include="Fichiers d%27en-tête">
      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
      <Extensions>h;hh;hpp;hxx;hm;inl;inc;ipp;xsd</Extensions>
    </Filter>
    <Filter Include="Fichiers de ressources">
      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav;mfcribbon-ms</Extensions>
    </Filter>
    <Filter Include="Fichiers sources\sdk">
      <UniqueIdentifier>{4b591468-4fa4-4b5f-8c11-a4354b11a260}</UniqueIdentifier>
    </Filter>
    <Filter Include="Fichiers sources\security">
      <UniqueIdentifier>{609ffff4-1233-4231-b4a2-e5edbee6c97b}</UniqueIdentifier>
    </Filter>
    <Filter Include="Fichiers sources\common">
      <UniqueIdentifier>{4e0d1e8a-4033-4fbc-b346-9d61a1625f7c}</UniqueIdentifier>
    </Filter>
    <Filter Include="Fichiers sources\hook">
      <UniqueIdentifier>{a79e6209-ef1b-4dc5-a27f-c33e14818a57}</UniqueIdentifier>
    </Filter>
    <Filter Include="Fichiers sources\sdk\interfaces">
      <UniqueIdentifier>{b3988637-dc0f-423e-8c6f-f3185824453d}</UniqueIdentifier>
    </Filter>
    <Filter Include="Fichiers sources\sdk\structs">
      <UniqueIdentifier>{ef748a34-a533-4c25-b39d-8060a48b91d4}</UniqueIdentifier>
    </Filter>
    <Filter Include="Fichiers sources\ui">
      <UniqueIdentifier>{0f29de97-3088-47b9-a043-e811647bd495}</UniqueIdentifier>
    </Filter>
    <Filter Include="Fichiers sources\hook\functions">
      <UniqueIdentifier>{68032718-dda3-4439-b65d-fff28acd154a}</UniqueIdentifier>
    </Filter>
    <Filter Include="Fichiers sources\sdk\math">
      <UniqueIdentifier>{3fb1bd71-a852-4c38-9a19-3d87e22c7bfe}</UniqueIdentifier>
    </Filter>
    <Filter Include="Fichiers sources\features">
      <UniqueIdentifier>{7ea22b8b-aece-450b-883d-ccdd2d750335}</UniqueIdentifier>
    </Filter>
    <Filter Include="Fichiers sources\features\visuals">
      <UniqueIdentifier>{e575b879-9f27-4f88-8a8b-b121b335750a}</UniqueIdentifier>
    </Filter>
    <Filter Include="Fichiers sources\features\misc">
      <UniqueIdentifier>{46339cc5-f047-4b16-8732-81d4e7659cb9}</UniqueIdentifier>
    </Filter>
    <Filter Include="Fichiers sources\ui\zgui">
      <UniqueIdentifier>{5733fa88-4a76-40e5-a591-2cafb0ef6127}</UniqueIdentifier>
    </Filter>
    <Filter Include="Fichiers sources\common\json">
      <UniqueIdentifier>{796d95e8-6eb4-4abe-96cd-ef62e175dd47}</UniqueIdentifier>
    </Filter>
    <Filter Include="Fichiers sources\features\backtrack">
      <UniqueIdentifier>{4c6739d4-dca1-423a-8310-1e2cc514f7ad}</UniqueIdentifier>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="main.cpp">
      <Filter>Fichiers sources</Filter>
    </ClCompile>
    <ClCompile Include="sdk\interfaces.cpp">
      <Filter>Fichiers sources\sdk</Filter>
    </ClCompile>
    <ClCompile Include="sdk\offsets.cpp">
      <Filter>Fichiers sources\sdk</Filter>
    </ClCompile>
    <ClCompile Include="common\common.cpp">
      <Filter>Fichiers sources\common</Filter>
    </ClCompile>
    <ClCompile Include="common\utils.cpp">
      <Filter>Fichiers sources\common</Filter>
    </ClCompile>
    <ClCompile Include="hook\vtableHook.cpp">
      <Filter>Fichiers sources\hook</Filter>
    </ClCompile>
    <ClCompile Include="sdk\interfaces\CGlowObjectManager.cpp">
      <Filter>Fichiers sources\sdk\interfaces</Filter>
    </ClCompile>
    <ClCompile Include="hook\hook.cpp">
      <Filter>Fichiers sources\hook</Filter>
    </ClCompile>
    <ClCompile Include="hook\functions\paintTraverse.cpp">
      <Filter>Fichiers sources\hook\functions</Filter>
    </ClCompile>
    <ClCompile Include="ui\render.cpp">
      <Filter>Fichiers sources\ui</Filter>
    </ClCompile>
    <ClCompile Include="hook\functions\shutdown.cpp">
      <Filter>Fichiers sources\hook\functions</Filter>
    </ClCompile>
    <ClCompile Include="hook\functions\lockCursor.cpp">
      <Filter>Fichiers sources\hook\functions</Filter>
    </ClCompile>
    <ClCompile Include="ui\texture.cpp">
      <Filter>Fichiers sources\ui</Filter>
    </ClCompile>
    <ClCompile Include="common\config.cpp">
      <Filter>Fichiers sources\common</Filter>
    </ClCompile>
    <ClCompile Include="features\visuals\esp.cpp">
      <Filter>Fichiers sources\features\visuals</Filter>
    </ClCompile>
    <ClCompile Include="sdk\structs\Entity.cpp">
      <Filter>Fichiers sources\sdk\structs</Filter>
    </ClCompile>
    <ClCompile Include="sdk\netvars.cpp">
      <Filter>Fichiers sources\sdk</Filter>
    </ClCompile>
    <ClCompile Include="ui\image.cpp">
      <Filter>Fichiers sources\ui</Filter>
    </ClCompile>
    <ClCompile Include="ui\menu.cpp">
      <Filter>Fichiers sources\ui</Filter>
    </ClCompile>
    <ClCompile Include="common\input.cpp">
      <Filter>Fichiers sources\common</Filter>
    </ClCompile>
    <ClCompile Include="features\visuals\chams.cpp">
      <Filter>Fichiers sources\features\visuals</Filter>
    </ClCompile>
    <ClCompile Include="hook\functions\drawModelExecute.cpp">
      <Filter>Fichiers sources\hook\functions</Filter>
    </ClCompile>
    <ClCompile Include="features\visuals\skinchanger.cpp">
      <Filter>Fichiers sources\features\visuals</Filter>
    </ClCompile>
    <ClCompile Include="features\misc\voice.cpp">
      <Filter>Fichiers sources\features\misc</Filter>
    </ClCompile>
    <ClCompile Include="features\misc\misc.cpp">
      <Filter>Fichiers sources\features\misc</Filter>
    </ClCompile>
    <ClCompile Include="features\visuals\visualMisc.cpp">
      <Filter>Fichiers sources\features\visuals</Filter>
    </ClCompile>
    <ClCompile Include="common\events.cpp">
      <Filter>Fichiers sources\common</Filter>
    </ClCompile>
    <ClCompile Include="hook\functions\frameStageNotify.cpp">
      <Filter>Fichiers sources\hook\functions</Filter>
    </ClCompile>
    <ClCompile Include="features\misc\bypasses.cpp">
      <Filter>Fichiers sources\features\misc</Filter>
    </ClCompile>
    <ClCompile Include="hook\functions\serverSideChecks.cpp">
      <Filter>Fichiers sources\hook\functions</Filter>
    </ClCompile>
    <ClCompile Include="ui\zgui\dist\zgui.cc">
      <Filter>Fichiers sources\ui\zgui</Filter>
    </ClCompile>
    <ClCompile Include="ui\sound.cpp">
      <Filter>Fichiers sources\ui</Filter>
    </ClCompile>
    <ClCompile Include="features\visuals\glow.cpp">
      <Filter>Fichiers sources\features\visuals</Filter>
    </ClCompile>
    <ClCompile Include="hook\functions\doPostScreenEffects.cpp">
      <Filter>Fichiers sources\hook\functions</Filter>
    </ClCompile>
    <ClCompile Include="common\json\json.cpp">
      <Filter>Fichiers sources\common\json</Filter>
    </ClCompile>
    <ClCompile Include="common\game.cpp">
      <Filter>Fichiers sources\common</Filter>
    </ClCompile>
    <ClCompile Include="sdk\structs\ClientClass.cpp">
      <Filter>Fichiers sources\sdk\structs</Filter>
    </ClCompile>
    <ClCompile Include="hook\functions\fireEventClientSide.cpp">
      <Filter>Fichiers sources\hook\functions</Filter>
    </ClCompile>
    <ClCompile Include="hook\functions\createMove.cpp">
      <Filter>Fichiers sources\hook\functions</Filter>
    </ClCompile>
    <ClCompile Include="features\visuals\world.cpp">
      <Filter>Fichiers sources\features\visuals</Filter>
    </ClCompile>
    <ClCompile Include="hook\functions\shouldDrawFog.cpp">
      <Filter>Fichiers sources\hook\functions</Filter>
    </ClCompile>
    <ClCompile Include="hook\functions\levelInitPostEntity.cpp">
      <Filter>Fichiers sources\hook\functions</Filter>
    </ClCompile>
    <ClCompile Include="features\visuals\animationfix.cpp">
      <Filter>Fichiers sources\features\visuals</Filter>
    </ClCompile>
    <ClCompile Include="features\backtrack\backtrack.cpp">
      <Filter>Fichiers sources\features\backtrack</Filter>
    </ClCompile>
    <ClCompile Include="features\misc\soundEsp.cpp">
      <Filter>Fichiers sources\features\misc</Filter>
    </ClCompile>
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="common\includes.h">
      <Filter>Fichiers sources\common</Filter>
    </ClInclude>
    <ClInclude Include="sdk\interfaces.h">
      <Filter>Fichiers sources\sdk</Filter>
    </ClInclude>
    <ClInclude Include="sdk\offsets.h">
      <Filter>Fichiers sources\sdk</Filter>
    </ClInclude>
    <ClInclude Include="common\common.h">
      <Filter>Fichiers sources\common</Filter>
    </ClInclude>
    <ClInclude Include="common\utils.h">
      <Filter>Fichiers sources\common</Filter>
    </ClInclude>
    <ClInclude Include="security\eraser.hpp">
      <Filter>Fichiers sources\security</Filter>
    </ClInclude>
    <ClInclude Include="security\instr.h">
      <Filter>Fichiers sources\security</Filter>
    </ClInclude>
    <ClInclude Include="security\lazy.hpp">
      <Filter>Fichiers sources\security</Filter>
    </ClInclude>
    <ClInclude Include="security\xorstr.hpp">
      <Filter>Fichiers sources\security</Filter>
    </ClInclude>
    <ClInclude Include="sdk\interfaces\CGlowObjectManager.h">
      <Filter>Fichiers sources\sdk\interfaces</Filter>
    </ClInclude>
    <ClInclude Include="sdk\interfaces\CHud.h">
      <Filter>Fichiers sources\sdk\interfaces</Filter>
    </ClInclude>
    <ClInclude Include="sdk\interfaces\CSPlayerResource.h">
      <Filter>Fichiers sources\sdk\interfaces</Filter>
    </ClInclude>
    <ClInclude Include="sdk\interfaces\IBaseClientDll.h">
      <Filter>Fichiers sources\sdk\interfaces</Filter>
    </ClInclude>
    <ClInclude Include="sdk\interfaces\IClientEntityList.h">
      <Filter>Fichiers sources\sdk\interfaces</Filter>
    </ClInclude>
    <ClInclude Include="sdk\interfaces\IClientModeShared.h">
      <Filter>Fichiers sources\sdk\interfaces</Filter>
    </ClInclude>
    <ClInclude Include="sdk\interfaces\IClientState.h">
      <Filter>Fichiers sources\sdk\interfaces</Filter>
    </ClInclude>
    <ClInclude Include="sdk\interfaces\ICVar.h">
      <Filter>Fichiers sources\sdk\interfaces</Filter>
    </ClInclude>
    <ClInclude Include="sdk\interfaces\IEngineClient.h">
      <Filter>Fichiers sources\sdk\interfaces</Filter>
    </ClInclude>
    <ClInclude Include="sdk\interfaces\IEngineTrace.h">
      <Filter>Fichiers sources\sdk\interfaces</Filter>
    </ClInclude>
    <ClInclude Include="sdk\interfaces\IGameEventManager.h">
      <Filter>Fichiers sources\sdk\interfaces</Filter>
    </ClInclude>
    <ClInclude Include="sdk\interfaces\IGlobalVarsBase.h">
      <Filter>Fichiers sources\sdk\interfaces</Filter>
    </ClInclude>
    <ClInclude Include="sdk\interfaces\IInput.h">
      <Filter>Fichiers sources\sdk\interfaces</Filter>
    </ClInclude>
    <ClInclude Include="sdk\interfaces\ILocalize.h">
      <Filter>Fichiers sources\sdk\interfaces</Filter>
    </ClInclude>
    <ClInclude Include="sdk\interfaces\IMaterialSystem.h">
      <Filter>Fichiers sources\sdk\interfaces</Filter>
    </ClInclude>
    <ClInclude Include="sdk\interfaces\IMatRenderContext.h">
      <Filter>Fichiers sources\sdk\interfaces</Filter>
    </ClInclude>
    <ClInclude Include="sdk\interfaces\IMemAlloc.h">
      <Filter>Fichiers sources\sdk\interfaces</Filter>
    </ClInclude>
    <ClInclude Include="sdk\interfaces\IMoveHelper.h">
      <Filter>Fichiers sources\sdk\interfaces</Filter>
    </ClInclude>
    <ClInclude Include="sdk\interfaces\IPhysicsSurfaceProps.h">
      <Filter>Fichiers sources\sdk\interfaces</Filter>
    </ClInclude>
    <ClInclude Include="sdk\interfaces\IPrediction.h">
      <Filter>Fichiers sources\sdk\interfaces</Filter>
    </ClInclude>
    <ClInclude Include="sdk\interfaces\ISurface.h">
      <Filter>Fichiers sources\sdk\interfaces</Filter>
    </ClInclude>
    <ClInclude Include="sdk\interfaces\IVDebugOverlay.h">
      <Filter>Fichiers sources\sdk\interfaces</Filter>
    </ClInclude>
    <ClInclude Include="sdk\interfaces\IViewRender.h">
      <Filter>Fichiers sources\sdk\interfaces</Filter>
    </ClInclude>
    <ClInclude Include="sdk\interfaces\IViewRenderBeams.h">
      <Filter>Fichiers sources\sdk\interfaces</Filter>
    </ClInclude>
    <ClInclude Include="sdk\interfaces\IVModelInfo.h">
      <Filter>Fichiers sources\sdk\interfaces</Filter>
    </ClInclude>
    <ClInclude Include="sdk\interfaces\IVModelRender.h">
      <Filter>Fichiers sources\sdk\interfaces</Filter>
    </ClInclude>
    <ClInclude Include="sdk\interfaces\IVPanel.h">
      <Filter>Fichiers sources\sdk\interfaces</Filter>
    </ClInclude>
    <ClInclude Include="sdk\interfaces\IVRenderView.h">
      <Filter>Fichiers sources\sdk\interfaces</Filter>
    </ClInclude>
    <ClInclude Include="sdk\interfaces\IWeaponSystem.h">
      <Filter>Fichiers sources\sdk\interfaces</Filter>
    </ClInclude>
    <ClInclude Include="sdk\math\Color.h">
      <Filter>Fichiers sources\sdk\math</Filter>
    </ClInclude>
    <ClInclude Include="sdk\math\CUtlVector.h">
      <Filter>Fichiers sources\sdk\math</Filter>
    </ClInclude>
    <ClInclude Include="sdk\math\matrix3x4_t.h">
      <Filter>Fichiers sources\sdk\math</Filter>
    </ClInclude>
    <ClInclude Include="sdk\math\QAngle.h">
      <Filter>Fichiers sources\sdk\math</Filter>
    </ClInclude>
    <ClInclude Include="sdk\math\Vector.h">
      <Filter>Fichiers sources\sdk\math</Filter>
    </ClInclude>
    <ClInclude Include="sdk\math\Vector2D.h">
      <Filter>Fichiers sources\sdk\math</Filter>
    </ClInclude>
    <ClInclude Include="sdk\math\Vector4D.h">
      <Filter>Fichiers sources\sdk\math</Filter>
    </ClInclude>
    <ClInclude Include="sdk\math\VMatrix.h">
      <Filter>Fichiers sources\sdk\math</Filter>
    </ClInclude>
    <ClInclude Include="sdk\defines.h">
      <Filter>Fichiers sources\sdk</Filter>
    </ClInclude>
    <ClInclude Include="sdk\structs\CBoneChache.h">
      <Filter>Fichiers sources\sdk\structs</Filter>
    </ClInclude>
    <ClInclude Include="sdk\structs\CCSGameRulesProxy.h">
      <Filter>Fichiers sources\sdk\structs</Filter>
    </ClInclude>
    <ClInclude Include="sdk\structs\CCSGOPlayerAnimState.h">
      <Filter>Fichiers sources\sdk\structs</Filter>
    </ClInclude>
    <ClInclude Include="sdk\structs\ClientClass.h">
      <Filter>Fichiers sources\sdk\structs</Filter>
    </ClInclude>
    <ClInclude Include="sdk\structs\CNetChannel.h">
      <Filter>Fichiers sources\sdk\structs</Filter>
    </ClInclude>
    <ClInclude Include="sdk\structs\ConVar.h">
      <Filter>Fichiers sources\sdk\structs</Filter>
    </ClInclude>
    <ClInclude Include="sdk\structs\IClientEntity.h">
      <Filter>Fichiers sources\sdk\structs</Filter>
    </ClInclude>
    <ClInclude Include="sdk\structs\IMaterial.h">
      <Filter>Fichiers sources\sdk\structs</Filter>
    </ClInclude>
    <ClInclude Include="sdk\structs\IMaterialVar.h">
      <Filter>Fichiers sources\sdk\structs</Filter>
    </ClInclude>
    <ClInclude Include="sdk\structs\INetChannelInfo.h">
      <Filter>Fichiers sources\sdk\structs</Filter>
    </ClInclude>
    <ClInclude Include="sdk\structs\IRefCounted.h">
      <Filter>Fichiers sources\sdk\structs</Filter>
    </ClInclude>
    <ClInclude Include="sdk\structs\misc.h">
      <Filter>Fichiers sources\sdk\structs</Filter>
    </ClInclude>
    <ClInclude Include="sdk\structs\structs.h">
      <Filter>Fichiers sources\sdk\structs</Filter>
    </ClInclude>
    <ClInclude Include="sdk\structs\trace_ray.h">
      <Filter>Fichiers sources\sdk\structs</Filter>
    </ClInclude>
    <ClInclude Include="hook\vtableHook.h">
      <Filter>Fichiers sources\hook</Filter>
    </ClInclude>
    <ClInclude Include="hook\hook.h">
      <Filter>Fichiers sources\hook</Filter>
    </ClInclude>
    <ClInclude Include="hook\functions\paintTraverse.h">
      <Filter>Fichiers sources\hook\functions</Filter>
    </ClInclude>
    <ClInclude Include="ui\render.h">
      <Filter>Fichiers sources\ui</Filter>
    </ClInclude>
    <ClInclude Include="hook\functions\shutdown.h">
      <Filter>Fichiers sources\hook\functions</Filter>
    </ClInclude>
    <ClInclude Include="hook\functions\lockCursor.h">
      <Filter>Fichiers sources\hook\functions</Filter>
    </ClInclude>
    <ClInclude Include="ui\image.h">
      <Filter>Fichiers sources\ui</Filter>
    </ClInclude>
    <ClInclude Include="ui\texture.h">
      <Filter>Fichiers sources\ui</Filter>
    </ClInclude>
    <ClInclude Include="common\config.h">
      <Filter>Fichiers sources\common</Filter>
    </ClInclude>
    <ClInclude Include="features\visuals\esp.h">
      <Filter>Fichiers sources\features\visuals</Filter>
    </ClInclude>
    <ClInclude Include="sdk\structs\Entity.h">
      <Filter>Fichiers sources\sdk\structs</Filter>
    </ClInclude>
    <ClInclude Include="sdk\netvars.h">
      <Filter>Fichiers sources\sdk</Filter>
    </ClInclude>
    <ClInclude Include="sdk\structs\datamap.h">
      <Filter>Fichiers sources\sdk\structs</Filter>
    </ClInclude>
    <ClInclude Include="common\vfunc.h">
      <Filter>Fichiers sources\common</Filter>
    </ClInclude>
    <ClInclude Include="sdk\structs\mystructs.h">
      <Filter>Fichiers sources\sdk\structs</Filter>
    </ClInclude>
    <ClInclude Include="ui\menu.h">
      <Filter>Fichiers sources\ui</Filter>
    </ClInclude>
    <ClInclude Include="common\input.h">
      <Filter>Fichiers sources\common</Filter>
    </ClInclude>
    <ClInclude Include="ui\sound.h">
      <Filter>Fichiers sources\ui</Filter>
    </ClInclude>
    <ClInclude Include="features\visuals\chams.h">
      <Filter>Fichiers sources\features\visuals</Filter>
    </ClInclude>
    <ClInclude Include="hook\functions\drawModelExecute.h">
      <Filter>Fichiers sources\hook\functions</Filter>
    </ClInclude>
    <ClInclude Include="features\visuals\skinchanger.h">
      <Filter>Fichiers sources\features\visuals</Filter>
    </ClInclude>
    <ClInclude Include="features\misc\voice.h">
      <Filter>Fichiers sources\features\misc</Filter>
    </ClInclude>
    <ClInclude Include="features\misc\misc.h">
      <Filter>Fichiers sources\features\misc</Filter>
    </ClInclude>
    <ClInclude Include="features\visuals\visualMisc.h">
      <Filter>Fichiers sources\features\visuals</Filter>
    </ClInclude>
    <ClInclude Include="common\events.h">
      <Filter>Fichiers sources\common</Filter>
    </ClInclude>
    <ClInclude Include="hook\functions\frameStageNotify.h">
      <Filter>Fichiers sources\hook\functions</Filter>
    </ClInclude>
    <ClInclude Include="features\misc\bypasses.h">
      <Filter>Fichiers sources\features\misc</Filter>
    </ClInclude>
    <ClInclude Include="hook\functions\serverSideChecks.h">
      <Filter>Fichiers sources\hook\functions</Filter>
    </ClInclude>
    <ClInclude Include="ui\zgui\dist\zgui.hh">
      <Filter>Fichiers sources\ui\zgui</Filter>
    </ClInclude>
    <ClInclude Include="features\visuals\glow.h">
      <Filter>Fichiers sources\features\visuals</Filter>
    </ClInclude>
    <ClInclude Include="hook\functions\doPostScreenEffects.h">
      <Filter>Fichiers sources\hook\functions</Filter>
    </ClInclude>
    <ClInclude Include="common\json\json.h">
      <Filter>Fichiers sources\common\json</Filter>
    </ClInclude>
    <ClInclude Include="common\json\json-forwards.h">
      <Filter>Fichiers sources\common\json</Filter>
    </ClInclude>
    <ClInclude Include="common\game.h">
      <Filter>Fichiers sources\common</Filter>
    </ClInclude>
    <ClInclude Include="sdk\interfaces\IConsole.h">
      <Filter>Fichiers sources\sdk\interfaces</Filter>
    </ClInclude>
    <ClInclude Include="hook\functions\fireEventClientSide.h">
      <Filter>Fichiers sources\hook\functions</Filter>
    </ClInclude>
    <ClInclude Include="resource.h">
      <Filter>Fichiers d%27en-tête</Filter>
    </ClInclude>
    <ClInclude Include="sdk\interfaces\ISteamGameServer.h">
      <Filter>Fichiers sources\sdk\interfaces</Filter>
    </ClInclude>
    <ClInclude Include="sdk\interfaces\IStudioRender.h">
      <Filter>Fichiers sources\sdk\interfaces</Filter>
    </ClInclude>
    <ClInclude Include="hook\functions\createMove.h">
      <Filter>Fichiers sources\hook\functions</Filter>
    </ClInclude>
    <ClInclude Include="features\visuals\world.h">
      <Filter>Fichiers sources\features\visuals</Filter>
    </ClInclude>
    <ClInclude Include="sdk\math\math.h">
      <Filter>Fichiers sources\sdk\math</Filter>
    </ClInclude>
    <ClInclude Include="security\hash.h">
      <Filter>Fichiers sources\security</Filter>
    </ClInclude>
    <ClInclude Include="hook\functions\shouldDrawFog.h">
      <Filter>Fichiers sources\hook\functions</Filter>
    </ClInclude>
    <ClInclude Include="hook\functions\levelInitPostEntity.h">
      <Filter>Fichiers sources\hook\functions</Filter>
    </ClInclude>
    <ClInclude Include="features\visuals\animationfix.h">
      <Filter>Fichiers sources\features\visuals</Filter>
    </ClInclude>
    <ClInclude Include="features\backtrack\backtrack.h">
      <Filter>Fichiers sources\features\backtrack</Filter>
    </ClInclude>
    <ClInclude Include="features\misc\soundEsp.h">
      <Filter>Fichiers sources\features\misc</Filter>
    </ClInclude>
  </ItemGroup>
  <ItemGroup>
    <None Include="exportOrdinals.def">
      <Filter>Fichiers sources</Filter>
    </None>
  </ItemGroup>
  <ItemGroup>
    <ResourceCompile Include="resource.rc">
      <Filter>Fichiers de ressources</Filter>
    </ResourceCompile>
  </ItemGroup>
</Project>
```

`Lumina/Lumina/common/common.cpp`:

```cpp
#include "../common/includes.h"

#include "common.h"

#include <fstream>

namespace common {

	bool active = true;
	bool unload = false;

	float hitmarkerTime = 0;
	int   hitmarkerDamage = 0;

	HMODULE currentModule = NULL;
	HMODULE engineModule = NULL;
	HMODULE clientModule = NULL;
	HMODULE materialsystemModule = NULL;
	HMODULE vguimatsurfaceModule = NULL;
	HMODULE vstdlibModule = NULL;
	HMODULE soundsystemModule = NULL;
	HMODULE vgui2Module = NULL;
	HMODULE datacacheModule = NULL;
	HMODULE dx9apiModule = NULL;
	HMODULE inputSysModule = NULL;
	HMODULE localizeModule = NULL;
	HMODULE steamApiModule = NULL;
	HMODULE studiorenderModule = NULL;

	std::string luminaPath = XorStr("C:\\Lumina\\");

	void ps(std::string message)
	{
#ifdef _DEBUG

		time_t rawtime;
		char buffer[80];
		char bufferLog[80];
		char printedString[150];

		time(&rawtime);

		strftime(buffer, sizeof(buffer), XorStr("%H:%M:%S"), localtime(&rawtime));

		strftime(bufferLog, sizeof(bufferLog), XorStr("%d.%m.%Y"), localtime(&rawtime));

		sprintf(printedString, XorStr("[%s] %s\r\n"), buffer, message.c_str());

#endif

#ifdef FULL_DEBUG

		std::ofstream logFile;

		std::string logFileNAme = "C:\\Lumina\\log.";

		logFileNAme += bufferLog;
		logFileNAme += ".txt";

		logFile.open(logFileNAme.c_str(), std::ios_base::app);

		std::string ff = printedString;

		logFile << ff.substr(0, ff.length() - 2);
		logFile << "\n";
#endif

#ifdef _DEBUG
		printf(printedString);
#endif

	}

	void pf(std::string fmt, ...) {

#ifdef _DEBUG

			int size = ((int)fmt.size()) * 2 + 50;
			std::string str;
			va_list ap;
			while (1) {
				str.resize(size);
				va_start(ap, fmt);
				int n = vsnprintf((char *)str.data(), size, fmt.c_str(), ap);
				va_end(ap);
				if (n > -1 && n < size) {
					str.resize(n);
					goto fine;
				}
				if (n > -1)
					size = n + 1;
				else
					size *= 2;
			}

		fine:

			time_t rawtime;
			char buffer[80];
			char bufferLog[80];
			char printedString[150];

			time(&rawtime);

			strftime(buffer, sizeof(buffer), XorStr("%H:%M:%S"), localtime(&rawtime));

			strftime(bufferLog, sizeof(bufferLog), XorStr("%d.%m.%Y"), localtime(&rawtime));

			sprintf(printedString, XorStr("[%s] %s\r\n"), buffer, str.c_str());
#endif

#ifdef FULL_DEBUG

			std::ofstream logFile;

			std::string logFileNAme = "C:\\Lumina\\log.";

			logFileNAme += bufferLog;
			logFileNAme += ".txt";

			logFile.open(logFileNAme.c_str(), std::ios_base::app);

			std::string ff = printedString;

			logFile << ff.substr(0,ff.length()-2);
			logFile << "\n";
#endif

#ifdef _DEBUG
			printf(printedString);
#endif
	}

	void exit() {

#ifdef _DEBUG
		ps("common::exit : exit");
#endif

		FreeLibraryAndExitThread(common::currentModule, 0);

		active = false;
	}
}
```

`Lumina/Lumina/common/common.h`:

```h
#ifndef common_h

#define common_h

#include "../common/includes.h"

#define VECTOR_PUSH(vec, str, ord) \
	const char* ord = StringHeavy(str); \
	vec.push_back(ord); \

#define VECTOR_PUSH_TUPLE(vec, str, pointer, ord, ord1) \
	const char* ord = StringHeavy(str); \
	zgui::multi_select_item ord1; \
	ord1.name = ord; \
	ord1.value = pointer; \
	vec.push_back(ord1); \

#define BLOCK __asm __emit 0xB0 __asm __emit 0x0B __asm __emit 0xF0 __asm __emit 0xB0 __asm __emit 0x0B __asm __emit 0xF0 __asm __emit 0xB0 __asm __emit 0xBE __asm __emit 0xEF __asm __emit 0xDE __asm __emit 0xAD __asm __emit 0x01 __asm __emit 0xDE __asm __emit 0xAD
#define JUNK(a) __asm jmp a BLOCK

namespace common {

	extern HMODULE currentModule;
	extern HMODULE engineModule;
	extern HMODULE clientModule;
	extern HMODULE materialsystemModule;
	extern HMODULE vguimatsurfaceModule;
	extern HMODULE vstdlibModule;
	extern HMODULE soundsystemModule;
	extern HMODULE vgui2Module;
	extern HMODULE datacacheModule;
	extern HMODULE dx9apiModule;
	extern HMODULE inputSysModule;
	extern HMODULE localizeModule;
	extern HMODULE steamApiModule;
	extern HMODULE studiorenderModule;

	extern std::string luminaPath;

	extern bool active;

	extern bool unload;

	extern float hitmarkerTime;
	extern int   hitmarkerDamage;

//#ifdef _DEBUG
	void ps(std::string message);
	void pf(std::string fmt, ...);
//#endif

	void exit();
}

#endif // !common_h
```

`Lumina/Lumina/common/config.cpp`:

```cpp
#include "config.h"

#include "common.h"
#include "../ui/menu.h"
#include "json/json.h"

#include <fstream>

namespace config {

	visuals visual;
	cheat cheats;

	void init() {

		ZeroMemory(&visual, sizeof(visuals));
		ZeroMemory(&cheats, sizeof(cheat));

#ifdef _DEBUG
		common::ps(XorStr("config::init : done"));
#endif
	}

	void openCheatConfig(std::string name) {

		VMProtectBeginMutation("config::openCheatConfig");

		std::string configPath = common::luminaPath + name;

		Json::Value config;

		std::ifstream file(configPath, std::ifstream::binary);

		file >> config;

		BOOL_WRITE(cheats.fastStop, config[XorStr("fastStop")])
		BOOL_WRITE(cheats.silentWalk, config[XorStr("silentWalk")])
		BOOL_WRITE(cheats.optimization, config[XorStr("optimization")])

		BOOL_WRITE(cheats.backtrack, config[XorStr("backtrack")])
		FLOAT_WRITE(cheats.backtrackVisibility, config[XorStr("backtrackVisibility")])
		FLOAT_WRITE(cheats.backtrackTime, config[XorStr("backtrackTime")])

#ifdef _DEBUG
		common::ps(XorStr("config::openCheatConfig : done"));
#endif

		VMProtectEnd();
	}

	void saveCheatConfig(std::string name) {

		VMProtectBeginMutation("config::saveCheatConfig");

		std::string configPath = common::luminaPath + name;

		Json::Value config;


		config[XorStr("fastStop")] = cheats.fastStop;
		config[XorStr("silentWalk")] = cheats.silentWalk;
		config[XorStr("optimization")] = cheats.optimization;

		config[XorStr("backtrack")] = cheats.backtrack;
		config[XorStr("backtrackVisibility")] = cheats.backtrackVisibility;
		config[XorStr("backtrackTime")] = cheats.backtrackTime;

		std::remove(configPath.c_str());

		std::ofstream file;

		file.open(configPath.c_str(), std::ios_base::app);

		Json::StreamWriterBuilder builder;

		builder["commentStyle"] = "None";
		builder["indentation"] = "   ";

		std::unique_ptr<Json::StreamWriter> writer(builder.newStreamWriter());

		writer->write(config, &file);

		file.close();

#ifdef _DEBUG
		common::ps(XorStr("config::saveCheatConfig : done"));
#endif

		VMProtectEnd();
	}

	void openVisualConfig(std::string name) {

		VMProtectBeginMutation("config::openVisualConfig");

		std::string configPath = common::luminaPath + name;

		Json::Value config;

		std::ifstream file(configPath, std::ifstream::binary);

		file >> config;

		// serialization is not working :(
		// so ghettto json read

		BOOL_WRITE(visual.enemyEsp.showOnlyIsDead, config[XorStr("enemyEsp")][XorStr("showOnlyIsDead")])
		BOOL_WRITE(visual.enemyEsp.showBox, config[XorStr("enemyEsp")][XorStr("showBox")]);
		BOOL_WRITE(visual.enemyEsp.showName, config[XorStr("enemyEsp")][XorStr("showName")]);
		BOOL_WRITE(visual.enemyEsp.showSkeleton, config[XorStr("enemyEsp")][XorStr("showSkeleton")]);
		BOOL_WRITE(visual.enemyEsp.showLife, config[XorStr("enemyEsp")][XorStr("showLife")]);
		BOOL_WRITE(visual.enemyEsp.showAmmo, config[XorStr("enemyEsp")][XorStr("showAmmo")]);
		BOOL_WRITE(visual.enemyEsp.showIcons, config[XorStr("enemyEsp")][XorStr("showIcons")]);
		BOOL_WRITE(visual.enemyEsp.showWeaponName, config[XorStr("enemyEsp")][XorStr("showWeaponName")]);
		BOOL_WRITE(visual.enemyEsp.showWeaponIcon, config[XorStr("enemyEsp")][XorStr("showWeaponIcon")]);
		BOOL_WRITE(visual.enemyEsp.showPing, config[XorStr("enemyEsp")][XorStr("showPing")]);
		BOOL_WRITE(visual.enemyEsp.showMoney, config[XorStr("enemyEsp")][XorStr("showMoney")]);
		BOOL_WRITE(visual.enemyEsp.showArmor, config[XorStr("enemyEsp")][XorStr("showArmor")]);
		BOOL_WRITE(visual.enemyEsp.showHasDefuser, config[XorStr("enemyEsp")][XorStr("showHasDefuser")]);
		BOOL_WRITE(visual.enemyEsp.showDefusing, config[XorStr("enemyEsp")][XorStr("showDefusing")]);
		BOOL_WRITE(visual.enemyEsp.showReload, config[XorStr("enemyEsp")][XorStr("showReload")]);
		BOOL_WRITE(visual.enemyEsp.showBomb, config[XorStr("enemyEsp")][XorStr("showBomb")]);
		BOOL_WRITE(visual.enemyEsp.showFlashed, config[XorStr("enemyEsp")][XorStr("showFlashed")]);
		BOOL_WRITE(visual.enemyEsp.showScopping, config[XorStr("enemyEsp")][XorStr("showScopping")]);
		BOOL_WRITE(visual.enemyEsp.showCheating, config[XorStr("enemyEsp")][XorStr("showCheating")]);
		BOOL_WRITE(visual.enemyEsp.showFakeDuck, config[XorStr("enemyEsp")][XorStr("showFakeDuck")]);
		BOOL_WRITE(visual.enemyEsp.showLegitAA, config[XorStr("enemyEsp")][XorStr("showLegitAA")]);
		BOOL_WRITE(visual.enemyEsp.showFakeDuck, config[XorStr("enemyEsp")][XorStr("showFakeDuck")]);
		BOOL_WRITE(visual.enemyEsp.showPlanting, config[XorStr("enemyEsp")][XorStr("showPlanting")]);

		//BOOL_WRITE(visual.sounds.enable, config[XorStr("sounds")][XorStr("enable")]);
		//INT_WRITE(visual.sounds.hitmarkerSound, config[XorStr("sounds")][XorStr("hitmarkerSound")]);
		//INT_WRITE(visual.sounds.headShootSound, config[XorStr("sounds")][XorStr("headShootSound")]);
		//INT_WRITE(visual.sounds.roundStartSound, config[XorStr("sounds")][XorStr("roundStartSound")]);
		//INT_WRITE(visual.sounds.roundEndLostSound, config[XorStr("sounds")][XorStr("roundEndLostSound")]);
		//INT_WRITE(visual.sounds.roundEndWonSound, config[XorStr("sounds")][XorStr("roundEndWonSound")]);
		//INT_WRITE(visual.sounds.bombPlantedSound, config[XorStr("sounds")][XorStr("bombPlantedSound")]);
		//INT_WRITE(visual.sounds.playerKickSound, config[XorStr("sounds")][XorStr("playerKickSound")]);

		BOOL_WRITE(visual.playerModel.enable, config[XorStr("playerModel")][XorStr("enable")]);
		INT_WRITE(visual.playerModel.id, config[XorStr("playerModel")][XorStr("id")]);
		COLOR_JSON_READ(visual.enemyEsp.espColor, config[XorStr("enemyEsp")][XorStr("espColor")])

		BOOL_WRITE(visual.glow.enable, config[XorStr("glow")][XorStr("enable")]);
		FLOAT_WRITE(visual.glow.bloom, config[XorStr("glow")][XorStr("bloom")]);
		BOOL_WRITE(visual.glow.onlyIfDead, config[XorStr("glow")][XorStr("onlyIfDead")])

		COLOR_JSON_READ(visual.glow.glowColor, config[XorStr("glow")][XorStr("glowColor")])

		BOOL_WRITE(visual.skins.enable, config[XorStr("skins")][XorStr("enable")]);

		SKIN_COLLECTION_JSON_READ(ctSkins, "ctSkins")

		//config::visual.skins.ctSkins.knifeId
		INT_WRITE(visual.skins.ctSkins.knifeId, config[XorStr("skins")][XorStr("ctSkins")][XorStr("knifeId")])
		INT_WRITE(visual.skins.ctSkins.knifePaint, config[XorStr("skins")][XorStr("ctSkins")][XorStr("knifePaint")])

		SKIN_COLLECTION_JSON_READ(tSkins, "tSkins")

		INT_WRITE(visual.skins.tSkins.knifeId, config[XorStr("skins")][XorStr("tSkins")][XorStr("knifeId")])
		INT_WRITE(visual.skins.tSkins.knifePaint, config[XorStr("skins")][XorStr("tSkins")][XorStr("knifePaint")])

		BOOL_WRITE(visual.showSpectators, config[XorStr("showSpectators")]);
		BOOL_WRITE(visual.spreadCircle.enable, config[XorStr("spreadCircle")][XorStr("enable")]);
		FLOAT_WRITE(visual.spreadCircle.min, config[XorStr("spreadCircle")][XorStr("min")]);
		BOOL_WRITE(visual.indicators.showFlashDuration, config[XorStr("indicators")][XorStr("showFlashDuration")]);

		CHAMS_JSON_READ(enemyChamsVisible, "enemyChamsVisible", color1)
		CHAMS_JSON_READ(enemyChamsBacktrack, "enemyChamsBacktrack", color1)
		CHAMS_JSON_READ(handChams, "handChams", color2)
		CHAMS_JSON_READ(sleeveChams, "sleeveChams", color3)

		BOOL_WRITE(visual.showGrenadePred, config[XorStr("showGrenadePred")]);

		BOOL_WRITE(visual.world.enable, config[XorStr("world")][XorStr("enable")]);
		COLOR_JSON_READ(visual.world.worldColor, config[XorStr("world")][XorStr("worldColor")])
		COLOR_JSON_READ(visual.world.propsColor, config[XorStr("world")][XorStr("propsColor")])

		BOOL_WRITE(visual.sky.enable, config[XorStr("sky")][XorStr("enable")]);
		INT_WRITE(visual.sky.sky, config[XorStr("sky")][XorStr("sky")]);
		COLOR_JSON_READ(visual.sky.skyColor, config[XorStr("sky")][XorStr("skyColor")])

		menu::loadConfig();

#ifdef _DEBUG
			common::ps(XorStr("config::openVisualConfig : done"));
#endif

		VMProtectEnd();
	}

	void saveVisualConfig(std::string name) {

		VMProtectBeginMutation("config::saveVisualConfig");

		std::string configPath = common::luminaPath + name;

		Json::Value config;

		// serialization is not working :(
		// so ghettto json writing

		config[XorStr("enemyEsp")][XorStr("showOnlyIsDead")] = visual.enemyEsp.showOnlyIsDead;
		config[XorStr("enemyEsp")][XorStr("showBox")] = visual.enemyEsp.showBox;
		config[XorStr("enemyEsp")][XorStr("showName")] = visual.enemyEsp.showName;
		config[XorStr("enemyEsp")][XorStr("showSkeleton")] = visual.enemyEsp.showSkeleton;
		config[XorStr("enemyEsp")][XorStr("showLife")] = visual.enemyEsp.showLife;
		config[XorStr("enemyEsp")][XorStr("showAmmo")] = visual.enemyEsp.showAmmo;
		config[XorStr("enemyEsp")][XorStr("showIcons")] = visual.enemyEsp.showIcons;
		config[XorStr("enemyEsp")][XorStr("showWeaponName")] = visual.enemyEsp.showWeaponName;
		config[XorStr("enemyEsp")][XorStr("showWeaponIcon")] = visual.enemyEsp.showWeaponIcon;
		config[XorStr("enemyEsp")][XorStr("showPing")] = visual.enemyEsp.showPing;
		config[XorStr("enemyEsp")][XorStr("showMoney")] = visual.enemyEsp.showMoney;
		config[XorStr("enemyEsp")][XorStr("showArmor")] = visual.enemyEsp.showArmor;
		config[XorStr("enemyEsp")][XorStr("showHasDefuser")] = visual.enemyEsp.showHasDefuser;
		config[XorStr("enemyEsp")][XorStr("showDefusing")] = visual.enemyEsp.showDefusing;
		config[XorStr("enemyEsp")][XorStr("showReload")] = visual.enemyEsp.showReload;
		config[XorStr("enemyEsp")][XorStr("showBomb")] = visual.enemyEsp.showBomb;
		config[XorStr("enemyEsp")][XorStr("showFlashed")] = visual.enemyEsp.showFlashed;
		config[XorStr("enemyEsp")][XorStr("showScopping")] = visual.enemyEsp.showScopping;
		config[XorStr("enemyEsp")][XorStr("showCheating")] = visual.enemyEsp.showCheating;
		config[XorStr("enemyEsp")][XorStr("showFakeDuck")] = visual.enemyEsp.showFakeDuck;
		config[XorStr("enemyEsp")][XorStr("showLegitAA")] = visual.enemyEsp.showLegitAA;
		config[XorStr("enemyEsp")][XorStr("showFakeDuck")] = visual.enemyEsp.showFakeDuck;
		config[XorStr("enemyEsp")][XorStr("showPlanting")] = visual.enemyEsp.showPlanting;

		//config[XorStr("sounds")][XorStr("enable")] = visual.sounds.enable;
		//config[XorStr("sounds")][XorStr("hitmarkerSound")] = visual.sounds.hitmarkerSound;
		//config[XorStr("sounds")][XorStr("headShootSound")] = visual.sounds.headShootSound;
		//config[XorStr("sounds")][XorStr("roundStartSound")] = visual.sounds.roundStartSound;
		//config[XorStr("sounds")][XorStr("roundEndLostSound")] = visual.sounds.roundEndLostSound;
		//config[XorStr("sounds")][XorStr("roundEndWonSound")] = visual.sounds.roundEndWonSound;
		//config[XorStr("sounds")][XorStr("bombPlantedSound")] = visual.sounds.bombPlantedSound;
		//config[XorStr("sounds")][XorStr("playerKickSound")] = visual.sounds.playerKickSound;

		config[XorStr("playerModel")][XorStr("enable")] = visual.playerModel.enable;
		config[XorStr("playerModel")][XorStr("id")] = visual.playerModel.id;


		COLOR_JSON_WRITE(espColor, visual.enemyEsp.espColor)

		config[XorStr("enemyEsp")][XorStr("espColor")] = espColor;

		config[XorStr("glow")][XorStr("enable")] = visual.glow.enable;
		config[XorStr("glow")][XorStr("onlyIfDead")] = visual.glow.onlyIfDead;
		config[XorStr("glow")][XorStr("bloom")] = visual.glow.bloom;

		COLOR_JSON_WRITE(glowColor, visual.glow.glowColor)

		config[XorStr("glow")][XorStr("glowColor")] = glowColor;

		config[XorStr("skins")][XorStr("enable")] = visual.skins.enable;

		SKIN_COLLECTION_JSON(ctSkins, "ctSkins")

		config[XorStr("skins")][XorStr("ctSkins")][XorStr("knifeId")] = visual.skins.ctSkins.knifeId;
		config[XorStr("skins")][XorStr("ctSkins")][XorStr("knifePaint")] = visual.skins.ctSkins.knifePaint;

		SKIN_COLLECTION_JSON(tSkins, "tSkins")
		config[XorStr("skins")][XorStr("tSkins")][XorStr("knifeId")] = visual.skins.tSkins.knifeId;
		config[XorStr("skins")][XorStr("tSkins")][XorStr("knifePaint")] = visual.skins.tSkins.knifePaint;



		config[XorStr("showGrenadePred")] = visual.showGrenadePred;
		config[XorStr("showSpectators")] = visual.showSpectators;
		config[XorStr("spreadCircle")][XorStr("enable")] = visual.spreadCircle.enable;
		config[XorStr("spreadCircle")][XorStr("min")] = visual.spreadCircle.min;
		config[XorStr("indicators")][XorStr("showFlashDuration")] = visual.indicators.showFlashDuration;

		CHAMS_JSON(enemyChamsVisible, "enemyChamsVisible", color1, color1_)
		CHAMS_JSON(enemyChamsBacktrack, "enemyChamsBacktrack", color4, color4_)
		CHAMS_JSON(handChams, "handChams", color2, color2_)
		CHAMS_JSON(sleeveChams, "sleeveChams", color3, color3_)

		config[XorStr("world")][XorStr("enable")] = visual.world.enable;
		COLOR_JSON_WRITE(worldColor, visual.world.worldColor)
		config[XorStr("world")][XorStr("worldColor")] = worldColor;
		COLOR_JSON_WRITE(propsColor, visual.world.propsColor)
		config[XorStr("world")][XorStr("propsColor")] = propsColor;

		config[XorStr("sky")][XorStr("enable")] = visual.sky.enable;
		config[XorStr("sky")][XorStr("sky")] = visual.sky.sky;
		COLOR_JSON_WRITE(skyColor, visual.sky.skyColor)
		config[XorStr("sky")][XorStr("skyColor")] = skyColor;

		std::remove(configPath.c_str());

		std::ofstream file;

		file.open(configPath.c_str(), std::ios_base::app);

		Json::StreamWriterBuilder builder;

		builder["commentStyle"] = "None";
		builder["indentation"] = "   "; 

		std::unique_ptr<Json::StreamWriter> writer(builder.newStreamWriter());

		writer->write(config, &file);

		file.close();

#ifdef _DEBUG
		common::ps(XorStr("config::saveVisualConfig : done"));
#endif

		VMProtectEnd();
	}
}
```

`Lumina/Lumina/common/config.h`:

```h
#ifndef config_h

#define config_h

#include "../sdk/math/Color.h"
#include <string>

struct skin {
		int paint; 
		float wear; 
		int seed; 
		bool stattrack;
		int stattrackCount; 
		int quality; 
		int sticker1; 
		int sticker2; 
		int sticker3; 
		int sticker4; 
}; 

#define SKIN(name) \
	skin name;
/*
	struct skin name { \
		int paint; \
		float wear; \
		int seed; \
		bool stattrack; \
		int stattrackCount; \
		int quality; \
		int sticker1; \
		int sticker2; \
		int sticker3; \
		int sticker4; \
	}; \
*/

#define SKIN_COLLECTION(name) \
	struct { \
		int knifeId; \
		int knifePaint; \
		SKIN(awpSkin) \
		SKIN(ak47Skin) \
		SKIN(uspSkin) \
		SKIN(deagleSkin) \
		SKIN(ssg08Skin) \
		SKIN(scarSkin) \
		SKIN(m4a1Skin) \
		SKIN(famasSkin) \
		SKIN(g3sg1Skin) \
		SKIN(m4a1s1Skin) \
		SKIN(sg553Skin) \
		SKIN(augSkin) \
		SKIN(galilSkin) \
	    SKIN(mac10Skin) \
		SKIN(mp5Skin) \
		SKIN(mp7Skin) \
		SKIN(mp9Skin) \
		SKIN(ppbizonSkin) \
		SKIN(p90Skin) \
		SKIN(umpSkin) \
		SKIN(cz75Skin) \
		SKIN(dualberttaSkin) \
		SKIN(fiveSevenSkin) \
		SKIN(glockSkin) \
		SKIN(p250Skin) \
		SKIN(tec9Skin) \
		SKIN(revolverSkin) \
	} name; \

struct chams_t
{
	bool enable;
	int material;
	bool rainbowColor;
	Color color;
	bool throughWall;
	bool throughWallOnlyIfDead;

	bool enableOverlay;
	int overlayMaterial;
	bool overlayRainbowColor;
	Color overlayColor;
};

#define CHAMS_(name) \
	chams_t name; \


#define BOOL_WRITE(bool_, config) \
	std::istringstream(config.asString()) >> std::boolalpha >> bool_;

#define INT_WRITE(int_, config) \
	 int_ = std::stoi(config.asString());

#define FLOAT_WRITE(float_, config) \
	 float_ = std::stof(config.asString());


#define CHAMS_JSON(name, nameStr, pad, pad0) \
	config[XorStr(nameStr)][XorStr("enable")] = visual.name.enable; \
	config[XorStr(nameStr)][XorStr("throughWall")] = visual.name.throughWall; \
	config[XorStr(nameStr)][XorStr("throughWallOnlyIfDead")] = visual.name.throughWallOnlyIfDead; \
	config[XorStr(nameStr)][XorStr("material")] = visual.name.material; \
	config[XorStr(nameStr)][XorStr("rainbowColor")] = visual.name.rainbowColor; \
	COLOR_JSON_WRITE(pad, visual.name.color) \
	config[XorStr(nameStr)][XorStr("color")] = pad; \
	config[XorStr(nameStr)][XorStr("enableOverlay")] = visual.name.enableOverlay; \
	config[XorStr(nameStr)][XorStr("overlayMaterial")] = visual.name.overlayMaterial; \
	config[XorStr(nameStr)][XorStr("overlayRainbowColor")] = visual.name.overlayRainbowColor; \
	COLOR_JSON_WRITE(pad0, visual.name.overlayColor) \
	config[XorStr(nameStr)][XorStr("overlayColor")] = pad0; \

#define COLOR_JSON_WRITE(name, path) \
		Json::Value name(Json::arrayValue); \
		name.append(Json::Value(path.r())); \
		name.append(Json::Value(path.g())); \
		name.append(Json::Value(path.b())); \
		name.append(Json::Value(path.a())); \

#define SKIN_JSON(side,name,sideStr,nameStr) \
	config[XorStr("skins")][XorStr(sideStr)][XorStr(nameStr)][XorStr("paint")] = visual.skins.side.name.paint; \
	config[XorStr("skins")][XorStr(sideStr)][XorStr(nameStr)][XorStr("wear")] = visual.skins.side.name.wear; \
	config[XorStr("skins")][XorStr(sideStr)][XorStr(nameStr)][XorStr("seed")] = visual.skins.side.name.seed; \
	config[XorStr("skins")][XorStr(sideStr)][XorStr(nameStr)][XorStr("stattrack")] = visual.skins.side.name.stattrack; \
	config[XorStr("skins")][XorStr(sideStr)][XorStr(nameStr)][XorStr("stattrackCount")] = visual.skins.side.name.stattrackCount; \
	config[XorStr("skins")][XorStr(sideStr)][XorStr(nameStr)][XorStr("quality")] = visual.skins.side.name.quality; \
	config[XorStr("skins")][XorStr(sideStr)][XorStr(nameStr)][XorStr("sticker1")] = visual.skins.side.name.sticker1; \
	config[XorStr("skins")][XorStr(sideStr)][XorStr(nameStr)][XorStr("sticker2")] = visual.skins.side.name.sticker2; \
	config[XorStr("skins")][XorStr(sideStr)][XorStr(nameStr)][XorStr("sticker3")] = visual.skins.side.name.sticker3; \
	config[XorStr("skins")][XorStr(sideStr)][XorStr(nameStr)][XorStr("sticker4")] = visual.skins.side.name.sticker4; \

#define SKIN_COLLECTION_JSON(side, sideStr) \
		SKIN_JSON(side, awpSkin, sideStr, "awpSkin") \
		SKIN_JSON(side, ak47Skin, sideStr, "ak47Skin") \
		SKIN_JSON(side, uspSkin, sideStr, "uspSkin") \
		SKIN_JSON(side, deagleSkin, sideStr, "deagleSkin") \
		SKIN_JSON(side, ssg08Skin, sideStr, "ssg08Skin") \
		SKIN_JSON(side, scarSkin, sideStr, "scarSkin") \
		SKIN_JSON(side, m4a1Skin, sideStr, "m4a1Skin") \
		SKIN_JSON(side, famasSkin, sideStr, "famasSkin") \
		SKIN_JSON(side, g3sg1Skin, sideStr, "g3sg1Skin") \
		SKIN_JSON(side, m4a1s1Skin, sideStr, "m4a1s1Skin") \
		SKIN_JSON(side, sg553Skin, sideStr, "sg553Skin") \
		SKIN_JSON(side, augSkin, sideStr, "augSkin") \
		SKIN_JSON(side, galilSkin, sideStr, "galilSkin") \
	    SKIN_JSON(side, mac10Skin, sideStr, "mac10Skin") \
		SKIN_JSON(side, mp5Skin, sideStr, "mp5Skin") \
		SKIN_JSON(side, mp7Skin, sideStr, "mp7Skin") \
		SKIN_JSON(side, mp9Skin, sideStr, "mp9Skin") \
		SKIN_JSON(side, ppbizonSkin, sideStr, "ppbizonSkin") \
		SKIN_JSON(side, p90Skin, sideStr, "p90Skin") \
		SKIN_JSON(side, umpSkin, sideStr, "umpSkin") \
		SKIN_JSON(side, cz75Skin, sideStr, "cz75Skin") \
		SKIN_JSON(side, dualberttaSkin, sideStr, "dualberttaSkin") \
		SKIN_JSON(side, fiveSevenSkin, sideStr, "fiveSevenSkin") \
		SKIN_JSON(side, glockSkin, sideStr, "glockSkin") \
		SKIN_JSON(side, p250Skin, sideStr, "p250Skin") \
		SKIN_JSON(side, tec9Skin, sideStr, "tec9Skin") \
		SKIN_JSON(side, revolverSkin, sideStr, "revolverSkin") \


#define COLOR_JSON_READ(path,json) \
		path.SetColor(std::stoi(json[0].asString()),std::stoi(json[1].asString()),std::stoi(json[2].asString()),std::stoi(json[3].asString())); \

#define SKIN_JSON_READ(side,name,sideStr,nameStr) \
	INT_WRITE(visual.skins.side.name.paint, config[XorStr("skins")][XorStr(sideStr)][XorStr(nameStr)][XorStr("paint")]); \
	FLOAT_WRITE(visual.skins.side.name.wear, config[XorStr("skins")][XorStr(sideStr)][XorStr(nameStr)][XorStr("wear")]); \
	INT_WRITE(visual.skins.side.name.seed, config[XorStr("skins")][XorStr(sideStr)][XorStr(nameStr)][XorStr("seed")]); \
	BOOL_WRITE(visual.skins.side.name.stattrack, config[XorStr("skins")][XorStr(sideStr)][XorStr(nameStr)][XorStr("stattrack")]); \
	INT_WRITE(visual.skins.side.name.stattrackCount, config[XorStr("skins")][XorStr(sideStr)][XorStr(nameStr)][XorStr("stattrackCount")]); \
	INT_WRITE(visual.skins.side.name.quality, config[XorStr("skins")][XorStr(sideStr)][XorStr(nameStr)][XorStr("quality")]); \
	INT_WRITE(visual.skins.side.name.sticker1, config[XorStr("skins")][XorStr(sideStr)][XorStr(nameStr)][XorStr("sticker1")]); \
	INT_WRITE(visual.skins.side.name.sticker2, config[XorStr("skins")][XorStr(sideStr)][XorStr(nameStr)][XorStr("sticker2")]); \
	INT_WRITE(visual.skins.side.name.sticker3, config[XorStr("skins")][XorStr(sideStr)][XorStr(nameStr)][XorStr("sticker3")]); \
	INT_WRITE(visual.skins.side.name.sticker4, config[XorStr("skins")][XorStr(sideStr)][XorStr(nameStr)][XorStr("sticker4")]); \

#define CHAMS_JSON_READ(name, nameStr, pad) \
	BOOL_WRITE(visual.name.enable, config[XorStr(nameStr)][XorStr("enable")]); \
	BOOL_WRITE(visual.name.throughWall, config[XorStr(nameStr)][XorStr("throughWall")]); \
	BOOL_WRITE(visual.name.throughWallOnlyIfDead, config[XorStr(nameStr)][XorStr("throughWallOnlyIfDead")]); \
	INT_WRITE(visual.name.material, config[XorStr(nameStr)][XorStr("material")]); \
	BOOL_WRITE(visual.name.rainbowColor, config[XorStr(nameStr)][XorStr("rainbowColor")]); \
	COLOR_JSON_READ(visual.name.color, config[XorStr(nameStr)][XorStr("color")]) \
	BOOL_WRITE(visual.name.enableOverlay, config[XorStr(nameStr)][XorStr("enableOverlay")]); \
	INT_WRITE(visual.name.overlayMaterial, config[XorStr(nameStr)][XorStr("overlayMaterial")]); \
	BOOL_WRITE(visual.name.overlayRainbowColor, config[XorStr(nameStr)][XorStr("overlayRainbowColor")]); \
	COLOR_JSON_READ(visual.name.overlayColor, config[XorStr(nameStr)][XorStr("overlayColor")]) \


#define SKIN_COLLECTION_JSON_READ(side, sideStr) \
		SKIN_JSON_READ(side, awpSkin, sideStr, "awpSkin") \
		SKIN_JSON_READ(side, ak47Skin, sideStr, "ak47Skin") \
		SKIN_JSON_READ(side, uspSkin, sideStr, "uspSkin") \
		SKIN_JSON_READ(side, deagleSkin, sideStr, "deagleSkin") \
		SKIN_JSON_READ(side, ssg08Skin, sideStr, "ssg08Skin") \
		SKIN_JSON_READ(side, scarSkin, sideStr, "scarSkin") \
		SKIN_JSON_READ(side, m4a1Skin, sideStr, "m4a1Skin") \
		SKIN_JSON_READ(side, famasSkin, sideStr, "famasSkin") \
		SKIN_JSON_READ(side, g3sg1Skin, sideStr, "g3sg1Skin") \
		SKIN_JSON_READ(side, m4a1s1Skin, sideStr, "m4a1s1Skin") \
		SKIN_JSON_READ(side, sg553Skin, sideStr, "sg553Skin") \
		SKIN_JSON_READ(side, augSkin, sideStr, "augSkin") \
		SKIN_JSON_READ(side, galilSkin, sideStr, "galilSkin") \
	    SKIN_JSON_READ(side, mac10Skin, sideStr, "mac10Skin") \
		SKIN_JSON_READ(side, mp5Skin, sideStr, "mp5Skin") \
		SKIN_JSON_READ(side, mp7Skin, sideStr, "mp7Skin") \
		SKIN_JSON_READ(side, mp9Skin, sideStr, "mp9Skin") \
		SKIN_JSON_READ(side, ppbizonSkin, sideStr, "ppbizonSkin") \
		SKIN_JSON_READ(side, p90Skin, sideStr, "p90Skin") \
		SKIN_JSON_READ(side, umpSkin, sideStr, "umpSkin") \
		SKIN_JSON_READ(side, cz75Skin, sideStr, "cz75Skin") \
		SKIN_JSON_READ(side, dualberttaSkin, sideStr, "dualberttaSkin") \
		SKIN_JSON_READ(side, fiveSevenSkin, sideStr, "fiveSevenSkin") \
		SKIN_JSON_READ(side, glockSkin, sideStr, "glockSkin") \
		SKIN_JSON_READ(side, p250Skin, sideStr, "p250Skin") \
		SKIN_JSON_READ(side, tec9Skin, sideStr, "tec9Skin") \
		SKIN_JSON_READ(side, revolverSkin, sideStr, "revolverSkin") \

namespace config {

	struct visuals {

		struct
		{
			bool showOnlyIsDead;
			bool showBox;
			bool showName;
			bool showSkeleton;
			bool showLife;
			bool showAmmo;
			bool showIcons;
			bool showIconsOnly;
			bool showWeaponName;
			bool showWeaponIcon;
			bool showPing;
			bool showMoney;
			bool showArmor;
			bool showHasDefuser;
			bool showPlanting;
			bool showDefusing;
			bool showReload;
			bool showBomb;
			bool showFlashed;
			bool showScopping;
			bool showCheating;
			bool showFakeDuck;
			bool showLegitAA;
			Color espColor;

		} enemyEsp;

		struct {
			bool enable;
			bool onlyIfDead;
			float bloom;
			Color glowColor;
		} glow;

		struct
		{
			bool showName;
			Color espColor;
		} weaponEsp;

		struct
		{
			bool enable;
			int id;
		} playerModel;

		struct
		{
			bool enable;
			int id;
		} teamMateModel;

		CHAMS_(enemyChamsVisible)
		CHAMS_(enemyChamsNotVisible)
		CHAMS_(enemyChamsBacktrack)
		CHAMS_(weaponWorldChams)
		CHAMS_(handChams)
		CHAMS_(gloveChams)
		CHAMS_(sleeveChams)
		CHAMS_(weaponChams)

		struct
		{
			bool enable;
			float min;

		} spreadCircle;

		struct
		{
			bool showFlashDuration;

		} indicators;

		struct
		{
			bool enable;
			SKIN_COLLECTION(ctSkins)
			SKIN_COLLECTION(tSkins)
		} skins;

		struct
		{
			bool enable;

			struct
			{
				int index;
				bool random;
				bool through_mic;
			} hitmarkerSound;

			struct
			{
				int index;
				bool random;
				bool through_mic;
			} headShootSound;


			struct
			{
				int index;
				bool random;
				bool through_mic;
			} roundStartSound;

			struct
			{
				int index;
				bool random;
				bool through_mic;
			} roundEndLostSound;

			struct
			{
				int index;
				bool random;
				bool through_mic;
			} roundEndWonSound;

			struct
			{
				int index;
				bool random;
				bool through_mic;
			} bombPlantedSound;

			struct
			{
				int index;
				bool random;
				bool through_mic;
			} voteStartedSound;

			struct
			{
				int index;
				bool random;
				bool through_mic;
			} voteChangedSound;

			struct
			{
				int index;
				bool random;
				bool through_mic;
			} votePassedSound;

			struct
			{
				int index;
				bool random;
				bool through_mic;
			} voteFailledSound;

		} sounds;

		bool showSpectators;
		bool showGrenadePred;
		bool showRadar;

		struct
		{
			bool enable;
			Color worldColor;
			Color propsColor;
		} world;

		struct
		{
			bool enable;
			int sky;
			Color skyColor;
		} sky;
	};

	struct cheat {

		bool fastStop;
		bool silentWalk;
		bool optimization;
		bool infinitDuck;

		bool volumeEsp;

		bool backtrack;
		float backtrackVisibility;
		float backtrackTime;
	};

	extern visuals visual;

	extern cheat cheats;

	void init();

	void openVisualConfig(std::string name);

	void saveVisualConfig(std::string name);

	void openCheatConfig(std::string name);

	void saveCheatConfig(std::string name);
}

#endif
```

`Lumina/Lumina/common/events.cpp`:

```cpp
#include "events.h"

#include "../sdk/interfaces.h"
#include "../features/misc/voice.h"
#include "../features/misc/misc.h"
#include "common.h"

namespace events {

	listener* eventListener = NULL;

	std::map<hash32_t, eventInfo*> eventWorkers;

	void init() {

		eventWorkers = {};

		eventListener = new listener();

#ifdef _DEBUG
		common::ps(XorStr("events::init : done"));
#endif
	}

	void shutdown() {

		interfaces::gameEventManager->RemoveListener(eventListener);
		
		for (auto& eventInfoPointer : eventWorkers)
			free(eventInfoPointer.second);

		eventWorkers.clear();

		delete eventListener;

#ifdef _DEBUG
		common::ps(XorStr("events::shutdown : done"));
#endif
	}

#define ADD_EVENT(str,pointer,side,var) \
	eventInfo* var = (eventInfo*)malloc(sizeof(eventInfo)); \
	var->name = XorStr(str); \
	var->hash = HASH(str); \
	var->clientside = side; \
	var->callback = (void*)pointer; \
	eventWorkers[var->hash] = var; \

	listener::listener()
	{
		VMProtectBeginMutation("listener::listener");

		ADD_EVENT("player_hurt", misc::hitmarkerSound, false, tmp0)
		//ADD_EVENT("player_spawned", misc::fixSkin, tmp1)
		ADD_EVENT("round_end", misc::roundSounds, false, tmp2)
		ADD_EVENT("round_start", misc::roundSounds, false, tmp3)
		ADD_EVENT("player_death", misc::headShoot, false, tmp4)
		ADD_EVENT("vote_cast", misc::voteRealer, false, tmp5)
		ADD_EVENT("vote_started", misc::voteRealer, true, tmp6)
		ADD_EVENT("vote_failed", misc::voteRealer, true, tmp7)
		ADD_EVENT("vote_passed", misc::voteRealer, true, tmp8)

		for (auto& eventInfoPointer : eventWorkers)
			interfaces::gameEventManager->AddListener(this, eventInfoPointer.second->name, eventInfoPointer.second->clientside);

#ifdef _DEBUG
		common::ps(XorStr("listener::listener : done"));
#endif

		VMProtectEnd();
	};

	void listener::FireGameEvent(IGameEvent* event) {

		VMProtectBeginMutation("listener::FireGameEvent");

		if (event) {

			hash32_t eventNameHash = FNV1a::get(event->GetName());

			if (eventWorkers.count(eventNameHash)){
				auto currentEventInfo = eventWorkers.at(eventNameHash);
				((eventWorker)currentEventInfo->callback)(event, currentEventInfo);
			}
		}

		VMProtectEnd();
	}
}

```

`Lumina/Lumina/common/events.h`:

```h
#ifndef events_h

#define events_h

#include "../sdk/interfaces/IGameEventManager.h"
#include "includes.h"

struct eventInfo {
	char* name;
	uint32_t hash;
	bool clientside;
	void* callback;
};

using eventWorker = void(*)(IGameEvent*, eventInfo*);

// from fatality.win source code

namespace events {

	void init();
	void shutdown();

	class listener : public IGameEventListener2
	{
	public:

		listener();

		virtual void	FireGameEvent(IGameEvent* event);

		int				GetEventDebugID() override { return 0x2A; };
	};
}

#endif // !events_h
```

`Lumina/Lumina/common/game.cpp`:

```cpp
#include "game.h"

#include "../sdk/interfaces.h"
#include "common.h"

namespace game {

	Entity* getLocalPlayer() {

		VMProtectBeginMutation("game::getLocalPlayer");

		Entity* entity = (Entity*)interfaces::clientEntityList->GetClientEntity(interfaces::engineClient->GetLocalPlayer());

		VMProtectEnd();

		return entity;
	}

	bool isEnvironmentValid() {

		VMProtectBeginMutation("game::isEnvironmentValid");

		bool result = interfaces::engineClient->IsConnected() && interfaces::engineClient->IsInGame();

		VMProtectEnd();

		return result;
	}

	ConVar* getConvarNullCallback(const char* name) {

		VMProtectBeginMutation("game::getConvarNullCallback");

		ConVar* convar = (ConVar*)interfaces::console->get_convar(name);

		*(int*)((DWORD)&convar->fnChangeCallbacks + 0xC) = NULL;

		VMProtectEnd();

		return convar;
	}
}

```

`Lumina/Lumina/common/game.h`:

```h
#ifndef game_h

#define game_h

#include "../sdk/structs/Entity.h"
#include "../sdk/structs/mystructs.h"
#include "../sdk/interfaces.h"
#include <vector>

namespace game {

	extern std::vector<player_t*> players;

	extern player_t* localPlayer;

	void init();

	void updatePlayerCollection();

	player_t* getPlayerFromHandle(uintptr_t pointer);

	Entity* getLocalPlayer();

	ConVar* getConvarNullCallback(const char* name);

	bool isEnvironmentValid();
}

#endif // !game_h
```

`Lumina/Lumina/common/includes.h`:

```h
#ifndef includes_h

//#define FULL_DEBUG

#ifdef NDEBUG
//#pragma optimize("", off)
#define MUTATION
#endif

#include <Windows.h>
#include <string>
#include <vector>
#include <math.h>
#include <time.h>
#include <stdio.h>
#include <stdlib.h>
#include <assert.h>
#include <stdexcept>
#include <cstdint>
#include <xstring>
#include <cstring>
#include <map>
#include <deque>
#include <d3dx9.h>
#include <corecrt_math.h>
#include <unordered_map>
#include <filesystem>
#include <algorithm>

#ifdef MUTATION
#include <VMProtectSDK.h>
#define StringHeavy(s) (VMProtectDecryptStringA(s))
#else
// ;)
// find yourself why I did that
#include <VMProtectSDK.h>
#define StringHeavy(s) (VMProtectDecryptStringA(s))
//#define StringHeavy(s) (s)
//#define VMProtectBeginMutation(NAME) const char* FUNCTION_NAME = NAME
//#define VMProtectEnd() char* FUNCTION_NAME_END
#endif

#include "vfunc.h"

#include "../sdk/defines.h"

#include "../security/hash.h"

#include "../sdk/math/math.h"
#include "../sdk/math/Color.h"
#include "../sdk/math/CUtlVector.h"
#include "../sdk/math/Vector.h"
#include "../sdk/math/matrix3x4_t.h"
#include "../sdk/math/QAngle.h"
#include "../sdk/math/Vector2D.h"
#include "../sdk/math/Vector4D.h"
#include "../sdk/math/VMatrix.h"

#include "../sdk/structs/structs.h"
#include "../sdk/structs/misc.h"
#include "../sdk/structs/mystructs.h"

#include "../sdk/structs/datamap.h"

#include "../sdk/structs/IMaterial.h"

#include "../sdk/structs/CBoneChache.h"
#include "../sdk/structs/ClientClass.h"
#include "../sdk/structs/CNetChannel.h"
#include "../sdk/structs/IClientEntity.h"
#include "../sdk/structs/ConVar.h"
#include "../sdk/structs/INetChannelInfo.h"

#include "../sdk/interfaces/IBaseClientDll.h"
#include "../sdk/interfaces/ISurface.h"
#include "../sdk/interfaces/IVPanel.h"
#include "../sdk/interfaces/IMaterialSystem.h"
#include "../sdk/interfaces/IEngineClient.h"
#include "../sdk/interfaces/IGlobalVarsBase.h"
#include "../sdk/interfaces/IClientEntityList.h"
#include "../sdk/interfaces/IVDebugOverlay.h"
#include "../sdk/interfaces/IVModelInfo.h"
#include "../sdk/interfaces/IVModelRender.h"
#include "../sdk/interfaces/IVRenderView.h"
#include "../sdk/interfaces/CSPlayerResource.h"
#include "../sdk/interfaces/ICVar.h"
#include "../sdk/interfaces/IGameEventManager.h"
#include "../sdk/interfaces/ILocalize.h"
#include "../sdk/interfaces/CGlowObjectManager.h"
#include "../sdk/interfaces/IConsole.h"
#include "../sdk/interfaces/ISteamGameServer.h"
#include "../sdk/interfaces/IStudioRender.h"

#include "../sdk/netvars.h"

#include "../sdk/structs/Entity.h"

#include "utils.h"

#include "../sdk/offsets.h"

#include "../security/instr.h"
#include "../security/lazy.hpp"
#include "../security/xorstr.hpp"
#include "../security/eraser.hpp"

#include "../hook/hook.h"

#include "game.h"

#include "../hook/functions/paintTraverse.h"
#include "../hook/functions/lockCursor.h"
#include "../hook/functions/shutdown.h"
#include "../hook/functions/drawModelExecute.h"
#include "../hook/functions/frameStageNotify.h"
#include "../hook/functions/serverSideChecks.h"
#include "../hook/functions/doPostScreenEffects.h"
#include "../hook/functions/fireEventClientSide.h"
#include "../hook/functions/createMove.h"
#include "../hook/functions/shouldDrawFog.h"
#include "../hook/functions/levelInitPostEntity.h"

#include "config.h"

#endif // !includes_h
```

`Lumina/Lumina/common/input.cpp`:

```cpp
#include "input.h"
#include "../ui/menu.h"
#include "common.h"
#include "../features/misc/voice.h"

namespace input
{
	HWND m_window = NULL;
	WNDPROC m_original_wndproc = nullptr;

	char m_last_char;
	std::array<key_info_t, 256> m_key_info{};

	mouse_info_t m_mouse_info;

	void init()
	{
		VMProtectBeginMutation("input::init");

		/// Input was already initialized ?
		if (m_window)
			return;

		m_window = FindWindowA(XorStr("Valve001"), NULL);

		if (!m_window)
		{
#ifdef _DEBUG
			common::ps(XorStr("input::init : failed to find input window"));
#endif
			common::exit();
		}

		m_original_wndproc = reinterpret_cast<WNDPROC>(SetWindowLongW(m_window, GWLP_WNDPROC, reinterpret_cast<LONG_PTR>(hook)));
		
		if (!m_original_wndproc)
		{
#ifdef _DEBUG
			common::ps(XorStr("input::init : failed to set new WndProc"));
#endif
			common::exit();
		}
	
#ifdef _DEBUG
		common::ps(XorStr("input::init : done"));
#endif

		VMProtectEnd();
	}

	void undo()
	{
		VMProtectBeginMutation("input::undo");

		if (m_original_wndproc)
			SetWindowLongW(m_window, GWLP_WNDPROC, reinterpret_cast<LONG_PTR>(m_original_wndproc));

		m_original_wndproc = NULL;

		VMProtectEnd();
	}

	bool handle_mouse(const UINT msg)
	{
		VMProtectBeginMutation("input::handle_mouse");

		switch (msg)
		{
			/// Left mouse button
		case WM_LBUTTONDOWN:
		case WM_LBUTTONDBLCLK:
			if (m_mouse_info.m_state == e_state::IDLE)
				m_mouse_info.m_state = e_state::PRESSED;
			return true;
		case WM_LBUTTONUP:
			m_mouse_info.m_state = e_state::IDLE;
			return true;

			/// Right mouse button
		case WM_RBUTTONDOWN:
		case WM_RBUTTONDBLCLK:
			if (m_mouse_info.m_state_right == e_state::IDLE)
				m_mouse_info.m_state_right = e_state::PRESSED;
			return true;
		case WM_RBUTTONUP:
			m_mouse_info.m_state_right = e_state::IDLE;
			return true;
		default:
			break;
		}

		/// Mouse has been pressed for more than 1 input tick
		if (m_mouse_info.m_state == e_state::PRESSED)
			m_mouse_info.m_state = e_state::HELD;

		if (m_mouse_info.m_state_right == e_state::PRESSED)
			m_mouse_info.m_state_right = e_state::HELD;

		VMProtectEnd();

		return msg == WM_MOUSEMOVE || msg == WM_NCMOUSEMOVE;
	}

	bool handle_keyboard(const UINT msg, const WPARAM param)
	{
		auto changed_state = false;

		VMProtectBeginMutation("input::handle_keyboard");

		for (auto i = 0; i < 256; i++)
		{
			if (m_key_info.at(i).m_state == e_state::PRESSED)
			{
				m_key_info.at(i).m_state = e_state::HELD;
				changed_state = true;
			}
		}

		switch (msg)
		{
			/// Input character
		case WM_CHAR:
			if (param > 0 && param < 0x10000)
				m_last_char = static_cast<char>(param);
			return true;

			/// "Normal" keys
		case WM_KEYDOWN:
			if (param >= 0 && param < 256)
				m_key_info.at(param).m_state = e_state::PRESSED;
			return true;
		case WM_KEYUP:
			if (param >= 0 && param < 256)
			{
				m_key_info.at(param).m_state = e_state::IDLE;
			}
			return true;

			/// Side mouse buttons
		case WM_XBUTTONDOWN:
		case WM_XBUTTONDBLCLK:
			if (GET_XBUTTON_WPARAM(param) & XBUTTON1)
				m_key_info.at(VK_XBUTTON1).m_state = e_state::PRESSED;
			else if (GET_XBUTTON_WPARAM(param) & XBUTTON2)
				m_key_info.at(VK_XBUTTON2).m_state = e_state::PRESSED;
			return true;
		case WM_XBUTTONUP:
			if (GET_XBUTTON_WPARAM(param) & XBUTTON1)
				m_key_info.at(VK_XBUTTON1).m_state = e_state::IDLE;
			else if (GET_XBUTTON_WPARAM(param) & XBUTTON2)
				m_key_info.at(VK_XBUTTON2).m_state = e_state::IDLE;
			return true;

			/// System keys
		case WM_SYSKEYDOWN:
			if (param >= 0 && param < 256)
				m_key_info.at(param).m_state = e_state::PRESSED;
			return true;
		case WM_SYSKEYUP:
			if (param >= 0 && param < 256)
				m_key_info.at(param).m_state = e_state::IDLE;
			return true;

			/// Middle button
		case WM_MBUTTONDOWN:
		case WM_MBUTTONDBLCLK:
			m_key_info.at(VK_MBUTTON).m_state = e_state::PRESSED;
			return true;
		case WM_MBUTTONUP:
			m_key_info.at(VK_MBUTTON).m_state = e_state::IDLE;
			return true;

			/// Left mouse button
		case WM_LBUTTONDOWN:
		case WM_LBUTTONDBLCLK:
			m_key_info.at(VK_LBUTTON).m_state = e_state::PRESSED;
			return true;
		case WM_LBUTTONUP:
			m_key_info.at(VK_LBUTTON).m_state = e_state::IDLE;
			return true;

			/// Right mouse button
		case WM_RBUTTONDOWN:
		case WM_RBUTTONDBLCLK:
			m_key_info.at(VK_RBUTTON).m_state = e_state::PRESSED;
			return true;
		case WM_RBUTTONUP:
			m_key_info.at(VK_RBUTTON).m_state = e_state::IDLE;
			return true;

			/// Mouse wheel
		case WM_MOUSEWHEEL:
			m_mouse_info.m_scroll = GET_WHEEL_DELTA_WPARAM(param) / WHEEL_DELTA;
			return true;
		default:;
		}

		VMProtectEnd();

		return changed_state;
	}

	/// Mouse info
	void update_mouse()
	{
		VMProtectBeginMutation("input::update_mouse");

		POINT p;
		if (!GetCursorPos(&p))
			return;

		ScreenToClient(m_window, &p);

		m_mouse_info.m_pos = {
			static_cast<float>(p.x),
			static_cast<float>(p.y) };

		VMProtectEnd();
	}

	mouse_info_t& get_mouse()
	{
		return m_mouse_info;
	}

	void reset_mouse()
	{
		VMProtectBeginMutation("input::reset_mouse");

		m_mouse_info.m_state = e_state::IDLE;
		m_mouse_info.m_state_right = e_state::IDLE;
		m_mouse_info.m_scroll = 0;

		VMProtectEnd();
	}

	bool mouse_in_bounds(const Vector2D& pos, const Vector2D& size)
	{
		const auto mouse_pos = m_mouse_info.m_pos;

		return mouse_pos.x >= pos.x && mouse_pos.x <= pos.x + size.x
			&& mouse_pos.y >= pos.y && mouse_pos.y <= pos.y + size.y;
	}

	bool mouse_in_bounds(const Vector4D& bounds)
	{
		return mouse_in_bounds(bounds.get_pos(), bounds.get_size());
	}

	/// Key info
	key_info_t& get_key_info(const int key)
	{
		return m_key_info.at(key);
	}

	std::string get_key_name(const int key)
	{
		return "";
	}

	char get_last_char()
	{
		return m_last_char;
	}

	void clear_char()
	{
		m_last_char = '\0';
	}

	unsigned long WINAPI hook(HWND hwnd, UINT msg, WPARAM wparam, LPARAM lparam)
	{
		VMProtectBeginMutation("input::hook");

		const auto handled_mouse = handle_mouse(msg);
		const auto handled_keyboard = handle_keyboard(msg, wparam);

		menu::toggle();

		if (menu::visible && (handled_mouse || handled_keyboard))
		{
			update_mouse();

			get_mouse().reset_scroll();

			return false;
		}

		VMProtectEnd();

		const auto ret = CallWindowProc(m_original_wndproc, hwnd, msg, wparam, lparam);

		return ret && !handled_keyboard && !handled_mouse;
	}
}
```

`Lumina/Lumina/common/input.h`:

```h
#ifndef input_h

#define input_h

#include "../common/includes.h"
#include <array>

// from : https://github.com/DucaRii/csgo_modest

namespace input
{
	/// <summary>
	/// Different states used for mouse/key info
	/// </summary>
	enum e_state
	{
		IDLE,
		PRESSED,
		HELD
	};

	struct mouse_info_t
	{
		/// <summary>
		/// Constructs mouse info with default values
		/// </summary>
		mouse_info_t() :
			m_state(e_state::IDLE),
			m_state_right(e_state::IDLE),
			m_scroll(0),
			m_pos(Vector2D())
		{}

		/// <summary>
		/// Reset scroll amount
		/// </summary>
		void reset_scroll()
		{
			m_scroll = 0;
		}

		/// <summary>
		/// State of of the left mouse button ( IDLE, PRESSED, HELD )
		/// </summary>
		e_state m_state;

		/// <summary>
		/// State of of the right mouse button ( IDLE, PRESSED, HELD )
		/// </summary>
		e_state m_state_right;

		/// <summary>
		/// Scroll amount. Negative means scrolling up and the other way around
		/// </summary>
		int m_scroll;

		/// <summary>
		/// Current mouse position
		/// </summary>
		Vector2D m_pos;
	};

	struct key_info_t
	{
		/// <summary>
		/// State of key ( IDLE, PRESSED, HELD )
		/// </summary>
		e_state m_state;

		/// <summary>
		/// Checks if key is pressed
		/// </summary>
		bool is_pressed()
		{
			bool pressed = m_state == PRESSED;

			if (pressed)
				m_state = HELD;

			return pressed;
		}

		/// <summary>
		/// Checks if key is held
		/// </summary>
		bool is_held()
		{
			return m_state == HELD;
		}
	};

	/// <summary>
	/// Initializes input handler with given window class
	/// </summary>
	/// <returns>Returns true if it was successful</returns>
	void init();

	/// <summary>
	/// Restores original WndProc
	/// </summary>
	void undo();

	/// Message handling

	/// <summary>
	/// Handles mouse input message and fills the local mouse info
	/// </summary>
	/// <param name="msg">Mouse message emitted from WndProc</param>
	/// <returns>Returns true if mouse input was handled</returns>
	bool handle_mouse(const UINT msg);

	/// <summary>
	/// Handles keyboard input message and fills the right key info
	/// </summary>
	/// <param name="msg">Key message emitted from WndProc</param>
	/// <param name="param">Additional message info dependent on the msg parameter</param>
	/// <returns>Returns true if keyboard input was handled</returns>
	bool handle_keyboard(const UINT msg, const WPARAM param);

	/// <summary>
	/// All Windows input goes through this function so it can just be yoinked from there
	/// </summary>
	/// <param name="hwnd">A handle to the window</param>
	/// <param name="msg">The message received</param>
	/// <param name="wparam">Additional message info dependent on the msg parameter</param>
	/// <param name="lparam">Additional message info dependent on the msg parameter</param>
	/// <returns>Result of the message processing and depends on the message sent</returns>
	unsigned long WINAPI hook(HWND hwnd, UINT msg, WPARAM wparam, LPARAM lparam);

	/// Mouse info

	/// <summary>
	/// Updates mouse position
	/// </summary>
	void update_mouse();

	/// <summary>
	/// Gets mouse info
	/// </summary>
	mouse_info_t& get_mouse();

	/// <summary>
	/// Reset mouse key states + scroll amount
	/// </summary>
	void reset_mouse();

	/// <summary>
	/// Checks if current mouse position is within specified bounds
	/// </summary>
	/// <param name="pos">Bounds start</param>
	/// <param name="size">Bounds size</param>
	/// <returns>Returns true if mouse position is within specified bounds</returns>
	bool mouse_in_bounds(const Vector2D& pos, const Vector2D& size);

	/// <summary>
	/// Checks if current mouse position is within specified bounds
	/// </summary>
	/// <param name="bounds">Bounds</param>
	/// <returns>Returns true if mouse position is within specified bounds</returns>
	bool mouse_in_bounds(const Vector4D& bounds);

	/// Key info

	/// <summary>
	/// Returns key info of given key
	/// </summary>
	/// <param name="key">Virtual key code of wished key info</param>
	/// <returns>Returns key info object</returns>
	key_info_t& get_key_info(const int key);

	/// <summary>
	/// Returns key name of given key
	/// </summary>
	/// <param name="key">Virtual key code of wished key name</param>
	/// <returns>Returns key name</returns>
	std::string get_key_name(const int key);

	/// <summary>
	/// Returns last char input by keyboard
	/// </summary>
	/// <returns>Last char entered by keyboard</returns>
	char get_last_char();

	/// <summary>
	/// Clears last char received
	/// </summary>
	void clear_char();
}

#endif 
```

`Lumina/Lumina/common/json/json-forwards.h`:

```h
/// Json-cpp amalgamated forward header (http://jsoncpp.sourceforge.net/).
/// It is intended to be used with #include "json/json-forwards.h"
/// This header provides forward declaration for all JsonCpp types.

// //////////////////////////////////////////////////////////////////////
// Beginning of content of file: LICENSE
// //////////////////////////////////////////////////////////////////////

/*
The JsonCpp library's source code, including accompanying documentation,
tests and demonstration applications, are licensed under the following
conditions...

Baptiste Lepilleur and The JsonCpp Authors explicitly disclaim copyright in all
jurisdictions which recognize such a disclaimer. In such jurisdictions,
this software is released into the Public Domain.

In jurisdictions which do not recognize Public Domain property (e.g. Germany as of
2010), this software is Copyright (c) 2007-2010 by Baptiste Lepilleur and
The JsonCpp Authors, and is released under the terms of the MIT License (see below).

In jurisdictions which recognize Public Domain property, the user of this
software may choose to accept it either as 1) Public Domain, 2) under the
conditions of the MIT License (see below), or 3) under the terms of dual
Public Domain/MIT License conditions described here, as they choose.

The MIT License is about as close to Public Domain as a license can get, and is
described in clear, concise terms at:

   http://en.wikipedia.org/wiki/MIT_License

The full text of the MIT License follows:

========================================================================
Copyright (c) 2007-2010 Baptiste Lepilleur and The JsonCpp Authors

Permission is hereby granted, free of charge, to any person
obtaining a copy of this software and associated documentation
files (the "Software"), to deal in the Software without
restriction, including without limitation the rights to use, copy,
modify, merge, publish, distribute, sublicense, and/or sell copies
of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be
included in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
========================================================================
(END LICENSE TEXT)

The MIT license is compatible with both the GPL and commercial
software, affording one all of the rights of Public Domain with the
minor nuisance of being required to keep the above copyright notice
and license text in the source code. Note also that by accepting the
Public Domain "license" you can re-license your copy using whatever
license you like.

*/

// //////////////////////////////////////////////////////////////////////
// End of content of file: LICENSE
// //////////////////////////////////////////////////////////////////////





#ifndef JSON_FORWARD_AMALGAMATED_H_INCLUDED
# define JSON_FORWARD_AMALGAMATED_H_INCLUDED
/// If defined, indicates that the source file is amalgamated
/// to prevent private header inclusion.
#define JSON_IS_AMALGAMATION

// //////////////////////////////////////////////////////////////////////
// Beginning of content of file: include/json/config.h
// //////////////////////////////////////////////////////////////////////

// Copyright 2007-2010 Baptiste Lepilleur and The JsonCpp Authors
// Distributed under MIT license, or public domain if desired and
// recognized in your jurisdiction.
// See file LICENSE for detail or copy at http://jsoncpp.sourceforge.net/LICENSE

#ifndef JSON_CONFIG_H_INCLUDED
#define JSON_CONFIG_H_INCLUDED
#include <cstddef>
#include <cstdint>
#include <istream>
#include <memory>
#include <ostream>
#include <sstream>
#include <string>
#include <type_traits>

/// If defined, indicates that json library is embedded in CppTL library.
//# define JSON_IN_CPPTL 1

/// If defined, indicates that json may leverage CppTL library
//#  define JSON_USE_CPPTL 1
/// If defined, indicates that cpptl vector based map should be used instead of
/// std::map
/// as Value container.
//#  define JSON_USE_CPPTL_SMALLMAP 1

// If non-zero, the library uses exceptions to report bad input instead of C
// assertion macros. The default is to use exceptions.
#ifndef JSON_USE_EXCEPTION
#define JSON_USE_EXCEPTION 1
#endif

// Temporary, tracked for removal with issue #982.
#ifndef JSON_USE_NULLREF
#define JSON_USE_NULLREF 1
#endif

/// If defined, indicates that the source file is amalgamated
/// to prevent private header inclusion.
/// Remarks: it is automatically defined in the generated amalgamated header.
// #define JSON_IS_AMALGAMATION

#ifdef JSON_IN_CPPTL
#include <cpptl/config.h>
#ifndef JSON_USE_CPPTL
#define JSON_USE_CPPTL 1
#endif
#endif

#ifdef JSON_IN_CPPTL
#define JSON_API CPPTL_API
#elif defined(JSON_DLL_BUILD)
#if defined(_MSC_VER) || defined(__MINGW32__)
#define JSON_API __declspec(dllexport)
#define JSONCPP_DISABLE_DLL_INTERFACE_WARNING
#elif defined(__GNUC__) || defined(__clang__)
#define JSON_API __attribute__((visibility("default")))
#endif // if defined(_MSC_VER)
#elif defined(JSON_DLL)
#if defined(_MSC_VER) || defined(__MINGW32__)
#define JSON_API __declspec(dllimport)
#define JSONCPP_DISABLE_DLL_INTERFACE_WARNING
#endif // if defined(_MSC_VER)
#endif // ifdef JSON_IN_CPPTL
#if !defined(JSON_API)
#define JSON_API
#endif

#if defined(_MSC_VER) && _MSC_VER < 1800
#error                                                                         \
    "ERROR:  Visual Studio 12 (2013) with _MSC_VER=1800 is the oldest supported compiler with sufficient C++11 capabilities"
#endif

#if defined(_MSC_VER) && _MSC_VER < 1900
// As recommended at
// https://stackoverflow.com/questions/2915672/snprintf-and-visual-studio-2010
extern JSON_API int msvc_pre1900_c99_snprintf(char* outBuf, size_t size,
    const char* format, ...);
#define jsoncpp_snprintf msvc_pre1900_c99_snprintf
#else
#define jsoncpp_snprintf std::snprintf
#endif

// If JSON_NO_INT64 is defined, then Json only support C++ "int" type for
// integer
// Storages, and 64 bits integer support is disabled.
// #define JSON_NO_INT64 1

// JSONCPP_OVERRIDE is maintained for backwards compatibility of external tools.
// C++11 should be used directly in JSONCPP.
#define JSONCPP_OVERRIDE override

#if __cplusplus >= 201103L
#define JSONCPP_NOEXCEPT noexcept
#define JSONCPP_OP_EXPLICIT explicit
#elif defined(_MSC_VER) && _MSC_VER < 1900
#define JSONCPP_NOEXCEPT throw()
#define JSONCPP_OP_EXPLICIT explicit
#elif defined(_MSC_VER) && _MSC_VER >= 1900
#define JSONCPP_NOEXCEPT noexcept
#define JSONCPP_OP_EXPLICIT explicit
#else
#define JSONCPP_NOEXCEPT throw()
#define JSONCPP_OP_EXPLICIT
#endif

#ifdef __clang__
#if __has_extension(attribute_deprecated_with_message)
#define JSONCPP_DEPRECATED(message) __attribute__((deprecated(message)))
#endif
#elif defined(__GNUC__) // not clang (gcc comes later since clang emulates gcc)
#if (__GNUC__ > 4 || (__GNUC__ == 4 && __GNUC_MINOR__ >= 5))
#define JSONCPP_DEPRECATED(message) __attribute__((deprecated(message)))
#elif (__GNUC__ > 3 || (__GNUC__ == 3 && __GNUC_MINOR__ >= 1))
#define JSONCPP_DEPRECATED(message) __attribute__((__deprecated__))
#endif                  // GNUC version
#elif defined(_MSC_VER) // MSVC (after clang because clang on Windows emulates
                        // MSVC)
#define JSONCPP_DEPRECATED(message) __declspec(deprecated(message))
#endif // __clang__ || __GNUC__ || _MSC_VER

#if !defined(JSONCPP_DEPRECATED)
#define JSONCPP_DEPRECATED(message)
#endif // if !defined(JSONCPP_DEPRECATED)

#if defined(__clang__) || (defined(__GNUC__) && (__GNUC__ >= 6))
#define JSON_USE_INT64_DOUBLE_CONVERSION 1
#endif

#if !defined(JSON_IS_AMALGAMATION)

#include "allocator.h"
#include "version.h"

#endif // if !defined(JSON_IS_AMALGAMATION)

namespace Json {
    typedef int Int;
    typedef unsigned int UInt;
#if defined(JSON_NO_INT64)
    typedef int LargestInt;
    typedef unsigned int LargestUInt;
#undef JSON_HAS_INT64
#else                 // if defined(JSON_NO_INT64)
    // For Microsoft Visual use specific types as long long is not supported
#if defined(_MSC_VER) // Microsoft Visual Studio
    typedef __int64 Int64;
    typedef unsigned __int64 UInt64;
#else                 // if defined(_MSC_VER) // Other platforms, use long long
    typedef int64_t Int64;
    typedef uint64_t UInt64;
#endif                // if defined(_MSC_VER)
    typedef Int64 LargestInt;
    typedef UInt64 LargestUInt;
#define JSON_HAS_INT64
#endif // if defined(JSON_NO_INT64)

    template <typename T>
    using Allocator =
        typename std::conditional<JSONCPP_USING_SECURE_MEMORY, SecureAllocator<T>,
        std::allocator<T>>::type;
    using String = std::basic_string<char, std::char_traits<char>, Allocator<char>>;
    using IStringStream =
        std::basic_istringstream<String::value_type, String::traits_type,
        String::allocator_type>;
    using OStringStream =
        std::basic_ostringstream<String::value_type, String::traits_type,
        String::allocator_type>;
    using IStream = std::istream;
    using OStream = std::ostream;
} // namespace Json

// Legacy names (formerly macros).
using JSONCPP_STRING = Json::String;
using JSONCPP_ISTRINGSTREAM = Json::IStringStream;
using JSONCPP_OSTRINGSTREAM = Json::OStringStream;
using JSONCPP_ISTREAM = Json::IStream;
using JSONCPP_OSTREAM = Json::OStream;

#endif // JSON_CONFIG_H_INCLUDED

// //////////////////////////////////////////////////////////////////////
// End of content of file: include/json/config.h
// //////////////////////////////////////////////////////////////////////






// //////////////////////////////////////////////////////////////////////
// Beginning of content of file: include/json/forwards.h
// //////////////////////////////////////////////////////////////////////

// Copyright 2007-2010 Baptiste Lepilleur and The JsonCpp Authors
// Distributed under MIT license, or public domain if desired and
// recognized in your jurisdiction.
// See file LICENSE for detail or copy at http://jsoncpp.sourceforge.net/LICENSE

#ifndef JSON_FORWARDS_H_INCLUDED
#define JSON_FORWARDS_H_INCLUDED

#if !defined(JSON_IS_AMALGAMATION)
#include "config.h"
#endif // if !defined(JSON_IS_AMALGAMATION)

namespace Json {

    // writer.h
    class StreamWriter;
    class StreamWriterBuilder;
    class Writer;
    class FastWriter;
    class StyledWriter;
    class StyledStreamWriter;

    // reader.h
    class Reader;
    class CharReader;
    class CharReaderBuilder;

    // json_features.h
    class Features;

    // value.h
    typedef unsigned int ArrayIndex;
    class StaticString;
    class Path;
    class PathArgument;
    class Value;
    class ValueIteratorBase;
    class ValueIterator;
    class ValueConstIterator;

} // namespace Json

#endif // JSON_FORWARDS_H_INCLUDED

// //////////////////////////////////////////////////////////////////////
// End of content of file: include/json/forwards.h
// //////////////////////////////////////////////////////////////////////





#endif //ifndef JSON_FORWARD_AMALGAMATED_H_INCLUDED

```

`Lumina/Lumina/common/json/json.cpp`:

```cpp
/// Json-cpp amalgamated source (http://jsoncpp.sourceforge.net/).
/// It is intended to be used with #include "json/json.h"

// //////////////////////////////////////////////////////////////////////
// Beginning of content of file: LICENSE
// //////////////////////////////////////////////////////////////////////

/*
The JsonCpp library's source code, including accompanying documentation,
tests and demonstration applications, are licensed under the following
conditions...

Baptiste Lepilleur and The JsonCpp Authors explicitly disclaim copyright in all
jurisdictions which recognize such a disclaimer. In such jurisdictions,
this software is released into the Public Domain.

In jurisdictions which do not recognize Public Domain property (e.g. Germany as of
2010), this software is Copyright (c) 2007-2010 by Baptiste Lepilleur and
The JsonCpp Authors, and is released under the terms of the MIT License (see below).

In jurisdictions which recognize Public Domain property, the user of this
software may choose to accept it either as 1) Public Domain, 2) under the
conditions of the MIT License (see below), or 3) under the terms of dual
Public Domain/MIT License conditions described here, as they choose.

The MIT License is about as close to Public Domain as a license can get, and is
described in clear, concise terms at:

   http://en.wikipedia.org/wiki/MIT_License

The full text of the MIT License follows:

========================================================================
Copyright (c) 2007-2010 Baptiste Lepilleur and The JsonCpp Authors

Permission is hereby granted, free of charge, to any person
obtaining a copy of this software and associated documentation
files (the "Software"), to deal in the Software without
restriction, including without limitation the rights to use, copy,
modify, merge, publish, distribute, sublicense, and/or sell copies
of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be
included in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
========================================================================
(END LICENSE TEXT)

The MIT license is compatible with both the GPL and commercial
software, affording one all of the rights of Public Domain with the
minor nuisance of being required to keep the above copyright notice
and license text in the source code. Note also that by accepting the
Public Domain "license" you can re-license your copy using whatever
license you like.

*/

// //////////////////////////////////////////////////////////////////////
// End of content of file: LICENSE
// //////////////////////////////////////////////////////////////////////






#include "json.h"

#ifndef JSON_IS_AMALGAMATION
#error "Compile with -I PATH_TO_JSON_DIRECTORY"
#endif


// //////////////////////////////////////////////////////////////////////
// Beginning of content of file: src/lib_json/json_tool.h
// //////////////////////////////////////////////////////////////////////

// Copyright 2007-2010 Baptiste Lepilleur and The JsonCpp Authors
// Distributed under MIT license, or public domain if desired and
// recognized in your jurisdiction.
// See file LICENSE for detail or copy at http://jsoncpp.sourceforge.net/LICENSE

#ifndef LIB_JSONCPP_JSON_TOOL_H_INCLUDED
#define LIB_JSONCPP_JSON_TOOL_H_INCLUDED

#if !defined(JSON_IS_AMALGAMATION)
#include <json/config.h>
#endif

// Also support old flag NO_LOCALE_SUPPORT
#ifdef NO_LOCALE_SUPPORT
#define JSONCPP_NO_LOCALE_SUPPORT
#endif

#ifndef JSONCPP_NO_LOCALE_SUPPORT
#include <clocale>
#endif

/* This header provides common string manipulation support, such as UTF-8,
 * portable conversion from/to string...
 *
 * It is an internal header that must not be exposed.
 */

namespace Json {
    static inline char getDecimalPoint() {
#ifdef JSONCPP_NO_LOCALE_SUPPORT
        return '\0';
#else
        struct lconv* lc = localeconv();
        return lc ? *(lc->decimal_point) : '\0';
#endif
    }

    /// Converts a unicode code-point to UTF-8.
    static inline String codePointToUTF8(unsigned int cp) {
        String result;

        // based on description from http://en.wikipedia.org/wiki/UTF-8

        if (cp <= 0x7f) {
            result.resize(1);
            result[0] = static_cast<char>(cp);
        } else if (cp <= 0x7FF) {
            result.resize(2);
            result[1] = static_cast<char>(0x80 | (0x3f & cp));
            result[0] = static_cast<char>(0xC0 | (0x1f & (cp >> 6)));
        } else if (cp <= 0xFFFF) {
            result.resize(3);
            result[2] = static_cast<char>(0x80 | (0x3f & cp));
            result[1] = static_cast<char>(0x80 | (0x3f & (cp >> 6)));
            result[0] = static_cast<char>(0xE0 | (0xf & (cp >> 12)));
        } else if (cp <= 0x10FFFF) {
            result.resize(4);
            result[3] = static_cast<char>(0x80 | (0x3f & cp));
            result[2] = static_cast<char>(0x80 | (0x3f & (cp >> 6)));
            result[1] = static_cast<char>(0x80 | (0x3f & (cp >> 12)));
            result[0] = static_cast<char>(0xF0 | (0x7 & (cp >> 18)));
        }

        return result;
    }

    enum {
        /// Constant that specify the size of the buffer that must be passed to
        /// uintToString.
        uintToStringBufferSize = 3 * sizeof(LargestUInt) + 1
    };

    // Defines a char buffer for use with uintToString().
    typedef char UIntToStringBuffer[uintToStringBufferSize];

    /** Converts an unsigned integer to string.
     * @param value Unsigned integer to convert to string
     * @param current Input/Output string buffer.
     *        Must have at least uintToStringBufferSize chars free.
     */
    static inline void uintToString(LargestUInt value, char*& current) {
        *--current = 0;
        do {
            *--current = static_cast<char>(value % 10U + static_cast<unsigned>('0'));
            value /= 10;
        } while (value != 0);
    }

    /** Change ',' to '.' everywhere in buffer.
     *
     * We had a sophisticated way, but it did not work in WinCE.
     * @see https://github.com/open-source-parsers/jsoncpp/pull/9
     */
    template <typename Iter> Iter fixNumericLocale(Iter begin, Iter end) {
        for (; begin != end; ++begin) {
            if (*begin == ',') {
                *begin = '.';
            }
        }
        return begin;
    }

    template <typename Iter> void fixNumericLocaleInput(Iter begin, Iter end) {
        char decimalPoint = getDecimalPoint();
        if (decimalPoint == '\0' || decimalPoint == '.') {
            return;
        }
        for (; begin != end; ++begin) {
            if (*begin == '.') {
                *begin = decimalPoint;
            }
        }
    }

    /**
     * Return iterator that would be the new end of the range [begin,end), if we
     * were to delete zeros in the end of string, but not the last zero before '.'.
     */
    template <typename Iter> Iter fixZerosInTheEnd(Iter begin, Iter end) {
        for (; begin != end; --end) {
            if (*(end - 1) != '0') {
                return end;
            }
            // Don't delete the last zero before the decimal point.
            if (begin != (end - 1) && *(end - 2) == '.') {
                return end;
            }
        }
        return end;
    }

} // namespace Json

#endif // LIB_JSONCPP_JSON_TOOL_H_INCLUDED

// //////////////////////////////////////////////////////////////////////
// End of content of file: src/lib_json/json_tool.h
// //////////////////////////////////////////////////////////////////////






// //////////////////////////////////////////////////////////////////////
// Beginning of content of file: src/lib_json/json_reader.cpp
// //////////////////////////////////////////////////////////////////////

// Copyright 2007-2011 Baptiste Lepilleur and The JsonCpp Authors
// Copyright (C) 2016 InfoTeCS JSC. All rights reserved.
// Distributed under MIT license, or public domain if desired and
// recognized in your jurisdiction.
// See file LICENSE for detail or copy at http://jsoncpp.sourceforge.net/LICENSE

#if !defined(JSON_IS_AMALGAMATION)
#include "json_tool.h"
#include <json/assertions.h>
#include <json/reader.h>
#include <json/value.h>
#endif // if !defined(JSON_IS_AMALGAMATION)
#include <cassert>
#include <cstring>
#include <iostream>
#include <istream>
#include <limits>
#include <memory>
#include <set>
#include <sstream>
#include <utility>

#include <cstdio>
#if __cplusplus >= 201103L

#if !defined(sscanf)
#define sscanf std::sscanf
#endif

#endif //__cplusplus

#if defined(_MSC_VER)
#if !defined(_CRT_SECURE_CPP_OVERLOAD_STANDARD_NAMES)
#define _CRT_SECURE_CPP_OVERLOAD_STANDARD_NAMES 1
#endif //_CRT_SECURE_CPP_OVERLOAD_STANDARD_NAMES
#endif //_MSC_VER

#if defined(_MSC_VER)
// Disable warning about strdup being deprecated.
#pragma warning(disable : 4996)
#endif

// Define JSONCPP_DEPRECATED_STACK_LIMIT as an appropriate integer at compile
// time to change the stack limit
#if !defined(JSONCPP_DEPRECATED_STACK_LIMIT)
#define JSONCPP_DEPRECATED_STACK_LIMIT 1000
#endif

static size_t const stackLimit_g =
JSONCPP_DEPRECATED_STACK_LIMIT; // see readValue()

namespace Json {

#if __cplusplus >= 201103L || (defined(_CPPLIB_VER) && _CPPLIB_VER >= 520)
    using CharReaderPtr = std::unique_ptr<CharReader>;
#else
    typedef std::auto_ptr<CharReader> CharReaderPtr;
#endif

    // Implementation of class Features
    // ////////////////////////////////

    Features::Features() = default;

    Features Features::all() { return {}; }

    Features Features::strictMode() {
        Features features;
        features.allowComments_ = false;
        features.strictRoot_ = true;
        features.allowDroppedNullPlaceholders_ = false;
        features.allowNumericKeys_ = false;
        return features;
    }

    // Implementation of class Reader
    // ////////////////////////////////

    bool Reader::containsNewLine(Reader::Location begin, Reader::Location end) {
        for (; begin < end; ++begin)
            if (*begin == '\n' || *begin == '\r')
                return true;
        return false;
    }

    // Class Reader
    // //////////////////////////////////////////////////////////////////

    Reader::Reader() : features_(Features::all()) {}

    Reader::Reader(const Features& features) : features_(features) {}

    bool Reader::parse(const std::string& document, Value& root,
        bool collectComments) {
        document_.assign(document.begin(), document.end());
        const char* begin = document_.c_str();
        const char* end = begin + document_.length();
        return parse(begin, end, root, collectComments);
    }

    bool Reader::parse(std::istream& is, Value& root, bool collectComments) {
        // std::istream_iterator<char> begin(is);
        // std::istream_iterator<char> end;
        // Those would allow streamed input from a file, if parse() were a
        // template function.

        // Since String is reference-counted, this at least does not
        // create an extra copy.
        String doc;
        std::getline(is, doc, static_cast<char> EOF);
        return parse(doc.data(), doc.data() + doc.size(), root, collectComments);
    }

    bool Reader::parse(const char* beginDoc, const char* endDoc, Value& root,
        bool collectComments) {
        if (!features_.allowComments_) {
            collectComments = false;
        }

        begin_ = beginDoc;
        end_ = endDoc;
        collectComments_ = collectComments;
        current_ = begin_;
        lastValueEnd_ = nullptr;
        lastValue_ = nullptr;
        commentsBefore_.clear();
        errors_.clear();
        while (!nodes_.empty())
            nodes_.pop();
        nodes_.push(&root);

        bool successful = readValue();
        Token token;
        skipCommentTokens(token);
        if (collectComments_ && !commentsBefore_.empty())
            root.setComment(commentsBefore_, commentAfter);
        if (features_.strictRoot_) {
            if (!root.isArray() && !root.isObject()) {
                // Set error location to start of doc, ideally should be first token found
                // in doc
                token.type_ = tokenError;
                token.start_ = beginDoc;
                token.end_ = endDoc;
                addError(
                    "A valid JSON document must be either an array or an object value.",
                    token);
                return false;
            }
        }
        return successful;
    }

    bool Reader::readValue() {
        // readValue() may call itself only if it calls readObject() or ReadArray().
        // These methods execute nodes_.push() just before and nodes_.pop)() just
        // after calling readValue(). parse() executes one nodes_.push(), so > instead
        // of >=.
        if (nodes_.size() > stackLimit_g)
            throwRuntimeError("Exceeded stackLimit in readValue().");

        Token token;
        skipCommentTokens(token);
        bool successful = true;

        if (collectComments_ && !commentsBefore_.empty()) {
            currentValue().setComment(commentsBefore_, commentBefore);
            commentsBefore_.clear();
        }

        switch (token.type_) {
        case tokenObjectBegin:
            successful = readObject(token);
            currentValue().setOffsetLimit(current_ - begin_);
            break;
        case tokenArrayBegin:
            successful = readArray(token);
            currentValue().setOffsetLimit(current_ - begin_);
            break;
        case tokenNumber:
            successful = decodeNumber(token);
            break;
        case tokenString:
            successful = decodeString(token);
            break;
        case tokenTrue: {
            Value v(true);
            currentValue().swapPayload(v);
            currentValue().setOffsetStart(token.start_ - begin_);
            currentValue().setOffsetLimit(token.end_ - begin_);
        } break;
        case tokenFalse: {
            Value v(false);
            currentValue().swapPayload(v);
            currentValue().setOffsetStart(token.start_ - begin_);
            currentValue().setOffsetLimit(token.end_ - begin_);
        } break;
        case tokenNull: {
            Value v;
            currentValue().swapPayload(v);
            currentValue().setOffsetStart(token.start_ - begin_);
            currentValue().setOffsetLimit(token.end_ - begin_);
        } break;
        case tokenArraySeparator:
        case tokenObjectEnd:
        case tokenArrayEnd:
            if (features_.allowDroppedNullPlaceholders_) {
                // "Un-read" the current token and mark the current value as a null
                // token.
                current_--;
                Value v;
                currentValue().swapPayload(v);
                currentValue().setOffsetStart(current_ - begin_ - 1);
                currentValue().setOffsetLimit(current_ - begin_);
                break;
            } // Else, fall through...
        default:
            currentValue().setOffsetStart(token.start_ - begin_);
            currentValue().setOffsetLimit(token.end_ - begin_);
            return addError("Syntax error: value, object or array expected.", token);
        }

        if (collectComments_) {
            lastValueEnd_ = current_;
            lastValue_ = &currentValue();
        }

        return successful;
    }

    void Reader::skipCommentTokens(Token& token) {
        if (features_.allowComments_) {
            do {
                readToken(token);
            } while (token.type_ == tokenComment);
        } else {
            readToken(token);
        }
    }

    bool Reader::readToken(Token& token) {
        skipSpaces();
        token.start_ = current_;
        Char c = getNextChar();
        bool ok = true;
        switch (c) {
        case '{':
            token.type_ = tokenObjectBegin;
            break;
        case '}':
            token.type_ = tokenObjectEnd;
            break;
        case '[':
            token.type_ = tokenArrayBegin;
            break;
        case ']':
            token.type_ = tokenArrayEnd;
            break;
        case '"':
            token.type_ = tokenString;
            ok = readString();
            break;
        case '/':
            token.type_ = tokenComment;
            ok = readComment();
            break;
        case '0':
        case '1':
        case '2':
        case '3':
        case '4':
        case '5':
        case '6':
        case '7':
        case '8':
        case '9':
        case '-':
            token.type_ = tokenNumber;
            readNumber();
            break;
        case 't':
            token.type_ = tokenTrue;
            ok = match("rue", 3);
            break;
        case 'f':
            token.type_ = tokenFalse;
            ok = match("alse", 4);
            break;
        case 'n':
            token.type_ = tokenNull;
            ok = match("ull", 3);
            break;
        case ',':
            token.type_ = tokenArraySeparator;
            break;
        case ':':
            token.type_ = tokenMemberSeparator;
            break;
        case 0:
            token.type_ = tokenEndOfStream;
            break;
        default:
            ok = false;
            break;
        }
        if (!ok)
            token.type_ = tokenError;
        token.end_ = current_;
        return ok;
    }

    void Reader::skipSpaces() {
        while (current_ != end_) {
            Char c = *current_;
            if (c == ' ' || c == '\t' || c == '\r' || c == '\n')
                ++current_;
            else
                break;
        }
    }

    bool Reader::match(const Char* pattern, int patternLength) {
        if (end_ - current_ < patternLength)
            return false;
        int index = patternLength;
        while (index--)
            if (current_[index] != pattern[index])
                return false;
        current_ += patternLength;
        return true;
    }

    bool Reader::readComment() {
        Location commentBegin = current_ - 1;
        Char c = getNextChar();
        bool successful = false;
        if (c == '*')
            successful = readCStyleComment();
        else if (c == '/')
            successful = readCppStyleComment();
        if (!successful)
            return false;

        if (collectComments_) {
            CommentPlacement placement = commentBefore;
            if (lastValueEnd_ && !containsNewLine(lastValueEnd_, commentBegin)) {
                if (c != '*' || !containsNewLine(commentBegin, current_))
                    placement = commentAfterOnSameLine;
            }

            addComment(commentBegin, current_, placement);
        }
        return true;
    }

    String Reader::normalizeEOL(Reader::Location begin, Reader::Location end) {
        String normalized;
        normalized.reserve(static_cast<size_t>(end - begin));
        Reader::Location current = begin;
        while (current != end) {
            char c = *current++;
            if (c == '\r') {
                if (current != end && *current == '\n')
                    // convert dos EOL
                    ++current;
                // convert Mac EOL
                normalized += '\n';
            } else {
                normalized += c;
            }
        }
        return normalized;
    }

    void Reader::addComment(Location begin, Location end,
        CommentPlacement placement) {
        assert(collectComments_);
        const String& normalized = normalizeEOL(begin, end);
        if (placement == commentAfterOnSameLine) {
            assert(lastValue_ != nullptr);
            lastValue_->setComment(normalized, placement);
        } else {
            commentsBefore_ += normalized;
        }
    }

    bool Reader::readCStyleComment() {
        while ((current_ + 1) < end_) {
            Char c = getNextChar();
            if (c == '*' && *current_ == '/')
                break;
        }
        return getNextChar() == '/';
    }

    bool Reader::readCppStyleComment() {
        while (current_ != end_) {
            Char c = getNextChar();
            if (c == '\n')
                break;
            if (c == '\r') {
                // Consume DOS EOL. It will be normalized in addComment.
                if (current_ != end_ && *current_ == '\n')
                    getNextChar();
                // Break on Moc OS 9 EOL.
                break;
            }
        }
        return true;
    }

    void Reader::readNumber() {
        Location p = current_;
        char c = '0'; // stopgap for already consumed character
        // integral part
        while (c >= '0' && c <= '9')
            c = (current_ = p) < end_ ? *p++ : '\0';
        // fractional part
        if (c == '.') {
            c = (current_ = p) < end_ ? *p++ : '\0';
            while (c >= '0' && c <= '9')
                c = (current_ = p) < end_ ? *p++ : '\0';
        }
        // exponential part
        if (c == 'e' || c == 'E') {
            c = (current_ = p) < end_ ? *p++ : '\0';
            if (c == '+' || c == '-')
                c = (current_ = p) < end_ ? *p++ : '\0';
            while (c >= '0' && c <= '9')
                c = (current_ = p) < end_ ? *p++ : '\0';
        }
    }

    bool Reader::readString() {
        Char c = '\0';
        while (current_ != end_) {
            c = getNextChar();
            if (c == '\\')
                getNextChar();
            else if (c == '"')
                break;
        }
        return c == '"';
    }

    bool Reader::readObject(Token& token) {
        Token tokenName;
        String name;
        Value init(objectValue);
        currentValue().swapPayload(init);
        currentValue().setOffsetStart(token.start_ - begin_);
        while (readToken(tokenName)) {
            bool initialTokenOk = true;
            while (tokenName.type_ == tokenComment && initialTokenOk)
                initialTokenOk = readToken(tokenName);
            if (!initialTokenOk)
                break;
            if (tokenName.type_ == tokenObjectEnd && name.empty()) // empty object
                return true;
            name.clear();
            if (tokenName.type_ == tokenString) {
                if (!decodeString(tokenName, name))
                    return recoverFromError(tokenObjectEnd);
            } else if (tokenName.type_ == tokenNumber && features_.allowNumericKeys_) {
                Value numberName;
                if (!decodeNumber(tokenName, numberName))
                    return recoverFromError(tokenObjectEnd);
                name = String(numberName.asCString());
            } else {
                break;
            }

            Token colon;
            if (!readToken(colon) || colon.type_ != tokenMemberSeparator) {
                return addErrorAndRecover("Missing ':' after object member name", colon,
                    tokenObjectEnd);
            }
            Value& value = currentValue()[name];
            nodes_.push(&value);
            bool ok = readValue();
            nodes_.pop();
            if (!ok) // error already set
                return recoverFromError(tokenObjectEnd);

            Token comma;
            if (!readToken(comma) ||
                (comma.type_ != tokenObjectEnd && comma.type_ != tokenArraySeparator &&
                    comma.type_ != tokenComment)) {
                return addErrorAndRecover("Missing ',' or '}' in object declaration",
                    comma, tokenObjectEnd);
            }
            bool finalizeTokenOk = true;
            while (comma.type_ == tokenComment && finalizeTokenOk)
                finalizeTokenOk = readToken(comma);
            if (comma.type_ == tokenObjectEnd)
                return true;
        }
        return addErrorAndRecover("Missing '}' or object member name", tokenName,
            tokenObjectEnd);
    }

    bool Reader::readArray(Token& token) {
        Value init(arrayValue);
        currentValue().swapPayload(init);
        currentValue().setOffsetStart(token.start_ - begin_);
        skipSpaces();
        if (current_ != end_ && *current_ == ']') // empty array
        {
            Token endArray;
            readToken(endArray);
            return true;
        }
        int index = 0;
        for (;;) {
            Value& value = currentValue()[index++];
            nodes_.push(&value);
            bool ok = readValue();
            nodes_.pop();
            if (!ok) // error already set
                return recoverFromError(tokenArrayEnd);

            Token currentToken;
            // Accept Comment after last item in the array.
            ok = readToken(currentToken);
            while (currentToken.type_ == tokenComment && ok) {
                ok = readToken(currentToken);
            }
            bool badTokenType = (currentToken.type_ != tokenArraySeparator &&
                currentToken.type_ != tokenArrayEnd);
            if (!ok || badTokenType) {
                return addErrorAndRecover("Missing ',' or ']' in array declaration",
                    currentToken, tokenArrayEnd);
            }
            if (currentToken.type_ == tokenArrayEnd)
                break;
        }
        return true;
    }

    bool Reader::decodeNumber(Token& token) {
        Value decoded;
        if (!decodeNumber(token, decoded))
            return false;
        currentValue().swapPayload(decoded);
        currentValue().setOffsetStart(token.start_ - begin_);
        currentValue().setOffsetLimit(token.end_ - begin_);
        return true;
    }

    bool Reader::decodeNumber(Token& token, Value& decoded) {
        // Attempts to parse the number as an integer. If the number is
        // larger than the maximum supported value of an integer then
        // we decode the number as a double.
        Location current = token.start_;
        bool isNegative = *current == '-';
        if (isNegative)
            ++current;
        // TODO: Help the compiler do the div and mod at compile time or get rid of
        // them.
        Value::LargestUInt maxIntegerValue =
            isNegative ? Value::LargestUInt(Value::maxLargestInt) + 1
            : Value::maxLargestUInt;
        Value::LargestUInt threshold = maxIntegerValue / 10;
        Value::LargestUInt value = 0;
        while (current < token.end_) {
            Char c = *current++;
            if (c < '0' || c > '9')
                return decodeDouble(token, decoded);
            auto digit(static_cast<Value::UInt>(c - '0'));
            if (value >= threshold) {
                // We've hit or exceeded the max value divided by 10 (rounded down). If
                // a) we've only just touched the limit, b) this is the last digit, and
                // c) it's small enough to fit in that rounding delta, we're okay.
                // Otherwise treat this number as a double to avoid overflow.
                if (value > threshold || current != token.end_ ||
                    digit > maxIntegerValue % 10) {
                    return decodeDouble(token, decoded);
                }
            }
            value = value * 10 + digit;
        }
        if (isNegative && value == maxIntegerValue)
            decoded = Value::minLargestInt;
        else if (isNegative)
            decoded = -Value::LargestInt(value);
        else if (value <= Value::LargestUInt(Value::maxInt))
            decoded = Value::LargestInt(value);
        else
            decoded = value;
        return true;
    }

    bool Reader::decodeDouble(Token& token) {
        Value decoded;
        if (!decodeDouble(token, decoded))
            return false;
        currentValue().swapPayload(decoded);
        currentValue().setOffsetStart(token.start_ - begin_);
        currentValue().setOffsetLimit(token.end_ - begin_);
        return true;
    }

    bool Reader::decodeDouble(Token& token, Value& decoded) {
        double value = 0;
        String buffer(token.start_, token.end_);
        IStringStream is(buffer);
        if (!(is >> value))
            return addError(
                "'" + String(token.start_, token.end_) + "' is not a number.", token);
        decoded = value;
        return true;
    }

    bool Reader::decodeString(Token& token) {
        String decoded_string;
        if (!decodeString(token, decoded_string))
            return false;
        Value decoded(decoded_string);
        currentValue().swapPayload(decoded);
        currentValue().setOffsetStart(token.start_ - begin_);
        currentValue().setOffsetLimit(token.end_ - begin_);
        return true;
    }

    bool Reader::decodeString(Token& token, String& decoded) {
        decoded.reserve(static_cast<size_t>(token.end_ - token.start_ - 2));
        Location current = token.start_ + 1; // skip '"'
        Location end = token.end_ - 1;       // do not include '"'
        while (current != end) {
            Char c = *current++;
            if (c == '"')
                break;
            else if (c == '\\') {
                if (current == end)
                    return addError("Empty escape sequence in string", token, current);
                Char escape = *current++;
                switch (escape) {
                case '"':
                    decoded += '"';
                    break;
                case '/':
                    decoded += '/';
                    break;
                case '\\':
                    decoded += '\\';
                    break;
                case 'b':
                    decoded += '\b';
                    break;
                case 'f':
                    decoded += '\f';
                    break;
                case 'n':
                    decoded += '\n';
                    break;
                case 'r':
                    decoded += '\r';
                    break;
                case 't':
                    decoded += '\t';
                    break;
                case 'u': {
                    unsigned int unicode;
                    if (!decodeUnicodeCodePoint(token, current, end, unicode))
                        return false;
                    decoded += codePointToUTF8(unicode);
                } break;
                default:
                    return addError("Bad escape sequence in string", token, current);
                }
            } else {
                decoded += c;
            }
        }
        return true;
    }

    bool Reader::decodeUnicodeCodePoint(Token& token, Location& current,
        Location end, unsigned int& unicode) {

        if (!decodeUnicodeEscapeSequence(token, current, end, unicode))
            return false;
        if (unicode >= 0xD800 && unicode <= 0xDBFF) {
            // surrogate pairs
            if (end - current < 6)
                return addError(
                    "additional six characters expected to parse unicode surrogate pair.",
                    token, current);
            if (*(current++) == '\\' && *(current++) == 'u') {
                unsigned int surrogatePair;
                if (decodeUnicodeEscapeSequence(token, current, end, surrogatePair)) {
                    unicode = 0x10000 + ((unicode & 0x3FF) << 10) + (surrogatePair & 0x3FF);
                } else
                    return false;
            } else
                return addError("expecting another \\u token to begin the second half of "
                    "a unicode surrogate pair",
                    token, current);
        }
        return true;
    }

    bool Reader::decodeUnicodeEscapeSequence(Token& token, Location& current,
        Location end,
        unsigned int& ret_unicode) {
        if (end - current < 4)
            return addError(
                "Bad unicode escape sequence in string: four digits expected.", token,
                current);
        int unicode = 0;
        for (int index = 0; index < 4; ++index) {
            Char c = *current++;
            unicode *= 16;
            if (c >= '0' && c <= '9')
                unicode += c - '0';
            else if (c >= 'a' && c <= 'f')
                unicode += c - 'a' + 10;
            else if (c >= 'A' && c <= 'F')
                unicode += c - 'A' + 10;
            else
                return addError(
                    "Bad unicode escape sequence in string: hexadecimal digit expected.",
                    token, current);
        }
        ret_unicode = static_cast<unsigned int>(unicode);
        return true;
    }

    bool Reader::addError(const String& message, Token& token, Location extra) {
        ErrorInfo info;
        info.token_ = token;
        info.message_ = message;
        info.extra_ = extra;
        errors_.push_back(info);
        return false;
    }

    bool Reader::recoverFromError(TokenType skipUntilToken) {
        size_t const errorCount = errors_.size();
        Token skip;
        for (;;) {
            if (!readToken(skip))
                errors_.resize(errorCount); // discard errors caused by recovery
            if (skip.type_ == skipUntilToken || skip.type_ == tokenEndOfStream)
                break;
        }
        errors_.resize(errorCount);
        return false;
    }

    bool Reader::addErrorAndRecover(const String& message, Token& token,
        TokenType skipUntilToken) {
        addError(message, token);
        return recoverFromError(skipUntilToken);
    }

    Value& Reader::currentValue() { return *(nodes_.top()); }

    Reader::Char Reader::getNextChar() {
        if (current_ == end_)
            return 0;
        return *current_++;
    }

    void Reader::getLocationLineAndColumn(Location location, int& line,
        int& column) const {
        Location current = begin_;
        Location lastLineStart = current;
        line = 0;
        while (current < location && current != end_) {
            Char c = *current++;
            if (c == '\r') {
                if (*current == '\n')
                    ++current;
                lastLineStart = current;
                ++line;
            } else if (c == '\n') {
                lastLineStart = current;
                ++line;
            }
        }
        // column & line start at 1
        column = int(location - lastLineStart) + 1;
        ++line;
    }

    String Reader::getLocationLineAndColumn(Location location) const {
        int line, column;
        getLocationLineAndColumn(location, line, column);
        char buffer[18 + 16 + 16 + 1];
        jsoncpp_snprintf(buffer, sizeof(buffer), "Line %d, Column %d", line, column);
        return buffer;
    }

    // Deprecated. Preserved for backward compatibility
    String Reader::getFormatedErrorMessages() const {
        return getFormattedErrorMessages();
    }

    String Reader::getFormattedErrorMessages() const {
        String formattedMessage;
        for (const auto& error : errors_) {
            formattedMessage +=
                "* " + getLocationLineAndColumn(error.token_.start_) + "\n";
            formattedMessage += "  " + error.message_ + "\n";
            if (error.extra_)
                formattedMessage +=
                "See " + getLocationLineAndColumn(error.extra_) + " for detail.\n";
        }
        return formattedMessage;
    }

    std::vector<Reader::StructuredError> Reader::getStructuredErrors() const {
        std::vector<Reader::StructuredError> allErrors;
        for (const auto& error : errors_) {
            Reader::StructuredError structured;
            structured.offset_start = error.token_.start_ - begin_;
            structured.offset_limit = error.token_.end_ - begin_;
            structured.message = error.message_;
            allErrors.push_back(structured);
        }
        return allErrors;
    }

    bool Reader::pushError(const Value& value, const String& message) {
        ptrdiff_t const length = end_ - begin_;
        if (value.getOffsetStart() > length || value.getOffsetLimit() > length)
            return false;
        Token token;
        token.type_ = tokenError;
        token.start_ = begin_ + value.getOffsetStart();
        token.end_ = begin_ + value.getOffsetLimit();
        ErrorInfo info;
        info.token_ = token;
        info.message_ = message;
        info.extra_ = nullptr;
        errors_.push_back(info);
        return true;
    }

    bool Reader::pushError(const Value& value, const String& message,
        const Value& extra) {
        ptrdiff_t const length = end_ - begin_;
        if (value.getOffsetStart() > length || value.getOffsetLimit() > length ||
            extra.getOffsetLimit() > length)
            return false;
        Token token;
        token.type_ = tokenError;
        token.start_ = begin_ + value.getOffsetStart();
        token.end_ = begin_ + value.getOffsetLimit();
        ErrorInfo info;
        info.token_ = token;
        info.message_ = message;
        info.extra_ = begin_ + extra.getOffsetStart();
        errors_.push_back(info);
        return true;
    }

    bool Reader::good() const { return errors_.empty(); }

    // Originally copied from the Features class (now deprecated), used internally
    // for features implementation.
    class OurFeatures {
    public:
        static OurFeatures all();
        bool allowComments_;
        bool strictRoot_;
        bool allowDroppedNullPlaceholders_;
        bool allowNumericKeys_;
        bool allowSingleQuotes_;
        bool failIfExtra_;
        bool rejectDupKeys_;
        bool allowSpecialFloats_;
        size_t stackLimit_;
    }; // OurFeatures

    OurFeatures OurFeatures::all() { return {}; }

    // Implementation of class Reader
    // ////////////////////////////////

    // Originally copied from the Reader class (now deprecated), used internally
    // for implementing JSON reading.
    class OurReader {
    public:
        using Char = char;
        using Location = const Char*;
        struct StructuredError {
            ptrdiff_t offset_start;
            ptrdiff_t offset_limit;
            String message;
        };

        explicit OurReader(OurFeatures const& features);
        bool parse(const char* beginDoc, const char* endDoc, Value& root,
            bool collectComments = true);
        String getFormattedErrorMessages() const;
        std::vector<StructuredError> getStructuredErrors() const;
        bool pushError(const Value& value, const String& message);
        bool pushError(const Value& value, const String& message, const Value& extra);
        bool good() const;

    private:
        OurReader(OurReader const&);      // no impl
        void operator=(OurReader const&); // no impl

        enum TokenType {
            tokenEndOfStream = 0,
            tokenObjectBegin,
            tokenObjectEnd,
            tokenArrayBegin,
            tokenArrayEnd,
            tokenString,
            tokenNumber,
            tokenTrue,
            tokenFalse,
            tokenNull,
            tokenNaN,
            tokenPosInf,
            tokenNegInf,
            tokenArraySeparator,
            tokenMemberSeparator,
            tokenComment,
            tokenError
        };

        class Token {
        public:
            TokenType type_;
            Location start_;
            Location end_;
        };

        class ErrorInfo {
        public:
            Token token_;
            String message_;
            Location extra_;
        };

        using Errors = std::deque<ErrorInfo>;

        bool readToken(Token& token);
        void skipSpaces();
        bool match(const Char* pattern, int patternLength);
        bool readComment();
        bool readCStyleComment(bool* containsNewLineResult);
        bool readCppStyleComment();
        bool readString();
        bool readStringSingleQuote();
        bool readNumber(bool checkInf);
        bool readValue();
        bool readObject(Token& token);
        bool readArray(Token& token);
        bool decodeNumber(Token& token);
        bool decodeNumber(Token& token, Value& decoded);
        bool decodeString(Token& token);
        bool decodeString(Token& token, String& decoded);
        bool decodeDouble(Token& token);
        bool decodeDouble(Token& token, Value& decoded);
        bool decodeUnicodeCodePoint(Token& token, Location& current, Location end,
            unsigned int& unicode);
        bool decodeUnicodeEscapeSequence(Token& token, Location& current,
            Location end, unsigned int& unicode);
        bool addError(const String& message, Token& token, Location extra = nullptr);
        bool recoverFromError(TokenType skipUntilToken);
        bool addErrorAndRecover(const String& message, Token& token,
            TokenType skipUntilToken);
        void skipUntilSpace();
        Value& currentValue();
        Char getNextChar();
        void getLocationLineAndColumn(Location location, int& line,
            int& column) const;
        String getLocationLineAndColumn(Location location) const;
        void addComment(Location begin, Location end, CommentPlacement placement);
        void skipCommentTokens(Token& token);

        static String normalizeEOL(Location begin, Location end);
        static bool containsNewLine(Location begin, Location end);

        using Nodes = std::stack<Value*>;

        Nodes nodes_{};
        Errors errors_{};
        String document_{};
        Location begin_ = nullptr;
        Location end_ = nullptr;
        Location current_ = nullptr;
        Location lastValueEnd_ = nullptr;
        Value* lastValue_ = nullptr;
        bool lastValueHasAComment_ = false;
        String commentsBefore_{};

        OurFeatures const features_;
        bool collectComments_ = false;
    }; // OurReader

    // complete copy of Read impl, for OurReader

    bool OurReader::containsNewLine(OurReader::Location begin,
        OurReader::Location end) {
        for (; begin < end; ++begin)
            if (*begin == '\n' || *begin == '\r')
                return true;
        return false;
    }

    OurReader::OurReader(OurFeatures const& features) : features_(features) {}

    bool OurReader::parse(const char* beginDoc, const char* endDoc, Value& root,
        bool collectComments) {
        if (!features_.allowComments_) {
            collectComments = false;
        }

        begin_ = beginDoc;
        end_ = endDoc;
        collectComments_ = collectComments;
        current_ = begin_;
        lastValueEnd_ = nullptr;
        lastValue_ = nullptr;
        commentsBefore_.clear();
        errors_.clear();
        while (!nodes_.empty())
            nodes_.pop();
        nodes_.push(&root);

        bool successful = readValue();
        nodes_.pop();
        Token token;
        skipCommentTokens(token);
        if (features_.failIfExtra_ && (token.type_ != tokenEndOfStream)) {
            addError("Extra non-whitespace after JSON value.", token);
            return false;
        }
        if (collectComments_ && !commentsBefore_.empty())
            root.setComment(commentsBefore_, commentAfter);
        if (features_.strictRoot_) {
            if (!root.isArray() && !root.isObject()) {
                // Set error location to start of doc, ideally should be first token found
                // in doc
                token.type_ = tokenError;
                token.start_ = beginDoc;
                token.end_ = endDoc;
                addError(
                    "A valid JSON document must be either an array or an object value.",
                    token);
                return false;
            }
        }
        return successful;
    }

    bool OurReader::readValue() {
        //  To preserve the old behaviour we cast size_t to int.
        if (nodes_.size() > features_.stackLimit_)
            throwRuntimeError("Exceeded stackLimit in readValue().");
        Token token;
        skipCommentTokens(token);
        bool successful = true;

        if (collectComments_ && !commentsBefore_.empty()) {
            currentValue().setComment(commentsBefore_, commentBefore);
            commentsBefore_.clear();
        }

        switch (token.type_) {
        case tokenObjectBegin:
            successful = readObject(token);
            currentValue().setOffsetLimit(current_ - begin_);
            break;
        case tokenArrayBegin:
            successful = readArray(token);
            currentValue().setOffsetLimit(current_ - begin_);
            break;
        case tokenNumber:
            successful = decodeNumber(token);
            break;
        case tokenString:
            successful = decodeString(token);
            break;
        case tokenTrue: {
            Value v(true);
            currentValue().swapPayload(v);
            currentValue().setOffsetStart(token.start_ - begin_);
            currentValue().setOffsetLimit(token.end_ - begin_);
        } break;
        case tokenFalse: {
            Value v(false);
            currentValue().swapPayload(v);
            currentValue().setOffsetStart(token.start_ - begin_);
            currentValue().setOffsetLimit(token.end_ - begin_);
        } break;
        case tokenNull: {
            Value v;
            currentValue().swapPayload(v);
            currentValue().setOffsetStart(token.start_ - begin_);
            currentValue().setOffsetLimit(token.end_ - begin_);
        } break;
        case tokenNaN: {
            Value v(std::numeric_limits<double>::quiet_NaN());
            currentValue().swapPayload(v);
            currentValue().setOffsetStart(token.start_ - begin_);
            currentValue().setOffsetLimit(token.end_ - begin_);
        } break;
        case tokenPosInf: {
            Value v(std::numeric_limits<double>::infinity());
            currentValue().swapPayload(v);
            currentValue().setOffsetStart(token.start_ - begin_);
            currentValue().setOffsetLimit(token.end_ - begin_);
        } break;
        case tokenNegInf: {
            Value v(-std::numeric_limits<double>::infinity());
            currentValue().swapPayload(v);
            currentValue().setOffsetStart(token.start_ - begin_);
            currentValue().setOffsetLimit(token.end_ - begin_);
        } break;
        case tokenArraySeparator:
        case tokenObjectEnd:
        case tokenArrayEnd:
            if (features_.allowDroppedNullPlaceholders_) {
                // "Un-read" the current token and mark the current value as a null
                // token.
                current_--;
                Value v;
                currentValue().swapPayload(v);
                currentValue().setOffsetStart(current_ - begin_ - 1);
                currentValue().setOffsetLimit(current_ - begin_);
                break;
            } // else, fall through ...
        default:
            currentValue().setOffsetStart(token.start_ - begin_);
            currentValue().setOffsetLimit(token.end_ - begin_);
            return addError("Syntax error: value, object or array expected.", token);
        }

        if (collectComments_) {
            lastValueEnd_ = current_;
            lastValueHasAComment_ = false;
            lastValue_ = &currentValue();
        }

        return successful;
    }

    void OurReader::skipCommentTokens(Token& token) {
        if (features_.allowComments_) {
            do {
                readToken(token);
            } while (token.type_ == tokenComment);
        } else {
            readToken(token);
        }
    }

    bool OurReader::readToken(Token& token) {
        skipSpaces();
        token.start_ = current_;
        Char c = getNextChar();
        bool ok = true;
        switch (c) {
        case '{':
            token.type_ = tokenObjectBegin;
            break;
        case '}':
            token.type_ = tokenObjectEnd;
            break;
        case '[':
            token.type_ = tokenArrayBegin;
            break;
        case ']':
            token.type_ = tokenArrayEnd;
            break;
        case '"':
            token.type_ = tokenString;
            ok = readString();
            break;
        case '\'':
            if (features_.allowSingleQuotes_) {
                token.type_ = tokenString;
                ok = readStringSingleQuote();
                break;
            } // else fall through
        case '/':
            token.type_ = tokenComment;
            ok = readComment();
            break;
        case '0':
        case '1':
        case '2':
        case '3':
        case '4':
        case '5':
        case '6':
        case '7':
        case '8':
        case '9':
            token.type_ = tokenNumber;
            readNumber(false);
            break;
        case '-':
            if (readNumber(true)) {
                token.type_ = tokenNumber;
            } else {
                token.type_ = tokenNegInf;
                ok = features_.allowSpecialFloats_ && match("nfinity", 7);
            }
            break;
        case '+':
            if (readNumber(true)) {
                token.type_ = tokenNumber;
            } else {
                token.type_ = tokenPosInf;
                ok = features_.allowSpecialFloats_ && match("nfinity", 7);
            }
            break;
        case 't':
            token.type_ = tokenTrue;
            ok = match("rue", 3);
            break;
        case 'f':
            token.type_ = tokenFalse;
            ok = match("alse", 4);
            break;
        case 'n':
            token.type_ = tokenNull;
            ok = match("ull", 3);
            break;
        case 'N':
            if (features_.allowSpecialFloats_) {
                token.type_ = tokenNaN;
                ok = match("aN", 2);
            } else {
                ok = false;
            }
            break;
        case 'I':
            if (features_.allowSpecialFloats_) {
                token.type_ = tokenPosInf;
                ok = match("nfinity", 7);
            } else {
                ok = false;
            }
            break;
        case ',':
            token.type_ = tokenArraySeparator;
            break;
        case ':':
            token.type_ = tokenMemberSeparator;
            break;
        case 0:
            token.type_ = tokenEndOfStream;
            break;
        default:
            ok = false;
            break;
        }
        if (!ok)
            token.type_ = tokenError;
        token.end_ = current_;
        return ok;
    }

    void OurReader::skipSpaces() {
        while (current_ != end_) {
            Char c = *current_;
            if (c == ' ' || c == '\t' || c == '\r' || c == '\n')
                ++current_;
            else
                break;
        }
    }

    bool OurReader::match(const Char* pattern, int patternLength) {
        if (end_ - current_ < patternLength)
            return false;
        int index = patternLength;
        while (index--)
            if (current_[index] != pattern[index])
                return false;
        current_ += patternLength;
        return true;
    }

    bool OurReader::readComment() {
        const Location commentBegin = current_ - 1;
        const Char c = getNextChar();
        bool successful = false;
        bool cStyleWithEmbeddedNewline = false;

        const bool isCStyleComment = (c == '*');
        const bool isCppStyleComment = (c == '/');
        if (isCStyleComment) {
            successful = readCStyleComment(&cStyleWithEmbeddedNewline);
        } else if (isCppStyleComment) {
            successful = readCppStyleComment();
        }

        if (!successful)
            return false;

        if (collectComments_) {
            CommentPlacement placement = commentBefore;

            if (!lastValueHasAComment_) {
                if (lastValueEnd_ && !containsNewLine(lastValueEnd_, commentBegin)) {
                    if (isCppStyleComment || !cStyleWithEmbeddedNewline) {
                        placement = commentAfterOnSameLine;
                        lastValueHasAComment_ = true;
                    }
                }
            }

            addComment(commentBegin, current_, placement);
        }
        return true;
    }

    String OurReader::normalizeEOL(OurReader::Location begin,
        OurReader::Location end) {
        String normalized;
        normalized.reserve(static_cast<size_t>(end - begin));
        OurReader::Location current = begin;
        while (current != end) {
            char c = *current++;
            if (c == '\r') {
                if (current != end && *current == '\n')
                    // convert dos EOL
                    ++current;
                // convert Mac EOL
                normalized += '\n';
            } else {
                normalized += c;
            }
        }
        return normalized;
    }

    void OurReader::addComment(Location begin, Location end,
        CommentPlacement placement) {
        assert(collectComments_);
        const String& normalized = normalizeEOL(begin, end);
        if (placement == commentAfterOnSameLine) {
            assert(lastValue_ != nullptr);
            lastValue_->setComment(normalized, placement);
        } else {
            commentsBefore_ += normalized;
        }
    }

    bool OurReader::readCStyleComment(bool* containsNewLineResult) {
        *containsNewLineResult = false;

        while ((current_ + 1) < end_) {
            Char c = getNextChar();
            if (c == '*' && *current_ == '/') {
                break;
            } else if (c == '\n') {
                *containsNewLineResult = true;
            }
        }

        return getNextChar() == '/';
    }

    bool OurReader::readCppStyleComment() {
        while (current_ != end_) {
            Char c = getNextChar();
            if (c == '\n')
                break;
            if (c == '\r') {
                // Consume DOS EOL. It will be normalized in addComment.
                if (current_ != end_ && *current_ == '\n')
                    getNextChar();
                // Break on Moc OS 9 EOL.
                break;
            }
        }
        return true;
    }

    bool OurReader::readNumber(bool checkInf) {
        Location p = current_;
        if (checkInf && p != end_ && *p == 'I') {
            current_ = ++p;
            return false;
        }
        char c = '0'; // stopgap for already consumed character
        // integral part
        while (c >= '0' && c <= '9')
            c = (current_ = p) < end_ ? *p++ : '\0';
        // fractional part
        if (c == '.') {
            c = (current_ = p) < end_ ? *p++ : '\0';
            while (c >= '0' && c <= '9')
                c = (current_ = p) < end_ ? *p++ : '\0';
        }
        // exponential part
        if (c == 'e' || c == 'E') {
            c = (current_ = p) < end_ ? *p++ : '\0';
            if (c == '+' || c == '-')
                c = (current_ = p) < end_ ? *p++ : '\0';
            while (c >= '0' && c <= '9')
                c = (current_ = p) < end_ ? *p++ : '\0';
        }
        return true;
    }
    bool OurReader::readString() {
        Char c = 0;
        while (current_ != end_) {
            c = getNextChar();
            if (c == '\\')
                getNextChar();
            else if (c == '"')
                break;
        }
        return c == '"';
    }

    bool OurReader::readStringSingleQuote() {
        Char c = 0;
        while (current_ != end_) {
            c = getNextChar();
            if (c == '\\')
                getNextChar();
            else if (c == '\'')
                break;
        }
        return c == '\'';
    }

    bool OurReader::readObject(Token& token) {
        Token tokenName;
        String name;
        Value init(objectValue);
        currentValue().swapPayload(init);
        currentValue().setOffsetStart(token.start_ - begin_);
        while (readToken(tokenName)) {
            bool initialTokenOk = true;
            while (tokenName.type_ == tokenComment && initialTokenOk)
                initialTokenOk = readToken(tokenName);
            if (!initialTokenOk)
                break;
            if (tokenName.type_ == tokenObjectEnd && name.empty()) // empty object
                return true;
            name.clear();
            if (tokenName.type_ == tokenString) {
                if (!decodeString(tokenName, name))
                    return recoverFromError(tokenObjectEnd);
            } else if (tokenName.type_ == tokenNumber && features_.allowNumericKeys_) {
                Value numberName;
                if (!decodeNumber(tokenName, numberName))
                    return recoverFromError(tokenObjectEnd);
                name = numberName.asString();
            } else {
                break;
            }
            if (name.length() >= (1U << 30))
                throwRuntimeError("keylength >= 2^30");
            if (features_.rejectDupKeys_ && currentValue().isMember(name)) {
                String msg = "Duplicate key: '" + name + "'";
                return addErrorAndRecover(msg, tokenName, tokenObjectEnd);
            }

            Token colon;
            if (!readToken(colon) || colon.type_ != tokenMemberSeparator) {
                return addErrorAndRecover("Missing ':' after object member name", colon,
                    tokenObjectEnd);
            }
            Value& value = currentValue()[name];
            nodes_.push(&value);
            bool ok = readValue();
            nodes_.pop();
            if (!ok) // error already set
                return recoverFromError(tokenObjectEnd);

            Token comma;
            if (!readToken(comma) ||
                (comma.type_ != tokenObjectEnd && comma.type_ != tokenArraySeparator &&
                    comma.type_ != tokenComment)) {
                return addErrorAndRecover("Missing ',' or '}' in object declaration",
                    comma, tokenObjectEnd);
            }
            bool finalizeTokenOk = true;
            while (comma.type_ == tokenComment && finalizeTokenOk)
                finalizeTokenOk = readToken(comma);
            if (comma.type_ == tokenObjectEnd)
                return true;
        }
        return addErrorAndRecover("Missing '}' or object member name", tokenName,
            tokenObjectEnd);
    }

    bool OurReader::readArray(Token& token) {
        Value init(arrayValue);
        currentValue().swapPayload(init);
        currentValue().setOffsetStart(token.start_ - begin_);
        skipSpaces();
        if (current_ != end_ && *current_ == ']') // empty array
        {
            Token endArray;
            readToken(endArray);
            return true;
        }
        int index = 0;
        for (;;) {
            Value& value = currentValue()[index++];
            nodes_.push(&value);
            bool ok = readValue();
            nodes_.pop();
            if (!ok) // error already set
                return recoverFromError(tokenArrayEnd);

            Token currentToken;
            // Accept Comment after last item in the array.
            ok = readToken(currentToken);
            while (currentToken.type_ == tokenComment && ok) {
                ok = readToken(currentToken);
            }
            bool badTokenType = (currentToken.type_ != tokenArraySeparator &&
                currentToken.type_ != tokenArrayEnd);
            if (!ok || badTokenType) {
                return addErrorAndRecover("Missing ',' or ']' in array declaration",
                    currentToken, tokenArrayEnd);
            }
            if (currentToken.type_ == tokenArrayEnd)
                break;
        }
        return true;
    }

    bool OurReader::decodeNumber(Token& token) {
        Value decoded;
        if (!decodeNumber(token, decoded))
            return false;
        currentValue().swapPayload(decoded);
        currentValue().setOffsetStart(token.start_ - begin_);
        currentValue().setOffsetLimit(token.end_ - begin_);
        return true;
    }

    bool OurReader::decodeNumber(Token& token, Value& decoded) {
        // Attempts to parse the number as an integer. If the number is
        // larger than the maximum supported value of an integer then
        // we decode the number as a double.
        Location current = token.start_;
        bool isNegative = *current == '-';
        if (isNegative)
            ++current;

        static constexpr auto positive_threshold = Value::maxLargestUInt / 10;
        static constexpr auto positive_last_digit = Value::maxLargestUInt % 10;
        static constexpr auto negative_threshold =
            Value::LargestUInt(Value::minLargestInt) / 10;
        static constexpr auto negative_last_digit =
            Value::LargestUInt(Value::minLargestInt) % 10;

        const auto threshold = isNegative ? negative_threshold : positive_threshold;
        const auto last_digit =
            isNegative ? negative_last_digit : positive_last_digit;

        Value::LargestUInt value = 0;
        while (current < token.end_) {
            Char c = *current++;
            if (c < '0' || c > '9')
                return decodeDouble(token, decoded);

            const auto digit(static_cast<Value::UInt>(c - '0'));
            if (value >= threshold) {
                // We've hit or exceeded the max value divided by 10 (rounded down). If
                // a) we've only just touched the limit, meaing value == threshold,
                // b) this is the last digit, or
                // c) it's small enough to fit in that rounding delta, we're okay.
                // Otherwise treat this number as a double to avoid overflow.
                if (value > threshold || current != token.end_ || digit > last_digit) {
                    return decodeDouble(token, decoded);
                }
            }
            value = value * 10 + digit;
        }

        if (isNegative)
            decoded = -Value::LargestInt(value);
        else if (value <= Value::LargestUInt(Value::maxLargestInt))
            decoded = Value::LargestInt(value);
        else
            decoded = value;

        return true;
    }

    bool OurReader::decodeDouble(Token& token) {
        Value decoded;
        if (!decodeDouble(token, decoded))
            return false;
        currentValue().swapPayload(decoded);
        currentValue().setOffsetStart(token.start_ - begin_);
        currentValue().setOffsetLimit(token.end_ - begin_);
        return true;
    }

    bool OurReader::decodeDouble(Token& token, Value& decoded) {
        double value = 0;
        const int bufferSize = 32;
        int count;
        ptrdiff_t const length = token.end_ - token.start_;

        // Sanity check to avoid buffer overflow exploits.
        if (length < 0) {
            return addError("Unable to parse token length", token);
        }
        auto const ulength = static_cast<size_t>(length);

        // Avoid using a string constant for the format control string given to
        // sscanf, as this can cause hard to debug crashes on OS X. See here for more
        // info:
        //
        //     http://developer.apple.com/library/mac/#DOCUMENTATION/DeveloperTools/gcc-4.0.1/gcc/Incompatibilities.html
        char format[] = "%lf";

        if (length <= bufferSize) {
            Char buffer[bufferSize + 1];
            memcpy(buffer, token.start_, ulength);
            buffer[length] = 0;
            fixNumericLocaleInput(buffer, buffer + length);
            count = sscanf(buffer, format, &value);
        } else {
            String buffer(token.start_, token.end_);
            count = sscanf(buffer.c_str(), format, &value);
        }

        if (count != 1)
            return addError(
                "'" + String(token.start_, token.end_) + "' is not a number.", token);
        decoded = value;
        return true;
    }

    bool OurReader::decodeString(Token& token) {
        String decoded_string;
        if (!decodeString(token, decoded_string))
            return false;
        Value decoded(decoded_string);
        currentValue().swapPayload(decoded);
        currentValue().setOffsetStart(token.start_ - begin_);
        currentValue().setOffsetLimit(token.end_ - begin_);
        return true;
    }

    bool OurReader::decodeString(Token& token, String& decoded) {
        decoded.reserve(static_cast<size_t>(token.end_ - token.start_ - 2));
        Location current = token.start_ + 1; // skip '"'
        Location end = token.end_ - 1;       // do not include '"'
        while (current != end) {
            Char c = *current++;
            if (c == '"')
                break;
            else if (c == '\\') {
                if (current == end)
                    return addError("Empty escape sequence in string", token, current);
                Char escape = *current++;
                switch (escape) {
                case '"':
                    decoded += '"';
                    break;
                case '/':
                    decoded += '/';
                    break;
                case '\\':
                    decoded += '\\';
                    break;
                case 'b':
                    decoded += '\b';
                    break;
                case 'f':
                    decoded += '\f';
                    break;
                case 'n':
                    decoded += '\n';
                    break;
                case 'r':
                    decoded += '\r';
                    break;
                case 't':
                    decoded += '\t';
                    break;
                case 'u': {
                    unsigned int unicode;
                    if (!decodeUnicodeCodePoint(token, current, end, unicode))
                        return false;
                    decoded += codePointToUTF8(unicode);
                } break;
                default:
                    return addError("Bad escape sequence in string", token, current);
                }
            } else {
                decoded += c;
            }
        }
        return true;
    }

    bool OurReader::decodeUnicodeCodePoint(Token& token, Location& current,
        Location end, unsigned int& unicode) {

        if (!decodeUnicodeEscapeSequence(token, current, end, unicode))
            return false;
        if (unicode >= 0xD800 && unicode <= 0xDBFF) {
            // surrogate pairs
            if (end - current < 6)
                return addError(
                    "additional six characters expected to parse unicode surrogate pair.",
                    token, current);
            if (*(current++) == '\\' && *(current++) == 'u') {
                unsigned int surrogatePair;
                if (decodeUnicodeEscapeSequence(token, current, end, surrogatePair)) {
                    unicode = 0x10000 + ((unicode & 0x3FF) << 10) + (surrogatePair & 0x3FF);
                } else
                    return false;
            } else
                return addError("expecting another \\u token to begin the second half of "
                    "a unicode surrogate pair",
                    token, current);
        }
        return true;
    }

    bool OurReader::decodeUnicodeEscapeSequence(Token& token, Location& current,
        Location end,
        unsigned int& ret_unicode) {
        if (end - current < 4)
            return addError(
                "Bad unicode escape sequence in string: four digits expected.", token,
                current);
        int unicode = 0;
        for (int index = 0; index < 4; ++index) {
            Char c = *current++;
            unicode *= 16;
            if (c >= '0' && c <= '9')
                unicode += c - '0';
            else if (c >= 'a' && c <= 'f')
                unicode += c - 'a' + 10;
            else if (c >= 'A' && c <= 'F')
                unicode += c - 'A' + 10;
            else
                return addError(
                    "Bad unicode escape sequence in string: hexadecimal digit expected.",
                    token, current);
        }
        ret_unicode = static_cast<unsigned int>(unicode);
        return true;
    }

    bool OurReader::addError(const String& message, Token& token, Location extra) {
        ErrorInfo info;
        info.token_ = token;
        info.message_ = message;
        info.extra_ = extra;
        errors_.push_back(info);
        return false;
    }

    bool OurReader::recoverFromError(TokenType skipUntilToken) {
        size_t errorCount = errors_.size();
        Token skip;
        for (;;) {
            if (!readToken(skip))
                errors_.resize(errorCount); // discard errors caused by recovery
            if (skip.type_ == skipUntilToken || skip.type_ == tokenEndOfStream)
                break;
        }
        errors_.resize(errorCount);
        return false;
    }

    bool OurReader::addErrorAndRecover(const String& message, Token& token,
        TokenType skipUntilToken) {
        addError(message, token);
        return recoverFromError(skipUntilToken);
    }

    Value& OurReader::currentValue() { return *(nodes_.top()); }

    OurReader::Char OurReader::getNextChar() {
        if (current_ == end_)
            return 0;
        return *current_++;
    }

    void OurReader::getLocationLineAndColumn(Location location, int& line,
        int& column) const {
        Location current = begin_;
        Location lastLineStart = current;
        line = 0;
        while (current < location && current != end_) {
            Char c = *current++;
            if (c == '\r') {
                if (*current == '\n')
                    ++current;
                lastLineStart = current;
                ++line;
            } else if (c == '\n') {
                lastLineStart = current;
                ++line;
            }
        }
        // column & line start at 1
        column = int(location - lastLineStart) + 1;
        ++line;
    }

    String OurReader::getLocationLineAndColumn(Location location) const {
        int line, column;
        getLocationLineAndColumn(location, line, column);
        char buffer[18 + 16 + 16 + 1];
        jsoncpp_snprintf(buffer, sizeof(buffer), "Line %d, Column %d", line, column);
        return buffer;
    }

    String OurReader::getFormattedErrorMessages() const {
        String formattedMessage;
        for (const auto& error : errors_) {
            formattedMessage +=
                "* " + getLocationLineAndColumn(error.token_.start_) + "\n";
            formattedMessage += "  " + error.message_ + "\n";
            if (error.extra_)
                formattedMessage +=
                "See " + getLocationLineAndColumn(error.extra_) + " for detail.\n";
        }
        return formattedMessage;
    }

    std::vector<OurReader::StructuredError> OurReader::getStructuredErrors() const {
        std::vector<OurReader::StructuredError> allErrors;
        for (const auto& error : errors_) {
            OurReader::StructuredError structured;
            structured.offset_start = error.token_.start_ - begin_;
            structured.offset_limit = error.token_.end_ - begin_;
            structured.message = error.message_;
            allErrors.push_back(structured);
        }
        return allErrors;
    }

    bool OurReader::pushError(const Value& value, const String& message) {
        ptrdiff_t length = end_ - begin_;
        if (value.getOffsetStart() > length || value.getOffsetLimit() > length)
            return false;
        Token token;
        token.type_ = tokenError;
        token.start_ = begin_ + value.getOffsetStart();
        token.end_ = begin_ + value.getOffsetLimit();
        ErrorInfo info;
        info.token_ = token;
        info.message_ = message;
        info.extra_ = nullptr;
        errors_.push_back(info);
        return true;
    }

    bool OurReader::pushError(const Value& value, const String& message,
        const Value& extra) {
        ptrdiff_t length = end_ - begin_;
        if (value.getOffsetStart() > length || value.getOffsetLimit() > length ||
            extra.getOffsetLimit() > length)
            return false;
        Token token;
        token.type_ = tokenError;
        token.start_ = begin_ + value.getOffsetStart();
        token.end_ = begin_ + value.getOffsetLimit();
        ErrorInfo info;
        info.token_ = token;
        info.message_ = message;
        info.extra_ = begin_ + extra.getOffsetStart();
        errors_.push_back(info);
        return true;
    }

    bool OurReader::good() const { return errors_.empty(); }

    class OurCharReader : public CharReader {
        bool const collectComments_;
        OurReader reader_;

    public:
        OurCharReader(bool collectComments, OurFeatures const& features)
            : collectComments_(collectComments), reader_(features) {}
        bool parse(char const* beginDoc, char const* endDoc, Value* root,
            String* errs) override {
            bool ok = reader_.parse(beginDoc, endDoc, *root, collectComments_);
            if (errs) {
                *errs = reader_.getFormattedErrorMessages();
            }
            return ok;
        }
    };

    CharReaderBuilder::CharReaderBuilder() { setDefaults(&settings_); }
    CharReaderBuilder::~CharReaderBuilder() = default;
    CharReader* CharReaderBuilder::newCharReader() const {
        bool collectComments = settings_["collectComments"].asBool();
        OurFeatures features = OurFeatures::all();
        features.allowComments_ = settings_["allowComments"].asBool();
        features.strictRoot_ = settings_["strictRoot"].asBool();
        features.allowDroppedNullPlaceholders_ =
            settings_["allowDroppedNullPlaceholders"].asBool();
        features.allowNumericKeys_ = settings_["allowNumericKeys"].asBool();
        features.allowSingleQuotes_ = settings_["allowSingleQuotes"].asBool();

        // Stack limit is always a size_t, so we get this as an unsigned int
        // regardless of it we have 64-bit integer support enabled.
        features.stackLimit_ = static_cast<size_t>(settings_["stackLimit"].asUInt());
        features.failIfExtra_ = settings_["failIfExtra"].asBool();
        features.rejectDupKeys_ = settings_["rejectDupKeys"].asBool();
        features.allowSpecialFloats_ = settings_["allowSpecialFloats"].asBool();
        return new OurCharReader(collectComments, features);
    }
    static void getValidReaderKeys(std::set<String>* valid_keys) {
        valid_keys->clear();
        valid_keys->insert("collectComments");
        valid_keys->insert("allowComments");
        valid_keys->insert("strictRoot");
        valid_keys->insert("allowDroppedNullPlaceholders");
        valid_keys->insert("allowNumericKeys");
        valid_keys->insert("allowSingleQuotes");
        valid_keys->insert("stackLimit");
        valid_keys->insert("failIfExtra");
        valid_keys->insert("rejectDupKeys");
        valid_keys->insert("allowSpecialFloats");
    }
    bool CharReaderBuilder::validate(Json::Value* invalid) const {
        Json::Value my_invalid;
        if (!invalid)
            invalid = &my_invalid; // so we do not need to test for NULL
        Json::Value& inv = *invalid;
        std::set<String> valid_keys;
        getValidReaderKeys(&valid_keys);
        Value::Members keys = settings_.getMemberNames();
        size_t n = keys.size();
        for (size_t i = 0; i < n; ++i) {
            String const& key = keys[i];
            if (valid_keys.find(key) == valid_keys.end()) {
                inv[key] = settings_[key];
            }
        }
        return inv.empty();
    }
    Value& CharReaderBuilder::operator[](const String& key) {
        return settings_[key];
    }
    // static
    void CharReaderBuilder::strictMode(Json::Value* settings) {
        //! [CharReaderBuilderStrictMode]
        (*settings)["allowComments"] = false;
        (*settings)["strictRoot"] = true;
        (*settings)["allowDroppedNullPlaceholders"] = false;
        (*settings)["allowNumericKeys"] = false;
        (*settings)["allowSingleQuotes"] = false;
        (*settings)["stackLimit"] = 1000;
        (*settings)["failIfExtra"] = true;
        (*settings)["rejectDupKeys"] = true;
        (*settings)["allowSpecialFloats"] = false;
        //! [CharReaderBuilderStrictMode]
    }
    // static
    void CharReaderBuilder::setDefaults(Json::Value* settings) {
        //! [CharReaderBuilderDefaults]
        (*settings)["collectComments"] = true;
        (*settings)["allowComments"] = true;
        (*settings)["strictRoot"] = false;
        (*settings)["allowDroppedNullPlaceholders"] = false;
        (*settings)["allowNumericKeys"] = false;
        (*settings)["allowSingleQuotes"] = false;
        (*settings)["stackLimit"] = 1000;
        (*settings)["failIfExtra"] = false;
        (*settings)["rejectDupKeys"] = false;
        (*settings)["allowSpecialFloats"] = false;
        //! [CharReaderBuilderDefaults]
    }

    //////////////////////////////////
    // global functions

    bool parseFromStream(CharReader::Factory const& fact, IStream& sin, Value* root,
        String* errs) {
        OStringStream ssin;
        ssin << sin.rdbuf();
        String doc = ssin.str();
        char const* begin = doc.data();
        char const* end = begin + doc.size();
        // Note that we do not actually need a null-terminator.
        CharReaderPtr const reader(fact.newCharReader());
        return reader->parse(begin, end, root, errs);
    }

    IStream& operator>>(IStream& sin, Value& root) {
        CharReaderBuilder b;
        String errs;
        bool ok = parseFromStream(b, sin, &root, &errs);
        if (!ok) {
            throwRuntimeError(errs);
        }
        return sin;
    }

} // namespace Json

// //////////////////////////////////////////////////////////////////////
// End of content of file: src/lib_json/json_reader.cpp
// //////////////////////////////////////////////////////////////////////






// //////////////////////////////////////////////////////////////////////
// Beginning of content of file: src/lib_json/json_valueiterator.inl
// //////////////////////////////////////////////////////////////////////

// Copyright 2007-2010 Baptiste Lepilleur and The JsonCpp Authors
// Distributed under MIT license, or public domain if desired and
// recognized in your jurisdiction.
// See file LICENSE for detail or copy at http://jsoncpp.sourceforge.net/LICENSE

// included by json_value.cpp

namespace Json {

    // //////////////////////////////////////////////////////////////////
    // //////////////////////////////////////////////////////////////////
    // //////////////////////////////////////////////////////////////////
    // class ValueIteratorBase
    // //////////////////////////////////////////////////////////////////
    // //////////////////////////////////////////////////////////////////
    // //////////////////////////////////////////////////////////////////

    ValueIteratorBase::ValueIteratorBase() : current_() {}

    ValueIteratorBase::ValueIteratorBase(
        const Value::ObjectValues::iterator& current)
        : current_(current), isNull_(false) {}

    Value& ValueIteratorBase::deref() { return current_->second; }
    const Value& ValueIteratorBase::deref() const { return current_->second; }

    void ValueIteratorBase::increment() { ++current_; }

    void ValueIteratorBase::decrement() { --current_; }

    ValueIteratorBase::difference_type
        ValueIteratorBase::computeDistance(const SelfType& other) const {
#ifdef JSON_USE_CPPTL_SMALLMAP
        return other.current_ - current_;
#else
        // Iterator for null value are initialized using the default
        // constructor, which initialize current_ to the default
        // std::map::iterator. As begin() and end() are two instance
        // of the default std::map::iterator, they can not be compared.
        // To allow this, we handle this comparison specifically.
        if (isNull_ && other.isNull_) {
            return 0;
        }

        // Usage of std::distance is not portable (does not compile with Sun Studio 12
        // RogueWave STL,
        // which is the one used by default).
        // Using a portable hand-made version for non random iterator instead:
        //   return difference_type( std::distance( current_, other.current_ ) );
        difference_type myDistance = 0;
        for (Value::ObjectValues::iterator it = current_; it != other.current_;
            ++it) {
            ++myDistance;
        }
        return myDistance;
#endif
    }

    bool ValueIteratorBase::isEqual(const SelfType& other) const {
        if (isNull_) {
            return other.isNull_;
        }
        return current_ == other.current_;
    }

    void ValueIteratorBase::copy(const SelfType& other) {
        current_ = other.current_;
        isNull_ = other.isNull_;
    }

    Value ValueIteratorBase::key() const {
        const Value::CZString czstring = (*current_).first;
        if (czstring.data()) {
            if (czstring.isStaticString())
                return Value(StaticString(czstring.data()));
            return Value(czstring.data(), czstring.data() + czstring.length());
        }
        return Value(czstring.index());
    }

    UInt ValueIteratorBase::index() const {
        const Value::CZString czstring = (*current_).first;
        if (!czstring.data())
            return czstring.index();
        return Value::UInt(-1);
    }

    String ValueIteratorBase::name() const {
        char const* keey;
        char const* end;
        keey = memberName(&end);
        if (!keey)
            return String();
        return String(keey, end);
    }

    char const* ValueIteratorBase::memberName() const {
        const char* cname = (*current_).first.data();
        return cname ? cname : "";
    }

    char const* ValueIteratorBase::memberName(char const** end) const {
        const char* cname = (*current_).first.data();
        if (!cname) {
            *end = nullptr;
            return nullptr;
        }
        *end = cname + (*current_).first.length();
        return cname;
    }

    // //////////////////////////////////////////////////////////////////
    // //////////////////////////////////////////////////////////////////
    // //////////////////////////////////////////////////////////////////
    // class ValueConstIterator
    // //////////////////////////////////////////////////////////////////
    // //////////////////////////////////////////////////////////////////
    // //////////////////////////////////////////////////////////////////

    ValueConstIterator::ValueConstIterator() = default;

    ValueConstIterator::ValueConstIterator(
        const Value::ObjectValues::iterator& current)
        : ValueIteratorBase(current) {}

    ValueConstIterator::ValueConstIterator(ValueIterator const& other)
        : ValueIteratorBase(other) {}

    ValueConstIterator& ValueConstIterator::
        operator=(const ValueIteratorBase& other) {
        copy(other);
        return *this;
    }

    // //////////////////////////////////////////////////////////////////
    // //////////////////////////////////////////////////////////////////
    // //////////////////////////////////////////////////////////////////
    // class ValueIterator
    // //////////////////////////////////////////////////////////////////
    // //////////////////////////////////////////////////////////////////
    // //////////////////////////////////////////////////////////////////

    ValueIterator::ValueIterator() = default;

    ValueIterator::ValueIterator(const Value::ObjectValues::iterator& current)
        : ValueIteratorBase(current) {}

    ValueIterator::ValueIterator(const ValueConstIterator& other)
        : ValueIteratorBase(other) {
        throwRuntimeError("ConstIterator to Iterator should never be allowed.");
    }

    ValueIterator::ValueIterator(const ValueIterator& other) = default;

    ValueIterator& ValueIterator::operator=(const SelfType& other) {
        copy(other);
        return *this;
    }

} // namespace Json

// //////////////////////////////////////////////////////////////////////
// End of content of file: src/lib_json/json_valueiterator.inl
// //////////////////////////////////////////////////////////////////////






// //////////////////////////////////////////////////////////////////////
// Beginning of content of file: src/lib_json/json_value.cpp
// //////////////////////////////////////////////////////////////////////

// Copyright 2011 Baptiste Lepilleur and The JsonCpp Authors
// Distributed under MIT license, or public domain if desired and
// recognized in your jurisdiction.
// See file LICENSE for detail or copy at http://jsoncpp.sourceforge.net/LICENSE

#if !defined(JSON_IS_AMALGAMATION)
#include <json/assertions.h>
#include <json/value.h>
#include <json/writer.h>
#endif // if !defined(JSON_IS_AMALGAMATION)
#include <cassert>
#include <cmath>
#include <cstring>
#include <sstream>
#include <utility>
#ifdef JSON_USE_CPPTL
#include <cpptl/conststring.h>
#endif
#include <algorithm> // min()
#include <cstddef>   // size_t

// Provide implementation equivalent of std::snprintf for older _MSC compilers
#if defined(_MSC_VER) && _MSC_VER < 1900
#include <stdarg.h>
static int msvc_pre1900_c99_vsnprintf(char* outBuf, size_t size,
    const char* format, va_list ap) {
    int count = -1;
    if (size != 0)
        count = _vsnprintf_s(outBuf, size, _TRUNCATE, format, ap);
    if (count == -1)
        count = _vscprintf(format, ap);
    return count;
}

int JSON_API msvc_pre1900_c99_snprintf(char* outBuf, size_t size,
    const char* format, ...) {
    va_list ap;
    va_start(ap, format);
    const int count = msvc_pre1900_c99_vsnprintf(outBuf, size, format, ap);
    va_end(ap);
    return count;
}
#endif

// Disable warning C4702 : unreachable code
#if defined(_MSC_VER)
#pragma warning(disable : 4702)
#endif

#define JSON_ASSERT_UNREACHABLE assert(false)

namespace Json {
    template <typename T>
    static std::unique_ptr<T> cloneUnique(const std::unique_ptr<T>& p) {
        std::unique_ptr<T> r;
        if (p) {
            r = std::unique_ptr<T>(new T(*p));
        }
        return r;
    }

    // This is a walkaround to avoid the static initialization of Value::null.
    // kNull must be word-aligned to avoid crashing on ARM.  We use an alignment of
    // 8 (instead of 4) as a bit of future-proofing.
#if defined(__ARMEL__)
#define ALIGNAS(byte_alignment) __attribute__((aligned(byte_alignment)))
#else
#define ALIGNAS(byte_alignment)
#endif

// static
    Value const& Value::nullSingleton() {
        static Value const nullStatic;
        return nullStatic;
    }

#if JSON_USE_NULLREF
    // for backwards compatibility, we'll leave these global references around, but
    // DO NOT use them in JSONCPP library code any more!
    // static
    Value const& Value::null = Value::nullSingleton();

    // static
    Value const& Value::nullRef = Value::nullSingleton();
#endif

#if !defined(JSON_USE_INT64_DOUBLE_CONVERSION)
    template <typename T, typename U>
    static inline bool InRange(double d, T min, U max) {
        // The casts can lose precision, but we are looking only for
        // an approximate range. Might fail on edge cases though. ~cdunn
        return d >= static_cast<double>(min) && d <= static_cast<double>(max);
    }
#else  // if !defined(JSON_USE_INT64_DOUBLE_CONVERSION)
    static inline double integerToDouble(Json::UInt64 value) {
        return static_cast<double>(Int64(value / 2)) * 2.0 +
            static_cast<double>(Int64(value & 1));
    }

    template <typename T> static inline double integerToDouble(T value) {
        return static_cast<double>(value);
    }

    template <typename T, typename U>
    static inline bool InRange(double d, T min, U max) {
        return d >= integerToDouble(min) && d <= integerToDouble(max);
    }
#endif // if !defined(JSON_USE_INT64_DOUBLE_CONVERSION)

    /** Duplicates the specified string value.
     * @param value Pointer to the string to duplicate. Must be zero-terminated if
     *              length is "unknown".
     * @param length Length of the value. if equals to unknown, then it will be
     *               computed using strlen(value).
     * @return Pointer on the duplicate instance of string.
     */
    static inline char* duplicateStringValue(const char* value, size_t length) {
        // Avoid an integer overflow in the call to malloc below by limiting length
        // to a sane value.
        if (length >= static_cast<size_t>(Value::maxInt))
            length = Value::maxInt - 1;

        char* newString = static_cast<char*>(malloc(length + 1));
        if (newString == nullptr) {
            throwRuntimeError("in Json::Value::duplicateStringValue(): "
                "Failed to allocate string value buffer");
        }
        memcpy(newString, value, length);
        newString[length] = 0;
        return newString;
    }

    /* Record the length as a prefix.
     */
    static inline char* duplicateAndPrefixStringValue(const char* value,
        unsigned int length) {
        // Avoid an integer overflow in the call to malloc below by limiting length
        // to a sane value.
        JSON_ASSERT_MESSAGE(length <= static_cast<unsigned>(Value::maxInt) -
            sizeof(unsigned) - 1U,
            "in Json::Value::duplicateAndPrefixStringValue(): "
            "length too big for prefixing");
        unsigned actualLength = length + static_cast<unsigned>(sizeof(unsigned)) + 1U;
        char* newString = static_cast<char*>(malloc(actualLength));
        if (newString == nullptr) {
            throwRuntimeError("in Json::Value::duplicateAndPrefixStringValue(): "
                "Failed to allocate string value buffer");
        }
        *reinterpret_cast<unsigned*>(newString) = length;
        memcpy(newString + sizeof(unsigned), value, length);
        newString[actualLength - 1U] =
            0; // to avoid buffer over-run accidents by users later
        return newString;
    }
    inline static void decodePrefixedString(bool isPrefixed, char const* prefixed,
        unsigned* length, char const** value) {
        if (!isPrefixed) {
            *length = static_cast<unsigned>(strlen(prefixed));
            *value = prefixed;
        } else {
            *length = *reinterpret_cast<unsigned const*>(prefixed);
            *value = prefixed + sizeof(unsigned);
        }
    }
    /** Free the string duplicated by
     * duplicateStringValue()/duplicateAndPrefixStringValue().
     */
#if JSONCPP_USING_SECURE_MEMORY
    static inline void releasePrefixedStringValue(char* value) {
        unsigned length = 0;
        char const* valueDecoded;
        decodePrefixedString(true, value, &length, &valueDecoded);
        size_t const size = sizeof(unsigned) + length + 1U;
        memset(value, 0, size);
        free(value);
    }
    static inline void releaseStringValue(char* value, unsigned length) {
        // length==0 => we allocated the strings memory
        size_t size = (length == 0) ? strlen(value) : length;
        memset(value, 0, size);
        free(value);
    }
#else  // !JSONCPP_USING_SECURE_MEMORY
    static inline void releasePrefixedStringValue(char* value) { free(value); }
    static inline void releaseStringValue(char* value, unsigned) { free(value); }
#endif // JSONCPP_USING_SECURE_MEMORY

} // namespace Json

// //////////////////////////////////////////////////////////////////
// //////////////////////////////////////////////////////////////////
// //////////////////////////////////////////////////////////////////
// ValueInternals...
// //////////////////////////////////////////////////////////////////
// //////////////////////////////////////////////////////////////////
// //////////////////////////////////////////////////////////////////
#if !defined(JSON_IS_AMALGAMATION)

#include "json_valueiterator.inl"
#endif // if !defined(JSON_IS_AMALGAMATION)

namespace Json {

#if JSON_USE_EXCEPTION
    Exception::Exception(String msg) : msg_(std::move(msg)) {}
    Exception::~Exception() JSONCPP_NOEXCEPT = default;
    char const* Exception::what() const JSONCPP_NOEXCEPT { return msg_.c_str(); }
    RuntimeError::RuntimeError(String const& msg) : Exception(msg) {}
    LogicError::LogicError(String const& msg) : Exception(msg) {}
    JSONCPP_NORETURN void throwRuntimeError(String const& msg) {
        throw RuntimeError(msg);
    }
    JSONCPP_NORETURN void throwLogicError(String const& msg) {
        throw LogicError(msg);
    }
#else // !JSON_USE_EXCEPTION
    JSONCPP_NORETURN void throwRuntimeError(String const& msg) { abort(); }
    JSONCPP_NORETURN void throwLogicError(String const& msg) { abort(); }
#endif

    // //////////////////////////////////////////////////////////////////
    // //////////////////////////////////////////////////////////////////
    // //////////////////////////////////////////////////////////////////
    // class Value::CZString
    // //////////////////////////////////////////////////////////////////
    // //////////////////////////////////////////////////////////////////
    // //////////////////////////////////////////////////////////////////

    // Notes: policy_ indicates if the string was allocated when
    // a string is stored.

    Value::CZString::CZString(ArrayIndex index) : cstr_(nullptr), index_(index) {}

    Value::CZString::CZString(char const* str, unsigned length,
        DuplicationPolicy allocate)
        : cstr_(str) {
        // allocate != duplicate
        storage_.policy_ = allocate & 0x3;
        storage_.length_ = length & 0x3FFFFFFF;
    }

    Value::CZString::CZString(const CZString& other) {
        cstr_ = (other.storage_.policy_ != noDuplication && other.cstr_ != nullptr
            ? duplicateStringValue(other.cstr_, other.storage_.length_)
            : other.cstr_);
        storage_.policy_ =
            static_cast<unsigned>(
                other.cstr_
                ? (static_cast<DuplicationPolicy>(other.storage_.policy_) ==
                    noDuplication
                    ? noDuplication
                    : duplicate)
                : static_cast<DuplicationPolicy>(other.storage_.policy_)) &
            3U;
        storage_.length_ = other.storage_.length_;
    }

    Value::CZString::CZString(CZString&& other)
        : cstr_(other.cstr_), index_(other.index_) {
        other.cstr_ = nullptr;
    }

    Value::CZString::~CZString() {
        if (cstr_ && storage_.policy_ == duplicate) {
            releaseStringValue(const_cast<char*>(cstr_),
                storage_.length_ + 1U); // +1 for null terminating
                                        // character for sake of
                                        // completeness but not actually
                                        // necessary
        }
    }

    void Value::CZString::swap(CZString& other) {
        std::swap(cstr_, other.cstr_);
        std::swap(index_, other.index_);
    }

    Value::CZString& Value::CZString::operator=(const CZString& other) {
        cstr_ = other.cstr_;
        index_ = other.index_;
        return *this;
    }

    Value::CZString& Value::CZString::operator=(CZString&& other) {
        cstr_ = other.cstr_;
        index_ = other.index_;
        other.cstr_ = nullptr;
        return *this;
    }

    bool Value::CZString::operator<(const CZString& other) const {
        if (!cstr_)
            return index_ < other.index_;
        // return strcmp(cstr_, other.cstr_) < 0;
        // Assume both are strings.
        unsigned this_len = this->storage_.length_;
        unsigned other_len = other.storage_.length_;
        unsigned min_len = std::min<unsigned>(this_len, other_len);
        JSON_ASSERT(this->cstr_ && other.cstr_);
        int comp = memcmp(this->cstr_, other.cstr_, min_len);
        if (comp < 0)
            return true;
        if (comp > 0)
            return false;
        return (this_len < other_len);
    }

    bool Value::CZString::operator==(const CZString& other) const {
        if (!cstr_)
            return index_ == other.index_;
        // return strcmp(cstr_, other.cstr_) == 0;
        // Assume both are strings.
        unsigned this_len = this->storage_.length_;
        unsigned other_len = other.storage_.length_;
        if (this_len != other_len)
            return false;
        JSON_ASSERT(this->cstr_ && other.cstr_);
        int comp = memcmp(this->cstr_, other.cstr_, this_len);
        return comp == 0;
    }

    ArrayIndex Value::CZString::index() const { return index_; }

    // const char* Value::CZString::c_str() const { return cstr_; }
    const char* Value::CZString::data() const { return cstr_; }
    unsigned Value::CZString::length() const { return storage_.length_; }
    bool Value::CZString::isStaticString() const {
        return storage_.policy_ == noDuplication;
    }

    // //////////////////////////////////////////////////////////////////
    // //////////////////////////////////////////////////////////////////
    // //////////////////////////////////////////////////////////////////
    // class Value::Value
    // //////////////////////////////////////////////////////////////////
    // //////////////////////////////////////////////////////////////////
    // //////////////////////////////////////////////////////////////////

    /*! \internal Default constructor initialization must be equivalent to:
     * memset( this, 0, sizeof(Value) )
     * This optimization is used in ValueInternalMap fast allocator.
     */
    Value::Value(ValueType type) {
        static char const emptyString[] = "";
        initBasic(type);
        switch (type) {
        case nullValue:
            break;
        case intValue:
        case uintValue:
            value_.int_ = 0;
            break;
        case realValue:
            value_.real_ = 0.0;
            break;
        case stringValue:
            // allocated_ == false, so this is safe.
            value_.string_ = const_cast<char*>(static_cast<char const*>(emptyString));
            break;
        case arrayValue:
        case objectValue:
            value_.map_ = new ObjectValues();
            break;
        case booleanValue:
            value_.bool_ = false;
            break;
        default:
            JSON_ASSERT_UNREACHABLE;
        }
    }

    Value::Value(Int value) {
        initBasic(intValue);
        value_.int_ = value;
    }

    Value::Value(UInt value) {
        initBasic(uintValue);
        value_.uint_ = value;
    }
#if defined(JSON_HAS_INT64)
    Value::Value(Int64 value) {
        initBasic(intValue);
        value_.int_ = value;
    }
    Value::Value(UInt64 value) {
        initBasic(uintValue);
        value_.uint_ = value;
    }
#endif // defined(JSON_HAS_INT64)

    Value::Value(double value) {
        initBasic(realValue);
        value_.real_ = value;
    }

    Value::Value(const char* value) {
        initBasic(stringValue, true);
        JSON_ASSERT_MESSAGE(value != nullptr,
            "Null Value Passed to Value Constructor");
        value_.string_ = duplicateAndPrefixStringValue(
            value, static_cast<unsigned>(strlen(value)));
    }

    Value::Value(const char* begin, const char* end) {
        initBasic(stringValue, true);
        value_.string_ =
            duplicateAndPrefixStringValue(begin, static_cast<unsigned>(end - begin));
    }

    Value::Value(const String& value) {
        initBasic(stringValue, true);
        value_.string_ = duplicateAndPrefixStringValue(
            value.data(), static_cast<unsigned>(value.length()));
    }

    Value::Value(const StaticString& value) {
        initBasic(stringValue);
        value_.string_ = const_cast<char*>(value.c_str());
    }

#ifdef JSON_USE_CPPTL
    Value::Value(const CppTL::ConstString& value) {
        initBasic(stringValue, true);
        value_.string_ = duplicateAndPrefixStringValue(
            value, static_cast<unsigned>(value.length()));
    }
#endif

    Value::Value(bool value) {
        initBasic(booleanValue);
        value_.bool_ = value;
    }

    Value::Value(const Value& other) {
        dupPayload(other);
        dupMeta(other);
    }

    Value::Value(Value&& other) {
        initBasic(nullValue);
        swap(other);
    }

    Value::~Value() {
        releasePayload();
        value_.uint_ = 0;
    }

    Value& Value::operator=(const Value& other) {
        Value(other).swap(*this);
        return *this;
    }

    Value& Value::operator=(Value&& other) {
        other.swap(*this);
        return *this;
    }

    void Value::swapPayload(Value& other) {
        std::swap(bits_, other.bits_);
        std::swap(value_, other.value_);
    }

    void Value::copyPayload(const Value& other) {
        releasePayload();
        dupPayload(other);
    }

    void Value::swap(Value& other) {
        swapPayload(other);
        std::swap(comments_, other.comments_);
        std::swap(start_, other.start_);
        std::swap(limit_, other.limit_);
    }

    void Value::copy(const Value& other) {
        copyPayload(other);
        dupMeta(other);
    }

    ValueType Value::type() const {
        return static_cast<ValueType>(bits_.value_type_);
    }

    int Value::compare(const Value& other) const {
        if (*this < other)
            return -1;
        if (*this > other)
            return 1;
        return 0;
    }

    bool Value::operator<(const Value& other) const {
        int typeDelta = type() - other.type();
        if (typeDelta)
            return typeDelta < 0;
        switch (type()) {
        case nullValue:
            return false;
        case intValue:
            return value_.int_ < other.value_.int_;
        case uintValue:
            return value_.uint_ < other.value_.uint_;
        case realValue:
            return value_.real_ < other.value_.real_;
        case booleanValue:
            return value_.bool_ < other.value_.bool_;
        case stringValue: {
            if ((value_.string_ == nullptr) || (other.value_.string_ == nullptr)) {
                return other.value_.string_ != nullptr;
            }
            unsigned this_len;
            unsigned other_len;
            char const* this_str;
            char const* other_str;
            decodePrefixedString(this->isAllocated(), this->value_.string_, &this_len,
                &this_str);
            decodePrefixedString(other.isAllocated(), other.value_.string_, &other_len,
                &other_str);
            unsigned min_len = std::min<unsigned>(this_len, other_len);
            JSON_ASSERT(this_str && other_str);
            int comp = memcmp(this_str, other_str, min_len);
            if (comp < 0)
                return true;
            if (comp > 0)
                return false;
            return (this_len < other_len);
        }
        case arrayValue:
        case objectValue: {
            int delta = int(value_.map_->size() - other.value_.map_->size());
            if (delta)
                return delta < 0;
            return (*value_.map_) < (*other.value_.map_);
        }
        default:
            JSON_ASSERT_UNREACHABLE;
        }
        return false; // unreachable
    }

    bool Value::operator<=(const Value& other) const { return !(other < *this); }

    bool Value::operator>=(const Value& other) const { return !(*this < other); }

    bool Value::operator>(const Value& other) const { return other < *this; }

    bool Value::operator==(const Value& other) const {
        if (type() != other.type())
            return false;
        switch (type()) {
        case nullValue:
            return true;
        case intValue:
            return value_.int_ == other.value_.int_;
        case uintValue:
            return value_.uint_ == other.value_.uint_;
        case realValue:
            return value_.real_ == other.value_.real_;
        case booleanValue:
            return value_.bool_ == other.value_.bool_;
        case stringValue: {
            if ((value_.string_ == nullptr) || (other.value_.string_ == nullptr)) {
                return (value_.string_ == other.value_.string_);
            }
            unsigned this_len;
            unsigned other_len;
            char const* this_str;
            char const* other_str;
            decodePrefixedString(this->isAllocated(), this->value_.string_, &this_len,
                &this_str);
            decodePrefixedString(other.isAllocated(), other.value_.string_, &other_len,
                &other_str);
            if (this_len != other_len)
                return false;
            JSON_ASSERT(this_str && other_str);
            int comp = memcmp(this_str, other_str, this_len);
            return comp == 0;
        }
        case arrayValue:
        case objectValue:
            return value_.map_->size() == other.value_.map_->size() &&
                (*value_.map_) == (*other.value_.map_);
        default:
            JSON_ASSERT_UNREACHABLE;
        }
        return false; // unreachable
    }

    bool Value::operator!=(const Value& other) const { return !(*this == other); }

    const char* Value::asCString() const {
        JSON_ASSERT_MESSAGE(type() == stringValue,
            "in Json::Value::asCString(): requires stringValue");
        if (value_.string_ == nullptr)
            return nullptr;
        unsigned this_len;
        char const* this_str;
        decodePrefixedString(this->isAllocated(), this->value_.string_, &this_len,
            &this_str);
        return this_str;
    }

#if JSONCPP_USING_SECURE_MEMORY
    unsigned Value::getCStringLength() const {
        JSON_ASSERT_MESSAGE(type() == stringValue,
            "in Json::Value::asCString(): requires stringValue");
        if (value_.string_ == 0)
            return 0;
        unsigned this_len;
        char const* this_str;
        decodePrefixedString(this->isAllocated(), this->value_.string_, &this_len,
            &this_str);
        return this_len;
    }
#endif

    bool Value::getString(char const** begin, char const** end) const {
        if (type() != stringValue)
            return false;
        if (value_.string_ == nullptr)
            return false;
        unsigned length;
        decodePrefixedString(this->isAllocated(), this->value_.string_, &length,
            begin);
        *end = *begin + length;
        return true;
    }

    String Value::asString() const {
        switch (type()) {
        case nullValue:
            return "";
        case stringValue: {
            if (value_.string_ == nullptr)
                return "";
            unsigned this_len;
            char const* this_str;
            decodePrefixedString(this->isAllocated(), this->value_.string_, &this_len,
                &this_str);
            return String(this_str, this_len);
        }
        case booleanValue:
            return value_.bool_ ? "true" : "false";
        case intValue:
            return valueToString(value_.int_);
        case uintValue:
            return valueToString(value_.uint_);
        case realValue:
            return valueToString(value_.real_);
        default:
            JSON_FAIL_MESSAGE("Type is not convertible to string");
        }
    }

#ifdef JSON_USE_CPPTL
    CppTL::ConstString Value::asConstString() const {
        unsigned len;
        char const* str;
        decodePrefixedString(isAllocated(), value_.string_, &len, &str);
        return CppTL::ConstString(str, len);
    }
#endif

    Value::Int Value::asInt() const {
        switch (type()) {
        case intValue:
            JSON_ASSERT_MESSAGE(isInt(), "LargestInt out of Int range");
            return Int(value_.int_);
        case uintValue:
            JSON_ASSERT_MESSAGE(isInt(), "LargestUInt out of Int range");
            return Int(value_.uint_);
        case realValue:
            JSON_ASSERT_MESSAGE(InRange(value_.real_, minInt, maxInt),
                "double out of Int range");
            return Int(value_.real_);
        case nullValue:
            return 0;
        case booleanValue:
            return value_.bool_ ? 1 : 0;
        default:
            break;
        }
        JSON_FAIL_MESSAGE("Value is not convertible to Int.");
    }

    Value::UInt Value::asUInt() const {
        switch (type()) {
        case intValue:
            JSON_ASSERT_MESSAGE(isUInt(), "LargestInt out of UInt range");
            return UInt(value_.int_);
        case uintValue:
            JSON_ASSERT_MESSAGE(isUInt(), "LargestUInt out of UInt range");
            return UInt(value_.uint_);
        case realValue:
            JSON_ASSERT_MESSAGE(InRange(value_.real_, 0, maxUInt),
                "double out of UInt range");
            return UInt(value_.real_);
        case nullValue:
            return 0;
        case booleanValue:
            return value_.bool_ ? 1 : 0;
        default:
            break;
        }
        JSON_FAIL_MESSAGE("Value is not convertible to UInt.");
    }

#if defined(JSON_HAS_INT64)

    Value::Int64 Value::asInt64() const {
        switch (type()) {
        case intValue:
            return Int64(value_.int_);
        case uintValue:
            JSON_ASSERT_MESSAGE(isInt64(), "LargestUInt out of Int64 range");
            return Int64(value_.uint_);
        case realValue:
            JSON_ASSERT_MESSAGE(InRange(value_.real_, minInt64, maxInt64),
                "double out of Int64 range");
            return Int64(value_.real_);
        case nullValue:
            return 0;
        case booleanValue:
            return value_.bool_ ? 1 : 0;
        default:
            break;
        }
        JSON_FAIL_MESSAGE("Value is not convertible to Int64.");
    }

    Value::UInt64 Value::asUInt64() const {
        switch (type()) {
        case intValue:
            JSON_ASSERT_MESSAGE(isUInt64(), "LargestInt out of UInt64 range");
            return UInt64(value_.int_);
        case uintValue:
            return UInt64(value_.uint_);
        case realValue:
            JSON_ASSERT_MESSAGE(InRange(value_.real_, 0, maxUInt64),
                "double out of UInt64 range");
            return UInt64(value_.real_);
        case nullValue:
            return 0;
        case booleanValue:
            return value_.bool_ ? 1 : 0;
        default:
            break;
        }
        JSON_FAIL_MESSAGE("Value is not convertible to UInt64.");
    }
#endif // if defined(JSON_HAS_INT64)

    LargestInt Value::asLargestInt() const {
#if defined(JSON_NO_INT64)
        return asInt();
#else
        return asInt64();
#endif
    }

    LargestUInt Value::asLargestUInt() const {
#if defined(JSON_NO_INT64)
        return asUInt();
#else
        return asUInt64();
#endif
    }

    double Value::asDouble() const {
        switch (type()) {
        case intValue:
            return static_cast<double>(value_.int_);
        case uintValue:
#if !defined(JSON_USE_INT64_DOUBLE_CONVERSION)
            return static_cast<double>(value_.uint_);
#else  // if !defined(JSON_USE_INT64_DOUBLE_CONVERSION)
            return integerToDouble(value_.uint_);
#endif // if !defined(JSON_USE_INT64_DOUBLE_CONVERSION)
        case realValue:
            return value_.real_;
        case nullValue:
            return 0.0;
        case booleanValue:
            return value_.bool_ ? 1.0 : 0.0;
        default:
            break;
        }
        JSON_FAIL_MESSAGE("Value is not convertible to double.");
    }

    float Value::asFloat() const {
        switch (type()) {
        case intValue:
            return static_cast<float>(value_.int_);
        case uintValue:
#if !defined(JSON_USE_INT64_DOUBLE_CONVERSION)
            return static_cast<float>(value_.uint_);
#else  // if !defined(JSON_USE_INT64_DOUBLE_CONVERSION)
            // This can fail (silently?) if the value is bigger than MAX_FLOAT.
            return static_cast<float>(integerToDouble(value_.uint_));
#endif // if !defined(JSON_USE_INT64_DOUBLE_CONVERSION)
        case realValue:
            return static_cast<float>(value_.real_);
        case nullValue:
            return 0.0;
        case booleanValue:
            return value_.bool_ ? 1.0F : 0.0F;
        default:
            break;
        }
        JSON_FAIL_MESSAGE("Value is not convertible to float.");
    }

    bool Value::asBool() const {
        switch (type()) {
        case booleanValue:
            return value_.bool_;
        case nullValue:
            return false;
        case intValue:
            return value_.int_ != 0;
        case uintValue:
            return value_.uint_ != 0;
        case realValue: {
            // According to JavaScript language zero or NaN is regarded as false
            const auto value_classification = std::fpclassify(value_.real_);
            return value_classification != FP_ZERO && value_classification != FP_NAN;
        }
        default:
            break;
        }
        JSON_FAIL_MESSAGE("Value is not convertible to bool.");
    }

    bool Value::isConvertibleTo(ValueType other) const {
        switch (other) {
        case nullValue:
            return (isNumeric() && asDouble() == 0.0) ||
                (type() == booleanValue && !value_.bool_) ||
                (type() == stringValue && asString().empty()) ||
                (type() == arrayValue && value_.map_->empty()) ||
                (type() == objectValue && value_.map_->empty()) ||
                type() == nullValue;
        case intValue:
            return isInt() ||
                (type() == realValue && InRange(value_.real_, minInt, maxInt)) ||
                type() == booleanValue || type() == nullValue;
        case uintValue:
            return isUInt() ||
                (type() == realValue && InRange(value_.real_, 0, maxUInt)) ||
                type() == booleanValue || type() == nullValue;
        case realValue:
            return isNumeric() || type() == booleanValue || type() == nullValue;
        case booleanValue:
            return isNumeric() || type() == booleanValue || type() == nullValue;
        case stringValue:
            return isNumeric() || type() == booleanValue || type() == stringValue ||
                type() == nullValue;
        case arrayValue:
            return type() == arrayValue || type() == nullValue;
        case objectValue:
            return type() == objectValue || type() == nullValue;
        }
        JSON_ASSERT_UNREACHABLE;
        return false;
    }

    /// Number of values in array or object
    ArrayIndex Value::size() const {
        switch (type()) {
        case nullValue:
        case intValue:
        case uintValue:
        case realValue:
        case booleanValue:
        case stringValue:
            return 0;
        case arrayValue: // size of the array is highest index + 1
            if (!value_.map_->empty()) {
                ObjectValues::const_iterator itLast = value_.map_->end();
                --itLast;
                return (*itLast).first.index() + 1;
            }
            return 0;
        case objectValue:
            return ArrayIndex(value_.map_->size());
        }
        JSON_ASSERT_UNREACHABLE;
        return 0; // unreachable;
    }

    bool Value::empty() const {
        if (isNull() || isArray() || isObject())
            return size() == 0U;
        else
            return false;
    }

    Value::operator bool() const { return !isNull(); }

    void Value::clear() {
        JSON_ASSERT_MESSAGE(type() == nullValue || type() == arrayValue ||
            type() == objectValue,
            "in Json::Value::clear(): requires complex value");
        start_ = 0;
        limit_ = 0;
        switch (type()) {
        case arrayValue:
        case objectValue:
            value_.map_->clear();
            break;
        default:
            break;
        }
    }

    void Value::resize(ArrayIndex newSize) {
        JSON_ASSERT_MESSAGE(type() == nullValue || type() == arrayValue,
            "in Json::Value::resize(): requires arrayValue");
        if (type() == nullValue)
            *this = Value(arrayValue);
        ArrayIndex oldSize = size();
        if (newSize == 0)
            clear();
        else if (newSize > oldSize)
            this->operator[](newSize - 1);
        else {
            for (ArrayIndex index = newSize; index < oldSize; ++index) {
                value_.map_->erase(index);
            }
            JSON_ASSERT(size() == newSize);
        }
    }

    Value& Value::operator[](ArrayIndex index) {
        JSON_ASSERT_MESSAGE(
            type() == nullValue || type() == arrayValue,
            "in Json::Value::operator[](ArrayIndex): requires arrayValue");
        if (type() == nullValue)
            *this = Value(arrayValue);
        CZString key(index);
        auto it = value_.map_->lower_bound(key);
        if (it != value_.map_->end() && (*it).first == key)
            return (*it).second;

        ObjectValues::value_type defaultValue(key, nullSingleton());
        it = value_.map_->insert(it, defaultValue);
        return (*it).second;
    }

    Value& Value::operator[](int index) {
        JSON_ASSERT_MESSAGE(
            index >= 0,
            "in Json::Value::operator[](int index): index cannot be negative");
        return (*this)[ArrayIndex(index)];
    }

    const Value& Value::operator[](ArrayIndex index) const {
        JSON_ASSERT_MESSAGE(
            type() == nullValue || type() == arrayValue,
            "in Json::Value::operator[](ArrayIndex)const: requires arrayValue");
        if (type() == nullValue)
            return nullSingleton();
        CZString key(index);
        ObjectValues::const_iterator it = value_.map_->find(key);
        if (it == value_.map_->end())
            return nullSingleton();
        return (*it).second;
    }

    const Value& Value::operator[](int index) const {
        JSON_ASSERT_MESSAGE(
            index >= 0,
            "in Json::Value::operator[](int index) const: index cannot be negative");
        return (*this)[ArrayIndex(index)];
    }

    void Value::initBasic(ValueType type, bool allocated) {
        setType(type);
        setIsAllocated(allocated);
        comments_ = Comments{};
        start_ = 0;
        limit_ = 0;
    }

    void Value::dupPayload(const Value& other) {
        setType(other.type());
        setIsAllocated(false);
        switch (type()) {
        case nullValue:
        case intValue:
        case uintValue:
        case realValue:
        case booleanValue:
            value_ = other.value_;
            break;
        case stringValue:
            if (other.value_.string_ && other.isAllocated()) {
                unsigned len;
                char const* str;
                decodePrefixedString(other.isAllocated(), other.value_.string_, &len,
                    &str);
                value_.string_ = duplicateAndPrefixStringValue(str, len);
                setIsAllocated(true);
            } else {
                value_.string_ = other.value_.string_;
            }
            break;
        case arrayValue:
        case objectValue:
            value_.map_ = new ObjectValues(*other.value_.map_);
            break;
        default:
            JSON_ASSERT_UNREACHABLE;
        }
    }

    void Value::releasePayload() {
        switch (type()) {
        case nullValue:
        case intValue:
        case uintValue:
        case realValue:
        case booleanValue:
            break;
        case stringValue:
            if (isAllocated())
                releasePrefixedStringValue(value_.string_);
            break;
        case arrayValue:
        case objectValue:
            delete value_.map_;
            break;
        default:
            JSON_ASSERT_UNREACHABLE;
        }
    }

    void Value::dupMeta(const Value& other) {
        comments_ = other.comments_;
        start_ = other.start_;
        limit_ = other.limit_;
    }

    // Access an object value by name, create a null member if it does not exist.
    // @pre Type of '*this' is object or null.
    // @param key is null-terminated.
    Value& Value::resolveReference(const char* key) {
        JSON_ASSERT_MESSAGE(
            type() == nullValue || type() == objectValue,
            "in Json::Value::resolveReference(): requires objectValue");
        if (type() == nullValue)
            *this = Value(objectValue);
        CZString actualKey(key, static_cast<unsigned>(strlen(key)),
            CZString::noDuplication); // NOTE!
        auto it = value_.map_->lower_bound(actualKey);
        if (it != value_.map_->end() && (*it).first == actualKey)
            return (*it).second;

        ObjectValues::value_type defaultValue(actualKey, nullSingleton());
        it = value_.map_->insert(it, defaultValue);
        Value& value = (*it).second;
        return value;
    }

    // @param key is not null-terminated.
    Value& Value::resolveReference(char const* key, char const* end) {
        JSON_ASSERT_MESSAGE(
            type() == nullValue || type() == objectValue,
            "in Json::Value::resolveReference(key, end): requires objectValue");
        if (type() == nullValue)
            *this = Value(objectValue);
        CZString actualKey(key, static_cast<unsigned>(end - key),
            CZString::duplicateOnCopy);
        auto it = value_.map_->lower_bound(actualKey);
        if (it != value_.map_->end() && (*it).first == actualKey)
            return (*it).second;

        ObjectValues::value_type defaultValue(actualKey, nullSingleton());
        it = value_.map_->insert(it, defaultValue);
        Value& value = (*it).second;
        return value;
    }

    Value Value::get(ArrayIndex index, const Value& defaultValue) const {
        const Value* value = &((*this)[index]);
        return value == &nullSingleton() ? defaultValue : *value;
    }

    bool Value::isValidIndex(ArrayIndex index) const { return index < size(); }

    Value const* Value::find(char const* begin, char const* end) const {
        JSON_ASSERT_MESSAGE(type() == nullValue || type() == objectValue,
            "in Json::Value::find(begin, end): requires "
            "objectValue or nullValue");
        if (type() == nullValue)
            return nullptr;
        CZString actualKey(begin, static_cast<unsigned>(end - begin),
            CZString::noDuplication);
        ObjectValues::const_iterator it = value_.map_->find(actualKey);
        if (it == value_.map_->end())
            return nullptr;
        return &(*it).second;
    }
    Value* Value::demand(char const* begin, char const* end) {
        JSON_ASSERT_MESSAGE(type() == nullValue || type() == objectValue,
            "in Json::Value::demand(begin, end): requires "
            "objectValue or nullValue");
        return &resolveReference(begin, end);
    }
    const Value& Value::operator[](const char* key) const {
        Value const* found = find(key, key + strlen(key));
        if (!found)
            return nullSingleton();
        return *found;
    }
    Value const& Value::operator[](const String& key) const {
        Value const* found = find(key.data(), key.data() + key.length());
        if (!found)
            return nullSingleton();
        return *found;
    }

    Value& Value::operator[](const char* key) {
        return resolveReference(key, key + strlen(key));
    }

    Value& Value::operator[](const String& key) {
        return resolveReference(key.data(), key.data() + key.length());
    }

    Value& Value::operator[](const StaticString& key) {
        return resolveReference(key.c_str());
    }

#ifdef JSON_USE_CPPTL
    Value& Value::operator[](const CppTL::ConstString& key) {
        return resolveReference(key.c_str(), key.end_c_str());
    }
    Value const& Value::operator[](CppTL::ConstString const& key) const {
        Value const* found = find(key.c_str(), key.end_c_str());
        if (!found)
            return nullSingleton();
        return *found;
    }
#endif

    Value& Value::append(const Value& value) { return append(Value(value)); }

    Value& Value::append(Value&& value) {
        JSON_ASSERT_MESSAGE(type() == nullValue || type() == arrayValue,
            "in Json::Value::append: requires arrayValue");
        if (type() == nullValue) {
            *this = Value(arrayValue);
        }
        return this->value_.map_->emplace(size(), std::move(value)).first->second;
    }

    bool Value::insert(ArrayIndex index, Value newValue) {
        JSON_ASSERT_MESSAGE(type() == nullValue || type() == arrayValue,
            "in Json::Value::insert: requires arrayValue");
        ArrayIndex length = size();
        if (index > length) {
            return false;
        } else {
            for (ArrayIndex i = length; i > index; i--) {
                (*this)[i] = std::move((*this)[i - 1]);
            }
            (*this)[index] = std::move(newValue);
            return true;
        }
    }

    Value Value::get(char const* begin, char const* end,
        Value const& defaultValue) const {
        Value const* found = find(begin, end);
        return !found ? defaultValue : *found;
    }
    Value Value::get(char const* key, Value const& defaultValue) const {
        return get(key, key + strlen(key), defaultValue);
    }
    Value Value::get(String const& key, Value const& defaultValue) const {
        return get(key.data(), key.data() + key.length(), defaultValue);
    }

    bool Value::removeMember(const char* begin, const char* end, Value* removed) {
        if (type() != objectValue) {
            return false;
        }
        CZString actualKey(begin, static_cast<unsigned>(end - begin),
            CZString::noDuplication);
        auto it = value_.map_->find(actualKey);
        if (it == value_.map_->end())
            return false;
        if (removed)
            *removed = std::move(it->second);
        value_.map_->erase(it);
        return true;
    }
    bool Value::removeMember(const char* key, Value* removed) {
        return removeMember(key, key + strlen(key), removed);
    }
    bool Value::removeMember(String const& key, Value* removed) {
        return removeMember(key.data(), key.data() + key.length(), removed);
    }
    void Value::removeMember(const char* key) {
        JSON_ASSERT_MESSAGE(type() == nullValue || type() == objectValue,
            "in Json::Value::removeMember(): requires objectValue");
        if (type() == nullValue)
            return;

        CZString actualKey(key, unsigned(strlen(key)), CZString::noDuplication);
        value_.map_->erase(actualKey);
    }
    void Value::removeMember(const String& key) { removeMember(key.c_str()); }

    bool Value::removeIndex(ArrayIndex index, Value* removed) {
        if (type() != arrayValue) {
            return false;
        }
        CZString key(index);
        auto it = value_.map_->find(key);
        if (it == value_.map_->end()) {
            return false;
        }
        if (removed)
            *removed = it->second;
        ArrayIndex oldSize = size();
        // shift left all items left, into the place of the "removed"
        for (ArrayIndex i = index; i < (oldSize - 1); ++i) {
            CZString keey(i);
            (*value_.map_)[keey] = (*this)[i + 1];
        }
        // erase the last one ("leftover")
        CZString keyLast(oldSize - 1);
        auto itLast = value_.map_->find(keyLast);
        value_.map_->erase(itLast);
        return true;
    }

#ifdef JSON_USE_CPPTL
    Value Value::get(const CppTL::ConstString& key,
        const Value& defaultValue) const {
        return get(key.c_str(), key.end_c_str(), defaultValue);
    }
#endif

    bool Value::isMember(char const* begin, char const* end) const {
        Value const* value = find(begin, end);
        return nullptr != value;
    }
    bool Value::isMember(char const* key) const {
        return isMember(key, key + strlen(key));
    }
    bool Value::isMember(String const& key) const {
        return isMember(key.data(), key.data() + key.length());
    }

#ifdef JSON_USE_CPPTL
    bool Value::isMember(const CppTL::ConstString& key) const {
        return isMember(key.c_str(), key.end_c_str());
    }
#endif

    Value::Members Value::getMemberNames() const {
        JSON_ASSERT_MESSAGE(
            type() == nullValue || type() == objectValue,
            "in Json::Value::getMemberNames(), value must be objectValue");
        if (type() == nullValue)
            return Value::Members();
        Members members;
        members.reserve(value_.map_->size());
        ObjectValues::const_iterator it = value_.map_->begin();
        ObjectValues::const_iterator itEnd = value_.map_->end();
        for (; it != itEnd; ++it) {
            members.push_back(String((*it).first.data(), (*it).first.length()));
        }
        return members;
    }
    //
    //# ifdef JSON_USE_CPPTL
    // EnumMemberNames
    // Value::enumMemberNames() const
    //{
    //   if ( type() == objectValue )
    //   {
    //      return CppTL::Enum::any(  CppTL::Enum::transform(
    //         CppTL::Enum::keys( *(value_.map_), CppTL::Type<const CZString &>() ),
    //         MemberNamesTransform() ) );
    //   }
    //   return EnumMemberNames();
    //}
    //
    //
    // EnumValues
    // Value::enumValues() const
    //{
    //   if ( type() == objectValue  ||  type() == arrayValue )
    //      return CppTL::Enum::anyValues( *(value_.map_),
    //                                     CppTL::Type<const Value &>() );
    //   return EnumValues();
    //}
    //
    //# endif

    static bool IsIntegral(double d) {
        double integral_part;
        return modf(d, &integral_part) == 0.0;
    }

    bool Value::isNull() const { return type() == nullValue; }

    bool Value::isBool() const { return type() == booleanValue; }

    bool Value::isInt() const {
        switch (type()) {
        case intValue:
#if defined(JSON_HAS_INT64)
            return value_.int_ >= minInt && value_.int_ <= maxInt;
#else
            return true;
#endif
        case uintValue:
            return value_.uint_ <= UInt(maxInt);
        case realValue:
            return value_.real_ >= minInt && value_.real_ <= maxInt &&
                IsIntegral(value_.real_);
        default:
            break;
        }
        return false;
    }

    bool Value::isUInt() const {
        switch (type()) {
        case intValue:
#if defined(JSON_HAS_INT64)
            return value_.int_ >= 0 && LargestUInt(value_.int_) <= LargestUInt(maxUInt);
#else
            return value_.int_ >= 0;
#endif
        case uintValue:
#if defined(JSON_HAS_INT64)
            return value_.uint_ <= maxUInt;
#else
            return true;
#endif
        case realValue:
            return value_.real_ >= 0 && value_.real_ <= maxUInt &&
                IsIntegral(value_.real_);
        default:
            break;
        }
        return false;
    }

    bool Value::isInt64() const {
#if defined(JSON_HAS_INT64)
        switch (type()) {
        case intValue:
            return true;
        case uintValue:
            return value_.uint_ <= UInt64(maxInt64);
        case realValue:
            // Note that maxInt64 (= 2^63 - 1) is not exactly representable as a
            // double, so double(maxInt64) will be rounded up to 2^63. Therefore we
            // require the value to be strictly less than the limit.
            return value_.real_ >= double(minInt64) &&
                value_.real_ < double(maxInt64) && IsIntegral(value_.real_);
        default:
            break;
        }
#endif // JSON_HAS_INT64
        return false;
    }

    bool Value::isUInt64() const {
#if defined(JSON_HAS_INT64)
        switch (type()) {
        case intValue:
            return value_.int_ >= 0;
        case uintValue:
            return true;
        case realValue:
            // Note that maxUInt64 (= 2^64 - 1) is not exactly representable as a
            // double, so double(maxUInt64) will be rounded up to 2^64. Therefore we
            // require the value to be strictly less than the limit.
            return value_.real_ >= 0 && value_.real_ < maxUInt64AsDouble &&
                IsIntegral(value_.real_);
        default:
            break;
        }
#endif // JSON_HAS_INT64
        return false;
    }

    bool Value::isIntegral() const {
        switch (type()) {
        case intValue:
        case uintValue:
            return true;
        case realValue:
#if defined(JSON_HAS_INT64)
            // Note that maxUInt64 (= 2^64 - 1) is not exactly representable as a
            // double, so double(maxUInt64) will be rounded up to 2^64. Therefore we
            // require the value to be strictly less than the limit.
            return value_.real_ >= double(minInt64) &&
                value_.real_ < maxUInt64AsDouble && IsIntegral(value_.real_);
#else
            return value_.real_ >= minInt && value_.real_ <= maxUInt &&
                IsIntegral(value_.real_);
#endif // JSON_HAS_INT64
        default:
            break;
        }
        return false;
    }

    bool Value::isDouble() const {
        return type() == intValue || type() == uintValue || type() == realValue;
    }

    bool Value::isNumeric() const { return isDouble(); }

    bool Value::isString() const { return type() == stringValue; }

    bool Value::isArray() const { return type() == arrayValue; }

    bool Value::isObject() const { return type() == objectValue; }

    Value::Comments::Comments(const Comments& that)
        : ptr_{ cloneUnique(that.ptr_) } {}

    Value::Comments::Comments(Comments&& that) : ptr_{ std::move(that.ptr_) } {}

    Value::Comments& Value::Comments::operator=(const Comments& that) {
        ptr_ = cloneUnique(that.ptr_);
        return *this;
    }

    Value::Comments& Value::Comments::operator=(Comments&& that) {
        ptr_ = std::move(that.ptr_);
        return *this;
    }

    bool Value::Comments::has(CommentPlacement slot) const {
        return ptr_ && !(*ptr_)[slot].empty();
    }

    String Value::Comments::get(CommentPlacement slot) const {
        if (!ptr_)
            return {};
        return (*ptr_)[slot];
    }

    void Value::Comments::set(CommentPlacement slot, String comment) {
        if (!ptr_) {
            ptr_ = std::unique_ptr<Array>(new Array());
        }
        // check comments array boundry.
        if (slot < CommentPlacement::numberOfCommentPlacement) {
            (*ptr_)[slot] = std::move(comment);
        }
    }

    void Value::setComment(String comment, CommentPlacement placement) {
        if (!comment.empty() && (comment.back() == '\n')) {
            // Always discard trailing newline, to aid indentation.
            comment.pop_back();
        }
        JSON_ASSERT(!comment.empty());
        JSON_ASSERT_MESSAGE(
            comment[0] == '\0' || comment[0] == '/',
            "in Json::Value::setComment(): Comments must start with /");
        comments_.set(placement, std::move(comment));
    }

    bool Value::hasComment(CommentPlacement placement) const {
        return comments_.has(placement);
    }

    String Value::getComment(CommentPlacement placement) const {
        return comments_.get(placement);
    }

    void Value::setOffsetStart(ptrdiff_t start) { start_ = start; }

    void Value::setOffsetLimit(ptrdiff_t limit) { limit_ = limit; }

    ptrdiff_t Value::getOffsetStart() const { return start_; }

    ptrdiff_t Value::getOffsetLimit() const { return limit_; }

    String Value::toStyledString() const {
        StreamWriterBuilder builder;

        String out = this->hasComment(commentBefore) ? "\n" : "";
        out += Json::writeString(builder, *this);
        out += '\n';

        return out;
    }

    Value::const_iterator Value::begin() const {
        switch (type()) {
        case arrayValue:
        case objectValue:
            if (value_.map_)
                return const_iterator(value_.map_->begin());
            break;
        default:
            break;
        }
        return {};
    }

    Value::const_iterator Value::end() const {
        switch (type()) {
        case arrayValue:
        case objectValue:
            if (value_.map_)
                return const_iterator(value_.map_->end());
            break;
        default:
            break;
        }
        return {};
    }

    Value::iterator Value::begin() {
        switch (type()) {
        case arrayValue:
        case objectValue:
            if (value_.map_)
                return iterator(value_.map_->begin());
            break;
        default:
            break;
        }
        return iterator();
    }

    Value::iterator Value::end() {
        switch (type()) {
        case arrayValue:
        case objectValue:
            if (value_.map_)
                return iterator(value_.map_->end());
            break;
        default:
            break;
        }
        return iterator();
    }

    // class PathArgument
    // //////////////////////////////////////////////////////////////////

    PathArgument::PathArgument() = default;

    PathArgument::PathArgument(ArrayIndex index)
        : index_(index), kind_(kindIndex) {}

    PathArgument::PathArgument(const char* key) : key_(key), kind_(kindKey) {}

    PathArgument::PathArgument(String key) : key_(std::move(key)), kind_(kindKey) {}

    // class Path
    // //////////////////////////////////////////////////////////////////

    Path::Path(const String& path, const PathArgument& a1, const PathArgument& a2,
        const PathArgument& a3, const PathArgument& a4,
        const PathArgument& a5) {
        InArgs in;
        in.reserve(5);
        in.push_back(&a1);
        in.push_back(&a2);
        in.push_back(&a3);
        in.push_back(&a4);
        in.push_back(&a5);
        makePath(path, in);
    }

    void Path::makePath(const String& path, const InArgs& in) {
        const char* current = path.c_str();
        const char* end = current + path.length();
        auto itInArg = in.begin();
        while (current != end) {
            if (*current == '[') {
                ++current;
                if (*current == '%')
                    addPathInArg(path, in, itInArg, PathArgument::kindIndex);
                else {
                    ArrayIndex index = 0;
                    for (; current != end && *current >= '0' && *current <= '9'; ++current)
                        index = index * 10 + ArrayIndex(*current - '0');
                    args_.push_back(index);
                }
                if (current == end || *++current != ']')
                    invalidPath(path, int(current - path.c_str()));
            } else if (*current == '%') {
                addPathInArg(path, in, itInArg, PathArgument::kindKey);
                ++current;
            } else if (*current == '.' || *current == ']') {
                ++current;
            } else {
                const char* beginName = current;
                while (current != end && !strchr("[.", *current))
                    ++current;
                args_.push_back(String(beginName, current));
            }
        }
    }

    void Path::addPathInArg(const String& /*path*/, const InArgs& in,
        InArgs::const_iterator& itInArg,
        PathArgument::Kind kind) {
        if (itInArg == in.end()) {
            // Error: missing argument %d
        } else if ((*itInArg)->kind_ != kind) {
            // Error: bad argument type
        } else {
            args_.push_back(**itInArg++);
        }
    }

    void Path::invalidPath(const String& /*path*/, int /*location*/) {
        // Error: invalid path.
    }

    const Value& Path::resolve(const Value& root) const {
        const Value* node = &root;
        for (const auto& arg : args_) {
            if (arg.kind_ == PathArgument::kindIndex) {
                if (!node->isArray() || !node->isValidIndex(arg.index_)) {
                    // Error: unable to resolve path (array value expected at position... )
                    return Value::nullSingleton();
                }
                node = &((*node)[arg.index_]);
            } else if (arg.kind_ == PathArgument::kindKey) {
                if (!node->isObject()) {
                    // Error: unable to resolve path (object value expected at position...)
                    return Value::nullSingleton();
                }
                node = &((*node)[arg.key_]);
                if (node == &Value::nullSingleton()) {
                    // Error: unable to resolve path (object has no member named '' at
                    // position...)
                    return Value::nullSingleton();
                }
            }
        }
        return *node;
    }

    Value Path::resolve(const Value& root, const Value& defaultValue) const {
        const Value* node = &root;
        for (const auto& arg : args_) {
            if (arg.kind_ == PathArgument::kindIndex) {
                if (!node->isArray() || !node->isValidIndex(arg.index_))
                    return defaultValue;
                node = &((*node)[arg.index_]);
            } else if (arg.kind_ == PathArgument::kindKey) {
                if (!node->isObject())
                    return defaultValue;
                node = &((*node)[arg.key_]);
                if (node == &Value::nullSingleton())
                    return defaultValue;
            }
        }
        return *node;
    }

    Value& Path::make(Value& root) const {
        Value* node = &root;
        for (const auto& arg : args_) {
            if (arg.kind_ == PathArgument::kindIndex) {
                if (!node->isArray()) {
                    // Error: node is not an array at position ...
                }
                node = &((*node)[arg.index_]);
            } else if (arg.kind_ == PathArgument::kindKey) {
                if (!node->isObject()) {
                    // Error: node is not an object at position...
                }
                node = &((*node)[arg.key_]);
            }
        }
        return *node;
    }

} // namespace Json

// //////////////////////////////////////////////////////////////////////
// End of content of file: src/lib_json/json_value.cpp
// //////////////////////////////////////////////////////////////////////






// //////////////////////////////////////////////////////////////////////
// Beginning of content of file: src/lib_json/json_writer.cpp
// //////////////////////////////////////////////////////////////////////

// Copyright 2011 Baptiste Lepilleur and The JsonCpp Authors
// Distributed under MIT license, or public domain if desired and
// recognized in your jurisdiction.
// See file LICENSE for detail or copy at http://jsoncpp.sourceforge.net/LICENSE

#if !defined(JSON_IS_AMALGAMATION)
#include "json_tool.h"
#include <json/writer.h>
#endif // if !defined(JSON_IS_AMALGAMATION)
#include <cassert>
#include <cstring>
#include <iomanip>
#include <memory>
#include <set>
#include <sstream>
#include <utility>

#if __cplusplus >= 201103L
#include <cmath>
#include <cstdio>

#if !defined(isnan)
#define isnan std::isnan
#endif

#if !defined(isfinite)
#define isfinite std::isfinite
#endif

#else
#include <cmath>
#include <cstdio>

#if defined(_MSC_VER)
#if !defined(isnan)
#include <float.h>
#define isnan _isnan
#endif

#if !defined(isfinite)
#include <float.h>
#define isfinite _finite
#endif

#if !defined(_CRT_SECURE_CPP_OVERLOAD_STANDARD_NAMES)
#define _CRT_SECURE_CPP_OVERLOAD_STANDARD_NAMES 1
#endif //_CRT_SECURE_CPP_OVERLOAD_STANDARD_NAMES

#endif //_MSC_VER

#if defined(__sun) && defined(__SVR4) // Solaris
#if !defined(isfinite)
#include <ieeefp.h>
#define isfinite finite
#endif
#endif

#if defined(__hpux)
#if !defined(isfinite)
#if defined(__ia64) && !defined(finite)
#define isfinite(x)                                                            \
  ((sizeof(x) == sizeof(float) ? _Isfinitef(x) : _IsFinite(x)))
#endif
#endif
#endif

#if !defined(isnan)
// IEEE standard states that NaN values will not compare to themselves
#define isnan(x) (x != x)
#endif

#if !defined(__APPLE__)
#if !defined(isfinite)
#define isfinite finite
#endif
#endif
#endif

#if defined(_MSC_VER)
// Disable warning about strdup being deprecated.
#pragma warning(disable : 4996)
#endif

namespace Json {

#if __cplusplus >= 201103L || (defined(_CPPLIB_VER) && _CPPLIB_VER >= 520)
    using StreamWriterPtr = std::unique_ptr<StreamWriter>;
#else
    typedef std::auto_ptr<StreamWriter> StreamWriterPtr;
#endif

    String valueToString(LargestInt value) {
        UIntToStringBuffer buffer;
        char* current = buffer + sizeof(buffer);
        if (value == Value::minLargestInt) {
            uintToString(LargestUInt(Value::maxLargestInt) + 1, current);
            *--current = '-';
        } else if (value < 0) {
            uintToString(LargestUInt(-value), current);
            *--current = '-';
        } else {
            uintToString(LargestUInt(value), current);
        }
        assert(current >= buffer);
        return current;
    }

    String valueToString(LargestUInt value) {
        UIntToStringBuffer buffer;
        char* current = buffer + sizeof(buffer);
        uintToString(value, current);
        assert(current >= buffer);
        return current;
    }

#if defined(JSON_HAS_INT64)

    String valueToString(Int value) { return valueToString(LargestInt(value)); }

    String valueToString(UInt value) { return valueToString(LargestUInt(value)); }

#endif // # if defined(JSON_HAS_INT64)

    namespace {
        String valueToString(double value, bool useSpecialFloats,
            unsigned int precision, PrecisionType precisionType) {
            // Print into the buffer. We need not request the alternative representation
            // that always has a decimal point because JSON doesn't distinguish the
            // concepts of reals and integers.
            if (!isfinite(value)) {
                static const char* const reps[2][3] = { {"NaN", "-Infinity", "Infinity"},
                                                       {"null", "-1e+9999", "1e+9999"} };
                return reps[useSpecialFloats ? 0 : 1]
                    [isnan(value) ? 0 : (value < 0) ? 1 : 2];
            }

            String buffer(size_t(36), '\0');
            while (true) {
                int len = jsoncpp_snprintf(
                    &*buffer.begin(), buffer.size(),
                    (precisionType == PrecisionType::significantDigits) ? "%.*g" : "%.*f",
                    precision, value);
                assert(len >= 0);
                auto wouldPrint = static_cast<size_t>(len);
                if (wouldPrint >= buffer.size()) {
                    buffer.resize(wouldPrint + 1);
                    continue;
                }
                buffer.resize(wouldPrint);
                break;
            }

            buffer.erase(fixNumericLocale(buffer.begin(), buffer.end()), buffer.end());

            // strip the zero padding from the right
            if (precisionType == PrecisionType::decimalPlaces) {
                buffer.erase(fixZerosInTheEnd(buffer.begin(), buffer.end()), buffer.end());
            }

            // try to ensure we preserve the fact that this was given to us as a double on
            // input
            if (buffer.find('.') == buffer.npos && buffer.find('e') == buffer.npos) {
                buffer += ".0";
            }
            return buffer;
        }
    } // namespace

    String valueToString(double value, unsigned int precision,
        PrecisionType precisionType) {
        return valueToString(value, false, precision, precisionType);
    }

    String valueToString(bool value) { return value ? "true" : "false"; }

    static bool isAnyCharRequiredQuoting(char const* s, size_t n) {
        assert(s || !n);

        char const* const end = s + n;
        for (char const* cur = s; cur < end; ++cur) {
            if (*cur == '\\' || *cur == '\"' || *cur < ' ' ||
                static_cast<unsigned char>(*cur) < 0x80)
                return true;
        }
        return false;
    }

    static unsigned int utf8ToCodepoint(const char*& s, const char* e) {
        const unsigned int REPLACEMENT_CHARACTER = 0xFFFD;

        unsigned int firstByte = static_cast<unsigned char>(*s);

        if (firstByte < 0x80)
            return firstByte;

        if (firstByte < 0xE0) {
            if (e - s < 2)
                return REPLACEMENT_CHARACTER;

            unsigned int calculated =
                ((firstByte & 0x1F) << 6) | (static_cast<unsigned int>(s[1]) & 0x3F);
            s += 1;
            // oversized encoded characters are invalid
            return calculated < 0x80 ? REPLACEMENT_CHARACTER : calculated;
        }

        if (firstByte < 0xF0) {
            if (e - s < 3)
                return REPLACEMENT_CHARACTER;

            unsigned int calculated = ((firstByte & 0x0F) << 12) |
                ((static_cast<unsigned int>(s[1]) & 0x3F) << 6) |
                (static_cast<unsigned int>(s[2]) & 0x3F);
            s += 2;
            // surrogates aren't valid codepoints itself
            // shouldn't be UTF-8 encoded
            if (calculated >= 0xD800 && calculated <= 0xDFFF)
                return REPLACEMENT_CHARACTER;
            // oversized encoded characters are invalid
            return calculated < 0x800 ? REPLACEMENT_CHARACTER : calculated;
        }

        if (firstByte < 0xF8) {
            if (e - s < 4)
                return REPLACEMENT_CHARACTER;

            unsigned int calculated = ((firstByte & 0x07) << 18) |
                ((static_cast<unsigned int>(s[1]) & 0x3F) << 12) |
                ((static_cast<unsigned int>(s[2]) & 0x3F) << 6) |
                (static_cast<unsigned int>(s[3]) & 0x3F);
            s += 3;
            // oversized encoded characters are invalid
            return calculated < 0x10000 ? REPLACEMENT_CHARACTER : calculated;
        }

        return REPLACEMENT_CHARACTER;
    }

    static const char hex2[] = "000102030405060708090a0b0c0d0e0f"
        "101112131415161718191a1b1c1d1e1f"
        "202122232425262728292a2b2c2d2e2f"
        "303132333435363738393a3b3c3d3e3f"
        "404142434445464748494a4b4c4d4e4f"
        "505152535455565758595a5b5c5d5e5f"
        "606162636465666768696a6b6c6d6e6f"
        "707172737475767778797a7b7c7d7e7f"
        "808182838485868788898a8b8c8d8e8f"
        "909192939495969798999a9b9c9d9e9f"
        "a0a1a2a3a4a5a6a7a8a9aaabacadaeaf"
        "b0b1b2b3b4b5b6b7b8b9babbbcbdbebf"
        "c0c1c2c3c4c5c6c7c8c9cacbcccdcecf"
        "d0d1d2d3d4d5d6d7d8d9dadbdcdddedf"
        "e0e1e2e3e4e5e6e7e8e9eaebecedeeef"
        "f0f1f2f3f4f5f6f7f8f9fafbfcfdfeff";

    static String toHex16Bit(unsigned int x) {
        const unsigned int hi = (x >> 8) & 0xff;
        const unsigned int lo = x & 0xff;
        String result(4, ' ');
        result[0] = hex2[2 * hi];
        result[1] = hex2[2 * hi + 1];
        result[2] = hex2[2 * lo];
        result[3] = hex2[2 * lo + 1];
        return result;
    }

    static String valueToQuotedStringN(const char* value, unsigned length,
        bool emitUTF8 = false) {
        if (value == nullptr)
            return "";

        if (!isAnyCharRequiredQuoting(value, length))
            return String("\"") + value + "\"";
        // We have to walk value and escape any special characters.
        // Appending to String is not efficient, but this should be rare.
        // (Note: forward slashes are *not* rare, but I am not escaping them.)
        String::size_type maxsize = length * 2 + 3; // allescaped+quotes+NULL
        String result;
        result.reserve(maxsize); // to avoid lots of mallocs
        result += "\"";
        char const* end = value + length;
        for (const char* c = value; c != end; ++c) {
            switch (*c) {
            case '\"':
                result += "\\\"";
                break;
            case '\\':
                result += "\\\\";
                break;
            case '\b':
                result += "\\b";
                break;
            case '\f':
                result += "\\f";
                break;
            case '\n':
                result += "\\n";
                break;
            case '\r':
                result += "\\r";
                break;
            case '\t':
                result += "\\t";
                break;
                // case '/':
                // Even though \/ is considered a legal escape in JSON, a bare
                // slash is also legal, so I see no reason to escape it.
                // (I hope I am not misunderstanding something.)
                // blep notes: actually escaping \/ may be useful in javascript to avoid </
                // sequence.
                // Should add a flag to allow this compatibility mode and prevent this
                // sequence from occurring.
            default: {
                if (emitUTF8) {
                    result += *c;
                } else {
                    unsigned int codepoint = utf8ToCodepoint(c, end);
                    const unsigned int FIRST_NON_CONTROL_CODEPOINT = 0x20;
                    const unsigned int LAST_NON_CONTROL_CODEPOINT = 0x7F;
                    const unsigned int FIRST_SURROGATE_PAIR_CODEPOINT = 0x10000;
                    // don't escape non-control characters
                    // (short escape sequence are applied above)
                    if (FIRST_NON_CONTROL_CODEPOINT <= codepoint &&
                        codepoint <= LAST_NON_CONTROL_CODEPOINT) {
                        result += static_cast<char>(codepoint);
                    } else if (codepoint <
                        FIRST_SURROGATE_PAIR_CODEPOINT) { // codepoint is in Basic
                                                          // Multilingual Plane
                        result += "\\u";
                        result += toHex16Bit(codepoint);
                    } else { // codepoint is not in Basic Multilingual Plane
                             // convert to surrogate pair first
                        codepoint -= FIRST_SURROGATE_PAIR_CODEPOINT;
                        result += "\\u";
                        result += toHex16Bit((codepoint >> 10) + 0xD800);
                        result += "\\u";
                        result += toHex16Bit((codepoint & 0x3FF) + 0xDC00);
                    }
                }
            } break;
            }
        }
        result += "\"";
        return result;
    }

    String valueToQuotedString(const char* value) {
        return valueToQuotedStringN(value, static_cast<unsigned int>(strlen(value)));
    }

    // Class Writer
    // //////////////////////////////////////////////////////////////////
    Writer::~Writer() = default;

    // Class FastWriter
    // //////////////////////////////////////////////////////////////////

    FastWriter::FastWriter()

        = default;

    void FastWriter::enableYAMLCompatibility() { yamlCompatibilityEnabled_ = true; }

    void FastWriter::dropNullPlaceholders() { dropNullPlaceholders_ = true; }

    void FastWriter::omitEndingLineFeed() { omitEndingLineFeed_ = true; }

    String FastWriter::write(const Value& root) {
        document_.clear();
        writeValue(root);
        if (!omitEndingLineFeed_)
            document_ += '\n';
        return document_;
    }

    void FastWriter::writeValue(const Value& value) {
        switch (value.type()) {
        case nullValue:
            if (!dropNullPlaceholders_)
                document_ += "null";
            break;
        case intValue:
            document_ += valueToString(value.asLargestInt());
            break;
        case uintValue:
            document_ += valueToString(value.asLargestUInt());
            break;
        case realValue:
            document_ += valueToString(value.asDouble());
            break;
        case stringValue: {
            // Is NULL possible for value.string_? No.
            char const* str;
            char const* end;
            bool ok = value.getString(&str, &end);
            if (ok)
                document_ += valueToQuotedStringN(str, static_cast<unsigned>(end - str));
            break;
        }
        case booleanValue:
            document_ += valueToString(value.asBool());
            break;
        case arrayValue: {
            document_ += '[';
            ArrayIndex size = value.size();
            for (ArrayIndex index = 0; index < size; ++index) {
                if (index > 0)
                    document_ += ',';
                writeValue(value[index]);
            }
            document_ += ']';
        } break;
        case objectValue: {
            Value::Members members(value.getMemberNames());
            document_ += '{';
            for (auto it = members.begin(); it != members.end(); ++it) {
                const String& name = *it;
                if (it != members.begin())
                    document_ += ',';
                document_ += valueToQuotedStringN(name.data(),
                    static_cast<unsigned>(name.length()));
                document_ += yamlCompatibilityEnabled_ ? ": " : ":";
                writeValue(value[name]);
            }
            document_ += '}';
        } break;
        }
    }

    // Class StyledWriter
    // //////////////////////////////////////////////////////////////////

    StyledWriter::StyledWriter() = default;

    String StyledWriter::write(const Value& root) {
        document_.clear();
        addChildValues_ = false;
        indentString_.clear();
        writeCommentBeforeValue(root);
        writeValue(root);
        writeCommentAfterValueOnSameLine(root);
        document_ += '\n';
        return document_;
    }

    void StyledWriter::writeValue(const Value& value) {
        switch (value.type()) {
        case nullValue:
            pushValue("null");
            break;
        case intValue:
            pushValue(valueToString(value.asLargestInt()));
            break;
        case uintValue:
            pushValue(valueToString(value.asLargestUInt()));
            break;
        case realValue:
            pushValue(valueToString(value.asDouble()));
            break;
        case stringValue: {
            // Is NULL possible for value.string_? No.
            char const* str;
            char const* end;
            bool ok = value.getString(&str, &end);
            if (ok)
                pushValue(valueToQuotedStringN(str, static_cast<unsigned>(end - str)));
            else
                pushValue("");
            break;
        }
        case booleanValue:
            pushValue(valueToString(value.asBool()));
            break;
        case arrayValue:
            writeArrayValue(value);
            break;
        case objectValue: {
            Value::Members members(value.getMemberNames());
            if (members.empty())
                pushValue("{}");
            else {
                writeWithIndent("{");
                indent();
                auto it = members.begin();
                for (;;) {
                    const String& name = *it;
                    const Value& childValue = value[name];
                    writeCommentBeforeValue(childValue);
                    writeWithIndent(valueToQuotedString(name.c_str()));
                    document_ += " : ";
                    writeValue(childValue);
                    if (++it == members.end()) {
                        writeCommentAfterValueOnSameLine(childValue);
                        break;
                    }
                    document_ += ',';
                    writeCommentAfterValueOnSameLine(childValue);
                }
                unindent();
                writeWithIndent("}");
            }
        } break;
        }
    }

    void StyledWriter::writeArrayValue(const Value& value) {
        unsigned size = value.size();
        if (size == 0)
            pushValue("[]");
        else {
            bool isArrayMultiLine = isMultilineArray(value);
            if (isArrayMultiLine) {
                writeWithIndent("[");
                indent();
                bool hasChildValue = !childValues_.empty();
                unsigned index = 0;
                for (;;) {
                    const Value& childValue = value[index];
                    writeCommentBeforeValue(childValue);
                    if (hasChildValue)
                        writeWithIndent(childValues_[index]);
                    else {
                        writeIndent();
                        writeValue(childValue);
                    }
                    if (++index == size) {
                        writeCommentAfterValueOnSameLine(childValue);
                        break;
                    }
                    document_ += ',';
                    writeCommentAfterValueOnSameLine(childValue);
                }
                unindent();
                writeWithIndent("]");
            } else // output on a single line
            {
                assert(childValues_.size() == size);
                document_ += "[ ";
                for (unsigned index = 0; index < size; ++index) {
                    if (index > 0)
                        document_ += ", ";
                    document_ += childValues_[index];
                }
                document_ += " ]";
            }
        }
    }

    bool StyledWriter::isMultilineArray(const Value& value) {
        ArrayIndex const size = value.size();
        bool isMultiLine = size * 3 >= rightMargin_;
        childValues_.clear();
        for (ArrayIndex index = 0; index < size && !isMultiLine; ++index) {
            const Value& childValue = value[index];
            isMultiLine = ((childValue.isArray() || childValue.isObject()) &&
                !childValue.empty());
        }
        if (!isMultiLine) // check if line length > max line length
        {
            childValues_.reserve(size);
            addChildValues_ = true;
            ArrayIndex lineLength = 4 + (size - 1) * 2; // '[ ' + ', '*n + ' ]'
            for (ArrayIndex index = 0; index < size; ++index) {
                if (hasCommentForValue(value[index])) {
                    isMultiLine = true;
                }
                writeValue(value[index]);
                lineLength += static_cast<ArrayIndex>(childValues_[index].length());
            }
            addChildValues_ = false;
            isMultiLine = isMultiLine || lineLength >= rightMargin_;
        }
        return isMultiLine;
    }

    void StyledWriter::pushValue(const String& value) {
        if (addChildValues_)
            childValues_.push_back(value);
        else
            document_ += value;
    }

    void StyledWriter::writeIndent() {
        if (!document_.empty()) {
            char last = document_[document_.length() - 1];
            if (last == ' ') // already indented
                return;
            if (last != '\n') // Comments may add new-line
                document_ += '\n';
        }
        document_ += indentString_;
    }

    void StyledWriter::writeWithIndent(const String& value) {
        writeIndent();
        document_ += value;
    }

    void StyledWriter::indent() { indentString_ += String(indentSize_, ' '); }

    void StyledWriter::unindent() {
        assert(indentString_.size() >= indentSize_);
        indentString_.resize(indentString_.size() - indentSize_);
    }

    void StyledWriter::writeCommentBeforeValue(const Value& root) {
        if (!root.hasComment(commentBefore))
            return;

        document_ += '\n';
        writeIndent();
        const String& comment = root.getComment(commentBefore);
        String::const_iterator iter = comment.begin();
        while (iter != comment.end()) {
            document_ += *iter;
            if (*iter == '\n' && ((iter + 1) != comment.end() && *(iter + 1) == '/'))
                writeIndent();
            ++iter;
        }

        // Comments are stripped of trailing newlines, so add one here
        document_ += '\n';
    }

    void StyledWriter::writeCommentAfterValueOnSameLine(const Value& root) {
        if (root.hasComment(commentAfterOnSameLine))
            document_ += " " + root.getComment(commentAfterOnSameLine);

        if (root.hasComment(commentAfter)) {
            document_ += '\n';
            document_ += root.getComment(commentAfter);
            document_ += '\n';
        }
    }

    bool StyledWriter::hasCommentForValue(const Value& value) {
        return value.hasComment(commentBefore) ||
            value.hasComment(commentAfterOnSameLine) ||
            value.hasComment(commentAfter);
    }

    // Class StyledStreamWriter
    // //////////////////////////////////////////////////////////////////

    StyledStreamWriter::StyledStreamWriter(String indentation)
        : document_(nullptr), indentation_(std::move(indentation)),
        addChildValues_(), indented_(false) {}

    void StyledStreamWriter::write(OStream& out, const Value& root) {
        document_ = &out;
        addChildValues_ = false;
        indentString_.clear();
        indented_ = true;
        writeCommentBeforeValue(root);
        if (!indented_)
            writeIndent();
        indented_ = true;
        writeValue(root);
        writeCommentAfterValueOnSameLine(root);
        *document_ << "\n";
        document_ = nullptr; // Forget the stream, for safety.
    }

    void StyledStreamWriter::writeValue(const Value& value) {
        switch (value.type()) {
        case nullValue:
            pushValue("null");
            break;
        case intValue:
            pushValue(valueToString(value.asLargestInt()));
            break;
        case uintValue:
            pushValue(valueToString(value.asLargestUInt()));
            break;
        case realValue:
            pushValue(valueToString(value.asDouble()));
            break;
        case stringValue: {
            // Is NULL possible for value.string_? No.
            char const* str;
            char const* end;
            bool ok = value.getString(&str, &end);
            if (ok)
                pushValue(valueToQuotedStringN(str, static_cast<unsigned>(end - str)));
            else
                pushValue("");
            break;
        }
        case booleanValue:
            pushValue(valueToString(value.asBool()));
            break;
        case arrayValue:
            writeArrayValue(value);
            break;
        case objectValue: {
            Value::Members members(value.getMemberNames());
            if (members.empty())
                pushValue("{}");
            else {
                writeWithIndent("{");
                indent();
                auto it = members.begin();
                for (;;) {
                    const String& name = *it;
                    const Value& childValue = value[name];
                    writeCommentBeforeValue(childValue);
                    writeWithIndent(valueToQuotedString(name.c_str()));
                    *document_ << " : ";
                    writeValue(childValue);
                    if (++it == members.end()) {
                        writeCommentAfterValueOnSameLine(childValue);
                        break;
                    }
                    *document_ << ",";
                    writeCommentAfterValueOnSameLine(childValue);
                }
                unindent();
                writeWithIndent("}");
            }
        } break;
        }
    }

    void StyledStreamWriter::writeArrayValue(const Value& value) {
        unsigned size = value.size();
        if (size == 0)
            pushValue("[]");
        else {
            bool isArrayMultiLine = isMultilineArray(value);
            if (isArrayMultiLine) {
                writeWithIndent("[");
                indent();
                bool hasChildValue = !childValues_.empty();
                unsigned index = 0;
                for (;;) {
                    const Value& childValue = value[index];
                    writeCommentBeforeValue(childValue);
                    if (hasChildValue)
                        writeWithIndent(childValues_[index]);
                    else {
                        if (!indented_)
                            writeIndent();
                        indented_ = true;
                        writeValue(childValue);
                        indented_ = false;
                    }
                    if (++index == size) {
                        writeCommentAfterValueOnSameLine(childValue);
                        break;
                    }
                    *document_ << ",";
                    writeCommentAfterValueOnSameLine(childValue);
                }
                unindent();
                writeWithIndent("]");
            } else // output on a single line
            {
                assert(childValues_.size() == size);
                *document_ << "[ ";
                for (unsigned index = 0; index < size; ++index) {
                    if (index > 0)
                        *document_ << ", ";
                    *document_ << childValues_[index];
                }
                *document_ << " ]";
            }
        }
    }

    bool StyledStreamWriter::isMultilineArray(const Value& value) {
        ArrayIndex const size = value.size();
        bool isMultiLine = size * 3 >= rightMargin_;
        childValues_.clear();
        for (ArrayIndex index = 0; index < size && !isMultiLine; ++index) {
            const Value& childValue = value[index];
            isMultiLine = ((childValue.isArray() || childValue.isObject()) &&
                !childValue.empty());
        }
        if (!isMultiLine) // check if line length > max line length
        {
            childValues_.reserve(size);
            addChildValues_ = true;
            ArrayIndex lineLength = 4 + (size - 1) * 2; // '[ ' + ', '*n + ' ]'
            for (ArrayIndex index = 0; index < size; ++index) {
                if (hasCommentForValue(value[index])) {
                    isMultiLine = true;
                }
                writeValue(value[index]);
                lineLength += static_cast<ArrayIndex>(childValues_[index].length());
            }
            addChildValues_ = false;
            isMultiLine = isMultiLine || lineLength >= rightMargin_;
        }
        return isMultiLine;
    }

    void StyledStreamWriter::pushValue(const String& value) {
        if (addChildValues_)
            childValues_.push_back(value);
        else
            *document_ << value;
    }

    void StyledStreamWriter::writeIndent() {
        // blep intended this to look at the so-far-written string
        // to determine whether we are already indented, but
        // with a stream we cannot do that. So we rely on some saved state.
        // The caller checks indented_.
        *document_ << '\n' << indentString_;
    }

    void StyledStreamWriter::writeWithIndent(const String& value) {
        if (!indented_)
            writeIndent();
        *document_ << value;
        indented_ = false;
    }

    void StyledStreamWriter::indent() { indentString_ += indentation_; }

    void StyledStreamWriter::unindent() {
        assert(indentString_.size() >= indentation_.size());
        indentString_.resize(indentString_.size() - indentation_.size());
    }

    void StyledStreamWriter::writeCommentBeforeValue(const Value& root) {
        if (!root.hasComment(commentBefore))
            return;

        if (!indented_)
            writeIndent();
        const String& comment = root.getComment(commentBefore);
        String::const_iterator iter = comment.begin();
        while (iter != comment.end()) {
            *document_ << *iter;
            if (*iter == '\n' && ((iter + 1) != comment.end() && *(iter + 1) == '/'))
                // writeIndent();  // would include newline
                *document_ << indentString_;
            ++iter;
        }
        indented_ = false;
    }

    void StyledStreamWriter::writeCommentAfterValueOnSameLine(const Value& root) {
        if (root.hasComment(commentAfterOnSameLine))
            *document_ << ' ' << root.getComment(commentAfterOnSameLine);

        if (root.hasComment(commentAfter)) {
            writeIndent();
            *document_ << root.getComment(commentAfter);
        }
        indented_ = false;
    }

    bool StyledStreamWriter::hasCommentForValue(const Value& value) {
        return value.hasComment(commentBefore) ||
            value.hasComment(commentAfterOnSameLine) ||
            value.hasComment(commentAfter);
    }

    //////////////////////////
    // BuiltStyledStreamWriter

    /// Scoped enums are not available until C++11.
    struct CommentStyle {
        /// Decide whether to write comments.
        enum Enum {
            None, ///< Drop all comments.
            Most, ///< Recover odd behavior of previous versions (not implemented yet).
            All   ///< Keep all comments.
        };
    };

    struct BuiltStyledStreamWriter : public StreamWriter {
        BuiltStyledStreamWriter(String indentation, CommentStyle::Enum cs,
            String colonSymbol, String nullSymbol,
            String endingLineFeedSymbol, bool useSpecialFloats,
            bool emitUTF8, unsigned int precision,
            PrecisionType precisionType);
        int write(Value const& root, OStream* sout) override;

    private:
        void writeValue(Value const& value);
        void writeArrayValue(Value const& value);
        bool isMultilineArray(Value const& value);
        void pushValue(String const& value);
        void writeIndent();
        void writeWithIndent(String const& value);
        void indent();
        void unindent();
        void writeCommentBeforeValue(Value const& root);
        void writeCommentAfterValueOnSameLine(Value const& root);
        static bool hasCommentForValue(const Value& value);

        using ChildValues = std::vector<String>;

        ChildValues childValues_;
        String indentString_;
        unsigned int rightMargin_;
        String indentation_;
        CommentStyle::Enum cs_;
        String colonSymbol_;
        String nullSymbol_;
        String endingLineFeedSymbol_;
        bool addChildValues_ : 1;
        bool indented_ : 1;
        bool useSpecialFloats_ : 1;
        bool emitUTF8_ : 1;
        unsigned int precision_;
        PrecisionType precisionType_;
    };
    BuiltStyledStreamWriter::BuiltStyledStreamWriter(
        String indentation, CommentStyle::Enum cs, String colonSymbol,
        String nullSymbol, String endingLineFeedSymbol, bool useSpecialFloats,
        bool emitUTF8, unsigned int precision, PrecisionType precisionType)
        : rightMargin_(74), indentation_(std::move(indentation)), cs_(cs),
        colonSymbol_(std::move(colonSymbol)), nullSymbol_(std::move(nullSymbol)),
        endingLineFeedSymbol_(std::move(endingLineFeedSymbol)),
        addChildValues_(false), indented_(false),
        useSpecialFloats_(useSpecialFloats), emitUTF8_(emitUTF8),
        precision_(precision), precisionType_(precisionType) {}
    int BuiltStyledStreamWriter::write(Value const& root, OStream* sout) {
        sout_ = sout;
        addChildValues_ = false;
        indented_ = true;
        indentString_.clear();
        writeCommentBeforeValue(root);
        if (!indented_)
            writeIndent();
        indented_ = true;
        writeValue(root);
        writeCommentAfterValueOnSameLine(root);
        *sout_ << endingLineFeedSymbol_;
        sout_ = nullptr;
        return 0;
    }
    void BuiltStyledStreamWriter::writeValue(Value const& value) {
        switch (value.type()) {
        case nullValue:
            pushValue(nullSymbol_);
            break;
        case intValue:
            pushValue(valueToString(value.asLargestInt()));
            break;
        case uintValue:
            pushValue(valueToString(value.asLargestUInt()));
            break;
        case realValue:
            pushValue(valueToString(value.asDouble(), useSpecialFloats_, precision_,
                precisionType_));
            break;
        case stringValue: {
            // Is NULL is possible for value.string_? No.
            char const* str;
            char const* end;
            bool ok = value.getString(&str, &end);
            if (ok)
                pushValue(valueToQuotedStringN(str, static_cast<unsigned>(end - str),
                    emitUTF8_));
            else
                pushValue("");
            break;
        }
        case booleanValue:
            pushValue(valueToString(value.asBool()));
            break;
        case arrayValue:
            writeArrayValue(value);
            break;
        case objectValue: {
            Value::Members members(value.getMemberNames());
            if (members.empty())
                pushValue("{}");
            else {
                writeWithIndent("{");
                indent();
                auto it = members.begin();
                for (;;) {
                    String const& name = *it;
                    Value const& childValue = value[name];
                    writeCommentBeforeValue(childValue);
                    writeWithIndent(valueToQuotedStringN(
                        name.data(), static_cast<unsigned>(name.length()), emitUTF8_));
                    *sout_ << colonSymbol_;
                    writeValue(childValue);
                    if (++it == members.end()) {
                        writeCommentAfterValueOnSameLine(childValue);
                        break;
                    }
                    *sout_ << ",";
                    writeCommentAfterValueOnSameLine(childValue);
                }
                unindent();
                writeWithIndent("}");
            }
        } break;
        }
    }

    void BuiltStyledStreamWriter::writeArrayValue(Value const& value) {
        unsigned size = value.size();
        if (size == 0)
            pushValue("[]");
        else {
            bool isMultiLine = (cs_ == CommentStyle::All) || isMultilineArray(value);
            if (isMultiLine) {
                writeWithIndent("[");
                indent();
                bool hasChildValue = !childValues_.empty();
                unsigned index = 0;
                for (;;) {
                    Value const& childValue = value[index];
                    writeCommentBeforeValue(childValue);
                    if (hasChildValue)
                        writeWithIndent(childValues_[index]);
                    else {
                        if (!indented_)
                            writeIndent();
                        indented_ = true;
                        writeValue(childValue);
                        indented_ = false;
                    }
                    if (++index == size) {
                        writeCommentAfterValueOnSameLine(childValue);
                        break;
                    }
                    *sout_ << ",";
                    writeCommentAfterValueOnSameLine(childValue);
                }
                unindent();
                writeWithIndent("]");
            } else // output on a single line
            {
                assert(childValues_.size() == size);
                *sout_ << "[";
                if (!indentation_.empty())
                    *sout_ << " ";
                for (unsigned index = 0; index < size; ++index) {
                    if (index > 0)
                        *sout_ << ((!indentation_.empty()) ? ", " : ",");
                    *sout_ << childValues_[index];
                }
                if (!indentation_.empty())
                    *sout_ << " ";
                *sout_ << "]";
            }
        }
    }

    bool BuiltStyledStreamWriter::isMultilineArray(Value const& value) {
        ArrayIndex const size = value.size();
        bool isMultiLine = size * 3 >= rightMargin_;
        childValues_.clear();
        for (ArrayIndex index = 0; index < size && !isMultiLine; ++index) {
            Value const& childValue = value[index];
            isMultiLine = ((childValue.isArray() || childValue.isObject()) &&
                !childValue.empty());
        }
        if (!isMultiLine) // check if line length > max line length
        {
            childValues_.reserve(size);
            addChildValues_ = true;
            ArrayIndex lineLength = 4 + (size - 1) * 2; // '[ ' + ', '*n + ' ]'
            for (ArrayIndex index = 0; index < size; ++index) {
                if (hasCommentForValue(value[index])) {
                    isMultiLine = true;
                }
                writeValue(value[index]);
                lineLength += static_cast<ArrayIndex>(childValues_[index].length());
            }
            addChildValues_ = false;
            isMultiLine = isMultiLine || lineLength >= rightMargin_;
        }
        return isMultiLine;
    }

    void BuiltStyledStreamWriter::pushValue(String const& value) {
        if (addChildValues_)
            childValues_.push_back(value);
        else
            *sout_ << value;
    }

    void BuiltStyledStreamWriter::writeIndent() {
        // blep intended this to look at the so-far-written string
        // to determine whether we are already indented, but
        // with a stream we cannot do that. So we rely on some saved state.
        // The caller checks indented_.

        if (!indentation_.empty()) {
            // In this case, drop newlines too.
            *sout_ << '\n' << indentString_;
        }
    }

    void BuiltStyledStreamWriter::writeWithIndent(String const& value) {
        if (!indented_)
            writeIndent();
        *sout_ << value;
        indented_ = false;
    }

    void BuiltStyledStreamWriter::indent() { indentString_ += indentation_; }

    void BuiltStyledStreamWriter::unindent() {
        assert(indentString_.size() >= indentation_.size());
        indentString_.resize(indentString_.size() - indentation_.size());
    }

    void BuiltStyledStreamWriter::writeCommentBeforeValue(Value const& root) {
        if (cs_ == CommentStyle::None)
            return;
        if (!root.hasComment(commentBefore))
            return;

        if (!indented_)
            writeIndent();
        const String& comment = root.getComment(commentBefore);
        String::const_iterator iter = comment.begin();
        while (iter != comment.end()) {
            *sout_ << *iter;
            if (*iter == '\n' && ((iter + 1) != comment.end() && *(iter + 1) == '/'))
                // writeIndent();  // would write extra newline
                *sout_ << indentString_;
            ++iter;
        }
        indented_ = false;
    }

    void BuiltStyledStreamWriter::writeCommentAfterValueOnSameLine(
        Value const& root) {
        if (cs_ == CommentStyle::None)
            return;
        if (root.hasComment(commentAfterOnSameLine))
            *sout_ << " " + root.getComment(commentAfterOnSameLine);

        if (root.hasComment(commentAfter)) {
            writeIndent();
            *sout_ << root.getComment(commentAfter);
        }
    }

    // static
    bool BuiltStyledStreamWriter::hasCommentForValue(const Value& value) {
        return value.hasComment(commentBefore) ||
            value.hasComment(commentAfterOnSameLine) ||
            value.hasComment(commentAfter);
    }

    ///////////////
    // StreamWriter

    StreamWriter::StreamWriter() : sout_(nullptr) {}
    StreamWriter::~StreamWriter() = default;
    StreamWriter::Factory::~Factory() = default;
    StreamWriterBuilder::StreamWriterBuilder() { setDefaults(&settings_); }
    StreamWriterBuilder::~StreamWriterBuilder() = default;
    StreamWriter* StreamWriterBuilder::newStreamWriter() const {
        const String indentation = settings_["indentation"].asString();
        const String cs_str = settings_["commentStyle"].asString();
        const String pt_str = settings_["precisionType"].asString();
        const bool eyc = settings_["enableYAMLCompatibility"].asBool();
        const bool dnp = settings_["dropNullPlaceholders"].asBool();
        const bool usf = settings_["useSpecialFloats"].asBool();
        const bool emitUTF8 = settings_["emitUTF8"].asBool();
        unsigned int pre = settings_["precision"].asUInt();
        CommentStyle::Enum cs = CommentStyle::All;
        if (cs_str == "All") {
            cs = CommentStyle::All;
        } else if (cs_str == "None") {
            cs = CommentStyle::None;
        } else {
            throwRuntimeError("commentStyle must be 'All' or 'None'");
        }
        PrecisionType precisionType(significantDigits);
        if (pt_str == "significant") {
            precisionType = PrecisionType::significantDigits;
        } else if (pt_str == "decimal") {
            precisionType = PrecisionType::decimalPlaces;
        } else {
            throwRuntimeError("precisionType must be 'significant' or 'decimal'");
        }
        String colonSymbol = " : ";
        if (eyc) {
            colonSymbol = ": ";
        } else if (indentation.empty()) {
            colonSymbol = ":";
        }
        String nullSymbol = "null";
        if (dnp) {
            nullSymbol.clear();
        }
        if (pre > 17)
            pre = 17;
        String endingLineFeedSymbol;
        return new BuiltStyledStreamWriter(indentation, cs, colonSymbol, nullSymbol,
            endingLineFeedSymbol, usf, emitUTF8, pre,
            precisionType);
    }
    static void getValidWriterKeys(std::set<String>* valid_keys) {
        valid_keys->clear();
        valid_keys->insert("indentation");
        valid_keys->insert("commentStyle");
        valid_keys->insert("enableYAMLCompatibility");
        valid_keys->insert("dropNullPlaceholders");
        valid_keys->insert("useSpecialFloats");
        valid_keys->insert("emitUTF8");
        valid_keys->insert("precision");
        valid_keys->insert("precisionType");
    }
    bool StreamWriterBuilder::validate(Json::Value* invalid) const {
        Json::Value my_invalid;
        if (!invalid)
            invalid = &my_invalid; // so we do not need to test for NULL
        Json::Value& inv = *invalid;
        std::set<String> valid_keys;
        getValidWriterKeys(&valid_keys);
        Value::Members keys = settings_.getMemberNames();
        size_t n = keys.size();
        for (size_t i = 0; i < n; ++i) {
            String const& key = keys[i];
            if (valid_keys.find(key) == valid_keys.end()) {
                inv[key] = settings_[key];
            }
        }
        return inv.empty();
    }
    Value& StreamWriterBuilder::operator[](const String& key) {
        return settings_[key];
    }
    // static
    void StreamWriterBuilder::setDefaults(Json::Value* settings) {
        //! [StreamWriterBuilderDefaults]
        (*settings)["commentStyle"] = "All";
        (*settings)["indentation"] = "\t";
        (*settings)["enableYAMLCompatibility"] = false;
        (*settings)["dropNullPlaceholders"] = false;
        (*settings)["useSpecialFloats"] = false;
        (*settings)["emitUTF8"] = false;
        (*settings)["precision"] = 17;
        (*settings)["precisionType"] = "significant";
        //! [StreamWriterBuilderDefaults]
    }

    String writeString(StreamWriter::Factory const& factory, Value const& root) {
        OStringStream sout;
        StreamWriterPtr const writer(factory.newStreamWriter());
        writer->write(root, &sout);
        return sout.str();
    }

    OStream& operator<<(OStream& sout, Value const& root) {
        StreamWriterBuilder builder;
        StreamWriterPtr const writer(builder.newStreamWriter());
        writer->write(root, &sout);
        return sout;
    }

} // namespace Json

// //////////////////////////////////////////////////////////////////////
// End of content of file: src/lib_json/json_writer.cpp
// //////////////////////////////////////////////////////////////////////






```

`Lumina/Lumina/common/json/json.h`:

```h
/// Json-cpp amalgamated header (http://jsoncpp.sourceforge.net/).
/// It is intended to be used with #include "json/json.h"

// //////////////////////////////////////////////////////////////////////
// Beginning of content of file: LICENSE
// //////////////////////////////////////////////////////////////////////

/*
The JsonCpp library's source code, including accompanying documentation,
tests and demonstration applications, are licensed under the following
conditions...

Baptiste Lepilleur and The JsonCpp Authors explicitly disclaim copyright in all
jurisdictions which recognize such a disclaimer. In such jurisdictions,
this software is released into the Public Domain.

In jurisdictions which do not recognize Public Domain property (e.g. Germany as of
2010), this software is Copyright (c) 2007-2010 by Baptiste Lepilleur and
The JsonCpp Authors, and is released under the terms of the MIT License (see below).

In jurisdictions which recognize Public Domain property, the user of this
software may choose to accept it either as 1) Public Domain, 2) under the
conditions of the MIT License (see below), or 3) under the terms of dual
Public Domain/MIT License conditions described here, as they choose.

The MIT License is about as close to Public Domain as a license can get, and is
described in clear, concise terms at:

   http://en.wikipedia.org/wiki/MIT_License

The full text of the MIT License follows:

========================================================================
Copyright (c) 2007-2010 Baptiste Lepilleur and The JsonCpp Authors

Permission is hereby granted, free of charge, to any person
obtaining a copy of this software and associated documentation
files (the "Software"), to deal in the Software without
restriction, including without limitation the rights to use, copy,
modify, merge, publish, distribute, sublicense, and/or sell copies
of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be
included in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
========================================================================
(END LICENSE TEXT)

The MIT license is compatible with both the GPL and commercial
software, affording one all of the rights of Public Domain with the
minor nuisance of being required to keep the above copyright notice
and license text in the source code. Note also that by accepting the
Public Domain "license" you can re-license your copy using whatever
license you like.

*/

// //////////////////////////////////////////////////////////////////////
// End of content of file: LICENSE
// //////////////////////////////////////////////////////////////////////





#ifndef JSON_AMALGAMATED_H_INCLUDED
# define JSON_AMALGAMATED_H_INCLUDED
/// If defined, indicates that the source file is amalgamated
/// to prevent private header inclusion.
#define JSON_IS_AMALGAMATION

// //////////////////////////////////////////////////////////////////////
// Beginning of content of file: include/json/version.h
// //////////////////////////////////////////////////////////////////////

#ifndef JSON_VERSION_H_INCLUDED
#define JSON_VERSION_H_INCLUDED

// Note: version must be updated in three places when doing a release. This
// annoying process ensures that amalgamate, CMake, and meson all report the
// correct version.
// 1. /meson.build
// 2. /include/json/version.h
// 3. /CMakeLists.txt
// IMPORTANT: also update the SOVERSION!!

#define JSONCPP_VERSION_STRING "1.9.2"
#define JSONCPP_VERSION_MAJOR 1
#define JSONCPP_VERSION_MINOR 9
#define JSONCPP_VERSION_PATCH 2
#define JSONCPP_VERSION_QUALIFIER
#define JSONCPP_VERSION_HEXA                                                   \
  ((JSONCPP_VERSION_MAJOR << 24) | (JSONCPP_VERSION_MINOR << 16) |             \
   (JSONCPP_VERSION_PATCH << 8))

#ifdef JSONCPP_USING_SECURE_MEMORY
#undef JSONCPP_USING_SECURE_MEMORY
#endif
#define JSONCPP_USING_SECURE_MEMORY 0
// If non-zero, the library zeroes any memory that it has allocated before
// it frees its memory.

#endif // JSON_VERSION_H_INCLUDED

// //////////////////////////////////////////////////////////////////////
// End of content of file: include/json/version.h
// //////////////////////////////////////////////////////////////////////






// //////////////////////////////////////////////////////////////////////
// Beginning of content of file: include/json/allocator.h
// //////////////////////////////////////////////////////////////////////

// Copyright 2007-2010 Baptiste Lepilleur and The JsonCpp Authors
// Distributed under MIT license, or public domain if desired and
// recognized in your jurisdiction.
// See file LICENSE for detail or copy at http://jsoncpp.sourceforge.net/LICENSE

#ifndef CPPTL_JSON_ALLOCATOR_H_INCLUDED
#define CPPTL_JSON_ALLOCATOR_H_INCLUDED

#include <cstring>
#include <memory>

#pragma pack(push, 8)

namespace Json {
    template <typename T> class SecureAllocator {
    public:
        // Type definitions
        using value_type = T;
        using pointer = T*;
        using const_pointer = const T*;
        using reference = T&;
        using const_reference = const T&;
        using size_type = std::size_t;
        using difference_type = std::ptrdiff_t;

        /**
         * Allocate memory for N items using the standard allocator.
         */
        pointer allocate(size_type n) {
            // allocate using "global operator new"
            return static_cast<pointer>(::operator new(n * sizeof(T)));
        }

        /**
         * Release memory which was allocated for N items at pointer P.
         *
         * The memory block is filled with zeroes before being released.
         * The pointer argument is tagged as "volatile" to prevent the
         * compiler optimizing out this critical step.
         */
        void deallocate(volatile pointer p, size_type n) {
            std::memset(p, 0, n * sizeof(T));
            // free using "global operator delete"
            ::operator delete(p);
        }

        /**
         * Construct an item in-place at pointer P.
         */
        template <typename... Args> void construct(pointer p, Args&&... args) {
            // construct using "placement new" and "perfect forwarding"
            ::new (static_cast<void*>(p)) T(std::forward<Args>(args)...);
        }

        size_type max_size() const { return size_t(-1) / sizeof(T); }

        pointer address(reference x) const { return std::addressof(x); }

        const_pointer address(const_reference x) const { return std::addressof(x); }

        /**
         * Destroy an item in-place at pointer P.
         */
        void destroy(pointer p) {
            // destroy using "explicit destructor"
            p->~T();
        }

        // Boilerplate
        SecureAllocator() {}
        template <typename U> SecureAllocator(const SecureAllocator<U>&) {}
        template <typename U> struct rebind { using other = SecureAllocator<U>; };
    };

    template <typename T, typename U>
    bool operator==(const SecureAllocator<T>&, const SecureAllocator<U>&) {
        return true;
    }

    template <typename T, typename U>
    bool operator!=(const SecureAllocator<T>&, const SecureAllocator<U>&) {
        return false;
    }

} // namespace Json

#pragma pack(pop)

#endif // CPPTL_JSON_ALLOCATOR_H_INCLUDED

// //////////////////////////////////////////////////////////////////////
// End of content of file: include/json/allocator.h
// //////////////////////////////////////////////////////////////////////






// //////////////////////////////////////////////////////////////////////
// Beginning of content of file: include/json/config.h
// //////////////////////////////////////////////////////////////////////

// Copyright 2007-2010 Baptiste Lepilleur and The JsonCpp Authors
// Distributed under MIT license, or public domain if desired and
// recognized in your jurisdiction.
// See file LICENSE for detail or copy at http://jsoncpp.sourceforge.net/LICENSE

#ifndef JSON_CONFIG_H_INCLUDED
#define JSON_CONFIG_H_INCLUDED
#include <cstddef>
#include <cstdint>
#include <istream>
#include <memory>
#include <ostream>
#include <sstream>
#include <string>
#include <type_traits>

/// If defined, indicates that json library is embedded in CppTL library.
//# define JSON_IN_CPPTL 1

/// If defined, indicates that json may leverage CppTL library
//#  define JSON_USE_CPPTL 1
/// If defined, indicates that cpptl vector based map should be used instead of
/// std::map
/// as Value container.
//#  define JSON_USE_CPPTL_SMALLMAP 1

// If non-zero, the library uses exceptions to report bad input instead of C
// assertion macros. The default is to use exceptions.
#ifndef JSON_USE_EXCEPTION
#define JSON_USE_EXCEPTION 0
#endif

// Temporary, tracked for removal with issue #982.
#ifndef JSON_USE_NULLREF
#define JSON_USE_NULLREF 1
#endif

/// If defined, indicates that the source file is amalgamated
/// to prevent private header inclusion.
/// Remarks: it is automatically defined in the generated amalgamated header.
// #define JSON_IS_AMALGAMATION

#ifdef JSON_IN_CPPTL
#include <cpptl/config.h>
#ifndef JSON_USE_CPPTL
#define JSON_USE_CPPTL 1
#endif
#endif

#ifdef JSON_IN_CPPTL
#define JSON_API CPPTL_API
#elif defined(JSON_DLL_BUILD)
#if defined(_MSC_VER) || defined(__MINGW32__)
#define JSON_API __declspec(dllexport)
#define JSONCPP_DISABLE_DLL_INTERFACE_WARNING
#elif defined(__GNUC__) || defined(__clang__)
#define JSON_API __attribute__((visibility("default")))
#endif // if defined(_MSC_VER)
#elif defined(JSON_DLL)
#if defined(_MSC_VER) || defined(__MINGW32__)
#define JSON_API __declspec(dllimport)
#define JSONCPP_DISABLE_DLL_INTERFACE_WARNING
#endif // if defined(_MSC_VER)
#endif // ifdef JSON_IN_CPPTL
#if !defined(JSON_API)
#define JSON_API
#endif

#if defined(_MSC_VER) && _MSC_VER < 1800
#error                                                                         \
    "ERROR:  Visual Studio 12 (2013) with _MSC_VER=1800 is the oldest supported compiler with sufficient C++11 capabilities"
#endif

#if defined(_MSC_VER) && _MSC_VER < 1900
// As recommended at
// https://stackoverflow.com/questions/2915672/snprintf-and-visual-studio-2010
extern JSON_API int msvc_pre1900_c99_snprintf(char* outBuf, size_t size,
    const char* format, ...);
#define jsoncpp_snprintf msvc_pre1900_c99_snprintf
#else
#define jsoncpp_snprintf std::snprintf
#endif

// If JSON_NO_INT64 is defined, then Json only support C++ "int" type for
// integer
// Storages, and 64 bits integer support is disabled.
#define JSON_NO_INT64 1

// JSONCPP_OVERRIDE is maintained for backwards compatibility of external tools.
// C++11 should be used directly in JSONCPP.
#define JSONCPP_OVERRIDE override

#if __cplusplus >= 201103L
#define JSONCPP_NOEXCEPT noexcept
#define JSONCPP_OP_EXPLICIT explicit
#elif defined(_MSC_VER) && _MSC_VER < 1900
#define JSONCPP_NOEXCEPT throw()
#define JSONCPP_OP_EXPLICIT explicit
#elif defined(_MSC_VER) && _MSC_VER >= 1900
#define JSONCPP_NOEXCEPT noexcept
#define JSONCPP_OP_EXPLICIT explicit
#else
#define JSONCPP_NOEXCEPT throw()
#define JSONCPP_OP_EXPLICIT
#endif

#ifdef __clang__
#if __has_extension(attribute_deprecated_with_message)
#define JSONCPP_DEPRECATED(message) __attribute__((deprecated(message)))
#endif
#elif defined(__GNUC__) // not clang (gcc comes later since clang emulates gcc)
#if (__GNUC__ > 4 || (__GNUC__ == 4 && __GNUC_MINOR__ >= 5))
#define JSONCPP_DEPRECATED(message) __attribute__((deprecated(message)))
#elif (__GNUC__ > 3 || (__GNUC__ == 3 && __GNUC_MINOR__ >= 1))
#define JSONCPP_DEPRECATED(message) __attribute__((__deprecated__))
#endif                  // GNUC version
#elif defined(_MSC_VER) // MSVC (after clang because clang on Windows emulates
                        // MSVC)
#define JSONCPP_DEPRECATED(message) __declspec(deprecated(message))
#endif // __clang__ || __GNUC__ || _MSC_VER

#if !defined(JSONCPP_DEPRECATED)
#define JSONCPP_DEPRECATED(message)
#endif // if !defined(JSONCPP_DEPRECATED)

#if defined(__clang__) || (defined(__GNUC__) && (__GNUC__ >= 6))
#define JSON_USE_INT64_DOUBLE_CONVERSION 1
#endif

#if !defined(JSON_IS_AMALGAMATION)

#include "allocator.h"
#include "version.h"

#endif // if !defined(JSON_IS_AMALGAMATION)

namespace Json {
    typedef int Int;
    typedef unsigned int UInt;
#if defined(JSON_NO_INT64)
    typedef int LargestInt;
    typedef unsigned int LargestUInt;
#undef JSON_HAS_INT64
#else                 // if defined(JSON_NO_INT64)
    // For Microsoft Visual use specific types as long long is not supported
#if defined(_MSC_VER) // Microsoft Visual Studio
    typedef __int64 Int64;
    typedef unsigned __int64 UInt64;
#else                 // if defined(_MSC_VER) // Other platforms, use long long
    typedef int64_t Int64;
    typedef uint64_t UInt64;
#endif                // if defined(_MSC_VER)
    typedef Int64 LargestInt;
    typedef UInt64 LargestUInt;
#define JSON_HAS_INT64
#endif // if defined(JSON_NO_INT64)

    template <typename T>
    using Allocator =
        typename std::conditional<JSONCPP_USING_SECURE_MEMORY, SecureAllocator<T>,
        std::allocator<T>>::type;
    using String = std::basic_string<char, std::char_traits<char>, Allocator<char>>;
    using IStringStream =
        std::basic_istringstream<String::value_type, String::traits_type,
        String::allocator_type>;
    using OStringStream =
        std::basic_ostringstream<String::value_type, String::traits_type,
        String::allocator_type>;
    using IStream = std::istream;
    using OStream = std::ostream;
} // namespace Json

// Legacy names (formerly macros).
using JSONCPP_STRING = Json::String;
using JSONCPP_ISTRINGSTREAM = Json::IStringStream;
using JSONCPP_OSTRINGSTREAM = Json::OStringStream;
using JSONCPP_ISTREAM = Json::IStream;
using JSONCPP_OSTREAM = Json::OStream;

#endif // JSON_CONFIG_H_INCLUDED

// //////////////////////////////////////////////////////////////////////
// End of content of file: include/json/config.h
// //////////////////////////////////////////////////////////////////////






// //////////////////////////////////////////////////////////////////////
// Beginning of content of file: include/json/forwards.h
// //////////////////////////////////////////////////////////////////////

// Copyright 2007-2010 Baptiste Lepilleur and The JsonCpp Authors
// Distributed under MIT license, or public domain if desired and
// recognized in your jurisdiction.
// See file LICENSE for detail or copy at http://jsoncpp.sourceforge.net/LICENSE

#ifndef JSON_FORWARDS_H_INCLUDED
#define JSON_FORWARDS_H_INCLUDED

#if !defined(JSON_IS_AMALGAMATION)
#include "config.h"
#endif // if !defined(JSON_IS_AMALGAMATION)

namespace Json {

    // writer.h
    class StreamWriter;
    class StreamWriterBuilder;
    class Writer;
    class FastWriter;
    class StyledWriter;
    class StyledStreamWriter;

    // reader.h
    class Reader;
    class CharReader;
    class CharReaderBuilder;

    // json_features.h
    class Features;

    // value.h
    typedef unsigned int ArrayIndex;
    class StaticString;
    class Path;
    class PathArgument;
    class Value;
    class ValueIteratorBase;
    class ValueIterator;
    class ValueConstIterator;

} // namespace Json

#endif // JSON_FORWARDS_H_INCLUDED

// //////////////////////////////////////////////////////////////////////
// End of content of file: include/json/forwards.h
// //////////////////////////////////////////////////////////////////////






// //////////////////////////////////////////////////////////////////////
// Beginning of content of file: include/json/json_features.h
// //////////////////////////////////////////////////////////////////////

// Copyright 2007-2010 Baptiste Lepilleur and The JsonCpp Authors
// Distributed under MIT license, or public domain if desired and
// recognized in your jurisdiction.
// See file LICENSE for detail or copy at http://jsoncpp.sourceforge.net/LICENSE

#ifndef CPPTL_JSON_FEATURES_H_INCLUDED
#define CPPTL_JSON_FEATURES_H_INCLUDED

#if !defined(JSON_IS_AMALGAMATION)
#include "forwards.h"
#endif // if !defined(JSON_IS_AMALGAMATION)

#pragma pack(push, 8)

namespace Json {

    /** \brief Configuration passed to reader and writer.
     * This configuration object can be used to force the Reader or Writer
     * to behave in a standard conforming way.
     */
    class JSON_API Features {
    public:
        /** \brief A configuration that allows all features and assumes all strings
         * are UTF-8.
         * - C & C++ comments are allowed
         * - Root object can be any JSON value
         * - Assumes Value strings are encoded in UTF-8
         */
        static Features all();

        /** \brief A configuration that is strictly compatible with the JSON
         * specification.
         * - Comments are forbidden.
         * - Root object must be either an array or an object value.
         * - Assumes Value strings are encoded in UTF-8
         */
        static Features strictMode();

        /** \brief Initialize the configuration like JsonConfig::allFeatures;
         */
        Features();

        /// \c true if comments are allowed. Default: \c true.
        bool allowComments_{ true };

        /// \c true if root must be either an array or an object value. Default: \c
        /// false.
        bool strictRoot_{ false };

        /// \c true if dropped null placeholders are allowed. Default: \c false.
        bool allowDroppedNullPlaceholders_{ false };

        /// \c true if numeric object key are allowed. Default: \c false.
        bool allowNumericKeys_{ false };
    };

} // namespace Json

#pragma pack(pop)

#endif // CPPTL_JSON_FEATURES_H_INCLUDED

// //////////////////////////////////////////////////////////////////////
// End of content of file: include/json/json_features.h
// //////////////////////////////////////////////////////////////////////






// //////////////////////////////////////////////////////////////////////
// Beginning of content of file: include/json/value.h
// //////////////////////////////////////////////////////////////////////

// Copyright 2007-2010 Baptiste Lepilleur and The JsonCpp Authors
// Distributed under MIT license, or public domain if desired and
// recognized in your jurisdiction.
// See file LICENSE for detail or copy at http://jsoncpp.sourceforge.net/LICENSE

#ifndef CPPTL_JSON_H_INCLUDED
#define CPPTL_JSON_H_INCLUDED

#if !defined(JSON_IS_AMALGAMATION)
#include "forwards.h"
#endif // if !defined(JSON_IS_AMALGAMATION)

// Conditional NORETURN attribute on the throw functions would:
// a) suppress false positives from static code analysis
// b) possibly improve optimization opportunities.
#if !defined(JSONCPP_NORETURN)
#if defined(_MSC_VER) && _MSC_VER == 1800
#define JSONCPP_NORETURN __declspec(noreturn)
#else
#define JSONCPP_NORETURN [[noreturn]]
#endif
#endif

#include <array>
#include <exception>
#include <memory>
#include <string>
#include <vector>

#ifndef JSON_USE_CPPTL_SMALLMAP
#include <map>
#else
#include <cpptl/smallmap.h>
#endif
#ifdef JSON_USE_CPPTL
#include <cpptl/forwards.h>
#endif

// Disable warning C4251: <data member>: <type> needs to have dll-interface to
// be used by...
#if defined(JSONCPP_DISABLE_DLL_INTERFACE_WARNING)
#pragma warning(push)
#pragma warning(disable : 4251)
#endif // if defined(JSONCPP_DISABLE_DLL_INTERFACE_WARNING)

#pragma pack(push, 8)

/** \brief JSON (JavaScript Object Notation).
 */
namespace Json {

#if JSON_USE_EXCEPTION
    /** Base class for all exceptions we throw.
     *
     * We use nothing but these internally. Of course, STL can throw others.
     */
    class JSON_API Exception : public std::exception {
    public:
        Exception(String msg);
        ~Exception() JSONCPP_NOEXCEPT override;
        char const* what() const JSONCPP_NOEXCEPT override;

    protected:
        String msg_;
    };

    /** Exceptions which the user cannot easily avoid.
     *
     * E.g. out-of-memory (when we use malloc), stack-overflow, malicious input
     *
     * \remark derived from Json::Exception
     */
    class JSON_API RuntimeError : public Exception {
    public:
        RuntimeError(String const& msg);
    };

    /** Exceptions thrown by JSON_ASSERT/JSON_FAIL macros.
     *
     * These are precondition-violations (user bugs) and internal errors (our bugs).
     *
     * \remark derived from Json::Exception
     */
    class JSON_API LogicError : public Exception {
    public:
        LogicError(String const& msg);
    };
#endif

    /// used internally
    JSONCPP_NORETURN void throwRuntimeError(String const& msg);
    /// used internally
    JSONCPP_NORETURN void throwLogicError(String const& msg);

    /** \brief Type of the value held by a Value object.
     */
    enum ValueType {
        nullValue = 0, ///< 'null' value
        intValue,      ///< signed integer value
        uintValue,     ///< unsigned integer value
        realValue,     ///< double value
        stringValue,   ///< UTF-8 string value
        booleanValue,  ///< bool value
        arrayValue,    ///< array value (ordered list)
        objectValue    ///< object value (collection of name/value pairs).
    };

    enum CommentPlacement {
        commentBefore = 0,      ///< a comment placed on the line before a value
        commentAfterOnSameLine, ///< a comment just after a value on the same line
        commentAfter, ///< a comment on the line after a value (only make sense for
        /// root value)
        numberOfCommentPlacement
    };

    /** \brief Type of precision for formatting of real values.
     */
    enum PrecisionType {
        significantDigits = 0, ///< we set max number of significant digits in string
        decimalPlaces          ///< we set max number of digits after "." in string
    };

    //# ifdef JSON_USE_CPPTL
    //   typedef CppTL::AnyEnumerator<const char *> EnumMemberNames;
    //   typedef CppTL::AnyEnumerator<const Value &> EnumValues;
    //# endif

    /** \brief Lightweight wrapper to tag static string.
     *
     * Value constructor and objectValue member assignment takes advantage of the
     * StaticString and avoid the cost of string duplication when storing the
     * string or the member name.
     *
     * Example of usage:
     * \code
     * Json::Value aValue( StaticString("some text") );
     * Json::Value object;
     * static const StaticString code("code");
     * object[code] = 1234;
     * \endcode
     */
    class JSON_API StaticString {
    public:
        explicit StaticString(const char* czstring) : c_str_(czstring) {}

        operator const char* () const { return c_str_; }

        const char* c_str() const { return c_str_; }

    private:
        const char* c_str_;
    };

    /** \brief Represents a <a HREF="http://www.json.org">JSON</a> value.
     *
     * This class is a discriminated union wrapper that can represents a:
     * - signed integer [range: Value::minInt - Value::maxInt]
     * - unsigned integer (range: 0 - Value::maxUInt)
     * - double
     * - UTF-8 string
     * - boolean
     * - 'null'
     * - an ordered list of Value
     * - collection of name/value pairs (javascript object)
     *
     * The type of the held value is represented by a #ValueType and
     * can be obtained using type().
     *
     * Values of an #objectValue or #arrayValue can be accessed using operator[]()
     * methods.
     * Non-const methods will automatically create the a #nullValue element
     * if it does not exist.
     * The sequence of an #arrayValue will be automatically resized and initialized
     * with #nullValue. resize() can be used to enlarge or truncate an #arrayValue.
     *
     * The get() methods can be used to obtain default value in the case the
     * required element does not exist.
     *
     * It is possible to iterate over the list of member keys of an object using
     * the getMemberNames() method.
     *
     * \note #Value string-length fit in size_t, but keys must be < 2^30.
     * (The reason is an implementation detail.) A #CharReader will raise an
     * exception if a bound is exceeded to avoid security holes in your app,
     * but the Value API does *not* check bounds. That is the responsibility
     * of the caller.
     */
    class JSON_API Value {
        friend class ValueIteratorBase;

    public:
        typedef std::vector<String> Members;
        typedef ValueIterator iterator;
        typedef ValueConstIterator const_iterator;
        typedef Json::UInt UInt;
        typedef Json::Int Int;
#if defined(JSON_HAS_INT64)
        typedef Json::UInt64 UInt64;
        typedef Json::Int64 Int64;
#endif // defined(JSON_HAS_INT64)
        typedef Json::LargestInt LargestInt;
        typedef Json::LargestUInt LargestUInt;
        typedef Json::ArrayIndex ArrayIndex;

        // Required for boost integration, e. g. BOOST_TEST
        typedef std::string value_type;

#if JSON_USE_NULLREF
        // Binary compatibility kludges, do not use.
        static const Value& null;
        static const Value& nullRef;
#endif

        // null and nullRef are deprecated, use this instead.
        static Value const& nullSingleton();

        /// Minimum signed integer value that can be stored in a Json::Value.
        static constexpr LargestInt minLargestInt =
            LargestInt(~(LargestUInt(-1) / 2));
        /// Maximum signed integer value that can be stored in a Json::Value.
        static constexpr LargestInt maxLargestInt = LargestInt(LargestUInt(-1) / 2);
        /// Maximum unsigned integer value that can be stored in a Json::Value.
        static constexpr LargestUInt maxLargestUInt = LargestUInt(-1);

        /// Minimum signed int value that can be stored in a Json::Value.
        static constexpr Int minInt = Int(~(UInt(-1) / 2));
        /// Maximum signed int value that can be stored in a Json::Value.
        static constexpr Int maxInt = Int(UInt(-1) / 2);
        /// Maximum unsigned int value that can be stored in a Json::Value.
        static constexpr UInt maxUInt = UInt(-1);

#if defined(JSON_HAS_INT64)
        /// Minimum signed 64 bits int value that can be stored in a Json::Value.
        static constexpr Int64 minInt64 = Int64(~(UInt64(-1) / 2));
        /// Maximum signed 64 bits int value that can be stored in a Json::Value.
        static constexpr Int64 maxInt64 = Int64(UInt64(-1) / 2);
        /// Maximum unsigned 64 bits int value that can be stored in a Json::Value.
        static constexpr UInt64 maxUInt64 = UInt64(-1);
#endif // defined(JSON_HAS_INT64)
        /// Default precision for real value for string representation.
        static constexpr UInt defaultRealPrecision = 17;
        // The constant is hard-coded because some compiler have trouble
        // converting Value::maxUInt64 to a double correctly (AIX/xlC).
        // Assumes that UInt64 is a 64 bits integer.
        static constexpr double maxUInt64AsDouble = 18446744073709551615.0;
        // Workaround for bug in the NVIDIAs CUDA 9.1 nvcc compiler
        // when using gcc and clang backend compilers.  CZString
        // cannot be defined as private.  See issue #486
#ifdef __NVCC__
    public:
#else
    private:
#endif
#ifndef JSONCPP_DOC_EXCLUDE_IMPLEMENTATION
        class CZString {
        public:
            enum DuplicationPolicy { noDuplication = 0, duplicate, duplicateOnCopy };
            CZString(ArrayIndex index);
            CZString(char const* str, unsigned length, DuplicationPolicy allocate);
            CZString(CZString const& other);
            CZString(CZString&& other);
            ~CZString();
            CZString& operator=(const CZString& other);
            CZString& operator=(CZString&& other);

            bool operator<(CZString const& other) const;
            bool operator==(CZString const& other) const;
            ArrayIndex index() const;
            // const char* c_str() const; ///< \deprecated
            char const* data() const;
            unsigned length() const;
            bool isStaticString() const;

        private:
            void swap(CZString& other);

            struct StringStorage {
                unsigned policy_ : 2;
                unsigned length_ : 30; // 1GB max
            };

            char const* cstr_; // actually, a prefixed string, unless policy is noDup
            union {
                ArrayIndex index_;
                StringStorage storage_;
            };
        };

    public:
#ifndef JSON_USE_CPPTL_SMALLMAP
        typedef std::map<CZString, Value> ObjectValues;
#else
        typedef CppTL::SmallMap<CZString, Value> ObjectValues;
#endif // ifndef JSON_USE_CPPTL_SMALLMAP
#endif // ifndef JSONCPP_DOC_EXCLUDE_IMPLEMENTATION

    public:
        /**
         * \brief Create a default Value of the given type.
         *
         * This is a very useful constructor.
         * To create an empty array, pass arrayValue.
         * To create an empty object, pass objectValue.
         * Another Value can then be set to this one by assignment.
         * This is useful since clear() and resize() will not alter types.
         *
         * Examples:
         *   \code
         *   Json::Value null_value; // null
         *   Json::Value arr_value(Json::arrayValue); // []
         *   Json::Value obj_value(Json::objectValue); // {}
         *   \endcode
         */
        Value(ValueType type = nullValue);
        Value(Int value);
        Value(UInt value);
#if defined(JSON_HAS_INT64)
        Value(Int64 value);
        Value(UInt64 value);
#endif // if defined(JSON_HAS_INT64)
        Value(double value);
        Value(const char* value); ///< Copy til first 0. (NULL causes to seg-fault.)
        Value(const char* begin, const char* end); ///< Copy all, incl zeroes.
        /**
         * \brief Constructs a value from a static string.
         *
         * Like other value string constructor but do not duplicate the string for
         * internal storage. The given string must remain alive after the call to
         * this constructor.
         *
         * \note This works only for null-terminated strings. (We cannot change the
         * size of this class, so we have nowhere to store the length, which might be
         * computed later for various operations.)
         *
         * Example of usage:
         *   \code
         *   static StaticString foo("some text");
         *   Json::Value aValue(foo);
         *   \endcode
         */
        Value(const StaticString& value);
        Value(const String& value);
#ifdef JSON_USE_CPPTL
        Value(const CppTL::ConstString& value);
#endif
        Value(bool value);
        Value(const Value& other);
        Value(Value&& other);
        ~Value();

        /// \note Overwrite existing comments. To preserve comments, use
        /// #swapPayload().
        Value& operator=(const Value& other);
        Value& operator=(Value&& other);

        /// Swap everything.
        void swap(Value& other);
        /// Swap values but leave comments and source offsets in place.
        void swapPayload(Value& other);

        /// copy everything.
        void copy(const Value& other);
        /// copy values but leave comments and source offsets in place.
        void copyPayload(const Value& other);

        ValueType type() const;

        /// Compare payload only, not comments etc.
        bool operator<(const Value& other) const;
        bool operator<=(const Value& other) const;
        bool operator>=(const Value& other) const;
        bool operator>(const Value& other) const;
        bool operator==(const Value& other) const;
        bool operator!=(const Value& other) const;
        int compare(const Value& other) const;

        const char* asCString() const; ///< Embedded zeroes could cause you trouble!
#if JSONCPP_USING_SECURE_MEMORY
        unsigned getCStringLength() const; // Allows you to understand the length of
                                           // the CString
#endif
        String asString() const; ///< Embedded zeroes are possible.
        /** Get raw char* of string-value.
         *  \return false if !string. (Seg-fault if str or end are NULL.)
         */
        bool getString(char const** begin, char const** end) const;
#ifdef JSON_USE_CPPTL
        CppTL::ConstString asConstString() const;
#endif
        Int asInt() const;
        UInt asUInt() const;
#if defined(JSON_HAS_INT64)
        Int64 asInt64() const;
        UInt64 asUInt64() const;
#endif // if defined(JSON_HAS_INT64)
        LargestInt asLargestInt() const;
        LargestUInt asLargestUInt() const;
        float asFloat() const;
        double asDouble() const;
        bool asBool() const;

        bool isNull() const;
        bool isBool() const;
        bool isInt() const;
        bool isInt64() const;
        bool isUInt() const;
        bool isUInt64() const;
        bool isIntegral() const;
        bool isDouble() const;
        bool isNumeric() const;
        bool isString() const;
        bool isArray() const;
        bool isObject() const;

        bool isConvertibleTo(ValueType other) const;

        /// Number of values in array or object
        ArrayIndex size() const;

        /// \brief Return true if empty array, empty object, or null;
        /// otherwise, false.
        bool empty() const;

        /// Return !isNull()
        JSONCPP_OP_EXPLICIT operator bool() const;

        /// Remove all object members and array elements.
        /// \pre type() is arrayValue, objectValue, or nullValue
        /// \post type() is unchanged
        void clear();

        /// Resize the array to newSize elements.
        /// New elements are initialized to null.
        /// May only be called on nullValue or arrayValue.
        /// \pre type() is arrayValue or nullValue
        /// \post type() is arrayValue
        void resize(ArrayIndex newSize);

        //@{
        /// Access an array element (zero based index). If the array contains less
        /// than index element, then null value are inserted in the array so that
        /// its size is index+1.
        /// (You may need to say 'value[0u]' to get your compiler to distinguish
        /// this from the operator[] which takes a string.)
        Value& operator[](ArrayIndex index);
        Value& operator[](int index);
        //@}

        //@{
        /// Access an array element (zero based index).
        /// (You may need to say 'value[0u]' to get your compiler to distinguish
        /// this from the operator[] which takes a string.)
        const Value& operator[](ArrayIndex index) const;
        const Value& operator[](int index) const;
        //@}

        /// If the array contains at least index+1 elements, returns the element
        /// value, otherwise returns defaultValue.
        Value get(ArrayIndex index, const Value& defaultValue) const;
        /// Return true if index < size().
        bool isValidIndex(ArrayIndex index) const;
        /// \brief Append value to array at the end.
        ///
        /// Equivalent to jsonvalue[jsonvalue.size()] = value;
        Value& append(const Value& value);
        Value& append(Value&& value);
        /// \brief Insert value in array at specific index
        bool insert(ArrayIndex index, Value newValue);

        /// Access an object value by name, create a null member if it does not exist.
        /// \note Because of our implementation, keys are limited to 2^30 -1 chars.
        /// Exceeding that will cause an exception.
        Value& operator[](const char* key);
        /// Access an object value by name, returns null if there is no member with
        /// that name.
        const Value& operator[](const char* key) const;
        /// Access an object value by name, create a null member if it does not exist.
        /// \param key may contain embedded nulls.
        Value& operator[](const String& key);
        /// Access an object value by name, returns null if there is no member with
        /// that name.
        /// \param key may contain embedded nulls.
        const Value& operator[](const String& key) const;
        /** \brief Access an object value by name, create a null member if it does not
         * exist.
         *
         * If the object has no entry for that name, then the member name used to
         * store the new entry is not duplicated.
         * Example of use:
         *   \code
         *   Json::Value object;
         *   static const StaticString code("code");
         *   object[code] = 1234;
         *   \endcode
         */
        Value& operator[](const StaticString& key);
#ifdef JSON_USE_CPPTL
        /// Access an object value by name, create a null member if it does not exist.
        Value& operator[](const CppTL::ConstString& key);
        /// Access an object value by name, returns null if there is no member with
        /// that name.
        const Value& operator[](const CppTL::ConstString& key) const;
#endif
        /// Return the member named key if it exist, defaultValue otherwise.
        /// \note deep copy
        Value get(const char* key, const Value& defaultValue) const;
        /// Return the member named key if it exist, defaultValue otherwise.
        /// \note deep copy
        /// \note key may contain embedded nulls.
        Value get(const char* begin, const char* end,
            const Value& defaultValue) const;
        /// Return the member named key if it exist, defaultValue otherwise.
        /// \note deep copy
        /// \param key may contain embedded nulls.
        Value get(const String& key, const Value& defaultValue) const;
#ifdef JSON_USE_CPPTL
        /// Return the member named key if it exist, defaultValue otherwise.
        /// \note deep copy
        Value get(const CppTL::ConstString& key, const Value& defaultValue) const;
#endif
        /// Most general and efficient version of isMember()const, get()const,
        /// and operator[]const
        /// \note As stated elsewhere, behavior is undefined if (end-begin) >= 2^30
        Value const* find(char const* begin, char const* end) const;
        /// Most general and efficient version of object-mutators.
        /// \note As stated elsewhere, behavior is undefined if (end-begin) >= 2^30
        /// \return non-zero, but JSON_ASSERT if this is neither object nor nullValue.
        Value* demand(char const* begin, char const* end);
        /// \brief Remove and return the named member.
        ///
        /// Do nothing if it did not exist.
        /// \pre type() is objectValue or nullValue
        /// \post type() is unchanged
        void removeMember(const char* key);
        /// Same as removeMember(const char*)
        /// \param key may contain embedded nulls.
        void removeMember(const String& key);
        /// Same as removeMember(const char* begin, const char* end, Value* removed),
        /// but 'key' is null-terminated.
        bool removeMember(const char* key, Value* removed);
        /** \brief Remove the named map member.
         *
         *  Update 'removed' iff removed.
         *  \param key may contain embedded nulls.
         *  \return true iff removed (no exceptions)
         */
        bool removeMember(String const& key, Value* removed);
        /// Same as removeMember(String const& key, Value* removed)
        bool removeMember(const char* begin, const char* end, Value* removed);
        /** \brief Remove the indexed array element.
         *
         *  O(n) expensive operations.
         *  Update 'removed' iff removed.
         *  \return true if removed (no exceptions)
         */
        bool removeIndex(ArrayIndex index, Value* removed);

        /// Return true if the object has a member named key.
        /// \note 'key' must be null-terminated.
        bool isMember(const char* key) const;
        /// Return true if the object has a member named key.
        /// \param key may contain embedded nulls.
        bool isMember(const String& key) const;
        /// Same as isMember(String const& key)const
        bool isMember(const char* begin, const char* end) const;
#ifdef JSON_USE_CPPTL
        /// Return true if the object has a member named key.
        bool isMember(const CppTL::ConstString& key) const;
#endif

        /// \brief Return a list of the member names.
        ///
        /// If null, return an empty list.
        /// \pre type() is objectValue or nullValue
        /// \post if type() was nullValue, it remains nullValue
        Members getMemberNames() const;

        //# ifdef JSON_USE_CPPTL
        //      EnumMemberNames enumMemberNames() const;
        //      EnumValues enumValues() const;
        //# endif

        /// \deprecated Always pass len.
        JSONCPP_DEPRECATED("Use setComment(String const&) instead.")
            void setComment(const char* comment, CommentPlacement placement) {
            setComment(String(comment, strlen(comment)), placement);
        }
        /// Comments must be //... or /* ... */
        void setComment(const char* comment, size_t len, CommentPlacement placement) {
            setComment(String(comment, len), placement);
        }
        /// Comments must be //... or /* ... */
        void setComment(String comment, CommentPlacement placement);
        bool hasComment(CommentPlacement placement) const;
        /// Include delimiters and embedded newlines.
        String getComment(CommentPlacement placement) const;

        String toStyledString() const;

        const_iterator begin() const;
        const_iterator end() const;

        iterator begin();
        iterator end();

        // Accessors for the [start, limit) range of bytes within the JSON text from
        // which this value was parsed, if any.
        void setOffsetStart(ptrdiff_t start);
        void setOffsetLimit(ptrdiff_t limit);
        ptrdiff_t getOffsetStart() const;
        ptrdiff_t getOffsetLimit() const;

    private:
        void setType(ValueType v) {
            bits_.value_type_ = static_cast<unsigned char>(v);
        }
        bool isAllocated() const { return bits_.allocated_; }
        void setIsAllocated(bool v) { bits_.allocated_ = v; }

        void initBasic(ValueType type, bool allocated = false);
        void dupPayload(const Value& other);
        void releasePayload();
        void dupMeta(const Value& other);

        Value& resolveReference(const char* key);
        Value& resolveReference(const char* key, const char* end);

        // struct MemberNamesTransform
        //{
        //   typedef const char *result_type;
        //   const char *operator()( const CZString &name ) const
        //   {
        //      return name.c_str();
        //   }
        //};

        union ValueHolder {
            LargestInt int_;
            LargestUInt uint_;
            double real_;
            bool bool_;
            char* string_; // if allocated_, ptr to { unsigned, char[] }.
            ObjectValues* map_;
        } value_;

        struct {
            // Really a ValueType, but types should agree for bitfield packing.
            unsigned int value_type_ : 8;
            // Unless allocated_, string_ must be null-terminated.
            unsigned int allocated_ : 1;
        } bits_;

        class Comments {
        public:
            Comments() = default;
            Comments(const Comments& that);
            Comments(Comments&& that);
            Comments& operator=(const Comments& that);
            Comments& operator=(Comments&& that);
            bool has(CommentPlacement slot) const;
            String get(CommentPlacement slot) const;
            void set(CommentPlacement slot, String comment);

        private:
            using Array = std::array<String, numberOfCommentPlacement>;
            std::unique_ptr<Array> ptr_;
        };
        Comments comments_;

        // [start, limit) byte offsets in the source JSON text from which this Value
        // was extracted.
        ptrdiff_t start_;
        ptrdiff_t limit_;
    };

    /** \brief Experimental and untested: represents an element of the "path" to
     * access a node.
     */
    class JSON_API PathArgument {
    public:
        friend class Path;

        PathArgument();
        PathArgument(ArrayIndex index);
        PathArgument(const char* key);
        PathArgument(String key);

    private:
        enum Kind { kindNone = 0, kindIndex, kindKey };
        String key_;
        ArrayIndex index_{};
        Kind kind_{ kindNone };
    };

    /** \brief Experimental and untested: represents a "path" to access a node.
     *
     * Syntax:
     * - "." => root node
     * - ".[n]" => elements at index 'n' of root node (an array value)
     * - ".name" => member named 'name' of root node (an object value)
     * - ".name1.name2.name3"
     * - ".[0][1][2].name1[3]"
     * - ".%" => member name is provided as parameter
     * - ".[%]" => index is provided as parameter
     */
    class JSON_API Path {
    public:
        Path(const String& path, const PathArgument& a1 = PathArgument(),
            const PathArgument& a2 = PathArgument(),
            const PathArgument& a3 = PathArgument(),
            const PathArgument& a4 = PathArgument(),
            const PathArgument& a5 = PathArgument());

        const Value& resolve(const Value& root) const;
        Value resolve(const Value& root, const Value& defaultValue) const;
        /// Creates the "path" to access the specified node and returns a reference on
        /// the node.
        Value& make(Value& root) const;

    private:
        typedef std::vector<const PathArgument*> InArgs;
        typedef std::vector<PathArgument> Args;

        void makePath(const String& path, const InArgs& in);
        void addPathInArg(const String& path, const InArgs& in,
            InArgs::const_iterator& itInArg, PathArgument::Kind kind);
        static void invalidPath(const String& path, int location);

        Args args_;
    };

    /** \brief base class for Value iterators.
     *
     */
    class JSON_API ValueIteratorBase {
    public:
        typedef std::bidirectional_iterator_tag iterator_category;
        typedef unsigned int size_t;
        typedef int difference_type;
        typedef ValueIteratorBase SelfType;

        bool operator==(const SelfType& other) const { return isEqual(other); }

        bool operator!=(const SelfType& other) const { return !isEqual(other); }

        difference_type operator-(const SelfType& other) const {
            return other.computeDistance(*this);
        }

        /// Return either the index or the member name of the referenced value as a
        /// Value.
        Value key() const;

        /// Return the index of the referenced Value, or -1 if it is not an
        /// arrayValue.
        UInt index() const;

        /// Return the member name of the referenced Value, or "" if it is not an
        /// objectValue.
        /// \note Avoid `c_str()` on result, as embedded zeroes are possible.
        String name() const;

        /// Return the member name of the referenced Value. "" if it is not an
        /// objectValue.
        /// \deprecated This cannot be used for UTF-8 strings, since there can be
        /// embedded nulls.
        JSONCPP_DEPRECATED("Use `key = name();` instead.")
            char const* memberName() const;
        /// Return the member name of the referenced Value, or NULL if it is not an
        /// objectValue.
        /// \note Better version than memberName(). Allows embedded nulls.
        char const* memberName(char const** end) const;

    protected:
        /*! Internal utility functions to assist with implementing
         *   other iterator functions. The const and non-const versions
         *   of the "deref" protected methods expose the protected
         *   current_ member variable in a way that can often be
         *   optimized away by the compiler.
         */
        const Value& deref() const;
        Value& deref();

        void increment();

        void decrement();

        difference_type computeDistance(const SelfType& other) const;

        bool isEqual(const SelfType& other) const;

        void copy(const SelfType& other);

    private:
        Value::ObjectValues::iterator current_;
        // Indicates that iterator is for a null value.
        bool isNull_{ true };

    public:
        // For some reason, BORLAND needs these at the end, rather
        // than earlier. No idea why.
        ValueIteratorBase();
        explicit ValueIteratorBase(const Value::ObjectValues::iterator& current);
    };

    /** \brief const iterator for object and array value.
     *
     */
    class JSON_API ValueConstIterator : public ValueIteratorBase {
        friend class Value;

    public:
        typedef const Value value_type;
        // typedef unsigned int size_t;
        // typedef int difference_type;
        typedef const Value& reference;
        typedef const Value* pointer;
        typedef ValueConstIterator SelfType;

        ValueConstIterator();
        ValueConstIterator(ValueIterator const& other);

    private:
        /*! \internal Use by Value to create an iterator.
         */
        explicit ValueConstIterator(const Value::ObjectValues::iterator& current);

    public:
        SelfType& operator=(const ValueIteratorBase& other);

        SelfType operator++(int) {
            SelfType temp(*this);
            ++* this;
            return temp;
        }

        SelfType operator--(int) {
            SelfType temp(*this);
            --* this;
            return temp;
        }

        SelfType& operator--() {
            decrement();
            return *this;
        }

        SelfType& operator++() {
            increment();
            return *this;
        }

        reference operator*() const { return deref(); }

        pointer operator->() const { return &deref(); }
    };

    /** \brief Iterator for object and array value.
     */
    class JSON_API ValueIterator : public ValueIteratorBase {
        friend class Value;

    public:
        typedef Value value_type;
        typedef unsigned int size_t;
        typedef int difference_type;
        typedef Value& reference;
        typedef Value* pointer;
        typedef ValueIterator SelfType;

        ValueIterator();
        explicit ValueIterator(const ValueConstIterator& other);
        ValueIterator(const ValueIterator& other);

    private:
        /*! \internal Use by Value to create an iterator.
         */
        explicit ValueIterator(const Value::ObjectValues::iterator& current);

    public:
        SelfType& operator=(const SelfType& other);

        SelfType operator++(int) {
            SelfType temp(*this);
            ++* this;
            return temp;
        }

        SelfType operator--(int) {
            SelfType temp(*this);
            --* this;
            return temp;
        }

        SelfType& operator--() {
            decrement();
            return *this;
        }

        SelfType& operator++() {
            increment();
            return *this;
        }

        /*! The return value of non-const iterators can be
         *  changed, so the these functions are not const
         *  because the returned references/pointers can be used
         *  to change state of the base class.
         */
        reference operator*() { return deref(); }
        pointer operator->() { return &deref(); }
    };

    inline void swap(Value& a, Value& b) { a.swap(b); }

} // namespace Json

#pragma pack(pop)

#if defined(JSONCPP_DISABLE_DLL_INTERFACE_WARNING)
#pragma warning(pop)
#endif // if defined(JSONCPP_DISABLE_DLL_INTERFACE_WARNING)

#endif // CPPTL_JSON_H_INCLUDED

// //////////////////////////////////////////////////////////////////////
// End of content of file: include/json/value.h
// //////////////////////////////////////////////////////////////////////






// //////////////////////////////////////////////////////////////////////
// Beginning of content of file: include/json/reader.h
// //////////////////////////////////////////////////////////////////////

// Copyright 2007-2010 Baptiste Lepilleur and The JsonCpp Authors
// Distributed under MIT license, or public domain if desired and
// recognized in your jurisdiction.
// See file LICENSE for detail or copy at http://jsoncpp.sourceforge.net/LICENSE

#ifndef CPPTL_JSON_READER_H_INCLUDED
#define CPPTL_JSON_READER_H_INCLUDED

#if !defined(JSON_IS_AMALGAMATION)
#include "json_features.h"
#include "value.h"
#endif // if !defined(JSON_IS_AMALGAMATION)
#include <deque>
#include <iosfwd>
#include <istream>
#include <stack>
#include <string>

// Disable warning C4251: <data member>: <type> needs to have dll-interface to
// be used by...
#if defined(JSONCPP_DISABLE_DLL_INTERFACE_WARNING)
#pragma warning(push)
#pragma warning(disable : 4251)
#endif // if defined(JSONCPP_DISABLE_DLL_INTERFACE_WARNING)

#pragma pack(push, 8)

namespace Json {

    /** \brief Unserialize a <a HREF="http://www.json.org">JSON</a> document into a
     * Value.
     *
     * \deprecated Use CharReader and CharReaderBuilder.
     */

    class JSONCPP_DEPRECATED(
        "Use CharReader and CharReaderBuilder instead.") JSON_API Reader {
    public:
        typedef char Char;
        typedef const Char* Location;

        /** \brief An error tagged with where in the JSON text it was encountered.
         *
         * The offsets give the [start, limit) range of bytes within the text. Note
         * that this is bytes, not codepoints.
         */
        struct StructuredError {
            ptrdiff_t offset_start;
            ptrdiff_t offset_limit;
            String message;
        };

        /** \brief Constructs a Reader allowing all features for parsing.
         */
        JSONCPP_DEPRECATED("Use CharReader and CharReaderBuilder instead")
            Reader();

        /** \brief Constructs a Reader allowing the specified feature set for parsing.
         */
        JSONCPP_DEPRECATED("Use CharReader and CharReaderBuilder instead")
            Reader(const Features & features);

        /** \brief Read a Value from a <a HREF="http://www.json.org">JSON</a>
         * document.
         *
         * \param      document        UTF-8 encoded string containing the document
         *                             to read.
         * \param[out] root            Contains the root value of the document if it
         *                             was successfully parsed.
         * \param      collectComments \c true to collect comment and allow writing
         *                             them back during serialization, \c false to
         *                             discard comments.  This parameter is ignored
         *                             if Features::allowComments_ is \c false.
         * \return \c true if the document was successfully parsed, \c false if an
         * error occurred.
         */
        bool parse(const std::string & document, Value & root,
            bool collectComments = true);

        /** \brief Read a Value from a <a HREF="http://www.json.org">JSON</a>
         * document.
         *
         * \param      beginDoc        Pointer on the beginning of the UTF-8 encoded
         *                             string of the document to read.
         * \param      endDoc          Pointer on the end of the UTF-8 encoded string
         *                             of the document to read.  Must be >= beginDoc.
         * \param[out] root            Contains the root value of the document if it
         *                             was successfully parsed.
         * \param      collectComments \c true to collect comment and allow writing
         *                             them back during serialization, \c false to
         *                             discard comments.  This parameter is ignored
         *                             if Features::allowComments_ is \c false.
         * \return \c true if the document was successfully parsed, \c false if an
         * error occurred.
         */
        bool parse(const char* beginDoc, const char* endDoc, Value & root,
            bool collectComments = true);

        /// \brief Parse from input stream.
        /// \see Json::operator>>(std::istream&, Json::Value&).
        bool parse(IStream & is, Value & root, bool collectComments = true);

        /** \brief Returns a user friendly string that list errors in the parsed
         * document.
         *
         * \return Formatted error message with the list of errors with their
         * location in the parsed document. An empty string is returned if no error
         * occurred during parsing.
         * \deprecated Use getFormattedErrorMessages() instead (typo fix).
         */
        JSONCPP_DEPRECATED("Use getFormattedErrorMessages() instead.")
            String getFormatedErrorMessages() const;

        /** \brief Returns a user friendly string that list errors in the parsed
         * document.
         *
         * \return Formatted error message with the list of errors with their
         * location in the parsed document. An empty string is returned if no error
         * occurred during parsing.
         */
        String getFormattedErrorMessages() const;

        /** \brief Returns a vector of structured errors encountered while parsing.
         *
         * \return A (possibly empty) vector of StructuredError objects. Currently
         * only one error can be returned, but the caller should tolerate multiple
         * errors.  This can occur if the parser recovers from a non-fatal parse
         * error and then encounters additional errors.
         */
        std::vector<StructuredError> getStructuredErrors() const;

        /** \brief Add a semantic error message.
         *
         * \param value   JSON Value location associated with the error
         * \param message The error message.
         * \return \c true if the error was successfully added, \c false if the Value
         * offset exceeds the document size.
         */
        bool pushError(const Value & value, const String & message);

        /** \brief Add a semantic error message with extra context.
         *
         * \param value   JSON Value location associated with the error
         * \param message The error message.
         * \param extra   Additional JSON Value location to contextualize the error
         * \return \c true if the error was successfully added, \c false if either
         * Value offset exceeds the document size.
         */
        bool pushError(const Value & value, const String & message, const Value & extra);

        /** \brief Return whether there are any errors.
         *
         * \return \c true if there are no errors to report \c false if errors have
         * occurred.
         */
        bool good() const;

    private:
        enum TokenType {
            tokenEndOfStream = 0,
            tokenObjectBegin,
            tokenObjectEnd,
            tokenArrayBegin,
            tokenArrayEnd,
            tokenString,
            tokenNumber,
            tokenTrue,
            tokenFalse,
            tokenNull,
            tokenArraySeparator,
            tokenMemberSeparator,
            tokenComment,
            tokenError
        };

        class Token {
        public:
            TokenType type_;
            Location start_;
            Location end_;
        };

        class ErrorInfo {
        public:
            Token token_;
            String message_;
            Location extra_;
        };

        typedef std::deque<ErrorInfo> Errors;

        bool readToken(Token & token);
        void skipSpaces();
        bool match(const Char * pattern, int patternLength);
        bool readComment();
        bool readCStyleComment();
        bool readCppStyleComment();
        bool readString();
        void readNumber();
        bool readValue();
        bool readObject(Token & token);
        bool readArray(Token & token);
        bool decodeNumber(Token & token);
        bool decodeNumber(Token & token, Value & decoded);
        bool decodeString(Token & token);
        bool decodeString(Token & token, String & decoded);
        bool decodeDouble(Token & token);
        bool decodeDouble(Token & token, Value & decoded);
        bool decodeUnicodeCodePoint(Token & token, Location & current, Location end,
            unsigned int& unicode);
        bool decodeUnicodeEscapeSequence(Token & token, Location & current,
            Location end, unsigned int& unicode);
        bool addError(const String & message, Token & token, Location extra = nullptr);
        bool recoverFromError(TokenType skipUntilToken);
        bool addErrorAndRecover(const String & message, Token & token,
            TokenType skipUntilToken);
        void skipUntilSpace();
        Value& currentValue();
        Char getNextChar();
        void getLocationLineAndColumn(Location location, int& line,
            int& column) const;
        String getLocationLineAndColumn(Location location) const;
        void addComment(Location begin, Location end, CommentPlacement placement);
        void skipCommentTokens(Token & token);

        static bool containsNewLine(Location begin, Location end);
        static String normalizeEOL(Location begin, Location end);

        typedef std::stack<Value*> Nodes;
        Nodes nodes_;
        Errors errors_;
        String document_;
        Location begin_{};
        Location end_{};
        Location current_{};
        Location lastValueEnd_{};
        Value* lastValue_{};
        String commentsBefore_;
        Features features_;
        bool collectComments_{};
    }; // Reader

    /** Interface for reading JSON from a char array.
     */
    class JSON_API CharReader {
    public:
        virtual ~CharReader() = default;
        /** \brief Read a Value from a <a HREF="http://www.json.org">JSON</a>
         * document. The document must be a UTF-8 encoded string containing the
         * document to read.
         *
         * \param      beginDoc Pointer on the beginning of the UTF-8 encoded string
         *                      of the document to read.
         * \param      endDoc   Pointer on the end of the UTF-8 encoded string of the
         *                      document to read. Must be >= beginDoc.
         * \param[out] root     Contains the root value of the document if it was
         *                      successfully parsed.
         * \param[out] errs     Formatted error messages (if not NULL) a user
         *                      friendly string that lists errors in the parsed
         *                      document.
         * \return \c true if the document was successfully parsed, \c false if an
         * error occurred.
         */
        virtual bool parse(char const* beginDoc, char const* endDoc, Value* root,
            String* errs) = 0;

        class JSON_API Factory {
        public:
            virtual ~Factory() = default;
            /** \brief Allocate a CharReader via operator new().
             * \throw std::exception if something goes wrong (e.g. invalid settings)
             */
            virtual CharReader* newCharReader() const = 0;
        }; // Factory
    };   // CharReader

    /** \brief Build a CharReader implementation.
     *
     * Usage:
     *   \code
     *   using namespace Json;
     *   CharReaderBuilder builder;
     *   builder["collectComments"] = false;
     *   Value value;
     *   String errs;
     *   bool ok = parseFromStream(builder, std::cin, &value, &errs);
     *   \endcode
     */
    class JSON_API CharReaderBuilder : public CharReader::Factory {
    public:
        // Note: We use a Json::Value so that we can add data-members to this class
        // without a major version bump.
        /** Configuration of this builder.
         * These are case-sensitive.
         * Available settings (case-sensitive):
         * - `"collectComments": false or true`
         *   - true to collect comment and allow writing them back during
         *     serialization, false to discard comments.  This parameter is ignored
         *     if allowComments is false.
         * - `"allowComments": false or true`
         *   - true if comments are allowed.
         * - `"strictRoot": false or true`
         *   - true if root must be either an array or an object value
         * - `"allowDroppedNullPlaceholders": false or true`
         *   - true if dropped null placeholders are allowed. (See
         *     StreamWriterBuilder.)
         * - `"allowNumericKeys": false or true`
         *   - true if numeric object keys are allowed.
         * - `"allowSingleQuotes": false or true`
         *   - true if '' are allowed for strings (both keys and values)
         * - `"stackLimit": integer`
         *   - Exceeding stackLimit (recursive depth of `readValue()`) will cause an
         *     exception.
         *   - This is a security issue (seg-faults caused by deeply nested JSON), so
         *     the default is low.
         * - `"failIfExtra": false or true`
         *   - If true, `parse()` returns false when extra non-whitespace trails the
         *     JSON value in the input string.
         * - `"rejectDupKeys": false or true`
         *   - If true, `parse()` returns false when a key is duplicated within an
         *     object.
         * - `"allowSpecialFloats": false or true`
         *   - If true, special float values (NaNs and infinities) are allowed and
         *     their values are lossfree restorable.
         *
         * You can examine 'settings_` yourself to see the defaults. You can also
         * write and read them just like any JSON Value.
         * \sa setDefaults()
         */
        Json::Value settings_;

        CharReaderBuilder();
        ~CharReaderBuilder() override;

        CharReader* newCharReader() const override;

        /** \return true if 'settings' are legal and consistent;
         *   otherwise, indicate bad settings via 'invalid'.
         */
        bool validate(Json::Value* invalid) const;

        /** A simple way to update a specific setting.
         */
        Value& operator[](const String& key);

        /** Called by ctor, but you can use this to reset settings_.
         * \pre 'settings' != NULL (but Json::null is fine)
         * \remark Defaults:
         * \snippet src/lib_json/json_reader.cpp CharReaderBuilderDefaults
         */
        static void setDefaults(Json::Value* settings);
        /** Same as old Features::strictMode().
         * \pre 'settings' != NULL (but Json::null is fine)
         * \remark Defaults:
         * \snippet src/lib_json/json_reader.cpp CharReaderBuilderStrictMode
         */
        static void strictMode(Json::Value* settings);
    };

    /** Consume entire stream and use its begin/end.
     * Someday we might have a real StreamReader, but for now this
     * is convenient.
     */
    bool JSON_API parseFromStream(CharReader::Factory const&, IStream&, Value* root,
        String* errs);

    /** \brief Read from 'sin' into 'root'.
     *
     * Always keep comments from the input JSON.
     *
     * This can be used to read a file into a particular sub-object.
     * For example:
     *   \code
     *   Json::Value root;
     *   cin >> root["dir"]["file"];
     *   cout << root;
     *   \endcode
     * Result:
     * \verbatim
     * {
     * "dir": {
     *    "file": {
     *    // The input stream JSON would be nested here.
     *    }
     * }
     * }
     * \endverbatim
     * \throw std::exception on parse error.
     * \see Json::operator<<()
     */
    JSON_API IStream& operator>>(IStream&, Value&);

} // namespace Json

#pragma pack(pop)

#if defined(JSONCPP_DISABLE_DLL_INTERFACE_WARNING)
#pragma warning(pop)
#endif // if defined(JSONCPP_DISABLE_DLL_INTERFACE_WARNING)

#endif // CPPTL_JSON_READER_H_INCLUDED

// //////////////////////////////////////////////////////////////////////
// End of content of file: include/json/reader.h
// //////////////////////////////////////////////////////////////////////






// //////////////////////////////////////////////////////////////////////
// Beginning of content of file: include/json/writer.h
// //////////////////////////////////////////////////////////////////////

// Copyright 2007-2010 Baptiste Lepilleur and The JsonCpp Authors
// Distributed under MIT license, or public domain if desired and
// recognized in your jurisdiction.
// See file LICENSE for detail or copy at http://jsoncpp.sourceforge.net/LICENSE

#ifndef JSON_WRITER_H_INCLUDED
#define JSON_WRITER_H_INCLUDED

#if !defined(JSON_IS_AMALGAMATION)
#include "value.h"
#endif // if !defined(JSON_IS_AMALGAMATION)
#include <ostream>
#include <string>
#include <vector>

// Disable warning C4251: <data member>: <type> needs to have dll-interface to
// be used by...
#if defined(JSONCPP_DISABLE_DLL_INTERFACE_WARNING) && defined(_MSC_VER)
#pragma warning(push)
#pragma warning(disable : 4251)
#endif // if defined(JSONCPP_DISABLE_DLL_INTERFACE_WARNING)

#pragma pack(push, 8)

namespace Json {

    class Value;

    /**
     *
     * Usage:
     *  \code
     *  using namespace Json;
     *  void writeToStdout(StreamWriter::Factory const& factory, Value const& value)
     * { std::unique_ptr<StreamWriter> const writer( factory.newStreamWriter());
     *    writer->write(value, &std::cout);
     *    std::cout << std::endl;  // add lf and flush
     *  }
     *  \endcode
     */
    class JSON_API StreamWriter {
    protected:
        OStream* sout_; // not owned; will not delete
    public:
        StreamWriter();
        virtual ~StreamWriter();
        /** Write Value into document as configured in sub-class.
         *   Do not take ownership of sout, but maintain a reference during function.
         *   \pre sout != NULL
         *   \return zero on success (For now, we always return zero, so check the
         *   stream instead.) \throw std::exception possibly, depending on
         * configuration
         */
        virtual int write(Value const& root, OStream* sout) = 0;

        /** \brief A simple abstract factory.
         */
        class JSON_API Factory {
        public:
            virtual ~Factory();
            /** \brief Allocate a CharReader via operator new().
             * \throw std::exception if something goes wrong (e.g. invalid settings)
             */
            virtual StreamWriter* newStreamWriter() const = 0;
        }; // Factory
    };   // StreamWriter

    /** \brief Write into stringstream, then return string, for convenience.
     * A StreamWriter will be created from the factory, used, and then deleted.
     */
    String JSON_API writeString(StreamWriter::Factory const& factory,
        Value const& root);

    /** \brief Build a StreamWriter implementation.

    * Usage:
    *   \code
    *   using namespace Json;
    *   Value value = ...;
    *   StreamWriterBuilder builder;
    *   builder["commentStyle"] = "None";
    *   builder["indentation"] = "   ";  // or whatever you like
    *   std::unique_ptr<Json::StreamWriter> writer(
    *      builder.newStreamWriter());
    *   writer->write(value, &std::cout);
    *   std::cout << std::endl;  // add lf and flush
    *   \endcode
    */
    class JSON_API StreamWriterBuilder : public StreamWriter::Factory {
    public:
        // Note: We use a Json::Value so that we can add data-members to this class
        // without a major version bump.
        /** Configuration of this builder.
         *  Available settings (case-sensitive):
         *  - "commentStyle": "None" or "All"
         *  - "indentation":  "<anything>".
         *  - Setting this to an empty string also omits newline characters.
         *  - "enableYAMLCompatibility": false or true
         *  - slightly change the whitespace around colons
         *  - "dropNullPlaceholders": false or true
         *  - Drop the "null" string from the writer's output for nullValues.
         *    Strictly speaking, this is not valid JSON. But when the output is being
         *    fed to a browser's JavaScript, it makes for smaller output and the
         *    browser can handle the output just fine.
         *  - "useSpecialFloats": false or true
         *  - If true, outputs non-finite floating point values in the following way:
         *    NaN values as "NaN", positive infinity as "Infinity", and negative
         *  infinity as "-Infinity".
         *  - "precision": int
         *  - Number of precision digits for formatting of real values.
         *  - "precisionType": "significant"(default) or "decimal"
         *  - Type of precision for formatting of real values.

         *  You can examine 'settings_` yourself
         *  to see the defaults. You can also write and read them just like any
         *  JSON Value.
         *  \sa setDefaults()
         */
        Json::Value settings_;

        StreamWriterBuilder();
        ~StreamWriterBuilder() override;

        /**
         * \throw std::exception if something goes wrong (e.g. invalid settings)
         */
        StreamWriter* newStreamWriter() const override;

        /** \return true if 'settings' are legal and consistent;
         *   otherwise, indicate bad settings via 'invalid'.
         */
        bool validate(Json::Value* invalid) const;
        /** A simple way to update a specific setting.
         */
        Value& operator[](const String& key);

        /** Called by ctor, but you can use this to reset settings_.
         * \pre 'settings' != NULL (but Json::null is fine)
         * \remark Defaults:
         * \snippet src/lib_json/json_writer.cpp StreamWriterBuilderDefaults
         */
        static void setDefaults(Json::Value* settings);
    };

    /** \brief Abstract class for writers.
     * \deprecated Use StreamWriter. (And really, this is an implementation detail.)
     */
    class JSONCPP_DEPRECATED("Use StreamWriter instead") JSON_API Writer {
    public:
        virtual ~Writer();

        virtual String write(const Value & root) = 0;
    };

    /** \brief Outputs a Value in <a HREF="http://www.json.org">JSON</a> format
     *without formatting (not human friendly).
     *
     * The JSON document is written in a single line. It is not intended for 'human'
     *consumption,
     * but may be useful to support feature such as RPC where bandwidth is limited.
     * \sa Reader, Value
     * \deprecated Use StreamWriterBuilder.
     */
#if defined(_MSC_VER)
#pragma warning(push)
#pragma warning(disable : 4996) // Deriving from deprecated class
#endif
    class JSONCPP_DEPRECATED("Use StreamWriterBuilder instead") JSON_API FastWriter
        : public Writer{
    public:
      FastWriter();
      ~FastWriter() override = default;

      void enableYAMLCompatibility();

      /** \brief Drop the "null" string from the writer's output for nullValues.
       * Strictly speaking, this is not valid JSON. But when the output is being
       * fed to a browser's JavaScript, it makes for smaller output and the
       * browser can handle the output just fine.
       */
      void dropNullPlaceholders();

      void omitEndingLineFeed();

    public: // overridden from Writer
      String write(const Value& root) override;

    private:
      void writeValue(const Value& value);

      String document_;
      bool yamlCompatibilityEnabled_{false};
      bool dropNullPlaceholders_{false};
      bool omitEndingLineFeed_{false};
    };
#if defined(_MSC_VER)
#pragma warning(pop)
#endif

    /** \brief Writes a Value in <a HREF="http://www.json.org">JSON</a> format in a
     *human friendly way.
     *
     * The rules for line break and indent are as follow:
     * - Object value:
     *     - if empty then print {} without indent and line break
     *     - if not empty the print '{', line break & indent, print one value per
     *line
     *       and then unindent and line break and print '}'.
     * - Array value:
     *     - if empty then print [] without indent and line break
     *     - if the array contains no object value, empty array or some other value
     *types,
     *       and all the values fit on one lines, then print the array on a single
     *line.
     *     - otherwise, it the values do not fit on one line, or the array contains
     *       object or non empty array, then print one value per line.
     *
     * If the Value have comments then they are outputed according to their
     *#CommentPlacement.
     *
     * \sa Reader, Value, Value::setComment()
     * \deprecated Use StreamWriterBuilder.
     */
#if defined(_MSC_VER)
#pragma warning(push)
#pragma warning(disable : 4996) // Deriving from deprecated class
#endif
    class JSONCPP_DEPRECATED("Use StreamWriterBuilder instead") JSON_API
        StyledWriter : public Writer{
    public:
      StyledWriter();
      ~StyledWriter() override = default;

    public: // overridden from Writer
      /** \brief Serialize a Value in <a HREF="http://www.json.org">JSON</a> format.
       * \param root Value to serialize.
       * \return String containing the JSON document that represents the root value.
       */
      String write(const Value & root) override;

    private:
      void writeValue(const Value & value);
      void writeArrayValue(const Value & value);
      bool isMultilineArray(const Value & value);
      void pushValue(const String & value);
      void writeIndent();
      void writeWithIndent(const String & value);
      void indent();
      void unindent();
      void writeCommentBeforeValue(const Value & root);
      void writeCommentAfterValueOnSameLine(const Value & root);
      static bool hasCommentForValue(const Value & value);
      static String normalizeEOL(const String & text);

      typedef std::vector<String> ChildValues;

      ChildValues childValues_;
      String document_;
      String indentString_;
      unsigned int rightMargin_{74};
      unsigned int indentSize_{3};
      bool addChildValues_{false};
    };
#if defined(_MSC_VER)
#pragma warning(pop)
#endif

    /** \brief Writes a Value in <a HREF="http://www.json.org">JSON</a> format in a
     human friendly way,
         to a stream rather than to a string.
     *
     * The rules for line break and indent are as follow:
     * - Object value:
     *     - if empty then print {} without indent and line break
     *     - if not empty the print '{', line break & indent, print one value per
     line
     *       and then unindent and line break and print '}'.
     * - Array value:
     *     - if empty then print [] without indent and line break
     *     - if the array contains no object value, empty array or some other value
     types,
     *       and all the values fit on one lines, then print the array on a single
     line.
     *     - otherwise, it the values do not fit on one line, or the array contains
     *       object or non empty array, then print one value per line.
     *
     * If the Value have comments then they are outputed according to their
     #CommentPlacement.
     *
     * \sa Reader, Value, Value::setComment()
     * \deprecated Use StreamWriterBuilder.
     */
#if defined(_MSC_VER)
#pragma warning(push)
#pragma warning(disable : 4996) // Deriving from deprecated class
#endif
    class JSONCPP_DEPRECATED("Use StreamWriterBuilder instead") JSON_API
        StyledStreamWriter {
    public:
        /**
         * \param indentation Each level will be indented by this amount extra.
         */
        StyledStreamWriter(String indentation = "\t");
        ~StyledStreamWriter() = default;

    public:
        /** \brief Serialize a Value in <a HREF="http://www.json.org">JSON</a> format.
         * \param out Stream to write to. (Can be ostringstream, e.g.)
         * \param root Value to serialize.
         * \note There is no point in deriving from Writer, since write() should not
         * return a value.
         */
        void write(OStream & out, const Value & root);

    private:
        void writeValue(const Value & value);
        void writeArrayValue(const Value & value);
        bool isMultilineArray(const Value & value);
        void pushValue(const String & value);
        void writeIndent();
        void writeWithIndent(const String & value);
        void indent();
        void unindent();
        void writeCommentBeforeValue(const Value & root);
        void writeCommentAfterValueOnSameLine(const Value & root);
        static bool hasCommentForValue(const Value & value);
        static String normalizeEOL(const String & text);

        typedef std::vector<String> ChildValues;

        ChildValues childValues_;
        OStream* document_;
        String indentString_;
        unsigned int rightMargin_{ 74 };
        String indentation_;
        bool addChildValues_ : 1;
        bool indented_ : 1;
    };
#if defined(_MSC_VER)
#pragma warning(pop)
#endif

#if defined(JSON_HAS_INT64)
    String JSON_API valueToString(Int value);
    String JSON_API valueToString(UInt value);
#endif // if defined(JSON_HAS_INT64)
    String JSON_API valueToString(LargestInt value);
    String JSON_API valueToString(LargestUInt value);
    String JSON_API valueToString(
        double value, unsigned int precision = Value::defaultRealPrecision,
        PrecisionType precisionType = PrecisionType::significantDigits);
    String JSON_API valueToString(bool value);
    String JSON_API valueToQuotedString(const char* value);

    /// \brief Output using the StyledStreamWriter.
    /// \see Json::operator>>()
    JSON_API OStream& operator<<(OStream&, const Value& root);

} // namespace Json

#pragma pack(pop)

#if defined(JSONCPP_DISABLE_DLL_INTERFACE_WARNING)
#pragma warning(pop)
#endif // if defined(JSONCPP_DISABLE_DLL_INTERFACE_WARNING)

#endif // JSON_WRITER_H_INCLUDED

// //////////////////////////////////////////////////////////////////////
// End of content of file: include/json/writer.h
// //////////////////////////////////////////////////////////////////////






// //////////////////////////////////////////////////////////////////////
// Beginning of content of file: include/json/assertions.h
// //////////////////////////////////////////////////////////////////////

// Copyright 2007-2010 Baptiste Lepilleur and The JsonCpp Authors
// Distributed under MIT license, or public domain if desired and
// recognized in your jurisdiction.
// See file LICENSE for detail or copy at http://jsoncpp.sourceforge.net/LICENSE

#ifndef CPPTL_JSON_ASSERTIONS_H_INCLUDED
#define CPPTL_JSON_ASSERTIONS_H_INCLUDED

#include <cstdlib>
#include <sstream>

#if !defined(JSON_IS_AMALGAMATION)
#include "config.h"
#endif // if !defined(JSON_IS_AMALGAMATION)

/** It should not be possible for a maliciously designed file to
 *  cause an abort() or seg-fault, so these macros are used only
 *  for pre-condition violations and internal logic errors.
 */
#if JSON_USE_EXCEPTION

 // @todo <= add detail about condition in exception
#define JSON_ASSERT(condition)                                                 \
  {                                                                            \
    if (!(condition)) {                                                        \
      Json::throwLogicError("assert json failed");                             \
    }                                                                          \
  }

#define JSON_FAIL_MESSAGE(message)                                             \
  {                                                                            \
    OStringStream oss;                                                         \
    oss << message;                                                            \
    Json::throwLogicError(oss.str());                                          \
    abort();                                                                   \
  }

#else // JSON_USE_EXCEPTION

#define JSON_ASSERT(condition) assert(condition)

 // The call to assert() will show the failure message in debug builds. In
 // release builds we abort, for a core-dump or debugger.
#define JSON_FAIL_MESSAGE(message)                                             \
  {                                                                            \
    OStringStream oss;                                                         \
    oss << message;                                                            \
    assert(false && oss.str().c_str());                                        \
    abort();                                                                   \
  }

#endif

#define JSON_ASSERT_MESSAGE(condition, message)                                \
  if (!(condition)) {                                                          \
    JSON_FAIL_MESSAGE(message);                                                \
  }

#endif // CPPTL_JSON_ASSERTIONS_H_INCLUDED

// //////////////////////////////////////////////////////////////////////
// End of content of file: include/json/assertions.h
// //////////////////////////////////////////////////////////////////////





#endif //ifndef JSON_AMALGAMATED_H_INCLUDED

```

`Lumina/Lumina/common/utils.cpp`:

```cpp
#include "utils.h"

#include "../sdk/interfaces.h"
#include "common.h"
//#include "includes.h"

#include <algorithm>
#include <xutility>
#include <stdarg.h>
#include <fstream>
#include <string>

int utils::GetWavDuration(struct WavFileHeader* hdr)
{
	int numSamples = hdr->subchunk2_size / (hdr->num_channels * (hdr->bits_per_sample / 8));
	int durationSeconds = numSamples / hdr->sample_rate;
	return durationSeconds;
}

void utils::WriteFileFromBuffer(std::string file, BYTE* buffer, int size) {
	FILE* pFile;
	pFile = fopen(file.c_str(), "wb");
	fwrite(buffer, 1, size * sizeof(BYTE), pFile);
	fclose(pFile);
}

WavFileHeader* utils::ReadWavFileHeader(std::string file) {

	FILE* pFile;
	pFile = fopen(file.c_str(), "r");

	WavFileHeader* buffer = (WavFileHeader*)malloc(sizeof(WavFileHeader));

	fread(buffer, 1, sizeof(WavFileHeader), pFile);
	fclose(pFile);

	return buffer;
}

bool utils::FileExists(const std::string& name) {
	if (FILE* file = fopen(name.c_str(), "r")) {
		fclose(file);
		return true;
	}
	else {
		return false;
	}
}


std::vector<paint_kit> utils::getSkinsInfo() {

	// from : aristoise

	std::vector<paint_kit> skins = std::vector<paint_kit>();
	/*
	const auto V_UCS2ToUTF8 = static_cast<int(*)(const wchar_t* ucs2, char* utf8, int len)>( interfaces::UCS2ToUTF8 );
	const auto sig_address = (DWORD*)interfaces::itemSchema;
	const auto item_system_offset = *reinterpret_cast<std::int32_t*>(sig_address + 1);
	const auto item_system_fn = reinterpret_cast<CCStrike15ItemSystem * (*)()>(sig_address + 5 + item_system_offset);
	
	const auto item_schema = (CCStrike15ItemSchema*)(uintptr_t(item_system_fn()) + sizeof(void*));
	{
		const auto get_paint_kit_definition_offset = *(int*)(sig_address + 11 + 1);
		//const auto get_paint_kit_definition_fn = reinterpret_cast<paint_kit_t * (__thiscall*)(CCStrike15ItemSchema*, int)>(sig_address + 11 + 5 + get_paint_kit_definition_offset);
		//const auto start_element_offset = *reinterpret_cast<std::intptr_t*>(std::uintptr_t(get_paint_kit_definition_fn) + 8 + 2);
		//const auto head_offset = start_element_offset - 12;
		//const auto map_head = reinterpret_cast<head_t<int, paint_kit_t*>*>(std::uintptr_t(item_schema) + head_offset);
		
		
		for (auto i = 0; i <= map_head->last_element; ++i) {
			
			const auto paint_kit = map_head->memory[i].value;
			
			if (paint_kit->id == 9001)
				continue;
			
			const auto wide_name = interfaces::localize->Find(paint_kit->item_name.buffer + 1);
			char name[256];

			V_UCS2ToUTF8(wide_name, name, sizeof(name));

			if (paint_kit->id < 10000)
				skins.push_back({ paint_kit->id, name });

		}
		
		std::sort(skins.begin(), skins.end());
	}*/

	return skins;
}

bool utils::precacheModel(const char* szModelName)
{
	VMProtectBeginMutation("utils::precacheModel");

	// thx to : https://www.unknowncheats.me/forum/counterstrike-global-offensive/214919-precache-models.html

	INetworkStringTable* m_pModelPrecacheTable = interfaces::clientStringTableContainer->FindTable(XorStr("modelprecache"));

	if (m_pModelPrecacheTable)
	{
		interfaces::modelInfo->FindOrLoadModel(szModelName);

		int idx = m_pModelPrecacheTable->AddString(false, szModelName);

		if (idx == -1)
			return false;
	}

	VMProtectEnd();

	return true;
}

bool utils::getEntityBox(Entity* ent, box& in) {

	VMProtectBeginMutation("utils::getEntityBox");

	// from : aristoise

	Vector origin, min, max, flb, brt, blb, frt, frb, brb, blt, flt;
	float left, top, right, bottom;

	origin = ent->getAbsoluteOrigin();
	min = ((ICollideable*)ent->GetCollideable())->OBBMins() + origin;
	max = ((ICollideable*)ent->GetCollideable())->OBBMaxs() + origin;

	Vector points[] = {
		Vector(min.x, min.y, min.z),
		Vector(min.x, max.y, min.z),
		Vector(max.x, max.y, min.z),
		Vector(max.x, min.y, min.z),
		Vector(max.x, max.y, max.z),
		Vector(min.x, max.y, max.z),
		Vector(min.x, min.y, max.z),
		Vector(max.x, min.y, max.z)
	};

	if (!interfaces::debugOverlay->WorldToScreen(points[3], flb) || !interfaces::debugOverlay->WorldToScreen(points[5], brt)
		|| !interfaces::debugOverlay->WorldToScreen(points[0], blb) || !interfaces::debugOverlay->WorldToScreen(points[4], frt)
		|| !interfaces::debugOverlay->WorldToScreen(points[2], frb) || !interfaces::debugOverlay->WorldToScreen(points[1], brb)
		|| !interfaces::debugOverlay->WorldToScreen(points[6], blt) || !interfaces::debugOverlay->WorldToScreen(points[7], flt))
		return false;

	Vector arr[] = { flb, brt, blb, frt, frb, brb, blt, flt };

	left = flb.x;
	top = flb.y;
	right = flb.x;
	bottom = flb.y;

	for (int i = 1; i < 8; i++) {
		if (left > arr[i].x)
			left = arr[i].x;
		if (bottom < arr[i].y)
			bottom = arr[i].y;
		if (right < arr[i].x)
			right = arr[i].x;
		if (top > arr[i].y)
			top = arr[i].y;
	}

	in.x = (int)left;
	in.y = (int)top;
	in.w = int(right - left);
	in.h = int(bottom - top);

	VMProtectEnd();

	return true;
}
```

`Lumina/Lumina/common/utils.h`:

```h
#ifndef utils_h

#define utils_h

#include "../sdk/math/Vector.h"
#include "../sdk/structs/mystructs.h"
#include "../sdk/structs/Entity.h"

#include <vector>
#include "../sdk/structs/structs.h"

struct WavFileHeader {
	char chunk_id[4];
	int chunk_size;
	char format[4];
	char subchunk1_id[4];
	int subchunk1_size;
	short int audio_format;
	short int num_channels;
	int sample_rate;
	int byte_rate;
	short int block_align;
	short int bits_per_sample;
	char subchunk2_id[4];
	int subchunk2_size;
};

struct WavFile {
	WavFileHeader* buffer;
	DWORD size;

	WavFile(WavFileHeader* buffer, DWORD size) {
		this->buffer = buffer;
		this->size = size;
	}
};


namespace utils
{
	std::vector<paint_kit> getSkinsInfo();
	bool getEntityBox(Entity* ent, box& in);
	bool precacheModel(const char* szModelName);

	bool FileExists(const std::string& name);
	WavFileHeader* ReadWavFileHeader(std::string fname);
	int GetWavDuration(struct WavFileHeader* hdr);
	void WriteFileFromBuffer(std::string file, BYTE* buffer, int size);
}

#endif // !utils_h
```

`Lumina/Lumina/common/vfunc.h`:

```h
#ifndef vfunc_h

#define vfunc_h

namespace vfunc {

	template <typename T> T get_vfunc(void *v_table, const int i_index) { return (*static_cast<T**>(v_table))[i_index]; }
}

#define MEMEBR_FUNC_ARGS(...) ( this, __VA_ARGS__ ); }
#define FUNCARGS(...) ( __VA_ARGS__ ); }
#define VFUNC( index, func, sig ) auto func { return vfunc::get_vfunc< sig >( this, index ) MEMEBR_FUNC_ARGS
#define MFUNC(func, sig, offset) auto func { return reinterpret_cast< sig >( offset ) MEMEBR_FUNC_ARGS
#define FUNC(func, sig, offset) auto func { return reinterpret_cast< sig >( offset ) FUNCARGS

#endif
```

`Lumina/Lumina/exportOrdinals.def`:

```def
LIBRARY
EXPORTS
   Breakpad_SetSteamID   @1
   CreateInterface   @2
   g_dwDllEntryThreadId   @3
```

`Lumina/Lumina/features/backtrack/backtrack.cpp`:

```cpp
#include "backtrack.h"

#include "../../sdk/interfaces.h"
#include "../../common/config.h"

namespace backtrack {

	std::deque<stored_records> records[65];
	backtrack_convars vars;

	void init() {

		VMProtectBeginMutation("backtrack::init");

		vars.update_rate = (ConVar*)interfaces::console->get_convar(StringHeavy("cl_updaterate"));
		vars.max_update_rate = (ConVar*)interfaces::console->get_convar(StringHeavy("sv_maxupdaterate"));
		vars.min_interp_ratio = (ConVar*)interfaces::console->get_convar(StringHeavy("sv_client_min_interp_ratio"));
		vars.max_interp_ratio = (ConVar*)interfaces::console->get_convar(StringHeavy("sv_client_max_interp_ratio"));
		vars.max_unlag = (ConVar*)interfaces::console->get_convar(StringHeavy("sv_maxunlag"));
		vars.interp = (ConVar*)interfaces::console->get_convar(StringHeavy("cl_interp"));
		vars.interp_ratio = (ConVar*)interfaces::console->get_convar(StringHeavy("cl_interp_ratio"));

		records->clear();

		VMProtectEnd();
	}

	float get_lerp_time() {

		//VMProtectBeginMutation("backtrack::get_lerp_time");

		JUNK_0(tmp0)
			tmp0:

		auto ratio = std::clamp(vars.interp_ratio->get_float(), (vars.min_interp_ratio->get_float() != 1.f) ? vars.min_interp_ratio->get_float() : 1.f, vars.max_interp_ratio->get_float());

		JUNK_0(tmp1)
			tmp1:

		auto result = max(vars.interp->get_float(), (ratio / ((vars.max_update_rate) ? vars.max_update_rate->get_float() : vars.update_rate->get_float())));

		JUNK_0(tmp2) 
			tmp2:

		//VMProtectEnd(); 
		
		return result;
	}

	void update() {

		VMProtectBeginMutation("backtrack::update");

		auto local_player = game::getLocalPlayer();

		if (!config::cheats.backtrack || !local_player || !local_player->isAlive()) {

			if (!records->empty())
				records->clear();

			return;
		}

		for (int i = 1; i <= interfaces::globals->maxClients; i++) {

			auto entity = (Entity*)(interfaces::clientEntityList->GetClientEntity(i));

			if (!entity || entity == local_player || entity->m_bDormant() || !entity->isAlive() || entity->m_iTeamNum() == local_player->m_iTeamNum()) {

				if (records[i].size() > 2)
					records[i].clear();

				continue;
			}

			auto& rec = records[i];

			for (auto r = rec.begin(); r != rec.end();) {
				if (!valid_tick(r->simulation_time))
					r = rec.erase(r);
				else
					r++;
			}

			if (records[i].size() && (records[i].front().simulation_time == entity->simulation_time()))
				continue;

			while (records[i].size() > 3 && records[i].size() > static_cast<size_t>(time_to_ticks_2(static_cast<float>(config::cheats.backtrackTime) / 1000.f)))
				records[i].pop_back();

			auto var_map = reinterpret_cast<uintptr_t>(entity) + 0x24;
			auto vars_count = *reinterpret_cast<int*>(static_cast<uintptr_t>(var_map) + 0x14);

			for (int j = 0; j < vars_count; j++)
				*reinterpret_cast<uintptr_t*>(*reinterpret_cast<uintptr_t*>(var_map) + j * 0xC) = 0;

			stored_records record{ };
			record.head = get_hitbox_position(entity, HITBOX_HEAD);
			record.simulation_time = entity->simulation_time();

			entity->setup_bones(record.matrix, 128, 0x7FF00, interfaces::globals->curtime);

			records[i].push_front(record);
		}

		VMProtectEnd();
	}

	void run(void* cmd_) {

		VMProtectBeginMutation("backtrack::run");

		if (!config::cheats.backtrack)
			return;

		CUserCmd* cmd = (CUserCmd*)cmd_;

		if (!(cmd->buttons & IN_ATTACK))
			return;

		auto local_player = game::getLocalPlayer();

		if (!local_player)
			return;

		auto best_fov{ 255.f };
		Entity* best_target{ };
		int besst_target_index{ };
		Vector best_target_head_position{ };
		int best_record{ };

		for (int i = 1; i <= interfaces::globals->maxClients; i++) {

			auto entity = (Entity*)(interfaces::clientEntityList->GetClientEntity(i));

			if (!entity || entity == local_player || entity->m_bDormant() || !entity->isAlive() || entity->m_iTeamNum() == local_player->m_iTeamNum())
				continue;

			auto head_position = entity->get_bone_position(8);

			auto angle = math::calculate_angle(local_player->get_eye_pos(), head_position, cmd->viewangles);

			auto fov = std::hypotf(angle.x, angle.y);

			if (fov < best_fov) {
				best_fov = fov;
				best_target = entity;
				besst_target_index = i;
				best_target_head_position = head_position;
			}
		}

		if (best_target) {

			if (records[besst_target_index].size() <= 3)
				return;

			best_fov = 255.f;

			for (size_t i = 0; i < records[besst_target_index].size(); i++) {

				auto record = &records[besst_target_index][i];

				if (!record || !valid_tick(record->simulation_time))
					continue;

				auto angle = math::calculate_angle(local_player->get_eye_pos(), record->head, cmd->viewangles);

				auto fov = std::hypotf(angle.x, angle.y);

				if (fov < best_fov) {
					best_fov = fov;
					best_record = i;
				}
			}
		}

		if (best_record) {

			auto record = records[besst_target_index][best_record];
			cmd->tick_count = time_to_ticks_2(record.simulation_time);
		}

		VMProtectEnd();
	}

	Vector get_hitbox_position(Entity* entity, int hitbox_id) {

		//VMProtectBeginMutation("backtrack::get_hitbox_position");

		matrix3x4_t bone_matrix[128];

		// NOTE : I can't use mutation on this function due to fps, so, I use random JUNK_0 just for sign (useless)

		JUNK_0(tmp0)
			tmp0:

		if (entity->setup_bones(bone_matrix, 128, BONE_USED_BY_HITBOX, 0.0f)) {

			JUNK_0(tmp1) 
				tmp1:

			auto studio_model = interfaces::modelInfo->GetStudioModel(entity->model());

			JUNK_0(tmp2)
				tmp2:

			if (studio_model) {

				auto hitbox = studio_model->pHitboxSet(0)->pHitbox(hitbox_id);

				JUNK_0(tmp3)
					tmp3:

				if (hitbox) {

					auto min = Vector{}, max = Vector{};

					JUNK_0(tmp4) 
						tmp4:

					math::transform_vector(hitbox->bbmin, bone_matrix[hitbox->bone], min);

					JUNK_0(tmp5)
						tmp5:

					math::transform_vector(hitbox->bbmax, bone_matrix[hitbox->bone], max);

					JUNK_0(tmp6)
						tmp6:

					return Vector((min.x + max.x) * 0.5f, (min.y + max.y) * 0.5f, (min.z + max.z) * 0.5f);
				}
			}
		}

		//VMProtectEnd();

		return Vector{};
	}

	bool valid_tick(float simtime) {

		//VMProtectBeginMutation("backtrack::valid_tick");

		auto network = interfaces::engineClient->GetNetChannelInfo();

		JUNK_0(tmp0) 
			tmp0:

		if (!network)
			return false;

		JUNK_0(tmp1) 
			tmp1:

		auto delta = std::clamp(network->GetLatency(0) + get_lerp_time(), 0.f, vars.max_unlag->get_float()) - (interfaces::globals->curtime - simtime);
		
		JUNK_0(tmp2)
			tmp2:

		bool result = std::fabsf(delta) <= 0.2f;

		JUNK_0(tmp3) 
			tmp3:

		//VMProtectEnd();
		
		return result;
	}


	int time_to_ticks_2(float time) {

		//VMProtectBeginMutation("backtrack::time_to_ticks_2");

		int result = static_cast<int>((0.5f + static_cast<float>(time) / interfaces::globals->interval_per_tick));

		JUNK_0(tmp0)
			tmp0:

		//VMProtectEnd();

		return result;
	}
}




```

`Lumina/Lumina/features/backtrack/backtrack.h`:

```h
#ifndef backtrack_h

#define backtrack_h

#include "../../common/includes.h"

// modded from aristois


struct stored_records {
	Vector head;
	float simulation_time;
	matrix3x4_t matrix[128];
};

struct backtrack_convars {
	ConVar* update_rate;
	ConVar* max_update_rate;
	ConVar* interp;
	ConVar* interp_ratio;
	ConVar* min_interp_ratio;
	ConVar* max_interp_ratio;
	ConVar* max_unlag;
};

namespace backtrack {

	extern std::deque<stored_records> records[65];
	extern backtrack_convars vars;

	void update();
	void run(void*);
	Vector get_hitbox_position(Entity* entity, int hitbox_id);
	float get_lerp_time();
	int time_to_ticks_2(float time);
	bool valid_tick(float simtime);
	void init();
}

#endif // !backtrack_h
```

`Lumina/Lumina/features/misc/misc.cpp`:

```cpp
#include "misc.h"

#include "../../common/includes.h"
#include "../../sdk/interfaces.h"
#include "../visuals/skinchanger.h"
#include "../../ui/sound.h"
#include "../../common/game.h"
#include "../../common/common.h"
#include "../../common/events.h"
#include "voice.h"

bool misc::nameChanged = false;

void misc::hitmarkerSound(void* event, void* eventInfo) {

	VMProtectBeginMutation("misc::hitmarkerSound");

	if (!config::visual.sounds.enable)
		return;

	auto pEvent = (IGameEvent*)event;
	auto localPlayer = game::getLocalPlayer();

	if (!localPlayer || !game::isEnvironmentValid())
		return;

	int userIdAttacker = pEvent->GetInt(XorStr("attacker"), -1);

	if (userIdAttacker == -1)
		return;

	auto id = interfaces::engineClient->GetPlayerForUserID(userIdAttacker);

	if (!id)
		return;

	auto attacker = (Entity*)interfaces::clientEntityList->GetClientEntity(id);

	if (!attacker)
		return;

	if (!attacker->isPlayer())
		return;

	int userIdVictime = pEvent->GetInt(XorStr("userid"), -1);

	if (userIdVictime == -1)
		return;

	auto id2 = interfaces::engineClient->GetPlayerForUserID(userIdVictime);

	if (!id2)
		return;

	auto victime = (Entity*)(interfaces::clientEntityList->GetClientEntity(id2));

	if (!victime)
		return;

	if (!victime->isPlayer())
		return;

	if (victime == localPlayer)
		return;

	if (attacker == localPlayer) {

		int sound_index = config::visual.sounds.hitmarkerSound.index;

		if (config::visual.sounds.hitmarkerSound.random)
			sound_index = rand() % sound::sounds_short.size();

		sound::playSoundShort(sound_index);

		if (config::visual.sounds.hitmarkerSound.through_mic)
			voice::play(sound_index);

		common::hitmarkerTime = 255;
		common::hitmarkerDamage = pEvent->GetInt(XorStr("dmg_health"));
	}

	VMProtectEnd();
}

//void misc::fixSkin(void* event, void* eventInfo) {
//
//	VMProtectBeginMutation("misc::fixSkin");
//
//	auto pEvent = (IGameEvent*)event;
//
//	auto localPlayer = game::getLocalPlayer();
//
//	if (!localPlayer)
//		return;
//
//	int spawnedUserId = pEvent->GetInt(XorStr("userid"), -1);
//
//	if (spawnedUserId == -1)
//		return;
//
//	auto spawnedPlayerId = interfaces::engineClient->GetPlayerForUserID(spawnedUserId);
//
//	if (!spawnedPlayerId)
//		return;
//
//	auto spawnedPlayer = (Entity*)(interfaces::clientEntityList->GetClientEntity(spawnedPlayerId));
//
//	if (!spawnedPlayer)
//		return;
//
//	// localPlayer is spawning
//	if (spawnedPlayer == localPlayer) {
//
//		skinchanger::updateSkin = true;
//
//		// wait that "skin" thread refresh id's
//		//while (skinchanger::updateSkin);
//
//		//interfaces::forceUpdate();
//	}
//
//	VMProtectEnd();
//}

void misc::silentWalk(void* cmd_)
{
	//VMProtectBeginMutation("misc::silentWalk");

	//if (!config::cheats.silentWalk)
	//	return;

	//CUserCmd* cmd = (CUserCmd*)cmd_;

	//Vector moveDir = Vector(0.f, 0.f, 0.f);

	//float maxSpeed = 130.f; //can be 134 but sometimes I make a sound, 130 works perfectly

	//Entity* localPlayer = game::getLocalPlayer();

	//int movetype = localPlayer->m_nMoveType();

	//bool InAir = !(localPlayer->m_fFlags() & FL_ONGROUND);

	//if (movetype == MOVETYPE_FLY || movetype == MOVETYPE_NOCLIP || InAir || cmd->buttons & IN_DUCK || !(cmd->buttons & IN_SPEED) /* When holding knife or bomb*/) // IN_WALK doesnt work
	//	return;

	//moveDir.x = cmd->sidemove;
	//moveDir.y = cmd->forwardmove;
	//moveDir = math::ClampMagnitude(moveDir, maxSpeed);

	//cmd->sidemove = moveDir.x;
	//cmd->forwardmove = moveDir.y;

	//if (!(localPlayer->m_vecVelocity().Length2D() > maxSpeed + 1))
	//	cmd->buttons &= ~IN_SPEED;

	//VMProtectEnd();
}

void misc::fastStop(void* cmd)
{
	VMProtectBeginMutation("misc::fastStop");

	// code modded from legandware

	if (!config::cheats.fastStop)
		return;

	CUserCmd* m_pcmd = (CUserCmd*)cmd;

	Entity* localPlayer = game::getLocalPlayer();

	if (!(localPlayer->m_fFlags() & FL_ONGROUND))
		return;

	auto pressed_move_key = m_pcmd->buttons & IN_FORWARD || m_pcmd->buttons & IN_MOVELEFT || m_pcmd->buttons & IN_BACK || m_pcmd->buttons & IN_MOVERIGHT || m_pcmd->buttons & IN_JUMP;

	if (pressed_move_key)
		return;

	if (localPlayer->m_nMoveType() == MOVETYPE_NOCLIP || localPlayer->m_nMoveType() == MOVETYPE_LADDER)
		return;

	auto velocity = localPlayer->m_vecVelocity();

	if (!(!(m_pcmd->buttons & IN_ATTACK) && !(m_pcmd->buttons & IN_ATTACK2)) && velocity.Length2D() > 20.0f)
		goto execute;
	else if (velocity.Length2D() > 20.0f)
		goto execute;
	else
	{
		auto speed = 1.01f;

		static auto switch_move = false;

		if (switch_move)
			m_pcmd->sidemove += speed;
		else
			m_pcmd->sidemove -= speed;

		switch_move = !switch_move;

		return;
	}

execute:
	Vector direction;
	QAngle real_view = m_pcmd->viewangles;

	math::vector_angles(velocity, direction);

	direction.y = real_view.y - direction.y;

	Vector forward;

	math::angle_vectors(direction, forward);


	static auto cl_forwardspeed = (ConVar*)interfaces::console->get_convar(XorStr("cl_forwardspeed"));
	static auto cl_sidespeed = (ConVar*)interfaces::console->get_convar(XorStr("cl_sidespeed"));

	auto negative_forward_speed = -cl_forwardspeed->get_float();
	auto negative_side_speed = -cl_sidespeed->get_float();

	auto negative_forward_direction = forward * negative_forward_speed;
	auto negative_side_direction = forward * negative_side_speed;

	m_pcmd->forwardmove = negative_forward_direction.x;
	m_pcmd->sidemove = negative_side_direction.y;

	VMProtectEnd();
}

void misc::roundSounds(void* event, void* eventInfo_) {

	VMProtectBeginMutation("misc::roundSounds");

	if (!config::visual.sounds.enable)
		return;

	auto pEvent = (IGameEvent*)event;

	int sound_index = 0;

	if (((eventInfo*)eventInfo_)->hash == HASH("round_end")) {

		auto localPlayer = game::getLocalPlayer();

		if (!localPlayer)
			return;

		if (!localPlayer->m_iTeamNum())
			return;

		int team = localPlayer->m_iTeamNum();

		int winner = pEvent->GetInt(XorStr("winner"), -1);

		if (winner == -1)
			return;

		//sound_index = winner == team ? config::visual.sounds.roundEndWonSound.index : config::visual.sounds.roundEndLostSound.index;
		
		// TODO : clear this garbadge
		if (winner == team) {

			sound_index = config::visual.sounds.roundEndWonSound.index;

			if (config::visual.sounds.roundEndWonSound.random)
				sound_index = rand() % sound::sounds_short.size();

			sound::playSoundShort(sound_index);

			if (config::visual.sounds.roundEndWonSound.through_mic)
				voice::play(sound_index);
		}

		// NOTE : idk why but there is a case between winner == team and winner != team
		else if (winner != team)
		{
			sound_index = config::visual.sounds.roundEndLostSound.index;

			if (config::visual.sounds.roundEndLostSound.random)
				sound_index = rand() % sound::sounds_short.size();

			sound::playSoundShort(sound_index);

			if (config::visual.sounds.roundEndLostSound.through_mic)
				voice::play(sound_index);
		}
	}

	else if (((eventInfo*)eventInfo_)->hash == HASH("round_start")) {

		sound_index = config::visual.sounds.roundStartSound.index;

		if (config::visual.sounds.roundStartSound.random)
			sound_index = rand() % sound::sounds_short.size();

		sound::playSoundShort(sound_index);

		if (config::visual.sounds.roundStartSound.through_mic)
			voice::play(sound_index);
	}

	VMProtectEnd();
}

void misc::infiniteDuck(void* cmd)
{
	VMProtectBeginMutation("misc::infiniteDuck");

	if (!config::cheats.infinitDuck)
		return;

	((CUserCmd*)cmd)->buttons |= IN_BULLRUSH;

	VMProtectEnd();
}

void misc::hideVoteName() {

	VMProtectBeginMutation("misc::hideVoteName");

	static std::string player_name = "";
	static ConVar* name = game::getConvarNullCallback(XorStr("name"));

	if (!misc::nameChanged) {

		player_name.append(name->strString);

		name->set_value(XorStr("\n\xAD\xAD\xAD"));
		name->set_value(XorStr("MonsieurMisterMasterDrDetective"));

		misc::nameChanged = true;
	}

	else {

		name->set_value(XorStr("\n\xAD\xAD\xAD"));
		name->set_value(player_name.c_str());

		player_name.clear();

		misc::nameChanged = false;
	}

	VMProtectEnd();
}

void misc::fakeMessage(std::string mes) {

	//VMProtectBeginMutation("misc::fakeMessage");

	//static std::string player_name = "";
	//static ConVar* name = game::getConvarNullCallback(XorStr("name"));

	//if (!misc::nameChanged) {

	//	player_name.append(name->strString);

	//	name->set_value(XorStr("\n\xAD\xAD\xAD"));

	//	std::string message = XorStr("\x16\x02\x02\x09\x0A\x02\x07");

	//	message.append(mes.c_str());
	//	message.append(XorStr(" has been permanently banned from official CS:GO servers.\x01"));

	//	message.append(XorStr("\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x02\x00"));

	//	name->set_value(message.c_str());

	//	misc::nameChanged = true;
	//}

	//else {

	//	name->set_value(XorStr("\n\xAD\xAD\xAD"));
	//	name->set_value(player_name.c_str());

	//	player_name.clear();

	//	misc::nameChanged = false;
	//}

	//VMProtectEnd();
}

void misc::copyClipboardExploit() {

	VMProtectBeginMutation("misc::copyClipboardExploit");

	const wchar_t* strData = L"﷽﷽ ﷽﷽﷽ ﷽﷽﷽ ﷽ ﷽﷽ ﷽﷽﷽ ﷽﷽﷽ ﷽ ﷽﷽ ﷽﷽ ﷽﷽﷽ ﷽﷽﷽ ﷽ ﷽﷽ ﷽﷽﷽ ﷽﷽";

	// from stackoverflow

	if (OpenClipboard(0)) {

		EmptyClipboard();
		HGLOBAL hClipboardData;
		hClipboardData = GlobalAlloc(GMEM_DDESHARE, 2 * (wcslen(strData) + 1));
		WCHAR* pchData;
		pchData = (WCHAR*)GlobalLock(hClipboardData);
		wcscpy(pchData, strData);
		GlobalUnlock(hClipboardData);
		SetClipboardData(CF_UNICODETEXT, hClipboardData);
		CloseClipboard();
	}

	VMProtectEnd();
}

void misc::voteRealer(void* event, void* eventInfo_) {

	VMProtectBeginMutation("misc::voteRealer");

	auto pEvent = (IGameEvent*)event;

	auto localPlayer = game::getLocalPlayer();

	if (!localPlayer)
		return;

	if (((eventInfo*)eventInfo_)->hash == HASH("vote_cast")) {

		int vote = pEvent->GetInt(XorStr("vote_option"));
		int id = pEvent->GetInt(XorStr("entityid"));
		int team = pEvent->GetInt(XorStr("team"));

		player_info_t player;
		interfaces::engineClient->GetPlayerInfo(id, &player);

		if (interfaces::hudChat && player.name) {

			interfaces::hudChat->ChatPrintf(0, 0, std::string("[").
				append(XorStr("\x0A")). //Light Blue
				append(localPlayer->m_iTeamNum() == team ? XorStr("Team-mates") : XorStr("Enemy")).
				append(XorStr("\x01")). //Default Color
				append(XorStr("] ")).
				append(XorStr("Voted")).
				append((vote == 0 ? std::string(XorStr(" \x04")).append(XorStr("YES")) : std::string(XorStr(" \x02")).append(XorStr("NO")))).
				append(XorStr("\x01")). //Default Color
				append(XorStr(" : [")).
				append(XorStr("\x0A")). //Light Blue
				append(player.name).
				append(XorStr("\x01")). //Default Color
				append(XorStr("]")).c_str());

			int sound_index = config::visual.sounds.voteChangedSound.index;

			if (config::visual.sounds.voteChangedSound.random)
				sound_index = rand() % sound::sounds_short.size();

			sound::playSoundShort(sound_index);

			if (config::visual.sounds.voteChangedSound.through_mic)
				voice::play(sound_index);
		}
	}

	if (((eventInfo*)eventInfo_)->hash == HASH("vote_started")) {

		int initiator = pEvent->GetInt(XorStr("initiator"));
		int team = pEvent->GetInt(XorStr("team"));
		const char* param1 = pEvent->GetString(XorStr("param1"));
		const char* issue = pEvent->GetString(XorStr("issue"));

		auto initiator_id = interfaces::engineClient->GetPlayerForUserID(initiator);

		if (!initiator_id)
			return;

		player_info_t initiator_info;
		interfaces::engineClient->GetPlayerInfo(initiator_id, &initiator_info);
		
		if (interfaces::hudChat && initiator_info.name) {

			interfaces::hudChat->ChatPrintf(0, 0, std::string("[").
				append(XorStr("\x0A")). //Light Blue
				append(localPlayer->m_iTeamNum() == team ? XorStr("Team-mates") : XorStr("Enemy")).
				append(XorStr("\x01")). //Default Color
				append(XorStr("] [")).
				append(XorStr("\x0A")). //Light Blue
				append(initiator_info.name).
				append(XorStr("\x01")). //Default Color
				append(XorStr("] Started a vote [")).
				append(XorStr("\x04")).
				append(param1).
				append(XorStr("\x01")).
				append(XorStr("] [")).
				append(issue).
				append(XorStr("]")).c_str());
		}
	}

	VMProtectEnd();
}

void misc::headShoot(void* event, void* eventInfo) {

	VMProtectBeginMutation("misc::headShoot");

	if (!config::visual.sounds.enable)
		return;

	auto pEvent = (IGameEvent*)event;

	auto localPlayer = game::getLocalPlayer();

	if (!localPlayer)
		return;

	int userIdAttacker = pEvent->GetInt(XorStr("attacker"), -1);

	if (userIdAttacker == -1)
		return;

	auto id = interfaces::engineClient->GetPlayerForUserID(userIdAttacker);

	if (!id)
		return;

	auto attacker = (Entity*)interfaces::clientEntityList->GetClientEntity(id);

	if (!attacker)
		return;

	int headshot = pEvent->GetInt(XorStr("headshot"), -1);

	if (headshot == -1)
		return;

	if (attacker == localPlayer && headshot) {

		int sound_index = config::visual.sounds.headShootSound.index;

		if (config::visual.sounds.headShootSound.random)
			sound_index = rand() % sound::sounds_short.size();

		sound::playSoundShort(sound_index);

		if (config::visual.sounds.headShootSound.through_mic)
			voice::play(sound_index);
	}

	VMProtectEnd();
}
```

`Lumina/Lumina/features/misc/misc.h`:

```h
#ifndef misc_h_

#define misc_h_

#include <string>

namespace misc {

	extern bool nameChanged;

	void hitmarkerSound(void* event, void* eventInfo);

	//void fixSkin(void* event, void* eventInfo);

	void roundSounds(void* event, void* eventInfo);

	void headShoot(void* event, void* eventInfo);

	void fakeMessage(std::string mes);

	void fastStop(void* cmd);

	void copyClipboardExploit();

	void silentWalk(void* cmd_);

	void infiniteDuck(void* cmd);

	void hideVoteName();

	void voteRealer(void* event, void* eventInfo);
}

#endif // !misc_h_
```

`Lumina/Lumina/features/misc/soundEsp.cpp`:

```cpp
#include "soundEsp.h"

#include "../../common/includes.h"
#include "../../common/common.h"

// modded from ekknod : https://github.com/ekknod/nv_v2

namespace soundEsp {

    static Entity* _target;
    static int _target_hitbox;
    static float  start_volume, min_volume;
    static ConVar* volume;

    float get_fov(Vector vangle, Vector angle)
    {
        VMProtectBeginMutation("soundEsp::get_fov");

        Vector a0, a1;

        math::angle_vectors(vangle, a0);
        math::angle_vectors(angle, a1);

        auto fov = RAD2DEG(acos(a0.Dot(a1) / (a0.Length())));

        VMProtectEnd();

        return fov;
    }

    Vector get_target_angle(Entity* localPlayer, Entity* target, int hitbox_id)
    {
        VMProtectBeginMutation("soundEsp::get_target_angle");

        Vector m, c;

        m = target->get_bone_position(hitbox_id);
        c = localPlayer->get_eye_pos();
        c.x = m.x - c.x; c.y = m.y - c.y; c.z = m.z - c.z;
        math::vec_normalize(&c);
        math::vector_angles(c, c);
        m = localPlayer->m_viewPunchAngle();
        c.x -= m.x * 2.0f, c.y -= m.y * 2.0f, c.z -= m.z * 2.0f;
        math::vec_clamp(&c);

        VMProtectEnd();

        return c;
    }


    bool get_target(Entity* localPlayer, Vector vangle)
    {
        VMProtectBeginMutation("soundEsp::get_target");

        float     best_fov;
        int       i;
        float     fov;
        int       j;

        int hitbox_list[6] = { 5, 4, 3, 0, 7, 8 };

        best_fov = 9999.0f;

        for (int i = 0; i < interfaces::globals->maxClients; i++) {

            auto entity = reinterpret_cast<Entity*>(interfaces::clientEntityList->GetClientEntity(i));

            if (!entity)
                continue;

            if (entity->m_bDormant() || entity == localPlayer || !entity->isAlive() || !entity->isPlayer())
                continue;

            if (localPlayer->m_iTeamNum() == entity->m_iTeamNum())
                continue;

            for (j = 6; j--;) {

                fov = get_fov(vangle, get_target_angle(localPlayer, entity, hitbox_list[j]));

                if (fov < best_fov) {

                    best_fov = fov;
                    _target = entity;
                    _target_hitbox = hitbox_list[j];
                }
            }
        }

        VMProtectEnd();

        return best_fov != 9999.0f;
    }

    void remove() {

        VMProtectBeginMutation("soundEsp::remove");

        if (volume->fValue != start_volume)
            volume->set_value(start_volume);

        VMProtectEnd();
    }

    void init() {

        VMProtectBeginMutation("soundEsp::init");

        volume = game::getConvarNullCallback(XorStr("volume"));

        start_volume = volume->fValue;

        if (start_volume >= 0.30f)
            start_volume = 0.25f;

        min_volume = 1.0f - start_volume;

        VMProtectEnd();
    }

    void worker(void* cmd) {

        VMProtectBeginMutation("soundEsp::worker");

        if (!config::cheats.volumeEsp)
            return;

        auto localPlayer = game::getLocalPlayer();

        if (!game::isEnvironmentValid() || !localPlayer)
            return;

        auto vangle = ((CUserCmd*)cmd)->viewangles;

        if (!get_target(localPlayer, vangle)) {

            if (volume->fValue != start_volume)
                volume->set_value(start_volume);

            return;
        }

        auto fov = get_fov(vangle, get_target_angle(localPlayer, _target, _target_hitbox));

        if (fov <= 6.0f) {

            auto vol = 1.0f - fov / 6.0f * min_volume;

            if (vol > 1.0f || vol <= start_volume)
                return;

            volume->set_value(vol);
        }

        else {
            if (volume->fValue != start_volume)
                volume->set_value(start_volume);
        }

        VMProtectEnd();
    }
}

```

`Lumina/Lumina/features/misc/soundEsp.h`:

```h
#ifndef soundEsp_h

#define soundEsp_h

namespace soundEsp {

	void init();
	void remove();
	void worker(void* cmd);
}

#endif // !soundEsp_h
```

`Lumina/Lumina/features/misc/voice.cpp`:

```cpp
#include "voice.h"

#include "../../common/includes.h"
#include "../../common/common.h"
#include "../../ui/sound.h"

// using resources from : fluffyguy & mz & SilentSys
// source : https://www.unknowncheats.me/forum/counterstrike-global-offensive/258133-music-voice-chat.html
//          https://www.unknowncheats.me/forum/counterstrike-global-offensive/324404-playing-custom-files-voice-chat.html
//          https://github.com/SilentSys/SLAM/blob/master/SLAM/Form1.vb

// NOTE : Idk why, but I can't use Voice_RecordStart, it record my microphone IN the input file
//        so I will do it through cmd commands like SLAM

bool voice::is_playing_sound = false;
int voice::sound_end_timestamp = 0;

hash32_t voice::last_sound_played = 0;

void voice::tick() {

    VMProtectBeginMutation("voice::tick");

    // if the end-sound-time if passed
    if (is_playing_sound && interfaces::globals->curtime >= sound_end_timestamp) {

        // stop the microphone recording
        sound_end_timestamp = 0;
        stop();
    }

    VMProtectEnd();
}

void voice::play(std::size_t sound_id) {

    VMProtectBeginMutation("voice::play");

    if (!game::isEnvironmentValid())
        return;

    // if a sound is currently not stopped
    if(is_playing_sound)
        voice::stop();

    std::string original_sound_path = XorStr("csgo\\sound\\lumina\\vocal\\");

    // append the sound name
    original_sound_path.append(sound::sounds_short[sound_id]);

    if (!std::filesystem::exists(original_sound_path))
        return;

    std::string voice_input_path = XorStr("voice_input.wav");

    // get sound path hash
    hash32_t file_path_hash = FNV1a::get(original_sound_path.c_str());

    // this part is main to check if the next sound is already "installed" (name hash check)
    // in order to fast up this homemade shitty system
    // NOTE : stay safe, keep this boolean order
    if (std::filesystem::exists(voice_input_path)) {

        // check if the sound is new
        if (last_sound_played == 0 || file_path_hash != last_sound_played) {

            // delete the file old root/voice_input.wav
            std::filesystem::remove(voice_input_path);

            // copy the sound to root/voice_input.wav
            std::filesystem::copy_file(original_sound_path, voice_input_path);
        }
    }
    else {
        // copy the sound to root/voice_input.wav
        std::filesystem::copy_file(original_sound_path, voice_input_path);
    }

    // get wav file header to get its duration
    //WavFileHeader* wav_file_header = utils::ReadWavFileHeader(voice_input_path);

    //int wav_duration = utils::GetWavDuration(wav_file_header);

    // set the end-time to stop recording
    // TODO : care about the size of wav files
    sound_end_timestamp = interfaces::globals->curtime + 5;//wav_duration;

    //free(wav_file_header);

    // launch the sound
    interfaces::engineClient->ExecuteClientCmd(XorStr("voice_inputfromfile 1; voice_loopback 1; +voicerecord"));

    if(file_path_hash != last_sound_played)
        // save the current played sound hash
        last_sound_played = file_path_hash;

    is_playing_sound = true;

    VMProtectEnd();
}

void voice::stop(void) {

    VMProtectBeginMutation("voice::stop");

    // stop recording 
    interfaces::engineClient->ExecuteClientCmd(XorStr("-voicerecord; voice_inputfromfile 0; voice_loopback 0;"));

    sound_end_timestamp = 0;
    is_playing_sound = false;

    VMProtectEnd();
}
```

`Lumina/Lumina/features/misc/voice.h`:

```h
#ifndef voice_h

#define voice_h

#include <string>
#include "../../security/hash.h"

namespace voice {

    extern bool is_playing_sound;
    extern int sound_end_timestamp;
    extern hash32_t last_sound_played;

    void play(std::size_t sound_id);
    void stop();
    void tick();
};

#endif // !voice_h
```

`Lumina/Lumina/features/visuals/animationfix.cpp`:

```cpp
#include "animationfix.h"
#include "../../common/includes.h"
#include "../../sdk/interfaces.h"
#include "skinchanger.h"

namespace animationfix {

	// modded from aristois

	recv_var_proxy_fn_ sequence_proxy_fn = nullptr;
	recv_var_proxy_fn_ recv_model_index;

	void hooked_recvproxy_viewmodel(c_recv_proxy_data_* p_data, void* p_struct, void* p_out) {

		VMProtectBeginMutation("aniamtionfix::hooked_recvproxy_viewmodel");

		auto localPlayer = game::getLocalPlayer();

		if(!localPlayer || !localPlayer->isAlive())
			return recv_model_index(p_data, p_struct, p_out);

		std::vector<int> knifeModelIndexs = {};

		// grab all knife model ids
		for (std::string knifeModel : skinchanger::knifeModelNames){
			knifeModelIndexs.push_back(interfaces::modelInfo->GetModelIndex(knifeModel.c_str()));
		}

		// if current viewmodel is knife
		if (std::find(knifeModelIndexs.begin(), knifeModelIndexs.end(), p_data->value.m_int) != knifeModelIndexs.end()) {

			int knifeId = localPlayer->m_iTeamNum() == TEAM_COUNTER_TERRORIST ? config::visual.skins.ctSkins.knifeId : config::visual.skins.tSkins.knifeId;

			// set the according model id
			p_data->value.m_int = knifeModelIndexs.at(knifeId);
		}

		// reset
		recv_model_index(p_data, p_struct, p_out);

		VMProtectEnd();
	}

	void set_view_model_sequence(const c_recv_proxy_data_* pDataConst, void* p_struct, void* p_out) noexcept {

		VMProtectBeginMutation("aniamtionfix::set_view_model_sequence");

		c_recv_proxy_data_* p_data = const_cast<c_recv_proxy_data_*>(pDataConst);

		C_BaseAttributableItem* player_view_model = (C_BaseAttributableItem*)(p_struct);

		if (!player_view_model)
			return sequence_proxy_fn(p_data, p_struct, p_out);

		auto localPlayer = game::getLocalPlayer();

		if (!localPlayer || !localPlayer->isAlive())
			return sequence_proxy_fn(p_data, p_struct, p_out);

		Entity* p_owner = (Entity*)(interfaces::clientEntityList->GetClientEntity(*player_view_model->m_hOwner() & 0xFFF));

		if (p_owner != localPlayer)
			return sequence_proxy_fn(p_data, p_struct, p_out);

		std::string sz_model = interfaces::modelInfo->GetModelName(interfaces::modelInfo->GetModel(*player_view_model->m_nModelIndex()));

		hash32_t modelHash = FNV1a::get(sz_model);

		int m_nSequence = p_data->value.m_int;

		if (modelHash == HASH("models/weapons/v_knife_butterfly.mdl")) {
			switch (m_nSequence) {
			case SEQUENCE_DEFAULT_DRAW:
				m_nSequence = RandomInt(SEQUENCE_BUTTERFLY_DRAW, SEQUENCE_BUTTERFLY_DRAW2);
				break;
			case SEQUENCE_DEFAULT_LOOKAT01:
				m_nSequence = RandomInt(SEQUENCE_BUTTERFLY_LOOKAT01, SEQUENCE_BUTTERFLY_LOOKAT03);
				break;
			default:
				m_nSequence++;
			}
		}
		else if (modelHash == HASH("models/weapons/v_knife_falchion_advanced.mdl")) {
			switch (m_nSequence) {
			case SEQUENCE_DEFAULT_IDLE2:
				m_nSequence = SEQUENCE_FALCHION_IDLE1; break;
			case SEQUENCE_DEFAULT_HEAVY_MISS1:
				m_nSequence = RandomInt(SEQUENCE_FALCHION_HEAVY_MISS1, SEQUENCE_FALCHION_HEAVY_MISS1_NOFLIP);
				break;
			case SEQUENCE_DEFAULT_LOOKAT01:
				m_nSequence = RandomInt(SEQUENCE_FALCHION_LOOKAT01, SEQUENCE_FALCHION_LOOKAT02);
				break;
			case SEQUENCE_DEFAULT_DRAW:
			case SEQUENCE_DEFAULT_IDLE1:
				break;
			default:
				m_nSequence--;
			}
		}
		else if (modelHash == HASH("models/weapons/v_knife_push.mdl")) {
			switch (m_nSequence) {
			case SEQUENCE_DEFAULT_IDLE2:
				m_nSequence = SEQUENCE_DAGGERS_IDLE1; break;
			case SEQUENCE_DEFAULT_LIGHT_MISS1:
			case SEQUENCE_DEFAULT_LIGHT_MISS2:
				m_nSequence = RandomInt(SEQUENCE_DAGGERS_LIGHT_MISS1, SEQUENCE_DAGGERS_LIGHT_MISS5);
				break;
			case SEQUENCE_DEFAULT_HEAVY_MISS1:
				m_nSequence = RandomInt(SEQUENCE_DAGGERS_HEAVY_MISS2, SEQUENCE_DAGGERS_HEAVY_MISS1);
				break;
			case SEQUENCE_DEFAULT_HEAVY_HIT1:
			case SEQUENCE_DEFAULT_HEAVY_BACKSTAB:
			case SEQUENCE_DEFAULT_LOOKAT01:
				m_nSequence += 3; break;
			case SEQUENCE_DEFAULT_DRAW:
			case SEQUENCE_DEFAULT_IDLE1:
				break;
			default:
				m_nSequence += 2;
			}
		}
		else if (modelHash == HASH("models/weapons/v_knife_survival_bowie.mdl")) {
			switch (m_nSequence)
			{
			case SEQUENCE_DEFAULT_DRAW:
			case SEQUENCE_DEFAULT_IDLE1:
				break;
			case SEQUENCE_DEFAULT_IDLE2:
				m_nSequence = SEQUENCE_BOWIE_IDLE1;
				break;
			default:
				m_nSequence--;
			}
		}
		else if (modelHash == HASH("models/weapons/v_knife_ursus.mdl")) {
			switch (m_nSequence) {
			case SEQUENCE_DEFAULT_DRAW:
				m_nSequence = RandomInt(SEQUENCE_BUTTERFLY_DRAW, SEQUENCE_BUTTERFLY_DRAW2);
				break;
			case SEQUENCE_DEFAULT_LOOKAT01:
				m_nSequence = RandomInt(SEQUENCE_BUTTERFLY_LOOKAT01, SEQUENCE_BUTTERFLY_LOOKAT03);
				break;
			default:
				m_nSequence++;
				break;
			}
		}
		else if (modelHash == HASH("models/weapons/v_knife_stiletto.mdl")) {
			switch (m_nSequence) {
			case SEQUENCE_DEFAULT_LOOKAT01:
				m_nSequence = RandomInt(12, 13);
				break;
			}
		}
		else if (modelHash == HASH("models/weapons/v_knife_widowmaker.mdl")) {
			switch (m_nSequence) {
			case SEQUENCE_DEFAULT_LOOKAT01:
				m_nSequence = RandomInt(14, 15);
				break;
			}
		}
		else if (modelHash == HASH("models/weapons/v_knife_cord.mdl")
			|| modelHash == HASH("models/weapons/v_knife_canis.mdl")
			|| modelHash == HASH("models/weapons/v_knife_outdoor.mdl")
			|| modelHash == HASH("models/weapons/v_knife_skeleton.mdl"))
		{
			switch (m_nSequence)
			{
			case SEQUENCE_DEFAULT_DRAW:
				m_nSequence = RandomInt(SEQUENCE_BUTTERFLY_DRAW, SEQUENCE_BUTTERFLY_DRAW2);
			case SEQUENCE_DEFAULT_LOOKAT01:
				m_nSequence = RandomInt(SEQUENCE_BUTTERFLY_LOOKAT01, 14);
			default:
				m_nSequence = m_nSequence + 1;
			}
		}

		p_data->value.m_int = m_nSequence;

		sequence_proxy_fn(p_data, p_struct, p_out);

		VMProtectEnd();
	}

	void knifeAnimationHook() {

		VMProtectBeginMutation("aniamtionfix::knifeAnimationHook");

		for (auto client_class = interfaces::baseClientDll->GetAllClasses(); client_class; client_class = client_class->m_pNext) {

			if (FNV1a::get(client_class->m_pNetworkName) == HASH("CBaseViewModel")) {
				const auto table = reinterpret_cast<recv_table_*>(client_class->m_pRecvTable);
				for (int nIndex = 0; nIndex < table->props_count; nIndex++) {
					recv_prop_* pProp = &table->props[nIndex];
					if (!pProp || FNV1a::get(pProp->prop_name) != HASH("m_nSequence"))
						continue;
					sequence_proxy_fn = static_cast<recv_var_proxy_fn_>(pProp->proxy_fn);
					pProp->proxy_fn = static_cast<recv_var_proxy_fn_>(set_view_model_sequence);
					break;
				}
				break;
			}
		}

		VMProtectEnd();
	}

	void init() {

		VMProtectBeginMutation("aniamtionfix::knifeAnimation");

		knifeAnimationHook();

		auto client_class = interfaces::baseClientDll->GetAllClasses();

		while (client_class) {

			const char* pszName = client_class->m_pRecvTable->table_name;

			if (FNV1a::get(pszName) == HASH("DT_BaseViewModel")) {
				for (int i = 0; i < client_class->m_pRecvTable->props_count; i++) {
					recv_prop_* pProp = &(client_class->m_pRecvTable->props[i]);
					const char* name = pProp->prop_name;
					if (FNV1a::get(name) == HASH("m_nModelIndex")) {
						recv_model_index = (recv_var_proxy_fn_)pProp->proxy_fn;
						pProp->proxy_fn = (recv_var_proxy_fn_)hooked_recvproxy_viewmodel;
					}
				}
			}

			client_class = client_class->m_pNext;
		}

		VMProtectEnd();
	}

}
```

`Lumina/Lumina/features/visuals/animationfix.h`:

```h
#ifndef animationfix_h

#define animationfix_h

#define SEQUENCE_DEFAULT_DRAW 0
#define SEQUENCE_DEFAULT_IDLE1 1
#define SEQUENCE_DEFAULT_IDLE2 2
#define SEQUENCE_DEFAULT_LIGHT_MISS1 3
#define SEQUENCE_DEFAULT_LIGHT_MISS2 4
#define SEQUENCE_DEFAULT_HEAVY_MISS1 9
#define SEQUENCE_DEFAULT_HEAVY_HIT1 10
#define SEQUENCE_DEFAULT_HEAVY_BACKSTAB 11
#define SEQUENCE_DEFAULT_LOOKAT01 12

#define SEQUENCE_BUTTERFLY_DRAW 0
#define SEQUENCE_BUTTERFLY_DRAW2 1
#define SEQUENCE_BUTTERFLY_LOOKAT01 13
#define SEQUENCE_BUTTERFLY_LOOKAT03 15

#define SEQUENCE_FALCHION_IDLE1 1
#define SEQUENCE_FALCHION_HEAVY_MISS1 8
#define SEQUENCE_FALCHION_HEAVY_MISS1_NOFLIP 9
#define SEQUENCE_FALCHION_LOOKAT01 12
#define SEQUENCE_FALCHION_LOOKAT02 13

#define SEQUENCE_DAGGERS_IDLE1 1
#define SEQUENCE_DAGGERS_LIGHT_MISS1 2
#define SEQUENCE_DAGGERS_LIGHT_MISS5 6
#define SEQUENCE_DAGGERS_HEAVY_MISS2 11
#define SEQUENCE_DAGGERS_HEAVY_MISS1 12

#define SEQUENCE_BOWIE_IDLE1 1

namespace animationfix {
	void init();
}

#endif // !animationfix_h
```

`Lumina/Lumina/features/visuals/chams.cpp`:

```cpp
#include "chams.h"

#include "../../hook/functions/drawModelExecute.h"
#include "../../sdk/interfaces.h"
#include "../../common/config.h"
#include "../../common/common.h"
#include "../../features/backtrack/backtrack.h"

#include <fstream>

namespace chams {

	const char* materialsNames[6];

	int materialSize = 6;
	IMaterial* materialPointers[6];

	std::vector<std::string> materialsInternals = {};

	void* ecx;
	void* currentState;
	const ModelRenderInfo_t* mrenderInfo;
	void* currentMatrix;

	void init() {

		VMProtectBeginMutation("chams::init");

		VECTOR_PUSH(materialsInternals, "textured", tmp0)
		VECTOR_PUSH(materialsInternals, "debug/debugdrawflat", tmp1)
		VECTOR_PUSH(materialsInternals, "tools/toolsskyfog.vmt", tmp2)
		VECTOR_PUSH(materialsInternals, "models/weapons/v_models/eq_healthshot/health_shot_clear.vmt", tmp3)
		VECTOR_PUSH(materialsInternals, "glowOverlay", tmp4)
		VECTOR_PUSH(materialsInternals, "models/inventory_items/trophy_majors/silver_plain.vmt", tmp5)

		// obligated to do it like this because of xor
		materialsNames[0] = StringHeavy("TEXTURED");
		materialsNames[1] = StringHeavy("FLAT");
		materialsNames[2] = StringHeavy("MESHES");
		materialsNames[3] = StringHeavy("METALIC");
		materialsNames[4] = StringHeavy("GLOW OVERLAY");
		materialsNames[5] = StringHeavy("CHROME");

		std::string materialPath = StringHeavy("csgo\\materials\\");

		std::string texturedMaterial = StringHeavy("\"VertexLitGeneric\" {\n");
		texturedMaterial.append(StringHeavy("	\"$basetexture\" \"vgui/white_additive\"\n"));
		texturedMaterial.append(StringHeavy("	\"$ignorez\"     \"0\"\n"));
		texturedMaterial.append(StringHeavy("	\"$envmap\"       \"\"\n"));
		texturedMaterial.append(StringHeavy("	\"$nofog\"        \"1\"\n"));
		texturedMaterial.append(StringHeavy("	\"$model\"        \"1\"\n"));
		texturedMaterial.append(StringHeavy("	\"$nocull\"       \"0\"\n"));
		texturedMaterial.append(StringHeavy("	\"$selfillum\"    \"1\"\n"));
		texturedMaterial.append(StringHeavy("	\"$halflambert\"  \"1\"\n"));
		texturedMaterial.append(StringHeavy("	\"$znearer\"      \"0\"\n"));
		texturedMaterial.append(StringHeavy("	\"$flat\"         \"1\"\n"));
		texturedMaterial.append(StringHeavy("}"));

		std::ofstream(materialPath + StringHeavy("textured.vmt")) << texturedMaterial;

		texturedMaterial.erase(texturedMaterial.length());

		std::string flatMaterial = StringHeavy("\"UnlitGeneric\" {\n");
		flatMaterial.append(StringHeavy("	\"$flat\" \"1\"\n"));
		flatMaterial.append(StringHeavy("	\"%noToolTexture\"     \"1\"\n"));
		flatMaterial.append(StringHeavy("}"));

		std::ofstream(materialPath + StringHeavy("flat.vmt")) << flatMaterial;

		flatMaterial.erase(flatMaterial.length());

		std::string lsdMaterial = StringHeavy("\"VertexLitGeneric\" {\n");
		lsdMaterial.append(StringHeavy("	\"$pearlescent\" \"1\"\n"));
		lsdMaterial.append(StringHeavy("	\"$color[0]\" \"1\"\n"));
		lsdMaterial.append(StringHeavy("	\"$envmaptint\" \"[1 0 0]\"\n"));
		lsdMaterial.append(StringHeavy("	\"proxies\"\n"));
		lsdMaterial.append(StringHeavy("		\"Sine\"\n"));
		lsdMaterial.append(StringHeavy("		{\n"));
		lsdMaterial.append(StringHeavy("			\"sineperiod\" \"1\"\n"));
		lsdMaterial.append(StringHeavy("			\"sinemin\" \"0\"\n"));
		lsdMaterial.append(StringHeavy("			\"sinemax\" \"1\"\n"));
		lsdMaterial.append(StringHeavy("			\"timeoffset\" \"0\"\n"));
		lsdMaterial.append(StringHeavy("			\"resultvar\" \"$color[0]\"\n"));
		lsdMaterial.append(StringHeavy("		}\n"));
		lsdMaterial.append(StringHeavy("		\"Sine\"\n"));
		lsdMaterial.append(StringHeavy("		{\n"));
		lsdMaterial.append(StringHeavy("			\"sineperiod\" \"1\"\n"));
		lsdMaterial.append(StringHeavy("			\"sinemin\" \"0\"\n"));
		lsdMaterial.append(StringHeavy("			\"sinemax\" \"1\"\n"));
		lsdMaterial.append(StringHeavy("			\"timeoffset\" \"0\"\n"));
		lsdMaterial.append(StringHeavy("			\"resultvar\" \"$pearlescent\"\n"));
		lsdMaterial.append(StringHeavy("		}\n"));
		lsdMaterial.append(StringHeavy("}"));

		std::ofstream(materialPath + StringHeavy("lsd.vmt")) << lsdMaterial;

		lsdMaterial.erase(lsdMaterial.length());


		std::string glowOverlayMaterial = StringHeavy("\"VertexLitGeneric\" {\n");
		glowOverlayMaterial.append(StringHeavy("	\"$additive\" \"1\"\n"));
		glowOverlayMaterial.append(StringHeavy("	\"$envmap\" \"models/effects/cube_white\"\n"));
		glowOverlayMaterial.append(StringHeavy("	\"$envmaptint\" \"[0 0 0]\"\n"));
		glowOverlayMaterial.append(StringHeavy("	\"$envmapfresnel\" \"1\"\n"));
		glowOverlayMaterial.append(StringHeavy("	\"$envmapfresnelminmaxexp\" \"[0 1 2]\"\n"));
		glowOverlayMaterial.append(StringHeavy("	\"$alpha\" \"0.8\"\n"));
		glowOverlayMaterial.append(StringHeavy("}"));

		std::ofstream(materialPath + StringHeavy("glowOverlay.vmt")) << glowOverlayMaterial;

		glowOverlayMaterial.erase(glowOverlayMaterial.length());

		VMProtectEnd();

#ifdef _DEBUG
		common::ps(XorStr("chams::init : done"));
#endif
	}

	bool drawModelExecute(void* context, void* state, const ModelRenderInfo_t& renderInfo, void* matrix, const char* modelName, bool arms, bool sleeve) {

		VMProtectBeginMutation("chams::drawModelExecute");

		bool drawOriginal = true;

		// means !renderInfo.pModel
		if (!modelName)
			return drawOriginal;

		ecx = context;
		currentState = state;
		currentMatrix = matrix;

		bool isHands = arms && !sleeve;
		bool isSleeves = arms && sleeve;

		// hands and sleeves doesn't have an entity
		if ((isHands || isSleeves) && (game::getLocalPlayer() && game::getLocalPlayer()->isAlive())) {

			// draw hands
			CHAMS(config::visual.handChams, isHands, renderInfo, currentMatrix, false)
			// draw sleeves
			CHAMS_ELSE(config::visual.sleeveChams, isSleeves, renderInfo, currentMatrix, false)
		}
		else {

			if (renderInfo.entity_index == INVALID_EHANDLE_INDEX)
				return drawOriginal;

			Entity* entity = reinterpret_cast<Entity*>(interfaces::clientEntityList->GetClientEntity(renderInfo.entity_index));

			if (!entity)
				return drawOriginal;

			bool isPlayerEnemy = (entity->isPlayer() && entity->isAlive()) && game::getLocalPlayer()->m_iTeamNum() != entity->m_iTeamNum();

			if (isPlayerEnemy && config::cheats.backtrack && config::visual.enemyChamsBacktrack.enable) {

				auto record = &backtrack::records[entity->index()];

				// checks that record exists for the enemy
				if (record && record->size() > 1 && backtrack::valid_tick(record->front().simulation_time)) {

					int factor = (config::cheats.backtrackVisibility / 100) * record->size();

					for (size_t i = 1; i < factor; i++){

						// draw backtrack
						CHAMS(config::visual.enemyChamsBacktrack, isPlayerEnemy, renderInfo, record->at(i).matrix, false)
					}
				}
			}

			// premium far chams by : https://www.unknowncheats.me/forum/counterstrike-global-offensive/449124-epic-cheap-dme-fix.html
			// NOTE : still don't want to create a class for convars

			static ConVar* r_PortalTestEnts = game::getConvarNullCallback(XorStr("r_PortalTestEnts"));
			static ConVar* r_Portalsopenall = game::getConvarNullCallback(XorStr("r_Portalsopenall"));

			r_PortalTestEnts->nFlags &= (1 << 14);
			r_Portalsopenall->nFlags &= (1 << 14);

			r_PortalTestEnts->set_value(config::visual.enemyChamsVisible.enable ? 0 : 1);
			r_Portalsopenall->set_value(config::visual.enemyChamsVisible.enable ? 0 : 1);

			bool shouldDrawThroughWall = config::visual.enemyChamsVisible.throughWall &&
				(!config::visual.enemyChamsVisible.throughWallOnlyIfDead || (config::visual.enemyChamsVisible.throughWallOnlyIfDead && !game::getLocalPlayer()->isAlive()));

			// draw player
			CHAMS(config::visual.enemyChamsVisible, isPlayerEnemy, renderInfo, currentMatrix, shouldDrawThroughWall)
		}

		VMProtectEnd();

		return drawOriginal;
	}

	void drawMaterial(chams_t* chams, const ModelRenderInfo_t& renderInfo, void* matrix, bool throughZ, bool delayOverlay) {

		VMProtectBeginMutation("chams::drawMaterial");

		float defaultColor[3] = { 1.0f, 1.0f, 1.0f };

		IMaterial* mat = interfaces::materialSystem->FindMaterial(materialsInternals.at(chams->material).c_str(), XorStr("Model textures"), true, nullptr);
		
		mat->IncrementReferenceCount();

		interfaces::modelRender->ForcedMaterialOverride(mat);

		// set through wall mat attribut
		mat->SetMaterialVarFlag(MATERIAL_VAR_IGNOREZ, throughZ);

		interfaces::renderView->SetColorModulation(chams->color.Base());

		interfaces::renderView->SetBlend(chams->color.aBase());

		auto returnCall = reinterpret_cast<drawModelExecuteFn>(hook::modelRenderHook.get_original(21));
		
		// draw
		returnCall(interfaces::modelRender, ecx, currentState, renderInfo, matrix);

		// overlay part
		if (chams->enableOverlay /*&& !delayOverlay*/)
		{
			drawOverlay(chams, renderInfo, matrix, throughZ);
		}

		// reset
		interfaces::modelRender->ForcedMaterialOverride(nullptr);
		interfaces::renderView->SetColorModulation(defaultColor);

		VMProtectEnd();
	}

	void drawOverlay(chams_t* chams, const ModelRenderInfo_t& renderInfo, void* matrix, bool throughZ) {

		auto returnCall = reinterpret_cast<drawModelExecuteFn>(hook::modelRenderHook.get_original(21));

		float defaultColor[3] = { 1.0f, 1.0f, 1.0f };

		// glow overlay
		auto glowOverlay = interfaces::materialSystem->FindMaterial(materialsInternals.at(chams->overlayMaterial).c_str(), XorStr("Other textures"), true, nullptr);

		glowOverlay->IncrementReferenceCount();

		bool materialVariableFound = false;

		auto tint = glowOverlay->FindVar(XorStr("$envmaptint"), &materialVariableFound);

		if (materialVariableFound)
		{
			interfaces::modelRender->ForcedMaterialOverride(glowOverlay);

			// set through wall mat attribut to overlay
			//glowOverlay->SetMaterialVarFlag(MATERIAL_VAR_IGNOREZ, throughZ);

			interfaces::renderView->SetColorModulation(chams->overlayColor.Base());

			tint->setColor(chams->overlayColor.rBase(), chams->overlayColor.gBase(), chams->overlayColor.bBase());

			interfaces::renderView->SetBlend(chams->overlayColor.aBase());

			// draw overlay
			returnCall(interfaces::modelRender, ecx, currentState, renderInfo, matrix);

			// reset
			interfaces::modelRender->ForcedMaterialOverride(nullptr);
			interfaces::renderView->SetColorModulation(defaultColor);
		}
	}
}
```

`Lumina/Lumina/features/visuals/chams.h`:

```h
#ifndef chams_h

#define chams_h

#include "../../common/includes.h"
#include "../../sdk/math/Color.h"
#include "../../sdk/structs/IMaterial.h"

struct materialInfo {
	void* ecx;
	void* currentState;
	const ModelRenderInfo_t& mrenderInfo;
	void* currentMatrix;
};

#define CHAMS(config, vector, info, matrix, throughZ) if (config.enable && vector) { \
		drawMaterial(&(config), info, matrix, throughZ, throughZ); \
		if(throughZ) { \
			drawMaterial(&(config), info, matrix, false, throughZ); \
			/*drawOverlay(&(config), info, matrix, throughZ);*/ \
		} \
		drawOriginal = false; \
	} \

#define CHAMS_ELSE(config, vector, info, matrix, throughZ) else if (config.enable && vector) { \
		drawMaterial(&(config), info, matrix, throughZ, throughZ); \
		if(throughZ) { \
			drawMaterial(&(config), info, matrix, false, throughZ); \
			/*drawOverlay(&(config), info, matrix, throughZ);*/  \
		} \
		drawOriginal = false; \
	} \

namespace chams {

	void init();

	bool drawModelExecute(void* context, void* state, const ModelRenderInfo_t& renderInfo, void* matrix, const char* modelName, bool arms, bool sleeve);

	void drawMaterial(chams_t* chams, const ModelRenderInfo_t& renderInfo, void* matrix, bool throughZ, bool delayOverlay);
	void drawOverlay(chams_t* chams, const ModelRenderInfo_t& renderInfo, void* matrix, bool throughZ);

	extern const char* materialsNames[];
	extern int materialSize;
}

#endif // !chams_h
```

`Lumina/Lumina/features/visuals/esp.cpp`:

```cpp
#include "esp.h"
#include "../../sdk/interfaces.h"
#include "../../common/common.h"
#include "../../ui/render.h"
#include "../../ui/texture.h"

#include "../../ui/image.h"

namespace esp {

	float dormantHistory[1024];

	texture* flashedLogo = nullptr;
	texture* reloadLogo = nullptr;
	texture* scopingLogo = nullptr;

	void init() {

	}

	void paintTraverse() {

		playerEsp();
	}

	void playerEsp() {

		VMProtectBeginMutation("esp::playerEsp");

		Entity* localPlayer = game::getLocalPlayer();
		
		for (auto i = 0; i < interfaces::globals->maxClients; i++)
		{
			Entity* entity = (Entity*)interfaces::clientEntityList->GetClientEntity(i);

			// keep the order
			if (!entity)
				continue;
			// escape localplayer and non player
			if(!entity->isPlayer() || entity == localPlayer)
				continue;
			// esp only on enemies
			if(!entity->isAlive() || entity->m_iTeamNum() == localPlayer->m_iTeamNum())
				continue;
			// increase the opacity because it's dormant
			if (entity->m_bDormant() && dormantHistory[entity->index()] > 0.0f)
				dormantHistory[entity->index()] -= 4.0f;
			// reset the opacity because not dormant
			else if (!entity->m_bDormant())
				dormantHistory[entity->index()] = 255.0f;
			// don't draw the esp if opacity is null
			if (dormantHistory[entity->index()] <= 0.0f)
				continue;

			if (config::visual.enemyEsp.showOnlyIsDead && localPlayer->isAlive())
				continue;

			if (config::visual.enemyEsp.showBox)
				render::drawEntityBox(entity, config::visual.enemyEsp.espColor);

			renderEsp(entity);
		}
	
		VMProtectEnd();
	}

	void renderEsp(Entity* player) {

		VMProtectBeginMutation("esp::renderEsp");

		box playerBox;

		// get the screen box around the player
		if (!utils::getEntityBox(player, playerBox))
			return;

		int space = 5;
		int hearthBarSize = 3;
		int indicatorPadding = 14;

		std::vector<std::string> indicators = std::vector<std::string>();
		std::vector<texture*> indicatorsLogo = std::vector<texture*>();

		// setup icon textures
		if (!flashedLogo)
			flashedLogo = new texture(images::flashingData, 14, 14);
		if (!reloadLogo)
			reloadLogo = new texture(images::reloadData, 14, 14);
		if (!scopingLogo)
			scopingLogo = new texture(images::scopingData, 14, 14);

		// set esp color in function of dormant history
		config::visual.enemyEsp.espColor.SetAlpha((int)dormantHistory[player->index()]);

		if (config::visual.enemyEsp.showBox) {
			render::drawOutlinedBox(playerBox.x, playerBox.y, playerBox.w, playerBox.h, config::visual.enemyEsp.espColor);
		}

		if (config::visual.enemyEsp.showName) {

			// allocate the struct
			player_info_t* playerInfo = new player_info_t();

			if (!interfaces::engineClient->GetPlayerInfo(player->index(), playerInfo))
				goto ret;

			std::string playerName = playerInfo->name;

			if (playerName.size() > 12)
			{
				playerName.resize(12);
				playerName.append(XorStr("..."));
			}

			// detect UTF 16
			//wchar_t buffer[128];
			//wsprintfW(buffer, L"%S", playerInfo.name);
			//if (MultiByteToWideChar(CP_UTF8, 0, playerInfo.name, -1, buffer, 128) > 0)

			int nameBoxSize = 20;

			//render::drawRectangle(playerBox.x, playerBox.y - (nameBoxSize - space), playerBox.w, nameBoxSize - (space * 2), config::visual.enemyEsp.espColor);

			render::drawText(playerBox.x, playerBox.y - nameBoxSize + space, render::font, playerName, false, config::visual.enemyEsp.espColor);

			delete playerInfo;
		}

		ret:

		if (config::visual.enemyEsp.showLife) {

			if (player->m_iMaxHealth() > 0 && player->m_iHealth() > 0) {

				int factor = player->m_iHealth() / player->m_iMaxHealth();

				int maxI = 256;

				Color green = Color(0, 255, 0);

				/*

				Color red = Color(255, 0, 0);
				
				Color currentColor = Color(0, 0, 0);
				
				int r = (green.r() + ((factor / 255.0) * (red.r() - green.r())));
				int g = (green.g() + ((factor / 255.0) * (red.g() - green.g())));
				int b = (green.b() + ((factor / 255.0) * (red.b() - green.b())));

				
				currentColor.SetColor(r, g, b);*/

				render::drawRectangle(playerBox.x - space - hearthBarSize, playerBox.y, hearthBarSize, playerBox.h * factor, green);

				render::drawOutlinedBox(playerBox.x - space - hearthBarSize, playerBox.y, hearthBarSize, playerBox.h, Color(config::visual.enemyEsp.espColor, 50));
			}
		}

		if (config::visual.enemyEsp.showWeaponIcon) {

			auto weapon = (C_BaseAttributableItem*)player->getWeapon();

			if (weapon) {

				if (*weapon->m_iItemDefinitionIndex() > 0 && *weapon->m_iItemDefinitionIndex() < 50) {

					//char indexChar[1] = { (char)(weapon->itemDefinitionIndex() & 0xFF) };

					std::string icon = "";
					icon.push_back(0x7);
					icon.push_back(0x0);

					render::drawText(playerBox.x, playerBox.y + playerBox.h + space, render::icons, icon, false, config::visual.enemyEsp.espColor);
				}
			}
		}

		if (config::visual.enemyEsp.showFlashed)
		{
			if (player->m_flFlashDuration() > 0.0f)
			{
				if (config::visual.enemyEsp.showIcons)
				{
					indicatorsLogo.push_back(flashedLogo);
				}

				indicators.push_back(XorStr("FLASHED"));
			}
		}
	
		if (config::visual.enemyEsp.showScopping)
		{
			if (player->m_bIsScoped())
			{
				if (config::visual.enemyEsp.showIcons)
				{
					indicatorsLogo.push_back(scopingLogo);
				}

				indicators.push_back(XorStr("SCOPING"));
			}
		}

		if (config::visual.enemyEsp.showReload)
		{
			/*
			if (entity->getWeapon())
			{
				if (!entity->getWeapon()->m_bReloadVisuallyComplete())
				{
					if (config::visual.enemyEsp.showIcons)
					{
						drawIcons = true;
						indicatorsLogo.push_back(reloadLogo);
					}

					indicators.push_back(XorStr("RELOADING"));
				}
			}*/
		}

		if (config::visual.enemyEsp.showHasDefuser)
		{
			if (player->m_bHasDefuser())
			{
				if (config::visual.enemyEsp.showIcons)
				{

				}

				indicators.push_back(XorStr("HAS DEFUSER"));
			}
		}

		if (config::visual.enemyEsp.showPlanting)
		{
			auto weapon = (C_BaseAttributableItem*)player->getWeapon();

			if (weapon)
			{
				if (*weapon->m_iItemDefinitionIndex() == WEAPON_C4) {

					auto c4 = (DT_WeaponC4*)weapon;

					if (c4->m_bStartedArming()) {

						if (config::visual.enemyEsp.showIcons)
						{

						}

						indicators.push_back(XorStr("PLANTING"));
					}
				}
			}
		}

		if (config::visual.enemyEsp.showDefusing)
		{
			if (player->m_bIsDefusing())
			{
				if (config::visual.enemyEsp.showIcons)
				{

				}

				indicators.push_back(XorStr("DEFUSING"));
			}
		}

		if (config::visual.enemyEsp.showBomb)
		{
			if (player->hasC4())
			{
				if (config::visual.enemyEsp.showIcons)
				{

				}

				indicators.push_back(XorStr("HAS BOMB"));
			}
		}

		if (config::visual.enemyEsp.showSkeleton) {

			// source : weave.su

			/*studiohdr_t* pStudioHdr = interfaces::modelInfo->GetStudioModel(player->model());

			if (pStudioHdr) {

				Vector vParent, vChild;
				Vector2D sParent, sChild;

				for (int j = 0; j < pStudioHdr->numbones; j++)
				{
					mstudiobone_t* pBone = pStudioHdr->pBone(j);

					if (pBone && (pBone->flags & 0x100) && (pBone->parent != -1))
					{
						vChild = player->get_bone_position(record.value()->bones, j);
						vParent = player->get_bone_position(record.value()->bones, pBone->parent);

						if (c_renderer::screen_transform(vParent, sParent, features->Visuals->world_to_screen_matrix) && c_renderer::screen_transform(vChild, sChild, features->Visuals->world_to_screen_matrix))
							c_renderer::line(Vector2D(sParent.x, sParent.y), Vector2D(sChild.x, sChild.y), clr);

					}
				}
			}*/
		}

		
		if (config::visual.enemyEsp.showWeaponName)
		{
			if (player->getWeapon() && player->getWeapon()->getWeaponData())
			{
				std::wstring weaponName = interfaces::localize->Find(player->getWeapon()->getWeaponData()->szHudName);

				render::drawText(playerBox.x, playerBox.y + playerBox.h + space, render::font, weaponName, false, config::visual.enemyEsp.espColor);
			}
		}

		int startXTextIndicators = playerBox.x + playerBox.w + space;

		// if there are icons
		if (indicatorsLogo.size() > 0)
			startXTextIndicators += space + indicatorPadding;

		// draw indicator icons
		for (size_t i = 0; i < indicatorsLogo.size(); i++)
		{
			indicatorsLogo[i]->m_bgColor.SetAlpha((int)dormantHistory[player->index()]);
			indicatorsLogo[i]->Draw(playerBox.x + playerBox.w + space, playerBox.y + ((space + indicatorPadding) * i));
		}

		if (config::visual.enemyEsp.showIconsOnly)
			return;

		// draw indicator text
		for (size_t i = 0; i < indicators.size(); i++)
			render::drawText(startXTextIndicators, playerBox.y + ((indicatorPadding + space) * i), render::font, indicators[i], false, config::visual.enemyEsp.espColor);
	
		VMProtectEnd();
	}
}
```

`Lumina/Lumina/features/visuals/esp.h`:

```h
#ifndef esp_h

#define esp_h

#include "../../common/includes.h"

namespace esp {

	void init();

	void paintTraverse();

	void playerEsp();

	void renderEsp(Entity* player);
}

#endif // !esp_h
```

`Lumina/Lumina/features/visuals/glow.cpp`:

```cpp
#include "glow.h"

#include "../../common/includes.h"
#include "../../sdk/interfaces.h"
#include "../../common/config.h"
#include "../../common/common.h"

namespace glow {

	void execute() 
	{
		VMProtectBeginMutation("glow::execute");

		if (!config::visual.glow.enable)
			return;

		Entity* localPlayer = game::getLocalPlayer();

		if (!localPlayer || !game::isEnvironmentValid())
			return;

		if (localPlayer->isAlive() && config::visual.glow.onlyIfDead)
			return;

		for (auto i = 0; i < interfaces::glowManager->size; i++)
		{
			auto glow_object = &interfaces::glowManager->m_glObjectDefinitions[i];

			Entity* entity = (Entity*)glow_object->m_pEntity;

			if (!entity || glow_object->IsUnused())
				continue;

			if (!entity->isAlive() || entity->m_bDormant())
				continue;

			if (entity->Class()->m_ClassID == ClassId::ClassId_CCSPlayer && entity->m_iTeamNum() != localPlayer->m_iTeamNum())
			{
				Vector colorVector = Vector(config::visual.glow.glowColor.rBase(), config::visual.glow.glowColor.gBase(), config::visual.glow.glowColor.bBase());

				glow_object->m_vGlowColor = colorVector;
				glow_object->m_flGlowAlpha = config::visual.glow.glowColor.aBase();
				glow_object->m_flBloomAmount = config::visual.glow.bloom;
				glow_object->m_bRenderWhenOccluded = true;
				glow_object->m_bRenderWhenUnoccluded = false;
				//glow_object->m_bFullBloomRender = false;

				continue;
			}
		}

		VMProtectEnd();
	}
}
```

`Lumina/Lumina/features/visuals/glow.h`:

```h
#ifndef glow_h

#define glow_h

namespace glow {

	void execute();
}

#endif // !glow_h
```

`Lumina/Lumina/features/visuals/skinchanger.cpp`:

```cpp
#include "skinchanger.h"

#include "../../sdk/interfaces.h"
#include "../../common/includes.h"
#include "../../common/config.h"
#include "../../common/common.h"

namespace skinchanger {

	std::vector<std::string> knifeModelNames = {};
	std::vector<std::string> playerModels = {};
	std::vector<std::string> armsModels = {};

	// init to the highest item index possible
	static int itemIDHighOriginals[GLOVE_HYDRA];

	static uint16_t s_iwoff = 0;

	static void* o_uint_fn;

	bool updateSkin = true;

	int getKnifeDefinitionIndex(int si)
	{
		switch (si)
		{
		case 0:
			return WEAPON_KNIFE;
		case 1:
			return WEAPON_KNIFE_T;
		case 2:
			return WEAPON_BAYONET;
		case 3:
			return WEAPON_KNIFE_M9_BAYONET;
		case 4:
			return WEAPON_KNIFE_KARAMBIT;
		case 5:
			return WEAPON_KNIFE_SURVIVAL_BOWIE;
		case 6:
			return WEAPON_KNIFE_BUTTERFLY;
		case 7:
			return WEAPON_KNIFE_FALCHION;
		case 8:
			return WEAPON_KNIFE_FLIP;
		case 9:
			return WEAPON_KNIFE_GUT;
		case 10:
			return WEAPON_KNIFE_TACTICAL;
		case 11:
			return WEAPON_KNIFE_PUSH;
		case 12:
			return WEAPON_KNIFE_GYPSY_JACKKNIFE;
		case 13:
			return WEAPON_KNIFE_STILETTO;
		case 14:
			return WEAPON_KNIFE_WIDOWMAKER;
		case 15:
			return WEAPON_KNIFE_URSUS;
		case 16:
			return 525;
		case 17:
			return 521;
		case 18:
			return 518;
		case 19:
			return 517;
		case 20:
			return 503;
		default:
			return -1;
		}
	}

	void init() {

		VMProtectBeginMutation("skinchanger::init");

		ZeroMemory(itemIDHighOriginals, GLOVE_HYDRA);

		VECTOR_PUSH(knifeModelNames, "models/weapons/v_knife_default_t.mdl", tmp0)
			VECTOR_PUSH(knifeModelNames, "models/weapons/v_knife_default_ct.mdl", tmp1)
			VECTOR_PUSH(knifeModelNames, "models/weapons/v_knife_bayonet.mdl", tmp2)
			VECTOR_PUSH(knifeModelNames, "models/weapons/v_knife_m9_bay.mdl", tmp3)
			VECTOR_PUSH(knifeModelNames, "models/weapons/v_knife_karam.mdl", tmp4)
			VECTOR_PUSH(knifeModelNames, "models/weapons/v_knife_survival_bowie.mdl", tmp4_)
			VECTOR_PUSH(knifeModelNames, "models/weapons/v_knife_butterfly.mdl", tmp5)
			VECTOR_PUSH(knifeModelNames, "models/weapons/v_knife_falchion_advanced.mdl", tmp6)
			VECTOR_PUSH(knifeModelNames, "models/weapons/v_knife_flip.mdl", tmp7)
			VECTOR_PUSH(knifeModelNames, "models/weapons/v_knife_gut.mdl", tmp8)
			VECTOR_PUSH(knifeModelNames, "models/weapons/v_knife_tactical.mdl", tmp9)
			VECTOR_PUSH(knifeModelNames, "models/weapons/v_knife_push.mdl", tmp10)
			VECTOR_PUSH(knifeModelNames, "models/weapons/v_knife_gypsy_jackknife.mdl", tmp11)
			VECTOR_PUSH(knifeModelNames, "models/weapons/v_knife_stiletto.mdl", tmp12)
			VECTOR_PUSH(knifeModelNames, "models/weapons/v_knife_widowmaker.mdl", tmp13)
			VECTOR_PUSH(knifeModelNames, "models/weapons/v_knife_ursus.mdl", tmp14)
			VECTOR_PUSH(knifeModelNames, "models/weapons/v_knife_skeleton.mdl", tmp15)
			VECTOR_PUSH(knifeModelNames, "models/weapons/v_knife_outdoor.mdl", tmp16)
			VECTOR_PUSH(knifeModelNames, "models/weapons/v_knife_canis.mdl", tmp17)
			VECTOR_PUSH(knifeModelNames, "models/weapons/v_knife_cord.mdl", tmp18)
			VECTOR_PUSH(knifeModelNames, "models/weapons/v_knife_css.mdl", tmp19)

			VECTOR_PUSH(playerModels, "models/player/custom_player/legacy/ctm_fbi_variantb.mdl", tmp20)
			VECTOR_PUSH(playerModels, "models/player/custom_player/nf/lara/lara.mdl", tmp20_)
			VECTOR_PUSH(playerModels, "models/player/custom_player/voikanaa/halo4/cortana.mdl", tmp21)
			VECTOR_PUSH(playerModels, "models/player/samus/samus.mdl", tmp22)
			VECTOR_PUSH(playerModels, "models/player/custom_player/kodua/goku/goku.mdl", tmp23)
			VECTOR_PUSH(playerModels, "models/player/custom_player/legacy/cuddleleader.mdl", tmp24)
			VECTOR_PUSH(playerModels, "models/player/custom_player/legacy/gxp/valorant_viper/viper_v1f.mdl", tmp25)
			VECTOR_PUSH(playerModels, "models/player/custom_player/kuristaja/cso2/sas/sas.mdl", tmp26)
			VECTOR_PUSH(playerModels, "models/player/custom_player/kuristaja/cso2/lincoln/lincoln.mdl", tmp27)
			VECTOR_PUSH(playerModels, "models/player/custom_player/kuristaja/cso2/karachenko/karachenko.mdl", tmp28)
			VECTOR_PUSH(playerModels, "models/player/custom_player/kuristaja/cso2/gign/gign.mdl", tmp29)
			VECTOR_PUSH(playerModels, "models/player/custom_player/kuristaja/cso2/carrie/carrie.mdl", tmp30)
			VECTOR_PUSH(playerModels, "models/player/custom_player/kuristaja/cso2/707/707.mdl", tmp31)
			VECTOR_PUSH(playerModels, "models/player/custom_player/legacy/tm_phoenix_variantf.mdl", tmp40)
			VECTOR_PUSH(playerModels, "models/player/custom_player/legacy/tm_phoenix_variantg.mdl", tmp41)
			VECTOR_PUSH(playerModels, "models/player/custom_player/legacy/tm_phoenix_varianth.mdl", tmp42)

			VECTOR_PUSH(armsModels, "models/player/custom_player/legacy/ctm_fbi_variantf.mdl", tmp21_)
			VECTOR_PUSH(armsModels, "models/player/custom_player/legacy/ctm_fbi_variantg.mdl", tmp22_)
			VECTOR_PUSH(armsModels, "models/player/custom_player/legacy/ctm_fbi_varianth.mdl", tmp23_)
			VECTOR_PUSH(armsModels, "models/player/custom_player/legacy/ctm_sas_variantf.mdl", tmp24_)
			VECTOR_PUSH(armsModels, "models/player/custom_player/legacy/ctm_st6_variante.mdl", tmp25_)
			VECTOR_PUSH(armsModels, "models/player/custom_player/legacy/ctm_st6_variantg.mdl", tmp26_)
			VECTOR_PUSH(armsModels, "models/player/custom_player/legacy/ctm_st6_varianti.mdl", tmp27_)
			VECTOR_PUSH(armsModels, "models/player/custom_player/legacy/ctm_st6_variantk.mdl", tmp28_)
			VECTOR_PUSH(armsModels, "models/player/custom_player/legacy/ctm_st6_variantm.mdl", tmp29_)
			VECTOR_PUSH(armsModels, "models/player/custom_player/legacy/tm_balkan_variantf.mdl", tmp31_)
			VECTOR_PUSH(armsModels, "models/player/custom_player/legacy/tm_balkan_variantg.mdl", tmp32_)
			VECTOR_PUSH(armsModels, "models/player/custom_player/legacy/tm_balkan_varianth.mdl", tmp33_)
			VECTOR_PUSH(armsModels, "models/player/custom_player/legacy/tm_balkan_varianti.mdl", tmp34_)
			VECTOR_PUSH(armsModels, "models/player/custom_player/legacy/tm_balkan_variantj.mdl", tmp35_)
			VECTOR_PUSH(armsModels, "models/player/custom_player/legacy/tm_leet_variantf.mdl", tmp36_)
			VECTOR_PUSH(armsModels, "models/player/custom_player/legacy/tm_leet_variantg.mdl", tmp37_)
			VECTOR_PUSH(armsModels, "models/player/custom_player/legacy/tm_leet_varianth.mdl", tmp38_)
			VECTOR_PUSH(armsModels, "models/player/custom_player/legacy/tm_leet_varianti.mdl", tmp39_)
			VECTOR_PUSH(armsModels, "models/player/custom_player/legacy/tm_phoenix_variantf.mdl", tmp40_)
			VECTOR_PUSH(armsModels, "models/player/custom_player/legacy/tm_phoenix_variantg.mdl", tmp41_)
			VECTOR_PUSH(armsModels, "models/player/custom_player/legacy/tm_phoenix_varianth.mdl", tmp42_)
			VECTOR_PUSH(armsModels, "models/player/custom_player/legacy/ctm_st6_variantj.mdl", tmp43_)
			VECTOR_PUSH(armsModels, "models/player/custom_player/legacy/ctm_st6_variantl.mdl", tmp44_)
			VECTOR_PUSH(armsModels, "models/player/custom_player/legacy/ctm_swat_variante.mdl", tmp45_)
			VECTOR_PUSH(armsModels, "models/player/custom_player/legacy/ctm_swat_variantf.mdl", tmp46_)
			VECTOR_PUSH(armsModels, "models/player/custom_player/legacy/ctm_swat_variantg.mdl", tmp47_)
			VECTOR_PUSH(armsModels, "models/player/custom_player/legacy/ctm_swat_varianth.mdl", tmp48_)
			VECTOR_PUSH(armsModels, "models/player/custom_player/legacy/ctm_swat_varianti.mdl", tmp49_)
			VECTOR_PUSH(armsModels, "models/player/custom_player/legacy/ctm_swat_variantj.mdl", tmp50_)
			VECTOR_PUSH(armsModels, "models/player/custom_player/legacy/tm_balkan_variantk.mdl", tmp51_)
			VECTOR_PUSH(armsModels, "models/player/custom_player/legacy/tm_balkan_variantl.mdl", tmp52_)
			VECTOR_PUSH(armsModels, "models/player/custom_player/legacy/tm_phoenix_varianti.mdl", tmp53_)
			VECTOR_PUSH(armsModels, "models/player/custom_player/legacy/tm_professional_varf.mdl", tmp54_)
			VECTOR_PUSH(armsModels, "models/player/custom_player/legacy/tm_professional_varf1.mdl", tmp55_)
			VECTOR_PUSH(armsModels, "models/player/custom_player/legacy/tm_professional_varf2.mdl", tmp56_)
			VECTOR_PUSH(armsModels, "models/player/custom_player/legacy/tm_professional_varf3.mdl", tmp57_)
			VECTOR_PUSH(armsModels, "models/player/custom_player/legacy/tm_professional_varf4.mdl", tmp58_)
			VECTOR_PUSH(armsModels, "models/player/custom_player/legacy/tm_professional_varg.mdl", tmp59_)
			VECTOR_PUSH(armsModels, "models/player/custom_player/legacy/tm_professional_varh.mdl", tmp60_)
			VECTOR_PUSH(armsModels, "models/player/custom_player/legacy/tm_professional_vari.mdl", tmp61_)
			VECTOR_PUSH(armsModels, "models/player/custom_player/legacy/tm_professional_varj.mdl", tmp62_)

			/*
			VECTOR_PUSH(armsModels, "models/player/custom_player/legacy/ctm_fbi_variantb.mdl", tmp50)
			VECTOR_PUSH(armsModels, "models/player/custom_player/nf/lara/lara_arms.mdl", tmp51)
			VECTOR_PUSH(armsModels, "models/player/custom_player/voikanaa/halo4/cortana.mdl", tmp52)
			VECTOR_PUSH(armsModels, "models/player/samus/samus.mdl", tmp53)
			VECTOR_PUSH(armsModels, "models/player/custom_player/kodua/goku/goku_arms.mdl", tmp54)
			VECTOR_PUSH(armsModels, "models/player/custom_player/legacy/cuddleleader.mdl", tmp55)
			VECTOR_PUSH(armsModels, "models/player/custom_player/legacy/gxp/valorant_viper/viper_arm_v1.mdl", tmp56)
			VECTOR_PUSH(armsModels, "models/player/custom_player/kuristaja/cso2/sas/sas_arms.mdl", tmp57)
			VECTOR_PUSH(armsModels, "models/player/custom_player/kuristaja/cso2/lincoln/lincoln_arms.mdl", tmp58)
			VECTOR_PUSH(armsModels, "models/player/custom_player/kuristaja/cso2/karachenko/karachenko_arms.mdl", tmp59)
			VECTOR_PUSH(armsModels, "models/player/custom_player/kuristaja/cso2/gign/gign_arms.mdl", tmp60)
			VECTOR_PUSH(armsModels, "models/player/custom_player/kuristaja/cso2/carrie/carrie_arms.mdl", tmp61)
			VECTOR_PUSH(armsModels, "models/player/custom_player/kuristaja/cso2/707/707_arms.mdl", tmp62)
			VECTOR_PUSH(armsModels, "models/player/custom_player/legacy/tm_phoenix_variantf.mdl", tmp63)
			VECTOR_PUSH(armsModels, "models/player/custom_player/legacy/tm_phoenix_variantg.mdl", tmp64)
			VECTOR_PUSH(armsModels, "models/player/custom_player/legacy/tm_phoenix_varianth.mdl", tmp65)
			VECTOR_PUSH(playerModels, "models/player/custom_player/legacy/ctm_fbi_variantf.mdl", tmp21)
			VECTOR_PUSH(playerModels, "models/player/custom_player/legacy/ctm_fbi_variantg.mdl", tmp22)
			VECTOR_PUSH(playerModels, "models/player/custom_player/legacy/ctm_fbi_varianth.mdl", tmp23)
			VECTOR_PUSH(playerModels, "models/player/custom_player/legacy/ctm_sas_variantf.mdl", tmp24)
			VECTOR_PUSH(playerModels, "models/player/custom_player/legacy/ctm_st6_variante.mdl", tmp25)
			VECTOR_PUSH(playerModels, "models/player/custom_player/legacy/ctm_st6_variantg.mdl", tmp26)
			VECTOR_PUSH(playerModels, "models/player/custom_player/legacy/ctm_st6_varianti.mdl", tmp27)
			VECTOR_PUSH(playerModels, "models/player/custom_player/legacy/ctm_st6_variantk.mdl", tmp28)
			VECTOR_PUSH(playerModels, "models/player/custom_player/legacy/ctm_st6_variantm.mdl", tmp29)
			VECTOR_PUSH(playerModels, "models/player/custom_player/legacy/tm_balkan_variantf.mdl", tmp31)
			VECTOR_PUSH(playerModels, "models/player/custom_player/legacy/tm_balkan_variantg.mdl", tmp32)
			VECTOR_PUSH(playerModels, "models/player/custom_player/legacy/tm_balkan_varianth.mdl", tmp33)
			VECTOR_PUSH(playerModels, "models/player/custom_player/legacy/tm_balkan_varianti.mdl", tmp34)
			VECTOR_PUSH(playerModels, "models/player/custom_player/legacy/tm_balkan_variantj.mdl", tmp35)
			VECTOR_PUSH(playerModels, "models/player/custom_player/legacy/tm_leet_variantf.mdl", tmp36)
			VECTOR_PUSH(playerModels, "models/player/custom_player/legacy/tm_leet_variantg.mdl", tmp37)
			VECTOR_PUSH(playerModels, "models/player/custom_player/legacy/tm_leet_varianth.mdl", tmp38)
			VECTOR_PUSH(playerModels, "models/player/custom_player/legacy/tm_leet_varianti.mdl", tmp39)
			VECTOR_PUSH(playerModels, "models/player/custom_player/legacy/tm_phoenix_variantf.mdl", tmp40)
			VECTOR_PUSH(playerModels, "models/player/custom_player/legacy/tm_phoenix_variantg.mdl", tmp41)
			VECTOR_PUSH(playerModels, "models/player/custom_player/legacy/tm_phoenix_varianth.mdl", tmp42)
			VECTOR_PUSH(playerModels, "models/player/custom_player/legacy/ctm_st6_variantj.mdl", tmp43)
			VECTOR_PUSH(playerModels, "models/player/custom_player/legacy/ctm_st6_variantl.mdl", tmp44)
			VECTOR_PUSH(playerModels, "models/player/custom_player/legacy/ctm_swat_variante.mdl", tmp45)
			VECTOR_PUSH(playerModels, "models/player/custom_player/legacy/ctm_swat_variantf.mdl", tmp46)
			VECTOR_PUSH(playerModels, "models/player/custom_player/legacy/ctm_swat_variantg.mdl", tmp47)
			VECTOR_PUSH(playerModels, "models/player/custom_player/legacy/ctm_swat_varianth.mdl", tmp48)
			VECTOR_PUSH(playerModels, "models/player/custom_player/legacy/ctm_swat_varianti.mdl", tmp49)
			VECTOR_PUSH(playerModels, "models/player/custom_player/legacy/ctm_swat_variantj.mdl", tmp50)
			VECTOR_PUSH(playerModels, "models/player/custom_player/legacy/tm_balkan_variantk.mdl", tmp51)
			VECTOR_PUSH(playerModels, "models/player/custom_player/legacy/tm_balkan_variantl.mdl", tmp52)
			VECTOR_PUSH(playerModels, "models/player/custom_player/legacy/tm_phoenix_varianti.mdl", tmp53)
			VECTOR_PUSH(playerModels, "models/player/custom_player/legacy/tm_professional_varf.mdl", tmp54)
			VECTOR_PUSH(playerModels, "models/player/custom_player/legacy/tm_professional_varf1.mdl", tmp55)
			VECTOR_PUSH(playerModels, "models/player/custom_player/legacy/tm_professional_varf2.mdl", tmp56)
			VECTOR_PUSH(playerModels, "models/player/custom_player/legacy/tm_professional_varf3.mdl", tmp57)
			VECTOR_PUSH(playerModels, "models/player/custom_player/legacy/tm_professional_varf4.mdl", tmp58)
			VECTOR_PUSH(playerModels, "models/player/custom_player/legacy/tm_professional_varg.mdl", tmp59)
			VECTOR_PUSH(playerModels, "models/player/custom_player/legacy/tm_professional_varh.mdl", tmp60)
			VECTOR_PUSH(playerModels, "models/player/custom_player/legacy/tm_professional_vari.mdl", tmp61)
			VECTOR_PUSH(playerModels, "models/player/custom_player/legacy/tm_professional_varj.mdl", tmp62)
			*/

			VMProtectEnd();
	}

	static unsigned int __fastcall hooked_uint_fn(void* thisptr, void*, int slot, EStickerAttributeType attribute, unsigned fl)
	{
		VMProtectBeginMutation("skinchanger::hooked_uint_fn");

		auto item = reinterpret_cast<C_BaseAttributableItem*>(uintptr_t(thisptr) - s_iwoff);

		if(!item)
			return reinterpret_cast<decltype(hooked_uint_fn)*>(o_uint_fn)(thisptr, nullptr, slot, attribute, fl);

		auto localPlayer = game::getLocalPlayer();

		if (!localPlayer->isAlive())
			return reinterpret_cast<decltype(hooked_uint_fn)*>(o_uint_fn)(thisptr, nullptr, slot, attribute, fl);

		int team = localPlayer->m_iTeamNum();

		if (attribute == EStickerAttributeType::Index)
		{
			if (!item->IsBaseCombatWeapon() || ((C_BaseCombatWeapon*)item)->IsKnife())
				return reinterpret_cast<decltype(hooked_uint_fn)*>(o_uint_fn)(thisptr, nullptr, slot, attribute, fl);

			if(*item->m_iItemDefinitionIndex() == WEAPON_KNIFE || *item->m_iItemDefinitionIndex() == WEAPON_KNIFE_T)
				return reinterpret_cast<decltype(hooked_uint_fn)*>(o_uint_fn)(thisptr, nullptr, slot, attribute, fl);

			if (team == TEAM_COUNTER_TERRORIST) // CT
			{
				switch (*item->m_iItemDefinitionIndex())
				{
					STICKER_GROUPE(ctSkins, slot)
				}
			}
			else if (team == TEAM_TERRORIST) // T
			{
				switch (*item->m_iItemDefinitionIndex())
				{
					STICKER_GROUPE(tSkins, slot)
				}
			}
		}

		VMProtectEnd();

		return reinterpret_cast<decltype(hooked_uint_fn)*>(o_uint_fn)(thisptr, nullptr, slot, attribute, fl);
	}

	int applyStickerHooks(int* item)
	{
		VMProtectBeginMutation("skinchanger::initStickerHooks");

		// thx to a guy from ukc

		if (!s_iwoff)
			s_iwoff = 0x2DC0 + 0xC; //m_Item

		void**& iw_vt = *reinterpret_cast<void***>(uintptr_t(item) + s_iwoff);

		static void** iw_hook_vt = nullptr;

		if (!iw_hook_vt)
		{
			size_t len = 0;

			for (; iw_vt[len]; ++len);

			iw_hook_vt = new void*[len];

			memcpy(iw_hook_vt, iw_vt, len * sizeof(void*));

			o_uint_fn = iw_hook_vt[5];

			iw_hook_vt[5] = &hooked_uint_fn;
		}

		iw_vt = iw_hook_vt;

		VMProtectEnd();

		return 0;
	}

	void applyPlayerModel(int frameStage) {

		VMProtectBeginMutation("skinchanger::applyPlayerModel");

		auto localPlayer = game::getLocalPlayer();

		static int originalIdx = 0;

		if (!localPlayer) {
			originalIdx = 0;
			return;
		}

		if (!localPlayer->isAlive()) {
			originalIdx = 0;
			return;
		}

		auto modelPath = playerModels.at(config::visual.playerModel.id).c_str();

		if (frameStage == FRAME_RENDER_START)
			originalIdx = localPlayer->m_nModelIndex();

		int modelIndex = frameStage == FRAME_RENDER_END && originalIdx ? originalIdx : interfaces::modelInfo->GetModelIndex(modelPath);

		// if a custom model is not loaded
		if (modelIndex == -1) {
			// load it
			if (!utils::precacheModel(modelPath)) {

#ifdef _DEBUG
				common::ps(XorStr("skinchanger::applyPlayerModel : fail to precacheModel"));
#endif
			}
			// retry to get its id
			else {
				modelIndex = frameStage == FRAME_RENDER_END && originalIdx ? originalIdx : interfaces::modelInfo->GetModelIndex(modelPath);
			}
		}

		auto armsModelPath = armsModels.at(config::visual.playerModel.id).c_str();

		// checks if loaded or not
		int armsModelId = interfaces::modelInfo->GetModelIndex(armsModelPath);

		// if a custom model arms is not loaded
		if (armsModelId == -1) {
			// load it
			if (!utils::precacheModel(armsModelPath)) {

#ifdef _DEBUG
				common::ps(XorStr("skinchanger::applyPlayerModel : fail to precacheModel arms"));
#endif
			}
		}

		localPlayer->setModelIndex(modelIndex);

		auto ragdoll = (Entity*)interfaces::clientEntityList->GetClientEntityFromHandle(localPlayer->m_hRagdoll());

		if (ragdoll)
			ragdoll->setModelIndex(modelIndex);

		VMProtectEnd();
	}

	void applyTeamMateModel(Entity* e, int frameStage) {

		VMProtectBeginMutation("skinchanger::applyTeamMateModel");

		auto modelPath = playerModels.at(config::visual.teamMateModel.id).c_str();

		int modelIndex = interfaces::modelInfo->GetModelIndex(modelPath);

		// if a custom model is not loaded
		if (modelIndex == -1) {
			// load it
			if (!utils::precacheModel(modelPath)) {

#ifdef _DEBUG
				common::ps(XorStr("skinchanger::applyTeamMateModel : fail to precacheModel"));
#endif
				return;
			}
			// retry to get its id
			else {
				modelIndex = interfaces::modelInfo->GetModelIndex(modelPath);
			}
		}

		e->setModelIndex(modelIndex);

		auto ragdoll = (Entity*)interfaces::clientEntityList->GetClientEntityFromHandle(e->m_hRagdoll());

		if (ragdoll)
			ragdoll->setModelIndex(modelIndex);

		VMProtectEnd();
	}

	void entityLoop(int frameStage) {

		VMProtectBeginMutation("skinchanger::entityLoop");

		auto localPlayer = game::getLocalPlayer();

		if (!localPlayer)
			return;

		// loop about entities
		for (int i = 0; i < interfaces::clientEntityList->GetHighestEntityIndex(); i++) {

			auto entity = (Entity*)(interfaces::clientEntityList->GetClientEntity(i));

			if (!entity)
				continue;

			if (!entity->isPlayer() || entity == localPlayer)
				continue;

			// if team mates
			if (config::visual.teamMateModel.enable && entity->m_iTeamNum() == localPlayer->m_iTeamNum())
			{
				applyTeamMateModel(entity, frameStage);
			}
			else if (entity->m_iTeamNum() != localPlayer->m_iTeamNum()) {
				// radar
				entity->setSpotted(config::visual.showRadar);
			}
		}

		VMProtectEnd();
	}

	void updateAnimations(C_BaseCombatWeapon* ent) {

		VMProtectBeginMutation("skinchanger::updateAnimations");

		// from : legendware

		int seq = *ent->m_nSequence();

		int itemDefinitionIndex = *((C_BaseAttributableItem*)ent)->m_iItemDefinitionIndex();

		// check if this knife needs extra fixing.
		if (itemDefinitionIndex == WEAPON_KNIFE_BUTTERFLY ||
			itemDefinitionIndex == WEAPON_KNIFE_FALCHION ||
			itemDefinitionIndex == WEAPON_KNIFE_SURVIVAL_BOWIE ||
			itemDefinitionIndex == WEAPON_KNIFE_OUTDOOR) {

			// fix the idle sequences.
			if (seq == 1 || seq == 2) {
				// set the animation to be completed.
				*ent->m_flCycle() = 0.999f;

				// cycle change, re-render.
				interfaces::invalidatePhysicsRecursive((void*)ent, ANIMATION_CHANGED);
			}
		}

		VMProtectEnd();
	}

	void changeViewModel(C_BaseAttributableItem* pCurrentWeapon) {

		VMProtectBeginMutation("skinchanger::changeViewModel");

		auto localPlayer = game::getLocalPlayer();

		if (!localPlayer->m_hViewModel())
			return;

		C_BaseViewModel* pViewModel = (C_BaseViewModel*)interfaces::clientEntityList->GetClientEntityFromHandle((CBaseHandle)localPlayer->m_hViewModel());

		if (!pViewModel)
			return;

		DWORD hViewModelWeapon = pViewModel->m_hWeapon();

		if (!hViewModelWeapon)
			return;

		C_BaseAttributableItem* pViewModelWeapon = (C_BaseAttributableItem*)interfaces::clientEntityList->GetClientEntityFromHandle((CBaseHandle)hViewModelWeapon);

		// if the weapon is the current weapon of the player
		if (!pViewModelWeapon || pViewModelWeapon != pCurrentWeapon)
			return;

		auto pViewModelWeaponInfo = (C_BaseCombatWeapon*)pViewModelWeapon;

		// if it's not a knife
		if (!pViewModelWeaponInfo->IsKnife())
			return;

		int team = localPlayer->m_iTeamNum();

		int knifeId = team == TEAM_COUNTER_TERRORIST ? config::visual.skins.ctSkins.knifeId : config::visual.skins.tSkins.knifeId;

		auto pViewModelWeaponBase = (C_BaseViewModel*)pViewModelWeapon;

		pViewModel->setModelIndex(interfaces::modelInfo->GetModelIndex(knifeModelNames.at(knifeId).c_str()));

		VMProtectEnd();
	}

	void applyKnifeSkin(int itemDefinitionIndex, C_BaseAttributableItem* weaponObject, player_info_t* info, bool updateSkin) {

		VMProtectBeginMutation("skinchanger::applyKnifeSkin");

		int team = game::getLocalPlayer()->m_iTeamNum();

		int knifeId = team == TEAM_COUNTER_TERRORIST ? config::visual.skins.ctSkins.knifeId : config::visual.skins.tSkins.knifeId;
		int knifePaint = team == TEAM_COUNTER_TERRORIST ? config::visual.skins.ctSkins.knifePaint : config::visual.skins.tSkins.knifePaint;

		// update only if I change its paint
		if (knifePaint == 0)
			return;

		int knifeModelId = interfaces::modelInfo->GetModelIndex(knifeModelNames.at(knifeId).c_str());
		int knifeDefinitionId = getKnifeDefinitionIndex(knifeId);

		if (itemDefinitionIndex == WEAPON_KNIFE ||
			itemDefinitionIndex == WEAPON_KNIFE_T ||
			itemDefinitionIndex == knifeDefinitionId)
		{
			/*
			if (updateSkin) {
				// save it to restore it latter
				itemIDHighOriginals[itemDefinitionIndex] = *weaponObject->m_iItemIDHigh();
				// force csgo to use callbacks
				*weaponObject->m_iItemIDHigh() = -1;

				// live update ...
				//weaponObject->PostDataUpdate(DATA_UPDATE_CREATED);
				//weaponObject->OnDataChanged(DATA_UPDATE_CREATED);
			}
			else if (*weaponObject->m_iItemIDHigh() != itemIDHighOriginals[itemDefinitionIndex]) {
				// restore the original ID High
				*weaponObject->m_iItemIDHigh() = itemIDHighOriginals[itemDefinitionIndex];
			}
			*/
			
			*weaponObject->m_nModelIndex() = knifeModelId;

			((C_BaseCombatWeapon*)weaponObject)->setViewModelIndex(knifeModelId);

			if (updateSkin) {

				*weaponObject->m_iItemDefinitionIndex() = knifeDefinitionId;
				*weaponObject->m_nFallbackPaintKit() = knifePaint;
				*weaponObject->m_iEntityQuality() = 3;
				*weaponObject->m_flFallbackWear() = 0;
				*weaponObject->m_nFallbackSeed() = 0;

				*weaponObject->m_iItemIDHigh() = -1;
			}
		}

		VMProtectEnd();
	}

	void applySkin(int itemDefinitionIndex, C_BaseAttributableItem* weaponObject, skin* s, player_info_t* info) {

		VMProtectBeginMutation("skinchanger::applySkin");

		// update only if I change its paint
		if (s->paint == 0)
			return;

		// it's not my weapon
		if (info->xuidlow != *weaponObject->m_OriginalOwnerXuidLow() || info->xuidhigh != *weaponObject->m_OriginalOwnerXuidHigh())
			return;

		/*
		if (updateSkin) {
			// save it to restore it latter
			itemIDHighOriginals[itemDefinitionIndex] = *weaponObject->m_iItemIDHigh();
			// force csgo to use callbacks
			*weaponObject->m_iItemIDHigh() = -1;

			// live update ...
			//weaponObject->PostDataUpdate(DATA_UPDATE_CREATED);
			//weaponObject->OnDataChanged(DATA_UPDATE_CREATED);
		}
		else if (*weaponObject->m_iItemIDHigh() != itemIDHighOriginals[itemDefinitionIndex]) {
			// restore the original ID High
			*weaponObject->m_iItemIDHigh() = itemIDHighOriginals[itemDefinitionIndex];
		}
		*/

		// apply config
		*weaponObject->m_nFallbackPaintKit() = s->paint;
		*weaponObject->m_flFallbackWear() = s->wear;
		*weaponObject->m_nFallbackSeed() = s->seed;
		*weaponObject->m_iEntityQuality() = s->quality;
		// fix stattrack
		*weaponObject->m_iAccountID() = info->xuidlow;
		// force csgo to use callbacks
		*weaponObject->m_iItemIDHigh() = -1;

		VMProtectEnd();
	}

	void applyWeaponSkins() {

		VMProtectBeginMutation("skinchanger::applyWeaponSkins");

		auto localPlayer = game::getLocalPlayer();

		if (!localPlayer)
			return;

		if (!localPlayer->isAlive())
			return;

		int team = localPlayer->m_iTeamNum();

		CBaseHandle m_hActiveWeapon = localPlayer->m_hActiveWeapon();

		if (!m_hActiveWeapon)
			return;

		auto myWeapons = localPlayer->myWeapons();

		if (!myWeapons)
			return;

		player_info_t info;

		if (!interfaces::engineClient->GetPlayerInfo(localPlayer->index(), &info))
			return;

		for (size_t i = 0; myWeapons[i] != INVALID_EHANDLE_INDEX; i++) {

			auto weapon = (C_BaseAttributableItem*)(interfaces::clientEntityList->GetClientEntityFromHandle(myWeapons[i]));

			if (!weapon)
				continue;

			// sticker fix
			if (((Entity*)weapon)->is(HASH("CPredictedViewModel"))) {

				if (!((C_BaseCombatWeapon*)weapon)->IsKnife())
					continue;

				if (info.xuidlow != *weapon->m_OriginalOwnerXuidLow() || info.xuidhigh != *weapon->m_OriginalOwnerXuidHigh())
					continue;

				int itemDefinitionIndex = *weapon->m_iItemDefinitionIndex();

				// change model first lap
				applyKnifeSkin(itemDefinitionIndex, weapon, &info, false);

				// change the knife model
				changeViewModel(weapon);

				// fix animtions
				updateAnimations((C_BaseCombatWeapon*)weapon);
			}

			if (!weapon->IsBaseCombatWeapon())
				continue;

			if (info.xuidlow != *weapon->m_OriginalOwnerXuidLow() || info.xuidhigh != *weapon->m_OriginalOwnerXuidHigh())
				continue;

			int itemDefinitionIndex = *weapon->m_iItemDefinitionIndex();

			if (!itemDefinitionIndex)
				continue;

			// changing skin
			if (((C_BaseCombatWeapon*)weapon)->IsKnife())
			{
				applyKnifeSkin(itemDefinitionIndex, weapon, &info, true);
			}
			else {

				bool weaponSkinChanged = false;

				if (team == TEAM_COUNTER_TERRORIST) // CT
				{
					switch (*weapon->m_iItemDefinitionIndex())
					{
						SKIN_GROUPE(ctSkins, weapon)
					}
				}

				else if (team == TEAM_TERRORIST) // T
				{
					switch (*weapon->m_iItemDefinitionIndex())
					{
						SKIN_GROUPE(tSkins, weapon)
					}
				}

				// apply sticker ONLY on changed weapons AFTER changing skin and knife model
				if(weaponSkinChanged)
					applyStickerHooks((int*)weapon);
			}
		}

		// use this to restore at the ID next call
		if(updateSkin)
			updateSkin = false;

		VMProtectEnd();
	}

	void frameStageNotify(int frameStage) {

		VMProtectBeginMutation("skinchanger::frameStageNotify");

		if (config::visual.skins.enable && frameStage == FRAME_NET_UPDATE_POSTDATAUPDATE_START) 
			applyWeaponSkins();

		if (config::visual.playerModel.enable)
			applyPlayerModel(frameStage);
		
		entityLoop(frameStage);

		VMProtectEnd();
	}
}
```

`Lumina/Lumina/features/visuals/skinchanger.h`:

```h
#ifndef skinchanger_h

#define skinchanger_h

#include <string>
#include <vector>

#define SKIN_SLOT(id,side,weapon,weaponObject) \
	case (int)id: \
			applySkin(itemDefinitionIndex, weaponObject, &(config::visual.skins.side.weapon), &info); \
			weaponSkinChanged = true; \
	break; \

#define STICKER_SLOT(id,side,weapon,slot) \
	case (int)id: \
		switch (slot) \
		{\
		case 0:\
			return config::visual.skins.side.weapon.sticker1;\
		case 1:\
			return config::visual.skins.side.weapon.sticker2;\
		case 2:\
			return config::visual.skins.side.weapon.sticker3;\
		case 3:\
			return config::visual.skins.side.weapon.sticker4;\
		case 4:\
			return config::visual.skins.side.weapon.sticker4;\
		default:\
			break;\
		}\
	break;\

#define STICKER_GROUPE(side,slot) \
	STICKER_SLOT(WEAPON_AK47,side,ak47Skin,slot) \
	STICKER_SLOT(WEAPON_AWP,side,awpSkin,slot) \
	STICKER_SLOT(WEAPON_USP_SILENCER,side,uspSkin,slot) \
	STICKER_SLOT(WEAPON_DEAGLE,side,deagleSkin,slot) \
	STICKER_SLOT(WEAPON_SSG08,side, ssg08Skin,slot) \
	STICKER_SLOT(WEAPON_SCAR20,side, scarSkin,slot) \
	STICKER_SLOT(WEAPON_M4A1, side, m4a1Skin,slot) \
	STICKER_SLOT(WEAPON_FAMAS, side, famasSkin, slot) \
	STICKER_SLOT(WEAPON_G3SG1, side, g3sg1Skin, slot) \
	STICKER_SLOT(WEAPON_M4A1_SILENCER, side, m4a1s1Skin, slot) \
	STICKER_SLOT(WEAPON_SG556, side, sg553Skin, slot) \
	STICKER_SLOT(WEAPON_AUG, side, augSkin, slot) \
	STICKER_SLOT(WEAPON_GALILAR, side, galilSkin, slot) \
	STICKER_SLOT(WEAPON_MAC10, side, mac10Skin, slot) \
	STICKER_SLOT(WEAPON_MP5SD, side, mp5Skin, slot) \
	STICKER_SLOT(WEAPON_MP7, side, mp7Skin, slot) \
	STICKER_SLOT(WEAPON_MP9, side, mp9Skin, slot) \
	STICKER_SLOT(WEAPON_BIZON, side, ppbizonSkin, slot) \
	STICKER_SLOT(WEAPON_P90, side, p90Skin, slot) \
	STICKER_SLOT(WEAPON_UMP45, side, umpSkin, slot) \
	STICKER_SLOT(WEAPON_CZ75A, side, cz75Skin, slot) \
	STICKER_SLOT(WEAPON_ELITE, side, dualberttaSkin, slot) \
	STICKER_SLOT(WEAPON_FIVESEVEN, side, fiveSevenSkin, slot) \
	STICKER_SLOT(WEAPON_GLOCK, side, glockSkin, slot) \
	STICKER_SLOT(WEAPON_P250, side, p250Skin, slot) \
	STICKER_SLOT(WEAPON_TEC9, side, tec9Skin, slot) \
	STICKER_SLOT(WEAPON_REVOLVER, side, revolverSkin, slot) \


// don't know why, but EU csgo version has two usp and cz id
#define SKIN_GROUPE(side,weaponObject) \
	SKIN_SLOT(WEAPON_AK47,side,ak47Skin,weaponObject) \
	SKIN_SLOT(WEAPON_AWP,side,awpSkin,weaponObject) \
	SKIN_SLOT(WEAPON_USP_SILENCER,side,uspSkin,weaponObject) \
	SKIN_SLOT(262205,side,uspSkin,weaponObject) \
	SKIN_SLOT(WEAPON_DEAGLE,side,deagleSkin,weaponObject) \
	SKIN_SLOT(WEAPON_SSG08,side, ssg08Skin,weaponObject) \
	SKIN_SLOT(WEAPON_SCAR20,side, scarSkin,weaponObject) \
	SKIN_SLOT(WEAPON_M4A1, side, m4a1Skin, weaponObject) \
	SKIN_SLOT(WEAPON_FAMAS, side, famasSkin, weaponObject) \
	SKIN_SLOT(WEAPON_G3SG1, side, g3sg1Skin, weaponObject) \
	SKIN_SLOT(WEAPON_M4A1_SILENCER, side, m4a1s1Skin, weaponObject) \
	SKIN_SLOT(WEAPON_SG556, side, sg553Skin, weaponObject) \
	SKIN_SLOT(WEAPON_AUG, side, augSkin, weaponObject) \
	SKIN_SLOT(WEAPON_GALILAR, side, galilSkin, weaponObject) \
	SKIN_SLOT(WEAPON_MAC10, side, mac10Skin, weaponObject) \
	SKIN_SLOT(WEAPON_MP5SD, side, mp5Skin, weaponObject) \
	SKIN_SLOT(WEAPON_MP7, side, mp7Skin, weaponObject) \
	SKIN_SLOT(WEAPON_MP9, side, mp9Skin, weaponObject) \
	SKIN_SLOT(WEAPON_BIZON, side, ppbizonSkin, weaponObject) \
	SKIN_SLOT(WEAPON_P90, side, p90Skin, weaponObject) \
	SKIN_SLOT(WEAPON_UMP45, side, umpSkin, weaponObject) \
	SKIN_SLOT(WEAPON_CZ75A, side, cz75Skin, weaponObject) \
	SKIN_SLOT(262207, side, cz75Skin, weaponObject) \
	SKIN_SLOT(WEAPON_ELITE, side, dualberttaSkin, weaponObject) \
	SKIN_SLOT(WEAPON_FIVESEVEN, side, fiveSevenSkin, weaponObject) \
	SKIN_SLOT(WEAPON_GLOCK, side, glockSkin, weaponObject) \
	SKIN_SLOT(WEAPON_P250, side, p250Skin, weaponObject) \
	SKIN_SLOT(WEAPON_TEC9, side, tec9Skin, weaponObject) \
	SKIN_SLOT(WEAPON_REVOLVER, side, revolverSkin, weaponObject) \


namespace skinchanger {

	extern std::vector<std::string> playerModels;
	extern std::vector<std::string> knifeModelNames;

	extern bool updateSkin;

	void init();

	void frameStageNotify(int frameStage);

	void applyWeaponSkins();

	void applyPlayerModel(int frameStage);
}

#endif // !skinchanger_h
```

`Lumina/Lumina/features/visuals/visualMisc.cpp`:

```cpp
#include "visualMisc.h"

#include "../../common/includes.h"
#include "../../common/config.h"
#include "../../sdk/interfaces.h"
#include "../../ui/render.h"
#include "../../ui/menu.h"
#include "../../common/game.h"
#include "../../common/common.h"

namespace visualMisc {

	void init() {

	}

	void watermark()
	{
		VMProtectBeginMutation("visualMisc::watermark");

		// from aristois

		int width, height;
		interfaces::engineClient->GetScreenSize(width, height);

		static int fps, old_tick_count;

		if ((interfaces::globals->tickcount - old_tick_count) > 50) {
			fps = static_cast<int>(1.f / interfaces::globals->frametime);
			old_tick_count = interfaces::globals->tickcount;
		}

		std::string barText;

		INetChannelInfo* netChannel = interfaces::engineClient->GetNetChannelInfo();

		auto localPlayer = game::getLocalPlayer();

		std::string outgoing = localPlayer ? std::to_string((int)(netChannel->GetLatency(FLOW_OUTGOING) * 1000)) : "0";

		barText.append(XorStr("Lumina"));

		if (game::isEnvironmentValid() && localPlayer) {

			ConVar* hostname = (ConVar*)interfaces::console->get_convar(XorStr("hostname"));

			if (hostname) {

				barText.append(XorStr(" | "));
				barText.append(netChannel->GetName());
				//barText.append(XorStr(" | "));
				//barText.append(interfaces::steamGameServer->BSecure() ? XorStr("VAC") : "UNPROTECTED");
			}
		}

		barText.append(XorStr(" | FPS : "));
		barText.append(std::to_string(fps));
		barText.append(XorStr(" | UP : "));
		barText.append(outgoing);
		barText.append(XorStr(" m/s"));

		int lineSize = 1;

		render::drawGradiant(width - 200, 4, 195, 20, menu::lightTop, menu::lightBottom, 255, false);
		render::drawGradiant(width - 200 + lineSize, 4 + lineSize, 195 - (lineSize * 2), 20 - (lineSize * 2), menu::mainTop, menu::mainBottom, 255, false);

		render::drawText(width - 195, 7, render::fontLight, barText.c_str(), false, Color(255, 255, 255, 255));

		VMProtectEnd();
	}
	
	int drawSpectators() {

		VMProtectBeginMutation("visualMisc::drawSpectators");

		if (!config::visual.showSpectators)
			return 0;

		auto local_player = game::getLocalPlayer();

		if (!local_player->isAlive())
			return 0;

		int spectator_index = 0;

		std::string playerList[100];

		int playerCount = 0;

		for (int i = 0; i < interfaces::globals->maxClients; i++) {

			auto entity = reinterpret_cast<Entity*>(interfaces::clientEntityList->GetClientEntity(i));

			if (!entity)
				continue;

			if (entity->m_bDormant() || entity == local_player || entity->isAlive() || !entity->isPlayer())
				continue;

			player_info_t info;
			
			interfaces::engineClient->GetPlayerInfo(i, &info);

			auto target = entity->m_hObserverTarget();

			if(!target)
				continue;

			auto spectatorTarget = reinterpret_cast<Entity*>(interfaces::clientEntityList->GetClientEntityFromHandle((uintptr_t)target));

			if(!spectatorTarget || spectatorTarget != local_player)
				continue;

			std::string name = info.name;

			if ((int)name.length() > 15) {
				name = name.substr(0, 15);
				name += "...";
			}

			playerList[playerCount++] = name;
		}

		if (playerCount == (0)) return 0;

		int width, height;

		interfaces::engineClient->GetScreenSize(width, height);

		int lineSize = 1;

		render::drawGradiant(width - 150, height / 2 - 10, 150, 10, menu::mainTop, menu::mainBottom, 255, false);

		//render::drawGradiant(width - 150 + lineSize, (height / 2 - 10) + lineSize, 150 - (lineSize * 2), 10 - (lineSize * 2), menu::mainTop, menu::mainBottom, 255, false);

		for (int i = 0; i < playerCount; i++)
		{
			std::transform(playerList[i].begin(), playerList[i].end(), playerList[i].begin(), ::tolower);

			player_info_t spectator_info;

			interfaces::engineClient->GetPlayerInfo(i, &spectator_info);

			render::drawRectangle(width - 150, height / 2 + (10 * spectator_index), 150, 10, Color(0, 0, 0, 100));

			render::drawText(width - 80, height / 2 + (10 * spectator_index), render::fontLight, playerList[i].c_str(), true, Color(255, 255, 255, 255));

			spectator_index++;
		}

		// lol ghetto
		render::drawRectangle(width - 150, height / 2 + (10 * spectator_index), 150, 4, Color(0, 0, 0, 100));
		render::drawGradiant(width - 150, height / 2 + (10 * spectator_index) + 4, 150, 3, menu::mainTop, menu::mainBottom, 255, false);

		VMProtectEnd();

		return 0;
	}

	void optimization() {

		VMProtectBeginMutation("visualMisc::optimization");

		// omg, this code

		static ConVar* mat_disable_bloom = game::getConvarNullCallback(XorStr("mat_disable_bloom"));

		mat_disable_bloom->nFlags &= (1 << 14);

		mat_disable_bloom->set_value((int)config::cheats.optimization);



		static ConVar* mat_colorcorrection = game::getConvarNullCallback(XorStr("mat_colorcorrection"));

		mat_colorcorrection->nFlags &= (1 << 14);

		mat_colorcorrection->set_value((int)!config::cheats.optimization);


		static ConVar* shadows = game::getConvarNullCallback(XorStr("cl_csm_enabled"));

		shadows->nFlags &= (1 << 14);

		shadows->set_value((int)!config::cheats.optimization);


		static ConVar* mat_postprocess_enable = game::getConvarNullCallback(XorStr("mat_postprocess_enable"));

		mat_postprocess_enable->nFlags &= (1 << 14);

		mat_postprocess_enable->set_value((int)!config::cheats.optimization);

		VMProtectEnd();
	}

	void drawGrenadePrediction() {

		VMProtectBeginMutation("visualMisc::drawGrenadePrediction");

		if (!game::getLocalPlayer())
			return;

		static ConVar* cl_grenadepreview = game::getConvarNullCallback(XorStr("cl_grenadepreview"));

		cl_grenadepreview->set_value(config::visual.showGrenadePred);

		VMProtectEnd();
	}

	void maintainCrosshair() {

		VMProtectBeginMutation("visualMisc::maintainCrosshair");

		Entity* localPlayer = game::getLocalPlayer();

		if (localPlayer && localPlayer->isAlive()) {

			static ConVar* weapon_debug_spread_show = game::getConvarNullCallback(XorStr("weapon_debug_spread_show"));

			weapon_debug_spread_show->set_value(localPlayer->m_bIsScoped() || !config::visual.spreadCircle.enable ? 0 : 3);
		}

		VMProtectEnd();
	}

	void drawSpreadCircle() {

		VMProtectBeginMutation("visualMisc::drawSpreadCircle");

		if (!config::visual.spreadCircle.enable)
			return;

		Entity* localPlayer = game::getLocalPlayer();

		if (!localPlayer->isAlive())
			return;

		auto weapon = localPlayer->getWeapon();

		if (!weapon)
			return;

		auto playerFov = localPlayer->fov();

		int w, h;

		interfaces::engineClient->GetScreenSize(w, h);

		float spreadDist = ((weapon->get_inaccuracy() + weapon->get_spread()) * 320.f) / std::tan(DEG2RAD(playerFov == 0 ? 90 : playerFov) * 0.5f);
		
		float spreadRadius = spreadDist * (h / 480.f);

		float max = config::visual.spreadCircle.min;

		float alpha = ((spreadRadius / max) * 255);

		if(alpha < 40)
			render::drawCircle(w / 2, h / 2, 1, 240, Color(255, 255, 255, 255));
		else if (spreadRadius < max && (255 - alpha) > 0)
			render::drawCircle(w / 2, h / 2, static_cast<int>((spreadRadius)), 240, Color(255, 255, 255, 255 - alpha));

		VMProtectEnd();
	}

	void drawHitmarker() {

		VMProtectBeginMutation("visualMisc::drawHitmarker");

		if (!config::visual.sounds.enable || common::hitmarkerTime <= 0)
			return;

		int width, height;

		interfaces::engineClient->GetScreenSize(width, height);

		int w = width / 2;
		int h = height / 2;

		int size_x = 8;
		int size_y = 4;

		Color c = Color(255, 255, 255, common::hitmarkerTime);

		render::drawLine(w + size_x, h + size_x, w + size_y, h + size_y, c);
		render::drawLine(w - size_x, h + size_x, w - size_y, h + size_y, c);
		render::drawLine(w + size_x, h - size_x, w + size_y, h - size_y, c);
		render::drawLine(w - size_x, h - size_x, w - size_y, h - size_y, c);

		common::hitmarkerTime -= 2;

		std::string damage = std::to_string(common::hitmarkerDamage);

		render::drawText(w + 20, h + 20, render::fontBigger, damage.c_str(), true, c);

		VMProtectEnd();
	}

	void drawFlashTimer() {

		VMProtectBeginMutation("visualMisc::drawFlashTimer");

		if (!config::visual.indicators.showFlashDuration)
			return;

		Entity* localPlayer = game::getLocalPlayer();

		if (!localPlayer)
			return;

		if (!localPlayer->m_flFlashDuration() || !localPlayer->isAlive())
			return;

		float factor = localPlayer->m_flFlashAlpha() / localPlayer->m_flFlashMaxAlpha();

		int w, h;

		Color c = Color(255, 255, 255, factor * 255);

		interfaces::engineClient->GetScreenSize(w, h);

		std::string flash = XorStr("FLASHED FOR ");
		flash.append(std::to_string(factor));
		flash.append(XorStr(" SECONDES"));

		render::drawText(w / 2, (h / 2) + 25, render::fontBigger, flash.c_str(), true, c);

		int barSizeX = 150;
		int barSizeY = 10;

		int barSizeCurrent = factor * barSizeX;

		render::drawRectangle((w / 2) - (barSizeX / 2), (h / 2) + 60, barSizeCurrent, barSizeY, Color(0, 0, 0, factor * 255));

		VMProtectEnd();
	}
}

```

`Lumina/Lumina/features/visuals/visualMisc.h`:

```h
#include <vector>

namespace visualMisc {

	void init();

	void drawSpreadCircle();

	void drawFlashTimer();

	int drawSpectators();

	void drawGrenadePrediction();

	void maintainCrosshair();

	void drawHitmarker();

	void watermark();

	void optimization();
}
```

`Lumina/Lumina/features/visuals/world.cpp`:

```cpp
#include "world.h"

#include "../../common/common.h"
#include "../../sdk/interfaces.h"

std::vector<IMaterial*> worlds, props;
std::vector<std::string> world::skyboxs = std::vector<std::string>();

void world::worldModulation() {

	VMProtectBeginMutation("world::worldModulation");

	if (!game::getLocalPlayer() || !game::isEnvironmentValid())
		return;

	static ConVar* r_DrawSpecificStaticProp = game::getConvarNullCallback(XorStr("r_DrawSpecificStaticProp"));

	// IsUsingStaticPropDebugModes : thx pandora
	r_DrawSpecificStaticProp->set_value(config::visual.world.enable ? 0 : -1);

	// reset mat collection
	worldModulationResetMaterials();

	// modulate world
	for (auto mat : worlds) {

		if (config::visual.world.enable) {
			mat->ColorModulate((float)config::visual.world.worldColor.r() / 255.0f, (float)config::visual.world.worldColor.g() / 255.0f, (float)config::visual.world.worldColor.b() / 255.0f);
			mat->AlphaModulate((float)config::visual.world.worldColor.a() / 255.0f);
		}
		else {
			mat->ColorModulate(1.f, 1.f, 1.f);
			mat->AlphaModulate(1.f);
		}
	}

	// modulate props
	for (auto mat : props) {

		if (config::visual.world.enable) {
			mat->ColorModulate((float)config::visual.world.propsColor.r() / 255.0f, (float)config::visual.world.propsColor.g() / 255.0f, (float)config::visual.world.propsColor.b() / 255.0f);
			mat->AlphaModulate((float)config::visual.world.propsColor.a() / 255.0f);
		}
		else {
			mat->ColorModulate(1.f, 1.f, 1.f);
			mat->AlphaModulate(1.f);
		}
	}

	VMProtectEnd();
}

void world::init() {

	VMProtectBeginMutation("world::init");

	VECTOR_PUSH(skyboxs, "sky_csgo_night02", tmp0)
	VECTOR_PUSH(skyboxs, "sky101", tmp1)
	VECTOR_PUSH(skyboxs, "sky105", tmp2)
	VECTOR_PUSH(skyboxs, "sky106", tmp3)
	VECTOR_PUSH(skyboxs, "sky191", tmp4)
	VECTOR_PUSH(skyboxs, "vertigoblue_hdr", tmp5)
	VECTOR_PUSH(skyboxs, "sky302", tmp6)
	VECTOR_PUSH(skyboxs, "sky303", tmp7)
	VECTOR_PUSH(skyboxs, "space_10", tmp8)
	VECTOR_PUSH(skyboxs, "space", tmp9)
	VECTOR_PUSH(skyboxs, "mr_15", tmp10)
	VECTOR_PUSH(skyboxs, "sky184", tmp11)

	VMProtectEnd();
}

void world::changeWorldSky() {

	VMProtectBeginMutation("world::changeWorldSky");

	if (!game::getLocalPlayer() || !game::isEnvironmentValid())
		return;

	static ConVar* r_3dsky = game::getConvarNullCallback(XorStr("r_3dsky"));

	r_3dsky->set_value(config::visual.sky.enable ? 0 : 1);

	// normally I just do it once, but here, it's needed
	using changeSkyFn = void(__fastcall*)(const char*);

	auto changeSky = (changeSkyFn)(interfaces::patternScan(common::engineModule, XorStr("55 8B EC 81 EC ? ? ? ? 56 57 8B F9 C7 45")));

	if (config::visual.sky.enable)
		changeSky(skyboxs.at(config::visual.sky.sky).c_str());
	else
		changeSky(XorStr("vertigoblue_hdr"));

	VMProtectEnd();
}

void world::worldModulationResetMaterials() {

	VMProtectBeginMutation("world::worldModulationResetMaterials");

	worlds.clear();
	props.clear();

	for (auto h = interfaces::materialSystem->FirstMaterial();
		h != interfaces::materialSystem->InvalidMaterial();
		h = interfaces::materialSystem->NextMaterial(h)) {

		IMaterial* mat = interfaces::materialSystem->GetMaterial(h);

		if (!mat)
			continue;

		if (mat->IsErrorMaterial())
			continue;

		hash32_t textureGroupHash = FNV1a::get(mat->GetTextureGroupName());

		if (textureGroupHash == HASH(TEXTURE_GROUP_WORLD))
			worlds.push_back(mat);

		if (textureGroupHash == HASH("StaticProp textures"))
			props.push_back(mat);

	}

	VMProtectEnd();
}
```

`Lumina/Lumina/features/visuals/world.h`:

```h
#include "../../common/includes.h"

namespace world {

	extern std::vector<std::string> skyboxs;

	void worldModulation();
	void worldModulationResetMaterials();
	void changeWorldSky();
	void init();
}
```

`Lumina/Lumina/hook/functions/createMove.cpp`:

```cpp
#include "../../common/includes.h"

#include "../../sdk/interfaces.h"
#include "../../common/common.h"
#include "../../features/misc/misc.h"
#include "../../features/backtrack/backtrack.h"
#include "../../features/misc/soundEsp.h"
#include "../../features/misc/voice.h"

bool __stdcall createMoveHook(float smt, void* cmd) {

	VMProtectBeginMutation("createMoveHook");

	auto returnCall = reinterpret_cast<createMoveFn>(hook::clientModeHook.get_original(24));

	CUserCmd* userCmd = (CUserCmd*)cmd;

	if(!userCmd || !userCmd->command_number || !game::getLocalPlayer() || !game::isEnvironmentValid() || common::unload)
		return returnCall(interfaces::clientMode, smt, cmd);

	bool originalCall = returnCall(interfaces::clientMode, smt, cmd);

	if (game::getLocalPlayer()->isAlive()) {
		misc::fastStop(userCmd);
		backtrack::run(userCmd);
		soundEsp::worker(userCmd);
		//misc::silentWalk(userCmd);
		misc::infiniteDuck(userCmd);
		voice::tick();
	}

	VMProtectEnd();

	return false;
}
```

`Lumina/Lumina/hook/functions/createMove.h`:

```h
#ifndef createMove_h

#define createMove_h

using createMoveFn = bool(__thiscall*)(void*, float, void*);

bool __stdcall createMoveHook(float smt, void* cmd);

#endif
```

`Lumina/Lumina/hook/functions/doPostScreenEffects.cpp`:

```cpp
#include "doPostScreenEffects.h"

#include "../hook.h"
#include "../../sdk/interfaces.h"
#include "../../features/visuals/glow.h"
#include "../../common/common.h"

int __stdcall doPostScreenEffectHook(int value) {

	auto returnCall = reinterpret_cast<doPostScreenEffectFn>(hook::clientModeHook.get_original(44));

	VMProtectBeginMutation("doPostScreenEffectHook");

	if (game::isEnvironmentValid() && !common::unload)
	{
		glow::execute();
	}

	VMProtectEnd();

	return returnCall(interfaces::clientMode, value);
}
```

`Lumina/Lumina/hook/functions/doPostScreenEffects.h`:

```h
#ifndef doPostScreenEffects_h

#define doPostScreenEffects_h

using doPostScreenEffectFn = int(__thiscall*)(void *, int);

int __stdcall doPostScreenEffectHook(int value);

#endif
```

`Lumina/Lumina/hook/functions/drawModelExecute.cpp`:

```cpp
#include "drawModelExecute.h"

#include "../hook.h"
#include "../../sdk/interfaces.h"
#include "../../features/visuals/chams.h"
#include "../../common/common.h"

void __stdcall drawModelExecuteHook(void* context, void* state, const ModelRenderInfo_t& renderInfo, void* matrix) {
	
	VMProtectBeginMutation("drawModelExecuteHook");

	bool drawOriginal = true;

	auto returnCall = reinterpret_cast<drawModelExecuteFn>(hook::modelRenderHook.get_original(21));

	bool isEnvironmentValid = game::getLocalPlayer() && game::isEnvironmentValid();

	bool arms = false;
	bool sleeve = false;

	const char* modelName = "";

	// not optimized, but do it once :|
	if (renderInfo.pModel)
	{
		modelName = interfaces::modelInfo->GetModelName(renderInfo.pModel);

		if (modelName) {

			arms = strstr(modelName, XorStr("arms"));
			sleeve = strstr(modelName, XorStr("sleeve"));
		}
	}

	// IsForcedMaterialOverride is to avoid the glow material override
	// interfaces::modelRender->IsForcedMaterialOverride() don't works with patches
	// thx to Osiris
	if(common::unload || (interfaces::studioRender->isForcedMaterialOverride() && !(arms || sleeve)) || !isEnvironmentValid)
		return returnCall(interfaces::modelRender, context, state, renderInfo, matrix);

	drawOriginal = chams::drawModelExecute(context, state, renderInfo, matrix, modelName, arms, sleeve);

	if (drawOriginal)
		returnCall(interfaces::modelRender, context, state, renderInfo, matrix);

	VMProtectEnd();
}
```

`Lumina/Lumina/hook/functions/drawModelExecute.h`:

```h
#ifndef drawModelExecute_h

#define drawModelExecute_h

#include "../../common/includes.h"

void __stdcall drawModelExecuteHook(void* context, void* state, const ModelRenderInfo_t& renderInfo, void* matrix);

using drawModelExecuteFn = void(__thiscall*)(void*, void*, void*, const ModelRenderInfo_t&, void*);

#endif
```

`Lumina/Lumina/hook/functions/fireEventClientSide.cpp`:

```cpp
#include "fireEventClientSide.h"

/*
bool __fastcall fireEventClientSideHook(void* thisptr, void* edx, IGameEvent* event)
{
	auto returnCall = reinterpret_cast<fireEventClientSideFn>(hook::eventManagerHook.get_original(8));

	if (event)
	{
		if (!strcmp(event->GetName(), "bomb_planted")) //event name from the list
		{
			int userid = event->GetInt("userid"); //userid != entityid 
			int entid = gInts.Engine->GetPlayerForUserID(userid); //index 9 in EngineClient


			if (entid == gInts.Engine->GetLocalPlayer()) //index 12 in EngineClient
				printf("I just planted the bomb!");
		}
	}

	return returnCall(thisptr, edx, event);
}
*/
```

`Lumina/Lumina/hook/functions/fireEventClientSide.h`:

```h
#ifndef fireEventClientSide_h

#define fireEventClientSide_h

/*

#include "../../common/includes.h"

bool __fastcall fireEventClientSideHook(void* thisptr, void* edx, IGameEvent* event);

using fireEventClientSideFn = bool(__fastcall*)(IGameEventManager2*, IGameEvent*);

*/

#endif // !fireEventClientSide_h
```

`Lumina/Lumina/hook/functions/frameStageNotify.cpp`:

```cpp
#include "frameStageNotify.h"
#include "../hook.h"

#include "../../common/includes.h"
#include "../../common/common.h"
#include "../../sdk/interfaces.h"
#include "../../features/visuals/skinchanger.h"
#include "../../features/visuals/visualMisc.h"
#include "../../features/backtrack/backtrack.h"

void __stdcall frameStageNotifyHook(int frameStage) {

	VMProtectBeginMutation("frameStageNotifyHook");

	auto returnCall = reinterpret_cast<frameStageNotifyPrototype>(hook::clientHook.get_original(37));

	if (common::unload || !game::isEnvironmentValid())
		return returnCall(interfaces::modelRender, frameStage);

	static auto backtrack_init = (backtrack::init(), false);

	if (frameStage == FRAME_RENDER_START) {
		visualMisc::drawGrenadePrediction();
		visualMisc::maintainCrosshair();
		visualMisc::optimization();
	}

	else if (frameStage == FRAME_NET_UPDATE_END) {
		backtrack::update();
	}

	// safe call
	returnCall(interfaces::modelRender, frameStage);

	skinchanger::frameStageNotify(frameStage);

	VMProtectEnd();
}
```

`Lumina/Lumina/hook/functions/frameStageNotify.h`:

```h
#ifndef frameStageNotify_h

#define frameStageNotify_h

void __stdcall frameStageNotifyHook(int frameStage);

using frameStageNotifyPrototype = void(__thiscall*)(void*, int);

#endif
```

`Lumina/Lumina/hook/functions/levelInitPostEntity.cpp`:

```cpp
#include "../../common/includes.h"

#include "../../features/visuals/world.h"
#include "../../sdk/interfaces.h"

void __fastcall levelInitPostEntityHook(void* ecx, void* edx) {

	VMProtectBeginMutation("levelInitPostEntityHook");

	auto returnCall = reinterpret_cast<levelInitPostEntityFn>(hook::clientHook.get_original(6));

	returnCall(ecx);

	world::worldModulation();
	world::changeWorldSky();

	VMProtectEnd();
}
```

`Lumina/Lumina/hook/functions/levelInitPostEntity.h`:

```h
#ifndef levelInitPostEntity_h

#define levelInitPostEntity_h

using levelInitPostEntityFn = void(__thiscall*)(void*);

void __fastcall levelInitPostEntityHook(void* ecx, void* edx);

#endif // !levelInitPostEntity_h

```

`Lumina/Lumina/hook/functions/lockCursor.cpp`:

```cpp
#include "lockCursor.h"
#include "../../sdk/interfaces.h"
#include "../../ui/menu.h"
#include "../../common/common.h"

void __stdcall lockCursorHook(){

	auto returnCall = reinterpret_cast<lockCursorFn>(hook::surfaceHook.get_original(67));

	VMProtectBeginMutation("lockCursorHook");

	if (common::unload)
		return returnCall(interfaces::surface);

	if (menu::visible) {

		interfaces::surface->UnlockCursor();
		return;
	}

	VMProtectEnd();

	return returnCall(interfaces::surface);
}
```

`Lumina/Lumina/hook/functions/lockCursor.h`:

```h
#ifndef lockCursor_h

#define lockCursor_h

#include "../../common/includes.h"

using lockCursorFn = void(__thiscall*)(void*);

void __stdcall lockCursorHook();

#endif
```

`Lumina/Lumina/hook/functions/paintTraverse.cpp`:

```cpp
#include "paintTraverse.h"

#include "../../sdk/interfaces.h"
#include "../../ui/menu.h"
#include "../../features/visuals/esp.h"
#include "../../features/visuals/visualMisc.h"
#include "../../common/common.h"

void __stdcall paintTraverseHook(unsigned int panel, bool force_repaint, bool allow_force) {

	VMProtectBeginMutation("paintTraverseHook");

	auto returnCall = reinterpret_cast<paintTraverseFN>(hook::panelHook.get_original(41));

	if (common::unload)
		return returnCall(interfaces::panel, panel, force_repaint, allow_force);

	// render the original process
	returnCall(interfaces::panel, panel, force_repaint, allow_force);

	// last panel
	if (FNV1a::get(interfaces::panel->GetName(panel)) == HASH("MatSystemTopPanel")) {

		if (game::getLocalPlayer() && game::isEnvironmentValid())
		{
			esp::paintTraverse();
			
			visualMisc::drawSpreadCircle();

			visualMisc::drawSpectators();

			visualMisc::drawFlashTimer();

			visualMisc::drawHitmarker();
		}

		menu::draw();

		//visualMisc::watermark();
	}

	VMProtectEnd();
}
```

`Lumina/Lumina/hook/functions/paintTraverse.h`:

```h
#ifndef paintTraverse_h

#define paintTraverse_h

#include "../../common/includes.h"

using paintTraverseFN = void(__thiscall*)(IVPanel*, unsigned int, bool, bool);

void __stdcall paintTraverseHook(unsigned int panel, bool force_repaint, bool allow_force);

#endif
```

`Lumina/Lumina/hook/functions/serverSideChecks.cpp`:

```cpp
#include "serverSideChecks.h"

#include "../hook.h"

int __stdcall hkGetUnverifiedFileHashes(void* _this, void* someclass, int nMaxFiles)
{
	return 0;
}

int __fastcall hkCanLoadThirdPartyFiles(void* _this)
{
	return 1;
}

void __fastcall hkAllowLooseFileLoads(void* ecx, void* edx, bool allow)
{
	VMProtectBeginMutation("hkAllowLooseFileLoads");

	auto returnCall = reinterpret_cast<hkAllowLooseFileLoads_fn>(hook::fileSystemHook.get_original(129));

	returnCall(ecx, edx, true);

	VMProtectEnd();
}
```

`Lumina/Lumina/hook/functions/serverSideChecks.h`:

```h
#ifndef serverSideChecks_h

#define serverSideChecks_h

using hkAllowLooseFileLoads_fn = void(__fastcall*)(void*, void*, bool);

void __fastcall hkAllowLooseFileLoads(void* ecx, void* edx, bool allow);

int __stdcall hkGetUnverifiedFileHashes(void* _this, void* someclass, int nMaxFiles);

int __fastcall hkCanLoadThirdPartyFiles(void* _this);

#endif // !serverSideChecks_h

```

`Lumina/Lumina/hook/functions/shouldDrawFog.cpp`:

```cpp
#include "../../common/includes.h"

bool __fastcall shouldDrawFogHook(void* ecx, void* edx) {
	return !config::cheats.optimization;
}

```

`Lumina/Lumina/hook/functions/shouldDrawFog.h`:

```h
#ifndef shoudlDrawFog_h

#define shoudlDrawFog_h

bool __fastcall shouldDrawFogHook(void* ecx, void* edx);

#endif // !shoudlDrawFog_h
```

`Lumina/Lumina/hook/functions/shutdown.cpp`:

```cpp
#include "shutdown.h"
#include "../../sdk/interfaces.h"
#include "../../ui/menu.h"
#include "../../common/common.h"
#include "../../common/input.h"
#include "../../common/events.h"

void __stdcall shutdownHook(void* _interface) {

	VMProtectBeginMutation("shutdownHook");

	auto returnCall = reinterpret_cast<shutdownFN>(hook::clientHook.get_original(4));

#ifdef _DEBUG
	common::ps(XorStr("shutdownHook : started"));
#endif 

	common::unload = true;

	input::undo();

	events::shutdown();

	returnCall(interfaces::baseClientDll);

	hook::shutdown();

	common::active = false;

#ifdef _DEBUG
	common::ps(XorStr("shutdownHook : done"));
#endif 

	VMProtectEnd();
}
```

`Lumina/Lumina/hook/functions/shutdown.h`:

```h
#ifndef shutdown_h

#define shutdown_h

using shutdownFN = void(__thiscall*)(void*);

void __stdcall shutdownHook(void* _interface);

#endif
```

`Lumina/Lumina/hook/hook.cpp`:

```cpp
#include "hook.h"
#include "../sdk/interfaces.h"
#include "../common/common.h"

/*
typedef MDLHandle_t(__thiscall* iFindMdl)(void*, char*);

void __fastcall findMdl(void* _this, void* _edx, char* FilePath) {

	auto returnCall = reinterpret_cast<iFindMdl>(hook::cacheMdlHook.get_original(10));

	common::pf(XorStr("findMdl() : OK %s"), FilePath);

	returnCall(interfaces::mdlCache, FilePath);
}*/

namespace hook {

	vmt viewRenderHook;
	vmt renderViewHook;
	vmt modelRenderHook;
	vmt clientHook;
	vmt surfaceHook;
	vmt panelHook;
	vmt soundSystemHook;
	vmt findMaterialHook;
	vmt cacheMdlHook;
	vmt clientModeHook;
	vmt engineSound;
	vmt direct3d;
	vmt bspQuery;
	vmt fileSystemHook;
	vmt eventManagerHook;

	void isValid(bool var, std::string name) {

		VMProtectBeginMutation("hook::isValid");

		if (var)
		{
#ifdef _DEBUG
			common::pf(XorStr("hook::isValid : %s.setup done"), name.c_str());
#endif 
		}
		else
		{
#ifdef _DEBUG
			common::pf(XorStr("hook::isValid : %s.setup fail"), name.c_str());
#endif 
			common::exit();
		}

		VMProtectEnd();
	}

	void shutdown() {

		VMProtectBeginMutation("hook::shutdown");

		panelHook.release();
		clientHook.release();
		surfaceHook.release();
		modelRenderHook.release();
		fileSystemHook.release();
		clientModeHook.release();
		cacheMdlHook.release();

		VMProtectEnd();
	}

	int init() {

		VMProtectBeginMutation("hook::init");

		HOOK_SETUP(panelHook, "vgui2.dll", interfaces::panel, pad0)
		HOOK_SETUP(clientHook, "client.dll", interfaces::baseClientDll, pad1)
		HOOK_SETUP(surfaceHook, "vguimatsurface.dll", interfaces::surface, pad2)
		HOOK_SETUP(modelRenderHook, "engine.dll", interfaces::modelRender, pad3)
		HOOK_SETUP(fileSystemHook, "engine.dll", interfaces::fileSystem, pad4)
		HOOK_SETUP(clientModeHook, "client.dll", interfaces::clientMode, pad5)
		//HOOK_SETUP(eventManagerHook, "engine.dll", interfaces::eventManager, pad6)
		HOOK_SETUP(cacheMdlHook, "datacache.dll", interfaces::mdlCache, pad7)

		panelHook.hook_index(41, reinterpret_cast<void*>(paintTraverseHook));

		clientHook.hook_index(4, reinterpret_cast<void*>(shutdownHook));
		clientHook.hook_index(6, reinterpret_cast<void*>(levelInitPostEntityHook));
		clientHook.hook_index(37, reinterpret_cast<void*>(frameStageNotifyHook));

		surfaceHook.hook_index(67, reinterpret_cast<void*>(lockCursorHook));

		modelRenderHook.hook_index(21, reinterpret_cast<void*>(drawModelExecuteHook));

		fileSystemHook.hook_index(101, reinterpret_cast<void*>(hkGetUnverifiedFileHashes));
		fileSystemHook.hook_index(129, reinterpret_cast<void*>(hkAllowLooseFileLoads));
		fileSystemHook.hook_index(128, reinterpret_cast<void*>(hkCanLoadThirdPartyFiles));

		clientModeHook.hook_index(44, reinterpret_cast<void*>(doPostScreenEffectHook));
		clientModeHook.hook_index(24, reinterpret_cast<void*>(createMoveHook));
		clientModeHook.hook_index(17, reinterpret_cast<void*>(shouldDrawFogHook));

		//cacheMdlHook.hook_index(10, reinterpret_cast<void*>(findMdl));

		//eventManagerHook.hook_index(8, reinterpret_cast<void*>(fireEventClientSideHook));

		VMProtectEnd();

		return 0;
	}
}

```

`Lumina/Lumina/hook/hook.h`:

```h
#pragma once

#ifndef hook_h

#define hook_h

#include "vtableHook.h"

#define HOOK_SETUP(VTABLE, MODULE, INTERFACE_, TMP) bool TMP = VTABLE.setup(INTERFACE_, StringHeavy(MODULE)); \
		isValid(TMP, StringHeavy(MODULE)); \

namespace hook {

	int init();
	void shutdown();
	extern vmt renderViewHook;
	extern vmt viewRenderHook;
	extern vmt modelRenderHook;
	extern vmt clientHook;
	extern vmt surfaceHook;
	extern vmt panelHook;
	extern vmt soundSystemHook;
	extern vmt findMaterialHook;
	extern vmt cacheMdlHook;
	extern vmt clientModeHook;
	extern vmt engineSound;
	extern vmt direct3d;
	extern vmt fileSystemHook;
	extern vmt bspQuery;
	extern vmt eventManagerHook;
}

#endif // !hook_h
```

`Lumina/Lumina/hook/vtableHook.cpp`:

```cpp
#include "../common/includes.h"
#include "../common/common.h"

// thx to oneshot for the trick
// Modified code from exphck https://www.unknowncheats.me/forum/2128832-post43.html

uintptr_t* vmt::search_free_data_page(const char* module_name, const std::size_t vmt_size) 
{
	HMODULE module_addr = NULL;

	VMProtectBeginMutation("vmt::search_free_data_page");

	auto check_data_section = [&](LPCVOID address, const std::size_t vmt_size) {

		const DWORD DataProtection = (PAGE_EXECUTE_READWRITE | PAGE_READWRITE);
		MEMORY_BASIC_INFORMATION mbi = { 0 };

		//if (LI_FN(VirtualQuery).get()(address, &mbi, sizeof(mbi)) == sizeof(mbi) && mbi.AllocationBase && mbi.BaseAddress &&
		if (VirtualQuery(address, &mbi, sizeof(mbi)) == sizeof(mbi) && mbi.AllocationBase && mbi.BaseAddress &&
			mbi.State == MEM_COMMIT && !(mbi.Protect & PAGE_GUARD) && mbi.Protect != PAGE_NOACCESS) {
			if ((mbi.Protect & (DataProtection)) && mbi.RegionSize >= vmt_size) {
				return ((mbi.Protect & (DataProtection)) && mbi.RegionSize >= vmt_size) ? true : false;
			}
		}

		return false;
	};

	hash32_t moduleNameHash = FNV1a::get(module_name);

	// this is very ghetto trick, but it's the only with to keep it at compile time
	// TODO : use hash
	if (moduleNameHash == HASH("materialsystem.dll"))
	{
		module_addr = (HMODULE)LI_MODULE("materialsystem.dll").cached();
#ifdef _DEBUG
		common::ps(StringHeavy("vmt::search_free_data_page() : materialsystem.dll cached"));
#endif
	}
	else if (moduleNameHash == HASH("client.dll"))
	{
		module_addr = (HMODULE)LI_MODULE("client.dll").cached();
#ifdef _DEBUG
		common::ps(StringHeavy("vmt::search_free_data_page() : client.dll cached"));
#endif
	}
	else if (moduleNameHash == HASH("vgui2.dll"))
	{
		module_addr = (HMODULE)LI_MODULE("vgui2.dll").cached();
#ifdef _DEBUG
		common::ps(StringHeavy("vmt::search_free_data_page() : vgui2.dll cached"));
#endif
	}
	else if (moduleNameHash == HASH("engine.dll"))
	{
		module_addr = (HMODULE)LI_MODULE("engine.dll").cached();
#ifdef _DEBUG
		common::ps(StringHeavy("vmt::search_free_data_page() : engine.dll cached"));
#endif
	}
	else if (moduleNameHash == HASH("shaderapidx9.dll"))
	{
		module_addr = (HMODULE)LI_MODULE("shaderapidx9.dll").cached();
#ifdef _DEBUG
		common::ps(StringHeavy("vmt::search_free_data_page() : shaderapidx9.dll cached"));
#endif
	}
	else if (moduleNameHash == HASH("vguimatsurface.dll"))
	{
		module_addr = (HMODULE)LI_MODULE("vguimatsurface.dll").cached();
#ifdef _DEBUG
		common::ps(StringHeavy("vmt::search_free_data_page() : vguimatsurface.dll cached"));
#endif
	}
	else if (moduleNameHash == HASH("direct3d.dll"))
	{
		module_addr = (HMODULE)LI_MODULE("direct3d.dll").cached();
#ifdef _DEBUG
		common::ps(StringHeavy("vmt::search_free_data_page() : direct3d.dll cached"));
#endif
	}
	else if (moduleNameHash == HASH("datacache.dll"))
	{
		module_addr = (HMODULE)LI_MODULE("datacache.dll").cached();
#ifdef _DEBUG
		common::ps(StringHeavy("vmt::search_free_data_page() : datacache.dll cached"));
#endif
	}

	else
	{
		module_addr = LI_FN(GetModuleHandleA).get()(module_name);
#ifdef _DEBUG
		common::ps(StringHeavy("vmt::search_free_data_page() : module not cached"));
#endif
	}



	if (module_addr == nullptr) {
#ifdef _DEBUG
		common::ps(StringHeavy("vmt::setup() : module_addr == nullptr"));
		common::ps(StringHeavy("vmt::setup() : trying a last thing"));
#endif
		module_addr = GetModuleHandleA(module_name);

		if (module_addr == nullptr) {

#ifdef _DEBUG
			common::ps(StringHeavy("vmt::setup() : fail module_addr == nullptr"));
#endif

			return nullptr;
		}
	}

	/*
module_addr = GetModuleHandleA(module_name);

if (module_addr == nullptr) {

	common::ps(StringHeavy("vmt::setup() : fail module_addr == nullptr"));

	return nullptr;
}*/

	const auto dos_header = reinterpret_cast<PIMAGE_DOS_HEADER> (module_addr);

	const auto nt_headers = reinterpret_cast<PIMAGE_NT_HEADERS> (reinterpret_cast<std::uint8_t*>(module_addr) + dos_header->e_lfanew);

	const auto module_end = reinterpret_cast<std::uintptr_t>(module_addr) + nt_headers->OptionalHeader.SizeOfImage - sizeof(std::uintptr_t);

	for (auto current_address = module_end; current_address > (DWORD)module_addr; current_address -= sizeof(std::uintptr_t)) {

		if (*reinterpret_cast<std::uintptr_t*>(current_address) == 0 && check_data_section(reinterpret_cast<LPCVOID>(current_address), vmt_size)) {

			//OBF_BEGIN

			bool is_good_vmt = true;
			auto page_count = (0u);

			int i = 0;
			/*
				FOR(V(i) = N(0), page_count < vmt_size && V(is_good_vmt), page_count += sizeof(std::uintptr_t))

					IF(*reinterpret_cast<std::uintptr_t*>(current_address + page_count) != 0)
						V(is_good_vmt) = false;
					ENDIF

				ENDFOR

						if (is_good_vmt && page_count >= vmt_size)
							RETURN((uintptr_t*)current_address);

			OBF_END

					*/

			for (; page_count < vmt_size && is_good_vmt; page_count += sizeof(std::uintptr_t)) {

				if (*reinterpret_cast<std::uintptr_t*>(current_address + page_count) != 0)
					is_good_vmt = false;
			}

			if (is_good_vmt && page_count >= vmt_size)
				return ((uintptr_t*)current_address);
		}
	}

	//common::ps(StringHeavy("vmt::search_free_data_page() : end"));

	VMProtectEnd();

	return nullptr;
}

vmt::vmt()
	: class_base(nullptr), vftbl_len(0), new_vftb1(nullptr), old_vftbl(nullptr) {
}
vmt::vmt(void* base)
	: class_base(base), vftbl_len(0), new_vftb1(nullptr), old_vftbl(nullptr) {
}
vmt::~vmt() {

	VMProtectBeginMutation("vmt::~vmt");

	release();
	if (was_allocated)
		delete[] new_vftb1;

	VMProtectEnd();
}

bool vmt::setup(void* base, const char * module_name) {

	VMProtectBeginMutation("vmt::setup");

	// using a little bit of meta prog for obfu reasons

	OBF_BEGIN

	IF(base == 0)
		RETURN(false)
		ENDIF

		IF(base != nullptr)
		class_base = base;
	ENDIF

		IF(class_base == nullptr)
		RETURN(false)
		ENDIF

		size_t pointerSize = sizeof(std::uintptr_t);


	old_vftbl = *(std::uintptr_t**)class_base;



	vftbl_len = estimate_vftbl_length(old_vftbl) * (pointerSize);

	IF(vftbl_len == N((size_t)0))

	RETURN(false)
		ENDIF


	new_vftb1 = search_free_data_page(module_name, vftbl_len + (pointerSize));


	if (new_vftb1 == nullptr) {

		RETURN(false)
	}


	/*
	memset(new_vftb1, NULL, vftbl_len + sizeof(std::uintptr_t));
	*/

	unsigned char *ptr = (unsigned char *)new_vftb1;

	int len = vftbl_len + V(pointerSize);

	WHILE(len-- > 0)
		V(*ptr)++ = N(0);
	ENDWHILE


		/*
		memcpy(&new_vftb1[N(1)], old_vftbl, vftbl_len);
		*/

	char *d = (char *)&new_vftb1[N(1)];
	const char *s = (const char *)old_vftbl;

	len = vftbl_len;

	WHILE(len--)
		*d++ = *s++;
	ENDWHILE


		/*
	memset(new_vftb1, NULL, vftbl_len + sizeof(std::uintptr_t));



	memcpy(&new_vftb1[1], old_vftbl, vftbl_len);

	*/
		new_vftb1[N(0)] = old_vftbl[-1];


	try {
		auto guard = detail::protect_guard{ class_base, sizeof(std::uintptr_t), PAGE_READWRITE };

		*(std::uintptr_t**)class_base = &new_vftb1[(1)];


		was_allocated = false;
	}
	catch (...) {
		delete[] new_vftb1;
		return false;
	}

	OBF_END

	VMProtectEnd();

	return true;
}

std::size_t vmt::estimate_vftbl_length(std::uintptr_t* vftbl_start) {

	VMProtectBeginMutation("vmt::estimate_vftbl_length");

	MEMORY_BASIC_INFORMATION memInfo = { NULL };
	int m_nSize = -1;
	do {
		m_nSize++;
		LI_FN(VirtualQuery).get()(reinterpret_cast<LPCVOID>(vftbl_start[m_nSize]), &memInfo, sizeof(memInfo));
		//VirtualQuery(reinterpret_cast<LPCVOID>(vftbl_start[m_nSize]), &memInfo, sizeof(memInfo));
	} while (memInfo.Protect == PAGE_EXECUTE_READ || memInfo.Protect == PAGE_EXECUTE_READWRITE);

	VMProtectEnd();

	return m_nSize;
}

void vmt::hook_index(size_t fn_index, void* fn_pointer) {

	VMProtectBeginMutation("vmt::hook_index");

	if (fn_index >= 0 && fn_index <= (int)vftbl_len)
		new_vftb1[fn_index + 1] = reinterpret_cast<std::uintptr_t>(fn_pointer);

	VMProtectEnd();
}

void vmt::release() {

	VMProtectBeginMutation("vmt::release");

	try {
		if (old_vftbl != nullptr) {
			auto guard = detail::protect_guard{ class_base, sizeof(std::uintptr_t), PAGE_READWRITE };
			*(std::uintptr_t**)class_base = old_vftbl;
			old_vftbl = nullptr;
		}
	}
	catch (...) {
	}

	VMProtectEnd();
}

void* vmt::get_original(size_t fn_index) {

	VMProtectBeginMutation("vmt::get_original");

	void* result = reinterpret_cast<void*>(old_vftbl[fn_index]);

	VMProtectEnd();

	return result;
}

```

`Lumina/Lumina/hook/vtableHook.h`:

```h
#ifndef vtableHook_h

#define vtableHook_h

#define NOMINMAX

#include "../common/includes.h"

namespace detail {
	class protect_guard {
	public:
		protect_guard(void* base, size_t len, std::uint32_t flags) {
			_base = base;
			_length = len;
			//VirtualProtect(base, len, flags, (PDWORD)&_old);
			LI_FN(VirtualProtect).get()(base, len, flags, (PDWORD)&_old);
		}
		~protect_guard() {
			//VirtualProtect(_base, _length, _old, (PDWORD)&_old);
			LI_FN(VirtualProtect).get()(_base, _length, _old, (PDWORD)&_old);
		}

	private:
		void*         _base;
		size_t        _length;
		std::uint32_t _old;
	};
}

class vmt {
public:
	static inline std::size_t estimate_vftbl_length(std::uintptr_t* vftbl_start);

	void*           class_base;
	std::size_t     vftbl_len;
	std::uintptr_t* new_vftb1;
	std::uintptr_t* old_vftbl;
	LPCVOID         search_base = nullptr;
	bool was_allocated = false;

	uintptr_t * search_free_data_page(const char * module_name, const std::size_t vmt_size);
	vmt();
	vmt(void* base);
	~vmt();

	bool setup(void * base, const char * module_name);

	void hook_index(size_t fn_index, void* fn_pointer);
	void release();

	void* get_original(size_t fn_index);
};

#endif // !vtableHook_h
```

`Lumina/Lumina/main.cpp`:

```cpp
#include "common/includes.h"
#include "common/common.h"
#include "common/events.h"
#include "common/input.h"
#include "sdk/interfaces.h"
#include "ui/menu.h"
#include "ui/render.h"
#include "ui/fgui_/render.hpp"
#include "features/visuals/chams.h"
#include "features/misc/voice.h"
#include "features/visuals/skinchanger.h"
#include "features/visuals/animationfix.h"
#include "ui/sound.h"
#include "features/visuals/world.h"
#include "features/misc/soundEsp.h"
#include "features/misc/voice.h"

bool CheckGame() {

	VMProtectBeginMutation("CheckGame");

	char fileName[MAX_PATH + 1];

	if (!GetModuleFileName(NULL, fileName, MAX_PATH + 1))
		return FALSE;

	const char* sCsgoCiphered = XorStr("csgo.exe");

	bool result = strstr(fileName, sCsgoCiphered);

	VMProtectEnd();

	return result;
}

DWORD WINAPI Start(LPVOID param) {

	VMProtectBeginMutation("Start");

	common::currentModule = (HMODULE)param;

	if (!CheckGame()) {
		common::exit();
		return FALSE;
	}

#ifdef _DEBUG

	LI_FN(AllocConsole).get()();

	freopen_s((FILE**)stdout, XorStr("CONOUT$"), XorStr("w"), stdout);

	common::ps(XorStr("Lumina build : 0.1.13"));

#endif

#ifdef _DEBUG
	common::ps(XorStr("Start : check if all modules are here"));
#endif

	while (!LI_FN(GetModuleHandleA).get()(XorStr("serverbrowser.dll")))
		Sleep(200);

	srand(time(NULL));

	interfaces::init();

	chams::init();

	hook::init();

	config::init();

	sound::init();

	soundEsp::init();

	world::init();

	events::init();

	input::init();

	skinchanger::init();

	animationfix::init();

	//voice::init();

	render::init();

	zguiInit();

	menu::init();

#ifdef _DEBUG
	common::ps(XorStr("Start : everything done"));
#endif

	while (common::active)
		Sleep(200);

#ifdef _DEBUG
	common::ps(XorStr("Start : exiting the cheat"));
#endif 

	VMProtectEnd();

	return FALSE;
}

BOOL WINAPI DllMain(HINSTANCE hinstDLL, DWORD fdwReason, LPVOID lpReserved) {

	VMProtectBeginMutation("DllMain");

	if (fdwReason == DLL_PROCESS_ATTACH)
	{
		DisableThreadLibraryCalls((HMODULE)hinstDLL);

		HANDLE thread = CreateThread(0, 0, Start, hinstDLL, 0, 0);

		CloseHandle(thread);
	}

	VMProtectEnd();

	return TRUE;
}

// crashhandler.dll exports
// same as the original; probably useless

// NOTE FROM 2020 : produce rare crashes because of g_dwDllEntryThreadId

#define EXPORT __declspec(dllexport)

volatile HMODULE hOriginalCrashHandler = NULL;

volatile PVOID pBreakpad_SetSteamID = NULL;
volatile PVOID pCreateInterface = NULL;
volatile PVOID pg_dwDllEntryThreadId = NULL;

int32_t EXPORT Breakpad_SetSteamID(int32_t arg1, int32_t arg2) {

	/*
	if (!hOriginalCrashHandler) {
		hOriginalCrashHandler = LI_FN(LoadLibraryA).get()(XorStr("crashhandler.dex"));
	}

	if (!pBreakpad_SetSteamID) {
		pBreakpad_SetSteamID = LI_FN(GetProcAddress).get()(hOriginalCrashHandler, XorStr("Breakpad_SetSteamID"));
	}

#ifdef _DEBUG
	common::pf(XorStr("Breakpad_SetSteamID : call to %p"), pBreakpad_SetSteamID);
#endif 

	return ((int32_t(*)(int32_t, int32_t))(pBreakpad_SetSteamID))(arg1, arg2);*/

	return 0;
}

int32_t EXPORT CreateInterface(char* arg1, int32_t* arg2) {

	/*
	if (!hOriginalCrashHandler) {
		hOriginalCrashHandler = LI_FN(LoadLibraryA).get()(XorStr("crashhandler.dex"));
	}

	if (!pCreateInterface) {
		pCreateInterface = LI_FN(GetProcAddress).get()(hOriginalCrashHandler, XorStr("CreateInterface"));
	}

#ifdef _DEBUG
	common::pf(XorStr("CreateInterface : call to %p"), pCreateInterface);
#endif 

	return ((int32_t(*)(char*, int32_t*))(pCreateInterface))(arg1, arg2);

	*/

	return 0;
}

void _declspec(naked) EXPORT g_dwDllEntryThreadId() {
	__asm {
		__emit 0x00;
		__emit 0x00;
		__emit 0x00;
		__emit 0x00;
		__emit 0x00;
		__emit 0x00;
		__emit 0x00;
		__emit 0x00;
		__emit 0x00;
		__emit 0x00;
		__emit 0x00;
		__emit 0x00;
		__emit 0x00;
		__emit 0x00;
		__emit 0x00;
		__emit 0x00;
		__emit 0x00;
		__emit 0x00;
	}
}
```

`Lumina/Lumina/resource.h`:

```h
//{{NO_DEPENDENCIES}}
// Microsoft Visual C++ generated include file.
// Used by resource.rc

// Valeurs par défaut suivantes des nouveaux objets
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        101
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1001
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif

```

`Lumina/Lumina/resource.rc`:

```rc
// Microsoft Visual C++ generated resource script.
//
#include "resource.h"

#define APSTUDIO_READONLY_SYMBOLS
/////////////////////////////////////////////////////////////////////////////
//
// Generated from the TEXTINCLUDE 2 resource.
//
#include "winres.h"

/////////////////////////////////////////////////////////////////////////////
#undef APSTUDIO_READONLY_SYMBOLS

/////////////////////////////////////////////////////////////////////////////
// Français (France) resources

#if !defined(AFX_RESOURCE_DLL) || defined(AFX_TARG_FRA)
LANGUAGE LANG_FRENCH, SUBLANG_FRENCH

#ifdef APSTUDIO_INVOKED
/////////////////////////////////////////////////////////////////////////////
//
// TEXTINCLUDE
//

1 TEXTINCLUDE 
BEGIN
    "resource.h\0"
END

2 TEXTINCLUDE 
BEGIN
    "#include ""winres.h""\r\n"
    "\0"
END

3 TEXTINCLUDE 
BEGIN
    "\r\n"
    "\0"
END

#endif    // APSTUDIO_INVOKED


/////////////////////////////////////////////////////////////////////////////
//
// Version
//

VS_VERSION_INFO VERSIONINFO
 FILEVERSION 6,54,98,72
 PRODUCTVERSION 1,0,0,1
 FILEFLAGSMASK 0x3fL
#ifdef _DEBUG
 FILEFLAGS 0x1L
#else
 FILEFLAGS 0x0L
#endif
 FILEOS 0x4L
 FILETYPE 0x2L
 FILESUBTYPE 0x0L
BEGIN
    BLOCK "StringFileInfo"
    BEGIN
        BLOCK "040904b0"
        BEGIN
            VALUE "CompanyName", "Valve Corporation"
            VALUE "FileDescription", "Steam Crash Handler Library"
            VALUE "FileVersion", "6.54.98.72"
            VALUE "InternalName", "crashhandler (buildbot_steam-relclient-win32-builder_steam_rel_client_win32@steam-relclient-win32-builder)"
            VALUE "LegalCopyright", "Copyright (C) 2010"
            VALUE "OriginalFilename", "crashhandler.dll"
            VALUE "ProductName", "Steam Crash Handler Library"
            VALUE "ProductVersion", "01.00.00.01"
        END
    END
    BLOCK "VarFileInfo"
    BEGIN
        VALUE "Translation", 0x409, 1200
    END
END

#endif    // Français (France) resources
/////////////////////////////////////////////////////////////////////////////



#ifndef APSTUDIO_INVOKED
/////////////////////////////////////////////////////////////////////////////
//
// Generated from the TEXTINCLUDE 3 resource.
//


/////////////////////////////////////////////////////////////////////////////
#endif    // not APSTUDIO_INVOKED


```

`Lumina/Lumina/sdk/defines.h`:

```h
#ifndef defines_h

#define defines_h

typedef __int16					int16;
typedef unsigned __int16		uint16;
typedef __int32					int32;
typedef unsigned __int32		uint32;
typedef __int64					int64;
typedef unsigned __int64		uint64;

#define M_PI		(float)3.14159265358979323846f
#define M_RADPI		57.295779513082f
#define RAD2DEG( x  )  ( (float)(x) * (float)(180.f / M_PI) )
#define DEG2RAD( x  )  ( (float)(x) * (float)(M_PI / 180.f) )

#define RandomInt( min, max ) ( rand() % ( max - min + 1 ) + min)
#define RandomFlt( min, max ) ( min + 1 ) + ( ( ( float ) rand() ) / ( float ) RAND_MAX ) * ( max - ( min + 1 ) );

#define FLOAT32_NAN_BITS     (uint32)0x7FC00000	// not a number!
#define FLOAT32_NAN          BitsToFloat( FLOAT32_NAN_BITS )
#define VEC_T_NAN FLOAT32_NAN

#define DECL_ALIGN(x)			__declspec( align( x ) )

#define ALIGN4 DECL_ALIGN(4)
#define ALIGN8 DECL_ALIGN(8)
#define ALIGN16 DECL_ALIGN(16)
#define ALIGN32 DECL_ALIGN(32)
#define ALIGN128 DECL_ALIGN(128)


#define CHECK_VALID( _v ) 0
#define Assert( _exp ) ((void)0)

#define INRANGE( x, a, b )    ( x >= a && x <= b ) 
#define getBits( x )    ( INRANGE( ( x&( ~0x20 ) ),'A','F') ? ( ( x&( ~0x20 ) ) - 'A' + 0xa ) : ( INRANGE( x, '0', '9') ? x - '0' : 0 ) )
#define getByte( x )    ( getBits( x[ 0 ] ) << 4 | getBits( x[ 1 ] ) )

#define tick_interval			( g_pGlobals->interval_per_tick )

#define time_to_ticks( dt )		( (int)( 0.5f + (float)(dt) / tick_interval ) )
#define ticks_to_time( t )		( tick_interval *( t ) )
#define round_to_ticks( t )		( tick_interval * time_to_ticks( t ) )

#define IN_ATTACK				(1 << 0)
#define IN_JUMP					(1 << 1)
#define IN_DUCK					(1 << 2)
#define IN_FORWARD				(1 << 3)
#define IN_BACK					(1 << 4)
#define IN_USE					(1 << 5)
#define IN_CANCEL				(1 << 6)
#define IN_LEFT					(1 << 7)
#define IN_RIGHT				(1 << 8)
#define IN_MOVELEFT				(1 << 9)
#define IN_MOVERIGHT			(1 << 10)
#define IN_ATTACK2				(1 << 11)
#define IN_RUN					(1 << 12)
#define IN_RELOAD				(1 << 13)
#define IN_ALT1					(1 << 14)
#define IN_ALT2					(1 << 15)
#define IN_SCORE				(1 << 16)
#define IN_SPEED				(1 << 17)
#define IN_WALK					(1 << 18)
#define IN_ZOOM					(1 << 19)
#define IN_WEAPON1				(1 << 20)
#define IN_WEAPON2				(1 << 21)
#define IN_BULLRUSH				(1 << 22)

#define	FL_ONGROUND				(1 << 0)	
#define FL_DUCKING				(1 << 1)	
#define	FL_WATERJUMP			(1 << 3)	
#define FL_ONTRAIN				(1 << 4) 
#define FL_INRAIN				(1 << 5)	
#define FL_FROZEN				(1 << 6) 
#define FL_ATCONTROLS			(1 << 7) 
#define	FL_CLIENT				(1 << 8)	
#define FL_FAKECLIENT			(1 << 9)	
#define	FL_INWATER				(1 << 10)

#define TEXTURE_GROUP_LIGHTMAP						_w( "Lightmaps" )
#define TEXTURE_GROUP_WORLD							( "World textures" )
#define TEXTURE_GROUP_MODEL							_w( "Model textures" )
#define TEXTURE_GROUP_VGUI							_w( "VGUI textures" )
#define TEXTURE_GROUP_PARTICLE						_w( "Particle textures" )
#define TEXTURE_GROUP_DECAL							_w( "Decal textures" )
#define TEXTURE_GROUP_SKYBOX						( "SkyBox textures" )
#define TEXTURE_GROUP_CLIENT_EFFECTS				_w( "ClientEffect textures" )
#define TEXTURE_GROUP_OTHER							_w( "Other textures" )
#define TEXTURE_GROUP_PRECACHED						_w( "Precached" )				// TODO: assign texture groups to the precached materials
#define TEXTURE_GROUP_CUBE_MAP						_w( "CubeMap textures" )
#define TEXTURE_GROUP_RENDER_TARGET					_w( "RenderTargets" )
#define TEXTURE_GROUP_UNACCOUNTED					_w( "Unaccounted textures" )	// Textures that weren't assigned a texture group.
//#define TEXTURE_GROUP_STATIC_VERTEX_BUFFER		"Static Vertex"
#define TEXTURE_GROUP_STATIC_INDEX_BUFFER			_w( "Static Indices" )
#define TEXTURE_GROUP_STATIC_VERTEX_BUFFER_DISP		_w( "Displacement Verts" )
#define TEXTURE_GROUP_STATIC_VERTEX_BUFFER_COLOR	_w( "Lighting Verts" )
#define TEXTURE_GROUP_STATIC_VERTEX_BUFFER_WORLD	_w( "World Verts" )
#define TEXTURE_GROUP_STATIC_VERTEX_BUFFER_MODELS	_w( "Model Verts" )
#define TEXTURE_GROUP_STATIC_VERTEX_BUFFER_OTHER	_w( "Other Verts" )
#define TEXTURE_GROUP_DYNAMIC_INDEX_BUFFER			_w( "Dynamic Indices" )
#define TEXTURE_GROUP_DYNAMIC_VERTEX_BUFFER			_w( "Dynamic Verts" )
#define TEXTURE_GROUP_DEPTH_BUFFER					_w( "DepthBuffer" )
#define TEXTURE_GROUP_VIEW_MODEL					_w( "ViewModel" )
#define TEXTURE_GROUP_PIXEL_SHADERS					_w( "Pixel Shaders" )
#define TEXTURE_GROUP_VERTEX_SHADERS				_w( "Vertex Shaders" )
#define TEXTURE_GROUP_RENDER_TARGET_SURFACE			_w( "RenderTarget Surfaces" )
#define TEXTURE_GROUP_MORPH_TARGETS					_w( "Morph Targets" )

#define MAX_AREA_STATE_BYTES		32
#define MAX_AREA_PORTAL_STATE_BYTES 24

#define CHAR_TEX_CONCRETE	'C'			// texture types
#define CHAR_TEX_METAL		'M'
#define CHAR_TEX_DIRT		'D'
#define CHAR_TEX_VENT		'V'
#define CHAR_TEX_GRATE		'G'
#define CHAR_TEX_TILE		'T'
#define CHAR_TEX_SLOSH		'S'
#define CHAR_TEX_WOOD		'W'
#define CHAR_TEX_COMPUTER	'P'
#define CHAR_TEX_GLASS		'Y'
#define CHAR_TEX_FLESH		'F'
#define CHAR_TEX_SNOW		'N'
#define CHAR_TEX_PLASTIC	'L'
#define CHAR_TEX_CARDBOARD	'U'

#define	DAMAGE_NO				0
#define DAMAGE_EVENTS_ONLY		1		// Call damage functions, but don't modify health
#define	DAMAGE_YES				2
#define	DAMAGE_AIM				3

#define	HITGROUP_GENERIC	0
#define	HITGROUP_HEAD		1
#define	HITGROUP_CHEST		2
#define	HITGROUP_STOMACH	3
#define HITGROUP_LEFTARM	4	
#define HITGROUP_RIGHTARM	5
#define HITGROUP_LEFTLEG	6
#define HITGROUP_RIGHTLEG	7
#define HITGROUP_GEAR		10	

#define	HITGROUP_HEAD_FLAG      (1<<0)
#define	HITGROUP_CHEST_FLAG		(1<<1)
#define	HITGROUP_STOMACH_FLAG	(1<<2)
#define HITGROUP_LEFTARM_FLAG	(1<<3)
#define HITGROUP_RIGHTARM_FLAG	(1<<4)
#define HITGROUP_LEFTLEG_FLAG	(1<<5)
#define HITGROUP_RIGHTLEG_FLAG	(1<<6)
#define HITGROUP_ALL_FLAG (1<<7)

// NOTE: These are stored in a short in the engine now.  Don't use more than 16 bits
#define	SURF_LIGHT		0x0001		// value will hold the light strength
#define	SURF_SKY2D		0x0002		// don't draw, indicates we should skylight + draw 2d sky but not draw the 3D skybox
#define	SURF_SKY		0x0004		// don't draw, but add to skybox
#define	SURF_WARP		0x0008		// turbulent water warp
#define	SURF_TRANS		0x0010
#define SURF_NOPORTAL	0x0020	// the surface can not have a portal placed on it
#define	SURF_TRIGGER	0x0040	// FIXME: This is an xbox hack to work around elimination of trigger surfaces, which breaks occluders
#define	SURF_NODRAW		0x0080	// don't bother referencing the texture

#define	SURF_HINT		0x0100	// make a primary bsp splitter

#define	SURF_SKIP		0x0200	// completely ignore, allowing non-closed brushes
#define SURF_NOLIGHT	0x0400	// Don't calculate light
#define SURF_BUMPLIGHT	0x0800	// calculate three lightmaps for the surface for bumpmapping
#define SURF_NOSHADOWS	0x1000	// Don't receive shadows
#define SURF_NODECALS	0x2000	// Don't receive decals
#define SURF_NOPAINT	SURF_NODECALS	// the surface can not have paint placed on it
#define SURF_NOCHOP		0x4000	// Don't subdivide patches on this surface 
#define SURF_HITBOX		0x8000	// surface is part of a hitbox

#define	CONTENTS_EMPTY			0		// No contents

#define	CONTENTS_SOLID			0x1		// an eye is never valid in a solid
#define	CONTENTS_WINDOW			0x2		// translucent, but not watery (glass)
#define	CONTENTS_AUX			0x4
#define	CONTENTS_GRATE			0x8		// alpha-tested "grate" textures.  Bullets/sight pass through, but solids don't
#define	CONTENTS_SLIME			0x10
#define	CONTENTS_WATER			0x20
#define	CONTENTS_BLOCKLOS		0x40	// block AI line of sight
#define CONTENTS_OPAQUE			0x80	// things that cannot be seen through (may be non-solid though)
#define	LAST_VISIBLE_CONTENTS	CONTENTS_OPAQUE

#define ALL_VISIBLE_CONTENTS (LAST_VISIBLE_CONTENTS | (LAST_VISIBLE_CONTENTS-1))

#define CONTENTS_TESTFOGVOLUME	0x100
#define CONTENTS_UNUSED			0x200	

// unused 
// NOTE: If it's visible, grab from the top + update LAST_VISIBLE_CONTENTS
// if not visible, then grab from the bottom.
// CONTENTS_OPAQUE + SURF_NODRAW count as CONTENTS_OPAQUE (shadow-casting toolsblocklight textures)
#define CONTENTS_BLOCKLIGHT		0x400

#define CONTENTS_TEAM1			0x800	// per team contents used to differentiate collisions 
#define CONTENTS_TEAM2			0x1000	// between players and objects on different teams

// ignore CONTENTS_OPAQUE on surfaces that have SURF_NODRAW
#define CONTENTS_IGNORE_NODRAW_OPAQUE	0x2000

// hits entities which are MOVETYPE_PUSH (doors, plats, etc.)
#define CONTENTS_MOVEABLE		0x4000

// remaining contents are non-visible, and don't eat brushes
#define	CONTENTS_AREAPORTAL		0x8000

#define	CONTENTS_PLAYERCLIP		0x10000
#define	CONTENTS_MONSTERCLIP	0x20000

// currents can be added to any other contents, and may be mixed
#define	CONTENTS_CURRENT_0		0x40000
#define	CONTENTS_CURRENT_90		0x80000
#define	CONTENTS_CURRENT_180	0x100000
#define	CONTENTS_CURRENT_270	0x200000
#define	CONTENTS_CURRENT_UP		0x400000
#define	CONTENTS_CURRENT_DOWN	0x800000

#define	CONTENTS_ORIGIN			0x1000000	// removed before bsping an entity

#define	CONTENTS_MONSTER		0x2000000	// should never be on a brush, only in game
#define	CONTENTS_DEBRIS			0x4000000
#define	CONTENTS_DETAIL			0x8000000	// brushes to be added after vis leafs
#define	CONTENTS_TRANSLUCENT	0x10000000	// auto set if any surface has trans
#define	CONTENTS_LADDER			0x20000000
#define CONTENTS_HITBOX			0x40000000	// use accurate hitboxes on trace

#define	MASK_SHOT	(CONTENTS_SOLID|CONTENTS_MOVEABLE|CONTENTS_MONSTER|CONTENTS_WINDOW|CONTENTS_DEBRIS|CONTENTS_HITBOX)

#define	MASK_ALL					(0xFFFFFFFF)
// everything that is normally solid
#define	MASK_SOLID					(CONTENTS_SOLID|CONTENTS_MOVEABLE|CONTENTS_WINDOW|CONTENTS_MONSTER|CONTENTS_GRATE)
// everything that blocks player movement
#define	MASK_PLAYERSOLID			(CONTENTS_SOLID|CONTENTS_MOVEABLE|CONTENTS_PLAYERCLIP|CONTENTS_WINDOW|CONTENTS_MONSTER|CONTENTS_GRATE)
// blocks npc movement
#define	MASK_NPCSOLID				(CONTENTS_SOLID|CONTENTS_MOVEABLE|CONTENTS_MONSTERCLIP|CONTENTS_WINDOW|CONTENTS_MONSTER|CONTENTS_GRATE)
// blocks fluid movement
#define	MASK_NPCFLUID				(CONTENTS_SOLID|CONTENTS_MOVEABLE|CONTENTS_MONSTERCLIP|CONTENTS_WINDOW|CONTENTS_MONSTER)
// water physics in these contents
#define	MASK_WATER					(CONTENTS_WATER|CONTENTS_MOVEABLE|CONTENTS_SLIME)
// everything that blocks lighting
#define	MASK_OPAQUE					(CONTENTS_SOLID|CONTENTS_MOVEABLE|CONTENTS_OPAQUE)
// everything that blocks lighting, but with monsters added.
#define MASK_OPAQUE_AND_NPCS		(MASK_OPAQUE|CONTENTS_MONSTER)
// everything that blocks line of sight for AI
#define MASK_BLOCKLOS				(CONTENTS_SOLID|CONTENTS_MOVEABLE|CONTENTS_BLOCKLOS)
// everything that blocks line of sight for AI plus NPCs
#define MASK_BLOCKLOS_AND_NPCS		(MASK_BLOCKLOS|CONTENTS_MONSTER)
// everything that blocks line of sight for players
#define	MASK_VISIBLE					(MASK_OPAQUE|CONTENTS_IGNORE_NODRAW_OPAQUE)
// everything that blocks line of sight for players, but with monsters added.
#define MASK_VISIBLE_AND_NPCS		(MASK_OPAQUE_AND_NPCS|CONTENTS_IGNORE_NODRAW_OPAQUE)
// bullets see these as solid
#define	MASK_SHOT					(CONTENTS_SOLID|CONTENTS_MOVEABLE|CONTENTS_MONSTER|CONTENTS_WINDOW|CONTENTS_DEBRIS|CONTENTS_HITBOX)
// bullets see these as solid, except monsters (world+brush only)
#define MASK_SHOT_BRUSHONLY			(CONTENTS_SOLID|CONTENTS_MOVEABLE|CONTENTS_WINDOW|CONTENTS_DEBRIS)
// non-raycasted weapons see this as solid (includes grates)
#define MASK_SHOT_HULL				(CONTENTS_SOLID|CONTENTS_MOVEABLE|CONTENTS_MONSTER|CONTENTS_WINDOW|CONTENTS_DEBRIS|CONTENTS_GRATE)
// hits solids (not grates) and passes through everything else
#define MASK_SHOT_PORTAL			(CONTENTS_SOLID|CONTENTS_MOVEABLE|CONTENTS_WINDOW|CONTENTS_MONSTER)
// everything normally solid, except monsters (world+brush only)
#define MASK_SOLID_BRUSHONLY		(CONTENTS_SOLID|CONTENTS_MOVEABLE|CONTENTS_WINDOW|CONTENTS_GRATE)
// everything normally solid for player movement, except monsters (world+brush only)
#define MASK_PLAYERSOLID_BRUSHONLY	(CONTENTS_SOLID|CONTENTS_MOVEABLE|CONTENTS_WINDOW|CONTENTS_PLAYERCLIP|CONTENTS_GRATE)
// everything normally solid for npc movement, except monsters (world+brush only)
#define MASK_NPCSOLID_BRUSHONLY		(CONTENTS_SOLID|CONTENTS_MOVEABLE|CONTENTS_WINDOW|CONTENTS_MONSTERCLIP|CONTENTS_GRATE)
// just the world, used for route rebuilding
#define MASK_NPCWORLDSTATIC			(CONTENTS_SOLID|CONTENTS_WINDOW|CONTENTS_MONSTERCLIP|CONTENTS_GRATE)
// just the world, used for route rebuilding
#define MASK_NPCWORLDSTATIC_FLUID	(CONTENTS_SOLID|CONTENTS_WINDOW|CONTENTS_MONSTERCLIP)
// These are things that can split areaportals
#define MASK_SPLITAREAPORTAL		(CONTENTS_WATER|CONTENTS_SLIME)

// UNDONE: This is untested, any moving water
#define MASK_CURRENT				(CONTENTS_CURRENT_0|CONTENTS_CURRENT_90|CONTENTS_CURRENT_180|CONTENTS_CURRENT_270|CONTENTS_CURRENT_UP|CONTENTS_CURRENT_DOWN)

// everything that blocks corpse movement
// UNDONE: Not used yet / may be deleted
#define	MASK_DEADSOLID				(CONTENTS_SOLID|CONTENTS_PLAYERCLIP|CONTENTS_WINDOW|CONTENTS_GRATE)


#define BONE_USED_MASK				0x0007FF00
#define BONE_USED_BY_ANYTHING		0x0007FF00
#define BONE_USED_BY_HITBOX			0x00000100	// bone (or child) is used by a hit box
#define BONE_USED_BY_ATTACHMENT		0x00000200	// bone (or child) is used by an attachment point
#define BONE_USED_BY_VERTEX_MASK	0x0003FC00
#define BONE_USED_BY_VERTEX_LOD0	0x00000400	// bone (or child) is used by the toplevel model via skinned vertex
#define BONE_USED_BY_VERTEX_LOD1	0x00000800	
#define BONE_USED_BY_VERTEX_LOD2	0x00001000  
#define BONE_USED_BY_VERTEX_LOD3	0x00002000
#define BONE_USED_BY_VERTEX_LOD4	0x00004000
#define BONE_USED_BY_VERTEX_LOD5	0x00008000
#define BONE_USED_BY_VERTEX_LOD6	0x00010000
#define BONE_USED_BY_VERTEX_LOD7	0x00020000
#define BONE_USED_BY_BONE_MERGE		0x00040000	// bone is available for bone merge to occur against it

#define BONE_USED_BY_VERTEX_AT_LOD(lod) ( BONE_USED_BY_VERTEX_LOD0 << (lod) )
#define BONE_USED_BY_ANYTHING_AT_LOD(lod) ( ( BONE_USED_BY_ANYTHING & ~BONE_USED_BY_VERTEX_MASK ) | BONE_USED_BY_VERTEX_AT_LOD(lod) )

#define ATTACHMENT_FLAG_WORLD_ALIGN 0x10000

#define INVALID_EHANDLE_INDEX 0xFFFFFFFF


#define NET_FRAMES_BACKUP 64 // must be power of 2. 
#define NET_FRAMES_MASK ( NET_FRAMES_BACKUP - 1 )

template<class T> const T&
clamp( const T& x, const T& lower, const T& upper ) { return min( upper, max( x, lower ) ); }

inline float BitsToFloat( uint32 i )
{
	union Convertor_t
	{
		float f;
		unsigned long ul;
	}tmp;
	tmp.ul = i;
	return tmp.f;
}

inline float sqrt2( float sqr )
{
	float root = 0;

	__asm
	{
		sqrtss xmm0, sqr
		movss root, xmm0
	}

	return root;
}

#endif // !defines_h
```

`Lumina/Lumina/sdk/interfaces.cpp`:

```cpp
#include "../common/common.h"
#include "interfaces.h"

namespace interfaces {

	IBaseClientDll* baseClientDll = NULL;
	IEngineClient* engineClient = NULL;
	IVRenderView* renderView = NULL;
	IClientEntityList* clientEntityList = NULL;
	IMaterialSystem* materialSystem = NULL;
	IVModelRender* modelRender = NULL;
	IVModelInfo* modelInfo = NULL;
	IVPanel* panel = NULL;
	IConsole* console = NULL;
	ISurface* surface = NULL;
	void* eventManager = NULL;
	void* inputSys = NULL;
	void* mdlCache = NULL;
	void* engineSoundClient = NULL;
	IVDebugOverlay* debugOverlay = NULL;
	C_CSPlayerResource** playerResource = NULL;
	IGlobalVarsBase* globals = NULL;
	IDirect3DDevice9* d3dDevice9 = NULL;
	void* loadFromBufferMaterial = NULL;
	void* initKeyValuesMaterial = NULL;
	ICVar* cvar = NULL;
	IGameEventManager2* gameEventManager = NULL;
	void* voiceRecordStart = NULL;
	void* fileSystem = NULL;
	void* UCS2ToUTF8 = NULL;
	void* itemSchema = NULL;
	ILocalize* localize = NULL;
	forceUpdateFn forceUpdate = NULL;
	CGlowObjectManager* glowManager = NULL;
	hasC4Fn hasC4 = NULL;
	getSequenceActivityFn getSequenceActivity = NULL;
	ClientMode* clientMode = NULL;
	CNetworkStringTableContainer* clientStringTableContainer = NULL;
	ISteamGameServer* steamGameServer = NULL;
	IStudioRender* studioRender = NULL;
	invalidatePhysicsRecursiveFn invalidatePhysicsRecursive = NULL;
	i_client_state* clientState = NULL;
	CHudChat* hudChat = NULL;

	void init() {

		VMProtectBeginMutation("interfaces::init");

		resolveModules();

		fromName();

		fromPattern();

#ifdef _DEBUG
		common::ps(StringHeavy("interfaces::init : done"));
#endif

		VMProtectEnd();
	}

	void erase() {

		/*
		* can't be used due to mutation
		erase_function((uint8_t*)interfaces::init);
		erase_function((uint8_t*)interfaces::resolveModules);
		erase_function((uint8_t*)interfaces::getInterface);
		erase_function((uint8_t*)interfaces::fromName);
		erase_function((uint8_t*)interfaces::fromPattern);
		erase_function((uint8_t*)interfaces::patternToByte);
		erase_function((uint8_t*)interfaces::patternScan);
		erase_function((uint8_t*)interfaces::isValid);
		*/

#ifdef _DEBUG
		common::ps(StringHeavy("interfaces::erase : done"));
#endif
	}

	void resolveModules()
	{
		VMProtectBeginMutation("interfaces::resolveModules");

		RESOLVE_MODULE("client.dll", common::clientModule)
		RESOLVE_MODULE("engine.dll", common::engineModule)
		RESOLVE_MODULE("materialsystem.dll", common::materialsystemModule)
		RESOLVE_MODULE("vguimatsurface.dll", common::vguimatsurfaceModule)
		RESOLVE_MODULE("vstdlib.dll", common::vstdlibModule)
		RESOLVE_MODULE("soundsystem.dll", common::soundsystemModule)
		RESOLVE_MODULE("vgui2.dll", common::vgui2Module)
		RESOLVE_MODULE("datacache.dll", common::datacacheModule)
		RESOLVE_MODULE("shaderapidx9.dll", common::dx9apiModule)
		RESOLVE_MODULE("inputsystem.dll", common::inputSysModule)
		RESOLVE_MODULE("localize.dll", common::localizeModule)
		RESOLVE_MODULE("steam_api.dll", common::steamApiModule)
		RESOLVE_MODULE("studiorender.dll", common::studiorenderModule)

#ifdef _DEBUG
		common::ps(StringHeavy("interfaces::resolveModules : done"));
#endif

		VMProtectEnd();
	}

	void isValid(void* var, const char* name) {

		VMProtectBeginMutation("interfaces::isValid");

		if (var == NULL) {
#ifdef _DEBUG
			common::pf(StringHeavy("interfaces::isValid : %s fail to load"), name);
#endif
			common::exit(); 
		} 

#ifdef _DEBUG
		else {
			common::pf(StringHeavy("interfaces::isValid : %s loaded at 0x%x"), name, var);
		}
#endif
		VMProtectEnd();
	}

	void* getInterfaceAddress(HMODULE hModule, hash32_t fnvInterface)
	{
		// credits : https://www.unknowncheats.me/forum/counterstrike-global-offensive/165359-easy-createinterface.html

		VMProtectBeginMutation("interfaces::getInterfaceAddress");

		void* pCreateInterface = NULL;

		// resolve the CreateInterface function dynamicaly from exports
		RESOLVE_EXPORT(pCreateInterface, CreateInterface, "CreateInterface*", hModule, void*)

		ULONG ShortJump = (ULONG)pCreateInterface + 5; //magic number shit explained above

		ULONG Jump = (((ULONG)pCreateInterface + 5) + *(ULONG*)ShortJump) + 4;

		InterfaceNode* List = **(InterfaceNode***)(Jump + 6);

		do {
			if (List)
			{
				if (FNV1a::get(List->InterfaceName) == fnvInterface)
					return List->Interface();
			}

		} while (List = List->NextInterface);

		VMProtectEnd();

		return 0;
	}

	void fromName()
	{
		VMProtectBeginMutation("interfaces::fromName");

		RESOLVE_INTERFACE(baseClientDll, ("VClient018"), common::clientModule, IBaseClientDll)
		RESOLVE_INTERFACE(engineClient, ("VEngineClient014"), common::engineModule, IEngineClient)
		RESOLVE_INTERFACE(materialSystem, ("VMaterialSystem080"), common::materialsystemModule, IMaterialSystem)
		RESOLVE_INTERFACE(panel, ("VGUI_Panel009"), common::vgui2Module, IVPanel)
		RESOLVE_INTERFACE(surface, ("VGUI_Surface031"), common::vguimatsurfaceModule, ISurface)
		RESOLVE_INTERFACE(clientEntityList, ("VClientEntityList003"), common::clientModule, IClientEntityList)
		RESOLVE_INTERFACE(debugOverlay, ("VDebugOverlay004"), common::engineModule, IVDebugOverlay)
		RESOLVE_INTERFACE(modelInfo, ("VModelInfoClient004"), common::engineModule, IVModelInfo)
		RESOLVE_INTERFACE(modelRender, ("VEngineModel016"), common::engineModule, IVModelRender)
		RESOLVE_INTERFACE(renderView, ("VEngineRenderView014"), common::engineModule, IVRenderView)
		RESOLVE_INTERFACE(cvar, ("VEngineCvar007"), common::vstdlibModule, ICVar)
		RESOLVE_INTERFACE(gameEventManager, ("GAMEEVENTSMANAGER002"), common::engineModule, IGameEventManager2)
		RESOLVE_INTERFACE(localize, ("Localize_001"), common::localizeModule, ILocalize)
		RESOLVE_INTERFACE(console, ("VEngineCvar007"), common::vstdlibModule, IConsole)
		RESOLVE_INTERFACE(clientStringTableContainer, ("VEngineClientStringTable001"), common::engineModule, CNetworkStringTableContainer)
		RESOLVE_INTERFACE(studioRender, ("VStudioRender026"), common::studiorenderModule, IStudioRender)
		RESOLVE_INTERFACE(mdlCache, ("MDLCache004"), common::datacacheModule, void)

#ifdef _DEBUG
			common::ps(StringHeavy("interfaces::fromName : done"));
#endif
			VMProtectEnd();
	}

	void fromPattern()
	{
		VMProtectBeginMutation("interfaces::fromPattern");

		RESOLVE_PATTERN(d3dDevice9, **(IDirect3DDevice9 ***), common::dx9apiModule, "A1 ? ? ? ? 50 8B 08 FF 51 0C", 1)
		RESOLVE_PATTERN(playerResource, *(C_CSPlayerResource ***), common::clientModule, "A1 ? ? ? ? 57 85 C0 74 08", 1)
		RESOLVE_PATTERN(loadFromBufferMaterial, (void*), common::clientModule, "55 8B EC 83 E4 F8 83 EC 34 53 8B 5D 0C 89 4C 24 04", 0)
		RESOLVE_PATTERN(initKeyValuesMaterial, (void*), common::clientModule, "55 8B EC 51 33 C0 C7 45", 0)
		RESOLVE_PATTERN(voiceRecordStart, (void*), common::engineModule, "55 8B EC 83 EC 0C 83 3D ? ? ? ? ? 56 57", 0)
		RESOLVE_PATTERN(fileSystem, **(void***), common::engineModule, "8B 0D ? ? ? ? 8D 95 ? ? ? ? 6A 00 C6", 2)
		RESOLVE_PATTERN(itemSchema, (void*), common::clientModule, "E8 ? ? ? ? FF 76 0C 8D 48 04 E8", 0)
		RESOLVE_PATTERN(forceUpdate, (forceUpdateFn), common::engineModule, "A1 ? ? ? ? B9 ? ? ? ? 56 FF 50 14 8B 34 85", 0)
		RESOLVE_PATTERN(glowManager, *(CGlowObjectManager**), common::clientModule, "0F 11 05 ? ? ? ? 83 C8 01 C7 05 ? ? ? ? 00 00 00 00", 3)
		RESOLVE_PATTERN(hasC4, hasC4Fn, common::clientModule, "56 8B F1 85 F6 74 31", 0)
		RESOLVE_PATTERN(invalidatePhysicsRecursive, invalidatePhysicsRecursiveFn, common::clientModule, "55 8B EC 83 E4 F8 83 EC 0C 53 8B 5D 08 8B C3 56 83 E0 04", 0)
		RESOLVE_PATTERN(getSequenceActivity, getSequenceActivityFn, common::clientModule, "55 8B EC 53 8B 5D 08 56 8B F1 83", 0)
		RESOLVE_PATTERN(clientState, **(i_client_state***), common::engineModule, "A1 ? ? ? ? 8B 80 ? ? ? ? C3", 1)

		// from export 

		RESOLVE_EXPORT(UCS2ToUTF8, V_UCS2ToUTF8, "UCS2ToUTF8*", common::vstdlibModule, int(*)(const wchar_t* ucs2, char* utf8, int len))

		// from offsets

		globals = **reinterpret_cast<IGlobalVarsBase***>((*reinterpret_cast<uintptr_t**>(baseClientDll)[0] + 0x1F));	
		isValid(globals, StringHeavy("**IGlobalVarsBase***"));

		clientMode = **reinterpret_cast<ClientMode***>((*reinterpret_cast<uintptr_t**>(baseClientDll))[10] + 5);
		isValid(clientMode, StringHeavy("**ClientMode***"));

		//D3DDevice9 = **(IDirect3DDevice9 ***)(patternScan((HMODULE)dx9api, StringHeavy("A1 ? ? ? ? 50 8B 08 FF 51 0C")) + 1);

		hudChat = (CHudChat*)FindHudElement<CHudChat>(XorStr("CHudChat"));

#ifdef _DEBUG
		common::ps(StringHeavy("interfaces::fromPattern : done"));
#endif

		VMProtectEnd();
	}


	template<class T>
	static T* FindHudElement(const char* name)
	{
		static auto pThis = *reinterpret_cast<DWORD**>(patternScan(common::clientModule, XorStr("B9 ? ? ? ? E8 ? ? ? ? 8B 5D 08")) + 1);

		static auto find_hud_element = reinterpret_cast<DWORD(__thiscall*)(void*, const char*)>(patternScan(common::clientModule, XorStr("55 8B EC 53 8B 5D 08 56 57 8B F9 33 F6 39 77 28")));

		return (T*)find_hud_element(pThis, name);
	}

	std::vector<int> patternToByte(const char* pattern) {

		auto bytes = std::vector<int>{};

		VMProtectBeginMutation("interfaces::patternToByte");

		auto start = const_cast<char*>(pattern);
		auto end = const_cast<char*>(pattern) + strlen(pattern);

		for (auto current = start; current < end; ++current) {
			if (*current == '?') {
				++current;
				if (*current == '?')
					++current;
				bytes.push_back(-1);
			}
			else {
				bytes.push_back(strtoul(current, &current, 16));
			}
		}

		VMProtectEnd();

		return bytes;
	}

	std::uint8_t* patternScan(void* module, const char* signature) {

		VMProtectBeginMutation("interfaces::patternScan");

		auto dos_headers = reinterpret_cast<PIMAGE_DOS_HEADER>(module);
		auto nt_headers = reinterpret_cast<PIMAGE_NT_HEADERS>((std::uint8_t*)module + dos_headers->e_lfanew);

		auto size_of_image = nt_headers->OptionalHeader.SizeOfImage;
		auto pattern_bytes = patternToByte(signature);
		auto scan_bytes = reinterpret_cast<std::uint8_t*>(module);

		auto s = pattern_bytes.size();
		auto d = pattern_bytes.data();

		for (auto i = 0ul; i < size_of_image - s; ++i) {
			bool found = true;
			for (auto j = 0ul; j < s; ++j) {
				if (scan_bytes[i + j] != d[j] && d[j] != -1) {
					found = false;
					break;
				}
			}
			if (found) {
				return &scan_bytes[i];
			}
		}

		VMProtectEnd();

		return nullptr;
	}
}

```

`Lumina/Lumina/sdk/interfaces.h`:

```h
#ifndef interfaces_h

#define interfaces_h

#include "../common/includes.h"

#define RESOLVE_MODULE(NAME, VAR) VAR = (HMODULE)LI_MODULE(NAME).cached(); \
	isValid(VAR, StringHeavy(NAME)); \

#define RESOLVE_INTERFACE(VAR, NAME, MODULE, TYPE) VAR = reinterpret_cast<TYPE*>(getInterfaceAddress(MODULE, HASH(NAME))); \
	isValid(VAR, StringHeavy(NAME)); \

#define RESOLVE_PATTERN(VAR, CAST, MODULE, _PATTERN, PADDING) VAR = CAST(patternScan(MODULE, StringHeavy(_PATTERN)) + PADDING); \
	isValid(VAR, StringHeavy(_PATTERN)); \

#define RESOLVE_EXPORT(VAR, NAME, NAME_STR, MODULE, CAST) void(*NAME); \
	VAR = (CAST)(LI_FN(NAME).in(MODULE));\
	isValid(VAR, StringHeavy(NAME_STR)); \

class ClientMode {};

struct InterfaceNode
{
	void* (*Interface)(); //0x0000
	char* InterfaceName; //0x0004 
	InterfaceNode* NextInterface; //0x0008 
};

class CHudChat
{
public:
	enum ChatFilters
	{
		CHAT_FILTER_NONE = 0,
		CHAT_FILTER_JOINLEAVE = 0x000001,
		CHAT_FILTER_NAMECHANGE = 0x000002,
		CHAT_FILTER_PUBLICCHAT = 0x000004,
		CHAT_FILTER_SERVERMSG = 0x000008,
		CHAT_FILTER_TEAMCHANGE = 0x000010,

		//=============================================================================
		// HPE_BEGIN:
		// [tj]Added a filter for achievement announce
		//=============================================================================

		CHAT_FILTER_ACHIEVEMENT = 0x000020,

		//=============================================================================
		// HPE_END
		//=============================================================================
	};

	void ChatPrintf(int iPlayerIndex, int iFilter, const char* fmt, ...)
	{
		using original_fn = void(__cdecl*)(void*, int, int, const char*, ...);
		return (*(original_fn**)this)[27](this, iPlayerIndex, iFilter, fmt);
	}
};


enum InvalidatePhysicsBits_t : int {
	POSITION_CHANGED = 0x1,
	ANGLES_CHANGED = 0x2,
	VELOCITY_CHANGED = 0x4,
	ANIMATION_CHANGED = 0x8,
	BOUNDS_CHANGED = 0x10,
	SEQUENCE_CHANGED = 0x20
};

namespace interfaces {

	using invalidatePhysicsRecursiveFn = void(__thiscall*)(void*, InvalidatePhysicsBits_t);
	using forceUpdateFn = void(__cdecl*)();
	using hasC4Fn = bool(__thiscall*)(void*);
	using getSequenceActivityFn = int(__fastcall*)(void*, studiohdr_t*, int);

	extern IBaseClientDll* baseClientDll;
	extern IEngineClient* engineClient;
	extern IVRenderView* renderView;
	extern IClientEntityList* clientEntityList;
	extern IMaterialSystem* materialSystem;
	extern IVModelRender* modelRender;
	extern IVModelInfo* modelInfo;
	extern IVPanel* panel;
	extern IConsole* console;
	extern ISurface* surface;
	extern void* eventManager;
	extern void* inputSys;
	extern void* mdlCache;
	extern void* engineSoundClient;
	extern IGlobalVarsBase* globals;
	extern IDirect3DDevice9* d3dDevice9;
	extern IVDebugOverlay* debugOverlay;
	extern C_CSPlayerResource** playerResource;
	extern void* loadFromBufferMaterial;
	extern void* initKeyValuesMaterial;
	extern ICVar* cvar;
	extern void* voiceRecordStart;
	extern IGameEventManager2* gameEventManager;
	extern void* fileSystem;
	extern void* UCS2ToUTF8;
	extern void* itemSchema;
	extern ILocalize* localize;
	extern forceUpdateFn forceUpdate;
	extern CGlowObjectManager* glowManager;
	extern hasC4Fn hasC4;
	extern invalidatePhysicsRecursiveFn invalidatePhysicsRecursive;
	extern ClientMode* clientMode;
	extern getSequenceActivityFn getSequenceActivity;
	extern CNetworkStringTableContainer* clientStringTableContainer;
	extern ISteamGameServer* steamGameServer;
	extern IStudioRender* studioRender;
	extern i_client_state* clientState;
	extern CHudChat* hudChat;

	void init();
	void* getExport(const char* module_name, const char* export_name);
	void resolveModules();
	void fromName();
	void fromPattern();
	void erase();
	void isValid(void* var, const char* name);
	//void* getInterface(HMODULE module, const char* name);
	void* getInterfaceAddress(HMODULE hModule, hash32_t fnvInterface);
	std::vector<int> patternToByte(const char* pattern);
	std::uint8_t* patternScan(void* module, const char* signature);
	void setupSteamInterfaces();
	void* getExport(HMODULE module, const char* export_name);

	template<class T>
	static T* FindHudElement(const char* name);
}

#endif
```

`Lumina/Lumina/sdk/interfaces/CGlowObjectManager.cpp`:

```cpp
/*
#include "../..\include_cheat.h"

bool is_grenade( const int id )
{
	return id == ClassId_CDecoyGrenade || id == ClassId_CHEGrenade || id == ClassId_CIncendiaryGrenade || id == ClassId_CMolotovGrenade || id == ClassId_CSmokeGrenade || id == ClassId_CFlashbang || id == ClassId_CDecoyProjectile || id == ClassId_CBaseCSGrenadeProjectile || id == ClassId_CMolotovProjectile || id == ClassId_CSmokeGrenadeProjectile || id == ClassId_CFlashbang;
}

bool is_weapon( const int id )
{
	return id >= ClassId_CWeaponAug && id <= ClassId_CWeaponXM1014 || id == ClassId_CAK47 || id == ClassId_CDEagle;
}

void CGlowObjectManager::RenderGlowEffects()
{
	const auto player_glow = [ & ]( const int idx )
	{
		const auto classid = m_glObjectDefinitions[ idx ].m_pEntity->GetClientClass()->m_ClassID;
		if ( classid != ClassId_CCSPlayer)
			return;

		auto player = reinterpret_cast< C_BasePlayer* >( m_glObjectDefinitions[ idx ].m_pEntity );

		if ( !vars::visuals.glow.local.enabled.get<bool>() && player == g_pLocalPlayer )
			return;
		if ( !vars::visuals.glow.enemy.enabled.get<bool>() && player->is_enemy() )
			return;
		if ( !vars::visuals.glow.team.enabled.get<bool>() && !player->is_enemy() && player != g_pLocalPlayer )
			return;

		Color col;

		if ( player == g_pLocalPlayer )
			col = get_col( vars::visuals.glow.local.color.get<uintptr_t>() );
		else if ( player->is_enemy() )
			col = get_col( vars::visuals.glow.enemy.color.get<uintptr_t>() );
		else
			col = get_col( vars::visuals.glow.team.color.get<uintptr_t>() );

		const Vector color( col.rBase(), col.gBase(), col.bBase() );

		auto player_alpha = visuals::get().get_players()[ player->EntIndex() ].alpha / 255.f;

		auto alpha = ( !player->is_enemy() || player == g_pLocalPlayer ) ? col.aBase() : player_alpha * col.aBase();

		m_glObjectDefinitions[ idx ].m_vGlowColor = color;
		m_glObjectDefinitions[ idx ].m_flGlowAlpha = alpha;
		m_glObjectDefinitions[ idx ].m_bRenderWhenOccluded = true;
		m_glObjectDefinitions[ idx ].m_bRenderWhenUnoccluded = false;
		m_glObjectDefinitions[ idx ].m_flBloomAmount = 0.8f;
	};

	const auto weapon_glow = [ & ]( const int idx )
	{
		const auto classid = m_glObjectDefinitions[ idx ].m_pEntity->GetClientClass()->m_ClassID;
		if ( !is_weapon( classid ) )
			return;

		if ( m_glObjectDefinitions[ idx ].m_pEntity->get_owner_ent() != -1 )
			return;

		if ( !vars::visuals.glow.world.weapons.get<bool>() )
			return;

		auto col = get_col( vars::visuals.glow.world.color.get<uintptr_t>() );
		const Vector color( col.rBase(), col.gBase(), col.bBase() );

		m_glObjectDefinitions[ idx ].m_vGlowColor = color;
		m_glObjectDefinitions[ idx ].m_flGlowAlpha = col.aBase();
		m_glObjectDefinitions[ idx ].m_bRenderWhenOccluded = true;
		m_glObjectDefinitions[ idx ].m_bRenderWhenUnoccluded = false;
		m_glObjectDefinitions[ idx ].m_flBloomAmount = 0.8f;
	};

	const auto grenade_glow = [ & ]( const int idx )
	{
		const auto classid = m_glObjectDefinitions[ idx ].m_pEntity->GetClientClass()->m_ClassID;
		if ( !is_grenade( classid ) )
			return;

		if ( !vars::visuals.glow.world.grenades.get<bool>() )
			return;

		auto col = get_col( vars::visuals.glow.world.color.get<uintptr_t>() );
		const Vector color( col.rBase(), col.gBase(), col.bBase() );

		m_glObjectDefinitions[ idx ].m_vGlowColor = color;
		m_glObjectDefinitions[ idx ].m_flGlowAlpha = col.aBase();
		m_glObjectDefinitions[ idx ].m_bRenderWhenOccluded = true;
		m_glObjectDefinitions[ idx ].m_bRenderWhenUnoccluded = false;
		m_glObjectDefinitions[ idx ].m_flBloomAmount = 0.8f;
	};

	const auto c4_glow = [ & ]( const int idx )
	{
		const auto classid = m_glObjectDefinitions[ idx ].m_pEntity->GetClientClass()->m_ClassID;
		if ( classid != ClassId_CC4 && classid != ClassId_CPlantedC4 )
			return;

		if ( !vars::visuals.glow.world.c4.get<bool>() )
			return;

		auto c4 = reinterpret_cast< C_PlantedC4* >( m_glObjectDefinitions[ idx ].m_pEntity );
		auto defusing = c4->get_defuser() != -1 || c4->get_defused();

		auto col = get_col( vars::visuals.glow.world.color.get<uintptr_t>() );
		if ( classid == ClassId_CPlantedC4 )col = Color::Red();
		if ( defusing )col = Color::LightBlue();
		const Vector color( col.rBase(), col.gBase(), col.bBase() );

		m_glObjectDefinitions[ idx ].m_vGlowColor = color;
		m_glObjectDefinitions[ idx ].m_flGlowAlpha = col.aBase();
		m_glObjectDefinitions[ idx ].m_bRenderWhenOccluded = true;
		m_glObjectDefinitions[ idx ].m_bRenderWhenUnoccluded = false;
		m_glObjectDefinitions[ idx ].m_flBloomAmount = 0.8f;
	};

	for ( int i = 0; i < m_glObjectDefinitions.Count(); i++ )
	{
		if ( m_glObjectDefinitions[ i ].IsUnused() || !m_glObjectDefinitions[ i ].m_pEntity )
			continue;

		player_glow( i );

		weapon_glow( i );

		grenade_glow( i );

		c4_glow( i );
	}
}*/

```

`Lumina/Lumina/sdk/interfaces/CGlowObjectManager.h`:

```h
#pragma once

class CGlowObjectManager
{
public:
	class GlowObjectDefinition_t
	{
	public:
		bool ShouldDraw() const { return m_pEntity && ( m_bRenderWhenOccluded || m_bRenderWhenUnoccluded ); }
		bool IsUnused() const { return m_nNextFreeSlot != GlowObjectDefinition_t::ENTRY_IN_USE; }

		void*	m_pEntity;
		Vector          m_vGlowColor;
		float           m_flGlowAlpha;

		char			unknown[ 4 ];
		float           flUnk;
		float           m_flBloomAmount;
		float           localplayeriszeropoint3;
		bool            m_bRenderWhenOccluded;
		bool            m_bRenderWhenUnoccluded;
		bool            m_bFullBloomRender;
		char            unknown1[ 1 ];
		int             m_nFullBloomStencilTestValue; // 0x28 only render full bloom objects if stencil is equal to this value (value of -1 implies no stencil test)
		int             iUnk; //appears like it needs to be zero  
		int             m_nSplitScreenSlot; //Should be -1 
											// Linked list of free slots 
		int             m_nNextFreeSlot;
		// Special values for GlowObjectDefinition_t::m_nNextFreeSlot 
		static const int END_OF_FREE_LIST = -1;
		static const int ENTRY_IN_USE = -2;
	};

	//CUtlVector< GlowObjectDefinition_t > m_glObjectDefinitions;
	//int m_nFirstFreeSlot;
	GlowObjectDefinition_t *m_glObjectDefinitions;
	char pad[8];
	int size;
};

struct ShaderStencilState_t
{
	bool m_bEnable;
	StencilOperation_t m_FailOp;
	StencilOperation_t m_ZFailOp;
	StencilOperation_t m_PassOp;
	StencilComparisonFunction_t m_CompareFunc;
	int m_nReferenceValue;
	uint32 m_nTestMask;
	uint32 m_nWriteMask;

	ShaderStencilState_t()
	{
		m_bEnable = false;
		m_PassOp = m_FailOp = m_ZFailOp = STENCILOPERATION_KEEP;
		m_CompareFunc = STENCILCOMPARISONFUNCTION_ALWAYS;
		m_nReferenceValue = 0;
		m_nTestMask = m_nWriteMask = 0xFFFFFFFF;
	}
};

extern CGlowObjectManager* g_pGlowObjectManager;
```

`Lumina/Lumina/sdk/interfaces/CHud.h`:

```h
#pragma once

/*
class CHud
{
public:
	MFUNC( FindElement( const char* name ), void*( __thiscall * )( void*, const char* ), offsets::find_element )( name )
};

extern CHud* g_pHud;*/
```

`Lumina/Lumina/sdk/interfaces/CSPlayerResource.h`:

```h
#pragma once

#ifndef csplayerresource_h

#define csplayerresource_h

#include "../netvars.h"

class Color;

class C_CSPlayerResource
{
public:
	OFFSET(int, get_c4_player, 0x161C)

	OFFSETRS( get_ping, int, 0x0AE4 )

};

//extern C_CSPlayerResource** g_ppPlayerResource;

#endif
```

`Lumina/Lumina/sdk/interfaces/IBaseClientDll.h`:

```h
#pragma once

class ClientClass;
class IBaseClientDll
{
public:
	VFUNC( 4, Shutdown(), void(__thiscall*)(void*))()
	VFUNC( 8, GetAllClasses(), ClientClass*( __thiscall* )( void* ) )( )
	VFUNC( 20, IN_KeyEvent( int eventcode, int keynum, const char *pszCurrentBinding ), void( __thiscall* )( void*, int, int, const char* ) )( eventcode, keynum, pszCurrentBinding )
	VFUNC( 21, CreateMove( int sequence_number, float frametime, bool active ), void( __thiscall* )( void*, int, float, bool ) )( sequence_number, frametime, active )
};

extern IBaseClientDll* g_pClient;
```

`Lumina/Lumina/sdk/interfaces/ICVar.h`:

```h
#pragma once

class IAppSystem2
{
public:
	virtual void func0() = 0;
	virtual void func1() = 0;
	virtual void func2() = 0;
	virtual void func3() = 0;
	virtual void func4() = 0;
	virtual void func5() = 0;
	virtual void func6() = 0;
	virtual void func7() = 0;
	virtual void func8() = 0;
	virtual void func9() = 0;
};

struct CVarDLLIdentifier_t;

class ICVar : public IAppSystem2
{
public:
	virtual void			func10() = 0;
	virtual void			RegisterConCommand( ConVar *pCommandBase ) = 0;
	virtual void			UnregisterConCommand( ConVar *pCommandBase ) = 0;
	virtual void			func13() = 0;
	virtual ConVar			*FindVar( const char *var_name ) = 0;

	/*
	template <typename... Values>
	void ConsoleColorPrintf( const Color& MsgColor, const char* szMsgFormat, Values... Parameters )
	{
		typedef void( *oConsoleColorPrintf )( void*, const Color&, const char*, ... );
		return util::get_vfunc<oConsoleColorPrintf>( this, 25 )( this, MsgColor, szMsgFormat, Parameters... );
	}*/
};

extern ICVar* g_pCVar;
```

`Lumina/Lumina/sdk/interfaces/IClientEntityList.h`:

```h
#pragma once

class IClientEntity;
class IClientUnknown;
class IClientNetworkable;
using CBaseHandle = unsigned long;
class IClientEntityList
{
public:
	virtual IClientNetworkable* GetClientNetworkable( int iEnt ) = 0;
	virtual IClientNetworkable* GetClientNetworkableFromHandle( CBaseHandle hEnt ) = 0;
	virtual IClientUnknown* GetClientUnknownFromHandle( CBaseHandle hEnt ) = 0;
	virtual IClientEntity* GetClientEntity( int iEnt ) = 0;
	virtual IClientEntity* GetClientEntityFromHandle( CBaseHandle hEnt ) = 0;
	virtual int NumberOfEntities( bool bIncludeNonNetworkable ) = 0;
	virtual int GetHighestEntityIndex() = 0;
	virtual void SetMaxEntities( int iMax ) = 0;
	virtual int GetMaxEntities() = 0;
};

extern IClientEntityList* g_pEntitiyList;
```

`Lumina/Lumina/sdk/interfaces/IClientModeShared.h`:

```h
#pragma once

class CBaseHudChat
{
public:
	VFUNC( 26, ChatPrintf( int idx, int filter, const char* fmt, ... ), void( __cdecl* )( void*, int, int, const char*, ... ) )( idx, filter, fmt )
};

class IClientModeShared
{
public:
	char pad[ 28 ];
	CBaseHudChat			*m_pChatElement;
};

extern IClientModeShared* g_pClientMode;
```

`Lumina/Lumina/sdk/interfaces/IClientState.h`:

```h
#pragma once

class INetChannel;
class INetMessage
{
public:
	virtual	~INetMessage() {};

	// Use these to setup who can hear whose voice.
	// Pass in client indices (which are their ent indices - 1).

	virtual void	SetNetChannel( INetChannel * netchan ) = 0; // netchannel this message is from/for
	virtual void	SetReliable( bool state ) = 0;	// set to true if it's a reliable message

	virtual bool	Process( void ) = 0; // calles the recently set handler to process this message

	virtual	bool	ReadFromBuffer( bf_read &buffer ) = 0; // returns true if parsing was OK
	virtual	bool	WriteToBuffer( void* buffer ) = 0;	// returns true if writing was OK

	virtual bool	IsReliable( void ) const = 0;  // true, if message needs reliable handling

	virtual int				GetType( void ) const = 0; // returns module specific header tag eg svc_serverinfo
	virtual int				GetGroup( void ) const = 0;	// returns net message group of this message
	virtual const char		*GetName( void ) const = 0;	// returns network message name, eg "svc_serverinfo"
	virtual INetChannel		*GetNetChannel( void ) const = 0;
	virtual const char		*ToString( void ) const = 0; // returns a human readable string about message content
};



class CClockDriftMgr
{
public:
	float m_ClockOffsets[ 17 ];   //0x0000
	uint32_t m_iCurClockOffset; //0x0044
	uint32_t m_nServerTick;     //0x0048
	uint32_t m_nClientTick;     //0x004C
}; //Size: 0x0050

class IClientState
{
public:
	void ForceFullUpdate()
	{
		m_nDeltaTick = -1;
	};

	char pad_0000[ 0x9C ];             //0x0000
	CNetChannel* m_NetChannel;          //0x009C
	uint32_t m_nChallengeNr;        //0x00A0
	char pad_00A4[ 0x64 ];             //0x00A4
	uint32_t m_nSignonState;        //0x0108
	char pad_010C[ 0x8 ];               //0x010C
	float m_flNextCmdTime;          //0x0114
	uint32_t m_nServerCount;        //0x0118
	uint32_t m_nCurrentSequence;    //0x011C
	char pad_0120[ 4 ];               //0x0120
	CClockDriftMgr m_ClockDriftMgr; //0x0128
	uint32_t m_nDeltaTick;          //0x0178
	bool m_bPaused;                 //0x017C
	char pad_017D[ 7 ];               //0x017D
	uint32_t m_nViewEntity;         //0x0180
	uint32_t m_nPlayerSlot;         //0x0184
	char m_szLevelName[ 260 ];        //0x0188
	char m_szLevelNameShort[ 80 ];    //0x028C
	char m_szGroupName[ 80 ];         //0x02B4
	char pad_02DC[ 92 ];              //0x02DC
	uint32_t m_nMaxClients;         //0x0310
	char pad_0314[ 18820 ];           //0x0314
	float m_flLastServerTickTime;   //0x4C98
	bool insimulation;              //0x4C9C
	char pad_4C9D[ 3 ];               //0x4C9D
	uint32_t oldtickcount;          //0x4CA0
	float m_tickRemainder;          //0x4CA4
	float m_frameTime;              //0x4CA8
	uint32_t m_nLastOutgoingCommand;   //0x4CAC
	uint32_t m_nChokedCommands;        //0x4CB0
	uint32_t m_nLastCommandAck;      //0x4CB4
	uint32_t m_nCommandAck;           //0x4CB8
	uint32_t m_nSoundSequence;      //0x4CBC
	char pad_4CC0[ 80 ];              //0x4CC0
	Vector viewangles;              //0x4D10
	char pad_4D14[ 0xD0 ];          //0x4D1C
	CEventInfo* m_Events;           //0x4DEC
}; 

extern IClientState* g_pClientState;
```

`Lumina/Lumina/sdk/interfaces/IConsole.h`:

```h
#ifndef console_h

#define console_h

class i_app_system {
public:
	virtual bool connect(void* factory) = 0;
	virtual void disconnect() = 0;
	virtual void* query_interface(const char *pInterfaceName) = 0;
	virtual int init() = 0;
	virtual void shutdown() = 0;
	virtual const void* get_dependencies() = 0;
	virtual int  get_tier() = 0;
	virtual void reconnect(void* factory, const char *pInterfaceName) = 0;
	virtual void unknown() = 0;
};

class con_command;
class con_command_base;

typedef int cvar_dll_indentifier_t;

class IConsole : public i_app_system {
public:
	virtual cvar_dll_indentifier_t allocate_dll_indentifier() = 0;
	virtual void register_con_command(con_command_base *pCommandBase) = 0;
	virtual void unregister_con_command(con_command_base *pCommandBase) = 0;
	virtual void unregister_con_commands(cvar_dll_indentifier_t id) = 0;
	virtual const char* get_command_line_value(const char *pVariableName) = 0;
	virtual con_command_base* find_command_base(const char *name) = 0;
	virtual const con_command_base* find_command_base(const char *name) const = 0;
	virtual void* get_convar(const char *var_name) = 0;
	virtual const void* get_convar(const char *var_name) const = 0;
};

#endif // !console
```

`Lumina/Lumina/sdk/interfaces/IEngineClient.h`:

```h
#pragma once

class IEngineSound
{
public:
	// Precache a particular sample
	virtual bool PrecacheSound( const char *pSample, bool bPreload = false, bool bIsUISound = false ) = 0;
	virtual bool IsSoundPrecached( const char *pSample ) = 0;
};

extern IEngineSound* g_pEngineSound;

typedef struct InputContextHandle_t__ *InputContextHandle_t;
struct client_textmessage_t;
struct model_t;
class SurfInfo;
class IMaterial;
class CSentence;
class CAudioSource;
class AudioState_t;
class ISpatialQuery;
class IMaterialSystem;
class CPhysCollide;
class IAchievementMgr;
class INetChannelInfo;
class ISPSharedMemory;
class CGamestatsData;
class CSteamAPIContext;
struct Frustum_t;
class pfnDemoCustomDataCallback;

class IEngineClient
{
public:
	virtual int                   GetIntersectingSurfaces( const model_t *model, const Vector &vCenter, const float radius, const bool bOnlyVisibleSurfaces, SurfInfo *pInfos, const int nMaxInfos ) = 0;
	virtual Vector                GetLightForPoint( const Vector &pos, bool bClamp ) = 0;
	virtual IMaterial*            TraceLineMaterialAndLighting( const Vector &start, const Vector &end, Vector &diffuseLightColor, Vector& baseColor ) = 0;
	virtual const char*           ParseFile( const char *data, char *token, int maxlen ) = 0;
	virtual bool                  CopyFile( const char *source, const char *destination ) = 0;
	virtual void                  GetScreenSize( int& width, int& height ) = 0;
	virtual void                  ServerCmd( const char *szCmdString, bool bReliable = true ) = 0;
	virtual void                  ClientCmd( const char *szCmdString ) = 0;
	virtual bool                  GetPlayerInfo( int ent_num, player_info_t *pinfo ) = 0;
	virtual int                   GetPlayerForUserID( int userID ) = 0;
	virtual client_textmessage_t* TextMessageGet( const char *pName ) = 0; // 10
	virtual bool                  Con_BoneIsVisible( void ) = 0;
	virtual int                   GetLocalPlayer( void ) = 0;
	virtual const model_t*        LoadModel( const char *pName, bool bProp = false ) = 0;
	virtual float                 GetLastTimeStamp( void ) = 0;
	virtual CSentence*            GetSentence( CAudioSource *pAudioSource ) = 0; // 15
	virtual float                 GetSentenceLength( CAudioSource *pAudioSource ) = 0;
	virtual bool                  IsStreaming( CAudioSource *pAudioSource ) const = 0;
	virtual void                  GetViewAngles( QAngle& va ) = 0;
	virtual void                  SetViewAngles( QAngle& va ) = 0;
	virtual int                   GetMaxClients( void ) = 0; // 20
	virtual   const char*         k_LookupBinding( const char *pBinding ) = 0;
	virtual const char*           k_BindingForKey( int &code ) = 0;
	virtual void                  k_SetBinding( int, char const* ) = 0;
	virtual void                  StartKeyTrapMode( void ) = 0;
	virtual bool                  CheckDoneKeyTrapping( int &code ) = 0;
	virtual bool                  IsInGame( void ) = 0;
	virtual bool                  IsConnected( void ) = 0;
	virtual bool                  IsDrawingLoadingImage( void ) = 0;
	virtual void                  HideLoadingPlaque( void ) = 0;
	virtual void                  Con_NPrintf( int pos, const char *fmt, ... ) = 0; // 30
	virtual void                  Con_NXPrintf( const struct con_nprint_s *info, const char *fmt, ... ) = 0;
	virtual int                   IsBoxVisible( const Vector& mins, const Vector& maxs ) = 0;
	virtual int                   IsBoxInViewCluster( const Vector& mins, const Vector& maxs ) = 0;
	virtual bool                  CullBox( const Vector& mins, const Vector& maxs ) = 0;
	virtual void                  Sound_ExtraUpdate( void ) = 0;
	virtual const char*           GetGameDirectory( void ) = 0;
	virtual const VMatrix&        WorldToScreenMatrix() = 0;
	virtual const VMatrix&        WorldToViewMatrix() = 0;
	virtual int                   GameLumpVersion( int lumpId ) const = 0;
	virtual int                   GameLumpSize( int lumpId ) const = 0; // 40
	virtual bool                  LoadGameLump( int lumpId, void* pBuffer, int size ) = 0;
	virtual int                   LevelLeafCount() const = 0;
	virtual ISpatialQuery*        GetBSPTreeQuery() = 0;
	virtual void                  LinearToGamma( float* linear, float* gamma ) = 0;
	virtual float                 LightStyleValue( int style ) = 0; // 45
	virtual void                  ComputeDynamicLighting( const Vector& pt, const Vector* pNormal, Vector& color ) = 0;
	virtual void                  GetAmbientLightColor( Vector& color ) = 0;
	virtual int                   GetDXSupportLevel() = 0;
	virtual bool                  SupportsHDR() = 0;
	virtual void                  Mat_Stub( IMaterialSystem *pMatSys ) = 0; // 50
	virtual void                  GetChapterName( char *pchBuff, int iMaxLength ) = 0;
	virtual char const*           GetLevelName( void ) = 0;
	virtual char const*           GetLevelNameShort( void ) = 0;
	virtual char const*           GetMapGroupName( void ) = 0;
	virtual struct IVoiceTweak_s* GetVoiceTweakAPI( void ) = 0;
	virtual void                  SetVoiceCasterID( unsigned int someint ) = 0; // 56
	virtual void                  EngineStats_BeginFrame( void ) = 0;
	virtual void                  EngineStats_EndFrame( void ) = 0;
	virtual void                  FireEvents() = 0;
	virtual int                   GetLeavesArea( unsigned short *pLeaves, int nLeaves ) = 0;
	virtual bool                  DoesBoxTouchAreaFrustum( const Vector &mins, const Vector &maxs, int iArea ) = 0; // 60
	virtual int                   GetFrustumList( Frustum_t **pList, int listMax ) = 0;
	virtual bool                  ShouldUseAreaFrustum( int i ) = 0;
	virtual void                  SetAudioState( const AudioState_t& state ) = 0;
	virtual int                   SentenceGroupPick( int groupIndex, char *name, int nameBufLen ) = 0;
	virtual int                   SentenceGroupPickSequential( int groupIndex, char *name, int nameBufLen, int sentenceIndex, int reset ) = 0;
	virtual int                   SentenceIndexFromName( const char *pSentenceName ) = 0;
	virtual const char*           SentenceNameFromIndex( int sentenceIndex ) = 0;
	virtual int                   SentenceGroupIndexFromName( const char *pGroupName ) = 0;
	virtual const char*           SentenceGroupNameFromIndex( int groupIndex ) = 0;
	virtual float                 SentenceLength( int sentenceIndex ) = 0;
	virtual void                  ComputeLighting( const Vector& pt, const Vector* pNormal, bool bClamp, Vector& color, Vector *pBoxColors = nullptr ) = 0;
	virtual void                  ActivateOccluder( int nOccluderIndex, bool bActive ) = 0;
	virtual bool                  IsOccluded( const Vector &vecAbsMins, const Vector &vecAbsMaxs ) = 0; // 74
	virtual int                   GetOcclusionViewId( void ) = 0;
	virtual void*                 SaveAllocMemory( size_t num, size_t size ) = 0;
	virtual void                  SaveFreeMemory( void *pSaveMem ) = 0;
	virtual INetChannelInfo*      GetNetChannelInfo( void ) = 0;
	virtual void                  DebugDrawPhysCollide( const CPhysCollide *pCollide, IMaterial *pMaterial, const matrix3x4_t& transform, const Color &color ) = 0; //79
	virtual void                  CheckPoint( const char *pName ) = 0; // 80
	virtual void                  DrawPortals() = 0;
	virtual bool                  IsPlayingDemo( void ) = 0;
	virtual bool                  IsRecordingDemo( void ) = 0;
	virtual bool                  IsPlayingTimeDemo( void ) = 0;
	virtual int                   GetDemoRecordingTick( void ) = 0;
	virtual int                   GetDemoPlaybackTick( void ) = 0;
	virtual int                   GetDemoPlaybackStartTick( void ) = 0;
	virtual float                 GetDemoPlaybackTimeScale( void ) = 0;
	virtual int                   GetDemoPlaybackTotalTicks( void ) = 0;
	virtual bool                  IsPaused( void ) = 0; // 90
	virtual float                 GetTimescale( void ) const = 0;
	virtual bool                  IsTakingScreenshot( void ) = 0;
	virtual bool                  IsHLTV( void ) = 0;
	virtual bool                  IsLevelMainMenuBackground( void ) = 0;
	virtual void                  GetMainMenuBackgroundName( char *dest, int destlen ) = 0;
	virtual void                  SetOcclusionParameters( const int /*OcclusionParams_t*/ &params ) = 0; // 96
	virtual void                  GetUILanguage( char *dest, int destlen ) = 0;
	virtual int                   IsSkyboxVisibleFromPoint( const Vector &vecPoint ) = 0;
	virtual const char*           GetMapEntitiesString() = 0;
	virtual bool                  IsInEditMode( void ) = 0; // 100
	virtual float                 GetScreenAspectRatio( int viewportWidth, int viewportHeight ) = 0;
	virtual bool                  REMOVED_SteamRefreshLogin( const char *password, bool isSecure ) = 0; // 100
	virtual bool                  REMOVED_SteamProcessCall( bool & finished ) = 0;
	virtual unsigned int          GetEngineBuildNumber() = 0; // engines build
	virtual const char *          GetProductVersionString() = 0; // mods version number (steam.inf)
	virtual void                  GrabPreColorCorrectedFrame( int x, int y, int width, int height ) = 0;
	virtual bool                  IsHammerRunning() const = 0;
	virtual void                  ExecuteClientCmd( const char *szCmdString ) = 0; //108
	virtual bool                  MapHasHDRLighting( void ) = 0;
	virtual bool                  MapHasLightMapAlphaData( void ) = 0;
	virtual int                   GetAppID() = 0;
	virtual Vector                GetLightForPointFast( const Vector &pos, bool bClamp ) = 0;
	virtual void                  ClientCmd_Unrestricted1( char  const*, int, bool );
	virtual void                  ClientCmd_Unrestricted( const char *szCmdString, const char *newFlag = 0 ) = 0;
	virtual void                  SetRestrictServerCommands( bool bRestrict ) = 0;
	virtual void                  SetRestrictClientCommands( bool bRestrict ) = 0;
	virtual void                  SetOverlayBindProxy( int iOverlayID, void *pBindProxy ) = 0;
	virtual bool                  CopyFrameBufferToMaterial( const char *pMaterialName ) = 0;
	virtual void                  ReadConfiguration( const int iController, const bool readDefault ) = 0;
	virtual void                  SetAchievementMgr( IAchievementMgr *pAchievementMgr ) = 0;
	virtual IAchievementMgr*      GetAchievementMgr() = 0;
	virtual bool                  MapLoadFailed( void ) = 0;
	virtual void                  SetMapLoadFailed( bool bState ) = 0;
	virtual bool                  IsLowViolence() = 0;
	virtual const char*           GetMostRecentSaveGame( void ) = 0;
	virtual void                  SetMostRecentSaveGame( const char *lpszFilename ) = 0;
	virtual void                  StartXboxExitingProcess() = 0;
	virtual bool                  IsSaveInProgress() = 0;
	virtual bool                  IsAutoSaveDangerousInProgress( void ) = 0;
	virtual unsigned int          OnStorageDeviceAttached( int iController ) = 0;
	virtual void                  OnStorageDeviceDetached( int iController ) = 0;
	virtual char* const           GetSaveDirName( void ) = 0;
	virtual void                  WriteScreenshot( const char *pFilename ) = 0;
	virtual void                  ResetDemoInterpolation( void ) = 0;
	virtual int                   GetActiveSplitScreenPlayerSlot() = 0;
	virtual int                   SetActiveSplitScreenPlayerSlot( int slot ) = 0;
	virtual bool                  SetLocalPlayerIsResolvable( char const *pchContext, int nLine, bool bResolvable ) = 0;
	virtual bool                  IsLocalPlayerResolvable() = 0;
	virtual int                   GetSplitScreenPlayer( int nSlot ) = 0;
	virtual bool                  IsSplitScreenActive() = 0;
	virtual bool                  IsValidSplitScreenSlot( int nSlot ) = 0;
	virtual int                   FirstValidSplitScreenSlot() = 0; // -1 == invalid
	virtual int                   NextValidSplitScreenSlot( int nPreviousSlot ) = 0; // -1 == invalid
	virtual ISPSharedMemory*      GetSinglePlayerSharedMemorySpace( const char *szName, int ent_num = ( 1 << 11 ) ) = 0;
	virtual void                  ComputeLightingCube( const Vector& pt, bool bClamp, Vector *pBoxColors ) = 0;
	virtual void                  RegisterDemoCustomDataCallback( const char* szCallbackSaveID, pfnDemoCustomDataCallback pCallback ) = 0;
	virtual void                  RecordDemoCustomData( pfnDemoCustomDataCallback pCallback, const void *pData, size_t iDataLength ) = 0;
	virtual void                  SetPitchScale( float flPitchScale ) = 0;
	virtual float                 GetPitchScale( void ) = 0;
	virtual bool                  LoadFilmmaker() = 0;
	virtual void                  UnloadFilmmaker() = 0;
	virtual void                  SetLeafFlag( int nLeafIndex, int nFlagBits ) = 0;
	virtual void                  RecalculateBSPLeafFlags( void ) = 0;
	virtual bool                  DSPGetCurrentDASRoomNew( void ) = 0;
	virtual bool                  DSPGetCurrentDASRoomChanged( void ) = 0;
	virtual bool                  DSPGetCurrentDASRoomSkyAbove( void ) = 0;
	virtual float                 DSPGetCurrentDASRoomSkyPercent( void ) = 0;
	virtual void                  SetMixGroupOfCurrentMixer( const char *szgroupname, const char *szparam, float val, int setMixerType ) = 0;
	virtual int                   GetMixLayerIndex( const char *szmixlayername ) = 0;
	virtual void                  SetMixLayerLevel( int index, float level ) = 0;
	virtual int                   GetMixGroupIndex( char  const* groupname ) = 0;
	virtual void                  SetMixLayerTriggerFactor( int i1, int i2, float fl ) = 0;
	virtual void                  SetMixLayerTriggerFactor( char  const* char1, char  const* char2, float fl ) = 0;
	virtual bool                  IsCreatingReslist() = 0;
	virtual bool                  IsCreatingXboxReslist() = 0;
	virtual void                  SetTimescale( float flTimescale ) = 0;
	virtual void                  SetGamestatsData( CGamestatsData *pGamestatsData ) = 0;
	virtual CGamestatsData*       GetGamestatsData() = 0;
	virtual void                  GetMouseDelta( int &dx, int &dy, bool b ) = 0; // unknown
	virtual   const char*         k_LookupBindingEx( const char *pBinding, int iUserId = -1, int iStartCount = 0, int iAllowJoystick = -1 ) = 0;
	virtual int                   k_CodeForBinding( char  const*, int, int, int ) = 0;
	virtual void                  UpdateDAndELights( void ) = 0;
	virtual int                   GetBugSubmissionCount() const = 0;
	virtual void                  ClearBugSubmissionCount() = 0;
	virtual bool                  DoesLevelContainWater() const = 0;
	virtual float                 GetServerSimulationFrameTime() const = 0;
	virtual void                  SolidMoved( class IClientEntity *pSolidEnt, class ICollideable *pSolidCollide, const Vector* pPrevAbsOrigin, bool accurateBboxTriggerChecks ) = 0;
	virtual void                  TriggerMoved( class IClientEntity *pTriggerEnt, bool accurateBboxTriggerChecks ) = 0;
	virtual void                  ComputeLeavesConnected( const Vector &vecOrigin, int nCount, const int *pLeafIndices, bool *pIsConnected ) = 0;
	virtual bool                  IsInCommentaryMode( void ) = 0;
	virtual void                  SetBlurFade( float amount ) = 0;
	virtual bool                  IsTransitioningToLoad() = 0;
	virtual void                  SearchPathsChangedAfterInstall() = 0;
	virtual void                  ConfigureSystemLevel( int nCPULevel, int nGPULevel ) = 0;
	virtual void                  SetConnectionPassword( char const *pchCurrentPW ) = 0;
	virtual CSteamAPIContext*     GetSteamAPIContext() = 0;
	virtual void                  SubmitStatRecord( char const *szMapName, unsigned int uiBlobVersion, unsigned int uiBlobSize, const void *pvBlob ) = 0;
	virtual void                  ServerCmdKeyValues( void *pKeyValues ) = 0; // 203
	virtual void                  SpherePaintSurface( const model_t* model, const Vector& location, unsigned char chr, float fl1, float fl2 ) = 0;
	virtual bool                  HasPaintmap( void ) = 0;
	virtual void                  EnablePaintmapRender() = 0;
	//virtual void                TracePaintSurface( const model_t *model, const Vector& position, float radius, CUtlVector<Color>& surfColors ) = 0;
	virtual void                  SphereTracePaintSurface( const model_t* model, const Vector& position, const Vector &vec2, float radius, /*CUtlVector<unsigned char, CUtlMemory<unsigned char, int>>*/ int& utilVecShit ) = 0;
	virtual void                  RemoveAllPaint() = 0;
	virtual void                  PaintAllSurfaces( unsigned char uchr ) = 0;
	virtual void                  RemovePaint( const model_t* model ) = 0;
	virtual bool                  IsActiveApp() = 0;
	virtual bool                  IsClientLocalToActiveServer() = 0;
	virtual void                  TickProgressBar() = 0;
	virtual InputContextHandle_t  GetInputContext( int /*EngineInputContextId_t*/ id ) = 0;
	virtual void                  GetStartupImage( char* filename, int size ) = 0;
	virtual bool                  IsUsingLocalNetworkBackdoor( void ) = 0;
	virtual void                  SaveGame( const char*, bool, char*, int, char*, int ) = 0;
	virtual void                  GetGenericMemoryStats(/* GenericMemoryStat_t */ void ** ) = 0;
	virtual bool                  GameHasShutdownAndFlushedMemory( void ) = 0;
	virtual int                   GetLastAcknowledgedCommand( void ) = 0;
	virtual void                  FinishContainerWrites( int i ) = 0;
	virtual void                  FinishAsyncSave( void ) = 0;
	virtual int                   GetServerTick( void ) = 0;
	virtual const char*           GetModDirectory( void ) = 0;
	virtual bool                  AudioLanguageChanged( void ) = 0;
	virtual bool                  IsAutoSaveInProgress( void ) = 0;
	virtual void                  StartLoadingScreenForCommand( const char* command ) = 0;
	virtual void                  StartLoadingScreenForKeyValues( void* values ) = 0;
	virtual void                  SOSSetOpvarFloat( const char*, float ) = 0;
	virtual void                  SOSGetOpvarFloat( const char*, float & ) = 0;
	virtual bool                  IsSubscribedMap( const char*, bool ) = 0;
	virtual bool                  IsFeaturedMap( const char*, bool ) = 0;
	virtual void                  GetDemoPlaybackParameters( void ) = 0;
	virtual int                   GetClientVersion( void ) = 0;
	virtual bool                  IsDemoSkipping( void ) = 0;
	virtual void                  SetDemoImportantEventData( const void* values ) = 0;
	virtual void                  ClearEvents( void ) = 0;
	virtual int                   GetSafeZoneXMin( void ) = 0;
	virtual bool                  IsVoiceRecording( void ) = 0;
	virtual void                  ForceVoiceRecordOn( void ) = 0;
	virtual bool                  IsReplay( void ) = 0;
};

extern IEngineClient* g_pEngine;
```

`Lumina/Lumina/sdk/interfaces/IEngineTrace.h`:

```h
#pragma once

struct virtualmeshlist_t;


class ITraceListData
{
public:
	virtual ~ITraceListData() {}

	virtual void Reset() = 0;
	virtual bool IsEmpty() = 0;
	// CanTraceRay will return true if the current volume encloses the ray
	// NOTE: The leaflist trace will NOT check this.  Traces are intersected
	// against the culled volume exclusively.
	virtual bool CanTraceRay( const Ray_t &ray ) = 0;
};

class IEntityEnumerator
{
public:
	// This gets called with each handle
	virtual bool EnumEntity( IHandleEntity *pHandleEntity ) = 0;
};


struct BrushSideInfo_t
{
	Vector plane;			// The plane of the brush side
	float planec;
	unsigned short bevel;	// Bevel plane?
	unsigned short thin;	// Thin?
};

enum DebugTraceCounterBehavior_t
{
	kTRACE_COUNTER_SET = 0,
	kTRACE_COUNTER_INC,
};

class IEngineTrace
{
public:
	// Returns the contents mask + entity at a particular world-space position
	virtual int		GetPointContents( const Vector &vecAbsPosition, int contentsMask = MASK_ALL, IHandleEntity** ppEntity = NULL ) = 0;

	// Returns the contents mask of the world only @ the world-space position (static props are ignored)
	virtual int		GetPointContents_WorldOnly( const Vector &vecAbsPosition, int contentsMask = MASK_ALL ) = 0;

	// Get the point contents, but only test the specific entity. This works
	// on static props and brush models.
	//
	// If the entity isn't a static prop or a brush model, it returns CONTENTS_EMPTY and sets
	// bFailed to true if bFailed is non-null.
	virtual int		GetPointContents_Collideable( ICollideable *pCollide, const Vector &vecAbsPosition ) = 0;

	// Traces a ray against a particular entity
	virtual void	ClipRayToEntity( const Ray_t &ray, unsigned int fMask, IHandleEntity *pEnt, trace_t *pTrace ) = 0;

	// Traces a ray against a particular entity
	virtual void	ClipRayToCollideable( const Ray_t &ray, unsigned int fMask, ICollideable *pCollide, trace_t *pTrace ) = 0;

	// A version that simply accepts a ray (can work as a traceline or tracehull)
	virtual void	TraceRay( const Ray_t &ray, unsigned int fMask, ITraceFilter *pTraceFilter, trace_t *pTrace ) = 0;

	// A version that sets up the leaf and entity lists and allows you to pass those in for collision.
	virtual void	SetupLeafAndEntityListRay( const Ray_t &ray, ITraceListData *pTraceData ) = 0;
	virtual void    SetupLeafAndEntityListBox( const Vector &vecBoxMin, const Vector &vecBoxMax, ITraceListData *pTraceData ) = 0;
	virtual void	TraceRayAgainstLeafAndEntityList( const Ray_t &ray, ITraceListData *pTraceData, unsigned int fMask, ITraceFilter *pTraceFilter, trace_t *pTrace ) = 0;

	// A version that sweeps a collideable through the world
	// abs start + abs end represents the collision origins you want to sweep the collideable through
	// vecAngles represents the collision angles of the collideable during the sweep
	virtual void	SweepCollideable( ICollideable *pCollide, const Vector &vecAbsStart, const Vector &vecAbsEnd,
									  const QAngle &vecAngles, unsigned int fMask, ITraceFilter *pTraceFilter, trace_t *pTrace ) = 0;

	// Enumerates over all entities along a ray
	// If triggers == true, it enumerates all triggers along a ray
	virtual void	EnumerateEntities( const Ray_t &ray, bool triggers, IEntityEnumerator *pEnumerator ) = 0;

	// Same thing, but enumerate entitys within a box
	virtual void	EnumerateEntities( const Vector &vecAbsMins, const Vector &vecAbsMaxs, IEntityEnumerator *pEnumerator ) = 0;

	// Convert a handle entity to a collideable.  Useful inside enumer
	virtual ICollideable *GetCollideable( IHandleEntity *pEntity ) = 0;

	// HACKHACK: Temp for performance measurments
	virtual int GetStatByIndex( int index, bool bClear ) = 0;

	//finds brushes in an AABB, prone to some false positives
	virtual void lolignorethisaswellrifk() = 0;

	//Creates a CPhysCollide out of all displacements wholly or partially contained in the specified AABB
	virtual void GetCollidableFromDisplacementsInAABB() = 0;

	// gets the number of displacements in the world
	virtual int GetNumDisplacements() = 0;

	// gets a specific diplacement mesh
	virtual void GetDisplacementMesh( int nIndex, virtualmeshlist_t *pMeshTriList ) = 0;

	//retrieve brush planes and contents, returns true if data is being returned in the output pointers, false if the brush doesn't exist
	virtual bool lolignorethis() = 0;

	virtual bool PointOutsideWorld( const Vector &ptTest ) = 0; //Tests a point to see if it's outside any playable area

																// Walks bsp to find the leaf containing the specified point
	virtual int GetLeafContainingPoint( const Vector &ptTest ) = 0;

	virtual ITraceListData *AllocTraceListData() = 0;
	virtual void FreeTraceListData( ITraceListData * ) = 0;

	/// Used only in debugging: get/set/clear/increment the trace debug counter. See comment below for details.
	virtual int GetSetDebugTraceCounter( int value, DebugTraceCounterBehavior_t behavior ) = 0;

	void clip_ray_to_player( const Vector& src, const Vector& end, const uint32_t mask, C_BaseEntity* player, ITraceFilter* filter, trace_t* t )
	{
		if (!player || player->IsDormant())
			return;

		if ( filter && !filter->ShouldHitEntity( player, mask ) )
			return;

		trace_t t_new{};
		Ray_t r{};
		r.Init( src, end );

		ClipRayToEntity( r, mask, player, &t_new );
		if ( t_new.fraction < t->fraction )
			*t = t_new;
	}
};

extern IEngineTrace* g_pTrace;
```

`Lumina/Lumina/sdk/interfaces/IGameEventManager.h`:

```h
#pragma once


class IGameEvent
{
public:
	virtual ~IGameEvent() {};
	virtual const char *GetName() const = 0;	// get event name

	virtual bool  IsReliable() const = 0; // if event handled reliable
	virtual bool  IsLocal() const = 0; // if event is never networked
	virtual bool  IsEmpty(const char *keyName ) = 0; // check if data field exists

	// Data access
	virtual bool  GetBool(const char *keyName , bool defaultValue = false) = 0;
	virtual int   GetInt(const char *keyName , int defaultValue = 0) = 0;
	virtual unsigned __int64 GetUint64(const char *keyName , unsigned __int64 defaultValue = 0) = 0;
	virtual float GetFloat(const char *keyName , float defaultValue = 0.0f) = 0;
	virtual const char *GetString(const char *keyName , const char *defaultValue = "") = 0;
	virtual const wchar_t * GetWString(char const *keyName , const wchar_t *defaultValue = L"") = 0;

	virtual void SetBool(const char *keyName, bool value) = 0;
	virtual void SetInt(const char *keyName, int value) = 0;
	virtual void SetUint64(const char *keyName, unsigned __int64 value) = 0;
	virtual void SetFloat(const char *keyName, float value) = 0;
	virtual void SetString(const char *keyName, const char *value) = 0;
	virtual void SetWString(const char *keyName, const wchar_t *value) = 0;
};


class IGameEventListener2
{
public:
	virtual    ~IGameEventListener2( void ) {};

	virtual void FireGameEvent( IGameEvent *event ) = 0;
	virtual int  GetEventDebugID( void ) = 0;
};

#undef CreateEvent
class IGameEventManager2
{
public:
	virtual ~IGameEventManager2( void ) {};
	virtual int LoadEventsFromFile( const char* filename ) = 0;
	virtual void Reset() = 0;
	virtual bool AddListener( IGameEventListener2* listener, const char* name, bool bServerSide ) = 0;
	virtual bool FindListener( IGameEventListener2* listener, const char* name ) = 0;
	virtual void RemoveListener( IGameEventListener2* listener ) = 0;
	virtual void AddListenerGlobal( IGameEventListener2* listener, bool bIsServerSide ) = 0;
	virtual IGameEvent* CreateEvent( const char* name, bool bForce = false, int* pCookie = 0 ) = 0;
	virtual bool FireEvent( IGameEvent* event, bool bDontBroadcast = false ) = 0;
	virtual bool FireEventClientSide( IGameEvent* event ) = 0;
	virtual IGameEvent* DuplicateEvent( IGameEvent* event ) = 0;
	virtual void FreeEvent( IGameEvent* event ) = 0;
	virtual bool SerializeEvent( IGameEvent* event, int* buf ) = 0;
	virtual IGameEvent* UnserializeEvent( int* buf ) = 0;
	virtual void *GetEventDataTypes( IGameEvent* event ) = 0;
};
```

`Lumina/Lumina/sdk/interfaces/IGlobalVarsBase.h`:

```h
#pragma once

class IGlobalVarsBase
{
public:
	float				realtime;
	int					framecount;
	float				absoluteframetime;
	float				absoluteframestarttimestddev;
	float				curtime;
	float				frametime;
	int					maxClients;
	int					tickcount;
	float				interval_per_tick;
	float				interpolation_at;
	int					simTicksThisFrame;
	int					network_protocol;
	void*				pSaveData;
private:
	bool				m_bClient;
public:
	bool				m_bRemoteClient;
private:
	int					nTimestampNetworkingBase;
	int					nTimestampRandomizeWindow;
};

```

`Lumina/Lumina/sdk/interfaces/IInput.h`:

```h
#pragma once

typedef unsigned int CRC32_t;
class IInput
{
public:
	class CVerifiedUserCmd
	{
	public:
		CUserCmd	m_cmd;
		CRC32_t		m_crc;
	};
public:
	void*               pvftable;                     //0x00
	bool                m_fTrackIRAvailable;          //0x04
	bool                m_fMouseInitialized;          //0x05
	bool                m_fMouseActive;               //0x06
	bool                m_fJoystickAdvancedInit;      //0x07
	char                pad_0x08[ 0x2C ];             //0x08
	void*               m_pKeys;                      //0x34
	char                pad_0x38[ 0x64 ];             //0x38
	int					pad_0x41;
	int					pad_0x42;
	int					pad_0x43;
	int					pad_0x44;
	bool                m_fCameraInterceptingMouse;   //0x9C
	bool                m_fCameraInThirdPerson;       //0x9D
	bool                m_fCameraMovingWithMouse;     //0x9E
	Vector				m_vecCameraOffset;            //0xA0
	bool                m_fCameraDistanceMove;        //0xAC
	int                 m_nCameraOldX;                //0xB0
	int                 m_nCameraOldY;                //0xB4
	int                 m_nCameraX;                   //0xB8
	int                 m_nCameraY;                   //0xBC
	bool                m_CameraIsOrthographic;       //0xC0
	Vector              m_angPreviousViewAngles;      //0xC4
	Vector              m_angPreviousViewAnglesTilt;  //0xD0
	float               m_flLastForwardMove;          //0xDC
	int                 m_nClearInputState;           //0xE0
	//char                pad_0xE4[ 0x8 ];              //0xE4
	CUserCmd*           m_pCommands;                  //0xEC
	CVerifiedUserCmd*   m_pVerifiedCommands;		  //0xF0
	VFUNC( 8, GetUserCmd( int slot, int seq ), CUserCmd*( __thiscall* )( void*, int, int ) )( slot, seq )
};

extern IInput* g_pInput;

```

`Lumina/Lumina/sdk/interfaces/ILocalize.h`:

```h
#pragma once

enum InitReturnVal_t
{
	INIT_FAILED = 0,
	INIT_OK,

	INIT_LAST_VAL,
};

enum AppSystemTier_t
{
	APP_SYSTEM_TIER0 = 0,
	APP_SYSTEM_TIER1,
	APP_SYSTEM_TIER2,
	APP_SYSTEM_TIER3,

	APP_SYSTEM_TIER_OTHER,
};

struct AppSystemInfo_t;

using CreateInterfaceFn = void* ( *)( const char*, int* );

class IAppSystem
{
public:
	virtual bool					Connect( CreateInterfaceFn factory ) = 0;
	virtual void					Disconnect() = 0;
	virtual void*					QueryInterface( const char* pInterfaceName ) = 0;
	virtual InitReturnVal_t			Init() = 0;
	virtual void					Shutdown() = 0;
	virtual const AppSystemInfo_t*	GetDependencies() = 0;
	virtual AppSystemTier_t			GetTier() = 0;
	virtual void					Reconnect( CreateInterfaceFn factory, const char* pInterfaceName ) = 0;
	virtual bool					IsSingleton() = 0;
};


using LocalizeStringIndex_t = unsigned;

class ILocalizeTextQuery
{
public:
	virtual int ComputeTextWidth( const wchar_t* pString ) = 0;
};

class ILocalizationChangeCallback
{
public:
	virtual void OnLocalizationChanged() = 0;
};

class ILocalize : public IAppSystem
{
public:
	virtual bool					AddFile( const char* fileName, const char* pPathID = nullptr, bool bIncludeFallbackSearchPaths = false ) = 0;
	virtual void					RemoveAll() = 0;
	virtual wchar_t*				Find( const char* tokenName ) = 0;
	virtual const wchar_t*			FindSafe( const char* tokenName ) = 0;
	virtual int						ConvertANSIToUnicode( const char* ansi, wchar_t* unicode, int unicodeBufferSizeInBytes ) = 0;
	virtual int						ConvertUnicodeToANSI( const wchar_t* unicode, char* ansi, int ansiBufferSize ) = 0;
	virtual LocalizeStringIndex_t	FindIndex( const char* tokenName ) = 0;
	virtual void					ConstructString( wchar_t* unicodeOuput, int unicodeBufferSizeInBytes, const wchar_t* formatString, int numFormatParameters, ... ) = 0;
	virtual const char*				GetNameByIndex( LocalizeStringIndex_t index ) = 0;
	virtual wchar_t*				GetValueByIndex( LocalizeStringIndex_t index ) = 0;
};

extern ILocalize* g_pLocalize;

```

`Lumina/Lumina/sdk/interfaces/IMatRenderContext.h`:

```h
#pragma once

struct ShaderStencilState_t;
struct LightDesc_t;
class Vector4D;
struct MaterialMatrixMode_t;
struct MaterialCullMode_t;
struct MaterialFogMode_t;
struct MaterialHeightClipMode_t;
class IMesh;
struct MaterialIndexFormat_t;
class IVertexBuffer;
class IIndexBuffer;
struct OcclusionQueryObjectHandle_t;
struct MaterialPrimitiveType_t;
struct FlashlightState_t;
struct MorphFormat_t;
struct MorphWeight_t;
struct Rect_t;
class IMorph;
class ICallQueue;
struct DeformationBase_t;
struct ColorCorrectionHandle_t;
struct MaterialNonInteractiveMode_t;
class ITexture;
typedef uint64 VertexFormat_t;
struct Vector2D;
class IMatRenderContext : public IRefCounted
{
public:
public:
	virtual void				BeginRender() = 0;
	virtual void				EndRender() = 0;

	virtual void				Flush( bool flushHardware = false ) = 0;

	virtual void				BindLocalCubemap( ITexture *pTexture ) = 0;

	// pass in an ITexture (that is build with "rendertarget" "1") or
	// pass in NULL for the regular backbuffer.
	virtual void				SetRenderTarget( ITexture *pTexture ) = 0;
	virtual ITexture *			GetRenderTarget() = 0;

	virtual void				GetRenderTargetDimensions( int &width, int &height ) const = 0;

	// Bind a material is current for rendering.
	virtual void				Bind( IMaterial *material, void *proxyData = nullptr ) = 0;
	// Bind a lightmap page current for rendering.  You only have to 
	// do this for materials that require lightmaps.
	virtual void				BindLightmapPage( int lightmapPageID ) = 0;

	// inputs are between 0 and 1
	virtual void				DepthRange( float zNear, float zFar ) = 0;

	virtual void				ClearBuffers( bool bClearColor, bool bClearDepth, bool bClearStencil = false ) = 0;

	// read to a unsigned char rgb image.
	virtual void				ReadPixels( int x, int y, int width, int height, unsigned char *data, ImageFormat dstFormat ) = 0;
	virtual void				ReadPixelsAsync( int, int, int, int, unsigned char *, ImageFormat, ITexture *,/* CThreadEvent * */ void* ) = 0;
	virtual void				ReadPixelsAsyncGetResult( int, int, int, int, unsigned char *, ImageFormat,/* CThreadEvent * */ void* ) = 0;
	// Sets lighting
	virtual void				SetLightingState( void* ) = 0;
	//virtual void				SetAmbientLight(float r, float g, float b) = 0;
	virtual void				SetLights( int lightNum, const LightDesc_t& desc ) = 0;

	// The faces of the cube are specified in the same order as cubemap textures
	virtual void				SetAmbientLightCube( Vector4D cube[ 6 ] ) = 0;

	// Blit the backbuffer to the framebuffer texture
	virtual void				CopyRenderTargetToTexture( ITexture *pTexture ) = 0;

	// Set the current texture that is a copy of the framebuffer.
	virtual void				SetFrameBufferCopyTexture( ITexture *pTexture, int textureIndex = 0 ) = 0;
	virtual ITexture		   *GetFrameBufferCopyTexture( int textureIndex ) = 0;

	//
	// end vertex array api
	//

	// matrix api
	virtual void				MatrixMode( MaterialMatrixMode_t matrixMode ) = 0;
	virtual void				PushMatrix() = 0;
	virtual void				PopMatrix() = 0;
	virtual void				LoadMatrix( VMatrix const& matrix ) = 0;
	virtual void				LoadMatrix( matrix3x4_t const& matrix ) = 0;
	virtual void				MultMatrix( VMatrix const& matrix ) = 0;
	virtual void				MultMatrix( matrix3x4_t const& matrix ) = 0;
	virtual void				MultMatrixLocal( VMatrix const& matrix ) = 0;
	virtual void				MultMatrixLocal( matrix3x4_t const& matrix ) = 0;
	virtual void				GetMatrix( MaterialMatrixMode_t matrixMode, VMatrix *matrix ) = 0;
	virtual void				GetMatrix( MaterialMatrixMode_t matrixMode, matrix3x4_t *matrix ) = 0;
	virtual void				LoadIdentity( void ) = 0;
	virtual void				Ortho( double left, double top, double right, double bottom, double zNear, double zFar ) = 0;
	virtual void				PerspectiveX( double fovx, double aspect, double zNear, double zFar ) = 0;
	virtual void				PickMatrix( int x, int y, int width, int height ) = 0;
	virtual void				Rotate( float angle, float x, float y, float z ) = 0;
	virtual void				Translate( float x, float y, float z ) = 0;
	virtual void				Scale( float x, float y, float z ) = 0;
	// end matrix api

	// Sets/gets the viewport
	virtual void				Viewport( int x, int y, int width, int height ) = 0;
	virtual void				GetViewport( int& x, int& y, int& width, int& height ) const = 0;

	// The cull mode
	virtual void				CullMode( MaterialCullMode_t cullMode ) = 0;
	virtual void				FlipCullMode() = 0;
	// end matrix api

	virtual void				BeginGeneratingCSMs() = 0;
	virtual void				EndGeneratingCSMs() = 0;
	virtual void				PerpareForCascadeDraw( int, float, float ) = 0;

	// This could easily be extended to a general user clip plane
	virtual void				SetHeightClipMode( MaterialHeightClipMode_t nHeightClipMode ) = 0;
	// garymcthack : fog z is always used for heightclipz for now.
	virtual void				SetHeightClipZ( float z ) = 0;

	// Fog methods...
	virtual void				FogMode( MaterialFogMode_t fogMode ) = 0;
	virtual void				FogStart( float fStart ) = 0;
	virtual void				FogEnd( float fEnd ) = 0;
	virtual void				SetFogZ( float fogZ ) = 0;
	virtual MaterialFogMode_t	GetFogMode( void ) = 0;

	virtual void				FogColor3f( float r, float g, float b ) = 0;
	virtual void				FogColor3fv( float const* rgb ) = 0;
	virtual void				FogColor3ub( unsigned char r, unsigned char g, unsigned char b ) = 0;
	virtual void				FogColor3ubv( unsigned char const* rgb ) = 0;

	virtual void				GetFogColor( unsigned char *rgb ) = 0;

	// Sets the number of bones for skinning
	virtual void				SetNumBoneWeights( int numBones ) = 0;

	// Creates/destroys Mesh
	virtual IMesh* CreateStaticMesh( VertexFormat_t fmt, const char *pTextureBudgetGroup, IMaterial * pMaterial = nullptr ) = 0;
	virtual void DestroyStaticMesh( IMesh* mesh ) = 0;

	// Gets the dynamic mesh associated with the currently bound material
	// note that you've got to render the mesh before calling this function 
	// a second time. Clients should *not* call DestroyStaticMesh on the mesh 
	// returned by this call.
	// Use buffered = false if you want to not have the mesh be buffered,
	// but use it instead in the following pattern:
	//		meshBuilder.Begin
	//		meshBuilder.End
	//		Draw partial
	//		Draw partial
	//		Draw partial
	//		meshBuilder.Begin
	//		meshBuilder.End
	//		etc
	// Use Vertex or Index Override to supply a static vertex or index buffer
	// to use in place of the dynamic buffers.
	//
	// If you pass in a material in pAutoBind, it will automatically bind the
	// material. This can be helpful since you must bind the material you're
	// going to use BEFORE calling GetDynamicMesh.
	virtual IMesh* GetDynamicMesh(
		bool buffered = true,
		IMesh* pVertexOverride = nullptr,
		IMesh* pIndexOverride = nullptr,
		IMaterial *pAutoBind = nullptr ) = 0;

	// ------------ New Vertex/Index Buffer interface ----------------------------
	// Do we need support for bForceTempMesh and bSoftwareVertexShader?
	// I don't think we use bSoftwareVertexShader anymore. .need to look into bForceTempMesh.
	virtual IVertexBuffer *CreateStaticVertexBuffer( VertexFormat_t fmt, int nVertexCount, const char *pTextureBudgetGroup ) = 0;
	virtual IIndexBuffer *CreateStaticIndexBuffer( MaterialIndexFormat_t fmt, int nIndexCount, const char *pTextureBudgetGroup ) = 0;
	virtual void DestroyVertexBuffer( IVertexBuffer * ) = 0;
	virtual void DestroyIndexBuffer( IIndexBuffer * ) = 0;
	// Do we need to specify the stream here in the case of locking multiple dynamic VBs on different streams?
	virtual IVertexBuffer *GetDynamicVertexBuffer( int streamID, VertexFormat_t vertexFormat, bool bBuffered = true ) = 0;
	virtual IIndexBuffer *GetDynamicIndexBuffer( MaterialIndexFormat_t fmt, bool bBuffered = true ) = 0;
	virtual void BindVertexBuffer( int streamID, IVertexBuffer *pVertexBuffer, int nOffsetInBytes, int nFirstVertex, int nVertexCount, VertexFormat_t fmt, int nRepetitions = 1 ) = 0;
	virtual void BindIndexBuffer( IIndexBuffer *pIndexBuffer, int nOffsetInBytes ) = 0;
	virtual void Draw( MaterialPrimitiveType_t primitiveType, int firstIndex, int numIndices ) = 0;
	// ------------ End ----------------------------

	// Selection mode methods
	virtual int  SelectionMode( bool selectionMode ) = 0;
	virtual void SelectionBuffer( unsigned int* pBuffer, int size ) = 0;
	virtual void ClearSelectionNames() = 0;
	virtual void LoadSelectionName( int name ) = 0;
	virtual void PushSelectionName( int name ) = 0;
	virtual void PopSelectionName() = 0;

	// Sets the Clear Color for ClearBuffer....
	virtual void		ClearColor3ub( unsigned char r, unsigned char g, unsigned char b ) = 0;
	virtual void		ClearColor4ub( unsigned char r, unsigned char g, unsigned char b, unsigned char a ) = 0;

	// Allows us to override the depth buffer setting of a material
	virtual void	OverrideDepthEnable( bool bEnable, bool bDepthEnable ) = 0;

	// FIXME: This is a hack required for NVidia/XBox, can they fix in drivers?
	virtual void	DrawScreenSpaceQuad( IMaterial* pMaterial ) = 0;

	// For debugging and building recording files. This will stuff a token into the recording file,
	// then someone doing a playback can watch for the token.
	virtual void	SyncToken( const char *pToken ) = 0;

	// FIXME: REMOVE THIS FUNCTION!
	// The only reason why it's not gone is because we're a week from ship when I found the bug in it
	// and everything's tuned to use it.
	// It's returning values which are 2x too big (it's returning sphere diameter x2)
	// Use ComputePixelDiameterOfSphere below in all new code instead.
	virtual float	ComputePixelWidthOfSphere( const Vector& origin, float flRadius ) = 0;

	//
	// Occlusion query support
	//

	// Allocate and delete query objects.
	virtual OcclusionQueryObjectHandle_t CreateOcclusionQueryObject( void ) = 0;
	virtual void DestroyOcclusionQueryObject( OcclusionQueryObjectHandle_t ) = 0;

	// Bracket drawing with begin and end so that we can get counts next frame.
	virtual void BeginOcclusionQueryDrawing( OcclusionQueryObjectHandle_t ) = 0;
	virtual void EndOcclusionQueryDrawing( OcclusionQueryObjectHandle_t ) = 0;

	// Get the number of pixels rendered between begin and end on an earlier frame.
	// Calling this in the same frame is a huge perf hit!
	virtual int OcclusionQuery_GetNumPixelsRendered( OcclusionQueryObjectHandle_t ) = 0;

	virtual void SetFlashlightMode( bool bEnable ) = 0;

	virtual void SetFlashlightState( const FlashlightState_t &state, const VMatrix &worldToTexture ) = 0;

	virtual bool IsCascadedShadowMapping() = 0;
	virtual void SetCascadedShadowMapping( bool ) = 0;
	virtual void SetCascadedShadowMappingState(/*CascadedShadowMappingState_t*/ int const&, ITexture * ) = 0;

	// Gets the current height clip mode
	virtual MaterialHeightClipMode_t GetHeightClipMode() = 0;

	// This returns the diameter of the sphere in pixels based on 
	// the current model, view, + projection matrices and viewport.
	virtual float	ComputePixelDiameterOfSphere( const Vector& vecAbsOrigin, float flRadius ) = 0;

	// By default, the material system applies the VIEW and PROJECTION matrices	to the user clip
	// planes (which are specified in world space) to generate projection-space user clip planes
	// Occasionally (for the particle system in hl2, for example), we want to override that
	// behavior and explictly specify a ViewProj transform for user clip planes
	virtual void	EnableUserClipTransformOverride( bool bEnable ) = 0;
	virtual void	UserClipTransform( const VMatrix &worldToView ) = 0;

	virtual bool GetFlashlightMode() const = 0;

	virtual bool IsCullingEnabledForSinglePassFlashlight() = 0;
	virtual void EnableCullingForSinglePassFlashlight( bool ) = 0;
	// Used to make the handle think it's never had a successful query before
	virtual void ResetOcclusionQueryObject( OcclusionQueryObjectHandle_t ) = 0;

	// Creates/destroys morph data associated w/ a particular material
	virtual IMorph *CreateMorph( MorphFormat_t format, const char *pDebugName ) = 0;
	virtual void DestroyMorph( IMorph *pMorph ) = 0;

	// Binds the morph data for use in rendering
	virtual void BindMorph( IMorph *pMorph ) = 0;

	// Sets flexweights for rendering
	virtual void SetFlexWeights( int nFirstWeight, int nCount, const MorphWeight_t* pWeights ) = 0;

	virtual void LockRenderData( int ) = 0;
	virtual void UnlockRenderData() = 0;
	virtual void AddRefRenderData() = 0;
	virtual void ReleaseRenderData() = 0;
	virtual void IsRenderData( void const* ) = 0;

	// Read w/ stretch to a host-memory buffer
	virtual void ReadPixelsAndStretch( Rect_t *pSrcRect, Rect_t *pDstRect, unsigned char *pBuffer, ImageFormat dstFormat, int nDstStride ) = 0;

	// Gets the window size
	virtual void GetWindowSize( int &width, int &height ) const = 0;

	// This function performs a texture map from one texture map to the render destination, doing
	// all the necessary pixel/texel coordinate fix ups. fractional values can be used for the
	// src_texture coordinates to get linear sampling - integer values should produce 1:1 mappings
	// for non-scaled operations.
	virtual void DrawScreenSpaceRectangle(
		IMaterial *pMaterial,
		int destx, int desty,
		int width, int height,
		float src_texture_x0, float src_texture_y0,			// which texel you want to appear at
															// destx/y
		float src_texture_x1, float src_texture_y1,			// which texel you want to appear at
															// destx+width-1, desty+height-1
		int src_texture_width, int src_texture_height,		// needed for fixup
		void *pClientRenderable = nullptr,
		int nXDice = 1,
		int nYDice = 1 ) = 0;

	virtual void LoadBoneMatrix( int boneIndex, const matrix3x4_t& matrix ) = 0;

	// This version will push the current rendertarget + current viewport onto the stack
	virtual void PushRenderTargetAndViewport() = 0;

	// This version will push a new rendertarget + a maximal viewport for that rendertarget onto the stack
	virtual void PushRenderTargetAndViewport( ITexture *pTexture ) = 0;

	// This version will push a new rendertarget + a specified viewport onto the stack
	virtual void PushRenderTargetAndViewport( ITexture *pTexture, int nViewX, int nViewY, int nViewW, int nViewH ) = 0;

	// This version will push a new rendertarget + a specified viewport onto the stack
	virtual void PushRenderTargetAndViewport( ITexture *pTexture, ITexture *pDepthTexture, int nViewX, int nViewY, int nViewW, int nViewH ) = 0;

	// This will pop a rendertarget + viewport
	virtual void PopRenderTargetAndViewport() = 0;

	// Binds a particular texture as the current lightmap
	virtual void BindLightmapTexture( ITexture *pLightmapTexture ) = 0;

	// Blit a subrect of the current render target to another texture
	virtual void CopyRenderTargetToTextureEx( ITexture *pTexture, int nRenderTargetID, Rect_t *pSrcRect, Rect_t *pDstRect = nullptr ) = 0;
	virtual void CopyRenderTargetToTextureExCopyTextureToRenderTargetEx( int, ITexture *, Rect_t *, Rect_t * ) = 0;
	// Special off-center perspective matrix for DoF, MSAA jitter and poster rendering
	virtual void PerspectiveOffCenterX( double fovx, double aspect, double zNear, double zFar, double bottom, double top, double left, double right ) = 0;

	// Rendering parameters control special drawing modes withing the material system, shader
	// system, shaders, and engine. renderparm.h has their definitions.
	virtual void SetFloatRenderingParameter( int parm_number, float value ) = 0;
	virtual void SetIntRenderingParameter( int parm_number, int value ) = 0;
	virtual void SetVectorRenderingParameter( int parm_number, Vector const &value ) = 0;

	// stencil buffer operations.
	virtual void SetStencilState( ShaderStencilState_t& ) = 0;
	//virtual void SetStencilEnable(bool onoff) = 0;
	//virtual void SetStencilFailOperation(StencilOperation_t op) = 0;
	//virtual void SetStencilZFailOperation(StencilOperation_t op) = 0;
	//virtual void SetStencilPassOperation(StencilOperation_t op) = 0;
	//virtual void SetStencilCompareFunction(StencilComparisonFunction_t cmpfn) = 0;
	//virtual void SetStencilReferenceValue(int ref) = 0;
	//virtual void SetStencilTestMask(uint32 msk) = 0;
	//virtual void SetStencilWriteMask(uint32 msk) = 0;
	virtual void ClearStencilBufferRectangle( int xmin, int ymin, int xmax, int ymax, int value ) = 0;

	virtual void SetRenderTargetEx( int nRenderTargetID, ITexture *pTexture ) = 0;

	// rendering clip planes, beware that only the most recently pushed plane will actually be used in a sizeable chunk of hardware configurations
	// and that changes to the clip planes mid-frame while UsingFastClipping() is true will result unresolvable depth inconsistencies
	virtual void PushCustomClipPlane( const float *pPlane ) = 0;
	virtual void PopCustomClipPlane() = 0;

	// Returns the number of vertices + indices we can render using the dynamic mesh
	// Passing true in the second parameter will return the max # of vertices + indices
	// we can use before a flush is provoked and may return different values 
	// if called multiple times in succession. 
	// Passing false into the second parameter will return
	// the maximum possible vertices + indices that can be rendered in a single batch
	virtual void GetMaxToRender( IMesh *pMesh, bool bMaxUntilFlush, int *pMaxVerts, int *pMaxIndices ) = 0;

	// Returns the max possible vertices + indices to render in a single draw call
	virtual int GetMaxVerticesToRender( IMaterial *pMaterial ) = 0;
	virtual int GetMaxIndicesToRender() = 0;
	virtual void DisableAllLocalLights() = 0;
	virtual int CompareMaterialCombos( IMaterial *pMaterial1, IMaterial *pMaterial2, int lightMapID1, int lightMapID2 ) = 0;

	virtual IMesh *GetFlexMesh() = 0;

	virtual void SetFlashlightStateEx( const FlashlightState_t &state, const VMatrix &worldToTexture, ITexture *pFlashlightDepthTexture ) = 0;

	// Returns the currently bound local cubemap
	virtual ITexture *GetLocalCubemap() = 0;

	// This is a version of clear buffers which will only clear the buffer at pixels which pass the stencil test
	virtual void ClearBuffersObeyStencil( bool bClearColor, bool bClearDepth ) = 0;

	//enables/disables all entered clipping planes, returns the input from the last time it was called.
	virtual bool EnableClipping( bool bEnable ) = 0;

	//get fog distances entered with FogStart(), FogEnd(), and SetFogZ()
	virtual void GetFogDistances( float *fStart, float *fEnd, float *fFogZ ) = 0;

	// Hooks for firing PIX events from outside the Material System...
	virtual void BeginPIXEvent( unsigned long color, const char *szName ) = 0;
	virtual void EndPIXEvent() = 0;
	virtual void SetPIXMarker( unsigned long color, const char *szName ) = 0;

	// Batch API
	// from changelist 166623:
	// - replaced obtuse material system batch usage with an explicit and easier to thread API
	virtual void BeginBatch( IMesh* pIndices ) = 0;
	virtual void BindBatch( IMesh* pVertices, IMaterial *pAutoBind = nullptr ) = 0;
	virtual void DrawBatch( int firstIndex, int numIndices ) = 0;
	virtual void EndBatch() = 0;

	// Raw access to the call queue, which can be NULL if not in a queued mode
	virtual ICallQueue *GetCallQueue() = 0;

	// Returns the world-space camera position
	virtual void GetWorldSpaceCameraPosition( Vector *pCameraPos ) = 0;
	virtual void GetWorldSpaceCameraVectors( Vector *pVecForward, Vector *pVecRight, Vector *pVecUp ) = 0;

	// Tone mapping
	//virtual void				ResetToneMappingScale(float monoscale) = 0; 			// set scale to monoscale instantly with no chasing
	//virtual void				SetGoalToneMappingScale(float monoscale) = 0; 			// set scale to monoscale instantly with no chasing

	// call TurnOnToneMapping before drawing the 3d scene to get the proper interpolated brightness
	// value set.
	//virtual void				TurnOnToneMapping() = 0;

	// Set a linear vector color scale for all 3D rendering.
	// A value of [1.0f, 1.0f, 1.0f] should match non-tone-mapped rendering.
	virtual void				SetToneMappingScaleLinear( const Vector &scale ) = 0;

	virtual Vector				GetToneMappingScaleLinear() = 0;
	virtual void				SetShadowDepthBiasFactors( float fSlopeScaleDepthBias, float fDepthBias ) = 0;

	// Apply stencil operations to every pixel on the screen without disturbing depth or color buffers
	virtual void				PerformFullScreenStencilOperation( void ) = 0;

	// Sets lighting origin for the current model (needed to convert directional lights to points)
	virtual void				SetLightingOrigin( Vector vLightingOrigin ) = 0;

	// Set scissor rect for rendering
	virtual void				PushScissorRect( const int nLeft, const int nTop, const int nRight, const int nBottom ) = 0;
	virtual void				PopScissorRect() = 0;

	// Methods used to build the morph accumulator that is read from when HW morph<ing is enabled.
	virtual void				BeginMorphAccumulation() = 0;
	virtual void				EndMorphAccumulation() = 0;
	virtual void				AccumulateMorph( IMorph* pMorph, int nMorphCount, const MorphWeight_t* pWeights ) = 0;

	virtual void				PushDeformation( DeformationBase_t const *Deformation ) = 0;
	virtual void				PopDeformation() = 0;
	virtual int					GetNumActiveDeformations() const = 0;

	virtual bool				GetMorphAccumulatorTexCoord( Vector2D *pTexCoord, IMorph *pMorph, int nVertex ) = 0;

	// Version of get dynamic mesh that specifies a specific vertex format
	virtual IMesh*				GetDynamicMeshEx( VertexFormat_t vertexFormat, bool bBuffered = true,
												  IMesh* pVertexOverride = nullptr, IMesh* pIndexOverride = nullptr, IMaterial *pAutoBind = nullptr ) = 0;

	virtual void				FogMaxDensity( float flMaxDensity ) = 0;

	virtual IMaterial *GetCurrentMaterial() = 0;
	virtual int  GetCurrentNumBones() const = 0;
	virtual void *GetCurrentProxy() = 0;

	// Color correction related methods..
	// Client cannot call IColorCorrectionSystem directly because it is not thread-safe
	// FIXME: Make IColorCorrectionSystem threadsafe?
	virtual void EnableColorCorrection( bool bEnable ) = 0;
	virtual ColorCorrectionHandle_t AddLookup( const char *pName ) = 0;
	virtual bool RemoveLookup( ColorCorrectionHandle_t handle ) = 0;
	virtual void LockLookup( ColorCorrectionHandle_t handle ) = 0;
	virtual void LoadLookup( ColorCorrectionHandle_t handle, const char *pLookupName ) = 0;
	virtual void UnlockLookup( ColorCorrectionHandle_t handle ) = 0;
	virtual void SetLookupWeight( ColorCorrectionHandle_t handle, float flWeight ) = 0;
	virtual void ResetLookupWeights() = 0;
	virtual void SetResetable( ColorCorrectionHandle_t handle, bool bResetable ) = 0;

	//There are some cases where it's simply not reasonable to update the full screen depth texture (mostly on PC).
	//Use this to mark it as invalid and use a dummy texture for depth reads.
	virtual void SetFullScreenDepthTextureValidityFlag( bool bIsValid ) = 0;

	// A special path used to tick the front buffer while loading on the 360
	virtual void SetNonInteractivePacifierTexture( ITexture *pTexture, float flNormalizedX, float flNormalizedY, float flNormalizedSize ) = 0;
	virtual void SetNonInteractiveTempFullscreenBuffer( ITexture *pTexture, MaterialNonInteractiveMode_t mode ) = 0;
	virtual void EnableNonInteractiveMode( MaterialNonInteractiveMode_t mode ) = 0;
	virtual void RefreshFrontBufferNonInteractive() = 0;
};

class CMatRenderContextPtr
{
public:
	CMatRenderContextPtr() {}
	CMatRenderContextPtr( IMatRenderContext *pInit ) { m_pObject = pInit;/* if ( m_pObject ) m_pObject->BeginRender()*/; }
	CMatRenderContextPtr( IMaterialSystem *pFrom ) { if ( pFrom ) { m_pObject = pFrom->GetRenderContext(); } /*if ( m_pObject ) m_pObject->BeginRender();*/ }
	~CMatRenderContextPtr() { /*if ( m_pObject ) m_pObject->EndRender();*/ }
public:
	IMatRenderContext * m_pObject;
};
```

`Lumina/Lumina/sdk/interfaces/IMaterialSystem.h`:

```h
#pragma once

#include "../structs/structs.h"

typedef unsigned short MaterialHandle_t;

struct MaterialVideoMode_t
{
	int m_Width;
	int m_Height;
	int m_Format;
	int m_RefreshRate;
};

struct MaterialSystem_Config_t
{
	MaterialVideoMode_t m_VideoMode;
	float m_fMonitorGamma;
	float m_fGammaTVRangeMin;
	float m_fGammaTVRangeMax;
	float m_fGammaTVExponent;
	bool m_bGammaTVEnabled;
	bool m_bTripleBuffered;
	int m_nAASamples;
	int m_nForceAnisotropicLevel;
	int m_nSkipMipLevels;
	int m_nDxSupportLevel;
	int m_nFlags;
	bool m_bEditMode;
	char m_nProxiesTestMode;
	bool m_bCompressedTextures;
	bool m_bFilterLightmaps;
	bool m_bFilterTextures;
	bool m_bReverseDepth;
	bool m_bBufferPrimitives;
	bool m_bDrawFlat;
	bool m_bMeasureFillRate;
	bool m_bVisualizeFillRate;
	bool m_bNoTransparency;
	bool m_bSoftwareLighting;
	bool m_bAllowCheats;
	char m_nShowMipLevels;
	bool m_bShowLowResImage;
	bool m_bShowNormalMap;
	bool m_bMipMapTextures;
	char m_nFullbright;
	bool m_bFastNoBump;
	bool m_bSuppressRendering;
	bool m_bDrawGray;
	bool m_bShowSpecular;
	bool m_bShowDiffuse;
	int m_nWindowedSizeLimitWidth;
	int m_nWindowedSizeLimitHeight;
	int m_nAAQuality;
	bool m_bShadowDepthTexture;
	bool m_bMotionBlur;
	bool m_bSupportFlashlight;
	bool m_bPaintEnabled;
	char pad[ 0xC ];
};

// KeyValues
class KeyValues
{
public:
	char _pad[0x20]; //csgo, for css its a diff size
};


class IMatRenderContext;
class ITexture;
class IMaterialSystem
{
public:
		VFUNC( 21, OverrideConfig( const MaterialSystem_Config_t& cfg, bool b ), bool( __thiscall* )( void*, const MaterialSystem_Config_t&, bool ) )( cfg, b )
		VFUNC( 36, GetBackBufferFormat(), ImageFormat( __thiscall* )( void* ) )( )
		VFUNC( 84, FindMaterial( const char* name, const char *texgroup, bool complain = true, const char *complainprefix = nullptr ), IMaterial*( __thiscall* )( void*, const char*, const char*, bool, const char* ) )( name, texgroup, complain, complainprefix )
		VFUNC( 86, FirstMaterial(), MaterialHandle_t( __thiscall* )( void* ) )( )
		VFUNC( 87, NextMaterial( MaterialHandle_t h ), MaterialHandle_t( __thiscall* )( void*, MaterialHandle_t ) )( h )
		VFUNC( 88, InvalidMaterial(), MaterialHandle_t( __thiscall* )( void* ) )( )
		VFUNC( 89, GetMaterial( MaterialHandle_t h ), IMaterial* ( __thiscall* )( void*, MaterialHandle_t ) )( h )
		VFUNC( 90, GetNumMaterials(), int( __thiscall* )( void* ) )( )
		VFUNC( 91, FindTexture( const char* name, const char *groupname, bool complain ), ITexture*( __thiscall* )( void*, const char*, const char*, bool ) )( name, groupname, complain )
		VFUNC( 94, BeginRenderTargetAllocation(), void( __thiscall* )( void* ) )( )
		VFUNC( 95, EndRenderTargetAllocation(), void( __thiscall* )( void* ) )( )
		VFUNC( 115, GetRenderContext(), IMatRenderContext*( __thiscall* )( void* ) )( )
		VFUNC( 83, CreateMaterial(const char * pMaterialName, KeyValues* pVMTKeyValues), IMaterial*(__thiscall*)(void*, const char *, KeyValues*)) (pMaterialName, pVMTKeyValues)
};

extern IMaterialSystem* g_pMaterialSystem;

/*
//-----------------------------------------------------------------------------
// Forward declarations
//-----------------------------------------------------------------------------
struct studiohdr_t;
struct studiohwdata_t;
struct vcollide_t;
struct virtualmodel_t;
struct vertexFileHeader_t;

namespace OptimizedModel
{
	struct FileHeader_t;
}


//-----------------------------------------------------------------------------
// Reference to a loaded studiomdl 
//-----------------------------------------------------------------------------
typedef unsigned short MDLHandle_t;

enum
{
	MDLHANDLE_INVALID = (MDLHandle_t)~0
};


//-----------------------------------------------------------------------------
// Cache data types
//-----------------------------------------------------------------------------
enum MDLCacheDataType_t
{
	// Callbacks to get called when data is loaded or unloaded for these:
	MDLCACHE_STUDIOHDR = 0,
	MDLCACHE_STUDIOHWDATA,
	MDLCACHE_VCOLLIDE,

	// Callbacks NOT called when data is loaded or unloaded for these:
	MDLCACHE_ANIMBLOCK,
	MDLCACHE_VIRTUALMODEL,
	MDLCACHE_VERTEXES,
	MDLCACHE_DECODEDANIMBLOCK,
};

class IMDLCacheNotify
{
public:
	// Called right after the data is loaded
	virtual void OnDataLoaded(MDLCacheDataType_t type, MDLHandle_t handle) = 0;

	// Called right before the data is unloaded
	virtual void OnDataUnloaded(MDLCacheDataType_t type, MDLHandle_t handle) = 0;
};


//-----------------------------------------------------------------------------
// Flags for flushing 
//-----------------------------------------------------------------------------
enum MDLCacheFlush_t
{
	MDLCACHE_FLUSH_STUDIOHDR = 0x01,
	MDLCACHE_FLUSH_STUDIOHWDATA = 0x02,
	MDLCACHE_FLUSH_VCOLLIDE = 0x04,
	MDLCACHE_FLUSH_ANIMBLOCK = 0x08,
	MDLCACHE_FLUSH_VIRTUALMODEL = 0x10,
	MDLCACHE_FLUSH_AUTOPLAY = 0x20,
	MDLCACHE_FLUSH_VERTEXES = 0x40,

	MDLCACHE_FLUSH_IGNORELOCK = 0x80000000,
	MDLCACHE_FLUSH_ALL = 0xFFFFFFFF
};

/*
#define MDLCACHE_INTERFACE_VERSION_4 "MDLCache004"
namespace MDLCacheV4
{
abstract_class IMDLCache : public IAppSystem
{
public:
	// Used to install callbacks for when data is loaded + unloaded
	virtual void SetCacheNotify( IMDLCacheNotify *pNotify ) = 0;
	// NOTE: This assumes the "GAME" path if you don't use
	// the UNC method of specifying files. This will also increment
	// the reference count of the MDL
	virtual MDLHandle_t FindMDL( const char *pMDLRelativePath ) = 0;
	// Reference counting
	virtual int AddRef( MDLHandle_t handle ) = 0;
	virtual int Release( MDLHandle_t handle ) = 0;
	// Gets at the various data associated with a MDL
	virtual studiohdr_t *GetStudioHdr( MDLHandle_t handle ) = 0;
	virtual studiohwdata_t *GetHardwareData( MDLHandle_t handle ) = 0;
	virtual vcollide_t *GetVCollide( MDLHandle_t handle ) = 0;
	virtual unsigned char *GetAnimBlock( MDLHandle_t handle, int nBlock ) = 0;
	virtual virtualmodel_t *GetVirtualModel( MDLHandle_t handle ) = 0;
	virtual int GetAutoplayList( MDLHandle_t handle, unsigned short **pOut ) = 0;
	virtual vertexFileHeader_t *GetVertexData( MDLHandle_t handle ) = 0;
	// Brings all data associated with an MDL into memory
	virtual void TouchAllData( MDLHandle_t handle ) = 0;
	// Gets/sets user data associated with the MDL
	virtual void SetUserData( MDLHandle_t handle, void* pData ) = 0;
	virtual void *GetUserData( MDLHandle_t handle ) = 0;
	// Is this MDL using the error model?
	virtual bool IsErrorModel( MDLHandle_t handle ) = 0;
	// Flushes the cache, force a full discard
	virtual void Flush( int nFlushFlags = MDLCACHE_FLUSH_ALL ) = 0;
	// Flushes a particular model out of memory
	virtual void Flush( MDLHandle_t handle, int nFlushFlags = MDLCACHE_FLUSH_ALL ) = 0;
	// Returns the name of the model (its relative path)
	virtual const char *GetModelName( MDLHandle_t handle ) = 0;
	// faster access when you already have the studiohdr
	virtual virtualmodel_t *GetVirtualModelFast( const studiohdr_t *pStudioHdr, MDLHandle_t handle ) = 0;
	// all cache entries that subsequently allocated or successfully checked
	// are considered "locked" and will not be freed when additional memory is needed
	virtual void BeginLock() = 0;
	// reset all protected blocks to normal
	virtual void EndLock() = 0;
	// returns a pointer to a counter that is incremented every time the cache has been out of the locked state (EVIL)
	virtual int *GetFrameUnlockCounterPtr()  = 0;
	// Finish all pending async operations
	virtual void FinishPendingLoads() = 0;
};
}
*/
/*


typedef void* (*create_interface_fn)(const char* pName, int* pReturnCode);


//-----------------------------------------------------------------------------
// The main MDL cacher 
//-----------------------------------------------------------------------------


class IMdlCache : public i_app_system
{
public:
	// Used to install callbacks for when data is loaded + unloaded
	// Returns the prior notify
	virtual void SetCacheNotify(IMDLCacheNotify* pNotify) = 0;

	// NOTE: This assumes the "GAME" path if you don't use
	// the UNC method of specifying files. This will also increment
	// the reference count of the MDL
	virtual MDLHandle_t FindMDL(const char* pMDLRelativePath) = 0;

	// Reference counting
	virtual int AddRef(MDLHandle_t handle) = 0;
	virtual int Release(MDLHandle_t handle) = 0;
	virtual int GetRef(MDLHandle_t handle) = 0;

	// Gets at the various data associated with a MDL
	virtual studiohdr_t* GetStudioHdr(MDLHandle_t handle) = 0;
	virtual studiohwdata_t* GetHardwareData(MDLHandle_t handle) = 0;
	virtual vcollide_t* GetVCollide(MDLHandle_t handle) = 0;
	virtual unsigned char* GetAnimBlock(MDLHandle_t handle, int nBlock) = 0;
	virtual virtualmodel_t* GetVirtualModel(MDLHandle_t handle) = 0;
	virtual int GetAutoplayList(MDLHandle_t handle, unsigned short** pOut) = 0;
	virtual vertexFileHeader_t* GetVertexData(MDLHandle_t handle) = 0;

	// Brings all data associated with an MDL into memory
	virtual void TouchAllData(MDLHandle_t handle) = 0;

	// Gets/sets user data associated with the MDL
	virtual void SetUserData(MDLHandle_t handle, void* pData) = 0;
	virtual void* GetUserData(MDLHandle_t handle) = 0;

	// Is this MDL using the error model?
	virtual bool IsErrorModel(MDLHandle_t handle) = 0;

	// Flushes the cache, force a full discard
	virtual void Flush(MDLCacheFlush_t nFlushFlags = MDLCACHE_FLUSH_ALL) = 0;

	// Flushes a particular model out of memory
	virtual void Flush(MDLHandle_t handle, int nFlushFlags = MDLCACHE_FLUSH_ALL) = 0;

	// Returns the name of the model (its relative path)
	virtual const char* GetModelName(MDLHandle_t handle) = 0;

	// faster access when you already have the studiohdr
	virtual virtualmodel_t* GetVirtualModelFast(const studiohdr_t* pStudioHdr, MDLHandle_t handle) = 0;

	// all cache entries that subsequently allocated or successfully checked 
	// are considered "locked" and will not be freed when additional memory is needed
	virtual void BeginLock() = 0;

	// reset all protected blocks to normal
	virtual void EndLock() = 0;

	// returns a pointer to a counter that is incremented every time the cache has been out of the locked state (EVIL)
	virtual int* GetFrameUnlockCounterPtrOLD() = 0;

	// Finish all pending async operations
	virtual void FinishPendingLoads() = 0;

	virtual vcollide_t* GetVCollideEx(MDLHandle_t handle, bool synchronousLoad = true) = 0;
	virtual bool GetVCollideSize(MDLHandle_t handle, int* pVCollideSize) = 0;

	virtual bool GetAsyncLoad(MDLCacheDataType_t type) = 0;
	virtual bool SetAsyncLoad(MDLCacheDataType_t type, bool bAsync) = 0;

	virtual void BeginMapLoad() = 0;
	virtual void EndMapLoad() = 0;
	virtual void MarkAsLoaded(MDLHandle_t handle) = 0;

	virtual void InitPreloadData(bool rebuild) = 0;
	virtual void ShutdownPreloadData() = 0;

	virtual bool IsDataLoaded(MDLHandle_t handle, MDLCacheDataType_t type) = 0;

	virtual int* GetFrameUnlockCounterPtr(MDLCacheDataType_t type) = 0;

	virtual studiohdr_t* LockStudioHdr(MDLHandle_t handle) = 0;
	virtual void UnlockStudioHdr(MDLHandle_t handle) = 0;

	virtual bool PreloadModel(MDLHandle_t handle) = 0;

	// Hammer uses this. If a model has an error loading in GetStudioHdr, then it is flagged
	// as an error model and any further attempts to load it will just get the error model.
	// That is, until you call this function. Then it will load the correct model.
	virtual void ResetErrorModelStatus(MDLHandle_t handle) = 0;

	virtual void MarkFrame() = 0;
};
*/


```

`Lumina/Lumina/sdk/interfaces/IMemAlloc.h`:

```h
#pragma once

class IMemAlloc
{
public:
	VFUNC( 1, Alloc( size_t size ), void*( __thiscall* )( void*, size_t ) )( size )
		VFUNC( 3, Realloc( void *mem, size_t size ), void*( __thiscall* )( void*, void*, size_t ) )( mem, size )
		VFUNC( 5, Free( void *mem ), void( __thiscall* )( void*, void* ) )( mem )
};

extern IMemAlloc* g_pMemAlloc;
```

`Lumina/Lumina/sdk/interfaces/IMoveHelper.h`:

```h
#pragma once

class IMoveHelper
{
public:
	virtual	void _vpad() = 0;
	virtual void SetHost( IClientEntity* host ) = 0;

	bool m_bFirstRunOfFunctions : 1;
	bool m_bGameCodeMovedPlayer : 1;
	int m_nPlayerHandle; // edict index on server, client entity handle on client=
	int m_nImpulseCommand; // Impulse command issued.
	QAngle m_vecViewAngles; // Command view angles (local space)
	QAngle m_vecAbsViewAngles; // Command view angles (world space)
	int m_nButtons; // Attack buttons.
	int m_nOldButtons; // From host_client->oldbuttons;
	float m_flForwardMove;
	float m_flSideMove;
	float m_flUpMove;
	float m_flMaxSpeed;
	float m_flClientMaxSpeed;
	Vector m_vecVelocity; // edict::velocity // Current movement direction.
	QAngle m_vecAngles; // edict::angles
	QAngle m_vecOldAngles;
	float m_outStepHeight; // how much you climbed this move
	Vector m_outWishVel; // This is where you tried 
	Vector m_outJumpVel; // This is your jump velocity
	Vector m_vecConstraintCenter;
	float m_flConstraintRadius;
	float m_flConstraintWidth;
	float m_flConstraintSpeedFactor;
	float m_flUnknown[ 5 ];
	Vector m_vecAbsOrigin;
};

extern IMoveHelper* g_pMoveHelper;
```

`Lumina/Lumina/sdk/interfaces/IPhysicsSurfaceProps.h`:

```h
#pragma once


struct surfacephysicsparams_t
{
	float    friction;
	float    elasticity;
	float    density;
	float    thickness;
	float    dampening;
};

struct surfaceaudioparams_t
{
	float    reflectivity;             // like elasticity, but how much sound should be reflected by this surface
	float    hardnessFactor;           // like elasticity, but only affects impact sound choices
	float    roughnessFactor;          // like friction, but only affects scrape sound choices   
	float    roughThreshold;           // surface roughness > this causes "rough" scrapes, < this causes "smooth" scrapes
	float    hardThreshold;            // surface hardness > this causes "hard" impacts, < this causes "soft" impacts
	float    hardVelocityThreshold;    // collision velocity > this causes "hard" impacts, < this causes "soft" impacts   
	float    highPitchOcclusion;       //a value betweeen 0 and 100 where 0 is not occluded at all and 100 is silent (except for any additional reflected sound)
	float    midPitchOcclusion;
	float    lowPitchOcclusion;
};

struct surfacesoundnames_t
{
	unsigned short    walkStepLeft;
	unsigned short    walkStepRight;
	unsigned short	  runStepLeft;
	unsigned short	  runStepRight;
	unsigned short    impactSoft;
	unsigned short    impactHard;
	unsigned short    scrapeSmooth;
	unsigned short    scrapeRough;
	unsigned short    bulletImpact;
	unsigned short    rolling;
	unsigned short    breakSound;
	unsigned short    strainSound;
};

struct surfacegameprops_t
{
public:
	float maxspeedfactor;
	float jumpfactor;
	float penetrationmodifier;
	float damagemodifier;
	uint16_t material;
	uint8_t climbable;
};

struct surfacedata_t
{
	surfacephysicsparams_t physics;
	surfaceaudioparams_t audio;
	surfacesoundnames_t sounds;
	surfacegameprops_t game;
	char pad[ 48 ];
};

class IPhysicsSurfaceProps
{
public:
	virtual void _pad01() = 0;
	virtual int ParseSurfaceData( const char *pFilename, const char *pTextfile ) = 0;
	virtual int SurfacePropCount( void ) const = 0;
	virtual int GetSurfaceIndex( const char *pSurfacePropName ) const = 0;
	virtual void GetPhysicsProperties( int surfaceDataIndex, float *density, float *thickness, float *friction, float *elasticity ) const = 0;
	virtual surfacedata_t *GetSurfaceData( int surfaceDataIndex ) = 0;
	virtual const char *GetString( unsigned short stringTableIndex ) const = 0;
	virtual const char *GetPropName( int surfaceDataIndex ) const = 0;
	virtual void SetWorldMaterialIndexTable( int *pMapArray, int mapSize ) = 0;
	virtual void GetPhysicsParameters( int surfaceDataIndex, surfacephysicsparams_t *pParamsOut ) const = 0;
};

extern IPhysicsSurfaceProps* g_pSurfaceProps;
```

`Lumina/Lumina/sdk/interfaces/IPrediction.h`:

```h
#pragma once

class CMoveData
{
public:
	bool    m_bFirstRunOfFunctions : 1;
	bool    m_bGameCodeMovedPlayer : 1;
	int     m_nPlayerHandle;        // edict index on server, client entity handle on client=
	int     m_nImpulseCommand;      // Impulse command issued.
	Vector  m_vecViewAngles;        // Command view angles (local space)
	Vector  m_vecAbsViewAngles;     // Command view angles (world space)
	int     m_nButtons;             // Attack buttons.
	int     m_nOldButtons;          // From host_client->oldbuttons;
	float   m_flForwardMove;
	float   m_flSideMove;
	float   m_flUpMove;
	float   m_flMaxSpeed;
	float   m_flClientMaxSpeed;
	Vector  m_vecVelocity;          // edict::velocity        // Current movement direction.
	Vector  m_vecAngles;            // edict::angles
	Vector  m_vecOldAngles;
	float   m_outStepHeight;        // how much you climbed this move
	Vector  m_outWishVel;           // This is where you tried 
	Vector  m_outJumpVel;           // This is your jump velocity
	Vector  m_vecConstraintCenter;
	float   m_flConstraintRadius;
	float   m_flConstraintWidth;
	float   m_flConstraintSpeedFactor;
	float   m_flUnknown[ 5 ];
	Vector  m_vecAbsOrigin;
};

class IGameMovement
{
public:
	virtual			~IGameMovement( void ) {}

	virtual void	          ProcessMovement( C_BasePlayer *pPlayer, CMoveData *pMove ) = 0;
	virtual void	          Reset( void ) = 0;
	virtual void	          StartTrackPredictionErrors( C_BasePlayer *pPlayer ) = 0;
	virtual void	          FinishTrackPredictionErrors( C_BasePlayer *pPlayer ) = 0;
	virtual void	          DiffPrint( char const *fmt, ... ) = 0;
	virtual Vector const&	  GetPlayerMins( bool ducked ) const = 0;
	virtual Vector const&	  GetPlayerMaxs( bool ducked ) const = 0;
	virtual Vector const&   GetPlayerViewOffset( bool ducked ) const = 0;
	virtual bool		        IsMovingPlayerStuck( void ) const = 0;
	virtual C_BasePlayer*   GetMovingPlayer( void ) const = 0;
	virtual void		        UnblockPusher( C_BasePlayer *pPlayer, C_BasePlayer *pPusher ) = 0;
	virtual void            SetupMovementBounds( CMoveData *pMove ) = 0;
};

extern IGameMovement* g_pGameMovement;

class CGameMovement
	: public IGameMovement
{
public:
	virtual ~CGameMovement( void ) {}
};

class IPrediction
{
public:
	VFUNC( 12, GetLocalViewAngles( QAngle& ang ), void( __thiscall* )( void*, QAngle& ) )( ang )
	VFUNC( 371, SetLocalViewAngles( QAngle& ang ), void( __thiscall* )( void*, QAngle& ) )( ang )
		VFUNC( 14, InPrediction(), bool( __thiscall* )( void* ) )( )
		VFUNC( 19, RunCommand( C_BasePlayer *player, CUserCmd *cmd, IMoveHelper *movehelper ), void( __thiscall* )( void*, C_BasePlayer*, CUserCmd *, IMoveHelper * ) )( player, cmd, movehelper )
		VFUNC( 20, SetupMove( C_BasePlayer *player, CUserCmd *cmd, IMoveHelper *movehelper, void* movedata ), void( __thiscall* )( void*, C_BasePlayer *, CUserCmd *, IMoveHelper *, void* ) )( player, cmd, movehelper, movedata )
		VFUNC( 21, FinishMove( C_BasePlayer *player, CUserCmd *cmd, void* movedata ), void( __thiscall* )( void*, C_BasePlayer *, CUserCmd *, void* ) )( player, cmd, movedata )

public:
	float GetIdealPitch( int nSlot ) const
	{
		if ( nSlot == -1 ) { Assert( 0 ); return 0.0f; }
		return m_Split[ nSlot ].m_flIdealPitch;
	}

	CBaseHandle		m_hLastGround;

	bool			m_bInPrediction;
	bool			m_bOldCLPredictValue;
	bool			m_bEnginePaused;

	int				m_nPreviousStartFrame;
	int				m_nIncomingPacketNumber;

	float			m_flLastServerWorldTimeStamp;

	// Last network origin for local player
	struct Split_t
	{
		Split_t()
		{
			m_bFirstTimePredicted = false;
			m_nCommandsPredicted = 0;
			m_nServerCommandsAcknowledged = 0;
			m_bPreviousAckHadErrors = false;
			m_flIdealPitch = 0.0f;

		}

		bool			m_bFirstTimePredicted;
		int				m_nCommandsPredicted;
		int				m_nServerCommandsAcknowledged;
		int				m_bPreviousAckHadErrors;
		float			m_flIdealPitch;
	};

	Split_t				m_Split[ 2 ];
};

extern IPrediction* g_pPrediction;
```

`Lumina/Lumina/sdk/interfaces/ISteamGameServer.h`:

```h
#pragma once

class ISteamGameServer
{
public:

	// connection functions
	virtual void LogOn() = 0;
	virtual void LogOff() = 0;

	// status functions
	virtual bool BLoggedOn() = 0;
	virtual bool BSecure() = 0;

	/*

	this is version 012

	//
	// Basic server data.  These properties, if set, must be set before before calling LogOn.  They
	// may not be changed after logged in.
	//

		/// This is called by SteamGameServer_Init, and you will usually not need to call it directly
	virtual bool InitGameServer(unsigned __int32 unIP, unsigned __int16 usGamePort, unsigned __int16 usQueryPort, unsigned __int32 unFlags, unsigned __int32 nGameAppId, const char *pchVersionString) = 0;

	/// Game product identifier.  This is currently used by the master server for version checking purposes.
	/// It's a required field, but will eventually will go away, and the AppID will be used for this purpose.
	virtual void SetProduct(const char *pszProduct) = 0;

	/// Description of the game.  This is a required field and is displayed in the steam server browser....for now.
	/// This is a required field, but it will go away eventually, as the data should be determined from the AppID.
	virtual void SetGameDescription(const char *pszGameDescription) = 0;

	/// If your game is a "mod," pass the string that identifies it.  The default is an empty string, meaning
	/// this application is the original game, not a mod.
	///
	/// @see k_cbMaxGameServerGameDir
	virtual void SetModDir(const char *pszModDir) = 0;

	/// Is this is a dedicated server?  The default value is false.
	virtual void SetDedicatedServer(bool bDedicated) = 0;

	//
	// Login
	//

		/// Begin process to login to a persistent game server account
		///
		/// You need to register for callbacks to determine the result of this operation.
		/// @see SteamServersConnected_t
		/// @see SteamServerConnectFailure_t
		/// @see SteamServersDisconnected_t
	virtual void LogOn(const char *pszToken) = 0;

	/// Login to a generic, anonymous account.
	///
	/// Note: in previous versions of the SDK, this was automatically called within SteamGameServer_Init,
	/// but this is no longer the case.
	virtual void LogOnAnonymous() = 0;

	/// Begin process of logging game server out of steam
	virtual void LogOff() = 0;

	// status functions
	virtual bool BLoggedOn() = 0;
	virtual bool BSecure() = 0;

	virtual CSteamID GetSteamID() = 0;

	/// Returns true if the master server has requested a restart.
	/// Only returns true once per request.
	virtual bool WasRestartRequested() = 0;

	//
	// Server state.  These properties may be changed at any time.
	//

		/// Max player count that will be reported to server browser and client queries
	virtual void SetMaxPlayerCount(int cPlayersMax) = 0;

	/// Number of bots.  Default value is zero
	virtual void SetBotPlayerCount(int cBotplayers) = 0;

	/// Set the name of server as it will appear in the server browser
	///
	/// @see k_cbMaxGameServerName
	virtual void SetServerName(const char *pszServerName) = 0;

	/// Set name of map to report in the server browser
	///
	/// @see k_cbMaxGameServerName
	virtual void SetMapName(const char *pszMapName) = 0;

	/// Let people know if your server will require a password
	virtual void SetPasswordProtected(bool bPasswordProtected) = 0;

	/// Spectator server.  The default value is zero, meaning the service
	/// is not used.
	virtual void SetSpectatorPort(unsigned __int16 unSpectatorPort) = 0;

	/// Name of the spectator server.  (Only used if spectator port is nonzero.)
	///
	/// @see k_cbMaxGameServerMapName
	virtual void SetSpectatorServerName(const char *pszSpectatorServerName) = 0;

	/// Call this to clear the whole list of key/values that are sent in rules queries.
	virtual void ClearAllKeyValues() = 0;

	/// Call this to add/update a key/value pair.
	virtual void SetKeyValue(const char *pKey, const char *pValue) = 0;

	/// Sets a string defining the "gametags" for this server, this is optional, but if it is set
	/// it allows users to filter in the matchmaking/server-browser interfaces based on the value
	///
	/// @see k_cbMaxGameServerTags
	virtual void SetGameTags(const char *pchGameTags) = 0;

	/// Sets a string defining the "gamedata" for this server, this is optional, but if it is set
	/// it allows users to filter in the matchmaking/server-browser interfaces based on the value
	/// don't set this unless it actually changes, its only uploaded to the master once (when
	/// acknowledged)
	///
	/// @see k_cbMaxGameServerGameData
	virtual void SetGameData(const char *pchGameData) = 0;

	/// Region identifier.  This is an optional field, the default value is empty, meaning the "world" region
	virtual void SetRegion(const char *pszRegion) = 0;

	//
	// Player list management / authentication
	//

		// Handles receiving a new connection from a Steam user.  This call will ask the Steam
		// servers to validate the users identity, app ownership, and VAC status.  If the Steam servers 
		// are off-line, then it will validate the cached ticket itself which will validate app ownership 
		// and identity.  The AuthBlob here should be acquired on the game client using SteamUser()->InitiateGameConnection()
		// and must then be sent up to the game server for authentication.
		//
		// Return Value: returns true if the users ticket passes basic checks. pSteamIDUser will contain the Steam ID of this user. pSteamIDUser must NOT be NULL
		// If the call succeeds then you should expect a GSClientApprove_t or GSClientDeny_t callback which will tell you whether authentication
		// for the user has succeeded or failed (the steamid in the callback will match the one returned by this call)
	virtual bool SendUserConnectAndAuthenticate(unsigned __int32 unIPClient, const void *pvAuthBlob, unsigned __int32 cubAuthBlobSize, CSteamID *pSteamIDUser) = 0;

	// Creates a fake user (ie, a bot) which will be listed as playing on the server, but skips validation.  
	// 
	// Return Value: Returns a SteamID for the user to be tracked with, you should call HandleUserDisconnect()
	// when this user leaves the server just like you would for a real user.
	virtual CSteamID CreateUnauthenticatedUserConnection() = 0;

	// Should be called whenever a user leaves our game server, this lets Steam internally
	// track which users are currently on which servers for the purposes of preventing a single
	// account being logged into multiple servers, showing who is currently on a server, etc.
	virtual void SendUserDisconnect(CSteamID steamIDUser) = 0;

	// Update the data to be displayed in the server browser and matchmaking interfaces for a user
	// currently connected to the server.  For regular users you must call this after you receive a
	// GSUserValidationSuccess callback.
	// 
	// Return Value: true if successful, false if failure (ie, steamIDUser wasn't for an active player)
	virtual bool BUpdateUserData(CSteamID steamIDUser, const char *pchPlayerName, unsigned __int32 uScore) = 0;

	// New auth system APIs - do not mix with the old auth system APIs.
	// ----------------------------------------------------------------

	// Retrieve ticket to be sent to the entity who wishes to authenticate you ( using BeginAuthSession API ). 
	// pcbTicket retrieves the length of the actual ticket.
	virtual HAuthTicket GetAuthSessionTicket(void *pTicket, int cbMaxTicket, unsigned __int32 *pcbTicket) = 0;

	// Authenticate ticket ( from GetAuthSessionTicket ) from entity steamID to be sure it is valid and isnt reused
	// Registers for callbacks if the entity goes offline or cancels the ticket ( see ValidateAuthTicketResponse_t callback and EAuthSessionResponse )
	virtual EBeginAuthSessionResult BeginAuthSession(const void *pAuthTicket, int cbAuthTicket, CSteamID steamID) = 0;

	// Stop tracking started by BeginAuthSession - called when no longer playing game with this entity
	virtual void EndAuthSession(CSteamID steamID) = 0;

	// Cancel auth ticket from GetAuthSessionTicket, called when no longer playing game with the entity you gave the ticket to
	virtual void CancelAuthTicket(HAuthTicket hAuthTicket) = 0;

	// After receiving a user's authentication data, and passing it to SendUserConnectAndAuthenticate, use this function
	// to determine if the user owns downloadable content specified by the provided AppID.
	virtual EUserHasLicenseForAppResult UserHasLicenseForApp(CSteamID steamID, AppId_t appID) = 0;

	// Ask if a user in in the specified group, results returns async by GSUserGroupStatus_t
	// returns false if we're not connected to the steam servers and thus cannot ask
	virtual bool RequestUserGroupStatus(CSteamID steamIDUser, CSteamID steamIDGroup) = 0;


	// these two functions s are deprecated, and will not return results
	// they will be removed in a future version of the SDK
	virtual void GetGameplayStats() = 0;
	CALL_RESULT(GSReputation_t)
		virtual SteamAPICall_t GetServerReputation() = 0;

	// Returns the public IP of the server according to Steam, useful when the server is 
	// behind NAT and you want to advertise its IP in a lobby for other clients to directly
	// connect to
	virtual unsigned __int32 GetPublicIP() = 0;

	// These are in GameSocketShare mode, where instead of ISteamGameServer creating its own
	// socket to talk to the master server on, it lets the game use its socket to forward messages
	// back and forth. This prevents us from requiring server ops to open up yet another port
	// in their firewalls.
	//
	// the IP address and port should be in host order, i.e 127.0.0.1 == 0x7f000001

		// These are used when you've elected to multiplex the game server's UDP socket
		// rather than having the master server updater use its own sockets.
		// 
		// Source games use this to simplify the job of the server admins, so they 
		// don't have to open up more ports on their firewalls.

		// Call this when a packet that starts with 0xFFFFFFFF comes in. That means
		// it's for us.
	virtual bool HandleIncomingPacket(const void *pData, int cbData, unsigned __int32 srcIP, unsigned __int16 srcPort) = 0;

	// AFTER calling HandleIncomingPacket for any packets that came in that frame, call this.
	// This gets a packet that the master server updater needs to send out on UDP.
	// It returns the length of the packet it wants to send, or 0 if there are no more packets to send.
	// Call this each frame until it returns 0.
	virtual int GetNextOutgoingPacket(void *pOut, int cbMaxOut, unsigned __int32 *pNetAdr, unsigned __int16 *pPort) = 0;

	//
	// Control heartbeats / advertisement with master server
	//

		// Call this as often as you like to tell the master server updater whether or not
		// you want it to be active (default: off).
	virtual void EnableHeartbeats(bool bActive) = 0;

	// You usually don't need to modify this.
	// Pass -1 to use the default value for iHeartbeatInterval.
	// Some mods change this.
	virtual void SetHeartbeatInterval(int iHeartbeatInterval) = 0;

	// Force a heartbeat to steam at the next opportunity
	virtual void ForceHeartbeat() = 0;

	*/
};

typedef int32 HSteamPipe;
// handle to single instance of a steam user
typedef int32 HSteamUser;

class ISteamClient
{
public:
	virtual void* CreateSteamPipe() = 0;
	virtual bool BReleaseSteamPipe(HSteamPipe hSteamPipe) = 0;
	virtual void* ConnectToGlobalUser(HSteamPipe hSteamPipe) = 0;
	virtual void* CreateLocalUser(HSteamPipe *phSteamPipe, void* eAccountType) = 0;
	virtual void ReleaseUser(HSteamPipe hSteamPipe, HSteamUser hUser) = 0;
	virtual void *GetISteamUser(HSteamUser hSteamUser, HSteamPipe hSteamPipe, const char *pchVersion) = 0;
	virtual ISteamGameServer *GetISteamGameServer(HSteamUser hSteamUser, HSteamPipe hSteamPipe, const char *pchVersion) = 0;
	/*
	virtual void SetLocalIPBinding(uint32_t unIP, uint16_t usPort) = 0;
	virtual ISteamFriends *GetISteamFriends(SteamUserHandle hSteamUser, SteamPipeHandle hSteamPipe, const char *pchVersion) = 0;
	virtual ISteamUtils *GetISteamUtils(SteamPipeHandle hSteamPipe, const char *pchVersion) = 0;
	virtual ISteamMatchmaking *GetISteamMatchmaking(SteamUserHandle hSteamUser, SteamPipeHandle hSteamPipe, const char *pchVersion) = 0;
	virtual ISteamMatchmakingServers *GetISteamMatchmakingServers(SteamUserHandle hSteamUser, SteamPipeHandle hSteamPipe, const char *pchVersion) = 0;
	virtual void *GetISteamGenericInterface(SteamUserHandle hSteamUser, SteamPipeHandle hSteamPipe, const char *pchVersion) = 0;
	virtual ISteamUserStats *GetISteamUserStats(SteamUserHandle hSteamUser, SteamPipeHandle hSteamPipe, const char *pchVersion) = 0;
	virtual ISteamGameServerStats *GetISteamGameServerStats(SteamUserHandle hSteamuser, SteamPipeHandle hSteamPipe, const char *pchVersion) = 0;
	virtual ISteamApps *GetISteamApps(SteamUserHandle hSteamUser, SteamPipeHandle hSteamPipe, const char *pchVersion) = 0;
	virtual ISteamNetworking *GetISteamNetworking(SteamUserHandle hSteamUser, SteamPipeHandle hSteamPipe, const char *pchVersion) = 0;
	virtual ISteamRemoteStorage *GetISteamRemoteStorage(SteamUserHandle hSteamuser, SteamPipeHandle hSteamPipe, const char *pchVersion) = 0;
	virtual ISteamScreenshots *GetISteamScreenshots(SteamUserHandle hSteamuser, SteamPipeHandle hSteamPipe, const char *pchVersion) = 0;
	virtual void RunFrame() = 0;
	virtual uint32_t GetIPCCallCount() = 0;
	virtual void SetWarningMessageHook(SteamAPIWarningMessageHook_t pFunction) = 0;
	virtual bool ShutdownIfAllPipesClosed() = 0;
	virtual ISteamHTTP *GetISteamHTTP(SteamUserHandle hSteamuser, SteamPipeHandle hSteamPipe, const char *pchVersion) = 0;
	virtual ISteamUnifiedMessages *GetISteamUnifiedMessages(SteamUserHandle hSteamuser, SteamPipeHandle hSteamPipe, const char *pchVersion) = 0;
	virtual ISteamController *GetISteamController(SteamUserHandle hSteamUser, SteamPipeHandle hSteamPipe, const char *pchVersion) = 0;
	virtual ISteamUGC *GetISteamUGC(SteamUserHandle hSteamUser, SteamPipeHandle hSteamPipe, const char *pchVersion) = 0;
	virtual ISteamAppList *GetISteamAppList(SteamUserHandle hSteamUser, SteamPipeHandle hSteamPipe, const char *pchVersion) = 0;
	virtual ISteamMusic *GetISteamMusic(SteamUserHandle hSteamuser, SteamPipeHandle hSteamPipe, const char *pchVersion) = 0;
	virtual ISteamMusicRemote *GetISteamMusicRemote(SteamUserHandle hSteamuser, SteamPipeHandle hSteamPipe, const char *pchVersion) = 0;
	virtual ISteamHTMLSurface *GetISteamHTMLSurface(SteamUserHandle hSteamuser, SteamPipeHandle hSteamPipe, const char *pchVersion) = 0;
	virtual void Set_SteamAPI_CPostAPIResultInProcess(SteamAPI_PostAPIResultInProcess_t func) = 0;
	virtual void Remove_SteamAPI_CPostAPIResultInProcess(SteamAPI_PostAPIResultInProcess_t func) = 0;
	virtual void Set_SteamAPI_CCheckCallbackRegisteredInProcess(SteamAPI_CheckCallbackRegistered_t func) = 0;
	virtual ISteamInventory *GetISteamInventory(SteamUserHandle hSteamuser, SteamPipeHandle hSteamPipe, const char *pchVersion) = 0;
	virtual ISteamVideo *GetISteamVideo(SteamUserHandle hSteamuser, SteamPipeHandle hSteamPipe, const char *pchVersion) = 0;
	*/
};
```

`Lumina/Lumina/sdk/interfaces/IStudioRender.h`:

```h
#pragma once

// from Osiris : https://github.com/danielkrupinski/Osiris/blob/master/Osiris/SDK/StudioRender.h

enum class OverrideType {
	Normal = 0,
	BuildShadows,
	DepthWrite,
	CustomMaterial, // weapon skins
	SsaoDepthWrite
};

class IStudioRender {
	byte pad_0[0x250];
	IMaterial* materialOverride;
	byte pad_1[0xC];
	OverrideType overrideType;

public:
	bool isForcedMaterialOverride()
	{
		if (!materialOverride)
			return overrideType == OverrideType::DepthWrite || overrideType == OverrideType::SsaoDepthWrite; // see CStudioRenderContext::IsForcedMaterialOverride

		return strstr(materialOverride->GetName(), XorStr("dev/glow"));
	}
};

```

`Lumina/Lumina/sdk/interfaces/ISurface.h`:

```h
#pragma once

#define FW_DONTCARE         0
#define FW_THIN             100
#define FW_EXTRALIGHT       200
#define FW_LIGHT            300
#define FW_NORMAL           400
#define FW_MEDIUM           500
#define FW_SEMIBOLD         600
#define FW_BOLD             700
#define FW_EXTRABOLD        800
#define FW_HEAVY            900

enum FontFlags_t
{
	FONTFLAG_NONE,
	FONTFLAG_ITALIC = 0x001,
	FONTFLAG_UNDERLINE = 0x002,
	FONTFLAG_STRIKEOUT = 0x004,
	FONTFLAG_SYMBOL = 0x008,
	FONTFLAG_ANTIALIAS = 0x010,
	FONTFLAG_GAUSSIANBLUR = 0x020,
	FONTFLAG_ROTARY = 0x040,
	FONTFLAG_DROPSHADOW = 0x080,
	FONTFLAG_ADDITIVE = 0x100,
	FONTFLAG_OUTLINE = 0x200,
	FONTFLAG_CUSTOM = 0x400,
	FONTFLAG_BITMAP = 0x800,
};
#undef PlaySound
#undef CreateFont
struct IntRect
{
	int x0;
	int y0;
	int x1;
	int y1;
};
class Color;
typedef unsigned long HFont;
typedef unsigned int VPANEL;
class ISurface
{
public:
	virtual void		_pad01() = 0;
	virtual void		_pad02() = 0;
	virtual void		_pad03() = 0;
	virtual void		_pad04() = 0;
	virtual void		_pad05() = 0;
	virtual void		_pad06() = 0;
	virtual void		_pad07() = 0;
	virtual void		_pad08() = 0;
	virtual void		_pad09() = 0;
	virtual void		_pad10() = 0;
	virtual void		_pad11() = 0;
	virtual void		_pad12() = 0;
	virtual void		_pad13() = 0;
	virtual void		_pad14() = 0;
	virtual void        DrawSetColor( int r, int g, int b, int a ) = 0;
	virtual void        DrawSetColor( Color col ) = 0;
	virtual void        DrawFilledRect( int x0, int y0, int x1, int y1 ) = 0;
	virtual void        DrawFilledRectArray( IntRect *pRects, int numRects ) = 0;
	virtual void        DrawOutlinedRect( int x0, int y0, int x1, int y1 ) = 0;
	virtual void        DrawLine( int x0, int y0, int x1, int y1 ) = 0;
	virtual void        DrawPolyLine( int *px, int *py, int numPoints ) = 0;
	virtual void        DrawSetApparentDepth( float f ) = 0;
	virtual void        DrawClearApparentDepth( void ) = 0;
	virtual void        DrawSetTextFont( HFont font ) = 0;
	virtual void        DrawSetTextColor( int r, int g, int b, int a ) = 0;
	virtual void        DrawSetTextColor( Color col ) = 0;
	virtual void        DrawSetTextPos( int x, int y ) = 0;
	virtual void        DrawGetTextPos( int& x, int& y ) = 0;
	virtual void        DrawPrintText( const wchar_t *text, int textLen, FontDrawType_t drawType = FontDrawType_t::FONT_DRAW_DEFAULT ) = 0;
	virtual void        DrawUnicodeChar( wchar_t wch, FontDrawType_t drawType = FontDrawType_t::FONT_DRAW_DEFAULT ) = 0;
	virtual void        DrawFlushText() = 0;
	virtual void*       CreateHTMLWindow( void *events, VPANEL context ) = 0;
	virtual void        PaintHTMLWindow( void *htmlwin ) = 0;
	virtual void        DeleteHTMLWindow( void *htmlwin ) = 0;
	virtual int         DrawGetTextureId( char const *filename ) = 0;
	virtual bool        DrawGetTextureFile( int id, char *filename, int maxlen ) = 0;
	virtual void        DrawSetTextureFile( int id, const char *filename, int hardwareFilter, bool forceReload ) = 0;
	virtual void        DrawSetTextureRGBA( int id, const unsigned char *rgba, int wide, int tall ) = 0;
	virtual void        DrawSetTexture( int id ) = 0;
	virtual void        DeleteTextureByID( int id ) = 0;
	virtual void        DrawGetTextureSize( int id, int &wide, int &tall ) = 0;
	virtual void        DrawTexturedRect( int x0, int y0, int x1, int y1 ) = 0;
	virtual bool        IsTextureIDValid( int id ) = 0;
	virtual int         CreateNewTextureID( bool procedural = false ) = 0;
	virtual void        GetScreenSize( int &wide, int &tall ) = 0;
	virtual void        SetAsTopMost( VPANEL panel, bool state ) = 0;
	virtual void        SringToFront( VPANEL panel ) = 0;
	virtual void        SetForegroundWindow( VPANEL panel ) = 0;
	virtual void        SetPanelVisible( VPANEL panel, bool state ) = 0;
	virtual void        SetMinimized( VPANEL panel, bool state ) = 0;
	virtual bool        IsMinimized( VPANEL panel ) = 0;
	virtual void        FlashWindow( VPANEL panel, bool state ) = 0;
	virtual void        SetTitle( VPANEL panel, const wchar_t *title ) = 0;
	virtual void        SetAsToolBar( VPANEL panel, bool state ) = 0;
	virtual void        CreatePopup( VPANEL panel, bool minimised, bool showTaskbarIcon = true, bool disabled = false, bool mouseInput = true, bool kbInput = true ) = 0;
	virtual void        SwapBuffers( VPANEL panel ) = 0;
	virtual void        Invalidate( VPANEL panel ) = 0;
	virtual void        SetCursor( unsigned long cursor ) = 0;
	virtual bool        IsCursorVisible() = 0;
	virtual void        ApplyChanges() = 0;
	virtual bool        IsWithin( int x, int y ) = 0;
	virtual bool        HasFocus() = 0;
	virtual bool        SupportsFeature( int /*SurfaceFeature_t*/ feature ) = 0;
	virtual void        RestrictPaintToSinglePanel( VPANEL panel, bool bForceAllowNonModalSurface = false ) = 0;
	virtual void        SetModalPanel( VPANEL ) = 0;
	virtual VPANEL		GetModalPanel() = 0;
	virtual void        UnlockCursor() = 0;
	virtual void        LockCursor() = 0;
	virtual void        SetTranslateExtendedKeys( bool state ) = 0;
	virtual VPANEL		GetTopmostPopup() = 0;
	virtual void        SetTopLevelFocus( VPANEL panel ) = 0;
	virtual HFont		CreateFont() = 0;
	virtual bool        SetFontGlyphSet( HFont font, const char *windowsFontName, int tall, int weight, int blur, int scanlines, int flags, int nRangeMin = 0, int nRangeMax = 0 ) = 0;
	virtual bool        AddCustomFontFile( const char *fontFileName ) = 0;
	virtual int         GetFontTall( HFont font ) = 0;
	virtual int         GetFontAscent( HFont font, wchar_t wch ) = 0;
	virtual bool        IsFontAdditive( HFont font ) = 0;
	virtual void        GetCharABCwide( HFont font, int ch, int &a, int &b, int &c ) = 0;
	virtual int         etCharacterWidth( HFont font, int ch ) = 0;
	virtual void        GetTextSize( HFont font, const wchar_t *text, int &wide, int &tall ) = 0;
	virtual VPANEL		GetNotifyPanel() = 0;
	virtual void        SetNotifyIcon( VPANEL context, unsigned long icon, VPANEL panelToReceiveMessages, const char *text ) = 0;
	virtual void        PlaySound( const char *fileName ) = 0;
	virtual int         GetPopupCount() = 0;
	virtual VPANEL		GetPopup( int index ) = 0;
	virtual bool		ShouldPaintChildPanel( VPANEL childPanel ) = 0;
	virtual bool        RecreateContext( VPANEL panel ) = 0;
	virtual void        AddPanel( VPANEL panel ) = 0;
	virtual void        ReleasePanel( VPANEL panel ) = 0;
	virtual void        MovePopupToFront( VPANEL panel ) = 0;
	virtual void        MovePopupToBack( VPANEL panel ) = 0;
	virtual void        SolveTraverse( VPANEL panel, bool forceApplySchemeSettings = false ) = 0;
	virtual void        PaintTraverse( VPANEL panel ) = 0;
	virtual void        EnableMouseCapture( VPANEL panel, bool state ) = 0;
	virtual void        GetWorkspaceBounds( int &x, int &y, int &wide, int &tall ) = 0;
	virtual void        GetAbsoluteWindowBounds( int &x, int &y, int &wide, int &tall ) = 0;
	virtual void        GetProportionalBase( int &width, int &height ) = 0;
	virtual void        CalculateMouseVisible() = 0;
	virtual bool        NeedKBInput() = 0;
	virtual bool        HasCursorPosFunctions() = 0;
	virtual void        SurfaceGetCursorPos( int &x, int &y ) = 0;
	virtual void        SurfaceSetCursorPos( int x, int y ) = 0;
	virtual void        DrawTexturedLine( const Vertex_t &a, const Vertex_t &b ) = 0;
	virtual void        DrawOutlinedCircle( int x, int y, int radius, int segments ) = 0;
	virtual void        DrawTexturedPolyLine( const Vertex_t *p, int n ) = 0;
	virtual void        DrawTexturedSubRect( int x0, int y0, int x1, int y1, float texs0, float text0, float texs1, float text1 ) = 0;
	virtual void        DrawTexturedPolygon( int n, Vertex_t *pVertice, bool bClipVertices = true ) = 0;
	VFUNC( 123, DrawFilledRectFade( int x0, int y0, int x1, int y1, size_t alpha0, size_t alpha1, bool horizontal ), void( __thiscall* )( void*, int, int, int, int, size_t, size_t, bool ) )( x0, y0, x1, y1, alpha0, alpha1, horizontal )
};

extern ISurface* g_pSurface;
```

`Lumina/Lumina/sdk/interfaces/IVDebugOverlay.h`:

```h
#pragma once

#ifndef IVDebugOverlay_h

#define IVDebugOverlay_h

class OverlayText_t;

class IVDebugOverlay
{
public:
	virtual void            AddEntityTextOverlay( int ent_index, int line_offset, float duration, int r, int g, int b, int a, const char *format, ... ) = 0;
	virtual void            AddBoxOverlay( const Vector& origin, const Vector& mins, const Vector& max, QAngle const& orientation, int r, int g, int b, int a, float duration ) = 0;
	virtual void            AddSphereOverlay( const Vector& vOrigin, float flRadius, int nTheta, int nPhi, int r, int g, int b, int a, float flDuration ) = 0;
	virtual void            AddTriangleOverlay( const Vector& p1, const Vector& p2, const Vector& p3, int r, int g, int b, int a, bool noDepthTest, float duration ) = 0;
	virtual void            AddLineOverlay( const Vector& origin, const Vector& dest, int r, int g, int b, bool noDepthTest, float duration ) = 0;
	virtual void            AddTextOverlay( const Vector& origin, float duration, const char *format, ... ) = 0;
	virtual void            AddTextOverlay( const Vector& origin, int line_offset, float duration, const char *format, ... ) = 0;
	virtual void            AddScreenTextOverlay( float flXPos, float flYPos, float flDuration, int r, int g, int b, int a, const char *text ) = 0;
	virtual void            AddSweptBoxOverlay( const Vector& start, const Vector& end, const Vector& mins, const Vector& max, const QAngle & angles, int r, int g, int b, int a, float flDuration ) = 0;
	virtual void            AddGridOverlay( const Vector& origin ) = 0;
	virtual void            AddCoordFrameOverlay( const matrix3x4_t& frame, float flScale, int vColorTable[ 3 ][ 3 ] = NULL ) = 0;
	virtual int             ScreenPosition( const Vector& point, Vector& screen ) = 0;
	virtual int             ScreenPosition( float flXPos, float flYPos, Vector& screen ) = 0;
	virtual OverlayText_t*  GetFirst( void ) = 0;
	virtual OverlayText_t*  GetNext( OverlayText_t *current ) = 0;
	virtual void            ClearDeadOverlays( void ) = 0;
	virtual void            ClearAllOverlays( void ) = 0;
	virtual void            AddTextOverlayRGB( const Vector& origin, int line_offset, float duration, float r, float g, float b, float alpha, const char *format, ... ) = 0;
	virtual void            AddTextOverlayRGB( const Vector& origin, int line_offset, float duration, int r, int g, int b, int a, const char *format, ... ) = 0;
	virtual void            AddLineOverlayAlpha( const Vector& origin, const Vector& dest, int r, int g, int b, int a, bool noDepthTest, float duration ) = 0;
	virtual void            AddBoxOverlay2( const Vector& origin, const Vector& mins, const Vector& max, QAngle const& orientation, const uint8_t* faceColor, const uint8_t* edgeColor, float duration ) = 0;
	virtual void			AddLineOverlay( const Vector& origin, const Vector& dest, int r, int g, int b, int a, float, float ) = 0;
	virtual void            PurgeTextOverlays() = 0;
	VFUNC( 23, AddCapsuleOverlay( Vector& mins, Vector& maxs, float radius, int r, int g, int b, int a, float duration ), void( __thiscall* )( void*, Vector&, Vector&, float&, int, int, int, int, float ) )( mins, maxs, radius, r, g, b, a, duration )
	VFUNC( 24, AddCapsuleOverlayVisible( Vector& mins, Vector& maxs, float radius, int r, int g, int b, int a, float duration ), void( __thiscall* )( void*, Vector&, Vector&, float&, int, int, int, int, float ) )( mins, maxs, radius, r, g, b, a, duration )

	bool WorldToScreen(const Vector& in, Vector& out) {
		using original_fn = int(__thiscall*)(IVDebugOverlay*, const Vector&, Vector&);
		int return_value = (*(original_fn**)this)[13](this, in, out);
		return static_cast<bool>(return_value != 1);
	}
};

#endif // !IVDebugOverlay_h
```

`Lumina/Lumina/sdk/interfaces/IVModelInfo.h`:

```h
#pragma once

#ifndef modelinfo_h

#define modelinfo_h

#include "../structs/misc.h"

typedef int TABLEID;

class INetworkStringTable
{
public:

	virtual					~INetworkStringTable(void) {};

	// Table Info
	virtual const char		*GetTableName(void) const = 0;
	virtual TABLEID			GetTableId(void) const = 0;
	virtual int				GetNumStrings(void) const = 0;
	virtual int				GetMaxStrings(void) const = 0;
	virtual int				GetEntryBits(void) const = 0;

	// Networking
	virtual void			SetTick(int tick) = 0;
	virtual bool			ChangedSinceTick(int tick) const = 0;

	// Accessors (length -1 means don't change user data if string already exits)
	virtual int				AddString(bool bIsServer, const char *value, int length = -1, const void *userdata = 0) = 0;

	virtual const char		*GetString(int stringNumber) const = 0;
	virtual void			SetStringUserData(int stringNumber, int length, const void *userdata) = 0;
	virtual const void		*GetStringUserData(int stringNumber, int *length) const = 0;
	virtual int				FindStringIndex(char const *string) = 0; // returns INVALID_STRING_INDEX if not found

	// Callbacks
	//virtual void			SetStringChangedCallback(void *object, pfnStringChanged changeFunc) = 0;
};


class CNetworkStringTableContainer
{
public:

	INetworkStringTable* FindTable(const char *tableName)
	{
		using original_fn = INetworkStringTable * (__thiscall* )(PVOID, const char*);
		return (*(original_fn**)this)[3](this, tableName);
	}
};

enum Hitboxes
{
	HITBOX_HEAD,
	HITBOX_NECK,
	HITBOX_PELVIS,
	HITBOX_BODY,
	HITBOX_THORAX,
	HITBOX_CHEST,
	HITBOX_UPPER_CHEST,
	HITBOX_RIGHT_THIGH,
	HITBOX_LEFT_THIGH,
	HITBOX_RIGHT_CALF,
	HITBOX_LEFT_CALF,
	HITBOX_RIGHT_FOOT,
	HITBOX_LEFT_FOOT,
	HITBOX_RIGHT_HAND,
	HITBOX_LEFT_HAND,
	HITBOX_RIGHT_UPPER_ARM,
	HITBOX_RIGHT_FOREARM,
	HITBOX_LEFT_UPPER_ARM,
	HITBOX_LEFT_FOREARM,
	HITBOX_MAX
};

//-----------------------------------------------------------------------------
// Forward declarations
//-----------------------------------------------------------------------------
class IMaterial;
struct vcollide_t;
struct model_t;
class Vector;
class QAngle;
class CGameTrace;
struct cplane_t;
typedef CGameTrace trace_t;
struct studiohdr_t;
struct virtualmodel_t;
typedef unsigned char byte;
struct virtualterrainparams_t;
class CPhysCollide;
typedef unsigned short MDLHandle_t;
class CUtlBuffer;
class IClientRenderable;
class Quaternion;
struct mstudioanimdesc_t;
struct mstudioseqdesc_t;
struct mstudiobodyparts_t;
struct mstudiotexture_t;

class RadianEuler
{
public:
	inline RadianEuler( void ) {}
	inline RadianEuler( float X, float Y, float Z ) { x = X; y = Y; z = Z; }
	inline RadianEuler( Quaternion const &q );	// evil auto type promotion!!!
	inline RadianEuler( QAngle const &angles );	// evil auto type promotion!!!

												// Initialization
	inline void Init( float ix = 0.0f, float iy = 0.0f, float iz = 0.0f ) { x = ix; y = iy; z = iz; }

	//	conversion to qangle
	QAngle ToQAngle( void ) const;
	bool IsValid() const;
	void Invalidate();

	inline float *Base() { return &x; }
	inline const float *Base() const { return &x; }

	// array access...
	float operator[]( int i ) const;
	float& operator[]( int i );

	float x, y, z;
};


struct mstudiohitboxset_t
{
	int sznameindex;

	inline char * const pszName( void ) const
	{
		return ( ( char* )this ) + sznameindex;
	}

	int numhitboxes;
	int hitboxindex;

	inline mstudiobbox_t* pHitbox( int i ) const
	{
		return ( mstudiobbox_t* )( ( ( byte* )this ) + hitboxindex ) + i;
	}
};

struct mstudiobone_t
{
	int					sznameindex;
	inline char * const pszName( void ) const { return ( ( char * )this ) + sznameindex; }
	int		 			parent;		// parent bone
	int					bonecontroller[ 6 ];	// bone controller index, -1 == none

												// default values
	Vector				pos;
	void*			quat;
	RadianEuler			rot;
	// compression scale
	Vector				posscale;
	Vector				rotscale;

	matrix3x4_t			poseToBone;
	void*			qAlignment;
	int					flags;
	int					proctype;
	int					procindex;		// procedural rule
	mutable int			physicsbone;	// index into physically simulated bone
	inline void *pProcedure() const { if ( procindex == 0 ) return NULL; else return  ( void * )( ( ( byte * )this ) + procindex ); };
	int					surfacepropidx;	// index into string tablefor property name
	inline char * const pszSurfaceProp( void ) const { return ( ( char * )this ) + surfacepropidx; }
	inline int			GetSurfaceProp( void ) const { return surfacepropLookup; }

	int					contents;		// See BSPFlags.h for the contents flags
	int					surfacepropLookup;	// this index must be cached by the loader, not saved in the file
	int					unused[ 7 ];		// remove as appropriate
};

struct mstudiobonecontroller_t
{
	int					bone;	// -1 == 0
	int					type;	// X, Y, Z, XR, YR, ZR, M
	float				start;
	float				end;
	int					rest;	// byte index value at rest
	int					inputfield;	// 0-3 user set controller, 4 mouth
	int					unused[ 8 ];
};

// attachment
struct mstudioattachment_t
{
	int					sznameindex;
	inline char * const pszName( void ) const { return ( ( char * )this ) + sznameindex; }
	unsigned int		flags;
	int					localbone;
	matrix3x4_t			local; // attachment point
	int					unused[ 8 ];
};

struct studiohdr_t
{
	// Look up hitbox set by index
	mstudiohitboxset_t	*pHitboxSet( int i ) const
	{
		Assert( i >= 0 && i < numhitboxsets );
		return ( mstudiohitboxset_t * )( ( ( byte * )this ) + hitboxsetindex ) + i;
	};

	// Calls through to hitbox to determine size of specified set
	inline mstudiobbox_t *pHitbox( int i, int set ) const
	{
		mstudiohitboxset_t const *s = pHitboxSet( set );
		if ( !s )
			return NULL;

		return s->pHitbox( i );
	};

	// Calls through to set to get hitbox count for set
	inline int			iHitboxCount( int set ) const
	{
		mstudiohitboxset_t const *s = pHitboxSet( set );
		if ( !s )
			return 0;

		return s->numhitboxes;
	};
	inline mstudiobone_t *pBone( int i ) const { Assert( i >= 0 && i < numbones ); return ( mstudiobone_t * )( ( ( byte * )this ) + boneindex ) + i; };
	inline mstudioattachment_t	*pLocalAttachment( int i ) const { Assert( i >= 0 && i < numlocalattachments ); return ( mstudioattachment_t * )( ( ( byte * )this ) + localattachmentindex ) + i; };

	int id;
	int version;
	int checksum;
	char name[ 64 ];
	int length;

	Vector eyeposition;
	Vector illumposition;
	Vector hull_min;
	Vector hull_max;
	Vector view_bbmin;
	Vector view_bbmax;

	int flags;
	int numbones;
	int boneindex;

	int numbonecontrollers;
	int bonecontrollerindex;
	int numhitboxsets;
	int hitboxsetindex;

	int numlocalanim;
	int localanimindex;
	int numlocalseq;
	int localseqindex;

	mutable int activitylistversion;
	mutable int eventsindexed;

	int numtextures;
	int textureindex;
	int numcdtextures;
	int cdtextureindex;

	int numskinref;
	int numskinfamilies;
	int skinindex;

	int numbodyparts;
	int bodypartindex;
	int numlocalattachments;
	int localattachmentindex;

	int numlocalnodes;
	int localnodeindex;
	int localnodenameindex;

	int numflexdesc;
	int flexdescindex;
	int numflexcontrollers;
	int flexcontrollerindex;
	int numflexrules;
	int flexruleindex;
	int numikchains;
	int ikchainindex;
	int nummouths;
	int mouthindex;
	int numlocalposeparameters;
	int localposeparamindex;
	int surfacepropindex;

	int keyvalueindex;
	int keyvaluesize;

	int numlocalikautoplaylocks;
	int localikautoplaylockindex;

	float mass;
	int contents;
	int numincludemodels;
	int includemodelindex;

	mutable void *virtualModel;
	int szanimblocknameindex;

	int numanimblocks;
	int animblockindex;
	mutable void *animblockModel;
	int bonetablebynameindex;

	void *pVertexBase;
	void *pIndexBase;
	unsigned char constdirectionallightdot;
	unsigned char rootLOD;
	unsigned char numAllowedRootLODs;
	unsigned char unused[ 1 ];
	int unused4;
	int numflexcontrollerui;
	int flexcontrolleruiindex;
	int unused3[ 2 ];
	int studiohdr2index;
	int unused2[ 1 ];

	// ReSharper disable once CppPossiblyUninitializedMember
	studiohdr_t() {}
private:
	studiohdr_t( const studiohdr_t &vOther );

	friend struct virtualmodel_t;
};

class virtualgroup_t
{
public:
	void *cache;
	const studiohdr_t *GetStudioHdr( void ) const
	{
		return ( studiohdr_t * )cache;
	}

	CUtlVector< int > boneMap;				// maps global bone to local bone
	CUtlVector< int > masterBone;			// maps local bone to global bone
	CUtlVector< int > masterSeq;			// maps local sequence to master sequence
	CUtlVector< int > masterAnim;			// maps local animation to master animation
	CUtlVector< int > masterAttachment;	// maps local attachment to global
	CUtlVector< int > masterPose;			// maps local pose parameter to global
	CUtlVector< int > masterNode;			// maps local transition nodes to global
};

struct virtualsequence_t
{
	int	flags;
	int activity;
	int group;
	int index;
};

struct virtualgeneric_t
{
	int group;
	int index;
};

struct virtualmodel_t
{
	char pad_mutex[ 0x8 ];
	CUtlVector< virtualsequence_t > m_seq;
	CUtlVector< virtualgeneric_t > m_anim;
	CUtlVector< virtualgeneric_t > m_attachment;
	CUtlVector< virtualgeneric_t > m_pose;
	CUtlVector< virtualgroup_t > m_group;
	CUtlVector< virtualgeneric_t > m_node;
	CUtlVector< virtualgeneric_t > m_iklock;
	CUtlVector< unsigned short > m_autoplaySequences;
};

class CStudioHdr
{
public:
	mutable studiohdr_t* m_pStudioHdr; //0x0000 
	mutable virtualmodel_t* m_pVModel; //0x0004 
	char				pad_unknown[ 0x4 ]; //0x0008 
	mutable CUtlVector< const studiohdr_t* > m_pStudioHdrCache; //0x000C 
	mutable int			m_nFrameUnlockCounter; //0x0020 
	int*				m_pFrameUnlockCounter; //0x0024 
	char				pad_mutex[ 0x8 ]; //0x0028 
	CUtlVector< int >	m_boneFlags; //0x0030
	CUtlVector< int >	m_boneParent; //0x0050 
	inline int			numbones( void ) const { return m_pStudioHdr->numbones; };
	inline mstudiobone_t *pBone( int i ) const { return m_pStudioHdr->pBone( i ); };
	inline virtualmodel_t		*GetVirtualModel( void ) const { return m_pVModel; };
	int	GetNumAttachments( void ) const
	{
		if ( m_pStudioHdr->numincludemodels == 0 )
		{
			return m_pStudioHdr->numlocalattachments;
		}

		virtualmodel_t *pVModel = GetVirtualModel();
		Assert( pVModel );

		return pVModel->m_attachment.Count();
	}
	const studiohdr_t *GroupStudioHdr( int i )
	{
		const studiohdr_t *pStudioHdr = m_pStudioHdrCache[ i ];

		if ( !pStudioHdr )
		{
			virtualgroup_t *pGroup = &m_pVModel->m_group[ i ];
			pStudioHdr = pGroup->GetStudioHdr();
		}

		Assert( pStudioHdr );
		return pStudioHdr;
	}
	const mstudioattachment_t &pAttachment( int i )
	{
		if ( m_pVModel == NULL )
		{
			return *m_pStudioHdr->pLocalAttachment( i );
		}

		Assert( m_pVModel );

		const studiohdr_t *pStudioHdr = GroupStudioHdr( m_pVModel->m_attachment[ i ].group );

		return *pStudioHdr->pLocalAttachment( m_pVModel->m_attachment[ i ].index );
	}
	int	GetAttachmentBone( int i )
	{
		const mstudioattachment_t &attachment = pAttachment( i );

		// remap bone
		virtualmodel_t *pVModel = GetVirtualModel();
		if ( pVModel )
		{
			virtualgroup_t *pGroup = &pVModel->m_group[ pVModel->m_attachment[ i ].group ];
			int iBone = pGroup->masterBone[ attachment.localbone ];
			if ( iBone == -1 )
				return 0;
			return iBone;
		}
		return attachment.localbone;
	}

}; //Size=0x0054


   //-----------------------------------------------------------------------------
   // Indicates the type of translucency of an unmodulated renderable
   //-----------------------------------------------------------------------------
enum RenderableTranslucencyType_t
{
	RENDERABLE_IS_OPAQUE = 0,
	RENDERABLE_IS_TRANSLUCENT,
	RENDERABLE_IS_TWO_PASS,	// has both translucent and opaque sub-partsa
};


//-----------------------------------------------------------------------------
// Model info interface
//-----------------------------------------------------------------------------

class IVModelInfo
{
public:
	virtual							~IVModelInfo( void ) {}
	virtual const model_t			*GetModel( int modelindex ) const = 0;
	// Returns index of model by name
	virtual int						GetModelIndex( const char *name ) const = 0;
	// Returns name of model
	virtual const char				*GetModelName( const model_t *model ) const = 0;
	virtual vcollide_t				*GetVCollide( const model_t *model ) const = 0;
	virtual vcollide_t				*GetVCollide( int modelindex ) const = 0;
	virtual void					GetModelBounds( const model_t *model, Vector& mins, Vector& maxs ) const = 0;
	virtual	void					GetModelRenderBounds( const model_t *model, Vector& mins, Vector& maxs ) const = 0;
	virtual int						GetModelFrameCount( const model_t *model ) const = 0;
	virtual int						GetModelType( const model_t *model ) const = 0;
	virtual void					*GetModelExtraData( const model_t *model ) = 0;
	virtual bool					ModelHasMaterialProxy( const model_t *model ) const = 0;
	virtual bool					IsTranslucent( model_t const* model ) const = 0;
	virtual bool					IsTranslucentTwoPass( const model_t *model ) const = 0;
	virtual void					Unused0() {};
	virtual RenderableTranslucencyType_t ComputeTranslucencyType( const model_t *model, int nSkin, int nBody ) = 0;
	virtual int						GetModelMaterialCount( const model_t* model ) const = 0;
	virtual void					GetModelMaterials( const model_t *model, int count, IMaterial** ppMaterials ) = 0;
	virtual bool					IsModelVertexLit( const model_t *model ) const = 0;
	virtual const char				*GetModelKeyValueText( const model_t *model ) = 0;
	virtual bool					GetModelKeyValue( const model_t *model, CUtlBuffer &buf ) = 0; // supports keyvalue blocks in submodels
	virtual float					GetModelRadius( const model_t *model ) = 0;

	virtual const studiohdr_t		*FindModel( const studiohdr_t *pStudioHdr, void **cache, const char *modelname ) const = 0;
	virtual const studiohdr_t		*FindModel( void *cache ) const = 0;
	virtual	virtualmodel_t			*GetVirtualModel( const studiohdr_t *pStudioHdr ) const = 0;
	virtual byte					*GetAnimBlock( const studiohdr_t *pStudioHdr, int iBlock ) const = 0;
	virtual bool					HasAnimBlockBeenPreloaded( studiohdr_t const*, int ) const = 0;

	// Available on Client only!!!
	virtual void					GetModelMaterialColorAndLighting( const model_t *model, Vector const& origin,
																	  QAngle const& angles, trace_t* pTrace,
																	  Vector& lighting, Vector& matColor ) = 0;
	virtual void					GetIlluminationPoint( const model_t *model, IClientRenderable *pRenderable, Vector const& origin,
														  QAngle const& angles, Vector* pLightingCenter ) = 0;

	virtual int						GetModelContents( int modelIndex ) const = 0;
	virtual void					_pad30() = 0;
	virtual void					_pad31() = 0;
	virtual studiohdr_t				*GetStudioModel( const model_t *mod ) = 0;
	virtual int						GetModelSpriteWidth( const model_t *model ) const = 0;
	virtual int						GetModelSpriteHeight( const model_t *model ) const = 0;

	// Sets/gets a map-specified fade range (Client only)
	virtual void					SetLevelScreenFadeRange( float flMinSize, float flMaxSize ) = 0;
	virtual void					GetLevelScreenFadeRange( float *pMinArea, float *pMaxArea ) const = 0;

	// Sets/gets a map-specified per-view fade range (Client only)
	virtual void					SetViewScreenFadeRange( float flMinSize, float flMaxSize ) = 0;

	// Computes fade alpha based on distance fade + screen fade (Client only)
	virtual unsigned char			ComputeLevelScreenFade( const Vector &vecAbsOrigin, float flRadius, float flFadeScale ) const = 0;
	virtual unsigned char			ComputeViewScreenFade( const Vector &vecAbsOrigin, float flRadius, float flFadeScale ) const = 0;

	// both Client and server
	virtual int						GetAutoplayList( const studiohdr_t *pStudioHdr, unsigned short **pAutoplayList ) const = 0;

	// Gets a virtual terrain collision model (creates if necessary)
	// NOTE: This may return NULL if the terrain model cannot be virtualized
	virtual CPhysCollide			*GetCollideForVirtualTerrain( int index ) = 0;
	virtual bool					IsUsingFBTexture( const model_t *model, int nSkin, int nBody, void /*IClientRenderable*/ *pClientRenderable ) const = 0;
	virtual const model_t			*FindOrLoadModel( const char *name ) const = 0;
	virtual MDLHandle_t				GetCacheHandle( const model_t *model ) const = 0;
	// Returns planes of non-nodraw brush model surfaces
	virtual int						GetBrushModelPlaneCount( const model_t *model ) const = 0;
	virtual void					GetBrushModelPlane( const model_t *model, int nIndex, cplane_t &plane, Vector *pOrigin ) const = 0;
	virtual int						GetSurfacepropsForVirtualTerrain( int index ) = 0;
	virtual bool					UsesEnvCubemap( const model_t *model ) const = 0;
	virtual bool					UsesStaticLighting( const model_t *model ) const = 0;
};

extern IVModelInfo* g_pModelInfo;


class IVModelInfoClient : public IVModelInfo
{
public:
};


struct virtualterrainparams_t
{
	// UNDONE: Add grouping here, specified in BSP file? (test grouping to see if this is necessary)
	int index;
};
#endif
```

`Lumina/Lumina/sdk/interfaces/IVModelRender.h`:

```h
#pragma once

struct model_t
{
	char        name[ 255 ];
};
typedef unsigned short ModelInstanceHandle_t;

enum modtype_t
{
	mod_bad = 0,
	mod_brush,
	mod_sprite,
	mod_studio
};

struct ModelRenderInfo_t
{
	Vector origin;
	QAngle angles;
	char pad[ 0x4 ];
	void *pRenderable;
	const model_t *pModel;
	const matrix3x4_t *pModelToWorld;
	const matrix3x4_t *pLightingOffset;
	const Vector *pLightingOrigin;
	int flags;
	int entity_index;
	int skin;
	int body;
	int hitboxset;
	ModelInstanceHandle_t instance;
	ModelRenderInfo_t()
	{
		pModelToWorld = NULL;
		pLightingOffset = NULL;
		pLightingOrigin = NULL;
	}
};

typedef void* StudioDecalHandle_t;

struct studiohwdata_t;
struct DrawModelState_t
{
	studiohdr_t*			m_pStudioHdr;
	studiohwdata_t*			m_pStudioHWData;
	IClientRenderable*		m_pRenderable;
	const matrix3x4_t		*m_pModelToWorld;
	StudioDecalHandle_t		m_decals;
	int						m_drawFlags;
	int						m_lod;
};

class IMatRenderContext;
class IVModelRender
{
public:
	VFUNC( 1, ForcedMaterialOverride( IMaterial *mat = nullptr, OverrideType_t type = OVERRIDE_NORMAL ), void( __thiscall* )( void*, IMaterial*, OverrideType_t, int ) )( mat, type, 0 )
	VFUNC( 2, IsForcedMaterialOverride(), bool(__thiscall*)(void*))()
	VFUNC( 21, DrawModelExecute( IMatRenderContext* context, const DrawModelState_t& state, const ModelRenderInfo_t& info, matrix3x4_t* pCustomBoneToWorld = nullptr ), void( __thiscall* )( void*, IMatRenderContext*, const DrawModelState_t&, const ModelRenderInfo_t&, matrix3x4_t* ) )( context, state, info, pCustomBoneToWorld )
};

extern IVModelRender* g_pModelRender;
```

`Lumina/Lumina/sdk/interfaces/IVPanel.h`:

```h
#pragma once

class IVPanel
{
public:
	VFUNC( 36, GetName( int panel ), const char*( __thiscall* )( void*, int ) )( panel )
	VFUNC( 32, SetMouseInputEnabled( unsigned int panel, bool state ), void( __thiscall* )( PVOID, int, bool ) )( panel, state )
};

extern IVPanel* g_pPanel;
```

`Lumina/Lumina/sdk/interfaces/IVRenderView.h`:

```h
#pragma once

class IWorldRenderList
{
};

struct VisibleFogVolumeInfo_t
{
	int		m_nVisibleFogVolume;
	int		m_nVisibleFogVolumeLeaf;
	bool	m_bEyeInFogVolume;
	float	m_flDistanceToWater;
	float	m_flWaterHeight;
	IMaterial *m_pFogVolumeMaterial;
};

typedef unsigned short LeafIndex_t;
enum
{
	INVALID_LEAF_INDEX = ( LeafIndex_t )~0
};

struct WorldListLeafData_t
{
	LeafIndex_t	leafIndex;	// 16 bits
	int16	waterData;
	uint16 	firstTranslucentSurface;	// engine-internal list index
	uint16	translucentSurfaceCount;	// count of translucent surfaces+disps
};

struct WorldListInfo_t
{
	int		m_ViewFogVolume;
	int		m_LeafCount;
	bool	m_bHasWater;
	WorldListLeafData_t	*m_pLeafDataList;
};

struct VisOverrideData_t
{
	Vector		m_vecVisOrigin;					// The point to to use as the viewpoint for area portal backface cull checks.
	float		m_fDistToAreaPortalTolerance;	// The distance from an area portal before using the full screen as the viewable portion.
};

struct BrushVertex_t
{
	Vector		m_Pos;
	Vector		m_Normal;
	Vector		m_TangentS;
	Vector		m_TangentT;
	Vector2D	m_TexCoord;
	Vector2D	m_LightmapCoord;

private:
	BrushVertex_t( const BrushVertex_t& src );
};

class IBrushSurface
{
public:
	// Computes texture coordinates + lightmap coordinates given a world position
	virtual void ComputeTextureCoordinate( Vector const& worldPos, Vector2D& texCoord ) = 0;
	virtual void ComputeLightmapCoordinate( Vector const& worldPos, Vector2D& lightmapCoord ) = 0;

	// Gets the vertex data for this surface
	virtual int  GetVertexCount() const = 0;
	virtual void GetVertexData( BrushVertex_t* pVerts ) = 0;

	// Gets at the material properties for this surface
	virtual IMaterial* GetMaterial() = 0;
};

class IBrushRenderer
{
public:
	// Draws the surface; returns true if decals should be rendered on this surface
	virtual bool RenderBrushModelSurface( C_BaseEntity* pBaseEntity, IBrushSurface* pBrushSurface ) = 0;
};


class IVRenderView
{
public:

	// Draw normal brush model.
	// If pMaterialOverride is non-null, then all the faces of the bmodel will
	// set this material rather than their regular material.
	virtual void			DrawBrushModel( C_BaseEntity *baseentity, model_t *model, const Vector& origin, const QAngle& angles, bool sort ) = 0;

	// Draw brush model that has no origin/angles change ( uses identity transform )
	// FIXME, g_pMaterial proxy IClientEntity *baseentity is unused right now, use DrawBrushModel for brushes with
	//  proxies for now.
	virtual void			DrawIdentityBrushModel( IWorldRenderList *pList, model_t *model ) = 0;

	// Mark this dynamic light as having changed this frame ( so light maps affected will be recomputed )
	virtual void			TouchLight( struct dlight_t *light ) = 0;
	// Draw 3D Overlays
	virtual void			Draw3DDebugOverlays( void ) = 0;
	// Sets global blending fraction
	virtual void			SetBlend( float blend ) = 0;
	virtual float			GetBlend( void ) = 0;

	// Sets global color modulation
	virtual void			SetColorModulation( float const* blend ) = 0;
	virtual void			GetColorModulation( float* blend ) = 0;

	// Wrap entire scene drawing
	virtual void			SceneBegin( void ) = 0;
	virtual void			SceneEnd( void ) = 0;

	// Gets the fog volume for a particular point
	virtual void			GetVisibleFogVolume( const Vector& eyePoint, VisibleFogVolumeInfo_t *pInfo ) = 0;

	// Wraps world drawing
	// If iForceViewLeaf is not -1, then it uses the specified leaf as your starting area for setting up area portal culling.
	// This is used by water since your reflected view origin is often in solid space, but we still want to treat it as though
	// the first portal we're looking out of is a water portal, so our view effectively originates under the water.
	virtual IWorldRenderList * CreateWorldList() = 0;

	virtual void			BuildWorldLists( IWorldRenderList *pList, WorldListInfo_t* pInfo, int iForceFViewLeaf, const VisOverrideData_t* pVisData = NULL, bool bShadowDepth = false, float *pReflectionWaterHeight = NULL ) = 0;
	virtual void			DrawWorldLists( IWorldRenderList *pList, unsigned long flags, float waterZAdjust ) = 0;
	virtual int				GetNumIndicesForWorldLists( IWorldRenderList *pList, unsigned long nFlags ) = 0;

	// Optimization for top view
	virtual void			DrawTopView( bool enable ) = 0;
	virtual void			TopViewBounds( Vector2D const& mins, Vector2D const& maxs ) = 0;

	// Draw lights
	virtual void			DrawLights( void ) = 0;
	// FIXME:  This function is a stub, doesn't do anything in the engine right now
	virtual void			DrawMaskEntities( void ) = 0;

	// Draw surfaces with alpha, don't call in shadow depth pass
	virtual void			DrawTranslucentSurfaces( IWorldRenderList *pList, int *pSortList, int sortCount, unsigned long flags ) = 0;

	// Draw Particles ( just draws the linefine for debugging map leaks )
	virtual void			DrawLineFile( void ) = 0;
	// Draw lightmaps
	virtual void			DrawLightmaps( IWorldRenderList *pList, int pageId ) = 0;
	// Wraps view render sequence, sets up a view
	virtual void			ViewSetupVis( bool novis, int numorigins, const Vector origin[] ) = 0;

	// Return true if any of these leaves are visible in the current PVS.
	virtual bool			AreAnyLeavesVisible( int *leafList, int nLeaves ) = 0;

	virtual	void			VguiPaint( void ) = 0;
	// Sets up view fade parameters
	virtual void			ViewDrawFade( byte *color, IMaterial *pMaterial ) = 0;
	// Sets up the projection matrix for the specified field of view
	virtual void			OLD_SetProjectionMatrix( float fov, float zNear, float zFar ) = 0;
	// Determine lighting at specified position
	virtual colorVec		GetLightAtPoint( Vector& pos ) = 0;
	// Whose eyes are we looking through?
	virtual int				GetViewEntity( void ) = 0;
	virtual bool			IsViewEntity( int entindex ) = 0;
	// Get engine field of view setting
	virtual float			GetFieldOfView( void ) = 0;
	// 1 == ducking, 0 == not
	virtual unsigned char	**GetAreaBits( void ) = 0;

	// Set up fog for a particular leaf
	virtual void			SetFogVolumeState( int nVisibleFogVolume, bool bUseHeightFog ) = 0;

	// Installs a brush surface draw override method, null means use normal renderer
	virtual void			InstallBrushSurfaceRenderer( IBrushRenderer* pBrushRenderer ) = 0;

	// Draw brush model shadow
	virtual void			DrawBrushModelShadow( IClientRenderable *pRenderable ) = 0;

	// Does the leaf contain translucent surfaces?
	virtual	bool			LeafContainsTranslucentSurfaces( IWorldRenderList *pList, int sortIndex, unsigned long flags ) = 0;

	virtual bool			DoesBoxIntersectWaterVolume( const Vector &mins, const Vector &maxs, int leafWaterDataID ) = 0;

	virtual void			SetAreaState( unsigned char chAreaBits[ MAX_AREA_STATE_BYTES ], unsigned char chAreaPortalBits[ MAX_AREA_PORTAL_STATE_BYTES ] ) = 0;

	// See i
	virtual void			VGui_Paint( int mode ) = 0;
};

extern IVRenderView* g_pRenderView;
```

`Lumina/Lumina/sdk/interfaces/IViewRender.h`:

```h
#pragma once

class IViewRender
{
public:
	virtual void		Init( void ) = 0;

	// Clear any systems between levels
	virtual void		LevelInit( void ) = 0;
	virtual void		LevelShutdown( void ) = 0;

	// Shutdown
	virtual void		Shutdown( void ) = 0;

	// RENDERING
	// Called right before simulation. It must setup the view model origins and angles here so 
	// the correct attachment points can be used during simulation.	
	virtual void		OnRenderStart() = 0;

	// Called to render the entire scene
	virtual	void		Render( void *rect ) = 0;

	// Called to render just a particular setup ( for timerefresh and envmap creation )
	virtual void		RenderView( const CViewSetup &view, int nClearFlags, int whatToDraw ) = 0;

	// What are we currently rendering? Returns a combination of DF_ flags.
	virtual int GetDrawFlags() = 0;

	// MISC
	// Start and stop pitch drifting logic
	virtual void		StartPitchDrift( void ) = 0;
	virtual void		StopPitchDrift( void ) = 0;
};

extern IViewRender* g_pViewRender;
```

`Lumina/Lumina/sdk/interfaces/IViewRenderBeams.h`:

```h
#pragma once

enum
{
	TE_BEAMPOINTS = 0x00,		// beam effect between two points
	TE_SPRITE = 0x01,	// additive sprite, plays 1 cycle
	TE_BEAMDISK = 0x02,	// disk that expands to max radius over lifetime
	TE_BEAMCYLINDER = 0x03,		// cylinder that expands to max radius over lifetime
	TE_BEAMFOLLOW = 0x04,		// create a line of decaying beam segments until entity stops moving
	TE_BEAMRING = 0x05,		// connect a beam ring to two entities
	TE_bmsPLINE = 0x06,
	TE_BEAMRINGPOINT = 0x07,
	TE_BEAMLASER = 0x08,		// Fades according to viewpoint
	TE_BEAMTESLA = 0x09,
};
enum
{
	FBEAM_STARTENTITY = 0x00000001,
	FBEAM_ENDENTITY = 0x00000002,
	FBEAM_FADEIN = 0x00000004,
	FBEAM_FADEOUT = 0x00000008,
	FBEAM_SINENOISE = 0x00000010,
	FBEAM_SOLID = 0x00000020,
	FBEAM_SHADEIN = 0x00000040,
	FBEAM_SHADEOUT = 0x00000080,
	FBEAM_ONLYNOISEONCE = 0x00000100,		// Only calculate our noise once
	FBEAM_NOTILE = 0x00000200,
	FBEAM_USE_HITBOXES = 0x00000400,		// Attachment indices represent hitbox indices instead when this is set.
	FBEAM_STARTVISIBLE = 0x00000800,		// Has this client actually seen this beam's start entity yet?
	FBEAM_ENDVISIBLE = 0x00001000,		// Has this client actually seen this beam's end entity yet?
	FBEAM_ISACTIVE = 0x00002000,
	FBEAM_FOREVER = 0x00004000,
	FBEAM_HALOBEAM = 0x00008000,		// When drawing a beam with a halo, don't ignore the segments and endwidth
	FBEAM_REVERSED = 0x00010000,
	NUM_BEAM_FLAGS = 17	// KEEP THIS UPDATED!
};

struct BeamTrail_t
{
	// NOTE:  Don't add user defined fields except after these four fields.
	BeamTrail_t*	next;
	float			die;
	Vector			org;
	Vector			vel;
};

#define NOISE_DIVISIONS		128
#define MAX_BEAM_ENTS		10


typedef int pixelvis_handle_t;

class Beam_t
{
public:
	Beam_t();

	// Methods of IClientRenderable
	virtual const Vector&	GetRenderOrigin( void ) = 0;
	virtual const QAngle&	GetRenderAngles( void ) = 0;
	virtual const matrix3x4_t &RenderableToWorldTransform() = 0;
	virtual void			GetRenderBounds( Vector& mins, Vector& maxs ) = 0;
	virtual bool			ShouldDraw( void ) = 0;
	virtual bool			IsTransparent( void ) = 0;
	virtual int				DrawModel( int flags ) = 0;
	virtual void			ComputeFxBlend() = 0;
	virtual int				GetFxBlend() = 0;

	// Resets the beam state
	void			Reset();

	// Method to computing the bounding box
	void			ComputeBounds();

	// Bounding box...
	Vector			m_Mins;
	Vector			m_Maxs;
	pixelvis_handle_t *m_queryHandleHalo;
	float			m_haloProxySize;

	// Data is below..

	// Next beam in list
	Beam_t*			next;

	// Type of beam
	int				type;
	int				flags;

	// Control points for the beam
	int				numAttachments;
	Vector			attachment[ MAX_BEAM_ENTS ];
	Vector			delta;

	// 0 .. 1 over lifetime of beam
	float			t;
	float			freq;

	// Time when beam should die
	float			die;
	float			width;
	float			endWidth;
	float			fadeLength;
	float			amplitude;
	float			life;

	// Color
	float			r, g, b;
	float			brightness;

	// Speed
	float			speed;

	// Animation
	float			frameRate;
	float			frame;
	int				segments;

	// Attachment entities for the beam
	HANDLE			entity[ MAX_BEAM_ENTS ];
	int				attachmentIndex[ MAX_BEAM_ENTS ];

	// Model info
	int				modelIndex;
	int				haloIndex;

	float			haloScale;
	int				frameCount;

	float			rgNoise[ NOISE_DIVISIONS + 1 ];

	// Popcorn trail for beam follows to use
	BeamTrail_t*	trail;

	// for TE_BEAMRINGPOINT
	float			start_radius;
	float			end_radius;

	// for FBEAM_ONLYNOISEONCE
	bool			m_bCalculatedNoise;

	float			m_flHDRColorScale;

};

struct BeamInfo_t
{
	//Beam
	int				m_nType;
	C_BaseEntity*	m_pStartEnt;
	int				m_nStartAttachment;
	C_BaseEntity*	m_pEndEnt;
	int				m_nEndAttachment;
	Vector			m_vecStart;
	Vector			m_vecEnd;
	int				m_nModelIndex;
	const char*		m_pszModelName;
	int				m_nHaloIndex;
	const char*		m_pszHaloName;
	float			m_flHaloScale;
	float			m_flLife;
	float			m_flWidth;
	float			m_flEndWidth;
	float			m_flFadeLength;
	float			m_flAmplitude;
	float			m_flBrightness;
	float			m_flSpeed;
	int				m_nStartFrame;
	float			m_flFrameRate;
	float			m_flRed;
	float			m_flGreen;
	float			m_flBlue;
	bool			m_bRenderable;
	int				m_nSegments;
	int				m_nFlags;
	// Rings
	Vector			m_vecCenter;
	float			m_flStartRadius;
	float			m_flEndRadius;

	BeamInfo_t()
	{
		m_nType = TE_BEAMPOINTS;
		m_nSegments = -1;
		m_pszModelName = NULL;
		m_pszHaloName = NULL;
		m_nModelIndex = -1;
		m_nHaloIndex = -1;
		m_bRenderable = true;
		m_nFlags = 0;
	}
};

class C_Beam;
class ITraceFilter;
class IViewRenderBeams
{
public:
	virtual void	InitBeams( void ) = 0;
	virtual void	ShutdownBeams( void ) = 0;
	virtual void	ClearBeams( void ) = 0;

	// Updates the state of the temp ent beams
	virtual void	UpdateTempEntBeams() = 0;

	virtual void	DrawBeam( C_Beam* pbeam, ITraceFilter *pEntityBeamTraceFilter = NULL ) = 0;
	virtual void	DrawBeam( Beam_t *pbeam ) = 0;

	virtual void	KillDeadBeams( C_BaseEntity *pEnt ) = 0;

	// New interfaces!
	virtual Beam_t	*CreateBeamEnts( BeamInfo_t &beamInfo ) = 0;
	virtual Beam_t	*CreateBeamEntPoint( BeamInfo_t &beamInfo ) = 0;
	virtual	Beam_t	*CreateBeamPoints( BeamInfo_t &beamInfo ) = 0;
	virtual Beam_t	*CreateBeamRing( BeamInfo_t &beamInfo ) = 0;
	virtual Beam_t	*CreateBeamRingPoint( BeamInfo_t &beamInfo ) = 0;
	virtual Beam_t	*CreateBeamCirclePoints( BeamInfo_t &beamInfo ) = 0;
	virtual Beam_t	*CreateBeamFollow( BeamInfo_t &beamInfo ) = 0;

	virtual void	FreeBeam( Beam_t *pBeam ) = 0;
	virtual void	UpdateBeamInfo( Beam_t *pBeam, BeamInfo_t &beamInfo ) = 0;

	// These will go away!
	virtual void	CreateBeamEnts( int startEnt, int endEnt, int modelIndex, int haloIndex, float haloScale,
									float life, float width, float m_nEndWidth, float m_nFadeLength, float amplitude,
									float brightness, float speed, int startFrame,
									float framerate, float r, float g, float b, int type = -1 ) = 0;
	virtual void	CreateBeamEntPoint( int	nStartEntity, const Vector *pStart, int nEndEntity, const Vector* pEnd,
										int modelIndex, int haloIndex, float haloScale,
										float life, float width, float m_nEndWidth, float m_nFadeLength, float amplitude,
										float brightness, float speed, int startFrame,
										float framerate, float r, float g, float b ) = 0;
	virtual void	CreateBeamPoints( Vector& start, Vector& end, int modelIndex, int haloIndex, float haloScale,
									  float life, float width, float m_nEndWidth, float m_nFadeLength, float amplitude,
									  float brightness, float speed, int startFrame,
									  float framerate, float r, float g, float b ) = 0;
	virtual void	CreateBeamRing( int startEnt, int endEnt, int modelIndex, int haloIndex, float haloScale,
									float life, float width, float m_nEndWidth, float m_nFadeLength, float amplitude,
									float brightness, float speed, int startFrame,
									float framerate, float r, float g, float b, int flags = 0 ) = 0;
	virtual void	CreateBeamRingPoint( const Vector& center, float start_radius, float end_radius, int modelIndex, int haloIndex, float haloScale,
										 float life, float width, float m_nEndWidth, float m_nFadeLength, float amplitude,
										 float brightness, float speed, int startFrame,
										 float framerate, float r, float g, float b, int flags = 0 ) = 0;
	virtual void	CreateBeamCirclePoints( int type, Vector& start, Vector& end,
											int modelIndex, int haloIndex, float haloScale, float life, float width,
											float m_nEndWidth, float m_nFadeLength, float amplitude, float brightness, float speed,
											int startFrame, float framerate, float r, float g, float b ) = 0;
	virtual void	CreateBeamFollow( int startEnt, int modelIndex, int haloIndex, float haloScale,
									  float life, float width, float m_nEndWidth, float m_nFadeLength, float r, float g, float b,
									  float brightness ) = 0;
};

extern IViewRenderBeams* g_pBeams;
```

`Lumina/Lumina/sdk/interfaces/IWeaponSystem.h`:

```h
#pragma once

/*
class IWeaponSystem
{
	virtual void unused0() = 0;
	virtual void unused1() = 0;
public:
	virtual CCSWeaponData* GetWpnData( unsigned ItemDefinitionIndex ) = 0;
};

extern IWeaponSystem* g_pWeaponSystem;*/
```

`Lumina/Lumina/sdk/math/CUtlVector.h`:

```h
#pragma once

inline int UtlMemory_CalcNewAllocationCount( int nAllocationCount, int nGrowSize, int nNewSize, int nBytesItem )
{
	if ( nGrowSize )
	{
		nAllocationCount = ( ( 1 + ( ( nNewSize - 1 ) / nGrowSize ) ) * nGrowSize );
	}
	else
	{
		if ( !nAllocationCount )
		{
			// Compute an allocation which is at least as big as a cache line...
			nAllocationCount = ( 31 + nBytesItem ) / nBytesItem;
		}

		while ( nAllocationCount < nNewSize )
		{
			nAllocationCount *= 2;
		}
	}

	return nAllocationCount;
}

template <class T, class I = int> class CUtlMemory
{
public:
	inline bool IsIdxValid( I i ) const
	{
		long x = i;
		return ( x >= 0 ) && ( x < m_nAllocationCount );
	}
	T& operator[]( I i );
	const T& operator[]( I i ) const;
	T *Base()
	{
		return m_pMemory;
	}
	inline int NumAllocated() const
	{
		return m_nAllocationCount;
	}
	void Grow( int num )
	{
		Assert( num > 0 );

		auto oldAllocationCount = m_nAllocationCount;
		// Make sure we have at least numallocated + num allocations.
		// Use the grow rules specified for this memory (in m_nGrowSize)
		int nAllocationRequested = m_nAllocationCount + num;

		int nNewAllocationCount = UtlMemory_CalcNewAllocationCount( m_nAllocationCount, m_nGrowSize, nAllocationRequested, sizeof( T ) );

		// if m_nAllocationRequested wraps index type I, recalculate
		if ( ( int )( I )nNewAllocationCount < nAllocationRequested )
		{
			if ( ( int )( I )nNewAllocationCount == 0 && ( int )( I )( nNewAllocationCount - 1 ) >= nAllocationRequested )
			{
				--nNewAllocationCount; // deal w/ the common case of m_nAllocationCount == MAX_USHORT + 1
			}
			else
			{
				if ( ( int )( I )nAllocationRequested != nAllocationRequested )
				{
					// we've been asked to grow memory to a size s.t. the index type can't address the requested amount of memory
					Assert( 0 );
					return;
				}
				while ( ( int )( I )nNewAllocationCount < nAllocationRequested )
				{
					nNewAllocationCount = ( nNewAllocationCount + nAllocationRequested ) / 2;
				}
			}
		}

		m_nAllocationCount = nNewAllocationCount;

		if ( m_pMemory )
		{
			auto ptr = new unsigned char[ m_nAllocationCount * sizeof( T ) ];

			memcpy( ptr, m_pMemory, oldAllocationCount * sizeof( T ) );
			m_pMemory = ( T* )ptr;
		}
		else
		{
			m_pMemory = ( T* )new unsigned char[ m_nAllocationCount * sizeof( T ) ];
		}
	}
protected:
	T * m_pMemory;
	int m_nAllocationCount;
	int m_nGrowSize;
};

template< class T, class I >
inline T& CUtlMemory<T, I>::operator[]( I i )
{
	Assert( IsIdxValid( i ) );
	return m_pMemory[ i ];
}

template< class T, class I >
inline const T& CUtlMemory<T, I>::operator[]( I i ) const
{
	Assert( IsIdxValid( i ) );
	return m_pMemory[ i ];
}

template <class T>
inline void Destruct( T *pMemory )
{
	pMemory->~T();
}

template <class T>
inline T* Construct( T* pMemory )
{
	return ::new( pMemory ) T;
}

template< typename T, size_t SIZE, int nAlignment = 0 >
class CUtlMemoryFixed
{
public:
	// constructor, destructor
	CUtlMemoryFixed( int nGrowSize = 0, int nInitSize = 0 ) { Assert( nInitSize == 0 || nInitSize == SIZE ); }
	CUtlMemoryFixed( T* pMemory, int numElements ) { Assert( 0 ); }

	// Can we use this index?
	// Use unsigned math to improve performance
	bool IsIdxValid( int i ) const { return ( size_t )i < SIZE; }

	// Specify the invalid ('null') index that we'll only return on failure
	static const int INVALID_INDEX = -1; // For use with COMPILE_TIME_Assert
	static int InvalidIndex() { return INVALID_INDEX; }

	// Gets the base address
	T* Base() { if ( nAlignment == 0 ) return ( T* )( &m_Memory[ 0 ] ); else return ( T* )AlignValue( &m_Memory[ 0 ], nAlignment ); }
	const T* Base() const { if ( nAlignment == 0 ) return ( T* )( &m_Memory[ 0 ] ); else return ( T* )AlignValue( &m_Memory[ 0 ], nAlignment ); }

	// element access
	// Use unsigned math and inlined checks to improve performance.
	T& operator[]( int i ) { Assert( ( size_t )i < SIZE ); return Base()[ i ]; }
	const T& operator[]( int i ) const { Assert( ( size_t )i < SIZE ); return Base()[ i ]; }
	T& Element( int i ) { Assert( ( size_t )i < SIZE ); return Base()[ i ]; }
	const T& Element( int i ) const { Assert( ( size_t )i < SIZE ); return Base()[ i ]; }

	// Attaches the buffer to external memory....
	void SetExternalBuffer( T* pMemory, int numElements ) { Assert( 0 ); }

	// Size
	int NumAllocated() const { return SIZE; }
	int Count() const { return SIZE; }

	// Grows the memory, so that at least allocated + num elements are allocated
	void Grow( int num = 1 ) { Assert( 0 ); }

	// Makes sure we've got at least this much memory
	void EnsureCapacity( int num ) { Assert( num <= SIZE ); }

	// Memory deallocation
	void Purge() {}

	// Purge all but the given number of elements (NOT IMPLEMENTED IN CUtlMemoryFixed)
	void Purge( int numElements ) { Assert( 0 ); }

	// is the memory externally allocated?
	bool IsExternallyAllocated() const { return false; }

	// Set the size by which the memory grows
	void SetGrowSize( int size ) {}

	class Iterator_t
	{
	public:
		Iterator_t( int i ) : index( i ) {}
		int index;
		bool operator==( const Iterator_t it ) const { return index == it.index; }
		bool operator!=( const Iterator_t it ) const { return index != it.index; }
	};
	Iterator_t First() const { return Iterator_t( IsIdxValid( 0 ) ? 0 : InvalidIndex() ); }
	Iterator_t Next( const Iterator_t &it ) const { return Iterator_t( IsIdxValid( it.index + 1 ) ? it.index + 1 : InvalidIndex() ); }
	int GetIndex( const Iterator_t &it ) const { return it.index; }
	bool IsIdxAfter( int i, const Iterator_t &it ) const { return i > it.index; }
	bool IsValidIterator( const Iterator_t &it ) const { return IsIdxValid( it.index ); }
	Iterator_t InvalidIterator() const { return Iterator_t( InvalidIndex() ); }

private:
	char m_Memory[ SIZE * sizeof( T ) + nAlignment ];
};

template< class T, class A = CUtlMemory<T> >
class CUtlVector
{
	typedef A CAllocator;

	typedef T *iterator;
	typedef const T *const_iterator;
public:
	T & operator[]( int i );
	const T& operator[]( int i ) const;

	T& Element( int i )
	{
		return m_Memory[ i ];
	}

	T* Base()
	{
		return m_Memory.Base();
	}

	int Count() const
	{
		return m_Size;
	}

	void RemoveAll()
	{
		for ( int i = m_Size; --i >= 0; )
			Destruct( &Element( i ) );

		m_Size = 0;
	}

	inline bool IsValidIndex( int i ) const
	{
		return ( i >= 0 ) && ( i < m_Size );
	}

	void GrowVector( int num = 1 )
	{
		if ( m_Size + num > m_Memory.NumAllocated() )
		{
			m_Memory.Grow( m_Size + num - m_Memory.NumAllocated() );
		}

		m_Size += num;
	}

	iterator begin() { return Base(); }
	const_iterator begin() const { return Base(); }
	iterator end() { return Base() + Count(); }
	const_iterator end() const { return Base() + Count(); }

protected:
	CAllocator m_Memory;
	int m_Size;
	T *m_pElements;
};

template< typename T, class A >
inline T& CUtlVector<T, A>::operator[]( int i )
{
	Assert( i < m_Size );
	return m_Memory[ i ];
}

template< typename T, class A >
inline const T& CUtlVector<T, A>::operator[]( int i ) const
{
	Assert( i < m_Size );
	return m_Memory[ i ];
}

template< class T, size_t MAX_SIZE >
class CUtlVectorFixed : public CUtlVector< T, CUtlMemoryFixed<T, MAX_SIZE > >
{
	typedef CUtlVector< T, CUtlMemoryFixed<T, MAX_SIZE > > BaseClass;
public:

	// constructor, destructor
	explicit CUtlVectorFixed( int growSize = 0, int initSize = 0 ) : BaseClass( growSize, initSize ) {}
	explicit CUtlVectorFixed( T* pMemory, int numElements ) : BaseClass( pMemory, numElements ) {}
};

template< class T, class M = CUtlMemory< T > > 
class CUtlStack
{
public:
	// constructor, destructor
	CUtlStack( int growSize = 0, int initSize = 0 );
	~CUtlStack();

	void CopyFrom( const CUtlStack<T, M> &from );

	// element access
	T& operator[]( int i );
	T const& operator[]( int i ) const;
	T& Element( int i );
	T const& Element( int i ) const;

	// Gets the base address (can change when adding elements!)
	T* Base();
	T const* Base() const;

	// Looks at the stack top
	T& Top();
	T const& Top() const;

	// Size
	int Count() const;

	// Is element index valid?
	bool IsIdxValid( int i ) const;

	// Adds an element, uses default constructor
	int Push();

	// Adds an element, uses copy constructor
	int Push( T const& src );

	// Pops the stack
	void Pop();
	void Pop( T& oldTop );
	void PopMultiple( int num );

	// Makes sure we have enough memory allocated to store a requested # of elements
	void EnsureCapacity( int num );

	// Clears the stack, no deallocation
	void Clear();

	// Memory deallocation
	void Purge();

private:
	// Grows the stack allocation
	void GrowStack();

	// For easier access to the elements through the debugger
	void ResetDbgInfo();

	M m_Memory;
	int m_Size;

	// For easier access to the elements through the debugger
	T* m_pElements;
};


//-----------------------------------------------------------------------------
// For easier access to the elements through the debugger
//-----------------------------------------------------------------------------

template< class T, class M >
inline void CUtlStack<T,M>::ResetDbgInfo()
{
	m_pElements = m_Memory.Base();
}

//-----------------------------------------------------------------------------
// constructor, destructor
//-----------------------------------------------------------------------------

template< class T, class M >
CUtlStack<T,M>::CUtlStack( int growSize, int initSize )	: 
	m_Memory(growSize, initSize), m_Size(0)
{
	ResetDbgInfo();
}

template< class T, class M >
CUtlStack<T,M>::~CUtlStack()
{
	Purge();
}


//-----------------------------------------------------------------------------
// copy into
//-----------------------------------------------------------------------------

template< class T, class M >
void CUtlStack<T,M>::CopyFrom( const CUtlStack<T, M> &from )
{
	Purge();
	EnsureCapacity( from.Count() );
	for ( int i = 0; i < from.Count(); i++ )
	{
		Push( from[i] );
	}
}

//-----------------------------------------------------------------------------
// element access
//-----------------------------------------------------------------------------

template< class T, class M >
inline T& CUtlStack<T,M>::operator[]( int i )
{
	Assert( IsIdxValid(i) );
	return m_Memory[i];
}

template< class T, class M >
inline T const& CUtlStack<T,M>::operator[]( int i ) const
{
	Assert( IsIdxValid(i) );
	return m_Memory[i];
}

template< class T, class M >
inline T& CUtlStack<T,M>::Element( int i )
{
	//Assert( IsIdxValid(i) );
	return m_Memory[i];
}

template< class T, class M >
inline T const& CUtlStack<T,M>::Element( int i ) const
{
	Assert( IsIdxValid(i) );
	return m_Memory[i];
}


//-----------------------------------------------------------------------------
// Gets the base address (can change when adding elements!)
//-----------------------------------------------------------------------------

template< class T, class M >
inline T* CUtlStack<T,M>::Base()
{
	return m_Memory.Base();
}

template< class T, class M >
inline T const* CUtlStack<T,M>::Base() const
{
	return m_Memory.Base();
}

//-----------------------------------------------------------------------------
// Returns the top of the stack
//-----------------------------------------------------------------------------

template< class T, class M >
inline T& CUtlStack<T,M>::Top()
{
	Assert( m_Size > 0 );
	return Element(m_Size-1);
}

template< class T, class M >
inline T const& CUtlStack<T,M>::Top() const
{
	Assert( m_Size > 0 );
	return Element(m_Size-1);
}

//-----------------------------------------------------------------------------
// Size
//-----------------------------------------------------------------------------

template< class T, class M >
inline int CUtlStack<T,M>::Count() const
{
	return m_Size;
}


//-----------------------------------------------------------------------------
// Is element index valid?
//-----------------------------------------------------------------------------

template< class T, class M >
inline bool CUtlStack<T,M>::IsIdxValid( int i ) const
{
	return (i >= 0) && (i < m_Size);
}
 
//-----------------------------------------------------------------------------
// Grows the stack
//-----------------------------------------------------------------------------

template< class T, class M >
void CUtlStack<T,M>::GrowStack()
{
	if (m_Size >= m_Memory.NumAllocated())
		m_Memory.Grow();

	++m_Size;

	ResetDbgInfo();
}

//-----------------------------------------------------------------------------
// Makes sure we have enough memory allocated to store a requested # of elements
//-----------------------------------------------------------------------------

template< class T, class M >
void CUtlStack<T,M>::EnsureCapacity( int num )
{
	m_Memory.EnsureCapacity(num);
	ResetDbgInfo();
}


//-----------------------------------------------------------------------------
// Adds an element, uses default constructor
//-----------------------------------------------------------------------------

template< class T, class M >
int CUtlStack<T,M>::Push()
{
	GrowStack();
	Construct( &Element(m_Size-1) );
	return m_Size - 1;
}

//-----------------------------------------------------------------------------
// Adds an element, uses copy constructor
//-----------------------------------------------------------------------------

template< class T, class M >
int CUtlStack<T,M>::Push( T const& src )
{
	GrowStack();
	CopyConstruct( &Element(m_Size-1), src );
	return m_Size - 1;
}


//-----------------------------------------------------------------------------
// Pops the stack
//-----------------------------------------------------------------------------

template< class T, class M >
void CUtlStack<T,M>::Pop()
{
	Assert( m_Size > 0 );
	Destruct( &Element(m_Size-1) );
	--m_Size;
}

template< class T, class M >
void CUtlStack<T,M>::Pop( T& oldTop )
{
	Assert( m_Size > 0 );
	oldTop = Top();
	Pop();
}

template< class T, class M >
void CUtlStack<T,M>::PopMultiple( int num )
{
	Assert( m_Size >= num );
	for ( int i = 0; i < num; ++i )
		Destruct( &Element( m_Size - i - 1 ) );
	m_Size -= num;
}


//-----------------------------------------------------------------------------
// Element removal
//-----------------------------------------------------------------------------

template< class T, class M >
void CUtlStack<T,M>::Clear()
{
	for (int i = m_Size; --i >= 0; )
		Destruct(&Element(i));

	m_Size = 0;
}


//-----------------------------------------------------------------------------
// Memory deallocation
//-----------------------------------------------------------------------------

template< class T, class M >
void CUtlStack<T,M>::Purge()
{
	Clear();
	m_Memory.Purge( );
	ResetDbgInfo();
}
```

`Lumina/Lumina/sdk/math/Color.h`:

```h
#pragma once

#ifndef Color_h

#define Color_h

#include "Vector.h"

class Color
{
public:
	Color()
	{
		*( ( int * )this ) = 0;
	}
	Color( int _r, int _g, int _b )
	{
		SetColor( _r, _g, _b, 255 );
	}
	Color( int _r, int _g, int _b, int _a )
	{
		SetColor( _r, _g, _b, _a );
	}
	Color( float _rgb[ 3 ] )
	{
		SetColor( ( int )( _rgb[ 0 ] * 255.0f ), ( int )( _rgb[ 1 ] * 255.0f ), ( int )( _rgb[ 2 ] * 255.0f ), 255 );
	}
	Color( float _rgb[ 3 ], float _alpha )
	{
		SetColor( ( int )( _rgb[ 0 ] * 255.0f ), ( int )( _rgb[ 1 ] * 255.0f ), ( int )( _rgb[ 2 ] * 255.0f ), ( int )_alpha );
	}

	Color( Color _cl, float _alpha )
	{
		SetColor( ( int )_cl.r(), ( int )_cl.g(), ( int )_cl.b(), ( int )_alpha );
	}

	void SetAlpha(int _a)
	{
		_cl[3] = (unsigned char)_a;
	}

	void SetColor( int _r, int _g, int _b, int _a = 255 )
	{
		_cl[ 0 ] = ( unsigned char )_r;
		_cl[ 1 ] = ( unsigned char )_g;
		_cl[ 2 ] = ( unsigned char )_b;
		_cl[ 3 ] = ( unsigned char )_a;
	}

	void GetColor( int &_r, int &_g, int &_b, int &_a ) const
	{
		_r = _cl[ 0 ];
		_g = _cl[ 1 ];
		_b = _cl[ 2 ];
		_a = _cl[ 3 ];
	}

	void SetRawColor( int color32 )
	{
		*( ( int* )this ) = color32;
	}

	int GetRawColor() const
	{
		return *( ( int* )this );
	}

	int GetD3DColor() const
	{
		return ( ( int )( ( ( ( _cl[ 3 ] ) & 0xff ) << 24 ) | ( ( ( _cl[ 0 ] ) & 0xff ) << 16 ) | ( ( ( _cl[ 1 ] ) & 0xff ) << 8 ) | ( ( _cl[ 2 ] ) & 0xff ) ) );
	}

	inline int r() const { return _cl[ 0 ]; }
	inline int g() const { return _cl[ 1 ]; }
	inline int b() const { return _cl[ 2 ]; }
	inline int a() const { return _cl[ 3 ]; }

	inline float rBase() const { return _cl[ 0 ] / 255.0f; }
	inline float gBase() const { return _cl[ 1 ] / 255.0f; }
	inline float bBase() const { return _cl[ 2 ] / 255.0f; }
	inline float aBase() const { return _cl[ 3 ] / 255.0f; }

	unsigned char &operator[]( int index )
	{
		return _cl[ index ];
	}

	const unsigned char &operator[]( int index ) const
	{
		return _cl[ index ];
	}

	bool operator == ( const Color &rhs ) const
	{
		return ( *( ( int * )this ) == *( ( int * )&rhs ) );
	}

	bool operator != ( const Color &rhs ) const
	{
		return !( operator==( rhs ) );
	}

	Color &operator=( const Color &rhs )
	{
		SetRawColor( rhs.GetRawColor() );
		return *this;
	}

	float* Base()
	{
		float clr[ 3 ];

		clr[ 0 ] = _cl[ 0 ] / 255.0f;
		clr[ 1 ] = _cl[ 1 ] / 255.0f;
		clr[ 2 ] = _cl[ 2 ] / 255.0f;

		return &clr[ 0 ];
	}

	float* BaseNoReduction()
	{
		float clr[3];

		clr[0] = _cl[0];
		clr[1] = _cl[1];
		clr[2] = _cl[2];

		return &clr[0];
	}

	float* BaseAlpha()
	{
		float clr[ 4 ];

		clr[ 0 ] = _cl[ 0 ] / 255.0f;
		clr[ 1 ] = _cl[ 1 ] / 255.0f;
		clr[ 2 ] = _cl[ 2 ] / 255.0f;
		clr[ 3 ] = _cl[ 3 ] / 255.0f;

		return &clr[ 0 ];
	}


	Vector BaseVector()
	{
		return Vector(_cl[0] / 255.0f, _cl[1] / 255.0f, _cl[2] / 255.0f);
	}


	float Hue() const
	{
		if ( _cl[ 0 ] == _cl[ 1 ] && _cl[ 1 ] == _cl[ 2 ] )
		{
			return 0.0f;
		}

		float r = _cl[ 0 ] / 255.0f;
		float g = _cl[ 1 ] / 255.0f;
		float b = _cl[ 2 ] / 255.0f;

		float max = r > g ? r : g > b ? g : b,
			min = r < g ? r : g < b ? g : b;
		float delta = max - min;
		float hue = 0.0f;

		if ( r == max )
		{
			hue = ( g - b ) / delta;
		}
		else if ( g == max )
		{
			hue = 2 + ( b - r ) / delta;
		}
		else if ( b == max )
		{
			hue = 4 + ( r - g ) / delta;
		}
		hue *= 60;

		if ( hue < 0.0f )
		{
			hue += 360.0f;
		}
		return hue;
	}

	float Saturation() const
	{
		float r = _cl[ 0 ] / 255.0f;
		float g = _cl[ 1 ] / 255.0f;
		float b = _cl[ 2 ] / 255.0f;

		float max = r > g ? r : g > b ? g : b,
			min = r < g ? r : g < b ? g : b;
		float l, s = 0;

		if ( max != min )
		{
			l = ( max + min ) / 2;
			if ( l <= 0.5f )
				s = ( max - min ) / ( max + min );
			else
				s = ( max - min ) / ( 2 - max - min );
		}
		return s;
	}

	float Brightness() const
	{
		float r = _cl[ 0 ] / 255.0f;
		float g = _cl[ 1 ] / 255.0f;
		float b = _cl[ 2 ] / 255.0f;

		float max = r > g ? r : g > b ? g : b,
			min = r < g ? r : g < b ? g : b;
		return ( max + min ) / 2;
	}

	static Color FromHSB( float hue, float saturation, float brightness )
	{
		float h = hue == 1.0f ? 0 : hue * 6.0f;
		float f = h - ( int )h;
		float p = brightness * ( 1.0f - saturation );
		float q = brightness * ( 1.0f - saturation * f );
		float t = brightness * ( 1.0f - ( saturation * ( 1.0f - f ) ) );

		if ( h < 1 )
		{
			return Color(
				( unsigned char )( brightness * 255 ),
				( unsigned char )( t * 255 ),
				( unsigned char )( p * 255 )
			);
		}
		else if ( h < 2 )
		{
			return Color(
				( unsigned char )( q * 255 ),
				( unsigned char )( brightness * 255 ),
				( unsigned char )( p * 255 )
			);
		}
		else if ( h < 3 )
		{
			return Color(
				( unsigned char )( p * 255 ),
				( unsigned char )( brightness * 255 ),
				( unsigned char )( t * 255 )
			);
		}
		else if ( h < 4 )
		{
			return Color(
				( unsigned char )( p * 255 ),
				( unsigned char )( q * 255 ),
				( unsigned char )( brightness * 255 )
			);
		}
		else if ( h < 5 )
		{
			return Color(
				( unsigned char )( t * 255 ),
				( unsigned char )( p * 255 ),
				( unsigned char )( brightness * 255 )
			);
		}
		else
		{
			return Color(
				( unsigned char )( brightness * 255 ),
				( unsigned char )( p * 255 ),
				( unsigned char )( q * 255 )
			);
		}
	}

	static Color Red() { return Color( 255, 0, 0 ); }
	static Color Green() { return Color( 0, 255, 0 ); }
	static Color Blue() { return Color( 0, 0, 255 ); }
	static Color LightBlue() { return Color( 100, 100, 255 ); }
	static Color Grey() { return Color( 128, 128, 128 ); }
	static Color DarkGrey() { return Color( 45, 45, 45 ); }
	static Color Black() { return Color( 0, 0, 0 ); }
	static Color White() { return Color( 255, 255, 255 ); }
	static Color Purple() { return Color( 220, 0, 220 ); }
	static Color Pink() { return Color( 255, 105, 180 ); }

	//Menu
	static Color Background() { return Color( 55, 55, 55 ); }
	static Color FrameBorder() { return Color( 80, 80, 80 ); }
	static Color MainText() { return Color( 230, 230, 230 ); }
	static Color HeaderText() { return Color( 49, 124, 230 ); }
	static Color CurrentTab() { return Color( 55, 55, 55 ); }
	static Color Tabs() { return Color( 23, 23, 23 ); }
	static Color Highlight() { return Color( 49, 124, 230 ); }
	static Color ElementBorder() { return Color( 0, 0, 0 ); }
	static Color SliderScroll() { return Color( 78, 143, 230 ); }


private:
	unsigned char _cl[ 4 ];
};

#endif // !Color_h

```

`Lumina/Lumina/sdk/math/QAngle.h`:

```h
#pragma once

class QAngle
{
public:
	float x, y, z;

	QAngle( void );
	QAngle( float X, float Y, float Z );
	QAngle( Vector A );

	void Init( float ix = 0.0f, float iy = 0.0f, float iz = 0.0f );
	void Random( float minVal, float maxVal );

	bool IsValid() const;
	void Invalidate();

	bool IsZero()
	{
		CHECK_VALID( *this );
		if ( this->x == 0.f && this->y == 0.f && this->z == 0.f )
			return true;

		return false;
	}

	float operator[]( int i ) const;
	float& operator[]( int i );

	float* Base();
	float const* Base() const;

	bool operator==( const QAngle& v ) const;
	bool operator!=( const QAngle& v ) const;

	QAngle& operator+=( const QAngle &v );
	QAngle& operator-=( const QAngle &v );
	QAngle& operator*=( float s );
	QAngle& operator/=( float s );

	float   Length() const;
	float   LengthSqr() const;

	QAngle& operator=( const QAngle& src );

	QAngle  operator-( void ) const;

	QAngle  operator+( const QAngle& v ) const;
	QAngle  operator-( const QAngle& v ) const;
	QAngle  operator*( float fl ) const;
	QAngle  operator/( float fl ) const;

	QAngle Clamp();
	QAngle NormalizeNoClamp();
	QAngle Mod( float N );

	inline QAngle Normalize();
};

//-----------------------------------------------------------------------------
// constructors
//-----------------------------------------------------------------------------
inline QAngle::QAngle( void )
{
#ifdef _DEBUG
#ifdef VECTOR_PARANOIA
	// Initialize to NAN to catch errors
	x = y = z = float_NAN;
#endif
#endif
}

inline QAngle::QAngle( float X, float Y, float Z )
{
	x = X; y = Y; z = Z;
	CHECK_VALID( *this );
}

inline QAngle::QAngle( Vector A )
{
	x = A.x;
	y = A.y;
	z = A.z;
}

//-----------------------------------------------------------------------------
// initialization
//-----------------------------------------------------------------------------
inline void QAngle::Init( float ix, float iy, float iz )
{
	x = ix; y = iy; z = iz;
	CHECK_VALID( *this );
}

inline void QAngle::Random( float minVal, float maxVal )
{
	x = minVal + ( ( float )rand() / RAND_MAX ) * ( maxVal - minVal );
	y = minVal + ( ( float )rand() / RAND_MAX ) * ( maxVal - minVal );
	z = minVal + ( ( float )rand() / RAND_MAX ) * ( maxVal - minVal );
	CHECK_VALID( *this );
}

/*
//-----------------------------------------------------------------------------
// IsValid?
//-----------------------------------------------------------------------------

inline bool QAngle::IsValid() const
{
	return std::isfinite( x ) && std::isfinite( y ) && std::isfinite( z );
}

//-----------------------------------------------------------------------------
// Invalidate
//-----------------------------------------------------------------------------

inline void QAngle::Invalidate()
{
	//#ifdef _DEBUG
	//#ifdef VECTOR_PARANOIA
	x = y = z = std::numeric_limits<float>::infinity();
	//#endif
	//#endif
}
*/
//-----------------------------------------------------------------------------
// assignment
//-----------------------------------------------------------------------------
inline QAngle& QAngle::operator=( const QAngle &vOther )
{
	CHECK_VALID( vOther );
	x = vOther.x; y = vOther.y; z = vOther.z;
	return *this;
}

//-----------------------------------------------------------------------------
// comparison
//-----------------------------------------------------------------------------
inline bool QAngle::operator==( const QAngle& src ) const
{
	CHECK_VALID( src );
	CHECK_VALID( *this );
	return ( src.x == x ) && ( src.y == y ) && ( src.z == z );
}

inline bool QAngle::operator!=( const QAngle& src ) const
{
	CHECK_VALID( src );
	CHECK_VALID( *this );
	return ( src.x != x ) || ( src.y != y ) || ( src.z != z );
}

//-----------------------------------------------------------------------------
// standard math operations
//-----------------------------------------------------------------------------
inline QAngle& QAngle::operator+=( const QAngle& v )
{
	CHECK_VALID( *this );
	CHECK_VALID( v );
	x += v.x; y += v.y; z += v.z;
	return *this;
}

inline QAngle& QAngle::operator-=( const QAngle& v )
{
	CHECK_VALID( *this );
	CHECK_VALID( v );
	x -= v.x; y -= v.y; z -= v.z;
	return *this;
}

inline QAngle& QAngle::operator*=( float fl )
{
	x *= fl;
	y *= fl;
	z *= fl;
	CHECK_VALID( *this );
	return *this;
}

inline QAngle& QAngle::operator/=( float fl )
{
	Assert( fl != 0.0f );
	float oofl = 1.0f / fl;
	x *= oofl;
	y *= oofl;
	z *= oofl;
	CHECK_VALID( *this );
	return *this;
}

//-----------------------------------------------------------------------------
// Base address...
//-----------------------------------------------------------------------------
inline float* QAngle::Base()
{
	return ( float* )this;
}

inline float const* QAngle::Base() const
{
	return ( float const* )this;
}

//-----------------------------------------------------------------------------
// Array access
//-----------------------------------------------------------------------------
inline float& QAngle::operator[]( int i )
{
	Assert( ( i >= 0 ) && ( i < 3 ) );
	return ( ( float* )this )[ i ];
}

inline float QAngle::operator[]( int i ) const
{
	Assert( ( i >= 0 ) && ( i < 3 ) );
	return ( ( float* )this )[ i ];
}

//-----------------------------------------------------------------------------
// length
//-----------------------------------------------------------------------------
inline float QAngle::Length() const
{
	CHECK_VALID( *this );
	return ( float )sqrt( LengthSqr() ); //todo replace with fastsqrt
}


inline float QAngle::LengthSqr() const
{
	CHECK_VALID( *this );
	return x * x + y * y;
}

inline QAngle QAngle::operator-( void ) const
{
	return QAngle( -x, -y, -z );
}

inline QAngle QAngle::operator+( const QAngle& v ) const
{
	QAngle res;
	res.x = x + v.x;
	res.y = y + v.y;
	res.z = z + v.z;
	return res;
}

inline QAngle QAngle::operator-( const QAngle& v ) const
{
	QAngle res;
	res.x = x - v.x;
	res.y = y - v.y;
	res.z = z - v.z;
	return res;
}

inline QAngle QAngle::operator*( float fl ) const
{
	QAngle res;
	res.x = x * fl;
	res.y = y * fl;
	res.z = z * fl;
	return res;
}

inline QAngle QAngle::operator/( float fl ) const
{
	QAngle res;
	res.x = x / fl;
	res.y = y / fl;
	res.z = z / fl;
	return res;
}

inline QAngle QAngle::Clamp()
{
	CHECK_VALID( *this );

	if ( this->x < -89.0f )
		this->x = -89.0f;

	if ( this->x > 89.0f )
		this->x = 89.0f;

	while ( this->y < -180.0f )
		this->y += 360.0f;

	while ( this->y > 180.0f )
		this->y -= 360.0f;

	this->z = 0.0f;

	return *this;
}

inline QAngle QAngle::NormalizeNoClamp()
{
	CHECK_VALID( *this );

	this->x -= floorf( this->x / 360.0f + 0.5f ) * 360.0f;

	this->y -= floorf( this->y / 360.0f + 0.5f ) * 360.0f;

	this->z -= floorf( this->z / 360.0f + 0.5f ) * 360.0f;

	return *this;
}

inline QAngle QAngle::Mod( float N )
{
	CHECK_VALID( *this );
	this->x = fmod( x, N );
	this->y = fmod( y, N );
	this->z = fmod( z, N );

	return *this;
}

inline QAngle QAngle::Normalize()
{
	CHECK_VALID( *this );

	QAngle vector;
	float length = this->Length();

	if ( length != 0 )
	{
		vector.x = x / length;
		vector.y = y / length;
		vector.z = z / length;
	}
	else
		vector.x = vector.y = 0.0f; vector.z = 1.0f;

	return vector;
}
```

`Lumina/Lumina/sdk/math/VMatrix.h`:

```h
#pragma once

struct VMatrix
{
	float m[ 4 ][ 4 ];

	inline float* operator[]( int i )
	{
		return m[ i ];
	}

	inline const float* operator[]( int i ) const
	{
		return m[ i ];
	}
};
```

`Lumina/Lumina/sdk/math/Vector.h`:

```h
#pragma once

#ifndef Vector_h

#define Vector_h

#include "../defines.h"
#include <cmath>

class Vector
{
public:
	float x, y, z;
	Vector( void );
	Vector( float X, float Y, float Z );
	void	normalize_aimbot();
	void Init( float ix = 0.0f, float iy = 0.0f, float iz = 0.0f );
	bool IsValid() const;
	float operator[]( int i ) const;
	float& operator[]( int i );
	inline void Zero();
	inline void Rotate2D( const float &f );
	bool operator==( const Vector& v ) const;
	bool operator!=( const Vector& v ) const;
	__forceinline Vector&	operator+=( const Vector &v );
	__forceinline Vector&	operator-=( const Vector &v );
	__forceinline Vector&	operator*=( const Vector &v );
	__forceinline Vector&	operator*=( float s );
	__forceinline Vector&	operator/=( const Vector &v );
	__forceinline Vector&	operator/=( float s );
	__forceinline Vector&	operator+=( float fl );
	__forceinline Vector&	operator-=( float fl );
	__forceinline Vector	operator+( float fl );
	__forceinline Vector	operator-( float fl );
	inline float	Length() const;
	__forceinline float LengthSqr( void ) const
	{
		CHECK_VALID( *this );
		return ( this->x*this->x + this->y*this->y + this->z*this->z );
	}
	bool IsZero( float tolerance = 0.01f ) const
	{
		return ( x > -tolerance && x < tolerance &&
				 y > -tolerance && y < tolerance &&
				 z > -tolerance && z < tolerance );
	}
	float	NormalizeInPlace();
	Vector	Normalize();
	float	NormalizeL();
	inline Vector Normalized() const;
	__forceinline float	DistToSqr( const Vector &vOther ) const;
	__forceinline float	Dist( const Vector &vOther ) const;
	Vector	Cross( const Vector & vOther ) const;
	float	Dot( const Vector& vOther ) const;
	float	Dot( const float* fOther ) const;
	float	Length2D( void ) const;
	float	Length2DSqr( void ) const;
	Vector	Angle( Vector* up = 0 );
	Vector& operator=( const Vector &vOther );
	Vector	operator-( const Vector& v ) const;
	Vector	operator+( const Vector& v ) const;
	Vector	operator*( const Vector& v ) const;
	Vector	operator/( const Vector& v ) const;
	Vector	operator*( float fl ) const;
	Vector	operator/( float fl ) const;
	// Base address...
	float* Base();
	float const* Base() const;
};


inline void Vector::normalize_aimbot() {
	x = std::isfinite(x) ? std::remainderf(x, 360.0f) : 0.0f;
	y = std::isfinite(y) ? std::remainderf(y, 360.0f) : 0.0f;
	z = 0.0f;
}

//===============================================
inline void Vector::Init( float ix, float iy, float iz )
{
	x = ix; y = iy; z = iz;
	CHECK_VALID( *this );
}
//===============================================
inline Vector::Vector( float X, float Y, float Z )
{
	x = X; y = Y; z = Z;
	CHECK_VALID( *this );
}
//===============================================
inline Vector::Vector( void ) {}
//===============================================
inline void Vector::Zero()
{
	x = y = z = 0.0f;
}
//===============================================
inline void Vector::Rotate2D( const float &f )
{
	float _x, _y;

	float s, c;

	float r = f * M_PI / 180.0f;
	s = sin( r );
	c = cos( r );

	_x = x;
	_y = y;

	x = ( _x * c ) - ( _y * s );
	y = ( _x * s ) + ( _y * c );
}
//===============================================
inline void VectorClear( Vector& a )
{
	a.x = a.y = a.z = 0.0f;
}
//===============================================
inline Vector& Vector::operator=( const Vector &vOther )
{
	CHECK_VALID( vOther );
	x = vOther.x; y = vOther.y; z = vOther.z;
	return *this;
}
//===============================================
inline float& Vector::operator[]( int i )
{
	Assert( ( i >= 0 ) && ( i < 3 ) );
	return ( ( float* )this )[ i ];
}
//===============================================
inline float Vector::operator[]( int i ) const
{
	Assert( ( i >= 0 ) && ( i < 3 ) );
	return ( ( float* )this )[ i ];
}
//===============================================
inline bool Vector::operator==( const Vector& src ) const
{
	CHECK_VALID( src );
	CHECK_VALID( *this );
	return ( src.x == x ) && ( src.y == y ) && ( src.z == z );
}
//===============================================
inline bool Vector::operator!=( const Vector& src ) const
{
	CHECK_VALID( src );
	CHECK_VALID( *this );
	return ( src.x != x ) || ( src.y != y ) || ( src.z != z );
}
//===============================================
__forceinline void VectorCopy( const Vector& src, Vector& dst )
{
	CHECK_VALID( src );
	dst.x = src.x;
	dst.y = src.y;
	dst.z = src.z;
}
//===============================================
__forceinline  Vector& Vector::operator+=( const Vector& v )
{
	CHECK_VALID( *this );
	CHECK_VALID( v );
	x += v.x; y += v.y; z += v.z;
	return *this;
}
//===============================================
__forceinline  Vector& Vector::operator-=( const Vector& v )
{
	CHECK_VALID( *this );
	CHECK_VALID( v );
	x -= v.x; y -= v.y; z -= v.z;
	return *this;
}
//===============================================
__forceinline  Vector& Vector::operator*=( float fl )
{
	x *= fl;
	y *= fl;
	z *= fl;
	CHECK_VALID( *this );
	return *this;
}
//===============================================
__forceinline  Vector& Vector::operator*=( const Vector& v )
{
	CHECK_VALID( v );
	x *= v.x;
	y *= v.y;
	z *= v.z;
	CHECK_VALID( *this );
	return *this;
}
//===============================================
__forceinline Vector&	Vector::operator+=( float fl )
{
	x += fl;
	y += fl;
	z += fl;
	CHECK_VALID( *this );
	return *this;
}
//===============================================
__forceinline Vector&	Vector::operator-=( float fl )
{
	x -= fl;
	y -= fl;
	z -= fl;
	CHECK_VALID( *this );
	return *this;
}

//===============================================
__forceinline Vector Vector::operator+( float fl )
{
	return Vector( x + fl, y + fl, z + fl );
}

//===============================================
__forceinline Vector Vector::operator-( float fl )
{
	return Vector( x - fl, y - fl, z - fl );
}
//===============================================
__forceinline  Vector& Vector::operator/=( float fl )
{
	Assert( fl != 0.0f );
	float oofl = 1.0f / fl;
	x *= oofl;
	y *= oofl;
	z *= oofl;
	CHECK_VALID( *this );
	return *this;
}
//===============================================
__forceinline  Vector& Vector::operator/=( const Vector& v )
{
	CHECK_VALID( v );
	Assert( v.x != 0.0f && v.y != 0.0f && v.z != 0.0f );
	x /= v.x;
	y /= v.y;
	z /= v.z;
	CHECK_VALID( *this );
	return *this;
}
//===============================================
inline float Vector::Length( void ) const
{
	CHECK_VALID( *this );

	float root = 0.0f;

	float sqsr = x * x + y * y + z * z;

	__asm sqrtss xmm0, sqsr
	__asm movss root, xmm0

	return root;
}
//===============================================
inline float Vector::Length2D( void ) const
{
	CHECK_VALID( *this );

	float root = 0.0f;

	float sqst = x * x + y * y;

	__asm
	{
		sqrtss xmm0, sqst
		movss root, xmm0
	}

	return root;
}
//===============================================
inline float Vector::Length2DSqr( void ) const
{
	return ( x*x + y * y );
}

//===============================================
inline Vector Vector::Angle( Vector* up )
{
	if ( !x && !y )
		return Vector( 0, 0, 0 );

	float roll = 0;

	if ( up )
	{
		Vector left = ( *up ).Cross( *this );
		roll = atan2f( left.z, ( left.y * x ) - ( left.x * y ) ) * 180.0f / M_PI;
	}

	return Vector( atan2f( -z, sqrt2( x*x + y * y ) ) * 180.0f / M_PI, atan2f( y, x ) * 180.0f / M_PI, roll );
}
//===============================================
inline Vector CrossProduct( const Vector& a, const Vector& b )
{
	return Vector( a.y*b.z - a.z*b.y, a.z*b.x - a.x*b.z, a.x*b.y - a.y*b.x );
}
//===============================================
float Vector::DistToSqr( const Vector &vOther ) const
{
	Vector delta;

	delta.x = x - vOther.x;
	delta.y = y - vOther.y;
	delta.z = z - vOther.z;

	return delta.LengthSqr();
}

float Vector::Dist( const Vector &vOther ) const
{
	Vector delta;

	delta.x = x - vOther.x;
	delta.y = y - vOther.y;
	delta.z = z - vOther.z;

	return delta.Length();
}

inline Vector Vector::Cross( const Vector& vOther ) const
{
	Vector res;
	return CrossProduct( *this, vOther );
}

inline Vector Vector::Normalize()
{
	Vector vector;
	float length = this->Length();

	if ( length != 0 )
	{
		vector.x = x / length;
		vector.y = y / length;
		vector.z = z / length;
	}
	else
		vector.x = vector.y = 0.0f; vector.z = 1.0f;

	return vector;
}

inline float Vector::NormalizeL()
{
	Vector res = *this;
	float length = res.Length();
	if ( length != 0.0f )
		res /= length;
	else
		res.x = res.y = res.z = 0.0f;
	return length;
}


//===============================================
inline float Vector::NormalizeInPlace()
{
	Vector& v = *this;

	float iradius = 1.f / ( this->Length() + 1.192092896e-07F ); //FLT_EPSILON

	v.x *= iradius;
	v.y *= iradius;
	v.z *= iradius;

	return v.Length();
}
//===============================================
inline float VectorNormalize( Vector& v )
{
	Assert( v.IsValid() );
	float l = v.Length();
	if ( l != 0.0f )
	{
		v /= l;
	}
	else
	{
		v.x = v.y = 0.0f; v.z = 1.0f;
	}
	return l;
}
//===============================================
__forceinline float VectorNormalize( float * v )
{
	return VectorNormalize( *( reinterpret_cast< Vector * >( v ) ) );
}

//===============================================
inline Vector Vector::Normalized() const
{
	Vector norm = *this;
	VectorNormalize( norm );
	return norm;
}
//===============================================
inline Vector Vector::operator+( const Vector& v ) const
{
	Vector res;
	res.x = x + v.x;
	res.y = y + v.y;
	res.z = z + v.z;
	return res;
}

//===============================================
inline Vector Vector::operator-( const Vector& v ) const
{
	Vector res;
	res.x = x - v.x;
	res.y = y - v.y;
	res.z = z - v.z;
	return res;
}
//===============================================
inline Vector Vector::operator*( float fl ) const
{
	Vector res;
	res.x = x * fl;
	res.y = y * fl;
	res.z = z * fl;
	return res;
}
//===============================================
inline Vector Vector::operator*( const Vector& v ) const
{
	Vector res;
	res.x = x * v.x;
	res.y = y * v.y;
	res.z = z * v.z;
	return res;
}
//===============================================
inline Vector Vector::operator/( float fl ) const
{
	Vector res;
	res.x = x / fl;
	res.y = y / fl;
	res.z = z / fl;
	return res;
}
//===============================================
inline Vector Vector::operator/( const Vector& v ) const
{
	Vector res;
	res.x = x / v.x;
	res.y = y / v.y;
	res.z = z / v.z;
	return res;
}
//===============================================
inline float Vector::Dot( const Vector& vOther ) const
{
	const Vector& a = *this;

	return( a.x*vOther.x + a.y*vOther.y + a.z*vOther.z );
}
//===============================================
inline float Vector::Dot( const float* fOther ) const
{
	const Vector& a = *this;

	return( a.x*fOther[ 0 ] + a.y*fOther[ 1 ] + a.z*fOther[ 2 ] );
}
//===============================================
inline float* Vector::Base()
{
	return ( float* )this;
}
//===============================================
inline float const* Vector::Base() const
{
	return ( float const* )this;
}


#endif // !Vector_h
```

`Lumina/Lumina/sdk/math/Vector2D.h`:

```h
#pragma once

struct Vector2D
{
public:
	float x, y;

	Vector2D() {}
	Vector2D( float x_, float y_ ) { x = x_; y = y_; }
	Vector2D( float x_, float y_, float z_ ) { x = x_; y = y_; }
	__forceinline Vector2D&	operator+=( const Vector2D &v );
	__forceinline Vector2D&	operator-=( const Vector2D &v );
	__forceinline Vector2D&	operator*=( const Vector2D &v );
	__forceinline Vector2D&	operator*=( float s );
	__forceinline Vector2D&	operator/=( const Vector2D &v );
	__forceinline Vector2D&	operator/=( float s );
	__forceinline Vector2D&	operator+=( float fl );
	__forceinline Vector2D&	operator-=( float fl );
	__forceinline Vector2D	operator+( float fl ) const;
	__forceinline Vector2D  operator+( Vector2D v ) const;
	__forceinline Vector2D	operator-( float fl ) const;
	__forceinline Vector2D  operator-( Vector2D v ) const;
	__forceinline Vector2D	operator/( float fl ) const;
	inline float	Length() const;
};

//===============================================
__forceinline  Vector2D& Vector2D::operator+=( const Vector2D& v )
{
	x += v.x; y += v.y;
	return *this;
}
//===============================================
__forceinline  Vector2D& Vector2D::operator-=( const Vector2D& v )
{
	x -= v.x; y -= v.y;
	return *this;
}
//===============================================
__forceinline  Vector2D& Vector2D::operator*=( float fl )
{
	x *= fl;
	y *= fl;
	return *this;
}
//===============================================
__forceinline  Vector2D& Vector2D::operator*=( const Vector2D& v )
{
	x *= v.x;
	y *= v.y;
	return *this;
}
//===============================================
__forceinline Vector2D&	Vector2D::operator+=( float fl )
{
	x += fl;
	y += fl;
	return *this;
}
//===============================================
__forceinline Vector2D&	Vector2D::operator-=( float fl )
{
	x -= fl;
	y -= fl;
	return *this;
}

//===============================================
__forceinline Vector2D Vector2D::operator+( float fl ) const
{
	return Vector2D( x + fl, y + fl );
}

//===============================================
__forceinline Vector2D Vector2D::operator+( Vector2D v ) const
{
	return Vector2D( x + v.x, y + v.y );
}

//===============================================
__forceinline Vector2D Vector2D::operator-( float fl ) const
{
	return Vector2D( x - fl, y - fl );
}
//===============================================
__forceinline Vector2D Vector2D::operator-( Vector2D v ) const
{
	return Vector2D( x - v.x, y - v.y );
}
//===============================================
__forceinline Vector2D Vector2D::operator/( float fl ) const
{
	return Vector2D( x / fl, y / fl );
}
//===============================================
__forceinline  Vector2D& Vector2D::operator/=( float fl )
{
	float oofl = 1.0f / fl;
	x *= oofl;
	y *= oofl;
	return *this;
}
//===============================================
__forceinline  Vector2D& Vector2D::operator/=( const Vector2D& v )
{
	x /= v.x;
	y /= v.y;
	return *this;
}

//===============================================
inline float Vector2D::Length( void ) const
{
	float root = 0.0f;

	float sqsr = x * x + y * y;

	__asm sqrtss xmm0, sqsr
	__asm movss root, xmm0

	return root;
}
```

`Lumina/Lumina/sdk/math/Vector4D.h`:

```h
#pragma once

class Vector4D					
{
public:
	// Members
	float x, y, z, w;

	inline float* Base();
	inline float const* Base() const;

	float operator[](int i) const;
	float& operator[](int i);

	inline Vector2D get_pos() const;
	inline Vector2D get_size() const;
};

inline float* Vector4D::Base()
{
	return (float*)this;
}

inline float const* Vector4D::Base() const
{
	return (float const*)this;
}

inline float& Vector4D::operator[](int i)
{
	Assert( (i >= 0) && (i < 4) );
	return ((float*)this)[i];
}

inline float Vector4D::operator[](int i) const
{
	Assert( (i >= 0) && (i < 4) );
	return ((float*)this)[i];
}

inline Vector2D Vector4D::get_pos() const
{
	return Vector2D(x, y);
}

inline Vector2D Vector4D::get_size() const
{
	return Vector2D(z, w);
}
```

`Lumina/Lumina/sdk/math/math.h`:

```h
#pragma once

#ifndef math_h

#define math_h

#include "Vector.h"
#include "matrix3x4_t.h"

class math
{
public:
	static float Magnitude(Vector a)
	{
		return sqrt((a.x * a.x) + (a.y * a.y));
	}

	static void vec_normalize(Vector* vec)
	{
		float radius;

		radius = 1.f / (float)(sqrt(vec->x * vec->x + vec->y * vec->y + vec->z * vec->z) + 1.192092896e-07f);
		vec->x *= radius, vec->y *= radius, vec->z *= radius;
	}

	static Vector Normalize(Vector value)
	{
		VMProtectBeginMutation("math::Normalize");

		float num = Magnitude(value);
		if (num != 0.f)
			return value / num;

		VMProtectEnd();

		return Vector(0.f, 0.f, 0.f);
	}

	static void transform_vector(Vector& a, matrix3x4_t& b, Vector& out) {

		VMProtectBeginMutation("math::transform_vector");

		out.x = a.Dot(b.m_flMatVal[0]) + b.m_flMatVal[0][3];
		out.y = a.Dot(b.m_flMatVal[1]) + b.m_flMatVal[1][3];
		out.z = a.Dot(b.m_flMatVal[2]) + b.m_flMatVal[2][3];

		VMProtectEnd();
	}

	static void vec_clamp(Vector* v)
	{
		if (v->x > 89.0f && v->x <= 180.0f) {
			v->x = 89.0f;
		}
		if (v->x > 180.0f) {
			v->x = v->x - 360.0f;
		}
		if (v->x < -89.0f) {
			v->x = -89.0f;
		}
		v->y = fmodf(v->y + 180, 360) - 180;
		v->z = 0;
	}

	static Vector ClampMagnitude(Vector vector, float maxLength)
	{
		VMProtectBeginMutation("math::ClampMagnitude");

		if (Magnitude(vector) > maxLength)
			return Vector(Normalize(vector).x * maxLength, Normalize(vector).y * maxLength, 0);

		VMProtectEnd();

		return vector;
	}

	static void vector_angles(const Vector& forward, Vector& angles)
	{
		VMProtectBeginMutation("math::vector_angles");

		Vector view;

		if (!forward[0] && !forward[1])
		{
			view[0] = 0.0f;
			view[1] = 0.0f;
		}
		else
		{
			view[1] = atan2(forward[1], forward[0]) * 180.0f / M_PI;

			if (view[1] < 0.0f)
				view[1] += 360.0f;

			view[2] = sqrt(forward[0] * forward[0] + forward[1] * forward[1]);
			view[0] = atan2(forward[2], view[2]) * 180.0f / M_PI;
		}

		angles[0] = -view[0];
		angles[1] = view[1];
		angles[2] = 0.f;

		VMProtectEnd();
	}

	static void angle_vectors(const Vector& angles, Vector& forward)
	{
		VMProtectBeginMutation("math::angle_vectors");

		float sp, sy, cp, cy;

		sy = sin(DEG2RAD(angles[1]));
		cy = cos(DEG2RAD(angles[1]));

		sp = sin(DEG2RAD(angles[0]));
		cp = cos(DEG2RAD(angles[0]));

		forward.x = cp * cy;
		forward.y = cp * sy;
		forward.z = -sp;

		VMProtectEnd();
	}

	static Vector calculate_angle(const Vector& source, const Vector& destination, const Vector& viewAngles) {

		//VMProtectBeginMutation("math::calculate_angle");

		Vector delta = source - destination;
		auto radians_to_degrees = [](float radians) { return radians * 180 / static_cast<float>(M_PI); };
		Vector angles;

		angles.z = 0.0f;
		angles.y = radians_to_degrees(atanf(delta.y / delta.x)) - viewAngles.y;
		angles.x = radians_to_degrees(atanf(delta.z / std::hypotf(delta.x, delta.y))) - viewAngles.x;

		if (delta.x >= 0.0)
			angles.y += 180.0f;

		angles.normalize_aimbot();

		//VMProtectEnd();

		return angles;
	}

};

#endif // !math_h

```

`Lumina/Lumina/sdk/math/matrix3x4_t.h`:

```h
#pragma once

#ifndef matrix3x4_t_h

#define matrix3x4_t_h

struct matrix3x4_t
{
	matrix3x4_t() {}
	matrix3x4_t(
		float m00, float m01, float m02, float m03,
		float m10, float m11, float m12, float m13,
		float m20, float m21, float m22, float m23 )
	{
		m_flMatVal[ 0 ][ 0 ] = m00;	m_flMatVal[ 0 ][ 1 ] = m01; m_flMatVal[ 0 ][ 2 ] = m02; m_flMatVal[ 0 ][ 3 ] = m03;
		m_flMatVal[ 1 ][ 0 ] = m10;	m_flMatVal[ 1 ][ 1 ] = m11; m_flMatVal[ 1 ][ 2 ] = m12; m_flMatVal[ 1 ][ 3 ] = m13;
		m_flMatVal[ 2 ][ 0 ] = m20;	m_flMatVal[ 2 ][ 1 ] = m21; m_flMatVal[ 2 ][ 2 ] = m22; m_flMatVal[ 2 ][ 3 ] = m23;
	}

	matrix3x4_t( const float arr[ 12 ] )
	{
		m_flMatVal[ 0 ][ 0 ] = arr[ 0 ];	m_flMatVal[ 0 ][ 1 ] = arr[ 1 ]; m_flMatVal[ 0 ][ 2 ] = arr[ 2 ]; m_flMatVal[ 0 ][ 3 ] = arr[ 3 ];
		m_flMatVal[ 1 ][ 0 ] = arr[ 4 ];	m_flMatVal[ 1 ][ 1 ] = arr[ 5 ]; m_flMatVal[ 1 ][ 2 ] = arr[ 6 ]; m_flMatVal[ 1 ][ 3 ] = arr[ 7 ];
		m_flMatVal[ 2 ][ 0 ] = arr[ 8 ];	m_flMatVal[ 2 ][ 1 ] = arr[ 9 ]; m_flMatVal[ 2 ][ 2 ] = arr[ 10 ]; m_flMatVal[ 2 ][ 3 ] = arr[ 11 ];
	}

	//-----------------------------------------------------------------------------
	// Creates a matrix where the X axis = forward
	// the Y axis = left, and the Z axis = up
	//-----------------------------------------------------------------------------
	void Init( const Vector& xAxis, const Vector& yAxis, const Vector& zAxis, const Vector &vecOrigin )
	{
		m_flMatVal[ 0 ][ 0 ] = xAxis.x; m_flMatVal[ 0 ][ 1 ] = yAxis.x; m_flMatVal[ 0 ][ 2 ] = zAxis.x; m_flMatVal[ 0 ][ 3 ] = vecOrigin.x;
		m_flMatVal[ 1 ][ 0 ] = xAxis.y; m_flMatVal[ 1 ][ 1 ] = yAxis.y; m_flMatVal[ 1 ][ 2 ] = zAxis.y; m_flMatVal[ 1 ][ 3 ] = vecOrigin.y;
		m_flMatVal[ 2 ][ 0 ] = xAxis.z; m_flMatVal[ 2 ][ 1 ] = yAxis.z; m_flMatVal[ 2 ][ 2 ] = zAxis.z; m_flMatVal[ 2 ][ 3 ] = vecOrigin.z;
	}

	//-----------------------------------------------------------------------------
	// Creates a matrix where the X axis = forward
	// the Y axis = left, and the Z axis = up
	//-----------------------------------------------------------------------------
	matrix3x4_t( const Vector& xAxis, const Vector& yAxis, const Vector& zAxis, const Vector &vecOrigin )
	{
		Init( xAxis, yAxis, zAxis, vecOrigin );
	}

	inline void SetOrigin( Vector const & p )
	{
		m_flMatVal[ 0 ][ 3 ] = p.x;
		m_flMatVal[ 1 ][ 3 ] = p.y;
		m_flMatVal[ 2 ][ 3 ] = p.z;
	}

	inline void Invalidate( void )
	{
		for ( int i = 0; i < 3; i++ )
		{
			for ( int j = 0; j < 4; j++ )
			{
				m_flMatVal[ i ][ j ] = VEC_T_NAN;
			}
		}
	}

	float *operator[]( int i ) { Assert( ( i >= 0 ) && ( i < 3 ) ); return m_flMatVal[ i ]; }
	const float *operator[]( int i ) const { Assert( ( i >= 0 ) && ( i < 3 ) ); return m_flMatVal[ i ]; }
	float *Base() { return &m_flMatVal[ 0 ][ 0 ]; }
	const float *Base() const { return &m_flMatVal[ 0 ][ 0 ]; }

	float m_flMatVal[ 3 ][ 4 ];
};

#endif // !matrix3x4_t_h
```

`Lumina/Lumina/sdk/netvars.cpp`:

```cpp
#include "netvars.h"

#include "interfaces.h"

/*

CNetVars::CNetVars()
{
	for (auto clazz = interfaces::baseClientDll->GetAllClasses(); clazz; clazz = clazz->m_pNext)
		if (clazz->m_pRecvTable)
			dump_recursive(clazz->m_pNetworkName, clazz->m_pRecvTable, 0);
}
//===============================================
void CNetVars::dump_recursive(const char* base_class, RecvTable* table, uint16_t offset)
{
	for (auto i = 0; i < table->m_nProps; ++i)
	{
		auto prop_ptr = &table->m_pProps[i];

		//Skip trash array items
		if (!prop_ptr || isdigit(prop_ptr->m_pVarName[0]))
			continue;

		//We dont care about the base class, we already know that
		if (strcmp(prop_ptr->m_pVarName, XorStr("baseclass")) == 0)
			continue;

		if (prop_ptr->m_RecvType == DPT_DataTable &&
			prop_ptr->m_pDataTable != nullptr &&
			prop_ptr->m_pDataTable->m_pNetTableName[0] == 'D') // Skip shitty tables
		{
			dump_recursive(base_class, prop_ptr->m_pDataTable, offset + prop_ptr->m_Offset);
		}

		char hash_name[256];

		strcpy_s(hash_name, base_class);
		strcat_s(hash_name, XorStr("->"));
		strcat_s(hash_name, prop_ptr->m_pVarName);

		// Need to cast it to prevent FnvHash using the recursive hasher
		// which would hash all 256 bytes
		auto hash = FnvHash(static_cast<const char*>(hash_name));

		m_props[hash] = { prop_ptr,  uint16_t(offset + prop_ptr->m_Offset) };
	}
}

*/

// from aristois

class d_variant;
class recv_table;
class recv_prop;
class c_recv_proxy_data;

using recv_var_proxy_fn = void(*)(const c_recv_proxy_data* data, void* struct_ptr, void* out_ptr);
using array_length_recv_proxy_fn = void(*)(void* struct_ptr, int object_id, int current_array_length);
using data_table_recv_var_proxy_fn = void(*)(const recv_prop* prop, void** out_ptr, void* data_ptr, int object_id);

enum send_prop_type {
	_int = 0,
	_float,
	_vec,
	_vec_xy,
	_string,
	_array,
	_data_table,
	_int_64,
};
class d_variant {
public:
	union {
		float m_float;
		long m_int;
		char* m_string;
		void* m_data;
		float m_vector[3];
		__int64 m_int64;
	};
	send_prop_type type;
};
class c_recv_proxy_data {
public:
	const recv_prop* recv_prop;
	d_variant value;
	int element_index;
	int object_id;
};
class recv_prop {
public:
	char* prop_name;
	send_prop_type prop_type;
	int prop_flags;
	int buffer_size;
	int is_inside_of_array;
	const void* extra_data_ptr;
	recv_prop* array_prop;
	array_length_recv_proxy_fn array_length_proxy;
	recv_var_proxy_fn proxy_fn;
	data_table_recv_var_proxy_fn data_table_proxy_fn;
	recv_table* data_table;
	int offset;
	int element_stride;
	int elements_count;
	const char* parent_array_prop_name;
};

class recv_table {

public:
	recv_prop * props;
	int props_count;
	void* decoder_ptr;
	char* table_name;
	bool is_initialized;
	bool is_in_main_list;
};


namespace netvar_manager {
	using netvar_key_value_map = std::unordered_map< uint32_t, uintptr_t >;
	using netvar_table_map = std::unordered_map< uint32_t, netvar_key_value_map >;
	void initProps(netvar_table_map& table_map);

	uintptr_t get_net_var(const uint32_t table, const uint32_t prop) {

		VMProtectBeginMutation("netvar_manager::get_net_var");

		static netvar_table_map map = {};

		if (map.empty()) {
			initProps(map);
		}

		if (map.find(table) == map.end()) {
			return 0;
		}

		VMProtectEnd();

		netvar_key_value_map& table_map = map.at(table);

		if (table_map.find(prop) == table_map.end()) {
			return 0;
		}

		return table_map.at(prop);
	}

	void add_props_for_table(netvar_table_map& table_map, const uint32_t table_name_hash, const std::string& table_name, recv_table* table, const bool dump_vars, std::map< std::string, std::map< uintptr_t, std::string > >& var_dump, const size_t child_offset = 0) {

		VMProtectBeginMutation("netvar_manager::add_props_for_table");
		
		for (auto i = 0; i < table->props_count; ++i) {
			auto& prop = table->props[i];

			if (prop.data_table && prop.elements_count > 0) {
				if (std::string(prop.prop_name).substr(0, 1) == std::string("0"))
					continue;

				add_props_for_table(table_map, table_name_hash, table_name, prop.data_table, dump_vars, var_dump, prop.offset + child_offset);
			}

			auto name = std::string(prop.prop_name);

			if (name.substr(0, 1) != "m" )
				continue;

			const auto name_hash = fnv::hash(prop.prop_name);
			const auto offset = uintptr_t(prop.offset) + child_offset;

			table_map[table_name_hash][name_hash] = offset;

			if (dump_vars)
			{
				var_dump[table_name][offset] = prop.prop_name;
			}
		}

		VMProtectEnd();
	}

	void initProps(netvar_table_map & table_map) {

		VMProtectBeginMutation("netvar_manager::initProps");

		const auto dump_vars = true;  //true if netvar dump

		std::map< std::string, std::map< uintptr_t, std::string > > var_dump;
		for (auto client_class = interfaces::baseClientDll->GetAllClasses();
			client_class;
			client_class = client_class->m_pNext)
		{
			const auto table = reinterpret_cast<recv_table*>(client_class->m_pRecvTable);
			const auto table_name = table->table_name;
			const auto table_name_hash = fnv::hash(table_name);

			if (table == nullptr)
				continue;

			add_props_for_table(table_map, table_name_hash, table_name, table, dump_vars, var_dump);
		}

		VMProtectEnd();
	}
}

```

`Lumina/Lumina/sdk/netvars.h`:

```h
#ifndef netvart_h

#define netvart_h

#include <cstdint>
#include <map>
#include "../security/xorstr.hpp"
#include "../sdk/math/Vector.h"

/*

using fnv_t = unsigned;
class FnvHash
{
	static const fnv_t FNV_PRIME = 16777619u;
	static const fnv_t OFFSET_BASIS = 2166136261u;

	template <unsigned int N>
	static constexpr fnv_t fnvHashConst(const char(&str)[N], unsigned int I = N)
	{
		return static_cast<fnv_t>(1ULL * (I == 1 ? (OFFSET_BASIS ^ str[0]) : (fnvHashConst(str, I - 1) ^ str[I - 1])) * FNV_PRIME);
	}

	static fnv_t fnvHash(const char* str)
	{
		const auto length = strlen(str) + 1;
		auto hash = OFFSET_BASIS;
		for (size_t i = 0; i < length; ++i)
		{
			hash ^= *str++;
			hash *= FNV_PRIME;
		}
		return hash;
	}

	struct Wrapper
	{
		Wrapper(const char* str) : str(str) {}
		const char* str;
	};

	fnv_t hash_value;
public:
	FnvHash(Wrapper wrapper) : hash_value(fnvHash(wrapper.str)) {}

	template <unsigned int N>
	constexpr FnvHash(const char(&str)[N]) : hash_value(fnvHashConst(str)) {}

	constexpr operator fnv_t() const { return this->hash_value; }
};

struct CRecvProxyData;

class RecvProp;
class RecvTable;

using RecvVarProxyFn = void(__cdecl *)(CRecvProxyData*, void*, void*);

struct DVariant
{
	union
	{
		float m_Float;
		long m_Int;
		char* m_pString;
		void* m_pData;
		Vector m_Vector;
		int64_t m_Int64;
	};

	int m_Type;
};

struct CRecvProxyData
{
	const RecvProp* m_pRecvProp;
	DVariant m_Value;
	int m_iElement;
	int m_ObjectID;
};

enum SendPropType : int
{
	DPT_Int = 0,
	DPT_Float,
	DPT_Vector,
	DPT_VectorXY,
	DPT_String,
	DPT_Array,
	DPT_DataTable,
	DPT_Int64,
	DPT_NUMSendPropTypes
};

class RecvProp
{
public:
	char* m_pVarName;
	SendPropType m_RecvType;
	int m_Flags;
	int m_StringBufferSize;
	bool m_bInsideArray;
	const void* m_pExtraData;
	RecvProp* m_pArrayProp;
	void* m_ArrayLengthProxy;
	RecvVarProxyFn m_ProxyFn;
	void* m_DataTableProxyFn;
	RecvTable* m_pDataTable;
	int m_Offset;
	int m_ElementStride;
	int m_nElements;
	const char* m_pParentArrayPropName;
};

class RecvTable
{
public:
	RecvProp * m_pProps;
	int m_nProps;
	void* m_pDecoder;
	char* m_pNetTableName;
	bool m_bInitialized;
	bool m_bInMainList;
};

class CNetVars
{
private:
	struct StoredPropData
	{
		RecvProp* prop_ptr;
		uint16_t class_relative_offset;
	};

public:
	static CNetVars& Get()
	{
		static CNetVars instance;
		return instance;
	}

	unsigned short GetOffset(unsigned int hash) { return m_props[hash].class_relative_offset; }
	RecvProp* GetPropPtr(unsigned int hash) { return m_props[hash].prop_ptr; }

	// Prevent instruction cache pollution caused by automatic
	// inlining of Get and GetOffset every netvar usage when there
	// are a lot of netvars
	__declspec(noinline) static uint16_t GetOffsetByHash(fnv_t hash)
	{
		return Get().GetOffset(hash);
	}

private:
	CNetVars();
	void dump_recursive(const char* base_class, RecvTable* table, uint16_t offset);

private:
	std::map<fnv_t, StoredPropData> m_props;
};
//===============================================
#define PNETVAR(funcname, type, netvarname) type* funcname() \
{ \
    static fnv_t hash; \
	static uint16_t offset; \
    if( !offset ) { char* str = XorStr(netvarname); \
	hash = FnvHash( str ); \
	offset = CNetVars::GetOffsetByHash(hash); \
	Assert(offset); } \
	return reinterpret_cast<type*>(uintptr_t(this) + offset); \
}
//===============================================
#define ANETVAR(funcname, type, num, netvarname) std::array<type, num>& funcname() \
{ \
	static fnv_t hash; \
	static uint16_t offset; \
    if( !offset ) { char* str = XorStr(netvarname); \
	hash = FnvHash( str ) \
	offset = CNetVars::GetOffsetByHash(hash); \
	Assert(offset); } \
	return *reinterpret_cast<std::array<type, num>*>(uintptr_t(this) + offset); \
}
//===============================================
#define NETVAR(funcname, type, netvarname) type& funcname() \
{ \
	static fnv_t hash; \
	static uint16_t offset; \
    if( !offset ) { char* str = XorStr(netvarname); \
	hash = FnvHash( str ); \
	offset = CNetVars::GetOffsetByHash(hash); \
	Assert(offset); } \
	return *reinterpret_cast<type*>(uintptr_t(this) + offset); \
}
//===============================================
#define NETVARA(funcname, type, netvarname, add) type& funcname() \
{ \
	static fnv_t hash; \
	static uint16_t offset; \
    if( !offset ) {char* str = XorStr(netvarname); \
	hash = FnvHash( str ); \
	offset = CNetVars::GetOffsetByHash(hash); \
	Assert(offset); } \
	return *reinterpret_cast<type*>(uintptr_t(this) + offset + add); \
}
//===============================================
#define NETPROP(funcname, netvarname) static RecvProp* funcname() \
{ \
	static fnv_t hash; \
	static RecvProp* prop_ptr = nullptr; \
    if( !prop_ptr ) { char* str = XorStr(netvarname); \
	hash = FnvHash( str ); \
	prop_ptr = CNetVars::Get().GetPropPtr(hash); } \
	return prop_ptr; \
}
//===============================================
#define OFFSET(funcname, type, offset) type& funcname() \
{ \
	static uint16_t _offset = offset; \
	Assert(_offset); \
	return *reinterpret_cast<type*>(uintptr_t(this) + _offset); \
}
//===============================================
#define POFFSET(funcname, type, offset) type* funcname() \
{ \
	static uint16_t _offset = offset; \
	Assert(_offset); \
	return reinterpret_cast<type*>(uintptr_t(this) + _offset); \
}
//===============================================
#define AOFFSET(funcname, type, num, offset) std::array<type, num>& funcname() \
{ \
	static uint16_t _offset = offset; \
	Assert(_offset); \
	return *reinterpret_cast<std::array<type, num>*>(uintptr_t(this) + _offset); \
}
//===============================================
#define APOFFSET(funcname, type, num, offset) std::array<type, num>& funcname() \
{ \
	static uint16_t _offset = offset; \
	Assert(_offset); \
	return **reinterpret_cast<std::array<type, num>**>(uintptr_t(this) + _offset); \
}
//===============================================
#define OFFSETRS(funcname, type, offset) type& funcname( int index ) \
{ \
	static uint16_t _offset = offset; \
	Assert(_offset); \
	return *reinterpret_cast<type*>(uintptr_t(this) + _offset + index * 4); \
}*/


namespace netvar_manager {

#pragma warning( push )
#pragma warning( disable: 4307 )

	namespace fnv_1a {
		template< typename S >
		struct fnv_internal;
		template< typename S >
		struct fnv1a;

		template< >
		struct fnv_internal< uint32_t > {
			constexpr static uint32_t default_offset_basis = 0x811C9DC5;
			constexpr static uint32_t prime = 0x01000193;
		};

		template< >
		struct fnv1a< uint32_t > : public fnv_internal< uint32_t > {
			constexpr static uint32_t hash(char const* const aString, const uint32_t val = default_offset_basis) {
				return (aString[0] == '\0')
					? val
					: hash(&aString[1], (val ^ uint32_t(aString[0])) * prime);
			}

			constexpr static uint32_t hash(wchar_t const* const aString, const uint32_t val = default_offset_basis) {
				return (aString[0] == L'\0')
					? val
					: hash(&aString[1], (val ^ uint32_t(aString[0])) * prime);
			}
		};
	}

	using fnv = fnv_1a::fnv1a< uint32_t >;

#pragma warning( pop )
}

#define NETVAR(table, prop, func_name, type) \
	type& func_name( ) { \
      static uintptr_t offset = 0; \
      if(!offset) \
      { offset = netvar_manager::get_net_var(netvar_manager::fnv::hash( table ), netvar_manager::fnv::hash( prop ) ); } \
	  \
      return *reinterpret_cast< type* >( uintptr_t( this ) + offset ); \
    }

#define NETVAR_PTR(table, prop, func_name, type) \
	type* func_name( ) { \
      static uintptr_t offset = 0; \
      if(!offset) \
      { offset = netvar_manager::get_net_var(netvar_manager::fnv::hash( table ), netvar_manager::fnv::hash( prop ) ); } \
	  \
      return reinterpret_cast< type* >( uintptr_t( this ) + offset ); \
    }

#define POFFSET(type, var, offset) \
	type* var() { \
		return (type*)(uintptr_t(this) + offset); \
	} \

#define GOFFSET(type, var, offset) \
	type var() { \
		return *(type*)(uintptr_t(this) + offset); \
	} \

#define OFFSET(type, var, offset) \
	type& var() { \
		return *(type*)(uintptr_t(this) + offset); \
	} \

#define OFFSETRS(funcname, type, offset) type& funcname( int index ) \
{ \
	static uint16_t _offset = offset; \
	Assert(_offset); \
	return *reinterpret_cast<type*>(uintptr_t(this) + _offset + index * 4); \
}

namespace netvar_manager {
	uintptr_t get_net_var(uint32_t table, uint32_t prop);
}

#endif 
```

`Lumina/Lumina/sdk/structs/CBoneChache.h`:

```h
#pragma once

class CBoneCache
{
public:
	matrix3x4_t* m_pCachedBones;
	char pad[ 8 ];
	unsigned int m_CachedBoneCount;
};
```

`Lumina/Lumina/sdk/structs/CCSGOPlayerAnimState.h`:

```h
#pragma once

class CCSGOPlayerAnimState
{
public:
	MFUNC( update( QAngle ang ), void( __vectorcall* )( void*, void*, float, float, float, void* ), offsets::update_anim_state )( nullptr, 0, ang.y, ang.x, nullptr );
	char            pad[3];
	char            bUnknown; //0x4
	char            pad2[91];
	void*           pBaseEntity; //0x60
	void*           pActiveWeapon; //0x64
	void*           pLastActiveWeapon; //0x68
	float           m_flLastClientSideAnimationUpdateTime; //0x6C
	int             m_iLastClientSideAnimationUpdateFramecount; //0x70
	float           m_flEyePitch; //0x74
	float           m_flEyeYaw; //0x78
	float           m_flPitch; //0x7C
	float           m_flGoalFeetYaw; //0x80
	float           m_flCurrentFeetYaw; //0x84
	float           m_flCurrentTorsoYaw; //0x88
	float           m_flUnknownVelocityLean; //0x8C //changes when moving/jumping/hitting ground
	float           m_flLeanAmount; //0x90
	char            pad4[4];
	float           m_flFeetCycle; //0x98 0 to 1
	float           m_flFeetYawRate; //0x9C 0 to 1
	float           m_fUnknown2;
	float           m_fDuckAmount; //0xA4
	float           m_fLandingDuckAdditiveSomething;
	float           m_fUnknown3;
	Vector          m_vOrigin;
	Vector          m_vLastOrigin;
	float           m_vVelocityX;
	float           m_vVelocityY;
	char            pad5[4];
	float           m_flUnknownFloat1;
	char            pad6[8];
	float           m_flUnknownFloat2;
	float           m_flUnknownFloat3;
	float           m_unknown;
	float           m_velocity;
	float           flUpVelocity; //0xF0
	float           m_flSpeedNormalized; //0xF4 //from 0 to 1
	float           m_flFeetSpeedForwardsOrSideWays; //0xF8 //from 0 to 2. something  is 1 when walking, 2.something when running, 0.653 when crouch walking
	float           m_flFeetSpeedUnknownForwardOrSideways; //0xFC //from 0 to 3. something
	float           m_flTimeSinceStartedMoving;
	float           m_flTimeSinceStoppedMoving;
	unsigned char   m_bOnGround; //0x108
	unsigned char   m_bInHitGroundAnimation; //0x109
	char            pad7[10];
	float           m_flLastOriginZ; //0x114
	float           m_flHeadHeightOrOffsetFromHittingGroundAnimation; //0x118 from 0 to 1, is 1 when standing
	float           m_flStopToFullRunningFraction; //0x11C from 0 to 1, doesnt change when walking or crouching, only running
	char            pad8[4];
	float            m_flUnknownFraction; //0x124 affected while jumping and running, or when just jumping, 0 to 1
	char            pad9[4];
	float           m_flUnknown3;
	char            pad10[528];
	template< class T >
	inline T& get_offset(const int off)
	{
		return *reinterpret_cast<T*>(DWORD(this) + off);
	}
};
```

`Lumina/Lumina/sdk/structs/CCSGameRulesProxy.h`:

```h
#pragma once

class C_CSGameRulesProxy
{
public:
	OFFSET( m_bFreezePeriod, bool, 0x20 )
		OFFSET( m_bIsValveDS, bool, 0x75 )
		OFFSET( m_bBombPlanted, bool, 0x8D1 )
		OFFSET( m_bBombDropped, bool, 0x8D0 )
};
```

`Lumina/Lumina/sdk/structs/CNetChannel.h`:

```h
#pragma once

typedef enum
{
	NA_NULL = 0,
	NA_LOOPBACK,
	NA_BROADCAST,
	NA_IP,
} netadrtype_t;

struct netadr_t
{
	netadrtype_t	type;
	unsigned char	ip[ 4 ];
	unsigned short	port;
};

class bf_read
{
public:
	uintptr_t base_address;
	uintptr_t cur_offset;

	bf_read( uintptr_t addr )
	{
		base_address = addr;
		cur_offset = 0;
	}

	void SetOffset( uintptr_t offset )
	{
		cur_offset = offset;
	}

	void Skip( uintptr_t length )
	{
		cur_offset += length;
	}

	int ReadByte()
	{
		auto val = *reinterpret_cast<char*>( base_address + cur_offset );
		++cur_offset;
		return val;
	}

	long ReadLong()
	{
		auto val = *reinterpret_cast<long*>( base_address + cur_offset );
		++cur_offset;
		return val;
	}

	bool ReadBool()
	{
		auto val = *reinterpret_cast<bool*>( base_address + cur_offset );
		++cur_offset;
		return val;
	}

	std::string ReadString()
	{
		char buffer[ 256 ];
		auto str_length = *reinterpret_cast<char*>( base_address + cur_offset );
		++cur_offset;
		memcpy( buffer, reinterpret_cast<void*>( base_address + cur_offset ), str_length > 255 ? 255 : str_length );
		buffer[ str_length > 255 ? 255 : str_length ] = '\0';
		cur_offset += str_length + 1;
		return std::string( buffer );
	}
};

typedef struct netpacket_s netpacket_t;

typedef struct netpacket_s
{
	netadr_t		from;		// sender IP
	int				source;		// received source 
	double			received;	// received time
	unsigned char	*data;		// pointer to raw packet data
	bf_read			message;	// easy bitbuf data access
	int				size;		// size in bytes
	int				wiresize;   // size in bytes before decompression
	bool			stream;		// was send as stream
	struct netpacket_s *pNext;	// for internal use, should be NULL in public
} netpacket_t;

class CNetChannel
{
public:
	char pad_0x0000[ 0x18 ]; //0x0000
	__int32 m_nOutSequenceNr; //0x0018 
	__int32 m_nInSequenceNr; //0x001C 
	__int32 m_nOutSequenceNrAck; //0x0020 
	__int32 m_nOutReliableState; //0x0024 
	__int32 m_nInReliableState; //0x0028 
	__int32 m_nChokedPackets; //0x002C 

	VFUNC( 42, SendNetMsg( void* msg, bool bForceReliable = false, bool bVoice = false ), bool( __thiscall* )( void*, void*, bool, bool ) )( msg, bForceReliable, bVoice )
	VFUNC( 49, Transmit( bool onlyreliable = false ), bool( __thiscall* )( void*, bool ) )( onlyreliable )
};//Size=0x4294
```

`Lumina/Lumina/sdk/structs/ClientClass.cpp`:

```cpp
#include "ClientClass.h"


```

`Lumina/Lumina/sdk/structs/ClientClass.h`:

```h
#ifndef ClientClass_h

#define ClientClass_h

class IClientNetworkable;
class ClientClass;


class d_variant_ {
public:
	union {
		float m_float;
		long m_int;
		char* m_string;
		void* m_data;
		float m_vector[3];
		__int64 m_int64;
	};
	int type;
};



class recv_prop_ {
public:
	char* prop_name;
	int prop_type;
	int prop_flags;
	int buffer_size;
	int is_inside_of_array;
	const void* extra_data_ptr;
	recv_prop_* array_prop;
	void* array_length_proxy;
	void* proxy_fn;
	void* data_table_proxy_fn;
	void* data_table;
	int offset;
	int element_stride;
	int elements_count;
	const char* parent_array_prop_name;
};

class recv_table_ {

public:
	recv_prop_ * props;
	int props_count;
	void* decoder_ptr;
	char* table_name;
	bool is_initialized;
	bool is_in_main_list;
};

class c_recv_proxy_data_ {
public:
	const recv_prop_* recv_prop;
	d_variant_ value;
	int element_index;
	int object_id;
};

using recv_var_proxy_fn_ = void(*)(const c_recv_proxy_data_* data, void* struct_ptr, void* out_ptr);


using CreateClientClassFn = IClientNetworkable * ( *)( int, int );
using CreateEventFn = IClientNetworkable * ( *)( );

class ClientClass
{
public:
	CreateClientClassFn m_pCreateFn;
	CreateEventFn m_pCreateEventFn;
	const char* m_pNetworkName;
	recv_table_* m_pRecvTable;
	ClientClass* m_pNext;
	int m_ClassID;
};

#endif // !ClientClass_h
```

`Lumina/Lumina/sdk/structs/ConVar.h`:

```h
#pragma once

class ConVar
{
public:
	VFUNC( 5, get_name(), char*( __thiscall* )( void* ) )( )
		VFUNC( 14, set_value( const char* value ), void( __thiscall* )( void*, const char* ) )( value )
		VFUNC( 15, set_value( float value ), void( __thiscall* )( void*, float ) )( value )
		VFUNC( 16, set_value( int value ), void( __thiscall* )( void*, int ) )( value )
		VFUNC( 17, set_value( Color value ), void( __thiscall* )( void*, Color ) )( value )

		bool get_bool() { return !!get_int(); }
	char* get_default() { return pszDefaultValue; }
	float get_float()
	{
		const auto temp = *reinterpret_cast< int* >( &fValue );
		auto temp_result = static_cast< int >( temp ^ reinterpret_cast< uintptr_t >( this ) );

		return *reinterpret_cast< float* >( &temp_result );
	}
	int get_int()
	{
		const auto temp = *reinterpret_cast< int* >( &fValue );
		auto temp_result = static_cast< int >( temp ^ reinterpret_cast< uintptr_t >( this ) );

		return *static_cast< int* >( &temp_result );
	}

	char pad_0x0000[ 0x4 ]; //0x0000
	ConVar* pNext; //0x0004 
	__int32 bRegistered; //0x0008 
	char* pszName; //0x000C 
	char* pszHelpString; //0x0010 
	__int32 nFlags; //0x0014 
	char pad_0x0018[ 0x4 ]; //0x0018
	ConVar* pParent; //0x001C 
	char* pszDefaultValue; //0x0020 
	char* strString; //0x0024 
	__int32 StringLength; //0x0028 
	float fValue; //0x002C 
	__int32 nValue; //0x0030 
	__int32 bHasMin; //0x0034 
	float fMinVal; //0x0038 
	__int32 bHasMax; //0x003C 
	float fMaxVal; //0x0040 
	void* fnChangeCallbacks;

	__forceinline const char* GetString() {

		using original_fn = const char*(__thiscall*)(decltype(this));
		return (*(original_fn**)this)[11](this);
	}

};//Size=0x0048

```

`Lumina/Lumina/sdk/structs/Entity.cpp`:

```cpp
#include "Entity.h"

#include "../interfaces.h"

bool Entity::hasC4() {
	
	return interfaces::hasC4(this);

	/*
	using is_c4_owner_fn = bool(__thiscall*)(Entity*);

	// cast from memory
	static auto is_c4_owner = reinterpret_cast<is_c4_owner_fn>(interfaces::baseClientDll + 0x3ADAD0);

	for (auto i = 0; i < interfaces::globals->maxClients; i++)
	{
		Entity* entity = (Entity*)interfaces::clientEntityList->GetClientEntity(i);

		if (!entity)
			continue;

		if (!entity->isPlayer())
			continue;

		if (!entity->isAlive())
			continue;

		if ((*interfaces::playerResource)->get_c4_player() == entity->index())
			return true;
	}
	return false;*/
}

bool Entity::is(hash32_t hash) {

	auto client_class = interfaces::baseClientDll->GetAllClasses();

	while (client_class) {

		const char* pszName = client_class->m_pRecvTable->table_name;

		if (FNV1a::get(pszName) == hash) 
			return client_class->m_ClassID == (this->Class() ? this->Class()->m_ClassID : -1);
		
		client_class = client_class->m_pNext;
	}

	return false;
}

C_BaseCombatWeapon* Entity::getWeapon() {

	if (!this->m_hActiveWeapon())
		return nullptr;

	auto handle = (*(DWORD*)this->m_hActiveWeapon()) & 0xFFF;

	if (!handle)
		return nullptr;

	return reinterpret_cast<C_BaseCombatWeapon*>(interfaces::clientEntityList->GetClientEntity((int)handle));
}

bool C_BaseCombatWeapon::IsKnife() {

	return getWeaponData()->iWeaponType == WEAPONTYPE_KNIFE && *((C_BaseAttributableItem*)this)->m_iItemDefinitionIndex() != WEAPON_TASER;
}
```

`Lumina/Lumina/sdk/structs/Entity.h`:

```h
#pragma once

#ifndef Entity_h

#define Entity_h

#include <Windows.h>

#include "../../common/vfunc.h"
#include "../netvars.h"
#include "../math/Vector.h"
#include "../math/QAngle.h"
#include "../../sdk/structs/misc.h"
#include "datamap.h"
#include "../structs/IClientEntity.h"
#include "../structs/structs.h"

#include "../../security/hash.h"

class C_BaseViewModel
{
public:

	void SendViewModelMatchingSequence(int sequence)
	{
		using original_fn = void(__thiscall*)(void*, int);
		return (*(original_fn**)this)[241](this, sequence);
	}

	void setModelIndex(int value)
	{
		*(int*)(uintptr_t(this) + 0x258) = value;
	}

	inline void setWeaponModel(const char* Filename, IClientUnknown* Weapon) {

		using original_fn = void(__thiscall*)(void*, const char*, IClientUnknown*);
		return (*(original_fn**)this)[243](this, Filename, Weapon);
	}

	OFFSET(int, m_nModelIndex, 0x258);
	OFFSET(CBaseHandle, m_hWeapon, 0x29C8);
	OFFSET(int, m_nSequence, 0x28BC);
};


class CCSWeaponData
{
public:

	virtual	~CCSWeaponData() {};

	//char		pad_vtable[ 0x4 ];		// 0x0
	char*		consoleName;			// 0x4
	char		pad_0[0xc];			// 0x8
	int32_t		iMaxClip1;				// 0x14
	int32_t		iMaxClip2;				// 0x18
	int32_t		iDefaultClip1;			// 0x1c
	int32_t		iDefaultClip2;			// 0x20
	int32_t		iPrimaryReserveAmmoMax; // 0x24
	int32_t		iSecondaryReserveAmmoMax; // 0x28
	char*		szWorldModel;			// 0x2c
	char*		szViewModel;			// 0x30
	char*		szDroppedModel;			// 0x34
	char		pad_9[0x50];			// 0x38
	char*		szHudName;				// 0x88
	char*		szWeaponName;			// 0x8c
	char		pad_11[0x2];			// 0x90
	bool		bIsMeleeWeapon;			// 0x92
	char		pad_12[0x9];			// 0x93
	float_t		flWeaponWeight;			// 0x9c
	char		pad_13[0x2c];			// 0xa0
	int32_t		iWeaponType;			// 0xcc
	int32_t		iWeaponPrice;			// 0xd0
	int32_t		iKillAward;				// 0xd4
	char		pad_16[0x4];			// 0xd8
	float_t		flCycleTime;			// 0xdc
	float_t		flCycleTimeAlt;			// 0xe0
	char		pad_18[0x8];			// 0xe4
	bool		bFullAuto;				// 0xec
	char		pad_19[0x3];			// 0xed
	int32_t		iDamage;				// 0xf0
	float_t		flArmorRatio;			// 0xf4
	int32_t		iBullets;				// 0xf8
	float_t		flPenetration;			// 0xfc
	char		pad_23[0x8];			// 0x100
	float_t		flWeaponRange;			// 0x108
	float_t		flRangeModifier;		// 0x10c
	float_t		flThrowVelocity;		// 0x110
	char		pad_26[0xc];			// 0x114
	bool		bHasSilencer;			// 0x120
	char		pad_27[0xb];			// 0x121
	char*		szBulletType;			// 0x12c
	float_t		flMaxSpeed;				// 0x130
	float_t		flMaxSpeedAlt;			// 0x134
	float		flSpread;				// 0x138
	float		flSpreadAlt;			// 0x13C
	float		flInaccuracyCrouch;		// 0x140
	float		flInaccuracyCrouchAlt;	// 0x144
	float		flInaccuracyStand;		// 0x148
	float		flInaccuracyStandAlt;	// 0x14C
	char		pad_29[0x34];			// 0x150
	int32_t		iRecoilSeed;			// 0x184
};

class DT_WeaponC4 {
public:
	bool m_bStartedArming()
	{
		return *(bool*)(uintptr_t(this) + 0x33F0);
	}
};

class C_BaseCombatWeapon // : public C_WeaponCSBase
{
public:

	//NETVAR("DT_WeaponCSBase", "m_bReloadVisuallyComplete", m_bReloadVisuallyComplete, bool);


	//NETVAR( get_next_primary_attack, float, "CBaseCombatWeapon->m_flNextPrimaryAttack" )
	//NETVAR( get_postpone_fire_ready_time, float, "CWeaponCSBase->m_flPostponeFireReadyTime" )
	//NETVAR( get_clip1, int, "CBaseCombatWeapon->m_iClip1" )
	//NETVAR( get_max_clip, int, "CBaseCombatWeapon->m_iPrimaryReserveAmmoCount" )
	//OFFSET(bool, in_reload, 0x32A5)
		//NETVAR( get_throw_time, float, "CBaseCSGrenade->m_fThrowTime" )
		//NETVAR( get_pin_pulled, bool, "CBaseCSGrenade->m_bPinPulled" )
		//NETVAR( get_world_model_handle, CBaseHandle, "CBaseCombatWeapon->m_hWeaponWorldModel" )
		//NETVAR( get_last_shot_time, float, "CWeaponCSBase->m_fLastShotTime" )	
		VFUNC(452, get_spread(), float(__thiscall*)(void*))()
		VFUNC(482, get_inaccuracy(), float(__thiscall*)(void*))()
		//VFUNC( 480, update_accuracy(), void( __thiscall* )( void* ) )( )
		VFUNC(460, getWeaponData(), CCSWeaponData*(__thiscall*)(void*))()

		bool IsKnife();

		void setViewModelIndex(int value)
		{
			*(int*)(uintptr_t(this) + 0x3234) = value;
		}

		void setWorldModelIndex(int value)
		{
			*(int*)(uintptr_t(this) + 0x3244) = value;
		}

		POFFSET(int, m_nSequence, 0x28BC);
		POFFSET(float, m_flCycle, 0xA14);

		/*
		bool is_grenade();
		int get_weapon_id();
		int get_weapon_type();
		bool is_knife();
		bool is_being_thrown();

		CCSWeaponData* get_wpn_data_safe();

		C_EconItemView* get_econ_item_view()
		{
			static auto Address = sig( "client_panorama.dll", "E8 ? ? ? ? 89 44 24 28 85 C0 0F 84 ? ? ? ? 8B C8" );
			static auto fnGetEconItemView = reinterpret_cast< C_EconItemView*( __thiscall* )( void* ) >( *reinterpret_cast< uintptr_t* >( Address + 1 ) + Address + 5 );

			return fnGetEconItemView( this );
		}*/
};


class Entity {

public:
	
	//NETVAR("DT_CSPlayer", "m_bHasDefuser", m_bHasDefuser, bool)
	//NETVAR("DT_BasePlayer", "m_vecOrigin", origin, Vector);
	NETVAR("DT_CSPlayer", "m_flSimulationTime", simulation_time, float);
	//NETVAR("DT_BasePlayer", "m_vecViewOffset[0]", view_offset, Vector);
	NETVAR("DT_PlantedC4", "m_bBombTicking", c4_is_ticking, bool);
	NETVAR("DT_PlantedC4", "m_bBombDefused", c4_is_defused, bool);
	NETVAR("DT_PlantedC4", "m_hBombDefuser", c4_gets_defused, float);
	NETVAR("DT_PlantedC4", "m_flC4Blow", c4_blow_time, float);
	NETVAR("DT_PlantedC4", "m_flDefuseCountDown", c4_defuse_countdown, float);
	//NETVAR("CBaseEntity", "m_nModelIndex", modelIndex, unsigned)
	NETVAR("DT_CSPlayer", "m_nTickBase", get_tick_base, int);
	NETVAR("DT_CSPlayer", "m_bGunGameImmunity", m_bGunGameImmunity, bool);
	//NETVAR("DT_BasePlayer", "m_lifeState", m_lifeState, int32_t);
	//NETVAR(CHandle<c_base_combat_weapon>, m_hActiveWeapon, "DT_BaseCombatCharacter", "m_hActiveWeapon");
	NETVAR("DT_CSPlayer", "m_bHasHelmet", m_bHasHelmet, bool);
	NETVAR("DT_CSPlayer", "m_bHasHeavyArmor", m_bHasHeavyArmor, bool);
	NETVAR("DT_CSPlayer", "m_ArmorValue", m_ArmorValue, int);
	//NETVAR(int, m_MoveType, "DT_CSPlayer", "m_MoveType");
	//NETVAR(Vector, m_vecViewOffset, "DT_BasePlayer", "m_vecViewOffset[0]");
	//NETVAR("DT_CSPlayer", "m_bIsScoped", m_bIsScoped, bool);

	OFFSET(int, m_iHealth, 0x100);
	OFFSET(int, m_iMaxHealth, 0x29F8);

	OFFSET(Vector, m_vecOrigin, 0x138);
	OFFSET(Vector, m_vecViewOffset, 0x108);

	OFFSET(int, get_take_damage, 0x27C);
	OFFSET(bool, m_bDormant, 0xED);
	OFFSET(unsigned, m_nModelIndex, 0x258);
	OFFSET(int, m_hViewModel, 0x32F8);

	OFFSET(float, m_flFlashDuration, 0xA420);
	OFFSET(float, m_flFlashAlpha, 0xA41C - 0x8);
	OFFSET(float, m_flFlashMaxAlpha, 0xA41C);

	OFFSET(Vector, m_viewPunchAngle, 0x3020);

	OFFSET(int, m_fFlags, 0x104);

	OFFSET(Vector, m_vecVelocity, 0x114);

	OFFSET(int, m_nMoveType, 0x25C);

	//NETVAR("DT_CSPlayer", "m_hObserverTarget", m_hObserverTarget, int);

	void setSpotted(bool spot)
	{
		*reinterpret_cast<bool*>(uintptr_t(this) + 0x93D) = spot;
	}

	void setModelIndex(int index)
	{
		using original_fn = void(__thiscall*)(void*, int);
		return (*(original_fn**)this)[75](this, index);
	}

	CBaseHandle m_hRagdoll() {
		return (*(DWORD*)(uintptr_t(this) + 0xA3EC)) & 0xFFF;
	}

	//NETVAR(int32_t, m_bDidSmokeEffect, "DT_BaseCSGrenadeProjectile", "m_bDidSmokeEffect");
	//NETVAR(int32_t, m_nSmokeEffectTickBegin, "DT_BaseCSGrenadeProjectile", "m_nSmokeEffectTickBegin");
	//NETVAR(Vector, m_viewPunchAngle, "DT_BasePlayer", "m_viewPunchAngle");
	//NETVAR(Vector, m_aimPunchAngle, "DT_BasePlayer", "m_aimPunchAngle");
	//NETVAR(bool, m_bUseCustomAutoExposureMin, "DT_EnvTonemapController", "m_bUseCustomAutoExposureMin");
	//NETVAR(bool, m_bUseCustomAutoExposureMax, "DT_EnvTonemapController", "m_bUseCustomAutoExposureMax");
	//NETVAR(float, m_flCustomAutoExposureMin, "DT_EnvTonemapController", "m_flCustomAutoExposureMin");
	//NETVAR(float, m_flCustomAutoExposureMax, "DT_EnvTonemapController", "m_flCustomAutoExposureMax");
	//NETVAR(float, m_flCustomBloomScale, "DT_EnvTonemapController", "m_flCustomBloomScale");
	//NETVAR("DT_CSPlayer", "m_flFlashDuration", m_flFlashDuration, float);
	//NETVAR(float, m_flFlashMaxAlpha, "DT_CSPlayer", "m_flFlashMaxAlpha");
	//NETVAR(float, m_flDuckSpeed, "DT_BaseEntity", "m_flDuckSpeed");
	//NETVAR(float, m_flDuckAmount, "DT_BaseEntity", "m_flDuckAmount");
	//NETVAR(int32_t, m_fFlags, "DT_BasePlayer", "m_fFlags");
	//NETVAR(Vector, m_vecVelocity, "DT_BasePlayer", "m_vecVelocity[0]");
	//NETVAR(int32_t, m_nTickBase, "DT_BasePlayer", "m_nTickBase");
	//NETVAR(float, m_flSimulationTime, "DT_BaseEntity", "m_flSimulationTime");
	//NETVAR(Vector, m_angAbsAngles, "DT_BaseEntity", "m_angAbsAngles");
	//NETVAR(float, m_lby, "DT_CSPlayer", "m_flLowerBodyYawTarget");
	//NETVAR(Vector, m_angEyeAngles, "DT_CSPlayer", "m_angEyeAngles[0]");
	//NETVAR(int, m_fEffects, "DT_BaseEntity", "m_fEffects");
	//NETVAR(float, m_flNextAttack, "CBaseCombatCharacter", "m_flNextAttack");
	
	
	unsigned long m_hObserverTarget() {
		return (*reinterpret_cast<unsigned long*>(uintptr_t(this) + 0x338C));
	}

	bool m_bIsDefusing() {
		return (*reinterpret_cast<bool*>(uintptr_t(this) + 0x3930));
	}

	bool m_bHasDefuser() {
		return (*reinterpret_cast<bool*>(uintptr_t(this) + 0xB388));
	}

	bool m_bIsScoped() {
		return (*reinterpret_cast<bool*>(uintptr_t(this) + 0x3928));
	}

	bool hasC4();
	bool is(hash32_t hash);

	CBaseHandle m_hActiveWeapon() {

		return (CBaseHandle)(uintptr_t(this) + 0x2EF8);
		//auto active_weapon = *(reinterpret_cast<DWORD*>(uintptr_t(this) + 0x2EF8)) & 0xFFF;
		//return reinterpret_cast<weapon_t*>(interfaces::clientEntityList->getClientEntity(active_weapon));
	}
	
	int* myWeapons() {
		return (reinterpret_cast<int*>(uintptr_t(this) + 0x2DE8));
	}


	C_BaseCombatWeapon* getWeapon();

	void* animation() {
		return reinterpret_cast<void*>(uintptr_t(this) + 0x4);
	}

	void* networkable() {
		return reinterpret_cast<void*>(uintptr_t(this) + 0x8);
	}

	ClientClass* Class() {
		using original_fn = ClientClass * (__thiscall*)(void*);
		return (*(original_fn**)networkable())[2](networkable());
	}


	Vector get_eye_pos() {
		return m_vecOrigin() + m_vecViewOffset();
	}

	void* GetCollideable() {
		using original_fn = void * (__thiscall*)(void*);
		return (*(original_fn**)this)[3](this);
	}

	Vector getAbsoluteOrigin() {
		__asm {
			MOV ECX, this
			MOV EAX, DWORD PTR DS : [ECX]
			CALL DWORD PTR DS : [EAX + 0x28]
		}
	}

	model_t* model() {
		using original_fn = model_t * (__thiscall*)(void*);
		return (*(original_fn**)animation())[8](animation());
	}


	int fov()
	{
		return *reinterpret_cast<int*>(uintptr_t(this) + 0x31E4);
	}

	bool setup_bones(matrix3x4_t* out, int max_bones, int mask, float time) {

		if (!this) {
			return false;
		}

		using original_fn = bool(__thiscall*)(void*, matrix3x4_t*, int, int, float);
		return (*(original_fn**)animation())[13](animation(), out, max_bones, mask, time);
	}

	Vector get_bone_position(int bone) {

		matrix3x4_t bone_matrices[128];

		Vector result;

		if (setup_bones(bone_matrices, 128, 256, 0.0f))
			result = Vector{ bone_matrices[bone][0][3], bone_matrices[bone][1][3], bone_matrices[bone][2][3] };
		else
			result = Vector{ };

		return result;
	}

	/*
	bool isDormant() {
		return *reinterpret_cast<bool*>(uintptr_t(this) + offset::DT_BaseEntity::m_bDormant);
	}*/

	int m_lifeState() {
		return (*reinterpret_cast<int*>(uintptr_t(this) + 0x25F));
	}

	int m_iTeamNum() {
		return (*reinterpret_cast<int*>(uintptr_t(this) + 0xF4));
	}

	bool isAlive() {
		return m_lifeState() == 0;
	}

	bool isPlayer() {

		using original_fn = bool(__thiscall*)(void*);
		return (*(original_fn**)this)[157](this);
	}

	int index() {
		using original_fn = int(__thiscall*)(void*);
		return (*(original_fn**)networkable())[10](networkable());
	}

	/*
	float m_flSimulationTime() {
		return *reinterpret_cast<float*>(uintptr_t(this) + 0x268);
	}

	// from alphauc sdk : https://github.com/alphauc/sdk

	clientClass_t* clientClass() {
		using original_fn = clientClass_t * (__thiscall*)(void*);
		return (*(original_fn**)networkable())[2](networkable());
	}



	model_t* model() {
		using original_fn = model_t * (__thiscall*)(void*);
		return (*(original_fn**)animation())[8](animation());
	}

	int drawModel(int flags, uint8_t alpha) {
		using original_fn = int(__thiscall*)(void*, int, uint8_t);
		return (*(original_fn**)animation())[9](animation(), flags, alpha);
	}

	bool setup_bones(matrix_t* out, int max_bones, int mask, float time) {

		if (!this) {
			return false;
		}

		using original_fn = bool(__thiscall*)(void*, matrix_t*, int, int, float);
		return (*(original_fn**)animation())[13](animation(), out, max_bones, mask, time);
	}*/
};

/*
class Weapon {
public:
	VFUNC(457, get_wpn_data(), CCSWeaponData*(__thiscall*)(void*))()
};*/

/*
class C_BaseEntity //: public IClientEntity
{
public:
		VFUNC( 17, get_pred_desc_map(), datamap_t*( __thiscall * )( void* ) )( )

		NETVAR( get_team, int, "CBaseEntity->m_iTeamNum" )
		NETVAR( get_origin, Vector, "CBaseEntity->m_vecOrigin" )
		NETVARA( get_oldorigin, Vector, "CBaseEntity->m_vecOrigin", 0x274 )
		NETVAR( get_simtime, float, "CBaseEntity->m_flSimulationTime" )
		NETVARA( get_oldsimtime, float, "CBaseEntity->m_flSimulationTime", 4 )
		NETVAR( get_spotted, bool, "CBaseEntity->m_bSpotted" )
		NETVAR( get_model_idx, unsigned, "CBaseEntity->m_nModelIndex" )
		NETVAR( get_owner_ent, uint32, "CBaseEntity->m_hOwnerEntity" )
		NETVAR( get_rotation, QAngle, "CBaseEntity->m_angRotation" )
		OFFSET( get_take_damage, int, 0x27C )
		DATAMAPVAR( get_effects, int, "m_fEffects" )
		DATAMAPVAR( get_duck_amt, float, "m_flDuckAmount" )
		DATAMAPVAR( get_eflags, int, "m_iEFlags" )
		DATAMAPVAR( get_abs_velocity, Vector, "m_vecAbsVelocity" )
		DATAMAPVAR( get_abs_rotation, Vector, "m_angAbsRotation" )
		DATAMAPVAR( get_abs_origin, Vector, "m_vecAbsOrigin" )
		//MFUNC( set_abs_origin( Vector origin ), void( __thiscall* )( void*, const Vector& ), offsets::set_abs_origin )( origin )
		//MFUNC( is_breakable_entity(), bool( __thiscall* )( void* ), offsets::is_breakable_entity )( )
		VFUNC( 75, set_model_idx( int index ), void( __thiscall* )( void*, int ) )( index )
		NETPROP( get_rotation_prop, "CBaseEntity->m_angRotation" )


		//model_t* get_model();
	//IClientRenderable* get_renderable();
};


class C_BaseCombatCharacter : public C_BaseEntity
{
public:
	PNETVAR( get_weapons, CBaseHandle, "CBaseCombatCharacter->m_hMyWeapons" )
	PNETVAR( get_wearables, CBaseHandle, "CBaseCombatCharacter->m_hMyWearables" )
	PNETVAR( get_active_weapon, CBaseHandle, "CBaseCombatCharacter->m_hActiveWeapon" )
};

class CEconItemDefinition;
*/

class C_BaseAttributableItem
{
public:

	void PreDataUpdate(DataUpdateType_t update_type) {

		IClientNetworkable* net = (IClientNetworkable*)((Entity*)this)->networkable();
		return net->PreDataUpdate(update_type);

		//using original_fn = void(__thiscall*)(void*, int);
		//return (*(original_fn * *)e->networkable())[6](e->networkable(), update_type);
	}

	void PostDataUpdate(DataUpdateType_t update_type) {

		IClientNetworkable* net = (IClientNetworkable*)((Entity*)this)->networkable();
		return net->PostDataUpdate(update_type);
	}

	void OnDataChanged(DataUpdateType_t update_type) {

		IClientNetworkable* net = (IClientNetworkable*)((Entity*)this)->networkable();
		return net->OnDataChanged(update_type);
	}

	bool IsBaseCombatWeapon() {
		using original_fn = bool(__thiscall*)(void*);
		return (*(original_fn**)this)[166](this);
	}

	POFFSET(int, m_nFallbackPaintKit, 0x31C8)
	POFFSET(int, m_iAccountID, 0x2FC8)
	POFFSET(int, m_OriginalOwnerXuidHigh, 0x31C4)
	POFFSET(int, m_OriginalOwnerXuidLow, 0x31C0)
	POFFSET(int, m_hOwner, 0x29CC)
	POFFSET(int, m_flFallbackWear, 0x31D0)
	POFFSET(int, m_nFallbackSeed, 0x31CC)
	POFFSET(int, m_iEntityQuality, 0x2FAC)
	POFFSET(int, m_nModelIndex, 0x258)
	POFFSET(int, m_iViewModelIndex, 0x3240)
	OFFSET(uintptr_t, m_hWeaponWorldModel, 0x3254)
	POFFSET(int, m_iItemIDHigh, 0x2FC0)
	POFFSET(int, m_iItemDefinitionIndex, 0x2FAA)

	/*
	int getViewModelIndex()
	{
		return *(int*)(uintptr_t(this) + 0x3220);
	}

	uintptr_t WeaponWorldModel() {
		return *(uintptr_t*)(uintptr_t(this) + 0x31F4);
	}*/
};

/*
class C_BaseWeaponWorldModel : public C_BaseEntity {};


class CEconItemDefinition
{
public:
	virtual const char * get_definition_index() = 0;
	virtual const char * get_prefab_name() = 0;
	virtual const char * get_item_base_name() = 0;
	virtual const char * get_item_type_name() = 0;
	virtual const char * get_item_desc() = 0;
	virtual const char * get_inventory_image() = 0;
	int GetEquippedPosition()
	{
		return *reinterpret_cast< int* >( ( uintptr_t )this + 0x24C );
	}
};

class IRefCounted;
class CEconItem;

class C_EconItemView
{
public:
	/ *
	CEconItemDefinition * get_static_data()
	{
		static auto fnGetStaticData = reinterpret_cast< CEconItemDefinition*( __thiscall* )( void* ) >( sig( "client_panorama.dll", "55 8B EC 51 56 57 8B F1 E8 ? ? ? ? 0F B7 8E" ) );
		return fnGetStaticData( this );
	}
	CEconItem* GetSOCData()
	{
		static auto fnGetSOCData = reinterpret_cast< CEconItem*( __thiscall* )( C_EconItemView* ) >( sig( "client_panorama.dll", "55 8B EC 83 E4 F0 83 EC 18 56 8B F1 57 8B 86" ) );

		return fnGetSOCData( this );
	}
	int InitializeAttributes()
	{
		static auto fnInitializeAttributes = reinterpret_cast< int( __thiscall* )( void* ) >( sig( "client_panorama.dll", "55 8B EC 83 E4 F8 83 EC 0C 53 56 8B F1 8B 86" ) );

		return fnInitializeAttributes( this );
	}* /

	char _pad_0x0000[ 0x14 ];
	CUtlVector<IRefCounted*>	m_CustomMaterials; //0x0014
	char _pad_0x0034[ 0x160 ];
	__int32                     m_iItemDefinitionIndex; //0x0194 
	__int32                     m_iEntityQuality; //0x0198 
	__int32                     m_iEntityLevel; //0x019C 
	char _pad_0x01A0[ 0x8 ]; //0x01A0
	__int32                     m_iItemIDHigh; //0x01A8 
	__int32                     m_iItemIDLow; //0x01AC 
	__int32                     m_iAccountID; //0x01B0 
	char pad_0x01B4[ 0x8 ]; //0x01B4
	unsigned char               m_bInitialized; //0x01BC 
	char pad_0x01BD[ 0x63 ]; //0x01BD
	CUtlVector<IRefCounted*>    m_VisualsDataProcessors; //0x0220
};

class C_AttributeManager
{
public:
	char	_pad_0x0000[ 0x18 ];
	__int32						m_iReapplyProvisionParity; //0x0018 
	DWORD						m_hOuter; //0x001C 
	char	_pad_0x0020[ 0x4 ];
	__int32						m_ProviderType; //0x0024 
	char	_pad_0x0028[ 0x18 ];
	C_EconItemView				m_Item; //0x0040 
};

class C_WeaponCSBase : public C_BaseAttributableItem
{
public:
	char	_pad_0x0000[ 0x09CC ];
	CUtlVector<IRefCounted*>	m_CustomMaterials; //0x09DC
	char	_pad_0x09F0[ 0x2380 ];
	C_AttributeManager			m_AttributeManager; //0x2D70
	char	_pad_0x2D84[ 0x2F9 ];
	bool						m_bCustomMaterialInitialized; //0x32DD
};*/

/*
class C_BasePlayer : public C_BaseCombatCharacter
{
public:
	NETVAR( get_lifestate, LifeState, "CBasePlayer->m_lifeState" )
	NETVAR( get_health, int, "CBasePlayer->m_iHealth" )
	NETVAR( get_flags, int, "CBasePlayer->m_fFlags" )
	NETVAR( get_tickbase, int, "CBasePlayer->m_nTickBase" )
	NETVAR( get_velocity, Vector, "CBasePlayer->m_vecVelocity[0]" )
	NETVAR( get_aim_punch, QAngle, "CBasePlayer->m_aimPunchAngle" )
	NETVAR( get_view_punch, QAngle, "CBasePlayer->m_viewPunchAngle" )
	NETVAR( get_observer_mode, int, "CBasePlayer->m_iObserverMode" )
	NETVAR( get_observer_target, CBaseHandle, "CBasePlayer->m_hObserverTarget" )
	NETVAR( get_view_model, CBaseHandle, "CBasePlayer->m_hViewModel[0]" )
	DATAMAPVAR( get_move_type, int, "m_MoveType" )
	DATAMAPVAR( get_next_attack, float, "m_flNextAttack" )
	OFFSET( get_spawn_time, float, 0xA360)
	//VFUNC( 11, get_abs_angles(), QAngle&( __thiscall* )( void* ) )( )
	//MFUNC( set_abs_angles( QAngle ang ), void( __thiscall* )( void*, const QAngle& ), offsets::set_abs_angles )( ang )
	//MFUNC( invalidate_physics_recursive( int physbit ), void( __thiscall* )( void*, int ), offsets::invalidate_physics_recursive )( physbit )

		/ *
	bool get_alive();
	Vector get_eye_pos();
	bool is_enemy();
	player_info_t get_player_info() const;
	std::string get_name() const;
	C_CSPlayer* get_observer(); * /
};

class CBoneAccessor;
class CBoneCache;
class CStudioHdr;
class CThreadFastMutex;
class C_BaseAnimating : public C_BasePlayer
{
public:
	NETVAR( get_hitbox_set, int, "CBaseAnimating->m_nHitboxSet" )
	//ANETVAR( get_pose_params, float, 24, "CBaseAnimating->m_flPoseParameter" )
	NETVAR( get_model_scale, float, "CBaseAnimating->m_flModelScale" )
	NETVAR( get_clientside_animation, bool, "CBaseAnimating->m_bClientSideAnimation" )
	DATAMAPVAR( get_playback_rate, int, "m_flPlaybackRate" )
	//OFFSET( get_model_ptr, CStudioHdr*, 0x294C)
	//OFFSET( get_enable_invalidate_bone_cache, bool, offsets::enable_invalidate_bone_cache )
	OFFSET( get_writable_bones, int, 0x26B0);
	//POFFSET( get_bone_accessor, CBoneAccessor, 0x26A8 )
	//POFFSET( get_bone_cache, CBoneCache, 0x2910) 
	NETVAR( get_force_bone, int, "CBaseAnimating->m_nForceBone" );
};

class CCSGOPlayerAnimState;
class QuaternionAligned;
class Quaternion;
class C_AnimationLayer;
class CIKContext;
struct studiohdr_t;

class C_CSPlayer : public C_BaseAnimating
{
public:
	//NETVAR( get_lby, float, "CCSPlayer->m_flLowerBodyYawTarget" )
	NETVAR( get_helmet, bool, "CCSPlayer->m_bHasHelmet" )
	NETVAR( get_armor, int, "CCSPlayer->m_ArmorValue" )
	NETVAR( get_heavy_armor, bool, "CCSPlayer->m_bHasHeavyArmor" )
	//NETVAR( get_eye_angles, QAngle, "CCSPlayer->m_angEyeAngles" )
	//NETVAR( get_flash_alpha, float, "CCSPlayer->m_flFlashMaxAlpha" )
	NETVAR( get_scoped, bool, "CCSPlayer->m_bIsScoped" )
	//NETVAR( get_immunity, bool, "CCSPlayer->m_bGunGameImmunity" )
	NETVAR( has_defuser, bool, "CCSPlayer->m_bHasDefuser" )
	//NETVAR( get_tp_angle, QAngle, "CCSPlayer->deadflag" )
	//OFFSET( get_visual_angles, QAngle, 0x31D8) // CCSPlayer->deadflag + 0x4
	//OFFSET( get_context, CIKContext*, 0x266C + 0x4 )
	//OFFSET( get_occlusion_flags, int, 0xA28 )
	//APOFFSET( get_anim_layers, C_AnimationLayer, 15, 0x2980)
	//OFFSET( get_anim_layer_count, int, 0x2980 + 12 )
	//OFFSET( get_anim_state, CCSGOPlayerAnimState*, 0x3900)
	//FUNC( create_anim_state( CCSGOPlayerAnimState* state ), void( __thiscall* )( CCSGOPlayerAnimState*, C_BasePlayer* ), offsets::create_anim_state )( state, this )
	//VFUNC( 189, build_transformations( CStudioHdr* hdr, Vector* vec, Quaternion* q, matrix3x4_t& transform, const int mask, uint8_t* computed ), void( __thiscall* )( void*, CStudioHdr*, Vector*, Quaternion*, matrix3x4_t const&, int, uint8_t* ) )( hdr, vec, q, transform, mask, computed )
	//VFUNC( 205, standard_blending_rules( CStudioHdr* hdr, Vector* vec, Quaternion* q, const float time, const int mask ), void( __thiscall* )( void*, CStudioHdr*, Vector*, Quaternion*, float, int ) )( hdr, vec, q, time, mask )
	//VFUNC( 223, update_clientside_anim(), void( __thiscall* )( void* ) )( )
		/ *
	NETPROP( get_lby_prop, "CCSPlayer->m_flLowerBodyYawTarget" )
	NETPROP( get_eye_angles0_prop, "CCSPlayer->m_angEyeAngles[0]" )
	NETPROP( get_eye_angles1_prop, "CCSPlayer->m_angEyeAngles[1]" )

	
	static bool setup_bones( lag_record_t& record, int boneMask, matrix3x4_t* pBoneToWorldOut );
	void set_anim_layers( std::array<C_AnimationLayer, 15>& layers );
	void set_pose_params( std::array<float, 24>& params );
	void set_pose_params_scaled( std::array<float, 24>& params );
	void set_pose_param( int param, float value );
	int get_sequence_act( int sequence );
	float  GetDesyncDelta();* /
};

class C_PlantedC4 : public C_BaseEntity
{
public:
	NETVAR( get_defuser, int32, "CPlantedC4->m_hBombDefuser" )
	NETVAR( get_defused, bool, "CPlantedC4->m_bBombDefused" )
	NETVAR( get_ticking, bool, "CPlantedC4->m_bBombTicking" )
	NETVAR( get_timer, float, "CPlantedC4->m_flC4Blow" )
};

class CSmokeGrenadeProjectile
{
public:
	//NETPROP( get_smoke_effect_prop, "CSmokeGrenadeProjectile->m_bDidSmokeEffect" )
};



class C_locPlayer
{
	friend bool operator==( const C_locPlayer& lhs, void* rhs ) { return *lhs.m_loc == rhs; }
public:
	C_locPlayer() : m_loc( nullptr ) {}

	operator bool() const { return *m_loc != nullptr; }
	operator C_CSPlayer*( ) const { return *m_loc; }

	C_CSPlayer* operator->() const { return *m_loc; }

private:
	C_CSPlayer * *m_loc;
}; */

#endif // !Entity_h


```

`Lumina/Lumina/sdk/structs/IClientEntity.h`:

```h
#pragma once

#ifndef IClientEntity_h

#define IClientEntity_h


enum DrawModelFlags_t
{
	STUDIO_NONE = 0x00000000,
	STUDIO_RENDER = 0x00000001,
	STUDIO_VIEWXFORMATTACHMENTS = 0x00000002,
	STUDIO_DRAWTRANSLUCENTSUBMODELS = 0x00000004,
	STUDIO_TWOPASS = 0x00000008,
	STUDIO_STATIC_LIGHTING = 0x00000010,
	STUDIO_WIREFRAME = 0x00000020,
	STUDIO_ITEM_BLINK = 0x00000040,
	STUDIO_NOSHADOWS = 0x00000080,
	STUDIO_WIREFRAME_VCOLLIDE = 0x00000100,
	STUDIO_NOLIGHTING_OR_CUBEMAP = 0x00000200,
	STUDIO_SKIP_FLEXES = 0x00000400,
	STUDIO_DONOTMODIFYSTENCILSTATE = 0x00000800,
	// Not a studio flag, but used to flag model as a non-sorting brush model
	STUDIO_tr = 0x80000000,
	// Not a studio flag, but used to flag model as using shadow depth material override
	STUDIO_SHADOWDEPTHTEXTURE = 0x40000000,
	// Not a studio flag, but used to flag model as doing custom rendering into shadow texture
	STUDIO_SHADOWTEXTURE = 0x20000000,
	STUDIO_SKIP_DECALS = 0x10000000,
};

class bf_read;
using CBaseHandle = unsigned long;

class ICollideable;
class IClientRenderable;
class IClientEntity;
class C_BaseEntity;
class IClientThinkable;
class IClientAlphaProperty;

class IHandleEntity
{
public:
	virtual ~IHandleEntity() {}
	virtual void SetRefEHandle( const CBaseHandle& handle ) = 0;
	virtual const CBaseHandle& GetRefEHandle() const = 0;
};

struct SolidType_t;
struct Ray_t;
class CGameTrace;
typedef CGameTrace trace_t;
struct model_t;
class IClientUnknown;

class ICollideable
{
public:
	virtual IHandleEntity*      GetEntityHandle() = 0;
	virtual Vector&				OBBMins() const = 0;
	virtual Vector&				OBBMaxs() const = 0;
	virtual void                WorldSpaceTriggerBounds( Vector *pVecWorldMins, Vector *pVecWorldMaxs ) const = 0;
	virtual bool                TestCollision( const Ray_t &ray, unsigned int fContentsMask, trace_t& tr ) = 0;
	virtual bool                TestHitboxes( const Ray_t &ray, unsigned int fContentsMask, trace_t& tr ) = 0;
	virtual int                 GetCollisionModelIndex() = 0;
	virtual const model_t*      GetCollisionModel() = 0;
	virtual Vector&				GetCollisionOrigin() const = 0;
	virtual QAngle&		        GetCollisionAngles() const = 0;
	virtual const matrix3x4_t&  CollisionToWorldTransform() const = 0;
	virtual SolidType_t         GetSolid() const = 0;
	virtual int                 GetSolidFlags() const = 0;
	virtual IClientUnknown*     GetIClientUnknown() = 0;
	virtual int                 GetCollisionGroup() const = 0;
	virtual void                WorldSpaceSurroundingBounds( Vector *pVecMins, Vector *pVecMaxs ) = 0;
	virtual bool                ShouldTouchTrigger( int triggerSolidFlags ) const = 0;
	virtual const matrix3x4_t*  GetRootParentToWorldTransform() const = 0;
};

class IClientNetworkable
{
public:
	virtual IClientUnknown*	GetIClientUnknown() = 0;
	virtual void			Release() = 0;
	virtual ClientClass*	GetClientClass() = 0;
	virtual void			NotifyShouldTransmit(int state) = 0;
	virtual void			OnPreDataChanged(int updateType) = 0;
	virtual void			OnDataChanged(int updateType) = 0;
	virtual void			PreDataUpdate(int updateType) = 0;
	virtual void			PostDataUpdate(int updateType) = 0;
	virtual void			OnDataUnchangedInPVS() = 0;
	virtual bool			IsDormant() = 0;
	virtual int				EntIndex() const = 0;
	virtual void			ReceiveMessage(int classID, bf_read& msg) = 0;
	virtual void*			GetDataTableBasePtr() = 0;
	virtual void			SetDestroyedOnRecreateEntities() = 0;
};


class IClientUnknown : public IHandleEntity
{
public:
	virtual ICollideable*			GetCollideable() = 0;
	virtual IClientNetworkable*		GetClientNetworkable() = 0;
	virtual IClientRenderable*		GetClientRenderable() = 0;
	virtual IClientEntity*			GetIClientEntity() = 0;
	virtual C_BaseEntity*			GetBaseEntity() = 0;
	virtual IClientThinkable*		GetClientThinkable() = 0;
	virtual IClientAlphaProperty*	GetClientAlphaProperty() = 0;
};

class IClientThinkable
{
public:
	virtual ~IClientThinkable() {};
};

typedef unsigned short ClientShadowHandle_t;
typedef unsigned short ClientRenderHandle_t;
typedef unsigned short ModelInstanceHandle_t;
struct model_t;
struct RenderableInstance_t
{
	uint8_t m_nAlpha;
};
class IClientRenderable
{
public:
	virtual IClientUnknown*            GetIClientUnknown() = 0;
	virtual Vector const&              GetRenderOrigin( void ) = 0;
	virtual QAngle const&              GetRenderAngles( void ) = 0;
	virtual bool                       ShouldDraw( void ) = 0;
	virtual int                        GetRenderFlags( void ) = 0; // ERENDERFLAGS_xxx
	virtual void                       Unused( void ) const {}
	virtual ClientShadowHandle_t       GetShadowHandle() const = 0;
	virtual ClientRenderHandle_t&      RenderHandle() = 0;
	virtual const model_t*             GetModel() const = 0;
	virtual int                        DrawModel( int flags, uint8_t alpha ) = 0;
	virtual int                        GetBody() = 0;
	virtual void                       GetColorModulation( float* color ) = 0;
	virtual bool                       LODTest() = 0;
	virtual bool                       SetupBones( matrix3x4_t *pBoneToWorldOut, int nMaxBones, int boneMask, float currentTime ) = 0;
	virtual void                       SetupWeights( const matrix3x4_t *pBoneToWorld, int nFlexWeightCount, float *pFlexWeights, float *pFlexDelayedWeights ) = 0;
	virtual void                       DoAnimationEvents( void ) = 0;
	virtual void* /*IPVSNotify*/       GetPVSNotifyInterface() = 0;
	virtual void                       GetRenderBounds( Vector& mins, Vector& maxs ) = 0;
	virtual void                       GetRenderBoundsWorldspace( Vector& mins, Vector& maxs ) = 0;
	virtual void                       GetShadowRenderBounds( Vector &mins, Vector &maxs, int /*ShadowType_t*/ shadowType ) = 0;
	virtual bool                       ShouldReceiveProjectedTextures( int flags ) = 0;
	virtual bool                       GetShadowCastDistance( float *pDist, int /*ShadowType_t*/ shadowType ) const = 0;
	virtual bool                       GetShadowCastDirection( Vector *pDirection, int /*ShadowType_t*/ shadowType ) const = 0;
	virtual bool                       IsShadowDirty() = 0;
	virtual void                       MarkShadowDirty( bool bDirty ) = 0;
	virtual IClientRenderable*         GetShadowParent() = 0;
	virtual IClientRenderable*         FirstShadowChild() = 0;
	virtual IClientRenderable*         NextShadowPeer() = 0;
	virtual int /*ShadowType_t*/       ShadowCastType() = 0;
	virtual void                       CreateModelInstance() = 0;
	virtual ModelInstanceHandle_t      GetModelInstance() = 0;
	virtual const matrix3x4_t&         RenderableToWorldTransform() = 0;
	virtual int                        LookupAttachment( const char *pAttachmentName ) = 0;
	virtual   bool                     GetAttachment( int number, Vector &origin, QAngle &angles ) = 0;
	virtual bool                       GetAttachment( int number, matrix3x4_t &matrix ) = 0;
	virtual float*                     GetRenderClipPlane( void ) = 0;
	virtual int                        GetSkin() = 0;
	virtual void                       OnThreadedDrawSetup() = 0;
	virtual bool                       UsesFlexDelayedWeights() = 0;
	virtual void                       RecordToolMessage() = 0;
	virtual bool                       ShouldDrawForSplitScreenUser( int nSlot ) = 0;
	virtual uint8_t                      OverrideAlphaModulation( uint8_t nAlpha ) = 0;
	virtual uint8_t                      OverrideShadowAlphaModulation( uint8_t nAlpha ) = 0;
};



class IClientEntity : public IClientUnknown, public IClientRenderable, public IClientNetworkable, public IClientThinkable
{
public:
    virtual void             Release(void) = 0;
    virtual const Vector     GetAbsOrigin(void) const = 0;
    virtual const QAngle     GetAbsAngles(void) const = 0;
    virtual void*            GetMouth(void) = 0;
    virtual bool             GetSoundSpatialization(void* info) = 0;
    virtual bool             IsBlurred(void) = 0;
};

#endif
```

`Lumina/Lumina/sdk/structs/IMaterial.h`:

```h
#pragma once

#include "IMaterialVar.h"

//-----------------------------------------------------------------------------
// Forward declarations
//-----------------------------------------------------------------------------

//class IMaterialVar;
class ITexture;
class IMaterialProxy;
class Vector;

typedef uint64 VertexFormat_t;

//-----------------------------------------------------------------------------
// Flags for GetVertexFormat
//-----------------------------------------------------------------------------
enum VertexFormatFlags_t
{
	// Indicates an uninitialized VertexFormat_t value
	VERTEX_FORMAT_INVALID = 0xFFFFFFFF,

	VERTEX_POSITION = 0x0001,
	VERTEX_NORMAL = 0x0002,
	VERTEX_cl = 0x0004,
	VERTEX_SPECULAR = 0x0008,

	VERTEX_TANGENT_S = 0x0010,
	VERTEX_TANGENT_T = 0x0020,
	VERTEX_TANGENT_SPACE = VERTEX_TANGENT_S | VERTEX_TANGENT_T,

	// Indicates we're using wrinkle
	VERTEX_WRINKLE = 0x0040,

	// Indicates we're using bone indices
	VERTEX_BONE_INDEX = 0x0080,

	// Indicates this expects a color stream on stream 1
	VERTEX_cl_STREAM_1 = 0x0100,

	// Indicates this format shouldn't be bloated to cache align it
	// (only used for VertexUsage)
	VERTEX_FORMAT_USE_EXACT_FORMAT = 0x0200,

	// Indicates that compressed vertex elements are to be used (see also VertexCompressionType_t)
	VERTEX_FORMAT_COMPRESSED = 0x400,

	// Position or normal (if present) should be 4D not 3D
	VERTEX_FORMAT_PAD_POS_NORM = 0x800,

	// Update this if you add or remove bits...
	VERTEX_LAST_BIT = 11,

	VERTEX_BONE_WEIGHT_BIT = VERTEX_LAST_BIT + 1,
	USER_DATA_SIZE_BIT = VERTEX_LAST_BIT + 4,
	TEX_COORD_SIZE_BIT = VERTEX_LAST_BIT + 7,

	VERTEX_BONE_WEIGHT_MASK = ( 0x7 << VERTEX_BONE_WEIGHT_BIT ),
	USER_DATA_SIZE_MASK = ( 0x7 << USER_DATA_SIZE_BIT ),

	VERTEX_FORMAT_FIELD_MASK = 0x0FF,

	// If everything is off, it's an unknown vertex format
	VERTEX_FORMAT_UNKNOWN = 0,
};

enum MaterialPropertyTypes_t
{
	MATERIAL_PROPERTY_NEEDS_LIGHTMAP = 0,					// bool
	MATERIAL_PROPERTY_OPACITY,								// int (enum MaterialPropertyOpacityTypes_t)
	MATERIAL_PROPERTY_REFLECTIVITY,							// vec3_t
	MATERIAL_PROPERTY_NEEDS_BUMPED_LIGHTMAPS				// bool
};

//-----------------------------------------------------------------------------
// Macros for construction..
//-----------------------------------------------------------------------------
#define VERTEX_BONEWEIGHT( _n )				((_n) << VERTEX_BONE_WEIGHT_BIT)
#define VERTEX_USERDATA_SIZE( _n )			((_n) << USER_DATA_SIZE_BIT)
#define VERTEX_TEXCOORD_MASK( _coord )		(( 0x7ULL ) << ( TEX_COORD_SIZE_BIT + 3 * (_coord) ))

inline VertexFormat_t VERTEX_TEXCOORD_SIZE( int nIndex, int nNumCoords )
{
	uint64 n64 = nNumCoords;
	uint64 nShift = TEX_COORD_SIZE_BIT + ( 3 * nIndex );
	return n64 << nShift;
}



//-----------------------------------------------------------------------------
// Gets at various vertex format info...
//-----------------------------------------------------------------------------
inline int VertexFlags( VertexFormat_t vertexFormat )
{
	return static_cast< int > ( vertexFormat & ( ( 1 << ( VERTEX_LAST_BIT + 1 ) ) - 1 ) );
}

inline int NumBoneWeights( VertexFormat_t vertexFormat )
{
	return static_cast< int > ( ( vertexFormat >> VERTEX_BONE_WEIGHT_BIT ) & 0x7 );
}

inline int UserDataSize( VertexFormat_t vertexFormat )
{
	return static_cast< int > ( ( vertexFormat >> USER_DATA_SIZE_BIT ) & 0x7 );
}

inline int TexCoordSize( int nTexCoordIndex, VertexFormat_t vertexFormat )
{
	return static_cast< int > ( ( vertexFormat >> ( TEX_COORD_SIZE_BIT + 3 * nTexCoordIndex ) ) & 0x7 );
}


//-----------------------------------------------------------------------------
// VertexElement_t (enumerates all usable vertex elements)
//-----------------------------------------------------------------------------
// FIXME: unify this with VertexFormat_t (i.e. construct the lower bits of VertexFormat_t with "1 << (VertexElement_t)element")
enum VertexElement_t
{
	VERTEX_ELEMENT_NONE = -1,

	// Deliberately explicitly numbered so it's a pain in the ass to change, so you read this:
	// #!#!#NOTE#!#!# update GetVertexElementSize, VertexElementToDeclType and
	//                CVBAllocTracker (elementTable) when you update this!
	VERTEX_ELEMENT_POSITION = 0,
	VERTEX_ELEMENT_POSITION4D = 1,
	VERTEX_ELEMENT_NORMAL = 2,
	VERTEX_ELEMENT_NORMAL4D = 3,
	VERTEX_ELEMENT_cl = 4,
	VERTEX_ELEMENT_SPECULAR = 5,
	VERTEX_ELEMENT_TANGENT_S = 6,
	VERTEX_ELEMENT_TANGENT_T = 7,
	VERTEX_ELEMENT_WRINKLE = 8,
	VERTEX_ELEMENT_BONEINDEX = 9,
	VERTEX_ELEMENT_BONEWEIGHTS1 = 10,
	VERTEX_ELEMENT_BONEWEIGHTS2 = 11,
	VERTEX_ELEMENT_BONEWEIGHTS3 = 12,
	VERTEX_ELEMENT_BONEWEIGHTS4 = 13,
	VERTEX_ELEMENT_USERDATA1 = 14,
	VERTEX_ELEMENT_USERDATA2 = 15,
	VERTEX_ELEMENT_USERDATA3 = 16,
	VERTEX_ELEMENT_USERDATA4 = 17,
	VERTEX_ELEMENT_TEXCOORD1D_0 = 18,
	VERTEX_ELEMENT_TEXCOORD1D_1 = 19,
	VERTEX_ELEMENT_TEXCOORD1D_2 = 20,
	VERTEX_ELEMENT_TEXCOORD1D_3 = 21,
	VERTEX_ELEMENT_TEXCOORD1D_4 = 22,
	VERTEX_ELEMENT_TEXCOORD1D_5 = 23,
	VERTEX_ELEMENT_TEXCOORD1D_6 = 24,
	VERTEX_ELEMENT_TEXCOORD1D_7 = 25,
	VERTEX_ELEMENT_TEXCOORD2D_0 = 26,
	VERTEX_ELEMENT_TEXCOORD2D_1 = 27,
	VERTEX_ELEMENT_TEXCOORD2D_2 = 28,
	VERTEX_ELEMENT_TEXCOORD2D_3 = 29,
	VERTEX_ELEMENT_TEXCOORD2D_4 = 30,
	VERTEX_ELEMENT_TEXCOORD2D_5 = 31,
	VERTEX_ELEMENT_TEXCOORD2D_6 = 32,
	VERTEX_ELEMENT_TEXCOORD2D_7 = 33,
	VERTEX_ELEMENT_TEXCOORD3D_0 = 34,
	VERTEX_ELEMENT_TEXCOORD3D_1 = 35,
	VERTEX_ELEMENT_TEXCOORD3D_2 = 36,
	VERTEX_ELEMENT_TEXCOORD3D_3 = 37,
	VERTEX_ELEMENT_TEXCOORD3D_4 = 38,
	VERTEX_ELEMENT_TEXCOORD3D_5 = 39,
	VERTEX_ELEMENT_TEXCOORD3D_6 = 40,
	VERTEX_ELEMENT_TEXCOORD3D_7 = 41,
	VERTEX_ELEMENT_TEXCOORD4D_0 = 42,
	VERTEX_ELEMENT_TEXCOORD4D_1 = 43,
	VERTEX_ELEMENT_TEXCOORD4D_2 = 44,
	VERTEX_ELEMENT_TEXCOORD4D_3 = 45,
	VERTEX_ELEMENT_TEXCOORD4D_4 = 46,
	VERTEX_ELEMENT_TEXCOORD4D_5 = 47,
	VERTEX_ELEMENT_TEXCOORD4D_6 = 48,
	VERTEX_ELEMENT_TEXCOORD4D_7 = 49,

	VERTEX_ELEMENT_NUMELEMENTS = 50
};

inline void Detect_VertexElement_t_Changes( VertexElement_t element ) // GREPs for VertexElement_t will hit this
{
	// Make it harder for someone to change VertexElement_t without noticing that dependent code
	// (GetVertexElementSize, VertexElementToDeclType, CVBAllocTracker) needs updating
	Assert( VERTEX_ELEMENT_NUMELEMENTS == 50 );
	switch ( element )
	{
		case VERTEX_ELEMENT_POSITION:		Assert( VERTEX_ELEMENT_POSITION == 0 ); break;
		case VERTEX_ELEMENT_POSITION4D:		Assert( VERTEX_ELEMENT_POSITION4D == 1 ); break;
		case VERTEX_ELEMENT_NORMAL:			Assert( VERTEX_ELEMENT_NORMAL == 2 ); break;
		case VERTEX_ELEMENT_NORMAL4D:		Assert( VERTEX_ELEMENT_NORMAL4D == 3 ); break;
		case VERTEX_ELEMENT_cl:			Assert( VERTEX_ELEMENT_cl == 4 ); break;
		case VERTEX_ELEMENT_SPECULAR:		Assert( VERTEX_ELEMENT_SPECULAR == 5 ); break;
		case VERTEX_ELEMENT_TANGENT_S:		Assert( VERTEX_ELEMENT_TANGENT_S == 6 ); break;
		case VERTEX_ELEMENT_TANGENT_T:		Assert( VERTEX_ELEMENT_TANGENT_T == 7 ); break;
		case VERTEX_ELEMENT_WRINKLE:		Assert( VERTEX_ELEMENT_WRINKLE == 8 ); break;
		case VERTEX_ELEMENT_BONEINDEX:		Assert( VERTEX_ELEMENT_BONEINDEX == 9 ); break;
		case VERTEX_ELEMENT_BONEWEIGHTS1:	Assert( VERTEX_ELEMENT_BONEWEIGHTS1 == 10 ); break;
		case VERTEX_ELEMENT_BONEWEIGHTS2:	Assert( VERTEX_ELEMENT_BONEWEIGHTS2 == 11 ); break;
		case VERTEX_ELEMENT_BONEWEIGHTS3:	Assert( VERTEX_ELEMENT_BONEWEIGHTS3 == 12 ); break;
		case VERTEX_ELEMENT_BONEWEIGHTS4:	Assert( VERTEX_ELEMENT_BONEWEIGHTS4 == 13 ); break;
		case VERTEX_ELEMENT_USERDATA1:		Assert( VERTEX_ELEMENT_USERDATA1 == 14 ); break;
		case VERTEX_ELEMENT_USERDATA2:		Assert( VERTEX_ELEMENT_USERDATA2 == 15 ); break;
		case VERTEX_ELEMENT_USERDATA3:		Assert( VERTEX_ELEMENT_USERDATA3 == 16 ); break;
		case VERTEX_ELEMENT_USERDATA4:		Assert( VERTEX_ELEMENT_USERDATA4 == 17 ); break;
		case VERTEX_ELEMENT_TEXCOORD1D_0:	Assert( VERTEX_ELEMENT_TEXCOORD1D_0 == 18 ); break;
		case VERTEX_ELEMENT_TEXCOORD1D_1:	Assert( VERTEX_ELEMENT_TEXCOORD1D_1 == 19 ); break;
		case VERTEX_ELEMENT_TEXCOORD1D_2:	Assert( VERTEX_ELEMENT_TEXCOORD1D_2 == 20 ); break;
		case VERTEX_ELEMENT_TEXCOORD1D_3:	Assert( VERTEX_ELEMENT_TEXCOORD1D_3 == 21 ); break;
		case VERTEX_ELEMENT_TEXCOORD1D_4:	Assert( VERTEX_ELEMENT_TEXCOORD1D_4 == 22 ); break;
		case VERTEX_ELEMENT_TEXCOORD1D_5:	Assert( VERTEX_ELEMENT_TEXCOORD1D_5 == 23 ); break;
		case VERTEX_ELEMENT_TEXCOORD1D_6:	Assert( VERTEX_ELEMENT_TEXCOORD1D_6 == 24 ); break;
		case VERTEX_ELEMENT_TEXCOORD1D_7:	Assert( VERTEX_ELEMENT_TEXCOORD1D_7 == 25 ); break;
		case VERTEX_ELEMENT_TEXCOORD2D_0:	Assert( VERTEX_ELEMENT_TEXCOORD2D_0 == 26 ); break;
		case VERTEX_ELEMENT_TEXCOORD2D_1:	Assert( VERTEX_ELEMENT_TEXCOORD2D_1 == 27 ); break;
		case VERTEX_ELEMENT_TEXCOORD2D_2:	Assert( VERTEX_ELEMENT_TEXCOORD2D_2 == 28 ); break;
		case VERTEX_ELEMENT_TEXCOORD2D_3:	Assert( VERTEX_ELEMENT_TEXCOORD2D_3 == 29 ); break;
		case VERTEX_ELEMENT_TEXCOORD2D_4:	Assert( VERTEX_ELEMENT_TEXCOORD2D_4 == 30 ); break;
		case VERTEX_ELEMENT_TEXCOORD2D_5:	Assert( VERTEX_ELEMENT_TEXCOORD2D_5 == 31 ); break;
		case VERTEX_ELEMENT_TEXCOORD2D_6:	Assert( VERTEX_ELEMENT_TEXCOORD2D_6 == 32 ); break;
		case VERTEX_ELEMENT_TEXCOORD2D_7:	Assert( VERTEX_ELEMENT_TEXCOORD2D_7 == 33 ); break;
		case VERTEX_ELEMENT_TEXCOORD3D_0:	Assert( VERTEX_ELEMENT_TEXCOORD3D_0 == 34 ); break;
		case VERTEX_ELEMENT_TEXCOORD3D_1:	Assert( VERTEX_ELEMENT_TEXCOORD3D_1 == 35 ); break;
		case VERTEX_ELEMENT_TEXCOORD3D_2:	Assert( VERTEX_ELEMENT_TEXCOORD3D_2 == 36 ); break;
		case VERTEX_ELEMENT_TEXCOORD3D_3:	Assert( VERTEX_ELEMENT_TEXCOORD3D_3 == 37 ); break;
		case VERTEX_ELEMENT_TEXCOORD3D_4:	Assert( VERTEX_ELEMENT_TEXCOORD3D_4 == 38 ); break;
		case VERTEX_ELEMENT_TEXCOORD3D_5:	Assert( VERTEX_ELEMENT_TEXCOORD3D_5 == 39 ); break;
		case VERTEX_ELEMENT_TEXCOORD3D_6:	Assert( VERTEX_ELEMENT_TEXCOORD3D_6 == 40 ); break;
		case VERTEX_ELEMENT_TEXCOORD3D_7:	Assert( VERTEX_ELEMENT_TEXCOORD3D_7 == 41 ); break;
		case VERTEX_ELEMENT_TEXCOORD4D_0:	Assert( VERTEX_ELEMENT_TEXCOORD4D_0 == 42 ); break;
		case VERTEX_ELEMENT_TEXCOORD4D_1:	Assert( VERTEX_ELEMENT_TEXCOORD4D_1 == 43 ); break;
		case VERTEX_ELEMENT_TEXCOORD4D_2:	Assert( VERTEX_ELEMENT_TEXCOORD4D_2 == 44 ); break;
		case VERTEX_ELEMENT_TEXCOORD4D_3:	Assert( VERTEX_ELEMENT_TEXCOORD4D_3 == 45 ); break;
		case VERTEX_ELEMENT_TEXCOORD4D_4:	Assert( VERTEX_ELEMENT_TEXCOORD4D_4 == 46 ); break;
		case VERTEX_ELEMENT_TEXCOORD4D_5:	Assert( VERTEX_ELEMENT_TEXCOORD4D_5 == 47 ); break;
		case VERTEX_ELEMENT_TEXCOORD4D_6:	Assert( VERTEX_ELEMENT_TEXCOORD4D_6 == 48 ); break;
		case VERTEX_ELEMENT_TEXCOORD4D_7:	Assert( VERTEX_ELEMENT_TEXCOORD4D_7 == 49 ); break;
		default:
			Assert( 0 ); // Invalid Input or VertexElement_t has definitely changed
			break;
	}
}

// We're testing 2 normal compression methods
// One compressed normals+tangents into a SHORT2 each (8 bytes total)
// The other compresses them together, into a single UBYTE4 (4 bytes total)
// FIXME: pick one or the other, compare lighting quality in important cases
#define COMPRESSED_NORMALS_SEPARATETANGENTS_SHORT2	0
#define COMPRESSED_NORMALS_COMBINEDTANGENTS_UBYTE4	1
//#define COMPRESSED_NORMALS_TYPE						COMPRESSED_NORMALS_SEPARATETANGENTS_SHORT2
#define COMPRESSED_NORMALS_TYPE						COMPRESSED_NORMALS_COMBINEDTANGENTS_UBYTE4


//-----------------------------------------------------------------------------
// Shader state flags can be read from the FLAGS materialvar
// Also can be read or written to with the Set/GetMaterialVarFlags() call
// Also make sure you add/remove a string associated with each flag below to CShaderSysteMath->ShaderStateString in ShaderSystem.cpp
//-----------------------------------------------------------------------------
enum MaterialVarFlags_t
{
	MATERIAL_VAR_DEBUG = ( 1 << 0 ),
	MATERIAL_VAR_NO_DEBUG_OVERRIDE = ( 1 << 1 ),
	MATERIAL_VAR_NO_DRAW = ( 1 << 2 ),
	MATERIAL_VAR_USE_IN_FILLRATE_MODE = ( 1 << 3 ),

	MATERIAL_VAR_VERTEXCOLOR = ( 1 << 4 ),
	MATERIAL_VAR_VERTEXALPHA = ( 1 << 5 ),
	MATERIAL_VAR_SELFILLUM = ( 1 << 6 ),
	MATERIAL_VAR_ADDITIVE = ( 1 << 7 ),
	MATERIAL_VAR_ALPHATEST = ( 1 << 8 ),
	//	MATERIAL_VAR_UNUSED					  = (1 << 9),
	MATERIAL_VAR_ZNEARER = ( 1 << 10 ),
	MATERIAL_VAR_MODEL = ( 1 << 11 ),
	MATERIAL_VAR_FLAT = ( 1 << 12 ),
	MATERIAL_VAR_NOCULL = ( 1 << 13 ),
	MATERIAL_VAR_NOFOG = ( 1 << 14 ),
	MATERIAL_VAR_IGNOREZ = ( 1 << 15 ),
	MATERIAL_VAR_DECAL = ( 1 << 16 ),
	MATERIAL_VAR_ENVMAPSPHERE = ( 1 << 17 ), // OBSOLETE
	//	MATERIAL_VAR_UNUSED					  = (1 << 18),
	MATERIAL_VAR_ENVMAPCAMERASPACE = ( 1 << 19 ), // OBSOLETE
	MATERIAL_VAR_BASEALPHAENVMAPMASK = ( 1 << 20 ),
	MATERIAL_VAR_TRANSLUCENT = ( 1 << 21 ),
	MATERIAL_VAR_NORMALMAPALPHAENVMAPMASK = ( 1 << 22 ),
	MATERIAL_VAR_NEEDS_SOFTWARE_SKINNING = ( 1 << 23 ), // OBSOLETE
	MATERIAL_VAR_OPAQUETEXTURE = ( 1 << 24 ),
	MATERIAL_VAR_ENVMAPMODE = ( 1 << 25 ), // OBSOLETE
	MATERIAL_VAR_SUPPRESS_DECALS = ( 1 << 26 ),
	MATERIAL_VAR_HALFLAMBERT = ( 1 << 27 ),
	MATERIAL_VAR_WIREFRAME = ( 1 << 28 ),
	MATERIAL_VAR_ALLOWALPHATOCOVERAGE = ( 1 << 29 ),
	MATERIAL_VAR_ALPHA_MODIFIED_BY_PROXY = ( 1 << 30 ),
	MATERIAL_VAR_VERTEXFOG = ( 1 << 31 ),

	// NOTE: Only add flags here that either should be read from
	// .vmts or can be set directly from Client code. Other, internal
	// flags should to into the flag enum in IMaterialInternal.h
};


//-----------------------------------------------------------------------------
// Internal flags not accessible from outside the material system. Stored in Flags2
//-----------------------------------------------------------------------------
enum MaterialVarFlags2_t
{
	// NOTE: These are for $flags2!!!!!
	//	UNUSED											= (1 << 0),

	MATERIAL_VAR2_LIGHTING_UNLIT = 0,
	MATERIAL_VAR2_LIGHTING_VERTEX_LIT = ( 1 << 1 ),
	MATERIAL_VAR2_LIGHTING_LIGHTMAP = ( 1 << 2 ),
	MATERIAL_VAR2_LIGHTING_BUMPED_LIGHTMAP = ( 1 << 3 ),
	MATERIAL_VAR2_LIGHTING_MASK =
	( MATERIAL_VAR2_LIGHTING_VERTEX_LIT |
	  MATERIAL_VAR2_LIGHTING_LIGHTMAP |
	  MATERIAL_VAR2_LIGHTING_BUMPED_LIGHTMAP ),

	// FIXME: Should this be a part of the above lighting enums?
	MATERIAL_VAR2_DIFFUSE_BUMPMAPPED_MODEL = ( 1 << 4 ),
	MATERIAL_VAR2_USES_ENV_CUBEMAP = ( 1 << 5 ),
	MATERIAL_VAR2_NEEDS_TANGENT_SPACES = ( 1 << 6 ),
	MATERIAL_VAR2_NEEDS_SOFTWARE_LIGHTING = ( 1 << 7 ),
	// GR - HDR path puts lightmap alpha in separate texture...
	MATERIAL_VAR2_BLEND_WITH_LIGHTMAP_ALPHA = ( 1 << 8 ),
	MATERIAL_VAR2_NEEDS_BAKED_LIGHTING_SNAPSHOTS = ( 1 << 9 ),
	MATERIAL_VAR2_USE_FLASHLIGHT = ( 1 << 10 ),
	MATERIAL_VAR2_USE_FIXED_FUNCTION_BAKED_LIGHTING = ( 1 << 11 ),
	MATERIAL_VAR2_NEEDS_FIXED_FUNCTION_FLASHLIGHT = ( 1 << 12 ),
	MATERIAL_VAR2_USE_EDITOR = ( 1 << 13 ),
	MATERIAL_VAR2_NEEDS_POWER_OF_TWO_FRAME_BUFFER_TEXTURE = ( 1 << 14 ),
	MATERIAL_VAR2_NEEDS_FULL_FRAME_BUFFER_TEXTURE = ( 1 << 15 ),
	MATERIAL_VAR2_IS_SPRITECARD = ( 1 << 16 ),
	MATERIAL_VAR2_USES_VERTEXID = ( 1 << 17 ),
	MATERIAL_VAR2_SUPPORTS_HW_SKINNING = ( 1 << 18 ),
	MATERIAL_VAR2_SUPPORTS_FLASHLIGHT = ( 1 << 19 ),
	MATERIAL_VAR2_USE_GBUFFER0 = ( 1 << 20 ),
	MATERIAL_VAR2_USE_GBUFFER1 = ( 1 << 21 ),
	MATERIAL_VAR2_SELFILLUMMASK = ( 1 << 22 ),
	MATERIAL_VAR2_SUPPORTS_TESSELLATION = ( 1 << 23 )
};


//-----------------------------------------------------------------------------
// Preview image return values
//-----------------------------------------------------------------------------
enum PreviewImageRetVal_t
{
	MATERIAL_PREVIEW_IMAGE_BAD = 0,
	MATERIAL_PREVIEW_IMAGE_OK,
	MATERIAL_NO_PREVIEW_IMAGE,
};


//-----------------------------------------------------------------------------
// material interface
//-----------------------------------------------------------------------------
class IMaterial
{
public:
	// Get the name of the material.  This is a full path to 
	// the vmt file starting from "hl2/materials" (or equivalent) without
	// a file extension.
	virtual const char *	GetName() const = 0;
	virtual const char *	GetTextureGroupName() const = 0;

	// Get the preferred size/bitDepth of a preview image of a material.
	// This is the sort of image that you would use for a thumbnail view
	// of a material, or in WorldCraft until it uses materials to render.
	// separate this for the tools maybe
	virtual PreviewImageRetVal_t GetPreviewImageProperties( int *width, int *height, ImageFormat *imageFormat, bool* isTranslucent ) const = 0;

	// Get a preview image at the specified width/height and bitDepth.
	// Will do resampling if necessary.(not yet!!! :) )
	// Will do color format conversion. (works now.)
	virtual PreviewImageRetVal_t GetPreviewImage( unsigned char *data, int width, int height, ImageFormat imageFormat ) const = 0;
	// 
	virtual int				GetMappingWidth() = 0;
	virtual int				GetMappingHeight() = 0;

	virtual int				GetNumAnimationFrames() = 0;

	// For material subrects (material pages).  Offset(u,v) and scale(u,v) are normalized to texture.
	virtual bool			InMaterialPage( void ) = 0;
	virtual	void			GetMaterialOffset( float *pOffset ) = 0;
	virtual void			GetMaterialScale( float *pScale ) = 0;
	virtual IMaterial		*GetMaterialPage( void ) = 0;

	// find a vmt variable.
	// This is how game code affects how a material is rendered.
	// The game code must know about the params that are used by
	// the shader for the material that it is trying to affect.
	virtual IMaterialVar *	FindVar( const char *varName, bool *found, bool complain = true ) = 0;

	// The user never allocates or deallocates materials.  Reference counting is
	// used instead.  Garbage collection is done upon a call to 
	// IMaterialSysteMath->UncacheUnusedMaterials.
	virtual void			IncrementReferenceCount( void ) = 0;
	virtual void			DecrementReferenceCount( void ) = 0;

	inline void AddRef() { IncrementReferenceCount(); }
	inline void Release() { DecrementReferenceCount(); }

	// Each material is assigned a number that groups it with like materials
	// for sorting in the application.
	virtual int 			GetEnumerationID( void ) const = 0;

	virtual void			GetLowResColorSample( float s, float t, float *color ) const = 0;

	// This computes the state snapshots for this material
	virtual void			RecomputeStateSnapshots() = 0;

	// Are we translucent?
	virtual bool			IsTranslucent() = 0;

	// Are we alphatested?
	virtual bool			IsAlphaTested() = 0;

	// Are we vertex lit?
	virtual bool			IsVertexLit() = 0;

	// Gets the vertex format
	virtual VertexFormat_t	GetVertexFormat() const = 0;

	// returns true if this material uses a material proxy
	virtual bool			HasProxy( void ) const = 0;

	virtual bool			UsesEnvCubemap( void ) = 0;

	virtual bool			NeedsTangentSpace( void ) = 0;

	virtual bool			NeedsPowerOfTwoFrameBufferTexture( bool bCheckSpecificToThisFrame = true ) = 0;
	virtual bool			NeedsFullFrameBufferTexture( bool bCheckSpecificToThisFrame = true ) = 0;

	// returns true if the shader doesn't do skinning itself and requires
	// the data that is sent to it to be preskinned.
	virtual bool			NeedsSoftwareSkinning( void ) = 0;

	// Apply constant color or alpha modulation
	virtual void			AlphaModulate( float alpha ) = 0;
	virtual void			ColorModulate( float r, float g, float b ) = 0;

	// g_pMaterial Var flags...
	virtual void			SetMaterialVarFlag( MaterialVarFlags_t flag, bool on ) = 0;
	virtual bool			GetMaterialVarFlag( MaterialVarFlags_t flag ) = 0;

	// Gets material reflectivity
	virtual void			GetReflectivity( Vector& reflect ) = 0;

	// Gets material property flags
	virtual bool			GetPropertyFlag( MaterialPropertyTypes_t type ) = 0;

	// Is the material visible from both sides?
	virtual bool			IsTwoSided() = 0;

	// Sets the shader associated with the material
	virtual void			SetShader( const char *pShaderName ) = 0;

	// Can't be const because the material might have to precache itself.
	virtual int				GetNumPasses( void ) = 0;

	// Can't be const because the material might have to precache itself.
	virtual int				GetTextureMemoryBytes( void ) = 0;

	// Meant to be used with materials created using CreateMaterial
	// It updates the materials to reflect the current values stored in the material vars
	virtual void			Refresh() = 0;

	// GR - returns true is material uses lightmap alpha for blending
	virtual bool			NeedsLightmapBlendAlpha( void ) = 0;

	// returns true if the shader doesn't do lighting itself and requires
	// the data that is sent to it to be prelighted
	virtual bool			NeedsSoftwareLighting( void ) = 0;

	// Gets at the shader parameters
	virtual int				ShaderParamCount() const = 0;
	virtual IMaterialVar	**GetShaderParams( void ) = 0;

	// Returns true if this is the error material you get back from IMaterialSysteMath->FindMaterial if
	// the material can't be found.
	virtual bool			IsErrorMaterial() const = 0;

	virtual void			Unused() = 0;

	// Gets the current alpha modulation
	virtual float			GetAlphaModulation() = 0;
	virtual void			GetColorModulation( float *r, float *g, float *b ) = 0;

	// Is this translucent given a particular alpha modulation?
	virtual bool			IsTranslucentUnderModulation( float fAlphaModulation = 1.0f ) const = 0;

	// fast find that stores the index of the found var in the string table in local cache
	virtual IMaterialVar *	FindVarFast( char const *pVarName, unsigned int *pToken ) = 0;

	// Sets new VMT shader parameters for the material
	virtual void			SetShaderAndParams( void *pKeyValues ) = 0;
	virtual const char *	GetShaderName() const = 0;

	virtual void			DeleteIfUnreferenced() = 0;

	virtual bool			IsSpriteCard() = 0;

	virtual void			CallBindProxy( void *proxyData ) = 0;

	virtual void			RefreshPreservingMaterialVars() = 0;

	virtual bool			WasReloadedFromWhitelist() = 0;

	virtual bool			SetTempExcluded( bool bSet, int nExcludedDimensionLimit ) = 0;

	virtual int				GetReferenceCount() const = 0;
};

inline bool IsErrorMaterial( IMaterial *pMat )
{
	return !pMat || pMat->IsErrorMaterial();
}

//
// Vertex stream specifications
//

struct VertexStreamSpec_t
{
	enum StreamSpec_t
	{
		STREAM_DEFAULT,		// stream 0: with position, normal, etc.
		STREAM_SPECULAR1,	// stream 1: following specular vhv lighting
		STREAM_FLEXDELTA,	// stream 2: flex deltas
		STREAM_MORPH,		// stream 3: morph
		STREAM_UNIQUE_A,	// unique stream 4
		STREAM_UNIQUE_B,	// unique stream 5
		STREAM_UNIQUE_C,	// unique stream 6
		STREAM_UNIQUE_D,	// unique stream 7
		STREAM_SUBDQUADS,	// stream 8: quad buffer for subd's
	};

	enum
	{
		MAX_UNIQUE_STREAMS = 4
	};

	VertexFormatFlags_t iVertexDataElement;
	StreamSpec_t iStreamSpec;
};

inline VertexStreamSpec_t * FindVertexStreamSpec( VertexFormat_t iElement, VertexStreamSpec_t *arrVertexStreamSpec )
{
	for ( ; arrVertexStreamSpec &&
		  arrVertexStreamSpec->iVertexDataElement != VERTEX_FORMAT_UNKNOWN;
		  ++arrVertexStreamSpec )
	{
		if ( arrVertexStreamSpec->iVertexDataElement == iElement )
			return arrVertexStreamSpec;
	}
	return NULL;
}

```

`Lumina/Lumina/sdk/structs/IMaterialVar.h`:

```h
#pragma once

class IMaterialVar
{
public:
	void* getTexture() {
		using original_fn = void* (__thiscall*)(IMaterialVar*);
		return (*(original_fn**)this)[1](this);
	}

	void setFloat(float val) {
		using original_fn = void(__thiscall*)(IMaterialVar*, float);
		return (*(original_fn**)this)[4](this, val);
	}

	void setInt(int val) {
		using original_fn = void(__thiscall*)(IMaterialVar*, int);
		return (*(original_fn**)this)[5](this, val);
	}

	void setString(char const* val) {
		using original_fn = void(__thiscall*)(IMaterialVar*, char const*);
		return (*(original_fn**)this)[6](this, val);
	}

	void setColor(float r, float g, float b) {
		using original_fn = void(__thiscall*)(IMaterialVar*, float, float, float);
		return (*(original_fn**)this)[11](this, r, g, b);
	}

	void setTexture(void* val) {
		using original_fn = void(__thiscall*)(IMaterialVar*, void*);
		return (*(original_fn**)this)[15](this, val);
	}
};

```

`Lumina/Lumina/sdk/structs/INetChannelInfo.h`:

```h
#pragma once

#define FLOW_OUTGOING	0		
#define FLOW_INCOMING	1
#define MAX_FLOWS		2		// in & out

class INetChannelInfo
{
public:

	enum
	{
		GENERIC = 0,	// must be first and is default group
		LOCALPLAYER,	// bytes for local player entity update
		OTHERPLAYERS,	// bytes for other players update
		ENTITIES,		// all other entity bytes
		SOUNDS,			// game sounds
		EVENTS,			// event messages
		USERMESSAGES,	// user messages
		ENTMESSAGES,	// entity messages
		VOICE,			// voice data
		STRINGTABLE,	// a stringtable update
		MOVE,			// client move cmds
		STRINGCMD,		// string command
		SIGNON,			// various signondata
		TOTAL,			// must be last and is not a real group
	};

	virtual const char  *GetName( void ) const = 0;	// get channel name
	virtual const char  *GetAddress( void ) const = 0; // get channel IP address as string
	virtual float		GetTime( void ) const = 0;	// current net time
	virtual float		GetTimeConnected( void ) const = 0;	// get connection time in seconds
	virtual int			GetBufferSize( void ) const = 0;	// netchannel packet history size
	virtual int			GetDataRate( void ) const = 0; // send data rate in byte/sec

	virtual bool		IsLoopback( void ) const = 0;	// true if loopback channel
	virtual bool		IsTimingOut( void ) const = 0;	// true if timing out
	virtual bool		IsPlayback( void ) const = 0;	// true if demo playback

	virtual float		GetLatency( int flow ) const = 0;	 // current latency (RTT), more accurate but jittering
	virtual float		GetAvgLatency( int flow ) const = 0; // average packet latency in seconds
	virtual float		GetAvgLoss( int flow ) const = 0;	 // avg packet loss[0..1]
	virtual float		GetAvgChoke( int flow ) const = 0;	 // avg packet choke[0..1]
	virtual float		GetAvgData( int flow ) const = 0;	 // data flow in bytes/sec
	virtual float		GetAvgPackets( int flow ) const = 0; // avg packets/sec
	virtual int			GetTotalData( int flow ) const = 0;	 // total flow in/out in bytes
	virtual int			GetSequenceNr( int flow ) const = 0;	// last send seq number
	virtual bool		IsValidPacket( int flow, int frame_number ) const = 0; // true if packet was not lost/dropped/chocked/flushed
	virtual float		GetPacketTime( int flow, int frame_number ) const = 0; // time when packet was send
	virtual int			GetPacketBytes( int flow, int frame_number, int group ) const = 0; // group size of this packet
	virtual bool		GetStreamProgress( int flow, int *received, int *total ) const = 0;  // TCP progress if transmitting
	virtual float		GetTimeSinceLastReceived( void ) const = 0;	// get time since last recieved packet in seconds
	virtual	float		GetCommandInterpolationAmount( int flow, int frame_number ) const = 0;
	virtual void		GetPacketResponseLatency( int flow, int frame_number, int *pnLatencyMsecs, int *pnChoke ) const = 0;
	virtual void		GetRemoteFramerate( float *pflFrameTime, float *pflFrameTimeStdDeviation ) const = 0;

	virtual float		GetTimeoutSeconds() const = 0;
};
```

`Lumina/Lumina/sdk/structs/IRefCounted.h`:

```h
#pragma once

class IRefCounted
{
private:
	volatile long refCount;

public:
	virtual void destructor( char bDelete ) = 0;
	virtual bool OnFinalRelease() = 0;

	void unreference()
	{
		if ( InterlockedDecrement( &refCount ) == 0 && OnFinalRelease() )
			destructor( 1 );
	}
};

```

`Lumina/Lumina/sdk/structs/datamap.h`:

```h
#pragma once

struct inputdata_t;
typedef enum _fieldtypes
{
	FIELD_VOID = 0,			// No type or value
	FIELD_FLOAT,			// Any floating point value
	FIELD_STRING,			// A string ID (return from ALLOC_STRING)
	FIELD_VECTOR,			// Any vector, QAngle, or AngularImpulse
	FIELD_QUATERNION,		// A quaternion
	FIELD_INTEGER,			// Any integer or enum
	FIELD_BOOLEAN,			// boolean, implemented as an int, I may use this as a hint for compression
	FIELD_SHORT,			// 2 byte integer
	FIELD_CHARACTER,		// a byte
	FIELD_COLOR32,			// 8-bit per channel r,g,b,a (32bit color)
	FIELD_EMBEDDED,			// an embedded object with a datadesc, recursively traverse and embedded class/structure based on an additional typedescription
	FIELD_CUSTOM,			// special type that contains function pointers to it's read/write/parse functions

	FIELD_CLASSPTR,			// CBaseEntity *
	FIELD_EHANDLE,			// Entity handle
	FIELD_EDICT,			// edict_t *

	FIELD_POSITION_VECTOR,	// A world coordinate (these are fixed up across level transitions automagically)
	FIELD_TIME,				// a floating point time (these are fixed up automatically too!)
	FIELD_TICK,				// an integer tick count( fixed up similarly to time)
	FIELD_MODELNAME,		// Engine string that is a model name (needs precache)
	FIELD_SOUNDNAME,		// Engine string that is a sound name (needs precache)

	FIELD_INPUT,			// a list of inputed data fields (all derived from CMultiInputVar)
	FIELD_FUNCTION,			// A class function pointer (Think, Use, etc)

	FIELD_VMATRIX,			// a vmatrix (output coords are NOT worldspace)

							// NOTE: Use float arrays for local transformations that don't need to be fixed up.
							FIELD_VMATRIX_WORLDSPACE,// A VMatrix that maps some local space to world space (translation is fixed up on level transitions)
							FIELD_MATRIX3X4_WORLDSPACE,	// matrix3x4_t that maps some local space to world space (translation is fixed up on level transitions)

							FIELD_INTERVAL,			// a start and range floating point interval ( e.g., 3.2->3.6 == 3.2 and 0.4 )
							FIELD_MODELINDEX,		// a model index
							FIELD_MATERIALINDEX,	// a material index (using the material precache string table)

							FIELD_VECTOR2D,			// 2 floats

							FIELD_TYPECOUNT,		// MUST BE LAST
} fieldtype_t;

class ISaveRestoreOps;
class C_BaseEntity;
//
// Function prototype for all input handlers.
//
typedef void ( C_BaseEntity::*inputfunc_t )( inputdata_t &data );

struct datamap_t;
class typedescription_t;

enum
{
	TD_OFFSET_NORMAL = 0,
	TD_OFFSET_PACKED = 1,

	// Must be last
	TD_OFFSET_COUNT,
};

class typedescription_t
{
public:
	int32_t fieldType; //0x0000
	char* fieldName; //0x0004
	int fieldOffset[ TD_OFFSET_COUNT ]; //0x0008
	int16_t fieldSize_UNKNWN; //0x0010
	int16_t flags_UNKWN; //0x0012
	char pad_0014[ 12 ]; //0x0014
	datamap_t* td; //0x0020
	char pad_0024[ 24 ]; //0x0024
}; //Size: 0x003C


   //-----------------------------------------------------------------------------
   // Purpose: stores the list of objects in the hierarchy
   //            used to iterate through an object's data descriptions
   //-----------------------------------------------------------------------------
struct datamap_t
{
	typedescription_t    *dataDesc;
	int                    dataNumFields;
	char const            *dataClassName;
	datamap_t            *baseMap;

	bool                chains_validated;
	// Have the "packed" offsets been computed
	bool                packed_offsets_computed;
	int                    packed_size;
};

__declspec( noinline ) static unsigned int find_in_data_map( datamap_t *map, const char *name )
{
	while ( map )
	{
		for ( auto i = 0; i < map->dataNumFields; i++ )
		{
			if ( map->dataDesc[ i ].fieldName == nullptr )
				continue;

			if ( strcmp( name, map->dataDesc[ i ].fieldName ) == 0 )
				return map->dataDesc[ i ].fieldOffset[ TD_OFFSET_NORMAL ];

			if ( map->dataDesc[ i ].fieldType == FIELD_EMBEDDED )
			{
				if ( map->dataDesc[ i ].td )
				{
					unsigned int offset;

					if ( ( offset = find_in_data_map( map->dataDesc[ i ].td, name ) ) != 0 )
						return offset;
				}
			}
		}
		map = map->baseMap;
	}
	return 0;
}

//===============================================
#define DATAMAPVAR(funcname, type, datamapname) type& funcname() \
{ \
	static uint16_t offset = 0; \
	if(!offset) { offset = find_in_data_map(this->get_pred_desc_map(), XorStr(datamapname) ); \
	Assert(offset); } \
    return *reinterpret_cast< type* >( uintptr_t( this ) + offset ); \
}
//===============================================
#define DATAMAPVARA(funcname, type, datamapname, add) type& funcname() \
{ \
	static uint16_t offset = 0; \
	if(!offset) { offset = find_in_data_map(this->get_pred_desc_map(),  XorStr(datamapname)); \
	Assert(offset); } \
    return *reinterpret_cast< type* >( uintptr_t( this ) + offset + add ); \
}
```

`Lumina/Lumina/sdk/structs/misc.h`:

```h
#pragma once

#ifndef misc_h

#define misc_h

#include <string>

#include "../math/matrix3x4_t.h"
#include "../math/CUtlVector.h"

class NoticeText_t
{
public:
	wchar_t m_nString[ 512 ]; //0x0000 
	char pad_0x0400[ 0xC ]; //0x0400
	float set; //0x040C
	float m_flStartTime; //0x0410 
	float m_flStartTime2; //0x0414 
	float m_flLifeTimeModifier; //0x0418 
	char pad_0x041C[ 0x4 ]; //0x041C
}; //Size=0x420

class SFHudDeathNoticeAndBotStatus
{
public:
	char pad_0x00[ 0x68 ];
	CUtlVector<NoticeText_t>m_nDeathNotices;
};

extern SFHudDeathNoticeAndBotStatus* g_pDeathNotice;

class CUserCmd
{
public:
	virtual ~CUserCmd() {};
	int		command_number;
	int		tick_count;
	Vector	viewangles;
	Vector	aimdirection;
	float	forwardmove;
	float	sidemove;
	float	upmove;
	int		buttons;
	byte    impulse;
	int		weaponselect;
	int		weaponsubtype;
	int		random_seed;
	short	mousedx;
	short	mousedy;
	bool	hasbeenpredicted;
	char	pad_0x4C[ 0x18 ];
};

class CViewSetup
{
public:
	int			x, x_old;
	int			y, y_old;
	int			width, width_old;
	int			height, height_old;
	bool		m_bOrtho;
	float		m_OrthoLeft;
	float		m_OrthoTop;
	float		m_OrthoRight;
	float		m_OrthoBottom;
	bool		m_bCustomViewMatrix;
	matrix3x4_t	m_matCustomViewMatrix;
	char		pad_0x68[ 0x48 ];
	float		fov;
	float		fovViewmodel;
	Vector		origin;
	QAngle		angles;
	float		zNear;
	float		zFar;
	float		zNearViewmodel;
	float		zFarViewmodel;
	float		m_flAspectRatio;
	float		m_flNearBlurDepth;
	float		m_flNearFocusDepth;
	float		m_flFarFocusDepth;
	float		m_flFarBlurDepth;
	float		m_flNearBlurRadius;
	float		m_flFarBlurRadius;
	int			m_nDoFQuality;
	int			m_nMotionBlurMode;
	float		m_flShutterTime;
	Vector		m_vShutterOpenPosition;
	QAngle		m_shutterOpenAngles;
	Vector		m_vShutterClosePosition;
	QAngle		m_shutterCloseAngles;
	float		m_flOffCenterTop;
	float		m_flOffCenterBottom;
	float		m_flOffCenterLeft;
	float		m_flOffCenterRight;
	int			m_EdgeBlur;
};

class VarMapEntry_t
{
public:
	unsigned short type;
	unsigned short m_bNeedsToInterpolate;	// Set to false when this var doesn't
											// need Interpolate() called on it anymore.
	void *data;
	void *watcher;
};

class Quaternion				// same data-layout as engine's vec4_t,
{								//		which is a float[4]
public:
	inline Quaternion( void ) {}
	inline Quaternion( float ix, float iy, float iz, float iw ) : x( ix ), y( iy ), z( iz ), w( iw ) {}

	inline void Init( float ix = 0.0f, float iy = 0.0f, float iz = 0.0f, float iw = 0.0f ) { x = ix; y = iy; z = iz; w = iw; }

	float* Base() { return ( float* )this; }
	const float* Base() const { return ( float* )this; }

	float x, y, z, w;
};

class ALIGN16 QuaternionAligned : public Quaternion
{
public:
	inline QuaternionAligned( void ) {};
	inline QuaternionAligned( float X, float Y, float Z, float W )
	{
		Init( X, Y, Z, W );
	}
public:
	explicit QuaternionAligned( const Quaternion &vOther )
	{
		Init( vOther.x, vOther.y, vOther.z, vOther.w );
	}

	QuaternionAligned& operator=( const Quaternion &vOther )
	{
		Init( vOther.x, vOther.y, vOther.z, vOther.w );
		return *this;
	}
};

class C_AnimationLayer
{
public:
	char  pad_0000[ 20 ];
	uint32_t m_nOrder; //0x0014
	uint32_t m_nSequence; //0x0018
	float_t m_flPrevCycle; //0x001C
	float_t m_flWeight; //0x0020
	float_t m_flWeightDeltaRate; //0x0024
	float_t m_flPlaybackRate; //0x0028
	float_t m_flCycle; //0x002C
	void *m_pOwner; //0x0030 // player's thisptr
	char  pad_0038[ 4 ]; //0x0034
};

class ClientClass;
class CEventInfo
{
public:
	uint16_t classID; //0x0000 0 implies not in use
	char pad_0002[ 2 ]; //0x0002 
	float fire_delay; //0x0004 If non-zero, the delay time when the event should be fired ( fixed up on the client )
	char pad_0008[ 4 ]; //0x0008
	ClientClass *pClientClass; //0x000C
	void *pData; //0x0010 Raw event data
	char pad_0014[ 48 ]; //0x0014
}; //Size: 0x0044

class C_TEFireBullets
{
public:
	char pad[ 12 ];
	int		m_iPlayer; //12
	int _m_iItemDefinitionIndex;
	Vector	_m_vecOrigin;
	QAngle	m_vecAngles;
	int		_m_iWeaponID;
	int		m_iMode;
	int		m_iSeed;
	float	m_flSpread;
};

struct Item_t
{
	Item_t( std::string model, std::string icon = "" ) :
		model( model ),
		icon( icon )
	{
	}

	std::string model;
	std::string icon;
};

struct WeaponName_t
{
	WeaponName_t( int definition_index, std::string name ) :
		definition_index( definition_index ),
		name( name )
	{
	}

	int definition_index = 0;
	std::string name = nullptr;
};

struct QualityName_t
{
	QualityName_t( int index, std::string name ) :
		index( index ),
		name( name )
	{
	}

	int index = 0;
	std::string name;
};

#endif
```

`Lumina/Lumina/sdk/structs/mystructs.h`:

```h
#ifndef mystruct_h

#define mystruct_h

#include "Entity.h"

struct box {

	int x, y, w, h;

	box() = default;

	box(int x, int y, int w, int h) {
		this->x = x;
		this->y = y;
		this->w = w;
		this->h = h;
	}
};

struct boxPoint {

	int x1, y1, x2, y2;

	boxPoint() = default;

	boxPoint(int x1, int y1, int x2, int y2) {
		this->x1 = x1;
		this->y1 = y1;
		this->x2 = x2;
		this->y2 = y2;
	}
};

struct player_t {

	Entity* handle;
	bool dormant;
	bool enemie;
	bool alive;
	player_info_t* info;
	CCSWeaponData* weaponData;

	player_t() = default;

};

#endif // !mystruct_h
```

`Lumina/Lumina/sdk/structs/structs.h`:

```h
#pragma once

#include <string>

#include "trace_ray.h"
#include "../math/Vector2D.h"

#define MAX_JOYSTICK_AXES 0
#define MAX_JOYSTICKS 0

struct paint_kit {
	int id;
	std::string name;
};

class CCStrike15ItemSchema;
class CCStrike15ItemSystem;
template <typename Key, typename Value>

struct node_t {
	int previous_id;
	int next_id;
	void* _unknown_ptr;
	int _unknown;
	Key key;
	Value value;
};
template <typename key, typename value>
struct head_t {
	node_t<key, value>* memory;
	int allocation_count;
	int grow_size;
	int start_element;
	int next_available;
	int _unknown;
	int last_element;
};

struct string_t {
	char* buffer;
	int capacity;
	int grow_size;
	int length;
};

enum class EStickerAttributeType
{
	Index,
	Wear,
	Scale,
	Rotation
};

struct paint_kit_t {
	int id;
	string_t name;
	string_t description;
	string_t item_name;
	string_t material_name;
	string_t image_inventory;
	char pad_0x0054[0x8C];
};

enum TeamID {
	TEAM_UNASSIGNED = 0,
	TEAM_SPECTATOR = 1,
	TEAM_TERRORIST = 2,
	TEAM_COUNTER_TERRORIST = 3,
};


enum
{
	JOYSTICK_MAX_BUTTON_COUNT = 32,
	JOYSTICK_POV_BUTTON_COUNT = 4,
	JOYSTICK_AXIS_BUTTON_COUNT = MAX_JOYSTICK_AXES * 2,
};

/*
#define JOYSTICK_BUTTON_INTERNAL( _joystick, _button ) ( JOYSTICK_FIRST_BUTTON + ((_joystick) * JOYSTICK_MAX_BUTTON_COUNT) + (_button) )
#define JOYSTICK_POV_BUTTON_INTERNAL( _joystick, _button ) ( JOYSTICK_FIRST_POV_BUTTON + ((_joystick) * JOYSTICK_POV_BUTTON_COUNT) + (_button) )
#define JOYSTICK_AXIS_BUTTON_INTERNAL( _joystick, _button ) ( JOYSTICK_FIRST_AXIS_BUTTON + ((_joystick) * JOYSTICK_AXIS_BUTTON_COUNT) + (_button) )

#define JOYSTICK_BUTTON( _joystick, _button ) ( (ButtonCode_t)JOYSTICK_BUTTON_INTERNAL( _joystick, _button ) )
#define JOYSTICK_POV_BUTTON( _joystick, _button ) ( (ButtonCode_t)JOYSTICK_POV_BUTTON_INTERNAL( _joystick, _button ) )
#define JOYSTICK_AXIS_BUTTON( _joystick, _button ) ( (ButtonCode_t)JOYSTICK_AXIS_BUTTON_INTERNAL( _joystick, _button ) )

enum ButtonCode_t
{
	BUTTON_CODE_INVALID = -1,
	BUTTON_CODE_NONE = 0,

	KEY_FIRST = 0,

	KEY_NONE = KEY_FIRST,
	KEY_0,
	KEY_1,
	KEY_2,
	KEY_3,
	KEY_4,
	KEY_5,
	KEY_6,
	KEY_7,
	KEY_8,
	KEY_9,
	KEY_A,
	KEY_B,
	KEY_C,
	KEY_D,
	KEY_E,
	KEY_F,
	KEY_G,
	KEY_H,
	KEY_I,
	KEY_J,
	KEY_K,
	KEY_L,
	KEY_M,
	KEY_N,
	KEY_O,
	KEY_P,
	KEY_Q,
	KEY_R,
	KEY_S,
	KEY_T,
	KEY_U,
	KEY_V,
	KEY_W,
	KEY_X,
	KEY_Y,
	KEY_Z,
	KEY_PAD_0,
	KEY_PAD_1,
	KEY_PAD_2,
	KEY_PAD_3,
	KEY_PAD_4,
	KEY_PAD_5,
	KEY_PAD_6,
	KEY_PAD_7,
	KEY_PAD_8,
	KEY_PAD_9,
	KEY_PAD_DIVIDE,
	KEY_PAD_MULTIPLY,
	KEY_PAD_MINUS,
	KEY_PAD_PLUS,
	KEY_PAD_ENTER,
	KEY_PAD_DECIMAL,
	KEY_LBRACKET,
	KEY_RBRACKET,
	KEY_SEMICOLON,
	KEY_APOSTROPHE,
	KEY_BACKQUOTE,
	KEY_COMMA,
	KEY_PERIOD,
	KEY_SLASH,
	KEY_BACKSLASH,
	KEY_MINUS,
	KEY_EQUAL,
	KEY_ENTER,
	KEY_SPACE,
	KEY_BACKSPACE,
	KEY_TAB,
	KEY_CAPSLOCK,
	KEY_NUMLOCK,
	KEY_ESCAPE,
	KEY_SCROLLLOCK,
	KEY_INSERT,
	KEY_DELETE,
	KEY_HOME,
	KEY_END,
	KEY_PAGEUP,
	KEY_PAGEDOWN,
	KEY_BREAK,
	KEY_LSHIFT,
	KEY_RSHIFT,
	KEY_LALT,
	KEY_RALT,
	KEY_LCONTROL,
	KEY_RCONTROL,
	KEY_LWIN,
	KEY_RWIN,
	KEY_APP,
	KEY_UP,
	KEY_LEFT,
	KEY_DOWN,
	KEY_RIGHT,
	KEY_F1,
	KEY_F2,
	KEY_F3,
	KEY_F4,
	KEY_F5,
	KEY_F6,
	KEY_F7,
	KEY_F8,
	KEY_F9,
	KEY_F10,
	KEY_F11,
	KEY_F12,
	KEY_CAPSLOCKTOGGLE,
	KEY_NUMLOCKTOGGLE,
	KEY_SCROLLLOCKTOGGLE,

	KEY_LAST = KEY_SCROLLLOCKTOGGLE,
	KEY_COUNT = KEY_LAST - KEY_FIRST + 1,

	// Mouse
	MOUSE_FIRST = KEY_LAST + 1,

	MOUSE_LEFT = MOUSE_FIRST,
	MOUSE_RIGHT,
	MOUSE_MIDDLE,
	MOUSE_4,
	MOUSE_5,
	MOUSE_WHEEL_UP,		// A fake button which is 'pressed' and 'released' when the wheel is moved up 
	MOUSE_WHEEL_DOWN,	// A fake button which is 'pressed' and 'released' when the wheel is moved down

	MOUSE_LAST = MOUSE_WHEEL_DOWN,
	MOUSE_COUNT = MOUSE_LAST - MOUSE_FIRST + 1,

	// Joystick
	JOYSTICK_FIRST = MOUSE_LAST + 1,

	JOYSTICK_FIRST_BUTTON = JOYSTICK_FIRST,
	JOYSTICK_LAST_BUTTON = JOYSTICK_BUTTON_INTERNAL(MAX_JOYSTICKS - 1, JOYSTICK_MAX_BUTTON_COUNT - 1),
	JOYSTICK_FIRST_POV_BUTTON,
	JOYSTICK_LAST_POV_BUTTON = JOYSTICK_POV_BUTTON_INTERNAL(MAX_JOYSTICKS - 1, JOYSTICK_POV_BUTTON_COUNT - 1),
	JOYSTICK_FIRST_AXIS_BUTTON,
	JOYSTICK_LAST_AXIS_BUTTON = JOYSTICK_AXIS_BUTTON_INTERNAL(MAX_JOYSTICKS - 1, JOYSTICK_AXIS_BUTTON_COUNT - 1),

	JOYSTICK_LAST = JOYSTICK_LAST_AXIS_BUTTON,

	BUTTON_CODE_LAST,
	BUTTON_CODE_COUNT = BUTTON_CODE_LAST - KEY_FIRST + 1,

	// Helpers for XBox 360
	KEY_XBUTTON_UP = JOYSTICK_FIRST_POV_BUTTON,	// POV buttons
	KEY_XBUTTON_RIGHT,
	KEY_XBUTTON_DOWN,
	KEY_XBUTTON_LEFT,

	KEY_XBUTTON_A = JOYSTICK_FIRST_BUTTON,		// Buttons
	KEY_XBUTTON_B,
	KEY_XBUTTON_X,
	KEY_XBUTTON_Y,
	KEY_XBUTTON_LEFT_SHOULDER,
	KEY_XBUTTON_RIGHT_SHOULDER,
	KEY_XBUTTON_BACK,
	KEY_XBUTTON_START,
	KEY_XBUTTON_STICK1,
	KEY_XBUTTON_STICK2,
	KEY_XBUTTON_INACTIVE_START,

	KEY_XSTICK1_RIGHT = JOYSTICK_FIRST_AXIS_BUTTON,	// XAXIS POSITIVE
	KEY_XSTICK1_LEFT,							// XAXIS NEGATIVE
	KEY_XSTICK1_DOWN,							// YAXIS POSITIVE
	KEY_XSTICK1_UP,								// YAXIS NEGATIVE
	KEY_XBUTTON_LTRIGGER,						// ZAXIS POSITIVE
	KEY_XBUTTON_RTRIGGER,						// ZAXIS NEGATIVE
	KEY_XSTICK2_RIGHT,							// UAXIS POSITIVE
	KEY_XSTICK2_LEFT,							// UAXIS NEGATIVE
	KEY_XSTICK2_DOWN,							// VAXIS POSITIVE
	KEY_XSTICK2_UP,								// VAXIS NEGATIVE
};
*/

typedef struct player_info_s
{
	int64_t __pad0;
	union
	{
		int64_t xuid;
		struct
		{
			int xuidlow;
			int xuidhigh;
		};
	};
	char name[ 128 ];
	int userid;
	char guid[ 33 ];
	unsigned int friendsid;
	char friendsname[ 128 ];
	bool fakeplayer;
	bool ishltv;
	unsigned int customfiles[ 4 ];
	unsigned char filesdownloaded;
} player_info_t;

enum ClientFrameStage_t
{
	FRAME_UNDEFINED = -1,
	FRAME_START,
	FRAME_NET_UPDATE_START,
	FRAME_NET_UPDATE_POSTDATAUPDATE_START,
	FRAME_NET_UPDATE_POSTDATAUPDATE_END,
	FRAME_NET_UPDATE_END,
	FRAME_RENDER_START,
	FRAME_RENDER_END
};

enum MoveType_t
{
	MOVETYPE_NONE = 0,
	MOVETYPE_ISOMETRIC,
	MOVETYPE_WALK,
	MOVETYPE_STEP,
	MOVETYPE_FLY,
	MOVETYPE_FLYGRAVITY,
	MOVETYPE_VPHYSICS,
	MOVETYPE_PUSH,
	MOVETYPE_NOCLIP,
	MOVETYPE_LADDER,
	MOVETYPE_OBSERVER,
	MOVETYPE_CUSTOM,
	MOVETYPE_LAST = MOVETYPE_CUSTOM,
	MOVETYPE_MAX_BITS = 4
};

enum class LifeState
{
	ALIVE = 0,
	DYING,
	DEAD,
	RESPAWNABLE,
	DISCARDBODY,
};

struct mstudiobbox_t
{
	int		bone;
	int		group; // intersection group
	Vector	bbmin; // bounding box 
	Vector	bbmax;
	int		hitboxnameindex; // offset to the name of the hitbox.
	int		pad[ 3 ];
	float	radius;
	int		pad2[ 4 ];

	const char* getHitboxName()
	{
		if ( hitboxnameindex == 0 )
			return "";

		return ( ( char* )this ) + hitboxnameindex;
	}
};


class i_net_channel {
public:
	char pad_0000[20];
	bool is_processing_messages;
	bool should_delete;
	char pad_0016[2];
	int32_t out_sequence_nr;
	int32_t in_sequence_nr;
	int32_t out_sequence_nr_ack;
	int32_t out_reliable_state_count;
	int32_t in_reliable_state_count;
	int32_t choked_packets;
	char pad_0030[1044];

	bool transmit(bool only_reliable) {
		using fn = bool(__thiscall*)(void*, bool);
		return (*(fn**)this)[49](this, only_reliable);
	}
};

class i_client_state {
public:
	char pad_0000[156];
	uint32_t net_channel;
	uint32_t challenge_count;
	double reconnect_time;
	int32_t retry_count;
	char pad_00A8[88];
	int32_t signon_state_count;
	char pad_0104[8];
	float next_cmd_time;
	int32_t server_count;
	uint32_t current_sequence;
	char pad_0118[8];
	char pad_0120[0x4C];
	int32_t delta_tick;
	bool is_paused;
	char pad_0171[3];
	int32_t view_entity;
	int32_t player_slot;
	char pad_017C[4];
	char level_name[260];
	char level_name_short[40];
	char pad_02AC[92];
	int32_t max_clients;
	char pad_030C[4083];
	uint32_t string_table_container;
	char pad_1303[14737];
	float last_server_tick_time;
	bool is_in_simulation;
	char pad_4C99[3];
	uint32_t old_tick_count;
	float tick_remainder;
	float frame_time;
	int32_t last_outgoing_command;
	int32_t choked_commands;
	int32_t last_command_ack;
	int32_t command_ack;
	int32_t sound_sequence;
	char pad_4CBC[80];
	Vector view_angles;
};

enum ItemDefinitionIndex : int
{
	WEAPON_DEAGLE = 1,
	WEAPON_ELITE = 2,
	WEAPON_FIVESEVEN = 3,
	WEAPON_GLOCK = 4,
	WEAPON_AK47 = 7,
	WEAPON_AUG = 8,
	WEAPON_AWP = 9,
	WEAPON_FAMAS = 10,
	WEAPON_G3SG1 = 11,
	WEAPON_GALILAR = 13,
	WEAPON_M249 = 14,
	WEAPON_M4A1 = 16,
	WEAPON_MAC10 = 17,
	WEAPON_P90 = 19,
	WEAPON_MP5SD = 23,
	WEAPON_UMP45 = 24,
	WEAPON_XM1014 = 25,
	WEAPON_BIZON = 26,
	WEAPON_MAG7 = 27,
	WEAPON_NEGEV = 28,
	WEAPON_SAWEDOFF = 29,
	WEAPON_TEC9 = 30,
	WEAPON_TASER = 31,
	WEAPON_HKP2000 = 32,
	WEAPON_MP7 = 33,
	WEAPON_MP9 = 34,
	WEAPON_NOVA = 35,
	WEAPON_P250 = 36,
	WEAPON_SHIELD = 37,
	WEAPON_SCAR20 = 38,
	WEAPON_SG556 = 39,
	WEAPON_SSG08 = 40,
	WEAPON_KNIFEGG = 41,
	WEAPON_KNIFE = 42,
	WEAPON_FLASHBANG = 43,
	WEAPON_HEGRENADE = 44,
	WEAPON_SMOKEGRENADE = 45,
	WEAPON_MOLOTOV = 46,
	WEAPON_DECOY = 47,
	WEAPON_INCGRENADE = 48,
	WEAPON_C4 = 49,
	WEAPON_HEALTHSHOT = 57,
	WEAPON_KNIFE_T = 59,
	WEAPON_M4A1_SILENCER = 60,
	WEAPON_USP_SILENCER = 61,
	WEAPON_CZ75A = 63,
	WEAPON_REVOLVER = 64,
	WEAPON_TAGRENADE = 68,
	WEAPON_FISTS = 69,
	WEAPON_BREACHCHARGE = 70,
	WEAPON_TABLET = 72,
	WEAPON_MELEE = 74,
	WEAPON_AXE = 75,
	WEAPON_HAMMER = 76,
	WEAPON_SPANNER = 78,
	WEAPON_KNIFE_GHOST = 80,
	WEAPON_FIREBOMB = 81,
	WEAPON_DIVERSION = 82,
	WEAPON_FRAG_GRENADE = 83,
	WEAPON_SNOWBALL = 84,
	WEAPON_BUMPMINE = 85,
	WEAPON_BAYONET = 500,
	WEAPON_KNIFE_CSS = 503,
	WEAPON_KNIFE_FLIP = 505,
	WEAPON_KNIFE_GUT = 506,
	WEAPON_KNIFE_KARAMBIT = 507,
	WEAPON_KNIFE_M9_BAYONET = 508,
	WEAPON_KNIFE_TACTICAL = 509,
	WEAPON_KNIFE_FALCHION = 512,
	WEAPON_KNIFE_SURVIVAL_BOWIE = 514,
	WEAPON_KNIFE_BUTTERFLY = 515,
	WEAPON_KNIFE_PUSH = 516,
	WEAPON_KNIFE_CORD = 517,
	WEAPON_KNIFE_CANIS = 518,
	WEAPON_KNIFE_URSUS = 519,
	WEAPON_KNIFE_GYPSY_JACKKNIFE = 520,
	WEAPON_KNIFE_OUTDOOR = 521,
	WEAPON_KNIFE_STILETTO = 522,
	WEAPON_KNIFE_WIDOWMAKER = 523,
	WEAPON_KNIFE_SKELETON = 525,
	GLOVE_STUDDED_BLOODHOUND = 5027,
	GLOVE_T_SIDE = 5028,
	GLOVE_CT_SIDE = 5029,
	GLOVE_SPORTY = 5030,
	GLOVE_SLICK = 5031,
	GLOVE_LEATHER_WRAP = 5032,
	GLOVE_MOTORCYCLE = 5033,
	GLOVE_SPECIALIST = 5034,
	GLOVE_HYDRA = 5035
};


enum CSWeaponType : int
{
	WEAPONTYPE_KNIFE = 1,
	WEAPONTYPE_PISTOL,
	WEAPONTYPE_SUBMACHINEGUN,
	WEAPONTYPE_RIFLE,
	WEAPONTYPE_SHOTGUN,
	WEAPONTYPE_SNIPER_RIFLE,
	WEAPONTYPE_MACHINEGUN,
	WEAPONTYPE_C4,
	WEAPONTYPE_GRENADE,
	WEAPONTYPE_UNKNOWN
};

enum StencilOperation_t
{
	STENCILOPERATION_KEEP = 1,
	STENCILOPERATION_ZERO = 2,
	STENCILOPERATION_REPLACE = 3,
	STENCILOPERATION_INCRSAT = 4,
	STENCILOPERATION_DECRSAT = 5,
	STENCILOPERATION_INVERT = 6,
	STENCILOPERATION_INCR = 7,
	STENCILOPERATION_DECR = 8,
	STENCILOPERATION_FORCE_DWORD = 0x7fffffff
};

enum StencilComparisonFunction_t
{
	STENCILCOMPARISONFUNCTION_NEVER = 1,
	STENCILCOMPARISONFUNCTION_LESS = 2,
	STENCILCOMPARISONFUNCTION_EQUAL = 3,
	STENCILCOMPARISONFUNCTION_LESSEQUAL = 4,
	STENCILCOMPARISONFUNCTION_GREATER = 5,
	STENCILCOMPARISONFUNCTION_NOTEQUAL = 6,
	STENCILCOMPARISONFUNCTION_GREATEREQUAL = 7,
	STENCILCOMPARISONFUNCTION_ALWAYS = 8,
	STENCILCOMPARISONFUNCTION_FORCE_DWORD = 0x7fffffff
};

enum ImageFormat
{
	IMAGE_FORMAT_UNKNOWN = -1,
	IMAGE_FORMAT_RGBA8888 = 0,
	IMAGE_FORMAT_ABGR8888,
	IMAGE_FORMAT_RGB888,
	IMAGE_FORMAT_BGR888,
	IMAGE_FORMAT_RGB565,
	IMAGE_FORMAT_I8,
	IMAGE_FORMAT_IA88,
	IMAGE_FORMAT_P8,
	IMAGE_FORMAT_A8,
	IMAGE_FORMAT_RGB888_BLUESCREEN,
	IMAGE_FORMAT_BGR888_BLUESCREEN,
	IMAGE_FORMAT_ARGB8888,
	IMAGE_FORMAT_BGRA8888,
	IMAGE_FORMAT_DXT1,
	IMAGE_FORMAT_DXT3,
	IMAGE_FORMAT_DXT5,
	IMAGE_FORMAT_BGRX8888,
	IMAGE_FORMAT_BGR565,
	IMAGE_FORMAT_BGRX5551,
	IMAGE_FORMAT_BGRA4444,
	IMAGE_FORMAT_DXT1_ONEBITALPHA,
	IMAGE_FORMAT_BGRA5551,
	IMAGE_FORMAT_UV88,
	IMAGE_FORMAT_UVWQ8888,
	IMAGE_FORMAT_RGBA16161616F,
	IMAGE_FORMAT_RGBA16161616,
	IMAGE_FORMAT_UVLX8888,
	IMAGE_FORMAT_R32F,			// Single-channel 32-bit floating point
	IMAGE_FORMAT_RGB323232F,	// NOTE: D3D9 does not have this format
	IMAGE_FORMAT_RGBA32323232F,
	IMAGE_FORMAT_RG1616F,
	IMAGE_FORMAT_RG3232F,
	IMAGE_FORMAT_RGBX8888,

	IMAGE_FORMAT_NULL,			// Dummy format which takes no video memory
	// Compressed normal map formats
	IMAGE_FORMAT_ATI2N,			// One-surface ATI2N / DXN format
	IMAGE_FORMAT_ATI1N,			// Two-surface ATI1N format

	IMAGE_FORMAT_RGBA1010102,	// 10 bit-per component render targets
	IMAGE_FORMAT_BGRA1010102,
	IMAGE_FORMAT_R16F,			// 16 bit FP format

	// Depth-stencil texture formats
	IMAGE_FORMAT_D16,
	IMAGE_FORMAT_D15S1,
	IMAGE_FORMAT_D32,
	IMAGE_FORMAT_D24S8,
	IMAGE_FORMAT_LINEAR_D24S8,
	IMAGE_FORMAT_D24X8,
	IMAGE_FORMAT_D24X4S4,
	IMAGE_FORMAT_D24FS8,
	IMAGE_FORMAT_D16_SHADOW,	// Specific formats for shadow mapping
	IMAGE_FORMAT_D24X8_SHADOW,	// Specific formats for shadow mapping

	// supporting these specific formats as non-tiled for procedural cpu access (360-specific)
	IMAGE_FORMAT_LINEAR_BGRX8888,
	IMAGE_FORMAT_LINEAR_RGBA8888,
	IMAGE_FORMAT_LINEAR_ABGR8888,
	IMAGE_FORMAT_LINEAR_ARGB8888,
	IMAGE_FORMAT_LINEAR_BGRA8888,
	IMAGE_FORMAT_LINEAR_RGB888,
	IMAGE_FORMAT_LINEAR_BGR888,
	IMAGE_FORMAT_LINEAR_BGRX5551,
	IMAGE_FORMAT_LINEAR_I8,
	IMAGE_FORMAT_LINEAR_RGBA16161616,

	IMAGE_FORMAT_LE_BGRX8888,
	IMAGE_FORMAT_LE_BGRA8888,

	NUM_IMAGE_FORMATS
};

struct colorVec
{
	unsigned r, g, b, a;
};

enum OverrideType_t
{
	OVERRIDE_NORMAL = 0,
	OVERRIDE_BUILD_SHADOWS,
	OVERRIDE_DEPTH_WRITE,
	OVERRIDE_SSAO_DEPTH_WRITE,
};

enum FontDrawType_t
{
	FONT_DRAW_DEFAULT = 0,
	FONT_DRAW_NONADDITIVE,
	FONT_DRAW_ADDITIVE,
	FONT_DRAW_TYPE_COUNT = 2,
};

struct FontVertex_t
{
	Vector2D m_Position;
	Vector2D m_TexCoord;

	FontVertex_t() {}
	FontVertex_t( const Vector2D &pos, const Vector2D &coord = Vector2D( 0, 0 ) )
	{
		m_Position = pos;
		m_TexCoord = coord;
	}
	void Init( const Vector2D &pos, const Vector2D &coord = Vector2D( 0, 0 ) )
	{
		m_Position = pos;
		m_TexCoord = coord;
	}
};

typedef FontVertex_t Vertex_t;

enum CCSGOAnimStatePoses
{
	ACT_RESET,
	ACT_IDLE,
	ACT_TRANSITION,
	ACT_COVER,
	ACT_COVER_MED,
	ACT_COVER_LOW,
	ACT_WALK,
	ACT_WALK_AIM,
	ACT_WALK_CROUCH,
	ACT_WALK_CROUCH_AIM,
	ACT_RUN,
	ACT_RUN_AIM,
	ACT_RUN_CROUCH,
	ACT_RUN_CROUCH_AIM,
	ACT_RUN_PROTECTED,
	ACT_SCRIPT_CUSTOM_MOVE,
	ACT_RANGE_ATTACK1,
	ACT_RANGE_ATTACK2,
	ACT_RANGE_ATTACK1_LOW,
	ACT_RANGE_ATTACK2_LOW,
	ACT_DIESIMPLE,
	ACT_DIEBACKWARD,
	ACT_DIEFORWARD,
	ACT_DIEVIOLENT,
	ACT_DIERAGDOLL,
	ACT_FLY,
	ACT_HOVER,
	ACT_GLIDE,
	ACT_SWIM,
	ACT_JUMP,
	ACT_HOP,
	ACT_LEAP,
	ACT_LAND,
	ACT_CLIMB_UP,
	ACT_CLIMB_DOWN,
	ACT_CLIMB_DISMOUNT,
	ACT_SHIPLADDER_UP,
	ACT_SHIPLADDER_DOWN,
	ACT_STRAFE_LEFT,
	ACT_STRAFE_RIGHT,
	ACT_ROLL_LEFT,
	ACT_ROLL_RIGHT,
	ACT_TURN_LEFT,
	ACT_TURN_RIGHT,
	ACT_CROUCH,
	ACT_CROUCHIDLE,
	ACT_STAND,
	ACT_USE,
	ACT_ALIEN_BURROW_IDLE,
	ACT_ALIEN_BURROW_OUT,
	ACT_SIGNAL1,
	ACT_SIGNAL2,
	ACT_SIGNAL3,
	ACT_SIGNAL_ADVANCE,
	ACT_SIGNAL_FORWARD,
	ACT_SIGNAL_GROUP,
	ACT_SIGNAL_HALT,
	ACT_SIGNAL_LEFT,
	ACT_SIGNAL_RIGHT,
	ACT_SIGNAL_TAKECOVER,
	ACT_LOOKBACK_RIGHT,
	ACT_LOOKBACK_LEFT,
	ACT_COWER,
	ACT_SMALL_FLINCH,
	ACT_BIG_FLINCH,
	ACT_MELEE_ATTACK1,
	ACT_MELEE_ATTACK2,
	ACT_RELOAD,
	ACT_RELOAD_START,
	ACT_RELOAD_FINISH,
	ACT_RELOAD_LOW,
	ACT_ARM,
	ACT_DISARM,
	ACT_DROP_WEAPON,
	ACT_DROP_WEAPON_SHOTGUN,
	ACT_PICKUP_GROUND,
	ACT_PICKUP_RACK,
	ACT_IDLE_ANGRY,
	ACT_IDLE_RELAXED,
	ACT_IDLE_STIMULATED,
	ACT_IDLE_AGITATED,
	ACT_IDLE_STEALTH,
	ACT_IDLE_HURT,
	ACT_WALK_RELAXED,
	ACT_WALK_STIMULATED,
	ACT_WALK_AGITATED,
	ACT_WALK_STEALTH,
	ACT_RUN_RELAXED,
	ACT_RUN_STIMULATED,
	ACT_RUN_AGITATED,
	ACT_RUN_STEALTH,
	ACT_IDLE_AIM_RELAXED,
	ACT_IDLE_AIM_STIMULATED,
	ACT_IDLE_AIM_AGITATED,
	ACT_IDLE_AIM_STEALTH,
	ACT_WALK_AIM_RELAXED,
	ACT_WALK_AIM_STIMULATED,
	ACT_WALK_AIM_AGITATED,
	ACT_WALK_AIM_STEALTH,
	ACT_RUN_AIM_RELAXED,
	ACT_RUN_AIM_STIMULATED,
	ACT_RUN_AIM_AGITATED,
	ACT_RUN_AIM_STEALTH,
	ACT_CROUCHIDLE_STIMULATED,
	ACT_CROUCHIDLE_AIM_STIMULATED,
	ACT_CROUCHIDLE_AGITATED,
	ACT_WALK_HURT,
	ACT_RUN_HURT,
	ACT_SPECIAL_ATTACK1,
	ACT_SPECIAL_ATTACK2,
	ACT_COMBAT_IDLE,
	ACT_WALK_SCARED,
	ACT_RUN_SCARED,
	ACT_VICTORY_DANCE,
	ACT_DIE_HEADSHOT,
	ACT_DIE_CHESTSHOT,
	ACT_DIE_GUTSHOT,
	ACT_DIE_BACKSHOT,
	ACT_FLINCH_HEAD,
	ACT_FLINCH_CHEST,
	ACT_FLINCH_STOMACH,
	ACT_FLINCH_LEFTARM,
	ACT_FLINCH_RIGHTARM,
	ACT_FLINCH_LEFTLEG,
	ACT_FLINCH_RIGHTLEG,
	ACT_FLINCH_PHYSICS,
	ACT_FLINCH_HEAD_BACK,
	ACT_FLINCH_HEAD_LEFT,
	ACT_FLINCH_HEAD_RIGHT,
	ACT_FLINCH_CHEST_BACK,
	ACT_FLINCH_STOMACH_BACK,
	ACT_FLINCH_CROUCH_FRONT,
	ACT_FLINCH_CROUCH_BACK,
	ACT_FLINCH_CROUCH_LEFT,
	ACT_FLINCH_CROUCH_RIGHT,
	ACT_IDLE_ON_FIRE,
	ACT_WALK_ON_FIRE,
	ACT_RUN_ON_FIRE,
	ACT_RAPPEL_LOOP,
	ACT_180_LEFT,
	ACT_180_RIGHT,
	ACT_90_LEFT,
	ACT_90_RIGHT,
	ACT_STEP_LEFT,
	ACT_STEP_RIGHT,
	ACT_STEP_BACK,
	ACT_STEP_FORE,
	ACT_GESTURE_RANGE_ATTACK1,
	ACT_GESTURE_RANGE_ATTACK2,
	ACT_GESTURE_MELEE_ATTACK1,
	ACT_GESTURE_MELEE_ATTACK2,
	ACT_GESTURE_RANGE_ATTACK1_LOW,
	ACT_GESTURE_RANGE_ATTACK2_LOW,
	ACT_MELEE_ATTACK_SWING_GESTURE,
	ACT_GESTURE_SMALL_FLINCH,
	ACT_GESTURE_BIG_FLINCH,
	ACT_GESTURE_FLINCH_BLAST,
	ACT_GESTURE_FLINCH_BLAST_SHOTGUN,
	ACT_GESTURE_FLINCH_BLAST_DAMAGED,
	ACT_GESTURE_FLINCH_BLAST_DAMAGED_SHOTGUN,
	ACT_GESTURE_FLINCH_HEAD,
	ACT_GESTURE_FLINCH_CHEST,
	ACT_GESTURE_FLINCH_STOMACH,
	ACT_GESTURE_FLINCH_LEFTARM,
	ACT_GESTURE_FLINCH_RIGHTARM,
	ACT_GESTURE_FLINCH_LEFTLEG,
	ACT_GESTURE_FLINCH_RIGHTLEG,
	ACT_GESTURE_TURN_LEFT,
	ACT_GESTURE_TURN_RIGHT,
	ACT_GESTURE_TURN_LEFT45,
	ACT_GESTURE_TURN_RIGHT45,
	ACT_GESTURE_TURN_LEFT90,
	ACT_GESTURE_TURN_RIGHT90,
	ACT_GESTURE_TURN_LEFT45_FLAT,
	ACT_GESTURE_TURN_RIGHT45_FLAT,
	ACT_GESTURE_TURN_LEFT90_FLAT,
	ACT_GESTURE_TURN_RIGHT90_FLAT,
	ACT_BARNACLE_HIT,
	ACT_BARNACLE_PULL,
	ACT_BARNACLE_CHOMP,
	ACT_BARNACLE_CHEW,
	ACT_DO_NOT_DISTURB,
	ACT_SPECIFIC_SEQUENCE,
	ACT_VM_DRAW,
	ACT_VM_HOLSTER,
	ACT_VM_IDLE,
	ACT_VM_FIDGET,
	ACT_VM_PULLBACK,
	ACT_VM_PULLBACK_HIGH,
	ACT_VM_PULLBACK_LOW,
	ACT_VM_THROW,
	ACT_VM_PULLPIN,
	ACT_VM_PRIMARYATTACK,
	ACT_VM_SECONDARYATTACK,
	ACT_VM_RELOAD,
	ACT_VM_DRYFIRE,
	ACT_VM_HITLEFT,
	ACT_VM_HITLEFT2,
	ACT_VM_HITRIGHT,
	ACT_VM_HITRIGHT2,
	ACT_VM_HITCENTER,
	ACT_VM_HITCENTER2,
	ACT_VM_MISSLEFT,
	ACT_VM_MISSLEFT2,
	ACT_VM_MISSRIGHT,
	ACT_VM_MISSRIGHT2,
	ACT_VM_MISSCENTER,
	ACT_VM_MISSCENTER2,
	ACT_VM_HAULBACK,
	ACT_VM_SWINGHARD,
	ACT_VM_SWINGMISS,
	ACT_VM_SWINGHIT,
	ACT_VM_IDLE_TO_LOWERED,
	ACT_VM_IDLE_LOWERED,
	ACT_VM_LOWERED_TO_IDLE,
	ACT_VM_RECOIL1,
	ACT_VM_RECOIL2,
	ACT_VM_RECOIL3,
	ACT_VM_PICKUP,
	ACT_VM_RELEASE,
	ACT_VM_ATTACH_SILENCER,
	ACT_VM_DETACH_SILENCER,
	ACT_VM_EMPTY_FIRE,
	ACT_VM_EMPTY_RELOAD,
	ACT_VM_EMPTY_DRAW,
	ACT_VM_EMPTY_IDLE,
	ACT_SLAM_STICKWALL_IDLE,
	ACT_SLAM_STICKWALL_ND_IDLE,
	ACT_SLAM_STICKWALL_ATTACH,
	ACT_SLAM_STICKWALL_ATTACH2,
	ACT_SLAM_STICKWALL_ND_ATTACH,
	ACT_SLAM_STICKWALL_ND_ATTACH2,
	ACT_SLAM_STICKWALL_DETONATE,
	ACT_SLAM_STICKWALL_DETONATOR_HOLSTER,
	ACT_SLAM_STICKWALL_DRAW,
	ACT_SLAM_STICKWALL_ND_DRAW,
	ACT_SLAM_STICKWALL_TO_THROW,
	ACT_SLAM_STICKWALL_TO_THROW_ND,
	ACT_SLAM_STICKWALL_TO_TRIPMINE_ND,
	ACT_SLAM_THROW_IDLE,
	ACT_SLAM_THROW_ND_IDLE,
	ACT_SLAM_THROW_THROW,
	ACT_SLAM_THROW_THROW2,
	ACT_SLAM_THROW_THROW_ND,
	ACT_SLAM_THROW_THROW_ND2,
	ACT_SLAM_THROW_DRAW,
	ACT_SLAM_THROW_ND_DRAW,
	ACT_SLAM_THROW_TO_STICKWALL,
	ACT_SLAM_THROW_TO_STICKWALL_ND,
	ACT_SLAM_THROW_DETONATE,
	ACT_SLAM_THROW_DETONATOR_HOLSTER,
	ACT_SLAM_THROW_TO_TRIPMINE_ND,
	ACT_SLAM_TRIPMINE_IDLE,
	ACT_SLAM_TRIPMINE_DRAW,
	ACT_SLAM_TRIPMINE_ATTACH,
	ACT_SLAM_TRIPMINE_ATTACH2,
	ACT_SLAM_TRIPMINE_TO_STICKWALL_ND,
	ACT_SLAM_TRIPMINE_TO_THROW_ND,
	ACT_SLAM_DETONATOR_IDLE,
	ACT_SLAM_DETONATOR_DRAW,
	ACT_SLAM_DETONATOR_DETONATE,
	ACT_SLAM_DETONATOR_HOLSTER,
	ACT_SLAM_DETONATOR_STICKWALL_DRAW,
	ACT_SLAM_DETONATOR_THROW_DRAW,
	ACT_SHOTGUN_RELOAD_START,
	ACT_SHOTGUN_RELOAD_FINISH,
	ACT_SHOTGUN_PUMP,
	ACT_SMG2_IDLE2,
	ACT_SMG2_FIRE2,
	ACT_SMG2_DRAW2,
	ACT_SMG2_RELOAD2,
	ACT_SMG2_DRYFIRE2,
	ACT_SMG2_TOAUTO,
	ACT_SMG2_TOBURST,
	ACT_PHYSCANNON_UPGRADE,
	ACT_RANGE_ATTACK_AR1,
	ACT_RANGE_ATTACK_AR2,
	ACT_RANGE_ATTACK_AR2_LOW,
	ACT_RANGE_ATTACK_AR2_GRENADE,
	ACT_RANGE_ATTACK_HMG1,
	ACT_RANGE_ATTACK_ML,
	ACT_RANGE_ATTACK_SMG1,
	ACT_RANGE_ATTACK_SMG1_LOW,
	ACT_RANGE_ATTACK_SMG2,
	ACT_RANGE_ATTACK_SHOTGUN,
	ACT_RANGE_ATTACK_SHOTGUN_LOW,
	ACT_RANGE_ATTACK_PISTOL,
	ACT_RANGE_ATTACK_PISTOL_LOW,
	ACT_RANGE_ATTACK_SLAM,
	ACT_RANGE_ATTACK_TRIPWIRE,
	ACT_RANGE_ATTACK_THROW,
	ACT_RANGE_ATTACK_SNIPER_RIFLE,
	ACT_RANGE_ATTACK_RPG,
	ACT_MELEE_ATTACK_SWING,
	ACT_RANGE_AIM_LOW,
	ACT_RANGE_AIM_SMG1_LOW,
	ACT_RANGE_AIM_PISTOL_LOW,
	ACT_RANGE_AIM_AR2_LOW,
	ACT_COVER_PISTOL_LOW,
	ACT_COVER_SMG1_LOW,
	ACT_GESTURE_RANGE_ATTACK_AR1,
	ACT_GESTURE_RANGE_ATTACK_AR2,
	ACT_GESTURE_RANGE_ATTACK_AR2_GRENADE,
	ACT_GESTURE_RANGE_ATTACK_HMG1,
	ACT_GESTURE_RANGE_ATTACK_ML,
	ACT_GESTURE_RANGE_ATTACK_SMG1,
	ACT_GESTURE_RANGE_ATTACK_SMG1_LOW,
	ACT_GESTURE_RANGE_ATTACK_SMG2,
	ACT_GESTURE_RANGE_ATTACK_SHOTGUN,
	ACT_GESTURE_RANGE_ATTACK_PISTOL,
	ACT_GESTURE_RANGE_ATTACK_PISTOL_LOW,
	ACT_GESTURE_RANGE_ATTACK_SLAM,
	ACT_GESTURE_RANGE_ATTACK_TRIPWIRE,
	ACT_GESTURE_RANGE_ATTACK_THROW,
	ACT_GESTURE_RANGE_ATTACK_SNIPER_RIFLE,
	ACT_GESTURE_MELEE_ATTACK_SWING,
	ACT_IDLE_RIFLE,
	ACT_IDLE_SMG1,
	ACT_IDLE_ANGRY_SMG1,
	ACT_IDLE_PISTOL,
	ACT_IDLE_ANGRY_PISTOL,
	ACT_IDLE_ANGRY_SHOTGUN,
	ACT_IDLE_STEALTH_PISTOL,
	ACT_IDLE_PACKAGE,
	ACT_WALK_PACKAGE,
	ACT_IDLE_SUITCASE,
	ACT_WALK_SUITCASE,
	ACT_IDLE_SMG1_RELAXED,
	ACT_IDLE_SMG1_STIMULATED,
	ACT_WALK_RIFLE_RELAXED,
	ACT_RUN_RIFLE_RELAXED,
	ACT_WALK_RIFLE_STIMULATED,
	ACT_RUN_RIFLE_STIMULATED,
	ACT_IDLE_AIM_RIFLE_STIMULATED,
	ACT_WALK_AIM_RIFLE_STIMULATED,
	ACT_RUN_AIM_RIFLE_STIMULATED,
	ACT_IDLE_SHOTGUN_RELAXED,
	ACT_IDLE_SHOTGUN_STIMULATED,
	ACT_IDLE_SHOTGUN_AGITATED,
	ACT_WALK_ANGRY,
	ACT_POLICE_HARASS1,
	ACT_POLICE_HARASS2,
	ACT_IDLE_MANNEDGUN,
	ACT_IDLE_MELEE,
	ACT_IDLE_ANGRY_MELEE,
	ACT_IDLE_RPG_RELAXED,
	ACT_IDLE_RPG,
	ACT_IDLE_ANGRY_RPG,
	ACT_COVER_LOW_RPG,
	ACT_WALK_RPG,
	ACT_RUN_RPG,
	ACT_WALK_CROUCH_RPG,
	ACT_RUN_CROUCH_RPG,
	ACT_WALK_RPG_RELAXED,
	ACT_RUN_RPG_RELAXED,
	ACT_WALK_RIFLE,
	ACT_WALK_AIM_RIFLE,
	ACT_WALK_CROUCH_RIFLE,
	ACT_WALK_CROUCH_AIM_RIFLE,
	ACT_RUN_RIFLE,
	ACT_RUN_AIM_RIFLE,
	ACT_RUN_CROUCH_RIFLE,
	ACT_RUN_CROUCH_AIM_RIFLE,
	ACT_RUN_STEALTH_PISTOL,
	ACT_WALK_AIM_SHOTGUN,
	ACT_RUN_AIM_SHOTGUN,
	ACT_WALK_PISTOL,
	ACT_RUN_PISTOL,
	ACT_WALK_AIM_PISTOL,
	ACT_RUN_AIM_PISTOL,
	ACT_WALK_STEALTH_PISTOL,
	ACT_WALK_AIM_STEALTH_PISTOL,
	ACT_RUN_AIM_STEALTH_PISTOL,
	ACT_RELOAD_PISTOL,
	ACT_RELOAD_PISTOL_LOW,
	ACT_RELOAD_SMG1,
	ACT_RELOAD_SMG1_LOW,
	ACT_RELOAD_SHOTGUN,
	ACT_RELOAD_SHOTGUN_LOW,
	ACT_GESTURE_RELOAD,
	ACT_GESTURE_RELOAD_PISTOL,
	ACT_GESTURE_RELOAD_SMG1,
	ACT_GESTURE_RELOAD_SHOTGUN,
	ACT_BUSY_LEAN_LEFT,
	ACT_BUSY_LEAN_LEFT_ENTRY,
	ACT_BUSY_LEAN_LEFT_EXIT,
	ACT_BUSY_LEAN_BACK,
	ACT_BUSY_LEAN_BACK_ENTRY,
	ACT_BUSY_LEAN_BACK_EXIT,
	ACT_BUSY_SIT_GROUND,
	ACT_BUSY_SIT_GROUND_ENTRY,
	ACT_BUSY_SIT_GROUND_EXIT,
	ACT_BUSY_SIT_CHAIR,
	ACT_BUSY_SIT_CHAIR_ENTRY,
	ACT_BUSY_SIT_CHAIR_EXIT,
	ACT_BUSY_STAND,
	ACT_BUSY_QUEUE,
	ACT_DUCK_DODGE,
	ACT_DIE_BARNACLE_SWALLOW,
	ACT_GESTURE_BARNACLE_STRANGLE,
	ACT_PHYSCANNON_DETACH,
	ACT_PHYSCANNON_ANIMATE,
	ACT_PHYSCANNON_ANIMATE_PRE,
	ACT_PHYSCANNON_ANIMATE_POST,
	ACT_DIE_FRONTSIDE,
	ACT_DIE_RIGHTSIDE,
	ACT_DIE_BACKSIDE,
	ACT_DIE_LEFTSIDE,
	ACT_DIE_CROUCH_FRONTSIDE,
	ACT_DIE_CROUCH_RIGHTSIDE,
	ACT_DIE_CROUCH_BACKSIDE,
	ACT_DIE_CROUCH_LEFTSIDE,
	ACT_OPEN_DOOR,
	ACT_DI_ALYX_ZOMBIE_MELEE,
	ACT_DI_ALYX_ZOMBIE_TORSO_MELEE,
	ACT_DI_ALYX_HEADCRAB_MELEE,
	ACT_DI_ALYX_ANTLION,
	ACT_DI_ALYX_ZOMBIE_SHOTGUN64,
	ACT_DI_ALYX_ZOMBIE_SHOTGUN26,
	ACT_READINESS_RELAXED_TO_STIMULATED,
	ACT_READINESS_RELAXED_TO_STIMULATED_WALK,
	ACT_READINESS_AGITATED_TO_STIMULATED,
	ACT_READINESS_STIMULATED_TO_RELAXED,
	ACT_READINESS_PISTOL_RELAXED_TO_STIMULATED,
	ACT_READINESS_PISTOL_RELAXED_TO_STIMULATED_WALK,
	ACT_READINESS_PISTOL_AGITATED_TO_STIMULATED,
	ACT_READINESS_PISTOL_STIMULATED_TO_RELAXED,
	ACT_IDLE_CARRY,
	ACT_WALK_CARRY,
	ACT_STARTDYING,
	ACT_DYINGLOOP,
	ACT_DYINGTODEAD,
	ACT_RIDE_MANNED_GUN,
	ACT_VM_SPRINT_ENTER,
	ACT_VM_SPRINT_IDLE,
	ACT_VM_SPRINT_LEAVE,
	ACT_FIRE_START,
	ACT_FIRE_LOOP,
	ACT_FIRE_END,
	ACT_CROUCHING_GRENADEIDLE,
	ACT_CROUCHING_GRENADEREADY,
	ACT_CROUCHING_PRIMARYATTACK,
	ACT_OVERLAY_GRENADEIDLE,
	ACT_OVERLAY_GRENADEREADY,
	ACT_OVERLAY_PRIMARYATTACK,
	ACT_OVERLAY_SHIELD_UP,
	ACT_OVERLAY_SHIELD_DOWN,
	ACT_OVERLAY_SHIELD_UP_IDLE,
	ACT_OVERLAY_SHIELD_ATTACK,
	ACT_OVERLAY_SHIELD_KNOCKBACK,
	ACT_SHIELD_UP,
	ACT_SHIELD_DOWN,
	ACT_SHIELD_UP_IDLE,
	ACT_SHIELD_ATTACK,
	ACT_SHIELD_KNOCKBACK,
	ACT_CROUCHING_SHIELD_UP,
	ACT_CROUCHING_SHIELD_DOWN,
	ACT_CROUCHING_SHIELD_UP_IDLE,
	ACT_CROUCHING_SHIELD_ATTACK,
	ACT_CROUCHING_SHIELD_KNOCKBACK,
	ACT_TURNRIGHT45,
	ACT_TURNLEFT45,
	ACT_TURN,
	ACT_OBJ_ASSEMBLING,
	ACT_OBJ_DISMANTLING,
	ACT_OBJ_STARTUP,
	ACT_OBJ_RUNNING,
	ACT_OBJ_IDLE,
	ACT_OBJ_PLACING,
	ACT_OBJ_DETERIORATING,
	ACT_OBJ_UPGRADING,
	ACT_DEPLOY,
	ACT_DEPLOY_IDLE,
	ACT_UNDEPLOY,
	ACT_CROSSBOW_DRAW_UNLOADED,
	ACT_GAUSS_SPINUP,
	ACT_GAUSS_SPINCYCLE,
	ACT_VM_PRIMARYATTACK_SILENCED,
	ACT_VM_RELOAD_SILENCED,
	ACT_VM_DRYFIRE_SILENCED,
	ACT_VM_IDLE_SILENCED,
	ACT_VM_DRAW_SILENCED,
	ACT_VM_IDLE_EMPTY_LEFT,
	ACT_VM_DRYFIRE_LEFT,
	ACT_VM_IS_DRAW,
	ACT_VM_IS_HOLSTER,
	ACT_VM_IS_IDLE,
	ACT_VM_IS_PRIMARYATTACK,
	ACT_PLAYER_IDLE_FIRE,
	ACT_PLAYER_CROUCH_FIRE,
	ACT_PLAYER_CROUCH_WALK_FIRE,
	ACT_PLAYER_WALK_FIRE,
	ACT_PLAYER_RUN_FIRE,
	ACT_IDLETORUN,
	ACT_RUNTOIDLE,
	ACT_VM_DRAW_DEPLOYED,
	ACT_HL2MP_IDLE_MELEE,
	ACT_HL2MP_RUN_MELEE,
	ACT_HL2MP_IDLE_CROUCH_MELEE,
	ACT_HL2MP_WALK_CROUCH_MELEE,
	ACT_HL2MP_GESTURE_RANGE_ATTACK_MELEE,
	ACT_HL2MP_GESTURE_RELOAD_MELEE,
	ACT_HL2MP_JUMP_MELEE,
	ACT_VM_FIZZLE,
	ACT_MP_STAND_IDLE,
	ACT_MP_CROUCH_IDLE,
	ACT_MP_CROUCH_DEPLOYED_IDLE,
	ACT_MP_CROUCH_DEPLOYED,
	ACT_MP_DEPLOYED_IDLE,
	ACT_MP_RUN,
	ACT_MP_WALK,
	ACT_MP_AIRWALK,
	ACT_MP_CROUCHWALK,
	ACT_MP_SPRINT,
	ACT_MP_JUMP,
	ACT_MP_JUMP_START,
	ACT_MP_JUMP_FLOAT,
	ACT_MP_JUMP_LAND,
	ACT_MP_JUMP_IMPACT_N,
	ACT_MP_JUMP_IMPACT_E,
	ACT_MP_JUMP_IMPACT_W,
	ACT_MP_JUMP_IMPACT_S,
	ACT_MP_JUMP_IMPACT_TOP,
	ACT_MP_DOUBLEJUMP,
	ACT_MP_SWIM,
	ACT_MP_DEPLOYED,
	ACT_MP_SWIM_DEPLOYED,
	ACT_MP_VCD,
	ACT_MP_ATTACK_STAND_PRIMARYFIRE,
	ACT_MP_ATTACK_STAND_PRIMARYFIRE_DEPLOYED,
	ACT_MP_ATTACK_STAND_SECONDARYFIRE,
	ACT_MP_ATTACK_STAND_GRENADE,
	ACT_MP_ATTACK_CROUCH_PRIMARYFIRE,
	ACT_MP_ATTACK_CROUCH_PRIMARYFIRE_DEPLOYED,
	ACT_MP_ATTACK_CROUCH_SECONDARYFIRE,
	ACT_MP_ATTACK_CROUCH_GRENADE,
	ACT_MP_ATTACK_SWIM_PRIMARYFIRE,
	ACT_MP_ATTACK_SWIM_SECONDARYFIRE,
	ACT_MP_ATTACK_SWIM_GRENADE,
	ACT_MP_ATTACK_AIRWALK_PRIMARYFIRE,
	ACT_MP_ATTACK_AIRWALK_SECONDARYFIRE,
	ACT_MP_ATTACK_AIRWALK_GRENADE,
	ACT_MP_RELOAD_STAND,
	ACT_MP_RELOAD_STAND_LOOP,
	ACT_MP_RELOAD_STAND_END,
	ACT_MP_RELOAD_CROUCH,
	ACT_MP_RELOAD_CROUCH_LOOP,
	ACT_MP_RELOAD_CROUCH_END,
	ACT_MP_RELOAD_SWIM,
	ACT_MP_RELOAD_SWIM_LOOP,
	ACT_MP_RELOAD_SWIM_END,
	ACT_MP_RELOAD_AIRWALK,
	ACT_MP_RELOAD_AIRWALK_LOOP,
	ACT_MP_RELOAD_AIRWALK_END,
	ACT_MP_ATTACK_STAND_PREFIRE,
	ACT_MP_ATTACK_STAND_POSTFIRE,
	ACT_MP_ATTACK_STAND_STARTFIRE,
	ACT_MP_ATTACK_CROUCH_PREFIRE,
	ACT_MP_ATTACK_CROUCH_POSTFIRE,
	ACT_MP_ATTACK_SWIM_PREFIRE,
	ACT_MP_ATTACK_SWIM_POSTFIRE,
	ACT_MP_STAND_PRIMARY,
	ACT_MP_CROUCH_PRIMARY,
	ACT_MP_RUN_PRIMARY,
	ACT_MP_WALK_PRIMARY,
	ACT_MP_AIRWALK_PRIMARY,
	ACT_MP_CROUCHWALK_PRIMARY,
	ACT_MP_JUMP_PRIMARY,
	ACT_MP_JUMP_START_PRIMARY,
	ACT_MP_JUMP_FLOAT_PRIMARY,
	ACT_MP_JUMP_LAND_PRIMARY,
	ACT_MP_SWIM_PRIMARY,
	ACT_MP_DEPLOYED_PRIMARY,
	ACT_MP_SWIM_DEPLOYED_PRIMARY,
	ACT_MP_ATTACK_STAND_PRIMARY,
	ACT_MP_ATTACK_STAND_PRIMARY_DEPLOYED,
	ACT_MP_ATTACK_CROUCH_PRIMARY,
	ACT_MP_ATTACK_CROUCH_PRIMARY_DEPLOYED,
	ACT_MP_ATTACK_SWIM_PRIMARY,
	ACT_MP_ATTACK_AIRWALK_PRIMARY,
	ACT_MP_RELOAD_STAND_PRIMARY,
	ACT_MP_RELOAD_STAND_PRIMARY_LOOP,
	ACT_MP_RELOAD_STAND_PRIMARY_END,
	ACT_MP_RELOAD_CROUCH_PRIMARY,
	ACT_MP_RELOAD_CROUCH_PRIMARY_LOOP,
	ACT_MP_RELOAD_CROUCH_PRIMARY_END,
	ACT_MP_RELOAD_SWIM_PRIMARY,
	ACT_MP_RELOAD_SWIM_PRIMARY_LOOP,
	ACT_MP_RELOAD_SWIM_PRIMARY_END,
	ACT_MP_RELOAD_AIRWALK_PRIMARY,
	ACT_MP_RELOAD_AIRWALK_PRIMARY_LOOP,
	ACT_MP_RELOAD_AIRWALK_PRIMARY_END,
	ACT_MP_ATTACK_STAND_GRENADE_PRIMARY,
	ACT_MP_ATTACK_CROUCH_GRENADE_PRIMARY,
	ACT_MP_ATTACK_SWIM_GRENADE_PRIMARY,
	ACT_MP_ATTACK_AIRWALK_GRENADE_PRIMARY,
	ACT_MP_STAND_SECONDARY,
	ACT_MP_CROUCH_SECONDARY,
	ACT_MP_RUN_SECONDARY,
	ACT_MP_WALK_SECONDARY,
	ACT_MP_AIRWALK_SECONDARY,
	ACT_MP_CROUCHWALK_SECONDARY,
	ACT_MP_JUMP_SECONDARY,
	ACT_MP_JUMP_START_SECONDARY,
	ACT_MP_JUMP_FLOAT_SECONDARY,
	ACT_MP_JUMP_LAND_SECONDARY,
	ACT_MP_SWIM_SECONDARY,
	ACT_MP_ATTACK_STAND_SECONDARY,
	ACT_MP_ATTACK_CROUCH_SECONDARY,
	ACT_MP_ATTACK_SWIM_SECONDARY,
	ACT_MP_ATTACK_AIRWALK_SECONDARY,
	ACT_MP_RELOAD_STAND_SECONDARY,
	ACT_MP_RELOAD_STAND_SECONDARY_LOOP,
	ACT_MP_RELOAD_STAND_SECONDARY_END,
	ACT_MP_RELOAD_CROUCH_SECONDARY,
	ACT_MP_RELOAD_CROUCH_SECONDARY_LOOP,
	ACT_MP_RELOAD_CROUCH_SECONDARY_END,
	ACT_MP_RELOAD_SWIM_SECONDARY,
	ACT_MP_RELOAD_SWIM_SECONDARY_LOOP,
	ACT_MP_RELOAD_SWIM_SECONDARY_END,
	ACT_MP_RELOAD_AIRWALK_SECONDARY,
	ACT_MP_RELOAD_AIRWALK_SECONDARY_LOOP,
	ACT_MP_RELOAD_AIRWALK_SECONDARY_END,
	ACT_MP_ATTACK_STAND_GRENADE_SECONDARY,
	ACT_MP_ATTACK_CROUCH_GRENADE_SECONDARY,
	ACT_MP_ATTACK_SWIM_GRENADE_SECONDARY,
	ACT_MP_ATTACK_AIRWALK_GRENADE_SECONDARY,
	ACT_MP_STAND_MELEE,
	ACT_MP_CROUCH_MELEE,
	ACT_MP_RUN_MELEE,
	ACT_MP_WALK_MELEE,
	ACT_MP_AIRWALK_MELEE,
	ACT_MP_CROUCHWALK_MELEE,
	ACT_MP_JUMP_MELEE,
	ACT_MP_JUMP_START_MELEE,
	ACT_MP_JUMP_FLOAT_MELEE,
	ACT_MP_JUMP_LAND_MELEE,
	ACT_MP_SWIM_MELEE,
	ACT_MP_ATTACK_STAND_MELEE,
	ACT_MP_ATTACK_STAND_MELEE_SECONDARY,
	ACT_MP_ATTACK_CROUCH_MELEE,
	ACT_MP_ATTACK_CROUCH_MELEE_SECONDARY,
	ACT_MP_ATTACK_SWIM_MELEE,
	ACT_MP_ATTACK_AIRWALK_MELEE,
	ACT_MP_ATTACK_STAND_GRENADE_MELEE,
	ACT_MP_ATTACK_CROUCH_GRENADE_MELEE,
	ACT_MP_ATTACK_SWIM_GRENADE_MELEE,
	ACT_MP_ATTACK_AIRWALK_GRENADE_MELEE,
	ACT_MP_STAND_ITEM1,
	ACT_MP_CROUCH_ITEM1,
	ACT_MP_RUN_ITEM1,
	ACT_MP_WALK_ITEM1,
	ACT_MP_AIRWALK_ITEM1,
	ACT_MP_CROUCHWALK_ITEM1,
	ACT_MP_JUMP_ITEM1,
	ACT_MP_JUMP_START_ITEM1,
	ACT_MP_JUMP_FLOAT_ITEM1,
	ACT_MP_JUMP_LAND_ITEM1,
	ACT_MP_SWIM_ITEM1,
	ACT_MP_ATTACK_STAND_ITEM1,
	ACT_MP_ATTACK_STAND_ITEM1_SECONDARY,
	ACT_MP_ATTACK_CROUCH_ITEM1,
	ACT_MP_ATTACK_CROUCH_ITEM1_SECONDARY,
	ACT_MP_ATTACK_SWIM_ITEM1,
	ACT_MP_ATTACK_AIRWALK_ITEM1,
	ACT_MP_STAND_ITEM2,
	ACT_MP_CROUCH_ITEM2,
	ACT_MP_RUN_ITEM2,
	ACT_MP_WALK_ITEM2,
	ACT_MP_AIRWALK_ITEM2,
	ACT_MP_CROUCHWALK_ITEM2,
	ACT_MP_JUMP_ITEM2,
	ACT_MP_JUMP_START_ITEM2,
	ACT_MP_JUMP_FLOAT_ITEM2,
	ACT_MP_JUMP_LAND_ITEM2,
	ACT_MP_SWIM_ITEM2,
	ACT_MP_ATTACK_STAND_ITEM2,
	ACT_MP_ATTACK_STAND_ITEM2_SECONDARY,
	ACT_MP_ATTACK_CROUCH_ITEM2,
	ACT_MP_ATTACK_CROUCH_ITEM2_SECONDARY,
	ACT_MP_ATTACK_SWIM_ITEM2,
	ACT_MP_ATTACK_AIRWALK_ITEM2,
	ACT_MP_GESTURE_FLINCH,
	ACT_MP_GESTURE_FLINCH_PRIMARY,
	ACT_MP_GESTURE_FLINCH_SECONDARY,
	ACT_MP_GESTURE_FLINCH_MELEE,
	ACT_MP_GESTURE_FLINCH_ITEM1,
	ACT_MP_GESTURE_FLINCH_ITEM2,
	ACT_MP_GESTURE_FLINCH_HEAD,
	ACT_MP_GESTURE_FLINCH_CHEST,
	ACT_MP_GESTURE_FLINCH_STOMACH,
	ACT_MP_GESTURE_FLINCH_LEFTARM,
	ACT_MP_GESTURE_FLINCH_RIGHTARM,
	ACT_MP_GESTURE_FLINCH_LEFTLEG,
	ACT_MP_GESTURE_FLINCH_RIGHTLEG,
	ACT_MP_GRENADE1_DRAW,
	ACT_MP_GRENADE1_IDLE,
	ACT_MP_GRENADE1_ATTACK,
	ACT_MP_GRENADE2_DRAW,
	ACT_MP_GRENADE2_IDLE,
	ACT_MP_GRENADE2_ATTACK,
	ACT_MP_PRIMARY_GRENADE1_DRAW,
	ACT_MP_PRIMARY_GRENADE1_IDLE,
	ACT_MP_PRIMARY_GRENADE1_ATTACK,
	ACT_MP_PRIMARY_GRENADE2_DRAW,
	ACT_MP_PRIMARY_GRENADE2_IDLE,
	ACT_MP_PRIMARY_GRENADE2_ATTACK,
	ACT_MP_SECONDARY_GRENADE1_DRAW,
	ACT_MP_SECONDARY_GRENADE1_IDLE,
	ACT_MP_SECONDARY_GRENADE1_ATTACK,
	ACT_MP_SECONDARY_GRENADE2_DRAW,
	ACT_MP_SECONDARY_GRENADE2_IDLE,
	ACT_MP_SECONDARY_GRENADE2_ATTACK,
	ACT_MP_MELEE_GRENADE1_DRAW,
	ACT_MP_MELEE_GRENADE1_IDLE,
	ACT_MP_MELEE_GRENADE1_ATTACK,
	ACT_MP_MELEE_GRENADE2_DRAW,
	ACT_MP_MELEE_GRENADE2_IDLE,
	ACT_MP_MELEE_GRENADE2_ATTACK,
	ACT_MP_ITEM1_GRENADE1_DRAW,
	ACT_MP_ITEM1_GRENADE1_IDLE,
	ACT_MP_ITEM1_GRENADE1_ATTACK,
	ACT_MP_ITEM1_GRENADE2_DRAW,
	ACT_MP_ITEM1_GRENADE2_IDLE,
	ACT_MP_ITEM1_GRENADE2_ATTACK,
	ACT_MP_ITEM2_GRENADE1_DRAW,
	ACT_MP_ITEM2_GRENADE1_IDLE,
	ACT_MP_ITEM2_GRENADE1_ATTACK,
	ACT_MP_ITEM2_GRENADE2_DRAW,
	ACT_MP_ITEM2_GRENADE2_IDLE,
	ACT_MP_ITEM2_GRENADE2_ATTACK,
	ACT_MP_STAND_BUILDING,
	ACT_MP_CROUCH_BUILDING,
	ACT_MP_RUN_BUILDING,
	ACT_MP_WALK_BUILDING,
	ACT_MP_AIRWALK_BUILDING,
	ACT_MP_CROUCHWALK_BUILDING,
	ACT_MP_JUMP_BUILDING,
	ACT_MP_JUMP_START_BUILDING,
	ACT_MP_JUMP_FLOAT_BUILDING,
	ACT_MP_JUMP_LAND_BUILDING,
	ACT_MP_SWIM_BUILDING,
	ACT_MP_ATTACK_STAND_BUILDING,
	ACT_MP_ATTACK_CROUCH_BUILDING,
	ACT_MP_ATTACK_SWIM_BUILDING,
	ACT_MP_ATTACK_AIRWALK_BUILDING,
	ACT_MP_ATTACK_STAND_GRENADE_BUILDING,
	ACT_MP_ATTACK_CROUCH_GRENADE_BUILDING,
	ACT_MP_ATTACK_SWIM_GRENADE_BUILDING,
	ACT_MP_ATTACK_AIRWALK_GRENADE_BUILDING,
	ACT_MP_STAND_PDA,
	ACT_MP_CROUCH_PDA,
	ACT_MP_RUN_PDA,
	ACT_MP_WALK_PDA,
	ACT_MP_AIRWALK_PDA,
	ACT_MP_CROUCHWALK_PDA,
	ACT_MP_JUMP_PDA,
	ACT_MP_JUMP_START_PDA,
	ACT_MP_JUMP_FLOAT_PDA,
	ACT_MP_JUMP_LAND_PDA,
	ACT_MP_SWIM_PDA,
	ACT_MP_ATTACK_STAND_PDA,
	ACT_MP_ATTACK_SWIM_PDA,
	ACT_MP_GESTURE_VC_HANDMOUTH,
	ACT_MP_GESTURE_VC_FINGERPOINT,
	ACT_MP_GESTURE_VC_FISTPUMP,
	ACT_MP_GESTURE_VC_THUMBSUP,
	ACT_MP_GESTURE_VC_NODYES,
	ACT_MP_GESTURE_VC_NODNO,
	ACT_MP_GESTURE_VC_HANDMOUTH_PRIMARY,
	ACT_MP_GESTURE_VC_FINGERPOINT_PRIMARY,
	ACT_MP_GESTURE_VC_FISTPUMP_PRIMARY,
	ACT_MP_GESTURE_VC_THUMBSUP_PRIMARY,
	ACT_MP_GESTURE_VC_NODYES_PRIMARY,
	ACT_MP_GESTURE_VC_NODNO_PRIMARY,
	ACT_MP_GESTURE_VC_HANDMOUTH_SECONDARY,
	ACT_MP_GESTURE_VC_FINGERPOINT_SECONDARY,
	ACT_MP_GESTURE_VC_FISTPUMP_SECONDARY,
	ACT_MP_GESTURE_VC_THUMBSUP_SECONDARY,
	ACT_MP_GESTURE_VC_NODYES_SECONDARY,
	ACT_MP_GESTURE_VC_NODNO_SECONDARY,
	ACT_MP_GESTURE_VC_HANDMOUTH_MELEE,
	ACT_MP_GESTURE_VC_FINGERPOINT_MELEE,
	ACT_MP_GESTURE_VC_FISTPUMP_MELEE,
	ACT_MP_GESTURE_VC_THUMBSUP_MELEE,
	ACT_MP_GESTURE_VC_NODYES_MELEE,
	ACT_MP_GESTURE_VC_NODNO_MELEE,
	ACT_MP_GESTURE_VC_HANDMOUTH_ITEM1,
	ACT_MP_GESTURE_VC_FINGERPOINT_ITEM1,
	ACT_MP_GESTURE_VC_FISTPUMP_ITEM1,
	ACT_MP_GESTURE_VC_THUMBSUP_ITEM1,
	ACT_MP_GESTURE_VC_NODYES_ITEM1,
	ACT_MP_GESTURE_VC_NODNO_ITEM1,
	ACT_MP_GESTURE_VC_HANDMOUTH_ITEM2,
	ACT_MP_GESTURE_VC_FINGERPOINT_ITEM2,
	ACT_MP_GESTURE_VC_FISTPUMP_ITEM2,
	ACT_MP_GESTURE_VC_THUMBSUP_ITEM2,
	ACT_MP_GESTURE_VC_NODYES_ITEM2,
	ACT_MP_GESTURE_VC_NODNO_ITEM2,
	ACT_MP_GESTURE_VC_HANDMOUTH_BUILDING,
	ACT_MP_GESTURE_VC_FINGERPOINT_BUILDING,
	ACT_MP_GESTURE_VC_FISTPUMP_BUILDING,
	ACT_MP_GESTURE_VC_THUMBSUP_BUILDING,
	ACT_MP_GESTURE_VC_NODYES_BUILDING,
	ACT_MP_GESTURE_VC_NODNO_BUILDING,
	ACT_MP_GESTURE_VC_HANDMOUTH_PDA,
	ACT_MP_GESTURE_VC_FINGERPOINT_PDA,
	ACT_MP_GESTURE_VC_FISTPUMP_PDA,
	ACT_MP_GESTURE_VC_THUMBSUP_PDA,
	ACT_MP_GESTURE_VC_NODYES_PDA,
	ACT_MP_GESTURE_VC_NODNO_PDA,
	ACT_VM_UNUSABLE,
	ACT_VM_UNUSABLE_TO_USABLE,
	ACT_VM_USABLE_TO_UNUSABLE,
	ACT_PRIMARY_VM_DRAW,
	ACT_PRIMARY_VM_HOLSTER,
	ACT_PRIMARY_VM_IDLE,
	ACT_PRIMARY_VM_PULLBACK,
	ACT_PRIMARY_VM_PRIMARYATTACK,
	ACT_PRIMARY_VM_SECONDARYATTACK,
	ACT_PRIMARY_VM_RELOAD,
	ACT_PRIMARY_VM_DRYFIRE,
	ACT_PRIMARY_VM_IDLE_TO_LOWERED,
	ACT_PRIMARY_VM_IDLE_LOWERED,
	ACT_PRIMARY_VM_LOWERED_TO_IDLE,
	ACT_SECONDARY_VM_DRAW,
	ACT_SECONDARY_VM_HOLSTER,
	ACT_SECONDARY_VM_IDLE,
	ACT_SECONDARY_VM_PULLBACK,
	ACT_SECONDARY_VM_PRIMARYATTACK,
	ACT_SECONDARY_VM_SECONDARYATTACK,
	ACT_SECONDARY_VM_RELOAD,
	ACT_SECONDARY_VM_DRYFIRE,
	ACT_SECONDARY_VM_IDLE_TO_LOWERED,
	ACT_SECONDARY_VM_IDLE_LOWERED,
	ACT_SECONDARY_VM_LOWERED_TO_IDLE,
	ACT_MELEE_VM_DRAW,
	ACT_MELEE_VM_HOLSTER,
	ACT_MELEE_VM_IDLE,
	ACT_MELEE_VM_PULLBACK,
	ACT_MELEE_VM_PRIMARYATTACK,
	ACT_MELEE_VM_SECONDARYATTACK,
	ACT_MELEE_VM_RELOAD,
	ACT_MELEE_VM_DRYFIRE,
	ACT_MELEE_VM_IDLE_TO_LOWERED,
	ACT_MELEE_VM_IDLE_LOWERED,
	ACT_MELEE_VM_LOWERED_TO_IDLE,
	ACT_PDA_VM_DRAW,
	ACT_PDA_VM_HOLSTER,
	ACT_PDA_VM_IDLE,
	ACT_PDA_VM_PULLBACK,
	ACT_PDA_VM_PRIMARYATTACK,
	ACT_PDA_VM_SECONDARYATTACK,
	ACT_PDA_VM_RELOAD,
	ACT_PDA_VM_DRYFIRE,
	ACT_PDA_VM_IDLE_TO_LOWERED,
	ACT_PDA_VM_IDLE_LOWERED,
	ACT_PDA_VM_LOWERED_TO_IDLE,
	ACT_ITEM1_VM_DRAW,
	ACT_ITEM1_VM_HOLSTER,
	ACT_ITEM1_VM_IDLE,
	ACT_ITEM1_VM_PULLBACK,
	ACT_ITEM1_VM_PRIMARYATTACK,
	ACT_ITEM1_VM_SECONDARYATTACK,
	ACT_ITEM1_VM_RELOAD,
	ACT_ITEM1_VM_DRYFIRE,
	ACT_ITEM1_VM_IDLE_TO_LOWERED,
	ACT_ITEM1_VM_IDLE_LOWERED,
	ACT_ITEM1_VM_LOWERED_TO_IDLE,
	ACT_ITEM2_VM_DRAW,
	ACT_ITEM2_VM_HOLSTER,
	ACT_ITEM2_VM_IDLE,
	ACT_ITEM2_VM_PULLBACK,
	ACT_ITEM2_VM_PRIMARYATTACK,
	ACT_ITEM2_VM_SECONDARYATTACK,
	ACT_ITEM2_VM_RELOAD,
	ACT_ITEM2_VM_DRYFIRE,
	ACT_ITEM2_VM_IDLE_TO_LOWERED,
	ACT_ITEM2_VM_IDLE_LOWERED,
	ACT_ITEM2_VM_LOWERED_TO_IDLE,
	ACT_RELOAD_SUCCEED,
	ACT_RELOAD_FAIL,
	ACT_WALK_AIM_AUTOGUN,
	ACT_RUN_AIM_AUTOGUN,
	ACT_IDLE_AUTOGUN,
	ACT_IDLE_AIM_AUTOGUN,
	ACT_RELOAD_AUTOGUN,
	ACT_CROUCH_IDLE_AUTOGUN,
	ACT_RANGE_ATTACK_AUTOGUN,
	ACT_JUMP_AUTOGUN,
	ACT_IDLE_AIM_PISTOL,
	ACT_WALK_AIM_DUAL,
	ACT_RUN_AIM_DUAL,
	ACT_IDLE_DUAL,
	ACT_IDLE_AIM_DUAL,
	ACT_RELOAD_DUAL,
	ACT_CROUCH_IDLE_DUAL,
	ACT_RANGE_ATTACK_DUAL,
	ACT_JUMP_DUAL,
	ACT_IDLE_SHOTGUN,
	ACT_IDLE_AIM_SHOTGUN,
	ACT_CROUCH_IDLE_SHOTGUN,
	ACT_JUMP_SHOTGUN,
	ACT_IDLE_AIM_RIFLE,
	ACT_RELOAD_RIFLE,
	ACT_CROUCH_IDLE_RIFLE,
	ACT_RANGE_ATTACK_RIFLE,
	ACT_JUMP_RIFLE,
	ACT_SLEEP,
	ACT_WAKE,
	ACT_FLICK_LEFT,
	ACT_FLICK_LEFT_MIDDLE,
	ACT_FLICK_RIGHT_MIDDLE,
	ACT_FLICK_RIGHT,
	ACT_SPINAROUND,
	ACT_PREP_TO_FIRE,
	ACT_FIRE,
	ACT_FIRE_RECOVER,
	ACT_SPRAY,
	ACT_PREP_EXPLODE,
	ACT_EXPLODE,
	ACT_DOTA_IDLE,
	ACT_DOTA_RUN,
	ACT_DOTA_ATTACK,
	ACT_DOTA_ATTACK_EVENT,
	ACT_DOTA_DIE,
	ACT_DOTA_FLINCH,
	ACT_DOTA_DISABLED,
	ACT_DOTA_CAST_ABILITY_1,
	ACT_DOTA_CAST_ABILITY_2,
	ACT_DOTA_CAST_ABILITY_3,
	ACT_DOTA_CAST_ABILITY_4,
	ACT_DOTA_OVERRIDE_ABILITY_1,
	ACT_DOTA_OVERRIDE_ABILITY_2,
	ACT_DOTA_OVERRIDE_ABILITY_3,
	ACT_DOTA_OVERRIDE_ABILITY_4,
	ACT_DOTA_CHANNEL_ABILITY_1,
	ACT_DOTA_CHANNEL_ABILITY_2,
	ACT_DOTA_CHANNEL_ABILITY_3,
	ACT_DOTA_CHANNEL_ABILITY_4,
	ACT_DOTA_CHANNEL_END_ABILITY_1,
	ACT_DOTA_CHANNEL_END_ABILITY_2,
	ACT_DOTA_CHANNEL_END_ABILITY_3,
	ACT_DOTA_CHANNEL_END_ABILITY_4,
	ACT_MP_RUN_SPEEDPAINT,
	ACT_MP_LONG_FALL,
	ACT_MP_TRACTORBEAM_FLOAT,
	ACT_MP_DEATH_CRUSH,
	ACT_MP_RUN_SPEEDPAINT_PRIMARY,
	ACT_MP_DROWNING_PRIMARY,
	ACT_MP_LONG_FALL_PRIMARY,
	ACT_MP_TRACTORBEAM_FLOAT_PRIMARY,
	ACT_MP_DEATH_CRUSH_PRIMARY,
	ACT_DIE_STAND,
	ACT_DIE_STAND_HEADSHOT,
	ACT_DIE_CROUCH,
	ACT_DIE_CROUCH_HEADSHOT,
	ACT_CSGO_NULL,
	ACT_CSGO_DEFUSE,
	ACT_CSGO_DEFUSE_WITH_KIT,
	ACT_CSGO_FLASHBANG_REACTION,
	ACT_CSGO_FIRE_PRIMARY,
	ACT_CSGO_FIRE_PRIMARY_OPT_1,
	ACT_CSGO_FIRE_PRIMARY_OPT_2,
	ACT_CSGO_FIRE_SECONDARY,
	ACT_CSGO_FIRE_SECONDARY_OPT_1,
	ACT_CSGO_FIRE_SECONDARY_OPT_2,
	ACT_CSGO_RELOAD,
	ACT_CSGO_RELOAD_START,
	ACT_CSGO_RELOAD_LOOP,
	ACT_CSGO_RELOAD_END,
	ACT_CSGO_OPERATE,
	ACT_CSGO_DEPLOY,
	ACT_CSGO_CATCH,
	ACT_CSGO_SILENCER_DETACH,
	ACT_CSGO_SILENCER_ATTACH,
	ACT_CSGO_TWITCH,
	ACT_CSGO_TWITCH_BUYZONE,
	ACT_CSGO_PLANT_BOMB,
	ACT_CSGO_IDLE_TURN_BALANCEADJUST,
	ACT_CSGO_IDLE_ADJUST_STOPPEDMOVING,
	ACT_CSGO_ALIVE_LOOP,
	ACT_CSGO_FLINCH,
	ACT_CSGO_FLINCH_HEAD,
	ACT_CSGO_FLINCH_MOLOTOV,
	ACT_CSGO_JUMP,
	ACT_CSGO_FALL,
	ACT_CSGO_CLIMB_LADDER,
	ACT_CSGO_LAND_LIGHT,
	ACT_CSGO_LAND_HEAVY,
	ACT_CSGO_EXIT_LADDER_TOP,
	ACT_CSGO_EXIT_LADDER_BOTTOM,
};

enum
{
	EF_BONEMERGE = 0x001,	// Performs bone merge on client side
	EF_BRIGHTLIGHT = 0x002,	// DLIGHT centered at entity origin
	EF_DIMLIGHT = 0x004,	// player flashlight
	EF_NOINTERP = 0x008,	// don't interpolate the next frame
	EF_NOSHADOW = 0x010,	// Don't cast no shadow
	EF_NODRAW = 0x020,	// don't draw entity
	EF_NORECEIVESHADOW = 0x040,	// Don't receive no shadow
	EF_BONEMERGE_FASTCULL = 0x080,	// For use with EF_BONEMERGE. If this is set, then it places this ent's origin at its
									// parent and uses the parent's bbox + the max extents of the aiment.
									// Otherwise, it sets up the parent's bones every frame to figure out where to place
									// the aiment, which is inefficient because it'll setup the parent's bones even if
									// the parent is not in the PVS.
									EF_ITEM_BLINK = 0x100,	// blink an item so that the user notices it.
									EF_PARENT_ANIMATES = 0x200,	// always assume that the parent entity is animating
									EF_MAX_BITS = 10
};

enum DataUpdateType_t
{
	DATA_UPDATE_CREATED = 0,	// indicates it was created +and+ entered the pvs
								//	DATA_UPDATE_ENTERED_PVS,
								DATA_UPDATE_DATATABLE_CHANGED,
								//	DATA_UPDATE_LEFT_PVS,
								//	DATA_UPDATE_DESTROYED,		// FIXME: Could enable this, but it's a little worrying
								// since it changes a bunch of existing code
};

enum ClassId
{
	ClassId_CAI_BaseNPC = 0,
	ClassId_CAK47,
	ClassId_CBaseAnimating,
	ClassId_CBaseAnimatingOverlay,
	ClassId_CBaseAttributableItem,
	ClassId_CBaseButton,
	ClassId_CBaseCombatCharacter,
	ClassId_CBaseCombatWeapon,
	ClassId_CBaseCSGrenade,
	ClassId_CBaseCSGrenadeProjectile,
	ClassId_CBaseDoor,
	ClassId_CBaseEntity,
	ClassId_CBaseFlex,
	ClassId_CBaseGrenade,
	ClassId_CBaseParticleEntity,
	ClassId_CBasePlayer,
	ClassId_CBasePropDoor,
	ClassId_CBaseTeamObjectiveResource,
	ClassId_CBaseTempEntity,
	ClassId_CBaseToggle,
	ClassId_CBaseTrigger,
	ClassId_CBaseViewModel,
	ClassId_CBaseVPhysicsTrigger,
	ClassId_CBaseWeaponWorldModel,
	ClassId_CBeam,
	ClassId_CBeamSpotlight,
	ClassId_CBoneFollower,
	ClassId_CBRC4Target,
	ClassId_CBreachCharge,
	ClassId_CBreachChargeProjectile,
	ClassId_CBreakableProp,
	ClassId_CBreakableSurface,
	ClassId_CBumpMine,
	ClassId_CBumpMineProjectile,
	ClassId_CC4,
	ClassId_CCascadeLight,
	ClassId_CChicken,
	ClassId_CColorCorrection,
	ClassId_CColorCorrectionVolume,
	ClassId_CCSGameRulesProxy,
	ClassId_CCSPlayer,
	ClassId_CCSPlayerResource,
	ClassId_CCSRagdoll,
	ClassId_CCSTeam,
	ClassId_CDangerZone,
	ClassId_CDangerZoneController,
	ClassId_CDEagle,
	ClassId_CDecoyGrenade,
	ClassId_CDecoyProjectile,
	ClassId_CDrone,
	ClassId_CDronegun,
	ClassId_CDynamicLight,
	ClassId_CDynamicProp,
	ClassId_CEconEntity,
	ClassId_CEconWearable,
	ClassId_CEmbers,
	ClassId_CEntityDissolve,
	ClassId_CEntityFlame,
	ClassId_CEntityFreezing,
	ClassId_CEntityParticleTrail,
	ClassId_CEnvAmbientLight,
	ClassId_CEnvDetailController,
	ClassId_CEnvDOFController,
	ClassId_CEnvGasCanister,
	ClassId_CEnvParticleScript,
	ClassId_CEnvProjectedTexture,
	ClassId_CEnvQuadraticBeam,
	ClassId_CEnvScreenEffect,
	ClassId_CEnvScreenOverlay,
	ClassId_CEnvTonemapController,
	ClassId_CEnvWind,
	ClassId_CFEPlayerDecal,
	ClassId_CFireCrackerBlast,
	ClassId_CFireSmoke,
	ClassId_CFireTrail,
	ClassId_CFish,
	ClassId_CFists,
	ClassId_CFlashbang,
	ClassId_CFogController,
	ClassId_CFootstepControl,
	ClassId_CFunc_Dust,
	ClassId_CFunc_LOD,
	ClassId_CFuncAreaPortalWindow,
	ClassId_CFuncBrush,
	ClassId_CFuncConveyor,
	ClassId_CFuncLadder,
	ClassId_CFuncMonitor,
	ClassId_CFuncMoveLinear,
	ClassId_CFuncOccluder,
	ClassId_CFuncReflectiveGlass,
	ClassId_CFuncRotating,
	ClassId_CFuncSmokeVolume,
	ClassId_CFuncTrackTrain,
	ClassId_CGameRulesProxy,
	ClassId_CGrassBurn,
	ClassId_CHandleTest,
	ClassId_CHEGrenade,
	ClassId_CHostage,
	ClassId_CHostageCarriableProp,
	ClassId_CIncendiaryGrenade,
	ClassId_CInferno,
	ClassId_CInfoLadderDismount,
	ClassId_CInfoMapRegion,
	ClassId_CInfoOverlayAccessor,
	ClassId_CItem_Healthshot,
	ClassId_CItemCash,
	ClassId_CItemDogtags,
	ClassId_CKnife,
	ClassId_CKnifeGG,
	ClassId_CLightGlow,
	ClassId_CMaterialModifyControl,
	ClassId_CMelee,
	ClassId_CMolotovGrenade,
	ClassId_CMolotovProjectile,
	ClassId_CMovieDisplay,
	ClassId_CParadropChopper,
	ClassId_CParticleFire,
	ClassId_CParticlePerformanceMonitor,
	ClassId_CParticleSystem,
	ClassId_CPhysBox,
	ClassId_CPhysBoxMultiplayer,
	ClassId_CPhysicsProp,
	ClassId_CPhysicsPropMultiplayer,
	ClassId_CPhysMagnet,
	ClassId_CPhysPropAmmoBox,
	ClassId_CPhysPropLootCrate,
	ClassId_CPhysPropRadarJammer,
	ClassId_CPhysPropWeaponUpgrade,
	ClassId_CPlantedC4,
	ClassId_CPlasma,
	ClassId_CPlayerPing,
	ClassId_CPlayerResource,
	ClassId_CPointCamera,
	ClassId_CPointCommentaryNode,
	ClassId_CPointWorldText,
	ClassId_CPoseController,
	ClassId_CPostProcessController,
	ClassId_CPrecipitation,
	ClassId_CPrecipitationBlocker,
	ClassId_CPredictedViewModel,
	ClassId_CProp_Hallucination,
	ClassId_CPropCounter,
	ClassId_CPropDoorRotating,
	ClassId_CPropJeep,
	ClassId_CPropVehicleDriveable,
	ClassId_CRagdollManager,
	ClassId_CRagdollProp,
	ClassId_CRagdollPropAttached,
	ClassId_CRopeKeyframe,
	ClassId_CSCAR17,
	ClassId_CSceneEntity,
	ClassId_CSensorGrenade,
	ClassId_CSensorGrenadeProjectile,
	ClassId_CShadowControl,
	ClassId_CSlideshowDisplay,
	ClassId_CSmokeGrenade,
	ClassId_CSmokeGrenadeProjectile,
	ClassId_CSmokeStack,
	ClassId_CSnowball,
	ClassId_CSnowballPile,
	ClassId_CSnowballProjectile,
	ClassId_CSpatialEntity,
	ClassId_CSpotlightEnd,
	ClassId_CSprite,
	ClassId_CSpriteOriented,
	ClassId_CSpriteTrail,
	ClassId_CStatueProp,
	ClassId_CSteamJet,
	ClassId_CSun,
	ClassId_CSunlightShadowControl,
	ClassId_CSurvivalSpawnChopper,
	ClassId_CTablet,
	ClassId_CTeam,
	ClassId_CTeamplayRoundBasedRulesProxy,
	ClassId_CTEArmorRicochet,
	ClassId_CTEBaseBeam,
	ClassId_CTEBeamEntPoint,
	ClassId_CTEBeamEnts,
	ClassId_CTEBeamFollow,
	ClassId_CTEBeamLaser,
	ClassId_CTEBeamPoints,
	ClassId_CTEBeamRing,
	ClassId_CTEBeamRingPoint,
	ClassId_CTEBeamSpline,
	ClassId_CTEBloodSprite,
	ClassId_CTEBloodStream,
	ClassId_CTEBreakModel,
	ClassId_CTEBSPDecal,
	ClassId_CTEBubbles,
	ClassId_CTEBubbleTrail,
	ClassId_CTEClientProjectile,
	ClassId_CTEDecal,
	ClassId_CTEDust,
	ClassId_CTEDynamicLight,
	ClassId_CTEEffectDispatch,
	ClassId_CTEEnergySplash,
	ClassId_CTEExplosion,
	ClassId_CTEFireBullets,
	ClassId_CTEFizz,
	ClassId_CTEFootprintDecal,
	ClassId_CTEFoundryHelpers,
	ClassId_CTEGaussExplosion,
	ClassId_CTEGlowSprite,
	ClassId_CTEImpact,
	ClassId_CTEKillPlayerAttachments,
	ClassId_CTELargeFunnel,
	ClassId_CTEMetalSparks,
	ClassId_CTEMuzzleFlash,
	ClassId_CTEParticleSystem,
	ClassId_CTEPhysicsProp,
	ClassId_CTEPlantBomb,
	ClassId_CTEPlayerAnimEvent,
	ClassId_CTEPlayerDecal,
	ClassId_CTEProjectedDecal,
	ClassId_CTERadioIcon,
	ClassId_CTEShatterSurface,
	ClassId_CTEShowLine,
	ClassId_CTesla,
	ClassId_CTESmoke,
	ClassId_CTESparks,
	ClassId_CTESprite,
	ClassId_CTESpriteSpray,
	ClassId_CTest_ProxyToggle_Networkable,
	ClassId_CTestTraceline,
	ClassId_CTEWorldDecal,
	ClassId_CTriggerPlayerMovement,
	ClassId_CTriggerSoundOperator,
	ClassId_CVGuiScreen,
	ClassId_CVoteController,
	ClassId_CWaterBullet,
	ClassId_CWaterLODControl,
	ClassId_CWeaponAug,
	ClassId_CWeaponAWP,
	ClassId_CWeaponBaseItem,
	ClassId_CWeaponBizon,
	ClassId_CWeaponCSBase,
	ClassId_CWeaponCSBaseGun,
	ClassId_CWeaponCycler,
	ClassId_CWeaponElite,
	ClassId_CWeaponFamas,
	ClassId_CWeaponFiveSeven,
	ClassId_CWeaponG3SG1,
	ClassId_CWeaponGalil,
	ClassId_CWeaponGalilAR,
	ClassId_CWeaponGlock,
	ClassId_CWeaponHKP2000,
	ClassId_CWeaponM249,
	ClassId_CWeaponM3,
	ClassId_CWeaponM4A1,
	ClassId_CWeaponMAC10,
	ClassId_CWeaponMag7,
	ClassId_CWeaponMP5Navy,
	ClassId_CWeaponMP7,
	ClassId_CWeaponMP9,
	ClassId_CWeaponNegev,
	ClassId_CWeaponNOVA,
	ClassId_CWeaponP228,
	ClassId_CWeaponP250,
	ClassId_CWeaponP90,
	ClassId_CWeaponSawedoff,
	ClassId_CWeaponSCAR20,
	ClassId_CWeaponScout,
	ClassId_CWeaponSG550,
	ClassId_CWeaponSG552,
	ClassId_CWeaponSG556,
	ClassId_CWeaponShield,
	ClassId_CWeaponSSG08,
	ClassId_CWeaponTaser,
	ClassId_CWeaponTec9,
	ClassId_CWeaponTMP,
	ClassId_CWeaponUMP45,
	ClassId_CWeaponUSP,
	ClassId_CWeaponXM1014,
	ClassId_CWorld,
	ClassId_CWorldVguiText,
	ClassId_DustTrail,
	ClassId_MovieExplosion,
	ClassId_ParticleSmokeGrenade,
	ClassId_RocketTrail,
	ClassId_SmokeTrail,
	ClassId_SporeExplosion,
	ClassId_SporeTrail,
	MAX_CLASSID
};

enum PoseParam_t
{
	STRAFE_YAW,
	STAND,
	LEAN_YAW,
	SPEED,
	LADDER_YAW,
	LADDER_SPEED,
	JUMP_FALL,
	MOVE_YAW,
	MOVE_BLEND_CROUCH,
	MOVE_BLEND_WALK,
	MOVE_BLEND_RUN,
	BODY_YAW,
	BODY_PITCH,
	AIM_BLEND_STAND_IDLE,
	AIM_BLEND_STAND_WALK,
	AIM_BLEND_STAND_RUN,
	AIM_BLEND_COURCH_IDLE,
	AIM_BLEND_CROUCH_WALK,
	DEATH_YAW
};


enum resolver_modes
{
	RMODE_MOVING = 0,
	RMODE_DELTA,
	RMODE_SPIN,
	RMODE_WALL
};


/*
struct aim_data_t
{
	C_CSPlayer*	player;
	int			index;
};


struct visual_data_t
{
	C_CSPlayer*	player;
	bool		valid;
	int			index;
	float		fade_time;
	float		alpha;
	Vector		top;
	Vector		bot;
	float		width;
	float		height;
	bool was_unseen;
	bool oof;
	Vector pos;

	//extra
	float vel;
	int act;
	float l1_weight;
	float l1_cycle;
	bool dormant;
	float nextupdate;
	int maxclip;
	int clip;
	int armor;
	int health;
	bool scoped;
	bool reload;
	float ping;
	bool bomb;

	//record
	bool running_timer;
	int shots;
	bool fakewalking;
	std::string name;
	std::string weapon_name;
	std::string rmode;
};

struct world_data_t
{
	int classid;
	float alpha;
	Vector pos;
	std::string name;
	float explode_time;
	int clip;
	int maxclip;
	bool defusing;
	int32 defuser;
};


struct visual_world_data_t
{
	std::vector<world_data_t> world_data;
};

struct lag_record_t
{
	lag_record_t() = default;
	//lag_record_t(C_CSPlayer* player);
	//void apply(C_CSPlayer* player, bool backup = false) const;

	int index;
	bool valid;
	matrix3x4_t matrix[128];

	bool m_fake_walk;
	int m_mode;
	bool m_dormant;
	Vector m_velocity;
	Vector m_origin;
	Vector m_abs_origin;
	Vector m_anim_velocity;
	Vector m_obb_mins;
	Vector m_obb_maxs;
	std::array<C_AnimationLayer, 15> m_layers;
	std::array<float, 24> m_poses;
	float m_anim_time;
	float m_sim_time;
	float m_duck;
	float m_body;
	QAngle m_eye_angles;
	QAngle m_abs_ang;
	int m_flags;
	int m_lag;
	QAngle m_rotation;

	int m_cached_count;
	int m_writable_bones;

	bool m_lby_flick;
	bool m_shot;
	bool m_override;
};

struct dormant_record_t
{
	QAngle m_abs_ang;
	float m_flEyePitch; //0x74
	float m_flEyeYaw; //0x78
	float m_flPitch; //0x7C
	float m_flGoalFeetYaw; //0x80
	float m_flCurrentFeetYaw; //0x84
	float m_flCurrentTorsoYaw; //0x88
	float m_flLeanAmount; //0x90
	float m_flFeetCycle; //0x98 0 to 1
	float m_flFeetYawRate; //0x9C 0 to 1
};


struct player_log_t
{
	player_log_t()
	{
		player = nullptr;
		m_bCustomCorrection = false;
		m_bFilled = false;
		m_iPlayerListYawCorrection = 0;
		onground_nospread = false;
		m_bOverride = false;
		m_nShotsLby = 0;
		last_hit_bute = 0;
		m_iMode = 0;
		lastvalid = 0;
		lastvalid_vis = 0;
		spindelta = 0;
		spinbody = 0;
		step = 0;
	}
	C_CSPlayer*	player;
	bool m_bFilled;
	int m_iMode;

	float spindelta;
	float spinbody;
	int step;

	int lastvalid;
	int lastvalid_vis;

	float m_flSpawntime;

	float m_flLowerBodyYawTarget;
	float m_flOldLowerBodyYawTarget;
	float m_flLastLowerBodyYawTargetUpdateTime;
	float m_flLastMovingLowerBodyYawTarget;
	float m_flLastMovingLowerBodyYawTargetTime;
	float nextBodyUpdate;
	float m_flSavedLbyDelta;
	float m_flBruteStartLby;

	QAngle m_vecLastShotEyeAngles;
	float m_flLastShotSimulationTime;

	int m_iPlayerListYawCorrection;
	bool m_bCustomCorrection;
	float m_flPitch;

	float m_flProxyPitch;
	float m_flProxyYaw;

	bool onground_nospread;
	bool fakewalking;

	int m_nShots;
	int oldshots;
	int m_nShotsLby;

	bool m_bLbyFlick;
	bool m_bShot;
	bool m_bOverride;

	int last_hit_bute;

	bool m_bRunningTimer;
	Vector m_vecLastNonDormantOrig;

	std::deque<lag_record_t> record;
	dormant_record_t dormant_record;
	float last_dormant_time;
	Vector last_nondormant_origin;
};

enum material_index_t : int
{
	MAT_VISIBLE = 0,
	MAT_VISIBLE_FLAT,
	MAT_VISIBLE_SHINE,
	MAT_HID,
	MAT_HID_FLAT,
	MAT_HID_SHINE,
	MAT_RECORD,


	NUM_MATERIALS
};

struct FireBulletData
{
	Vector           src;
	trace_t          enter_trace;
	Vector           direction;
	ITraceFilter     filter;
	CCSWeaponData*  wpn_data;
	float           trace_length;
	float           trace_length_remaining;
	float           length_to_end;
	float           current_damage;
	int             penetrate_count;
};*/


```

`Lumina/Lumina/sdk/structs/trace_ray.h`:

```h
#pragma once

/*
class C_BaseEntity;
class IHandleEntity;
class VectorAligned : public Vector
{
public:
	VectorAligned() {}

	VectorAligned( const Vector &vec )
	{
		this->x = vec.x;
		this->y = vec.y;
		this->z = vec.z;
	}

	float w;
};

enum TraceType_t
{
	TRACE_EVERYTHING = 0,
	TRACE_WORLD_ONLY,				// NOTE: This does *not* test static props!!!
	TRACE_ENTITIES_ONLY,			// NOTE: This version will *not* test static props
	TRACE_EVERYTHING_FILTER_PROPS,	// NOTE: This version will pass the IHandleEntity for props through the filter, unlike all other filters
};

struct Ray_t
{
	Ray_t() {}

	VectorAligned		m_Start;
	VectorAligned		m_dt;
	VectorAligned		m_StartOffset;
	VectorAligned		m_Extents;
	const matrix3x4_t	*m_pWorldAxisTransform;
	bool				m_IsRay;
	bool				m_IsSwept;

	void Init( Vector vecStart, Vector vecEnd )
	{
		m_dt = VectorAligned( vecEnd - vecStart );
		m_IsSwept = ( m_dt.LengthSqr() != 0 );
		m_Extents.Zero();
		m_pWorldAxisTransform = NULL;
		m_IsRay = true;
		m_StartOffset.Zero();
		m_Start = vecStart;
	}
	void Init( Vector vecStart, Vector vecEnd, const Vector & extents )
	{
		m_dt = VectorAligned( vecEnd - vecStart );
		m_IsSwept = ( m_dt.LengthSqr() != 0 );
		m_Extents = extents;
		m_pWorldAxisTransform = NULL;
		m_IsRay = false;
		m_StartOffset.Zero();
		m_Start = vecStart;
	}
	void Init( Vector const& start, Vector const& end, Vector const& mins, Vector const& maxs )
	{
		m_dt = end - start;

		m_pWorldAxisTransform = NULL;
		m_IsSwept = ( m_dt.LengthSqr() != 0 );

		m_Extents = maxs - mins;
		m_Extents *= 0.5f;
		m_IsRay = ( m_Extents.LengthSqr() < 1e-6 );

		// Offset m_Start to be in the center of the box...
		m_StartOffset = maxs + mins;
		m_StartOffset *= 0.5f;
		m_Start = start + m_StartOffset;
		m_StartOffset *= -1.0f;
	}
};

struct cplane_t
{
	Vector	normal;
	float	dist;
	byte	type;
	byte	signbits;
	byte	pad[ 2 ];
};

class ITraceFilter
{
public:
	virtual bool ShouldHitEntity( C_BaseEntity* pEntityHandle, int contentsMask )
	{
		return !( pEntityHandle == pSkip );
	}
	virtual TraceType_t	GetTraceType()
	{
		return TRACE_EVERYTHING;
	}
	void* pSkip;
};

class CTraceFilter : public ITraceFilter
{
public:
	CTraceFilter() = default;
	explicit CTraceFilter( C_BaseEntity* entity, TraceType_t tracetype = TRACE_EVERYTHING )
	{
		pSkip = entity;
		type = tracetype;
	}
	virtual bool ShouldHitEntity( C_BaseEntity* pEntityHandle, int contentsMask )
	{
		return !( pEntityHandle == pSkip );
	}

	virtual TraceType_t	GetTraceType() const
	{
		return type;
	}
	void* pSkip;
	TraceType_t type = TRACE_EVERYTHING;
};

class CTraceFilterSkipTwoEntities : public ITraceFilter
{
public:
	CTraceFilterSkipTwoEntities() {}
	CTraceFilterSkipTwoEntities( void *pPassEnt1, void *pPassEnt2 )
	{
		pPassEntity1 = pPassEnt1;
		pPassEntity2 = pPassEnt2;
	}

	virtual bool ShouldHitEntity( C_BaseEntity *pEntityHandle, int contentsMask )
	{
		return !( pEntityHandle == pPassEntity1 || pEntityHandle == pPassEntity2 );
	}

	virtual TraceType_t GetTraceType() const
	{
		return TRACE_EVERYTHING;
	}

	void *pPassEntity1;
	void *pPassEntity2;
};

typedef bool( *ShouldHitFunc_t )( IHandleEntity *pHandleEntity, int contentsMask );

class CTraceFilterSimple : public CTraceFilter
{
public:
	// It does have a base, but we'll never network anything below here..
	CTraceFilterSimple( const IHandleEntity *passentity, int collisionGroup, ShouldHitFunc_t pExtraShouldHitCheckFn = NULL );
	virtual bool ShouldHitEntity( IHandleEntity *pHandleEntity, int contentsMask );
	virtual void SetPassEntity( const IHandleEntity *pPassEntity ) { m_pPassEnt = pPassEntity; }
	virtual void SetCollisionGroup( int iCollisionGroup ) { m_collisionGroup = iCollisionGroup; }

	const IHandleEntity *GetPassEntity( void ) { return m_pPassEnt; }

private:
	const IHandleEntity *m_pPassEnt;
	int m_collisionGroup;
	ShouldHitFunc_t m_pExtraShouldHitCheckFunction;

};

class CBaseTrace
{
public:
	Vector			startpos;
	Vector			endpos;
	cplane_t		plane;

	float			fraction;

	int				contents;
	unsigned short	dispFlags;

	bool			allsolid;
	bool			startsolid;

	CBaseTrace() {}
};

struct csurface_t
{
	const char*		name;
	short			surfaceProps;
	unsigned short	flags;
};

class CTraceFilterWorldOnly : public ITraceFilter
{
public:
	virtual bool ShouldHitEntity( IHandleEntity *pServerEntity, int contentsMask )
	{
		return false;
	}
	virtual TraceType_t	GetTraceType() const
	{
		return TRACE_WORLD_ONLY;
	}
};

class IClientUnknown;
class IClientEntity;
class CTraceFilterNoPlayers : public CTraceFilter
{
public:
	CTraceFilterNoPlayers() {}
	virtual bool ShouldHitEntity( C_BaseEntity* pEntityHandle, int contentsMask ) override
	{
		return false;
	}
};

class CGameTrace : public CBaseTrace
{
public:
	bool                    DidHitWorld() const
	{
		return m_pEnt == (C_BaseEntity*)g_pEntitiyList->GetClientEntity( 0 );
	}
	bool                    DidHitNonWorldEntity() const
	{
		return m_pEnt != NULL && !DidHitWorld();
	}
	int                     GetEntityIndex() const;
	bool                    DidHit() const { return fraction < 1 || allsolid || startsolid; };
	bool					BoneIsVisible() const;

public:

	float                   fractionleftsolid;
	csurface_t              surface;
	int                     hitgroup;
	short                   physicsbone;
	unsigned short          worldSurfaceIndex;
	C_BaseEntity*           m_pEnt;
	int                     hitbox;

	CGameTrace() {}

public:
	CGameTrace( const CGameTrace& vOther )
	{
		fractionleftsolid = vOther.fractionleftsolid;
		surface = vOther.surface;
		hitgroup = vOther.hitgroup;
		physicsbone = vOther.physicsbone;
		worldSurfaceIndex = vOther.worldSurfaceIndex;
		m_pEnt = vOther.m_pEnt;
		hitbox = vOther.hitbox;
		startpos = vOther.startpos;
		endpos = vOther.endpos;
		plane = vOther.plane;
		fraction = vOther.fraction;
		contents = vOther.contents;
		dispFlags = vOther.dispFlags;
		allsolid = vOther.allsolid;
		startsolid = vOther.startsolid;
	}
};

typedef CGameTrace trace_t;*/

```

`Lumina/Lumina/security/eraser.hpp`:

```hpp
#pragma once

inline uint8_t* find_sig_ext(uint32_t offset, const char* signature, uint32_t range = 0u)
{
	static auto pattern_to_bytes = [](const char* pattern) -> std::vector<int>
	{
		auto bytes = std::vector<int32_t>{};
		auto start = const_cast<char*>(pattern);
		auto end = const_cast<char*>(pattern) + strlen(pattern);

		for (auto current = start; current < end; ++current)
		{
			if (*current == '?')
			{
				current++;

				if (*current == '?')
					current++;

				bytes.push_back(-1);
			}
			else
				bytes.push_back(static_cast<int32_t>(strtoul(current, &current, 0x10)));
		}

		return bytes;
	};

	const auto scan_bytes = reinterpret_cast<std::uint8_t*>(offset);
	auto pattern_bytes = pattern_to_bytes(signature);
	const auto s = pattern_bytes.size();
	const auto d = pattern_bytes.data();

	for (auto i = 0ul; i < range - s; ++i)
	{
		auto found = true;

		for (auto j = 0ul; j < s; ++j)
			if (scan_bytes[i + j] != d[j] && d[j] != -1)
			{
				found = false;
				break;
			}

		if (found)
			return &scan_bytes[i];
	}

	return nullptr;
}

__forceinline void erase_function(uint8_t* function)
{
	if (*function == 0xE9)
	{
		auto pdFollow = (PDWORD)(function + 1);
		function = ((PBYTE)(*pdFollow + (DWORD)function + 5));
	}
	else if (*function == 0xEB)
	{
		auto pbFollow = (PDWORD)(function + 1);
		function = ((PBYTE)((DWORD)*pbFollow + (DWORD)function + 2));
	}

	static const auto current_process = reinterpret_cast<HANDLE>(-1);

	const auto end = find_sig_ext(reinterpret_cast<uint32_t>(function), XorStr("90 90 90 90 90"), 0x2000);
	
	size_t bytes = reinterpret_cast<DWORD>(end) - reinterpret_cast<DWORD>(function) + 6;

	void* fn = function;
	size_t size = bytes;
	DWORD old;

	LI_FN(VirtualProtect).get()(fn, size, PAGE_EXECUTE_READWRITE, &old);

	fn = function;
	size = bytes;
	memset(fn, 0, size);

	LI_FN(VirtualProtect).get()(fn, size, old, &old);
}

// NOLINTNEXTLINE
#define erase_fn(a) constexpr auto concat(w, __LINE__) = &a;\
    erase_function(reinterpret_cast<uint8_t*>((void*&)concat(w, __LINE__)))

#define erase_end  __asm _emit 0x90 __asm _emit 0x90 __asm _emit 0x90 __asm _emit 0x90 __asm _emit 0x90 

#define BLOCK_0 __asm __emit 0xB0 __asm __emit 0x0B __asm __emit 0xF0 __asm __emit 0xB0 __asm __emit 0x0B __asm __emit 0xF0 __asm __emit 0xB0 __asm __emit 0xBE __asm __emit 0xEF __asm __emit 0xDE __asm __emit 0xAD __asm __emit 0x01 __asm __emit 0xDE __asm __emit 0xAD
#define JUNK_0(a) __asm jmp a BLOCK_0 \
```

`Lumina/Lumina/security/hash.h`:

```h
#pragma once

// from pandoracheats.pw

// todo - dex; check arg type for macros?

// hash type.
using hash32_t = uint32_t;

// compile-time hash.
#define HASH( str )                                     \
    []() {                                              \
        constexpr hash32_t out{ FNV1a::get( str ) };    \
                                                        \
        return out;                                     \
    }()

// compile-time const hash.
#define CONST_HASH( str ) FNV1a::get( str )

class FNV1a {
private:
    // fnv1a constants.
    enum : uint32_t {
        PRIME = 0x1000193u,
        BASIS = 0x811C9DC5u
    };

    // compile-time strlen.
    // todo - dex; move this?
    static __forceinline constexpr size_t ct_strlen(const char* str, bool include_nullchar = false) {
        size_t out{};

        // count number of characters.
        while (str[++out] != '\0');

        // add one for null character if desired.
        if (include_nullchar)
            ++out;

        return out;
    }

public:
    // hash data ( compile-time or run-time ).
    static __forceinline constexpr hash32_t get(const uint8_t* data, const size_t len) {
        hash32_t out{ BASIS };

        for (size_t i{}; i < len; ++i)
            out = (out ^ data[i]) * PRIME;

        return out;
    }

    // hash c-style string ( compile-time or run-time ).
    static __forceinline constexpr hash32_t get(const char* str) {
        hash32_t out{ BASIS };
        size_t   len{ ct_strlen(str) };

        for (size_t i{}; i < len; ++i)
            out = (out ^ str[i]) * PRIME;

        return out;
    }

    // hash c++-style string ( run-time only ).
    static __forceinline hash32_t get(const std::string& str) {
        return get((uint8_t*)str.c_str(), str.size());
    }
};
```

`Lumina/Lumina/security/instr.h`:

```h
/*
 * Copyright (c) 2016, Ferenc Deak
 *
 * Permission is hereby granted, free of charge, to any person obtaining
 * a copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
 * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
 * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
 * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 **/

#ifndef INSTR_H
#define INSTR_H

#include <string>
#include <typeinfo>

#include <memory>
#include <random>
#include <vector>
#include <type_traits>
#include <utility>

#ifndef MAX_BOGUS_IMPLEMENTATIONS
#define MAX_BOGUS_IMPLEMENTATIONS 3
#endif

namespace obf
{

// Compile time random number generator from https://github.com/andrivet/ADVobfuscator
/*
 * Written by Sebastien Andrivet
 * Copyright (c) 2010-2015 - Sebastien Andrivet All rights reserved.
 * Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:
 * 1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the copyright holder nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission.
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
constexpr char time[] = __TIME__;
constexpr int DigitToInt(char c) { return c - '0'; }
const int seed = DigitToInt(time[7]) +
                 DigitToInt(time[6]) * 10 +
                 DigitToInt(time[4]) * 60 +
                 DigitToInt(time[3]) * 600 +
                 DigitToInt(time[1]) * 3600 +
                 DigitToInt(time[0]) * 36000;

template<int N>
struct MetaRandomGenerator final
{
private:
    static constexpr unsigned a = 16807;
    static constexpr unsigned m = 2147483647;
    static constexpr unsigned s = MetaRandomGenerator<N - 1>::value;
    static constexpr unsigned lo = a * (s & 0xFFFF);
    static constexpr unsigned hi = a * (s >> 16);
    static constexpr unsigned lo2 = lo + ((hi & 0x7FFF) << 16);
    static constexpr unsigned hi2 = hi >> 15;
    static constexpr unsigned lo3 = lo2 + hi;

public:
    static constexpr unsigned max = m;
    static constexpr unsigned value = lo3 > m ? lo3 - m : lo3;
};

template<>
struct MetaRandomGenerator<0> final
{
    static constexpr unsigned value = seed;
};

template<int N, int M>
struct MetaRandom final
{
    static const int value = MetaRandomGenerator<N + 1>::value % M;
};

#define COMP_ASSIGNMENT_OPERATOR(x) \
    refholder<T>& operator x##= (const refholder<T>& ov) { v x##= ov.v; return *this;}  \
    refholder<T>& operator x##= (const refholder<T>&& ov) { v x##= ov.v; return *this;} \
    refholder<T>& operator x##= (const T& ov) { v x##= ov; return *this;}               \
    refholder<T>& operator x##= (const T&& ov) { v x##= ov; return *this;}              \
    refholder<T>& operator x##= (T& ov) { v x##= ov; return *this;}


#define COMPARISON_OPERATOR(x) \
    bool operator x (const T& ov) { return (v x ov); }

/* simple reference holder class, mostly for dealing with holding variables */
template <typename T>
class refholder final
{
public:
    /* Construction, destruction */
    refholder() = delete;
    refholder(T& pv) : v(pv) {}
    refholder(const refholder& ov) : v(ov.v) {}
    refholder(T&&) = delete;

    ~refholder() = default;

    /* Assignment */
    refholder<T>& operator = (const T& ov) { v = ov; return *this;}
    refholder<T>& operator = (const refholder<T>& ov ) { v = ov.v; return *this; }

    /* Comparison */
    bool operator == (const T& ov) { return !(v ^ ov); }
    bool operator != (const T& ov) { return !operator ==(ov); }
    COMPARISON_OPERATOR(>=)
    COMPARISON_OPERATOR(<=)
    COMPARISON_OPERATOR(>)
    COMPARISON_OPERATOR(<)

    /* Conversion to the real type */
    operator T() {return v;}

    /* Pre increment/decrement operators */
    refholder<T>& operator++() { ++ v; return *this; }
    refholder<T>& operator--() { -- v; return *this; }

    /* post increment/decrement */
    refholder<T> operator++(int) { refholder<T> rv(*this); operator ++(); return rv; }
    refholder<T> operator--(int) { refholder<T> rv(*this); operator --(); return rv; }

    /* Compound assignments */
    COMP_ASSIGNMENT_OPERATOR(+)
    COMP_ASSIGNMENT_OPERATOR(-)
    COMP_ASSIGNMENT_OPERATOR(*)
    COMP_ASSIGNMENT_OPERATOR(/)
    COMP_ASSIGNMENT_OPERATOR(%)
    COMP_ASSIGNMENT_OPERATOR(<<)
    COMP_ASSIGNMENT_OPERATOR(>>)
    COMP_ASSIGNMENT_OPERATOR(&)
    COMP_ASSIGNMENT_OPERATOR(|)
    COMP_ASSIGNMENT_OPERATOR(^)

private:

    /* The root of all evil */
    volatile T& v;
};

/* simple reference holder class, for holding reference of constant variables */
template <typename T>
class refholder <const T> final
{
public:
    /* Construction, destruction */
    refholder() = delete;
    refholder(const T& pv) : v(pv) {}
    refholder(T&&) = delete;

    ~refholder() = default;

    /* Conversion to the real type */
    operator const T() {return v;}

private:

    /* The root of all evil */
    const T& v;
};

/* Binary operators for the value wrappers */
#define DEFINE_BINARY_OPERATOR(x) \
template <class T> refholder<T> operator x (refholder<T>& ls, const T& rs) {refholder<T> rv = ls; ls x##= rs; return rv; } \
template <class T> refholder<T> operator x (refholder<T>& ls, T& rs) {refholder<T> rv = ls; ls x##= rs; return rv; } \
template <class T> refholder<T> operator x (refholder<T>& ls, T&& rs) {refholder<T> rv = ls; ls x##= rs; return rv; } \
template <class T> refholder<T> operator x (refholder<T>& ls, const T&& rs) {refholder<T> rv = ls; ls x##= rs; return rv; } \
template <class T> refholder<T> operator x (refholder<T>& ls, const refholder<T>&& rs) {refholder<T> rv = ls; ls x##= rs; return rv; } \
template <class T> refholder<T> operator x (refholder<T>& ls, refholder<T>&& rs) {refholder<T> rv = ls; ls x##= rs; return rv; } \
template <class T> refholder<T> operator x (refholder<T>& ls, refholder<T>& rs) {refholder<T> rv = ls; ls x##= rs; return rv; } \
template <class T> refholder<T> operator x (refholder<T>& ls, const refholder<T>& rs) {refholder<T> rv = ls; ls x##= rs; return rv; }

DEFINE_BINARY_OPERATOR(+)
DEFINE_BINARY_OPERATOR(-)
DEFINE_BINARY_OPERATOR(*)
DEFINE_BINARY_OPERATOR(/)
DEFINE_BINARY_OPERATOR(%)
DEFINE_BINARY_OPERATOR(&)
DEFINE_BINARY_OPERATOR(|)
DEFINE_BINARY_OPERATOR(<<)
DEFINE_BINARY_OPERATOR(>>)
DEFINE_BINARY_OPERATOR(^)


/* Helping stuff */

struct base_rvholder
{
    virtual ~base_rvholder() = default;

    template<class T>
    operator T () const
    {
        return *reinterpret_cast<const T*>(get());
    }

    template<class T>
    bool operator == (const T& o) const
    {
        return o == operator T ();
    }

    template<class T>
    bool equals(const T& o) const
    {
        return o == *reinterpret_cast<const T*>(get());
    }

    virtual const void* get() const = 0;
};

template<class T>
class rvholder : public base_rvholder
{
public:
    rvholder(T t, T c) :base_rvholder(), v(t), check(c) {}
    ~rvholder() = default;
    virtual const void* get() const override {return reinterpret_cast<const void*>(&v);}
private:
    T v;
    T check;
};


/* what the RETURN/BREAK/CONTINUE will return while running from inside a loop block*/
enum class next_step
{
    ns_break,
    ns_continue,
    ns_return,
    ns_done,
    ns_unused
};

struct next_step_functor_base
{
    virtual ~next_step_functor_base() = default;
    virtual next_step run() = 0;
};

template <class T>
struct next_step_functor final : public next_step_functor_base
{
    next_step_functor(T r) : runner(r) {}
    virtual next_step run() {return runner();}

private:
    T runner;
};

struct bool_functor_base
{
    virtual ~bool_functor_base() = default;
    virtual bool run() = 0;
};

template <class T>
struct bool_functor final : public bool_functor_base
{
    bool_functor(T r) : runner(r) {}
    virtual bool run() {return runner();}

private:
    T runner;
};

struct any_functor_base
{
    virtual ~any_functor_base() = default;
    virtual void run(void*) const = 0;
};

template <class T>
struct any_functor final : public any_functor_base
{
    any_functor(T r) : runner(r) {}

    virtual void run(void* retv) const override
    {
        auto r = runner();
        *reinterpret_cast<decltype(r)*>(retv) = r;
    }


private:
    T runner;

};

/* c++ control structures implementation */

/* supporting implementation for the REPEAT/AS_LONG_AS macros*/

class repeat_wrapper final
{
public:
    repeat_wrapper():body(nullptr), condition(nullptr) {}

    void run()
    {
        do
        {
            try
            {
                body->run();
            }
            catch(next_step& c)
            {
                if(c == next_step::ns_break) break;
                if(c == next_step::ns_continue) continue;
            }
        }
        while( condition->run() );
    }

    template<class T>
    repeat_wrapper& set_body(T lambda) { body.reset(new next_step_functor<T>(lambda)); return *this; }


    template<class T>
    repeat_wrapper& set_condition(T lambda) { condition.reset(new bool_functor<T>(lambda)); return *this; }

private:

    std::unique_ptr<next_step_functor_base> body;
    std::unique_ptr<bool_functor_base> condition;
};

/* supporting implementation for the FOR macro */

class for_wrapper final
{
public:

    template<class INIT, class COND, class INCR>
    explicit for_wrapper(INIT lambda_init, COND lambda_cond, INCR lambda_incr)
    {
        condition.reset(new bool_functor<COND>(lambda_cond));
        initializer.reset(new next_step_functor<INIT>(lambda_init));
        increment.reset(new next_step_functor<INCR>(lambda_incr));
    }

    void run()
    {
        for( initializer->run(); condition->run(); increment->run())
        {
            try
            {
                body->run();
            }
            catch(next_step& c)
            {
                if(c == next_step::ns_break) break;
                if(c == next_step::ns_continue) continue;
            }
        }
    }

    ~for_wrapper() noexcept = default;

    template<class T>
    for_wrapper& set_body(T lambda) { body.reset(new next_step_functor<T>(lambda)); return *this; }
private:
    std::unique_ptr<next_step_functor_base> initializer;
    std::unique_ptr<bool_functor_base> condition;
    std::unique_ptr<next_step_functor_base> increment;
    std::unique_ptr<next_step_functor_base> body;

};

/* supporting implementation for the WHILE macro */

class while_wrapper final
{
public:
    template<class T>
    explicit while_wrapper(T lambda) :body(nullptr), condition(nullptr)
    {condition.reset(new bool_functor<T>(lambda));}

    void run()
    {
        while( condition->run() )
        {
            try
            {
                body->run();
            }
            catch(next_step& c)
            {
                if(c == next_step::ns_break) break;
                if(c == next_step::ns_continue) continue;
            }
        }
    }

    ~while_wrapper() noexcept = default;

    template<class T>
    while_wrapper& set_body(T lambda) { body.reset(new next_step_functor<T>(lambda)); return *this; }

private:
    std::unique_ptr<next_step_functor_base> body;
    std::unique_ptr<bool_functor_base> condition;
};

/* supporting implementation for the IF macro */

class if_wrapper final
{
public:
    template<class T>
    if_wrapper(T lambda) {condition.reset(new bool_functor<T>(lambda));}

    void run()
    {
        if(condition->run()) { if(thens) {
            thens->run();
        }}
        else { if(elses) {
            elses->run();
        }}

    }

    ~if_wrapper() noexcept = default;

    template<class T>
    if_wrapper& set_then(T lambda) { thens.reset(new next_step_functor<T>(lambda)); return *this; }
    template<class T>
    if_wrapper& set_else(T lambda) { elses.reset(new next_step_functor<T>(lambda)); return *this; }

private:
    std::unique_ptr<bool_functor_base> condition;
    std::unique_ptr<next_step_functor_base> thens;
    std::unique_ptr<next_step_functor_base> elses;
};

/* select ... case helper */

class case_instruction
{
public:
    case_instruction() = default;
    virtual ~case_instruction() = default;
    virtual next_step execute(const base_rvholder&) const = 0;
};

template<class CT>
class branch final : public case_instruction
{
public:
    template<class T>
    branch(T lambda) {condition.reset(new any_functor<T>(lambda));}

    bool equals(const base_rvholder& rv, CT lv) const
    {
        return rv.equals(lv);
    }

    virtual next_step execute(const base_rvholder& against) const override
    {
        CT retv;
        condition->run( const_cast<void*>(reinterpret_cast<const void*>(&retv) ) );
        // this looks funny, however we cannot use the operator ==
        // due to a visual C++ 2015 compiler bug, which fails to compile and crashes
        return equals(against,retv) ? next_step::ns_done : next_step::ns_continue;
    }

private:
    std::unique_ptr<any_functor_base> condition;
};

class body final : public case_instruction
{
public:
    template<class T>
    body(T lambda) {instructions.reset(new next_step_functor<T>(lambda));}


    virtual next_step execute(const base_rvholder&) const override
    {
        return instructions->run();
    }
private:
    std::unique_ptr<next_step_functor_base> instructions;
};

template <class CT>
class case_wrapper_base
{
public:
    explicit case_wrapper_base(const CT& v) : check(v), default_step(nullptr) {}


    case_wrapper_base& add_entry(const case_instruction& lambda_holder)
    {
        steps.push_back(&lambda_holder);
        return *this;
    }

    case_wrapper_base& add_default(const case_instruction& lambda_holder)
    {
        default_step = &lambda_holder;
        return *this;
    }

    case_wrapper_base& join()
    {
        return *this;
    }

    void run() const
    {
        auto it = steps.begin();
        while(it != steps.end())
        {
            bool increased = false;
            // see if this is a branch
            if(dynamic_cast<const branch<CT>*>(*it) || dynamic_cast<const branch<const CT>*>(*it))
            {
                // branch. Execute it, see if it returns true or false
                next_step enter = (*it)->execute(rvholder<CT>(check,check));
                if(enter == next_step::ns_continue)
                {
                    // step to the next branch
                    ++it;
                    increased = true;
                }
                else
                {
                    // now fast forward and find the first body,
                    // and from that point on run all the bodies, unless one of them breaks
                    while(! dynamic_cast<const body*>(*it)  && it != steps.end() )
                    {
                        ++it;
                        increased = true;
                    }

                    // found the first body.
                    while(it != steps.end())
                    {
                        if(dynamic_cast<const body*>(*it))
                        {
                            (*it)->execute(rvholder<CT>(check,check));
                        }
                        increased = true;
                        ++it;
                    }
                }
            }
            else if(dynamic_cast<const body*>(*it))
            {
                // skip body
            }
            else
            {
                throw(std::string("invalid type:") + typeid(*it).name());
            }

            // just for safety
            if(!increased)
            {
                ++it;
            }
        }

        if(default_step)
        {
            default_step->execute(rvholder<CT>(check,check));
        }
    }

private:

    std::vector<const case_instruction*> steps;
    const CT check;
    const case_instruction* default_step;
};

template<class CT>
class case_wrapper final : public case_wrapper_base<CT>
{
public:
    explicit case_wrapper(const CT& v) : case_wrapper_base<CT>(v) {}
};


template<class CT>
class case_wrapper <const CT> final : public case_wrapper_base<CT>
{
public:
    explicit case_wrapper(const CT& v) : case_wrapper_base<CT>(v) {}
};

/* syntactic sugar */

class stream_helper {};
template <typename T>
refholder<T> operator << (stream_helper, T& a)
{
    return refholder<T>(a);
}

/* The bogus operations allowed */
class basic_extra
{
public:
    basic_extra() = default;
    ~basic_extra() = default;
    basic_extra(const basic_extra&) = delete;
    basic_extra& operator = (const basic_extra&) = delete;
    basic_extra(const basic_extra&&) = delete;
    basic_extra& operator = (const basic_extra&&) = delete;
};

template <class T>
class extra_xor final : public basic_extra
{
public:
    extra_xor(T& a) : v(a)
    {
		volatile T lv = MetaRandom<__COUNTER__, 4096>::value;
        v ^= lv;
    }
    virtual ~extra_xor()
	{
		volatile T lv = MetaRandom<__COUNTER__ - 1, 4096>::value;
		v ^= lv;
	}

private:
    volatile T& v;
};

template <class T>
class extra_xor <const T> final : public basic_extra
{
public:
    extra_xor(const T&) {}
};

template <class T>
class extra_addition final : public basic_extra
{
public:
    extra_addition(T& a) : v(a)
	{
		volatile T lv = MetaRandom<__COUNTER__, 4096>::value;
		v += lv;
	}
    virtual ~extra_addition()
	{
		volatile T lv = MetaRandom<__COUNTER__ - 1, 4096>::value;
		v -= lv;
	}
private:
    volatile T& v;
};

template <class T>
class extra_addition <const T> final: public basic_extra
{
public:
    extra_addition(const T&) {}
};

template <class T>
class extra_substraction final : public basic_extra
{
public:
    extra_substraction(T& a) : v(a) {v -= MetaRandom<__COUNTER__, 4096>::value; }
    virtual ~extra_substraction() { v += MetaRandom<__COUNTER__ - 1, 4096>::value; }

private:
    volatile T& v;
};

template <class T>
class extra_substraction <const T> final : public basic_extra
{
public:
    extra_substraction(const T&) {}
};

template <typename T, int N>
class extra_chooser final
{
    using type=basic_extra; // intentionally private
};

/* Constant obfuscation implementer */

template<typename T, T n> class Num final
{
public:
    enum { value = ( (n & 0x01)  | ( Num < T , (n >> 1)>::value << 1) ), int64_forcer = 0xffffffffffffffffULL };
    Num() : v(0)
    {
        v = value ^  MetaRandom<32, 4096>::value;
    }
    T get() const { T x = v ^ MetaRandom<32, 4096>::value; return x;}
private:
    volatile T v;
};

struct ObfZero { enum {value = 0}; };
struct ObfOne { enum {value = 1}; };
#define OBF_ZERO(t) template <> struct Num<t,0> final : public ObfZero { t v = value; };
#define OBF_ONE(t) template <> struct Num<t,1> final : public ObfOne { t v = value; };
#define OBF_TYPE(t) OBF_ZERO(t) OBF_ONE(t)

OBF_TYPE(bool)

OBF_TYPE(char)
OBF_TYPE(signed char)
OBF_TYPE(unsigned char)
OBF_TYPE(char16_t)
OBF_TYPE(char32_t)
OBF_TYPE(wchar_t)

OBF_TYPE(short int)
OBF_TYPE(unsigned short int)

OBF_TYPE(int)
OBF_TYPE(unsigned int)

OBF_TYPE(long int)
OBF_TYPE(unsigned long int)

OBF_TYPE(long long int)
OBF_TYPE(unsigned long long int)

#if defined OBF_DEBUG

#define OBF_BEGIN
#define OBF_END

#define V(x) x
#define N(x) x

#define RETURN(x) return x;

#define BREAK break;
#define CONTINUE continue;

#define IF(x) if(x) {
#define ELSE } else {
#define ENDIF }

#define FOR(init,cond,inc) for(init;cond;inc) {
#define ENDFOR }

#define WHILE(x) while(x) {
#define ENDWHILE }

#define REPEAT   do {
#define AS_LONG_AS(x) } while ((x));

#define CASE(a) switch (a) {
#define ENDCASE }
#define WHEN(c) case c:
#define DO {
#define DONE }
#define OR
#define DEFAULT default:



#else
#define _JOIN(a,b) a##b
#define N(a) (obf::Num<decltype(a), obf::MetaRandom<__COUNTER__, 4096>::value ^ a>().get() ^ obf::MetaRandom<__COUNTER__ - 1, 4096>::value)
#define DEFINE_EXTRA(N,implementer) template <typename T> struct extra_chooser<T,N> { using type = implementer<T>; }
DEFINE_EXTRA(0, extra_xor);
DEFINE_EXTRA(1, extra_substraction);
DEFINE_EXTRA(2, extra_addition);
#define V(a) ([&](){obf::extra_chooser<std::remove_reference<decltype(a)>::type, obf::MetaRandom<__COUNTER__, \
            MAX_BOGUS_IMPLEMENTATIONS>::value >::type _JOIN(_ec_,__COUNTER__)(a);\
            return obf::stream_helper();}() << a)

#define FOR(init,cond,inc) { std::shared_ptr<obf::base_rvholder> __rvlocal; obf::for_wrapper( [&](){(init); return __crv; },\
           [&]()->bool{return (cond); }, \
           [&](){inc;return __crv;}).set_body( [&]() {
#define ENDFOR return __crv;}).run(); }

#define END return __crv;}).run(); }

#define IF(x) {std::shared_ptr<obf::base_rvholder> __rvlocal; obf::if_wrapper(( [&]()->bool{ return (x); })).set_then( [&]() {
#define ELSE return __crv;}).set_else( [&]() {
#define ENDIF END

#define WHILE(x) {std::shared_ptr<obf::base_rvholder> __rvlocal; obf::while_wrapper([&]()->bool{ return (x); }).set_body( [&]() {
#define ENDWHILE END

#define BREAK __crv = obf::next_step::ns_break; throw __crv;
#define CONTINUE __crv = obf::next_step::ns_continue; throw __crv;

#define RETURN(x) __rvlocal.reset(new obf::rvholder<std::remove_reference<decltype(x)>::type>(x,x));  throw __rvlocal;

#define REPEAT { std::shared_ptr<obf::base_rvholder> __rvlocal; obf::repeat_wrapper().set_body( [&]() {
#define AS_LONG_AS(x) return __crv;}).set_condition([&]()->bool{ return ( (x) ); }).run(); }

#define OBF_BEGIN try { obf::next_step __crv = obf::next_step::ns_done; std::shared_ptr<obf::base_rvholder> __rvlocal; (void)__crv;
#define OBF_END } catch(std::shared_ptr<obf::base_rvholder>& r) { return *r; } catch (...) {throw;}

#define CASE(a) try { std::shared_ptr<obf::base_rvholder> __rvlocal;\
                auto __avholder = a; obf::case_wrapper<std::remove_reference<decltype(a)>::type>(a).
#define ENDCASE run(); } catch(obf::next_step&) {}
#define WHEN(c) add_entry(obf::branch<std::remove_reference<decltype(__avholder)>::type>\
                ( [&,__avholder]() -> std::remove_reference<decltype(__avholder)>::type \
                { std::remove_reference<decltype(__avholder)>::type __c = (c); return __c;} )).
#define DO add_entry( obf::body([&](){
#define DONE return obf::next_step::ns_continue;})).
#define OR join().
#define DEFAULT add_default(obf::body([&](){

#endif

} // namespace obf

#endif // INSTR_H

```

`Lumina/Lumina/security/lazy.hpp`:

```hpp
/*
 * Copyright 2018 Justas Masiulis
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

 // documentation is available at https://github.com/JustasMasiulis/lazy_importer

#ifndef LAZY_IMPORTER_HPP
#define LAZY_IMPORTER_HPP

#define LI_FN(name) \
    ::li::detail::lazy_function<::li::detail::khash(#name), decltype(&name)>()

#define LI_FN_DEF(name) ::li::detail::lazy_function<::li::detail::khash(#name), name>()

#define LI_MODULE(name) ::li::detail::lazy_module<::li::detail::khash(name)>()

// NOTE only std::forward is used from this header.
// If there is a need to eliminate this dependency the function itself is very small.
#include <utility>
#include <cstddef>
#include <intrin.h>

#ifndef LAZY_IMPORTER_NO_FORCEINLINE
#if defined(_MSC_VER)
#define LAZY_IMPORTER_FORCEINLINE __forceinline
#elif defined(__GNUC__) && __GNUC__ > 3
#define LAZY_IMPORTER_FORCEINLINE inline __attribute__((__always_inline__))
#else
#define LAZY_IMPORTER_FORCEINLINE inline
#endif
#else
#define LAZY_IMPORTER_FORCEINLINE inline
#endif

#ifdef LAZY_IMPORTER_CASE_INSENSITIVE
#define LAZY_IMPORTER_TOLOWER(c) (c >= 'A' && c <= 'Z' ? (c | (1 << 5)) : c)
#else
#define LAZY_IMPORTER_TOLOWER(c) (c)
#endif

namespace li {
	namespace detail {

		template<class First, class Second>
		struct pair {
			First  first;
			Second second;
		};

		namespace win {

			struct LIST_ENTRY_T {
				const char* Flink;
				const char* Blink;
			};

			struct UNICODE_STRING_T {
				unsigned short Length;
				unsigned short MaximumLength;
				wchar_t*       Buffer;
			};

			struct PEB_LDR_DATA_T {
				unsigned long Length;
				unsigned long Initialized;
				const char*   SsHandle;
				LIST_ENTRY_T  InLoadOrderModuleList;
			};

			struct PEB_T {
				unsigned char   Reserved1[2];
				unsigned char   BeingDebugged;
				unsigned char   Reserved2[1];
				const char*     Reserved3[2];
				PEB_LDR_DATA_T* Ldr;
			};

			struct LDR_DATA_TABLE_ENTRY_T {
				LIST_ENTRY_T InLoadOrderLinks;
				LIST_ENTRY_T InMemoryOrderLinks;
				LIST_ENTRY_T InInitializationOrderLinks;
				const char*  DllBase;
				const char*  EntryPoint;
				union {
					unsigned long SizeOfImage;
					const char*   _dummy;
				};
				UNICODE_STRING_T FullDllName;
				UNICODE_STRING_T BaseDllName;

				LAZY_IMPORTER_FORCEINLINE const LDR_DATA_TABLE_ENTRY_T*
					load_order_next() const noexcept
				{
					return reinterpret_cast<const LDR_DATA_TABLE_ENTRY_T*>(
						InLoadOrderLinks.Flink);
				}
			};

			struct IMAGE_DOS_HEADER { // DOS .EXE header
				unsigned short e_magic; // Magic number
				unsigned short e_cblp; // Bytes on last page of file
				unsigned short e_cp; // Pages in file
				unsigned short e_crlc; // Relocations
				unsigned short e_cparhdr; // Size of header in paragraphs
				unsigned short e_minalloc; // Minimum extra paragraphs needed
				unsigned short e_maxalloc; // Maximum extra paragraphs needed
				unsigned short e_ss; // Initial (relative) SS value
				unsigned short e_sp; // Initial SP value
				unsigned short e_csum; // Checksum
				unsigned short e_ip; // Initial IP value
				unsigned short e_cs; // Initial (relative) CS value
				unsigned short e_lfarlc; // File address of relocation table
				unsigned short e_ovno; // Overlay number
				unsigned short e_res[4]; // Reserved words
				unsigned short e_oemid; // OEM identifier (for e_oeminfo)
				unsigned short e_oeminfo; // OEM information; e_oemid specific
				unsigned short e_res2[10]; // Reserved words
				long           e_lfanew; // File address of new exe header
			};

			struct IMAGE_FILE_HEADER {
				unsigned short Machine;
				unsigned short NumberOfSections;
				unsigned long  TimeDateStamp;
				unsigned long  PointerToSymbolTable;
				unsigned long  NumberOfSymbols;
				unsigned short SizeOfOptionalHeader;
				unsigned short Characteristics;
			};

			struct IMAGE_EXPORT_DIRECTORY {
				unsigned long  Characteristics;
				unsigned long  TimeDateStamp;
				unsigned short MajorVersion;
				unsigned short MinorVersion;
				unsigned long  Name;
				unsigned long  Base;
				unsigned long  NumberOfFunctions;
				unsigned long  NumberOfNames;
				unsigned long  AddressOfFunctions; // RVA from base of image
				unsigned long  AddressOfNames; // RVA from base of image
				unsigned long  AddressOfNameOrdinals; // RVA from base of image
			};

			struct IMAGE_DATA_DIRECTORY {
				unsigned long VirtualAddress;
				unsigned long Size;
			};

			struct IMAGE_OPTIONAL_HEADER64 {
				unsigned short       Magic;
				unsigned char        MajorLinkerVersion;
				unsigned char        MinorLinkerVersion;
				unsigned long        SizeOfCode;
				unsigned long        SizeOfInitializedData;
				unsigned long        SizeOfUninitializedData;
				unsigned long        AddressOfEntryPoint;
				unsigned long        BaseOfCode;
				unsigned long long   ImageBase;
				unsigned long        SectionAlignment;
				unsigned long        FileAlignment;
				unsigned short       MajorOperatingSystemVersion;
				unsigned short       MinorOperatingSystemVersion;
				unsigned short       MajorImageVersion;
				unsigned short       MinorImageVersion;
				unsigned short       MajorSubsystemVersion;
				unsigned short       MinorSubsystemVersion;
				unsigned long        Win32VersionValue;
				unsigned long        SizeOfImage;
				unsigned long        SizeOfHeaders;
				unsigned long        CheckSum;
				unsigned short       Subsystem;
				unsigned short       DllCharacteristics;
				unsigned long long   SizeOfStackReserve;
				unsigned long long   SizeOfStackCommit;
				unsigned long long   SizeOfHeapReserve;
				unsigned long long   SizeOfHeapCommit;
				unsigned long        LoaderFlags;
				unsigned long        NumberOfRvaAndSizes;
				IMAGE_DATA_DIRECTORY DataDirectory[16];
			};

			struct IMAGE_OPTIONAL_HEADER32 {
				unsigned short       Magic;
				unsigned char        MajorLinkerVersion;
				unsigned char        MinorLinkerVersion;
				unsigned long        SizeOfCode;
				unsigned long        SizeOfInitializedData;
				unsigned long        SizeOfUninitializedData;
				unsigned long        AddressOfEntryPoint;
				unsigned long        BaseOfCode;
				unsigned long        BaseOfData;
				unsigned long        ImageBase;
				unsigned long        SectionAlignment;
				unsigned long        FileAlignment;
				unsigned short       MajorOperatingSystemVersion;
				unsigned short       MinorOperatingSystemVersion;
				unsigned short       MajorImageVersion;
				unsigned short       MinorImageVersion;
				unsigned short       MajorSubsystemVersion;
				unsigned short       MinorSubsystemVersion;
				unsigned long        Win32VersionValue;
				unsigned long        SizeOfImage;
				unsigned long        SizeOfHeaders;
				unsigned long        CheckSum;
				unsigned short       Subsystem;
				unsigned short       DllCharacteristics;
				unsigned long        SizeOfStackReserve;
				unsigned long        SizeOfStackCommit;
				unsigned long        SizeOfHeapReserve;
				unsigned long        SizeOfHeapCommit;
				unsigned long        LoaderFlags;
				unsigned long        NumberOfRvaAndSizes;
				IMAGE_DATA_DIRECTORY DataDirectory[16];
			};

			struct IMAGE_NT_HEADERS {
				unsigned long     Signature;
				IMAGE_FILE_HEADER FileHeader;
#ifdef _WIN64
				IMAGE_OPTIONAL_HEADER64 OptionalHeader;
#else
				IMAGE_OPTIONAL_HEADER32 OptionalHeader;
#endif
			};

		} // namespace win

		// hashing stuff
		struct hash_t {
			using value_type = unsigned long;
			constexpr static value_type         offset = 2166136261;
			constexpr static value_type         prime = 16777619;
			constexpr static unsigned long long prime64 = prime;

			LAZY_IMPORTER_FORCEINLINE constexpr static value_type single(value_type value,
				char c) noexcept
			{
				return static_cast<hash_t::value_type>(
					(value ^ LAZY_IMPORTER_TOLOWER(c)) *
					static_cast<unsigned long long>(prime));
			}
		};

		template<class CharT = char>
		LAZY_IMPORTER_FORCEINLINE constexpr hash_t::value_type
			khash(const CharT* str, hash_t::value_type value = hash_t::offset) noexcept
		{
			return (*str ? khash(str + 1, hash_t::single(value, *str)) : value);
		}

		template<class CharT = char>
		LAZY_IMPORTER_FORCEINLINE hash_t::value_type hash(const CharT* str) noexcept
		{
			hash_t::value_type value = hash_t::offset;

			for (;;) {
				char c = *str++;
				if (!c)
					return value;
				value = hash_t::single(value, c);
			}
		}

		LAZY_IMPORTER_FORCEINLINE hash_t::value_type hash(
			const win::UNICODE_STRING_T& str) noexcept
		{
			auto       first = str.Buffer;
			const auto last = first + (str.Length / sizeof(wchar_t));
			auto       value = hash_t::offset;
			for (; first != last; ++first)
				value = hash_t::single(value, static_cast<char>(*first));

			return value;
		}

		LAZY_IMPORTER_FORCEINLINE pair<hash_t::value_type, hash_t::value_type> hash_forwarded(
			const char* str) noexcept
		{
			pair<hash_t::value_type, hash_t::value_type> module_and_function{
				hash_t::offset, hash_t::offset
			};

			for (; *str != '.'; ++str)
				hash_t::single(module_and_function.first, *str);

			++str;

			for (; *str; ++str)
				hash_t::single(module_and_function.second, *str);

			return module_and_function;
		}


		// some helper functions
		LAZY_IMPORTER_FORCEINLINE const win::PEB_T* peb() noexcept
		{
#if defined(_WIN64)
			return reinterpret_cast<const win::PEB_T*>(__readgsqword(0x60));
#elif defined(_WIN32)
			return reinterpret_cast<const win::PEB_T*>(__readfsdword(0x30));
#else
#error Unsupported platform. Open an issue and I'll probably add support.
#endif
		}

		LAZY_IMPORTER_FORCEINLINE const win::PEB_LDR_DATA_T* ldr()
		{
			return reinterpret_cast<const win::PEB_LDR_DATA_T*>(peb()->Ldr);
		}

		LAZY_IMPORTER_FORCEINLINE const win::IMAGE_NT_HEADERS* nt_headers(
			const char* base) noexcept
		{
			return reinterpret_cast<const win::IMAGE_NT_HEADERS*>(
				base + reinterpret_cast<const win::IMAGE_DOS_HEADER*>(base)->e_lfanew);
		}

		LAZY_IMPORTER_FORCEINLINE const win::IMAGE_EXPORT_DIRECTORY* image_export_dir(
			const char* base) noexcept
		{
			return reinterpret_cast<const win::IMAGE_EXPORT_DIRECTORY*>(
				base + nt_headers(base)->OptionalHeader.DataDirectory->VirtualAddress);
		}

		LAZY_IMPORTER_FORCEINLINE const win::LDR_DATA_TABLE_ENTRY_T* ldr_data_entry() noexcept
		{
			return reinterpret_cast<const win::LDR_DATA_TABLE_ENTRY_T*>(
				ldr()->InLoadOrderModuleList.Flink);
		}

		struct exports_directory {
			const char*                        _base;
			const win::IMAGE_EXPORT_DIRECTORY* _ied;
			unsigned long                      _ied_size;

		public:
			using size_type = unsigned long;

			LAZY_IMPORTER_FORCEINLINE
				exports_directory(const char* base) noexcept : _base(base)
			{
				const auto ied_data_dir = nt_headers(base)->OptionalHeader.DataDirectory[0];
				_ied = reinterpret_cast<const win::IMAGE_EXPORT_DIRECTORY*>(
					base + ied_data_dir.VirtualAddress);
				_ied_size = ied_data_dir.Size;
			}

			LAZY_IMPORTER_FORCEINLINE explicit operator bool() const noexcept
			{
				return reinterpret_cast<const char*>(_ied) != _base;
			}

			LAZY_IMPORTER_FORCEINLINE size_type size() const noexcept
			{
				return _ied->NumberOfNames;
			}

			LAZY_IMPORTER_FORCEINLINE const char* base() const noexcept { return _base; }
			LAZY_IMPORTER_FORCEINLINE const win::IMAGE_EXPORT_DIRECTORY* ied() const noexcept
			{
				return _ied;
			}

			LAZY_IMPORTER_FORCEINLINE const char* name(size_type index) const noexcept
			{
				return reinterpret_cast<const char*>(
					_base + reinterpret_cast<const unsigned long*>(
						_base + _ied->AddressOfNames)[index]);
			}

			LAZY_IMPORTER_FORCEINLINE const char* address(size_type index) const noexcept
			{
				const auto* const rva_table =
					reinterpret_cast<const unsigned long*>(_base + _ied->AddressOfFunctions);

				const auto* const ord_table = reinterpret_cast<const unsigned short*>(
					_base + _ied->AddressOfNameOrdinals);

				return _base + rva_table[ord_table[index]];
			}

			LAZY_IMPORTER_FORCEINLINE bool is_forwarded(const char* export_address) const
				noexcept
			{
				const auto ui_ied = reinterpret_cast<const char*>(_ied);
				return (export_address > ui_ied && export_address < ui_ied + _ied_size);
			}
		};

		struct safe_module_enumerator {
			using value_type = const detail::win::LDR_DATA_TABLE_ENTRY_T;
			value_type*       value;
			value_type* const head;

			LAZY_IMPORTER_FORCEINLINE safe_module_enumerator() noexcept
				: value(ldr_data_entry()), head(value)
			{}

			LAZY_IMPORTER_FORCEINLINE void reset() noexcept { value = head; }

			LAZY_IMPORTER_FORCEINLINE bool next() noexcept
			{
				value = value->load_order_next();
				return value != head && value->DllBase;
			}
		};

		struct unsafe_module_enumerator {
			using value_type = const detail::win::LDR_DATA_TABLE_ENTRY_T*;
			value_type value;

			LAZY_IMPORTER_FORCEINLINE unsafe_module_enumerator() noexcept
				: value(ldr_data_entry())
			{}

			LAZY_IMPORTER_FORCEINLINE void reset() noexcept { value = ldr_data_entry(); }

			LAZY_IMPORTER_FORCEINLINE bool next() noexcept
			{
				value = value->load_order_next();
				return true;
			}
		};

		// provides the cached functions which use Derive classes methods
		template<class Derived, class DefaultType = void*>
		class lazy_base {
		protected:
			// This function is needed because every templated function
			// with different args has its own static buffer
			LAZY_IMPORTER_FORCEINLINE static void*& _cache() noexcept
			{
				static void* value = nullptr;
				return value;
			}

		public:
			template<class T = DefaultType>
			LAZY_IMPORTER_FORCEINLINE static T safe() noexcept
			{
				return Derived::template get<T, safe_module_enumerator>();
			}

			template<class T = DefaultType, class Enum = unsafe_module_enumerator>
			LAZY_IMPORTER_FORCEINLINE static T cached() noexcept
			{
				auto& cached = _cache();
				if (!cached)
					cached = Derived::template get<void*, Enum>();

				return (T)(cached);
			}

			template<class T = DefaultType>
			LAZY_IMPORTER_FORCEINLINE static T safe_cached() noexcept
			{
				return cached<T, safe_module_enumerator>();
			}
		};

		template<hash_t::value_type Hash>
		struct lazy_module : lazy_base<lazy_module<Hash>> {
			template<class T = void*, class Enum = unsafe_module_enumerator>
			LAZY_IMPORTER_FORCEINLINE static T get() noexcept
			{
				Enum e;
				do {
					if (hash(e.value->BaseDllName) == Hash)
						return (T)(e.value->DllBase);
				} while (e.next());
				return {};
			}
		};

		template<hash_t::value_type Hash, class T>
		struct lazy_function : lazy_base<lazy_function<Hash, T>, T> {
			using base_type = lazy_base<lazy_function<Hash, T>, T>;

			template<class... Args>
			LAZY_IMPORTER_FORCEINLINE decltype(auto) operator()(Args&&... args) const
			{
#ifndef LAZY_IMPORTER_CACHE_OPERATOR_PARENS
				return get()(std::forward<Args>(args)...);
#else
				return this->cached()(std::forward<Args>(args)...);
#endif
			}

			template<class F = T, class Enum = unsafe_module_enumerator>
			LAZY_IMPORTER_FORCEINLINE static F get() noexcept
			{
				// for backwards compatability.
				// Before 2.0 it was only possible to resolve forwarded exports when
				// this macro was enabled
#ifdef LAZY_IMPORTER_RESOLVE_FORWARDED_EXPORTS
				return forwarded<F, Enum>();
#else
				Enum e;
				do {
					const exports_directory exports(e.value->DllBase);

					if (exports) {
						auto export_index = exports.size();
						while (export_index--)
							if (hash(exports.name(export_index)) == Hash)
								return (F)(exports.address(export_index));
					}
				} while (e.next());
				return {};
#endif
			}

			template<class F = T, class Enum = unsafe_module_enumerator>
			LAZY_IMPORTER_FORCEINLINE static F forwarded() noexcept
			{
				detail::win::UNICODE_STRING_T name;
				hash_t::value_type            module_hash = 0;
				auto                          function_hash = Hash;

				Enum e;
				do {
					name = e.value->BaseDllName;
					name.Length -= 8; // get rid of .dll extension

					if (!module_hash || hash(name) == module_hash) {
						const exports_directory exports(e.value->DllBase);

						if (exports) {
							auto export_index = exports.size();
							while (export_index--)
								if (hash(exports.name(export_index)) == function_hash) {
									const auto addr = exports.address(export_index);

									if (exports.is_forwarded(addr)) {
										auto hashes = hash_forwarded(
											reinterpret_cast<const char*>(addr));

										function_hash = hashes.second;
										module_hash = hashes.first;

										e.reset();
										break;
									}
									return (F)(addr);
								}
						}
					}
				} while (e.next());
				return {};
			}

			template<class F = T>
			LAZY_IMPORTER_FORCEINLINE static F forwarded_safe() noexcept
			{
				return forwarded<F, safe_module_enumerator>();
			}

			template<class F = T, class Enum = unsafe_module_enumerator>
			LAZY_IMPORTER_FORCEINLINE static F forwarded_cached() noexcept
			{
				auto& value = base_type::_cache();
				if (!value)
					value = forwarded<void*, Enum>();
				return (F)(value);
			}

			template<class F = T>
			LAZY_IMPORTER_FORCEINLINE static F forwarded_safe_cached() noexcept
			{
				return forwarded_cached<F, safe_module_enumerator>();
			}

			template<class F = T, bool IsSafe = false, class Module>
			LAZY_IMPORTER_FORCEINLINE static F in(Module m) noexcept
			{
				if (IsSafe && !m)
					return {};

				const exports_directory exports((const char*)(m));
				if (IsSafe && !exports)
					return {};

				for (unsigned long i{};; ++i) {
					if (IsSafe && i == exports.size())
						break;

					if (hash(exports.name(i)) == Hash)
						return (F)(exports.address(i));
				}
				return {};
			}

			template<class F = T, class Module>
			LAZY_IMPORTER_FORCEINLINE static F in_safe(Module m) noexcept
			{
				return in<F, true>(m);
			}

			template<class F = T, bool IsSafe = false, class Module>
			LAZY_IMPORTER_FORCEINLINE static F in_cached(Module m) noexcept
			{
				auto& value = base_type::_cache();
				if (!value)
					value = in<void*, IsSafe>(m);
				return (F)(value);
			}

			template<class F = T, class Module>
			LAZY_IMPORTER_FORCEINLINE static F in_safe_cached(Module m) noexcept
			{
				return in_cached<F, true>(m);
			}

			template<class F = T>
			LAZY_IMPORTER_FORCEINLINE static F nt() noexcept
			{
				return in<F>(ldr_data_entry()->load_order_next()->DllBase);
			}

			template<class F = T>
			LAZY_IMPORTER_FORCEINLINE static F nt_safe() noexcept
			{
				return in_safe<F>(ldr_data_entry()->load_order_next()->DllBase);
			}

			template<class F = T>
			LAZY_IMPORTER_FORCEINLINE static F nt_cached() noexcept
			{
				return in_cached<F>(ldr_data_entry()->load_order_next()->DllBase);
			}

			template<class F = T>
			LAZY_IMPORTER_FORCEINLINE static F nt_safe_cached() noexcept
			{
				return in_safe_cached<F>(ldr_data_entry()->load_order_next()->DllBase);
			}
		};

	}
} // namespace li::detail

#endif // include guard

```

`Lumina/Lumina/security/xorstr.hpp`:

```hpp

/*
 * Copyright 2017 - 2020 Justas Masiulis
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#ifndef JM_XORSTR_HPP
#define JM_XORSTR_HPP

#include <immintrin.h>
#include <cstdint>
#include <cstddef>
#include <utility>
#include <type_traits>

#define xorstr(str) ::jm::xor_string([]() { return str; }, std::integral_constant<std::size_t, sizeof(str) / sizeof(*str)>{}, std::make_index_sequence<::jm::detail::_buffer_size<sizeof(str)>()>{})
#define xorstr_(str) xorstr(str).crypt_get()

#ifdef _MSC_VER
#define XORSTR_FORCEINLINE __forceinline
#else
#define XORSTR_FORCEINLINE __attribute__((always_inline)) inline
#endif

#if defined(__clang__) || defined(__GNUC__)
#define JM_XORSTR_LOAD_FROM_REG(x) ::jm::detail::load_from_reg(x)
#else
#define JM_XORSTR_LOAD_FROM_REG(x) (x)
#endif

namespace jm {

	namespace detail {

		template<std::size_t Size>
		XORSTR_FORCEINLINE constexpr std::size_t _buffer_size()
		{
			return ((Size / 16) + (Size % 16 != 0)) * 2;
		}

		template<std::uint32_t Seed>
		XORSTR_FORCEINLINE constexpr std::uint32_t key4() noexcept
		{
			std::uint32_t value = Seed;
			for (char c : __TIME__)
				value = static_cast<std::uint32_t>((value ^ c) * 16777619ull);
			return value;
		}

		template<std::size_t S>
		XORSTR_FORCEINLINE constexpr std::uint64_t key8()
		{
			constexpr auto first_part = key4<2166136261 + S>();
			constexpr auto second_part = key4<first_part>();
			return (static_cast<std::uint64_t>(first_part) << 32) | second_part;
		}

		// loads up to 8 characters of string into uint64 and xors it with the key
		template<std::size_t N, class CharT>
		XORSTR_FORCEINLINE constexpr std::uint64_t
			load_xored_str8(std::uint64_t key, std::size_t idx, const CharT* str) noexcept
		{
			using cast_type = typename std::make_unsigned<CharT>::type;
			constexpr auto value_size = sizeof(CharT);
			constexpr auto idx_offset = 8 / value_size;

			std::uint64_t value = key;
			for (std::size_t i = 0; i < idx_offset && i + idx * idx_offset < N; ++i)
				value ^=
				(std::uint64_t{ static_cast<cast_type>(str[i + idx * idx_offset]) }
			<< ((i % idx_offset) * 8 * value_size));

			return value;
		}

		// forces compiler to use registers instead of stuffing constants in rdata
		XORSTR_FORCEINLINE std::uint64_t load_from_reg(std::uint64_t value) noexcept
		{
#if defined(__clang__) || defined(__GNUC__)
			asm("" : "=r"(value) : "0"(value) : );
#endif
			return value;
		}

		template<std::uint64_t V>
		struct uint64_v {
			constexpr static std::uint64_t value = V;
		};

	} // namespace detail

	template<class CharT, std::size_t Size, class Keys, class Indices>
	class xor_string;

	template<class CharT, std::size_t Size, std::uint64_t... Keys, std::size_t... Indices>
	class xor_string<CharT, Size, std::integer_sequence<std::uint64_t, Keys...>, std::index_sequence<Indices...>> {
#ifndef JM_XORSTR_DISABLE_AVX_INTRINSICS
		constexpr static inline std::uint64_t alignment = ((Size > 16) ? 32 : 16);
#else
		constexpr static inline std::uint64_t alignment = 16;
#endif

		alignas(alignment) std::uint64_t _storage[sizeof...(Keys)];

	public:
		using value_type = CharT;
		using size_type = std::size_t;
		using pointer = CharT * ;
		using const_pointer = const CharT*;

		template<class L>
		XORSTR_FORCEINLINE xor_string(L l, std::integral_constant<std::size_t, Size>, std::index_sequence<Indices...>) noexcept
			: _storage{ JM_XORSTR_LOAD_FROM_REG(detail::uint64_v<detail::load_xored_str8<Size>(Keys, Indices, l())>::value)... }
		{}

		XORSTR_FORCEINLINE constexpr size_type size() const noexcept
		{
			return Size - 1;
		}

		XORSTR_FORCEINLINE void crypt() noexcept
		{
#if defined(__clang__)
			alignas(alignment)
				std::uint64_t arr[]{ JM_XORSTR_LOAD_FROM_REG(Keys)... };
			std::uint64_t*    keys =
				(std::uint64_t*)JM_XORSTR_LOAD_FROM_REG((std::uint64_t)arr);
#else
			alignas(alignment) std::uint64_t keys[]{ JM_XORSTR_LOAD_FROM_REG(Keys)... };
#endif

#ifndef JM_XORSTR_DISABLE_AVX_INTRINSICS
			((Indices >= sizeof(_storage) / 32 ? static_cast<void>(0) : _mm256_store_si256(
				reinterpret_cast<__m256i*>(_storage) + Indices,
				_mm256_xor_si256(
					_mm256_load_si256(reinterpret_cast<const __m256i*>(_storage) + Indices),
					_mm256_load_si256(reinterpret_cast<const __m256i*>(keys) + Indices)))), ...);

			if constexpr (sizeof(_storage) % 32 != 0)
				_mm_store_si128(
					reinterpret_cast<__m128i*>(_storage + sizeof...(Keys) - 2),
					_mm_xor_si128(_mm_load_si128(reinterpret_cast<const __m128i*>(_storage + sizeof...(Keys) - 2)),
						_mm_load_si128(reinterpret_cast<const __m128i*>(keys + sizeof...(Keys) - 2))));
#else
			((Indices >= sizeof(_storage) / 16 ? static_cast<void>(0) : _mm_store_si128(
				reinterpret_cast<__m128i*>(_storage) + Indices,
				_mm_xor_si128(_mm_load_si128(reinterpret_cast<const __m128i*>(_storage) + Indices),
					_mm_load_si128(reinterpret_cast<const __m128i*>(keys) + Indices)))), ...);
#endif
		}

		XORSTR_FORCEINLINE const_pointer get() const noexcept
		{
			return reinterpret_cast<const_pointer>(_storage);
		}

		XORSTR_FORCEINLINE pointer get() noexcept
		{
			return reinterpret_cast<pointer>(_storage);
		}

		XORSTR_FORCEINLINE pointer crypt_get() noexcept
		{
			// crypt() function inlined by hand, because MSVC linker chokes when you have a lot of strings
			// on 32 bit builds, so don't blame me for shit code :pepekms:
#if defined(__clang__)
			alignas(alignment)
				std::uint64_t arr[]{ JM_XORSTR_LOAD_FROM_REG(Keys)... };
			std::uint64_t*    keys =
				(std::uint64_t*)JM_XORSTR_LOAD_FROM_REG((std::uint64_t)arr);
#else
			alignas(alignment) std::uint64_t keys[]{ JM_XORSTR_LOAD_FROM_REG(Keys)... };
#endif

#ifndef JM_XORSTR_DISABLE_AVX_INTRINSICS
			((Indices >= sizeof(_storage) / 32 ? static_cast<void>(0) : _mm256_store_si256(
				reinterpret_cast<__m256i*>(_storage) + Indices,
				_mm256_xor_si256(
					_mm256_load_si256(reinterpret_cast<const __m256i*>(_storage) + Indices),
					_mm256_load_si256(reinterpret_cast<const __m256i*>(keys) + Indices)))), ...);

			if constexpr (sizeof(_storage) % 32 != 0)
				_mm_store_si128(
					reinterpret_cast<__m128i*>(_storage + sizeof...(Keys) - 2),
					_mm_xor_si128(_mm_load_si128(reinterpret_cast<const __m128i*>(_storage + sizeof...(Keys) - 2)),
						_mm_load_si128(reinterpret_cast<const __m128i*>(keys + sizeof...(Keys) - 2))));
#else
			((Indices >= sizeof(_storage) / 16 ? static_cast<void>(0) : _mm_store_si128(
				reinterpret_cast<__m128i*>(_storage) + Indices,
				_mm_xor_si128(_mm_load_si128(reinterpret_cast<const __m128i*>(_storage) + Indices),
					_mm_load_si128(reinterpret_cast<const __m128i*>(keys) + Indices)))), ...);
#endif
			return (pointer)(_storage);
		}
	};

	template<class L, std::size_t Size, std::size_t... Indices>
	xor_string(L l, std::integral_constant<std::size_t, Size>, std::index_sequence<Indices...>)->xor_string<
		std::remove_const_t<std::remove_reference_t<decltype(l()[0])>>,
		Size,
		std::integer_sequence<std::uint64_t, detail::key8<Indices>()...>,
		std::index_sequence<Indices...>>;

} // namespace jm

#define XorStr( s ) (xorstr(s).crypt_get())

#endif // include guard
```

`Lumina/Lumina/ui/fgui_/FGUI.hpp`:

```hpp
//
// FGUI - feature rich graphical user interface
//

#ifdef FGUI_IMPLEMENTATION

// NOTE: DON'T INCLUDE THIS HEADER FILE INSIDE THE LIBRARY!
// NOTE: DON'T INCLUDE THIS HEADER FILE INSIDE THE LIBRARY!
// NOTE: DON'T INCLUDE THIS HEADER FILE INSIDE THE LIBRARY!
// NOTE: DON'T INCLUDE THIS HEADER FILE INSIDE THE LIBRARY!
// NOTE: DON'T INCLUDE THIS HEADER FILE INSIDE THE LIBRARY!
// NOTE: DON'T INCLUDE THIS HEADER FILE INSIDE THE LIBRARY!
// NOTE: DON'T INCLUDE THIS HEADER FILE INSIDE THE LIBRARY!
// NOTE: DON'T INCLUDE THIS HEADER FILE INSIDE THE LIBRARY!
// NOTE: DON'T INCLUDE THIS HEADER FILE INSIDE THE LIBRARY!
// NOTE: DON'T INCLUDE THIS HEADER FILE INSIDE THE LIBRARY!
// NOTE: DON'T INCLUDE THIS HEADER FILE INSIDE THE LIBRARY!
// NOTE: DON'T INCLUDE THIS HEADER FILE INSIDE THE LIBRARY!
// NOTE: DON'T INCLUDE THIS HEADER FILE INSIDE THE LIBRARY!
// NOTE: DON'T INCLUDE THIS HEADER FILE INSIDE THE LIBRARY!
// NOTE: DON'T INCLUDE THIS HEADER FILE INSIDE THE LIBRARY!

// dependencies
#include "dependencies/aliases.hpp"
#include "dependencies/builder.hpp"
#include "dependencies/definitions.hpp"
#include "dependencies/helpers.hpp"

// widgets
#include "widgets/button.hpp"
#include "widgets/checkbox.hpp"
#include "widgets/colorlist.hpp"
#include "widgets/form.hpp"
#include "widgets/groupbox.hpp"
#include "widgets/keybinder.hpp"
#include "widgets/label.hpp"
#include "widgets/listbox.hpp"
#include "widgets/multibox.hpp"
#include "widgets/slider.hpp"
#include "widgets/tabs.hpp"
#include "widgets/textbox.hpp"
#include "widgets/widgets.hpp"

#endif // FGUI_IMPLEMENTATION
```

`Lumina/Lumina/ui/fgui_/dependencies/aliases.hpp`:

```hpp
//
// FGUI - feature rich graphical user interface
//

#ifndef FGUI_ALIASES_HH
#define FGUI_ALIASES_HH

// includes
#include <functional>

// library includes
#include "definitions.hpp"
#include "helpers.hpp"

namespace FGUI
{
	namespace DETAIL
	{
		// drawing functions pointers
		using pCreateFont = std::add_pointer_t<void(FGUI::FONT&, std::string, int, int, bool)>;
		using pGetScreenSize = std::add_pointer_t<FGUI::DIMENSION()>;
		using pGetTextSize = std::add_pointer_t<FGUI::DIMENSION(FGUI::FONT, std::string)>;
		using pDrawRectangle = std::add_pointer_t<void(int, int, int, int, FGUI::COLOR)>;
		using pDrawOutline = std::add_pointer_t<void(int, int, int, int, FGUI::COLOR)>;
		using pDrawGradient = std::add_pointer_t<void(int, int, int, int, FGUI::COLOR, FGUI::COLOR, bool)>;
		using pDrawLine = std::add_pointer_t<void(int, int, int, int, FGUI::COLOR)>;
		using pDrawText = std::add_pointer_t<void(int, int, FGUI::FONT, FGUI::COLOR, std::string)>;

		// input functions pointers
		using pPullInput = std::add_pointer_t<void()>;
		using pGetKeyState = std::add_pointer_t<bool(int)>;
		using pGetKeyPress = std::add_pointer_t<bool(int)>;
		using pGetKeyRelease = std::add_pointer_t<bool(int)>;
		using pGetCursorPos = std::add_pointer_t<FGUI::POINT()>;
		using pGetCursorPosDelta = std::add_pointer_t<FGUI::POINT()>;
		using pGetCursorWheelDelta = std::add_pointer_t<int()>;
		using pIsCursorInArea = std::add_pointer_t<bool(FGUI::AREA)>;

	} // namespace DETAIL

	using RENDER_MANAGER = struct SRenderManager_t
	{
		DETAIL::pCreateFont CreateFont;
		DETAIL::pGetScreenSize GetScreenSize;
		DETAIL::pGetTextSize GetTextSize;
		DETAIL::pDrawRectangle Rectangle;
		DETAIL::pDrawOutline Outline;
		DETAIL::pDrawGradient Gradient;
		DETAIL::pDrawLine Line;
		DETAIL::pDrawText Text;
	};

	using INPUT_SYTEM = struct SInputSystem_t
	{
		DETAIL::pPullInput PullInput;
		DETAIL::pGetKeyState GetKeyState;
		DETAIL::pGetKeyRelease GetKeyRelease;
		DETAIL::pGetKeyPress GetKeyPress;
		DETAIL::pGetCursorPos GetCursorPos;
		DETAIL::pGetCursorPosDelta GetCursorPosDelta;
		DETAIL::pGetCursorWheelDelta GetCursorWheelDelta;
		DETAIL::pIsCursorInArea IsCursorInArea;
	};

	inline RENDER_MANAGER RENDER;
	inline INPUT_SYTEM INPUT;

} // namespace FGUI

#endif // FGUI_ALIASES_HH
```

`Lumina/Lumina/ui/fgui_/dependencies/builder.hpp`:

```hpp
//
// FGUI - feature rich graphical user interface
//

#ifndef FGUI_BUILDER_HH
#define FGUI_BUILDER_HH

// includes
#include <memory>
#include <utility>
#include <functional>

// library includes
#include "../widgets/button.hpp"
#include "../widgets/checkbox.hpp"
#include "../widgets/colorlist.hpp"
#include "../widgets/form.hpp"
#include "../widgets/groupbox.hpp"
#include "../widgets/keybinder.hpp"
#include "../widgets/label.hpp"
#include "../widgets/listbox.hpp"
#include "../widgets/multibox.hpp"
#include "../widgets/slider.hpp"
#include "../widgets/tabs.hpp"
#include "../widgets/textbox.hpp"
#include "../widgets/widgets.hpp"

namespace FGUI
{
	class CBuilder
	{
	public:
		// @brief: add a new widget to the queue (to be spawned by the builder pattern)
		// @args: std::shared_ptr<FGUI::CWidgets> widget = widget that will be spawned
		// @note: NEEDS TO BE INITIALIZED FIRST!
		CBuilder& Widget(std::shared_ptr<FGUI::CWidgets> widget)
		{
			m_pTemporaryWidget = widget;
			m_pTemporaryTab = nullptr;
			m_pTemporaryForm = nullptr;

			return const_cast<FGUI::CBuilder&>(*this);
		}

		// @brief: add a new form to the queue (to be spawned by the builder pattern)
		// @args: std::shared_ptr<FGUI::CWidgets> widget = widget that will be spawned
		// @note: NEEDS TO BE INITIALIZED FIRST!
		CBuilder& Widget(std::shared_ptr<FGUI::CForm> form)
		{
			m_pTemporaryForm = form;
			m_pTemporaryWidget = nullptr;
			m_pTemporaryTab = nullptr;

			return const_cast<FGUI::CBuilder&>(*this);
		}

		// @brief: add a new tab to the queue (to be spawned by the builder pattern)
		// @args: std::shared_ptr<FGUI::CWidgets> widget = widget that will be spawned
		// @note: NEEDS TO BE INITIALIZED FIRST!
		CBuilder& Widget(std::shared_ptr<FGUI::CTabs> tab)
		{
			m_pTemporaryTab = tab;
			m_pTemporaryWidget = nullptr;
			m_pTemporaryForm = nullptr;

			return const_cast<FGUI::CBuilder&>(*this);
		}

		// @brief: set widget default title
		// @args: std::string title = widget title/name
		CBuilder& Title(std::string title)
		{
			if (!m_pTemporaryTab && !m_pTemporaryForm)
			{
				m_pTemporaryWidget->SetTitle(title);
			}
			else if (!m_pTemporaryTab && m_pTemporaryForm)
			{
				m_pTemporaryForm->SetTitle(title);
			}
			else
			{
				m_pTemporaryTab->SetTitle(title);
			}

			return const_cast<FGUI::CBuilder&>(*this);
		}

		// @brief: set widget default position
		// @args: unsigned int x = left position (in pixels), unsigned y = top position (in pixels)
		CBuilder& Position(unsigned int x, unsigned int y)
		{
			if (!m_pTemporaryForm)
			{
				m_pTemporaryWidget->SetPosition(x, y);
			}
			else
			{
				m_pTemporaryForm->SetPosition(x, y);
			}

			return const_cast<FGUI::CBuilder&>(*this);
		}

		// @brief: set widget default size
		// @args: unsigned int width = widget width, unsigned int height = widget height
		CBuilder& Size(unsigned int width, unsigned int height)
		{
			if (!m_pTemporaryForm)
			{
				m_pTemporaryWidget->SetSize(width, height);
			}
			else
			{
				m_pTemporaryForm->SetSize(width, height);
			}

			return const_cast<FGUI::CBuilder&>(*this);
		}

		// @brief: set the widget default font
		// @args: std::string family = font family/name, int size = font size (tall), bool bold = make the font bold, int flags = font custom flags (shadow, outline, etc)
		CBuilder& Font(std::string family, int size, bool bold = false, int flags = 0x0)
		{
			if (!m_pTemporaryTab && !m_pTemporaryForm)
			{
				m_pTemporaryWidget->SetFont(family, size, bold, flags);
			}
			else if (!m_pTemporaryTab && m_pTemporaryForm)
			{
				m_pTemporaryForm->SetFont(family, size, bold, flags);
			}
			else
			{
				m_pTemporaryTab->SetFont(family, size, bold, flags);
			}

			return const_cast<FGUI::CBuilder&>(*this);
		}

		// @brief: set the widget default font
		// @args: FGUI::WIDGET_FONT font = widget font struct (same as above)
		CBuilder& Font(FGUI::WIDGET_FONT font)
		{
			if (!m_pTemporaryTab && !m_pTemporaryForm)
			{
				m_pTemporaryWidget->SetFont(font);
			}
			else if (!m_pTemporaryTab && m_pTemporaryForm)
			{
				m_pTemporaryForm->SetFont(font);
			}
			else
			{
				m_pTemporaryTab->SetFont(font);
			}

			return const_cast<FGUI::CBuilder&>(*this);
		}

		// @brief: change widget default flags
		// @args: FGUI::WIDGET_FLAG flags = widget custom flag (DRAWABLE, CLICKABLE, etc)
		CBuilder& Flags(FGUI::WIDGET_FLAG flags)
		{
			if (!m_pTemporaryForm && !m_pTemporaryTab)
			{
				m_pTemporaryWidget->SetFlags(static_cast<int>(flags));
			}
			else if (!m_pTemporaryTab && m_pTemporaryForm)
			{
				m_pTemporaryForm->SetFlags(static_cast<int>(flags));
			}

			return const_cast<FGUI::CBuilder&>(*this);
		}

		// @brief: groupbox/multibox scrollbar state
		// @args: bool state = scrollbar state (enabled/disabled)
		CBuilder& ScrollBar(bool onoff)
		{
			if (m_pTemporaryWidget->GetType() == static_cast<int>(WIDGET_TYPE::GROUPBOX))
			{
				std::reinterpret_pointer_cast<FGUI::CGroupBox>(m_pTemporaryWidget)->SetScrollbarState(onoff);
			}

			return const_cast<FGUI::CBuilder&>(*this);
		}

		// @brief: set the widget medium (controller)
		// @args: std::shared_ptr<FGUI::CWidgets> medium = widget that will "control" the current widget
		// unsigned int page = page to draw current widget according to the controller state (selected entry, value, state, etc)
		CBuilder& Medium(std::shared_ptr<FGUI::CWidgets> medium, unsigned int page)
		{
			m_pTemporaryWidget->SetMedium(medium, page);

			return const_cast<FGUI::CBuilder&>(*this);
		}

		// @brief: add a new color to the colorlist
		// @args: std::string identifier = color name, FGUI::COLOR color = default color, bool gradient = gradient status (enable/disable interpolation)
		CBuilder& Color(std::string identifier, FGUI::COLOR color, bool gradient = false)
		{
			if (m_pTemporaryWidget->GetType() == static_cast<int>(WIDGET_TYPE::COLORLIST))
			{
				std::reinterpret_pointer_cast<FGUI::CColorList>(m_pTemporaryWidget)->AddColor(identifier, color, gradient);
			}

			return const_cast<FGUI::CBuilder&>(*this);
		}

		// @brief: add a new color to the colorlist
		// @args: std::string identifier = color name, std::uint8_t red = red color (0 - 255), std::uint8_t green = green color (0 - 255), 
		// std::uint8_t blue = blue color (0 - 255), std::uint8_t alpha = color alpha (0 - 255), bool gradient = gradient status (enable/disable interpolation)
		CBuilder& Color(std::string identifier, std::uint8_t red, std::uint8_t green, std::uint8_t blue, std::uint8_t alpha = 255, bool gradient = false)
		{
			if (m_pTemporaryWidget->GetType() == static_cast<int>(WIDGET_TYPE::COLORLIST))
			{
				std::reinterpret_pointer_cast<FGUI::CColorList>(m_pTemporaryWidget)->AddColor(identifier, { red, green, blue, alpha }, gradient);
			}

			return const_cast<FGUI::CBuilder&>(*this);
		}

		// @brief: set the default color of a widget (colorpicker/label)
		// @args: FGUI::COLOR color = widget color
		CBuilder& Color(FGUI::COLOR color)
		{
			if (m_pTemporaryWidget->GetType() == static_cast<int>(WIDGET_TYPE::LABEL))
			{
				std::reinterpret_pointer_cast<FGUI::CLabel>(m_pTemporaryWidget)->SetColor(color);
			}
			else if (m_pTemporaryWidget->GetType() == static_cast<int>(WIDGET_TYPE::COLORPICKER))
			{
			}

			return const_cast<FGUI::CBuilder&>(*this);
		}

		// @brief: set the default color of a widget (colorpicker/label)
		// @args: std::uint8_t red = red color (0 - 255), std::uint8_t green = green color (0 - 255), 
		// std::uint8_t blue = blue color (0 - 255), std::uint8_t alpha = color alpha (0 - 255)
		CBuilder& Color(std::uint8_t red, std::uint8_t green, std::uint8_t blue, std::uint8_t alpha = 255)
		{
			if (m_pTemporaryWidget->GetType() == static_cast<int>(WIDGET_TYPE::LABEL))
			{
				std::reinterpret_pointer_cast<FGUI::CLabel>(m_pTemporaryWidget)->SetColor({ red, green, blue, alpha });
			}
			else if (m_pTemporaryWidget->GetType() == static_cast<int>(WIDGET_TYPE::COLORPICKER))
			{
			}

			return const_cast<FGUI::CBuilder&>(*this);
		}

		// @brief: set the default key of a widget (keybinder and form)
		// @args: unsigned int key = default key
		// @note: key = selected key on keybinders
		// key = toggle key on forms/child forms
		CBuilder& Key(unsigned int key)
		{
			if (!m_pTemporaryForm)
			{
				if (m_pTemporaryWidget->GetType() == static_cast<int>(WIDGET_TYPE::KEYBINDER))
				{
					std::reinterpret_pointer_cast<FGUI::CKeyBinder>(m_pTemporaryWidget)->SetKey(key);
				}
			}
			else
			{
				m_pTemporaryForm->SetKey(key);
			}

			return const_cast<FGUI::CBuilder&>(*this);
		}

		// @brief: set the default text of a widget (textbox and labels)
		// @args: std::string text = default text
		CBuilder& Text(std::string text)
		{
			if (m_pTemporaryWidget->GetType() == static_cast<int>(WIDGET_TYPE::TEXTBOX))
			{
				std::reinterpret_pointer_cast<FGUI::CTextBox>(m_pTemporaryWidget)->SetText(text);
			}
			else if (m_pTemporaryWidget->GetType() == static_cast<int>(WIDGET_TYPE::LABEL))
			{
				std::reinterpret_pointer_cast<FGUI::CLabel>(m_pTemporaryWidget)->SetTitle(text);
			}

			return const_cast<FGUI::CBuilder&>(*this);
		}

		// @brief: set the selected index of a widget (multibox and listbox)
		// @args: std::size_T index = selected index
		CBuilder& Index(std::size_t index)
		{
			if (m_pTemporaryWidget->GetType() == static_cast<int>(WIDGET_TYPE::LISTBOX))
			{
				std::reinterpret_pointer_cast<FGUI::CListBox>(m_pTemporaryWidget)->SetIndex(index);
			}
			else if (m_pTemporaryWidget->GetType() == static_cast<int>(WIDGET_TYPE::MULTIBOX))
			{
				std::reinterpret_pointer_cast<FGUI::CMultiBox>(m_pTemporaryWidget)->SetIndex(index);
			}

			return const_cast<FGUI::CBuilder&>(*this);
		}

		// @brief: set the default value of a widget (slider)
		// @args: float value = default value
		CBuilder& Value(float value)
		{
			if (m_pTemporaryWidget->GetType() == static_cast<int>(WIDGET_TYPE::SLIDER))
			{
				std::reinterpret_pointer_cast<FGUI::CSlider>(m_pTemporaryWidget)->SetValue(value);
			}

			return const_cast<FGUI::CBuilder&>(*this);
		}

		// @brief: set the default prefix of a slider
		// @args: std::string prefix = slider prefix (ms, %, °, etc)
		CBuilder& Prefix(std::string prefix)
		{
			if (m_pTemporaryWidget->GetType() == static_cast<int>(WIDGET_TYPE::SLIDER))
			{
				std::reinterpret_pointer_cast<FGUI::CSlider>(m_pTemporaryWidget)->SetPrefix(prefix);
			}

			return const_cast<FGUI::CBuilder&>(*this);
		}

		// @brief: set the widget state
		// @args: bool state = widget state (toggled on/off)
		// @note: state = set the checkbox state (checked or not)
		// state = set multibox dropdown list state (toggled on/off)
		// state = set the form state (on/off)
		CBuilder& State(bool state)
		{
			if (!m_pTemporaryForm)
			{
				if (m_pTemporaryWidget->GetType() == static_cast<int>(WIDGET_TYPE::CHECKBOX))
				{
					std::reinterpret_pointer_cast<FGUI::CCheckBox>(m_pTemporaryWidget)->SetState(state);
				}
				else if (m_pTemporaryWidget->GetType() == static_cast<int>(WIDGET_TYPE::MULTIBOX))
				{
					std::reinterpret_pointer_cast<FGUI::CMultiBox>(m_pTemporaryWidget)->SetState(state);
				}
			}
			else
			{
				m_pTemporaryForm->SetState(state);
			}

			return const_cast<FGUI::CBuilder&>(*this);
		}

		// @brief: add a new entry to the widget (multibox and listbox)
		// @args: std::string title = entry title, unsigned int value = custom value
		CBuilder& Entry(std::string title, unsigned int value = 0)
		{
			if (m_pTemporaryWidget->GetType() == static_cast<int>(WIDGET_TYPE::MULTIBOX))
			{
				if (std::reinterpret_pointer_cast<FGUI::CMultiBox>(m_pTemporaryWidget)->GetStyle() == static_cast<int>(MULTIBOX_STYLE::NORMAL))
				{
					std::reinterpret_pointer_cast<FGUI::CMultiBox>(m_pTemporaryWidget)->AddEntry(title, value);
				}
				else if (std::reinterpret_pointer_cast<FGUI::CMultiBox>(m_pTemporaryWidget)->GetStyle() == static_cast<int>(MULTIBOX_STYLE::MULTI))
				{
					std::reinterpret_pointer_cast<FGUI::CMultiBox>(m_pTemporaryWidget)->AddEntry(title, static_cast<bool>(value));
				}
			}
			else if (m_pTemporaryWidget->GetType() == static_cast<int>(WIDGET_TYPE::LISTBOX))
			{
				std::reinterpret_pointer_cast<FGUI::CListBox>(m_pTemporaryWidget)->AddEntry(title, value);
			}

			return const_cast<FGUI::CBuilder&>(*this);
		}

		// @brief: set the style of a widget (multibox, label and textbox)
		// @args: int style
		// @note: style = multibox style (normal and multi - FGUI::MULTIBOX_STYLE)
		// style = label style (normal, colored and link - FGUI::LABEL_STYLE)
		// style = textbox style (normal, password and uppercase - FGUI::TEXTBOX_STYLE)
		CBuilder& Style(int style)
		{
			if (m_pTemporaryWidget->GetType() == static_cast<int>(WIDGET_TYPE::MULTIBOX))
			{
				std::reinterpret_pointer_cast<FGUI::CMultiBox>(m_pTemporaryWidget)->SetStyle(static_cast<FGUI::MULTIBOX_STYLE>(style));
			}
			else if (m_pTemporaryWidget->GetType() == static_cast<int>(WIDGET_TYPE::LABEL))
			{
				std::reinterpret_pointer_cast<FGUI::CLabel>(m_pTemporaryWidget)->SetStyle(static_cast<FGUI::LABEL_STYLE>(style));
			}
			else if (m_pTemporaryWidget->GetType() == static_cast<int>(WIDGET_TYPE::TEXTBOX))
			{
			}

			return const_cast<FGUI::CBuilder&>(*this);
		}

		// @brief: add a callback to a widget
		// @args: std::function<void()> callback = function to call
		CBuilder& Callback(std::function<void()> callback)
		{
			if (!m_pTemporaryForm && m_pTemporaryWidget)
			{
				if (m_pTemporaryWidget->GetType() == static_cast<int>(WIDGET_TYPE::MULTIBOX))
				{
					std::reinterpret_pointer_cast<FGUI::CMultiBox>(m_pTemporaryWidget)->AddCallback(callback);
				}
				else if (m_pTemporaryWidget->GetType() == static_cast<int>(WIDGET_TYPE::LABEL))
				{
					std::reinterpret_pointer_cast<FGUI::CLabel>(m_pTemporaryWidget)->AddCallback(callback);
				}
				else if (m_pTemporaryWidget->GetType() == static_cast<int>(WIDGET_TYPE::CHECKBOX))
				{
					std::reinterpret_pointer_cast<FGUI::CCheckBox>(m_pTemporaryWidget)->AddCallback(callback);
				}
				else if (m_pTemporaryWidget->GetType() == static_cast<int>(WIDGET_TYPE::BUTTON))
				{
					std::reinterpret_pointer_cast<FGUI::CButton>(m_pTemporaryWidget)->AddCallback(callback);
				}
				else if (m_pTemporaryWidget->GetType() == static_cast<int>(WIDGET_TYPE::LISTBOX))
				{
					std::reinterpret_pointer_cast<FGUI::CListBox>(m_pTemporaryWidget)->AddCallback(callback);
				}
			}
			else
			{
				m_pTemporaryForm->AddCallback(callback);
			}

			return const_cast<FGUI::CBuilder&>(*this);
		}

		// @brief: widget value range (sliders)
		// @args: float min = min value, float max = max value
		CBuilder& Range(float min, float max)
		{
			if (m_pTemporaryWidget->GetType() == static_cast<int>(WIDGET_TYPE::SLIDER))
			{
				std::reinterpret_pointer_cast<FGUI::CSlider>(m_pTemporaryWidget)->SetRange(min, max);
			}

			return const_cast<FGUI::CBuilder&>(*this);
		}

		// @brief: set the text length of textboxes
		// @args: unsigned int length = text max length 
		CBuilder& Length(unsigned int length)
		{
			if (m_pTemporaryWidget->GetType() == static_cast<int>(WIDGET_TYPE::TEXTBOX))
			{
				std::reinterpret_pointer_cast<FGUI::CTextBox>(m_pTemporaryWidget)->SetLength(length);
			}

			return const_cast<FGUI::CBuilder&>(*this);
		}

		// @brief: spawn widget inside a groupbox
		// @args: std::shared_ptr<FGUI::CGroupBox> groupbox = groupbox that the widget will be spawned, std::shared_ptr<FGUI::CTabs> tab = tab that the groupbox is spawned, 
		// bool padding = enable/disable padding (enabled by default)
		CBuilder& Spawn(std::shared_ptr<FGUI::CGroupBox> groupbox, std::shared_ptr<FGUI::CTabs> tab, bool padding = true)
		{
			groupbox->AddWidget(m_pTemporaryWidget, tab, padding);

			return const_cast<FGUI::CBuilder&>(*this);
		}

		// @brief: spawn widget inside a tab
		// @args: std::shared_ptr<FGUI::CTabs> tab = tab to spawn widget
		CBuilder& Spawn(std::shared_ptr<FGUI::CTabs> tab)
		{
			tab->AddWidget(m_pTemporaryWidget);

			return const_cast<FGUI::CBuilder&>(*this);
		}

		// @brief: spawn tab inside a form
		// @args: std::shared_ptr<FGUI::CForm> form = form to spawn tab
		CBuilder& Spawn(std::shared_ptr<FGUI::CForm> form)
		{
			form->AddTab(m_pTemporaryTab);

			return const_cast<FGUI::CBuilder&>(*this);
		}

		// @brief: spawn child inside a parent form
		// @args: std::shared_ptr<FGUI::CForm> parent_form = parent form (main form), std::shared_ptr<FGUI::CForm> child_form = child form to spawn
		CBuilder& Spawn(std::shared_ptr<FGUI::CForm> parent_form, std::shared_ptr<FGUI::CForm> child_form)
		{
			parent_form->AddForm(child_form);

			return const_cast<FGUI::CBuilder&>(*this);
		}

	private:
		std::shared_ptr<FGUI::CWidgets> m_pTemporaryWidget = nullptr;
		std::shared_ptr<FGUI::CTabs> m_pTemporaryTab = nullptr;
		std::shared_ptr<FGUI::CForm> m_pTemporaryForm = nullptr;
	};

} // namespace FGUI

#endif // FGUI_BUILDER_HH
```

`Lumina/Lumina/ui/fgui_/dependencies/definitions.hpp`:

```hpp
//
// FGUI - feature rich graphical user interface
//

#ifndef FGUI_DEFINITIONS_HH
#define FGUI_DEFINITIONS_HH

// includes
#include <string>
#include <stdint.h>
#include <algorithm>

namespace FGUI
{

using POINT = struct SPoint_t
{
  int m_iX, m_iY;
};

using PRECISION = struct SPrecisionPoint_t
{
  float m_flX, m_flY;
};

using DIMENSION = struct SDimension_t
{
  int m_iWidth, m_iHeight;
};

using AREA = struct SArea_t
{
  int m_iLeft, m_iTop, m_iRight, m_iBottom;
};

using RANGE = struct SRange_t
{
  float m_flMin, m_flMax;
};

using VERTEX = struct SVertex_t
{
  float m_flX, m_flY, m_flZ, m_flW;
  unsigned long m_ulColor;
};

using COLOR = struct SColor_t
{
  SColor_t() = default;

  SColor_t(std::uint8_t red, std::uint8_t green, std::uint8_t blue, std::uint8_t alpha = 255) : m_ucRed(red), m_ucGreen(green), m_ucBlue(blue), m_ucAlpha(alpha) {}
  SColor_t(SColor_t color, std::uint8_t alpha) : m_ucRed(color.m_ucRed), m_ucGreen(color.m_ucGreen), m_ucBlue(color.m_ucBlue), m_ucAlpha(alpha) {}

  static SColor_t Interpolate(SColor_t color1, SColor_t color2, float ttt)
  {
    float flRed = color1.m_ucRed * (1.f - ttt) + (color2.m_ucRed * ttt);
    float flGreen = color1.m_ucGreen * (1.f - ttt) + (color2.m_ucGreen * ttt);
    float flBlue = color1.m_ucBlue * (1.f - ttt) + (color2.m_ucBlue * ttt);
    float flAlpha = color1.m_ucAlpha * (1.f - ttt) + (color2.m_ucAlpha * ttt);

    return SColor_t((int)flRed, (int)flGreen, (int)flBlue, (int)flAlpha);
  }

  static SColor_t HSBToRGB(float hue, float saturation, float brightness, std::uint8_t alpha = 255)
  {
    hue = std::clamp(hue, 0.f, 1.f);
    saturation = std::clamp(saturation, 0.f, 1.f);
    brightness = std::clamp(brightness, 0.f, 1.f);

    float flHue = (hue == 1.f) ? 0.f : (hue * 6.f);
    float flF = flHue - static_cast<int>(flHue);
    float flP = brightness * (1.f - saturation);
    float flQ = brightness * (1.f - saturation * flF);
    float flT = brightness * (1.f - (saturation * (1.f - flF)));

    if (flHue < 1)
    {
      return SColor_t((int)(brightness * 255), (int)(flT * 255), (int)(flP * 255), alpha);
    }
    else if (flHue < 2)
    {
      return SColor_t((int)(flQ * 255), (int)(brightness * 255), (int)(flP * 255), alpha);
    }
    else if (flHue < 3)
    {
      return SColor_t((int)(flP * 255), (int)(brightness * 255), (int)(flT * 255), alpha);
    }
    else if (flHue < 4)
    {
      return SColor_t((int)(flP * 255), (int)(flQ * 255), (int)(brightness * 255), alpha);
    }
    else if (flHue < 5)
    {
      return SColor_t((int)(flT * 255), (int)(flP * 255), (int)(brightness * 255), alpha);
    }
    else
    {
      return SColor_t((int)(brightness * 255), (int)(flP * 255), (int)(flQ * 255), alpha);
    }
  }

  static float GetHue(SColor_t color)
  {
    float flRed = (color.m_ucRed / 255.f);
    float flGreen = (color.m_ucGreen / 255.f);
    float flBlue = (color.m_ucBlue / 255.f);

    float flMax = std::fmaxf(std::fmaxf(flRed, flGreen), flBlue);
    float flMin = std::fminf(std::fminf(flRed, flGreen), flBlue);

    float flDelta = (flMax - flMin);

    if (flDelta != 0.f)
    {
      static float flHue = 0.f;

      if (flRed == flMax)
      {
        flHue = (flGreen - flBlue) / flDelta;
      }
      else
      {
        if (flGreen == flMax)
        {
          flHue = 2.f + (flBlue - flRed) / flDelta;
        }
        else
        {
          flHue = 4.f + (flRed - flGreen) / flDelta;
        }
      }

      flHue *= 60.f;

      if (flHue < 0.f)
      {
        flHue += 360.f;
      }

      return (flHue / 360.f);
    }
    else
    {
      return 0.f;
    }
  }

  std::uint8_t m_ucRed, m_ucGreen, m_ucBlue, m_ucAlpha;
};

using WIDGET_FONT = struct SWidgetFont_t
{
  std::string m_strFamily;
  int m_iSize;
  bool m_bBold;
  int m_nFlags;
};

using KEY_CODES = struct SKeyCodes_t
{
  // Valve's IInputSystem
  const std::string_view m_strInputSystem[117] = {"'", "0", "1", "2", "3", "4", "5", "6", "7",
                                                  "8", "9", "A", "B", "C", "D", "E", "F", "G", "H",
                                                  "I", "J", "K", "L", "M", "N", "O", "P", "Q", "R",
                                                  "S", "T", "U", "V", "W", "X", "Y", "Z", "NUM0",
                                                  "NUM1", "NUM2", "NUM3", "NUM4", "NUM5", "NUM6", "NUM7",
                                                  "NUM8", "NUM9", "/", "*", "-", "+", "NUMENTER", ",", "[",
                                                  "]", "Ç", "'", "´", ",", ".", "/", "\\", "-", "=",
                                                  "ENTER", "SPACE", "BACKSPACE", "TAB", "CAPSLOCK", "NUMLCK", "ESCAPE",
                                                  "SCRLK", "INSERT", "DELETE", "HOME", "END", "PAGE UP", "PAGE DOWN",
                                                  "PAUSE", "LSHIFT", "RSHIFT", "ALT", "RALT", "LCONTROL",
                                                  "RCONTROL", "LWIN", "RWIN", "APP", "UP", "LEFT", "DOWN",
                                                  "RIGHT", "F1", "F2", "F3", "F4", "F5", "F6", "F7",
                                                  "F8", "F9", "F10", "F11", "F12", "", "", "",
                                                  "MOUSE1", "MOUSE2", "MOUSE3", "MOUSE4", "MOUSE5", "", ""};

  // Windows Virtual Key Codes (VK)
  const std::string_view m_strVirtualKeyCodes[222] = {"MOUSE1", "MOUSE2", "", "MOUSE3", "MOUSE4", "MOUSE5", "",
                                                      "BACKSPACE", "TAB", "", "", "", "ENTER", "", "", "SHIFT", "CONTROL", "ALT",
                                                      "PAUSE", "CAPSLOCK", "", "", "", "", "", "", "ESC", "", "", "", "",
                                                      "SPACE", "PAGE UP", "PAGE DOWN", "END", "HOME", "LEFT", "UP", "RIGHT",
                                                      "DOWN", "", "", "", "", "INS", "DEL", "", "0", "1", "2", "3",
                                                      "4", "5", "6", "7", "8", "9", "", "", "", "", "", "", "", "A",
                                                      "B", "C", "D", "E", "F", "G", "H", "I", "J", "K", "L", "M", "N",
                                                      "O", "P", "Q", "R", "S", "T", "U", "V", "W", "X", "Y", "Z", "LWIN",
                                                      "RWIN", "", "", "", "NUM0", "NUM1", "NUM2", "NUM3", "NUM4", "NUM5",
                                                      "NUM6", "NUM7", "NUM8", "NUM9", "*", "+", "_", "-", ".", "/", "F1",
                                                      "F2", "F3", "F4", "F5", "F6", "F7", "F8", "F9", "F10", "F11", "F12",
                                                      "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
                                                      "", "", "", "", "SCROLL LOCK", "", "", "", "", "", "", "", "", "", "",
                                                      "", "", "", "", "LSHIFT", "RSHIFT", "LCONTROL", "RCONTROL", "", "",
                                                      "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
                                                      "", "", "", ";", "+", ",", "-", ".", "/?", "~", "", "", "", "", "",
                                                      "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
                                                      "", "", "", "", "{", "\\", "}", "/"};
};

using KEY_STRINGS = struct SKeyStrings_t
{
  // Valve's IInputSystem
  const std::string_view m_strInputSystem[117] = {"'", "0", "1", "2", "3", "4", "5", "6", "7",
                                                  "8", "9", "a", "b", "c", "d", "e", "f", "g", "h",
                                                  "i", "j", "k", "l", "m", "n", "o", "p", "q", "r",
                                                  "s", "t", "u", "v", "w", "x", "y", "z", "",
                                                  "", "", "", "", "", "", "",
                                                  "", "", "/", "*", "-", "+", "", ",", "[",
                                                  "]", "Ç", "'", "´", ",", ".", "/", "\\", "-", "=",
                                                  "", " ", "", "", "", "", "",
                                                  "", "", "", "", "", "", "",
                                                  "", "", "", "", "", "",
                                                  "", "", "", "", "", "", "",
                                                  "", "", "", "", "", "", "", "",
                                                  "", "", "", "", "", "", "", "",
                                                  "", "", "", "", "", "", ""};

  // Windows Virtual Key Codes (VK)
  const std::string_view m_strVirtualKeyCodes[222] = {"", "", "", "", "", "", "",
                                                      "", "", "", "", "", "", "", "", "", "", "",
                                                      "", "", "", "", "", "", "", "", "", "", "", "", "",
                                                      " ", "", "", "", "", "", "", "",
                                                      "", "", "", "", "", "", "", "", "0", "1", "2", "3",
                                                      "4", "5", "6", "7", "8", "9", "", "", "", "", "", "", "", "A",
                                                      "b", "c", "d", "e", "f", "g", "h", "i", "j", "k", "l", "m", "n",
                                                      "q", "p", "q", "r", "s", "t", "u", "v", "w", "x", "y", "z", "",
                                                      "", "", "", "", "0", "1", "2", "3", "4", "5",
                                                      "6", "7", "8", "9", "*", "+", "_", "-", ".", "/", "",
                                                      "", "", "", "", "", "", "", "", "", "", "",
                                                      "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
                                                      "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
                                                      "", "", "", "", "", "", "", "", "", "",
                                                      "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
                                                      "", "", "", ";", "+", ",", "-", ".", "/?", "~", "", "", "", "", "",
                                                      "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
                                                      "", "", "", "", "{", "\\", "}", "/"};
};

using WIDGET_TYPE = enum struct ESWidgetType_t : int {
  BUTTON = 0,
  CHECKBOX,
  GROUPBOX,
  MULTIBOX,
  SLIDER,
  KEYBINDER,
  LISTBOX,
  LABEL,
  TEXTBOX,
  COLORLIST,
  COLORPICKER
};

using WIDGET_FLAG = enum struct ESWidgetFlag_t : int {
  DRAWABLE = 0x1,
  CLICKABLE = 0x2,
  FOCUSABLE = 0x4,

  FULLSCREEN = 0x16 // this is exclusively for Forms
};

} // namespace FGUI

#endif // FGUI_DEFINITIONS_HH

```

`Lumina/Lumina/ui/fgui_/dependencies/external/tinyxml2.cpp`:

```cpp
/*
Original code by Lee Thomason (www.grinninglizard.com)

This software is provided 'as-is', without any express or implied
warranty. In no event will the authors be held liable for any
damages arising from the use of this software.

Permission is granted to anyone to use this software for any
purpose, including commercial applications, and to alter it and
redistribute it freely, subject to the following restrictions:

1. The origin of this software must not be misrepresented; you must
not claim that you wrote the original software. If you use this
software in a product, an acknowledgment in the product documentation
would be appreciated but is not required.

2. Altered source versions must be plainly marked as such, and
must not be misrepresented as being the original software.

3. This notice may not be removed or altered from any source
distribution.
*/

#include "tinyxml2.hpp"

#include <new>		// yes, this one new style header, is in the Android SDK.
#if defined(ANDROID_NDK) || defined(__BORLANDC__) || defined(__QNXNTO__)
#   include <stddef.h>
#   include <stdarg.h>
#else
#   include <cstddef>
#   include <cstdarg>
#endif

#if defined(_MSC_VER) && (_MSC_VER >= 1400 ) && (!defined WINCE)
	// Microsoft Visual Studio, version 2005 and higher. Not WinCE.
	/*int _snprintf_s(
	   char *buffer,
	   size_t sizeOfBuffer,
	   size_t count,
	   const char *format [,
		  argument] ...
	);*/
	static inline int TIXML_SNPRINTF( char* buffer, size_t size, const char* format, ... )
	{
		va_list va;
		va_start( va, format );
		const int result = vsnprintf_s( buffer, size, _TRUNCATE, format, va );
		va_end( va );
		return result;
	}

	static inline int TIXML_VSNPRINTF( char* buffer, size_t size, const char* format, va_list va )
	{
		const int result = vsnprintf_s( buffer, size, _TRUNCATE, format, va );
		return result;
	}

	#define TIXML_VSCPRINTF	_vscprintf
	#define TIXML_SSCANF	sscanf_s
#elif defined _MSC_VER
	// Microsoft Visual Studio 2003 and earlier or WinCE
	#define TIXML_SNPRINTF	_snprintf
	#define TIXML_VSNPRINTF _vsnprintf
	#define TIXML_SSCANF	sscanf
	#if (_MSC_VER < 1400 ) && (!defined WINCE)
		// Microsoft Visual Studio 2003 and not WinCE.
		#define TIXML_VSCPRINTF   _vscprintf // VS2003's C runtime has this, but VC6 C runtime or WinCE SDK doesn't have.
	#else
		// Microsoft Visual Studio 2003 and earlier or WinCE.
		static inline int TIXML_VSCPRINTF( const char* format, va_list va )
		{
			int len = 512;
			for (;;) {
				len = len*2;
				char* str = new char[len]();
				const int required = _vsnprintf(str, len, format, va);
				delete[] str;
				if ( required != -1 ) {
					TIXMLASSERT( required >= 0 );
					len = required;
					break;
				}
			}
			TIXMLASSERT( len >= 0 );
			return len;
		}
	#endif
#else
	// GCC version 3 and higher
	//#warning( "Using sn* functions." )
	#define TIXML_SNPRINTF	snprintf
	#define TIXML_VSNPRINTF	vsnprintf
	static inline int TIXML_VSCPRINTF( const char* format, va_list va )
	{
		int len = vsnprintf( 0, 0, format, va );
		TIXMLASSERT( len >= 0 );
		return len;
	}
	#define TIXML_SSCANF   sscanf
#endif


static const char LINE_FEED				= static_cast<char>(0x0a);			// all line endings are normalized to LF
static const char LF = LINE_FEED;
static const char CARRIAGE_RETURN		= static_cast<char>(0x0d);			// CR gets filtered out
static const char CR = CARRIAGE_RETURN;
static const char SINGLE_QUOTE			= '\'';
static const char DOUBLE_QUOTE			= '\"';

// Bunch of unicode info at:
//		http://www.unicode.org/faq/utf_bom.html
//	ef bb bf (Microsoft "lead bytes") - designates UTF-8

static const unsigned char TIXML_UTF_LEAD_0 = 0xefU;
static const unsigned char TIXML_UTF_LEAD_1 = 0xbbU;
static const unsigned char TIXML_UTF_LEAD_2 = 0xbfU;

namespace tinyxml2
{

struct Entity {
    const char* pattern;
    int length;
    char value;
};

static const int NUM_ENTITIES = 5;
static const Entity entities[NUM_ENTITIES] = {
    { "quot", 4,	DOUBLE_QUOTE },
    { "amp", 3,		'&'  },
    { "apos", 4,	SINGLE_QUOTE },
    { "lt",	2, 		'<'	 },
    { "gt",	2,		'>'	 }
};


StrPair::~StrPair()
{
    Reset();
}


void StrPair::TransferTo( StrPair* other )
{
    if ( this == other ) {
        return;
    }
    // This in effect implements the assignment operator by "moving"
    // ownership (as in auto_ptr).

    TIXMLASSERT( other != 0 );
    TIXMLASSERT( other->_flags == 0 );
    TIXMLASSERT( other->_start == 0 );
    TIXMLASSERT( other->_end == 0 );

    other->Reset();

    other->_flags = _flags;
    other->_start = _start;
    other->_end = _end;

    _flags = 0;
    _start = 0;
    _end = 0;
}


void StrPair::Reset()
{
    if ( _flags & NEEDS_DELETE ) {
        delete [] _start;
    }
    _flags = 0;
    _start = 0;
    _end = 0;
}


void StrPair::SetStr( const char* str, int flags )
{
    TIXMLASSERT( str );
    Reset();
    size_t len = strlen( str );
    TIXMLASSERT( _start == 0 );
    _start = new char[ len+1 ];
    memcpy( _start, str, len+1 );
    _end = _start + len;
    _flags = flags | NEEDS_DELETE;
}


char* StrPair::ParseText( char* p, const char* endTag, int strFlags, int* curLineNumPtr )
{
    TIXMLASSERT( p );
    TIXMLASSERT( endTag && *endTag );
	TIXMLASSERT(curLineNumPtr);

    char* start = p;
    const char  endChar = *endTag;
    size_t length = strlen( endTag );

    // Inner loop of text parsing.
    while ( *p ) {
        if ( *p == endChar && strncmp( p, endTag, length ) == 0 ) {
            Set( start, p, strFlags );
            return p + length;
        } else if (*p == '\n') {
            ++(*curLineNumPtr);
        }
        ++p;
        TIXMLASSERT( p );
    }
    return 0;
}


char* StrPair::ParseName( char* p )
{
    if ( !p || !(*p) ) {
        return 0;
    }
    if ( !XMLUtil::IsNameStartChar( *p ) ) {
        return 0;
    }

    char* const start = p;
    ++p;
    while ( *p && XMLUtil::IsNameChar( *p ) ) {
        ++p;
    }

    Set( start, p, 0 );
    return p;
}


void StrPair::CollapseWhitespace()
{
    // Adjusting _start would cause undefined behavior on delete[]
    TIXMLASSERT( ( _flags & NEEDS_DELETE ) == 0 );
    // Trim leading space.
    _start = XMLUtil::SkipWhiteSpace( _start, 0 );

    if ( *_start ) {
        const char* p = _start;	// the read pointer
        char* q = _start;	// the write pointer

        while( *p ) {
            if ( XMLUtil::IsWhiteSpace( *p )) {
                p = XMLUtil::SkipWhiteSpace( p, 0 );
                if ( *p == 0 ) {
                    break;    // don't write to q; this trims the trailing space.
                }
                *q = ' ';
                ++q;
            }
            *q = *p;
            ++q;
            ++p;
        }
        *q = 0;
    }
}


const char* StrPair::GetStr()
{
    TIXMLASSERT( _start );
    TIXMLASSERT( _end );
    if ( _flags & NEEDS_FLUSH ) {
        *_end = 0;
        _flags ^= NEEDS_FLUSH;

        if ( _flags ) {
            const char* p = _start;	// the read pointer
            char* q = _start;	// the write pointer

            while( p < _end ) {
                if ( (_flags & NEEDS_NEWLINE_NORMALIZATION) && *p == CR ) {
                    // CR-LF pair becomes LF
                    // CR alone becomes LF
                    // LF-CR becomes LF
                    if ( *(p+1) == LF ) {
                        p += 2;
                    }
                    else {
                        ++p;
                    }
                    *q = LF;
                    ++q;
                }
                else if ( (_flags & NEEDS_NEWLINE_NORMALIZATION) && *p == LF ) {
                    if ( *(p+1) == CR ) {
                        p += 2;
                    }
                    else {
                        ++p;
                    }
                    *q = LF;
                    ++q;
                }
                else if ( (_flags & NEEDS_ENTITY_PROCESSING) && *p == '&' ) {
                    // Entities handled by tinyXML2:
                    // - special entities in the entity table [in/out]
                    // - numeric character reference [in]
                    //   &#20013; or &#x4e2d;

                    if ( *(p+1) == '#' ) {
                        const int buflen = 10;
                        char buf[buflen] = { 0 };
                        int len = 0;
                        const char* adjusted = const_cast<char*>( XMLUtil::GetCharacterRef( p, buf, &len ) );
                        if ( adjusted == 0 ) {
                            *q = *p;
                            ++p;
                            ++q;
                        }
                        else {
                            TIXMLASSERT( 0 <= len && len <= buflen );
                            TIXMLASSERT( q + len <= adjusted );
                            p = adjusted;
                            memcpy( q, buf, len );
                            q += len;
                        }
                    }
                    else {
                        bool entityFound = false;
                        for( int i = 0; i < NUM_ENTITIES; ++i ) {
                            const Entity& entity = entities[i];
                            if ( strncmp( p + 1, entity.pattern, entity.length ) == 0
                                    && *( p + entity.length + 1 ) == ';' ) {
                                // Found an entity - convert.
                                *q = entity.value;
                                ++q;
                                p += entity.length + 2;
                                entityFound = true;
                                break;
                            }
                        }
                        if ( !entityFound ) {
                            // fixme: treat as error?
                            ++p;
                            ++q;
                        }
                    }
                }
                else {
                    *q = *p;
                    ++p;
                    ++q;
                }
            }
            *q = 0;
        }
        // The loop below has plenty going on, and this
        // is a less useful mode. Break it out.
        if ( _flags & NEEDS_WHITESPACE_COLLAPSING ) {
            CollapseWhitespace();
        }
        _flags = (_flags & NEEDS_DELETE);
    }
    TIXMLASSERT( _start );
    return _start;
}




// --------- XMLUtil ----------- //

const char* XMLUtil::writeBoolTrue  = "true";
const char* XMLUtil::writeBoolFalse = "false";

void XMLUtil::SetBoolSerialization(const char* writeTrue, const char* writeFalse)
{
	static const char* defTrue  = "true";
	static const char* defFalse = "false";

	writeBoolTrue = (writeTrue) ? writeTrue : defTrue;
	writeBoolFalse = (writeFalse) ? writeFalse : defFalse;
}


const char* XMLUtil::ReadBOM( const char* p, bool* bom )
{
    TIXMLASSERT( p );
    TIXMLASSERT( bom );
    *bom = false;
    const unsigned char* pu = reinterpret_cast<const unsigned char*>(p);
    // Check for BOM:
    if (    *(pu+0) == TIXML_UTF_LEAD_0
            && *(pu+1) == TIXML_UTF_LEAD_1
            && *(pu+2) == TIXML_UTF_LEAD_2 ) {
        *bom = true;
        p += 3;
    }
    TIXMLASSERT( p );
    return p;
}


void XMLUtil::ConvertUTF32ToUTF8( unsigned long input, char* output, int* length )
{
    const unsigned long BYTE_MASK = 0xBF;
    const unsigned long BYTE_MARK = 0x80;
    const unsigned long FIRST_BYTE_MARK[7] = { 0x00, 0x00, 0xC0, 0xE0, 0xF0, 0xF8, 0xFC };

    if (input < 0x80) {
        *length = 1;
    }
    else if ( input < 0x800 ) {
        *length = 2;
    }
    else if ( input < 0x10000 ) {
        *length = 3;
    }
    else if ( input < 0x200000 ) {
        *length = 4;
    }
    else {
        *length = 0;    // This code won't convert this correctly anyway.
        return;
    }

    output += *length;

    // Scary scary fall throughs are annotated with carefully designed comments
    // to suppress compiler warnings such as -Wimplicit-fallthrough in gcc
    switch (*length) {
        case 4:
            --output;
            *output = static_cast<char>((input | BYTE_MARK) & BYTE_MASK);
            input >>= 6;
            //fall through
        case 3:
            --output;
            *output = static_cast<char>((input | BYTE_MARK) & BYTE_MASK);
            input >>= 6;
            //fall through
        case 2:
            --output;
            *output = static_cast<char>((input | BYTE_MARK) & BYTE_MASK);
            input >>= 6;
            //fall through
        case 1:
            --output;
            *output = static_cast<char>(input | FIRST_BYTE_MARK[*length]);
            break;
        default:
            TIXMLASSERT( false );
    }
}


const char* XMLUtil::GetCharacterRef( const char* p, char* value, int* length )
{
    // Presume an entity, and pull it out.
    *length = 0;

    if ( *(p+1) == '#' && *(p+2) ) {
        unsigned long ucs = 0;
        TIXMLASSERT( sizeof( ucs ) >= 4 );
        ptrdiff_t delta = 0;
        unsigned mult = 1;
        static const char SEMICOLON = ';';

        if ( *(p+2) == 'x' ) {
            // Hexadecimal.
            const char* q = p+3;
            if ( !(*q) ) {
                return 0;
            }

            q = strchr( q, SEMICOLON );

            if ( !q ) {
                return 0;
            }
            TIXMLASSERT( *q == SEMICOLON );

            delta = q-p;
            --q;

            while ( *q != 'x' ) {
                unsigned int digit = 0;

                if ( *q >= '0' && *q <= '9' ) {
                    digit = *q - '0';
                }
                else if ( *q >= 'a' && *q <= 'f' ) {
                    digit = *q - 'a' + 10;
                }
                else if ( *q >= 'A' && *q <= 'F' ) {
                    digit = *q - 'A' + 10;
                }
                else {
                    return 0;
                }
                TIXMLASSERT( digit < 16 );
                TIXMLASSERT( digit == 0 || mult <= UINT_MAX / digit );
                const unsigned int digitScaled = mult * digit;
                TIXMLASSERT( ucs <= ULONG_MAX - digitScaled );
                ucs += digitScaled;
                TIXMLASSERT( mult <= UINT_MAX / 16 );
                mult *= 16;
                --q;
            }
        }
        else {
            // Decimal.
            const char* q = p+2;
            if ( !(*q) ) {
                return 0;
            }

            q = strchr( q, SEMICOLON );

            if ( !q ) {
                return 0;
            }
            TIXMLASSERT( *q == SEMICOLON );

            delta = q-p;
            --q;

            while ( *q != '#' ) {
                if ( *q >= '0' && *q <= '9' ) {
                    const unsigned int digit = *q - '0';
                    TIXMLASSERT( digit < 10 );
                    TIXMLASSERT( digit == 0 || mult <= UINT_MAX / digit );
                    const unsigned int digitScaled = mult * digit;
                    TIXMLASSERT( ucs <= ULONG_MAX - digitScaled );
                    ucs += digitScaled;
                }
                else {
                    return 0;
                }
                TIXMLASSERT( mult <= UINT_MAX / 10 );
                mult *= 10;
                --q;
            }
        }
        // convert the UCS to UTF-8
        ConvertUTF32ToUTF8( ucs, value, length );
        return p + delta + 1;
    }
    return p+1;
}


void XMLUtil::ToStr( int v, char* buffer, int bufferSize )
{
    TIXML_SNPRINTF( buffer, bufferSize, "%d", v );
}


void XMLUtil::ToStr( unsigned v, char* buffer, int bufferSize )
{
    TIXML_SNPRINTF( buffer, bufferSize, "%u", v );
}


void XMLUtil::ToStr( bool v, char* buffer, int bufferSize )
{
    TIXML_SNPRINTF( buffer, bufferSize, "%s", v ? writeBoolTrue : writeBoolFalse);
}

/*
	ToStr() of a number is a very tricky topic.
	https://github.com/leethomason/tinyxml2/issues/106
*/
void XMLUtil::ToStr( float v, char* buffer, int bufferSize )
{
    TIXML_SNPRINTF( buffer, bufferSize, "%.8g", v );
}


void XMLUtil::ToStr( double v, char* buffer, int bufferSize )
{
    TIXML_SNPRINTF( buffer, bufferSize, "%.17g", v );
}


void XMLUtil::ToStr( int64_t v, char* buffer, int bufferSize )
{
	// horrible syntax trick to make the compiler happy about %lld
	TIXML_SNPRINTF(buffer, bufferSize, "%lld", static_cast<long long>(v));
}

void XMLUtil::ToStr( uint64_t v, char* buffer, int bufferSize )
{
    // horrible syntax trick to make the compiler happy about %llu
    TIXML_SNPRINTF(buffer, bufferSize, "%llu", (long long)v);
}

bool XMLUtil::ToInt( const char* str, int* value )
{
    if ( TIXML_SSCANF( str, "%d", value ) == 1 ) {
        return true;
    }
    return false;
}

bool XMLUtil::ToUnsigned( const char* str, unsigned *value )
{
    if ( TIXML_SSCANF( str, "%u", value ) == 1 ) {
        return true;
    }
    return false;
}

bool XMLUtil::ToBool( const char* str, bool* value )
{
    int ival = 0;
    if ( ToInt( str, &ival )) {
        *value = (ival==0) ? false : true;
        return true;
    }
    static const char* TRUE_VALS[] = { "true", "True", "TRUE", 0 };
    static const char* FALSE_VALS[] = { "false", "False", "FALSE", 0 };

    for (int i = 0; TRUE_VALS[i]; ++i) {
        if (StringEqual(str, TRUE_VALS[i])) {
            *value = true;
            return true;
        }
    }
    for (int i = 0; FALSE_VALS[i]; ++i) {
        if (StringEqual(str, FALSE_VALS[i])) {
            *value = false;
            return true;
        }
    }
    return false;
}


bool XMLUtil::ToFloat( const char* str, float* value )
{
    if ( TIXML_SSCANF( str, "%f", value ) == 1 ) {
        return true;
    }
    return false;
}


bool XMLUtil::ToDouble( const char* str, double* value )
{
    if ( TIXML_SSCANF( str, "%lf", value ) == 1 ) {
        return true;
    }
    return false;
}


bool XMLUtil::ToInt64(const char* str, int64_t* value)
{
	long long v = 0;	// horrible syntax trick to make the compiler happy about %lld
	if (TIXML_SSCANF(str, "%lld", &v) == 1) {
		*value = static_cast<int64_t>(v);
		return true;
	}
	return false;
}


bool XMLUtil::ToUnsigned64(const char* str, uint64_t* value) {
    unsigned long long v = 0;	// horrible syntax trick to make the compiler happy about %llu
    if(TIXML_SSCANF(str, "%llu", &v) == 1) {
        *value = (uint64_t)v;
        return true;
    }
    return false;
}


char* XMLDocument::Identify( char* p, XMLNode** node )
{
    TIXMLASSERT( node );
    TIXMLASSERT( p );
    char* const start = p;
    int const startLine = _parseCurLineNum;
    p = XMLUtil::SkipWhiteSpace( p, &_parseCurLineNum );
    if( !*p ) {
        *node = 0;
        TIXMLASSERT( p );
        return p;
    }

    // These strings define the matching patterns:
    static const char* xmlHeader		= { "<?" };
    static const char* commentHeader	= { "<!--" };
    static const char* cdataHeader		= { "<![CDATA[" };
    static const char* dtdHeader		= { "<!" };
    static const char* elementHeader	= { "<" };	// and a header for everything else; check last.

    static const int xmlHeaderLen		= 2;
    static const int commentHeaderLen	= 4;
    static const int cdataHeaderLen		= 9;
    static const int dtdHeaderLen		= 2;
    static const int elementHeaderLen	= 1;

    TIXMLASSERT( sizeof( XMLComment ) == sizeof( XMLUnknown ) );		// use same memory pool
    TIXMLASSERT( sizeof( XMLComment ) == sizeof( XMLDeclaration ) );	// use same memory pool
    XMLNode* returnNode = 0;
    if ( XMLUtil::StringEqual( p, xmlHeader, xmlHeaderLen ) ) {
        returnNode = CreateUnlinkedNode<XMLDeclaration>( _commentPool );
        returnNode->_parseLineNum = _parseCurLineNum;
        p += xmlHeaderLen;
    }
    else if ( XMLUtil::StringEqual( p, commentHeader, commentHeaderLen ) ) {
        returnNode = CreateUnlinkedNode<XMLComment>( _commentPool );
        returnNode->_parseLineNum = _parseCurLineNum;
        p += commentHeaderLen;
    }
    else if ( XMLUtil::StringEqual( p, cdataHeader, cdataHeaderLen ) ) {
        XMLText* text = CreateUnlinkedNode<XMLText>( _textPool );
        returnNode = text;
        returnNode->_parseLineNum = _parseCurLineNum;
        p += cdataHeaderLen;
        text->SetCData( true );
    }
    else if ( XMLUtil::StringEqual( p, dtdHeader, dtdHeaderLen ) ) {
        returnNode = CreateUnlinkedNode<XMLUnknown>( _commentPool );
        returnNode->_parseLineNum = _parseCurLineNum;
        p += dtdHeaderLen;
    }
    else if ( XMLUtil::StringEqual( p, elementHeader, elementHeaderLen ) ) {
        returnNode =  CreateUnlinkedNode<XMLElement>( _elementPool );
        returnNode->_parseLineNum = _parseCurLineNum;
        p += elementHeaderLen;
    }
    else {
        returnNode = CreateUnlinkedNode<XMLText>( _textPool );
        returnNode->_parseLineNum = _parseCurLineNum; // Report line of first non-whitespace character
        p = start;	// Back it up, all the text counts.
        _parseCurLineNum = startLine;
    }

    TIXMLASSERT( returnNode );
    TIXMLASSERT( p );
    *node = returnNode;
    return p;
}


bool XMLDocument::Accept( XMLVisitor* visitor ) const
{
    TIXMLASSERT( visitor );
    if ( visitor->VisitEnter( *this ) ) {
        for ( const XMLNode* node=FirstChild(); node; node=node->NextSibling() ) {
            if ( !node->Accept( visitor ) ) {
                break;
            }
        }
    }
    return visitor->VisitExit( *this );
}


// --------- XMLNode ----------- //

XMLNode::XMLNode( XMLDocument* doc ) :
    _document( doc ),
    _parent( 0 ),
    _value(),
    _parseLineNum( 0 ),
    _firstChild( 0 ), _lastChild( 0 ),
    _prev( 0 ), _next( 0 ),
	_userData( 0 ),
    _memPool( 0 )
{
}


XMLNode::~XMLNode()
{
    DeleteChildren();
    if ( _parent ) {
        _parent->Unlink( this );
    }
}

const char* XMLNode::Value() const
{
    // Edge case: XMLDocuments don't have a Value. Return null.
    if ( this->ToDocument() )
        return 0;
    return _value.GetStr();
}

void XMLNode::SetValue( const char* str, bool staticMem )
{
    if ( staticMem ) {
        _value.SetInternedStr( str );
    }
    else {
        _value.SetStr( str );
    }
}

XMLNode* XMLNode::DeepClone(XMLDocument* target) const
{
	XMLNode* clone = this->ShallowClone(target);
	if (!clone) return 0;

	for (const XMLNode* child = this->FirstChild(); child; child = child->NextSibling()) {
		XMLNode* childClone = child->DeepClone(target);
		TIXMLASSERT(childClone);
		clone->InsertEndChild(childClone);
	}
	return clone;
}

void XMLNode::DeleteChildren()
{
    while( _firstChild ) {
        TIXMLASSERT( _lastChild );
        DeleteChild( _firstChild );
    }
    _firstChild = _lastChild = 0;
}


void XMLNode::Unlink( XMLNode* child )
{
    TIXMLASSERT( child );
    TIXMLASSERT( child->_document == _document );
    TIXMLASSERT( child->_parent == this );
    if ( child == _firstChild ) {
        _firstChild = _firstChild->_next;
    }
    if ( child == _lastChild ) {
        _lastChild = _lastChild->_prev;
    }

    if ( child->_prev ) {
        child->_prev->_next = child->_next;
    }
    if ( child->_next ) {
        child->_next->_prev = child->_prev;
    }
	child->_next = 0;
	child->_prev = 0;
	child->_parent = 0;
}


void XMLNode::DeleteChild( XMLNode* node )
{
    TIXMLASSERT( node );
    TIXMLASSERT( node->_document == _document );
    TIXMLASSERT( node->_parent == this );
    Unlink( node );
	TIXMLASSERT(node->_prev == 0);
	TIXMLASSERT(node->_next == 0);
	TIXMLASSERT(node->_parent == 0);
    DeleteNode( node );
}


XMLNode* XMLNode::InsertEndChild( XMLNode* addThis )
{
    TIXMLASSERT( addThis );
    if ( addThis->_document != _document ) {
        TIXMLASSERT( false );
        return 0;
    }
    InsertChildPreamble( addThis );

    if ( _lastChild ) {
        TIXMLASSERT( _firstChild );
        TIXMLASSERT( _lastChild->_next == 0 );
        _lastChild->_next = addThis;
        addThis->_prev = _lastChild;
        _lastChild = addThis;

        addThis->_next = 0;
    }
    else {
        TIXMLASSERT( _firstChild == 0 );
        _firstChild = _lastChild = addThis;

        addThis->_prev = 0;
        addThis->_next = 0;
    }
    addThis->_parent = this;
    return addThis;
}


XMLNode* XMLNode::InsertFirstChild( XMLNode* addThis )
{
    TIXMLASSERT( addThis );
    if ( addThis->_document != _document ) {
        TIXMLASSERT( false );
        return 0;
    }
    InsertChildPreamble( addThis );

    if ( _firstChild ) {
        TIXMLASSERT( _lastChild );
        TIXMLASSERT( _firstChild->_prev == 0 );

        _firstChild->_prev = addThis;
        addThis->_next = _firstChild;
        _firstChild = addThis;

        addThis->_prev = 0;
    }
    else {
        TIXMLASSERT( _lastChild == 0 );
        _firstChild = _lastChild = addThis;

        addThis->_prev = 0;
        addThis->_next = 0;
    }
    addThis->_parent = this;
    return addThis;
}


XMLNode* XMLNode::InsertAfterChild( XMLNode* afterThis, XMLNode* addThis )
{
    TIXMLASSERT( addThis );
    if ( addThis->_document != _document ) {
        TIXMLASSERT( false );
        return 0;
    }

    TIXMLASSERT( afterThis );

    if ( afterThis->_parent != this ) {
        TIXMLASSERT( false );
        return 0;
    }
    if ( afterThis == addThis ) {
        // Current state: BeforeThis -> AddThis -> OneAfterAddThis
        // Now AddThis must disappear from it's location and then
        // reappear between BeforeThis and OneAfterAddThis.
        // So just leave it where it is.
        return addThis;
    }

    if ( afterThis->_next == 0 ) {
        // The last node or the only node.
        return InsertEndChild( addThis );
    }
    InsertChildPreamble( addThis );
    addThis->_prev = afterThis;
    addThis->_next = afterThis->_next;
    afterThis->_next->_prev = addThis;
    afterThis->_next = addThis;
    addThis->_parent = this;
    return addThis;
}




const XMLElement* XMLNode::FirstChildElement( const char* name ) const
{
    for( const XMLNode* node = _firstChild; node; node = node->_next ) {
        const XMLElement* element = node->ToElementWithName( name );
        if ( element ) {
            return element;
        }
    }
    return 0;
}


const XMLElement* XMLNode::LastChildElement( const char* name ) const
{
    for( const XMLNode* node = _lastChild; node; node = node->_prev ) {
        const XMLElement* element = node->ToElementWithName( name );
        if ( element ) {
            return element;
        }
    }
    return 0;
}


const XMLElement* XMLNode::NextSiblingElement( const char* name ) const
{
    for( const XMLNode* node = _next; node; node = node->_next ) {
        const XMLElement* element = node->ToElementWithName( name );
        if ( element ) {
            return element;
        }
    }
    return 0;
}


const XMLElement* XMLNode::PreviousSiblingElement( const char* name ) const
{
    for( const XMLNode* node = _prev; node; node = node->_prev ) {
        const XMLElement* element = node->ToElementWithName( name );
        if ( element ) {
            return element;
        }
    }
    return 0;
}


char* XMLNode::ParseDeep( char* p, StrPair* parentEndTag, int* curLineNumPtr )
{
    // This is a recursive method, but thinking about it "at the current level"
    // it is a pretty simple flat list:
    //		<foo/>
    //		<!-- comment -->
    //
    // With a special case:
    //		<foo>
    //		</foo>
    //		<!-- comment -->
    //
    // Where the closing element (/foo) *must* be the next thing after the opening
    // element, and the names must match. BUT the tricky bit is that the closing
    // element will be read by the child.
    //
    // 'endTag' is the end tag for this node, it is returned by a call to a child.
    // 'parentEnd' is the end tag for the parent, which is filled in and returned.

	XMLDocument::DepthTracker tracker(_document);
	if (_document->Error())
		return 0;

	while( p && *p ) {
        XMLNode* node = 0;

        p = _document->Identify( p, &node );
        TIXMLASSERT( p );
        if ( node == 0 ) {
            break;
        }

       const int initialLineNum = node->_parseLineNum;

        StrPair endTag;
        p = node->ParseDeep( p, &endTag, curLineNumPtr );
        if ( !p ) {
            DeleteNode( node );
            if ( !_document->Error() ) {
                _document->SetError( XML_ERROR_PARSING, initialLineNum, 0);
            }
            break;
        }

        const XMLDeclaration* const decl = node->ToDeclaration();
        if ( decl ) {
            // Declarations are only allowed at document level
            //
            // Multiple declarations are allowed but all declarations
            // must occur before anything else. 
            //
            // Optimized due to a security test case. If the first node is 
            // a declaration, and the last node is a declaration, then only 
            // declarations have so far been added.
            bool wellLocated = false;

            if (ToDocument()) {
                if (FirstChild()) {
                    wellLocated =
                        FirstChild() &&
                        FirstChild()->ToDeclaration() &&
                        LastChild() &&
                        LastChild()->ToDeclaration();
                }
                else {
                    wellLocated = true;
                }
            }
            if ( !wellLocated ) {
                _document->SetError( XML_ERROR_PARSING_DECLARATION, initialLineNum, "XMLDeclaration value=%s", decl->Value());
                DeleteNode( node );
                break;
            }
        }

        XMLElement* ele = node->ToElement();
        if ( ele ) {
            // We read the end tag. Return it to the parent.
            if ( ele->ClosingType() == XMLElement::CLOSING ) {
                if ( parentEndTag ) {
                    ele->_value.TransferTo( parentEndTag );
                }
                node->_memPool->SetTracked();   // created and then immediately deleted.
                DeleteNode( node );
                return p;
            }

            // Handle an end tag returned to this level.
            // And handle a bunch of annoying errors.
            bool mismatch = false;
            if ( endTag.Empty() ) {
                if ( ele->ClosingType() == XMLElement::OPEN ) {
                    mismatch = true;
                }
            }
            else {
                if ( ele->ClosingType() != XMLElement::OPEN ) {
                    mismatch = true;
                }
                else if ( !XMLUtil::StringEqual( endTag.GetStr(), ele->Name() ) ) {
                    mismatch = true;
                }
            }
            if ( mismatch ) {
                _document->SetError( XML_ERROR_MISMATCHED_ELEMENT, initialLineNum, "XMLElement name=%s", ele->Name());
                DeleteNode( node );
                break;
            }
        }
        InsertEndChild( node );
    }
    return 0;
}

/*static*/ void XMLNode::DeleteNode( XMLNode* node )
{
    if ( node == 0 ) {
        return;
    }
	TIXMLASSERT(node->_document);
	if (!node->ToDocument()) {
		node->_document->MarkInUse(node);
	}

    MemPool* pool = node->_memPool;
    node->~XMLNode();
    pool->Free( node );
}

void XMLNode::InsertChildPreamble( XMLNode* insertThis ) const
{
    TIXMLASSERT( insertThis );
    TIXMLASSERT( insertThis->_document == _document );

	if (insertThis->_parent) {
        insertThis->_parent->Unlink( insertThis );
	}
	else {
		insertThis->_document->MarkInUse(insertThis);
        insertThis->_memPool->SetTracked();
	}
}

const XMLElement* XMLNode::ToElementWithName( const char* name ) const
{
    const XMLElement* element = this->ToElement();
    if ( element == 0 ) {
        return 0;
    }
    if ( name == 0 ) {
        return element;
    }
    if ( XMLUtil::StringEqual( element->Name(), name ) ) {
       return element;
    }
    return 0;
}

// --------- XMLText ---------- //
char* XMLText::ParseDeep( char* p, StrPair*, int* curLineNumPtr )
{
    if ( this->CData() ) {
        p = _value.ParseText( p, "]]>", StrPair::NEEDS_NEWLINE_NORMALIZATION, curLineNumPtr );
        if ( !p ) {
            _document->SetError( XML_ERROR_PARSING_CDATA, _parseLineNum, 0 );
        }
        return p;
    }
    else {
        int flags = _document->ProcessEntities() ? StrPair::TEXT_ELEMENT : StrPair::TEXT_ELEMENT_LEAVE_ENTITIES;
        if ( _document->WhitespaceMode() == COLLAPSE_WHITESPACE ) {
            flags |= StrPair::NEEDS_WHITESPACE_COLLAPSING;
        }

        p = _value.ParseText( p, "<", flags, curLineNumPtr );
        if ( p && *p ) {
            return p-1;
        }
        if ( !p ) {
            _document->SetError( XML_ERROR_PARSING_TEXT, _parseLineNum, 0 );
        }
    }
    return 0;
}


XMLNode* XMLText::ShallowClone( XMLDocument* doc ) const
{
    if ( !doc ) {
        doc = _document;
    }
    XMLText* text = doc->NewText( Value() );	// fixme: this will always allocate memory. Intern?
    text->SetCData( this->CData() );
    return text;
}


bool XMLText::ShallowEqual( const XMLNode* compare ) const
{
    TIXMLASSERT( compare );
    const XMLText* text = compare->ToText();
    return ( text && XMLUtil::StringEqual( text->Value(), Value() ) );
}


bool XMLText::Accept( XMLVisitor* visitor ) const
{
    TIXMLASSERT( visitor );
    return visitor->Visit( *this );
}


// --------- XMLComment ---------- //

XMLComment::XMLComment( XMLDocument* doc ) : XMLNode( doc )
{
}


XMLComment::~XMLComment()
{
}


char* XMLComment::ParseDeep( char* p, StrPair*, int* curLineNumPtr )
{
    // Comment parses as text.
    p = _value.ParseText( p, "-->", StrPair::COMMENT, curLineNumPtr );
    if ( p == 0 ) {
        _document->SetError( XML_ERROR_PARSING_COMMENT, _parseLineNum, 0 );
    }
    return p;
}


XMLNode* XMLComment::ShallowClone( XMLDocument* doc ) const
{
    if ( !doc ) {
        doc = _document;
    }
    XMLComment* comment = doc->NewComment( Value() );	// fixme: this will always allocate memory. Intern?
    return comment;
}


bool XMLComment::ShallowEqual( const XMLNode* compare ) const
{
    TIXMLASSERT( compare );
    const XMLComment* comment = compare->ToComment();
    return ( comment && XMLUtil::StringEqual( comment->Value(), Value() ));
}


bool XMLComment::Accept( XMLVisitor* visitor ) const
{
    TIXMLASSERT( visitor );
    return visitor->Visit( *this );
}


// --------- XMLDeclaration ---------- //

XMLDeclaration::XMLDeclaration( XMLDocument* doc ) : XMLNode( doc )
{
}


XMLDeclaration::~XMLDeclaration()
{
    //printf( "~XMLDeclaration\n" );
}


char* XMLDeclaration::ParseDeep( char* p, StrPair*, int* curLineNumPtr )
{
    // Declaration parses as text.
    p = _value.ParseText( p, "?>", StrPair::NEEDS_NEWLINE_NORMALIZATION, curLineNumPtr );
    if ( p == 0 ) {
        _document->SetError( XML_ERROR_PARSING_DECLARATION, _parseLineNum, 0 );
    }
    return p;
}


XMLNode* XMLDeclaration::ShallowClone( XMLDocument* doc ) const
{
    if ( !doc ) {
        doc = _document;
    }
    XMLDeclaration* dec = doc->NewDeclaration( Value() );	// fixme: this will always allocate memory. Intern?
    return dec;
}


bool XMLDeclaration::ShallowEqual( const XMLNode* compare ) const
{
    TIXMLASSERT( compare );
    const XMLDeclaration* declaration = compare->ToDeclaration();
    return ( declaration && XMLUtil::StringEqual( declaration->Value(), Value() ));
}



bool XMLDeclaration::Accept( XMLVisitor* visitor ) const
{
    TIXMLASSERT( visitor );
    return visitor->Visit( *this );
}

// --------- XMLUnknown ---------- //

XMLUnknown::XMLUnknown( XMLDocument* doc ) : XMLNode( doc )
{
}


XMLUnknown::~XMLUnknown()
{
}


char* XMLUnknown::ParseDeep( char* p, StrPair*, int* curLineNumPtr )
{
    // Unknown parses as text.
    p = _value.ParseText( p, ">", StrPair::NEEDS_NEWLINE_NORMALIZATION, curLineNumPtr );
    if ( !p ) {
        _document->SetError( XML_ERROR_PARSING_UNKNOWN, _parseLineNum, 0 );
    }
    return p;
}


XMLNode* XMLUnknown::ShallowClone( XMLDocument* doc ) const
{
    if ( !doc ) {
        doc = _document;
    }
    XMLUnknown* text = doc->NewUnknown( Value() );	// fixme: this will always allocate memory. Intern?
    return text;
}


bool XMLUnknown::ShallowEqual( const XMLNode* compare ) const
{
    TIXMLASSERT( compare );
    const XMLUnknown* unknown = compare->ToUnknown();
    return ( unknown && XMLUtil::StringEqual( unknown->Value(), Value() ));
}


bool XMLUnknown::Accept( XMLVisitor* visitor ) const
{
    TIXMLASSERT( visitor );
    return visitor->Visit( *this );
}

// --------- XMLAttribute ---------- //

const char* XMLAttribute::Name() const
{
    return _name.GetStr();
}

const char* XMLAttribute::Value() const
{
    return _value.GetStr();
}

char* XMLAttribute::ParseDeep( char* p, bool processEntities, int* curLineNumPtr )
{
    // Parse using the name rules: bug fix, was using ParseText before
    p = _name.ParseName( p );
    if ( !p || !*p ) {
        return 0;
    }

    // Skip white space before =
    p = XMLUtil::SkipWhiteSpace( p, curLineNumPtr );
    if ( *p != '=' ) {
        return 0;
    }

    ++p;	// move up to opening quote
    p = XMLUtil::SkipWhiteSpace( p, curLineNumPtr );
    if ( *p != '\"' && *p != '\'' ) {
        return 0;
    }

    const char endTag[2] = { *p, 0 };
    ++p;	// move past opening quote

    p = _value.ParseText( p, endTag, processEntities ? StrPair::ATTRIBUTE_VALUE : StrPair::ATTRIBUTE_VALUE_LEAVE_ENTITIES, curLineNumPtr );
    return p;
}


void XMLAttribute::SetName( const char* n )
{
    _name.SetStr( n );
}


XMLError XMLAttribute::QueryIntValue( int* value ) const
{
    if ( XMLUtil::ToInt( Value(), value )) {
        return XML_SUCCESS;
    }
    return XML_WRONG_ATTRIBUTE_TYPE;
}


XMLError XMLAttribute::QueryUnsignedValue( unsigned int* value ) const
{
    if ( XMLUtil::ToUnsigned( Value(), value )) {
        return XML_SUCCESS;
    }
    return XML_WRONG_ATTRIBUTE_TYPE;
}


XMLError XMLAttribute::QueryInt64Value(int64_t* value) const
{
	if (XMLUtil::ToInt64(Value(), value)) {
		return XML_SUCCESS;
	}
	return XML_WRONG_ATTRIBUTE_TYPE;
}


XMLError XMLAttribute::QueryUnsigned64Value(uint64_t* value) const
{
    if(XMLUtil::ToUnsigned64(Value(), value)) {
        return XML_SUCCESS;
    }
    return XML_WRONG_ATTRIBUTE_TYPE;
}


XMLError XMLAttribute::QueryBoolValue( bool* value ) const
{
    if ( XMLUtil::ToBool( Value(), value )) {
        return XML_SUCCESS;
    }
    return XML_WRONG_ATTRIBUTE_TYPE;
}


XMLError XMLAttribute::QueryFloatValue( float* value ) const
{
    if ( XMLUtil::ToFloat( Value(), value )) {
        return XML_SUCCESS;
    }
    return XML_WRONG_ATTRIBUTE_TYPE;
}


XMLError XMLAttribute::QueryDoubleValue( double* value ) const
{
    if ( XMLUtil::ToDouble( Value(), value )) {
        return XML_SUCCESS;
    }
    return XML_WRONG_ATTRIBUTE_TYPE;
}


void XMLAttribute::SetAttribute( const char* v )
{
    _value.SetStr( v );
}


void XMLAttribute::SetAttribute( int v )
{
    char buf[BUF_SIZE];
    XMLUtil::ToStr( v, buf, BUF_SIZE );
    _value.SetStr( buf );
}


void XMLAttribute::SetAttribute( unsigned v )
{
    char buf[BUF_SIZE];
    XMLUtil::ToStr( v, buf, BUF_SIZE );
    _value.SetStr( buf );
}


void XMLAttribute::SetAttribute(int64_t v)
{
	char buf[BUF_SIZE];
	XMLUtil::ToStr(v, buf, BUF_SIZE);
	_value.SetStr(buf);
}

void XMLAttribute::SetAttribute(uint64_t v)
{
    char buf[BUF_SIZE];
    XMLUtil::ToStr(v, buf, BUF_SIZE);
    _value.SetStr(buf);
}


void XMLAttribute::SetAttribute( bool v )
{
    char buf[BUF_SIZE];
    XMLUtil::ToStr( v, buf, BUF_SIZE );
    _value.SetStr( buf );
}

void XMLAttribute::SetAttribute( double v )
{
    char buf[BUF_SIZE];
    XMLUtil::ToStr( v, buf, BUF_SIZE );
    _value.SetStr( buf );
}

void XMLAttribute::SetAttribute( float v )
{
    char buf[BUF_SIZE];
    XMLUtil::ToStr( v, buf, BUF_SIZE );
    _value.SetStr( buf );
}


// --------- XMLElement ---------- //
XMLElement::XMLElement( XMLDocument* doc ) : XMLNode( doc ),
    _closingType( OPEN ),
    _rootAttribute( 0 )
{
}


XMLElement::~XMLElement()
{
    while( _rootAttribute ) {
        XMLAttribute* next = _rootAttribute->_next;
        DeleteAttribute( _rootAttribute );
        _rootAttribute = next;
    }
}


const XMLAttribute* XMLElement::FindAttribute( const char* name ) const
{
    for( XMLAttribute* a = _rootAttribute; a; a = a->_next ) {
        if ( XMLUtil::StringEqual( a->Name(), name ) ) {
            return a;
        }
    }
    return 0;
}


const char* XMLElement::Attribute( const char* name, const char* value ) const
{
    const XMLAttribute* a = FindAttribute( name );
    if ( !a ) {
        return 0;
    }
    if ( !value || XMLUtil::StringEqual( a->Value(), value )) {
        return a->Value();
    }
    return 0;
}

int XMLElement::IntAttribute(const char* name, int defaultValue) const
{
	int i = defaultValue;
	QueryIntAttribute(name, &i);
	return i;
}

unsigned XMLElement::UnsignedAttribute(const char* name, unsigned defaultValue) const
{
	unsigned i = defaultValue;
	QueryUnsignedAttribute(name, &i);
	return i;
}

int64_t XMLElement::Int64Attribute(const char* name, int64_t defaultValue) const
{
	int64_t i = defaultValue;
	QueryInt64Attribute(name, &i);
	return i;
}

uint64_t XMLElement::Unsigned64Attribute(const char* name, uint64_t defaultValue) const
{
	uint64_t i = defaultValue;
	QueryUnsigned64Attribute(name, &i);
	return i;
}

bool XMLElement::BoolAttribute(const char* name, bool defaultValue) const
{
	bool b = defaultValue;
	QueryBoolAttribute(name, &b);
	return b;
}

double XMLElement::DoubleAttribute(const char* name, double defaultValue) const
{
	double d = defaultValue;
	QueryDoubleAttribute(name, &d);
	return d;
}

float XMLElement::FloatAttribute(const char* name, float defaultValue) const
{
	float f = defaultValue;
	QueryFloatAttribute(name, &f);
	return f;
}

const char* XMLElement::GetText() const
{
    if ( FirstChild() && FirstChild()->ToText() ) {
        return FirstChild()->Value();
    }
    return 0;
}


void	XMLElement::SetText( const char* inText )
{
	if ( FirstChild() && FirstChild()->ToText() )
		FirstChild()->SetValue( inText );
	else {
		XMLText*	theText = GetDocument()->NewText( inText );
		InsertFirstChild( theText );
	}
}


void XMLElement::SetText( int v )
{
    char buf[BUF_SIZE];
    XMLUtil::ToStr( v, buf, BUF_SIZE );
    SetText( buf );
}


void XMLElement::SetText( unsigned v )
{
    char buf[BUF_SIZE];
    XMLUtil::ToStr( v, buf, BUF_SIZE );
    SetText( buf );
}


void XMLElement::SetText(int64_t v)
{
	char buf[BUF_SIZE];
	XMLUtil::ToStr(v, buf, BUF_SIZE);
	SetText(buf);
}

void XMLElement::SetText(uint64_t v) {
    char buf[BUF_SIZE];
    XMLUtil::ToStr(v, buf, BUF_SIZE);
    SetText(buf);
}


void XMLElement::SetText( bool v )
{
    char buf[BUF_SIZE];
    XMLUtil::ToStr( v, buf, BUF_SIZE );
    SetText( buf );
}


void XMLElement::SetText( float v )
{
    char buf[BUF_SIZE];
    XMLUtil::ToStr( v, buf, BUF_SIZE );
    SetText( buf );
}


void XMLElement::SetText( double v )
{
    char buf[BUF_SIZE];
    XMLUtil::ToStr( v, buf, BUF_SIZE );
    SetText( buf );
}


XMLError XMLElement::QueryIntText( int* ival ) const
{
    if ( FirstChild() && FirstChild()->ToText() ) {
        const char* t = FirstChild()->Value();
        if ( XMLUtil::ToInt( t, ival ) ) {
            return XML_SUCCESS;
        }
        return XML_CAN_NOT_CONVERT_TEXT;
    }
    return XML_NO_TEXT_NODE;
}


XMLError XMLElement::QueryUnsignedText( unsigned* uval ) const
{
    if ( FirstChild() && FirstChild()->ToText() ) {
        const char* t = FirstChild()->Value();
        if ( XMLUtil::ToUnsigned( t, uval ) ) {
            return XML_SUCCESS;
        }
        return XML_CAN_NOT_CONVERT_TEXT;
    }
    return XML_NO_TEXT_NODE;
}


XMLError XMLElement::QueryInt64Text(int64_t* ival) const
{
	if (FirstChild() && FirstChild()->ToText()) {
		const char* t = FirstChild()->Value();
		if (XMLUtil::ToInt64(t, ival)) {
			return XML_SUCCESS;
		}
		return XML_CAN_NOT_CONVERT_TEXT;
	}
	return XML_NO_TEXT_NODE;
}


XMLError XMLElement::QueryUnsigned64Text(uint64_t* ival) const
{
    if(FirstChild() && FirstChild()->ToText()) {
        const char* t = FirstChild()->Value();
        if(XMLUtil::ToUnsigned64(t, ival)) {
            return XML_SUCCESS;
        }
        return XML_CAN_NOT_CONVERT_TEXT;
    }
    return XML_NO_TEXT_NODE;
}


XMLError XMLElement::QueryBoolText( bool* bval ) const
{
    if ( FirstChild() && FirstChild()->ToText() ) {
        const char* t = FirstChild()->Value();
        if ( XMLUtil::ToBool( t, bval ) ) {
            return XML_SUCCESS;
        }
        return XML_CAN_NOT_CONVERT_TEXT;
    }
    return XML_NO_TEXT_NODE;
}


XMLError XMLElement::QueryDoubleText( double* dval ) const
{
    if ( FirstChild() && FirstChild()->ToText() ) {
        const char* t = FirstChild()->Value();
        if ( XMLUtil::ToDouble( t, dval ) ) {
            return XML_SUCCESS;
        }
        return XML_CAN_NOT_CONVERT_TEXT;
    }
    return XML_NO_TEXT_NODE;
}


XMLError XMLElement::QueryFloatText( float* fval ) const
{
    if ( FirstChild() && FirstChild()->ToText() ) {
        const char* t = FirstChild()->Value();
        if ( XMLUtil::ToFloat( t, fval ) ) {
            return XML_SUCCESS;
        }
        return XML_CAN_NOT_CONVERT_TEXT;
    }
    return XML_NO_TEXT_NODE;
}

int XMLElement::IntText(int defaultValue) const
{
	int i = defaultValue;
	QueryIntText(&i);
	return i;
}

unsigned XMLElement::UnsignedText(unsigned defaultValue) const
{
	unsigned i = defaultValue;
	QueryUnsignedText(&i);
	return i;
}

int64_t XMLElement::Int64Text(int64_t defaultValue) const
{
	int64_t i = defaultValue;
	QueryInt64Text(&i);
	return i;
}

uint64_t XMLElement::Unsigned64Text(uint64_t defaultValue) const
{
	uint64_t i = defaultValue;
	QueryUnsigned64Text(&i);
	return i;
}

bool XMLElement::BoolText(bool defaultValue) const
{
	bool b = defaultValue;
	QueryBoolText(&b);
	return b;
}

double XMLElement::DoubleText(double defaultValue) const
{
	double d = defaultValue;
	QueryDoubleText(&d);
	return d;
}

float XMLElement::FloatText(float defaultValue) const
{
	float f = defaultValue;
	QueryFloatText(&f);
	return f;
}


XMLAttribute* XMLElement::FindOrCreateAttribute( const char* name )
{
    XMLAttribute* last = 0;
    XMLAttribute* attrib = 0;
    for( attrib = _rootAttribute;
            attrib;
            last = attrib, attrib = attrib->_next ) {
        if ( XMLUtil::StringEqual( attrib->Name(), name ) ) {
            break;
        }
    }
    if ( !attrib ) {
        attrib = CreateAttribute();
        TIXMLASSERT( attrib );
        if ( last ) {
            TIXMLASSERT( last->_next == 0 );
            last->_next = attrib;
        }
        else {
            TIXMLASSERT( _rootAttribute == 0 );
            _rootAttribute = attrib;
        }
        attrib->SetName( name );
    }
    return attrib;
}


void XMLElement::DeleteAttribute( const char* name )
{
    XMLAttribute* prev = 0;
    for( XMLAttribute* a=_rootAttribute; a; a=a->_next ) {
        if ( XMLUtil::StringEqual( name, a->Name() ) ) {
            if ( prev ) {
                prev->_next = a->_next;
            }
            else {
                _rootAttribute = a->_next;
            }
            DeleteAttribute( a );
            break;
        }
        prev = a;
    }
}


char* XMLElement::ParseAttributes( char* p, int* curLineNumPtr )
{
    XMLAttribute* prevAttribute = 0;

    // Read the attributes.
    while( p ) {
        p = XMLUtil::SkipWhiteSpace( p, curLineNumPtr );
        if ( !(*p) ) {
            _document->SetError( XML_ERROR_PARSING_ELEMENT, _parseLineNum, "XMLElement name=%s", Name() );
            return 0;
        }

        // attribute.
        if (XMLUtil::IsNameStartChar( *p ) ) {
            XMLAttribute* attrib = CreateAttribute();
            TIXMLASSERT( attrib );
            attrib->_parseLineNum = _document->_parseCurLineNum;

            const int attrLineNum = attrib->_parseLineNum;

            p = attrib->ParseDeep( p, _document->ProcessEntities(), curLineNumPtr );
            if ( !p || Attribute( attrib->Name() ) ) {
                DeleteAttribute( attrib );
                _document->SetError( XML_ERROR_PARSING_ATTRIBUTE, attrLineNum, "XMLElement name=%s", Name() );
                return 0;
            }
            // There is a minor bug here: if the attribute in the source xml
            // document is duplicated, it will not be detected and the
            // attribute will be doubly added. However, tracking the 'prevAttribute'
            // avoids re-scanning the attribute list. Preferring performance for
            // now, may reconsider in the future.
            if ( prevAttribute ) {
                TIXMLASSERT( prevAttribute->_next == 0 );
                prevAttribute->_next = attrib;
            }
            else {
                TIXMLASSERT( _rootAttribute == 0 );
                _rootAttribute = attrib;
            }
            prevAttribute = attrib;
        }
        // end of the tag
        else if ( *p == '>' ) {
            ++p;
            break;
        }
        // end of the tag
        else if ( *p == '/' && *(p+1) == '>' ) {
            _closingType = CLOSED;
            return p+2;	// done; sealed element.
        }
        else {
            _document->SetError( XML_ERROR_PARSING_ELEMENT, _parseLineNum, 0 );
            return 0;
        }
    }
    return p;
}

void XMLElement::DeleteAttribute( XMLAttribute* attribute )
{
    if ( attribute == 0 ) {
        return;
    }
    MemPool* pool = attribute->_memPool;
    attribute->~XMLAttribute();
    pool->Free( attribute );
}

XMLAttribute* XMLElement::CreateAttribute()
{
    TIXMLASSERT( sizeof( XMLAttribute ) == _document->_attributePool.ItemSize() );
    XMLAttribute* attrib = new (_document->_attributePool.Alloc() ) XMLAttribute();
    TIXMLASSERT( attrib );
    attrib->_memPool = &_document->_attributePool;
    attrib->_memPool->SetTracked();
    return attrib;
}


XMLElement* XMLElement::InsertNewChildElement(const char* name)
{
    XMLElement* node = _document->NewElement(name);
    return InsertEndChild(node) ? node : 0;
}

XMLComment* XMLElement::InsertNewComment(const char* comment)
{
    XMLComment* node = _document->NewComment(comment);
    return InsertEndChild(node) ? node : 0;
}

XMLText* XMLElement::InsertNewText(const char* text)
{
    XMLText* node = _document->NewText(text);
    return InsertEndChild(node) ? node : 0;
}

XMLDeclaration* XMLElement::InsertNewDeclaration(const char* text)
{
    XMLDeclaration* node = _document->NewDeclaration(text);
    return InsertEndChild(node) ? node : 0;
}

XMLUnknown* XMLElement::InsertNewUnknown(const char* text)
{
    XMLUnknown* node = _document->NewUnknown(text);
    return InsertEndChild(node) ? node : 0;
}



//
//	<ele></ele>
//	<ele>foo<b>bar</b></ele>
//
char* XMLElement::ParseDeep( char* p, StrPair* parentEndTag, int* curLineNumPtr )
{
    // Read the element name.
    p = XMLUtil::SkipWhiteSpace( p, curLineNumPtr );

    // The closing element is the </element> form. It is
    // parsed just like a regular element then deleted from
    // the DOM.
    if ( *p == '/' ) {
        _closingType = CLOSING;
        ++p;
    }

    p = _value.ParseName( p );
    if ( _value.Empty() ) {
        return 0;
    }

    p = ParseAttributes( p, curLineNumPtr );
    if ( !p || !*p || _closingType != OPEN ) {
        return p;
    }

    p = XMLNode::ParseDeep( p, parentEndTag, curLineNumPtr );
    return p;
}



XMLNode* XMLElement::ShallowClone( XMLDocument* doc ) const
{
    if ( !doc ) {
        doc = _document;
    }
    XMLElement* element = doc->NewElement( Value() );					// fixme: this will always allocate memory. Intern?
    for( const XMLAttribute* a=FirstAttribute(); a; a=a->Next() ) {
        element->SetAttribute( a->Name(), a->Value() );					// fixme: this will always allocate memory. Intern?
    }
    return element;
}


bool XMLElement::ShallowEqual( const XMLNode* compare ) const
{
    TIXMLASSERT( compare );
    const XMLElement* other = compare->ToElement();
    if ( other && XMLUtil::StringEqual( other->Name(), Name() )) {

        const XMLAttribute* a=FirstAttribute();
        const XMLAttribute* b=other->FirstAttribute();

        while ( a && b ) {
            if ( !XMLUtil::StringEqual( a->Value(), b->Value() ) ) {
                return false;
            }
            a = a->Next();
            b = b->Next();
        }
        if ( a || b ) {
            // different count
            return false;
        }
        return true;
    }
    return false;
}


bool XMLElement::Accept( XMLVisitor* visitor ) const
{
    TIXMLASSERT( visitor );
    if ( visitor->VisitEnter( *this, _rootAttribute ) ) {
        for ( const XMLNode* node=FirstChild(); node; node=node->NextSibling() ) {
            if ( !node->Accept( visitor ) ) {
                break;
            }
        }
    }
    return visitor->VisitExit( *this );
}


// --------- XMLDocument ----------- //

// Warning: List must match 'enum XMLError'
const char* XMLDocument::_errorNames[XML_ERROR_COUNT] = {
    "XML_SUCCESS",
    "XML_NO_ATTRIBUTE",
    "XML_WRONG_ATTRIBUTE_TYPE",
    "XML_ERROR_FILE_NOT_FOUND",
    "XML_ERROR_FILE_COULD_NOT_BE_OPENED",
    "XML_ERROR_FILE_READ_ERROR",
    "XML_ERROR_PARSING_ELEMENT",
    "XML_ERROR_PARSING_ATTRIBUTE",
    "XML_ERROR_PARSING_TEXT",
    "XML_ERROR_PARSING_CDATA",
    "XML_ERROR_PARSING_COMMENT",
    "XML_ERROR_PARSING_DECLARATION",
    "XML_ERROR_PARSING_UNKNOWN",
    "XML_ERROR_EMPTY_DOCUMENT",
    "XML_ERROR_MISMATCHED_ELEMENT",
    "XML_ERROR_PARSING",
    "XML_CAN_NOT_CONVERT_TEXT",
    "XML_NO_TEXT_NODE",
	"XML_ELEMENT_DEPTH_EXCEEDED"
};


XMLDocument::XMLDocument( bool processEntities, Whitespace whitespaceMode ) :
    XMLNode( 0 ),
    _writeBOM( false ),
    _processEntities( processEntities ),
    _errorID(XML_SUCCESS),
    _whitespaceMode( whitespaceMode ),
    _errorStr(),
    _errorLineNum( 0 ),
    _charBuffer( 0 ),
    _parseCurLineNum( 0 ),
	_parsingDepth(0),
    _unlinked(),
    _elementPool(),
    _attributePool(),
    _textPool(),
    _commentPool()
{
    // avoid VC++ C4355 warning about 'this' in initializer list (C4355 is off by default in VS2012+)
    _document = this;
}


XMLDocument::~XMLDocument()
{
    Clear();
}


void XMLDocument::MarkInUse(const XMLNode* const node)
{
	TIXMLASSERT(node);
	TIXMLASSERT(node->_parent == 0);

	for (int i = 0; i < _unlinked.Size(); ++i) {
		if (node == _unlinked[i]) {
			_unlinked.SwapRemove(i);
			break;
		}
	}
}

void XMLDocument::Clear()
{
    DeleteChildren();
	while( _unlinked.Size()) {
		DeleteNode(_unlinked[0]);	// Will remove from _unlinked as part of delete.
	}

#ifdef TINYXML2_DEBUG
    const bool hadError = Error();
#endif
    ClearError();

    delete [] _charBuffer;
    _charBuffer = 0;
	_parsingDepth = 0;

#if 0
    _textPool.Trace( "text" );
    _elementPool.Trace( "element" );
    _commentPool.Trace( "comment" );
    _attributePool.Trace( "attribute" );
#endif

#ifdef TINYXML2_DEBUG
    if ( !hadError ) {
        TIXMLASSERT( _elementPool.CurrentAllocs()   == _elementPool.Untracked() );
        TIXMLASSERT( _attributePool.CurrentAllocs() == _attributePool.Untracked() );
        TIXMLASSERT( _textPool.CurrentAllocs()      == _textPool.Untracked() );
        TIXMLASSERT( _commentPool.CurrentAllocs()   == _commentPool.Untracked() );
    }
#endif
}


void XMLDocument::DeepCopy(XMLDocument* target) const
{
	TIXMLASSERT(target);
    if (target == this) {
        return; // technically success - a no-op.
    }

	target->Clear();
	for (const XMLNode* node = this->FirstChild(); node; node = node->NextSibling()) {
		target->InsertEndChild(node->DeepClone(target));
	}
}

XMLElement* XMLDocument::NewElement( const char* name )
{
    XMLElement* ele = CreateUnlinkedNode<XMLElement>( _elementPool );
    ele->SetName( name );
    return ele;
}


XMLComment* XMLDocument::NewComment( const char* str )
{
    XMLComment* comment = CreateUnlinkedNode<XMLComment>( _commentPool );
    comment->SetValue( str );
    return comment;
}


XMLText* XMLDocument::NewText( const char* str )
{
    XMLText* text = CreateUnlinkedNode<XMLText>( _textPool );
    text->SetValue( str );
    return text;
}


XMLDeclaration* XMLDocument::NewDeclaration( const char* str )
{
    XMLDeclaration* dec = CreateUnlinkedNode<XMLDeclaration>( _commentPool );
    dec->SetValue( str ? str : "xml version=\"1.0\" encoding=\"UTF-8\"" );
    return dec;
}


XMLUnknown* XMLDocument::NewUnknown( const char* str )
{
    XMLUnknown* unk = CreateUnlinkedNode<XMLUnknown>( _commentPool );
    unk->SetValue( str );
    return unk;
}

static FILE* callfopen( const char* filepath, const char* mode )
{
    TIXMLASSERT( filepath );
    TIXMLASSERT( mode );
#if defined(_MSC_VER) && (_MSC_VER >= 1400 ) && (!defined WINCE)
    FILE* fp = 0;
    const errno_t err = fopen_s( &fp, filepath, mode );
    if ( err ) {
        return 0;
    }
#else
    FILE* fp = fopen( filepath, mode );
#endif
    return fp;
}

void XMLDocument::DeleteNode( XMLNode* node )	{
    TIXMLASSERT( node );
    TIXMLASSERT(node->_document == this );
    if (node->_parent) {
        node->_parent->DeleteChild( node );
    }
    else {
        // Isn't in the tree.
        // Use the parent delete.
        // Also, we need to mark it tracked: we 'know'
        // it was never used.
        node->_memPool->SetTracked();
        // Call the static XMLNode version:
        XMLNode::DeleteNode(node);
    }
}


XMLError XMLDocument::LoadFile( const char* filename )
{
    if ( !filename ) {
        TIXMLASSERT( false );
        SetError( XML_ERROR_FILE_COULD_NOT_BE_OPENED, 0, "filename=<null>" );
        return _errorID;
    }

    Clear();
    FILE* fp = callfopen( filename, "rb" );
    if ( !fp ) {
        SetError( XML_ERROR_FILE_NOT_FOUND, 0, "filename=%s", filename );
        return _errorID;
    }
    LoadFile( fp );
    fclose( fp );
    return _errorID;
}

// This is likely overengineered template art to have a check that unsigned long value incremented
// by one still fits into size_t. If size_t type is larger than unsigned long type
// (x86_64-w64-mingw32 target) then the check is redundant and gcc and clang emit
// -Wtype-limits warning. This piece makes the compiler select code with a check when a check
// is useful and code with no check when a check is redundant depending on how size_t and unsigned long
// types sizes relate to each other.
template
<bool = (sizeof(unsigned long) >= sizeof(size_t))>
struct LongFitsIntoSizeTMinusOne {
    static bool Fits( unsigned long value )
    {
        return value < static_cast<size_t>(-1);
    }
};

template <>
struct LongFitsIntoSizeTMinusOne<false> {
    static bool Fits( unsigned long )
    {
        return true;
    }
};

XMLError XMLDocument::LoadFile( FILE* fp )
{
    Clear();

    fseek( fp, 0, SEEK_SET );
    if ( fgetc( fp ) == EOF && ferror( fp ) != 0 ) {
        SetError( XML_ERROR_FILE_READ_ERROR, 0, 0 );
        return _errorID;
    }

    fseek( fp, 0, SEEK_END );
    const long filelength = ftell( fp );
    fseek( fp, 0, SEEK_SET );
    if ( filelength == -1L ) {
        SetError( XML_ERROR_FILE_READ_ERROR, 0, 0 );
        return _errorID;
    }
    TIXMLASSERT( filelength >= 0 );

    if ( !LongFitsIntoSizeTMinusOne<>::Fits( filelength ) ) {
        // Cannot handle files which won't fit in buffer together with null terminator
        SetError( XML_ERROR_FILE_READ_ERROR, 0, 0 );
        return _errorID;
    }

    if ( filelength == 0 ) {
        SetError( XML_ERROR_EMPTY_DOCUMENT, 0, 0 );
        return _errorID;
    }

    const size_t size = filelength;
    TIXMLASSERT( _charBuffer == 0 );
    _charBuffer = new char[size+1];
    const size_t read = fread( _charBuffer, 1, size, fp );
    if ( read != size ) {
        SetError( XML_ERROR_FILE_READ_ERROR, 0, 0 );
        return _errorID;
    }

    _charBuffer[size] = 0;

    Parse();
    return _errorID;
}


XMLError XMLDocument::SaveFile( const char* filename, bool compact )
{
    if ( !filename ) {
        TIXMLASSERT( false );
        SetError( XML_ERROR_FILE_COULD_NOT_BE_OPENED, 0, "filename=<null>" );
        return _errorID;
    }

    FILE* fp = callfopen( filename, "w" );
    if ( !fp ) {
        SetError( XML_ERROR_FILE_COULD_NOT_BE_OPENED, 0, "filename=%s", filename );
        return _errorID;
    }
    SaveFile(fp, compact);
    fclose( fp );
    return _errorID;
}


XMLError XMLDocument::SaveFile( FILE* fp, bool compact )
{
    // Clear any error from the last save, otherwise it will get reported
    // for *this* call.
    ClearError();
    XMLPrinter stream( fp, compact );
    Print( &stream );
    return _errorID;
}


XMLError XMLDocument::Parse( const char* p, size_t len )
{
    Clear();

    if ( len == 0 || !p || !*p ) {
        SetError( XML_ERROR_EMPTY_DOCUMENT, 0, 0 );
        return _errorID;
    }
    if ( len == static_cast<size_t>(-1) ) {
        len = strlen( p );
    }
    TIXMLASSERT( _charBuffer == 0 );
    _charBuffer = new char[ len+1 ];
    memcpy( _charBuffer, p, len );
    _charBuffer[len] = 0;

    Parse();
    if ( Error() ) {
        // clean up now essentially dangling memory.
        // and the parse fail can put objects in the
        // pools that are dead and inaccessible.
        DeleteChildren();
        _elementPool.Clear();
        _attributePool.Clear();
        _textPool.Clear();
        _commentPool.Clear();
    }
    return _errorID;
}


void XMLDocument::Print( XMLPrinter* streamer ) const
{
    if ( streamer ) {
        Accept( streamer );
    }
    else {
        XMLPrinter stdoutStreamer( stdout );
        Accept( &stdoutStreamer );
    }
}


void XMLDocument::SetError( XMLError error, int lineNum, const char* format, ... )
{
    TIXMLASSERT( error >= 0 && error < XML_ERROR_COUNT );
    _errorID = error;
    _errorLineNum = lineNum;
	_errorStr.Reset();

    const size_t BUFFER_SIZE = 1000;
    char* buffer = new char[BUFFER_SIZE];

    TIXMLASSERT(sizeof(error) <= sizeof(int));
    TIXML_SNPRINTF(buffer, BUFFER_SIZE, "Error=%s ErrorID=%d (0x%x) Line number=%d", ErrorIDToName(error), int(error), int(error), lineNum);

	if (format) {
		size_t len = strlen(buffer);
		TIXML_SNPRINTF(buffer + len, BUFFER_SIZE - len, ": ");
		len = strlen(buffer);

		va_list va;
		va_start(va, format);
		TIXML_VSNPRINTF(buffer + len, BUFFER_SIZE - len, format, va);
		va_end(va);
	}
	_errorStr.SetStr(buffer);
	delete[] buffer;
}


/*static*/ const char* XMLDocument::ErrorIDToName(XMLError errorID)
{
	TIXMLASSERT( errorID >= 0 && errorID < XML_ERROR_COUNT );
    const char* errorName = _errorNames[errorID];
    TIXMLASSERT( errorName && errorName[0] );
    return errorName;
}

const char* XMLDocument::ErrorStr() const
{
	return _errorStr.Empty() ? "" : _errorStr.GetStr();
}


void XMLDocument::PrintError() const
{
    printf("%s\n", ErrorStr());
}

const char* XMLDocument::ErrorName() const
{
    return ErrorIDToName(_errorID);
}

void XMLDocument::Parse()
{
    TIXMLASSERT( NoChildren() ); // Clear() must have been called previously
    TIXMLASSERT( _charBuffer );
    _parseCurLineNum = 1;
    _parseLineNum = 1;
    char* p = _charBuffer;
    p = XMLUtil::SkipWhiteSpace( p, &_parseCurLineNum );
    p = const_cast<char*>( XMLUtil::ReadBOM( p, &_writeBOM ) );
    if ( !*p ) {
        SetError( XML_ERROR_EMPTY_DOCUMENT, 0, 0 );
        return;
    }
    ParseDeep(p, 0, &_parseCurLineNum );
}

void XMLDocument::PushDepth()
{
	_parsingDepth++;
	if (_parsingDepth == TINYXML2_MAX_ELEMENT_DEPTH) {
		SetError(XML_ELEMENT_DEPTH_EXCEEDED, _parseCurLineNum, "Element nesting is too deep." );
	}
}

void XMLDocument::PopDepth()
{
	TIXMLASSERT(_parsingDepth > 0);
	--_parsingDepth;
}

XMLPrinter::XMLPrinter( FILE* file, bool compact, int depth ) :
    _elementJustOpened( false ),
    _stack(),
    _firstElement( true ),
    _fp( file ),
    _depth( depth ),
    _textDepth( -1 ),
    _processEntities( true ),
    _compactMode( compact ),
    _buffer()
{
    for( int i=0; i<ENTITY_RANGE; ++i ) {
        _entityFlag[i] = false;
        _restrictedEntityFlag[i] = false;
    }
    for( int i=0; i<NUM_ENTITIES; ++i ) {
        const char entityValue = entities[i].value;
        const unsigned char flagIndex = static_cast<unsigned char>(entityValue);
        TIXMLASSERT( flagIndex < ENTITY_RANGE );
        _entityFlag[flagIndex] = true;
    }
    _restrictedEntityFlag[static_cast<unsigned char>('&')] = true;
    _restrictedEntityFlag[static_cast<unsigned char>('<')] = true;
    _restrictedEntityFlag[static_cast<unsigned char>('>')] = true;	// not required, but consistency is nice
    _buffer.Push( 0 );
}


void XMLPrinter::Print( const char* format, ... )
{
    va_list     va;
    va_start( va, format );

    if ( _fp ) {
        vfprintf( _fp, format, va );
    }
    else {
        const int len = TIXML_VSCPRINTF( format, va );
        // Close out and re-start the va-args
        va_end( va );
        TIXMLASSERT( len >= 0 );
        va_start( va, format );
        TIXMLASSERT( _buffer.Size() > 0 && _buffer[_buffer.Size() - 1] == 0 );
        char* p = _buffer.PushArr( len ) - 1;	// back up over the null terminator.
		TIXML_VSNPRINTF( p, len+1, format, va );
    }
    va_end( va );
}


void XMLPrinter::Write( const char* data, size_t size )
{
    if ( _fp ) {
        fwrite ( data , sizeof(char), size, _fp);
    }
    else {
        char* p = _buffer.PushArr( static_cast<int>(size) ) - 1;   // back up over the null terminator.
        memcpy( p, data, size );
        p[size] = 0;
    }
}


void XMLPrinter::Putc( char ch )
{
    if ( _fp ) {
        fputc ( ch, _fp);
    }
    else {
        char* p = _buffer.PushArr( sizeof(char) ) - 1;   // back up over the null terminator.
        p[0] = ch;
        p[1] = 0;
    }
}


void XMLPrinter::PrintSpace( int depth )
{
    for( int i=0; i<depth; ++i ) {
        Write( "    " );
    }
}


void XMLPrinter::PrintString( const char* p, bool restricted )
{
    // Look for runs of bytes between entities to print.
    const char* q = p;

    if ( _processEntities ) {
        const bool* flag = restricted ? _restrictedEntityFlag : _entityFlag;
        while ( *q ) {
            TIXMLASSERT( p <= q );
            // Remember, char is sometimes signed. (How many times has that bitten me?)
            if ( *q > 0 && *q < ENTITY_RANGE ) {
                // Check for entities. If one is found, flush
                // the stream up until the entity, write the
                // entity, and keep looking.
                if ( flag[static_cast<unsigned char>(*q)] ) {
                    while ( p < q ) {
                        const size_t delta = q - p;
                        const int toPrint = ( INT_MAX < delta ) ? INT_MAX : static_cast<int>(delta);
                        Write( p, toPrint );
                        p += toPrint;
                    }
                    bool entityPatternPrinted = false;
                    for( int i=0; i<NUM_ENTITIES; ++i ) {
                        if ( entities[i].value == *q ) {
                            Putc( '&' );
                            Write( entities[i].pattern, entities[i].length );
                            Putc( ';' );
                            entityPatternPrinted = true;
                            break;
                        }
                    }
                    if ( !entityPatternPrinted ) {
                        // TIXMLASSERT( entityPatternPrinted ) causes gcc -Wunused-but-set-variable in release
                        TIXMLASSERT( false );
                    }
                    ++p;
                }
            }
            ++q;
            TIXMLASSERT( p <= q );
        }
        // Flush the remaining string. This will be the entire
        // string if an entity wasn't found.
        if ( p < q ) {
            const size_t delta = q - p;
            const int toPrint = ( INT_MAX < delta ) ? INT_MAX : static_cast<int>(delta);
            Write( p, toPrint );
        }
    }
    else {
        Write( p );
    }
}


void XMLPrinter::PushHeader( bool writeBOM, bool writeDec )
{
    if ( writeBOM ) {
        static const unsigned char bom[] = { TIXML_UTF_LEAD_0, TIXML_UTF_LEAD_1, TIXML_UTF_LEAD_2, 0 };
        Write( reinterpret_cast< const char* >( bom ) );
    }
    if ( writeDec ) {
        PushDeclaration( "xml version=\"1.0\"" );
    }
}


void XMLPrinter::OpenElement( const char* name, bool compactMode )
{
    SealElementIfJustOpened();
    _stack.Push( name );

    if ( _textDepth < 0 && !_firstElement && !compactMode ) {
        Putc( '\n' );
        PrintSpace( _depth );
    }

    Write ( "<" );
    Write ( name );

    _elementJustOpened = true;
    _firstElement = false;
    ++_depth;
}


void XMLPrinter::PushAttribute( const char* name, const char* value )
{
    TIXMLASSERT( _elementJustOpened );
    Putc ( ' ' );
    Write( name );
    Write( "=\"" );
    PrintString( value, false );
    Putc ( '\"' );
}


void XMLPrinter::PushAttribute( const char* name, int v )
{
    char buf[BUF_SIZE];
    XMLUtil::ToStr( v, buf, BUF_SIZE );
    PushAttribute( name, buf );
}


void XMLPrinter::PushAttribute( const char* name, unsigned v )
{
    char buf[BUF_SIZE];
    XMLUtil::ToStr( v, buf, BUF_SIZE );
    PushAttribute( name, buf );
}


void XMLPrinter::PushAttribute(const char* name, int64_t v)
{
	char buf[BUF_SIZE];
	XMLUtil::ToStr(v, buf, BUF_SIZE);
	PushAttribute(name, buf);
}


void XMLPrinter::PushAttribute(const char* name, uint64_t v)
{
	char buf[BUF_SIZE];
	XMLUtil::ToStr(v, buf, BUF_SIZE);
	PushAttribute(name, buf);
}


void XMLPrinter::PushAttribute( const char* name, bool v )
{
    char buf[BUF_SIZE];
    XMLUtil::ToStr( v, buf, BUF_SIZE );
    PushAttribute( name, buf );
}


void XMLPrinter::PushAttribute( const char* name, double v )
{
    char buf[BUF_SIZE];
    XMLUtil::ToStr( v, buf, BUF_SIZE );
    PushAttribute( name, buf );
}


void XMLPrinter::CloseElement( bool compactMode )
{
    --_depth;
    const char* name = _stack.Pop();

    if ( _elementJustOpened ) {
        Write( "/>" );
    }
    else {
        if ( _textDepth < 0 && !compactMode) {
            Putc( '\n' );
            PrintSpace( _depth );
        }
        Write ( "</" );
        Write ( name );
        Write ( ">" );
    }

    if ( _textDepth == _depth ) {
        _textDepth = -1;
    }
    if ( _depth == 0 && !compactMode) {
        Putc( '\n' );
    }
    _elementJustOpened = false;
}


void XMLPrinter::SealElementIfJustOpened()
{
    if ( !_elementJustOpened ) {
        return;
    }
    _elementJustOpened = false;
    Putc( '>' );
}


void XMLPrinter::PushText( const char* text, bool cdata )
{
    _textDepth = _depth-1;

    SealElementIfJustOpened();
    if ( cdata ) {
        Write( "<![CDATA[" );
        Write( text );
        Write( "]]>" );
    }
    else {
        PrintString( text, true );
    }
}


void XMLPrinter::PushText( int64_t value )
{
    char buf[BUF_SIZE];
    XMLUtil::ToStr( value, buf, BUF_SIZE );
    PushText( buf, false );
}


void XMLPrinter::PushText( uint64_t value )
{
	char buf[BUF_SIZE];
	XMLUtil::ToStr(value, buf, BUF_SIZE);
	PushText(buf, false);
}


void XMLPrinter::PushText( int value )
{
    char buf[BUF_SIZE];
    XMLUtil::ToStr( value, buf, BUF_SIZE );
    PushText( buf, false );
}


void XMLPrinter::PushText( unsigned value )
{
    char buf[BUF_SIZE];
    XMLUtil::ToStr( value, buf, BUF_SIZE );
    PushText( buf, false );
}


void XMLPrinter::PushText( bool value )
{
    char buf[BUF_SIZE];
    XMLUtil::ToStr( value, buf, BUF_SIZE );
    PushText( buf, false );
}


void XMLPrinter::PushText( float value )
{
    char buf[BUF_SIZE];
    XMLUtil::ToStr( value, buf, BUF_SIZE );
    PushText( buf, false );
}


void XMLPrinter::PushText( double value )
{
    char buf[BUF_SIZE];
    XMLUtil::ToStr( value, buf, BUF_SIZE );
    PushText( buf, false );
}


void XMLPrinter::PushComment( const char* comment )
{
    SealElementIfJustOpened();
    if ( _textDepth < 0 && !_firstElement && !_compactMode) {
        Putc( '\n' );
        PrintSpace( _depth );
    }
    _firstElement = false;

    Write( "<!--" );
    Write( comment );
    Write( "-->" );
}


void XMLPrinter::PushDeclaration( const char* value )
{
    SealElementIfJustOpened();
    if ( _textDepth < 0 && !_firstElement && !_compactMode) {
        Putc( '\n' );
        PrintSpace( _depth );
    }
    _firstElement = false;

    Write( "<?" );
    Write( value );
    Write( "?>" );
}


void XMLPrinter::PushUnknown( const char* value )
{
    SealElementIfJustOpened();
    if ( _textDepth < 0 && !_firstElement && !_compactMode) {
        Putc( '\n' );
        PrintSpace( _depth );
    }
    _firstElement = false;

    Write( "<!" );
    Write( value );
    Putc( '>' );
}


bool XMLPrinter::VisitEnter( const XMLDocument& doc )
{
    _processEntities = doc.ProcessEntities();
    if ( doc.HasBOM() ) {
        PushHeader( true, false );
    }
    return true;
}


bool XMLPrinter::VisitEnter( const XMLElement& element, const XMLAttribute* attribute )
{
    const XMLElement* parentElem = 0;
    if ( element.Parent() ) {
        parentElem = element.Parent()->ToElement();
    }
    const bool compactMode = parentElem ? CompactMode( *parentElem ) : _compactMode;
    OpenElement( element.Name(), compactMode );
    while ( attribute ) {
        PushAttribute( attribute->Name(), attribute->Value() );
        attribute = attribute->Next();
    }
    return true;
}


bool XMLPrinter::VisitExit( const XMLElement& element )
{
    CloseElement( CompactMode(element) );
    return true;
}


bool XMLPrinter::Visit( const XMLText& text )
{
    PushText( text.Value(), text.CData() );
    return true;
}


bool XMLPrinter::Visit( const XMLComment& comment )
{
    PushComment( comment.Value() );
    return true;
}

bool XMLPrinter::Visit( const XMLDeclaration& declaration )
{
    PushDeclaration( declaration.Value() );
    return true;
}


bool XMLPrinter::Visit( const XMLUnknown& unknown )
{
    PushUnknown( unknown.Value() );
    return true;
}

}   // namespace tinyxml2

```

`Lumina/Lumina/ui/fgui_/dependencies/external/tinyxml2.hpp`:

```hpp
/*
Original code by Lee Thomason (www.grinninglizard.com)

This software is provided 'as-is', without any express or implied
warranty. In no event will the authors be held liable for any
damages arising from the use of this software.

Permission is granted to anyone to use this software for any
purpose, including commercial applications, and to alter it and
redistribute it freely, subject to the following restrictions:

1. The origin of this software must not be misrepresented; you must
not claim that you wrote the original software. If you use this
software in a product, an acknowledgment in the product documentation
would be appreciated but is not required.

2. Altered source versions must be plainly marked as such, and
must not be misrepresented as being the original software.

3. This notice may not be removed or altered from any source
distribution.
*/

#ifndef TINYXML2_INCLUDED
#define TINYXML2_INCLUDED

#if defined(ANDROID_NDK) || defined(__BORLANDC__) || defined(__QNXNTO__)
#   include <ctype.h>
#   include <limits.h>
#   include <stdio.h>
#   include <stdlib.h>
#   include <string.h>
#	if defined(__PS3__)
#		include <stddef.h>
#	endif
#else
#   include <cctype>
#   include <climits>
#   include <cstdio>
#   include <cstdlib>
#   include <cstring>
#endif
#include <stdint.h>

/*
   TODO: intern strings instead of allocation.
*/
/*
	gcc:
        g++ -Wall -DTINYXML2_DEBUG tinyxml2.cpp xmltest.cpp -o gccxmltest.exe

    Formatting, Artistic Style:
        AStyle.exe --style=1tbs --indent-switches --break-closing-brackets --indent-preprocessor tinyxml2.cpp tinyxml2.h
*/

#if defined( _DEBUG ) || defined (__DEBUG__)
#   ifndef TINYXML2_DEBUG
#       define TINYXML2_DEBUG
#   endif
#endif

#ifdef _MSC_VER
#   pragma warning(push)
#   pragma warning(disable: 4251)
#endif

#ifdef _WIN32
#   ifdef TINYXML2_EXPORT
#       define TINYXML2_LIB __declspec(dllexport)
#   elif defined(TINYXML2_IMPORT)
#       define TINYXML2_LIB __declspec(dllimport)
#   else
#       define TINYXML2_LIB
#   endif
#elif __GNUC__ >= 4
#   define TINYXML2_LIB __attribute__((visibility("default")))
#else
#   define TINYXML2_LIB
#endif


#if defined(TINYXML2_DEBUG)
#   if defined(_MSC_VER)
#       // "(void)0," is for suppressing C4127 warning in "assert(false)", "assert(true)" and the like
#       define TIXMLASSERT( x )           if ( !((void)0,(x))) { __debugbreak(); }
#   elif defined (ANDROID_NDK)
#       include <android/log.h>
#       define TIXMLASSERT( x )           if ( !(x)) { __android_log_assert( "assert", "grinliz", "ASSERT in '%s' at %d.", __FILE__, __LINE__ ); }
#   else
#       include <assert.h>
#       define TIXMLASSERT                assert
#   endif
#else
#   define TIXMLASSERT( x )               {}
#endif


/* Versioning, past 1.0.14:
	http://semver.org/
*/
static const int TIXML2_MAJOR_VERSION = 8;
static const int TIXML2_MINOR_VERSION = 0;
static const int TIXML2_PATCH_VERSION = 0;

#define TINYXML2_MAJOR_VERSION 8
#define TINYXML2_MINOR_VERSION 0
#define TINYXML2_PATCH_VERSION 0

// A fixed element depth limit is problematic. There needs to be a
// limit to avoid a stack overflow. However, that limit varies per
// system, and the capacity of the stack. On the other hand, it's a trivial
// attack that can result from ill, malicious, or even correctly formed XML,
// so there needs to be a limit in place.
static const int TINYXML2_MAX_ELEMENT_DEPTH = 100;

namespace tinyxml2
{
class XMLDocument;
class XMLElement;
class XMLAttribute;
class XMLComment;
class XMLText;
class XMLDeclaration;
class XMLUnknown;
class XMLPrinter;

/*
	A class that wraps strings. Normally stores the start and end
	pointers into the XML file itself, and will apply normalization
	and entity translation if actually read. Can also store (and memory
	manage) a traditional char[]

    Isn't clear why TINYXML2_LIB is needed; but seems to fix #719
*/
class TINYXML2_LIB StrPair
{
public:
    enum {
        NEEDS_ENTITY_PROCESSING			= 0x01,
        NEEDS_NEWLINE_NORMALIZATION		= 0x02,
        NEEDS_WHITESPACE_COLLAPSING     = 0x04,

        TEXT_ELEMENT		            = NEEDS_ENTITY_PROCESSING | NEEDS_NEWLINE_NORMALIZATION,
        TEXT_ELEMENT_LEAVE_ENTITIES		= NEEDS_NEWLINE_NORMALIZATION,
        ATTRIBUTE_NAME		            = 0,
        ATTRIBUTE_VALUE		            = NEEDS_ENTITY_PROCESSING | NEEDS_NEWLINE_NORMALIZATION,
        ATTRIBUTE_VALUE_LEAVE_ENTITIES  = NEEDS_NEWLINE_NORMALIZATION,
        COMMENT							= NEEDS_NEWLINE_NORMALIZATION
    };

    StrPair() : _flags( 0 ), _start( 0 ), _end( 0 ) {}
    ~StrPair();

    void Set( char* start, char* end, int flags ) {
        TIXMLASSERT( start );
        TIXMLASSERT( end );
        Reset();
        _start  = start;
        _end    = end;
        _flags  = flags | NEEDS_FLUSH;
    }

    const char* GetStr();

    bool Empty() const {
        return _start == _end;
    }

    void SetInternedStr( const char* str ) {
        Reset();
        _start = const_cast<char*>(str);
    }

    void SetStr( const char* str, int flags=0 );

    char* ParseText( char* in, const char* endTag, int strFlags, int* curLineNumPtr );
    char* ParseName( char* in );

    void TransferTo( StrPair* other );
	void Reset();

private:
    void CollapseWhitespace();

    enum {
        NEEDS_FLUSH = 0x100,
        NEEDS_DELETE = 0x200
    };

    int     _flags;
    char*   _start;
    char*   _end;

    StrPair( const StrPair& other );	// not supported
    void operator=( const StrPair& other );	// not supported, use TransferTo()
};


/*
	A dynamic array of Plain Old Data. Doesn't support constructors, etc.
	Has a small initial memory pool, so that low or no usage will not
	cause a call to new/delete
*/
template <class T, int INITIAL_SIZE>
class DynArray
{
public:
    DynArray() :
        _mem( _pool ),
        _allocated( INITIAL_SIZE ),
        _size( 0 )
    {
    }

    ~DynArray() {
        if ( _mem != _pool ) {
            delete [] _mem;
        }
    }

    void Clear() {
        _size = 0;
    }

    void Push( T t ) {
        TIXMLASSERT( _size < INT_MAX );
        EnsureCapacity( _size+1 );
        _mem[_size] = t;
        ++_size;
    }

    T* PushArr( int count ) {
        TIXMLASSERT( count >= 0 );
        TIXMLASSERT( _size <= INT_MAX - count );
        EnsureCapacity( _size+count );
        T* ret = &_mem[_size];
        _size += count;
        return ret;
    }

    T Pop() {
        TIXMLASSERT( _size > 0 );
        --_size;
        return _mem[_size];
    }

    void PopArr( int count ) {
        TIXMLASSERT( _size >= count );
        _size -= count;
    }

    bool Empty() const					{
        return _size == 0;
    }

    T& operator[](int i)				{
        TIXMLASSERT( i>= 0 && i < _size );
        return _mem[i];
    }

    const T& operator[](int i) const	{
        TIXMLASSERT( i>= 0 && i < _size );
        return _mem[i];
    }

    const T& PeekTop() const            {
        TIXMLASSERT( _size > 0 );
        return _mem[ _size - 1];
    }

    int Size() const					{
        TIXMLASSERT( _size >= 0 );
        return _size;
    }

    int Capacity() const				{
        TIXMLASSERT( _allocated >= INITIAL_SIZE );
        return _allocated;
    }

	void SwapRemove(int i) {
		TIXMLASSERT(i >= 0 && i < _size);
		TIXMLASSERT(_size > 0);
		_mem[i] = _mem[_size - 1];
		--_size;
	}

    const T* Mem() const				{
        TIXMLASSERT( _mem );
        return _mem;
    }

    T* Mem() {
        TIXMLASSERT( _mem );
        return _mem;
    }

private:
    DynArray( const DynArray& ); // not supported
    void operator=( const DynArray& ); // not supported

    void EnsureCapacity( int cap ) {
        TIXMLASSERT( cap > 0 );
        if ( cap > _allocated ) {
            TIXMLASSERT( cap <= INT_MAX / 2 );
            const int newAllocated = cap * 2;
            T* newMem = new T[newAllocated];
            TIXMLASSERT( newAllocated >= _size );
            memcpy( newMem, _mem, sizeof(T)*_size );	// warning: not using constructors, only works for PODs
            if ( _mem != _pool ) {
                delete [] _mem;
            }
            _mem = newMem;
            _allocated = newAllocated;
        }
    }

    T*  _mem;
    T   _pool[INITIAL_SIZE];
    int _allocated;		// objects allocated
    int _size;			// number objects in use
};


/*
	Parent virtual class of a pool for fast allocation
	and deallocation of objects.
*/
class MemPool
{
public:
    MemPool() {}
    virtual ~MemPool() {}

    virtual int ItemSize() const = 0;
    virtual void* Alloc() = 0;
    virtual void Free( void* ) = 0;
    virtual void SetTracked() = 0;
};


/*
	Template child class to create pools of the correct type.
*/
template< int ITEM_SIZE >
class MemPoolT : public MemPool
{
public:
    MemPoolT() : _blockPtrs(), _root(0), _currentAllocs(0), _nAllocs(0), _maxAllocs(0), _nUntracked(0)	{}
    ~MemPoolT() {
        MemPoolT< ITEM_SIZE >::Clear();
    }

    void Clear() {
        // Delete the blocks.
        while( !_blockPtrs.Empty()) {
            Block* lastBlock = _blockPtrs.Pop();
            delete lastBlock;
        }
        _root = 0;
        _currentAllocs = 0;
        _nAllocs = 0;
        _maxAllocs = 0;
        _nUntracked = 0;
    }

    virtual int ItemSize() const	{
        return ITEM_SIZE;
    }
    int CurrentAllocs() const		{
        return _currentAllocs;
    }

    virtual void* Alloc() {
        if ( !_root ) {
            // Need a new block.
            Block* block = new Block();
            _blockPtrs.Push( block );

            Item* blockItems = block->items;
            for( int i = 0; i < ITEMS_PER_BLOCK - 1; ++i ) {
                blockItems[i].next = &(blockItems[i + 1]);
            }
            blockItems[ITEMS_PER_BLOCK - 1].next = 0;
            _root = blockItems;
        }
        Item* const result = _root;
        TIXMLASSERT( result != 0 );
        _root = _root->next;

        ++_currentAllocs;
        if ( _currentAllocs > _maxAllocs ) {
            _maxAllocs = _currentAllocs;
        }
        ++_nAllocs;
        ++_nUntracked;
        return result;
    }

    virtual void Free( void* mem ) {
        if ( !mem ) {
            return;
        }
        --_currentAllocs;
        Item* item = static_cast<Item*>( mem );
#ifdef TINYXML2_DEBUG
        memset( item, 0xfe, sizeof( *item ) );
#endif
        item->next = _root;
        _root = item;
    }
    void Trace( const char* name ) {
        printf( "Mempool %s watermark=%d [%dk] current=%d size=%d nAlloc=%d blocks=%d\n",
                name, _maxAllocs, _maxAllocs * ITEM_SIZE / 1024, _currentAllocs,
                ITEM_SIZE, _nAllocs, _blockPtrs.Size() );
    }

    void SetTracked() {
        --_nUntracked;
    }

    int Untracked() const {
        return _nUntracked;
    }

	// This number is perf sensitive. 4k seems like a good tradeoff on my machine.
	// The test file is large, 170k.
	// Release:		VS2010 gcc(no opt)
	//		1k:		4000
	//		2k:		4000
	//		4k:		3900	21000
	//		16k:	5200
	//		32k:	4300
	//		64k:	4000	21000
    // Declared public because some compilers do not accept to use ITEMS_PER_BLOCK
    // in private part if ITEMS_PER_BLOCK is private
    enum { ITEMS_PER_BLOCK = (4 * 1024) / ITEM_SIZE };

private:
    MemPoolT( const MemPoolT& ); // not supported
    void operator=( const MemPoolT& ); // not supported

    union Item {
        Item*   next;
        char    itemData[ITEM_SIZE];
    };
    struct Block {
        Item items[ITEMS_PER_BLOCK];
    };
    DynArray< Block*, 10 > _blockPtrs;
    Item* _root;

    int _currentAllocs;
    int _nAllocs;
    int _maxAllocs;
    int _nUntracked;
};



/**
	Implements the interface to the "Visitor pattern" (see the Accept() method.)
	If you call the Accept() method, it requires being passed a XMLVisitor
	class to handle callbacks. For nodes that contain other nodes (Document, Element)
	you will get called with a VisitEnter/VisitExit pair. Nodes that are always leafs
	are simply called with Visit().

	If you return 'true' from a Visit method, recursive parsing will continue. If you return
	false, <b>no children of this node or its siblings</b> will be visited.

	All flavors of Visit methods have a default implementation that returns 'true' (continue
	visiting). You need to only override methods that are interesting to you.

	Generally Accept() is called on the XMLDocument, although all nodes support visiting.

	You should never change the document from a callback.

	@sa XMLNode::Accept()
*/
class TINYXML2_LIB XMLVisitor
{
public:
    virtual ~XMLVisitor() {}

    /// Visit a document.
    virtual bool VisitEnter( const XMLDocument& /*doc*/ )			{
        return true;
    }
    /// Visit a document.
    virtual bool VisitExit( const XMLDocument& /*doc*/ )			{
        return true;
    }

    /// Visit an element.
    virtual bool VisitEnter( const XMLElement& /*element*/, const XMLAttribute* /*firstAttribute*/ )	{
        return true;
    }
    /// Visit an element.
    virtual bool VisitExit( const XMLElement& /*element*/ )			{
        return true;
    }

    /// Visit a declaration.
    virtual bool Visit( const XMLDeclaration& /*declaration*/ )		{
        return true;
    }
    /// Visit a text node.
    virtual bool Visit( const XMLText& /*text*/ )					{
        return true;
    }
    /// Visit a comment node.
    virtual bool Visit( const XMLComment& /*comment*/ )				{
        return true;
    }
    /// Visit an unknown node.
    virtual bool Visit( const XMLUnknown& /*unknown*/ )				{
        return true;
    }
};

// WARNING: must match XMLDocument::_errorNames[]
enum XMLError {
    XML_SUCCESS = 0,
    XML_NO_ATTRIBUTE,
    XML_WRONG_ATTRIBUTE_TYPE,
    XML_ERROR_FILE_NOT_FOUND,
    XML_ERROR_FILE_COULD_NOT_BE_OPENED,
    XML_ERROR_FILE_READ_ERROR,
    XML_ERROR_PARSING_ELEMENT,
    XML_ERROR_PARSING_ATTRIBUTE,
    XML_ERROR_PARSING_TEXT,
    XML_ERROR_PARSING_CDATA,
    XML_ERROR_PARSING_COMMENT,
    XML_ERROR_PARSING_DECLARATION,
    XML_ERROR_PARSING_UNKNOWN,
    XML_ERROR_EMPTY_DOCUMENT,
    XML_ERROR_MISMATCHED_ELEMENT,
    XML_ERROR_PARSING,
    XML_CAN_NOT_CONVERT_TEXT,
    XML_NO_TEXT_NODE,
	XML_ELEMENT_DEPTH_EXCEEDED,

	XML_ERROR_COUNT
};


/*
	Utility functionality.
*/
class TINYXML2_LIB XMLUtil
{
public:
    static const char* SkipWhiteSpace( const char* p, int* curLineNumPtr )	{
        TIXMLASSERT( p );

        while( IsWhiteSpace(*p) ) {
            if (curLineNumPtr && *p == '\n') {
                ++(*curLineNumPtr);
            }
            ++p;
        }
        TIXMLASSERT( p );
        return p;
    }
    static char* SkipWhiteSpace( char* const p, int* curLineNumPtr ) {
        return const_cast<char*>( SkipWhiteSpace( const_cast<const char*>(p), curLineNumPtr ) );
    }

    // Anything in the high order range of UTF-8 is assumed to not be whitespace. This isn't
    // correct, but simple, and usually works.
    static bool IsWhiteSpace( char p )					{
        return !IsUTF8Continuation(p) && isspace( static_cast<unsigned char>(p) );
    }

    inline static bool IsNameStartChar( unsigned char ch ) {
        if ( ch >= 128 ) {
            // This is a heuristic guess in attempt to not implement Unicode-aware isalpha()
            return true;
        }
        if ( isalpha( ch ) ) {
            return true;
        }
        return ch == ':' || ch == '_';
    }

    inline static bool IsNameChar( unsigned char ch ) {
        return IsNameStartChar( ch )
               || isdigit( ch )
               || ch == '.'
               || ch == '-';
    }

    inline static bool StringEqual( const char* p, const char* q, int nChar=INT_MAX )  {
        if ( p == q ) {
            return true;
        }
        TIXMLASSERT( p );
        TIXMLASSERT( q );
        TIXMLASSERT( nChar >= 0 );
        return strncmp( p, q, nChar ) == 0;
    }

    inline static bool IsUTF8Continuation( const char p ) {
        return ( p & 0x80 ) != 0;
    }

    static const char* ReadBOM( const char* p, bool* hasBOM );
    // p is the starting location,
    // the UTF-8 value of the entity will be placed in value, and length filled in.
    static const char* GetCharacterRef( const char* p, char* value, int* length );
    static void ConvertUTF32ToUTF8( unsigned long input, char* output, int* length );

    // converts primitive types to strings
    static void ToStr( int v, char* buffer, int bufferSize );
    static void ToStr( unsigned v, char* buffer, int bufferSize );
    static void ToStr( bool v, char* buffer, int bufferSize );
    static void ToStr( float v, char* buffer, int bufferSize );
    static void ToStr( double v, char* buffer, int bufferSize );
	static void ToStr(int64_t v, char* buffer, int bufferSize);
    static void ToStr(uint64_t v, char* buffer, int bufferSize);

    // converts strings to primitive types
    static bool	ToInt( const char* str, int* value );
    static bool ToUnsigned( const char* str, unsigned* value );
    static bool	ToBool( const char* str, bool* value );
    static bool	ToFloat( const char* str, float* value );
    static bool ToDouble( const char* str, double* value );
	static bool ToInt64(const char* str, int64_t* value);
    static bool ToUnsigned64(const char* str, uint64_t* value);
	// Changes what is serialized for a boolean value.
	// Default to "true" and "false". Shouldn't be changed
	// unless you have a special testing or compatibility need.
	// Be careful: static, global, & not thread safe.
	// Be sure to set static const memory as parameters.
	static void SetBoolSerialization(const char* writeTrue, const char* writeFalse);

private:
	static const char* writeBoolTrue;
	static const char* writeBoolFalse;
};


/** XMLNode is a base class for every object that is in the
	XML Document Object Model (DOM), except XMLAttributes.
	Nodes have siblings, a parent, and children which can
	be navigated. A node is always in a XMLDocument.
	The type of a XMLNode can be queried, and it can
	be cast to its more defined type.

	A XMLDocument allocates memory for all its Nodes.
	When the XMLDocument gets deleted, all its Nodes
	will also be deleted.

	@verbatim
	A Document can contain:	Element	(container or leaf)
							Comment (leaf)
							Unknown (leaf)
							Declaration( leaf )

	An Element can contain:	Element (container or leaf)
							Text	(leaf)
							Attributes (not on tree)
							Comment (leaf)
							Unknown (leaf)

	@endverbatim
*/
class TINYXML2_LIB XMLNode
{
    friend class XMLDocument;
    friend class XMLElement;
public:

    /// Get the XMLDocument that owns this XMLNode.
    const XMLDocument* GetDocument() const	{
        TIXMLASSERT( _document );
        return _document;
    }
    /// Get the XMLDocument that owns this XMLNode.
    XMLDocument* GetDocument()				{
        TIXMLASSERT( _document );
        return _document;
    }

    /// Safely cast to an Element, or null.
    virtual XMLElement*		ToElement()		{
        return 0;
    }
    /// Safely cast to Text, or null.
    virtual XMLText*		ToText()		{
        return 0;
    }
    /// Safely cast to a Comment, or null.
    virtual XMLComment*		ToComment()		{
        return 0;
    }
    /// Safely cast to a Document, or null.
    virtual XMLDocument*	ToDocument()	{
        return 0;
    }
    /// Safely cast to a Declaration, or null.
    virtual XMLDeclaration*	ToDeclaration()	{
        return 0;
    }
    /// Safely cast to an Unknown, or null.
    virtual XMLUnknown*		ToUnknown()		{
        return 0;
    }

    virtual const XMLElement*		ToElement() const		{
        return 0;
    }
    virtual const XMLText*			ToText() const			{
        return 0;
    }
    virtual const XMLComment*		ToComment() const		{
        return 0;
    }
    virtual const XMLDocument*		ToDocument() const		{
        return 0;
    }
    virtual const XMLDeclaration*	ToDeclaration() const	{
        return 0;
    }
    virtual const XMLUnknown*		ToUnknown() const		{
        return 0;
    }

    /** The meaning of 'value' changes for the specific type.
    	@verbatim
    	Document:	empty (NULL is returned, not an empty string)
    	Element:	name of the element
    	Comment:	the comment text
    	Unknown:	the tag contents
    	Text:		the text string
    	@endverbatim
    */
    const char* Value() const;

    /** Set the Value of an XML node.
    	@sa Value()
    */
    void SetValue( const char* val, bool staticMem=false );

    /// Gets the line number the node is in, if the document was parsed from a file.
    int GetLineNum() const { return _parseLineNum; }

    /// Get the parent of this node on the DOM.
    const XMLNode*	Parent() const			{
        return _parent;
    }

    XMLNode* Parent()						{
        return _parent;
    }

    /// Returns true if this node has no children.
    bool NoChildren() const					{
        return !_firstChild;
    }

    /// Get the first child node, or null if none exists.
    const XMLNode*  FirstChild() const		{
        return _firstChild;
    }

    XMLNode*		FirstChild()			{
        return _firstChild;
    }

    /** Get the first child element, or optionally the first child
        element with the specified name.
    */
    const XMLElement* FirstChildElement( const char* name = 0 ) const;

    XMLElement* FirstChildElement( const char* name = 0 )	{
        return const_cast<XMLElement*>(const_cast<const XMLNode*>(this)->FirstChildElement( name ));
    }

    /// Get the last child node, or null if none exists.
    const XMLNode*	LastChild() const						{
        return _lastChild;
    }

    XMLNode*		LastChild()								{
        return _lastChild;
    }

    /** Get the last child element or optionally the last child
        element with the specified name.
    */
    const XMLElement* LastChildElement( const char* name = 0 ) const;

    XMLElement* LastChildElement( const char* name = 0 )	{
        return const_cast<XMLElement*>(const_cast<const XMLNode*>(this)->LastChildElement(name) );
    }

    /// Get the previous (left) sibling node of this node.
    const XMLNode*	PreviousSibling() const					{
        return _prev;
    }

    XMLNode*	PreviousSibling()							{
        return _prev;
    }

    /// Get the previous (left) sibling element of this node, with an optionally supplied name.
    const XMLElement*	PreviousSiblingElement( const char* name = 0 ) const ;

    XMLElement*	PreviousSiblingElement( const char* name = 0 ) {
        return const_cast<XMLElement*>(const_cast<const XMLNode*>(this)->PreviousSiblingElement( name ) );
    }

    /// Get the next (right) sibling node of this node.
    const XMLNode*	NextSibling() const						{
        return _next;
    }

    XMLNode*	NextSibling()								{
        return _next;
    }

    /// Get the next (right) sibling element of this node, with an optionally supplied name.
    const XMLElement*	NextSiblingElement( const char* name = 0 ) const;

    XMLElement*	NextSiblingElement( const char* name = 0 )	{
        return const_cast<XMLElement*>(const_cast<const XMLNode*>(this)->NextSiblingElement( name ) );
    }

    /**
    	Add a child node as the last (right) child.
		If the child node is already part of the document,
		it is moved from its old location to the new location.
		Returns the addThis argument or 0 if the node does not
		belong to the same document.
    */
    XMLNode* InsertEndChild( XMLNode* addThis );

    XMLNode* LinkEndChild( XMLNode* addThis )	{
        return InsertEndChild( addThis );
    }
    /**
    	Add a child node as the first (left) child.
		If the child node is already part of the document,
		it is moved from its old location to the new location.
		Returns the addThis argument or 0 if the node does not
		belong to the same document.
    */
    XMLNode* InsertFirstChild( XMLNode* addThis );
    /**
    	Add a node after the specified child node.
		If the child node is already part of the document,
		it is moved from its old location to the new location.
		Returns the addThis argument or 0 if the afterThis node
		is not a child of this node, or if the node does not
		belong to the same document.
    */
    XMLNode* InsertAfterChild( XMLNode* afterThis, XMLNode* addThis );

    /**
    	Delete all the children of this node.
    */
    void DeleteChildren();

    /**
    	Delete a child of this node.
    */
    void DeleteChild( XMLNode* node );

    /**
    	Make a copy of this node, but not its children.
    	You may pass in a Document pointer that will be
    	the owner of the new Node. If the 'document' is
    	null, then the node returned will be allocated
    	from the current Document. (this->GetDocument())

    	Note: if called on a XMLDocument, this will return null.
    */
    virtual XMLNode* ShallowClone( XMLDocument* document ) const = 0;

	/**
		Make a copy of this node and all its children.

		If the 'target' is null, then the nodes will
		be allocated in the current document. If 'target'
        is specified, the memory will be allocated is the
        specified XMLDocument.

		NOTE: This is probably not the correct tool to
		copy a document, since XMLDocuments can have multiple
		top level XMLNodes. You probably want to use
        XMLDocument::DeepCopy()
	*/
	XMLNode* DeepClone( XMLDocument* target ) const;

    /**
    	Test if 2 nodes are the same, but don't test children.
    	The 2 nodes do not need to be in the same Document.

    	Note: if called on a XMLDocument, this will return false.
    */
    virtual bool ShallowEqual( const XMLNode* compare ) const = 0;

    /** Accept a hierarchical visit of the nodes in the TinyXML-2 DOM. Every node in the
    	XML tree will be conditionally visited and the host will be called back
    	via the XMLVisitor interface.

    	This is essentially a SAX interface for TinyXML-2. (Note however it doesn't re-parse
    	the XML for the callbacks, so the performance of TinyXML-2 is unchanged by using this
    	interface versus any other.)

    	The interface has been based on ideas from:

    	- http://www.saxproject.org/
    	- http://c2.com/cgi/wiki?HierarchicalVisitorPattern

    	Which are both good references for "visiting".

    	An example of using Accept():
    	@verbatim
    	XMLPrinter printer;
    	tinyxmlDoc.Accept( &printer );
    	const char* xmlcstr = printer.CStr();
    	@endverbatim
    */
    virtual bool Accept( XMLVisitor* visitor ) const = 0;

	/**
		Set user data into the XMLNode. TinyXML-2 in
		no way processes or interprets user data.
		It is initially 0.
	*/
	void SetUserData(void* userData)	{ _userData = userData; }

	/**
		Get user data set into the XMLNode. TinyXML-2 in
		no way processes or interprets user data.
		It is initially 0.
	*/
	void* GetUserData() const			{ return _userData; }

protected:
    explicit XMLNode( XMLDocument* );
    virtual ~XMLNode();

    virtual char* ParseDeep( char* p, StrPair* parentEndTag, int* curLineNumPtr);

    XMLDocument*	_document;
    XMLNode*		_parent;
    mutable StrPair	_value;
    int             _parseLineNum;

    XMLNode*		_firstChild;
    XMLNode*		_lastChild;

    XMLNode*		_prev;
    XMLNode*		_next;

	void*			_userData;

private:
    MemPool*		_memPool;
    void Unlink( XMLNode* child );
    static void DeleteNode( XMLNode* node );
    void InsertChildPreamble( XMLNode* insertThis ) const;
    const XMLElement* ToElementWithName( const char* name ) const;

    XMLNode( const XMLNode& );	// not supported
    XMLNode& operator=( const XMLNode& );	// not supported
};


/** XML text.

	Note that a text node can have child element nodes, for example:
	@verbatim
	<root>This is <b>bold</b></root>
	@endverbatim

	A text node can have 2 ways to output the next. "normal" output
	and CDATA. It will default to the mode it was parsed from the XML file and
	you generally want to leave it alone, but you can change the output mode with
	SetCData() and query it with CData().
*/
class TINYXML2_LIB XMLText : public XMLNode
{
    friend class XMLDocument;
public:
    virtual bool Accept( XMLVisitor* visitor ) const;

    virtual XMLText* ToText()			{
        return this;
    }
    virtual const XMLText* ToText() const	{
        return this;
    }

    /// Declare whether this should be CDATA or standard text.
    void SetCData( bool isCData )			{
        _isCData = isCData;
    }
    /// Returns true if this is a CDATA text element.
    bool CData() const						{
        return _isCData;
    }

    virtual XMLNode* ShallowClone( XMLDocument* document ) const;
    virtual bool ShallowEqual( const XMLNode* compare ) const;

protected:
    explicit XMLText( XMLDocument* doc )	: XMLNode( doc ), _isCData( false )	{}
    virtual ~XMLText()												{}

    char* ParseDeep( char* p, StrPair* parentEndTag, int* curLineNumPtr );

private:
    bool _isCData;

    XMLText( const XMLText& );	// not supported
    XMLText& operator=( const XMLText& );	// not supported
};


/** An XML Comment. */
class TINYXML2_LIB XMLComment : public XMLNode
{
    friend class XMLDocument;
public:
    virtual XMLComment*	ToComment()					{
        return this;
    }
    virtual const XMLComment* ToComment() const		{
        return this;
    }

    virtual bool Accept( XMLVisitor* visitor ) const;

    virtual XMLNode* ShallowClone( XMLDocument* document ) const;
    virtual bool ShallowEqual( const XMLNode* compare ) const;

protected:
    explicit XMLComment( XMLDocument* doc );
    virtual ~XMLComment();

    char* ParseDeep( char* p, StrPair* parentEndTag, int* curLineNumPtr);

private:
    XMLComment( const XMLComment& );	// not supported
    XMLComment& operator=( const XMLComment& );	// not supported
};


/** In correct XML the declaration is the first entry in the file.
	@verbatim
		<?xml version="1.0" standalone="yes"?>
	@endverbatim

	TinyXML-2 will happily read or write files without a declaration,
	however.

	The text of the declaration isn't interpreted. It is parsed
	and written as a string.
*/
class TINYXML2_LIB XMLDeclaration : public XMLNode
{
    friend class XMLDocument;
public:
    virtual XMLDeclaration*	ToDeclaration()					{
        return this;
    }
    virtual const XMLDeclaration* ToDeclaration() const		{
        return this;
    }

    virtual bool Accept( XMLVisitor* visitor ) const;

    virtual XMLNode* ShallowClone( XMLDocument* document ) const;
    virtual bool ShallowEqual( const XMLNode* compare ) const;

protected:
    explicit XMLDeclaration( XMLDocument* doc );
    virtual ~XMLDeclaration();

    char* ParseDeep( char* p, StrPair* parentEndTag, int* curLineNumPtr );

private:
    XMLDeclaration( const XMLDeclaration& );	// not supported
    XMLDeclaration& operator=( const XMLDeclaration& );	// not supported
};


/** Any tag that TinyXML-2 doesn't recognize is saved as an
	unknown. It is a tag of text, but should not be modified.
	It will be written back to the XML, unchanged, when the file
	is saved.

	DTD tags get thrown into XMLUnknowns.
*/
class TINYXML2_LIB XMLUnknown : public XMLNode
{
    friend class XMLDocument;
public:
    virtual XMLUnknown*	ToUnknown()					{
        return this;
    }
    virtual const XMLUnknown* ToUnknown() const		{
        return this;
    }

    virtual bool Accept( XMLVisitor* visitor ) const;

    virtual XMLNode* ShallowClone( XMLDocument* document ) const;
    virtual bool ShallowEqual( const XMLNode* compare ) const;

protected:
    explicit XMLUnknown( XMLDocument* doc );
    virtual ~XMLUnknown();

    char* ParseDeep( char* p, StrPair* parentEndTag, int* curLineNumPtr );

private:
    XMLUnknown( const XMLUnknown& );	// not supported
    XMLUnknown& operator=( const XMLUnknown& );	// not supported
};



/** An attribute is a name-value pair. Elements have an arbitrary
	number of attributes, each with a unique name.

	@note The attributes are not XMLNodes. You may only query the
	Next() attribute in a list.
*/
class TINYXML2_LIB XMLAttribute
{
    friend class XMLElement;
public:
    /// The name of the attribute.
    const char* Name() const;

    /// The value of the attribute.
    const char* Value() const;

    /// Gets the line number the attribute is in, if the document was parsed from a file.
    int GetLineNum() const { return _parseLineNum; }

    /// The next attribute in the list.
    const XMLAttribute* Next() const {
        return _next;
    }

    /** IntValue interprets the attribute as an integer, and returns the value.
        If the value isn't an integer, 0 will be returned. There is no error checking;
    	use QueryIntValue() if you need error checking.
    */
	int	IntValue() const {
		int i = 0;
		QueryIntValue(&i);
		return i;
	}

	int64_t Int64Value() const {
		int64_t i = 0;
		QueryInt64Value(&i);
		return i;
	}

    uint64_t Unsigned64Value() const {
        uint64_t i = 0;
        QueryUnsigned64Value(&i);
        return i;
    }

    /// Query as an unsigned integer. See IntValue()
    unsigned UnsignedValue() const			{
        unsigned i=0;
        QueryUnsignedValue( &i );
        return i;
    }
    /// Query as a boolean. See IntValue()
    bool	 BoolValue() const				{
        bool b=false;
        QueryBoolValue( &b );
        return b;
    }
    /// Query as a double. See IntValue()
    double 	 DoubleValue() const			{
        double d=0;
        QueryDoubleValue( &d );
        return d;
    }
    /// Query as a float. See IntValue()
    float	 FloatValue() const				{
        float f=0;
        QueryFloatValue( &f );
        return f;
    }

    /** QueryIntValue interprets the attribute as an integer, and returns the value
    	in the provided parameter. The function will return XML_SUCCESS on success,
    	and XML_WRONG_ATTRIBUTE_TYPE if the conversion is not successful.
    */
    XMLError QueryIntValue( int* value ) const;
    /// See QueryIntValue
    XMLError QueryUnsignedValue( unsigned int* value ) const;
	/// See QueryIntValue
	XMLError QueryInt64Value(int64_t* value) const;
    /// See QueryIntValue
    XMLError QueryUnsigned64Value(uint64_t* value) const;
	/// See QueryIntValue
    XMLError QueryBoolValue( bool* value ) const;
    /// See QueryIntValue
    XMLError QueryDoubleValue( double* value ) const;
    /// See QueryIntValue
    XMLError QueryFloatValue( float* value ) const;

    /// Set the attribute to a string value.
    void SetAttribute( const char* value );
    /// Set the attribute to value.
    void SetAttribute( int value );
    /// Set the attribute to value.
    void SetAttribute( unsigned value );
	/// Set the attribute to value.
	void SetAttribute(int64_t value);
    /// Set the attribute to value.
    void SetAttribute(uint64_t value);
    /// Set the attribute to value.
    void SetAttribute( bool value );
    /// Set the attribute to value.
    void SetAttribute( double value );
    /// Set the attribute to value.
    void SetAttribute( float value );

private:
    enum { BUF_SIZE = 200 };

    XMLAttribute() : _name(), _value(),_parseLineNum( 0 ), _next( 0 ), _memPool( 0 ) {}
    virtual ~XMLAttribute()	{}

    XMLAttribute( const XMLAttribute& );	// not supported
    void operator=( const XMLAttribute& );	// not supported
    void SetName( const char* name );

    char* ParseDeep( char* p, bool processEntities, int* curLineNumPtr );

    mutable StrPair _name;
    mutable StrPair _value;
    int             _parseLineNum;
    XMLAttribute*   _next;
    MemPool*        _memPool;
};


/** The element is a container class. It has a value, the element name,
	and can contain other elements, text, comments, and unknowns.
	Elements also contain an arbitrary number of attributes.
*/
class TINYXML2_LIB XMLElement : public XMLNode
{
    friend class XMLDocument;
public:
    /// Get the name of an element (which is the Value() of the node.)
    const char* Name() const		{
        return Value();
    }
    /// Set the name of the element.
    void SetName( const char* str, bool staticMem=false )	{
        SetValue( str, staticMem );
    }

    virtual XMLElement* ToElement()				{
        return this;
    }
    virtual const XMLElement* ToElement() const {
        return this;
    }
    virtual bool Accept( XMLVisitor* visitor ) const;

    /** Given an attribute name, Attribute() returns the value
    	for the attribute of that name, or null if none
    	exists. For example:

    	@verbatim
    	const char* value = ele->Attribute( "foo" );
    	@endverbatim

    	The 'value' parameter is normally null. However, if specified,
    	the attribute will only be returned if the 'name' and 'value'
    	match. This allow you to write code:

    	@verbatim
    	if ( ele->Attribute( "foo", "bar" ) ) callFooIsBar();
    	@endverbatim

    	rather than:
    	@verbatim
    	if ( ele->Attribute( "foo" ) ) {
    		if ( strcmp( ele->Attribute( "foo" ), "bar" ) == 0 ) callFooIsBar();
    	}
    	@endverbatim
    */
    const char* Attribute( const char* name, const char* value=0 ) const;

    /** Given an attribute name, IntAttribute() returns the value
    	of the attribute interpreted as an integer. The default
        value will be returned if the attribute isn't present,
        or if there is an error. (For a method with error
    	checking, see QueryIntAttribute()).
    */
	int IntAttribute(const char* name, int defaultValue = 0) const;
    /// See IntAttribute()
	unsigned UnsignedAttribute(const char* name, unsigned defaultValue = 0) const;
	/// See IntAttribute()
	int64_t Int64Attribute(const char* name, int64_t defaultValue = 0) const;
    /// See IntAttribute()
    uint64_t Unsigned64Attribute(const char* name, uint64_t defaultValue = 0) const;
	/// See IntAttribute()
	bool BoolAttribute(const char* name, bool defaultValue = false) const;
    /// See IntAttribute()
	double DoubleAttribute(const char* name, double defaultValue = 0) const;
    /// See IntAttribute()
	float FloatAttribute(const char* name, float defaultValue = 0) const;

    /** Given an attribute name, QueryIntAttribute() returns
    	XML_SUCCESS, XML_WRONG_ATTRIBUTE_TYPE if the conversion
    	can't be performed, or XML_NO_ATTRIBUTE if the attribute
    	doesn't exist. If successful, the result of the conversion
    	will be written to 'value'. If not successful, nothing will
    	be written to 'value'. This allows you to provide default
    	value:

    	@verbatim
    	int value = 10;
    	QueryIntAttribute( "foo", &value );		// if "foo" isn't found, value will still be 10
    	@endverbatim
    */
    XMLError QueryIntAttribute( const char* name, int* value ) const				{
        const XMLAttribute* a = FindAttribute( name );
        if ( !a ) {
            return XML_NO_ATTRIBUTE;
        }
        return a->QueryIntValue( value );
    }

	/// See QueryIntAttribute()
    XMLError QueryUnsignedAttribute( const char* name, unsigned int* value ) const	{
        const XMLAttribute* a = FindAttribute( name );
        if ( !a ) {
            return XML_NO_ATTRIBUTE;
        }
        return a->QueryUnsignedValue( value );
    }

	/// See QueryIntAttribute()
	XMLError QueryInt64Attribute(const char* name, int64_t* value) const {
		const XMLAttribute* a = FindAttribute(name);
		if (!a) {
			return XML_NO_ATTRIBUTE;
		}
		return a->QueryInt64Value(value);
	}

    /// See QueryIntAttribute()
    XMLError QueryUnsigned64Attribute(const char* name, uint64_t* value) const {
        const XMLAttribute* a = FindAttribute(name);
        if(!a) {
            return XML_NO_ATTRIBUTE;
        }
        return a->QueryUnsigned64Value(value);
    }

	/// See QueryIntAttribute()
    XMLError QueryBoolAttribute( const char* name, bool* value ) const				{
        const XMLAttribute* a = FindAttribute( name );
        if ( !a ) {
            return XML_NO_ATTRIBUTE;
        }
        return a->QueryBoolValue( value );
    }
    /// See QueryIntAttribute()
    XMLError QueryDoubleAttribute( const char* name, double* value ) const			{
        const XMLAttribute* a = FindAttribute( name );
        if ( !a ) {
            return XML_NO_ATTRIBUTE;
        }
        return a->QueryDoubleValue( value );
    }
    /// See QueryIntAttribute()
    XMLError QueryFloatAttribute( const char* name, float* value ) const			{
        const XMLAttribute* a = FindAttribute( name );
        if ( !a ) {
            return XML_NO_ATTRIBUTE;
        }
        return a->QueryFloatValue( value );
    }

	/// See QueryIntAttribute()
	XMLError QueryStringAttribute(const char* name, const char** value) const {
		const XMLAttribute* a = FindAttribute(name);
		if (!a) {
			return XML_NO_ATTRIBUTE;
		}
		*value = a->Value();
		return XML_SUCCESS;
	}



    /** Given an attribute name, QueryAttribute() returns
    	XML_SUCCESS, XML_WRONG_ATTRIBUTE_TYPE if the conversion
    	can't be performed, or XML_NO_ATTRIBUTE if the attribute
    	doesn't exist. It is overloaded for the primitive types,
		and is a generally more convenient replacement of
		QueryIntAttribute() and related functions.

		If successful, the result of the conversion
    	will be written to 'value'. If not successful, nothing will
    	be written to 'value'. This allows you to provide default
    	value:

    	@verbatim
    	int value = 10;
    	QueryAttribute( "foo", &value );		// if "foo" isn't found, value will still be 10
    	@endverbatim
    */
	XMLError QueryAttribute( const char* name, int* value ) const {
		return QueryIntAttribute( name, value );
	}

	XMLError QueryAttribute( const char* name, unsigned int* value ) const {
		return QueryUnsignedAttribute( name, value );
	}

	XMLError QueryAttribute(const char* name, int64_t* value) const {
		return QueryInt64Attribute(name, value);
	}

    XMLError QueryAttribute(const char* name, uint64_t* value) const {
        return QueryUnsigned64Attribute(name, value);
    }

    XMLError QueryAttribute( const char* name, bool* value ) const {
		return QueryBoolAttribute( name, value );
	}

	XMLError QueryAttribute( const char* name, double* value ) const {
		return QueryDoubleAttribute( name, value );
	}

	XMLError QueryAttribute( const char* name, float* value ) const {
		return QueryFloatAttribute( name, value );
	}

	/// Sets the named attribute to value.
    void SetAttribute( const char* name, const char* value )	{
        XMLAttribute* a = FindOrCreateAttribute( name );
        a->SetAttribute( value );
    }
    /// Sets the named attribute to value.
    void SetAttribute( const char* name, int value )			{
        XMLAttribute* a = FindOrCreateAttribute( name );
        a->SetAttribute( value );
    }
    /// Sets the named attribute to value.
    void SetAttribute( const char* name, unsigned value )		{
        XMLAttribute* a = FindOrCreateAttribute( name );
        a->SetAttribute( value );
    }

	/// Sets the named attribute to value.
	void SetAttribute(const char* name, int64_t value) {
		XMLAttribute* a = FindOrCreateAttribute(name);
		a->SetAttribute(value);
	}

    /// Sets the named attribute to value.
    void SetAttribute(const char* name, uint64_t value) {
        XMLAttribute* a = FindOrCreateAttribute(name);
        a->SetAttribute(value);
    }
    
    /// Sets the named attribute to value.
    void SetAttribute( const char* name, bool value )			{
        XMLAttribute* a = FindOrCreateAttribute( name );
        a->SetAttribute( value );
    }
    /// Sets the named attribute to value.
    void SetAttribute( const char* name, double value )		{
        XMLAttribute* a = FindOrCreateAttribute( name );
        a->SetAttribute( value );
    }
    /// Sets the named attribute to value.
    void SetAttribute( const char* name, float value )		{
        XMLAttribute* a = FindOrCreateAttribute( name );
        a->SetAttribute( value );
    }

    /**
    	Delete an attribute.
    */
    void DeleteAttribute( const char* name );

    /// Return the first attribute in the list.
    const XMLAttribute* FirstAttribute() const {
        return _rootAttribute;
    }
    /// Query a specific attribute in the list.
    const XMLAttribute* FindAttribute( const char* name ) const;

    /** Convenience function for easy access to the text inside an element. Although easy
    	and concise, GetText() is limited compared to getting the XMLText child
    	and accessing it directly.

    	If the first child of 'this' is a XMLText, the GetText()
    	returns the character string of the Text node, else null is returned.

    	This is a convenient method for getting the text of simple contained text:
    	@verbatim
    	<foo>This is text</foo>
    		const char* str = fooElement->GetText();
    	@endverbatim

    	'str' will be a pointer to "This is text".

    	Note that this function can be misleading. If the element foo was created from
    	this XML:
    	@verbatim
    		<foo><b>This is text</b></foo>
    	@endverbatim

    	then the value of str would be null. The first child node isn't a text node, it is
    	another element. From this XML:
    	@verbatim
    		<foo>This is <b>text</b></foo>
    	@endverbatim
    	GetText() will return "This is ".
    */
    const char* GetText() const;

    /** Convenience function for easy access to the text inside an element. Although easy
    	and concise, SetText() is limited compared to creating an XMLText child
    	and mutating it directly.

    	If the first child of 'this' is a XMLText, SetText() sets its value to
		the given string, otherwise it will create a first child that is an XMLText.

    	This is a convenient method for setting the text of simple contained text:
    	@verbatim
    	<foo>This is text</foo>
    		fooElement->SetText( "Hullaballoo!" );
     	<foo>Hullaballoo!</foo>
		@endverbatim

    	Note that this function can be misleading. If the element foo was created from
    	this XML:
    	@verbatim
    		<foo><b>This is text</b></foo>
    	@endverbatim

    	then it will not change "This is text", but rather prefix it with a text element:
    	@verbatim
    		<foo>Hullaballoo!<b>This is text</b></foo>
    	@endverbatim

		For this XML:
    	@verbatim
    		<foo />
    	@endverbatim
    	SetText() will generate
    	@verbatim
    		<foo>Hullaballoo!</foo>
    	@endverbatim
    */
	void SetText( const char* inText );
    /// Convenience method for setting text inside an element. See SetText() for important limitations.
    void SetText( int value );
    /// Convenience method for setting text inside an element. See SetText() for important limitations.
    void SetText( unsigned value );
	/// Convenience method for setting text inside an element. See SetText() for important limitations.
	void SetText(int64_t value);
    /// Convenience method for setting text inside an element. See SetText() for important limitations.
    void SetText(uint64_t value);
	/// Convenience method for setting text inside an element. See SetText() for important limitations.
    void SetText( bool value );
    /// Convenience method for setting text inside an element. See SetText() for important limitations.
    void SetText( double value );
    /// Convenience method for setting text inside an element. See SetText() for important limitations.
    void SetText( float value );

    /**
    	Convenience method to query the value of a child text node. This is probably best
    	shown by example. Given you have a document is this form:
    	@verbatim
    		<point>
    			<x>1</x>
    			<y>1.4</y>
    		</point>
    	@endverbatim

    	The QueryIntText() and similar functions provide a safe and easier way to get to the
    	"value" of x and y.

    	@verbatim
    		int x = 0;
    		float y = 0;	// types of x and y are contrived for example
    		const XMLElement* xElement = pointElement->FirstChildElement( "x" );
    		const XMLElement* yElement = pointElement->FirstChildElement( "y" );
    		xElement->QueryIntText( &x );
    		yElement->QueryFloatText( &y );
    	@endverbatim

    	@returns XML_SUCCESS (0) on success, XML_CAN_NOT_CONVERT_TEXT if the text cannot be converted
    			 to the requested type, and XML_NO_TEXT_NODE if there is no child text to query.

    */
    XMLError QueryIntText( int* ival ) const;
    /// See QueryIntText()
    XMLError QueryUnsignedText( unsigned* uval ) const;
	/// See QueryIntText()
	XMLError QueryInt64Text(int64_t* uval) const;
	/// See QueryIntText()
	XMLError QueryUnsigned64Text(uint64_t* uval) const;
	/// See QueryIntText()
    XMLError QueryBoolText( bool* bval ) const;
    /// See QueryIntText()
    XMLError QueryDoubleText( double* dval ) const;
    /// See QueryIntText()
    XMLError QueryFloatText( float* fval ) const;

	int IntText(int defaultValue = 0) const;

	/// See QueryIntText()
	unsigned UnsignedText(unsigned defaultValue = 0) const;
	/// See QueryIntText()
	int64_t Int64Text(int64_t defaultValue = 0) const;
    /// See QueryIntText()
    uint64_t Unsigned64Text(uint64_t defaultValue = 0) const;
	/// See QueryIntText()
	bool BoolText(bool defaultValue = false) const;
	/// See QueryIntText()
	double DoubleText(double defaultValue = 0) const;
	/// See QueryIntText()
    float FloatText(float defaultValue = 0) const;

    /**
        Convenience method to create a new XMLElement and add it as last (right)
        child of this node. Returns the created and inserted element.
    */
    XMLElement* InsertNewChildElement(const char* name);
    /// See InsertNewChildElement()
    XMLComment* InsertNewComment(const char* comment);
    /// See InsertNewChildElement()
    XMLText* InsertNewText(const char* text);
    /// See InsertNewChildElement()
    XMLDeclaration* InsertNewDeclaration(const char* text);
    /// See InsertNewChildElement()
    XMLUnknown* InsertNewUnknown(const char* text);


    // internal:
    enum ElementClosingType {
        OPEN,		// <foo>
        CLOSED,		// <foo/>
        CLOSING		// </foo>
    };
    ElementClosingType ClosingType() const {
        return _closingType;
    }
    virtual XMLNode* ShallowClone( XMLDocument* document ) const;
    virtual bool ShallowEqual( const XMLNode* compare ) const;

protected:
    char* ParseDeep( char* p, StrPair* parentEndTag, int* curLineNumPtr );

private:
    XMLElement( XMLDocument* doc );
    virtual ~XMLElement();
    XMLElement( const XMLElement& );	// not supported
    void operator=( const XMLElement& );	// not supported

    XMLAttribute* FindOrCreateAttribute( const char* name );
    char* ParseAttributes( char* p, int* curLineNumPtr );
    static void DeleteAttribute( XMLAttribute* attribute );
    XMLAttribute* CreateAttribute();

    enum { BUF_SIZE = 200 };
    ElementClosingType _closingType;
    // The attribute list is ordered; there is no 'lastAttribute'
    // because the list needs to be scanned for dupes before adding
    // a new attribute.
    XMLAttribute* _rootAttribute;
};


enum Whitespace {
    PRESERVE_WHITESPACE,
    COLLAPSE_WHITESPACE
};


/** A Document binds together all the functionality.
	It can be saved, loaded, and printed to the screen.
	All Nodes are connected and allocated to a Document.
	If the Document is deleted, all its Nodes are also deleted.
*/
class TINYXML2_LIB XMLDocument : public XMLNode
{
    friend class XMLElement;
    // Gives access to SetError and Push/PopDepth, but over-access for everything else.
    // Wishing C++ had "internal" scope.
    friend class XMLNode;
    friend class XMLText;
    friend class XMLComment;
    friend class XMLDeclaration;
    friend class XMLUnknown;
public:
    /// constructor
    XMLDocument( bool processEntities = true, Whitespace whitespaceMode = PRESERVE_WHITESPACE );
    ~XMLDocument();

    virtual XMLDocument* ToDocument()				{
        TIXMLASSERT( this == _document );
        return this;
    }
    virtual const XMLDocument* ToDocument() const	{
        TIXMLASSERT( this == _document );
        return this;
    }

    /**
    	Parse an XML file from a character string.
    	Returns XML_SUCCESS (0) on success, or
    	an errorID.

    	You may optionally pass in the 'nBytes', which is
    	the number of bytes which will be parsed. If not
    	specified, TinyXML-2 will assume 'xml' points to a
    	null terminated string.
    */
    XMLError Parse( const char* xml, size_t nBytes=static_cast<size_t>(-1) );

    /**
    	Load an XML file from disk.
    	Returns XML_SUCCESS (0) on success, or
    	an errorID.
    */
    XMLError LoadFile( const char* filename );

    /**
    	Load an XML file from disk. You are responsible
    	for providing and closing the FILE*.

        NOTE: The file should be opened as binary ("rb")
        not text in order for TinyXML-2 to correctly
        do newline normalization.

    	Returns XML_SUCCESS (0) on success, or
    	an errorID.
    */
    XMLError LoadFile( FILE* );

    /**
    	Save the XML file to disk.
    	Returns XML_SUCCESS (0) on success, or
    	an errorID.
    */
    XMLError SaveFile( const char* filename, bool compact = false );

    /**
    	Save the XML file to disk. You are responsible
    	for providing and closing the FILE*.

    	Returns XML_SUCCESS (0) on success, or
    	an errorID.
    */
    XMLError SaveFile( FILE* fp, bool compact = false );

    bool ProcessEntities() const		{
        return _processEntities;
    }
    Whitespace WhitespaceMode() const	{
        return _whitespaceMode;
    }

    /**
    	Returns true if this document has a leading Byte Order Mark of UTF8.
    */
    bool HasBOM() const {
        return _writeBOM;
    }
    /** Sets whether to write the BOM when writing the file.
    */
    void SetBOM( bool useBOM ) {
        _writeBOM = useBOM;
    }

    /** Return the root element of DOM. Equivalent to FirstChildElement().
        To get the first node, use FirstChild().
    */
    XMLElement* RootElement()				{
        return FirstChildElement();
    }
    const XMLElement* RootElement() const	{
        return FirstChildElement();
    }

    /** Print the Document. If the Printer is not provided, it will
        print to stdout. If you provide Printer, this can print to a file:
    	@verbatim
    	XMLPrinter printer( fp );
    	doc.Print( &printer );
    	@endverbatim

    	Or you can use a printer to print to memory:
    	@verbatim
    	XMLPrinter printer;
    	doc.Print( &printer );
    	// printer.CStr() has a const char* to the XML
    	@endverbatim
    */
    void Print( XMLPrinter* streamer=0 ) const;
    virtual bool Accept( XMLVisitor* visitor ) const;

    /**
    	Create a new Element associated with
    	this Document. The memory for the Element
    	is managed by the Document.
    */
    XMLElement* NewElement( const char* name );
    /**
    	Create a new Comment associated with
    	this Document. The memory for the Comment
    	is managed by the Document.
    */
    XMLComment* NewComment( const char* comment );
    /**
    	Create a new Text associated with
    	this Document. The memory for the Text
    	is managed by the Document.
    */
    XMLText* NewText( const char* text );
    /**
    	Create a new Declaration associated with
    	this Document. The memory for the object
    	is managed by the Document.

    	If the 'text' param is null, the standard
    	declaration is used.:
    	@verbatim
    		<?xml version="1.0" encoding="UTF-8"?>
    	@endverbatim
    */
    XMLDeclaration* NewDeclaration( const char* text=0 );
    /**
    	Create a new Unknown associated with
    	this Document. The memory for the object
    	is managed by the Document.
    */
    XMLUnknown* NewUnknown( const char* text );

    /**
    	Delete a node associated with this document.
    	It will be unlinked from the DOM.
    */
    void DeleteNode( XMLNode* node );

    void ClearError() {
        SetError(XML_SUCCESS, 0, 0);
    }

    /// Return true if there was an error parsing the document.
    bool Error() const {
        return _errorID != XML_SUCCESS;
    }
    /// Return the errorID.
    XMLError  ErrorID() const {
        return _errorID;
    }
	const char* ErrorName() const;
    static const char* ErrorIDToName(XMLError errorID);

    /** Returns a "long form" error description. A hopefully helpful
        diagnostic with location, line number, and/or additional info.
    */
	const char* ErrorStr() const;

    /// A (trivial) utility function that prints the ErrorStr() to stdout.
    void PrintError() const;

    /// Return the line where the error occurred, or zero if unknown.
    int ErrorLineNum() const
    {
        return _errorLineNum;
    }

    /// Clear the document, resetting it to the initial state.
    void Clear();

	/**
		Copies this document to a target document.
		The target will be completely cleared before the copy.
		If you want to copy a sub-tree, see XMLNode::DeepClone().

		NOTE: that the 'target' must be non-null.
	*/
	void DeepCopy(XMLDocument* target) const;

	// internal
    char* Identify( char* p, XMLNode** node );

	// internal
	void MarkInUse(const XMLNode* const);

    virtual XMLNode* ShallowClone( XMLDocument* /*document*/ ) const	{
        return 0;
    }
    virtual bool ShallowEqual( const XMLNode* /*compare*/ ) const	{
        return false;
    }

private:
    XMLDocument( const XMLDocument& );	// not supported
    void operator=( const XMLDocument& );	// not supported

    bool			_writeBOM;
    bool			_processEntities;
    XMLError		_errorID;
    Whitespace		_whitespaceMode;
    mutable StrPair	_errorStr;
    int             _errorLineNum;
    char*			_charBuffer;
    int				_parseCurLineNum;
	int				_parsingDepth;
	// Memory tracking does add some overhead.
	// However, the code assumes that you don't
	// have a bunch of unlinked nodes around.
	// Therefore it takes less memory to track
	// in the document vs. a linked list in the XMLNode,
	// and the performance is the same.
	DynArray<XMLNode*, 10> _unlinked;

    MemPoolT< sizeof(XMLElement) >	 _elementPool;
    MemPoolT< sizeof(XMLAttribute) > _attributePool;
    MemPoolT< sizeof(XMLText) >		 _textPool;
    MemPoolT< sizeof(XMLComment) >	 _commentPool;

	static const char* _errorNames[XML_ERROR_COUNT];

    void Parse();

    void SetError( XMLError error, int lineNum, const char* format, ... );

	// Something of an obvious security hole, once it was discovered.
	// Either an ill-formed XML or an excessively deep one can overflow
	// the stack. Track stack depth, and error out if needed.
	class DepthTracker {
	public:
		explicit DepthTracker(XMLDocument * document) {
			this->_document = document;
			document->PushDepth();
		}
		~DepthTracker() {
			_document->PopDepth();
		}
	private:
		XMLDocument * _document;
	};
	void PushDepth();
	void PopDepth();

    template<class NodeType, int PoolElementSize>
    NodeType* CreateUnlinkedNode( MemPoolT<PoolElementSize>& pool );
};

template<class NodeType, int PoolElementSize>
inline NodeType* XMLDocument::CreateUnlinkedNode( MemPoolT<PoolElementSize>& pool )
{
    TIXMLASSERT( sizeof( NodeType ) == PoolElementSize );
    TIXMLASSERT( sizeof( NodeType ) == pool.ItemSize() );
    NodeType* returnNode = new (pool.Alloc()) NodeType( this );
    TIXMLASSERT( returnNode );
    returnNode->_memPool = &pool;

	_unlinked.Push(returnNode);
    return returnNode;
}

/**
	A XMLHandle is a class that wraps a node pointer with null checks; this is
	an incredibly useful thing. Note that XMLHandle is not part of the TinyXML-2
	DOM structure. It is a separate utility class.

	Take an example:
	@verbatim
	<Document>
		<Element attributeA = "valueA">
			<Child attributeB = "value1" />
			<Child attributeB = "value2" />
		</Element>
	</Document>
	@endverbatim

	Assuming you want the value of "attributeB" in the 2nd "Child" element, it's very
	easy to write a *lot* of code that looks like:

	@verbatim
	XMLElement* root = document.FirstChildElement( "Document" );
	if ( root )
	{
		XMLElement* element = root->FirstChildElement( "Element" );
		if ( element )
		{
			XMLElement* child = element->FirstChildElement( "Child" );
			if ( child )
			{
				XMLElement* child2 = child->NextSiblingElement( "Child" );
				if ( child2 )
				{
					// Finally do something useful.
	@endverbatim

	And that doesn't even cover "else" cases. XMLHandle addresses the verbosity
	of such code. A XMLHandle checks for null pointers so it is perfectly safe
	and correct to use:

	@verbatim
	XMLHandle docHandle( &document );
	XMLElement* child2 = docHandle.FirstChildElement( "Document" ).FirstChildElement( "Element" ).FirstChildElement().NextSiblingElement();
	if ( child2 )
	{
		// do something useful
	@endverbatim

	Which is MUCH more concise and useful.

	It is also safe to copy handles - internally they are nothing more than node pointers.
	@verbatim
	XMLHandle handleCopy = handle;
	@endverbatim

	See also XMLConstHandle, which is the same as XMLHandle, but operates on const objects.
*/
class TINYXML2_LIB XMLHandle
{
public:
    /// Create a handle from any node (at any depth of the tree.) This can be a null pointer.
    explicit XMLHandle( XMLNode* node ) : _node( node ) {
    }
    /// Create a handle from a node.
    explicit XMLHandle( XMLNode& node ) : _node( &node ) {
    }
    /// Copy constructor
    XMLHandle( const XMLHandle& ref ) : _node( ref._node ) {
    }
    /// Assignment
    XMLHandle& operator=( const XMLHandle& ref )							{
        _node = ref._node;
        return *this;
    }

    /// Get the first child of this handle.
    XMLHandle FirstChild() 													{
        return XMLHandle( _node ? _node->FirstChild() : 0 );
    }
    /// Get the first child element of this handle.
    XMLHandle FirstChildElement( const char* name = 0 )						{
        return XMLHandle( _node ? _node->FirstChildElement( name ) : 0 );
    }
    /// Get the last child of this handle.
    XMLHandle LastChild()													{
        return XMLHandle( _node ? _node->LastChild() : 0 );
    }
    /// Get the last child element of this handle.
    XMLHandle LastChildElement( const char* name = 0 )						{
        return XMLHandle( _node ? _node->LastChildElement( name ) : 0 );
    }
    /// Get the previous sibling of this handle.
    XMLHandle PreviousSibling()												{
        return XMLHandle( _node ? _node->PreviousSibling() : 0 );
    }
    /// Get the previous sibling element of this handle.
    XMLHandle PreviousSiblingElement( const char* name = 0 )				{
        return XMLHandle( _node ? _node->PreviousSiblingElement( name ) : 0 );
    }
    /// Get the next sibling of this handle.
    XMLHandle NextSibling()													{
        return XMLHandle( _node ? _node->NextSibling() : 0 );
    }
    /// Get the next sibling element of this handle.
    XMLHandle NextSiblingElement( const char* name = 0 )					{
        return XMLHandle( _node ? _node->NextSiblingElement( name ) : 0 );
    }

    /// Safe cast to XMLNode. This can return null.
    XMLNode* ToNode()							{
        return _node;
    }
    /// Safe cast to XMLElement. This can return null.
    XMLElement* ToElement() 					{
        return ( _node ? _node->ToElement() : 0 );
    }
    /// Safe cast to XMLText. This can return null.
    XMLText* ToText() 							{
        return ( _node ? _node->ToText() : 0 );
    }
    /// Safe cast to XMLUnknown. This can return null.
    XMLUnknown* ToUnknown() 					{
        return ( _node ? _node->ToUnknown() : 0 );
    }
    /// Safe cast to XMLDeclaration. This can return null.
    XMLDeclaration* ToDeclaration() 			{
        return ( _node ? _node->ToDeclaration() : 0 );
    }

private:
    XMLNode* _node;
};


/**
	A variant of the XMLHandle class for working with const XMLNodes and Documents. It is the
	same in all regards, except for the 'const' qualifiers. See XMLHandle for API.
*/
class TINYXML2_LIB XMLConstHandle
{
public:
    explicit XMLConstHandle( const XMLNode* node ) : _node( node ) {
    }
    explicit XMLConstHandle( const XMLNode& node ) : _node( &node ) {
    }
    XMLConstHandle( const XMLConstHandle& ref ) : _node( ref._node ) {
    }

    XMLConstHandle& operator=( const XMLConstHandle& ref )							{
        _node = ref._node;
        return *this;
    }

    const XMLConstHandle FirstChild() const											{
        return XMLConstHandle( _node ? _node->FirstChild() : 0 );
    }
    const XMLConstHandle FirstChildElement( const char* name = 0 ) const				{
        return XMLConstHandle( _node ? _node->FirstChildElement( name ) : 0 );
    }
    const XMLConstHandle LastChild()	const										{
        return XMLConstHandle( _node ? _node->LastChild() : 0 );
    }
    const XMLConstHandle LastChildElement( const char* name = 0 ) const				{
        return XMLConstHandle( _node ? _node->LastChildElement( name ) : 0 );
    }
    const XMLConstHandle PreviousSibling() const									{
        return XMLConstHandle( _node ? _node->PreviousSibling() : 0 );
    }
    const XMLConstHandle PreviousSiblingElement( const char* name = 0 ) const		{
        return XMLConstHandle( _node ? _node->PreviousSiblingElement( name ) : 0 );
    }
    const XMLConstHandle NextSibling() const										{
        return XMLConstHandle( _node ? _node->NextSibling() : 0 );
    }
    const XMLConstHandle NextSiblingElement( const char* name = 0 ) const			{
        return XMLConstHandle( _node ? _node->NextSiblingElement( name ) : 0 );
    }


    const XMLNode* ToNode() const				{
        return _node;
    }
    const XMLElement* ToElement() const			{
        return ( _node ? _node->ToElement() : 0 );
    }
    const XMLText* ToText() const				{
        return ( _node ? _node->ToText() : 0 );
    }
    const XMLUnknown* ToUnknown() const			{
        return ( _node ? _node->ToUnknown() : 0 );
    }
    const XMLDeclaration* ToDeclaration() const	{
        return ( _node ? _node->ToDeclaration() : 0 );
    }

private:
    const XMLNode* _node;
};


/**
	Printing functionality. The XMLPrinter gives you more
	options than the XMLDocument::Print() method.

	It can:
	-# Print to memory.
	-# Print to a file you provide.
	-# Print XML without a XMLDocument.

	Print to Memory

	@verbatim
	XMLPrinter printer;
	doc.Print( &printer );
	SomeFunction( printer.CStr() );
	@endverbatim

	Print to a File

	You provide the file pointer.
	@verbatim
	XMLPrinter printer( fp );
	doc.Print( &printer );
	@endverbatim

	Print without a XMLDocument

	When loading, an XML parser is very useful. However, sometimes
	when saving, it just gets in the way. The code is often set up
	for streaming, and constructing the DOM is just overhead.

	The Printer supports the streaming case. The following code
	prints out a trivially simple XML file without ever creating
	an XML document.

	@verbatim
	XMLPrinter printer( fp );
	printer.OpenElement( "foo" );
	printer.PushAttribute( "foo", "bar" );
	printer.CloseElement();
	@endverbatim
*/
class TINYXML2_LIB XMLPrinter : public XMLVisitor
{
public:
    /** Construct the printer. If the FILE* is specified,
    	this will print to the FILE. Else it will print
    	to memory, and the result is available in CStr().
    	If 'compact' is set to true, then output is created
    	with only required whitespace and newlines.
    */
    XMLPrinter( FILE* file=0, bool compact = false, int depth = 0 );
    virtual ~XMLPrinter()	{}

    /** If streaming, write the BOM and declaration. */
    void PushHeader( bool writeBOM, bool writeDeclaration );
    /** If streaming, start writing an element.
        The element must be closed with CloseElement()
    */
    void OpenElement( const char* name, bool compactMode=false );
    /// If streaming, add an attribute to an open element.
    void PushAttribute( const char* name, const char* value );
    void PushAttribute( const char* name, int value );
    void PushAttribute( const char* name, unsigned value );
	void PushAttribute( const char* name, int64_t value );
	void PushAttribute( const char* name, uint64_t value );
	void PushAttribute( const char* name, bool value );
    void PushAttribute( const char* name, double value );
    /// If streaming, close the Element.
    virtual void CloseElement( bool compactMode=false );

    /// Add a text node.
    void PushText( const char* text, bool cdata=false );
    /// Add a text node from an integer.
    void PushText( int value );
    /// Add a text node from an unsigned.
    void PushText( unsigned value );
	/// Add a text node from a signed 64bit integer.
	void PushText( int64_t value );
	/// Add a text node from an unsigned 64bit integer.
	void PushText( uint64_t value );
	/// Add a text node from a bool.
    void PushText( bool value );
    /// Add a text node from a float.
    void PushText( float value );
    /// Add a text node from a double.
    void PushText( double value );

    /// Add a comment
    void PushComment( const char* comment );

    void PushDeclaration( const char* value );
    void PushUnknown( const char* value );

    virtual bool VisitEnter( const XMLDocument& /*doc*/ );
    virtual bool VisitExit( const XMLDocument& /*doc*/ )			{
        return true;
    }

    virtual bool VisitEnter( const XMLElement& element, const XMLAttribute* attribute );
    virtual bool VisitExit( const XMLElement& element );

    virtual bool Visit( const XMLText& text );
    virtual bool Visit( const XMLComment& comment );
    virtual bool Visit( const XMLDeclaration& declaration );
    virtual bool Visit( const XMLUnknown& unknown );

    /**
    	If in print to memory mode, return a pointer to
    	the XML file in memory.
    */
    const char* CStr() const {
        return _buffer.Mem();
    }
    /**
    	If in print to memory mode, return the size
    	of the XML file in memory. (Note the size returned
    	includes the terminating null.)
    */
    int CStrSize() const {
        return _buffer.Size();
    }
    /**
    	If in print to memory mode, reset the buffer to the
    	beginning.
    */
    void ClearBuffer( bool resetToFirstElement = true ) {
        _buffer.Clear();
        _buffer.Push(0);
		_firstElement = resetToFirstElement;
    }

protected:
	virtual bool CompactMode( const XMLElement& )	{ return _compactMode; }

	/** Prints out the space before an element. You may override to change
	    the space and tabs used. A PrintSpace() override should call Print().
	*/
    virtual void PrintSpace( int depth );
    void Print( const char* format, ... );
    void Write( const char* data, size_t size );
    inline void Write( const char* data )           { Write( data, strlen( data ) ); }
    void Putc( char ch );

    void SealElementIfJustOpened();
    bool _elementJustOpened;
    DynArray< const char*, 10 > _stack;

private:
    void PrintString( const char*, bool restrictedEntitySet );	// prints out, after detecting entities.

    bool _firstElement;
    FILE* _fp;
    int _depth;
    int _textDepth;
    bool _processEntities;
	bool _compactMode;

    enum {
        ENTITY_RANGE = 64,
        BUF_SIZE = 200
    };
    bool _entityFlag[ENTITY_RANGE];
    bool _restrictedEntityFlag[ENTITY_RANGE];

    DynArray< char, 20 > _buffer;

    // Prohibit cloning, intentionally not implemented
    XMLPrinter( const XMLPrinter& );
    XMLPrinter& operator=( const XMLPrinter& );
};


}	// tinyxml2

#if defined(_MSC_VER)
#   pragma warning(pop)
#endif

#endif // TINYXML2_INCLUDED

```

`Lumina/Lumina/ui/fgui_/dependencies/helpers.hpp`:

```hpp
//
// FGUI - feature rich graphical user interface
//

#ifndef FGUI_HELPERS_HH
#define FGUI_HELPERS_HH

#ifdef _WIN32
#define WIN32_LEAN_AND_MEAN
#define NOMINMAX
// These keys defaults to virtual key-codes from WindowsAPI (GetAsyncKeyState)
#define MOUSE_1 1
#define KEY_ESCAPE 27
#define KEY_ENTER 13
#define KEY_BACKSPACE 8
#define KEY_LSHIFT 160
#define KEY_RSHIFT 161
#define KEY_DELETE 46
#define KEY_LEFT 37
#define KEY_RIGHT 39
#define KEY_PAGEUP 33
#define KEY_PAGEDOWN 34
#else
// These keys defaults to virtual key-codes from Source Engine (IInputSystem) 
#define MOUSE_1 107
#define KEY_ESCAPE 70
#define KEY_ENTER 64
#define KEY_BACKSPACE 66
#define KEY_LSHIFT 79
#define KEY_RSHIFT 80
#define KEY_DELETE 73
#define KEY_LEFT 89
#define KEY_RIGHT 91
#define KEY_PAGEUP 76
#define KEY_PAGEDOWN 77
#endif

#ifdef FGUI_USE_D3D9
#include <d3d9.h>
#include <d3dx9.h>

#pragma comment(lib, "d3d9.lib")
#pragma comment(lib, "d3dx9.lib")

namespace FGUI
{
	using FONT = ID3DXFont*;
}
#elif defined(FGUI_USE_D3D10)
#include <d3d10.h>
#include <d3dx10.h>

#pragma comment(lib, "d3d10.lib")
#pragma comment(lib, "d3dx10.lib")

namespace FGUI
{
	using FONT = ID3DX10Font*;
}
#elif defined(FGUI_USE_OPENGL)

// TODO: OpenGL support

#else
namespace FGUI
{
	using FONT = unsigned long;
}
#endif

#endif // FGUI_HELPERS_HH
```

`Lumina/Lumina/ui/fgui_/input.hpp`:

```hpp
#pragma once

/*
#include "render.hpp"
#include "../../common/input.h"
#include "../../sdk/interfaces.h"
*/

namespace FGUI_INPUT
{
	/*
	inline FGUI::POINT GetCursorPos()
	{
		FGUI::POINT point = FGUI::POINT();

		point.m_iX = input::get_mouse().m_pos.x;
		point.m_iY = input::get_mouse().m_pos.y;

		return point;
	}

	inline void PullInput()
	{
		//input::update_mouse();
	}

	inline bool GetKeyState(int key)
	{
		return input::get_key_info(key).m_state == input::e_state::PRESSED; //current_pressed_keys.at(key_code);
	}

	inline bool GetKeyPress(int key)
	{
		return input::get_key_info(key).m_state == input::e_state::PRESSED;
	}

	inline bool GetKeyRelease(int key)
	{
		return input::get_key_info(key).m_state == input::e_state::IDLE;
	}

	inline FGUI::POINT GetCursorPosDelta()
	{
		static Vector2D* oldVector;

		if(!oldVector)
			oldVector = new Vector2D(input::get_mouse().m_pos);

		FGUI::POINT point = FGUI::POINT();

		point.m_iX = input::get_mouse().m_pos.x - oldVector->x;
		point.m_iY = input::get_mouse().m_pos.y - oldVector->y;

		return point;
	}

	inline int GetCursorWheelDelta()
	{
		static int* oldScroll;

		if (!oldScroll)
			oldScroll = new int(input::get_mouse().m_scroll);

		return input::get_mouse().m_scroll - *oldScroll;
	}

	inline bool IsCursorInArea(FGUI::AREA area)
	{
		// m_iLeft = x, m_iTop = y, m_iRight = w, m_iBottom = h
		Vector2D vector1 = Vector2D(area.m_iLeft, area.m_iTop);
		Vector2D vector2 = Vector2D(area.m_iRight, area.m_iBottom);

		return input::mouse_in_bounds(vector1, vector2);
	}*/

	/*
	inline std::array<bool, 256> m_prgpCurrentPressedKeys, m_prgpOldPressedKeys;
	inline FGUI::POINT m_ptCursorPosition, m_ptCursorPositionDelta;

	inline void PullInput()
	{
		static FGUI::POINT ptLastKnownPosition = { 0, 0 };

		std::copy(m_prgpCurrentPressedKeys.begin(), m_prgpCurrentPressedKeys.end(), m_prgpOldPressedKeys.begin());

		for (std::size_t i = 0; i < 256; i++)
		{
			m_prgpCurrentPressedKeys.at(i) = GetAsyncKeyState(i);
		}

		// Get current cursor position
		GetCursorPos(reinterpret_cast<LPPOINT>(&m_ptCursorPosition));

		// Calculate the cursor position delta
		m_ptCursorPositionDelta = { (m_ptCursorPosition.m_iX - ptLastKnownPosition.m_iX), (m_ptCursorPosition.m_iY - ptLastKnownPosition.m_iY) };

		// Get last known position of the cursor
		ptLastKnownPosition = m_ptCursorPosition;
	}

	inline bool GetKeyState(int _key_code)
	{
		return m_prgpCurrentPressedKeys.at(_key_code);
	}

	inline bool GetKeyRelease(int _key_code)
	{
		return (!m_prgpCurrentPressedKeys.at(_key_code) && m_prgpOldPressedKeys.at(_key_code));
	}

	inline bool GetKeyPress(int _key_code)
	{
		return (m_prgpCurrentPressedKeys.at(_key_code) && !m_prgpOldPressedKeys.at(_key_code));
	}

	inline FGUI::POINT GetCursorPos()
	{
		return m_ptCursorPosition;
	}

	inline FGUI::POINT GetCursorPosDelta()
	{
		return m_ptCursorPositionDelta;
	}

	inline int GetCursorWheelDelta()
	{
		return 0;
	}

	inline bool IsCursorInArea(FGUI::AREA area)
	{
		return (GetCursorPos().m_iX > area.m_iLeft && GetCursorPos().m_iY > area.m_iTop &&
			GetCursorPos().m_iX < area.m_iLeft + area.m_iRight && GetCursorPos().m_iY < area.m_iTop + area.m_iBottom);
	}


	inline void init()
	{
		FGUI::INPUT.GetCursorPos = FGUI_INPUT::GetCursorPos;
		FGUI::INPUT.GetKeyPress = FGUI_INPUT::GetKeyPress;
		FGUI::INPUT.IsCursorInArea = FGUI_INPUT::IsCursorInArea;
		FGUI::INPUT.GetKeyState = FGUI_INPUT::GetKeyState;
		FGUI::INPUT.GetKeyRelease = FGUI_INPUT::GetKeyRelease;
		FGUI::INPUT.GetCursorWheelDelta = FGUI_INPUT::GetCursorWheelDelta;
		FGUI::INPUT.GetCursorPosDelta = FGUI_INPUT::GetCursorPosDelta;
		FGUI::INPUT.PullInput = FGUI_INPUT::PullInput;
	}

	fgui::state get_key_state(const fgui::key& key) {
		return input::get_key_info(key).m_state == input::e_state::PRESSED;// interfaces::surfac->is_button_down(key);
	}

	fgui::delta get_scroll_delta() {
		return 0; // core::ifaces::get_ifaces.input_system->get_analog_delta(enums::analog_code::analog_code_mouse_wheel);
	}

	fgui::point get_mouse_position() {
		static fgui::point point = { 0, 0 };

		interfaces::surface->SurfaceGetCursorPos(point.x, point.y);

		return point;
	}

	void setup_input_funcs() {
		fgui::input.get_key_state = get_key_state;
		fgui::input.get_scroll_delta = get_scroll_delta;
		fgui::input.get_mouse_position = get_mouse_position;
	}*/
}
```

`Lumina/Lumina/ui/fgui_/render.hpp`:

```hpp
#pragma once

#define FGUI_IMPLEMENTATION

#include "../../sdk/interfaces.h"
#include "../render.h"

#include "../zgui/dist/zgui.hh"

//#include "../fgui_old/FGUI.hh"

void line(int x, int y, int x2, int y2, zgui::color c) noexcept
{
	interfaces::surface->DrawSetColor(c.r, c.g, c.b, c.a);
	interfaces::surface->DrawLine(x, y, x+x2, y+y2);
}

void rect(int x, int y, int x2, int y2, zgui::color c) noexcept
{
	render::drawOutlinedRectangle(x, y, x2, y2, Color(c.r, c.g, c.b, c.a));
}

void filled_rect(int x, int y, int x2, int y2, zgui::color c) noexcept
{
	render::drawRectangle(x, y, x2, y2, Color(c.r, c.g, c.b, c.a));
}

void text(int x, int y, zgui::color color, int font, bool center, const char* text) noexcept
{
	render::drawText(x, y, font, text, false, Color(color.r, color.g, color.b, color.a));
}

void get_text_size(unsigned long font, const char* text, int& width, int& height) noexcept
{
	interfaces::surface->GetTextSize(font, (wchar_t*)text, width, height);
}

float get_frametime() noexcept
{
	return interfaces::globals->frametime;
}

void zguiInit() {

	zgui::functions.draw_line = line;
	zgui::functions.draw_rect = rect;
	zgui::functions.draw_filled_rect = filled_rect;
	zgui::functions.draw_text = text;
	zgui::functions.get_text_size = get_text_size;
	zgui::functions.get_frametime = get_frametime;
}

/*
void create_font(fgui::font& font, const std::string_view family, const std::int32_t size, const std::int32_t flags, const bool bold) {

	font = interfaces::surface->CreateFont();

	interfaces::surface->SetFontGlyphSet(font, family.data(), size, bold ? 800 : 0, 0, 0, flags, 0, 0);
}

void get_screen_size(std::int32_t& x, std::int32_t& y) {
	interfaces::surface->GetScreenSize(x, y);
}

fgui::dimension get_text_size(const fgui::font& font, const std::string_view text) {
	fgui::dimension dimension = { 0, 0 };

	interfaces::surface->GetTextSize(font, std::wstring(text.begin(), text.end()).data(), dimension.width, dimension.height);

	return dimension;
}

void rectangle(const std::int32_t x, const std::int32_t y, const std::int32_t w, const std::int32_t h, const fgui::color color) {
	interfaces::surface->DrawSetColor(color.m_red, color.m_green, color.m_blue, color.m_alpha);
	interfaces::surface->DrawFilledRect(x, y, x + w, y + h);
}

void outlined_rectangle(const std::int32_t x, const std::int32_t y, const std::int32_t w, const std::int32_t h, const fgui::color color) {
	interfaces::surface->DrawSetColor(color.m_red, color.m_green, color.m_blue, color.m_alpha);
	interfaces::surface->DrawOutlinedRect(x, y, x + w, y + h);
}

void line(const std::int32_t x, const std::int32_t y, const std::int32_t w, const std::int32_t h, const fgui::color color) {
	interfaces::surface->DrawSetColor(color.m_red, color.m_green, color.m_blue, color.m_alpha);
	interfaces::surface->DrawLine(x, y, w, h);
}

void polygon(const std::int32_t count, fgui::vertex* vertex, const fgui::color color) {

	

	static auto texture = interfaces::surface->CreateNewTextureID(true);

	std::uint8_t buffer[4] = { 255, 255, 255, 255 };

	Vertex_t* vec = new Vertex_t(,);

	interfaces::surface->DrawSetTextureRGBA(texture, buffer, 1, 1);
	interfaces::surface->DrawSetColor(color.m_red, color.m_green, color.m_blue, color.m_alpha);
	interfaces::surface->DrawSetTexture(texture);
	interfaces::surface->DrawTexturedPolygon(count, vec, true);*
}

void text(const std::int32_t x, const std::int32_t y, const fgui::color color, const unsigned long font, const std::string_view text) {
	const auto converted_text = std::wstring(text.begin(), text.end());

	interfaces::surface->DrawSetTextColor(color.m_red, color.m_green, color.m_blue, color.m_alpha);
	interfaces::surface->DrawSetTextFont(font);
	interfaces::surface->DrawSetTextPos(x, y);
	interfaces::surface->DrawPrintText(converted_text.c_str(), std::wcslen(converted_text.c_str()));
}

void circle(const std::int32_t x, const std::int32_t y, const std::int32_t radius, const std::int32_t segments, const fgui::color color) {
	interfaces::surface->DrawSetColor(color.m_red, color.m_green, color.m_blue, color.m_alpha);
	interfaces::surface->DrawOutlinedCircle(x, y, radius, segments);
}

void gradient(const std::int32_t x, const std::int32_t y, const std::int32_t w, const std::int32_t h, const std::int32_t first_alpha, const std::int32_t second_alpha, const fgui::color color, const bool horizontal) {
	interfaces::surface->DrawSetColor(color.m_red, color.m_green, color.m_blue, color.m_alpha);
	interfaces::surface->DrawFilledRectFade(x, y, x + w, y + h, first_alpha, second_alpha, horizontal);
}

void colored_gradient(const std::int32_t x, const std::int32_t y, const std::int32_t w, const std::int32_t h, const fgui::color first_color, const fgui::color second_color, const bool is_horizontal) {
	if (is_horizontal) {
		rectangle(x, y, w, h, first_color);

		for (auto i = 0; i < w; i++)
			rectangle(x + i, y, 1, h, fgui::color(second_color.m_red, second_color.m_red, second_color.m_blue, i / w * 255));
	}
	else {
		rectangle(x, y, w, h, first_color);

		for (auto i = 0; i < w; i++)
			rectangle(x, y + i, w, 1, fgui::color(second_color.m_red, second_color.m_red, second_color.m_blue, i / w * 255));
	}
}

void get_alpha_value(const std::int32_t x, const std::int32_t y, const std::int32_t w, const std::int32_t h) {
	for (auto i = 0; i < h / 5; i++) {
		for (auto t = 0; t < w / 5; t++) {
			const auto pixel = static_cast<std::int32_t>(std::roundf(t));
			const auto line = static_cast<std::int32_t>(std::roundf(i));
			const auto is_brick_light = line % 2 ? pixel % 2 : pixel % 2 == 0;
			const auto new_color = is_brick_light ? fgui::color(60, 60, 60) : fgui::color(40, 40, 40);

			rectangle(x + t * 5, y + i * 5, 5, 5, new_color);
		}
	}
}

void clip_rectangle(const std::int32_t x, const std::int32_t y, const std::int32_t width, const std::int32_t height) {
	
	const fgui::rect viewport = { x, y, (x + width), (y + height) };

	//interfaces::surface->set_clip_rectangle(viewport.left, viewport.top, viewport.right, viewport.bottom);
}

void setup_render_funcs() {
	fgui::render.create_font = create_font;
	fgui::render.get_screen_size = get_screen_size;
	fgui::render.get_text_size = get_text_size;
	fgui::render.rect = rectangle;
	fgui::render.gradient = gradient;
	fgui::render.colored_gradient = colored_gradient;
	fgui::render.outline = outlined_rectangle;
	fgui::render.line = line;
	fgui::render.polygon = polygon;
	fgui::render.circle = circle;
	fgui::render.text = text;
	fgui::render.alpha = get_alpha_value;
	fgui::render.clip_rect = clip_rectangle;

	//fonts.push_back(CONV_ENUM_TYPE(std::int32_t, enums::font::font_watermark));
	//fonts.push_back(CONV_ENUM_TYPE(std::int32_t, enums::font::font_visuals));

	//fgui::render.create_font(, "Tahoma", 12, fgui::external::font_flags::SHADOW, false);
	//fgui::render.create_font(, "Tahoma", 16, fgui::external::font_flags::SHADOW, false);
}*/

/*
#include "FGUI.hpp"



// NOTE: make sure to use your surface interface pointer
// replace "interfaces::surface" with your pointer


namespace FGUI_SURFACE
{
	inline void CreateFont(FGUI::FONT& _font, std::string _family, int _size, int _flags, bool _bold)
	{
		_font = interfaces::surface->CreateFont();
		interfaces::surface->SetFontGlyphSet(_font, _family.c_str(), _size, _bold ? 800 : 0, 0, 0, _flags);
	}

	inline FGUI::DIMENSION GetScreenSize()
	{
		static FGUI::DIMENSION dmTemporarySize = { 0, 0 };

		interfaces::surface->GetScreenSize(dmTemporarySize.m_iWidth, dmTemporarySize.m_iHeight);

		return dmTemporarySize;
	}

	inline FGUI::DIMENSION GetTextSize(FGUI::FONT _font, std::string _text)
	{
		static FGUI::DIMENSION dmTemporarySize = { 0, 0 };

		interfaces::surface->GetTextSize(_font, std::wstring(_text.begin(), _text.end()).c_str(), dmTemporarySize.m_iWidth, dmTemporarySize.m_iHeight);

		return dmTemporarySize;
	}

	inline void Rectangle(int _x, int _y, int _width, int _height, FGUI::COLOR _color)
	{
		interfaces::surface->DrawSetColor(_color.m_ucRed, _color.m_ucGreen, _color.m_ucBlue, _color.m_ucAlpha);
		interfaces::surface->DrawFilledRect(_x, _y, _x + _width, _y + _height);
	}

	inline void Outline(int _x, int _y, int _width, int _height, FGUI::COLOR _color)
	{
		interfaces::surface->DrawSetColor(_color.m_ucRed, _color.m_ucGreen, _color.m_ucBlue, _color.m_ucAlpha);
		interfaces::surface->DrawOutlinedRect(_x, _y, _x + _width, _y + _height);
	}

	inline void Gradient(int _x, int _y, int _width, int _height, FGUI::COLOR _color1, FGUI::COLOR _color2, bool _horizontal)
	{
		interfaces::surface->DrawSetColor(_color1.m_ucRed, _color1.m_ucGreen, _color1.m_ucBlue, _color1.m_ucAlpha);
		interfaces::surface->DrawFilledRectFade(_x, _y, _x + _width, _y + _height, 255, 255, _horizontal);

		interfaces::surface->DrawSetColor(_color2.m_ucRed, _color2.m_ucGreen, _color2.m_ucBlue, _color2.m_ucAlpha);
		interfaces::surface->DrawFilledRectFade(_x, _y, _x + _width, _y + _height, 0, 255, _horizontal);
	}

	inline void Line(int _from_x, int _from_y, int _to_x, int _to_y, FGUI::COLOR _color)
	{
		interfaces::surface->DrawSetColor(_color.m_ucRed, _color.m_ucGreen, _color.m_ucBlue, _color.m_ucAlpha);
		interfaces::surface->DrawLine(_from_x, _from_y, _to_x, _to_y);
	}

	inline void Text(int _x, int _y, FGUI::FONT _font, FGUI::COLOR _color, std::string _text)
	{
		render::drawText(_x, _y, _font, _text, false, Color(_color.m_ucRed, _color.m_ucGreen, _color.m_ucBlue, _color.m_ucAlpha));
	}

	// NOTE: call this function only once (preferably when you initialize your application)
	inline void init()
	{
		FGUI::RENDER.CreateFont = FGUI_SURFACE::CreateFont;
		FGUI::RENDER.GetScreenSize = FGUI_SURFACE::GetScreenSize;
		FGUI::RENDER.GetTextSize = FGUI_SURFACE::GetTextSize;
		FGUI::RENDER.Rectangle = FGUI_SURFACE::Rectangle;
		FGUI::RENDER.Outline = FGUI_SURFACE::Outline;
		FGUI::RENDER.Line = FGUI_SURFACE::Line;
		FGUI::RENDER.Text = FGUI_SURFACE::Text;
		FGUI::RENDER.Gradient = FGUI_SURFACE::Gradient;
	}
}
*/
```

`Lumina/Lumina/ui/fgui_/widgets/button.cpp`:

```cpp
//
// FGUI - feature rich graphical user interface
//

// library includes
#include "button.hpp"

namespace FGUI
{

CButton::CButton()
{
  m_strTitle = "Button";
  m_dmSize = {100, 20};
  m_ulFont = 0;
  m_fnctCallback = nullptr;
  m_nType = static_cast<int>(WIDGET_TYPE::BUTTON);
  m_nFlags = static_cast<int>(WIDGET_FLAG::DRAWABLE) | static_cast<int>(WIDGET_FLAG::CLICKABLE);
}

void CButton::AddCallback(std::function<void()> callback)
{
  m_fnctCallback = callback;
}

void CButton::Geometry()
{
  // widget's area
  FGUI::AREA arWidgetRegion = { GetAbsolutePosition().m_iX, GetAbsolutePosition().m_iY, m_dmSize.m_iWidth, m_dmSize.m_iHeight };

  // widget's title text size
  FGUI::DIMENSION dmTitleTextSize = FGUI::RENDER.GetTextSize(m_ulFont, m_strTitle);

  // button body
  if (FGUI::INPUT.IsCursorInArea(arWidgetRegion))
  {
    FGUI::RENDER.Rectangle(arWidgetRegion.m_iLeft, arWidgetRegion.m_iTop, arWidgetRegion.m_iRight, arWidgetRegion.m_iBottom, {50, 50, 50});
  }
  else
  {
    FGUI::RENDER.Rectangle(arWidgetRegion.m_iLeft, arWidgetRegion.m_iTop, arWidgetRegion.m_iRight, arWidgetRegion.m_iBottom, {35, 90, 120});
  }

  // button label  
  FGUI::RENDER.Text(arWidgetRegion.m_iLeft + (arWidgetRegion.m_iRight / 2) - (dmTitleTextSize.m_iWidth / 2),
    arWidgetRegion.m_iTop + (arWidgetRegion.m_iBottom / 2) - (dmTitleTextSize.m_iHeight / 2), m_ulFont, {245, 245, 245}, m_strTitle);
}

void CButton::Update()
{
}

void CButton::Input()
{
  // widget's area
  FGUI::AREA arWidgetRegion = { GetAbsolutePosition().m_iX, GetAbsolutePosition().m_iY, m_dmSize.m_iWidth, m_dmSize.m_iHeight };

  if (FGUI::INPUT.IsCursorInArea(arWidgetRegion))
  {
    if (m_fnctCallback)
    {
      // call function
      m_fnctCallback();
    }
  }
}

} // namespace FGUI
```

`Lumina/Lumina/ui/fgui_/widgets/button.hpp`:

```hpp
//
// FGUI - feature rich graphical user interface
//

#ifndef FGUI_BUTTON_HH
#define FGUI_BUTTON_HH

// includes
#include <functional>

// library includes
#include "widgets.hpp"

namespace FGUI
{

class CButton : public FGUI::CWidgets
{
public:
  CButton();

  // @brief: adds a function callback for the button (it will call the function whenever the user clicks the button)
  // @params: std::function<void()> callback = function instance
  void AddCallback(std::function<void()> callback);

  // @brief: populate widget geometry (draw widget)
  void Geometry() override;

  // @brief: handle update operations on the widget
  void Update() override;

  // @brief: handle input inside the widget
  void Input() override;
private:
 std::function<void()> m_fnctCallback;
};

} // namespace FGUI

#endif // FGUI_BUTTON_HH
```

`Lumina/Lumina/ui/fgui_/widgets/checkbox.cpp`:

```cpp
//
// FGUI - feature rich graphical user interface
//

// library includes
#include "checkbox.hpp"
#include "../../../common/common.h"
#include "../../menu.h"

namespace FGUI
{

CCheckBox::CCheckBox()
{
  m_strTitle = "CheckBox";
  m_dmSize = {16, 16};
  m_ulFont = 0;
  m_bIsChecked = false;
  m_fnctCallback = nullptr;
  m_nType = static_cast<int>(WIDGET_TYPE::CHECKBOX);
  m_nFlags = static_cast<int>(WIDGET_FLAG::DRAWABLE) | static_cast<int>(WIDGET_FLAG::CLICKABLE);
}

void CCheckBox::SetState(bool onoff)
{
  m_bIsChecked = onoff;
}

bool CCheckBox::GetState()
{
  return m_bIsChecked;
}

void CCheckBox::AddCallback(std::function<void()> callback)
{
  m_fnctCallback = callback;
}

void CCheckBox::Geometry()
{
  // widget's area
  FGUI::AREA arWidgetRegion = { GetAbsolutePosition().m_iX, GetAbsolutePosition().m_iY, m_dmSize.m_iWidth, m_dmSize.m_iHeight};

  // checkbox body
  FGUI::RENDER.Outline((arWidgetRegion.m_iLeft - 1), (arWidgetRegion.m_iTop - 1), arWidgetRegion.m_iRight, arWidgetRegion.m_iBottom, {220, 220, 220});
  FGUI::RENDER.Rectangle(arWidgetRegion.m_iLeft, arWidgetRegion.m_iTop, (arWidgetRegion.m_iRight - 2), (arWidgetRegion.m_iBottom - 2), {255, 255, 255});

  if (m_bIsChecked)
  {
    if (FGUI::INPUT.IsCursorInArea(arWidgetRegion))
    {
      FGUI::RENDER.Outline((arWidgetRegion.m_iLeft - 1), (arWidgetRegion.m_iTop - 1), arWidgetRegion.m_iRight, arWidgetRegion.m_iBottom, {180, 25, 25});
    }

    FGUI::RENDER.Rectangle((arWidgetRegion.m_iLeft + 3), (arWidgetRegion.m_iTop + 3), (arWidgetRegion.m_iRight - 8), (arWidgetRegion.m_iBottom - 8), {180, 25, 25});
  }
  else
  {
    if (FGUI::INPUT.IsCursorInArea(arWidgetRegion))
    {
      FGUI::RENDER.Outline((arWidgetRegion.m_iLeft - 1), (arWidgetRegion.m_iTop - 1), arWidgetRegion.m_iRight, arWidgetRegion.m_iBottom, {195, 195, 195});
    }
  }

  // checkbox label
  FGUI::RENDER.Text(arWidgetRegion.m_iLeft + (arWidgetRegion.m_iRight + 5), arWidgetRegion.m_iTop, m_ulFont, menu::textColor.toFGUICOLOR(), m_strTitle);

}

void CCheckBox::Update()
{
  m_dmSize = { 16, 16 }; // this is required to keep the widget from being padded on groupboxes
}

void CCheckBox::Input()
{
  // widget's area
  FGUI::AREA arWidgetRegion = { GetAbsolutePosition().m_iX, GetAbsolutePosition().m_iY, m_dmSize.m_iWidth, m_dmSize.m_iHeight};

  if (FGUI::INPUT.IsCursorInArea(arWidgetRegion))
  {
    m_bIsChecked = !m_bIsChecked;

    //if (m_bIsChecked)
    //{
      if (m_fnctCallback)
      {
        // call function
        m_fnctCallback();
      }
    //}
  }
}

} // namespace FGUI
```

`Lumina/Lumina/ui/fgui_/widgets/checkbox.hpp`:

```hpp
//
// FGUI - feature rich graphical user interface
//

#ifndef FGUI_CHECKBOX_HH
#define FGUI_CHECKBOX_HH

// includes
#include <functional>

// library includes
#include "widgets.hpp"

namespace FGUI
{
class CCheckBox : public FGUI::CWidgets
{
public:
  CCheckBox();

  // @brief: set the checkbox state (toggle on/off)
  // @params: bool onoff = checkbox state
  void SetState(bool onoff);

  // @brief: get the checkbox state (toggled or not)
  bool GetState();

  // @brief: adds a function callback for the checkbox (it will call the function whenever the user check the checkbox)
  // @params: std::function<void()> callback = function instance
  void AddCallback(std::function<void()> callback);

  // @brief: populate widget geometry (draw widget)
  void Geometry() override;

  // @brief: handle update operations on the widget
  void Update() override;

  // @brief: handle input inside the widget
  void Input() override;

private:
  bool m_bIsChecked;
  std::function<void()> m_fnctCallback;
};
} // namespace FGUI

#endif // FGUI_CHECKBOX_HH
```

`Lumina/Lumina/ui/fgui_/widgets/colorlist.cpp`:

```cpp
//
// FGUI - feature rich graphical user interface
//

// library includes
#include "colorlist.hpp"

namespace FGUI
{

SColorInfo_t::SColorInfo_t(std::string identificator, FGUI::COLOR color, bool gradient)
{
  m_strIdentificator = identificator;
  m_bIsSecondColorAdded = false;
  m_bGradient = gradient;
  m_clrFirst = color;
  m_clrSecond = {1, 1, 1};
}

CColorList::CColorList()
{
  m_strTitle = "ColorList";
  m_iEntrySpacing = 20;
  m_iScrollThumbPosition = 0;
  m_uiSelectedEntry = false;
  m_bIsDragging = false;
  m_ulFont = 0;
  m_nType = static_cast<int>(WIDGET_TYPE::COLORLIST);
  m_nFlags = static_cast<int>(WIDGET_FLAG::DRAWABLE) | static_cast<int>(WIDGET_FLAG::CLICKABLE);
}

void CColorList::AddColor(std::string identificator, FGUI::COLOR color, bool gradient)
{
  m_prgpColorInfo.emplace_back(identificator, color, gradient);
}

void CColorList::SetColor(std::size_t index, FGUI::COLOR color, bool gradient)
{
  m_prgpColorInfo[index].m_clrFirst = color;
  m_prgpColorInfo[index].m_bGradient = gradient;
}

FGUI::COLOR CColorList::GetColor(std::size_t index)
{
  if (m_prgpColorInfo[index].m_bGradient)
  {
    static float flFirstTimeFraction = 0.f;

    flFirstTimeFraction = std::fminf(flFirstTimeFraction + 0.0005f, 1.f);

    if (flFirstTimeFraction >= 1.f)
    {
      static float flSecondTimeFraction = 0.f;

      // ghetto way to return back to the first color
      flSecondTimeFraction = std::fminf(flSecondTimeFraction + 0.0005f, 1.f);

      if (flSecondTimeFraction >= 1.f)
      {
        flSecondTimeFraction = 0.f;
        flFirstTimeFraction = 0.f;
      }

      return FGUI::COLOR::Interpolate(m_prgpColorInfo[index].m_clrSecond, m_prgpColorInfo[index].m_clrFirst, flSecondTimeFraction);
    }

    return FGUI::COLOR::Interpolate(m_prgpColorInfo[index].m_clrFirst, m_prgpColorInfo[index].m_clrSecond, flFirstTimeFraction);
  }

  return m_prgpColorInfo[index].m_clrFirst;
}

std::vector<FGUI::COLOR_INFO> CColorList::GetColorInfo()
{
  return m_prgpColorInfo;
}

void CColorList::Geometry()
{
  // color gap
  static constexpr int iColorPickerGap = 250;

  // widget's area
  FGUI::AREA arWidgetRegion = { GetAbsolutePosition().m_iX, GetAbsolutePosition().m_iY, (m_dmSize.m_iWidth - iColorPickerGap), m_dmSize.m_iHeight};

  // scrollbar area
  FGUI::AREA arScrollBarRegion = {(arWidgetRegion.m_iLeft + arWidgetRegion.m_iRight) - 15, (arWidgetRegion.m_iTop + 20), 15, (m_dmSize.m_iHeight - 20)};

  // entries displayed
  int iEntriesDisplayed = 0;

  // calculate the amount of entries (colors) that will be drawn inside the colorlist
  int iCalculatedEntries = ((m_dmSize.m_iHeight - 20) / m_iEntrySpacing);

  // colorlist body
  FGUI::RENDER.Rectangle(arWidgetRegion.m_iLeft, (arWidgetRegion.m_iTop - 5), arWidgetRegion.m_iRight, 1, {220, 220, 220});
  FGUI::RENDER.Rectangle(arWidgetRegion.m_iLeft, (arWidgetRegion.m_iTop + 17), arWidgetRegion.m_iRight, 1, {220, 220, 220});
  FGUI::RENDER.Outline(arWidgetRegion.m_iLeft, (arWidgetRegion.m_iTop + 20) - 1, (arWidgetRegion.m_iRight + 1), (arWidgetRegion.m_iBottom - 20) + 1, {220, 220, 220});
  FGUI::RENDER.Rectangle((arWidgetRegion.m_iLeft + 1), (arWidgetRegion.m_iTop + 20) + 1, arWidgetRegion.m_iRight - 2, (arWidgetRegion.m_iBottom - 20) - 2, {255, 255, 255});

  // colorlist entries
  for (std::size_t i = m_iScrollThumbPosition; (i < m_prgpColorInfo.size()) && (iEntriesDisplayed < iCalculatedEntries); i++)
  {
    // entry area
    FGUI::AREA arEntryRegion = {arWidgetRegion.m_iLeft, arWidgetRegion.m_iTop + (m_iEntrySpacing * iEntriesDisplayed) + 20, (arWidgetRegion.m_iRight - arScrollBarRegion.m_iRight), m_iEntrySpacing};

    // check if the user is hovers or selects something on the colorlist
    if (FGUI::INPUT.IsCursorInArea(arEntryRegion) || m_uiSelectedEntry == i)
    {
      FGUI::RENDER.Rectangle((arEntryRegion.m_iLeft + 1), arEntryRegion.m_iTop, (arWidgetRegion.m_iRight - 2), arEntryRegion.m_iBottom, {235, 235, 255});
    }

    // color button size
    static constexpr FGUI::DIMENSION dmColorButtonSize = {20, 16};

    // color button body
    FGUI::RENDER.Outline((arEntryRegion.m_iLeft + 95), (arEntryRegion.m_iTop + 2), dmColorButtonSize.m_iWidth, (dmColorButtonSize.m_iHeight - 2), {220, 220, 220});
    FGUI::RENDER.Rectangle((arEntryRegion.m_iLeft + 95) + 1, (arEntryRegion.m_iTop + 3), (dmColorButtonSize.m_iWidth - 2), (dmColorButtonSize.m_iHeight - 4), {195, 195, 195});
    FGUI::RENDER.Rectangle((arEntryRegion.m_iLeft + 95) + 1, (arEntryRegion.m_iTop + 3), (dmColorButtonSize.m_iWidth - 2), (dmColorButtonSize.m_iHeight - 4), m_prgpColorInfo[i].m_clrFirst);

    // if the user adds a second color sequence
    if (m_prgpColorInfo[i].m_bIsSecondColorAdded)
    {
      FGUI::RENDER.Outline((arEntryRegion.m_iLeft + 95) + 25, (arEntryRegion.m_iTop + 2), dmColorButtonSize.m_iWidth, (dmColorButtonSize.m_iHeight - 2), {220, 220, 220});
      FGUI::RENDER.Rectangle(((arEntryRegion.m_iLeft + 95) + 25) + 1, (arEntryRegion.m_iTop + 3), (dmColorButtonSize.m_iWidth - 2), (dmColorButtonSize.m_iHeight - 4), {195, 195, 195});
      FGUI::RENDER.Rectangle(((arEntryRegion.m_iLeft + 95) + 25) + 1, (arEntryRegion.m_iTop + 3), (dmColorButtonSize.m_iWidth - 2), (dmColorButtonSize.m_iHeight - 4), m_prgpColorInfo[i].m_clrSecond);
    }

    // color separator
    FGUI::RENDER.Rectangle(arEntryRegion.m_iLeft, (arEntryRegion.m_iTop + arEntryRegion.m_iBottom) - 1, arWidgetRegion.m_iRight, 1, {205, 205, 205});

    // color button label
    FGUI::RENDER.Text((arEntryRegion.m_iLeft + 5), (arEntryRegion.m_iTop + 2), m_ulFont, {35, 35, 35}, m_prgpColorInfo[i].m_strIdentificator);

    iEntriesDisplayed++;
  }

  // color picker size
  static constexpr FGUI::DIMENSION dmColorPickerSize = {150, 150};

  // color picker's area
  FGUI::AREA arColorPickerRegion = {(GetAbsolutePosition().m_iX + (m_dmSize.m_iWidth - iColorPickerGap) + 10), (GetAbsolutePosition().m_iY + 20), dmColorPickerSize.m_iWidth, dmColorPickerSize.m_iHeight};

  // color picker's pixelation (ghetto optimization)
  static constexpr int iPixelation = 3; // TODO: make a function for this

  // color picker body
  FGUI::RENDER.Rectangle(arColorPickerRegion.m_iLeft, arColorPickerRegion.m_iTop, arColorPickerRegion.m_iRight, arColorPickerRegion.m_iBottom, {100, 100, 100});

  for (std::size_t i = 0; i < static_cast<float>(arColorPickerRegion.m_iBottom); i += iPixelation)
  {
    // color hue
    FGUI::COLOR clrHue = FGUI::COLOR::HSBToRGB(i / 150.f, 1.f, 1.f);

    FGUI::RENDER.Rectangle((arColorPickerRegion.m_iLeft + arColorPickerRegion.m_iRight) + 10, (arColorPickerRegion.m_iTop + i), 15, iPixelation, clrHue);

    for (std::size_t j = 0; j < static_cast<float>(arColorPickerRegion.m_iRight); j += iPixelation)
    {
      // color hsb
      FGUI::COLOR clrHSB = FGUI::COLOR::HSBToRGB(FGUI::COLOR::GetHue(m_prgpColorInfo[m_uiSelectedEntry].m_clrFirst), j / static_cast<float>(arColorPickerRegion.m_iRight), i / static_cast<float>(arColorPickerRegion.m_iBottom), m_prgpColorInfo[m_uiSelectedEntry].m_clrFirst.m_ucAlpha);

      FGUI::RENDER.Rectangle((arColorPickerRegion.m_iLeft + j), (arColorPickerRegion.m_iTop + i), iPixelation, iPixelation, clrHSB);
    }
  }

  // color hsb body
  FGUI::RENDER.Outline(arColorPickerRegion.m_iLeft - 1, arColorPickerRegion.m_iTop - 1, arColorPickerRegion.m_iRight + 2, arColorPickerRegion.m_iBottom + 2, {220, 220, 220});

  // hue bar body
  FGUI::RENDER.Outline(((arColorPickerRegion.m_iLeft + arColorPickerRegion.m_iRight) + 10) - 1, arColorPickerRegion.m_iTop - 1, (15 + 2), arColorPickerRegion.m_iBottom + 2, {220, 220, 220});
  FGUI::RENDER.Rectangle(((arColorPickerRegion.m_iLeft + arColorPickerRegion.m_iRight) + 5), arColorPickerRegion.m_iTop + (arColorPickerRegion.m_iBottom * FGUI::COLOR::GetHue(m_prgpColorInfo[m_uiSelectedEntry].m_clrFirst)), 3, 3, {35, 35, 35});

  // r, g, b color text size
  FGUI::DIMENSION dmColorRedTextSize = FGUI::RENDER.GetTextSize(m_ulFont, std::to_string(m_prgpColorInfo[m_uiSelectedEntry].m_clrFirst.m_ucRed));
  FGUI::DIMENSION dmColorGreenTextSize = FGUI::RENDER.GetTextSize(m_ulFont, std::to_string(m_prgpColorInfo[m_uiSelectedEntry].m_clrFirst.m_ucGreen));
  FGUI::DIMENSION dmColorBlueTextSize = FGUI::RENDER.GetTextSize(m_ulFont, std::to_string(m_prgpColorInfo[m_uiSelectedEntry].m_clrFirst.m_ucBlue));

  // color preview body
  FGUI::RENDER.Outline(((arColorPickerRegion.m_iLeft + arColorPickerRegion.m_iRight) + 35) - 1, arColorPickerRegion.m_iTop - 1, (45 + 2), (45 + 2), {220, 220, 220});
  FGUI::RENDER.Rectangle(((arColorPickerRegion.m_iLeft + arColorPickerRegion.m_iRight) + 35), arColorPickerRegion.m_iTop, 45, 45, m_prgpColorInfo[m_uiSelectedEntry].m_clrFirst);

  // color preview label
  FGUI::RENDER.Text((arColorPickerRegion.m_iLeft + arColorPickerRegion.m_iRight) + 35, (arColorPickerRegion.m_iTop - 20) + (arColorPickerRegion.m_iBottom / 2) - (dmColorRedTextSize.m_iHeight / 2) + 10, m_ulFont, {35, 35, 35}, "R: " + std::to_string(m_prgpColorInfo[m_uiSelectedEntry].m_clrFirst.m_ucRed));
  FGUI::RENDER.Text((arColorPickerRegion.m_iLeft + arColorPickerRegion.m_iRight) + 35, (arColorPickerRegion.m_iTop - 20) + (arColorPickerRegion.m_iBottom / 2) - (dmColorGreenTextSize.m_iHeight / 2) + 30, m_ulFont, {35, 35, 35}, "G: " + std::to_string(m_prgpColorInfo[m_uiSelectedEntry].m_clrFirst.m_ucGreen));
  FGUI::RENDER.Text((arColorPickerRegion.m_iLeft + arColorPickerRegion.m_iRight) + 35, (arColorPickerRegion.m_iTop - 20) + (arColorPickerRegion.m_iBottom / 2) - (dmColorBlueTextSize.m_iHeight / 2) + 50, m_ulFont, {35, 35, 35}, "B: " + std::to_string(m_prgpColorInfo[m_uiSelectedEntry].m_clrFirst.m_ucBlue));

  // sequence label
  FGUI::RENDER.Text(arWidgetRegion.m_iLeft, arWidgetRegion.m_iTop, m_ulFont, {35, 35, 35}, "Sequences");

  //
  // plus sequence button
  //

  // plus button area
  FGUI::AREA arPlusButtonRegion = { (GetAbsolutePosition().m_iX + 70), (GetAbsolutePosition().m_iY - 1), 16, 16};

  // plus button title text size
  FGUI::DIMENSION dmPlusButtonTextSize = FGUI::RENDER.GetTextSize(m_ulFont, "+");

  // plus button body
  if (FGUI::INPUT.IsCursorInArea(arPlusButtonRegion))
  {
    FGUI::RENDER.Rectangle(arPlusButtonRegion.m_iLeft, arPlusButtonRegion.m_iTop, arPlusButtonRegion.m_iRight, arPlusButtonRegion.m_iBottom, {50, 50, 50});
  }
  else
  {
    FGUI::RENDER.Rectangle(arPlusButtonRegion.m_iLeft, arPlusButtonRegion.m_iTop, arPlusButtonRegion.m_iRight, arPlusButtonRegion.m_iBottom, {35, 90, 120});
  }

  // plus button label
  FGUI::RENDER.Text(arPlusButtonRegion.m_iLeft + (arPlusButtonRegion.m_iRight / 2) - (dmPlusButtonTextSize.m_iWidth / 2),
                    arPlusButtonRegion.m_iTop + (arPlusButtonRegion.m_iBottom / 2) - (dmPlusButtonTextSize.m_iHeight / 2), m_ulFont, {245, 245, 245}, "+");

  //
  // remove sequence button
  //

  // minus button area
  FGUI::AREA arMinusButtonRegion = { (GetAbsolutePosition().m_iX + 90), (GetAbsolutePosition().m_iY - 1), 16, 16};

  // minus button title text size
  FGUI::DIMENSION dmMinusButtonTextSize = FGUI::RENDER.GetTextSize(m_ulFont, "-");

  // minus button body
  if (FGUI::INPUT.IsCursorInArea(arMinusButtonRegion))
  {
    FGUI::RENDER.Rectangle(arMinusButtonRegion.m_iLeft, arMinusButtonRegion.m_iTop, arMinusButtonRegion.m_iRight, arMinusButtonRegion.m_iBottom, {50, 50, 50});
  }
  else
  {
    FGUI::RENDER.Rectangle(arMinusButtonRegion.m_iLeft, arMinusButtonRegion.m_iTop, arMinusButtonRegion.m_iRight, arMinusButtonRegion.m_iBottom, {35, 90, 120});
  }

  // minus button label
  FGUI::RENDER.Text(arMinusButtonRegion.m_iLeft + (arMinusButtonRegion.m_iRight / 2) - (dmMinusButtonTextSize.m_iWidth / 2),
                    arMinusButtonRegion.m_iTop + (arMinusButtonRegion.m_iBottom / 2) - (dmMinusButtonTextSize.m_iHeight / 2), m_ulFont, {245, 245, 245}, "-");

  //
  // gradient checkbox
  //

  // checkbox area
  FGUI::AREA arCheckboxRegion = { (GetAbsolutePosition().m_iX + 115), (GetAbsolutePosition().m_iY - 1), 16, 16};

  // checkbox body
  FGUI::RENDER.Outline((arCheckboxRegion.m_iLeft - 1), (arCheckboxRegion.m_iTop - 1), arCheckboxRegion.m_iRight, arCheckboxRegion.m_iBottom, {220, 220, 220});
  FGUI::RENDER.Rectangle(arCheckboxRegion.m_iLeft, arCheckboxRegion.m_iTop, (arCheckboxRegion.m_iRight - 2), (arCheckboxRegion.m_iBottom - 2), {255, 255, 255});

  if (m_prgpColorInfo[m_uiSelectedEntry].m_bGradient)
  {
    if (FGUI::INPUT.IsCursorInArea(arCheckboxRegion))
    {
      FGUI::RENDER.Outline((arCheckboxRegion.m_iLeft - 1), (arCheckboxRegion.m_iTop - 1), arCheckboxRegion.m_iRight, arCheckboxRegion.m_iBottom, {180, 25, 25});
    }

    FGUI::RENDER.Rectangle((arCheckboxRegion.m_iLeft + 3), (arCheckboxRegion.m_iTop + 3), (arCheckboxRegion.m_iRight - 8), (arCheckboxRegion.m_iBottom - 8), {180, 25, 25});
  }
  else
  {
    if (FGUI::INPUT.IsCursorInArea(arCheckboxRegion))
    {
      FGUI::RENDER.Outline((arCheckboxRegion.m_iLeft - 1), (arCheckboxRegion.m_iTop - 1), arCheckboxRegion.m_iRight, arCheckboxRegion.m_iBottom, {195, 195, 195});
    }
  }

  // checkbox label
  FGUI::RENDER.Text(arCheckboxRegion.m_iLeft + (arCheckboxRegion.m_iRight + 5), arCheckboxRegion.m_iTop, m_ulFont, {35, 35, 35}, "Gradient");

  //
  // alpha slider
  //

  // slider picker size 
  static constexpr FGUI::DIMENSION dmSliderThumbSize = {8, 6};

  // slider area
  FGUI::AREA arSliderRegion = {arColorPickerRegion.m_iLeft, (arColorPickerRegion.m_iTop + arColorPickerRegion.m_iBottom) + 40, arColorPickerRegion.m_iRight, 2};
  
  // slider title text size
  FGUI::DIMENSION dmSliderTextSize = FGUI::RENDER.GetTextSize(m_ulFont, "alpha");

  // slider body
  FGUI::RENDER.Rectangle(arSliderRegion.m_iLeft, arSliderRegion.m_iTop, arSliderRegion.m_iRight, arSliderRegion.m_iBottom, {20, 50, 70});

  // slider label
  FGUI::RENDER.Text(arSliderRegion.m_iLeft, (arSliderRegion.m_iTop - dmSliderTextSize.m_iHeight), m_ulFont, {35, 35, 35}, "alpha");

  // slider custom value
  std::string strCustomValue = "";
  float flValueToPercentage = (m_prgpColorInfo[m_uiSelectedEntry].m_clrFirst.m_ucAlpha / 2.55f);

  // custom range text
  if (m_prgpColorInfo[m_uiSelectedEntry].m_clrFirst.m_ucAlpha == 0)
  {
    strCustomValue = "Transparent";
  }
  else if (m_prgpColorInfo[m_uiSelectedEntry].m_clrFirst.m_ucAlpha == 255)
  {
    strCustomValue = "Opaque";
  }
  else
  {
    strCustomValue = std::to_string(static_cast<int>(flValueToPercentage)) + "%";
  }

   // slider value text size
  FGUI::DIMENSION dmSliderValueTextSize = FGUI::RENDER.GetTextSize(m_ulFont, strCustomValue);

  // slider value
  FGUI::RENDER.Text((arSliderRegion.m_iLeft + arSliderRegion.m_iRight) - dmSliderValueTextSize.m_iWidth, (arSliderRegion.m_iTop - dmSliderTextSize.m_iHeight) - 2, m_ulFont, {35, 35, 35}, strCustomValue);

  // slider position ratio
  float flRatio = (m_prgpColorInfo[m_uiSelectedEntry].m_clrFirst.m_ucAlpha - 0.f) / (255.f - 0.f);
  float flLocation = (flRatio * arColorPickerRegion.m_iRight);

  // slider thumb
  FGUI::RENDER.Rectangle((arSliderRegion.m_iLeft + flLocation), (arSliderRegion.m_iTop - 2), dmSliderThumbSize.m_iWidth, dmSliderThumbSize.m_iHeight, {180, 25, 25});

  // thumb properties
  static constexpr FGUI::DIMENSION dmScrollBarThumbWidth = {8, 5};

  // calculate thumb position
  float flCalculatedPosition = static_cast<float>(m_iScrollThumbPosition) / static_cast<float>(m_prgpColorInfo.size());

  if (flCalculatedPosition >= 1.f)
  {
    flCalculatedPosition = 1.f;
  }

  flCalculatedPosition *= ((m_dmSize.m_iHeight - 20) - m_iEntrySpacing) - 10;

  // calculate thumb size
  float flCalculatedSize = static_cast<float>(iCalculatedEntries) / static_cast<float>(m_prgpColorInfo.size());

  if (flCalculatedSize > 1.f)
  {
    flCalculatedSize = 1.f;
  }

  flCalculatedSize *= ((m_dmSize.m_iHeight - 20) - m_iEntrySpacing);

  // scrollbar body
  FGUI::RENDER.Rectangle(arScrollBarRegion.m_iLeft, arScrollBarRegion.m_iTop, arScrollBarRegion.m_iRight, arScrollBarRegion.m_iBottom, {235, 235, 235});

  if (m_prgpColorInfo.size() > 50)
  {
    FGUI::RENDER.Rectangle((arScrollBarRegion.m_iLeft + 4), (arScrollBarRegion.m_iTop + flCalculatedPosition) + 5, dmScrollBarThumbWidth.m_iWidth, dmScrollBarThumbWidth.m_iHeight, {220, 223, 231});
  }
  else
  {
    FGUI::RENDER.Rectangle((arScrollBarRegion.m_iLeft + 4), (arScrollBarRegion.m_iTop + flCalculatedPosition) + 5, dmScrollBarThumbWidth.m_iWidth, flCalculatedSize, {220, 223, 231});
  }
}

void CColorList::Update()
{
  if (m_bIsDragging)
  {
    // calculate the amount of entries that will be drawn on the colorlist
    int iCalculatedEntries = ((m_dmSize.m_iHeight - 20) / m_iEntrySpacing);

    // cursor position
    FGUI::POINT ptCursorPos = FGUI::INPUT.GetCursorPos();

    if (FGUI::INPUT.GetKeyState(MOUSE_1))
    {
      // move thumb vertically
      ptCursorPos.m_iY -= (GetAbsolutePosition().m_iY + 20);

      // ratio of how many visible to how many are hidden
      float flVisibleRatio = static_cast<float>(iCalculatedEntries) / static_cast<float>(m_prgpColorInfo.size());
      flVisibleRatio *= ((m_dmSize.m_iHeight - 20) - m_iEntrySpacing);

      // calculate height delta
      float flHeightDelta = static_cast<float>(ptCursorPos.m_iY + flVisibleRatio) - static_cast<float>((m_dmSize.m_iHeight - 20));

      if (flHeightDelta >= 0.f)
      {
        ptCursorPos.m_iY -= flHeightDelta;
      }

      // new vertical position ratio
      float flNewYRatio = static_cast<float>(ptCursorPos.m_iY) / static_cast<float>(m_dmSize.m_iHeight - 20);
      m_iScrollThumbPosition = (flNewYRatio * m_prgpColorInfo.size());

      // clamp position (don't let the user drag the scrollthumb if it reaches the "start" of the scrollbar area)
      if (m_iScrollThumbPosition <= 0)
      {
        m_iScrollThumbPosition = 0;
      }
    }
    else
    {
      m_bIsDragging = false;
    }
  }

  // color gap
  static constexpr int iColorPickerGap = 250;

  // color picker size
  static constexpr FGUI::DIMENSION dmColorPickerSize = {150, 150};

  // color picker area
  FGUI::AREA arColorPickerRegion = {(GetAbsolutePosition().m_iX + (m_dmSize.m_iWidth - iColorPickerGap) + 10), (GetAbsolutePosition().m_iY + 20), dmColorPickerSize.m_iWidth, dmColorPickerSize.m_iHeight};

  // color hsb area
  FGUI::AREA arColorHSBRegion = {arColorPickerRegion.m_iLeft, arColorPickerRegion.m_iTop, arColorPickerRegion.m_iRight, arColorPickerRegion.m_iBottom};

  // color hue area
  FGUI::AREA arColorHueRegion = {(arColorPickerRegion.m_iLeft + arColorPickerRegion.m_iRight) + 10, arColorPickerRegion.m_iTop, 15, arColorPickerRegion.m_iBottom};

  // alpha slider area
  FGUI::AREA arAlphaSliderRegion = {arColorPickerRegion.m_iLeft, (arColorPickerRegion.m_iTop + arColorPickerRegion.m_iBottom) + 40, arColorPickerRegion.m_iRight, 10};

  // switches
  static bool bColorHSBSelected = false;
  static bool bColorHueSelected = false;
  static bool bAlphaSliderSelected = false;

  // get cursor position
  FGUI::POINT ptCursorPos = FGUI::INPUT.GetCursorPos();

  if (FGUI::INPUT.GetKeyPress(MOUSE_1))
  {
    bColorHSBSelected = FGUI::INPUT.IsCursorInArea(arColorHSBRegion);
    bColorHueSelected = FGUI::INPUT.IsCursorInArea(arColorHueRegion);
    bAlphaSliderSelected = FGUI::INPUT.IsCursorInArea(arAlphaSliderRegion);
  }
  else if (FGUI::INPUT.GetKeyRelease(MOUSE_1))
  {
    bColorHSBSelected = false;
    bColorHueSelected = false;
    bAlphaSliderSelected = false;
  }

  if (bColorHSBSelected)
  {
    FGUI::PRECISION plRelativePos = { ptCursorPos.m_iX - static_cast<float>(arColorHSBRegion.m_iLeft), ptCursorPos.m_iY - static_cast<float>(arColorHSBRegion.m_iTop) };
		
    m_prgpColorInfo[m_uiSelectedEntry].m_clrFirst = FGUI::COLOR::HSBToRGB(FGUI::COLOR::GetHue(m_prgpColorInfo[m_uiSelectedEntry].m_clrFirst), (plRelativePos.m_flX / 
    arColorPickerRegion.m_iRight), (plRelativePos.m_flY / arColorPickerRegion.m_iBottom), m_prgpColorInfo[m_uiSelectedEntry].m_clrFirst.m_ucAlpha);
  }
  else if (bColorHueSelected)
  {
    float flHue = (ptCursorPos.m_iY - arColorHueRegion.m_iTop) / 150.f;
    
    m_prgpColorInfo[m_uiSelectedEntry].m_clrFirst = FGUI::COLOR::HSBToRGB(std::clamp(flHue, 0.f, 1.f), 1.f, 1.f);
  }
  else if (bAlphaSliderSelected)
  {
    float flXPosDelta = 0.f;
    float flRatio = 0.f;

    // change slider value based on mouse movement
    flXPosDelta = (ptCursorPos.m_iX - arColorPickerRegion.m_iLeft);

    // clamp values
    if (flXPosDelta <= 0.f)
    {
      flXPosDelta = 0.f;
    }

    else if (flXPosDelta >= arColorPickerRegion.m_iRight)
    {
      flXPosDelta = arColorPickerRegion.m_iRight;
    }

    // calculate slider ratio
    flRatio = flXPosDelta / static_cast<float>(arColorPickerRegion.m_iRight);

    // change slider value
    m_prgpColorInfo[m_uiSelectedEntry].m_clrFirst.m_ucAlpha = 0.f + (255.f - 0.f) * flRatio;
  }
}

void CColorList::Input()
{
  // color gap
  static constexpr int iColorPickerGap = 250;

  // widget's area
  FGUI::AREA arWidgetRegion = { GetAbsolutePosition().m_iX, GetAbsolutePosition().m_iY, (m_dmSize.m_iWidth - iColorPickerGap), m_dmSize.m_iHeight};

  // scrollbar area
  FGUI::AREA arScrollBarRegion = {(arWidgetRegion.m_iLeft + arWidgetRegion.m_iRight) - 15, (arWidgetRegion.m_iTop + 20), 15, (m_dmSize.m_iHeight - 20)};

  if (FGUI::INPUT.IsCursorInArea(arScrollBarRegion))
  {
    m_bIsDragging = true;
  }

  // entries displayed
  int iEntriesDisplayed = 0;

  // calculate the amount of entries that will be drawn on the colorlist
  int iCalculatedEntries = ((m_dmSize.m_iHeight - 20) / m_iEntrySpacing);

  // colorlist entries
  for (std::size_t i = m_iScrollThumbPosition; (i < m_prgpColorInfo.size()) && (iEntriesDisplayed < iCalculatedEntries); i++)
  {
    // entry area
    FGUI::AREA arEntryRegion = {arWidgetRegion.m_iLeft, arWidgetRegion.m_iTop + (m_iEntrySpacing * iEntriesDisplayed) + 20, (arWidgetRegion.m_iRight - 15), m_iEntrySpacing};

    // select an entry
    if (FGUI::INPUT.IsCursorInArea(arEntryRegion))
    {
      m_uiSelectedEntry = i;
    }

    iEntriesDisplayed++;
  }

  // plus button area
  FGUI::AREA arPlusButtonRegion = { (GetAbsolutePosition().m_iX + 70), (GetAbsolutePosition().m_iY - 1), 16, 16};

  // minus button area
  FGUI::AREA arMinusButtonRegion = { (GetAbsolutePosition().m_iX + 90), (GetAbsolutePosition().m_iY - 1), 16, 16};

  if (FGUI::INPUT.IsCursorInArea(arPlusButtonRegion))
  {
    if (!m_prgpColorInfo[m_uiSelectedEntry].m_bIsSecondColorAdded)
    {
      // make the first color be the secondary color
      m_prgpColorInfo[m_uiSelectedEntry].m_clrSecond = m_prgpColorInfo[m_uiSelectedEntry].m_clrFirst;

      // add a new color into the sequence
      m_prgpColorInfo[m_uiSelectedEntry].m_bIsSecondColorAdded = true;
    }
  }

  else if (FGUI::INPUT.IsCursorInArea(arMinusButtonRegion))
  {
    if (m_prgpColorInfo[m_uiSelectedEntry].m_bIsSecondColorAdded)
    {
      // remeve color from sequence
      m_prgpColorInfo[m_uiSelectedEntry].m_bIsSecondColorAdded = false;
    }
  }

  // gradient checkbox area
  FGUI::AREA arCheckboxRegion = { (GetAbsolutePosition().m_iX + 115), (GetAbsolutePosition().m_iY - 1), 16, 16};

  if (FGUI::INPUT.IsCursorInArea(arCheckboxRegion))
  {
    m_prgpColorInfo[m_uiSelectedEntry].m_bGradient = !m_prgpColorInfo[m_uiSelectedEntry].m_bGradient;
  }
}

} // namespace FGUI
```

`Lumina/Lumina/ui/fgui_/widgets/colorlist.hpp`:

```hpp
//
// FGUI - feature rich graphical user interface
//

#ifndef FGUI_COLORLIST_HH
#define FGUI_COLORLIST_HH

// includes
#include <vector>
#include <string>
#include <algorithm>
#include <cmath>

// library includes
#include "widgets.hpp"

namespace FGUI
{

class CSlider;
class CButton;
class CCheckBox;

using COLOR_INFO = struct SColorInfo_t
{
  SColorInfo_t(std::string identificator, FGUI::COLOR color, bool gradient);

  std::string m_strIdentificator;
  FGUI::COLOR m_clrFirst;
  FGUI::COLOR m_clrSecond;
  bool m_bGradient;
  bool m_bIsSecondColorAdded;
};

class CColorList : public FGUI::CWidgets
{
public:
  CColorList();

  // @brief: adds a new color into the list
  // @params: std::string identificator = color identificator (label), FGUI::COLOR color = color, bool gradient = interpolation state (true by default or not)
  void AddColor(std::string identificator, FGUI::COLOR color, bool gradient = false);

  // @brief: set a custom color and the gradient state of an entry on the list
  // @params: std::size_t index = entry index, FGUI::COLOR color = color, bool gradient = gradient state (defaults to false)
  void SetColor(std::size_t index, FGUI::COLOR color, bool gradient = false);

  // @brief: returns the current color from a entry on the list
  // @params: std::size_t index = entry index (defaults to 0)
  FGUI::COLOR GetColor(std::size_t index = 0);

  // @brief: get color info
  std::vector<FGUI::COLOR_INFO> GetColorInfo();

  // @brief: populate widget geometry (draw widget)
  void Geometry() override;

  // @brief: handle update operations on the widget
  void Update() override;

  // @brief: handle input inside the widget
  void Input() override;

private:
  std::size_t m_uiSelectedEntry;
  int m_iEntrySpacing;
  bool m_bIsDragging;
  int m_iScrollThumbPosition;
  std::vector<FGUI::COLOR_INFO> m_prgpColorInfo;
};

} // namespace FGUI

#endif // FGUI_COLORLIST_hH
```

`Lumina/Lumina/ui/fgui_/widgets/form.cpp`:

```cpp
//
// FGUI - feature rich graphical user interface
//

// library includes
#include "form.hpp"
#include "groupbox.hpp"
#include "../../../common/common.h"

#include "../../menu.h"
#include "../../render.h"

namespace FGUI
{

	void CForm::Render()
	{
		// handle input system
		//FGUI::INPUT.PullInput();

		if (FGUI::INPUT.GetKeyPress(GetKey()))
		{
			// toggle main form on and off
			SetState(!GetState());
		}

		// if the user toggles the main form
		if (GetState())
		{
			// update main form
			Update();

			// handle main form movement
			Movement();

			// populate main form geometry
			Geometry();
		}


		// iterate over child forms
		for (const std::shared_ptr<FGUI::CForm>& childs : m_prgpForms)
		{
			if (FGUI::INPUT.GetKeyPress(childs->GetKey()))
			{
				// toggle child forms on and off
				childs->SetState(!childs->GetState());
			}

			// if the user toggles a child form
			if (childs->GetState())
			{
				// update child forms
				childs->Update();

				// handle child forms movement
				childs->Movement();

				// populate child forms geometry
				childs->Geometry();
			}
		}
	}

	void CForm::SetState(bool onoff)
	{
		m_bIsOpened = onoff;
	}

	bool CForm::GetState()
	{
		return m_bIsOpened;
	}

	void CForm::AddForm(std::shared_ptr<FGUI::CForm> form)
	{
		if (!form)
		{
			return;
		}

		// populate the form container
		m_prgpForms.emplace_back(form);
	}

	void CForm::AddTab(std::shared_ptr<FGUI::CTabs> tab)
	{
		if (!tab)
		{
			return;
		}

		// select the current tab being added (in case the form doesn't select one for us)
		if (!m_prgpTabs.size())
		{
			m_pSelectedTab = tab;
		}

		// set parent form
		tab->m_pParentForm = std::dynamic_pointer_cast<FGUI::CForm>(shared_from_this());

		// populate the tab container
		m_prgpTabs.emplace_back(tab);
	}

	void CForm::AddCallback(std::function<void()> callback)
	{
		m_fnctCallback = callback;
	}

	void CForm::SetKey(unsigned int key_code)
	{
		m_iKey = key_code;
	}

	void CForm::SetPosition(unsigned int x, unsigned int y)
	{
		m_ptPosition.m_iX = x;
		m_ptPosition.m_iY = y;
	}

	void CForm::SetSize(unsigned int width, unsigned int height)
	{
		m_dmSize.m_iWidth = width;
		m_dmSize.m_iHeight = height;
	}

	void CForm::SetSize(FGUI::DIMENSION size)
	{
		m_dmSize.m_iWidth = size.m_iWidth;
		m_dmSize.m_iHeight = size.m_iHeight;
	}

	void CForm::SetTitle(std::string title)
	{
		m_strTitle = title;
	}

	void CForm::SetFlags(int flags)
	{
		m_nFlags = flags;
	}

	int CForm::GetKey()
	{
		return m_iKey;
	}

	std::string CForm::GetTitle()
	{
		return m_strTitle;
	}

	void CForm::SetFont(std::string family, int size, bool bold, int flags)
	{
		FGUI::RENDER.CreateFont(m_ulFont, family, size, flags, bold);
	}

	void CForm::SetFont(FGUI::WIDGET_FONT font)
	{
		FGUI::RENDER.CreateFont(m_ulFont, font.m_strFamily, font.m_iSize, font.m_nFlags, font.m_bBold);
	}

	FGUI::AREA CForm::GetWidgetArea()
	{
		// NOTE: if you plan to change the form design, make sure to edit this as well. (this is the area where widgets will be drawned)
		return { m_ptPosition.m_iX + menu::spaceSize + menu::lineSize, m_ptPosition.m_iY + menu::spaceSize + menu::tabSpaceSize + menu::lineSize, m_dmSize.m_iWidth, m_dmSize.m_iHeight };
	}

	void CForm::SetFocusedWidget(std::shared_ptr<FGUI::CWidgets> widget)
	{
		m_pFocusedWidget = widget;

		if (widget)
		{
			m_bIsFocusingOnWidget = true;
		}
		else
		{
			m_bIsFocusingOnWidget = false;
		}
	}

	std::shared_ptr<FGUI::CWidgets> CForm::GetFocusedWidget()
	{
		return m_pFocusedWidget;
	}

	FGUI::FONT CForm::GetFont()
	{
		return m_ulFont;
	}

	bool CForm::GetFlags(FGUI::WIDGET_FLAG flags)
	{
		if (m_nFlags & static_cast<int>(flags))
		{
			return true;
		}

		return false;
	}

	FGUI::POINT CForm::GetPosition()
	{
		return m_ptPosition;
	}

	FGUI::DIMENSION CForm::GetSize()
	{
		return m_dmSize;
	}

	void CForm::Geometry()
	{
		render::drawGradiant(m_ptPosition.m_iX, m_ptPosition.m_iY, m_dmSize.m_iWidth, m_dmSize.m_iHeight, menu::lightTop, menu::lightBottom, menu::alphaBackground, false);
		render::drawGradiant(m_ptPosition.m_iX + menu::lineSize, m_ptPosition.m_iY + menu::lineSize, m_dmSize.m_iWidth - (menu::lineSize * 2), m_dmSize.m_iHeight - (menu::lineSize * 2), menu::mainTop, menu::mainBottom, menu::alphaBackground, false);

		menu::logo.m_bgColor.SetAlpha(menu::alphaBackground);
		menu::logo.Draw(m_ptPosition.m_iX + menu::spaceSize, m_ptPosition.m_iY + menu::spaceSize + 22);
		
		render::drawRectangle(m_ptPosition.m_iX + menu::spaceSize, m_ptPosition.m_iY + menu::spaceSize + menu::tabSpaceSize, m_dmSize.m_iWidth - (menu::spaceSize * 2), m_dmSize.m_iHeight - (menu::spaceSize * 2) - menu::tabSpaceSize, menu::mainTabLight);
		
		render::drawRectangle(m_ptPosition.m_iX + menu::spaceSize + menu::tabIconX, m_ptPosition.m_iY + menu::spaceSize, (76 * 4) + (menu::lineSize * 2), 80, menu::mainTabLight);
		
		render::drawRectangle(m_ptPosition.m_iX + menu::spaceSize + menu::lineSize, m_ptPosition.m_iY + menu::spaceSize + menu::tabSpaceSize + menu::lineSize, m_dmSize.m_iWidth - (menu::spaceSize * 2) - (menu::lineSize * 2), m_dmSize.m_iHeight - (menu::spaceSize * 2) - menu::tabSpaceSize - (menu::lineSize * 2), menu::mainTab);
		
		//render::drawRectangle(m_ptPosition.m_iX + menu::spaceSize + menu::tabIconX + menu::lineSize, m_ptPosition.m_iY + menu::spaceSize + menu::lineSize, (76 * 4) + (menu::spaceSize * 2), 80, menu::mainTab);


		// if the window has a function
		if (m_fnctCallback)
		{
			// invoke function
			m_fnctCallback();
		}

		// don't proceed if the form doesn't have any tabs
		if (m_prgpTabs.empty())
		{
			return;
		}

		// tab buttons
		for (std::size_t i = 0; i < m_prgpTabs.size(); i++)
		{
			// tab button area
			FGUI::AREA arTabRegion = { (m_ptPosition.m_iX + menu::spaceSize + menu::tabIconX + menu::lineSize) + (static_cast<int>(i) * 76), (m_ptPosition.m_iY + menu::spaceSize + menu::lineSize), 76, 80 };

			if (FGUI::INPUT.IsCursorInArea(arTabRegion))
			{
				if (FGUI::INPUT.GetKeyPress(MOUSE_1))
				{
					// select tab
					m_pSelectedTab = m_prgpTabs[i];
				}

				// unfocus widget
				m_pFocusedWidget = nullptr;
			}

			// draw the buttons according to the tab state
			if (m_pSelectedTab == m_prgpTabs[i])
			{
				FGUI::RENDER.Rectangle(arTabRegion.m_iLeft, arTabRegion.m_iTop, arTabRegion.m_iRight, arTabRegion.m_iBottom, menu::mainTab.toFGUICOLOR());
				FGUI::RENDER.Text(arTabRegion.m_iLeft + 20, arTabRegion.m_iTop + (arTabRegion.m_iBottom / 2) - 5, m_prgpTabs[i]->GetFont(), { 255, 255, 255 }, m_prgpTabs[i]->GetTitle());
			}
			else
			{
				FGUI::RENDER.Rectangle(arTabRegion.m_iLeft, arTabRegion.m_iTop, arTabRegion.m_iRight, arTabRegion.m_iBottom, menu::mainTab.toFGUICOLOR());
				FGUI::RENDER.Text(arTabRegion.m_iLeft + 20, arTabRegion.m_iTop + (arTabRegion.m_iBottom / 2) - 5, m_prgpTabs[i]->GetFont(), { 220, 220, 220 }, m_prgpTabs[i]->GetTitle());
			}
		}

		// if the user selects a tab
		if (m_pSelectedTab)
		{
			// this will tell the form to skip focused elements (so it can be drawned after all others)
			bool bSkipWidget = false;

			// this will hold the skipped element
			std::shared_ptr<FGUI::CWidgets> pWidgetToSkip = nullptr;

			// if the form is focusing on a widget
			if (m_bIsFocusingOnWidget)
			{
				if (m_pFocusedWidget)
				{
					// assign the widget that will be skipped
					pWidgetToSkip = m_pFocusedWidget;

					// tell the form to skip this widget
					bSkipWidget = true;
				}
			}

			// if the tab doesn't have any widgets, don't proceed
			if (m_pSelectedTab->m_prgpWidgets.empty())
			{
				return;
			}

			// iterate over the rest of the widgets
			for (const std::shared_ptr<FGUI::CWidgets>& pWidgets : m_pSelectedTab->m_prgpWidgets)
			{
				// if the menu is having a widget skiped
				if (bSkipWidget)
				{
					// check if the widget inside this iteration is not the one that will be skipped
					if (pWidgetToSkip == pWidgets)
					{
						continue;
					}
				}

				// check if widgets are unlocked (able to be drawned)
				if (pWidgets && pWidgets->GetFlags(WIDGET_FLAG::DRAWABLE) && pWidgets->IsUnlocked())
				{
					// found groupbox
					std::shared_ptr<FGUI::CGroupBox> pFoundGroupBox = nullptr;

					if (pWidgets->GetType() != static_cast<int>(WIDGET_TYPE::GROUPBOX))
					{
						pFoundGroupBox = pWidgets->m_pParentGroupBox ? std::reinterpret_pointer_cast<FGUI::CGroupBox>(pWidgets->m_pParentGroupBox) : nullptr;
					}

					if (pFoundGroupBox)
					{
						// check if the groupbox has scrollbars enabled
						if (pFoundGroupBox->GetScrollbarState())
						{
							// check if the skipped widgets are inside the boundaries of the groupbox
							if ((pWidgets->GetAbsolutePosition().m_iY + pWidgets->GetSize().m_iHeight) <= (pFoundGroupBox->GetAbsolutePosition().m_iY + pFoundGroupBox->GetSize().m_iHeight)
								&& (pWidgets->GetAbsolutePosition().m_iY >= pFoundGroupBox->GetAbsolutePosition().m_iY))
							{
								// draw other skipped widgets
								pWidgets->Geometry();
							}
						}
						else
						{
							// draw other widgets
							pWidgets->Geometry();
						}
					}
					else if (pWidgets->GetType() == static_cast<int>(WIDGET_TYPE::GROUPBOX) || pWidgets->GetType() == static_cast<int>(WIDGET_TYPE::COLORLIST))
					{
						// draw widgets that needs to be outside of a groupbox
						pWidgets->Geometry();
					}
				}
			}

			// now the form can draw skipped widgets
			if (bSkipWidget)
			{
				if (pWidgetToSkip && pWidgetToSkip->GetFlags(WIDGET_FLAG::DRAWABLE) && pWidgetToSkip->IsUnlocked())
				{
					// found groupbox
					std::shared_ptr<FGUI::CGroupBox> pFoundGroupBox = nullptr;

					if (pWidgetToSkip->GetType() != static_cast<int>(WIDGET_TYPE::GROUPBOX))
					{
						pFoundGroupBox = pWidgetToSkip->m_pParentGroupBox ? std::reinterpret_pointer_cast<FGUI::CGroupBox>(pWidgetToSkip->m_pParentGroupBox) : nullptr;
					}

					if (pFoundGroupBox)
					{
						// check if the groupbox has scrollbars enabled
						if (pFoundGroupBox->GetScrollbarState())
						{
							// check if the skipped widgets are inside the boundaries of the groupbox
							if ((pWidgetToSkip->GetAbsolutePosition().m_iY + pWidgetToSkip->GetSize().m_iHeight) <= (pFoundGroupBox->GetAbsolutePosition().m_iY + pFoundGroupBox->GetSize().m_iHeight)
								&& (pWidgetToSkip->GetAbsolutePosition().m_iY >= pFoundGroupBox->GetAbsolutePosition().m_iY))
							{
								// draw other skipped widgets
								pWidgetToSkip->Geometry();
							}
						}
						else
						{
							// draw other skipped widgets
							pWidgetToSkip->Geometry();
						}
					}
					else if (pWidgetToSkip->GetType() == static_cast<int>(WIDGET_TYPE::GROUPBOX) || pWidgetToSkip->GetType() == static_cast<int>(WIDGET_TYPE::COLORLIST))
					{
						// draw widgets that needs to be outside of a groupbox
						pWidgetToSkip->Geometry();
					}
				}
			}
		}
	}

	void CForm::Update()
	{
		// don't do updates while the form is closed
		if (!m_bIsOpened)
		{
			return;
		}

		// form flags
		if (GetFlags(WIDGET_FLAG::FULLSCREEN))
		{
			// change form size
			SetSize(FGUI::RENDER.GetScreenSize());
		}

		// check if the form received a click
		bool bCheckWidgetClicks = false;

		if (FGUI::INPUT.GetKeyPress(MOUSE_1))
		{
			// grab screen size
			FGUI::DIMENSION dmScreenSize = FGUI::RENDER.GetScreenSize();

			// get "clickable" area (you can limit this to the form boundaries instead of using the entire screen.)
			FGUI::AREA arClickableRegion = { m_ptPosition.m_iX, m_ptPosition.m_iY, dmScreenSize.m_iWidth, dmScreenSize.m_iHeight };

			if (FGUI::INPUT.IsCursorInArea(arClickableRegion))
			{
				// tell the form that it had received a click
				bCheckWidgetClicks = true;
			}
		}

		// if the form doesn't have a tab selected, don't proceed
		if (!m_pSelectedTab)
		{
			return;
		}

		// if the tab doesn't have any widgets, don't proceed
		if (m_pSelectedTab->m_prgpWidgets.empty())
		{
			return;
		}

		// this will tell the form to skip focused elements (so it can be drawned after all other's)
		bool bSkipWidget = false;

		// this will hold the skipped element
		std::shared_ptr<FGUI::CWidgets> pWidgetToSkip = nullptr;

		// handle updates on the focused widget first
		if (m_bIsFocusingOnWidget)
		{
			if (m_pFocusedWidget)
			{
				// check if the focused widget is unlocked
				if (m_pFocusedWidget->IsUnlocked())
				{
					// tell the form to skip this widget
					bSkipWidget = true;

					// assign the widget that will be skipped
					pWidgetToSkip = m_pFocusedWidget;

					// get focused widget area
					FGUI::AREA arFocusedWidgetRegion = { pWidgetToSkip->GetAbsolutePosition().m_iX, pWidgetToSkip->GetAbsolutePosition().m_iY, pWidgetToSkip->GetSize().m_iWidth, pWidgetToSkip->GetSize().m_iHeight };

					// update focused widget
					pWidgetToSkip->Update();

					// check if the focused widget can be clicked
					if (pWidgetToSkip->GetFlags(WIDGET_FLAG::CLICKABLE) && FGUI::INPUT.IsCursorInArea(arFocusedWidgetRegion) && bCheckWidgetClicks)
					{
						// handle input of focused widgets
						pWidgetToSkip->Input();

						// unfocus this widget
						SetFocusedWidget(nullptr);

						// tell the form to look for another click
						bCheckWidgetClicks = false;
					}
				}
			}
		}

		// iterate over the rest of the widgets
		for (const std::shared_ptr<FGUI::CWidgets>& pWidgets : m_pSelectedTab->m_prgpWidgets)
		{
			// check if the widgets are unlocked first
			if (pWidgets->IsUnlocked())
			{
				// if the menu is having a widget skiped
				if (bSkipWidget)
				{
					// check if the widget inside this iteration is not the one that will be skipped
					if (pWidgetToSkip == pWidgets)
					{
						continue;
					}
				}
				// found groupbox
				std::shared_ptr<FGUI::CGroupBox> pFoundGroupBox = nullptr;

				if (pWidgets->GetType() != static_cast<int>(WIDGET_TYPE::GROUPBOX))
				{
					pFoundGroupBox = pWidgets->m_pParentGroupBox ? std::reinterpret_pointer_cast<FGUI::CGroupBox>(pWidgets->m_pParentGroupBox) : nullptr;
				}
				
				// get the widget area
				FGUI::AREA arWidgetRegion = { pWidgets->GetAbsolutePosition().m_iX, pWidgets->GetAbsolutePosition().m_iY, pWidgets->GetSize().m_iWidth, pWidgets->GetSize().m_iHeight };

				if (pFoundGroupBox)
				{
					// check if the groupbox has scrollbars enabled
					if (pFoundGroupBox->GetScrollbarState())
					{
						// check if the skipped widgets are inside the boundaries of the groupbox
						if ((pWidgets->GetAbsolutePosition().m_iY + pWidgets->GetSize().m_iHeight) <= (pFoundGroupBox->GetAbsolutePosition().m_iY + pFoundGroupBox->GetSize().m_iHeight)
							&& (pWidgets->GetAbsolutePosition().m_iY >= pFoundGroupBox->GetAbsolutePosition().m_iY))
						{
							// update widgets
							pWidgets->Update();

							// check if the widget can be clicked
							if (pWidgets->GetFlags(WIDGET_FLAG::CLICKABLE) && FGUI::INPUT.IsCursorInArea(arWidgetRegion) && bCheckWidgetClicks)
							{
								// handle widget input
								pWidgets->Input();

								// tell the form to look for another click
								bCheckWidgetClicks = false;

								// focus widget
								if (pWidgets->GetFlags(WIDGET_FLAG::FOCUSABLE))
								{
									SetFocusedWidget(pWidgets);
								}
								else
								{
									SetFocusedWidget(nullptr);
								}
							}
						}
					}
					else
					{
						// update widgets
						pWidgets->Update();

						// check if the widget can be clicked
						if (pWidgets->GetFlags(WIDGET_FLAG::CLICKABLE) && FGUI::INPUT.IsCursorInArea(arWidgetRegion) && bCheckWidgetClicks)
						{
							// handle widget input
							pWidgets->Input();

							// tell the form to look for another click
							bCheckWidgetClicks = false;

							// focus widget
							if (pWidgets->GetFlags(WIDGET_FLAG::FOCUSABLE))
							{
								SetFocusedWidget(pWidgets);
							}
							else
							{
								SetFocusedWidget(nullptr);
							}
						}
					}
				}
				else if (pWidgets->GetType() == static_cast<int>(WIDGET_TYPE::GROUPBOX) || pWidgets->GetType() == static_cast<int>(WIDGET_TYPE::COLORLIST))
				{
					// update widgets outside a groupbox
					pWidgets->Update();

					// check if the widgets can be clicked
					if (pWidgets->GetFlags(WIDGET_FLAG::CLICKABLE) && FGUI::INPUT.IsCursorInArea(arWidgetRegion) && bCheckWidgetClicks)
					{
						// handle input
						pWidgets->Input();

						// tell the form to look for another click
						bCheckWidgetClicks = false;
					}
				}
			}
		}
	}

	void CForm::Movement()
	{
		// don't handle movement while the form is closed
		if (!m_bIsOpened)
		{
			return;
		}

		// form draggable area
		FGUI::AREA arDraggableArea = { m_ptPosition.m_iX, m_ptPosition.m_iY, m_dmSize.m_iWidth, 60 };

		if (FGUI::INPUT.IsCursorInArea(arDraggableArea))
		{
			if (FGUI::INPUT.GetKeyPress(MOUSE_1))
			{
				// drag form
				m_bIsDragging = true;
			}
		}

		// if the user started dragging the form
		if (m_bIsDragging)
		{
			// get cursor position delta
			FGUI::POINT ptCursorPosDelta = FGUI::INPUT.GetCursorPosDelta();

			// move form
			m_ptPosition.m_iX += ptCursorPosDelta.m_iX;
			m_ptPosition.m_iY += ptCursorPosDelta.m_iY;
		}

		if (FGUI::INPUT.GetKeyRelease(MOUSE_1))
		{
			m_bIsDragging = false;
		}
	}

} // namespace FGUI
```

`Lumina/Lumina/ui/fgui_/widgets/form.hpp`:

```hpp
//
// FGUI - feature rich graphical user interface
//

#ifndef FGUI_FORM_HH
#define FGUI_FORM_HH

// includes
#include <algorithm>
#include <functional>
#include <memory>
#include <string>
#include <vector>

// library includes
#include "../dependencies/aliases.hpp"
#include "../dependencies/definitions.hpp"
#include "tabs.hpp"

namespace FGUI
{

  class CTabs;
  class CGroupBox;
  class CWidgets;

  class CForm : public std::enable_shared_from_this<FGUI::CForm>
  {
    friend class FGUI::CWidgets;
    friend class FGUI::CGroupBox;
  public:
    // @brief: handles rendering of forms and widgets
    void Render();

    // @brief: set the form state (toggle on/off)
    // @params: bool onoff = form state
    void SetState(bool onoff);

    // @brief: get the form state (toggled or not)
    bool GetState();

    // @brief: add a new form into the container
    // @params: std::shared_ptr<FGUI::CForm> form = form instance (pointer)
    void AddForm(std::shared_ptr<FGUI::CForm> form);

    // @brief: add a new tab into the form
    // @params: std::shared_ptr<FGUI::CTabs> tab = tab instance (pointer)
    void AddTab(std::shared_ptr<FGUI::CTabs> tab);

    // @brief: adds a function callback for the form (it will call the function whenever the opens the form)
    // @params: std::function<void()> callback = function instance
    void AddCallback(std::function<void()> callback);

    // @brief: set the key that will toggle the form on and off
    // @params: unsigned int key_code = virtual key code
    void SetKey(unsigned int key_code);

    // @brief: set the default position of the form
    // @params: unsigned int x, unsigned int y = pixels coordinates (on the screen)
    void SetPosition(unsigned int x, unsigned int y);

    // @brief: set the default size of the form
    // @params: unsigned int width, unsigned int height = width and height of the menu in pixels
    void SetSize(unsigned int width, unsigned int height);

    // @brief: set the default size of the form
    // @params: FGUI::DIMENSION size = width and height of the menu in pixels
    void SetSize(FGUI::DIMENSION size);

    // @brief: set the default title of the form
    // @params: std::string title = default title of the form
    void SetTitle(std::string title);

    // @brief: adds a flag to the form
    // @params: form default/custom flags
    void SetFlags(int flags);

    // @brief: return the font toggle key
    int GetKey();

    // @brief: get the form's default title
    std::string GetTitle();

    // @brief: set the default font of the form
    // @params: std::string family = font family name, int size = font size, bool bold = make the font bold, int flags = font flags
    void SetFont(std::string family, int size, bool bold = false, int flags = 0x0);

    // @brief: set the default font of the form
    // @params: FGUI::WIDGET_FONT font = widget font struct
    void SetFont(FGUI::WIDGET_FONT font);

    // @brief: get the widget drawable area inside the form (this will set where the widgets will be drawned)
    FGUI::AREA GetWidgetArea();

    // @brief: make a widget be focused
    // @params: std::shared_ptr<FGUI::CWidgets> widget = widget instance (instance)
    void SetFocusedWidget(std::shared_ptr<FGUI::CWidgets> widget);

    // @brief: get the current focused widget
    std::shared_ptr<FGUI::CWidgets> GetFocusedWidget();

    // @brief: get the form's default font
    FGUI::FONT GetFont();

    // @brief: return true if the form has the flag we're looking for
    // @params: FGUI::WIDGET_FLAG flag = widget flag
    bool GetFlags(FGUI::WIDGET_FLAG flags);

    // @brief: get the current position of the form
    FGUI::POINT GetPosition();

    // @brief: get the form default size
    FGUI::DIMENSION GetSize();

  protected:
    // @brief: populate form geometry (draw form)
    void Geometry();

    // @brief: handle update operations on the form
    void Update();

    // @brief: handles form movement
    void Movement();

  private:
    bool m_bIsOpened;
    bool m_bIsDragging;
    bool m_bIsFocusingOnWidget;
    int m_iKey;
    int m_nFlags;
    std::function<void()> m_fnctCallback;
    std::shared_ptr<FGUI::CTabs> m_pSelectedTab;
    std::shared_ptr<FGUI::CWidgets> m_pFocusedWidget;
    std::vector<std::shared_ptr<FGUI::CTabs>> m_prgpTabs;
    std::vector<std::shared_ptr<FGUI::CForm>> m_prgpForms;
    std::string m_strTitle;
    FGUI::POINT m_ptPosition;
    FGUI::DIMENSION m_dmSize;
    FGUI::FONT m_ulFont;
  };

} // namespace FGUI

#endif // FGUI_FORM_HH
```

`Lumina/Lumina/ui/fgui_/widgets/groupbox.cpp`:

```cpp
//
// FGUI - feature rich graphical user interface
//

// library includes
#include "groupbox.hpp"

#include "../../menu.h"
#include "../../render.h"

namespace FGUI
{

CGroupBox::CGroupBox()
{
  m_strTitle = "GroupBox";
  m_ulFont = 0;
  m_bScrollBarState = false;
  m_iWidgetPositionOffset = 0;
  m_nType = static_cast<int>(WIDGET_TYPE::GROUPBOX);
  m_nFlags = static_cast<int>(WIDGET_FLAG::DRAWABLE);
}

void CGroupBox::AddWidget(std::shared_ptr<FGUI::CWidgets> widget, std::shared_ptr<FGUI::CTabs> tab, bool padding)
{
  // configure padding
  if (padding)
  {
    widget->SetSize(m_dmSize.m_iWidth - (widget->GetPosition().m_iX * 2), widget->GetSize().m_iHeight);
  }

  // set widget position
  widget->SetPosition((m_ptPosition.m_iX + widget->GetPosition().m_iX), (m_ptPosition.m_iY + widget->GetPosition().m_iY));

  // set the parent groupbox of the widget
  widget->m_pParentGroupBox = shared_from_this();

  // add widget inside the tab container
  tab->AddWidget(widget);

  // populate temporary container with all widgets inside the current groupbox
  m_prgpGroupBoxWidgets.emplace_back(widget);
}

void CGroupBox::SetScrollbarState(bool state)
{
  m_bScrollBarState = state;
}

bool CGroupBox::GetScrollbarState()
{
  return m_bScrollBarState;
}

int CGroupBox::GetScrollOffset()
{
  return m_iWidgetPositionOffset;
}

void CGroupBox::Geometry()
{
  // widget's area
  FGUI::AREA arWidgetRegion = { GetAbsolutePosition().m_iX, GetAbsolutePosition().m_iY, m_dmSize.m_iWidth, m_dmSize.m_iHeight};

  /*
  // widget's title text size
  FGUI::DIMENSION dmTitleTextSize = FGUI::RENDER.GetTextSize(m_ulFont, m_strTitle);

  // groupbox body
  FGUI::RENDER.Rectangle(arWidgetRegion.m_iLeft, arWidgetRegion.m_iTop, 5, 1, {220, 220, 200}); // top1
  FGUI::RENDER.Rectangle((arWidgetRegion.m_iLeft + dmTitleTextSize.m_iWidth) + 10, arWidgetRegion.m_iTop, (arWidgetRegion.m_iRight - dmTitleTextSize.m_iWidth) - 10, 1, {220, 220, 200}); // top2
  FGUI::RENDER.Rectangle(arWidgetRegion.m_iLeft, arWidgetRegion.m_iTop, 1, arWidgetRegion.m_iBottom, {220, 220, 220}); // left
  FGUI::RENDER.Rectangle((arWidgetRegion.m_iLeft + arWidgetRegion.m_iRight), arWidgetRegion.m_iTop, 1, arWidgetRegion.m_iBottom, {220, 220, 220}); // right
  FGUI::RENDER.Rectangle(arWidgetRegion.m_iLeft, (arWidgetRegion.m_iTop + arWidgetRegion.m_iBottom), arWidgetRegion.m_iRight, 1, {220, 220, 220}); // bottom
  FGUI::RENDER.Rectangle((arWidgetRegion.m_iLeft + 1), (arWidgetRegion.m_iTop + 1), (arWidgetRegion.m_iRight - 2), (arWidgetRegion.m_iBottom - 2), {245, 245, 245}); // background

  // groupbox label
  FGUI::RENDER.Text((arWidgetRegion.m_iLeft + 10), arWidgetRegion.m_iTop - (dmTitleTextSize.m_iHeight / 2), m_ulFont, {35, 35, 35}, m_strTitle);
	*/

  render::drawRectangle(arWidgetRegion.m_iLeft, arWidgetRegion.m_iTop, m_dmSize.m_iWidth, m_dmSize.m_iHeight, menu::highContrast);
  render::drawRectangle(arWidgetRegion.m_iLeft + menu::lineSize, arWidgetRegion.m_iTop + menu::lineSize, m_dmSize.m_iWidth - (menu::lineSize * 2), m_dmSize.m_iHeight - (menu::lineSize * 2), menu::highContrast);


  if (m_bScrollBarState)
  {
    // scrollbar area
    FGUI::AREA arScrollBarRegion = { (arWidgetRegion.m_iLeft + arWidgetRegion.m_iRight) - 15, arWidgetRegion.m_iTop, 15, m_dmSize.m_iHeight };

    static constexpr FGUI::DIMENSION dmScrollBarThumbWidth = { 8, 5 };

    // scrollbar thumb size
    float flScrollbarThumbSize = (m_dmSize.m_iHeight / static_cast<float>(m_prgpGroupBoxWidgets.back()->GetPosition().m_iY)) * static_cast<float>((m_dmSize.m_iHeight - m_prgpGroupBoxWidgets.back()->GetSize().m_iHeight));

    // calculate the scrollbar slider position
    float flScrollbarThumbPosition = (m_dmSize.m_iHeight - flScrollbarThumbSize) * static_cast<float>(m_iWidgetPositionOffset / 
      static_cast<float>((m_prgpGroupBoxWidgets.back()->GetPosition().m_iY + m_prgpGroupBoxWidgets.back()->GetSize().m_iHeight) - (m_dmSize.m_iHeight - 5)));

    // scrollbar body
    FGUI::RENDER.Rectangle(arScrollBarRegion.m_iLeft, arScrollBarRegion.m_iTop, arScrollBarRegion.m_iRight, arScrollBarRegion.m_iBottom, { 235, 235, 235 });

    // scrollbar thumb
    FGUI::RENDER.Rectangle((arScrollBarRegion.m_iLeft + 4), (arScrollBarRegion.m_iTop + flScrollbarThumbPosition) + 5, dmScrollBarThumbWidth.m_iWidth, flScrollbarThumbSize, { 220, 223, 231 });
  }
}

void CGroupBox::Update()
{
  // widget's area
  FGUI::AREA arWidgetRegion = { GetAbsolutePosition().m_iX, GetAbsolutePosition().m_iY, m_dmSize.m_iWidth, m_dmSize.m_iHeight };

  // scrollbar area
  FGUI::AREA arScrollBarRegion = { (arWidgetRegion.m_iLeft + arWidgetRegion.m_iRight) - 15, arWidgetRegion.m_iTop, 15, m_dmSize.m_iHeight };

  // check if the user is hovering the groupbox
  if (FGUI::INPUT.IsCursorInArea(arWidgetRegion))
  {
    for (const std::shared_ptr<FGUI::CWidgets>& pWidgets : m_pParentForm->m_pSelectedTab->m_prgpWidgets)
    {
      // current groupbox
      std::shared_ptr<FGUI::CGroupBox> pCurrentGroupBox = nullptr;

      if (pWidgets->GetType() != static_cast<int>(WIDGET_TYPE::GROUPBOX))
      {
        pCurrentGroupBox = pWidgets->m_pParentGroupBox ? std::reinterpret_pointer_cast<FGUI::CGroupBox>(pWidgets->m_pParentGroupBox) : nullptr;
      }

      if (pCurrentGroupBox)
      {
        if (pCurrentGroupBox->GetScrollbarState())
        {
          static bool bIsDraggingThumb = false;

          if (FGUI::INPUT.IsCursorInArea(arScrollBarRegion))
          {
            if (FGUI::INPUT.GetKeyPress(MOUSE_1))
            {
              bIsDraggingThumb = true;
            }
          }

          if (bIsDraggingThumb)
          {
            FGUI::POINT ptCursorPosDelta = FGUI::INPUT.GetCursorPosDelta();

            if (FGUI::INPUT.GetKeyState(MOUSE_1))
            {
              m_iWidgetPositionOffset += (ptCursorPosDelta.m_iY / 7);
            }
            else
            {
              bIsDraggingThumb = false;
            }

            m_pParentForm->SetFocusedWidget(nullptr);
          }

          // clamp scrolling
          m_iWidgetPositionOffset = std::clamp(m_iWidgetPositionOffset, 0, std::max(0, ((m_prgpGroupBoxWidgets.back()->GetPosition().m_iY + m_prgpGroupBoxWidgets.back()->GetSize().m_iHeight)) - (m_dmSize.m_iHeight + 5)));
        }
      }
    }
  }
}

void CGroupBox::Input()
{
}

} // namespace FGUI
```

`Lumina/Lumina/ui/fgui_/widgets/groupbox.hpp`:

```hpp
//
// FGUI - feature rich graphical user interface
//

#ifndef FGUI_GROUPBOX_HH
#define FGUI_GROUPBOX_HH

// includes
#include <memory>

// library includes
#include "widgets.hpp"

namespace FGUI
{

class CTabs;

class CGroupBox : public FGUI::CWidgets
{
public:
  CGroupBox();

  // @brief: add a new widget inside the groupbox
  // @params: std::shared_ptr<FGUI::CWidgets> widget = widget
  // std::shared_ptr<FGUI::CTabs> tab = tab that the widget will be added
  // bool padding = enable/disable padding
  void AddWidget(std::shared_ptr<FGUI::CWidgets> widget, std::shared_ptr<FGUI::CTabs> tab, bool padding = true);

  // @brief: enables/disabled groupbox scrollbar
  // @params: bool state = scrollbar state (on/off)
  void SetScrollbarState(bool state);

  // @brief: gets the state of the scrollbar, if it's enabled or not
  bool GetScrollbarState();

  // @brief: get the scrolling offset
  int GetScrollOffset();

  // @brief: populate widget geometry (draw widget)
  void Geometry() override;

  // @brief: handle update operations on the widget
  void Update() override;

  // @brief: handle input inside the widget
  void Input() override;

private:
  int m_iWidgetPositionOffset;
  bool m_bScrollBarState;
  std::vector<std::shared_ptr<FGUI::CWidgets>> m_prgpGroupBoxWidgets;
};
} // namespace FGUI

#endif // FGUI_GROUPBOX_HH
```

`Lumina/Lumina/ui/fgui_/widgets/keybinder.cpp`:

```cpp
//
// FGUI - feature rich graphical user interface
//

// library includes
#include "keybinder.hpp"

namespace FGUI
{

CKeyBinder::CKeyBinder()
{
  m_strTitle = "KeyBinder";
  m_ulFont = 0;
  m_dmSize = {150, 20};
  m_uiKey = 0;
  m_strStatus = "None";
  m_bIsGettingKey = false;
  m_nType = static_cast<int>(WIDGET_TYPE::KEYBINDER);
  m_nFlags = static_cast<int>(WIDGET_FLAG::DRAWABLE) | static_cast<int>(WIDGET_FLAG::CLICKABLE);
}

void CKeyBinder::SetKey(unsigned int key_code)
{
  m_uiKey = key_code;
}

unsigned int CKeyBinder::GetKey()
{
  return m_uiKey;
}

void CKeyBinder::Geometry()
{
  // widget's area
  FGUI::AREA arWidgetRegion = { GetAbsolutePosition().m_iX, GetAbsolutePosition().m_iY, m_dmSize.m_iWidth, m_dmSize.m_iHeight};

  // widget's title text size
  FGUI::DIMENSION dmTitleTextSize = FGUI::RENDER.GetTextSize(m_ulFont, m_strTitle);

  // keybinder body
  if (FGUI::INPUT.IsCursorInArea(arWidgetRegion) || m_bIsGettingKey)
  {
    FGUI::RENDER.Outline(arWidgetRegion.m_iLeft, arWidgetRegion.m_iTop, arWidgetRegion.m_iRight, arWidgetRegion.m_iBottom, {195, 195, 195});
    FGUI::RENDER.Rectangle((arWidgetRegion.m_iLeft + 1), (arWidgetRegion.m_iTop + 1), (arWidgetRegion.m_iRight - 2), (arWidgetRegion.m_iBottom - 2), {255, 255, 235});
  }
  else
  {
    FGUI::RENDER.Outline(arWidgetRegion.m_iLeft, arWidgetRegion.m_iTop, arWidgetRegion.m_iRight, arWidgetRegion.m_iBottom, {220, 220, 220});
    FGUI::RENDER.Rectangle((arWidgetRegion.m_iLeft + 1), (arWidgetRegion.m_iTop + 1), (arWidgetRegion.m_iRight - 2), (arWidgetRegion.m_iBottom - 2), {255, 255, 255});
  }

  // keybinder label
  FGUI::RENDER.Text((arWidgetRegion.m_iLeft + 10), arWidgetRegion.m_iTop + (arWidgetRegion.m_iBottom / 2) - (dmTitleTextSize.m_iHeight / 2), m_ulFont, {35, 35, 35}, m_strTitle + ":");

  // keybinder current key
  FGUI::RENDER.Text(arWidgetRegion.m_iLeft + (dmTitleTextSize.m_iWidth + 20), arWidgetRegion.m_iTop + (arWidgetRegion.m_iBottom / 2) - (dmTitleTextSize.m_iHeight / 2), m_ulFont, {35, 35, 35}, m_strStatus);
}

void CKeyBinder::Update()
{
  if (m_bIsGettingKey)
  {
    for (std::size_t key = 0; key < 256; key++)
    { 
      // if the user has pressed a valid key
      if (FGUI::INPUT.GetKeyPress(key))
      { 
        // if the user press ESCAPE
        if (key == KEY_ESCAPE)
        { 
          // change the key to an invalid key
          m_uiKey = 0;

          // reset status
          m_strStatus = "None";

          // block keybinder
          m_bIsGettingKey = false;
        }
        else // iterate the rest of the keys
        { 
          // set key 
          m_uiKey = key;

          // change status to currently pressed key
          // m_strStatus = m_kcCodes.m_strInputSystem[key].data(); // TODO: make a function to let users select which type of "input system" they want
          m_strStatus = m_kcCodes.m_strVirtualKeyCodes[key].data();

          // block keybinder from receiving input
          m_bIsGettingKey = false;
        } 
      }
    }
  }
}

void CKeyBinder::Input()
{
  // widget's area
  FGUI::AREA arWidgetRegion = { GetAbsolutePosition().m_iX, GetAbsolutePosition().m_iY, m_dmSize.m_iWidth, m_dmSize.m_iHeight};

  if (FGUI::INPUT.IsCursorInArea(arWidgetRegion))
  {
    m_bIsGettingKey = !m_bIsGettingKey;
  }
}

} // namespace FGUI
```

`Lumina/Lumina/ui/fgui_/widgets/keybinder.hpp`:

```hpp
//
// FGUI - feature rich graphical user interface
//

#ifndef FGUI_KEYBINDER_HH
#define FGUI_KEYBINDER_HH

// library includes
#include "widgets.hpp"

namespace FGUI
{

class CKeyBinder : public FGUI::CWidgets
{
public:
  CKeyBinder();

  // @brief: set a custom key for the keybinder
  // @params: unsigned int key = custom key code
  void SetKey(unsigned int key_code);

  // @brief: get the current key set on the keybinder
  unsigned int GetKey();

  // @brief: populate widget geometry (draw widget)
  void Geometry() override;

  // @brief: handle update operations on the widget
  void Update() override;

  // @brief: handle input inside the widget
  void Input() override;
private:
 unsigned int m_uiKey;
 std::string m_strStatus;
 bool m_bIsGettingKey;
 FGUI::KEY_CODES m_kcCodes;
};

} // namespace FGUI

#endif // FGUI_KEYBINDER_HH
```

`Lumina/Lumina/ui/fgui_/widgets/label.cpp`:

```cpp
//
// FGUI - feature rich graphical user interface
//

// library includes
#include "label.hpp"

namespace FGUI
{

CLabel::CLabel()
{
  m_strTitle = "Label";
  m_ulFont = 0;
  m_fnctCallback = nullptr;
  m_clrLabel = {180, 25, 25};
  m_nStyle = static_cast<int>(LABEL_STYLE::NORMAL);
  m_nType = static_cast<int>(WIDGET_TYPE::LABEL);
  m_nFlags = static_cast<int>(WIDGET_FLAG::DRAWABLE) | static_cast<int>(WIDGET_FLAG::CLICKABLE);
}

void CLabel::AddCallback(std::function<void()> callback)
{
  m_fnctCallback = callback;
}

void CLabel::SetStyle(FGUI::LABEL_STYLE style)
{
  m_nStyle = static_cast<int>(style);
}

void CLabel::SetColor(FGUI::COLOR color)
{
  if (m_nStyle == static_cast<int>(LABEL_STYLE::COLORED))
  {
    m_clrLabel = color;
  }
}

FGUI::COLOR CLabel::GetColor()
{
  return m_clrLabel;
}

int CLabel::GetStyle()
{
  return m_nStyle;
}

void CLabel::Geometry()
{
  // widget's title text size
  FGUI::DIMENSION dmTitleTextSize = FGUI::RENDER.GetTextSize(m_ulFont, m_strTitle);

  // widget's area
  FGUI::AREA arWidgetRegion = { GetAbsolutePosition().m_iX, GetAbsolutePosition().m_iY, dmTitleTextSize.m_iWidth, dmTitleTextSize.m_iHeight};

  // label body
  if (m_nStyle == static_cast<int>(LABEL_STYLE::NORMAL))
  {
    FGUI::RENDER.Text(arWidgetRegion.m_iLeft, arWidgetRegion.m_iTop, m_ulFont, {35, 35, 35}, m_strTitle);
  }

  else if (m_nStyle == static_cast<int>(LABEL_STYLE::COLORED))
  {
    FGUI::RENDER.Text(arWidgetRegion.m_iLeft, arWidgetRegion.m_iTop, m_ulFont, m_clrLabel, m_strTitle);
  }

  else if (m_nStyle == static_cast<int>(LABEL_STYLE::LINK))
  {
    FGUI::RENDER.Text(arWidgetRegion.m_iLeft, arWidgetRegion.m_iTop, m_ulFont, {25, 25, 215}, m_strTitle);
    FGUI::RENDER.Rectangle(arWidgetRegion.m_iLeft, (arWidgetRegion.m_iTop + arWidgetRegion.m_iBottom) + 1, arWidgetRegion.m_iRight, 1, {25, 25, 255});
  }
}

void CLabel::Update()
{
  // widget's title text size
  FGUI::DIMENSION dmTitleTextSize = FGUI::RENDER.GetTextSize(m_ulFont, m_strTitle);

  // widget's area
  FGUI::AREA arWidgetRegion = { GetAbsolutePosition().m_iX, GetAbsolutePosition().m_iY, dmTitleTextSize.m_iWidth, dmTitleTextSize.m_iHeight};

  // check if the label is a link
  if (m_nStyle == static_cast<int>(LABEL_STYLE::LINK))
  {
    if (FGUI::INPUT.IsCursorInArea(arWidgetRegion))
    {
      if (FGUI::INPUT.GetKeyPress(MOUSE_1))
      {
        if (m_fnctCallback)
        {
          // call function
          m_fnctCallback();
        }
      }
    }
  }
}

void CLabel::Input()
{
}

} // namespace FGUI
```

`Lumina/Lumina/ui/fgui_/widgets/label.hpp`:

```hpp
//
// FGUI - feature rich graphical user interface
//

#ifndef FGUI_LABEL_HH
#define FGUI_LABEL_HH

// includes
#include <string>
#include <functional>

// library includes
#include "widgets.hpp"

namespace FGUI
{

using LABEL_STYLE = enum struct ESLabelStyle_t : int {
  NORMAL = 1,
  COLORED,
  LINK,
};

class CLabel : public FGUI::CWidgets
{
public:
  CLabel();

  // @brief: adds a function callback for the label (it will call the function whenever the user clicks on the label)
  // @params: std::function<void()> callback = function instance
  void AddCallback(std::function<void()> callback);

  // @brief: set the label style (NORMAL = it will draw a normal label; COLORED = it will draw a colored label; LINK = it will draw a clickable label)
  // @params: FGUI::MULTIBOX_STYLE style = multibox style (type)
  void SetStyle(FGUI::LABEL_STYLE style);

  // @brief: set the label color (it only works for colored label type)
  // @params: FGUI::COLOR color = label custom color
  void SetColor(FGUI::COLOR color);

  // @brief: return the current color of the label
  FGUI::COLOR GetColor();

  // @brief: returns the current style of the label
  int GetStyle();

  // @brief: populate widget geometry (draw widget)
  void Geometry() override;

  // @brief: handle update operations on the widget
  void Update() override;

  // @brief: handle input inside the widget
  void Input() override;

private:
  int m_nStyle;
  FGUI::COLOR m_clrLabel;
  std::function<void()> m_fnctCallback;
};

} // namespace FGUI

#endif // FGUI_LABEL_HH
```

`Lumina/Lumina/ui/fgui_/widgets/listbox.cpp`:

```cpp
//
// FGUI - feature rich graphical user interface
//

// library includes
#include "listbox.hpp"

namespace FGUI
{

CListBox::CListBox()
{
  m_strTitle = "ListBox";
  m_ulFont = 0;
  m_iEntrySpacing = 20;
  m_uiSelectedEntry = 0;
  m_iScrollThumbPosition = 0;
  m_fnctCallback = nullptr;
  m_prgpEntries = {};
  m_nType = static_cast<int>(WIDGET_TYPE::LISTBOX);
  m_nFlags = static_cast<int>(WIDGET_FLAG::DRAWABLE) | static_cast<int>(WIDGET_FLAG::CLICKABLE);
}

void CListBox::SetIndex(std::size_t index)
{
  m_uiSelectedEntry = index;
}

std::size_t CListBox::GetIndex()
{
  return m_uiSelectedEntry;
}

int CListBox::GetValue()
{
  return m_prgpEntries.second[m_uiSelectedEntry];
}

void CListBox::AddEntry(std::string name, unsigned int value)
{
  m_prgpEntries.first.emplace_back(name);
  m_prgpEntries.second.emplace_back(value);
}

void CListBox::AddCallback(std::function<void()> callback)
{
  m_fnctCallback = callback;
}

void CListBox::Geometry()
{
  // widget's area
  FGUI::AREA arWidgetRegion = { GetAbsolutePosition().m_iX, GetAbsolutePosition().m_iY, m_dmSize.m_iWidth, m_dmSize.m_iHeight};

  // scrollbar area
  FGUI::AREA arScrollBarRegion = {(arWidgetRegion.m_iLeft + arWidgetRegion.m_iRight) - 15, arWidgetRegion.m_iTop, 15, m_dmSize.m_iHeight};

  // widget's title text size
  FGUI::DIMENSION dmTitleTextSize = FGUI::RENDER.GetTextSize(m_ulFont, m_strTitle);

  // entries displayed
  int iEntriesDisplayed = 0;

  // calculate the amount of entries that will be drawn on the listbox
  int iCalculatedEntries = (m_dmSize.m_iHeight / m_iEntrySpacing);

  // listbox body
  FGUI::RENDER.Outline(arWidgetRegion.m_iLeft, arWidgetRegion.m_iTop + (iEntriesDisplayed * m_iEntrySpacing), m_dmSize.m_iWidth, m_dmSize.m_iHeight, {220, 220, 220});
  FGUI::RENDER.Rectangle((arWidgetRegion.m_iLeft + 1), (arWidgetRegion.m_iTop + (iEntriesDisplayed * m_iEntrySpacing)) + 1, (m_dmSize.m_iWidth - 2), (m_dmSize.m_iHeight - 2), {255, 255, 255});

  // listbox label
  FGUI::RENDER.Text(arWidgetRegion.m_iLeft, (arWidgetRegion.m_iTop - dmTitleTextSize.m_iHeight) - 2, m_ulFont, {35, 35, 35}, m_strTitle);

  // listbox entries
  for (std::size_t i = m_iScrollThumbPosition; (i < m_prgpEntries.first.size()) && (iEntriesDisplayed < iCalculatedEntries); i++)
  {
    // entry area
    FGUI::AREA arEntryRegion = {arWidgetRegion.m_iLeft, arWidgetRegion.m_iTop + (m_iEntrySpacing * iEntriesDisplayed), (arWidgetRegion.m_iRight - arScrollBarRegion.m_iRight), m_iEntrySpacing};

    // check if the user is hovering something on the listbox
    if (FGUI::INPUT.IsCursorInArea(arEntryRegion))
    {
      FGUI::RENDER.Rectangle(arEntryRegion.m_iLeft, arEntryRegion.m_iTop, arEntryRegion.m_iRight, arEntryRegion.m_iBottom, {255, 255, 235});
      FGUI::RENDER.Rectangle(arEntryRegion.m_iLeft, (arEntryRegion.m_iTop + arEntryRegion.m_iBottom) - 1, arEntryRegion.m_iRight, 1, {205, 205, 205});
      FGUI::RENDER.Text((arEntryRegion.m_iLeft + 5), (arEntryRegion.m_iTop + 3), m_ulFont, {35, 35, 35}, m_prgpEntries.first[i]);
    }
    else
    {
      FGUI::RENDER.Rectangle(arEntryRegion.m_iLeft, (arEntryRegion.m_iTop + arEntryRegion.m_iBottom) - 1, arEntryRegion.m_iRight, 1, {205, 205, 205});
      FGUI::RENDER.Text((arEntryRegion.m_iLeft + 5), (arEntryRegion.m_iTop + 3), m_ulFont, {35, 35, 35}, m_prgpEntries.first[i]);
    }

    // if the user selects an entry on the listbox
    if (m_uiSelectedEntry == i)
    {
      FGUI::RENDER.Rectangle(arEntryRegion.m_iLeft, arEntryRegion.m_iTop, arEntryRegion.m_iRight, arEntryRegion.m_iBottom, {25, 145, 255});
      FGUI::RENDER.Text((arEntryRegion.m_iLeft + 5), (arEntryRegion.m_iTop + 3), m_ulFont, {245, 245, 245}, m_prgpEntries.first[i]);
    }

    iEntriesDisplayed++;
  }

  // thumb properties
  static constexpr FGUI::DIMENSION dmScrollBarThumbWidth = {8, 5};

  // calculate thumb position
  float flCalculatedPosition = static_cast<float>(m_iScrollThumbPosition) / static_cast<float>(m_prgpEntries.first.size());

  if (flCalculatedPosition >= 1.f)
  {
    flCalculatedPosition = 1.f;
  }

  flCalculatedPosition *= (m_dmSize.m_iHeight - m_iEntrySpacing) - 10;

  // calculate thumb size
  float flCalculatedSize = static_cast<float>(iCalculatedEntries) / static_cast<float>(m_prgpEntries.first.size());

  if (flCalculatedSize > 1.f)
  {
    flCalculatedSize = 1.f;
  }

  flCalculatedSize *= (m_dmSize.m_iHeight - m_iEntrySpacing);

  // scrollbar body
  FGUI::RENDER.Rectangle(arScrollBarRegion.m_iLeft, arScrollBarRegion.m_iTop, arScrollBarRegion.m_iRight, arScrollBarRegion.m_iBottom, {235, 235, 235});

  if (m_prgpEntries.first.size() > 50)
  {
    FGUI::RENDER.Rectangle((arScrollBarRegion.m_iLeft + 4), (arScrollBarRegion.m_iTop + flCalculatedPosition) + 5, dmScrollBarThumbWidth.m_iWidth, dmScrollBarThumbWidth.m_iHeight, {220, 223, 231});
  }
  else
  {
    FGUI::RENDER.Rectangle((arScrollBarRegion.m_iLeft + 4), (arScrollBarRegion.m_iTop + flCalculatedPosition) + 5, dmScrollBarThumbWidth.m_iWidth, flCalculatedSize, {220, 223, 231});
  }
}

void CListBox::Update()
{
  if (m_bIsDragging)
  {
    // calculate the amount of entries that will be drawn on the listbox
    int iCalculatedEntries = (m_dmSize.m_iHeight / m_iEntrySpacing);

    // cursor position
    FGUI::POINT ptCursorPos = FGUI::INPUT.GetCursorPos();

    if (FGUI::INPUT.GetKeyState(MOUSE_1))
    {
      // move thumb vertically
      ptCursorPos.m_iY -= GetAbsolutePosition().m_iY;

      // ratio of how many visible to how many are hidden
      float flVisibleRatio = static_cast<float>(iCalculatedEntries) / static_cast<float>(m_prgpEntries.first.size());
      flVisibleRatio *= (m_dmSize.m_iHeight - m_iEntrySpacing);

      // calculate height delta
      float flHeightDelta = static_cast<float>(ptCursorPos.m_iY + flVisibleRatio) - static_cast<float>(m_dmSize.m_iHeight);

      if (flHeightDelta >= 0.f)
      {
        ptCursorPos.m_iY -= flHeightDelta;
      }
      
      // new vertical position ratio
      float flNewYRatio = static_cast<float>(ptCursorPos.m_iY) / static_cast<float>(m_dmSize.m_iHeight);
      m_iScrollThumbPosition = (flNewYRatio * m_prgpEntries.first.size());

      // clamp position (don't let the user drag the scrollthumb if it reaches the "start" of the scrollbar area)
      if (m_iScrollThumbPosition <= 0)
      {
        m_iScrollThumbPosition = 0;
      }
    }
    else
    {
      m_bIsDragging = false;
    }
  }
}

void CListBox::Input()
{
  // widget's area
  FGUI::AREA arWidgetRegion = { GetAbsolutePosition().m_iX, GetAbsolutePosition().m_iY, m_dmSize.m_iWidth, m_dmSize.m_iHeight};

  // thumb properties
  static constexpr FGUI::DIMENSION dmScrollBarThumbWidth = {8, 5};

  // scrollbar area
  FGUI::AREA arScrollBarRegion = {((arWidgetRegion.m_iLeft + arWidgetRegion.m_iRight) - 15), arWidgetRegion.m_iTop, dmScrollBarThumbWidth.m_iWidth, (m_dmSize.m_iHeight - m_iEntrySpacing)};

  if (FGUI::INPUT.IsCursorInArea(arScrollBarRegion))
  {
    m_bIsDragging = true;
  }

  // entries displayed
  int iEntriesDisplayed = 0;

  // calculate the amount of entries that will be drawn on the listbox
  int iCalculatedEntries = (m_dmSize.m_iHeight / m_iEntrySpacing);

  // listbox entries
  for (std::size_t i = m_iScrollThumbPosition; (i < m_prgpEntries.first.size()) && (iEntriesDisplayed < iCalculatedEntries); i++)
  {
    // entry area
    FGUI::AREA arEntryRegion = {arWidgetRegion.m_iLeft, arWidgetRegion.m_iTop + (m_iEntrySpacing * iEntriesDisplayed), (arWidgetRegion.m_iRight - 15), m_iEntrySpacing};

    // select an entry
    if (FGUI::INPUT.IsCursorInArea(arEntryRegion))
    {
      m_uiSelectedEntry = i;
    }

    if (m_uiSelectedEntry == i)
    {
      if (m_fnctCallback)
      {
        // call function
        m_fnctCallback();
      }
    }

    iEntriesDisplayed++;
  }
}

} // namespace FGUI
```

`Lumina/Lumina/ui/fgui_/widgets/listbox.hpp`:

```hpp
//
// FGUI - feature rich graphical user interface
//

#ifndef FGUI_LISTBOX_HH
#define FGUI_LISTBOX_HH

// includes
#include <string>
#include <utility>
#include <vector>
#include <functional>

// library includes
#include "widgets.hpp"

namespace FGUI
{

class CListBox : public FGUI::CWidgets
{
public:
  CListBox();

  // @brief: set the listbox selected index
  // @params: int index = selected index (starting with 0)
  void SetIndex(std::size_t index);

  // @brief: get the listbox selected index (entry)
  std::size_t GetIndex();

  // @brief: get the listbox selected entry custom value
  int GetValue();

  // @brief: adds a new entry inside the listbox
  // @params: std::string name = entry title, unsigned int value = entry custom value
  void AddEntry(std::string name, unsigned int value = 0);

  // @brief: adds a function callback for the listbox (it will call the function whenever the user selects something on the listbox)
  // @params: std::function<void()> callback = function instance
  void AddCallback(std::function<void()> callback);

  // @brief: populate widget geometry (draw widget)
  void Geometry() override;

  // @brief: handle update operations on the widget
  void Update() override;

  // @brief: handle input inside the widget
  void Input() override;

private:
  std::size_t m_uiSelectedEntry;
  int m_iEntrySpacing;
  bool m_bIsDragging;
  int m_iScrollThumbPosition;
  std::pair<std::vector<std::string>, std::vector<int>> m_prgpEntries;
  std::function<void()> m_fnctCallback;
};

} // namespace FGUI

#endif // FGUI_LISTBOX_HH
```

`Lumina/Lumina/ui/fgui_/widgets/multibox.cpp`:

```cpp
//
// FGUI - feature rich graphical user interface
//

// library includes
#include "multibox.hpp"

namespace FGUI
{

CMultiBox::CMultiBox()
{
  m_strTitle = "MultiBox";
  m_ulFont = 0;
  m_dmSize = {150, 20};
  m_dmBackupSize = {m_dmSize};
  m_iEntrySpacing = 20;
  m_uiSelectedEntry = 0;
  m_fnctCallback = nullptr;
  m_prgpNormalEntries = {};
  m_prgpMultiEntries = {};
  m_bIsOpened = false;
  m_nStyle = static_cast<int>(MULTIBOX_STYLE::NORMAL);
  m_nType = static_cast<int>(WIDGET_TYPE::MULTIBOX);
  m_nFlags = static_cast<int>(WIDGET_FLAG::DRAWABLE) | static_cast<int>(WIDGET_FLAG::CLICKABLE) | static_cast<int>(WIDGET_FLAG::FOCUSABLE);
}

void CMultiBox::SetState(bool onoff)
{
  m_bIsOpened = onoff;
}

bool CMultiBox::GetState()
{
  return m_bIsOpened;
}

void CMultiBox::SetIndex(std::size_t index)
{
  m_uiSelectedEntry = index;
}

std::size_t CMultiBox::GetIndex()
{
  return m_uiSelectedEntry;
}

void CMultiBox::SetValue(std::size_t index, unsigned int value)
{
  if (m_nStyle == static_cast<int>(MULTIBOX_STYLE::NORMAL))
  {
    m_prgpNormalEntries.second[index] = value;
  }
  else if (m_nStyle == static_cast<int>(MULTIBOX_STYLE::MULTI))
  {
    m_prgpMultiEntries.second[index] = value;
  }
}

std::size_t CMultiBox::GetValue(std::size_t index)
{
  if (m_nStyle == static_cast<int>(MULTIBOX_STYLE::NORMAL))
  {
    return m_prgpNormalEntries.second[m_uiSelectedEntry];
  }
  else if (m_nStyle == static_cast<int>(MULTIBOX_STYLE::MULTI))
  {
    return m_prgpMultiEntries.second[index];
  }

  return {};
}

std::pair<std::vector<std::string>, std::vector<bool>> CMultiBox::GetMultiEntryInfo()
{
  return m_prgpMultiEntries;
}

void CMultiBox::SetStyle(FGUI::MULTIBOX_STYLE style)
{
  m_nStyle = static_cast<int>(style);
}

int CMultiBox::GetStyle()
{
  return m_nStyle;
}

void CMultiBox::AddEntry(std::string name, unsigned int value)
{
  if (m_nStyle == static_cast<int>(MULTIBOX_STYLE::NORMAL))
  {
    m_prgpNormalEntries.first.emplace_back(name);
    m_prgpNormalEntries.second.emplace_back(value);
  }
  else if (m_nStyle == static_cast<int>(MULTIBOX_STYLE::MULTI))
  {
    m_prgpMultiEntries.first.emplace_back(name);
    m_prgpMultiEntries.second.emplace_back(value);
  }
}

void CMultiBox::AddCallback(std::function<void()> callback)
{
  m_fnctCallback = callback;
}

void CMultiBox::Geometry()
{
  // widget's area
  FGUI::AREA arWidgetRegion = { GetAbsolutePosition().m_iX, GetAbsolutePosition().m_iY, m_dmSize.m_iWidth, m_dmBackupSize.m_iHeight};

  // widget's title text size
  FGUI::DIMENSION dmTitleTextSize = FGUI::RENDER.GetTextSize(m_ulFont, m_strTitle);

  // multibox body
  if (FGUI::INPUT.IsCursorInArea(arWidgetRegion) || m_bIsOpened)
  {
    FGUI::RENDER.Outline(arWidgetRegion.m_iLeft, arWidgetRegion.m_iTop, arWidgetRegion.m_iRight, arWidgetRegion.m_iBottom, {195, 195, 195});
    FGUI::RENDER.Rectangle((arWidgetRegion.m_iLeft + 1), (arWidgetRegion.m_iTop + 1), (arWidgetRegion.m_iRight - 2), (arWidgetRegion.m_iBottom - 2), {255, 255, 235});
  }
  else
  {
    FGUI::RENDER.Outline(arWidgetRegion.m_iLeft, arWidgetRegion.m_iTop, arWidgetRegion.m_iRight, arWidgetRegion.m_iBottom, {220, 220, 220});
    FGUI::RENDER.Rectangle((arWidgetRegion.m_iLeft + 1), (arWidgetRegion.m_iTop + 1), (arWidgetRegion.m_iRight - 2), (arWidgetRegion.m_iBottom - 2), {255, 255, 255});
  }

  // multibox label
  FGUI::RENDER.Text((arWidgetRegion.m_iLeft + 10), arWidgetRegion.m_iTop + (arWidgetRegion.m_iBottom / 2) - (dmTitleTextSize.m_iHeight / 2), m_ulFont, {35, 35, 35}, m_strTitle + ":");

  if (m_nStyle == static_cast<int>(MULTIBOX_STYLE::NORMAL))
  {
    // draw current selected entry
    FGUI::RENDER.Text(arWidgetRegion.m_iLeft + (dmTitleTextSize.m_iWidth + 20), arWidgetRegion.m_iTop + (arWidgetRegion.m_iBottom / 2) - (dmTitleTextSize.m_iHeight / 2), m_ulFont, {35, 35, 35}, m_prgpNormalEntries.first[m_uiSelectedEntry]);

    if (m_bIsOpened)
    {
      // dropdown list body
      FGUI::RENDER.Outline(arWidgetRegion.m_iLeft, (arWidgetRegion.m_iTop + 21), arWidgetRegion.m_iRight, (m_prgpNormalEntries.first.size() * m_iEntrySpacing), {121, 180, 209});
      FGUI::RENDER.Rectangle((arWidgetRegion.m_iLeft + 1), (arWidgetRegion.m_iTop + 21) + 1, (arWidgetRegion.m_iRight - 2), (m_prgpNormalEntries.first.size() * m_iEntrySpacing) - 2, {255, 255, 255});

      for (std::size_t i = 0; i < m_prgpNormalEntries.first.size(); i++)
      {
        // entry area
        FGUI::AREA arEntryRegion = {arWidgetRegion.m_iLeft, (arWidgetRegion.m_iTop + 21) + (static_cast<int>(i) * m_iEntrySpacing), arWidgetRegion.m_iRight, m_iEntrySpacing};

        // check if the user is hovering/have selected an entry
        if (FGUI::INPUT.IsCursorInArea(arEntryRegion) || m_uiSelectedEntry == i)
        {
          FGUI::RENDER.Rectangle(arEntryRegion.m_iLeft + 1, arEntryRegion.m_iTop, arEntryRegion.m_iRight - 2, arEntryRegion.m_iBottom, {25, 145, 255});
          FGUI::RENDER.Text(arEntryRegion.m_iLeft + 5, arEntryRegion.m_iTop + 2, m_ulFont, {255, 255, 255}, m_prgpNormalEntries.first[i]);
        }
        else
        {
          FGUI::RENDER.Rectangle(arEntryRegion.m_iLeft + 1, (arEntryRegion.m_iTop + arEntryRegion.m_iBottom), arEntryRegion.m_iRight - 1, 1, {205, 205, 205});
          FGUI::RENDER.Text(arEntryRegion.m_iLeft + 5, arEntryRegion.m_iTop + 2, m_ulFont, {35, 35, 35}, m_prgpNormalEntries.first[i]);
        }
      }
    }
  }

  else if (m_nStyle == static_cast<int>(MULTIBOX_STYLE::MULTI))
  {
    // string format (this needs to be initialized as an empty string)
    std::string strMultiString = "";

    for (std::size_t i = 0; i < m_prgpMultiEntries.first.size(); ++i)
    {
      // switches
      bool bHasReachedLength = strMultiString.length() > 15;
      bool bIsFirstItem = strMultiString.length() <= 0;

      if (m_prgpMultiEntries.second[i] && !bHasReachedLength)
      {
        if (!m_prgpMultiEntries.first[i].empty())
        {
          if (!bIsFirstItem)
          {
            strMultiString.append(", ");
          }

          strMultiString.append(m_prgpMultiEntries.first[i]);
        }
      }
      else if (bHasReachedLength && !bIsFirstItem)
      {
        strMultiString.append(" ...");

        break;
      }
    }

    if (strMultiString.length() <= 0)
    {
      strMultiString.assign("None");
    }

    // draw current selected entry
    FGUI::RENDER.Text(arWidgetRegion.m_iLeft + (dmTitleTextSize.m_iWidth + 20), arWidgetRegion.m_iTop + (arWidgetRegion.m_iBottom / 2) - (dmTitleTextSize.m_iHeight / 2), m_ulFont, {35, 35, 35}, strMultiString);

    if (m_bIsOpened)
    {
      // dropdown list body
      FGUI::RENDER.Outline(arWidgetRegion.m_iLeft, (arWidgetRegion.m_iTop + 21), arWidgetRegion.m_iRight, (m_prgpMultiEntries.first.size() * m_iEntrySpacing), {121, 180, 209});
      FGUI::RENDER.Rectangle((arWidgetRegion.m_iLeft + 1), (arWidgetRegion.m_iTop + 21) + 1, (arWidgetRegion.m_iRight - 2), (m_prgpMultiEntries.first.size() * m_iEntrySpacing) - 2, {255, 255, 255});

      for (std::size_t i = 0; i < m_prgpMultiEntries.first.size(); i++)
      {
        // entry area
        FGUI::AREA arEntryRegion = {arWidgetRegion.m_iLeft, (arWidgetRegion.m_iTop + 21) + (static_cast<int>(i) * m_iEntrySpacing), arWidgetRegion.m_iRight, m_iEntrySpacing};

        // check if the user is hovering/have selected an entry
        if (FGUI::INPUT.IsCursorInArea(arEntryRegion) || m_prgpMultiEntries.second[i])
        {
          FGUI::RENDER.Rectangle(arEntryRegion.m_iLeft + 1, arEntryRegion.m_iTop, arEntryRegion.m_iRight - 2, arEntryRegion.m_iBottom, {25, 145, 255});
          FGUI::RENDER.Text(arEntryRegion.m_iLeft + 5, arEntryRegion.m_iTop + 2, m_ulFont, {255, 255, 255}, m_prgpMultiEntries.first[i]);
        }
        else
        {
          FGUI::RENDER.Rectangle(arEntryRegion.m_iLeft + 1, (arEntryRegion.m_iTop + arEntryRegion.m_iBottom), arEntryRegion.m_iRight - 1, 1, {205, 205, 205});
          FGUI::RENDER.Text(arEntryRegion.m_iLeft + 5, arEntryRegion.m_iTop + 2, m_ulFont, {35, 35, 35}, m_prgpMultiEntries.first[i]);
        }
      }
    }
  }

  // multibox dropdown arrow body
  FGUI::RENDER.Rectangle((arWidgetRegion.m_iLeft + arWidgetRegion.m_iRight - 10) - 8, arWidgetRegion.m_iTop + ((arWidgetRegion.m_iBottom / 2) - 3) + 1, 8, 1, {20, 20, 20});
  FGUI::RENDER.Rectangle((arWidgetRegion.m_iLeft + arWidgetRegion.m_iRight - 10) - 7, arWidgetRegion.m_iTop + ((arWidgetRegion.m_iBottom / 2) - 3) + 2, 6, 1, {20, 20, 20});
  FGUI::RENDER.Rectangle((arWidgetRegion.m_iLeft + arWidgetRegion.m_iRight - 10) - 6, arWidgetRegion.m_iTop + ((arWidgetRegion.m_iBottom / 2) - 3) + 3, 4, 1, {20, 20, 20});
  FGUI::RENDER.Rectangle((arWidgetRegion.m_iLeft + arWidgetRegion.m_iRight - 10) - 5, arWidgetRegion.m_iTop + ((arWidgetRegion.m_iBottom / 2) - 3) + 4, 2, 1, {20, 20, 20});
}

void CMultiBox::Update()
{
  if (m_bIsOpened)
  {
    if (m_nStyle == static_cast<int>(MULTIBOX_STYLE::NORMAL))
    {
      // close dropdown list if the user clicks on something else
      if (GetParentForm()->GetFocusedWidget() != shared_from_this())
      {
        m_bIsOpened = false;
      }

      m_dmSize.m_iHeight = m_iEntrySpacing + (m_prgpNormalEntries.first.size() * m_iEntrySpacing) + 2;
    }
    else if (m_nStyle == static_cast<int>(MULTIBOX_STYLE::MULTI))
    {
      // close dropdown list if the user clicks on something else
      if (GetParentForm()->GetFocusedWidget() != shared_from_this())
      {
        GetParentForm()->SetFocusedWidget(shared_from_this());
      }

      // widget's area
      FGUI::AREA arWidgetRegion = { GetAbsolutePosition().m_iX, GetAbsolutePosition().m_iY, m_dmSize.m_iWidth, m_dmSize.m_iHeight};

      // close dropdown if the user clicks on something else
      if (!FGUI::INPUT.IsCursorInArea(arWidgetRegion))
      {
        if (FGUI::INPUT.GetKeyPress(MOUSE_1))
        {
          m_bIsOpened = false;
        }
      }

      m_dmSize.m_iHeight = m_iEntrySpacing + (m_prgpMultiEntries.first.size() * m_iEntrySpacing) + 2;
    }
  }
  else
  {
    // restore widget size
    m_dmSize.m_iHeight = m_dmBackupSize.m_iHeight;
  }
}

void CMultiBox::Input()
{
  // widget's area
  FGUI::AREA arWidgetRegion = { GetAbsolutePosition().m_iX, GetAbsolutePosition().m_iY, m_dmSize.m_iWidth, m_dmBackupSize.m_iHeight};

  // toggle dropdown list on and off
  if (FGUI::INPUT.IsCursorInArea(arWidgetRegion))
  {
    m_bIsOpened = !m_bIsOpened;
  }

  if (m_bIsOpened)
  {
    if (!FGUI::INPUT.IsCursorInArea(arWidgetRegion))
    {
      if (m_nStyle == static_cast<int>(MULTIBOX_STYLE::NORMAL))
      {
        for (std::size_t i = 0; i < m_prgpNormalEntries.first.size(); i++)
        {
          // entry area
          FGUI::AREA arEntryRegion = {arWidgetRegion.m_iLeft, (arWidgetRegion.m_iTop + 21) + (static_cast<int>(i) * m_iEntrySpacing), arWidgetRegion.m_iRight, m_iEntrySpacing};

          if (FGUI::INPUT.IsCursorInArea(arEntryRegion))
          {
            // select an entry
            m_uiSelectedEntry = i;

            if (m_uiSelectedEntry == i)
            {
              if (m_fnctCallback)
              {
                // call function
                m_fnctCallback();
              }
            }
          }
        }
      }
      else if (m_nStyle == static_cast<int>(MULTIBOX_STYLE::MULTI))
      {
        for (std::size_t i = 0; i < m_prgpMultiEntries.first.size(); i++)
        {
          // entry area
          FGUI::AREA arEntryRegion = {arWidgetRegion.m_iLeft, (arWidgetRegion.m_iTop + 21) + (static_cast<int>(i) * m_iEntrySpacing), arWidgetRegion.m_iRight, m_iEntrySpacing};

          if (FGUI::INPUT.IsCursorInArea(arEntryRegion))
          {
            // select an entry
            m_prgpMultiEntries.second[i] = !m_prgpMultiEntries.second[i];

			if (m_fnctCallback)
			{
				// call function
				m_fnctCallback();
			}
          }
        }
      }
    }
  }
}

} // namespace FGUI
```

`Lumina/Lumina/ui/fgui_/widgets/multibox.hpp`:

```hpp
//
// FGUI - feature rich graphical user interface
//

#ifndef FGUI_COMBOBOX_HH
#define FGUI_COMBOBOX_HH

// includes
#include <string>
#include <functional>
#include <utility>
#include <vector>

// library includes
#include "widgets.hpp"

namespace FGUI
{

using MULTIBOX_STYLE = enum struct ESMultiBox_Style_t : int {
  NORMAL = 1,
  MULTI
};

class CMultiBox : public FGUI::CWidgets
{
public:
  CMultiBox();

  // @brief: set the multibox state (toggle dropdown list on/off)
  // @params: bool onoff = dropdown state
  void SetState(bool onoff);

  // @brief: get the multibox state (dropdown list enabled or not)
  bool GetState();

  // @brief: set the multibox selected index
  // @params: std::size_t index = selected index (starting with 0)
  void SetIndex(std::size_t index);

  // @brief: get the multibox selected index (entry)
  std::size_t GetIndex();

  // @brief: sets a custom value to a specific entry on the dropdown
  // @params: std::size_t index = entry index, unsigned int value = custom value
  void SetValue(std::size_t index, unsigned int value);

  // @brief: get the multibox selected entry custom value or state
  // @params: std::size_t index = index of the entry that you want to get the value
  std::size_t GetValue(std::size_t index = 0);

  // @brief: get info about the multibox entries (name, value/state)
  std::pair<std::vector<std::string>, std::vector<bool>> GetMultiEntryInfo();

  // @brief: set the multibox style (NORMAL = it will select one entry at a time; MULTI = it can select multiple entries at once)
  // @params: FGUI::MULTIBOX_STYLE style = multibox style (type)
  void SetStyle(FGUI::MULTIBOX_STYLE style);

  // @brief: returns the current style of the multibox (if it's normal or multi)
  int GetStyle();

  // @brief: adds a new entry inside the multibox
  // @params: std::string name = entry title, unsigned int value = entry custom value (use true or false if you are using the 'MULTI' style)
  void AddEntry(std::string name, unsigned int value = 0);

  // @brief: adds a function callback for the multibox (it will call the function whenever the user selects something on the multibox)
  // NOTE: this is only recommended if the multibox is using the 'NORMAL' style
  // @params: std::function<void()> callback = function instance
  void AddCallback(std::function<void()> callback);

  // @brief: populate widget geometry (draw widget)
  void Geometry() override;

  // @brief: handle update operations on the widget
  void Update() override;

  // @brief: handle input inside the widget
  void Input() override;

private:
  int m_nStyle;
  bool m_bIsOpened;
  std::size_t m_uiSelectedEntry;
  int m_iEntrySpacing;
  std::pair<std::vector<std::string>, std::vector<int>> m_prgpNormalEntries;
  std::pair<std::vector<std::string>, std::vector<bool>> m_prgpMultiEntries;
  std::function<void()> m_fnctCallback;
  FGUI::DIMENSION m_dmBackupSize;
};
} // namespace FGUI

#endif // FGUI_COMBOBOX_HH
```

`Lumina/Lumina/ui/fgui_/widgets/slider.cpp`:

```cpp
//
// FGUI - feature rich graphical user interface
//

// library includes
#include "slider.hpp"

namespace FGUI
{

CSlider::CSlider()
{
  m_strTitle = "Slider";
  m_strPrefix = "";
  m_dmSize = {100, 2};
  m_dmSliderThumbSize = {8, 6};
  m_flValue = 0.f;
  m_bIsDragging = false;
  m_rngBoundaries = {0.f, 0.f};
  m_ulFont = 0;
  m_nType = static_cast<int>(WIDGET_TYPE::SLIDER);
  m_nFlags = static_cast<int>(WIDGET_FLAG::DRAWABLE) | static_cast<int>(WIDGET_FLAG::CLICKABLE);
}

void CSlider::SetValue(float value)
{
  m_flValue = value;
}

float CSlider::GetValue()
{
  return m_flValue;
}

void CSlider::SetRange(float min, float max)
{
  m_rngBoundaries.m_flMin = min;
  m_rngBoundaries.m_flMax = max;
}

void CSlider::SetPrefix(std::string prefix)
{
  m_strPrefix = prefix;
}

void CSlider::Geometry()
{
  // widget's area
  FGUI::AREA arWidgetRegion = { GetAbsolutePosition().m_iX, GetAbsolutePosition().m_iY, m_dmSize.m_iWidth, m_dmSize.m_iHeight};

  // widget's title text size
  FGUI::DIMENSION dmTitleTextSize = FGUI::RENDER.GetTextSize(m_ulFont, m_strTitle);

  // slider value text size
  FGUI::DIMENSION dmValueTextSize = FGUI::RENDER.GetTextSize(m_ulFont, std::to_string(static_cast<int>(m_flValue)) + " " + m_strPrefix);

  // slider position ratio
  float flRatio = (m_flValue - m_rngBoundaries.m_flMin) / (m_rngBoundaries.m_flMax - m_rngBoundaries.m_flMin);
  float flLocation = (flRatio * m_dmSize.m_iWidth);

  // slider body
  FGUI::RENDER.Rectangle(arWidgetRegion.m_iLeft, arWidgetRegion.m_iTop, m_dmSize.m_iWidth, m_dmSize.m_iHeight, {20, 50, 70});

  // slider thumb
  FGUI::RENDER.Rectangle((arWidgetRegion.m_iLeft + flLocation), (arWidgetRegion.m_iTop - 2), m_dmSliderThumbSize.m_iWidth, m_dmSliderThumbSize.m_iHeight, {180, 25, 25});

  // slider label & value
  FGUI::RENDER.Text(arWidgetRegion.m_iLeft, (arWidgetRegion.m_iTop - dmTitleTextSize.m_iHeight) - 2, m_ulFont, {35, 35, 35}, m_strTitle);
  FGUI::RENDER.Text((arWidgetRegion.m_iLeft + arWidgetRegion.m_iRight) - dmValueTextSize.m_iWidth, (arWidgetRegion.m_iTop - dmTitleTextSize.m_iHeight) - 2, m_ulFont, {30, 30, 30}, std::to_string(static_cast<int>(m_flValue)) + " " + m_strPrefix);
}

void CSlider::Update()
{
  // cursor position
  FGUI::POINT ptCursorPos = FGUI::INPUT.GetCursorPos();

  // custom height in pixels from the "clickable" area
  static constexpr int iCustomHeight = 15;

  // widget's area
  FGUI::AREA arWidgetRegion = { GetAbsolutePosition().m_iX, GetAbsolutePosition().m_iY, m_dmSize.m_iWidth, iCustomHeight};

  if (FGUI::INPUT.IsCursorInArea(arWidgetRegion))
  {
    if (FGUI::INPUT.GetKeyPress(MOUSE_1))
    {
      m_bIsDragging = true;
    }
  }

  // if the user is dragging the slider
  if (m_bIsDragging)
  {
    if (FGUI::INPUT.GetKeyState(MOUSE_1))
    {
      float flXPosDelta = 0.f;
      float flRatio = 0.f;

      // change slider value based on mouse movement
      flXPosDelta = (ptCursorPos.m_iX - arWidgetRegion.m_iLeft);

      // clamp thumb position
      if (flXPosDelta < 0.f)
      {
        flXPosDelta = 0.f;
      }
      else if (flXPosDelta >= m_dmSize.m_iWidth)
      {
        flXPosDelta = m_dmSize.m_iWidth;
      }

      // calculate slider ratio
      flRatio = flXPosDelta / static_cast<float>(m_dmSize.m_iWidth);

      // change slider value
      m_flValue = m_rngBoundaries.m_flMin + (m_rngBoundaries.m_flMax - m_rngBoundaries.m_flMin) * flRatio;
    }
    else
    {
      m_bIsDragging = false;
    }
  }
}

void CSlider::Input()
{
}

} // namespace FGUI
```

`Lumina/Lumina/ui/fgui_/widgets/slider.hpp`:

```hpp
//
// FGUI - feature rich graphical user interface
//

#ifndef FGUI_SLIDER_HH
#define FGUI_SLIDER_HH

// library includes
#include "widgets.hpp"

namespace FGUI
{

class CSlider : public FGUI::CWidgets
{
public:
  CSlider();

  // @brief: set a custom value for the slider
  // @params: float value = custom slider value (defaults to 0)
  void SetValue(float value);

  // @brief: get the current value from the slider
  float GetValue();

  // @brief: set the slider range (boundaries)
  // @params: float min = min value acceptable by the slider, float max = max value reachable by the slider
  void SetRange(float min, float max);

  // @brief: set a custom prefix for the slider
  // @params: std::string prefix = custom prefix (%, ms, °, etc)
  void SetPrefix(std::string prefix);

  // @brief: populate widget geometry (draw widget)
  void Geometry() override;

  // @brief: handle update operations on the widget
  void Update() override;

  // @brief: handle input inside the widget
  void Input() override;
private:
 float m_flValue;
 bool m_bIsDragging;
 std::string m_strPrefix;
 FGUI::RANGE m_rngBoundaries;
 FGUI::DIMENSION m_dmSliderThumbSize;
};

} // namespace FGUI

#endif // FGUI_SLIDER_HH
```

`Lumina/Lumina/ui/fgui_/widgets/tabs.cpp`:

```cpp
//
// FGUI - feature rich graphical user interface
//

// library includes
#include "tabs.hpp"
#include "../../../common/common.h"

namespace FGUI
{

void CTabs::SetTitle(std::string title)
{
  m_strTitle = title;
}

std::string CTabs::GetTitle()
{
  return m_strTitle;
}

void CTabs::AddWidget(std::shared_ptr<FGUI::CWidgets> widget)
{
  // assign parent form
  widget->m_pParentForm = m_pParentForm;

  // populate widget container
  m_prgpWidgets.emplace_back(widget);
}

void CTabs::SetFont(std::string family, unsigned int size, int flags, bool bold)
{
  FGUI::RENDER.CreateFont(m_ulFont, family, size, flags, bold);
}

void CTabs::SetFont(FGUI::WIDGET_FONT font)
{
  FGUI::RENDER.CreateFont(m_ulFont, font.m_strFamily, font.m_iSize, font.m_nFlags, font.m_bBold);
}

FGUI::FONT CTabs::GetFont()
{
  return m_ulFont;
}

} // namespace FGUI
```

`Lumina/Lumina/ui/fgui_/widgets/tabs.hpp`:

```hpp
//
// FGUI - feature rich graphical user interface
//

#ifndef FGUI_TABS_HH
#define FGUI_TABS_HH

// includes
#include <vector>
#include <memory>
#include <string>

// library includes
#include "widgets.hpp"
#include "../dependencies/aliases.hpp"
#include "../dependencies/definitions.hpp"

namespace FGUI
{

class CForm;
class CGroupBox;
class CWidgets;

class CTabs
{
  friend class FGUI::CForm;
  friend class FGUI::CGroupBox;
public:

  // @brief: sets a custom title for the tab
  // @params: std::string title = title of the tab
  void SetTitle(std::string title);

  // @brief: get the tab's default title
  std::string GetTitle();

  // @brief: insert a new widget inside the tab
  // @params: std::shared_ptr<FGUI::CWidgets> widget instance (pointer)
  void AddWidget(std::shared_ptr<FGUI::CWidgets> widget);

  // @brief: set the default font of the tab
  // @params: std::string family = font family name, unsigned int size = font size, int flags = font flags, bool bold = make the font bold
  void SetFont(std::string family, unsigned int size, int flags = 0x0, bool bold = false);

  // @brief: set the default font of the tab
  // @params: FGUI::WIDGET_FONT font = widget font struct
  void SetFont(FGUI::WIDGET_FONT font);

  // @brief: get the tab's default font
  FGUI::FONT GetFont();

private:
  std::string m_strTitle;
  std::shared_ptr<FGUI::CForm> m_pParentForm;
  std::vector<std::shared_ptr<FGUI::CWidgets>> m_prgpWidgets;
  FGUI::FONT m_ulFont;
};

} // namespace FGUI

#endif // FGUI_TABS_HH
```

`Lumina/Lumina/ui/fgui_/widgets/textbox.cpp`:

```cpp
//
// FGUI - feature rich graphical user interface
//

// library includes
#include "textbox.hpp"

namespace FGUI
{

CTextBox::CTextBox()
{
  m_strTitle = "TextBox";
  m_ulFont = 0;
  m_dmSize = {150, 20};
  m_strCustomText = "";
  m_iLength = 24;
  m_iInputPos = 0;
  m_bIsGettingKey = false;
  m_nType = static_cast<int>(WIDGET_TYPE::TEXTBOX);
  m_nFlags = static_cast<int>(WIDGET_FLAG::DRAWABLE) | static_cast<int>(WIDGET_FLAG::CLICKABLE);
}

void CTextBox::SetText(std::string text)
{
  m_strCustomText = text;
}

std::string CTextBox::GetText()
{
  return m_strCustomText;
}

void CTextBox::SetLength(unsigned int length)
{
  m_iLength = length;
}

void CTextBox::Geometry()
{
  // widget's area
  FGUI::AREA arWidgetRegion = { GetAbsolutePosition().m_iX, GetAbsolutePosition().m_iY, m_dmSize.m_iWidth, m_dmSize.m_iHeight};

  // widget's title text size
  FGUI::DIMENSION dmTitleTextSize = FGUI::RENDER.GetTextSize(m_ulFont, m_strTitle);

  // textbox body
  if (FGUI::INPUT.IsCursorInArea(arWidgetRegion) || m_bIsGettingKey)
  {
    FGUI::RENDER.Outline(arWidgetRegion.m_iLeft, arWidgetRegion.m_iTop, arWidgetRegion.m_iRight, arWidgetRegion.m_iBottom, {195, 195, 195});
    FGUI::RENDER.Rectangle((arWidgetRegion.m_iLeft + 1), (arWidgetRegion.m_iTop + 1), (arWidgetRegion.m_iRight - 2), (arWidgetRegion.m_iBottom - 2), {255, 255, 235});
  }
  else
  {
    FGUI::RENDER.Outline(arWidgetRegion.m_iLeft, arWidgetRegion.m_iTop, arWidgetRegion.m_iRight, arWidgetRegion.m_iBottom, {220, 220, 220});
    FGUI::RENDER.Rectangle((arWidgetRegion.m_iLeft + 1), (arWidgetRegion.m_iTop + 1), (arWidgetRegion.m_iRight - 2), (arWidgetRegion.m_iBottom - 2), {255, 255, 255});
  }

  // textbox label
  FGUI::RENDER.Text((arWidgetRegion.m_iLeft + 10), arWidgetRegion.m_iTop + (arWidgetRegion.m_iBottom / 2) - (dmTitleTextSize.m_iHeight / 2), m_ulFont, {35, 35, 35}, m_strTitle + ":");

  // textbox current text
  FGUI::RENDER.Text(arWidgetRegion.m_iLeft + (dmTitleTextSize.m_iWidth + 20), arWidgetRegion.m_iTop + (arWidgetRegion.m_iBottom / 2) - (dmTitleTextSize.m_iHeight / 2), m_ulFont, {35, 35, 35}, m_strCustomText);
}

void CTextBox::Update()
{
  // if the keybinder is listening for a new key press
  if (m_bIsGettingKey)
  {
    for (std::size_t key = 0; key < 256; key++)
    {
      // don't proceed until the user press something
      if (!FGUI::INPUT.GetKeyPress(key))
      {
        continue;
      }

      // key input
      //std::string strKeyInput = m_ksStrings.m_strInputSystem[key].data();
      std::string strKeyInput = m_ksStrings.m_strVirtualKeyCodes[key].data();

      // if the user press ESC or ENTER, stop the textbox from receiving input
      if (key == KEY_ESCAPE || key == KEY_ENTER)
      {
        // block listbox
        m_bIsGettingKey = false;
      }

      // handle upper case keys
      if (FGUI::INPUT.GetKeyState(KEY_LSHIFT) || FGUI::INPUT.GetKeyState(KEY_RSHIFT))
      {
        std::transform(strKeyInput.begin(), strKeyInput.end(), strKeyInput.begin(), ::toupper);
      }

      // insert text
      if (strKeyInput.length() == 1 && (static_cast<int>(m_strCustomText.length()) < m_iLength))
      {
        m_strCustomText.insert(m_iInputPos, strKeyInput);
        m_iInputPos++;
      }

      if (m_strCustomText.length() > 0)
      { 
        if (key == KEY_BACKSPACE && (m_iInputPos > -1))
        { 
          m_strCustomText.erase(m_iInputPos, 1);
          m_iInputPos--;

          if (m_iInputPos < 0)
          {
            m_iInputPos = 0;
          }
        }
        else if (key == KEY_DELETE)
        {
          // clear text
          m_strCustomText.clear();

          m_iInputPos = 0;
        }

        // change the current input position
        if (key == KEY_LEFT) 
        {
          m_iInputPos--;

          if (m_iInputPos < 0)
          {
            m_iInputPos = 0;
          }
        }
        else if (key == KEY_RIGHT && m_iInputPos < (static_cast<int>(m_strCustomText.length())))
        {
          m_iInputPos++;
        }
      }
    }
  }
}

void CTextBox::Input()
{
  // widget's area
  FGUI::AREA arWidgetRegion = { GetAbsolutePosition().m_iX, GetAbsolutePosition().m_iY, m_dmSize.m_iWidth, m_dmSize.m_iHeight};

  if (FGUI::INPUT.IsCursorInArea(arWidgetRegion))
  {
    m_bIsGettingKey = !m_bIsGettingKey;
  }
}

} // namespace FGUI
```

`Lumina/Lumina/ui/fgui_/widgets/textbox.hpp`:

```hpp
//
// FGUI - feature rich graphical user interface
//

#ifndef FGUI_TEXTBOX_HH
#define FGUI_TEXTBOX_HH

// includes
#include <string>
#include <algorithm>

// library includes
#include "widgets.hpp"

namespace FGUI
{

class CTextBox : public FGUI::CWidgets
{
public:
  CTextBox();

  // @brief: set a custom text for the textbox
  // @params: std::string text = custom default text
  void SetText(std::string text);

  // @brief: get the current text of the textbox
  std::string GetText();

  // @brief: set custom text length
  // @params: unsigned int length = text length (characters allowed)
  void SetLength(unsigned int length);

  // @brief: populate widget geometry (draw widget)
  void Geometry() override;

  // @brief: handle update operations on the widget
  void Update() override;

  // @brief: handle input inside the widget
  void Input() override;
private:
 std::string m_strCustomText;
 int m_iLength;
 int m_iInputPos;
 bool m_bIsGettingKey;
 FGUI::KEY_STRINGS m_ksStrings;
};

} // namespace FGUI

#endif // FGUI_TEXTBOX_HH
```

`Lumina/Lumina/ui/fgui_/widgets/widgets.cpp`:

```cpp
//
// FGUI - feature rich graphical user interface
//

// library includes
#include "widgets.hpp"
#include "listbox.hpp"
#include "multibox.hpp"
#include "checkbox.hpp"
#include "groupbox.hpp"
#include "slider.hpp"

namespace FGUI
{

void CWidgets::SetPosition(unsigned int x, unsigned int y)
{
  m_ptPosition.m_iX = x;
  m_ptPosition.m_iY = y;
}

FGUI::POINT CWidgets::GetPosition()
{
  return m_ptPosition;
}

FGUI::POINT CWidgets::GetAbsolutePosition()
{
  static FGUI::POINT ptTemporaryPosition = {0, 0};

  if (!m_pParentForm)
  {
    return {0, 0};
  }

  if (m_pParentForm)
  {
    // get the parent form's widget area
    FGUI::AREA arWidgetArea = m_pParentForm->GetWidgetArea();

    ptTemporaryPosition = { (m_ptPosition.m_iX + arWidgetArea.m_iLeft), (m_ptPosition.m_iY + arWidgetArea.m_iTop) };

    // scrolling
    if (m_pParentGroupBox && std::reinterpret_pointer_cast<FGUI::CGroupBox>(m_pParentGroupBox)->GetScrollbarState())
    {
      ptTemporaryPosition.m_iY -= std::reinterpret_pointer_cast<FGUI::CGroupBox>(m_pParentGroupBox)->GetScrollOffset();
    }
  }

  return ptTemporaryPosition;
}

void CWidgets::SetSize(unsigned int width, unsigned int height)
{
  m_dmSize.m_iWidth = width;
  m_dmSize.m_iHeight = height;
}

void CWidgets::SetSize(FGUI::DIMENSION size)
{
  m_dmSize.m_iWidth = size.m_iWidth;
  m_dmSize.m_iHeight = size.m_iHeight;
}

FGUI::DIMENSION CWidgets::GetSize()
{
  return m_dmSize;
}

void CWidgets::SetTitle(std::string title)
{
  m_strTitle = title;
}

std::string CWidgets::GetTitle()
{
  return m_strTitle;
}

void CWidgets::SetFlags(int flags)
{
  m_nFlags = flags;
}

bool CWidgets::GetFlags(FGUI::WIDGET_FLAG flags)
{
  if (m_nFlags & static_cast<int>(flags))
  {
    return true;
  }

  return false;
}

bool CWidgets::IsUnlocked()
{ 
  // if the parent form is closed or null, keep widgets locked
  if (!m_pParentForm || !m_pParentForm->GetState())
  {
    return false;
  }

  // if the widget doesn't have a medium or we have an invalid page keep it unlocked
  if (!m_pMedium || m_iPage < 0)
  {
    return true;
  }

  // otherwise, it will lock them until cetain conditions are met
  switch (m_pMedium->m_nType)
  {
  case static_cast<int>(WIDGET_TYPE::LISTBOX):
  {
    return std::reinterpret_pointer_cast<FGUI::CListBox>(m_pMedium)->GetIndex() == static_cast<std::size_t>(m_iPage);
  }
  case static_cast<int>(WIDGET_TYPE::CHECKBOX):
  {
    return std::reinterpret_pointer_cast<FGUI::CCheckBox>(m_pMedium)->GetState() == static_cast<bool>(m_iPage);
  }
  case static_cast<int>(WIDGET_TYPE::SLIDER) :
  {
    return std::reinterpret_pointer_cast<FGUI::CSlider>(m_pMedium)->GetValue() == static_cast<float>(m_iPage);
  }
  case static_cast<int>(WIDGET_TYPE::MULTIBOX):
  {
    if (std::reinterpret_pointer_cast<FGUI::CMultiBox>(m_pMedium)->GetStyle() == static_cast<int>(MULTIBOX_STYLE::NORMAL))
    {
      return std::reinterpret_pointer_cast<FGUI::CMultiBox>(m_pMedium)->GetIndex() == static_cast<std::size_t>(m_iPage);
    }
  }
  }

  return false;
}

std::shared_ptr<FGUI::CForm> CWidgets::GetParentForm()
{
  return m_pParentForm;
}

void CWidgets::SetMedium(std::shared_ptr<FGUI::CWidgets> medium, unsigned int page)
{
  m_pMedium = medium;
  m_iPage = page;
}

std::shared_ptr<FGUI::CWidgets> CWidgets::GetMedium()
{
  return m_pMedium;
}

unsigned int CWidgets::GetPage()
{
  return m_iPage;
}

int CWidgets::GetType()
{
  return m_nType;
}

void CWidgets::SetFont(std::string family, unsigned int size, bool bold, int flags)
{
  FGUI::RENDER.CreateFont(m_ulFont, family, size, flags, bold);
}

void CWidgets::SetFont(FGUI::WIDGET_FONT font)
{
  FGUI::RENDER.CreateFont(m_ulFont, font.m_strFamily, font.m_iSize, font.m_nFlags, font.m_bBold);
}

FGUI::FONT CWidgets::GetFont()
{
  return m_ulFont;
}

} // namespace FGUI
```

`Lumina/Lumina/ui/fgui_/widgets/widgets.hpp`:

```hpp
//
// FGUI - feature rich graphical user interface
//

#ifndef FGUI_WIDGETS_HH
#define FGUI_WIDGETS_HH

// includes
#include <memory>
#include <string>

// library includes
#include "form.hpp"
#include "../dependencies/aliases.hpp"
#include "../dependencies/definitions.hpp"

namespace FGUI
{

class CForm;
class CGroupBox;
class CTabs;

class CWidgets : public std::enable_shared_from_this<FGUI::CWidgets>
{
  friend class FGUI::CForm;
  friend class FGUI::CTabs;
  friend class FGUI::CGroupBox;
public:
  // @brief: set the default position of the widget
  // @params: unsigned int x, unsigned int y = pixels coordinates (on the screen)
  void SetPosition(unsigned int x, unsigned int y);

  // @brief: get the default position of the widget
  FGUI::POINT GetPosition();

  // @brief: get the widget's absolute position
  FGUI::POINT GetAbsolutePosition();

  // @brief: set the default size of the widget
  // @params: unsigned int width, unsigned int height = width and height of the menu in pixels
  void SetSize(unsigned int width, unsigned int height);

  // @brief: set the default size of the form
  // @params: FGUI::DIMENSION size = width and height of the menu in pixels
  void SetSize(FGUI::DIMENSION size);

  // @brief: get the widget default size
  FGUI::DIMENSION GetSize();

  // @brief: set the default title of the widget
  // @params: std::string title = default title of the widget
  void SetTitle(std::string title);

  // @brief: get the widget's default title
  std::string GetTitle();

  // @brief: set the widget flags
  // @params: int flags = widget default/custom flags
  void SetFlags(int flags);

  // @brief: return true if the widget has the flag we're looking for
  // @params: FGUI::WIDGET_FLAG flag = widget flag
  bool GetFlags(FGUI::WIDGET_FLAG flags);

  // @brief: checks if the widget is unlocked (can be drawned)
  bool IsUnlocked();

  // @brief: return an instance of the widget's parent form
  std::shared_ptr<FGUI::CForm> GetParentForm();

  // @brief: set the widget that will behave like a medium (controller) for the parent widget
  // @params: std::shared_ptr<FGUI::CWidgets> medium = controller (element that will control the other)
  // unsigned int page = widget page
  void SetMedium(std::shared_ptr<FGUI::CWidgets> medium, unsigned int page);

  // @brief: return an instance of the current medium (controller widget)
  std::shared_ptr<FGUI::CWidgets> GetMedium();

  // @brief: get current widget page
  unsigned int GetPage();

  // @brief: return the widget type (family)
  int GetType();

  // @brief: set the default font of the widget
  // @params: std::string family = font family name, unsigned int size = font size, bool bold = make the font bold,  int flags = font flags
  void SetFont(std::string family, unsigned int size, bool bold = false, int flags = 0x0);

  // @brief: set the default font of the widget
  // @params: FGUI::WIDGET_FONT font = widget font struct
  void SetFont(FGUI::WIDGET_FONT font);

  // @brief: get the widget's default font
  FGUI::FONT GetFont();

protected:

  // @brief: populate widget geometry (draw widget)
  virtual void Geometry() = 0;

  // @brief: handle update operations on the widget
  virtual void Update() = 0;

  // @brief: handle input inside the widget
  virtual void Input() = 0;

protected:
  int m_nFlags;
  int m_nType;
  int m_iPage;
  std::shared_ptr<FGUI::CForm> m_pParentForm;
  std::shared_ptr<FGUI::CWidgets> m_pParentGroupBox;
  std::shared_ptr<FGUI::CWidgets> m_pMedium;
  std::string m_strTitle;
  FGUI::FONT m_ulFont;
  FGUI::DIMENSION m_dmSize;
  FGUI::POINT m_ptPosition;
};

} // namespace FGUI

#endif // FGUI_WIDGETS_HH
```

`Lumina/Lumina/ui/image.cpp`:

```cpp
#include "image.h"

namespace images {

	unsigned char logoData[29664] = {
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xF8, 0xF8, 0xF8, 0x00, 0xF7, 0xF7, 0xF8, 0x00,
	0xF6, 0xF6, 0xF6, 0x00, 0xF5, 0xF4, 0xF5, 0x00, 0xF3, 0xF4, 0xF3, 0x00,
	0xF2, 0xF3, 0xF2, 0x00, 0xF1, 0xF1, 0xF1, 0x00, 0xEF, 0xEF, 0xEF, 0x00,
	0xEE, 0xEE, 0xEE, 0x00, 0xEC, 0xEC, 0xEC, 0x1C, 0xEB, 0xEB, 0xEB, 0x60,
	0xEA, 0xE9, 0xE9, 0x9F, 0xE9, 0xE8, 0xE8, 0xBD, 0xE7, 0xE6, 0xE7, 0xA7,
	0xE5, 0xE5, 0xE5, 0x64, 0xE4, 0xE3, 0xE4, 0x1C, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xF9, 0xF9, 0xF8, 0x00, 0xF8, 0xF8, 0xF7, 0x00, 0xF6, 0xF6, 0xF6, 0x00,
	0xF5, 0xF5, 0xF4, 0x00, 0xF4, 0xF4, 0xF4, 0x00, 0xF2, 0xF2, 0xF2, 0x00,
	0xF0, 0xF1, 0xF1, 0x00, 0xEF, 0xF0, 0xEF, 0x20, 0xEF, 0xEE, 0xEE, 0x86,
	0xED, 0xED, 0xED, 0xCC, 0xEB, 0xEB, 0xEB, 0xE0, 0xEA, 0xEA, 0xEA, 0xED,
	0xE8, 0xE9, 0xE8, 0xC0, 0xE7, 0xE7, 0xE7, 0x5C, 0xE5, 0xE5, 0xE5, 0x1B,
	0xE4, 0xE4, 0xE4, 0x07, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xE8, 0xE8, 0xE8, 0x22, 0xE8, 0xE8, 0xE8, 0xFF,
	0xE7, 0xE8, 0xE8, 0xFF, 0xE7, 0xE7, 0xE7, 0xFF, 0xE7, 0xE7, 0xE7, 0xFF,
	0xE7, 0xE7, 0xE7, 0xFF, 0xE6, 0xE6, 0xE6, 0xFF, 0xE6, 0xE5, 0xE6, 0xFF,
	0xE6, 0xE5, 0xE5, 0x99, 0xE5, 0xE5, 0xE5, 0x00, 0xE5, 0xE5, 0xE5, 0x00,
	0xE5, 0xE4, 0xE4, 0x00, 0xE5, 0xE5, 0xE4, 0x00, 0xE4, 0xE4, 0xE4, 0x00,
	0xE4, 0xE3, 0xE4, 0x00, 0xE4, 0xE3, 0xE3, 0x00, 0xE3, 0xE3, 0xE3, 0x00,
	0xE3, 0xE3, 0xE3, 0x00, 0xE2, 0xE2, 0xE2, 0x00, 0xE2, 0xE2, 0xE2, 0x00,
	0xE2, 0xE2, 0xE2, 0x00, 0xE1, 0xE1, 0xE1, 0x00, 0xE1, 0xE1, 0xE1, 0x00,
	0xE1, 0xE1, 0xE0, 0x00, 0xE1, 0xE0, 0xE1, 0x00, 0xE0, 0xE0, 0xE0, 0x22,
	0xDF, 0xDF, 0xDF, 0xFF, 0xDF, 0xDF, 0xDF, 0xFF, 0xDF, 0xDF, 0xDF, 0xFF,
	0xDF, 0xDF, 0xDE, 0xFF, 0xDF, 0xDF, 0xDF, 0xFF, 0xDF, 0xDF, 0xDE, 0xFF,
	0xDE, 0xDE, 0xDE, 0xFF, 0xDE, 0xDD, 0xDD, 0x99, 0xDD, 0xDE, 0xDD, 0x00,
	0xDD, 0xDD, 0xDD, 0x00, 0xDC, 0xDD, 0xDD, 0x00, 0xDC, 0xDD, 0xDC, 0x00,
	0xDC, 0xDC, 0xDC, 0x00, 0xDC, 0xDC, 0xDC, 0x00, 0xDB, 0xDB, 0xDC, 0x00,
	0xDB, 0xDB, 0xDB, 0x99, 0xDB, 0xDB, 0xDB, 0xFF, 0xDB, 0xDA, 0xDB, 0xFF,
	0xDA, 0xDA, 0xDA, 0xFF, 0xDA, 0xDA, 0xDA, 0xFF, 0xDA, 0xDA, 0xDA, 0xFF,
	0xDA, 0xDA, 0xD9, 0xFF, 0xD9, 0xDA, 0xD9, 0xFF, 0xD9, 0xD9, 0xD9, 0x44,
	0xD8, 0xD8, 0xD8, 0x00, 0xD8, 0xD9, 0xD9, 0x00, 0xD8, 0xD8, 0xD8, 0x00,
	0xD7, 0xD8, 0xD8, 0x00, 0xD8, 0xD7, 0xD7, 0xFF, 0xD7, 0xD8, 0xD7, 0xFF,
	0xD7, 0xD7, 0xD7, 0xFF, 0xD7, 0xD7, 0xD7, 0xFF, 0xD6, 0xD6, 0xD7, 0xFF,
	0xD7, 0xD6, 0xD6, 0xFF, 0xD6, 0xD6, 0xD6, 0xFF, 0xD6, 0xD6, 0xD6, 0x88,
	0xD5, 0xD6, 0xD6, 0x00, 0xD6, 0xD5, 0xD5, 0x00, 0xD5, 0xD5, 0xD5, 0x00,
	0xD5, 0xD4, 0xD5, 0x00, 0xD5, 0xD4, 0xD5, 0x00, 0xD5, 0xD5, 0xD4, 0x00,
	0xD5, 0xD4, 0xD5, 0x00, 0xD4, 0xD4, 0xD4, 0x00, 0xD3, 0xD3, 0xD3, 0x00,
	0xD4, 0xD4, 0xD4, 0x00, 0xD3, 0xD3, 0xD3, 0x00, 0xD3, 0xD3, 0xD3, 0x00,
	0xD3, 0xD3, 0xD3, 0x55, 0xD2, 0xD2, 0xD3, 0xFF, 0xD2, 0xD2, 0xD2, 0xFF,
	0xD2, 0xD3, 0xD3, 0xFF, 0xD2, 0xD2, 0xD2, 0xFF, 0xD2, 0xD2, 0xD1, 0xFF,
	0xD2, 0xD2, 0xD1, 0xFF, 0xD2, 0xD1, 0xD2, 0xFF, 0xD2, 0xD1, 0xD1, 0x44,
	0xD1, 0xD1, 0xD1, 0x00, 0xD1, 0xD1, 0xD1, 0x00, 0xD1, 0xD1, 0xD1, 0x00,
	0xD1, 0xD1, 0xD1, 0x00, 0xD1, 0xD0, 0xD0, 0x00, 0xD0, 0xD1, 0xD0, 0xFF,
	0xD1, 0xD0, 0xD0, 0xFF, 0xD0, 0xD0, 0xD0, 0xFF, 0xD0, 0xD0, 0xD0, 0xFF,
	0xD0, 0xD0, 0xD0, 0xFF, 0xD0, 0xD0, 0xD0, 0xFF, 0xD0, 0xD0, 0xD0, 0xFF,
	0xD0, 0xD0, 0xD0, 0x77, 0xD0, 0xD0, 0xD0, 0x00, 0xD0, 0xD0, 0xD0, 0x00,
	0xD0, 0xD0, 0xD0, 0x00, 0xD0, 0xD0, 0xD0, 0x44, 0xD0, 0xD0, 0xD0, 0xFF,
	0xD0, 0xD0, 0xD0, 0xFF, 0xD0, 0xD0, 0xD0, 0xFF, 0xD0, 0xD0, 0xD0, 0xFF,
	0xD0, 0xD0, 0xD0, 0xFF, 0xD0, 0xD0, 0xD0, 0xFF, 0xD0, 0xD0, 0xD0, 0xFF,
	0xD0, 0xD0, 0xD0, 0x77, 0xD0, 0xD0, 0xD0, 0x00, 0xD0, 0xD0, 0xD0, 0x00,
	0xD0, 0xD0, 0xD0, 0x00, 0xD0, 0xD0, 0xD0, 0x00, 0xD0, 0xD0, 0xD0, 0x00,
	0xD0, 0xD0, 0xD0, 0x00, 0xD0, 0xD0, 0xD0, 0x00, 0xD0, 0xD0, 0xD0, 0x00,
	0xD0, 0xD0, 0xD0, 0x00, 0xD0, 0xD0, 0xD0, 0xFF, 0xD0, 0xD0, 0xD0, 0xFF,
	0xD0, 0xD0, 0xD0, 0xFF, 0xD0, 0xD0, 0xD0, 0xFF, 0xD0, 0xD0, 0xD0, 0xFF,
	0xD0, 0xD0, 0xD0, 0xFF, 0xD0, 0xD0, 0xD0, 0xFF, 0xD0, 0xD0, 0xD0, 0x77,
	0xD0, 0xD0, 0xD0, 0x00, 0xD0, 0xD0, 0xD0, 0x00, 0xD0, 0xD0, 0xD0, 0x00,
	0xD0, 0xD0, 0xD0, 0x00, 0xD0, 0xD0, 0xD0, 0x00, 0xD0, 0xD0, 0xD0, 0x00,
	0xD0, 0xD0, 0xD0, 0x00, 0xD0, 0xD0, 0xD0, 0x00, 0xD0, 0xD0, 0xD0, 0x00,
	0xD0, 0xD0, 0xD0, 0x00, 0xD0, 0xD0, 0xD0, 0x00, 0xD0, 0xD0, 0xD0, 0x00,
	0xD0, 0xD0, 0xD0, 0x77, 0xD0, 0xD0, 0xD0, 0xFF, 0xD0, 0xD0, 0xD0, 0xFF,
	0xD0, 0xD0, 0xD0, 0xFF, 0xD0, 0xD0, 0xD0, 0xFF, 0xD0, 0xD0, 0xD0, 0xFF,
	0xD0, 0xD0, 0xD0, 0xFF, 0xD0, 0xD0, 0xD0, 0x77, 0xD0, 0xD0, 0xD0, 0x00,
	0xD0, 0xD0, 0xD0, 0x00, 0xD0, 0xD0, 0xD0, 0x00, 0xD0, 0xD0, 0xD0, 0x00,
	0xD0, 0xD0, 0xD0, 0x00, 0xD0, 0xD0, 0xD0, 0x00, 0xD0, 0xD0, 0xD0, 0x00,
	0xD0, 0xD0, 0xD0, 0x00, 0xD0, 0xD0, 0xD0, 0x00, 0xD0, 0xD0, 0xD0, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xF8, 0xF8, 0xF8, 0x00,
	0xF7, 0xF7, 0xF8, 0x00, 0xF6, 0xF7, 0xF6, 0x00, 0xF5, 0xF5, 0xF5, 0x00,
	0xF4, 0xF4, 0xF4, 0x00, 0xF2, 0xF2, 0xF3, 0x0B, 0xF1, 0xF1, 0xF1, 0x6E,
	0xF0, 0xF0, 0xF0, 0xB5, 0xEF, 0xEF, 0xEF, 0xF0, 0xED, 0xED, 0xED, 0xFF,
	0xEB, 0xEB, 0xEB, 0xFF, 0xEA, 0xEA, 0xEA, 0xD3, 0xE8, 0xE9, 0xE8, 0x72,
	0xE7, 0xE7, 0xE7, 0x14, 0xE6, 0xE6, 0xE5, 0x00, 0xE4, 0xE4, 0xE4, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xEA, 0xEA, 0xEA, 0x22, 0xEA, 0xEA, 0xEA, 0xFF, 0xEA, 0xE9, 0xEA, 0xFF,
	0xE9, 0xE9, 0xE9, 0xFF, 0xE8, 0xE9, 0xE9, 0xFF, 0xE8, 0xE9, 0xE9, 0xFF,
	0xE8, 0xE8, 0xE8, 0xFF, 0xE8, 0xE7, 0xE8, 0xFF, 0xE7, 0xE8, 0xE8, 0x99,
	0xE7, 0xE7, 0xE7, 0x00, 0xE7, 0xE7, 0xE7, 0x00, 0xE6, 0xE7, 0xE6, 0x00,
	0xE6, 0xE6, 0xE6, 0x00, 0xE6, 0xE6, 0xE6, 0x00, 0xE6, 0xE5, 0xE5, 0x00,
	0xE5, 0xE5, 0xE5, 0x00, 0xE5, 0xE4, 0xE5, 0x00, 0xE4, 0xE4, 0xE4, 0x00,
	0xE4, 0xE4, 0xE4, 0x00, 0xE3, 0xE3, 0xE4, 0x00, 0xE3, 0xE3, 0xE4, 0x00,
	0xE3, 0xE3, 0xE3, 0x00, 0xE3, 0xE3, 0xE3, 0x00, 0xE2, 0xE2, 0xE3, 0x00,
	0xE2, 0xE2, 0xE2, 0x00, 0xE2, 0xE1, 0xE2, 0x22, 0xE1, 0xE1, 0xE2, 0xFF,
	0xE1, 0xE1, 0xE1, 0xFF, 0xE1, 0xE0, 0xE1, 0xFF, 0xE1, 0xE0, 0xE1, 0xFF,
	0xE0, 0xE0, 0xE0, 0xFF, 0xDF, 0xDF, 0xE0, 0xFF, 0xE0, 0xDF, 0xDF, 0xFF,
	0xDF, 0xDF, 0xDF, 0x99, 0xDF, 0xDF, 0xDF, 0x00, 0xDE, 0xDF, 0xDF, 0x00,
	0xDE, 0xDE, 0xDE, 0x00, 0xDD, 0xDE, 0xDE, 0x00, 0xDE, 0xDD, 0xDE, 0x00,
	0xDD, 0xDE, 0xDD, 0x00, 0xDD, 0xDD, 0xDD, 0x00, 0xDD, 0xDD, 0xDD, 0x99,
	0xDD, 0xDD, 0xDD, 0xFF, 0xDC, 0xDC, 0xDC, 0xFF, 0xDB, 0xDB, 0xDC, 0xFF,
	0xDC, 0xDC, 0xDC, 0xFF, 0xDB, 0xDB, 0xDB, 0xFF, 0xDB, 0xDB, 0xDB, 0xFF,
	0xDA, 0xDB, 0xDA, 0xFF, 0xDA, 0xDA, 0xDB, 0x44, 0xDA, 0xDA, 0xDA, 0x00,
	0xDA, 0xDA, 0xDA, 0x00, 0xDA, 0xDA, 0xD9, 0x00, 0xD9, 0xD9, 0xD9, 0x00,
	0xD9, 0xD9, 0xD9, 0xFF, 0xD8, 0xD8, 0xD8, 0xFF, 0xD9, 0xD9, 0xD8, 0xFF,
	0xD8, 0xD8, 0xD9, 0xFF, 0xD8, 0xD8, 0xD7, 0xFF, 0xD7, 0xD8, 0xD7, 0xFF,
	0xD8, 0xD7, 0xD7, 0xFF, 0xD7, 0xD7, 0xD7, 0xFF, 0xD6, 0xD7, 0xD7, 0x33,
	0xD7, 0xD6, 0xD6, 0x00, 0xD6, 0xD7, 0xD6, 0x00, 0xD6, 0xD6, 0xD6, 0x00,
	0xD6, 0xD6, 0xD5, 0x00, 0xD5, 0xD6, 0xD6, 0x00, 0xD5, 0xD5, 0xD5, 0x00,
	0xD5, 0xD5, 0xD5, 0x00, 0xD4, 0xD5, 0xD5, 0x00, 0xD5, 0xD5, 0xD5, 0x00,
	0xD4, 0xD4, 0xD5, 0x00, 0xD4, 0xD4, 0xD4, 0x11, 0xD4, 0xD4, 0xD4, 0xDD,
	0xD4, 0xD4, 0xD4, 0xFF, 0xD4, 0xD3, 0xD4, 0xFF, 0xD3, 0xD3, 0xD3, 0xFF,
	0xD3, 0xD3, 0xD3, 0xFF, 0xD3, 0xD3, 0xD2, 0xFF, 0xD2, 0xD3, 0xD2, 0xFF,
	0xD2, 0xD2, 0xD2, 0xFF, 0xD2, 0xD2, 0xD2, 0x44, 0xD2, 0xD2, 0xD2, 0x00,
	0xD1, 0xD2, 0xD2, 0x00, 0xD2, 0xD1, 0xD2, 0x00, 0xD2, 0xD2, 0xD2, 0x00,
	0xD1, 0xD1, 0xD2, 0x00, 0xD1, 0xD1, 0xD1, 0xFF, 0xD1, 0xD1, 0xD1, 0xFF,
	0xD1, 0xD1, 0xD1, 0xFF, 0xD0, 0xD1, 0xD1, 0xFF, 0xD0, 0xD0, 0xD1, 0xFF,
	0xD0, 0xD0, 0xD0, 0xFF, 0xD0, 0xD0, 0xD0, 0xFF, 0xD1, 0xD0, 0xD0, 0x77,
	0xD0, 0xD0, 0xD0, 0x00, 0xD0, 0xD0, 0xD0, 0x00, 0xD0, 0xD0, 0xD0, 0x00,
	0xD0, 0xD0, 0xD0, 0x44, 0xD0, 0xD0, 0xD0, 0xFF, 0xD0, 0xD0, 0xD0, 0xFF,
	0xD0, 0xD0, 0xCF, 0xFF, 0xD0, 0xD0, 0xD0, 0xFF, 0xD0, 0xD0, 0xD0, 0xFF,
	0xD0, 0xD0, 0xD0, 0xFF, 0xD0, 0xD0, 0xD0, 0xFF, 0xD0, 0xD0, 0xD0, 0xFF,
	0xD0, 0xD0, 0xD0, 0x33, 0xD0, 0xD0, 0xD0, 0x00, 0xD0, 0xD0, 0xD0, 0x00,
	0xD0, 0xD0, 0xD0, 0x00, 0xD0, 0xD0, 0xD0, 0x00, 0xD0, 0xD0, 0xD0, 0x00,
	0xD0, 0xD0, 0xD0, 0x00, 0xD0, 0xD0, 0xD0, 0x00, 0xD0, 0xD0, 0xD0, 0x00,
	0xD0, 0xD0, 0xD0, 0xFF, 0xD0, 0xD0, 0xD0, 0xFF, 0xD0, 0xD0, 0xD0, 0xFF,
	0xD0, 0xD0, 0xD0, 0xFF, 0xD0, 0xD0, 0xD0, 0xFF, 0xD0, 0xD0, 0xD0, 0xFF,
	0xD0, 0xD0, 0xD0, 0xFF, 0xD0, 0xD0, 0xD0, 0x77, 0xD0, 0xD0, 0xD0, 0x00,
	0xD0, 0xD0, 0xD0, 0x00, 0xD0, 0xD0, 0xD0, 0x00, 0xD0, 0xD0, 0xD0, 0x00,
	0xD0, 0xD0, 0xD0, 0x00, 0xD0, 0xD0, 0xD0, 0x00, 0xD0, 0xD0, 0xD0, 0x00,
	0xD0, 0xD0, 0xD0, 0x00, 0xD0, 0xD0, 0xD0, 0x00, 0xD0, 0xD0, 0xD0, 0x00,
	0xD0, 0xD0, 0xD0, 0x00, 0xD0, 0xD0, 0xD0, 0x00, 0xD0, 0xD0, 0xD0, 0xDD,
	0xD0, 0xD0, 0xD0, 0xFF, 0xD0, 0xD0, 0xD0, 0xFF, 0xD0, 0xD0, 0xD0, 0xFF,
	0xD0, 0xD0, 0xD0, 0xFF, 0xD0, 0xD0, 0xD0, 0xFF, 0xD0, 0xD0, 0xD0, 0xFF,
	0xD0, 0xD0, 0xD0, 0xDD, 0xD0, 0xD0, 0xD0, 0x00, 0xD0, 0xD0, 0xD0, 0x00,
	0xD0, 0xD0, 0xD0, 0x00, 0xD0, 0xD0, 0xD0, 0x00, 0xD0, 0xD0, 0xD0, 0x00,
	0xD0, 0xD0, 0xD0, 0x00, 0xD0, 0xD0, 0xD0, 0x00, 0xD0, 0xD0, 0xD0, 0x00,
	0xD0, 0xD0, 0xD0, 0x00, 0xD0, 0xD0, 0xD0, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xF9, 0xF8, 0xF8, 0x00, 0xF8, 0xF7, 0xF7, 0x00,
	0xF7, 0xF6, 0xF7, 0x00, 0xF5, 0xF5, 0xF5, 0x00, 0xF4, 0xF4, 0xF4, 0x1F,
	0xF2, 0xF2, 0xF2, 0x89, 0xF1, 0xF2, 0xF1, 0xF0, 0xF0, 0xF0, 0xF0, 0xFF,
	0xEF, 0xEE, 0xEF, 0xFF, 0xED, 0xED, 0xED, 0xFE, 0xEC, 0xEB, 0xEC, 0xE0,
	0xEA, 0xEA, 0xEA, 0x81, 0xE9, 0xE9, 0xE9, 0x20, 0xE8, 0xE8, 0xE7, 0x00,
	0xE5, 0xE6, 0xE6, 0x00, 0xE4, 0xE5, 0xE4, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xEC, 0xEC, 0xEC, 0x22,
	0xEC, 0xEB, 0xEB, 0xFF, 0xEB, 0xEB, 0xEB, 0xFF, 0xEB, 0xEB, 0xEB, 0xFF,
	0xEA, 0xEA, 0xEA, 0xFF, 0xEA, 0xEA, 0xEA, 0xFF, 0xEA, 0xE9, 0xEA, 0xFF,
	0xE9, 0xE9, 0xEA, 0xFF, 0xE9, 0xE9, 0xE9, 0x99, 0xE9, 0xE9, 0xE9, 0x00,
	0xE8, 0xE8, 0xE9, 0x00, 0xE8, 0xE8, 0xE8, 0x00, 0xE8, 0xE8, 0xE7, 0x00,
	0xE8, 0xE8, 0xE8, 0x00, 0xE8, 0xE7, 0xE7, 0x00, 0xE7, 0xE7, 0xE7, 0x00,
	0xE6, 0xE6, 0xE6, 0x00, 0xE7, 0xE6, 0xE7, 0x00, 0xE5, 0xE6, 0xE6, 0x00,
	0xE5, 0xE6, 0xE5, 0x00, 0xE5, 0xE5, 0xE5, 0x00, 0xE5, 0xE5, 0xE5, 0x00,
	0xE4, 0xE4, 0xE4, 0x00, 0xE4, 0xE4, 0xE4, 0x00, 0xE4, 0xE3, 0xE4, 0x00,
	0xE3, 0xE4, 0xE3, 0x22, 0xE3, 0xE4, 0xE3, 0xFF, 0xE2, 0xE3, 0xE3, 0xFF,
	0xE3, 0xE3, 0xE3, 0xFF, 0xE2, 0xE2, 0xE2, 0xFF, 0xE2, 0xE2, 0xE2, 0xFF,
	0xE1, 0xE2, 0xE2, 0xFF, 0xE1, 0xE1, 0xE1, 0xFF, 0xE1, 0xE1, 0xE1, 0x99,
	0xE0, 0xE1, 0xE0, 0x00, 0xE0, 0xE0, 0xE0, 0x00, 0xE0, 0xE0, 0xE0, 0x00,
	0xDF, 0xDF, 0xDF, 0x00, 0xE0, 0xDF, 0xDF, 0x00, 0xDF, 0xDF, 0xDF, 0x00,
	0xDE, 0xDE, 0xDF, 0x00, 0xDE, 0xDE, 0xDE, 0x99, 0xDE, 0xDE, 0xDE, 0xFF,
	0xDD, 0xDE, 0xDE, 0xFF, 0xDE, 0xDD, 0xDE, 0xFF, 0xDD, 0xDE, 0xDD, 0xFF,
	0xDC, 0xDD, 0xDD, 0xFF, 0xDC, 0xDD, 0xDC, 0xFF, 0xDC, 0xDC, 0xDC, 0xFF,
	0xDC, 0xDC, 0xDC, 0x44, 0xDC, 0xDB, 0xDB, 0x00, 0xDB, 0xDB, 0xDB, 0x00,
	0xDB, 0xDC, 0xDB, 0x00, 0xDB, 0xDB, 0xDA, 0x00, 0xDA, 0xDA, 0xDA, 0xFF,
	0xDB, 0xDA, 0xDA, 0xFF, 0xDA, 0xDA, 0xDA, 0xFF, 0xD9, 0xD9, 0xDA, 0xFF,
	0xD9, 0xDA, 0xD9, 0xFF, 0xD9, 0xD9, 0xD9, 0xFF, 0xD9, 0xD8, 0xD9, 0xFF,
	0xD9, 0xD9, 0xD8, 0xFF, 0xD8, 0xD9, 0xD8, 0xBB, 0xD8, 0xD8, 0xD8, 0x00,
	0xD7, 0xD7, 0xD7, 0x00, 0xD7, 0xD8, 0xD8, 0x00, 0xD7, 0xD7, 0xD7, 0x00,
	0xD7, 0xD7, 0xD7, 0x00, 0xD7, 0xD6, 0xD7, 0x00, 0xD6, 0xD7, 0xD6, 0x00,
	0xD7, 0xD6, 0xD6, 0x00, 0xD6, 0xD6, 0xD6, 0x00, 0xD5, 0xD6, 0xD6, 0x00,
	0xD5, 0xD6, 0xD5, 0x77, 0xD5, 0xD5, 0xD5, 0xFF, 0xD4, 0xD5, 0xD5, 0xFF,
	0xD5, 0xD4, 0xD4, 0xFF, 0xD5, 0xD5, 0xD4, 0xFF, 0xD4, 0xD4, 0xD4, 0xFF,
	0xD4, 0xD4, 0xD4, 0xFF, 0xD4, 0xD3, 0xD4, 0xFF, 0xD4, 0xD4, 0xD3, 0xFF,
	0xD3, 0xD4, 0xD3, 0x44, 0xD3, 0xD3, 0xD3, 0x00, 0xD3, 0xD3, 0xD3, 0x00,
	0xD2, 0xD3, 0xD3, 0x00, 0xD2, 0xD3, 0xD3, 0x00, 0xD2, 0xD2, 0xD3, 0x00,
	0xD2, 0xD2, 0xD3, 0xFF, 0xD2, 0xD2, 0xD2, 0xFF, 0xD2, 0xD2, 0xD2, 0xFF,
	0xD1, 0xD2, 0xD2, 0xFF, 0xD2, 0xD2, 0xD1, 0xFF, 0xD1, 0xD1, 0xD1, 0xFF,
	0xD1, 0xD1, 0xD1, 0xFF, 0xD1, 0xD1, 0xD1, 0x77, 0xD1, 0xD0, 0xD1, 0x00,
	0xD1, 0xD1, 0xD1, 0x00, 0xD0, 0xD0, 0xD1, 0x00, 0xD0, 0xD1, 0xD1, 0x44,
	0xD1, 0xD0, 0xD0, 0xFF, 0xD0, 0xD0, 0xD0, 0xFF, 0xD0, 0xD0, 0xD0, 0xFF,
	0xD0, 0xD0, 0xD0, 0xFF, 0xD0, 0xD0, 0xD0, 0xFF, 0xD0, 0xCF, 0xD0, 0xFF,
	0xD0, 0xD0, 0xD0, 0xFF, 0xD0, 0xD0, 0xD0, 0xFF, 0xD0, 0xD0, 0xD0, 0xCC,
	0xD0, 0xD0, 0xD0, 0x00, 0xD0, 0xD0, 0xD0, 0x00, 0xD0, 0xD0, 0xD0, 0x00,
	0xD0, 0xD0, 0xD0, 0x00, 0xD0, 0xD0, 0xD0, 0x00, 0xD0, 0xD0, 0xD0, 0x00,
	0xD0, 0xD0, 0xCF, 0x00, 0xD0, 0xD0, 0xD0, 0x00, 0xD0, 0xD0, 0xD0, 0xFF,
	0xD0, 0xD0, 0xD0, 0xFF, 0xD0, 0xD0, 0xD0, 0xFF, 0xD0, 0xD0, 0xD0, 0xFF,
	0xD0, 0xD0, 0xD0, 0xFF, 0xD0, 0xD0, 0xD0, 0xFF, 0xD0, 0xD0, 0xD0, 0xFF,
	0xD0, 0xD0, 0xD0, 0x77, 0xD0, 0xD0, 0xD0, 0x00, 0xD0, 0xD0, 0xD0, 0x00,
	0xD0, 0xD0, 0xD0, 0x00, 0xD0, 0xD0, 0xD0, 0x00, 0xD0, 0xD0, 0xD0, 0x00,
	0xD0, 0xD0, 0xD0, 0x00, 0xD0, 0xD0, 0xD0, 0x00, 0xD0, 0xD0, 0xD0, 0x00,
	0xD0, 0xD0, 0xD0, 0x00, 0xD0, 0xD0, 0xD0, 0x00, 0xD0, 0xD0, 0xD0, 0x00,
	0xD0, 0xD0, 0xD0, 0x44, 0xD0, 0xD0, 0xD0, 0xFF, 0xD0, 0xD0, 0xD0, 0xFF,
	0xD0, 0xD0, 0xD0, 0xFF, 0xD0, 0xD0, 0xD0, 0xFF, 0xD0, 0xD0, 0xD0, 0xFF,
	0xD0, 0xD0, 0xD0, 0xFF, 0xD0, 0xD0, 0xD0, 0xFF, 0xD0, 0xD0, 0xD0, 0xFF,
	0xD0, 0xD0, 0xD0, 0x44, 0xD0, 0xD0, 0xD0, 0x00, 0xD0, 0xD0, 0xD0, 0x00,
	0xD0, 0xD0, 0xD0, 0x00, 0xD0, 0xD0, 0xD0, 0x00, 0xD0, 0xD0, 0xD0, 0x00,
	0xD0, 0xD0, 0xD0, 0x00, 0xD0, 0xD0, 0xD0, 0x00, 0xD0, 0xD0, 0xD0, 0x00,
	0xD0, 0xD0, 0xD0, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xF9, 0xF8, 0xF9, 0x00, 0xF8, 0xF8, 0xF8, 0x00, 0xF7, 0xF6, 0xF6, 0x00,
	0xF6, 0xF5, 0xF5, 0x1F, 0xF4, 0xF3, 0xF4, 0x91, 0xF2, 0xF2, 0xF3, 0xFF,
	0xF2, 0xF2, 0xF2, 0xFF, 0xF0, 0xF0, 0xF0, 0xFF, 0xEE, 0xEE, 0xEF, 0xFF,
	0xEE, 0xED, 0xED, 0xF0, 0xEC, 0xEB, 0xEB, 0xA6, 0xEB, 0xEA, 0xEA, 0x44,
	0xE9, 0xE9, 0xE9, 0x00, 0xE7, 0xE8, 0xE7, 0x00, 0xE6, 0xE6, 0xE6, 0x00,
	0xE5, 0xE5, 0xE5, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xED, 0xEE, 0xEE, 0x22, 0xED, 0xED, 0xED, 0xFF,
	0xED, 0xED, 0xED, 0xFF, 0xED, 0xED, 0xEC, 0xFF, 0xED, 0xED, 0xED, 0xFF,
	0xEC, 0xEC, 0xEC, 0xFF, 0xEB, 0xEC, 0xEB, 0xFF, 0xEB, 0xEB, 0xEC, 0xFF,
	0xEB, 0xEA, 0xEB, 0x99, 0xEB, 0xEA, 0xEB, 0x00, 0xEA, 0xEA, 0xEA, 0x00,
	0xEA, 0xEA, 0xEA, 0x00, 0xEA, 0xEA, 0xE9, 0x00, 0xE9, 0xE9, 0xEA, 0x00,
	0xE9, 0xE9, 0xE9, 0x00, 0xE9, 0xE9, 0xE9, 0x00, 0xE8, 0xE9, 0xE8, 0x00,
	0xE8, 0xE7, 0xE8, 0x00, 0xE7, 0xE8, 0xE7, 0x00, 0xE7, 0xE7, 0xE7, 0x00,
	0xE7, 0xE7, 0xE7, 0x00, 0xE6, 0xE7, 0xE7, 0x00, 0xE6, 0xE6, 0xE6, 0x00,
	0xE6, 0xE6, 0xE6, 0x00, 0xE6, 0xE5, 0xE6, 0x00, 0xE5, 0xE5, 0xE5, 0x22,
	0xE5, 0xE5, 0xE5, 0xFF, 0xE5, 0xE5, 0xE5, 0xFF, 0xE4, 0xE5, 0xE4, 0xFF,
	0xE4, 0xE4, 0xE4, 0xFF, 0xE4, 0xE4, 0xE4, 0xFF, 0xE3, 0xE4, 0xE3, 0xFF,
	0xE3, 0xE3, 0xE3, 0xFF, 0xE3, 0xE3, 0xE3, 0x99, 0xE2, 0xE2, 0xE3, 0x00,
	0xE2, 0xE2, 0xE2, 0x00, 0xE2, 0xE2, 0xE1, 0x00, 0xE1, 0xE1, 0xE1, 0x00,
	0xE1, 0xE1, 0xE1, 0x00, 0xE0, 0xE0, 0xE1, 0x00, 0xE1, 0xE1, 0xE1, 0x00,
	0xE0, 0xE1, 0xE0, 0x99, 0xE0, 0xE0, 0xE0, 0xFF, 0xDF, 0xE0, 0xE0, 0xFF,
	0xDF, 0xDF, 0xDF, 0xFF, 0xDF, 0xDF, 0xDF, 0xFF, 0xDF, 0xDE, 0xDF, 0xFF,
	0xDE, 0xDF, 0xDF, 0xFF, 0xDE, 0xDE, 0xDE, 0xFF, 0xDD, 0xDD, 0xDE, 0x44,
	0xDD, 0xDD, 0xDD, 0x00, 0xDD, 0xDD, 0xDD, 0x00, 0xDC, 0xDD, 0xDD, 0x00,
	0xDC, 0xDC, 0xDC, 0x00, 0xDC, 0xDC, 0xDC, 0xFF, 0xDC, 0xDC, 0xDC, 0xFF,
	0xDC, 0xDB, 0xDB, 0xFF, 0xDB, 0xDB, 0xDB, 0xFF, 0xDB, 0xDB, 0xDB, 0xFF,
	0xDA, 0xDA, 0xDB, 0xFF, 0xDB, 0xDA, 0xDA, 0xFF, 0xDA, 0xDA, 0xDA, 0xFF,
	0xD9, 0xD9, 0xDA, 0xFF, 0xD9, 0xDA, 0xDA, 0x66, 0xD9, 0xD9, 0xDA, 0x00,
	0xD9, 0xD9, 0xD9, 0x00, 0xD8, 0xD9, 0xD8, 0x00, 0xD9, 0xD9, 0xD8, 0x00,
	0xD8, 0xD8, 0xD8, 0x00, 0xD8, 0xD8, 0xD8, 0x00, 0xD7, 0xD8, 0xD8, 0x00,
	0xD7, 0xD7, 0xD7, 0x00, 0xD7, 0xD7, 0xD7, 0x22, 0xD6, 0xD6, 0xD7, 0xFF,
	0xD7, 0xD6, 0xD7, 0xFF, 0xD6, 0xD6, 0xD6, 0xFF, 0xD6, 0xD6, 0xD5, 0xFF,
	0xD6, 0xD6, 0xD5, 0xFF, 0xD6, 0xD6, 0xD6, 0xFF, 0xD5, 0xD6, 0xD5, 0xFF,
	0xD4, 0xD5, 0xD5, 0xFF, 0xD5, 0xD5, 0xD5, 0xFF, 0xD5, 0xD4, 0xD4, 0x44,
	0xD4, 0xD4, 0xD4, 0x00, 0xD4, 0xD4, 0xD4, 0x00, 0xD4, 0xD4, 0xD4, 0x00,
	0xD4, 0xD3, 0xD3, 0x00, 0xD3, 0xD3, 0xD3, 0x00, 0xD3, 0xD3, 0xD4, 0xFF,
	0xD3, 0xD3, 0xD3, 0xFF, 0xD3, 0xD3, 0xD3, 0xFF, 0xD3, 0xD2, 0xD3, 0xFF,
	0xD2, 0xD2, 0xD2, 0xFF, 0xD2, 0xD2, 0xD2, 0xFF, 0xD2, 0xD2, 0xD2, 0xFF,
	0xD2, 0xD1, 0xD2, 0x77, 0xD2, 0xD2, 0xD1, 0x00, 0xD1, 0xD2, 0xD2, 0x00,
	0xD1, 0xD2, 0xD1, 0x00, 0xD1, 0xD1, 0xD1, 0x44, 0xD1, 0xD1, 0xD1, 0xFF,
	0xD1, 0xD0, 0xD1, 0xFF, 0xD0, 0xD0, 0xD1, 0xFF, 0xD1, 0xD0, 0xD1, 0xFF,
	0xD0, 0xD0, 0xD1, 0xFF, 0xD0, 0xD0, 0xD0, 0xFF, 0xD0, 0xD0, 0xD1, 0xFF,
	0xD0, 0xD0, 0xD0, 0xFF, 0xD0, 0xD0, 0xD0, 0xFF, 0xD0, 0xD0, 0xD0, 0x77,
	0xD0, 0xD0, 0xD0, 0x00, 0xD0, 0xD0, 0xD0, 0x00, 0xD0, 0xD0, 0xD0, 0x00,
	0xD0, 0xD0, 0xD0, 0x00, 0xD0, 0xD0, 0xD0, 0x00, 0xD0, 0xD0, 0xD0, 0x00,
	0xD0, 0xD0, 0xD0, 0x00, 0xD0, 0xD0, 0xD0, 0xFF, 0xD0, 0xD0, 0xD0, 0xFF,
	0xD0, 0xD0, 0xD0, 0xFF, 0xD0, 0xD0, 0xD0, 0xFF, 0xD0, 0xD0, 0xD0, 0xFF,
	0xD0, 0xD0, 0xD0, 0xFF, 0xD0, 0xD0, 0xD0, 0xFF, 0xD0, 0xD0, 0xD0, 0x77,
	0xD0, 0xD0, 0xCF, 0x00, 0xD0, 0xD0, 0xD0, 0x00, 0xD0, 0xD0, 0xD0, 0x00,
	0xD0, 0xD0, 0xD0, 0x00, 0xD0, 0xD0, 0xD0, 0x00, 0xD0, 0xD0, 0xD0, 0x00,
	0xD0, 0xD0, 0xD0, 0x00, 0xD0, 0xD0, 0xD0, 0x00, 0xD0, 0xCF, 0xD0, 0x00,
	0xD0, 0xD0, 0xD0, 0x00, 0xD0, 0xD0, 0xD0, 0x00, 0xD0, 0xD0, 0xD0, 0x99,
	0xD0, 0xD0, 0xD0, 0xFF, 0xD0, 0xD0, 0xD0, 0xFF, 0xD0, 0xD0, 0xD0, 0xFF,
	0xD0, 0xD0, 0xD0, 0xFF, 0xD0, 0xD0, 0xD0, 0xFF, 0xD0, 0xD0, 0xD0, 0xFF,
	0xD0, 0xD0, 0xD0, 0xFF, 0xD0, 0xD0, 0xD0, 0xFF, 0xD0, 0xD0, 0xD0, 0x99,
	0xD0, 0xD0, 0xD0, 0x00, 0xD0, 0xD0, 0xD0, 0x00, 0xD0, 0xD0, 0xD0, 0x00,
	0xD0, 0xD0, 0xD0, 0x00, 0xD0, 0xD0, 0xD0, 0x00, 0xD0, 0xD0, 0xD0, 0x00,
	0xD0, 0xD0, 0xD0, 0x00, 0xD0, 0xD0, 0xD0, 0x00, 0xD0, 0xD0, 0xD0, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xF9, 0xF9, 0xF9, 0x00,
	0xF8, 0xF8, 0xF8, 0x00, 0xF7, 0xF7, 0xF6, 0x0B, 0xF5, 0xF6, 0xF5, 0x8B,
	0xF4, 0xF4, 0xF4, 0xFF, 0xF3, 0xF3, 0xF2, 0xFF, 0xF1, 0xF1, 0xF2, 0xFF,
	0xF0, 0xF0, 0xF0, 0xFF, 0xEE, 0xEF, 0xEE, 0xFF, 0xED, 0xED, 0xEE, 0xD7,
	0xEC, 0xEC, 0xEC, 0x69, 0xEA, 0xEB, 0xEB, 0x24, 0xE9, 0xE9, 0xE9, 0x03,
	0xE7, 0xE8, 0xE8, 0x00, 0xE6, 0xE6, 0xE6, 0x00, 0xE5, 0xE5, 0xE5, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xEF, 0xEF, 0xEF, 0x22, 0xEF, 0xEF, 0xEF, 0xFF, 0xEE, 0xEE, 0xEE, 0xFF,
	0xEF, 0xEF, 0xEE, 0xFF, 0xEE, 0xEE, 0xEE, 0xFF, 0xEE, 0xEE, 0xEE, 0xFF,
	0xED, 0xED, 0xEE, 0xFF, 0xED, 0xED, 0xED, 0xFF, 0xED, 0xED, 0xED, 0x99,
	0xED, 0xED, 0xEC, 0x00, 0xEC, 0xEC, 0xEC, 0x00, 0xEB, 0xEC, 0xEC, 0x00,
	0xEB, 0xEB, 0xEB, 0x00, 0xEB, 0xEB, 0xEB, 0x00, 0xEB, 0xEA, 0xEA, 0x00,
	0xEB, 0xEA, 0xEB, 0x00, 0xEA, 0xEA, 0xEA, 0x00, 0xEA, 0xE9, 0xEA, 0x00,
	0xEA, 0xE9, 0xEA, 0x00, 0xE9, 0xE9, 0xE9, 0x00, 0xE9, 0xE9, 0xE9, 0x00,
	0xE8, 0xE8, 0xE8, 0x00, 0xE8, 0xE8, 0xE8, 0x00, 0xE8, 0xE8, 0xE7, 0x00,
	0xE7, 0xE8, 0xE7, 0x00, 0xE7, 0xE7, 0xE7, 0x22, 0xE7, 0xE7, 0xE7, 0xFF,
	0xE6, 0xE6, 0xE6, 0xFF, 0xE6, 0xE6, 0xE6, 0xFF, 0xE5, 0xE6, 0xE5, 0xFF,
	0xE5, 0xE6, 0xE6, 0xFF, 0xE5, 0xE5, 0xE5, 0xFF, 0xE4, 0xE5, 0xE5, 0xFF,
	0xE4, 0xE4, 0xE4, 0x99, 0xE4, 0xE4, 0xE4, 0x00, 0xE4, 0xE4, 0xE3, 0x00,
	0xE3, 0xE3, 0xE4, 0x00, 0xE3, 0xE3, 0xE3, 0x00, 0xE3, 0xE3, 0xE3, 0x00,
	0xE3, 0xE2, 0xE2, 0x00, 0xE3, 0xE2, 0xE2, 0x00, 0xE2, 0xE1, 0xE2, 0x99,
	0xE2, 0xE1, 0xE1, 0xFF, 0xE1, 0xE2, 0xE1, 0xFF, 0xE1, 0xE0, 0xE1, 0xFF,
	0xE1, 0xE0, 0xE0, 0xFF, 0xE0, 0xE0, 0xE0, 0xFF, 0xDF, 0xE0, 0xE0, 0xFF,
	0xE0, 0xE0, 0xE0, 0xFF, 0xDF, 0xE0, 0xDF, 0x44, 0xDF, 0xDF, 0xDE, 0x00,
	0xDE, 0xDE, 0xDF, 0x00, 0xDE, 0xDE, 0xDF, 0x00, 0xDE, 0xDE, 0xDE, 0x00,
	0xDE, 0xDE, 0xDE, 0xFF, 0xDD, 0xDD, 0xDD, 0xFF, 0xDD, 0xDD, 0xDD, 0xFF,
	0xDD, 0xDC, 0xDC, 0xFF, 0xDC, 0xDC, 0xDC, 0xFF, 0xDC, 0xDC, 0xDC, 0xFF,
	0xDC, 0xDC, 0xDC, 0xFF, 0xDC, 0xDB, 0xDC, 0xFF, 0xDB, 0xDB, 0xDB, 0xFF,
	0xDB, 0xDB, 0xDB, 0xEE, 0xDB, 0xDB, 0xDB, 0x11, 0xDA, 0xDA, 0xDA, 0x00,
	0xDA, 0xDA, 0xDA, 0x00, 0xDA, 0xDA, 0xDA, 0x00, 0xDA, 0xD9, 0xDA, 0x00,
	0xD9, 0xD9, 0xD9, 0x00, 0xD9, 0xD9, 0xD9, 0x00, 0xD9, 0xD9, 0xD8, 0x00,
	0xD9, 0xD8, 0xD9, 0xBB, 0xD8, 0xD8, 0xD8, 0xFF, 0xD8, 0xD8, 0xD8, 0xFF,
	0xD7, 0xD7, 0xD8, 0xFF, 0xD7, 0xD7, 0xD8, 0xFF, 0xD7, 0xD7, 0xD7, 0xFF,
	0xD6, 0xD7, 0xD7, 0xFF, 0xD7, 0xD6, 0xD6, 0xFF, 0xD6, 0xD7, 0xD7, 0xFF,
	0xD6, 0xD6, 0xD6, 0xFF, 0xD6, 0xD6, 0xD6, 0x44, 0xD6, 0xD6, 0xD6, 0x00,
	0xD6, 0xD5, 0xD6, 0x00, 0xD5, 0xD5, 0xD5, 0x00, 0xD5, 0xD5, 0xD5, 0x00,
	0xD4, 0xD4, 0xD5, 0x00, 0xD5, 0xD4, 0xD4, 0xFF, 0xD5, 0xD4, 0xD4, 0xFF,
	0xD4, 0xD4, 0xD4, 0xFF, 0xD4, 0xD4, 0xD4, 0xFF, 0xD3, 0xD3, 0xD4, 0xFF,
	0xD3, 0xD4, 0xD3, 0xFF, 0xD3, 0xD3, 0xD3, 0xFF, 0xD3, 0xD3, 0xD3, 0x77,
	0xD2, 0xD2, 0xD3, 0x00, 0xD3, 0xD2, 0xD2, 0x00, 0xD3, 0xD2, 0xD3, 0x00,
	0xD2, 0xD3, 0xD2, 0x44, 0xD2, 0xD2, 0xD2, 0xFF, 0xD1, 0xD2, 0xD2, 0xFF,
	0xD1, 0xD2, 0xD2, 0xFF, 0xD1, 0xD1, 0xD1, 0xFF, 0xD1, 0xD1, 0xD1, 0xFF,
	0xD1, 0xD1, 0xD1, 0xFF, 0xD1, 0xD1, 0xD1, 0xFF, 0xD1, 0xD1, 0xD1, 0xFF,
	0xD0, 0xD1, 0xD1, 0xFF, 0xD1, 0xD1, 0xD0, 0xFF, 0xD1, 0xD1, 0xD1, 0x22,
	0xD0, 0xD0, 0xD0, 0x00, 0xD0, 0xD0, 0xD0, 0x00, 0xD0, 0xD0, 0xD0, 0x00,
	0xD0, 0xD0, 0xD0, 0x00, 0xD0, 0xD0, 0xD0, 0x00, 0xD0, 0xD0, 0xD0, 0x00,
	0xD0, 0xD0, 0xD0, 0xFF, 0xD0, 0xD0, 0xD0, 0xFF, 0xD0, 0xD0, 0xD0, 0xFF,
	0xD0, 0xD0, 0xD0, 0xFF, 0xD0, 0xD0, 0xD0, 0xFF, 0xD0, 0xCF, 0xD0, 0xFF,
	0xD0, 0xD0, 0xD0, 0xFF, 0xD0, 0xD0, 0xD0, 0x77, 0xD0, 0xD0, 0xD0, 0x00,
	0xD0, 0xD0, 0xD0, 0x00, 0xD0, 0xD0, 0xD0, 0x00, 0xD0, 0xD0, 0xD0, 0x00,
	0xD0, 0xD0, 0xD0, 0x00, 0xD0, 0xD0, 0xD0, 0x00, 0xD0, 0xD0, 0xD0, 0x00,
	0xD0, 0xD0, 0xD0, 0x00, 0xD0, 0xD0, 0xD0, 0x00, 0xD0, 0xD0, 0xD0, 0x00,
	0xD0, 0xD0, 0xD0, 0x11, 0xD0, 0xD0, 0xD0, 0xEE, 0xD0, 0xD0, 0xD0, 0xFF,
	0xD0, 0xD0, 0xD0, 0xFF, 0xD0, 0xD0, 0xD0, 0xFF, 0xD0, 0xD0, 0xD0, 0xFF,
	0xD0, 0xD0, 0xD0, 0xFF, 0xD0, 0xD0, 0xD0, 0xFF, 0xD0, 0xD0, 0xD0, 0xFF,
	0xD0, 0xD0, 0xD0, 0xFF, 0xD0, 0xD0, 0xD0, 0xEE, 0xD0, 0xD0, 0xD0, 0x11,
	0xD0, 0xD0, 0xD0, 0x00, 0xD0, 0xD0, 0xD0, 0x00, 0xD0, 0xD0, 0xD0, 0x00,
	0xD0, 0xD0, 0xD0, 0x00, 0xD0, 0xD0, 0xD0, 0x00, 0xD0, 0xD0, 0xD0, 0x00,
	0xD0, 0xD0, 0xCF, 0x00, 0xD0, 0xD0, 0xD0, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xF9, 0xF8, 0xF9, 0x00, 0xF8, 0xF8, 0xF8, 0x00,
	0xF6, 0xF6, 0xF7, 0x6D, 0xF6, 0xF5, 0xF5, 0xF1, 0xF5, 0xF4, 0xF4, 0xFF,
	0xF3, 0xF3, 0xF3, 0xFF, 0xF1, 0xF1, 0xF1, 0xFF, 0xF0, 0xF0, 0xF0, 0xFF,
	0xEF, 0xEF, 0xEE, 0xFF, 0xED, 0xEE, 0xEE, 0xC4, 0xEC, 0xEC, 0xEC, 0x40,
	0xEA, 0xEB, 0xEA, 0x15, 0xE9, 0xE9, 0xE9, 0x01, 0xE8, 0xE7, 0xE8, 0x00,
	0xE6, 0xE7, 0xE6, 0x00, 0xE5, 0xE5, 0xE5, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xF1, 0xF1, 0xF1, 0x22,
	0xF1, 0xF0, 0xF1, 0xFF, 0xF1, 0xF0, 0xF1, 0xFF, 0xF0, 0xF0, 0xF0, 0xFF,
	0xF0, 0xEF, 0xEF, 0xFF, 0xF0, 0xEF, 0xEF, 0xFF, 0xEF, 0xEF, 0xEF, 0xFF,
	0xEF, 0xEE, 0xEF, 0xFF, 0xEE, 0xEE, 0xEE, 0x99, 0xEE, 0xEE, 0xEE, 0x00,
	0xED, 0xED, 0xED, 0x00, 0xED, 0xED, 0xEE, 0x00, 0xED, 0xED, 0xED, 0x00,
	0xED, 0xED, 0xED, 0x00, 0xEC, 0xEC, 0xEC, 0x00, 0xEC, 0xEC, 0xEC, 0x00,
	0xEC, 0xEC, 0xEC, 0x00, 0xEB, 0xEB, 0xEC, 0x00, 0xEB, 0xEB, 0xEB, 0x00,
	0xEA, 0xEB, 0xEA, 0x00, 0xEA, 0xEB, 0xEA, 0x00, 0xEA, 0xEA, 0xEA, 0x00,
	0xEA, 0xEA, 0xEA, 0x00, 0xE9, 0xEA, 0xE9, 0x00, 0xE9, 0xE9, 0xE9, 0x00,
	0xE9, 0xE8, 0xE8, 0x22, 0xE9, 0xE8, 0xE9, 0xFF, 0xE8, 0xE8, 0xE8, 0xFF,
	0xE8, 0xE8, 0xE8, 0xFF, 0xE8, 0xE8, 0xE7, 0xFF, 0xE7, 0xE7, 0xE7, 0xFF,
	0xE7, 0xE7, 0xE6, 0xFF, 0xE6, 0xE6, 0xE6, 0xFF, 0xE7, 0xE6, 0xE6, 0x99,
	0xE6, 0xE6, 0xE6, 0x00, 0xE5, 0xE5, 0xE5, 0x00, 0xE5, 0xE5, 0xE5, 0x00,
	0xE5, 0xE5, 0xE5, 0x00, 0xE5, 0xE4, 0xE5, 0x00, 0xE4, 0xE4, 0xE5, 0x00,
	0xE4, 0xE4, 0xE3, 0x00, 0xE3, 0xE4, 0xE3, 0x99, 0xE3, 0xE4, 0xE3, 0xFF,
	0xE3, 0xE3, 0xE3, 0xFF, 0xE2, 0xE2, 0xE2, 0xFF, 0xE2, 0xE3, 0xE2, 0xFF,
	0xE2, 0xE2, 0xE2, 0xFF, 0xE1, 0xE2, 0xE1, 0xFF, 0xE1, 0xE1, 0xE2, 0xFF,
	0xE1, 0xE1, 0xE1, 0x44, 0xE1, 0xE0, 0xE1, 0x00, 0xE0, 0xE0, 0xE0, 0x00,
	0xE0, 0xE0, 0xE0, 0x00, 0xE0, 0xE0, 0xE0, 0x00, 0xDF, 0xDF, 0xDF, 0xFF,
	0xDF, 0xDF, 0xDF, 0xFF, 0xDE, 0xDE, 0xDF, 0xFF, 0xDE, 0xDE, 0xDF, 0xFF,
	0xDE, 0xDE, 0xDE, 0xFF, 0xDE, 0xDE, 0xDE, 0xFF, 0xDE, 0xDE, 0xDD, 0xFF,
	0xDD, 0xDD, 0xDD, 0xFF, 0xDD, 0xDC, 0xDD, 0xFF, 0xDC, 0xDD, 0xDD, 0xFF,
	0xDC, 0xDC, 0xDC, 0x88, 0xDC, 0xDC, 0xDC, 0x00, 0xDB, 0xDC, 0xDC, 0x00,
	0xDB, 0xDC, 0xDB, 0x00, 0xDB, 0xDB, 0xDB, 0x00, 0xDB, 0xDB, 0xDA, 0x00,
	0xDA, 0xDB, 0xDA, 0x00, 0xDA, 0xDA, 0xDB, 0x55, 0xDA, 0xDA, 0xDA, 0xFF,
	0xDA, 0xDA, 0xDA, 0xFF, 0xD9, 0xDA, 0xD9, 0xFF, 0xD9, 0xD9, 0xD9, 0xFF,
	0xD9, 0xD8, 0xD9, 0xFF, 0xD8, 0xD8, 0xD9, 0xFF, 0xD9, 0xD8, 0xD8, 0xFF,
	0xD8, 0xD7, 0xD8, 0xFF, 0xD8, 0xD8, 0xD7, 0xFF, 0xD8, 0xD8, 0xD7, 0xFF,
	0xD7, 0xD7, 0xD7, 0x44, 0xD7, 0xD7, 0xD7, 0x00, 0xD6, 0xD6, 0xD7, 0x00,
	0xD6, 0xD7, 0xD7, 0x00, 0xD6, 0xD6, 0xD7, 0x00, 0xD6, 0xD6, 0xD6, 0x00,
	0xD5, 0xD6, 0xD5, 0xFF, 0xD5, 0xD5, 0xD5, 0xFF, 0xD5, 0xD5, 0xD5, 0xFF,
	0xD5, 0xD5, 0xD5, 0xFF, 0xD5, 0xD5, 0xD4, 0xFF, 0xD5, 0xD4, 0xD4, 0xFF,
	0xD4, 0xD4, 0xD4, 0xFF, 0xD4, 0xD4, 0xD4, 0x77, 0xD4, 0xD3, 0xD3, 0x00,
	0xD3, 0xD4, 0xD4, 0x00, 0xD4, 0xD4, 0xD3, 0x00, 0xD3, 0xD3, 0xD3, 0x44,
	0xD3, 0xD3, 0xD3, 0xFF, 0xD3, 0xD3, 0xD2, 0xFF, 0xD3, 0xD2, 0xD2, 0xFF,
	0xD2, 0xD2, 0xD2, 0xFF, 0xD2, 0xD2, 0xD2, 0xFF, 0xD2, 0xD2, 0xD2, 0xFF,
	0xD2, 0xD2, 0xD1, 0xFF, 0xD2, 0xD2, 0xD2, 0xFF, 0xD1, 0xD2, 0xD1, 0xFF,
	0xD1, 0xD1, 0xD1, 0xFF, 0xD1, 0xD1, 0xD1, 0xBB, 0xD0, 0xD1, 0xD1, 0x00,
	0xD0, 0xD1, 0xD1, 0x00, 0xD0, 0xD0, 0xD1, 0x00, 0xD0, 0xD0, 0xD1, 0x00,
	0xD0, 0xD1, 0xD0, 0x00, 0xD0, 0xD0, 0xD0, 0x00, 0xD0, 0xD0, 0xD0, 0xFF,
	0xD0, 0xD0, 0xD0, 0xFF, 0xD0, 0xD0, 0xD0, 0xFF, 0xD0, 0xD0, 0xD0, 0xFF,
	0xD0, 0xD0, 0xD0, 0xFF, 0xD0, 0xD0, 0xD0, 0xFF, 0xD0, 0xD0, 0xD0, 0xFF,
	0xD0, 0xD0, 0xD0, 0x77, 0xD0, 0xD0, 0xD0, 0x00, 0xD0, 0xD0, 0xD0, 0x00,
	0xD0, 0xD0, 0xD0, 0x00, 0xD0, 0xD0, 0xD0, 0x00, 0xD0, 0xD0, 0xD0, 0x00,
	0xD0, 0xD0, 0xD0, 0x00, 0xD0, 0xD0, 0xD0, 0x00, 0xD0, 0xD0, 0xD0, 0x00,
	0xD0, 0xD0, 0xD0, 0x00, 0xD0, 0xD0, 0xD0, 0x00, 0xD0, 0xD0, 0xD0, 0x66,
	0xD0, 0xD0, 0xD0, 0xFF, 0xD0, 0xD0, 0xD0, 0xFF, 0xD0, 0xD0, 0xD0, 0xFF,
	0xD0, 0xD0, 0xD0, 0xFF, 0xD0, 0xD0, 0xD0, 0xFF, 0xD0, 0xD0, 0xD0, 0xFF,
	0xD0, 0xD0, 0xD0, 0xFF, 0xD0, 0xD0, 0xD0, 0xFF, 0xD0, 0xD0, 0xD0, 0xFF,
	0xD0, 0xD0, 0xD0, 0xFF, 0xD0, 0xD0, 0xD0, 0x66, 0xD0, 0xD0, 0xD0, 0x00,
	0xD0, 0xD0, 0xD0, 0x00, 0xD0, 0xD0, 0xD0, 0x00, 0xD0, 0xD0, 0xD0, 0x00,
	0xD0, 0xD0, 0xD0, 0x00, 0xD0, 0xD0, 0xD0, 0x00, 0xD0, 0xD0, 0xD0, 0x00,
	0xD0, 0xD0, 0xD0, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xF9, 0xF9, 0xF9, 0x00, 0xF8, 0xF8, 0xF8, 0x2F, 0xF7, 0xF7, 0xF7, 0xBC,
	0xF6, 0xF6, 0xF5, 0xFF, 0xF4, 0xF5, 0xF4, 0xFF, 0xF3, 0xF3, 0xF3, 0xFF,
	0xF2, 0xF1, 0xF2, 0xFF, 0xF0, 0xF1, 0xF0, 0xFF, 0xEF, 0xEF, 0xEE, 0xFF,
	0xED, 0xEE, 0xED, 0xB3, 0xEC, 0xEC, 0xED, 0x18, 0xEB, 0xEB, 0xEA, 0x05,
	0xE9, 0xEA, 0xE9, 0x00, 0xE8, 0xE8, 0xE8, 0x00, 0xE6, 0xE7, 0xE6, 0x00,
	0xE5, 0xE5, 0xE5, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xF2, 0xF3, 0xF2, 0x22, 0xF2, 0xF2, 0xF3, 0xFF,
	0xF2, 0xF1, 0xF2, 0xFF, 0xF2, 0xF2, 0xF1, 0xFF, 0xF1, 0xF2, 0xF1, 0xFF,
	0xF1, 0xF1, 0xF1, 0xFF, 0xF1, 0xF1, 0xF1, 0xFF, 0xF0, 0xF1, 0xF1, 0xFF,
	0xF0, 0xF0, 0xF0, 0x99, 0xF0, 0xF0, 0xF0, 0x00, 0xF0, 0xEF, 0xEF, 0x00,
	0xEF, 0xF0, 0xEF, 0x00, 0xEF, 0xEF, 0xEF, 0x00, 0xEE, 0xEF, 0xEE, 0x00,
	0xEE, 0xEE, 0xEF, 0x00, 0xEE, 0xEE, 0xEE, 0x00, 0xEE, 0xED, 0xEE, 0x00,
	0xED, 0xEE, 0xED, 0x00, 0xED, 0xED, 0xED, 0x00, 0xED, 0xEC, 0xEC, 0x00,
	0xED, 0xEC, 0xEC, 0x00, 0xEC, 0xEC, 0xEC, 0x00, 0xEB, 0xEC, 0xEB, 0x00,
	0xEB, 0xEB, 0xEC, 0x00, 0xEB, 0xEB, 0xEB, 0x00, 0xEB, 0xEB, 0xEB, 0x22,
	0xEA, 0xEA, 0xEA, 0xFF, 0xEA, 0xEA, 0xEA, 0xFF, 0xEA, 0xE9, 0xE9, 0xFF,
	0xE9, 0xEA, 0xE9, 0xFF, 0xE9, 0xE8, 0xE9, 0xFF, 0xE8, 0xE8, 0xE9, 0xFF,
	0xE8, 0xE9, 0xE8, 0xFF, 0xE8, 0xE8, 0xE8, 0x99, 0xE8, 0xE7, 0xE8, 0x00,
	0xE7, 0xE7, 0xE7, 0x00, 0xE7, 0xE7, 0xE6, 0x00, 0xE7, 0xE6, 0xE7, 0x00,
	0xE6, 0xE6, 0xE7, 0x00, 0xE6, 0xE6, 0xE6, 0x00, 0xE6, 0xE6, 0xE6, 0x00,
	0xE5, 0xE5, 0xE5, 0x99, 0xE5, 0xE5, 0xE5, 0xFF, 0xE5, 0xE4, 0xE5, 0xFF,
	0xE4, 0xE4, 0xE4, 0xFF, 0xE4, 0xE4, 0xE4, 0xFF, 0xE4, 0xE3, 0xE3, 0xFF,
	0xE4, 0xE4, 0xE4, 0xFF, 0xE3, 0xE3, 0xE3, 0xFF, 0xE3, 0xE2, 0xE2, 0x44,
	0xE2, 0xE2, 0xE2, 0x00, 0xE2, 0xE2, 0xE2, 0x00, 0xE2, 0xE1, 0xE2, 0x00,
	0xE2, 0xE2, 0xE2, 0x00, 0xE1, 0xE1, 0xE1, 0xFF, 0xE0, 0xE0, 0xE1, 0xFF,
	0xE1, 0xE0, 0xE0, 0xFF, 0xE0, 0xE0, 0xE0, 0xFF, 0xDF, 0xE0, 0xE0, 0xFF,
	0xE0, 0xDF, 0xDF, 0xFF, 0xDF, 0xDF, 0xDF, 0xFF, 0xDF, 0xDF, 0xDF, 0xFF,
	0xDF, 0xDE, 0xDE, 0xFF, 0xDE, 0xDE, 0xDF, 0xFF, 0xDE, 0xDD, 0xDE, 0xFF,
	0xDD, 0xDD, 0xDE, 0x33, 0xDE, 0xDD, 0xDE, 0x00, 0xDD, 0xDD, 0xDD, 0x00,
	0xDC, 0xDD, 0xDD, 0x00, 0xDD, 0xDC, 0xDD, 0x00, 0xDC, 0xDC, 0xDC, 0x11,
	0xDB, 0xDC, 0xDB, 0xDD, 0xDC, 0xDB, 0xDC, 0xFF, 0xDB, 0xDB, 0xDB, 0xFF,
	0xDB, 0xDB, 0xDB, 0xFF, 0xDB, 0xDB, 0xDA, 0xFF, 0xDA, 0xDA, 0xDA, 0xFF,
	0xDA, 0xDA, 0xDA, 0xFF, 0xD9, 0xD9, 0xDA, 0xFF, 0xD9, 0xDA, 0xDA, 0xFF,
	0xD9, 0xD9, 0xD9, 0xFF, 0xD9, 0xD9, 0xD9, 0xFF, 0xD8, 0xD8, 0xD9, 0x44,
	0xD8, 0xD8, 0xD8, 0x00, 0xD8, 0xD8, 0xD8, 0x00, 0xD7, 0xD8, 0xD7, 0x00,
	0xD8, 0xD7, 0xD8, 0x00, 0xD8, 0xD7, 0xD7, 0x00, 0xD7, 0xD7, 0xD7, 0xFF,
	0xD7, 0xD7, 0xD7, 0xFF, 0xD6, 0xD7, 0xD6, 0xFF, 0xD6, 0xD6, 0xD6, 0xFF,
	0xD6, 0xD6, 0xD6, 0xFF, 0xD6, 0xD6, 0xD6, 0xFF, 0xD5, 0xD5, 0xD5, 0xFF,
	0xD5, 0xD5, 0xD5, 0x77, 0xD5, 0xD5, 0xD5, 0x00, 0xD5, 0xD5, 0xD4, 0x00,
	0xD4, 0xD5, 0xD5, 0x00, 0xD5, 0xD4, 0xD4, 0x44, 0xD4, 0xD4, 0xD4, 0xFF,
	0xD4, 0xD4, 0xD4, 0xFF, 0xD4, 0xD4, 0xD4, 0xFF, 0xD4, 0xD3, 0xD3, 0xFF,
	0xD3, 0xD3, 0xD3, 0xFF, 0xD3, 0xD3, 0xD3, 0xFF, 0xD3, 0xD3, 0xD3, 0xFF,
	0xD3, 0xD2, 0xD3, 0xFF, 0xD3, 0xD3, 0xD3, 0xFF, 0xD3, 0xD2, 0xD2, 0xFF,
	0xD2, 0xD2, 0xD2, 0xFF, 0xD2, 0xD2, 0xD2, 0x77, 0xD2, 0xD2, 0xD2, 0x00,
	0xD1, 0xD1, 0xD2, 0x00, 0xD1, 0xD1, 0xD1, 0x00, 0xD1, 0xD1, 0xD1, 0x00,
	0xD1, 0xD1, 0xD1, 0x00, 0xD1, 0xD1, 0xD1, 0xFF, 0xD1, 0xD0, 0xD0, 0xFF,
	0xD1, 0xD1, 0xD1, 0xFF, 0xD1, 0xD0, 0xD0, 0xFF, 0xD1, 0xD1, 0xD0, 0xFF,
	0xD0, 0xD0, 0xD0, 0xFF, 0xD0, 0xD0, 0xD0, 0xFF, 0xD0, 0xD0, 0xD0, 0x77,
	0xD0, 0xD0, 0xD0, 0x00, 0xD0, 0xD0, 0xD0, 0x00, 0xD0, 0xD0, 0xD0, 0x00,
	0xD0, 0xD0, 0xD0, 0x00, 0xD0, 0xD0, 0xD0, 0x00, 0xD0, 0xD0, 0xD0, 0x00,
	0xD0, 0xD0, 0xCF, 0x00, 0xD0, 0xD0, 0xD0, 0x00, 0xD0, 0xD0, 0xD0, 0x00,
	0xD0, 0xD0, 0xD0, 0x00, 0xD0, 0xD0, 0xD0, 0xBB, 0xD0, 0xD0, 0xD0, 0xFF,
	0xD0, 0xD0, 0xD0, 0xFF, 0xD0, 0xD0, 0xD0, 0xFF, 0xD0, 0xD0, 0xD0, 0xFF,
	0xD0, 0xD0, 0xD0, 0xFF, 0xD0, 0xD0, 0xD0, 0xFF, 0xD0, 0xD0, 0xD0, 0xFF,
	0xD0, 0xD0, 0xD0, 0xFF, 0xD0, 0xD0, 0xD0, 0xFF, 0xD0, 0xD0, 0xD0, 0xFF,
	0xD0, 0xD0, 0xD0, 0xAA, 0xD0, 0xD0, 0xD0, 0x00, 0xD0, 0xD0, 0xD0, 0x00,
	0xD0, 0xD0, 0xD0, 0x00, 0xD0, 0xD0, 0xD0, 0x00, 0xD0, 0xD0, 0xD0, 0x00,
	0xD0, 0xD0, 0xD0, 0x00, 0xD0, 0xD0, 0xD0, 0x00, 0xD0, 0xD0, 0xD0, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xF9, 0xF9, 0xF9, 0x00,
	0xF8, 0xF8, 0xF8, 0x8B, 0xF7, 0xF7, 0xF7, 0xF3, 0xF6, 0xF6, 0xF5, 0xFF,
	0xF5, 0xF4, 0xF5, 0xFF, 0xF3, 0xF3, 0xF3, 0xFF, 0xF2, 0xF1, 0xF2, 0xFF,
	0xF1, 0xF1, 0xF1, 0xFF, 0xF0, 0xEF, 0xF0, 0xFF, 0xEE, 0xEE, 0xEE, 0xA6,
	0xEC, 0xEC, 0xEC, 0x03, 0xEB, 0xEB, 0xEB, 0x00, 0xE9, 0xE9, 0xE9, 0x00,
	0xE8, 0xE8, 0xE8, 0x00, 0xE7, 0xE7, 0xE6, 0x00, 0xE5, 0xE5, 0xE5, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xF4, 0xF4, 0xF4, 0x22, 0xF4, 0xF4, 0xF4, 0xFF, 0xF3, 0xF4, 0xF4, 0xFF,
	0xF3, 0xF3, 0xF3, 0xFF, 0xF3, 0xF3, 0xF3, 0xFF, 0xF3, 0xF3, 0xF2, 0xFF,
	0xF3, 0xF2, 0xF2, 0xFF, 0xF2, 0xF2, 0xF2, 0xFF, 0xF1, 0xF2, 0xF2, 0x99,
	0xF2, 0xF2, 0xF1, 0x00, 0xF1, 0xF1, 0xF1, 0x00, 0xF1, 0xF1, 0xF1, 0x00,
	0xF1, 0xF1, 0xF0, 0x00, 0xF0, 0xF1, 0xF0, 0x00, 0xF0, 0xF0, 0xF0, 0x00,
	0xEF, 0xEF, 0xF0, 0x00, 0xEF, 0xEF, 0xEF, 0x00, 0xEF, 0xEF, 0xEF, 0x00,
	0xEE, 0xEF, 0xEF, 0x00, 0xEE, 0xEE, 0xEE, 0x00, 0xEE, 0xEE, 0xEE, 0x00,
	0xEE, 0xEE, 0xEE, 0x00, 0xED, 0xEE, 0xED, 0x00, 0xED, 0xED, 0xED, 0x00,
	0xED, 0xED, 0xEC, 0x00, 0xED, 0xEC, 0xEC, 0x22, 0xEC, 0xEC, 0xEC, 0xFF,
	0xEC, 0xEC, 0xEC, 0xFF, 0xEC, 0xEC, 0xEB, 0xFF, 0xEB, 0xEB, 0xEB, 0xFF,
	0xEB, 0xEB, 0xEA, 0xFF, 0xEA, 0xEA, 0xEA, 0xFF, 0xEA, 0xEA, 0xEA, 0xFF,
	0xE9, 0xEA, 0xEA, 0x99, 0xEA, 0xEA, 0xEA, 0x00, 0xE9, 0xE9, 0xE9, 0x00,
	0xE9, 0xE9, 0xE9, 0x00, 0xE8, 0xE8, 0xE8, 0x00, 0xE8, 0xE8, 0xE8, 0x00,
	0xE8, 0xE8, 0xE8, 0x00, 0xE8, 0xE7, 0xE7, 0x00, 0xE7, 0xE7, 0xE7, 0x99,
	0xE7, 0xE7, 0xE7, 0xFF, 0xE6, 0xE7, 0xE6, 0xFF, 0xE6, 0xE6, 0xE6, 0xFF,
	0xE5, 0xE6, 0xE5, 0xFF, 0xE6, 0xE6, 0xE6, 0xFF, 0xE5, 0xE5, 0xE5, 0xFF,
	0xE4, 0xE5, 0xE4, 0xFF, 0xE4, 0xE4, 0xE5, 0x44, 0xE4, 0xE4, 0xE5, 0x00,
	0xE4, 0xE4, 0xE4, 0x00, 0xE4, 0xE3, 0xE4, 0x00, 0xE3, 0xE3, 0xE3, 0x00,
	0xE3, 0xE3, 0xE2, 0xFF, 0xE3, 0xE3, 0xE2, 0xFF, 0xE2, 0xE2, 0xE2, 0xFF,
	0xE2, 0xE2, 0xE2, 0xFF, 0xE1, 0xE1, 0xE2, 0xFF, 0xE2, 0xE1, 0xE1, 0xFF,
	0xE1, 0xE1, 0xE1, 0xFF, 0xE0, 0xE1, 0xE0, 0xFF, 0xE0, 0xE0, 0xE0, 0xFF,
	0xE0, 0xE0, 0xE0, 0xFF, 0xE0, 0xE0, 0xDF, 0xFF, 0xE0, 0xDF, 0xDF, 0xBB,
	0xDF, 0xDF, 0xDE, 0x00, 0xDE, 0xDF, 0xDF, 0x00, 0xDE, 0xDE, 0xDE, 0x00,
	0xDE, 0xDE, 0xDE, 0x00, 0xDD, 0xDE, 0xDE, 0x77, 0xDD, 0xDE, 0xDE, 0xFF,
	0xDD, 0xDD, 0xDD, 0xFF, 0xDD, 0xDC, 0xDD, 0xFF, 0xDC, 0xDD, 0xDC, 0xFF,
	0xDC, 0xDC, 0xDC, 0xFF, 0xDB, 0xDC, 0xDC, 0xFF, 0xDC, 0xDC, 0xDB, 0xFF,
	0xDB, 0xDC, 0xDB, 0xFF, 0xDB, 0xDB, 0xDB, 0xFF, 0xDB, 0xDB, 0xDB, 0xFF,
	0xDA, 0xDA, 0xDA, 0xFF, 0xDA, 0xDA, 0xDA, 0x44, 0xDA, 0xDA, 0xDA, 0x00,
	0xDA, 0xD9, 0xD9, 0x00, 0xD9, 0xD9, 0xD9, 0x00, 0xD9, 0xD9, 0xD9, 0x00,
	0xD8, 0xD9, 0xD8, 0x00, 0xD8, 0xD9, 0xD9, 0xFF, 0xD8, 0xD8, 0xD8, 0xFF,
	0xD8, 0xD8, 0xD8, 0xFF, 0xD8, 0xD8, 0xD8, 0xFF, 0xD7, 0xD7, 0xD7, 0xFF,
	0xD7, 0xD7, 0xD7, 0xFF, 0xD7, 0xD7, 0xD7, 0xFF, 0xD7, 0xD7, 0xD6, 0x77,
	0xD6, 0xD6, 0xD6, 0x00, 0xD6, 0xD6, 0xD6, 0x00, 0xD5, 0xD6, 0xD6, 0x00,
	0xD5, 0xD6, 0xD5, 0x44, 0xD6, 0xD5, 0xD6, 0xFF, 0xD5, 0xD5, 0xD5, 0xFF,
	0xD5, 0xD5, 0xD5, 0xFF, 0xD5, 0xD4, 0xD4, 0xFF, 0xD4, 0xD4, 0xD4, 0xFF,
	0xD4, 0xD4, 0xD5, 0xFF, 0xD4, 0xD4, 0xD4, 0xFF, 0xD4, 0xD4, 0xD3, 0xFF,
	0xD4, 0xD3, 0xD4, 0xFF, 0xD4, 0xD3, 0xD3, 0xFF, 0xD3, 0xD3, 0xD3, 0xFF,
	0xD3, 0xD3, 0xD2, 0xEE, 0xD3, 0xD3, 0xD3, 0x22, 0xD2, 0xD2, 0xD2, 0x00,
	0xD3, 0xD3, 0xD3, 0x00, 0xD2, 0xD2, 0xD2, 0x00, 0xD1, 0xD2, 0xD2, 0x00,
	0xD2, 0xD2, 0xD2, 0xFF, 0xD1, 0xD1, 0xD2, 0xFF, 0xD2, 0xD1, 0xD1, 0xFF,
	0xD1, 0xD2, 0xD1, 0xFF, 0xD1, 0xD1, 0xD1, 0xFF, 0xD1, 0xD1, 0xD1, 0xFF,
	0xD1, 0xD1, 0xD1, 0xFF, 0xD0, 0xD0, 0xD0, 0x77, 0xD0, 0xD1, 0xD0, 0x00,
	0xD0, 0xD0, 0xD0, 0x00, 0xD0, 0xD0, 0xD0, 0x00, 0xD0, 0xD0, 0xD0, 0x00,
	0xD0, 0xD0, 0xD0, 0x00, 0xD0, 0xD0, 0xD0, 0x00, 0xD0, 0xD0, 0xD0, 0x00,
	0xD0, 0xD0, 0xD0, 0x00, 0xD0, 0xD0, 0xCF, 0x00, 0xD0, 0xD0, 0xD0, 0x22,
	0xD0, 0xD0, 0xD0, 0xFF, 0xD0, 0xD0, 0xD0, 0xFF, 0xD0, 0xD0, 0xD0, 0xFF,
	0xD0, 0xD0, 0xD0, 0xFF, 0xD0, 0xD0, 0xD0, 0xFF, 0xD0, 0xD0, 0xD0, 0xFF,
	0xD0, 0xD0, 0xD0, 0xFF, 0xCF, 0xD0, 0xD0, 0xFF, 0xD0, 0xD0, 0xD0, 0xFF,
	0xD0, 0xD0, 0xD0, 0xFF, 0xD0, 0xD0, 0xD0, 0xFF, 0xD0, 0xD0, 0xD0, 0xFF,
	0xD0, 0xD0, 0xD0, 0x11, 0xD0, 0xD0, 0xD0, 0x00, 0xD0, 0xD0, 0xD0, 0x00,
	0xD0, 0xD0, 0xCF, 0x00, 0xD0, 0xD0, 0xD0, 0x00, 0xD0, 0xD0, 0xD0, 0x00,
	0xD0, 0xD0, 0xD0, 0x00, 0xD0, 0xD0, 0xD0, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xF9, 0xF9, 0xF9, 0x22, 0xF8, 0xF8, 0xF8, 0xCD,
	0xF7, 0xF7, 0xF7, 0xFF, 0xF6, 0xF6, 0xF6, 0xFF, 0xF4, 0xF5, 0xF4, 0xFF,
	0xF3, 0xF3, 0xF3, 0xFF, 0xF2, 0xF2, 0xF2, 0xFF, 0xF1, 0xF1, 0xF1, 0xFF,
	0xF0, 0xEF, 0xEF, 0xFF, 0xEE, 0xEE, 0xEE, 0x9F, 0xEC, 0xEC, 0xED, 0x00,
	0xEB, 0xEB, 0xEB, 0x00, 0xEA, 0xEA, 0xEA, 0x00, 0xE9, 0xE8, 0xE8, 0x00,
	0xE6, 0xE7, 0xE7, 0x00, 0xE5, 0xE5, 0xE5, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xF5, 0xF6, 0xF6, 0x22,
	0xF5, 0xF5, 0xF5, 0xFF, 0xF5, 0xF5, 0xF5, 0xFF, 0xF5, 0xF4, 0xF5, 0xFF,
	0xF5, 0xF4, 0xF4, 0xFF, 0xF4, 0xF4, 0xF4, 0xFF, 0xF4, 0xF4, 0xF4, 0xFF,
	0xF4, 0xF4, 0xF4, 0xFF, 0xF4, 0xF4, 0xF4, 0x99, 0xF3, 0xF3, 0xF3, 0x00,
	0xF3, 0xF3, 0xF3, 0x00, 0xF2, 0xF2, 0xF2, 0x00, 0xF2, 0xF2, 0xF2, 0x00,
	0xF2, 0xF1, 0xF1, 0x00, 0xF2, 0xF1, 0xF1, 0x00, 0xF2, 0xF1, 0xF1, 0x00,
	0xF1, 0xF1, 0xF1, 0x00, 0xF0, 0xF0, 0xF0, 0x00, 0xF1, 0xF0, 0xF1, 0x00,
	0xF0, 0xF0, 0xF0, 0x00, 0xF0, 0xF0, 0xF0, 0x00, 0xF0, 0xEF, 0xF0, 0x00,
	0xEF, 0xEF, 0xF0, 0x00, 0xEF, 0xEF, 0xEE, 0x00, 0xEE, 0xEF, 0xEE, 0x00,
	0xEE, 0xEE, 0xEE, 0x22, 0xEE, 0xEE, 0xEE, 0xFF, 0xED, 0xED, 0xED, 0xFF,
	0xED, 0xED, 0xED, 0xFF, 0xED, 0xED, 0xED, 0xFF, 0xED, 0xEC, 0xED, 0xFF,
	0xEC, 0xEC, 0xEC, 0xFF, 0xEB, 0xEC, 0xEC, 0xFF, 0xEB, 0xEC, 0xEC, 0x99,
	0xEC, 0xEB, 0xEB, 0x00, 0xEB, 0xEB, 0xEB, 0x00, 0xEA, 0xEA, 0xEB, 0x00,
	0xEA, 0xEA, 0xEA, 0x00, 0xEA, 0xE9, 0xEA, 0x00, 0xEA, 0xE9, 0xE9, 0x00,
	0xEA, 0xE9, 0xE9, 0x00, 0xE9, 0xE9, 0xE9, 0x99, 0xE8, 0xE8, 0xE9, 0xFF,
	0xE8, 0xE8, 0xE9, 0xFF, 0xE8, 0xE8, 0xE8, 0xFF, 0xE7, 0xE8, 0xE7, 0xFF,
	0xE8, 0xE7, 0xE7, 0xFF, 0xE7, 0xE7, 0xE7, 0xFF, 0xE7, 0xE6, 0xE6, 0xFF,
	0xE6, 0xE6, 0xE6, 0x44, 0xE6, 0xE6, 0xE6, 0x00, 0xE5, 0xE6, 0xE5, 0x00,
	0xE5, 0xE5, 0xE5, 0x00, 0xE5, 0xE5, 0xE5, 0x00, 0xE5, 0xE4, 0xE5, 0xFF,
	0xE5, 0xE4, 0xE4, 0xFF, 0xE4, 0xE4, 0xE4, 0xFF, 0xE3, 0xE4, 0xE4, 0xFF,
	0xE3, 0xE3, 0xE3, 0xFF, 0xE3, 0xE3, 0xE3, 0xFF, 0xE3, 0xE2, 0xE3, 0xFF,
	0xE2, 0xE2, 0xE2, 0xFF, 0xE2, 0xE2, 0xE2, 0xFF, 0xE1, 0xE1, 0xE1, 0xFF,
	0xE2, 0xE1, 0xE1, 0xFF, 0xE1, 0xE1, 0xE1, 0xFF, 0xE1, 0xE1, 0xE0, 0x55,
	0xE0, 0xE0, 0xE0, 0x00, 0xE0, 0xE0, 0xE0, 0x00, 0xE0, 0xE0, 0xE0, 0x22,
	0xDF, 0xE0, 0xDF, 0xFF, 0xDF, 0xDF, 0xDF, 0xFF, 0xDF, 0xDF, 0xDF, 0xFF,
	0xDF, 0xDF, 0xDF, 0xFF, 0xDE, 0xDE, 0xDE, 0xFF, 0xDE, 0xDD, 0xDE, 0xFF,
	0xDE, 0xDE, 0xDD, 0xFF, 0xDD, 0xDD, 0xDD, 0xFF, 0xDD, 0xDD, 0xDD, 0xFF,
	0xDD, 0xDC, 0xDD, 0xFF, 0xDD, 0xDC, 0xDD, 0xFF, 0xDC, 0xDC, 0xDC, 0xFF,
	0xDC, 0xDB, 0xDB, 0x44, 0xDB, 0xDB, 0xDC, 0x00, 0xDB, 0xDB, 0xDB, 0x00,
	0xDA, 0xDB, 0xDB, 0x00, 0xDB, 0xDA, 0xDB, 0x00, 0xDA, 0xDA, 0xDA, 0x00,
	0xDA, 0xDA, 0xDA, 0xFF, 0xD9, 0xDA, 0xD9, 0xFF, 0xD9, 0xDA, 0xD9, 0xFF,
	0xD9, 0xD9, 0xD9, 0xFF, 0xD8, 0xD9, 0xD9, 0xFF, 0xD9, 0xD9, 0xD9, 0xFF,
	0xD8, 0xD8, 0xD8, 0xFF, 0xD8, 0xD8, 0xD8, 0x77, 0xD7, 0xD8, 0xD8, 0x00,
	0xD8, 0xD7, 0xD8, 0x00, 0xD7, 0xD7, 0xD8, 0x00, 0xD7, 0xD7, 0xD7, 0x44,
	0xD6, 0xD7, 0xD7, 0xFF, 0xD7, 0xD6, 0xD7, 0xFF, 0xD6, 0xD6, 0xD6, 0xFF,
	0xD6, 0xD6, 0xD6, 0xFF, 0xD6, 0xD6, 0xD6, 0xFF, 0xD5, 0xD6, 0xD5, 0xFF,
	0xD5, 0xD5, 0xD5, 0xFF, 0xD5, 0xD5, 0xD5, 0xFF, 0xD4, 0xD5, 0xD5, 0xFF,
	0xD5, 0xD5, 0xD5, 0xFF, 0xD4, 0xD4, 0xD4, 0xFF, 0xD4, 0xD4, 0xD4, 0xFF,
	0xD3, 0xD4, 0xD4, 0xBB, 0xD3, 0xD3, 0xD4, 0x00, 0xD4, 0xD3, 0xD4, 0x00,
	0xD4, 0xD4, 0xD3, 0x00, 0xD3, 0xD3, 0xD3, 0x00, 0xD3, 0xD2, 0xD2, 0xFF,
	0xD3, 0xD2, 0xD3, 0xFF, 0xD3, 0xD2, 0xD3, 0xFF, 0xD2, 0xD2, 0xD2, 0xFF,
	0xD2, 0xD2, 0xD2, 0xFF, 0xD2, 0xD2, 0xD2, 0xFF, 0xD1, 0xD2, 0xD2, 0xFF,
	0xD1, 0xD1, 0xD1, 0x77, 0xD2, 0xD1, 0xD2, 0x00, 0xD2, 0xD1, 0xD1, 0x00,
	0xD1, 0xD1, 0xD1, 0x00, 0xD1, 0xD1, 0xD1, 0x00, 0xD1, 0xD0, 0xD1, 0x00,
	0xD0, 0xD0, 0xD0, 0x00, 0xD0, 0xD0, 0xD1, 0x00, 0xD0, 0xD0, 0xD0, 0x00,
	0xD0, 0xD0, 0xD0, 0x00, 0xD0, 0xD0, 0xD0, 0x77, 0xD0, 0xD0, 0xD0, 0xFF,
	0xD0, 0xD0, 0xD0, 0xFF, 0xD0, 0xD0, 0xD0, 0xFF, 0xD0, 0xD0, 0xD0, 0xFF,
	0xD0, 0xD0, 0xD0, 0xFF, 0xD0, 0xD0, 0xD0, 0xFF, 0xD0, 0xD0, 0xD0, 0xFF,
	0xD0, 0xD0, 0xD0, 0xFF, 0xD0, 0xD0, 0xD0, 0xFF, 0xD0, 0xD0, 0xD0, 0xFF,
	0xD0, 0xD0, 0xD0, 0xFF, 0xD0, 0xD0, 0xD0, 0xFF, 0xD0, 0xD0, 0xD0, 0x77,
	0xD0, 0xD0, 0xD0, 0x00, 0xD0, 0xD0, 0xD0, 0x00, 0xD0, 0xD0, 0xD0, 0x00,
	0xD0, 0xD0, 0xD0, 0x00, 0xD0, 0xD0, 0xD0, 0x00, 0xD0, 0xD0, 0xD0, 0x00,
	0xD0, 0xD0, 0xD0, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFA, 0xF9, 0xF9, 0x6B, 0xF9, 0xF8, 0xF9, 0xE3, 0xF7, 0xF7, 0xF7, 0xFF,
	0xF6, 0xF6, 0xF6, 0xFF, 0xF5, 0xF4, 0xF4, 0xFF, 0xF3, 0xF3, 0xF4, 0xFF,
	0xF2, 0xF3, 0xF2, 0xFF, 0xF1, 0xF1, 0xF1, 0xFF, 0xEF, 0xEF, 0xF0, 0xFF,
	0xEE, 0xEE, 0xEE, 0x9F, 0xED, 0xEC, 0xEC, 0x00, 0xEC, 0xEB, 0xEB, 0x00,
	0xEA, 0xEA, 0xEA, 0x00, 0xE8, 0xE9, 0xE8, 0x00, 0xE6, 0xE7, 0xE7, 0x00,
	0xE6, 0xE5, 0xE6, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xF7, 0xF7, 0xF7, 0x22, 0xF7, 0xF7, 0xF7, 0xFF,
	0xF6, 0xF6, 0xF6, 0xFF, 0xF6, 0xF6, 0xF6, 0xFF, 0xF6, 0xF6, 0xF6, 0xFF,
	0xF6, 0xF5, 0xF6, 0xFF, 0xF5, 0xF5, 0xF5, 0xFF, 0xF5, 0xF5, 0xF5, 0xFF,
	0xF5, 0xF5, 0xF5, 0x99, 0xF5, 0xF5, 0xF5, 0x00, 0xF5, 0xF4, 0xF4, 0x00,
	0xF4, 0xF4, 0xF4, 0x00, 0xF4, 0xF4, 0xF4, 0x00, 0xF3, 0xF3, 0xF3, 0x00,
	0xF4, 0xF3, 0xF3, 0x00, 0xF3, 0xF3, 0xF3, 0x00, 0xF2, 0xF3, 0xF2, 0x00,
	0xF2, 0xF3, 0xF2, 0x00, 0xF1, 0xF2, 0xF2, 0x00, 0xF2, 0xF2, 0xF2, 0x00,
	0xF2, 0xF1, 0xF1, 0x00, 0xF1, 0xF1, 0xF1, 0x00, 0xF1, 0xF1, 0xF1, 0x00,
	0xF0, 0xF1, 0xF0, 0x00, 0xF0, 0xF1, 0xF0, 0x00, 0xF0, 0xF0, 0xEF, 0x22,
	0xF0, 0xEF, 0xEF, 0xFF, 0xEF, 0xEF, 0xEF, 0xFF, 0xEF, 0xEE, 0xEF, 0xFF,
	0xEF, 0xEF, 0xEE, 0xFF, 0xEE, 0xEE, 0xEE, 0xFF, 0xEE, 0xEE, 0xEE, 0xFF,
	0xED, 0xEE, 0xEE, 0xFF, 0xED, 0xEE, 0xED, 0x99, 0xEC, 0xED, 0xED, 0x00,
	0xED, 0xED, 0xEC, 0x00, 0xED, 0xED, 0xED, 0x00, 0xEC, 0xEC, 0xEB, 0x00,
	0xEC, 0xEB, 0xEC, 0x00, 0xEB, 0xEB, 0xEB, 0x00, 0xEB, 0xEB, 0xEB, 0x00,
	0xEA, 0xEA, 0xEA, 0x99, 0xEB, 0xEB, 0xEB, 0xFF, 0xEA, 0xEA, 0xEA, 0xFF,
	0xEA, 0xEA, 0xEA, 0xFF, 0xE9, 0xE9, 0xEA, 0xFF, 0xE9, 0xE9, 0xE9, 0xFF,
	0xE8, 0xE8, 0xE8, 0xFF, 0xE8, 0xE8, 0xE8, 0xFF, 0xE8, 0xE8, 0xE8, 0x44,
	0xE8, 0xE7, 0xE8, 0x00, 0xE8, 0xE7, 0xE7, 0x00, 0xE7, 0xE6, 0xE7, 0x00,
	0xE7, 0xE7, 0xE7, 0x00, 0xE6, 0xE6, 0xE6, 0xFF, 0xE6, 0xE6, 0xE6, 0xFF,
	0xE5, 0xE6, 0xE6, 0xFF, 0xE6, 0xE6, 0xE5, 0xFF, 0xE5, 0xE5, 0xE5, 0xFF,
	0xE5, 0xE5, 0xE4, 0xFF, 0xE4, 0xE4, 0xE5, 0xFF, 0xE4, 0xE4, 0xE4, 0xFF,
	0xE4, 0xE4, 0xE3, 0xFF, 0xE3, 0xE4, 0xE4, 0xFF, 0xE3, 0xE3, 0xE3, 0xFF,
	0xE2, 0xE2, 0xE3, 0xFF, 0xE3, 0xE2, 0xE2, 0xDD, 0xE2, 0xE2, 0xE2, 0x11,
	0xE1, 0xE1, 0xE1, 0x00, 0xE1, 0xE2, 0xE2, 0xBB, 0xE1, 0xE1, 0xE1, 0xFF,
	0xE1, 0xE1, 0xE1, 0xFF, 0xE0, 0xE1, 0xE0, 0xFF, 0xE0, 0xE0, 0xE0, 0xFF,
	0xE0, 0xDF, 0xE0, 0xFF, 0xDF, 0xDF, 0xDF, 0xFF, 0xDF, 0xDF, 0xDF, 0xFF,
	0xDF, 0xDE, 0xDF, 0xFF, 0xDE, 0xDE, 0xDE, 0xFF, 0xDE, 0xDE, 0xDE, 0xFF,
	0xDE, 0xDE, 0xDE, 0xFF, 0xDD, 0xDE, 0xDE, 0xFF, 0xDD, 0xDD, 0xDE, 0x44,
	0xDC, 0xDD, 0xDD, 0x00, 0xDC, 0xDD, 0xDD, 0x00, 0xDC, 0xDC, 0xDC, 0x00,
	0xDC, 0xDC, 0xDC, 0x00, 0xDC, 0xDC, 0xDB, 0x00, 0xDB, 0xDB, 0xDB, 0xFF,
	0xDB, 0xDB, 0xDB, 0xFF, 0xDA, 0xDB, 0xDB, 0xFF, 0xDB, 0xDB, 0xDB, 0xFF,
	0xDB, 0xDA, 0xDA, 0xFF, 0xDA, 0xDA, 0xDA, 0xFF, 0xDA, 0xD9, 0xDA, 0xFF,
	0xDA, 0xDA, 0xD9, 0x77, 0xDA, 0xD9, 0xD9, 0x00, 0xD9, 0xD9, 0xD9, 0x00,
	0xD8, 0xD8, 0xD9, 0x00, 0xD9, 0xD8, 0xD9, 0x44, 0xD8, 0xD8, 0xD8, 0xFF,
	0xD8, 0xD8, 0xD8, 0xFF, 0xD8, 0xD8, 0xD8, 0xFF, 0xD7, 0xD7, 0xD7, 0xFF,
	0xD7, 0xD7, 0xD7, 0xFF, 0xD7, 0xD6, 0xD6, 0xFF, 0xD6, 0xD7, 0xD6, 0xFF,
	0xD6, 0xD6, 0xD6, 0xFF, 0xD6, 0xD6, 0xD6, 0xFF, 0xD5, 0xD5, 0xD6, 0xFF,
	0xD5, 0xD6, 0xD5, 0xFF, 0xD5, 0xD5, 0xD6, 0xFF, 0xD5, 0xD5, 0xD5, 0xFF,
	0xD5, 0xD4, 0xD5, 0x55, 0xD5, 0xD5, 0xD5, 0x00, 0xD5, 0xD4, 0xD4, 0x00,
	0xD4, 0xD4, 0xD4, 0x00, 0xD4, 0xD4, 0xD4, 0xFF, 0xD3, 0xD4, 0xD4, 0xFF,
	0xD4, 0xD3, 0xD4, 0xFF, 0xD3, 0xD3, 0xD3, 0xFF, 0xD3, 0xD3, 0xD3, 0xFF,
	0xD2, 0xD3, 0xD3, 0xFF, 0xD2, 0xD3, 0xD3, 0xFF, 0xD2, 0xD2, 0xD2, 0x77,
	0xD2, 0xD2, 0xD2, 0x00, 0xD2, 0xD2, 0xD2, 0x00, 0xD2, 0xD2, 0xD2, 0x00,
	0xD1, 0xD2, 0xD2, 0x00, 0xD2, 0xD1, 0xD1, 0x00, 0xD1, 0xD1, 0xD1, 0x00,
	0xD1, 0xD1, 0xD2, 0x00, 0xD1, 0xD1, 0xD1, 0x00, 0xD1, 0xD0, 0xD1, 0x00,
	0xD1, 0xD1, 0xD1, 0xCC, 0xD0, 0xD0, 0xD1, 0xFF, 0xD0, 0xD0, 0xD1, 0xFF,
	0xD1, 0xD0, 0xD0, 0xFF, 0xD0, 0xD0, 0xD0, 0xFF, 0xD0, 0xD0, 0xD0, 0xFF,
	0xD0, 0xD0, 0xD0, 0xFF, 0xD0, 0xD0, 0xD0, 0xFF, 0xD0, 0xD0, 0xD0, 0xFF,
	0xD0, 0xD0, 0xD0, 0xFF, 0xD0, 0xD0, 0xD0, 0xFF, 0xD0, 0xD0, 0xD0, 0xFF,
	0xD0, 0xD0, 0xD0, 0xFF, 0xD0, 0xD0, 0xD0, 0xCC, 0xD0, 0xD0, 0xD0, 0x00,
	0xD0, 0xD0, 0xD0, 0x00, 0xD0, 0xD0, 0xD0, 0x00, 0xD0, 0xD0, 0xD0, 0x00,
	0xD0, 0xD0, 0xD0, 0x00, 0xD0, 0xD0, 0xD0, 0x00, 0xD0, 0xD0, 0xD0, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFA, 0xFA, 0xFA, 0xA6,
	0xF9, 0xF9, 0xF9, 0xF1, 0xF7, 0xF8, 0xF7, 0xFF, 0xF6, 0xF6, 0xF6, 0xFF,
	0xF4, 0xF5, 0xF5, 0xFF, 0xF3, 0xF4, 0xF3, 0xFF, 0xF2, 0xF2, 0xF2, 0xFF,
	0xF1, 0xF1, 0xF1, 0xFF, 0xEF, 0xF0, 0xEF, 0xFF, 0xEE, 0xEE, 0xEE, 0xA3,
	0xED, 0xED, 0xED, 0x01, 0xEB, 0xEC, 0xEC, 0x00, 0xEA, 0xE9, 0xEA, 0x00,
	0xE8, 0xE9, 0xE9, 0x00, 0xE7, 0xE7, 0xE7, 0x00, 0xE6, 0xE5, 0xE5, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xF9, 0xF9, 0xF9, 0x22, 0xF8, 0xF8, 0xF8, 0xFF, 0xF8, 0xF8, 0xF8, 0xFF,
	0xF8, 0xF8, 0xF8, 0xFF, 0xF8, 0xF7, 0xF7, 0xFF, 0xF8, 0xF8, 0xF7, 0xFF,
	0xF7, 0xF7, 0xF7, 0xFF, 0xF7, 0xF7, 0xF7, 0xFF, 0xF7, 0xF6, 0xF7, 0x99,
	0xF6, 0xF6, 0xF6, 0x00, 0xF6, 0xF5, 0xF6, 0x00, 0xF5, 0xF5, 0xF5, 0x00,
	0xF6, 0xF5, 0xF6, 0x00, 0xF5, 0xF5, 0xF5, 0x00, 0xF5, 0xF5, 0xF5, 0x00,
	0xF5, 0xF5, 0xF4, 0x00, 0xF4, 0xF4, 0xF4, 0x00, 0xF3, 0xF4, 0xF4, 0x00,
	0xF3, 0xF4, 0xF3, 0x00, 0xF3, 0xF3, 0xF3, 0x00, 0xF3, 0xF3, 0xF3, 0x00,
	0xF3, 0xF3, 0xF2, 0x00, 0xF3, 0xF3, 0xF3, 0x00, 0xF3, 0xF2, 0xF2, 0x00,
	0xF1, 0xF2, 0xF2, 0x00, 0xF1, 0xF1, 0xF1, 0x22, 0xF1, 0xF1, 0xF1, 0xFF,
	0xF1, 0xF1, 0xF0, 0xFF, 0xF1, 0xF1, 0xF1, 0xFF, 0xF0, 0xF0, 0xF1, 0xFF,
	0xF0, 0xF0, 0xF0, 0xFF, 0xF0, 0xEF, 0xF0, 0xFF, 0xEF, 0xEF, 0xEF, 0xFF,
	0xEF, 0xEF, 0xEF, 0x99, 0xEF, 0xEE, 0xEF, 0x00, 0xEE, 0xEF, 0xEE, 0x00,
	0xEE, 0xEE, 0xEE, 0x00, 0xED, 0xED, 0xEE, 0x00, 0xEE, 0xED, 0xED, 0x00,
	0xED, 0xED, 0xED, 0x00, 0xED, 0xEC, 0xEC, 0x00, 0xEC, 0xED, 0xEC, 0x99,
	0xEC, 0xEC, 0xEC, 0xFF, 0xEC, 0xEB, 0xEC, 0xFF, 0xEB, 0xEB, 0xEB, 0xFF,
	0xEB, 0xEB, 0xEB, 0xFF, 0xEB, 0xEB, 0xEB, 0xFF, 0xEA, 0xEA, 0xEB, 0xFF,
	0xEA, 0xEA, 0xEA, 0xFF, 0xEA, 0xE9, 0xEA, 0x44, 0xE9, 0xEA, 0xEA, 0x00,
	0xE9, 0xE9, 0xE9, 0x00, 0xE9, 0xE9, 0xE9, 0x00, 0xE8, 0xE9, 0xE8, 0x00,
	0xE8, 0xE8, 0xE9, 0xFF, 0xE8, 0xE8, 0xE8, 0xFF, 0xE8, 0xE7, 0xE8, 0xFF,
	0xE7, 0xE7, 0xE7, 0xFF, 0xE7, 0xE6, 0xE7, 0xFF, 0xE6, 0xE6, 0xE6, 0xFF,
	0xE6, 0xE7, 0xE6, 0xFF, 0xE6, 0xE5, 0xE6, 0xFF, 0xE5, 0xE5, 0xE6, 0xFF,
	0xE5, 0xE5, 0xE5, 0xFF, 0xE5, 0xE4, 0xE5, 0xFF, 0xE4, 0xE5, 0xE4, 0xFF,
	0xE4, 0xE4, 0xE4, 0xFF, 0xE4, 0xE3, 0xE4, 0x77, 0xE4, 0xE4, 0xE4, 0x55,
	0xE4, 0xE3, 0xE3, 0xFF, 0xE2, 0xE3, 0xE2, 0xFF, 0xE3, 0xE2, 0xE3, 0xFF,
	0xE2, 0xE2, 0xE3, 0xFF, 0xE2, 0xE1, 0xE2, 0xFF, 0xE2, 0xE2, 0xE2, 0xFF,
	0xE1, 0xE1, 0xE1, 0xFF, 0xE1, 0xE1, 0xE0, 0xFF, 0xE0, 0xE0, 0xE0, 0xFF,
	0xE0, 0xE0, 0xE0, 0xFF, 0xDF, 0xE0, 0xE0, 0xFF, 0xDF, 0xE0, 0xE0, 0xFF,
	0xDF, 0xDF, 0xDF, 0xFF, 0xDE, 0xDF, 0xDE, 0x44, 0xDE, 0xDF, 0xDF, 0x00,
	0xDE, 0xDF, 0xDE, 0x00, 0xDE, 0xDE, 0xDE, 0x00, 0xDD, 0xDD, 0xDE, 0x00,
	0xDE, 0xDD, 0xDE, 0x00, 0xDD, 0xDD, 0xDD, 0xFF, 0xDC, 0xDD, 0xDD, 0xFF,
	0xDC, 0xDD, 0xDC, 0xFF, 0xDD, 0xDC, 0xDD, 0xFF, 0xDC, 0xDC, 0xDC, 0xFF,
	0xDC, 0xDC, 0xDB, 0xFF, 0xDB, 0xDB, 0xDC, 0xFF, 0xDB, 0xDB, 0xDB, 0x77,
	0xDB, 0xDB, 0xDB, 0x00, 0xDA, 0xDA, 0xDA, 0x00, 0xDA, 0xDA, 0xDA, 0x00,
	0xDA, 0xD9, 0xD9, 0x44, 0xD9, 0xD9, 0xDA, 0xFF, 0xDA, 0xD9, 0xDA, 0xFF,
	0xD9, 0xD9, 0xD9, 0xFF, 0xD9, 0xD8, 0xD9, 0xFF, 0xD8, 0xD9, 0xD9, 0xFF,
	0xD8, 0xD8, 0xD9, 0xFF, 0xD8, 0xD8, 0xD7, 0xFF, 0xD8, 0xD7, 0xD7, 0xFF,
	0xD7, 0xD7, 0xD8, 0xFF, 0xD7, 0xD7, 0xD7, 0xFF, 0xD6, 0xD7, 0xD7, 0xFF,
	0xD7, 0xD6, 0xD7, 0xFF, 0xD7, 0xD6, 0xD7, 0xFF, 0xD6, 0xD6, 0xD6, 0xEE,
	0xD6, 0xD5, 0xD6, 0x11, 0xD6, 0xD6, 0xD6, 0x00, 0xD6, 0xD5, 0xD6, 0x00,
	0xD5, 0xD5, 0xD5, 0xFF, 0xD4, 0xD5, 0xD5, 0xFF, 0xD5, 0xD5, 0xD4, 0xFF,
	0xD5, 0xD4, 0xD4, 0xFF, 0xD4, 0xD4, 0xD4, 0xFF, 0xD4, 0xD4, 0xD4, 0xFF,
	0xD4, 0xD3, 0xD3, 0xFF, 0xD4, 0xD3, 0xD3, 0x77, 0xD3, 0xD4, 0xD3, 0x00,
	0xD3, 0xD3, 0xD3, 0x00, 0xD3, 0xD2, 0xD3, 0x00, 0xD2, 0xD2, 0xD2, 0x00,
	0xD2, 0xD2, 0xD3, 0x00, 0xD2, 0xD2, 0xD3, 0x00, 0xD2, 0xD2, 0xD2, 0x00,
	0xD1, 0xD2, 0xD2, 0x00, 0xD1, 0xD2, 0xD2, 0x33, 0xD2, 0xD2, 0xD2, 0xFF,
	0xD1, 0xD1, 0xD1, 0xFF, 0xD1, 0xD1, 0xD2, 0xFF, 0xD1, 0xD2, 0xD1, 0xFF,
	0xD1, 0xD1, 0xD1, 0xFF, 0xD1, 0xD1, 0xD0, 0xFF, 0xD0, 0xD1, 0xD0, 0xBB,
	0xD0, 0xD1, 0xD0, 0xAA, 0xD0, 0xD1, 0xD0, 0xFF, 0xD0, 0xD0, 0xD0, 0xFF,
	0xD0, 0xD0, 0xD0, 0xFF, 0xD0, 0xD0, 0xD0, 0xFF, 0xD0, 0xD0, 0xD0, 0xFF,
	0xD0, 0xD0, 0xD0, 0xFF, 0xD0, 0xD0, 0xD0, 0x33, 0xD0, 0xD0, 0xD0, 0x00,
	0xD0, 0xD0, 0xD0, 0x00, 0xD0, 0xD0, 0xD0, 0x00, 0xD0, 0xD0, 0xD0, 0x00,
	0xD0, 0xD0, 0xD0, 0x00, 0xD0, 0xD0, 0xD0, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xF9, 0xF9, 0xFA, 0xCD, 0xF8, 0xF8, 0xF9, 0xFB,
	0xF7, 0xF7, 0xF7, 0xFF, 0xF6, 0xF6, 0xF6, 0xFF, 0xF5, 0xF5, 0xF5, 0xFF,
	0xF4, 0xF4, 0xF4, 0xFF, 0xF2, 0xF2, 0xF2, 0xFF, 0xF1, 0xF1, 0xF1, 0xFF,
	0xF0, 0xF0, 0xEF, 0xFF, 0xEE, 0xEF, 0xEF, 0xAC, 0xEC, 0xED, 0xED, 0x0C,
	0xEB, 0xEB, 0xEB, 0x01, 0xE9, 0xEA, 0xEA, 0x00, 0xE9, 0xE8, 0xE9, 0x00,
	0xE7, 0xE8, 0xE7, 0x00, 0xE6, 0xE6, 0xE6, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFA, 0xF9, 0xF9, 0x22,
	0xFA, 0xFA, 0xF9, 0xFF, 0xFA, 0xF9, 0xF9, 0xFF, 0xF9, 0xF9, 0xF9, 0xFF,
	0xF9, 0xF9, 0xF9, 0xFF, 0xF9, 0xF9, 0xF9, 0xFF, 0xF8, 0xF9, 0xF9, 0xFF,
	0xF8, 0xF8, 0xF8, 0xFF, 0xF8, 0xF8, 0xF7, 0x99, 0xF8, 0xF8, 0xF7, 0x00,
	0xF7, 0xF8, 0xF8, 0x00, 0xF7, 0xF7, 0xF7, 0x00, 0xF7, 0xF7, 0xF7, 0x00,
	0xF6, 0xF6, 0xF6, 0x00, 0xF6, 0xF6, 0xF6, 0x00, 0xF6, 0xF6, 0xF6, 0x00,
	0xF6, 0xF5, 0xF5, 0x00, 0xF6, 0xF5, 0xF5, 0x00, 0xF5, 0xF5, 0xF5, 0x00,
	0xF5, 0xF5, 0xF5, 0x00, 0xF4, 0xF4, 0xF4, 0x00, 0xF4, 0xF4, 0xF5, 0x00,
	0xF4, 0xF4, 0xF4, 0x00, 0xF3, 0xF3, 0xF4, 0x00, 0xF4, 0xF4, 0xF3, 0x00,
	0xF3, 0xF3, 0xF3, 0x22, 0xF3, 0xF3, 0xF3, 0xFF, 0xF2, 0xF2, 0xF2, 0xFF,
	0xF3, 0xF2, 0xF3, 0xFF, 0xF2, 0xF2, 0xF2, 0xFF, 0xF1, 0xF1, 0xF1, 0xFF,
	0xF1, 0xF1, 0xF1, 0xFF, 0xF1, 0xF1, 0xF1, 0xFF, 0xF1, 0xF1, 0xF0, 0x99,
	0xF0, 0xF1, 0xF0, 0x00, 0xF0, 0xF0, 0xF0, 0x00, 0xEF, 0xEF, 0xF0, 0x00,
	0xF0, 0xF0, 0xEF, 0x00, 0xEF, 0xEF, 0xEF, 0x00, 0xEF, 0xEF, 0xEF, 0x00,
	0xEE, 0xEE, 0xEF, 0x00, 0xEE, 0xEE, 0xEE, 0x99, 0xEE, 0xEE, 0xEE, 0xFF,
	0xEE, 0xEE, 0xED, 0xFF, 0xED, 0xEE, 0xED, 0xFF, 0xED, 0xED, 0xED, 0xFF,
	0xEC, 0xED, 0xEC, 0xFF, 0xEC, 0xEC, 0xEC, 0xFF, 0xEC, 0xEC, 0xEB, 0xFF,
	0xEC, 0xEB, 0xEB, 0x44, 0xEC, 0xEB, 0xEB, 0x00, 0xEB, 0xEB, 0xEB, 0x00,
	0xEA, 0xEA, 0xEA, 0x00, 0xEA, 0xEA, 0xEA, 0x00, 0xE9, 0xEA, 0xEA, 0xFF,
	0xE9, 0xEA, 0xE9, 0xFF, 0xE9, 0xE9, 0xE9, 0xFF, 0xE9, 0xE9, 0xE9, 0xFF,
	0xE8, 0xE9, 0xE8, 0xFF, 0xE8, 0xE8, 0xE8, 0xFF, 0xE7, 0xE8, 0xE8, 0xFF,
	0xE8, 0xE7, 0xE8, 0xFF, 0xE7, 0xE7, 0xE7, 0xFF, 0xE7, 0xE7, 0xE7, 0xFF,
	0xE6, 0xE7, 0xE6, 0xFF, 0xE6, 0xE7, 0xE7, 0xFF, 0xE5, 0xE6, 0xE5, 0xFF,
	0xE5, 0xE6, 0xE5, 0xFF, 0xE5, 0xE5, 0xE5, 0xDD, 0xE5, 0xE4, 0xE5, 0xFF,
	0xE4, 0xE5, 0xE5, 0xFF, 0xE4, 0xE4, 0xE4, 0xFF, 0xE4, 0xE4, 0xE4, 0xFF,
	0xE4, 0xE4, 0xE4, 0xFF, 0xE3, 0xE3, 0xE3, 0xFF, 0xE3, 0xE2, 0xE3, 0xFF,
	0xE3, 0xE2, 0xE3, 0xFF, 0xE2, 0xE2, 0xE2, 0xFF, 0xE2, 0xE2, 0xE2, 0xFF,
	0xE2, 0xE2, 0xE1, 0xFF, 0xE1, 0xE1, 0xE2, 0xFF, 0xE1, 0xE1, 0xE1, 0xFF,
	0xE1, 0xE1, 0xE0, 0x44, 0xE0, 0xE0, 0xE0, 0x00, 0xE0, 0xDF, 0xE0, 0x00,
	0xDF, 0xE0, 0xE0, 0x00, 0xDF, 0xDF, 0xDF, 0x00, 0xDF, 0xDF, 0xDF, 0x00,
	0xDF, 0xDF, 0xDF, 0xFF, 0xDF, 0xDF, 0xDE, 0xFF, 0xDE, 0xDE, 0xDE, 0xFF,
	0xDE, 0xDE, 0xDD, 0xFF, 0xDE, 0xDE, 0xDD, 0xFF, 0xDD, 0xDD, 0xDD, 0xFF,
	0xDD, 0xDD, 0xDD, 0xFF, 0xDD, 0xDD, 0xDC, 0x77, 0xDC, 0xDC, 0xDD, 0x00,
	0xDC, 0xDB, 0xDB, 0x00, 0xDC, 0xDC, 0xDC, 0x00, 0xDB, 0xDC, 0xDC, 0x44,
	0xDB, 0xDB, 0xDB, 0xFF, 0xDA, 0xDA, 0xDB, 0xFF, 0xDB, 0xDA, 0xDB, 0xFF,
	0xDA, 0xDA, 0xDA, 0xFF, 0xD9, 0xDA, 0xDA, 0xFF, 0xDA, 0xDA, 0xD9, 0xFF,
	0xD9, 0xD9, 0xD9, 0xFF, 0xD9, 0xD9, 0xD9, 0xFF, 0xD8, 0xD9, 0xD9, 0xFF,
	0xD8, 0xD9, 0xD8, 0xFF, 0xD9, 0xD9, 0xD9, 0xFF, 0xD8, 0xD8, 0xD8, 0xFF,
	0xD8, 0xD8, 0xD8, 0xFF, 0xD7, 0xD8, 0xD7, 0xFF, 0xD7, 0xD7, 0xD7, 0xAA,
	0xD7, 0xD7, 0xD6, 0x00, 0xD7, 0xD7, 0xD6, 0x00, 0xD7, 0xD7, 0xD6, 0xFF,
	0xD6, 0xD6, 0xD6, 0xFF, 0xD6, 0xD6, 0xD6, 0xFF, 0xD6, 0xD5, 0xD6, 0xFF,
	0xD5, 0xD5, 0xD6, 0xFF, 0xD5, 0xD5, 0xD5, 0xFF, 0xD4, 0xD5, 0xD5, 0xFF,
	0xD5, 0xD5, 0xD5, 0x77, 0xD5, 0xD4, 0xD4, 0x00, 0xD5, 0xD4, 0xD4, 0x00,
	0xD4, 0xD4, 0xD4, 0x00, 0xD4, 0xD4, 0xD4, 0x00, 0xD3, 0xD3, 0xD4, 0x00,
	0xD3, 0xD4, 0xD3, 0x00, 0xD3, 0xD3, 0xD3, 0x00, 0xD3, 0xD3, 0xD3, 0x00,
	0xD3, 0xD2, 0xD3, 0x88, 0xD2, 0xD2, 0xD3, 0xFF, 0xD2, 0xD3, 0xD2, 0xFF,
	0xD2, 0xD2, 0xD2, 0xFF, 0xD2, 0xD2, 0xD2, 0xFF, 0xD2, 0xD2, 0xD1, 0xFF,
	0xD1, 0xD1, 0xD1, 0xFF, 0xD2, 0xD2, 0xD2, 0x77, 0xD1, 0xD1, 0xD2, 0x77,
	0xD1, 0xD1, 0xD1, 0xFF, 0xD1, 0xD1, 0xD1, 0xFF, 0xD0, 0xD0, 0xD1, 0xFF,
	0xD1, 0xD1, 0xD0, 0xFF, 0xD0, 0xD0, 0xD0, 0xFF, 0xD0, 0xD0, 0xD0, 0xFF,
	0xD0, 0xD0, 0xD0, 0x88, 0xD0, 0xD0, 0xD0, 0x00, 0xD0, 0xD0, 0xD0, 0x00,
	0xD0, 0xD0, 0xD0, 0x00, 0xD0, 0xD0, 0xD0, 0x00, 0xD0, 0xD0, 0xD0, 0x00,
	0xD0, 0xD0, 0xD0, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xF9, 0xF9, 0xF9, 0xE9, 0xF9, 0xF9, 0xF8, 0xFF, 0xF8, 0xF8, 0xF8, 0xFF,
	0xF7, 0xF6, 0xF6, 0xFF, 0xF5, 0xF5, 0xF5, 0xFF, 0xF4, 0xF4, 0xF4, 0xFF,
	0xF2, 0xF2, 0xF2, 0xFF, 0xF1, 0xF2, 0xF1, 0xFF, 0xF0, 0xF0, 0xEF, 0xFF,
	0xEE, 0xEF, 0xEE, 0xBA, 0xED, 0xED, 0xED, 0x2B, 0xEB, 0xEC, 0xEB, 0x0D,
	0xEA, 0xEA, 0xEA, 0x01, 0xE8, 0xE9, 0xE8, 0x00, 0xE7, 0xE7, 0xE7, 0x00,
	0xE5, 0xE6, 0xE6, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFB, 0xFB, 0xFB, 0x22, 0xFB, 0xFB, 0xFA, 0xFF,
	0xFB, 0xFA, 0xFA, 0xFF, 0xFA, 0xFB, 0xFB, 0xFF, 0xFA, 0xFA, 0xFA, 0xFF,
	0xF9, 0xFA, 0xFA, 0xFF, 0xF9, 0xFA, 0xFA, 0xFF, 0xF9, 0xFA, 0xF9, 0xFF,
	0xF9, 0xF9, 0xF9, 0x99, 0xF9, 0xF9, 0xF9, 0x00, 0xF8, 0xF9, 0xF8, 0x00,
	0xF9, 0xF9, 0xF8, 0x00, 0xF8, 0xF9, 0xF8, 0x00, 0xF8, 0xF8, 0xF7, 0x00,
	0xF8, 0xF8, 0xF8, 0x00, 0xF7, 0xF8, 0xF8, 0x00, 0xF7, 0xF8, 0xF7, 0x00,
	0xF6, 0xF7, 0xF7, 0x00, 0xF6, 0xF7, 0xF7, 0x00, 0xF7, 0xF7, 0xF6, 0x00,
	0xF6, 0xF6, 0xF6, 0x00, 0xF6, 0xF6, 0xF6, 0x00, 0xF6, 0xF5, 0xF5, 0x00,
	0xF6, 0xF5, 0xF5, 0x00, 0xF5, 0xF5, 0xF5, 0x00, 0xF4, 0xF5, 0xF4, 0x22,
	0xF4, 0xF4, 0xF5, 0xFF, 0xF4, 0xF4, 0xF4, 0xFF, 0xF4, 0xF4, 0xF4, 0xFF,
	0xF3, 0xF4, 0xF3, 0xFF, 0xF3, 0xF4, 0xF3, 0xFF, 0xF3, 0xF3, 0xF3, 0xFF,
	0xF2, 0xF3, 0xF3, 0xFF, 0xF3, 0xF3, 0xF2, 0x99, 0xF2, 0xF2, 0xF2, 0x00,
	0xF1, 0xF2, 0xF2, 0x00, 0xF1, 0xF1, 0xF2, 0x00, 0xF1, 0xF1, 0xF1, 0x00,
	0xF1, 0xF1, 0xF0, 0x00, 0xF1, 0xF1, 0xF1, 0x00, 0xF0, 0xF0, 0xF0, 0x00,
	0xF0, 0xEF, 0xF0, 0x99, 0xEF, 0xEF, 0xF0, 0xFF, 0xEF, 0xEF, 0xEF, 0xFF,
	0xEF, 0xEF, 0xEF, 0xFF, 0xEF, 0xEF, 0xEF, 0xFF, 0xEE, 0xEE, 0xEE, 0xFF,
	0xED, 0xEE, 0xEE, 0xFF, 0xED, 0xEE, 0xED, 0xFF, 0xED, 0xED, 0xED, 0x44,
	0xED, 0xED, 0xED, 0x00, 0xED, 0xED, 0xEC, 0x00, 0xEC, 0xED, 0xEC, 0x00,
	0xEC, 0xEC, 0xEC, 0x00, 0xEB, 0xEC, 0xEC, 0xFF, 0xEB, 0xEB, 0xEC, 0xFF,
	0xEA, 0xEB, 0xEB, 0xFF, 0xEB, 0xEB, 0xEB, 0xFF, 0xEB, 0xEA, 0xEA, 0xFF,
	0xEA, 0xEA, 0xEA, 0xFF, 0xEA, 0xE9, 0xEA, 0xFF, 0xEA, 0xE9, 0xE9, 0xFF,
	0xE9, 0xE9, 0xE9, 0xFF, 0xE9, 0xE9, 0xE8, 0xFF, 0xE8, 0xE8, 0xE8, 0xFF,
	0xE8, 0xE8, 0xE8, 0xFF, 0xE8, 0xE8, 0xE7, 0xFF, 0xE7, 0xE7, 0xE8, 0xFF,
	0xE7, 0xE7, 0xE7, 0xFF, 0xE7, 0xE6, 0xE6, 0xFF, 0xE6, 0xE7, 0xE6, 0xFF,
	0xE6, 0xE5, 0xE6, 0xFF, 0xE6, 0xE6, 0xE6, 0xFF, 0xE5, 0xE6, 0xE6, 0xFF,
	0xE5, 0xE5, 0xE5, 0xFF, 0xE5, 0xE5, 0xE5, 0xFF, 0xE4, 0xE4, 0xE4, 0xFF,
	0xE4, 0xE4, 0xE4, 0xFF, 0xE3, 0xE3, 0xE3, 0xFF, 0xE3, 0xE3, 0xE3, 0xFF,
	0xE3, 0xE3, 0xE3, 0xFF, 0xE3, 0xE3, 0xE2, 0xFF, 0xE2, 0xE2, 0xE2, 0x44,
	0xE2, 0xE2, 0xE2, 0x00, 0xE2, 0xE2, 0xE2, 0x00, 0xE1, 0xE1, 0xE2, 0x00,
	0xE1, 0xE1, 0xE1, 0x00, 0xE0, 0xE0, 0xE0, 0x00, 0xE0, 0xE1, 0xE1, 0xFF,
	0xE0, 0xE0, 0xE0, 0xFF, 0xE0, 0xDF, 0xE0, 0xFF, 0xDF, 0xE0, 0xE0, 0xFF,
	0xE0, 0xDF, 0xDF, 0xFF, 0xDF, 0xDF, 0xDF, 0xFF, 0xDE, 0xDE, 0xDF, 0xFF,
	0xDE, 0xDE, 0xDE, 0x77, 0xDE, 0xDE, 0xDD, 0x00, 0xDE, 0xDE, 0xDE, 0x00,
	0xDD, 0xDD, 0xDD, 0x00, 0xDD, 0xDD, 0xDD, 0x44, 0xDC, 0xDC, 0xDD, 0xFF,
	0xDC, 0xDC, 0xDC, 0xFF, 0xDC, 0xDC, 0xDC, 0xFF, 0xDB, 0xDC, 0xDC, 0xFF,
	0xDB, 0xDC, 0xDC, 0xFF, 0xDB, 0xDB, 0xDB, 0xFF, 0xDB, 0xDA, 0xDB, 0xFF,
	0xDB, 0xDA, 0xDB, 0xFF, 0xDA, 0xDA, 0xDB, 0xFF, 0xDA, 0xDA, 0xDA, 0xFF,
	0xDA, 0xDA, 0xDA, 0xFF, 0xDA, 0xDA, 0xD9, 0xFF, 0xD9, 0xD9, 0xD9, 0xFF,
	0xD9, 0xD9, 0xD9, 0xFF, 0xD9, 0xD8, 0xD9, 0xFF, 0xD8, 0xD8, 0xD8, 0x55,
	0xD8, 0xD8, 0xD8, 0x00, 0xD8, 0xD8, 0xD7, 0xFF, 0xD7, 0xD8, 0xD8, 0xFF,
	0xD7, 0xD7, 0xD7, 0xFF, 0xD7, 0xD7, 0xD7, 0xFF, 0xD7, 0xD6, 0xD7, 0xFF,
	0xD7, 0xD6, 0xD6, 0xFF, 0xD6, 0xD7, 0xD6, 0xFF, 0xD6, 0xD6, 0xD6, 0x77,
	0xD6, 0xD5, 0xD5, 0x00, 0xD5, 0xD6, 0xD5, 0x00, 0xD6, 0xD6, 0xD5, 0x00,
	0xD5, 0xD5, 0xD5, 0x00, 0xD4, 0xD5, 0xD5, 0x00, 0xD5, 0xD5, 0xD5, 0x00,
	0xD4, 0xD4, 0xD4, 0x00, 0xD4, 0xD4, 0xD5, 0x00, 0xD4, 0xD3, 0xD4, 0xEE,
	0xD4, 0xD3, 0xD3, 0xFF, 0xD3, 0xD3, 0xD4, 0xFF, 0xD3, 0xD3, 0xD3, 0xFF,
	0xD3, 0xD3, 0xD3, 0xFF, 0xD2, 0xD3, 0xD3, 0xFF, 0xD2, 0xD2, 0xD2, 0xFF,
	0xD2, 0xD2, 0xD3, 0x33, 0xD2, 0xD2, 0xD2, 0x22, 0xD2, 0xD3, 0xD2, 0xFF,
	0xD2, 0xD2, 0xD2, 0xFF, 0xD2, 0xD1, 0xD2, 0xFF, 0xD1, 0xD2, 0xD1, 0xFF,
	0xD2, 0xD1, 0xD1, 0xFF, 0xD1, 0xD1, 0xD2, 0xFF, 0xD1, 0xD0, 0xD1, 0xEE,
	0xD1, 0xD1, 0xD0, 0x00, 0xD1, 0xD1, 0xD1, 0x00, 0xD0, 0xD0, 0xD0, 0x00,
	0xD0, 0xD0, 0xD1, 0x00, 0xD0, 0xD1, 0xD1, 0x00, 0xD0, 0xD0, 0xD0, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFA, 0xF9, 0xFA, 0xFD,
	0xF9, 0xF9, 0xF9, 0xFF, 0xF7, 0xF8, 0xF8, 0xFF, 0xF6, 0xF6, 0xF6, 0xFF,
	0xF5, 0xF5, 0xF5, 0xFF, 0xF4, 0xF4, 0xF4, 0xFF, 0xF2, 0xF3, 0xF3, 0xFF,
	0xF1, 0xF1, 0xF1, 0xFF, 0xEF, 0xF0, 0xF0, 0xFF, 0xEF, 0xEE, 0xEE, 0xCE,
	0xEE, 0xED, 0xED, 0x56, 0xEC, 0xEC, 0xEB, 0x1C, 0xEA, 0xEA, 0xEA, 0x02,
	0xE9, 0xE9, 0xE9, 0x00, 0xE7, 0xE7, 0xE7, 0x00, 0xE6, 0xE6, 0xE6, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFC, 0xFC, 0xFC, 0x22, 0xFC, 0xFC, 0xFC, 0xFF, 0xFC, 0xFC, 0xFC, 0xFF,
	0xFC, 0xFB, 0xFB, 0xFF, 0xFB, 0xFB, 0xFB, 0xFF, 0xFB, 0xFC, 0xFB, 0xFF,
	0xFB, 0xFB, 0xFB, 0xFF, 0xFB, 0xFB, 0xFB, 0xFF, 0xFB, 0xFB, 0xFA, 0x99,
	0xFA, 0xFA, 0xFB, 0x00, 0xFA, 0xFA, 0xFA, 0x00, 0xF9, 0xFA, 0xFA, 0x00,
	0xF9, 0xFA, 0xFA, 0x00, 0xF9, 0xF9, 0xF9, 0x00, 0xF9, 0xF9, 0xF9, 0x00,
	0xF8, 0xF9, 0xF9, 0x00, 0xF8, 0xF8, 0xF9, 0x00, 0xF8, 0xF9, 0xF8, 0x00,
	0xF8, 0xF8, 0xF8, 0x00, 0xF8, 0xF7, 0xF8, 0x00, 0xF7, 0xF7, 0xF8, 0x00,
	0xF8, 0xF7, 0xF7, 0x00, 0xF7, 0xF7, 0xF7, 0x00, 0xF7, 0xF6, 0xF7, 0x00,
	0xF6, 0xF7, 0xF6, 0x00, 0xF6, 0xF6, 0xF7, 0x22, 0xF6, 0xF6, 0xF6, 0xFF,
	0xF5, 0xF6, 0xF5, 0xFF, 0xF5, 0xF5, 0xF5, 0xFF, 0xF5, 0xF5, 0xF5, 0xFF,
	0xF4, 0xF5, 0xF5, 0xFF, 0xF4, 0xF4, 0xF4, 0xFF, 0xF5, 0xF4, 0xF5, 0xFF,
	0xF4, 0xF4, 0xF4, 0x99, 0xF4, 0xF3, 0xF4, 0x00, 0xF4, 0xF4, 0xF3, 0x00,
	0xF3, 0xF3, 0xF3, 0x00, 0xF3, 0xF3, 0xF2, 0x00, 0xF2, 0xF2, 0xF2, 0x00,
	0xF2, 0xF2, 0xF2, 0x00, 0xF2, 0xF1, 0xF2, 0x00, 0xF2, 0xF1, 0xF1, 0x99,
	0xF1, 0xF1, 0xF1, 0xFF, 0xF1, 0xF1, 0xF1, 0xFF, 0xF0, 0xF0, 0xF0, 0xFF,
	0xF1, 0xF0, 0xF0, 0xFF, 0xF0, 0xF0, 0xF0, 0xFF, 0xEF, 0xF0, 0xF0, 0xFF,
	0xEF, 0xF0, 0xEF, 0xFF, 0xEF, 0xEF, 0xEF, 0x44, 0xEE, 0xEF, 0xEF, 0x00,
	0xEE, 0xEE, 0xEF, 0x00, 0xEE, 0xEE, 0xEE, 0x00, 0xED, 0xED, 0xEE, 0x00,
	0xED, 0xED, 0xED, 0xFF, 0xED, 0xED, 0xED, 0xFF, 0xEC, 0xEC, 0xED, 0xFF,
	0xED, 0xEC, 0xEC, 0xFF, 0xEC, 0xEC, 0xEC, 0xFF, 0xEC, 0xEC, 0xEC, 0xFF,
	0xEB, 0xEB, 0xEB, 0xFF, 0xEB, 0xEB, 0xEB, 0xEE, 0xEB, 0xEA, 0xEA, 0xFF,
	0xEA, 0xEA, 0xEB, 0xFF, 0xEA, 0xEB, 0xEA, 0xFF, 0xEA, 0xE9, 0xEA, 0xFF,
	0xE9, 0xE9, 0xE9, 0xFF, 0xE9, 0xE9, 0xE9, 0xFF, 0xE9, 0xE9, 0xE9, 0xFF,
	0xE8, 0xE9, 0xE8, 0xFF, 0xE8, 0xE8, 0xE8, 0xFF, 0xE8, 0xE7, 0xE8, 0xFF,
	0xE7, 0xE8, 0xE8, 0xFF, 0xE7, 0xE7, 0xE7, 0xFF, 0xE6, 0xE6, 0xE6, 0xEE,
	0xE7, 0xE7, 0xE7, 0xFF, 0xE6, 0xE6, 0xE6, 0xFF, 0xE6, 0xE6, 0xE5, 0xFF,
	0xE5, 0xE5, 0xE5, 0xFF, 0xE5, 0xE5, 0xE5, 0xFF, 0xE5, 0xE5, 0xE5, 0xFF,
	0xE5, 0xE5, 0xE4, 0xFF, 0xE4, 0xE4, 0xE4, 0x44, 0xE4, 0xE4, 0xE4, 0x00,
	0xE4, 0xE3, 0xE3, 0x00, 0xE3, 0xE3, 0xE3, 0x00, 0xE3, 0xE3, 0xE3, 0x00,
	0xE2, 0xE2, 0xE3, 0x00, 0xE2, 0xE2, 0xE2, 0xFF, 0xE2, 0xE1, 0xE1, 0xFF,
	0xE1, 0xE2, 0xE2, 0xFF, 0xE1, 0xE2, 0xE1, 0xFF, 0xE1, 0xE1, 0xE1, 0xFF,
	0xE1, 0xE0, 0xE0, 0xFF, 0xE0, 0xE1, 0xE0, 0xFF, 0xE0, 0xE0, 0xE0, 0x77,
	0xDF, 0xE0, 0xE0, 0x00, 0xDF, 0xE0, 0xDF, 0x00, 0xDF, 0xDF, 0xDE, 0x00,
	0xDE, 0xDE, 0xDF, 0x44, 0xDE, 0xDE, 0xDF, 0xFF, 0xDE, 0xDE, 0xDE, 0xFF,
	0xDD, 0xDD, 0xDE, 0xFF, 0xDE, 0xDD, 0xDD, 0xFF, 0xDD, 0xDD, 0xDD, 0xFF,
	0xDC, 0xDD, 0xDC, 0xFF, 0xDD, 0xDD, 0xDC, 0xFF, 0xDC, 0xDC, 0xDC, 0xBB,
	0xDC, 0xDC, 0xDB, 0xFF, 0xDB, 0xDB, 0xDC, 0xFF, 0xDB, 0xDB, 0xDB, 0xFF,
	0xDB, 0xDA, 0xDB, 0xFF, 0xDB, 0xDB, 0xDA, 0xFF, 0xDA, 0xDB, 0xDA, 0xFF,
	0xDA, 0xDA, 0xDA, 0xFF, 0xDA, 0xDA, 0xD9, 0xDD, 0xD9, 0xDA, 0xD9, 0x11,
	0xD9, 0xDA, 0xDA, 0xFF, 0xD9, 0xD9, 0xD9, 0xFF, 0xD9, 0xD8, 0xD9, 0xFF,
	0xD8, 0xD8, 0xD8, 0xFF, 0xD8, 0xD8, 0xD8, 0xFF, 0xD7, 0xD7, 0xD8, 0xFF,
	0xD7, 0xD8, 0xD8, 0xFF, 0xD7, 0xD7, 0xD7, 0x77, 0xD7, 0xD7, 0xD8, 0x00,
	0xD7, 0xD7, 0xD6, 0x00, 0xD6, 0xD7, 0xD6, 0x00, 0xD6, 0xD6, 0xD7, 0x00,
	0xD6, 0xD6, 0xD7, 0x00, 0xD6, 0xD6, 0xD6, 0x00, 0xD5, 0xD5, 0xD5, 0x00,
	0xD5, 0xD5, 0xD5, 0x55, 0xD5, 0xD5, 0xD5, 0xFF, 0xD5, 0xD5, 0xD5, 0xFF,
	0xD5, 0xD5, 0xD5, 0xFF, 0xD4, 0xD5, 0xD5, 0xFF, 0xD4, 0xD4, 0xD4, 0xFF,
	0xD4, 0xD4, 0xD4, 0xFF, 0xD4, 0xD4, 0xD3, 0xCC, 0xD3, 0xD4, 0xD3, 0x00,
	0xD4, 0xD3, 0xD3, 0x00, 0xD3, 0xD3, 0xD3, 0xCC, 0xD3, 0xD3, 0xD3, 0xFF,
	0xD3, 0xD3, 0xD2, 0xFF, 0xD3, 0xD2, 0xD2, 0xFF, 0xD2, 0xD2, 0xD2, 0xFF,
	0xD2, 0xD2, 0xD2, 0xFF, 0xD1, 0xD2, 0xD2, 0xFF, 0xD1, 0xD1, 0xD1, 0x55,
	0xD1, 0xD1, 0xD1, 0x00, 0xD1, 0xD2, 0xD1, 0x00, 0xD2, 0xD2, 0xD1, 0x00,
	0xD1, 0xD1, 0xD1, 0x00, 0xD1, 0xD1, 0xD1, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFA, 0xFA, 0xFA, 0xFD, 0xF9, 0xF9, 0xF9, 0xFF,
	0xF8, 0xF8, 0xF7, 0xFF, 0xF7, 0xF7, 0xF6, 0xFF, 0xF5, 0xF5, 0xF5, 0xFF,
	0xF4, 0xF4, 0xF4, 0xFF, 0xF2, 0xF3, 0xF3, 0xFF, 0xF2, 0xF2, 0xF2, 0xFF,
	0xF0, 0xF1, 0xF0, 0xFF, 0xEF, 0xEE, 0xEF, 0xE8, 0xED, 0xED, 0xEE, 0x91,
	0xEB, 0xEC, 0xEC, 0x37, 0xEA, 0xEA, 0xEB, 0x00, 0xE9, 0xE9, 0xE9, 0x00,
	0xE8, 0xE8, 0xE7, 0x00, 0xE6, 0xE6, 0xE6, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFE, 0xFE, 0xFD, 0x22,
	0xFD, 0xFD, 0xFD, 0xFF, 0xFD, 0xFD, 0xFD, 0xFF, 0xFD, 0xFD, 0xFD, 0xFF,
	0xFD, 0xFC, 0xFD, 0xFF, 0xFC, 0xFC, 0xFC, 0xFF, 0xFC, 0xFC, 0xFC, 0xFF,
	0xFB, 0xFB, 0xFC, 0xFF, 0xFB, 0xFC, 0xFC, 0x99, 0xFC, 0xFC, 0xFB, 0x00,
	0xFB, 0xFB, 0xFB, 0x00, 0xFB, 0xFB, 0xFB, 0x00, 0xFB, 0xFB, 0xFB, 0x00,
	0xFB, 0xFB, 0xFA, 0x00, 0xFA, 0xFA, 0xFA, 0x00, 0xFA, 0xFA, 0xFA, 0x00,
	0xF9, 0xFA, 0xFA, 0x00, 0xFA, 0xF9, 0xFA, 0x00, 0xFA, 0xF9, 0xF9, 0x00,
	0xF9, 0xF9, 0xFA, 0x00, 0xF9, 0xF9, 0xF9, 0x00, 0xF9, 0xF9, 0xF9, 0x00,
	0xF8, 0xF8, 0xF9, 0x00, 0xF8, 0xF8, 0xF8, 0x00, 0xF8, 0xF7, 0xF7, 0x00,
	0xF7, 0xF7, 0xF7, 0x22, 0xF7, 0xF8, 0xF7, 0xFF, 0xF7, 0xF7, 0xF7, 0xFF,
	0xF7, 0xF7, 0xF7, 0xFF, 0xF7, 0xF7, 0xF6, 0xFF, 0xF6, 0xF6, 0xF6, 0xFF,
	0xF6, 0xF6, 0xF6, 0xFF, 0xF5, 0xF5, 0xF6, 0xFF, 0xF5, 0xF5, 0xF5, 0x99,
	0xF5, 0xF5, 0xF5, 0x00, 0xF5, 0xF5, 0xF4, 0x00, 0xF4, 0xF5, 0xF4, 0x00,
	0xF4, 0xF4, 0xF4, 0x00, 0xF4, 0xF4, 0xF4, 0x00, 0xF4, 0xF4, 0xF3, 0x00,
	0xF3, 0xF3, 0xF4, 0x00, 0xF3, 0xF3, 0xF3, 0x99, 0xF2, 0xF2, 0xF3, 0xFF,
	0xF2, 0xF3, 0xF3, 0xFF, 0xF2, 0xF2, 0xF2, 0xFF, 0xF2, 0xF2, 0xF2, 0xFF,
	0xF1, 0xF1, 0xF2, 0xFF, 0xF1, 0xF1, 0xF1, 0xFF, 0xF1, 0xF1, 0xF1, 0xFF,
	0xF1, 0xF0, 0xF0, 0x44, 0xF0, 0xF1, 0xF1, 0x00, 0xF0, 0xF0, 0xF0, 0x00,
	0xEF, 0xEF, 0xF0, 0x00, 0xEF, 0xEF, 0xEF, 0x00, 0xEF, 0xEF, 0xEF, 0xFF,
	0xEE, 0xEF, 0xEF, 0xFF, 0xEE, 0xEE, 0xEE, 0xFF, 0xEE, 0xEE, 0xEE, 0xFF,
	0xEE, 0xEE, 0xEE, 0xFF, 0xED, 0xED, 0xEE, 0xFF, 0xED, 0xED, 0xED, 0xFF,
	0xED, 0xEC, 0xED, 0x77, 0xED, 0xEC, 0xEC, 0xFF, 0xEC, 0xEC, 0xEC, 0xFF,
	0xEC, 0xEC, 0xEC, 0xFF, 0xEC, 0xEB, 0xEC, 0xFF, 0xEB, 0xEB, 0xEB, 0xFF,
	0xEA, 0xEA, 0xEB, 0xFF, 0xEA, 0xEB, 0xEA, 0xFF, 0xEA, 0xEA, 0xEA, 0xFF,
	0xEA, 0xEA, 0xE9, 0xFF, 0xEA, 0xE9, 0xE9, 0xFF, 0xE9, 0xE9, 0xEA, 0xFF,
	0xE8, 0xE8, 0xE9, 0xFF, 0xE9, 0xE8, 0xE8, 0x77, 0xE9, 0xE8, 0xE8, 0xFF,
	0xE8, 0xE7, 0xE8, 0xFF, 0xE7, 0xE8, 0xE8, 0xFF, 0xE7, 0xE7, 0xE7, 0xFF,
	0xE7, 0xE7, 0xE7, 0xFF, 0xE6, 0xE6, 0xE7, 0xFF, 0xE6, 0xE6, 0xE7, 0xFF,
	0xE5, 0xE6, 0xE6, 0x44, 0xE5, 0xE5, 0xE5, 0x00, 0xE5, 0xE6, 0xE5, 0x00,
	0xE5, 0xE5, 0xE5, 0x00, 0xE5, 0xE4, 0xE4, 0x00, 0xE4, 0xE5, 0xE4, 0x00,
	0xE4, 0xE4, 0xE4, 0xFF, 0xE4, 0xE4, 0xE4, 0xFF, 0xE3, 0xE3, 0xE3, 0xFF,
	0xE3, 0xE3, 0xE2, 0xFF, 0xE3, 0xE3, 0xE2, 0xFF, 0xE3, 0xE3, 0xE3, 0xFF,
	0xE2, 0xE2, 0xE2, 0xFF, 0xE1, 0xE2, 0xE1, 0x77, 0xE1, 0xE1, 0xE2, 0x00,
	0xE1, 0xE1, 0xE1, 0x00, 0xE0, 0xE1, 0xE1, 0x00, 0xE0, 0xE1, 0xE1, 0x44,
	0xE0, 0xE0, 0xDF, 0xFF, 0xE0, 0xDF, 0xDF, 0xFF, 0xDF, 0xDF, 0xE0, 0xFF,
	0xDF, 0xDF, 0xDF, 0xFF, 0xDE, 0xDF, 0xDF, 0xFF, 0xDE, 0xDF, 0xDF, 0xFF,
	0xDE, 0xDE, 0xDE, 0xFF, 0xDE, 0xDE, 0xDE, 0x44, 0xDE, 0xDE, 0xDD, 0xCC,
	0xDD, 0xDD, 0xDD, 0xFF, 0xDC, 0xDC, 0xDD, 0xFF, 0xDC, 0xDD, 0xDD, 0xFF,
	0xDC, 0xDD, 0xDC, 0xFF, 0xDB, 0xDC, 0xDC, 0xFF, 0xDC, 0xDB, 0xDC, 0xFF,
	0xDB, 0xDC, 0xDB, 0xFF, 0xDB, 0xDB, 0xDB, 0x88, 0xDB, 0xDB, 0xDB, 0xFF,
	0xDA, 0xDA, 0xDB, 0xFF, 0xDB, 0xDA, 0xDA, 0xFF, 0xDA, 0xDA, 0xDA, 0xFF,
	0xD9, 0xDA, 0xDA, 0xFF, 0xD9, 0xD9, 0xD9, 0xFF, 0xD9, 0xD9, 0xD9, 0xFF,
	0xD8, 0xD8, 0xD9, 0x77, 0xD8, 0xD8, 0xD9, 0x00, 0xD8, 0xD8, 0xD8, 0x00,
	0xD8, 0xD8, 0xD8, 0x00, 0xD7, 0xD8, 0xD8, 0x00, 0xD8, 0xD8, 0xD7, 0x00,
	0xD7, 0xD7, 0xD7, 0x00, 0xD7, 0xD7, 0xD7, 0x00, 0xD7, 0xD6, 0xD7, 0xAA,
	0xD6, 0xD6, 0xD6, 0xFF, 0xD6, 0xD6, 0xD6, 0xFF, 0xD6, 0xD6, 0xD6, 0xFF,
	0xD5, 0xD6, 0xD6, 0xFF, 0xD5, 0xD5, 0xD5, 0xFF, 0xD5, 0xD5, 0xD5, 0xFF,
	0xD5, 0xD5, 0xD5, 0x88, 0xD5, 0xD4, 0xD5, 0x00, 0xD4, 0xD5, 0xD5, 0x00,
	0xD4, 0xD4, 0xD4, 0x88, 0xD4, 0xD4, 0xD4, 0xFF, 0xD4, 0xD4, 0xD4, 0xFF,
	0xD3, 0xD3, 0xD3, 0xFF, 0xD3, 0xD4, 0xD3, 0xFF, 0xD3, 0xD3, 0xD3, 0xFF,
	0xD3, 0xD3, 0xD3, 0xFF, 0xD3, 0xD3, 0xD3, 0xAA, 0xD3, 0xD2, 0xD3, 0x00,
	0xD3, 0xD2, 0xD2, 0x00, 0xD2, 0xD3, 0xD2, 0x00, 0xD2, 0xD2, 0xD2, 0x00,
	0xD2, 0xD2, 0xD2, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFA, 0xFA, 0xFA, 0xEB, 0xF9, 0xF9, 0xF9, 0xFF, 0xF8, 0xF7, 0xF7, 0xFF,
	0xF7, 0xF6, 0xF6, 0xFF, 0xF6, 0xF5, 0xF5, 0xFF, 0xF4, 0xF4, 0xF5, 0xFF,
	0xF3, 0xF3, 0xF3, 0xFF, 0xF2, 0xF1, 0xF2, 0xFF, 0xF0, 0xF0, 0xF1, 0xFF,
	0xEF, 0xEF, 0xEF, 0xFC, 0xEE, 0xED, 0xED, 0xCF, 0xEC, 0xEC, 0xEC, 0x6A,
	0xEB, 0xEB, 0xEB, 0x10, 0xE9, 0xEA, 0xE9, 0x00, 0xE7, 0xE7, 0xE8, 0x00,
	0xE7, 0xE6, 0xE7, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFE, 0xFE, 0x22, 0xFE, 0xFE, 0xFE, 0xFF,
	0xFE, 0xFE, 0xFE, 0xFF, 0xFE, 0xFE, 0xFE, 0xFF, 0xFE, 0xFE, 0xFE, 0xFF,
	0xFD, 0xFD, 0xFD, 0xFF, 0xFD, 0xFD, 0xFD, 0xFF, 0xFD, 0xFD, 0xFD, 0xFF,
	0xFD, 0xFC, 0xFD, 0x99, 0xFC, 0xFC, 0xFC, 0x00, 0xFD, 0xFC, 0xFD, 0x00,
	0xFC, 0xFC, 0xFC, 0x00, 0xFC, 0xFC, 0xFC, 0x00, 0xFC, 0xFC, 0xFC, 0x00,
	0xFB, 0xFC, 0xFC, 0x00, 0xFC, 0xFB, 0xFB, 0x00, 0xFB, 0xFB, 0xFB, 0x00,
	0xFB, 0xFB, 0xFB, 0x00, 0xFA, 0xFA, 0xFB, 0x00, 0xFA, 0xFA, 0xFA, 0x00,
	0xFB, 0xFB, 0xFA, 0x00, 0xFA, 0xFA, 0xFA, 0x00, 0xF9, 0xF9, 0xF9, 0x00,
	0xFA, 0xF9, 0xF9, 0x00, 0xF9, 0xF9, 0xF9, 0x00, 0xF9, 0xF9, 0xF8, 0x22,
	0xF9, 0xF8, 0xF9, 0xFF, 0xF8, 0xF8, 0xF9, 0xFF, 0xF8, 0xF9, 0xF8, 0xFF,
	0xF8, 0xF8, 0xF8, 0xFF, 0xF8, 0xF8, 0xF8, 0xFF, 0xF7, 0xF8, 0xF7, 0xFF,
	0xF7, 0xF8, 0xF7, 0xFF, 0xF7, 0xF7, 0xF7, 0x99, 0xF7, 0xF7, 0xF7, 0x00,
	0xF7, 0xF7, 0xF6, 0x00, 0xF6, 0xF6, 0xF6, 0x00, 0xF6, 0xF5, 0xF6, 0x00,
	0xF5, 0xF6, 0xF5, 0x00, 0xF6, 0xF6, 0xF6, 0x00, 0xF4, 0xF5, 0xF5, 0x00,
	0xF4, 0xF5, 0xF4, 0x99, 0xF4, 0xF5, 0xF5, 0xFF, 0xF4, 0xF4, 0xF4, 0xFF,
	0xF4, 0xF4, 0xF4, 0xFF, 0xF4, 0xF4, 0xF3, 0xFF, 0xF3, 0xF3, 0xF4, 0xFF,
	0xF3, 0xF3, 0xF3, 0xFF, 0xF3, 0xF3, 0xF3, 0xFF, 0xF2, 0xF3, 0xF3, 0x44,
	0xF2, 0xF1, 0xF2, 0x00, 0xF1, 0xF2, 0xF2, 0x00, 0xF1, 0xF2, 0xF1, 0x00,
	0xF1, 0xF1, 0xF1, 0x00, 0xF0, 0xF1, 0xF0, 0xFF, 0xF0, 0xF0, 0xF0, 0xFF,
	0xF0, 0xF0, 0xF0, 0xFF, 0xEF, 0xEF, 0xEF, 0xFF, 0xF0, 0xEF, 0xEF, 0xFF,
	0xF0, 0xEF, 0xEF, 0xFF, 0xEE, 0xEF, 0xEF, 0xFF, 0xEF, 0xEF, 0xEF, 0x44,
	0xEE, 0xEE, 0xEE, 0x99, 0xEE, 0xEE, 0xEE, 0xFF, 0xED, 0xED, 0xEE, 0xFF,
	0xED, 0xED, 0xED, 0xFF, 0xED, 0xED, 0xED, 0xFF, 0xED, 0xED, 0xED, 0xFF,
	0xEC, 0xEC, 0xEC, 0xFF, 0xEC, 0xEC, 0xEC, 0xFF, 0xEB, 0xEB, 0xEB, 0xFF,
	0xEC, 0xEB, 0xEB, 0xFF, 0xEB, 0xEB, 0xEB, 0xFF, 0xEB, 0xEA, 0xEB, 0xDD,
	0xEA, 0xEA, 0xEA, 0x00, 0xEA, 0xEA, 0xEA, 0xFF, 0xEA, 0xE9, 0xE9, 0xFF,
	0xEA, 0xE9, 0xEA, 0xFF, 0xE9, 0xE8, 0xE9, 0xFF, 0xE9, 0xE8, 0xE8, 0xFF,
	0xE8, 0xE8, 0xE8, 0xFF, 0xE8, 0xE8, 0xE8, 0xFF, 0xE7, 0xE8, 0xE8, 0x44,
	0xE7, 0xE7, 0xE7, 0x00, 0xE7, 0xE7, 0xE7, 0x00, 0xE7, 0xE7, 0xE7, 0x00,
	0xE6, 0xE6, 0xE7, 0x00, 0xE6, 0xE6, 0xE6, 0x00, 0xE6, 0xE6, 0xE5, 0xFF,
	0xE5, 0xE5, 0xE5, 0xFF, 0xE5, 0xE5, 0xE5, 0xFF, 0xE4, 0xE5, 0xE5, 0xFF,
	0xE4, 0xE4, 0xE4, 0xFF, 0xE4, 0xE4, 0xE4, 0xFF, 0xE3, 0xE4, 0xE3, 0xFF,
	0xE3, 0xE3, 0xE3, 0x77, 0xE3, 0xE3, 0xE3, 0x00, 0xE3, 0xE3, 0xE2, 0x00,
	0xE2, 0xE2, 0xE2, 0x00, 0xE2, 0xE2, 0xE2, 0x44, 0xE1, 0xE2, 0xE2, 0xFF,
	0xE1, 0xE1, 0xE1, 0xFF, 0xE1, 0xE1, 0xE1, 0xFF, 0xE1, 0xE1, 0xE1, 0xFF,
	0xE0, 0xE0, 0xE0, 0xFF, 0xE0, 0xE0, 0xE0, 0xFF, 0xE0, 0xDF, 0xE0, 0xFF,
	0xDF, 0xDF, 0xE0, 0x44, 0xDF, 0xDF, 0xDF, 0x33, 0xDF, 0xDF, 0xDE, 0xFF,
	0xDF, 0xDE, 0xDE, 0xFF, 0xDE, 0xDE, 0xDE, 0xFF, 0xDD, 0xDE, 0xDE, 0xFF,
	0xDE, 0xDD, 0xDD, 0xFF, 0xDD, 0xDD, 0xDD, 0xFF, 0xDD, 0xDD, 0xDD, 0xFF,
	0xDD, 0xDC, 0xDC, 0xFF, 0xDC, 0xDC, 0xDC, 0xFF, 0xDC, 0xDC, 0xDC, 0xFF,
	0xDC, 0xDC, 0xDB, 0xFF, 0xDC, 0xDB, 0xDC, 0xFF, 0xDC, 0xDB, 0xDB, 0xFF,
	0xDA, 0xDA, 0xDB, 0xFF, 0xDA, 0xDB, 0xDA, 0xFF, 0xDA, 0xDA, 0xDB, 0x77,
	0xDA, 0xDA, 0xDA, 0x00, 0xDA, 0xDA, 0xD9, 0x00, 0xDA, 0xD9, 0xD9, 0x00,
	0xD9, 0xD9, 0xD9, 0x00, 0xD9, 0xD9, 0xD9, 0x00, 0xD9, 0xD9, 0xD9, 0x00,
	0xD8, 0xD8, 0xD9, 0x11, 0xD8, 0xD8, 0xD8, 0xFF, 0xD7, 0xD7, 0xD8, 0xFF,
	0xD7, 0xD7, 0xD7, 0xFF, 0xD7, 0xD7, 0xD7, 0xFF, 0xD7, 0xD7, 0xD7, 0xFF,
	0xD6, 0xD7, 0xD7, 0xFF, 0xD7, 0xD6, 0xD7, 0xFF, 0xD6, 0xD6, 0xD6, 0x33,
	0xD6, 0xD6, 0xD6, 0x00, 0xD6, 0xD6, 0xD6, 0x00, 0xD5, 0xD5, 0xD6, 0x44,
	0xD5, 0xD5, 0xD5, 0xFF, 0xD5, 0xD5, 0xD5, 0xFF, 0xD5, 0xD5, 0xD5, 0xFF,
	0xD5, 0xD4, 0xD4, 0xFF, 0xD4, 0xD4, 0xD4, 0xFF, 0xD4, 0xD4, 0xD5, 0xFF,
	0xD4, 0xD4, 0xD4, 0xFF, 0xD4, 0xD4, 0xD3, 0x11, 0xD4, 0xD3, 0xD4, 0x00,
	0xD3, 0xD3, 0xD3, 0x00, 0xD3, 0xD3, 0xD3, 0x00, 0xD3, 0xD2, 0xD3, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFA, 0xFA, 0xFA, 0xCF,
	0xF9, 0xF9, 0xF9, 0xFC, 0xF8, 0xF8, 0xF8, 0xFF, 0xF7, 0xF7, 0xF7, 0xFF,
	0xF5, 0xF5, 0xF6, 0xFF, 0xF4, 0xF4, 0xF4, 0xFF, 0xF3, 0xF3, 0xF3, 0xFF,
	0xF2, 0xF2, 0xF2, 0xFF, 0xF0, 0xF0, 0xF0, 0xFF, 0xEF, 0xEF, 0xEF, 0xFF,
	0xEE, 0xEE, 0xEE, 0xF6, 0xEC, 0xEC, 0xEC, 0xB0, 0xEB, 0xEA, 0xEB, 0x4D,
	0xE9, 0xE9, 0xEA, 0x0B, 0xE8, 0xE8, 0xE8, 0x00, 0xE7, 0xE6, 0xE6, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x22, 0xFE, 0xFE, 0xFF, 0xFF, 0xFE, 0xFE, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFE, 0xFF, 0xFF, 0xFE, 0xFF, 0xFE, 0xFF,
	0xFE, 0xFE, 0xFE, 0xFF, 0xFE, 0xFE, 0xFE, 0xFF, 0xFE, 0xFE, 0xFE, 0x99,
	0xFE, 0xFE, 0xFD, 0x00, 0xFE, 0xFD, 0xFD, 0x00, 0xFD, 0xFD, 0xFD, 0x00,
	0xFD, 0xFD, 0xFD, 0x00, 0xFD, 0xFD, 0xFC, 0x00, 0xFC, 0xFC, 0xFC, 0x00,
	0xFC, 0xFD, 0xFD, 0x00, 0xFC, 0xFD, 0xFC, 0x00, 0xFC, 0xFC, 0xFC, 0x00,
	0xFB, 0xFB, 0xFC, 0x00, 0xFB, 0xFB, 0xFC, 0x00, 0xFB, 0xFB, 0xFC, 0x00,
	0xFB, 0xFB, 0xFB, 0x00, 0xFB, 0xFB, 0xFB, 0x00, 0xFA, 0xFB, 0xFB, 0x00,
	0xFA, 0xFB, 0xFA, 0x00, 0xFB, 0xFA, 0xFA, 0x22, 0xFA, 0xFA, 0xFA, 0xFF,
	0xFA, 0xF9, 0xFA, 0xFF, 0xF9, 0xF9, 0xFA, 0xFF, 0xF9, 0xF9, 0xF9, 0xFF,
	0xF9, 0xF9, 0xF9, 0xFF, 0xF9, 0xF9, 0xF8, 0xFF, 0xF8, 0xF9, 0xF9, 0xFF,
	0xF8, 0xF9, 0xF8, 0x99, 0xF8, 0xF8, 0xF8, 0x00, 0xF7, 0xF8, 0xF8, 0x00,
	0xF8, 0xF7, 0xF7, 0x00, 0xF8, 0xF7, 0xF8, 0x00, 0xF7, 0xF7, 0xF7, 0x00,
	0xF7, 0xF6, 0xF7, 0x00, 0xF7, 0xF7, 0xF7, 0x00, 0xF6, 0xF6, 0xF6, 0x99,
	0xF6, 0xF6, 0xF5, 0xFF, 0xF6, 0xF6, 0xF6, 0xFF, 0xF6, 0xF5, 0xF5, 0xFF,
	0xF5, 0xF5, 0xF5, 0xFF, 0xF5, 0xF5, 0xF5, 0xFF, 0xF4, 0xF4, 0xF4, 0xFF,
	0xF4, 0xF4, 0xF4, 0xFF, 0xF4, 0xF4, 0xF4, 0x44, 0xF3, 0xF4, 0xF4, 0x00,
	0xF3, 0xF3, 0xF4, 0x00, 0xF3, 0xF3, 0xF3, 0x00, 0xF3, 0xF2, 0xF2, 0x00,
	0xF3, 0xF2, 0xF2, 0xFF, 0xF2, 0xF2, 0xF2, 0xFF, 0xF2, 0xF2, 0xF2, 0xFF,
	0xF2, 0xF2, 0xF1, 0xFF, 0xF1, 0xF1, 0xF1, 0xFF, 0xF0, 0xF1, 0xF1, 0xFF,
	0xF1, 0xF1, 0xF0, 0xFF, 0xF0, 0xF1, 0xF0, 0x44, 0xF0, 0xF0, 0xF0, 0x11,
	0xF0, 0xF0, 0xEF, 0xEE, 0xEF, 0xEF, 0xF0, 0xFF, 0xEF, 0xEE, 0xEF, 0xFF,
	0xEF, 0xEE, 0xEE, 0xFF, 0xEE, 0xEE, 0xEE, 0xFF, 0xEE, 0xEE, 0xEE, 0xFF,
	0xEE, 0xED, 0xEE, 0xFF, 0xED, 0xED, 0xED, 0xFF, 0xED, 0xED, 0xED, 0xFF,
	0xED, 0xEC, 0xED, 0xFF, 0xEC, 0xEC, 0xED, 0x44, 0xEC, 0xEC, 0xEC, 0x00,
	0xEC, 0xEB, 0xEC, 0xFF, 0xEB, 0xEB, 0xEC, 0xFF, 0xEB, 0xEB, 0xEB, 0xFF,
	0xEB, 0xEB, 0xEB, 0xFF, 0xEA, 0xEA, 0xEB, 0xFF, 0xEA, 0xEA, 0xEA, 0xFF,
	0xE9, 0xEA, 0xE9, 0xFF, 0xE9, 0xE9, 0xE9, 0x44, 0xE9, 0xE9, 0xE9, 0x00,
	0xE9, 0xE9, 0xE9, 0x00, 0xE8, 0xE8, 0xE8, 0x00, 0xE8, 0xE8, 0xE8, 0x00,
	0xE8, 0xE8, 0xE8, 0x00, 0xE7, 0xE7, 0xE7, 0xFF, 0xE7, 0xE7, 0xE7, 0xFF,
	0xE7, 0xE6, 0xE7, 0xFF, 0xE6, 0xE7, 0xE6, 0xFF, 0xE6, 0xE6, 0xE6, 0xFF,
	0xE6, 0xE5, 0xE5, 0xFF, 0xE6, 0xE6, 0xE6, 0xFF, 0xE5, 0xE5, 0xE5, 0x77,
	0xE4, 0xE5, 0xE5, 0x00, 0xE5, 0xE5, 0xE4, 0x00, 0xE4, 0xE4, 0xE4, 0x00,
	0xE3, 0xE4, 0xE4, 0x44, 0xE4, 0xE3, 0xE3, 0xFF, 0xE3, 0xE3, 0xE3, 0xFF,
	0xE2, 0xE3, 0xE3, 0xFF, 0xE2, 0xE2, 0xE2, 0xFF, 0xE3, 0xE2, 0xE2, 0xFF,
	0xE1, 0xE2, 0xE2, 0xFF, 0xE1, 0xE1, 0xE2, 0xFF, 0xE2, 0xE1, 0xE1, 0x44,
	0xE1, 0xE0, 0xE0, 0x00, 0xE0, 0xE1, 0xE0, 0x77, 0xE1, 0xE0, 0xE0, 0xFF,
	0xE0, 0xE0, 0xE0, 0xFF, 0xE0, 0xDF, 0xE0, 0xFF, 0xDF, 0xDF, 0xDF, 0xFF,
	0xDF, 0xDF, 0xDF, 0xFF, 0xDE, 0xDE, 0xDF, 0xFF, 0xDF, 0xDE, 0xDF, 0xFF,
	0xDE, 0xDE, 0xDE, 0xFF, 0xDE, 0xDD, 0xDE, 0xFF, 0xDD, 0xDD, 0xDD, 0xFF,
	0xDD, 0xDD, 0xDD, 0xFF, 0xDC, 0xDD, 0xDD, 0xFF, 0xDD, 0xDC, 0xDC, 0xFF,
	0xDD, 0xDC, 0xDC, 0xFF, 0xDC, 0xDC, 0xDC, 0x77, 0xDC, 0xDC, 0xDB, 0x00,
	0xDB, 0xDB, 0xDC, 0x00, 0xDB, 0xDB, 0xDB, 0x00, 0xDA, 0xDA, 0xDA, 0x00,
	0xDB, 0xDA, 0xDB, 0x00, 0xDA, 0xDA, 0xDA, 0x00, 0xDA, 0xDA, 0xDA, 0x77,
	0xDA, 0xDA, 0xDA, 0xFF, 0xD9, 0xD9, 0xD9, 0xFF, 0xD9, 0xD9, 0xD9, 0xFF,
	0xD9, 0xD9, 0xD8, 0xFF, 0xD8, 0xD9, 0xD8, 0xFF, 0xD8, 0xD8, 0xD8, 0xFF,
	0xD8, 0xD7, 0xD8, 0xEE, 0xD7, 0xD7, 0xD7, 0x00, 0xD7, 0xD7, 0xD7, 0x00,
	0xD7, 0xD7, 0xD7, 0x00, 0xD7, 0xD7, 0xD7, 0x00, 0xD7, 0xD7, 0xD7, 0xEE,
	0xD7, 0xD6, 0xD7, 0xFF, 0xD6, 0xD6, 0xD6, 0xFF, 0xD5, 0xD5, 0xD6, 0xFF,
	0xD6, 0xD6, 0xD6, 0xFF, 0xD5, 0xD6, 0xD6, 0xFF, 0xD5, 0xD5, 0xD5, 0xFF,
	0xD5, 0xD5, 0xD5, 0x77, 0xD5, 0xD4, 0xD5, 0x00, 0xD5, 0xD5, 0xD4, 0x00,
	0xD4, 0xD4, 0xD4, 0x00, 0xD4, 0xD4, 0xD4, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFA, 0xFA, 0xFA, 0xA7, 0xF9, 0xF9, 0xF9, 0xF1,
	0xF8, 0xF8, 0xF8, 0xFF, 0xF7, 0xF7, 0xF7, 0xFF, 0xF6, 0xF5, 0xF6, 0xFF,
	0xF4, 0xF4, 0xF4, 0xFF, 0xF3, 0xF3, 0xF3, 0xFF, 0xF2, 0xF2, 0xF2, 0xFF,
	0xF0, 0xF0, 0xF0, 0xFF, 0xEF, 0xEF, 0xEF, 0xFF, 0xED, 0xEE, 0xEE, 0xFE,
	0xEC, 0xEC, 0xEC, 0xEC, 0xEA, 0xEB, 0xEB, 0xA1, 0xEA, 0xE9, 0xEA, 0x2F,
	0xE8, 0xE8, 0xE8, 0x00, 0xE7, 0xE7, 0xE7, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x22,
	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFE, 0xFF, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFE, 0x99, 0xFF, 0xFE, 0xFE, 0x00,
	0xFF, 0xFF, 0xFE, 0x00, 0xFE, 0xFE, 0xFE, 0x00, 0xFD, 0xFE, 0xFD, 0x00,
	0xFE, 0xFE, 0xFD, 0x00, 0xFE, 0xFE, 0xFD, 0x00, 0xFE, 0xFE, 0xFE, 0x00,
	0xFD, 0xFD, 0xFD, 0x00, 0xFD, 0xFD, 0xFD, 0x00, 0xFD, 0xFD, 0xFD, 0x00,
	0xFD, 0xFD, 0xFD, 0x00, 0xFC, 0xFC, 0xFD, 0x00, 0xFC, 0xFC, 0xFC, 0x00,
	0xFC, 0xFC, 0xFC, 0x00, 0xFC, 0xFC, 0xFC, 0x00, 0xFC, 0xFB, 0xFC, 0x00,
	0xFC, 0xFB, 0xFC, 0x22, 0xFB, 0xFB, 0xFB, 0xFF, 0xFB, 0xFB, 0xFB, 0xFF,
	0xFB, 0xFB, 0xFB, 0xFF, 0xFB, 0xFB, 0xFB, 0xFF, 0xFA, 0xFA, 0xFB, 0xFF,
	0xFA, 0xFB, 0xFA, 0xFF, 0xFA, 0xFA, 0xF9, 0xFF, 0xF9, 0xFA, 0xFA, 0x99,
	0xF9, 0xF9, 0xFA, 0x00, 0xF9, 0xF9, 0xF9, 0x00, 0xF9, 0xF9, 0xF9, 0x00,
	0xF8, 0xF9, 0xF9, 0x00, 0xF8, 0xF8, 0xF9, 0x00, 0xF8, 0xF8, 0xF8, 0x00,
	0xF8, 0xF8, 0xF8, 0x00, 0xF7, 0xF8, 0xF7, 0x99, 0xF7, 0xF8, 0xF8, 0xFF,
	0xF7, 0xF7, 0xF7, 0xFF, 0xF6, 0xF7, 0xF7, 0xFF, 0xF6, 0xF6, 0xF7, 0xFF,
	0xF7, 0xF7, 0xF6, 0xFF, 0xF6, 0xF6, 0xF6, 0xFF, 0xF6, 0xF5, 0xF6, 0xFF,
	0xF5, 0xF6, 0xF6, 0x44, 0xF5, 0xF5, 0xF5, 0x00, 0xF5, 0xF5, 0xF5, 0x00,
	0xF4, 0xF5, 0xF4, 0x00, 0xF4, 0xF4, 0xF4, 0x00, 0xF4, 0xF4, 0xF4, 0xFF,
	0xF4, 0xF4, 0xF4, 0xFF, 0xF3, 0xF3, 0xF4, 0xFF, 0xF3, 0xF3, 0xF3, 0xFF,
	0xF3, 0xF2, 0xF3, 0xFF, 0xF3, 0xF2, 0xF2, 0xFF, 0xF2, 0xF3, 0xF2, 0xFF,
	0xF2, 0xF2, 0xF1, 0x44, 0xF2, 0xF1, 0xF1, 0x00, 0xF1, 0xF2, 0xF1, 0x66,
	0xF1, 0xF1, 0xF1, 0xFF, 0xF1, 0xF0, 0xF1, 0xFF, 0xF1, 0xF0, 0xF0, 0xFF,
	0xF0, 0xF0, 0xF0, 0xFF, 0xF0, 0xF0, 0xF0, 0xFF, 0xF0, 0xF0, 0xEF, 0xFF,
	0xEF, 0xEF, 0xEF, 0xFF, 0xEE, 0xEF, 0xEF, 0xFF, 0xEE, 0xEE, 0xEE, 0x99,
	0xEE, 0xEE, 0xEE, 0x00, 0xEE, 0xEE, 0xEE, 0x00, 0xED, 0xED, 0xED, 0xFF,
	0xED, 0xED, 0xEE, 0xFF, 0xEC, 0xED, 0xED, 0xFF, 0xEC, 0xEC, 0xEC, 0xFF,
	0xEC, 0xEC, 0xED, 0xFF, 0xEC, 0xEC, 0xEC, 0xFF, 0xEB, 0xEB, 0xEB, 0xFF,
	0xEB, 0xEB, 0xEB, 0x44, 0xEB, 0xEB, 0xEA, 0x00, 0xEA, 0xEB, 0xEB, 0x00,
	0xEA, 0xEA, 0xEA, 0x00, 0xEA, 0xEA, 0xEA, 0x00, 0xE9, 0xEA, 0xEA, 0x00,
	0xE9, 0xE9, 0xE9, 0xFF, 0xE9, 0xE9, 0xE9, 0xFF, 0xE9, 0xE9, 0xE8, 0xFF,
	0xE8, 0xE8, 0xE8, 0xFF, 0xE7, 0xE8, 0xE7, 0xFF, 0xE7, 0xE7, 0xE8, 0xFF,
	0xE7, 0xE8, 0xE7, 0xFF, 0xE7, 0xE7, 0xE7, 0x77, 0xE7, 0xE6, 0xE6, 0x00,
	0xE7, 0xE6, 0xE7, 0x00, 0xE6, 0xE6, 0xE6, 0x00, 0xE6, 0xE5, 0xE5, 0x44,
	0xE6, 0xE5, 0xE6, 0xFF, 0xE5, 0xE5, 0xE4, 0xFF, 0xE5, 0xE4, 0xE4, 0xFF,
	0xE4, 0xE4, 0xE5, 0xFF, 0xE4, 0xE4, 0xE4, 0xFF, 0xE4, 0xE3, 0xE4, 0xFF,
	0xE3, 0xE4, 0xE3, 0xFF, 0xE3, 0xE3, 0xE2, 0x44, 0xE2, 0xE3, 0xE3, 0x00,
	0xE2, 0xE2, 0xE2, 0x00, 0xE2, 0xE2, 0xE1, 0xCC, 0xE2, 0xE1, 0xE1, 0xFF,
	0xE1, 0xE2, 0xE1, 0xFF, 0xE1, 0xE1, 0xE1, 0xFF, 0xE1, 0xE1, 0xE1, 0xFF,
	0xE0, 0xE0, 0xE0, 0xFF, 0xE0, 0xE0, 0xE0, 0xFF, 0xE0, 0xE0, 0xE0, 0xFF,
	0xDF, 0xDF, 0xE0, 0xFF, 0xDF, 0xDF, 0xDF, 0xFF, 0xDF, 0xDF, 0xDE, 0xFF,
	0xDF, 0xDE, 0xDE, 0xFF, 0xDE, 0xDF, 0xDE, 0xFF, 0xDE, 0xDE, 0xDE, 0xFF,
	0xDD, 0xDE, 0xDE, 0x77, 0xDD, 0xDD, 0xDD, 0x00, 0xDD, 0xDD, 0xDD, 0x00,
	0xDC, 0xDD, 0xDD, 0x00, 0xDD, 0xDC, 0xDD, 0x00, 0xDC, 0xDC, 0xDC, 0x00,
	0xDB, 0xDC, 0xDC, 0x00, 0xDB, 0xDC, 0xDB, 0xCC, 0xDB, 0xDB, 0xDB, 0xFF,
	0xDB, 0xDB, 0xDB, 0xFF, 0xDA, 0xDA, 0xDB, 0xFF, 0xDA, 0xDA, 0xDA, 0xFF,
	0xDA, 0xDA, 0xDA, 0xFF, 0xD9, 0xD9, 0xD9, 0xFF, 0xD9, 0xD9, 0xDA, 0xFF,
	0xD9, 0xD9, 0xD9, 0xFF, 0xD9, 0xD9, 0xD9, 0xFF, 0xD8, 0xD9, 0xD9, 0xFF,
	0xD9, 0xD9, 0xD8, 0xFF, 0xD8, 0xD7, 0xD8, 0xFF, 0xD8, 0xD8, 0xD7, 0xFF,
	0xD7, 0xD7, 0xD8, 0xFF, 0xD7, 0xD7, 0xD7, 0xFF, 0xD7, 0xD7, 0xD6, 0xFF,
	0xD6, 0xD7, 0xD7, 0xFF, 0xD6, 0xD6, 0xD6, 0xFF, 0xD7, 0xD6, 0xD7, 0xCC,
	0xD6, 0xD6, 0xD6, 0x00, 0xD6, 0xD5, 0xD5, 0x00, 0xD5, 0xD6, 0xD5, 0x00,
	0xD5, 0xD5, 0xD6, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFA, 0xFA, 0xFA, 0x6C, 0xFA, 0xFA, 0xF9, 0xE3, 0xF8, 0xF9, 0xF9, 0xFF,
	0xF7, 0xF7, 0xF7, 0xFF, 0xF6, 0xF6, 0xF5, 0xFF, 0xF5, 0xF5, 0xF4, 0xFF,
	0xF3, 0xF3, 0xF3, 0xFF, 0xF2, 0xF2, 0xF2, 0xFF, 0xF1, 0xF0, 0xF0, 0xFF,
	0xEF, 0xF0, 0xEF, 0xFF, 0xED, 0xED, 0xEE, 0xFF, 0xEC, 0xEC, 0xEC, 0xFE,
	0xEB, 0xEB, 0xEB, 0xDF, 0xE9, 0xEA, 0xE9, 0x96, 0xE8, 0xE8, 0xE8, 0x45,
	0xE6, 0xE7, 0xE7, 0x09, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xD4, 0xD4, 0xD4, 0x12,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x22, 0xFF, 0xFF, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0x99, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFE, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFE, 0xFE, 0x00, 0xFE, 0xFE, 0xFF, 0x00, 0xFE, 0xFE, 0xFE, 0x00,
	0xFE, 0xFE, 0xFE, 0x00, 0xFE, 0xFD, 0xFE, 0x00, 0xFD, 0xFE, 0xFE, 0x00,
	0xFD, 0xFD, 0xFE, 0x00, 0xFD, 0xFE, 0xFD, 0x00, 0xFD, 0xFD, 0xFD, 0x00,
	0xFD, 0xFD, 0xFC, 0x00, 0xFD, 0xFD, 0xFD, 0x00, 0xFD, 0xFD, 0xFD, 0x22,
	0xFD, 0xFD, 0xFD, 0xFF, 0xFC, 0xFD, 0xFD, 0xFF, 0xFC, 0xFC, 0xFC, 0xFF,
	0xFC, 0xFC, 0xFC, 0xFF, 0xFC, 0xFC, 0xFC, 0xFF, 0xFB, 0xFB, 0xFB, 0xFF,
	0xFB, 0xFB, 0xFB, 0xFF, 0xFB, 0xFB, 0xFB, 0xCC, 0xFB, 0xFB, 0xFB, 0x00,
	0xFA, 0xFA, 0xFA, 0x00, 0xFA, 0xFA, 0xFA, 0x00, 0xFA, 0xFA, 0xFA, 0x00,
	0xFA, 0xF9, 0xFA, 0x00, 0xF9, 0xF9, 0xF9, 0x00, 0xFA, 0xF9, 0xF9, 0x00,
	0xF9, 0xF8, 0xF9, 0xCC, 0xF9, 0xF8, 0xF9, 0xFF, 0xF9, 0xF9, 0xF9, 0xFF,
	0xF9, 0xF8, 0xF8, 0xFF, 0xF8, 0xF8, 0xF8, 0xFF, 0xF7, 0xF8, 0xF8, 0xFF,
	0xF7, 0xF7, 0xF7, 0xFF, 0xF7, 0xF7, 0xF7, 0xFF, 0xF7, 0xF7, 0xF7, 0x33,
	0xF7, 0xF7, 0xF6, 0x00, 0xF7, 0xF6, 0xF7, 0x00, 0xF6, 0xF6, 0xF6, 0x00,
	0xF6, 0xF6, 0xF6, 0x00, 0xF6, 0xF6, 0xF5, 0xFF, 0xF6, 0xF5, 0xF5, 0xFF,
	0xF5, 0xF4, 0xF5, 0xFF, 0xF5, 0xF4, 0xF4, 0xFF, 0xF4, 0xF5, 0xF5, 0xFF,
	0xF4, 0xF4, 0xF4, 0xFF, 0xF4, 0xF4, 0xF4, 0xFF, 0xF4, 0xF3, 0xF3, 0x44,
	0xF3, 0xF3, 0xF4, 0x00, 0xF2, 0xF3, 0xF3, 0x00, 0xF3, 0xF3, 0xF3, 0xBB,
	0xF2, 0xF2, 0xF2, 0xFF, 0xF2, 0xF2, 0xF2, 0xFF, 0xF2, 0xF1, 0xF2, 0xFF,
	0xF1, 0xF1, 0xF2, 0xFF, 0xF1, 0xF1, 0xF1, 0xFF, 0xF0, 0xF1, 0xF1, 0xFF,
	0xF0, 0xF0, 0xF1, 0xEE, 0xF0, 0xF0, 0xF0, 0x11, 0xF0, 0xEF, 0xF0, 0x00,
	0xF0, 0xEF, 0xF0, 0x00, 0xEF, 0xEF, 0xEF, 0xFF, 0xEF, 0xEF, 0xEE, 0xFF,
	0xEF, 0xEF, 0xEE, 0xFF, 0xEE, 0xEE, 0xEE, 0xFF, 0xEE, 0xEE, 0xEE, 0xFF,
	0xED, 0xEE, 0xEE, 0xFF, 0xED, 0xED, 0xED, 0xFF, 0xED, 0xED, 0xED, 0x44,
	0xEC, 0xED, 0xED, 0x00, 0xED, 0xEC, 0xED, 0x00, 0xEC, 0xEC, 0xEC, 0x00,
	0xEC, 0xEB, 0xEC, 0x00, 0xEC, 0xEB, 0xEC, 0x00, 0xEB, 0xEB, 0xEB, 0xFF,
	0xEA, 0xEA, 0xEA, 0xFF, 0xEA, 0xEA, 0xEB, 0xFF, 0xEA, 0xEA, 0xEA, 0xFF,
	0xEA, 0xE9, 0xEA, 0xFF, 0xEA, 0xE9, 0xE9, 0xFF, 0xE9, 0xE9, 0xE9, 0xFF,
	0xE9, 0xE8, 0xE8, 0x77, 0xE9, 0xE8, 0xE8, 0x00, 0xE8, 0xE8, 0xE8, 0x00,
	0xE8, 0xE8, 0xE8, 0x00, 0xE7, 0xE7, 0xE7, 0x44, 0xE7, 0xE7, 0xE7, 0xFF,
	0xE7, 0xE6, 0xE6, 0xFF, 0xE6, 0xE6, 0xE6, 0xFF, 0xE6, 0xE6, 0xE6, 0xFF,
	0xE5, 0xE6, 0xE5, 0xFF, 0xE6, 0xE5, 0xE5, 0xFF, 0xE5, 0xE5, 0xE5, 0xFF,
	0xE5, 0xE5, 0xE4, 0x44, 0xE4, 0xE5, 0xE5, 0x00, 0xE4, 0xE4, 0xE4, 0x00,
	0xE4, 0xE4, 0xE4, 0x33, 0xE3, 0xE3, 0xE3, 0xFF, 0xE3, 0xE3, 0xE3, 0xFF,
	0xE3, 0xE2, 0xE3, 0xFF, 0xE2, 0xE2, 0xE2, 0xFF, 0xE2, 0xE2, 0xE2, 0xFF,
	0xE2, 0xE1, 0xE2, 0xFF, 0xE2, 0xE1, 0xE1, 0xFF, 0xE1, 0xE1, 0xE1, 0xFF,
	0xE1, 0xE1, 0xE1, 0xFF, 0xE0, 0xE0, 0xE0, 0xFF, 0xE0, 0xE0, 0xE0, 0xFF,
	0xE0, 0xDF, 0xE0, 0xFF, 0xDF, 0xE0, 0xDF, 0xFF, 0xDF, 0xDF, 0xDF, 0x77,
	0xDF, 0xDF, 0xDF, 0x00, 0xDE, 0xDF, 0xDE, 0x00, 0xDE, 0xDE, 0xDE, 0x00,
	0xDE, 0xDE, 0xDE, 0x00, 0xDE, 0xDD, 0xDE, 0x00, 0xDE, 0xDD, 0xDD, 0x33,
	0xDD, 0xDD, 0xDD, 0xFF, 0xDD, 0xDD, 0xDD, 0xFF, 0xDC, 0xDD, 0xDC, 0xFF,
	0xDC, 0xDC, 0xDC, 0xFF, 0xDB, 0xDC, 0xDC, 0xFF, 0xDB, 0xDB, 0xDB, 0xFF,
	0xDB, 0xDB, 0xDB, 0xFF, 0xDA, 0xDB, 0xDA, 0xFF, 0xDA, 0xDA, 0xDB, 0xFF,
	0xDA, 0xDA, 0xDB, 0xFF, 0xDA, 0xDA, 0xDA, 0xFF, 0xDA, 0xDA, 0xDA, 0xFF,
	0xD9, 0xDA, 0xD9, 0xFF, 0xDA, 0xD9, 0xD9, 0xFF, 0xD9, 0xD9, 0xD9, 0xFF,
	0xD9, 0xD8, 0xD9, 0xFF, 0xD8, 0xD8, 0xD8, 0xFF, 0xD8, 0xD8, 0xD8, 0xFF,
	0xD8, 0xD8, 0xD8, 0xFF, 0xD7, 0xD7, 0xD7, 0xFF, 0xD7, 0xD7, 0xD7, 0x33,
	0xD7, 0xD7, 0xD7, 0x00, 0xD7, 0xD6, 0xD6, 0x00, 0xD7, 0xD7, 0xD6, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFA, 0xFA, 0xFA, 0x22,
	0xFA, 0xF9, 0xFA, 0xCD, 0xF8, 0xF8, 0xF9, 0xFF, 0xF7, 0xF7, 0xF7, 0xFF,
	0xF6, 0xF6, 0xF6, 0xFF, 0xF5, 0xF5, 0xF5, 0xFF, 0xF3, 0xF4, 0xF4, 0xFF,
	0xF2, 0xF2, 0xF2, 0xFF, 0xF0, 0xF1, 0xF1, 0xFF, 0xEF, 0xEF, 0xEF, 0xFF,
	0xEE, 0xEE, 0xEE, 0xFF, 0xED, 0xEC, 0xEC, 0xFF, 0xEB, 0xEB, 0xEB, 0xFC,
	0xEA, 0xEA, 0xEA, 0xEC, 0xE8, 0xE8, 0xE8, 0xAF, 0xE7, 0xE7, 0xE7, 0x5B,
	0xE5, 0xE5, 0xE6, 0x26, 0xE4, 0xE4, 0xE3, 0x14, 0xE2, 0xE2, 0xE2, 0x0A,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xD9, 0xD9, 0xD9, 0x05, 0xD8, 0xD8, 0xD8, 0x0E, 0xD6, 0xD6, 0xD7, 0x29,
	0xD6, 0xD5, 0xD6, 0x32, 0xD4, 0xD5, 0xD5, 0x0E, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x22, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x99,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFE, 0xFE, 0xFF, 0x00, 0xFF, 0xFE, 0xFE, 0x00,
	0xFE, 0xFF, 0xFE, 0x00, 0xFE, 0xFE, 0xFE, 0x00, 0xFE, 0xFD, 0xFE, 0x00,
	0xFE, 0xFE, 0xFE, 0x00, 0xFE, 0xFE, 0xFD, 0x11, 0xFE, 0xFD, 0xFD, 0xFF,
	0xFD, 0xFD, 0xFE, 0xFF, 0xFD, 0xFD, 0xFD, 0xFF, 0xFC, 0xFD, 0xFD, 0xFF,
	0xFC, 0xFD, 0xFC, 0xFF, 0xFC, 0xFD, 0xFD, 0xFF, 0xFC, 0xFC, 0xFC, 0xFF,
	0xFC, 0xFC, 0xFC, 0xFF, 0xFC, 0xFC, 0xFB, 0x55, 0xFB, 0xFC, 0xFC, 0x00,
	0xFB, 0xFB, 0xFB, 0x00, 0xFB, 0xFB, 0xFB, 0x00, 0xFB, 0xFB, 0xFB, 0x00,
	0xFA, 0xFA, 0xFA, 0x00, 0xFA, 0xFA, 0xFB, 0x55, 0xFA, 0xFA, 0xFA, 0xFF,
	0xFA, 0xFA, 0xFA, 0xFF, 0xF9, 0xFA, 0xF9, 0xFF, 0xFA, 0xFA, 0xF9, 0xFF,
	0xFA, 0xF9, 0xF9, 0xFF, 0xF9, 0xF9, 0xF9, 0xFF, 0xF9, 0xF9, 0xF9, 0xFF,
	0xF8, 0xF8, 0xF8, 0xFF, 0xF9, 0xF8, 0xF8, 0x11, 0xF8, 0xF8, 0xF8, 0x00,
	0xF8, 0xF8, 0xF8, 0x00, 0xF8, 0xF7, 0xF7, 0x00, 0xF7, 0xF8, 0xF7, 0x00,
	0xF7, 0xF7, 0xF7, 0xFF, 0xF7, 0xF6, 0xF6, 0xFF, 0xF6, 0xF6, 0xF7, 0xFF,
	0xF6, 0xF6, 0xF6, 0xFF, 0xF6, 0xF6, 0xF6, 0xFF, 0xF6, 0xF5, 0xF5, 0xFF,
	0xF6, 0xF5, 0xF5, 0xFF, 0xF5, 0xF5, 0xF5, 0x44, 0xF5, 0xF4, 0xF5, 0x00,
	0xF4, 0xF5, 0xF4, 0x00, 0xF4, 0xF4, 0xF4, 0x33, 0xF4, 0xF4, 0xF4, 0xFF,
	0xF3, 0xF3, 0xF4, 0xFF, 0xF3, 0xF3, 0xF3, 0xFF, 0xF3, 0xF3, 0xF3, 0xFF,
	0xF3, 0xF3, 0xF3, 0xFF, 0xF3, 0xF2, 0xF3, 0xFF, 0xF3, 0xF2, 0xF2, 0x77,
	0xF2, 0xF1, 0xF2, 0x00, 0xF1, 0xF1, 0xF1, 0x00, 0xF1, 0xF1, 0xF1, 0x00,
	0xF1, 0xF1, 0xF1, 0xFF, 0xF0, 0xF1, 0xF1, 0xFF, 0xF1, 0xF0, 0xF0, 0xFF,
	0xF0, 0xF0, 0xF0, 0xFF, 0xEF, 0xF0, 0xF0, 0xFF, 0xEF, 0xEF, 0xF0, 0xFF,
	0xEF, 0xEF, 0xEF, 0xFF, 0xEE, 0xEE, 0xEF, 0x44, 0xEF, 0xEF, 0xEE, 0x00,
	0xEE, 0xEE, 0xEE, 0x00, 0xEE, 0xED, 0xEE, 0x00, 0xED, 0xED, 0xED, 0x00,
	0xED, 0xED, 0xEC, 0x00, 0xED, 0xEC, 0xEC, 0xFF, 0xEC, 0xED, 0xEC, 0xFF,
	0xED, 0xEC, 0xEC, 0xFF, 0xEC, 0xEC, 0xEC, 0xFF, 0xEB, 0xEC, 0xEC, 0xFF,
	0xEB, 0xEB, 0xEB, 0xFF, 0xEB, 0xEB, 0xEB, 0xFF, 0xEB, 0xEA, 0xEA, 0x77,
	0xEA, 0xEA, 0xEA, 0x00, 0xEA, 0xEA, 0xEA, 0x00, 0xEA, 0xEA, 0xEA, 0x00,
	0xE9, 0xE9, 0xE9, 0x44, 0xE9, 0xE9, 0xE8, 0xFF, 0xE9, 0xE8, 0xE8, 0xFF,
	0xE8, 0xE8, 0xE8, 0xFF, 0xE8, 0xE8, 0xE8, 0xFF, 0xE7, 0xE7, 0xE7, 0xFF,
	0xE7, 0xE7, 0xE7, 0xFF, 0xE7, 0xE7, 0xE7, 0xFF, 0xE7, 0xE6, 0xE7, 0x44,
	0xE6, 0xE6, 0xE6, 0x00, 0xE6, 0xE6, 0xE6, 0x00, 0xE5, 0xE6, 0xE5, 0x00,
	0xE5, 0xE5, 0xE5, 0x77, 0xE5, 0xE4, 0xE5, 0xFF, 0xE5, 0xE4, 0xE5, 0xFF,
	0xE4, 0xE4, 0xE4, 0xFF, 0xE3, 0xE4, 0xE3, 0xFF, 0xE4, 0xE4, 0xE4, 0xFF,
	0xE3, 0xE3, 0xE3, 0xFF, 0xE3, 0xE2, 0xE2, 0xFF, 0xE2, 0xE3, 0xE3, 0xFF,
	0xE2, 0xE2, 0xE2, 0xFF, 0xE2, 0xE2, 0xE2, 0xFF, 0xE2, 0xE2, 0xE2, 0xFF,
	0xE1, 0xE1, 0xE1, 0xFF, 0xE1, 0xE1, 0xE1, 0x77, 0xE0, 0xE1, 0xE1, 0x00,
	0xE0, 0xE0, 0xE0, 0x00, 0xE0, 0xE0, 0xE0, 0x00, 0xE0, 0xE0, 0xE0, 0x00,
	0xDF, 0xE0, 0xDF, 0x00, 0xDF, 0xDF, 0xDF, 0x88, 0xDF, 0xDF, 0xDE, 0xFF,
	0xDE, 0xDE, 0xDF, 0xFF, 0xDE, 0xDE, 0xDE, 0xFF, 0xDE, 0xDD, 0xDE, 0xFF,
	0xDD, 0xDE, 0xDE, 0xFF, 0xDD, 0xDD, 0xDD, 0xFF, 0xDC, 0xDD, 0xDC, 0xFF,
	0xDD, 0xDD, 0xDC, 0xFF, 0xDC, 0xDC, 0xDC, 0xFF, 0xDC, 0xDC, 0xDC, 0xFF,
	0xDC, 0xDB, 0xDB, 0xFF, 0xDB, 0xDB, 0xDC, 0xFF, 0xDB, 0xDB, 0xDB, 0xFF,
	0xDB, 0xDB, 0xDA, 0xFF, 0xDA, 0xDA, 0xDA, 0xFF, 0xDA, 0xDA, 0xDA, 0xFF,
	0xDA, 0xDA, 0xDA, 0xFF, 0xDA, 0xDA, 0xDA, 0xFF, 0xDA, 0xDA, 0xD9, 0xFF,
	0xD8, 0xD9, 0xD9, 0xFF, 0xD9, 0xD9, 0xD9, 0x77, 0xD8, 0xD9, 0xD8, 0x00,
	0xD9, 0xD9, 0xD8, 0x00, 0xD8, 0xD8, 0xD8, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFB, 0xFB, 0xFB, 0x00, 0xF9, 0xFA, 0xFA, 0x8B,
	0xF8, 0xF9, 0xF8, 0xF3, 0xF7, 0xF7, 0xF7, 0xFF, 0xF6, 0xF6, 0xF6, 0xFF,
	0xF5, 0xF5, 0xF5, 0xFF, 0xF3, 0xF4, 0xF4, 0xFF, 0xF3, 0xF3, 0xF2, 0xFF,
	0xF1, 0xF1, 0xF1, 0xFF, 0xF0, 0xEF, 0xEF, 0xFF, 0xEE, 0xEE, 0xEE, 0xFF,
	0xEC, 0xED, 0xED, 0xFF, 0xEB, 0xEB, 0xEC, 0xFF, 0xEA, 0xE9, 0xE9, 0xFF,
	0xE9, 0xE9, 0xE8, 0xF4, 0xE6, 0xE7, 0xE6, 0xC7, 0xE6, 0xE6, 0xE5, 0x89,
	0xE4, 0xE4, 0xE4, 0x52, 0xE3, 0xE2, 0xE3, 0x32, 0xE2, 0xE1, 0xE1, 0x0F,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xDB, 0xDA, 0xDA, 0x02, 0xD9, 0xD9, 0xD9, 0x20,
	0xD8, 0xD8, 0xD8, 0x49, 0xD7, 0xD7, 0xD7, 0x72, 0xD5, 0xD6, 0xD6, 0x59,
	0xD4, 0xD4, 0xD5, 0x02, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x22,
	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x99, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFE, 0x00, 0xFF, 0xFE, 0xFF, 0x00, 0xFF, 0xFF, 0xFE, 0x00,
	0xFE, 0xFE, 0xFE, 0x00, 0xFE, 0xFE, 0xFE, 0xCC, 0xFE, 0xFE, 0xFE, 0xFF,
	0xFE, 0xFE, 0xFE, 0xFF, 0xFE, 0xFE, 0xFE, 0xFF, 0xFE, 0xFE, 0xFE, 0xFF,
	0xFE, 0xFD, 0xFE, 0xFF, 0xFD, 0xFD, 0xFE, 0xFF, 0xFD, 0xFD, 0xFD, 0xFF,
	0xFD, 0xFC, 0xFD, 0xFF, 0xFD, 0xFD, 0xFC, 0x88, 0xFD, 0xFD, 0xFD, 0x11,
	0xFC, 0xFC, 0xFC, 0x00, 0xFC, 0xFC, 0xFC, 0x11, 0xFC, 0xFB, 0xFC, 0x88,
	0xFB, 0xFB, 0xFC, 0xFF, 0xFC, 0xFC, 0xFC, 0xFF, 0xFB, 0xFB, 0xFB, 0xFF,
	0xFB, 0xFB, 0xFB, 0xFF, 0xFB, 0xFB, 0xFA, 0xFF, 0xFB, 0xFA, 0xFA, 0xFF,
	0xFA, 0xFB, 0xFA, 0xFF, 0xFA, 0xFA, 0xFA, 0xFF, 0xFA, 0xFA, 0xFA, 0xCC,
	0xF9, 0xFA, 0xFA, 0x00, 0xF9, 0xFA, 0xFA, 0x00, 0xF9, 0xF9, 0xF9, 0x00,
	0xF9, 0xF9, 0xF9, 0x00, 0xF9, 0xF9, 0xF9, 0x00, 0xF9, 0xF8, 0xF8, 0xFF,
	0xF8, 0xF8, 0xF8, 0xFF, 0xF8, 0xF8, 0xF8, 0xFF, 0xF8, 0xF7, 0xF7, 0xFF,
	0xF8, 0xF7, 0xF8, 0xFF, 0xF7, 0xF7, 0xF7, 0xFF, 0xF7, 0xF7, 0xF7, 0xFF,
	0xF6, 0xF6, 0xF7, 0x44, 0xF6, 0xF6, 0xF6, 0x00, 0xF6, 0xF6, 0xF6, 0x00,
	0xF6, 0xF6, 0xF6, 0x00, 0xF5, 0xF5, 0xF5, 0x77, 0xF5, 0xF5, 0xF6, 0xFF,
	0xF5, 0xF5, 0xF5, 0xFF, 0xF5, 0xF5, 0xF5, 0xFF, 0xF4, 0xF4, 0xF4, 0xFF,
	0xF4, 0xF4, 0xF3, 0xBB, 0xF3, 0xF3, 0xF3, 0x00, 0xF3, 0xF4, 0xF4, 0x00,
	0xF3, 0xF3, 0xF3, 0x00, 0xF3, 0xF3, 0xF3, 0x00, 0xF3, 0xF2, 0xF2, 0xFF,
	0xF2, 0xF2, 0xF2, 0xFF, 0xF2, 0xF2, 0xF2, 0xFF, 0xF1, 0xF2, 0xF2, 0xFF,
	0xF1, 0xF1, 0xF2, 0xFF, 0xF1, 0xF1, 0xF1, 0xFF, 0xF1, 0xF1, 0xF1, 0xFF,
	0xF1, 0xF0, 0xF0, 0x44, 0xF0, 0xF0, 0xF0, 0x00, 0xEF, 0xEF, 0xF0, 0x00,
	0xEF, 0xEF, 0xEF, 0x00, 0xEF, 0xEF, 0xEF, 0x00, 0xEE, 0xEF, 0xEF, 0x00,
	0xEF, 0xEE, 0xEF, 0xFF, 0xEE, 0xEE, 0xEE, 0xFF, 0xEE, 0xEE, 0xED, 0xFF,
	0xED, 0xED, 0xED, 0xFF, 0xED, 0xED, 0xED, 0xFF, 0xED, 0xED, 0xED, 0xFF,
	0xED, 0xED, 0xEC, 0xFF, 0xEC, 0xEC, 0xEC, 0x77, 0xEB, 0xEC, 0xEC, 0x00,
	0xEC, 0xEC, 0xEB, 0x00, 0xEC, 0xEB, 0xEB, 0x00, 0xEB, 0xEB, 0xEB, 0x44,
	0xEA, 0xEB, 0xEA, 0xFF, 0xEA, 0xEA, 0xEA, 0xFF, 0xEA, 0xEA, 0xEA, 0xFF,
	0xE9, 0xE9, 0xE9, 0xFF, 0xE9, 0xE9, 0xE9, 0xFF, 0xE9, 0xE9, 0xE8, 0xFF,
	0xE8, 0xE8, 0xE8, 0xFF, 0xE8, 0xE8, 0xE8, 0x44, 0xE8, 0xE8, 0xE8, 0x00,
	0xE8, 0xE7, 0xE7, 0x00, 0xE7, 0xE7, 0xE8, 0x00, 0xE7, 0xE7, 0xE7, 0x11,
	0xE6, 0xE7, 0xE7, 0xDD, 0xE6, 0xE6, 0xE6, 0xFF, 0xE6, 0xE6, 0xE6, 0xFF,
	0xE5, 0xE6, 0xE6, 0xFF, 0xE5, 0xE5, 0xE5, 0xFF, 0xE5, 0xE5, 0xE5, 0xFF,
	0xE4, 0xE5, 0xE5, 0xFF, 0xE4, 0xE4, 0xE4, 0xFF, 0xE4, 0xE4, 0xE4, 0xFF,
	0xE3, 0xE3, 0xE3, 0xFF, 0xE3, 0xE3, 0xE3, 0xFF, 0xE3, 0xE3, 0xE3, 0xFF,
	0xE3, 0xE3, 0xE3, 0x77, 0xE2, 0xE3, 0xE2, 0x00, 0xE2, 0xE2, 0xE2, 0x00,
	0xE1, 0xE2, 0xE1, 0x00, 0xE1, 0xE1, 0xE1, 0x00, 0xE1, 0xE0, 0xE1, 0x00,
	0xE0, 0xE1, 0xE1, 0xDD, 0xE0, 0xE1, 0xE0, 0xFF, 0xE0, 0xE0, 0xE0, 0xFF,
	0xE0, 0xE0, 0xDF, 0xFF, 0xDF, 0xE0, 0xE0, 0xFF, 0xDF, 0xDF, 0xDF, 0xFF,
	0xDF, 0xDF, 0xDF, 0xFF, 0xDE, 0xDE, 0xDE, 0xFF, 0xDE, 0xDE, 0xDE, 0xFF,
	0xDD, 0xDE, 0xDE, 0xFF, 0xDE, 0xDE, 0xDD, 0xFF, 0xDD, 0xDE, 0xDD, 0xFF,
	0xDD, 0xDD, 0xDD, 0xFF, 0xDC, 0xDD, 0xDD, 0xFF, 0xDD, 0xDC, 0xDD, 0xFF,
	0xDC, 0xDC, 0xDB, 0xFF, 0xDB, 0xDC, 0xDB, 0xFF, 0xDB, 0xDB, 0xDB, 0xFF,
	0xDB, 0xDB, 0xDB, 0xFF, 0xDA, 0xDA, 0xDA, 0xFF, 0xDA, 0xDA, 0xDB, 0xFF,
	0xDA, 0xDA, 0xDA, 0xDD, 0xDA, 0xDA, 0xDA, 0x00, 0xDA, 0xD9, 0xD9, 0x00,
	0xD9, 0xD9, 0xD9, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFB, 0xFA, 0xFB, 0x00, 0xFA, 0xFA, 0xF9, 0x2F, 0xF9, 0xF8, 0xF9, 0xBC,
	0xF7, 0xF8, 0xF8, 0xFF, 0xF6, 0xF6, 0xF7, 0xFF, 0xF5, 0xF5, 0xF5, 0xFF,
	0xF4, 0xF4, 0xF4, 0xFF, 0xF2, 0xF3, 0xF3, 0xFF, 0xF1, 0xF1, 0xF1, 0xFF,
	0xF0, 0xF0, 0xEF, 0xFF, 0xEF, 0xEF, 0xEF, 0xFF, 0xED, 0xED, 0xED, 0xFF,
	0xEB, 0xEB, 0xEC, 0xFF, 0xEA, 0xEA, 0xEA, 0xFF, 0xE9, 0xE8, 0xE8, 0xFF,
	0xE7, 0xE7, 0xE7, 0xFF, 0xE5, 0xE5, 0xE6, 0xE1, 0xE4, 0xE4, 0xE4, 0xB0,
	0xE2, 0xE3, 0xE2, 0x8F, 0xE1, 0xE1, 0xE1, 0x6D, 0xE0, 0xE0, 0xE0, 0x52,
	0xDF, 0xDE, 0xDE, 0x46, 0xDD, 0xDD, 0xDD, 0x46, 0xDC, 0xDC, 0xDC, 0x4D,
	0xDB, 0xDB, 0xDA, 0x5F, 0xD9, 0xD9, 0xD9, 0x7D, 0xD8, 0xD8, 0xD8, 0xAF,
	0xD7, 0xD7, 0xD7, 0x94, 0xD5, 0xD6, 0xD6, 0x37, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x22, 0xFF, 0xFF, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0x66, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x77, 0xFE, 0xFF, 0xFF, 0xFF, 0xFF, 0xFE, 0xFF, 0xFF,
	0xFE, 0xFE, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFE, 0xFE, 0xFE, 0xFF,
	0xFE, 0xFE, 0xFE, 0xFF, 0xFE, 0xFE, 0xFE, 0xFF, 0xFD, 0xFE, 0xFD, 0xFF,
	0xFE, 0xFE, 0xFE, 0xFF, 0xFD, 0xFD, 0xFD, 0xFF, 0xFD, 0xFD, 0xFD, 0xFF,
	0xFD, 0xFD, 0xFD, 0xFF, 0xFD, 0xFD, 0xFD, 0xFF, 0xFD, 0xFC, 0xFD, 0xFF,
	0xFC, 0xFD, 0xFD, 0xFF, 0xFC, 0xFC, 0xFC, 0xFF, 0xFC, 0xFC, 0xFC, 0xFF,
	0xFC, 0xFB, 0xFC, 0xFF, 0xFC, 0xFC, 0xFC, 0xFF, 0xFC, 0xFB, 0xFB, 0xFF,
	0xFC, 0xFB, 0xFC, 0xFF, 0xFB, 0xFB, 0xFB, 0x77, 0xFB, 0xFB, 0xFB, 0x00,
	0xFA, 0xFA, 0xFB, 0x00, 0xFA, 0xFB, 0xFA, 0x00, 0xFA, 0xFA, 0xFA, 0x00,
	0xFA, 0xFA, 0xFA, 0x00, 0xFA, 0xFA, 0xF9, 0xFF, 0xF9, 0xF9, 0xFA, 0xFF,
	0xF9, 0xF9, 0xF9, 0xFF, 0xF9, 0xF9, 0xF9, 0xFF, 0xF9, 0xF9, 0xF9, 0xFF,
	0xF9, 0xF8, 0xF9, 0xFF, 0xF8, 0xF9, 0xF8, 0xFF, 0xF8, 0xF8, 0xF8, 0x44,
	0xF7, 0xF7, 0xF7, 0x00, 0xF8, 0xF7, 0xF7, 0x00, 0xF7, 0xF7, 0xF7, 0x00,
	0xF7, 0xF7, 0xF7, 0x11, 0xF7, 0xF6, 0xF7, 0xDD, 0xF6, 0xF6, 0xF6, 0xFF,
	0xF6, 0xF6, 0xF6, 0xFF, 0xF6, 0xF6, 0xF6, 0xFF, 0xF6, 0xF6, 0xF6, 0x33,
	0xF5, 0xF5, 0xF6, 0x00, 0xF5, 0xF5, 0xF5, 0x00, 0xF5, 0xF5, 0xF4, 0x00,
	0xF4, 0xF4, 0xF4, 0x00, 0xF4, 0xF4, 0xF4, 0xFF, 0xF3, 0xF4, 0xF4, 0xFF,
	0xF4, 0xF4, 0xF3, 0xFF, 0xF3, 0xF3, 0xF3, 0xFF, 0xF3, 0xF3, 0xF3, 0xFF,
	0xF3, 0xF3, 0xF2, 0xFF, 0xF2, 0xF2, 0xF2, 0xFF, 0xF1, 0xF2, 0xF2, 0x44,
	0xF2, 0xF1, 0xF2, 0x00, 0xF2, 0xF1, 0xF1, 0x00, 0xF1, 0xF1, 0xF1, 0x00,
	0xF1, 0xF0, 0xF1, 0x00, 0xF1, 0xF0, 0xF0, 0x00, 0xF0, 0xF0, 0xF0, 0xFF,
	0xEF, 0xF0, 0xF0, 0xFF, 0xEF, 0xF0, 0xEF, 0xFF, 0xEF, 0xEF, 0xEF, 0xFF,
	0xEF, 0xEF, 0xEE, 0xFF, 0xEF, 0xEF, 0xEE, 0xFF, 0xEF, 0xEE, 0xEE, 0xFF,
	0xEE, 0xEE, 0xED, 0x77, 0xED, 0xED, 0xEE, 0x00, 0xED, 0xEE, 0xED, 0x00,
	0xEC, 0xED, 0xED, 0x00, 0xED, 0xEC, 0xEC, 0x44, 0xEC, 0xEC, 0xEC, 0xFF,
	0xEC, 0xEC, 0xEC, 0xFF, 0xEC, 0xEC, 0xEC, 0xFF, 0xEB, 0xEB, 0xEB, 0xFF,
	0xEB, 0xEA, 0xEB, 0xFF, 0xEA, 0xEB, 0xEA, 0xFF, 0xEA, 0xEA, 0xEB, 0xFF,
	0xEA, 0xEA, 0xEA, 0x44, 0xE9, 0xEA, 0xEA, 0x00, 0xEA, 0xEA, 0xE9, 0x00,
	0xE9, 0xE8, 0xE9, 0x00, 0xE8, 0xE9, 0xE9, 0x00, 0xE8, 0xE9, 0xE8, 0x44,
	0xE8, 0xE8, 0xE8, 0xFF, 0xE8, 0xE8, 0xE7, 0xFF, 0xE7, 0xE7, 0xE8, 0xFF,
	0xE7, 0xE7, 0xE7, 0xFF, 0xE7, 0xE6, 0xE7, 0xFF, 0xE7, 0xE6, 0xE7, 0xFF,
	0xE6, 0xE6, 0xE6, 0xFF, 0xE5, 0xE5, 0xE6, 0xFF, 0xE5, 0xE5, 0xE5, 0xFF,
	0xE5, 0xE5, 0xE4, 0xFF, 0xE5, 0xE5, 0xE4, 0xFF, 0xE5, 0xE4, 0xE5, 0x77,
	0xE4, 0xE4, 0xE4, 0x00, 0xE4, 0xE3, 0xE4, 0x00, 0xE3, 0xE3, 0xE4, 0x00,
	0xE3, 0xE3, 0xE3, 0x00, 0xE3, 0xE3, 0xE2, 0x44, 0xE2, 0xE2, 0xE2, 0xFF,
	0xE2, 0xE2, 0xE2, 0xFF, 0xE2, 0xE2, 0xE1, 0xFF, 0xE2, 0xE1, 0xE1, 0xFF,
	0xE1, 0xE1, 0xE1, 0xFF, 0xE0, 0xE0, 0xE0, 0xFF, 0xE0, 0xE0, 0xE0, 0xFF,
	0xE0, 0xE0, 0xE0, 0xFF, 0xE0, 0xDF, 0xE0, 0xFF, 0xDF, 0xE0, 0xDF, 0xFF,
	0xDF, 0xDF, 0xDF, 0xFF, 0xDF, 0xDE, 0xDF, 0xFF, 0xDF, 0xDE, 0xDF, 0xFF,
	0xDE, 0xDF, 0xDE, 0xFF, 0xDD, 0xDE, 0xDE, 0xFF, 0xDD, 0xDE, 0xDD, 0xFF,
	0xDE, 0xDD, 0xDD, 0xFF, 0xDD, 0xDD, 0xDD, 0xFF, 0xDC, 0xDC, 0xDD, 0xFF,
	0xDC, 0xDD, 0xDC, 0xFF, 0xDC, 0xDC, 0xDC, 0xFF, 0xDC, 0xDB, 0xDB, 0xFF,
	0xDB, 0xDB, 0xDB, 0x44, 0xDB, 0xDB, 0xDB, 0x00, 0xDA, 0xDB, 0xDB, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFB, 0xFA, 0xFB, 0x00,
	0xFA, 0xFA, 0xFA, 0x00, 0xF8, 0xF9, 0xF8, 0x6D, 0xF7, 0xF7, 0xF7, 0xF1,
	0xF6, 0xF6, 0xF6, 0xFF, 0xF5, 0xF6, 0xF5, 0xFF, 0xF4, 0xF4, 0xF3, 0xFF,
	0xF2, 0xF3, 0xF2, 0xFF, 0xF1, 0xF1, 0xF1, 0xFF, 0xEF, 0xF0, 0xF0, 0xFF,
	0xEF, 0xEE, 0xEE, 0xFF, 0xED, 0xED, 0xED, 0xFF, 0xEB, 0xEC, 0xEC, 0xFF,
	0xEB, 0xEA, 0xEA, 0xFF, 0xE8, 0xE9, 0xE9, 0xFF, 0xE7, 0xE7, 0xE7, 0xFF,
	0xE5, 0xE6, 0xE5, 0xFF, 0xE4, 0xE4, 0xE4, 0xFF, 0xE3, 0xE3, 0xE3, 0xFF,
	0xE1, 0xE1, 0xE1, 0xFF, 0xE0, 0xE0, 0xE0, 0xFF, 0xDF, 0xDF, 0xDE, 0xFF,
	0xDD, 0xDD, 0xDE, 0xFF, 0xDC, 0xDC, 0xDC, 0xFF, 0xDB, 0xDB, 0xDB, 0xFF,
	0xD9, 0xDA, 0xD9, 0xFF, 0xD8, 0xD8, 0xD8, 0xF8, 0xD7, 0xD8, 0xD7, 0x72,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x22, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x66,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x11,
	0xFF, 0xFF, 0xFF, 0xDD, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFE, 0xFF, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFE, 0xFF, 0xFF, 0xFF, 0xFE, 0xFF, 0xFE, 0xFF, 0xFE, 0xFF,
	0xFE, 0xFE, 0xFF, 0xFF, 0xFE, 0xFE, 0xFF, 0xFF, 0xFE, 0xFE, 0xFE, 0xFF,
	0xFD, 0xFE, 0xFE, 0xFF, 0xFE, 0xFE, 0xFE, 0xFF, 0xFD, 0xFD, 0xFD, 0xFF,
	0xFD, 0xFE, 0xFD, 0xFF, 0xFD, 0xFD, 0xFE, 0xFF, 0xFD, 0xFD, 0xFD, 0xFF,
	0xFD, 0xFD, 0xFD, 0xFF, 0xFD, 0xFD, 0xFC, 0xFF, 0xFD, 0xFC, 0xFD, 0xEE,
	0xFC, 0xFD, 0xFC, 0x11, 0xFC, 0xFC, 0xFC, 0x00, 0xFC, 0xFC, 0xFC, 0x00,
	0xFC, 0xFC, 0xFC, 0x00, 0xFC, 0xFC, 0xFB, 0x00, 0xFB, 0xFB, 0xFC, 0x00,
	0xFB, 0xFB, 0xFB, 0xFF, 0xFB, 0xFB, 0xFB, 0xFF, 0xFA, 0xFA, 0xFA, 0xFF,
	0xFA, 0xFA, 0xFB, 0xFF, 0xFA, 0xFA, 0xFA, 0xFF, 0xFA, 0xFA, 0xFA, 0xFF,
	0xF9, 0xFA, 0xFA, 0xFF, 0xFA, 0xF9, 0xF9, 0x44, 0xF9, 0xF9, 0xF9, 0x00,
	0xF8, 0xF8, 0xF9, 0x00, 0xF8, 0xF8, 0xF8, 0x00, 0xF8, 0xF8, 0xF8, 0x00,
	0xF8, 0xF8, 0xF8, 0x55, 0xF8, 0xF8, 0xF8, 0xFF, 0xF8, 0xF8, 0xF8, 0xFF,
	0xF8, 0xF7, 0xF7, 0x88, 0xF7, 0xF7, 0xF7, 0x00, 0xF7, 0xF7, 0xF6, 0x00,
	0xF7, 0xF7, 0xF7, 0x00, 0xF7, 0xF6, 0xF6, 0x00, 0xF6, 0xF6, 0xF6, 0x00,
	0xF6, 0xF6, 0xF5, 0xFF, 0xF5, 0xF5, 0xF5, 0xFF, 0xF5, 0xF5, 0xF5, 0xFF,
	0xF5, 0xF5, 0xF5, 0xFF, 0xF4, 0xF5, 0xF4, 0xFF, 0xF4, 0xF4, 0xF5, 0xFF,
	0xF4, 0xF4, 0xF4, 0xFF, 0xF4, 0xF3, 0xF4, 0x44, 0xF3, 0xF3, 0xF3, 0x00,
	0xF3, 0xF3, 0xF3, 0x00, 0xF2, 0xF3, 0xF2, 0x00, 0xF2, 0xF2, 0xF3, 0x00,
	0xF2, 0xF2, 0xF2, 0x00, 0xF2, 0xF2, 0xF2, 0xFF, 0xF1, 0xF2, 0xF1, 0xFF,
	0xF1, 0xF1, 0xF1, 0xFF, 0xF0, 0xF1, 0xF1, 0xFF, 0xF0, 0xF0, 0xF0, 0xFF,
	0xF0, 0xF0, 0xF0, 0xFF, 0xF0, 0xF0, 0xF0, 0xFF, 0xF0, 0xF0, 0xF0, 0x77,
	0xEF, 0xEF, 0xEF, 0x00, 0xEF, 0xEF, 0xEF, 0x00, 0xEF, 0xEF, 0xEE, 0x00,
	0xEF, 0xEE, 0xEF, 0x44, 0xEE, 0xEE, 0xEE, 0xFF, 0xED, 0xEE, 0xEE, 0xFF,
	0xED, 0xEE, 0xED, 0xFF, 0xED, 0xED, 0xED, 0xFF, 0xED, 0xEC, 0xED, 0xFF,
	0xED, 0xEC, 0xEC, 0xFF, 0xEC, 0xEC, 0xEC, 0xFF, 0xEB, 0xEC, 0xEB, 0x44,
	0xEB, 0xEB, 0xEB, 0x00, 0xEB, 0xEB, 0xEB, 0x00, 0xEB, 0xEB, 0xEB, 0x00,
	0xEA, 0xEA, 0xEA, 0x00, 0xEB, 0xEA, 0xEA, 0x00, 0xEA, 0xEA, 0xEA, 0x88,
	0xEA, 0xE9, 0xE9, 0xFF, 0xE9, 0xE9, 0xE9, 0xFF, 0xE8, 0xE9, 0xE8, 0xFF,
	0xE9, 0xE8, 0xE8, 0xFF, 0xE8, 0xE8, 0xE8, 0xFF, 0xE8, 0xE8, 0xE7, 0xFF,
	0xE8, 0xE8, 0xE8, 0xFF, 0xE7, 0xE7, 0xE7, 0xFF, 0xE7, 0xE6, 0xE7, 0xFF,
	0xE7, 0xE6, 0xE6, 0xFF, 0xE6, 0xE6, 0xE6, 0x77, 0xE6, 0xE6, 0xE6, 0x00,
	0xE5, 0xE5, 0xE5, 0x00, 0xE5, 0xE5, 0xE5, 0x00, 0xE4, 0xE5, 0xE5, 0x00,
	0xE5, 0xE4, 0xE4, 0x99, 0xE4, 0xE4, 0xE4, 0xFF, 0xE4, 0xE3, 0xE4, 0xFF,
	0xE4, 0xE4, 0xE4, 0xFF, 0xE3, 0xE3, 0xE3, 0xFF, 0xE3, 0xE3, 0xE3, 0xFF,
	0xE2, 0xE2, 0xE2, 0xFF, 0xE2, 0xE2, 0xE2, 0xFF, 0xE2, 0xE2, 0xE2, 0xFF,
	0xE1, 0xE2, 0xE1, 0xFF, 0xE1, 0xE1, 0xE1, 0xFF, 0xE1, 0xE1, 0xE1, 0xFF,
	0xE1, 0xE0, 0xE0, 0xFF, 0xE0, 0xE0, 0xE0, 0xFF, 0xE0, 0xE0, 0xE0, 0xFF,
	0xDF, 0xE0, 0xE0, 0xFF, 0xDF, 0xE0, 0xDF, 0xFF, 0xDF, 0xDF, 0xDE, 0xFF,
	0xDF, 0xDE, 0xDF, 0xFF, 0xDE, 0xDF, 0xDF, 0xFF, 0xDD, 0xDE, 0xDE, 0xFF,
	0xDE, 0xDE, 0xDE, 0xFF, 0xDE, 0xDE, 0xDD, 0xFF, 0xDD, 0xDD, 0xDD, 0x99,
	0xDD, 0xDC, 0xDC, 0x00, 0xDC, 0xDC, 0xDC, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFB, 0xFA, 0xFB, 0x00, 0xFA, 0xFA, 0xFA, 0x00,
	0xF8, 0xF8, 0xF9, 0x0B, 0xF8, 0xF7, 0xF7, 0x8B, 0xF7, 0xF6, 0xF6, 0xFF,
	0xF5, 0xF5, 0xF5, 0xFF, 0xF3, 0xF4, 0xF4, 0xFF, 0xF3, 0xF2, 0xF2, 0xFF,
	0xF1, 0xF1, 0xF1, 0xFF, 0xF0, 0xF0, 0xF0, 0xFF, 0xEE, 0xEF, 0xEF, 0xFF,
	0xED, 0xED, 0xED, 0xFF, 0xEB, 0xEC, 0xEB, 0xFF, 0xEA, 0xEA, 0xEB, 0xFF,
	0xE9, 0xE9, 0xE8, 0xFF, 0xE7, 0xE8, 0xE7, 0xFF, 0xE6, 0xE6, 0xE6, 0xFF,
	0xE5, 0xE5, 0xE5, 0xFF, 0xE3, 0xE3, 0xE3, 0xFF, 0xE1, 0xE1, 0xE2, 0xFF,
	0xE1, 0xE1, 0xE0, 0xFF, 0xDF, 0xDF, 0xDF, 0xFF, 0xDD, 0xDE, 0xDD, 0xFF,
	0xDC, 0xDC, 0xDC, 0xFF, 0xDA, 0xDB, 0xDB, 0xFF, 0xD9, 0xD9, 0xD9, 0xFF,
	0xD8, 0xD8, 0xD8, 0x8C, 0xD7, 0xD8, 0xD7, 0x0B, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x22,
	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x66, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x44,
	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFE, 0xFF, 0xFF, 0xFF, 0xFE, 0xFF, 0xFF,
	0xFE, 0xFE, 0xFE, 0xFF, 0xFE, 0xFE, 0xFF, 0xFF, 0xFE, 0xFE, 0xFE, 0xFF,
	0xFE, 0xFE, 0xFE, 0xFF, 0xFE, 0xFE, 0xFE, 0xFF, 0xFE, 0xFE, 0xFD, 0xFF,
	0xFD, 0xFE, 0xFE, 0xFF, 0xFD, 0xFD, 0xFD, 0x55, 0xFD, 0xFD, 0xFD, 0x00,
	0xFD, 0xFD, 0xFD, 0x00, 0xFD, 0xFD, 0xFD, 0x00, 0xFD, 0xFC, 0xFD, 0x00,
	0xFC, 0xFD, 0xFC, 0x00, 0xFC, 0xFC, 0xFC, 0x00, 0xFC, 0xFC, 0xFC, 0xFF,
	0xFC, 0xFC, 0xFB, 0xFF, 0xFC, 0xFC, 0xFB, 0xFF, 0xFB, 0xFB, 0xFB, 0xFF,
	0xFB, 0xFB, 0xFB, 0xFF, 0xFB, 0xFB, 0xFB, 0xFF, 0xFB, 0xFB, 0xFB, 0xFF,
	0xFA, 0xFA, 0xFA, 0x44, 0xFB, 0xFA, 0xFB, 0x00, 0xFA, 0xFA, 0xFA, 0x00,
	0xFA, 0xFA, 0xFA, 0x00, 0xFA, 0xF9, 0xFA, 0x00, 0xF9, 0xF9, 0xF9, 0x00,
	0xF9, 0xF9, 0xF9, 0x88, 0xF9, 0xF9, 0xF9, 0xAA, 0xF8, 0xF8, 0xF8, 0x11,
	0xF8, 0xF9, 0xF8, 0x00, 0xF8, 0xF8, 0xF9, 0x00, 0xF8, 0xF8, 0xF8, 0x00,
	0xF8, 0xF8, 0xF8, 0x00, 0xF7, 0xF7, 0xF7, 0x00, 0xF7, 0xF7, 0xF7, 0xFF,
	0xF7, 0xF6, 0xF7, 0xFF, 0xF7, 0xF6, 0xF6, 0xFF, 0xF6, 0xF6, 0xF6, 0xFF,
	0xF6, 0xF6, 0xF6, 0xFF, 0xF6, 0xF6, 0xF5, 0xFF, 0xF5, 0xF6, 0xF6, 0xFF,
	0xF5, 0xF5, 0xF5, 0x44, 0xF4, 0xF5, 0xF5, 0x00, 0xF4, 0xF5, 0xF4, 0x00,
	0xF4, 0xF4, 0xF4, 0x00, 0xF4, 0xF4, 0xF4, 0x00, 0xF3, 0xF4, 0xF3, 0x00,
	0xF3, 0xF4, 0xF3, 0xFF, 0xF3, 0xF3, 0xF4, 0xFF, 0xF3, 0xF3, 0xF3, 0xFF,
	0xF2, 0xF3, 0xF3, 0xFF, 0xF2, 0xF2, 0xF2, 0xFF, 0xF2, 0xF2, 0xF2, 0xFF,
	0xF2, 0xF2, 0xF1, 0xFF, 0xF1, 0xF2, 0xF1, 0x77, 0xF1, 0xF1, 0xF1, 0x00,
	0xF0, 0xF0, 0xF1, 0x00, 0xF0, 0xF0, 0xF0, 0x00, 0xF0, 0xF0, 0xF0, 0x44,
	0xF0, 0xF0, 0xEF, 0xFF, 0xF0, 0xEF, 0xEF, 0xFF, 0xEF, 0xEF, 0xEF, 0xFF,
	0xEE, 0xEF, 0xEE, 0xFF, 0xEF, 0xEE, 0xEE, 0xFF, 0xEE, 0xEE, 0xEE, 0xFF,
	0xED, 0xEE, 0xEE, 0xFF, 0xED, 0xEE, 0xED, 0x44, 0xED, 0xED, 0xED, 0x00,
	0xED, 0xED, 0xED, 0x00, 0xEC, 0xED, 0xEC, 0x00, 0xEC, 0xEC, 0xEC, 0x00,
	0xEC, 0xEC, 0xEB, 0x00, 0xEB, 0xEC, 0xEC, 0x11, 0xEB, 0xEB, 0xEB, 0xDD,
	0xEB, 0xEA, 0xEB, 0xFF, 0xEA, 0xEA, 0xEB, 0xFF, 0xEA, 0xEA, 0xEA, 0xFF,
	0xEA, 0xEA, 0xEA, 0xFF, 0xE9, 0xE9, 0xE9, 0xFF, 0xE9, 0xE9, 0xE9, 0xFF,
	0xE9, 0xE8, 0xE8, 0xFF, 0xE8, 0xE8, 0xE8, 0xFF, 0xE8, 0xE8, 0xE9, 0xFF,
	0xE8, 0xE8, 0xE8, 0x77, 0xE7, 0xE7, 0xE7, 0x00, 0xE7, 0xE7, 0xE7, 0x00,
	0xE7, 0xE7, 0xE6, 0x00, 0xE6, 0xE7, 0xE6, 0x11, 0xE6, 0xE6, 0xE6, 0xEE,
	0xE6, 0xE6, 0xE5, 0xFF, 0xE5, 0xE6, 0xE5, 0xFF, 0xE6, 0xE5, 0xE6, 0xFF,
	0xE5, 0xE5, 0xE5, 0xFF, 0xE4, 0xE4, 0xE4, 0xFF, 0xE5, 0xE4, 0xE4, 0xFF,
	0xE4, 0xE3, 0xE3, 0xFF, 0xE4, 0xE3, 0xE4, 0xFF, 0xE3, 0xE4, 0xE4, 0xFF,
	0xE3, 0xE3, 0xE3, 0xFF, 0xE3, 0xE2, 0xE3, 0xFF, 0xE2, 0xE2, 0xE2, 0xFF,
	0xE2, 0xE2, 0xE2, 0xFF, 0xE2, 0xE2, 0xE2, 0xFF, 0xE1, 0xE1, 0xE2, 0xFF,
	0xE1, 0xE1, 0xE1, 0xFF, 0xE1, 0xE1, 0xE0, 0xFF, 0xE0, 0xE0, 0xE0, 0xFF,
	0xE0, 0xE0, 0xE0, 0xFF, 0xE0, 0xE0, 0xE0, 0xFF, 0xDF, 0xE0, 0xDF, 0xFF,
	0xDF, 0xDF, 0xDF, 0xFF, 0xDF, 0xDF, 0xDE, 0xEE, 0xDF, 0xDE, 0xDE, 0x11,
	0xDE, 0xDE, 0xDE, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFA, 0xFB, 0xFB, 0x00, 0xFA, 0xFA, 0xFA, 0x00, 0xF9, 0xF9, 0xF9, 0x00,
	0xF8, 0xF8, 0xF7, 0x1E, 0xF6, 0xF7, 0xF6, 0x90, 0xF6, 0xF5, 0xF5, 0xFF,
	0xF4, 0xF4, 0xF4, 0xFF, 0xF2, 0xF3, 0xF3, 0xFF, 0xF2, 0xF1, 0xF1, 0xFF,
	0xF0, 0xF0, 0xF0, 0xFF, 0xEE, 0xEE, 0xEF, 0xFF, 0xED, 0xED, 0xED, 0xFF,
	0xEB, 0xEC, 0xEC, 0xFF, 0xEA, 0xEB, 0xEA, 0xFF, 0xE9, 0xE9, 0xE9, 0xFF,
	0xE7, 0xE7, 0xE7, 0xFF, 0xE6, 0xE6, 0xE6, 0xFF, 0xE4, 0xE5, 0xE5, 0xFF,
	0xE3, 0xE3, 0xE3, 0xFF, 0xE2, 0xE2, 0xE2, 0xFF, 0xE0, 0xE1, 0xE1, 0xFF,
	0xDF, 0xDF, 0xDF, 0xFF, 0xDD, 0xDD, 0xDD, 0xFF, 0xDC, 0xDC, 0xDC, 0xFF,
	0xDB, 0xDB, 0xDA, 0xFF, 0xD9, 0xDA, 0xD9, 0x91, 0xD8, 0xD8, 0xD8, 0x1F,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x22, 0xFF, 0xFF, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0x66, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x66,
	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFE, 0xFF, 0x66,
	0xFE, 0xFE, 0xFE, 0x00, 0xFE, 0xFE, 0xFE, 0x00, 0xFE, 0xFE, 0xFE, 0x00,
	0xFD, 0xFE, 0xFE, 0x00, 0xFD, 0xFD, 0xFE, 0x00, 0xFE, 0xFD, 0xFE, 0x00,
	0xFD, 0xFE, 0xFD, 0x00, 0xFD, 0xFD, 0xFD, 0xFF, 0xFD, 0xFD, 0xFD, 0xFF,
	0xFC, 0xFD, 0xFD, 0xFF, 0xFD, 0xFD, 0xFD, 0xFF, 0xFD, 0xFC, 0xFD, 0xFF,
	0xFC, 0xFC, 0xFD, 0xFF, 0xFC, 0xFC, 0xFC, 0xFF, 0xFB, 0xFC, 0xFC, 0x44,
	0xFC, 0xFC, 0xFB, 0x00, 0xFB, 0xFB, 0xFB, 0x00, 0xFB, 0xFB, 0xFB, 0x00,
	0xFA, 0xFB, 0xFB, 0x00, 0xFA, 0xFB, 0xFB, 0x00, 0xFA, 0xFB, 0xFA, 0x00,
	0xFA, 0xFA, 0xFA, 0x00, 0xFA, 0xFA, 0xFA, 0x00, 0xF9, 0xFA, 0xFA, 0x00,
	0xFA, 0xFA, 0xF9, 0x00, 0xF9, 0xF9, 0xFA, 0x00, 0xF9, 0xF9, 0xF9, 0x00,
	0xF9, 0xF8, 0xF8, 0x00, 0xF8, 0xF9, 0xF8, 0xFF, 0xF8, 0xF8, 0xF8, 0xFF,
	0xF8, 0xF8, 0xF8, 0xFF, 0xF8, 0xF8, 0xF7, 0xFF, 0xF7, 0xF7, 0xF8, 0xFF,
	0xF7, 0xF7, 0xF7, 0xFF, 0xF6, 0xF7, 0xF7, 0xFF, 0xF7, 0xF7, 0xF7, 0x44,
	0xF7, 0xF7, 0xF6, 0x00, 0xF6, 0xF6, 0xF6, 0x00, 0xF6, 0xF6, 0xF6, 0x00,
	0xF5, 0xF6, 0xF5, 0x00, 0xF6, 0xF5, 0xF5, 0x00, 0xF5, 0xF4, 0xF5, 0xFF,
	0xF5, 0xF4, 0xF4, 0xFF, 0xF4, 0xF4, 0xF4, 0xFF, 0xF4, 0xF4, 0xF4, 0xFF,
	0xF4, 0xF4, 0xF4, 0xFF, 0xF3, 0xF3, 0xF3, 0xFF, 0xF3, 0xF4, 0xF4, 0xFF,
	0xF3, 0xF3, 0xF3, 0x77, 0xF3, 0xF3, 0xF3, 0x00, 0xF2, 0xF2, 0xF3, 0x00,
	0xF2, 0xF2, 0xF2, 0x00, 0xF1, 0xF1, 0xF2, 0x44, 0xF1, 0xF1, 0xF1, 0xFF,
	0xF1, 0xF1, 0xF1, 0xFF, 0xF0, 0xF0, 0xF0, 0xFF, 0xF1, 0xF0, 0xF1, 0xFF,
	0xF0, 0xF0, 0xF1, 0xFF, 0xF0, 0xF0, 0xF0, 0xFF, 0xF0, 0xF0, 0xEF, 0xFF,
	0xEF, 0xEF, 0xEF, 0x44, 0xEE, 0xEF, 0xEE, 0x00, 0xEE, 0xEE, 0xEF, 0x00,
	0xEE, 0xEE, 0xEE, 0x00, 0xEE, 0xEE, 0xEE, 0x00, 0xED, 0xED, 0xEE, 0x00,
	0xED, 0xED, 0xEE, 0x00, 0xED, 0xED, 0xED, 0x44, 0xEC, 0xED, 0xED, 0xFF,
	0xEC, 0xEC, 0xED, 0xFF, 0xEC, 0xEC, 0xEC, 0xFF, 0xEC, 0xEB, 0xEC, 0xFF,
	0xEB, 0xEB, 0xEC, 0xFF, 0xEB, 0xEB, 0xEB, 0xFF, 0xEB, 0xEB, 0xEB, 0xFF,
	0xEA, 0xEA, 0xEA, 0xFF, 0xEA, 0xEA, 0xEA, 0xFF, 0xEA, 0xEA, 0xEA, 0x77,
	0xE9, 0xE9, 0xE9, 0x00, 0xE9, 0xE8, 0xE9, 0x00, 0xE9, 0xE8, 0xE9, 0x00,
	0xE8, 0xE8, 0xE8, 0x66, 0xE7, 0xE7, 0xE8, 0xFF, 0xE8, 0xE7, 0xE8, 0xFF,
	0xE8, 0xE7, 0xE7, 0xFF, 0xE7, 0xE7, 0xE7, 0xFF, 0xE6, 0xE7, 0xE6, 0xFF,
	0xE7, 0xE6, 0xE6, 0xFF, 0xE6, 0xE6, 0xE6, 0xFF, 0xE5, 0xE6, 0xE6, 0x77,
	0xE6, 0xE5, 0xE5, 0x00, 0xE5, 0xE5, 0xE5, 0x00, 0xE5, 0xE5, 0xE4, 0x00,
	0xE4, 0xE4, 0xE5, 0x00, 0xE4, 0xE4, 0xE4, 0x00, 0xE3, 0xE4, 0xE3, 0x00,
	0xE3, 0xE4, 0xE4, 0x00, 0xE3, 0xE3, 0xE3, 0x00, 0xE3, 0xE3, 0xE3, 0x77,
	0xE2, 0xE2, 0xE2, 0xFF, 0xE2, 0xE2, 0xE2, 0xFF, 0xE2, 0xE2, 0xE2, 0xFF,
	0xE1, 0xE2, 0xE1, 0xFF, 0xE1, 0xE1, 0xE1, 0xFF, 0xE1, 0xE1, 0xE1, 0xFF,
	0xE0, 0xE1, 0xE0, 0xFF, 0xE0, 0xE0, 0xE0, 0x66, 0xDF, 0xE0, 0xE0, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFB, 0xFB, 0xFB, 0x00,
	0xFA, 0xFA, 0xFA, 0x00, 0xF8, 0xF9, 0xF9, 0x00, 0xF8, 0xF7, 0xF8, 0x00,
	0xF7, 0xF7, 0xF7, 0x1C, 0xF5, 0xF6, 0xF5, 0x81, 0xF4, 0xF4, 0xF4, 0xEC,
	0xF3, 0xF2, 0xF3, 0xFF, 0xF1, 0xF1, 0xF1, 0xFF, 0xF0, 0xF0, 0xF0, 0xFF,
	0xEF, 0xEF, 0xEF, 0xFF, 0xEE, 0xED, 0xED, 0xFF, 0xEC, 0xEC, 0xEC, 0xFF,
	0xEB, 0xEB, 0xEB, 0xFF, 0xE9, 0xE9, 0xE9, 0xFF, 0xE8, 0xE8, 0xE7, 0xFF,
	0xE6, 0xE6, 0xE7, 0xFF, 0xE5, 0xE5, 0xE4, 0xFF, 0xE3, 0xE3, 0xE3, 0xFF,
	0xE2, 0xE2, 0xE2, 0xFF, 0xE0, 0xE0, 0xE0, 0xFF, 0xDF, 0xDF, 0xDF, 0xFF,
	0xDE, 0xDE, 0xDD, 0xFF, 0xDC, 0xDC, 0xDD, 0xED, 0xDB, 0xDB, 0xDB, 0x81,
	0xDA, 0xDA, 0xDA, 0x1D, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x22, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x66,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x44,
	0xFF, 0xFF, 0xFF, 0xDD, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xEE,
	0xFF, 0xFF, 0xFF, 0x44, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFE, 0x00, 0xFF, 0xFE, 0xFF, 0x00,
	0xFF, 0xFE, 0xFF, 0x00, 0xFE, 0xFE, 0xFF, 0x00, 0xFF, 0xFF, 0xFE, 0x00,
	0xFE, 0xFE, 0xFE, 0xFF, 0xFE, 0xFE, 0xFE, 0xFF, 0xFD, 0xFE, 0xFE, 0xFF,
	0xFD, 0xFD, 0xFD, 0xFF, 0xFE, 0xFE, 0xFE, 0xFF, 0xFD, 0xFD, 0xFD, 0xFF,
	0xFC, 0xFD, 0xFD, 0xFF, 0xFD, 0xFD, 0xFD, 0x44, 0xFD, 0xFD, 0xFD, 0x00,
	0xFC, 0xFD, 0xFC, 0x00, 0xFC, 0xFC, 0xFC, 0x00, 0xFC, 0xFC, 0xFC, 0x00,
	0xFB, 0xFC, 0xFB, 0x00, 0xFB, 0xFB, 0xFC, 0x00, 0xFB, 0xFB, 0xFC, 0x00,
	0xFB, 0xFB, 0xFB, 0x00, 0xFB, 0xFB, 0xFB, 0x00, 0xFB, 0xFB, 0xFB, 0x00,
	0xFB, 0xFB, 0xFA, 0x00, 0xFA, 0xFA, 0xFA, 0x00, 0xFA, 0xFA, 0xFA, 0x00,
	0xFA, 0xFA, 0xFA, 0xFF, 0xF9, 0xFA, 0xF9, 0xFF, 0xFA, 0xFA, 0xF9, 0xFF,
	0xF9, 0xF9, 0xF9, 0xFF, 0xF8, 0xF9, 0xF9, 0xFF, 0xF9, 0xF9, 0xF8, 0xFF,
	0xF9, 0xF8, 0xF9, 0xFF, 0xF8, 0xF8, 0xF8, 0x44, 0xF8, 0xF8, 0xF8, 0x00,
	0xF7, 0xF8, 0xF8, 0x00, 0xF7, 0xF7, 0xF8, 0x00, 0xF7, 0xF7, 0xF7, 0x00,
	0xF6, 0xF7, 0xF6, 0x00, 0xF6, 0xF7, 0xF6, 0xFF, 0xF6, 0xF6, 0xF6, 0xFF,
	0xF6, 0xF6, 0xF6, 0xFF, 0xF6, 0xF5, 0xF6, 0xFF, 0xF6, 0xF5, 0xF5, 0xFF,
	0xF5, 0xF5, 0xF5, 0xFF, 0xF5, 0xF5, 0xF4, 0xFF, 0xF4, 0xF4, 0xF5, 0x77,
	0xF4, 0xF4, 0xF4, 0x00, 0xF3, 0xF4, 0xF4, 0x00, 0xF4, 0xF4, 0xF3, 0x00,
	0xF3, 0xF3, 0xF3, 0x44, 0xF3, 0xF3, 0xF3, 0xFF, 0xF3, 0xF3, 0xF3, 0xFF,
	0xF2, 0xF2, 0xF2, 0xFF, 0xF2, 0xF2, 0xF2, 0xFF, 0xF2, 0xF2, 0xF1, 0xFF,
	0xF1, 0xF1, 0xF2, 0xFF, 0xF1, 0xF1, 0xF1, 0xFF, 0xF1, 0xF1, 0xF1, 0x44,
	0xF0, 0xF0, 0xF0, 0x00, 0xF1, 0xF0, 0xF0, 0x00, 0xEF, 0xF0, 0xF0, 0x00,
	0xEF, 0xF0, 0xF0, 0x00, 0xF0, 0xF0, 0xEF, 0x00, 0xEF, 0xEF, 0xEF, 0x00,
	0xEF, 0xEF, 0xEE, 0x00, 0xEE, 0xEF, 0xEE, 0x88, 0xEE, 0xEE, 0xEE, 0xFF,
	0xEE, 0xEE, 0xED, 0xFF, 0xEE, 0xEE, 0xED, 0xFF, 0xED, 0xED, 0xED, 0xFF,
	0xED, 0xED, 0xED, 0xFF, 0xEC, 0xED, 0xEC, 0xFF, 0xEC, 0xEC, 0xEC, 0xFF,
	0xEC, 0xEC, 0xEC, 0xFF, 0xEB, 0xEC, 0xEC, 0x77, 0xEC, 0xEB, 0xEB, 0x00,
	0xEB, 0xEB, 0xEB, 0x00, 0xEA, 0xEA, 0xEB, 0x00, 0xEA, 0xEA, 0xEA, 0xBB,
	0xEA, 0xEA, 0xEA, 0xFF, 0xEA, 0xEA, 0xEA, 0xFF, 0xE9, 0xE9, 0xE9, 0xFF,
	0xE8, 0xE9, 0xE9, 0xFF, 0xE8, 0xE9, 0xE8, 0xFF, 0xE8, 0xE8, 0xE8, 0xFF,
	0xE8, 0xE7, 0xE7, 0xFF, 0xE7, 0xE7, 0xE7, 0x22, 0xE7, 0xE7, 0xE7, 0x00,
	0xE6, 0xE7, 0xE6, 0x00, 0xE6, 0xE6, 0xE6, 0x00, 0xE6, 0xE6, 0xE6, 0x00,
	0xE6, 0xE6, 0xE6, 0x00, 0xE6, 0xE5, 0xE5, 0x00, 0xE5, 0xE5, 0xE5, 0x00,
	0xE5, 0xE5, 0xE5, 0x00, 0xE4, 0xE4, 0xE5, 0x22, 0xE4, 0xE4, 0xE4, 0xFF,
	0xE3, 0xE4, 0xE4, 0xFF, 0xE4, 0xE3, 0xE3, 0xFF, 0xE3, 0xE3, 0xE3, 0xFF,
	0xE3, 0xE3, 0xE3, 0xFF, 0xE2, 0xE2, 0xE3, 0xFF, 0xE2, 0xE2, 0xE2, 0xFF,
	0xE2, 0xE2, 0xE2, 0xBB, 0xE1, 0xE1, 0xE1, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFC, 0xFB, 0xFB, 0x00, 0xFA, 0xFA, 0xFA, 0x00,
	0xF9, 0xF9, 0xF9, 0x00, 0xF8, 0xF8, 0xF7, 0x00, 0xF7, 0xF7, 0xF7, 0x00,
	0xF6, 0xF6, 0xF6, 0x05, 0xF4, 0xF4, 0xF5, 0x6A, 0xF4, 0xF3, 0xF3, 0xB5,
	0xF2, 0xF2, 0xF1, 0xF0, 0xF0, 0xF0, 0xF0, 0xFF, 0xEF, 0xEF, 0xEF, 0xFF,
	0xED, 0xEE, 0xEE, 0xFF, 0xEC, 0xEC, 0xED, 0xFF, 0xEB, 0xEA, 0xEA, 0xFF,
	0xEA, 0xEA, 0xE9, 0xFF, 0xE7, 0xE8, 0xE7, 0xFF, 0xE7, 0xE6, 0xE6, 0xFF,
	0xE4, 0xE4, 0xE5, 0xFF, 0xE4, 0xE3, 0xE4, 0xFF, 0xE2, 0xE2, 0xE2, 0xFF,
	0xE0, 0xE0, 0xE1, 0xFF, 0xDF, 0xDF, 0xDF, 0xF0, 0xDE, 0xDE, 0xDE, 0xB5,
	0xDC, 0xDD, 0xDC, 0x6B, 0xDB, 0xDB, 0xDB, 0x06, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x22,
	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x66, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x77, 0xFF, 0xFF, 0xFF, 0xEE, 0xFF, 0xFF, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0x77, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFE, 0x00, 0xFF, 0xFF, 0xFF, 0xFF,
	0xFF, 0xFE, 0xFF, 0xFF, 0xFF, 0xFF, 0xFE, 0xFF, 0xFF, 0xFF, 0xFE, 0xFF,
	0xFE, 0xFE, 0xFF, 0xFF, 0xFE, 0xFE, 0xFF, 0xFF, 0xFE, 0xFE, 0xFE, 0xFF,
	0xFE, 0xFE, 0xFD, 0x44, 0xFE, 0xFE, 0xFE, 0x00, 0xFE, 0xFD, 0xFD, 0x00,
	0xFD, 0xFD, 0xFD, 0x00, 0xFD, 0xFD, 0xFD, 0x00, 0xFD, 0xFD, 0xFD, 0x00,
	0xFC, 0xFC, 0xFC, 0x00, 0xFD, 0xFD, 0xFC, 0x00, 0xFC, 0xFD, 0xFD, 0x00,
	0xFC, 0xFC, 0xFC, 0x00, 0xFB, 0xFC, 0xFB, 0x00, 0xFC, 0xFC, 0xFC, 0x00,
	0xFC, 0xFC, 0xFB, 0x00, 0xFB, 0xFB, 0xFB, 0x00, 0xFB, 0xFB, 0xFB, 0xFF,
	0xFB, 0xFA, 0xFB, 0xFF, 0xFB, 0xFA, 0xFB, 0xFF, 0xFA, 0xFA, 0xFA, 0xFF,
	0xFA, 0xFA, 0xFB, 0xFF, 0xFA, 0xFA, 0xF9, 0xFF, 0xFA, 0xF9, 0xFA, 0xFF,
	0xFA, 0xF9, 0xF9, 0x44, 0xF9, 0xF9, 0xF9, 0x00, 0xF9, 0xF9, 0xF8, 0x00,
	0xF9, 0xF9, 0xF8, 0x00, 0xF9, 0xF9, 0xF8, 0x00, 0xF8, 0xF8, 0xF8, 0x00,
	0xF8, 0xF8, 0xF8, 0xFF, 0xF7, 0xF8, 0xF7, 0xFF, 0xF8, 0xF7, 0xF7, 0xFF,
	0xF7, 0xF7, 0xF7, 0xFF, 0xF7, 0xF7, 0xF7, 0xFF, 0xF6, 0xF6, 0xF6, 0xFF,
	0xF7, 0xF6, 0xF6, 0xFF, 0xF6, 0xF6, 0xF6, 0x77, 0xF6, 0xF5, 0xF6, 0x00,
	0xF5, 0xF6, 0xF5, 0x00, 0xF5, 0xF5, 0xF5, 0x00, 0xF5, 0xF5, 0xF5, 0x44,
	0xF4, 0xF5, 0xF5, 0xFF, 0xF4, 0xF4, 0xF4, 0xFF, 0xF4, 0xF4, 0xF4, 0xFF,
	0xF4, 0xF4, 0xF4, 0xFF, 0xF3, 0xF4, 0xF3, 0xFF, 0xF3, 0xF3, 0xF3, 0xFF,
	0xF2, 0xF2, 0xF3, 0xFF, 0xF3, 0xF3, 0xF3, 0x44, 0xF3, 0xF3, 0xF2, 0x00,
	0xF1, 0xF2, 0xF2, 0x00, 0xF1, 0xF2, 0xF1, 0x00, 0xF2, 0xF1, 0xF1, 0x00,
	0xF1, 0xF0, 0xF1, 0x00, 0xF1, 0xF1, 0xF0, 0x00, 0xF0, 0xF0, 0xF0, 0x00,
	0xF0, 0xF0, 0xF0, 0x11, 0xF0, 0xEF, 0xF0, 0xEE, 0xEF, 0xEF, 0xF0, 0xFF,
	0xEF, 0xEF, 0xEF, 0xFF, 0xEE, 0xEE, 0xEF, 0xFF, 0xEF, 0xEF, 0xEE, 0xFF,
	0xEE, 0xEE, 0xEE, 0xFF, 0xEE, 0xEE, 0xED, 0xFF, 0xED, 0xED, 0xED, 0xFF,
	0xEE, 0xED, 0xEE, 0x77, 0xED, 0xED, 0xED, 0x00, 0xED, 0xEC, 0xEC, 0x00,
	0xED, 0xEC, 0xED, 0x22, 0xEB, 0xEB, 0xEC, 0xFF, 0xEB, 0xEC, 0xEC, 0xFF,
	0xEB, 0xEB, 0xEC, 0xFF, 0xEB, 0xEB, 0xEB, 0xFF, 0xEB, 0xEA, 0xEA, 0xFF,
	0xEA, 0xEA, 0xEA, 0xFF, 0xEA, 0xEA, 0xEA, 0xFF, 0xEA, 0xE9, 0xEA, 0xBB,
	0xE9, 0xE9, 0xE9, 0x00, 0xE9, 0xE8, 0xE9, 0x00, 0xE8, 0xE8, 0xE9, 0x00,
	0xE8, 0xE8, 0xE8, 0x00, 0xE8, 0xE8, 0xE8, 0x00, 0xE7, 0xE7, 0xE8, 0x00,
	0xE7, 0xE7, 0xE7, 0x00, 0xE6, 0xE6, 0xE7, 0x00, 0xE7, 0xE7, 0xE7, 0x00,
	0xE7, 0xE6, 0xE7, 0x00, 0xE6, 0xE6, 0xE6, 0xBB, 0xE6, 0xE5, 0xE6, 0xFF,
	0xE6, 0xE5, 0xE5, 0xFF, 0xE5, 0xE5, 0xE5, 0xFF, 0xE5, 0xE4, 0xE4, 0xFF,
	0xE4, 0xE4, 0xE4, 0xFF, 0xE4, 0xE4, 0xE4, 0xFF, 0xE3, 0xE3, 0xE3, 0xFF,
	0xE3, 0xE3, 0xE3, 0x22, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFC, 0xFB, 0xFB, 0x00, 0xFA, 0xFA, 0xFA, 0x00, 0xFA, 0xF9, 0xF9, 0x00,
	0xF8, 0xF8, 0xF8, 0x00, 0xF7, 0xF6, 0xF7, 0x00, 0xF5, 0xF6, 0xF6, 0x00,
	0xF4, 0xF4, 0xF5, 0x00, 0xF3, 0xF4, 0xF3, 0x21, 0xF2, 0xF2, 0xF1, 0x87,
	0xF1, 0xF1, 0xF0, 0xCD, 0xEF, 0xEF, 0xEF, 0xE1, 0xEE, 0xEE, 0xED, 0xF1,
	0xEC, 0xEC, 0xEC, 0xFB, 0xEB, 0xEB, 0xEB, 0xFF, 0xE9, 0xE9, 0xE9, 0xFF,
	0xE8, 0xE8, 0xE8, 0xFF, 0xE6, 0xE6, 0xE7, 0xFF, 0xE5, 0xE5, 0xE5, 0xFB,
	0xE3, 0xE4, 0xE3, 0xF1, 0xE2, 0xE2, 0xE2, 0xE1, 0xE1, 0xE1, 0xE1, 0xCD,
	0xDF, 0xDF, 0xDF, 0x87, 0xDE, 0xDE, 0xDE, 0x21, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x22, 0xFF, 0xFF, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0x66, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x55, 0xFF, 0xFF, 0xFF, 0x77,
	0xFF, 0xFF, 0xFF, 0xDD, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xEE, 0xFF, 0xFF, 0xFF, 0x77,
	0xFF, 0xFF, 0xFF, 0x55, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x44,
	0xFE, 0xFE, 0xFF, 0x00, 0xFE, 0xFF, 0xFE, 0x00, 0xFE, 0xFE, 0xFE, 0x00,
	0xFE, 0xFE, 0xFE, 0x00, 0xFD, 0xFE, 0xFE, 0x00, 0xFE, 0xFE, 0xFE, 0x00,
	0xFD, 0xFD, 0xFE, 0x00, 0xFD, 0xFD, 0xFD, 0x00, 0xFD, 0xFD, 0xFD, 0x00,
	0xFD, 0xFD, 0xFD, 0x00, 0xFD, 0xFD, 0xFC, 0x00, 0xFC, 0xFC, 0xFC, 0x00,
	0xFC, 0xFC, 0xFC, 0x00, 0xFC, 0xFC, 0xFC, 0xFF, 0xFC, 0xFC, 0xFC, 0xFF,
	0xFB, 0xFB, 0xFC, 0xFF, 0xFB, 0xFC, 0xFB, 0xFF, 0xFC, 0xFB, 0xFC, 0xFF,
	0xFB, 0xFB, 0xFB, 0xFF, 0xFA, 0xFA, 0xFB, 0xFF, 0xFB, 0xFA, 0xFB, 0x44,
	0xFB, 0xFB, 0xFA, 0x00, 0xFB, 0xFA, 0xFA, 0x00, 0xFA, 0xFA, 0xFA, 0x00,
	0xFA, 0xFA, 0xFA, 0x00, 0xF9, 0xFA, 0xFA, 0x00, 0xF9, 0xF9, 0xF9, 0xFF,
	0xF8, 0xF9, 0xF9, 0xFF, 0xF9, 0xF9, 0xF9, 0xFF, 0xF8, 0xF9, 0xF8, 0xFF,
	0xF8, 0xF9, 0xF8, 0xFF, 0xF8, 0xF8, 0xF8, 0xFF, 0xF7, 0xF8, 0xF8, 0xFF,
	0xF7, 0xF7, 0xF7, 0x77, 0xF8, 0xF8, 0xF7, 0x00, 0xF6, 0xF7, 0xF7, 0x00,
	0xF7, 0xF7, 0xF6, 0x00, 0xF7, 0xF6, 0xF6, 0x44, 0xF6, 0xF6, 0xF6, 0xFF,
	0xF6, 0xF6, 0xF6, 0xFF, 0xF6, 0xF5, 0xF5, 0xFF, 0xF5, 0xF5, 0xF5, 0xFF,
	0xF5, 0xF5, 0xF5, 0xFF, 0xF5, 0xF4, 0xF5, 0xFF, 0xF5, 0xF4, 0xF4, 0xFF,
	0xF4, 0xF4, 0xF4, 0x44, 0xF4, 0xF4, 0xF4, 0x00, 0xF3, 0xF3, 0xF4, 0x00,
	0xF3, 0xF3, 0xF3, 0x00, 0xF3, 0xF3, 0xF3, 0x00, 0xF2, 0xF3, 0xF3, 0x00,
	0xF2, 0xF2, 0xF2, 0x00, 0xF2, 0xF2, 0xF2, 0x00, 0xF1, 0xF2, 0xF2, 0x00,
	0xF1, 0xF1, 0xF1, 0x55, 0xF1, 0xF1, 0xF1, 0xFF, 0xF1, 0xF1, 0xF1, 0xFF,
	0xF0, 0xF1, 0xF0, 0xFF, 0xF0, 0xF0, 0xF0, 0xFF, 0xF0, 0xF0, 0xEF, 0xFF,
	0xEF, 0xF0, 0xF0, 0xFF, 0xEF, 0xEF, 0xEF, 0xFF, 0xEF, 0xEF, 0xEF, 0x77,
	0xEF, 0xEF, 0xEF, 0x00, 0xEE, 0xEE, 0xEE, 0x00, 0xEE, 0xEE, 0xEE, 0x77,
	0xEE, 0xED, 0xEE, 0xFF, 0xED, 0xEE, 0xED, 0xFF, 0xED, 0xED, 0xED, 0xFF,
	0xED, 0xEC, 0xED, 0xFF, 0xEC, 0xEC, 0xED, 0xFF, 0xEC, 0xEC, 0xEC, 0xFF,
	0xEB, 0xEB, 0xEC, 0xFF, 0xEB, 0xEC, 0xEB, 0x66, 0xEB, 0xEB, 0xEB, 0x00,
	0xEB, 0xEA, 0xEB, 0x00, 0xEA, 0xEB, 0xEB, 0x00, 0xEA, 0xEA, 0xEA, 0x00,
	0xEA, 0xEA, 0xE9, 0x00, 0xE9, 0xEA, 0xE9, 0x00, 0xE9, 0xE9, 0xE9, 0x00,
	0xE8, 0xE9, 0xE8, 0x00, 0xE8, 0xE9, 0xE9, 0x00, 0xE8, 0xE7, 0xE8, 0x00,
	0xE8, 0xE8, 0xE8, 0x66, 0xE7, 0xE8, 0xE7, 0xFF, 0xE7, 0xE7, 0xE7, 0xFF,
	0xE6, 0xE6, 0xE7, 0xFF, 0xE6, 0xE6, 0xE7, 0xFF, 0xE6, 0xE6, 0xE6, 0xFF,
	0xE5, 0xE5, 0xE6, 0xFF, 0xE5, 0xE5, 0xE6, 0xFF, 0xE5, 0xE5, 0xE5, 0x77,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFB, 0xFB, 0xFB, 0x00,
	0xFB, 0xFA, 0xFA, 0x00, 0xF9, 0xF9, 0xF9, 0x00, 0xF8, 0xF8, 0xF8, 0x00,
	0xF7, 0xF7, 0xF7, 0x00, 0xF5, 0xF6, 0xF6, 0x00, 0xF4, 0xF5, 0xF4, 0x00,
	0xF3, 0xF3, 0xF3, 0x00, 0xF2, 0xF2, 0xF2, 0x00, 0xF0, 0xF1, 0xF1, 0x22,
	0xF0, 0xEF, 0xEF, 0x6B, 0xED, 0xEE, 0xEE, 0xA6, 0xEC, 0xED, 0xEC, 0xCD,
	0xEB, 0xEB, 0xEB, 0xEA, 0xE9, 0xEA, 0xE9, 0xFD, 0xE8, 0xE8, 0xE8, 0xFD,
	0xE6, 0xE7, 0xE6, 0xEA, 0xE5, 0xE5, 0xE5, 0xCD, 0xE4, 0xE4, 0xE4, 0xA6,
	0xE2, 0xE2, 0xE2, 0x6B, 0xE1, 0xE1, 0xE1, 0x22, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00
	};

	unsigned char flashingData[784] = {
		0xD0, 0xD0, 0xD1, 0x00, 0xD0, 0xD0, 0xD1, 0x00, 0xCE, 0xCE, 0xCF, 0x05,
		0xE4, 0xE1, 0xE3, 0x03, 0xEE, 0xDC, 0xDC, 0x00, 0xF0, 0xE1, 0xE1, 0x00,
		0xCA, 0xD5, 0xCB, 0x00, 0xC7, 0xD4, 0xC9, 0x00, 0xD7, 0xDE, 0xD8, 0x41,
		0xE4, 0xE3, 0xE4, 0x18, 0xE2, 0xE2, 0xE2, 0x00, 0xE6, 0xE6, 0xE6, 0x00,
		0xED, 0xF0, 0xF0, 0x00, 0xC9, 0xCF, 0xCF, 0x00, 0xCC, 0xD1, 0xCD, 0x00,
		0xCB, 0xD1, 0xCD, 0x00, 0xCA, 0xCF, 0xCC, 0x07, 0xE6, 0xE8, 0xE6, 0x68,
		0xEF, 0xDC, 0xDC, 0x1D, 0xEF, 0xDF, 0xDF, 0x00, 0xB3, 0xCB, 0xB5, 0x00,
		0xAF, 0xCB, 0xB4, 0x19, 0xEA, 0xEE, 0xE9, 0xBD, 0xF7, 0xEB, 0xED, 0x29,
		0xF3, 0xEC, 0xEC, 0x00, 0xF0, 0xF1, 0xF1, 0x00, 0xEE, 0xF0, 0xF0, 0x00,
		0xC8, 0xCF, 0xCF, 0x00, 0xCF, 0xD1, 0xD0, 0x00, 0xCF, 0xD9, 0xD1, 0x00,
		0xCC, 0xD7, 0xCE, 0x00, 0xDD, 0xE8, 0xE1, 0x84, 0xF8, 0xF1, 0xF1, 0xC4,
		0xF6, 0xE3, 0xE4, 0x15, 0xC1, 0xC7, 0xB8, 0x00, 0xC6, 0xDC, 0xCC, 0x7D,
		0xFF, 0xFD, 0xFE, 0xEC, 0xFC, 0xF3, 0xF3, 0x25, 0xF5, 0xF2, 0xF2, 0x00,
		0xEF, 0xEF, 0xEF, 0x00, 0xEE, 0xF0, 0xF0, 0x00, 0xC9, 0xD2, 0xD2, 0x00,
		0xD9, 0xD7, 0xD8, 0x00, 0xF3, 0xF6, 0xF2, 0x00, 0xC5, 0xDA, 0xC8, 0x00,
		0xBF, 0xD5, 0xC2, 0x2F, 0xFB, 0xFE, 0xFD, 0xFF, 0xFC, 0xF3, 0xF5, 0xC1,
		0xD3, 0xD2, 0xC9, 0x3A, 0xED, 0xF6, 0xF0, 0xDE, 0xFF, 0xFD, 0xFD, 0xF2,
		0xF1, 0xEA, 0xEA, 0x26, 0xF2, 0xF3, 0xF3, 0x02, 0xF0, 0xF0, 0xF0, 0x2E,
		0xEF, 0xEF, 0xEF, 0x6A, 0xC4, 0xB7, 0xB7, 0x17, 0xD6, 0xD5, 0xD6, 0x00,
		0xFF, 0xFF, 0xFF, 0x00, 0xE5, 0xED, 0xE7, 0x00, 0xBD, 0xD0, 0xC1, 0x00,
		0xEB, 0xF0, 0xEB, 0xB5, 0xF4, 0xEE, 0xED, 0xB5, 0xFD, 0xFD, 0xFC, 0xF2,
		0xF2, 0xE9, 0xE7, 0xAB, 0xF1, 0xEE, 0xEB, 0xB9, 0xF5, 0xF0, 0xF1, 0xAE,
		0xFB, 0xFB, 0xFB, 0xC2, 0xFF, 0xFF, 0xFF, 0xFE, 0xE7, 0xD1, 0xD1, 0x98,
		0xBA, 0x98, 0x98, 0x03, 0xD7, 0xD6, 0xD7, 0x45, 0xFF, 0xFF, 0xFF, 0x6E,
		0xF5, 0xF5, 0xF5, 0x62, 0xF0, 0xEC, 0xF0, 0x6F, 0xFB, 0xFD, 0xFC, 0xD8,
		0xF4, 0xEB, 0xE9, 0x7A, 0xEB, 0xEB, 0xE8, 0x53, 0xD2, 0xCD, 0xC9, 0x21,
		0xD7, 0xE6, 0xD9, 0x78, 0xF5, 0xF3, 0xF0, 0xA7, 0xEC, 0xEF, 0xEA, 0xC6,
		0xF9, 0xF1, 0xF1, 0xD8, 0xDA, 0xB8, 0xB8, 0x0E, 0xBD, 0x9E, 0x9E, 0x00,
		0xDC, 0xE5, 0xDD, 0x45, 0xF2, 0xF7, 0xF3, 0xD8, 0xFF, 0xFE, 0xFF, 0xFA,
		0xF8, 0xF3, 0xF1, 0x9C, 0xF0, 0xEB, 0xE7, 0x8F, 0xEC, 0xEA, 0xEA, 0x58,
		0xE7, 0xE7, 0xE5, 0x0B, 0xE0, 0xE0, 0xDE, 0x40, 0xD9, 0xDB, 0xD6, 0x11,
		0xC9, 0xD8, 0xC8, 0x27, 0xE7, 0xEE, 0xE8, 0xCC, 0xED, 0xD9, 0xDA, 0x40,
		0xE2, 0xC8, 0xC8, 0x00, 0xE8, 0xD6, 0xD6, 0x00, 0xD7, 0xE2, 0xD9, 0x00,
		0xDD, 0xE9, 0xDF, 0x1C, 0xF2, 0xF6, 0xF2, 0xA8, 0xFD, 0xF7, 0xF7, 0x9B,
		0xF0, 0xE2, 0xE1, 0x12, 0xC3, 0xBE, 0xBE, 0x00, 0xDF, 0xE7, 0xE2, 0x83,
		0xFF, 0xFF, 0xFF, 0xFF, 0xE2, 0xD5, 0xD4, 0x59, 0xCE, 0xD7, 0xCA, 0x62,
		0xFC, 0xFB, 0xFB, 0xEA, 0xF7, 0xF0, 0xF1, 0x74, 0xF4, 0xEA, 0xEA, 0x10,
		0xF0, 0xE2, 0xE2, 0x00, 0xDE, 0xE6, 0xE0, 0x00, 0xD0, 0xE0, 0xD3, 0x00,
		0xC3, 0xD7, 0xC6, 0x03, 0xE7, 0xF0, 0xEA, 0xB4, 0xF6, 0xEB, 0xEC, 0xAB,
		0xE5, 0xE0, 0xDF, 0x05, 0xD5, 0xE1, 0xD9, 0x3B, 0xEC, 0xEC, 0xEB, 0x90,
		0xE6, 0xDA, 0xDA, 0x3B, 0xEA, 0xE3, 0xE4, 0x15, 0xE8, 0xEF, 0xEB, 0x7E,
		0xFB, 0xFE, 0xFD, 0xFF, 0xFB, 0xF8, 0xF9, 0xE1, 0xF0, 0xE3, 0xE3, 0x50,
		0xAD, 0xC8, 0xB2, 0x00, 0x9A, 0xBD, 0xA1, 0x00, 0x9F, 0xBF, 0xA4, 0x0B,
		0xE0, 0xEA, 0xE1, 0xBA, 0xF5, 0xEB, 0xEE, 0xB2, 0xF8, 0xF7, 0xF6, 0xB8,
		0xE8, 0xE1, 0xDD, 0x32, 0xC2, 0xC8, 0xC4, 0x00, 0xE4, 0xDC, 0xDC, 0x01,
		0xF0, 0xF3, 0xF0, 0x89, 0xF9, 0xF8, 0xF7, 0xD9, 0xF8, 0xF5, 0xF3, 0x9C,
		0xF5, 0xEF, 0xED, 0x6F, 0xEE, 0xE0, 0xE0, 0x33, 0x8E, 0xB5, 0x95, 0x00,
		0x8F, 0xB5, 0x96, 0x00, 0xCB, 0xDD, 0xCE, 0x80, 0xFF, 0xFE, 0xFE, 0xF4,
		0xF6, 0xED, 0xEB, 0x92, 0xFE, 0xF9, 0xF9, 0xC4, 0xE9, 0xE6, 0xE1, 0x59,
		0xE5, 0xED, 0xE7, 0xA0, 0xFA, 0xF5, 0xF6, 0xC3, 0xED, 0xF2, 0xED, 0xAE,
		0xF4, 0xE9, 0xE9, 0x97, 0xED, 0xDD, 0xDD, 0x00, 0xF1, 0xE9, 0xE5, 0x00,
		0xEC, 0xDC, 0xDB, 0x00, 0xA8, 0xC7, 0xAE, 0x00, 0xAB, 0xC8, 0xB1, 0x19,
		0xE0, 0xE2, 0xDA, 0x84, 0xF9, 0xED, 0xEC, 0x3A, 0xE7, 0xE0, 0xD9, 0x00,
		0xE5, 0xEC, 0xE5, 0x82, 0xF9, 0xF8, 0xF7, 0xE5, 0xF4, 0xEC, 0xEA, 0xB6,
		0xF0, 0xF0, 0xED, 0xA7, 0xFC, 0xFC, 0xFC, 0xFE, 0xF8, 0xEF, 0xEF, 0xB0,
		0xE8, 0xD3, 0xD4, 0x00, 0xEF, 0xE1, 0xDF, 0x00, 0xEC, 0xDC, 0xDB, 0x00,
		0xC0, 0xD7, 0xC4, 0x00, 0xC1, 0xD9, 0xC6, 0x07, 0xE0, 0xDD, 0xD5, 0x00,
		0xEC, 0xE5, 0xE1, 0x00, 0xEB, 0xF3, 0xEE, 0x00, 0xF4, 0xFA, 0xF7, 0x94,
		0xF8, 0xEF, 0xEF, 0xDE, 0xD8, 0xB3, 0xB3, 0x1C, 0xDE, 0xDF, 0xD8, 0x00,
		0xEA, 0xF5, 0xEE, 0x83, 0xF7, 0xF2, 0xF1, 0xD3, 0xEA, 0xD8, 0xD8, 0x1A,
		0xEA, 0xDA, 0xDB, 0x00, 0xEA, 0xDB, 0xDC, 0x00, 0xBF, 0xD6, 0xC3, 0x00,
		0xC0, 0xD8, 0xC5, 0x00, 0xE3, 0xE0, 0xD9, 0x00, 0xCB, 0xD4, 0xC5, 0x00,
		0xBA, 0xD4, 0xBF, 0x00, 0xCF, 0xDD, 0xD2, 0x5D, 0xDF, 0xC5, 0xC6, 0x3B,
		0xD3, 0xA8, 0xA8, 0x00, 0xE1, 0xE3, 0xDC, 0x00, 0xD9, 0xE9, 0xDE, 0x00,
		0xDA, 0xE2, 0xDA, 0x4A, 0xEB, 0xE4, 0xE5, 0x21, 0xEC, 0xE6, 0xE7, 0x00,
		0xEB, 0xE6, 0xE7, 0x00
	};

	unsigned char reloadData[784] = {
		0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
		0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
		0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
		0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
		0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
		0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x05,
		0xFF, 0xFF, 0xFF, 0x2B, 0xFF, 0xFF, 0xFF, 0x66, 0xFF, 0xFF, 0xFF, 0x8B,
		0xFF, 0xFF, 0xFF, 0x84, 0xFF, 0xFF, 0xFF, 0x52, 0xFF, 0xFF, 0xFF, 0x16,
		0xFF, 0xFF, 0xFF, 0x07, 0xFF, 0xFF, 0xFF, 0x78, 0xFF, 0xFF, 0xFF, 0xB7,
		0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
		0xFF, 0xFF, 0xFF, 0x11, 0xFF, 0xFF, 0xFF, 0x7E, 0xFF, 0xFF, 0xFF, 0xF1,
		0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
		0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xBC, 0xFF, 0xFF, 0xFF, 0x97,
		0xFF, 0xFF, 0xFF, 0xEF, 0xFF, 0xFF, 0xFF, 0xEE, 0xFF, 0xFF, 0xFF, 0x00,
		0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x08, 0xFF, 0xFF, 0xFF, 0x91,
		0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xD2,
		0xFF, 0xFF, 0xFF, 0xAC, 0xFF, 0xFF, 0xFF, 0xB0, 0xFF, 0xFF, 0xFF, 0xDE,
		0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
		0xFF, 0xFF, 0xFF, 0xE2, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
		0xFF, 0xFF, 0xFF, 0x4C, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xF9,
		0xFF, 0xFF, 0xFF, 0xA3, 0xFF, 0xFF, 0xFF, 0x30, 0xFF, 0xFF, 0xFF, 0x00,
		0xFF, 0xFF, 0xFF, 0x06, 0xFF, 0xFF, 0xFF, 0xA1, 0xFF, 0xFF, 0xFF, 0xFE,
		0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xE2,
		0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0xAF,
		0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xBB, 0xFF, 0xFF, 0xFF, 0x12,
		0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x0E, 0xFF, 0xFF, 0xFF, 0x73,
		0xFF, 0xFF, 0xFF, 0xE2, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
		0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xF2, 0xFF, 0xFF, 0xFF, 0x00,
		0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0xE5, 0xFF, 0xFF, 0xFF, 0xF8,
		0xFF, 0xFF, 0xFF, 0x72, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
		0xFF, 0xFF, 0xFF, 0x30, 0xFF, 0xFF, 0xFF, 0xD0, 0xFF, 0xFF, 0xFF, 0xF3,
		0xFF, 0xFF, 0xFF, 0xE8, 0xFF, 0xFF, 0xFF, 0xE6, 0xFF, 0xFF, 0xFF, 0xE8,
		0xFF, 0xFF, 0xFF, 0xDD, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
		0xFF, 0xFF, 0xFF, 0xEB, 0xFF, 0xFF, 0xFF, 0xF3, 0xFF, 0xFF, 0xFF, 0x64,
		0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x12,
		0xFF, 0xFF, 0xFF, 0x43, 0xFF, 0xFF, 0xFF, 0x55, 0xFF, 0xFF, 0xFF, 0x44,
		0xFF, 0xFF, 0xFF, 0x32, 0xFF, 0xFF, 0xFF, 0x3B, 0xFF, 0xFF, 0xFF, 0x44,
		0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0xCE,
		0xFF, 0xFF, 0xFF, 0xFC, 0xFF, 0xFF, 0xFF, 0x93, 0xFF, 0xFF, 0xFF, 0x00,
		0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
		0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x4B,
		0xFF, 0xFF, 0xFF, 0x26, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
		0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x7B, 0xFF, 0xFF, 0xFF, 0xFF,
		0xFF, 0xFF, 0xFF, 0xE3, 0xFF, 0xFF, 0xFF, 0x54, 0xFF, 0xFF, 0xFF, 0x00,
		0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x07,
		0xFF, 0xFF, 0xFF, 0x8B, 0xFF, 0xFF, 0xFF, 0xEE, 0xFF, 0xFF, 0xFF, 0xC0,
		0xFF, 0xFF, 0xFF, 0x11, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
		0xFF, 0xFF, 0xFF, 0x21, 0xFF, 0xFF, 0xFF, 0xD1, 0xFF, 0xFF, 0xFF, 0xFF,
		0xFF, 0xFF, 0xFF, 0xE4, 0xFF, 0xFF, 0xFF, 0x8D, 0xFF, 0xFF, 0xFF, 0x5B,
		0xFF, 0xFF, 0xFF, 0x68, 0xFF, 0xFF, 0xFF, 0xAC, 0xFF, 0xFF, 0xFF, 0xF5,
		0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x96, 0xFF, 0xFF, 0xFF, 0x0A,
		0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
		0xFF, 0xFF, 0xFF, 0x3D, 0xFF, 0xFF, 0xFF, 0xD4, 0xFF, 0xFF, 0xFF, 0xFF,
		0xFF, 0xFF, 0xFF, 0xFD, 0xFF, 0xFF, 0xFF, 0xEE, 0xFF, 0xFF, 0xFF, 0xF2,
		0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xA5,
		0xFF, 0xFF, 0xFF, 0x1B, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
		0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
		0xFF, 0xFF, 0xFF, 0x26, 0xFF, 0xFF, 0xFF, 0x83, 0xFF, 0xFF, 0xFF, 0xD5,
		0xFF, 0xFF, 0xFF, 0xEE, 0xFF, 0xFF, 0xFF, 0xEB, 0xFF, 0xFF, 0xFF, 0xC1,
		0xFF, 0xFF, 0xFF, 0x5C, 0xFF, 0xFF, 0xFF, 0x10, 0xFF, 0xFF, 0xFF, 0x00,
		0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
		0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
		0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
		0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
		0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
		0xFF, 0xFF, 0xFF, 0x00
	};

	unsigned char scopingData[784] = {
		0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
		0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
		0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
		0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
		0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
		0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
		0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0xD0,
		0xFF, 0xFF, 0xFF, 0xD0, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
		0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
		0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
		0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x79,
		0xFF, 0xFF, 0xFF, 0xE9, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
		0xFF, 0xFF, 0xFF, 0xE9, 0xFF, 0xFF, 0xFF, 0x79, 0xFF, 0xFF, 0xFF, 0x00,
		0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
		0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
		0xFF, 0xFF, 0xFF, 0xC4, 0xFF, 0xFF, 0xFF, 0xF1, 0xFF, 0xFF, 0xFF, 0xA0,
		0xFF, 0xFF, 0xFF, 0xED, 0xFF, 0xFF, 0xFF, 0xED, 0xFF, 0xFF, 0xFF, 0x9E,
		0xFF, 0xFF, 0xFF, 0xF1, 0xFF, 0xFF, 0xFF, 0xC4, 0xFF, 0xFF, 0xFF, 0x00,
		0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
		0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x7C, 0xFF, 0xFF, 0xFF, 0xF2,
		0xFF, 0xFF, 0xFF, 0x9E, 0xFF, 0xFF, 0xFF, 0x16, 0xFF, 0xFF, 0xFF, 0xDD,
		0xFF, 0xFF, 0xFF, 0xDD, 0xFF, 0xFF, 0xFF, 0x16, 0xFF, 0xFF, 0xFF, 0x9D,
		0xFF, 0xFF, 0xFF, 0xF1, 0xFF, 0xFF, 0xFF, 0x7A, 0xFF, 0xFF, 0xFF, 0x00,
		0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
		0xFF, 0xFF, 0xFF, 0xE8, 0xFF, 0xFF, 0xFF, 0xA7, 0xFF, 0xFF, 0xFF, 0x00,
		0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0xD7, 0xFF, 0xFF, 0xFF, 0xD7,
		0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0xA4,
		0xFF, 0xFF, 0xFF, 0xE8, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
		0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0xD0, 0xFF, 0xFF, 0xFF, 0xFF,
		0xFF, 0xFF, 0xFF, 0xED, 0xFF, 0xFF, 0xFF, 0xDD, 0xFF, 0xFF, 0xFF, 0xDF,
		0xFF, 0xFF, 0xFF, 0xFB, 0xFF, 0xFF, 0xFF, 0xFB, 0xFF, 0xFF, 0xFF, 0xDF,
		0xFF, 0xFF, 0xFF, 0xDD, 0xFF, 0xFF, 0xFF, 0xED, 0xFF, 0xFF, 0xFF, 0xFF,
		0xFF, 0xFF, 0xFF, 0xD0, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
		0xFF, 0xFF, 0xFF, 0xD0, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xEC,
		0xFF, 0xFF, 0xFF, 0xDD, 0xFF, 0xFF, 0xFF, 0xDF, 0xFF, 0xFF, 0xFF, 0xFB,
		0xFF, 0xFF, 0xFF, 0xFB, 0xFF, 0xFF, 0xFF, 0xDF, 0xFF, 0xFF, 0xFF, 0xDD,
		0xFF, 0xFF, 0xFF, 0xED, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xD0,
		0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
		0xFF, 0xFF, 0xFF, 0xE8, 0xFF, 0xFF, 0xFF, 0xA6, 0xFF, 0xFF, 0xFF, 0x00,
		0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0xD7, 0xFF, 0xFF, 0xFF, 0xD7,
		0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0xA6,
		0xFF, 0xFF, 0xFF, 0xE8, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
		0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x7D,
		0xFF, 0xFF, 0xFF, 0xF2, 0xFF, 0xFF, 0xFF, 0x9E, 0xFF, 0xFF, 0xFF, 0x16,
		0xFF, 0xFF, 0xFF, 0xDC, 0xFF, 0xFF, 0xFF, 0xDC, 0xFF, 0xFF, 0xFF, 0x16,
		0xFF, 0xFF, 0xFF, 0x9D, 0xFF, 0xFF, 0xFF, 0xF1, 0xFF, 0xFF, 0xFF, 0x7C,
		0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
		0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0xC4,
		0xFF, 0xFF, 0xFF, 0xF0, 0xFF, 0xFF, 0xFF, 0x9C, 0xFF, 0xFF, 0xFF, 0xEC,
		0xFF, 0xFF, 0xFF, 0xEC, 0xFF, 0xFF, 0xFF, 0x9C, 0xFF, 0xFF, 0xFF, 0xF0,
		0xFF, 0xFF, 0xFF, 0xC4, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
		0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
		0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x79,
		0xFF, 0xFF, 0xFF, 0xE9, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
		0xFF, 0xFF, 0xFF, 0xE9, 0xFF, 0xFF, 0xFF, 0x79, 0xFF, 0xFF, 0xFF, 0x00,
		0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
		0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
		0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
		0xFF, 0xFF, 0xFF, 0xD0, 0xFF, 0xFF, 0xFF, 0xD0, 0xFF, 0xFF, 0xFF, 0x00,
		0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
		0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
		0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
		0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
		0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
		0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
		0xFF, 0xFF, 0xFF, 0x00
	};

}
```

`Lumina/Lumina/ui/image.h`:

```h
#ifndef image_h

#define image_h

namespace images {

	extern unsigned char logoData[29664];
	extern unsigned char flashingData[784];
	extern unsigned char reloadData[784];
	extern unsigned char scopingData[784];
}

#endif // !image_h

```

`Lumina/Lumina/ui/menu.cpp`:

```cpp
#include "menu.h"

//#include "fgui/render.hpp"
#include "../ui/zgui/dist/zgui.hh"
//#include "fgui_old/FGUI.hh"

#include "../ui/render.h"

#include "../common/includes.h"
#include "../common/input.h"
#include "../common/common.h"
#include "../common/config.h"

#include <vector>
#include <unordered_map>
#include <string>
#include <memory>
#include <cstdint>
#include <sstream>

#include "../features/visuals/chams.h"
#include "../features/visuals/skinchanger.h"
#include "../features/misc/soundEsp.h"
#include "../features/misc/misc.h"
#include "../features/misc/voice.h"

#include "image.h"
#include "sound.h"

#include "../features/visuals/world.h"

namespace menu {

	bool visible = false;
	bool inTransition = false;

	int alphaBackground = 0;

	int alphaIntro = 0;

	bool inIntro = true;

	int frameTime = 2;

	int startSleep = 100;
	int tabIconX = 217;

	int sizeX = 572;
	int sizeY = 640;

	int lineSize = 3;
	int spaceSize = 20;
	int tabSpaceSize = 78;

	UINT32 currentFrame = 0;

	Color lightTop;
	Color lightBottom;

	Color mainTop;
	Color mainBottom;

	Color mainTabLight;
	Color mainTab;

	Color highContrast;

	std::string pseudo;


	Color textColor;

	texture logo;

	int wait = 100 * 3;

	std::vector<std::string> materialsNames = {
	};

	std::vector<std::string> sides = {

	};

	std::vector<std::string> weaponNames = {

	};

	std::vector<std::string> knifeNames = {

	};

	std::vector<std::string> modelNames = {
	};

	std::vector<skin*> tSkins = {
		&(config::visual.skins.tSkins.ak47Skin),
		&(config::visual.skins.tSkins.deagleSkin),
		&(config::visual.skins.tSkins.awpSkin),
		&(config::visual.skins.tSkins.m4a1Skin),
		&(config::visual.skins.tSkins.scarSkin),
		&(config::visual.skins.tSkins.ssg08Skin),
		&(config::visual.skins.tSkins.uspSkin),
		&(config::visual.skins.tSkins.famasSkin),
		&(config::visual.skins.tSkins.g3sg1Skin),
		&(config::visual.skins.tSkins.m4a1s1Skin),
		&(config::visual.skins.tSkins.sg553Skin),
		&(config::visual.skins.tSkins.augSkin),
		&(config::visual.skins.tSkins.galilSkin),
		&(config::visual.skins.tSkins.mac10Skin),
		&(config::visual.skins.tSkins.mp5Skin),
		&(config::visual.skins.tSkins.mp7Skin),
		&(config::visual.skins.tSkins.mp9Skin),
		&(config::visual.skins.tSkins.ppbizonSkin),
		&(config::visual.skins.tSkins.p90Skin),
		&(config::visual.skins.tSkins.umpSkin),
		&(config::visual.skins.tSkins.cz75Skin),
		&(config::visual.skins.tSkins.dualberttaSkin),
		&(config::visual.skins.tSkins.fiveSevenSkin),
		&(config::visual.skins.tSkins.glockSkin),
		&(config::visual.skins.tSkins.p250Skin),
		&(config::visual.skins.tSkins.tec9Skin),
		&(config::visual.skins.tSkins.revolverSkin),
	};

	std::vector<skin*> ctSkins = {
		&(config::visual.skins.ctSkins.ak47Skin),
		&(config::visual.skins.ctSkins.deagleSkin),
		&(config::visual.skins.ctSkins.awpSkin),
		&(config::visual.skins.ctSkins.m4a1Skin),
		&(config::visual.skins.ctSkins.scarSkin),
		&(config::visual.skins.ctSkins.ssg08Skin),
		&(config::visual.skins.ctSkins.uspSkin),
		&(config::visual.skins.ctSkins.famasSkin),
		&(config::visual.skins.ctSkins.g3sg1Skin),
		&(config::visual.skins.ctSkins.m4a1s1Skin),
		&(config::visual.skins.ctSkins.sg553Skin),
		&(config::visual.skins.ctSkins.augSkin),
		&(config::visual.skins.ctSkins.galilSkin),
		&(config::visual.skins.ctSkins.mac10Skin),
		&(config::visual.skins.ctSkins.mp5Skin),
		&(config::visual.skins.ctSkins.mp7Skin),
		&(config::visual.skins.ctSkins.mp9Skin),
		&(config::visual.skins.ctSkins.ppbizonSkin),
		&(config::visual.skins.ctSkins.p90Skin),
		&(config::visual.skins.ctSkins.umpSkin),
		&(config::visual.skins.ctSkins.cz75Skin),
		&(config::visual.skins.ctSkins.dualberttaSkin),
		&(config::visual.skins.ctSkins.fiveSevenSkin),
		&(config::visual.skins.ctSkins.glockSkin),
		&(config::visual.skins.ctSkins.p250Skin),
		&(config::visual.skins.ctSkins.tec9Skin),
		&(config::visual.skins.ctSkins.revolverSkin),
	};

	/*
	std::vector<skin*> chams = {
		&(config::visual.enemyChamsVisible.),
		&(config::visual.skins.tSkins.deagleSkin),
		&(config::visual.skins.tSkins.awpSkin),
		&(config::visual.skins.tSkins.m4a1Skin),
		&(config::visual.skins.tSkins.scarSkin),
		&(config::visual.skins.tSkins.ssg08Skin),
		&(config::visual.skins.tSkins.uspSkin),
	};*/


	int currentSide = 0;

	int currentSkin = 0;

	std::vector<std::string> skinsName = std::vector<std::string>();

	std::vector<zgui::multi_select_item> espIndicators = {

	};

	std::vector<zgui::multi_select_item> worldIndicator = {

	};

	void* currentTabDrawFunction;

	void init() {

		VMProtectBeginMutation("menu::init");

		logo = texture(images::logoData, 206, 36);

		lightTop = Color(134, 44, 63, 255);
		lightBottom = Color(150, 51, 126, 255);

		mainTop = Color(115, 3, 26, 255);
		mainBottom = Color(124, 0, 93, 255);

		mainTabLight = Color(104, 51, 76, 255);
		mainTab = Color(69, 0, 32, 255);

		highContrast = Color(48, 0, 15, 255);

		textColor = Color(255,255,255,255);

		currentTabDrawFunction = &drawSkinTab;

		std::vector<paint_kit> skins = utils::getSkinsInfo();

		for (size_t i = 0; i < skins.size(); i++)
		{
			std::string name = std::to_string(skins[i].id);
			name.append(" | ");
			name.append(skins[i].name);

			skinsName.push_back(name);
		}

		VECTOR_PUSH_TUPLE(espIndicators, "Ammo", &(config::visual.enemyEsp.showAmmo), tmp0, tmp0_)
		VECTOR_PUSH_TUPLE(espIndicators, "Armor", &(config::visual.enemyEsp.showArmor), tmp1, tmp1_)
		VECTOR_PUSH_TUPLE(espIndicators, "Has bomb", &(config::visual.enemyEsp.showBomb), tmp2, tmp2_)
		VECTOR_PUSH_TUPLE(espIndicators, "Cheating", &(config::visual.enemyEsp.showCheating), tmp3, tmp3_)
		VECTOR_PUSH_TUPLE(espIndicators, "Defusing", &(config::visual.enemyEsp.showDefusing), tmp4, tmp4_)
		VECTOR_PUSH_TUPLE(espIndicators, "Fake duck", &(config::visual.enemyEsp.showFakeDuck), tmp5, tmp5_)
		VECTOR_PUSH_TUPLE(espIndicators, "Flashed", &(config::visual.enemyEsp.showFlashed), tmp6, tmp6_)
		VECTOR_PUSH_TUPLE(espIndicators, "Has defuser", &(config::visual.enemyEsp.showHasDefuser), tmp7, tmp7_)
		VECTOR_PUSH_TUPLE(espIndicators, "Legit AA", &(config::visual.enemyEsp.showLegitAA), tmp8, tmp8_)
		VECTOR_PUSH_TUPLE(espIndicators, "Money", &(config::visual.enemyEsp.showMoney), tmp9, tmp9_)
		VECTOR_PUSH_TUPLE(espIndicators, "Ping", &(config::visual.enemyEsp.showPing), tmp10, tmp10_)
		VECTOR_PUSH_TUPLE(espIndicators, "Reload", &(config::visual.enemyEsp.showReload), tmp11, tmp11_)
		VECTOR_PUSH_TUPLE(espIndicators, "Scopping", &(config::visual.enemyEsp.showScopping), tmp12, tmp12_)
		VECTOR_PUSH_TUPLE(espIndicators, "Planting", &(config::visual.enemyEsp.showPlanting), tmp13, tmp13_)

		VECTOR_PUSH_TUPLE(worldIndicator, "Flash duration", &(config::visual.indicators.showFlashDuration), tmp14, tmp14_)

		VECTOR_PUSH(materialsNames, "TEXTURED", pad0)
		VECTOR_PUSH(materialsNames, "FLAT", pad1)
		VECTOR_PUSH(materialsNames, "MEHSES", pad2)
		VECTOR_PUSH(materialsNames, "METALIC", pad3)
		VECTOR_PUSH(materialsNames, "OVERLAY", pad4___)
		VECTOR_PUSH(materialsNames, "CHROME", pad5___)

		VECTOR_PUSH(sides, "CT", pad4)
		VECTOR_PUSH(sides, "T", pad5)

		VECTOR_PUSH(weaponNames, "AK47", pad6)
		VECTOR_PUSH(weaponNames, "DEAGLE", pad7)
		VECTOR_PUSH(weaponNames, "AWP", pad8)
		VECTOR_PUSH(weaponNames, "M4A1", pad9)
		VECTOR_PUSH(weaponNames, "SCAR", pad10)
		VECTOR_PUSH(weaponNames, "SSG08", pad11)
		VECTOR_PUSH(weaponNames, "USP", pad12)
			VECTOR_PUSH(weaponNames, "FAMAS", pad121)
			VECTOR_PUSH(weaponNames, "G3SG1", pad122)
			VECTOR_PUSH(weaponNames, "M4A1_SILENCER", pad123)
			VECTOR_PUSH(weaponNames, "SG556", pad124)
			VECTOR_PUSH(weaponNames, "AUG", pad125)
			VECTOR_PUSH(weaponNames, "GALILAR", pad126)
			VECTOR_PUSH(weaponNames, "MAC10", pad127)
			VECTOR_PUSH(weaponNames, "MP5SD", pad128)
			VECTOR_PUSH(weaponNames, "MP7", pad129)
			VECTOR_PUSH(weaponNames, "MP9", pad1210)
			VECTOR_PUSH(weaponNames, "BIZON", pad1211)
			VECTOR_PUSH(weaponNames, "P90", pad1212)
			VECTOR_PUSH(weaponNames, "UMP45", pad1213)
			VECTOR_PUSH(weaponNames, "CZ75A", pad1214)
			VECTOR_PUSH(weaponNames, "ELITE", pad1215)
			VECTOR_PUSH(weaponNames, "FIVESEVEN", pad1216)
			VECTOR_PUSH(weaponNames, "GLOCK", pad1217)
			VECTOR_PUSH(weaponNames, "P250", pad1218)
			VECTOR_PUSH(weaponNames, "TEC9", pad1219)
			VECTOR_PUSH(weaponNames, "REVOLVER", pad1220)


		VECTOR_PUSH(knifeNames, "Default T", pad13)
		VECTOR_PUSH(knifeNames, "Default CT", pad14)
		VECTOR_PUSH(knifeNames, "Bayonet", pad15)
		VECTOR_PUSH(knifeNames, "M9 Bayonet", pad16)
		VECTOR_PUSH(knifeNames, "Karambit", pad17)
		VECTOR_PUSH(knifeNames, "Bowie", pad18)
		VECTOR_PUSH(knifeNames, "Butterfly", pad19)
		VECTOR_PUSH(knifeNames, "Falchion", pad20)
		VECTOR_PUSH(knifeNames, "Flip", pad21)
		VECTOR_PUSH(knifeNames, "Tactical", pad22)
		VECTOR_PUSH(knifeNames, "Push", pad23)
		VECTOR_PUSH(knifeNames, "Jackknife", pad24)
		VECTOR_PUSH(knifeNames, "Stiletto", pad25)
		VECTOR_PUSH(knifeNames, "Widowmaker", pad26)
		VECTOR_PUSH(knifeNames, "Ursus", pad27)
		VECTOR_PUSH(knifeNames, "Outdoor", pad28)
		VECTOR_PUSH(knifeNames, "Canis", pad29)
		VECTOR_PUSH(knifeNames, "Ord", pad30)
		VECTOR_PUSH(knifeNames, "Css", pad31)


			VECTOR_PUSH(modelNames, "ctm_fbi_variantb.mdl", tmp20)
			VECTOR_PUSH(modelNames, "lara.mdl", tmp20_)
			VECTOR_PUSH(modelNames, "cortana.mdl", tmp21)
			VECTOR_PUSH(modelNames, "samus.mdl", tmp22)
			VECTOR_PUSH(modelNames, "goku.mdl", tmp23)
			VECTOR_PUSH(modelNames, "cuddleleader.mdl", tmp24)
			VECTOR_PUSH(modelNames, "viper_v1f.mdl", tmp25)
			VECTOR_PUSH(modelNames, "sas.mdl", tmp26)
			VECTOR_PUSH(modelNames, "lincoln.mdl", tmp27)
			VECTOR_PUSH(modelNames, "karachenko.mdl", tmp28)
			VECTOR_PUSH(modelNames, "gign.mdl", tmp29)
			VECTOR_PUSH(modelNames, "carrie.mdl", tmp30)
			VECTOR_PUSH(modelNames, "707.mdl", tmp31)

			VECTOR_PUSH(modelNames, "tm_phoenix_variantf.mdl", tmp40)
			VECTOR_PUSH(modelNames, "tm_phoenix_variantg.mdl", tmp41)
			VECTOR_PUSH(modelNames, "tm_phoenix_varianth.mdl", tmp42)

			/*
			


			VECTOR_PUSH(modelNames, "fbi_variantb", tmp20)
			VECTOR_PUSH(modelNames, "Lara", tmp20_)
			VECTOR_PUSH(modelNames, "fbi_variantf", tmp21)
			VECTOR_PUSH(modelNames, "fbi_variantg", tmp22)
			VECTOR_PUSH(modelNames, "fbi_varianth", tmp23)
			VECTOR_PUSH(modelNames, "sas_variantf", tmp24)
			VECTOR_PUSH(modelNames, "st6_variante", tmp25)
			VECTOR_PUSH(modelNames, "st6_variantg", tmp26)
			VECTOR_PUSH(modelNames, "st6_varianti", tmp27)
			VECTOR_PUSH(modelNames, "st6_variantk", tmp28)
			VECTOR_PUSH(modelNames, "st6_variantm", tmp29)
			VECTOR_PUSH(modelNames, "balkan_variantf", tmp31)
			VECTOR_PUSH(modelNames, "balkan_variantg", tmp32)
			VECTOR_PUSH(modelNames, "balkan_varianth", tmp33)
			VECTOR_PUSH(modelNames, "balkan_varianti", tmp34)
			VECTOR_PUSH(modelNames, "balkan_variantj", tmp35)
			VECTOR_PUSH(modelNames, "leet_variantf", tmp36)
			VECTOR_PUSH(modelNames, "leet_variantg", tmp37)
			VECTOR_PUSH(modelNames, "leet_varianth", tmp38)
			VECTOR_PUSH(modelNames, "leet_varianti", tmp39)
			VECTOR_PUSH(modelNames, "phoenix_variantf", tmp40)
			VECTOR_PUSH(modelNames, "phoenix_variantg", tmp41)
			VECTOR_PUSH(modelNames, "phoenix_varianth", tmp42)

			VECTOR_PUSH(modelNames, "st6_variantj", tmp43)
			VECTOR_PUSH(modelNames, "st6_variantl", tmp44)
			VECTOR_PUSH(modelNames, "swat_variante", tmp45)
			VECTOR_PUSH(modelNames, "swat_variantf", tmp46)
			VECTOR_PUSH(modelNames, "swat_variantg", tmp47)
			VECTOR_PUSH(modelNames, "swat_varianth", tmp48)
			VECTOR_PUSH(modelNames, "swat_varianti", tmp49)
			VECTOR_PUSH(modelNames, "swat_variantj", tmp50)
			VECTOR_PUSH(modelNames, "balkan_variantk", tmp51)
			VECTOR_PUSH(modelNames, "balkan_variantl", tmp52)
			VECTOR_PUSH(modelNames, "phoenix_varianti", tmp53)
			VECTOR_PUSH(modelNames, "professional_varf", tmp54)
			VECTOR_PUSH(modelNames, "professional_varf1", tmp55)
			VECTOR_PUSH(modelNames, "professional_varf2", tmp56)
			VECTOR_PUSH(modelNames, "professional_varf3", tmp57)
			VECTOR_PUSH(modelNames, "professional_varf4", tmp58)
			VECTOR_PUSH(modelNames, "professional_varg", tmp59)
			VECTOR_PUSH(modelNames, "professional_varh", tmp60)
			VECTOR_PUSH(modelNames, "professional_vari", tmp61)
			VECTOR_PUSH(modelNames, "professional_varj", tmp62)
						*/

#ifdef _DEBUG
		common::ps(XorStr("menu::init : done"));
#endif
		VMProtectEnd();
	}

	void skinUpdateCallback() {

	}

	void toggle()
	{
		VMProtectBeginMutation("menu::toggle");

		bool inIntro = currentFrame < startSleep + (15 * 2) + wait;

		if (!inIntro && input::get_key_info(VK_INSERT).m_state == input::PRESSED)
		{
			inTransition = !inTransition;

			visible = !visible;
		}

		VMProtectEnd();
	}

	bool playIntro = false;

	void draw()
	{
		VMProtectBeginMutation("menu::draw");

		if (currentFrame == MAXUINT32)
			currentFrame = 0;
		else
			currentFrame++;

		if (startSleep > 0)
		{
			startSleep--;
			return;
		}

		inIntro = currentFrame < startSleep + (15 * 2) + wait;

		if (currentFrame == startSleep + (15 * 2) + wait + 1)
			visible = false;

		if (inIntro)
		{
			if (!playIntro && currentFrame < startSleep + 7)
			{
				playIntro = true;
			}

			visible = inIntro;

			moduleAlpha();

			drawIntro();
		}
		else {

			if (visible)
			{
				menu::alphaBackground = 255;

				drawBackground();

				lightTop = Color(134, 44, 63, menu::alphaBackground);
				lightBottom = Color(150, 51, 126, menu::alphaBackground);

				mainTop = Color(115, 3, 26, menu::alphaBackground);
				mainBottom = Color(124, 0, 93, menu::alphaBackground);

				mainTabLight = Color(104, 51, 76, menu::alphaBackground);
				mainTab = Color(69, 0, 32, menu::alphaBackground);

				highContrast = Color(48, 0, 15, menu::alphaBackground);
			}

			// is triggered by key
			drawMenu();
		}

		VMProtectEnd();
	}

	void moduleAlpha()
	{
		VMProtectBeginMutation("menu::moduleAlpha");

		int* alpha = &alphaBackground;
		int max = 255;
		int value = 15;

		if (inIntro)
		{
			alpha = &alphaIntro;
			max = 200;
			value = 10;
		}

		if (!inTransition)
		{
			if (*alpha < max)
			{
				*alpha += value;
			}
			else if (*alpha >= max)
			{
				*alpha = max;
			}
		}
		else
		{
			if (*alpha > -1)
			{
				*alpha -= value;
			}
			else if (*alpha <= 0)
			{
				*alpha = 0;
			}
		}

		VMProtectEnd();
	}

	void drawBackground() {

		VMProtectBeginMutation("menu::drawBackground");

		int screenX, screenY;

		interfaces::engineClient->GetScreenSize(screenX, screenY);

		interfaces::surface->DrawSetColor(Color(0, 0, 0));
		interfaces::surface->DrawFilledRectFade(0, 0, screenX, screenY, 0, alphaBackground, false);

		VMProtectEnd();
	}

	void drawIntro() {

		VMProtectBeginMutation("menu::drawIntro");

		int screenX, screenY;

		interfaces::engineClient->GetScreenSize(screenX, screenY);

		interfaces::surface->DrawSetColor(Color(0, 0, 0, alphaIntro));
		interfaces::surface->DrawFilledRect(0, 0, screenX, screenY);

		logo.m_bgColor.SetAlpha(alphaIntro);

		float scale = 1;

		logo.Draw((screenX / 2) - (206 * scale / 2), (screenY / 2) - (36 * scale / 2), scale);

		VMProtectEnd();
	}

	void drawMenu() {

		VMProtectBeginMutation("menu::drawMenu");

		zgui::poll_input(XorStr("Valve001"));

		if (zgui::begin_window("", { (float)sizeX, (float)sizeY }, render::font, zgui::zgui_window_flags_none))
		{
			if (zgui::buttonWithPosition(XorStr("#showTab1"), { 74, 74 }, { (float)(spaceSize + tabIconX + lineSize ), (float)(spaceSize + lineSize )})) {
				currentTabDrawFunction = &drawSkinTab;
			}

			if (zgui::buttonWithPosition(XorStr("#showTab2"), { 74, 74 }, { (float)(spaceSize + tabIconX + lineSize + (74 * 1)), (float)(spaceSize + lineSize )})) {
				currentTabDrawFunction = &drawVisualTab;
			}

			if (zgui::buttonWithPosition(XorStr("#showTab3"), { 74, 74 }, { (float)(spaceSize + tabIconX + lineSize + (74 * 2)), (float)(spaceSize + lineSize )})) {
				currentTabDrawFunction = &drawSound;
			}

			if (zgui::buttonWithPosition(XorStr("#showTab4"), { 74, 74 }, { (float)(spaceSize + tabIconX + lineSize + (74 * 3)), (float)(spaceSize + lineSize) })) {
				currentTabDrawFunction = &drawMiscTab;
			}

			// reset pos

			zgui::setMousePos((float)menu::spaceSize + 20.0f, (float)(menu::spaceSize + menu::tabSpaceSize) + 22.0f);

			__asm {
				call currentTabDrawFunction
			}

			zgui::end_window();
		}

		VMProtectEnd();
	}


	void drawVisualTab() {

		VMProtectBeginMutation("menu::drawVisualTab");

		// esp

		float x = (float)menu::spaceSize + 20.0f;
		float y = (float)(menu::spaceSize + menu::tabSpaceSize) + 22.0f;

		zgui::checkbox(XorStr("Show box#useEsp"), config::visual.enemyEsp.showBox);

		zgui::setMousePos(x + 100, y);

		zgui::color espColor = zgui::color();

		espColor.r = config::visual.enemyEsp.espColor.r();
		espColor.g = config::visual.enemyEsp.espColor.g();
		espColor.b = config::visual.enemyEsp.espColor.b();
		espColor.a = config::visual.enemyEsp.espColor.a();

		if(zgui::colorpicker(XorStr("Esp color#espColor"), espColor))

			config::visual.enemyEsp.espColor.SetColor(espColor.r, espColor.g, espColor.b, espColor.a);

		zgui::setMousePos(x + 200, y);

		zgui::checkbox(XorStr("Show if dead#useEspif"), config::visual.enemyEsp.showOnlyIsDead);

		zgui::setMousePos(x + 300, y);

		zgui::checkbox(XorStr("Show life#useEspLife"), config::visual.enemyEsp.showLife);

		zgui::setMousePos(x + 400, y);

		zgui::checkbox(XorStr("Show name#useEspName"), config::visual.enemyEsp.showName);

		zgui::setMousePos(x, y + 50);

		zgui::multi_combobox(XorStr("Show indicators#useEspIndicators"), espIndicators);

		zgui::setMousePos(x + 100, y + 50);

		zgui::checkbox(XorStr("Show icons#useEspicon"), config::visual.enemyEsp.showIcons);

		zgui::setMousePos(x + 200, y + 50);

		zgui::checkbox(XorStr("Show weapon name#swn"), config::visual.enemyEsp.showWeaponName);

		zgui::setMousePos(x + 300, y + 50);

		zgui::checkbox(XorStr("Show weapon icon#swi"), config::visual.enemyEsp.showWeaponIcon);


		// chams

		zgui::setMousePos(x, y + 100);

		zgui::checkbox(XorStr("Show chams#useChams"), config::visual.enemyChamsVisible.enable);

		zgui::setMousePos(x + 100, y + 100);

		zgui::color chamsColor = zgui::color();

		chamsColor.r = config::visual.enemyChamsVisible.color.r();
		chamsColor.g = config::visual.enemyChamsVisible.color.g();
		chamsColor.b = config::visual.enemyChamsVisible.color.b();
		chamsColor.a = config::visual.enemyChamsVisible.color.a();

		if(zgui::colorpicker(XorStr("Chams color#chamsColor"), chamsColor))
			config::visual.enemyChamsVisible.color.SetColor(chamsColor.r, chamsColor.g, chamsColor.b, chamsColor.a);

		zgui::setMousePos(x + 200, y + 100);

		zgui::combobox(XorStr("Material#material"), materialsNames, config::visual.enemyChamsVisible.material);

		zgui::setMousePos(x + 300, y + 100);

		zgui::checkbox(XorStr("Use rainbow color#rainbow"), config::visual.enemyChamsVisible.rainbowColor);

		zgui::setMousePos(x + 400, y + 100);

		zgui::checkbox(XorStr("Through wall#throughWall"), config::visual.enemyChamsVisible.throughWall);

		zgui::setMousePos(x + 500, y + 100);

		zgui::checkbox(XorStr("Through wall only if dead#throughWallonlyifdead"), config::visual.enemyChamsVisible.throughWallOnlyIfDead);

		// overlay chams

		zgui::setMousePos(x, y + 150);

		zgui::checkbox(XorStr("Show overlay#useChamsoverlay"), config::visual.enemyChamsVisible.enableOverlay);

		zgui::setMousePos(x + 100, y + 150);

		zgui::color overlaychamsColor = zgui::color();

		overlaychamsColor.r = config::visual.enemyChamsVisible.overlayColor.r();
		overlaychamsColor.g = config::visual.enemyChamsVisible.overlayColor.g();
		overlaychamsColor.b = config::visual.enemyChamsVisible.overlayColor.b();
		overlaychamsColor.a = config::visual.enemyChamsVisible.overlayColor.a();

		if (zgui::colorpicker(XorStr("Overlay color#chamsColorOverlay"), overlaychamsColor))
			config::visual.enemyChamsVisible.overlayColor.SetColor(overlaychamsColor.r, overlaychamsColor.g, overlaychamsColor.b, overlaychamsColor.a);

		zgui::setMousePos(x + 200, y + 150);

		zgui::combobox(XorStr("Material#materialOverlay"), materialsNames, config::visual.enemyChamsVisible.overlayMaterial);

		zgui::setMousePos(x + 300, y + 150);

		zgui::checkbox(XorStr("Use rainbow color#rainbowOverlay"), config::visual.enemyChamsVisible.overlayRainbowColor);





		// glow

		zgui::setMousePos(x, y + 200);

		zgui::checkbox(XorStr("Show glow#useGlow"), config::visual.glow.enable);

		zgui::setMousePos(x + 100, y + 200);

		zgui::color glowColor = zgui::color();

		glowColor.r = config::visual.glow.glowColor.r();
		glowColor.g = config::visual.glow.glowColor.g();
		glowColor.b = config::visual.glow.glowColor.b();
		glowColor.a = config::visual.glow.glowColor.a();

		if(zgui::colorpicker(XorStr("Glow color#glowColor"), glowColor))
			config::visual.glow.glowColor.SetColor(glowColor.r, glowColor.g, glowColor.b, glowColor.a);

		zgui::setMousePos(x + 200, y + 200);

		zgui::checkbox(XorStr("Show if dead#useGlowIfDead"), config::visual.glow.onlyIfDead);

		zgui::setMousePos(x + 300, y + 200);

		zgui::slider_float(XorStr("Bloom#glowBloom"), 0, 1, config::visual.glow.bloom);

		// hands

		zgui::setMousePos(x, y + 250);

		zgui::checkbox(XorStr("Hand chams#useChamsHand"), config::visual.handChams.enable);

		zgui::setMousePos(x + 100, y + 250);

		zgui::color chamsColor2 = zgui::color();

		chamsColor2.r = config::visual.handChams.color.r();
		chamsColor2.g = config::visual.handChams.color.g();
		chamsColor2.b = config::visual.handChams.color.b();
		chamsColor2.a = config::visual.handChams.color.a();

		if(zgui::colorpicker(XorStr("Chams color#chamsColorHand"), chamsColor2))
			config::visual.handChams.color.SetColor(chamsColor2.r, chamsColor2.g, chamsColor2.b, chamsColor2.a);

		zgui::setMousePos(x + 200, y + 250);

		zgui::combobox(XorStr("Material#materialHand"), materialsNames, config::visual.handChams.material);


		// overlay hand

		zgui::setMousePos(x, y + 300);

		zgui::checkbox(XorStr("Show overlay#useChamsoverlayHand"), config::visual.handChams.enableOverlay);

		zgui::setMousePos(x + 100, y + 300);

		zgui::color chamsColorHand = zgui::color();

		chamsColorHand.r = config::visual.handChams.overlayColor.r();
		chamsColorHand.g = config::visual.handChams.overlayColor.g();
		chamsColorHand.b = config::visual.handChams.overlayColor.b();
		chamsColorHand.a = config::visual.handChams.overlayColor.a();

		if (zgui::colorpicker(XorStr("Overlay color#chamsColorOverlayHand"), chamsColorHand))
			config::visual.handChams.overlayColor.SetColor(chamsColorHand.r, chamsColorHand.g, chamsColorHand.b, chamsColorHand.a);

		zgui::setMousePos(x + 200, y + 300);

		zgui::combobox(XorStr("Material#materialHandOverlay"), materialsNames, config::visual.handChams.overlayMaterial);

		zgui::setMousePos(x + 300, y + 300);

		zgui::checkbox(XorStr("Use rainbow color#rainbowOverlayHand"), config::visual.handChams.overlayRainbowColor);



		// Steeve


		zgui::setMousePos(x, y + 350);

		zgui::checkbox(XorStr("Steeves chams#useSteeves"), config::visual.sleeveChams.enable);

		zgui::setMousePos(x + 100, y + 350);

		zgui::color chamsColor3 = zgui::color();

		chamsColor3.r = config::visual.sleeveChams.color.r();
		chamsColor3.g = config::visual.sleeveChams.color.g();
		chamsColor3.b = config::visual.sleeveChams.color.b();
		chamsColor3.a = config::visual.sleeveChams.color.a();

		if (zgui::colorpicker(XorStr("Chams color#chamsColorSteeves"), chamsColor3))
			config::visual.sleeveChams.color.SetColor(chamsColor3.r, chamsColor3.g, chamsColor3.b, chamsColor3.a);

		zgui::setMousePos(x + 200, y + 350);

		zgui::combobox(XorStr("Material#materialSteeves"), materialsNames, config::visual.sleeveChams.material);

		// overlay Steeve

		zgui::setMousePos(x, y + 400);

		zgui::checkbox(XorStr("Show overlay#useChamsovSteeve"), config::visual.sleeveChams.enableOverlay);

		zgui::setMousePos(x + 100, y + 400);

		zgui::color chamsColorSteeve = zgui::color();

		chamsColorSteeve.r = config::visual.sleeveChams.overlayColor.r();
		chamsColorSteeve.g = config::visual.sleeveChams.overlayColor.g();
		chamsColorSteeve.b = config::visual.sleeveChams.overlayColor.b();
		chamsColorSteeve.a = config::visual.sleeveChams.overlayColor.a();

		if (zgui::colorpicker(XorStr("Overlay color#chamsColorOverSteeve"), chamsColorSteeve))
			config::visual.sleeveChams.overlayColor.SetColor(chamsColorSteeve.r, chamsColorSteeve.g, chamsColorSteeve.b, chamsColorSteeve.a);

		zgui::setMousePos(x + 200, y + 400);

		zgui::combobox(XorStr("Material#materialSteeveOverlay"), materialsNames, config::visual.sleeveChams.overlayMaterial);

		zgui::setMousePos(x + 300, y + 400);

		zgui::checkbox(XorStr("Use rainbow color#rainbowOverSteeve"), config::visual.sleeveChams.overlayRainbowColor);





		// backtrack chams

		zgui::setMousePos(x, y + 450);

		zgui::checkbox(XorStr("Show backtrack#useChamsbacktrack"), config::visual.enemyChamsBacktrack.enable);

		zgui::setMousePos(x + 100, y + 450);

		zgui::color chamsColor5 = zgui::color();

		chamsColor5.r = config::visual.enemyChamsBacktrack.color.r();
		chamsColor5.g = config::visual.enemyChamsBacktrack.color.g();
		chamsColor5.b = config::visual.enemyChamsBacktrack.color.b();
		chamsColor5.a = config::visual.enemyChamsBacktrack.color.a();

		if (zgui::colorpicker(XorStr("Chams color#chamsColorbacktrack"), chamsColor5))
			config::visual.enemyChamsBacktrack.color.SetColor(chamsColor5.r, chamsColor5.g, chamsColor5.b, chamsColor5.a);

		zgui::setMousePos(x + 200, y + 450);

		zgui::combobox(XorStr("Material#materialbacktrack"), materialsNames, config::visual.enemyChamsBacktrack.material);

		zgui::setMousePos(x + 300, y + 450);

		zgui::checkbox(XorStr("Use rainbow color#rainbowbacktrack"), config::visual.enemyChamsBacktrack.rainbowColor);

		// overlay chams

		zgui::setMousePos(x, y + 500);

		zgui::checkbox(XorStr("Show overlay#useChamsoverlaybacktrack"), config::visual.enemyChamsBacktrack.enableOverlay);

		zgui::setMousePos(x + 100, y + 500);

		zgui::color overlaychamsColor7 = zgui::color();

		overlaychamsColor7.r = config::visual.enemyChamsBacktrack.overlayColor.r();
		overlaychamsColor7.g = config::visual.enemyChamsBacktrack.overlayColor.g();
		overlaychamsColor7.b = config::visual.enemyChamsBacktrack.overlayColor.b();
		overlaychamsColor7.a = config::visual.enemyChamsBacktrack.overlayColor.a();

		if (zgui::colorpicker(XorStr("Overlay color#chamsColorbacktrackOverlay"), overlaychamsColor7))
			config::visual.enemyChamsBacktrack.overlayColor.SetColor(overlaychamsColor7.r, overlaychamsColor7.g, overlaychamsColor7.b, overlaychamsColor7.a);

		zgui::setMousePos(x + 200, y + 500);

		zgui::combobox(XorStr("Material#materialOverlaybacktrack"), materialsNames, config::visual.enemyChamsBacktrack.overlayMaterial);

		zgui::setMousePos(x + 300, y + 500);

		zgui::checkbox(XorStr("Use rainbow color#rainbowOverlaybacktrack"), config::visual.enemyChamsBacktrack.overlayRainbowColor);




		VMProtectEnd();
	}

	void drawMiscTab() {

		VMProtectBeginMutation("menu::drawMiscTab");

		float x = (float)menu::spaceSize + 20.0f;
		float y = (float)(menu::spaceSize + menu::tabSpaceSize) + 22.0f;

		zgui::checkbox(XorStr("Show spread circle"), config::visual.spreadCircle.enable);
		
		zgui::setMousePos(x + 150, y);

		zgui::checkbox(XorStr("Show grenade prediction"), config::visual.showGrenadePred);

		zgui::setMousePos(x + 270, y);

		zgui::checkbox(XorStr("Show spectators"), config::visual.showSpectators);

		zgui::setMousePos(x + 350, y);

		zgui::checkbox(XorStr("Show radar"), config::visual.showRadar);

		zgui::setMousePos(x + 420, y);

		zgui::checkbox(XorStr("Fast stop"), config::cheats.fastStop);



		zgui::setMousePos(x + 520, y);

		zgui::checkbox(XorStr("Silent walk"), config::cheats.silentWalk);


		zgui::setMousePos(x + 620, y);

		zgui::checkbox(XorStr("Optimize"), config::cheats.optimization);


		zgui::setMousePos(x, y + 100);

		zgui::multi_combobox(XorStr("Indicators#worldIndicators"), worldIndicator);

		zgui::setMousePos(x, y + 50);

		zgui::slider_float(XorStr("Spread minimun#spreadCicleminimun"), 0, 100, config::visual.spreadCircle.min);


		zgui::setMousePos(x, y + 170);

		zgui::checkbox(XorStr("Infinit Duck"), config::cheats.infinitDuck);

		zgui::setMousePos(x + 150, y + 170);

		if (zgui::checkbox(XorStr("Volume ESP"), config::cheats.volumeEsp)) {

			// make sure to exec after zgui::checkbox
			if (!config::cheats.volumeEsp) {
				soundEsp::remove();
			}
		}

		zgui::setMousePos(x + 200, y + 170);

		if (zgui::button(XorStr("Copy clear cheat exploit#sgsd0grdsgdshsdhsh"), { 150, 20 })) {
			misc::copyClipboardExploit();
		}


		zgui::setMousePos(x + 360, y + 170);

		if (zgui::button(XorStr("Hide name from vote#sgsd0grdsqsfqfqsfqdhsh"), { 150, 20 })) {
			misc::hideVoteName();
		}

		zgui::setMousePos(x + 520, y + 170);

		//zgui::text_input(XorStr("Fake ban#qgqsegqsggqee00"), pseudo, 30);

		//zgui::setMousePos(x + 450, y + 170);

		//if (zgui::button(XorStr("Apply#edsgqsgg44"), { 100, 20 })) {
		//	misc::fakeMessage(pseudo);
		//}

		if (zgui::button(XorStr("Stop microphone#qsfqfsqfqf"), { 100, 20 })) {
			voice::stop();
		}

		zgui::setMousePos(x, y + 200);

		zgui::checkbox(XorStr("Backtrack"), config::cheats.backtrack);

		zgui::setMousePos(x + 100, y + 200);

		zgui::slider_float(XorStr("Backtrack time#Backtracktime"), 0, 200, config::cheats.backtrackTime);

		zgui::setMousePos(x + 300, y + 200);

		zgui::slider_float(XorStr("Backtrack visibility#Backtrackvisibility"), 0, 100, config::cheats.backtrackVisibility);





		zgui::setMousePos(x, y + 300);

		if (zgui::button(XorStr("Load visual config#dfsfsdfdsfs"), { 100, 20 })) {
			config::openVisualConfig(XorStr("config.json"));
		}

		zgui::setMousePos(x + 120, y + 300);

		if (zgui::button(XorStr("Save visual config#sdgsgesgers"), { 100, 20 })) {
			config::saveVisualConfig(XorStr("config.json"));

			config::saveCheatConfig(XorStr("config.cheat.json"));
		}

		zgui::setMousePos(x + 240, y + 300);

		if (zgui::button(XorStr("Load cheat config#dfsfsddddfdsfs"), { 100, 20 })) {
			config::openCheatConfig(XorStr("config.cheat.json"));
		}

		zgui::setMousePos(x + 360, y + 300);

		if (zgui::button(XorStr("Save cheat config#sdgsgdddesgers"), { 100, 20 })) {
			config::saveCheatConfig(XorStr("config.cheat.json"));
		}

		VMProtectEnd();
	}

	void drawSound() {

		VMProtectBeginMutation("menu::drawSound");

		float x = (float)menu::spaceSize + 20.0f;
		float y = (float)(menu::spaceSize + menu::tabSpaceSize) + 22.0f;

		zgui::checkbox(XorStr("Enable sounds#soundsEnable"), config::visual.sounds.enable);

		zgui::setMousePos(x + 100, y);

		zgui::combobox(XorStr("Hitmarker#HitmarkerSound"), sound::sounds_short, config::visual.sounds.hitmarkerSound.index);

		zgui::setMousePos(x + 100, y + 50);

		zgui::checkbox(XorStr("Random#HitmarkerSoundRandom"), config::visual.sounds.hitmarkerSound.random);

		zgui::setMousePos(x + 100, y + 75);

		zgui::checkbox(XorStr("Through mic#4524674747"), config::visual.sounds.hitmarkerSound.through_mic);



		zgui::setMousePos(x + 200, y);

		zgui::combobox(XorStr("Headshot#HeadshotrSound"), sound::sounds_short, config::visual.sounds.headShootSound.index);

		zgui::setMousePos(x + 200, y + 50);

		zgui::checkbox(XorStr("Random#RandomHeadshotrSound"), config::visual.sounds.headShootSound.random);

		zgui::setMousePos(x + 200, y + 75);

		zgui::checkbox(XorStr("Through mic#563746464"), config::visual.sounds.headShootSound.through_mic);



		zgui::setMousePos(x + 300, y);

		zgui::combobox(XorStr("Bomb Planted#BombSound"), sound::sounds_short, config::visual.sounds.bombPlantedSound.index);

		zgui::setMousePos(x + 300, y + 50);

		zgui::checkbox(XorStr("Random#BombSoundRandom"), config::visual.sounds.bombPlantedSound.random);

		zgui::setMousePos(x + 300, y + 75);

		zgui::checkbox(XorStr("Through mic#54678634524"), config::visual.sounds.bombPlantedSound.through_mic);



		zgui::setMousePos(x + 400, y);

		zgui::combobox(XorStr("Round Lost#RoundLostSound"), sound::sounds_short, config::visual.sounds.roundEndLostSound.index);

		zgui::setMousePos(x + 400, y + 50);

		zgui::checkbox(XorStr("Random#RandomRoundLostSound"), config::visual.sounds.roundEndLostSound.random);


		zgui::setMousePos(x + 400, y + 75);

		zgui::checkbox(XorStr("Through mic#54678676746"), config::visual.sounds.roundEndLostSound.through_mic);



		zgui::setMousePos(x + 500, y);

		zgui::combobox(XorStr("Round Won#RoundWonSound"), sound::sounds_short, config::visual.sounds.roundEndWonSound.index);

		zgui::setMousePos(x + 500, y + 50);

		zgui::checkbox(XorStr("Random#RandomRoundWonSound"), config::visual.sounds.roundEndWonSound.random);

		zgui::setMousePos(x + 500, y + 75);

		zgui::checkbox(XorStr("Through mic#RanThroughundWonSound"), config::visual.sounds.roundEndWonSound.through_mic);




		zgui::setMousePos(x + 600, y);

		zgui::combobox(XorStr("Round Start#RoundStartSound"), sound::sounds_short, config::visual.sounds.roundStartSound.index);

		zgui::setMousePos(x + 600, y + 50);

		zgui::checkbox(XorStr("Random#RandomRoundStartSound"), config::visual.sounds.roundStartSound.random);

		zgui::setMousePos(x + 600, y + 75);

		zgui::checkbox(XorStr("Through mic#57456h78645"), config::visual.sounds.roundStartSound.through_mic);



		zgui::setMousePos(x, y + 200);

		zgui::checkbox(XorStr("Enable Team Model#EnableTeamModel"), config::visual.teamMateModel.enable);




		zgui::setMousePos(x + 100, y + 200);

		zgui::combobox(XorStr("Model#Model__"), modelNames, config::visual.teamMateModel.id);

		zgui::setMousePos(x, y + 300);

		if (zgui::checkbox(XorStr("World Modulation#dfshdshdeshsdhsds"), config::visual.world.enable)) {
			world::worldModulation();
		}

		zgui::setMousePos(x + 100, y + 300);

		zgui::color worldColor = zgui::color();

		worldColor.r = config::visual.world.worldColor.r();
		worldColor.g = config::visual.world.worldColor.g();
		worldColor.b = config::visual.world.worldColor.b();
		worldColor.a = config::visual.world.worldColor.a();

		if (zgui::colorpicker(XorStr("World Color#WorlddColor"), worldColor)) {
			config::visual.world.worldColor.SetColor(worldColor.r, worldColor.g, worldColor.b, worldColor.a);
			world::worldModulation();
		}

		zgui::setMousePos(x + 200, y + 300);

		zgui::color proposColor = zgui::color();

		proposColor.r = config::visual.world.propsColor.r();
		proposColor.g = config::visual.world.propsColor.g();
		proposColor.b = config::visual.world.propsColor.b();
		proposColor.a = config::visual.world.propsColor.a();

		if (zgui::colorpicker(XorStr("Props Color#PropssdColor"), proposColor)) {
			config::visual.world.propsColor.SetColor(proposColor.r, proposColor.g, proposColor.b, proposColor.a);
			world::worldModulation();
		}

		zgui::setMousePos(x + 300, y + 300);

		if (zgui::checkbox(XorStr("Sky Changer#ChangerSKy"), config::visual.sky.enable)) {
			world::changeWorldSky();
		}

		zgui::setMousePos(x + 400, y + 300);

		if (zgui::combobox(XorStr("Sky#dfshgdshsdhds"), world::skyboxs, config::visual.sky.sky)) {
			world::changeWorldSky();
		}


		VMProtectEnd();
	}

	std::string inputSkin = "";
	std::string inputKnifeSkin = "";
	std::string inputWear = "";
	std::string inputSeed = "";

	std::string inputSticker1 = "";
	std::string inputSticker2 = "";
	std::string inputSticker3 = "";
	std::string inputSticker4 = "";

	bool parseInt(std::string text, int* i) {

		VMProtectBeginMutation("menu::parseInt");

		std::stringstream ss(text);

		bool process = ((ss >> *i).fail());
		bool check = (ss >> std::ws).eof();

		VMProtectEnd();

		return (!process && check);
	}

	void loadConfig() {

		VMProtectBeginMutation("menu::loadConfig");

		auto currentSkinObject = currentSide ? tSkins : ctSkins;

		LOAD_CONFIG(inputSkin, paint)
			LOAD_CONFIG(inputWear, wear)
			LOAD_CONFIG(inputSeed, seed)
			LOAD_CONFIG(inputSticker1, sticker1)
			LOAD_CONFIG(inputSticker2, sticker2)
			LOAD_CONFIG(inputSticker3, sticker3)
			LOAD_CONFIG(inputSticker4, sticker4)
			
			inputKnifeSkin = std::to_string(currentSide ? config::visual.skins.tSkins.knifePaint : config::visual.skins.ctSkins.knifePaint);


		if(config::visual.world.enable)
			world::worldModulation();

		if (config::visual.sky.enable)
			world::changeWorldSky();

		VMProtectEnd();
	}


	void updateMenuSkin() {

		VMProtectBeginMutation("menu::updateMenuSkin");

		auto currentSkinObject = currentSide ? tSkins : ctSkins;

		UPDATE_CONFIG(inputSkin, paint, tmp1)
			UPDATE_CONFIG(inputWear, wear, tmp2)
			UPDATE_CONFIG(inputSeed, seed, tmp3)
			UPDATE_CONFIG(inputSticker1, sticker1, tmp4)
			UPDATE_CONFIG(inputSticker2, sticker2, tmp5)
			UPDATE_CONFIG(inputSticker3, sticker3, tmp6)
			UPDATE_CONFIG(inputSticker4, sticker4, tmp7)

			int knifeId = 0;
		if (parseInt(inputKnifeSkin, &knifeId))
			currentSide ? config::visual.skins.tSkins.knifePaint = knifeId : config::visual.skins.ctSkins.knifePaint = knifeId;

		VMProtectEnd();
	}

	void updateSkins() {

		VMProtectBeginMutation("menu::updateSkins");

		updateMenuSkin();

		skinchanger::updateSkin = true;

		// wait that "skin" thread refresh id's
		//while (skinchanger::updateSkin);

		interfaces::forceUpdate();
		
		VMProtectEnd();
	}

	void drawSkinTab() {

		VMProtectBeginMutation("menu::drawSkinTab");

		float x = (float)menu::spaceSize + 20.0f;
		float y = (float)(menu::spaceSize + menu::tabSpaceSize) + 22.0f;

		float paddingSlider = 120;

		// weapon skins

		auto currentSkinObject = currentSide ? tSkins : ctSkins;

		zgui::checkbox(XorStr("Enable skins#useSkin"), config::visual.skins.enable);

		zgui::setMousePos(x + 100, y);

		if (zgui::combobox(XorStr("Skin side#skinSide"), sides, currentSide)) {
			loadConfig();
		}

		zgui::setMousePos(x + 200, y);

		if (zgui::combobox(XorStr("Weapon#skinWeapon"), weaponNames, currentSkin)) {
			loadConfig();
		}

		zgui::setMousePos(x + 300, y);

		if (zgui::button(XorStr("Update#updateSkin"), { 75, 20 })) {
			//updateSkins();
		}

		zgui::setMousePos(x + 400, y);

		if (zgui::button(XorStr("Force Update#updateSkinUpdate"), { 75, 20 })) {
			updateMenuSkin();
			updateSkins();
		}

		zgui::setMousePos(x, y + 50);

		//zgui::combobox("Skins#skinCollection", skinsName, currentSkinObject[currentSkin]->paint);

		//zgui::slider_int(XorStr("Skins#skinCollection"), 0, 1200, currentSkinObject[currentSkin]->paint);
		if (zgui::text_input(XorStr("Skins#skinCollection"), inputSkin, 6)) {
			updateMenuSkin();
		}

		zgui::setMousePos(x, y + 100);

		//zgui::slider_int(XorStr("Sticker1#sSticker1"), 0, 5500, currentSkinObject[currentSkin]->sticker1);

		if (zgui::text_input(XorStr("Sticker1#sSticker1"), inputSticker1, 6)) {
		updateMenuSkin();
		}

		zgui::setMousePos(x + (paddingSlider), y + 100);

		if (zgui::text_input(XorStr("Sticker2#sSticker2"), inputSticker2, 6)) {
		updateMenuSkin();
		}
		//zgui::slider_int(XorStr("Sticker2#sSticker2"), 0, 5500, currentSkinObject[currentSkin]->sticker2);

		zgui::setMousePos(x + (paddingSlider * 2), y + 100);

		if (zgui::text_input(XorStr("Sticker3#sSticker3"), inputSticker3, 6)) {
		updateMenuSkin();
		}
		//zgui::slider_int(XorStr("Sticker3#sSticker3"), 0, 5500, currentSkinObject[currentSkin]->sticker3);

		zgui::setMousePos(x + (paddingSlider * 3), y + 100);

		if (zgui::text_input(XorStr("Sticker4#sSticker4"), inputSticker4, 6)) {
		updateMenuSkin();
		}
		//zgui::slider_int(XorStr("Sticker4#sSticker4"), 0, 5500, currentSkinObject[currentSkin]->sticker4);

		zgui::setMousePos(x, y + 200);

		// can't do it because of compilation optimization
		//auto knifeId = currentSide ? config::visual.skins.tSkins.knifeId : config::visual.skins.ctSkins.knifeId;

		if(currentSide)
			zgui::combobox(XorStr("Knife model#knifeModel"), knifeNames, config::visual.skins.tSkins.knifeId);
		else 
			zgui::combobox(XorStr("Knife model#knifeModel"), knifeNames, config::visual.skins.ctSkins.knifeId);

		zgui::setMousePos(x + 100, y + 200);

		//auto knifeSkin = currentSide ? config::visual.skins.tSkins.knifePaint : config::visual.skins.ctSkins.knifePaint;

		if (zgui::text_input(XorStr("Knife skin#skinKnife"), inputKnifeSkin, 6)) {
		updateMenuSkin();
		}

		//if (currentSide)
			//zgui::slider_int(XorStr("Knife skin#skinKnife"), 0, 1000, config::visual.skins.tSkins.knifePaint);
		//else
			//zgui::slider_int(XorStr("Knife skin#skinKnife"), 0, 1000, config::visual.skins.ctSkins.knifePaint);

		// model 

		zgui::setMousePos(x + 200, y + 200);

		zgui::checkbox(XorStr("Enable model changer#useModgdsg"), config::visual.playerModel.enable);

		zgui::setMousePos(x + 400, y + 200);

		zgui::combobox(XorStr("Model#modelDD"), modelNames, config::visual.playerModel.id);

		VMProtectEnd();
	}
}
```

`Lumina/Lumina/ui/menu.h`:

```h
#ifndef menu_h

#define menu_h

#include "../sdk/math/Color.h"
#include "texture.h"

#define UPDATE_CONFIG(text,object,var) \
int var = 0; \
if (parseInt(text, &var)) \
	currentSkinObject[currentSkin]->object = var; \

#define LOAD_CONFIG(text,object) \
	text = std::to_string(currentSkinObject[currentSkin]->object); \

namespace menu {

	extern bool visible;

	extern int x;
	extern int y;
	extern int alphaBackground;
	extern int alphaIntro;

	extern int lineSize;
	extern int spaceSize;
	extern int tabSpaceSize;
	extern int tabIconX;

	extern Color lightTop;
	extern Color lightBottom;

	extern Color mainTop;
	extern Color mainBottom;

	extern Color mainTabLight;
	extern Color mainTab;

	extern Color highContrast;

	extern Color textColor;

	extern texture logo;

	extern std::string inputSkin ;
	extern std::string inputKnifeSkin ;
	extern std::string inputWear ;
	extern std::string inputSeed ;

	extern std::string inputSticker1 ;
	extern std::string inputSticker2 ;
	extern std::string inputSticker3 ;
	extern std::string inputSticker4 ;

	extern void loadConfig();

	void drawVisualTab();
	void drawMiscTab();
	void drawSkinTab();
	void drawSound();

	void init();
	void drawMenu();
	void toggle();
	void skinUpdateCallback();
	//void multiboxCallback(std::pair<std::vector<std::string>, std::vector<bool*>> config, std::shared_ptr<FGUI::CMultiBox> box);
	//void checkboxCallback(bool* configValue, std::shared_ptr<FGUI::CCheckBox> checkbox);
	void draw();
	void drawIntro();
	void moduleAlpha();
	void drawBackground();
}

#endif
```

`Lumina/Lumina/ui/render.cpp`:

```cpp
#include "render.h"

#include "../sdk/interfaces.h"

namespace render {

	unsigned long font;
	unsigned long icons;
	unsigned long fontLight;
	unsigned long fontBigger;

	void init() {

		VMProtectBeginMutation("render::init");

		font = interfaces::surface->CreateFont(); //Tahoma//
		fontBigger = interfaces::surface->CreateFont(); //Tahoma//
		icons = interfaces::surface->CreateFont(); //Tahoma//
		fontLight = interfaces::surface->CreateFont(); //Tahoma//

		interfaces::surface->SetFontGlyphSet(font, XorStr("Visitor TT2 BRK"), 12, 400, 0, 0, FontFlags_t::FONTFLAG_OUTLINE);
		interfaces::surface->SetFontGlyphSet(icons, XorStr("csgo_icons"), 22, 400, 0, 0, FontFlags_t::FONTFLAG_NONE);
		interfaces::surface->SetFontGlyphSet(fontLight, XorStr("Tahoma"), 12, 400, 0, 0, FontFlags_t::FONTFLAG_OUTLINE);
		interfaces::surface->SetFontGlyphSet(fontBigger, XorStr("Tahoma"), 20, 400, 0, 0, FontFlags_t::FONTFLAG_OUTLINE);
			
		VMProtectEnd();
	}

	void drawEntityBox(Entity* entity, Color c) {

		VMProtectBeginMutation("render::drawEntityBox");

		box box;

		if (!utils::getEntityBox(entity, box))
			return;

		drawOutlinedBox(box.x,box.y,box.w,box.h,c);

		VMProtectEnd();
	}

	void drawCircle(int x, int y, int r, int s, Color color) {

		VMProtectBeginMutation("render::drawCircle");

		float Step = M_PI * 2.0 / s;

		for (float a = 0; a < (M_PI*2.0); a += Step) {
			float x1 = r * cos(a) + x;
			float y1 = r * sin(a) + y;
			float x2 = r * cos(a + Step) + x;
			float y2 = r * sin(a + Step) + y;
			interfaces::surface->DrawSetColor(color);
			interfaces::surface->DrawLine(x1, y1, x2, y2);
		}

		VMProtectEnd();
	}

	void drawLine(int x1, int y1, int x2, int y2, Color color) {

		VMProtectBeginMutation("render::drawLine");

		interfaces::surface->DrawSetColor(color);
		interfaces::surface->DrawLine(x1, y1, x2, y2);

		VMProtectEnd();
	}

	void drawOutlinedBoxFilled(int x, int y, int sizeX, int sizeY, Color color) {

		VMProtectBeginMutation("render::drawOutlinedBoxFilled");

		drawOutlinedRectangle(x - 1, y - 1, sizeX + 2, sizeY + 2, Color(0, 0, 0, color.a()));
		drawOutlinedRectangle(x + 1, y + 1, sizeX - 2, sizeY - 2, Color(0, 0, 0, color.a()));
		drawRectangle(x, y, sizeX, sizeY, color);

		VMProtectEnd();
	}

	void drawOutlinedBox(int x, int y, int sizeX, int sizeY, Color color) {

		VMProtectBeginMutation("render::drawOutlinedBox");

		drawOutlinedRectangle(x - 1, y - 1, sizeX + 2, sizeY + 2, Color(0, 0, 0, color.a()));
		drawOutlinedRectangle(x + 1, y + 1, sizeX - 2, sizeY - 2, Color(0, 0, 0, color.a()));
		drawOutlinedRectangle(x, y, sizeX, sizeY, color);

		VMProtectEnd();
	}

	void drawText(int x, int y, unsigned long font, std::wstring string, bool text_centered, Color color) {

		VMProtectBeginMutation("render::drawText");

		const wchar_t* converted_text = string.c_str();

		int width, height;
		interfaces::surface->GetTextSize(font, converted_text, width, height);

		interfaces::surface->DrawSetTextColor(color);
		interfaces::surface->DrawSetTextFont(font);

		if (text_centered)
			interfaces::surface->DrawSetTextPos(x - (width / 2), y);
		else
			interfaces::surface->DrawSetTextPos(x, y);

		interfaces::surface->DrawPrintText(converted_text, wcslen(converted_text));

		VMProtectEnd();
	}

	void drawText(int x, int y, unsigned long font, std::string string, bool text_centered, Color color) {

		VMProtectBeginMutation("render::drawText");

		std::wstring text = std::wstring(string.begin(), string.end());

		const wchar_t* converted_text = text.c_str();

		int width, height;
		interfaces::surface->GetTextSize(font, converted_text, width, height);

		interfaces::surface->DrawSetTextColor(color);
		interfaces::surface->DrawSetTextFont(font);

		if (text_centered)
			interfaces::surface->DrawSetTextPos(x - (width / 2), y);
		else
			interfaces::surface->DrawSetTextPos(x, y);

		interfaces::surface->DrawPrintText(converted_text, wcslen(converted_text));

		VMProtectEnd();
	}

	void drawRectangle(int x, int y, int sizeX, int sizeY, Color color) {

		VMProtectBeginMutation("render::drawRectangle");

		interfaces::surface->DrawSetColor(color);
		interfaces::surface->DrawFilledRect(x, y, x + sizeX, y + sizeY);

		VMProtectEnd();
	}

	void drawOutlinedRectangle(int x, int y, int sizeX, int sizeY, Color color) {

		VMProtectBeginMutation("render::drawOutlinedRectangle");

		interfaces::surface->DrawSetColor(color);
		interfaces::surface->DrawOutlinedRect(x, y, x + sizeX, y + sizeY);

		VMProtectEnd();
	}

	void drawGradiant(int x, int y, int sizeX, int sizeY, Color color1, Color color2, int alpha, bool horizontal) {

		VMProtectBeginMutation("render::drawGradiant");

		interfaces::surface->DrawSetColor(color1);
		interfaces::surface->DrawFilledRectFade(x, y, x + sizeX, y + sizeY, alpha, alpha, horizontal);

		interfaces::surface->DrawSetColor(color2);
		interfaces::surface->DrawFilledRectFade(x, y, x + sizeX, y + sizeY, 0, alpha, horizontal);

		VMProtectEnd();
	}
}
```

`Lumina/Lumina/ui/render.h`:

```h
#ifndef render_h

#define render_h

#include "../common/includes.h"

namespace render {

	extern unsigned long font;

	extern unsigned long icons;

	extern unsigned long fontLight;

	extern unsigned long fontBigger;

	void init();

	void drawLine(int x1, int y1, int x2, int y2, Color color);

	void drawText(int x, int y, unsigned long font, std::string string, bool text_centered, Color color);

	void drawText(int x, int y, unsigned long font, std::wstring string, bool text_centered, Color color);

	void drawEntityBox(Entity* entity, Color c);

	void drawOutlinedBox(int x, int y, int sizeX, int sizeY, Color color);

	void drawOutlinedBoxFilled(int x, int y, int sizeX, int sizeY, Color color);

	void drawOutlinedRectangle(int x, int y, int sizeX, int sizeY, Color color);

	void drawRectangle(int x, int y, int sizeX, int sizeY, Color color);

	void drawCircle(int x, int y, int r, int s, Color color);

	void drawGradiant(int x, int y, int sizeX, int sizeY, Color color1, Color color2, int alpha, bool horizontal);
}

#endif
```

`Lumina/Lumina/ui/sound.cpp`:

```cpp
#include "sound.h"

#include "../common/common.h"

#include "../sdk/interfaces.h"

#include <fstream>
#include <filesystem>

namespace sound {

	std::vector<std::string> sounds_short = {};
	std::vector<std::string> sounds_long = {};

	void init() {

		VMProtectBeginMutation("sound::init");

		std::string sound_path_short = StringHeavy("csgo\\sound\\lumina\\short");
		std::string sound_path_long = StringHeavy("csgo\\sound\\lumina\\long");

		for (const auto& entry : std::filesystem::directory_iterator(sound_path_short)) {
			if(strstr(entry.path().filename().string().c_str(), XorStr(".wav")))
				sounds_short.push_back(entry.path().filename().string());
		}
			

		for (const auto& entry : std::filesystem::directory_iterator(sound_path_long)) {
			if (strstr(entry.path().filename().string().c_str(), XorStr(".wav")))
				sounds_long.push_back(entry.path().filename().string());
		}

		//VECTOR_PUSH(sounds, "oof.mp3", tmp0)
		//VECTOR_PUSH(sounds, "heasshotgirl.wav", tmp1)
		//VECTOR_PUSH(sounds, "marioFail.wav", tmp2)
		//VECTOR_PUSH(sounds, "cavapeter.wav", tmp3)
		//VECTOR_PUSH(sounds, "roblox.wav", tmp4)
		//VECTOR_PUSH(sounds, "byebye.mp3", tmp5)
		//VECTOR_PUSH(sounds, "bell.wav", tmp6)
		//VECTOR_PUSH(sounds, "open.wav", tmp7)
		//VECTOR_PUSH(sounds, "close.wav", tmp8)
		//VECTOR_PUSH(sounds, "cod.wav", tmp9)
		//VECTOR_PUSH(sounds, "fatality.wav", tmp10)
		//VECTOR_PUSH(sounds, "flick.wav", tmp11)
		//VECTOR_PUSH(sounds, "bell.wav", tmp12)
		//VECTOR_PUSH(sounds, "marioFail.wav", tmp13)
		//VECTOR_PUSH(sounds, "buttons\\arena_switch_press_02.wav", tmp14)
		//VECTOR_PUSH(sounds, "pw_ragequit.mp3", tmp15)
		//VECTOR_PUSH(sounds, "started.wav", tmp16)
		//VECTOR_PUSH(sounds, "bom.mp3", tmp17)
		//VECTOR_PUSH(sounds, "pong.wav", tmp18)
		//VECTOR_PUSH(sounds, "solong.wav", tmp19)
		//VECTOR_PUSH(sounds, "hello.wav", tmp20)
		//VECTOR_PUSH(sounds, "bowser.mp3", tmp21)
		//VECTOR_PUSH(sounds, "newchainssameshackles.mp3", tmp22)

		VMProtectEnd();
	}

	void playSoundShort(int id) {

		VMProtectBeginMutation("sound::playSoundShort");

		std::string sound_path_short = XorStr("lumina\\short\\");
		sound_path_short.append(sound::sounds_short[id]);

		// play the sound
		interfaces::surface->PlaySound(sound_path_short.c_str());

		VMProtectEnd();
	}

	void playOpeningSound() {

		VMProtectBeginMutation("sound::playOpeningSound");

		interfaces::surface->PlaySound(XorStr("lumina\\open.wav"));

		//PlaySoundA(openRaw, NULL, SND_ASYNC | SND_MEMORY);

		VMProtectEnd();
	}

	void playClosingSound() {

		VMProtectBeginMutation("sound::playClosingSound");

		interfaces::surface->PlaySound(XorStr("lumina\\close.wav"));

		VMProtectEnd();
	}
}
```

`Lumina/Lumina/ui/sound.h`:

```h
#ifndef sound_h

#define sound_h

#include <string>
#include <vector>

namespace sound {

	void init();

	void playOpeningSound();

	void playClosingSound();

	void playSoundShort(int id);

	extern std::vector<std::string> sounds_short;
	extern std::vector<std::string> sounds_long;
}
#endif
```

`Lumina/Lumina/ui/texture.h`:

```h
#ifndef texture_h

#define texture_h

// from : https://www.unknowncheats.me/wiki/Team_Fortress_2:Embedding_and_rendering_custom_textures

#include "../common/includes.h"
#include "../sdk/interfaces.h"

class texture
{
public:
	typedef std::shared_ptr<texture> Ptr;
	texture()
		: m_pSurface(interfaces::surface), m_iH(0), m_iW(0), m_bgColor(255, 255, 255, 255), m_bValid(false)
	{ };

	texture(const unsigned char* pRawRGBAData, uint32 W, uint32 H)
		: m_pSurface(interfaces::surface), m_iH(H), m_iW(W), m_bgColor(255, 255, 255, 255), m_bValid(false)
	{
		m_iTexture = m_pSurface->CreateNewTextureID(true);
		if (!m_iTexture)
			return;
		m_pSurface->DrawSetTextureRGBA(m_iTexture, pRawRGBAData, W, H);
		m_bValid = true;
	};

	bool IsValid() const
	{
		return m_bValid;
	};

	int GetTextureId() const
	{
		return m_iTexture;
	};

	bool Draw(int x, int y, float scale = 1.0)
	{
		if (!m_pSurface->IsTextureIDValid(m_iTexture))
			return false;

		m_pSurface->DrawSetColor(m_bgColor);
		m_pSurface->DrawSetTexture(m_iTexture);
		m_pSurface->DrawTexturedRect(x, y, x + (int)(m_iW * scale), (int)(y + m_iH * scale));
		return true;
	};

	uint32 m_iTexture;
	uint32 m_iW, m_iH;
	Color  m_bgColor;
	bool   m_bValid;

	ISurface* m_pSurface;
};

#endif // !texture_h
```

`Lumina/Lumina/ui/zgui/LICENSE.md`:

```md
The MIT License (MIT)

Copyright (c) 2019, zxvnme

Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
```

`Lumina/Lumina/ui/zgui/README.md`:

```md
<div align="center">
<img width="258" src="resources/zgui.png" alt="zgui logo">
<h4>Simple immediate mode gui framework</h4>

[![forthebadge](https://forthebadge.com/images/badges/made-with-c-plus-plus.svg)](https://forthebadge.com)
[![forthebadge](https://forthebadge.com/images/badges/built-with-love.svg)](https://forthebadge.com)
<div>
 
[![discord](https://discordapp.com/api/guilds/583423779988832445/widget.png?style=shield)](https://discord.gg/gJVGg7u)
</div>

</div>

#

Simple, two file immediate mode gui framework written in **C++17**, mainly aimed for people beginning their journey with game hacking (but not limited to).
Its main goals are to be **universal** (it works on all graphics APIs; DirectX, OpenGL, Vulkan etc.) and **dependency free**. Therefore zgui is really **easy to use** and it has simple but aesthetic UI that can be extended or modified easily too.

All functions of framework are described in [header file](zgui.hh).  
Dont forget to check out [official zgui wiki](https://github.com/zxvnme/zgui/wiki), you will find there documentation of zgui and guide how to use zgui.  

Also shoutout to [alphauc](https://github.com/alphauc) for example zgui implementation in his [SDK](https://github.com/alphauc/sdk)

See gif for preview.

<img src="https://i.imgur.com/jH2lcDl.gif" width="380" height="350">

### Donators
Huge thanks to [vocan](https://github.com/vocan) for finance support of the project :)

If you want to be here and give donation to `zgui`, write to me on [official zgui discord](https://discord.gg/gJVGg7u).

### Acknowledgments
Special thanks to [cyanidee](https://github.com/cyanidee) for explaining me loads of things.
... and all the community contributors.

```

`Lumina/Lumina/ui/zgui/dist/zgui.cc`:

```cc
#include "./zgui.hh"
#include "../../render.h"
#include "../../sound.h"

using namespace zgui::globals;
zgui::functions_t zgui::functions;
zgui::gui_window_context_t zgui::globals::window_ctx;

// ========================================================================
bool zgui::button(const char *id, const vec2 size) {

    bool result = false;

    VMProtectBeginMutation("zgui::button");

    std::vector<std::string> id_split = utils::hash::split_str(id, '#');

    const unsigned long font = utils::misc::pop_font();

    const vec2 cursor_pos = utils::misc::pop_cursor_pos();
    const vec2 draw_pos{window_ctx.position.x + cursor_pos.x, window_ctx.position.y + cursor_pos.y};

    const bool active = window_ctx.blocking == utils::hash::hash(id);

    if (const bool hovered = utils::input::mouse_in_region(draw_pos.x, draw_pos.y, size.x, size.y); !active && hovered && utils::input::key_pressed(VK_LBUTTON)) {
        window_ctx.blocking = utils::hash::hash(id);
    }
    else if (active && !utils::input::key_down(VK_LBUTTON)) {
        window_ctx.blocking = 0;
        result = hovered;
        sound::playOpeningSound();
    }

    int text_width, text_height;
    functions.get_text_size(font, id_split[0].c_str(), text_width, text_height);

    window_ctx.render.emplace_back(zgui_control_render_t{{draw_pos.x + size.x / 2 - text_width / 2, draw_pos.y + size.y / 2 - text_height / 2}, zgui_render_type::zgui_text, global_colors.color_text, id_split[0], vec2{0, 0}, font});
    window_ctx.render.emplace_back(zgui_control_render_t{{draw_pos.x + 1, draw_pos.y + 1}, zgui_render_type::zgui_filled_rect, active ? global_colors.control_active_or_clicked : global_colors.control_idle, "", {size.x - 2, size.y - 2}});
    window_ctx.render.emplace_back(zgui_control_render_t{{draw_pos.x, draw_pos.y}, zgui_render_type::zgui_filled_rect, global_colors.control_outline, "", size});

    utils::misc::push_cursor_pos(vec2{cursor_pos.x + size.x + global_config.item_spacing, cursor_pos.y});
    utils::misc::push_cursor_pos(vec2{cursor_pos.x, cursor_pos.y + size.y / 2 + global_config.item_spacing});

    utils::misc::push_font(font);

    VMProtectEnd();

    return result;
}
// ========================================================================

bool zgui::buttonWithPosition(const char *id, const vec2 size, const vec2 cursor_pos) {

  bool result = false;

  VMProtectBeginMutation("zgui::buttonWithPosition");

  std::vector<std::string> id_split = utils::hash::split_str(id, '#');

  const unsigned long font = utils::misc::pop_font();

  const vec2 draw_pos{ window_ctx.position.x + cursor_pos.x, window_ctx.position.y + cursor_pos.y };

  const bool active = window_ctx.blocking == utils::hash::hash(id);

  if (const bool hovered = utils::input::mouse_in_region(draw_pos.x, draw_pos.y, size.x, size.y); !active && hovered && utils::input::key_pressed(VK_LBUTTON)) {
    window_ctx.blocking = utils::hash::hash(id);
  }
  else if (active && !utils::input::key_down(VK_LBUTTON)) {
    window_ctx.blocking = 0;
    result = hovered;
  }

  int text_width, text_height;
  functions.get_text_size(font, id_split[0].c_str(), text_width, text_height);

  window_ctx.render.emplace_back(zgui_control_render_t{ {draw_pos.x + size.x / 2 - text_width / 2, draw_pos.y + size.y / 2 - text_height / 2}, zgui_render_type::zgui_text, global_colors.color_text, id_split[0], vec2{0, 0}, font });
  window_ctx.render.emplace_back(zgui_control_render_t{ {draw_pos.x + 1, draw_pos.y + 1}, zgui_render_type::zgui_filled_rect, active ? global_colors.control_active_or_clicked : global_colors.control_idle, "", {size.x - 2, size.y - 2} });
  window_ctx.render.emplace_back(zgui_control_render_t{ {draw_pos.x, draw_pos.y}, zgui_render_type::zgui_filled_rect, global_colors.control_outline, "", size });

  utils::misc::push_cursor_pos(vec2{ cursor_pos.x + size.x + global_config.item_spacing, cursor_pos.y });
  utils::misc::push_cursor_pos(vec2{ cursor_pos.x, cursor_pos.y + size.y / 2 + global_config.item_spacing });

  utils::misc::push_font(font);

  VMProtectEnd();

  return result;
}

// ========================================================================
bool zgui::checkbox(const char *id, bool &value) {

    VMProtectBeginMutation("zgui::checkbox");

    std::vector<std::string> id_split = utils::hash::split_str(id, '#');

    const int control_height = 8;
    const int control_width = 8;

    const unsigned long font = utils::misc::pop_font();

    const vec2 cursor_pos = utils::misc::pop_cursor_pos();
    const vec2 draw_pos{window_ctx.position.x + cursor_pos.x, window_ctx.position.y + cursor_pos.y};

    int text_width, text_height;
    functions.get_text_size(font, id_split[0].c_str(), text_width, text_height);

    const bool active = window_ctx.blocking == utils::hash::hash(id);

    bool clicked_value = false;

    if (const bool hovered = utils::input::mouse_in_region(draw_pos.x, draw_pos.y, control_width + 6 + text_width, control_height); !active && hovered && utils::input::key_pressed(VK_LBUTTON)) {
        window_ctx.blocking = utils::hash::hash(id);
    }
    else if (active && !utils::input::key_down(VK_LBUTTON)) {
        window_ctx.blocking = 0;
        value = !value;

        clicked_value = true;

        if(!value)
          sound::playClosingSound();
        else
          sound::playOpeningSound();
    } 

    window_ctx.render.emplace_back(zgui_control_render_t{{draw_pos.x + 14, draw_pos.y - 2}, zgui_render_type::zgui_text, value ? global_colors.color_text : global_colors.color_text_dimmer, id_split[0], vec2{0, 0}, font});
    window_ctx.render.emplace_back(zgui_control_render_t{{draw_pos.x + 1, draw_pos.y + 1}, zgui_render_type::zgui_filled_rect, value ? global_colors.control_active_or_clicked : global_colors.control_idle, "", {control_width - 2, control_height - 2}});
    window_ctx.render.emplace_back(zgui_control_render_t{{draw_pos.x, draw_pos.y}, zgui_render_type::zgui_filled_rect, global_colors.control_outline, "", {control_width, control_height}});

    utils::misc::push_cursor_pos(vec2{cursor_pos.x + 14 + text_width + global_config.item_spacing, cursor_pos.y});
    utils::misc::push_cursor_pos(vec2{cursor_pos.x, cursor_pos.y + global_config.item_spacing});

    utils::misc::push_font(font);

    return clicked_value;

    VMProtectEnd();
}
// ========================================================================

// ========================================================================
bool zgui::combobox(const char *id, std::vector<std::string> items, int &value) {

    VMProtectBeginMutation("zgui::combobox");

    std::vector<std::string> id_split = utils::hash::split_str(id, '#');

    const int control_width = 70;
    const int control_height = 20;

    value = std::clamp(value, 0, static_cast<int>(items.size()) - 1);

    const unsigned long font = utils::misc::pop_font();

    const vec2 cursor_pos = utils::misc::pop_cursor_pos();
    vec2 draw_pos{window_ctx.position.x + cursor_pos.x + 14, window_ctx.position.y + cursor_pos.y};

    const bool inlined = id_split[0].empty();

    if (!inlined) {
        int text_width, text_height;

        functions.get_text_size(font, id_split[0].c_str(), text_width, text_height);

        window_ctx.render.emplace_back(zgui_control_render_t{{draw_pos.x, draw_pos.y - 4}, zgui_render_type::zgui_text, global_colors.color_text, id_split[0], vec2{0, 0}, font});

        draw_pos.y += text_height;
    }

    window_ctx.render.emplace_back(zgui_control_render_t{{draw_pos.x + control_width - 10, draw_pos.y + 4}, zgui_render_type::zgui_text, global_colors.color_text, "+", vec2{0, 0}, font});
    window_ctx.render.emplace_back(zgui_control_render_t{{draw_pos.x + 4, draw_pos.y + 4}, zgui_render_type::zgui_text, global_colors.color_text, items.at(value), vec2{0, 0}, font});
    window_ctx.render.emplace_back(zgui_control_render_t{{draw_pos.x + 1, draw_pos.y + 1}, zgui_render_type::zgui_filled_rect, global_colors.control_idle, "", {control_width - 2, control_height - 2}});
    window_ctx.render.emplace_back(zgui_control_render_t{{draw_pos.x, draw_pos.y}, zgui_render_type::zgui_filled_rect, global_colors.control_outline, "", {control_width, control_height}});

    utils::misc::push_cursor_pos(vec2{cursor_pos.x + control_width + global_config.item_spacing, cursor_pos.y});
    utils::misc::push_cursor_pos(vec2{cursor_pos.x, cursor_pos.y + control_height / 2 + global_config.item_spacing + (inlined ? 0 : 12)});

    bool clicked = false;

    if (const bool hovered = utils::input::mouse_in_region(draw_pos.x, draw_pos.y, control_width, control_height); hovered && utils::input::key_pressed(VK_LBUTTON) && window_ctx.blocking == 0) {
        window_ctx.blocking = utils::hash::hash(id);
    }
    else if (window_ctx.blocking == utils::hash::hash(id)) {
        for (int i = 1; i <= items.size(); i++) {
            bool hovered = utils::input::mouse_in_region(draw_pos.x, draw_pos.y + (control_height - 1) * i, control_width, control_height);

            if (hovered && utils::input::key_pressed(VK_LBUTTON)) {
                window_ctx.blocking = 0;
                value = i - 1;

                 sound::playOpeningSound();
                 clicked = true;
            }

            if (!hovered && utils::input::key_pressed(VK_LBUTTON)) {
                window_ctx.blocking = 0;
            }


            bool selected = value == i - 1;
            window_ctx.render.emplace_back(zgui_control_render_t{{draw_pos.x + 4, draw_pos.y + (control_height - 1) * i + 4}, zgui_render_type::zgui_text, selected ? global_colors.control_active_or_clicked : global_colors.color_text, items.at(i - 1), vec2{0, 0}, font});
            window_ctx.render.emplace_back(zgui_control_render_t{{draw_pos.x + 1, draw_pos.y + (19 * i) + 1}, zgui_render_type::zgui_filled_rect, hovered ? global_colors.color_combo_bg : global_colors.control_idle, "", {control_width - 2, control_height - 2}});
            window_ctx.render.emplace_back(zgui_control_render_t{{draw_pos.x, draw_pos.y + 19 * i}, zgui_render_type::zgui_filled_rect, global_colors.control_outline, "", {control_width, control_height}});
        }
    }

    utils::misc::push_font(font);

    VMProtectEnd();

    return clicked;
}

void zgui::setMousePos(float x, float y) {

  zgui::vec2 cursor_pos = zgui::utils::misc::pop_cursor_pos();

  zgui::vec2 new_cursor_pos{ x, y };

  zgui::utils::misc::push_cursor_pos(new_cursor_pos);
}

// ========================================================================
void zgui::multi_combobox(const char *id, std::vector<multi_select_item> items) {



    std::vector<std::string> id_split = utils::hash::split_str(id, '#');

    const int control_width = 100;
    const int control_height = 20;

    const unsigned long font = utils::misc::pop_font();

    const vec2 cursor_pos = utils::misc::pop_cursor_pos();
    vec2 draw_pos{window_ctx.position.x + cursor_pos.x + 14, window_ctx.position.y + cursor_pos.y};

    const bool inlined = id_split[0].empty();

    if (!inlined) {
        int text_width, text_height;
        functions.get_text_size(font, id_split[0].c_str(), text_width, text_height);

        window_ctx.render.emplace_back(zgui_control_render_t{{draw_pos.x, draw_pos.y - 4}, zgui_render_type::zgui_text, global_colors.color_text, id_split[0], vec2{0, 0}, font});

        draw_pos.y += text_height;
    }

    std::string value_str;
    int text_width, text_height;

    for (auto &item_t : items) {
        if (*item_t.value) {
            if (value_str.length() > 0)
                value_str += ", ";

            value_str += item_t.name;
        }
    }

    functions.get_text_size(font, value_str.c_str(), text_width, text_height);
    if (text_width > control_width - 18) {
        value_str.resize(control_width / 10);
        value_str += " ...";
    }
    if (!value_str.length())
        value_str += "None";

    window_ctx.render.emplace_back(zgui_control_render_t{{draw_pos.x + control_width - 10, draw_pos.y + 4}, zgui_render_type::zgui_text, global_colors.color_text, "+", vec2{0, 0}, font});
    window_ctx.render.emplace_back(zgui_control_render_t{{draw_pos.x + 4, draw_pos.y + 4}, zgui_render_type::zgui_text, global_colors.color_text, value_str, vec2{0, 0}, font});
    window_ctx.render.emplace_back(zgui_control_render_t{{draw_pos.x + 1, draw_pos.y + 1}, zgui_render_type::zgui_filled_rect, global_colors.control_idle, "", {control_width - 2, control_height - 2}});
    window_ctx.render.emplace_back(zgui_control_render_t{{draw_pos.x, draw_pos.y}, zgui_render_type::zgui_filled_rect, global_colors.control_outline, "", {control_width, control_height}});

    utils::misc::push_cursor_pos(vec2{cursor_pos.x + control_width + global_config.item_spacing, cursor_pos.y});
    utils::misc::push_cursor_pos(vec2{cursor_pos.x, cursor_pos.y + control_height / 2 + global_config.item_spacing + (inlined ? 0 : 12)});


    if (const bool hovered = utils::input::mouse_in_region(draw_pos.x, draw_pos.y, control_width, control_height); hovered && utils::input::key_pressed(VK_LBUTTON) && window_ctx.blocking == 0) {
        window_ctx.blocking = utils::hash::hash(id);
    }
    else if (window_ctx.blocking == utils::hash::hash(id)) {
        for (int i = 1; i <= items.size(); i++) {
            bool hovered = utils::input::mouse_in_region(draw_pos.x, draw_pos.y + (control_height - 1) * i, control_width, control_height);
            const bool outofbounds = utils::input::mouse_in_region(draw_pos.x, draw_pos.y + (control_height - 1), control_width, control_height * i);
            if (hovered && utils::input::key_pressed(VK_LBUTTON)) {
                window_ctx.blocking = utils::hash::hash(id);
                *items[i - 1].value = !*items[i - 1].value;

                if (!*items[i - 1].value)
                  sound::playClosingSound();
                else
                  sound::playOpeningSound();
            }
            if (!outofbounds && utils::input::key_pressed(VK_LBUTTON)) {
                window_ctx.blocking = 0;
            }
            bool selected = *items[i - 1].value >= 1;
            window_ctx.render.emplace_back(zgui_control_render_t{{draw_pos.x + 4, draw_pos.y + (control_height - 1) * i + 4}, zgui_render_type::zgui_text, selected ? global_colors.control_active_or_clicked : global_colors.color_text, items[i - 1].name.data(), vec2{0, 0}, font});
            window_ctx.render.emplace_back(zgui_control_render_t{{draw_pos.x + 1, draw_pos.y + (19 * i) + 1}, zgui_render_type::zgui_filled_rect, hovered ? global_colors.color_combo_bg : global_colors.control_idle, "", {control_width - 2, control_height - 2}});
            window_ctx.render.emplace_back(zgui_control_render_t{{draw_pos.x, draw_pos.y + 19 * i}, zgui_render_type::zgui_filled_rect, global_colors.control_outline, "", {control_width, control_height}});
        }
    }

    utils::misc::push_font(font);
}
// ========================================================================

static bool rightclicked;
HWND hwndclip = GetDesktopWindow();

void zgui::sendToClipboard(HWND hwnd, const std::string& s) {
  OpenClipboard(hwnd);
  EmptyClipboard();
  HGLOBAL hg = GlobalAlloc(GMEM_MOVEABLE, s.size() + 1);
  if (!hg) {
    CloseClipboard();
    return;
  }
  memcpy(GlobalLock(hg), s.c_str(), s.size() + 1);
  GlobalUnlock(hg);
  SetClipboardData(CF_TEXT, hg);
  CloseClipboard();
  GlobalFree(hg);
}

bool zgui::colorpicker(const char* id, zgui::color& item)
{
    bool setColor = false;

  try {
   
  std::vector<std::string> id_split = utils::hash::split_str(id, '#');

  const int control_height = 8;
  const int control_width = 8;

  const int slider_height = 10;
  const int slider_width = 152.5f;

  const zgui::vec2 cursor_pos = utils::misc::pop_cursor_pos();
 // const zgui::vec2 draw_pos{ window_ctx.position.x + cursor_pos.x + 175, window_ctx.position.y + cursor_pos.y - 16 };
  const zgui::vec2 draw_pos{ window_ctx.position.x + cursor_pos.x, window_ctx.position.y + cursor_pos.y };

  zgui::color rainbow;
  zgui::color grey;

  int text_wide, text_tall;

  // TROUBLLLLLLLLLLLLLLLLEEE

  const unsigned long font = utils::misc::pop_font();

  zgui::functions.get_text_size(font, id_split[0].c_str(), text_wide, text_tall);

  int CtrXoffset = 0;
 
  const float x_offset = 75;
  const float y_offset = 0;
  float yoffset = draw_pos.y + y_offset;
  float slideryoffset = draw_pos.y + 173;
  float xoffset = draw_pos.x + x_offset;
  float sliderxoffset = draw_pos.x + (x_offset / 2) - 3.5f;

  const int min = 0;
  const int max = 255;

  const bool active = window_ctx.blocking == utils::hash::hash(id);

  std::string itemstring = std::to_string(item.r);
  itemstring += std::to_string(item.g);
  itemstring += std::to_string(item.b);
  itemstring += std::to_string(item.a);
 


  if (const bool hovered = utils::input::mouse_in_region(draw_pos.x, draw_pos.y, control_width + 6 + text_wide, control_height); !active && hovered && utils::input::key_pressed(VK_RBUTTON)) {
    rightclicked = true;
  }
  else {
    rightclicked = false;
  }

  if (rightclicked)
  {
    zgui::sendToClipboard(hwndclip, itemstring);
  }

  
  if (const bool hovered = utils::input::mouse_in_region(draw_pos.x, draw_pos.y, control_width * 2, control_height); !active && hovered && utils::input::key_pressed(VK_LBUTTON))
  {
    window_ctx.blocking = utils::hash::hash(id);
  }
  else if (active)
  {
    if (utils::input::mouse_in_region(draw_pos.x, draw_pos.y, 2 * control_width, control_height) && utils::input::key_pressed(VK_LBUTTON))
      window_ctx.blocking = 0;

    if (utils::input::mouse_in_region(draw_pos.x + 20, draw_pos.y + 5, 200, 180) && utils::input::key_pressed(VK_LBUTTON))
      window_ctx.blocking = utils::hash::hash(id);

    if (!utils::input::mouse_in_region(draw_pos.x + 15, draw_pos.y + 5, 200, 190) && utils::input::key_pressed(VK_LBUTTON))
      window_ctx.blocking = 0;

    for (int i = 0; i < 990; i++)
    {
      if (utils::input::mouse_in_region(xoffset + 100, yoffset, 5, 5))
      {
        if (utils::input::key_down(VK_LBUTTON)) {
          item.r = rainbow.r;
          item.g = rainbow.g;
          item.b = rainbow.b;
          setColor = true;
        }
        //if (key_released(VK_LBUTTON))
        //	window_ctx.blocking = 0;
      }

      if (xoffset >= draw_pos.x + x_offset)
      {
        xoffset -= 150;
        yoffset += 5;
      }

      float hue = (i * .001f);

      rainbow.FromHSV(hue, 1.f, 1.f);

      window_ctx.render.emplace_back(zgui::zgui_control_render_t{ { xoffset + 110, yoffset, }, zgui::zgui_render_type::zgui_filled_rect,zgui::color { rainbow.r, rainbow.g, rainbow.b, global_colors.control_outline.a },"", { 5,5 } });

      if (GetAsyncKeyState(VK_LBUTTON) && utils::input::mouse_in_region(xoffset + 125, yoffset, 5, 5))
      {
        item.r = rainbow.r;
        item.g = rainbow.g;
        item.b = rainbow.b;
        setColor = true;
      }

      xoffset += 5;

    }

    for (int i = 0; i < 40; i++)
    {
      if (utils::input::mouse_in_region(draw_pos.x + 20, (yoffset + 5) - 170, 10, 4))
      {
        if (utils::input::key_down(VK_LBUTTON)) {
          item.r = grey.r;
          item.g = grey.g;
          item.b = grey.b;
          setColor = true;
        }
        //if (key_released(VK_LBUTTON))
        //	window_ctx.blocking = 0;
      }

      if (xoffset >= draw_pos.x + x_offset)
      {
        xoffset -= 4;
        yoffset += 4;
      }

      float hue = (i * .025f);

      grey.FromHSV(0.f, 0.f, hue);

      window_ctx.render.emplace_back(zgui::zgui_control_render_t{ { draw_pos.x + 20, (yoffset + 5) - 170, }, zgui::zgui_render_type::zgui_filled_rect,zgui::color { grey.r, grey.g, grey.b, global_colors.control_outline.a },"", { 10,4 } });

      if (GetAsyncKeyState(VK_LBUTTON) && utils::input::mouse_in_region(draw_pos.x + 20, (yoffset + 5) - 170, 10, 4))
      {
        item.r = grey.r;
        item.g = grey.g;
        item.b = grey.b;
        setColor = true;
      }

      xoffset += 4;

    }

    if (window_ctx.blocking == 0 && utils::input::mouse_in_region(draw_pos.x - (control_height - 2), draw_pos.y, 8, 10) && utils::input::key_pressed(VK_LBUTTON)) {
        item.a = std::clamp(item.a - 1, min, max);
        setColor = true;
    }
      
    else if (window_ctx.blocking == 0 && utils::input::mouse_in_region(draw_pos.x + control_width, draw_pos.y, 8, 10) && utils::input::key_pressed(VK_LBUTTON)) {
        item.a = std::clamp(item.a + 1, min, max);
        setColor = true;
    }
      

    if (utils::input::key_down(VK_LBUTTON) && utils::input::mouse_in_region(sliderxoffset, slideryoffset, slider_width + 5, slider_height) && window_ctx.blocking == utils::hash::hash(id)) {
      window_ctx.blocking = utils::hash::hash(id);
      float value_unmapped = std::clamp(mouse_pos.x - sliderxoffset, 0.0f, static_cast<float>(slider_width));
      int value_mapped = static_cast<int>(value_unmapped / slider_width * (max - min) + min);
      item.a = value_mapped;
      setColor = true;
    }

    const int dynamic_width = (static_cast<float>(item.a) - min) / (max - min) * slider_width - 2;

    int text_x = dynamic_width - text_wide;

    if (text_x < 0)
      text_x = 0;

    rainbow.r = item.r;
    rainbow.g = item.g;
    rainbow.b = item.b;
    rainbow.a = item.a;

    window_ctx.render.emplace_back(zgui::zgui_control_render_t{ { sliderxoffset + 1 , slideryoffset + 1  }, zgui_render_type::zgui_filled_rect, color{item.r,item.g,item.b,item.a}, "", { static_cast<float>(dynamic_width), control_height - 2 } });
    window_ctx.render.emplace_back(zgui::zgui_control_render_t{ { sliderxoffset + 1 , slideryoffset + 1 }, zgui_render_type::zgui_filled_rect, global_colors.control_idle,"", { slider_width - 2, control_height - 2 } });
    window_ctx.render.emplace_back(zgui::zgui_control_render_t{ { sliderxoffset , slideryoffset  }, zgui_render_type::zgui_filled_rect, global_colors.control_outline,"", { slider_width, control_height } });

  }

  if (global_colors.control_outline.a >= 250)
    window_ctx.render.emplace_back(zgui::zgui_control_render_t{ { draw_pos.x, draw_pos.y }, zgui::zgui_render_type::zgui_filled_rect, zgui::color{item.r,item.g,item.b,item.a},"", { 2 * control_width, control_height } });
  else
    window_ctx.render.emplace_back(zgui::zgui_control_render_t{ { draw_pos.x, draw_pos.y }, zgui::zgui_render_type::zgui_filled_rect, zgui::color{item.r,item.g,item.b,global_colors.control_outline.a},"", { 2 * control_width, control_height } });

  window_ctx.render.emplace_back(zgui::zgui_control_render_t{ { draw_pos.x - 1, draw_pos.y - 1 }, zgui::zgui_render_type::zgui_rect, zgui::color{0,0,0,global_colors.control_outline.a},"", { 2 * control_width + 2, control_height + 2 } });

  utils::misc::push_cursor_pos(zgui::vec2{ cursor_pos.x + 14 + global_config.item_spacing, cursor_pos.y });
  utils::misc::push_cursor_pos(zgui::vec2{ cursor_pos.x, cursor_pos.y });

  utils::misc::push_font(font);

    }
    catch (...)
    {

    } 

    return setColor;
}


// ========================================================================
void zgui::begin_groupbox(std::string_view title, const vec2 size, const int flags) {
    const unsigned long font = utils::misc::pop_font();

    const vec2 cursor_pos = utils::misc::pop_cursor_pos();
    const vec2 draw_pos{window_ctx.position.x + cursor_pos.x, window_ctx.position.y + cursor_pos.y};

    int text_width, text_height;

    if (!title.empty())
        functions.get_text_size(font, title.data(), text_width, text_height);

    const int header_height = title.empty() ? 16 : text_height + 3;

    if (flags & zgui_groupbox_flags_legacy_design) {
        functions.draw_rect(draw_pos.x - 1, draw_pos.y - 1, size.x + 2, size.y + 2, global_colors.control_outline);
        functions.draw_filled_rect(draw_pos.x, draw_pos.y, size.x, size.y, global_colors.color_groupbox_bg);

        if (!title.empty()) {
            functions.draw_text(draw_pos.x + 4, draw_pos.y - 8, global_colors.color_text, font, false, title.data());
        }
    }
    else {
        functions.draw_rect(draw_pos.x - 1, draw_pos.y - 1, size.x + 2, size.y + 2, global_colors.control_outline);
        functions.draw_filled_rect(draw_pos.x, draw_pos.y, size.x, size.y, global_colors.color_groupbox_bg);

        functions.draw_filled_rect(draw_pos.x, draw_pos.y, size.x, header_height, global_colors.color_groupbox_header);
        functions.draw_line(draw_pos.x, draw_pos.y + header_height, draw_pos.x + size.x, draw_pos.y + header_height, global_colors.control_outline);

        if (!title.empty()) {
            functions.draw_text(draw_pos.x + size.x / 2 - text_width / 2, draw_pos.y + 2, global_colors.color_text, font, false, title.data());
        }
    }

    window_ctx.next_cursor_pos = vec2{cursor_pos.x, cursor_pos.y + size.y + 10};

    utils::misc::push_cursor_pos(vec2{ cursor_pos.x + 8, cursor_pos.y + ((flags & zgui_groupbox_flags_legacy_design) ? 0 : header_height) + 8 });

    utils::misc::push_font(font);
}

// ========================================================================
void zgui::end_groupbox() {
    utils::misc::push_cursor_pos(window_ctx.next_cursor_pos);
    window_ctx.next_cursor_pos = {};
}
// ========================================================================


// ========================================================================
void zgui::key_bind(const char *id, int &value) {
    std::vector<std::string> id_split = utils::hash::split_str(id, '#');

    const int control_width = 80;
    const int control_height = 20;

    value = std::clamp(value, 0, 255);

    const unsigned long font = utils::misc::pop_font();

    const vec2 cursor_pos = utils::misc::pop_cursor_pos();
    vec2 draw_pos{window_ctx.position.x + cursor_pos.x + 14, window_ctx.position.y + cursor_pos.y};

    const bool inlined = id_split[0].empty();

    if (!inlined) {
        int text_width, text_height;
        functions.get_text_size(font, id_split[0].c_str(), text_width, text_height);

        window_ctx.render.emplace_back(zgui_control_render_t{{draw_pos.x, draw_pos.y - 4}, zgui_render_type::zgui_text, global_colors.color_text, id_split[0], vec2{0, 0}, font});

        draw_pos.y += text_height;
    }

    const bool active = window_ctx.blocking == utils::hash::hash(id);

    if (const bool hovered = utils::input::mouse_in_region(draw_pos.x, draw_pos.y, control_width, control_height); hovered && utils::input::key_pressed(VK_LBUTTON) && window_ctx.blocking == 0) {
        window_ctx.blocking = utils::hash::hash(id);
    }
    else if (active) {
        for (int i = 0; i < 256; i++) {
            if (utils::input::key_pressed(i)) {
                if (keys_list[i] != "Error")
                    value = i;

                window_ctx.blocking = 0;
            }
        }
    }

    window_ctx.render.emplace_back(zgui_control_render_t{{draw_pos.x + 4, draw_pos.y + 4}, zgui_render_type::zgui_text, global_colors.color_text, active ? "Press any key" : keys_list[value].data(), vec2{0, 0}, font});
    window_ctx.render.emplace_back(zgui_control_render_t{{draw_pos.x + 1, draw_pos.y + 1}, zgui_render_type::zgui_filled_rect, active ? global_colors.control_active_or_clicked : global_colors.control_idle, "", {control_width, control_height}});
    window_ctx.render.emplace_back(zgui_control_render_t{{draw_pos.x, draw_pos.y}, zgui_render_type::zgui_filled_rect, global_colors.control_outline, "", {control_width + 2, control_height + 2}});

    utils::misc::push_cursor_pos(vec2{cursor_pos.x + control_width + global_config.item_spacing, cursor_pos.y});
    utils::misc::push_cursor_pos(vec2{cursor_pos.x, cursor_pos.y + control_height / 2 + global_config.item_spacing + (inlined ? 0 : 12)});

    utils::misc::push_font(font);
}
// ========================================================================



// ========================================================================
void zgui::listbox(const char *id, std::vector<multi_select_item> items) {
    std::vector<std::string> id_split = utils::hash::split_str(id, '#');

    const int control_width = 100;
    const int control_height = 20;

    const unsigned long font = utils::misc::pop_font();

    const vec2 cursor_pos = utils::misc::pop_cursor_pos();
    vec2 draw_pos{window_ctx.position.x + cursor_pos.x, window_ctx.position.y + cursor_pos.y};

    const bool inlined = id_split[0].empty();

    if (!inlined) {
        int text_width, text_height;
        functions.get_text_size(font, id_split[0].c_str(), text_width, text_height);

        window_ctx.render.emplace_back(zgui_control_render_t{{draw_pos.x, draw_pos.y - 4}, zgui_render_type::zgui_text, global_colors.color_text, id_split[0], vec2{0, 0}, font});

        draw_pos.y += text_height;
    }

    for (int i = 1; i <= items.size(); i++) {
        const bool hovered = utils::input::mouse_in_region(draw_pos.x, draw_pos.y + (control_height - 1) * (i - 1), control_width, control_height);

        if (hovered && utils::input::key_pressed(VK_LBUTTON)) {
            window_ctx.blocking = 0;
            *items[i - 1].value = !*items[i - 1].value;
        }
        window_ctx.render.emplace_back(zgui_control_render_t{{draw_pos.x + 4, draw_pos.y + (control_height - 1) * (i - 1) + 4}, zgui_render_type::zgui_text, *items[i - 1].value || hovered ? global_colors.control_active_or_clicked : global_colors.color_text, items[i - 1].name.data(), vec2{0, 0}, font});
    }


    window_ctx.render.emplace_back(zgui_control_render_t{{draw_pos.x + 1, draw_pos.y + 1}, zgui_render_type::zgui_filled_rect, global_colors.control_idle, "", {control_width - 2, static_cast<float>(control_height * items.size() - 2)}});
    window_ctx.render.emplace_back(zgui_control_render_t{{draw_pos.x, draw_pos.y}, zgui_render_type::zgui_filled_rect, global_colors.control_outline, "", {control_width, static_cast<float>(control_height * items.size())}});

    utils::misc::push_cursor_pos(vec2{cursor_pos.x + control_width + global_config.item_spacing, cursor_pos.y});
    utils::misc::push_cursor_pos(vec2{cursor_pos.x, cursor_pos.y + control_height / 2 + global_config.item_spacing + (inlined ? 0 : 12) + control_height * (items.size() - 1)});

    if (const bool hovered = utils::input::mouse_in_region(draw_pos.x, draw_pos.y, control_width, control_height); hovered && utils::input::key_pressed(VK_LBUTTON) && window_ctx.blocking == 0) {
        window_ctx.blocking = utils::hash::hash(id);
    }

    utils::misc::push_font(font);
}
// ========================================================================

// ========================================================================
void zgui::slider_int(const char *id, const int min, const int max, int &value) {
    std::vector<std::string> id_split = utils::hash::split_str(id, '#');

    const unsigned long font = utils::misc::pop_font();

    const int control_width = 120;
    const int control_height = 10;

    const vec2 cursor_pos = utils::misc::pop_cursor_pos();
    vec2 draw_pos{window_ctx.position.x + cursor_pos.x + 14, window_ctx.position.y + cursor_pos.y};

    const bool inlined = id_split[0].empty();

    if (!inlined) {
        int text_width, text_height;
        functions.get_text_size(font, id_split[0].c_str(), text_width, text_height);

        window_ctx.render.emplace_back(zgui_control_render_t{{draw_pos.x, draw_pos.y - 4}, zgui_render_type::zgui_text, global_colors.color_text, id_split[0], vec2{0, 0}, font});

        draw_pos.y += text_height;
    }

    if (window_ctx.blocking == 0 && utils::input::mouse_in_region(draw_pos.x - (control_height - 2), draw_pos.y, 8, 10) && utils::input::key_pressed(VK_LBUTTON))
        value = std::clamp(value - 1, min, max);
    else if (window_ctx.blocking == 0 && utils::input::mouse_in_region(draw_pos.x + control_width, draw_pos.y, 8, 10) && utils::input::key_pressed(VK_LBUTTON))
        value = std::clamp(value + 1, min, max);

    if (const bool hovered = utils::input::mouse_in_region(draw_pos.x, draw_pos.y, control_width, control_height); hovered && utils::input::key_pressed(VK_LBUTTON) && window_ctx.blocking == 0) {
        window_ctx.blocking = utils::hash::hash(id);
    }
    else if (utils::input::key_down(VK_LBUTTON) && window_ctx.blocking == utils::hash::hash(id)) {
        float value_unmapped = std::clamp(mouse_pos.x - draw_pos.x, 0.0f, static_cast<float>(control_width));
        int value_mapped = static_cast<int>(value_unmapped / control_width * (max - min) + min);

        value = value_mapped;
    }
    else if (!utils::input::key_down(VK_LBUTTON) && window_ctx.blocking == utils::hash::hash(id)) {
        window_ctx.blocking = 0;
    }

    const int dynamic_width = (static_cast<float>(value) - min) / (max - min) * control_width - 2;

    int text_width, text_height;
    std::string value_str = std::to_string(value);
    functions.get_text_size(font, value_str.c_str(), text_width, text_height);

    int text_x = dynamic_width - text_width;

    if (text_x < 0)
        text_x = 0;

    window_ctx.render.emplace_back(zgui_control_render_t{{draw_pos.x - (control_height - 2), draw_pos.y - 2}, zgui_render_type::zgui_text, global_colors.color_text_dimmer, "-", vec2{0, 0}, font});
    window_ctx.render.emplace_back(zgui_control_render_t{{draw_pos.x + (control_width + 4), draw_pos.y - 2}, zgui_render_type::zgui_text, global_colors.color_text_dimmer, "+", vec2{0, 0}, font});
    window_ctx.render.emplace_back(zgui_control_render_t{{draw_pos.x + text_x, draw_pos.y}, zgui_render_type::zgui_text, global_colors.color_text, value_str, vec2{0, 0}, font});

    window_ctx.render.emplace_back(zgui_control_render_t{{draw_pos.x + 1, draw_pos.y + 1}, zgui_render_type::zgui_filled_rect, global_colors.color_slider, "", {static_cast<float>(dynamic_width), control_height - 2}});
    window_ctx.render.emplace_back(zgui_control_render_t{{draw_pos.x + 1, draw_pos.y + 1}, zgui_render_type::zgui_filled_rect, global_colors.control_idle, "", {control_width - 2, control_height - 2}});
    window_ctx.render.emplace_back(zgui_control_render_t{{draw_pos.x, draw_pos.y}, zgui_render_type::zgui_filled_rect, global_colors.control_outline, "", {control_width, control_height}});


    utils::misc::push_cursor_pos(vec2{cursor_pos.x + control_width + 14 + global_config.item_spacing, cursor_pos.y});
    utils::misc::push_cursor_pos(vec2{cursor_pos.x, cursor_pos.y + control_height / 2 + global_config.item_spacing + (inlined ? 0 : 12)});

    utils::misc::push_font(font);
}

// ========================================================================
void zgui::slider_float(const char *id, const float min, const float max, float &value) {
    std::vector<std::string> id_split = utils::hash::split_str(id, '#');

    const int control_width = 120;
    const int control_height = 10;

    const unsigned long font = utils::misc::pop_font();

    const vec2 cursor_pos = utils::misc::pop_cursor_pos();
    vec2 draw_pos{window_ctx.position.x + cursor_pos.x + 14, window_ctx.position.y + cursor_pos.y};

    const bool inlined = id_split[0].empty();

    if (!inlined) {
        int text_width, text_height;
        functions.get_text_size(font, id_split[0].c_str(), text_width, text_height);

        window_ctx.render.emplace_back(zgui_control_render_t{{draw_pos.x, draw_pos.y - 4}, zgui_render_type::zgui_text, global_colors.color_text, id_split[0], vec2{0, 0}, font});

        draw_pos.y += text_height;
    }

    if (window_ctx.blocking == 0 && utils::input::mouse_in_region(draw_pos.x - (control_height - 2), draw_pos.y, 8, 10) && utils::input::key_pressed(VK_LBUTTON))
        value = std::clamp(value - 1, min, max);
    else if (window_ctx.blocking == 0 && utils::input::mouse_in_region(draw_pos.x + control_width, draw_pos.y, 8, 10) && utils::input::key_pressed(VK_LBUTTON))
        value = std::clamp(value + 1, min, max);

    if (const bool hovered = utils::input::mouse_in_region(draw_pos.x, draw_pos.y, control_width, control_height); hovered && utils::input::key_pressed(VK_LBUTTON) && window_ctx.blocking == 0) {
        window_ctx.blocking = utils::hash::hash(id);
    }
    else if (utils::input::key_down(VK_LBUTTON) && window_ctx.blocking == utils::hash::hash(id)) {
        float value_unmapped = std::clamp(mouse_pos.x - draw_pos.x, 0.0f, static_cast<float>(control_width));
        float value_mapped = static_cast<float>((value_unmapped / static_cast<float>(control_width)) * (max - min) + min);

        value = value_mapped;
    }
    else if (!utils::input::key_down(VK_LBUTTON) && window_ctx.blocking == utils::hash::hash(id)) {
        window_ctx.blocking = 0;
    }

    const float dynamic_width = (static_cast<float>(value) - min) / (max - min) * control_width - 2;

    int text_width, text_height;
    std::stringstream ss;
    ss << std::fixed << std::setprecision(2) << value;
    std::string value_str = ss.str();
    functions.get_text_size(font, value_str.c_str(), text_width, text_height);

    int text_x = dynamic_width - text_width;

    if (text_x < 0)
        text_x = 0;

    window_ctx.render.emplace_back(zgui_control_render_t{{draw_pos.x - (control_height - 2), draw_pos.y - 2}, zgui_render_type::zgui_text, global_colors.color_text_dimmer, "-", vec2{0, 0}, font});
    window_ctx.render.emplace_back(zgui_control_render_t{{draw_pos.x + (control_width + 4), draw_pos.y - 2}, zgui_render_type::zgui_text, global_colors.color_text_dimmer, "+", vec2{0, 0}, font});
    window_ctx.render.emplace_back(zgui_control_render_t{{draw_pos.x + text_x, draw_pos.y}, zgui_render_type::zgui_text, global_colors.color_text, value_str, vec2{0, 0}, font});

    window_ctx.render.emplace_back(zgui_control_render_t{{draw_pos.x + 1, draw_pos.y + 1}, zgui_render_type::zgui_filled_rect, global_colors.color_slider, "", {dynamic_width, control_height - 2}});
    window_ctx.render.emplace_back(zgui_control_render_t{{draw_pos.x + 1, draw_pos.y + 1}, zgui_render_type::zgui_filled_rect, global_colors.control_idle, "", {control_width - 2, control_height - 2}});
    window_ctx.render.emplace_back(zgui_control_render_t{{draw_pos.x, draw_pos.y}, zgui_render_type::zgui_filled_rect, global_colors.control_outline, "", {control_width, control_height}});


    utils::misc::push_cursor_pos(vec2{cursor_pos.x + control_width + 14 + global_config.item_spacing, cursor_pos.y});
    utils::misc::push_cursor_pos(vec2{cursor_pos.x, cursor_pos.y + control_height / 2 + global_config.item_spacing + (inlined ? 0 : 12)});

    utils::misc::push_font(font);
}
// ========================================================================

// ========================================================================
bool zgui::clickable_text(const char *id) {
    std::vector<std::string> id_split = utils::hash::split_str(id, '#');

    const unsigned long font = utils::misc::pop_font();

    const vec2 cursor_pos = utils::misc::pop_cursor_pos();
    const vec2 draw_pos{window_ctx.position.x + cursor_pos.x, window_ctx.position.y + cursor_pos.y};

    int text_width, text_height;
    functions.get_text_size(font, id_split[0].c_str(), text_width, text_height);

    const bool active = window_ctx.blocking == utils::hash::hash(id);
    const bool hovered = utils::input::mouse_in_region(draw_pos.x, draw_pos.y, text_width, text_height);

    window_ctx.render.emplace_back(zgui_control_render_t{{draw_pos.x, draw_pos.y}, zgui_render_type::zgui_text, (hovered || window_ctx.blocking == utils::hash::hash(id)) ? global_colors.control_active_or_clicked : global_colors.color_text, id_split[0], vec2{0, 0}, font});

    utils::misc::push_cursor_pos(vec2{cursor_pos.x + text_width + global_config.item_spacing, cursor_pos.y});
    utils::misc::push_cursor_pos(vec2{cursor_pos.x, cursor_pos.y + text_height / 2 + global_config.item_spacing});

    bool result = false;

    if (!active && hovered && utils::input::key_pressed(VK_LBUTTON)) {
        window_ctx.blocking = utils::hash::hash(id);
    }
    else if (active && !utils::input::key_down(VK_LBUTTON)) {
        window_ctx.blocking = 0;
        result = hovered;
    }

    utils::misc::push_font(font);

    return result;
}

// ========================================================================
void zgui::text(const char *text) {
    const unsigned long font = utils::misc::pop_font();

    const vec2 cursor_pos = utils::misc::pop_cursor_pos();
    const vec2 draw_pos{window_ctx.position.x + cursor_pos.x, window_ctx.position.y + cursor_pos.y};

    int text_width, text_height;
    functions.get_text_size(font, text, text_width, text_height);

    window_ctx.render.emplace_back(zgui_control_render_t{{draw_pos.x, draw_pos.y}, zgui_render_type::zgui_text, global_colors.color_text, text, vec2{0, 0}, font});

    utils::misc::push_cursor_pos(vec2{cursor_pos.x + text_width + global_config.item_spacing, cursor_pos.y});
    utils::misc::push_cursor_pos(vec2{cursor_pos.x, cursor_pos.y + text_height / 2 + global_config.item_spacing});

    utils::misc::push_font(font);
}
// ========================================================================

// ========================================================================
bool zgui::text_input(const char *id, std::string &value, const int max_length, const int flags) {
    std::vector<std::string> id_split = utils::hash::split_str(id, '#');

    const int control_width = 80;
    const int control_height = 20;

    const unsigned long font = utils::misc::pop_font();

    const vec2 cursor_pos = utils::misc::pop_cursor_pos();
    vec2 draw_pos{window_ctx.position.x + cursor_pos.x + 14, window_ctx.position.y + cursor_pos.y};

    const bool inlined = id_split[0].empty();

    if (!inlined) {
        int text_width, text_height;
        functions.get_text_size(font, id_split[0].c_str(), text_width, text_height);

        window_ctx.render.emplace_back(zgui_control_render_t{{draw_pos.x, draw_pos.y - 4}, zgui_render_type::zgui_text, global_colors.color_text, id_split[0], vec2{0, 0}, font});

        draw_pos.y += text_height;
    }

    const bool active = window_ctx.blocking == utils::hash::hash(id);
    const bool hovered = utils::input::mouse_in_region(draw_pos.x, draw_pos.y, control_width, control_height);

    bool input = false;

    if (hovered && utils::input::key_pressed(VK_LBUTTON) && !active) {
        window_ctx.blocking = utils::hash::hash(id);
    }
    else if (active) {
        if (utils::input::key_pressed(VK_ESCAPE) || utils::input::key_pressed(VK_RETURN) || (!hovered && utils::input::key_pressed(VK_LBUTTON))) {
            window_ctx.blocking = 0;
        }
        else if (utils::input::key_pressed(VK_BACK) && !value.empty()) {
            value.pop_back();
        }
        else if (value.length() < max_length) {
            for (int i = 32; i <= 222; i++) {
                if ((i > 32 && i < 48) || (i > 57 && i < 65) || (i > 90 && i < 186))
                    continue;

                if (i > 57 && i <= 90) {
                  if (utils::input::key_pressed(i)) {
                    value += utils::input::key_down(VK_SHIFT) ? static_cast<char>(i) : static_cast<char>(i + 32);
                    input = true;
                  }
                }
                else {
                    if (utils::input::key_pressed(i)) {
                        for (int j = 0; j < sizeof(special_characters); j++) {
                          if (special_characters[j].vk == i) {
                            value += utils::input::key_down(VK_SHIFT) ? special_characters[j].shift : special_characters[j].regular;
                            input = true;
                          }
                        }
                    }
                }
            }
        }
    }

    window_ctx.render.emplace_back(zgui_control_render_t{{draw_pos.x + 4, draw_pos.y + 4}, zgui_render_type::zgui_text, global_colors.color_text, flags & zgui_text_input_flags_password ? std::string(value.length(), '*').c_str() : value.c_str(), vec2{0, 0}, font});
    window_ctx.render.emplace_back(zgui_control_render_t{{draw_pos.x + 1, draw_pos.y + 1}, zgui_render_type::zgui_filled_rect, active ? global_colors.control_active_or_clicked : global_colors.control_idle, "", {control_width - 2, control_height - 2}});
    window_ctx.render.emplace_back(zgui_control_render_t{{draw_pos.x, draw_pos.y}, zgui_render_type::zgui_filled_rect, global_colors.control_outline, "", {control_width, control_height}});

    utils::misc::push_cursor_pos(vec2{cursor_pos.x + control_width + global_config.item_spacing, cursor_pos.y});
    utils::misc::push_cursor_pos(vec2{cursor_pos.x, cursor_pos.y + control_height / 2 + global_config.item_spacing + (inlined ? 0 : 12)});

    utils::misc::push_font(font);

    return input;
}
// ========================================================================

// ========================================================================
void zgui::toggle_button(const char *id, const vec2 size, bool &value) {
    std::vector<std::string> id_split = utils::hash::split_str(id, '#');

    const unsigned long font = utils::misc::pop_font();

    const vec2 cursor_pos = utils::misc::pop_cursor_pos();
    const vec2 draw_pos{window_ctx.position.x + cursor_pos.x, window_ctx.position.y + cursor_pos.y};

    const bool active = window_ctx.blocking == utils::hash::hash(id);

    if (const bool hovered = utils::input::mouse_in_region(draw_pos.x, draw_pos.y, size.x, size.y); !active && hovered && utils::input::key_pressed(VK_LBUTTON)) {
        window_ctx.blocking = utils::hash::hash(id);
    }
    else if (active && !utils::input::key_down(VK_LBUTTON)) {
        window_ctx.blocking = 0;
        value = !value;
    }

    int text_width, text_height;
    functions.get_text_size(font, id_split[0].c_str(), text_width, text_height);

    window_ctx.render.emplace_back(zgui_control_render_t{{draw_pos.x + size.x / 2 - text_width / 2, draw_pos.y + size.y / 2 - text_height / 2}, zgui_render_type::zgui_text, global_colors.color_text, id_split[0], vec2{0, 0}, font});
    window_ctx.render.emplace_back(zgui_control_render_t{{draw_pos.x + 1, draw_pos.y + 1}, zgui_render_type::zgui_filled_rect, value ? global_colors.control_active_or_clicked : global_colors.control_idle, "", size});
    window_ctx.render.emplace_back(zgui_control_render_t{{draw_pos.x, draw_pos.y}, zgui_render_type::zgui_filled_rect, global_colors.control_outline, "", {size.x + 2, size.y + 2}});

    utils::misc::push_cursor_pos(vec2{cursor_pos.x + size.x + global_config.item_spacing, cursor_pos.y});
    utils::misc::push_cursor_pos(vec2{cursor_pos.x, cursor_pos.y + size.y / 2 + global_config.item_spacing});

    utils::misc::push_font(font);
}
// ========================================================================

// ========================================================================
bool zgui::begin_window(std::string_view title, const vec2 default_size, const unsigned long font, const int flags) {

    if (!input_loop_started)
        throw std::exception("Input loop didnt start or didnt start properly.");;

    if (!(flags & zgui_window_flags_always_open)) {
        if (utils::input::key_pressed(global_config.menu_toggle_key))
            window_ctx.opened = !window_ctx.opened;
    }
    else
        window_ctx.opened = true;

    if (const int prev_alpha = window_ctx.alpha; !(flags & zgui_window_flags_no_ontoggle_animation)) {
        const int fade_factor = static_cast<int>(1.0f / 0.15f * functions.get_frametime() * 255);
        window_ctx.alpha = std::clamp(window_ctx.alpha + (window_ctx.opened ? fade_factor : -fade_factor), 0, 255);

        if (window_ctx.alpha != prev_alpha) {
            global_colors.window_border_inner_fill.a = window_ctx.alpha;
            global_colors.window_border_fill.a = window_ctx.alpha;
            global_colors.window_border_color.a = window_ctx.alpha;
            global_colors.window_background.a = window_ctx.alpha;

            global_colors.control_outline.a = window_ctx.alpha;
            global_colors.control_active_or_clicked.a = window_ctx.alpha;
            global_colors.control_idle.a = window_ctx.alpha;

            global_colors.color_groupbox_bg.a = window_ctx.alpha;
            global_colors.color_text.a = window_ctx.alpha;
            global_colors.color_text_dimmer.a = window_ctx.alpha;
            global_colors.color_slider.a = window_ctx.alpha;
        }
    }

    if (window_ctx.opened || window_ctx.alpha > 0) {
        if (!(flags & zgui_window_flags_no_move)) {
            if ((flags & zgui_window_flags_no_border ? utils::input::mouse_in_region(window_ctx.position.x + 9, window_ctx.position.y + 14, window_ctx.size.x - 18, 14)
                                                     : utils::input::mouse_in_region(window_ctx.position.x - 6, window_ctx.position.y - 10, window_ctx.size.x + 12, 16))
                && utils::input::key_pressed(VK_LBUTTON) && !window_ctx.dragging) {
                window_ctx.dragging = true;
            }
            else if (utils::input::key_down(VK_LBUTTON) && window_ctx.dragging) {
                const vec2 mouse_delta{mouse_pos.x - previous_mouse_pos.x, mouse_pos.y - previous_mouse_pos.y};
                const vec2 new_position{window_ctx.position.x + mouse_delta.x, window_ctx.position.y + mouse_delta.y};

                window_ctx.position = new_position;
            }
            else if (!utils::input::key_down(VK_LBUTTON) && window_ctx.dragging) {
                window_ctx.dragging = false;
            }
        }

        if (window_ctx.size.x < 1 && window_ctx.size.y < 1)
            window_ctx.size = default_size;

        render::drawGradiant(window_ctx.position.x, window_ctx.position.y, window_ctx.size.x, window_ctx.size.y, menu::lightTop, menu::lightBottom, menu::alphaBackground, false);
        render::drawGradiant(window_ctx.position.x + menu::lineSize, window_ctx.position.y + menu::lineSize, window_ctx.size.x - (menu::lineSize * 2), window_ctx.size.y - (menu::lineSize * 2), menu::mainTop, menu::mainBottom, menu::alphaBackground, false);

        menu::logo.m_bgColor.SetAlpha(menu::alphaBackground);
        menu::logo.Draw(window_ctx.position.x + menu::spaceSize, window_ctx.position.y + menu::spaceSize + 22);

        render::drawRectangle(window_ctx.position.x + menu::spaceSize, window_ctx.position.y + menu::spaceSize + menu::tabSpaceSize, window_ctx.size.x - (menu::spaceSize * 2), window_ctx.size.y - (menu::spaceSize * 2) - menu::tabSpaceSize, menu::mainTabLight);

        render::drawRectangle(window_ctx.position.x + menu::spaceSize + menu::tabIconX, window_ctx.position.y + menu::spaceSize, (76 * 4) + (menu::lineSize * 2), 80, menu::mainTabLight);

        render::drawRectangle(window_ctx.position.x + menu::spaceSize + menu::lineSize, window_ctx.position.y + menu::spaceSize + menu::tabSpaceSize + menu::lineSize, window_ctx.size.x - (menu::spaceSize * 2) - (menu::lineSize * 2), window_ctx.size.y - (menu::spaceSize * 2) - menu::tabSpaceSize - (menu::lineSize * 2), menu::mainTab);


        /*
        if (!(flags & zgui_window_flags_no_border)) {
            functions.draw_filled_rect(window_ctx.position.x - 6, window_ctx.position.y - 10, window_ctx.size.x + 12, window_ctx.size.y + 16, global_colors.window_border_inner_fill);
            functions.draw_filled_rect(window_ctx.position.x - 5, window_ctx.position.y - 9, window_ctx.size.x + 10, window_ctx.size.y + 14, global_colors.window_border_color);
            functions.draw_filled_rect(window_ctx.position.x - 4, window_ctx.position.y - 8, window_ctx.size.x + 8, window_ctx.size.y + 12, global_colors.window_border_fill);
            functions.draw_filled_rect(window_ctx.position.x, window_ctx.position.y + 7, window_ctx.size.x, window_ctx.size.y - 7, global_colors.window_border_color);
            functions.draw_filled_rect(window_ctx.position.x + 1, window_ctx.position.y + 8, window_ctx.size.x - 2, window_ctx.size.y - 9, global_colors.window_border_inner_fill);
            functions.draw_filled_rect(window_ctx.position.x + 8, window_ctx.position.y + 15, window_ctx.size.x - 16, window_ctx.size.y - 23, global_colors.window_border_color);
        }

        if (!(flags & zgui_window_flags_no_titlebar))
            functions.draw_text(window_ctx.position.x + window_ctx.size.x * 0.5, window_ctx.position.y + (window_ctx.size.y * 0.010) - 10, global_colors.color_text, font, true, title.data());

        functions.draw_filled_rect(window_ctx.position.x + 9, window_ctx.position.y + 16, window_ctx.size.x - 18, window_ctx.size.y - 25, global_colors.window_background);
        */

        utils::misc::push_font(font);
        utils::misc::push_cursor_pos(global_config.base_pos);
    }

    return window_ctx.opened || window_ctx.alpha > 0;
}

// ========================================================================
void zgui::end_window() {
    for (int i = window_ctx.render.size() - 1; i >= 0; i--) {
        switch (window_ctx.render[i].render_type) {
            case zgui_render_type::zgui_line:
                functions.draw_line(window_ctx.render[i].draw_position.x, window_ctx.render[i].draw_position.y, window_ctx.render[i].size.x, window_ctx.render[i].size.y, window_ctx.render[i].color);
                break;
            case zgui_render_type::zgui_rect:
                functions.draw_rect(window_ctx.render[i].draw_position.x, window_ctx.render[i].draw_position.y, window_ctx.render[i].size.x, window_ctx.render[i].size.y, window_ctx.render[i].color);
                break;
            case zgui_render_type::zgui_filled_rect:
                functions.draw_filled_rect(window_ctx.render[i].draw_position.x, window_ctx.render[i].draw_position.y, window_ctx.render[i].size.x, window_ctx.render[i].size.y, window_ctx.render[i].color);
                break;
            case zgui_render_type::zgui_text:
                functions.draw_text(window_ctx.render[i].draw_position.x, window_ctx.render[i].draw_position.y, window_ctx.render[i].color, window_ctx.render[i].font, false, window_ctx.render[i].text.c_str());
                break;
        }
    }

    window_ctx.render.clear();

    while (!window_ctx.cursor_pos.empty())
        window_ctx.cursor_pos.pop();
}
// ========================================================================

// ========================================================================
void zgui::dummy() {
    const vec2 cursor_pos = utils::misc::pop_cursor_pos();
    utils::misc::push_cursor_pos(vec2{cursor_pos.x, cursor_pos.y + global_config.item_spacing});
}

// ========================================================================
void zgui::next_column(const int pusher_x, const int pusher_y) {
    const vec2 cursor_pos = utils::misc::pop_cursor_pos();
    vec2 new_cursor_pos{cursor_pos.x + pusher_x, global_config.base_pos.y + pusher_y};

    if (window_ctx.next_cursor_pos.y != 0)
        new_cursor_pos.y += 14;

    utils::misc::push_cursor_pos(new_cursor_pos);
}

// ========================================================================
void zgui::same_line(const float x_axis) {
    const vec2 cursor_pos = utils::misc::pop_cursor_pos();

    if (x_axis != -1)
        utils::misc::push_cursor_pos(vec2{global_config.base_pos.x + x_axis, cursor_pos.x});
}

// ========================================================================
void zgui::backup_line() {
    const vec2 cursor_pos = utils::misc::pop_cursor_pos();

    utils::misc::push_cursor_pos(vec2{window_ctx.next_cursor_pos.x, cursor_pos.y});
}
// ========================================================================

// ========================================================================
std::vector<std::string> zgui::utils::hash::split_str(const char *str, const char separator) {
    std::vector<std::string> output;
    std::string substring;
    std::istringstream stream{str};

    while (std::getline(stream, substring, separator))
        output.push_back(substring);

    return output;
}

// ========================================================================
uint32_t zgui::utils::hash::hash(const char *str, const uint32_t value) {
    return *str ? hash(str + 1, (value ^ *str) * 0x1000193ull) : value;
}
// ========================================================================

// ========================================================================
// Function for starting our input loop.
void zgui::poll_input(std::string_view window_name) {
    if (window_name.empty())
        throw std::exception("No window from where input should be read from specified in function parameter.");

    for (int i = 0; i < 256; i++) {
        prev_key_state[i] = key_state[i];
        key_state[i] = GetAsyncKeyState(i);
    }

    POINT p_mouse_pos;
    GetCursorPos(&p_mouse_pos);
    ScreenToClient(FindWindowA(nullptr, window_name.data()), &p_mouse_pos);
    previous_mouse_pos = mouse_pos;
    mouse_pos = vec2{static_cast<float>(p_mouse_pos.x), static_cast<float>(p_mouse_pos.y)};

    if (!input_loop_started)
        input_loop_started = true;
}

// ========================================================================
// Function for starting our input loop.
void zgui::poll_input(HWND hwnd) {
    if (!hwnd)
        throw std::exception("No window from where input should be read from specified in function parameter.");

    for (int i = 0; i < 256; i++) {
        prev_key_state[i] = key_state[i];
        key_state[i] = GetAsyncKeyState(i);
    }

    POINT p_mouse_pos;
    GetCursorPos(&p_mouse_pos);
    ScreenToClient(hwnd, &p_mouse_pos);
    previous_mouse_pos = mouse_pos;

    mouse_pos = vec2{static_cast<float>(p_mouse_pos.x), static_cast<float>(p_mouse_pos.y)};

    if (!input_loop_started)
        input_loop_started = true;
}

// ========================================================================
bool zgui::utils::input::key_pressed(const int key) {
    return key_state[key] && !prev_key_state[key];
}

// ========================================================================
bool zgui::utils::input::key_down(const int key) {
    return key_state[key];
}

// ========================================================================
bool zgui::utils::input::key_released(const int key) {
    return !key_state[key] && prev_key_state[key];
}

// ========================================================================
// Check if mouse is hovered over specified region.
bool zgui::utils::input::mouse_in_region(const int x, const int y, const int w, const int h) {
    return mouse_pos.x > x && mouse_pos.y > y && mouse_pos.x < w + x && mouse_pos.y < h + y;
}
// ========================================================================

// ========================================================================
// Push cursor position to the stack defined in window context.
void zgui::utils::misc::push_cursor_pos(const vec2 pos) {
    window_ctx.cursor_pos.push(pos);
}

// ========================================================================
// Pop cursor position from the stack defined in window context.
zgui::vec2 zgui::utils::misc::pop_cursor_pos() {
    const vec2 pos = window_ctx.cursor_pos.top();
    window_ctx.cursor_pos.pop();
    return pos;
}

// ========================================================================
// Pop font from the stack defined in window context.
void zgui::utils::misc::push_font(const unsigned long font) {
    window_ctx.fonts.push(font);
}

// ========================================================================
// Push font to the stack defined in window context.
unsigned long zgui::utils::misc::pop_font() {
    const unsigned long font = window_ctx.fonts.top();
    window_ctx.fonts.pop();
    return font;
}
// ========================================================================
```

`Lumina/Lumina/ui/zgui/dist/zgui.hh`:

```hh
#pragma once

#include <cstdint>
#include <stack>
#include <vector>
#include <string>
#include <string_view>
#include <type_traits>
#include <windows.h>
#include <algorithm>
#include <iomanip>
#include <sstream>

#include "../../menu.h"

#define ZGUI_API //__declspec(dllexport)

// zgui by zxvnme (https://github.com/zxvnme) and all the community contributors
#define ZGUI_VER "1.4.9" // the number after second dot is snapshot version.
/* =============================[general]===============================
 *
 * zgui is an simple framework created to help people with GUI rendering during their game hacking (but not only) journey.
 * here is glance zgui feature presentation:
 *	- easy to use immediate mode rendering (all you need is to include zgui header and source files to your project).
 *	- simple and aesthetic design.
 *	- extensible code.
 *	... and function documentation in section below:
 *
 *    ================================[pseudo documentation]=====================================
 *
 *    get_functions()
 *      -- function that is used to get our wrapped ones.
 *
 *    begin_window(std::string_view title, vec2 default_size, unsigned long font, int flags);
 *    end_window();
 *      -- functions used to create and end window.
 *
 *    begin_groupbox(std::string_view name, vec2 size);
 *    end_groupbox();
 *      -- functions uses to create our groupbox with desired size and end it.
 *
 *    slider_int(std::string_view id, int min, int max, int* value);
 *    slider_float(std::string_view id, float min, float max, float* value);
 *      -- functions used to create sliders with value type described in function name.
 *
 *    combobox(std::string_view id, std::vector<std::string> items, int* value);
 *    multi_combobox(std::string id, std::vector<multi_select_item> items)
 *      -- functions used for creating combo boxes.
 *
 *    checkbox(std::string_view id, bool* value);
 *      -- function that creates checkbox.
 *
 *    toggle_button(std::string_view id, vec2 size, bool* value);
 *      -- function that creates toggle button.
 *
 *    button(std::string_view id, vec2 size);
 *      -- function that creates button.
 *
 *    key_bind(std::string_view id, int* value);
 *      -- function that creates key binder.
 *
 *    text_input(std::string_view id, std::string* value, int max_length = 18);
 *      -- functions that creates text input box.
 *
 *    clickable_text(std::string_view text);
 *      -- function that creates text that can be clicked and eventually perform an action.
 *
 *    text(std::string_view text);
 *      -- function that creates text.
 *
 *    dummy();
 *      -- function that pushes cursor_pos.x to make empty space between our controls.
 *
 *    same_line(float x_axis = -1);
 *    backup_line();
 *      -- functions used for inline controls positioning. NOTE: there can be only one item between these two functions called.
 *
 *    ================================[hashing controls names]================================
 *
 *    the '#' thing in control name is separator that splits our name to two elements; actual displayed name & the one that is "hidden"
 *
 *    bad example:
 *      zgui::button("button", { 120, 30 });
 *      zgui::button("button", { 120, 30 });
 *
 *    code above won't work correctly because of same name provided. (known consequence is clicking 2 buttons at once)
 *
 *    good example:
 *      zgui::button("button#button_1", { 120, 30 });
 *      zgui::button("button#button_2", { 120, 30 });
 *
 *    and now, code above works fine because unique id (used in window input blocking) is provided after '#'
 *
 *    ==================================[input handling]======================================
 *
 *    IMPORTANT NOTE: poll_input(); HAS to be called before everything. Otherwise zgui will throw an exception or won't work properly.
 *
 *    poll_input("type_your_window_name") is function used to start reading input from window we specify in function parameter (string_view)
 *
 *    bad example:
 *      zgui::poll_input("");
 *      ... not calling this before whole zgui :)
 *
 *    code above won't work correctly because window name string_view size is equal to 0.
 *
 *    good example:
 *      zgui::poll_input("zgui directx9 example");
 *      zgui::poll_input("Minecraft 1.8.9");
 *
 *    and now, code above will work fine if your window titles are "zgui directx9 example" or "Minecraft 1.8.9"
 *
 *    ================================================================================================
 *
 * ================================================================================================
*/

// For examples and function descriptions see zgui header file.
namespace zgui {
    // Multi selectable item.
    struct multi_select_item {
      std::string_view name;
      bool* value;
    };
    // Two dimensional vector.
    struct vec2 {
      float x, y;
    };
    // Color with 4 paremeters; red, green, blue and alpha.
    struct color {
      int r, g, b, a;

      constexpr color& FromHSV(float h, float s, float v)
      {
        float colOut[3]{ };
        if (s == 0.0f)
        {
          r = g = b = static_cast<int>(v * 255);
          return *this;
        }

        h = std::fmodf(h, 1.0f) / (60.0f / 360.0f);
        int   i = static_cast<int>(h);
        float f = h - static_cast<float>(i);
        float p = v * (1.0f - s);
        float q = v * (1.0f - s * f);
        float t = v * (1.0f - s * (1.0f - f));

        switch (i)
        {
        case 0:
          colOut[0] = v;
          colOut[1] = t;
          colOut[2] = p;
          break;
        case 1:
          colOut[0] = q;
          colOut[1] = v;
          colOut[2] = p;
          break;
        case 2:
          colOut[0] = p;
          colOut[1] = v;
          colOut[2] = t;
          break;
        case 3:
          colOut[0] = p;
          colOut[1] = q;
          colOut[2] = v;
          break;
        case 4:
          colOut[0] = t;
          colOut[1] = p;
          colOut[2] = v;
          break;
        case 5: default:
          colOut[0] = v;
          colOut[1] = p;
          colOut[2] = q;
          break;
        }

        r = static_cast<int>(colOut[0] * 255);
        g = static_cast<int>(colOut[1] * 255);
        b = static_cast<int>(colOut[2] * 255);
        return *this;
      }
    };

    /// "Proxy" functions definitions.
    using line_t = std::add_pointer_t<void(int x, int y, int x2, int y2, color color) noexcept>;
    using rect_t = std::add_pointer_t<void(int x, int y, int x2, int y2, color color) noexcept>;
    using filled_rect_t = std::add_pointer_t<void(int x, int y, int x2, int y2, color color) noexcept>;
    using text_t = std::add_pointer_t<void(int x, int y, color color, int font, bool center, const char *text) noexcept>;
    using get_text_size_t = std::add_pointer_t<void(unsigned long font, const char *text, int &width, int &height) noexcept>;
    using get_frametime = std::add_pointer_t<float() noexcept>;
    ///

    // "Proxy" functions stuff...
    struct functions_t {
      line_t draw_line;
      rect_t draw_rect;
      filled_rect_t draw_filled_rect;
      text_t draw_text;
      get_text_size_t get_text_size;
      get_frametime get_frametime;
    };
    extern functions_t functions;

    // Flags for window appereance and its behavior.
    // ex: (zgui_window_flags_no_border | zgui_window_flags_no_titlebar) will cause window to be borderless and without title bar.
    enum zgui_window_flags {
      zgui_window_flags_none = 0,
      zgui_window_flags_no_border = 1 << 0,
      zgui_window_flags_no_titlebar = 1 << 1,
      zgui_window_flags_no_ontoggle_animation = 1 << 2,
      zgui_window_flags_no_move = 1 << 3,
      zgui_window_flags_always_open = 1 << 4,
    };

    // Flags for text input appereance.
    // ex: (zgui_text_input_flags_password) will convert text input (ex: "abcdef") to "******".
    enum zgui_text_input_flags {
      zgui_text_input_flags_none = 0,
      zgui_text_input_flags_password = 1 << 0
    };

    // Flags for groupboxes appereance.
    // ex: (zgui_groupbox_flags_title_centered) will center align title of groupbox.
    enum zgui_groupbox_flags {
      zgui_groupbox_flags_none = 0,
      zgui_groupbox_flags_legacy_design = 1 << 0,
    };

    enum class zgui_render_type {
      zgui_line = 1,
      zgui_rect,
      zgui_filled_rect,
      zgui_text
    };

    struct zgui_control_render_t {
      vec2 draw_position;
      zgui_render_type render_type;
      color color;
      std::string text;
      vec2 size;
      unsigned long font = 0;
    };

    struct gui_window_context_t {
      uint32_t blocking;
      std::stack<vec2> cursor_pos;
      std::stack<unsigned long> fonts;
      std::vector<zgui_control_render_t> render;
      vec2 position, size;
      vec2 next_cursor_pos;
      bool dragging;
      bool opened;
      int alpha;
    };

    struct key_code_info {
      int vk;

      char regular;
      char shift;
    };

    namespace globals {

        constexpr std::string_view keys_list[]{
                "Error", "Left Mouse", "Right Mouse", "Break", "Middle Mouse", "Mouse 4", "Mouse 5",
                "Error", "Backspace", "TAB", "Error", "Error", "Error", "ENTER", "Error", "Error", "SHIFT",
                "CTRL", "ALT", "PAUSE", "CAPS LOCK", "Error", "Error", "Error", "Error", "Error", "Error",
                "Error", "Error", "Error", "Error", "Error", "SPACEBAR", "PG UP", "PG DOWN", "END", "HOME", "Left",
                "Up", "Right", "Down", "Error", "Print", "Error", "Print Screen", "Insert", "Delete", "Error", "0", "1",
                "2", "3", "4", "5", "6", "7", "8", "9", "Error", "Error", "Error", "Error", "Error", "Error",
                "Error", "A", "B", "C", "D", "E", "F", "G", "H", "I", "J", "K", "L", "M", "N", "O", "P", "Q", "R", "S", "T", "U",
                "V", "W", "X", "Y", "Z", "Left Windows", "Right Windows", "Error", "Error", "Error", "NUM 0", "NUM 1",
                "NUM 2", "NUM 3", "NUM 4", "NUM 5", "NUM 6", "NUM 7", "NUM 8", "NUM 9", "*", "+", "_", "-", ".", "/", "F1", "F2", "F3",
                "F4", "F5", "F6", "F7", "F8", "F9", "F10", "F11", "F12", "F13", "F14", "F15", "F16", "F17", "F18", "F19", "F20", "F21",
                "F22", "F23", "F24", "Error", "Error", "Error", "Error", "Error", "Error", "Error", "Error",
                "NUM LOCK", "SCROLL LOCK", "Error", "Error", "Error", "Error", "Error", "Error", "Error",
                "Error", "Error", "Error", "Error", "Error", "Error", "Error", "LSHIFT", "RSHIFT", "LCONTROL",
                "RCONTROL", "LMENU", "RMENU", "Error", "Error", "Error", "Error", "Error", "Error", "Error",
                "Error", "Error", "Error", "Next Track", "Previous Track", "Stop", "Play/Pause", "Error", "Error",
                "Error", "Error", "Error", "Error", ";", "+", ",", "-", ".", "/?", "~", "Error", "Error",
                "Error", "Error", "Error", "Error", "Error", "Error", "Error", "Error", "Error",
                "Error", "Error", "Error", "Error", "Error", "Error", "Error", "Error", "Error",
                "Error", "Error", "Error", "Error", "Error", "Error", "[{", "\\|", "}]", "'\"", "Error",
                "Error", "Error", "Error", "Error", "Error", "Error", "Error", "Error", "Error",
                "Error", "Error", "Error", "Error", "Error", "Error", "Error", "Error", "Error",
                "Error", "Error", "Error", "Error", "Error", "Error", "Error", "Error", "Error",
                "Error", "Error"
        };

        static key_code_info special_characters[22] = {
                {48,  '0',  ')'},
                {49,  '1',  '!'},
                {50,  '2',  '@'},
                {51,  '3',  '#'},
                {52,  '4',  '$'},
                {53,  '5',  '%'},
                {54,  '6',  '^'},
                {55,  '7',  '&'},
                {56,  '8',  '*'},
                {57,  '9',  '('},
                {32,  ' ',  ' '},
                {192, '`',  '~'},
                {189, '-',  '_'},
                {187, '=',  '+'},
                {219, '[',  '{'},
                {220, '\\', '|'},
                {221, ']',  '}'},
                {186, ';',  ':'},
                {222, '\'', '"'},
                {188, ',',  '<'},
                {190, '.',  '>'},
                {191, '/',  '?'}
        };

        // Color definition. Can be changed at any time just simply by editing this struct.
        static struct {
          color window_border_inner_fill{60, 60, 60, 255};
          color window_border_fill{40, 40, 40, 255};
          color window_border_color{10, 10, 10, 255};
          color window_background{40, 40, 40, 255};

          color control_outline{23, 23, 30, 255};
          color control_active_or_clicked{108, 92, 231, 255};
          color control_idle{62, 62, 72, 255};

          color color_groupbox_bg{50, 50, 50, 255};
          color color_text{203, 203, 203, 255};
          color color_text_dimmer{99, 110, 114, 255};
          color color_slider{108, 92, 231, 255};
          color color_combo_bg{108, 92, 231, 255};
          color color_groupbox_header{26, 26, 26, 150};
        } global_colors;

        static struct {
          // Base position of first drawn control (px). DO NOT change if its necessary
          zgui::vec2 base_pos{ (float)menu::spaceSize + 20.0f,(float)(menu::spaceSize + menu::tabSpaceSize) + 22.0f };
          // Spacing between items (px)
          int item_spacing = 16;
          // Key that will toggle menu visibility unless zgui_window_flags_always_open is set
          int menu_toggle_key = VK_INSERT;
        } global_config;

        // Window definitions.
        extern gui_window_context_t window_ctx;

        // "Proxy" functions stuff...
        //inline zgui::functions_t zgui::functions;

        // Globals
        static vec2 mouse_pos;
        static vec2 previous_mouse_pos;

        // Input handling stuff
        static bool key_state[256];
        static bool prev_key_state[256];

        // Check for input polling.
        static bool input_loop_started = false;
    }

    // Start Input loop
    ZGUI_API void poll_input(std::string_view window_name);

    ZGUI_API void poll_input(HWND hwnd);

    namespace utils {
        namespace input {
            bool key_pressed(int key);

            bool key_down(int key);

            bool key_released(int key);

            bool mouse_in_region(int x, int y, int w, int h);

        }

        namespace hash {
            std::vector<std::string> split_str(const char *str, char separator);

            uint32_t hash(const char *str, uint32_t value = 0x811c9dc5);
        }

        namespace misc {
            ZGUI_API void push_cursor_pos(vec2 pos);

            ZGUI_API vec2 pop_cursor_pos();

            ZGUI_API void push_font(unsigned long font);

            ZGUI_API unsigned long pop_font();
        }

    }

    void setMousePos(float x, float y);

    void sendToClipboard(HWND hwnd, const std::string& s);

    ZGUI_API bool colorpicker(const char* id, zgui::color& item);

    ZGUI_API bool begin_window(std::string_view title, vec2 default_size, unsigned long font, int flags = 0);

    ZGUI_API void end_window();

    ZGUI_API void begin_groupbox(std::string_view title, vec2 size, int flags = 0);

    ZGUI_API void end_groupbox();

    ZGUI_API bool checkbox(const char *id, bool &value);

    ZGUI_API void toggle_button(const char *id, vec2 size, bool &value);

    ZGUI_API bool button(const char *id, vec2 size);

    ZGUI_API bool buttonWithPosition(const char *id, const vec2 size, const vec2 cursor_pos);

    ZGUI_API void key_bind(const char *id, int &value);

    ZGUI_API bool text_input(const char *id, std::string &value, int max_length = 16, int flags = 0);

    ZGUI_API void slider_int(const char *id, int min, int max, int &value);

    ZGUI_API void slider_float(const char *id, float min, float max, float &value);

    ZGUI_API bool combobox(const char *, std::vector<std::string> items, int &value);

    ZGUI_API void multi_combobox(const char *id, std::vector<multi_select_item> items);

    ZGUI_API void listbox(const char *id, std::vector<multi_select_item> items);

    ZGUI_API bool clickable_text(const char *id);

    ZGUI_API void text(const char *text);

    ZGUI_API void dummy();

    ZGUI_API void next_column(int pusher_x = 174, int pusher_y = 14);

    ZGUI_API void same_line(float x_axis = -1);

    ZGUI_API void backup_line();
}
```

`README.md`:

```md
![](Resources/logo.png)


![](Resources/preview_0.jpg)

# IMPORTANT UPDATE

Since people definitly don't know how to use this, things will change from now.

Why ? Because the non-mutated version of the cheat is now detected by AV's as HackTool:Win32/GameHack.*, this mean that the NON-MUTATED VERSION was injected using bad injectors in CSGO. But the point of the cheat is to use mutation to maintain a changing signature. If you don't know how to use it with VMProtect, you should not use it at all. Before trying to cheat in CSGO, you should know about computer science and game hacking in the first place before trying to be a l33t ch3at3r. If you are just a random kid that saw a video talking about cheats on yt, and you've downloaded VS to compile a cheat that you plan to modify to pretend it's our own one. You will be VACED because you don't even know how to properly use this kind of things.

Since the first upload, there are some anti-paste / anti-run in my cheat, but now I will make sure no one that want to cheat for bad purposes can do it without knowledge. If you are in RE or game hacking, it's not a big deal to avoid.

# What is it ?

This is the CSGO cheat I'm coding since 2018.

# Why ?

I've coded this because there are too many cheaters in this game. I'm angry that I can't do anything against cheaters with the vanila CSGO. So I'm cheating ONLY against cheaters.

# Is it detectable ?

Well.

The cheat by itself (the file, the code) is not "identifiable" because of code mutation. I'm using VMP mutation for every functions I made, and the compilation doesn't split that much the code regarding the mutation (at least with my current configuration).

So if you use it mutated on VAC protected servers, Steam anti cheat will not be able to find any known patterns because of code mutation. Even if VAC detect the module and send it to Valve's servers to "extract" sigatures, next time the cheat is compiled, its code signature will completly change (my functions). So VAC cannot identify the cheat by a code signature of my features. However, I use public code that could be flagged by VAC (JsonCpp, ZGUI, ...), but those codes are commonly used by legit softwares. And if VAC flag them, they will flag most of the overlay software too, so they don't do it. 

So let's summarize, the code signature is not detectable, is the cheat still detectable then ? YES

The first vector could be the DLL injection. In my case the CSGO process load by itself the crashhandler.dll, so the module is loaded before the installation of LoadLibrary and other hooks. But if the injection process is spotted by CSGO process, you will be VAC.

The second is to consider the "pattern" detection of the cheat. For exemple if VAC is now able to detect a feature of the cheat, no matter its implementation. You will be VAC, as well as skeet users when double tap was detected by CSGO. So maybe tomorow, the Faststop feature could be detected server side. 

I could continue my explanation for hours (string, data...) but I think you get the idea.

# Why do I release this then ?

Like I explained earlier, the point of being not detected regarding the code is highly liked to knowledge of VAC about it. So, more people use it, more chance that it's "detected", even if I use code mutation. 

But I've spend a lot of time working on this game, and I think it's now time to do release it as I'm not playing that much anymore.

# How to compile it ?

Compile in Release mode to be sure that the code is mutated. Modify the `sign.bat` file and set your VMProtect path and grab the last `crashhandler.dll` signature as `crashhandler.original.sig`.

# How to use ?

Place the `crashhandler.dll` file Steam's root folder. CSGO will load it before applying the LoadLibrary hook.

# Features

Like I said, it's a legit cheat, so features are meant to be hidden regarding overwatch. But it's depending of your own gameplay.

- Chams
    - Enemy (+through wall, +only if dead)
    - Backtrack
    - Hands and Steeves 
- Glow (+only if dead)
- Skin Changer (two slots, T and CT)
    - Weapon (paint, stickers, ...) 
    - Knife 
    - Local Model
    - Team Model
- ESP
    - Show only if dead
    - Box
    - Name
    - Weapon name
    - Life
    - Indicators (flash, scope, has defuser, has bomb, planting, defusing, ...)
- Grenade Prediction
- Radar
- Backtrack
- Misc
  - My Spread Circle + Crosshair (not the classic filled circle)
  - Hitmarker
  - Sounds on event (hitmarker, headshot, roundwon, roundlost, roundstart) 
  - Play event sounds through microphone (like SLAM)
  - Spectator List
  - Fast Stop
  - Silent Walk
  - Flash Timer
  - Infinit Duck
  - Vote revealer
- Exploits
  - Clear chat exploit to clipboard
  - Invisible vote initiator name 
- Bypasses
  - 3 Party Files
  - Signature Checks

# About the code

I made the cheat optimized, but there is one thing that is not looking good in all this project, the UI.

I started to made the UI from raw, but at the end I didn't want to put too much effort into it. So I used the zgui framework to handle it, and I didn't took the time to modify the gui, buttons and stuff. So the menu (the button and UI) are pretty huggly, but I prefer to work on features instead of loosing time on this.

It's why I don't provide screenshots of the menu.

# Preview video

[![](http://img.youtube.com/vi/PN5KUjSbEYw/0.jpg)](http://www.youtube.com/watch?v=PN5KUjSbEYw "")

# Logs

- 28-06-2021 v0.1.13
  - Fixed double chams bug through wall 
  - Added event sound playing through microphone
  - Added volume esp feature from NV_v2 made by ekknod
  - Added old Natacha features (infinit duck, clear chat exploit, invisible vote initiator name, vote revealer)
  - Improved the `crashhandler.dll` ripper (takes the according dates of crashhandler.original)
  - Improved some code parts
  - Added assets to the repo (player models, sounds, skyboxes)
- 10-03-2021 v0.1.12
  - Added a new way to grab interfaces since VAC monitors CreateInterface calls now [(see)](https://www.unknowncheats.me/forum/counterstrike-global-offensive/444181-vac-monitors-createinterface-calls.html#post3084991)
  - "Policy" update
  - Improved API resolver (export resolved from PEB, without GetProcAddress)
  - Improved execution speed of backtrack
  - Updated `crashhandler.dll` certificat
- 07-03-2021 v0.1.11 
  - Added old Natacha features 
  - Added chams overlay
  - Added backtrack and backtrack chams
  - Fix knife applied to spectators
- 19-02-2021 v0.1.10  
  - Fix knife animations
  - Fix hand chams bug
- 05-02-2021 v0.1.9  
  - Added hands and sleeves color changer
- 27-01-2021 v0.1.8  
  - Added world modulation and
  - Removed strcmp (using hash)
- 07-01-2021 v0.1.7 
  - Official release
- 14-09-2019 v0.1.0 
  - Merging Natacha project to Lumina project
- 05-06-2018 v0.0.0  
  - Starting the project

# Bugs

There is still a bug when you plant a bomb, sometimes it crashes but it's too rare, so I can't debug it.

# Credit

- Oneshot
- ekknod
- coders from weave.su
- coders from legendware
- fatality.win 2018 source code
- JsonCpp http://jsoncpp.sourceforge.net/
- zxvnme (zgui)
- coders from pandoracheats.pw
- Ferenc Deak, Sebastien Andrivet https://github.com/andrivet/ADVobfuscator
- Justas Masiulis https://github.com/JustasMasiulis/lazy_importer, https://github.com/JustasMasiulis/xorstr

```

`Resources/DT_BaseAttributableItem.log`:

```log

[DT_BaseAttributableItem]
AnimTimeMustBeFirst            = 0x0
m_flAnimTime                   = 0x260
m_flSimulationTime             = 0x268
m_cellbits                     = 0x74
m_cellX                        = 0x7C
m_cellY                        = 0x80
m_cellZ                        = 0x84
m_vecOrigin                    = 0x138
m_angRotation                  = 0x12C
m_nModelIndex                  = 0x258
m_fEffects                     = 0xF0
m_nRenderMode                  = 0x25B
m_nRenderFX                    = 0x25A
m_clrRender                    = 0x70
m_iTeamNum                     = 0xF4
m_iPendingTeamNum              = 0xF8
m_CollisionGroup               = 0x474
m_flElasticity                 = 0x300
m_flShadowCastDistance         = 0x3A0
m_hOwnerEntity                 = 0x14C
m_hEffectEntity                = 0x998
moveparent                     = 0x148
m_iParentAttachment            = 0x2EC
m_iName                        = 0x154
movetype                       = 0x0
movecollide                    = 0x0
m_Collision                    = 0x320
m_vecMins                      = 0x328
m_vecMaxs                      = 0x334
m_nSolidType                   = 0x342
m_usSolidFlags                 = 0x340
m_nSurroundType                = 0x34A
m_triggerBloat                 = 0x343
m_vecSpecifiedSurroundingMins  = 0x34C
m_vecSpecifiedSurroundingMaxs  = 0x358
m_iTextureFrameIndex           = 0x98C
m_bSimulatedEveryTick          = 0x93A
m_bAnimatedEveryTick           = 0x93B
m_bAlternateSorting            = 0x93C
m_bSpotted                     = 0x93D
m_bSpottedBy                   = 0x93E
000                            = 0x93E
001                            = 0x93F
002                            = 0x940
003                            = 0x941
004                            = 0x942
005                            = 0x943
006                            = 0x944
007                            = 0x945
008                            = 0x946
009                            = 0x947
010                            = 0x948
011                            = 0x949
012                            = 0x94A
013                            = 0x94B
014                            = 0x94C
015                            = 0x94D
016                            = 0x94E
017                            = 0x94F
018                            = 0x950
019                            = 0x951
020                            = 0x952
021                            = 0x953
022                            = 0x954
023                            = 0x955
024                            = 0x956
025                            = 0x957
026                            = 0x958
027                            = 0x959
028                            = 0x95A
029                            = 0x95B
030                            = 0x95C
031                            = 0x95D
032                            = 0x95E
033                            = 0x95F
034                            = 0x960
035                            = 0x961
036                            = 0x962
037                            = 0x963
038                            = 0x964
039                            = 0x965
040                            = 0x966
041                            = 0x967
042                            = 0x968
043                            = 0x969
044                            = 0x96A
045                            = 0x96B
046                            = 0x96C
047                            = 0x96D
048                            = 0x96E
049                            = 0x96F
050                            = 0x970
051                            = 0x971
052                            = 0x972
053                            = 0x973
054                            = 0x974
055                            = 0x975
056                            = 0x976
057                            = 0x977
058                            = 0x978
059                            = 0x979
060                            = 0x97A
061                            = 0x97B
062                            = 0x97C
063                            = 0x97D
064                            = 0x97E
m_bSpottedByMask               = 0x980
m_bIsAutoaimTarget             = 0x60
m_fadeMinDist                  = 0x2F4
m_fadeMaxDist                  = 0x2F8
m_flFadeScale                  = 0x2FC
m_nMinCPULevel                 = 0x988
m_nMaxCPULevel                 = 0x989
m_nMinGPULevel                 = 0x98A
m_nMaxGPULevel                 = 0x98B
m_flUseLookAtAngle             = 0x2CC
m_flLastMadeNoiseTime          = 0x20
m_flMaxFallVelocity            = 0xDC
m_bEligibleForScreenHighlight  = 0x9B9
m_nSequence                    = 0x28BC
m_nForceBone                   = 0x268C
m_vecForce                     = 0x2680
m_nSkin                        = 0xA1C
m_nBody                        = 0xA20
m_nHitboxSet                   = 0x9FC
m_flModelScale                 = 0x2748
m_flPoseParameter              = 0x2774
m_flPlaybackRate               = 0xA18
m_flEncodedController          = 0xA54
m_bClientSideAnimation         = 0x289C
m_bClientSideFrameReset        = 0x26C0
m_bClientSideRagdoll           = 0x279
m_nNewSequenceParity           = 0xA44
m_nResetEventsParity           = 0xA48
m_nMuzzleFlashParity           = 0xA64
m_hLightingOrigin              = 0x2944
serveranimdata                 = 0x0
m_flCycle                      = 0xA14
m_flFrozen                     = 0x26F8
m_ScaleType                    = 0x274C
m_bSuppressAnimSounds          = 0x294A
m_nHighlightColorR             = 0xA38
m_nHighlightColorG             = 0xA3C
m_nHighlightColorB             = 0xA40
m_AttributeManager             = 0x2D80
m_hOuter                       = 0x2D9C
m_ProviderType                 = 0x2DA4
m_iReapplyProvisionParity      = 0x2D98
m_Item                         = 0x2DC0
m_iItemDefinitionIndex         = 0x2FAA
m_iEntityLevel                 = 0x2FB0
m_iItemIDHigh                  = 0x2FC0
m_iItemIDLow                   = 0x2FC4
m_iAccountID                   = 0x2FC8
m_iEntityQuality               = 0x2FAC
m_bInitialized                 = 0x2FD4
m_szCustomName                 = 0x303C
m_NetworkedDynamicAttributesForDemos = 0x3020
m_Attributes                   = 0x3020
lengthproxy                    = 0x3020
lengthprop32                   = 0x3020
m_iAttributeDefinitionIndex    = 0x3024
m_iRawValue32                  = 0x3028
m_flValue                      = 0x3028
m_iRawInitialValue32           = 0x302C
m_nRefundableCurrency          = 0x3030
m_bSetBonus                    = 0x3034
m_OriginalOwnerXuidLow         = 0x31C0
m_OriginalOwnerXuidHigh        = 0x31C4
m_nFallbackPaintKit            = 0x31C8
m_nFallbackSeed                = 0x31CC
m_flFallbackWear               = 0x31D0
m_nFallbackStatTrak            = 0x31D4

```

`Resources/DT_BaseCombatWeapon.log`:

```log

[DT_BaseCombatWeapon]
AnimTimeMustBeFirst            = 0x0
m_flAnimTime                   = 0x260
m_flSimulationTime             = 0x268
m_cellbits                     = 0x74
m_cellX                        = 0x7C
m_cellY                        = 0x80
m_cellZ                        = 0x84
m_vecOrigin                    = 0x138
m_angRotation                  = 0x12C
m_nModelIndex                  = 0x258
m_fEffects                     = 0xF0
m_nRenderMode                  = 0x25B
m_nRenderFX                    = 0x25A
m_clrRender                    = 0x70
m_iTeamNum                     = 0xF4
m_iPendingTeamNum              = 0xF8
m_CollisionGroup               = 0x474
m_flElasticity                 = 0x300
m_flShadowCastDistance         = 0x3A0
m_hOwnerEntity                 = 0x14C
m_hEffectEntity                = 0x998
moveparent                     = 0x148
m_iParentAttachment            = 0x2EC
m_iName                        = 0x154
movetype                       = 0x0
movecollide                    = 0x0
m_Collision                    = 0x320
m_vecMins                      = 0x328
m_vecMaxs                      = 0x334
m_nSolidType                   = 0x342
m_usSolidFlags                 = 0x340
m_nSurroundType                = 0x34A
m_triggerBloat                 = 0x343
m_vecSpecifiedSurroundingMins  = 0x34C
m_vecSpecifiedSurroundingMaxs  = 0x358
m_iTextureFrameIndex           = 0x98C
m_bSimulatedEveryTick          = 0x93A
m_bAnimatedEveryTick           = 0x93B
m_bAlternateSorting            = 0x93C
m_bSpotted                     = 0x93D
m_bSpottedBy                   = 0x93E
000                            = 0x93E
001                            = 0x93F
002                            = 0x940
003                            = 0x941
004                            = 0x942
005                            = 0x943
006                            = 0x944
007                            = 0x945
008                            = 0x946
009                            = 0x947
010                            = 0x948
011                            = 0x949
012                            = 0x94A
013                            = 0x94B
014                            = 0x94C
015                            = 0x94D
016                            = 0x94E
017                            = 0x94F
018                            = 0x950
019                            = 0x951
020                            = 0x952
021                            = 0x953
022                            = 0x954
023                            = 0x955
024                            = 0x956
025                            = 0x957
026                            = 0x958
027                            = 0x959
028                            = 0x95A
029                            = 0x95B
030                            = 0x95C
031                            = 0x95D
032                            = 0x95E
033                            = 0x95F
034                            = 0x960
035                            = 0x961
036                            = 0x962
037                            = 0x963
038                            = 0x964
039                            = 0x965
040                            = 0x966
041                            = 0x967
042                            = 0x968
043                            = 0x969
044                            = 0x96A
045                            = 0x96B
046                            = 0x96C
047                            = 0x96D
048                            = 0x96E
049                            = 0x96F
050                            = 0x970
051                            = 0x971
052                            = 0x972
053                            = 0x973
054                            = 0x974
055                            = 0x975
056                            = 0x976
057                            = 0x977
058                            = 0x978
059                            = 0x979
060                            = 0x97A
061                            = 0x97B
062                            = 0x97C
063                            = 0x97D
064                            = 0x97E
m_bSpottedByMask               = 0x980
m_bIsAutoaimTarget             = 0x60
m_fadeMinDist                  = 0x2F4
m_fadeMaxDist                  = 0x2F8
m_flFadeScale                  = 0x2FC
m_nMinCPULevel                 = 0x988
m_nMaxCPULevel                 = 0x989
m_nMinGPULevel                 = 0x98A
m_nMaxGPULevel                 = 0x98B
m_flUseLookAtAngle             = 0x2CC
m_flLastMadeNoiseTime          = 0x20
m_flMaxFallVelocity            = 0xDC
m_bEligibleForScreenHighlight  = 0x9B9
m_nSequence                    = 0x28BC
m_nForceBone                   = 0x268C
m_vecForce                     = 0x2680
m_nSkin                        = 0xA1C
m_nBody                        = 0xA20
m_nHitboxSet                   = 0x9FC
m_flModelScale                 = 0x2748
m_flPoseParameter              = 0x2774
m_flPlaybackRate               = 0xA18
m_flEncodedController          = 0xA54
m_bClientSideAnimation         = 0x289C
m_bClientSideFrameReset        = 0x26C0
m_bClientSideRagdoll           = 0x279
m_nNewSequenceParity           = 0xA44
m_nResetEventsParity           = 0xA48
m_nMuzzleFlashParity           = 0xA64
m_hLightingOrigin              = 0x2944
serveranimdata                 = 0x0
m_flCycle                      = 0xA14
m_flFrozen                     = 0x26F8
m_ScaleType                    = 0x274C
m_bSuppressAnimSounds          = 0x294A
m_nHighlightColorR             = 0xA38
m_nHighlightColorG             = 0xA3C
m_nHighlightColorB             = 0xA40
overlay_vars                   = 0x0
m_AnimOverlay                  = 0x0
lengthproxy                    = 0x0
lengthprop15                   = 0x0
m_flPrevCycle                  = 0x1C
m_flWeight                     = 0x20
m_flWeightDeltaRate            = 0x24
m_nOrder                       = 0x14
m_flexWeight                   = 0x2A28
065                            = 0x2B2C
066                            = 0x2B30
067                            = 0x2B34
068                            = 0x2B38
069                            = 0x2B3C
070                            = 0x2B40
071                            = 0x2B44
072                            = 0x2B48
073                            = 0x2B4C
074                            = 0x2B50
075                            = 0x2B54
076                            = 0x2B58
077                            = 0x2B5C
078                            = 0x2B60
079                            = 0x2B64
080                            = 0x2B68
081                            = 0x2B6C
082                            = 0x2B70
083                            = 0x2B74
084                            = 0x2B78
085                            = 0x2B7C
086                            = 0x2B80
087                            = 0x2B84
088                            = 0x2B88
089                            = 0x2B8C
090                            = 0x2B90
091                            = 0x2B94
092                            = 0x2B98
093                            = 0x2B9C
094                            = 0x2BA0
095                            = 0x2BA4
m_blinktoggle                  = 0x2BD4
m_viewtarget                   = 0x29F0
m_AttributeManager             = 0x2D80
m_hOuter                       = 0x2D9C
m_ProviderType                 = 0x2DA4
m_iReapplyProvisionParity      = 0x2D98
m_Item                         = 0x2DC0
m_iItemDefinitionIndex         = 0x2FAA
m_iEntityLevel                 = 0x2FB0
m_iItemIDHigh                  = 0x2FC0
m_iItemIDLow                   = 0x2FC4
m_iAccountID                   = 0x2FC8
m_iEntityQuality               = 0x2FAC
m_bInitialized                 = 0x2FD4
m_szCustomName                 = 0x303C
m_NetworkedDynamicAttributesForDemos = 0x3020
m_Attributes                   = 0x3020
lengthprop32                   = 0x3020
m_iAttributeDefinitionIndex    = 0x3024
m_iRawValue32                  = 0x3028
m_flValue                      = 0x3028
m_iRawInitialValue32           = 0x302C
m_nRefundableCurrency          = 0x3030
m_bSetBonus                    = 0x3034
m_OriginalOwnerXuidLow         = 0x31C0
m_OriginalOwnerXuidHigh        = 0x31C4
m_nFallbackPaintKit            = 0x31C8
m_nFallbackSeed                = 0x31CC
m_flFallbackWear               = 0x31D0
m_nFallbackStatTrak            = 0x31D4
LocalWeaponData                = 0x0
m_iPrimaryAmmoType             = 0x325C
m_iSecondaryAmmoType           = 0x3260
m_nViewModelIndex              = 0x3234
m_bFlipViewModel               = 0x32C4
m_iWeaponOrigin                = 0x32C8
m_iWeaponModule                = 0x324C
LocalActiveWeaponData          = 0x0
m_flNextPrimaryAttack          = 0x3238
m_flNextSecondaryAttack        = 0x323C
m_nNextThinkTick               = 0xFC
m_flTimeWeaponIdle             = 0x3274
m_iViewModelIndex              = 0x3240
m_iWorldModelIndex             = 0x3244
m_iWorldDroppedModelIndex      = 0x3248
m_iState                       = 0x3258
m_hOwner                       = 0x3230
m_iClip1                       = 0x3264
m_iClip2                       = 0x3268
m_iPrimaryReserveAmmoCount     = 0x326C
m_iSecondaryReserveAmmoCount   = 0x3270
m_hWeaponWorldModel            = 0x3254
m_iNumEmptyAttacks             = 0x3250

```

`Resources/DT_BasePlayer.log`:

```log

[DT_BasePlayer]
AnimTimeMustBeFirst            = 0x0
m_flAnimTime                   = 0x260
m_flSimulationTime             = 0x268
m_cellbits                     = 0x74
m_cellX                        = 0x7C
m_cellY                        = 0x80
m_cellZ                        = 0x84
m_vecOrigin                    = 0x138
m_angRotation                  = 0x12C
m_nModelIndex                  = 0x258
m_fEffects                     = 0xF0
m_nRenderMode                  = 0x25B
m_nRenderFX                    = 0x25A
m_clrRender                    = 0x70
m_iTeamNum                     = 0xF4
m_iPendingTeamNum              = 0xF8
m_CollisionGroup               = 0x474
m_flElasticity                 = 0x300
m_flShadowCastDistance         = 0x3A0
m_hOwnerEntity                 = 0x14C
m_hEffectEntity                = 0x998
moveparent                     = 0x148
m_iParentAttachment            = 0x2EC
m_iName                        = 0x154
movetype                       = 0x0
movecollide                    = 0x0
m_Collision                    = 0x320
m_vecMins                      = 0x328
m_vecMaxs                      = 0x334
m_nSolidType                   = 0x342
m_usSolidFlags                 = 0x340
m_nSurroundType                = 0x34A
m_triggerBloat                 = 0x343
m_vecSpecifiedSurroundingMins  = 0x34C
m_vecSpecifiedSurroundingMaxs  = 0x358
m_iTextureFrameIndex           = 0x98C
m_bSimulatedEveryTick          = 0x93A
m_bAnimatedEveryTick           = 0x93B
m_bAlternateSorting            = 0x93C
m_bSpotted                     = 0x93D
m_bSpottedBy                   = 0x93E
000                            = 0x93E
001                            = 0x93F
002                            = 0x940
003                            = 0x941
004                            = 0x942
005                            = 0x943
006                            = 0x944
007                            = 0x945
008                            = 0x946
009                            = 0x947
010                            = 0x948
011                            = 0x949
012                            = 0x94A
013                            = 0x94B
014                            = 0x94C
015                            = 0x94D
016                            = 0x94E
017                            = 0x94F
018                            = 0x950
019                            = 0x951
020                            = 0x952
021                            = 0x953
022                            = 0x954
023                            = 0x955
024                            = 0x956
025                            = 0x957
026                            = 0x958
027                            = 0x959
028                            = 0x95A
029                            = 0x95B
030                            = 0x95C
031                            = 0x95D
032                            = 0x95E
033                            = 0x95F
034                            = 0x960
035                            = 0x961
036                            = 0x962
037                            = 0x963
038                            = 0x964
039                            = 0x965
040                            = 0x966
041                            = 0x967
042                            = 0x968
043                            = 0x969
044                            = 0x96A
045                            = 0x96B
046                            = 0x96C
047                            = 0x96D
048                            = 0x96E
049                            = 0x96F
050                            = 0x970
051                            = 0x971
052                            = 0x972
053                            = 0x973
054                            = 0x974
055                            = 0x975
056                            = 0x976
057                            = 0x977
058                            = 0x978
059                            = 0x979
060                            = 0x97A
061                            = 0x97B
062                            = 0x97C
063                            = 0x97D
064                            = 0x97E
m_bSpottedByMask               = 0x980
m_bIsAutoaimTarget             = 0x60
m_fadeMinDist                  = 0x2F4
m_fadeMaxDist                  = 0x2F8
m_flFadeScale                  = 0x2FC
m_nMinCPULevel                 = 0x988
m_nMaxCPULevel                 = 0x989
m_nMinGPULevel                 = 0x98A
m_nMaxGPULevel                 = 0x98B
m_flUseLookAtAngle             = 0x2CC
m_flLastMadeNoiseTime          = 0x20
m_flMaxFallVelocity            = 0xDC
m_bEligibleForScreenHighlight  = 0x9B9
m_nSequence                    = 0x28BC
m_nForceBone                   = 0x268C
m_vecForce                     = 0x2680
m_nSkin                        = 0xA1C
m_nBody                        = 0xA20
m_nHitboxSet                   = 0x9FC
m_flModelScale                 = 0x2748
m_flPoseParameter              = 0x2774
m_flPlaybackRate               = 0xA18
m_flEncodedController          = 0xA54
m_bClientSideAnimation         = 0x289C
m_bClientSideFrameReset        = 0x26C0
m_bClientSideRagdoll           = 0x279
m_nNewSequenceParity           = 0xA44
m_nResetEventsParity           = 0xA48
m_nMuzzleFlashParity           = 0xA64
m_hLightingOrigin              = 0x2944
serveranimdata                 = 0x0
m_flCycle                      = 0xA14
m_flFrozen                     = 0x26F8
m_ScaleType                    = 0x274C
m_bSuppressAnimSounds          = 0x294A
m_nHighlightColorR             = 0xA38
m_nHighlightColorG             = 0xA3C
m_nHighlightColorB             = 0xA40
overlay_vars                   = 0x0
m_AnimOverlay                  = 0x0
lengthproxy                    = 0x0
lengthprop15                   = 0x0
m_flPrevCycle                  = 0x1C
m_flWeight                     = 0x20
m_flWeightDeltaRate            = 0x24
m_nOrder                       = 0x14
m_flexWeight                   = 0x2A28
065                            = 0x2B2C
066                            = 0x2B30
067                            = 0x2B34
068                            = 0x2B38
069                            = 0x2B3C
070                            = 0x2B40
071                            = 0x2B44
072                            = 0x2B48
073                            = 0x2B4C
074                            = 0x2B50
075                            = 0x2B54
076                            = 0x2B58
077                            = 0x2B5C
078                            = 0x2B60
079                            = 0x2B64
080                            = 0x2B68
081                            = 0x2B6C
082                            = 0x2B70
083                            = 0x2B74
084                            = 0x2B78
085                            = 0x2B7C
086                            = 0x2B80
087                            = 0x2B84
088                            = 0x2B88
089                            = 0x2B8C
090                            = 0x2B90
091                            = 0x2B94
092                            = 0x2B98
093                            = 0x2B9C
094                            = 0x2BA0
095                            = 0x2BA4
m_blinktoggle                  = 0x2BD4
m_viewtarget                   = 0x29F0
bcc_localdata                  = 0x0
m_flNextAttack                 = 0x2D70
bcc_nonlocaldata               = 0x0
m_hMyWeapons                   = 0x2DF8
m_LastHitGroup                 = 0x2D74
m_hActiveWeapon                = 0x2EF8
m_flTimeOfLastInjury           = 0x2EFC
m_nRelativeDirectionOfLastInjury = 0x2F00
m_hMyWearables                 = 0x2F04
localdata                      = 0x0
m_Local                        = 0x2FBC
m_chAreaBits                   = 0x2FC0
m_chAreaPortalBits             = 0x2FE0
m_iHideHUD                     = 0x3004
m_flFOVRate                    = 0x3000
m_bDucked                      = 0x3044
m_bDucking                     = 0x3045
m_flLastDuckTime               = 0x3048
m_bInDuckJump                  = 0x304C
m_nDuckTimeMsecs               = 0x3008
m_nDuckJumpTimeMsecs           = 0x300C
m_nJumpTimeMsecs               = 0x3010
m_flFallVelocity               = 0x3014
m_viewPunchAngle               = 0x3020
m_aimPunchAngle                = 0x302C
m_aimPunchAngleVel             = 0x3038
m_bDrawViewmodel               = 0x304D
m_bWearingSuit                 = 0x304E
m_bPoisoned                    = 0x304F
m_flStepSize                   = 0x301C
m_bAllowAutoMovement           = 0x3050
m_skybox3d.scale               = 0x30F0
m_skybox3d.origin              = 0x30F4
m_skybox3d.area                = 0x3100
m_skybox3d.fog.enable          = 0x3148
m_skybox3d.fog.blend           = 0x3149
m_skybox3d.fog.dirPrimary      = 0x3108
m_skybox3d.fog.colorPrimary    = 0x3114
m_skybox3d.fog.colorSecondary  = 0x3118
m_skybox3d.fog.start           = 0x3124
m_skybox3d.fog.end             = 0x3128
m_skybox3d.fog.maxdensity      = 0x3130
m_skybox3d.fog.HDRColorScale   = 0x3150
m_audio.localSound[0]          = 0x3158
m_audio.localSound[1]          = 0x3164
m_audio.localSound[2]          = 0x3170
m_audio.localSound[3]          = 0x317C
m_audio.localSound[4]          = 0x3188
m_audio.localSound[5]          = 0x3194
m_audio.localSound[6]          = 0x31A0
m_audio.localSound[7]          = 0x31AC
m_audio.soundscapeIndex        = 0x31B8
m_audio.localBits              = 0x31BC
m_audio.entIndex               = 0x31C0
m_vecViewOffset[0]             = 0x108
m_vecViewOffset[1]             = 0x10C
m_vecViewOffset[2]             = 0x110
m_flFriction                   = 0x144
m_fOnTarget                    = 0x3324
m_nTickBase                    = 0x3430
m_nNextThinkTick               = 0xFC
m_hLastWeapon                  = 0x32F4
m_vecVelocity[0]               = 0x114
m_vecVelocity[1]               = 0x118
m_vecVelocity[2]               = 0x11C
m_vecBaseVelocity              = 0x120
m_hConstraintEntity            = 0x3344
m_vecConstraintCenter          = 0x3348
m_flConstraintRadius           = 0x3354
m_flConstraintWidth            = 0x3358
m_flConstraintSpeedFactor      = 0x335C
m_bConstraintPastRadius        = 0x3360
m_flDeathTime                  = 0x33C4
m_flNextDecalTime              = 0x33C8
m_fForceTeam                   = 0x33CC
m_flLaggedMovementValue        = 0x3594
m_hTonemapController           = 0x31CC
pl                             = 0x31D0
deadflag                       = 0x31D4
m_iFOV                         = 0x31E4
m_iFOVStart                    = 0x31E8
m_flFOVTime                    = 0x3208
m_iDefaultFOV                  = 0x332C
m_hZoomOwner                   = 0x324C
m_afPhysicsFlags               = 0x32EC
m_hVehicle                     = 0x32F0
m_hUseEntity                   = 0x3328
m_hGroundEntity                = 0x150
m_iHealth                      = 0x100
m_lifeState                    = 0x25F
m_iAmmo                        = 0x2D78
m_iBonusProgress               = 0x3240
m_iBonusChallenge              = 0x3244
m_flMaxspeed                   = 0x3248
m_fFlags                       = 0x104
m_iObserverMode                = 0x3378
m_bActiveCameraMan             = 0x337C
m_bCameraManXRay               = 0x337D
m_bCameraManOverview           = 0x337E
m_bCameraManScoreBoard         = 0x337F
m_uCameraManGraphs             = 0x3380
m_iDeathPostEffect             = 0x3374
m_hObserverTarget              = 0x338C
m_hViewModel[0]                = 0x32F8
m_hViewModel                   = 0x0
m_iCoachingTeam                = 0x2F50
m_szLastPlaceName              = 0x35B4
m_vecLadderNormal              = 0x3230
m_ladderSurfaceProps           = 0x3200
m_ubEFNoInterpParity           = 0x35D8
m_hPostProcessCtrl             = 0x37A8
m_hColorCorrectionCtrl         = 0x37AC
m_PlayerFog.m_hCtrl            = 0x37B4
m_vphysicsCollisionState       = 0x325C
m_hViewEntity                  = 0x333C
m_bShouldDrawPlayerWhileUsingViewEntity = 0x3340
m_flDuckAmount                 = 0x2FAC
m_flDuckSpeed                  = 0x2FB0
m_nWaterLevel                  = 0x25E

```

`Resources/DT_CSPlayer.log`:

```log

[DT_CSPlayer]
AnimTimeMustBeFirst            = 0x0
m_flAnimTime                   = 0x260
m_flSimulationTime             = 0x268
m_cellbits                     = 0x74
m_cellX                        = 0x7C
m_cellY                        = 0x80
m_cellZ                        = 0x84
m_vecOrigin                    = 0x138
m_angRotation                  = 0x12C
m_nModelIndex                  = 0x258
m_fEffects                     = 0xF0
m_nRenderMode                  = 0x25B
m_nRenderFX                    = 0x25A
m_clrRender                    = 0x70
m_iTeamNum                     = 0xF4
m_iPendingTeamNum              = 0xF8
m_CollisionGroup               = 0x474
m_flElasticity                 = 0x300
m_flShadowCastDistance         = 0x3A0
m_hOwnerEntity                 = 0x14C
m_hEffectEntity                = 0x998
moveparent                     = 0x148
m_iParentAttachment            = 0x2EC
m_iName                        = 0x154
movetype                       = 0x0
movecollide                    = 0x0
m_Collision                    = 0x320
m_vecMins                      = 0x328
m_vecMaxs                      = 0x334
m_nSolidType                   = 0x342
m_usSolidFlags                 = 0x340
m_nSurroundType                = 0x34A
m_triggerBloat                 = 0x343
m_vecSpecifiedSurroundingMins  = 0x34C
m_vecSpecifiedSurroundingMaxs  = 0x358
m_iTextureFrameIndex           = 0x98C
m_bSimulatedEveryTick          = 0x93A
m_bAnimatedEveryTick           = 0x93B
m_bAlternateSorting            = 0x93C
m_bSpotted                     = 0x93D
m_bSpottedBy                   = 0x93E
000                            = 0x93E
001                            = 0x93F
002                            = 0x940
003                            = 0x941
004                            = 0x942
005                            = 0x943
006                            = 0x944
007                            = 0x945
008                            = 0x946
009                            = 0x947
010                            = 0x948
011                            = 0x949
012                            = 0x94A
013                            = 0x94B
014                            = 0x94C
015                            = 0x94D
016                            = 0x94E
017                            = 0x94F
018                            = 0x950
019                            = 0x951
020                            = 0x952
021                            = 0x953
022                            = 0x954
023                            = 0x955
024                            = 0x956
025                            = 0x957
026                            = 0x958
027                            = 0x959
028                            = 0x95A
029                            = 0x95B
030                            = 0x95C
031                            = 0x95D
032                            = 0x95E
033                            = 0x95F
034                            = 0x960
035                            = 0x961
036                            = 0x962
037                            = 0x963
038                            = 0x964
039                            = 0x965
040                            = 0x966
041                            = 0x967
042                            = 0x968
043                            = 0x969
044                            = 0x96A
045                            = 0x96B
046                            = 0x96C
047                            = 0x96D
048                            = 0x96E
049                            = 0x96F
050                            = 0x970
051                            = 0x971
052                            = 0x972
053                            = 0x973
054                            = 0x974
055                            = 0x975
056                            = 0x976
057                            = 0x977
058                            = 0x978
059                            = 0x979
060                            = 0x97A
061                            = 0x97B
062                            = 0x97C
063                            = 0x97D
064                            = 0x97E
m_bSpottedByMask               = 0x980
m_bIsAutoaimTarget             = 0x60
m_fadeMinDist                  = 0x2F4
m_fadeMaxDist                  = 0x2F8
m_flFadeScale                  = 0x2FC
m_nMinCPULevel                 = 0x988
m_nMaxCPULevel                 = 0x989
m_nMinGPULevel                 = 0x98A
m_nMaxGPULevel                 = 0x98B
m_flUseLookAtAngle             = 0x2CC
m_flLastMadeNoiseTime          = 0x20
m_flMaxFallVelocity            = 0xDC
m_bEligibleForScreenHighlight  = 0x9B9
m_nSequence                    = 0x28BC
m_nForceBone                   = 0x268C
m_vecForce                     = 0x2680
m_nSkin                        = 0xA1C
m_nBody                        = 0xA20
m_nHitboxSet                   = 0x9FC
m_flModelScale                 = 0x2748
m_flPoseParameter              = 0x2774
m_flPlaybackRate               = 0xA18
m_flEncodedController          = 0xA54
m_bClientSideAnimation         = 0x289C
m_bClientSideFrameReset        = 0x26C0
m_bClientSideRagdoll           = 0x279
m_nNewSequenceParity           = 0xA44
m_nResetEventsParity           = 0xA48
m_nMuzzleFlashParity           = 0xA64
m_hLightingOrigin              = 0x2944
serveranimdata                 = 0x0
m_flCycle                      = 0xA14
m_flFrozen                     = 0x26F8
m_ScaleType                    = 0x274C
m_bSuppressAnimSounds          = 0x294A
m_nHighlightColorR             = 0xA38
m_nHighlightColorG             = 0xA3C
m_nHighlightColorB             = 0xA40
overlay_vars                   = 0x0
m_AnimOverlay                  = 0x0
lengthproxy                    = 0x0
lengthprop15                   = 0x0
m_flPrevCycle                  = 0x1C
m_flWeight                     = 0x20
m_flWeightDeltaRate            = 0x24
m_nOrder                       = 0x14
m_flexWeight                   = 0x2A28
065                            = 0x2B2C
066                            = 0x2B30
067                            = 0x2B34
068                            = 0x2B38
069                            = 0x2B3C
070                            = 0x2B40
071                            = 0x2B44
072                            = 0x2B48
073                            = 0x2B4C
074                            = 0x2B50
075                            = 0x2B54
076                            = 0x2B58
077                            = 0x2B5C
078                            = 0x2B60
079                            = 0x2B64
080                            = 0x2B68
081                            = 0x2B6C
082                            = 0x2B70
083                            = 0x2B74
084                            = 0x2B78
085                            = 0x2B7C
086                            = 0x2B80
087                            = 0x2B84
088                            = 0x2B88
089                            = 0x2B8C
090                            = 0x2B90
091                            = 0x2B94
092                            = 0x2B98
093                            = 0x2B9C
094                            = 0x2BA0
095                            = 0x2BA4
m_blinktoggle                  = 0x2BD4
m_viewtarget                   = 0x29F0
bcc_localdata                  = 0x0
m_flNextAttack                 = 0x2D70
bcc_nonlocaldata               = 0x0
m_hMyWeapons                   = 0x2DF8
m_LastHitGroup                 = 0x2D74
m_hActiveWeapon                = 0x2EF8
m_flTimeOfLastInjury           = 0x2EFC
m_nRelativeDirectionOfLastInjury = 0x2F00
m_hMyWearables                 = 0x2F04
localdata                      = 0x0
m_Local                        = 0x2FBC
m_chAreaBits                   = 0x2FC0
m_chAreaPortalBits             = 0x2FE0
m_iHideHUD                     = 0x3004
m_flFOVRate                    = 0x3000
m_bDucked                      = 0x3044
m_bDucking                     = 0x3045
m_flLastDuckTime               = 0x3048
m_bInDuckJump                  = 0x304C
m_nDuckTimeMsecs               = 0x3008
m_nDuckJumpTimeMsecs           = 0x300C
m_nJumpTimeMsecs               = 0x3010
m_flFallVelocity               = 0x3014
m_viewPunchAngle               = 0x3020
m_aimPunchAngle                = 0x302C
m_aimPunchAngleVel             = 0x3038
m_bDrawViewmodel               = 0x304D
m_bWearingSuit                 = 0x304E
m_bPoisoned                    = 0x304F
m_flStepSize                   = 0x301C
m_bAllowAutoMovement           = 0x3050
m_skybox3d.scale               = 0x30F0
m_skybox3d.origin              = 0x30F4
m_skybox3d.area                = 0x3100
m_skybox3d.fog.enable          = 0x3148
m_skybox3d.fog.blend           = 0x3149
m_skybox3d.fog.dirPrimary      = 0x3108
m_skybox3d.fog.colorPrimary    = 0x3114
m_skybox3d.fog.colorSecondary  = 0x3118
m_skybox3d.fog.start           = 0x3124
m_skybox3d.fog.end             = 0x3128
m_skybox3d.fog.maxdensity      = 0x3130
m_skybox3d.fog.HDRColorScale   = 0x3150
m_audio.localSound[0]          = 0x3158
m_audio.localSound[1]          = 0x3164
m_audio.localSound[2]          = 0x3170
m_audio.localSound[3]          = 0x317C
m_audio.localSound[4]          = 0x3188
m_audio.localSound[5]          = 0x3194
m_audio.localSound[6]          = 0x31A0
m_audio.localSound[7]          = 0x31AC
m_audio.soundscapeIndex        = 0x31B8
m_audio.localBits              = 0x31BC
m_audio.entIndex               = 0x31C0
m_vecViewOffset[0]             = 0x108
m_vecViewOffset[1]             = 0x10C
m_vecViewOffset[2]             = 0x110
m_flFriction                   = 0x144
m_fOnTarget                    = 0x3324
m_nTickBase                    = 0x3430
m_nNextThinkTick               = 0xFC
m_hLastWeapon                  = 0x32F4
m_vecVelocity[0]               = 0x114
m_vecVelocity[1]               = 0x118
m_vecVelocity[2]               = 0x11C
m_vecBaseVelocity              = 0x120
m_hConstraintEntity            = 0x3344
m_vecConstraintCenter          = 0x3348
m_flConstraintRadius           = 0x3354
m_flConstraintWidth            = 0x3358
m_flConstraintSpeedFactor      = 0x335C
m_bConstraintPastRadius        = 0x3360
m_flDeathTime                  = 0x33C4
m_flNextDecalTime              = 0x33C8
m_fForceTeam                   = 0x33CC
m_flLaggedMovementValue        = 0x3594
m_hTonemapController           = 0x31CC
pl                             = 0x31D0
deadflag                       = 0x31D4
m_iFOV                         = 0x31E4
m_iFOVStart                    = 0x31E8
m_flFOVTime                    = 0x3208
m_iDefaultFOV                  = 0x332C
m_hZoomOwner                   = 0x324C
m_afPhysicsFlags               = 0x32EC
m_hVehicle                     = 0x32F0
m_hUseEntity                   = 0x3328
m_hGroundEntity                = 0x150
m_iHealth                      = 0x100
m_lifeState                    = 0x25F
m_iAmmo                        = 0x2D78
m_iBonusProgress               = 0x3240
m_iBonusChallenge              = 0x3244
m_flMaxspeed                   = 0x3248
m_fFlags                       = 0x104
m_iObserverMode                = 0x3378
m_bActiveCameraMan             = 0x337C
m_bCameraManXRay               = 0x337D
m_bCameraManOverview           = 0x337E
m_bCameraManScoreBoard         = 0x337F
m_uCameraManGraphs             = 0x3380
m_iDeathPostEffect             = 0x3374
m_hObserverTarget              = 0x338C
m_hViewModel[0]                = 0x32F8
m_hViewModel                   = 0x0
m_iCoachingTeam                = 0x2F50
m_szLastPlaceName              = 0x35B4
m_vecLadderNormal              = 0x3230
m_ladderSurfaceProps           = 0x3200
m_ubEFNoInterpParity           = 0x35D8
m_hPostProcessCtrl             = 0x37A8
m_hColorCorrectionCtrl         = 0x37AC
m_PlayerFog.m_hCtrl            = 0x37B4
m_vphysicsCollisionState       = 0x325C
m_hViewEntity                  = 0x333C
m_bShouldDrawPlayerWhileUsingViewEntity = 0x3340
m_flDuckAmount                 = 0x2FAC
m_flDuckSpeed                  = 0x2FB0
m_nWaterLevel                  = 0x25E
cslocaldata                    = 0x0
m_vecOrigin[2]                 = 0x140
m_flStamina                    = 0xA388
m_iDirection                   = 0xA38C
m_iShotsFired                  = 0xA390
m_nNumFastDucks                = 0xA394
m_bDuckOverride                = 0xA398
m_flVelocityModifier           = 0xA39C
m_bPlayerDominated             = 0xB494
m_bPlayerDominatingMe          = 0xB4D5
m_iWeaponPurchasesThisRound    = 0xB518
096                            = 0xB698
097                            = 0xB69C
098                            = 0xB6A0
099                            = 0xB6A4
100                            = 0xB6A8
101                            = 0xB6AC
102                            = 0xB6B0
103                            = 0xB6B4
104                            = 0xB6B8
105                            = 0xB6BC
106                            = 0xB6C0
107                            = 0xB6C4
108                            = 0xB6C8
109                            = 0xB6CC
110                            = 0xB6D0
111                            = 0xB6D4
112                            = 0xB6D8
113                            = 0xB6DC
114                            = 0xB6E0
115                            = 0xB6E4
116                            = 0xB6E8
117                            = 0xB6EC
118                            = 0xB6F0
119                            = 0xB6F4
120                            = 0xB6F8
121                            = 0xB6FC
122                            = 0xB700
123                            = 0xB704
124                            = 0xB708
125                            = 0xB70C
126                            = 0xB710
127                            = 0xB714
128                            = 0xB718
129                            = 0xB71C
130                            = 0xB720
131                            = 0xB724
132                            = 0xB728
133                            = 0xB72C
134                            = 0xB730
135                            = 0xB734
136                            = 0xB738
137                            = 0xB73C
138                            = 0xB740
139                            = 0xB744
140                            = 0xB748
141                            = 0xB74C
142                            = 0xB750
143                            = 0xB754
144                            = 0xB758
145                            = 0xB75C
146                            = 0xB760
147                            = 0xB764
148                            = 0xB768
149                            = 0xB76C
150                            = 0xB770
151                            = 0xB774
152                            = 0xB778
153                            = 0xB77C
154                            = 0xB780
155                            = 0xB784
156                            = 0xB788
157                            = 0xB78C
158                            = 0xB790
159                            = 0xB794
160                            = 0xB798
161                            = 0xB79C
162                            = 0xB7A0
163                            = 0xB7A4
164                            = 0xB7A8
165                            = 0xB7AC
166                            = 0xB7B0
167                            = 0xB7B4
168                            = 0xB7B8
169                            = 0xB7BC
170                            = 0xB7C0
171                            = 0xB7C4
172                            = 0xB7C8
173                            = 0xB7CC
174                            = 0xB7D0
175                            = 0xB7D4
176                            = 0xB7D8
177                            = 0xB7DC
178                            = 0xB7E0
179                            = 0xB7E4
180                            = 0xB7E8
181                            = 0xB7EC
182                            = 0xB7F0
183                            = 0xB7F4
184                            = 0xB7F8
185                            = 0xB7FC
186                            = 0xB800
187                            = 0xB804
188                            = 0xB808
189                            = 0xB80C
190                            = 0xB810
191                            = 0xB814
192                            = 0xB818
193                            = 0xB81C
194                            = 0xB820
195                            = 0xB824
196                            = 0xB828
197                            = 0xB82C
198                            = 0xB830
199                            = 0xB834
200                            = 0xB838
201                            = 0xB83C
202                            = 0xB840
203                            = 0xB844
204                            = 0xB848
205                            = 0xB84C
206                            = 0xB850
207                            = 0xB854
208                            = 0xB858
209                            = 0xB85C
210                            = 0xB860
211                            = 0xB864
212                            = 0xB868
213                            = 0xB86C
214                            = 0xB870
215                            = 0xB874
216                            = 0xB878
217                            = 0xB87C
218                            = 0xB880
219                            = 0xB884
220                            = 0xB888
221                            = 0xB88C
222                            = 0xB890
223                            = 0xB894
224                            = 0xB898
225                            = 0xB89C
226                            = 0xB8A0
227                            = 0xB8A4
228                            = 0xB8A8
229                            = 0xB8AC
230                            = 0xB8B0
231                            = 0xB8B4
232                            = 0xB8B8
233                            = 0xB8BC
234                            = 0xB8C0
235                            = 0xB8C4
236                            = 0xB8C8
237                            = 0xB8CC
238                            = 0xB8D0
239                            = 0xB8D4
240                            = 0xB8D8
241                            = 0xB8DC
242                            = 0xB8E0
243                            = 0xB8E4
244                            = 0xB8E8
245                            = 0xB8EC
246                            = 0xB8F0
247                            = 0xB8F4
248                            = 0xB8F8
249                            = 0xB8FC
250                            = 0xB900
251                            = 0xB904
252                            = 0xB908
253                            = 0xB90C
254                            = 0xB910
255                            = 0xB914
m_unActiveQuestId              = 0xB328
m_nQuestProgressReason         = 0xB32C
csnonlocaldata                 = 0x0
csteamdata                     = 0x0
m_iWeaponPurchasesThisMatch    = 0xAA7C
256                            = 0xAE7C
257                            = 0xAE80
258                            = 0xAE84
259                            = 0xAE88
260                            = 0xAE8C
261                            = 0xAE90
262                            = 0xAE94
263                            = 0xAE98
264                            = 0xAE9C
265                            = 0xAEA0
266                            = 0xAEA4
267                            = 0xAEA8
268                            = 0xAEAC
269                            = 0xAEB0
270                            = 0xAEB4
271                            = 0xAEB8
272                            = 0xAEBC
273                            = 0xAEC0
274                            = 0xAEC4
275                            = 0xAEC8
276                            = 0xAECC
277                            = 0xAED0
278                            = 0xAED4
279                            = 0xAED8
280                            = 0xAEDC
281                            = 0xAEE0
282                            = 0xAEE4
283                            = 0xAEE8
284                            = 0xAEEC
285                            = 0xAEF0
286                            = 0xAEF4
287                            = 0xAEF8
288                            = 0xAEFC
289                            = 0xAF00
290                            = 0xAF04
291                            = 0xAF08
292                            = 0xAF0C
293                            = 0xAF10
294                            = 0xAF14
295                            = 0xAF18
296                            = 0xAF1C
297                            = 0xAF20
298                            = 0xAF24
299                            = 0xAF28
300                            = 0xAF2C
301                            = 0xAF30
302                            = 0xAF34
303                            = 0xAF38
304                            = 0xAF3C
305                            = 0xAF40
306                            = 0xAF44
307                            = 0xAF48
308                            = 0xAF4C
309                            = 0xAF50
310                            = 0xAF54
311                            = 0xAF58
312                            = 0xAF5C
313                            = 0xAF60
314                            = 0xAF64
315                            = 0xAF68
316                            = 0xAF6C
317                            = 0xAF70
318                            = 0xAF74
319                            = 0xAF78
320                            = 0xAF7C
321                            = 0xAF80
322                            = 0xAF84
323                            = 0xAF88
324                            = 0xAF8C
325                            = 0xAF90
326                            = 0xAF94
327                            = 0xAF98
328                            = 0xAF9C
329                            = 0xAFA0
330                            = 0xAFA4
331                            = 0xAFA8
332                            = 0xAFAC
333                            = 0xAFB0
334                            = 0xAFB4
335                            = 0xAFB8
336                            = 0xAFBC
337                            = 0xAFC0
338                            = 0xAFC4
339                            = 0xAFC8
340                            = 0xAFCC
341                            = 0xAFD0
342                            = 0xAFD4
343                            = 0xAFD8
344                            = 0xAFDC
345                            = 0xAFE0
346                            = 0xAFE4
347                            = 0xAFE8
348                            = 0xAFEC
349                            = 0xAFF0
350                            = 0xAFF4
351                            = 0xAFF8
352                            = 0xAFFC
353                            = 0xB000
354                            = 0xB004
355                            = 0xB008
356                            = 0xB00C
357                            = 0xB010
358                            = 0xB014
359                            = 0xB018
360                            = 0xB01C
361                            = 0xB020
362                            = 0xB024
363                            = 0xB028
364                            = 0xB02C
365                            = 0xB030
366                            = 0xB034
367                            = 0xB038
368                            = 0xB03C
369                            = 0xB040
370                            = 0xB044
371                            = 0xB048
372                            = 0xB04C
373                            = 0xB050
374                            = 0xB054
375                            = 0xB058
376                            = 0xB05C
377                            = 0xB060
378                            = 0xB064
379                            = 0xB068
380                            = 0xB06C
381                            = 0xB070
382                            = 0xB074
383                            = 0xB078
384                            = 0xB07C
385                            = 0xB080
386                            = 0xB084
387                            = 0xB088
388                            = 0xB08C
389                            = 0xB090
390                            = 0xB094
391                            = 0xB098
392                            = 0xB09C
393                            = 0xB0A0
394                            = 0xB0A4
395                            = 0xB0A8
396                            = 0xB0AC
397                            = 0xB0B0
398                            = 0xB0B4
399                            = 0xB0B8
400                            = 0xB0BC
401                            = 0xB0C0
402                            = 0xB0C4
403                            = 0xB0C8
404                            = 0xB0CC
405                            = 0xB0D0
406                            = 0xB0D4
407                            = 0xB0D8
408                            = 0xB0DC
409                            = 0xB0E0
410                            = 0xB0E4
411                            = 0xB0E8
412                            = 0xB0EC
413                            = 0xB0F0
414                            = 0xB0F4
415                            = 0xB0F8
416                            = 0xB0FC
417                            = 0xB100
418                            = 0xB104
419                            = 0xB108
420                            = 0xB10C
421                            = 0xB110
422                            = 0xB114
423                            = 0xB118
424                            = 0xB11C
425                            = 0xB120
426                            = 0xB124
427                            = 0xB128
428                            = 0xB12C
429                            = 0xB130
430                            = 0xB134
431                            = 0xB138
432                            = 0xB13C
433                            = 0xB140
434                            = 0xB144
435                            = 0xB148
436                            = 0xB14C
437                            = 0xB150
438                            = 0xB154
439                            = 0xB158
440                            = 0xB15C
441                            = 0xB160
442                            = 0xB164
443                            = 0xB168
444                            = 0xB16C
445                            = 0xB170
446                            = 0xB174
447                            = 0xB178
448                            = 0xB17C
449                            = 0xB180
450                            = 0xB184
451                            = 0xB188
452                            = 0xB18C
453                            = 0xB190
454                            = 0xB194
455                            = 0xB198
456                            = 0xB19C
457                            = 0xB1A0
458                            = 0xB1A4
459                            = 0xB1A8
460                            = 0xB1AC
461                            = 0xB1B0
462                            = 0xB1B4
463                            = 0xB1B8
464                            = 0xB1BC
465                            = 0xB1C0
466                            = 0xB1C4
467                            = 0xB1C8
468                            = 0xB1CC
469                            = 0xB1D0
470                            = 0xB1D4
471                            = 0xB1D8
472                            = 0xB1DC
473                            = 0xB1E0
474                            = 0xB1E4
475                            = 0xB1E8
476                            = 0xB1EC
477                            = 0xB1F0
478                            = 0xB1F4
479                            = 0xB1F8
480                            = 0xB1FC
481                            = 0xB200
482                            = 0xB204
483                            = 0xB208
484                            = 0xB20C
485                            = 0xB210
486                            = 0xB214
487                            = 0xB218
488                            = 0xB21C
489                            = 0xB220
490                            = 0xB224
491                            = 0xB228
492                            = 0xB22C
493                            = 0xB230
494                            = 0xB234
495                            = 0xB238
496                            = 0xB23C
497                            = 0xB240
498                            = 0xB244
m_EquippedLoadoutItemDefIndices = 0xB254
m_angEyeAngles[0]              = 0xB37C
m_angEyeAngles[1]              = 0xB380
m_iAddonBits                   = 0xA374
m_iPrimaryAddon                = 0xA378
m_iSecondaryAddon              = 0xA37C
m_iThrowGrenadeCounter         = 0x396C
m_bWaitForNoAttack             = 0x3970
m_bIsRespawningForDMBonus      = 0x3971
m_iPlayerState                 = 0x392C
m_iAccount                     = 0xB364
m_iStartAccount                = 0xA3A4
m_totalHitsOnServer            = 0xA3A8
m_bInBombZone                  = 0x3968
m_bInBuyZone                   = 0x3969
m_bInNoDefuseArea              = 0x396A
m_bKilledByTaser               = 0x3981
m_iMoveState                   = 0x3984
m_iClass                       = 0xB374
m_ArmorValue                   = 0xB378
m_angEyeAngles                 = 0xB37C
m_bHasDefuser                  = 0xB388
m_bNightVisionOn               = 0xA399
m_bHasNightVision              = 0xA39A
m_bInHostageRescueZone         = 0xB389
m_bIsDefusing                  = 0x3930
m_bIsGrabbingHostage           = 0x3931
m_iBlockingUseActionInProgress = 0x3934
m_bIsScoped                    = 0x3928
m_bIsWalking                   = 0x3929
m_nIsAutoMounting              = 0x3A98
m_bResumeZoom                  = 0x392A
m_fImmuneToGunGameDamageTime   = 0x393C
m_bGunGameImmunity             = 0x3944
m_bHasMovedSinceSpawn          = 0x3945
m_bMadeFinalGunGameProgressiveKill = 0x3946
m_iGunGameProgressiveWeaponIndex = 0x3948
m_iNumGunGameTRKillPoints      = 0x394C
m_iNumGunGameKillsWithCurrentWeapon = 0x3950
m_iNumRoundKills               = 0x3954
m_fMolotovUseTime              = 0x3960
m_fMolotovDamageTime           = 0x3964
m_szArmsModel                  = 0x398B
m_hCarriedHostage              = 0xA3F8
m_hCarriedHostageProp          = 0xA3FC
m_bIsRescuing                  = 0x3938
m_flGroundAccelLinearFracLastTime = 0xA3A0
m_bCanMoveDuringFreezePeriod   = 0x3988
m_isCurrentGunGameLeader       = 0x3989
m_isCurrentGunGameTeamLeader   = 0x398A
m_flGuardianTooFarDistFrac     = 0x3974
m_flDetectedByEnemySensorTime  = 0x3978
m_bIsPlayerGhost               = 0x3A95
m_iMatchStats_Kills            = 0xA464
m_iMatchStats_Damage           = 0xA4DC
m_iMatchStats_EquipmentValue   = 0xA554
m_iMatchStats_MoneySaved       = 0xA5CC
m_iMatchStats_KillReward       = 0xA644
m_iMatchStats_LiveTime         = 0xA6BC
m_iMatchStats_Deaths           = 0xA734
m_iMatchStats_Assists          = 0xA7AC
m_iMatchStats_HeadShotKills    = 0xA824
m_iMatchStats_Objective        = 0xA89C
m_iMatchStats_CashEarned       = 0xA914
m_iMatchStats_UtilityDamage    = 0xA98C
m_iMatchStats_EnemiesFlashed   = 0xAA04
m_rank                         = 0xB338
m_passiveItems                 = 0xB350
m_bHasParachute                = 0xB350
m_unMusicID                    = 0xB354
m_bHasHelmet                   = 0xB36C
m_bHasHeavyArmor               = 0xB36D
m_nHeavyAssaultSuitCooldownRemaining = 0xB370
m_flFlashDuration              = 0xA420
m_flFlashMaxAlpha              = 0xA41C
m_iProgressBarDuration         = 0xA380
m_flProgressBarStartTime       = 0xA384
m_hRagdoll                     = 0xA3EC
m_hPlayerPing                  = 0xA3F0
m_cycleLatch                   = 0xB48C
m_unCurrentEquipmentValue      = 0xB330
m_unRoundStartEquipmentValue   = 0xB332
m_unFreezetimeEndEquipmentValue = 0xB334
m_bIsControllingBot            = 0xB9F9
m_bHasControlledBotThisRound   = 0xBA08
m_bCanControlObservedBot       = 0xB9FA
m_iControlledBotEntIndex       = 0xB9FC
m_vecAutomoveTargetEnd         = 0x3AA8
m_flAutoMoveStartTime          = 0x3AB8
m_flAutoMoveTargetTime         = 0x3ABC
m_bIsAssassinationTarget       = 0xB9F8
m_bHud_MiniScoreHidden         = 0xB3AA
m_bHud_RadarHidden             = 0xB3AB
m_nLastKillerIndex             = 0xB3AC
m_nLastConcurrentKilled        = 0xB3B0
m_nDeathCamMusic               = 0xB3B4
m_bIsHoldingLookAtWeapon       = 0xB921
m_bIsLookingAtWeapon           = 0xB920
m_iNumRoundKillsHeadshots      = 0x3958
m_unTotalRoundDamageDealt      = 0x395C
m_flLowerBodyYawTarget         = 0x3A90
m_bStrafing                    = 0x3A94
m_flThirdpersonRecoil          = 0xB998
m_bHideTargetID                = 0xB99C
m_bIsSpawnRappelling           = 0xA3AD
m_vecSpawnRappellingRopeOrigin = 0xA3B0
m_nSurvivalTeam                = 0xA3C0
m_hSurvivalAssassinationTarget = 0xA3C4
m_flHealthShotBoostExpirationTime = 0xA3C8
m_flLastExoJumpTime            = 0x3AC0
m_vecPlayerPatchEconIndices    = 0xB970
```