Project Path: arc_PierreCiholas_NotAnOverlay__d2apw2_

Source Tree:

```txt
arc_PierreCiholas_NotAnOverlay__d2apw2_
├── NotAnOverlay
│   ├── NotAnOverlay.hpp
│   ├── NotAnOverlay.vcxproj
│   ├── NotAnOverlay.vcxproj.filters
│   ├── PerfMgr.hpp
│   ├── cap.bmp
│   └── main.cpp
├── NotAnOverlay.sln
└── README.md

```

`NotAnOverlay.sln`:

```sln

Microsoft Visual Studio Solution File, Format Version 12.00
# Visual Studio 15
VisualStudioVersion = 15.0.26430.6
MinimumVisualStudioVersion = 10.0.40219.1
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "NotAnOverlay", "NotAnOverlay\NotAnOverlay.vcxproj", "{49CE407B-A6B3-4705-9466-06171E3D257E}"
EndProject
Global
	GlobalSection(SolutionConfigurationPlatforms) = preSolution
		Debug|x64 = Debug|x64
		Debug|x86 = Debug|x86
		Release|x64 = Release|x64
		Release|x86 = Release|x86
	EndGlobalSection
	GlobalSection(ProjectConfigurationPlatforms) = postSolution
		{49CE407B-A6B3-4705-9466-06171E3D257E}.Debug|x64.ActiveCfg = Debug|x64
		{49CE407B-A6B3-4705-9466-06171E3D257E}.Debug|x64.Build.0 = Debug|x64
		{49CE407B-A6B3-4705-9466-06171E3D257E}.Debug|x86.ActiveCfg = Debug|Win32
		{49CE407B-A6B3-4705-9466-06171E3D257E}.Debug|x86.Build.0 = Debug|Win32
		{49CE407B-A6B3-4705-9466-06171E3D257E}.Release|x64.ActiveCfg = Release|x64
		{49CE407B-A6B3-4705-9466-06171E3D257E}.Release|x64.Build.0 = Release|x64
		{49CE407B-A6B3-4705-9466-06171E3D257E}.Release|x86.ActiveCfg = Release|Win32
		{49CE407B-A6B3-4705-9466-06171E3D257E}.Release|x86.Build.0 = Release|Win32
	EndGlobalSection
	GlobalSection(SolutionProperties) = preSolution
		HideSolutionNode = FALSE
	EndGlobalSection
EndGlobal

```

`NotAnOverlay/NotAnOverlay.hpp`:

```hpp
#pragma once
#include <Windows.h>
#include <string>
// For screen capture
#include <ole2.h>
#include <olectl.h>
#include "PerfMgr.hpp"

#define DEFAULT_WNDCLASSNAME L"Control"
#define DEFAULT_WNDTITLE L""

class NotAnOverlay {
public:
	NotAnOverlay();
	~NotAnOverlay();

	// Start-up (Required to have a thread on a private method)
	static void NotAnOverlay::Start(void* notAnOverlayInstance);
	HANDLE NotAnOverlay::StartThread();

	// Window management
	static void TreatWindowMessageQueue();
	static LRESULT CALLBACK NotAnOverlay::WindowProc(HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam);

	// Getters
	HWND NotAnOverlay::GetWindow();
	HANDLE NotAnOverlay::GetThread();

private:
	void NotAnOverlay::InitOverlay();
	void NotAnOverlay::CloneArea(int x, int y, int w, int h);
	// Window management
	HWND NotAnOverlay::SpawnOverlayWindow(std::wstring windowClassName = DEFAULT_WNDCLASSNAME, std::wstring windowTitle = DEFAULT_WNDTITLE);
	bool NotAnOverlay::RegisterWindowClass(std::wstring windowClassName = DEFAULT_WNDCLASSNAME);
	bool NotAnOverlay::GetScreenResolution();
	// Screen capture
	void NotAnOverlay::CaptureScreenArea(int x, int y, int w, int h, HBITMAP* hBitmap);
	bool NotAnOverlay::SaveBitmap(LPCSTR filename, HBITMAP bmp, HPALETTE pal = NULL);

protected:
	HANDLE m_hThreadNotAnOverlay = NULL;
	HWND m_hwndNotOverlay = NULL;
	POINT m_screenResolution;
	RECT m_windowSize;

	PAINTSTRUCT m_paintStruct;

	HDC m_hdcSource = NULL;
	HDC m_hdcDestination = NULL;
	HDC m_hdcSrcTemp = NULL;
	HDC m_hdcDstTemp = NULL;

	HBITMAP m_hBitmapSource = NULL;
	HBITMAP m_hBitmapTemp = NULL;

	PerfManager perfs;
};

NotAnOverlay::NotAnOverlay() {
	m_hdcSource = GetDC(NULL); // TODO: Use HWND to capture specific window
	m_hdcSrcTemp = CreateCompatibleDC(m_hdcSource);
	Start(this);
}

NotAnOverlay::~NotAnOverlay() {
	// TODO: on destruction, make the thread terminate properly, join, then destroy.
	DeleteObject(m_hBitmapSource);
	DeleteObject(m_hBitmapTemp);
	DeleteDC(m_hdcDestination);
	DeleteDC(m_hdcDstTemp);
	DeleteDC(m_hdcSrcTemp);
	ReleaseDC(NULL, m_hdcSource);
}

// Getters
HWND NotAnOverlay::GetWindow() { return m_hwndNotOverlay; }
HANDLE NotAnOverlay::GetThread() { return m_hThreadNotAnOverlay; }

void NotAnOverlay::Start(void* notAnOverlayInstance) {
	return ((NotAnOverlay*)notAnOverlayInstance)->InitOverlay();
}

HANDLE NotAnOverlay::StartThread() {
	m_hThreadNotAnOverlay = CreateThread(NULL, NULL, (LPTHREAD_START_ROUTINE)Start, this, NULL, NULL);
}

void NotAnOverlay::CloneArea(int x, int y, int w, int h) {
	NotAnOverlay::CaptureScreenArea(x, y, w, h, &m_hBitmapSource);

	InvalidateRect(m_hwndNotOverlay, NULL, TRUE); // Tells that the window should be repainted
	m_hdcDestination = BeginPaint(m_hwndNotOverlay, &m_paintStruct);
	m_hdcDstTemp = CreateCompatibleDC(m_hdcDestination);
	m_hBitmapTemp = (HBITMAP)SelectObject(m_hdcDstTemp, m_hBitmapSource);
	
	// No resizing (ideal when same resolution)
	//BitBlt(hdc, 0, 0, w, h, hdcMem, 0, 0, SRCCOPY);

	// Resizing (ideal when resolutions are different)
	GetClientRect(m_hwndNotOverlay, &m_windowSize); // TODO: Move to WindowProc and refresh only on msg WM_SIZE (require WindowProc to be method)
	SetStretchBltMode(m_hdcDestination, COLORONCOLOR); // Use HALFTONE for better image quality (but slower)
	StretchBlt(m_hdcDestination, 0, 0, m_windowSize.right, m_windowSize.bottom, m_hdcDstTemp, x, y, w, h, SRCCOPY);
	EndPaint(m_hwndNotOverlay, &m_paintStruct);

	UpdateWindow(m_hwndNotOverlay); // Force direct repaint window
}

void NotAnOverlay::CaptureScreenArea(int x, int y, int w, int h, HBITMAP* hBitmap) {
	*hBitmap = CreateCompatibleBitmap(m_hdcSource, w, h);
	m_hBitmapTemp = (HBITMAP)SelectObject(m_hdcSrcTemp, *hBitmap);

	BitBlt(m_hdcSrcTemp, 0, 0, w, h, m_hdcSource, x, y, SRCCOPY);
	*hBitmap = (HBITMAP)SelectObject(m_hdcSrcTemp, m_hBitmapTemp);
}

void NotAnOverlay::InitOverlay() {
	NotAnOverlay::GetScreenResolution();
	m_hwndNotOverlay = SpawnOverlayWindow();

	while (true) {
		perfs.AddTick();

		NotAnOverlay::CloneArea(0, 0, m_screenResolution.x, m_screenResolution.y);
		TreatWindowMessageQueue();
	}
}

HWND NotAnOverlay::SpawnOverlayWindow(std::wstring windowClassName, std::wstring windowTitle) {
	NotAnOverlay::RegisterWindowClass(windowClassName);
	return CreateWindowEx(NULL, windowClassName.c_str(), windowTitle.c_str(), WS_VISIBLE | WS_TILEDWINDOW, CW_USEDEFAULT, CW_USEDEFAULT, CW_USEDEFAULT, CW_USEDEFAULT, NULL, NULL, NULL, NULL);
}

bool NotAnOverlay::RegisterWindowClass(std::wstring windowClassName) {
	WNDCLASSEX overlayWindowClass;
	SecureZeroMemory(&overlayWindowClass, sizeof(WNDCLASSEX));
	overlayWindowClass.cbClsExtra = NULL;
	overlayWindowClass.cbWndExtra = NULL;
	overlayWindowClass.cbSize = sizeof(WNDCLASSEX);
	overlayWindowClass.style = CS_HREDRAW | CS_VREDRAW;
	overlayWindowClass.lpfnWndProc = WindowProc; // Function that will be executed when the window receives a "message" (input). Required! (crashes if set to NULL)
	overlayWindowClass.hInstance = NULL;
	overlayWindowClass.hCursor = LoadCursor(NULL, IDC_ARROW);
	overlayWindowClass.hIcon = LoadIcon(0, IDI_APPLICATION);
	overlayWindowClass.hIconSm = LoadIcon(0, IDI_APPLICATION);
	overlayWindowClass.hbrBackground = NULL; // (HBRUSH)RGB(0, 0, 0)
	overlayWindowClass.lpszClassName = windowClassName.c_str(); // Class name to use with the Windows API function CreateWindow(Ex) to create the window
	overlayWindowClass.lpszMenuName = windowClassName.c_str();
	if (!RegisterClassEx(&overlayWindowClass))
		return false;
	else
		return true;
}

void NotAnOverlay::TreatWindowMessageQueue() {
	MSG msg;
	while (PeekMessage(&msg, NULL, 0, 0, PM_REMOVE)) {
		TranslateMessage(&msg);
		DispatchMessage(&msg);
	}
}

LRESULT CALLBACK NotAnOverlay::WindowProc(HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam) {
	switch (message) {
		case WM_DESTROY: {
			PostQuitMessage(0); // Exit the program if the window gets closed.
			exit(EXIT_SUCCESS);
			return EXIT_SUCCESS;
		} break;
		case WM_SIZE: {
			// GetClientRect(m_hwndNotOverlay, &m_windowSize);
		} break;
	}

	return DefWindowProc(hWnd, message, wParam, lParam); // Handle any messages the switch statement didn't
}

bool NotAnOverlay::SaveBitmap(LPCSTR filename, HBITMAP bmp, HPALETTE pal) {
	bool result = false;
	PICTDESC pd;

	pd.cbSizeofstruct = sizeof(PICTDESC);
	pd.picType = PICTYPE_BITMAP;
	pd.bmp.hbitmap = bmp;
	pd.bmp.hpal = pal;

	LPPICTURE picture;
	HRESULT res = OleCreatePictureIndirect(&pd, IID_IPicture, false,
		reinterpret_cast<void**>(&picture));

	if (!SUCCEEDED(res))
		return false;

	LPSTREAM stream;
	res = CreateStreamOnHGlobal(0, true, &stream);

	if (!SUCCEEDED(res))
	{
		picture->Release();
		return false;
	}

	LONG bytes_streamed;
	res = picture->SaveAsFile(stream, true, &bytes_streamed);

	HANDLE file = CreateFileA(filename, GENERIC_WRITE, FILE_SHARE_READ, 0, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, 0);

	if (!SUCCEEDED(res) || !file) {
		stream->Release();
		picture->Release();
		return false;
	}

	HGLOBAL mem = 0;
	GetHGlobalFromStream(stream, &mem);
	LPVOID data = GlobalLock(mem);

	DWORD bytes_written;

	result = !!WriteFile(file, data, bytes_streamed, &bytes_written, 0);
	result &= (bytes_written == static_cast<DWORD>(bytes_streamed));

	GlobalUnlock(mem);
	CloseHandle(file);

	stream->Release();
	picture->Release();

	return result;
}

bool NotAnOverlay::GetScreenResolution() {
	RECT desktop;
	const HWND hDesktop = GetDesktopWindow();
	if (!GetWindowRect(hDesktop, &desktop))
		return false;
	m_screenResolution.x = desktop.right;
	m_screenResolution.y = desktop.bottom;
	return true;
}
```

`NotAnOverlay/NotAnOverlay.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" ToolsVersion="15.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|Win32">
      <Configuration>Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <VCProjectVersion>15.0</VCProjectVersion>
    <ProjectGuid>{49CE407B-A6B3-4705-9466-06171E3D257E}</ProjectGuid>
    <Keyword>Win32Proj</Keyword>
    <RootNamespace>NotAnOverlay</RootNamespace>
    <WindowsTargetPlatformVersion>10.0.15063.0</WindowsTargetPlatformVersion>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v141</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v141</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v141</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v141</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="Shared">
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <LinkIncremental>true</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <LinkIncremental>true</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <LinkIncremental>false</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <LinkIncremental>false</LinkIncremental>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <ClCompile>
      <PrecompiledHeader>
      </PrecompiledHeader>
      <WarningLevel>Level3</WarningLevel>
      <Optimization>Disabled</Optimization>
      <PreprocessorDefinitions>WIN32;_DEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <ClCompile>
      <PrecompiledHeader>
      </PrecompiledHeader>
      <WarningLevel>Level3</WarningLevel>
      <Optimization>Disabled</Optimization>
      <PreprocessorDefinitions>_DEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <PrecompiledHeader>
      </PrecompiledHeader>
      <Optimization>MaxSpeed</Optimization>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <PreprocessorDefinitions>WIN32;NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <PrecompiledHeader>
      </PrecompiledHeader>
      <Optimization>MaxSpeed</Optimization>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <PreprocessorDefinitions>NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
    </Link>
  </ItemDefinitionGroup>
  <ItemGroup>
    <ClCompile Include="main.cpp" />
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="NotAnOverlay.hpp" />
    <ClInclude Include="PerfMgr.hpp" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>
```

`NotAnOverlay/NotAnOverlay.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="Source Files">
      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
      <Extensions>cpp;c;cc;cxx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
    </Filter>
    <Filter Include="Header Files">
      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
      <Extensions>h;hh;hpp;hxx;hm;inl;inc;xsd</Extensions>
    </Filter>
    <Filter Include="Resource Files">
      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav;mfcribbon-ms</Extensions>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="main.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="NotAnOverlay.hpp">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="PerfMgr.hpp">
      <Filter>Header Files</Filter>
    </ClInclude>
  </ItemGroup>
</Project>
```

`NotAnOverlay/PerfMgr.hpp`:

```hpp
#pragma once
#include <Windows.h>
#include <map>
#include <deque>
#include <iostream>

#define DEFAULT_TARGET_FPS 60
#define MAX_FRAMES_BETWEEN_NON_CRITICAL_OPS 6

#define MAX_TICK_ID 10 // Define how many different "ticks" the performance manager can manage (size of the int array)
#define ID_TICK_CPS 0
#define ID_TICK_FPS 1

using namespace std;

// The class FpsManager allows to see the overlay performance in FPS and set it
// (its data can be used to decide to skip rendering)
class PerfManager {
public:
	PerfManager::PerfManager();
	PerfManager::~PerfManager();

	int PerfManager::GetTicksPerSecond(int tickID = 0);
	int PerfManager::AddTick(int tickID = 0);
	// bool drawNextFrame(); // TODO
	void PerfManager::StartBenchmark(unsigned int benchmarkID = 0);
	int PerfManager::StopBenchmark(unsigned int benchmarkID = 0);
	void PerfManager::BalanceFPS();
	bool PerfManager::ShouldExecuteNonCritOps();
	bool PerfManager::ToggleLimitFps();

private:
	SYSTEMTIME m_sysTime;
	map<unsigned int, SYSTEMTIME> m_benchmarks;
	deque<int> m_execTimesLastSecond;
	int m_targetFps = DEFAULT_TARGET_FPS, m_maxFrameSpaceNonCrits = MAX_FRAMES_BETWEEN_NON_CRITICAL_OPS, m_currentFps = 0, m_framesThisSecond = 0, m_thisSecond = -1, m_msToWaitBetweenFrames = 15, m_execTimeLastFrame = 0;
	unsigned int m_frameNbr = 1, m_execNonCritOpsEachXFrames = 1;
	int m_tickCounting[MAX_TICK_ID] = { 0 }; // Used to increment every tick
	int m_tickCounts[MAX_TICK_ID] = { 0 }; // Updated every second (these are the values to be read for further display)
	bool m_limitFps = true;
};

PerfManager::PerfManager() { // Performance manager constructor
	GetSystemTime(&m_sysTime);
}

PerfManager::~PerfManager() { // Performance manager destructor

}

int PerfManager::GetTicksPerSecond(int tickID) { return m_tickCounts[tickID]; }

int PerfManager::AddTick(int tickID) {
	// Saving the frame number
	++m_frameNbr;
	if (m_frameNbr > m_targetFps)
		m_frameNbr = 1;

	GetSystemTime(&m_sysTime); // Refresh time
	if (m_sysTime.wSecond == m_thisSecond) { // Same second = add frame to counter
		++m_tickCounting[tickID];
		return m_tickCounting[tickID];
	}
	else { // Different second, update the ticks per second in the array for display and set ticks this second to 1
		m_thisSecond = m_sysTime.wSecond;
		m_tickCounts[tickID] = m_tickCounting[tickID];
		m_tickCounting[tickID] = 1;

		std::cout << "FPS: " << m_tickCounts[tickID] << std::endl;

		/* Should go in BalanceFPS?
		// TODO: To balance when to perform non-critical operations (scanning items and other static entities)
		m_execNonCritOpsEachXFrames = (unsigned int)ceil(m_targetFps / (m_tickCounts[tickID] + 1)); // For performance adjustments (+1 to avoid possibility to /0, not the best solution)
		if (m_execNonCritOpsEachXFrames > m_maxFrameSpaceNonCrits) // Checking if not above maximum
		m_execNonCritOpsEachXFrames = m_maxFrameSpaceNonCrits;
		*/

		return 1;
	}
}

void PerfManager::StartBenchmark(unsigned int benchmarkID) {
	SYSTEMTIME sysTimeStart;
	GetSystemTime(&sysTimeStart);
	m_benchmarks[benchmarkID] = sysTimeStart;
}

int PerfManager::StopBenchmark(unsigned int benchmarkID) {
	// Getting start and stop time
	SYSTEMTIME sysTimeStart, sysTimeStop;
	GetSystemTime(&sysTimeStop);
	sysTimeStart = m_benchmarks[benchmarkID];

	// Calculating time
	int startMs = (sysTimeStart.wSecond * 1000) + sysTimeStart.wMilliseconds;
	int stopMs = (sysTimeStop.wSecond * 1000) + sysTimeStop.wMilliseconds;

	if (startMs > stopMs) // Special case, if it was the end of a minute
		stopMs += 60000;

	m_execTimeLastFrame = stopMs - startMs;

	// Adding to the queue to calculate the average execution time over the last second
	m_execTimesLastSecond.push_front(m_execTimeLastFrame);
	if (m_execTimesLastSecond.size() > m_targetFps)
		m_execTimesLastSecond.pop_back();

	return m_execTimeLastFrame;
}

void PerfManager::BalanceFPS() {
	// If last frame took more than the maximum time to get the desired FPS, we don't wait
	if ((m_msToWaitBetweenFrames - m_execTimeLastFrame) < 0 || !m_limitFps)
		return;

	// Calculating average execution time over last second
	int totalExecTimeLastSec = 0, avgOver = 1;

	if (m_execTimesLastSecond.size() < m_targetFps)
		avgOver = m_execTimesLastSecond.size();
	else
		avgOver = m_targetFps;

	for (int i(0); i < avgOver; ++i)
		totalExecTimeLastSec += m_execTimesLastSecond[i];
	int avgTimePerCycleLastSec = ceil(totalExecTimeLastSec / avgOver);

	// Calculate the time that should be waited to smooth frames
	int timeToWait = m_msToWaitBetweenFrames - avgTimePerCycleLastSec;
	if (timeToWait > 0)
		Sleep(timeToWait);
}

bool PerfManager::ShouldExecuteNonCritOps() {
	// TODO: Make dynamic with m_execNonCritOpsEachXFrames
	if ((m_frameNbr % m_maxFrameSpaceNonCrits) == 0)
		return true;
	else
		return false;
}

bool PerfManager::ToggleLimitFps() {
	if (m_limitFps) {
		m_limitFps = false;
		return false;
	}
	else {
		m_limitFps = true;
		return true;
	}
}
```

`NotAnOverlay/main.cpp`:

```cpp
#include <Windows.h>
#include "NotAnOverlay.hpp"

int main() {
	NotAnOverlay overlay;

	while (true) {
		Sleep(10);
	}

	return EXIT_SUCCESS;
}
```

`README.md`:

```md
# NotAnOverlay

In video game hacking, being able to write and draw on top of the game’s frames allows uncountable ways to get new advantages, especially for ESP cheat (Extra Sensorial Perception) in which you can draw coloured boxes around players with their names, distance, weapons, health points and more, giving you an almost perfect situational awareness.

External cheats (external meaning that they run in a separate process) often use a straightforward system: creating a completely transparent window, without borders or menus, that stay always on top of others, with the same size as the game and at the same position.
This way one can simply draw whatever in this transparent window and for the user it will appear as if it is draw on top of the game’s frames themselves.
Here is how it’s done:

![External ESP overlay system flowchart](http://en.ciholas.fr/wp-content/uploads/sites/2/2017/12/External-ESP-common-design-flowchart-small.png)

Whether the overlays are detected or not has been an on-going controversial topic for a long time.
In my opinion overlays are detected, but one need to understand something, having one detected element in a cheat doesn’t mean that the whole cheat will be detected.
Imagine that the anti-cheat finds a window, same size and position of the game, transparent, always on top, etc… that’s suspicious right? But okay, some unknown application might do that, banning people on that only basis might lead to false positives and ruin the reputation of both the anti-cheat and the game.
Now let’s say that in addition to this suspicious window, the anti-cheat takes a look at the process owning this window with a simple call of GetWindowThreadProcessId and by taking a look at the system handles of this process, they notice that it has a process handle to the game with full access, despite the fact that the anti-cheat driver has callbacks that prevent this from happening.
Now it is beyond a simple oddity.
They could even make sure automatically that the handle is being used for cheating purposes by analysing what this process does, for example monitoring if it is running calls to ReadProcessMemory using the handle to the game frenetically, for example by placing hooks or with other methods.

Anyway, whatever is your opinion on this, I think we can all agree that doing without such a suspicious overlay window would be a good thing.
There has been interesting approaches, like for example leveraging applications whitelisted by anti-cheats having the approval to draw on top of game frames, such as Discord, FRAPS, TeamSpeak, NVIDIA, and many other gaming related software.
Another interesting approach is to use Direct Kernel Object Manipulation (DKOM) to remove all tracks of that window, making it impossible to find with common API functions.
I have started an Overwolf plugin but haven’t finished and I do not know if I will work again on that, but if I do, I’ll share that.

I thought a bit about other possible solutions to do without an overlay window.
An idea that come to most people’s mind is to do a 2D radar to locate enemies around, but let’s admit it: Once you have tasted a state of the art ESP with overlay, there’s not going back, I wouldn’t settle for less.
So I was looking for a way to have an overlay, but without overlay window.
Then I had an idea: Duplicating the game’s image in a window (classic, custom size, non-transparent, non-always-on-top, etc… to be undetectable because like any other window) and drawing the cheat overlay on top of that image.
I wanted it to be (1) efficient, it has to run smoothly, and (2) compatible with the classic overlay systems (some people use DirectX, others use OpenGL, GDI, and probably many others).
One way to allow this would be to have the frame of the game being the background of the window, then the rendered image of the cheat overlay would just be added on top of that.
To do that I used GDI functions, the main ones being GetDC, CreateCompatibleDC, CreateCompatibleBitmap, BitBlt, and StretchBlt.
I read several times that GDI was not very performent, so I was expecting something laggy, but in fact it runs absolutely smooth!
With DayZ Standalone it ran at about 160 FPS constant as you can see in the following video:

[![NotAnOverlay PoC live demo](https://img.youtube.com/vi/Jgcz5QRaQkI/0.jpg)](https://www.youtube.com/watch?v=Jgcz5QRaQkI)

It actually runs so smoothly that one can play by watching only the duplicated frame in the overlay window without problem.
I do not know if I will use this, but at least I know that this is definitely a viable solution.

```