Project Path: arc_tsoding_olive.c_7wmg8uvl

Source Tree:

```txt
arc_tsoding_olive.c_7wmg8uvl
├── LICENSE
├── README.md
├── assets
│   ├── CREDITS.txt
│   ├── lavastone-origin.png
│   ├── lavastone.png
│   ├── oldstone-origin.png
│   ├── oldstone.png
│   ├── olivec-200.png
│   ├── olivec.svg
│   ├── penger_obj
│   │   ├── author.txt
│   │   ├── penger.mtl
│   │   ├── penger.obj
│   │   └── penger.png
│   ├── tsodinCup.png
│   ├── tsodinCupLowPoly.obj
│   ├── tsodinPog.png
│   └── utahTeapot.obj
├── css
│   ├── index.css
│   └── reset.css
├── demos
│   ├── cup3d.c
│   ├── dots3d.c
│   ├── model3d.c
│   ├── penger3d.c
│   ├── squish.c
│   ├── teapot3d.c
│   ├── triangle.c
│   ├── triangle3d.c
│   ├── triangle3dTex.c
│   ├── triangleTex.c
│   └── vc.c
├── dev-deps
│   ├── arena.h
│   ├── nob.h
│   ├── stb_image.h
│   └── stb_image_write.h
├── docs
│   ├── 3d-projection.pdf
│   ├── 3d-projection.tex
│   ├── barycentric.pdf
│   └── barycentric.tex
├── fonts
│   ├── LibreBaskerville-Regular.ttf
│   └── OFL.txt
├── index.html
├── js
│   └── vc.js
├── nob.c
├── olive.c
├── test
│   ├── alpha_blending_expected.png
│   ├── barycentric_overflow_expected.png
│   ├── bilinear_interpolation_expected.png
│   ├── checker_example_expected.png
│   ├── circle_example_expected.png
│   ├── draw_line_expected.png
│   ├── empty_rect_expected.png
│   ├── fill_circle_expected.png
│   ├── fill_ellipse_expected.png
│   ├── fill_rect_expected.png
│   ├── fill_triangle_expected.png
│   ├── frame_expected.png
│   ├── hello_world_text_rendering_expected.png
│   ├── line_bug_offset_expected.png
│   ├── line_edge_cases_expected.png
│   ├── lines_circle_expected.png
│   ├── lines_example_expected.png
│   ├── sprite_blend_empty_rect_expected.png
│   ├── sprite_blend_expected.png
│   ├── sprite_blend_flip_cut_expected.png
│   ├── sprite_blend_flip_expected.png
│   ├── sprite_blend_null_expected.png
│   ├── sprite_blend_out_of_bounds_cut_expected.png
│   ├── sprite_blend_vs_copy_expected.png
│   ├── triangle_order_flip_expected.png
│   └── weird_triangle_bug_expected.png
├── test.c
├── tools
│   ├── obj2c.c
│   └── png2c.c
└── wasm
    ├── cup3d.wasm
    ├── dots3d.wasm
    ├── penger3d.wasm
    ├── squish.wasm
    ├── teapot3d.wasm
    ├── triangle.wasm
    ├── triangle3d.wasm
    ├── triangle3dTex.wasm
    └── triangleTex.wasm

```

`LICENSE`:

```
Copyright 2022 Alexey Kutepov <reximkut@gmail.com>

Permission is hereby granted, free of charge, to any person obtaining
a copy of this software and associated documentation files (the
"Software"), to deal in the Software without restriction, including
without limitation the rights to use, copy, modify, merge, publish,
distribute, sublicense, and/or sell copies of the Software, and to
permit persons to whom the Software is furnished to do so, subject to
the following conditions:

The above copyright notice and this permission notice shall be
included in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
```

`README.md`:

```md
# Olive.c

<p align="center">
<a href="https://tsoding.github.io/olive.c/"><img src="./assets/olivec-200.png"></a>
</p>

> [!WARNING]
> THIS LIBRARY IS A WORK IN PROGRESS! ANYTHING CAN CHANGE AT ANY MOMENT WITHOUT ANY NOTICE! USE THIS LIBRARY AT YOUR OWN RISK!

Simple graphics library that does not have any dependencies and renders everything into the given memory pixel by pixel.

Visit [https://tsoding.github.io/olive.c/](https://tsoding.github.io/olive.c/) to see some demos.

The library is not concerned with displaying the image. It only fills up the memory with pixels. It's up to you what to do with those pixels.

The name is pronounced as "olivets'" which is a Ukrainian word for "pencil" (["олівець"](https://translate.google.com/?sl=uk&tl=en&text=%D0%BE%D0%BB%D1%96%D0%B2%D0%B5%D1%86%D1%8C&op=translate)).

The library itself does not require any special building. You can simply copy-paste [./olive.c](./olive.c) to your project and `#include` it. (Because the truly reusable code is the one that you can simply copy-paste).

Olive.c is a classical [stb-style](https://github.com/nothings/stb) single header library. That is by default it acts like a header, but if you `#define OLIVEC_IMPLEMENTATION` prior including the library it acts like a source file. The `.c` extension might be confusing, but it's a part of the name of the library (why JavaScript people can use `.js` as part of the name of a library and I cannot?)

## Quick Example (Flag of Japan)

> [!WARNING]
> Always initialize your Canvas with a color that has Non-Zero Alpha Channel! A lot of functions use `olivec_blend_color()` function to blend with the Background which preserves the original Alpha of the Background. So you may easily end up with a result that is perceptually transparent if the Alpha is Zero.

*This example also uses [stb_image_write.h](https://raw.githubusercontent.com/nothings/stb/master/stb_image_write.h) to create the PNG image*

```c
// flag_jp.c
#define OLIVEC_IMPLEMENTATION
#include "olive.c"

#define STB_IMAGE_WRITE_IMPLEMENTATION
#include "stb_image_write.h"

#define WIDTH 900
#define HEIGHT 600

uint32_t pixels[WIDTH*HEIGHT];

int main(void)
{
    Olivec_Canvas oc = olivec_canvas(pixels, WIDTH, HEIGHT, WIDTH);
    // Taken from https://upload.wikimedia.org/wikipedia/en/9/9e/Flag_of_Japan.svg
    olivec_fill(oc, 0xFFFFFFFF);
    olivec_circle(oc, WIDTH/2, HEIGHT/2, 180, 0xFF2D00BC);

    const char *file_path = "flag_jp.png";
    if (!stbi_write_png(file_path, WIDTH, HEIGHT, 4, pixels, sizeof(uint32_t)*WIDTH)) {
        fprintf(stderr, "ERROR: could not write %s\n", file_path);
        return 1;
    }
    return 0;
}
```

## Building the Tests and Demos

Even though the library does not require any special building, the tests and demos do. We use [nob](https://github.com/tsoding/nob.h) build system:

```console
$ clang -o nob nob.c
$ ./nob
```

## Tests

Run the tests:

```console
$ ./build/test run
```

If the expected behavior of the library has changed in the way that breaks current test cases, you probably want to update them:

```console
$ ./build/test update
```

For more info see the help:

```console
$ ./build/test help
```

## Demos

The source code for demos is located at [demos](./demos/). Each demo is compiled for 3 different "platforms" that is 3 different ways to display the generated images:

1. [SDL](https://www.libsdl.org/) -- displays the images via [SDL_Texture](https://wiki.libsdl.org/SDL_Texture).
2. Terminal -- converts the images into ASCII art and prints them into the terminal.
3. WASM -- displays the images in [HTML5 canvas](https://developer.mozilla.org/en-US/docs/Web/API/Canvas_API)

To run the SDL version of a demo do

```console
$ ./build/demos/<demo>.sdl
```

To run the Terminal version of a demo do

```console
$ ./build/demos/<demo>.term
```

To run the WASM versions of the demos from [https://tsoding.github.io/olive.c/](https://tsoding.github.io/olive.c/) locally do

```console
$ python3 -m http.server 6969
$ iexplore.exe http://localhost:6969/
```

### Virtual Console

The support for several platforms is provided by Demo Virtual Console. It is implemented in two files:

- [./demos/vc.c](./demos/vc.c) -- the C runtime required by all platforms.
- [./js/vc.js](./js/vc.js) -- the JavaScript runtime for running in a browser when compiled to WebAssembly.

The Demo Virtual Console is not part of the main library and is designed specifically for demos. (I do consider including it into the main library, 'cause it looks pretty useful. The library is still in development).

```

`assets/CREDITS.txt`:

```txt
- https://opengameart.org/content/handpainted-stone-texture
  - lavastone-origin.png
  - lavastone.png
  - oldstone-origin.png
  - oldstone.png

```

`assets/olivec.svg`:

```svg
<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!-- Created with Inkscape (http://www.inkscape.org/) -->

<svg
   xmlns:dc="http://purl.org/dc/elements/1.1/"
   xmlns:cc="http://creativecommons.org/ns#"
   xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#"
   xmlns:svg="http://www.w3.org/2000/svg"
   xmlns="http://www.w3.org/2000/svg"
   xmlns:sodipodi="http://sodipodi.sourceforge.net/DTD/sodipodi-0.dtd"
   xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape"
   width="536.70093"
   height="746.5365"
   viewBox="0 0 142.00212 197.52113"
   version="1.1"
   id="svg8"
   inkscape:version="0.92.4 (5da689c313, 2019-01-14)"
   sodipodi:docname="olivec.svg">
  <defs
     id="defs2" />
  <sodipodi:namedview
     id="base"
     pagecolor="#ffffff"
     bordercolor="#666666"
     borderopacity="1.0"
     inkscape:pageopacity="0.0"
     inkscape:pageshadow="2"
     inkscape:zoom="0.69999999"
     inkscape:cx="-110.06677"
     inkscape:cy="310.68659"
     inkscape:document-units="mm"
     inkscape:current-layer="layer1"
     showgrid="false"
     inkscape:window-width="1920"
     inkscape:window-height="1035"
     inkscape:window-x="0"
     inkscape:window-y="22"
     inkscape:window-maximized="0"
     units="px"
     inkscape:snap-bbox="true"
     inkscape:snap-global="false"
     showguides="false"
     fit-margin-top="0"
     fit-margin-left="0"
     fit-margin-right="0"
     fit-margin-bottom="0" />
  <metadata
     id="metadata5">
    <rdf:RDF>
      <cc:Work
         rdf:about="">
        <dc:format>image/svg+xml</dc:format>
        <dc:type
           rdf:resource="http://purl.org/dc/dcmitype/StillImage" />
        <dc:title />
      </cc:Work>
    </rdf:RDF>
  </metadata>
  <g
     inkscape:label="Layer 1"
     inkscape:groupmode="layer"
     id="layer1"
     transform="translate(-108.00417,-52.979386)">
    <path
       style="opacity:1;fill:#2a9700;fill-opacity:1;stroke:#000000;stroke-width:12.07900047;stroke-linecap:round;stroke-miterlimit:4;stroke-dasharray:none;stroke-dashoffset:0;stroke-opacity:1"
       d="m 116.84547,122.53431 c -13.06236,-12.04766 21.24645,-25.288669 64.26763,-14.59905 29.18058,7.25062 59.5133,23.57306 55.58501,34.66395 -3.9283,11.09092 -36.03445,11.7583 -65.52385,5.9403 -25.99668,-5.12887 -42.66029,-15.24314 -54.32879,-26.0052 z"
       id="path889"
       inkscape:connector-curvature="0"
       sodipodi:nodetypes="sssss" />
    <path
       style="opacity:1;fill:#36c000;fill-opacity:1;stroke:#000000;stroke-width:12.07900047;stroke-linecap:round;stroke-miterlimit:4;stroke-dasharray:none;stroke-dashoffset:0;stroke-opacity:1"
       d="m 158.31458,67.145084 c -2.35876,-17.638624 32.46426,-5.797239 58.7225,30.021867 17.81054,24.295519 30.7209,56.300729 20.62683,62.301719 -10.09406,6.00101 -35.20404,-14.08799 -54.16571,-37.48093 -16.71594,-20.62225 -23.0766,-39.086191 -25.18362,-54.842656 z"
       id="path889-6"
       inkscape:connector-curvature="0"
       sodipodi:nodetypes="sssss" />
    <path
       style="opacity:1;fill:#8cb300;fill-opacity:1;stroke:#000000;stroke-width:12.07872391;stroke-linecap:round;stroke-miterlimit:4;stroke-dasharray:none;stroke-dashoffset:0;stroke-opacity:1"
       d="m 230.76815,200.08424 c -18.42948,24.60682 -37.94547,34.92079 -57.27473,24.95914 -19.32924,-9.96165 -21.30014,-29.84644 -12.72266,-61.03345 8.16473,-29.68633 28.65512,-49.5676 61.11753,-32.85267 30.78373,15.85058 24.98928,47.41791 8.87986,68.92698 z"
       id="path834"
       inkscape:connector-curvature="0"
       sodipodi:nodetypes="sssss" />
    <path
       style="fill:#000000;fill-opacity:0.26732674;fill-rule:evenodd;stroke:none;stroke-width:0.21305525px;stroke-linecap:butt;stroke-linejoin:miter;stroke-opacity:1"
       d="m 167.2912,158.55455 c 22.89131,-39.95311 63.90421,-15.99824 62.25421,11.29885 -0.95088,15.73099 -17.02201,39.57963 -27.62086,41.61531 -2.82552,-16.03064 -24.53892,-27.45311 -41.15534,-10.4343 -7.76705,5.87658 -1.67597,27.62001 -1.67597,27.62001 0,0 29.38564,10.58992 49.70864,-5.93155 20.323,-16.52148 40.5164,-49.35649 38.23438,-56.40819 -7.20587,-15.50124 -24.22371,-35.06579 -38.47081,-39.98079 -6.82029,-2.35289 -20.37921,-2.17075 -28.32749,4.90487 -9.41029,8.37713 -12.94676,27.31579 -12.94676,27.31579 z"
       id="path1007"
       inkscape:connector-curvature="0"
       sodipodi:nodetypes="cscccscssc" />
    <path
       style="fill:none;fill-opacity:1;fill-rule:evenodd;stroke:#000000;stroke-width:12.07900047;stroke-linecap:butt;stroke-linejoin:miter;stroke-miterlimit:4;stroke-dasharray:none;stroke-opacity:1"
       d="m 192.13825,229.12052 c -26.80631,24.14882 -34.01344,19.85806 -29.00693,-14.19196"
       id="path867-6-0"
       inkscape:connector-curvature="0"
       sodipodi:nodetypes="cc" />
    <path
       style="opacity:1;fill:none;fill-opacity:1;stroke:#000000;stroke-width:12.07900047;stroke-linecap:round;stroke-miterlimit:4;stroke-dasharray:none;stroke-dashoffset:0;stroke-opacity:1"
       d="m 230.80193,199.87307 c -18.42948,24.60682 -37.94547,34.92079 -57.27474,24.95915 -19.32924,-9.96166 -21.30015,-29.84645 -12.72266,-61.03347 8.16474,-29.68632 28.65513,-49.5676 61.11754,-32.85266 30.78372,15.85057 24.98927,47.4179 8.87986,68.92698 z"
       id="path834-3"
       inkscape:connector-curvature="0"
       sodipodi:nodetypes="sssss" />
    <path
       style="fill:#eff650;fill-opacity:1;fill-rule:evenodd;stroke:#000000;stroke-width:4.0262413;stroke-linecap:butt;stroke-linejoin:miter;stroke-miterlimit:4;stroke-dasharray:none;stroke-opacity:1"
       d="m 165.72101,207.88523 c 3.14905,-7.23664 11.92187,-9.11684 20.09821,-5.44563 8.17635,3.67127 12.66002,11.50375 8.90872,19.6376 -26.80631,24.14879 -34.01345,19.85806 -29.00693,-14.19197 z"
       id="path867-6"
       inkscape:connector-curvature="0"
       sodipodi:nodetypes="cscc" />
    <path
       style="fill:#ff3232;fill-opacity:1;fill-rule:evenodd;stroke:#000000;stroke-width:4.0262413;stroke-linecap:butt;stroke-linejoin:miter;stroke-miterlimit:4;stroke-dasharray:none;stroke-opacity:1"
       d="m 163.99568,226.49686 c 1.23452,-2.88013 6.46911,-3.34495 9.67446,-1.88383 3.20536,1.46114 6.85296,6.2793 5.38235,9.51652 -11.26478,8.47712 -15.60208,6.10798 -15.05681,-7.63269 z"
       id="path867-6-3"
       inkscape:connector-curvature="0"
       sodipodi:nodetypes="cscc" />
    <circle
       style="opacity:1;fill:#ffffff;fill-opacity:1;stroke:none;stroke-width:2.83005381;stroke-linecap:round;stroke-miterlimit:4;stroke-dasharray:none;stroke-dashoffset:0;stroke-opacity:1"
       id="path990"
       cx="224.54573"
       cy="148.55684"
       r="7.3808813"
       transform="rotate(1.4214233)" />
    <circle
       style="opacity:1;fill:#ffffff;fill-opacity:1;stroke:none;stroke-width:2.83005381;stroke-linecap:round;stroke-miterlimit:4;stroke-dasharray:none;stroke-dashoffset:0;stroke-opacity:1"
       id="path990-9"
       cx="210.9617"
       cy="155.05789"
       r="3.5299869"
       transform="rotate(1.4214233)" />
  </g>
</svg>

```

`assets/penger_obj/author.txt`:

```txt
https://github.com/Max-Kawula/penger-obj

```

`assets/penger_obj/penger.mtl`:

```mtl
# Blender 4.2.1 LTS MTL File: 'raylib-penger.blend'
# www.blender.org

newmtl penger_mat
Ns 250.000000
Ka 1.000000 1.000000 1.000000
Ks 0.500000 0.500000 0.500000
Ke 0.000000 0.000000 0.000000
Ni 1.500000
d 1.000000
illum 2
map_Kd penger.png

```

`assets/penger_obj/penger.obj`:

```obj
# Blender 4.2.1 LTS
# www.blender.org
mtllib penger.mtl
o penger
v -0.086914 0.777547 0.400041
v -0.069555 0.829698 0.376422
v -0.125429 0.805056 0.175577
v -0.087431 0.859323 0.182228
v 0.086914 0.777547 0.400041
v 0.069555 0.829698 0.376422
v 0.125429 0.805056 0.175577
v 0.087431 0.859323 0.182228
v -0.162461 0.831177 0.163170
v -0.120032 0.785356 0.287080
v 0.000000 0.816913 0.150254
v 0.000000 0.931152 0.159026
v 0.162461 0.831177 0.163170
v 0.120032 0.785356 0.287080
v 0.038632 0.851515 0.295188
v 0.112575 0.800152 0.416327
v 0.000000 0.783376 0.423906
v 0.000000 0.839429 0.443461
v -0.038632 0.851515 0.295188
v 0.000000 0.833645 0.122512
v 0.151316 0.813187 0.289445
v 0.000000 0.807518 0.456379
v 0.000000 0.799713 0.285755
v 0.000000 0.863275 0.294437
v -0.112575 0.800152 0.416327
v 0.093738 0.749308 0.407523
v 0.080099 0.856611 0.384454
v 0.132657 0.778000 0.164820
v 0.105284 0.882964 0.177497
v -0.151316 0.813187 0.289445
v 0.000000 0.790410 0.136199
v 0.000000 0.960646 0.153539
v 0.188457 0.829885 0.148254
v 0.129281 0.756856 0.285586
v 0.051895 0.877119 0.303468
v 0.135150 0.799588 0.436077
v 0.000000 0.755364 0.434645
v 0.000000 0.866105 0.457187
v -0.093738 0.749308 0.407523
v 0.000000 0.828010 0.093046
v 0.180592 0.816698 0.294976
v 0.000000 0.810560 0.486224
v 0.000000 0.769968 0.281850
v 0.000000 0.890575 0.306875
v -0.080099 0.856611 0.384454
v -0.132657 0.778000 0.164820
v -0.105284 0.882964 0.177497
v -0.188457 0.829885 0.148254
v -0.129281 0.756856 0.285586
v -0.051895 0.877119 0.303468
v -0.135150 0.799588 0.436077
v -0.180592 0.816698 0.294976
v 0.118885 0.899961 0.192279
v 0.100036 0.933856 0.198983
v 0.102966 0.896398 0.165539
v 0.084118 0.930293 0.172243
v 0.176608 0.939909 0.152593
v 0.157760 0.973804 0.159297
v 0.160690 0.936346 0.125853
v 0.141841 0.970241 0.132557
v 0.106666 0.890088 0.182523
v 0.104880 0.912922 0.202910
v 0.083687 0.931411 0.190696
v 0.085473 0.908578 0.170310
v 0.132149 0.912268 0.142032
v 0.109170 0.953590 0.150205
v 0.155846 0.957280 0.121927
v 0.177039 0.938791 0.134140
v 0.154060 0.980114 0.142313
v 0.175253 0.961624 0.154527
v 0.151556 0.916612 0.174632
v 0.128577 0.957934 0.182805
v 0.081904 0.901564 0.195735
v 0.116999 0.932110 0.139970
v 0.178822 0.968638 0.129101
v 0.143727 0.938092 0.184867
v 0.146186 0.906646 0.156790
v 0.114539 0.963556 0.168046
v -0.118885 0.899961 0.192279
v -0.100036 0.933856 0.198983
v -0.102966 0.896398 0.165539
v -0.084118 0.930293 0.172243
v -0.176608 0.939909 0.152593
v -0.157760 0.973804 0.159297
v -0.160690 0.936346 0.125853
v -0.141841 0.970241 0.132557
v -0.106666 0.890088 0.182523
v -0.104880 0.912922 0.202910
v -0.083687 0.931411 0.190696
v -0.085473 0.908578 0.170310
v -0.132149 0.912268 0.142032
v -0.109170 0.953590 0.150205
v -0.155846 0.957280 0.121927
v -0.177039 0.938791 0.134140
v -0.154060 0.980114 0.142313
v -0.175253 0.961624 0.154527
v -0.151556 0.916612 0.174632
v -0.128577 0.957934 0.182805
v -0.081904 0.901564 0.195735
v -0.116999 0.932110 0.139970
v -0.178822 0.968638 0.129102
v -0.143727 0.938092 0.184867
v -0.146187 0.906646 0.156790
v -0.114539 0.963556 0.168046
v 0.116485 1.100505 0.141727
v 0.261417 0.200098 0.348366
v -0.116485 1.100505 0.141727
v -0.261417 0.200098 0.348366
v 0.112046 1.157167 -0.052576
v 0.239249 0.214387 -0.195621
v -0.112046 1.157167 -0.052576
v -0.239249 0.214387 -0.195621
v 0.182365 0.086114 -0.130600
v -0.182365 0.086114 -0.130600
v 0.185370 0.088873 0.285766
v -0.185370 0.088873 0.285766
v -0.000000 0.219302 -0.288600
v 0.000000 1.185597 -0.059119
v -0.000000 0.197646 0.418056
v 0.000000 0.073265 -0.175525
v -0.000000 1.116801 0.172179
v 0.346767 0.186055 0.082211
v 0.134460 1.152623 0.053817
v 0.226383 0.065407 0.081386
v 0.000000 0.093950 0.064396
v -0.000000 1.202832 0.076074
v 0.148239 0.999868 -0.129503
v 0.167399 0.717376 -0.179106
v 0.000000 1.010360 -0.177507
v 0.000000 0.722228 -0.243510
v 0.000000 0.078977 0.303086
v -0.346767 0.186055 0.082211
v -0.134460 1.152623 0.053817
v 0.253877 0.706739 -0.012612
v 0.214625 0.979434 0.003080
v 0.158129 0.950290 0.133907
v 0.188613 0.688153 0.148241
v 0.000000 0.944652 0.202967
v -0.000000 0.689861 0.237317
v -0.226383 0.065407 0.081386
v 0.228074 0.440323 -0.205451
v 0.000000 0.444399 -0.288645
v -0.000000 0.422331 0.380767
v -0.148239 0.999868 -0.129503
v -0.167399 0.717376 -0.179106
v 0.336477 0.428624 0.037431
v 0.258730 0.418837 0.294948
v -0.253877 0.706739 -0.012612
v -0.214625 0.979434 0.003080
v -0.158129 0.950290 0.133907
v -0.188613 0.688153 0.148241
v -0.228074 0.440323 -0.205451
v -0.336477 0.428624 0.037431
v -0.258730 0.418837 0.294948
v 0.066239 1.177571 -0.057217
v 0.213490 0.131626 -0.165516
v 0.128870 0.219724 -0.267035
v 0.106735 0.077250 -0.160566
v 0.000000 0.126377 -0.249661
v 0.314673 0.198293 -0.071136
v -0.314673 0.198293 -0.071136
v 0.210922 0.071390 -0.043983
v 0.000000 0.076945 -0.065328
v -0.244201 0.319222 -0.207684
v 0.126667 1.163471 -0.006633
v -0.195294 0.991192 -0.068821
v 0.000000 1.211143 0.010063
v -0.213490 0.131626 -0.165516
v 0.071185 1.191313 0.070402
v -0.155241 0.865055 -0.158770
v 0.303068 0.103034 0.087021
v -0.132112 1.102600 -0.089009
v 0.120944 0.077310 0.070511
v 0.183037 1.081878 0.028539
v 0.132112 1.102600 -0.089009
v 0.155241 0.865055 -0.158770
v 0.244201 0.319222 -0.207684
v 0.000000 1.117590 -0.123992
v 0.000000 0.872508 -0.215321
v 0.000000 0.325970 -0.298421
v 0.103174 0.687991 0.210662
v 0.000000 0.301556 0.419635
v -0.294693 0.565372 0.007647
v -0.129550 1.127979 0.107967
v 0.294693 0.565372 0.007647
v 0.232020 0.849539 -0.013046
v 0.000000 0.823920 0.208490
v 0.088589 0.720688 -0.227407
v 0.079730 1.007125 -0.165927
v -0.232020 0.849539 -0.013046
v 0.195294 0.991192 -0.068821
v 0.226314 0.713436 -0.101955
v 0.170260 0.826295 0.126748
v -0.000000 1.042220 0.194351
v 0.138605 1.045492 0.141718
v -0.210922 0.071390 -0.043983
v 0.224239 0.127127 0.324377
v -0.000000 0.118600 0.379001
v 0.107381 0.082266 0.299738
v 0.069123 1.112108 0.162110
v 0.144110 0.200197 0.404857
v 0.273464 0.299769 0.340419
v 0.086530 0.945098 0.182669
v -0.170260 0.826295 0.126748
v 0.000000 1.170466 0.131824
v -0.226314 0.713436 -0.101955
v 0.129550 1.127979 0.107967
v -0.126667 1.163471 -0.006633
v 0.240899 0.696199 0.072126
v 0.202094 0.963683 0.072293
v -0.224239 0.127127 0.324377
v 0.196495 0.573973 -0.194947
v 0.000000 0.577321 -0.268617
v -0.000000 0.553716 0.306623
v 0.356649 0.298828 0.064475
v 0.223708 0.550083 0.216822
v 0.302413 0.435133 -0.098045
v -0.138605 1.045492 0.141718
v 0.143359 0.420422 0.361124
v -0.273464 0.299769 0.340419
v 0.122283 0.443412 -0.268697
v 0.323489 0.422181 0.178606
v -0.183037 1.081878 0.028539
v 0.211567 0.074486 0.204949
v 0.329913 0.190801 0.232998
v -0.303068 0.103034 0.087021
v 0.000000 0.083871 0.193289
v -0.240899 0.696199 0.072126
v -0.202094 0.963683 0.072293
v -0.196495 0.573973 -0.194947
v -0.356649 0.298828 0.064475
v -0.223708 0.550083 0.216822
v -0.302413 0.435133 -0.098045
v -0.323489 0.422181 0.178606
v -0.211567 0.074486 0.204949
v -0.329913 0.190801 0.232998
v -0.120944 0.077310 0.070511
v -0.128870 0.219724 -0.267035
v -0.106735 0.077250 -0.160566
v -0.071185 1.191312 0.070402
v -0.103174 0.687991 0.210662
v -0.144110 0.200197 0.404857
v -0.066239 1.177571 -0.057217
v -0.079730 1.007125 -0.165927
v -0.088589 0.720688 -0.227407
v -0.069123 1.112108 0.162110
v -0.107381 0.082266 0.299738
v -0.086530 0.945098 0.182669
v -0.143359 0.420422 0.361124
v -0.122283 0.443412 -0.268697
v -0.116187 0.130914 -0.229604
v -0.072661 1.112795 -0.116367
v 0.116187 0.130913 -0.229604
v 0.113112 0.075394 0.196042
v 0.218688 0.836754 0.060131
v -0.082517 0.870222 -0.201199
v -0.342146 0.297255 0.218515
v -0.277483 0.115220 -0.052960
v 0.342146 0.297255 0.218515
v -0.123321 0.551288 0.282574
v 0.104612 0.576285 -0.250504
v -0.263362 0.570961 -0.103638
v 0.072661 1.112795 -0.116367
v 0.068288 1.200296 0.006932
v -0.218688 0.836754 0.060131
v -0.068288 1.200296 0.006932
v 0.092843 0.823418 0.183578
v 0.277483 0.115220 -0.052960
v -0.092843 0.823418 0.183578
v 0.114344 0.069341 -0.055794
v -0.069793 1.161151 0.124576
v 0.123321 0.551288 0.282574
v -0.113112 0.075394 0.196042
v 0.123369 0.124214 0.369703
v 0.069793 1.161151 0.124576
v -0.169024 1.094663 -0.036361
v -0.151487 0.301276 0.403451
v 0.082517 0.870222 -0.201199
v 0.284665 0.113243 0.223581
v -0.284665 0.113243 0.223581
v -0.077124 1.041621 0.179388
v -0.123369 0.124214 0.369703
v 0.322028 0.308268 -0.086948
v -0.114344 0.069341 -0.055794
v 0.169024 1.094663 -0.036361
v 0.208363 0.858708 -0.090994
v 0.077124 1.041621 0.179388
v -0.322028 0.308268 -0.086948
v 0.173487 1.062450 0.090260
v 0.263362 0.570961 -0.103638
v -0.173487 1.062450 0.090260
v -0.131368 0.324783 -0.277201
v -0.208363 0.858708 -0.090994
v 0.151487 0.301276 0.403451
v -0.282070 0.556411 0.120093
v 0.131368 0.324783 -0.277201
v 0.282071 0.556411 0.120093
v -0.104612 0.576285 -0.250504
v 0.139456 1.115482 0.170848
v 0.287271 0.189966 0.377156
v -0.139456 1.115482 0.170848
v -0.287271 0.189966 0.377156
v 0.133667 1.185114 -0.071325
v 0.266366 0.203725 -0.223025
v -0.133667 1.185114 -0.071325
v -0.266366 0.203726 -0.223025
v 0.195667 0.051247 -0.144999
v -0.195667 0.051247 -0.144999
v 0.194474 0.052243 0.299008
v -0.194474 0.052243 0.299008
v 0.000000 0.209464 -0.327372
v 0.000000 1.219137 -0.080914
v 0.000000 0.188516 0.457000
v -0.000000 0.035680 -0.189215
v 0.000000 1.134596 0.208003
v 0.384990 0.174395 0.080468
v 0.162868 1.179727 0.061455
v 0.235551 0.026472 0.081467
v 0.000000 0.053964 0.065479
v -0.000000 1.240713 0.088920
v 0.173912 1.011387 -0.157932
v 0.193708 0.724703 -0.208332
v -0.000000 1.024361 -0.214977
v 0.000000 0.729344 -0.282872
v 0.000000 0.040320 0.313365
v -0.384990 0.174395 0.080468
v -0.162868 1.179727 0.061455
v 0.292852 0.715413 -0.014998
v 0.253766 0.987671 0.002714
v 0.185951 0.952824 0.162535
v 0.215515 0.701473 0.174678
v 0.000000 0.946738 0.242913
v 0.000000 0.703927 0.274763
v -0.235551 0.026472 0.081467
v 0.255368 0.446432 -0.234047
v -0.000000 0.449117 -0.328366
v 0.000000 0.439027 0.417116
v -0.173912 1.011387 -0.157932
v -0.193708 0.724703 -0.208332
v 0.375424 0.437400 0.034948
v 0.284700 0.435181 0.320607
v -0.292852 0.715413 -0.014998
v -0.253766 0.987671 0.002714
v -0.185951 0.952824 0.162535
v -0.215515 0.701473 0.174678
v -0.255368 0.446432 -0.234047
v -0.375424 0.437400 0.034948
v -0.284700 0.435181 0.320607
v 0.076969 1.209939 -0.078126
v 0.236028 0.108130 -0.188755
v 0.142717 0.209637 -0.303181
v 0.112677 0.040335 -0.174778
v 0.000000 0.101844 -0.281254
v 0.350053 0.187057 -0.086034
v -0.350053 0.187057 -0.086034
v 0.222273 0.033577 -0.050412
v -0.000000 0.036973 -0.063835
v -0.272234 0.318950 -0.236216
v 0.153140 1.192878 -0.012504
v -0.230594 1.001151 -0.084781
v 0.000000 1.250939 0.006027
v -0.236028 0.108130 -0.188755
v 0.085715 1.226738 0.081975
v -0.181373 0.872182 -0.188204
v 0.331447 0.074854 0.086304
v -0.156519 1.122257 -0.113866
v 0.117699 0.037449 0.071304
v 0.219507 1.098061 0.031380
v 0.156519 1.122257 -0.113866
v 0.181373 0.872182 -0.188204
v 0.272234 0.318950 -0.236216
v -0.000000 1.140332 -0.156898
v 0.000000 0.881317 -0.254339
v 0.000000 0.325735 -0.338420
v 0.118953 0.701990 0.244648
v 0.000000 0.307976 0.459117
v -0.332953 0.576790 0.005233
v -0.156442 1.149940 0.127831
v 0.332953 0.576790 0.005233
v 0.271568 0.855224 -0.014936
v 0.000000 0.828915 0.248177
v 0.102444 0.727876 -0.264236
v 0.092320 1.020357 -0.201514
v -0.271568 0.855224 -0.014936
v 0.230594 1.001151 -0.084781
v 0.261398 0.720992 -0.119618
v 0.198368 0.831051 0.154807
v 0.000000 1.049056 0.233763
v 0.164996 1.052710 0.170897
v -0.222273 0.033577 -0.050412
v 0.243011 0.100535 0.347626
v 0.000000 0.091090 0.408039
v 0.110234 0.044142 0.311504
v 0.081739 1.129230 0.195987
v 0.154778 0.190977 0.442290
v 0.300922 0.305702 0.368894
v 0.102604 0.946974 0.219249
v -0.198368 0.831051 0.154807
v -0.000000 1.200544 0.158192
v -0.261398 0.720992 -0.119618
v 0.156442 1.149940 0.127831
v -0.153139 1.192878 -0.012504
v 0.276552 0.707282 0.086480
v 0.238355 0.968905 0.088351
v -0.243011 0.100535 0.347626
v 0.223019 0.582269 -0.223716
v 0.000000 0.583858 -0.308079
v 0.000000 0.573428 0.341429
v 0.396566 0.299805 0.062092
v 0.248899 0.569216 0.241302
v 0.338439 0.442069 -0.113985
v -0.164996 1.052710 0.170897
v 0.155245 0.437577 0.395248
v -0.300922 0.305702 0.368894
v 0.136150 0.448614 -0.305854
v 0.359578 0.434799 0.190369
v -0.219507 1.098061 0.031380
v 0.220460 0.035971 0.211073
v 0.365966 0.179385 0.246030
v -0.331447 0.074854 0.086304
v -0.000000 0.043880 0.192436
v -0.276552 0.707282 0.086480
v -0.238355 0.968905 0.088351
v -0.223019 0.582269 -0.223716
v -0.396566 0.299805 0.062092
v -0.248899 0.569216 0.241302
v -0.338439 0.442069 -0.113985
v -0.359578 0.434799 0.190369
v -0.220460 0.035971 0.211073
v -0.365966 0.179384 0.246030
v -0.117699 0.037449 0.071304
v -0.142717 0.209637 -0.303181
v -0.112677 0.040335 -0.174778
v -0.085715 1.226738 0.081975
v -0.118953 0.701990 0.244648
v -0.154778 0.190977 0.442290
v -0.076969 1.209939 -0.078126
v -0.092320 1.020357 -0.201514
v -0.102444 0.727876 -0.264236
v -0.081739 1.129230 0.195987
v -0.110234 0.044142 0.311504
v -0.102604 0.946974 0.219249
v -0.155245 0.437577 0.395248
v -0.136150 0.448614 -0.305854
v -0.127815 0.107103 -0.259568
v -0.083673 1.134534 -0.148087
v 0.127815 0.107103 -0.259568
v 0.111491 0.035439 0.197029
v 0.255177 0.841892 0.075693
v -0.096035 0.878509 -0.237922
v -0.380059 0.300592 0.230823
v -0.305465 0.089413 -0.065249
v 0.380059 0.300592 0.230823
v -0.136479 0.571296 0.314614
v 0.118420 0.583400 -0.287365
v -0.298474 0.580339 -0.120346
v 0.083673 1.134534 -0.148087
v 0.081319 1.237915 0.003058
v -0.255177 0.841892 0.075693
v -0.081319 1.237915 0.003058
v 0.109808 0.828218 0.219483
v 0.305465 0.089413 -0.065249
v -0.109808 0.828218 0.219483
v 0.113657 0.029350 -0.056297
v -0.083372 1.189810 0.148954
v 0.136479 0.571296 0.314614
v -0.111491 0.035439 0.197029
v 0.130968 0.097527 0.398513
v 0.083372 1.189810 0.148954
v -0.202781 1.112807 -0.047817
v -0.163077 0.307992 0.441141
v 0.096035 0.878509 -0.237922
v 0.310921 0.085245 0.234838
v -0.310921 0.085245 0.234838
v -0.091241 1.047897 0.216284
v -0.130968 0.097527 0.398513
v 0.358889 0.308169 -0.102481
v -0.113657 0.029350 -0.056297
v 0.202781 1.112807 -0.047817
v 0.243685 0.864892 -0.108716
v 0.091241 1.047897 0.216284
v -0.358889 0.308169 -0.102481
v 0.207788 1.074204 0.107150
v 0.298474 0.580339 -0.120346
v -0.207788 1.074204 0.107150
v -0.145457 0.324547 -0.314637
v -0.243685 0.864892 -0.108716
v 0.163077 0.307992 0.441141
v -0.316786 0.571835 0.132619
v 0.145457 0.324547 -0.314637
v 0.316786 0.571835 0.132619
v -0.118420 0.583400 -0.287365
v -0.508828 0.011263 0.156039
v -0.522541 0.089935 0.161508
v -0.282585 0.011263 -0.115427
v -0.282585 0.190227 -0.115427
v -0.361756 0.011263 0.278610
v -0.364664 0.089935 0.293084
v -0.135514 0.011263 0.007144
v -0.135514 0.190227 0.007144
v -0.411821 0.004267 0.006876
v -0.549731 0.044418 0.172353
v -0.411821 0.211204 0.006876
v -0.273911 0.044418 -0.158601
v -0.184261 0.004267 -0.083886
v -0.184261 0.211204 -0.083886
v -0.094610 0.044418 -0.009170
v -0.232520 0.004267 0.156307
v -0.232520 0.211204 0.156307
v -0.370430 0.044418 0.321783
v -0.460081 0.004267 0.247068
v -0.477521 0.103880 0.267995
v -0.445638 0.044418 -0.021308
v -0.132239 0.044418 -0.146306
v -0.198703 0.044418 0.184490
v -0.512102 0.044418 0.309488
v -0.322171 -0.010414 0.081591
v -0.322171 0.255226 0.081591
v 0.508827 0.011263 0.156039
v 0.522541 0.089935 0.161508
v 0.282585 0.011263 -0.115427
v 0.282585 0.190227 -0.115427
v 0.361756 0.011263 0.278610
v 0.364664 0.089935 0.293084
v 0.135514 0.011263 0.007144
v 0.135514 0.190227 0.007144
v 0.411821 0.004267 0.006876
v 0.549731 0.044418 0.172353
v 0.411821 0.211204 0.006876
v 0.273911 0.044418 -0.158601
v 0.184261 0.004267 -0.083886
v 0.184261 0.211204 -0.083886
v 0.094610 0.044418 -0.009170
v 0.232520 0.004267 0.156307
v 0.232520 0.211204 0.156307
v 0.370430 0.044418 0.321783
v 0.460080 0.004267 0.247068
v 0.477521 0.103880 0.267995
v 0.445638 0.044418 -0.021308
v 0.132239 0.044418 -0.146306
v 0.198703 0.044418 0.184490
v 0.512102 0.044418 0.309488
v 0.322171 -0.010414 0.081591
v 0.322171 0.255226 0.081591
v -0.526869 -0.024208 0.152000
v -0.555296 0.112752 0.158961
v -0.289810 -0.024208 -0.132445
v -0.292530 0.213963 -0.146049
v -0.354531 -0.024208 0.295628
v -0.356255 0.112752 0.324844
v -0.117472 -0.024208 0.011183
v -0.103601 0.213963 0.011407
v -0.425788 -0.031362 -0.004764
v -0.588868 0.036314 0.170732
v -0.436697 0.238989 -0.007587
v -0.282718 0.033088 -0.195938
v -0.175994 -0.033592 -0.093804
v -0.167515 0.241468 -0.103978
v -0.056297 0.033088 -0.007237
v -0.218553 -0.031362 0.167947
v -0.213811 0.238989 0.178169
v -0.361782 0.036314 0.359987
v -0.468347 -0.033592 0.256987
v -0.494838 0.133348 0.288774
v -0.475820 0.034779 -0.045724
v -0.107523 0.033947 -0.175962
v -0.169247 0.034779 0.209777
v -0.537439 0.038600 0.339889
v -0.322171 -0.050414 0.081591
v -0.326703 0.294595 0.087030
v 0.526869 -0.024208 0.152000
v 0.555296 0.112752 0.158961
v 0.289810 -0.024208 -0.132445
v 0.292530 0.213963 -0.146049
v 0.354531 -0.024208 0.295628
v 0.356255 0.112752 0.324844
v 0.117472 -0.024208 0.011183
v 0.103601 0.213963 0.011407
v 0.425788 -0.031362 -0.004764
v 0.588867 0.036314 0.170732
v 0.436697 0.238989 -0.007587
v 0.282718 0.033088 -0.195938
v 0.175994 -0.033592 -0.093804
v 0.167515 0.241468 -0.103978
v 0.056297 0.033088 -0.007237
v 0.218553 -0.031362 0.167947
v 0.213811 0.238989 0.178169
v 0.361782 0.036314 0.359987
v 0.468347 -0.033592 0.256987
v 0.494838 0.133348 0.288774
v 0.475820 0.034779 -0.045724
v 0.107523 0.033947 -0.175962
v 0.169247 0.034779 0.209777
v 0.537439 0.038600 0.339889
v 0.322171 -0.050414 0.081591
v 0.326703 0.294595 0.087030
vn -0.2298 -0.9382 0.2589
vn -0.3321 0.9074 0.2577
vn -0.2533 -0.8850 -0.3906
vn -0.3960 0.8983 -0.1903
vn 0.2298 -0.9382 0.2589
vn 0.3321 0.9074 0.2577
vn 0.2533 -0.8850 -0.3906
vn 0.3960 0.8983 -0.1903
vn -0.8535 0.1303 -0.5045
vn -0.3218 -0.9448 -0.0616
vn -0.0000 -0.9347 -0.3554
vn -0.0000 0.9356 -0.3530
vn 0.8535 0.1303 -0.5045
vn 0.3218 -0.9448 -0.0616
vn 0.2997 0.9395 0.1659
vn 0.7362 0.0427 0.6754
vn -0.0000 -0.9476 0.3195
vn -0.0000 0.7000 0.7142
vn -0.2997 0.9395 0.1659
vn -0.0000 -0.2060 -0.9785
vn 0.9751 0.1377 0.1737
vn -0.0000 -0.1005 0.9949
vn -0.0000 -0.9915 -0.1304
vn -0.0000 0.9720 0.2348
vn -0.7362 0.0427 0.6754
vn -0.2958 0.9038 -0.3094
vn -0.4035 -0.8643 -0.3002
vn -0.3309 0.8478 0.4144
vn -0.4868 -0.8361 0.2531
vn -0.9751 0.1377 0.1737
vn -0.0000 0.8916 0.4527
vn -0.0000 -0.9301 0.3673
vn -0.8493 -0.0993 0.5184
vn -0.3972 0.9167 0.0442
vn -0.3618 -0.9069 -0.2160
vn -0.7347 -0.0238 -0.6780
vn -0.0000 0.9046 -0.4263
vn -0.0000 -0.7352 -0.6779
vn 0.2958 0.9038 -0.3094
vn -0.0000 0.1082 0.9941
vn -0.9748 -0.1410 -0.1729
vn -0.0000 -0.0041 -1.0000
vn -0.0000 0.9921 0.1251
vn -0.0000 -0.9567 -0.2909
vn 0.4035 -0.8643 -0.3002
vn 0.3309 0.8478 0.4144
vn 0.4868 -0.8361 0.2531
vn 0.8493 -0.0993 0.5184
vn 0.3972 0.9167 0.0442
vn 0.3618 -0.9069 -0.2160
vn 0.7347 -0.0238 -0.6780
vn 0.9748 -0.1410 -0.1729
vn 0.3924 -0.6232 0.6765
vn -0.1913 0.4264 0.8841
vn -0.3252 -0.7838 -0.5290
vn -0.9089 0.2658 -0.3214
vn 0.9089 -0.2658 0.3214
vn 0.3252 0.7838 0.5290
vn 0.1913 -0.4264 -0.8841
vn -0.3924 0.6232 -0.6765
vn -0.0391 -0.9872 0.1548
vn 0.0559 -0.1637 0.9849
vn -0.8102 0.3995 0.4291
vn -0.8087 -0.3573 -0.4674
vn -0.0690 -0.6512 -0.7558
vn -0.6977 0.4796 -0.5321
vn -0.0559 0.1637 -0.9849
vn 0.8102 -0.3995 -0.4291
vn 0.0391 0.9872 -0.1548
vn 0.8087 0.3573 0.4674
vn 0.6977 -0.4796 0.5321
vn 0.0690 0.6512 0.7558
vn -0.7158 -0.4954 0.4921
vn -0.5082 -0.1138 -0.8537
vn 0.7158 0.4954 -0.4921
vn 0.5082 0.1138 0.8537
vn 0.4789 -0.8612 -0.1703
vn -0.4789 0.8612 0.1703
vn -0.3924 -0.6232 0.6765
vn 0.1913 0.4264 0.8841
vn 0.3252 -0.7838 -0.5290
vn 0.9089 0.2658 -0.3214
vn -0.9089 -0.2658 0.3214
vn -0.3252 0.7838 0.5290
vn -0.1913 -0.4264 -0.8841
vn 0.3924 0.6232 -0.6765
vn 0.0391 -0.9872 0.1548
vn -0.0559 -0.1637 0.9849
vn 0.8102 0.3995 0.4291
vn 0.8087 -0.3573 -0.4674
vn 0.0690 -0.6512 -0.7558
vn 0.6977 0.4796 -0.5321
vn 0.0559 0.1637 -0.9849
vn -0.8102 -0.3995 -0.4291
vn -0.0391 0.9872 -0.1548
vn -0.8087 0.3573 0.4674
vn -0.6977 -0.4796 0.5321
vn -0.0690 0.6512 0.7558
vn 0.7158 -0.4954 0.4921
vn 0.5082 -0.1138 -0.8537
vn -0.7158 0.4954 -0.4921
vn -0.5082 0.1138 0.8537
vn -0.4789 -0.8612 -0.1703
vn 0.4789 0.8612 0.1703
vn 0.5747 0.3772 0.7263
vn 0.6454 -0.2598 0.7183
vn -0.5747 0.3772 0.7263
vn -0.6454 -0.2598 0.7183
vn 0.5332 0.7141 -0.4536
vn 0.6790 -0.2668 -0.6840
vn -0.5332 0.7141 -0.4536
vn -0.6790 -0.2668 -0.6840
vn 0.3333 -0.8609 -0.3844
vn -0.3333 -0.8609 -0.3844
vn 0.2334 -0.9128 0.3351
vn -0.2334 -0.9128 0.3351
vn -0.0000 -0.2448 -0.9696
vn -0.0000 0.8402 -0.5422
vn -0.0000 -0.2337 0.9723
vn -0.0000 -0.9479 -0.3186
vn -0.0000 0.4496 0.8932
vn 0.9556 -0.2920 -0.0401
vn 0.7090 0.6779 0.1945
vn 0.2103 -0.9776 -0.0130
vn -0.0000 -0.9999 0.0130
vn -0.0000 0.9475 0.3197
vn 0.6382 0.2812 -0.7167
vn 0.6581 0.1827 -0.7304
vn -0.0000 0.3519 -0.9360
vn -0.0000 0.1759 -0.9844
vn -0.0000 -0.9754 0.2203
vn -0.9556 -0.2920 -0.0401
vn -0.7090 0.6779 0.1945
vn 0.9748 0.2160 -0.0567
vn 0.9790 0.2035 -0.0091
vn 0.6985 0.0609 0.7131
vn 0.6756 0.3360 0.6562
vn -0.0000 0.0579 0.9983
vn -0.0000 0.3527 0.9357
vn -0.2103 -0.9776 -0.0130
vn 0.6785 0.1573 -0.7175
vn -0.0000 0.1177 -0.9930
vn -0.0000 0.3985 0.9172
vn -0.6382 0.2812 -0.7167
vn -0.6581 0.1827 -0.7304
vn 0.9743 0.2171 -0.0595
vn 0.6533 0.4148 0.6334
vn -0.9748 0.2160 -0.0567
vn -0.9790 0.2035 -0.0091
vn -0.6985 0.0609 0.7131
vn -0.6756 0.3360 0.6562
vn -0.6785 0.1573 -0.7175
vn -0.9743 0.2171 -0.0595
vn -0.6533 0.4148 0.6334
vn 0.2592 0.8144 -0.5192
vn 0.5676 -0.5750 -0.5892
vn 0.3426 -0.2517 -0.9051
vn 0.1568 -0.9237 -0.3496
vn -0.0000 -0.6134 -0.7898
vn 0.8849 -0.2808 -0.3716
vn -0.8849 -0.2808 -0.3716
vn 0.2792 -0.9498 -0.1411
vn -0.0000 -0.9986 0.0524
vn -0.7002 -0.0049 -0.7139
vn 0.6613 0.7382 -0.1330
vn -0.8830 0.2428 -0.4016
vn -0.0000 0.9947 -0.1030
vn -0.5676 -0.5750 -0.5892
vn 0.3630 0.8856 0.2896
vn -0.6518 0.1791 -0.7369
vn 0.7051 -0.7089 -0.0155
vn -0.6112 0.4806 -0.6288
vn -0.1017 -0.9948 -0.0000
vn 0.9106 0.4063 0.0761
vn 0.6112 0.4806 -0.6288
vn 0.6518 0.1791 -0.7369
vn 0.7002 -0.0049 -0.7139
vn -0.0000 0.5713 -0.8207
vn -0.0000 0.2204 -0.9754
vn -0.0000 -0.0038 -1.0000
vn 0.4019 0.3553 0.8439
vn -0.0000 0.1582 0.9874
vn -0.9573 0.2834 -0.0573
vn -0.6757 0.5557 0.4844
vn 0.9573 0.2834 -0.0573
vn 0.9886 0.1430 -0.0470
vn -0.0000 0.1243 0.9922
vn 0.3494 0.1778 -0.9200
vn 0.3162 0.3280 -0.8902
vn -0.9886 0.1430 -0.0470
vn 0.8830 0.2428 -0.4016
vn 0.8758 0.1902 -0.4436
vn 0.7042 0.1143 0.7008
vn -0.0000 0.1789 0.9839
vn 0.6646 0.1681 0.7281
vn -0.2792 -0.9498 -0.1411
vn 0.4811 -0.6477 0.5907
vn -0.0000 -0.6901 0.7237
vn 0.0723 -0.9581 0.2771
vn 0.2987 0.4295 0.8523
vn 0.2633 -0.2340 0.9359
vn 0.6886 0.1524 0.7090
vn 0.4009 0.0468 0.9149
vn -0.7042 0.1143 0.7008
vn -0.0000 0.7497 0.6618
vn -0.8758 0.1902 -0.4436
vn 0.6757 0.5557 0.4844
vn -0.6613 0.7382 -0.1330
vn 0.8896 0.2748 0.3648
vn 0.9060 0.1311 0.4025
vn -0.4811 -0.6477 0.5907
vn 0.6597 0.2103 -0.7215
vn -0.0000 0.1616 -0.9869
vn -0.0000 0.4855 0.8742
vn 0.9979 0.0244 -0.0592
vn 0.6347 0.4833 0.6030
vn 0.9008 0.1734 -0.3982
vn -0.6646 0.1681 0.7281
vn 0.2921 0.4249 0.8568
vn -0.6886 0.1524 0.7090
vn 0.3438 0.1328 -0.9296
vn 0.9025 0.3170 0.2917
vn -0.9106 0.4063 0.0761
vn 0.2153 -0.9627 0.1639
vn 0.8990 -0.2945 0.3242
vn -0.7051 -0.7089 -0.0155
vn -0.0000 -0.9998 -0.0208
vn -0.8896 0.2748 0.3648
vn -0.9060 0.1311 0.4025
vn -0.6597 0.2103 -0.7215
vn -0.9979 0.0244 -0.0592
vn -0.6347 0.4833 0.6030
vn -0.9008 0.1734 -0.3982
vn -0.9025 0.3170 0.2917
vn -0.2153 -0.9627 0.1639
vn -0.8990 -0.2945 0.3242
vn 0.1017 -0.9948 -0.0000
vn -0.3426 -0.2517 -0.9051
vn -0.1568 -0.9237 -0.3496
vn -0.3630 0.8856 0.2896
vn -0.4019 0.3553 0.8439
vn -0.2633 -0.2340 0.9359
vn -0.2592 0.8144 -0.5192
vn -0.3162 0.3280 -0.8902
vn -0.3494 0.1778 -0.9200
vn -0.2987 0.4295 0.8523
vn -0.0723 -0.9581 0.2771
vn -0.4009 0.0468 0.9149
vn -0.2921 0.4249 0.8568
vn -0.3438 0.1328 -0.9296
vn -0.2923 -0.5994 -0.7452
vn -0.2738 0.5435 -0.7935
vn 0.2923 -0.5994 -0.7452
vn -0.0444 -0.9979 0.0476
vn 0.9104 0.1251 0.3943
vn -0.3412 0.2089 -0.9165
vn -0.9484 0.0861 0.3052
vn -0.7009 -0.6475 -0.2991
vn 0.9484 0.0861 0.3052
vn -0.3320 0.5024 0.7984
vn 0.3447 0.1782 -0.9217
vn -0.8768 0.2357 -0.4191
vn 0.2738 0.5435 -0.7935
vn 0.3281 0.9393 -0.0999
vn -0.9104 0.1251 0.3943
vn -0.3281 0.9393 -0.0999
vn 0.4290 0.1172 0.8957
vn 0.7009 -0.6475 -0.2991
vn -0.4290 0.1172 0.8957
vn -0.0138 -0.9998 -0.0135
vn -0.3357 0.7152 0.6130
vn 0.3320 0.5024 0.7984
vn 0.0444 -0.9979 0.0476
vn 0.1900 -0.6656 0.7217
vn 0.3357 0.7152 0.6130
vn -0.8447 0.4521 -0.2865
vn -0.2827 0.1692 0.9442
vn 0.3412 0.2089 -0.9165
vn 0.6571 -0.6984 0.2837
vn -0.6571 -0.6984 0.2837
vn -0.3490 0.1581 0.9237
vn -0.1900 -0.6656 0.7217
vn 0.9223 -0.0042 -0.3865
vn 0.0138 -0.9998 -0.0135
vn 0.8447 0.4521 -0.2865
vn 0.8826 0.1548 -0.4438
vn 0.3490 0.1581 0.9237
vn -0.9223 -0.0042 -0.3865
vn 0.8580 0.2931 0.4219
vn 0.8768 0.2357 -0.4191
vn -0.8580 0.2931 0.4219
vn -0.3498 -0.0024 -0.9368
vn -0.8826 0.1548 -0.4438
vn 0.2827 0.1692 0.9442
vn -0.8679 0.3858 0.3131
vn 0.3498 -0.0024 -0.9368
vn 0.8679 0.3858 0.3131
vn -0.3447 0.1782 -0.9217
vn -0.5744 -0.3797 -0.7252
vn -0.6461 0.2595 -0.7178
vn 0.5744 -0.3797 -0.7252
vn 0.6461 0.2595 -0.7178
vn -0.5390 -0.7040 0.4624
vn -0.6782 0.2686 0.6841
vn 0.5390 -0.7040 0.4624
vn 0.6782 0.2686 0.6841
vn -0.3415 0.8648 0.3681
vn 0.3415 0.8648 0.3681
vn -0.2379 0.9100 -0.3396
vn 0.2379 0.9100 -0.3396
vn -0.0000 0.2490 0.9685
vn -0.0000 -0.8424 0.5389
vn -0.0000 0.2371 -0.9715
vn -0.0000 0.9447 0.3279
vn -0.0000 -0.4518 -0.8921
vn -0.9542 0.2968 0.0388
vn -0.7075 -0.6798 -0.1934
vn -0.2229 0.9748 0.0127
vn -0.0000 0.9999 -0.0116
vn -0.0000 -0.9481 -0.3178
vn -0.6388 -0.2826 0.7156
vn -0.6572 -0.1829 0.7312
vn -0.0000 -0.3529 0.9356
vn -0.0000 -0.1760 0.9844
vn -0.0000 0.9665 -0.2565
vn 0.9542 0.2968 0.0388
vn 0.7075 -0.6798 -0.1934
vn -0.9747 -0.2162 0.0567
vn -0.9788 -0.2044 0.0087
vn -0.7001 -0.0615 -0.7114
vn -0.6780 -0.3358 -0.6538
vn -0.0000 -0.0579 -0.9983
vn -0.0000 -0.3520 -0.9360
vn 0.2229 0.9748 0.0127
vn -0.6788 -0.1561 0.7176
vn -0.0000 -0.1170 0.9931
vn -0.0000 -0.4051 -0.9143
vn 0.6388 -0.2826 0.7156
vn 0.6572 -0.1829 0.7312
vn -0.9746 -0.2161 0.0581
vn -0.6541 -0.4125 -0.6340
vn 0.9747 -0.2162 0.0567
vn 0.9788 -0.2044 0.0087
vn 0.7001 -0.0615 -0.7114
vn 0.6780 -0.3358 -0.6538
vn 0.6788 -0.1561 0.7176
vn 0.9746 -0.2161 0.0581
vn 0.6541 -0.4125 -0.6340
vn -0.2531 -0.8146 0.5218
vn -0.5738 0.5714 0.5867
vn -0.3437 0.2547 0.9039
vn -0.1452 0.9254 0.3501
vn -0.0000 0.6164 0.7874
vn -0.8839 0.2838 0.3717
vn 0.8839 0.2838 0.3717
vn -0.2862 0.9475 0.1428
vn -0.0000 0.9992 -0.0406
vn 0.7001 0.0068 0.7140
vn -0.6654 -0.7353 0.1286
vn 0.8832 -0.2438 0.4007
vn -0.0000 -0.9946 0.1039
vn 0.5738 0.5714 0.5867
vn -0.3641 -0.8860 -0.2872
vn 0.6516 -0.1797 0.7370
vn -0.7051 0.7090 0.0157
vn 0.6114 -0.4822 0.6274
vn 0.0922 0.9957 0.0012
vn -0.9095 -0.4086 -0.0769
vn -0.6114 -0.4822 0.6274
vn -0.6516 -0.1797 0.7370
vn -0.7001 0.0068 0.7140
vn -0.0000 -0.5746 0.8184
vn -0.0000 -0.2209 0.9753
vn -0.0000 0.0058 1.0000
vn -0.3991 -0.3554 -0.8452
vn -0.0000 -0.1480 -0.9890
vn 0.9575 -0.2831 0.0561
vn 0.6744 -0.5571 -0.4846
vn -0.9575 -0.2831 0.0561
vn -0.9885 -0.1436 0.0475
vn -0.0000 -0.1224 -0.9925
vn -0.3486 -0.1779 0.9202
vn -0.3183 -0.3292 0.8890
vn 0.9885 -0.1436 0.0475
vn -0.8832 -0.2438 0.4007
vn -0.8761 -0.1906 0.4428
vn -0.7066 -0.1131 -0.6985
vn -0.0000 -0.1819 -0.9833
vn -0.6656 -0.1709 -0.7265
vn 0.2862 0.9475 0.1428
vn -0.4836 0.6453 -0.5914
vn -0.0000 0.6886 -0.7252
vn -0.0892 0.9504 -0.2980
vn -0.2989 -0.4325 -0.8507
vn -0.2668 0.2355 -0.9345
vn -0.6891 -0.1487 -0.7092
vn -0.3992 -0.0466 -0.9157
vn 0.7066 -0.1131 -0.6985
vn -0.0000 -0.7504 -0.6610
vn 0.8761 -0.1906 0.4428
vn -0.6744 -0.5571 -0.4846
vn 0.6654 -0.7353 0.1286
vn -0.8915 -0.2747 -0.3601
vn -0.9071 -0.1327 -0.3995
vn 0.4836 0.6453 -0.5914
vn -0.6595 -0.2100 0.7218
vn -0.0000 -0.1614 0.9869
vn -0.0000 -0.4855 -0.8742
vn -0.9981 -0.0222 0.0576
vn -0.6358 -0.4833 -0.6018
vn -0.9007 -0.1723 0.3988
vn 0.6656 -0.1709 -0.7265
vn -0.2995 -0.4263 -0.8536
vn 0.6891 -0.1487 -0.7092
vn -0.3454 -0.1319 0.9291
vn -0.9022 -0.3152 -0.2943
vn 0.9095 -0.4086 -0.0769
vn -0.2233 0.9607 -0.1651
vn -0.8977 0.2956 -0.3266
vn 0.7051 0.7090 0.0157
vn -0.0000 0.9992 0.0391
vn 0.8915 -0.2747 -0.3601
vn 0.9071 -0.1327 -0.3995
vn 0.6595 -0.2100 0.7218
vn 0.9981 -0.0222 0.0576
vn 0.6358 -0.4833 -0.6018
vn 0.9007 -0.1723 0.3988
vn 0.9022 -0.3152 -0.2943
vn 0.2233 0.9607 -0.1651
vn 0.8977 0.2956 -0.3266
vn -0.0922 0.9957 0.0012
vn 0.3437 0.2547 0.9039
vn 0.1452 0.9254 0.3501
vn 0.3641 -0.8860 -0.2872
vn 0.3991 -0.3554 -0.8452
vn 0.2668 0.2355 -0.9345
vn 0.2531 -0.8146 0.5218
vn 0.3183 -0.3292 0.8890
vn 0.3486 -0.1779 0.9202
vn 0.2989 -0.4325 -0.8507
vn 0.0892 0.9504 -0.2980
vn 0.3992 -0.0466 -0.9157
vn 0.2995 -0.4263 -0.8536
vn 0.3454 -0.1319 0.9291
vn 0.2882 0.5973 0.7484
vn 0.2765 -0.5461 0.7907
vn -0.2882 0.5973 0.7484
vn 0.0268 0.9989 -0.0380
vn -0.9128 -0.1253 -0.3888
vn 0.3414 -0.2095 0.9163
vn 0.9474 -0.0832 -0.3090
vn 0.6999 0.6487 0.2990
vn -0.9474 -0.0832 -0.3090
vn 0.3323 -0.5024 -0.7982
vn -0.3453 -0.1780 0.9215
vn 0.8769 -0.2355 0.4191
vn -0.2765 -0.5461 0.7907
vn -0.3252 -0.9408 0.0959
vn 0.9128 -0.1253 -0.3888
vn 0.3252 -0.9408 0.0959
vn -0.4257 -0.1154 -0.8975
vn -0.6999 0.6487 0.2990
vn 0.4257 -0.1154 -0.8975
vn 0.0080 0.9998 0.0194
vn 0.3362 -0.7165 -0.6112
vn -0.3323 -0.5024 -0.7982
vn -0.0268 0.9989 -0.0380
vn -0.1931 0.6626 -0.7237
vn -0.3362 -0.7165 -0.6112
vn 0.8433 -0.4548 0.2864
vn 0.2912 -0.1616 -0.9429
vn -0.3414 -0.2095 0.9163
vn -0.6596 0.6956 -0.2849
vn 0.6596 0.6956 -0.2849
vn 0.3482 -0.1609 -0.9235
vn 0.1931 0.6626 -0.7237
vn -0.9219 0.0060 0.3874
vn -0.0080 0.9998 0.0194
vn -0.8433 -0.4548 0.2864
vn -0.8833 -0.1553 0.4423
vn -0.3482 -0.1609 -0.9235
vn 0.9219 0.0060 0.3874
vn -0.8576 -0.2959 -0.4206
vn -0.8769 -0.2355 0.4191
vn 0.8576 -0.2959 -0.4206
vn 0.3514 0.0044 0.9362
vn 0.8833 -0.1553 0.4423
vn -0.2912 -0.1616 -0.9429
vn 0.8680 -0.3855 -0.3130
vn -0.3514 0.0044 0.9362
vn -0.8680 -0.3855 -0.3130
vn 0.3453 -0.1780 0.9215
vn -0.4806 -0.8730 -0.0831
vn -0.8105 0.5826 -0.0612
vn -0.1683 -0.8730 -0.4578
vn -0.2114 0.5864 -0.7819
vn 0.1683 -0.8730 0.4578
vn 0.2063 0.5826 0.7862
vn 0.4806 -0.8730 0.0831
vn 0.8072 0.5864 0.0670
vn -0.3337 -0.9007 -0.2781
vn -0.9865 -0.1617 -0.0269
vn -0.6344 0.6933 -0.3419
vn -0.2090 -0.2707 -0.9397
vn 0.2036 -0.9481 -0.2443
vn 0.4280 0.7437 -0.5135
vn 0.9620 -0.2707 0.0362
vn 0.3337 -0.9007 0.2781
vn 0.4506 0.6933 0.5623
vn 0.2043 -0.1617 0.9655
vn -0.2036 -0.9481 0.2443
vn -0.4268 0.7453 0.5122
vn -0.7522 -0.2599 -0.6054
vn 0.6174 -0.2647 -0.7408
vn 0.7311 -0.2599 0.6308
vn -0.6331 -0.1484 0.7597
vn -0.0000 -1.0000 -0.0000
vn -0.1187 0.9827 0.1425
vn 0.4806 -0.8730 -0.0831
vn 0.8105 0.5826 -0.0612
vn 0.1683 -0.8730 -0.4578
vn 0.2114 0.5864 -0.7819
vn -0.1683 -0.8730 0.4578
vn -0.2063 0.5826 0.7862
vn -0.4806 -0.8730 0.0831
vn -0.8072 0.5864 0.0670
vn 0.3337 -0.9007 -0.2781
vn 0.9865 -0.1617 -0.0269
vn 0.6344 0.6933 -0.3419
vn 0.2090 -0.2707 -0.9397
vn -0.2036 -0.9481 -0.2443
vn -0.4280 0.7437 -0.5135
vn -0.9620 -0.2707 0.0362
vn -0.3337 -0.9007 0.2781
vn -0.4506 0.6933 0.5623
vn -0.2043 -0.1617 0.9655
vn 0.2036 -0.9481 0.2443
vn 0.4268 0.7453 0.5122
vn 0.7522 -0.2599 -0.6054
vn -0.6174 -0.2647 -0.7408
vn -0.7311 -0.2599 0.6308
vn 0.6331 -0.1484 0.7597
vn 0.1187 0.9827 0.1425
vn 0.5234 0.8498 0.0628
vn 0.8453 -0.5331 0.0354
vn 0.1579 0.8550 0.4940
vn 0.2281 -0.5897 0.7747
vn -0.1561 0.8498 -0.5035
vn -0.1872 -0.5331 -0.8251
vn -0.5144 0.8550 -0.0663
vn -0.8032 -0.5897 -0.0847
vn 0.3592 0.8838 0.2997
vn 0.9846 0.1735 0.0232
vn 0.6323 -0.6922 0.3481
vn 0.2155 0.2641 0.9401
vn -0.2405 0.9267 0.2886
vn -0.4198 -0.7550 0.5038
vn -0.9636 0.2641 -0.0425
vn -0.3595 0.8838 -0.2993
vn -0.4563 -0.6922 -0.5592
vn -0.2003 0.1735 -0.9643
vn 0.2492 0.9211 -0.2990
vn 0.4582 -0.6985 -0.5497
vn 0.7551 0.2339 0.6125
vn -0.6182 0.2599 0.7418
vn -0.7386 0.2339 -0.6323
vn 0.6334 0.1459 -0.7600
vn -0.0000 1.0000 -0.0000
vn 0.1148 -0.9838 -0.1377
vn -0.5234 0.8498 0.0628
vn -0.8453 -0.5331 0.0354
vn -0.1579 0.8550 0.4940
vn -0.2281 -0.5897 0.7747
vn 0.1561 0.8498 -0.5035
vn 0.1872 -0.5331 -0.8251
vn 0.5144 0.8550 -0.0663
vn 0.8032 -0.5897 -0.0847
vn -0.3592 0.8838 0.2997
vn -0.9846 0.1735 0.0232
vn -0.6323 -0.6922 0.3481
vn -0.2155 0.2641 0.9401
vn 0.2405 0.9267 0.2886
vn 0.4198 -0.7550 0.5038
vn 0.9636 0.2641 -0.0425
vn 0.3595 0.8838 -0.2993
vn 0.4563 -0.6922 -0.5592
vn 0.2003 0.1735 -0.9643
vn -0.2492 0.9211 -0.2990
vn -0.4582 -0.6985 -0.5497
vn -0.7551 0.2339 0.6125
vn 0.6182 0.2599 0.7418
vn 0.7386 0.2339 -0.6323
vn -0.6334 0.1459 -0.7600
vn -0.1148 -0.9838 -0.1377
vt 0.009831 0.035651
vt 0.022569 0.022913
vt 0.022569 0.010176
vt 0.027346 0.058473
vt 0.048045 0.048389
vt 0.030000 0.048389
vt 0.048045 0.022913
vt 0.060783 0.035651
vt 0.048045 0.035651
vt 0.030000 0.035651
vt 0.030000 0.022913
vt 0.022569 0.048389
vt 0.060783 0.022913
vt 0.027346 0.012829
vt 0.022569 0.035651
vt 0.058552 0.058052
vt 0.009831 0.048389
vt 0.042069 0.919810
vt 0.025357 0.936523
vt 0.042069 0.903098
vt 0.075494 0.953235
vt 0.048336 0.966466
vt 0.051818 0.953235
vt 0.075494 0.936523
vt 0.092207 0.919810
vt 0.075494 0.919810
vt 0.051818 0.936523
vt 0.042069 0.936523
vt 0.042069 0.953235
vt 0.025357 0.953235
vt 0.092207 0.936523
vt 0.089279 0.965914
vt 0.048336 0.906579
vt 0.051818 0.919810
vt 0.044493 0.911901
vt 0.049930 0.920258
vt 0.041425 0.922613
vt 0.049566 0.930222
vt 0.029819 0.983012
vt 0.041206 0.973418
vt 0.031998 0.988770
vt 0.041206 0.955516
vt 0.031242 0.955880
vt 0.033597 0.947375
vt 0.022885 0.950443
vt 0.025064 0.956202
vt 0.041206 0.928736
vt 0.029819 0.938329
vt 0.034570 0.926898
vt 0.013677 0.965795
vt 0.068954 0.965795
vt 0.057567 0.956202
vt 0.059746 0.950443
vt 0.027441 0.969607
vt 0.023641 0.983334
vt 0.041425 0.973418
vt 0.046256 0.959334
vt 0.048061 0.971581
vt 0.018508 0.979880
vt 0.055189 0.969607
vt 0.051388 0.955880
vt 0.020313 0.967633
vt 0.082820 0.921014
vt 0.077383 0.912657
vt 0.085888 0.910302
vt 0.077747 0.902693
vt 0.073930 0.907524
vt 0.021286 0.991838
vt 0.077061 0.918835
vt 0.067468 0.930222
vt 0.065630 0.923586
vt 0.027441 0.924925
vt 0.036375 0.914651
vt 0.059845 0.902693
vt 0.061683 0.909329
vt 0.052812 0.983012
vt 0.050633 0.988770
vt 0.062318 0.967633
vt 0.041425 0.955516
vt 0.025064 0.911520
vt 0.031242 0.911198
vt 0.064123 0.979880
vt 0.058990 0.983334
vt 0.022885 0.905761
vt 0.013677 0.921113
vt 0.020313 0.922951
vt 0.041206 0.910834
vt 0.033597 0.902693
vt 0.018508 0.935198
vt 0.023641 0.938651
vt 0.013677 0.939015
vt 0.036375 0.959334
vt 0.068954 0.983697
vt 0.061345 0.991838
vt 0.021286 0.947156
vt 0.053383 0.925391
vt 0.063656 0.916457
vt 0.031998 0.944088
vt 0.050252 0.914080
vt 0.034570 0.971581
vt 0.013677 0.983697
vt 0.229068 0.283003
vt 0.171021 0.368583
vt 0.235716 0.372905
vt 0.104567 0.291799
vt 0.161402 0.287784
vt 0.118691 0.365651
vt 0.177081 0.436390
vt 0.237434 0.450190
vt 0.772487 0.244608
vt 0.830885 0.291437
vt 0.831241 0.240456
vt 0.773900 0.300420
vt 0.829115 0.333252
vt 0.858218 0.317125
vt 0.866299 0.284431
vt 0.869054 0.237785
vt 0.159565 0.206435
vt 0.213843 0.116300
vt 0.223009 0.193059
vt 0.156030 0.138449
vt 0.108167 0.216695
vt 0.868437 0.835431
vt 0.916164 0.782980
vt 0.891119 0.855846
vt 0.877245 0.780118
vt 0.924195 0.701498
vt 0.957286 0.796000
vt 0.930059 0.894764
vt 0.249114 0.893652
vt 0.328855 0.924338
vt 0.225876 0.926457
vt 0.257535 0.859491
vt 0.339356 0.898423
vt 0.344655 0.861842
vt 0.438835 0.906224
vt 0.431835 0.922219
vt 0.580003 0.258208
vt 0.686235 0.308569
vt 0.683794 0.250874
vt 0.583296 0.320100
vt 0.686303 0.359562
vt 0.691504 0.441139
vt 0.602015 0.493654
vt 0.594643 0.454895
vt 0.788365 0.427384
vt 0.689209 0.474676
vt 0.765689 0.476993
vt 0.690181 0.526260
vt 0.607823 0.542411
vt 0.227666 0.508117
vt 0.136648 0.417420
vt 0.165829 0.485511
vt 0.086053 0.486788
vt 0.143284 0.527760
vt 0.200515 0.568731
vt 0.634440 0.952577
vt 0.730424 0.991987
vt 0.632591 0.991987
vt 0.633335 0.903487
vt 0.723436 0.959106
vt 0.717145 0.907898
vt 0.798831 0.946058
vt 0.828257 0.991987
vt 0.526463 0.729599
vt 0.612405 0.622994
vt 0.618141 0.723122
vt 0.431463 0.736311
vt 0.522077 0.643428
vt 0.427681 0.664226
vt 0.517969 0.573320
vt 0.386138 0.271905
vt 0.473008 0.192406
vt 0.379420 0.186626
vt 0.478888 0.265352
vt 0.574560 0.196467
vt 0.568364 0.141638
vt 0.466865 0.128406
vt 0.372049 0.112959
vt 0.583189 0.443916
vt 0.487880 0.452057
vt 0.488713 0.492568
vt 0.585318 0.418038
vt 0.486240 0.402628
vt 0.394538 0.431253
vt 0.394863 0.487115
vt 0.394237 0.541219
vt 0.823720 0.190033
vt 0.766038 0.189151
vt 0.859768 0.191989
vt 0.847170 0.160757
vt 0.816088 0.148881
vt 0.758302 0.141655
vt 0.894025 0.128798
vt 0.887748 0.188080
vt 0.915920 0.180862
vt 0.861783 0.148124
vt 0.899896 0.235606
vt 0.937815 0.232927
vt 0.303437 0.564580
vt 0.228802 0.606173
vt 0.201183 0.576962
vt 0.405691 0.552198
vt 0.317477 0.588761
vt 0.414871 0.567050
vt 0.327867 0.624233
vt 0.241943 0.638810
vt 0.909101 0.342178
vt 0.894551 0.284367
vt 0.874462 0.327577
vt 0.923458 0.287552
vt 0.437854 0.808212
vt 0.337918 0.742921
vt 0.441953 0.867838
vt 0.342845 0.807680
vt 0.257628 0.809274
vt 0.253673 0.748873
vt 0.196028 0.060322
vt 0.160623 0.004128
vt 0.137983 0.091398
vt 0.058820 0.101351
vt 0.095632 0.140872
vt 0.118666 0.162916
vt 0.249096 0.688515
vt 0.333691 0.678111
vt 0.423355 0.604616
vt 0.068431 0.212573
vt 0.031594 0.200115
vt 0.004367 0.298879
vt 0.059852 0.294958
vt 0.117239 0.666316
vt 0.065422 0.708562
vt 0.079778 0.653937
vt 0.139178 0.675275
vt 0.097441 0.710472
vt 0.133417 0.708896
vt 0.093800 0.760168
vt 0.051065 0.763188
vt 0.626541 0.823061
vt 0.534236 0.815531
vt 0.540027 0.885520
vt 0.850159 0.576735
vt 0.904787 0.621954
vt 0.866657 0.630260
vt 0.902827 0.509326
vt 0.869745 0.553333
vt 0.943670 0.603281
vt 0.880327 0.704597
vt 0.774922 0.712044
vt 0.834344 0.794361
vt 0.780248 0.812728
vt 0.832905 0.707948
vt 0.836519 0.864944
vt 0.786100 0.894578
vt 0.072960 0.815252
vt 0.130202 0.849793
vt 0.094854 0.867316
vt 0.104392 0.808859
vt 0.140233 0.805362
vt 0.150664 0.837838
vt 0.848399 0.380665
vt 0.835276 0.360419
vt 0.774076 0.384184
vt 0.787697 0.419153
vt 0.702416 0.717167
vt 0.766038 0.611612
vt 0.695143 0.611448
vt 0.760323 0.529752
vt 0.678098 0.193410
vt 0.670996 0.142913
vt 0.852630 0.909631
vt 0.879158 0.943376
vt 0.814409 0.552003
vt 0.824076 0.505494
vt 0.845596 0.468355
vt 0.182207 0.699838
vt 0.185592 0.753683
vt 0.176475 0.657128
vt 0.822179 0.622190
vt 0.356289 0.004127
vt 0.274120 0.050504
vt 0.364516 0.057606
vt 0.258456 0.004127
vt 0.286751 0.107677
vt 0.079930 0.375319
vt 0.116942 0.442483
vt 0.045210 0.392834
vt 0.828514 0.099228
vt 0.763004 0.069658
vt 0.818368 0.121118
vt 0.754435 0.106194
vt 0.664745 0.103857
vt 0.660024 0.071777
vt 0.562792 0.099218
vt 0.189812 0.807469
vt 0.190142 0.850561
vt 0.133550 0.757360
vt 0.306364 0.506857
vt 0.297376 0.554975
vt 0.310830 0.448476
vt 0.179066 0.877522
vt 0.160365 0.896887
vt 0.557045 0.073896
vt 0.461538 0.079237
vt 0.456667 0.039012
vt 0.161718 0.631992
vt 0.140481 0.615449
vt 0.309148 0.369469
vt 0.303499 0.277744
vt 0.391478 0.357281
vt 0.685605 0.399110
vt 0.685443 0.431535
vt 0.772919 0.348532
vt 0.584870 0.375255
vt 0.710080 0.822858
vt 0.500167 0.503547
vt 0.510231 0.530285
vt 0.296194 0.186135
vt 0.532213 0.957103
vt 0.538417 0.929215
vt 0.483323 0.338399
vt 0.038332 0.914438
vt 0.032492 0.923049
vt 0.031524 0.914919
vt 0.025805 0.915324
vt 0.029033 0.927963
vt 0.027226 0.922754
vt 0.039174 0.931260
vt 0.039001 0.923484
vt 0.093009 0.910575
vt 0.098885 0.915287
vt 0.093152 0.916191
vt 0.098707 0.919494
vt 0.093053 0.921032
vt 0.101635 0.917872
vt 0.098921 0.910158
vt 0.102449 0.914582
vt 0.031339 0.906734
vt 0.037723 0.905389
vt 0.036800 0.897665
vt 0.027224 0.902356
vt 0.030983 0.899894
vt 0.102664 0.970022
vt 0.107466 0.964745
vt 0.103550 0.964457
vt 0.103860 0.956858
vt 0.111603 0.966055
vt 0.108274 0.956546
vt 0.108864 0.975992
vt 0.104946 0.972076
vt 0.048373 0.978968
vt 0.040349 0.975880
vt 0.038011 0.979181
vt 0.049429 0.976360
vt 0.041197 0.972443
vt 0.059438 0.977145
vt 0.049962 0.972680
vt 0.058734 0.978754
vt 0.073642 0.911944
vt 0.084331 0.917011
vt 0.073974 0.918171
vt 0.084338 0.922142
vt 0.074132 0.923721
vt 0.084085 0.911206
vt 0.075857 0.935634
vt 0.084861 0.930350
vt 0.075115 0.931734
vt 0.084630 0.933724
vt 0.094607 0.928966
vt 0.084728 0.938914
vt 0.092326 0.933957
vt 0.076441 0.940539
vt 0.038191 0.937089
vt 0.033101 0.929872
vt 0.031969 0.934814
vt 0.023943 0.934943
vt 0.027050 0.930485
vt 0.035459 0.943188
vt 0.088777 0.985774
vt 0.079120 0.981809
vt 0.078934 0.985774
vt 0.088074 0.982466
vt 0.079008 0.976870
vt 0.095660 0.981153
vt 0.087441 0.977314
vt 0.098621 0.985774
vt 0.076903 0.948647
vt 0.068255 0.959374
vt 0.077480 0.958722
vt 0.067814 0.950703
vt 0.058697 0.960049
vt 0.067401 0.943649
vt 0.058316 0.952796
vt 0.054136 0.913322
vt 0.062877 0.905323
vt 0.063468 0.912662
vt 0.073095 0.905731
vt 0.072471 0.900215
vt 0.053460 0.904741
vt 0.062259 0.898883
vt 0.073963 0.930629
vt 0.064373 0.931448
vt 0.074177 0.928025
vt 0.064208 0.926475
vt 0.054981 0.929355
vt 0.064457 0.935524
vt 0.055014 0.934976
vt 0.098164 0.905084
vt 0.101791 0.905281
vt 0.102726 0.909889
vt 0.100524 0.902138
vt 0.092361 0.904995
vt 0.097397 0.900944
vt 0.105238 0.898923
vt 0.104607 0.904888
vt 0.101994 0.900867
vt 0.107441 0.904161
vt 0.105829 0.909670
vt 0.038306 0.946955
vt 0.045815 0.942770
vt 0.035527 0.944016
vt 0.047228 0.945203
vt 0.056104 0.941524
vt 0.048273 0.948772
vt 0.057027 0.943018
vt 0.039628 0.950239
vt 0.106755 0.920392
vt 0.105291 0.914576
vt 0.108200 0.914896
vt 0.109644 0.909400
vt 0.103270 0.918923
vt 0.049284 0.960714
vt 0.059340 0.967283
vt 0.049780 0.967230
vt 0.059752 0.973283
vt 0.041206 0.967390
vt 0.035008 0.892033
vt 0.029168 0.895160
vt 0.031446 0.886379
vt 0.021202 0.896161
vt 0.026324 0.891270
vt 0.040347 0.955240
vt 0.040808 0.961313
vt 0.048859 0.954193
vt 0.057881 0.946798
vt 0.022169 0.907352
vt 0.024906 0.900138
vt 0.018463 0.906098
vt 0.015724 0.916036
vt 0.026168 0.907767
vt 0.021306 0.915641
vt 0.021867 0.957257
vt 0.027080 0.953006
vt 0.023311 0.951761
vt 0.025088 0.957449
vt 0.029288 0.953908
vt 0.024722 0.962449
vt 0.028708 0.957291
vt 0.020422 0.962753
vt 0.078325 0.968778
vt 0.069037 0.968020
vt 0.069620 0.975062
vt 0.100825 0.943993
vt 0.106321 0.948543
vt 0.102795 0.941638
vt 0.106124 0.937210
vt 0.110233 0.946664
vt 0.102485 0.949378
vt 0.093255 0.957607
vt 0.099233 0.965890
vt 0.099089 0.957195
vt 0.093790 0.967738
vt 0.099452 0.972992
vt 0.028385 0.971467
vt 0.022625 0.967992
vt 0.024828 0.973230
vt 0.025788 0.967349
vt 0.029394 0.966997
vt 0.030443 0.970264
vt 0.100648 0.924265
vt 0.099327 0.922228
vt 0.093169 0.924619
vt 0.094540 0.928137
vt 0.092361 0.947502
vt 0.085959 0.958123
vt 0.085227 0.947486
vt 0.091786 0.939266
vt 0.083512 0.905424
vt 0.082798 0.900343
vt 0.094379 0.975973
vt 0.101073 0.977488
vt 0.103742 0.980883
vt 0.097228 0.941504
vt 0.098200 0.936825
vt 0.100365 0.933088
vt 0.033617 0.956379
vt 0.033958 0.961797
vt 0.028722 0.962167
vt 0.033041 0.952082
vt 0.098009 0.948566
vt 0.051133 0.886379
vt 0.042865 0.891045
vt 0.041289 0.886379
vt 0.051961 0.891760
vt 0.044136 0.896798
vt 0.023326 0.923727
vt 0.019833 0.925489
vt 0.098647 0.895948
vt 0.097626 0.898150
vt 0.092055 0.892972
vt 0.091193 0.896648
vt 0.082169 0.896413
vt 0.081694 0.893185
vt 0.071911 0.895947
vt 0.071332 0.893399
vt 0.091582 0.900216
vt 0.034382 0.967209
vt 0.034416 0.971545
vt 0.054951 0.940419
vt 0.046110 0.936962
vt 0.046559 0.931088
vt 0.045205 0.941803
vt 0.033301 0.974257
vt 0.031420 0.976206
vt 0.061723 0.893936
vt 0.061233 0.889889
vt 0.052719 0.897329
vt 0.031556 0.949553
vt 0.029419 0.947888
vt 0.046390 0.923138
vt 0.045821 0.913909
vt 0.054673 0.921912
vt 0.084268 0.926121
vt 0.084251 0.929383
vt 0.086730 0.968757
vt 0.065609 0.936629
vt 0.066622 0.939319
vt 0.045086 0.904692
vt 0.068834 0.982264
vt 0.069458 0.979458
vt 0.063915 0.920012
vt 0.026495 0.015853
vt 0.033128 0.022486
vt 0.026495 0.022486
vt 0.037537 0.015853
vt 0.033128 0.015853
vt 0.039761 0.029119
vt 0.033128 0.029119
vt 0.026495 0.029119
vt 0.026495 0.035752
vt 0.039761 0.035752
vt 0.033128 0.035752
vt 0.033128 0.042386
vt 0.026495 0.042386
vt 0.033128 0.049019
vt 0.026495 0.049019
vt 0.039761 0.042386
vt 0.037537 0.055652
vt 0.033128 0.055652
vt 0.026495 0.055652
vt 0.026495 0.062285
vt 0.037537 0.062285
vt 0.033128 0.062285
vt 0.033128 0.068918
vt 0.026495 0.068918
vt 0.013229 0.042386
vt 0.019862 0.049019
vt 0.013229 0.049019
vt 0.019862 0.042386
vt 0.019862 0.055652
vt 0.013229 0.055652
vt 0.046394 0.049019
vt 0.039761 0.049019
vt 0.053027 0.042386
vt 0.046394 0.042386
vt 0.053748 0.056327
vt 0.046394 0.056875
vt 0.039761 0.022486
vt 0.053027 0.049019
vt 0.043345 0.873754
vt 0.057804 0.888212
vt 0.057804 0.873754
vt 0.067415 0.873754
vt 0.072262 0.902670
vt 0.072262 0.888212
vt 0.043345 0.902670
vt 0.043345 0.888212
vt 0.043345 0.917128
vt 0.057804 0.902670
vt 0.057804 0.917128
vt 0.072262 0.931587
vt 0.072262 0.917128
vt 0.057804 0.931587
vt 0.043345 0.931587
vt 0.057804 0.946045
vt 0.067415 0.960503
vt 0.072262 0.946045
vt 0.043345 0.960503
vt 0.043345 0.946045
vt 0.043345 0.974962
vt 0.057804 0.960503
vt 0.067415 0.974962
vt 0.057804 0.989420
vt 0.057804 0.974962
vt 0.014429 0.931587
vt 0.028887 0.946045
vt 0.028887 0.931587
vt 0.014429 0.960503
vt 0.014429 0.946045
vt 0.086720 0.946045
vt 0.086720 0.931587
vt 0.101178 0.931587
vt 0.102750 0.961976
vt 0.101178 0.946045
vt 0.033214 0.908776
vt 0.043601 0.919163
vt 0.033214 0.919163
vt 0.050505 0.908776
vt 0.043601 0.908776
vt 0.053988 0.929550
vt 0.043601 0.929550
vt 0.033214 0.929550
vt 0.033214 0.939937
vt 0.043601 0.939937
vt 0.053988 0.950323
vt 0.043601 0.950323
vt 0.033214 0.950323
vt 0.043601 0.960710
vt 0.033214 0.960710
vt 0.050505 0.971097
vt 0.043601 0.971097
vt 0.033214 0.971097
vt 0.033214 0.981484
vt 0.050505 0.981484
vt 0.043601 0.981484
vt 0.043601 0.991871
vt 0.033214 0.991871
vt 0.012440 0.950323
vt 0.022827 0.960710
vt 0.012440 0.960710
vt 0.022827 0.950323
vt 0.022827 0.971097
vt 0.012440 0.971097
vt 0.064375 0.960710
vt 0.053988 0.960710
vt 0.074761 0.950323
vt 0.064375 0.950323
vt 0.075890 0.972155
vt 0.064375 0.973013
vt 0.049034 0.947375
vt 0.984513 0.697236
vt 0.109722 0.052739
vt 0.114343 0.956117
vt 0.029701 0.939065
vt 0.037537 0.068918
vt 0.067415 0.989420
vt 0.043345 0.989420
vt 0.028887 0.960503
vt 0.086720 0.963170
vt 0.053988 0.919163
vt 0.053988 0.939937
vt 0.050505 0.991871
vt 0.074761 0.960710
s 1
usemtl penger_mat
f 23/1/23 3/2/3 11/3/11
f 22/4/22 2/5/2 25/6/25
f 8/7/8 24/8/24 15/9/15
f 3/2/3 30/10/30 9/11/9
f 1/12/1 22/4/22 25/6/25
f 2/5/2 24/8/24 19/9/19
f 4/7/4 24/8/24 12/13/12
f 3/2/3 20/14/20 11/3/11
f 20/14/20 8/7/8 13/11/13
f 7/2/7 20/14/20 13/11/13
f 23/1/23 1/12/1 10/15/10
f 21/10/21 6/5/6 16/6/16
f 14/15/14 16/6/16 5/12/5
f 8/7/8 21/10/21 13/11/13
f 6/5/6 24/8/24 18/16/18
f 30/10/30 2/5/2 19/9/19
f 23/1/23 5/12/5 17/17/17
f 7/2/7 23/1/23 11/3/11
f 20/14/20 4/7/4 12/13/12
f 25/6/25 10/15/10 1/12/1
f 5/12/5 22/4/22 17/17/17
f 6/5/6 22/4/22 16/6/16
f 30/10/30 4/7/4 9/11/9
f 7/2/7 21/10/21 14/15/14
f 46/18/46 43/19/43 31/20/31
f 45/21/45 42/22/42 51/23/51
f 35/24/35 32/25/32 29/26/29
f 46/18/46 52/27/52 49/28/49
f 39/29/39 42/22/42 37/30/37
f 45/21/45 44/31/44 38/32/38
f 32/25/32 50/24/50 47/26/47
f 46/18/46 40/33/40 48/34/48
f 40/33/40 29/26/29 32/25/32
f 28/18/28 40/33/40 31/20/31
f 43/19/43 39/29/39 37/30/37
f 41/27/41 27/21/27 35/24/35
f 26/29/26 41/27/41 34/28/34
f 41/27/41 29/26/29 33/34/33
f 27/21/27 44/31/44 35/24/35
f 52/27/52 45/21/45 51/23/51
f 43/19/43 26/29/26 34/28/34
f 43/19/43 28/18/28 31/20/31
f 40/33/40 47/26/47 48/34/48
f 39/29/39 52/27/52 51/23/51
f 26/29/26 42/22/42 36/23/36
f 42/22/42 27/21/27 36/23/36
f 47/26/47 52/27/52 48/34/48
f 28/18/28 41/27/41 33/34/33
f 61/35/61 62/36/62 73/37/73
f 62/36/62 63/38/63 73/37/73
f 60/39/60 78/40/78 69/41/69
f 63/42/63 64/43/64 73/44/73
f 61/45/61 64/43/64 55/46/55
f 103/47/103 85/48/85 91/49/91
f 55/46/55 77/50/77 61/45/61
f 104/51/104 80/52/80 89/53/89
f 74/54/74 60/39/60 67/55/67
f 103/56/103 79/57/79 97/58/97
f 59/59/59 74/54/74 67/55/67
f 102/60/102 79/57/79 88/61/88
f 55/46/55 74/54/74 65/62/65
f 69/63/69 70/64/70 75/65/75
f 68/66/68 70/64/70 57/67/57
f 67/55/67 69/41/69 75/68/75
f 58/69/58 78/70/78 72/71/72
f 100/72/100 81/73/81 91/49/91
f 77/74/77 57/67/57 71/75/71
f 59/59/59 77/50/77 65/62/65
f 103/56/103 83/76/83 94/77/94
f 102/60/102 80/52/80 98/78/98
f 87/79/87 88/61/88 79/57/79
f 100/72/100 82/80/82 90/81/90
f 88/61/88 89/53/89 80/52/80
f 102/60/102 84/82/84 96/83/96
f 89/84/89 90/81/90 82/80/82
f 104/85/104 82/80/82 92/86/92
f 87/87/87 90/81/90 99/88/99
f 103/47/103 81/73/81 87/87/87
f 86/89/86 100/72/100 93/90/93
f 104/85/104 86/89/86 95/91/95
f 100/72/100 85/48/85 93/90/93
f 56/92/56 74/54/74 64/43/64
f 95/93/95 96/83/96 84/82/84
f 104/51/104 84/82/84 98/78/98
f 94/77/94 96/83/96 101/94/101
f 95/91/95 93/90/93 101/95/101
f 54/96/54 76/97/76 72/71/72
f 102/60/102 83/76/83 97/58/97
f 94/98/94 93/90/93 85/48/85
f 53/99/53 77/74/77 71/75/71
f 76/97/76 53/99/53 71/75/71
f 56/92/56 78/40/78 66/100/66
f 57/67/57 76/97/76 71/75/71
f 58/69/58 76/97/76 70/64/70
f 78/70/78 54/96/54 72/71/72
f 67/55/67 68/101/68 59/59/59
f 117/102/117 251/103/251 238/104/238
f 120/105/120 251/103/251 159/106/159
f 239/107/239 168/108/168 251/103/251
f 251/103/251 112/109/112 238/104/238
f 129/110/129 252/111/252 178/112/178
f 244/113/244 172/114/172 252/111/252
f 252/111/252 111/115/111 243/116/243
f 178/112/178 243/116/243 118/117/118
f 117/102/117 253/118/253 159/106/159
f 110/119/110 253/118/253 157/120/157
f 156/121/156 158/122/158 253/118/253
f 253/118/253 120/105/120 159/106/159
f 115/123/115 254/124/254 224/125/224
f 199/126/199 227/127/227 254/124/254
f 227/127/227 173/128/173 254/124/254
f 254/124/254 124/129/124 224/125/224
f 210/130/210 186/131/186 135/132/135
f 136/133/136 255/134/255 210/130/210
f 193/135/193 209/136/209 255/134/255
f 255/134/255 134/137/134 186/131/186
f 130/138/130 256/139/256 179/140/179
f 245/141/245 170/142/170 256/139/256
f 170/142/170 244/113/244 256/139/256
f 179/140/179 244/113/244 129/110/129
f 231/143/231 234/144/234 153/145/153
f 132/146/132 257/147/257 231/143/231
f 236/148/236 220/149/220 257/147/257
f 257/147/257 154/150/154 234/144/234
f 168/108/168 161/151/161 112/109/112
f 114/152/114 258/153/258 168/108/168
f 258/153/258 140/154/140 226/155/226
f 258/153/258 132/156/132 161/151/161
f 222/157/222 215/158/215 146/159/146
f 147/160/147 259/161/259 222/157/222
f 202/162/202 225/163/225 259/161/259
f 259/161/259 122/164/122 215/158/215
f 214/165/214 249/166/249 143/167/143
f 139/168/139 260/169/260 214/165/214
f 241/170/241 232/171/232 260/169/260
f 260/169/260 154/150/154 249/166/249
f 142/172/142 261/173/261 221/174/221
f 213/175/213 188/176/188 261/173/261
f 261/173/261 128/177/128 212/178/212
f 221/174/221 212/178/212 141/179/141
f 148/180/148 262/181/262 183/182/183
f 206/183/206 230/184/230 262/181/262
f 262/181/262 152/185/152 233/186/233
f 183/182/183 233/186/233 153/187/153
f 129/110/129 263/188/263 189/189/189
f 178/112/178 155/190/155 263/188/263
f 263/188/263 109/191/109 175/192/175
f 189/189/189 175/192/175 127/193/127
f 123/194/123 264/195/264 169/196/169
f 165/197/165 155/190/155 264/195/264
f 264/195/264 118/117/118 167/198/167
f 169/196/169 167/198/167 126/199/126
f 190/200/190 229/201/229 149/202/149
f 148/203/148 265/204/265 190/200/190
f 228/205/228 204/206/204 265/204/265
f 265/204/265 150/207/150 229/201/229
f 133/208/133 266/209/266 208/210/208
f 240/211/240 167/198/167 266/209/266
f 266/209/266 118/117/118 243/116/243
f 208/210/208 243/116/243 111/115/111
f 181/212/181 187/213/187 139/168/139
f 137/214/137 267/215/267 181/212/181
f 267/215/267 136/133/136 203/216/203
f 187/213/187 203/216/203 138/217/138
f 160/218/160 156/121/156 110/119/110
f 122/219/122 268/220/268 160/218/160
f 268/220/268 124/221/124 162/222/162
f 268/220/268 113/223/113 156/121/156
f 187/213/187 241/170/241 139/168/139
f 187/213/187 248/224/248 269/225/269
f 269/225/269 150/207/150 204/206/204
f 269/225/269 151/226/151 241/170/241
f 113/223/113 270/227/270 158/122/158
f 162/222/162 173/228/173 270/227/270
f 270/227/270 125/229/125 163/230/163
f 158/122/158 163/230/163 120/105/120
f 184/231/184 240/232/240 133/233/133
f 107/234/107 271/235/271 184/231/184
f 246/236/246 205/237/205 271/235/271
f 271/235/271 126/238/126 240/232/240
f 219/239/219 214/165/214 143/167/143
f 147/160/147 272/240/272 219/239/219
f 216/241/216 181/212/181 272/240/272
f 272/240/272 139/168/139 214/165/214
f 116/242/116 273/243/273 247/244/247
f 140/245/140 273/243/273 235/246/235
f 237/247/237 227/127/227 273/243/273
f 247/244/247 227/127/227 131/248/131
f 119/249/119 274/250/274 201/251/201
f 198/252/198 199/126/199 274/250/274
f 274/250/274 115/123/115 197/253/197
f 201/251/201 197/253/197 106/254/106
f 169/255/169 207/256/207 123/257/123
f 126/238/126 275/258/275 169/255/169
f 205/237/205 200/259/200 275/258/275
f 275/258/275 105/260/105 207/256/207
f 208/210/208 223/261/223 133/208/133
f 111/115/111 276/262/276 208/210/208
f 172/114/172 166/263/166 276/262/276
f 276/262/276 149/264/149 223/261/223
f 182/265/182 242/266/242 119/249/119
f 182/265/182 249/166/249 277/267/277
f 249/166/249 220/149/220 277/267/277
f 277/267/277 108/268/108 242/266/242
f 130/138/130 278/269/278 188/176/188
f 179/140/179 189/189/189 278/269/278
f 189/189/189 176/270/176 278/269/278
f 188/176/188 176/270/176 128/177/128
f 197/253/197 225/163/225 106/254/106
f 115/123/115 279/271/279 197/253/197
f 224/125/224 171/272/171 279/271/279
f 279/271/279 122/164/122 225/163/225
f 236/148/236 211/273/211 108/268/108
f 132/146/132 280/274/280 236/148/236
f 226/275/226 235/246/235 280/274/280
f 280/274/280 116/242/116 211/273/211
f 138/217/138 281/276/281 248/224/248
f 194/277/194 246/236/246 281/276/281
f 281/276/281 107/234/107 218/278/218
f 248/224/248 218/278/218 150/207/150
f 119/249/119 282/279/282 198/252/198
f 242/266/242 211/273/211 282/279/282
f 282/279/282 116/242/116 247/244/247
f 198/252/198 247/244/247 131/248/131
f 146/280/146 283/281/283 217/282/217
f 215/283/215 160/218/160 283/281/283
f 283/281/283 110/119/110 177/284/177
f 217/282/217 177/284/177 141/179/141
f 114/152/114 284/285/284 196/286/196
f 239/107/239 163/230/163 284/285/284
f 284/285/284 125/229/125 237/287/237
f 196/286/196 237/287/237 140/154/140
f 174/288/174 165/197/165 123/194/123
f 135/289/135 285/290/285 174/288/174
f 191/291/191 175/192/175 285/290/285
f 285/290/285 109/191/109 165/197/165
f 135/289/135 286/292/286 191/291/191
f 186/293/186 192/294/192 286/292/286
f 286/292/286 128/177/128 176/270/176
f 286/292/286 127/193/127 191/291/191
f 138/217/138 287/295/287 194/277/194
f 203/216/203 195/296/195 287/295/287
f 287/295/287 105/260/105 200/259/200
f 194/277/194 200/259/200 121/297/121
f 153/187/153 288/298/288 231/299/231
f 233/186/233 164/300/164 288/298/288
f 288/298/288 112/109/112 161/151/161
f 231/299/231 161/151/161 132/156/132
f 123/257/123 289/301/289 174/302/174
f 105/260/105 289/301/289 207/256/207
f 289/301/289 136/133/136 210/130/210
f 289/301/289 135/132/135 174/302/174
f 134/303/134 290/304/290 192/294/192
f 185/305/185 217/282/217 290/304/290
f 290/304/290 141/179/141 212/178/212
f 192/294/192 212/178/212 128/177/128
f 133/233/133 291/306/291 184/231/184
f 149/202/149 291/306/291 223/307/223
f 291/306/291 150/207/150 218/278/218
f 291/306/291 107/234/107 184/231/184
f 117/102/117 292/308/292 180/309/180
f 238/104/238 164/300/164 292/308/292
f 292/308/292 152/185/152 250/310/250
f 180/309/180 250/310/250 142/172/142
f 149/264/149 293/311/293 190/312/190
f 144/313/144 293/311/293 166/263/166
f 293/311/293 145/314/145 206/183/206
f 190/312/190 206/183/206 148/180/148
f 201/251/201 182/265/182 119/249/119
f 106/254/106 294/315/294 201/251/201
f 202/162/202 219/239/219 294/315/294
f 182/265/182 219/239/219 143/167/143
f 183/316/183 228/205/228 148/203/148
f 153/145/153 295/317/295 183/316/183
f 234/144/234 232/171/232 295/317/295
f 295/317/295 151/226/151 228/205/228
f 117/102/117 296/318/296 157/120/157
f 180/309/180 221/174/221 296/318/296
f 296/318/296 141/179/141 177/284/177
f 157/120/157 177/284/177 110/119/110
f 209/136/209 185/319/185 134/137/134
f 137/214/137 297/320/297 209/136/209
f 216/241/216 222/157/222 297/320/297
f 297/320/297 146/159/146 185/319/185
f 142/172/142 298/321/298 213/175/213
f 250/310/250 230/184/230 298/321/298
f 298/321/298 145/314/145 245/141/245
f 213/175/213 245/141/245 130/138/130
f 311/322/311 445/323/445 353/324/353
f 445/323/445 314/325/314 353/324/353
f 445/323/445 308/326/308 433/327/433
f 306/328/306 445/323/445 432/329/432
f 323/330/323 446/331/446 438/332/438
f 438/332/438 366/333/366 338/334/338
f 446/331/446 305/335/305 366/333/366
f 372/336/372 437/337/437 446/331/446
f 311/322/311 447/338/447 351/339/351
f 447/338/447 304/340/304 351/339/351
f 447/338/447 307/341/307 350/342/350
f 314/325/314 447/338/447 353/324/353
f 309/343/309 448/344/448 393/345/393
f 448/344/448 325/346/325 393/345/393
f 367/347/367 421/348/421 448/344/448
f 318/349/318 448/344/448 418/350/418
f 380/351/380 404/352/404 329/353/329
f 449/354/449 330/355/330 404/352/404
f 403/356/403 387/357/387 449/354/449
f 328/358/328 449/354/449 380/351/380
f 324/359/324 450/360/450 439/361/439
f 439/361/439 364/362/364 339/363/339
f 438/332/438 364/362/364 450/360/450
f 373/364/373 438/332/438 450/360/450
f 428/365/428 425/366/425 347/367/347
f 451/368/451 326/369/326 425/366/425
f 414/370/414 430/371/430 451/368/451
f 348/372/348 451/368/451 428/365/428
f 355/373/355 362/374/362 306/328/306
f 452/375/452 308/326/308 362/374/362
f 452/375/452 334/376/334 390/377/390
f 326/378/326 452/375/452 355/373/355
f 409/379/409 416/380/416 340/381/340
f 453/382/453 341/383/341 416/380/416
f 419/384/419 396/385/396 453/382/453
f 316/386/316 453/382/453 409/379/409
f 443/387/443 408/388/408 337/389/337
f 454/390/454 333/391/333 408/388/408
f 426/392/426 435/393/435 454/390/454
f 348/372/348 454/390/454 443/387/443
f 336/394/336 455/395/455 407/396/407
f 407/396/407 382/397/382 324/359/324
f 455/395/455 322/398/322 382/397/382
f 415/399/415 406/400/406 455/395/455
f 342/401/342 456/402/456 400/403/400
f 400/403/400 424/404/424 339/363/339
f 456/402/456 346/405/346 424/404/424
f 377/406/377 427/407/427 456/402/456
f 323/330/323 457/408/457 372/336/372
f 372/336/372 349/409/349 312/410/312
f 457/408/457 303/411/303 349/409/349
f 383/412/383 369/413/369 457/408/457
f 317/414/317 458/415/458 359/416/359
f 458/415/458 303/411/303 359/416/359
f 458/415/458 312/410/312 349/409/349
f 363/417/363 361/418/361 458/415/458
f 423/419/423 384/420/384 343/421/343
f 459/422/459 342/423/342 384/420/384
f 398/424/398 422/425/422 459/422/459
f 344/426/344 459/422/459 423/419/423
f 327/427/327 460/428/460 434/429/434
f 434/429/434 361/418/361 320/430/320
f 460/428/460 312/410/312 361/418/361
f 305/335/305 460/428/460 402/431/402
f 381/432/381 375/433/375 333/391/333
f 461/434/461 331/435/331 375/433/375
f 461/434/461 330/355/330 387/357/387
f 381/432/381 397/436/397 461/434/461
f 350/342/350 354/437/354 304/340/304
f 462/438/462 316/439/316 354/437/354
f 462/438/462 318/440/318 365/441/365
f 307/341/307 462/438/462 350/342/350
f 435/393/435 381/432/381 333/391/333
f 381/432/381 442/442/442 332/443/332
f 463/444/463 344/426/344 442/442/442
f 345/445/345 463/444/463 435/393/435
f 307/341/307 464/446/464 356/447/356
f 356/447/356 367/448/367 318/440/318
f 464/446/464 319/449/319 367/448/367
f 352/450/352 357/451/357 464/446/464
f 434/452/434 378/453/378 327/454/327
f 465/455/465 301/456/301 378/453/378
f 399/457/399 440/458/440 465/455/465
f 320/459/320 465/455/465 434/452/434
f 408/388/408 413/460/413 337/389/337
f 466/461/466 341/383/341 413/460/413
f 375/433/375 410/462/410 466/461/466
f 333/391/333 466/461/466 408/388/408
f 310/463/310 467/464/467 429/465/429
f 467/464/467 334/466/334 429/465/429
f 421/348/421 431/467/431 467/464/467
f 325/346/325 467/464/467 441/468/441
f 313/469/313 468/470/468 392/471/392
f 392/471/392 393/345/393 325/346/325
f 468/470/468 309/343/309 393/345/393
f 395/472/395 391/473/391 468/470/468
f 401/474/401 363/475/363 317/476/317
f 469/477/469 320/459/320 363/475/363
f 394/478/394 399/457/399 469/477/469
f 299/479/299 469/477/469 401/474/401
f 417/480/417 402/431/402 327/427/327
f 470/481/470 305/335/305 402/431/402
f 360/482/360 366/333/366 470/481/470
f 343/483/343 470/481/470 417/480/417
f 436/484/436 376/485/376 313/469/313
f 471/486/471 337/389/337 376/485/376
f 414/370/414 443/387/443 471/486/471
f 302/487/302 471/486/471 436/484/436
f 324/359/324 472/488/472 373/364/373
f 373/364/373 383/412/383 323/330/323
f 370/489/370 383/412/383 472/488/472
f 382/397/382 370/489/370 472/488/472
f 419/384/419 391/473/391 300/490/300
f 473/491/473 309/343/309 391/473/391
f 365/492/365 418/350/418 473/491/473
f 316/386/316 473/491/473 419/384/419
f 405/493/405 430/371/430 302/487/302
f 474/494/474 326/369/326 430/371/430
f 429/465/429 420/495/420 474/494/474
f 310/463/310 474/494/474 405/493/405
f 332/443/332 475/496/475 388/497/388
f 388/497/388 440/458/440 315/498/315
f 475/496/475 301/456/301 440/458/440
f 442/442/442 412/499/412 475/496/475
f 313/469/313 476/500/476 436/484/436
f 436/484/436 405/493/405 302/487/302
f 476/500/476 310/463/310 405/493/405
f 392/471/392 441/468/441 476/500/476
f 340/501/340 477/502/477 409/503/409
f 409/503/409 354/437/354 316/439/316
f 477/502/477 304/340/304 354/437/354
f 411/504/411 371/505/371 477/502/477
f 308/326/308 478/506/478 433/327/433
f 433/327/433 357/451/357 314/325/314
f 478/506/478 319/449/319 357/451/357
f 390/377/390 431/507/431 478/506/478
f 359/416/359 368/508/368 317/414/317
f 479/509/479 329/510/329 368/508/368
f 369/413/369 385/511/385 479/509/479
f 303/411/303 479/509/479 359/416/359
f 329/510/329 480/512/480 380/513/380
f 380/513/380 386/514/386 328/515/328
f 480/512/480 322/398/322 386/514/386
f 321/516/321 480/512/480 385/511/385
f 332/443/332 481/517/481 397/436/397
f 397/436/397 389/518/389 330/355/330
f 481/517/481 299/479/299 389/518/389
f 388/497/388 394/478/394 481/517/481
f 347/519/347 482/520/482 427/407/427
f 427/407/427 358/521/358 346/405/346
f 482/520/482 306/328/306 358/521/358
f 425/522/425 355/373/355 482/520/482
f 317/476/317 483/523/483 401/474/401
f 483/523/483 299/479/299 401/474/401
f 483/523/483 330/355/330 389/518/389
f 368/524/368 404/352/404 483/523/483
f 328/515/328 484/525/484 379/526/379
f 379/526/379 411/504/411 340/501/340
f 484/525/484 335/527/335 411/504/411
f 386/514/386 406/400/406 484/525/484
f 327/454/327 485/528/485 417/529/417
f 417/529/417 423/419/423 343/421/343
f 485/528/485 344/426/344 423/419/423
f 301/456/301 485/528/485 378/453/378
f 311/322/311 486/530/486 432/329/432
f 432/329/432 358/521/358 306/328/306
f 486/530/486 346/405/346 358/521/358
f 374/531/374 444/532/444 486/530/486
f 343/483/343 487/533/487 360/482/360
f 487/533/487 338/334/338 360/482/360
f 487/533/487 339/363/339 364/362/364
f 384/534/384 400/403/400 487/533/487
f 376/485/376 395/472/395 313/469/313
f 488/535/488 300/490/300 395/472/395
f 413/460/413 396/385/396 488/535/488
f 337/389/337 488/535/488 376/485/376
f 422/425/422 377/536/377 342/423/342
f 489/537/489 347/367/347 377/536/377
f 426/392/426 428/365/428 489/537/489
f 345/445/345 489/537/489 422/425/422
f 311/322/311 490/538/490 374/531/374
f 374/531/374 415/399/415 336/394/336
f 490/538/490 335/527/335 415/399/415
f 351/339/351 371/505/371 490/538/490
f 379/539/379 403/356/403 328/358/328
f 491/540/491 331/435/331 403/356/403
f 416/380/416 410/462/410 491/540/491
f 340/381/340 491/540/491 379/539/379
f 336/394/336 492/541/492 444/532/444
f 444/532/444 424/404/424 346/405/346
f 492/541/492 339/363/339 424/404/424
f 407/396/407 439/361/439 492/541/492
f 493/542/493 513/543/513 501/544/501
f 494/545/494 513/543/513 502/546/502
f 513/543/513 496/547/496 504/548/504
f 513/543/513 495/549/495 501/544/501
f 504/548/504 505/550/505 495/549/495
f 504/548/504 506/551/506 514/552/514
f 506/551/506 507/553/507 514/552/514
f 505/550/505 507/553/507 499/554/499
f 499/554/499 515/555/515 508/556/508
f 500/557/500 515/555/515 507/553/507
f 515/555/515 498/558/498 510/559/510
f 515/555/515 497/560/497 508/556/508
f 510/559/510 511/561/511 497/560/497
f 510/559/510 512/562/512 516/563/516
f 512/562/512 502/564/502 516/563/516
f 511/561/511 502/564/502 493/565/493
f 495/566/495 517/567/517 501/568/501
f 499/554/499 517/567/517 505/569/505
f 517/567/517 497/560/497 511/570/511
f 517/567/517 493/571/493 501/568/501
f 500/557/500 518/572/518 509/573/509
f 496/574/496 518/572/518 506/575/506
f 518/572/518 494/576/494 512/577/512
f 518/572/518 498/558/498 509/573/509
f 519/542/519 539/543/539 528/546/528
f 539/543/539 520/545/520 528/546/528
f 539/543/539 522/547/522 529/578/529
f 521/549/521 539/543/539 527/544/527
f 531/550/531 530/548/530 521/549/521
f 530/548/530 532/551/532 522/547/522
f 533/553/533 532/551/532 540/552/540
f 531/550/531 533/553/533 540/552/540
f 525/554/525 541/555/541 533/553/533
f 541/555/541 526/557/526 533/553/533
f 541/555/541 524/558/524 535/573/535
f 523/560/523 541/555/541 534/556/534
f 537/561/537 536/559/536 523/560/523
f 536/559/536 538/562/538 524/558/524
f 528/564/528 538/562/538 542/563/542
f 537/561/537 528/564/528 542/563/542
f 521/566/521 543/567/517 531/569/531
f 543/567/517 525/554/525 531/569/531
f 543/567/517 523/560/523 534/556/534
f 519/571/519 543/567/517 527/568/527
f 526/557/526 544/572/543 532/575/532
f 544/572/543 522/574/522 532/575/532
f 544/572/543 520/576/520 529/579/529
f 524/558/524 544/572/543 535/573/535
f 545/580/544 565/581/564 554/582/553
f 565/581/564 546/583/545 554/582/553
f 565/581/564 548/584/547 555/585/554
f 547/586/546 565/581/564 553/587/552
f 557/588/556 556/589/555 547/586/546
f 566/590/565 548/584/547 556/589/555
f 566/590/565 552/591/551 558/592/557
f 557/588/556 559/593/558 566/590/565
f 551/594/550 567/595/566 559/593/558
f 567/595/566 552/591/551 559/593/558
f 567/595/566 550/596/549 561/597/560
f 549/598/548 567/595/566 560/599/559
f 563/600/562 562/601/561 549/598/548
f 562/601/561 564/602/563 550/596/549
f 554/603/553 564/602/563 568/604/567
f 563/600/562 554/603/553 568/604/567
f 547/605/546 569/606/568 557/607/556
f 569/606/568 551/594/550 557/607/556
f 569/606/568 549/598/548 560/599/559
f 545/608/544 569/606/568 553/609/552
f 552/591/551 570/610/569 558/611/557
f 570/610/569 548/612/547 558/611/557
f 570/610/569 546/613/545 555/614/554
f 550/596/549 570/610/569 561/597/560
f 571/615/570 591/616/590 579/617/578
f 572/618/571 591/616/590 580/619/579
f 591/616/590 574/620/573 582/621/581
f 591/616/590 573/622/572 579/617/578
f 582/621/581 583/623/582 573/622/572
f 574/620/573 592/624/591 582/621/581
f 592/624/591 578/625/577 585/626/584
f 583/623/582 585/626/584 577/627/576
f 577/627/576 593/628/592 586/629/585
f 578/625/577 593/628/592 585/626/584
f 593/628/592 576/630/575 588/631/587
f 593/628/592 575/632/574 586/629/585
f 588/631/587 589/633/588 575/632/574
f 588/631/587 590/634/589 594/635/593
f 590/634/589 580/636/579 594/635/593
f 589/633/588 580/636/579 571/637/570
f 573/638/572 595/639/568 579/640/578
f 577/627/576 595/639/568 583/641/582
f 595/639/568 575/632/574 589/642/588
f 595/639/568 571/643/570 579/640/578
f 578/625/577 596/644/594 587/645/586
f 574/646/573 596/644/594 584/647/583
f 596/644/594 572/648/571 590/649/589
f 596/644/594 576/630/575 587/645/586
f 23/1/23 10/15/10 3/2/3
f 22/4/22 18/16/18 2/5/2
f 8/7/8 12/13/12 24/8/24
f 3/2/3 10/15/10 30/10/30
f 1/12/1 17/17/17 22/4/22
f 2/5/2 18/16/18 24/8/24
f 4/7/4 19/9/19 24/8/24
f 3/2/3 9/11/9 20/14/20
f 20/14/20 12/13/12 8/7/8
f 7/2/7 11/3/11 20/14/20
f 23/1/23 17/17/17 1/12/1
f 21/10/21 15/9/15 6/5/6
f 14/15/14 21/10/21 16/6/16
f 8/7/8 15/9/15 21/10/21
f 6/5/6 15/9/15 24/8/24
f 30/10/30 25/6/25 2/5/2
f 23/1/23 14/15/14 5/12/5
f 7/2/7 14/15/14 23/1/23
f 20/14/20 9/11/9 4/7/4
f 25/6/25 30/10/30 10/15/10
f 5/12/5 16/6/16 22/4/22
f 6/5/6 18/16/18 22/4/22
f 30/10/30 19/9/19 4/7/4
f 7/2/7 13/11/13 21/10/21
f 46/18/46 49/28/49 43/19/43
f 45/21/45 38/32/38 42/22/42
f 35/24/35 44/31/44 32/25/32
f 46/18/46 48/34/48 52/27/52
f 39/29/39 51/23/51 42/22/42
f 45/21/45 50/24/50 44/31/44
f 32/25/32 44/31/44 50/24/50
f 46/18/46 31/20/31 40/33/40
f 40/33/40 33/34/33 29/26/29
f 28/18/28 33/34/33 40/33/40
f 43/19/43 49/28/49 39/29/39
f 41/27/41 36/23/36 27/21/27
f 26/29/26 36/23/36 41/27/41
f 41/27/41 35/24/35 29/26/29
f 27/21/27 38/32/38 44/31/44
f 52/27/52 50/24/50 45/21/45
f 43/19/43 37/30/37 26/29/26
f 43/19/43 34/28/34 28/18/28
f 40/33/40 32/25/32 47/26/47
f 39/29/39 49/28/49 52/27/52
f 26/29/26 37/30/37 42/22/42
f 42/22/42 38/32/38 27/21/27
f 47/26/47 50/24/50 52/27/52
f 28/18/28 34/28/34 41/27/41
f 61/35/61 53/99/53 62/36/62
f 62/36/62 54/96/54 63/38/63
f 60/39/60 66/100/66 78/40/78
f 63/42/63 56/92/56 64/43/64
f 61/45/61 73/44/73 64/43/64
f 103/47/103 94/98/94 85/48/85
f 55/46/55 65/62/65 77/50/77
f 104/51/104 98/78/98 80/52/80
f 74/54/74 66/100/66 60/39/60
f 103/56/103 87/79/87 79/57/79
f 59/59/59 65/62/65 74/54/74
f 102/60/102 97/58/97 79/57/79
f 55/46/55 64/43/64 74/54/74
f 69/63/69 58/69/58 70/64/70
f 68/66/68 75/65/75 70/64/70
f 67/55/67 60/39/60 69/41/69
f 58/69/58 69/63/69 78/70/78
f 100/72/100 90/81/90 81/73/81
f 77/74/77 68/66/68 57/67/57
f 59/59/59 68/101/68 77/50/77
f 103/56/103 97/58/97 83/76/83
f 102/60/102 88/61/88 80/52/80
f 87/79/87 99/650/99 88/61/88
f 100/72/100 92/86/92 82/80/82
f 88/61/88 99/650/99 89/53/89
f 102/60/102 98/78/98 84/82/84
f 89/84/89 99/88/99 90/81/90
f 104/85/104 89/84/89 82/80/82
f 87/87/87 81/73/81 90/81/90
f 103/47/103 91/49/91 81/73/81
f 86/89/86 92/86/92 100/72/100
f 104/85/104 92/86/92 86/89/86
f 100/72/100 91/49/91 85/48/85
f 56/92/56 66/100/66 74/54/74
f 95/93/95 101/94/101 96/83/96
f 104/51/104 95/93/95 84/82/84
f 94/77/94 83/76/83 96/83/96
f 95/91/95 86/89/86 93/90/93
f 54/96/54 62/36/62 76/97/76
f 102/60/102 96/83/96 83/76/83
f 94/98/94 101/95/101 93/90/93
f 53/99/53 61/35/61 77/74/77
f 76/97/76 62/36/62 53/99/53
f 56/92/56 63/42/63 78/40/78
f 57/67/57 70/64/70 76/97/76
f 58/69/58 72/71/72 76/97/76
f 78/70/78 63/38/63 54/96/54
f 67/55/67 75/68/75 68/101/68
f 117/102/117 159/106/159 251/103/251
f 120/105/120 239/107/239 251/103/251
f 239/107/239 114/152/114 168/108/168
f 251/103/251 168/108/168 112/109/112
f 129/110/129 244/113/244 252/111/252
f 244/113/244 144/313/144 172/114/172
f 252/111/252 172/114/172 111/115/111
f 178/112/178 252/111/252 243/116/243
f 117/102/117 157/120/157 253/118/253
f 110/119/110 156/121/156 253/118/253
f 156/121/156 113/223/113 158/122/158
f 253/118/253 158/122/158 120/105/120
f 115/123/115 199/126/199 254/124/254
f 199/126/199 131/248/131 227/127/227
f 227/127/227 125/651/125 173/128/173
f 254/124/254 173/128/173 124/129/124
f 210/130/210 255/134/255 186/131/186
f 136/133/136 193/135/193 255/134/255
f 193/135/193 137/214/137 209/136/209
f 255/134/255 209/136/209 134/137/134
f 130/138/130 245/141/245 256/139/256
f 245/141/245 145/314/145 170/142/170
f 170/142/170 144/313/144 244/113/244
f 179/140/179 256/139/256 244/113/244
f 231/143/231 257/147/257 234/144/234
f 132/146/132 236/148/236 257/147/257
f 236/148/236 108/268/108 220/149/220
f 257/147/257 220/149/220 154/150/154
f 168/108/168 258/153/258 161/151/161
f 114/152/114 196/286/196 258/153/258
f 258/153/258 196/286/196 140/154/140
f 258/153/258 226/155/226 132/156/132
f 222/157/222 259/161/259 215/158/215
f 147/160/147 202/162/202 259/161/259
f 202/162/202 106/254/106 225/163/225
f 259/161/259 225/163/225 122/164/122
f 214/165/214 260/169/260 249/166/249
f 139/168/139 241/170/241 260/169/260
f 241/170/241 151/226/151 232/171/232
f 260/169/260 232/171/232 154/150/154
f 142/172/142 213/175/213 261/173/261
f 213/175/213 130/138/130 188/176/188
f 261/173/261 188/176/188 128/177/128
f 221/174/221 261/173/261 212/178/212
f 148/180/148 206/183/206 262/181/262
f 206/183/206 145/314/145 230/184/230
f 262/181/262 230/184/230 152/185/152
f 183/182/183 262/181/262 233/186/233
f 129/110/129 178/112/178 263/188/263
f 178/112/178 118/117/118 155/190/155
f 263/188/263 155/190/155 109/191/109
f 189/189/189 263/188/263 175/192/175
f 123/194/123 165/197/165 264/195/264
f 165/197/165 109/191/109 155/190/155
f 264/195/264 155/190/155 118/117/118
f 169/196/169 264/195/264 167/198/167
f 190/200/190 265/204/265 229/201/229
f 148/203/148 228/205/228 265/204/265
f 228/205/228 151/226/151 204/206/204
f 265/204/265 204/206/204 150/207/150
f 133/208/133 240/211/240 266/209/266
f 240/211/240 126/199/126 167/198/167
f 266/209/266 167/198/167 118/117/118
f 208/210/208 266/209/266 243/116/243
f 181/212/181 267/215/267 187/213/187
f 137/214/137 193/135/193 267/215/267
f 267/215/267 193/135/193 136/133/136
f 187/213/187 267/215/267 203/216/203
f 160/218/160 268/220/268 156/121/156
f 122/219/122 171/652/171 268/220/268
f 268/220/268 171/652/171 124/221/124
f 268/220/268 162/222/162 113/223/113
f 187/213/187 269/225/269 241/170/241
f 187/213/187 138/217/138 248/224/248
f 269/225/269 248/224/248 150/207/150
f 269/225/269 204/206/204 151/226/151
f 113/223/113 162/222/162 270/227/270
f 162/222/162 124/221/124 173/228/173
f 270/227/270 173/228/173 125/229/125
f 158/122/158 270/227/270 163/230/163
f 184/231/184 271/235/271 240/232/240
f 107/234/107 246/236/246 271/235/271
f 246/236/246 121/297/121 205/237/205
f 271/235/271 205/237/205 126/238/126
f 219/239/219 272/240/272 214/165/214
f 147/160/147 216/241/216 272/240/272
f 216/241/216 137/214/137 181/212/181
f 272/240/272 181/212/181 139/168/139
f 116/242/116 235/246/235 273/243/273
f 140/245/140 237/247/237 273/243/273
f 237/247/237 125/651/125 227/127/227
f 247/244/247 273/243/273 227/127/227
f 119/249/119 198/252/198 274/250/274
f 198/252/198 131/248/131 199/126/199
f 274/250/274 199/126/199 115/123/115
f 201/251/201 274/250/274 197/253/197
f 169/255/169 275/258/275 207/256/207
f 126/238/126 205/237/205 275/258/275
f 205/237/205 121/297/121 200/259/200
f 275/258/275 200/259/200 105/260/105
f 208/210/208 276/262/276 223/261/223
f 111/115/111 172/114/172 276/262/276
f 172/114/172 144/313/144 166/263/166
f 276/262/276 166/263/166 149/264/149
f 182/265/182 277/267/277 242/266/242
f 182/265/182 143/167/143 249/166/249
f 249/166/249 154/150/154 220/149/220
f 277/267/277 220/149/220 108/268/108
f 130/138/130 179/140/179 278/269/278
f 179/140/179 129/110/129 189/189/189
f 189/189/189 127/193/127 176/270/176
f 188/176/188 278/269/278 176/270/176
f 197/253/197 279/271/279 225/163/225
f 115/123/115 224/125/224 279/271/279
f 224/125/224 124/129/124 171/272/171
f 279/271/279 171/272/171 122/164/122
f 236/148/236 280/274/280 211/273/211
f 132/146/132 226/275/226 280/274/280
f 226/275/226 140/245/140 235/246/235
f 280/274/280 235/246/235 116/242/116
f 138/217/138 194/277/194 281/276/281
f 194/277/194 121/297/121 246/236/246
f 281/276/281 246/236/246 107/234/107
f 248/224/248 281/276/281 218/278/218
f 119/249/119 242/266/242 282/279/282
f 242/266/242 108/268/108 211/273/211
f 282/279/282 211/273/211 116/242/116
f 198/252/198 282/279/282 247/244/247
f 146/280/146 215/283/215 283/281/283
f 215/283/215 122/219/122 160/218/160
f 283/281/283 160/218/160 110/119/110
f 217/282/217 283/281/283 177/284/177
f 114/152/114 239/107/239 284/285/284
f 239/107/239 120/105/120 163/230/163
f 284/285/284 163/230/163 125/229/125
f 196/286/196 284/285/284 237/287/237
f 174/288/174 285/290/285 165/197/165
f 135/289/135 191/291/191 285/290/285
f 191/291/191 127/193/127 175/192/175
f 285/290/285 175/192/175 109/191/109
f 135/289/135 186/293/186 286/292/286
f 186/293/186 134/303/134 192/294/192
f 286/292/286 192/294/192 128/177/128
f 286/292/286 176/270/176 127/193/127
f 138/217/138 203/216/203 287/295/287
f 203/216/203 136/133/136 195/296/195
f 287/295/287 195/296/195 105/260/105
f 194/277/194 287/295/287 200/259/200
f 153/187/153 233/186/233 288/298/288
f 233/186/233 152/185/152 164/300/164
f 288/298/288 164/300/164 112/109/112
f 231/299/231 288/298/288 161/151/161
f 123/257/123 207/256/207 289/301/289
f 105/260/105 195/296/195 289/301/289
f 289/301/289 195/296/195 136/133/136
f 289/301/289 210/130/210 135/132/135
f 134/303/134 185/305/185 290/304/290
f 185/305/185 146/280/146 217/282/217
f 290/304/290 217/282/217 141/179/141
f 192/294/192 290/304/290 212/178/212
f 133/233/133 223/307/223 291/306/291
f 149/202/149 229/201/229 291/306/291
f 291/306/291 229/201/229 150/207/150
f 291/306/291 218/278/218 107/234/107
f 117/102/117 238/104/238 292/308/292
f 238/104/238 112/109/112 164/300/164
f 292/308/292 164/300/164 152/185/152
f 180/309/180 292/308/292 250/310/250
f 149/264/149 166/263/166 293/311/293
f 144/313/144 170/142/170 293/311/293
f 293/311/293 170/142/170 145/314/145
f 190/312/190 293/311/293 206/183/206
f 201/251/201 294/315/294 182/265/182
f 106/254/106 202/162/202 294/315/294
f 202/162/202 147/160/147 219/239/219
f 182/265/182 294/315/294 219/239/219
f 183/316/183 295/317/295 228/205/228
f 153/145/153 234/144/234 295/317/295
f 234/144/234 154/150/154 232/171/232
f 295/317/295 232/171/232 151/226/151
f 117/102/117 180/309/180 296/318/296
f 180/309/180 142/172/142 221/174/221
f 296/318/296 221/174/221 141/179/141
f 157/120/157 296/318/296 177/284/177
f 209/136/209 297/320/297 185/319/185
f 137/214/137 216/241/216 297/320/297
f 216/241/216 147/160/147 222/157/222
f 297/320/297 222/157/222 146/159/146
f 142/172/142 250/310/250 298/321/298
f 250/310/250 152/185/152 230/184/230
f 298/321/298 230/184/230 145/314/145
f 213/175/213 298/321/298 245/141/245
f 311/322/311 432/329/432 445/323/445
f 445/323/445 433/327/433 314/325/314
f 445/323/445 362/374/362 308/326/308
f 306/328/306 362/374/362 445/323/445
f 323/330/323 372/336/372 446/331/446
f 438/332/438 446/331/446 366/333/366
f 446/331/446 437/337/437 305/335/305
f 372/336/372 312/410/312 437/337/437
f 311/322/311 353/324/353 447/338/447
f 447/338/447 350/342/350 304/340/304
f 447/338/447 352/450/352 307/341/307
f 314/325/314 352/450/352 447/338/447
f 309/343/309 418/350/418 448/344/448
f 448/344/448 421/348/421 325/346/325
f 367/347/367 319/653/319 421/348/421
f 318/349/318 367/347/367 448/344/448
f 380/351/380 449/354/449 404/352/404
f 449/354/449 387/357/387 330/355/330
f 403/356/403 331/435/331 387/357/387
f 328/358/328 403/356/403 449/354/449
f 324/359/324 373/364/373 450/360/450
f 439/361/439 450/360/450 364/362/364
f 438/332/438 338/334/338 364/362/364
f 373/364/373 323/330/323 438/332/438
f 428/365/428 451/368/451 425/366/425
f 451/368/451 430/371/430 326/369/326
f 414/370/414 302/487/302 430/371/430
f 348/372/348 414/370/414 451/368/451
f 355/373/355 452/375/452 362/374/362
f 452/375/452 390/377/390 308/326/308
f 452/375/452 420/654/420 334/376/334
f 326/378/326 420/654/420 452/375/452
f 409/379/409 453/382/453 416/380/416
f 453/382/453 396/385/396 341/383/341
f 419/384/419 300/490/300 396/385/396
f 316/386/316 419/384/419 453/382/453
f 443/387/443 454/390/454 408/388/408
f 454/390/454 435/393/435 333/391/333
f 426/392/426 345/445/345 435/393/435
f 348/372/348 426/392/426 454/390/454
f 336/394/336 415/399/415 455/395/455
f 407/396/407 455/395/455 382/397/382
f 455/395/455 406/400/406 322/398/322
f 415/399/415 335/527/335 406/400/406
f 342/401/342 377/406/377 456/402/456
f 400/403/400 456/402/456 424/404/424
f 456/402/456 427/407/427 346/405/346
f 377/406/377 347/519/347 427/407/427
f 323/330/323 383/412/383 457/408/457
f 372/336/372 457/408/457 349/409/349
f 457/408/457 369/413/369 303/411/303
f 383/412/383 321/516/321 369/413/369
f 317/414/317 363/417/363 458/415/458
f 458/415/458 349/409/349 303/411/303
f 458/415/458 361/418/361 312/410/312
f 363/417/363 320/430/320 361/418/361
f 423/419/423 459/422/459 384/420/384
f 459/422/459 422/425/422 342/423/342
f 398/424/398 345/445/345 422/425/422
f 344/426/344 398/424/398 459/422/459
f 327/427/327 402/431/402 460/428/460
f 434/429/434 460/428/460 361/418/361
f 460/428/460 437/337/437 312/410/312
f 305/335/305 437/337/437 460/428/460
f 381/432/381 461/434/461 375/433/375
f 461/434/461 387/357/387 331/435/331
f 461/434/461 397/436/397 330/355/330
f 381/432/381 332/443/332 397/436/397
f 350/342/350 462/438/462 354/437/354
f 462/438/462 365/441/365 316/439/316
f 462/438/462 356/447/356 318/440/318
f 307/341/307 356/447/356 462/438/462
f 435/393/435 463/444/463 381/432/381
f 381/432/381 463/444/463 442/442/442
f 463/444/463 398/424/398 344/426/344
f 345/445/345 398/424/398 463/444/463
f 307/341/307 352/450/352 464/446/464
f 356/447/356 464/446/464 367/448/367
f 464/446/464 357/451/357 319/449/319
f 352/450/352 314/325/314 357/451/357
f 434/452/434 465/455/465 378/453/378
f 465/455/465 440/458/440 301/456/301
f 399/457/399 315/498/315 440/458/440
f 320/459/320 399/457/399 465/455/465
f 408/388/408 466/461/466 413/460/413
f 466/461/466 410/462/410 341/383/341
f 375/433/375 331/435/331 410/462/410
f 333/391/333 375/433/375 466/461/466
f 310/463/310 441/468/441 467/464/467
f 467/464/467 431/467/431 334/466/334
f 421/348/421 319/653/319 431/467/431
f 325/346/325 421/348/421 467/464/467
f 313/469/313 395/472/395 468/470/468
f 392/471/392 468/470/468 393/345/393
f 468/470/468 391/473/391 309/343/309
f 395/472/395 300/490/300 391/473/391
f 401/474/401 469/477/469 363/475/363
f 469/477/469 399/457/399 320/459/320
f 394/478/394 315/498/315 399/457/399
f 299/479/299 394/478/394 469/477/469
f 417/480/417 470/481/470 402/431/402
f 470/481/470 366/333/366 305/335/305
f 360/482/360 338/334/338 366/333/366
f 343/483/343 360/482/360 470/481/470
f 436/484/436 471/486/471 376/485/376
f 471/486/471 443/387/443 337/389/337
f 414/370/414 348/372/348 443/387/443
f 302/487/302 414/370/414 471/486/471
f 324/359/324 382/397/382 472/488/472
f 373/364/373 472/488/472 383/412/383
f 370/489/370 321/516/321 383/412/383
f 382/397/382 322/398/322 370/489/370
f 419/384/419 473/491/473 391/473/391
f 473/491/473 418/350/418 309/343/309
f 365/492/365 318/349/318 418/350/418
f 316/386/316 365/492/365 473/491/473
f 405/493/405 474/494/474 430/371/430
f 474/494/474 420/495/420 326/369/326
f 429/465/429 334/466/334 420/495/420
f 310/463/310 429/465/429 474/494/474
f 332/443/332 442/442/442 475/496/475
f 388/497/388 475/496/475 440/458/440
f 475/496/475 412/499/412 301/456/301
f 442/442/442 344/426/344 412/499/412
f 313/469/313 392/471/392 476/500/476
f 436/484/436 476/500/476 405/493/405
f 476/500/476 441/468/441 310/463/310
f 392/471/392 325/346/325 441/468/441
f 340/501/340 411/504/411 477/502/477
f 409/503/409 477/502/477 354/437/354
f 477/502/477 371/505/371 304/340/304
f 411/504/411 335/527/335 371/505/371
f 308/326/308 390/377/390 478/506/478
f 433/327/433 478/506/478 357/451/357
f 478/506/478 431/507/431 319/449/319
f 390/377/390 334/376/334 431/507/431
f 359/416/359 479/509/479 368/508/368
f 479/509/479 385/511/385 329/510/329
f 369/413/369 321/516/321 385/511/385
f 303/411/303 369/413/369 479/509/479
f 329/510/329 385/511/385 480/512/480
f 380/513/380 480/512/480 386/514/386
f 480/512/480 370/489/370 322/398/322
f 321/516/321 370/489/370 480/512/480
f 332/443/332 388/497/388 481/517/481
f 397/436/397 481/517/481 389/518/389
f 481/517/481 394/478/394 299/479/299
f 388/497/388 315/498/315 394/478/394
f 347/519/347 425/522/425 482/520/482
f 427/407/427 482/520/482 358/521/358
f 482/520/482 355/373/355 306/328/306
f 425/522/425 326/378/326 355/373/355
f 317/476/317 368/524/368 483/523/483
f 483/523/483 389/518/389 299/479/299
f 483/523/483 404/352/404 330/355/330
f 368/524/368 329/353/329 404/352/404
f 328/515/328 386/514/386 484/525/484
f 379/526/379 484/525/484 411/504/411
f 484/525/484 406/400/406 335/527/335
f 386/514/386 322/398/322 406/400/406
f 327/454/327 378/453/378 485/528/485
f 417/529/417 485/528/485 423/419/423
f 485/528/485 412/499/412 344/426/344
f 301/456/301 412/499/412 485/528/485
f 311/322/311 374/531/374 486/530/486
f 432/329/432 486/530/486 358/521/358
f 486/530/486 444/532/444 346/405/346
f 374/531/374 336/394/336 444/532/444
f 343/483/343 384/534/384 487/533/487
f 487/533/487 364/362/364 338/334/338
f 487/533/487 400/403/400 339/363/339
f 384/534/384 342/401/342 400/403/400
f 376/485/376 488/535/488 395/472/395
f 488/535/488 396/385/396 300/490/300
f 413/460/413 341/383/341 396/385/396
f 337/389/337 413/460/413 488/535/488
f 422/425/422 489/537/489 377/536/377
f 489/537/489 428/365/428 347/367/347
f 426/392/426 348/372/348 428/365/428
f 345/445/345 426/392/426 489/537/489
f 311/322/311 351/339/351 490/538/490
f 374/531/374 490/538/490 415/399/415
f 490/538/490 371/505/371 335/527/335
f 351/339/351 304/340/304 371/505/371
f 379/539/379 491/540/491 403/356/403
f 491/540/491 410/462/410 331/435/331
f 416/380/416 341/383/341 410/462/410
f 340/381/340 416/380/416 491/540/491
f 336/394/336 407/396/407 492/541/492
f 444/532/444 492/541/492 424/404/424
f 492/541/492 439/361/439 339/363/339
f 407/396/407 324/359/324 439/361/439
f 493/542/493 502/546/502 513/543/513
f 494/545/494 503/578/503 513/543/513
f 513/543/513 503/578/503 496/547/496
f 513/543/513 504/548/504 495/549/495
f 504/548/504 514/552/514 505/550/505
f 504/548/504 496/547/496 506/551/506
f 506/551/506 500/557/500 507/553/507
f 505/550/505 514/552/514 507/553/507
f 499/554/499 507/553/507 515/555/515
f 500/557/500 509/573/509 515/555/515
f 515/555/515 509/573/509 498/558/498
f 515/555/515 510/559/510 497/560/497
f 510/559/510 516/563/516 511/561/511
f 510/559/510 498/558/498 512/562/512
f 512/562/512 494/655/494 502/564/502
f 511/561/511 516/563/516 502/564/502
f 495/566/495 505/569/505 517/567/517
f 499/554/499 508/556/508 517/567/517
f 517/567/517 508/556/508 497/560/497
f 517/567/517 511/570/511 493/571/493
f 500/557/500 506/575/506 518/572/518
f 496/574/496 503/579/503 518/572/518
f 518/572/518 503/579/503 494/576/494
f 518/572/518 512/577/512 498/558/498
f 519/542/519 527/544/527 539/543/539
f 539/543/539 529/578/529 520/545/520
f 539/543/539 530/548/530 522/547/522
f 521/549/521 530/548/530 539/543/539
f 531/550/531 540/552/540 530/548/530
f 530/548/530 540/552/540 532/551/532
f 533/553/533 526/557/526 532/551/532
f 531/550/531 525/554/525 533/553/533
f 525/554/525 534/556/534 541/555/541
f 541/555/541 535/573/535 526/557/526
f 541/555/541 536/559/536 524/558/524
f 523/560/523 536/559/536 541/555/541
f 537/561/537 542/563/542 536/559/536
f 536/559/536 542/563/542 538/562/538
f 528/564/528 520/655/520 538/562/538
f 537/561/537 519/565/519 528/564/528
f 521/566/521 527/568/527 543/567/517
f 543/567/517 534/556/534 525/554/525
f 543/567/517 537/570/537 523/560/523
f 519/571/519 537/570/537 543/567/517
f 526/557/526 535/573/535 544/572/543
f 544/572/543 529/579/529 522/574/522
f 544/572/543 538/577/538 520/576/520
f 524/558/524 538/577/538 544/572/543
f 545/580/544 553/587/552 565/581/564
f 565/581/564 555/585/554 546/583/545
f 565/581/564 556/589/555 548/584/547
f 547/586/546 556/589/555 565/581/564
f 557/588/556 566/590/565 556/589/555
f 566/590/565 558/592/557 548/584/547
f 566/590/565 559/593/558 552/591/551
f 557/588/556 551/594/550 559/593/558
f 551/594/550 560/599/559 567/595/566
f 567/595/566 561/597/560 552/591/551
f 567/595/566 562/601/561 550/596/549
f 549/598/548 562/601/561 567/595/566
f 563/600/562 568/604/567 562/601/561
f 562/601/561 568/604/567 564/602/563
f 554/603/553 546/656/545 564/602/563
f 563/600/562 545/657/544 554/603/553
f 547/605/546 553/609/552 569/606/568
f 569/606/568 560/599/559 551/594/550
f 569/606/568 563/658/562 549/598/548
f 545/608/544 563/658/562 569/606/568
f 552/591/551 561/597/560 570/610/569
f 570/610/569 555/614/554 548/612/547
f 570/610/569 564/659/563 546/613/545
f 550/596/549 564/659/563 570/610/569
f 571/615/570 580/619/579 591/616/590
f 572/618/571 581/660/580 591/616/590
f 591/616/590 581/660/580 574/620/573
f 591/616/590 582/621/581 573/622/572
f 582/621/581 592/624/591 583/623/582
f 574/620/573 584/661/583 592/624/591
f 592/624/591 584/661/583 578/625/577
f 583/623/582 592/624/591 585/626/584
f 577/627/576 585/626/584 593/628/592
f 578/625/577 587/645/586 593/628/592
f 593/628/592 587/645/586 576/630/575
f 593/628/592 588/631/587 575/632/574
f 588/631/587 594/635/593 589/633/588
f 588/631/587 576/630/575 590/634/589
f 590/634/589 572/662/571 580/636/579
f 589/633/588 594/635/593 580/636/579
f 573/638/572 583/641/582 595/639/568
f 577/627/576 586/629/585 595/639/568
f 595/639/568 586/629/585 575/632/574
f 595/639/568 589/642/588 571/643/570
f 578/625/577 584/647/583 596/644/594
f 574/646/573 581/663/580 596/644/594
f 596/644/594 581/663/580 572/648/571
f 596/644/594 590/649/589 576/630/575

```

`assets/tsodinCupLowPoly.obj`:

```obj
v 0.000000 -0.000156 -1.066203
v -0.626698 -0.000156 -0.862576
v -1.014019 -0.000156 -0.329475
v -1.014019 -0.000156 0.329475
v -0.626698 -0.000156 0.862576
v 0.000000 -0.000156 1.066203
v 0.626698 -0.000156 0.862576
v 1.014019 -0.000156 0.329475
v 1.014019 -0.000156 -0.329475
v 0.626698 -0.000156 -0.862576
v 0.000000 -0.542991 -0.955058
v -0.561369 -0.542991 -0.772658
v -0.908314 -0.542991 -0.295129
v -0.908314 -0.542991 0.295129
v -0.561369 -0.542991 0.772658
v 0.000000 -0.542991 0.955058
v 0.561369 -0.542991 0.772658
v 0.908314 -0.542991 0.295129
v 0.908314 -0.542991 -0.295129
v 0.561369 -0.542991 -0.772658
v 0.000000 -1.034103 -0.766091
v -0.450297 -1.034103 -0.619781
v -0.728596 -1.034103 -0.236735
v -0.728596 -1.034103 0.236735
v -0.450297 -1.034103 0.619781
v 0.000000 -1.034103 0.766091
v 0.450297 -1.034103 0.619781
v 0.728596 -1.034103 0.236735
v 0.728596 -1.034103 -0.236735
v 0.450297 -1.034103 -0.619781
v -0.000000 -1.422396 -0.497612
v -0.292489 -1.422396 -0.402576
v -0.473257 -1.422396 -0.153770
v -0.473257 -1.422396 0.153770
v -0.292489 -1.422396 0.402576
v 0.000000 -1.422396 0.497612
v 0.292489 -1.422396 0.402576
v 0.473257 -1.422396 0.153771
v 0.473257 -1.422396 -0.153771
v 0.292489 -1.422396 -0.402576
v -0.000000 -1.514935 -0.497612
v -0.292489 -1.514935 -0.402576
v -0.473257 -1.514935 -0.153770
v -0.473257 -1.514935 0.153770
v -0.292489 -1.514935 0.402576
v 0.000000 -1.514935 0.497612
v 0.292489 -1.514935 0.402576
v 0.473257 -1.514935 0.153771
v 0.473257 -1.514935 -0.153771
v 0.292489 -1.514935 -0.402576
v 0.000000 0.010858 -0.987583
v -0.580486 0.010858 -0.798971
v -0.939247 0.010858 -0.305180
v -0.939247 0.010858 0.305180
v -0.580486 0.010858 0.798971
v 0.000000 0.010858 0.987583
v 0.580487 0.010858 0.798971
v 0.939247 0.010858 0.305180
v 0.939247 0.010858 -0.305180
v 0.580487 0.010858 -0.798971
v 0.000000 -0.521118 -0.875554
v -0.514638 -0.521118 -0.708338
v -0.832702 -0.521118 -0.270561
v -0.832702 -0.521118 0.270561
v -0.514638 -0.521118 0.708338
v 0.000000 -0.521118 0.875554
v 0.514638 -0.521118 0.708338
v 0.832701 -0.521118 0.270561
v 0.832701 -0.521118 -0.270561
v 0.514638 -0.521118 -0.708338
v 0.000000 -0.993567 -0.691708
v -0.406576 -0.993567 -0.559603
v -0.657853 -0.993567 -0.213749
v -0.657853 -0.993567 0.213749
v -0.406576 -0.993567 0.559603
v 0.000000 -0.993567 0.691708
v 0.406576 -0.993567 0.559603
v 0.657853 -0.993567 0.213749
v 0.657853 -0.993567 -0.213750
v 0.406576 -0.993567 -0.559603
v 0.000000 -1.367126 -0.422987
v -0.248625 -1.367126 -0.342204
v -0.402285 -1.367126 -0.130710
v -0.402285 -1.367126 0.130710
v -0.248625 -1.367126 0.342204
v 0.000000 -1.367126 0.422987
v 0.248626 -1.367126 0.342204
v 0.402285 -1.367126 0.130710
v 0.402285 -1.367126 -0.130710
v 0.248626 -1.367126 -0.342204
v -0.893877 -0.278278 0.402886
v -0.659723 -0.278431 0.724741
v -0.870406 -0.405366 0.393083
v -0.643093 -0.405514 0.705535
v -1.043524 -0.292722 0.541859
v -0.838261 -0.292879 0.824072
v -1.024132 -0.402048 0.527565
v -0.818596 -0.402206 0.810154
v -1.142123 -0.391251 0.633202
v -0.955602 -0.391372 0.889584
v -1.064234 -0.441499 0.576417
v -0.877453 -0.441621 0.833156
v -1.130418 -0.567091 0.651982
v -0.969656 -0.567208 0.872953
v -1.050666 -0.531856 0.594071
v -0.889901 -0.531973 0.815046
v -0.921231 -0.971574 0.540621
v -0.798838 -0.971662 0.708883
v -0.879760 -0.912354 0.510614
v -0.757484 -0.912441 0.678716
v -0.695367 -1.185602 0.388707
v -0.584510 -1.185674 0.541085
v -0.698309 -1.121105 0.391044
v -0.587667 -1.121177 0.543127
v -0.617364 -1.109944 0.305061
v -0.480793 -1.110033 0.492785
v -0.583260 -1.173834 0.280524
v -0.446870 -1.173923 0.467997

f 27 18 17
f 10 11 1
f 17 8 7
f 14 5 4
f 1 12 2
f 8 19 9
f 15 6 5
f 2 13 3
f 19 10 9
f 16 7 6
f 13 4 3
f 24 35 25
f 24 15 14
f 21 12 11
f 18 29 19
f 25 16 15
f 22 13 12
f 29 20 19
f 26 17 16
f 23 14 13
f 30 11 20
f 34 45 35
f 21 32 22
f 28 39 29
f 35 26 25
f 22 33 23
f 29 40 30
f 36 27 26
f 33 24 23
f 40 21 30
f 37 28 27
f 46 44 42
f 41 32 31
f 48 39 38
f 35 46 36
f 42 33 32
f 49 40 39
f 46 37 36
f 43 34 33
f 50 31 40
f 47 38 37
f 101 95 97
f 91 96 92
f 97 91 93
f 98 93 94
f 92 98 94
f 104 102 100
f 102 97 98
f 96 102 98
f 95 100 96
f 104 110 106
f 103 100 99
f 101 103 99
f 102 105 101
f 111 108 107
f 107 104 103
f 109 103 105
f 106 109 105
f 115 111 113
f 113 107 109
f 110 113 109
f 108 114 110
f 117 112 111
f 116 112 118
f 115 114 116
f 27 28 18
f 10 20 11
f 17 18 8
f 14 15 5
f 1 11 12
f 8 18 19
f 15 16 6
f 2 12 13
f 19 20 10
f 16 17 7
f 13 14 4
f 24 34 35
f 24 25 15
f 21 22 12
f 18 28 29
f 25 26 16
f 22 23 13
f 29 30 20
f 26 27 17
f 23 24 14
f 30 21 11
f 34 44 45
f 21 31 32
f 28 38 39
f 35 36 26
f 22 32 33
f 29 39 40
f 36 37 27
f 33 34 24
f 40 31 21
f 37 38 28
f 42 41 50
f 50 49 42
f 49 48 42
f 48 47 46
f 46 45 44
f 44 43 42
f 48 46 42
f 41 42 32
f 48 49 39
f 35 45 46
f 42 43 33
f 49 50 40
f 46 47 37
f 43 44 34
f 50 41 31
f 47 48 38
f 101 99 95
f 91 95 96
f 97 95 91
f 98 97 93
f 92 96 98
f 104 106 102
f 102 101 97
f 96 100 102
f 95 99 100
f 104 108 110
f 103 104 100
f 101 105 103
f 102 106 105
f 111 112 108
f 107 108 104
f 109 107 103
f 106 110 109
f 115 117 111
f 113 111 107
f 110 114 113
f 108 112 114
f 117 118 112
f 116 114 112
f 115 113 114
f 69 58 59
f 79 68 69
f 66 55 56
f 63 52 53
f 70 59 60
f 57 66 56
f 64 53 54
f 61 60 51
f 68 57 58
f 65 54 55
f 52 61 51
f 76 85 75
f 66 75 65
f 73 62 63
f 80 69 70
f 67 76 66
f 64 73 63
f 61 80 70
f 68 77 67
f 75 64 65
f 72 61 62
f 84 88 90
f 83 72 73
f 90 79 80
f 77 86 76
f 74 83 73
f 81 80 71
f 78 87 77
f 85 74 75
f 82 71 72
f 89 78 79
f 69 68 58
f 79 78 68
f 66 65 55
f 63 62 52
f 70 69 59
f 57 67 66
f 64 63 53
f 61 70 60
f 68 67 57
f 65 64 54
f 52 62 61
f 76 86 85
f 66 76 75
f 73 72 62
f 80 79 69
f 67 77 76
f 64 74 73
f 61 71 80
f 68 78 77
f 75 74 64
f 72 71 61
f 90 81 82
f 82 83 84
f 84 85 86
f 86 87 88
f 88 89 90
f 90 82 84
f 84 86 88
f 83 82 72
f 90 89 79
f 77 87 86
f 74 84 83
f 81 90 80
f 78 88 87
f 85 84 74
f 82 81 71
f 89 88 78
f 4 53 3
f 1 60 10
f 58 7 8
f 5 54 4
f 52 1 2
f 59 8 9
f 56 5 6
f 53 2 3
f 10 59 9
f 57 6 7
f 4 54 53
f 1 51 60
f 58 57 7
f 5 55 54
f 52 51 1
f 59 58 8
f 56 55 5
f 53 52 2
f 10 60 59
f 57 56 6

```

`assets/utahTeapot.obj`:

```obj
# Source: https://graphics.stanford.edu/courses/cs148-10-summer/as3/code/as3/teapot.obj
v -3.000000 1.800000 0.000000
v -2.991600 1.800000 -0.081000
v -2.991600 1.800000 0.081000
v -2.989450 1.666162 0.000000
v -2.985000 1.921950 0.000000
v -2.985000 1.921950 0.000000
v -2.981175 1.667844 -0.081000
v -2.981175 1.667844 0.081000
v -2.976687 1.920243 -0.081000
v -2.976687 1.920243 0.081000
v -2.968800 1.800000 -0.144000
v -2.968800 1.800000 0.144000
v -2.958713 1.672406 -0.144000
v -2.958713 1.672406 0.144000
v -2.957600 1.534800 0.000000
v -2.957600 1.534800 0.000000
v -2.954122 1.915609 -0.144000
v -2.954122 1.915609 0.144000
v -2.949693 1.537790 -0.081000
v -2.949693 1.537790 0.081000
v -2.940000 2.019600 0.000000
v -2.935200 1.800000 -0.189000
v -2.935200 1.800000 0.189000
v -2.931958 2.016526 0.081000
v -2.931958 2.016526 -0.081000
v -2.928230 1.545907 -0.144000
v -2.928230 1.545907 0.144000
v -2.925611 1.679131 -0.189000
v -2.925611 1.679131 0.189000
v -2.920870 1.908779 -0.189000
v -2.920870 1.908779 0.189000
v -2.910131 2.008181 -0.144000
v -2.910131 2.008181 0.144000
v -2.904150 1.406137 0.000000
v -2.904150 1.406137 0.000000
v -2.896846 1.410135 0.081000
v -2.896846 1.410135 -0.081000
v -2.896602 1.557869 -0.189000
v -2.896602 1.557869 0.189000
v -2.894400 1.800000 -0.216000
v -2.894400 1.800000 0.216000
v -2.885416 1.687296 -0.216000
v -2.885416 1.687296 0.216000
v -2.880491 1.900487 -0.216000
v -2.880491 1.900487 0.216000
v -2.877965 1.995883 -0.189000
v -2.877965 1.995883 0.189000
v -2.877022 1.420985 -0.144000
v -2.877022 1.420985 0.144000
v -2.865000 2.095650 0.000000
v -2.858195 1.572394 0.216000
v -2.858195 1.572394 -0.216000
v -2.857432 2.091511 -0.081000
v -2.857432 2.091511 0.081000
v -2.850000 1.800000 -0.225000
v -2.850000 1.800000 0.225000
v -2.847806 1.436974 0.189000
v -2.847806 1.436974 -0.189000
v -2.841675 1.696181 0.225000
v -2.841675 1.696181 -0.225000
v -2.838906 1.980950 -0.216000
v -2.838906 1.980950 0.216000
v -2.836889 2.080276 -0.144000
v -2.836889 2.080276 0.144000
v -2.836550 1.891463 -0.225000
v -2.836550 1.891463 0.225000
v -2.828800 1.280400 0.000000
v -2.822326 1.285171 -0.081000
v -2.822326 1.285171 0.081000
v -2.816400 1.588200 -0.225000
v -2.816400 1.588200 0.225000
v -2.812331 1.456390 0.216000
v -2.812331 1.456390 -0.216000
v -2.806615 2.063720 -0.189000
v -2.806615 2.063720 0.189000
v -2.805600 1.800000 -0.216000
v -2.805600 1.800000 0.216000
v -2.804755 1.298122 -0.144000
v -2.804755 1.298122 0.144000
v -2.797934 1.705067 -0.216000
v -2.797934 1.705067 0.216000
v -2.796400 1.964700 0.225000
v -2.796400 1.964700 -0.225000
v -2.792609 1.882438 -0.216000
v -2.792609 1.882438 0.216000
v -2.778861 1.317206 -0.189000
v -2.778861 1.317206 0.189000
v -2.774605 1.604006 0.216000
v -2.774605 1.604006 -0.216000
v -2.773725 1.477519 0.225000
v -2.773725 1.477519 -0.225000
v -2.769854 2.043616 -0.216000
v -2.769854 2.043616 0.216000
v -2.764800 1.800000 -0.189000
v -2.764800 1.800000 0.189000
v -2.760000 2.152800 0.000000
v -2.760000 2.152800 0.000000
v -2.757739 1.713232 -0.189000
v -2.757739 1.713232 0.189000
v -2.753894 1.948450 -0.216000
v -2.753894 1.948450 0.216000
v -2.753123 2.147861 -0.081000
v -2.753123 2.147861 0.081000
v -2.752230 1.874146 -0.189000
v -2.752230 1.874146 0.189000
v -2.747418 1.340381 -0.216000
v -2.747418 1.340381 0.216000
v -2.736198 1.618531 -0.189000
v -2.736198 1.618531 0.189000
v -2.735119 1.498648 0.216000
v -2.735119 1.498648 -0.216000
v -2.734458 2.134454 -0.144000
v -2.734458 2.134454 0.144000
v -2.731250 1.157813 0.000000
v -2.731250 1.157813 0.000000
v -2.731200 1.800000 -0.144000
v -2.731200 1.800000 0.144000
v -2.729850 2.021737 -0.225000
v -2.729850 2.021737 0.225000
v -2.725825 1.163194 0.081000
v -2.725825 1.163194 -0.081000
v -2.724637 1.719956 -0.144000
v -2.724637 1.719956 0.144000
v -2.718978 1.867316 -0.144000
v -2.718978 1.867316 0.144000
v -2.714835 1.933517 -0.189000
v -2.714835 1.933517 0.189000
v -2.713200 1.365600 -0.225000
v -2.713200 1.365600 0.225000
v -2.711100 1.177800 -0.144000
v -2.711100 1.177800 0.144000
v -2.708400 1.800000 -0.081000
v -2.708400 1.800000 0.081000
v -2.706950 2.114698 -0.189000
v -2.706950 2.114698 0.189000
v -2.704570 1.630493 -0.144000
v -2.704570 1.630493 0.144000
v -2.702175 1.724519 -0.081000
v -2.702175 1.724519 0.081000
v -2.700000 1.800000 0.000000
v -2.699644 1.518063 0.189000
v -2.699644 1.518063 -0.189000
v -2.696413 1.862682 -0.081000
v -2.696413 1.862682 0.081000
v -2.693900 1.726200 0.000000
v -2.689846 1.999859 -0.216000
v -2.689846 1.999859 0.216000
v -2.689400 1.199325 -0.189000
v -2.689400 1.199325 0.189000
v -2.688100 1.860975 0.000000
v -2.688100 1.860975 0.000000
v -2.683107 1.638610 -0.081000
v -2.683107 1.638610 0.081000
v -2.682669 1.921219 -0.144000
v -2.682669 1.921219 0.144000
v -2.678982 1.390819 -0.216000
v -2.678982 1.390819 0.216000
v -2.675200 1.641600 0.000000
v -2.675200 1.641600 0.000000
v -2.673549 2.090707 -0.216000
v -2.673549 2.090707 0.216000
v -2.670428 1.534053 -0.144000
v -2.670428 1.534053 0.144000
v -2.663050 1.225463 -0.216000
v -2.663050 1.225463 0.216000
v -2.660842 1.912874 0.081000
v -2.660842 1.912874 -0.081000
v -2.653085 1.979755 -0.189000
v -2.653085 1.979755 0.189000
v -2.652800 1.909800 0.000000
v -2.652800 1.909800 0.000000
v -2.650604 1.544903 0.081000
v -2.650604 1.544903 -0.081000
v -2.647539 1.413994 -0.189000
v -2.647539 1.413994 0.189000
v -2.643300 1.548900 0.000000
v -2.637200 2.064600 -0.225000
v -2.637200 2.064600 0.225000
v -2.634375 1.253906 0.225000
v -2.634375 1.253906 -0.225000
v -2.625000 2.193750 0.000000
v -2.622811 1.963199 -0.144000
v -2.622811 1.963199 0.144000
v -2.621645 1.433078 -0.144000
v -2.621645 1.433078 0.144000
v -2.619050 2.188238 -0.081000
v -2.619050 2.188238 0.081000
v -2.611200 1.038600 0.000000
v -2.611200 1.038600 0.000000
v -2.607034 1.044497 0.081000
v -2.607034 1.044497 -0.081000
v -2.605700 1.282350 -0.216000
v -2.605700 1.282350 0.216000
v -2.604074 1.446029 -0.081000
v -2.604074 1.446029 0.081000
v -2.602900 2.173275 -0.144000
v -2.602900 2.173275 0.144000
v -2.602268 1.951964 -0.081000
v -2.602268 1.951964 0.081000
v -2.600851 2.038493 -0.216000
v -2.600851 2.038493 0.216000
v -2.597600 1.450800 0.000000
v -2.595725 1.060502 -0.144000
v -2.595725 1.060502 0.144000
v -2.594700 1.947825 0.000000
v -2.579350 1.308488 -0.189000
v -2.579350 1.308488 0.189000
v -2.579100 2.151225 -0.189000
v -2.579100 2.151225 0.189000
v -2.579059 1.084090 -0.189000
v -2.579059 1.084090 0.189000
v -2.567450 2.014502 -0.189000
v -2.567450 2.014502 0.189000
v -2.558822 1.112731 0.216000
v -2.558822 1.112731 -0.216000
v -2.557650 1.330013 -0.144000
v -2.557650 1.330013 0.144000
v -2.550200 2.124450 -0.216000
v -2.550200 2.124450 0.216000
v -2.542925 1.344619 0.081000
v -2.542925 1.344619 -0.081000
v -2.539942 1.994746 -0.144000
v -2.539942 1.994746 0.144000
v -2.537500 1.350000 0.000000
v -2.537500 1.350000 0.000000
v -2.536800 1.143900 0.225000
v -2.536800 1.143900 -0.225000
v -2.521277 1.981339 -0.081000
v -2.521277 1.981339 0.081000
v -2.518750 2.095312 -0.225000
v -2.518750 2.095312 0.225000
v -2.514778 1.175069 0.216000
v -2.514778 1.175069 -0.216000
v -2.514400 1.976400 0.000000
v -2.514400 1.976400 0.000000
v -2.494541 1.203710 -0.189000
v -2.494541 1.203710 0.189000
v -2.487300 2.066175 -0.216000
v -2.487300 2.066175 0.216000
v -2.477875 1.227298 -0.144000
v -2.477875 1.227298 0.144000
v -2.468350 0.922987 0.000000
v -2.466566 1.243303 0.081000
v -2.466566 1.243303 -0.081000
v -2.465644 0.929375 -0.081000
v -2.465644 0.929375 0.081000
v -2.462400 1.249200 0.000000
v -2.462400 1.249200 0.000000
v -2.460000 2.221200 0.000000
v -2.460000 2.221200 0.000000
v -2.458400 2.039400 -0.189000
v -2.458400 2.039400 0.189000
v -2.458298 0.946711 -0.144000
v -2.458298 0.946711 0.144000
v -2.455229 2.215303 -0.081000
v -2.455229 2.215303 0.081000
v -2.447474 0.972260 0.189000
v -2.447474 0.972260 -0.189000
v -2.442278 2.199298 -0.144000
v -2.442278 2.199298 0.144000
v -2.434600 2.017350 -0.144000
v -2.434600 2.017350 0.144000
v -2.434329 1.003283 -0.216000
v -2.434329 1.003283 0.216000
v -2.423194 2.175710 -0.189000
v -2.423194 2.175710 0.189000
v -2.420025 1.037044 -0.225000
v -2.420025 1.037044 0.225000
v -2.418450 2.002387 -0.081000
v -2.418450 2.002388 0.081000
v -2.412500 1.996875 0.000000
v -2.412500 1.996875 0.000000
v -2.405721 1.070804 -0.216000
v -2.405721 1.070804 0.216000
v -2.400019 2.147069 -0.216000
v -2.400019 2.147069 0.216000
v -2.392576 1.101828 -0.189000
v -2.392576 1.101828 0.189000
v -2.381752 1.127376 -0.144000
v -2.381752 1.127376 0.144000
v -2.374800 2.115900 -0.225000
v -2.374800 2.115900 0.225000
v -2.374406 1.144713 0.081000
v -2.374406 1.144713 -0.081000
v -2.371700 1.151100 0.000000
v -2.349581 2.084731 -0.216000
v -2.349581 2.084731 0.216000
v -2.326406 2.056090 -0.189000
v -2.326406 2.056090 0.189000
v -2.307322 2.032502 -0.144000
v -2.307322 2.032502 0.144000
v -2.302400 0.811200 0.000000
v -2.302400 0.811200 0.000000
v -2.301347 0.818122 0.081000
v -2.301347 0.818122 -0.081000
v -2.298490 0.836909 0.144000
v -2.298490 0.836909 -0.144000
v -2.294371 2.016497 -0.081000
v -2.294371 2.016497 0.081000
v -2.294278 0.864595 0.189000
v -2.294278 0.864595 -0.189000
v -2.289600 2.010600 0.000000
v -2.289600 2.010600 0.000000
v -2.289165 0.898214 0.216000
v -2.289165 0.898214 -0.216000
v -2.283600 0.934800 0.225000
v -2.283600 0.934800 -0.225000
v -2.278035 0.971386 0.216000
v -2.278035 0.971386 -0.216000
v -2.272922 1.005005 0.189000
v -2.272922 1.005005 -0.189000
v -2.268710 1.032691 -0.144000
v -2.268710 1.032691 0.144000
v -2.265853 1.051478 0.081000
v -2.265853 1.051478 -0.081000
v -2.265000 2.237850 0.000000
v -2.264800 1.058400 0.000000
v -2.264800 1.058400 0.000000
v -2.261676 2.231720 -0.081000
v -2.261676 2.231720 0.081000
v -2.252655 2.215082 -0.144000
v -2.252655 2.215082 0.144000
v -2.239361 2.190562 -0.189000
v -2.239361 2.190562 0.189000
v -2.223218 2.160788 -0.216000
v -2.223218 2.160788 0.216000
v -2.205650 2.128387 0.225000
v -2.205650 2.128388 -0.225000
v -2.188082 2.095987 -0.216000
v -2.188082 2.095987 0.216000
v -2.171939 2.066213 -0.189000
v -2.171939 2.066213 0.189000
v -2.158645 2.041693 -0.144000
v -2.158645 2.041693 0.144000
v -2.149624 2.025055 -0.081000
v -2.149624 2.025055 0.081000
v -2.146300 2.018925 0.000000
v -2.141100 0.973800 0.000000
v -2.141100 0.973800 0.000000
v -2.140315 0.966231 0.081000
v -2.140315 0.966231 -0.081000
v -2.138183 0.945685 0.144000
v -2.138183 0.945685 -0.144000
v -2.135041 0.915407 0.189000
v -2.135041 0.915407 -0.189000
v -2.131226 0.878641 0.216000
v -2.131226 0.878641 -0.216000
v -2.127075 0.838631 0.225000
v -2.127075 0.838631 -0.225000
v -2.122924 0.798621 0.216000
v -2.122924 0.798621 -0.216000
v -2.119109 0.761855 0.189000
v -2.119109 0.761855 -0.189000
v -2.115967 0.731578 0.144000
v -2.115967 0.731578 -0.144000
v -2.113835 0.711032 0.081000
v -2.113835 0.711032 -0.081000
v -2.113050 0.703463 0.000000
v -2.113050 0.703463 0.000000
v -2.040000 2.246400 0.000000
v -2.040000 2.246400 0.000000
v -2.038410 2.240150 -0.081000
v -2.038410 2.240150 0.081000
v -2.034093 2.223187 -0.144000
v -2.034093 2.223187 0.144000
v -2.027731 2.198189 -0.189000
v -2.027731 2.198189 0.189000
v -2.020006 2.167834 0.216000
v -2.020006 2.167834 -0.216000
v -2.011600 2.134800 0.225000
v -2.011600 2.134800 -0.225000
v -2.003194 2.101766 0.216000
v -2.003194 2.101766 -0.216000
v -2.000000 0.900000 0.000000
v -2.000000 0.900000 0.000000
v -2.000000 0.900000 0.000000
v -1.997200 0.891600 0.081000
v -1.997200 0.891600 -0.081000
v -1.995469 2.071411 -0.189000
v -1.995469 2.071411 0.189000
v -1.992750 1.037175 -0.000000
v -1.992750 1.037175 0.000000
v -1.989600 0.868800 0.144000
v -1.989600 0.868800 -0.144000
v -1.989107 2.046413 0.144000
v -1.989107 2.046413 -0.144000
v -1.986000 0.771675 0.000000
v -1.986000 0.771675 0.000000
v -1.984790 2.029450 -0.081000
v -1.984790 2.029450 0.081000
v -1.983200 2.023200 0.000000
v -1.983200 2.023200 0.000000
v -1.978400 0.835200 0.189000
v -1.978400 0.835200 -0.189000
v -1.974240 0.900000 -0.328160
v -1.974240 0.900000 -0.328160
v -1.974240 0.900000 0.328160
v -1.972000 1.178400 -0.000000
v -1.972000 1.178400 0.000000
v -1.967083 1.037175 -0.326970
v -1.967083 1.037175 0.326970
v -1.964800 0.794400 0.216000
v -1.964800 0.794400 -0.216000
v -1.960420 0.771675 -0.325863
v -1.960420 0.771675 0.325863
v -1.950000 0.750000 -0.225000
v -1.950000 0.750000 0.225000
v -1.948000 0.656400 0.000000
v -1.948000 0.656400 0.000000
v -1.946601 1.178400 -0.323566
v -1.946601 1.178400 0.323566
v -1.939250 1.323225 0.000000
v -1.939250 1.323225 0.000000
v -1.935200 0.705600 0.216000
v -1.935200 0.705600 -0.216000
v -1.922910 0.656400 -0.319628
v -1.922910 0.656400 0.319628
v -1.921600 0.664800 0.189000
v -1.921600 0.664800 -0.189000
v -1.914272 1.323225 -0.318192
v -1.914272 1.323225 0.318192
v -1.910400 0.631200 0.144000
v -1.910400 0.631200 -0.144000
v -1.902800 0.608400 0.081000
v -1.902800 0.608400 -0.081000
v -1.900000 0.600000 0.000000
v -1.900000 0.600000 0.000000
v -1.899520 0.900000 -0.638080
v -1.899520 0.900000 -0.638080
v -1.899520 0.900000 0.638080
v -1.899520 0.900000 0.638080
v -1.896000 1.471200 0.000000
v -1.896000 1.471200 0.000000
v -1.892634 1.037175 -0.635767
v -1.892634 1.037175 0.635767
v -1.892000 0.553725 0.000000
v -1.892000 0.553725 0.000000
v -1.886223 0.771675 -0.633613
v -1.886223 0.771675 0.633613
v -1.872927 1.178400 -0.629147
v -1.872927 1.178400 0.629147
v -1.871580 1.471200 -0.311096
v -1.871580 1.471200 0.311096
v -1.867631 0.553725 -0.310439
v -1.867631 0.553725 0.310439
v -1.850132 0.656400 -0.621490
v -1.850132 0.656400 0.621490
v -1.843750 1.621875 0.000000
v -1.843750 1.621875 0.000000
v -1.841822 1.323225 -0.618698
v -1.841822 1.323225 0.618698
v -1.824000 0.463200 -0.000000
v -1.824000 0.463200 0.000000
v -1.820003 1.621875 -0.302522
v -1.820003 1.621875 0.302523
v -1.800900 2.024775 0.000000
v -1.800745 1.471200 -0.604900
v -1.800745 1.471200 0.604900
v -1.800507 0.463200 -0.299282
v -1.800507 0.463200 0.299282
v -1.800455 2.031069 -0.081000
v -1.800455 2.031069 0.081000
v -1.799246 2.048152 -0.144000
v -1.799246 2.048152 0.144000
v -1.797466 2.073326 -0.189000
v -1.797466 2.073326 0.189000
v -1.796946 0.553725 -0.603624
v -1.796946 0.553725 0.603624
v -1.795303 2.103896 -0.216000
v -1.795303 2.103896 0.216000
v -1.792950 2.137163 -0.225000
v -1.792950 2.137163 0.225000
v -1.790597 2.170429 -0.216000
v -1.790597 2.170429 0.216000
v -1.788434 2.200999 -0.189000
v -1.788434 2.200999 0.189000
v -1.786654 2.226173 -0.144000
v -1.786654 2.226173 0.144000
v -1.785445 2.243256 -0.081000
v -1.785445 2.243256 0.081000
v -1.785000 2.249550 0.000000
v -1.784000 1.774800 -0.000000
v -1.784000 1.774800 0.000000
v -1.779680 0.900000 -0.925920
v -1.779680 0.900000 -0.925920
v -1.779680 0.900000 0.925920
v -1.779680 0.900000 0.925920
v -1.773229 1.037175 -0.922564
v -1.773229 1.037175 0.922564
v -1.767222 0.771675 -0.919439
v -1.767222 0.771675 0.919439
v -1.761022 1.774800 -0.292719
v -1.761022 1.774800 0.292719
v -1.754764 1.178400 -0.912957
v -1.754764 1.178400 0.912957
v -1.751120 1.621875 -0.588230
v -1.751120 1.621875 0.588230
v -1.750000 0.384375 -0.000000
v -1.750000 0.384375 0.000000
v -1.733408 0.656400 -0.901846
v -1.733408 0.656400 0.901846
v -1.732362 0.463200 -0.581929
v -1.732362 0.463200 0.581929
v -1.727460 0.384375 -0.287140
v -1.727460 0.384375 0.287140
v -1.725622 1.323225 -0.897795
v -1.725622 1.323225 0.897795
v -1.718250 1.929525 -0.000000
v -1.718250 1.929525 0.000000
v -1.696119 1.929525 -0.281930
v -1.696119 1.929525 0.281930
v -1.694372 1.774800 -0.569167
v -1.694372 1.774800 0.569167
v -1.687137 1.471200 -0.877772
v -1.687137 1.471200 0.877772
v -1.683577 0.553725 -0.875920
v -1.683577 0.553725 0.875920
v -1.676000 0.316800 0.000000
v -1.676000 0.316800 0.000000
v -1.662080 0.384375 -0.558320
v -1.662080 0.384375 0.558320
v -1.654413 0.316800 -0.274998
v -1.654413 0.316800 0.274998
v -1.648000 2.085600 0.000000
v -1.648000 2.085600 0.000000
v -1.640643 1.621875 -0.853583
v -1.640643 1.621875 0.853583
v -1.631925 1.929525 -0.548190
v -1.631925 1.929525 0.548190
v -1.626774 2.085600 -0.270404
v -1.626774 2.085600 0.270404
v -1.623068 0.463200 -0.844439
v -1.623068 0.463200 0.844439
v -1.618560 0.900000 -1.187840
v -1.618560 0.900000 -1.187840
v -1.618560 0.900000 1.187840
v -1.618560 0.900000 1.187840
v -1.612693 1.037175 -1.183534
v -1.612693 1.037175 1.183534
v -1.608000 0.260025 -0.000000
v -1.608000 0.260025 0.000000
v -1.607230 0.771675 -1.179525
v -1.607230 0.771675 1.179525
v -1.600000 2.025000 0.000000
v -1.597200 2.031300 -0.081000
v -1.597200 2.031300 0.081000
v -1.595900 1.178400 -1.171210
v -1.595900 1.178400 1.171210
v -1.591798 0.316800 -0.534711
v -1.591798 0.316800 0.534711
v -1.589600 2.048400 -0.144000
v -1.589600 2.048400 0.144000
v -1.587475 1.774800 -0.825921
v -1.587475 1.774800 0.825921
v -1.587289 0.260025 0.263841
v -1.587289 0.260025 -0.263841
v -1.578400 2.073600 -0.189000
v -1.578400 2.073600 0.189000
v -1.576477 0.656400 -1.156956
v -1.576477 0.656400 1.156956
v -1.574750 2.242575 0.000000
v -1.574750 2.242575 0.000000
v -1.569396 1.323225 -1.151759
v -1.569396 1.323225 1.151759
v -1.565204 2.085600 -0.525778
v -1.565204 2.085600 0.525778
v -1.564800 2.104200 -0.216000
v -1.564800 2.104200 0.216000
v -1.557220 0.384375 -0.810180
v -1.557220 0.384375 0.810180
v -1.554467 2.242575 -0.258385
v -1.554467 2.242575 0.258385
v -1.552000 0.213600 0.000000
v -1.552000 0.213600 0.000000
v -1.550000 2.137500 -0.225000
v -1.550000 2.137500 0.225000
v -1.535200 2.170800 -0.216000
v -1.535200 2.170800 0.216000
v -1.534395 1.471200 -1.126072
v -1.534395 1.471200 1.126072
v -1.532010 0.213600 0.254652
v -1.532010 0.213600 -0.254652
v -1.531158 0.553725 -1.123697
v -1.531158 0.553725 1.123697
v -1.528968 1.929525 -0.795481
v -1.528968 1.929525 0.795481
v -1.527214 0.260025 -0.513016
v -1.527214 0.260025 0.513016
v -1.521600 2.201400 -0.189000
v -1.521600 2.201400 0.189000
v -1.514000 0.177075 0.000000
v -1.514000 0.177075 0.000000
v -1.510400 2.226600 -0.144000
v -1.510400 2.226600 0.144000
v -1.502800 2.243700 -0.081000
v -1.502800 2.243700 0.081000
v -1.500000 2.400000 0.000000
v -1.500000 0.150000 0.000000
v -1.500000 2.250000 0.000000
v -1.500000 2.400000 0.000000
v -1.500000 0.150000 0.000000
v -1.496475 0.127575 -0.000000
v -1.496475 0.127575 0.000000
v -1.495635 2.242575 -0.502408
v -1.495635 2.242575 0.502408
v -1.494500 0.177075 0.248417
v -1.494500 0.177075 -0.248417
v -1.492110 1.621875 -1.095040
v -1.492110 1.621875 1.095040
v -1.491372 0.316800 -0.775921
v -1.491372 0.316800 0.775921
v -1.480800 0.105600 0.000000
v -1.480800 0.105600 -0.000000
v -1.480680 2.400000 -0.246120
v -1.480680 0.150000 0.246120
v -1.480680 2.400000 0.246120
v -1.480680 0.150000 -0.246120
v -1.480680 0.150000 -0.246120
v -1.480680 0.150000 0.246120
v -1.480325 2.435437 0.000000
v -1.480325 2.435437 0.000000
v -1.477200 0.127575 0.245542
v -1.477200 0.127575 -0.245542
v -1.476127 0.463200 -1.083310
v -1.476127 0.463200 1.083310
v -1.474028 0.213600 0.495150
v -1.474028 0.213600 -0.495150
v -1.466456 2.085600 -0.762958
v -1.466456 2.085600 0.762958
v -1.461727 0.105600 -0.242970
v -1.461727 0.105600 0.242970
v -1.461258 2.435437 -0.242892
v -1.461258 2.435437 0.242892
v -1.459600 2.463000 0.000000
v -1.459600 2.463000 0.000000
v -1.445325 0.084525 0.000000
v -1.445325 0.084525 0.000000
v -1.443756 1.774800 -1.059553
v -1.443756 1.774800 1.059553
v -1.440800 2.463000 -0.239491
v -1.440800 2.463000 0.239491
v -1.439025 2.482687 0.000000
v -1.437937 0.177075 0.483027
v -1.437937 0.177075 -0.483027
v -1.430863 0.260025 0.744440
v -1.430863 0.260025 -0.744440
v -1.426709 0.084525 -0.237149
v -1.426709 0.084525 0.237149
v -1.424640 2.400000 -0.478560
v -1.424640 0.150000 -0.478560
v -1.424640 0.150000 -0.478560
v -1.424640 0.150000 0.478560
v -1.424640 0.150000 0.478560
v -1.424640 2.400000 0.478560
v -1.421292 0.127575 0.477435
v -1.421292 0.127575 -0.477435
v -1.420490 2.482687 -0.236115
v -1.420490 2.482687 0.236115
v -1.420000 0.900000 -1.420000
v -1.420000 0.900000 -1.420000
v -1.420000 0.900000 1.420000
v -1.420000 0.900000 1.420000
v -1.419800 2.494500 0.000000
v -1.419800 2.494500 0.000000
v -1.416240 0.384375 -1.039360
v -1.416240 0.384375 1.039360
v -1.414853 1.037175 -1.414853
v -1.414853 1.037175 1.414853
v -1.410060 0.771675 -1.410060
v -1.410060 0.771675 1.410060
v -1.406405 0.105600 -0.472434
v -1.406405 0.105600 0.472434
v -1.405953 2.435437 -0.472283
v -1.405953 2.435437 0.472283
v -1.403125 2.498438 0.000000
v -1.403125 2.498438 0.000000
v -1.401513 2.494500 -0.232961
v -1.401513 2.494500 0.232961
v -1.401276 2.242575 -0.729046
v -1.401276 2.242575 0.729046
v -1.400120 1.178400 -1.400120
v -1.400120 1.178400 1.400120
v -1.400000 2.400000 0.000000
v -1.400000 2.400000 0.000000
v -1.390545 1.929525 -1.020503
v -1.390545 1.929525 1.020503
v -1.390200 2.494500 0.000000
v -1.390200 2.494500 0.000000
v -1.386270 2.463000 -0.465671
v -1.386270 2.463000 0.465671
v -1.385925 2.435437 0.000000
v -1.385925 2.435437 0.000000
v -1.385053 2.498438 -0.230225
v -1.385053 2.498438 0.230225
v -1.383080 0.656400 -1.383080
v -1.383080 0.656400 1.383080
v -1.382400 0.064800 -0.000000
v -1.382400 0.064800 0.000000
v -1.382225 2.482687 -0.000000
v -1.382225 2.482687 0.000000
v -1.381968 2.400000 -0.229712
v -1.381968 2.400000 0.229712
v -1.381032 0.213600 0.718514
v -1.381032 0.213600 -0.718514
v -1.380400 2.463000 0.000000
v -1.380400 2.463000 0.000000
v -1.376868 1.323225 -1.376867
v -1.376867 1.323225 1.376868
v -1.372712 0.084525 -0.461116
v -1.372712 0.084525 0.461116
v -1.372294 2.494500 -0.228104
v -1.372294 2.494500 0.228104
v -1.368074 2.435437 -0.227403
v -1.368074 2.435437 0.227403
v -1.366728 2.482687 -0.459107
v -1.366728 2.482687 0.459107
v -1.364595 0.064800 -0.226824
v -1.364595 0.064800 0.226824
v -1.364422 2.482687 -0.226795
v -1.364422 2.482687 0.226795
v -1.362620 2.463000 -0.226496
v -1.362620 2.463000 0.226496
v -1.356353 0.316800 -0.995410
v -1.356353 0.316800 0.995410
v -1.348469 2.494500 -0.452973
v -1.348469 2.494500 0.452973
v -1.347218 0.177075 0.700921
v -1.347218 0.177075 -0.700921
v -1.346160 1.471200 -1.346160
v -1.346160 1.471200 1.346160
v -1.343320 0.553725 -1.343320
v -1.343320 0.553725 1.343320
v -1.334760 2.400000 -0.694440
v -1.334760 0.150000 -0.694440
v -1.334760 0.150000 0.694440
v -1.334760 0.150000 0.694440
v -1.334760 2.400000 0.694440
v -1.334760 0.150000 -0.694440
v -1.333693 2.085600 -0.978780
v -1.333693 2.085600 0.978780
v -1.332632 2.498438 -0.447653
v -1.332632 2.498438 0.447653
v -1.331623 0.127575 0.692808
v -1.331623 0.127575 -0.692808
v -1.329664 2.400000 -0.446656
v -1.329664 2.400000 0.446656
v -1.320356 2.494500 -0.443529
v -1.320356 2.494500 0.443529
v -1.317675 0.105600 -0.685551
v -1.317675 0.105600 0.685551
v -1.317252 2.435437 -0.685331
v -1.317252 2.435437 0.685331
v -1.316296 2.435437 -0.442166
v -1.316296 2.435437 0.442166
v -1.312948 0.064800 0.441041
v -1.312948 0.064800 -0.441041
v -1.312782 2.482687 -0.440985
v -1.312782 2.482687 0.440985
v -1.311049 2.463000 -0.440403
v -1.311049 2.463000 0.440403
v -1.309063 1.621875 -1.309063
v -1.309063 1.621875 1.309063
v -1.301322 0.260025 0.955023
v -1.301322 0.260025 -0.955023
v -1.300000 2.400000 0.000000
v -1.300000 2.400000 0.000000
v -1.298810 2.463000 -0.675736
v -1.298810 2.463000 0.675736
v -1.295040 0.463200 -1.295040
v -1.295040 0.463200 1.295040
v -1.286108 0.084525 -0.669128
v -1.286108 0.084525 0.669128
v -1.284375 0.046875 0.000000
v -1.284375 0.046875 0.000000
v -1.283256 2.400000 -0.213304
v -1.283256 2.400000 0.213304
v -1.280502 2.482687 -0.666211
v -1.280502 2.482687 0.666211
v -1.274600 2.440800 0.000000
v -1.274600 2.440800 0.000000
v -1.274414 2.242575 -0.935276
v -1.274414 2.242575 0.935276
v -1.267832 0.046875 -0.210740
v -1.267832 0.046875 0.210740
v -1.266640 1.774800 -1.266640
v -1.266640 1.774800 1.266640
v -1.263395 2.494500 -0.657311
v -1.263395 2.494500 0.657311
v -1.258183 2.440800 0.209136
v -1.258183 2.440800 -0.209136
v -1.256003 0.213600 0.921764
v -1.256003 0.213600 -0.921764
v -1.248557 2.498438 -0.649591
v -1.248557 2.498438 0.649591
v -1.245776 2.400000 -0.648144
v -1.245776 2.400000 0.648144
v -1.242500 0.384375 -1.242500
v -1.242500 0.384375 1.242500
v -1.237056 2.494500 -0.643607
v -1.237056 2.494500 0.643607
v -1.234688 2.400000 -0.414752
v -1.234688 2.400000 0.414752
v -1.233252 2.435437 -0.641628
v -1.233252 2.435437 0.641628
v -1.230115 0.064800 -0.639996
v -1.230115 0.064800 0.639996
v -1.229959 2.482687 -0.639915
v -1.229959 2.482687 0.639915
v -1.228335 2.463000 -0.639070
v -1.228335 2.463000 0.639070
v -1.225250 0.177075 0.899195
v -1.225250 0.177075 -0.899195
v -1.219958 1.929525 1.219958
v -1.219958 1.929525 -1.219958
v -1.219848 0.046875 -0.409767
v -1.219848 0.046875 0.409767
v -1.213920 2.400000 -0.890880
v -1.213920 0.150000 -0.890880
v -1.213920 0.150000 -0.890880
v -1.213920 0.150000 0.890880
v -1.213920 0.150000 0.890880
v -1.213920 2.400000 0.890880
v -1.211067 0.127575 0.888786
v -1.211067 0.127575 -0.888786
v -1.210564 2.440800 0.406648
v -1.210564 2.440800 -0.406648
v -1.204800 2.474400 0.000000
v -1.204800 2.474400 0.000000
v -1.198382 0.105600 -0.879477
v -1.198382 0.105600 0.879477
v -1.197997 2.435437 -0.879195
v -1.197997 2.435437 0.879195
v -1.189960 0.316800 -1.189960
v -1.189960 0.316800 1.189960
v -1.189282 2.474400 -0.197684
v -1.189282 2.474400 0.197684
v -1.187840 0.900000 -1.618560
v -1.187840 0.900000 -1.618560
v -1.187840 0.900000 1.618560
v -1.187840 0.900000 1.618560
v -1.183534 1.037175 -1.612693
v -1.183534 1.037175 1.612693
v -1.181225 2.463000 -0.866886
v -1.181225 2.463000 0.866886
v -1.179525 0.771675 -1.607230
v -1.179525 0.771675 1.607230
v -1.171210 1.178400 -1.595900
v -1.171210 1.178400 1.595900
v -1.170080 2.085600 -1.170080
v -1.170080 2.085600 1.170080
v -1.169673 0.084525 -0.858407
v -1.169673 0.084525 0.858407
v -1.164574 2.482687 -0.854666
v -1.164574 2.482687 0.854666
v -1.156956 0.656400 -1.576477
v -1.156956 0.656400 1.576477
v -1.156792 2.400000 -0.601848
v -1.156792 2.400000 0.601848
v -1.151759 1.323225 -1.569396
v -1.151759 1.323225 1.569396
v -1.149016 2.494500 -0.843248
v -1.149016 2.494500 0.843248
v -1.144271 2.474400 -0.384379
v -1.144271 2.474400 0.384379
v -1.143600 0.031200 0.000000
v -1.143600 0.031200 0.000000
v -1.142888 0.046875 -0.594614
v -1.142888 0.046875 0.594614
v -1.141680 0.260025 1.141680
v -1.141680 0.260025 -1.141680
v -1.135521 2.498438 -0.833344
v -1.135521 2.498438 0.833344
v -1.134190 2.440800 0.590089
v -1.134190 2.440800 -0.590089
v -1.132992 2.400000 -0.831488
v -1.132992 2.400000 0.831488
v -1.128870 0.031200 -0.187642
v -1.128870 0.031200 0.187642
v -1.126072 1.471200 -1.534395
v -1.126072 1.471200 1.534395
v -1.125061 2.494500 -0.825668
v -1.125061 2.494500 0.825668
v -1.123697 0.553725 -1.531158
v -1.123697 0.553725 1.531158
v -1.121601 2.435437 -0.823129
v -1.121601 2.435437 0.823129
v -1.118749 0.064800 -0.821035
v -1.118749 0.064800 0.821035
v -1.118607 2.482687 -0.820931
v -1.118607 2.482687 0.820931
v -1.118073 2.242575 -1.118073
v -1.118073 2.242575 1.118073
v -1.117130 2.463000 -0.819847
v -1.117130 2.463000 0.819847
v -1.101920 0.213600 1.101920
v -1.101920 0.213600 -1.101920
v -1.100200 2.502600 0.000000
v -1.100200 2.502600 0.000000
v -1.095040 1.621875 -1.492110
v -1.095040 1.621875 1.492110
v -1.086146 0.031200 0.364854
v -1.086146 0.031200 -0.364854
v -1.086029 2.502600 0.180521
v -1.086029 2.502600 -0.180521
v -1.083310 0.463200 -1.476127
v -1.083310 0.463200 1.476127
v -1.074940 0.177075 -1.074940
v -1.074940 0.177075 1.074940
v -1.072079 2.474400 -0.557774
v -1.072079 2.474400 0.557774
v -1.065000 2.400000 -1.065000
v -1.065000 0.150000 -1.065000
v -1.065000 0.150000 1.065000
v -1.065000 2.400000 1.065000
v -1.062497 0.127575 1.062497
v -1.062497 0.127575 -1.062497
v -1.059553 1.774800 -1.443756
v -1.059553 1.774800 1.443756
v -1.052064 2.400000 -0.772096
v -1.052064 2.400000 0.772096
v -1.051368 0.105600 -1.051368
v -1.051368 0.105600 1.051368
v -1.051031 2.435437 -1.051031
v -1.051031 2.435437 1.051031
v -1.044926 2.502600 -0.351008
v -1.044926 2.502600 0.351008
v -1.039419 0.046875 -0.762816
v -1.039419 0.046875 0.762816
v -1.039360 0.384375 -1.416240
v -1.039360 0.384375 1.416240
v -1.036316 2.463000 -1.036316
v -1.036316 2.463000 1.036316
v -1.031508 2.440800 0.757010
v -1.031508 2.440800 -0.757010
v -1.026181 0.084525 -1.026181
v -1.026181 0.084525 1.026181
v -1.021708 2.482687 -1.021708
v -1.021708 2.482687 1.021708
v -1.020503 1.929525 -1.390545
v -1.020503 1.929525 1.390545
v -1.017621 0.031200 0.529441
v -1.017621 0.031200 -0.529441
v -1.008058 2.494500 -1.008058
v -1.008058 2.494500 1.008058
v -0.996219 2.498438 -0.996219
v -0.996219 2.498438 0.996219
v -0.995410 0.316800 -1.356353
v -0.995410 0.316800 1.356353
v -0.994000 2.400000 -0.994000
v -0.994000 2.400000 0.994000
v -0.987042 2.494500 -0.987042
v -0.987042 2.494500 0.987042
v -0.984007 2.435437 -0.984007
v -0.984007 2.435437 0.984007
v -0.981504 0.064800 0.981504
v -0.981504 0.064800 -0.981504
v -0.981380 2.482687 -0.981380
v -0.981380 2.482687 0.981380
v -0.980084 2.463000 -0.980084
v -0.980084 2.463000 0.980084
v -0.979002 2.502600 0.509349
v -0.979002 2.502600 -0.509349
v -0.978780 2.085600 -1.333693
v -0.978780 2.085600 1.333693
v -0.975021 2.474400 -0.715555
v -0.975021 2.474400 0.715555
v -0.970400 2.527200 0.000000
v -0.970400 2.527200 0.000000
v -0.957901 2.527200 -0.159223
v -0.957901 2.527200 0.159223
v -0.955023 0.260025 1.301322
v -0.955023 0.260025 -1.301322
v -0.952425 0.018225 -0.000000
v -0.952425 0.018225 0.000000
v -0.940158 0.018225 0.156274
v -0.940158 0.018225 -0.156274
v -0.935276 2.242575 -1.274414
v -0.935276 2.242575 1.274414
v -0.925920 0.900000 -1.779680
v -0.925920 0.900000 1.779680
v -0.925920 0.900000 1.779680
v -0.925920 0.900000 -1.779680
v -0.925493 0.031200 0.679207
v -0.925493 0.031200 -0.679207
v -0.923000 2.400000 -0.923000
v -0.923000 2.400000 0.923000
v -0.922564 1.037175 1.773229
v -0.922564 1.037175 -1.773229
v -0.921764 0.213600 1.256003
v -0.921764 0.213600 -1.256003
v -0.921647 2.527200 -0.309596
v -0.921647 2.527200 0.309596
v -0.919439 0.771675 -1.767222
v -0.919439 0.771675 1.767222
v -0.912957 1.178400 -1.754764
v -0.912957 1.178400 1.754764
v -0.911906 0.046875 -0.911906
v -0.911906 0.046875 0.911906
v -0.904966 2.440800 0.904966
v -0.904966 2.440800 -0.904966
v -0.904575 0.018225 0.303862
v -0.904575 0.018225 -0.303862
v -0.901846 0.656400 -1.733408
v -0.901846 0.656400 1.733408
v -0.899195 0.177075 1.225250
v -0.899195 0.177075 -1.225250
v -0.897795 1.323225 -1.725622
v -0.897795 1.323225 1.725622
v -0.890880 0.150000 -1.213920
v -0.890880 0.150000 1.213920
v -0.890880 2.400000 -1.213920
v -0.890880 0.150000 -1.213920
v -0.890880 0.150000 1.213920
v -0.890880 2.400000 1.213920
v -0.890370 2.502600 -0.653431
v -0.890370 2.502600 0.653431
v -0.888786 0.127575 1.211067
v -0.888786 0.127575 -1.211067
v -0.879477 0.105600 -1.198382
v -0.879477 0.105600 1.198382
v -0.879195 2.435437 -1.197997
v -0.879195 2.435437 1.197997
v -0.877772 1.471200 -1.687137
v -0.877772 1.471200 1.687137
v -0.875920 0.553725 -1.683577
v -0.875920 0.553725 1.683577
v -0.866886 2.463000 -1.181225
v -0.866886 2.463000 1.181225
v -0.863501 2.527200 -0.449256
v -0.863501 2.527200 0.449256
v -0.858407 0.084525 -1.169673
v -0.858407 0.084525 1.169673
v -0.855408 2.474400 -0.855408
v -0.855408 2.474400 0.855408
v -0.854666 2.482687 -1.164574
v -0.854666 2.482687 1.164574
v -0.853583 1.621875 -1.640643
v -0.853583 1.621875 1.640643
v -0.847506 0.018225 -0.440935
v -0.847506 0.018225 0.440935
v -0.844439 0.463200 1.623068
v -0.844439 0.463200 -1.623068
v -0.843248 2.494500 -1.149016
v -0.843248 2.494500 1.149016
v -0.833344 2.498438 -1.135521
v -0.833344 2.498438 1.135521
v -0.831488 2.400000 -1.132992
v -0.831488 2.400000 1.132992
v -0.825921 1.774800 1.587475
v -0.825921 1.774800 -1.587475
v -0.825668 2.494500 -1.125061
v -0.825668 2.494500 1.125061
v -0.825000 2.550000 0.000000
v -0.825000 2.550000 0.000000
v -0.823129 2.435437 -1.121601
v -0.823129 2.435437 1.121601
v -0.821035 0.064800 1.118749
v -0.821035 0.064800 -1.118749
v -0.820931 2.482687 1.118607
v -0.820931 2.482687 -1.118607
v -0.819847 2.463000 -1.117130
v -0.819847 2.463000 1.117130
v -0.814374 2.550000 -0.135366
v -0.814374 2.550000 0.135366
v -0.811956 0.031200 0.811956
v -0.811956 0.031200 -0.811956
v -0.810180 0.384375 1.557220
v -0.810180 0.384375 -1.557220
v -0.795481 1.929525 1.528968
v -0.795481 1.929525 -1.528968
v -0.785325 2.527200 -0.576340
v -0.785325 2.527200 0.576340
v -0.783552 2.550000 -0.263208
v -0.783552 2.550000 0.263208
v -0.781142 2.502600 -0.781142
v -0.781142 2.502600 0.781142
v -0.775921 0.316800 -1.491372
v -0.775921 0.316800 1.491372
v -0.772096 2.400000 -1.052064
v -0.772096 2.400000 1.052064
v -0.770779 0.018225 0.565664
v -0.770779 0.018225 -0.565664
v -0.762958 2.085600 -1.466456
v -0.762958 2.085600 1.466456
v -0.762816 0.046875 -1.039419
v -0.762816 0.046875 1.039419
v -0.757010 2.440800 1.031508
v -0.757010 2.440800 -1.031508
v -0.744440 0.260025 1.430863
v -0.744440 0.260025 -1.430863
v -0.734118 2.550000 -0.381942
v -0.734118 2.550000 0.381942
v -0.729046 2.242575 -1.401276
v -0.729046 2.242575 1.401276
v -0.718514 0.213600 1.381032
v -0.718514 0.213600 -1.381032
v -0.715555 2.474400 -0.975021
v -0.715555 2.474400 0.975021
v -0.703200 0.008400 0.000000
v -0.700921 0.177075 1.347218
v -0.700921 0.177075 -1.347218
v -0.694440 0.150000 -1.334760
v -0.694440 0.150000 1.334760
v -0.694440 2.400000 1.334760
v -0.694440 0.150000 1.334760
v -0.694440 2.400000 -1.334760
v -0.694440 0.150000 -1.334760
v -0.694143 0.008400 -0.115381
v -0.694143 0.008400 0.115381
v -0.692808 0.127575 1.331623
v -0.692808 0.127575 -1.331623
v -0.688984 2.527200 -0.688984
v -0.688984 2.527200 0.688984
v -0.685551 0.105600 -1.317675
v -0.685551 0.105600 1.317675
v -0.685331 2.435437 -1.317252
v -0.685331 2.435437 1.317252
v -0.679207 0.031200 -0.925493
v -0.679207 0.031200 0.925493
v -0.676222 0.018225 0.676222
v -0.676222 0.018225 -0.676222
v -0.675736 2.463000 -1.298810
v -0.675736 2.463000 1.298810
v -0.673600 2.572800 0.000000
v -0.673600 2.572800 0.000000
v -0.669128 0.084525 -1.286108
v -0.669128 0.084525 1.286108
v -0.667871 0.008400 -0.224349
v -0.667871 0.008400 0.224349
v -0.667656 2.550000 -0.489984
v -0.667656 2.550000 0.489984
v -0.666211 2.482687 1.280502
v -0.666211 2.482687 -1.280502
v -0.664924 2.572800 -0.110524
v -0.664924 2.572800 0.110524
v -0.657311 2.494500 -1.263395
v -0.657311 2.494500 1.263395
v -0.653431 2.502600 -0.890370
v -0.653431 2.502600 0.890370
v -0.649591 2.498438 -1.248557
v -0.649591 2.498438 1.248557
v -0.648144 2.400000 -1.245776
v -0.648144 2.400000 1.245776
v -0.643607 2.494500 -1.237056
v -0.643607 2.494500 1.237056
v -0.641628 2.435437 -1.233252
v -0.641628 2.435437 1.233252
v -0.639996 0.064800 -1.230115
v -0.639996 0.064800 1.230115
v -0.639915 2.482687 1.229959
v -0.639915 2.482687 -1.229959
v -0.639758 2.572800 -0.214905
v -0.639758 2.572800 0.214905
v -0.639070 2.463000 -1.228335
v -0.639070 2.463000 1.228335
v -0.638080 0.900000 -1.899520
v -0.638080 0.900000 -1.899520
v -0.638080 0.900000 1.899520
v -0.638080 0.900000 1.899520
v -0.635767 1.037175 -1.892634
v -0.635767 1.037175 1.892634
v -0.633613 0.771675 -1.886223
v -0.633613 0.771675 1.886223
v -0.629147 1.178400 -1.872927
v -0.629147 1.178400 1.872927
v -0.625735 0.008400 0.325553
v -0.625735 0.008400 -0.325553
v -0.621490 0.656400 -1.850132
v -0.621490 0.656400 1.850132
v -0.618698 1.323225 -1.841822
v -0.618698 1.323225 1.841822
v -0.604900 1.471200 -1.800745
v -0.604900 1.471200 1.800745
v -0.603624 0.553725 -1.796946
v -0.603624 0.553725 1.796946
v -0.601848 2.400000 -1.156792
v -0.601848 2.400000 1.156792
v -0.599396 2.572800 -0.311850
v -0.599396 2.572800 0.311850
v -0.594614 0.046875 -1.142888
v -0.594614 0.046875 1.142888
v -0.590089 2.440800 1.134190
v -0.590089 2.440800 -1.134190
v -0.588230 1.621875 -1.751120
v -0.588230 1.621875 1.751120
v -0.585750 2.550000 -0.585750
v -0.585750 2.550000 0.585750
v -0.581929 0.463200 -1.732362
v -0.581929 0.463200 1.732362
v -0.576340 2.527200 -0.785325
v -0.576340 2.527200 0.785325
v -0.569167 1.774800 -1.694372
v -0.569167 1.774800 1.694372
v -0.569086 0.008400 -0.417645
v -0.569086 0.008400 0.417645
v -0.565664 0.018225 0.770779
v -0.565664 0.018225 -0.770779
v -0.558320 0.384375 -1.662080
v -0.558320 0.384375 1.662080
v -0.557774 2.474400 -1.072079
v -0.557774 2.474400 1.072079
v -0.548190 1.929525 -1.631925
v -0.548190 1.929525 1.631925
v -0.545131 2.572800 -0.400065
v -0.545131 2.572800 0.400065
v -0.534711 0.316800 -1.591798
v -0.534711 0.316800 1.591798
v -0.529441 0.031200 -1.017621
v -0.529441 0.031200 1.017621
v -0.525800 2.597400 0.000000
v -0.525800 2.597400 0.000000
v -0.525778 2.085600 -1.565204
v -0.525778 2.085600 1.565204
v -0.519028 2.597400 0.086273
v -0.519028 2.597400 -0.086273
v -0.513016 0.260025 -1.527214
v -0.513016 0.260025 1.527214
v -0.509349 2.502600 0.979002
v -0.509349 2.502600 -0.979002
v -0.502408 2.242575 -1.495635
v -0.502408 2.242575 1.495635
v -0.499384 2.597400 -0.167751
v -0.499384 2.597400 0.167751
v -0.499272 0.008400 -0.499272
v -0.499272 0.008400 0.499272
v -0.495150 0.213600 -1.474028
v -0.495150 0.213600 1.474028
v -0.489984 2.550000 -0.667656
v -0.489984 2.550000 0.667656
v -0.483027 0.177075 -1.437937
v -0.483027 0.177075 1.437937
v -0.478560 0.150000 1.424640
v -0.478560 2.400000 -1.424640
v -0.478560 0.150000 -1.424640
v -0.478560 0.150000 -1.424640
v -0.478560 0.150000 1.424640
v -0.478560 2.400000 1.424640
v -0.478256 2.572800 -0.478256
v -0.478256 2.572800 0.478256
v -0.477435 0.127575 1.421292
v -0.477435 0.127575 -1.421292
v -0.472434 0.105600 1.406405
v -0.472434 0.105600 -1.406405
v -0.472283 2.435437 -1.405953
v -0.472283 2.435437 1.405953
v -0.467878 2.597400 -0.243424
v -0.467878 2.597400 0.243424
v -0.465671 2.463000 -1.386270
v -0.465671 2.463000 1.386270
v -0.461116 0.084525 1.372712
v -0.461116 0.084525 -1.372712
v -0.459107 2.482687 -1.366728
v -0.459107 2.482687 1.366728
v -0.452973 2.494500 -1.348469
v -0.452973 2.494500 1.348469
v -0.449256 2.527200 -0.863501
v -0.449256 2.527200 0.863501
v -0.447653 2.498438 -1.332632
v -0.447653 2.498438 1.332632
v -0.446656 2.400000 -1.329664
v -0.446656 2.400000 1.329664
v -0.443529 2.494500 -1.320356
v -0.443529 2.494500 1.320356
v -0.442166 2.435437 -1.316296
v -0.442166 2.435437 1.316296
v -0.441041 0.064800 1.312948
v -0.441041 0.064800 -1.312948
v -0.440985 2.482687 -1.312782
v -0.440985 2.482687 1.312782
v -0.440935 0.018225 0.847506
v -0.440935 0.018225 -0.847506
v -0.440403 2.463000 -1.311049
v -0.440403 2.463000 1.311049
v -0.425519 2.597400 0.312283
v -0.425519 2.597400 -0.312283
v -0.417645 0.008400 -0.569086
v -0.417645 0.008400 0.569086
v -0.414752 2.400000 -1.234688
v -0.414752 2.400000 1.234688
v -0.409767 0.046875 1.219848
v -0.409767 0.046875 -1.219848
v -0.406648 2.440800 -1.210564
v -0.406648 2.440800 1.210564
v -0.400065 2.572800 -0.545131
v -0.400065 2.572800 0.545131
v -0.391200 2.625600 0.000000
v -0.391200 2.625600 0.000000
v -0.388275 0.002175 -0.000000
v -0.388275 0.002175 0.000000
v -0.386161 2.625600 -0.064188
v -0.386161 2.625600 0.064188
v -0.384379 2.474400 -1.144271
v -0.384379 2.474400 1.144271
v -0.383274 0.002175 -0.063708
v -0.383274 0.002175 0.063708
v -0.381942 2.550000 -0.734118
v -0.381942 2.550000 0.734118
v -0.373318 2.597400 -0.373318
v -0.373318 2.597400 0.373318
v -0.371546 2.625600 -0.124808
v -0.371546 2.625600 0.124808
v -0.368768 0.002175 -0.123875
v -0.368768 0.002175 0.123875
v -0.364854 0.031200 1.086146
v -0.364854 0.031200 -1.086146
v -0.358400 3.034800 0.000000
v -0.358400 3.034800 0.000000
v -0.358200 3.081150 0.000000
v -0.358200 3.081150 0.000000
v -0.353807 3.034800 -0.059016
v -0.353807 3.034800 0.059016
v -0.353610 3.081150 -0.058988
v -0.353610 3.081150 0.058988
v -0.351008 2.502600 -1.044926
v -0.351008 2.502600 1.044926
v -0.348105 2.625600 -0.181110
v -0.348105 2.625600 0.181110
v -0.345503 0.002175 -0.179756
v -0.345503 0.002175 0.179756
v -0.340477 3.034800 -0.114676
v -0.340477 3.034800 0.114676
v -0.340289 3.081150 -0.114619
v -0.340289 3.081150 0.114619
v -0.328160 0.900000 -1.974240
v -0.328160 0.900000 1.974240
v -0.328160 0.900000 1.974240
v -0.326970 1.037175 -1.967083
v -0.326970 1.037175 1.967083
v -0.325863 0.771675 -1.960420
v -0.325863 0.771675 1.960420
v -0.325553 0.008400 -0.625735
v -0.325553 0.008400 0.625735
v -0.325000 2.981250 0.000000
v -0.325000 2.981250 0.000000
v -0.323566 1.178400 -1.946601
v -0.323566 1.178400 1.946601
v -0.320834 2.981250 -0.053508
v -0.320834 2.981250 0.053508
v -0.319628 0.656400 -1.922910
v -0.319628 0.656400 1.922910
v -0.319082 3.034800 -0.166306
v -0.319082 3.034800 0.166306
v -0.318907 3.081150 -0.166221
v -0.318907 3.081150 0.166221
v -0.318192 1.323225 -1.914272
v -0.318192 1.323225 1.914272
v -0.316590 2.625600 -0.232342
v -0.316590 2.625600 0.232342
v -0.314223 0.002175 -0.230604
v -0.314223 0.002175 0.230604
v -0.312283 2.597400 -0.425519
v -0.312283 2.597400 0.425519
v -0.311850 2.572800 -0.599396
v -0.311850 2.572800 0.599396
v -0.311096 1.471200 -1.871580
v -0.311096 1.471200 1.871580
v -0.310439 0.553725 -1.867631
v -0.310439 0.553725 1.867631
v -0.309596 2.527200 -0.921647
v -0.309596 2.527200 0.921647
v -0.308800 3.117600 0.000000
v -0.308800 3.117600 0.000000
v -0.308744 2.981250 -0.103976
v -0.308744 2.981250 0.103976
v -0.304843 3.117600 -0.050855
v -0.304843 3.117600 0.050855
v -0.303862 0.018225 0.904575
v -0.303862 0.018225 -0.904575
v -0.302523 1.621875 -1.820003
v -0.302522 1.621875 1.820003
v -0.299282 0.463200 -1.800507
v -0.299282 0.463200 1.800507
v -0.293360 3.117600 -0.098814
v -0.293360 3.117600 0.098814
v -0.292719 1.774800 -1.761022
v -0.292719 1.774800 1.761022
v -0.290295 3.034800 -0.213234
v -0.290295 3.034800 0.213234
v -0.290138 3.081150 -0.213123
v -0.290138 3.081150 0.213123
v -0.289340 2.981250 -0.150793
v -0.289340 2.981250 0.150793
v -0.287140 0.384375 -1.727460
v -0.287140 0.384375 1.727460
v -0.281930 1.929525 1.696119
v -0.281930 1.929525 -1.696119
v -0.279400 2.659200 0.000000
v -0.277752 2.625600 -0.277752
v -0.277752 2.625600 0.277752
v -0.275801 2.659200 -0.045844
v -0.275801 2.659200 0.045844
v -0.275675 0.002175 -0.275675
v -0.275675 0.002175 0.275675
v -0.274998 0.316800 -1.654413
v -0.274998 0.316800 1.654413
v -0.274928 3.117600 -0.143301
v -0.274928 3.117600 0.143301
v -0.273600 2.923200 0.000000
v -0.273600 2.923200 0.000000
v -0.270404 2.085600 -1.626774
v -0.270404 2.085600 1.626774
v -0.270092 2.923200 -0.045032
v -0.270092 2.923200 0.045032
v -0.265363 2.659200 -0.089140
v -0.265363 2.659200 0.089140
v -0.263841 0.260025 1.587289
v -0.263841 0.260025 -1.587289
v -0.263232 2.981250 -0.193348
v -0.263232 2.981250 0.193348
v -0.263208 2.550000 -0.783552
v -0.263208 2.550000 0.783552
v -0.259910 2.923200 -0.087511
v -0.259910 2.923200 0.087511
v -0.258385 2.242575 -1.554467
v -0.258385 2.242575 1.554467
v -0.254788 3.034800 -0.254788
v -0.254788 3.034800 0.254788
v -0.254653 3.081150 -0.254653
v -0.254653 3.081150 0.254653
v -0.254652 0.213600 -1.532010
v -0.254652 0.213600 1.532010
v -0.250127 3.117600 -0.183734
v -0.250127 3.117600 0.183734
v -0.248621 2.659200 0.129351
v -0.248621 2.659200 -0.129351
v -0.248417 0.177075 -1.494500
v -0.248417 0.177075 1.494500
v -0.246120 0.150000 1.480680
v -0.246120 2.400000 -1.480680
v -0.246120 0.150000 -1.480680
v -0.246120 0.150000 -1.480680
v -0.246120 0.150000 1.480680
v -0.246120 2.400000 1.480680
v -0.245542 0.127575 1.477200
v -0.245542 0.127575 -1.477200
v -0.243569 2.923200 -0.126920
v -0.243569 2.923200 0.126920
v -0.243424 2.597400 0.467878
v -0.243424 2.597400 -0.467878
v -0.242970 0.105600 1.461727
v -0.242970 0.105600 -1.461727
v -0.242892 2.435437 -1.461258
v -0.242892 2.435437 1.461258
v -0.239491 2.463000 -1.440800
v -0.239491 2.463000 1.440800
v -0.237149 0.084525 1.426709
v -0.237149 0.084525 -1.426709
v -0.236115 2.482687 -1.420490
v -0.236115 2.482687 1.420490
v -0.232961 2.494500 -1.401513
v -0.232961 2.494500 1.401513
v -0.232342 2.625600 -0.316590
v -0.232342 2.625600 0.316590
v -0.231031 2.981250 -0.231031
v -0.231031 2.981250 0.231031
v -0.230604 0.002175 -0.314223
v -0.230604 0.002175 0.314223
v -0.230225 2.498438 -1.385053
v -0.230225 2.498438 1.385053
v -0.229712 2.400000 -1.381968
v -0.229712 2.400000 1.381968
v -0.228104 2.494500 -1.372294
v -0.228104 2.494500 1.372294
v -0.227403 2.435437 -1.368074
v -0.227403 2.435437 1.368074
v -0.226824 0.064800 1.364595
v -0.226824 0.064800 -1.364595
v -0.226795 2.482687 1.364422
v -0.226795 2.482687 -1.364422
v -0.226496 2.463000 -1.362620
v -0.226496 2.463000 1.362620
v -0.226113 2.659200 -0.165941
v -0.226113 2.659200 0.165941
v -0.224349 0.008400 0.667871
v -0.224349 0.008400 -0.667871
v -0.221585 2.923200 -0.162745
v -0.221585 2.923200 0.162745
v -0.219800 2.863350 0.000000
v -0.219800 2.863350 0.000000
v -0.219536 3.117600 -0.219536
v -0.219536 3.117600 0.219536
v -0.216979 2.863350 0.036157
v -0.216979 2.863350 -0.036157
v -0.214905 2.572800 -0.639758
v -0.214905 2.572800 0.639758
v -0.213304 2.400000 -1.283256
v -0.213304 2.400000 1.283256
v -0.213234 3.034800 -0.290295
v -0.213234 3.034800 0.290295
v -0.213123 3.081150 -0.290138
v -0.213123 3.081150 0.290138
v -0.210740 0.046875 -1.267832
v -0.210740 0.046875 1.267832
v -0.209136 2.440800 -1.258183
v -0.209136 2.440800 1.258183
v -0.208794 2.863350 0.070270
v -0.208794 2.863350 -0.070270
v -0.200000 2.700000 0.000000
v -0.200000 2.700000 0.000000
v -0.200000 2.700000 0.000000
v -0.200000 2.700000 0.000000
v -0.198374 2.659200 -0.198374
v -0.198374 2.659200 0.198374
v -0.197684 2.474400 -1.189282
v -0.197684 2.474400 1.189282
v -0.197424 2.700000 -0.032816
v -0.197424 2.700000 0.032816
v -0.197424 2.700000 0.032816
v -0.197424 2.700000 -0.032816
v -0.195658 2.863350 -0.101925
v -0.195658 2.863350 0.101925
v -0.194600 3.141450 0.000000
v -0.194600 3.141450 0.000000
v -0.194472 2.923200 -0.194472
v -0.194472 2.923200 0.194472
v -0.193348 2.981250 -0.263232
v -0.193348 2.981250 0.263232
v -0.192107 3.141450 -0.032048
v -0.192107 3.141450 0.032048
v -0.189952 2.700000 -0.063808
v -0.189952 2.700000 0.063808
v -0.189952 2.700000 0.063808
v -0.189952 2.700000 -0.063808
v -0.187642 0.031200 1.128870
v -0.187642 0.031200 -1.128870
v -0.184870 3.141450 -0.062272
v -0.184870 3.141450 0.062272
v -0.183734 3.117600 -0.250127
v -0.183734 3.117600 0.250127
v -0.181110 2.625600 0.348105
v -0.181110 2.625600 -0.348105
v -0.180521 2.502600 -1.086029
v -0.180521 2.502600 1.086029
v -0.179756 0.002175 -0.345503
v -0.179756 0.002175 0.345503
v -0.179200 2.804400 0.000000
v -0.179200 2.804400 0.000000
v -0.177989 2.863350 -0.130707
v -0.177989 2.863350 0.130707
v -0.177968 2.700000 -0.092592
v -0.177968 2.700000 0.092592
v -0.177968 2.700000 0.092592
v -0.177968 2.700000 -0.092592
v -0.176897 2.804400 0.029450
v -0.176897 2.804400 -0.029450
v -0.173255 3.141450 -0.090306
v -0.173255 3.141450 0.090306
v -0.170215 2.804400 0.057246
v -0.170215 2.804400 -0.057246
v -0.167751 2.597400 -0.499384
v -0.167751 2.597400 0.499384
v -0.167400 2.749050 0.000000
v -0.167400 2.749050 0.000000
v -0.166306 3.034800 -0.319082
v -0.166306 3.034800 0.319082
v -0.166221 3.081150 0.318907
v -0.166221 3.081150 -0.318907
v -0.165941 2.659200 -0.226113
v -0.165941 2.659200 0.226113
v -0.165245 2.749050 0.027480
v -0.165245 2.749050 -0.027480
v -0.162745 2.923200 -0.221585
v -0.162745 2.923200 0.221585
v -0.161856 2.700000 -0.118784
v -0.161856 2.700000 0.118784
v -0.161856 2.700000 0.118784
v -0.161856 2.700000 -0.118784
v -0.159496 2.804400 0.083047
v -0.159496 2.804400 -0.083047
v -0.159223 2.527200 -0.957901
v -0.159223 2.527200 0.957901
v -0.158995 2.749050 0.053428
v -0.158995 2.749050 -0.053428
v -0.157626 3.141450 -0.115787
v -0.157626 3.141450 0.115787
v -0.156274 0.018225 0.940158
v -0.156274 0.018225 -0.940158
v -0.156200 2.863350 -0.156200
v -0.156200 2.863350 0.156200
v -0.150793 2.981250 -0.289340
v -0.150793 2.981250 0.289340
v -0.148969 2.749050 0.077523
v -0.148969 2.749050 -0.077523
v -0.145078 2.804400 0.106513
v -0.145078 2.804400 -0.106513
v -0.143301 3.117600 -0.274928
v -0.143301 3.117600 0.274928
v -0.142000 2.700000 -0.142000
v -0.142000 2.700000 0.142000
v -0.142000 2.700000 0.142000
v -0.142000 2.700000 -0.142000
v -0.138348 3.141450 -0.138348
v -0.138348 3.141450 0.138348
v -0.135489 2.749050 0.099446
v -0.135489 2.749050 -0.099446
v -0.135366 2.550000 -0.814374
v -0.135366 2.550000 0.814374
v -0.130707 2.863350 -0.177989
v -0.130707 2.863350 0.177989
v -0.129351 2.659200 0.248621
v -0.129351 2.659200 -0.248621
v -0.127304 2.804400 0.127304
v -0.127304 2.804400 -0.127304
v -0.126920 2.923200 -0.243569
v -0.126920 2.923200 0.243569
v -0.124808 2.625600 -0.371546
v -0.124808 2.625600 0.371546
v -0.123875 0.002175 0.368768
v -0.123875 0.002175 -0.368768
v -0.118874 2.749050 0.118874
v -0.118874 2.749050 -0.118874
v -0.118784 2.700000 -0.161856
v -0.118784 2.700000 0.161856
v -0.118784 2.700000 0.161856
v -0.118784 2.700000 -0.161856
v -0.115787 3.141450 -0.157626
v -0.115787 3.141450 0.157626
v -0.115381 0.008400 0.694143
v -0.115381 0.008400 -0.694143
v -0.114676 3.034800 -0.340477
v -0.114676 3.034800 0.340477
v -0.114619 3.081150 -0.340289
v -0.114619 3.081150 0.340289
v -0.110524 2.572800 -0.664924
v -0.110524 2.572800 0.664924
v -0.106513 2.804400 -0.145078
v -0.106513 2.804400 0.145078
v -0.103976 2.981250 -0.308744
v -0.103976 2.981250 0.308744
v -0.101925 2.863350 -0.195658
v -0.101925 2.863350 0.195658
v -0.099446 2.749050 0.135489
v -0.099446 2.749050 -0.135489
v -0.098814 3.117600 -0.293360
v -0.098814 3.117600 0.293360
v -0.092592 2.700000 -0.177968
v -0.092592 2.700000 0.177968
v -0.092592 2.700000 -0.177968
v -0.092592 2.700000 0.177968
v -0.090306 3.141450 -0.173255
v -0.090306 3.141450 0.173255
v -0.089140 2.659200 -0.265363
v -0.089140 2.659200 0.265363
v -0.087511 2.923200 -0.259910
v -0.087511 2.923200 0.259910
v -0.086273 2.597400 -0.519028
v -0.086273 2.597400 0.519028
v -0.083047 2.804400 -0.159496
v -0.083047 2.804400 0.159496
v -0.077523 2.749050 -0.148969
v -0.077523 2.749050 0.148969
v -0.070270 2.863350 -0.208794
v -0.070270 2.863350 0.208794
v -0.064188 2.625600 -0.386161
v -0.064188 2.625600 0.386161
v -0.063808 2.700000 -0.189952
v -0.063808 2.700000 0.189952
v -0.063808 2.700000 -0.189952
v -0.063808 2.700000 0.189952
v -0.063708 0.002175 0.383274
v -0.063708 0.002175 -0.383274
v -0.062272 3.141450 -0.184870
v -0.062272 3.141450 0.184870
v -0.059016 3.034800 -0.353807
v -0.059016 3.034800 0.353807
v -0.058988 3.081150 -0.353610
v -0.058988 3.081150 0.353610
v -0.057246 2.804400 -0.170215
v -0.057246 2.804400 0.170215
v -0.053508 2.981250 -0.320834
v -0.053508 2.981250 0.320834
v -0.053428 2.749050 -0.158995
v -0.053428 2.749050 0.158995
v -0.050855 3.117600 -0.304843
v -0.050855 3.117600 0.304843
v -0.045844 2.659200 -0.275801
v -0.045844 2.659200 0.275801
v -0.045032 2.923200 -0.270092
v -0.045032 2.923200 0.270092
v -0.036157 2.863350 -0.216979
v -0.036157 2.863350 0.216979
v -0.032816 2.700000 -0.197424
v -0.032816 2.700000 0.197424
v -0.032816 2.700000 -0.197424
v -0.032816 2.700000 0.197424
v -0.032048 3.141450 -0.192107
v -0.032048 3.141450 0.192107
v -0.029450 2.804400 -0.176897
v -0.029450 2.804400 0.176897
v -0.027480 2.749050 -0.165245
v -0.027480 2.749050 0.165245
v -0.000000 0.260025 1.608000
v -0.000000 1.929525 1.718250
v -0.000000 2.085600 -1.648000
v -0.000000 0.656400 -1.948000
v -0.000000 0.771675 -1.986000
v -0.000000 2.482687 1.382225
v -0.000000 2.700000 -0.200000
v -0.000000 0.127575 1.496475
v -0.000000 2.474400 -1.204800
v -0.000000 2.749050 -0.167400
v -0.000000 0.018225 0.952425
v -0.000000 0.046875 -1.284375
v -0.000000 0.064800 1.382400
v -0.000000 0.384375 1.750000
v -0.000000 0.463200 1.824000
v -0.000000 0.553725 -1.892000
v -0.000000 1.037175 1.992750
v -0.000000 1.178400 1.972000
v -0.000000 1.323225 -1.939250
v -0.000000 1.621875 -1.843750
v -0.000000 1.774800 1.784000
v -0.000000 2.400000 -1.300000
v -0.000000 2.435437 -1.480325
v -0.000000 2.435437 -1.385925
v -0.000000 2.463000 -1.459600
v -0.000000 2.463000 -1.380400
v -0.000000 2.494500 -1.390200
v -0.000000 2.502600 -1.100200
v -0.000000 2.804400 -0.179200
v -0.000000 2.863350 -0.219800
v -0.000000 2.572800 -0.673600
v -0.000000 0.105600 1.480800
v -0.000000 0.177075 -1.514000
v -0.000000 2.494500 -1.419800
v -0.000000 2.527200 -0.970400
v -0.000000 2.923200 -0.273600
v -0.000000 3.117600 -0.308800
v -0.000000 2.597400 -0.525800
v -0.000000 2.700000 -0.200000
v -0.000000 2.981250 -0.325000
v -0.000000 3.141450 -0.194600
v -0.000000 0.002175 0.388275
v -0.000000 3.081150 -0.358200
v 0.000000 0.000000 0.000000
v 0.000000 0.002175 -0.388275
v 0.000000 0.002175 0.388275
v 0.000000 0.008400 -0.703200
v 0.000000 0.008400 0.703200
v 0.000000 0.018225 -0.952425
v 0.000000 0.018225 0.952425
v 0.000000 0.031200 -1.143600
v 0.000000 0.031200 -1.143600
v 0.000000 0.031200 1.143600
v 0.000000 0.031200 1.143600
v 0.000000 0.046875 -1.284375
v 0.000000 0.046875 1.284375
v 0.000000 0.064800 -1.382400
v 0.000000 0.064800 1.382400
v 0.000000 0.084525 -1.445325
v 0.000000 0.084525 -1.445325
v 0.000000 0.084525 1.445325
v 0.000000 0.084525 1.445325
v 0.000000 0.105600 -1.480800
v 0.000000 0.105600 1.480800
v 0.000000 0.127575 -1.496475
v 0.000000 0.127575 1.496475
v 0.000000 0.150000 -1.500000
v 0.000000 0.150000 -1.500000
v 0.000000 0.150000 1.500000
v 0.000000 0.150000 1.500000
v 0.000000 0.177075 -1.514000
v 0.000000 0.177075 1.514000
v 0.000000 0.213600 -1.552000
v 0.000000 0.213600 -1.552000
v 0.000000 0.213600 1.552000
v 0.000000 0.213600 1.552000
v 0.000000 0.260025 -1.608000
v 0.000000 0.260025 1.608000
v 0.000000 0.316800 -1.676000
v 0.000000 0.316800 -1.676000
v 0.000000 0.316800 1.676000
v 0.000000 0.316800 1.676000
v 0.000000 0.384375 -1.750000
v 0.000000 0.384375 1.750000
v 0.000000 0.463200 -1.824000
v 0.000000 0.463200 1.824000
v 0.000000 0.553725 -1.892000
v 0.000000 0.553725 1.892000
v 0.000000 0.656400 -1.948000
v 0.000000 0.656400 1.948000
v 0.000000 0.771675 -1.986000
v 0.000000 0.771675 1.986000
v 0.000000 0.900000 -2.000000
v 0.000000 0.900000 -2.000000
v 0.000000 0.900000 2.000000
v 0.000000 0.900000 2.000000
v 0.000000 1.037175 -1.992750
v 0.000000 1.037175 1.992750
v 0.000000 1.178400 -1.972000
v 0.000000 1.178400 1.972000
v 0.000000 1.323225 -1.939250
v 0.000000 1.323225 1.939250
v 0.000000 1.471200 -1.896000
v 0.000000 1.471200 -1.896000
v 0.000000 1.471200 1.896000
v 0.000000 1.471200 1.896000
v 0.000000 1.621875 -1.843750
v 0.000000 1.621875 1.843750
v 0.000000 1.774800 -1.784000
v 0.000000 1.774800 1.784000
v 0.000000 1.929525 -1.718250
v 0.000000 1.929525 1.718250
v 0.000000 2.085600 -1.648000
v 0.000000 2.085600 1.648000
v 0.000000 2.242575 -1.574750
v 0.000000 2.242575 -1.574750
v 0.000000 2.242575 1.574750
v 0.000000 2.242575 1.574750
v 0.000000 2.400000 -1.500000
v 0.000000 2.400000 -1.500000
v 0.000000 2.400000 -1.400000
v 0.000000 2.400000 -1.400000
v 0.000000 2.400000 -1.300000
v 0.000000 2.400000 1.300000
v 0.000000 2.400000 1.400000
v 0.000000 2.400000 1.400000
v 0.000000 2.400000 1.500000
v 0.000000 2.400000 1.500000
v 0.000000 2.435437 -1.480325
v 0.000000 2.435437 -1.385925
v 0.000000 2.435437 1.385925
v 0.000000 2.435437 1.480325
v 0.000000 2.440800 -1.274600
v 0.000000 2.440800 -1.274600
v 0.000000 2.440800 1.274600
v 0.000000 2.440800 1.274600
v 0.000000 2.463000 -1.459600
v 0.000000 2.463000 -1.380400
v 0.000000 2.463000 1.380400
v 0.000000 2.463000 1.459600
v 0.000000 2.474400 -1.204800
v 0.000000 2.474400 1.204800
v 0.000000 2.482687 -1.439025
v 0.000000 2.482687 -1.382225
v 0.000000 2.482687 1.382225
v 0.000000 2.482687 1.439025
v 0.000000 2.494500 -1.419800
v 0.000000 2.494500 -1.390200
v 0.000000 2.494500 1.390200
v 0.000000 2.494500 1.419800
v 0.000000 2.498438 -1.403125
v 0.000000 2.498438 -1.403125
v 0.000000 2.498438 1.403125
v 0.000000 2.498438 1.403125
v 0.000000 2.502600 -1.100200
v 0.000000 2.502600 1.100200
v 0.000000 2.527200 -0.970400
v 0.000000 2.527200 0.970400
v 0.000000 2.550000 -0.825000
v 0.000000 2.550000 -0.825000
v 0.000000 2.550000 0.825000
v 0.000000 2.550000 0.825000
v 0.000000 2.572800 -0.673600
v 0.000000 2.572800 0.673600
v 0.000000 2.597400 -0.525800
v 0.000000 2.597400 0.525800
v 0.000000 2.625600 -0.391200
v 0.000000 2.625600 -0.391200
v 0.000000 2.625600 0.391200
v 0.000000 2.625600 0.391200
v 0.000000 2.659200 -0.279400
v 0.000000 2.659200 0.279400
v 0.000000 2.700000 -0.200000
v 0.000000 2.700000 -0.200000
v 0.000000 2.700000 0.200000
v 0.000000 2.700000 0.200000
v 0.000000 2.749050 -0.167400
v 0.000000 2.749050 0.167400
v 0.000000 2.804400 -0.179200
v 0.000000 2.804400 0.179200
v 0.000000 2.863350 -0.219800
v 0.000000 2.863350 0.219800
v 0.000000 2.923200 -0.273600
v 0.000000 2.923200 0.273600
v 0.000000 2.981250 -0.325000
v 0.000000 2.981250 0.325000
v 0.000000 3.034800 -0.358400
v 0.000000 3.034800 -0.358400
v 0.000000 3.034800 0.358400
v 0.000000 3.034800 0.358400
v 0.000000 3.081150 -0.358200
v 0.000000 3.081150 0.358200
v 0.000000 3.117600 -0.308800
v 0.000000 3.117600 0.308800
v 0.000000 3.141450 -0.194600
v 0.000000 3.141450 0.194600
v 0.000000 3.150000 0.000000
v 0.000000 0.002175 -0.388275
v 0.000000 3.081150 0.358200
v 0.000000 2.597400 0.525800
v 0.000000 2.700000 0.200000
v 0.000000 2.981250 0.325000
v 0.000000 3.141450 0.194600
v 0.000000 3.117600 0.308800
v 0.000000 0.105600 -1.480800
v 0.000000 0.177075 1.514000
v 0.000000 2.494500 1.419800
v 0.000000 2.527200 0.970400
v 0.000000 2.923200 0.273600
v 0.000000 2.572800 0.673600
v 0.000000 2.863350 0.219800
v 0.000000 0.018225 -0.952425
v 0.000000 0.046875 1.284375
v 0.000000 0.064800 -1.382400
v 0.000000 0.384375 -1.750000
v 0.000000 0.463200 -1.824000
v 0.000000 0.553725 1.892000
v 0.000000 1.037175 -1.992750
v 0.000000 1.178400 -1.972000
v 0.000000 1.323225 1.939250
v 0.000000 1.621875 1.843750
v 0.000000 1.774800 -1.784000
v 0.000000 2.400000 1.300000
v 0.000000 2.435437 1.385925
v 0.000000 2.435437 1.480325
v 0.000000 2.463000 1.380400
v 0.000000 2.463000 1.459600
v 0.000000 2.494500 1.390200
v 0.000000 2.502600 1.100200
v 0.000000 2.804400 0.179200
v 0.000000 2.749050 0.167400
v 0.000000 0.127575 -1.496475
v 0.000000 2.474400 1.204800
v 0.000000 0.656400 1.948000
v 0.000000 0.771675 1.986000
v 0.000000 2.482687 -1.382225
v 0.000000 2.700000 0.200000
v 0.000000 0.260025 -1.608000
v 0.000000 1.929525 -1.718250
v 0.000000 2.085600 1.648000
v 0.027480 2.749050 -0.165245
v 0.027480 2.749050 0.165245
v 0.029450 2.804400 -0.176897
v 0.029450 2.804400 0.176897
v 0.032048 3.141450 -0.192107
v 0.032048 3.141450 0.192107
v 0.032816 2.700000 -0.197424
v 0.032816 2.700000 0.197424
v 0.032816 2.700000 -0.197424
v 0.032816 2.700000 0.197424
v 0.036157 2.863350 -0.216979
v 0.036157 2.863350 0.216979
v 0.045032 2.923200 -0.270092
v 0.045032 2.923200 0.270092
v 0.045844 2.659200 -0.275801
v 0.045844 2.659200 0.275801
v 0.050855 3.117600 -0.304843
v 0.050855 3.117600 0.304843
v 0.053428 2.749050 -0.158995
v 0.053428 2.749050 0.158995
v 0.053508 2.981250 -0.320834
v 0.053508 2.981250 0.320834
v 0.057246 2.804400 -0.170215
v 0.057246 2.804400 0.170215
v 0.058988 3.081150 -0.353610
v 0.058988 3.081150 0.353610
v 0.059016 3.034800 -0.353807
v 0.059016 3.034800 0.353807
v 0.062272 3.141450 -0.184870
v 0.062272 3.141450 0.184870
v 0.063708 0.002175 0.383274
v 0.063708 0.002175 -0.383274
v 0.063808 2.700000 -0.189952
v 0.063808 2.700000 0.189952
v 0.063808 2.700000 -0.189952
v 0.063808 2.700000 0.189952
v 0.064188 2.625600 -0.386161
v 0.064188 2.625600 0.386161
v 0.070270 2.863350 -0.208794
v 0.070270 2.863350 0.208794
v 0.077523 2.749050 -0.148969
v 0.077523 2.749050 0.148969
v 0.083047 2.804400 -0.159496
v 0.083047 2.804400 0.159496
v 0.086273 2.597400 -0.519028
v 0.086273 2.597400 0.519028
v 0.087511 2.923200 -0.259910
v 0.087511 2.923200 0.259910
v 0.089140 2.659200 -0.265363
v 0.089140 2.659200 0.265363
v 0.090306 3.141450 -0.173255
v 0.090306 3.141450 0.173255
v 0.092592 2.700000 -0.177968
v 0.092592 2.700000 0.177968
v 0.092592 2.700000 -0.177968
v 0.092592 2.700000 0.177968
v 0.098814 3.117600 -0.293360
v 0.098814 3.117600 0.293360
v 0.099446 2.749050 0.135489
v 0.099446 2.749050 -0.135489
v 0.101925 2.863350 -0.195658
v 0.101925 2.863350 0.195658
v 0.103976 2.981250 -0.308744
v 0.103976 2.981250 0.308744
v 0.106513 2.804400 -0.145078
v 0.106513 2.804400 0.145078
v 0.110524 2.572800 -0.664924
v 0.110524 2.572800 0.664924
v 0.114619 3.081150 -0.340289
v 0.114619 3.081150 0.340289
v 0.114676 3.034800 -0.340477
v 0.114676 3.034800 0.340477
v 0.115381 0.008400 0.694143
v 0.115381 0.008400 -0.694143
v 0.115787 3.141450 -0.157626
v 0.115787 3.141450 0.157626
v 0.118784 2.700000 0.161856
v 0.118784 2.700000 -0.161856
v 0.118784 2.700000 -0.161856
v 0.118784 2.700000 0.161856
v 0.118874 2.749050 0.118874
v 0.118874 2.749050 -0.118874
v 0.123875 0.002175 0.368768
v 0.123875 0.002175 -0.368768
v 0.124808 2.625600 -0.371546
v 0.124808 2.625600 0.371546
v 0.126920 2.923200 -0.243569
v 0.126920 2.923200 0.243569
v 0.127304 2.804400 0.127304
v 0.127304 2.804400 -0.127304
v 0.129351 2.659200 0.248621
v 0.129351 2.659200 -0.248621
v 0.130707 2.863350 -0.177989
v 0.130707 2.863350 0.177989
v 0.135366 2.550000 -0.814374
v 0.135366 2.550000 0.814374
v 0.135489 2.749050 0.099446
v 0.135489 2.749050 -0.099446
v 0.138348 3.141450 -0.138348
v 0.138348 3.141450 0.138348
v 0.142000 2.700000 0.142000
v 0.142000 2.700000 -0.142000
v 0.142000 2.700000 -0.142000
v 0.142000 2.700000 0.142000
v 0.143301 3.117600 -0.274928
v 0.143301 3.117600 0.274928
v 0.145078 2.804400 0.106513
v 0.145078 2.804400 -0.106513
v 0.148969 2.749050 0.077523
v 0.148969 2.749050 -0.077523
v 0.150793 2.981250 -0.289340
v 0.150793 2.981250 0.289340
v 0.156200 2.863350 -0.156200
v 0.156200 2.863350 0.156200
v 0.156274 0.018225 0.940158
v 0.156274 0.018225 -0.940158
v 0.157626 3.141450 -0.115787
v 0.157626 3.141450 0.115787
v 0.158995 2.749050 0.053428
v 0.158995 2.749050 -0.053428
v 0.159223 2.527200 -0.957901
v 0.159223 2.527200 0.957901
v 0.159496 2.804400 0.083047
v 0.159496 2.804400 -0.083047
v 0.161856 2.700000 0.118784
v 0.161856 2.700000 -0.118784
v 0.161856 2.700000 -0.118784
v 0.161856 2.700000 0.118784
v 0.162745 2.923200 -0.221585
v 0.162745 2.923200 0.221585
v 0.165245 2.749050 0.027480
v 0.165245 2.749050 -0.027480
v 0.165941 2.659200 -0.226113
v 0.165941 2.659200 0.226113
v 0.166221 3.081150 0.318907
v 0.166221 3.081150 -0.318907
v 0.166306 3.034800 -0.319082
v 0.166306 3.034800 0.319082
v 0.167400 2.749050 -0.000000
v 0.167400 2.749050 0.000000
v 0.167751 2.597400 -0.499384
v 0.167751 2.597400 0.499384
v 0.170215 2.804400 0.057246
v 0.170215 2.804400 -0.057246
v 0.173255 3.141450 -0.090306
v 0.173255 3.141450 0.090306
v 0.176897 2.804400 0.029450
v 0.176897 2.804400 -0.029450
v 0.177968 2.700000 0.092592
v 0.177968 2.700000 -0.092592
v 0.177968 2.700000 -0.092592
v 0.177968 2.700000 0.092592
v 0.177989 2.863350 -0.130707
v 0.177989 2.863350 0.130707
v 0.179200 2.804400 -0.000000
v 0.179200 2.804400 0.000000
v 0.179756 0.002175 -0.345503
v 0.179756 0.002175 0.345503
v 0.180521 2.502600 -1.086029
v 0.180521 2.502600 1.086029
v 0.181110 2.625600 0.348105
v 0.181110 2.625600 -0.348105
v 0.183734 3.117600 -0.250127
v 0.183734 3.117600 0.250127
v 0.184870 3.141450 -0.062272
v 0.184870 3.141450 0.062272
v 0.187642 0.031200 1.128870
v 0.187642 0.031200 -1.128870
v 0.189952 2.700000 0.063808
v 0.189952 2.700000 -0.063808
v 0.189952 2.700000 -0.063808
v 0.189952 2.700000 0.063808
v 0.192107 3.141450 -0.032048
v 0.192107 3.141450 0.032048
v 0.193348 2.981250 -0.263232
v 0.193348 2.981250 0.263232
v 0.194472 2.923200 -0.194472
v 0.194472 2.923200 0.194472
v 0.194600 3.141450 0.000000
v 0.194600 3.141450 -0.000000
v 0.195658 2.863350 -0.101925
v 0.195658 2.863350 0.101925
v 0.197424 2.700000 0.032816
v 0.197424 2.700000 -0.032816
v 0.197424 2.700000 -0.032816
v 0.197424 2.700000 0.032816
v 0.197684 2.474400 -1.189282
v 0.197684 2.474400 1.189282
v 0.198374 2.659200 -0.198374
v 0.198374 2.659200 0.198374
v 0.200000 2.700000 -0.000000
v 0.200000 2.700000 0.000000
v 0.200000 2.700000 0.000000
v 0.200000 2.700000 -0.000000
v 0.208794 2.863350 0.070270
v 0.208794 2.863350 -0.070270
v 0.209136 2.440800 -1.258183
v 0.209136 2.440800 1.258183
v 0.210740 0.046875 -1.267832
v 0.210740 0.046875 1.267832
v 0.213123 3.081150 -0.290138
v 0.213123 3.081150 0.290138
v 0.213234 3.034800 -0.290295
v 0.213234 3.034800 0.290295
v 0.213304 2.400000 -1.283256
v 0.213304 2.400000 1.283256
v 0.214905 2.572800 -0.639758
v 0.214905 2.572800 0.639758
v 0.216979 2.863350 0.036157
v 0.216979 2.863350 -0.036157
v 0.219536 3.117600 -0.219536
v 0.219536 3.117600 0.219536
v 0.219800 2.863350 -0.000000
v 0.219800 2.863350 0.000000
v 0.221585 2.923200 -0.162745
v 0.221585 2.923200 0.162745
v 0.224349 0.008400 0.667871
v 0.224349 0.008400 -0.667871
v 0.226113 2.659200 -0.165941
v 0.226113 2.659200 0.165941
v 0.226496 2.463000 -1.362620
v 0.226496 2.463000 1.362620
v 0.226795 2.482687 1.364422
v 0.226795 2.482687 -1.364422
v 0.226824 0.064800 1.364595
v 0.226824 0.064800 -1.364595
v 0.227403 2.435437 -1.368074
v 0.227403 2.435437 1.368074
v 0.228104 2.494500 -1.372294
v 0.228104 2.494500 1.372294
v 0.229712 2.400000 -1.381968
v 0.229712 2.400000 1.381968
v 0.230225 2.498438 -1.385053
v 0.230225 2.498438 1.385053
v 0.230604 0.002175 -0.314223
v 0.230604 0.002175 0.314223
v 0.231031 2.981250 -0.231031
v 0.231031 2.981250 0.231031
v 0.232342 2.625600 -0.316590
v 0.232342 2.625600 0.316590
v 0.232961 2.494500 -1.401513
v 0.232961 2.494500 1.401513
v 0.236115 2.482687 -1.420490
v 0.236115 2.482687 1.420490
v 0.237149 0.084525 1.426709
v 0.237149 0.084525 -1.426709
v 0.239491 2.463000 -1.440800
v 0.239491 2.463000 1.440800
v 0.242892 2.435437 -1.461258
v 0.242892 2.435437 1.461258
v 0.242970 0.105600 1.461727
v 0.242970 0.105600 -1.461727
v 0.243424 2.597400 0.467878
v 0.243424 2.597400 -0.467878
v 0.243569 2.923200 -0.126920
v 0.243569 2.923200 0.126920
v 0.245542 0.127575 1.477200
v 0.245542 0.127575 -1.477200
v 0.246120 0.150000 -1.480680
v 0.246120 2.400000 -1.480680
v 0.246120 0.150000 1.480680
v 0.246120 0.150000 1.480680
v 0.246120 2.400000 1.480680
v 0.246120 0.150000 -1.480680
v 0.248417 0.177075 -1.494500
v 0.248417 0.177075 1.494500
v 0.248621 2.659200 0.129351
v 0.248621 2.659200 -0.129351
v 0.250127 3.117600 -0.183734
v 0.250127 3.117600 0.183734
v 0.254652 0.213600 -1.532010
v 0.254652 0.213600 1.532010
v 0.254653 3.081150 -0.254653
v 0.254653 3.081150 0.254653
v 0.254788 3.034800 -0.254788
v 0.254788 3.034800 0.254788
v 0.258385 2.242575 -1.554467
v 0.258385 2.242575 1.554467
v 0.259910 2.923200 -0.087511
v 0.259910 2.923200 0.087511
v 0.263208 2.550000 -0.783552
v 0.263208 2.550000 0.783552
v 0.263232 2.981250 -0.193348
v 0.263232 2.981250 0.193348
v 0.263841 0.260025 1.587289
v 0.263841 0.260025 -1.587289
v 0.265363 2.659200 -0.089140
v 0.265363 2.659200 0.089140
v 0.270092 2.923200 -0.045032
v 0.270092 2.923200 0.045032
v 0.270404 2.085600 -1.626774
v 0.270404 2.085600 1.626774
v 0.273600 2.923200 -0.000000
v 0.273600 2.923200 0.000000
v 0.274928 3.117600 -0.143301
v 0.274928 3.117600 0.143301
v 0.274998 0.316800 -1.654413
v 0.274998 0.316800 1.654413
v 0.275675 0.002175 -0.275675
v 0.275675 0.002175 0.275675
v 0.275801 2.659200 -0.045844
v 0.275801 2.659200 0.045844
v 0.277752 2.625600 -0.277752
v 0.277752 2.625600 0.277752
v 0.279400 2.659200 0.000000
v 0.281930 1.929525 1.696119
v 0.281930 1.929525 -1.696119
v 0.287140 0.384375 -1.727460
v 0.287140 0.384375 1.727460
v 0.289340 2.981250 -0.150793
v 0.289340 2.981250 0.150793
v 0.290138 3.081150 -0.213123
v 0.290138 3.081150 0.213123
v 0.290295 3.034800 -0.213234
v 0.290295 3.034800 0.213234
v 0.292719 1.774800 -1.761022
v 0.292719 1.774800 1.761022
v 0.293360 3.117600 -0.098814
v 0.293360 3.117600 0.098814
v 0.299282 0.463200 -1.800507
v 0.299282 0.463200 1.800507
v 0.302522 1.621875 -1.820003
v 0.302523 1.621875 1.820003
v 0.303862 0.018225 0.904575
v 0.303862 0.018225 -0.904575
v 0.304843 3.117600 -0.050855
v 0.304843 3.117600 0.050855
v 0.308744 2.981250 -0.103976
v 0.308744 2.981250 0.103976
v 0.308800 3.117600 0.000000
v 0.308800 3.117600 -0.000000
v 0.309596 2.527200 -0.921647
v 0.309596 2.527200 0.921647
v 0.310439 0.553725 -1.867631
v 0.310439 0.553725 1.867631
v 0.311096 1.471200 -1.871580
v 0.311096 1.471200 1.871580
v 0.311850 2.572800 -0.599396
v 0.311850 2.572800 0.599396
v 0.312283 2.597400 -0.425519
v 0.312283 2.597400 0.425519
v 0.314223 0.002175 -0.230604
v 0.314223 0.002175 0.230604
v 0.316590 2.625600 -0.232342
v 0.316590 2.625600 0.232342
v 0.318192 1.323225 -1.914272
v 0.318192 1.323225 1.914272
v 0.318907 3.081150 -0.166221
v 0.318907 3.081150 0.166221
v 0.319082 3.034800 -0.166306
v 0.319082 3.034800 0.166306
v 0.319628 0.656400 -1.922910
v 0.319628 0.656400 1.922910
v 0.320834 2.981250 -0.053508
v 0.320834 2.981250 0.053508
v 0.323566 1.178400 -1.946601
v 0.323566 1.178400 1.946601
v 0.325000 2.981250 0.000000
v 0.325000 2.981250 -0.000000
v 0.325553 0.008400 -0.625735
v 0.325553 0.008400 0.625735
v 0.325863 0.771675 -1.960420
v 0.325863 0.771675 1.960420
v 0.326970 1.037175 -1.967083
v 0.326970 1.037175 1.967083
v 0.328160 0.900000 -1.974240
v 0.328160 0.900000 -1.974240
v 0.328160 0.900000 1.974240
v 0.340289 3.081150 -0.114619
v 0.340289 3.081150 0.114619
v 0.340477 3.034800 -0.114676
v 0.340477 3.034800 0.114676
v 0.345503 0.002175 -0.179756
v 0.345503 0.002175 0.179756
v 0.348105 2.625600 -0.181110
v 0.348105 2.625600 0.181110
v 0.351008 2.502600 -1.044926
v 0.351008 2.502600 1.044926
v 0.353610 3.081150 -0.058988
v 0.353610 3.081150 0.058988
v 0.353807 3.034800 -0.059016
v 0.353807 3.034800 0.059016
v 0.358200 3.081150 -0.000000
v 0.358200 3.081150 0.000000
v 0.358400 3.034800 0.000000
v 0.358400 3.034800 0.000000
v 0.364854 0.031200 1.086146
v 0.364854 0.031200 -1.086146
v 0.368768 0.002175 -0.123875
v 0.368768 0.002175 0.123875
v 0.371546 2.625600 -0.124808
v 0.371546 2.625600 0.124808
v 0.373318 2.597400 -0.373318
v 0.373318 2.597400 0.373318
v 0.381942 2.550000 -0.734118
v 0.381942 2.550000 0.734118
v 0.383274 0.002175 -0.063708
v 0.383274 0.002175 0.063708
v 0.384379 2.474400 -1.144271
v 0.384379 2.474400 1.144271
v 0.386161 2.625600 -0.064188
v 0.386161 2.625600 0.064188
v 0.388275 0.002175 0.000000
v 0.388275 0.002175 0.000000
v 0.391200 2.625600 0.000000
v 0.391200 2.625600 0.000000
v 0.400065 2.572800 -0.545131
v 0.400065 2.572800 0.545131
v 0.406648 2.440800 -1.210564
v 0.406648 2.440800 1.210564
v 0.409767 0.046875 1.219848
v 0.409767 0.046875 -1.219848
v 0.414752 2.400000 -1.234688
v 0.414752 2.400000 1.234688
v 0.417645 0.008400 -0.569086
v 0.417645 0.008400 0.569086
v 0.425519 2.597400 0.312283
v 0.425519 2.597400 -0.312283
v 0.440403 2.463000 -1.311049
v 0.440403 2.463000 1.311049
v 0.440935 0.018225 0.847506
v 0.440935 0.018225 -0.847506
v 0.440985 2.482687 -1.312782
v 0.440985 2.482687 1.312782
v 0.441041 0.064800 1.312948
v 0.441041 0.064800 -1.312948
v 0.442166 2.435437 -1.316296
v 0.442166 2.435437 1.316296
v 0.443529 2.494500 -1.320356
v 0.443529 2.494500 1.320356
v 0.446656 2.400000 -1.329664
v 0.446656 2.400000 1.329664
v 0.447653 2.498438 -1.332632
v 0.447653 2.498438 1.332632
v 0.449256 2.527200 -0.863501
v 0.449256 2.527200 0.863501
v 0.452973 2.494500 -1.348469
v 0.452973 2.494500 1.348469
v 0.459107 2.482687 -1.366728
v 0.459107 2.482687 1.366728
v 0.461116 0.084525 1.372712
v 0.461116 0.084525 -1.372712
v 0.465671 2.463000 -1.386270
v 0.465671 2.463000 1.386270
v 0.467878 2.597400 -0.243424
v 0.467878 2.597400 0.243424
v 0.472283 2.435437 -1.405953
v 0.472283 2.435437 1.405953
v 0.472434 0.105600 1.406405
v 0.472434 0.105600 -1.406405
v 0.477435 0.127575 1.421292
v 0.477435 0.127575 -1.421292
v 0.478256 2.572800 -0.478256
v 0.478256 2.572800 0.478256
v 0.478560 0.150000 -1.424640
v 0.478560 2.400000 -1.424640
v 0.478560 0.150000 1.424640
v 0.478560 0.150000 1.424640
v 0.478560 0.150000 -1.424640
v 0.478560 2.400000 1.424640
v 0.483027 0.177075 -1.437937
v 0.483027 0.177075 1.437937
v 0.489984 2.550000 -0.667656
v 0.489984 2.550000 0.667656
v 0.495150 0.213600 -1.474028
v 0.495150 0.213600 1.474028
v 0.499272 0.008400 -0.499272
v 0.499272 0.008400 0.499272
v 0.499384 2.597400 -0.167751
v 0.499384 2.597400 0.167751
v 0.502408 2.242575 -1.495635
v 0.502408 2.242575 1.495635
v 0.509349 2.502600 0.979002
v 0.509349 2.502600 -0.979002
v 0.513016 0.260025 -1.527214
v 0.513016 0.260025 1.527214
v 0.519028 2.597400 0.086273
v 0.519028 2.597400 -0.086273
v 0.525778 2.085600 -1.565204
v 0.525778 2.085600 1.565204
v 0.525800 2.597400 -0.000000
v 0.525800 2.597400 0.000000
v 0.529441 0.031200 -1.017621
v 0.529441 0.031200 1.017621
v 0.534711 0.316800 -1.591798
v 0.534711 0.316800 1.591798
v 0.545131 2.572800 -0.400065
v 0.545131 2.572800 0.400065
v 0.548190 1.929525 -1.631925
v 0.548190 1.929525 1.631925
v 0.557774 2.474400 -1.072079
v 0.557774 2.474400 1.072079
v 0.558320 0.384375 -1.662080
v 0.558320 0.384375 1.662080
v 0.565664 0.018225 0.770779
v 0.565664 0.018225 -0.770779
v 0.569086 0.008400 -0.417645
v 0.569086 0.008400 0.417645
v 0.569167 1.774800 -1.694372
v 0.569167 1.774800 1.694372
v 0.576340 2.527200 -0.785325
v 0.576340 2.527200 0.785325
v 0.581929 0.463200 -1.732362
v 0.581929 0.463200 1.732362
v 0.585750 2.550000 -0.585750
v 0.585750 2.550000 0.585750
v 0.588230 1.621875 -1.751120
v 0.588230 1.621875 1.751120
v 0.590089 2.440800 1.134190
v 0.590089 2.440800 -1.134190
v 0.594614 0.046875 -1.142888
v 0.594614 0.046875 1.142888
v 0.599396 2.572800 -0.311850
v 0.599396 2.572800 0.311850
v 0.601848 2.400000 -1.156792
v 0.601848 2.400000 1.156792
v 0.603624 0.553725 -1.796946
v 0.603624 0.553725 1.796946
v 0.604900 1.471200 -1.800745
v 0.604900 1.471200 1.800745
v 0.618698 1.323225 -1.841822
v 0.618698 1.323225 1.841822
v 0.621490 0.656400 -1.850132
v 0.621490 0.656400 1.850132
v 0.625735 0.008400 0.325553
v 0.625735 0.008400 -0.325553
v 0.629147 1.178400 -1.872927
v 0.629147 1.178400 1.872927
v 0.633613 0.771675 -1.886223
v 0.633613 0.771675 1.886223
v 0.635767 1.037175 -1.892634
v 0.635767 1.037175 1.892634
v 0.638080 0.900000 -1.899520
v 0.638080 0.900000 -1.899520
v 0.638080 0.900000 1.899520
v 0.638080 0.900000 1.899520
v 0.639070 2.463000 -1.228335
v 0.639070 2.463000 1.228335
v 0.639758 2.572800 -0.214905
v 0.639758 2.572800 0.214905
v 0.639915 2.482687 1.229959
v 0.639915 2.482687 -1.229959
v 0.639996 0.064800 -1.230115
v 0.639996 0.064800 1.230115
v 0.641628 2.435437 -1.233252
v 0.641628 2.435437 1.233252
v 0.643607 2.494500 -1.237056
v 0.643607 2.494500 1.237056
v 0.648144 2.400000 -1.245776
v 0.648144 2.400000 1.245776
v 0.649591 2.498438 -1.248557
v 0.649591 2.498438 1.248557
v 0.653431 2.502600 -0.890370
v 0.653431 2.502600 0.890370
v 0.657311 2.494500 -1.263395
v 0.657311 2.494500 1.263395
v 0.664924 2.572800 -0.110524
v 0.664924 2.572800 0.110524
v 0.666211 2.482687 1.280502
v 0.666211 2.482687 -1.280502
v 0.667656 2.550000 -0.489984
v 0.667656 2.550000 0.489984
v 0.667871 0.008400 -0.224349
v 0.667871 0.008400 0.224349
v 0.669128 0.084525 -1.286108
v 0.669128 0.084525 1.286108
v 0.673600 2.572800 0.000000
v 0.673600 2.572800 -0.000000
v 0.675736 2.463000 -1.298810
v 0.675736 2.463000 1.298810
v 0.676222 0.018225 0.676222
v 0.676222 0.018225 -0.676222
v 0.679207 0.031200 -0.925493
v 0.679207 0.031200 0.925493
v 0.685331 2.435437 -1.317252
v 0.685331 2.435437 1.317252
v 0.685551 0.105600 -1.317675
v 0.685551 0.105600 1.317675
v 0.688984 2.527200 -0.688984
v 0.688984 2.527200 0.688984
v 0.692808 0.127575 1.331623
v 0.692808 0.127575 -1.331623
v 0.694143 0.008400 -0.115381
v 0.694143 0.008400 0.115381
v 0.694440 0.150000 1.334760
v 0.694440 0.150000 -1.334760
v 0.694440 2.400000 1.334760
v 0.694440 0.150000 -1.334760
v 0.694440 0.150000 1.334760
v 0.694440 2.400000 -1.334760
v 0.700921 0.177075 1.347218
v 0.700921 0.177075 -1.347218
v 0.703200 0.008400 0.000000
v 0.715555 2.474400 -0.975021
v 0.715555 2.474400 0.975021
v 0.718514 0.213600 1.381032
v 0.718514 0.213600 -1.381032
v 0.729046 2.242575 -1.401276
v 0.729046 2.242575 1.401276
v 0.734118 2.550000 -0.381942
v 0.734118 2.550000 0.381942
v 0.744440 0.260025 1.430863
v 0.744440 0.260025 -1.430863
v 0.757010 2.440800 1.031508
v 0.757010 2.440800 -1.031508
v 0.762816 0.046875 -1.039419
v 0.762816 0.046875 1.039419
v 0.762958 2.085600 -1.466456
v 0.762958 2.085600 1.466456
v 0.770779 0.018225 0.565664
v 0.770779 0.018225 -0.565664
v 0.772096 2.400000 -1.052064
v 0.772096 2.400000 1.052064
v 0.775921 0.316800 -1.491372
v 0.775921 0.316800 1.491372
v 0.781142 2.502600 -0.781142
v 0.781142 2.502600 0.781142
v 0.783552 2.550000 -0.263208
v 0.783552 2.550000 0.263208
v 0.785325 2.527200 -0.576340
v 0.785325 2.527200 0.576340
v 0.795481 1.929525 1.528968
v 0.795481 1.929525 -1.528968
v 0.810180 0.384375 1.557220
v 0.810180 0.384375 -1.557220
v 0.811956 0.031200 0.811956
v 0.811956 0.031200 -0.811956
v 0.814374 2.550000 -0.135366
v 0.814374 2.550000 0.135366
v 0.819847 2.463000 -1.117130
v 0.819847 2.463000 1.117130
v 0.820931 2.482687 1.118607
v 0.820931 2.482687 -1.118607
v 0.821035 0.064800 1.118749
v 0.821035 0.064800 -1.118749
v 0.823129 2.435437 -1.121601
v 0.823129 2.435437 1.121601
v 0.825000 2.550000 0.000000
v 0.825000 2.550000 0.000000
v 0.825668 2.494500 -1.125061
v 0.825668 2.494500 1.125061
v 0.825921 1.774800 1.587475
v 0.825921 1.774800 -1.587475
v 0.831488 2.400000 -1.132992
v 0.831488 2.400000 1.132992
v 0.833344 2.498438 -1.135521
v 0.833344 2.498438 1.135521
v 0.843248 2.494500 -1.149016
v 0.843248 2.494500 1.149016
v 0.844439 0.463200 1.623068
v 0.844439 0.463200 -1.623068
v 0.847506 0.018225 -0.440935
v 0.847506 0.018225 0.440935
v 0.853583 1.621875 -1.640643
v 0.853583 1.621875 1.640643
v 0.854666 2.482687 -1.164574
v 0.854666 2.482687 1.164574
v 0.855408 2.474400 -0.855408
v 0.855408 2.474400 0.855408
v 0.858407 0.084525 -1.169673
v 0.858407 0.084525 1.169673
v 0.863501 2.527200 -0.449256
v 0.863501 2.527200 0.449256
v 0.866886 2.463000 -1.181225
v 0.866886 2.463000 1.181225
v 0.875920 0.553725 -1.683577
v 0.875920 0.553725 1.683577
v 0.877772 1.471200 -1.687137
v 0.877772 1.471200 1.687137
v 0.879195 2.435437 -1.197997
v 0.879195 2.435437 1.197997
v 0.879477 0.105600 -1.198382
v 0.879477 0.105600 1.198382
v 0.888786 0.127575 1.211067
v 0.888786 0.127575 -1.211067
v 0.890370 2.502600 -0.653431
v 0.890370 2.502600 0.653431
v 0.890880 0.150000 -1.213920
v 0.890880 0.150000 1.213920
v 0.890880 2.400000 -1.213920
v 0.890880 0.150000 -1.213920
v 0.890880 0.150000 1.213920
v 0.890880 2.400000 1.213920
v 0.897795 1.323225 -1.725622
v 0.897795 1.323225 1.725622
v 0.899195 0.177075 1.225250
v 0.899195 0.177075 -1.225250
v 0.901846 0.656400 -1.733408
v 0.901846 0.656400 1.733408
v 0.904575 0.018225 0.303862
v 0.904575 0.018225 -0.303862
v 0.904966 2.440800 0.904966
v 0.904966 2.440800 -0.904966
v 0.911906 0.046875 -0.911906
v 0.911906 0.046875 0.911906
v 0.912957 1.178400 -1.754764
v 0.912957 1.178400 1.754764
v 0.919439 0.771675 -1.767222
v 0.919439 0.771675 1.767222
v 0.921647 2.527200 -0.309596
v 0.921647 2.527200 0.309596
v 0.921764 0.213600 1.256003
v 0.921764 0.213600 -1.256003
v 0.922564 1.037175 1.773229
v 0.922564 1.037175 -1.773229
v 0.923000 2.400000 -0.923000
v 0.923000 2.400000 0.923000
v 0.925493 0.031200 0.679207
v 0.925493 0.031200 -0.679207
v 0.925920 0.900000 1.779680
v 0.925920 0.900000 -1.779680
v 0.925920 0.900000 -1.779680
v 0.925920 0.900000 1.779680
v 0.935276 2.242575 -1.274414
v 0.935276 2.242575 1.274414
v 0.940158 0.018225 0.156274
v 0.940158 0.018225 -0.156274
v 0.952425 0.018225 0.000000
v 0.952425 0.018225 0.000000
v 0.955023 0.260025 1.301322
v 0.955023 0.260025 -1.301322
v 0.957901 2.527200 -0.159223
v 0.957901 2.527200 0.159223
v 0.970400 2.527200 0.000000
v 0.970400 2.527200 -0.000000
v 0.975021 2.474400 -0.715555
v 0.975021 2.474400 0.715555
v 0.978780 2.085600 -1.333693
v 0.978780 2.085600 1.333693
v 0.979002 2.502600 0.509349
v 0.979002 2.502600 -0.509349
v 0.980084 2.463000 -0.980084
v 0.980084 2.463000 0.980084
v 0.981380 2.482687 -0.981380
v 0.981380 2.482687 0.981380
v 0.981504 0.064800 0.981504
v 0.981504 0.064800 -0.981504
v 0.984007 2.435437 -0.984007
v 0.984007 2.435437 0.984007
v 0.987042 2.494500 -0.987042
v 0.987042 2.494500 0.987042
v 0.994000 2.400000 -0.994000
v 0.994000 2.400000 0.994000
v 0.995410 0.316800 -1.356353
v 0.995410 0.316800 1.356353
v 0.996219 2.498438 -0.996219
v 0.996219 2.498438 0.996219
v 1.008058 2.494500 -1.008058
v 1.008058 2.494500 1.008058
v 1.017621 0.031200 0.529441
v 1.017621 0.031200 -0.529441
v 1.020503 1.929525 -1.390545
v 1.020503 1.929525 1.390545
v 1.021708 2.482687 -1.021708
v 1.021708 2.482687 1.021708
v 1.026181 0.084525 -1.026181
v 1.026181 0.084525 1.026181
v 1.031508 2.440800 0.757010
v 1.031508 2.440800 -0.757010
v 1.036316 2.463000 -1.036316
v 1.036316 2.463000 1.036316
v 1.039360 0.384375 -1.416240
v 1.039360 0.384375 1.416240
v 1.039419 0.046875 -0.762816
v 1.039419 0.046875 0.762816
v 1.044926 2.502600 -0.351008
v 1.044926 2.502600 0.351008
v 1.051031 2.435437 -1.051031
v 1.051031 2.435437 1.051031
v 1.051368 0.105600 -1.051368
v 1.051368 0.105600 1.051368
v 1.052064 2.400000 -0.772096
v 1.052064 2.400000 0.772096
v 1.059553 1.774800 -1.443756
v 1.059553 1.774800 1.443756
v 1.062497 0.127575 1.062497
v 1.062497 0.127575 -1.062497
v 1.065000 0.150000 -1.065000
v 1.065000 0.150000 1.065000
v 1.065000 2.400000 -1.065000
v 1.065000 2.400000 1.065000
v 1.072079 2.474400 -0.557774
v 1.072079 2.474400 0.557774
v 1.074940 0.177075 -1.074940
v 1.074940 0.177075 1.074940
v 1.083310 0.463200 -1.476127
v 1.083310 0.463200 1.476127
v 1.086029 2.502600 0.180521
v 1.086029 2.502600 -0.180521
v 1.086146 0.031200 0.364854
v 1.086146 0.031200 -0.364854
v 1.095040 1.621875 -1.492110
v 1.095040 1.621875 1.492110
v 1.100200 2.502600 -0.000000
v 1.100200 2.502600 0.000000
v 1.101920 0.213600 1.101920
v 1.101920 0.213600 -1.101920
v 1.117130 2.463000 -0.819847
v 1.117130 2.463000 0.819847
v 1.118073 2.242575 -1.118073
v 1.118073 2.242575 1.118073
v 1.118607 2.482687 -0.820931
v 1.118607 2.482687 0.820931
v 1.118749 0.064800 -0.821035
v 1.118749 0.064800 0.821035
v 1.121601 2.435437 -0.823129
v 1.121601 2.435437 0.823129
v 1.123697 0.553725 -1.531158
v 1.123697 0.553725 1.531158
v 1.125061 2.494500 -0.825668
v 1.125061 2.494500 0.825668
v 1.126072 1.471200 -1.534395
v 1.126072 1.471200 1.534395
v 1.128870 0.031200 -0.187642
v 1.128870 0.031200 0.187642
v 1.132992 2.400000 -0.831488
v 1.132992 2.400000 0.831488
v 1.134190 2.440800 0.590089
v 1.134190 2.440800 -0.590089
v 1.135521 2.498438 -0.833344
v 1.135521 2.498438 0.833344
v 1.141680 0.260025 1.141680
v 1.141680 0.260025 -1.141680
v 1.142888 0.046875 -0.594614
v 1.142888 0.046875 0.594614
v 1.143600 0.031200 0.000000
v 1.143600 0.031200 0.000000
v 1.144271 2.474400 -0.384379
v 1.144271 2.474400 0.384379
v 1.149016 2.494500 -0.843248
v 1.149016 2.494500 0.843248
v 1.151759 1.323225 -1.569396
v 1.151759 1.323225 1.569396
v 1.156792 2.400000 -0.601848
v 1.156792 2.400000 0.601848
v 1.156956 0.656400 -1.576477
v 1.156956 0.656400 1.576477
v 1.164574 2.482687 -0.854666
v 1.164574 2.482687 0.854666
v 1.169673 0.084525 -0.858407
v 1.169673 0.084525 0.858407
v 1.170080 2.085600 -1.170080
v 1.170080 2.085600 1.170080
v 1.171210 1.178400 -1.595900
v 1.171210 1.178400 1.595900
v 1.179525 0.771675 -1.607230
v 1.179525 0.771675 1.607230
v 1.181225 2.463000 -0.866886
v 1.181225 2.463000 0.866886
v 1.183534 1.037175 -1.612693
v 1.183534 1.037175 1.612693
v 1.187840 0.900000 -1.618560
v 1.187840 0.900000 -1.618560
v 1.187840 0.900000 1.618560
v 1.187840 0.900000 1.618560
v 1.189282 2.474400 -0.197684
v 1.189282 2.474400 0.197684
v 1.189960 0.316800 -1.189960
v 1.189960 0.316800 1.189960
v 1.197997 2.435437 -0.879195
v 1.197997 2.435437 0.879195
v 1.198382 0.105600 -0.879477
v 1.198382 0.105600 0.879477
v 1.204800 2.474400 0.000000
v 1.204800 2.474400 -0.000000
v 1.210564 2.440800 0.406648
v 1.210564 2.440800 -0.406648
v 1.211067 0.127575 0.888786
v 1.211067 0.127575 -0.888786
v 1.213920 0.150000 -0.890880
v 1.213920 0.150000 -0.890880
v 1.213920 0.150000 0.890880
v 1.213920 0.150000 0.890880
v 1.213920 2.400000 -0.890880
v 1.213920 2.400000 0.890880
v 1.219848 0.046875 -0.409767
v 1.219848 0.046875 0.409767
v 1.219958 1.929525 1.219958
v 1.219958 1.929525 -1.219958
v 1.225250 0.177075 0.899195
v 1.225250 0.177075 -0.899195
v 1.228335 2.463000 -0.639070
v 1.228335 2.463000 0.639070
v 1.229959 2.482687 -0.639915
v 1.229959 2.482687 0.639915
v 1.230115 0.064800 -0.639996
v 1.230115 0.064800 0.639996
v 1.233252 2.435437 -0.641628
v 1.233252 2.435437 0.641628
v 1.234688 2.400000 -0.414752
v 1.234688 2.400000 0.414752
v 1.237056 2.494500 -0.643607
v 1.237056 2.494500 0.643607
v 1.242500 0.384375 -1.242500
v 1.242500 0.384375 1.242500
v 1.245776 2.400000 -0.648144
v 1.245776 2.400000 0.648144
v 1.248557 2.498438 -0.649591
v 1.248557 2.498438 0.649591
v 1.256003 0.213600 0.921764
v 1.256003 0.213600 -0.921764
v 1.258183 2.440800 0.209136
v 1.258183 2.440800 -0.209136
v 1.263395 2.494500 -0.657311
v 1.263395 2.494500 0.657311
v 1.266640 1.774800 -1.266640
v 1.266640 1.774800 1.266640
v 1.267832 0.046875 -0.210740
v 1.267832 0.046875 0.210740
v 1.274414 2.242575 -0.935276
v 1.274414 2.242575 0.935276
v 1.274600 2.440800 0.000000
v 1.274600 2.440800 0.000000
v 1.280502 2.482687 -0.666211
v 1.280502 2.482687 0.666211
v 1.283256 2.400000 -0.213304
v 1.283256 2.400000 0.213304
v 1.284375 0.046875 0.000000
v 1.284375 0.046875 -0.000000
v 1.286108 0.084525 -0.669128
v 1.286108 0.084525 0.669128
v 1.295040 0.463200 -1.295040
v 1.295040 0.463200 1.295040
v 1.298810 2.463000 -0.675736
v 1.298810 2.463000 0.675736
v 1.300000 2.400000 0.000000
v 1.300000 2.400000 -0.000000
v 1.301322 0.260025 0.955023
v 1.301322 0.260025 -0.955023
v 1.309063 1.621875 -1.309063
v 1.309063 1.621875 1.309063
v 1.311049 2.463000 -0.440403
v 1.311049 2.463000 0.440403
v 1.312782 2.482687 -0.440985
v 1.312782 2.482687 0.440985
v 1.312948 0.064800 0.441041
v 1.312948 0.064800 -0.441041
v 1.316296 2.435437 -0.442166
v 1.316296 2.435437 0.442166
v 1.317252 2.435437 -0.685331
v 1.317252 2.435437 0.685331
v 1.317675 0.105600 -0.685551
v 1.317675 0.105600 0.685551
v 1.320356 2.494500 -0.443529
v 1.320356 2.494500 0.443529
v 1.329664 2.400000 -0.446656
v 1.329664 2.400000 0.446656
v 1.331623 0.127575 0.692808
v 1.331623 0.127575 -0.692808
v 1.332632 2.498438 -0.447653
v 1.332632 2.498438 0.447653
v 1.333693 2.085600 -0.978780
v 1.333693 2.085600 0.978780
v 1.334760 0.150000 0.694440
v 1.334760 0.150000 -0.694440
v 1.334760 0.150000 -0.694440
v 1.334760 0.150000 0.694440
v 1.334760 2.400000 -0.694440
v 1.334760 2.400000 0.694440
v 1.343320 0.553725 -1.343320
v 1.343320 0.553725 1.343320
v 1.346160 1.471200 -1.346160
v 1.346160 1.471200 1.346160
v 1.347218 0.177075 0.700921
v 1.347218 0.177075 -0.700921
v 1.348469 2.494500 -0.452973
v 1.348469 2.494500 0.452973
v 1.356353 0.316800 -0.995410
v 1.356353 0.316800 0.995410
v 1.362620 2.463000 -0.226496
v 1.362620 2.463000 0.226496
v 1.364422 2.482687 -0.226795
v 1.364422 2.482687 0.226795
v 1.364595 0.064800 -0.226824
v 1.364595 0.064800 0.226824
v 1.366728 2.482687 -0.459107
v 1.366728 2.482687 0.459107
v 1.368074 2.435437 -0.227403
v 1.368074 2.435437 0.227403
v 1.372294 2.494500 -0.228104
v 1.372294 2.494500 0.228104
v 1.372712 0.084525 -0.461116
v 1.372712 0.084525 0.461116
v 1.376867 1.323225 -1.376868
v 1.376868 1.323225 1.376867
v 1.380400 2.463000 0.000000
v 1.380400 2.463000 -0.000000
v 1.381032 0.213600 0.718514
v 1.381032 0.213600 -0.718514
v 1.381968 2.400000 -0.229712
v 1.381968 2.400000 0.229712
v 1.382225 2.482687 0.000000
v 1.382225 2.482687 0.000000
v 1.382400 0.064800 0.000000
v 1.382400 0.064800 0.000000
v 1.383080 0.656400 -1.383080
v 1.383080 0.656400 1.383080
v 1.385053 2.498438 -0.230225
v 1.385053 2.498438 0.230225
v 1.385925 2.435437 0.000000
v 1.385925 2.435437 -0.000000
v 1.386270 2.463000 -0.465671
v 1.386270 2.463000 0.465671
v 1.390200 2.494500 0.000000
v 1.390200 2.494500 -0.000000
v 1.390545 1.929525 -1.020503
v 1.390545 1.929525 1.020503
v 1.400000 2.400000 0.000000
v 1.400000 2.400000 0.000000
v 1.400120 1.178400 -1.400120
v 1.400120 1.178400 1.400120
v 1.401276 2.242575 -0.729046
v 1.401276 2.242575 0.729046
v 1.401513 2.494500 -0.232961
v 1.401513 2.494500 0.232961
v 1.403125 2.498438 0.000000
v 1.403125 2.498438 0.000000
v 1.405953 2.435437 -0.472283
v 1.405953 2.435437 0.472283
v 1.406405 0.105600 -0.472434
v 1.406405 0.105600 0.472434
v 1.410060 0.771675 -1.410060
v 1.410060 0.771675 1.410060
v 1.414853 1.037175 -1.414853
v 1.414853 1.037175 1.414853
v 1.416240 0.384375 -1.039360
v 1.416240 0.384375 1.039360
v 1.419800 2.494500 0.000000
v 1.419800 2.494500 -0.000000
v 1.420000 0.900000 -1.420000
v 1.420000 0.900000 -1.420000
v 1.420000 0.900000 1.420000
v 1.420000 0.900000 1.420000
v 1.420490 2.482687 -0.236115
v 1.420490 2.482687 0.236115
v 1.421292 0.127575 0.477435
v 1.421292 0.127575 -0.477435
v 1.424640 0.150000 -0.478560
v 1.424640 0.150000 -0.478560
v 1.424640 0.150000 0.478560
v 1.424640 0.150000 0.478560
v 1.424640 2.400000 -0.478560
v 1.424640 2.400000 0.478560
v 1.426709 0.084525 -0.237149
v 1.426709 0.084525 0.237149
v 1.430863 0.260025 0.744440
v 1.430863 0.260025 -0.744440
v 1.437937 0.177075 0.483027
v 1.437937 0.177075 -0.483027
v 1.439025 2.482687 0.000000
v 1.440800 2.463000 -0.239491
v 1.440800 2.463000 0.239491
v 1.443756 1.774800 -1.059553
v 1.443756 1.774800 1.059553
v 1.445325 0.084525 0.000000
v 1.445325 0.084525 0.000000
v 1.459600 2.463000 0.000000
v 1.459600 2.463000 -0.000000
v 1.461258 2.435437 -0.242892
v 1.461258 2.435437 0.242892
v 1.461727 0.105600 -0.242970
v 1.461727 0.105600 0.242970
v 1.466456 2.085600 -0.762958
v 1.466456 2.085600 0.762958
v 1.474028 0.213600 0.495150
v 1.474028 0.213600 -0.495150
v 1.476127 0.463200 -1.083310
v 1.476127 0.463200 1.083310
v 1.477200 0.127575 0.245542
v 1.477200 0.127575 -0.245542
v 1.480325 2.435437 0.000000
v 1.480325 2.435437 -0.000000
v 1.480680 0.150000 -0.246120
v 1.480680 0.150000 0.246120
v 1.480680 0.150000 0.246120
v 1.480680 0.150000 -0.246120
v 1.480680 2.400000 -0.246120
v 1.480680 2.400000 0.246120
v 1.480800 0.105600 0.000000
v 1.480800 0.105600 0.000000
v 1.491372 0.316800 -0.775921
v 1.491372 0.316800 0.775921
v 1.492110 1.621875 -1.095040
v 1.492110 1.621875 1.095040
v 1.494500 0.177075 0.248417
v 1.494500 0.177075 -0.248417
v 1.495635 2.242575 -0.502408
v 1.495635 2.242575 0.502408
v 1.496475 0.127575 0.000000
v 1.496475 0.127575 0.000000
v 1.500000 0.150000 0.000000
v 1.500000 0.150000 0.000000
v 1.500000 2.400000 0.000000
v 1.500000 2.400000 0.000000
v 1.514000 0.177075 -0.000000
v 1.514000 0.177075 0.000000
v 1.527214 0.260025 -0.513016
v 1.527214 0.260025 0.513016
v 1.528968 1.929525 -0.795481
v 1.528968 1.929525 0.795481
v 1.531158 0.553725 -1.123697
v 1.531158 0.553725 1.123697
v 1.532010 0.213600 0.254652
v 1.532010 0.213600 -0.254652
v 1.534395 1.471200 -1.126072
v 1.534395 1.471200 1.126072
v 1.552000 0.213600 0.000000
v 1.552000 0.213600 0.000000
v 1.554467 2.242575 -0.258385
v 1.554467 2.242575 0.258385
v 1.557220 0.384375 -0.810180
v 1.557220 0.384375 0.810180
v 1.565204 2.085600 -0.525778
v 1.565204 2.085600 0.525778
v 1.569396 1.323225 -1.151759
v 1.569396 1.323225 1.151759
v 1.574750 2.242575 0.000000
v 1.574750 2.242575 0.000000
v 1.576477 0.656400 -1.156956
v 1.576477 0.656400 1.156956
v 1.587289 0.260025 0.263841
v 1.587289 0.260025 -0.263841
v 1.587475 1.774800 -0.825921
v 1.587475 1.774800 0.825921
v 1.591798 0.316800 -0.534711
v 1.591798 0.316800 0.534711
v 1.595900 1.178400 -1.171210
v 1.595900 1.178400 1.171210
v 1.607230 0.771675 -1.179525
v 1.607230 0.771675 1.179525
v 1.608000 0.260025 0.000000
v 1.608000 0.260025 0.000000
v 1.612693 1.037175 -1.183534
v 1.612693 1.037175 1.183534
v 1.618560 0.900000 -1.187840
v 1.618560 0.900000 -1.187840
v 1.618560 0.900000 1.187840
v 1.618560 0.900000 1.187840
v 1.623068 0.463200 -0.844439
v 1.623068 0.463200 0.844439
v 1.626774 2.085600 -0.270404
v 1.626774 2.085600 0.270404
v 1.631925 1.929525 -0.548190
v 1.631925 1.929525 0.548190
v 1.640643 1.621875 -0.853583
v 1.640643 1.621875 0.853583
v 1.648000 2.085600 0.000000
v 1.648000 2.085600 -0.000000
v 1.654413 0.316800 -0.274998
v 1.654413 0.316800 0.274998
v 1.662080 0.384375 -0.558320
v 1.662080 0.384375 0.558320
v 1.676000 0.316800 0.000000
v 1.676000 0.316800 0.000000
v 1.683577 0.553725 -0.875920
v 1.683577 0.553725 0.875920
v 1.687137 1.471200 -0.877772
v 1.687137 1.471200 0.877772
v 1.694372 1.774800 -0.569167
v 1.694372 1.774800 0.569167
v 1.696119 1.929525 -0.281930
v 1.696119 1.929525 0.281930
v 1.700000 0.600000 0.000000
v 1.700000 0.600000 0.000000
v 1.700000 0.623100 0.178200
v 1.700000 0.623100 -0.178200
v 1.700000 0.685800 -0.316800
v 1.700000 0.685800 0.316800
v 1.700000 0.778200 0.415800
v 1.700000 0.778200 -0.415800
v 1.700000 0.890400 -0.475200
v 1.700000 0.890400 0.475200
v 1.700000 1.012500 -0.495000
v 1.700000 1.012500 0.495000
v 1.700000 1.134600 -0.475200
v 1.700000 1.134600 0.475200
v 1.700000 1.246800 0.415800
v 1.700000 1.246800 -0.415800
v 1.700000 1.339200 -0.316800
v 1.700000 1.339200 0.316800
v 1.700000 1.401900 0.178200
v 1.700000 1.401900 -0.178200
v 1.700000 1.425000 0.000000
v 1.700000 1.425000 0.000000
v 1.718250 1.929525 0.000000
v 1.718250 1.929525 0.000000
v 1.725622 1.323225 -0.897795
v 1.725622 1.323225 0.897795
v 1.727460 0.384375 -0.287140
v 1.727460 0.384375 0.287140
v 1.732362 0.463200 -0.581929
v 1.732362 0.463200 0.581929
v 1.733408 0.656400 -0.901846
v 1.733408 0.656400 0.901846
v 1.750000 0.384375 0.000000
v 1.750000 0.384375 0.000000
v 1.751120 1.621875 -0.588230
v 1.751120 1.621875 0.588230
v 1.754764 1.178400 -0.912957
v 1.754764 1.178400 0.912957
v 1.761022 1.774800 -0.292719
v 1.761022 1.774800 0.292719
v 1.767222 0.771675 -0.919439
v 1.767222 0.771675 0.919439
v 1.773229 1.037175 -0.922564
v 1.773229 1.037175 0.922564
v 1.779680 0.900000 -0.925920
v 1.779680 0.900000 -0.925920
v 1.779680 0.900000 0.925920
v 1.779680 0.900000 0.925920
v 1.784000 1.774800 0.000000
v 1.784000 1.774800 0.000000
v 1.796946 0.553725 -0.603624
v 1.796946 0.553725 0.603624
v 1.800507 0.463200 -0.299282
v 1.800507 0.463200 0.299282
v 1.800745 1.471200 -0.604900
v 1.800745 1.471200 0.604900
v 1.820003 1.621875 -0.302523
v 1.820003 1.621875 0.302522
v 1.824000 0.463200 0.000000
v 1.824000 0.463200 0.000000
v 1.841822 1.323225 -0.618698
v 1.841822 1.323225 0.618698
v 1.843750 1.621875 0.000000
v 1.843750 1.621875 -0.000000
v 1.850132 0.656400 -0.621490
v 1.850132 0.656400 0.621490
v 1.867631 0.553725 -0.310439
v 1.867631 0.553725 0.310439
v 1.871580 1.471200 -0.311096
v 1.871580 1.471200 0.311096
v 1.872927 1.178400 -0.629147
v 1.872927 1.178400 0.629147
v 1.886223 0.771675 -0.633613
v 1.886223 0.771675 0.633613
v 1.892000 0.553725 0.000000
v 1.892000 0.553725 -0.000000
v 1.892634 1.037175 -0.635767
v 1.892634 1.037175 0.635767
v 1.896000 1.471200 0.000000
v 1.896000 1.471200 0.000000
v 1.899520 0.900000 -0.638080
v 1.899520 0.900000 -0.638080
v 1.899520 0.900000 0.638080
v 1.899520 0.900000 0.638080
v 1.914272 1.323225 -0.318192
v 1.914272 1.323225 0.318192
v 1.922910 0.656400 -0.319628
v 1.922910 0.656400 0.319628
v 1.935900 1.444200 0.000000
v 1.935900 1.444200 0.000000
v 1.939250 1.323225 0.000000
v 1.939250 1.323225 -0.000000
v 1.939394 1.423221 -0.175100
v 1.939394 1.423221 0.175100
v 1.946601 1.178400 -0.323566
v 1.946601 1.178400 0.323566
v 1.948000 0.656400 0.000000
v 1.948000 0.656400 -0.000000
v 1.948879 1.366278 -0.311290
v 1.948879 1.366278 0.311290
v 1.960420 0.771675 -0.325863
v 1.960420 0.771675 0.325863
v 1.962857 1.282362 -0.408568
v 1.962857 1.282362 0.408568
v 1.967083 1.037175 -0.326970
v 1.967083 1.037175 0.326970
v 1.972000 1.178400 0.000000
v 1.972000 1.178400 0.000000
v 1.974240 0.900000 -0.328160
v 1.974240 0.900000 0.328160
v 1.974240 0.900000 0.328160
v 1.979830 1.180464 -0.466934
v 1.979830 1.180464 0.466934
v 1.986000 0.771675 0.000000
v 1.986000 0.771675 -0.000000
v 1.992750 1.037175 0.000000
v 1.992750 1.037175 0.000000
v 1.998300 1.069575 -0.486390
v 1.998300 1.069575 0.486390
v 2.000000 0.900000 0.000000
v 2.000000 0.900000 0.000000
v 2.016770 0.958686 -0.466934
v 2.016770 0.958686 0.466934
v 2.033743 0.856788 -0.408568
v 2.033743 0.856788 0.408568
v 2.047721 0.772872 0.311290
v 2.047721 0.772872 -0.311290
v 2.057206 0.715929 0.175100
v 2.057206 0.715929 -0.175100
v 2.060700 0.694950 0.000000
v 2.060700 0.694950 0.000000
v 2.111200 1.497600 0.000000
v 2.111200 1.497600 0.000000
v 2.116979 1.479120 -0.166687
v 2.116979 1.479120 0.166687
v 2.132666 1.428960 -0.296333
v 2.132666 1.428960 0.296333
v 2.155782 1.355040 -0.388937
v 2.155782 1.355040 0.388937
v 2.183853 1.265280 -0.444499
v 2.183853 1.265280 0.444499
v 2.214400 1.167600 -0.463020
v 2.214400 1.167600 0.463020
v 2.237300 1.578900 0.000000
v 2.237300 1.578900 0.000000
v 2.244457 1.563171 -0.154289
v 2.244457 1.563171 0.154289
v 2.244947 1.069920 -0.444499
v 2.244947 1.069920 0.444499
v 2.263882 1.520478 -0.274291
v 2.263882 1.520478 0.274291
v 2.273018 0.980160 -0.388937
v 2.273018 0.980160 0.388937
v 2.292510 1.457562 -0.360007
v 2.292510 1.457562 0.360007
v 2.296134 0.906240 -0.296333
v 2.296134 0.906240 0.296333
v 2.311821 0.856080 -0.166687
v 2.311821 0.856080 0.166687
v 2.317600 0.837600 0.000000
v 2.317600 0.837600 0.000000
v 2.325600 1.681800 0.000000
v 2.325600 1.681800 0.000000
v 2.327271 1.381164 -0.411437
v 2.327271 1.381164 0.411437
v 2.333530 1.668948 -0.139234
v 2.333530 1.668948 0.139234
v 2.355053 1.634064 -0.247526
v 2.355053 1.634064 0.247526
v 2.365100 1.298025 -0.428580
v 2.365100 1.298025 0.428580
v 2.386771 1.582656 -0.324878
v 2.386771 1.582656 0.324878
v 2.387500 1.800000 0.000000
v 2.387500 1.800000 0.000000
v 2.395900 1.790025 0.122850
v 2.395900 1.790025 -0.122850
v 2.402929 1.214886 -0.411437
v 2.402929 1.214886 0.411437
v 2.418700 1.762950 -0.218400
v 2.418700 1.762950 0.218400
v 2.425286 1.520232 -0.371290
v 2.425286 1.520232 0.371290
v 2.434400 1.927200 0.000000
v 2.434400 1.927200 0.000000
v 2.437690 1.138488 -0.360007
v 2.437690 1.138488 0.360007
v 2.443270 1.919976 0.106466
v 2.443270 1.919976 -0.106466
v 2.452300 1.723050 -0.286650
v 2.452300 1.723050 0.286650
v 2.466318 1.075572 -0.274291
v 2.466318 1.075572 0.274291
v 2.467200 1.452300 -0.386760
v 2.467200 1.452300 0.386760
v 2.467347 1.900368 0.189274
v 2.467347 1.900368 -0.189274
v 2.477700 2.057100 0.000000
v 2.477700 2.057100 0.000000
v 2.485743 1.032879 -0.154289
v 2.485743 1.032879 0.154289
v 2.487343 2.052375 -0.091411
v 2.487343 2.052375 0.091411
v 2.492900 1.017150 0.000000
v 2.492900 1.017150 0.000000
v 2.493100 1.674600 -0.327600
v 2.493100 1.674600 0.327600
v 2.502829 1.871472 0.248422
v 2.502829 1.871472 -0.248422
v 2.509114 1.384368 -0.371290
v 2.509114 1.384368 0.371290
v 2.513518 2.039550 0.162509
v 2.513518 2.039550 -0.162509
v 2.528800 2.183400 0.000000
v 2.537500 1.621875 -0.341250
v 2.537500 1.621875 0.341250
v 2.539821 2.180796 -0.079013
v 2.539821 2.180796 0.079013
v 2.545914 1.836384 -0.283910
v 2.545914 1.836384 0.283910
v 2.547629 1.321944 -0.324878
v 2.547629 1.321944 0.324878
v 2.552090 2.020650 -0.213293
v 2.552090 2.020650 0.213293
v 2.569734 2.173728 -0.140467
v 2.569734 2.173728 0.140467
v 2.579347 1.270536 -0.247526
v 2.579347 1.270536 0.247526
v 2.581900 1.569150 -0.327600
v 2.581900 1.569150 0.327600
v 2.592800 1.798200 -0.295740
v 2.592800 1.798200 0.295740
v 2.598929 1.997700 -0.243763
v 2.598929 1.997700 0.243763
v 2.599100 2.299800 0.000000
v 2.599100 2.299800 0.000000
v 2.600870 1.235652 -0.139234
v 2.600870 1.235652 0.139234
v 2.608800 1.222800 0.000000
v 2.608800 1.222800 0.000000
v 2.612406 2.298813 0.070600
v 2.612406 2.298813 -0.070600
v 2.613818 2.163312 -0.184363
v 2.613818 2.163312 0.184363
v 2.622700 1.520700 -0.286650
v 2.622700 1.520700 0.286650
v 2.639686 1.760016 -0.283910
v 2.639686 1.760016 0.283910
v 2.648521 2.296134 0.125510
v 2.648521 2.296134 -0.125510
v 2.649900 1.972725 0.253920
v 2.649900 1.972725 -0.253920
v 2.656300 1.480800 -0.218400
v 2.656300 1.480800 0.218400
v 2.667347 2.150664 -0.210701
v 2.667347 2.150664 0.210701
v 2.679100 1.453725 0.122850
v 2.679100 1.453725 -0.122850
v 2.682771 1.724928 0.248422
v 2.682771 1.724928 -0.248422
v 2.687500 1.443750 0.000000
v 2.687500 1.443750 0.000000
v 2.700000 2.400000 0.000000
v 2.700000 2.400000 0.000000
v 2.700000 2.400000 0.000000
v 2.700871 1.947750 -0.243763
v 2.700871 1.947750 0.243763
v 2.701743 2.292186 0.164732
v 2.701743 2.292186 -0.164732
v 2.716800 2.400000 0.067500
v 2.716800 2.400000 -0.067500
v 2.716800 2.400000 -0.067500
v 2.716800 2.400000 0.067500
v 2.718253 1.696032 0.189274
v 2.718253 1.696032 -0.189274
v 2.725600 2.136900 -0.219480
v 2.725600 2.136900 0.219480
v 2.729800 2.420250 0.000000
v 2.742330 1.676424 0.106466
v 2.742330 1.676424 -0.106466
v 2.747407 2.420406 -0.066744
v 2.747407 2.420406 0.066744
v 2.747710 1.924800 -0.213293
v 2.747710 1.924800 0.213293
v 2.751200 1.669200 0.000000
v 2.751200 1.669200 0.000000
v 2.758400 2.436000 0.000000
v 2.762400 2.400000 0.120000
v 2.762400 2.400000 -0.120000
v 2.762400 2.400000 -0.120000
v 2.762400 2.400000 0.120000
v 2.766370 2.287392 0.188266
v 2.766370 2.287392 -0.188266
v 2.776365 2.436302 -0.064692
v 2.776365 2.436302 0.064692
v 2.783853 2.123136 -0.210701
v 2.783853 2.123136 0.210701
v 2.784600 2.447250 0.000000
v 2.784600 2.447250 0.000000
v 2.786282 1.905900 0.162509
v 2.786282 1.905900 -0.162509
v 2.795198 2.420829 -0.118656
v 2.795198 2.420829 0.118656
v 2.800000 2.400000 0.000000
v 2.802528 2.447680 -0.061668
v 2.802528 2.447680 0.061668
v 2.807200 2.454000 0.000000
v 2.811200 2.400000 -0.040500
v 2.811200 2.400000 0.040500
v 2.812457 1.893075 0.091411
v 2.812457 1.893075 -0.091411
v 2.822100 1.888350 0.000000
v 2.822100 1.888350 0.000000
v 2.824200 2.420250 0.000000
v 2.824200 2.420250 0.000000
v 2.824750 2.454529 -0.057996
v 2.824750 2.454529 0.057996
v 2.825000 2.456250 0.000000
v 2.825000 2.456250 0.000000
v 2.825126 2.437123 -0.115008
v 2.825126 2.437123 0.115008
v 2.829600 2.400000 0.157500
v 2.829600 2.400000 -0.157500
v 2.829600 2.400000 -0.157500
v 2.829600 2.400000 0.157500
v 2.836672 2.420519 -0.041256
v 2.836672 2.420519 0.041256
v 2.836700 2.282175 0.196110
v 2.836700 2.282175 -0.196110
v 2.836800 2.454000 0.000000
v 2.836800 2.454000 0.000000
v 2.837382 2.110488 -0.184363
v 2.837382 2.110488 0.184363
v 2.837600 2.436000 0.000000
v 2.837600 2.436000 0.000000
v 2.841400 2.447250 0.000000
v 2.841400 2.447250 0.000000
v 2.841600 2.400000 -0.072000
v 2.841600 2.400000 0.072000
v 2.841887 2.456841 -0.054000
v 2.841887 2.456841 0.054000
v 2.851189 2.448847 -0.109632
v 2.851189 2.448847 0.109632
v 2.851331 2.436454 -0.043308
v 2.851331 2.436454 0.043308
v 2.852794 2.454605 -0.050004
v 2.852794 2.454605 0.050004
v 2.856323 2.447812 -0.046332
v 2.856323 2.447812 0.046332
v 2.865626 2.421453 -0.155736
v 2.865626 2.421453 0.155736
v 2.870524 2.421250 -0.073344
v 2.870524 2.421250 0.073344
v 2.872387 2.455966 -0.103104
v 2.872387 2.455966 0.103104
v 2.881466 2.100072 -0.140467
v 2.881466 2.100072 0.140467
v 2.886400 2.400000 -0.094500
v 2.886400 2.400000 0.094500
v 2.887725 2.458444 -0.096000
v 2.887725 2.458444 0.096000
v 2.888602 2.437685 -0.076992
v 2.888602 2.437685 0.076992
v 2.896205 2.456246 0.088896
v 2.896205 2.456246 -0.088896
v 2.896829 2.449338 -0.082368
v 2.896829 2.449338 0.082368
v 2.896986 2.438333 -0.150948
v 2.896986 2.438333 0.150948
v 2.907030 2.276958 0.188266
v 2.907030 2.276958 -0.188266
v 2.911200 2.400000 -0.180000
v 2.911200 2.400000 -0.180000
v 2.911200 2.400000 0.180000
v 2.911379 2.093004 -0.079013
v 2.911379 2.093004 0.079013
v 2.920412 2.422328 -0.096264
v 2.920412 2.422328 0.096264
v 2.922400 2.090400 0.000000
v 2.922899 2.450567 -0.143892
v 2.922899 2.450567 0.143892
v 2.940800 2.400000 -0.108000
v 2.940800 2.400000 0.108000
v 2.942589 2.458082 -0.135324
v 2.942589 2.458082 0.135324
v 2.943526 2.439499 -0.101052
v 2.943526 2.439499 0.101052
v 2.951146 2.422210 -0.177984
v 2.951146 2.422210 0.177984
v 2.955275 2.460806 -0.126000
v 2.955275 2.460806 0.126000
v 2.956523 2.451588 -0.108108
v 2.956523 2.451588 0.108108
v 2.960179 2.458666 -0.116676
v 2.960179 2.458666 0.116676
v 2.971657 2.272164 0.164732
v 2.971657 2.272164 -0.164732
v 2.980990 2.423636 0.110016
v 2.980990 2.423636 -0.110016
v 2.984243 2.439802 -0.172512
v 2.984243 2.439802 0.172512
v 3.000000 2.400000 -0.187500
v 3.000000 2.400000 -0.187500
v 3.000000 2.400000 -0.112500
v 3.000000 2.400000 0.112500
v 3.000000 2.400000 0.187500
v 3.009977 2.452655 -0.164448
v 3.009977 2.452655 0.164448
v 3.010221 2.441702 -0.115488
v 3.010221 2.441702 0.115488
v 3.024879 2.268216 0.125510
v 3.024879 2.268216 -0.125510
v 3.027834 2.460653 -0.154656
v 3.027834 2.460653 0.154656
v 3.029007 2.454319 -0.123552
v 3.029007 2.454319 0.123552
v 3.037300 2.463675 -0.144000
v 3.037300 2.463675 0.144000
v 3.037862 2.461603 0.133344
v 3.037862 2.461603 -0.133344
v 3.044212 2.423034 -0.185400
v 3.044212 2.423034 0.185400
v 3.046912 2.425059 0.114600
v 3.046912 2.425059 -0.114600
v 3.059200 2.400000 -0.108000
v 3.059200 2.400000 0.108000
v 3.060994 2.265537 0.070600
v 3.060994 2.265537 -0.070600
v 3.074300 2.264550 0.000000
v 3.074300 2.264550 0.000000
v 3.079200 2.441400 -0.179700
v 3.079200 2.441400 0.179700
v 3.082800 2.444100 -0.120300
v 3.082800 2.444100 0.120300
v 3.088800 2.400000 -0.180000
v 3.088800 2.400000 -0.180000
v 3.088800 2.400000 0.180000
v 3.104737 2.454928 -0.171300
v 3.104738 2.454928 0.171300
v 3.107887 2.457291 -0.128700
v 3.107887 2.457291 0.128700
v 3.112835 2.426483 0.110016
v 3.112835 2.426483 -0.110016
v 3.113600 2.400000 -0.094500
v 3.113600 2.400000 0.094500
v 3.120600 2.463450 0.161100
v 3.120600 2.463450 -0.161100
v 3.122400 2.464800 0.138900
v 3.122400 2.464800 -0.138900
v 3.126562 2.466797 -0.150000
v 3.126562 2.466797 0.150000
v 3.137279 2.423859 -0.177984
v 3.137279 2.423859 0.177984
v 3.155379 2.446498 -0.115488
v 3.155379 2.446498 0.115488
v 3.158400 2.400000 -0.072000
v 3.158400 2.400000 0.072000
v 3.170400 2.400000 -0.157500
v 3.170400 2.400000 0.157500
v 3.170400 2.400000 -0.157500
v 3.173413 2.427791 -0.096264
v 3.173413 2.427791 0.096264
v 3.174157 2.442998 -0.172512
v 3.174157 2.442998 0.172512
v 3.186768 2.460263 -0.123552
v 3.186768 2.460263 0.123552
v 3.188800 2.400000 -0.040500
v 3.188800 2.400000 0.040500
v 3.199498 2.457201 -0.164448
v 3.199498 2.457201 0.164448
v 3.200000 2.400000 0.000000
v 3.206938 2.467997 0.133344
v 3.206938 2.467997 -0.133344
v 3.213366 2.466247 -0.154656
v 3.213366 2.466247 0.154656
v 3.215825 2.469919 -0.144000
v 3.215825 2.469919 0.144000
v 3.222074 2.448701 -0.101052
v 3.222074 2.448701 0.101052
v 3.222799 2.424616 -0.155736
v 3.222799 2.424616 0.155736
v 3.223301 2.428868 -0.073344
v 3.223301 2.428868 0.073344
v 3.237600 2.400000 -0.120000
v 3.237600 2.400000 0.120000
v 3.237600 2.400000 -0.120000
v 3.257153 2.429599 -0.041256
v 3.257153 2.429599 0.041256
v 3.259252 2.462994 -0.108108
v 3.259252 2.462994 0.108108
v 3.261414 2.444467 -0.150948
v 3.261414 2.444467 0.150948
v 3.269625 2.429869 0.000000
v 3.269625 2.429869 0.000000
v 3.276998 2.450515 -0.076992
v 3.276998 2.450515 0.076992
v 3.283200 2.400000 -0.067500
v 3.283200 2.400000 0.067500
v 3.283200 2.400000 -0.067500
v 3.284621 2.470934 -0.116676
v 3.284621 2.470934 0.116676
v 3.286576 2.459289 -0.143892
v 3.286576 2.459289 0.143892
v 3.293227 2.425240 -0.118656
v 3.293227 2.425240 0.118656
v 3.297850 2.472787 -0.126000
v 3.297850 2.472788 0.126000
v 3.298611 2.468818 -0.135324
v 3.298611 2.468818 0.135324
v 3.300000 2.400000 0.000000
v 3.300000 2.400000 0.000000
v 3.314269 2.451746 -0.043308
v 3.314269 2.451746 0.043308
v 3.318946 2.465243 -0.082368
v 3.318946 2.465243 0.082368
v 3.328000 2.452200 0.000000
v 3.328000 2.452200 0.000000
v 3.333274 2.445677 -0.115008
v 3.333274 2.445677 0.115008
v 3.341018 2.425663 -0.066744
v 3.341018 2.425663 0.066744
v 3.348595 2.473354 0.088896
v 3.348595 2.473354 -0.088896
v 3.358286 2.461009 -0.109632
v 3.358286 2.461009 0.109632
v 3.358625 2.425819 0.000000
v 3.359452 2.466769 -0.046332
v 3.359452 2.466769 0.046332
v 3.365400 2.475150 -0.096000
v 3.365400 2.475150 0.096000
v 3.368813 2.470934 -0.103104
v 3.368813 2.470934 0.103104
v 3.374375 2.467331 0.000000
v 3.374375 2.467331 0.000000
v 3.382035 2.446498 -0.064692
v 3.382035 2.446498 0.064692
v 3.392006 2.474995 -0.050004
v 3.392006 2.474995 0.050004
v 3.400000 2.446800 0.000000
v 3.406947 2.462176 -0.061668
v 3.406947 2.462176 0.061668
v 3.408000 2.475600 0.000000
v 3.408000 2.475600 0.000000
v 3.411237 2.476753 -0.054000
v 3.411237 2.476753 0.054000
v 3.416450 2.472371 -0.057996
v 3.416450 2.472371 0.057996
v 3.424875 2.462606 0.000000
v 3.428125 2.477344 0.000000
v 3.428125 2.477344 0.000000
v 3.434000 2.472900 0.000000

f 2909 2921 2939
f 2939 2931 2909
f 2869 2877 2921
f 2921 2909 2869
f 2819 2827 2877
f 2877 2869 2819
f 2737 2747 2827
f 2827 2819 2737
f 2669 2673 2747
f 2747 2737 2669
f 2567 2575 2673
f 2673 2669 2567
f 2476 2480 2575
f 2575 2567 2476
f 2358 2362 2480
f 2480 2476 2358
f 2158 2162 2362
f 2362 2358 2158
f 1715 1812 2162
f 2162 2158 1715
f 2901 2909 2931
f 2931 2917 2901
f 2863 2869 2909
f 2909 2901 2863
f 2813 2819 2869
f 2869 2863 2813
f 2729 2737 2819
f 2819 2813 2729
f 2663 2669 2737
f 2737 2729 2663
f 2561 2567 2669
f 2669 2663 2561
f 2468 2476 2567
f 2567 2561 2468
f 2350 2358 2476
f 2476 2468 2350
f 2152 2158 2358
f 2358 2350 2152
f 1717 1715 2158
f 2158 2152 1717
f 2903 2901 2917
f 2917 2923 2903
f 2865 2863 2901
f 2901 2903 2865
f 2815 2813 2863
f 2863 2865 2815
f 2733 2729 2813
f 2813 2815 2733
f 2665 2663 2729
f 2729 2733 2665
f 2564 2561 2663
f 2663 2665 2564
f 2473 2468 2561
f 2561 2564 2473
f 2354 2350 2468
f 2468 2473 2354
f 2155 2152 2350
f 2350 2354 2155
f 1927 1717 2152
f 2152 2155 1927
f 2911 2903 2923
f 2923 2935 2911
f 2875 2865 2903
f 2903 2911 2875
f 2823 2815 2865
f 2865 2875 2823
f 2741 2733 2815
f 2815 2823 2741
f 2671 2665 2733
f 2733 2741 2671
f 2571 2564 2665
f 2665 2671 2571
f 2478 2473 2564
f 2564 2571 2478
f 2360 2354 2473
f 2473 2478 2360
f 2160 2155 2354
f 2354 2360 2160
f 1718 1927 2155
f 2155 2160 1718
f 2929 2911 2935
f 2935 2947 2929
f 2881 2875 2911
f 2911 2929 2881
f 2829 2823 2875
f 2875 2881 2829
f 2751 2741 2823
f 2823 2829 2751
f 2677 2671 2741
f 2741 2751 2677
f 2577 2571 2671
f 2671 2677 2577
f 2482 2478 2571
f 2571 2577 2482
f 2364 2360 2478
f 2478 2482 2364
f 2164 2160 2360
f 2360 2364 2164
f 1842 1718 2160
f 2160 2164 1842
f 2945 2929 2947
f 2947 2959 2945
f 2897 2881 2929
f 2929 2945 2897
f 2835 2829 2881
f 2881 2897 2835
f 2761 2751 2829
f 2829 2835 2761
f 2679 2677 2751
f 2751 2761 2679
f 2579 2577 2677
f 2677 2679 2579
f 2486 2482 2577
f 2577 2579 2486
f 2368 2364 2482
f 2482 2486 2368
f 2172 2164 2364
f 2364 2368 2172
f 1725 1842 2164
f 2164 2172 1725
f 2965 2945 2959
f 2959 2981 2965
f 2907 2897 2945
f 2945 2965 2907
f 2845 2835 2897
f 2897 2907 2845
f 2769 2761 2835
f 2835 2845 2769
f 2685 2679 2761
f 2761 2769 2685
f 2587 2579 2679
f 2679 2685 2587
f 2491 2486 2579
f 2579 2587 2491
f 2370 2368 2486
f 2486 2491 2370
f 2174 2172 2368
f 2368 2370 2174
f 1834 1725 2172
f 2172 2174 1834
f 2982 2965 2981
f 2981 2988 2982
f 2933 2907 2965
f 2965 2982 2933
f 2855 2845 2907
f 2907 2933 2855
f 2779 2769 2845
f 2845 2855 2779
f 2691 2685 2769
f 2769 2779 2691
f 2595 2587 2685
f 2685 2691 2595
f 2500 2491 2587
f 2587 2595 2500
f 2374 2370 2491
f 2491 2500 2374
f 2178 2174 2370
f 2370 2374 2178
f 1716 1834 2174
f 2174 2178 1716
f 2990 2982 2988
f 2988 3002 2990
f 2949 2933 2982
f 2982 2990 2949
f 2871 2855 2933
f 2933 2949 2871
f 2791 2779 2855
f 2855 2871 2791
f 2699 2691 2779
f 2779 2791 2699
f 2601 2595 2691
f 2691 2699 2601
f 2506 2500 2595
f 2595 2601 2506
f 2378 2374 2500
f 2500 2506 2378
f 2180 2178 2374
f 2374 2378 2180
f 1714 1716 2178
f 2178 2180 1714
f 3008 2990 3002
f 3002 3024 3008
f 2973 2949 2990
f 2990 3008 2973
f 2889 2871 2949
f 2949 2973 2889
f 2805 2791 2871
f 2871 2889 2805
f 2711 2699 2791
f 2791 2805 2711
f 2611 2601 2699
f 2699 2711 2611
f 2521 2506 2601
f 2601 2611 2521
f 2387 2378 2506
f 2506 2521 2387
f 2191 2180 2378
f 2378 2387 2191
f 1810 1714 2180
f 2180 2191 1810
f 1464 1460 1813
f 1813 1821 1464
f 1264 1260 1460
f 1460 1464 1264
f 1146 1142 1260
f 1260 1264 1146
f 1055 1047 1142
f 1142 1146 1055
f 953 949 1047
f 1047 1055 953
f 885 875 949
f 949 953 885
f 803 795 875
f 875 885 803
f 753 745 795
f 795 803 753
f 713 701 745
f 745 753 713
f 691 683 701
f 701 713 691
f 1470 1464 1821
f 1821 1829 1470
f 1272 1264 1464
f 1464 1470 1272
f 1154 1146 1264
f 1264 1272 1154
f 1061 1055 1146
f 1146 1154 1061
f 959 953 1055
f 1055 1061 959
f 893 885 953
f 953 959 893
f 809 803 885
f 885 893 809
f 759 753 803
f 803 809 759
f 721 713 753
f 753 759 721
f 705 691 713
f 713 721 705
f 1469 1470 1829
f 1829 1835 1469
f 1268 1272 1470
f 1470 1469 1268
f 1151 1154 1272
f 1272 1268 1151
f 1060 1061 1154
f 1154 1151 1060
f 957 959 1061
f 1061 1060 957
f 889 893 959
f 959 957 889
f 807 809 893
f 893 889 807
f 757 759 809
f 809 807 757
f 719 721 759
f 759 757 719
f 699 705 721
f 721 719 699
f 1462 1469 1835
f 1835 1839 1462
f 1262 1268 1469
f 1469 1462 1262
f 1144 1151 1268
f 1268 1262 1144
f 1051 1060 1151
f 1151 1144 1051
f 951 957 1060
f 1060 1051 951
f 881 889 957
f 957 951 881
f 799 807 889
f 889 881 799
f 747 757 807
f 807 799 747
f 711 719 757
f 757 747 711
f 687 699 719
f 719 711 687
f 1458 1462 1839
f 1839 1843 1458
f 1258 1262 1462
f 1462 1458 1258
f 1140 1144 1262
f 1262 1258 1140
f 1045 1051 1144
f 1144 1140 1045
f 945 951 1051
f 1051 1045 945
f 871 881 951
f 951 945 871
f 793 799 881
f 881 871 793
f 741 747 799
f 799 793 741
f 693 711 747
f 747 741 693
f 675 687 711
f 711 693 675
f 1450 1458 1843
f 1843 1838 1450
f 1254 1258 1458
f 1458 1450 1254
f 1136 1140 1258
f 1258 1254 1136
f 1043 1045 1140
f 1140 1136 1043
f 943 945 1045
f 1045 1043 943
f 861 871 945
f 945 943 861
f 787 793 871
f 871 861 787
f 725 741 793
f 793 787 725
f 677 693 741
f 741 725 677
f 663 675 693
f 693 677 663
f 1448 1450 1838
f 1838 1834 1448
f 1252 1254 1450
f 1450 1448 1252
f 1133 1136 1254
f 1254 1252 1133
f 1035 1043 1136
f 1136 1133 1035
f 937 943 1043
f 1043 1035 937
f 853 861 943
f 943 937 853
f 777 787 861
f 861 853 777
f 715 725 787
f 787 777 715
f 657 677 725
f 725 715 657
f 642 663 677
f 677 657 642
f 1444 1448 1834
f 1834 1828 1444
f 1248 1252 1448
f 1448 1444 1248
f 1122 1133 1252
f 1252 1248 1122
f 1027 1035 1133
f 1133 1122 1027
f 931 937 1035
f 1035 1027 931
f 843 853 937
f 937 931 843
f 767 777 853
f 853 843 767
f 689 715 777
f 777 767 689
f 640 657 715
f 715 689 640
f 634 642 657
f 657 640 634
f 1442 1444 1828
f 1828 1820 1442
f 1244 1248 1444
f 1444 1442 1244
f 1116 1122 1248
f 1248 1244 1116
f 1021 1027 1122
f 1122 1116 1021
f 923 931 1027
f 1027 1021 923
f 831 843 931
f 931 923 831
f 751 767 843
f 843 831 751
f 673 689 767
f 767 751 673
f 632 640 689
f 689 673 632
f 620 634 640
f 640 632 620
f 1429 1442 1820
f 1820 1811 1429
f 1233 1244 1442
f 1442 1429 1233
f 1106 1116 1244
f 1244 1233 1106
f 1011 1021 1116
f 1116 1106 1011
f 911 923 1021
f 1021 1011 911
f 817 831 923
f 923 911 817
f 733 751 831
f 831 817 733
f 649 673 751
f 751 733 649
f 614 632 673
f 673 649 614
f 597 620 632
f 632 614 597
f 714 702 684
f 684 692 714
f 754 746 702
f 702 714 754
f 804 796 746
f 746 754 804
f 886 876 796
f 796 804 886
f 954 950 876
f 876 886 954
f 1056 1048 950
f 950 954 1056
f 1147 1143 1048
f 1048 1056 1147
f 1265 1261 1143
f 1143 1147 1265
f 1465 1461 1261
f 1261 1265 1465
f 1915 1817 1461
f 1461 1465 1915
f 722 714 692
f 692 706 722
f 760 754 714
f 714 722 760
f 810 804 754
f 754 760 810
f 894 886 804
f 804 810 894
f 960 954 886
f 886 894 960
f 1062 1056 954
f 954 960 1062
f 1155 1147 1056
f 1056 1062 1155
f 1273 1265 1147
f 1147 1155 1273
f 1471 1465 1265
f 1265 1273 1471
f 1917 1915 1465
f 1465 1471 1917
f 720 722 706
f 706 700 720
f 758 760 722
f 722 720 758
f 808 810 760
f 760 758 808
f 890 894 810
f 810 808 890
f 958 960 894
f 894 890 958
f 1059 1062 960
f 960 958 1059
f 1150 1155 1062
f 1062 1059 1150
f 1269 1273 1155
f 1155 1150 1269
f 1468 1471 1273
f 1273 1269 1468
f 1697 1917 1471
f 1471 1468 1697
f 712 720 700
f 700 688 712
f 748 758 720
f 720 712 748
f 800 808 758
f 758 748 800
f 882 890 808
f 808 800 882
f 952 958 890
f 890 882 952
f 1052 1059 958
f 958 952 1052
f 1145 1150 1059
f 1059 1052 1145
f 1263 1269 1150
f 1150 1145 1263
f 1463 1468 1269
f 1269 1263 1463
f 1919 1697 1468
f 1468 1463 1919
f 694 712 688
f 688 676 694
f 742 748 712
f 712 694 742
f 794 800 748
f 748 742 794
f 872 882 800
f 800 794 872
f 946 952 882
f 882 872 946
f 1046 1052 952
f 952 946 1046
f 1141 1145 1052
f 1052 1046 1141
f 1259 1263 1145
f 1145 1141 1259
f 1459 1463 1263
f 1263 1259 1459
f 1845 1919 1463
f 1463 1459 1845
f 678 694 676
f 676 664 678
f 726 742 694
f 694 678 726
f 788 794 742
f 742 726 788
f 862 872 794
f 794 788 862
f 944 946 872
f 872 862 944
f 1044 1046 946
f 946 944 1044
f 1137 1141 1046
f 1046 1044 1137
f 1255 1259 1141
f 1141 1137 1255
f 1451 1459 1259
f 1259 1255 1451
f 1898 1845 1459
f 1459 1451 1898
f 658 678 664
f 664 642 658
f 716 726 678
f 678 658 716
f 778 788 726
f 726 716 778
f 854 862 788
f 788 778 854
f 938 944 862
f 862 854 938
f 1036 1044 944
f 944 938 1036
f 1132 1137 1044
f 1044 1036 1132
f 1253 1255 1137
f 1137 1132 1253
f 1449 1451 1255
f 1255 1253 1449
f 1837 1898 1451
f 1451 1449 1837
f 641 658 642
f 642 635 641
f 690 716 658
f 658 641 690
f 768 778 716
f 716 690 768
f 844 854 778
f 778 768 844
f 932 938 854
f 854 844 932
f 1028 1036 938
f 938 932 1028
f 1123 1132 1036
f 1036 1028 1123
f 1249 1253 1132
f 1132 1123 1249
f 1445 1449 1253
f 1253 1249 1445
f 1918 1837 1449
f 1449 1445 1918
f 633 641 635
f 635 621 633
f 674 690 641
f 641 633 674
f 752 768 690
f 690 674 752
f 832 844 768
f 768 752 832
f 924 932 844
f 844 832 924
f 1022 1028 932
f 932 924 1022
f 1117 1123 1028
f 1028 1022 1117
f 1245 1249 1123
f 1123 1117 1245
f 1443 1445 1249
f 1249 1245 1443
f 1916 1918 1445
f 1445 1443 1916
f 616 633 621
f 621 600 616
f 654 674 633
f 633 616 654
f 737 752 674
f 674 654 737
f 822 832 752
f 752 737 822
f 914 924 832
f 832 822 914
f 1014 1022 924
f 924 914 1014
f 1104 1117 1022
f 1022 1014 1104
f 1237 1245 1117
f 1117 1104 1237
f 1433 1443 1245
f 1245 1237 1433
f 1819 1916 1443
f 1443 1433 1819
f 2159 2163 1816
f 1816 1822 2159
f 2359 2363 2163
f 2163 2159 2359
f 2477 2481 2363
f 2363 2359 2477
f 2568 2576 2481
f 2481 2477 2568
f 2670 2674 2576
f 2576 2568 2670
f 2738 2748 2674
f 2674 2670 2738
f 2820 2828 2748
f 2748 2738 2820
f 2870 2878 2828
f 2828 2820 2870
f 2910 2922 2878
f 2878 2870 2910
f 2932 2940 2922
f 2922 2910 2932
f 2153 2159 1822
f 1822 1830 2153
f 2351 2359 2159
f 2159 2153 2351
f 2469 2477 2359
f 2359 2351 2469
f 2562 2568 2477
f 2477 2469 2562
f 2664 2670 2568
f 2568 2562 2664
f 2730 2738 2670
f 2670 2664 2730
f 2814 2820 2738
f 2738 2730 2814
f 2864 2870 2820
f 2820 2814 2864
f 2902 2910 2870
f 2870 2864 2902
f 2918 2932 2910
f 2910 2902 2918
f 2154 2153 1830
f 1830 1836 2154
f 2355 2351 2153
f 2153 2154 2355
f 2472 2469 2351
f 2351 2355 2472
f 2563 2562 2469
f 2469 2472 2563
f 2666 2664 2562
f 2562 2563 2666
f 2734 2730 2664
f 2664 2666 2734
f 2816 2814 2730
f 2730 2734 2816
f 2866 2864 2814
f 2814 2816 2866
f 2904 2902 2864
f 2864 2866 2904
f 2924 2918 2902
f 2902 2904 2924
f 2161 2154 1836
f 1836 1840 2161
f 2361 2355 2154
f 2154 2161 2361
f 2479 2472 2355
f 2355 2361 2479
f 2572 2563 2472
f 2472 2479 2572
f 2672 2666 2563
f 2563 2572 2672
f 2742 2734 2666
f 2666 2672 2742
f 2824 2816 2734
f 2734 2742 2824
f 2876 2866 2816
f 2816 2824 2876
f 2912 2904 2866
f 2866 2876 2912
f 2936 2924 2904
f 2904 2912 2936
f 2165 2161 1840
f 1840 1844 2165
f 2365 2361 2161
f 2161 2165 2365
f 2483 2479 2361
f 2361 2365 2483
f 2578 2572 2479
f 2479 2483 2578
f 2678 2672 2572
f 2572 2578 2678
f 2752 2742 2672
f 2672 2678 2752
f 2830 2824 2742
f 2742 2752 2830
f 2882 2876 2824
f 2824 2830 2882
f 2930 2912 2876
f 2876 2882 2930
f 2948 2936 2912
f 2912 2930 2948
f 2173 2165 1844
f 1844 1841 2173
f 2369 2365 2165
f 2165 2173 2369
f 2487 2483 2365
f 2365 2369 2487
f 2580 2578 2483
f 2483 2487 2580
f 2680 2678 2578
f 2578 2580 2680
f 2762 2752 2678
f 2678 2680 2762
f 2836 2830 2752
f 2752 2762 2836
f 2898 2882 2830
f 2830 2836 2898
f 2946 2930 2882
f 2882 2898 2946
f 2960 2948 2930
f 2930 2946 2960
f 2175 2173 1841
f 1841 1837 2175
f 2371 2369 2173
f 2173 2175 2371
f 2490 2487 2369
f 2369 2371 2490
f 2588 2580 2487
f 2487 2490 2588
f 2686 2680 2580
f 2580 2588 2686
f 2770 2762 2680
f 2680 2686 2770
f 2846 2836 2762
f 2762 2770 2846
f 2908 2898 2836
f 2836 2846 2908
f 2966 2946 2898
f 2898 2908 2966
f 2981 2960 2946
f 2946 2966 2981
f 2179 2175 1837
f 1837 1831 2179
f 2375 2371 2175
f 2175 2179 2375
f 2501 2490 2371
f 2371 2375 2501
f 2596 2588 2490
f 2490 2501 2596
f 2692 2686 2588
f 2588 2596 2692
f 2780 2770 2686
f 2686 2692 2780
f 2856 2846 2770
f 2770 2780 2856
f 2934 2908 2846
f 2846 2856 2934
f 2983 2966 2908
f 2908 2934 2983
f 2989 2981 2966
f 2966 2983 2989
f 2181 2179 1831
f 1831 1823 2181
f 2379 2375 2179
f 2179 2181 2379
f 2507 2501 2375
f 2375 2379 2507
f 2602 2596 2501
f 2501 2507 2602
f 2700 2692 2596
f 2596 2602 2700
f 2792 2780 2692
f 2692 2700 2792
f 2872 2856 2780
f 2780 2792 2872
f 2950 2934 2856
f 2856 2872 2950
f 2991 2983 2934
f 2934 2950 2991
f 3003 2989 2983
f 2983 2991 3003
f 2194 2181 1823
f 1823 1818 2194
f 2391 2379 2181
f 2181 2194 2391
f 2518 2507 2379
f 2379 2391 2518
f 2614 2602 2507
f 2507 2518 2614
f 2712 2700 2602
f 2602 2614 2712
f 2806 2792 2700
f 2700 2712 2806
f 2890 2872 2792
f 2792 2806 2890
f 2974 2950 2872
f 2872 2890 2974
f 3009 2991 2950
f 2950 2974 3009
f 3025 3003 2991
f 2991 3009 3025
f 3040 3008 3024
f 3024 3048 3040
f 3018 2973 3008
f 3008 3040 3018
f 2943 2889 2973
f 2973 3018 2943
f 2841 2805 2889
f 2889 2943 2841
f 2731 2711 2805
f 2805 2841 2731
f 2645 2611 2711
f 2711 2731 2645
f 2529 2521 2611
f 2611 2645 2529
f 2402 2387 2521
f 2521 2529 2402
f 2208 2191 2387
f 2387 2402 2208
f 1806 1810 2191
f 2191 2208 1806
f 3072 3040 3048
f 3048 3078 3072
f 3044 3018 3040
f 3040 3072 3044
f 2994 2943 3018
f 3018 3044 2994
f 2883 2841 2943
f 2943 2994 2883
f 2773 2731 2841
f 2841 2883 2773
f 2659 2645 2731
f 2731 2773 2659
f 2539 2529 2645
f 2645 2659 2539
f 2410 2402 2529
f 2529 2539 2410
f 2222 2208 2402
f 2402 2410 2222
f 1694 1806 2208
f 2208 2222 1694
f 3092 3072 3078
f 3078 3116 3092
f 3074 3044 3072
f 3072 3092 3074
f 3030 2994 3044
f 3044 3074 3030
f 2937 2883 2994
f 2994 3030 2937
f 2810 2773 2883
f 2883 2937 2810
f 2683 2659 2773
f 2773 2810 2683
f 2554 2539 2659
f 2659 2683 2554
f 2420 2410 2539
f 2539 2554 2420
f 2238 2222 2410
f 2410 2420 2238
f 1930 1694 2222
f 2222 2238 1930
f 3132 3092 3116
f 3116 3142 3132
f 3090 3074 3092
f 3092 3132 3090
f 3054 3030 3074
f 3074 3090 3054
f 2984 2937 3030
f 3030 3054 2984
f 2837 2810 2937
f 2937 2984 2837
f 2705 2683 2810
f 2810 2837 2705
f 2574 2554 2683
f 2683 2705 2574
f 2430 2420 2554
f 2554 2574 2430
f 2247 2238 2420
f 2420 2430 2247
f 1913 1930 2238
f 2238 2247 1913
f 3150 3132 3142
f 3142 3156 3150
f 3128 3090 3132
f 3132 3150 3128
f 3076 3054 3090
f 3090 3128 3076
f 3014 2984 3054
f 3054 3076 3014
f 2861 2837 2984
f 2984 3014 2861
f 2723 2705 2837
f 2837 2861 2723
f 2585 2574 2705
f 2705 2723 2585
f 2438 2430 2574
f 2574 2585 2438
f 2253 2247 2430
f 2430 2438 2253
f 1711 1913 2247
f 2247 2253 1711
f 3162 3150 3156
f 3156 3172 3162
f 3148 3128 3150
f 3150 3162 3148
f 3088 3076 3128
f 3128 3148 3088
f 3036 3014 3076
f 3076 3088 3036
f 2893 2861 3014
f 3014 3036 2893
f 2743 2723 2861
f 2861 2893 2743
f 2599 2585 2723
f 2723 2743 2599
f 2450 2438 2585
f 2585 2599 2450
f 2267 2253 2438
f 2438 2450 2267
f 1794 1711 2253
f 2253 2267 1794
f 3178 3162 3172
f 3172 3184 3178
f 3154 3148 3162
f 3162 3178 3154
f 3118 3088 3148
f 3148 3154 3118
f 3046 3036 3088
f 3088 3118 3046
f 2915 2893 3036
f 3036 3046 2915
f 2763 2743 2893
f 2893 2915 2763
f 2615 2599 2743
f 2743 2763 2615
f 2452 2450 2599
f 2599 2615 2452
f 2277 2267 2450
f 2450 2452 2277
f 1710 1794 2267
f 2267 2277 1710
f 3188 3178 3184
f 3184 3200 3188
f 3164 3154 3178
f 3178 3188 3164
f 3130 3118 3154
f 3154 3164 3130
f 3058 3046 3118
f 3118 3130 3058
f 2941 2915 3046
f 3046 3058 2941
f 2775 2763 2915
f 2915 2941 2775
f 2627 2615 2763
f 2763 2775 2627
f 2458 2452 2615
f 2615 2627 2458
f 2287 2277 2452
f 2452 2458 2287
f 1910 1710 2277
f 2277 2287 1910
f 3198 3188 3200
f 3200 3209 3198
f 3170 3164 3188
f 3188 3198 3170
f 3136 3130 3164
f 3164 3170 3136
f 3064 3058 3130
f 3130 3136 3064
f 2955 2941 3058
f 3058 3064 2955
f 2781 2775 2941
f 2941 2955 2781
f 2636 2627 2775
f 2775 2781 2636
f 2462 2458 2627
f 2627 2636 2462
f 2295 2287 2458
f 2458 2462 2295
f 1909 1910 2287
f 2287 2295 1909
f 3202 3198 3209
f 3209 3213 3202
f 3174 3170 3198
f 3198 3202 3174
f 3138 3136 3170
f 3170 3174 3138
f 3066 3064 3136
f 3136 3138 3066
f 2961 2955 3064
f 3064 3066 2961
f 2783 2781 2955
f 2955 2961 2783
f 2642 2636 2781
f 2781 2783 2642
f 2464 2462 2636
f 2636 2642 2464
f 2297 2295 2462
f 2462 2464 2297
f 1784 1909 2295
f 2295 2297 1784
f 1414 1429 1811
f 1811 1807 1414
f 1220 1233 1429
f 1429 1414 1220
f 1093 1106 1233
f 1233 1220 1093
f 977 1011 1106
f 1106 1093 977
f 891 911 1011
f 1011 977 891
f 781 817 911
f 911 891 781
f 679 733 817
f 817 781 679
f 604 649 733
f 733 679 604
f 571 614 649
f 649 604 571
f 561 597 614
f 614 571 561
f 1400 1414 1807
f 1807 1804 1400
f 1212 1220 1414
f 1414 1400 1212
f 1083 1093 1220
f 1220 1212 1083
f 963 977 1093
f 1093 1083 963
f 849 891 977
f 977 963 849
f 739 781 891
f 891 849 739
f 628 679 781
f 781 739 628
f 565 604 679
f 679 628 565
f 530 571 604
f 604 565 530
f 524 561 571
f 571 530 524
f 1386 1400 1804
f 1804 1802 1386
f 1202 1212 1400
f 1400 1386 1202
f 1070 1083 1212
f 1212 1202 1070
f 939 963 1083
f 1083 1070 939
f 814 849 963
f 963 939 814
f 685 739 849
f 849 814 685
f 585 628 739
f 739 685 585
f 528 565 628
f 628 585 528
f 510 530 565
f 565 528 510
f 508 524 530
f 530 510 508
f 1375 1386 1802
f 1802 1800 1375
f 1192 1202 1386
f 1386 1375 1192
f 1050 1070 1202
f 1202 1192 1050
f 917 939 1070
f 1070 1050 917
f 785 814 939
f 939 917 785
f 638 685 814
f 814 785 638
f 553 585 685
f 685 638 553
f 512 528 585
f 585 553 512
f 492 510 528
f 528 512 492
f 482 508 510
f 510 492 482
f 1369 1375 1800
f 1800 1798 1369
f 1184 1192 1375
f 1375 1369 1184
f 1037 1050 1192
f 1192 1184 1037
f 899 917 1050
f 1050 1037 899
f 761 785 917
f 917 899 761
f 608 638 785
f 785 761 608
f 526 553 638
f 638 608 526
f 496 512 553
f 553 526 496
f 454 492 512
f 512 496 454
f 448 482 492
f 492 454 448
f 1355 1369 1798
f 1798 1795 1355
f 1172 1184 1369
f 1369 1355 1172
f 1023 1037 1184
f 1184 1172 1023
f 879 899 1037
f 1037 1023 879
f 729 761 899
f 899 879 729
f 579 608 761
f 761 729 579
f 514 526 608
f 608 579 514
f 457 496 526
f 526 514 457
f 442 454 496
f 496 457 442
f 432 448 454
f 454 442 432
f 1345 1355 1795
f 1795 1792 1345
f 1170 1172 1355
f 1355 1345 1170
f 1007 1023 1172
f 1172 1170 1007
f 859 879 1023
f 1023 1007 859
f 707 729 879
f 879 859 707
f 563 579 729
f 729 707 563
f 506 514 579
f 579 563 506
f 450 457 514
f 514 506 450
f 420 442 457
f 457 450 420
f 412 432 442
f 442 420 412
f 1335 1345 1792
f 1792 1790 1335
f 1164 1170 1345
f 1345 1335 1164
f 995 1007 1170
f 1170 1164 995
f 847 859 1007
f 1007 995 847
f 681 707 859
f 859 847 681
f 547 563 707
f 707 681 547
f 494 506 563
f 563 547 494
f 440 450 506
f 506 494 440
f 410 420 450
f 450 440 410
f 398 412 420
f 420 410 398
f 1327 1335 1790
f 1790 1788 1327
f 1160 1164 1335
f 1335 1327 1160
f 988 995 1164
f 1164 1160 988
f 841 847 995
f 995 988 841
f 667 681 847
f 847 841 667
f 538 547 681
f 681 667 538
f 488 494 547
f 547 538 488
f 434 440 494
f 494 488 434
f 400 410 440
f 440 434 400
f 381 398 410
f 410 400 381
f 1324 1327 1788
f 1788 1785 1324
f 1156 1160 1327
f 1327 1324 1156
f 979 988 1160
f 1160 1156 979
f 837 841 988
f 988 979 837
f 659 667 841
f 841 837 659
f 534 538 667
f 667 659 534
f 484 488 538
f 538 534 484
f 428 434 488
f 488 484 428
f 395 400 434
f 434 428 395
f 374 381 400
f 400 395 374
f 572 616 600
f 600 562 572
f 605 654 616
f 616 572 605
f 680 737 654
f 654 605 680
f 782 822 737
f 737 680 782
f 892 914 822
f 822 782 892
f 978 1014 914
f 914 892 978
f 1094 1104 1014
f 1014 978 1094
f 1221 1237 1104
f 1104 1094 1221
f 1415 1433 1237
f 1237 1221 1415
f 1809 1819 1433
f 1433 1415 1809
f 531 572 562
f 562 525 531
f 566 605 572
f 572 531 566
f 629 680 605
f 605 566 629
f 740 782 680
f 680 629 740
f 850 892 782
f 782 740 850
f 964 978 892
f 892 850 964
f 1084 1094 978
f 978 964 1084
f 1213 1221 1094
f 1094 1084 1213
f 1401 1415 1221
f 1221 1213 1401
f 1931 1809 1415
f 1415 1401 1931
f 511 531 525
f 525 509 511
f 529 566 531
f 531 511 529
f 586 629 566
f 566 529 586
f 686 740 629
f 629 586 686
f 813 850 740
f 740 686 813
f 940 964 850
f 850 813 940
f 1069 1084 964
f 964 940 1069
f 1203 1213 1084
f 1084 1069 1203
f 1385 1401 1213
f 1213 1203 1385
f 1693 1931 1401
f 1401 1385 1693
f 493 511 509
f 509 483 493
f 513 529 511
f 511 493 513
f 554 586 529
f 529 513 554
f 639 686 586
f 586 554 639
f 786 813 686
f 686 639 786
f 918 940 813
f 813 786 918
f 1049 1069 940
f 940 918 1049
f 1193 1203 1069
f 1069 1049 1193
f 1376 1385 1203
f 1203 1193 1376
f 1712 1693 1385
f 1385 1376 1712
f 455 493 483
f 483 449 455
f 497 513 493
f 493 455 497
f 527 554 513
f 513 497 527
f 609 639 554
f 554 527 609
f 762 786 639
f 639 609 762
f 900 918 786
f 786 762 900
f 1038 1049 918
f 918 900 1038
f 1185 1193 1049
f 1049 1038 1185
f 1370 1376 1193
f 1193 1185 1370
f 1912 1712 1376
f 1376 1370 1912
f 443 455 449
f 449 433 443
f 458 497 455
f 455 443 458
f 515 527 497
f 497 458 515
f 580 609 527
f 527 515 580
f 730 762 609
f 609 580 730
f 880 900 762
f 762 730 880
f 1024 1038 900
f 900 880 1024
f 1173 1185 1038
f 1038 1024 1173
f 1356 1370 1185
f 1185 1173 1356
f 1797 1912 1370
f 1370 1356 1797
f 421 443 433
f 433 413 421
f 451 458 443
f 443 421 451
f 507 515 458
f 458 451 507
f 564 580 515
f 515 507 564
f 708 730 580
f 580 564 708
f 860 880 730
f 730 708 860
f 1008 1024 880
f 880 860 1008
f 1171 1173 1024
f 1024 1008 1171
f 1346 1356 1173
f 1173 1171 1346
f 1911 1797 1356
f 1356 1346 1911
f 411 421 413
f 413 399 411
f 441 451 421
f 421 411 441
f 495 507 451
f 451 441 495
f 548 564 507
f 507 495 548
f 682 708 564
f 564 548 682
f 848 860 708
f 708 682 848
f 996 1008 860
f 860 848 996
f 1165 1171 1008
f 1008 996 1165
f 1336 1346 1171
f 1171 1165 1336
f 1709 1911 1346
f 1346 1336 1709
f 401 411 399
f 399 382 401
f 435 441 411
f 411 401 435
f 489 495 441
f 441 435 489
f 539 548 495
f 495 489 539
f 668 682 548
f 548 539 668
f 842 848 682
f 682 668 842
f 987 996 848
f 848 842 987
f 1161 1165 996
f 996 987 1161
f 1328 1336 1165
f 1165 1161 1328
f 1708 1709 1336
f 1336 1328 1708
f 397 401 382
f 382 376 397
f 431 435 401
f 401 397 431
f 487 489 435
f 435 431 487
f 537 539 489
f 489 487 537
f 662 668 539
f 539 537 662
f 840 842 668
f 668 662 840
f 981 987 842
f 842 840 981
f 1159 1161 987
f 987 981 1159
f 1326 1328 1161
f 1161 1159 1326
f 1787 1708 1328
f 1328 1326 1787
f 2209 2194 1818
f 1818 1808 2209
f 2403 2391 2194
f 2194 2209 2403
f 2530 2518 2391
f 2391 2403 2530
f 2646 2614 2518
f 2518 2530 2646
f 2732 2712 2614
f 2614 2646 2732
f 2842 2806 2712
f 2712 2732 2842
f 2944 2890 2806
f 2806 2842 2944
f 3019 2974 2890
f 2890 2944 3019
f 3041 3009 2974
f 2974 3019 3041
f 3049 3025 3009
f 3009 3041 3049
f 2223 2209 1808
f 1808 1805 2223
f 2411 2403 2209
f 2209 2223 2411
f 2540 2530 2403
f 2403 2411 2540
f 2660 2646 2530
f 2530 2540 2660
f 2774 2732 2646
f 2646 2660 2774
f 2884 2842 2732
f 2732 2774 2884
f 2995 2944 2842
f 2842 2884 2995
f 3045 3019 2944
f 2944 2995 3045
f 3073 3041 3019
f 3019 3045 3073
f 3079 3049 3041
f 3041 3073 3079
f 2237 2223 1805
f 1805 1803 2237
f 2421 2411 2223
f 2223 2237 2421
f 2553 2540 2411
f 2411 2421 2553
f 2684 2660 2540
f 2540 2553 2684
f 2809 2774 2660
f 2660 2684 2809
f 2938 2884 2774
f 2774 2809 2938
f 3031 2995 2884
f 2884 2938 3031
f 3075 3045 2995
f 2995 3031 3075
f 3093 3073 3045
f 3045 3075 3093
f 3117 3079 3073
f 3073 3093 3117
f 2248 2237 1803
f 1803 1801 2248
f 2431 2421 2237
f 2237 2248 2431
f 2573 2553 2421
f 2421 2431 2573
f 2706 2684 2553
f 2553 2573 2706
f 2838 2809 2684
f 2684 2706 2838
f 2985 2938 2809
f 2809 2838 2985
f 3055 3031 2938
f 2938 2985 3055
f 3091 3075 3031
f 3031 3055 3091
f 3133 3093 3075
f 3075 3091 3133
f 3143 3117 3093
f 3093 3133 3143
f 2254 2248 1801
f 1801 1799 2254
f 2439 2431 2248
f 2248 2254 2439
f 2586 2573 2431
f 2431 2439 2586
f 2724 2706 2573
f 2573 2586 2724
f 2862 2838 2706
f 2706 2724 2862
f 3015 2985 2838
f 2838 2862 3015
f 3077 3055 2985
f 2985 3015 3077
f 3129 3091 3055
f 3055 3077 3129
f 3151 3133 3091
f 3091 3129 3151
f 3157 3143 3133
f 3133 3151 3157
f 2268 2254 1799
f 1799 1796 2268
f 2451 2439 2254
f 2254 2268 2451
f 2600 2586 2439
f 2439 2451 2600
f 2744 2724 2586
f 2586 2600 2744
f 2894 2862 2724
f 2724 2744 2894
f 3037 3015 2862
f 2862 2894 3037
f 3089 3077 3015
f 3015 3037 3089
f 3149 3129 3077
f 3077 3089 3149
f 3163 3151 3129
f 3129 3149 3163
f 3173 3157 3151
f 3151 3163 3173
f 2278 2268 1796
f 1796 1793 2278
f 2453 2451 2268
f 2268 2278 2453
f 2616 2600 2451
f 2451 2453 2616
f 2764 2744 2600
f 2600 2616 2764
f 2916 2894 2744
f 2744 2764 2916
f 3047 3037 2894
f 2894 2916 3047
f 3119 3089 3037
f 3037 3047 3119
f 3155 3149 3089
f 3089 3119 3155
f 3179 3163 3149
f 3149 3155 3179
f 3185 3173 3163
f 3163 3179 3185
f 2288 2278 1793
f 1793 1791 2288
f 2459 2453 2278
f 2278 2288 2459
f 2628 2616 2453
f 2453 2459 2628
f 2776 2764 2616
f 2616 2628 2776
f 2942 2916 2764
f 2764 2776 2942
f 3059 3047 2916
f 2916 2942 3059
f 3131 3119 3047
f 3047 3059 3131
f 3165 3155 3119
f 3119 3131 3165
f 3189 3179 3155
f 3155 3165 3189
f 3201 3185 3179
f 3179 3189 3201
f 2296 2288 1791
f 1791 1789 2296
f 2463 2459 2288
f 2288 2296 2463
f 2635 2628 2459
f 2459 2463 2635
f 2782 2776 2628
f 2628 2635 2782
f 2956 2942 2776
f 2776 2782 2956
f 3065 3059 2942
f 2942 2956 3065
f 3137 3131 3059
f 3059 3065 3137
f 3171 3165 3131
f 3131 3137 3171
f 3199 3189 3165
f 3165 3171 3199
f 3210 3201 3189
f 3189 3199 3210
f 2299 2296 1789
f 1789 1786 2299
f 2467 2463 2296
f 2296 2299 2467
f 2644 2635 2463
f 2463 2467 2644
f 2786 2782 2635
f 2635 2644 2786
f 2964 2956 2782
f 2782 2786 2964
f 3069 3065 2956
f 2956 2964 3069
f 3141 3137 3065
f 3065 3069 3141
f 3177 3171 3137
f 3137 3141 3177
f 3204 3199 3171
f 3171 3177 3204
f 3214 3210 3199
f 3199 3204 3214
f 3194 3202 3213
f 3213 3207 3194
f 3166 3175 3202
f 3202 3194 3166
f 3134 3139 3175
f 3175 3166 3134
f 3060 3067 3139
f 3139 3134 3060
f 2953 2962 3067
f 3067 3060 2953
f 2777 2784 2962
f 2962 2953 2777
f 2629 2643 2784
f 2784 2777 2629
f 2460 2465 2643
f 2643 2629 2460
f 2293 2298 2465
f 2465 2460 2293
f 1696 1785 2298
f 2298 2293 1696
f 3180 3194 3207
f 3207 3190 3180
f 3158 3166 3194
f 3194 3180 3158
f 3124 3134 3166
f 3166 3158 3124
f 3050 3060 3134
f 3134 3124 3050
f 2927 2953 3060
f 3060 3050 2927
f 2767 2777 2953
f 2953 2927 2767
f 2619 2629 2777
f 2777 2767 2619
f 2454 2460 2629
f 2629 2619 2454
f 2283 2293 2460
f 2460 2454 2283
f 1695 1696 2293
f 2293 2283 1695
f 3160 3180 3190
f 3190 3168 3160
f 3144 3158 3180
f 3180 3160 3144
f 3086 3124 3158
f 3158 3144 3086
f 3032 3050 3124
f 3124 3086 3032
f 2891 2927 3050
f 3050 3032 2891
f 2739 2767 2927
f 2927 2891 2739
f 2597 2619 2767
f 2767 2739 2597
f 2448 2454 2619
f 2619 2597 2448
f 2265 2283 2454
f 2454 2448 2265
f 1707 1695 2283
f 2283 2265 1707
f 3146 3160 3168
f 3168 3152 3146
f 3122 3144 3160
f 3160 3146 3122
f 3070 3086 3144
f 3144 3122 3070
f 2998 3032 3086
f 3086 3070 2998
f 2853 2891 3032
f 3032 2998 2853
f 2717 2739 2891
f 2891 2853 2717
f 2582 2597 2739
f 2739 2717 2582
f 2434 2448 2597
f 2597 2582 2434
f 2251 2265 2448
f 2448 2434 2251
f 1907 1707 2265
f 2265 2251 1907
f 3120 3146 3152
f 3152 3126 3120
f 3082 3122 3146
f 3146 3120 3082
f 3042 3070 3122
f 3122 3082 3042
f 2957 2998 3070
f 3070 3042 2957
f 2825 2853 2998
f 2998 2957 2825
f 2693 2717 2853
f 2853 2825 2693
f 2556 2582 2717
f 2717 2693 2556
f 2424 2434 2582
f 2582 2556 2424
f 2239 2251 2434
f 2434 2424 2239
f 1906 1907 2251
f 2251 2239 1906
f 3080 3120 3126
f 3126 3084 3080
f 3056 3082 3120
f 3120 3080 3056
f 3012 3042 3082
f 3082 3056 3012
f 2899 2957 3042
f 3042 3012 2899
f 2789 2825 2957
f 2957 2899 2789
f 2675 2693 2825
f 2825 2789 2675
f 2545 2556 2693
f 2693 2675 2545
f 2416 2424 2556
f 2556 2545 2416
f 2228 2239 2424
f 2424 2416 2228
f 1770 1906 2239
f 2239 2228 1770
f 3053 3080 3084
f 3084 3062 3053
f 3028 3056 3080
f 3080 3053 3028
f 2978 3012 3056
f 3056 3028 2978
f 2860 2899 3012
f 3012 2978 2860
f 2754 2789 2899
f 2899 2860 2754
f 2652 2675 2789
f 2789 2754 2652
f 2534 2545 2675
f 2675 2652 2534
f 2406 2416 2545
f 2545 2534 2406
f 2217 2228 2416
f 2416 2406 2217
f 1929 1770 2228
f 2228 2217 1929
f 3035 3053 3062
f 3062 3039 3035
f 2997 3028 3053
f 3053 3035 2997
f 2920 2978 3028
f 3028 2997 2920
f 2832 2860 2978
f 2978 2920 2832
f 2728 2754 2860
f 2860 2832 2728
f 2634 2652 2754
f 2754 2728 2634
f 2528 2534 2652
f 2652 2634 2528
f 2396 2406 2534
f 2534 2528 2396
f 2202 2217 2406
f 2406 2396 2202
f 1765 1929 2217
f 2217 2202 1765
f 3017 3035 3039
f 3039 3027 3017
f 2980 2997 3035
f 3035 3017 2980
f 2896 2920 2997
f 2997 2980 2896
f 2812 2832 2920
f 2920 2896 2812
f 2715 2728 2832
f 2832 2812 2715
f 2618 2634 2728
f 2728 2715 2618
f 2523 2528 2634
f 2634 2618 2523
f 2392 2396 2528
f 2528 2523 2392
f 2196 2202 2396
f 2396 2392 2196
f 1724 1765 2202
f 2202 2196 1724
f 3007 3017 3027
f 3027 3023 3007
f 2969 2980 3017
f 3017 3007 2969
f 2887 2896 2980
f 2980 2969 2887
f 2802 2812 2896
f 2896 2887 2802
f 2709 2715 2812
f 2812 2802 2709
f 2609 2618 2715
f 2715 2709 2609
f 2519 2523 2618
f 2618 2609 2519
f 2386 2392 2523
f 2523 2519 2386
f 2190 2196 2392
f 2392 2386 2190
f 1759 1724 2196
f 2196 2190 1759
f 1329 1324 1785
f 1785 1782 1329
f 1162 1157 1324
f 1324 1329 1162
f 993 982 1157
f 1157 1162 993
f 845 838 982
f 982 993 845
f 669 660 838
f 838 845 669
f 542 535 660
f 660 669 542
f 490 485 535
f 535 542 490
f 438 429 485
f 485 490 438
f 404 396 429
f 429 438 404
f 387 376 396
f 396 404 387
f 1339 1329 1782
f 1782 1780 1339
f 1168 1162 1329
f 1329 1339 1168
f 1003 993 1162
f 1162 1168 1003
f 855 845 993
f 993 1003 855
f 695 669 845
f 845 855 695
f 559 542 669
f 669 695 559
f 500 490 542
f 542 559 500
f 446 438 490
f 490 500 446
f 416 404 438
f 438 446 416
f 408 387 404
f 404 416 408
f 1357 1339 1780
f 1780 1778 1357
f 1174 1168 1339
f 1339 1357 1174
f 1025 1003 1168
f 1168 1174 1025
f 883 855 1003
f 1003 1025 883
f 731 695 855
f 855 883 731
f 583 559 695
f 695 731 583
f 516 500 559
f 559 583 516
f 467 446 500
f 500 516 467
f 444 416 446
f 446 467 444
f 436 408 416
f 416 444 436
f 1371 1357 1778
f 1778 1776 1371
f 1188 1174 1357
f 1357 1371 1188
f 1042 1025 1174
f 1174 1188 1042
f 905 883 1025
f 1025 1042 905
f 769 731 883
f 883 905 769
f 624 583 731
f 731 769 624
f 532 516 583
f 583 624 532
f 502 467 516
f 516 532 502
f 459 444 467
f 467 502 459
f 452 436 444
f 444 459 452
f 1383 1371 1776
f 1776 1774 1383
f 1198 1188 1371
f 1371 1383 1198
f 1068 1042 1188
f 1188 1198 1068
f 929 905 1042
f 1042 1068 929
f 797 769 905
f 905 929 797
f 665 624 769
f 769 797 665
f 569 532 624
f 624 665 569
f 520 502 532
f 532 569 520
f 504 459 502
f 502 520 504
f 498 452 459
f 459 504 498
f 1394 1383 1774
f 1774 1771 1394
f 1206 1198 1383
f 1383 1394 1206
f 1077 1068 1198
f 1198 1206 1077
f 947 929 1068
f 1068 1077 947
f 833 797 929
f 929 947 833
f 723 665 797
f 797 833 723
f 610 569 665
f 665 723 610
f 549 520 569
f 569 610 549
f 522 504 520
f 520 549 522
f 518 498 504
f 504 522 518
f 1407 1394 1771
f 1771 1768 1407
f 1216 1206 1394
f 1394 1407 1216
f 1090 1077 1206
f 1206 1216 1090
f 972 947 1077
f 1077 1090 972
f 870 833 947
f 947 972 870
f 764 723 833
f 833 870 764
f 646 610 723
f 723 764 646
f 587 549 610
f 610 646 587
f 556 522 549
f 549 587 556
f 540 518 522
f 522 556 540
f 1420 1407 1768
f 1768 1764 1420
f 1226 1216 1407
f 1407 1420 1226
f 1096 1090 1216
f 1216 1226 1096
f 990 972 1090
f 1090 1096 990
f 896 870 972
f 972 990 896
f 792 764 870
f 870 896 792
f 704 646 764
f 764 792 704
f 627 587 646
f 646 704 627
f 582 556 587
f 587 627 582
f 574 540 556
f 556 582 574
f 1426 1420 1764
f 1764 1762 1426
f 1230 1226 1420
f 1420 1426 1230
f 1101 1096 1226
f 1226 1230 1101
f 1006 990 1096
f 1096 1101 1006
f 907 896 990
f 990 1006 907
f 812 792 896
f 896 907 812
f 728 704 792
f 792 812 728
f 644 627 704
f 704 728 644
f 607 582 627
f 627 644 607
f 592 574 582
f 582 607 592
f 1430 1426 1762
f 1762 1758 1430
f 1234 1230 1426
f 1426 1430 1234
f 1107 1101 1230
f 1230 1234 1107
f 1012 1006 1101
f 1101 1107 1012
f 912 907 1006
f 1006 1012 912
f 819 812 907
f 907 912 819
f 738 728 812
f 812 819 738
f 651 644 728
f 728 738 651
f 618 607 644
f 644 651 618
f 601 592 607
f 607 618 601
f 405 397 376
f 376 388 405
f 439 430 397
f 397 405 439
f 491 486 430
f 430 439 491
f 543 536 486
f 486 491 543
f 670 661 536
f 536 543 670
f 846 839 661
f 661 670 846
f 994 980 839
f 839 846 994
f 1163 1158 980
f 980 994 1163
f 1330 1325 1158
f 1158 1163 1330
f 1926 1786 1325
f 1325 1330 1926
f 417 405 388
f 388 409 417
f 447 439 405
f 405 417 447
f 501 491 439
f 439 447 501
f 560 543 491
f 491 501 560
f 696 670 543
f 543 560 696
f 856 846 670
f 670 696 856
f 1004 994 846
f 846 856 1004
f 1169 1163 994
f 994 1004 1169
f 1340 1330 1163
f 1163 1169 1340
f 1925 1926 1330
f 1330 1340 1925
f 445 417 409
f 409 437 445
f 468 447 417
f 417 445 468
f 517 501 447
f 447 468 517
f 584 560 501
f 501 517 584
f 732 696 560
f 560 584 732
f 884 856 696
f 696 732 884
f 1026 1004 856
f 856 884 1026
f 1175 1169 1004
f 1004 1026 1175
f 1358 1340 1169
f 1169 1175 1358
f 1908 1925 1340
f 1340 1358 1908
f 460 445 437
f 437 453 460
f 503 468 445
f 445 460 503
f 533 517 468
f 468 503 533
f 625 584 517
f 517 533 625
f 770 732 584
f 584 625 770
f 906 884 732
f 732 770 906
f 1041 1026 884
f 884 906 1041
f 1189 1175 1026
f 1026 1041 1189
f 1372 1358 1175
f 1175 1189 1372
f 1706 1908 1358
f 1358 1372 1706
f 505 460 453
f 453 499 505
f 521 503 460
f 460 505 521
f 570 533 503
f 503 521 570
f 666 625 533
f 533 570 666
f 798 770 625
f 625 666 798
f 930 906 770
f 770 798 930
f 1067 1041 906
f 906 930 1067
f 1199 1189 1041
f 1041 1067 1199
f 1384 1372 1189
f 1189 1199 1384
f 1705 1706 1372
f 1372 1384 1705
f 523 505 499
f 499 519 523
f 550 521 505
f 505 523 550
f 611 570 521
f 521 550 611
f 724 666 570
f 570 611 724
f 834 798 666
f 666 724 834
f 948 930 798
f 798 834 948
f 1078 1067 930
f 930 948 1078
f 1207 1199 1067
f 1067 1078 1207
f 1395 1384 1199
f 1199 1207 1395
f 1773 1705 1384
f 1384 1395 1773
f 555 523 519
f 519 541 555
f 588 550 523
f 523 555 588
f 645 611 550
f 550 588 645
f 763 724 611
f 611 645 763
f 869 834 724
f 724 763 869
f 971 948 834
f 834 869 971
f 1089 1078 948
f 948 971 1089
f 1217 1207 1078
f 1078 1089 1217
f 1406 1395 1207
f 1207 1217 1406
f 1692 1773 1395
f 1395 1406 1692
f 581 555 541
f 541 573 581
f 626 588 555
f 555 581 626
f 703 645 588
f 588 626 703
f 791 763 645
f 645 703 791
f 895 869 763
f 763 791 895
f 989 971 869
f 869 895 989
f 1095 1089 971
f 971 989 1095
f 1227 1217 1089
f 1089 1095 1227
f 1421 1406 1217
f 1217 1227 1421
f 1766 1692 1406
f 1406 1421 1766
f 606 581 573
f 573 591 606
f 643 626 581
f 581 606 643
f 727 703 626
f 626 643 727
f 811 791 703
f 703 727 811
f 908 895 791
f 791 811 908
f 1005 989 895
f 895 908 1005
f 1100 1095 989
f 989 1005 1100
f 1231 1227 1095
f 1095 1100 1231
f 1427 1421 1227
f 1227 1231 1427
f 1897 1766 1421
f 1421 1427 1897
f 615 606 591
f 591 598 615
f 653 643 606
f 606 615 653
f 735 727 643
f 643 653 735
f 820 811 727
f 727 735 820
f 913 908 811
f 811 820 913
f 1013 1005 908
f 908 913 1013
f 1103 1100 1005
f 1005 1013 1103
f 1236 1231 1100
f 1100 1103 1236
f 1432 1427 1231
f 1231 1236 1432
f 1760 1897 1427
f 1427 1432 1760
f 2294 2299 1786
f 1786 1783 2294
f 2461 2466 2299
f 2299 2294 2461
f 2630 2641 2466
f 2466 2461 2630
f 2778 2785 2641
f 2641 2630 2778
f 2954 2963 2785
f 2785 2778 2954
f 3061 3068 2963
f 2963 2954 3061
f 3135 3140 3068
f 3068 3061 3135
f 3167 3176 3140
f 3140 3135 3167
f 3195 3203 3176
f 3176 3167 3195
f 3208 3213 3203
f 3203 3195 3208
f 2284 2294 1783
f 1783 1781 2284
f 2455 2461 2294
f 2294 2284 2455
f 2620 2630 2461
f 2461 2455 2620
f 2768 2778 2630
f 2630 2620 2768
f 2928 2954 2778
f 2778 2768 2928
f 3051 3061 2954
f 2954 2928 3051
f 3125 3135 3061
f 3061 3051 3125
f 3159 3167 3135
f 3135 3125 3159
f 3181 3195 3167
f 3167 3159 3181
f 3191 3208 3195
f 3195 3181 3191
f 2266 2284 1781
f 1781 1779 2266
f 2449 2455 2284
f 2284 2266 2449
f 2598 2620 2455
f 2455 2449 2598
f 2740 2768 2620
f 2620 2598 2740
f 2892 2928 2768
f 2768 2740 2892
f 3033 3051 2928
f 2928 2892 3033
f 3087 3125 3051
f 3051 3033 3087
f 3145 3159 3125
f 3125 3087 3145
f 3161 3181 3159
f 3159 3145 3161
f 3169 3191 3181
f 3181 3161 3169
f 2252 2266 1779
f 1779 1777 2252
f 2435 2449 2266
f 2266 2252 2435
f 2581 2598 2449
f 2449 2435 2581
f 2718 2740 2598
f 2598 2581 2718
f 2854 2892 2740
f 2740 2718 2854
f 2999 3033 2892
f 2892 2854 2999
f 3071 3087 3033
f 3033 2999 3071
f 3123 3145 3087
f 3087 3071 3123
f 3147 3161 3145
f 3145 3123 3147
f 3153 3169 3161
f 3161 3147 3153
f 2240 2252 1777
f 1777 1775 2240
f 2425 2435 2252
f 2252 2240 2425
f 2555 2581 2435
f 2435 2425 2555
f 2694 2718 2581
f 2581 2555 2694
f 2826 2854 2718
f 2718 2694 2826
f 2958 2999 2854
f 2854 2826 2958
f 3043 3071 2999
f 2999 2958 3043
f 3083 3123 3071
f 3071 3043 3083
f 3121 3147 3123
f 3123 3083 3121
f 3127 3153 3147
f 3147 3121 3127
f 2229 2240 1775
f 1775 1772 2229
f 2417 2425 2240
f 2240 2229 2417
f 2546 2555 2425
f 2425 2417 2546
f 2676 2694 2555
f 2555 2546 2676
f 2790 2826 2694
f 2694 2676 2790
f 2900 2958 2826
f 2826 2790 2900
f 3013 3043 2958
f 2958 2900 3013
f 3057 3083 3043
f 3043 3013 3057
f 3081 3121 3083
f 3083 3057 3081
f 3085 3127 3121
f 3121 3081 3085
f 2216 2229 1772
f 1772 1769 2216
f 2407 2417 2229
f 2229 2216 2407
f 2533 2546 2417
f 2417 2407 2533
f 2651 2676 2546
f 2546 2533 2651
f 2753 2790 2676
f 2676 2651 2753
f 2859 2900 2790
f 2790 2753 2859
f 2977 3013 2900
f 2900 2859 2977
f 3029 3057 3013
f 3013 2977 3029
f 3052 3081 3057
f 3057 3029 3052
f 3063 3085 3081
f 3081 3052 3063
f 2203 2216 1769
f 1769 1767 2203
f 2397 2407 2216
f 2216 2203 2397
f 2527 2533 2407
f 2407 2397 2527
f 2633 2651 2533
f 2533 2527 2633
f 2727 2753 2651
f 2651 2633 2727
f 2831 2859 2753
f 2753 2727 2831
f 2919 2977 2859
f 2859 2831 2919
f 2996 3029 2977
f 2977 2919 2996
f 3034 3052 3029
f 3029 2996 3034
f 3038 3063 3052
f 3052 3034 3038
f 2197 2203 1767
f 1767 1763 2197
f 2393 2397 2203
f 2203 2197 2393
f 2522 2527 2397
f 2397 2393 2522
f 2617 2633 2527
f 2527 2522 2617
f 2716 2727 2633
f 2633 2617 2716
f 2811 2831 2727
f 2727 2716 2811
f 2895 2919 2831
f 2831 2811 2895
f 2979 2996 2919
f 2919 2895 2979
f 3016 3034 2996
f 2996 2979 3016
f 3026 3038 3034
f 3034 3016 3026
f 2193 2197 1763
f 1763 1761 2193
f 2389 2393 2197
f 2197 2193 2389
f 2516 2522 2393
f 2393 2389 2516
f 2610 2617 2522
f 2522 2516 2610
f 2710 2716 2617
f 2617 2610 2710
f 2803 2811 2716
f 2716 2710 2803
f 2885 2895 2811
f 2811 2803 2885
f 2971 2979 2895
f 2895 2885 2971
f 3005 3016 2979
f 2979 2971 3005
f 3022 3026 3016
f 3016 3005 3022
f 461 545 544
f 544 456 461
f 463 551 545
f 545 461 463
f 465 557 551
f 551 463 465
f 469 567 557
f 557 465 469
f 471 575 567
f 567 469 471
f 473 577 575
f 575 471 473
f 475 589 577
f 577 473 475
f 477 593 589
f 589 475 477
f 479 595 593
f 593 477 479
f 481 599 595
f 595 479 481
f 389 461 456
f 456 392 389
f 386 463 461
f 461 389 386
f 379 465 463
f 463 386 379
f 373 469 465
f 465 379 373
f 371 471 469
f 469 373 371
f 369 473 471
f 471 371 369
f 366 475 473
f 473 369 366
f 364 477 475
f 475 366 364
f 362 479 477
f 477 364 362
f 361 481 479
f 479 362 361
f 335 389 392
f 392 337 335
f 333 386 389
f 389 335 333
f 331 379 386
f 386 333 331
f 329 373 379
f 379 331 329
f 328 371 373
f 373 329 328
f 325 369 371
f 371 328 325
f 323 366 369
f 369 325 323
f 321 364 366
f 366 323 321
f 319 362 364
f 364 321 319
f 316 361 362
f 362 319 316
f 298 335 337
f 337 302 298
f 290 333 335
f 335 298 290
f 288 331 333
f 333 290 288
f 286 329 331
f 331 288 286
f 281 328 329
f 329 286 281
f 275 325 328
f 328 281 275
f 265 323 325
f 325 275 265
f 259 321 323
f 323 265 259
f 255 319 321
f 321 259 255
f 249 316 319
f 319 255 249
f 269 298 302
f 302 271 269
f 261 290 298
f 298 269 261
f 251 288 290
f 290 261 251
f 238 286 288
f 288 251 238
f 230 281 286
f 286 238 230
f 218 275 281
f 281 230 218
f 208 265 275
f 275 218 208
f 196 259 265
f 265 208 196
f 186 255 259
f 259 196 186
f 181 249 255
f 255 186 181
f 228 269 271
f 271 234 228
f 222 261 269
f 269 228 222
f 212 251 261
f 261 222 212
f 200 238 251
f 251 212 200
f 177 230 238
f 238 200 177
f 160 218 230
f 230 177 160
f 134 208 218
f 218 160 134
f 112 196 208
f 208 134 112
f 102 186 196
f 196 112 102
f 96 181 186
f 186 102 96
f 198 228 234
f 234 205 198
f 182 222 228
f 228 198 182
f 168 212 222
f 222 182 168
f 146 200 212
f 212 168 146
f 118 177 200
f 200 146 118
f 92 160 177
f 177 118 92
f 74 134 160
f 160 92 74
f 63 112 134
f 134 74 63
f 53 102 112
f 112 63 53
f 50 96 102
f 102 53 50
f 167 198 205
f 205 170 167
f 154 182 198
f 198 167 154
f 126 168 182
f 182 154 126
f 100 146 168
f 168 126 100
f 83 118 146
f 146 100 83
f 61 92 118
f 118 83 61
f 46 74 92
f 92 61 46
f 32 63 74
f 74 46 32
f 25 53 63
f 63 32 25
f 21 50 53
f 53 25 21
f 143 167 170
f 170 150 143
f 124 154 167
f 167 143 124
f 104 126 154
f 154 124 104
f 84 100 126
f 126 104 84
f 65 83 100
f 100 84 65
f 44 61 83
f 83 65 44
f 30 46 61
f 61 44 30
f 17 32 46
f 46 30 17
f 9 25 32
f 32 17 9
f 5 21 25
f 25 9 5
f 132 143 150
f 150 140 132
f 116 124 143
f 143 132 116
f 94 104 124
f 124 116 94
f 76 84 104
f 104 94 76
f 55 65 84
f 84 76 55
f 40 44 65
f 65 55 40
f 22 30 44
f 44 40 22
f 11 17 30
f 30 22 11
f 2 9 17
f 17 11 2
f 1 5 9
f 9 2 1
f 480 596 599
f 599 481 480
f 478 594 596
f 596 480 478
f 476 590 594
f 594 478 476
f 474 578 590
f 590 476 474
f 472 576 578
f 578 474 472
f 470 568 576
f 576 472 470
f 466 558 568
f 568 470 466
f 464 552 558
f 558 466 464
f 462 546 552
f 552 464 462
f 456 544 546
f 546 462 456
f 363 480 481
f 481 360 363
f 365 478 480
f 480 363 365
f 367 476 478
f 478 365 367
f 368 474 476
f 476 367 368
f 370 472 474
f 474 368 370
f 372 470 472
f 472 370 372
f 380 466 470
f 470 372 380
f 385 464 466
f 466 380 385
f 390 462 464
f 464 385 390
f 391 456 462
f 462 390 391
f 320 363 360
f 360 316 320
f 322 365 363
f 363 320 322
f 324 367 365
f 365 322 324
f 326 368 367
f 367 324 326
f 327 370 368
f 368 326 327
f 330 372 370
f 370 327 330
f 332 380 372
f 372 330 332
f 334 385 380
f 380 332 334
f 336 390 385
f 385 334 336
f 337 391 390
f 390 336 337
f 256 320 316
f 316 250 256
f 260 322 320
f 320 256 260
f 266 324 322
f 322 260 266
f 276 326 324
f 324 266 276
f 282 327 326
f 326 276 282
f 287 330 327
f 327 282 287
f 289 332 330
f 330 287 289
f 291 334 332
f 332 289 291
f 299 336 334
f 334 291 299
f 303 337 336
f 336 299 303
f 187 256 250
f 250 181 187
f 197 260 256
f 256 187 197
f 209 266 260
f 260 197 209
f 219 276 266
f 266 209 219
f 231 282 276
f 276 219 231
f 239 287 282
f 282 231 239
f 252 289 287
f 287 239 252
f 262 291 289
f 289 252 262
f 270 299 291
f 291 262 270
f 272 303 299
f 299 270 272
f 103 187 181
f 181 97 103
f 113 197 187
f 187 103 113
f 135 209 197
f 197 113 135
f 161 219 209
f 209 135 161
f 178 231 219
f 219 161 178
f 201 239 231
f 231 178 201
f 213 252 239
f 239 201 213
f 223 262 252
f 252 213 223
f 229 270 262
f 262 223 229
f 235 272 270
f 270 229 235
f 54 103 97
f 97 50 54
f 64 113 103
f 103 54 64
f 75 135 113
f 113 64 75
f 93 161 135
f 135 75 93
f 119 178 161
f 161 93 119
f 147 201 178
f 178 119 147
f 169 213 201
f 201 147 169
f 183 223 213
f 213 169 183
f 199 229 223
f 223 183 199
f 205 235 229
f 229 199 205
f 24 54 50
f 50 21 24
f 33 64 54
f 54 24 33
f 47 75 64
f 64 33 47
f 62 93 75
f 75 47 62
f 82 119 93
f 93 62 82
f 101 147 119
f 119 82 101
f 127 169 147
f 147 101 127
f 155 183 169
f 169 127 155
f 166 199 183
f 183 155 166
f 171 205 199
f 199 166 171
f 10 24 21
f 21 6 10
f 18 33 24
f 24 10 18
f 31 47 33
f 33 18 31
f 45 62 47
f 47 31 45
f 66 82 62
f 62 45 66
f 85 101 82
f 82 66 85
f 105 127 101
f 101 85 105
f 125 155 127
f 127 105 125
f 144 166 155
f 155 125 144
f 151 171 166
f 166 144 151
f 3 10 6
f 6 1 3
f 12 18 10
f 10 3 12
f 23 31 18
f 18 12 23
f 41 45 31
f 31 23 41
f 56 66 45
f 45 41 56
f 77 85 66
f 66 56 77
f 95 105 85
f 85 77 95
f 117 125 105
f 105 95 117
f 133 144 125
f 125 117 133
f 140 151 144
f 144 133 140
f 138 132 140
f 140 145 138
f 122 116 132
f 132 138 122
f 98 94 116
f 116 122 98
f 80 76 94
f 94 98 80
f 60 55 76
f 76 80 60
f 42 40 55
f 55 60 42
f 28 22 40
f 40 42 28
f 13 11 22
f 22 28 13
f 7 2 11
f 11 13 7
f 4 1 2
f 2 7 4
f 152 138 145
f 145 158 152
f 136 122 138
f 138 152 136
f 108 98 122
f 122 136 108
f 89 80 98
f 98 108 89
f 70 60 80
f 80 89 70
f 52 42 60
f 60 70 52
f 38 28 42
f 42 52 38
f 26 13 28
f 28 38 26
f 19 7 13
f 13 26 19
f 15 4 7
f 7 19 15
f 173 152 158
f 158 176 173
f 162 136 152
f 152 173 162
f 142 108 136
f 136 162 142
f 111 89 108
f 108 142 111
f 91 70 89
f 89 111 91
f 73 52 70
f 70 91 73
f 58 38 52
f 52 73 58
f 48 26 38
f 38 58 48
f 37 19 26
f 26 48 37
f 35 15 19
f 19 37 35
f 194 173 176
f 176 202 194
f 184 162 173
f 173 194 184
f 174 142 162
f 162 184 174
f 156 111 142
f 142 174 156
f 128 91 111
f 111 156 128
f 106 73 91
f 91 128 106
f 86 58 73
f 73 106 86
f 78 48 58
f 58 86 78
f 68 37 48
f 48 78 68
f 67 35 37
f 37 68 67
f 221 194 202
f 202 225 221
f 216 184 194
f 194 221 216
f 206 174 184
f 184 216 206
f 192 156 174
f 174 206 192
f 180 128 156
f 156 192 180
f 164 106 128
f 128 180 164
f 148 86 106
f 106 164 148
f 130 78 86
f 86 148 130
f 121 68 78
f 78 130 121
f 115 67 68
f 68 121 115
f 244 221 225
f 225 247 244
f 240 216 221
f 221 244 240
f 236 206 216
f 216 240 236
f 233 192 206
f 206 236 233
f 227 180 192
f 192 233 227
f 215 164 180
f 180 227 215
f 210 148 164
f 164 215 210
f 203 130 148
f 148 210 203
f 191 121 130
f 130 203 191
f 188 115 121
f 121 191 188
f 284 244 247
f 247 285 284
f 279 240 244
f 244 284 279
f 277 236 240
f 240 279 277
f 273 233 236
f 236 277 273
f 267 227 233
f 233 273 267
f 263 215 227
f 227 267 263
f 258 210 215
f 215 263 258
f 253 203 210
f 210 258 253
f 245 191 203
f 203 253 245
f 242 188 191
f 191 245 242
f 315 284 285
f 285 318 315
f 312 279 284
f 284 315 312
f 311 277 279
f 279 312 311
f 309 273 277
f 277 311 309
f 307 267 273
f 273 309 307
f 305 263 267
f 267 307 305
f 301 258 263
f 263 305 301
f 297 253 258
f 258 301 297
f 295 245 253
f 253 297 295
f 293 242 245
f 245 295 293
f 341 315 318
f 318 339 341
f 343 312 315
f 315 341 343
f 345 311 312
f 312 343 345
f 347 309 311
f 311 345 347
f 349 307 309
f 309 347 349
f 351 305 307
f 307 349 351
f 353 301 305
f 305 351 353
f 355 297 301
f 301 353 355
f 357 295 297
f 297 355 357
f 359 293 295
f 295 357 359
f 378 341 339
f 339 376 378
f 384 343 341
f 341 378 384
f 394 345 343
f 343 384 394
f 403 347 345
f 345 394 403
f 406 349 347
f 347 403 406
f 415 351 349
f 349 406 415
f 419 353 351
f 351 415 419
f 423 355 353
f 353 419 423
f 425 357 355
f 355 423 425
f 427 359 357
f 357 425 427
f 8 3 1
f 1 4 8
f 14 12 3
f 3 8 14
f 29 23 12
f 12 14 29
f 43 41 23
f 23 29 43
f 59 56 41
f 41 43 59
f 81 77 56
f 56 59 81
f 99 95 77
f 77 81 99
f 123 117 95
f 95 99 123
f 139 133 117
f 117 123 139
f 145 140 133
f 133 139 145
f 20 8 4
f 4 16 20
f 27 14 8
f 8 20 27
f 39 29 14
f 14 27 39
f 51 43 29
f 29 39 51
f 71 59 43
f 43 51 71
f 88 81 59
f 59 71 88
f 109 99 81
f 81 88 109
f 137 123 99
f 99 109 137
f 153 139 123
f 123 137 153
f 159 145 139
f 139 153 159
f 36 20 16
f 16 34 36
f 49 27 20
f 20 36 49
f 57 39 27
f 27 49 57
f 72 51 39
f 39 57 72
f 90 71 51
f 51 72 90
f 110 88 71
f 71 90 110
f 141 109 88
f 88 110 141
f 163 137 109
f 109 141 163
f 172 153 137
f 137 163 172
f 176 159 153
f 153 172 176
f 69 36 34
f 34 67 69
f 79 49 36
f 36 69 79
f 87 57 49
f 49 79 87
f 107 72 57
f 57 87 107
f 129 90 72
f 72 107 129
f 157 110 90
f 90 129 157
f 175 141 110
f 110 157 175
f 185 163 141
f 141 175 185
f 195 172 163
f 163 185 195
f 202 176 172
f 172 195 202
f 120 69 67
f 67 114 120
f 131 79 69
f 69 120 131
f 149 87 79
f 79 131 149
f 165 107 87
f 87 149 165
f 179 129 107
f 107 165 179
f 193 157 129
f 129 179 193
f 207 175 157
f 157 193 207
f 217 185 175
f 175 207 217
f 220 195 185
f 185 217 220
f 224 202 195
f 195 220 224
f 190 120 114
f 114 189 190
f 204 131 120
f 120 190 204
f 211 149 131
f 131 204 211
f 214 165 149
f 149 211 214
f 226 179 165
f 165 214 226
f 232 193 179
f 179 226 232
f 237 207 193
f 193 232 237
f 241 217 207
f 207 237 241
f 243 220 217
f 217 241 243
f 248 224 220
f 220 243 248
f 246 190 189
f 189 242 246
f 254 204 190
f 190 246 254
f 257 211 204
f 204 254 257
f 264 214 211
f 211 257 264
f 268 226 214
f 214 264 268
f 274 232 226
f 226 268 274
f 278 237 232
f 232 274 278
f 280 241 237
f 237 278 280
f 283 243 241
f 241 280 283
f 285 248 243
f 243 283 285
f 294 246 242
f 242 292 294
f 296 254 246
f 246 294 296
f 300 257 254
f 254 296 300
f 304 264 257
f 257 300 304
f 306 268 264
f 264 304 306
f 308 274 268
f 268 306 308
f 310 278 274
f 274 308 310
f 313 280 278
f 278 310 313
f 314 283 280
f 280 313 314
f 317 285 283
f 283 314 317
f 356 294 292
f 292 358 356
f 354 296 294
f 294 356 354
f 352 300 296
f 296 354 352
f 350 304 300
f 300 352 350
f 348 306 304
f 304 350 348
f 346 308 306
f 306 348 346
f 344 310 308
f 308 346 344
f 342 313 310
f 310 344 342
f 340 314 313
f 313 342 340
f 338 317 314
f 314 340 338
f 424 356 358
f 358 426 424
f 422 354 356
f 356 424 422
f 418 352 354
f 354 422 418
f 414 350 352
f 352 418 414
f 407 348 350
f 350 414 407
f 402 346 348
f 348 407 402
f 393 344 346
f 346 402 393
f 383 342 344
f 344 393 383
f 377 340 342
f 342 383 377
f 375 338 340
f 340 377 375
f 3186 3113 3115
f 3115 3182 3186
f 3192 3110 3113
f 3113 3186 3192
f 3196 3109 3110
f 3110 3192 3196
f 3205 3106 3109
f 3109 3196 3205
f 3211 3104 3106
f 3106 3205 3211
f 3215 3102 3104
f 3104 3211 3215
f 3217 3101 3102
f 3102 3215 3217
f 3220 3098 3101
f 3101 3217 3220
f 3222 3097 3098
f 3098 3220 3222
f 3223 3095 3097
f 3097 3222 3223
f 3227 3186 3182
f 3182 3225 3227
f 3229 3192 3186
f 3186 3227 3229
f 3231 3196 3192
f 3192 3229 3231
f 3233 3205 3196
f 3196 3231 3233
f 3235 3211 3205
f 3205 3233 3235
f 3241 3215 3211
f 3211 3235 3241
f 3245 3217 3215
f 3215 3241 3245
f 3249 3220 3217
f 3217 3245 3249
f 3251 3222 3220
f 3220 3249 3251
f 3253 3223 3222
f 3222 3251 3253
f 3239 3227 3225
f 3225 3237 3239
f 3243 3229 3227
f 3227 3239 3243
f 3247 3231 3229
f 3229 3243 3247
f 3257 3233 3231
f 3231 3247 3257
f 3263 3235 3233
f 3233 3257 3263
f 3271 3241 3235
f 3235 3263 3271
f 3279 3245 3241
f 3241 3271 3279
f 3285 3249 3245
f 3245 3279 3285
f 3293 3251 3249
f 3249 3285 3293
f 3297 3253 3251
f 3251 3293 3297
f 3259 3239 3237
f 3237 3255 3259
f 3261 3243 3239
f 3239 3259 3261
f 3265 3247 3243
f 3243 3261 3265
f 3275 3257 3247
f 3247 3265 3275
f 3287 3263 3257
f 3257 3275 3287
f 3303 3271 3263
f 3263 3287 3303
f 3314 3279 3271
f 3271 3303 3314
f 3320 3285 3279
f 3279 3314 3320
f 3330 3293 3285
f 3285 3320 3330
f 3332 3297 3293
f 3293 3330 3332
f 3270 3259 3255
f 3255 3268 3270
f 3273 3261 3259
f 3259 3270 3273
f 3283 3265 3261
f 3261 3273 3283
f 3299 3275 3265
f 3265 3283 3299
f 3308 3287 3275
f 3275 3299 3308
f 3322 3303 3287
f 3287 3308 3322
f 3338 3314 3303
f 3303 3322 3338
f 3346 3320 3314
f 3314 3338 3346
f 3351 3330 3320
f 3320 3346 3351
f 3355 3332 3330
f 3330 3351 3355
f 3282 3270 3268
f 3268 3278 3282
f 3290 3273 3270
f 3270 3282 3290
f 3302 3283 3273
f 3273 3290 3302
f 3312 3299 3283
f 3283 3302 3312
f 3324 3308 3299
f 3299 3312 3324
f 3340 3322 3308
f 3308 3324 3340
f 3353 3338 3322
f 3322 3340 3353
f 3368 3346 3338
f 3338 3353 3368
f 3373 3351 3346
f 3346 3368 3373
f 3379 3355 3351
f 3351 3373 3379
f 3295 3282 3278
f 3278 3292 3295
f 3306 3290 3282
f 3282 3295 3306
f 3316 3302 3290
f 3290 3306 3316
f 3326 3312 3302
f 3302 3316 3326
f 3345 3324 3312
f 3312 3326 3345
f 3359 3340 3324
f 3324 3345 3359
f 3376 3353 3340
f 3340 3359 3376
f 3394 3368 3353
f 3353 3376 3394
f 3404 3373 3368
f 3368 3394 3404
f 3406 3379 3373
f 3373 3404 3406
f 3310 3295 3292
f 3292 3307 3310
f 3318 3306 3295
f 3295 3310 3318
f 3336 3316 3306
f 3306 3318 3336
f 3348 3326 3316
f 3316 3336 3348
f 3369 3345 3326
f 3326 3348 3369
f 3389 3359 3345
f 3345 3369 3389
f 3425 3376 3359
f 3359 3389 3425
f 3449 3394 3376
f 3376 3425 3449
f 3468 3404 3394
f 3394 3449 3468
f 3472 3406 3404
f 3404 3468 3472
f 3335 3310 3307
f 3307 3329 3335
f 3343 3318 3310
f 3310 3335 3343
f 3362 3336 3318
f 3318 3343 3362
f 3386 3348 3336
f 3336 3362 3386
f 3422 3369 3348
f 3348 3386 3422
f 3464 3389 3369
f 3369 3422 3464
f 3490 3425 3389
f 3389 3464 3490
f 3505 3449 3425
f 3425 3490 3505
f 3521 3468 3449
f 3449 3505 3521
f 3523 3472 3468
f 3468 3521 3523
f 3364 3335 3329
f 3329 3357 3364
f 3382 3343 3335
f 3335 3364 3382
f 3416 3362 3343
f 3343 3382 3416
f 3465 3386 3362
f 3362 3416 3465
f 3495 3422 3386
f 3386 3465 3495
f 3528 3464 3422
f 3422 3495 3528
f 3553 3490 3464
f 3464 3528 3553
f 3579 3505 3490
f 3490 3553 3579
f 3592 3521 3505
f 3505 3579 3592
f 3604 3523 3521
f 3521 3592 3604
f 3221 3096 3094
f 3094 3224 3221
f 3219 3099 3096
f 3096 3221 3219
f 3218 3100 3099
f 3099 3219 3218
f 3216 3103 3100
f 3100 3218 3216
f 3212 3105 3103
f 3103 3216 3212
f 3206 3107 3105
f 3105 3212 3206
f 3197 3108 3107
f 3107 3206 3197
f 3193 3111 3108
f 3108 3197 3193
f 3187 3112 3111
f 3111 3193 3187
f 3183 3114 3112
f 3112 3187 3183
f 3252 3221 3224
f 3224 3254 3252
f 3250 3219 3221
f 3221 3252 3250
f 3246 3218 3219
f 3219 3250 3246
f 3242 3216 3218
f 3218 3246 3242
f 3236 3212 3216
f 3216 3242 3236
f 3234 3206 3212
f 3212 3236 3234
f 3232 3197 3206
f 3206 3234 3232
f 3230 3193 3197
f 3197 3232 3230
f 3228 3187 3193
f 3193 3230 3228
f 3226 3183 3187
f 3187 3228 3226
f 3294 3252 3254
f 3254 3298 3294
f 3286 3250 3252
f 3252 3294 3286
f 3280 3246 3250
f 3250 3286 3280
f 3272 3242 3246
f 3246 3280 3272
f 3264 3236 3242
f 3242 3272 3264
f 3258 3234 3236
f 3236 3264 3258
f 3248 3232 3234
f 3234 3258 3248
f 3244 3230 3232
f 3232 3248 3244
f 3240 3228 3230
f 3230 3244 3240
f 3238 3226 3228
f 3228 3240 3238
f 3331 3294 3298
f 3298 3333 3331
f 3321 3286 3294
f 3294 3331 3321
f 3315 3280 3286
f 3286 3321 3315
f 3304 3272 3280
f 3280 3315 3304
f 3288 3264 3272
f 3272 3304 3288
f 3276 3258 3264
f 3264 3288 3276
f 3266 3248 3258
f 3258 3276 3266
f 3262 3244 3248
f 3248 3266 3262
f 3260 3240 3244
f 3244 3262 3260
f 3256 3238 3240
f 3240 3260 3256
f 3350 3331 3333
f 3333 3354 3350
f 3347 3321 3331
f 3331 3350 3347
f 3339 3315 3321
f 3321 3347 3339
f 3323 3304 3315
f 3315 3339 3323
f 3309 3288 3304
f 3304 3323 3309
f 3300 3276 3288
f 3288 3309 3300
f 3284 3266 3276
f 3276 3300 3284
f 3274 3262 3266
f 3266 3284 3274
f 3269 3260 3262
f 3262 3274 3269
f 3267 3256 3260
f 3260 3269 3267
f 3372 3350 3354
f 3354 3378 3372
f 3367 3347 3350
f 3350 3372 3367
f 3352 3339 3347
f 3347 3367 3352
f 3341 3323 3339
f 3339 3352 3341
f 3325 3309 3323
f 3323 3341 3325
f 3313 3300 3309
f 3309 3325 3313
f 3301 3284 3300
f 3300 3313 3301
f 3289 3274 3284
f 3284 3301 3289
f 3281 3269 3274
f 3274 3289 3281
f 3277 3267 3269
f 3269 3281 3277
f 3403 3372 3378
f 3378 3405 3403
f 3393 3367 3372
f 3372 3403 3393
f 3377 3352 3367
f 3367 3393 3377
f 3360 3341 3352
f 3352 3377 3360
f 3344 3325 3341
f 3341 3360 3344
f 3327 3313 3325
f 3325 3344 3327
f 3317 3301 3313
f 3313 3327 3317
f 3305 3289 3301
f 3301 3317 3305
f 3296 3281 3289
f 3289 3305 3296
f 3291 3277 3281
f 3281 3296 3291
f 3469 3403 3405
f 3405 3472 3469
f 3450 3393 3403
f 3403 3469 3450
f 3426 3377 3393
f 3393 3450 3426
f 3390 3360 3377
f 3377 3426 3390
f 3370 3344 3360
f 3360 3390 3370
f 3349 3327 3344
f 3344 3370 3349
f 3337 3317 3327
f 3327 3349 3337
f 3319 3305 3317
f 3317 3337 3319
f 3311 3296 3305
f 3305 3319 3311
f 3307 3291 3296
f 3296 3311 3307
f 3520 3469 3472
f 3472 3522 3520
f 3504 3450 3469
f 3469 3520 3504
f 3489 3426 3450
f 3450 3504 3489
f 3463 3390 3426
f 3426 3489 3463
f 3421 3370 3390
f 3390 3463 3421
f 3385 3349 3370
f 3370 3421 3385
f 3361 3337 3349
f 3349 3385 3361
f 3342 3319 3337
f 3337 3361 3342
f 3334 3311 3319
f 3319 3342 3334
f 3328 3307 3311
f 3311 3334 3328
f 3591 3520 3522
f 3522 3603 3591
f 3578 3504 3520
f 3520 3591 3578
f 3552 3489 3504
f 3504 3578 3552
f 3530 3463 3489
f 3489 3552 3530
f 3499 3421 3463
f 3463 3530 3499
f 3467 3385 3421
f 3421 3499 3467
f 3415 3361 3385
f 3385 3467 3415
f 3381 3342 3361
f 3361 3415 3381
f 3363 3334 3342
f 3342 3381 3363
f 3356 3328 3334
f 3334 3363 3356
f 3374 3365 3358
f 3358 3371 3374
f 3395 3383 3365
f 3365 3374 3395
f 3443 3417 3383
f 3383 3395 3443
f 3481 3466 3417
f 3417 3443 3481
f 3514 3496 3466
f 3466 3481 3514
f 3545 3529 3496
f 3496 3514 3545
f 3573 3551 3529
f 3529 3545 3573
f 3597 3577 3551
f 3551 3573 3597
f 3613 3590 3577
f 3577 3597 3613
f 3619 3603 3590
f 3590 3613 3619
f 3387 3374 3371
f 3371 3380 3387
f 3413 3395 3374
f 3374 3387 3413
f 3461 3443 3395
f 3395 3413 3461
f 3493 3481 3443
f 3443 3461 3493
f 3524 3514 3481
f 3481 3493 3524
f 3556 3545 3514
f 3514 3524 3556
f 3584 3573 3545
f 3545 3556 3584
f 3611 3597 3573
f 3573 3584 3611
f 3628 3613 3597
f 3597 3611 3628
f 3632 3619 3613
f 3613 3628 3632
f 3398 3387 3380
f 3380 3391 3398
f 3435 3413 3387
f 3387 3398 3435
f 3473 3461 3413
f 3413 3435 3473
f 3500 3493 3461
f 3461 3473 3500
f 3531 3524 3493
f 3493 3500 3531
f 3562 3556 3524
f 3524 3531 3562
f 3595 3584 3556
f 3556 3562 3595
f 3617 3611 3584
f 3584 3595 3617
f 3633 3628 3611
f 3611 3617 3633
f 3641 3632 3628
f 3628 3633 3641
f 3409 3398 3391
f 3391 3400 3409
f 3447 3435 3398
f 3398 3409 3447
f 3477 3473 3435
f 3435 3447 3477
f 3506 3500 3473
f 3473 3477 3506
f 3540 3531 3500
f 3500 3506 3540
f 3567 3562 3531
f 3531 3540 3567
f 3601 3595 3562
f 3562 3567 3601
f 3624 3617 3595
f 3595 3601 3624
f 3639 3633 3617
f 3617 3624 3639
f 3644 3641 3633
f 3633 3639 3644
f 3433 3409 3400
f 3400 3411 3433
f 3453 3447 3409
f 3409 3433 3453
f 3483 3477 3447
f 3447 3453 3483
f 3510 3506 3477
f 3477 3483 3510
f 3543 3540 3506
f 3506 3510 3543
f 3569 3567 3540
f 3540 3543 3569
f 3599 3601 3567
f 3567 3569 3599
f 3622 3624 3601
f 3601 3599 3622
f 3637 3639 3624
f 3624 3622 3637
f 3642 3644 3639
f 3639 3637 3642
f 3439 3433 3411
f 3411 3424 3439
f 3458 3453 3433
f 3433 3439 3458
f 3487 3483 3453
f 3453 3458 3487
f 3513 3510 3483
f 3483 3487 3513
f 3542 3543 3510
f 3510 3513 3542
f 3566 3569 3543
f 3543 3542 3566
f 3593 3599 3569
f 3569 3566 3593
f 3616 3622 3599
f 3599 3593 3616
f 3630 3637 3622
f 3622 3616 3630
f 3636 3642 3637
f 3637 3630 3636
f 3441 3439 3424
f 3424 3429 3441
f 3459 3458 3439
f 3439 3441 3459
f 3485 3487 3458
f 3458 3459 3485
f 3508 3513 3487
f 3487 3485 3508
f 3533 3542 3513
f 3513 3508 3533
f 3558 3566 3542
f 3542 3533 3558
f 3582 3593 3566
f 3566 3558 3582
f 3607 3616 3593
f 3593 3582 3607
f 3620 3630 3616
f 3616 3607 3620
f 3626 3636 3630
f 3630 3620 3626
f 3437 3441 3429
f 3429 3427 3437
f 3455 3459 3441
f 3441 3437 3455
f 3479 3485 3459
f 3459 3455 3479
f 3502 3508 3485
f 3485 3479 3502
f 3526 3533 3508
f 3508 3502 3526
f 3547 3558 3533
f 3533 3526 3547
f 3571 3582 3558
f 3558 3547 3571
f 3588 3607 3582
f 3582 3571 3588
f 3605 3620 3607
f 3607 3588 3605
f 3609 3626 3620
f 3620 3605 3609
f 3419 3437 3427
f 3427 3408 3419
f 3445 3455 3437
f 3437 3419 3445
f 3470 3479 3455
f 3455 3445 3470
f 3492 3502 3479
f 3479 3470 3492
f 3517 3526 3502
f 3502 3492 3517
f 3536 3547 3526
f 3526 3517 3536
f 3554 3571 3547
f 3547 3536 3554
f 3575 3588 3571
f 3571 3554 3575
f 3580 3605 3588
f 3588 3575 3580
f 3587 3609 3605
f 3605 3580 3587
f 3401 3419 3408
f 3408 3397 3401
f 3431 3445 3419
f 3419 3401 3431
f 3451 3470 3445
f 3445 3431 3451
f 3475 3492 3470
f 3470 3451 3475
f 3497 3517 3492
f 3492 3475 3497
f 3518 3536 3517
f 3517 3497 3518
f 3537 3554 3536
f 3536 3518 3537
f 3549 3575 3554
f 3554 3537 3549
f 3560 3580 3575
f 3575 3549 3560
f 3564 3587 3580
f 3580 3560 3564
f 3614 3591 3603
f 3603 3619 3614
f 3598 3578 3591
f 3591 3614 3598
f 3574 3552 3578
f 3578 3598 3574
f 3546 3530 3552
f 3552 3574 3546
f 3515 3499 3530
f 3530 3546 3515
f 3482 3467 3499
f 3499 3515 3482
f 3444 3418 3467
f 3467 3482 3444
f 3396 3384 3418
f 3418 3444 3396
f 3375 3366 3384
f 3384 3396 3375
f 3371 3358 3366
f 3366 3375 3371
f 3629 3614 3619
f 3619 3632 3629
f 3612 3598 3614
f 3614 3629 3612
f 3585 3574 3598
f 3598 3612 3585
f 3557 3546 3574
f 3574 3585 3557
f 3525 3515 3546
f 3546 3557 3525
f 3494 3482 3515
f 3515 3525 3494
f 3462 3444 3482
f 3482 3494 3462
f 3414 3396 3444
f 3444 3462 3414
f 3388 3375 3396
f 3396 3414 3388
f 3380 3371 3375
f 3375 3388 3380
f 3634 3629 3632
f 3632 3641 3634
f 3618 3612 3629
f 3629 3634 3618
f 3596 3585 3612
f 3612 3618 3596
f 3563 3557 3585
f 3585 3596 3563
f 3532 3525 3557
f 3557 3563 3532
f 3501 3494 3525
f 3525 3532 3501
f 3474 3462 3494
f 3494 3501 3474
f 3436 3414 3462
f 3462 3474 3436
f 3399 3388 3414
f 3414 3436 3399
f 3392 3380 3388
f 3388 3399 3392
f 3640 3634 3641
f 3641 3644 3640
f 3625 3618 3634
f 3634 3640 3625
f 3602 3596 3618
f 3618 3625 3602
f 3568 3563 3596
f 3596 3602 3568
f 3539 3532 3563
f 3563 3568 3539
f 3507 3501 3532
f 3532 3539 3507
f 3478 3474 3501
f 3501 3507 3478
f 3448 3436 3474
f 3474 3478 3448
f 3410 3399 3436
f 3436 3448 3410
f 3400 3392 3399
f 3399 3410 3400
f 3638 3640 3644
f 3644 3643 3638
f 3623 3625 3640
f 3640 3638 3623
f 3600 3602 3625
f 3625 3623 3600
f 3570 3568 3602
f 3602 3600 3570
f 3544 3539 3568
f 3568 3570 3544
f 3511 3507 3539
f 3539 3544 3511
f 3484 3478 3507
f 3507 3511 3484
f 3454 3448 3478
f 3478 3484 3454
f 3434 3410 3448
f 3448 3454 3434
f 3412 3400 3410
f 3410 3434 3412
f 3631 3638 3643
f 3643 3635 3631
f 3615 3623 3638
f 3638 3631 3615
f 3594 3600 3623
f 3623 3615 3594
f 3565 3570 3600
f 3600 3594 3565
f 3541 3544 3570
f 3570 3565 3541
f 3512 3511 3544
f 3544 3541 3512
f 3488 3484 3511
f 3511 3512 3488
f 3457 3454 3484
f 3484 3488 3457
f 3440 3434 3454
f 3454 3457 3440
f 3423 3412 3434
f 3434 3440 3423
f 3621 3631 3635
f 3635 3627 3621
f 3608 3615 3631
f 3631 3621 3608
f 3583 3594 3615
f 3615 3608 3583
f 3559 3565 3594
f 3594 3583 3559
f 3534 3541 3565
f 3565 3559 3534
f 3509 3512 3541
f 3541 3534 3509
f 3486 3488 3512
f 3512 3509 3486
f 3460 3457 3488
f 3488 3486 3460
f 3442 3440 3457
f 3457 3460 3442
f 3430 3423 3440
f 3440 3442 3430
f 3606 3621 3627
f 3627 3610 3606
f 3589 3608 3621
f 3621 3606 3589
f 3572 3583 3608
f 3608 3589 3572
f 3548 3559 3583
f 3583 3572 3548
f 3527 3534 3559
f 3559 3548 3527
f 3503 3509 3534
f 3534 3527 3503
f 3480 3486 3509
f 3509 3503 3480
f 3456 3460 3486
f 3486 3480 3456
f 3438 3442 3460
f 3460 3456 3438
f 3428 3430 3442
f 3442 3438 3428
f 3581 3606 3610
f 3610 3586 3581
f 3576 3589 3606
f 3606 3581 3576
f 3555 3572 3589
f 3589 3576 3555
f 3535 3548 3572
f 3572 3555 3535
f 3516 3527 3548
f 3548 3535 3516
f 3491 3503 3527
f 3527 3516 3491
f 3471 3480 3503
f 3503 3491 3471
f 3446 3456 3480
f 3480 3471 3446
f 3420 3438 3456
f 3456 3446 3420
f 3407 3428 3438
f 3438 3420 3407
f 3561 3581 3586
f 3586 3564 3561
f 3550 3576 3581
f 3581 3561 3550
f 3538 3555 3576
f 3576 3550 3538
f 3519 3535 3555
f 3555 3538 3519
f 3498 3516 3535
f 3535 3519 3498
f 3476 3491 3516
f 3516 3498 3476
f 3452 3471 3491
f 3491 3476 3452
f 3432 3446 3471
f 3471 3452 3432
f 3402 3420 3446
f 3446 3432 3402
f 3397 3407 3420
f 3420 3402 3397
f 1888 2110 2104
f 1888 2104 2096
f 1888 2096 2076
f 1888 2076 2048
f 1888 2048 2030
f 1888 2030 2006
f 1888 2006 1982
f 1888 1982 1960
f 1888 1960 1936
f 1888 1936 1732
f 2257 2104 2110
f 2110 2261 2257
f 2249 2096 2104
f 2104 2257 2249
f 2226 2076 2096
f 2096 2249 2226
f 2200 2048 2076
f 2076 2226 2200
f 2142 2030 2048
f 2048 2200 2142
f 2094 2006 2030
f 2030 2142 2094
f 2036 1982 2006
f 2006 2094 2036
f 1988 1960 1982
f 1982 2036 1988
f 1948 1936 1960
f 1960 1988 1948
f 1728 1732 1936
f 1936 1948 1728
f 2310 2257 2261
f 2261 2315 2310
f 2300 2249 2257
f 2257 2310 2300
f 2279 2226 2249
f 2249 2300 2279
f 2243 2200 2226
f 2226 2279 2243
f 2204 2142 2200
f 2200 2243 2204
f 2132 2094 2142
f 2142 2204 2132
f 2067 2036 2094
f 2094 2132 2067
f 2000 1988 2036
f 2036 2067 2000
f 1956 1948 1988
f 1988 2000 1956
f 1734 1728 1948
f 1948 1956 1734
f 2312 2310 2315
f 2315 2316 2312
f 2302 2300 2310
f 2310 2312 2302
f 2281 2279 2300
f 2300 2302 2281
f 2245 2243 2279
f 2279 2281 2245
f 2206 2204 2243
f 2243 2245 2206
f 2134 2132 2204
f 2204 2206 2134
f 2068 2067 2132
f 2132 2134 2068
f 2002 2000 2067
f 2067 2068 2002
f 1958 1956 2000
f 2000 2002 1958
f 1878 1734 1956
f 1956 1958 1878
f 2285 2312 2316
f 2316 2289 2285
f 2259 2302 2312
f 2312 2285 2259
f 2241 2281 2302
f 2302 2259 2241
f 2214 2245 2281
f 2281 2241 2214
f 2168 2206 2245
f 2245 2214 2168
f 2106 2134 2206
f 2206 2168 2106
f 2042 2068 2134
f 2134 2106 2042
f 1994 2002 2068
f 2068 2042 1994
f 1952 1958 2002
f 2002 1994 1952
f 1731 1878 1958
f 1958 1952 1731
f 2220 2285 2289
f 2289 2225 2220
f 2210 2259 2285
f 2285 2220 2210
f 2186 2241 2259
f 2259 2210 2186
f 2146 2214 2241
f 2241 2186 2146
f 2108 2168 2214
f 2214 2146 2108
f 2060 2106 2168
f 2168 2108 2060
f 2018 2042 2106
f 2106 2060 2018
f 1978 1994 2042
f 2042 2018 1978
f 1944 1952 1994
f 1994 1978 1944
f 1727 1731 1952
f 1952 1944 1727
f 2141 2220 2225
f 2225 2145 2141
f 2127 2210 2220
f 2220 2141 2127
f 2112 2186 2210
f 2210 2127 2112
f 2084 2146 2186
f 2186 2112 2084
f 2044 2108 2146
f 2146 2084 2044
f 2024 2060 2108
f 2108 2044 2024
f 1992 2018 2060
f 2060 2024 1992
f 1970 1978 2018
f 2018 1992 1970
f 1942 1944 1978
f 1978 1970 1942
f 1721 1727 1944
f 1944 1942 1721
f 2079 2141 2145
f 2145 2087 2079
f 2075 2127 2141
f 2141 2079 2075
f 2055 2112 2127
f 2127 2075 2055
f 2039 2084 2112
f 2112 2055 2039
f 2021 2044 2084
f 2084 2039 2021
f 1996 2024 2044
f 2044 2021 1996
f 1974 1992 2024
f 2024 1996 1974
f 1954 1970 1992
f 1992 1974 1954
f 1934 1942 1970
f 1970 1954 1934
f 1720 1721 1942
f 1942 1934 1720
f 2063 2079 2087
f 2087 2071 2063
f 2051 2075 2079
f 2079 2063 2051
f 2041 2055 2075
f 2075 2051 2041
f 2029 2039 2055
f 2055 2041 2029
f 2013 2021 2039
f 2039 2029 2013
f 1991 1996 2021
f 2021 2013 1991
f 1972 1974 1996
f 1996 1991 1972
f 1950 1954 1974
f 1974 1972 1950
f 1932 1934 1954
f 1954 1950 1932
f 1701 1720 1934
f 1934 1932 1701
f 2115 2063 2071
f 2071 2123 2115
f 2101 2051 2063
f 2063 2115 2101
f 2081 2041 2051
f 2051 2101 2081
f 2057 2029 2041
f 2041 2081 2057
f 2033 2013 2029
f 2029 2057 2033
f 2009 1991 2013
f 2013 2033 2009
f 1984 1972 1991
f 1991 2009 1984
f 1964 1950 1972
f 1972 1984 1964
f 1938 1932 1950
f 1950 1964 1938
f 1698 1701 1932
f 1932 1938 1698
f 1888 1886 1686
f 1888 1686 1662
f 1888 1662 1640
f 1888 1640 1616
f 1888 1616 1592
f 1888 1592 1574
f 1888 1574 1546
f 1888 1546 1526
f 1888 1526 1518
f 1888 1518 1512
f 1674 1686 1886
f 1886 1884 1674
f 1634 1662 1686
f 1686 1674 1634
f 1586 1640 1662
f 1662 1634 1586
f 1528 1616 1640
f 1640 1586 1528
f 1480 1592 1616
f 1616 1528 1480
f 1422 1574 1592
f 1592 1480 1422
f 1396 1546 1574
f 1574 1422 1396
f 1373 1526 1546
f 1546 1396 1373
f 1365 1518 1526
f 1526 1373 1365
f 1361 1512 1518
f 1518 1365 1361
f 1666 1674 1884
f 1884 1882 1666
f 1622 1634 1674
f 1674 1666 1622
f 1557 1586 1634
f 1634 1622 1557
f 1490 1528 1586
f 1586 1557 1490
f 1418 1480 1528
f 1528 1490 1418
f 1379 1422 1480
f 1480 1418 1379
f 1343 1396 1422
f 1422 1379 1343
f 1322 1373 1396
f 1396 1343 1322
f 1312 1365 1373
f 1373 1322 1312
f 1309 1361 1365
f 1365 1312 1309
f 1664 1666 1882
f 1882 1879 1664
f 1620 1622 1666
f 1666 1664 1620
f 1554 1557 1622
f 1622 1620 1554
f 1488 1490 1557
f 1557 1554 1488
f 1416 1418 1490
f 1490 1488 1416
f 1377 1379 1418
f 1418 1416 1377
f 1341 1343 1379
f 1379 1377 1341
f 1320 1322 1343
f 1343 1341 1320
f 1310 1312 1322
f 1322 1320 1310
f 1306 1309 1312
f 1312 1310 1306
f 1670 1664 1879
f 1879 1876 1670
f 1628 1620 1664
f 1664 1670 1628
f 1580 1554 1620
f 1620 1628 1580
f 1516 1488 1554
f 1554 1580 1516
f 1454 1416 1488
f 1488 1516 1454
f 1408 1377 1416
f 1416 1454 1408
f 1381 1341 1377
f 1377 1408 1381
f 1363 1320 1341
f 1341 1381 1363
f 1337 1310 1320
f 1320 1363 1337
f 1333 1306 1310
f 1310 1337 1333
f 1678 1670 1876
f 1876 1874 1678
f 1644 1628 1670
f 1670 1678 1644
f 1604 1580 1628
f 1628 1644 1604
f 1562 1516 1580
f 1580 1604 1562
f 1514 1454 1516
f 1516 1562 1514
f 1476 1408 1454
f 1454 1514 1476
f 1436 1381 1408
f 1408 1476 1436
f 1412 1363 1381
f 1381 1436 1412
f 1402 1337 1363
f 1363 1412 1402
f 1399 1333 1337
f 1337 1402 1399
f 1680 1678 1874
f 1874 1872 1680
f 1652 1644 1678
f 1678 1680 1652
f 1630 1604 1644
f 1644 1652 1630
f 1598 1562 1604
f 1604 1630 1598
f 1578 1514 1562
f 1562 1598 1578
f 1538 1476 1514
f 1514 1578 1538
f 1510 1436 1476
f 1476 1538 1510
f 1497 1412 1436
f 1436 1510 1497
f 1483 1402 1412
f 1412 1497 1483
f 1479 1399 1402
f 1402 1483 1479
f 1688 1680 1872
f 1872 1870 1688
f 1668 1652 1680
f 1680 1688 1668
f 1648 1630 1652
f 1652 1668 1648
f 1626 1598 1630
f 1630 1648 1626
f 1603 1578 1598
f 1598 1626 1603
f 1585 1538 1578
f 1578 1603 1585
f 1569 1510 1538
f 1538 1585 1569
f 1549 1497 1510
f 1510 1569 1549
f 1545 1483 1497
f 1497 1549 1545
f 1537 1479 1483
f 1483 1545 1537
f 1690 1688 1870
f 1870 1868 1690
f 1672 1668 1688
f 1688 1690 1672
f 1650 1648 1668
f 1668 1672 1650
f 1633 1626 1648
f 1648 1650 1633
f 1611 1603 1626
f 1626 1633 1611
f 1595 1585 1603
f 1603 1611 1595
f 1583 1569 1585
f 1585 1595 1583
f 1573 1549 1569
f 1569 1583 1573
f 1561 1545 1549
f 1549 1573 1561
f 1553 1537 1545
f 1545 1561 1553
f 1684 1690 1868
f 1868 1865 1684
f 1658 1672 1690
f 1690 1684 1658
f 1638 1650 1672
f 1672 1658 1638
f 1615 1633 1650
f 1650 1638 1615
f 1591 1611 1633
f 1633 1615 1591
f 1567 1595 1611
f 1611 1591 1567
f 1543 1583 1595
f 1595 1567 1543
f 1523 1573 1583
f 1583 1543 1523
f 1509 1561 1573
f 1573 1523 1509
f 1501 1553 1561
f 1561 1509 1501
f 1888 1513 1519
f 1888 1519 1527
f 1888 1527 1547
f 1888 1547 1575
f 1888 1575 1593
f 1888 1593 1617
f 1888 1617 1641
f 1888 1641 1663
f 1888 1663 1687
f 1888 1687 1894
f 1366 1519 1513
f 1513 1362 1366
f 1374 1527 1519
f 1519 1366 1374
f 1397 1547 1527
f 1527 1374 1397
f 1423 1575 1547
f 1547 1397 1423
f 1481 1593 1575
f 1575 1423 1481
f 1529 1617 1593
f 1593 1481 1529
f 1587 1641 1617
f 1617 1529 1587
f 1635 1663 1641
f 1641 1587 1635
f 1675 1687 1663
f 1663 1635 1675
f 1895 1894 1687
f 1687 1675 1895
f 1313 1366 1362
f 1362 1308 1313
f 1323 1374 1366
f 1366 1313 1323
f 1344 1397 1374
f 1374 1323 1344
f 1380 1423 1397
f 1397 1344 1380
f 1419 1481 1423
f 1423 1380 1419
f 1491 1529 1481
f 1481 1419 1491
f 1556 1587 1529
f 1529 1491 1556
f 1623 1635 1587
f 1587 1556 1623
f 1667 1675 1635
f 1635 1623 1667
f 1890 1895 1675
f 1675 1667 1890
f 1311 1313 1308
f 1308 1307 1311
f 1321 1323 1313
f 1313 1311 1321
f 1342 1344 1323
f 1323 1321 1342
f 1378 1380 1344
f 1344 1342 1378
f 1417 1419 1380
f 1380 1378 1417
f 1489 1491 1419
f 1419 1417 1489
f 1555 1556 1491
f 1491 1489 1555
f 1621 1623 1556
f 1556 1555 1621
f 1665 1667 1623
f 1623 1621 1665
f 1881 1890 1667
f 1667 1665 1881
f 1338 1311 1307
f 1307 1334 1338
f 1364 1321 1311
f 1311 1338 1364
f 1382 1342 1321
f 1321 1364 1382
f 1409 1378 1342
f 1342 1382 1409
f 1455 1417 1378
f 1378 1409 1455
f 1517 1489 1417
f 1417 1455 1517
f 1581 1555 1489
f 1489 1517 1581
f 1629 1621 1555
f 1555 1581 1629
f 1671 1665 1621
f 1621 1629 1671
f 1893 1881 1665
f 1665 1671 1893
f 1403 1338 1334
f 1334 1398 1403
f 1413 1364 1338
f 1338 1403 1413
f 1437 1382 1364
f 1364 1413 1437
f 1477 1409 1382
f 1382 1437 1477
f 1515 1455 1409
f 1409 1477 1515
f 1563 1517 1455
f 1455 1515 1563
f 1605 1581 1517
f 1517 1563 1605
f 1645 1629 1581
f 1581 1605 1645
f 1679 1671 1629
f 1629 1645 1679
f 1900 1893 1671
f 1671 1679 1900
f 1482 1403 1398
f 1398 1478 1482
f 1496 1413 1403
f 1403 1482 1496
f 1511 1437 1413
f 1413 1496 1511
f 1539 1477 1437
f 1437 1511 1539
f 1579 1515 1477
f 1477 1539 1579
f 1599 1563 1515
f 1515 1579 1599
f 1631 1605 1563
f 1563 1599 1631
f 1653 1645 1605
f 1605 1631 1653
f 1681 1679 1645
f 1645 1653 1681
f 1902 1900 1679
f 1679 1681 1902
f 1544 1482 1478
f 1478 1536 1544
f 1548 1496 1482
f 1482 1544 1548
f 1568 1511 1496
f 1496 1548 1568
f 1584 1539 1511
f 1511 1568 1584
f 1602 1579 1539
f 1539 1584 1602
f 1627 1599 1579
f 1579 1602 1627
f 1649 1631 1599
f 1599 1627 1649
f 1669 1653 1631
f 1631 1649 1669
f 1689 1681 1653
f 1653 1669 1689
f 1921 1902 1681
f 1681 1689 1921
f 1560 1544 1536
f 1536 1552 1560
f 1572 1548 1544
f 1544 1560 1572
f 1582 1568 1548
f 1548 1572 1582
f 1594 1584 1568
f 1568 1582 1594
f 1610 1602 1584
f 1584 1594 1610
f 1632 1627 1602
f 1602 1610 1632
f 1651 1649 1627
f 1627 1632 1651
f 1673 1669 1649
f 1649 1651 1673
f 1691 1689 1669
f 1669 1673 1691
f 1922 1921 1689
f 1689 1691 1922
f 1508 1560 1552
f 1552 1500 1508
f 1522 1572 1560
f 1560 1508 1522
f 1542 1582 1572
f 1572 1522 1542
f 1566 1594 1582
f 1582 1542 1566
f 1590 1610 1594
f 1594 1566 1590
f 1614 1632 1610
f 1610 1590 1614
f 1639 1651 1632
f 1632 1614 1639
f 1659 1673 1651
f 1651 1639 1659
f 1685 1691 1673
f 1673 1659 1685
f 1928 1922 1691
f 1691 1685 1928
f 1888 1887 1937
f 1888 1937 1961
f 1888 1961 1983
f 1888 1983 2007
f 1888 2007 2031
f 1888 2031 2049
f 1888 2049 2077
f 1888 2077 2097
f 1888 2097 2105
f 1888 2105 2111
f 1949 1937 1887
f 1887 1885 1949
f 1989 1961 1937
f 1937 1949 1989
f 2037 1983 1961
f 1961 1989 2037
f 2095 2007 1983
f 1983 2037 2095
f 2143 2031 2007
f 2007 2095 2143
f 2201 2049 2031
f 2031 2143 2201
f 2227 2077 2049
f 2049 2201 2227
f 2250 2097 2077
f 2077 2227 2250
f 2258 2105 2097
f 2097 2250 2258
f 2262 2111 2105
f 2105 2258 2262
f 1957 1949 1885
f 1885 1883 1957
f 2001 1989 1949
f 1949 1957 2001
f 2066 2037 1989
f 1989 2001 2066
f 2133 2095 2037
f 2037 2066 2133
f 2205 2143 2095
f 2095 2133 2205
f 2244 2201 2143
f 2143 2205 2244
f 2280 2227 2201
f 2201 2244 2280
f 2301 2250 2227
f 2227 2280 2301
f 2311 2258 2250
f 2250 2301 2311
f 2314 2262 2258
f 2258 2311 2314
f 1959 1957 1883
f 1883 1880 1959
f 2003 2001 1957
f 1957 1959 2003
f 2069 2066 2001
f 2001 2003 2069
f 2135 2133 2066
f 2066 2069 2135
f 2207 2205 2133
f 2133 2135 2207
f 2246 2244 2205
f 2205 2207 2246
f 2282 2280 2244
f 2244 2246 2282
f 2303 2301 2280
f 2280 2282 2303
f 2313 2311 2301
f 2301 2303 2313
f 2317 2314 2311
f 2311 2313 2317
f 1953 1959 1880
f 1880 1877 1953
f 1995 2003 1959
f 1959 1953 1995
f 2043 2069 2003
f 2003 1995 2043
f 2107 2135 2069
f 2069 2043 2107
f 2169 2207 2135
f 2135 2107 2169
f 2215 2246 2207
f 2207 2169 2215
f 2242 2282 2246
f 2246 2215 2242
f 2260 2303 2282
f 2282 2242 2260
f 2286 2313 2303
f 2303 2260 2286
f 2290 2317 2313
f 2313 2286 2290
f 1945 1953 1877
f 1877 1875 1945
f 1979 1995 1953
f 1953 1945 1979
f 2019 2043 1995
f 1995 1979 2019
f 2061 2107 2043
f 2043 2019 2061
f 2109 2169 2107
f 2107 2061 2109
f 2147 2215 2169
f 2169 2109 2147
f 2187 2242 2215
f 2215 2147 2187
f 2211 2260 2242
f 2242 2187 2211
f 2221 2286 2260
f 2260 2211 2221
f 2224 2290 2286
f 2286 2221 2224
f 1943 1945 1875
f 1875 1873 1943
f 1971 1979 1945
f 1945 1943 1971
f 1993 2019 1979
f 1979 1971 1993
f 2025 2061 2019
f 2019 1993 2025
f 2045 2109 2061
f 2061 2025 2045
f 2085 2147 2109
f 2109 2045 2085
f 2113 2187 2147
f 2147 2085 2113
f 2126 2211 2187
f 2187 2113 2126
f 2140 2221 2211
f 2211 2126 2140
f 2144 2224 2221
f 2221 2140 2144
f 1935 1943 1873
f 1873 1871 1935
f 1955 1971 1943
f 1943 1935 1955
f 1975 1993 1971
f 1971 1955 1975
f 1997 2025 1993
f 1993 1975 1997
f 2020 2045 2025
f 2025 1997 2020
f 2038 2085 2045
f 2045 2020 2038
f 2054 2113 2085
f 2085 2038 2054
f 2074 2126 2113
f 2113 2054 2074
f 2078 2140 2126
f 2126 2074 2078
f 2086 2144 2140
f 2140 2078 2086
f 1933 1935 1871
f 1871 1869 1933
f 1951 1955 1935
f 1935 1933 1951
f 1973 1975 1955
f 1955 1951 1973
f 1990 1997 1975
f 1975 1973 1990
f 2012 2020 1997
f 1997 1990 2012
f 2028 2038 2020
f 2020 2012 2028
f 2040 2054 2038
f 2038 2028 2040
f 2050 2074 2054
f 2054 2040 2050
f 2062 2078 2074
f 2074 2050 2062
f 2070 2086 2078
f 2078 2062 2070
f 1939 1933 1869
f 1869 1866 1939
f 1965 1951 1933
f 1933 1939 1965
f 1985 1973 1951
f 1951 1965 1985
f 2008 1990 1973
f 1973 1985 2008
f 2032 2012 1990
f 1990 2008 2032
f 2056 2028 2012
f 2012 2032 2056
f 2080 2040 2028
f 2028 2056 2080
f 2100 2050 2040
f 2040 2080 2100
f 2114 2062 2050
f 2050 2100 2114
f 2122 2070 2062
f 2062 2114 2122
f 2232 2116 2124
f 2124 2236 2232
f 2218 2102 2116
f 2116 2232 2218
f 2199 2082 2102
f 2102 2218 2199
f 2150 2058 2082
f 2082 2199 2150
f 2120 2034 2058
f 2058 2150 2120
f 2064 2010 2034
f 2034 2120 2064
f 2023 1986 2010
f 2010 2064 2023
f 1980 1966 1986
f 1986 2023 1980
f 1946 1940 1966
f 1966 1980 1946
f 1862 1730 1940
f 1940 1946 1862
f 2332 2232 2236
f 2236 2336 2332
f 2322 2218 2232
f 2232 2332 2322
f 2306 2199 2218
f 2218 2322 2306
f 2275 2150 2199
f 2199 2306 2275
f 2234 2120 2150
f 2150 2275 2234
f 2170 2064 2120
f 2120 2234 2170
f 2093 2023 2064
f 2064 2170 2093
f 2016 1980 2023
f 2023 2093 2016
f 1968 1946 1980
f 1980 2016 1968
f 1858 1862 1946
f 1946 1968 1858
f 2409 2332 2336
f 2336 2413 2409
f 2400 2322 2332
f 2332 2409 2400
f 2376 2306 2322
f 2322 2400 2376
f 2349 2275 2306
f 2306 2376 2349
f 2324 2234 2275
f 2275 2349 2324
f 2271 2170 2234
f 2234 2324 2271
f 2185 2093 2170
f 2170 2271 2185
f 2072 2016 2093
f 2093 2185 2072
f 1976 1968 2016
f 2016 2072 1976
f 1729 1858 1968
f 1968 1976 1729
f 2488 2409 2413
f 2413 2498 2488
f 2470 2400 2409
f 2409 2488 2470
f 2444 2376 2400
f 2400 2470 2444
f 2418 2349 2376
f 2376 2444 2418
f 2384 2324 2349
f 2349 2418 2384
f 2338 2271 2324
f 2324 2384 2338
f 2269 2185 2271
f 2271 2338 2269
f 2138 2072 2185
f 2185 2269 2138
f 1998 1976 2072
f 2072 2138 1998
f 1722 1729 1976
f 1976 1998 1722
f 2559 2488 2498
f 2498 2569 2559
f 2549 2470 2488
f 2488 2559 2549
f 2531 2444 2470
f 2470 2549 2531
f 2492 2418 2444
f 2444 2531 2492
f 2436 2384 2418
f 2418 2492 2436
f 2394 2338 2384
f 2384 2436 2394
f 2326 2269 2338
f 2338 2394 2326
f 2212 2138 2269
f 2269 2326 2212
f 2026 1998 2138
f 2138 2212 2026
f 1850 1722 1998
f 1998 2026 1850
f 2653 2559 2569
f 2569 2655 2653
f 2631 2549 2559
f 2559 2653 2631
f 2593 2531 2549
f 2549 2631 2593
f 2551 2492 2531
f 2531 2593 2551
f 2510 2436 2492
f 2492 2551 2510
f 2432 2394 2436
f 2436 2510 2432
f 2366 2326 2394
f 2394 2432 2366
f 2263 2212 2326
f 2326 2366 2263
f 2052 2026 2212
f 2212 2263 2052
f 1726 1850 2026
f 2026 2052 1726
f 2720 2653 2655
f 2655 2726 2720
f 2697 2631 2653
f 2653 2720 2697
f 2662 2593 2631
f 2631 2697 2662
f 2607 2551 2593
f 2593 2662 2607
f 2547 2510 2551
f 2551 2607 2547
f 2484 2432 2510
f 2510 2547 2484
f 2405 2366 2432
f 2432 2484 2405
f 2308 2263 2366
f 2366 2405 2308
f 2090 2052 2263
f 2263 2308 2090
f 1719 1726 2052
f 2052 2090 1719
f 2787 2720 2726
f 2726 2795 2787
f 2759 2697 2720
f 2720 2787 2759
f 2713 2662 2697
f 2697 2759 2713
f 2657 2607 2662
f 2662 2713 2657
f 2589 2547 2607
f 2607 2657 2589
f 2525 2484 2547
f 2547 2589 2525
f 2422 2405 2484
f 2484 2525 2422
f 2330 2308 2405
f 2405 2422 2330
f 2118 2090 2308
f 2308 2330 2118
f 1700 1719 2090
f 2090 2118 1700
f 2834 2787 2795
f 2795 2844 2834
f 2798 2759 2787
f 2787 2834 2798
f 2750 2713 2759
f 2759 2798 2750
f 2690 2657 2713
f 2713 2750 2690
f 2624 2589 2657
f 2657 2690 2624
f 2536 2525 2589
f 2589 2624 2536
f 2441 2422 2525
f 2525 2536 2441
f 2340 2330 2422
f 2422 2441 2340
f 2128 2118 2330
f 2330 2340 2128
f 1825 1700 2118
f 2118 2128 1825
f 2847 2834 2844
f 2844 2857 2847
f 2821 2798 2834
f 2834 2847 2821
f 2765 2750 2798
f 2798 2821 2765
f 2703 2690 2750
f 2750 2765 2703
f 2637 2624 2690
f 2690 2703 2637
f 2543 2536 2624
f 2624 2637 2543
f 2446 2441 2536
f 2536 2543 2446
f 2344 2340 2441
f 2441 2446 2344
f 2136 2128 2340
f 2340 2344 2136
f 1713 1825 2128
f 2128 2136 1713
f 1676 1682 1864
f 1864 1862 1676
f 1642 1656 1682
f 1682 1676 1642
f 1601 1636 1656
f 1656 1642 1601
f 1558 1612 1636
f 1636 1601 1558
f 1502 1588 1612
f 1612 1558 1502
f 1472 1564 1588
f 1588 1502 1472
f 1425 1540 1564
f 1564 1472 1425
f 1404 1520 1540
f 1540 1425 1404
f 1390 1506 1520
f 1520 1404 1390
f 1387 1498 1506
f 1506 1390 1387
f 1654 1676 1862
f 1862 1859 1654
f 1606 1642 1676
f 1676 1654 1606
f 1531 1601 1642
f 1642 1606 1531
f 1452 1558 1601
f 1601 1531 1452
f 1388 1502 1558
f 1558 1452 1388
f 1347 1472 1502
f 1502 1388 1347
f 1316 1425 1472
f 1472 1347 1316
f 1300 1404 1425
f 1425 1316 1300
f 1290 1390 1404
f 1404 1300 1290
f 1286 1387 1390
f 1390 1290 1286
f 1646 1654 1859
f 1859 1856 1646
f 1550 1606 1654
f 1654 1646 1550
f 1439 1531 1606
f 1606 1550 1439
f 1351 1452 1531
f 1531 1439 1351
f 1298 1388 1452
f 1452 1351 1298
f 1275 1347 1388
f 1388 1298 1275
f 1246 1316 1347
f 1347 1275 1246
f 1222 1300 1316
f 1316 1246 1222
f 1215 1290 1300
f 1300 1222 1215
f 1211 1286 1290
f 1290 1215 1211
f 1624 1646 1856
f 1856 1854 1624
f 1484 1550 1646
f 1646 1624 1484
f 1353 1439 1550
f 1550 1484 1353
f 1284 1351 1439
f 1439 1353 1284
f 1238 1298 1351
f 1351 1284 1238
f 1204 1275 1298
f 1298 1238 1204
f 1178 1246 1275
f 1275 1204 1178
f 1152 1222 1246
f 1246 1178 1152
f 1134 1215 1222
f 1222 1152 1134
f 1124 1211 1215
f 1215 1134 1124
f 1596 1624 1854
f 1854 1851 1596
f 1410 1484 1624
f 1624 1596 1410
f 1296 1353 1484
f 1484 1410 1296
f 1228 1284 1353
f 1353 1296 1228
f 1186 1238 1284
f 1284 1228 1186
f 1130 1204 1238
f 1238 1186 1130
f 1091 1178 1204
f 1204 1130 1091
f 1073 1152 1178
f 1178 1091 1073
f 1063 1134 1152
f 1152 1073 1063
f 1053 1124 1134
f 1134 1063 1053
f 1570 1596 1851
f 1851 1848 1570
f 1359 1410 1596
f 1596 1570 1359
f 1256 1296 1410
f 1410 1359 1256
f 1190 1228 1296
f 1296 1256 1190
f 1112 1186 1228
f 1228 1190 1112
f 1071 1130 1186
f 1186 1112 1071
f 1029 1091 1130
f 1130 1071 1029
f 991 1073 1091
f 1091 1029 991
f 969 1063 1073
f 1073 991 969
f 967 1053 1063
f 1063 969 967
f 1532 1570 1848
f 1848 1846 1532
f 1314 1359 1570
f 1570 1532 1314
f 1219 1256 1359
f 1359 1314 1219
f 1138 1190 1256
f 1256 1219 1138
f 1075 1112 1190
f 1190 1138 1075
f 1015 1071 1112
f 1112 1075 1015
f 962 1029 1071
f 1071 1015 962
f 925 991 1029
f 1029 962 925
f 904 969 991
f 991 925 904
f 898 967 969
f 969 904 898
f 1504 1532 1846
f 1846 1832 1504
f 1292 1314 1532
f 1532 1504 1292
f 1200 1219 1314
f 1314 1292 1200
f 1097 1138 1219
f 1219 1200 1097
f 1033 1075 1138
f 1138 1097 1033
f 965 1015 1075
f 1075 1033 965
f 909 962 1015
f 1015 965 909
f 863 925 962
f 962 909 863
f 835 904 925
f 925 863 835
f 827 898 904
f 904 835 827
f 1494 1504 1832
f 1832 1824 1494
f 1282 1292 1504
f 1504 1494 1282
f 1183 1200 1292
f 1292 1282 1183
f 1088 1097 1200
f 1200 1183 1088
f 1000 1033 1097
f 1097 1088 1000
f 934 965 1033
f 1033 1000 934
f 874 909 965
f 965 934 874
f 826 863 909
f 909 874 826
f 790 835 863
f 863 826 790
f 780 827 835
f 835 790 780
f 1486 1494 1824
f 1824 1814 1486
f 1278 1282 1494
f 1494 1486 1278
f 1176 1183 1282
f 1282 1278 1176
f 1079 1088 1183
f 1183 1176 1079
f 985 1000 1088
f 1088 1079 985
f 919 934 1000
f 1000 985 919
f 857 874 934
f 934 919 857
f 801 826 874
f 874 857 801
f 775 790 826
f 826 801 775
f 765 780 790
f 790 775 765
f 1391 1507 1499
f 1499 1387 1391
f 1405 1521 1507
f 1507 1391 1405
f 1424 1541 1521
f 1521 1405 1424
f 1473 1565 1541
f 1541 1424 1473
f 1503 1589 1565
f 1565 1473 1503
f 1559 1613 1589
f 1589 1503 1559
f 1600 1637 1613
f 1613 1559 1600
f 1643 1657 1637
f 1637 1600 1643
f 1677 1683 1657
f 1657 1643 1677
f 1863 1892 1683
f 1683 1677 1863
f 1291 1391 1387
f 1387 1287 1291
f 1301 1405 1391
f 1391 1291 1301
f 1317 1424 1405
f 1405 1301 1317
f 1348 1473 1424
f 1424 1317 1348
f 1389 1503 1473
f 1473 1348 1389
f 1453 1559 1503
f 1503 1389 1453
f 1530 1600 1559
f 1559 1453 1530
f 1607 1643 1600
f 1600 1530 1607
f 1655 1677 1643
f 1643 1607 1655
f 1861 1863 1677
f 1677 1655 1861
f 1214 1291 1287
f 1287 1210 1214
f 1223 1301 1291
f 1291 1214 1223
f 1247 1317 1301
f 1301 1223 1247
f 1274 1348 1317
f 1317 1247 1274
f 1299 1389 1348
f 1348 1274 1299
f 1352 1453 1389
f 1389 1299 1352
f 1438 1530 1453
f 1453 1352 1438
f 1551 1607 1530
f 1530 1438 1551
f 1647 1655 1607
f 1607 1551 1647
f 1891 1861 1655
f 1655 1647 1891
f 1135 1214 1210
f 1210 1125 1135
f 1153 1223 1214
f 1214 1135 1153
f 1179 1247 1223
f 1223 1153 1179
f 1205 1274 1247
f 1247 1179 1205
f 1239 1299 1274
f 1274 1205 1239
f 1285 1352 1299
f 1299 1239 1285
f 1354 1438 1352
f 1352 1285 1354
f 1485 1551 1438
f 1438 1354 1485
f 1625 1647 1551
f 1551 1485 1625
f 1901 1891 1647
f 1647 1625 1901
f 1064 1135 1125
f 1125 1054 1064
f 1074 1153 1135
f 1135 1064 1074
f 1092 1179 1153
f 1153 1074 1092
f 1131 1205 1179
f 1179 1092 1131
f 1187 1239 1205
f 1205 1131 1187
f 1229 1285 1239
f 1239 1187 1229
f 1297 1354 1285
f 1285 1229 1297
f 1411 1485 1354
f 1354 1297 1411
f 1597 1625 1485
f 1485 1411 1597
f 1853 1901 1625
f 1625 1597 1853
f 970 1064 1054
f 1054 968 970
f 992 1074 1064
f 1064 970 992
f 1030 1092 1074
f 1074 992 1030
f 1072 1131 1092
f 1092 1030 1072
f 1113 1187 1131
f 1131 1072 1113
f 1191 1229 1187
f 1187 1113 1191
f 1257 1297 1229
f 1229 1191 1257
f 1360 1411 1297
f 1297 1257 1360
f 1571 1597 1411
f 1411 1360 1571
f 1899 1853 1597
f 1597 1571 1899
f 903 970 968
f 968 897 903
f 926 992 970
f 970 903 926
f 961 1030 992
f 992 926 961
f 1016 1072 1030
f 1030 961 1016
f 1076 1113 1072
f 1072 1016 1076
f 1139 1191 1113
f 1113 1076 1139
f 1218 1257 1191
f 1191 1139 1218
f 1315 1360 1257
f 1257 1218 1315
f 1533 1571 1360
f 1360 1315 1533
f 1920 1899 1571
f 1571 1533 1920
f 836 903 897
f 897 828 836
f 864 926 903
f 903 836 864
f 910 961 926
f 926 864 910
f 966 1016 961
f 961 910 966
f 1034 1076 1016
f 1016 966 1034
f 1098 1139 1076
f 1076 1034 1098
f 1201 1218 1139
f 1139 1098 1201
f 1293 1315 1218
f 1218 1201 1293
f 1505 1533 1315
f 1315 1293 1505
f 1924 1920 1533
f 1533 1505 1924
f 789 836 828
f 828 779 789
f 825 864 836
f 836 789 825
f 873 910 864
f 864 825 873
f 933 966 910
f 910 873 933
f 999 1034 966
f 966 933 999
f 1087 1098 1034
f 1034 999 1087
f 1182 1201 1098
f 1098 1087 1182
f 1283 1293 1201
f 1201 1182 1283
f 1495 1505 1293
f 1293 1283 1495
f 1826 1924 1505
f 1505 1495 1826
f 776 789 779
f 779 766 776
f 802 825 789
f 789 776 802
f 858 873 825
f 825 802 858
f 920 933 873
f 873 858 920
f 986 999 933
f 933 920 986
f 1080 1087 999
f 999 986 1080
f 1177 1182 1087
f 1087 1080 1177
f 1279 1283 1182
f 1182 1177 1279
f 1487 1495 1283
f 1283 1279 1487
f 1914 1826 1495
f 1495 1487 1914
f 1947 1941 1867
f 1867 1863 1947
f 1981 1967 1941
f 1941 1947 1981
f 2022 1987 1967
f 1967 1981 2022
f 2065 2011 1987
f 1987 2022 2065
f 2121 2035 2011
f 2011 2065 2121
f 2151 2059 2035
f 2035 2121 2151
f 2198 2083 2059
f 2059 2151 2198
f 2219 2103 2083
f 2083 2198 2219
f 2233 2117 2103
f 2103 2219 2233
f 2236 2125 2117
f 2117 2233 2236
f 1969 1947 1863
f 1863 1860 1969
f 2017 1981 1947
f 1947 1969 2017
f 2092 2022 1981
f 1981 2017 2092
f 2171 2065 2022
f 2022 2092 2171
f 2235 2121 2065
f 2065 2171 2235
f 2276 2151 2121
f 2121 2235 2276
f 2307 2198 2151
f 2151 2276 2307
f 2323 2219 2198
f 2198 2307 2323
f 2333 2233 2219
f 2219 2323 2333
f 2337 2236 2233
f 2233 2333 2337
f 1977 1969 1860
f 1860 1857 1977
f 2073 2017 1969
f 1969 1977 2073
f 2184 2092 2017
f 2017 2073 2184
f 2272 2171 2092
f 2092 2184 2272
f 2325 2235 2171
f 2171 2272 2325
f 2348 2276 2235
f 2235 2325 2348
f 2377 2307 2276
f 2276 2348 2377
f 2401 2323 2307
f 2307 2377 2401
f 2408 2333 2323
f 2323 2401 2408
f 2412 2337 2333
f 2333 2408 2412
f 1999 1977 1857
f 1857 1855 1999
f 2139 2073 1977
f 1977 1999 2139
f 2270 2184 2073
f 2073 2139 2270
f 2339 2272 2184
f 2184 2270 2339
f 2385 2325 2272
f 2272 2339 2385
f 2419 2348 2325
f 2325 2385 2419
f 2445 2377 2348
f 2348 2419 2445
f 2471 2401 2377
f 2377 2445 2471
f 2489 2408 2401
f 2401 2471 2489
f 2499 2412 2408
f 2408 2489 2499
f 2027 1999 1855
f 1855 1852 2027
f 2213 2139 1999
f 1999 2027 2213
f 2327 2270 2139
f 2139 2213 2327
f 2395 2339 2270
f 2270 2327 2395
f 2437 2385 2339
f 2339 2395 2437
f 2493 2419 2385
f 2385 2437 2493
f 2532 2445 2419
f 2419 2493 2532
f 2550 2471 2445
f 2445 2532 2550
f 2560 2489 2471
f 2471 2550 2560
f 2570 2499 2489
f 2489 2560 2570
f 2053 2027 1852
f 1852 1849 2053
f 2264 2213 2027
f 2027 2053 2264
f 2367 2327 2213
f 2213 2264 2367
f 2433 2395 2327
f 2327 2367 2433
f 2511 2437 2395
f 2395 2433 2511
f 2552 2493 2437
f 2437 2511 2552
f 2594 2532 2493
f 2493 2552 2594
f 2632 2550 2532
f 2532 2594 2632
f 2654 2560 2550
f 2550 2632 2654
f 2656 2570 2560
f 2560 2654 2656
f 2091 2053 1849
f 1849 1847 2091
f 2309 2264 2053
f 2053 2091 2309
f 2404 2367 2264
f 2264 2309 2404
f 2485 2433 2367
f 2367 2404 2485
f 2548 2511 2433
f 2433 2485 2548
f 2608 2552 2511
f 2511 2548 2608
f 2661 2594 2552
f 2552 2608 2661
f 2698 2632 2594
f 2594 2661 2698
f 2719 2654 2632
f 2632 2698 2719
f 2725 2656 2654
f 2654 2719 2725
f 2119 2091 1847
f 1847 1833 2119
f 2331 2309 2091
f 2091 2119 2331
f 2423 2404 2309
f 2309 2331 2423
f 2526 2485 2404
f 2404 2423 2526
f 2590 2548 2485
f 2485 2526 2590
f 2658 2608 2548
f 2548 2590 2658
f 2714 2661 2608
f 2608 2658 2714
f 2760 2698 2661
f 2661 2714 2760
f 2788 2719 2698
f 2698 2760 2788
f 2796 2725 2719
f 2719 2788 2796
f 2129 2119 1833
f 1833 1827 2129
f 2341 2331 2119
f 2119 2129 2341
f 2440 2423 2331
f 2331 2341 2440
f 2535 2526 2423
f 2423 2440 2535
f 2623 2590 2526
f 2526 2535 2623
f 2689 2658 2590
f 2590 2623 2689
f 2749 2714 2658
f 2658 2689 2749
f 2797 2760 2714
f 2714 2749 2797
f 2833 2788 2760
f 2760 2797 2833
f 2843 2796 2788
f 2788 2833 2843
f 2137 2129 1827
f 1827 1815 2137
f 2345 2341 2129
f 2129 2137 2345
f 2447 2440 2341
f 2341 2345 2447
f 2544 2535 2440
f 2440 2447 2544
f 2638 2623 2535
f 2535 2544 2638
f 2704 2689 2623
f 2623 2638 2704
f 2766 2749 2689
f 2689 2704 2766
f 2822 2797 2749
f 2749 2766 2822
f 2848 2833 2797
f 2797 2822 2848
f 2858 2843 2833
f 2833 2848 2858
f 1735 2334 2329
f 1735 2329 2321
f 1735 2321 2305
f 1735 2305 2274
f 1735 2274 2231
f 1735 2231 2167
f 1735 2167 2089
f 1735 2089 2014
f 1735 2014 1962
f 1735 1962 1733
f 2515 2329 2334
f 2334 2524 2515
f 2495 2321 2329
f 2329 2515 2495
f 2456 2305 2321
f 2321 2495 2456
f 2429 2274 2305
f 2305 2456 2429
f 2399 2231 2274
f 2274 2429 2399
f 2347 2167 2231
f 2231 2399 2347
f 2292 2089 2167
f 2167 2347 2292
f 2148 2014 2089
f 2089 2292 2148
f 2004 1962 2014
f 2014 2148 2004
f 1739 1733 1962
f 1962 2004 1739
f 2647 2515 2524
f 2524 2649 2647
f 2621 2495 2515
f 2515 2647 2621
f 2584 2456 2495
f 2495 2621 2584
f 2541 2429 2456
f 2456 2584 2541
f 2502 2399 2429
f 2429 2541 2502
f 2426 2347 2399
f 2399 2502 2426
f 2352 2292 2347
f 2347 2426 2352
f 2255 2148 2292
f 2292 2352 2255
f 2046 2004 2148
f 2148 2255 2046
f 1702 1739 2004
f 2004 2046 1702
f 2746 2647 2649
f 2649 2757 2746
f 2721 2621 2647
f 2647 2746 2721
f 2681 2584 2621
f 2621 2721 2681
f 2639 2541 2584
f 2584 2681 2639
f 2557 2502 2541
f 2541 2639 2557
f 2505 2426 2502
f 2502 2557 2505
f 2415 2352 2426
f 2426 2505 2415
f 2318 2255 2352
f 2352 2415 2318
f 2098 2046 2255
f 2255 2318 2098
f 1745 1702 2046
f 2046 2098 1745
f 2840 2746 2757
f 2757 2849 2840
f 2808 2721 2746
f 2746 2840 2808
f 2756 2681 2721
f 2721 2808 2756
f 2696 2639 2681
f 2681 2756 2696
f 2626 2557 2639
f 2639 2696 2626
f 2538 2505 2557
f 2557 2626 2538
f 2443 2415 2505
f 2505 2538 2443
f 2342 2318 2415
f 2415 2443 2342
f 2131 2098 2318
f 2318 2342 2131
f 1904 1745 2098
f 2098 2131 1904
f 2906 2840 2849
f 2849 2925 2906
f 2867 2808 2840
f 2840 2906 2867
f 2818 2756 2808
f 2808 2867 2818
f 2736 2696 2756
f 2756 2818 2736
f 2667 2626 2696
f 2696 2736 2667
f 2565 2538 2626
f 2626 2667 2565
f 2475 2443 2538
f 2538 2565 2475
f 2356 2342 2443
f 2443 2475 2356
f 2156 2131 2342
f 2342 2356 2156
f 1704 1904 2131
f 2131 2156 1704
f 2976 2906 2925
f 2925 2987 2976
f 2914 2867 2906
f 2906 2976 2914
f 2852 2818 2867
f 2867 2914 2852
f 2772 2736 2818
f 2818 2852 2772
f 2688 2667 2736
f 2736 2772 2688
f 2592 2565 2667
f 2667 2688 2592
f 2497 2475 2565
f 2565 2592 2497
f 2372 2356 2475
f 2475 2497 2372
f 2176 2156 2356
f 2356 2372 2176
f 1752 1704 2156
f 2156 2176 1752
f 2993 2976 2987
f 2987 3011 2993
f 2952 2914 2976
f 2976 2993 2952
f 2874 2852 2914
f 2914 2952 2874
f 2794 2772 2852
f 2852 2874 2794
f 2702 2688 2772
f 2772 2794 2702
f 2604 2592 2688
f 2688 2702 2604
f 2509 2497 2592
f 2592 2604 2509
f 2380 2372 2497
f 2497 2509 2380
f 2182 2176 2372
f 2372 2380 2182
f 1723 1752 2176
f 2176 2182 1723
f 3000 2993 3011
f 3011 3020 3000
f 2967 2952 2993
f 2993 3000 2967
f 2879 2874 2952
f 2952 2967 2879
f 2799 2794 2874
f 2874 2879 2799
f 2707 2702 2794
f 2794 2799 2707
f 2605 2604 2702
f 2702 2707 2605
f 2512 2509 2604
f 2604 2605 2512
f 2382 2380 2509
f 2509 2512 2382
f 2188 2182 2380
f 2380 2382 2188
f 1699 1723 2182
f 2182 2188 1699
f 3006 3000 3020
f 3020 3022 3006
f 2972 2967 3000
f 3000 3006 2972
f 2888 2879 2967
f 2967 2972 2888
f 2804 2799 2879
f 2879 2888 2804
f 2710 2707 2799
f 2799 2804 2710
f 2613 2605 2707
f 2707 2710 2613
f 2520 2512 2605
f 2605 2613 2520
f 2388 2382 2512
f 2512 2520 2388
f 2192 2188 2382
f 2382 2388 2192
f 1760 1699 2188
f 2188 2192 1760
f 1735 1737 1660
f 1735 1660 1608
f 1735 1608 1535
f 1735 1535 1457
f 1735 1457 1393
f 1735 1393 1350
f 1735 1350 1319
f 1735 1319 1303
f 1735 1303 1295
f 1735 1295 1288
f 1618 1660 1737
f 1737 1739 1618
f 1474 1608 1660
f 1660 1618 1474
f 1332 1535 1608
f 1608 1474 1332
f 1277 1457 1535
f 1535 1332 1277
f 1225 1393 1457
f 1457 1277 1225
f 1195 1350 1393
f 1393 1225 1195
f 1166 1319 1350
f 1350 1195 1166
f 1129 1303 1319
f 1319 1166 1129
f 1109 1295 1303
f 1303 1129 1109
f 1099 1288 1295
f 1295 1109 1099
f 1576 1618 1739
f 1739 1741 1576
f 1367 1474 1618
f 1618 1576 1367
f 1270 1332 1474
f 1474 1367 1270
f 1196 1277 1332
f 1332 1270 1196
f 1120 1225 1277
f 1277 1196 1120
f 1081 1195 1225
f 1225 1120 1081
f 1040 1166 1195
f 1195 1081 1040
f 1001 1129 1166
f 1166 1040 1001
f 975 1109 1129
f 1129 1001 975
f 973 1099 1109
f 1109 975 973
f 1524 1576 1741
f 1741 1744 1524
f 1304 1367 1576
f 1576 1524 1304
f 1209 1270 1367
f 1367 1304 1209
f 1119 1196 1270
f 1270 1209 1119
f 1065 1120 1196
f 1196 1119 1065
f 983 1081 1120
f 1120 1065 983
f 941 1040 1081
f 1081 983 941
f 901 1001 1040
f 1040 941 901
f 878 975 1001
f 1001 901 878
f 865 973 975
f 975 878 865
f 1493 1524 1744
f 1744 1747 1493
f 1280 1304 1524
f 1524 1493 1280
f 1181 1209 1304
f 1304 1280 1181
f 1086 1119 1209
f 1209 1181 1086
f 998 1065 1119
f 1119 1086 998
f 928 983 1065
f 1065 998 928
f 868 941 983
f 983 928 868
f 816 901 941
f 941 868 816
f 784 878 901
f 901 816 784
f 773 865 878
f 878 784 773
f 1466 1493 1747
f 1747 1749 1466
f 1266 1280 1493
f 1493 1466 1266
f 1149 1181 1280
f 1280 1266 1149
f 1057 1086 1181
f 1181 1149 1057
f 955 998 1086
f 1086 1057 955
f 888 928 998
f 998 955 888
f 806 868 928
f 928 888 806
f 755 816 868
f 868 806 755
f 718 784 816
f 816 755 718
f 697 773 784
f 784 718 697
f 1446 1466 1749
f 1749 1753 1446
f 1250 1266 1466
f 1466 1446 1250
f 1127 1149 1266
f 1266 1250 1127
f 1032 1057 1149
f 1149 1127 1032
f 936 955 1057
f 1057 1032 936
f 852 888 955
f 955 936 852
f 772 806 888
f 888 852 772
f 710 755 806
f 806 772 710
f 648 718 755
f 755 710 648
f 637 697 718
f 718 648 637
f 1440 1446 1753
f 1753 1755 1440
f 1242 1250 1446
f 1446 1440 1242
f 1115 1127 1250
f 1250 1242 1115
f 1020 1032 1127
f 1127 1115 1020
f 922 936 1032
f 1032 1020 922
f 830 852 936
f 936 922 830
f 750 772 852
f 852 830 750
f 672 710 772
f 772 750 672
f 631 648 710
f 710 672 631
f 613 637 648
f 648 631 613
f 1434 1440 1755
f 1755 1757 1434
f 1240 1242 1440
f 1440 1434 1240
f 1110 1115 1242
f 1242 1240 1110
f 1017 1020 1115
f 1115 1110 1017
f 915 922 1020
f 1020 1017 915
f 823 830 922
f 922 915 823
f 743 750 830
f 830 823 743
f 655 672 750
f 750 743 655
f 622 631 672
f 672 655 622
f 602 613 631
f 631 622 602
f 1428 1434 1757
f 1757 1760 1428
f 1232 1240 1434
f 1434 1428 1232
f 1105 1110 1240
f 1240 1232 1105
f 1010 1017 1110
f 1110 1105 1010
f 913 915 1017
f 1017 1010 913
f 821 823 915
f 915 913 821
f 736 743 823
f 823 821 736
f 652 655 743
f 743 736 652
f 619 622 655
f 655 652 619
f 601 602 622
f 622 619 601
f 1735 1289 1294
f 1735 1294 1302
f 1735 1302 1318
f 1735 1318 1349
f 1735 1349 1392
f 1735 1392 1456
f 1735 1456 1534
f 1735 1534 1609
f 1735 1609 1661
f 1735 1661 1889
f 1108 1294 1289
f 1289 1099 1108
f 1128 1302 1294
f 1294 1108 1128
f 1167 1318 1302
f 1302 1128 1167
f 1194 1349 1318
f 1318 1167 1194
f 1224 1392 1349
f 1349 1194 1224
f 1276 1456 1392
f 1392 1224 1276
f 1331 1534 1456
f 1456 1276 1331
f 1475 1609 1534
f 1534 1331 1475
f 1619 1661 1609
f 1609 1475 1619
f 1738 1889 1661
f 1661 1619 1738
f 976 1108 1099
f 1099 974 976
f 1002 1128 1108
f 1108 976 1002
f 1039 1167 1128
f 1128 1002 1039
f 1082 1194 1167
f 1167 1039 1082
f 1121 1224 1194
f 1194 1082 1121
f 1197 1276 1224
f 1224 1121 1197
f 1271 1331 1276
f 1276 1197 1271
f 1368 1475 1331
f 1331 1271 1368
f 1577 1619 1475
f 1475 1368 1577
f 1903 1738 1619
f 1619 1577 1903
f 877 976 974
f 974 866 877
f 902 1002 976
f 976 877 902
f 942 1039 1002
f 1002 902 942
f 984 1082 1039
f 1039 942 984
f 1066 1121 1082
f 1082 984 1066
f 1118 1197 1121
f 1121 1066 1118
f 1208 1271 1197
f 1197 1118 1208
f 1305 1368 1271
f 1271 1208 1305
f 1525 1577 1368
f 1368 1305 1525
f 1742 1903 1577
f 1577 1525 1742
f 783 877 866
f 866 774 783
f 815 902 877
f 877 783 815
f 867 942 902
f 902 815 867
f 927 984 942
f 942 867 927
f 997 1066 984
f 984 927 997
f 1085 1118 1066
f 1066 997 1085
f 1180 1208 1118
f 1118 1085 1180
f 1281 1305 1208
f 1208 1180 1281
f 1492 1525 1305
f 1305 1281 1492
f 1703 1742 1525
f 1525 1492 1703
f 717 783 774
f 774 698 717
f 756 815 783
f 783 717 756
f 805 867 815
f 815 756 805
f 887 927 867
f 867 805 887
f 956 997 927
f 927 887 956
f 1058 1085 997
f 997 956 1058
f 1148 1180 1085
f 1085 1058 1148
f 1267 1281 1180
f 1180 1148 1267
f 1467 1492 1281
f 1281 1267 1467
f 1905 1703 1492
f 1492 1467 1905
f 647 717 698
f 698 636 647
f 709 756 717
f 717 647 709
f 771 805 756
f 756 709 771
f 851 887 805
f 805 771 851
f 935 956 887
f 887 851 935
f 1031 1058 956
f 956 935 1031
f 1126 1148 1058
f 1058 1031 1126
f 1251 1267 1148
f 1148 1126 1251
f 1447 1467 1267
f 1267 1251 1447
f 1751 1905 1467
f 1467 1447 1751
f 630 647 636
f 636 612 630
f 671 709 647
f 647 630 671
f 749 771 709
f 709 671 749
f 829 851 771
f 771 749 829
f 921 935 851
f 851 829 921
f 1019 1031 935
f 935 921 1019
f 1114 1126 1031
f 1031 1019 1114
f 1243 1251 1126
f 1126 1114 1243
f 1441 1447 1251
f 1251 1243 1441
f 1896 1751 1447
f 1447 1441 1896
f 623 630 612
f 612 603 623
f 656 671 630
f 630 623 656
f 744 749 671
f 671 656 744
f 824 829 749
f 749 744 824
f 916 921 829
f 829 824 916
f 1018 1019 921
f 921 916 1018
f 1111 1114 1019
f 1019 1018 1111
f 1241 1243 1114
f 1114 1111 1241
f 1435 1441 1243
f 1243 1241 1435
f 1923 1896 1441
f 1441 1435 1923
f 617 623 603
f 603 601 617
f 650 656 623
f 623 617 650
f 734 744 656
f 656 650 734
f 818 824 744
f 744 734 818
f 912 916 824
f 824 818 912
f 1009 1018 916
f 916 912 1009
f 1102 1111 1018
f 1018 1009 1102
f 1235 1241 1111
f 1111 1102 1235
f 1431 1435 1241
f 1241 1235 1431
f 1759 1923 1435
f 1435 1431 1759
f 1735 1736 1963
f 1735 1963 2015
f 1735 2015 2088
f 1735 2088 2166
f 1735 2166 2230
f 1735 2230 2273
f 1735 2273 2304
f 1735 2304 2320
f 1735 2320 2328
f 1735 2328 2335
f 2005 1963 1736
f 1736 1738 2005
f 2149 2015 1963
f 1963 2005 2149
f 2291 2088 2015
f 2015 2149 2291
f 2346 2166 2088
f 2088 2291 2346
f 2398 2230 2166
f 2166 2346 2398
f 2428 2273 2230
f 2230 2398 2428
f 2457 2304 2273
f 2273 2428 2457
f 2494 2320 2304
f 2304 2457 2494
f 2514 2328 2320
f 2320 2494 2514
f 2524 2335 2328
f 2328 2514 2524
f 2047 2005 1738
f 1738 1740 2047
f 2256 2149 2005
f 2005 2047 2256
f 2353 2291 2149
f 2149 2256 2353
f 2427 2346 2291
f 2291 2353 2427
f 2503 2398 2346
f 2346 2427 2503
f 2542 2428 2398
f 2398 2503 2542
f 2583 2457 2428
f 2428 2542 2583
f 2622 2494 2457
f 2457 2583 2622
f 2648 2514 2494
f 2494 2622 2648
f 2650 2524 2514
f 2514 2648 2650
f 2099 2047 1740
f 1740 1743 2099
f 2319 2256 2047
f 2047 2099 2319
f 2414 2353 2256
f 2256 2319 2414
f 2504 2427 2353
f 2353 2414 2504
f 2558 2503 2427
f 2427 2504 2558
f 2640 2542 2503
f 2503 2558 2640
f 2682 2583 2542
f 2542 2640 2682
f 2722 2622 2583
f 2583 2682 2722
f 2745 2648 2622
f 2622 2722 2745
f 2758 2650 2648
f 2648 2745 2758
f 2130 2099 1743
f 1743 1746 2130
f 2343 2319 2099
f 2099 2130 2343
f 2442 2414 2319
f 2319 2343 2442
f 2537 2504 2414
f 2414 2442 2537
f 2625 2558 2504
f 2504 2537 2625
f 2695 2640 2558
f 2558 2625 2695
f 2755 2682 2640
f 2640 2695 2755
f 2807 2722 2682
f 2682 2755 2807
f 2839 2745 2722
f 2722 2807 2839
f 2850 2758 2745
f 2745 2839 2850
f 2157 2130 1746
f 1746 1748 2157
f 2357 2343 2130
f 2130 2157 2357
f 2474 2442 2343
f 2343 2357 2474
f 2566 2537 2442
f 2442 2474 2566
f 2668 2625 2537
f 2537 2566 2668
f 2735 2695 2625
f 2625 2668 2735
f 2817 2755 2695
f 2695 2735 2817
f 2868 2807 2755
f 2755 2817 2868
f 2905 2839 2807
f 2807 2868 2905
f 2926 2850 2839
f 2839 2905 2926
f 2177 2157 1748
f 1748 1750 2177
f 2373 2357 2157
f 2157 2177 2373
f 2496 2474 2357
f 2357 2373 2496
f 2591 2566 2474
f 2474 2496 2591
f 2687 2668 2566
f 2566 2591 2687
f 2771 2735 2668
f 2668 2687 2771
f 2851 2817 2735
f 2735 2771 2851
f 2913 2868 2817
f 2817 2851 2913
f 2975 2905 2868
f 2868 2913 2975
f 2986 2926 2905
f 2905 2975 2986
f 2183 2177 1750
f 1750 1754 2183
f 2381 2373 2177
f 2177 2183 2381
f 2508 2496 2373
f 2373 2381 2508
f 2603 2591 2496
f 2496 2508 2603
f 2701 2687 2591
f 2591 2603 2701
f 2793 2771 2687
f 2687 2701 2793
f 2873 2851 2771
f 2771 2793 2873
f 2951 2913 2851
f 2851 2873 2951
f 2992 2975 2913
f 2913 2951 2992
f 3010 2986 2975
f 2975 2992 3010
f 2189 2183 1754
f 1754 1756 2189
f 2383 2381 2183
f 2183 2189 2383
f 2513 2508 2381
f 2381 2383 2513
f 2606 2603 2508
f 2508 2513 2606
f 2708 2701 2603
f 2603 2606 2708
f 2800 2793 2701
f 2701 2708 2800
f 2880 2873 2793
f 2793 2800 2880
f 2968 2951 2873
f 2873 2880 2968
f 3001 2992 2951
f 2951 2968 3001
f 3021 3010 2992
f 2992 3001 3021
f 2195 2189 1756
f 1756 1759 2195
f 2390 2383 2189
f 2189 2195 2390
f 2517 2513 2383
f 2383 2390 2517
f 2612 2606 2513
f 2513 2517 2612
f 2709 2708 2606
f 2606 2612 2709
f 2801 2800 2708
f 2708 2709 2801
f 2886 2880 2800
f 2800 2801 2886
f 2970 2968 2880
f 2880 2886 2970
f 3004 3001 2968
f 2968 2970 3004
f 3022 3021 3001
f 3001 3004 3022

```

`css/index.css`:

```css
@font-face {
    font-family: 'LibreBaskerville';
    src: url('../fonts/LibreBaskerville-Regular.ttf') format('truetype');
}
body {
    background: #181818;
    color: #F0F0F0;
    font-family: LibreBaskerville;
    margin: auto;
    max-width: 960px;
    font-size: 16px;
}
p {
    padding-bottom: 20px;
    line-height: 1.5;
}
h1 {
    font-size: 40px;
    text-align: center;
    padding-top: 40px;
    padding-bottom: 40px;
}
h2 {
    font-size: 28px;
    text-align: left;
    padding-top: 20px;
    padding-bottom: 40px;
}
h2 a {
    color: #F0F0F0;
}
kbd {
    display: inline-block;
    font-family: monospace;
    padding: 3px 5px;
    background: #303030;
    line-height: 10px;
    vertical-align: middle;
    text-align: center;
    border-radius: 5px;
}
code {
    display: inline-block;
    font-family: monospace;
}
ul {
    padding-bottom: 20px;
    list-style: inside square;
}
ul li {
    padding-bottom: 10px;
}
.plot {
    width: 100%;
    padding-bottom: 20px;
}
a {
    color: #9090EE;
    text-decoration: none;
}
.author {
    text-align: center;
    padding-bottom: 40px;
    font-style: italic;
}
.author a {
    color: #F0F0F0;
}

```

`css/reset.css`:

```css
/* http://meyerweb.com/eric/tools/css/reset/ 
   v2.0 | 20110126
   License: none (public domain)
*/

html, body, div, span, applet, object, iframe,
h1, h2, h3, h4, h5, h6, p, blockquote, pre,
a, abbr, acronym, address, big, cite, code,
del, dfn, em, img, ins, kbd, q, s, samp,
small, strike, strong, sub, sup, tt, var,
b, u, i, center,
dl, dt, dd, ol, ul, li,
fieldset, form, label, legend,
table, caption, tbody, tfoot, thead, tr, th, td,
article, aside, canvas, details, embed, 
figure, figcaption, footer, header, hgroup, 
menu, nav, output, ruby, section, summary,
time, mark, audio, video {
	margin: 0;
	padding: 0;
	border: 0;
	font-size: 100%;
	font: inherit;
	vertical-align: baseline;
}
/* HTML5 display-role reset for older browsers */
article, aside, details, figcaption, figure, 
footer, header, hgroup, menu, nav, section {
	display: block;
}
body {
	line-height: 1;
}
ol, ul {
	list-style: none;
}
blockquote, q {
	quotes: none;
}
blockquote:before, blockquote:after,
q:before, q:after {
	content: '';
	content: none;
}
table {
	border-collapse: collapse;
	border-spacing: 0;
}

```

`demos/cup3d.c`:

```c
#include "assets/tsodinCupLowPoly.c"
#include "model3d.c"

```

`demos/dots3d.c`:

```c
#include "vc.c"

float sqrtf(float x);
float atan2f(float y, float x);
float sinf(float x);
float cosf(float x);

#define PI 3.14159265359

#define WIDTH 960
#define HEIGHT 720
#define BACKGROUND_COLOR 0xFF181818
#define GRID_COUNT 10
#define GRID_PAD 0.5/GRID_COUNT
#define GRID_SIZE ((GRID_COUNT - 1)*GRID_PAD)
#define CIRCLE_RADIUS 5
#define Z_START 0.25
#define ABOBA_PADDING 50

static uint32_t pixels[WIDTH*HEIGHT];
static float angle = 0;

Olivec_Canvas vc_render(float dt)
{
    angle += 0.25*PI*dt;

    Olivec_Canvas oc = olivec_canvas(pixels, WIDTH, HEIGHT, WIDTH);

    olivec_fill(oc, BACKGROUND_COLOR);
    for (int ix = 0; ix < GRID_COUNT; ++ix) {
        for (int iy = 0; iy < GRID_COUNT; ++iy) {
            for (int iz = 0; iz < GRID_COUNT; ++iz) {
                float x = ix*GRID_PAD - GRID_SIZE/2;
                float y = iy*GRID_PAD - GRID_SIZE/2;
                float z = Z_START + iz*GRID_PAD;

                float cx = 0.0;
                float cz = Z_START + GRID_SIZE/2;

                float dx = x - cx;
                float dz = z - cz;

                float a = atan2f(dz, dx);
                float m = sqrtf(dx*dx + dz*dz);

                dx = cosf(a + angle)*m;
                dz = sinf(a + angle)*m;

                x = dx + cx;
                z = dz + cz;

                x /= z;
                y /= z;

                uint32_t r = ix*255/GRID_COUNT;
                uint32_t g = iy*255/GRID_COUNT;
                uint32_t b = iz*255/GRID_COUNT;
                uint32_t color = 0xFF000000 | (r<<(0*8)) | (g<<(1*8)) | (b<<(2*8));
                olivec_circle(oc, (x + 1)/2*WIDTH, (y + 1)/2*HEIGHT, CIRCLE_RADIUS, color);
            }
        }
    }

    size_t size = 8;
    olivec_text(oc, "aboba", ABOBA_PADDING, HEIGHT - ABOBA_PADDING - olivec_default_font.height*size, olivec_default_font, size, 0xFFFFFFFF);

    return oc;
}

```

`demos/model3d.c`:

```c
#include "vc.c"

#define WIDTH 960
#define HEIGHT 720
#define BACKGROUND_COLOR 0xFF181818

#define PI 3.14159265359

float sqrtf(float x);
float atan2f(float y, float x);
float sinf(float x);
float cosf(float x);

static uint32_t pixels[WIDTH*HEIGHT];
static float zbuffer[WIDTH*HEIGHT] = {0};
static float angle = 0;

typedef struct {
    float x, y;
} Vector2;

static Vector2 make_vector2(float x, float y)
{
    Vector2 v2;
    v2.x = x;
    v2.y = y;
    return v2;
}

typedef struct {
    float x, y, z;
} Vector3;

static Vector3 make_vector3(float x, float y, float z)
{
    Vector3 v3;
    v3.x = x;
    v3.y = y;
    v3.z = z;
    return v3;
}

#define EPSILON 1e-6

static Vector2 project_3d_2d(Vector3 v3)
{
    if (v3.z < 0) v3.z = -v3.z;
    if (v3.z < EPSILON) v3.z += EPSILON;
    return make_vector2(v3.x/v3.z, v3.y/v3.z);
}

static Vector2 project_2d_scr(Vector2 v2)
{
    return make_vector2((v2.x + 1)/2*WIDTH, (1 - (v2.y + 1)/2)*HEIGHT);
}

static Vector3 rotate_y(Vector3 p, float delta_angle)
{
    float angle = atan2f(p.z, p.x) + delta_angle;
    float mag = sqrtf(p.x*p.x + p.z*p.z);
    return make_vector3(cosf(angle)*mag, p.y, sinf(angle)*mag);
}

typedef enum {
    FACE_V1,
    FACE_V2,
    FACE_V3,
    FACE_VT1,
    FACE_VT2,
    FACE_VT3,
    FACE_VN1,
    FACE_VN2,
    FACE_VN3,
} Face_Index;

float vector3_dot(Vector3 a, Vector3 b)
{
    return a.x*b.x + a.y*b.y + a.z*b.z;
}

Olivec_Canvas vc_render(float dt)
{
    angle += 0.25*PI*dt;

    Olivec_Canvas oc = olivec_canvas(pixels, WIDTH, HEIGHT, WIDTH);
    olivec_fill(oc, BACKGROUND_COLOR);
    for (size_t i = 0; i < WIDTH*HEIGHT; ++i) zbuffer[i] = 0;

    Vector3 camera = {0, 0, 1};
    for (size_t i = 0; i < faces_count; ++i) {
        int a, b, c;

        a = faces[i][FACE_V1];
        b = faces[i][FACE_V2];
        c = faces[i][FACE_V3];
        Vector3 v1 = rotate_y(make_vector3(vertices[a][0], vertices[a][1], vertices[a][2]), angle);
        Vector3 v2 = rotate_y(make_vector3(vertices[b][0], vertices[b][1], vertices[b][2]), angle);
        Vector3 v3 = rotate_y(make_vector3(vertices[c][0], vertices[c][1], vertices[c][2]), angle);
        v1.z += 1.5; v2.z += 1.5; v3.z += 1.5;

        a = faces[i][FACE_VN1];
        b = faces[i][FACE_VN2];
        c = faces[i][FACE_VN3];
        Vector3 vn1 = rotate_y(make_vector3(normals[a][0], normals[a][1], normals[a][2]), angle);
        Vector3 vn2 = rotate_y(make_vector3(normals[b][0], normals[b][1], normals[b][2]), angle);
        Vector3 vn3 = rotate_y(make_vector3(normals[c][0], normals[c][1], normals[c][2]), angle);
        if (vector3_dot(camera, vn1) > 0.0 &&
            vector3_dot(camera, vn2) > 0.0 &&
            vector3_dot(camera, vn3) > 0.0) continue;


        Vector2 p1 = project_2d_scr(project_3d_2d(v1));
        Vector2 p2 = project_2d_scr(project_3d_2d(v2));
        Vector2 p3 = project_2d_scr(project_3d_2d(v3));

        int x1 = p1.x;
        int x2 = p2.x;
        int x3 = p3.x;
        int y1 = p1.y;
        int y2 = p2.y;
        int y3 = p3.y;
        int lx, hx, ly, hy;
        if (olivec_normalize_triangle(oc.width, oc.height, x1, y1, x2, y2, x3, y3, &lx, &hx, &ly, &hy)) {
            for (int y = ly; y <= hy; ++y) {
                for (int x = lx; x <= hx; ++x) {
                    int u1, u2, det;
                    if (olivec_barycentric(x1, y1, x2, y2, x3, y3, x, y, &u1, &u2, &det)) {
                        int u3 = det - u1 - u2;
                        float z = 1/v1.z*u1/det + 1/v2.z*u2/det + 1/v3.z*u3/det;
                        float near = 0.1f;
                        float far = 5.0f;
                        if (1.0f/far < z && z < 1.0f/near && z > zbuffer[y*WIDTH + x]) {
                            zbuffer[y*WIDTH + x] = z;
                            OLIVEC_PIXEL(oc, x, y) = mix_colors3(0xFF1818FF, 0xFF18FF18, 0xFFFF1818, u1, u2, det);

                            z = 1.0f/z;
                            if (z >= 1.0) {
                                z -= 1.0;
                                uint32_t v = z*255;
                                if (v > 255) v = 255;
                                olivec_blend_color(&OLIVEC_PIXEL(oc, x, y), (v<<(3*8)));
                            }
                        }
                    }
                }
            }
        }
    }

    return oc;
}

```

`demos/penger3d.c`:

```c
#include "assets/penger.c"
#include "model3d.c"

```

`demos/squish.c`:

```c
#include "vc.c"
#include "./assets/tsodinPog.c"

#define WIDTH 960
#define HEIGHT 720

float sinf(float);

static uint32_t dst[WIDTH*HEIGHT];
static float global_time = 0;

#define SRC_SCALE 3

Olivec_Canvas vc_render(float dt)
{
    global_time += dt;

    float t = sinf(10*global_time);

    Olivec_Canvas dst_canvas = olivec_canvas(dst, WIDTH, HEIGHT, WIDTH);

    olivec_fill(dst_canvas, 0xFF181818);

    int factor = 100;
    int w = tsodinPog_width*SRC_SCALE - t*factor;
    int h = tsodinPog_height*SRC_SCALE + t*factor;

    olivec_sprite_copy_bilinear(
        dst_canvas,
        WIDTH/2 - w/2, HEIGHT - h, w, h,
        olivec_canvas(tsodinPog_pixels, tsodinPog_width, tsodinPog_height, tsodinPog_width));

    return dst_canvas;
}

```

`demos/teapot3d.c`:

```c
#include "assets/utahTeapot.c"
#define VC_TERM_SCALE_DOWN_FACTOR 10
#include "model3d.c"

```

`demos/triangle.c`:

```c
#include "vc.c"

#define WIDTH 960
#define HEIGHT 720
#define BACKGROUND_COLOR 0xFF181818
#define CIRCLE_RADIUS 100
#define CIRCLE_COLOR 0x99AA2020

static uint32_t pixels[WIDTH*HEIGHT];
static float triangle_angle = 0;
static float circle_x = WIDTH/2;
static float circle_y = HEIGHT/2;
static float circle_dx = 100;
static float circle_dy = 100;

float sqrtf(float x);
float atan2f(float y, float x);
float sinf(float x);
float cosf(float x);

#define PI 3.14159265359

static inline void rotate_point(float *x, float *y)
{
    float dx = *x - WIDTH/2;
    float dy = *y - HEIGHT/2;
    float mag = sqrtf(dx*dx + dy*dy);
    float dir = atan2f(dy, dx) + triangle_angle;
    *x = cosf(dir)*mag + WIDTH/2;
    *y = sinf(dir)*mag + HEIGHT/2;
}

Olivec_Canvas vc_render(float dt)
{
    Olivec_Canvas oc = olivec_canvas(pixels, WIDTH, HEIGHT, WIDTH);

    olivec_fill(oc, BACKGROUND_COLOR);

    // Triangle
    {
        triangle_angle += 0.5f*PI*dt;

        float x1 = WIDTH/2, y1 = HEIGHT/8;
        float x2 = WIDTH/8, y2 = HEIGHT/2;
        float x3 = WIDTH*7/8, y3 = HEIGHT*7/8;
        rotate_point(&x1, &y1);
        rotate_point(&x2, &y2);
        rotate_point(&x3, &y3);
        olivec_triangle3c(oc, x1, y1, x2, y2, x3, y3, 0xFF2020FF, 0xFF20FF20, 0xFFFF2020);
    }

    // Circle
    {
        float x = circle_x + circle_dx*dt;
        if (x - CIRCLE_RADIUS < 0 || x + CIRCLE_RADIUS >= WIDTH) {
            circle_dx *= -1;
        } else {
            circle_x = x;
        }

        float y = circle_y + circle_dy*dt;
        if (y - CIRCLE_RADIUS < 0 || y + CIRCLE_RADIUS >= HEIGHT) {
            circle_dy *= -1;
        } else {
            circle_y = y;
        }

        olivec_circle(oc, circle_x, circle_y, CIRCLE_RADIUS, CIRCLE_COLOR);
    }

    return oc;
}

```

`demos/triangle3d.c`:

```c
#include "vc.c"

#define WIDTH 960
#define HEIGHT 720

static uint32_t pixels1[WIDTH*HEIGHT];
static float zbuffer1[WIDTH*HEIGHT];
static uint32_t pixels2[WIDTH*HEIGHT];
static float zbuffer2[WIDTH*HEIGHT];

typedef struct {
    float x, y;
} Vector2;

Vector2 make_vector2(float x, float y)
{
    Vector2 v2;
    v2.x = x;
    v2.y = y;
    return v2;
}

typedef struct {
    float x, y, z;
} Vector3;

static Vector3 make_vector3(float x, float y, float z)
{
    Vector3 v3;
    v3.x = x;
    v3.y = y;
    v3.z = z;
    return v3;
}

static Vector2 project_3d_2d(Vector3 v3)
{
    return make_vector2(v3.x / v3.z, v3.y / v3.z);
}

static Vector2 project_2d_scr(Vector2 v2)
{
    return make_vector2((v2.x + 1)/2*WIDTH, (1 - (v2.y + 1)/2)*HEIGHT);
}

static float global_time = 1.0;

#define PI 3.14159265359

float sinf(float);
float cosf(float);

Olivec_Canvas vc_render(float dt)
{
    global_time += dt;

    Olivec_Canvas oc1 = olivec_canvas(pixels1, WIDTH, HEIGHT, WIDTH);
    olivec_fill(oc1, 0xFF181818);
    Olivec_Canvas zb1 = olivec_canvas((uint32_t*)zbuffer1, WIDTH, HEIGHT, WIDTH);
    olivec_fill(zb1, 0);

    float z = 1.5;
    float t = 0.75;
    {
        Vector3 v1 = make_vector3(cosf(global_time)*t, -t, z + sinf(global_time)*t);
        Vector3 v2 = make_vector3(cosf(global_time + PI)*t, -t, z + sinf(global_time + PI)*t);
        Vector3 v3 = make_vector3(0, t, z);

        Vector2 p1 = project_2d_scr(project_3d_2d(v1));
        Vector2 p2 = project_2d_scr(project_3d_2d(v2));
        Vector2 p3 = project_2d_scr(project_3d_2d(v3));

        olivec_triangle3z(zb1, p1.x, p1.y, p2.x, p2.y, p3.x, p3.y, 1.0f/v1.z, 1.0f/v2.z, 1.0f/v3.z);
        olivec_triangle3c(oc1, p1.x, p1.y, p2.x, p2.y, p3.x, p3.y, 0xFF1818FF, 0xFF18FF18, 0xFFFF1818);
    }

    Olivec_Canvas oc2 = olivec_canvas(pixels2, WIDTH, HEIGHT, WIDTH);
    olivec_fill(oc2, 0xFF181818);
    Olivec_Canvas zb2 = olivec_canvas((uint32_t*)zbuffer2, WIDTH, HEIGHT, WIDTH);
    olivec_fill(zb2, 0);

    {
        Vector3 v1 = make_vector3(cosf(global_time + PI/2)*t, -t, z + sinf(global_time + PI/2)*t);
        Vector3 v2 = make_vector3(cosf(global_time + PI + PI/2)*t, -t, z + sinf(global_time + PI + PI/2)*t);
        Vector3 v3 = make_vector3(0, t, z);

        Vector2 p1 = project_2d_scr(project_3d_2d(v1));
        Vector2 p2 = project_2d_scr(project_3d_2d(v2));
        Vector2 p3 = project_2d_scr(project_3d_2d(v3));

        olivec_triangle3z(zb2, p1.x, p1.y, p2.x, p2.y, p3.x, p3.y, 1.0f/v1.z, 1.0f/v2.z, 1.0f/v3.z);
        olivec_triangle3c(oc2, p1.x, p1.y, p2.x, p2.y, p3.x, p3.y, 0xFF1818FF, 0xFF18FF18, 0xFFFF1818);
    }

    for (size_t y = 0; y < HEIGHT; ++y) {
        for (size_t x = 0; x < WIDTH; ++x) {
            float z1 = *(float*)&OLIVEC_PIXEL(zb1, x, y);
            float z2 = *(float*)&OLIVEC_PIXEL(zb2, x, y);
            if (z1 < z2) {
                OLIVEC_PIXEL(oc1, x, y) = OLIVEC_PIXEL(oc2, x, y);
                z1 = z2;
            }
            z1 = 1.0f/z1;
            if (z1 >= 1.0) {
                z1 -= 1.0;
                uint32_t v = z1*255;
                if (v > 255) v = 255;
                olivec_blend_color(&OLIVEC_PIXEL(oc1, x, y), (v<<(3*8)));
            }
        }
    }

    return oc1;
}

```

`demos/triangle3dTex.c`:

```c
#define VC_TERM_SCALE_DOWN_FACTOR 10
#include "vc.c"
#include "./assets/tsodinPog.c"
#include "./assets/oldstone.c"
#include "./assets/lavastone.c"

#define WIDTH 960
#define HEIGHT 720

static uint32_t pixels1[WIDTH*HEIGHT];
static float zbuffer1[WIDTH*HEIGHT];
static uint32_t pixels2[WIDTH*HEIGHT];
static float zbuffer2[WIDTH*HEIGHT];

typedef struct {
    float x, y;
} Vector2;

static Vector2 make_vector2(float x, float y)
{
    Vector2 v2;
    v2.x = x;
    v2.y = y;
    return v2;
}

typedef struct {
    float x, y, z;
} Vector3;

static Vector3 make_vector3(float x, float y, float z)
{
    Vector3 v3;
    v3.x = x;
    v3.y = y;
    v3.z = z;
    return v3;
}

static Vector2 project_3d_2d(Vector3 v3)
{
    return make_vector2(v3.x / v3.z, v3.y / v3.z);
}

static Vector2 project_2d_scr(Vector2 v2)
{
    return make_vector2((v2.x + 1)/2*WIDTH, (1 - (v2.y + 1)/2)*HEIGHT);
}

static float global_time = 1.0;

#define PI 3.14159265359

float sinf(float);
float cosf(float);

Olivec_Canvas vc_render(float dt)
{
    global_time += dt;

    Olivec_Canvas oc1 = olivec_canvas(pixels1, WIDTH, HEIGHT, WIDTH);
    olivec_fill(oc1, 0xFF181818);
    Olivec_Canvas zb1 = olivec_canvas((uint32_t*)zbuffer1, WIDTH, HEIGHT, WIDTH);
    olivec_fill(zb1, 0);

    Olivec_Canvas oldstone = olivec_canvas(oldstone_pixels, oldstone_width, oldstone_height, oldstone_width);
    Olivec_Canvas lavastone = olivec_canvas(lavastone_pixels, lavastone_width, lavastone_height, lavastone_width);

    float z = 1.5;
    float t = 0.75;
    {
        Vector3 v1 = make_vector3(cosf(global_time)*t, -t, z + sinf(global_time)*t);
        Vector3 v2 = make_vector3(cosf(global_time + PI)*t, -t, z + sinf(global_time + PI)*t);
        Vector3 v3 = make_vector3(0, t, z);

        Vector2 p1 = project_2d_scr(project_3d_2d(v1));
        Vector2 p2 = project_2d_scr(project_3d_2d(v2));
        Vector2 p3 = project_2d_scr(project_3d_2d(v3));

        olivec_triangle3uv_bilinear(
            oc1,
            p1.x, p1.y, p2.x, p2.y, p3.x, p3.y,
            0/v1.z, 1/v1.z,
            1/v2.z, 1/v2.z,
            0.5/v3.z, 0/v3.z,
            1/v1.z, 1/v2.z, 1/v3.z,
            oldstone
        );
        olivec_triangle3z(zb1, p1.x, p1.y, p2.x, p2.y, p3.x, p3.y, 1.0f/v1.z, 1.0f/v2.z, 1.0f/v3.z);
    }

    Olivec_Canvas oc2 = olivec_canvas(pixels2, WIDTH, HEIGHT, WIDTH);
    olivec_fill(oc2, 0xFF181818);
    Olivec_Canvas zb2 = olivec_canvas((uint32_t*)zbuffer2, WIDTH, HEIGHT, WIDTH);
    olivec_fill(zb2, 0);

    {
        Vector3 v1 = make_vector3(cosf(global_time + PI/2)*t, -t, z + sinf(global_time + PI/2)*t);
        Vector3 v2 = make_vector3(cosf(global_time + PI + PI/2)*t, -t, z + sinf(global_time + PI + PI/2)*t);
        Vector3 v3 = make_vector3(0, t, z);

        Vector2 p1 = project_2d_scr(project_3d_2d(v1));
        Vector2 p2 = project_2d_scr(project_3d_2d(v2));
        Vector2 p3 = project_2d_scr(project_3d_2d(v3));

        olivec_triangle3uv_bilinear(
            oc2,
            p1.x, p1.y, p2.x, p2.y, p3.x, p3.y,
            0/v1.z, 1/v1.z,
            1/v2.z, 1/v2.z,
            0.5/v3.z, 0/v3.z,
            1/v1.z, 1/v2.z, 1/v3.z,
            lavastone
        );

        olivec_triangle3z(zb2, p1.x, p1.y, p2.x, p2.y, p3.x, p3.y, 1.0f/v1.z, 1.0f/v2.z, 1.0f/v3.z);
    }

    for (size_t y = 0; y < HEIGHT; ++y) {
        for (size_t x = 0; x < WIDTH; ++x) {
            float z1 = *(float*)&OLIVEC_PIXEL(zb1, x, y);
            float z2 = *(float*)&OLIVEC_PIXEL(zb2, x, y);
            if (z1 < z2) {
                OLIVEC_PIXEL(oc1, x, y) = OLIVEC_PIXEL(oc2, x, y);
                z1 = z2;
            }
            z1 = 1.0f/z1;
            if (z1 >= 1.0) {
                z1 -= 1.0;
                uint32_t v = z1*255;
                if (v > 255) v = 255;
                olivec_blend_color(&OLIVEC_PIXEL(oc1, x, y), (v<<(3*8)));
            }
        }
    }

    return oc1;
}

```

`demos/triangleTex.c`:

```c
#include "vc.c"
#include "assets/tsodinPog.c"

#define WIDTH 960
#define HEIGHT 720
#define BACKGROUND_COLOR 0xFF181818

static uint32_t pixels[WIDTH*HEIGHT];
static float triangle_angle = 0;

float sqrtf(float x);
float atan2f(float y, float x);
float sinf(float x);
float cosf(float x);

#define PI 3.14159265359

Olivec_Canvas vc_render(float dt)
{
    Olivec_Canvas oc = olivec_canvas(pixels, WIDTH, HEIGHT, WIDTH);
    Olivec_Canvas tsodinPog = olivec_canvas(tsodinPog_pixels, tsodinPog_width, tsodinPog_height, tsodinPog_width);

    olivec_fill(oc, BACKGROUND_COLOR);

    // Triangle
    {
        triangle_angle += 0.5f*PI*dt;

        float ps[4][2];
        float uvs[4][2] = {
            {0, 0},
            {1, 0},
            {1, 1},
            {0, 1},
        };
        float len = WIDTH/4;
        for (size_t i = 0; i < 4; ++i) {
            ps[i][0] = WIDTH/2  + cosf(PI/2*i + triangle_angle)*len;
            ps[i][1] = HEIGHT/2 + sinf(PI/2*i + triangle_angle)*len;
        }
        for (size_t i = 0; i < 2; ++i) {
            int i1 = (i*2 + 0)%4;
            int i2 = (i*2 + 1)%4;
            int i3 = (i*2 + 2)%4;
            olivec_triangle3uv_bilinear(
                oc,
                ps[i1][0], ps[i1][1],
                ps[i2][0], ps[i2][1],
                ps[i3][0], ps[i3][1],
                uvs[i1][0], uvs[i1][1],
                uvs[i2][0], uvs[i2][1],
                uvs[i3][0], uvs[i3][1],
                1, 1, 1,
                tsodinPog
            );
       }
    }

    return oc;
}

```

`demos/vc.c`:

```c
// C implementation of the Virtual Console (VC) for demos.
//
// # Usage
// ```c
// // demo.c
// // vc.c expectes render() to be defined and also supplies it's own entry point
// // if needed (some platforms like WASM_PLATFORM do not have the main()
// // entry point)
// #include "vc.c"
//
// #define WIDTH 800
// #define HEIGHT 600
// static uint32_t pixels[WIDTH*HEIGHT];
//
// static Olivec_Canvas vc_render(float dt)
// {
//     Olivec_Canvas oc = olivec_canvas(pixels, WIDTH, HEIGHT, WIDTH);
//     // ...
//     // ... render into oc ...
//     // ...
//     return oc;
// }
// ```
//
// # Build
// ```console
// $ clang -o demo.sdl -DVC_PLATFORM=VC_SDL_PLATFORM demo.c -lSDL2
// $ clang -o demo.term -DVC_PLATFORM=VC_TERM_PLATFORM demo.c
// $ clang -fno-builtin --target=wasm32 --no-standard-libraries -Wl,--no-entry -Wl,--export=render -Wl,--allow-undefined -o demo.wasm -DVC_PLATFORM=VC_WASM_PLATFORM demo.c
// ```

#define OLIVEC_IMPLEMENTATION
#include <olive.c>

Olivec_Canvas vc_render(float dt);

#ifndef VC_PLATFORM
#error "Please define VC_PLATFORM macro"
#endif

// Possible values of VC_PLATFORM
#define VC_WASM_PLATFORM 0
#define VC_SDL_PLATFORM 1
#define VC_TERM_PLATFORM 2

#if VC_PLATFORM == VC_SDL_PLATFORM
#include <stdio.h>
#include <SDL2/SDL.h>

#define return_defer(value) do { result = (value); goto defer; } while (0)

static SDL_Texture *vc_sdl_texture = NULL;
static size_t vc_sdl_actual_width = 0;
static size_t vc_sdl_actual_height = 0;

static bool vc_sdl_resize_texture(SDL_Renderer *renderer, size_t new_width, size_t new_height)
{
    if (vc_sdl_texture != NULL) SDL_DestroyTexture(vc_sdl_texture);
    vc_sdl_actual_width = new_width;
    vc_sdl_actual_height = new_height;
    vc_sdl_texture = SDL_CreateTexture(renderer, SDL_PIXELFORMAT_RGBA32, SDL_TEXTUREACCESS_STREAMING, vc_sdl_actual_width, vc_sdl_actual_height);
    if (vc_sdl_texture == NULL) return false;
    return true;
}

int main(void)
{
    int result = 0;

    SDL_Window *window = NULL;
    SDL_Renderer *renderer = NULL;

    {
        if (SDL_Init(SDL_INIT_VIDEO) < 0) return_defer(1);

        window = SDL_CreateWindow("Olivec", 0, 0, 0, 0, 0);
        if (window == NULL) return_defer(1);

        renderer = SDL_CreateRenderer(window, -1, SDL_RENDERER_ACCELERATED);
        if (renderer == NULL) return_defer(1);

        Uint32 prev = SDL_GetTicks();
        bool pause = false;
        for (;;) {
            // Compute Delta Time
            Uint32 curr = SDL_GetTicks();
            float dt = (curr - prev)/1000.f;
            prev = curr;

            // Flush the events
            SDL_Event event;
            while (SDL_PollEvent(&event)) {
                switch (event.type) {
                case SDL_QUIT: {
                    return_defer(0);
                } break;
                case SDL_KEYDOWN: {
                    if (event.key.keysym.sym == SDLK_SPACE) pause = !pause;
                } break;
                }
            }

            SDL_Rect window_rect = {0, 0, vc_sdl_actual_width, vc_sdl_actual_height};

            if (!pause) {
                // Render the texture
                Olivec_Canvas oc_src = vc_render(dt);
                if (oc_src.width != vc_sdl_actual_width || oc_src.height != vc_sdl_actual_height) {
                    if (!vc_sdl_resize_texture(renderer, oc_src.width, oc_src.height)) return_defer(1);
                    SDL_SetWindowSize(window, vc_sdl_actual_width, vc_sdl_actual_height);
                }
                void *pixels_dst;
                int pitch;
                if (SDL_LockTexture(vc_sdl_texture, &window_rect, &pixels_dst, &pitch) < 0) return_defer(1);
                for (size_t y = 0; y < vc_sdl_actual_height; ++y) {
                    // TODO: it would be cool if Olivec_Canvas supported pitch in bytes instead of pixels
                    // It would be more flexible and we could draw on the locked texture memory directly
                    memcpy((char*)pixels_dst + y*pitch, oc_src.pixels + y*vc_sdl_actual_width, vc_sdl_actual_width*sizeof(uint32_t));
                }
                SDL_UnlockTexture(vc_sdl_texture);
            }

            // Display the texture
            if (SDL_SetRenderDrawColor(renderer, 0, 0, 0, 0) < 0) return_defer(1);
            if (SDL_RenderClear(renderer) < 0) return_defer(1);
            if (SDL_RenderCopy(renderer, vc_sdl_texture, &window_rect, &window_rect) < 0) return_defer(1);
            SDL_RenderPresent(renderer);
        }
    }

defer:
    switch (result) {
    case 0:
        printf("OK\n");
        break;
    default:
        fprintf(stderr, "SDL ERROR: %s\n", SDL_GetError());
    }
    if (vc_sdl_texture) SDL_DestroyTexture(vc_sdl_texture);
    if (renderer) SDL_DestroyRenderer(renderer);
    if (window) SDL_DestroyWindow(window);
    SDL_Quit();
    return result;
}
#elif VC_PLATFORM == VC_TERM_PLATFORM

#include <assert.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <errno.h>
#include <time.h>
#include <unistd.h>
#include <math.h>

#define STB_IMAGE_WRITE_IMPLEMENTATION
#include "stb_image_write.h"

static size_t vc_term_actual_width = 0;
static size_t vc_term_actual_height = 0;
static size_t vc_term_scaled_down_width = 0;
static size_t vc_term_scaled_down_height = 0;
static int *vc_term_char_canvas = 0;

int hsl256[][3] = {
    {0, 0, 0},
    {0, 100, 25},
    {120, 100, 25},
    {60, 100, 25},
    {240, 100, 25},
    {300, 100, 25},
    {180, 100, 25},
    {0, 0, 75},
    {0, 0, 50},
    {0, 100, 50},
    {120, 100, 50},
    {60, 100, 50},
    {240, 100, 50},
    {300, 100, 50},
    {180, 100, 50},
    {0, 0, 100},
    {0, 0, 0},
    {240, 99, 18},
    {240, 100, 26},
    {240, 100, 34},
    {240, 100, 42},
    {240, 100, 50},
    {120, 99, 18},
    {180, 99, 18},
    {197, 100, 26},
    {207, 100, 34},
    {213, 100, 42},
    {217, 100, 50},
    {120, 100, 26},
    {162, 100, 26},
    {180, 100, 26},
    {193, 100, 34},
    {202, 100, 42},
    {208, 100, 50},
    {120, 100, 34},
    {152, 100, 34},
    {166, 100, 34},
    {180, 100, 34},
    {191, 100, 42},
    {198, 100, 50},
    {120, 100, 42},
    {146, 100, 42},
    {157, 100, 42},
    {168, 100, 42},
    {180, 100, 42},
    {189, 100, 50},
    {120, 100, 50},
    {142, 100, 50},
    {151, 100, 50},
    {161, 100, 50},
    {170, 100, 50},
    {180, 100, 50},
    {0, 99, 18},
    {300, 99, 18},
    {282, 100, 26},
    {272, 100, 34},
    {266, 100, 42},
    {262, 100, 50},
    {60, 99, 18},
    {0, 0, 37},
    {240, 17, 45},
    {240, 33, 52},
    {240, 60, 60},
    {240, 100, 68},
    {77, 100, 26},
    {120, 17, 45},
    {180, 17, 45},
    {210, 33, 52},
    {220, 60, 60},
    {225, 100, 68},
    {87, 100, 34},
    {120, 33, 52},
    {150, 33, 52},
    {180, 33, 52},
    {200, 60, 60},
    {210, 100, 68},
    {93, 100, 42},
    {120, 60, 60},
    {140, 60, 60},
    {160, 60, 60},
    {180, 60, 60},
    {195, 100, 68},
    {97, 100, 50},
    {120, 100, 68},
    {135, 100, 68},
    {150, 100, 68},
    {165, 100, 68},
    {180, 100, 68},
    {0, 100, 26},
    {317, 100, 26},
    {300, 100, 26},
    {286, 100, 34},
    {277, 100, 42},
    {271, 100, 50},
    {42, 100, 26},
    {0, 17, 45},
    {300, 17, 45},
    {270, 33, 52},
    {260, 60, 60},
    {255, 100, 68},
    {60, 100, 26},
    {60, 17, 45},
    {0, 0, 52},
    {240, 20, 60},
    {240, 50, 68},
    {240, 100, 76},
    {73, 100, 34},
    {90, 33, 52},
    {120, 20, 60},
    {180, 20, 60},
    {210, 50, 68},
    {220, 100, 76},
    {82, 100, 42},
    {100, 60, 60},
    {120, 50, 68},
    {150, 50, 68},
    {180, 50, 68},
    {200, 100, 76},
    {88, 100, 50},
    {105, 100, 68},
    {120, 100, 76},
    {140, 100, 76},
    {160, 100, 76},
    {180, 100, 76},
    {0, 100, 34},
    {327, 100, 34},
    {313, 100, 34},
    {300, 100, 34},
    {288, 100, 42},
    {281, 100, 50},
    {32, 100, 34},
    {0, 33, 52},
    {330, 33, 52},
    {300, 33, 52},
    {280, 60, 60},
    {270, 100, 68},
    {46, 100, 34},
    {30, 33, 52},
    {0, 20, 60},
    {300, 20, 60},
    {270, 50, 68},
    {260, 100, 76},
    {60, 100, 34},
    {60, 33, 52},
    {60, 20, 60},
    {0, 0, 68},
    {240, 33, 76},
    {240, 100, 84},
    {71, 100, 42},
    {80, 60, 60},
    {90, 50, 68},
    {120, 33, 76},
    {180, 33, 76},
    {210, 100, 84},
    {78, 100, 50},
    {90, 100, 68},
    {100, 100, 76},
    {120, 100, 84},
    {150, 100, 84},
    {180, 100, 84},
    {0, 100, 42},
    {333, 100, 42},
    {322, 100, 42},
    {311, 100, 42},
    {300, 100, 42},
    {290, 100, 50},
    {26, 100, 42},
    {0, 60, 60},
    {340, 60, 60},
    {320, 60, 60},
    {300, 60, 60},
    {285, 100, 68},
    {37, 100, 42},
    {20, 60, 60},
    {0, 50, 68},
    {330, 50, 68},
    {300, 50, 68},
    {280, 100, 76},
    {48, 100, 42},
    {40, 60, 60},
    {30, 50, 68},
    {0, 33, 76},
    {300, 33, 76},
    {270, 100, 84},
    {60, 100, 42},
    {60, 60, 60},
    {60, 50, 68},
    {60, 33, 76},
    {0, 0, 84},
    {240, 100, 92},
    {69, 100, 50},
    {75, 100, 68},
    {80, 100, 76},
    {90, 100, 84},
    {120, 100, 92},
    {180, 100, 92},
    {0, 100, 50},
    {337, 100, 50},
    {328, 100, 50},
    {318, 100, 50},
    {309, 100, 50},
    {300, 100, 50},
    {22, 100, 50},
    {0, 100, 68},
    {345, 100, 68},
    {330, 100, 68},
    {315, 100, 68},
    {300, 100, 68},
    {31, 100, 50},
    {15, 100, 68},
    {0, 100, 76},
    {340, 100, 76},
    {320, 100, 76},
    {300, 100, 76},
    {41, 100, 50},
    {30, 100, 68},
    {20, 100, 76},
    {0, 100, 84},
    {330, 100, 84},
    {300, 100, 84},
    {50, 100, 50},
    {45, 100, 68},
    {40, 100, 76},
    {30, 100, 84},
    {0, 100, 92},
    {300, 100, 92},
    {60, 100, 50},
    {60, 100, 68},
    {60, 100, 76},
    {60, 100, 84},
    {60, 100, 92},
    {0, 0, 100},
    {0, 0, 3},
    {0, 0, 7},
    {0, 0, 10},
    {0, 0, 14},
    {0, 0, 18},
    {0, 0, 22},
    {0, 0, 26},
    {0, 0, 30},
    {0, 0, 34},
    {0, 0, 38},
    {0, 0, 42},
    {0, 0, 46},
    {0, 0, 50},
    {0, 0, 54},
    {0, 0, 58},
    {0, 0, 61},
    {0, 0, 65},
    {0, 0, 69},
    {0, 0, 73},
    {0, 0, 77},
    {0, 0, 81},
    {0, 0, 85},
    {0, 0, 89},
    {0, 0, 93},
};

int distance_hsl256(int i, int h, int s, int l)
{
    int dh = h - hsl256[i][0];
    int ds = s - hsl256[i][1];
    int dl = l - hsl256[i][2];
    return dh*dh + ds*ds + dl*dl;
}

// TODO: bring find_ansi_index_by_rgb from image2term
int find_ansi_index_by_hsl(int h, int s, int l)
{
    int index = 0;
    for (int i = 0; i < 256; ++i) {
        if (distance_hsl256(i, h, s, l) < distance_hsl256(index, h, s, l)) {
            index = i;
        }
    }
    return index;
}

static uint32_t vc_term_compress_pixels_chunk(Olivec_Canvas oc)
{
    size_t r = 0;
    size_t g = 0;
    size_t b = 0;
    size_t a = 0;

    for (size_t y = 0; y < oc.height; ++y) {
        for (size_t x = 0; x < oc.width; ++x) {
            r += OLIVEC_RED(OLIVEC_PIXEL(oc, x, y));
            g += OLIVEC_GREEN(OLIVEC_PIXEL(oc, x, y));
            b += OLIVEC_BLUE(OLIVEC_PIXEL(oc, x, y));
            a += OLIVEC_ALPHA(OLIVEC_PIXEL(oc, x, y));
        }
    }

    r /= oc.width*oc.height;
    g /= oc.width*oc.height;
    b /= oc.width*oc.height;
    a /= oc.width*oc.height;

    return OLIVEC_RGBA(r, g, b, a);
}

#ifndef VC_TERM_SCALE_DOWN_FACTOR
#define VC_TERM_SCALE_DOWN_FACTOR 20
#endif // VC_TERM_SCALE_DOWN_FACTOR

static void vc_term_resize_char_canvas(size_t new_width, size_t new_height)
{
    // TODO: warn the user if vc_term_actual_width does not fit into the screen
    // TODO: can we just do something so the divisibility is not important?
    // Like round the stuff or something?
    // Or we can resize the frame on the fly similarly to how we resize sprites in olivec_sprite_*() functions.
    assert(new_width%VC_TERM_SCALE_DOWN_FACTOR == 0 && "Width must be divisible by VC_TERM_SCALE_DOWN_FACTOR");
    assert(new_height%VC_TERM_SCALE_DOWN_FACTOR == 0 && "Height must be divisible by VC_TERM_SCALE_DOWN_FACTOR");
    vc_term_actual_width = new_width;
    vc_term_actual_height = new_height;
    vc_term_scaled_down_width  = vc_term_actual_width/VC_TERM_SCALE_DOWN_FACTOR;
    vc_term_scaled_down_height = vc_term_actual_height/VC_TERM_SCALE_DOWN_FACTOR;
    free(vc_term_char_canvas);
    vc_term_char_canvas = malloc(sizeof(*vc_term_char_canvas)*vc_term_scaled_down_width*vc_term_scaled_down_height);
    assert(vc_term_char_canvas != NULL && "Just buy more RAM");
}

void rgb_to_hsl(int r, int g, int b, int *h, int *s, int *l)
{
    float r01 = r/255.0f;
    float g01 = g/255.0f;
    float b01 = b/255.0f;
    float cmax = r01;
    if (g01 > cmax) cmax = g01;
    if (b01 > cmax) cmax = b01;
    float cmin = r01;
    if (g01 < cmin) cmin = g01;
    if (b01 < cmin) cmin = b01;
    float delta = cmax - cmin;
    float epsilon = 1e-6;
    float hf = 0;
    if (delta < epsilon) hf = 0;
    else if (cmax == r01) hf = 60.0f*fmod((g01 - b01)/delta, 6.0f);
    else if (cmax == g01) hf = 60.0f*((b01 - r01)/delta + 2);
    else if (cmax == b01) hf = 60.0f*((r01 - g01)/delta + 4);
    else assert(0 && "unreachable");

    float lf = (cmax + cmin)/2;

    float sf = 0;
    if (delta < epsilon) sf = 0;
    else sf = delta/(1 - fabsf(2*lf - 1));

    *h = fmodf(fmodf(hf, 360.0f) + 360.0f, 360.0f);
    *s = sf*100.0f;
    *l = lf*100.0f;
}

static void vc_term_compress_pixels(Olivec_Canvas oc)
{
    if (vc_term_actual_width != oc.width || vc_term_actual_height != oc.height) {
        vc_term_resize_char_canvas(oc.width, oc.height);
    }

    for (size_t y = 0; y < vc_term_scaled_down_height; ++y) {
        for (size_t x = 0; x < vc_term_scaled_down_width; ++x) {
            Olivec_Canvas soc = olivec_subcanvas(oc, x*VC_TERM_SCALE_DOWN_FACTOR, y*VC_TERM_SCALE_DOWN_FACTOR, VC_TERM_SCALE_DOWN_FACTOR, VC_TERM_SCALE_DOWN_FACTOR);
            uint32_t cp = vc_term_compress_pixels_chunk(soc);
            int r = OLIVEC_RED(cp);
            int g = OLIVEC_GREEN(cp);
            int b = OLIVEC_BLUE(cp);
            int a = OLIVEC_ALPHA(cp);
            r = a*r/255;
            g = a*g/255;
            b = a*b/255;
            int h, s, l;
            rgb_to_hsl(r, g, b, &h, &s, &l);
            vc_term_char_canvas[y*vc_term_scaled_down_width + x] = find_ansi_index_by_hsl(h, s, l);
        }
    }
}

int main(void)
{
    for (;;) {
        vc_term_compress_pixels(vc_render(1.f/60.f));
        for (size_t y = 0; y < vc_term_scaled_down_height; ++y) {
            for (size_t x = 0; x < vc_term_scaled_down_width; ++x) {
                // TODO: explore the idea of figuring out aspect ratio of the character using escape ANSI codes of the terminal and rendering the image accordingly
                printf("\033[48;5;%dm  ", vc_term_char_canvas[y*vc_term_scaled_down_width + x]);
            }
            printf("\033[0m\n");
        }

        usleep(1000*1000/60);
        printf("\033[%zuA", vc_term_scaled_down_height);
        printf("\033[%zuD", vc_term_scaled_down_width);
    }
    return 0;
}
#elif VC_PLATFORM == VC_WASM_PLATFORM
// Do nothing because all the work is done in ../js/vc.js
#else
#error "Unknown VC platform"
#endif // VC_SDL_PLATFORM

```

`dev-deps/arena.h`:

```h
// Copyright 2022 Alexey Kutepov <reximkut@gmail.com>

// Permission is hereby granted, free of charge, to any person obtaining
// a copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to
// permit persons to whom the Software is furnished to do so, subject to
// the following conditions:

// The above copyright notice and this permission notice shall be
// included in all copies or substantial portions of the Software.

// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

#ifndef ARENA_H_
#define ARENA_H_

#include <stddef.h>
#include <stdint.h>

#ifndef ARENA_ASSERT
#include <assert.h>
#define ARENA_ASSERT assert
#endif

#define ARENA_BACKEND_LIBC_MALLOC 0
#define ARENA_BACKEND_LINUX_MMAP 1
#define ARENA_BACKEND_WIN32_VIRTUALALLOC 2
#define ARENA_BACKEND_WASM_HEAPBASE 3

#ifndef ARENA_BACKEND
#define ARENA_BACKEND ARENA_BACKEND_LIBC_MALLOC
#endif // ARENA_BACKEND

typedef struct Region Region;

struct Region {
    Region *next;
    size_t count;
    size_t capacity;
    uintptr_t data[];
};

typedef struct {
    Region *begin, *end;
} Arena;

#define REGION_DEFAULT_CAPACITY (8*1024)

Region *new_region(size_t capacity);
void free_region(Region *r);

// TODO: snapshot/rewind capability for the arena
// - Snapshot should be combination of a->end and a->end->count. 
// - Rewinding should be restoring a->end and a->end->count from the snapshot and
// setting count-s of all the Region-s after the remembered a->end to 0.
void *arena_alloc(Arena *a, size_t size_bytes);
void arena_reset(Arena *a);
void arena_free(Arena *a);

#endif // ARENA_H_

#ifdef ARENA_IMPLEMENTATION

#if ARENA_BACKEND == ARENA_BACKEND_LIBC_MALLOC
#include <stdlib.h>

// TODO: instead of accepting specific capacity new_region() should accept the size of the object we want to fit into the region
// It should be up to new_region() to decide the actual capacity to allocate
Region *new_region(size_t capacity)
{
    size_t size_bytes = sizeof(Region) + sizeof(uintptr_t)*capacity;
    // TODO: it would be nice if we could guarantee that the regions are allocated by ARENA_BACKEND_LIBC_MALLOC are page aligned
    Region *r = malloc(size_bytes);
    ARENA_ASSERT(r);
    r->next = NULL;
    r->count = 0;
    r->capacity = capacity;
    return r;
}

void free_region(Region *r)
{
    free(r);
}
#elif ARENA_BACKEND == ARENA_BACKEND_LINUX_MMAP
#  error "TODO: Linux mmap backend is not implemented yet"
#elif ARENA_BACKEND == ARENA_BACKEND_WIN32_VIRTUALALLOC
#  error "TODO: Win32 VirtualAlloc backend is not implemented yet"
#elif ARENA_BACKEND == ARENA_BACKEND_WASM_HEAPBASE
#  error "TODO: WASM __heap_base backend is not implemented yet"
#else
#  error "Unknown Arena backend"
#endif

// TODO: add debug statistic collection mode for arena
// Should collect things like:
// - How many times new_region was called
// - How many times existing region was skipped
// - How many times allocation exceeded REGION_DEFAULT_CAPACITY

void *arena_alloc(Arena *a, size_t size_bytes)
{
    size_t size = (size_bytes + sizeof(uintptr_t) - 1)/sizeof(uintptr_t);

    if (a->end == NULL) {
        ARENA_ASSERT(a->begin == NULL);
        size_t capacity = REGION_DEFAULT_CAPACITY;
        if (capacity < size) capacity = size;
        a->end = new_region(capacity);
        a->begin = a->end;
    }

    while (a->end->count + size > a->end->capacity && a->end->next != NULL) {
        a->end = a->end->next;
    }

    if (a->end->count + size > a->end->capacity) {
        ARENA_ASSERT(a->end->next == NULL);
        size_t capacity = REGION_DEFAULT_CAPACITY;
        if (capacity < size) capacity = size;
        a->end->next = new_region(capacity);
        a->end = a->end->next;
    }

    void *result = &a->end->data[a->end->count];
    a->end->count += size;
    return result;
}

void arena_reset(Arena *a)
{
    for (Region *r = a->begin; r != NULL; r = r->next) {
        r->count = 0;
    }

    a->end = a->begin;
}

void arena_free(Arena *a)
{
    Region *r = a->begin;
    while (r) {
        Region *r0 = r;
        r = r->next;
        free_region(r0);
    }
    a->begin = NULL;
    a->end = NULL;
}

#endif // ARENA_IMPLEMENTATION

```

`dev-deps/nob.h`:

```h
/* nob - v1.23.0 - Public Domain - https://github.com/tsoding/nob.h

   This library is the next generation of the [NoBuild](https://github.com/tsoding/nobuild) idea.

   # Quick Example

      ```c
      // nob.c
      #define NOB_IMPLEMENTATION
      #include "nob.h"

      int main(int argc, char **argv)
      {
          NOB_GO_REBUILD_URSELF(argc, argv);
          Nob_Cmd cmd = {0};
          nob_cmd_append(&cmd, "cc", "-Wall", "-Wextra", "-o", "main", "main.c");
          if (!nob_cmd_run(&cmd)) return 1;
          return 0;
      }
      ```

      ```console
      $ cc -o nob nob.c
      $ ./nob
      ```

      The `nob` automatically rebuilds itself if `nob.c` is modified thanks to
      the `NOB_GO_REBUILD_URSELF` macro (don't forget to check out how it works below)

   # Stripping off `nob_` Prefixes

      Since Pure C does not have any namespaces we prefix each name of the API with the `nob_` to avoid any
      potential conflicts with any other names in your code. But sometimes it is very annoying and makes
      the code noisy. If you know that none of the names from nob.h conflict with anything in your code
      you can enable NOB_STRIP_PREFIX macro and just drop all the prefixes:

      ```c
      // nob.c
      #define NOB_IMPLEMENTATION
      #define NOB_STRIP_PREFIX
      #include "nob.h"

      int main(int argc, char **argv)
      {
          NOB_GO_REBUILD_URSELF(argc, argv);
          Cmd cmd = {0};
          cmd_append(&cmd, "cc", "-Wall", "-Wextra", "-o", "main", "main.c");
          if (!cmd_run(&cmd)) return 1;
          return 0;
      }
      ```

      Not all the names have strippable prefixes. All the redefinable names like `NOB_GO_REBUILD_URSELF`
      for instance will retain their prefix even if NOB_STRIP_PREFIX is enabled. Notable exception is the
      nob_log() function. Stripping away the prefix results in log() which was historically always referring
      to the natural logarithmic function that is already defined in math.h. So there is no reason to strip
      off the prefix for nob_log(). Another exception is nob_rename() which collides with the widely known
      POSIX function rename(2) if you strip the prefix off.

      The prefixes are stripped off only on the level of preprocessor. The names of the functions in the
      compiled object file will still retain the `nob_` prefix. Keep that in mind when you FFI with nob.h
      from other languages (for whatever reason).

      If only few specific names create conflicts for you, you can just #undef those names after the
      `#include <nob.h>` since they are macros anyway.

   # Macro Interface

      All these macros are `#define`d by the user before including nob.h

   ## Flags

      Enable or disable certain aspects of nob.h

      - NOB_IMPLEMENTATION - Enable definitions of the functions. By default only declarations are included.
        See https://github.com/nothings/stb/blob/f58f558c120e9b32c217290b80bad1a0729fbb2c/docs/stb_howto.txt
        for more info.
      - NOB_WARN_DEPRECATED - Warn about the usage of deprecated function. We rarely actually remove deprecated functions,
        but if you want to know what is discourage you may want to enable this flag.
      - NOB_EXPERIMENTAL_DELETE_OLD - Experimental feature that automatically removes `nob.old` files. It's unclear how well
        it works on Windows, so it's experimental for now.
      - NOB_STRIP_PREFIX - string the `nob_` prefixes from non-redefinable names.

   ## Redefinable Macros

      Redefine default behaviors of nob.h.

      - NOBDEF - Appends additional things to function declarations. You can do something like `#define NOBDEF static inline`.
      - NOB_ASSERT(condition) - Redefine which assert() nob.h shall use.
      - NOB_REALLOC(oldptr, size) - Redefine which realloc() nob.h shall use.
      - NOB_FREE(ptr) - Redefine which free() nob.h shall use.
      - NOB_DEPRECATED(message) - Redefine how nob.h shall mark functions as deprecated.
      - NOB_DA_INIT_CAP - Redefine initial capacity of Dynamic Arrays.
      - NOB_TEMP_CAPACITY - Redefine the capacity of the temporary storate.
      - NOB_REBUILD_URSELF(binary_path, source_path) - redefine how nob.h shall rebuild itself.
      - NOB_WIN32_ERR_MSG_SIZE - Redefine the capacity of the buffer for error message on Windows.
*/

#ifndef NOB_H_
#define NOB_H_
#ifdef _WIN32
#define _CRT_SECURE_NO_WARNINGS (1)
#endif

#ifndef NOBDEF
/*
   Goes before declarations and definitions of the nob functions. Useful to `#define NOBDEF static inline`
   if your source code is a single file and you want the compiler to remove unused functions.
*/
#define NOBDEF
#endif /* NOBDEF */

#ifndef NOB_ASSERT
#include <assert.h>
#define NOB_ASSERT assert
#endif /* NOB_ASSERT */

#ifndef NOB_REALLOC
#include <stdlib.h>
#define NOB_REALLOC realloc
#endif /* NOB_REALLOC */

#ifndef NOB_FREE
#include <stdlib.h>
#define NOB_FREE free
#endif /* NOB_FREE */

#ifdef NOB_WARN_DEPRECATED
#    ifndef NOB_DEPRECATED
#        if defined(__GNUC__) || defined(__clang__)
#            define NOB_DEPRECATED(message) __attribute__((deprecated(message)))
#        elif defined(_MSC_VER)
#            define NOB_DEPRECATED(message) __declspec(deprecated(message))
#        else
#            define NOB_DEPRECATED(...)
#        endif
#    endif /* NOB_DEPRECATED */
#else
#    define NOB_DEPRECATED(...)
#endif /* NOB_WARN_DEPRECATED */

#include <stdbool.h>
#include <stdint.h>
#include <stdlib.h>
#include <stdio.h>
#include <stdarg.h>
#include <string.h>
#include <errno.h>
#include <ctype.h>
#include <limits.h>
#include <time.h>

#ifdef _WIN32
#    define WIN32_LEAN_AND_MEAN
#    define _WINUSER_
#    define _WINGDI_
#    define _IMM_
#    define _WINCON_
#    include <windows.h>
#    include <direct.h>
#    include <shellapi.h>
#else
#    include <sys/types.h>
#    include <sys/wait.h>
#    include <sys/stat.h>
#    include <unistd.h>
#    include <fcntl.h>
#endif

#ifdef _WIN32
#    define NOB_LINE_END "\r\n"
#else
#    define NOB_LINE_END "\n"
#endif

#if defined(__GNUC__) || defined(__clang__)
//   https://gcc.gnu.org/onlinedocs/gcc-4.7.2/gcc/Function-Attributes.html
#    ifdef __MINGW_PRINTF_FORMAT
#        define NOB_PRINTF_FORMAT(STRING_INDEX, FIRST_TO_CHECK) __attribute__ ((format (__MINGW_PRINTF_FORMAT, STRING_INDEX, FIRST_TO_CHECK)))
#    else
#        define NOB_PRINTF_FORMAT(STRING_INDEX, FIRST_TO_CHECK) __attribute__ ((format (printf, STRING_INDEX, FIRST_TO_CHECK)))
#    endif // __MINGW_PRINTF_FORMAT
#else
//   TODO: implement NOB_PRINTF_FORMAT for MSVC
#    define NOB_PRINTF_FORMAT(STRING_INDEX, FIRST_TO_CHECK)
#endif

#define NOB_UNUSED(value) (void)(value)
#define NOB_TODO(message) do { fprintf(stderr, "%s:%d: TODO: %s\n", __FILE__, __LINE__, message); abort(); } while(0)
#define NOB_UNREACHABLE(message) do { fprintf(stderr, "%s:%d: UNREACHABLE: %s\n", __FILE__, __LINE__, message); abort(); } while(0)

#define NOB_ARRAY_LEN(array) (sizeof(array)/sizeof(array[0]))
#define NOB_ARRAY_GET(array, index) \
    (NOB_ASSERT((size_t)index < NOB_ARRAY_LEN(array)), array[(size_t)index])

typedef enum {
    NOB_INFO,
    NOB_WARNING,
    NOB_ERROR,
    NOB_NO_LOGS,
} Nob_Log_Level;

// Any messages with the level below nob_minimal_log_level are going to be suppressed.
extern Nob_Log_Level nob_minimal_log_level;

NOBDEF void nob_log(Nob_Log_Level level, const char *fmt, ...) NOB_PRINTF_FORMAT(2, 3);

// It is an equivalent of shift command from bash (do `help shift` in bash). It basically
// pops an element from the beginning of a sized array.
#define nob_shift(xs, xs_sz) (NOB_ASSERT((xs_sz) > 0), (xs_sz)--, *(xs)++)
// NOTE: nob_shift_args() is an alias for an old variant of nob_shift that only worked with
// the command line arguments passed to the main() function. nob_shift() is more generic.
// So nob_shift_args() is semi-deprecated, but I don't see much reason to urgently
// remove it. This alias does not hurt anybody.
#define nob_shift_args(argc, argv) nob_shift(*argv, *argc)

typedef struct {
    const char **items;
    size_t count;
    size_t capacity;
} Nob_File_Paths;

typedef enum {
    NOB_FILE_REGULAR = 0,
    NOB_FILE_DIRECTORY,
    NOB_FILE_SYMLINK,
    NOB_FILE_OTHER,
} Nob_File_Type;

NOBDEF bool nob_mkdir_if_not_exists(const char *path);
NOBDEF bool nob_copy_file(const char *src_path, const char *dst_path);
NOBDEF bool nob_copy_directory_recursively(const char *src_path, const char *dst_path);
NOBDEF bool nob_read_entire_dir(const char *parent, Nob_File_Paths *children);
NOBDEF bool nob_write_entire_file(const char *path, const void *data, size_t size);
NOBDEF Nob_File_Type nob_get_file_type(const char *path);
NOBDEF bool nob_delete_file(const char *path);

#define nob_return_defer(value) do { result = (value); goto defer; } while(0)

// Initial capacity of a dynamic array
#ifndef NOB_DA_INIT_CAP
#define NOB_DA_INIT_CAP 256
#endif

#ifdef __cplusplus
#define NOB_DECLTYPE_CAST(T) (decltype(T))
#else
#define NOB_DECLTYPE_CAST(T)
#endif // __cplusplus

#define nob_da_reserve(da, expected_capacity)                                              \
    do {                                                                                   \
        if ((expected_capacity) > (da)->capacity) {                                        \
            if ((da)->capacity == 0) {                                                     \
                (da)->capacity = NOB_DA_INIT_CAP;                                          \
            }                                                                              \
            while ((expected_capacity) > (da)->capacity) {                                 \
                (da)->capacity *= 2;                                                       \
            }                                                                              \
            (da)->items = NOB_DECLTYPE_CAST((da)->items)NOB_REALLOC((da)->items, (da)->capacity * sizeof(*(da)->items)); \
            NOB_ASSERT((da)->items != NULL && "Buy more RAM lol");                         \
        }                                                                                  \
    } while (0)

// Append an item to a dynamic array
#define nob_da_append(da, item)                \
    do {                                       \
        nob_da_reserve((da), (da)->count + 1); \
        (da)->items[(da)->count++] = (item);   \
    } while (0)

#define nob_da_free(da) NOB_FREE((da).items)

// Append several items to a dynamic array
#define nob_da_append_many(da, new_items, new_items_count)                                      \
    do {                                                                                        \
        nob_da_reserve((da), (da)->count + (new_items_count));                                  \
        memcpy((da)->items + (da)->count, (new_items), (new_items_count)*sizeof(*(da)->items)); \
        (da)->count += (new_items_count);                                                       \
    } while (0)

#define nob_da_resize(da, new_size)     \
    do {                                \
        nob_da_reserve((da), new_size); \
        (da)->count = (new_size);       \
    } while (0)

#define nob_da_last(da) (da)->items[(NOB_ASSERT((da)->count > 0), (da)->count-1)]
#define nob_da_remove_unordered(da, i)               \
    do {                                             \
        size_t j = (i);                              \
        NOB_ASSERT(j < (da)->count);                 \
        (da)->items[j] = (da)->items[--(da)->count]; \
    } while(0)

// Foreach over Dynamic Arrays. Example:
// ```c
// typedef struct {
//     int *items;
//     size_t count;
//     size_t capacity;
// } Numbers;
//
// Numbers xs = {0};
//
// nob_da_append(&xs, 69);
// nob_da_append(&xs, 420);
// nob_da_append(&xs, 1337);
//
// nob_da_foreach(int, x, &xs) {
//     // `x` here is a pointer to the current element. You can get its index by taking a difference
//     // between `x` and the start of the array which is `x.items`.
//     size_t index = x - xs.items;
//     nob_log(INFO, "%zu: %d", index, *x);
// }
// ```
#define nob_da_foreach(Type, it, da) for (Type *it = (da)->items; it < (da)->items + (da)->count; ++it)

typedef struct {
    char *items;
    size_t count;
    size_t capacity;
} Nob_String_Builder;

NOBDEF bool nob_read_entire_file(const char *path, Nob_String_Builder *sb);
NOBDEF int nob_sb_appendf(Nob_String_Builder *sb, const char *fmt, ...) NOB_PRINTF_FORMAT(2, 3);

// Append a sized buffer to a string builder
#define nob_sb_append_buf(sb, buf, size) nob_da_append_many(sb, buf, size)

// Append a NULL-terminated string to a string builder
#define nob_sb_append_cstr(sb, cstr)  \
    do {                              \
        const char *s = (cstr);       \
        size_t n = strlen(s);         \
        nob_da_append_many(sb, s, n); \
    } while (0)

// Append a single NULL character at the end of a string builder. So then you can
// use it a NULL-terminated C string
#define nob_sb_append_null(sb) nob_da_append_many(sb, "", 1)

// Free the memory allocated by a string builder
#define nob_sb_free(sb) NOB_FREE((sb).items)

// Process handle
#ifdef _WIN32
typedef HANDLE Nob_Proc;
#define NOB_INVALID_PROC INVALID_HANDLE_VALUE
typedef HANDLE Nob_Fd;
#define NOB_INVALID_FD INVALID_HANDLE_VALUE
#else
typedef int Nob_Proc;
#define NOB_INVALID_PROC (-1)
typedef int Nob_Fd;
#define NOB_INVALID_FD (-1)
#endif // _WIN32

NOBDEF Nob_Fd nob_fd_open_for_read(const char *path);
NOBDEF Nob_Fd nob_fd_open_for_write(const char *path);
NOBDEF void nob_fd_close(Nob_Fd fd);

typedef struct {
    Nob_Proc *items;
    size_t count;
    size_t capacity;
} Nob_Procs;

// Wait until the process has finished
NOBDEF bool nob_proc_wait(Nob_Proc proc);

// Wait until all the processes have finished
NOBDEF bool nob_procs_wait(Nob_Procs procs);

// Wait until all the processes have finished and empty the procs array.
NOBDEF bool nob_procs_flush(Nob_Procs *procs);

// Alias to nob_procs_flush
NOB_DEPRECATED("Use `nob_procs_flush(&procs)` instead.")
NOBDEF bool nob_procs_wait_and_reset(Nob_Procs *procs);

// Append a new process to procs array and if procs.count reaches max_procs_count call nob_procs_wait_and_reset() on it
NOB_DEPRECATED("Use `nob_cmd_run(&cmd, .async = &procs, .max_procs = <integer>)` instead")
NOBDEF bool nob_procs_append_with_flush(Nob_Procs *procs, Nob_Proc proc, size_t max_procs_count);

// A command - the main workhorse of Nob. Nob is all about building commands and running them
typedef struct {
    const char **items;
    size_t count;
    size_t capacity;
} Nob_Cmd;

// Options for nob_cmd_run_opt() function.
typedef struct {
    // Run the command asynchronously appending its Nob_Proc to the provided Nob_Procs array
    Nob_Procs *async;
    // Maximum processes allowed in the .async list. Zero implies nob_nprocs().
    size_t max_procs;
    // Redirect stdin to file
    const char *stdin_path;
    // Redirect stdout to file
    const char *stdout_path;
    // Redirect stderr to file
    const char *stderr_path;
} Nob_Cmd_Opt;

// Run the command with options.
NOBDEF bool nob_cmd_run_opt(Nob_Cmd *cmd, Nob_Cmd_Opt opt);

// Get amount of processors on the machine.
NOBDEF int nob_nprocs(void);

#define NOB_NANOS_PER_SEC (1000*1000*1000)

// The maximum time span representable is 584 years.
NOBDEF uint64_t nob_nanos_since_unspecified_epoch(void);

// Same as nob_cmd_run_opt but using cool variadic macro to set the default options.
// See https://x.com/vkrajacic/status/1749816169736073295 for more info on how to use such macros.
#define nob_cmd_run(cmd, ...) nob_cmd_run_opt((cmd), (Nob_Cmd_Opt){__VA_ARGS__})

// DEPRECATED:
//
// You were suppose to use this structure like this:
//
// ```c
// Nob_Fd fdin = nob_fd_open_for_read("input.txt");
// if (fdin == NOB_INVALID_FD) fail();
// Nob_Fd fdout = nob_fd_open_for_write("output.txt");
// if (fdout == NOB_INVALID_FD) fail();
// Nob_Cmd cmd = {0};
// nob_cmd_append(&cmd, "cat");
// if (!nob_cmd_run_sync_redirect_and_reset(&cmd, (Nob_Cmd_Redirect) {
//     .fdin = &fdin,
//     .fdout = &fdout
// })) fail();
// ```
//
// But these days you should do:
//
// ```c
// Nob_Cmd cmd = {0};
// nob_cmd_append(&cmd, "cat");
// if (!nob_cmd_run(&cmd, .stdin_path = "input.txt", .stdout_path = "output.txt")) fail();
// ```
typedef struct {
    Nob_Fd *fdin;
    Nob_Fd *fdout;
    Nob_Fd *fderr;
} Nob_Cmd_Redirect;

// Render a string representation of a command into a string builder. Keep in mind the the
// string builder is not NULL-terminated by default. Use nob_sb_append_null if you plan to
// use it as a C string.
NOBDEF void nob_cmd_render(Nob_Cmd cmd, Nob_String_Builder *render);

#define nob_cmd_append(cmd, ...) \
    nob_da_append_many(cmd, \
                       ((const char*[]){__VA_ARGS__}), \
                       (sizeof((const char*[]){__VA_ARGS__})/sizeof(const char*)))

// TODO: nob_cmd_extend() evaluates other_cmd twice
#define nob_cmd_extend(cmd, other_cmd) \
    nob_da_append_many(cmd, (other_cmd)->items, (other_cmd)->count)

// Free all the memory allocated by command arguments
#define nob_cmd_free(cmd) NOB_FREE(cmd.items)

// Run command asynchronously
NOB_DEPRECATED("Use `nob_cmd_run(&cmd, .async = &procs)` instead, but keep in mind that it always resets the cmd array.")
NOBDEF Nob_Proc nob_cmd_run_async(Nob_Cmd cmd);

// nob_cmd_run_async_and_reset() is just like nob_cmd_run_async() except it also resets cmd.count to 0
// so the Nob_Cmd instance can be seamlessly used several times in a row
NOB_DEPRECATED("Use `nob_cmd_run(&cmd, .async = &procs)` intead.")
NOBDEF Nob_Proc nob_cmd_run_async_and_reset(Nob_Cmd *cmd);

// Run redirected command asynchronously
NOB_DEPRECATED("Use `nob_cmd_run(&cmd, "
               ".async = &procs, "
               ".stdin_path = \"path/to/stdin\", "
               ".stdout_path = \"path/to/stdout\", "
               ".stderr_path = \"path/to/stderr\")` instead, "
               "but keep in mind that it always resets the cmd array.")
NOBDEF Nob_Proc nob_cmd_run_async_redirect(Nob_Cmd cmd, Nob_Cmd_Redirect redirect);

// Run redirected command asynchronously and set cmd.count to 0 and close all the opened files
NOB_DEPRECATED("Use `nob_cmd_run(&cmd, "
               ".async = &procs, "
               ".stdin_path = \"path/to/stdin\", "
               ".stdout_path = \"path/to/stdout\", "
               ".stderr_path = \"path/to/stderr\")` instead.")
NOBDEF Nob_Proc nob_cmd_run_async_redirect_and_reset(Nob_Cmd *cmd, Nob_Cmd_Redirect redirect);

// Run command synchronously
NOB_DEPRECATED("Use `nob_cmd_run(&cmd)` instead, "
               "but keep in mind that it always resets the cmd array.")
NOBDEF bool nob_cmd_run_sync(Nob_Cmd cmd);

// NOTE: nob_cmd_run_sync_and_reset() is just like nob_cmd_run_sync() except it also resets cmd.count to 0
// so the Nob_Cmd instance can be seamlessly used several times in a row
NOB_DEPRECATED("Use `nob_cmd_run(&cmd)` instead.")
NOBDEF bool nob_cmd_run_sync_and_reset(Nob_Cmd *cmd);

// Run redirected command synchronously
NOB_DEPRECATED("Use `nob_cmd_run(&cmd, "
               ".stdin_path  = \"path/to/stdin\", "
               ".stdout_path = \"path/to/stdout\", "
               ".stderr_path = \"path/to/stderr\")` instead, "
               "but keep in mind that it always resets the cmd array.")
NOBDEF bool nob_cmd_run_sync_redirect(Nob_Cmd cmd, Nob_Cmd_Redirect redirect);

// Run redirected command synchronously and set cmd.count to 0 and close all the opened files
NOB_DEPRECATED("Use `nob_cmd_run(&cmd, "
               ".stdin_path = \"path/to/stdin\", "
               ".stdout_path = \"path/to/stdout\", "
               ".stderr_path = \"path/to/stderr\")` instead.")
NOBDEF bool nob_cmd_run_sync_redirect_and_reset(Nob_Cmd *cmd, Nob_Cmd_Redirect redirect);

#ifndef NOB_TEMP_CAPACITY
#define NOB_TEMP_CAPACITY (8*1024*1024)
#endif // NOB_TEMP_CAPACITY
NOBDEF char *nob_temp_strdup(const char *cstr);
NOBDEF void *nob_temp_alloc(size_t size);
NOBDEF char *nob_temp_sprintf(const char *format, ...) NOB_PRINTF_FORMAT(1, 2);
// nob_temp_reset() - Resets the entire temporary storage to 0.
//
// It is generally not recommended to call this function ever. What you usually want to do is let's say you have a loop,
// that allocates some temporary objects and cleans them up at the end of each iteration. You should use
// nob_temp_save() and nob_temp_rewind() to organize such loop like this:
//
// ```c
// char *message = nob_temp_sprintf("This message is still valid after the loop below");
// while (!quit) {
//     size_t mark = nob_temp_save();
//     nob_temp_alloc(69);
//     nob_temp_alloc(420);
//     nob_temp_alloc(1337);
//     nob_temp_rewind(mark);
// }
// printf("%s\n", message);
// ```
//
// That way all the temporary allocations created before the loop are still valid even after the loop.
// Such save/rewind blocks define lifetime boundaries of the temporary objects which also could be nested.
// This turns the temporary storage into kind of a second stack with a more manual management.
NOBDEF void nob_temp_reset(void);
NOBDEF size_t nob_temp_save(void);
NOBDEF void nob_temp_rewind(size_t checkpoint);

// Given any path returns the last part of that path.
// "/path/to/a/file.c" -> "file.c"; "/path/to/a/directory" -> "directory"
NOBDEF const char *nob_path_name(const char *path);
NOBDEF bool nob_rename(const char *old_path, const char *new_path);
NOBDEF int nob_needs_rebuild(const char *output_path, const char **input_paths, size_t input_paths_count);
NOBDEF int nob_needs_rebuild1(const char *output_path, const char *input_path);
NOBDEF int nob_file_exists(const char *file_path);
NOBDEF const char *nob_get_current_dir_temp(void);
NOBDEF bool nob_set_current_dir(const char *path);

// TODO: we should probably document somewhere all the compiler we support

// The nob_cc_* macros try to abstract away the specific compiler.
// They are verify basic and not particularly flexible, but you can redefine them if you need to
// or not use them at all and create your own abstraction on top of Nob_Cmd.

#ifndef nob_cc
#  if _WIN32
#    if defined(__GNUC__)
#       define nob_cc(cmd) nob_cmd_append(cmd, "cc")
#    elif defined(__clang__)
#       define nob_cc(cmd) nob_cmd_append(cmd, "clang")
#    elif defined(_MSC_VER)
#       define nob_cc(cmd) nob_cmd_append(cmd, "cl.exe")
#    endif
#  else
#    define nob_cc(cmd) nob_cmd_append(cmd, "cc")
#  endif
#endif // nob_cc

#ifndef nob_cc_flags
#  if defined(_MSC_VER) && !defined(__clang__)
#    define nob_cc_flags(cmd) nob_cmd_append(cmd, "/W4", "/nologo", "/D_CRT_SECURE_NO_WARNINGS")
#  else
#    define nob_cc_flags(cmd) nob_cmd_append(cmd, "-Wall", "-Wextra")
#  endif
#endif // nob_cc_output

#ifndef nob_cc_output
#  if defined(_MSC_VER) && !defined(__clang__)
#    define nob_cc_output(cmd, output_path) nob_cmd_append(cmd, nob_temp_sprintf("/Fe:%s", (output_path)))
#  else
#    define nob_cc_output(cmd, output_path) nob_cmd_append(cmd, "-o", (output_path))
#  endif
#endif // nob_cc_output

#ifndef nob_cc_inputs
#  define nob_cc_inputs(cmd, ...) nob_cmd_append(cmd, __VA_ARGS__)
#endif // nob_cc_inputs

// TODO: add MinGW support for Go Rebuild Urself™ Technology and all the nob_cc_* macros above
//   Musializer contributors came up with a pretty interesting idea of an optional prefix macro which could be useful for
//   MinGW support:
//   https://github.com/tsoding/musializer/blob/b7578cc76b9ecb573d239acc9ccf5a04d3aba2c9/src_build/nob_win64_mingw.c#L3-L9
// TODO: Maybe instead NOB_REBUILD_URSELF macro, the Go Rebuild Urself™ Technology should use the
//   user defined nob_cc_* macros instead?
#ifndef NOB_REBUILD_URSELF
#  if defined(_WIN32)
#    if defined(__GNUC__)
#       define NOB_REBUILD_URSELF(binary_path, source_path) "gcc", "-o", binary_path, source_path
#    elif defined(__clang__)
#       define NOB_REBUILD_URSELF(binary_path, source_path) "clang", "-o", binary_path, source_path
#    elif defined(_MSC_VER)
#       define NOB_REBUILD_URSELF(binary_path, source_path) "cl.exe", nob_temp_sprintf("/Fe:%s", (binary_path)), source_path
#    endif
#  else
#    define NOB_REBUILD_URSELF(binary_path, source_path) "cc", "-o", binary_path, source_path
#  endif
#endif

// Go Rebuild Urself™ Technology
//
//   How to use it:
//     int main(int argc, char** argv) {
//         NOB_GO_REBUILD_URSELF(argc, argv);
//         // actual work
//         return 0;
//     }
//
//   After you added this macro every time you run ./nob it will detect
//   that you modified its original source code and will try to rebuild itself
//   before doing any actual work. So you only need to bootstrap your build system
//   once.
//
//   The modification is detected by comparing the last modified times of the executable
//   and its source code. The same way the make utility usually does it.
//
//   The rebuilding is done by using the NOB_REBUILD_URSELF macro which you can redefine
//   if you need a special way of bootstraping your build system. (which I personally
//   do not recommend since the whole idea of NoBuild is to keep the process of bootstrapping
//   as simple as possible and doing all of the actual work inside of ./nob)
//
NOBDEF void nob__go_rebuild_urself(int argc, char **argv, const char *source_path, ...);
#define NOB_GO_REBUILD_URSELF(argc, argv) nob__go_rebuild_urself(argc, argv, __FILE__, NULL)
// Sometimes your nob.c includes additional files, so you want the Go Rebuild Urself™ Technology to check
// if they also were modified and rebuild nob.c accordingly. For that we have NOB_GO_REBUILD_URSELF_PLUS():
// ```c
// #define NOB_IMPLEMENTATION
// #include "nob.h"
//
// #include "foo.c"
// #include "bar.c"
//
// int main(int argc, char **argv)
// {
//     NOB_GO_REBUILD_URSELF_PLUS(argc, argv, "foo.c", "bar.c");
//     // ...
//     return 0;
// }
#define NOB_GO_REBUILD_URSELF_PLUS(argc, argv, ...) nob__go_rebuild_urself(argc, argv, __FILE__, __VA_ARGS__, NULL);

typedef struct {
    size_t count;
    const char *data;
} Nob_String_View;

NOBDEF const char *nob_temp_sv_to_cstr(Nob_String_View sv);

NOBDEF Nob_String_View nob_sv_chop_by_delim(Nob_String_View *sv, char delim);
NOBDEF Nob_String_View nob_sv_chop_left(Nob_String_View *sv, size_t n);
NOBDEF Nob_String_View nob_sv_trim(Nob_String_View sv);
NOBDEF Nob_String_View nob_sv_trim_left(Nob_String_View sv);
NOBDEF Nob_String_View nob_sv_trim_right(Nob_String_View sv);
NOBDEF bool nob_sv_eq(Nob_String_View a, Nob_String_View b);
NOBDEF bool nob_sv_end_with(Nob_String_View sv, const char *cstr);
NOBDEF bool nob_sv_starts_with(Nob_String_View sv, Nob_String_View expected_prefix);
NOBDEF Nob_String_View nob_sv_from_cstr(const char *cstr);
NOBDEF Nob_String_View nob_sv_from_parts(const char *data, size_t count);
// nob_sb_to_sv() enables you to just view Nob_String_Builder as Nob_String_View
#define nob_sb_to_sv(sb) nob_sv_from_parts((sb).items, (sb).count)

// printf macros for String_View
#ifndef SV_Fmt
#define SV_Fmt "%.*s"
#endif // SV_Fmt
#ifndef SV_Arg
#define SV_Arg(sv) (int) (sv).count, (sv).data
#endif // SV_Arg
// USAGE:
//   String_View name = ...;
//   printf("Name: "SV_Fmt"\n", SV_Arg(name));

// DEPRECATED: Usage of the bundled minirent.h below is deprecated, because it introduces more
// problems than it solves. It will be removed in the next major release of nob.h. In the meantime,
// it is recommended to `#define NOB_NO_MINIRENT` if it causes problems for you.
// TODO: Use NOB_DEPRECATED for minirent.h declarations

// minirent.h HEADER BEGIN ////////////////////////////////////////
// Copyright 2021 Alexey Kutepov <reximkut@gmail.com>
//
// Permission is hereby granted, free of charge, to any person obtaining
// a copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to
// permit persons to whom the Software is furnished to do so, subject to
// the following conditions:
//
// The above copyright notice and this permission notice shall be
// included in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
//
// ============================================================
//
// minirent — 0.0.1 — A subset of dirent interface for Windows.
//
// https://github.com/tsoding/minirent
//
// ============================================================
//
// ChangeLog (https://semver.org/ is implied)
//
//    0.0.2 Automatically include dirent.h on non-Windows
//          platforms
//    0.0.1 First Official Release

#if !defined(_WIN32) || defined(NOB_NO_MINIRENT)
#include <dirent.h>
#else // _WIN32

#define WIN32_LEAN_AND_MEAN
#include "windows.h"

struct dirent
{
    char d_name[MAX_PATH+1];
};

typedef struct DIR DIR;

static DIR *opendir(const char *dirpath);
static struct dirent *readdir(DIR *dirp);
static int closedir(DIR *dirp);

#endif // _WIN32
// minirent.h HEADER END ////////////////////////////////////////

#ifdef _WIN32

NOBDEF char *nob_win32_error_message(DWORD err);

#endif // _WIN32

#endif // NOB_H_

#ifdef NOB_IMPLEMENTATION

// This is like nob_proc_wait() but waits asynchronously. Depending on the platform ms means different thing.
// On Windows it means timeout. On POSIX it means for how long to sleep after checking if the process exited,
// so to not peg the core too much. Since this API is kinda of weird, the function is private for now.
static int nob__proc_wait_async(Nob_Proc proc, int ms);

// Starts the process for the command. Its main purpose is to be the base for nob_cmd_run() and nob_cmd_run_opt().
static Nob_Proc nob__cmd_start_process(Nob_Cmd cmd, Nob_Fd *fdin, Nob_Fd *fdout, Nob_Fd *fderr);

// Any messages with the level below nob_minimal_log_level are going to be suppressed.
Nob_Log_Level nob_minimal_log_level = NOB_INFO;

#ifdef _WIN32

// Base on https://stackoverflow.com/a/75644008
// > .NET Core uses 4096 * sizeof(WCHAR) buffer on stack for FormatMessageW call. And...thats it.
// >
// > https://github.com/dotnet/runtime/blob/3b63eb1346f1ddbc921374a5108d025662fb5ffd/src/coreclr/utilcode/posterror.cpp#L264-L265
#ifndef NOB_WIN32_ERR_MSG_SIZE
#define NOB_WIN32_ERR_MSG_SIZE (4 * 1024)
#endif // NOB_WIN32_ERR_MSG_SIZE

NOBDEF char *nob_win32_error_message(DWORD err) {
    static char win32ErrMsg[NOB_WIN32_ERR_MSG_SIZE] = {0};
    DWORD errMsgSize = FormatMessageA(FORMAT_MESSAGE_FROM_SYSTEM | FORMAT_MESSAGE_IGNORE_INSERTS, NULL, err, LANG_USER_DEFAULT, win32ErrMsg,
                                      NOB_WIN32_ERR_MSG_SIZE, NULL);

    if (errMsgSize == 0) {
        if (GetLastError() != ERROR_MR_MID_NOT_FOUND) {
            if (sprintf(win32ErrMsg, "Could not get error message for 0x%lX", err) > 0) {
                return (char *)&win32ErrMsg;
            } else {
                return NULL;
            }
        } else {
            if (sprintf(win32ErrMsg, "Invalid Windows Error code (0x%lX)", err) > 0) {
                return (char *)&win32ErrMsg;
            } else {
                return NULL;
            }
        }
    }

    while (errMsgSize > 1 && isspace(win32ErrMsg[errMsgSize - 1])) {
        win32ErrMsg[--errMsgSize] = '\0';
    }

    return win32ErrMsg;
}

#endif // _WIN32

// The implementation idea is stolen from https://github.com/zhiayang/nabs
NOBDEF void nob__go_rebuild_urself(int argc, char **argv, const char *source_path, ...)
{
    const char *binary_path = nob_shift(argv, argc);
#ifdef _WIN32
    // On Windows executables almost always invoked without extension, so
    // it's ./nob, not ./nob.exe. For renaming the extension is a must.
    if (!nob_sv_end_with(nob_sv_from_cstr(binary_path), ".exe")) {
        binary_path = nob_temp_sprintf("%s.exe", binary_path);
    }
#endif

    Nob_File_Paths source_paths = {0};
    nob_da_append(&source_paths, source_path);
    va_list args;
    va_start(args, source_path);
    for (;;) {
        const char *path = va_arg(args, const char*);
        if (path == NULL) break;
        nob_da_append(&source_paths, path);
    }
    va_end(args);

    int rebuild_is_needed = nob_needs_rebuild(binary_path, source_paths.items, source_paths.count);
    if (rebuild_is_needed < 0) exit(1); // error
    if (!rebuild_is_needed) {           // no rebuild is needed
        NOB_FREE(source_paths.items);
        return;
    }

    Nob_Cmd cmd = {0};

    const char *old_binary_path = nob_temp_sprintf("%s.old", binary_path);

    if (!nob_rename(binary_path, old_binary_path)) exit(1);
    nob_cmd_append(&cmd, NOB_REBUILD_URSELF(binary_path, source_path));
    Nob_Cmd_Opt opt = {0};
    if (!nob_cmd_run_opt(&cmd, opt)) {
        nob_rename(old_binary_path, binary_path);
        exit(1);
    }
#ifdef NOB_EXPERIMENTAL_DELETE_OLD
    // TODO: this is an experimental behavior behind a compilation flag.
    // Once it is confirmed that it does not cause much problems on both POSIX and Windows
    // we may turn it on by default.
    nob_delete_file(old_binary_path);
#endif // NOB_EXPERIMENTAL_DELETE_OLD

    nob_cmd_append(&cmd, binary_path);
    nob_da_append_many(&cmd, argv, argc);
    if (!nob_cmd_run_opt(&cmd, opt)) exit(1);
    exit(0);
}

static size_t nob_temp_size = 0;
static char nob_temp[NOB_TEMP_CAPACITY] = {0};

NOBDEF bool nob_mkdir_if_not_exists(const char *path)
{
#ifdef _WIN32
    int result = _mkdir(path);
#else
    int result = mkdir(path, 0755);
#endif
    if (result < 0) {
        if (errno == EEXIST) {
            nob_log(NOB_INFO, "directory `%s` already exists", path);
            return true;
        }
        nob_log(NOB_ERROR, "could not create directory `%s`: %s", path, strerror(errno));
        return false;
    }

    nob_log(NOB_INFO, "created directory `%s`", path);
    return true;
}

NOBDEF bool nob_copy_file(const char *src_path, const char *dst_path)
{
    nob_log(NOB_INFO, "copying %s -> %s", src_path, dst_path);
#ifdef _WIN32
    if (!CopyFile(src_path, dst_path, FALSE)) {
        nob_log(NOB_ERROR, "Could not copy file: %s", nob_win32_error_message(GetLastError()));
        return false;
    }
    return true;
#else
    int src_fd = -1;
    int dst_fd = -1;
    size_t buf_size = 32*1024;
    char *buf = (char*)NOB_REALLOC(NULL, buf_size);
    NOB_ASSERT(buf != NULL && "Buy more RAM lol!!");
    bool result = true;

    src_fd = open(src_path, O_RDONLY);
    if (src_fd < 0) {
        nob_log(NOB_ERROR, "Could not open file %s: %s", src_path, strerror(errno));
        nob_return_defer(false);
    }

    struct stat src_stat;
    if (fstat(src_fd, &src_stat) < 0) {
        nob_log(NOB_ERROR, "Could not get mode of file %s: %s", src_path, strerror(errno));
        nob_return_defer(false);
    }

    dst_fd = open(dst_path, O_CREAT | O_TRUNC | O_WRONLY, src_stat.st_mode);
    if (dst_fd < 0) {
        nob_log(NOB_ERROR, "Could not create file %s: %s", dst_path, strerror(errno));
        nob_return_defer(false);
    }

    for (;;) {
        ssize_t n = read(src_fd, buf, buf_size);
        if (n == 0) break;
        if (n < 0) {
            nob_log(NOB_ERROR, "Could not read from file %s: %s", src_path, strerror(errno));
            nob_return_defer(false);
        }
        char *buf2 = buf;
        while (n > 0) {
            ssize_t m = write(dst_fd, buf2, n);
            if (m < 0) {
                nob_log(NOB_ERROR, "Could not write to file %s: %s", dst_path, strerror(errno));
                nob_return_defer(false);
            }
            n    -= m;
            buf2 += m;
        }
    }

defer:
    NOB_FREE(buf);
    close(src_fd);
    close(dst_fd);
    return result;
#endif
}

NOBDEF void nob_cmd_render(Nob_Cmd cmd, Nob_String_Builder *render)
{
    for (size_t i = 0; i < cmd.count; ++i) {
        const char *arg = cmd.items[i];
        if (arg == NULL) break;
        if (i > 0) nob_sb_append_cstr(render, " ");
        if (!strchr(arg, ' ')) {
            nob_sb_append_cstr(render, arg);
        } else {
            nob_da_append(render, '\'');
            nob_sb_append_cstr(render, arg);
            nob_da_append(render, '\'');
        }
    }
}

#ifdef _WIN32
// https://learn.microsoft.com/en-gb/archive/blogs/twistylittlepassagesallalike/everyone-quotes-command-line-arguments-the-wrong-way
static void nob__win32_cmd_quote(Nob_Cmd cmd, Nob_String_Builder *quoted)
{
    for (size_t i = 0; i < cmd.count; ++i) {
        const char *arg = cmd.items[i];
        if (arg == NULL) break;
        size_t len = strlen(arg);
        if (i > 0) nob_da_append(quoted, ' ');
        if (len != 0 && NULL == strpbrk(arg, " \t\n\v\"")) {
            // no need to quote
            nob_da_append_many(quoted, arg, len);
        } else {
            // we need to escape:
            // 1. double quotes in the original arg
            // 2. consequent backslashes before a double quote
            size_t backslashes = 0;
            nob_da_append(quoted, '\"');
            for (size_t j = 0; j < len; ++j) {
                char x = arg[j];
                if (x == '\\') {
                    backslashes += 1;
                } else {
                    if (x == '\"') {
                        // escape backslashes (if any) and the double quote
                        for (size_t k = 0; k < 1+backslashes; ++k) {
                            nob_da_append(quoted, '\\');
                        }
                    }
                    backslashes = 0;
                }
                nob_da_append(quoted, x);
            }
            // escape backslashes (if any)
            for (size_t k = 0; k < backslashes; ++k) {
                nob_da_append(quoted, '\\');
            }
            nob_da_append(quoted, '\"');
        }
    }
}
#endif

NOBDEF int nob_nprocs(void)
{
#ifdef _WIN32
    SYSTEM_INFO siSysInfo;
    GetSystemInfo(&siSysInfo);
    return siSysInfo.dwNumberOfProcessors;
#else
    return sysconf(_SC_NPROCESSORS_ONLN);
#endif
}

NOBDEF bool nob_cmd_run_opt(Nob_Cmd *cmd, Nob_Cmd_Opt opt)
{
    bool result = true;
    Nob_Fd fdin  = NOB_INVALID_FD;
    Nob_Fd fdout = NOB_INVALID_FD;
    Nob_Fd fderr = NOB_INVALID_FD;
    Nob_Fd *opt_fdin  = NULL;
    Nob_Fd *opt_fdout = NULL;
    Nob_Fd *opt_fderr = NULL;

    size_t max_procs = opt.max_procs > 0 ? opt.max_procs : (size_t) nob_nprocs() + 1;

    if (opt.async && max_procs > 0) {
        while (opt.async->count >= max_procs) {
            for (size_t i = 0; i < opt.async->count; ++i) {
                int ret = nob__proc_wait_async(opt.async->items[i], 1);
                if (ret < 0) nob_return_defer(false);
                if (ret) {
                    nob_da_remove_unordered(opt.async, i);
                    break;
                }
            }
        }
    }

    if (opt.stdin_path) {
        fdin = nob_fd_open_for_read(opt.stdin_path);
        if (fdin == NOB_INVALID_FD) nob_return_defer(false);
        opt_fdin = &fdin;
    }
    if (opt.stdout_path) {
        fdout = nob_fd_open_for_write(opt.stdout_path);
        if (fdout == NOB_INVALID_FD) nob_return_defer(false);
        opt_fdout = &fdout;
    }
    if (opt.stderr_path) {
        fderr = nob_fd_open_for_write(opt.stderr_path);
        if (fderr == NOB_INVALID_FD) nob_return_defer(false);
        opt_fderr = &fderr;
    }
    Nob_Proc proc = nob__cmd_start_process(*cmd, opt_fdin, opt_fdout, opt_fderr);

    if (opt.async) {
        if (proc == NOB_INVALID_PROC) nob_return_defer(false);
        nob_da_append(opt.async, proc);
    } else {
        if (!nob_proc_wait(proc)) nob_return_defer(false);
    }

defer:
    if (opt_fdin)  nob_fd_close(*opt_fdin);
    if (opt_fdout) nob_fd_close(*opt_fdout);
    if (opt_fderr) nob_fd_close(*opt_fderr);
    cmd->count = 0;
    return result;
}

// The maximum time span representable is 584 years.
NOBDEF uint64_t nob_nanos_since_unspecified_epoch(void)
{
#ifdef _WIN32
    LARGE_INTEGER Time;
    QueryPerformanceCounter(&Time);

    static LARGE_INTEGER Frequency = {0};
    if (Frequency.QuadPart == 0) {
        QueryPerformanceFrequency(&Frequency);
    }

    uint64_t Secs  = Time.QuadPart / Frequency.QuadPart;
    uint64_t Nanos = Time.QuadPart % Frequency.QuadPart * NOB_NANOS_PER_SEC / Frequency.QuadPart;
    return NOB_NANOS_PER_SEC * Secs + Nanos;
#else
    struct timespec ts;
    clock_gettime(CLOCK_MONOTONIC, &ts);

    return NOB_NANOS_PER_SEC * ts.tv_sec + ts.tv_nsec;
#endif // _WIN32
}

NOBDEF Nob_Proc nob_cmd_run_async_redirect(Nob_Cmd cmd, Nob_Cmd_Redirect redirect)
{
    return nob__cmd_start_process(cmd, redirect.fdin, redirect.fdout, redirect.fderr);
}

static Nob_Proc nob__cmd_start_process(Nob_Cmd cmd, Nob_Fd *fdin, Nob_Fd *fdout, Nob_Fd *fderr)
{
    if (cmd.count < 1) {
        nob_log(NOB_ERROR, "Could not run empty command");
        return NOB_INVALID_PROC;
    }

    Nob_String_Builder sb = {0};
    nob_cmd_render(cmd, &sb);
    nob_sb_append_null(&sb);
    nob_log(NOB_INFO, "CMD: %s", sb.items);
    nob_sb_free(sb);
    memset(&sb, 0, sizeof(sb));

#ifdef _WIN32
    // https://docs.microsoft.com/en-us/windows/win32/procthread/creating-a-child-process-with-redirected-input-and-output

    STARTUPINFO siStartInfo;
    ZeroMemory(&siStartInfo, sizeof(siStartInfo));
    siStartInfo.cb = sizeof(STARTUPINFO);
    // NOTE: theoretically setting NULL to std handles should not be a problem
    // https://docs.microsoft.com/en-us/windows/console/getstdhandle?redirectedfrom=MSDN#attachdetach-behavior
    // TODO: check for errors in GetStdHandle
    siStartInfo.hStdError = fderr ? *fderr : GetStdHandle(STD_ERROR_HANDLE);
    siStartInfo.hStdOutput = fdout ? *fdout : GetStdHandle(STD_OUTPUT_HANDLE);
    siStartInfo.hStdInput = fdin ? *fdin : GetStdHandle(STD_INPUT_HANDLE);
    siStartInfo.dwFlags |= STARTF_USESTDHANDLES;

    PROCESS_INFORMATION piProcInfo;
    ZeroMemory(&piProcInfo, sizeof(PROCESS_INFORMATION));

    nob__win32_cmd_quote(cmd, &sb);
    nob_sb_append_null(&sb);
    BOOL bSuccess = CreateProcessA(NULL, sb.items, NULL, NULL, TRUE, 0, NULL, NULL, &siStartInfo, &piProcInfo);
    nob_sb_free(sb);

    if (!bSuccess) {
        nob_log(NOB_ERROR, "Could not create child process for %s: %s", cmd.items[0], nob_win32_error_message(GetLastError()));
        return NOB_INVALID_PROC;
    }

    CloseHandle(piProcInfo.hThread);

    return piProcInfo.hProcess;
#else
    pid_t cpid = fork();
    if (cpid < 0) {
        nob_log(NOB_ERROR, "Could not fork child process: %s", strerror(errno));
        return NOB_INVALID_PROC;
    }

    if (cpid == 0) {
        if (fdin) {
            if (dup2(*fdin, STDIN_FILENO) < 0) {
                nob_log(NOB_ERROR, "Could not setup stdin for child process: %s", strerror(errno));
                exit(1);
            }
        }

        if (fdout) {
            if (dup2(*fdout, STDOUT_FILENO) < 0) {
                nob_log(NOB_ERROR, "Could not setup stdout for child process: %s", strerror(errno));
                exit(1);
            }
        }

        if (fderr) {
            if (dup2(*fderr, STDERR_FILENO) < 0) {
                nob_log(NOB_ERROR, "Could not setup stderr for child process: %s", strerror(errno));
                exit(1);
            }
        }

        // NOTE: This leaks a bit of memory in the child process.
        // But do we actually care? It's a one off leak anyway...
        Nob_Cmd cmd_null = {0};
        nob_da_append_many(&cmd_null, cmd.items, cmd.count);
        nob_cmd_append(&cmd_null, NULL);

        if (execvp(cmd.items[0], (char * const*) cmd_null.items) < 0) {
            nob_log(NOB_ERROR, "Could not exec child process for %s: %s", cmd.items[0], strerror(errno));
            exit(1);
        }
        NOB_UNREACHABLE("nob_cmd_run_async_redirect");
    }

    return cpid;
#endif
}

NOBDEF Nob_Proc nob_cmd_run_async(Nob_Cmd cmd)
{
    return nob__cmd_start_process(cmd, NULL, NULL, NULL);
}

NOBDEF Nob_Proc nob_cmd_run_async_and_reset(Nob_Cmd *cmd)
{
    Nob_Proc proc = nob__cmd_start_process(*cmd, NULL, NULL, NULL);
    cmd->count = 0;
    return proc;
}

NOBDEF Nob_Proc nob_cmd_run_async_redirect_and_reset(Nob_Cmd *cmd, Nob_Cmd_Redirect redirect)
{
    Nob_Proc proc = nob__cmd_start_process(*cmd, redirect.fdin, redirect.fdout, redirect.fderr);
    cmd->count = 0;
    if (redirect.fdin) {
        nob_fd_close(*redirect.fdin);
        *redirect.fdin = NOB_INVALID_FD;
    }
    if (redirect.fdout) {
        nob_fd_close(*redirect.fdout);
        *redirect.fdout = NOB_INVALID_FD;
    }
    if (redirect.fderr) {
        nob_fd_close(*redirect.fderr);
        *redirect.fderr = NOB_INVALID_FD;
    }
    return proc;
}

NOBDEF Nob_Fd nob_fd_open_for_read(const char *path)
{
#ifndef _WIN32
    Nob_Fd result = open(path, O_RDONLY);
    if (result < 0) {
        nob_log(NOB_ERROR, "Could not open file %s: %s", path, strerror(errno));
        return NOB_INVALID_FD;
    }
    return result;
#else
    // https://docs.microsoft.com/en-us/windows/win32/fileio/opening-a-file-for-reading-or-writing
    SECURITY_ATTRIBUTES saAttr = {0};
    saAttr.nLength = sizeof(SECURITY_ATTRIBUTES);
    saAttr.bInheritHandle = TRUE;

    Nob_Fd result = CreateFile(
                    path,
                    GENERIC_READ,
                    0,
                    &saAttr,
                    OPEN_EXISTING,
                    FILE_ATTRIBUTE_READONLY,
                    NULL);

    if (result == INVALID_HANDLE_VALUE) {
        nob_log(NOB_ERROR, "Could not open file %s: %s", path, nob_win32_error_message(GetLastError()));
        return NOB_INVALID_FD;
    }

    return result;
#endif // _WIN32
}

NOBDEF Nob_Fd nob_fd_open_for_write(const char *path)
{
#ifndef _WIN32
    Nob_Fd result = open(path,
                     O_WRONLY | O_CREAT | O_TRUNC,
                     S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH);
    if (result < 0) {
        nob_log(NOB_ERROR, "could not open file %s: %s", path, strerror(errno));
        return NOB_INVALID_FD;
    }
    return result;
#else
    SECURITY_ATTRIBUTES saAttr = {0};
    saAttr.nLength = sizeof(SECURITY_ATTRIBUTES);
    saAttr.bInheritHandle = TRUE;

    Nob_Fd result = CreateFile(
                    path,                            // name of the write
                    GENERIC_WRITE,                   // open for writing
                    0,                               // do not share
                    &saAttr,                         // default security
                    CREATE_ALWAYS,                   // create always
                    FILE_ATTRIBUTE_NORMAL,           // normal file
                    NULL                             // no attr. template
                );

    if (result == INVALID_HANDLE_VALUE) {
        nob_log(NOB_ERROR, "Could not open file %s: %s", path, nob_win32_error_message(GetLastError()));
        return NOB_INVALID_FD;
    }

    return result;
#endif // _WIN32
}

NOBDEF void nob_fd_close(Nob_Fd fd)
{
#ifdef _WIN32
    CloseHandle(fd);
#else
    close(fd);
#endif // _WIN32
}

NOBDEF bool nob_procs_wait(Nob_Procs procs)
{
    bool success = true;
    for (size_t i = 0; i < procs.count; ++i) {
        success = nob_proc_wait(procs.items[i]) && success;
    }
    return success;
}

NOBDEF bool nob_procs_flush(Nob_Procs *procs)
{
    bool success = nob_procs_wait(*procs);
    procs->count = 0;
    return success;
}

NOBDEF bool nob_procs_wait_and_reset(Nob_Procs *procs)
{
    return nob_procs_flush(procs);
}

NOBDEF bool nob_proc_wait(Nob_Proc proc)
{
    if (proc == NOB_INVALID_PROC) return false;

#ifdef _WIN32
    DWORD result = WaitForSingleObject(
                       proc,    // HANDLE hHandle,
                       INFINITE // DWORD  dwMilliseconds
                   );

    if (result == WAIT_FAILED) {
        nob_log(NOB_ERROR, "could not wait on child process: %s", nob_win32_error_message(GetLastError()));
        return false;
    }

    DWORD exit_status;
    if (!GetExitCodeProcess(proc, &exit_status)) {
        nob_log(NOB_ERROR, "could not get process exit code: %s", nob_win32_error_message(GetLastError()));
        return false;
    }

    if (exit_status != 0) {
        nob_log(NOB_ERROR, "command exited with exit code %lu", exit_status);
        return false;
    }

    CloseHandle(proc);

    return true;
#else
    for (;;) {
        int wstatus = 0;
        if (waitpid(proc, &wstatus, 0) < 0) {
            nob_log(NOB_ERROR, "could not wait on command (pid %d): %s", proc, strerror(errno));
            return false;
        }

        if (WIFEXITED(wstatus)) {
            int exit_status = WEXITSTATUS(wstatus);
            if (exit_status != 0) {
                nob_log(NOB_ERROR, "command exited with exit code %d", exit_status);
                return false;
            }

            break;
        }

        if (WIFSIGNALED(wstatus)) {
            nob_log(NOB_ERROR, "command process was terminated by signal %d", WTERMSIG(wstatus));
            return false;
        }
    }

    return true;
#endif
}

static int nob__proc_wait_async(Nob_Proc proc, int ms)
{
    if (proc == NOB_INVALID_PROC) return false;

#ifdef _WIN32
    DWORD result = WaitForSingleObject(
                       proc,    // HANDLE hHandle,
                       ms       // DWORD  dwMilliseconds
                   );

    if (result == WAIT_TIMEOUT) {
        return 0;
    }

    if (result == WAIT_FAILED) {
        nob_log(NOB_ERROR, "could not wait on child process: %s", nob_win32_error_message(GetLastError()));
        return -1;
    }

    DWORD exit_status;
    if (!GetExitCodeProcess(proc, &exit_status)) {
        nob_log(NOB_ERROR, "could not get process exit code: %s", nob_win32_error_message(GetLastError()));
        return -1;
    }

    if (exit_status != 0) {
        nob_log(NOB_ERROR, "command exited with exit code %lu", exit_status);
        return -1;
    }

    CloseHandle(proc);

    return 1;
#else
    long ns = ms*1000*1000;
    struct timespec duration = {
        .tv_sec = ns/(1000*1000*1000),
        .tv_nsec = ns%(1000*1000*1000),
    };

    int wstatus = 0;
    pid_t pid = waitpid(proc, &wstatus, WNOHANG);
    if (pid < 0) {
        nob_log(NOB_ERROR, "could not wait on command (pid %d): %s", proc, strerror(errno));
        return -1;
    }

    if (pid == 0) {
        nanosleep(&duration, NULL);
        return 0;
    }

    if (WIFEXITED(wstatus)) {
        int exit_status = WEXITSTATUS(wstatus);
        if (exit_status != 0) {
            nob_log(NOB_ERROR, "command exited with exit code %d", exit_status);
            return -1;
        }

        return 1;
    }

    if (WIFSIGNALED(wstatus)) {
        nob_log(NOB_ERROR, "command process was terminated by signal %d", WTERMSIG(wstatus));
        return -1;
    }

    nanosleep(&duration, NULL);
    return 0;
#endif
}

NOBDEF bool nob_procs_append_with_flush(Nob_Procs *procs, Nob_Proc proc, size_t max_procs_count)
{
    nob_da_append(procs, proc);

    if (procs->count >= max_procs_count) {
        if (!nob_procs_flush(procs)) return false;
    }

    return true;
}

NOBDEF bool nob_cmd_run_sync_redirect(Nob_Cmd cmd, Nob_Cmd_Redirect redirect)
{
    Nob_Proc p = nob__cmd_start_process(cmd, redirect.fdin, redirect.fdout, redirect.fderr);
    return nob_proc_wait(p);
}

NOBDEF bool nob_cmd_run_sync(Nob_Cmd cmd)
{
    Nob_Proc p = nob__cmd_start_process(cmd, NULL, NULL, NULL);
    return nob_proc_wait(p);
}

NOBDEF bool nob_cmd_run_sync_and_reset(Nob_Cmd *cmd)
{
    Nob_Proc p = nob__cmd_start_process(*cmd, NULL, NULL, NULL);
    cmd->count = 0;
    return nob_proc_wait(p);
}

NOBDEF bool nob_cmd_run_sync_redirect_and_reset(Nob_Cmd *cmd, Nob_Cmd_Redirect redirect)
{
    Nob_Proc p = nob__cmd_start_process(*cmd, redirect.fdin, redirect.fdout, redirect.fderr);
    cmd->count = 0;
    if (redirect.fdin) {
        nob_fd_close(*redirect.fdin);
        *redirect.fdin = NOB_INVALID_FD;
    }
    if (redirect.fdout) {
        nob_fd_close(*redirect.fdout);
        *redirect.fdout = NOB_INVALID_FD;
    }
    if (redirect.fderr) {
        nob_fd_close(*redirect.fderr);
        *redirect.fderr = NOB_INVALID_FD;
    }
    return nob_proc_wait(p);
}

NOBDEF void nob_log(Nob_Log_Level level, const char *fmt, ...)
{
    if (level < nob_minimal_log_level) return;

    switch (level) {
    case NOB_INFO:
        fprintf(stderr, "[INFO] ");
        break;
    case NOB_WARNING:
        fprintf(stderr, "[WARNING] ");
        break;
    case NOB_ERROR:
        fprintf(stderr, "[ERROR] ");
        break;
    case NOB_NO_LOGS: return;
    default:
        NOB_UNREACHABLE("nob_log");
    }

    va_list args;
    va_start(args, fmt);
    vfprintf(stderr, fmt, args);
    va_end(args);
    fprintf(stderr, "\n");
}

NOBDEF bool nob_read_entire_dir(const char *parent, Nob_File_Paths *children)
{
    bool result = true;
    DIR *dir = NULL;
    struct dirent *ent = NULL;

    dir = opendir(parent);
    if (dir == NULL) {
        #ifdef _WIN32
        nob_log(NOB_ERROR, "Could not open directory %s: %s", parent, nob_win32_error_message(GetLastError()));
        #else
        nob_log(NOB_ERROR, "Could not open directory %s: %s", parent, strerror(errno));
        #endif // _WIN32
        nob_return_defer(false);
    }

    errno = 0;
    ent = readdir(dir);
    while (ent != NULL) {
        nob_da_append(children, nob_temp_strdup(ent->d_name));
        ent = readdir(dir);
    }

    if (errno != 0) {
        #ifdef _WIN32
        nob_log(NOB_ERROR, "Could not read directory %s: %s", parent, nob_win32_error_message(GetLastError()));
        #else
        nob_log(NOB_ERROR, "Could not read directory %s: %s", parent, strerror(errno));
        #endif // _WIN32
        nob_return_defer(false);
    }

defer:
    if (dir) closedir(dir);
    return result;
}

NOBDEF bool nob_write_entire_file(const char *path, const void *data, size_t size)
{
    bool result = true;

    const char *buf = NULL;
    FILE *f = fopen(path, "wb");
    if (f == NULL) {
        nob_log(NOB_ERROR, "Could not open file %s for writing: %s\n", path, strerror(errno));
        nob_return_defer(false);
    }

    //           len
    //           v
    // aaaaaaaaaa
    //     ^
    //     data

    buf = (const char*)data;
    while (size > 0) {
        size_t n = fwrite(buf, 1, size, f);
        if (ferror(f)) {
            nob_log(NOB_ERROR, "Could not write into file %s: %s\n", path, strerror(errno));
            nob_return_defer(false);
        }
        size -= n;
        buf  += n;
    }

defer:
    if (f) fclose(f);
    return result;
}

NOBDEF Nob_File_Type nob_get_file_type(const char *path)
{
#ifdef _WIN32
    DWORD attr = GetFileAttributesA(path);
    if (attr == INVALID_FILE_ATTRIBUTES) {
        nob_log(NOB_ERROR, "Could not get file attributes of %s: %s", path, nob_win32_error_message(GetLastError()));
        return -1;
    }

    if (attr & FILE_ATTRIBUTE_DIRECTORY) return NOB_FILE_DIRECTORY;
    // TODO: detect symlinks on Windows (whatever that means on Windows anyway)
    return NOB_FILE_REGULAR;
#else // _WIN32
    struct stat statbuf;
    if (lstat(path, &statbuf) < 0) {
        nob_log(NOB_ERROR, "Could not get stat of %s: %s", path, strerror(errno));
        return (Nob_File_Type)(-1);
    }

    if (S_ISREG(statbuf.st_mode)) return NOB_FILE_REGULAR;
    if (S_ISDIR(statbuf.st_mode)) return NOB_FILE_DIRECTORY;
    if (S_ISLNK(statbuf.st_mode)) return NOB_FILE_SYMLINK;
    return NOB_FILE_OTHER;
#endif // _WIN32
}

NOBDEF bool nob_delete_file(const char *path)
{
    nob_log(NOB_INFO, "deleting %s", path);
#ifdef _WIN32
    if (!DeleteFileA(path)) {
        nob_log(NOB_ERROR, "Could not delete file %s: %s", path, nob_win32_error_message(GetLastError()));
        return false;
    }
    return true;
#else
    if (remove(path) < 0) {
        nob_log(NOB_ERROR, "Could not delete file %s: %s", path, strerror(errno));
        return false;
    }
    return true;
#endif // _WIN32
}

NOBDEF bool nob_copy_directory_recursively(const char *src_path, const char *dst_path)
{
    bool result = true;
    Nob_File_Paths children = {0};
    Nob_String_Builder src_sb = {0};
    Nob_String_Builder dst_sb = {0};
    size_t temp_checkpoint = nob_temp_save();

    Nob_File_Type type = nob_get_file_type(src_path);
    if (type < 0) return false;

    switch (type) {
        case NOB_FILE_DIRECTORY: {
            if (!nob_mkdir_if_not_exists(dst_path)) nob_return_defer(false);
            if (!nob_read_entire_dir(src_path, &children)) nob_return_defer(false);

            for (size_t i = 0; i < children.count; ++i) {
                if (strcmp(children.items[i], ".") == 0) continue;
                if (strcmp(children.items[i], "..") == 0) continue;

                src_sb.count = 0;
                nob_sb_append_cstr(&src_sb, src_path);
                nob_sb_append_cstr(&src_sb, "/");
                nob_sb_append_cstr(&src_sb, children.items[i]);
                nob_sb_append_null(&src_sb);

                dst_sb.count = 0;
                nob_sb_append_cstr(&dst_sb, dst_path);
                nob_sb_append_cstr(&dst_sb, "/");
                nob_sb_append_cstr(&dst_sb, children.items[i]);
                nob_sb_append_null(&dst_sb);

                if (!nob_copy_directory_recursively(src_sb.items, dst_sb.items)) {
                    nob_return_defer(false);
                }
            }
        } break;

        case NOB_FILE_REGULAR: {
            if (!nob_copy_file(src_path, dst_path)) {
                nob_return_defer(false);
            }
        } break;

        case NOB_FILE_SYMLINK: {
            nob_log(NOB_WARNING, "TODO: Copying symlinks is not supported yet");
        } break;

        case NOB_FILE_OTHER: {
            nob_log(NOB_ERROR, "Unsupported type of file %s", src_path);
            nob_return_defer(false);
        } break;

        default: NOB_UNREACHABLE("nob_copy_directory_recursively");
    }

defer:
    nob_temp_rewind(temp_checkpoint);
    nob_da_free(src_sb);
    nob_da_free(dst_sb);
    nob_da_free(children);
    return result;
}

NOBDEF char *nob_temp_strdup(const char *cstr)
{
    size_t n = strlen(cstr);
    char *result = (char*)nob_temp_alloc(n + 1);
    NOB_ASSERT(result != NULL && "Increase NOB_TEMP_CAPACITY");
    memcpy(result, cstr, n);
    result[n] = '\0';
    return result;
}

NOBDEF void *nob_temp_alloc(size_t requested_size)
{
    size_t word_size = sizeof(uintptr_t);
    size_t size = (requested_size + word_size - 1)/word_size*word_size;
    if (nob_temp_size + size > NOB_TEMP_CAPACITY) return NULL;
    void *result = &nob_temp[nob_temp_size];
    nob_temp_size += size;
    return result;
}

NOBDEF char *nob_temp_sprintf(const char *format, ...)
{
    va_list args;
    va_start(args, format);
    int n = vsnprintf(NULL, 0, format, args);
    va_end(args);

    NOB_ASSERT(n >= 0);
    char *result = (char*)nob_temp_alloc(n + 1);
    NOB_ASSERT(result != NULL && "Extend the size of the temporary allocator");
    // TODO: use proper arenas for the temporary allocator;
    va_start(args, format);
    vsnprintf(result, n + 1, format, args);
    va_end(args);

    return result;
}

NOBDEF void nob_temp_reset(void)
{
    nob_temp_size = 0;
}

NOBDEF size_t nob_temp_save(void)
{
    return nob_temp_size;
}

NOBDEF void nob_temp_rewind(size_t checkpoint)
{
    nob_temp_size = checkpoint;
}

NOBDEF const char *nob_temp_sv_to_cstr(Nob_String_View sv)
{
    char *result = (char*)nob_temp_alloc(sv.count + 1);
    NOB_ASSERT(result != NULL && "Extend the size of the temporary allocator");
    memcpy(result, sv.data, sv.count);
    result[sv.count] = '\0';
    return result;
}

NOBDEF int nob_needs_rebuild(const char *output_path, const char **input_paths, size_t input_paths_count)
{
#ifdef _WIN32
    BOOL bSuccess;

    HANDLE output_path_fd = CreateFile(output_path, GENERIC_READ, 0, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_READONLY, NULL);
    if (output_path_fd == INVALID_HANDLE_VALUE) {
        // NOTE: if output does not exist it 100% must be rebuilt
        if (GetLastError() == ERROR_FILE_NOT_FOUND) return 1;
        nob_log(NOB_ERROR, "Could not open file %s: %s", output_path, nob_win32_error_message(GetLastError()));
        return -1;
    }
    FILETIME output_path_time;
    bSuccess = GetFileTime(output_path_fd, NULL, NULL, &output_path_time);
    CloseHandle(output_path_fd);
    if (!bSuccess) {
        nob_log(NOB_ERROR, "Could not get time of %s: %s", output_path, nob_win32_error_message(GetLastError()));
        return -1;
    }

    for (size_t i = 0; i < input_paths_count; ++i) {
        const char *input_path = input_paths[i];
        HANDLE input_path_fd = CreateFile(input_path, GENERIC_READ, 0, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_READONLY, NULL);
        if (input_path_fd == INVALID_HANDLE_VALUE) {
            // NOTE: non-existing input is an error cause it is needed for building in the first place
            nob_log(NOB_ERROR, "Could not open file %s: %s", input_path, nob_win32_error_message(GetLastError()));
            return -1;
        }
        FILETIME input_path_time;
        bSuccess = GetFileTime(input_path_fd, NULL, NULL, &input_path_time);
        CloseHandle(input_path_fd);
        if (!bSuccess) {
            nob_log(NOB_ERROR, "Could not get time of %s: %s", input_path, nob_win32_error_message(GetLastError()));
            return -1;
        }

        // NOTE: if even a single input_path is fresher than output_path that's 100% rebuild
        if (CompareFileTime(&input_path_time, &output_path_time) == 1) return 1;
    }

    return 0;
#else
    struct stat statbuf = {0};

    if (stat(output_path, &statbuf) < 0) {
        // NOTE: if output does not exist it 100% must be rebuilt
        if (errno == ENOENT) return 1;
        nob_log(NOB_ERROR, "could not stat %s: %s", output_path, strerror(errno));
        return -1;
    }
    int output_path_time = statbuf.st_mtime;

    for (size_t i = 0; i < input_paths_count; ++i) {
        const char *input_path = input_paths[i];
        if (stat(input_path, &statbuf) < 0) {
            // NOTE: non-existing input is an error cause it is needed for building in the first place
            nob_log(NOB_ERROR, "could not stat %s: %s", input_path, strerror(errno));
            return -1;
        }
        int input_path_time = statbuf.st_mtime;
        // NOTE: if even a single input_path is fresher than output_path that's 100% rebuild
        if (input_path_time > output_path_time) return 1;
    }

    return 0;
#endif
}

NOBDEF int nob_needs_rebuild1(const char *output_path, const char *input_path)
{
    return nob_needs_rebuild(output_path, &input_path, 1);
}

NOBDEF const char *nob_path_name(const char *path)
{
#ifdef _WIN32
    const char *p1 = strrchr(path, '/');
    const char *p2 = strrchr(path, '\\');
    const char *p = (p1 > p2)? p1 : p2;  // NULL is ignored if the other search is successful
    return p ? p + 1 : path;
#else
    const char *p = strrchr(path, '/');
    return p ? p + 1 : path;
#endif // _WIN32
}

NOBDEF bool nob_rename(const char *old_path, const char *new_path)
{
    nob_log(NOB_INFO, "renaming %s -> %s", old_path, new_path);
#ifdef _WIN32
    if (!MoveFileEx(old_path, new_path, MOVEFILE_REPLACE_EXISTING)) {
        nob_log(NOB_ERROR, "could not rename %s to %s: %s", old_path, new_path, nob_win32_error_message(GetLastError()));
        return false;
    }
#else
    if (rename(old_path, new_path) < 0) {
        nob_log(NOB_ERROR, "could not rename %s to %s: %s", old_path, new_path, strerror(errno));
        return false;
    }
#endif // _WIN32
    return true;
}

NOBDEF bool nob_read_entire_file(const char *path, Nob_String_Builder *sb)
{
    bool result = true;

    FILE *f = fopen(path, "rb");
    size_t new_count = 0;
    long long m = 0;
    if (f == NULL)                 nob_return_defer(false);
    if (fseek(f, 0, SEEK_END) < 0) nob_return_defer(false);
#ifndef _WIN32
    m = ftell(f);
#else
    m = _ftelli64(f);
#endif
    if (m < 0)                     nob_return_defer(false);
    if (fseek(f, 0, SEEK_SET) < 0) nob_return_defer(false);

    new_count = sb->count + m;
    if (new_count > sb->capacity) {
        sb->items = NOB_DECLTYPE_CAST(sb->items)NOB_REALLOC(sb->items, new_count);
        NOB_ASSERT(sb->items != NULL && "Buy more RAM lool!!");
        sb->capacity = new_count;
    }

    fread(sb->items + sb->count, m, 1, f);
    if (ferror(f)) {
        // TODO: Afaik, ferror does not set errno. So the error reporting in defer is not correct in this case.
        nob_return_defer(false);
    }
    sb->count = new_count;

defer:
    if (!result) nob_log(NOB_ERROR, "Could not read file %s: %s", path, strerror(errno));
    if (f) fclose(f);
    return result;
}

NOBDEF int nob_sb_appendf(Nob_String_Builder *sb, const char *fmt, ...)
{
    va_list args;

    va_start(args, fmt);
    int n = vsnprintf(NULL, 0, fmt, args);
    va_end(args);

    // NOTE: the new_capacity needs to be +1 because of the null terminator.
    // However, further below we increase sb->count by n, not n + 1.
    // This is because we don't want the sb to include the null terminator. The user can always sb_append_null() if they want it
    nob_da_reserve(sb, sb->count + n + 1);
    char *dest = sb->items + sb->count;
    va_start(args, fmt);
    vsnprintf(dest, n+1, fmt, args);
    va_end(args);

    sb->count += n;

    return n;
}

NOBDEF Nob_String_View nob_sv_chop_by_delim(Nob_String_View *sv, char delim)
{
    size_t i = 0;
    while (i < sv->count && sv->data[i] != delim) {
        i += 1;
    }

    Nob_String_View result = nob_sv_from_parts(sv->data, i);

    if (i < sv->count) {
        sv->count -= i + 1;
        sv->data  += i + 1;
    } else {
        sv->count -= i;
        sv->data  += i;
    }

    return result;
}

NOBDEF Nob_String_View nob_sv_chop_left(Nob_String_View *sv, size_t n)
{
    if (n > sv->count) {
        n = sv->count;
    }

    Nob_String_View result = nob_sv_from_parts(sv->data, n);

    sv->data  += n;
    sv->count -= n;

    return result;
}

NOBDEF Nob_String_View nob_sv_from_parts(const char *data, size_t count)
{
    Nob_String_View sv;
    sv.count = count;
    sv.data = data;
    return sv;
}

NOBDEF Nob_String_View nob_sv_trim_left(Nob_String_View sv)
{
    size_t i = 0;
    while (i < sv.count && isspace(sv.data[i])) {
        i += 1;
    }

    return nob_sv_from_parts(sv.data + i, sv.count - i);
}

NOBDEF Nob_String_View nob_sv_trim_right(Nob_String_View sv)
{
    size_t i = 0;
    while (i < sv.count && isspace(sv.data[sv.count - 1 - i])) {
        i += 1;
    }

    return nob_sv_from_parts(sv.data, sv.count - i);
}

NOBDEF Nob_String_View nob_sv_trim(Nob_String_View sv)
{
    return nob_sv_trim_right(nob_sv_trim_left(sv));
}

NOBDEF Nob_String_View nob_sv_from_cstr(const char *cstr)
{
    return nob_sv_from_parts(cstr, strlen(cstr));
}

NOBDEF bool nob_sv_eq(Nob_String_View a, Nob_String_View b)
{
    if (a.count != b.count) {
        return false;
    } else {
        return memcmp(a.data, b.data, a.count) == 0;
    }
}

NOBDEF bool nob_sv_end_with(Nob_String_View sv, const char *cstr)
{
    size_t cstr_count = strlen(cstr);
    if (sv.count >= cstr_count) {
        size_t ending_start = sv.count - cstr_count;
        Nob_String_View sv_ending = nob_sv_from_parts(sv.data + ending_start, cstr_count);
        return nob_sv_eq(sv_ending, nob_sv_from_cstr(cstr));
    }
    return false;
}


NOBDEF bool nob_sv_starts_with(Nob_String_View sv, Nob_String_View expected_prefix)
{
    if (expected_prefix.count <= sv.count) {
        Nob_String_View actual_prefix = nob_sv_from_parts(sv.data, expected_prefix.count);
        return nob_sv_eq(expected_prefix, actual_prefix);
    }

    return false;
}

// RETURNS:
//  0 - file does not exists
//  1 - file exists
// -1 - error while checking if file exists. The error is logged
NOBDEF int nob_file_exists(const char *file_path)
{
#if _WIN32
    // TODO: distinguish between "does not exists" and other errors
    DWORD dwAttrib = GetFileAttributesA(file_path);
    return dwAttrib != INVALID_FILE_ATTRIBUTES;
#else
    struct stat statbuf;
    if (stat(file_path, &statbuf) < 0) {
        if (errno == ENOENT) return 0;
        nob_log(NOB_ERROR, "Could not check if file %s exists: %s", file_path, strerror(errno));
        return -1;
    }
    return 1;
#endif
}

NOBDEF const char *nob_get_current_dir_temp(void)
{
#ifdef _WIN32
    DWORD nBufferLength = GetCurrentDirectory(0, NULL);
    if (nBufferLength == 0) {
        nob_log(NOB_ERROR, "could not get current directory: %s", nob_win32_error_message(GetLastError()));
        return NULL;
    }

    char *buffer = (char*) nob_temp_alloc(nBufferLength);
    if (GetCurrentDirectory(nBufferLength, buffer) == 0) {
        nob_log(NOB_ERROR, "could not get current directory: %s", nob_win32_error_message(GetLastError()));
        return NULL;
    }

    return buffer;
#else
    char *buffer = (char*) nob_temp_alloc(PATH_MAX);
    if (getcwd(buffer, PATH_MAX) == NULL) {
        nob_log(NOB_ERROR, "could not get current directory: %s", strerror(errno));
        return NULL;
    }

    return buffer;
#endif // _WIN32
}

NOBDEF bool nob_set_current_dir(const char *path)
{
#ifdef _WIN32
    if (!SetCurrentDirectory(path)) {
        nob_log(NOB_ERROR, "could not set current directory to %s: %s", path, nob_win32_error_message(GetLastError()));
        return false;
    }
    return true;
#else
    if (chdir(path) < 0) {
        nob_log(NOB_ERROR, "could not set current directory to %s: %s", path, strerror(errno));
        return false;
    }
    return true;
#endif // _WIN32
}

// minirent.h SOURCE BEGIN ////////////////////////////////////////
#if defined(_WIN32) && !defined(NOB_NO_MINIRENT)
struct DIR
{
    HANDLE hFind;
    WIN32_FIND_DATA data;
    struct dirent *dirent;
};

NOBDEF DIR *opendir(const char *dirpath)
{
    NOB_ASSERT(dirpath);

    char buffer[MAX_PATH];
    snprintf(buffer, MAX_PATH, "%s\\*", dirpath);

    DIR *dir = (DIR*)NOB_REALLOC(NULL, sizeof(DIR));
    memset(dir, 0, sizeof(DIR));

    dir->hFind = FindFirstFile(buffer, &dir->data);
    if (dir->hFind == INVALID_HANDLE_VALUE) {
        // TODO: opendir should set errno accordingly on FindFirstFile fail
        // https://docs.microsoft.com/en-us/windows/win32/api/errhandlingapi/nf-errhandlingapi-getlasterror
        errno = ENOSYS;
        goto fail;
    }

    return dir;

fail:
    if (dir) {
        NOB_FREE(dir);
    }

    return NULL;
}

NOBDEF struct dirent *readdir(DIR *dirp)
{
    NOB_ASSERT(dirp);

    if (dirp->dirent == NULL) {
        dirp->dirent = (struct dirent*)NOB_REALLOC(NULL, sizeof(struct dirent));
        memset(dirp->dirent, 0, sizeof(struct dirent));
    } else {
        if(!FindNextFile(dirp->hFind, &dirp->data)) {
            if (GetLastError() != ERROR_NO_MORE_FILES) {
                // TODO: readdir should set errno accordingly on FindNextFile fail
                // https://docs.microsoft.com/en-us/windows/win32/api/errhandlingapi/nf-errhandlingapi-getlasterror
                errno = ENOSYS;
            }

            return NULL;
        }
    }

    memset(dirp->dirent->d_name, 0, sizeof(dirp->dirent->d_name));

    strncpy(
        dirp->dirent->d_name,
        dirp->data.cFileName,
        sizeof(dirp->dirent->d_name) - 1);

    return dirp->dirent;
}

NOBDEF int closedir(DIR *dirp)
{
    NOB_ASSERT(dirp);

    if(!FindClose(dirp->hFind)) {
        // TODO: closedir should set errno accordingly on FindClose fail
        // https://docs.microsoft.com/en-us/windows/win32/api/errhandlingapi/nf-errhandlingapi-getlasterror
        errno = ENOSYS;
        return -1;
    }

    if (dirp->dirent) {
        NOB_FREE(dirp->dirent);
    }
    NOB_FREE(dirp);

    return 0;
}
#endif // _WIN32
// minirent.h SOURCE END ////////////////////////////////////////

#endif // NOB_IMPLEMENTATION

#ifndef NOB_STRIP_PREFIX_GUARD_
#define NOB_STRIP_PREFIX_GUARD_
    // NOTE: The name stripping should be part of the header so it's not accidentally included
    // several times. At the same time, it should be at the end of the file so to not create any
    // potential conflicts in the NOB_IMPLEMENTATION. The header obviously cannot be at the end
    // of the file because NOB_IMPLEMENTATION needs the forward declarations from there. So the
    // solution is to split the header into two parts where the name stripping part is at the
    // end of the file after the NOB_IMPLEMENTATION.
    #ifdef NOB_STRIP_PREFIX
        #define TODO NOB_TODO
        #define UNREACHABLE NOB_UNREACHABLE
        #define UNUSED NOB_UNUSED
        #define ARRAY_LEN NOB_ARRAY_LEN
        #define ARRAY_GET NOB_ARRAY_GET
        #define INFO NOB_INFO
        #define WARNING NOB_WARNING
        #define ERROR NOB_ERROR
        #define NO_LOGS NOB_NO_LOGS
        #define Log_Level Nob_Log_Level
        #define minimal_log_level nob_minimal_log_level
        // NOTE: Name log is already defined in math.h and historically always was the natural logarithmic function.
        // So there should be no reason to strip the `nob_` prefix in this specific case.
        // #define log nob_log
        #define shift nob_shift
        #define shift_args nob_shift_args
        #define File_Paths Nob_File_Paths
        #define FILE_REGULAR NOB_FILE_REGULAR
        #define FILE_DIRECTORY NOB_FILE_DIRECTORY
        #define FILE_SYMLINK NOB_FILE_SYMLINK
        #define FILE_OTHER NOB_FILE_OTHER
        #define File_Type Nob_File_Type
        #define mkdir_if_not_exists nob_mkdir_if_not_exists
        #define copy_file nob_copy_file
        #define copy_directory_recursively nob_copy_directory_recursively
        #define read_entire_dir nob_read_entire_dir
        #define write_entire_file nob_write_entire_file
        #define get_file_type nob_get_file_type
        #define delete_file nob_delete_file
        #define return_defer nob_return_defer
        #define da_append nob_da_append
        #define da_free nob_da_free
        #define da_append_many nob_da_append_many
        #define da_resize nob_da_resize
        #define da_reserve nob_da_reserve
        #define da_last nob_da_last
        #define da_remove_unordered nob_da_remove_unordered
        #define da_foreach nob_da_foreach
        #define String_Builder Nob_String_Builder
        #define read_entire_file nob_read_entire_file
        #define sb_appendf nob_sb_appendf
        #define sb_append_buf nob_sb_append_buf
        #define sb_append_cstr nob_sb_append_cstr
        #define sb_append_null nob_sb_append_null
        #define sb_free nob_sb_free
        #define Proc Nob_Proc
        #define INVALID_PROC NOB_INVALID_PROC
        #define Fd Nob_Fd
        #define INVALID_FD NOB_INVALID_FD
        #define fd_open_for_read nob_fd_open_for_read
        #define fd_open_for_write nob_fd_open_for_write
        #define fd_close nob_fd_close
        #define Procs Nob_Procs
        #define proc_wait nob_proc_wait
        #define procs_wait nob_procs_wait
        #define procs_wait_and_reset nob_procs_wait_and_reset
        #define procs_append_with_flush nob_procs_append_with_flush
        #define procs_flush nob_procs_flush
        #define Cmd Nob_Cmd
        #define Cmd_Redirect Nob_Cmd_Redirect
        #define Cmd_Opt Nob_Cmd_Opt
        #define cmd_run_opt nob_cmd_run_opt
        #define cmd_run nob_cmd_run
        #define cmd_render nob_cmd_render
        #define cmd_append nob_cmd_append
        #define cmd_extend nob_cmd_extend
        #define cmd_free nob_cmd_free
        #define cmd_run_async nob_cmd_run_async
        #define cmd_run_async_and_reset nob_cmd_run_async_and_reset
        #define cmd_run_async_redirect nob_cmd_run_async_redirect
        #define cmd_run_async_redirect_and_reset nob_cmd_run_async_redirect_and_reset
        #define cmd_run_sync nob_cmd_run_sync
        #define cmd_run_sync_and_reset nob_cmd_run_sync_and_reset
        #define cmd_run_sync_redirect nob_cmd_run_sync_redirect
        #define cmd_run_sync_redirect_and_reset nob_cmd_run_sync_redirect_and_reset
        #define temp_strdup nob_temp_strdup
        #define temp_alloc nob_temp_alloc
        #define temp_sprintf nob_temp_sprintf
        #define temp_reset nob_temp_reset
        #define temp_save nob_temp_save
        #define temp_rewind nob_temp_rewind
        #define path_name nob_path_name
        // NOTE: rename(2) is widely known POSIX function. We never wanna collide with it.
        // #define rename nob_rename
        #define needs_rebuild nob_needs_rebuild
        #define needs_rebuild1 nob_needs_rebuild1
        #define file_exists nob_file_exists
        #define get_current_dir_temp nob_get_current_dir_temp
        #define set_current_dir nob_set_current_dir
        #define String_View Nob_String_View
        #define temp_sv_to_cstr nob_temp_sv_to_cstr
        #define sv_chop_by_delim nob_sv_chop_by_delim
        #define sv_chop_left nob_sv_chop_left
        #define sv_trim nob_sv_trim
        #define sv_trim_left nob_sv_trim_left
        #define sv_trim_right nob_sv_trim_right
        #define sv_eq nob_sv_eq
        #define sv_starts_with nob_sv_starts_with
        #define sv_end_with nob_sv_end_with
        #define sv_from_cstr nob_sv_from_cstr
        #define sv_from_parts nob_sv_from_parts
        #define sb_to_sv nob_sb_to_sv
        #define win32_error_message nob_win32_error_message
        #define nprocs nob_nprocs
        #define nanos_since_unspecified_epoch nob_nanos_since_unspecified_epoch
        #define NANOS_PER_SEC NOB_NANOS_PER_SEC
    #endif // NOB_STRIP_PREFIX
#endif // NOB_STRIP_PREFIX_GUARD_

/*
   Revision history:

     1.23.0 (2025-08-22) Introduce new API for running commands (by @rexim, @programmerlexi, @0x152a)
                           - Add nob_cmd_run()
                           - Add nob_cmd_run_opt()
                           - Add struct Nob_Cmd_Opt
                           - Add nob_procs_flush()
                           - Add nob_nprocs()
                         Deprecate old API for running commands. (by @rexim)
                           We do not plan to delete this API any time, but we believe that the new one is more convenient.
                           - Deprecate struct Nob_Cmd_Redirect{} (it's not explicitly marked with NOB_DEPRECATED, but functions that use it are)
                           - Turn nob_cmd_run_async() into a function (otherwise it's not deprecatable with NOB_DEPRECATED)
                           - Deprecate nob_cmd_run_async()
                           - Deprecate nob_cmd_run_async_and_reset()
                           - Deprecate nob_cmd_run_async_redirect()
                           - Deprecate nob_cmd_run_async_redirect_and_reset()
                           - Deprecate nob_cmd_run_sync()
                           - Deprecate nob_cmd_run_sync_and_reset()
                           - Deprecate nob_cmd_run_sync_redirect()
                           - Deprecate nob_cmd_run_sync_redirect_and_reset()
                           - Deprecate nob_procs_append_with_flush()
                           - Deprecate nob_procs_wait_and_reset()
                         Introduce deprecation mechanism (by @yuI4140, @rexim)
                           By default, deprecation warnings are not reported. You have to #define NOB_WARN_DEPRECATED to enable them.
                           - Add NOB_DEPRECATED()
                           - Add NOB_WARN_DEPRECATED
                         Add NOB_DECLTYPE_CAST() for C++-compatible casting of allocation results (by @rexim)
                         Introduce basic performance measuring mechanism (By @mikmart)
                           - Add nob_nanos_since_unspecified_epoch()
                           - Add NOB_NANOS_PER_SEC
     1.22.0 (2025-08-12) Add NOBDEF macro to the beginning of function declarations (by @minefreak19)
                         Add more flags to MSVC nob_cc_flags() (by @PieVieRo)
     1.21.0 (2025-08-11) Add NOB_NO_MINIRENT guard for "minirent.h" (by @fietec)
     1.20.9 (2025-08-11) Fix warnings on Windows: Define _CRT_SECURE_NO_WARNINGS, Rename mkdir to _mkdir (by @OetkenPurveyorOfCode)
     1.20.8 (2025-08-11) Fix the bug with nob_get_file_type() not identifying symlinks correctly on POSIX (By @samuellieberman)
     1.20.7 (2025-07-29) Align nob_temp_alloc() allocations by the word size (By @rexim)
     1.20.6 (2025-05-16) Never strip nob_* suffix from nob_rename (By @rexim)
     1.20.5 (2025-05-16) NOB_PRINTF_FORMAT() support for MinGW (By @KillerxDBr)
     1.20.4 (2025-05-16) More reliable rendering of the Windows command (By @vylsaz)
     1.20.3 (2025-05-16) Add check for __clang__ along with _MSC_VER checks (By @nashiora)
     1.20.2 (2025-04-24) Report the program name that failed to start up in nob_cmd_run_async_redirect() (By @rexim)
     1.20.1 (2025-04-16) Use vsnprintf() in nob_sb_appendf() instead of vsprintf() (By @LainLayer)
     1.20.0 (2025-04-16) Introduce nob_cc(), nob_cc_flags(), nob_cc_inputs(), nob_cc_output() macros (By @rexim)
     1.19.0 (2025-03-25) Add nob_procs_append_with_flush() (By @rexim and @anion155)
     1.18.0 (2025-03-24) Add nob_da_foreach() (By @rexim)
                         Allow file sizes greater than 2GB to be read on windows (By @satchelfrost and @KillerxDBr)
                         Fix nob_fd_open_for_write behaviour on windows so it truncates the opened files (By @twixuss)
     1.17.0 (2025-03-16) Factor out nob_da_reserve() (By @rexim)
                         Add nob_sb_appendf() (By @angelcaru)
     1.16.1 (2025-03-16) Make nob_da_resize() exponentially grow capacity similar to no_da_append_many()
     1.16.0 (2025-03-16) Introduce NOB_PRINTF_FORMAT
     1.15.1 (2025-03-16) Make nob.h compilable in gcc/clang with -std=c99 on POSIX. This includes:
                           not using strsignal()
                           using S_IS* stat macros instead of S_IF* flags
     1.15.0 (2025-03-03) Add nob_sv_chop_left()
     1.14.1 (2025-03-02) Add NOB_EXPERIMENTAL_DELETE_OLD flag that enables deletion of nob.old in Go Rebuild Urself™ Technology
     1.14.0 (2025-02-17) Add nob_da_last()
                         Add nob_da_remove_unordered()
     1.13.1 (2025-02-17) Fix segfault in nob_delete_file() (By @SileNce5k)
     1.13.0 (2025-02-11) Add nob_da_resize() (By @satchelfrost)
     1.12.0 (2025-02-04) Add nob_delete_file()
                         Add nob_sv_start_with()
     1.11.0 (2025-02-04) Add NOB_GO_REBUILD_URSELF_PLUS() (By @rexim)
     1.10.0 (2025-02-04) Make NOB_ASSERT, NOB_REALLOC, and NOB_FREE redefinable (By @OleksiiBulba)
      1.9.1 (2025-02-04) Fix signature of nob_get_current_dir_temp() (By @julianstoerig)
      1.9.0 (2024-11-06) Add Nob_Cmd_Redirect mechanism (By @rexim)
                         Add nob_path_name() (By @0dminnimda)
      1.8.0 (2024-11-03) Add nob_cmd_extend() (By @0dminnimda)
      1.7.0 (2024-11-03) Add nob_win32_error_message and NOB_WIN32_ERR_MSG_SIZE (By @KillerxDBr)
      1.6.0 (2024-10-27) Add nob_cmd_run_sync_and_reset()
                         Add nob_sb_to_sv()
                         Add nob_procs_wait_and_reset()
      1.5.1 (2024-10-25) Include limits.h for Linux musl libc (by @pgalkin)
      1.5.0 (2024-10-23) Add nob_get_current_dir_temp()
                         Add nob_set_current_dir()
      1.4.0 (2024-10-21) Fix UX issues with NOB_GO_REBUILD_URSELF on Windows when you call nob without the .exe extension (By @pgalkin)
                         Add nob_sv_end_with (By @pgalkin)
      1.3.2 (2024-10-21) Fix unreachable error in nob_log on passing NOB_NO_LOGS
      1.3.1 (2024-10-21) Fix redeclaration error for minimal_log_level (By @KillerxDBr)
      1.3.0 (2024-10-17) Add NOB_UNREACHABLE
      1.2.2 (2024-10-16) Fix compilation of nob_cmd_run_sync_and_reset on Windows (By @KillerxDBr)
      1.2.1 (2024-10-16) Add a separate include guard for NOB_STRIP_PREFIX.
      1.2.0 (2024-10-15) Make NOB_DA_INIT_CAP redefinable
                         Add NOB_STRIP_PREFIX which strips off nob_* prefix from all the user facing names
                         Add NOB_UNUSED macro
                         Add NOB_TODO macro
                         Add nob_sv_trim_left and nob_sv_trim_right declarations to the header part
      1.1.1 (2024-10-15) Remove forward declaration for is_path1_modified_after_path2
      1.1.0 (2024-10-15) nob_minimal_log_level
                         nob_cmd_run_sync_and_reset
      1.0.0 (2024-10-15) first release based on https://github.com/tsoding/musializer/blob/4ac7cce9874bc19e02d8c160c8c6229de8919401/nob.h
*/

/*
   Version Conventions:

      We are following https://semver.org/ so the version has a format MAJOR.MINOR.PATCH:
      - Modifying comments does not update the version.
      - PATCH is incremented in case of a bug fix or refactoring without touching the API.
      - MINOR is incremented when new functions and/or types are added in a way that does
        not break any existing user code. We want to do this in the majority of the situation.
        If we want to delete a certain function or type in favor of another one we should
        just add the new function/type and deprecate the old one in a backward compatible way
        and let them co-exist for a while.
      - MAJOR update should be just a periodic cleanup of the DEPRECATED functions and types
        without really modifying any existing functionality.
      - Breaking backward compatibility in a MINOR release should be considered a bug and
        should be promptly fixed in the next PATCH release.

   Naming Conventions:

      - All the user facing names should be prefixed with `nob_` or `NOB_` depending on the case.
      - The prefixes of non-redefinable names should be strippable with NOB_STRIP_PREFIX (unless
        explicitly stated otherwise like in case of nob_log).
      - Internal functions should be prefixed with `nob__` (double underscore).
*/

/*
   ------------------------------------------------------------------------------
   This software is available under 2 licenses -- choose whichever you prefer.
   ------------------------------------------------------------------------------
   ALTERNATIVE A - MIT License
   Copyright (c) 2024 Alexey Kutepov
   Permission is hereby granted, free of charge, to any person obtaining a copy of
   this software and associated documentation files (the "Software"), to deal in
   the Software without restriction, including without limitation the rights to
   use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies
   of the Software, and to permit persons to whom the Software is furnished to do
   so, subject to the following conditions:
   The above copyright notice and this permission notice shall be included in all
   copies or substantial portions of the Software.
   THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
   IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
   FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
   AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
   LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
   OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
   SOFTWARE.
   ------------------------------------------------------------------------------
   ALTERNATIVE B - Public Domain (www.unlicense.org)
   This is free and unencumbered software released into the public domain.
   Anyone is free to copy, modify, publish, use, compile, sell, or distribute this
   software, either in source code form or as a compiled binary, for any purpose,
   commercial or non-commercial, and by any means.
   In jurisdictions that recognize copyright laws, the author or authors of this
   software dedicate any and all copyright interest in the software to the public
   domain. We make this dedication for the benefit of the public at large and to
   the detriment of our heirs and successors. We intend this dedication to be an
   overt act of relinquishment in perpetuity of all present and future rights to
   this software under copyright law.
   THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
   IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
   FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
   AUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
   ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
   WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
   ------------------------------------------------------------------------------
*/

```

`dev-deps/stb_image.h`:

```h
/* stb_image - v2.27 - public domain image loader - http://nothings.org/stb
                                  no warranty implied; use at your own risk

   Do this:
      #define STB_IMAGE_IMPLEMENTATION
   before you include this file in *one* C or C++ file to create the implementation.

   // i.e. it should look like this:
   #include ...
   #include ...
   #include ...
   #define STB_IMAGE_IMPLEMENTATION
   #include "stb_image.h"

   You can #define STBI_ASSERT(x) before the #include to avoid using assert.h.
   And #define STBI_MALLOC, STBI_REALLOC, and STBI_FREE to avoid using malloc,realloc,free


   QUICK NOTES:
      Primarily of interest to game developers and other people who can
          avoid problematic images and only need the trivial interface

      JPEG baseline & progressive (12 bpc/arithmetic not supported, same as stock IJG lib)
      PNG 1/2/4/8/16-bit-per-channel

      TGA (not sure what subset, if a subset)
      BMP non-1bpp, non-RLE
      PSD (composited view only, no extra channels, 8/16 bit-per-channel)

      GIF (*comp always reports as 4-channel)
      HDR (radiance rgbE format)
      PIC (Softimage PIC)
      PNM (PPM and PGM binary only)

      Animated GIF still needs a proper API, but here's one way to do it:
          http://gist.github.com/urraka/685d9a6340b26b830d49

      - decode from memory or through FILE (define STBI_NO_STDIO to remove code)
      - decode from arbitrary I/O callbacks
      - SIMD acceleration on x86/x64 (SSE2) and ARM (NEON)

   Full documentation under "DOCUMENTATION" below.


LICENSE

  See end of file for license information.

RECENT REVISION HISTORY:

      2.27  (2021-07-11) document stbi_info better, 16-bit PNM support, bug fixes
      2.26  (2020-07-13) many minor fixes
      2.25  (2020-02-02) fix warnings
      2.24  (2020-02-02) fix warnings; thread-local failure_reason and flip_vertically
      2.23  (2019-08-11) fix clang static analysis warning
      2.22  (2019-03-04) gif fixes, fix warnings
      2.21  (2019-02-25) fix typo in comment
      2.20  (2019-02-07) support utf8 filenames in Windows; fix warnings and platform ifdefs
      2.19  (2018-02-11) fix warning
      2.18  (2018-01-30) fix warnings
      2.17  (2018-01-29) bugfix, 1-bit BMP, 16-bitness query, fix warnings
      2.16  (2017-07-23) all functions have 16-bit variants; optimizations; bugfixes
      2.15  (2017-03-18) fix png-1,2,4; all Imagenet JPGs; no runtime SSE detection on GCC
      2.14  (2017-03-03) remove deprecated STBI_JPEG_OLD; fixes for Imagenet JPGs
      2.13  (2016-12-04) experimental 16-bit API, only for PNG so far; fixes
      2.12  (2016-04-02) fix typo in 2.11 PSD fix that caused crashes
      2.11  (2016-04-02) 16-bit PNGS; enable SSE2 in non-gcc x64
                         RGB-format JPEG; remove white matting in PSD;
                         allocate large structures on the stack;
                         correct channel count for PNG & BMP
      2.10  (2016-01-22) avoid warning introduced in 2.09
      2.09  (2016-01-16) 16-bit TGA; comments in PNM files; STBI_REALLOC_SIZED

   See end of file for full revision history.


 ============================    Contributors    =========================

 Image formats                          Extensions, features
    Sean Barrett (jpeg, png, bmp)          Jetro Lauha (stbi_info)
    Nicolas Schulz (hdr, psd)              Martin "SpartanJ" Golini (stbi_info)
    Jonathan Dummer (tga)                  James "moose2000" Brown (iPhone PNG)
    Jean-Marc Lienher (gif)                Ben "Disch" Wenger (io callbacks)
    Tom Seddon (pic)                       Omar Cornut (1/2/4-bit PNG)
    Thatcher Ulrich (psd)                  Nicolas Guillemot (vertical flip)
    Ken Miller (pgm, ppm)                  Richard Mitton (16-bit PSD)
    github:urraka (animated gif)           Junggon Kim (PNM comments)
    Christopher Forseth (animated gif)     Daniel Gibson (16-bit TGA)
                                           socks-the-fox (16-bit PNG)
                                           Jeremy Sawicki (handle all ImageNet JPGs)
 Optimizations & bugfixes                  Mikhail Morozov (1-bit BMP)
    Fabian "ryg" Giesen                    Anael Seghezzi (is-16-bit query)
    Arseny Kapoulkine                      Simon Breuss (16-bit PNM)
    John-Mark Allen
    Carmelo J Fdez-Aguera

 Bug & warning fixes
    Marc LeBlanc            David Woo          Guillaume George     Martins Mozeiko
    Christpher Lloyd        Jerry Jansson      Joseph Thomson       Blazej Dariusz Roszkowski
    Phil Jordan                                Dave Moore           Roy Eltham
    Hayaki Saito            Nathan Reed        Won Chun
    Luke Graham             Johan Duparc       Nick Verigakis       the Horde3D community
    Thomas Ruf              Ronny Chevalier                         github:rlyeh
    Janez Zemva             John Bartholomew   Michal Cichon        github:romigrou
    Jonathan Blow           Ken Hamada         Tero Hanninen        github:svdijk
    Eugene Golushkov        Laurent Gomila     Cort Stratton        github:snagar
    Aruelien Pocheville     Sergio Gonzalez    Thibault Reuille     github:Zelex
    Cass Everitt            Ryamond Barbiero                        github:grim210
    Paul Du Bois            Engin Manap        Aldo Culquicondor    github:sammyhw
    Philipp Wiesemann       Dale Weiler        Oriol Ferrer Mesia   github:phprus
    Josh Tobin                                 Matthew Gregan       github:poppolopoppo
    Julian Raschke          Gregory Mullen     Christian Floisand   github:darealshinji
    Baldur Karlsson         Kevin Schmidt      JR Smith             github:Michaelangel007
                            Brad Weinberger    Matvey Cherevko      github:mosra
    Luca Sas                Alexander Veselov  Zack Middleton       [reserved]
    Ryan C. Gordon          [reserved]                              [reserved]
                     DO NOT ADD YOUR NAME HERE

                     Jacko Dirks

  To add your name to the credits, pick a random blank space in the middle and fill it.
  80% of merge conflicts on stb PRs are due to people adding their name at the end
  of the credits.
*/

#ifndef STBI_INCLUDE_STB_IMAGE_H
#define STBI_INCLUDE_STB_IMAGE_H

// DOCUMENTATION
//
// Limitations:
//    - no 12-bit-per-channel JPEG
//    - no JPEGs with arithmetic coding
//    - GIF always returns *comp=4
//
// Basic usage (see HDR discussion below for HDR usage):
//    int x,y,n;
//    unsigned char *data = stbi_load(filename, &x, &y, &n, 0);
//    // ... process data if not NULL ...
//    // ... x = width, y = height, n = # 8-bit components per pixel ...
//    // ... replace '0' with '1'..'4' to force that many components per pixel
//    // ... but 'n' will always be the number that it would have been if you said 0
//    stbi_image_free(data)
//
// Standard parameters:
//    int *x                 -- outputs image width in pixels
//    int *y                 -- outputs image height in pixels
//    int *channels_in_file  -- outputs # of image components in image file
//    int desired_channels   -- if non-zero, # of image components requested in result
//
// The return value from an image loader is an 'unsigned char *' which points
// to the pixel data, or NULL on an allocation failure or if the image is
// corrupt or invalid. The pixel data consists of *y scanlines of *x pixels,
// with each pixel consisting of N interleaved 8-bit components; the first
// pixel pointed to is top-left-most in the image. There is no padding between
// image scanlines or between pixels, regardless of format. The number of
// components N is 'desired_channels' if desired_channels is non-zero, or
// *channels_in_file otherwise. If desired_channels is non-zero,
// *channels_in_file has the number of components that _would_ have been
// output otherwise. E.g. if you set desired_channels to 4, you will always
// get RGBA output, but you can check *channels_in_file to see if it's trivially
// opaque because e.g. there were only 3 channels in the source image.
//
// An output image with N components has the following components interleaved
// in this order in each pixel:
//
//     N=#comp     components
//       1           grey
//       2           grey, alpha
//       3           red, green, blue
//       4           red, green, blue, alpha
//
// If image loading fails for any reason, the return value will be NULL,
// and *x, *y, *channels_in_file will be unchanged. The function
// stbi_failure_reason() can be queried for an extremely brief, end-user
// unfriendly explanation of why the load failed. Define STBI_NO_FAILURE_STRINGS
// to avoid compiling these strings at all, and STBI_FAILURE_USERMSG to get slightly
// more user-friendly ones.
//
// Paletted PNG, BMP, GIF, and PIC images are automatically depalettized.
//
// To query the width, height and component count of an image without having to
// decode the full file, you can use the stbi_info family of functions:
//
//   int x,y,n,ok;
//   ok = stbi_info(filename, &x, &y, &n);
//   // returns ok=1 and sets x, y, n if image is a supported format,
//   // 0 otherwise.
//
// Note that stb_image pervasively uses ints in its public API for sizes,
// including sizes of memory buffers. This is now part of the API and thus
// hard to change without causing breakage. As a result, the various image
// loaders all have certain limits on image size; these differ somewhat
// by format but generally boil down to either just under 2GB or just under
// 1GB. When the decoded image would be larger than this, stb_image decoding
// will fail.
//
// Additionally, stb_image will reject image files that have any of their
// dimensions set to a larger value than the configurable STBI_MAX_DIMENSIONS,
// which defaults to 2**24 = 16777216 pixels. Due to the above memory limit,
// the only way to have an image with such dimensions load correctly
// is for it to have a rather extreme aspect ratio. Either way, the
// assumption here is that such larger images are likely to be malformed
// or malicious. If you do need to load an image with individual dimensions
// larger than that, and it still fits in the overall size limit, you can
// #define STBI_MAX_DIMENSIONS on your own to be something larger.
//
// ===========================================================================
//
// UNICODE:
//
//   If compiling for Windows and you wish to use Unicode filenames, compile
//   with
//       #define STBI_WINDOWS_UTF8
//   and pass utf8-encoded filenames. Call stbi_convert_wchar_to_utf8 to convert
//   Windows wchar_t filenames to utf8.
//
// ===========================================================================
//
// Philosophy
//
// stb libraries are designed with the following priorities:
//
//    1. easy to use
//    2. easy to maintain
//    3. good performance
//
// Sometimes I let "good performance" creep up in priority over "easy to maintain",
// and for best performance I may provide less-easy-to-use APIs that give higher
// performance, in addition to the easy-to-use ones. Nevertheless, it's important
// to keep in mind that from the standpoint of you, a client of this library,
// all you care about is #1 and #3, and stb libraries DO NOT emphasize #3 above all.
//
// Some secondary priorities arise directly from the first two, some of which
// provide more explicit reasons why performance can't be emphasized.
//
//    - Portable ("ease of use")
//    - Small source code footprint ("easy to maintain")
//    - No dependencies ("ease of use")
//
// ===========================================================================
//
// I/O callbacks
//
// I/O callbacks allow you to read from arbitrary sources, like packaged
// files or some other source. Data read from callbacks are processed
// through a small internal buffer (currently 128 bytes) to try to reduce
// overhead.
//
// The three functions you must define are "read" (reads some bytes of data),
// "skip" (skips some bytes of data), "eof" (reports if the stream is at the end).
//
// ===========================================================================
//
// SIMD support
//
// The JPEG decoder will try to automatically use SIMD kernels on x86 when
// supported by the compiler. For ARM Neon support, you must explicitly
// request it.
//
// (The old do-it-yourself SIMD API is no longer supported in the current
// code.)
//
// On x86, SSE2 will automatically be used when available based on a run-time
// test; if not, the generic C versions are used as a fall-back. On ARM targets,
// the typical path is to have separate builds for NEON and non-NEON devices
// (at least this is true for iOS and Android). Therefore, the NEON support is
// toggled by a build flag: define STBI_NEON to get NEON loops.
//
// If for some reason you do not want to use any of SIMD code, or if
// you have issues compiling it, you can disable it entirely by
// defining STBI_NO_SIMD.
//
// ===========================================================================
//
// HDR image support   (disable by defining STBI_NO_HDR)
//
// stb_image supports loading HDR images in general, and currently the Radiance
// .HDR file format specifically. You can still load any file through the existing
// interface; if you attempt to load an HDR file, it will be automatically remapped
// to LDR, assuming gamma 2.2 and an arbitrary scale factor defaulting to 1;
// both of these constants can be reconfigured through this interface:
//
//     stbi_hdr_to_ldr_gamma(2.2f);
//     stbi_hdr_to_ldr_scale(1.0f);
//
// (note, do not use _inverse_ constants; stbi_image will invert them
// appropriately).
//
// Additionally, there is a new, parallel interface for loading files as
// (linear) floats to preserve the full dynamic range:
//
//    float *data = stbi_loadf(filename, &x, &y, &n, 0);
//
// If you load LDR images through this interface, those images will
// be promoted to floating point values, run through the inverse of
// constants corresponding to the above:
//
//     stbi_ldr_to_hdr_scale(1.0f);
//     stbi_ldr_to_hdr_gamma(2.2f);
//
// Finally, given a filename (or an open file or memory block--see header
// file for details) containing image data, you can query for the "most
// appropriate" interface to use (that is, whether the image is HDR or
// not), using:
//
//     stbi_is_hdr(char *filename);
//
// ===========================================================================
//
// iPhone PNG support:
//
// We optionally support converting iPhone-formatted PNGs (which store
// premultiplied BGRA) back to RGB, even though they're internally encoded
// differently. To enable this conversion, call
// stbi_convert_iphone_png_to_rgb(1).
//
// Call stbi_set_unpremultiply_on_load(1) as well to force a divide per
// pixel to remove any premultiplied alpha *only* if the image file explicitly
// says there's premultiplied data (currently only happens in iPhone images,
// and only if iPhone convert-to-rgb processing is on).
//
// ===========================================================================
//
// ADDITIONAL CONFIGURATION
//
//  - You can suppress implementation of any of the decoders to reduce
//    your code footprint by #defining one or more of the following
//    symbols before creating the implementation.
//
//        STBI_NO_JPEG
//        STBI_NO_PNG
//        STBI_NO_BMP
//        STBI_NO_PSD
//        STBI_NO_TGA
//        STBI_NO_GIF
//        STBI_NO_HDR
//        STBI_NO_PIC
//        STBI_NO_PNM   (.ppm and .pgm)
//
//  - You can request *only* certain decoders and suppress all other ones
//    (this will be more forward-compatible, as addition of new decoders
//    doesn't require you to disable them explicitly):
//
//        STBI_ONLY_JPEG
//        STBI_ONLY_PNG
//        STBI_ONLY_BMP
//        STBI_ONLY_PSD
//        STBI_ONLY_TGA
//        STBI_ONLY_GIF
//        STBI_ONLY_HDR
//        STBI_ONLY_PIC
//        STBI_ONLY_PNM   (.ppm and .pgm)
//
//   - If you use STBI_NO_PNG (or _ONLY_ without PNG), and you still
//     want the zlib decoder to be available, #define STBI_SUPPORT_ZLIB
//
//  - If you define STBI_MAX_DIMENSIONS, stb_image will reject images greater
//    than that size (in either width or height) without further processing.
//    This is to let programs in the wild set an upper bound to prevent
//    denial-of-service attacks on untrusted data, as one could generate a
//    valid image of gigantic dimensions and force stb_image to allocate a
//    huge block of memory and spend disproportionate time decoding it. By
//    default this is set to (1 << 24), which is 16777216, but that's still
//    very big.

#ifndef STBI_NO_STDIO
#include <stdio.h>
#endif // STBI_NO_STDIO

#define STBI_VERSION 1

enum
{
   STBI_default = 0, // only used for desired_channels

   STBI_grey       = 1,
   STBI_grey_alpha = 2,
   STBI_rgb        = 3,
   STBI_rgb_alpha  = 4
};

#include <stdlib.h>
typedef unsigned char stbi_uc;
typedef unsigned short stbi_us;

#ifdef __cplusplus
extern "C" {
#endif

#ifndef STBIDEF
#ifdef STB_IMAGE_STATIC
#define STBIDEF static
#else
#define STBIDEF extern
#endif
#endif

//////////////////////////////////////////////////////////////////////////////
//
// PRIMARY API - works on images of any type
//

//
// load image by filename, open file, or memory buffer
//

typedef struct
{
   int      (*read)  (void *user,char *data,int size);   // fill 'data' with 'size' bytes.  return number of bytes actually read
   void     (*skip)  (void *user,int n);                 // skip the next 'n' bytes, or 'unget' the last -n bytes if negative
   int      (*eof)   (void *user);                       // returns nonzero if we are at end of file/data
} stbi_io_callbacks;

////////////////////////////////////
//
// 8-bits-per-channel interface
//

STBIDEF stbi_uc *stbi_load_from_memory   (stbi_uc           const *buffer, int len   , int *x, int *y, int *channels_in_file, int desired_channels);
STBIDEF stbi_uc *stbi_load_from_callbacks(stbi_io_callbacks const *clbk  , void *user, int *x, int *y, int *channels_in_file, int desired_channels);

#ifndef STBI_NO_STDIO
STBIDEF stbi_uc *stbi_load            (char const *filename, int *x, int *y, int *channels_in_file, int desired_channels);
STBIDEF stbi_uc *stbi_load_from_file  (FILE *f, int *x, int *y, int *channels_in_file, int desired_channels);
// for stbi_load_from_file, file pointer is left pointing immediately after image
#endif

#ifndef STBI_NO_GIF
STBIDEF stbi_uc *stbi_load_gif_from_memory(stbi_uc const *buffer, int len, int **delays, int *x, int *y, int *z, int *comp, int req_comp);
#endif

#ifdef STBI_WINDOWS_UTF8
STBIDEF int stbi_convert_wchar_to_utf8(char *buffer, size_t bufferlen, const wchar_t* input);
#endif

////////////////////////////////////
//
// 16-bits-per-channel interface
//

STBIDEF stbi_us *stbi_load_16_from_memory   (stbi_uc const *buffer, int len, int *x, int *y, int *channels_in_file, int desired_channels);
STBIDEF stbi_us *stbi_load_16_from_callbacks(stbi_io_callbacks const *clbk, void *user, int *x, int *y, int *channels_in_file, int desired_channels);

#ifndef STBI_NO_STDIO
STBIDEF stbi_us *stbi_load_16          (char const *filename, int *x, int *y, int *channels_in_file, int desired_channels);
STBIDEF stbi_us *stbi_load_from_file_16(FILE *f, int *x, int *y, int *channels_in_file, int desired_channels);
#endif

////////////////////////////////////
//
// float-per-channel interface
//
#ifndef STBI_NO_LINEAR
   STBIDEF float *stbi_loadf_from_memory     (stbi_uc const *buffer, int len, int *x, int *y, int *channels_in_file, int desired_channels);
   STBIDEF float *stbi_loadf_from_callbacks  (stbi_io_callbacks const *clbk, void *user, int *x, int *y,  int *channels_in_file, int desired_channels);

   #ifndef STBI_NO_STDIO
   STBIDEF float *stbi_loadf            (char const *filename, int *x, int *y, int *channels_in_file, int desired_channels);
   STBIDEF float *stbi_loadf_from_file  (FILE *f, int *x, int *y, int *channels_in_file, int desired_channels);
   #endif
#endif

#ifndef STBI_NO_HDR
   STBIDEF void   stbi_hdr_to_ldr_gamma(float gamma);
   STBIDEF void   stbi_hdr_to_ldr_scale(float scale);
#endif // STBI_NO_HDR

#ifndef STBI_NO_LINEAR
   STBIDEF void   stbi_ldr_to_hdr_gamma(float gamma);
   STBIDEF void   stbi_ldr_to_hdr_scale(float scale);
#endif // STBI_NO_LINEAR

// stbi_is_hdr is always defined, but always returns false if STBI_NO_HDR
STBIDEF int    stbi_is_hdr_from_callbacks(stbi_io_callbacks const *clbk, void *user);
STBIDEF int    stbi_is_hdr_from_memory(stbi_uc const *buffer, int len);
#ifndef STBI_NO_STDIO
STBIDEF int      stbi_is_hdr          (char const *filename);
STBIDEF int      stbi_is_hdr_from_file(FILE *f);
#endif // STBI_NO_STDIO


// get a VERY brief reason for failure
// on most compilers (and ALL modern mainstream compilers) this is threadsafe
STBIDEF const char *stbi_failure_reason  (void);

// free the loaded image -- this is just free()
STBIDEF void     stbi_image_free      (void *retval_from_stbi_load);

// get image dimensions & components without fully decoding
STBIDEF int      stbi_info_from_memory(stbi_uc const *buffer, int len, int *x, int *y, int *comp);
STBIDEF int      stbi_info_from_callbacks(stbi_io_callbacks const *clbk, void *user, int *x, int *y, int *comp);
STBIDEF int      stbi_is_16_bit_from_memory(stbi_uc const *buffer, int len);
STBIDEF int      stbi_is_16_bit_from_callbacks(stbi_io_callbacks const *clbk, void *user);

#ifndef STBI_NO_STDIO
STBIDEF int      stbi_info               (char const *filename,     int *x, int *y, int *comp);
STBIDEF int      stbi_info_from_file     (FILE *f,                  int *x, int *y, int *comp);
STBIDEF int      stbi_is_16_bit          (char const *filename);
STBIDEF int      stbi_is_16_bit_from_file(FILE *f);
#endif



// for image formats that explicitly notate that they have premultiplied alpha,
// we just return the colors as stored in the file. set this flag to force
// unpremultiplication. results are undefined if the unpremultiply overflow.
STBIDEF void stbi_set_unpremultiply_on_load(int flag_true_if_should_unpremultiply);

// indicate whether we should process iphone images back to canonical format,
// or just pass them through "as-is"
STBIDEF void stbi_convert_iphone_png_to_rgb(int flag_true_if_should_convert);

// flip the image vertically, so the first pixel in the output array is the bottom left
STBIDEF void stbi_set_flip_vertically_on_load(int flag_true_if_should_flip);

// as above, but only applies to images loaded on the thread that calls the function
// this function is only available if your compiler supports thread-local variables;
// calling it will fail to link if your compiler doesn't
STBIDEF void stbi_set_unpremultiply_on_load_thread(int flag_true_if_should_unpremultiply);
STBIDEF void stbi_convert_iphone_png_to_rgb_thread(int flag_true_if_should_convert);
STBIDEF void stbi_set_flip_vertically_on_load_thread(int flag_true_if_should_flip);

// ZLIB client - used by PNG, available for other purposes

STBIDEF char *stbi_zlib_decode_malloc_guesssize(const char *buffer, int len, int initial_size, int *outlen);
STBIDEF char *stbi_zlib_decode_malloc_guesssize_headerflag(const char *buffer, int len, int initial_size, int *outlen, int parse_header);
STBIDEF char *stbi_zlib_decode_malloc(const char *buffer, int len, int *outlen);
STBIDEF int   stbi_zlib_decode_buffer(char *obuffer, int olen, const char *ibuffer, int ilen);

STBIDEF char *stbi_zlib_decode_noheader_malloc(const char *buffer, int len, int *outlen);
STBIDEF int   stbi_zlib_decode_noheader_buffer(char *obuffer, int olen, const char *ibuffer, int ilen);


#ifdef __cplusplus
}
#endif

//
//
////   end header file   /////////////////////////////////////////////////////
#endif // STBI_INCLUDE_STB_IMAGE_H

#ifdef STB_IMAGE_IMPLEMENTATION

#if defined(STBI_ONLY_JPEG) || defined(STBI_ONLY_PNG) || defined(STBI_ONLY_BMP) \
  || defined(STBI_ONLY_TGA) || defined(STBI_ONLY_GIF) || defined(STBI_ONLY_PSD) \
  || defined(STBI_ONLY_HDR) || defined(STBI_ONLY_PIC) || defined(STBI_ONLY_PNM) \
  || defined(STBI_ONLY_ZLIB)
   #ifndef STBI_ONLY_JPEG
   #define STBI_NO_JPEG
   #endif
   #ifndef STBI_ONLY_PNG
   #define STBI_NO_PNG
   #endif
   #ifndef STBI_ONLY_BMP
   #define STBI_NO_BMP
   #endif
   #ifndef STBI_ONLY_PSD
   #define STBI_NO_PSD
   #endif
   #ifndef STBI_ONLY_TGA
   #define STBI_NO_TGA
   #endif
   #ifndef STBI_ONLY_GIF
   #define STBI_NO_GIF
   #endif
   #ifndef STBI_ONLY_HDR
   #define STBI_NO_HDR
   #endif
   #ifndef STBI_ONLY_PIC
   #define STBI_NO_PIC
   #endif
   #ifndef STBI_ONLY_PNM
   #define STBI_NO_PNM
   #endif
#endif

#if defined(STBI_NO_PNG) && !defined(STBI_SUPPORT_ZLIB) && !defined(STBI_NO_ZLIB)
#define STBI_NO_ZLIB
#endif


#include <stdarg.h>
#include <stddef.h> // ptrdiff_t on osx
#include <stdlib.h>
#include <string.h>
#include <limits.h>

#if !defined(STBI_NO_LINEAR) || !defined(STBI_NO_HDR)
#include <math.h>  // ldexp, pow
#endif

#ifndef STBI_NO_STDIO
#include <stdio.h>
#endif

#ifndef STBI_ASSERT
#include <assert.h>
#define STBI_ASSERT(x) assert(x)
#endif

#ifdef __cplusplus
#define STBI_EXTERN extern "C"
#else
#define STBI_EXTERN extern
#endif


#ifndef _MSC_VER
   #ifdef __cplusplus
   #define stbi_inline inline
   #else
   #define stbi_inline
   #endif
#else
   #define stbi_inline __forceinline
#endif

#ifndef STBI_NO_THREAD_LOCALS
   #if defined(__cplusplus) &&  __cplusplus >= 201103L
      #define STBI_THREAD_LOCAL       thread_local
   #elif defined(__GNUC__) && __GNUC__ < 5
      #define STBI_THREAD_LOCAL       __thread
   #elif defined(_MSC_VER)
      #define STBI_THREAD_LOCAL       __declspec(thread)
   #elif defined (__STDC_VERSION__) && __STDC_VERSION__ >= 201112L && !defined(__STDC_NO_THREADS__)
      #define STBI_THREAD_LOCAL       _Thread_local
   #endif

   #ifndef STBI_THREAD_LOCAL
      #if defined(__GNUC__)
        #define STBI_THREAD_LOCAL       __thread
      #endif
   #endif
#endif

#ifdef _MSC_VER
typedef unsigned short stbi__uint16;
typedef   signed short stbi__int16;
typedef unsigned int   stbi__uint32;
typedef   signed int   stbi__int32;
#else
#include <stdint.h>
typedef uint16_t stbi__uint16;
typedef int16_t  stbi__int16;
typedef uint32_t stbi__uint32;
typedef int32_t  stbi__int32;
#endif

// should produce compiler error if size is wrong
typedef unsigned char validate_uint32[sizeof(stbi__uint32)==4 ? 1 : -1];

#ifdef _MSC_VER
#define STBI_NOTUSED(v)  (void)(v)
#else
#define STBI_NOTUSED(v)  (void)sizeof(v)
#endif

#ifdef _MSC_VER
#define STBI_HAS_LROTL
#endif

#ifdef STBI_HAS_LROTL
   #define stbi_lrot(x,y)  _lrotl(x,y)
#else
   #define stbi_lrot(x,y)  (((x) << (y)) | ((x) >> (-(y) & 31)))
#endif

#if defined(STBI_MALLOC) && defined(STBI_FREE) && (defined(STBI_REALLOC) || defined(STBI_REALLOC_SIZED))
// ok
#elif !defined(STBI_MALLOC) && !defined(STBI_FREE) && !defined(STBI_REALLOC) && !defined(STBI_REALLOC_SIZED)
// ok
#else
#error "Must define all or none of STBI_MALLOC, STBI_FREE, and STBI_REALLOC (or STBI_REALLOC_SIZED)."
#endif

#ifndef STBI_MALLOC
#define STBI_MALLOC(sz)           malloc(sz)
#define STBI_REALLOC(p,newsz)     realloc(p,newsz)
#define STBI_FREE(p)              free(p)
#endif

#ifndef STBI_REALLOC_SIZED
#define STBI_REALLOC_SIZED(p,oldsz,newsz) STBI_REALLOC(p,newsz)
#endif

// x86/x64 detection
#if defined(__x86_64__) || defined(_M_X64)
#define STBI__X64_TARGET
#elif defined(__i386) || defined(_M_IX86)
#define STBI__X86_TARGET
#endif

#if defined(__GNUC__) && defined(STBI__X86_TARGET) && !defined(__SSE2__) && !defined(STBI_NO_SIMD)
// gcc doesn't support sse2 intrinsics unless you compile with -msse2,
// which in turn means it gets to use SSE2 everywhere. This is unfortunate,
// but previous attempts to provide the SSE2 functions with runtime
// detection caused numerous issues. The way architecture extensions are
// exposed in GCC/Clang is, sadly, not really suited for one-file libs.
// New behavior: if compiled with -msse2, we use SSE2 without any
// detection; if not, we don't use it at all.
#define STBI_NO_SIMD
#endif

#if defined(__MINGW32__) && defined(STBI__X86_TARGET) && !defined(STBI_MINGW_ENABLE_SSE2) && !defined(STBI_NO_SIMD)
// Note that __MINGW32__ doesn't actually mean 32-bit, so we have to avoid STBI__X64_TARGET
//
// 32-bit MinGW wants ESP to be 16-byte aligned, but this is not in the
// Windows ABI and VC++ as well as Windows DLLs don't maintain that invariant.
// As a result, enabling SSE2 on 32-bit MinGW is dangerous when not
// simultaneously enabling "-mstackrealign".
//
// See https://github.com/nothings/stb/issues/81 for more information.
//
// So default to no SSE2 on 32-bit MinGW. If you've read this far and added
// -mstackrealign to your build settings, feel free to #define STBI_MINGW_ENABLE_SSE2.
#define STBI_NO_SIMD
#endif

#if !defined(STBI_NO_SIMD) && (defined(STBI__X86_TARGET) || defined(STBI__X64_TARGET))
#define STBI_SSE2
#include <emmintrin.h>

#ifdef _MSC_VER

#if _MSC_VER >= 1400  // not VC6
#include <intrin.h> // __cpuid
static int stbi__cpuid3(void)
{
   int info[4];
   __cpuid(info,1);
   return info[3];
}
#else
static int stbi__cpuid3(void)
{
   int res;
   __asm {
      mov  eax,1
      cpuid
      mov  res,edx
   }
   return res;
}
#endif

#define STBI_SIMD_ALIGN(type, name) __declspec(align(16)) type name

#if !defined(STBI_NO_JPEG) && defined(STBI_SSE2)
static int stbi__sse2_available(void)
{
   int info3 = stbi__cpuid3();
   return ((info3 >> 26) & 1) != 0;
}
#endif

#else // assume GCC-style if not VC++
#define STBI_SIMD_ALIGN(type, name) type name __attribute__((aligned(16)))

#if !defined(STBI_NO_JPEG) && defined(STBI_SSE2)
static int stbi__sse2_available(void)
{
   // If we're even attempting to compile this on GCC/Clang, that means
   // -msse2 is on, which means the compiler is allowed to use SSE2
   // instructions at will, and so are we.
   return 1;
}
#endif

#endif
#endif

// ARM NEON
#if defined(STBI_NO_SIMD) && defined(STBI_NEON)
#undef STBI_NEON
#endif

#ifdef STBI_NEON
#include <arm_neon.h>
#ifdef _MSC_VER
#define STBI_SIMD_ALIGN(type, name) __declspec(align(16)) type name
#else
#define STBI_SIMD_ALIGN(type, name) type name __attribute__((aligned(16)))
#endif
#endif

#ifndef STBI_SIMD_ALIGN
#define STBI_SIMD_ALIGN(type, name) type name
#endif

#ifndef STBI_MAX_DIMENSIONS
#define STBI_MAX_DIMENSIONS (1 << 24)
#endif

///////////////////////////////////////////////
//
//  stbi__context struct and start_xxx functions

// stbi__context structure is our basic context used by all images, so it
// contains all the IO context, plus some basic image information
typedef struct
{
   stbi__uint32 img_x, img_y;
   int img_n, img_out_n;

   stbi_io_callbacks io;
   void *io_user_data;

   int read_from_callbacks;
   int buflen;
   stbi_uc buffer_start[128];
   int callback_already_read;

   stbi_uc *img_buffer, *img_buffer_end;
   stbi_uc *img_buffer_original, *img_buffer_original_end;
} stbi__context;


static void stbi__refill_buffer(stbi__context *s);

// initialize a memory-decode context
static void stbi__start_mem(stbi__context *s, stbi_uc const *buffer, int len)
{
   s->io.read = NULL;
   s->read_from_callbacks = 0;
   s->callback_already_read = 0;
   s->img_buffer = s->img_buffer_original = (stbi_uc *) buffer;
   s->img_buffer_end = s->img_buffer_original_end = (stbi_uc *) buffer+len;
}

// initialize a callback-based context
static void stbi__start_callbacks(stbi__context *s, stbi_io_callbacks *c, void *user)
{
   s->io = *c;
   s->io_user_data = user;
   s->buflen = sizeof(s->buffer_start);
   s->read_from_callbacks = 1;
   s->callback_already_read = 0;
   s->img_buffer = s->img_buffer_original = s->buffer_start;
   stbi__refill_buffer(s);
   s->img_buffer_original_end = s->img_buffer_end;
}

#ifndef STBI_NO_STDIO

static int stbi__stdio_read(void *user, char *data, int size)
{
   return (int) fread(data,1,size,(FILE*) user);
}

static void stbi__stdio_skip(void *user, int n)
{
   int ch;
   fseek((FILE*) user, n, SEEK_CUR);
   ch = fgetc((FILE*) user);  /* have to read a byte to reset feof()'s flag */
   if (ch != EOF) {
      ungetc(ch, (FILE *) user);  /* push byte back onto stream if valid. */
   }
}

static int stbi__stdio_eof(void *user)
{
   return feof((FILE*) user) || ferror((FILE *) user);
}

static stbi_io_callbacks stbi__stdio_callbacks =
{
   stbi__stdio_read,
   stbi__stdio_skip,
   stbi__stdio_eof,
};

static void stbi__start_file(stbi__context *s, FILE *f)
{
   stbi__start_callbacks(s, &stbi__stdio_callbacks, (void *) f);
}

//static void stop_file(stbi__context *s) { }

#endif // !STBI_NO_STDIO

static void stbi__rewind(stbi__context *s)
{
   // conceptually rewind SHOULD rewind to the beginning of the stream,
   // but we just rewind to the beginning of the initial buffer, because
   // we only use it after doing 'test', which only ever looks at at most 92 bytes
   s->img_buffer = s->img_buffer_original;
   s->img_buffer_end = s->img_buffer_original_end;
}

enum
{
   STBI_ORDER_RGB,
   STBI_ORDER_BGR
};

typedef struct
{
   int bits_per_channel;
   int num_channels;
   int channel_order;
} stbi__result_info;

#ifndef STBI_NO_JPEG
static int      stbi__jpeg_test(stbi__context *s);
static void    *stbi__jpeg_load(stbi__context *s, int *x, int *y, int *comp, int req_comp, stbi__result_info *ri);
static int      stbi__jpeg_info(stbi__context *s, int *x, int *y, int *comp);
#endif

#ifndef STBI_NO_PNG
static int      stbi__png_test(stbi__context *s);
static void    *stbi__png_load(stbi__context *s, int *x, int *y, int *comp, int req_comp, stbi__result_info *ri);
static int      stbi__png_info(stbi__context *s, int *x, int *y, int *comp);
static int      stbi__png_is16(stbi__context *s);
#endif

#ifndef STBI_NO_BMP
static int      stbi__bmp_test(stbi__context *s);
static void    *stbi__bmp_load(stbi__context *s, int *x, int *y, int *comp, int req_comp, stbi__result_info *ri);
static int      stbi__bmp_info(stbi__context *s, int *x, int *y, int *comp);
#endif

#ifndef STBI_NO_TGA
static int      stbi__tga_test(stbi__context *s);
static void    *stbi__tga_load(stbi__context *s, int *x, int *y, int *comp, int req_comp, stbi__result_info *ri);
static int      stbi__tga_info(stbi__context *s, int *x, int *y, int *comp);
#endif

#ifndef STBI_NO_PSD
static int      stbi__psd_test(stbi__context *s);
static void    *stbi__psd_load(stbi__context *s, int *x, int *y, int *comp, int req_comp, stbi__result_info *ri, int bpc);
static int      stbi__psd_info(stbi__context *s, int *x, int *y, int *comp);
static int      stbi__psd_is16(stbi__context *s);
#endif

#ifndef STBI_NO_HDR
static int      stbi__hdr_test(stbi__context *s);
static float   *stbi__hdr_load(stbi__context *s, int *x, int *y, int *comp, int req_comp, stbi__result_info *ri);
static int      stbi__hdr_info(stbi__context *s, int *x, int *y, int *comp);
#endif

#ifndef STBI_NO_PIC
static int      stbi__pic_test(stbi__context *s);
static void    *stbi__pic_load(stbi__context *s, int *x, int *y, int *comp, int req_comp, stbi__result_info *ri);
static int      stbi__pic_info(stbi__context *s, int *x, int *y, int *comp);
#endif

#ifndef STBI_NO_GIF
static int      stbi__gif_test(stbi__context *s);
static void    *stbi__gif_load(stbi__context *s, int *x, int *y, int *comp, int req_comp, stbi__result_info *ri);
static void    *stbi__load_gif_main(stbi__context *s, int **delays, int *x, int *y, int *z, int *comp, int req_comp);
static int      stbi__gif_info(stbi__context *s, int *x, int *y, int *comp);
#endif

#ifndef STBI_NO_PNM
static int      stbi__pnm_test(stbi__context *s);
static void    *stbi__pnm_load(stbi__context *s, int *x, int *y, int *comp, int req_comp, stbi__result_info *ri);
static int      stbi__pnm_info(stbi__context *s, int *x, int *y, int *comp);
static int      stbi__pnm_is16(stbi__context *s);
#endif

static
#ifdef STBI_THREAD_LOCAL
STBI_THREAD_LOCAL
#endif
const char *stbi__g_failure_reason;

STBIDEF const char *stbi_failure_reason(void)
{
   return stbi__g_failure_reason;
}

#ifndef STBI_NO_FAILURE_STRINGS
static int stbi__err(const char *str)
{
   stbi__g_failure_reason = str;
   return 0;
}
#endif

static void *stbi__malloc(size_t size)
{
    return STBI_MALLOC(size);
}

// stb_image uses ints pervasively, including for offset calculations.
// therefore the largest decoded image size we can support with the
// current code, even on 64-bit targets, is INT_MAX. this is not a
// significant limitation for the intended use case.
//
// we do, however, need to make sure our size calculations don't
// overflow. hence a few helper functions for size calculations that
// multiply integers together, making sure that they're non-negative
// and no overflow occurs.

// return 1 if the sum is valid, 0 on overflow.
// negative terms are considered invalid.
static int stbi__addsizes_valid(int a, int b)
{
   if (b < 0) return 0;
   // now 0 <= b <= INT_MAX, hence also
   // 0 <= INT_MAX - b <= INTMAX.
   // And "a + b <= INT_MAX" (which might overflow) is the
   // same as a <= INT_MAX - b (no overflow)
   return a <= INT_MAX - b;
}

// returns 1 if the product is valid, 0 on overflow.
// negative factors are considered invalid.
static int stbi__mul2sizes_valid(int a, int b)
{
   if (a < 0 || b < 0) return 0;
   if (b == 0) return 1; // mul-by-0 is always safe
   // portable way to check for no overflows in a*b
   return a <= INT_MAX/b;
}

#if !defined(STBI_NO_JPEG) || !defined(STBI_NO_PNG) || !defined(STBI_NO_TGA) || !defined(STBI_NO_HDR)
// returns 1 if "a*b + add" has no negative terms/factors and doesn't overflow
static int stbi__mad2sizes_valid(int a, int b, int add)
{
   return stbi__mul2sizes_valid(a, b) && stbi__addsizes_valid(a*b, add);
}
#endif

// returns 1 if "a*b*c + add" has no negative terms/factors and doesn't overflow
static int stbi__mad3sizes_valid(int a, int b, int c, int add)
{
   return stbi__mul2sizes_valid(a, b) && stbi__mul2sizes_valid(a*b, c) &&
      stbi__addsizes_valid(a*b*c, add);
}

// returns 1 if "a*b*c*d + add" has no negative terms/factors and doesn't overflow
#if !defined(STBI_NO_LINEAR) || !defined(STBI_NO_HDR) || !defined(STBI_NO_PNM)
static int stbi__mad4sizes_valid(int a, int b, int c, int d, int add)
{
   return stbi__mul2sizes_valid(a, b) && stbi__mul2sizes_valid(a*b, c) &&
      stbi__mul2sizes_valid(a*b*c, d) && stbi__addsizes_valid(a*b*c*d, add);
}
#endif

#if !defined(STBI_NO_JPEG) || !defined(STBI_NO_PNG) || !defined(STBI_NO_TGA) || !defined(STBI_NO_HDR)
// mallocs with size overflow checking
static void *stbi__malloc_mad2(int a, int b, int add)
{
   if (!stbi__mad2sizes_valid(a, b, add)) return NULL;
   return stbi__malloc(a*b + add);
}
#endif

static void *stbi__malloc_mad3(int a, int b, int c, int add)
{
   if (!stbi__mad3sizes_valid(a, b, c, add)) return NULL;
   return stbi__malloc(a*b*c + add);
}

#if !defined(STBI_NO_LINEAR) || !defined(STBI_NO_HDR) || !defined(STBI_NO_PNM)
static void *stbi__malloc_mad4(int a, int b, int c, int d, int add)
{
   if (!stbi__mad4sizes_valid(a, b, c, d, add)) return NULL;
   return stbi__malloc(a*b*c*d + add);
}
#endif

// stbi__err - error
// stbi__errpf - error returning pointer to float
// stbi__errpuc - error returning pointer to unsigned char

#ifdef STBI_NO_FAILURE_STRINGS
   #define stbi__err(x,y)  0
#elif defined(STBI_FAILURE_USERMSG)
   #define stbi__err(x,y)  stbi__err(y)
#else
   #define stbi__err(x,y)  stbi__err(x)
#endif

#define stbi__errpf(x,y)   ((float *)(size_t) (stbi__err(x,y)?NULL:NULL))
#define stbi__errpuc(x,y)  ((unsigned char *)(size_t) (stbi__err(x,y)?NULL:NULL))

STBIDEF void stbi_image_free(void *retval_from_stbi_load)
{
   STBI_FREE(retval_from_stbi_load);
}

#ifndef STBI_NO_LINEAR
static float   *stbi__ldr_to_hdr(stbi_uc *data, int x, int y, int comp);
#endif

#ifndef STBI_NO_HDR
static stbi_uc *stbi__hdr_to_ldr(float   *data, int x, int y, int comp);
#endif

static int stbi__vertically_flip_on_load_global = 0;

STBIDEF void stbi_set_flip_vertically_on_load(int flag_true_if_should_flip)
{
   stbi__vertically_flip_on_load_global = flag_true_if_should_flip;
}

#ifndef STBI_THREAD_LOCAL
#define stbi__vertically_flip_on_load  stbi__vertically_flip_on_load_global
#else
static STBI_THREAD_LOCAL int stbi__vertically_flip_on_load_local, stbi__vertically_flip_on_load_set;

STBIDEF void stbi_set_flip_vertically_on_load_thread(int flag_true_if_should_flip)
{
   stbi__vertically_flip_on_load_local = flag_true_if_should_flip;
   stbi__vertically_flip_on_load_set = 1;
}

#define stbi__vertically_flip_on_load  (stbi__vertically_flip_on_load_set       \
                                         ? stbi__vertically_flip_on_load_local  \
                                         : stbi__vertically_flip_on_load_global)
#endif // STBI_THREAD_LOCAL

static void *stbi__load_main(stbi__context *s, int *x, int *y, int *comp, int req_comp, stbi__result_info *ri, int bpc)
{
   memset(ri, 0, sizeof(*ri)); // make sure it's initialized if we add new fields
   ri->bits_per_channel = 8; // default is 8 so most paths don't have to be changed
   ri->channel_order = STBI_ORDER_RGB; // all current input & output are this, but this is here so we can add BGR order
   ri->num_channels = 0;

   // test the formats with a very explicit header first (at least a FOURCC
   // or distinctive magic number first)
   #ifndef STBI_NO_PNG
   if (stbi__png_test(s))  return stbi__png_load(s,x,y,comp,req_comp, ri);
   #endif
   #ifndef STBI_NO_BMP
   if (stbi__bmp_test(s))  return stbi__bmp_load(s,x,y,comp,req_comp, ri);
   #endif
   #ifndef STBI_NO_GIF
   if (stbi__gif_test(s))  return stbi__gif_load(s,x,y,comp,req_comp, ri);
   #endif
   #ifndef STBI_NO_PSD
   if (stbi__psd_test(s))  return stbi__psd_load(s,x,y,comp,req_comp, ri, bpc);
   #else
   STBI_NOTUSED(bpc);
   #endif
   #ifndef STBI_NO_PIC
   if (stbi__pic_test(s))  return stbi__pic_load(s,x,y,comp,req_comp, ri);
   #endif

   // then the formats that can end up attempting to load with just 1 or 2
   // bytes matching expectations; these are prone to false positives, so
   // try them later
   #ifndef STBI_NO_JPEG
   if (stbi__jpeg_test(s)) return stbi__jpeg_load(s,x,y,comp,req_comp, ri);
   #endif
   #ifndef STBI_NO_PNM
   if (stbi__pnm_test(s))  return stbi__pnm_load(s,x,y,comp,req_comp, ri);
   #endif

   #ifndef STBI_NO_HDR
   if (stbi__hdr_test(s)) {
      float *hdr = stbi__hdr_load(s, x,y,comp,req_comp, ri);
      return stbi__hdr_to_ldr(hdr, *x, *y, req_comp ? req_comp : *comp);
   }
   #endif

   #ifndef STBI_NO_TGA
   // test tga last because it's a crappy test!
   if (stbi__tga_test(s))
      return stbi__tga_load(s,x,y,comp,req_comp, ri);
   #endif

   return stbi__errpuc("unknown image type", "Image not of any known type, or corrupt");
}

static stbi_uc *stbi__convert_16_to_8(stbi__uint16 *orig, int w, int h, int channels)
{
   int i;
   int img_len = w * h * channels;
   stbi_uc *reduced;

   reduced = (stbi_uc *) stbi__malloc(img_len);
   if (reduced == NULL) return stbi__errpuc("outofmem", "Out of memory");

   for (i = 0; i < img_len; ++i)
      reduced[i] = (stbi_uc)((orig[i] >> 8) & 0xFF); // top half of each byte is sufficient approx of 16->8 bit scaling

   STBI_FREE(orig);
   return reduced;
}

static stbi__uint16 *stbi__convert_8_to_16(stbi_uc *orig, int w, int h, int channels)
{
   int i;
   int img_len = w * h * channels;
   stbi__uint16 *enlarged;

   enlarged = (stbi__uint16 *) stbi__malloc(img_len*2);
   if (enlarged == NULL) return (stbi__uint16 *) stbi__errpuc("outofmem", "Out of memory");

   for (i = 0; i < img_len; ++i)
      enlarged[i] = (stbi__uint16)((orig[i] << 8) + orig[i]); // replicate to high and low byte, maps 0->0, 255->0xffff

   STBI_FREE(orig);
   return enlarged;
}

static void stbi__vertical_flip(void *image, int w, int h, int bytes_per_pixel)
{
   int row;
   size_t bytes_per_row = (size_t)w * bytes_per_pixel;
   stbi_uc temp[2048];
   stbi_uc *bytes = (stbi_uc *)image;

   for (row = 0; row < (h>>1); row++) {
      stbi_uc *row0 = bytes + row*bytes_per_row;
      stbi_uc *row1 = bytes + (h - row - 1)*bytes_per_row;
      // swap row0 with row1
      size_t bytes_left = bytes_per_row;
      while (bytes_left) {
         size_t bytes_copy = (bytes_left < sizeof(temp)) ? bytes_left : sizeof(temp);
         memcpy(temp, row0, bytes_copy);
         memcpy(row0, row1, bytes_copy);
         memcpy(row1, temp, bytes_copy);
         row0 += bytes_copy;
         row1 += bytes_copy;
         bytes_left -= bytes_copy;
      }
   }
}

#ifndef STBI_NO_GIF
static void stbi__vertical_flip_slices(void *image, int w, int h, int z, int bytes_per_pixel)
{
   int slice;
   int slice_size = w * h * bytes_per_pixel;

   stbi_uc *bytes = (stbi_uc *)image;
   for (slice = 0; slice < z; ++slice) {
      stbi__vertical_flip(bytes, w, h, bytes_per_pixel);
      bytes += slice_size;
   }
}
#endif

static unsigned char *stbi__load_and_postprocess_8bit(stbi__context *s, int *x, int *y, int *comp, int req_comp)
{
   stbi__result_info ri;
   void *result = stbi__load_main(s, x, y, comp, req_comp, &ri, 8);

   if (result == NULL)
      return NULL;

   // it is the responsibility of the loaders to make sure we get either 8 or 16 bit.
   STBI_ASSERT(ri.bits_per_channel == 8 || ri.bits_per_channel == 16);

   if (ri.bits_per_channel != 8) {
      result = stbi__convert_16_to_8((stbi__uint16 *) result, *x, *y, req_comp == 0 ? *comp : req_comp);
      ri.bits_per_channel = 8;
   }

   // @TODO: move stbi__convert_format to here

   if (stbi__vertically_flip_on_load) {
      int channels = req_comp ? req_comp : *comp;
      stbi__vertical_flip(result, *x, *y, channels * sizeof(stbi_uc));
   }

   return (unsigned char *) result;
}

static stbi__uint16 *stbi__load_and_postprocess_16bit(stbi__context *s, int *x, int *y, int *comp, int req_comp)
{
   stbi__result_info ri;
   void *result = stbi__load_main(s, x, y, comp, req_comp, &ri, 16);

   if (result == NULL)
      return NULL;

   // it is the responsibility of the loaders to make sure we get either 8 or 16 bit.
   STBI_ASSERT(ri.bits_per_channel == 8 || ri.bits_per_channel == 16);

   if (ri.bits_per_channel != 16) {
      result = stbi__convert_8_to_16((stbi_uc *) result, *x, *y, req_comp == 0 ? *comp : req_comp);
      ri.bits_per_channel = 16;
   }

   // @TODO: move stbi__convert_format16 to here
   // @TODO: special case RGB-to-Y (and RGBA-to-YA) for 8-bit-to-16-bit case to keep more precision

   if (stbi__vertically_flip_on_load) {
      int channels = req_comp ? req_comp : *comp;
      stbi__vertical_flip(result, *x, *y, channels * sizeof(stbi__uint16));
   }

   return (stbi__uint16 *) result;
}

#if !defined(STBI_NO_HDR) && !defined(STBI_NO_LINEAR)
static void stbi__float_postprocess(float *result, int *x, int *y, int *comp, int req_comp)
{
   if (stbi__vertically_flip_on_load && result != NULL) {
      int channels = req_comp ? req_comp : *comp;
      stbi__vertical_flip(result, *x, *y, channels * sizeof(float));
   }
}
#endif

#ifndef STBI_NO_STDIO

#if defined(_WIN32) && defined(STBI_WINDOWS_UTF8)
STBI_EXTERN __declspec(dllimport) int __stdcall MultiByteToWideChar(unsigned int cp, unsigned long flags, const char *str, int cbmb, wchar_t *widestr, int cchwide);
STBI_EXTERN __declspec(dllimport) int __stdcall WideCharToMultiByte(unsigned int cp, unsigned long flags, const wchar_t *widestr, int cchwide, char *str, int cbmb, const char *defchar, int *used_default);
#endif

#if defined(_WIN32) && defined(STBI_WINDOWS_UTF8)
STBIDEF int stbi_convert_wchar_to_utf8(char *buffer, size_t bufferlen, const wchar_t* input)
{
	return WideCharToMultiByte(65001 /* UTF8 */, 0, input, -1, buffer, (int) bufferlen, NULL, NULL);
}
#endif

static FILE *stbi__fopen(char const *filename, char const *mode)
{
   FILE *f;
#if defined(_WIN32) && defined(STBI_WINDOWS_UTF8)
   wchar_t wMode[64];
   wchar_t wFilename[1024];
	if (0 == MultiByteToWideChar(65001 /* UTF8 */, 0, filename, -1, wFilename, sizeof(wFilename)/sizeof(*wFilename)))
      return 0;

	if (0 == MultiByteToWideChar(65001 /* UTF8 */, 0, mode, -1, wMode, sizeof(wMode)/sizeof(*wMode)))
      return 0;

#if defined(_MSC_VER) && _MSC_VER >= 1400
	if (0 != _wfopen_s(&f, wFilename, wMode))
		f = 0;
#else
   f = _wfopen(wFilename, wMode);
#endif

#elif defined(_MSC_VER) && _MSC_VER >= 1400
   if (0 != fopen_s(&f, filename, mode))
      f=0;
#else
   f = fopen(filename, mode);
#endif
   return f;
}


STBIDEF stbi_uc *stbi_load(char const *filename, int *x, int *y, int *comp, int req_comp)
{
   FILE *f = stbi__fopen(filename, "rb");
   unsigned char *result;
   if (!f) return stbi__errpuc("can't fopen", "Unable to open file");
   result = stbi_load_from_file(f,x,y,comp,req_comp);
   fclose(f);
   return result;
}

STBIDEF stbi_uc *stbi_load_from_file(FILE *f, int *x, int *y, int *comp, int req_comp)
{
   unsigned char *result;
   stbi__context s;
   stbi__start_file(&s,f);
   result = stbi__load_and_postprocess_8bit(&s,x,y,comp,req_comp);
   if (result) {
      // need to 'unget' all the characters in the IO buffer
      fseek(f, - (int) (s.img_buffer_end - s.img_buffer), SEEK_CUR);
   }
   return result;
}

STBIDEF stbi__uint16 *stbi_load_from_file_16(FILE *f, int *x, int *y, int *comp, int req_comp)
{
   stbi__uint16 *result;
   stbi__context s;
   stbi__start_file(&s,f);
   result = stbi__load_and_postprocess_16bit(&s,x,y,comp,req_comp);
   if (result) {
      // need to 'unget' all the characters in the IO buffer
      fseek(f, - (int) (s.img_buffer_end - s.img_buffer), SEEK_CUR);
   }
   return result;
}

STBIDEF stbi_us *stbi_load_16(char const *filename, int *x, int *y, int *comp, int req_comp)
{
   FILE *f = stbi__fopen(filename, "rb");
   stbi__uint16 *result;
   if (!f) return (stbi_us *) stbi__errpuc("can't fopen", "Unable to open file");
   result = stbi_load_from_file_16(f,x,y,comp,req_comp);
   fclose(f);
   return result;
}


#endif //!STBI_NO_STDIO

STBIDEF stbi_us *stbi_load_16_from_memory(stbi_uc const *buffer, int len, int *x, int *y, int *channels_in_file, int desired_channels)
{
   stbi__context s;
   stbi__start_mem(&s,buffer,len);
   return stbi__load_and_postprocess_16bit(&s,x,y,channels_in_file,desired_channels);
}

STBIDEF stbi_us *stbi_load_16_from_callbacks(stbi_io_callbacks const *clbk, void *user, int *x, int *y, int *channels_in_file, int desired_channels)
{
   stbi__context s;
   stbi__start_callbacks(&s, (stbi_io_callbacks *)clbk, user);
   return stbi__load_and_postprocess_16bit(&s,x,y,channels_in_file,desired_channels);
}

STBIDEF stbi_uc *stbi_load_from_memory(stbi_uc const *buffer, int len, int *x, int *y, int *comp, int req_comp)
{
   stbi__context s;
   stbi__start_mem(&s,buffer,len);
   return stbi__load_and_postprocess_8bit(&s,x,y,comp,req_comp);
}

STBIDEF stbi_uc *stbi_load_from_callbacks(stbi_io_callbacks const *clbk, void *user, int *x, int *y, int *comp, int req_comp)
{
   stbi__context s;
   stbi__start_callbacks(&s, (stbi_io_callbacks *) clbk, user);
   return stbi__load_and_postprocess_8bit(&s,x,y,comp,req_comp);
}

#ifndef STBI_NO_GIF
STBIDEF stbi_uc *stbi_load_gif_from_memory(stbi_uc const *buffer, int len, int **delays, int *x, int *y, int *z, int *comp, int req_comp)
{
   unsigned char *result;
   stbi__context s;
   stbi__start_mem(&s,buffer,len);

   result = (unsigned char*) stbi__load_gif_main(&s, delays, x, y, z, comp, req_comp);
   if (stbi__vertically_flip_on_load) {
      stbi__vertical_flip_slices( result, *x, *y, *z, *comp );
   }

   return result;
}
#endif

#ifndef STBI_NO_LINEAR
static float *stbi__loadf_main(stbi__context *s, int *x, int *y, int *comp, int req_comp)
{
   unsigned char *data;
   #ifndef STBI_NO_HDR
   if (stbi__hdr_test(s)) {
      stbi__result_info ri;
      float *hdr_data = stbi__hdr_load(s,x,y,comp,req_comp, &ri);
      if (hdr_data)
         stbi__float_postprocess(hdr_data,x,y,comp,req_comp);
      return hdr_data;
   }
   #endif
   data = stbi__load_and_postprocess_8bit(s, x, y, comp, req_comp);
   if (data)
      return stbi__ldr_to_hdr(data, *x, *y, req_comp ? req_comp : *comp);
   return stbi__errpf("unknown image type", "Image not of any known type, or corrupt");
}

STBIDEF float *stbi_loadf_from_memory(stbi_uc const *buffer, int len, int *x, int *y, int *comp, int req_comp)
{
   stbi__context s;
   stbi__start_mem(&s,buffer,len);
   return stbi__loadf_main(&s,x,y,comp,req_comp);
}

STBIDEF float *stbi_loadf_from_callbacks(stbi_io_callbacks const *clbk, void *user, int *x, int *y, int *comp, int req_comp)
{
   stbi__context s;
   stbi__start_callbacks(&s, (stbi_io_callbacks *) clbk, user);
   return stbi__loadf_main(&s,x,y,comp,req_comp);
}

#ifndef STBI_NO_STDIO
STBIDEF float *stbi_loadf(char const *filename, int *x, int *y, int *comp, int req_comp)
{
   float *result;
   FILE *f = stbi__fopen(filename, "rb");
   if (!f) return stbi__errpf("can't fopen", "Unable to open file");
   result = stbi_loadf_from_file(f,x,y,comp,req_comp);
   fclose(f);
   return result;
}

STBIDEF float *stbi_loadf_from_file(FILE *f, int *x, int *y, int *comp, int req_comp)
{
   stbi__context s;
   stbi__start_file(&s,f);
   return stbi__loadf_main(&s,x,y,comp,req_comp);
}
#endif // !STBI_NO_STDIO

#endif // !STBI_NO_LINEAR

// these is-hdr-or-not is defined independent of whether STBI_NO_LINEAR is
// defined, for API simplicity; if STBI_NO_LINEAR is defined, it always
// reports false!

STBIDEF int stbi_is_hdr_from_memory(stbi_uc const *buffer, int len)
{
   #ifndef STBI_NO_HDR
   stbi__context s;
   stbi__start_mem(&s,buffer,len);
   return stbi__hdr_test(&s);
   #else
   STBI_NOTUSED(buffer);
   STBI_NOTUSED(len);
   return 0;
   #endif
}

#ifndef STBI_NO_STDIO
STBIDEF int      stbi_is_hdr          (char const *filename)
{
   FILE *f = stbi__fopen(filename, "rb");
   int result=0;
   if (f) {
      result = stbi_is_hdr_from_file(f);
      fclose(f);
   }
   return result;
}

STBIDEF int stbi_is_hdr_from_file(FILE *f)
{
   #ifndef STBI_NO_HDR
   long pos = ftell(f);
   int res;
   stbi__context s;
   stbi__start_file(&s,f);
   res = stbi__hdr_test(&s);
   fseek(f, pos, SEEK_SET);
   return res;
   #else
   STBI_NOTUSED(f);
   return 0;
   #endif
}
#endif // !STBI_NO_STDIO

STBIDEF int      stbi_is_hdr_from_callbacks(stbi_io_callbacks const *clbk, void *user)
{
   #ifndef STBI_NO_HDR
   stbi__context s;
   stbi__start_callbacks(&s, (stbi_io_callbacks *) clbk, user);
   return stbi__hdr_test(&s);
   #else
   STBI_NOTUSED(clbk);
   STBI_NOTUSED(user);
   return 0;
   #endif
}

#ifndef STBI_NO_LINEAR
static float stbi__l2h_gamma=2.2f, stbi__l2h_scale=1.0f;

STBIDEF void   stbi_ldr_to_hdr_gamma(float gamma) { stbi__l2h_gamma = gamma; }
STBIDEF void   stbi_ldr_to_hdr_scale(float scale) { stbi__l2h_scale = scale; }
#endif

static float stbi__h2l_gamma_i=1.0f/2.2f, stbi__h2l_scale_i=1.0f;

STBIDEF void   stbi_hdr_to_ldr_gamma(float gamma) { stbi__h2l_gamma_i = 1/gamma; }
STBIDEF void   stbi_hdr_to_ldr_scale(float scale) { stbi__h2l_scale_i = 1/scale; }


//////////////////////////////////////////////////////////////////////////////
//
// Common code used by all image loaders
//

enum
{
   STBI__SCAN_load=0,
   STBI__SCAN_type,
   STBI__SCAN_header
};

static void stbi__refill_buffer(stbi__context *s)
{
   int n = (s->io.read)(s->io_user_data,(char*)s->buffer_start,s->buflen);
   s->callback_already_read += (int) (s->img_buffer - s->img_buffer_original);
   if (n == 0) {
      // at end of file, treat same as if from memory, but need to handle case
      // where s->img_buffer isn't pointing to safe memory, e.g. 0-byte file
      s->read_from_callbacks = 0;
      s->img_buffer = s->buffer_start;
      s->img_buffer_end = s->buffer_start+1;
      *s->img_buffer = 0;
   } else {
      s->img_buffer = s->buffer_start;
      s->img_buffer_end = s->buffer_start + n;
   }
}

stbi_inline static stbi_uc stbi__get8(stbi__context *s)
{
   if (s->img_buffer < s->img_buffer_end)
      return *s->img_buffer++;
   if (s->read_from_callbacks) {
      stbi__refill_buffer(s);
      return *s->img_buffer++;
   }
   return 0;
}

#if defined(STBI_NO_JPEG) && defined(STBI_NO_HDR) && defined(STBI_NO_PIC) && defined(STBI_NO_PNM)
// nothing
#else
stbi_inline static int stbi__at_eof(stbi__context *s)
{
   if (s->io.read) {
      if (!(s->io.eof)(s->io_user_data)) return 0;
      // if feof() is true, check if buffer = end
      // special case: we've only got the special 0 character at the end
      if (s->read_from_callbacks == 0) return 1;
   }

   return s->img_buffer >= s->img_buffer_end;
}
#endif

#if defined(STBI_NO_JPEG) && defined(STBI_NO_PNG) && defined(STBI_NO_BMP) && defined(STBI_NO_PSD) && defined(STBI_NO_TGA) && defined(STBI_NO_GIF) && defined(STBI_NO_PIC)
// nothing
#else
static void stbi__skip(stbi__context *s, int n)
{
   if (n == 0) return;  // already there!
   if (n < 0) {
      s->img_buffer = s->img_buffer_end;
      return;
   }
   if (s->io.read) {
      int blen = (int) (s->img_buffer_end - s->img_buffer);
      if (blen < n) {
         s->img_buffer = s->img_buffer_end;
         (s->io.skip)(s->io_user_data, n - blen);
         return;
      }
   }
   s->img_buffer += n;
}
#endif

#if defined(STBI_NO_PNG) && defined(STBI_NO_TGA) && defined(STBI_NO_HDR) && defined(STBI_NO_PNM)
// nothing
#else
static int stbi__getn(stbi__context *s, stbi_uc *buffer, int n)
{
   if (s->io.read) {
      int blen = (int) (s->img_buffer_end - s->img_buffer);
      if (blen < n) {
         int res, count;

         memcpy(buffer, s->img_buffer, blen);

         count = (s->io.read)(s->io_user_data, (char*) buffer + blen, n - blen);
         res = (count == (n-blen));
         s->img_buffer = s->img_buffer_end;
         return res;
      }
   }

   if (s->img_buffer+n <= s->img_buffer_end) {
      memcpy(buffer, s->img_buffer, n);
      s->img_buffer += n;
      return 1;
   } else
      return 0;
}
#endif

#if defined(STBI_NO_JPEG) && defined(STBI_NO_PNG) && defined(STBI_NO_PSD) && defined(STBI_NO_PIC)
// nothing
#else
static int stbi__get16be(stbi__context *s)
{
   int z = stbi__get8(s);
   return (z << 8) + stbi__get8(s);
}
#endif

#if defined(STBI_NO_PNG) && defined(STBI_NO_PSD) && defined(STBI_NO_PIC)
// nothing
#else
static stbi__uint32 stbi__get32be(stbi__context *s)
{
   stbi__uint32 z = stbi__get16be(s);
   return (z << 16) + stbi__get16be(s);
}
#endif

#if defined(STBI_NO_BMP) && defined(STBI_NO_TGA) && defined(STBI_NO_GIF)
// nothing
#else
static int stbi__get16le(stbi__context *s)
{
   int z = stbi__get8(s);
   return z + (stbi__get8(s) << 8);
}
#endif

#ifndef STBI_NO_BMP
static stbi__uint32 stbi__get32le(stbi__context *s)
{
   stbi__uint32 z = stbi__get16le(s);
   z += (stbi__uint32)stbi__get16le(s) << 16;
   return z;
}
#endif

#define STBI__BYTECAST(x)  ((stbi_uc) ((x) & 255))  // truncate int to byte without warnings

#if defined(STBI_NO_JPEG) && defined(STBI_NO_PNG) && defined(STBI_NO_BMP) && defined(STBI_NO_PSD) && defined(STBI_NO_TGA) && defined(STBI_NO_GIF) && defined(STBI_NO_PIC) && defined(STBI_NO_PNM)
// nothing
#else
//////////////////////////////////////////////////////////////////////////////
//
//  generic converter from built-in img_n to req_comp
//    individual types do this automatically as much as possible (e.g. jpeg
//    does all cases internally since it needs to colorspace convert anyway,
//    and it never has alpha, so very few cases ). png can automatically
//    interleave an alpha=255 channel, but falls back to this for other cases
//
//  assume data buffer is malloced, so malloc a new one and free that one
//  only failure mode is malloc failing

static stbi_uc stbi__compute_y(int r, int g, int b)
{
   return (stbi_uc) (((r*77) + (g*150) +  (29*b)) >> 8);
}
#endif

#if defined(STBI_NO_PNG) && defined(STBI_NO_BMP) && defined(STBI_NO_PSD) && defined(STBI_NO_TGA) && defined(STBI_NO_GIF) && defined(STBI_NO_PIC) && defined(STBI_NO_PNM)
// nothing
#else
static unsigned char *stbi__convert_format(unsigned char *data, int img_n, int req_comp, unsigned int x, unsigned int y)
{
   int i,j;
   unsigned char *good;

   if (req_comp == img_n) return data;
   STBI_ASSERT(req_comp >= 1 && req_comp <= 4);

   good = (unsigned char *) stbi__malloc_mad3(req_comp, x, y, 0);
   if (good == NULL) {
      STBI_FREE(data);
      return stbi__errpuc("outofmem", "Out of memory");
   }

   for (j=0; j < (int) y; ++j) {
      unsigned char *src  = data + j * x * img_n   ;
      unsigned char *dest = good + j * x * req_comp;

      #define STBI__COMBO(a,b)  ((a)*8+(b))
      #define STBI__CASE(a,b)   case STBI__COMBO(a,b): for(i=x-1; i >= 0; --i, src += a, dest += b)
      // convert source image with img_n components to one with req_comp components;
      // avoid switch per pixel, so use switch per scanline and massive macros
      switch (STBI__COMBO(img_n, req_comp)) {
         STBI__CASE(1,2) { dest[0]=src[0]; dest[1]=255;                                     } break;
         STBI__CASE(1,3) { dest[0]=dest[1]=dest[2]=src[0];                                  } break;
         STBI__CASE(1,4) { dest[0]=dest[1]=dest[2]=src[0]; dest[3]=255;                     } break;
         STBI__CASE(2,1) { dest[0]=src[0];                                                  } break;
         STBI__CASE(2,3) { dest[0]=dest[1]=dest[2]=src[0];                                  } break;
         STBI__CASE(2,4) { dest[0]=dest[1]=dest[2]=src[0]; dest[3]=src[1];                  } break;
         STBI__CASE(3,4) { dest[0]=src[0];dest[1]=src[1];dest[2]=src[2];dest[3]=255;        } break;
         STBI__CASE(3,1) { dest[0]=stbi__compute_y(src[0],src[1],src[2]);                   } break;
         STBI__CASE(3,2) { dest[0]=stbi__compute_y(src[0],src[1],src[2]); dest[1] = 255;    } break;
         STBI__CASE(4,1) { dest[0]=stbi__compute_y(src[0],src[1],src[2]);                   } break;
         STBI__CASE(4,2) { dest[0]=stbi__compute_y(src[0],src[1],src[2]); dest[1] = src[3]; } break;
         STBI__CASE(4,3) { dest[0]=src[0];dest[1]=src[1];dest[2]=src[2];                    } break;
         default: STBI_ASSERT(0); STBI_FREE(data); STBI_FREE(good); return stbi__errpuc("unsupported", "Unsupported format conversion");
      }
      #undef STBI__CASE
   }

   STBI_FREE(data);
   return good;
}
#endif

#if defined(STBI_NO_PNG) && defined(STBI_NO_PSD)
// nothing
#else
static stbi__uint16 stbi__compute_y_16(int r, int g, int b)
{
   return (stbi__uint16) (((r*77) + (g*150) +  (29*b)) >> 8);
}
#endif

#if defined(STBI_NO_PNG) && defined(STBI_NO_PSD)
// nothing
#else
static stbi__uint16 *stbi__convert_format16(stbi__uint16 *data, int img_n, int req_comp, unsigned int x, unsigned int y)
{
   int i,j;
   stbi__uint16 *good;

   if (req_comp == img_n) return data;
   STBI_ASSERT(req_comp >= 1 && req_comp <= 4);

   good = (stbi__uint16 *) stbi__malloc(req_comp * x * y * 2);
   if (good == NULL) {
      STBI_FREE(data);
      return (stbi__uint16 *) stbi__errpuc("outofmem", "Out of memory");
   }

   for (j=0; j < (int) y; ++j) {
      stbi__uint16 *src  = data + j * x * img_n   ;
      stbi__uint16 *dest = good + j * x * req_comp;

      #define STBI__COMBO(a,b)  ((a)*8+(b))
      #define STBI__CASE(a,b)   case STBI__COMBO(a,b): for(i=x-1; i >= 0; --i, src += a, dest += b)
      // convert source image with img_n components to one with req_comp components;
      // avoid switch per pixel, so use switch per scanline and massive macros
      switch (STBI__COMBO(img_n, req_comp)) {
         STBI__CASE(1,2) { dest[0]=src[0]; dest[1]=0xffff;                                     } break;
         STBI__CASE(1,3) { dest[0]=dest[1]=dest[2]=src[0];                                     } break;
         STBI__CASE(1,4) { dest[0]=dest[1]=dest[2]=src[0]; dest[3]=0xffff;                     } break;
         STBI__CASE(2,1) { dest[0]=src[0];                                                     } break;
         STBI__CASE(2,3) { dest[0]=dest[1]=dest[2]=src[0];                                     } break;
         STBI__CASE(2,4) { dest[0]=dest[1]=dest[2]=src[0]; dest[3]=src[1];                     } break;
         STBI__CASE(3,4) { dest[0]=src[0];dest[1]=src[1];dest[2]=src[2];dest[3]=0xffff;        } break;
         STBI__CASE(3,1) { dest[0]=stbi__compute_y_16(src[0],src[1],src[2]);                   } break;
         STBI__CASE(3,2) { dest[0]=stbi__compute_y_16(src[0],src[1],src[2]); dest[1] = 0xffff; } break;
         STBI__CASE(4,1) { dest[0]=stbi__compute_y_16(src[0],src[1],src[2]);                   } break;
         STBI__CASE(4,2) { dest[0]=stbi__compute_y_16(src[0],src[1],src[2]); dest[1] = src[3]; } break;
         STBI__CASE(4,3) { dest[0]=src[0];dest[1]=src[1];dest[2]=src[2];                       } break;
         default: STBI_ASSERT(0); STBI_FREE(data); STBI_FREE(good); return (stbi__uint16*) stbi__errpuc("unsupported", "Unsupported format conversion");
      }
      #undef STBI__CASE
   }

   STBI_FREE(data);
   return good;
}
#endif

#ifndef STBI_NO_LINEAR
static float   *stbi__ldr_to_hdr(stbi_uc *data, int x, int y, int comp)
{
   int i,k,n;
   float *output;
   if (!data) return NULL;
   output = (float *) stbi__malloc_mad4(x, y, comp, sizeof(float), 0);
   if (output == NULL) { STBI_FREE(data); return stbi__errpf("outofmem", "Out of memory"); }
   // compute number of non-alpha components
   if (comp & 1) n = comp; else n = comp-1;
   for (i=0; i < x*y; ++i) {
      for (k=0; k < n; ++k) {
         output[i*comp + k] = (float) (pow(data[i*comp+k]/255.0f, stbi__l2h_gamma) * stbi__l2h_scale);
      }
   }
   if (n < comp) {
      for (i=0; i < x*y; ++i) {
         output[i*comp + n] = data[i*comp + n]/255.0f;
      }
   }
   STBI_FREE(data);
   return output;
}
#endif

#ifndef STBI_NO_HDR
#define stbi__float2int(x)   ((int) (x))
static stbi_uc *stbi__hdr_to_ldr(float   *data, int x, int y, int comp)
{
   int i,k,n;
   stbi_uc *output;
   if (!data) return NULL;
   output = (stbi_uc *) stbi__malloc_mad3(x, y, comp, 0);
   if (output == NULL) { STBI_FREE(data); return stbi__errpuc("outofmem", "Out of memory"); }
   // compute number of non-alpha components
   if (comp & 1) n = comp; else n = comp-1;
   for (i=0; i < x*y; ++i) {
      for (k=0; k < n; ++k) {
         float z = (float) pow(data[i*comp+k]*stbi__h2l_scale_i, stbi__h2l_gamma_i) * 255 + 0.5f;
         if (z < 0) z = 0;
         if (z > 255) z = 255;
         output[i*comp + k] = (stbi_uc) stbi__float2int(z);
      }
      if (k < comp) {
         float z = data[i*comp+k] * 255 + 0.5f;
         if (z < 0) z = 0;
         if (z > 255) z = 255;
         output[i*comp + k] = (stbi_uc) stbi__float2int(z);
      }
   }
   STBI_FREE(data);
   return output;
}
#endif

//////////////////////////////////////////////////////////////////////////////
//
//  "baseline" JPEG/JFIF decoder
//
//    simple implementation
//      - doesn't support delayed output of y-dimension
//      - simple interface (only one output format: 8-bit interleaved RGB)
//      - doesn't try to recover corrupt jpegs
//      - doesn't allow partial loading, loading multiple at once
//      - still fast on x86 (copying globals into locals doesn't help x86)
//      - allocates lots of intermediate memory (full size of all components)
//        - non-interleaved case requires this anyway
//        - allows good upsampling (see next)
//    high-quality
//      - upsampled channels are bilinearly interpolated, even across blocks
//      - quality integer IDCT derived from IJG's 'slow'
//    performance
//      - fast huffman; reasonable integer IDCT
//      - some SIMD kernels for common paths on targets with SSE2/NEON
//      - uses a lot of intermediate memory, could cache poorly

#ifndef STBI_NO_JPEG

// huffman decoding acceleration
#define FAST_BITS   9  // larger handles more cases; smaller stomps less cache

typedef struct
{
   stbi_uc  fast[1 << FAST_BITS];
   // weirdly, repacking this into AoS is a 10% speed loss, instead of a win
   stbi__uint16 code[256];
   stbi_uc  values[256];
   stbi_uc  size[257];
   unsigned int maxcode[18];
   int    delta[17];   // old 'firstsymbol' - old 'firstcode'
} stbi__huffman;

typedef struct
{
   stbi__context *s;
   stbi__huffman huff_dc[4];
   stbi__huffman huff_ac[4];
   stbi__uint16 dequant[4][64];
   stbi__int16 fast_ac[4][1 << FAST_BITS];

// sizes for components, interleaved MCUs
   int img_h_max, img_v_max;
   int img_mcu_x, img_mcu_y;
   int img_mcu_w, img_mcu_h;

// definition of jpeg image component
   struct
   {
      int id;
      int h,v;
      int tq;
      int hd,ha;
      int dc_pred;

      int x,y,w2,h2;
      stbi_uc *data;
      void *raw_data, *raw_coeff;
      stbi_uc *linebuf;
      short   *coeff;   // progressive only
      int      coeff_w, coeff_h; // number of 8x8 coefficient blocks
   } img_comp[4];

   stbi__uint32   code_buffer; // jpeg entropy-coded buffer
   int            code_bits;   // number of valid bits
   unsigned char  marker;      // marker seen while filling entropy buffer
   int            nomore;      // flag if we saw a marker so must stop

   int            progressive;
   int            spec_start;
   int            spec_end;
   int            succ_high;
   int            succ_low;
   int            eob_run;
   int            jfif;
   int            app14_color_transform; // Adobe APP14 tag
   int            rgb;

   int scan_n, order[4];
   int restart_interval, todo;

// kernels
   void (*idct_block_kernel)(stbi_uc *out, int out_stride, short data[64]);
   void (*YCbCr_to_RGB_kernel)(stbi_uc *out, const stbi_uc *y, const stbi_uc *pcb, const stbi_uc *pcr, int count, int step);
   stbi_uc *(*resample_row_hv_2_kernel)(stbi_uc *out, stbi_uc *in_near, stbi_uc *in_far, int w, int hs);
} stbi__jpeg;

static int stbi__build_huffman(stbi__huffman *h, int *count)
{
   int i,j,k=0;
   unsigned int code;
   // build size list for each symbol (from JPEG spec)
   for (i=0; i < 16; ++i)
      for (j=0; j < count[i]; ++j)
         h->size[k++] = (stbi_uc) (i+1);
   h->size[k] = 0;

   // compute actual symbols (from jpeg spec)
   code = 0;
   k = 0;
   for(j=1; j <= 16; ++j) {
      // compute delta to add to code to compute symbol id
      h->delta[j] = k - code;
      if (h->size[k] == j) {
         while (h->size[k] == j)
            h->code[k++] = (stbi__uint16) (code++);
         if (code-1 >= (1u << j)) return stbi__err("bad code lengths","Corrupt JPEG");
      }
      // compute largest code + 1 for this size, preshifted as needed later
      h->maxcode[j] = code << (16-j);
      code <<= 1;
   }
   h->maxcode[j] = 0xffffffff;

   // build non-spec acceleration table; 255 is flag for not-accelerated
   memset(h->fast, 255, 1 << FAST_BITS);
   for (i=0; i < k; ++i) {
      int s = h->size[i];
      if (s <= FAST_BITS) {
         int c = h->code[i] << (FAST_BITS-s);
         int m = 1 << (FAST_BITS-s);
         for (j=0; j < m; ++j) {
            h->fast[c+j] = (stbi_uc) i;
         }
      }
   }
   return 1;
}

// build a table that decodes both magnitude and value of small ACs in
// one go.
static void stbi__build_fast_ac(stbi__int16 *fast_ac, stbi__huffman *h)
{
   int i;
   for (i=0; i < (1 << FAST_BITS); ++i) {
      stbi_uc fast = h->fast[i];
      fast_ac[i] = 0;
      if (fast < 255) {
         int rs = h->values[fast];
         int run = (rs >> 4) & 15;
         int magbits = rs & 15;
         int len = h->size[fast];

         if (magbits && len + magbits <= FAST_BITS) {
            // magnitude code followed by receive_extend code
            int k = ((i << len) & ((1 << FAST_BITS) - 1)) >> (FAST_BITS - magbits);
            int m = 1 << (magbits - 1);
            if (k < m) k += (~0U << magbits) + 1;
            // if the result is small enough, we can fit it in fast_ac table
            if (k >= -128 && k <= 127)
               fast_ac[i] = (stbi__int16) ((k * 256) + (run * 16) + (len + magbits));
         }
      }
   }
}

static void stbi__grow_buffer_unsafe(stbi__jpeg *j)
{
   do {
      unsigned int b = j->nomore ? 0 : stbi__get8(j->s);
      if (b == 0xff) {
         int c = stbi__get8(j->s);
         while (c == 0xff) c = stbi__get8(j->s); // consume fill bytes
         if (c != 0) {
            j->marker = (unsigned char) c;
            j->nomore = 1;
            return;
         }
      }
      j->code_buffer |= b << (24 - j->code_bits);
      j->code_bits += 8;
   } while (j->code_bits <= 24);
}

// (1 << n) - 1
static const stbi__uint32 stbi__bmask[17]={0,1,3,7,15,31,63,127,255,511,1023,2047,4095,8191,16383,32767,65535};

// decode a jpeg huffman value from the bitstream
stbi_inline static int stbi__jpeg_huff_decode(stbi__jpeg *j, stbi__huffman *h)
{
   unsigned int temp;
   int c,k;

   if (j->code_bits < 16) stbi__grow_buffer_unsafe(j);

   // look at the top FAST_BITS and determine what symbol ID it is,
   // if the code is <= FAST_BITS
   c = (j->code_buffer >> (32 - FAST_BITS)) & ((1 << FAST_BITS)-1);
   k = h->fast[c];
   if (k < 255) {
      int s = h->size[k];
      if (s > j->code_bits)
         return -1;
      j->code_buffer <<= s;
      j->code_bits -= s;
      return h->values[k];
   }

   // naive test is to shift the code_buffer down so k bits are
   // valid, then test against maxcode. To speed this up, we've
   // preshifted maxcode left so that it has (16-k) 0s at the
   // end; in other words, regardless of the number of bits, it
   // wants to be compared against something shifted to have 16;
   // that way we don't need to shift inside the loop.
   temp = j->code_buffer >> 16;
   for (k=FAST_BITS+1 ; ; ++k)
      if (temp < h->maxcode[k])
         break;
   if (k == 17) {
      // error! code not found
      j->code_bits -= 16;
      return -1;
   }

   if (k > j->code_bits)
      return -1;

   // convert the huffman code to the symbol id
   c = ((j->code_buffer >> (32 - k)) & stbi__bmask[k]) + h->delta[k];
   STBI_ASSERT((((j->code_buffer) >> (32 - h->size[c])) & stbi__bmask[h->size[c]]) == h->code[c]);

   // convert the id to a symbol
   j->code_bits -= k;
   j->code_buffer <<= k;
   return h->values[c];
}

// bias[n] = (-1<<n) + 1
static const int stbi__jbias[16] = {0,-1,-3,-7,-15,-31,-63,-127,-255,-511,-1023,-2047,-4095,-8191,-16383,-32767};

// combined JPEG 'receive' and JPEG 'extend', since baseline
// always extends everything it receives.
stbi_inline static int stbi__extend_receive(stbi__jpeg *j, int n)
{
   unsigned int k;
   int sgn;
   if (j->code_bits < n) stbi__grow_buffer_unsafe(j);

   sgn = j->code_buffer >> 31; // sign bit always in MSB; 0 if MSB clear (positive), 1 if MSB set (negative)
   k = stbi_lrot(j->code_buffer, n);
   j->code_buffer = k & ~stbi__bmask[n];
   k &= stbi__bmask[n];
   j->code_bits -= n;
   return k + (stbi__jbias[n] & (sgn - 1));
}

// get some unsigned bits
stbi_inline static int stbi__jpeg_get_bits(stbi__jpeg *j, int n)
{
   unsigned int k;
   if (j->code_bits < n) stbi__grow_buffer_unsafe(j);
   k = stbi_lrot(j->code_buffer, n);
   j->code_buffer = k & ~stbi__bmask[n];
   k &= stbi__bmask[n];
   j->code_bits -= n;
   return k;
}

stbi_inline static int stbi__jpeg_get_bit(stbi__jpeg *j)
{
   unsigned int k;
   if (j->code_bits < 1) stbi__grow_buffer_unsafe(j);
   k = j->code_buffer;
   j->code_buffer <<= 1;
   --j->code_bits;
   return k & 0x80000000;
}

// given a value that's at position X in the zigzag stream,
// where does it appear in the 8x8 matrix coded as row-major?
static const stbi_uc stbi__jpeg_dezigzag[64+15] =
{
    0,  1,  8, 16,  9,  2,  3, 10,
   17, 24, 32, 25, 18, 11,  4,  5,
   12, 19, 26, 33, 40, 48, 41, 34,
   27, 20, 13,  6,  7, 14, 21, 28,
   35, 42, 49, 56, 57, 50, 43, 36,
   29, 22, 15, 23, 30, 37, 44, 51,
   58, 59, 52, 45, 38, 31, 39, 46,
   53, 60, 61, 54, 47, 55, 62, 63,
   // let corrupt input sample past end
   63, 63, 63, 63, 63, 63, 63, 63,
   63, 63, 63, 63, 63, 63, 63
};

// decode one 64-entry block--
static int stbi__jpeg_decode_block(stbi__jpeg *j, short data[64], stbi__huffman *hdc, stbi__huffman *hac, stbi__int16 *fac, int b, stbi__uint16 *dequant)
{
   int diff,dc,k;
   int t;

   if (j->code_bits < 16) stbi__grow_buffer_unsafe(j);
   t = stbi__jpeg_huff_decode(j, hdc);
   if (t < 0 || t > 15) return stbi__err("bad huffman code","Corrupt JPEG");

   // 0 all the ac values now so we can do it 32-bits at a time
   memset(data,0,64*sizeof(data[0]));

   diff = t ? stbi__extend_receive(j, t) : 0;
   dc = j->img_comp[b].dc_pred + diff;
   j->img_comp[b].dc_pred = dc;
   data[0] = (short) (dc * dequant[0]);

   // decode AC components, see JPEG spec
   k = 1;
   do {
      unsigned int zig;
      int c,r,s;
      if (j->code_bits < 16) stbi__grow_buffer_unsafe(j);
      c = (j->code_buffer >> (32 - FAST_BITS)) & ((1 << FAST_BITS)-1);
      r = fac[c];
      if (r) { // fast-AC path
         k += (r >> 4) & 15; // run
         s = r & 15; // combined length
         j->code_buffer <<= s;
         j->code_bits -= s;
         // decode into unzigzag'd location
         zig = stbi__jpeg_dezigzag[k++];
         data[zig] = (short) ((r >> 8) * dequant[zig]);
      } else {
         int rs = stbi__jpeg_huff_decode(j, hac);
         if (rs < 0) return stbi__err("bad huffman code","Corrupt JPEG");
         s = rs & 15;
         r = rs >> 4;
         if (s == 0) {
            if (rs != 0xf0) break; // end block
            k += 16;
         } else {
            k += r;
            // decode into unzigzag'd location
            zig = stbi__jpeg_dezigzag[k++];
            data[zig] = (short) (stbi__extend_receive(j,s) * dequant[zig]);
         }
      }
   } while (k < 64);
   return 1;
}

static int stbi__jpeg_decode_block_prog_dc(stbi__jpeg *j, short data[64], stbi__huffman *hdc, int b)
{
   int diff,dc;
   int t;
   if (j->spec_end != 0) return stbi__err("can't merge dc and ac", "Corrupt JPEG");

   if (j->code_bits < 16) stbi__grow_buffer_unsafe(j);

   if (j->succ_high == 0) {
      // first scan for DC coefficient, must be first
      memset(data,0,64*sizeof(data[0])); // 0 all the ac values now
      t = stbi__jpeg_huff_decode(j, hdc);
      if (t < 0 || t > 15) return stbi__err("can't merge dc and ac", "Corrupt JPEG");
      diff = t ? stbi__extend_receive(j, t) : 0;

      dc = j->img_comp[b].dc_pred + diff;
      j->img_comp[b].dc_pred = dc;
      data[0] = (short) (dc * (1 << j->succ_low));
   } else {
      // refinement scan for DC coefficient
      if (stbi__jpeg_get_bit(j))
         data[0] += (short) (1 << j->succ_low);
   }
   return 1;
}

// @OPTIMIZE: store non-zigzagged during the decode passes,
// and only de-zigzag when dequantizing
static int stbi__jpeg_decode_block_prog_ac(stbi__jpeg *j, short data[64], stbi__huffman *hac, stbi__int16 *fac)
{
   int k;
   if (j->spec_start == 0) return stbi__err("can't merge dc and ac", "Corrupt JPEG");

   if (j->succ_high == 0) {
      int shift = j->succ_low;

      if (j->eob_run) {
         --j->eob_run;
         return 1;
      }

      k = j->spec_start;
      do {
         unsigned int zig;
         int c,r,s;
         if (j->code_bits < 16) stbi__grow_buffer_unsafe(j);
         c = (j->code_buffer >> (32 - FAST_BITS)) & ((1 << FAST_BITS)-1);
         r = fac[c];
         if (r) { // fast-AC path
            k += (r >> 4) & 15; // run
            s = r & 15; // combined length
            j->code_buffer <<= s;
            j->code_bits -= s;
            zig = stbi__jpeg_dezigzag[k++];
            data[zig] = (short) ((r >> 8) * (1 << shift));
         } else {
            int rs = stbi__jpeg_huff_decode(j, hac);
            if (rs < 0) return stbi__err("bad huffman code","Corrupt JPEG");
            s = rs & 15;
            r = rs >> 4;
            if (s == 0) {
               if (r < 15) {
                  j->eob_run = (1 << r);
                  if (r)
                     j->eob_run += stbi__jpeg_get_bits(j, r);
                  --j->eob_run;
                  break;
               }
               k += 16;
            } else {
               k += r;
               zig = stbi__jpeg_dezigzag[k++];
               data[zig] = (short) (stbi__extend_receive(j,s) * (1 << shift));
            }
         }
      } while (k <= j->spec_end);
   } else {
      // refinement scan for these AC coefficients

      short bit = (short) (1 << j->succ_low);

      if (j->eob_run) {
         --j->eob_run;
         for (k = j->spec_start; k <= j->spec_end; ++k) {
            short *p = &data[stbi__jpeg_dezigzag[k]];
            if (*p != 0)
               if (stbi__jpeg_get_bit(j))
                  if ((*p & bit)==0) {
                     if (*p > 0)
                        *p += bit;
                     else
                        *p -= bit;
                  }
         }
      } else {
         k = j->spec_start;
         do {
            int r,s;
            int rs = stbi__jpeg_huff_decode(j, hac); // @OPTIMIZE see if we can use the fast path here, advance-by-r is so slow, eh
            if (rs < 0) return stbi__err("bad huffman code","Corrupt JPEG");
            s = rs & 15;
            r = rs >> 4;
            if (s == 0) {
               if (r < 15) {
                  j->eob_run = (1 << r) - 1;
                  if (r)
                     j->eob_run += stbi__jpeg_get_bits(j, r);
                  r = 64; // force end of block
               } else {
                  // r=15 s=0 should write 16 0s, so we just do
                  // a run of 15 0s and then write s (which is 0),
                  // so we don't have to do anything special here
               }
            } else {
               if (s != 1) return stbi__err("bad huffman code", "Corrupt JPEG");
               // sign bit
               if (stbi__jpeg_get_bit(j))
                  s = bit;
               else
                  s = -bit;
            }

            // advance by r
            while (k <= j->spec_end) {
               short *p = &data[stbi__jpeg_dezigzag[k++]];
               if (*p != 0) {
                  if (stbi__jpeg_get_bit(j))
                     if ((*p & bit)==0) {
                        if (*p > 0)
                           *p += bit;
                        else
                           *p -= bit;
                     }
               } else {
                  if (r == 0) {
                     *p = (short) s;
                     break;
                  }
                  --r;
               }
            }
         } while (k <= j->spec_end);
      }
   }
   return 1;
}

// take a -128..127 value and stbi__clamp it and convert to 0..255
stbi_inline static stbi_uc stbi__clamp(int x)
{
   // trick to use a single test to catch both cases
   if ((unsigned int) x > 255) {
      if (x < 0) return 0;
      if (x > 255) return 255;
   }
   return (stbi_uc) x;
}

#define stbi__f2f(x)  ((int) (((x) * 4096 + 0.5)))
#define stbi__fsh(x)  ((x) * 4096)

// derived from jidctint -- DCT_ISLOW
#define STBI__IDCT_1D(s0,s1,s2,s3,s4,s5,s6,s7) \
   int t0,t1,t2,t3,p1,p2,p3,p4,p5,x0,x1,x2,x3; \
   p2 = s2;                                    \
   p3 = s6;                                    \
   p1 = (p2+p3) * stbi__f2f(0.5411961f);       \
   t2 = p1 + p3*stbi__f2f(-1.847759065f);      \
   t3 = p1 + p2*stbi__f2f( 0.765366865f);      \
   p2 = s0;                                    \
   p3 = s4;                                    \
   t0 = stbi__fsh(p2+p3);                      \
   t1 = stbi__fsh(p2-p3);                      \
   x0 = t0+t3;                                 \
   x3 = t0-t3;                                 \
   x1 = t1+t2;                                 \
   x2 = t1-t2;                                 \
   t0 = s7;                                    \
   t1 = s5;                                    \
   t2 = s3;                                    \
   t3 = s1;                                    \
   p3 = t0+t2;                                 \
   p4 = t1+t3;                                 \
   p1 = t0+t3;                                 \
   p2 = t1+t2;                                 \
   p5 = (p3+p4)*stbi__f2f( 1.175875602f);      \
   t0 = t0*stbi__f2f( 0.298631336f);           \
   t1 = t1*stbi__f2f( 2.053119869f);           \
   t2 = t2*stbi__f2f( 3.072711026f);           \
   t3 = t3*stbi__f2f( 1.501321110f);           \
   p1 = p5 + p1*stbi__f2f(-0.899976223f);      \
   p2 = p5 + p2*stbi__f2f(-2.562915447f);      \
   p3 = p3*stbi__f2f(-1.961570560f);           \
   p4 = p4*stbi__f2f(-0.390180644f);           \
   t3 += p1+p4;                                \
   t2 += p2+p3;                                \
   t1 += p2+p4;                                \
   t0 += p1+p3;

static void stbi__idct_block(stbi_uc *out, int out_stride, short data[64])
{
   int i,val[64],*v=val;
   stbi_uc *o;
   short *d = data;

   // columns
   for (i=0; i < 8; ++i,++d, ++v) {
      // if all zeroes, shortcut -- this avoids dequantizing 0s and IDCTing
      if (d[ 8]==0 && d[16]==0 && d[24]==0 && d[32]==0
           && d[40]==0 && d[48]==0 && d[56]==0) {
         //    no shortcut                 0     seconds
         //    (1|2|3|4|5|6|7)==0          0     seconds
         //    all separate               -0.047 seconds
         //    1 && 2|3 && 4|5 && 6|7:    -0.047 seconds
         int dcterm = d[0]*4;
         v[0] = v[8] = v[16] = v[24] = v[32] = v[40] = v[48] = v[56] = dcterm;
      } else {
         STBI__IDCT_1D(d[ 0],d[ 8],d[16],d[24],d[32],d[40],d[48],d[56])
         // constants scaled things up by 1<<12; let's bring them back
         // down, but keep 2 extra bits of precision
         x0 += 512; x1 += 512; x2 += 512; x3 += 512;
         v[ 0] = (x0+t3) >> 10;
         v[56] = (x0-t3) >> 10;
         v[ 8] = (x1+t2) >> 10;
         v[48] = (x1-t2) >> 10;
         v[16] = (x2+t1) >> 10;
         v[40] = (x2-t1) >> 10;
         v[24] = (x3+t0) >> 10;
         v[32] = (x3-t0) >> 10;
      }
   }

   for (i=0, v=val, o=out; i < 8; ++i,v+=8,o+=out_stride) {
      // no fast case since the first 1D IDCT spread components out
      STBI__IDCT_1D(v[0],v[1],v[2],v[3],v[4],v[5],v[6],v[7])
      // constants scaled things up by 1<<12, plus we had 1<<2 from first
      // loop, plus horizontal and vertical each scale by sqrt(8) so together
      // we've got an extra 1<<3, so 1<<17 total we need to remove.
      // so we want to round that, which means adding 0.5 * 1<<17,
      // aka 65536. Also, we'll end up with -128 to 127 that we want
      // to encode as 0..255 by adding 128, so we'll add that before the shift
      x0 += 65536 + (128<<17);
      x1 += 65536 + (128<<17);
      x2 += 65536 + (128<<17);
      x3 += 65536 + (128<<17);
      // tried computing the shifts into temps, or'ing the temps to see
      // if any were out of range, but that was slower
      o[0] = stbi__clamp((x0+t3) >> 17);
      o[7] = stbi__clamp((x0-t3) >> 17);
      o[1] = stbi__clamp((x1+t2) >> 17);
      o[6] = stbi__clamp((x1-t2) >> 17);
      o[2] = stbi__clamp((x2+t1) >> 17);
      o[5] = stbi__clamp((x2-t1) >> 17);
      o[3] = stbi__clamp((x3+t0) >> 17);
      o[4] = stbi__clamp((x3-t0) >> 17);
   }
}

#ifdef STBI_SSE2
// sse2 integer IDCT. not the fastest possible implementation but it
// produces bit-identical results to the generic C version so it's
// fully "transparent".
static void stbi__idct_simd(stbi_uc *out, int out_stride, short data[64])
{
   // This is constructed to match our regular (generic) integer IDCT exactly.
   __m128i row0, row1, row2, row3, row4, row5, row6, row7;
   __m128i tmp;

   // dot product constant: even elems=x, odd elems=y
   #define dct_const(x,y)  _mm_setr_epi16((x),(y),(x),(y),(x),(y),(x),(y))

   // out(0) = c0[even]*x + c0[odd]*y   (c0, x, y 16-bit, out 32-bit)
   // out(1) = c1[even]*x + c1[odd]*y
   #define dct_rot(out0,out1, x,y,c0,c1) \
      __m128i c0##lo = _mm_unpacklo_epi16((x),(y)); \
      __m128i c0##hi = _mm_unpackhi_epi16((x),(y)); \
      __m128i out0##_l = _mm_madd_epi16(c0##lo, c0); \
      __m128i out0##_h = _mm_madd_epi16(c0##hi, c0); \
      __m128i out1##_l = _mm_madd_epi16(c0##lo, c1); \
      __m128i out1##_h = _mm_madd_epi16(c0##hi, c1)

   // out = in << 12  (in 16-bit, out 32-bit)
   #define dct_widen(out, in) \
      __m128i out##_l = _mm_srai_epi32(_mm_unpacklo_epi16(_mm_setzero_si128(), (in)), 4); \
      __m128i out##_h = _mm_srai_epi32(_mm_unpackhi_epi16(_mm_setzero_si128(), (in)), 4)

   // wide add
   #define dct_wadd(out, a, b) \
      __m128i out##_l = _mm_add_epi32(a##_l, b##_l); \
      __m128i out##_h = _mm_add_epi32(a##_h, b##_h)

   // wide sub
   #define dct_wsub(out, a, b) \
      __m128i out##_l = _mm_sub_epi32(a##_l, b##_l); \
      __m128i out##_h = _mm_sub_epi32(a##_h, b##_h)

   // butterfly a/b, add bias, then shift by "s" and pack
   #define dct_bfly32o(out0, out1, a,b,bias,s) \
      { \
         __m128i abiased_l = _mm_add_epi32(a##_l, bias); \
         __m128i abiased_h = _mm_add_epi32(a##_h, bias); \
         dct_wadd(sum, abiased, b); \
         dct_wsub(dif, abiased, b); \
         out0 = _mm_packs_epi32(_mm_srai_epi32(sum_l, s), _mm_srai_epi32(sum_h, s)); \
         out1 = _mm_packs_epi32(_mm_srai_epi32(dif_l, s), _mm_srai_epi32(dif_h, s)); \
      }

   // 8-bit interleave step (for transposes)
   #define dct_interleave8(a, b) \
      tmp = a; \
      a = _mm_unpacklo_epi8(a, b); \
      b = _mm_unpackhi_epi8(tmp, b)

   // 16-bit interleave step (for transposes)
   #define dct_interleave16(a, b) \
      tmp = a; \
      a = _mm_unpacklo_epi16(a, b); \
      b = _mm_unpackhi_epi16(tmp, b)

   #define dct_pass(bias,shift) \
      { \
         /* even part */ \
         dct_rot(t2e,t3e, row2,row6, rot0_0,rot0_1); \
         __m128i sum04 = _mm_add_epi16(row0, row4); \
         __m128i dif04 = _mm_sub_epi16(row0, row4); \
         dct_widen(t0e, sum04); \
         dct_widen(t1e, dif04); \
         dct_wadd(x0, t0e, t3e); \
         dct_wsub(x3, t0e, t3e); \
         dct_wadd(x1, t1e, t2e); \
         dct_wsub(x2, t1e, t2e); \
         /* odd part */ \
         dct_rot(y0o,y2o, row7,row3, rot2_0,rot2_1); \
         dct_rot(y1o,y3o, row5,row1, rot3_0,rot3_1); \
         __m128i sum17 = _mm_add_epi16(row1, row7); \
         __m128i sum35 = _mm_add_epi16(row3, row5); \
         dct_rot(y4o,y5o, sum17,sum35, rot1_0,rot1_1); \
         dct_wadd(x4, y0o, y4o); \
         dct_wadd(x5, y1o, y5o); \
         dct_wadd(x6, y2o, y5o); \
         dct_wadd(x7, y3o, y4o); \
         dct_bfly32o(row0,row7, x0,x7,bias,shift); \
         dct_bfly32o(row1,row6, x1,x6,bias,shift); \
         dct_bfly32o(row2,row5, x2,x5,bias,shift); \
         dct_bfly32o(row3,row4, x3,x4,bias,shift); \
      }

   __m128i rot0_0 = dct_const(stbi__f2f(0.5411961f), stbi__f2f(0.5411961f) + stbi__f2f(-1.847759065f));
   __m128i rot0_1 = dct_const(stbi__f2f(0.5411961f) + stbi__f2f( 0.765366865f), stbi__f2f(0.5411961f));
   __m128i rot1_0 = dct_const(stbi__f2f(1.175875602f) + stbi__f2f(-0.899976223f), stbi__f2f(1.175875602f));
   __m128i rot1_1 = dct_const(stbi__f2f(1.175875602f), stbi__f2f(1.175875602f) + stbi__f2f(-2.562915447f));
   __m128i rot2_0 = dct_const(stbi__f2f(-1.961570560f) + stbi__f2f( 0.298631336f), stbi__f2f(-1.961570560f));
   __m128i rot2_1 = dct_const(stbi__f2f(-1.961570560f), stbi__f2f(-1.961570560f) + stbi__f2f( 3.072711026f));
   __m128i rot3_0 = dct_const(stbi__f2f(-0.390180644f) + stbi__f2f( 2.053119869f), stbi__f2f(-0.390180644f));
   __m128i rot3_1 = dct_const(stbi__f2f(-0.390180644f), stbi__f2f(-0.390180644f) + stbi__f2f( 1.501321110f));

   // rounding biases in column/row passes, see stbi__idct_block for explanation.
   __m128i bias_0 = _mm_set1_epi32(512);
   __m128i bias_1 = _mm_set1_epi32(65536 + (128<<17));

   // load
   row0 = _mm_load_si128((const __m128i *) (data + 0*8));
   row1 = _mm_load_si128((const __m128i *) (data + 1*8));
   row2 = _mm_load_si128((const __m128i *) (data + 2*8));
   row3 = _mm_load_si128((const __m128i *) (data + 3*8));
   row4 = _mm_load_si128((const __m128i *) (data + 4*8));
   row5 = _mm_load_si128((const __m128i *) (data + 5*8));
   row6 = _mm_load_si128((const __m128i *) (data + 6*8));
   row7 = _mm_load_si128((const __m128i *) (data + 7*8));

   // column pass
   dct_pass(bias_0, 10);

   {
      // 16bit 8x8 transpose pass 1
      dct_interleave16(row0, row4);
      dct_interleave16(row1, row5);
      dct_interleave16(row2, row6);
      dct_interleave16(row3, row7);

      // transpose pass 2
      dct_interleave16(row0, row2);
      dct_interleave16(row1, row3);
      dct_interleave16(row4, row6);
      dct_interleave16(row5, row7);

      // transpose pass 3
      dct_interleave16(row0, row1);
      dct_interleave16(row2, row3);
      dct_interleave16(row4, row5);
      dct_interleave16(row6, row7);
   }

   // row pass
   dct_pass(bias_1, 17);

   {
      // pack
      __m128i p0 = _mm_packus_epi16(row0, row1); // a0a1a2a3...a7b0b1b2b3...b7
      __m128i p1 = _mm_packus_epi16(row2, row3);
      __m128i p2 = _mm_packus_epi16(row4, row5);
      __m128i p3 = _mm_packus_epi16(row6, row7);

      // 8bit 8x8 transpose pass 1
      dct_interleave8(p0, p2); // a0e0a1e1...
      dct_interleave8(p1, p3); // c0g0c1g1...

      // transpose pass 2
      dct_interleave8(p0, p1); // a0c0e0g0...
      dct_interleave8(p2, p3); // b0d0f0h0...

      // transpose pass 3
      dct_interleave8(p0, p2); // a0b0c0d0...
      dct_interleave8(p1, p3); // a4b4c4d4...

      // store
      _mm_storel_epi64((__m128i *) out, p0); out += out_stride;
      _mm_storel_epi64((__m128i *) out, _mm_shuffle_epi32(p0, 0x4e)); out += out_stride;
      _mm_storel_epi64((__m128i *) out, p2); out += out_stride;
      _mm_storel_epi64((__m128i *) out, _mm_shuffle_epi32(p2, 0x4e)); out += out_stride;
      _mm_storel_epi64((__m128i *) out, p1); out += out_stride;
      _mm_storel_epi64((__m128i *) out, _mm_shuffle_epi32(p1, 0x4e)); out += out_stride;
      _mm_storel_epi64((__m128i *) out, p3); out += out_stride;
      _mm_storel_epi64((__m128i *) out, _mm_shuffle_epi32(p3, 0x4e));
   }

#undef dct_const
#undef dct_rot
#undef dct_widen
#undef dct_wadd
#undef dct_wsub
#undef dct_bfly32o
#undef dct_interleave8
#undef dct_interleave16
#undef dct_pass
}

#endif // STBI_SSE2

#ifdef STBI_NEON

// NEON integer IDCT. should produce bit-identical
// results to the generic C version.
static void stbi__idct_simd(stbi_uc *out, int out_stride, short data[64])
{
   int16x8_t row0, row1, row2, row3, row4, row5, row6, row7;

   int16x4_t rot0_0 = vdup_n_s16(stbi__f2f(0.5411961f));
   int16x4_t rot0_1 = vdup_n_s16(stbi__f2f(-1.847759065f));
   int16x4_t rot0_2 = vdup_n_s16(stbi__f2f( 0.765366865f));
   int16x4_t rot1_0 = vdup_n_s16(stbi__f2f( 1.175875602f));
   int16x4_t rot1_1 = vdup_n_s16(stbi__f2f(-0.899976223f));
   int16x4_t rot1_2 = vdup_n_s16(stbi__f2f(-2.562915447f));
   int16x4_t rot2_0 = vdup_n_s16(stbi__f2f(-1.961570560f));
   int16x4_t rot2_1 = vdup_n_s16(stbi__f2f(-0.390180644f));
   int16x4_t rot3_0 = vdup_n_s16(stbi__f2f( 0.298631336f));
   int16x4_t rot3_1 = vdup_n_s16(stbi__f2f( 2.053119869f));
   int16x4_t rot3_2 = vdup_n_s16(stbi__f2f( 3.072711026f));
   int16x4_t rot3_3 = vdup_n_s16(stbi__f2f( 1.501321110f));

#define dct_long_mul(out, inq, coeff) \
   int32x4_t out##_l = vmull_s16(vget_low_s16(inq), coeff); \
   int32x4_t out##_h = vmull_s16(vget_high_s16(inq), coeff)

#define dct_long_mac(out, acc, inq, coeff) \
   int32x4_t out##_l = vmlal_s16(acc##_l, vget_low_s16(inq), coeff); \
   int32x4_t out##_h = vmlal_s16(acc##_h, vget_high_s16(inq), coeff)

#define dct_widen(out, inq) \
   int32x4_t out##_l = vshll_n_s16(vget_low_s16(inq), 12); \
   int32x4_t out##_h = vshll_n_s16(vget_high_s16(inq), 12)

// wide add
#define dct_wadd(out, a, b) \
   int32x4_t out##_l = vaddq_s32(a##_l, b##_l); \
   int32x4_t out##_h = vaddq_s32(a##_h, b##_h)

// wide sub
#define dct_wsub(out, a, b) \
   int32x4_t out##_l = vsubq_s32(a##_l, b##_l); \
   int32x4_t out##_h = vsubq_s32(a##_h, b##_h)

// butterfly a/b, then shift using "shiftop" by "s" and pack
#define dct_bfly32o(out0,out1, a,b,shiftop,s) \
   { \
      dct_wadd(sum, a, b); \
      dct_wsub(dif, a, b); \
      out0 = vcombine_s16(shiftop(sum_l, s), shiftop(sum_h, s)); \
      out1 = vcombine_s16(shiftop(dif_l, s), shiftop(dif_h, s)); \
   }

#define dct_pass(shiftop, shift) \
   { \
      /* even part */ \
      int16x8_t sum26 = vaddq_s16(row2, row6); \
      dct_long_mul(p1e, sum26, rot0_0); \
      dct_long_mac(t2e, p1e, row6, rot0_1); \
      dct_long_mac(t3e, p1e, row2, rot0_2); \
      int16x8_t sum04 = vaddq_s16(row0, row4); \
      int16x8_t dif04 = vsubq_s16(row0, row4); \
      dct_widen(t0e, sum04); \
      dct_widen(t1e, dif04); \
      dct_wadd(x0, t0e, t3e); \
      dct_wsub(x3, t0e, t3e); \
      dct_wadd(x1, t1e, t2e); \
      dct_wsub(x2, t1e, t2e); \
      /* odd part */ \
      int16x8_t sum15 = vaddq_s16(row1, row5); \
      int16x8_t sum17 = vaddq_s16(row1, row7); \
      int16x8_t sum35 = vaddq_s16(row3, row5); \
      int16x8_t sum37 = vaddq_s16(row3, row7); \
      int16x8_t sumodd = vaddq_s16(sum17, sum35); \
      dct_long_mul(p5o, sumodd, rot1_0); \
      dct_long_mac(p1o, p5o, sum17, rot1_1); \
      dct_long_mac(p2o, p5o, sum35, rot1_2); \
      dct_long_mul(p3o, sum37, rot2_0); \
      dct_long_mul(p4o, sum15, rot2_1); \
      dct_wadd(sump13o, p1o, p3o); \
      dct_wadd(sump24o, p2o, p4o); \
      dct_wadd(sump23o, p2o, p3o); \
      dct_wadd(sump14o, p1o, p4o); \
      dct_long_mac(x4, sump13o, row7, rot3_0); \
      dct_long_mac(x5, sump24o, row5, rot3_1); \
      dct_long_mac(x6, sump23o, row3, rot3_2); \
      dct_long_mac(x7, sump14o, row1, rot3_3); \
      dct_bfly32o(row0,row7, x0,x7,shiftop,shift); \
      dct_bfly32o(row1,row6, x1,x6,shiftop,shift); \
      dct_bfly32o(row2,row5, x2,x5,shiftop,shift); \
      dct_bfly32o(row3,row4, x3,x4,shiftop,shift); \
   }

   // load
   row0 = vld1q_s16(data + 0*8);
   row1 = vld1q_s16(data + 1*8);
   row2 = vld1q_s16(data + 2*8);
   row3 = vld1q_s16(data + 3*8);
   row4 = vld1q_s16(data + 4*8);
   row5 = vld1q_s16(data + 5*8);
   row6 = vld1q_s16(data + 6*8);
   row7 = vld1q_s16(data + 7*8);

   // add DC bias
   row0 = vaddq_s16(row0, vsetq_lane_s16(1024, vdupq_n_s16(0), 0));

   // column pass
   dct_pass(vrshrn_n_s32, 10);

   // 16bit 8x8 transpose
   {
// these three map to a single VTRN.16, VTRN.32, and VSWP, respectively.
// whether compilers actually get this is another story, sadly.
#define dct_trn16(x, y) { int16x8x2_t t = vtrnq_s16(x, y); x = t.val[0]; y = t.val[1]; }
#define dct_trn32(x, y) { int32x4x2_t t = vtrnq_s32(vreinterpretq_s32_s16(x), vreinterpretq_s32_s16(y)); x = vreinterpretq_s16_s32(t.val[0]); y = vreinterpretq_s16_s32(t.val[1]); }
#define dct_trn64(x, y) { int16x8_t x0 = x; int16x8_t y0 = y; x = vcombine_s16(vget_low_s16(x0), vget_low_s16(y0)); y = vcombine_s16(vget_high_s16(x0), vget_high_s16(y0)); }

      // pass 1
      dct_trn16(row0, row1); // a0b0a2b2a4b4a6b6
      dct_trn16(row2, row3);
      dct_trn16(row4, row5);
      dct_trn16(row6, row7);

      // pass 2
      dct_trn32(row0, row2); // a0b0c0d0a4b4c4d4
      dct_trn32(row1, row3);
      dct_trn32(row4, row6);
      dct_trn32(row5, row7);

      // pass 3
      dct_trn64(row0, row4); // a0b0c0d0e0f0g0h0
      dct_trn64(row1, row5);
      dct_trn64(row2, row6);
      dct_trn64(row3, row7);

#undef dct_trn16
#undef dct_trn32
#undef dct_trn64
   }

   // row pass
   // vrshrn_n_s32 only supports shifts up to 16, we need
   // 17. so do a non-rounding shift of 16 first then follow
   // up with a rounding shift by 1.
   dct_pass(vshrn_n_s32, 16);

   {
      // pack and round
      uint8x8_t p0 = vqrshrun_n_s16(row0, 1);
      uint8x8_t p1 = vqrshrun_n_s16(row1, 1);
      uint8x8_t p2 = vqrshrun_n_s16(row2, 1);
      uint8x8_t p3 = vqrshrun_n_s16(row3, 1);
      uint8x8_t p4 = vqrshrun_n_s16(row4, 1);
      uint8x8_t p5 = vqrshrun_n_s16(row5, 1);
      uint8x8_t p6 = vqrshrun_n_s16(row6, 1);
      uint8x8_t p7 = vqrshrun_n_s16(row7, 1);

      // again, these can translate into one instruction, but often don't.
#define dct_trn8_8(x, y) { uint8x8x2_t t = vtrn_u8(x, y); x = t.val[0]; y = t.val[1]; }
#define dct_trn8_16(x, y) { uint16x4x2_t t = vtrn_u16(vreinterpret_u16_u8(x), vreinterpret_u16_u8(y)); x = vreinterpret_u8_u16(t.val[0]); y = vreinterpret_u8_u16(t.val[1]); }
#define dct_trn8_32(x, y) { uint32x2x2_t t = vtrn_u32(vreinterpret_u32_u8(x), vreinterpret_u32_u8(y)); x = vreinterpret_u8_u32(t.val[0]); y = vreinterpret_u8_u32(t.val[1]); }

      // sadly can't use interleaved stores here since we only write
      // 8 bytes to each scan line!

      // 8x8 8-bit transpose pass 1
      dct_trn8_8(p0, p1);
      dct_trn8_8(p2, p3);
      dct_trn8_8(p4, p5);
      dct_trn8_8(p6, p7);

      // pass 2
      dct_trn8_16(p0, p2);
      dct_trn8_16(p1, p3);
      dct_trn8_16(p4, p6);
      dct_trn8_16(p5, p7);

      // pass 3
      dct_trn8_32(p0, p4);
      dct_trn8_32(p1, p5);
      dct_trn8_32(p2, p6);
      dct_trn8_32(p3, p7);

      // store
      vst1_u8(out, p0); out += out_stride;
      vst1_u8(out, p1); out += out_stride;
      vst1_u8(out, p2); out += out_stride;
      vst1_u8(out, p3); out += out_stride;
      vst1_u8(out, p4); out += out_stride;
      vst1_u8(out, p5); out += out_stride;
      vst1_u8(out, p6); out += out_stride;
      vst1_u8(out, p7);

#undef dct_trn8_8
#undef dct_trn8_16
#undef dct_trn8_32
   }

#undef dct_long_mul
#undef dct_long_mac
#undef dct_widen
#undef dct_wadd
#undef dct_wsub
#undef dct_bfly32o
#undef dct_pass
}

#endif // STBI_NEON

#define STBI__MARKER_none  0xff
// if there's a pending marker from the entropy stream, return that
// otherwise, fetch from the stream and get a marker. if there's no
// marker, return 0xff, which is never a valid marker value
static stbi_uc stbi__get_marker(stbi__jpeg *j)
{
   stbi_uc x;
   if (j->marker != STBI__MARKER_none) { x = j->marker; j->marker = STBI__MARKER_none; return x; }
   x = stbi__get8(j->s);
   if (x != 0xff) return STBI__MARKER_none;
   while (x == 0xff)
      x = stbi__get8(j->s); // consume repeated 0xff fill bytes
   return x;
}

// in each scan, we'll have scan_n components, and the order
// of the components is specified by order[]
#define STBI__RESTART(x)     ((x) >= 0xd0 && (x) <= 0xd7)

// after a restart interval, stbi__jpeg_reset the entropy decoder and
// the dc prediction
static void stbi__jpeg_reset(stbi__jpeg *j)
{
   j->code_bits = 0;
   j->code_buffer = 0;
   j->nomore = 0;
   j->img_comp[0].dc_pred = j->img_comp[1].dc_pred = j->img_comp[2].dc_pred = j->img_comp[3].dc_pred = 0;
   j->marker = STBI__MARKER_none;
   j->todo = j->restart_interval ? j->restart_interval : 0x7fffffff;
   j->eob_run = 0;
   // no more than 1<<31 MCUs if no restart_interal? that's plenty safe,
   // since we don't even allow 1<<30 pixels
}

static int stbi__parse_entropy_coded_data(stbi__jpeg *z)
{
   stbi__jpeg_reset(z);
   if (!z->progressive) {
      if (z->scan_n == 1) {
         int i,j;
         STBI_SIMD_ALIGN(short, data[64]);
         int n = z->order[0];
         // non-interleaved data, we just need to process one block at a time,
         // in trivial scanline order
         // number of blocks to do just depends on how many actual "pixels" this
         // component has, independent of interleaved MCU blocking and such
         int w = (z->img_comp[n].x+7) >> 3;
         int h = (z->img_comp[n].y+7) >> 3;
         for (j=0; j < h; ++j) {
            for (i=0; i < w; ++i) {
               int ha = z->img_comp[n].ha;
               if (!stbi__jpeg_decode_block(z, data, z->huff_dc+z->img_comp[n].hd, z->huff_ac+ha, z->fast_ac[ha], n, z->dequant[z->img_comp[n].tq])) return 0;
               z->idct_block_kernel(z->img_comp[n].data+z->img_comp[n].w2*j*8+i*8, z->img_comp[n].w2, data);
               // every data block is an MCU, so countdown the restart interval
               if (--z->todo <= 0) {
                  if (z->code_bits < 24) stbi__grow_buffer_unsafe(z);
                  // if it's NOT a restart, then just bail, so we get corrupt data
                  // rather than no data
                  if (!STBI__RESTART(z->marker)) return 1;
                  stbi__jpeg_reset(z);
               }
            }
         }
         return 1;
      } else { // interleaved
         int i,j,k,x,y;
         STBI_SIMD_ALIGN(short, data[64]);
         for (j=0; j < z->img_mcu_y; ++j) {
            for (i=0; i < z->img_mcu_x; ++i) {
               // scan an interleaved mcu... process scan_n components in order
               for (k=0; k < z->scan_n; ++k) {
                  int n = z->order[k];
                  // scan out an mcu's worth of this component; that's just determined
                  // by the basic H and V specified for the component
                  for (y=0; y < z->img_comp[n].v; ++y) {
                     for (x=0; x < z->img_comp[n].h; ++x) {
                        int x2 = (i*z->img_comp[n].h + x)*8;
                        int y2 = (j*z->img_comp[n].v + y)*8;
                        int ha = z->img_comp[n].ha;
                        if (!stbi__jpeg_decode_block(z, data, z->huff_dc+z->img_comp[n].hd, z->huff_ac+ha, z->fast_ac[ha], n, z->dequant[z->img_comp[n].tq])) return 0;
                        z->idct_block_kernel(z->img_comp[n].data+z->img_comp[n].w2*y2+x2, z->img_comp[n].w2, data);
                     }
                  }
               }
               // after all interleaved components, that's an interleaved MCU,
               // so now count down the restart interval
               if (--z->todo <= 0) {
                  if (z->code_bits < 24) stbi__grow_buffer_unsafe(z);
                  if (!STBI__RESTART(z->marker)) return 1;
                  stbi__jpeg_reset(z);
               }
            }
         }
         return 1;
      }
   } else {
      if (z->scan_n == 1) {
         int i,j;
         int n = z->order[0];
         // non-interleaved data, we just need to process one block at a time,
         // in trivial scanline order
         // number of blocks to do just depends on how many actual "pixels" this
         // component has, independent of interleaved MCU blocking and such
         int w = (z->img_comp[n].x+7) >> 3;
         int h = (z->img_comp[n].y+7) >> 3;
         for (j=0; j < h; ++j) {
            for (i=0; i < w; ++i) {
               short *data = z->img_comp[n].coeff + 64 * (i + j * z->img_comp[n].coeff_w);
               if (z->spec_start == 0) {
                  if (!stbi__jpeg_decode_block_prog_dc(z, data, &z->huff_dc[z->img_comp[n].hd], n))
                     return 0;
               } else {
                  int ha = z->img_comp[n].ha;
                  if (!stbi__jpeg_decode_block_prog_ac(z, data, &z->huff_ac[ha], z->fast_ac[ha]))
                     return 0;
               }
               // every data block is an MCU, so countdown the restart interval
               if (--z->todo <= 0) {
                  if (z->code_bits < 24) stbi__grow_buffer_unsafe(z);
                  if (!STBI__RESTART(z->marker)) return 1;
                  stbi__jpeg_reset(z);
               }
            }
         }
         return 1;
      } else { // interleaved
         int i,j,k,x,y;
         for (j=0; j < z->img_mcu_y; ++j) {
            for (i=0; i < z->img_mcu_x; ++i) {
               // scan an interleaved mcu... process scan_n components in order
               for (k=0; k < z->scan_n; ++k) {
                  int n = z->order[k];
                  // scan out an mcu's worth of this component; that's just determined
                  // by the basic H and V specified for the component
                  for (y=0; y < z->img_comp[n].v; ++y) {
                     for (x=0; x < z->img_comp[n].h; ++x) {
                        int x2 = (i*z->img_comp[n].h + x);
                        int y2 = (j*z->img_comp[n].v + y);
                        short *data = z->img_comp[n].coeff + 64 * (x2 + y2 * z->img_comp[n].coeff_w);
                        if (!stbi__jpeg_decode_block_prog_dc(z, data, &z->huff_dc[z->img_comp[n].hd], n))
                           return 0;
                     }
                  }
               }
               // after all interleaved components, that's an interleaved MCU,
               // so now count down the restart interval
               if (--z->todo <= 0) {
                  if (z->code_bits < 24) stbi__grow_buffer_unsafe(z);
                  if (!STBI__RESTART(z->marker)) return 1;
                  stbi__jpeg_reset(z);
               }
            }
         }
         return 1;
      }
   }
}

static void stbi__jpeg_dequantize(short *data, stbi__uint16 *dequant)
{
   int i;
   for (i=0; i < 64; ++i)
      data[i] *= dequant[i];
}

static void stbi__jpeg_finish(stbi__jpeg *z)
{
   if (z->progressive) {
      // dequantize and idct the data
      int i,j,n;
      for (n=0; n < z->s->img_n; ++n) {
         int w = (z->img_comp[n].x+7) >> 3;
         int h = (z->img_comp[n].y+7) >> 3;
         for (j=0; j < h; ++j) {
            for (i=0; i < w; ++i) {
               short *data = z->img_comp[n].coeff + 64 * (i + j * z->img_comp[n].coeff_w);
               stbi__jpeg_dequantize(data, z->dequant[z->img_comp[n].tq]);
               z->idct_block_kernel(z->img_comp[n].data+z->img_comp[n].w2*j*8+i*8, z->img_comp[n].w2, data);
            }
         }
      }
   }
}

static int stbi__process_marker(stbi__jpeg *z, int m)
{
   int L;
   switch (m) {
      case STBI__MARKER_none: // no marker found
         return stbi__err("expected marker","Corrupt JPEG");

      case 0xDD: // DRI - specify restart interval
         if (stbi__get16be(z->s) != 4) return stbi__err("bad DRI len","Corrupt JPEG");
         z->restart_interval = stbi__get16be(z->s);
         return 1;

      case 0xDB: // DQT - define quantization table
         L = stbi__get16be(z->s)-2;
         while (L > 0) {
            int q = stbi__get8(z->s);
            int p = q >> 4, sixteen = (p != 0);
            int t = q & 15,i;
            if (p != 0 && p != 1) return stbi__err("bad DQT type","Corrupt JPEG");
            if (t > 3) return stbi__err("bad DQT table","Corrupt JPEG");

            for (i=0; i < 64; ++i)
               z->dequant[t][stbi__jpeg_dezigzag[i]] = (stbi__uint16)(sixteen ? stbi__get16be(z->s) : stbi__get8(z->s));
            L -= (sixteen ? 129 : 65);
         }
         return L==0;

      case 0xC4: // DHT - define huffman table
         L = stbi__get16be(z->s)-2;
         while (L > 0) {
            stbi_uc *v;
            int sizes[16],i,n=0;
            int q = stbi__get8(z->s);
            int tc = q >> 4;
            int th = q & 15;
            if (tc > 1 || th > 3) return stbi__err("bad DHT header","Corrupt JPEG");
            for (i=0; i < 16; ++i) {
               sizes[i] = stbi__get8(z->s);
               n += sizes[i];
            }
            L -= 17;
            if (tc == 0) {
               if (!stbi__build_huffman(z->huff_dc+th, sizes)) return 0;
               v = z->huff_dc[th].values;
            } else {
               if (!stbi__build_huffman(z->huff_ac+th, sizes)) return 0;
               v = z->huff_ac[th].values;
            }
            for (i=0; i < n; ++i)
               v[i] = stbi__get8(z->s);
            if (tc != 0)
               stbi__build_fast_ac(z->fast_ac[th], z->huff_ac + th);
            L -= n;
         }
         return L==0;
   }

   // check for comment block or APP blocks
   if ((m >= 0xE0 && m <= 0xEF) || m == 0xFE) {
      L = stbi__get16be(z->s);
      if (L < 2) {
         if (m == 0xFE)
            return stbi__err("bad COM len","Corrupt JPEG");
         else
            return stbi__err("bad APP len","Corrupt JPEG");
      }
      L -= 2;

      if (m == 0xE0 && L >= 5) { // JFIF APP0 segment
         static const unsigned char tag[5] = {'J','F','I','F','\0'};
         int ok = 1;
         int i;
         for (i=0; i < 5; ++i)
            if (stbi__get8(z->s) != tag[i])
               ok = 0;
         L -= 5;
         if (ok)
            z->jfif = 1;
      } else if (m == 0xEE && L >= 12) { // Adobe APP14 segment
         static const unsigned char tag[6] = {'A','d','o','b','e','\0'};
         int ok = 1;
         int i;
         for (i=0; i < 6; ++i)
            if (stbi__get8(z->s) != tag[i])
               ok = 0;
         L -= 6;
         if (ok) {
            stbi__get8(z->s); // version
            stbi__get16be(z->s); // flags0
            stbi__get16be(z->s); // flags1
            z->app14_color_transform = stbi__get8(z->s); // color transform
            L -= 6;
         }
      }

      stbi__skip(z->s, L);
      return 1;
   }

   return stbi__err("unknown marker","Corrupt JPEG");
}

// after we see SOS
static int stbi__process_scan_header(stbi__jpeg *z)
{
   int i;
   int Ls = stbi__get16be(z->s);
   z->scan_n = stbi__get8(z->s);
   if (z->scan_n < 1 || z->scan_n > 4 || z->scan_n > (int) z->s->img_n) return stbi__err("bad SOS component count","Corrupt JPEG");
   if (Ls != 6+2*z->scan_n) return stbi__err("bad SOS len","Corrupt JPEG");
   for (i=0; i < z->scan_n; ++i) {
      int id = stbi__get8(z->s), which;
      int q = stbi__get8(z->s);
      for (which = 0; which < z->s->img_n; ++which)
         if (z->img_comp[which].id == id)
            break;
      if (which == z->s->img_n) return 0; // no match
      z->img_comp[which].hd = q >> 4;   if (z->img_comp[which].hd > 3) return stbi__err("bad DC huff","Corrupt JPEG");
      z->img_comp[which].ha = q & 15;   if (z->img_comp[which].ha > 3) return stbi__err("bad AC huff","Corrupt JPEG");
      z->order[i] = which;
   }

   {
      int aa;
      z->spec_start = stbi__get8(z->s);
      z->spec_end   = stbi__get8(z->s); // should be 63, but might be 0
      aa = stbi__get8(z->s);
      z->succ_high = (aa >> 4);
      z->succ_low  = (aa & 15);
      if (z->progressive) {
         if (z->spec_start > 63 || z->spec_end > 63  || z->spec_start > z->spec_end || z->succ_high > 13 || z->succ_low > 13)
            return stbi__err("bad SOS", "Corrupt JPEG");
      } else {
         if (z->spec_start != 0) return stbi__err("bad SOS","Corrupt JPEG");
         if (z->succ_high != 0 || z->succ_low != 0) return stbi__err("bad SOS","Corrupt JPEG");
         z->spec_end = 63;
      }
   }

   return 1;
}

static int stbi__free_jpeg_components(stbi__jpeg *z, int ncomp, int why)
{
   int i;
   for (i=0; i < ncomp; ++i) {
      if (z->img_comp[i].raw_data) {
         STBI_FREE(z->img_comp[i].raw_data);
         z->img_comp[i].raw_data = NULL;
         z->img_comp[i].data = NULL;
      }
      if (z->img_comp[i].raw_coeff) {
         STBI_FREE(z->img_comp[i].raw_coeff);
         z->img_comp[i].raw_coeff = 0;
         z->img_comp[i].coeff = 0;
      }
      if (z->img_comp[i].linebuf) {
         STBI_FREE(z->img_comp[i].linebuf);
         z->img_comp[i].linebuf = NULL;
      }
   }
   return why;
}

static int stbi__process_frame_header(stbi__jpeg *z, int scan)
{
   stbi__context *s = z->s;
   int Lf,p,i,q, h_max=1,v_max=1,c;
   Lf = stbi__get16be(s);         if (Lf < 11) return stbi__err("bad SOF len","Corrupt JPEG"); // JPEG
   p  = stbi__get8(s);            if (p != 8) return stbi__err("only 8-bit","JPEG format not supported: 8-bit only"); // JPEG baseline
   s->img_y = stbi__get16be(s);   if (s->img_y == 0) return stbi__err("no header height", "JPEG format not supported: delayed height"); // Legal, but we don't handle it--but neither does IJG
   s->img_x = stbi__get16be(s);   if (s->img_x == 0) return stbi__err("0 width","Corrupt JPEG"); // JPEG requires
   if (s->img_y > STBI_MAX_DIMENSIONS) return stbi__err("too large","Very large image (corrupt?)");
   if (s->img_x > STBI_MAX_DIMENSIONS) return stbi__err("too large","Very large image (corrupt?)");
   c = stbi__get8(s);
   if (c != 3 && c != 1 && c != 4) return stbi__err("bad component count","Corrupt JPEG");
   s->img_n = c;
   for (i=0; i < c; ++i) {
      z->img_comp[i].data = NULL;
      z->img_comp[i].linebuf = NULL;
   }

   if (Lf != 8+3*s->img_n) return stbi__err("bad SOF len","Corrupt JPEG");

   z->rgb = 0;
   for (i=0; i < s->img_n; ++i) {
      static const unsigned char rgb[3] = { 'R', 'G', 'B' };
      z->img_comp[i].id = stbi__get8(s);
      if (s->img_n == 3 && z->img_comp[i].id == rgb[i])
         ++z->rgb;
      q = stbi__get8(s);
      z->img_comp[i].h = (q >> 4);  if (!z->img_comp[i].h || z->img_comp[i].h > 4) return stbi__err("bad H","Corrupt JPEG");
      z->img_comp[i].v = q & 15;    if (!z->img_comp[i].v || z->img_comp[i].v > 4) return stbi__err("bad V","Corrupt JPEG");
      z->img_comp[i].tq = stbi__get8(s);  if (z->img_comp[i].tq > 3) return stbi__err("bad TQ","Corrupt JPEG");
   }

   if (scan != STBI__SCAN_load) return 1;

   if (!stbi__mad3sizes_valid(s->img_x, s->img_y, s->img_n, 0)) return stbi__err("too large", "Image too large to decode");

   for (i=0; i < s->img_n; ++i) {
      if (z->img_comp[i].h > h_max) h_max = z->img_comp[i].h;
      if (z->img_comp[i].v > v_max) v_max = z->img_comp[i].v;
   }

   // check that plane subsampling factors are integer ratios; our resamplers can't deal with fractional ratios
   // and I've never seen a non-corrupted JPEG file actually use them
   for (i=0; i < s->img_n; ++i) {
      if (h_max % z->img_comp[i].h != 0) return stbi__err("bad H","Corrupt JPEG");
      if (v_max % z->img_comp[i].v != 0) return stbi__err("bad V","Corrupt JPEG");
   }

   // compute interleaved mcu info
   z->img_h_max = h_max;
   z->img_v_max = v_max;
   z->img_mcu_w = h_max * 8;
   z->img_mcu_h = v_max * 8;
   // these sizes can't be more than 17 bits
   z->img_mcu_x = (s->img_x + z->img_mcu_w-1) / z->img_mcu_w;
   z->img_mcu_y = (s->img_y + z->img_mcu_h-1) / z->img_mcu_h;

   for (i=0; i < s->img_n; ++i) {
      // number of effective pixels (e.g. for non-interleaved MCU)
      z->img_comp[i].x = (s->img_x * z->img_comp[i].h + h_max-1) / h_max;
      z->img_comp[i].y = (s->img_y * z->img_comp[i].v + v_max-1) / v_max;
      // to simplify generation, we'll allocate enough memory to decode
      // the bogus oversized data from using interleaved MCUs and their
      // big blocks (e.g. a 16x16 iMCU on an image of width 33); we won't
      // discard the extra data until colorspace conversion
      //
      // img_mcu_x, img_mcu_y: <=17 bits; comp[i].h and .v are <=4 (checked earlier)
      // so these muls can't overflow with 32-bit ints (which we require)
      z->img_comp[i].w2 = z->img_mcu_x * z->img_comp[i].h * 8;
      z->img_comp[i].h2 = z->img_mcu_y * z->img_comp[i].v * 8;
      z->img_comp[i].coeff = 0;
      z->img_comp[i].raw_coeff = 0;
      z->img_comp[i].linebuf = NULL;
      z->img_comp[i].raw_data = stbi__malloc_mad2(z->img_comp[i].w2, z->img_comp[i].h2, 15);
      if (z->img_comp[i].raw_data == NULL)
         return stbi__free_jpeg_components(z, i+1, stbi__err("outofmem", "Out of memory"));
      // align blocks for idct using mmx/sse
      z->img_comp[i].data = (stbi_uc*) (((size_t) z->img_comp[i].raw_data + 15) & ~15);
      if (z->progressive) {
         // w2, h2 are multiples of 8 (see above)
         z->img_comp[i].coeff_w = z->img_comp[i].w2 / 8;
         z->img_comp[i].coeff_h = z->img_comp[i].h2 / 8;
         z->img_comp[i].raw_coeff = stbi__malloc_mad3(z->img_comp[i].w2, z->img_comp[i].h2, sizeof(short), 15);
         if (z->img_comp[i].raw_coeff == NULL)
            return stbi__free_jpeg_components(z, i+1, stbi__err("outofmem", "Out of memory"));
         z->img_comp[i].coeff = (short*) (((size_t) z->img_comp[i].raw_coeff + 15) & ~15);
      }
   }

   return 1;
}

// use comparisons since in some cases we handle more than one case (e.g. SOF)
#define stbi__DNL(x)         ((x) == 0xdc)
#define stbi__SOI(x)         ((x) == 0xd8)
#define stbi__EOI(x)         ((x) == 0xd9)
#define stbi__SOF(x)         ((x) == 0xc0 || (x) == 0xc1 || (x) == 0xc2)
#define stbi__SOS(x)         ((x) == 0xda)

#define stbi__SOF_progressive(x)   ((x) == 0xc2)

static int stbi__decode_jpeg_header(stbi__jpeg *z, int scan)
{
   int m;
   z->jfif = 0;
   z->app14_color_transform = -1; // valid values are 0,1,2
   z->marker = STBI__MARKER_none; // initialize cached marker to empty
   m = stbi__get_marker(z);
   if (!stbi__SOI(m)) return stbi__err("no SOI","Corrupt JPEG");
   if (scan == STBI__SCAN_type) return 1;
   m = stbi__get_marker(z);
   while (!stbi__SOF(m)) {
      if (!stbi__process_marker(z,m)) return 0;
      m = stbi__get_marker(z);
      while (m == STBI__MARKER_none) {
         // some files have extra padding after their blocks, so ok, we'll scan
         if (stbi__at_eof(z->s)) return stbi__err("no SOF", "Corrupt JPEG");
         m = stbi__get_marker(z);
      }
   }
   z->progressive = stbi__SOF_progressive(m);
   if (!stbi__process_frame_header(z, scan)) return 0;
   return 1;
}

// decode image to YCbCr format
static int stbi__decode_jpeg_image(stbi__jpeg *j)
{
   int m;
   for (m = 0; m < 4; m++) {
      j->img_comp[m].raw_data = NULL;
      j->img_comp[m].raw_coeff = NULL;
   }
   j->restart_interval = 0;
   if (!stbi__decode_jpeg_header(j, STBI__SCAN_load)) return 0;
   m = stbi__get_marker(j);
   while (!stbi__EOI(m)) {
      if (stbi__SOS(m)) {
         if (!stbi__process_scan_header(j)) return 0;
         if (!stbi__parse_entropy_coded_data(j)) return 0;
         if (j->marker == STBI__MARKER_none ) {
            // handle 0s at the end of image data from IP Kamera 9060
            while (!stbi__at_eof(j->s)) {
               int x = stbi__get8(j->s);
               if (x == 255) {
                  j->marker = stbi__get8(j->s);
                  break;
               }
            }
            // if we reach eof without hitting a marker, stbi__get_marker() below will fail and we'll eventually return 0
         }
      } else if (stbi__DNL(m)) {
         int Ld = stbi__get16be(j->s);
         stbi__uint32 NL = stbi__get16be(j->s);
         if (Ld != 4) return stbi__err("bad DNL len", "Corrupt JPEG");
         if (NL != j->s->img_y) return stbi__err("bad DNL height", "Corrupt JPEG");
      } else {
         if (!stbi__process_marker(j, m)) return 0;
      }
      m = stbi__get_marker(j);
   }
   if (j->progressive)
      stbi__jpeg_finish(j);
   return 1;
}

// static jfif-centered resampling (across block boundaries)

typedef stbi_uc *(*resample_row_func)(stbi_uc *out, stbi_uc *in0, stbi_uc *in1,
                                    int w, int hs);

#define stbi__div4(x) ((stbi_uc) ((x) >> 2))

static stbi_uc *resample_row_1(stbi_uc *out, stbi_uc *in_near, stbi_uc *in_far, int w, int hs)
{
   STBI_NOTUSED(out);
   STBI_NOTUSED(in_far);
   STBI_NOTUSED(w);
   STBI_NOTUSED(hs);
   return in_near;
}

static stbi_uc* stbi__resample_row_v_2(stbi_uc *out, stbi_uc *in_near, stbi_uc *in_far, int w, int hs)
{
   // need to generate two samples vertically for every one in input
   int i;
   STBI_NOTUSED(hs);
   for (i=0; i < w; ++i)
      out[i] = stbi__div4(3*in_near[i] + in_far[i] + 2);
   return out;
}

static stbi_uc*  stbi__resample_row_h_2(stbi_uc *out, stbi_uc *in_near, stbi_uc *in_far, int w, int hs)
{
   // need to generate two samples horizontally for every one in input
   int i;
   stbi_uc *input = in_near;

   if (w == 1) {
      // if only one sample, can't do any interpolation
      out[0] = out[1] = input[0];
      return out;
   }

   out[0] = input[0];
   out[1] = stbi__div4(input[0]*3 + input[1] + 2);
   for (i=1; i < w-1; ++i) {
      int n = 3*input[i]+2;
      out[i*2+0] = stbi__div4(n+input[i-1]);
      out[i*2+1] = stbi__div4(n+input[i+1]);
   }
   out[i*2+0] = stbi__div4(input[w-2]*3 + input[w-1] + 2);
   out[i*2+1] = input[w-1];

   STBI_NOTUSED(in_far);
   STBI_NOTUSED(hs);

   return out;
}

#define stbi__div16(x) ((stbi_uc) ((x) >> 4))

static stbi_uc *stbi__resample_row_hv_2(stbi_uc *out, stbi_uc *in_near, stbi_uc *in_far, int w, int hs)
{
   // need to generate 2x2 samples for every one in input
   int i,t0,t1;
   if (w == 1) {
      out[0] = out[1] = stbi__div4(3*in_near[0] + in_far[0] + 2);
      return out;
   }

   t1 = 3*in_near[0] + in_far[0];
   out[0] = stbi__div4(t1+2);
   for (i=1; i < w; ++i) {
      t0 = t1;
      t1 = 3*in_near[i]+in_far[i];
      out[i*2-1] = stbi__div16(3*t0 + t1 + 8);
      out[i*2  ] = stbi__div16(3*t1 + t0 + 8);
   }
   out[w*2-1] = stbi__div4(t1+2);

   STBI_NOTUSED(hs);

   return out;
}

#if defined(STBI_SSE2) || defined(STBI_NEON)
static stbi_uc *stbi__resample_row_hv_2_simd(stbi_uc *out, stbi_uc *in_near, stbi_uc *in_far, int w, int hs)
{
   // need to generate 2x2 samples for every one in input
   int i=0,t0,t1;

   if (w == 1) {
      out[0] = out[1] = stbi__div4(3*in_near[0] + in_far[0] + 2);
      return out;
   }

   t1 = 3*in_near[0] + in_far[0];
   // process groups of 8 pixels for as long as we can.
   // note we can't handle the last pixel in a row in this loop
   // because we need to handle the filter boundary conditions.
   for (; i < ((w-1) & ~7); i += 8) {
#if defined(STBI_SSE2)
      // load and perform the vertical filtering pass
      // this uses 3*x + y = 4*x + (y - x)
      __m128i zero  = _mm_setzero_si128();
      __m128i farb  = _mm_loadl_epi64((__m128i *) (in_far + i));
      __m128i nearb = _mm_loadl_epi64((__m128i *) (in_near + i));
      __m128i farw  = _mm_unpacklo_epi8(farb, zero);
      __m128i nearw = _mm_unpacklo_epi8(nearb, zero);
      __m128i diff  = _mm_sub_epi16(farw, nearw);
      __m128i nears = _mm_slli_epi16(nearw, 2);
      __m128i curr  = _mm_add_epi16(nears, diff); // current row

      // horizontal filter works the same based on shifted vers of current
      // row. "prev" is current row shifted right by 1 pixel; we need to
      // insert the previous pixel value (from t1).
      // "next" is current row shifted left by 1 pixel, with first pixel
      // of next block of 8 pixels added in.
      __m128i prv0 = _mm_slli_si128(curr, 2);
      __m128i nxt0 = _mm_srli_si128(curr, 2);
      __m128i prev = _mm_insert_epi16(prv0, t1, 0);
      __m128i next = _mm_insert_epi16(nxt0, 3*in_near[i+8] + in_far[i+8], 7);

      // horizontal filter, polyphase implementation since it's convenient:
      // even pixels = 3*cur + prev = cur*4 + (prev - cur)
      // odd  pixels = 3*cur + next = cur*4 + (next - cur)
      // note the shared term.
      __m128i bias  = _mm_set1_epi16(8);
      __m128i curs = _mm_slli_epi16(curr, 2);
      __m128i prvd = _mm_sub_epi16(prev, curr);
      __m128i nxtd = _mm_sub_epi16(next, curr);
      __m128i curb = _mm_add_epi16(curs, bias);
      __m128i even = _mm_add_epi16(prvd, curb);
      __m128i odd  = _mm_add_epi16(nxtd, curb);

      // interleave even and odd pixels, then undo scaling.
      __m128i int0 = _mm_unpacklo_epi16(even, odd);
      __m128i int1 = _mm_unpackhi_epi16(even, odd);
      __m128i de0  = _mm_srli_epi16(int0, 4);
      __m128i de1  = _mm_srli_epi16(int1, 4);

      // pack and write output
      __m128i outv = _mm_packus_epi16(de0, de1);
      _mm_storeu_si128((__m128i *) (out + i*2), outv);
#elif defined(STBI_NEON)
      // load and perform the vertical filtering pass
      // this uses 3*x + y = 4*x + (y - x)
      uint8x8_t farb  = vld1_u8(in_far + i);
      uint8x8_t nearb = vld1_u8(in_near + i);
      int16x8_t diff  = vreinterpretq_s16_u16(vsubl_u8(farb, nearb));
      int16x8_t nears = vreinterpretq_s16_u16(vshll_n_u8(nearb, 2));
      int16x8_t curr  = vaddq_s16(nears, diff); // current row

      // horizontal filter works the same based on shifted vers of current
      // row. "prev" is current row shifted right by 1 pixel; we need to
      // insert the previous pixel value (from t1).
      // "next" is current row shifted left by 1 pixel, with first pixel
      // of next block of 8 pixels added in.
      int16x8_t prv0 = vextq_s16(curr, curr, 7);
      int16x8_t nxt0 = vextq_s16(curr, curr, 1);
      int16x8_t prev = vsetq_lane_s16(t1, prv0, 0);
      int16x8_t next = vsetq_lane_s16(3*in_near[i+8] + in_far[i+8], nxt0, 7);

      // horizontal filter, polyphase implementation since it's convenient:
      // even pixels = 3*cur + prev = cur*4 + (prev - cur)
      // odd  pixels = 3*cur + next = cur*4 + (next - cur)
      // note the shared term.
      int16x8_t curs = vshlq_n_s16(curr, 2);
      int16x8_t prvd = vsubq_s16(prev, curr);
      int16x8_t nxtd = vsubq_s16(next, curr);
      int16x8_t even = vaddq_s16(curs, prvd);
      int16x8_t odd  = vaddq_s16(curs, nxtd);

      // undo scaling and round, then store with even/odd phases interleaved
      uint8x8x2_t o;
      o.val[0] = vqrshrun_n_s16(even, 4);
      o.val[1] = vqrshrun_n_s16(odd,  4);
      vst2_u8(out + i*2, o);
#endif

      // "previous" value for next iter
      t1 = 3*in_near[i+7] + in_far[i+7];
   }

   t0 = t1;
   t1 = 3*in_near[i] + in_far[i];
   out[i*2] = stbi__div16(3*t1 + t0 + 8);

   for (++i; i < w; ++i) {
      t0 = t1;
      t1 = 3*in_near[i]+in_far[i];
      out[i*2-1] = stbi__div16(3*t0 + t1 + 8);
      out[i*2  ] = stbi__div16(3*t1 + t0 + 8);
   }
   out[w*2-1] = stbi__div4(t1+2);

   STBI_NOTUSED(hs);

   return out;
}
#endif

static stbi_uc *stbi__resample_row_generic(stbi_uc *out, stbi_uc *in_near, stbi_uc *in_far, int w, int hs)
{
   // resample with nearest-neighbor
   int i,j;
   STBI_NOTUSED(in_far);
   for (i=0; i < w; ++i)
      for (j=0; j < hs; ++j)
         out[i*hs+j] = in_near[i];
   return out;
}

// this is a reduced-precision calculation of YCbCr-to-RGB introduced
// to make sure the code produces the same results in both SIMD and scalar
#define stbi__float2fixed(x)  (((int) ((x) * 4096.0f + 0.5f)) << 8)
static void stbi__YCbCr_to_RGB_row(stbi_uc *out, const stbi_uc *y, const stbi_uc *pcb, const stbi_uc *pcr, int count, int step)
{
   int i;
   for (i=0; i < count; ++i) {
      int y_fixed = (y[i] << 20) + (1<<19); // rounding
      int r,g,b;
      int cr = pcr[i] - 128;
      int cb = pcb[i] - 128;
      r = y_fixed +  cr* stbi__float2fixed(1.40200f);
      g = y_fixed + (cr*-stbi__float2fixed(0.71414f)) + ((cb*-stbi__float2fixed(0.34414f)) & 0xffff0000);
      b = y_fixed                                     +   cb* stbi__float2fixed(1.77200f);
      r >>= 20;
      g >>= 20;
      b >>= 20;
      if ((unsigned) r > 255) { if (r < 0) r = 0; else r = 255; }
      if ((unsigned) g > 255) { if (g < 0) g = 0; else g = 255; }
      if ((unsigned) b > 255) { if (b < 0) b = 0; else b = 255; }
      out[0] = (stbi_uc)r;
      out[1] = (stbi_uc)g;
      out[2] = (stbi_uc)b;
      out[3] = 255;
      out += step;
   }
}

#if defined(STBI_SSE2) || defined(STBI_NEON)
static void stbi__YCbCr_to_RGB_simd(stbi_uc *out, stbi_uc const *y, stbi_uc const *pcb, stbi_uc const *pcr, int count, int step)
{
   int i = 0;

#ifdef STBI_SSE2
   // step == 3 is pretty ugly on the final interleave, and i'm not convinced
   // it's useful in practice (you wouldn't use it for textures, for example).
   // so just accelerate step == 4 case.
   if (step == 4) {
      // this is a fairly straightforward implementation and not super-optimized.
      __m128i signflip  = _mm_set1_epi8(-0x80);
      __m128i cr_const0 = _mm_set1_epi16(   (short) ( 1.40200f*4096.0f+0.5f));
      __m128i cr_const1 = _mm_set1_epi16( - (short) ( 0.71414f*4096.0f+0.5f));
      __m128i cb_const0 = _mm_set1_epi16( - (short) ( 0.34414f*4096.0f+0.5f));
      __m128i cb_const1 = _mm_set1_epi16(   (short) ( 1.77200f*4096.0f+0.5f));
      __m128i y_bias = _mm_set1_epi8((char) (unsigned char) 128);
      __m128i xw = _mm_set1_epi16(255); // alpha channel

      for (; i+7 < count; i += 8) {
         // load
         __m128i y_bytes = _mm_loadl_epi64((__m128i *) (y+i));
         __m128i cr_bytes = _mm_loadl_epi64((__m128i *) (pcr+i));
         __m128i cb_bytes = _mm_loadl_epi64((__m128i *) (pcb+i));
         __m128i cr_biased = _mm_xor_si128(cr_bytes, signflip); // -128
         __m128i cb_biased = _mm_xor_si128(cb_bytes, signflip); // -128

         // unpack to short (and left-shift cr, cb by 8)
         __m128i yw  = _mm_unpacklo_epi8(y_bias, y_bytes);
         __m128i crw = _mm_unpacklo_epi8(_mm_setzero_si128(), cr_biased);
         __m128i cbw = _mm_unpacklo_epi8(_mm_setzero_si128(), cb_biased);

         // color transform
         __m128i yws = _mm_srli_epi16(yw, 4);
         __m128i cr0 = _mm_mulhi_epi16(cr_const0, crw);
         __m128i cb0 = _mm_mulhi_epi16(cb_const0, cbw);
         __m128i cb1 = _mm_mulhi_epi16(cbw, cb_const1);
         __m128i cr1 = _mm_mulhi_epi16(crw, cr_const1);
         __m128i rws = _mm_add_epi16(cr0, yws);
         __m128i gwt = _mm_add_epi16(cb0, yws);
         __m128i bws = _mm_add_epi16(yws, cb1);
         __m128i gws = _mm_add_epi16(gwt, cr1);

         // descale
         __m128i rw = _mm_srai_epi16(rws, 4);
         __m128i bw = _mm_srai_epi16(bws, 4);
         __m128i gw = _mm_srai_epi16(gws, 4);

         // back to byte, set up for transpose
         __m128i brb = _mm_packus_epi16(rw, bw);
         __m128i gxb = _mm_packus_epi16(gw, xw);

         // transpose to interleave channels
         __m128i t0 = _mm_unpacklo_epi8(brb, gxb);
         __m128i t1 = _mm_unpackhi_epi8(brb, gxb);
         __m128i o0 = _mm_unpacklo_epi16(t0, t1);
         __m128i o1 = _mm_unpackhi_epi16(t0, t1);

         // store
         _mm_storeu_si128((__m128i *) (out + 0), o0);
         _mm_storeu_si128((__m128i *) (out + 16), o1);
         out += 32;
      }
   }
#endif

#ifdef STBI_NEON
   // in this version, step=3 support would be easy to add. but is there demand?
   if (step == 4) {
      // this is a fairly straightforward implementation and not super-optimized.
      uint8x8_t signflip = vdup_n_u8(0x80);
      int16x8_t cr_const0 = vdupq_n_s16(   (short) ( 1.40200f*4096.0f+0.5f));
      int16x8_t cr_const1 = vdupq_n_s16( - (short) ( 0.71414f*4096.0f+0.5f));
      int16x8_t cb_const0 = vdupq_n_s16( - (short) ( 0.34414f*4096.0f+0.5f));
      int16x8_t cb_const1 = vdupq_n_s16(   (short) ( 1.77200f*4096.0f+0.5f));

      for (; i+7 < count; i += 8) {
         // load
         uint8x8_t y_bytes  = vld1_u8(y + i);
         uint8x8_t cr_bytes = vld1_u8(pcr + i);
         uint8x8_t cb_bytes = vld1_u8(pcb + i);
         int8x8_t cr_biased = vreinterpret_s8_u8(vsub_u8(cr_bytes, signflip));
         int8x8_t cb_biased = vreinterpret_s8_u8(vsub_u8(cb_bytes, signflip));

         // expand to s16
         int16x8_t yws = vreinterpretq_s16_u16(vshll_n_u8(y_bytes, 4));
         int16x8_t crw = vshll_n_s8(cr_biased, 7);
         int16x8_t cbw = vshll_n_s8(cb_biased, 7);

         // color transform
         int16x8_t cr0 = vqdmulhq_s16(crw, cr_const0);
         int16x8_t cb0 = vqdmulhq_s16(cbw, cb_const0);
         int16x8_t cr1 = vqdmulhq_s16(crw, cr_const1);
         int16x8_t cb1 = vqdmulhq_s16(cbw, cb_const1);
         int16x8_t rws = vaddq_s16(yws, cr0);
         int16x8_t gws = vaddq_s16(vaddq_s16(yws, cb0), cr1);
         int16x8_t bws = vaddq_s16(yws, cb1);

         // undo scaling, round, convert to byte
         uint8x8x4_t o;
         o.val[0] = vqrshrun_n_s16(rws, 4);
         o.val[1] = vqrshrun_n_s16(gws, 4);
         o.val[2] = vqrshrun_n_s16(bws, 4);
         o.val[3] = vdup_n_u8(255);

         // store, interleaving r/g/b/a
         vst4_u8(out, o);
         out += 8*4;
      }
   }
#endif

   for (; i < count; ++i) {
      int y_fixed = (y[i] << 20) + (1<<19); // rounding
      int r,g,b;
      int cr = pcr[i] - 128;
      int cb = pcb[i] - 128;
      r = y_fixed + cr* stbi__float2fixed(1.40200f);
      g = y_fixed + cr*-stbi__float2fixed(0.71414f) + ((cb*-stbi__float2fixed(0.34414f)) & 0xffff0000);
      b = y_fixed                                   +   cb* stbi__float2fixed(1.77200f);
      r >>= 20;
      g >>= 20;
      b >>= 20;
      if ((unsigned) r > 255) { if (r < 0) r = 0; else r = 255; }
      if ((unsigned) g > 255) { if (g < 0) g = 0; else g = 255; }
      if ((unsigned) b > 255) { if (b < 0) b = 0; else b = 255; }
      out[0] = (stbi_uc)r;
      out[1] = (stbi_uc)g;
      out[2] = (stbi_uc)b;
      out[3] = 255;
      out += step;
   }
}
#endif

// set up the kernels
static void stbi__setup_jpeg(stbi__jpeg *j)
{
   j->idct_block_kernel = stbi__idct_block;
   j->YCbCr_to_RGB_kernel = stbi__YCbCr_to_RGB_row;
   j->resample_row_hv_2_kernel = stbi__resample_row_hv_2;

#ifdef STBI_SSE2
   if (stbi__sse2_available()) {
      j->idct_block_kernel = stbi__idct_simd;
      j->YCbCr_to_RGB_kernel = stbi__YCbCr_to_RGB_simd;
      j->resample_row_hv_2_kernel = stbi__resample_row_hv_2_simd;
   }
#endif

#ifdef STBI_NEON
   j->idct_block_kernel = stbi__idct_simd;
   j->YCbCr_to_RGB_kernel = stbi__YCbCr_to_RGB_simd;
   j->resample_row_hv_2_kernel = stbi__resample_row_hv_2_simd;
#endif
}

// clean up the temporary component buffers
static void stbi__cleanup_jpeg(stbi__jpeg *j)
{
   stbi__free_jpeg_components(j, j->s->img_n, 0);
}

typedef struct
{
   resample_row_func resample;
   stbi_uc *line0,*line1;
   int hs,vs;   // expansion factor in each axis
   int w_lores; // horizontal pixels pre-expansion
   int ystep;   // how far through vertical expansion we are
   int ypos;    // which pre-expansion row we're on
} stbi__resample;

// fast 0..255 * 0..255 => 0..255 rounded multiplication
static stbi_uc stbi__blinn_8x8(stbi_uc x, stbi_uc y)
{
   unsigned int t = x*y + 128;
   return (stbi_uc) ((t + (t >>8)) >> 8);
}

static stbi_uc *load_jpeg_image(stbi__jpeg *z, int *out_x, int *out_y, int *comp, int req_comp)
{
   int n, decode_n, is_rgb;
   z->s->img_n = 0; // make stbi__cleanup_jpeg safe

   // validate req_comp
   if (req_comp < 0 || req_comp > 4) return stbi__errpuc("bad req_comp", "Internal error");

   // load a jpeg image from whichever source, but leave in YCbCr format
   if (!stbi__decode_jpeg_image(z)) { stbi__cleanup_jpeg(z); return NULL; }

   // determine actual number of components to generate
   n = req_comp ? req_comp : z->s->img_n >= 3 ? 3 : 1;

   is_rgb = z->s->img_n == 3 && (z->rgb == 3 || (z->app14_color_transform == 0 && !z->jfif));

   if (z->s->img_n == 3 && n < 3 && !is_rgb)
      decode_n = 1;
   else
      decode_n = z->s->img_n;

   // nothing to do if no components requested; check this now to avoid
   // accessing uninitialized coutput[0] later
   if (decode_n <= 0) { stbi__cleanup_jpeg(z); return NULL; }

   // resample and color-convert
   {
      int k;
      unsigned int i,j;
      stbi_uc *output;
      stbi_uc *coutput[4] = { NULL, NULL, NULL, NULL };

      stbi__resample res_comp[4];

      for (k=0; k < decode_n; ++k) {
         stbi__resample *r = &res_comp[k];

         // allocate line buffer big enough for upsampling off the edges
         // with upsample factor of 4
         z->img_comp[k].linebuf = (stbi_uc *) stbi__malloc(z->s->img_x + 3);
         if (!z->img_comp[k].linebuf) { stbi__cleanup_jpeg(z); return stbi__errpuc("outofmem", "Out of memory"); }

         r->hs      = z->img_h_max / z->img_comp[k].h;
         r->vs      = z->img_v_max / z->img_comp[k].v;
         r->ystep   = r->vs >> 1;
         r->w_lores = (z->s->img_x + r->hs-1) / r->hs;
         r->ypos    = 0;
         r->line0   = r->line1 = z->img_comp[k].data;

         if      (r->hs == 1 && r->vs == 1) r->resample = resample_row_1;
         else if (r->hs == 1 && r->vs == 2) r->resample = stbi__resample_row_v_2;
         else if (r->hs == 2 && r->vs == 1) r->resample = stbi__resample_row_h_2;
         else if (r->hs == 2 && r->vs == 2) r->resample = z->resample_row_hv_2_kernel;
         else                               r->resample = stbi__resample_row_generic;
      }

      // can't error after this so, this is safe
      output = (stbi_uc *) stbi__malloc_mad3(n, z->s->img_x, z->s->img_y, 1);
      if (!output) { stbi__cleanup_jpeg(z); return stbi__errpuc("outofmem", "Out of memory"); }

      // now go ahead and resample
      for (j=0; j < z->s->img_y; ++j) {
         stbi_uc *out = output + n * z->s->img_x * j;
         for (k=0; k < decode_n; ++k) {
            stbi__resample *r = &res_comp[k];
            int y_bot = r->ystep >= (r->vs >> 1);
            coutput[k] = r->resample(z->img_comp[k].linebuf,
                                     y_bot ? r->line1 : r->line0,
                                     y_bot ? r->line0 : r->line1,
                                     r->w_lores, r->hs);
            if (++r->ystep >= r->vs) {
               r->ystep = 0;
               r->line0 = r->line1;
               if (++r->ypos < z->img_comp[k].y)
                  r->line1 += z->img_comp[k].w2;
            }
         }
         if (n >= 3) {
            stbi_uc *y = coutput[0];
            if (z->s->img_n == 3) {
               if (is_rgb) {
                  for (i=0; i < z->s->img_x; ++i) {
                     out[0] = y[i];
                     out[1] = coutput[1][i];
                     out[2] = coutput[2][i];
                     out[3] = 255;
                     out += n;
                  }
               } else {
                  z->YCbCr_to_RGB_kernel(out, y, coutput[1], coutput[2], z->s->img_x, n);
               }
            } else if (z->s->img_n == 4) {
               if (z->app14_color_transform == 0) { // CMYK
                  for (i=0; i < z->s->img_x; ++i) {
                     stbi_uc m = coutput[3][i];
                     out[0] = stbi__blinn_8x8(coutput[0][i], m);
                     out[1] = stbi__blinn_8x8(coutput[1][i], m);
                     out[2] = stbi__blinn_8x8(coutput[2][i], m);
                     out[3] = 255;
                     out += n;
                  }
               } else if (z->app14_color_transform == 2) { // YCCK
                  z->YCbCr_to_RGB_kernel(out, y, coutput[1], coutput[2], z->s->img_x, n);
                  for (i=0; i < z->s->img_x; ++i) {
                     stbi_uc m = coutput[3][i];
                     out[0] = stbi__blinn_8x8(255 - out[0], m);
                     out[1] = stbi__blinn_8x8(255 - out[1], m);
                     out[2] = stbi__blinn_8x8(255 - out[2], m);
                     out += n;
                  }
               } else { // YCbCr + alpha?  Ignore the fourth channel for now
                  z->YCbCr_to_RGB_kernel(out, y, coutput[1], coutput[2], z->s->img_x, n);
               }
            } else
               for (i=0; i < z->s->img_x; ++i) {
                  out[0] = out[1] = out[2] = y[i];
                  out[3] = 255; // not used if n==3
                  out += n;
               }
         } else {
            if (is_rgb) {
               if (n == 1)
                  for (i=0; i < z->s->img_x; ++i)
                     *out++ = stbi__compute_y(coutput[0][i], coutput[1][i], coutput[2][i]);
               else {
                  for (i=0; i < z->s->img_x; ++i, out += 2) {
                     out[0] = stbi__compute_y(coutput[0][i], coutput[1][i], coutput[2][i]);
                     out[1] = 255;
                  }
               }
            } else if (z->s->img_n == 4 && z->app14_color_transform == 0) {
               for (i=0; i < z->s->img_x; ++i) {
                  stbi_uc m = coutput[3][i];
                  stbi_uc r = stbi__blinn_8x8(coutput[0][i], m);
                  stbi_uc g = stbi__blinn_8x8(coutput[1][i], m);
                  stbi_uc b = stbi__blinn_8x8(coutput[2][i], m);
                  out[0] = stbi__compute_y(r, g, b);
                  out[1] = 255;
                  out += n;
               }
            } else if (z->s->img_n == 4 && z->app14_color_transform == 2) {
               for (i=0; i < z->s->img_x; ++i) {
                  out[0] = stbi__blinn_8x8(255 - coutput[0][i], coutput[3][i]);
                  out[1] = 255;
                  out += n;
               }
            } else {
               stbi_uc *y = coutput[0];
               if (n == 1)
                  for (i=0; i < z->s->img_x; ++i) out[i] = y[i];
               else
                  for (i=0; i < z->s->img_x; ++i) { *out++ = y[i]; *out++ = 255; }
            }
         }
      }
      stbi__cleanup_jpeg(z);
      *out_x = z->s->img_x;
      *out_y = z->s->img_y;
      if (comp) *comp = z->s->img_n >= 3 ? 3 : 1; // report original components, not output
      return output;
   }
}

static void *stbi__jpeg_load(stbi__context *s, int *x, int *y, int *comp, int req_comp, stbi__result_info *ri)
{
   unsigned char* result;
   stbi__jpeg* j = (stbi__jpeg*) stbi__malloc(sizeof(stbi__jpeg));
   if (!j) return stbi__errpuc("outofmem", "Out of memory");
   STBI_NOTUSED(ri);
   j->s = s;
   stbi__setup_jpeg(j);
   result = load_jpeg_image(j, x,y,comp,req_comp);
   STBI_FREE(j);
   return result;
}

static int stbi__jpeg_test(stbi__context *s)
{
   int r;
   stbi__jpeg* j = (stbi__jpeg*)stbi__malloc(sizeof(stbi__jpeg));
   if (!j) return stbi__err("outofmem", "Out of memory");
   j->s = s;
   stbi__setup_jpeg(j);
   r = stbi__decode_jpeg_header(j, STBI__SCAN_type);
   stbi__rewind(s);
   STBI_FREE(j);
   return r;
}

static int stbi__jpeg_info_raw(stbi__jpeg *j, int *x, int *y, int *comp)
{
   if (!stbi__decode_jpeg_header(j, STBI__SCAN_header)) {
      stbi__rewind( j->s );
      return 0;
   }
   if (x) *x = j->s->img_x;
   if (y) *y = j->s->img_y;
   if (comp) *comp = j->s->img_n >= 3 ? 3 : 1;
   return 1;
}

static int stbi__jpeg_info(stbi__context *s, int *x, int *y, int *comp)
{
   int result;
   stbi__jpeg* j = (stbi__jpeg*) (stbi__malloc(sizeof(stbi__jpeg)));
   if (!j) return stbi__err("outofmem", "Out of memory");
   j->s = s;
   result = stbi__jpeg_info_raw(j, x, y, comp);
   STBI_FREE(j);
   return result;
}
#endif

// public domain zlib decode    v0.2  Sean Barrett 2006-11-18
//    simple implementation
//      - all input must be provided in an upfront buffer
//      - all output is written to a single output buffer (can malloc/realloc)
//    performance
//      - fast huffman

#ifndef STBI_NO_ZLIB

// fast-way is faster to check than jpeg huffman, but slow way is slower
#define STBI__ZFAST_BITS  9 // accelerate all cases in default tables
#define STBI__ZFAST_MASK  ((1 << STBI__ZFAST_BITS) - 1)
#define STBI__ZNSYMS 288 // number of symbols in literal/length alphabet

// zlib-style huffman encoding
// (jpegs packs from left, zlib from right, so can't share code)
typedef struct
{
   stbi__uint16 fast[1 << STBI__ZFAST_BITS];
   stbi__uint16 firstcode[16];
   int maxcode[17];
   stbi__uint16 firstsymbol[16];
   stbi_uc  size[STBI__ZNSYMS];
   stbi__uint16 value[STBI__ZNSYMS];
} stbi__zhuffman;

stbi_inline static int stbi__bitreverse16(int n)
{
  n = ((n & 0xAAAA) >>  1) | ((n & 0x5555) << 1);
  n = ((n & 0xCCCC) >>  2) | ((n & 0x3333) << 2);
  n = ((n & 0xF0F0) >>  4) | ((n & 0x0F0F) << 4);
  n = ((n & 0xFF00) >>  8) | ((n & 0x00FF) << 8);
  return n;
}

stbi_inline static int stbi__bit_reverse(int v, int bits)
{
   STBI_ASSERT(bits <= 16);
   // to bit reverse n bits, reverse 16 and shift
   // e.g. 11 bits, bit reverse and shift away 5
   return stbi__bitreverse16(v) >> (16-bits);
}

static int stbi__zbuild_huffman(stbi__zhuffman *z, const stbi_uc *sizelist, int num)
{
   int i,k=0;
   int code, next_code[16], sizes[17];

   // DEFLATE spec for generating codes
   memset(sizes, 0, sizeof(sizes));
   memset(z->fast, 0, sizeof(z->fast));
   for (i=0; i < num; ++i)
      ++sizes[sizelist[i]];
   sizes[0] = 0;
   for (i=1; i < 16; ++i)
      if (sizes[i] > (1 << i))
         return stbi__err("bad sizes", "Corrupt PNG");
   code = 0;
   for (i=1; i < 16; ++i) {
      next_code[i] = code;
      z->firstcode[i] = (stbi__uint16) code;
      z->firstsymbol[i] = (stbi__uint16) k;
      code = (code + sizes[i]);
      if (sizes[i])
         if (code-1 >= (1 << i)) return stbi__err("bad codelengths","Corrupt PNG");
      z->maxcode[i] = code << (16-i); // preshift for inner loop
      code <<= 1;
      k += sizes[i];
   }
   z->maxcode[16] = 0x10000; // sentinel
   for (i=0; i < num; ++i) {
      int s = sizelist[i];
      if (s) {
         int c = next_code[s] - z->firstcode[s] + z->firstsymbol[s];
         stbi__uint16 fastv = (stbi__uint16) ((s << 9) | i);
         z->size [c] = (stbi_uc     ) s;
         z->value[c] = (stbi__uint16) i;
         if (s <= STBI__ZFAST_BITS) {
            int j = stbi__bit_reverse(next_code[s],s);
            while (j < (1 << STBI__ZFAST_BITS)) {
               z->fast[j] = fastv;
               j += (1 << s);
            }
         }
         ++next_code[s];
      }
   }
   return 1;
}

// zlib-from-memory implementation for PNG reading
//    because PNG allows splitting the zlib stream arbitrarily,
//    and it's annoying structurally to have PNG call ZLIB call PNG,
//    we require PNG read all the IDATs and combine them into a single
//    memory buffer

typedef struct
{
   stbi_uc *zbuffer, *zbuffer_end;
   int num_bits;
   stbi__uint32 code_buffer;

   char *zout;
   char *zout_start;
   char *zout_end;
   int   z_expandable;

   stbi__zhuffman z_length, z_distance;
} stbi__zbuf;

stbi_inline static int stbi__zeof(stbi__zbuf *z)
{
   return (z->zbuffer >= z->zbuffer_end);
}

stbi_inline static stbi_uc stbi__zget8(stbi__zbuf *z)
{
   return stbi__zeof(z) ? 0 : *z->zbuffer++;
}

static void stbi__fill_bits(stbi__zbuf *z)
{
   do {
      if (z->code_buffer >= (1U << z->num_bits)) {
        z->zbuffer = z->zbuffer_end;  /* treat this as EOF so we fail. */
        return;
      }
      z->code_buffer |= (unsigned int) stbi__zget8(z) << z->num_bits;
      z->num_bits += 8;
   } while (z->num_bits <= 24);
}

stbi_inline static unsigned int stbi__zreceive(stbi__zbuf *z, int n)
{
   unsigned int k;
   if (z->num_bits < n) stbi__fill_bits(z);
   k = z->code_buffer & ((1 << n) - 1);
   z->code_buffer >>= n;
   z->num_bits -= n;
   return k;
}

static int stbi__zhuffman_decode_slowpath(stbi__zbuf *a, stbi__zhuffman *z)
{
   int b,s,k;
   // not resolved by fast table, so compute it the slow way
   // use jpeg approach, which requires MSbits at top
   k = stbi__bit_reverse(a->code_buffer, 16);
   for (s=STBI__ZFAST_BITS+1; ; ++s)
      if (k < z->maxcode[s])
         break;
   if (s >= 16) return -1; // invalid code!
   // code size is s, so:
   b = (k >> (16-s)) - z->firstcode[s] + z->firstsymbol[s];
   if (b >= STBI__ZNSYMS) return -1; // some data was corrupt somewhere!
   if (z->size[b] != s) return -1;  // was originally an assert, but report failure instead.
   a->code_buffer >>= s;
   a->num_bits -= s;
   return z->value[b];
}

stbi_inline static int stbi__zhuffman_decode(stbi__zbuf *a, stbi__zhuffman *z)
{
   int b,s;
   if (a->num_bits < 16) {
      if (stbi__zeof(a)) {
         return -1;   /* report error for unexpected end of data. */
      }
      stbi__fill_bits(a);
   }
   b = z->fast[a->code_buffer & STBI__ZFAST_MASK];
   if (b) {
      s = b >> 9;
      a->code_buffer >>= s;
      a->num_bits -= s;
      return b & 511;
   }
   return stbi__zhuffman_decode_slowpath(a, z);
}

static int stbi__zexpand(stbi__zbuf *z, char *zout, int n)  // need to make room for n bytes
{
   char *q;
   unsigned int cur, limit, old_limit;
   z->zout = zout;
   if (!z->z_expandable) return stbi__err("output buffer limit","Corrupt PNG");
   cur   = (unsigned int) (z->zout - z->zout_start);
   limit = old_limit = (unsigned) (z->zout_end - z->zout_start);
   if (UINT_MAX - cur < (unsigned) n) return stbi__err("outofmem", "Out of memory");
   while (cur + n > limit) {
      if(limit > UINT_MAX / 2) return stbi__err("outofmem", "Out of memory");
      limit *= 2;
   }
   q = (char *) STBI_REALLOC_SIZED(z->zout_start, old_limit, limit);
   STBI_NOTUSED(old_limit);
   if (q == NULL) return stbi__err("outofmem", "Out of memory");
   z->zout_start = q;
   z->zout       = q + cur;
   z->zout_end   = q + limit;
   return 1;
}

static const int stbi__zlength_base[31] = {
   3,4,5,6,7,8,9,10,11,13,
   15,17,19,23,27,31,35,43,51,59,
   67,83,99,115,131,163,195,227,258,0,0 };

static const int stbi__zlength_extra[31]=
{ 0,0,0,0,0,0,0,0,1,1,1,1,2,2,2,2,3,3,3,3,4,4,4,4,5,5,5,5,0,0,0 };

static const int stbi__zdist_base[32] = { 1,2,3,4,5,7,9,13,17,25,33,49,65,97,129,193,
257,385,513,769,1025,1537,2049,3073,4097,6145,8193,12289,16385,24577,0,0};

static const int stbi__zdist_extra[32] =
{ 0,0,0,0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,13,13};

static int stbi__parse_huffman_block(stbi__zbuf *a)
{
   char *zout = a->zout;
   for(;;) {
      int z = stbi__zhuffman_decode(a, &a->z_length);
      if (z < 256) {
         if (z < 0) return stbi__err("bad huffman code","Corrupt PNG"); // error in huffman codes
         if (zout >= a->zout_end) {
            if (!stbi__zexpand(a, zout, 1)) return 0;
            zout = a->zout;
         }
         *zout++ = (char) z;
      } else {
         stbi_uc *p;
         int len,dist;
         if (z == 256) {
            a->zout = zout;
            return 1;
         }
         z -= 257;
         len = stbi__zlength_base[z];
         if (stbi__zlength_extra[z]) len += stbi__zreceive(a, stbi__zlength_extra[z]);
         z = stbi__zhuffman_decode(a, &a->z_distance);
         if (z < 0) return stbi__err("bad huffman code","Corrupt PNG");
         dist = stbi__zdist_base[z];
         if (stbi__zdist_extra[z]) dist += stbi__zreceive(a, stbi__zdist_extra[z]);
         if (zout - a->zout_start < dist) return stbi__err("bad dist","Corrupt PNG");
         if (zout + len > a->zout_end) {
            if (!stbi__zexpand(a, zout, len)) return 0;
            zout = a->zout;
         }
         p = (stbi_uc *) (zout - dist);
         if (dist == 1) { // run of one byte; common in images.
            stbi_uc v = *p;
            if (len) { do *zout++ = v; while (--len); }
         } else {
            if (len) { do *zout++ = *p++; while (--len); }
         }
      }
   }
}

static int stbi__compute_huffman_codes(stbi__zbuf *a)
{
   static const stbi_uc length_dezigzag[19] = { 16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15 };
   stbi__zhuffman z_codelength;
   stbi_uc lencodes[286+32+137];//padding for maximum single op
   stbi_uc codelength_sizes[19];
   int i,n;

   int hlit  = stbi__zreceive(a,5) + 257;
   int hdist = stbi__zreceive(a,5) + 1;
   int hclen = stbi__zreceive(a,4) + 4;
   int ntot  = hlit + hdist;

   memset(codelength_sizes, 0, sizeof(codelength_sizes));
   for (i=0; i < hclen; ++i) {
      int s = stbi__zreceive(a,3);
      codelength_sizes[length_dezigzag[i]] = (stbi_uc) s;
   }
   if (!stbi__zbuild_huffman(&z_codelength, codelength_sizes, 19)) return 0;

   n = 0;
   while (n < ntot) {
      int c = stbi__zhuffman_decode(a, &z_codelength);
      if (c < 0 || c >= 19) return stbi__err("bad codelengths", "Corrupt PNG");
      if (c < 16)
         lencodes[n++] = (stbi_uc) c;
      else {
         stbi_uc fill = 0;
         if (c == 16) {
            c = stbi__zreceive(a,2)+3;
            if (n == 0) return stbi__err("bad codelengths", "Corrupt PNG");
            fill = lencodes[n-1];
         } else if (c == 17) {
            c = stbi__zreceive(a,3)+3;
         } else if (c == 18) {
            c = stbi__zreceive(a,7)+11;
         } else {
            return stbi__err("bad codelengths", "Corrupt PNG");
         }
         if (ntot - n < c) return stbi__err("bad codelengths", "Corrupt PNG");
         memset(lencodes+n, fill, c);
         n += c;
      }
   }
   if (n != ntot) return stbi__err("bad codelengths","Corrupt PNG");
   if (!stbi__zbuild_huffman(&a->z_length, lencodes, hlit)) return 0;
   if (!stbi__zbuild_huffman(&a->z_distance, lencodes+hlit, hdist)) return 0;
   return 1;
}

static int stbi__parse_uncompressed_block(stbi__zbuf *a)
{
   stbi_uc header[4];
   int len,nlen,k;
   if (a->num_bits & 7)
      stbi__zreceive(a, a->num_bits & 7); // discard
   // drain the bit-packed data into header
   k = 0;
   while (a->num_bits > 0) {
      header[k++] = (stbi_uc) (a->code_buffer & 255); // suppress MSVC run-time check
      a->code_buffer >>= 8;
      a->num_bits -= 8;
   }
   if (a->num_bits < 0) return stbi__err("zlib corrupt","Corrupt PNG");
   // now fill header the normal way
   while (k < 4)
      header[k++] = stbi__zget8(a);
   len  = header[1] * 256 + header[0];
   nlen = header[3] * 256 + header[2];
   if (nlen != (len ^ 0xffff)) return stbi__err("zlib corrupt","Corrupt PNG");
   if (a->zbuffer + len > a->zbuffer_end) return stbi__err("read past buffer","Corrupt PNG");
   if (a->zout + len > a->zout_end)
      if (!stbi__zexpand(a, a->zout, len)) return 0;
   memcpy(a->zout, a->zbuffer, len);
   a->zbuffer += len;
   a->zout += len;
   return 1;
}

static int stbi__parse_zlib_header(stbi__zbuf *a)
{
   int cmf   = stbi__zget8(a);
   int cm    = cmf & 15;
   /* int cinfo = cmf >> 4; */
   int flg   = stbi__zget8(a);
   if (stbi__zeof(a)) return stbi__err("bad zlib header","Corrupt PNG"); // zlib spec
   if ((cmf*256+flg) % 31 != 0) return stbi__err("bad zlib header","Corrupt PNG"); // zlib spec
   if (flg & 32) return stbi__err("no preset dict","Corrupt PNG"); // preset dictionary not allowed in png
   if (cm != 8) return stbi__err("bad compression","Corrupt PNG"); // DEFLATE required for png
   // window = 1 << (8 + cinfo)... but who cares, we fully buffer output
   return 1;
}

static const stbi_uc stbi__zdefault_length[STBI__ZNSYMS] =
{
   8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8, 8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,
   8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8, 8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,
   8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8, 8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,
   8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8, 8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,
   8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8, 9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,
   9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9, 9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,
   9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9, 9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,
   9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9, 9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,
   7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7, 7,7,7,7,7,7,7,7,8,8,8,8,8,8,8,8
};
static const stbi_uc stbi__zdefault_distance[32] =
{
   5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5
};
/*
Init algorithm:
{
   int i;   // use <= to match clearly with spec
   for (i=0; i <= 143; ++i)     stbi__zdefault_length[i]   = 8;
   for (   ; i <= 255; ++i)     stbi__zdefault_length[i]   = 9;
   for (   ; i <= 279; ++i)     stbi__zdefault_length[i]   = 7;
   for (   ; i <= 287; ++i)     stbi__zdefault_length[i]   = 8;

   for (i=0; i <=  31; ++i)     stbi__zdefault_distance[i] = 5;
}
*/

static int stbi__parse_zlib(stbi__zbuf *a, int parse_header)
{
   int final, type;
   if (parse_header)
      if (!stbi__parse_zlib_header(a)) return 0;
   a->num_bits = 0;
   a->code_buffer = 0;
   do {
      final = stbi__zreceive(a,1);
      type = stbi__zreceive(a,2);
      if (type == 0) {
         if (!stbi__parse_uncompressed_block(a)) return 0;
      } else if (type == 3) {
         return 0;
      } else {
         if (type == 1) {
            // use fixed code lengths
            if (!stbi__zbuild_huffman(&a->z_length  , stbi__zdefault_length  , STBI__ZNSYMS)) return 0;
            if (!stbi__zbuild_huffman(&a->z_distance, stbi__zdefault_distance,  32)) return 0;
         } else {
            if (!stbi__compute_huffman_codes(a)) return 0;
         }
         if (!stbi__parse_huffman_block(a)) return 0;
      }
   } while (!final);
   return 1;
}

static int stbi__do_zlib(stbi__zbuf *a, char *obuf, int olen, int exp, int parse_header)
{
   a->zout_start = obuf;
   a->zout       = obuf;
   a->zout_end   = obuf + olen;
   a->z_expandable = exp;

   return stbi__parse_zlib(a, parse_header);
}

STBIDEF char *stbi_zlib_decode_malloc_guesssize(const char *buffer, int len, int initial_size, int *outlen)
{
   stbi__zbuf a;
   char *p = (char *) stbi__malloc(initial_size);
   if (p == NULL) return NULL;
   a.zbuffer = (stbi_uc *) buffer;
   a.zbuffer_end = (stbi_uc *) buffer + len;
   if (stbi__do_zlib(&a, p, initial_size, 1, 1)) {
      if (outlen) *outlen = (int) (a.zout - a.zout_start);
      return a.zout_start;
   } else {
      STBI_FREE(a.zout_start);
      return NULL;
   }
}

STBIDEF char *stbi_zlib_decode_malloc(char const *buffer, int len, int *outlen)
{
   return stbi_zlib_decode_malloc_guesssize(buffer, len, 16384, outlen);
}

STBIDEF char *stbi_zlib_decode_malloc_guesssize_headerflag(const char *buffer, int len, int initial_size, int *outlen, int parse_header)
{
   stbi__zbuf a;
   char *p = (char *) stbi__malloc(initial_size);
   if (p == NULL) return NULL;
   a.zbuffer = (stbi_uc *) buffer;
   a.zbuffer_end = (stbi_uc *) buffer + len;
   if (stbi__do_zlib(&a, p, initial_size, 1, parse_header)) {
      if (outlen) *outlen = (int) (a.zout - a.zout_start);
      return a.zout_start;
   } else {
      STBI_FREE(a.zout_start);
      return NULL;
   }
}

STBIDEF int stbi_zlib_decode_buffer(char *obuffer, int olen, char const *ibuffer, int ilen)
{
   stbi__zbuf a;
   a.zbuffer = (stbi_uc *) ibuffer;
   a.zbuffer_end = (stbi_uc *) ibuffer + ilen;
   if (stbi__do_zlib(&a, obuffer, olen, 0, 1))
      return (int) (a.zout - a.zout_start);
   else
      return -1;
}

STBIDEF char *stbi_zlib_decode_noheader_malloc(char const *buffer, int len, int *outlen)
{
   stbi__zbuf a;
   char *p = (char *) stbi__malloc(16384);
   if (p == NULL) return NULL;
   a.zbuffer = (stbi_uc *) buffer;
   a.zbuffer_end = (stbi_uc *) buffer+len;
   if (stbi__do_zlib(&a, p, 16384, 1, 0)) {
      if (outlen) *outlen = (int) (a.zout - a.zout_start);
      return a.zout_start;
   } else {
      STBI_FREE(a.zout_start);
      return NULL;
   }
}

STBIDEF int stbi_zlib_decode_noheader_buffer(char *obuffer, int olen, const char *ibuffer, int ilen)
{
   stbi__zbuf a;
   a.zbuffer = (stbi_uc *) ibuffer;
   a.zbuffer_end = (stbi_uc *) ibuffer + ilen;
   if (stbi__do_zlib(&a, obuffer, olen, 0, 0))
      return (int) (a.zout - a.zout_start);
   else
      return -1;
}
#endif

// public domain "baseline" PNG decoder   v0.10  Sean Barrett 2006-11-18
//    simple implementation
//      - only 8-bit samples
//      - no CRC checking
//      - allocates lots of intermediate memory
//        - avoids problem of streaming data between subsystems
//        - avoids explicit window management
//    performance
//      - uses stb_zlib, a PD zlib implementation with fast huffman decoding

#ifndef STBI_NO_PNG
typedef struct
{
   stbi__uint32 length;
   stbi__uint32 type;
} stbi__pngchunk;

static stbi__pngchunk stbi__get_chunk_header(stbi__context *s)
{
   stbi__pngchunk c;
   c.length = stbi__get32be(s);
   c.type   = stbi__get32be(s);
   return c;
}

static int stbi__check_png_header(stbi__context *s)
{
   static const stbi_uc png_sig[8] = { 137,80,78,71,13,10,26,10 };
   int i;
   for (i=0; i < 8; ++i)
      if (stbi__get8(s) != png_sig[i]) return stbi__err("bad png sig","Not a PNG");
   return 1;
}

typedef struct
{
   stbi__context *s;
   stbi_uc *idata, *expanded, *out;
   int depth;
} stbi__png;


enum {
   STBI__F_none=0,
   STBI__F_sub=1,
   STBI__F_up=2,
   STBI__F_avg=3,
   STBI__F_paeth=4,
   // synthetic filters used for first scanline to avoid needing a dummy row of 0s
   STBI__F_avg_first,
   STBI__F_paeth_first
};

static stbi_uc first_row_filter[5] =
{
   STBI__F_none,
   STBI__F_sub,
   STBI__F_none,
   STBI__F_avg_first,
   STBI__F_paeth_first
};

static int stbi__paeth(int a, int b, int c)
{
   int p = a + b - c;
   int pa = abs(p-a);
   int pb = abs(p-b);
   int pc = abs(p-c);
   if (pa <= pb && pa <= pc) return a;
   if (pb <= pc) return b;
   return c;
}

static const stbi_uc stbi__depth_scale_table[9] = { 0, 0xff, 0x55, 0, 0x11, 0,0,0, 0x01 };

// create the png data from post-deflated data
static int stbi__create_png_image_raw(stbi__png *a, stbi_uc *raw, stbi__uint32 raw_len, int out_n, stbi__uint32 x, stbi__uint32 y, int depth, int color)
{
   int bytes = (depth == 16? 2 : 1);
   stbi__context *s = a->s;
   stbi__uint32 i,j,stride = x*out_n*bytes;
   stbi__uint32 img_len, img_width_bytes;
   int k;
   int img_n = s->img_n; // copy it into a local for later

   int output_bytes = out_n*bytes;
   int filter_bytes = img_n*bytes;
   int width = x;

   STBI_ASSERT(out_n == s->img_n || out_n == s->img_n+1);
   a->out = (stbi_uc *) stbi__malloc_mad3(x, y, output_bytes, 0); // extra bytes to write off the end into
   if (!a->out) return stbi__err("outofmem", "Out of memory");

   if (!stbi__mad3sizes_valid(img_n, x, depth, 7)) return stbi__err("too large", "Corrupt PNG");
   img_width_bytes = (((img_n * x * depth) + 7) >> 3);
   img_len = (img_width_bytes + 1) * y;

   // we used to check for exact match between raw_len and img_len on non-interlaced PNGs,
   // but issue #276 reported a PNG in the wild that had extra data at the end (all zeros),
   // so just check for raw_len < img_len always.
   if (raw_len < img_len) return stbi__err("not enough pixels","Corrupt PNG");

   for (j=0; j < y; ++j) {
      stbi_uc *cur = a->out + stride*j;
      stbi_uc *prior;
      int filter = *raw++;

      if (filter > 4)
         return stbi__err("invalid filter","Corrupt PNG");

      if (depth < 8) {
         if (img_width_bytes > x) return stbi__err("invalid width","Corrupt PNG");
         cur += x*out_n - img_width_bytes; // store output to the rightmost img_len bytes, so we can decode in place
         filter_bytes = 1;
         width = img_width_bytes;
      }
      prior = cur - stride; // bugfix: need to compute this after 'cur +=' computation above

      // if first row, use special filter that doesn't sample previous row
      if (j == 0) filter = first_row_filter[filter];

      // handle first byte explicitly
      for (k=0; k < filter_bytes; ++k) {
         switch (filter) {
            case STBI__F_none       : cur[k] = raw[k]; break;
            case STBI__F_sub        : cur[k] = raw[k]; break;
            case STBI__F_up         : cur[k] = STBI__BYTECAST(raw[k] + prior[k]); break;
            case STBI__F_avg        : cur[k] = STBI__BYTECAST(raw[k] + (prior[k]>>1)); break;
            case STBI__F_paeth      : cur[k] = STBI__BYTECAST(raw[k] + stbi__paeth(0,prior[k],0)); break;
            case STBI__F_avg_first  : cur[k] = raw[k]; break;
            case STBI__F_paeth_first: cur[k] = raw[k]; break;
         }
      }

      if (depth == 8) {
         if (img_n != out_n)
            cur[img_n] = 255; // first pixel
         raw += img_n;
         cur += out_n;
         prior += out_n;
      } else if (depth == 16) {
         if (img_n != out_n) {
            cur[filter_bytes]   = 255; // first pixel top byte
            cur[filter_bytes+1] = 255; // first pixel bottom byte
         }
         raw += filter_bytes;
         cur += output_bytes;
         prior += output_bytes;
      } else {
         raw += 1;
         cur += 1;
         prior += 1;
      }

      // this is a little gross, so that we don't switch per-pixel or per-component
      if (depth < 8 || img_n == out_n) {
         int nk = (width - 1)*filter_bytes;
         #define STBI__CASE(f) \
             case f:     \
                for (k=0; k < nk; ++k)
         switch (filter) {
            // "none" filter turns into a memcpy here; make that explicit.
            case STBI__F_none:         memcpy(cur, raw, nk); break;
            STBI__CASE(STBI__F_sub)          { cur[k] = STBI__BYTECAST(raw[k] + cur[k-filter_bytes]); } break;
            STBI__CASE(STBI__F_up)           { cur[k] = STBI__BYTECAST(raw[k] + prior[k]); } break;
            STBI__CASE(STBI__F_avg)          { cur[k] = STBI__BYTECAST(raw[k] + ((prior[k] + cur[k-filter_bytes])>>1)); } break;
            STBI__CASE(STBI__F_paeth)        { cur[k] = STBI__BYTECAST(raw[k] + stbi__paeth(cur[k-filter_bytes],prior[k],prior[k-filter_bytes])); } break;
            STBI__CASE(STBI__F_avg_first)    { cur[k] = STBI__BYTECAST(raw[k] + (cur[k-filter_bytes] >> 1)); } break;
            STBI__CASE(STBI__F_paeth_first)  { cur[k] = STBI__BYTECAST(raw[k] + stbi__paeth(cur[k-filter_bytes],0,0)); } break;
         }
         #undef STBI__CASE
         raw += nk;
      } else {
         STBI_ASSERT(img_n+1 == out_n);
         #define STBI__CASE(f) \
             case f:     \
                for (i=x-1; i >= 1; --i, cur[filter_bytes]=255,raw+=filter_bytes,cur+=output_bytes,prior+=output_bytes) \
                   for (k=0; k < filter_bytes; ++k)
         switch (filter) {
            STBI__CASE(STBI__F_none)         { cur[k] = raw[k]; } break;
            STBI__CASE(STBI__F_sub)          { cur[k] = STBI__BYTECAST(raw[k] + cur[k- output_bytes]); } break;
            STBI__CASE(STBI__F_up)           { cur[k] = STBI__BYTECAST(raw[k] + prior[k]); } break;
            STBI__CASE(STBI__F_avg)          { cur[k] = STBI__BYTECAST(raw[k] + ((prior[k] + cur[k- output_bytes])>>1)); } break;
            STBI__CASE(STBI__F_paeth)        { cur[k] = STBI__BYTECAST(raw[k] + stbi__paeth(cur[k- output_bytes],prior[k],prior[k- output_bytes])); } break;
            STBI__CASE(STBI__F_avg_first)    { cur[k] = STBI__BYTECAST(raw[k] + (cur[k- output_bytes] >> 1)); } break;
            STBI__CASE(STBI__F_paeth_first)  { cur[k] = STBI__BYTECAST(raw[k] + stbi__paeth(cur[k- output_bytes],0,0)); } break;
         }
         #undef STBI__CASE

         // the loop above sets the high byte of the pixels' alpha, but for
         // 16 bit png files we also need the low byte set. we'll do that here.
         if (depth == 16) {
            cur = a->out + stride*j; // start at the beginning of the row again
            for (i=0; i < x; ++i,cur+=output_bytes) {
               cur[filter_bytes+1] = 255;
            }
         }
      }
   }

   // we make a separate pass to expand bits to pixels; for performance,
   // this could run two scanlines behind the above code, so it won't
   // intefere with filtering but will still be in the cache.
   if (depth < 8) {
      for (j=0; j < y; ++j) {
         stbi_uc *cur = a->out + stride*j;
         stbi_uc *in  = a->out + stride*j + x*out_n - img_width_bytes;
         // unpack 1/2/4-bit into a 8-bit buffer. allows us to keep the common 8-bit path optimal at minimal cost for 1/2/4-bit
         // png guarante byte alignment, if width is not multiple of 8/4/2 we'll decode dummy trailing data that will be skipped in the later loop
         stbi_uc scale = (color == 0) ? stbi__depth_scale_table[depth] : 1; // scale grayscale values to 0..255 range

         // note that the final byte might overshoot and write more data than desired.
         // we can allocate enough data that this never writes out of memory, but it
         // could also overwrite the next scanline. can it overwrite non-empty data
         // on the next scanline? yes, consider 1-pixel-wide scanlines with 1-bit-per-pixel.
         // so we need to explicitly clamp the final ones

         if (depth == 4) {
            for (k=x*img_n; k >= 2; k-=2, ++in) {
               *cur++ = scale * ((*in >> 4)       );
               *cur++ = scale * ((*in     ) & 0x0f);
            }
            if (k > 0) *cur++ = scale * ((*in >> 4)       );
         } else if (depth == 2) {
            for (k=x*img_n; k >= 4; k-=4, ++in) {
               *cur++ = scale * ((*in >> 6)       );
               *cur++ = scale * ((*in >> 4) & 0x03);
               *cur++ = scale * ((*in >> 2) & 0x03);
               *cur++ = scale * ((*in     ) & 0x03);
            }
            if (k > 0) *cur++ = scale * ((*in >> 6)       );
            if (k > 1) *cur++ = scale * ((*in >> 4) & 0x03);
            if (k > 2) *cur++ = scale * ((*in >> 2) & 0x03);
         } else if (depth == 1) {
            for (k=x*img_n; k >= 8; k-=8, ++in) {
               *cur++ = scale * ((*in >> 7)       );
               *cur++ = scale * ((*in >> 6) & 0x01);
               *cur++ = scale * ((*in >> 5) & 0x01);
               *cur++ = scale * ((*in >> 4) & 0x01);
               *cur++ = scale * ((*in >> 3) & 0x01);
               *cur++ = scale * ((*in >> 2) & 0x01);
               *cur++ = scale * ((*in >> 1) & 0x01);
               *cur++ = scale * ((*in     ) & 0x01);
            }
            if (k > 0) *cur++ = scale * ((*in >> 7)       );
            if (k > 1) *cur++ = scale * ((*in >> 6) & 0x01);
            if (k > 2) *cur++ = scale * ((*in >> 5) & 0x01);
            if (k > 3) *cur++ = scale * ((*in >> 4) & 0x01);
            if (k > 4) *cur++ = scale * ((*in >> 3) & 0x01);
            if (k > 5) *cur++ = scale * ((*in >> 2) & 0x01);
            if (k > 6) *cur++ = scale * ((*in >> 1) & 0x01);
         }
         if (img_n != out_n) {
            int q;
            // insert alpha = 255
            cur = a->out + stride*j;
            if (img_n == 1) {
               for (q=x-1; q >= 0; --q) {
                  cur[q*2+1] = 255;
                  cur[q*2+0] = cur[q];
               }
            } else {
               STBI_ASSERT(img_n == 3);
               for (q=x-1; q >= 0; --q) {
                  cur[q*4+3] = 255;
                  cur[q*4+2] = cur[q*3+2];
                  cur[q*4+1] = cur[q*3+1];
                  cur[q*4+0] = cur[q*3+0];
               }
            }
         }
      }
   } else if (depth == 16) {
      // force the image data from big-endian to platform-native.
      // this is done in a separate pass due to the decoding relying
      // on the data being untouched, but could probably be done
      // per-line during decode if care is taken.
      stbi_uc *cur = a->out;
      stbi__uint16 *cur16 = (stbi__uint16*)cur;

      for(i=0; i < x*y*out_n; ++i,cur16++,cur+=2) {
         *cur16 = (cur[0] << 8) | cur[1];
      }
   }

   return 1;
}

static int stbi__create_png_image(stbi__png *a, stbi_uc *image_data, stbi__uint32 image_data_len, int out_n, int depth, int color, int interlaced)
{
   int bytes = (depth == 16 ? 2 : 1);
   int out_bytes = out_n * bytes;
   stbi_uc *final;
   int p;
   if (!interlaced)
      return stbi__create_png_image_raw(a, image_data, image_data_len, out_n, a->s->img_x, a->s->img_y, depth, color);

   // de-interlacing
   final = (stbi_uc *) stbi__malloc_mad3(a->s->img_x, a->s->img_y, out_bytes, 0);
   if (!final) return stbi__err("outofmem", "Out of memory");
   for (p=0; p < 7; ++p) {
      int xorig[] = { 0,4,0,2,0,1,0 };
      int yorig[] = { 0,0,4,0,2,0,1 };
      int xspc[]  = { 8,8,4,4,2,2,1 };
      int yspc[]  = { 8,8,8,4,4,2,2 };
      int i,j,x,y;
      // pass1_x[4] = 0, pass1_x[5] = 1, pass1_x[12] = 1
      x = (a->s->img_x - xorig[p] + xspc[p]-1) / xspc[p];
      y = (a->s->img_y - yorig[p] + yspc[p]-1) / yspc[p];
      if (x && y) {
         stbi__uint32 img_len = ((((a->s->img_n * x * depth) + 7) >> 3) + 1) * y;
         if (!stbi__create_png_image_raw(a, image_data, image_data_len, out_n, x, y, depth, color)) {
            STBI_FREE(final);
            return 0;
         }
         for (j=0; j < y; ++j) {
            for (i=0; i < x; ++i) {
               int out_y = j*yspc[p]+yorig[p];
               int out_x = i*xspc[p]+xorig[p];
               memcpy(final + out_y*a->s->img_x*out_bytes + out_x*out_bytes,
                      a->out + (j*x+i)*out_bytes, out_bytes);
            }
         }
         STBI_FREE(a->out);
         image_data += img_len;
         image_data_len -= img_len;
      }
   }
   a->out = final;

   return 1;
}

static int stbi__compute_transparency(stbi__png *z, stbi_uc tc[3], int out_n)
{
   stbi__context *s = z->s;
   stbi__uint32 i, pixel_count = s->img_x * s->img_y;
   stbi_uc *p = z->out;

   // compute color-based transparency, assuming we've
   // already got 255 as the alpha value in the output
   STBI_ASSERT(out_n == 2 || out_n == 4);

   if (out_n == 2) {
      for (i=0; i < pixel_count; ++i) {
         p[1] = (p[0] == tc[0] ? 0 : 255);
         p += 2;
      }
   } else {
      for (i=0; i < pixel_count; ++i) {
         if (p[0] == tc[0] && p[1] == tc[1] && p[2] == tc[2])
            p[3] = 0;
         p += 4;
      }
   }
   return 1;
}

static int stbi__compute_transparency16(stbi__png *z, stbi__uint16 tc[3], int out_n)
{
   stbi__context *s = z->s;
   stbi__uint32 i, pixel_count = s->img_x * s->img_y;
   stbi__uint16 *p = (stbi__uint16*) z->out;

   // compute color-based transparency, assuming we've
   // already got 65535 as the alpha value in the output
   STBI_ASSERT(out_n == 2 || out_n == 4);

   if (out_n == 2) {
      for (i = 0; i < pixel_count; ++i) {
         p[1] = (p[0] == tc[0] ? 0 : 65535);
         p += 2;
      }
   } else {
      for (i = 0; i < pixel_count; ++i) {
         if (p[0] == tc[0] && p[1] == tc[1] && p[2] == tc[2])
            p[3] = 0;
         p += 4;
      }
   }
   return 1;
}

static int stbi__expand_png_palette(stbi__png *a, stbi_uc *palette, int len, int pal_img_n)
{
   stbi__uint32 i, pixel_count = a->s->img_x * a->s->img_y;
   stbi_uc *p, *temp_out, *orig = a->out;

   p = (stbi_uc *) stbi__malloc_mad2(pixel_count, pal_img_n, 0);
   if (p == NULL) return stbi__err("outofmem", "Out of memory");

   // between here and free(out) below, exitting would leak
   temp_out = p;

   if (pal_img_n == 3) {
      for (i=0; i < pixel_count; ++i) {
         int n = orig[i]*4;
         p[0] = palette[n  ];
         p[1] = palette[n+1];
         p[2] = palette[n+2];
         p += 3;
      }
   } else {
      for (i=0; i < pixel_count; ++i) {
         int n = orig[i]*4;
         p[0] = palette[n  ];
         p[1] = palette[n+1];
         p[2] = palette[n+2];
         p[3] = palette[n+3];
         p += 4;
      }
   }
   STBI_FREE(a->out);
   a->out = temp_out;

   STBI_NOTUSED(len);

   return 1;
}

static int stbi__unpremultiply_on_load_global = 0;
static int stbi__de_iphone_flag_global = 0;

STBIDEF void stbi_set_unpremultiply_on_load(int flag_true_if_should_unpremultiply)
{
   stbi__unpremultiply_on_load_global = flag_true_if_should_unpremultiply;
}

STBIDEF void stbi_convert_iphone_png_to_rgb(int flag_true_if_should_convert)
{
   stbi__de_iphone_flag_global = flag_true_if_should_convert;
}

#ifndef STBI_THREAD_LOCAL
#define stbi__unpremultiply_on_load  stbi__unpremultiply_on_load_global
#define stbi__de_iphone_flag  stbi__de_iphone_flag_global
#else
static STBI_THREAD_LOCAL int stbi__unpremultiply_on_load_local, stbi__unpremultiply_on_load_set;
static STBI_THREAD_LOCAL int stbi__de_iphone_flag_local, stbi__de_iphone_flag_set;

STBIDEF void stbi__unpremultiply_on_load_thread(int flag_true_if_should_unpremultiply)
{
   stbi__unpremultiply_on_load_local = flag_true_if_should_unpremultiply;
   stbi__unpremultiply_on_load_set = 1;
}

STBIDEF void stbi_convert_iphone_png_to_rgb_thread(int flag_true_if_should_convert)
{
   stbi__de_iphone_flag_local = flag_true_if_should_convert;
   stbi__de_iphone_flag_set = 1;
}

#define stbi__unpremultiply_on_load  (stbi__unpremultiply_on_load_set           \
                                       ? stbi__unpremultiply_on_load_local      \
                                       : stbi__unpremultiply_on_load_global)
#define stbi__de_iphone_flag  (stbi__de_iphone_flag_set                         \
                                ? stbi__de_iphone_flag_local                    \
                                : stbi__de_iphone_flag_global)
#endif // STBI_THREAD_LOCAL

static void stbi__de_iphone(stbi__png *z)
{
   stbi__context *s = z->s;
   stbi__uint32 i, pixel_count = s->img_x * s->img_y;
   stbi_uc *p = z->out;

   if (s->img_out_n == 3) {  // convert bgr to rgb
      for (i=0; i < pixel_count; ++i) {
         stbi_uc t = p[0];
         p[0] = p[2];
         p[2] = t;
         p += 3;
      }
   } else {
      STBI_ASSERT(s->img_out_n == 4);
      if (stbi__unpremultiply_on_load) {
         // convert bgr to rgb and unpremultiply
         for (i=0; i < pixel_count; ++i) {
            stbi_uc a = p[3];
            stbi_uc t = p[0];
            if (a) {
               stbi_uc half = a / 2;
               p[0] = (p[2] * 255 + half) / a;
               p[1] = (p[1] * 255 + half) / a;
               p[2] = ( t   * 255 + half) / a;
            } else {
               p[0] = p[2];
               p[2] = t;
            }
            p += 4;
         }
      } else {
         // convert bgr to rgb
         for (i=0; i < pixel_count; ++i) {
            stbi_uc t = p[0];
            p[0] = p[2];
            p[2] = t;
            p += 4;
         }
      }
   }
}

#define STBI__PNG_TYPE(a,b,c,d)  (((unsigned) (a) << 24) + ((unsigned) (b) << 16) + ((unsigned) (c) << 8) + (unsigned) (d))

static int stbi__parse_png_file(stbi__png *z, int scan, int req_comp)
{
   stbi_uc palette[1024], pal_img_n=0;
   stbi_uc has_trans=0, tc[3]={0};
   stbi__uint16 tc16[3];
   stbi__uint32 ioff=0, idata_limit=0, i, pal_len=0;
   int first=1,k,interlace=0, color=0, is_iphone=0;
   stbi__context *s = z->s;

   z->expanded = NULL;
   z->idata = NULL;
   z->out = NULL;

   if (!stbi__check_png_header(s)) return 0;

   if (scan == STBI__SCAN_type) return 1;

   for (;;) {
      stbi__pngchunk c = stbi__get_chunk_header(s);
      switch (c.type) {
         case STBI__PNG_TYPE('C','g','B','I'):
            is_iphone = 1;
            stbi__skip(s, c.length);
            break;
         case STBI__PNG_TYPE('I','H','D','R'): {
            int comp,filter;
            if (!first) return stbi__err("multiple IHDR","Corrupt PNG");
            first = 0;
            if (c.length != 13) return stbi__err("bad IHDR len","Corrupt PNG");
            s->img_x = stbi__get32be(s);
            s->img_y = stbi__get32be(s);
            if (s->img_y > STBI_MAX_DIMENSIONS) return stbi__err("too large","Very large image (corrupt?)");
            if (s->img_x > STBI_MAX_DIMENSIONS) return stbi__err("too large","Very large image (corrupt?)");
            z->depth = stbi__get8(s);  if (z->depth != 1 && z->depth != 2 && z->depth != 4 && z->depth != 8 && z->depth != 16)  return stbi__err("1/2/4/8/16-bit only","PNG not supported: 1/2/4/8/16-bit only");
            color = stbi__get8(s);  if (color > 6)         return stbi__err("bad ctype","Corrupt PNG");
            if (color == 3 && z->depth == 16)                  return stbi__err("bad ctype","Corrupt PNG");
            if (color == 3) pal_img_n = 3; else if (color & 1) return stbi__err("bad ctype","Corrupt PNG");
            comp  = stbi__get8(s);  if (comp) return stbi__err("bad comp method","Corrupt PNG");
            filter= stbi__get8(s);  if (filter) return stbi__err("bad filter method","Corrupt PNG");
            interlace = stbi__get8(s); if (interlace>1) return stbi__err("bad interlace method","Corrupt PNG");
            if (!s->img_x || !s->img_y) return stbi__err("0-pixel image","Corrupt PNG");
            if (!pal_img_n) {
               s->img_n = (color & 2 ? 3 : 1) + (color & 4 ? 1 : 0);
               if ((1 << 30) / s->img_x / s->img_n < s->img_y) return stbi__err("too large", "Image too large to decode");
               if (scan == STBI__SCAN_header) return 1;
            } else {
               // if paletted, then pal_n is our final components, and
               // img_n is # components to decompress/filter.
               s->img_n = 1;
               if ((1 << 30) / s->img_x / 4 < s->img_y) return stbi__err("too large","Corrupt PNG");
               // if SCAN_header, have to scan to see if we have a tRNS
            }
            break;
         }

         case STBI__PNG_TYPE('P','L','T','E'):  {
            if (first) return stbi__err("first not IHDR", "Corrupt PNG");
            if (c.length > 256*3) return stbi__err("invalid PLTE","Corrupt PNG");
            pal_len = c.length / 3;
            if (pal_len * 3 != c.length) return stbi__err("invalid PLTE","Corrupt PNG");
            for (i=0; i < pal_len; ++i) {
               palette[i*4+0] = stbi__get8(s);
               palette[i*4+1] = stbi__get8(s);
               palette[i*4+2] = stbi__get8(s);
               palette[i*4+3] = 255;
            }
            break;
         }

         case STBI__PNG_TYPE('t','R','N','S'): {
            if (first) return stbi__err("first not IHDR", "Corrupt PNG");
            if (z->idata) return stbi__err("tRNS after IDAT","Corrupt PNG");
            if (pal_img_n) {
               if (scan == STBI__SCAN_header) { s->img_n = 4; return 1; }
               if (pal_len == 0) return stbi__err("tRNS before PLTE","Corrupt PNG");
               if (c.length > pal_len) return stbi__err("bad tRNS len","Corrupt PNG");
               pal_img_n = 4;
               for (i=0; i < c.length; ++i)
                  palette[i*4+3] = stbi__get8(s);
            } else {
               if (!(s->img_n & 1)) return stbi__err("tRNS with alpha","Corrupt PNG");
               if (c.length != (stbi__uint32) s->img_n*2) return stbi__err("bad tRNS len","Corrupt PNG");
               has_trans = 1;
               if (z->depth == 16) {
                  for (k = 0; k < s->img_n; ++k) tc16[k] = (stbi__uint16)stbi__get16be(s); // copy the values as-is
               } else {
                  for (k = 0; k < s->img_n; ++k) tc[k] = (stbi_uc)(stbi__get16be(s) & 255) * stbi__depth_scale_table[z->depth]; // non 8-bit images will be larger
               }
            }
            break;
         }

         case STBI__PNG_TYPE('I','D','A','T'): {
            if (first) return stbi__err("first not IHDR", "Corrupt PNG");
            if (pal_img_n && !pal_len) return stbi__err("no PLTE","Corrupt PNG");
            if (scan == STBI__SCAN_header) { s->img_n = pal_img_n; return 1; }
            if ((int)(ioff + c.length) < (int)ioff) return 0;
            if (ioff + c.length > idata_limit) {
               stbi__uint32 idata_limit_old = idata_limit;
               stbi_uc *p;
               if (idata_limit == 0) idata_limit = c.length > 4096 ? c.length : 4096;
               while (ioff + c.length > idata_limit)
                  idata_limit *= 2;
               STBI_NOTUSED(idata_limit_old);
               p = (stbi_uc *) STBI_REALLOC_SIZED(z->idata, idata_limit_old, idata_limit); if (p == NULL) return stbi__err("outofmem", "Out of memory");
               z->idata = p;
            }
            if (!stbi__getn(s, z->idata+ioff,c.length)) return stbi__err("outofdata","Corrupt PNG");
            ioff += c.length;
            break;
         }

         case STBI__PNG_TYPE('I','E','N','D'): {
            stbi__uint32 raw_len, bpl;
            if (first) return stbi__err("first not IHDR", "Corrupt PNG");
            if (scan != STBI__SCAN_load) return 1;
            if (z->idata == NULL) return stbi__err("no IDAT","Corrupt PNG");
            // initial guess for decoded data size to avoid unnecessary reallocs
            bpl = (s->img_x * z->depth + 7) / 8; // bytes per line, per component
            raw_len = bpl * s->img_y * s->img_n /* pixels */ + s->img_y /* filter mode per row */;
            z->expanded = (stbi_uc *) stbi_zlib_decode_malloc_guesssize_headerflag((char *) z->idata, ioff, raw_len, (int *) &raw_len, !is_iphone);
            if (z->expanded == NULL) return 0; // zlib should set error
            STBI_FREE(z->idata); z->idata = NULL;
            if ((req_comp == s->img_n+1 && req_comp != 3 && !pal_img_n) || has_trans)
               s->img_out_n = s->img_n+1;
            else
               s->img_out_n = s->img_n;
            if (!stbi__create_png_image(z, z->expanded, raw_len, s->img_out_n, z->depth, color, interlace)) return 0;
            if (has_trans) {
               if (z->depth == 16) {
                  if (!stbi__compute_transparency16(z, tc16, s->img_out_n)) return 0;
               } else {
                  if (!stbi__compute_transparency(z, tc, s->img_out_n)) return 0;
               }
            }
            if (is_iphone && stbi__de_iphone_flag && s->img_out_n > 2)
               stbi__de_iphone(z);
            if (pal_img_n) {
               // pal_img_n == 3 or 4
               s->img_n = pal_img_n; // record the actual colors we had
               s->img_out_n = pal_img_n;
               if (req_comp >= 3) s->img_out_n = req_comp;
               if (!stbi__expand_png_palette(z, palette, pal_len, s->img_out_n))
                  return 0;
            } else if (has_trans) {
               // non-paletted image with tRNS -> source image has (constant) alpha
               ++s->img_n;
            }
            STBI_FREE(z->expanded); z->expanded = NULL;
            // end of PNG chunk, read and skip CRC
            stbi__get32be(s);
            return 1;
         }

         default:
            // if critical, fail
            if (first) return stbi__err("first not IHDR", "Corrupt PNG");
            if ((c.type & (1 << 29)) == 0) {
               #ifndef STBI_NO_FAILURE_STRINGS
               // not threadsafe
               static char invalid_chunk[] = "XXXX PNG chunk not known";
               invalid_chunk[0] = STBI__BYTECAST(c.type >> 24);
               invalid_chunk[1] = STBI__BYTECAST(c.type >> 16);
               invalid_chunk[2] = STBI__BYTECAST(c.type >>  8);
               invalid_chunk[3] = STBI__BYTECAST(c.type >>  0);
               #endif
               return stbi__err(invalid_chunk, "PNG not supported: unknown PNG chunk type");
            }
            stbi__skip(s, c.length);
            break;
      }
      // end of PNG chunk, read and skip CRC
      stbi__get32be(s);
   }
}

static void *stbi__do_png(stbi__png *p, int *x, int *y, int *n, int req_comp, stbi__result_info *ri)
{
   void *result=NULL;
   if (req_comp < 0 || req_comp > 4) return stbi__errpuc("bad req_comp", "Internal error");
   if (stbi__parse_png_file(p, STBI__SCAN_load, req_comp)) {
      if (p->depth <= 8)
         ri->bits_per_channel = 8;
      else if (p->depth == 16)
         ri->bits_per_channel = 16;
      else
         return stbi__errpuc("bad bits_per_channel", "PNG not supported: unsupported color depth");
      result = p->out;
      p->out = NULL;
      if (req_comp && req_comp != p->s->img_out_n) {
         if (ri->bits_per_channel == 8)
            result = stbi__convert_format((unsigned char *) result, p->s->img_out_n, req_comp, p->s->img_x, p->s->img_y);
         else
            result = stbi__convert_format16((stbi__uint16 *) result, p->s->img_out_n, req_comp, p->s->img_x, p->s->img_y);
         p->s->img_out_n = req_comp;
         if (result == NULL) return result;
      }
      *x = p->s->img_x;
      *y = p->s->img_y;
      if (n) *n = p->s->img_n;
   }
   STBI_FREE(p->out);      p->out      = NULL;
   STBI_FREE(p->expanded); p->expanded = NULL;
   STBI_FREE(p->idata);    p->idata    = NULL;

   return result;
}

static void *stbi__png_load(stbi__context *s, int *x, int *y, int *comp, int req_comp, stbi__result_info *ri)
{
   stbi__png p;
   p.s = s;
   return stbi__do_png(&p, x,y,comp,req_comp, ri);
}

static int stbi__png_test(stbi__context *s)
{
   int r;
   r = stbi__check_png_header(s);
   stbi__rewind(s);
   return r;
}

static int stbi__png_info_raw(stbi__png *p, int *x, int *y, int *comp)
{
   if (!stbi__parse_png_file(p, STBI__SCAN_header, 0)) {
      stbi__rewind( p->s );
      return 0;
   }
   if (x) *x = p->s->img_x;
   if (y) *y = p->s->img_y;
   if (comp) *comp = p->s->img_n;
   return 1;
}

static int stbi__png_info(stbi__context *s, int *x, int *y, int *comp)
{
   stbi__png p;
   p.s = s;
   return stbi__png_info_raw(&p, x, y, comp);
}

static int stbi__png_is16(stbi__context *s)
{
   stbi__png p;
   p.s = s;
   if (!stbi__png_info_raw(&p, NULL, NULL, NULL))
	   return 0;
   if (p.depth != 16) {
      stbi__rewind(p.s);
      return 0;
   }
   return 1;
}
#endif

// Microsoft/Windows BMP image

#ifndef STBI_NO_BMP
static int stbi__bmp_test_raw(stbi__context *s)
{
   int r;
   int sz;
   if (stbi__get8(s) != 'B') return 0;
   if (stbi__get8(s) != 'M') return 0;
   stbi__get32le(s); // discard filesize
   stbi__get16le(s); // discard reserved
   stbi__get16le(s); // discard reserved
   stbi__get32le(s); // discard data offset
   sz = stbi__get32le(s);
   r = (sz == 12 || sz == 40 || sz == 56 || sz == 108 || sz == 124);
   return r;
}

static int stbi__bmp_test(stbi__context *s)
{
   int r = stbi__bmp_test_raw(s);
   stbi__rewind(s);
   return r;
}


// returns 0..31 for the highest set bit
static int stbi__high_bit(unsigned int z)
{
   int n=0;
   if (z == 0) return -1;
   if (z >= 0x10000) { n += 16; z >>= 16; }
   if (z >= 0x00100) { n +=  8; z >>=  8; }
   if (z >= 0x00010) { n +=  4; z >>=  4; }
   if (z >= 0x00004) { n +=  2; z >>=  2; }
   if (z >= 0x00002) { n +=  1;/* >>=  1;*/ }
   return n;
}

static int stbi__bitcount(unsigned int a)
{
   a = (a & 0x55555555) + ((a >>  1) & 0x55555555); // max 2
   a = (a & 0x33333333) + ((a >>  2) & 0x33333333); // max 4
   a = (a + (a >> 4)) & 0x0f0f0f0f; // max 8 per 4, now 8 bits
   a = (a + (a >> 8)); // max 16 per 8 bits
   a = (a + (a >> 16)); // max 32 per 8 bits
   return a & 0xff;
}

// extract an arbitrarily-aligned N-bit value (N=bits)
// from v, and then make it 8-bits long and fractionally
// extend it to full full range.
static int stbi__shiftsigned(unsigned int v, int shift, int bits)
{
   static unsigned int mul_table[9] = {
      0,
      0xff/*0b11111111*/, 0x55/*0b01010101*/, 0x49/*0b01001001*/, 0x11/*0b00010001*/,
      0x21/*0b00100001*/, 0x41/*0b01000001*/, 0x81/*0b10000001*/, 0x01/*0b00000001*/,
   };
   static unsigned int shift_table[9] = {
      0, 0,0,1,0,2,4,6,0,
   };
   if (shift < 0)
      v <<= -shift;
   else
      v >>= shift;
   STBI_ASSERT(v < 256);
   v >>= (8-bits);
   STBI_ASSERT(bits >= 0 && bits <= 8);
   return (int) ((unsigned) v * mul_table[bits]) >> shift_table[bits];
}

typedef struct
{
   int bpp, offset, hsz;
   unsigned int mr,mg,mb,ma, all_a;
   int extra_read;
} stbi__bmp_data;

static int stbi__bmp_set_mask_defaults(stbi__bmp_data *info, int compress)
{
   // BI_BITFIELDS specifies masks explicitly, don't override
   if (compress == 3)
      return 1;

   if (compress == 0) {
      if (info->bpp == 16) {
         info->mr = 31u << 10;
         info->mg = 31u <<  5;
         info->mb = 31u <<  0;
      } else if (info->bpp == 32) {
         info->mr = 0xffu << 16;
         info->mg = 0xffu <<  8;
         info->mb = 0xffu <<  0;
         info->ma = 0xffu << 24;
         info->all_a = 0; // if all_a is 0 at end, then we loaded alpha channel but it was all 0
      } else {
         // otherwise, use defaults, which is all-0
         info->mr = info->mg = info->mb = info->ma = 0;
      }
      return 1;
   }
   return 0; // error
}

static void *stbi__bmp_parse_header(stbi__context *s, stbi__bmp_data *info)
{
   int hsz;
   if (stbi__get8(s) != 'B' || stbi__get8(s) != 'M') return stbi__errpuc("not BMP", "Corrupt BMP");
   stbi__get32le(s); // discard filesize
   stbi__get16le(s); // discard reserved
   stbi__get16le(s); // discard reserved
   info->offset = stbi__get32le(s);
   info->hsz = hsz = stbi__get32le(s);
   info->mr = info->mg = info->mb = info->ma = 0;
   info->extra_read = 14;

   if (info->offset < 0) return stbi__errpuc("bad BMP", "bad BMP");

   if (hsz != 12 && hsz != 40 && hsz != 56 && hsz != 108 && hsz != 124) return stbi__errpuc("unknown BMP", "BMP type not supported: unknown");
   if (hsz == 12) {
      s->img_x = stbi__get16le(s);
      s->img_y = stbi__get16le(s);
   } else {
      s->img_x = stbi__get32le(s);
      s->img_y = stbi__get32le(s);
   }
   if (stbi__get16le(s) != 1) return stbi__errpuc("bad BMP", "bad BMP");
   info->bpp = stbi__get16le(s);
   if (hsz != 12) {
      int compress = stbi__get32le(s);
      if (compress == 1 || compress == 2) return stbi__errpuc("BMP RLE", "BMP type not supported: RLE");
      if (compress >= 4) return stbi__errpuc("BMP JPEG/PNG", "BMP type not supported: unsupported compression"); // this includes PNG/JPEG modes
      if (compress == 3 && info->bpp != 16 && info->bpp != 32) return stbi__errpuc("bad BMP", "bad BMP"); // bitfields requires 16 or 32 bits/pixel
      stbi__get32le(s); // discard sizeof
      stbi__get32le(s); // discard hres
      stbi__get32le(s); // discard vres
      stbi__get32le(s); // discard colorsused
      stbi__get32le(s); // discard max important
      if (hsz == 40 || hsz == 56) {
         if (hsz == 56) {
            stbi__get32le(s);
            stbi__get32le(s);
            stbi__get32le(s);
            stbi__get32le(s);
         }
         if (info->bpp == 16 || info->bpp == 32) {
            if (compress == 0) {
               stbi__bmp_set_mask_defaults(info, compress);
            } else if (compress == 3) {
               info->mr = stbi__get32le(s);
               info->mg = stbi__get32le(s);
               info->mb = stbi__get32le(s);
               info->extra_read += 12;
               // not documented, but generated by photoshop and handled by mspaint
               if (info->mr == info->mg && info->mg == info->mb) {
                  // ?!?!?
                  return stbi__errpuc("bad BMP", "bad BMP");
               }
            } else
               return stbi__errpuc("bad BMP", "bad BMP");
         }
      } else {
         // V4/V5 header
         int i;
         if (hsz != 108 && hsz != 124)
            return stbi__errpuc("bad BMP", "bad BMP");
         info->mr = stbi__get32le(s);
         info->mg = stbi__get32le(s);
         info->mb = stbi__get32le(s);
         info->ma = stbi__get32le(s);
         if (compress != 3) // override mr/mg/mb unless in BI_BITFIELDS mode, as per docs
            stbi__bmp_set_mask_defaults(info, compress);
         stbi__get32le(s); // discard color space
         for (i=0; i < 12; ++i)
            stbi__get32le(s); // discard color space parameters
         if (hsz == 124) {
            stbi__get32le(s); // discard rendering intent
            stbi__get32le(s); // discard offset of profile data
            stbi__get32le(s); // discard size of profile data
            stbi__get32le(s); // discard reserved
         }
      }
   }
   return (void *) 1;
}


static void *stbi__bmp_load(stbi__context *s, int *x, int *y, int *comp, int req_comp, stbi__result_info *ri)
{
   stbi_uc *out;
   unsigned int mr=0,mg=0,mb=0,ma=0, all_a;
   stbi_uc pal[256][4];
   int psize=0,i,j,width;
   int flip_vertically, pad, target;
   stbi__bmp_data info;
   STBI_NOTUSED(ri);

   info.all_a = 255;
   if (stbi__bmp_parse_header(s, &info) == NULL)
      return NULL; // error code already set

   flip_vertically = ((int) s->img_y) > 0;
   s->img_y = abs((int) s->img_y);

   if (s->img_y > STBI_MAX_DIMENSIONS) return stbi__errpuc("too large","Very large image (corrupt?)");
   if (s->img_x > STBI_MAX_DIMENSIONS) return stbi__errpuc("too large","Very large image (corrupt?)");

   mr = info.mr;
   mg = info.mg;
   mb = info.mb;
   ma = info.ma;
   all_a = info.all_a;

   if (info.hsz == 12) {
      if (info.bpp < 24)
         psize = (info.offset - info.extra_read - 24) / 3;
   } else {
      if (info.bpp < 16)
         psize = (info.offset - info.extra_read - info.hsz) >> 2;
   }
   if (psize == 0) {
      if (info.offset != s->callback_already_read + (s->img_buffer - s->img_buffer_original)) {
        return stbi__errpuc("bad offset", "Corrupt BMP");
      }
   }

   if (info.bpp == 24 && ma == 0xff000000)
      s->img_n = 3;
   else
      s->img_n = ma ? 4 : 3;
   if (req_comp && req_comp >= 3) // we can directly decode 3 or 4
      target = req_comp;
   else
      target = s->img_n; // if they want monochrome, we'll post-convert

   // sanity-check size
   if (!stbi__mad3sizes_valid(target, s->img_x, s->img_y, 0))
      return stbi__errpuc("too large", "Corrupt BMP");

   out = (stbi_uc *) stbi__malloc_mad3(target, s->img_x, s->img_y, 0);
   if (!out) return stbi__errpuc("outofmem", "Out of memory");
   if (info.bpp < 16) {
      int z=0;
      if (psize == 0 || psize > 256) { STBI_FREE(out); return stbi__errpuc("invalid", "Corrupt BMP"); }
      for (i=0; i < psize; ++i) {
         pal[i][2] = stbi__get8(s);
         pal[i][1] = stbi__get8(s);
         pal[i][0] = stbi__get8(s);
         if (info.hsz != 12) stbi__get8(s);
         pal[i][3] = 255;
      }
      stbi__skip(s, info.offset - info.extra_read - info.hsz - psize * (info.hsz == 12 ? 3 : 4));
      if (info.bpp == 1) width = (s->img_x + 7) >> 3;
      else if (info.bpp == 4) width = (s->img_x + 1) >> 1;
      else if (info.bpp == 8) width = s->img_x;
      else { STBI_FREE(out); return stbi__errpuc("bad bpp", "Corrupt BMP"); }
      pad = (-width)&3;
      if (info.bpp == 1) {
         for (j=0; j < (int) s->img_y; ++j) {
            int bit_offset = 7, v = stbi__get8(s);
            for (i=0; i < (int) s->img_x; ++i) {
               int color = (v>>bit_offset)&0x1;
               out[z++] = pal[color][0];
               out[z++] = pal[color][1];
               out[z++] = pal[color][2];
               if (target == 4) out[z++] = 255;
               if (i+1 == (int) s->img_x) break;
               if((--bit_offset) < 0) {
                  bit_offset = 7;
                  v = stbi__get8(s);
               }
            }
            stbi__skip(s, pad);
         }
      } else {
         for (j=0; j < (int) s->img_y; ++j) {
            for (i=0; i < (int) s->img_x; i += 2) {
               int v=stbi__get8(s),v2=0;
               if (info.bpp == 4) {
                  v2 = v & 15;
                  v >>= 4;
               }
               out[z++] = pal[v][0];
               out[z++] = pal[v][1];
               out[z++] = pal[v][2];
               if (target == 4) out[z++] = 255;
               if (i+1 == (int) s->img_x) break;
               v = (info.bpp == 8) ? stbi__get8(s) : v2;
               out[z++] = pal[v][0];
               out[z++] = pal[v][1];
               out[z++] = pal[v][2];
               if (target == 4) out[z++] = 255;
            }
            stbi__skip(s, pad);
         }
      }
   } else {
      int rshift=0,gshift=0,bshift=0,ashift=0,rcount=0,gcount=0,bcount=0,acount=0;
      int z = 0;
      int easy=0;
      stbi__skip(s, info.offset - info.extra_read - info.hsz);
      if (info.bpp == 24) width = 3 * s->img_x;
      else if (info.bpp == 16) width = 2*s->img_x;
      else /* bpp = 32 and pad = 0 */ width=0;
      pad = (-width) & 3;
      if (info.bpp == 24) {
         easy = 1;
      } else if (info.bpp == 32) {
         if (mb == 0xff && mg == 0xff00 && mr == 0x00ff0000 && ma == 0xff000000)
            easy = 2;
      }
      if (!easy) {
         if (!mr || !mg || !mb) { STBI_FREE(out); return stbi__errpuc("bad masks", "Corrupt BMP"); }
         // right shift amt to put high bit in position #7
         rshift = stbi__high_bit(mr)-7; rcount = stbi__bitcount(mr);
         gshift = stbi__high_bit(mg)-7; gcount = stbi__bitcount(mg);
         bshift = stbi__high_bit(mb)-7; bcount = stbi__bitcount(mb);
         ashift = stbi__high_bit(ma)-7; acount = stbi__bitcount(ma);
         if (rcount > 8 || gcount > 8 || bcount > 8 || acount > 8) { STBI_FREE(out); return stbi__errpuc("bad masks", "Corrupt BMP"); }
      }
      for (j=0; j < (int) s->img_y; ++j) {
         if (easy) {
            for (i=0; i < (int) s->img_x; ++i) {
               unsigned char a;
               out[z+2] = stbi__get8(s);
               out[z+1] = stbi__get8(s);
               out[z+0] = stbi__get8(s);
               z += 3;
               a = (easy == 2 ? stbi__get8(s) : 255);
               all_a |= a;
               if (target == 4) out[z++] = a;
            }
         } else {
            int bpp = info.bpp;
            for (i=0; i < (int) s->img_x; ++i) {
               stbi__uint32 v = (bpp == 16 ? (stbi__uint32) stbi__get16le(s) : stbi__get32le(s));
               unsigned int a;
               out[z++] = STBI__BYTECAST(stbi__shiftsigned(v & mr, rshift, rcount));
               out[z++] = STBI__BYTECAST(stbi__shiftsigned(v & mg, gshift, gcount));
               out[z++] = STBI__BYTECAST(stbi__shiftsigned(v & mb, bshift, bcount));
               a = (ma ? stbi__shiftsigned(v & ma, ashift, acount) : 255);
               all_a |= a;
               if (target == 4) out[z++] = STBI__BYTECAST(a);
            }
         }
         stbi__skip(s, pad);
      }
   }

   // if alpha channel is all 0s, replace with all 255s
   if (target == 4 && all_a == 0)
      for (i=4*s->img_x*s->img_y-1; i >= 0; i -= 4)
         out[i] = 255;

   if (flip_vertically) {
      stbi_uc t;
      for (j=0; j < (int) s->img_y>>1; ++j) {
         stbi_uc *p1 = out +      j     *s->img_x*target;
         stbi_uc *p2 = out + (s->img_y-1-j)*s->img_x*target;
         for (i=0; i < (int) s->img_x*target; ++i) {
            t = p1[i]; p1[i] = p2[i]; p2[i] = t;
         }
      }
   }

   if (req_comp && req_comp != target) {
      out = stbi__convert_format(out, target, req_comp, s->img_x, s->img_y);
      if (out == NULL) return out; // stbi__convert_format frees input on failure
   }

   *x = s->img_x;
   *y = s->img_y;
   if (comp) *comp = s->img_n;
   return out;
}
#endif

// Targa Truevision - TGA
// by Jonathan Dummer
#ifndef STBI_NO_TGA
// returns STBI_rgb or whatever, 0 on error
static int stbi__tga_get_comp(int bits_per_pixel, int is_grey, int* is_rgb16)
{
   // only RGB or RGBA (incl. 16bit) or grey allowed
   if (is_rgb16) *is_rgb16 = 0;
   switch(bits_per_pixel) {
      case 8:  return STBI_grey;
      case 16: if(is_grey) return STBI_grey_alpha;
               // fallthrough
      case 15: if(is_rgb16) *is_rgb16 = 1;
               return STBI_rgb;
      case 24: // fallthrough
      case 32: return bits_per_pixel/8;
      default: return 0;
   }
}

static int stbi__tga_info(stbi__context *s, int *x, int *y, int *comp)
{
    int tga_w, tga_h, tga_comp, tga_image_type, tga_bits_per_pixel, tga_colormap_bpp;
    int sz, tga_colormap_type;
    stbi__get8(s);                   // discard Offset
    tga_colormap_type = stbi__get8(s); // colormap type
    if( tga_colormap_type > 1 ) {
        stbi__rewind(s);
        return 0;      // only RGB or indexed allowed
    }
    tga_image_type = stbi__get8(s); // image type
    if ( tga_colormap_type == 1 ) { // colormapped (paletted) image
        if (tga_image_type != 1 && tga_image_type != 9) {
            stbi__rewind(s);
            return 0;
        }
        stbi__skip(s,4);       // skip index of first colormap entry and number of entries
        sz = stbi__get8(s);    //   check bits per palette color entry
        if ( (sz != 8) && (sz != 15) && (sz != 16) && (sz != 24) && (sz != 32) ) {
            stbi__rewind(s);
            return 0;
        }
        stbi__skip(s,4);       // skip image x and y origin
        tga_colormap_bpp = sz;
    } else { // "normal" image w/o colormap - only RGB or grey allowed, +/- RLE
        if ( (tga_image_type != 2) && (tga_image_type != 3) && (tga_image_type != 10) && (tga_image_type != 11) ) {
            stbi__rewind(s);
            return 0; // only RGB or grey allowed, +/- RLE
        }
        stbi__skip(s,9); // skip colormap specification and image x/y origin
        tga_colormap_bpp = 0;
    }
    tga_w = stbi__get16le(s);
    if( tga_w < 1 ) {
        stbi__rewind(s);
        return 0;   // test width
    }
    tga_h = stbi__get16le(s);
    if( tga_h < 1 ) {
        stbi__rewind(s);
        return 0;   // test height
    }
    tga_bits_per_pixel = stbi__get8(s); // bits per pixel
    stbi__get8(s); // ignore alpha bits
    if (tga_colormap_bpp != 0) {
        if((tga_bits_per_pixel != 8) && (tga_bits_per_pixel != 16)) {
            // when using a colormap, tga_bits_per_pixel is the size of the indexes
            // I don't think anything but 8 or 16bit indexes makes sense
            stbi__rewind(s);
            return 0;
        }
        tga_comp = stbi__tga_get_comp(tga_colormap_bpp, 0, NULL);
    } else {
        tga_comp = stbi__tga_get_comp(tga_bits_per_pixel, (tga_image_type == 3) || (tga_image_type == 11), NULL);
    }
    if(!tga_comp) {
      stbi__rewind(s);
      return 0;
    }
    if (x) *x = tga_w;
    if (y) *y = tga_h;
    if (comp) *comp = tga_comp;
    return 1;                   // seems to have passed everything
}

static int stbi__tga_test(stbi__context *s)
{
   int res = 0;
   int sz, tga_color_type;
   stbi__get8(s);      //   discard Offset
   tga_color_type = stbi__get8(s);   //   color type
   if ( tga_color_type > 1 ) goto errorEnd;   //   only RGB or indexed allowed
   sz = stbi__get8(s);   //   image type
   if ( tga_color_type == 1 ) { // colormapped (paletted) image
      if (sz != 1 && sz != 9) goto errorEnd; // colortype 1 demands image type 1 or 9
      stbi__skip(s,4);       // skip index of first colormap entry and number of entries
      sz = stbi__get8(s);    //   check bits per palette color entry
      if ( (sz != 8) && (sz != 15) && (sz != 16) && (sz != 24) && (sz != 32) ) goto errorEnd;
      stbi__skip(s,4);       // skip image x and y origin
   } else { // "normal" image w/o colormap
      if ( (sz != 2) && (sz != 3) && (sz != 10) && (sz != 11) ) goto errorEnd; // only RGB or grey allowed, +/- RLE
      stbi__skip(s,9); // skip colormap specification and image x/y origin
   }
   if ( stbi__get16le(s) < 1 ) goto errorEnd;      //   test width
   if ( stbi__get16le(s) < 1 ) goto errorEnd;      //   test height
   sz = stbi__get8(s);   //   bits per pixel
   if ( (tga_color_type == 1) && (sz != 8) && (sz != 16) ) goto errorEnd; // for colormapped images, bpp is size of an index
   if ( (sz != 8) && (sz != 15) && (sz != 16) && (sz != 24) && (sz != 32) ) goto errorEnd;

   res = 1; // if we got this far, everything's good and we can return 1 instead of 0

errorEnd:
   stbi__rewind(s);
   return res;
}

// read 16bit value and convert to 24bit RGB
static void stbi__tga_read_rgb16(stbi__context *s, stbi_uc* out)
{
   stbi__uint16 px = (stbi__uint16)stbi__get16le(s);
   stbi__uint16 fiveBitMask = 31;
   // we have 3 channels with 5bits each
   int r = (px >> 10) & fiveBitMask;
   int g = (px >> 5) & fiveBitMask;
   int b = px & fiveBitMask;
   // Note that this saves the data in RGB(A) order, so it doesn't need to be swapped later
   out[0] = (stbi_uc)((r * 255)/31);
   out[1] = (stbi_uc)((g * 255)/31);
   out[2] = (stbi_uc)((b * 255)/31);

   // some people claim that the most significant bit might be used for alpha
   // (possibly if an alpha-bit is set in the "image descriptor byte")
   // but that only made 16bit test images completely translucent..
   // so let's treat all 15 and 16bit TGAs as RGB with no alpha.
}

static void *stbi__tga_load(stbi__context *s, int *x, int *y, int *comp, int req_comp, stbi__result_info *ri)
{
   //   read in the TGA header stuff
   int tga_offset = stbi__get8(s);
   int tga_indexed = stbi__get8(s);
   int tga_image_type = stbi__get8(s);
   int tga_is_RLE = 0;
   int tga_palette_start = stbi__get16le(s);
   int tga_palette_len = stbi__get16le(s);
   int tga_palette_bits = stbi__get8(s);
   int tga_x_origin = stbi__get16le(s);
   int tga_y_origin = stbi__get16le(s);
   int tga_width = stbi__get16le(s);
   int tga_height = stbi__get16le(s);
   int tga_bits_per_pixel = stbi__get8(s);
   int tga_comp, tga_rgb16=0;
   int tga_inverted = stbi__get8(s);
   // int tga_alpha_bits = tga_inverted & 15; // the 4 lowest bits - unused (useless?)
   //   image data
   unsigned char *tga_data;
   unsigned char *tga_palette = NULL;
   int i, j;
   unsigned char raw_data[4] = {0};
   int RLE_count = 0;
   int RLE_repeating = 0;
   int read_next_pixel = 1;
   STBI_NOTUSED(ri);
   STBI_NOTUSED(tga_x_origin); // @TODO
   STBI_NOTUSED(tga_y_origin); // @TODO

   if (tga_height > STBI_MAX_DIMENSIONS) return stbi__errpuc("too large","Very large image (corrupt?)");
   if (tga_width > STBI_MAX_DIMENSIONS) return stbi__errpuc("too large","Very large image (corrupt?)");

   //   do a tiny bit of precessing
   if ( tga_image_type >= 8 )
   {
      tga_image_type -= 8;
      tga_is_RLE = 1;
   }
   tga_inverted = 1 - ((tga_inverted >> 5) & 1);

   //   If I'm paletted, then I'll use the number of bits from the palette
   if ( tga_indexed ) tga_comp = stbi__tga_get_comp(tga_palette_bits, 0, &tga_rgb16);
   else tga_comp = stbi__tga_get_comp(tga_bits_per_pixel, (tga_image_type == 3), &tga_rgb16);

   if(!tga_comp) // shouldn't really happen, stbi__tga_test() should have ensured basic consistency
      return stbi__errpuc("bad format", "Can't find out TGA pixelformat");

   //   tga info
   *x = tga_width;
   *y = tga_height;
   if (comp) *comp = tga_comp;

   if (!stbi__mad3sizes_valid(tga_width, tga_height, tga_comp, 0))
      return stbi__errpuc("too large", "Corrupt TGA");

   tga_data = (unsigned char*)stbi__malloc_mad3(tga_width, tga_height, tga_comp, 0);
   if (!tga_data) return stbi__errpuc("outofmem", "Out of memory");

   // skip to the data's starting position (offset usually = 0)
   stbi__skip(s, tga_offset );

   if ( !tga_indexed && !tga_is_RLE && !tga_rgb16 ) {
      for (i=0; i < tga_height; ++i) {
         int row = tga_inverted ? tga_height -i - 1 : i;
         stbi_uc *tga_row = tga_data + row*tga_width*tga_comp;
         stbi__getn(s, tga_row, tga_width * tga_comp);
      }
   } else  {
      //   do I need to load a palette?
      if ( tga_indexed)
      {
         if (tga_palette_len == 0) {  /* you have to have at least one entry! */
            STBI_FREE(tga_data);
            return stbi__errpuc("bad palette", "Corrupt TGA");
         }

         //   any data to skip? (offset usually = 0)
         stbi__skip(s, tga_palette_start );
         //   load the palette
         tga_palette = (unsigned char*)stbi__malloc_mad2(tga_palette_len, tga_comp, 0);
         if (!tga_palette) {
            STBI_FREE(tga_data);
            return stbi__errpuc("outofmem", "Out of memory");
         }
         if (tga_rgb16) {
            stbi_uc *pal_entry = tga_palette;
            STBI_ASSERT(tga_comp == STBI_rgb);
            for (i=0; i < tga_palette_len; ++i) {
               stbi__tga_read_rgb16(s, pal_entry);
               pal_entry += tga_comp;
            }
         } else if (!stbi__getn(s, tga_palette, tga_palette_len * tga_comp)) {
               STBI_FREE(tga_data);
               STBI_FREE(tga_palette);
               return stbi__errpuc("bad palette", "Corrupt TGA");
         }
      }
      //   load the data
      for (i=0; i < tga_width * tga_height; ++i)
      {
         //   if I'm in RLE mode, do I need to get a RLE stbi__pngchunk?
         if ( tga_is_RLE )
         {
            if ( RLE_count == 0 )
            {
               //   yep, get the next byte as a RLE command
               int RLE_cmd = stbi__get8(s);
               RLE_count = 1 + (RLE_cmd & 127);
               RLE_repeating = RLE_cmd >> 7;
               read_next_pixel = 1;
            } else if ( !RLE_repeating )
            {
               read_next_pixel = 1;
            }
         } else
         {
            read_next_pixel = 1;
         }
         //   OK, if I need to read a pixel, do it now
         if ( read_next_pixel )
         {
            //   load however much data we did have
            if ( tga_indexed )
            {
               // read in index, then perform the lookup
               int pal_idx = (tga_bits_per_pixel == 8) ? stbi__get8(s) : stbi__get16le(s);
               if ( pal_idx >= tga_palette_len ) {
                  // invalid index
                  pal_idx = 0;
               }
               pal_idx *= tga_comp;
               for (j = 0; j < tga_comp; ++j) {
                  raw_data[j] = tga_palette[pal_idx+j];
               }
            } else if(tga_rgb16) {
               STBI_ASSERT(tga_comp == STBI_rgb);
               stbi__tga_read_rgb16(s, raw_data);
            } else {
               //   read in the data raw
               for (j = 0; j < tga_comp; ++j) {
                  raw_data[j] = stbi__get8(s);
               }
            }
            //   clear the reading flag for the next pixel
            read_next_pixel = 0;
         } // end of reading a pixel

         // copy data
         for (j = 0; j < tga_comp; ++j)
           tga_data[i*tga_comp+j] = raw_data[j];

         //   in case we're in RLE mode, keep counting down
         --RLE_count;
      }
      //   do I need to invert the image?
      if ( tga_inverted )
      {
         for (j = 0; j*2 < tga_height; ++j)
         {
            int index1 = j * tga_width * tga_comp;
            int index2 = (tga_height - 1 - j) * tga_width * tga_comp;
            for (i = tga_width * tga_comp; i > 0; --i)
            {
               unsigned char temp = tga_data[index1];
               tga_data[index1] = tga_data[index2];
               tga_data[index2] = temp;
               ++index1;
               ++index2;
            }
         }
      }
      //   clear my palette, if I had one
      if ( tga_palette != NULL )
      {
         STBI_FREE( tga_palette );
      }
   }

   // swap RGB - if the source data was RGB16, it already is in the right order
   if (tga_comp >= 3 && !tga_rgb16)
   {
      unsigned char* tga_pixel = tga_data;
      for (i=0; i < tga_width * tga_height; ++i)
      {
         unsigned char temp = tga_pixel[0];
         tga_pixel[0] = tga_pixel[2];
         tga_pixel[2] = temp;
         tga_pixel += tga_comp;
      }
   }

   // convert to target component count
   if (req_comp && req_comp != tga_comp)
      tga_data = stbi__convert_format(tga_data, tga_comp, req_comp, tga_width, tga_height);

   //   the things I do to get rid of an error message, and yet keep
   //   Microsoft's C compilers happy... [8^(
   tga_palette_start = tga_palette_len = tga_palette_bits =
         tga_x_origin = tga_y_origin = 0;
   STBI_NOTUSED(tga_palette_start);
   //   OK, done
   return tga_data;
}
#endif

// *************************************************************************************************
// Photoshop PSD loader -- PD by Thatcher Ulrich, integration by Nicolas Schulz, tweaked by STB

#ifndef STBI_NO_PSD
static int stbi__psd_test(stbi__context *s)
{
   int r = (stbi__get32be(s) == 0x38425053);
   stbi__rewind(s);
   return r;
}

static int stbi__psd_decode_rle(stbi__context *s, stbi_uc *p, int pixelCount)
{
   int count, nleft, len;

   count = 0;
   while ((nleft = pixelCount - count) > 0) {
      len = stbi__get8(s);
      if (len == 128) {
         // No-op.
      } else if (len < 128) {
         // Copy next len+1 bytes literally.
         len++;
         if (len > nleft) return 0; // corrupt data
         count += len;
         while (len) {
            *p = stbi__get8(s);
            p += 4;
            len--;
         }
      } else if (len > 128) {
         stbi_uc   val;
         // Next -len+1 bytes in the dest are replicated from next source byte.
         // (Interpret len as a negative 8-bit int.)
         len = 257 - len;
         if (len > nleft) return 0; // corrupt data
         val = stbi__get8(s);
         count += len;
         while (len) {
            *p = val;
            p += 4;
            len--;
         }
      }
   }

   return 1;
}

static void *stbi__psd_load(stbi__context *s, int *x, int *y, int *comp, int req_comp, stbi__result_info *ri, int bpc)
{
   int pixelCount;
   int channelCount, compression;
   int channel, i;
   int bitdepth;
   int w,h;
   stbi_uc *out;
   STBI_NOTUSED(ri);

   // Check identifier
   if (stbi__get32be(s) != 0x38425053)   // "8BPS"
      return stbi__errpuc("not PSD", "Corrupt PSD image");

   // Check file type version.
   if (stbi__get16be(s) != 1)
      return stbi__errpuc("wrong version", "Unsupported version of PSD image");

   // Skip 6 reserved bytes.
   stbi__skip(s, 6 );

   // Read the number of channels (R, G, B, A, etc).
   channelCount = stbi__get16be(s);
   if (channelCount < 0 || channelCount > 16)
      return stbi__errpuc("wrong channel count", "Unsupported number of channels in PSD image");

   // Read the rows and columns of the image.
   h = stbi__get32be(s);
   w = stbi__get32be(s);

   if (h > STBI_MAX_DIMENSIONS) return stbi__errpuc("too large","Very large image (corrupt?)");
   if (w > STBI_MAX_DIMENSIONS) return stbi__errpuc("too large","Very large image (corrupt?)");

   // Make sure the depth is 8 bits.
   bitdepth = stbi__get16be(s);
   if (bitdepth != 8 && bitdepth != 16)
      return stbi__errpuc("unsupported bit depth", "PSD bit depth is not 8 or 16 bit");

   // Make sure the color mode is RGB.
   // Valid options are:
   //   0: Bitmap
   //   1: Grayscale
   //   2: Indexed color
   //   3: RGB color
   //   4: CMYK color
   //   7: Multichannel
   //   8: Duotone
   //   9: Lab color
   if (stbi__get16be(s) != 3)
      return stbi__errpuc("wrong color format", "PSD is not in RGB color format");

   // Skip the Mode Data.  (It's the palette for indexed color; other info for other modes.)
   stbi__skip(s,stbi__get32be(s) );

   // Skip the image resources.  (resolution, pen tool paths, etc)
   stbi__skip(s, stbi__get32be(s) );

   // Skip the reserved data.
   stbi__skip(s, stbi__get32be(s) );

   // Find out if the data is compressed.
   // Known values:
   //   0: no compression
   //   1: RLE compressed
   compression = stbi__get16be(s);
   if (compression > 1)
      return stbi__errpuc("bad compression", "PSD has an unknown compression format");

   // Check size
   if (!stbi__mad3sizes_valid(4, w, h, 0))
      return stbi__errpuc("too large", "Corrupt PSD");

   // Create the destination image.

   if (!compression && bitdepth == 16 && bpc == 16) {
      out = (stbi_uc *) stbi__malloc_mad3(8, w, h, 0);
      ri->bits_per_channel = 16;
   } else
      out = (stbi_uc *) stbi__malloc(4 * w*h);

   if (!out) return stbi__errpuc("outofmem", "Out of memory");
   pixelCount = w*h;

   // Initialize the data to zero.
   //memset( out, 0, pixelCount * 4 );

   // Finally, the image data.
   if (compression) {
      // RLE as used by .PSD and .TIFF
      // Loop until you get the number of unpacked bytes you are expecting:
      //     Read the next source byte into n.
      //     If n is between 0 and 127 inclusive, copy the next n+1 bytes literally.
      //     Else if n is between -127 and -1 inclusive, copy the next byte -n+1 times.
      //     Else if n is 128, noop.
      // Endloop

      // The RLE-compressed data is preceded by a 2-byte data count for each row in the data,
      // which we're going to just skip.
      stbi__skip(s, h * channelCount * 2 );

      // Read the RLE data by channel.
      for (channel = 0; channel < 4; channel++) {
         stbi_uc *p;

         p = out+channel;
         if (channel >= channelCount) {
            // Fill this channel with default data.
            for (i = 0; i < pixelCount; i++, p += 4)
               *p = (channel == 3 ? 255 : 0);
         } else {
            // Read the RLE data.
            if (!stbi__psd_decode_rle(s, p, pixelCount)) {
               STBI_FREE(out);
               return stbi__errpuc("corrupt", "bad RLE data");
            }
         }
      }

   } else {
      // We're at the raw image data.  It's each channel in order (Red, Green, Blue, Alpha, ...)
      // where each channel consists of an 8-bit (or 16-bit) value for each pixel in the image.

      // Read the data by channel.
      for (channel = 0; channel < 4; channel++) {
         if (channel >= channelCount) {
            // Fill this channel with default data.
            if (bitdepth == 16 && bpc == 16) {
               stbi__uint16 *q = ((stbi__uint16 *) out) + channel;
               stbi__uint16 val = channel == 3 ? 65535 : 0;
               for (i = 0; i < pixelCount; i++, q += 4)
                  *q = val;
            } else {
               stbi_uc *p = out+channel;
               stbi_uc val = channel == 3 ? 255 : 0;
               for (i = 0; i < pixelCount; i++, p += 4)
                  *p = val;
            }
         } else {
            if (ri->bits_per_channel == 16) {    // output bpc
               stbi__uint16 *q = ((stbi__uint16 *) out) + channel;
               for (i = 0; i < pixelCount; i++, q += 4)
                  *q = (stbi__uint16) stbi__get16be(s);
            } else {
               stbi_uc *p = out+channel;
               if (bitdepth == 16) {  // input bpc
                  for (i = 0; i < pixelCount; i++, p += 4)
                     *p = (stbi_uc) (stbi__get16be(s) >> 8);
               } else {
                  for (i = 0; i < pixelCount; i++, p += 4)
                     *p = stbi__get8(s);
               }
            }
         }
      }
   }

   // remove weird white matte from PSD
   if (channelCount >= 4) {
      if (ri->bits_per_channel == 16) {
         for (i=0; i < w*h; ++i) {
            stbi__uint16 *pixel = (stbi__uint16 *) out + 4*i;
            if (pixel[3] != 0 && pixel[3] != 65535) {
               float a = pixel[3] / 65535.0f;
               float ra = 1.0f / a;
               float inv_a = 65535.0f * (1 - ra);
               pixel[0] = (stbi__uint16) (pixel[0]*ra + inv_a);
               pixel[1] = (stbi__uint16) (pixel[1]*ra + inv_a);
               pixel[2] = (stbi__uint16) (pixel[2]*ra + inv_a);
            }
         }
      } else {
         for (i=0; i < w*h; ++i) {
            unsigned char *pixel = out + 4*i;
            if (pixel[3] != 0 && pixel[3] != 255) {
               float a = pixel[3] / 255.0f;
               float ra = 1.0f / a;
               float inv_a = 255.0f * (1 - ra);
               pixel[0] = (unsigned char) (pixel[0]*ra + inv_a);
               pixel[1] = (unsigned char) (pixel[1]*ra + inv_a);
               pixel[2] = (unsigned char) (pixel[2]*ra + inv_a);
            }
         }
      }
   }

   // convert to desired output format
   if (req_comp && req_comp != 4) {
      if (ri->bits_per_channel == 16)
         out = (stbi_uc *) stbi__convert_format16((stbi__uint16 *) out, 4, req_comp, w, h);
      else
         out = stbi__convert_format(out, 4, req_comp, w, h);
      if (out == NULL) return out; // stbi__convert_format frees input on failure
   }

   if (comp) *comp = 4;
   *y = h;
   *x = w;

   return out;
}
#endif

// *************************************************************************************************
// Softimage PIC loader
// by Tom Seddon
//
// See http://softimage.wiki.softimage.com/index.php/INFO:_PIC_file_format
// See http://ozviz.wasp.uwa.edu.au/~pbourke/dataformats/softimagepic/

#ifndef STBI_NO_PIC
static int stbi__pic_is4(stbi__context *s,const char *str)
{
   int i;
   for (i=0; i<4; ++i)
      if (stbi__get8(s) != (stbi_uc)str[i])
         return 0;

   return 1;
}

static int stbi__pic_test_core(stbi__context *s)
{
   int i;

   if (!stbi__pic_is4(s,"\x53\x80\xF6\x34"))
      return 0;

   for(i=0;i<84;++i)
      stbi__get8(s);

   if (!stbi__pic_is4(s,"PICT"))
      return 0;

   return 1;
}

typedef struct
{
   stbi_uc size,type,channel;
} stbi__pic_packet;

static stbi_uc *stbi__readval(stbi__context *s, int channel, stbi_uc *dest)
{
   int mask=0x80, i;

   for (i=0; i<4; ++i, mask>>=1) {
      if (channel & mask) {
         if (stbi__at_eof(s)) return stbi__errpuc("bad file","PIC file too short");
         dest[i]=stbi__get8(s);
      }
   }

   return dest;
}

static void stbi__copyval(int channel,stbi_uc *dest,const stbi_uc *src)
{
   int mask=0x80,i;

   for (i=0;i<4; ++i, mask>>=1)
      if (channel&mask)
         dest[i]=src[i];
}

static stbi_uc *stbi__pic_load_core(stbi__context *s,int width,int height,int *comp, stbi_uc *result)
{
   int act_comp=0,num_packets=0,y,chained;
   stbi__pic_packet packets[10];

   // this will (should...) cater for even some bizarre stuff like having data
    // for the same channel in multiple packets.
   do {
      stbi__pic_packet *packet;

      if (num_packets==sizeof(packets)/sizeof(packets[0]))
         return stbi__errpuc("bad format","too many packets");

      packet = &packets[num_packets++];

      chained = stbi__get8(s);
      packet->size    = stbi__get8(s);
      packet->type    = stbi__get8(s);
      packet->channel = stbi__get8(s);

      act_comp |= packet->channel;

      if (stbi__at_eof(s))          return stbi__errpuc("bad file","file too short (reading packets)");
      if (packet->size != 8)  return stbi__errpuc("bad format","packet isn't 8bpp");
   } while (chained);

   *comp = (act_comp & 0x10 ? 4 : 3); // has alpha channel?

   for(y=0; y<height; ++y) {
      int packet_idx;

      for(packet_idx=0; packet_idx < num_packets; ++packet_idx) {
         stbi__pic_packet *packet = &packets[packet_idx];
         stbi_uc *dest = result+y*width*4;

         switch (packet->type) {
            default:
               return stbi__errpuc("bad format","packet has bad compression type");

            case 0: {//uncompressed
               int x;

               for(x=0;x<width;++x, dest+=4)
                  if (!stbi__readval(s,packet->channel,dest))
                     return 0;
               break;
            }

            case 1://Pure RLE
               {
                  int left=width, i;

                  while (left>0) {
                     stbi_uc count,value[4];

                     count=stbi__get8(s);
                     if (stbi__at_eof(s))   return stbi__errpuc("bad file","file too short (pure read count)");

                     if (count > left)
                        count = (stbi_uc) left;

                     if (!stbi__readval(s,packet->channel,value))  return 0;

                     for(i=0; i<count; ++i,dest+=4)
                        stbi__copyval(packet->channel,dest,value);
                     left -= count;
                  }
               }
               break;

            case 2: {//Mixed RLE
               int left=width;
               while (left>0) {
                  int count = stbi__get8(s), i;
                  if (stbi__at_eof(s))  return stbi__errpuc("bad file","file too short (mixed read count)");

                  if (count >= 128) { // Repeated
                     stbi_uc value[4];

                     if (count==128)
                        count = stbi__get16be(s);
                     else
                        count -= 127;
                     if (count > left)
                        return stbi__errpuc("bad file","scanline overrun");

                     if (!stbi__readval(s,packet->channel,value))
                        return 0;

                     for(i=0;i<count;++i, dest += 4)
                        stbi__copyval(packet->channel,dest,value);
                  } else { // Raw
                     ++count;
                     if (count>left) return stbi__errpuc("bad file","scanline overrun");

                     for(i=0;i<count;++i, dest+=4)
                        if (!stbi__readval(s,packet->channel,dest))
                           return 0;
                  }
                  left-=count;
               }
               break;
            }
         }
      }
   }

   return result;
}

static void *stbi__pic_load(stbi__context *s,int *px,int *py,int *comp,int req_comp, stbi__result_info *ri)
{
   stbi_uc *result;
   int i, x,y, internal_comp;
   STBI_NOTUSED(ri);

   if (!comp) comp = &internal_comp;

   for (i=0; i<92; ++i)
      stbi__get8(s);

   x = stbi__get16be(s);
   y = stbi__get16be(s);

   if (y > STBI_MAX_DIMENSIONS) return stbi__errpuc("too large","Very large image (corrupt?)");
   if (x > STBI_MAX_DIMENSIONS) return stbi__errpuc("too large","Very large image (corrupt?)");

   if (stbi__at_eof(s))  return stbi__errpuc("bad file","file too short (pic header)");
   if (!stbi__mad3sizes_valid(x, y, 4, 0)) return stbi__errpuc("too large", "PIC image too large to decode");

   stbi__get32be(s); //skip `ratio'
   stbi__get16be(s); //skip `fields'
   stbi__get16be(s); //skip `pad'

   // intermediate buffer is RGBA
   result = (stbi_uc *) stbi__malloc_mad3(x, y, 4, 0);
   if (!result) return stbi__errpuc("outofmem", "Out of memory");
   memset(result, 0xff, x*y*4);

   if (!stbi__pic_load_core(s,x,y,comp, result)) {
      STBI_FREE(result);
      result=0;
   }
   *px = x;
   *py = y;
   if (req_comp == 0) req_comp = *comp;
   result=stbi__convert_format(result,4,req_comp,x,y);

   return result;
}

static int stbi__pic_test(stbi__context *s)
{
   int r = stbi__pic_test_core(s);
   stbi__rewind(s);
   return r;
}
#endif

// *************************************************************************************************
// GIF loader -- public domain by Jean-Marc Lienher -- simplified/shrunk by stb

#ifndef STBI_NO_GIF
typedef struct
{
   stbi__int16 prefix;
   stbi_uc first;
   stbi_uc suffix;
} stbi__gif_lzw;

typedef struct
{
   int w,h;
   stbi_uc *out;                 // output buffer (always 4 components)
   stbi_uc *background;          // The current "background" as far as a gif is concerned
   stbi_uc *history;
   int flags, bgindex, ratio, transparent, eflags;
   stbi_uc  pal[256][4];
   stbi_uc lpal[256][4];
   stbi__gif_lzw codes[8192];
   stbi_uc *color_table;
   int parse, step;
   int lflags;
   int start_x, start_y;
   int max_x, max_y;
   int cur_x, cur_y;
   int line_size;
   int delay;
} stbi__gif;

static int stbi__gif_test_raw(stbi__context *s)
{
   int sz;
   if (stbi__get8(s) != 'G' || stbi__get8(s) != 'I' || stbi__get8(s) != 'F' || stbi__get8(s) != '8') return 0;
   sz = stbi__get8(s);
   if (sz != '9' && sz != '7') return 0;
   if (stbi__get8(s) != 'a') return 0;
   return 1;
}

static int stbi__gif_test(stbi__context *s)
{
   int r = stbi__gif_test_raw(s);
   stbi__rewind(s);
   return r;
}

static void stbi__gif_parse_colortable(stbi__context *s, stbi_uc pal[256][4], int num_entries, int transp)
{
   int i;
   for (i=0; i < num_entries; ++i) {
      pal[i][2] = stbi__get8(s);
      pal[i][1] = stbi__get8(s);
      pal[i][0] = stbi__get8(s);
      pal[i][3] = transp == i ? 0 : 255;
   }
}

static int stbi__gif_header(stbi__context *s, stbi__gif *g, int *comp, int is_info)
{
   stbi_uc version;
   if (stbi__get8(s) != 'G' || stbi__get8(s) != 'I' || stbi__get8(s) != 'F' || stbi__get8(s) != '8')
      return stbi__err("not GIF", "Corrupt GIF");

   version = stbi__get8(s);
   if (version != '7' && version != '9')    return stbi__err("not GIF", "Corrupt GIF");
   if (stbi__get8(s) != 'a')                return stbi__err("not GIF", "Corrupt GIF");

   stbi__g_failure_reason = "";
   g->w = stbi__get16le(s);
   g->h = stbi__get16le(s);
   g->flags = stbi__get8(s);
   g->bgindex = stbi__get8(s);
   g->ratio = stbi__get8(s);
   g->transparent = -1;

   if (g->w > STBI_MAX_DIMENSIONS) return stbi__err("too large","Very large image (corrupt?)");
   if (g->h > STBI_MAX_DIMENSIONS) return stbi__err("too large","Very large image (corrupt?)");

   if (comp != 0) *comp = 4;  // can't actually tell whether it's 3 or 4 until we parse the comments

   if (is_info) return 1;

   if (g->flags & 0x80)
      stbi__gif_parse_colortable(s,g->pal, 2 << (g->flags & 7), -1);

   return 1;
}

static int stbi__gif_info_raw(stbi__context *s, int *x, int *y, int *comp)
{
   stbi__gif* g = (stbi__gif*) stbi__malloc(sizeof(stbi__gif));
   if (!g) return stbi__err("outofmem", "Out of memory");
   if (!stbi__gif_header(s, g, comp, 1)) {
      STBI_FREE(g);
      stbi__rewind( s );
      return 0;
   }
   if (x) *x = g->w;
   if (y) *y = g->h;
   STBI_FREE(g);
   return 1;
}

static void stbi__out_gif_code(stbi__gif *g, stbi__uint16 code)
{
   stbi_uc *p, *c;
   int idx;

   // recurse to decode the prefixes, since the linked-list is backwards,
   // and working backwards through an interleaved image would be nasty
   if (g->codes[code].prefix >= 0)
      stbi__out_gif_code(g, g->codes[code].prefix);

   if (g->cur_y >= g->max_y) return;

   idx = g->cur_x + g->cur_y;
   p = &g->out[idx];
   g->history[idx / 4] = 1;

   c = &g->color_table[g->codes[code].suffix * 4];
   if (c[3] > 128) { // don't render transparent pixels;
      p[0] = c[2];
      p[1] = c[1];
      p[2] = c[0];
      p[3] = c[3];
   }
   g->cur_x += 4;

   if (g->cur_x >= g->max_x) {
      g->cur_x = g->start_x;
      g->cur_y += g->step;

      while (g->cur_y >= g->max_y && g->parse > 0) {
         g->step = (1 << g->parse) * g->line_size;
         g->cur_y = g->start_y + (g->step >> 1);
         --g->parse;
      }
   }
}

static stbi_uc *stbi__process_gif_raster(stbi__context *s, stbi__gif *g)
{
   stbi_uc lzw_cs;
   stbi__int32 len, init_code;
   stbi__uint32 first;
   stbi__int32 codesize, codemask, avail, oldcode, bits, valid_bits, clear;
   stbi__gif_lzw *p;

   lzw_cs = stbi__get8(s);
   if (lzw_cs > 12) return NULL;
   clear = 1 << lzw_cs;
   first = 1;
   codesize = lzw_cs + 1;
   codemask = (1 << codesize) - 1;
   bits = 0;
   valid_bits = 0;
   for (init_code = 0; init_code < clear; init_code++) {
      g->codes[init_code].prefix = -1;
      g->codes[init_code].first = (stbi_uc) init_code;
      g->codes[init_code].suffix = (stbi_uc) init_code;
   }

   // support no starting clear code
   avail = clear+2;
   oldcode = -1;

   len = 0;
   for(;;) {
      if (valid_bits < codesize) {
         if (len == 0) {
            len = stbi__get8(s); // start new block
            if (len == 0)
               return g->out;
         }
         --len;
         bits |= (stbi__int32) stbi__get8(s) << valid_bits;
         valid_bits += 8;
      } else {
         stbi__int32 code = bits & codemask;
         bits >>= codesize;
         valid_bits -= codesize;
         // @OPTIMIZE: is there some way we can accelerate the non-clear path?
         if (code == clear) {  // clear code
            codesize = lzw_cs + 1;
            codemask = (1 << codesize) - 1;
            avail = clear + 2;
            oldcode = -1;
            first = 0;
         } else if (code == clear + 1) { // end of stream code
            stbi__skip(s, len);
            while ((len = stbi__get8(s)) > 0)
               stbi__skip(s,len);
            return g->out;
         } else if (code <= avail) {
            if (first) {
               return stbi__errpuc("no clear code", "Corrupt GIF");
            }

            if (oldcode >= 0) {
               p = &g->codes[avail++];
               if (avail > 8192) {
                  return stbi__errpuc("too many codes", "Corrupt GIF");
               }

               p->prefix = (stbi__int16) oldcode;
               p->first = g->codes[oldcode].first;
               p->suffix = (code == avail) ? p->first : g->codes[code].first;
            } else if (code == avail)
               return stbi__errpuc("illegal code in raster", "Corrupt GIF");

            stbi__out_gif_code(g, (stbi__uint16) code);

            if ((avail & codemask) == 0 && avail <= 0x0FFF) {
               codesize++;
               codemask = (1 << codesize) - 1;
            }

            oldcode = code;
         } else {
            return stbi__errpuc("illegal code in raster", "Corrupt GIF");
         }
      }
   }
}

// this function is designed to support animated gifs, although stb_image doesn't support it
// two back is the image from two frames ago, used for a very specific disposal format
static stbi_uc *stbi__gif_load_next(stbi__context *s, stbi__gif *g, int *comp, int req_comp, stbi_uc *two_back)
{
   int dispose;
   int first_frame;
   int pi;
   int pcount;
   STBI_NOTUSED(req_comp);

   // on first frame, any non-written pixels get the background colour (non-transparent)
   first_frame = 0;
   if (g->out == 0) {
      if (!stbi__gif_header(s, g, comp,0)) return 0; // stbi__g_failure_reason set by stbi__gif_header
      if (!stbi__mad3sizes_valid(4, g->w, g->h, 0))
         return stbi__errpuc("too large", "GIF image is too large");
      pcount = g->w * g->h;
      g->out = (stbi_uc *) stbi__malloc(4 * pcount);
      g->background = (stbi_uc *) stbi__malloc(4 * pcount);
      g->history = (stbi_uc *) stbi__malloc(pcount);
      if (!g->out || !g->background || !g->history)
         return stbi__errpuc("outofmem", "Out of memory");

      // image is treated as "transparent" at the start - ie, nothing overwrites the current background;
      // background colour is only used for pixels that are not rendered first frame, after that "background"
      // color refers to the color that was there the previous frame.
      memset(g->out, 0x00, 4 * pcount);
      memset(g->background, 0x00, 4 * pcount); // state of the background (starts transparent)
      memset(g->history, 0x00, pcount);        // pixels that were affected previous frame
      first_frame = 1;
   } else {
      // second frame - how do we dispose of the previous one?
      dispose = (g->eflags & 0x1C) >> 2;
      pcount = g->w * g->h;

      if ((dispose == 3) && (two_back == 0)) {
         dispose = 2; // if I don't have an image to revert back to, default to the old background
      }

      if (dispose == 3) { // use previous graphic
         for (pi = 0; pi < pcount; ++pi) {
            if (g->history[pi]) {
               memcpy( &g->out[pi * 4], &two_back[pi * 4], 4 );
            }
         }
      } else if (dispose == 2) {
         // restore what was changed last frame to background before that frame;
         for (pi = 0; pi < pcount; ++pi) {
            if (g->history[pi]) {
               memcpy( &g->out[pi * 4], &g->background[pi * 4], 4 );
            }
         }
      } else {
         // This is a non-disposal case eithe way, so just
         // leave the pixels as is, and they will become the new background
         // 1: do not dispose
         // 0:  not specified.
      }

      // background is what out is after the undoing of the previou frame;
      memcpy( g->background, g->out, 4 * g->w * g->h );
   }

   // clear my history;
   memset( g->history, 0x00, g->w * g->h );        // pixels that were affected previous frame

   for (;;) {
      int tag = stbi__get8(s);
      switch (tag) {
         case 0x2C: /* Image Descriptor */
         {
            stbi__int32 x, y, w, h;
            stbi_uc *o;

            x = stbi__get16le(s);
            y = stbi__get16le(s);
            w = stbi__get16le(s);
            h = stbi__get16le(s);
            if (((x + w) > (g->w)) || ((y + h) > (g->h)))
               return stbi__errpuc("bad Image Descriptor", "Corrupt GIF");

            g->line_size = g->w * 4;
            g->start_x = x * 4;
            g->start_y = y * g->line_size;
            g->max_x   = g->start_x + w * 4;
            g->max_y   = g->start_y + h * g->line_size;
            g->cur_x   = g->start_x;
            g->cur_y   = g->start_y;

            // if the width of the specified rectangle is 0, that means
            // we may not see *any* pixels or the image is malformed;
            // to make sure this is caught, move the current y down to
            // max_y (which is what out_gif_code checks).
            if (w == 0)
               g->cur_y = g->max_y;

            g->lflags = stbi__get8(s);

            if (g->lflags & 0x40) {
               g->step = 8 * g->line_size; // first interlaced spacing
               g->parse = 3;
            } else {
               g->step = g->line_size;
               g->parse = 0;
            }

            if (g->lflags & 0x80) {
               stbi__gif_parse_colortable(s,g->lpal, 2 << (g->lflags & 7), g->eflags & 0x01 ? g->transparent : -1);
               g->color_table = (stbi_uc *) g->lpal;
            } else if (g->flags & 0x80) {
               g->color_table = (stbi_uc *) g->pal;
            } else
               return stbi__errpuc("missing color table", "Corrupt GIF");

            o = stbi__process_gif_raster(s, g);
            if (!o) return NULL;

            // if this was the first frame,
            pcount = g->w * g->h;
            if (first_frame && (g->bgindex > 0)) {
               // if first frame, any pixel not drawn to gets the background color
               for (pi = 0; pi < pcount; ++pi) {
                  if (g->history[pi] == 0) {
                     g->pal[g->bgindex][3] = 255; // just in case it was made transparent, undo that; It will be reset next frame if need be;
                     memcpy( &g->out[pi * 4], &g->pal[g->bgindex], 4 );
                  }
               }
            }

            return o;
         }

         case 0x21: // Comment Extension.
         {
            int len;
            int ext = stbi__get8(s);
            if (ext == 0xF9) { // Graphic Control Extension.
               len = stbi__get8(s);
               if (len == 4) {
                  g->eflags = stbi__get8(s);
                  g->delay = 10 * stbi__get16le(s); // delay - 1/100th of a second, saving as 1/1000ths.

                  // unset old transparent
                  if (g->transparent >= 0) {
                     g->pal[g->transparent][3] = 255;
                  }
                  if (g->eflags & 0x01) {
                     g->transparent = stbi__get8(s);
                     if (g->transparent >= 0) {
                        g->pal[g->transparent][3] = 0;
                     }
                  } else {
                     // don't need transparent
                     stbi__skip(s, 1);
                     g->transparent = -1;
                  }
               } else {
                  stbi__skip(s, len);
                  break;
               }
            }
            while ((len = stbi__get8(s)) != 0) {
               stbi__skip(s, len);
            }
            break;
         }

         case 0x3B: // gif stream termination code
            return (stbi_uc *) s; // using '1' causes warning on some compilers

         default:
            return stbi__errpuc("unknown code", "Corrupt GIF");
      }
   }
}

static void *stbi__load_gif_main_outofmem(stbi__gif *g, stbi_uc *out, int **delays)
{
   STBI_FREE(g->out);
   STBI_FREE(g->history);
   STBI_FREE(g->background);

   if (out) STBI_FREE(out);
   if (delays && *delays) STBI_FREE(*delays);
   return stbi__errpuc("outofmem", "Out of memory");
}

static void *stbi__load_gif_main(stbi__context *s, int **delays, int *x, int *y, int *z, int *comp, int req_comp)
{
   if (stbi__gif_test(s)) {
      int layers = 0;
      stbi_uc *u = 0;
      stbi_uc *out = 0;
      stbi_uc *two_back = 0;
      stbi__gif g;
      int stride;
      int out_size = 0;
      int delays_size = 0;

      STBI_NOTUSED(out_size);
      STBI_NOTUSED(delays_size);

      memset(&g, 0, sizeof(g));
      if (delays) {
         *delays = 0;
      }

      do {
         u = stbi__gif_load_next(s, &g, comp, req_comp, two_back);
         if (u == (stbi_uc *) s) u = 0;  // end of animated gif marker

         if (u) {
            *x = g.w;
            *y = g.h;
            ++layers;
            stride = g.w * g.h * 4;

            if (out) {
               void *tmp = (stbi_uc*) STBI_REALLOC_SIZED( out, out_size, layers * stride );
               if (!tmp)
                  return stbi__load_gif_main_outofmem(&g, out, delays);
               else {
                   out = (stbi_uc*) tmp;
                   out_size = layers * stride;
               }

               if (delays) {
                  int *new_delays = (int*) STBI_REALLOC_SIZED( *delays, delays_size, sizeof(int) * layers );
                  if (!new_delays)
                     return stbi__load_gif_main_outofmem(&g, out, delays);
                  *delays = new_delays;
                  delays_size = layers * sizeof(int);
               }
            } else {
               out = (stbi_uc*)stbi__malloc( layers * stride );
               if (!out)
                  return stbi__load_gif_main_outofmem(&g, out, delays);
               out_size = layers * stride;
               if (delays) {
                  *delays = (int*) stbi__malloc( layers * sizeof(int) );
                  if (!*delays)
                     return stbi__load_gif_main_outofmem(&g, out, delays);
                  delays_size = layers * sizeof(int);
               }
            }
            memcpy( out + ((layers - 1) * stride), u, stride );
            if (layers >= 2) {
               two_back = out - 2 * stride;
            }

            if (delays) {
               (*delays)[layers - 1U] = g.delay;
            }
         }
      } while (u != 0);

      // free temp buffer;
      STBI_FREE(g.out);
      STBI_FREE(g.history);
      STBI_FREE(g.background);

      // do the final conversion after loading everything;
      if (req_comp && req_comp != 4)
         out = stbi__convert_format(out, 4, req_comp, layers * g.w, g.h);

      *z = layers;
      return out;
   } else {
      return stbi__errpuc("not GIF", "Image was not as a gif type.");
   }
}

static void *stbi__gif_load(stbi__context *s, int *x, int *y, int *comp, int req_comp, stbi__result_info *ri)
{
   stbi_uc *u = 0;
   stbi__gif g;
   memset(&g, 0, sizeof(g));
   STBI_NOTUSED(ri);

   u = stbi__gif_load_next(s, &g, comp, req_comp, 0);
   if (u == (stbi_uc *) s) u = 0;  // end of animated gif marker
   if (u) {
      *x = g.w;
      *y = g.h;

      // moved conversion to after successful load so that the same
      // can be done for multiple frames.
      if (req_comp && req_comp != 4)
         u = stbi__convert_format(u, 4, req_comp, g.w, g.h);
   } else if (g.out) {
      // if there was an error and we allocated an image buffer, free it!
      STBI_FREE(g.out);
   }

   // free buffers needed for multiple frame loading;
   STBI_FREE(g.history);
   STBI_FREE(g.background);

   return u;
}

static int stbi__gif_info(stbi__context *s, int *x, int *y, int *comp)
{
   return stbi__gif_info_raw(s,x,y,comp);
}
#endif

// *************************************************************************************************
// Radiance RGBE HDR loader
// originally by Nicolas Schulz
#ifndef STBI_NO_HDR
static int stbi__hdr_test_core(stbi__context *s, const char *signature)
{
   int i;
   for (i=0; signature[i]; ++i)
      if (stbi__get8(s) != signature[i])
          return 0;
   stbi__rewind(s);
   return 1;
}

static int stbi__hdr_test(stbi__context* s)
{
   int r = stbi__hdr_test_core(s, "#?RADIANCE\n");
   stbi__rewind(s);
   if(!r) {
       r = stbi__hdr_test_core(s, "#?RGBE\n");
       stbi__rewind(s);
   }
   return r;
}

#define STBI__HDR_BUFLEN  1024
static char *stbi__hdr_gettoken(stbi__context *z, char *buffer)
{
   int len=0;
   char c = '\0';

   c = (char) stbi__get8(z);

   while (!stbi__at_eof(z) && c != '\n') {
      buffer[len++] = c;
      if (len == STBI__HDR_BUFLEN-1) {
         // flush to end of line
         while (!stbi__at_eof(z) && stbi__get8(z) != '\n')
            ;
         break;
      }
      c = (char) stbi__get8(z);
   }

   buffer[len] = 0;
   return buffer;
}

static void stbi__hdr_convert(float *output, stbi_uc *input, int req_comp)
{
   if ( input[3] != 0 ) {
      float f1;
      // Exponent
      f1 = (float) ldexp(1.0f, input[3] - (int)(128 + 8));
      if (req_comp <= 2)
         output[0] = (input[0] + input[1] + input[2]) * f1 / 3;
      else {
         output[0] = input[0] * f1;
         output[1] = input[1] * f1;
         output[2] = input[2] * f1;
      }
      if (req_comp == 2) output[1] = 1;
      if (req_comp == 4) output[3] = 1;
   } else {
      switch (req_comp) {
         case 4: output[3] = 1; /* fallthrough */
         case 3: output[0] = output[1] = output[2] = 0;
                 break;
         case 2: output[1] = 1; /* fallthrough */
         case 1: output[0] = 0;
                 break;
      }
   }
}

static float *stbi__hdr_load(stbi__context *s, int *x, int *y, int *comp, int req_comp, stbi__result_info *ri)
{
   char buffer[STBI__HDR_BUFLEN];
   char *token;
   int valid = 0;
   int width, height;
   stbi_uc *scanline;
   float *hdr_data;
   int len;
   unsigned char count, value;
   int i, j, k, c1,c2, z;
   const char *headerToken;
   STBI_NOTUSED(ri);

   // Check identifier
   headerToken = stbi__hdr_gettoken(s,buffer);
   if (strcmp(headerToken, "#?RADIANCE") != 0 && strcmp(headerToken, "#?RGBE") != 0)
      return stbi__errpf("not HDR", "Corrupt HDR image");

   // Parse header
   for(;;) {
      token = stbi__hdr_gettoken(s,buffer);
      if (token[0] == 0) break;
      if (strcmp(token, "FORMAT=32-bit_rle_rgbe") == 0) valid = 1;
   }

   if (!valid)    return stbi__errpf("unsupported format", "Unsupported HDR format");

   // Parse width and height
   // can't use sscanf() if we're not using stdio!
   token = stbi__hdr_gettoken(s,buffer);
   if (strncmp(token, "-Y ", 3))  return stbi__errpf("unsupported data layout", "Unsupported HDR format");
   token += 3;
   height = (int) strtol(token, &token, 10);
   while (*token == ' ') ++token;
   if (strncmp(token, "+X ", 3))  return stbi__errpf("unsupported data layout", "Unsupported HDR format");
   token += 3;
   width = (int) strtol(token, NULL, 10);

   if (height > STBI_MAX_DIMENSIONS) return stbi__errpf("too large","Very large image (corrupt?)");
   if (width > STBI_MAX_DIMENSIONS) return stbi__errpf("too large","Very large image (corrupt?)");

   *x = width;
   *y = height;

   if (comp) *comp = 3;
   if (req_comp == 0) req_comp = 3;

   if (!stbi__mad4sizes_valid(width, height, req_comp, sizeof(float), 0))
      return stbi__errpf("too large", "HDR image is too large");

   // Read data
   hdr_data = (float *) stbi__malloc_mad4(width, height, req_comp, sizeof(float), 0);
   if (!hdr_data)
      return stbi__errpf("outofmem", "Out of memory");

   // Load image data
   // image data is stored as some number of sca
   if ( width < 8 || width >= 32768) {
      // Read flat data
      for (j=0; j < height; ++j) {
         for (i=0; i < width; ++i) {
            stbi_uc rgbe[4];
           main_decode_loop:
            stbi__getn(s, rgbe, 4);
            stbi__hdr_convert(hdr_data + j * width * req_comp + i * req_comp, rgbe, req_comp);
         }
      }
   } else {
      // Read RLE-encoded data
      scanline = NULL;

      for (j = 0; j < height; ++j) {
         c1 = stbi__get8(s);
         c2 = stbi__get8(s);
         len = stbi__get8(s);
         if (c1 != 2 || c2 != 2 || (len & 0x80)) {
            // not run-length encoded, so we have to actually use THIS data as a decoded
            // pixel (note this can't be a valid pixel--one of RGB must be >= 128)
            stbi_uc rgbe[4];
            rgbe[0] = (stbi_uc) c1;
            rgbe[1] = (stbi_uc) c2;
            rgbe[2] = (stbi_uc) len;
            rgbe[3] = (stbi_uc) stbi__get8(s);
            stbi__hdr_convert(hdr_data, rgbe, req_comp);
            i = 1;
            j = 0;
            STBI_FREE(scanline);
            goto main_decode_loop; // yes, this makes no sense
         }
         len <<= 8;
         len |= stbi__get8(s);
         if (len != width) { STBI_FREE(hdr_data); STBI_FREE(scanline); return stbi__errpf("invalid decoded scanline length", "corrupt HDR"); }
         if (scanline == NULL) {
            scanline = (stbi_uc *) stbi__malloc_mad2(width, 4, 0);
            if (!scanline) {
               STBI_FREE(hdr_data);
               return stbi__errpf("outofmem", "Out of memory");
            }
         }

         for (k = 0; k < 4; ++k) {
            int nleft;
            i = 0;
            while ((nleft = width - i) > 0) {
               count = stbi__get8(s);
               if (count > 128) {
                  // Run
                  value = stbi__get8(s);
                  count -= 128;
                  if (count > nleft) { STBI_FREE(hdr_data); STBI_FREE(scanline); return stbi__errpf("corrupt", "bad RLE data in HDR"); }
                  for (z = 0; z < count; ++z)
                     scanline[i++ * 4 + k] = value;
               } else {
                  // Dump
                  if (count > nleft) { STBI_FREE(hdr_data); STBI_FREE(scanline); return stbi__errpf("corrupt", "bad RLE data in HDR"); }
                  for (z = 0; z < count; ++z)
                     scanline[i++ * 4 + k] = stbi__get8(s);
               }
            }
         }
         for (i=0; i < width; ++i)
            stbi__hdr_convert(hdr_data+(j*width + i)*req_comp, scanline + i*4, req_comp);
      }
      if (scanline)
         STBI_FREE(scanline);
   }

   return hdr_data;
}

static int stbi__hdr_info(stbi__context *s, int *x, int *y, int *comp)
{
   char buffer[STBI__HDR_BUFLEN];
   char *token;
   int valid = 0;
   int dummy;

   if (!x) x = &dummy;
   if (!y) y = &dummy;
   if (!comp) comp = &dummy;

   if (stbi__hdr_test(s) == 0) {
       stbi__rewind( s );
       return 0;
   }

   for(;;) {
      token = stbi__hdr_gettoken(s,buffer);
      if (token[0] == 0) break;
      if (strcmp(token, "FORMAT=32-bit_rle_rgbe") == 0) valid = 1;
   }

   if (!valid) {
       stbi__rewind( s );
       return 0;
   }
   token = stbi__hdr_gettoken(s,buffer);
   if (strncmp(token, "-Y ", 3)) {
       stbi__rewind( s );
       return 0;
   }
   token += 3;
   *y = (int) strtol(token, &token, 10);
   while (*token == ' ') ++token;
   if (strncmp(token, "+X ", 3)) {
       stbi__rewind( s );
       return 0;
   }
   token += 3;
   *x = (int) strtol(token, NULL, 10);
   *comp = 3;
   return 1;
}
#endif // STBI_NO_HDR

#ifndef STBI_NO_BMP
static int stbi__bmp_info(stbi__context *s, int *x, int *y, int *comp)
{
   void *p;
   stbi__bmp_data info;

   info.all_a = 255;
   p = stbi__bmp_parse_header(s, &info);
   if (p == NULL) {
      stbi__rewind( s );
      return 0;
   }
   if (x) *x = s->img_x;
   if (y) *y = s->img_y;
   if (comp) {
      if (info.bpp == 24 && info.ma == 0xff000000)
         *comp = 3;
      else
         *comp = info.ma ? 4 : 3;
   }
   return 1;
}
#endif

#ifndef STBI_NO_PSD
static int stbi__psd_info(stbi__context *s, int *x, int *y, int *comp)
{
   int channelCount, dummy, depth;
   if (!x) x = &dummy;
   if (!y) y = &dummy;
   if (!comp) comp = &dummy;
   if (stbi__get32be(s) != 0x38425053) {
       stbi__rewind( s );
       return 0;
   }
   if (stbi__get16be(s) != 1) {
       stbi__rewind( s );
       return 0;
   }
   stbi__skip(s, 6);
   channelCount = stbi__get16be(s);
   if (channelCount < 0 || channelCount > 16) {
       stbi__rewind( s );
       return 0;
   }
   *y = stbi__get32be(s);
   *x = stbi__get32be(s);
   depth = stbi__get16be(s);
   if (depth != 8 && depth != 16) {
       stbi__rewind( s );
       return 0;
   }
   if (stbi__get16be(s) != 3) {
       stbi__rewind( s );
       return 0;
   }
   *comp = 4;
   return 1;
}

static int stbi__psd_is16(stbi__context *s)
{
   int channelCount, depth;
   if (stbi__get32be(s) != 0x38425053) {
       stbi__rewind( s );
       return 0;
   }
   if (stbi__get16be(s) != 1) {
       stbi__rewind( s );
       return 0;
   }
   stbi__skip(s, 6);
   channelCount = stbi__get16be(s);
   if (channelCount < 0 || channelCount > 16) {
       stbi__rewind( s );
       return 0;
   }
   STBI_NOTUSED(stbi__get32be(s));
   STBI_NOTUSED(stbi__get32be(s));
   depth = stbi__get16be(s);
   if (depth != 16) {
       stbi__rewind( s );
       return 0;
   }
   return 1;
}
#endif

#ifndef STBI_NO_PIC
static int stbi__pic_info(stbi__context *s, int *x, int *y, int *comp)
{
   int act_comp=0,num_packets=0,chained,dummy;
   stbi__pic_packet packets[10];

   if (!x) x = &dummy;
   if (!y) y = &dummy;
   if (!comp) comp = &dummy;

   if (!stbi__pic_is4(s,"\x53\x80\xF6\x34")) {
      stbi__rewind(s);
      return 0;
   }

   stbi__skip(s, 88);

   *x = stbi__get16be(s);
   *y = stbi__get16be(s);
   if (stbi__at_eof(s)) {
      stbi__rewind( s);
      return 0;
   }
   if ( (*x) != 0 && (1 << 28) / (*x) < (*y)) {
      stbi__rewind( s );
      return 0;
   }

   stbi__skip(s, 8);

   do {
      stbi__pic_packet *packet;

      if (num_packets==sizeof(packets)/sizeof(packets[0]))
         return 0;

      packet = &packets[num_packets++];
      chained = stbi__get8(s);
      packet->size    = stbi__get8(s);
      packet->type    = stbi__get8(s);
      packet->channel = stbi__get8(s);
      act_comp |= packet->channel;

      if (stbi__at_eof(s)) {
          stbi__rewind( s );
          return 0;
      }
      if (packet->size != 8) {
          stbi__rewind( s );
          return 0;
      }
   } while (chained);

   *comp = (act_comp & 0x10 ? 4 : 3);

   return 1;
}
#endif

// *************************************************************************************************
// Portable Gray Map and Portable Pixel Map loader
// by Ken Miller
//
// PGM: http://netpbm.sourceforge.net/doc/pgm.html
// PPM: http://netpbm.sourceforge.net/doc/ppm.html
//
// Known limitations:
//    Does not support comments in the header section
//    Does not support ASCII image data (formats P2 and P3)

#ifndef STBI_NO_PNM

static int      stbi__pnm_test(stbi__context *s)
{
   char p, t;
   p = (char) stbi__get8(s);
   t = (char) stbi__get8(s);
   if (p != 'P' || (t != '5' && t != '6')) {
       stbi__rewind( s );
       return 0;
   }
   return 1;
}

static void *stbi__pnm_load(stbi__context *s, int *x, int *y, int *comp, int req_comp, stbi__result_info *ri)
{
   stbi_uc *out;
   STBI_NOTUSED(ri);

   ri->bits_per_channel = stbi__pnm_info(s, (int *)&s->img_x, (int *)&s->img_y, (int *)&s->img_n);
   if (ri->bits_per_channel == 0)
      return 0;

   if (s->img_y > STBI_MAX_DIMENSIONS) return stbi__errpuc("too large","Very large image (corrupt?)");
   if (s->img_x > STBI_MAX_DIMENSIONS) return stbi__errpuc("too large","Very large image (corrupt?)");

   *x = s->img_x;
   *y = s->img_y;
   if (comp) *comp = s->img_n;

   if (!stbi__mad4sizes_valid(s->img_n, s->img_x, s->img_y, ri->bits_per_channel / 8, 0))
      return stbi__errpuc("too large", "PNM too large");

   out = (stbi_uc *) stbi__malloc_mad4(s->img_n, s->img_x, s->img_y, ri->bits_per_channel / 8, 0);
   if (!out) return stbi__errpuc("outofmem", "Out of memory");
   stbi__getn(s, out, s->img_n * s->img_x * s->img_y * (ri->bits_per_channel / 8));

   if (req_comp && req_comp != s->img_n) {
      out = stbi__convert_format(out, s->img_n, req_comp, s->img_x, s->img_y);
      if (out == NULL) return out; // stbi__convert_format frees input on failure
   }
   return out;
}

static int      stbi__pnm_isspace(char c)
{
   return c == ' ' || c == '\t' || c == '\n' || c == '\v' || c == '\f' || c == '\r';
}

static void     stbi__pnm_skip_whitespace(stbi__context *s, char *c)
{
   for (;;) {
      while (!stbi__at_eof(s) && stbi__pnm_isspace(*c))
         *c = (char) stbi__get8(s);

      if (stbi__at_eof(s) || *c != '#')
         break;

      while (!stbi__at_eof(s) && *c != '\n' && *c != '\r' )
         *c = (char) stbi__get8(s);
   }
}

static int      stbi__pnm_isdigit(char c)
{
   return c >= '0' && c <= '9';
}

static int      stbi__pnm_getinteger(stbi__context *s, char *c)
{
   int value = 0;

   while (!stbi__at_eof(s) && stbi__pnm_isdigit(*c)) {
      value = value*10 + (*c - '0');
      *c = (char) stbi__get8(s);
   }

   return value;
}

static int      stbi__pnm_info(stbi__context *s, int *x, int *y, int *comp)
{
   int maxv, dummy;
   char c, p, t;

   if (!x) x = &dummy;
   if (!y) y = &dummy;
   if (!comp) comp = &dummy;

   stbi__rewind(s);

   // Get identifier
   p = (char) stbi__get8(s);
   t = (char) stbi__get8(s);
   if (p != 'P' || (t != '5' && t != '6')) {
       stbi__rewind(s);
       return 0;
   }

   *comp = (t == '6') ? 3 : 1;  // '5' is 1-component .pgm; '6' is 3-component .ppm

   c = (char) stbi__get8(s);
   stbi__pnm_skip_whitespace(s, &c);

   *x = stbi__pnm_getinteger(s, &c); // read width
   stbi__pnm_skip_whitespace(s, &c);

   *y = stbi__pnm_getinteger(s, &c); // read height
   stbi__pnm_skip_whitespace(s, &c);

   maxv = stbi__pnm_getinteger(s, &c);  // read max value
   if (maxv > 65535)
      return stbi__err("max value > 65535", "PPM image supports only 8-bit and 16-bit images");
   else if (maxv > 255)
      return 16;
   else
      return 8;
}

static int stbi__pnm_is16(stbi__context *s)
{
   if (stbi__pnm_info(s, NULL, NULL, NULL) == 16)
	   return 1;
   return 0;
}
#endif

static int stbi__info_main(stbi__context *s, int *x, int *y, int *comp)
{
   #ifndef STBI_NO_JPEG
   if (stbi__jpeg_info(s, x, y, comp)) return 1;
   #endif

   #ifndef STBI_NO_PNG
   if (stbi__png_info(s, x, y, comp))  return 1;
   #endif

   #ifndef STBI_NO_GIF
   if (stbi__gif_info(s, x, y, comp))  return 1;
   #endif

   #ifndef STBI_NO_BMP
   if (stbi__bmp_info(s, x, y, comp))  return 1;
   #endif

   #ifndef STBI_NO_PSD
   if (stbi__psd_info(s, x, y, comp))  return 1;
   #endif

   #ifndef STBI_NO_PIC
   if (stbi__pic_info(s, x, y, comp))  return 1;
   #endif

   #ifndef STBI_NO_PNM
   if (stbi__pnm_info(s, x, y, comp))  return 1;
   #endif

   #ifndef STBI_NO_HDR
   if (stbi__hdr_info(s, x, y, comp))  return 1;
   #endif

   // test tga last because it's a crappy test!
   #ifndef STBI_NO_TGA
   if (stbi__tga_info(s, x, y, comp))
       return 1;
   #endif
   return stbi__err("unknown image type", "Image not of any known type, or corrupt");
}

static int stbi__is_16_main(stbi__context *s)
{
   #ifndef STBI_NO_PNG
   if (stbi__png_is16(s))  return 1;
   #endif

   #ifndef STBI_NO_PSD
   if (stbi__psd_is16(s))  return 1;
   #endif

   #ifndef STBI_NO_PNM
   if (stbi__pnm_is16(s))  return 1;
   #endif
   return 0;
}

#ifndef STBI_NO_STDIO
STBIDEF int stbi_info(char const *filename, int *x, int *y, int *comp)
{
    FILE *f = stbi__fopen(filename, "rb");
    int result;
    if (!f) return stbi__err("can't fopen", "Unable to open file");
    result = stbi_info_from_file(f, x, y, comp);
    fclose(f);
    return result;
}

STBIDEF int stbi_info_from_file(FILE *f, int *x, int *y, int *comp)
{
   int r;
   stbi__context s;
   long pos = ftell(f);
   stbi__start_file(&s, f);
   r = stbi__info_main(&s,x,y,comp);
   fseek(f,pos,SEEK_SET);
   return r;
}

STBIDEF int stbi_is_16_bit(char const *filename)
{
    FILE *f = stbi__fopen(filename, "rb");
    int result;
    if (!f) return stbi__err("can't fopen", "Unable to open file");
    result = stbi_is_16_bit_from_file(f);
    fclose(f);
    return result;
}

STBIDEF int stbi_is_16_bit_from_file(FILE *f)
{
   int r;
   stbi__context s;
   long pos = ftell(f);
   stbi__start_file(&s, f);
   r = stbi__is_16_main(&s);
   fseek(f,pos,SEEK_SET);
   return r;
}
#endif // !STBI_NO_STDIO

STBIDEF int stbi_info_from_memory(stbi_uc const *buffer, int len, int *x, int *y, int *comp)
{
   stbi__context s;
   stbi__start_mem(&s,buffer,len);
   return stbi__info_main(&s,x,y,comp);
}

STBIDEF int stbi_info_from_callbacks(stbi_io_callbacks const *c, void *user, int *x, int *y, int *comp)
{
   stbi__context s;
   stbi__start_callbacks(&s, (stbi_io_callbacks *) c, user);
   return stbi__info_main(&s,x,y,comp);
}

STBIDEF int stbi_is_16_bit_from_memory(stbi_uc const *buffer, int len)
{
   stbi__context s;
   stbi__start_mem(&s,buffer,len);
   return stbi__is_16_main(&s);
}

STBIDEF int stbi_is_16_bit_from_callbacks(stbi_io_callbacks const *c, void *user)
{
   stbi__context s;
   stbi__start_callbacks(&s, (stbi_io_callbacks *) c, user);
   return stbi__is_16_main(&s);
}

#endif // STB_IMAGE_IMPLEMENTATION

/*
   revision history:
      2.20  (2019-02-07) support utf8 filenames in Windows; fix warnings and platform ifdefs
      2.19  (2018-02-11) fix warning
      2.18  (2018-01-30) fix warnings
      2.17  (2018-01-29) change sbti__shiftsigned to avoid clang -O2 bug
                         1-bit BMP
                         *_is_16_bit api
                         avoid warnings
      2.16  (2017-07-23) all functions have 16-bit variants;
                         STBI_NO_STDIO works again;
                         compilation fixes;
                         fix rounding in unpremultiply;
                         optimize vertical flip;
                         disable raw_len validation;
                         documentation fixes
      2.15  (2017-03-18) fix png-1,2,4 bug; now all Imagenet JPGs decode;
                         warning fixes; disable run-time SSE detection on gcc;
                         uniform handling of optional "return" values;
                         thread-safe initialization of zlib tables
      2.14  (2017-03-03) remove deprecated STBI_JPEG_OLD; fixes for Imagenet JPGs
      2.13  (2016-11-29) add 16-bit API, only supported for PNG right now
      2.12  (2016-04-02) fix typo in 2.11 PSD fix that caused crashes
      2.11  (2016-04-02) allocate large structures on the stack
                         remove white matting for transparent PSD
                         fix reported channel count for PNG & BMP
                         re-enable SSE2 in non-gcc 64-bit
                         support RGB-formatted JPEG
                         read 16-bit PNGs (only as 8-bit)
      2.10  (2016-01-22) avoid warning introduced in 2.09 by STBI_REALLOC_SIZED
      2.09  (2016-01-16) allow comments in PNM files
                         16-bit-per-pixel TGA (not bit-per-component)
                         info() for TGA could break due to .hdr handling
                         info() for BMP to shares code instead of sloppy parse
                         can use STBI_REALLOC_SIZED if allocator doesn't support realloc
                         code cleanup
      2.08  (2015-09-13) fix to 2.07 cleanup, reading RGB PSD as RGBA
      2.07  (2015-09-13) fix compiler warnings
                         partial animated GIF support
                         limited 16-bpc PSD support
                         #ifdef unused functions
                         bug with < 92 byte PIC,PNM,HDR,TGA
      2.06  (2015-04-19) fix bug where PSD returns wrong '*comp' value
      2.05  (2015-04-19) fix bug in progressive JPEG handling, fix warning
      2.04  (2015-04-15) try to re-enable SIMD on MinGW 64-bit
      2.03  (2015-04-12) extra corruption checking (mmozeiko)
                         stbi_set_flip_vertically_on_load (nguillemot)
                         fix NEON support; fix mingw support
      2.02  (2015-01-19) fix incorrect assert, fix warning
      2.01  (2015-01-17) fix various warnings; suppress SIMD on gcc 32-bit without -msse2
      2.00b (2014-12-25) fix STBI_MALLOC in progressive JPEG
      2.00  (2014-12-25) optimize JPG, including x86 SSE2 & NEON SIMD (ryg)
                         progressive JPEG (stb)
                         PGM/PPM support (Ken Miller)
                         STBI_MALLOC,STBI_REALLOC,STBI_FREE
                         GIF bugfix -- seemingly never worked
                         STBI_NO_*, STBI_ONLY_*
      1.48  (2014-12-14) fix incorrectly-named assert()
      1.47  (2014-12-14) 1/2/4-bit PNG support, both direct and paletted (Omar Cornut & stb)
                         optimize PNG (ryg)
                         fix bug in interlaced PNG with user-specified channel count (stb)
      1.46  (2014-08-26)
              fix broken tRNS chunk (colorkey-style transparency) in non-paletted PNG
      1.45  (2014-08-16)
              fix MSVC-ARM internal compiler error by wrapping malloc
      1.44  (2014-08-07)
              various warning fixes from Ronny Chevalier
      1.43  (2014-07-15)
              fix MSVC-only compiler problem in code changed in 1.42
      1.42  (2014-07-09)
              don't define _CRT_SECURE_NO_WARNINGS (affects user code)
              fixes to stbi__cleanup_jpeg path
              added STBI_ASSERT to avoid requiring assert.h
      1.41  (2014-06-25)
              fix search&replace from 1.36 that messed up comments/error messages
      1.40  (2014-06-22)
              fix gcc struct-initialization warning
      1.39  (2014-06-15)
              fix to TGA optimization when req_comp != number of components in TGA;
              fix to GIF loading because BMP wasn't rewinding (whoops, no GIFs in my test suite)
              add support for BMP version 5 (more ignored fields)
      1.38  (2014-06-06)
              suppress MSVC warnings on integer casts truncating values
              fix accidental rename of 'skip' field of I/O
      1.37  (2014-06-04)
              remove duplicate typedef
      1.36  (2014-06-03)
              convert to header file single-file library
              if de-iphone isn't set, load iphone images color-swapped instead of returning NULL
      1.35  (2014-05-27)
              various warnings
              fix broken STBI_SIMD path
              fix bug where stbi_load_from_file no longer left file pointer in correct place
              fix broken non-easy path for 32-bit BMP (possibly never used)
              TGA optimization by Arseny Kapoulkine
      1.34  (unknown)
              use STBI_NOTUSED in stbi__resample_row_generic(), fix one more leak in tga failure case
      1.33  (2011-07-14)
              make stbi_is_hdr work in STBI_NO_HDR (as specified), minor compiler-friendly improvements
      1.32  (2011-07-13)
              support for "info" function for all supported filetypes (SpartanJ)
      1.31  (2011-06-20)
              a few more leak fixes, bug in PNG handling (SpartanJ)
      1.30  (2011-06-11)
              added ability to load files via callbacks to accomidate custom input streams (Ben Wenger)
              removed deprecated format-specific test/load functions
              removed support for installable file formats (stbi_loader) -- would have been broken for IO callbacks anyway
              error cases in bmp and tga give messages and don't leak (Raymond Barbiero, grisha)
              fix inefficiency in decoding 32-bit BMP (David Woo)
      1.29  (2010-08-16)
              various warning fixes from Aurelien Pocheville
      1.28  (2010-08-01)
              fix bug in GIF palette transparency (SpartanJ)
      1.27  (2010-08-01)
              cast-to-stbi_uc to fix warnings
      1.26  (2010-07-24)
              fix bug in file buffering for PNG reported by SpartanJ
      1.25  (2010-07-17)
              refix trans_data warning (Won Chun)
      1.24  (2010-07-12)
              perf improvements reading from files on platforms with lock-heavy fgetc()
              minor perf improvements for jpeg
              deprecated type-specific functions so we'll get feedback if they're needed
              attempt to fix trans_data warning (Won Chun)
      1.23    fixed bug in iPhone support
      1.22  (2010-07-10)
              removed image *writing* support
              stbi_info support from Jetro Lauha
              GIF support from Jean-Marc Lienher
              iPhone PNG-extensions from James Brown
              warning-fixes from Nicolas Schulz and Janez Zemva (i.stbi__err. Janez (U+017D)emva)
      1.21    fix use of 'stbi_uc' in header (reported by jon blow)
      1.20    added support for Softimage PIC, by Tom Seddon
      1.19    bug in interlaced PNG corruption check (found by ryg)
      1.18  (2008-08-02)
              fix a threading bug (local mutable static)
      1.17    support interlaced PNG
      1.16    major bugfix - stbi__convert_format converted one too many pixels
      1.15    initialize some fields for thread safety
      1.14    fix threadsafe conversion bug
              header-file-only version (#define STBI_HEADER_FILE_ONLY before including)
      1.13    threadsafe
      1.12    const qualifiers in the API
      1.11    Support installable IDCT, colorspace conversion routines
      1.10    Fixes for 64-bit (don't use "unsigned long")
              optimized upsampling by Fabian "ryg" Giesen
      1.09    Fix format-conversion for PSD code (bad global variables!)
      1.08    Thatcher Ulrich's PSD code integrated by Nicolas Schulz
      1.07    attempt to fix C++ warning/errors again
      1.06    attempt to fix C++ warning/errors again
      1.05    fix TGA loading to return correct *comp and use good luminance calc
      1.04    default float alpha is 1, not 255; use 'void *' for stbi_image_free
      1.03    bugfixes to STBI_NO_STDIO, STBI_NO_HDR
      1.02    support for (subset of) HDR files, float interface for preferred access to them
      1.01    fix bug: possible bug in handling right-side up bmps... not sure
              fix bug: the stbi__bmp_load() and stbi__tga_load() functions didn't work at all
      1.00    interface to zlib that skips zlib header
      0.99    correct handling of alpha in palette
      0.98    TGA loader by lonesock; dynamically add loaders (untested)
      0.97    jpeg errors on too large a file; also catch another malloc failure
      0.96    fix detection of invalid v value - particleman@mollyrocket forum
      0.95    during header scan, seek to markers in case of padding
      0.94    STBI_NO_STDIO to disable stdio usage; rename all #defines the same
      0.93    handle jpegtran output; verbose errors
      0.92    read 4,8,16,24,32-bit BMP files of several formats
      0.91    output 24-bit Windows 3.0 BMP files
      0.90    fix a few more warnings; bump version number to approach 1.0
      0.61    bugfixes due to Marc LeBlanc, Christopher Lloyd
      0.60    fix compiling as c++
      0.59    fix warnings: merge Dave Moore's -Wall fixes
      0.58    fix bug: zlib uncompressed mode len/nlen was wrong endian
      0.57    fix bug: jpg last huffman symbol before marker was >9 bits but less than 16 available
      0.56    fix bug: zlib uncompressed mode len vs. nlen
      0.55    fix bug: restart_interval not initialized to 0
      0.54    allow NULL for 'int *comp'
      0.53    fix bug in png 3->4; speedup png decoding
      0.52    png handles req_comp=3,4 directly; minor cleanup; jpeg comments
      0.51    obey req_comp requests, 1-component jpegs return as 1-component,
              on 'test' only check type, not whether we support this variant
      0.50  (2006-11-19)
              first released version
*/


/*
------------------------------------------------------------------------------
This software is available under 2 licenses -- choose whichever you prefer.
------------------------------------------------------------------------------
ALTERNATIVE A - MIT License
Copyright (c) 2017 Sean Barrett
Permission is hereby granted, free of charge, to any person obtaining a copy of
this software and associated documentation files (the "Software"), to deal in
the Software without restriction, including without limitation the rights to
use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies
of the Software, and to permit persons to whom the Software is furnished to do
so, subject to the following conditions:
The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.
THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
------------------------------------------------------------------------------
ALTERNATIVE B - Public Domain (www.unlicense.org)
This is free and unencumbered software released into the public domain.
Anyone is free to copy, modify, publish, use, compile, sell, or distribute this
software, either in source code form or as a compiled binary, for any purpose,
commercial or non-commercial, and by any means.
In jurisdictions that recognize copyright laws, the author or authors of this
software dedicate any and all copyright interest in the software to the public
domain. We make this dedication for the benefit of the public at large and to
the detriment of our heirs and successors. We intend this dedication to be an
overt act of relinquishment in perpetuity of all present and future rights to
this software under copyright law.
THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
------------------------------------------------------------------------------
*/

```

`dev-deps/stb_image_write.h`:

```h
/* stb_image_write - v1.16 - public domain - http://nothings.org/stb
   writes out PNG/BMP/TGA/JPEG/HDR images to C stdio - Sean Barrett 2010-2015
                                     no warranty implied; use at your own risk

   Before #including,

       #define STB_IMAGE_WRITE_IMPLEMENTATION

   in the file that you want to have the implementation.

   Will probably not work correctly with strict-aliasing optimizations.

ABOUT:

   This header file is a library for writing images to C stdio or a callback.

   The PNG output is not optimal; it is 20-50% larger than the file
   written by a decent optimizing implementation; though providing a custom
   zlib compress function (see STBIW_ZLIB_COMPRESS) can mitigate that.
   This library is designed for source code compactness and simplicity,
   not optimal image file size or run-time performance.

BUILDING:

   You can #define STBIW_ASSERT(x) before the #include to avoid using assert.h.
   You can #define STBIW_MALLOC(), STBIW_REALLOC(), and STBIW_FREE() to replace
   malloc,realloc,free.
   You can #define STBIW_MEMMOVE() to replace memmove()
   You can #define STBIW_ZLIB_COMPRESS to use a custom zlib-style compress function
   for PNG compression (instead of the builtin one), it must have the following signature:
   unsigned char * my_compress(unsigned char *data, int data_len, int *out_len, int quality);
   The returned data will be freed with STBIW_FREE() (free() by default),
   so it must be heap allocated with STBIW_MALLOC() (malloc() by default),

UNICODE:

   If compiling for Windows and you wish to use Unicode filenames, compile
   with
       #define STBIW_WINDOWS_UTF8
   and pass utf8-encoded filenames. Call stbiw_convert_wchar_to_utf8 to convert
   Windows wchar_t filenames to utf8.

USAGE:

   There are five functions, one for each image file format:

     int stbi_write_png(char const *filename, int w, int h, int comp, const void *data, int stride_in_bytes);
     int stbi_write_bmp(char const *filename, int w, int h, int comp, const void *data);
     int stbi_write_tga(char const *filename, int w, int h, int comp, const void *data);
     int stbi_write_jpg(char const *filename, int w, int h, int comp, const void *data, int quality);
     int stbi_write_hdr(char const *filename, int w, int h, int comp, const float *data);

     void stbi_flip_vertically_on_write(int flag); // flag is non-zero to flip data vertically

   There are also five equivalent functions that use an arbitrary write function. You are
   expected to open/close your file-equivalent before and after calling these:

     int stbi_write_png_to_func(stbi_write_func *func, void *context, int w, int h, int comp, const void  *data, int stride_in_bytes);
     int stbi_write_bmp_to_func(stbi_write_func *func, void *context, int w, int h, int comp, const void  *data);
     int stbi_write_tga_to_func(stbi_write_func *func, void *context, int w, int h, int comp, const void  *data);
     int stbi_write_hdr_to_func(stbi_write_func *func, void *context, int w, int h, int comp, const float *data);
     int stbi_write_jpg_to_func(stbi_write_func *func, void *context, int x, int y, int comp, const void *data, int quality);

   where the callback is:
      void stbi_write_func(void *context, void *data, int size);

   You can configure it with these global variables:
      int stbi_write_tga_with_rle;             // defaults to true; set to 0 to disable RLE
      int stbi_write_png_compression_level;    // defaults to 8; set to higher for more compression
      int stbi_write_force_png_filter;         // defaults to -1; set to 0..5 to force a filter mode


   You can define STBI_WRITE_NO_STDIO to disable the file variant of these
   functions, so the library will not use stdio.h at all. However, this will
   also disable HDR writing, because it requires stdio for formatted output.

   Each function returns 0 on failure and non-0 on success.

   The functions create an image file defined by the parameters. The image
   is a rectangle of pixels stored from left-to-right, top-to-bottom.
   Each pixel contains 'comp' channels of data stored interleaved with 8-bits
   per channel, in the following order: 1=Y, 2=YA, 3=RGB, 4=RGBA. (Y is
   monochrome color.) The rectangle is 'w' pixels wide and 'h' pixels tall.
   The *data pointer points to the first byte of the top-left-most pixel.
   For PNG, "stride_in_bytes" is the distance in bytes from the first byte of
   a row of pixels to the first byte of the next row of pixels.

   PNG creates output files with the same number of components as the input.
   The BMP format expands Y to RGB in the file format and does not
   output alpha.

   PNG supports writing rectangles of data even when the bytes storing rows of
   data are not consecutive in memory (e.g. sub-rectangles of a larger image),
   by supplying the stride between the beginning of adjacent rows. The other
   formats do not. (Thus you cannot write a native-format BMP through the BMP
   writer, both because it is in BGR order and because it may have padding
   at the end of the line.)

   PNG allows you to set the deflate compression level by setting the global
   variable 'stbi_write_png_compression_level' (it defaults to 8).

   HDR expects linear float data. Since the format is always 32-bit rgb(e)
   data, alpha (if provided) is discarded, and for monochrome data it is
   replicated across all three channels.

   TGA supports RLE or non-RLE compressed data. To use non-RLE-compressed
   data, set the global variable 'stbi_write_tga_with_rle' to 0.

   JPEG does ignore alpha channels in input data; quality is between 1 and 100.
   Higher quality looks better but results in a bigger image.
   JPEG baseline (no JPEG progressive).

CREDITS:


   Sean Barrett           -    PNG/BMP/TGA
   Baldur Karlsson        -    HDR
   Jean-Sebastien Guay    -    TGA monochrome
   Tim Kelsey             -    misc enhancements
   Alan Hickman           -    TGA RLE
   Emmanuel Julien        -    initial file IO callback implementation
   Jon Olick              -    original jo_jpeg.cpp code
   Daniel Gibson          -    integrate JPEG, allow external zlib
   Aarni Koskela          -    allow choosing PNG filter

   bugfixes:
      github:Chribba
      Guillaume Chereau
      github:jry2
      github:romigrou
      Sergio Gonzalez
      Jonas Karlsson
      Filip Wasil
      Thatcher Ulrich
      github:poppolopoppo
      Patrick Boettcher
      github:xeekworx
      Cap Petschulat
      Simon Rodriguez
      Ivan Tikhonov
      github:ignotion
      Adam Schackart
      Andrew Kensler

LICENSE

  See end of file for license information.

*/

#ifndef INCLUDE_STB_IMAGE_WRITE_H
#define INCLUDE_STB_IMAGE_WRITE_H

#include <stdlib.h>

// if STB_IMAGE_WRITE_STATIC causes problems, try defining STBIWDEF to 'inline' or 'static inline'
#ifndef STBIWDEF
#ifdef STB_IMAGE_WRITE_STATIC
#define STBIWDEF  static
#else
#ifdef __cplusplus
#define STBIWDEF  extern "C"
#else
#define STBIWDEF  extern
#endif
#endif
#endif

#ifndef STB_IMAGE_WRITE_STATIC  // C++ forbids static forward declarations
STBIWDEF int stbi_write_tga_with_rle;
STBIWDEF int stbi_write_png_compression_level;
STBIWDEF int stbi_write_force_png_filter;
#endif

#ifndef STBI_WRITE_NO_STDIO
STBIWDEF int stbi_write_png(char const *filename, int w, int h, int comp, const void  *data, int stride_in_bytes);
STBIWDEF int stbi_write_bmp(char const *filename, int w, int h, int comp, const void  *data);
STBIWDEF int stbi_write_tga(char const *filename, int w, int h, int comp, const void  *data);
STBIWDEF int stbi_write_hdr(char const *filename, int w, int h, int comp, const float *data);
STBIWDEF int stbi_write_jpg(char const *filename, int x, int y, int comp, const void  *data, int quality);

#ifdef STBIW_WINDOWS_UTF8
STBIWDEF int stbiw_convert_wchar_to_utf8(char *buffer, size_t bufferlen, const wchar_t* input);
#endif
#endif

typedef void stbi_write_func(void *context, void *data, int size);

STBIWDEF int stbi_write_png_to_func(stbi_write_func *func, void *context, int w, int h, int comp, const void  *data, int stride_in_bytes);
STBIWDEF int stbi_write_bmp_to_func(stbi_write_func *func, void *context, int w, int h, int comp, const void  *data);
STBIWDEF int stbi_write_tga_to_func(stbi_write_func *func, void *context, int w, int h, int comp, const void  *data);
STBIWDEF int stbi_write_hdr_to_func(stbi_write_func *func, void *context, int w, int h, int comp, const float *data);
STBIWDEF int stbi_write_jpg_to_func(stbi_write_func *func, void *context, int x, int y, int comp, const void  *data, int quality);

STBIWDEF void stbi_flip_vertically_on_write(int flip_boolean);

#endif//INCLUDE_STB_IMAGE_WRITE_H

#ifdef STB_IMAGE_WRITE_IMPLEMENTATION

#ifdef _WIN32
   #ifndef _CRT_SECURE_NO_WARNINGS
   #define _CRT_SECURE_NO_WARNINGS
   #endif
   #ifndef _CRT_NONSTDC_NO_DEPRECATE
   #define _CRT_NONSTDC_NO_DEPRECATE
   #endif
#endif

#ifndef STBI_WRITE_NO_STDIO
#include <stdio.h>
#endif // STBI_WRITE_NO_STDIO

#include <stdarg.h>
#include <stdlib.h>
#include <string.h>
#include <math.h>

#if defined(STBIW_MALLOC) && defined(STBIW_FREE) && (defined(STBIW_REALLOC) || defined(STBIW_REALLOC_SIZED))
// ok
#elif !defined(STBIW_MALLOC) && !defined(STBIW_FREE) && !defined(STBIW_REALLOC) && !defined(STBIW_REALLOC_SIZED)
// ok
#else
#error "Must define all or none of STBIW_MALLOC, STBIW_FREE, and STBIW_REALLOC (or STBIW_REALLOC_SIZED)."
#endif

#ifndef STBIW_MALLOC
#define STBIW_MALLOC(sz)        malloc(sz)
#define STBIW_REALLOC(p,newsz)  realloc(p,newsz)
#define STBIW_FREE(p)           free(p)
#endif

#ifndef STBIW_REALLOC_SIZED
#define STBIW_REALLOC_SIZED(p,oldsz,newsz) STBIW_REALLOC(p,newsz)
#endif


#ifndef STBIW_MEMMOVE
#define STBIW_MEMMOVE(a,b,sz) memmove(a,b,sz)
#endif


#ifndef STBIW_ASSERT
#include <assert.h>
#define STBIW_ASSERT(x) assert(x)
#endif

#define STBIW_UCHAR(x) (unsigned char) ((x) & 0xff)

#ifdef STB_IMAGE_WRITE_STATIC
static int stbi_write_png_compression_level = 8;
static int stbi_write_tga_with_rle = 1;
static int stbi_write_force_png_filter = -1;
#else
int stbi_write_png_compression_level = 8;
int stbi_write_tga_with_rle = 1;
int stbi_write_force_png_filter = -1;
#endif

static int stbi__flip_vertically_on_write = 0;

STBIWDEF void stbi_flip_vertically_on_write(int flag)
{
   stbi__flip_vertically_on_write = flag;
}

typedef struct
{
   stbi_write_func *func;
   void *context;
   unsigned char buffer[64];
   int buf_used;
} stbi__write_context;

// initialize a callback-based context
static void stbi__start_write_callbacks(stbi__write_context *s, stbi_write_func *c, void *context)
{
   s->func    = c;
   s->context = context;
}

#ifndef STBI_WRITE_NO_STDIO

static void stbi__stdio_write(void *context, void *data, int size)
{
   fwrite(data,1,size,(FILE*) context);
}

#if defined(_WIN32) && defined(STBIW_WINDOWS_UTF8)
#ifdef __cplusplus
#define STBIW_EXTERN extern "C"
#else
#define STBIW_EXTERN extern
#endif
STBIW_EXTERN __declspec(dllimport) int __stdcall MultiByteToWideChar(unsigned int cp, unsigned long flags, const char *str, int cbmb, wchar_t *widestr, int cchwide);
STBIW_EXTERN __declspec(dllimport) int __stdcall WideCharToMultiByte(unsigned int cp, unsigned long flags, const wchar_t *widestr, int cchwide, char *str, int cbmb, const char *defchar, int *used_default);

STBIWDEF int stbiw_convert_wchar_to_utf8(char *buffer, size_t bufferlen, const wchar_t* input)
{
   return WideCharToMultiByte(65001 /* UTF8 */, 0, input, -1, buffer, (int) bufferlen, NULL, NULL);
}
#endif

static FILE *stbiw__fopen(char const *filename, char const *mode)
{
   FILE *f;
#if defined(_WIN32) && defined(STBIW_WINDOWS_UTF8)
   wchar_t wMode[64];
   wchar_t wFilename[1024];
   if (0 == MultiByteToWideChar(65001 /* UTF8 */, 0, filename, -1, wFilename, sizeof(wFilename)/sizeof(*wFilename)))
      return 0;

   if (0 == MultiByteToWideChar(65001 /* UTF8 */, 0, mode, -1, wMode, sizeof(wMode)/sizeof(*wMode)))
      return 0;

#if defined(_MSC_VER) && _MSC_VER >= 1400
   if (0 != _wfopen_s(&f, wFilename, wMode))
      f = 0;
#else
   f = _wfopen(wFilename, wMode);
#endif

#elif defined(_MSC_VER) && _MSC_VER >= 1400
   if (0 != fopen_s(&f, filename, mode))
      f=0;
#else
   f = fopen(filename, mode);
#endif
   return f;
}

static int stbi__start_write_file(stbi__write_context *s, const char *filename)
{
   FILE *f = stbiw__fopen(filename, "wb");
   stbi__start_write_callbacks(s, stbi__stdio_write, (void *) f);
   return f != NULL;
}

static void stbi__end_write_file(stbi__write_context *s)
{
   fclose((FILE *)s->context);
}

#endif // !STBI_WRITE_NO_STDIO

typedef unsigned int stbiw_uint32;
typedef int stb_image_write_test[sizeof(stbiw_uint32)==4 ? 1 : -1];

static void stbiw__writefv(stbi__write_context *s, const char *fmt, va_list v)
{
   while (*fmt) {
      switch (*fmt++) {
         case ' ': break;
         case '1': { unsigned char x = STBIW_UCHAR(va_arg(v, int));
                     s->func(s->context,&x,1);
                     break; }
         case '2': { int x = va_arg(v,int);
                     unsigned char b[2];
                     b[0] = STBIW_UCHAR(x);
                     b[1] = STBIW_UCHAR(x>>8);
                     s->func(s->context,b,2);
                     break; }
         case '4': { stbiw_uint32 x = va_arg(v,int);
                     unsigned char b[4];
                     b[0]=STBIW_UCHAR(x);
                     b[1]=STBIW_UCHAR(x>>8);
                     b[2]=STBIW_UCHAR(x>>16);
                     b[3]=STBIW_UCHAR(x>>24);
                     s->func(s->context,b,4);
                     break; }
         default:
            STBIW_ASSERT(0);
            return;
      }
   }
}

static void stbiw__writef(stbi__write_context *s, const char *fmt, ...)
{
   va_list v;
   va_start(v, fmt);
   stbiw__writefv(s, fmt, v);
   va_end(v);
}

static void stbiw__write_flush(stbi__write_context *s)
{
   if (s->buf_used) {
      s->func(s->context, &s->buffer, s->buf_used);
      s->buf_used = 0;
   }
}

static void stbiw__putc(stbi__write_context *s, unsigned char c)
{
   s->func(s->context, &c, 1);
}

static void stbiw__write1(stbi__write_context *s, unsigned char a)
{
   if ((size_t)s->buf_used + 1 > sizeof(s->buffer))
      stbiw__write_flush(s);
   s->buffer[s->buf_used++] = a;
}

static void stbiw__write3(stbi__write_context *s, unsigned char a, unsigned char b, unsigned char c)
{
   int n;
   if ((size_t)s->buf_used + 3 > sizeof(s->buffer))
      stbiw__write_flush(s);
   n = s->buf_used;
   s->buf_used = n+3;
   s->buffer[n+0] = a;
   s->buffer[n+1] = b;
   s->buffer[n+2] = c;
}

static void stbiw__write_pixel(stbi__write_context *s, int rgb_dir, int comp, int write_alpha, int expand_mono, unsigned char *d)
{
   unsigned char bg[3] = { 255, 0, 255}, px[3];
   int k;

   if (write_alpha < 0)
      stbiw__write1(s, d[comp - 1]);

   switch (comp) {
      case 2: // 2 pixels = mono + alpha, alpha is written separately, so same as 1-channel case
      case 1:
         if (expand_mono)
            stbiw__write3(s, d[0], d[0], d[0]); // monochrome bmp
         else
            stbiw__write1(s, d[0]);  // monochrome TGA
         break;
      case 4:
         if (!write_alpha) {
            // composite against pink background
            for (k = 0; k < 3; ++k)
               px[k] = bg[k] + ((d[k] - bg[k]) * d[3]) / 255;
            stbiw__write3(s, px[1 - rgb_dir], px[1], px[1 + rgb_dir]);
            break;
         }
         /* FALLTHROUGH */
      case 3:
         stbiw__write3(s, d[1 - rgb_dir], d[1], d[1 + rgb_dir]);
         break;
   }
   if (write_alpha > 0)
      stbiw__write1(s, d[comp - 1]);
}

static void stbiw__write_pixels(stbi__write_context *s, int rgb_dir, int vdir, int x, int y, int comp, void *data, int write_alpha, int scanline_pad, int expand_mono)
{
   stbiw_uint32 zero = 0;
   int i,j, j_end;

   if (y <= 0)
      return;

   if (stbi__flip_vertically_on_write)
      vdir *= -1;

   if (vdir < 0) {
      j_end = -1; j = y-1;
   } else {
      j_end =  y; j = 0;
   }

   for (; j != j_end; j += vdir) {
      for (i=0; i < x; ++i) {
         unsigned char *d = (unsigned char *) data + (j*x+i)*comp;
         stbiw__write_pixel(s, rgb_dir, comp, write_alpha, expand_mono, d);
      }
      stbiw__write_flush(s);
      s->func(s->context, &zero, scanline_pad);
   }
}

static int stbiw__outfile(stbi__write_context *s, int rgb_dir, int vdir, int x, int y, int comp, int expand_mono, void *data, int alpha, int pad, const char *fmt, ...)
{
   if (y < 0 || x < 0) {
      return 0;
   } else {
      va_list v;
      va_start(v, fmt);
      stbiw__writefv(s, fmt, v);
      va_end(v);
      stbiw__write_pixels(s,rgb_dir,vdir,x,y,comp,data,alpha,pad, expand_mono);
      return 1;
   }
}

static int stbi_write_bmp_core(stbi__write_context *s, int x, int y, int comp, const void *data)
{
   if (comp != 4) {
      // write RGB bitmap
      int pad = (-x*3) & 3;
      return stbiw__outfile(s,-1,-1,x,y,comp,1,(void *) data,0,pad,
              "11 4 22 4" "4 44 22 444444",
              'B', 'M', 14+40+(x*3+pad)*y, 0,0, 14+40,  // file header
               40, x,y, 1,24, 0,0,0,0,0,0);             // bitmap header
   } else {
      // RGBA bitmaps need a v4 header
      // use BI_BITFIELDS mode with 32bpp and alpha mask
      // (straight BI_RGB with alpha mask doesn't work in most readers)
      return stbiw__outfile(s,-1,-1,x,y,comp,1,(void *)data,1,0,
         "11 4 22 4" "4 44 22 444444 4444 4 444 444 444 444",
         'B', 'M', 14+108+x*y*4, 0, 0, 14+108, // file header
         108, x,y, 1,32, 3,0,0,0,0,0, 0xff0000,0xff00,0xff,0xff000000u, 0, 0,0,0, 0,0,0, 0,0,0, 0,0,0); // bitmap V4 header
   }
}

STBIWDEF int stbi_write_bmp_to_func(stbi_write_func *func, void *context, int x, int y, int comp, const void *data)
{
   stbi__write_context s = { 0 };
   stbi__start_write_callbacks(&s, func, context);
   return stbi_write_bmp_core(&s, x, y, comp, data);
}

#ifndef STBI_WRITE_NO_STDIO
STBIWDEF int stbi_write_bmp(char const *filename, int x, int y, int comp, const void *data)
{
   stbi__write_context s = { 0 };
   if (stbi__start_write_file(&s,filename)) {
      int r = stbi_write_bmp_core(&s, x, y, comp, data);
      stbi__end_write_file(&s);
      return r;
   } else
      return 0;
}
#endif //!STBI_WRITE_NO_STDIO

static int stbi_write_tga_core(stbi__write_context *s, int x, int y, int comp, void *data)
{
   int has_alpha = (comp == 2 || comp == 4);
   int colorbytes = has_alpha ? comp-1 : comp;
   int format = colorbytes < 2 ? 3 : 2; // 3 color channels (RGB/RGBA) = 2, 1 color channel (Y/YA) = 3

   if (y < 0 || x < 0)
      return 0;

   if (!stbi_write_tga_with_rle) {
      return stbiw__outfile(s, -1, -1, x, y, comp, 0, (void *) data, has_alpha, 0,
         "111 221 2222 11", 0, 0, format, 0, 0, 0, 0, 0, x, y, (colorbytes + has_alpha) * 8, has_alpha * 8);
   } else {
      int i,j,k;
      int jend, jdir;

      stbiw__writef(s, "111 221 2222 11", 0,0,format+8, 0,0,0, 0,0,x,y, (colorbytes + has_alpha) * 8, has_alpha * 8);

      if (stbi__flip_vertically_on_write) {
         j = 0;
         jend = y;
         jdir = 1;
      } else {
         j = y-1;
         jend = -1;
         jdir = -1;
      }
      for (; j != jend; j += jdir) {
         unsigned char *row = (unsigned char *) data + j * x * comp;
         int len;

         for (i = 0; i < x; i += len) {
            unsigned char *begin = row + i * comp;
            int diff = 1;
            len = 1;

            if (i < x - 1) {
               ++len;
               diff = memcmp(begin, row + (i + 1) * comp, comp);
               if (diff) {
                  const unsigned char *prev = begin;
                  for (k = i + 2; k < x && len < 128; ++k) {
                     if (memcmp(prev, row + k * comp, comp)) {
                        prev += comp;
                        ++len;
                     } else {
                        --len;
                        break;
                     }
                  }
               } else {
                  for (k = i + 2; k < x && len < 128; ++k) {
                     if (!memcmp(begin, row + k * comp, comp)) {
                        ++len;
                     } else {
                        break;
                     }
                  }
               }
            }

            if (diff) {
               unsigned char header = STBIW_UCHAR(len - 1);
               stbiw__write1(s, header);
               for (k = 0; k < len; ++k) {
                  stbiw__write_pixel(s, -1, comp, has_alpha, 0, begin + k * comp);
               }
            } else {
               unsigned char header = STBIW_UCHAR(len - 129);
               stbiw__write1(s, header);
               stbiw__write_pixel(s, -1, comp, has_alpha, 0, begin);
            }
         }
      }
      stbiw__write_flush(s);
   }
   return 1;
}

STBIWDEF int stbi_write_tga_to_func(stbi_write_func *func, void *context, int x, int y, int comp, const void *data)
{
   stbi__write_context s = { 0 };
   stbi__start_write_callbacks(&s, func, context);
   return stbi_write_tga_core(&s, x, y, comp, (void *) data);
}

#ifndef STBI_WRITE_NO_STDIO
STBIWDEF int stbi_write_tga(char const *filename, int x, int y, int comp, const void *data)
{
   stbi__write_context s = { 0 };
   if (stbi__start_write_file(&s,filename)) {
      int r = stbi_write_tga_core(&s, x, y, comp, (void *) data);
      stbi__end_write_file(&s);
      return r;
   } else
      return 0;
}
#endif

// *************************************************************************************************
// Radiance RGBE HDR writer
// by Baldur Karlsson

#define stbiw__max(a, b)  ((a) > (b) ? (a) : (b))

#ifndef STBI_WRITE_NO_STDIO

static void stbiw__linear_to_rgbe(unsigned char *rgbe, float *linear)
{
   int exponent;
   float maxcomp = stbiw__max(linear[0], stbiw__max(linear[1], linear[2]));

   if (maxcomp < 1e-32f) {
      rgbe[0] = rgbe[1] = rgbe[2] = rgbe[3] = 0;
   } else {
      float normalize = (float) frexp(maxcomp, &exponent) * 256.0f/maxcomp;

      rgbe[0] = (unsigned char)(linear[0] * normalize);
      rgbe[1] = (unsigned char)(linear[1] * normalize);
      rgbe[2] = (unsigned char)(linear[2] * normalize);
      rgbe[3] = (unsigned char)(exponent + 128);
   }
}

static void stbiw__write_run_data(stbi__write_context *s, int length, unsigned char databyte)
{
   unsigned char lengthbyte = STBIW_UCHAR(length+128);
   STBIW_ASSERT(length+128 <= 255);
   s->func(s->context, &lengthbyte, 1);
   s->func(s->context, &databyte, 1);
}

static void stbiw__write_dump_data(stbi__write_context *s, int length, unsigned char *data)
{
   unsigned char lengthbyte = STBIW_UCHAR(length);
   STBIW_ASSERT(length <= 128); // inconsistent with spec but consistent with official code
   s->func(s->context, &lengthbyte, 1);
   s->func(s->context, data, length);
}

static void stbiw__write_hdr_scanline(stbi__write_context *s, int width, int ncomp, unsigned char *scratch, float *scanline)
{
   unsigned char scanlineheader[4] = { 2, 2, 0, 0 };
   unsigned char rgbe[4];
   float linear[3];
   int x;

   scanlineheader[2] = (width&0xff00)>>8;
   scanlineheader[3] = (width&0x00ff);

   /* skip RLE for images too small or large */
   if (width < 8 || width >= 32768) {
      for (x=0; x < width; x++) {
         switch (ncomp) {
            case 4: /* fallthrough */
            case 3: linear[2] = scanline[x*ncomp + 2];
                    linear[1] = scanline[x*ncomp + 1];
                    linear[0] = scanline[x*ncomp + 0];
                    break;
            default:
                    linear[0] = linear[1] = linear[2] = scanline[x*ncomp + 0];
                    break;
         }
         stbiw__linear_to_rgbe(rgbe, linear);
         s->func(s->context, rgbe, 4);
      }
   } else {
      int c,r;
      /* encode into scratch buffer */
      for (x=0; x < width; x++) {
         switch(ncomp) {
            case 4: /* fallthrough */
            case 3: linear[2] = scanline[x*ncomp + 2];
                    linear[1] = scanline[x*ncomp + 1];
                    linear[0] = scanline[x*ncomp + 0];
                    break;
            default:
                    linear[0] = linear[1] = linear[2] = scanline[x*ncomp + 0];
                    break;
         }
         stbiw__linear_to_rgbe(rgbe, linear);
         scratch[x + width*0] = rgbe[0];
         scratch[x + width*1] = rgbe[1];
         scratch[x + width*2] = rgbe[2];
         scratch[x + width*3] = rgbe[3];
      }

      s->func(s->context, scanlineheader, 4);

      /* RLE each component separately */
      for (c=0; c < 4; c++) {
         unsigned char *comp = &scratch[width*c];

         x = 0;
         while (x < width) {
            // find first run
            r = x;
            while (r+2 < width) {
               if (comp[r] == comp[r+1] && comp[r] == comp[r+2])
                  break;
               ++r;
            }
            if (r+2 >= width)
               r = width;
            // dump up to first run
            while (x < r) {
               int len = r-x;
               if (len > 128) len = 128;
               stbiw__write_dump_data(s, len, &comp[x]);
               x += len;
            }
            // if there's a run, output it
            if (r+2 < width) { // same test as what we break out of in search loop, so only true if we break'd
               // find next byte after run
               while (r < width && comp[r] == comp[x])
                  ++r;
               // output run up to r
               while (x < r) {
                  int len = r-x;
                  if (len > 127) len = 127;
                  stbiw__write_run_data(s, len, comp[x]);
                  x += len;
               }
            }
         }
      }
   }
}

static int stbi_write_hdr_core(stbi__write_context *s, int x, int y, int comp, float *data)
{
   if (y <= 0 || x <= 0 || data == NULL)
      return 0;
   else {
      // Each component is stored separately. Allocate scratch space for full output scanline.
      unsigned char *scratch = (unsigned char *) STBIW_MALLOC(x*4);
      int i, len;
      char buffer[128];
      char header[] = "#?RADIANCE\n# Written by stb_image_write.h\nFORMAT=32-bit_rle_rgbe\n";
      s->func(s->context, header, sizeof(header)-1);

#ifdef __STDC_LIB_EXT1__
      len = sprintf_s(buffer, sizeof(buffer), "EXPOSURE=          1.0000000000000\n\n-Y %d +X %d\n", y, x);
#else
      len = sprintf(buffer, "EXPOSURE=          1.0000000000000\n\n-Y %d +X %d\n", y, x);
#endif
      s->func(s->context, buffer, len);

      for(i=0; i < y; i++)
         stbiw__write_hdr_scanline(s, x, comp, scratch, data + comp*x*(stbi__flip_vertically_on_write ? y-1-i : i));
      STBIW_FREE(scratch);
      return 1;
   }
}

STBIWDEF int stbi_write_hdr_to_func(stbi_write_func *func, void *context, int x, int y, int comp, const float *data)
{
   stbi__write_context s = { 0 };
   stbi__start_write_callbacks(&s, func, context);
   return stbi_write_hdr_core(&s, x, y, comp, (float *) data);
}

STBIWDEF int stbi_write_hdr(char const *filename, int x, int y, int comp, const float *data)
{
   stbi__write_context s = { 0 };
   if (stbi__start_write_file(&s,filename)) {
      int r = stbi_write_hdr_core(&s, x, y, comp, (float *) data);
      stbi__end_write_file(&s);
      return r;
   } else
      return 0;
}
#endif // STBI_WRITE_NO_STDIO


//////////////////////////////////////////////////////////////////////////////
//
// PNG writer
//

#ifndef STBIW_ZLIB_COMPRESS
// stretchy buffer; stbiw__sbpush() == vector<>::push_back() -- stbiw__sbcount() == vector<>::size()
#define stbiw__sbraw(a) ((int *) (void *) (a) - 2)
#define stbiw__sbm(a)   stbiw__sbraw(a)[0]
#define stbiw__sbn(a)   stbiw__sbraw(a)[1]

#define stbiw__sbneedgrow(a,n)  ((a)==0 || stbiw__sbn(a)+n >= stbiw__sbm(a))
#define stbiw__sbmaybegrow(a,n) (stbiw__sbneedgrow(a,(n)) ? stbiw__sbgrow(a,n) : 0)
#define stbiw__sbgrow(a,n)  stbiw__sbgrowf((void **) &(a), (n), sizeof(*(a)))

#define stbiw__sbpush(a, v)      (stbiw__sbmaybegrow(a,1), (a)[stbiw__sbn(a)++] = (v))
#define stbiw__sbcount(a)        ((a) ? stbiw__sbn(a) : 0)
#define stbiw__sbfree(a)         ((a) ? STBIW_FREE(stbiw__sbraw(a)),0 : 0)

static void *stbiw__sbgrowf(void **arr, int increment, int itemsize)
{
   int m = *arr ? 2*stbiw__sbm(*arr)+increment : increment+1;
   void *p = STBIW_REALLOC_SIZED(*arr ? stbiw__sbraw(*arr) : 0, *arr ? (stbiw__sbm(*arr)*itemsize + sizeof(int)*2) : 0, itemsize * m + sizeof(int)*2);
   STBIW_ASSERT(p);
   if (p) {
      if (!*arr) ((int *) p)[1] = 0;
      *arr = (void *) ((int *) p + 2);
      stbiw__sbm(*arr) = m;
   }
   return *arr;
}

static unsigned char *stbiw__zlib_flushf(unsigned char *data, unsigned int *bitbuffer, int *bitcount)
{
   while (*bitcount >= 8) {
      stbiw__sbpush(data, STBIW_UCHAR(*bitbuffer));
      *bitbuffer >>= 8;
      *bitcount -= 8;
   }
   return data;
}

static int stbiw__zlib_bitrev(int code, int codebits)
{
   int res=0;
   while (codebits--) {
      res = (res << 1) | (code & 1);
      code >>= 1;
   }
   return res;
}

static unsigned int stbiw__zlib_countm(unsigned char *a, unsigned char *b, int limit)
{
   int i;
   for (i=0; i < limit && i < 258; ++i)
      if (a[i] != b[i]) break;
   return i;
}

static unsigned int stbiw__zhash(unsigned char *data)
{
   stbiw_uint32 hash = data[0] + (data[1] << 8) + (data[2] << 16);
   hash ^= hash << 3;
   hash += hash >> 5;
   hash ^= hash << 4;
   hash += hash >> 17;
   hash ^= hash << 25;
   hash += hash >> 6;
   return hash;
}

#define stbiw__zlib_flush() (out = stbiw__zlib_flushf(out, &bitbuf, &bitcount))
#define stbiw__zlib_add(code,codebits) \
      (bitbuf |= (code) << bitcount, bitcount += (codebits), stbiw__zlib_flush())
#define stbiw__zlib_huffa(b,c)  stbiw__zlib_add(stbiw__zlib_bitrev(b,c),c)
// default huffman tables
#define stbiw__zlib_huff1(n)  stbiw__zlib_huffa(0x30 + (n), 8)
#define stbiw__zlib_huff2(n)  stbiw__zlib_huffa(0x190 + (n)-144, 9)
#define stbiw__zlib_huff3(n)  stbiw__zlib_huffa(0 + (n)-256,7)
#define stbiw__zlib_huff4(n)  stbiw__zlib_huffa(0xc0 + (n)-280,8)
#define stbiw__zlib_huff(n)  ((n) <= 143 ? stbiw__zlib_huff1(n) : (n) <= 255 ? stbiw__zlib_huff2(n) : (n) <= 279 ? stbiw__zlib_huff3(n) : stbiw__zlib_huff4(n))
#define stbiw__zlib_huffb(n) ((n) <= 143 ? stbiw__zlib_huff1(n) : stbiw__zlib_huff2(n))

#define stbiw__ZHASH   16384

#endif // STBIW_ZLIB_COMPRESS

STBIWDEF unsigned char * stbi_zlib_compress(unsigned char *data, int data_len, int *out_len, int quality)
{
#ifdef STBIW_ZLIB_COMPRESS
   // user provided a zlib compress implementation, use that
   return STBIW_ZLIB_COMPRESS(data, data_len, out_len, quality);
#else // use builtin
   static unsigned short lengthc[] = { 3,4,5,6,7,8,9,10,11,13,15,17,19,23,27,31,35,43,51,59,67,83,99,115,131,163,195,227,258, 259 };
   static unsigned char  lengtheb[]= { 0,0,0,0,0,0,0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4,  4,  5,  5,  5,  5,  0 };
   static unsigned short distc[]   = { 1,2,3,4,5,7,9,13,17,25,33,49,65,97,129,193,257,385,513,769,1025,1537,2049,3073,4097,6145,8193,12289,16385,24577, 32768 };
   static unsigned char  disteb[]  = { 0,0,0,0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,13,13 };
   unsigned int bitbuf=0;
   int i,j, bitcount=0;
   unsigned char *out = NULL;
   unsigned char ***hash_table = (unsigned char***) STBIW_MALLOC(stbiw__ZHASH * sizeof(unsigned char**));
   if (hash_table == NULL)
      return NULL;
   if (quality < 5) quality = 5;

   stbiw__sbpush(out, 0x78);   // DEFLATE 32K window
   stbiw__sbpush(out, 0x5e);   // FLEVEL = 1
   stbiw__zlib_add(1,1);  // BFINAL = 1
   stbiw__zlib_add(1,2);  // BTYPE = 1 -- fixed huffman

   for (i=0; i < stbiw__ZHASH; ++i)
      hash_table[i] = NULL;

   i=0;
   while (i < data_len-3) {
      // hash next 3 bytes of data to be compressed
      int h = stbiw__zhash(data+i)&(stbiw__ZHASH-1), best=3;
      unsigned char *bestloc = 0;
      unsigned char **hlist = hash_table[h];
      int n = stbiw__sbcount(hlist);
      for (j=0; j < n; ++j) {
         if (hlist[j]-data > i-32768) { // if entry lies within window
            int d = stbiw__zlib_countm(hlist[j], data+i, data_len-i);
            if (d >= best) { best=d; bestloc=hlist[j]; }
         }
      }
      // when hash table entry is too long, delete half the entries
      if (hash_table[h] && stbiw__sbn(hash_table[h]) == 2*quality) {
         STBIW_MEMMOVE(hash_table[h], hash_table[h]+quality, sizeof(hash_table[h][0])*quality);
         stbiw__sbn(hash_table[h]) = quality;
      }
      stbiw__sbpush(hash_table[h],data+i);

      if (bestloc) {
         // "lazy matching" - check match at *next* byte, and if it's better, do cur byte as literal
         h = stbiw__zhash(data+i+1)&(stbiw__ZHASH-1);
         hlist = hash_table[h];
         n = stbiw__sbcount(hlist);
         for (j=0; j < n; ++j) {
            if (hlist[j]-data > i-32767) {
               int e = stbiw__zlib_countm(hlist[j], data+i+1, data_len-i-1);
               if (e > best) { // if next match is better, bail on current match
                  bestloc = NULL;
                  break;
               }
            }
         }
      }

      if (bestloc) {
         int d = (int) (data+i - bestloc); // distance back
         STBIW_ASSERT(d <= 32767 && best <= 258);
         for (j=0; best > lengthc[j+1]-1; ++j);
         stbiw__zlib_huff(j+257);
         if (lengtheb[j]) stbiw__zlib_add(best - lengthc[j], lengtheb[j]);
         for (j=0; d > distc[j+1]-1; ++j);
         stbiw__zlib_add(stbiw__zlib_bitrev(j,5),5);
         if (disteb[j]) stbiw__zlib_add(d - distc[j], disteb[j]);
         i += best;
      } else {
         stbiw__zlib_huffb(data[i]);
         ++i;
      }
   }
   // write out final bytes
   for (;i < data_len; ++i)
      stbiw__zlib_huffb(data[i]);
   stbiw__zlib_huff(256); // end of block
   // pad with 0 bits to byte boundary
   while (bitcount)
      stbiw__zlib_add(0,1);

   for (i=0; i < stbiw__ZHASH; ++i)
      (void) stbiw__sbfree(hash_table[i]);
   STBIW_FREE(hash_table);

   // store uncompressed instead if compression was worse
   if (stbiw__sbn(out) > data_len + 2 + ((data_len+32766)/32767)*5) {
      stbiw__sbn(out) = 2;  // truncate to DEFLATE 32K window and FLEVEL = 1
      for (j = 0; j < data_len;) {
         int blocklen = data_len - j;
         if (blocklen > 32767) blocklen = 32767;
         stbiw__sbpush(out, data_len - j == blocklen); // BFINAL = ?, BTYPE = 0 -- no compression
         stbiw__sbpush(out, STBIW_UCHAR(blocklen)); // LEN
         stbiw__sbpush(out, STBIW_UCHAR(blocklen >> 8));
         stbiw__sbpush(out, STBIW_UCHAR(~blocklen)); // NLEN
         stbiw__sbpush(out, STBIW_UCHAR(~blocklen >> 8));
         memcpy(out+stbiw__sbn(out), data+j, blocklen);
         stbiw__sbn(out) += blocklen;
         j += blocklen;
      }
   }

   {
      // compute adler32 on input
      unsigned int s1=1, s2=0;
      int blocklen = (int) (data_len % 5552);
      j=0;
      while (j < data_len) {
         for (i=0; i < blocklen; ++i) { s1 += data[j+i]; s2 += s1; }
         s1 %= 65521; s2 %= 65521;
         j += blocklen;
         blocklen = 5552;
      }
      stbiw__sbpush(out, STBIW_UCHAR(s2 >> 8));
      stbiw__sbpush(out, STBIW_UCHAR(s2));
      stbiw__sbpush(out, STBIW_UCHAR(s1 >> 8));
      stbiw__sbpush(out, STBIW_UCHAR(s1));
   }
   *out_len = stbiw__sbn(out);
   // make returned pointer freeable
   STBIW_MEMMOVE(stbiw__sbraw(out), out, *out_len);
   return (unsigned char *) stbiw__sbraw(out);
#endif // STBIW_ZLIB_COMPRESS
}

static unsigned int stbiw__crc32(unsigned char *buffer, int len)
{
#ifdef STBIW_CRC32
    return STBIW_CRC32(buffer, len);
#else
   static unsigned int crc_table[256] =
   {
      0x00000000, 0x77073096, 0xEE0E612C, 0x990951BA, 0x076DC419, 0x706AF48F, 0xE963A535, 0x9E6495A3,
      0x0eDB8832, 0x79DCB8A4, 0xE0D5E91E, 0x97D2D988, 0x09B64C2B, 0x7EB17CBD, 0xE7B82D07, 0x90BF1D91,
      0x1DB71064, 0x6AB020F2, 0xF3B97148, 0x84BE41DE, 0x1ADAD47D, 0x6DDDE4EB, 0xF4D4B551, 0x83D385C7,
      0x136C9856, 0x646BA8C0, 0xFD62F97A, 0x8A65C9EC, 0x14015C4F, 0x63066CD9, 0xFA0F3D63, 0x8D080DF5,
      0x3B6E20C8, 0x4C69105E, 0xD56041E4, 0xA2677172, 0x3C03E4D1, 0x4B04D447, 0xD20D85FD, 0xA50AB56B,
      0x35B5A8FA, 0x42B2986C, 0xDBBBC9D6, 0xACBCF940, 0x32D86CE3, 0x45DF5C75, 0xDCD60DCF, 0xABD13D59,
      0x26D930AC, 0x51DE003A, 0xC8D75180, 0xBFD06116, 0x21B4F4B5, 0x56B3C423, 0xCFBA9599, 0xB8BDA50F,
      0x2802B89E, 0x5F058808, 0xC60CD9B2, 0xB10BE924, 0x2F6F7C87, 0x58684C11, 0xC1611DAB, 0xB6662D3D,
      0x76DC4190, 0x01DB7106, 0x98D220BC, 0xEFD5102A, 0x71B18589, 0x06B6B51F, 0x9FBFE4A5, 0xE8B8D433,
      0x7807C9A2, 0x0F00F934, 0x9609A88E, 0xE10E9818, 0x7F6A0DBB, 0x086D3D2D, 0x91646C97, 0xE6635C01,
      0x6B6B51F4, 0x1C6C6162, 0x856530D8, 0xF262004E, 0x6C0695ED, 0x1B01A57B, 0x8208F4C1, 0xF50FC457,
      0x65B0D9C6, 0x12B7E950, 0x8BBEB8EA, 0xFCB9887C, 0x62DD1DDF, 0x15DA2D49, 0x8CD37CF3, 0xFBD44C65,
      0x4DB26158, 0x3AB551CE, 0xA3BC0074, 0xD4BB30E2, 0x4ADFA541, 0x3DD895D7, 0xA4D1C46D, 0xD3D6F4FB,
      0x4369E96A, 0x346ED9FC, 0xAD678846, 0xDA60B8D0, 0x44042D73, 0x33031DE5, 0xAA0A4C5F, 0xDD0D7CC9,
      0x5005713C, 0x270241AA, 0xBE0B1010, 0xC90C2086, 0x5768B525, 0x206F85B3, 0xB966D409, 0xCE61E49F,
      0x5EDEF90E, 0x29D9C998, 0xB0D09822, 0xC7D7A8B4, 0x59B33D17, 0x2EB40D81, 0xB7BD5C3B, 0xC0BA6CAD,
      0xEDB88320, 0x9ABFB3B6, 0x03B6E20C, 0x74B1D29A, 0xEAD54739, 0x9DD277AF, 0x04DB2615, 0x73DC1683,
      0xE3630B12, 0x94643B84, 0x0D6D6A3E, 0x7A6A5AA8, 0xE40ECF0B, 0x9309FF9D, 0x0A00AE27, 0x7D079EB1,
      0xF00F9344, 0x8708A3D2, 0x1E01F268, 0x6906C2FE, 0xF762575D, 0x806567CB, 0x196C3671, 0x6E6B06E7,
      0xFED41B76, 0x89D32BE0, 0x10DA7A5A, 0x67DD4ACC, 0xF9B9DF6F, 0x8EBEEFF9, 0x17B7BE43, 0x60B08ED5,
      0xD6D6A3E8, 0xA1D1937E, 0x38D8C2C4, 0x4FDFF252, 0xD1BB67F1, 0xA6BC5767, 0x3FB506DD, 0x48B2364B,
      0xD80D2BDA, 0xAF0A1B4C, 0x36034AF6, 0x41047A60, 0xDF60EFC3, 0xA867DF55, 0x316E8EEF, 0x4669BE79,
      0xCB61B38C, 0xBC66831A, 0x256FD2A0, 0x5268E236, 0xCC0C7795, 0xBB0B4703, 0x220216B9, 0x5505262F,
      0xC5BA3BBE, 0xB2BD0B28, 0x2BB45A92, 0x5CB36A04, 0xC2D7FFA7, 0xB5D0CF31, 0x2CD99E8B, 0x5BDEAE1D,
      0x9B64C2B0, 0xEC63F226, 0x756AA39C, 0x026D930A, 0x9C0906A9, 0xEB0E363F, 0x72076785, 0x05005713,
      0x95BF4A82, 0xE2B87A14, 0x7BB12BAE, 0x0CB61B38, 0x92D28E9B, 0xE5D5BE0D, 0x7CDCEFB7, 0x0BDBDF21,
      0x86D3D2D4, 0xF1D4E242, 0x68DDB3F8, 0x1FDA836E, 0x81BE16CD, 0xF6B9265B, 0x6FB077E1, 0x18B74777,
      0x88085AE6, 0xFF0F6A70, 0x66063BCA, 0x11010B5C, 0x8F659EFF, 0xF862AE69, 0x616BFFD3, 0x166CCF45,
      0xA00AE278, 0xD70DD2EE, 0x4E048354, 0x3903B3C2, 0xA7672661, 0xD06016F7, 0x4969474D, 0x3E6E77DB,
      0xAED16A4A, 0xD9D65ADC, 0x40DF0B66, 0x37D83BF0, 0xA9BCAE53, 0xDEBB9EC5, 0x47B2CF7F, 0x30B5FFE9,
      0xBDBDF21C, 0xCABAC28A, 0x53B39330, 0x24B4A3A6, 0xBAD03605, 0xCDD70693, 0x54DE5729, 0x23D967BF,
      0xB3667A2E, 0xC4614AB8, 0x5D681B02, 0x2A6F2B94, 0xB40BBE37, 0xC30C8EA1, 0x5A05DF1B, 0x2D02EF8D
   };

   unsigned int crc = ~0u;
   int i;
   for (i=0; i < len; ++i)
      crc = (crc >> 8) ^ crc_table[buffer[i] ^ (crc & 0xff)];
   return ~crc;
#endif
}

#define stbiw__wpng4(o,a,b,c,d) ((o)[0]=STBIW_UCHAR(a),(o)[1]=STBIW_UCHAR(b),(o)[2]=STBIW_UCHAR(c),(o)[3]=STBIW_UCHAR(d),(o)+=4)
#define stbiw__wp32(data,v) stbiw__wpng4(data, (v)>>24,(v)>>16,(v)>>8,(v));
#define stbiw__wptag(data,s) stbiw__wpng4(data, s[0],s[1],s[2],s[3])

static void stbiw__wpcrc(unsigned char **data, int len)
{
   unsigned int crc = stbiw__crc32(*data - len - 4, len+4);
   stbiw__wp32(*data, crc);
}

static unsigned char stbiw__paeth(int a, int b, int c)
{
   int p = a + b - c, pa = abs(p-a), pb = abs(p-b), pc = abs(p-c);
   if (pa <= pb && pa <= pc) return STBIW_UCHAR(a);
   if (pb <= pc) return STBIW_UCHAR(b);
   return STBIW_UCHAR(c);
}

// @OPTIMIZE: provide an option that always forces left-predict or paeth predict
static void stbiw__encode_png_line(unsigned char *pixels, int stride_bytes, int width, int height, int y, int n, int filter_type, signed char *line_buffer)
{
   static int mapping[] = { 0,1,2,3,4 };
   static int firstmap[] = { 0,1,0,5,6 };
   int *mymap = (y != 0) ? mapping : firstmap;
   int i;
   int type = mymap[filter_type];
   unsigned char *z = pixels + stride_bytes * (stbi__flip_vertically_on_write ? height-1-y : y);
   int signed_stride = stbi__flip_vertically_on_write ? -stride_bytes : stride_bytes;

   if (type==0) {
      memcpy(line_buffer, z, width*n);
      return;
   }

   // first loop isn't optimized since it's just one pixel
   for (i = 0; i < n; ++i) {
      switch (type) {
         case 1: line_buffer[i] = z[i]; break;
         case 2: line_buffer[i] = z[i] - z[i-signed_stride]; break;
         case 3: line_buffer[i] = z[i] - (z[i-signed_stride]>>1); break;
         case 4: line_buffer[i] = (signed char) (z[i] - stbiw__paeth(0,z[i-signed_stride],0)); break;
         case 5: line_buffer[i] = z[i]; break;
         case 6: line_buffer[i] = z[i]; break;
      }
   }
   switch (type) {
      case 1: for (i=n; i < width*n; ++i) line_buffer[i] = z[i] - z[i-n]; break;
      case 2: for (i=n; i < width*n; ++i) line_buffer[i] = z[i] - z[i-signed_stride]; break;
      case 3: for (i=n; i < width*n; ++i) line_buffer[i] = z[i] - ((z[i-n] + z[i-signed_stride])>>1); break;
      case 4: for (i=n; i < width*n; ++i) line_buffer[i] = z[i] - stbiw__paeth(z[i-n], z[i-signed_stride], z[i-signed_stride-n]); break;
      case 5: for (i=n; i < width*n; ++i) line_buffer[i] = z[i] - (z[i-n]>>1); break;
      case 6: for (i=n; i < width*n; ++i) line_buffer[i] = z[i] - stbiw__paeth(z[i-n], 0,0); break;
   }
}

STBIWDEF unsigned char *stbi_write_png_to_mem(const unsigned char *pixels, int stride_bytes, int x, int y, int n, int *out_len)
{
   int force_filter = stbi_write_force_png_filter;
   int ctype[5] = { -1, 0, 4, 2, 6 };
   unsigned char sig[8] = { 137,80,78,71,13,10,26,10 };
   unsigned char *out,*o, *filt, *zlib;
   signed char *line_buffer;
   int j,zlen;

   if (stride_bytes == 0)
      stride_bytes = x * n;

   if (force_filter >= 5) {
      force_filter = -1;
   }

   filt = (unsigned char *) STBIW_MALLOC((x*n+1) * y); if (!filt) return 0;
   line_buffer = (signed char *) STBIW_MALLOC(x * n); if (!line_buffer) { STBIW_FREE(filt); return 0; }
   for (j=0; j < y; ++j) {
      int filter_type;
      if (force_filter > -1) {
         filter_type = force_filter;
         stbiw__encode_png_line((unsigned char*)(pixels), stride_bytes, x, y, j, n, force_filter, line_buffer);
      } else { // Estimate the best filter by running through all of them:
         int best_filter = 0, best_filter_val = 0x7fffffff, est, i;
         for (filter_type = 0; filter_type < 5; filter_type++) {
            stbiw__encode_png_line((unsigned char*)(pixels), stride_bytes, x, y, j, n, filter_type, line_buffer);

            // Estimate the entropy of the line using this filter; the less, the better.
            est = 0;
            for (i = 0; i < x*n; ++i) {
               est += abs((signed char) line_buffer[i]);
            }
            if (est < best_filter_val) {
               best_filter_val = est;
               best_filter = filter_type;
            }
         }
         if (filter_type != best_filter) {  // If the last iteration already got us the best filter, don't redo it
            stbiw__encode_png_line((unsigned char*)(pixels), stride_bytes, x, y, j, n, best_filter, line_buffer);
            filter_type = best_filter;
         }
      }
      // when we get here, filter_type contains the filter type, and line_buffer contains the data
      filt[j*(x*n+1)] = (unsigned char) filter_type;
      STBIW_MEMMOVE(filt+j*(x*n+1)+1, line_buffer, x*n);
   }
   STBIW_FREE(line_buffer);
   zlib = stbi_zlib_compress(filt, y*( x*n+1), &zlen, stbi_write_png_compression_level);
   STBIW_FREE(filt);
   if (!zlib) return 0;

   // each tag requires 12 bytes of overhead
   out = (unsigned char *) STBIW_MALLOC(8 + 12+13 + 12+zlen + 12);
   if (!out) return 0;
   *out_len = 8 + 12+13 + 12+zlen + 12;

   o=out;
   STBIW_MEMMOVE(o,sig,8); o+= 8;
   stbiw__wp32(o, 13); // header length
   stbiw__wptag(o, "IHDR");
   stbiw__wp32(o, x);
   stbiw__wp32(o, y);
   *o++ = 8;
   *o++ = STBIW_UCHAR(ctype[n]);
   *o++ = 0;
   *o++ = 0;
   *o++ = 0;
   stbiw__wpcrc(&o,13);

   stbiw__wp32(o, zlen);
   stbiw__wptag(o, "IDAT");
   STBIW_MEMMOVE(o, zlib, zlen);
   o += zlen;
   STBIW_FREE(zlib);
   stbiw__wpcrc(&o, zlen);

   stbiw__wp32(o,0);
   stbiw__wptag(o, "IEND");
   stbiw__wpcrc(&o,0);

   STBIW_ASSERT(o == out + *out_len);

   return out;
}

#ifndef STBI_WRITE_NO_STDIO
STBIWDEF int stbi_write_png(char const *filename, int x, int y, int comp, const void *data, int stride_bytes)
{
   FILE *f;
   int len;
   unsigned char *png = stbi_write_png_to_mem((const unsigned char *) data, stride_bytes, x, y, comp, &len);
   if (png == NULL) return 0;

   f = stbiw__fopen(filename, "wb");
   if (!f) { STBIW_FREE(png); return 0; }
   fwrite(png, 1, len, f);
   fclose(f);
   STBIW_FREE(png);
   return 1;
}
#endif

STBIWDEF int stbi_write_png_to_func(stbi_write_func *func, void *context, int x, int y, int comp, const void *data, int stride_bytes)
{
   int len;
   unsigned char *png = stbi_write_png_to_mem((const unsigned char *) data, stride_bytes, x, y, comp, &len);
   if (png == NULL) return 0;
   func(context, png, len);
   STBIW_FREE(png);
   return 1;
}


/* ***************************************************************************
 *
 * JPEG writer
 *
 * This is based on Jon Olick's jo_jpeg.cpp:
 * public domain Simple, Minimalistic JPEG writer - http://www.jonolick.com/code.html
 */

static const unsigned char stbiw__jpg_ZigZag[] = { 0,1,5,6,14,15,27,28,2,4,7,13,16,26,29,42,3,8,12,17,25,30,41,43,9,11,18,
      24,31,40,44,53,10,19,23,32,39,45,52,54,20,22,33,38,46,51,55,60,21,34,37,47,50,56,59,61,35,36,48,49,57,58,62,63 };

static void stbiw__jpg_writeBits(stbi__write_context *s, int *bitBufP, int *bitCntP, const unsigned short *bs) {
   int bitBuf = *bitBufP, bitCnt = *bitCntP;
   bitCnt += bs[1];
   bitBuf |= bs[0] << (24 - bitCnt);
   while(bitCnt >= 8) {
      unsigned char c = (bitBuf >> 16) & 255;
      stbiw__putc(s, c);
      if(c == 255) {
         stbiw__putc(s, 0);
      }
      bitBuf <<= 8;
      bitCnt -= 8;
   }
   *bitBufP = bitBuf;
   *bitCntP = bitCnt;
}

static void stbiw__jpg_DCT(float *d0p, float *d1p, float *d2p, float *d3p, float *d4p, float *d5p, float *d6p, float *d7p) {
   float d0 = *d0p, d1 = *d1p, d2 = *d2p, d3 = *d3p, d4 = *d4p, d5 = *d5p, d6 = *d6p, d7 = *d7p;
   float z1, z2, z3, z4, z5, z11, z13;

   float tmp0 = d0 + d7;
   float tmp7 = d0 - d7;
   float tmp1 = d1 + d6;
   float tmp6 = d1 - d6;
   float tmp2 = d2 + d5;
   float tmp5 = d2 - d5;
   float tmp3 = d3 + d4;
   float tmp4 = d3 - d4;

   // Even part
   float tmp10 = tmp0 + tmp3;   // phase 2
   float tmp13 = tmp0 - tmp3;
   float tmp11 = tmp1 + tmp2;
   float tmp12 = tmp1 - tmp2;

   d0 = tmp10 + tmp11;       // phase 3
   d4 = tmp10 - tmp11;

   z1 = (tmp12 + tmp13) * 0.707106781f; // c4
   d2 = tmp13 + z1;       // phase 5
   d6 = tmp13 - z1;

   // Odd part
   tmp10 = tmp4 + tmp5;       // phase 2
   tmp11 = tmp5 + tmp6;
   tmp12 = tmp6 + tmp7;

   // The rotator is modified from fig 4-8 to avoid extra negations.
   z5 = (tmp10 - tmp12) * 0.382683433f; // c6
   z2 = tmp10 * 0.541196100f + z5; // c2-c6
   z4 = tmp12 * 1.306562965f + z5; // c2+c6
   z3 = tmp11 * 0.707106781f; // c4

   z11 = tmp7 + z3;      // phase 5
   z13 = tmp7 - z3;

   *d5p = z13 + z2;         // phase 6
   *d3p = z13 - z2;
   *d1p = z11 + z4;
   *d7p = z11 - z4;

   *d0p = d0;  *d2p = d2;  *d4p = d4;  *d6p = d6;
}

static void stbiw__jpg_calcBits(int val, unsigned short bits[2]) {
   int tmp1 = val < 0 ? -val : val;
   val = val < 0 ? val-1 : val;
   bits[1] = 1;
   while(tmp1 >>= 1) {
      ++bits[1];
   }
   bits[0] = val & ((1<<bits[1])-1);
}

static int stbiw__jpg_processDU(stbi__write_context *s, int *bitBuf, int *bitCnt, float *CDU, int du_stride, float *fdtbl, int DC, const unsigned short HTDC[256][2], const unsigned short HTAC[256][2]) {
   const unsigned short EOB[2] = { HTAC[0x00][0], HTAC[0x00][1] };
   const unsigned short M16zeroes[2] = { HTAC[0xF0][0], HTAC[0xF0][1] };
   int dataOff, i, j, n, diff, end0pos, x, y;
   int DU[64];

   // DCT rows
   for(dataOff=0, n=du_stride*8; dataOff<n; dataOff+=du_stride) {
      stbiw__jpg_DCT(&CDU[dataOff], &CDU[dataOff+1], &CDU[dataOff+2], &CDU[dataOff+3], &CDU[dataOff+4], &CDU[dataOff+5], &CDU[dataOff+6], &CDU[dataOff+7]);
   }
   // DCT columns
   for(dataOff=0; dataOff<8; ++dataOff) {
      stbiw__jpg_DCT(&CDU[dataOff], &CDU[dataOff+du_stride], &CDU[dataOff+du_stride*2], &CDU[dataOff+du_stride*3], &CDU[dataOff+du_stride*4],
                     &CDU[dataOff+du_stride*5], &CDU[dataOff+du_stride*6], &CDU[dataOff+du_stride*7]);
   }
   // Quantize/descale/zigzag the coefficients
   for(y = 0, j=0; y < 8; ++y) {
      for(x = 0; x < 8; ++x,++j) {
         float v;
         i = y*du_stride+x;
         v = CDU[i]*fdtbl[j];
         // DU[stbiw__jpg_ZigZag[j]] = (int)(v < 0 ? ceilf(v - 0.5f) : floorf(v + 0.5f));
         // ceilf() and floorf() are C99, not C89, but I /think/ they're not needed here anyway?
         DU[stbiw__jpg_ZigZag[j]] = (int)(v < 0 ? v - 0.5f : v + 0.5f);
      }
   }

   // Encode DC
   diff = DU[0] - DC;
   if (diff == 0) {
      stbiw__jpg_writeBits(s, bitBuf, bitCnt, HTDC[0]);
   } else {
      unsigned short bits[2];
      stbiw__jpg_calcBits(diff, bits);
      stbiw__jpg_writeBits(s, bitBuf, bitCnt, HTDC[bits[1]]);
      stbiw__jpg_writeBits(s, bitBuf, bitCnt, bits);
   }
   // Encode ACs
   end0pos = 63;
   for(; (end0pos>0)&&(DU[end0pos]==0); --end0pos) {
   }
   // end0pos = first element in reverse order !=0
   if(end0pos == 0) {
      stbiw__jpg_writeBits(s, bitBuf, bitCnt, EOB);
      return DU[0];
   }
   for(i = 1; i <= end0pos; ++i) {
      int startpos = i;
      int nrzeroes;
      unsigned short bits[2];
      for (; DU[i]==0 && i<=end0pos; ++i) {
      }
      nrzeroes = i-startpos;
      if ( nrzeroes >= 16 ) {
         int lng = nrzeroes>>4;
         int nrmarker;
         for (nrmarker=1; nrmarker <= lng; ++nrmarker)
            stbiw__jpg_writeBits(s, bitBuf, bitCnt, M16zeroes);
         nrzeroes &= 15;
      }
      stbiw__jpg_calcBits(DU[i], bits);
      stbiw__jpg_writeBits(s, bitBuf, bitCnt, HTAC[(nrzeroes<<4)+bits[1]]);
      stbiw__jpg_writeBits(s, bitBuf, bitCnt, bits);
   }
   if(end0pos != 63) {
      stbiw__jpg_writeBits(s, bitBuf, bitCnt, EOB);
   }
   return DU[0];
}

static int stbi_write_jpg_core(stbi__write_context *s, int width, int height, int comp, const void* data, int quality) {
   // Constants that don't pollute global namespace
   static const unsigned char std_dc_luminance_nrcodes[] = {0,0,1,5,1,1,1,1,1,1,0,0,0,0,0,0,0};
   static const unsigned char std_dc_luminance_values[] = {0,1,2,3,4,5,6,7,8,9,10,11};
   static const unsigned char std_ac_luminance_nrcodes[] = {0,0,2,1,3,3,2,4,3,5,5,4,4,0,0,1,0x7d};
   static const unsigned char std_ac_luminance_values[] = {
      0x01,0x02,0x03,0x00,0x04,0x11,0x05,0x12,0x21,0x31,0x41,0x06,0x13,0x51,0x61,0x07,0x22,0x71,0x14,0x32,0x81,0x91,0xa1,0x08,
      0x23,0x42,0xb1,0xc1,0x15,0x52,0xd1,0xf0,0x24,0x33,0x62,0x72,0x82,0x09,0x0a,0x16,0x17,0x18,0x19,0x1a,0x25,0x26,0x27,0x28,
      0x29,0x2a,0x34,0x35,0x36,0x37,0x38,0x39,0x3a,0x43,0x44,0x45,0x46,0x47,0x48,0x49,0x4a,0x53,0x54,0x55,0x56,0x57,0x58,0x59,
      0x5a,0x63,0x64,0x65,0x66,0x67,0x68,0x69,0x6a,0x73,0x74,0x75,0x76,0x77,0x78,0x79,0x7a,0x83,0x84,0x85,0x86,0x87,0x88,0x89,
      0x8a,0x92,0x93,0x94,0x95,0x96,0x97,0x98,0x99,0x9a,0xa2,0xa3,0xa4,0xa5,0xa6,0xa7,0xa8,0xa9,0xaa,0xb2,0xb3,0xb4,0xb5,0xb6,
      0xb7,0xb8,0xb9,0xba,0xc2,0xc3,0xc4,0xc5,0xc6,0xc7,0xc8,0xc9,0xca,0xd2,0xd3,0xd4,0xd5,0xd6,0xd7,0xd8,0xd9,0xda,0xe1,0xe2,
      0xe3,0xe4,0xe5,0xe6,0xe7,0xe8,0xe9,0xea,0xf1,0xf2,0xf3,0xf4,0xf5,0xf6,0xf7,0xf8,0xf9,0xfa
   };
   static const unsigned char std_dc_chrominance_nrcodes[] = {0,0,3,1,1,1,1,1,1,1,1,1,0,0,0,0,0};
   static const unsigned char std_dc_chrominance_values[] = {0,1,2,3,4,5,6,7,8,9,10,11};
   static const unsigned char std_ac_chrominance_nrcodes[] = {0,0,2,1,2,4,4,3,4,7,5,4,4,0,1,2,0x77};
   static const unsigned char std_ac_chrominance_values[] = {
      0x00,0x01,0x02,0x03,0x11,0x04,0x05,0x21,0x31,0x06,0x12,0x41,0x51,0x07,0x61,0x71,0x13,0x22,0x32,0x81,0x08,0x14,0x42,0x91,
      0xa1,0xb1,0xc1,0x09,0x23,0x33,0x52,0xf0,0x15,0x62,0x72,0xd1,0x0a,0x16,0x24,0x34,0xe1,0x25,0xf1,0x17,0x18,0x19,0x1a,0x26,
      0x27,0x28,0x29,0x2a,0x35,0x36,0x37,0x38,0x39,0x3a,0x43,0x44,0x45,0x46,0x47,0x48,0x49,0x4a,0x53,0x54,0x55,0x56,0x57,0x58,
      0x59,0x5a,0x63,0x64,0x65,0x66,0x67,0x68,0x69,0x6a,0x73,0x74,0x75,0x76,0x77,0x78,0x79,0x7a,0x82,0x83,0x84,0x85,0x86,0x87,
      0x88,0x89,0x8a,0x92,0x93,0x94,0x95,0x96,0x97,0x98,0x99,0x9a,0xa2,0xa3,0xa4,0xa5,0xa6,0xa7,0xa8,0xa9,0xaa,0xb2,0xb3,0xb4,
      0xb5,0xb6,0xb7,0xb8,0xb9,0xba,0xc2,0xc3,0xc4,0xc5,0xc6,0xc7,0xc8,0xc9,0xca,0xd2,0xd3,0xd4,0xd5,0xd6,0xd7,0xd8,0xd9,0xda,
      0xe2,0xe3,0xe4,0xe5,0xe6,0xe7,0xe8,0xe9,0xea,0xf2,0xf3,0xf4,0xf5,0xf6,0xf7,0xf8,0xf9,0xfa
   };
   // Huffman tables
   static const unsigned short YDC_HT[256][2] = { {0,2},{2,3},{3,3},{4,3},{5,3},{6,3},{14,4},{30,5},{62,6},{126,7},{254,8},{510,9}};
   static const unsigned short UVDC_HT[256][2] = { {0,2},{1,2},{2,2},{6,3},{14,4},{30,5},{62,6},{126,7},{254,8},{510,9},{1022,10},{2046,11}};
   static const unsigned short YAC_HT[256][2] = {
      {10,4},{0,2},{1,2},{4,3},{11,4},{26,5},{120,7},{248,8},{1014,10},{65410,16},{65411,16},{0,0},{0,0},{0,0},{0,0},{0,0},{0,0},
      {12,4},{27,5},{121,7},{502,9},{2038,11},{65412,16},{65413,16},{65414,16},{65415,16},{65416,16},{0,0},{0,0},{0,0},{0,0},{0,0},{0,0},
      {28,5},{249,8},{1015,10},{4084,12},{65417,16},{65418,16},{65419,16},{65420,16},{65421,16},{65422,16},{0,0},{0,0},{0,0},{0,0},{0,0},{0,0},
      {58,6},{503,9},{4085,12},{65423,16},{65424,16},{65425,16},{65426,16},{65427,16},{65428,16},{65429,16},{0,0},{0,0},{0,0},{0,0},{0,0},{0,0},
      {59,6},{1016,10},{65430,16},{65431,16},{65432,16},{65433,16},{65434,16},{65435,16},{65436,16},{65437,16},{0,0},{0,0},{0,0},{0,0},{0,0},{0,0},
      {122,7},{2039,11},{65438,16},{65439,16},{65440,16},{65441,16},{65442,16},{65443,16},{65444,16},{65445,16},{0,0},{0,0},{0,0},{0,0},{0,0},{0,0},
      {123,7},{4086,12},{65446,16},{65447,16},{65448,16},{65449,16},{65450,16},{65451,16},{65452,16},{65453,16},{0,0},{0,0},{0,0},{0,0},{0,0},{0,0},
      {250,8},{4087,12},{65454,16},{65455,16},{65456,16},{65457,16},{65458,16},{65459,16},{65460,16},{65461,16},{0,0},{0,0},{0,0},{0,0},{0,0},{0,0},
      {504,9},{32704,15},{65462,16},{65463,16},{65464,16},{65465,16},{65466,16},{65467,16},{65468,16},{65469,16},{0,0},{0,0},{0,0},{0,0},{0,0},{0,0},
      {505,9},{65470,16},{65471,16},{65472,16},{65473,16},{65474,16},{65475,16},{65476,16},{65477,16},{65478,16},{0,0},{0,0},{0,0},{0,0},{0,0},{0,0},
      {506,9},{65479,16},{65480,16},{65481,16},{65482,16},{65483,16},{65484,16},{65485,16},{65486,16},{65487,16},{0,0},{0,0},{0,0},{0,0},{0,0},{0,0},
      {1017,10},{65488,16},{65489,16},{65490,16},{65491,16},{65492,16},{65493,16},{65494,16},{65495,16},{65496,16},{0,0},{0,0},{0,0},{0,0},{0,0},{0,0},
      {1018,10},{65497,16},{65498,16},{65499,16},{65500,16},{65501,16},{65502,16},{65503,16},{65504,16},{65505,16},{0,0},{0,0},{0,0},{0,0},{0,0},{0,0},
      {2040,11},{65506,16},{65507,16},{65508,16},{65509,16},{65510,16},{65511,16},{65512,16},{65513,16},{65514,16},{0,0},{0,0},{0,0},{0,0},{0,0},{0,0},
      {65515,16},{65516,16},{65517,16},{65518,16},{65519,16},{65520,16},{65521,16},{65522,16},{65523,16},{65524,16},{0,0},{0,0},{0,0},{0,0},{0,0},
      {2041,11},{65525,16},{65526,16},{65527,16},{65528,16},{65529,16},{65530,16},{65531,16},{65532,16},{65533,16},{65534,16},{0,0},{0,0},{0,0},{0,0},{0,0}
   };
   static const unsigned short UVAC_HT[256][2] = {
      {0,2},{1,2},{4,3},{10,4},{24,5},{25,5},{56,6},{120,7},{500,9},{1014,10},{4084,12},{0,0},{0,0},{0,0},{0,0},{0,0},{0,0},
      {11,4},{57,6},{246,8},{501,9},{2038,11},{4085,12},{65416,16},{65417,16},{65418,16},{65419,16},{0,0},{0,0},{0,0},{0,0},{0,0},{0,0},
      {26,5},{247,8},{1015,10},{4086,12},{32706,15},{65420,16},{65421,16},{65422,16},{65423,16},{65424,16},{0,0},{0,0},{0,0},{0,0},{0,0},{0,0},
      {27,5},{248,8},{1016,10},{4087,12},{65425,16},{65426,16},{65427,16},{65428,16},{65429,16},{65430,16},{0,0},{0,0},{0,0},{0,0},{0,0},{0,0},
      {58,6},{502,9},{65431,16},{65432,16},{65433,16},{65434,16},{65435,16},{65436,16},{65437,16},{65438,16},{0,0},{0,0},{0,0},{0,0},{0,0},{0,0},
      {59,6},{1017,10},{65439,16},{65440,16},{65441,16},{65442,16},{65443,16},{65444,16},{65445,16},{65446,16},{0,0},{0,0},{0,0},{0,0},{0,0},{0,0},
      {121,7},{2039,11},{65447,16},{65448,16},{65449,16},{65450,16},{65451,16},{65452,16},{65453,16},{65454,16},{0,0},{0,0},{0,0},{0,0},{0,0},{0,0},
      {122,7},{2040,11},{65455,16},{65456,16},{65457,16},{65458,16},{65459,16},{65460,16},{65461,16},{65462,16},{0,0},{0,0},{0,0},{0,0},{0,0},{0,0},
      {249,8},{65463,16},{65464,16},{65465,16},{65466,16},{65467,16},{65468,16},{65469,16},{65470,16},{65471,16},{0,0},{0,0},{0,0},{0,0},{0,0},{0,0},
      {503,9},{65472,16},{65473,16},{65474,16},{65475,16},{65476,16},{65477,16},{65478,16},{65479,16},{65480,16},{0,0},{0,0},{0,0},{0,0},{0,0},{0,0},
      {504,9},{65481,16},{65482,16},{65483,16},{65484,16},{65485,16},{65486,16},{65487,16},{65488,16},{65489,16},{0,0},{0,0},{0,0},{0,0},{0,0},{0,0},
      {505,9},{65490,16},{65491,16},{65492,16},{65493,16},{65494,16},{65495,16},{65496,16},{65497,16},{65498,16},{0,0},{0,0},{0,0},{0,0},{0,0},{0,0},
      {506,9},{65499,16},{65500,16},{65501,16},{65502,16},{65503,16},{65504,16},{65505,16},{65506,16},{65507,16},{0,0},{0,0},{0,0},{0,0},{0,0},{0,0},
      {2041,11},{65508,16},{65509,16},{65510,16},{65511,16},{65512,16},{65513,16},{65514,16},{65515,16},{65516,16},{0,0},{0,0},{0,0},{0,0},{0,0},{0,0},
      {16352,14},{65517,16},{65518,16},{65519,16},{65520,16},{65521,16},{65522,16},{65523,16},{65524,16},{65525,16},{0,0},{0,0},{0,0},{0,0},{0,0},
      {1018,10},{32707,15},{65526,16},{65527,16},{65528,16},{65529,16},{65530,16},{65531,16},{65532,16},{65533,16},{65534,16},{0,0},{0,0},{0,0},{0,0},{0,0}
   };
   static const int YQT[] = {16,11,10,16,24,40,51,61,12,12,14,19,26,58,60,55,14,13,16,24,40,57,69,56,14,17,22,29,51,87,80,62,18,22,
                             37,56,68,109,103,77,24,35,55,64,81,104,113,92,49,64,78,87,103,121,120,101,72,92,95,98,112,100,103,99};
   static const int UVQT[] = {17,18,24,47,99,99,99,99,18,21,26,66,99,99,99,99,24,26,56,99,99,99,99,99,47,66,99,99,99,99,99,99,
                              99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99};
   static const float aasf[] = { 1.0f * 2.828427125f, 1.387039845f * 2.828427125f, 1.306562965f * 2.828427125f, 1.175875602f * 2.828427125f,
                                 1.0f * 2.828427125f, 0.785694958f * 2.828427125f, 0.541196100f * 2.828427125f, 0.275899379f * 2.828427125f };

   int row, col, i, k, subsample;
   float fdtbl_Y[64], fdtbl_UV[64];
   unsigned char YTable[64], UVTable[64];

   if(!data || !width || !height || comp > 4 || comp < 1) {
      return 0;
   }

   quality = quality ? quality : 90;
   subsample = quality <= 90 ? 1 : 0;
   quality = quality < 1 ? 1 : quality > 100 ? 100 : quality;
   quality = quality < 50 ? 5000 / quality : 200 - quality * 2;

   for(i = 0; i < 64; ++i) {
      int uvti, yti = (YQT[i]*quality+50)/100;
      YTable[stbiw__jpg_ZigZag[i]] = (unsigned char) (yti < 1 ? 1 : yti > 255 ? 255 : yti);
      uvti = (UVQT[i]*quality+50)/100;
      UVTable[stbiw__jpg_ZigZag[i]] = (unsigned char) (uvti < 1 ? 1 : uvti > 255 ? 255 : uvti);
   }

   for(row = 0, k = 0; row < 8; ++row) {
      for(col = 0; col < 8; ++col, ++k) {
         fdtbl_Y[k]  = 1 / (YTable [stbiw__jpg_ZigZag[k]] * aasf[row] * aasf[col]);
         fdtbl_UV[k] = 1 / (UVTable[stbiw__jpg_ZigZag[k]] * aasf[row] * aasf[col]);
      }
   }

   // Write Headers
   {
      static const unsigned char head0[] = { 0xFF,0xD8,0xFF,0xE0,0,0x10,'J','F','I','F',0,1,1,0,0,1,0,1,0,0,0xFF,0xDB,0,0x84,0 };
      static const unsigned char head2[] = { 0xFF,0xDA,0,0xC,3,1,0,2,0x11,3,0x11,0,0x3F,0 };
      const unsigned char head1[] = { 0xFF,0xC0,0,0x11,8,(unsigned char)(height>>8),STBIW_UCHAR(height),(unsigned char)(width>>8),STBIW_UCHAR(width),
                                      3,1,(unsigned char)(subsample?0x22:0x11),0,2,0x11,1,3,0x11,1,0xFF,0xC4,0x01,0xA2,0 };
      s->func(s->context, (void*)head0, sizeof(head0));
      s->func(s->context, (void*)YTable, sizeof(YTable));
      stbiw__putc(s, 1);
      s->func(s->context, UVTable, sizeof(UVTable));
      s->func(s->context, (void*)head1, sizeof(head1));
      s->func(s->context, (void*)(std_dc_luminance_nrcodes+1), sizeof(std_dc_luminance_nrcodes)-1);
      s->func(s->context, (void*)std_dc_luminance_values, sizeof(std_dc_luminance_values));
      stbiw__putc(s, 0x10); // HTYACinfo
      s->func(s->context, (void*)(std_ac_luminance_nrcodes+1), sizeof(std_ac_luminance_nrcodes)-1);
      s->func(s->context, (void*)std_ac_luminance_values, sizeof(std_ac_luminance_values));
      stbiw__putc(s, 1); // HTUDCinfo
      s->func(s->context, (void*)(std_dc_chrominance_nrcodes+1), sizeof(std_dc_chrominance_nrcodes)-1);
      s->func(s->context, (void*)std_dc_chrominance_values, sizeof(std_dc_chrominance_values));
      stbiw__putc(s, 0x11); // HTUACinfo
      s->func(s->context, (void*)(std_ac_chrominance_nrcodes+1), sizeof(std_ac_chrominance_nrcodes)-1);
      s->func(s->context, (void*)std_ac_chrominance_values, sizeof(std_ac_chrominance_values));
      s->func(s->context, (void*)head2, sizeof(head2));
   }

   // Encode 8x8 macroblocks
   {
      static const unsigned short fillBits[] = {0x7F, 7};
      int DCY=0, DCU=0, DCV=0;
      int bitBuf=0, bitCnt=0;
      // comp == 2 is grey+alpha (alpha is ignored)
      int ofsG = comp > 2 ? 1 : 0, ofsB = comp > 2 ? 2 : 0;
      const unsigned char *dataR = (const unsigned char *)data;
      const unsigned char *dataG = dataR + ofsG;
      const unsigned char *dataB = dataR + ofsB;
      int x, y, pos;
      if(subsample) {
         for(y = 0; y < height; y += 16) {
            for(x = 0; x < width; x += 16) {
               float Y[256], U[256], V[256];
               for(row = y, pos = 0; row < y+16; ++row) {
                  // row >= height => use last input row
                  int clamped_row = (row < height) ? row : height - 1;
                  int base_p = (stbi__flip_vertically_on_write ? (height-1-clamped_row) : clamped_row)*width*comp;
                  for(col = x; col < x+16; ++col, ++pos) {
                     // if col >= width => use pixel from last input column
                     int p = base_p + ((col < width) ? col : (width-1))*comp;
                     float r = dataR[p], g = dataG[p], b = dataB[p];
                     Y[pos]= +0.29900f*r + 0.58700f*g + 0.11400f*b - 128;
                     U[pos]= -0.16874f*r - 0.33126f*g + 0.50000f*b;
                     V[pos]= +0.50000f*r - 0.41869f*g - 0.08131f*b;
                  }
               }
               DCY = stbiw__jpg_processDU(s, &bitBuf, &bitCnt, Y+0,   16, fdtbl_Y, DCY, YDC_HT, YAC_HT);
               DCY = stbiw__jpg_processDU(s, &bitBuf, &bitCnt, Y+8,   16, fdtbl_Y, DCY, YDC_HT, YAC_HT);
               DCY = stbiw__jpg_processDU(s, &bitBuf, &bitCnt, Y+128, 16, fdtbl_Y, DCY, YDC_HT, YAC_HT);
               DCY = stbiw__jpg_processDU(s, &bitBuf, &bitCnt, Y+136, 16, fdtbl_Y, DCY, YDC_HT, YAC_HT);

               // subsample U,V
               {
                  float subU[64], subV[64];
                  int yy, xx;
                  for(yy = 0, pos = 0; yy < 8; ++yy) {
                     for(xx = 0; xx < 8; ++xx, ++pos) {
                        int j = yy*32+xx*2;
                        subU[pos] = (U[j+0] + U[j+1] + U[j+16] + U[j+17]) * 0.25f;
                        subV[pos] = (V[j+0] + V[j+1] + V[j+16] + V[j+17]) * 0.25f;
                     }
                  }
                  DCU = stbiw__jpg_processDU(s, &bitBuf, &bitCnt, subU, 8, fdtbl_UV, DCU, UVDC_HT, UVAC_HT);
                  DCV = stbiw__jpg_processDU(s, &bitBuf, &bitCnt, subV, 8, fdtbl_UV, DCV, UVDC_HT, UVAC_HT);
               }
            }
         }
      } else {
         for(y = 0; y < height; y += 8) {
            for(x = 0; x < width; x += 8) {
               float Y[64], U[64], V[64];
               for(row = y, pos = 0; row < y+8; ++row) {
                  // row >= height => use last input row
                  int clamped_row = (row < height) ? row : height - 1;
                  int base_p = (stbi__flip_vertically_on_write ? (height-1-clamped_row) : clamped_row)*width*comp;
                  for(col = x; col < x+8; ++col, ++pos) {
                     // if col >= width => use pixel from last input column
                     int p = base_p + ((col < width) ? col : (width-1))*comp;
                     float r = dataR[p], g = dataG[p], b = dataB[p];
                     Y[pos]= +0.29900f*r + 0.58700f*g + 0.11400f*b - 128;
                     U[pos]= -0.16874f*r - 0.33126f*g + 0.50000f*b;
                     V[pos]= +0.50000f*r - 0.41869f*g - 0.08131f*b;
                  }
               }

               DCY = stbiw__jpg_processDU(s, &bitBuf, &bitCnt, Y, 8, fdtbl_Y,  DCY, YDC_HT, YAC_HT);
               DCU = stbiw__jpg_processDU(s, &bitBuf, &bitCnt, U, 8, fdtbl_UV, DCU, UVDC_HT, UVAC_HT);
               DCV = stbiw__jpg_processDU(s, &bitBuf, &bitCnt, V, 8, fdtbl_UV, DCV, UVDC_HT, UVAC_HT);
            }
         }
      }

      // Do the bit alignment of the EOI marker
      stbiw__jpg_writeBits(s, &bitBuf, &bitCnt, fillBits);
   }

   // EOI
   stbiw__putc(s, 0xFF);
   stbiw__putc(s, 0xD9);

   return 1;
}

STBIWDEF int stbi_write_jpg_to_func(stbi_write_func *func, void *context, int x, int y, int comp, const void *data, int quality)
{
   stbi__write_context s = { 0 };
   stbi__start_write_callbacks(&s, func, context);
   return stbi_write_jpg_core(&s, x, y, comp, (void *) data, quality);
}


#ifndef STBI_WRITE_NO_STDIO
STBIWDEF int stbi_write_jpg(char const *filename, int x, int y, int comp, const void *data, int quality)
{
   stbi__write_context s = { 0 };
   if (stbi__start_write_file(&s,filename)) {
      int r = stbi_write_jpg_core(&s, x, y, comp, data, quality);
      stbi__end_write_file(&s);
      return r;
   } else
      return 0;
}
#endif

#endif // STB_IMAGE_WRITE_IMPLEMENTATION

/* Revision history
      1.16  (2021-07-11)
             make Deflate code emit uncompressed blocks when it would otherwise expand
             support writing BMPs with alpha channel
      1.15  (2020-07-13) unknown
      1.14  (2020-02-02) updated JPEG writer to downsample chroma channels
      1.13
      1.12
      1.11  (2019-08-11)

      1.10  (2019-02-07)
             support utf8 filenames in Windows; fix warnings and platform ifdefs
      1.09  (2018-02-11)
             fix typo in zlib quality API, improve STB_I_W_STATIC in C++
      1.08  (2018-01-29)
             add stbi__flip_vertically_on_write, external zlib, zlib quality, choose PNG filter
      1.07  (2017-07-24)
             doc fix
      1.06 (2017-07-23)
             writing JPEG (using Jon Olick's code)
      1.05   ???
      1.04 (2017-03-03)
             monochrome BMP expansion
      1.03   ???
      1.02 (2016-04-02)
             avoid allocating large structures on the stack
      1.01 (2016-01-16)
             STBIW_REALLOC_SIZED: support allocators with no realloc support
             avoid race-condition in crc initialization
             minor compile issues
      1.00 (2015-09-14)
             installable file IO function
      0.99 (2015-09-13)
             warning fixes; TGA rle support
      0.98 (2015-04-08)
             added STBIW_MALLOC, STBIW_ASSERT etc
      0.97 (2015-01-18)
             fixed HDR asserts, rewrote HDR rle logic
      0.96 (2015-01-17)
             add HDR output
             fix monochrome BMP
      0.95 (2014-08-17)
             add monochrome TGA output
      0.94 (2014-05-31)
             rename private functions to avoid conflicts with stb_image.h
      0.93 (2014-05-27)
             warning fixes
      0.92 (2010-08-01)
             casts to unsigned char to fix warnings
      0.91 (2010-07-17)
             first public release
      0.90   first internal release
*/

/*
------------------------------------------------------------------------------
This software is available under 2 licenses -- choose whichever you prefer.
------------------------------------------------------------------------------
ALTERNATIVE A - MIT License
Copyright (c) 2017 Sean Barrett
Permission is hereby granted, free of charge, to any person obtaining a copy of
this software and associated documentation files (the "Software"), to deal in
the Software without restriction, including without limitation the rights to
use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies
of the Software, and to permit persons to whom the Software is furnished to do
so, subject to the following conditions:
The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.
THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
------------------------------------------------------------------------------
ALTERNATIVE B - Public Domain (www.unlicense.org)
This is free and unencumbered software released into the public domain.
Anyone is free to copy, modify, publish, use, compile, sell, or distribute this
software, either in source code form or as a compiled binary, for any purpose,
commercial or non-commercial, and by any means.
In jurisdictions that recognize copyright laws, the author or authors of this
software dedicate any and all copyright interest in the software to the public
domain. We make this dedication for the benefit of the public at large and to
the detriment of our heirs and successors. We intend this dedication to be an
overt act of relinquishment in perpetuity of all present and future rights to
this software under copyright law.
THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
------------------------------------------------------------------------------
*/

```

`docs/3d-projection.tex`:

```tex
\documentclass{article}
\usepackage{tikz}
\usepackage{amsmath}
\begin{document}
\section{3D Projection}
\def\minY{-2} \def\maxY{2}
\def\minZ{-2} \def\maxZ{6}
\def\screenZ{2}
\def\eyeZ{0} \def\eyeY{0}
\def\pZ{3} \def\pY{1}
\begin{tikzpicture}
  \draw[-stealth] (\minZ,0) -- (\maxZ,0) node[above]{$z$};
  \draw[-stealth] (0,\minY) -- (0,\maxY) node[above]{$x$};
  \draw[fill] (\eyeZ, \eyeY) circle (.5ex) node[above]{eye ($E$)};
  \draw[dotted,thick] (\screenZ, \minY) -- (\screenZ, \maxY) node[above]{screen ($S_z$)};
  \draw[dotted] (\eyeZ, \eyeY) -- (\pZ, \pY);
  \draw[dotted] (\eyeZ, \eyeY) -- (\pZ, -\pY);
  \draw[fill] (\pZ, \pY) circle (.5ex) node[above]{$p_1$};
  \draw[fill] (\pZ, -\pY) circle (.5ex) node[above]{$p_2$};
  \draw[fill] (\screenZ, {(\pY - \eyeY)/(\pZ - \eyeZ)*(\screenZ - \eyeZ) + \eyeY}) circle (.5ex) node[above]{$p_1'$};
  \draw[fill] (\screenZ, {-(\pY - \eyeY)/(\pZ - \eyeZ)*(\screenZ - \eyeZ) + \eyeY}) circle (.5ex) node[above]{$p_2'$};
\end{tikzpicture}

When we refer to $p$ we mean either $p_1$ or $p_2$. When we refer to $p'$ we mean either $p'_1$ or $p'_2$.

\begin{align}
  & p = (p_x, p_y, p_z) \\
  & p'= (p'_x, p'_y, S_z) \\
  & E = (E_x, E_y, E_z) \\
\end{align}

The formula to find $p'$

\begin{align}
  & p_y' = \frac{(p_y - E_y)(S_z - E_z)}{(p_z - E_z)} + E_y \\
  & p_x' = \frac{(p_x - E_x)(S_z - E_z)}{(p_z - E_z)} + E_x \\
\end{align}

If we assume that $E = (0, 0, 0)$ and $S_z = 1$

\begin{align}
  & p_y' = \frac{p_y}{p_z} \\
  & p_x' = \frac{p_x}{p_z} \\
\end{align}

\end{document}

```

`docs/barycentric.tex`:

```tex
\documentclass{article}
\usepackage{amsmath}
\usepackage{tikz}
\begin{document}
\section{Barycentric Coordinates}

Barycentric coordinates enable you to evenly interpolate between three values among the verticies of a triangle.

\def\xa{0} \def\ya{0}
\def\xb{1} \def\yb{2}
\def\xc{3} \def\yc{-1}
\def\xp{1} \def\yp{0.25}
\begin{center}
\begin{tikzpicture}
  \draw[gray, thick] (\xa,\ya) -- (\xb,\yb);
  \draw[gray, thick] (\xb,\yb) -- (\xc,\yc);
  \draw[gray, thick] (\xc,\yc) -- (\xa,\ya);
  \draw[gray, thick, dotted] (\xa,\ya) -- (\xp,\yp);
  \draw[gray, thick, dotted] (\xb,\yb) -- (\xp,\yp);
  \draw[gray, thick, dotted] (\xc,\yc) -- (\xp,\yp);
  \filldraw[black] (\xa,\ya) circle (2pt) node[anchor=west]{$v_1$};
  \filldraw[black] (\xb,\yb) circle (2pt) node[anchor=west]{$v_2$};
  \filldraw[black] (\xc,\yc) circle (2pt) node[anchor=west]{$v_3$};
  \filldraw[black] (\xp,\yp) circle (2pt) node[anchor=west]{$p$};
\end{tikzpicture}
\end{center}

\begin{align}
  U &= (u_1, u_2, u_3) \\
  v_1 &= (x_1, y_1) \\
  v_2 &= (x_2, y_2) \\
  v_3 &= (x_3, y_3) \\
  p   &= (x_p, y_p)
\end{align}

The Barycentric coordinates can be defined in terms of the following relationships:

\begin{align}
  \begin{cases}
  & u_1 + u_2 + u_3 = 1 \\
  & u_1x_1 + u_2x_2 + u_3x_3 = x_p \\
  & u_1y_1 + u_2y_2 + u_3y_3 = y_p
  \end{cases}
\end{align}


Let's reduce the amount of variables in these equations:

\begin{align}
  & u_3 = 1 - u_1 - u_2 \\
  & \begin{cases}
    u_1(x_1 - x_3) + u_2(x_2 - x_3) &= x_p - x_3 \\
    u_1(y_1 - y_3) + u_2(y_2 - y_3) &= y_p - y_3 \\
  \end{cases}
\end{align}

Now we can turn the system of equations into matrix form:

\begin{align}
  & T =
  \begin{bmatrix}
    x_1 - x_3 & x_2 - x_3 \\
    y_1 - y_3 & y_2 - y_3 \\
  \end{bmatrix} \\
  & U = \begin{bmatrix}
    u1 \\ u2 \\
  \end{bmatrix}\\
  & R = \begin{bmatrix}
    x_p - x_3 \\
    y_p - y_3 \\
  \end{bmatrix} \\
  & T \cdot U = R
\end{align}

So the solution is

\begin{align}
  U = T^{-1} \cdot R
\end{align}

The main effort goes towards finding $T^{-1}$

\begin{align}
  & T^{-1} = \frac{adj(T)}{det(T)} \\
  & det(T) = (x_1 - x_3)(y_2 - y_3) - (x_2 - x_3)(y_1 - y_3) \\
  & adj(T) = \begin{bmatrix}
    y_2 - y_3 & x_3 - x_2 \\
    y_3 - y_1 & x_1 - x_3 \\
  \end{bmatrix} \\
  & T^{-1} = \frac{1}{det(T)} \cdot \begin{bmatrix}
    y_2 - y_3 & x_3 - x_2 \\
    y_3 - y_1 & x_1 - x_3 \\
  \end{bmatrix} \\
  & T^{-1}\cdot R = \frac{1}{det(T)} \cdot \begin{bmatrix}
    (y_2 - y_3)(x_p - x_3) + (x_3 - x_2)(y_p - y_3) \\
    (y_3 - y_1)(x_p - x_3) + (x_1 - x_3)(y_p - y_3) \\
  \end{bmatrix}
\end{align}

And the final formula you need to find $(u_1, u_2, u_3)$ given the points $v_1, v_2, v_3, p$~is

\begin{align}
  u_1 &= \frac{(y_2 - y_3)(x_p - x_3) + (x_3 - x_2)(y_p - y_3)}{(x_1 - x_3)(y_2 - y_3) - (x_2 - x_3)(y_1 - y_3)} \\
  u_2 &= \frac{(y_3 - y_1)(x_p - x_3) + (x_1 - x_3)(y_p - y_3)}{(x_1 - x_3)(y_2 - y_3) - (x_2 - x_3)(y_1 - y_3)} \\
  u_3 &= 1 - u_2 - u_1
\end{align}

\end{document}


```

`fonts/OFL.txt`:

```txt
Copyright (c) 2012, Pablo Impallari (www.impallari.com|impallari@gmail.com), 
Copyright (c) 2012, Rodrigo Fuenzalida (www.rfuenzalida.com|hello@rfuenzalida.com), with Reserved Font Name Libre Baskerville.

This Font Software is licensed under the SIL Open Font License, Version 1.1.
This license is copied below, and is also available with a FAQ at:
http://scripts.sil.org/OFL


-----------------------------------------------------------
SIL OPEN FONT LICENSE Version 1.1 - 26 February 2007
-----------------------------------------------------------

PREAMBLE
The goals of the Open Font License (OFL) are to stimulate worldwide
development of collaborative font projects, to support the font creation
efforts of academic and linguistic communities, and to provide a free and
open framework in which fonts may be shared and improved in partnership
with others.

The OFL allows the licensed fonts to be used, studied, modified and
redistributed freely as long as they are not sold by themselves. The
fonts, including any derivative works, can be bundled, embedded, 
redistributed and/or sold with any software provided that any reserved
names are not used by derivative works. The fonts and derivatives,
however, cannot be released under any other type of license. The
requirement for fonts to remain under this license does not apply
to any document created using the fonts or their derivatives.

DEFINITIONS
"Font Software" refers to the set of files released by the Copyright
Holder(s) under this license and clearly marked as such. This may
include source files, build scripts and documentation.

"Reserved Font Name" refers to any names specified as such after the
copyright statement(s).

"Original Version" refers to the collection of Font Software components as
distributed by the Copyright Holder(s).

"Modified Version" refers to any derivative made by adding to, deleting,
or substituting -- in part or in whole -- any of the components of the
Original Version, by changing formats or by porting the Font Software to a
new environment.

"Author" refers to any designer, engineer, programmer, technical
writer or other person who contributed to the Font Software.

PERMISSION & CONDITIONS
Permission is hereby granted, free of charge, to any person obtaining
a copy of the Font Software, to use, study, copy, merge, embed, modify,
redistribute, and sell modified and unmodified copies of the Font
Software, subject to the following conditions:

1) Neither the Font Software nor any of its individual components,
in Original or Modified Versions, may be sold by itself.

2) Original or Modified Versions of the Font Software may be bundled,
redistributed and/or sold with any software, provided that each copy
contains the above copyright notice and this license. These can be
included either as stand-alone text files, human-readable headers or
in the appropriate machine-readable metadata fields within text or
binary files as long as those fields can be easily viewed by the user.

3) No Modified Version of the Font Software may use the Reserved Font
Name(s) unless explicit written permission is granted by the corresponding
Copyright Holder. This restriction only applies to the primary font name as
presented to the users.

4) The name(s) of the Copyright Holder(s) or the Author(s) of the Font
Software shall not be used to promote, endorse or advertise any
Modified Version, except to acknowledge the contribution(s) of the
Copyright Holder(s) and the Author(s) or with their explicit written
permission.

5) The Font Software, modified or unmodified, in part or in whole,
must be distributed entirely under this license, and must not be
distributed under any other license. The requirement for fonts to
remain under this license does not apply to any document created
using the Font Software.

TERMINATION
This license becomes null and void if any of the above conditions are
not met.

DISCLAIMER
THE FONT SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO ANY WARRANTIES OF
MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT
OF COPYRIGHT, PATENT, TRADEMARK, OR OTHER RIGHT. IN NO EVENT SHALL THE
COPYRIGHT HOLDER BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
INCLUDING ANY GENERAL, SPECIAL, INDIRECT, INCIDENTAL, OR CONSEQUENTIAL
DAMAGES, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
FROM, OUT OF THE USE OR INABILITY TO USE THE FONT SOFTWARE OR FROM
OTHER DEALINGS IN THE FONT SOFTWARE.

```

`index.html`:

```html
<html>
  <head>
    <title>Olive.c</title>
    <link rel="stylesheet" href="css/reset.css" />
    <link rel="stylesheet" href="css/index.css" />
  </head>
  <body>
    <h1>Olive.c Demos</h1>
    <p>Olive.c is a simple graphics library that does not have any dependencies and renders everything into the given memory pixel by pixel.</p>
    <p>Below is a bunch of demos written in C using this library compiled to WebAssembly. Every frame of the animations is generated pixel by pixel on CPU without using any special GPU APIs like OpenGL, Metal, etc. </p>
    <p>The source code of the library and the demos is available on GitHub: <a href="https://github.com/tsoding/olive.c">https://github.com/tsoding/olive.c</a></p>

    <div id="sec-triangle">
      <h2 id="demo-triangle"><a href="#demo-triangle">Triangle</a></h2>
      <p>Rainbow triangle together with a transparent circle. Source:&nbsp;<a href="https://github.com/tsoding/olive.c/blob/master/demos/triangle.c">demos/triangle.c</a></p>
      <canvas id="app-triangle"></canvas>
    </div>

    <div id="sec-dots3d">
      <h2 id="demo-dots3d"><a href="#demo-dots3d">Dots 3D</a></h2>
      <p>A bunch of 3D dots projected onto your 2D screen plus a text with a builtin monospaced font. Source:&nbsp;<a href="https://github.com/tsoding/olive.c/blob/master/demos/dots3d.c">demos/dots3d.c</a></p>
      <canvas id="app-dots3d"></canvas>
    </div>

    <div id="sec-squish">
      <h2 id="demo-squish"><a href="#demo-squish">Squish</a></h2>
      <p>Resizing images on the fly. Source:&nbsp;<a href="https://github.com/tsoding/olive.c/blob/master/demos/squish.c">demos/squish.c</a></p>
      <canvas id="app-squish"></canvas>
    </div>

    <div id="sec-triangle3d">
      <h2 id="demo-triangle3d"><a href="#demo-triangle3d">Triangle 3D</a></h2>
      <p>Rotating rainbow triangle in 3D. Unlike <a href="#demo-3d">3D dots above</a> this is a solid shape. Source:&nbsp;<a href="https://github.com/tsoding/olive.c/blob/master/demos/triangle3d.c">demos/triangle3d.c</a></p>
      <canvas id="app-triangle3d"></canvas>
    </div>

    <div id="sec-triangleTex">
      <h2 id="demo-triangleTex"><a href="#demo-triangleTex">Rotating 2D Textures</a></h2>
      <p>Source:&nbsp;<a href="https://github.com/tsoding/olive.c/blob/master/demos/triangleTex.c">demos/triangleTex.c</a></p>
      <canvas id="app-triangleTex"></canvas>
    </div>

    <div id="sec-triangle3dTex">
      <h2 id="demo-triangle3dTex"><a href="#demo-triangle3dTex">Rotating 3D Textures</a></h2>
      <p>Textures by <a href="https://opengameart.org/content/handpainted-stone-texture">MELLE</a>. Source:&nbsp;<a href="https://github.com/tsoding/olive.c/blob/master/demos/triangle3dTex.c">demos/triangle3dTex.c</a></p>
      <canvas id="app-triangle3dTex"></canvas>
    </div>

    <div id="sec-cup3d">
      <h2 id="demo-cup3d"><a href="#demo-cup3d">Cup 3D</a></h2>
      <p>Design by <a href="https://github.com/rexim">rexim</a>. 3D model by <a href="https://github.com/kolumb">kolumb</a>. Source:&nbsp;<a href="https://github.com/tsoding/olive.c/blob/master/demos/cup3d.c">demos/cup3d.c</a></p>
      <canvas id="app-cup3d"></canvas>
    </div>

    <div id="sec-teapot3d">
      <h2 id="demo-teapot3d"><a href="#demo-teapot3d">Utah Teapot</a></h2>
      <p>Famous <a href="https://en.wikipedia.org/wiki/Utah_teapot">Utah Teapot</a>. Model by <a href="https://graphics.stanford.edu/courses/cs148-10-summer/as3/code/as3/teapot.obj">Standford University</a>. Source:&nbsp;<a href="https://github.com/tsoding/olive.c/blob/master/demos/teapot3d.c">demos/teapot3d.c</a></p>
      <p>(I have no idea why it runs with a reasonable FPS)</p>
      <canvas id="app-teapot3d"></canvas>
    </div>

    <div id="sec-penger3d">
      <h2 id="demo-penger3d"><a href="#demo-penger3d">Penger</a></h2>
      <p><a href="https://penger.neocities.org/">Penger</a> - The Mascot of Tsoding Discord Community. The character design by <a href="https://github.com/LainLayer">LainLayer</a>. The model by <a href="https://github.com/Max-Kawula">Max-Kawula</a>. Source:&nbsp;<a href="https://github.com/tsoding/olive.c/blob/master/demos/penger3d.c">demos/penger3d.c</a></p>
      <canvas id="app-penger3d"></canvas>
    </div>

    <script src="js/vc.js"></script>
    <script>
      startDemo("triangle", "./wasm/triangle.wasm");
      startDemo("dots3d", "./wasm/dots3d.wasm");
      startDemo("squish", "./wasm/squish.wasm");
      startDemo("triangle3d", "./wasm/triangle3d.wasm");
      startDemo("triangleTex", "./wasm/triangleTex.wasm");
      startDemo("triangle3dTex", "./wasm/triangle3dTex.wasm");
      startDemo("cup3d", "./wasm/cup3d.wasm");
      startDemo("teapot3d", "./wasm/teapot3d.wasm");
      startDemo("penger3d", "./wasm/penger3d.wasm");
    </script>
  </body>
</html>

```

`js/vc.js`:

```js
// Browser runtime for the Demo Virtual Console
function make_environment(...envs) {
    return new Proxy(envs, {
        get(target, prop, receiver) {
            for (let env of envs) {
                if (env.hasOwnProperty(prop)) {
                    return env[prop];
                }
            }
            return (...args) => {console.error("NOT IMPLEMENTED: "+prop, args)}
        }
    });
}

const libm = {
    "atan2f": Math.atan2,
    "cosf": Math.cos,
    "sinf": Math.sin,
    "sqrtf": Math.sqrt,
};

let iota = 0;
// TODO: nothing in this Canvas "declaration" states that iota's measure units are Uint32
// Which is not useful for all kinds of structures. A more general approach would be to use Uint8 as the measure units.
const CANVAS_PIXELS = iota++;
const CANVAS_WIDTH  = iota++;
const CANVAS_HEIGHT = iota++;
const CANVAS_STRIDE = iota++;
const CANVAS_SIZE   = iota++;

function readCanvasFromMemory(memory_buffer, canvas_ptr)
{
    const canvas_memory = new Uint32Array(memory_buffer, canvas_ptr, CANVAS_SIZE);
    return {
        pixels: canvas_memory[CANVAS_PIXELS],
        width: canvas_memory[CANVAS_WIDTH],
        height: canvas_memory[CANVAS_HEIGHT],
        stride: canvas_memory[CANVAS_STRIDE],
    };
}

async function startDemo(elementId, wasmPath) {
    const app = document.getElementById(`app-${elementId}`);
    if (app === null) {
        console.error(`Could not find element app-${elementId}. Skipping demo ${wasmPath}...`);
        return;
    }
    const sec = document.getElementById(`sec-${elementId}`);
    if (sec === null) {
        console.error(`Could not find element sec-${elementId}. Skipping demo ${wasmPath}...`);
        return;
    }

    let paused = true;
    sec.addEventListener("mouseenter", () => paused = false);
    sec.addEventListener("mouseleave", () => paused = true);

    const ctx = app.getContext("2d");
    const w = await WebAssembly.instantiateStreaming(fetch(wasmPath), {
        "env": make_environment(libm)
    });

    // TODO: if __heap_base not found tell the user to compile their wasm module with -Wl,--export=__heap_base
    const heap_base = w.instance.exports.__heap_base.value;

    function render(dt) {
        const buffer = w.instance.exports.memory.buffer;
        w.instance.exports.vc_render(heap_base, dt*0.001);
        const canvas = readCanvasFromMemory(buffer, heap_base);
        if (canvas.width != canvas.stride) {
            // TODO: maybe we can preallocate a Uint8ClampedArray on JavaScript side and just copy the canvas data there to bring width and stride to the same value?
            console.error(`Canvas width (${canvas.width}) is not equal to its stride (${canvas.stride}). Unfortunately we can't easily support that in a browser because ImageData simply does not accept stride. Welcome to 2022.`);
            return;
        }
        const image = new ImageData(new Uint8ClampedArray(buffer, canvas.pixels, canvas.width*canvas.height*4), canvas.width);
        app.width = canvas.width;
        app.height = canvas.height;
        ctx.putImageData(image, 0, 0);
    }

    let prev = null;
    function first(timestamp) {
        prev = timestamp;
        render(0);
        window.requestAnimationFrame(loop);
    }
    function loop(timestamp) {
        const dt = timestamp - prev;
        prev = timestamp;
        if (!paused) render(dt);
        window.requestAnimationFrame(loop);
    }
    window.requestAnimationFrame(first);
}

```

`nob.c`:

```c
#define NOB_IMPLEMENTATION
#define NOB_STRIP_PREFIX
#define NOB_EXPERIMENTAL_DELETE_OLD
#define NOB_WARN_DEPRECATED
#include "./dev-deps/nob.h"

#define COMMON_CFLAGS "-Wall", "-Wextra", "-pedantic", "-ggdb", "-I.", "-I./build/", "-I./dev-deps/"

bool build_tools(Cmd *cmd, Procs *procs)
{
    if (!mkdir_if_not_exists("build")) return false;
    if (!mkdir_if_not_exists("build/tools")) return false;

    cmd_append(cmd, "clang", COMMON_CFLAGS, "-o", "./build/tools/png2c", "./tools/png2c.c", "-lm");
    if (!cmd_run(cmd, .async = procs)) return false;

    cmd_append(cmd, "clang", COMMON_CFLAGS, "-o", "./build/tools/obj2c", "./tools/obj2c.c", "-lm");
    if (!cmd_run(cmd, .async = procs)) return false;

    return true;
}

bool build_assets(Cmd *cmd, Procs *procs)
{
    if (!mkdir_if_not_exists("build")) return false;
    if (!mkdir_if_not_exists("build/assets")) return false;

    cmd_append(cmd, "./build/tools/png2c", "-n", "tsodinPog", "-o", "./build/assets/tsodinPog.c", "./assets/tsodinPog.png");
    if (!cmd_run(cmd, .async = procs)) return false;

    cmd_append(cmd, "./build/tools/png2c", "-n", "tsodinCup", "-o", "./build/assets/tsodinCup.c", "./assets/tsodinCup.png");
    if (!cmd_run(cmd, .async = procs)) return false;

    cmd_append(cmd, "./build/tools/png2c", "-n", "oldstone", "-o", "./build/assets/oldstone.c", "./assets/oldstone.png");
    if (!cmd_run(cmd, .async = procs)) return false;

    cmd_append(cmd, "./build/tools/png2c", "-n", "lavastone", "-o", "./build/assets/lavastone.c", "./assets/lavastone.png");
    if (!cmd_run(cmd, .async = procs)) return false;

    cmd_append(cmd, "./build/tools/obj2c", "-o", "./build/assets/tsodinCupLowPoly.c", "./assets/tsodinCupLowPoly.obj");
    if (!cmd_run(cmd, .async = procs)) return false;

    cmd_append(cmd, "./build/tools/obj2c", "-s", "0.40", "-o", "./build/assets/utahTeapot.c", "./assets/utahTeapot.obj");
    if (!cmd_run(cmd, .async = procs)) return false;

    cmd_append(cmd, "./build/tools/obj2c", "-s", "1.5", "-o", "./build/assets/penger.c", "./assets/penger_obj/penger.obj");
    if (!cmd_run(cmd, .async = procs)) return false;

    return true;
}

bool build_tests(Cmd *cmd, Procs *procs)
{
    cmd_append(cmd, "clang", COMMON_CFLAGS, "-fsanitize=memory", "-o", "./build/test", "test.c", "-lm");
    if (!cmd_run(cmd, .async = procs)) return false;
    return true;
}

bool build_wasm_demo(Cmd *cmd, Procs *procs, const char *name)
{
    cmd_append(cmd, "clang", COMMON_CFLAGS, "-O2", "-fno-builtin", "--target=wasm32", "--no-standard-libraries", "-Wl,--no-entry", "-Wl,--export=vc_render", "-Wl,--export=__heap_base", "-Wl,--allow-undefined", "-o", temp_sprintf("./build/demos/%s.wasm", name), "-DVC_PLATFORM=VC_WASM_PLATFORM", temp_sprintf("./demos/%s.c", name));
    return cmd_run(cmd, .async = procs);
}

bool build_term_demo(Cmd *cmd, Procs *procs, const char *name)
{
    cmd_append(cmd, "clang", COMMON_CFLAGS, "-O2", "-o", temp_sprintf("./build/demos/%s.term", name), "-DVC_PLATFORM=VC_TERM_PLATFORM", "-D_XOPEN_SOURCE=600", temp_sprintf("./demos/%s.c", name), "-lm");
    return cmd_run(cmd, .async = procs);
}

bool build_sdl_demo(Cmd *cmd, Procs *procs, const char *name)
{
    cmd_append(cmd, "clang", COMMON_CFLAGS, "-O2", "-o", temp_sprintf("./build/demos/%s.sdl", name), "-DVC_PLATFORM=VC_SDL_PLATFORM", temp_sprintf("./demos/%s.c", name), "-lm", "-lSDL2", NULL);
    return cmd_run(cmd, .async = procs);
}

bool build_vc_demo(Cmd *cmd, Procs *procs, const char *name)
{
    if (!build_wasm_demo(cmd, procs, name)) return false;
    if (!build_term_demo(cmd, procs, name)) return false;
    if (!build_sdl_demo(cmd, procs, name))  return false;
    return true;
}

const char *vc_demo_names[] = {
    "triangle",
    "dots3d",
    "squish",
    "triangle3d",
    "triangleTex",
    "triangle3dTex",
    "cup3d",
    "teapot3d",
    "penger3d",
};

bool copy_all_vc_demos_to_build(void)
{
    for (size_t i = 0; i < ARRAY_LEN(vc_demo_names); ++i) {
        const char *src_path = temp_sprintf("./build/demos/%s.wasm", vc_demo_names[i]);
        const char *dst_path = temp_sprintf("./wasm/%s.wasm", vc_demo_names[i]);
        if (!copy_file(src_path, dst_path)) return false;
    }
    return true;
}

bool build_all_vc_demos(Cmd *cmd, Procs *procs)
{
    if (!mkdir_if_not_exists("build")) return false;
    if (!mkdir_if_not_exists("build/demos")) return false;

    for (size_t i = 0; i < ARRAY_LEN(vc_demo_names); ++i) {
        if (!build_vc_demo(cmd, procs, vc_demo_names[i])) return false;
    }

    return true;
}

void usage(const char *program)
{
    nob_log(INFO, "Usage: %s [<subcommand>]", program);
    nob_log(INFO, "Subcommands:");
    nob_log(INFO, "    tools");
    nob_log(INFO, "        Build all the tools. Things like png2c, obj2c, etc.");
    nob_log(INFO, "    assets");
    nob_log(INFO, "        Build the assets in the assets/ folder.");
    nob_log(INFO, "        Basically convert their data to C code so we can bake them in demos.");
    nob_log(INFO, "    test[s] [<args>]");
    nob_log(INFO, "        Build and run test.c");
    nob_log(INFO, "        If <args> are provided the test utility is run with them.");
    nob_log(INFO, "    demos [<platform>] [run]");
    nob_log(INFO, "        Build demos.");
    nob_log(INFO, "        Available platforms are: sdl, term, or wasm.");
    nob_log(INFO, "        Optional [run] runs the demo after the build.");
    nob_log(INFO, "        [run] is not available for wasm platform.");
    nob_log(INFO, "    help");
    nob_log(INFO, "         Print this message");
}

int main(int argc, char **argv)
{
    NOB_GO_REBUILD_URSELF(argc, argv);

    Cmd cmd = {0};
    Procs procs = {0};

    const char *program = shift_args(&argc, &argv);

    if (argc > 0) {
        const char *subcmd = shift_args(&argc, &argv);
        if (strcmp(subcmd, "tools") == 0) {
            if (!build_tools(&cmd, &procs)) return 1;
            if (!procs_flush(&procs)) return 1;
        } else if (strcmp(subcmd, "assets") == 0) {
            if (!build_assets(&cmd, &procs)) return 1;
            if (!procs_flush(&procs)) return 1;
        } else if (strcmp(subcmd, "tests") == 0 || strcmp(subcmd, "test") == 0) {
            if (!build_tests(&cmd, &procs)) return 1;
            if (!procs_flush(&procs)) return 1;
            if (argc > 0) {
                cmd_append(&cmd, "./build/test");
                da_append_many(&cmd, argv, argc);
                if (!cmd_run(&cmd)) return 1;
            }
        } else if (strcmp(subcmd, "demos") == 0) {
            if (argc <= 0) {
                if (!build_all_vc_demos(&cmd, &procs)) return 1;
                if (!procs_flush(&procs));
                return 0;
            }

            const char *name = shift(argv, argc);
            if (argc <= 0) {
                if (build_vc_demo(&cmd, &procs, name)) return 1;
                if (!procs_flush(&procs)) return 1;
                const char *src_path = temp_sprintf("./build/demos/%s.wasm", name);
                const char *dst_path = temp_sprintf("./wasm/%s.wasm", name);
                if (!copy_file(src_path, dst_path)) return 1;
                return 0;
            }

            const char *platform = shift(argv, argc);
            if (strcmp(platform, "sdl") == 0) {
                if (!build_sdl_demo(&cmd, &procs, name)) return 1;
                if (!procs_flush(&procs)) return 1;
                if (argc <= 0) return 0;
                const char *run = shift(argv, argc);
                if (strcmp(run, "run") != 0) {
                    usage(program);
                    nob_log(ERROR, "unknown action `%s` for SDL demo: %s", run, name);
                    return 1;
                }
                cmd_append(&cmd, temp_sprintf("./build/demos/%s.sdl", name));
                if (!cmd_run(&cmd)) return 1;
                return 0;
            } else if (strcmp(platform, "term") == 0) {
                if (!build_term_demo(&cmd, &procs, name)) return 1;
                if (!procs_flush(&procs)) return 1;
                if (argc <= 0) return 0;
                const char *run = shift(argv, argc);
                if (strcmp(run, "run") != 0) {
                    usage(program);
                    nob_log(ERROR, "unknown action `%s` for Terminal demo: %s", run, name);
                    return 1;
                }
                cmd_append(&cmd, temp_sprintf("./build/demos/%s.term", name));
                if (!cmd_run(&cmd)) return 1;
                return 0;
            } else if (strcmp(platform, "wasm") == 0) {
                if (!build_wasm_demo(&cmd, &procs, name)) return 1;
                if (!procs_flush(&procs)) return 1;
                const char *src_path = temp_sprintf("./build/demos/%s.wasm", name);
                const char *dst_path = temp_sprintf("./wasm/%s.wasm", name);
                if (!copy_file(src_path, dst_path)) return 1;
            } else {
                usage(program);
                nob_log(ERROR, "unknown demo platform %s", platform);
                return 1;
            }
        } else if(strcmp(subcmd, "help") == 0) {
            usage(program);
        } else {
            usage(program);
            nob_log(ERROR, "Unknown command `%s`", subcmd);
            return 1;
        }
    } else {
        if (!build_tools(&cmd, &procs)) return 1;
        if (!procs_flush(&procs)) return 1;

        if (!build_assets(&cmd, &procs)) return 1;
        if (!procs_flush(&procs)) return 1;

        if (!build_tests(&cmd, &procs)) return 1;
        if (!procs_flush(&procs)) return 1;

        if (!build_all_vc_demos(&cmd, &procs)) return 1;
        if (!procs_flush(&procs)) return 1;

        if (!copy_all_vc_demos_to_build()) return 1;
    }

    return 0;
}

```

`olive.c`:

```c
// Copyright 2022 Alexey Kutepov <reximkut@gmail.com>
//
// Permission is hereby granted, free of charge, to any person obtaining
// a copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to
// permit persons to whom the Software is furnished to do so, subject to
// the following conditions:
//
// The above copyright notice and this permission notice shall be
// included in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

#ifndef OLIVE_C_
#define OLIVE_C_

#include <stddef.h>
#include <stdint.h>
#include <stdbool.h>

#ifndef OLIVECDEF
#define OLIVECDEF static inline
#endif

#ifndef OLIVEC_AA_RES
#define OLIVEC_AA_RES 2
#endif

#define OLIVEC_SWAP(T, a, b) do { T t = a; a = b; b = t; } while (0)
#define OLIVEC_SIGN(T, x) ((T)((x) > 0) - (T)((x) < 0))
#define OLIVEC_ABS(T, x) (OLIVEC_SIGN(T, x)*(x))

typedef struct {
    size_t width, height;
    const char *glyphs;
} Olivec_Font;

#define OLIVEC_DEFAULT_FONT_HEIGHT 6
#define OLIVEC_DEFAULT_FONT_WIDTH 6
// TODO: allocate proper descender and acender areas for the default font
static char olivec_default_glyphs[128][OLIVEC_DEFAULT_FONT_HEIGHT][OLIVEC_DEFAULT_FONT_WIDTH] = {
    ['a'] = {
        {0, 0, 0, 0, 0},
        {0, 1, 1, 0, 0},
        {0, 0, 0, 1, 0},
        {0, 1, 1, 1, 0},
        {1, 0, 0, 1, 0},
        {0, 1, 1, 1, 0},
    },
    ['b'] = {
        {1, 0, 0, 0, 0},
        {1, 1, 1, 0, 0},
        {1, 0, 0, 1, 0},
        {1, 0, 0, 1, 0},
        {1, 0, 0, 1, 0},
        {1, 1, 1, 0, 0},
    },
    ['c'] = {
        {0, 0, 0, 0, 0},
        {0, 1, 1, 0, 0},
        {1, 0, 0, 1, 0},
        {1, 0, 0, 0, 0},
        {1, 0, 0, 1, 0},
        {0, 1, 1, 0, 0},
    },
    ['d'] = {
        {0, 0, 0, 1, 0},
        {0, 1, 1, 1, 0},
        {1, 0, 0, 1, 0},
        {1, 0, 0, 1, 0},
        {1, 0, 0, 1, 0},
        {0, 1, 1, 1, 0},
    },
    ['e'] = {
        {0, 0, 0, 0, 0},
        {0, 1, 1, 0, 0},
        {1, 0, 0, 1, 0},
        {1, 1, 1, 1, 0},
        {1, 0, 0, 0, 0},
        {0, 1, 1, 1, 0},
    },
    ['f'] = {
        {0, 0, 1, 1, 0},
        {0, 1, 0, 0, 0},
        {1, 1, 1, 1, 0},
        {0, 1, 0, 0, 0},
        {0, 1, 0, 0, 0},
        {0, 1, 0, 0, 0},
    },
    ['g'] = {
        {0, 1, 1, 1, 0},
        {1, 0, 0, 1, 0},
        {1, 0, 0, 1, 0},
        {0, 1, 1, 1, 0},
        {0, 0, 0, 1, 0},
        {0, 1, 1, 0, 0},
    },
    ['h'] = {
        {1, 0, 0, 0, 0},
        {1, 1, 1, 0, 0},
        {1, 0, 0, 1, 0},
        {1, 0, 0, 1, 0},
        {1, 0, 0, 1, 0},
        {1, 0, 0, 1, 0},
    },
    ['i'] = {
        {0, 0, 1, 0, 0},
        {0, 0, 0, 0, 0},
        {0, 0, 1, 0, 0},
        {0, 0, 1, 0, 0},
        {0, 0, 1, 0, 0},
        {0, 0, 1, 0, 0},
    },
    ['j'] = {
        {0, 0, 1, 0, 0},
        {0, 0, 0, 0, 0},
        {0, 0, 1, 0, 0},
        {0, 0, 1, 0, 0},
        {1, 0, 1, 0, 0},
        {0, 1, 1, 0, 0},
    },
    ['k'] = {
        {1, 0, 0, 0, 0},
        {1, 0, 0, 1, 0},
        {1, 0, 1, 0, 0},
        {1, 1, 0, 0, 0},
        {1, 0, 1, 0, 0},
        {1, 0, 0, 1, 0},
    },
    ['l'] = {
        {0, 1, 1, 0, 0},
        {0, 0, 1, 0, 0},
        {0, 0, 1, 0, 0},
        {0, 0, 1, 0, 0},
        {0, 0, 1, 0, 0},
        {0, 1, 1, 1, 0},
    },
    ['m'] = {
        {0, 0, 0, 0, 0},
        {0, 1, 0, 1, 1},
        {1, 0, 1, 0, 1},
        {1, 0, 1, 0, 1},
        {1, 0, 1, 0, 1},
        {1, 0, 1, 0, 1},
    },
    ['n'] = {
        {0, 0, 0, 0, 0},
        {0, 1, 1, 1, 0},
        {1, 0, 0, 1, 0},
        {1, 0, 0, 1, 0},
        {1, 0, 0, 1, 0},
        {1, 0, 0, 1, 0},
    },
    ['o'] = {
        {0, 0, 0, 0, 0},
        {0, 1, 1, 0, 0},
        {1, 0, 0, 1, 0},
        {1, 0, 0, 1, 0},
        {1, 0, 0, 1, 0},
        {0, 1, 1, 0, 0},
    },
    ['p'] = {
        {1, 1, 1, 0, 0},
        {1, 0, 0, 1, 0},
        {1, 0, 0, 1, 0},
        {1, 1, 1, 0, 0},
        {1, 0, 0, 0, 0},
        {1, 0, 0, 0, 0},
    },
    ['q'] = {
        {0, 1, 1, 1, 0},
        {1, 0, 0, 1, 0},
        {1, 0, 0, 1, 0},
        {0, 1, 1, 1, 0},
        {0, 0, 0, 1, 0},
        {0, 0, 0, 1, 0},
    },
    ['r'] = {
        {0, 0, 0, 0, 0},
        {1, 0, 1, 1, 0},
        {1, 1, 0, 0, 1},
        {1, 0, 0, 0, 0},
        {1, 0, 0, 0, 0},
        {1, 0, 0, 0, 0},
    },
    ['s'] = {
        {0, 0, 0, 0, 0},
        {0, 1, 1, 1, 0},
        {1, 0, 0, 0, 0},
        {1, 1, 1, 1, 0},
        {0, 0, 0, 1, 0},
        {1, 1, 1, 0, 0},
    },
    ['t'] = {
        {0, 1, 0, 0, 0},
        {0, 1, 0, 0, 0},
        {1, 1, 1, 1, 0},
        {0, 1, 0, 0, 0},
        {0, 1, 0, 1, 0},
        {0, 1, 1, 0, 0},
    },
    ['u'] = {
        {0, 0, 0, 0, 0},
        {1, 0, 0, 1, 0},
        {1, 0, 0, 1, 0},
        {1, 0, 0, 1, 0},
        {1, 0, 0, 1, 0},
        {0, 1, 1, 1, 0},
    },
    ['v'] = {
        {0, 0, 0, 0, 0},
        {1, 0, 0, 1, 0},
        {1, 0, 0, 1, 0},
        {1, 0, 0, 1, 0},
        {1, 0, 0, 1, 0},
        {0, 1, 1, 0, 0},
    },
    ['w'] = {
        {0, 0, 0, 0, 0},
        {1, 0, 0, 0, 1},
        {1, 0, 1, 0, 1},
        {1, 0, 1, 0, 1},
        {1, 0, 1, 0, 1},
        {0, 1, 1, 1, 1},
    },
    ['x'] = {
        {0, 0, 0, 0, 0},
        {1, 0, 1, 0, 0},
        {1, 0, 1, 0, 0},
        {0, 1, 0, 0, 0},
        {1, 0, 1, 0, 0},
        {1, 0, 1, 0, 0},
    },
    ['y'] = {
        {0, 0, 0, 0, 0},
        {1, 0, 1, 0, 0},
        {1, 0, 1, 0, 0},
        {1, 0, 1, 0, 0},
        {0, 1, 0, 0, 0},
        {0, 1, 0, 0, 0},
    },
    ['z'] = {
        {0, 0, 0, 0, 0},
        {1, 1, 1, 1, 0},
        {0, 0, 0, 1, 0},
        {0, 1, 1, 0, 0},
        {1, 0, 0, 0, 0},
        {1, 1, 1, 1, 0},
    },

    ['A'] = {0},
    ['B'] = {0},
    ['C'] = {0},
    ['D'] = {0},
    ['E'] = {0},
    ['F'] = {0},
    ['G'] = {0},
    ['H'] = {0},
    ['I'] = {0},
    ['J'] = {0},
    ['K'] = {0},
    ['L'] = {0},
    ['M'] = {0},
    ['N'] = {0},
    ['O'] = {0},
    ['P'] = {0},
    ['Q'] = {0},
    ['R'] = {0},
    ['S'] = {0},
    ['T'] = {0},
    ['U'] = {0},
    ['V'] = {0},
    ['W'] = {0},
    ['X'] = {0},
    ['Y'] = {0},
    ['Z'] = {0},

    ['0'] = {
        {0, 1, 1, 0, 0},
        {1, 0, 0, 1, 0},
        {1, 0, 0, 1, 0},
        {1, 0, 0, 1, 0},
        {1, 0, 0, 1, 0},
        {0, 1, 1, 0, 0},
    },
    ['1'] = {
        {0, 0, 1, 0, 0},
        {0, 1, 1, 0, 0},
        {0, 0, 1, 0, 0},
        {0, 0, 1, 0, 0},
        {0, 0, 1, 0, 0},
        {0, 1, 1, 1, 0},
    },
    ['2'] = {
        {0, 1, 1, 0, 0},
        {1, 0, 0, 1, 0},
        {0, 0, 0, 1, 0},
        {0, 1, 1, 0, 0},
        {1, 0, 0, 0, 0},
        {1, 1, 1, 1, 0},
    },
    ['3'] = {
        {0, 1, 1, 0, 0},
        {1, 0, 0, 1, 0},
        {0, 0, 1, 0, 0},
        {0, 0, 0, 1, 0},
        {1, 0, 0, 1, 0},
        {0, 1, 1, 0, 0},
    },
    ['4'] = {
        {0, 0, 1, 1, 0},
        {0, 1, 0, 1, 0},
        {1, 0, 0, 1, 0},
        {1, 1, 1, 1, 1},
        {0, 0, 0, 1, 0},
        {0, 0, 0, 1, 0},
    },
    ['5'] = {
        {1, 1, 1, 0, 0},
        {1, 0, 0, 0, 0},
        {1, 1, 1, 0, 0},
        {0, 0, 0, 1, 0},
        {1, 0, 0, 1, 0},
        {0, 1, 1, 0, 0},
    },
    ['6'] = {
        {0, 1, 1, 0, 0},
        {1, 0, 0, 0, 0},
        {1, 1, 1, 0, 0},
        {1, 0, 0, 1, 0},
        {1, 0, 0, 1, 0},
        {0, 1, 1, 0, 0},
    },
    ['7'] = {
        {1, 1, 1, 1, 0},
        {0, 0, 0, 1, 0},
        {0, 0, 1, 0, 0},
        {0, 1, 0, 0, 0},
        {0, 1, 0, 0, 0},
        {0, 1, 0, 0, 0},
    },
    ['8'] = {
        {0, 1, 1, 0, 0},
        {1, 0, 0, 1, 0},
        {0, 1, 1, 0, 0},
        {1, 0, 0, 1, 0},
        {1, 0, 0, 1, 0},
        {0, 1, 1, 0, 0},

    },
    ['9'] = {
        {0, 1, 1, 0, 0},
        {1, 0, 0, 1, 0},
        {1, 0, 0, 1, 0},
        {0, 1, 1, 1, 0},
        {0, 0, 0, 1, 0},
        {0, 1, 1, 0, 0},
    },

    [','] = {
        {0, 0, 0, 0, 0},
        {0, 0, 0, 0, 0},
        {0, 0, 0, 0, 0},
        {0, 0, 0, 0, 0},
        {0, 0, 0, 1, 0},
        {0, 0, 1, 0, 0},
    },

    ['.'] = {
        {0, 0, 0, 0, 0},
        {0, 0, 0, 0, 0},
        {0, 0, 0, 0, 0},
        {0, 0, 0, 0, 0},
        {0, 0, 0, 0, 0},
        {0, 0, 1, 0, 0},
    },
    ['-'] = {
        {0, 0, 0, 0, 0},
        {0, 0, 0, 0, 0},
        {0, 0, 0, 0, 0},
        {1, 1, 1, 1, 0},
        {0, 0, 0, 0, 0},
        {0, 0, 0, 0, 0},
    },
};

static Olivec_Font olivec_default_font = {
    .glyphs = &olivec_default_glyphs[0][0][0],
    .width = OLIVEC_DEFAULT_FONT_WIDTH,
    .height = OLIVEC_DEFAULT_FONT_HEIGHT,
};

// WARNING! Always initialize your Canvas with a color that has Non-Zero Alpha Channel!
// A lot of functions use `olivec_blend_color()` function to blend with the Background
// which preserves the original Alpha of the Background. So you may easily end up with
// a result that is perceptually transparent if the Alpha is Zero.
typedef struct {
    uint32_t *pixels;
    size_t width;
    size_t height;
    size_t stride;
} Olivec_Canvas;

#define OLIVEC_CANVAS_NULL ((Olivec_Canvas) {0})
#define OLIVEC_PIXEL(oc, x, y) (oc).pixels[(y)*(oc).stride + (x)]

OLIVECDEF Olivec_Canvas olivec_canvas(uint32_t *pixels, size_t width, size_t height, size_t stride);
OLIVECDEF Olivec_Canvas olivec_subcanvas(Olivec_Canvas oc, int x, int y, int w, int h);
OLIVECDEF bool olivec_in_bounds(Olivec_Canvas oc, int x, int y);
OLIVECDEF void olivec_blend_color(uint32_t *c1, uint32_t c2);
OLIVECDEF void olivec_fill(Olivec_Canvas oc, uint32_t color);
OLIVECDEF void olivec_rect(Olivec_Canvas oc, int x, int y, int w, int h, uint32_t color);
OLIVECDEF void olivec_frame(Olivec_Canvas oc, int x, int y, int w, int h, size_t thiccness, uint32_t color);
OLIVECDEF void olivec_circle(Olivec_Canvas oc, int cx, int cy, int r, uint32_t color);
OLIVECDEF void olivec_ellipse(Olivec_Canvas oc, int cx, int cy, int rx, int ry, uint32_t color);
// TODO: lines with different thiccness
OLIVECDEF void olivec_line(Olivec_Canvas oc, int x1, int y1, int x2, int y2, uint32_t color);
OLIVECDEF bool olivec_normalize_triangle(size_t width, size_t height, int x1, int y1, int x2, int y2, int x3, int y3, int *lx, int *hx, int *ly, int *hy);
OLIVECDEF bool olivec_barycentric(int x1, int y1, int x2, int y2, int x3, int y3, int xp, int yp, int *u1, int *u2, int *det);
OLIVECDEF void olivec_triangle(Olivec_Canvas oc, int x1, int y1, int x2, int y2, int x3, int y3, uint32_t color);
OLIVECDEF void olivec_triangle3c(Olivec_Canvas oc, int x1, int y1, int x2, int y2, int x3, int y3, uint32_t c1, uint32_t c2, uint32_t c3);
OLIVECDEF void olivec_triangle3z(Olivec_Canvas oc, int x1, int y1, int x2, int y2, int x3, int y3, float z1, float z2, float z3);
OLIVECDEF void olivec_triangle3uv(Olivec_Canvas oc, int x1, int y1, int x2, int y2, int x3, int y3, float tx1, float ty1, float tx2, float ty2, float tx3, float ty3, float z1, float z2, float z3, Olivec_Canvas texture);
OLIVECDEF void olivec_triangle3uv_bilinear(Olivec_Canvas oc, int x1, int y1, int x2, int y2, int x3, int y3, float tx1, float ty1, float tx2, float ty2, float tx3, float ty3, float z1, float z2, float z3, Olivec_Canvas texture);
OLIVECDEF void olivec_text(Olivec_Canvas oc, const char *text, int x, int y, Olivec_Font font, size_t size, uint32_t color);
OLIVECDEF void olivec_sprite_blend(Olivec_Canvas oc, int x, int y, int w, int h, Olivec_Canvas sprite);
OLIVECDEF void olivec_sprite_copy(Olivec_Canvas oc, int x, int y, int w, int h, Olivec_Canvas sprite);
OLIVECDEF void olivec_sprite_copy_bilinear(Olivec_Canvas oc, int x, int y, int w, int h, Olivec_Canvas sprite);
OLIVECDEF uint32_t olivec_pixel_bilinear(Olivec_Canvas sprite, int nx, int ny, int w, int h);

typedef struct {
    // Safe ranges to iterate over.
    int x1, x2;
    int y1, y2;

    // Original uncut ranges some parts of which may be outside of the canvas boundaries.
    int ox1, ox2;
    int oy1, oy2;
} Olivec_Normalized_Rect;

// The point of this function is to produce two ranges x1..x2 and y1..y2 that are guaranteed to be safe to iterate over the canvas of size pixels_width by pixels_height without any boundary checks.
//
// Olivec_Normalized_Rect nr = {0};
// if (olivec_normalize_rect(x, y, w, h, WIDTH, HEIGHT, &nr)) {
//     for (int x = nr.x1; x <= nr.x2; ++x) {
//         for (int y = nr.y1; y <= nr.y2; ++y) {
//             OLIVEC_PIXEL(oc, x, y) = 0x69696969;
//         }
//     }
// } else {
//     // Rectangle is invisible cause it's completely out-of-bounds
// }
OLIVECDEF bool olivec_normalize_rect(int x, int y, int w, int h,
                                     size_t canvas_width, size_t canvas_height,
                                     Olivec_Normalized_Rect *nr);

#endif // OLIVE_C_

#ifdef OLIVEC_IMPLEMENTATION

OLIVECDEF Olivec_Canvas olivec_canvas(uint32_t *pixels, size_t width, size_t height, size_t stride)
{
    Olivec_Canvas oc = {
        .pixels = pixels,
        .width  = width,
        .height = height,
        .stride = stride,
    };
    return oc;
}

OLIVECDEF bool olivec_normalize_rect(int x, int y, int w, int h,
                                     size_t canvas_width, size_t canvas_height,
                                     Olivec_Normalized_Rect *nr)
{
    // No need to render empty rectangle
    if (w == 0) return false;
    if (h == 0) return false;

    nr->ox1 = x;
    nr->oy1 = y;

    // Convert the rectangle to 2-points representation
    nr->ox2 = nr->ox1 + OLIVEC_SIGN(int, w)*(OLIVEC_ABS(int, w) - 1);
    if (nr->ox1 > nr->ox2) OLIVEC_SWAP(int, nr->ox1, nr->ox2);
    nr->oy2 = nr->oy1 + OLIVEC_SIGN(int, h)*(OLIVEC_ABS(int, h) - 1);
    if (nr->oy1 > nr->oy2) OLIVEC_SWAP(int, nr->oy1, nr->oy2);

    // Cull out invisible rectangle
    if (nr->ox1 >= (int) canvas_width) return false;
    if (nr->ox2 < 0) return false;
    if (nr->oy1 >= (int) canvas_height) return false;
    if (nr->oy2 < 0) return false;

    nr->x1 = nr->ox1;
    nr->y1 = nr->oy1;
    nr->x2 = nr->ox2;
    nr->y2 = nr->oy2;

    // Clamp the rectangle to the boundaries
    if (nr->x1 < 0) nr->x1 = 0;
    if (nr->x2 >= (int) canvas_width) nr->x2 = (int) canvas_width - 1;
    if (nr->y1 < 0) nr->y1 = 0;
    if (nr->y2 >= (int) canvas_height) nr->y2 = (int) canvas_height - 1;

    return true;
}

OLIVECDEF Olivec_Canvas olivec_subcanvas(Olivec_Canvas oc, int x, int y, int w, int h)
{
    Olivec_Normalized_Rect nr = {0};
    if (!olivec_normalize_rect(x, y, w, h, oc.width, oc.height, &nr)) return OLIVEC_CANVAS_NULL;
    oc.pixels = &OLIVEC_PIXEL(oc, nr.x1, nr.y1);
    oc.width = nr.x2 - nr.x1 + 1;
    oc.height = nr.y2 - nr.y1 + 1;
    return oc;
}

// TODO: custom pixel formats
// Maybe we can store pixel format info in Olivec_Canvas
#define OLIVEC_RED(color)   (((color)&0x000000FF)>>(8*0))
#define OLIVEC_GREEN(color) (((color)&0x0000FF00)>>(8*1))
#define OLIVEC_BLUE(color)  (((color)&0x00FF0000)>>(8*2))
#define OLIVEC_ALPHA(color) (((color)&0xFF000000)>>(8*3))
#define OLIVEC_RGBA(r, g, b, a) ((((r)&0xFF)<<(8*0)) | (((g)&0xFF)<<(8*1)) | (((b)&0xFF)<<(8*2)) | (((a)&0xFF)<<(8*3)))

OLIVECDEF void olivec_blend_color(uint32_t *c1, uint32_t c2)
{
    uint32_t r1 = OLIVEC_RED(*c1);
    uint32_t g1 = OLIVEC_GREEN(*c1);
    uint32_t b1 = OLIVEC_BLUE(*c1);
    uint32_t a1 = OLIVEC_ALPHA(*c1);

    uint32_t r2 = OLIVEC_RED(c2);
    uint32_t g2 = OLIVEC_GREEN(c2);
    uint32_t b2 = OLIVEC_BLUE(c2);
    uint32_t a2 = OLIVEC_ALPHA(c2);

    r1 = (r1*(255 - a2) + r2*a2)/255; if (r1 > 255) r1 = 255;
    g1 = (g1*(255 - a2) + g2*a2)/255; if (g1 > 255) g1 = 255;
    b1 = (b1*(255 - a2) + b2*a2)/255; if (b1 > 255) b1 = 255;

    *c1 = OLIVEC_RGBA(r1, g1, b1, a1);
}

OLIVECDEF void olivec_fill(Olivec_Canvas oc, uint32_t color)
{
    for (size_t y = 0; y < oc.height; ++y) {
        for (size_t x = 0; x < oc.width; ++x) {
            OLIVEC_PIXEL(oc, x, y) = color;
        }
    }
}

OLIVECDEF void olivec_rect(Olivec_Canvas oc, int x, int y, int w, int h, uint32_t color)
{
    Olivec_Normalized_Rect nr = {0};
    if (!olivec_normalize_rect(x, y, w, h, oc.width, oc.height, &nr)) return;
    for (int x = nr.x1; x <= nr.x2; ++x) {
        for (int y = nr.y1; y <= nr.y2; ++y) {
            olivec_blend_color(&OLIVEC_PIXEL(oc, x, y), color);
        }
    }
}

OLIVECDEF void olivec_frame(Olivec_Canvas oc, int x, int y, int w, int h, size_t t, uint32_t color)
{
    if (t == 0) return; // Nothing to render

    // Convert the rectangle to 2-points representation
    int x1 = x;
    int y1 = y;
    int x2 = x1 + OLIVEC_SIGN(int, w)*(OLIVEC_ABS(int, w) - 1);
    if (x1 > x2) OLIVEC_SWAP(int, x1, x2);
    int y2 = y1 + OLIVEC_SIGN(int, h)*(OLIVEC_ABS(int, h) - 1);
    if (y1 > y2) OLIVEC_SWAP(int, y1, y2);

    olivec_rect(oc, x1 - t/2, y1 - t/2, (x2 - x1 + 1) + t/2*2, t, color);  // Top
    olivec_rect(oc, x1 - t/2, y1 - t/2, t, (y2 - y1 + 1) + t/2*2, color);  // Left
    olivec_rect(oc, x1 - t/2, y2 + t/2, (x2 - x1 + 1) + t/2*2, -t, color); // Bottom
    olivec_rect(oc, x2 + t/2, y1 - t/2, -t, (y2 - y1 + 1) + t/2*2, color); // Right
}

OLIVECDEF void olivec_ellipse(Olivec_Canvas oc, int cx, int cy, int rx, int ry, uint32_t color)
{
    Olivec_Normalized_Rect nr = {0};
    int rx1 = rx + OLIVEC_SIGN(int, rx);
    int ry1 = ry + OLIVEC_SIGN(int, ry);
    if (!olivec_normalize_rect(cx - rx1, cy - ry1, 2*rx1, 2*ry1, oc.width, oc.height, &nr)) return;

    for (int y = nr.y1; y <= nr.y2; ++y) {
        for (int x = nr.x1; x <= nr.x2; ++x) {
            float nx = (x + 0.5 - nr.x1)/(2.0f*rx1);
            float ny = (y + 0.5 - nr.y1)/(2.0f*ry1);
            float dx = nx - 0.5;
            float dy = ny - 0.5;
            if (dx*dx + dy*dy <= 0.5*0.5) {
                OLIVEC_PIXEL(oc, x, y) = color;
            }
        }
    }
}

OLIVECDEF void olivec_circle(Olivec_Canvas oc, int cx, int cy, int r, uint32_t color)
{
    Olivec_Normalized_Rect nr = {0};
    int r1 = r + OLIVEC_SIGN(int, r);
    if (!olivec_normalize_rect(cx - r1, cy - r1, 2*r1, 2*r1, oc.width, oc.height, &nr)) return;

    for (int y = nr.y1; y <= nr.y2; ++y) {
        for (int x = nr.x1; x <= nr.x2; ++x) {
            int count = 0;
            for (int sox = 0; sox < OLIVEC_AA_RES; ++sox) {
                for (int soy = 0; soy < OLIVEC_AA_RES; ++soy) {
                    // TODO: switch to 64 bits to make the overflow less likely
                    // Also research the probability of overflow
                    int res1 = (OLIVEC_AA_RES + 1);
                    int dx = (x*res1*2 + 2 + sox*2 - res1*cx*2 - res1);
                    int dy = (y*res1*2 + 2 + soy*2 - res1*cy*2 - res1);
                    if (dx*dx + dy*dy <= res1*res1*r*r*2*2) count += 1;
                }
            }
            uint32_t alpha = ((color&0xFF000000)>>(3*8))*count/OLIVEC_AA_RES/OLIVEC_AA_RES;
            uint32_t updated_color = (color&0x00FFFFFF)|(alpha<<(3*8));
            olivec_blend_color(&OLIVEC_PIXEL(oc, x, y), updated_color);
        }
    }
}

OLIVECDEF bool olivec_in_bounds(Olivec_Canvas oc, int x, int y)
{
    return 0 <= x && x < (int) oc.width && 0 <= y && y < (int) oc.height;
}

// TODO: AA for line
OLIVECDEF void olivec_line(Olivec_Canvas oc, int x1, int y1, int x2, int y2, uint32_t color)
{
    int dx = x2 - x1;
    int dy = y2 - y1;

    // If both of the differences are 0 there will be a division by 0 below.
    if (dx == 0 && dy == 0) {
        if (olivec_in_bounds(oc, x1, y1)) {
            olivec_blend_color(&OLIVEC_PIXEL(oc, x1, y1), color);
        }
        return;
    }

    if (OLIVEC_ABS(int, dx) > OLIVEC_ABS(int, dy)) {
        if (x1 > x2) {
            OLIVEC_SWAP(int, x1, x2);
            OLIVEC_SWAP(int, y1, y2);
        }

        for (int x = x1; x <= x2; ++x) {
            int y = dy*(x - x1)/dx + y1;
            // TODO: move boundary checks out side of the loops in olivec_draw_line
            if (olivec_in_bounds(oc, x, y)) {
                olivec_blend_color(&OLIVEC_PIXEL(oc, x, y), color);
            }
        }
    } else {
        if (y1 > y2) {
            OLIVEC_SWAP(int, x1, x2);
            OLIVEC_SWAP(int, y1, y2);
        }

        for (int y = y1; y <= y2; ++y) {
            int x = dx*(y - y1)/dy + x1;
            // TODO: move boundary checks out side of the loops in olivec_draw_line
            if (olivec_in_bounds(oc, x, y)) {
                olivec_blend_color(&OLIVEC_PIXEL(oc, x, y), color);
            }
        }
    }
}

OLIVECDEF uint32_t mix_colors2(uint32_t c1, uint32_t c2, int u1, int det)
{
    // TODO: estimate how much overflows are an issue in integer only environment
    int64_t r1 = OLIVEC_RED(c1);
    int64_t g1 = OLIVEC_GREEN(c1);
    int64_t b1 = OLIVEC_BLUE(c1);
    int64_t a1 = OLIVEC_ALPHA(c1);

    int64_t r2 = OLIVEC_RED(c2);
    int64_t g2 = OLIVEC_GREEN(c2);
    int64_t b2 = OLIVEC_BLUE(c2);
    int64_t a2 = OLIVEC_ALPHA(c2);

    if (det != 0) {
        int u2 = det - u1;
        int64_t r4 = (r1*u2 + r2*u1)/det;
        int64_t g4 = (g1*u2 + g2*u1)/det;
        int64_t b4 = (b1*u2 + b2*u1)/det;
        int64_t a4 = (a1*u2 + a2*u1)/det;

        return OLIVEC_RGBA(r4, g4, b4, a4);
    }

    return 0;
}

OLIVECDEF uint32_t mix_colors3(uint32_t c1, uint32_t c2, uint32_t c3, int u1, int u2, int det)
{
    // TODO: estimate how much overflows are an issue in integer only environment
    int64_t r1 = OLIVEC_RED(c1);
    int64_t g1 = OLIVEC_GREEN(c1);
    int64_t b1 = OLIVEC_BLUE(c1);
    int64_t a1 = OLIVEC_ALPHA(c1);

    int64_t r2 = OLIVEC_RED(c2);
    int64_t g2 = OLIVEC_GREEN(c2);
    int64_t b2 = OLIVEC_BLUE(c2);
    int64_t a2 = OLIVEC_ALPHA(c2);

    int64_t r3 = OLIVEC_RED(c3);
    int64_t g3 = OLIVEC_GREEN(c3);
    int64_t b3 = OLIVEC_BLUE(c3);
    int64_t a3 = OLIVEC_ALPHA(c3);

    if (det != 0) {
        int u3 = det - u1 - u2;
        int64_t r4 = (r1*u1 + r2*u2 + r3*u3)/det;
        int64_t g4 = (g1*u1 + g2*u2 + g3*u3)/det;
        int64_t b4 = (b1*u1 + b2*u2 + b3*u3)/det;
        int64_t a4 = (a1*u1 + a2*u2 + a3*u3)/det;

        return OLIVEC_RGBA(r4, g4, b4, a4);
    }

    return 0;
}

// NOTE: we imply u3 = det - u1 - u2
OLIVECDEF bool olivec_barycentric(int x1, int y1, int x2, int y2, int x3, int y3, int xp, int yp, int *u1, int *u2, int *det)
{
    *det = ((x1 - x3)*(y2 - y3) - (x2 - x3)*(y1 - y3));
    *u1  = ((y2 - y3)*(xp - x3) + (x3 - x2)*(yp - y3));
    *u2  = ((y3 - y1)*(xp - x3) + (x1 - x3)*(yp - y3));
    int u3 = *det - *u1 - *u2;
    return (
               (OLIVEC_SIGN(int, *u1) == OLIVEC_SIGN(int, *det) || *u1 == 0) &&
               (OLIVEC_SIGN(int, *u2) == OLIVEC_SIGN(int, *det) || *u2 == 0) &&
               (OLIVEC_SIGN(int, u3) == OLIVEC_SIGN(int, *det) || u3 == 0)
           );
}

OLIVECDEF bool olivec_normalize_triangle(size_t width, size_t height, int x1, int y1, int x2, int y2, int x3, int y3, int *lx, int *hx, int *ly, int *hy)
{
    *lx = x1;
    *hx = x1;
    if (*lx > x2) *lx = x2;
    if (*lx > x3) *lx = x3;
    if (*hx < x2) *hx = x2;
    if (*hx < x3) *hx = x3;
    if (*lx < 0) *lx = 0;
    if ((size_t) *lx >= width) return false;;
    if (*hx < 0) return false;;
    if ((size_t) *hx >= width) *hx = width-1;

    *ly = y1;
    *hy = y1;
    if (*ly > y2) *ly = y2;
    if (*ly > y3) *ly = y3;
    if (*hy < y2) *hy = y2;
    if (*hy < y3) *hy = y3;
    if (*ly < 0) *ly = 0;
    if ((size_t) *ly >= height) return false;;
    if (*hy < 0) return false;;
    if ((size_t) *hy >= height) *hy = height-1;

    return true;
}

OLIVECDEF void olivec_triangle3c(Olivec_Canvas oc, int x1, int y1, int x2, int y2, int x3, int y3,
                                 uint32_t c1, uint32_t c2, uint32_t c3)
{
    int lx, hx, ly, hy;
    if (olivec_normalize_triangle(oc.width, oc.height, x1, y1, x2, y2, x3, y3, &lx, &hx, &ly, &hy)) {
        for (int y = ly; y <= hy; ++y) {
            for (int x = lx; x <= hx; ++x) {
                int u1, u2, det;
                if (olivec_barycentric(x1, y1, x2, y2, x3, y3, x, y, &u1, &u2, &det)) {
                    olivec_blend_color(&OLIVEC_PIXEL(oc, x, y), mix_colors3(c1, c2, c3, u1, u2, det));
                }
            }
        }
    }
}

OLIVECDEF void olivec_triangle3z(Olivec_Canvas oc, int x1, int y1, int x2, int y2, int x3, int y3, float z1, float z2, float z3)
{
    int lx, hx, ly, hy;
    if (olivec_normalize_triangle(oc.width, oc.height, x1, y1, x2, y2, x3, y3, &lx, &hx, &ly, &hy)) {
        for (int y = ly; y <= hy; ++y) {
            for (int x = lx; x <= hx; ++x) {
                int u1, u2, det;
                if (olivec_barycentric(x1, y1, x2, y2, x3, y3, x, y, &u1, &u2, &det)) {
                    float z = z1*u1/det + z2*u2/det + z3*(det - u1 - u2)/det;
                    OLIVEC_PIXEL(oc, x, y) = *(uint32_t*)&z;
                }
            }
        }
    }
}

OLIVECDEF void olivec_triangle3uv(Olivec_Canvas oc, int x1, int y1, int x2, int y2, int x3, int y3, float tx1, float ty1, float tx2, float ty2, float tx3, float ty3, float z1, float z2, float z3, Olivec_Canvas texture)
{
    int lx, hx, ly, hy;
    if (olivec_normalize_triangle(oc.width, oc.height, x1, y1, x2, y2, x3, y3, &lx, &hx, &ly, &hy)) {
        for (int y = ly; y <= hy; ++y) {
            for (int x = lx; x <= hx; ++x) {
                int u1, u2, det;
                if (olivec_barycentric(x1, y1, x2, y2, x3, y3, x, y, &u1, &u2, &det)) {
                    int u3 = det - u1 - u2;
                    float z = z1*u1/det + z2*u2/det + z3*(det - u1 - u2)/det;
                    float tx = tx1*u1/det + tx2*u2/det + tx3*u3/det;
                    float ty = ty1*u1/det + ty2*u2/det + ty3*u3/det;

                    int texture_x = tx/z*texture.width;
                    if (texture_x < 0) texture_x = 0;
                    if ((size_t) texture_x >= texture.width) texture_x = texture.width - 1;

                    int texture_y = ty/z*texture.height;
                    if (texture_y < 0) texture_y = 0;
                    if ((size_t) texture_y >= texture.height) texture_y = texture.height - 1;
                    OLIVEC_PIXEL(oc, x, y) = OLIVEC_PIXEL(texture, (int)texture_x, (int)texture_y);
                }
            }
        }
    }
}

OLIVECDEF void olivec_triangle3uv_bilinear(Olivec_Canvas oc, int x1, int y1, int x2, int y2, int x3, int y3, float tx1, float ty1, float tx2, float ty2, float tx3, float ty3, float z1, float z2, float z3, Olivec_Canvas texture)
{
    int lx, hx, ly, hy;
    if (olivec_normalize_triangle(oc.width, oc.height, x1, y1, x2, y2, x3, y3, &lx, &hx, &ly, &hy)) {
        for (int y = ly; y <= hy; ++y) {
            for (int x = lx; x <= hx; ++x) {
                int u1, u2, det;
                if (olivec_barycentric(x1, y1, x2, y2, x3, y3, x, y, &u1, &u2, &det)) {
                    int u3 = det - u1 - u2;
                    float z = z1*u1/det + z2*u2/det + z3*(det - u1 - u2)/det;
                    float tx = tx1*u1/det + tx2*u2/det + tx3*u3/det;
                    float ty = ty1*u1/det + ty2*u2/det + ty3*u3/det;

                    float texture_x = tx/z*texture.width;
                    if (texture_x < 0) texture_x = 0;
                    if (texture_x >= (float) texture.width) texture_x = texture.width - 1;

                    float texture_y = ty/z*texture.height;
                    if (texture_y < 0) texture_y = 0;
                    if (texture_y >= (float) texture.height) texture_y = texture.height - 1;

                    int precision = 100;
                    OLIVEC_PIXEL(oc, x, y) = olivec_pixel_bilinear(
                                                 texture,
                                                 texture_x*precision, texture_y*precision,
                                                 precision, precision);
                }
            }
        }
    }
}

// TODO: AA for triangle
OLIVECDEF void olivec_triangle(Olivec_Canvas oc, int x1, int y1, int x2, int y2, int x3, int y3, uint32_t color)
{
    int lx, hx, ly, hy;
    if (olivec_normalize_triangle(oc.width, oc.height, x1, y1, x2, y2, x3, y3, &lx, &hx, &ly, &hy)) {
        for (int y = ly; y <= hy; ++y) {
            for (int x = lx; x <= hx; ++x) {
                int u1, u2, det;
                if (olivec_barycentric(x1, y1, x2, y2, x3, y3, x, y, &u1, &u2, &det)) {
                    olivec_blend_color(&OLIVEC_PIXEL(oc, x, y), color);
                }
            }
        }
    }
}

OLIVECDEF void olivec_text(Olivec_Canvas oc, const char *text, int tx, int ty, Olivec_Font font, size_t glyph_size, uint32_t color)
{
    for (size_t i = 0; *text; ++i, ++text) {
        int gx = tx + i*font.width*glyph_size;
        int gy = ty;
        const char *glyph = &font.glyphs[(*text)*sizeof(char)*font.width*font.height];
        for (int dy = 0; (size_t) dy < font.height; ++dy) {
            for (int dx = 0; (size_t) dx < font.width; ++dx) {
                int px = gx + dx*glyph_size;
                int py = gy + dy*glyph_size;
                if (0 <= px && px < (int) oc.width && 0 <= py && py < (int) oc.height) {
                    if (glyph[dy*font.width + dx]) {
                        olivec_rect(oc, px, py, glyph_size, glyph_size, color);
                    }
                }
            }
        }
    }
}

OLIVECDEF void olivec_sprite_blend(Olivec_Canvas oc, int x, int y, int w, int h, Olivec_Canvas sprite)
{
    if (sprite.width == 0) return;
    if (sprite.height == 0) return;

    Olivec_Normalized_Rect nr = {0};
    if (!olivec_normalize_rect(x, y, w, h, oc.width, oc.height, &nr)) return;

    int xa = nr.ox1;
    if (w < 0) xa = nr.ox2;
    int ya = nr.oy1;
    if (h < 0) ya = nr.oy2;
    for (int y = nr.y1; y <= nr.y2; ++y) {
        for (int x = nr.x1; x <= nr.x2; ++x) {
            size_t nx = (x - xa)*((int) sprite.width)/w;
            size_t ny = (y - ya)*((int) sprite.height)/h;
            olivec_blend_color(&OLIVEC_PIXEL(oc, x, y), OLIVEC_PIXEL(sprite, nx, ny));
        }
    }
}

OLIVECDEF void olivec_sprite_copy(Olivec_Canvas oc, int x, int y, int w, int h, Olivec_Canvas sprite)
{
    if (sprite.width == 0) return;
    if (sprite.height == 0) return;

    // TODO: consider introducing flip parameter instead of relying on negative width and height
    // Similar to how SDL_RenderCopyEx does that
    Olivec_Normalized_Rect nr = {0};
    if (!olivec_normalize_rect(x, y, w, h, oc.width, oc.height, &nr)) return;

    int xa = nr.ox1;
    if (w < 0) xa = nr.ox2;
    int ya = nr.oy1;
    if (h < 0) ya = nr.oy2;
    for (int y = nr.y1; y <= nr.y2; ++y) {
        for (int x = nr.x1; x <= nr.x2; ++x) {
            size_t nx = (x - xa)*((int) sprite.width)/w;
            size_t ny = (y - ya)*((int) sprite.height)/h;
            OLIVEC_PIXEL(oc, x, y) = OLIVEC_PIXEL(sprite, nx, ny);
        }
    }
}

// TODO: olivec_pixel_bilinear does not check for out-of-bounds
// But maybe it shouldn't. Maybe it's a responsibility of the caller of the function.
OLIVECDEF uint32_t olivec_pixel_bilinear(Olivec_Canvas sprite, int nx, int ny, int w, int h)
{
    int px = nx%w;
    int py = ny%h;

    int x1 = nx/w, x2 = nx/w;
    int y1 = ny/h, y2 = ny/h;
    if (px < w/2) {
        // left
        px += w/2;
        x1 -= 1;
        if (x1 < 0) x1 = 0;
    } else {
        // right
        px -= w/2;
        x2 += 1;
        if ((size_t) x2 >= sprite.width) x2 = sprite.width - 1;
    }

    if (py < h/2) {
        // top
        py += h/2;
        y1 -= 1;
        if (y1 < 0) y1 = 0;
    } else {
        // bottom
        py -= h/2;
        y2 += 1;
        if ((size_t) y2 >= sprite.height) y2 = sprite.height - 1;
    }

    return mix_colors2(mix_colors2(OLIVEC_PIXEL(sprite, x1, y1),
                                   OLIVEC_PIXEL(sprite, x2, y1),
                                   px, w),
                       mix_colors2(OLIVEC_PIXEL(sprite, x1, y2),
                                   OLIVEC_PIXEL(sprite, x2, y2),
                                   px, w),
                       py, h);
}

OLIVECDEF void olivec_sprite_copy_bilinear(Olivec_Canvas oc, int x, int y, int w, int h, Olivec_Canvas sprite)
{
    // TODO: support negative size in olivec_sprite_copy_bilinear()
    if (w <= 0) return;
    if (h <= 0) return;

    Olivec_Normalized_Rect nr = {0};
    if (!olivec_normalize_rect(x, y, w, h, oc.width, oc.height, &nr)) return;

    for (int y = nr.y1; y <= nr.y2; ++y) {
        for (int x = nr.x1; x <= nr.x2; ++x) {
            size_t nx = (x - nr.ox1)*sprite.width;
            size_t ny = (y - nr.oy1)*sprite.height;
            OLIVEC_PIXEL(oc, x, y) = olivec_pixel_bilinear(sprite, nx, ny, w, h);
        }
    }
}

#endif // OLIVEC_IMPLEMENTATION

// TODO: Benchmarking
// TODO: SIMD implementations
// TODO: bezier curves
// TODO: olivec_ring
// TODO: fuzzer
// TODO: Stencil

```

`test.c`:

```c
#include <stdio.h>
#include <stdlib.h>
#include <stdint.h>
#include <stdbool.h>
#include <string.h>
#include <errno.h>

#include "./assets/tsodinPog.c"
#include "./assets/tsodinCup.c"

#define NOB_IMPLEMENTATION
#define NOB_STRIP_PREFIX
#include "nob.h"

#define PI 3.14159265359

#define ARENA_IMPLEMENTATION
#include "./arena.h"

static Arena default_arena = {0};
static Arena *context_arena = &default_arena;

static void *context_alloc(size_t size)
{
    assert(context_arena);
    return arena_alloc(context_arena, size);
}

static void *context_realloc(void *oldp, size_t oldsz, size_t newsz)
{
    if (newsz <= oldsz) return oldp;
    return memcpy(context_alloc(newsz), oldp, oldsz);
}

#define STBI_MALLOC context_alloc
#define STBI_FREE UNUSED
#define STBI_REALLOC_SIZED context_realloc
#define STB_IMAGE_IMPLEMENTATION
#include "./stb_image.h"

#define STBIW_MALLOC STBI_MALLOC
#define STBIW_FREE STBI_FREE
#define STBIW_REALLOC_SIZED STBI_REALLOC_SIZED
#define STB_IMAGE_WRITE_IMPLEMENTATION
#include "./stb_image_write.h"

#define OLIVEC_IMPLEMENTATION
#include "olive.c"

#define BACKGROUND_COLOR 0xFF202020
#define FOREGROUND_COLOR 0xFF2020FF
#define WHITE_COLOR 0xFFAAAAAA
#define RED_COLOR 0xFF2020AA
#define GREEN_COLOR 0xFF20AA20
#define BLUE_COLOR 0xFFAA2020
#define ERROR_COLOR 0xFFFF00FF

#define TEST_DIR_PATH "./test"

bool canvas_stbi_load(const char *file_path, Olivec_Canvas *oc)
{
    int width, height;
    uint32_t *pixels = (uint32_t*) stbi_load(file_path, &width, &height, NULL, 4);
    if (pixels == NULL) return false;
    *oc = olivec_canvas(pixels, width, height, width);
    return true;
}

bool canvas_stbi_save(Olivec_Canvas oc, const char *file_path)
{
    return stbi_write_png(file_path, oc.width, oc.height, 4, oc.pixels, sizeof(uint32_t)*oc.stride);
}

typedef struct {
    Olivec_Canvas (*generate_actual_canvas)(void);
    const char *id;
    const char *expected_file_path;
    const char *actual_file_path;
    const char *diff_file_path;
} Test_Case;

#define DEFINE_TEST_CASE(name) \
    { \
        .generate_actual_canvas = test_##name, \
        .id = #name, \
        .expected_file_path = TEST_DIR_PATH "/" #name "_expected.png", \
        .actual_file_path = TEST_DIR_PATH "/" #name "_actual.png", \
        .diff_file_path = TEST_DIR_PATH "/" #name "_diff.png", \
    }

bool update_test_case(const Test_Case *tc)
{
    Olivec_Canvas actual_canvas = tc->generate_actual_canvas();
    const char *expected_file_path = tc->expected_file_path;

    if (!canvas_stbi_save(actual_canvas, expected_file_path)) {
        fprintf(stderr, "ERROR: could not write file %s: %s\n", expected_file_path, strerror(errno));
        return(false);
    }
    printf("%s: Generated %s\n", tc->id, expected_file_path);
    return(true);
}

Olivec_Canvas canvas_alloc(size_t width, size_t height)
{
    uint32_t *pixels = context_alloc(sizeof(uint32_t)*width*height);
    return olivec_canvas(pixels, width, height, width);
}

typedef enum {
    REPLAY_PASSED,
    REPLAY_FAILED,
    REPLAY_ERRORED,
} Replay_Result;

static inline size_t min_size(size_t a, size_t b)
{
    if (a < b) return a;
    return b;
}

static inline size_t max_size(size_t a, size_t b)
{
    if (a > b) return a;
    return b;
}

Replay_Result run_test_case(const char *program_path, const Test_Case *tc)
{
    printf("%s:", tc->id);
    fflush(stdout);

    const char *expected_file_path = tc->expected_file_path;
    const char *actual_file_path = tc->actual_file_path;
    const char *diff_file_path = tc->diff_file_path;

    Olivec_Canvas actual_canvas = tc->generate_actual_canvas();

    Olivec_Canvas expected_canvas;
    if (!canvas_stbi_load(expected_file_path, &expected_canvas)) {
        fprintf(stderr, "\n");
        fprintf(stderr, "  ERROR: could not read %s: %s\n", expected_file_path, stbi_failure_reason());
        if (errno == ENOENT) {
            fprintf(stderr, "  HINT: Consider running `$ %s update %s` to create it\n", program_path, tc->id);
        }
        return(REPLAY_ERRORED);
    }

    bool failed = false;

    if (expected_canvas.width != actual_canvas.width || expected_canvas.height != actual_canvas.height) {
        failed = true;
    }

    Olivec_Canvas diff_canvas =
        canvas_alloc(
            max_size(expected_canvas.width, actual_canvas.width),
            max_size(expected_canvas.height, actual_canvas.height));
    olivec_fill(diff_canvas, ERROR_COLOR);

    for (size_t y = 0; y < min_size(expected_canvas.height, actual_canvas.height); ++y) {
        for (size_t x = 0; x < min_size(expected_canvas.width, actual_canvas.width); ++x) {
            uint32_t expected_pixel = OLIVEC_PIXEL(expected_canvas, x, y);
            uint32_t actual_pixel = OLIVEC_PIXEL(actual_canvas, x, y);
            if (expected_pixel != actual_pixel) {
                OLIVEC_PIXEL(diff_canvas, x, y) = ERROR_COLOR;
                failed = true;
            } else {
                OLIVEC_PIXEL(diff_canvas, x, y) = expected_pixel;
            }
        }
    }

    if (failed) {
        fprintf(stderr, "\n");

        if (!canvas_stbi_save(actual_canvas, actual_file_path)) {
            fprintf(stderr, "  ERROR: could not write image file with actual pixels %s: %s\n", actual_file_path, strerror(errno));
            return(REPLAY_ERRORED);
        }

        if (!canvas_stbi_save(diff_canvas, diff_file_path)) {
            fprintf(stderr, "  ERROR: could not wrilte diff image file %s: %s\n", diff_file_path, strerror(errno));
            return(REPLAY_ERRORED);
        }

        fprintf(stderr, "  TEST FAILURE: unexpected pixels in generated image\n");
        fprintf(stderr, "    Expected: %s\n", expected_file_path);
        fprintf(stderr, "    Actual:   %s\n", actual_file_path);
        fprintf(stderr, "    Diff:     %s\n", diff_file_path);
        fprintf(stderr, "  HINT: If this behaviour is intentional confirm that by updating the image with `$ %s update`\n", program_path);
        return(REPLAY_FAILED);
    }

    printf(" OK\n");

    return(REPLAY_PASSED);
}

Olivec_Canvas test_fill_rect(void)
{
    size_t width = 128;
    size_t height = 128;
    Olivec_Canvas oc = canvas_alloc(width, height);
    olivec_fill(oc, BACKGROUND_COLOR);
    olivec_rect(oc, width/2 - width/8, height/2 - height/8, width/4, height/4, RED_COLOR);
    olivec_rect(oc, width - 1, height - 1, -width/2, -height/2, GREEN_COLOR);
    olivec_rect(oc, -width/4, -height/4, width/2, height/2, BLUE_COLOR);
    return oc;
}

Olivec_Canvas test_fill_circle(void)
{
    size_t width = 128;
    size_t height = 128;
    Olivec_Canvas oc = canvas_alloc(width, height);
    olivec_fill(oc, BACKGROUND_COLOR);
    olivec_circle(oc, 0, 0, width/2, RED_COLOR);
    olivec_circle(oc, width/2, height/2, width/4, BLUE_COLOR);
    olivec_circle(oc, width*3/4, height*3/4, -width/4, GREEN_COLOR);
    return oc;
}

Olivec_Canvas test_draw_line(void)
{
    size_t width = 128;
    size_t height = 128;
    Olivec_Canvas oc = canvas_alloc(width, height);
    olivec_fill(oc, BACKGROUND_COLOR);
    olivec_line(oc, 0, 0, width, height, RED_COLOR);
    olivec_line(oc, width, 0, 0, height, BLUE_COLOR);
    olivec_line(oc, width/2, 0, width/2, height, GREEN_COLOR);
    return oc;
}

Olivec_Canvas test_fill_triangle(void)
{
    size_t width = 128;
    size_t height = 128;
    Olivec_Canvas oc = canvas_alloc(width, height);

    olivec_fill(oc, BACKGROUND_COLOR);

    {
        int x1 = width/2,   y1 = height/8;
        int x2 = width/8,   y2 = height/2;
        int x3 = width*7/8, y3 = height*7/8;
        olivec_triangle(oc, x1, y1, x2, y2, x3, y3, RED_COLOR);
    }

    {
        int x1 = width/2,   y1 = height*2/8;
        int x2 = width*2/8, y2 = height/2;
        int x3 = width*6/8, y3 = height/2;
        olivec_triangle(oc, x1, y1, x2, y2, x3, y3, GREEN_COLOR);
    }

    {
        int x1 = width/8,   y1 = height/8;
        int x2 = width/8,   y2 = height*3/8;
        int x3 = width*3/8, y3 = height*3/8;
        olivec_triangle(oc, x1, y1, x2, y2, x3, y3, BLUE_COLOR);
    }

    return oc;
}

Olivec_Canvas test_alpha_blending(void)
{
    size_t width = 128;
    size_t height = 128;
    Olivec_Canvas oc = canvas_alloc(width, height);
    olivec_fill(oc, BACKGROUND_COLOR);
    olivec_rect(oc, 0, 0, width*3/4, height*3/4, RED_COLOR);
    olivec_rect(oc, width-1, height-1, -width*3/4, -height*3/4, 0x5520AA20);
    olivec_circle(oc, width/2, height/2, width/4, 0xBBAA2020);
    olivec_triangle(oc, 0, height-1, width-1, height-1, width/2, 0, 0xBB20AAAA);
    olivec_triangle3c(oc, 0, 0, width-1, 0, width/2, height-1, 0xBB2020AA, 0xBB20AA20, 0xBBAA2020);
    return oc;
}

Olivec_Canvas test_checker_example(void)
{
    int width = 800/2;
    int height = 600/2;
    int cols = (8*2);
    int rows = (6*2);
    int cell_width = (width/cols);
    int cell_height = (height/rows);
    Olivec_Canvas oc = canvas_alloc(width, height);

    olivec_fill(oc, BACKGROUND_COLOR);

    for (int y = 0; y < rows; ++y) {
        for (int x = 0; x < cols; ++x) {
            uint32_t color = BACKGROUND_COLOR;
            if ((x + y)%2 == 0) {
                color = 0xFF2020FF;
            }
            olivec_rect(oc, x*cell_width, y*cell_height, cell_width, cell_height, color);
        }
    }

    return oc;
}

Olivec_Canvas test_circle_example(void)
{
    int width = 800/2;
    int height = 600/2;
    int cols = (8*2);
    int rows = (6*2);
    int cell_width = (width/cols);
    int cell_height = (height/rows);
    Olivec_Canvas oc = canvas_alloc(width, height);
    olivec_fill(oc, BACKGROUND_COLOR);

    for (int y = 0; y < rows; ++y) {
        for (int x = 0; x < cols; ++x) {
            float u = (float)x/cols;
            float v = (float)y/rows;
            float t = (u + v)/2;

            int radius = cell_width;
            if (cell_height < radius) radius = cell_height;

            olivec_circle(oc,
                          x*cell_width + cell_width/2, y*cell_height + cell_height/2,
                          (size_t) (radius/8*(1 - t) + radius/2*t),
                          FOREGROUND_COLOR);
        }
    }

    return oc;
}

Olivec_Canvas test_lines_circle(void)
{
    int width = 800/2;
    int height = 600/2;
    Olivec_Canvas oc = canvas_alloc(width, height);
    olivec_fill(oc, BACKGROUND_COLOR);

    size_t n = 20;
    float angle = 2*PI/n;
    float length = width;
    if (length > height) length = height;
    length /= 3;
    float x1 = width/2;
    float y1 = height/2;
    for (size_t i = 0; i < n; ++i) {
        float x2 = x1 + cosf(angle*i)*length;
        float y2 = y1 + sinf(angle*i)*length;
        olivec_line(oc, x1, y1, x2, y2, 0xFF1818FF);
    }

    return oc;
}

Olivec_Canvas test_lines_example(void)
{
    int width = 800/2;
    int height = 600/2;
    Olivec_Canvas oc = canvas_alloc(width, height);

    olivec_fill(oc, BACKGROUND_COLOR);
    olivec_line(oc, 0, 0, width, height, FOREGROUND_COLOR);
    olivec_line(oc, width, 0, 0, height, FOREGROUND_COLOR);
    olivec_line(oc, 0, 0, width/4, height, 0xFF20FF20);
    olivec_line(oc, width/4, 0, 0, height, 0xFF20FF20);
    olivec_line(oc, width, 0, width/4*3, height, 0xFF20FF20);
    olivec_line(oc, width/4*3, 0, width, height, 0xFF20FF20);
    olivec_line(oc, 0, height/2, width, height/2, 0xFFFF3030);
    olivec_line(oc, width/2, 0, width/2, height, 0xFFFF3030);

    return oc;
}

Olivec_Canvas test_hello_world_text_rendering(void)
{
    size_t size = 5;
    const char *text = "hello, world";
    size_t text_len = strlen(text);
    Olivec_Canvas oc = canvas_alloc(400, 150);
    olivec_fill(oc, BACKGROUND_COLOR);
    olivec_text(oc, text, oc.width/2 - OLIVEC_DEFAULT_FONT_WIDTH*size*text_len/2, oc.height/2 - OLIVEC_DEFAULT_FONT_HEIGHT*size/2, olivec_default_font, size, FOREGROUND_COLOR);
    return oc;
}

Olivec_Canvas test_line_edge_cases(void)
{
    size_t width = 10;
    size_t height = 10;
    Olivec_Canvas oc = canvas_alloc(width, height);
    olivec_fill(oc, BACKGROUND_COLOR);
    // One pixel line
    olivec_line(oc, width/2, height/2, width/2, height/2, FOREGROUND_COLOR);
    // Out-of-bounds horizontally
    olivec_line(oc, width + 10, height/2, width + 20, height/2, FOREGROUND_COLOR);
    // Out-of-bounds vertically
    olivec_line(oc, width/2, height + 10, width/2, height + 20, FOREGROUND_COLOR);
    return oc;
}

Olivec_Canvas test_frame(void)
{
    size_t width = 256;
    size_t height = 128;
    Olivec_Canvas oc = canvas_alloc(width, height);
    olivec_fill(oc, BACKGROUND_COLOR);

    {
        size_t w = width/2;
        size_t h = height/2;
        olivec_frame(oc, 0, 0, w, h, 1, RED_COLOR);
    }

    {
        olivec_frame(oc, width/2, height/2, width, height, 1, GREEN_COLOR);
    }

    // Odd thiccness
    {
        size_t w = width/2;
        size_t h = height/2;
        size_t t = 5;
        olivec_frame(oc, width/2 - w/2, height/2 - h/2, w, h, t, WHITE_COLOR);
        olivec_frame(oc, width/2 - w/2, height/2 - h/2, w, h, 1, RED_COLOR);
    }

    // Even thiccness
    {
        size_t w = width/4 + 1;
        size_t h = height/4;
        size_t t = 6;
        olivec_frame(oc, width/2 - w/2, height/2 - h/2, w, h, t, WHITE_COLOR);
        olivec_frame(oc, width/2 - w/2, height/2 - h/2, w, h, 1, RED_COLOR);
    }

    // Zero thiccness
    {
        size_t w = width/8;
        size_t h = height/8;
        size_t t = 0;
        olivec_frame(oc, width/2 - w/2, height/2 - h/2, w, h, t, WHITE_COLOR);
    }

    return oc;
}

Olivec_Canvas test_sprite_blend(void)
{
    size_t width = 128;
    size_t height = 128;
    Olivec_Canvas dst = canvas_alloc(width, height);
    olivec_fill(dst, RED_COLOR);
    Olivec_Canvas src = canvas_alloc(width, height);

    for (size_t y = 0; y < src.height; ++y) {
        for (size_t x = 0; x < src.width; ++x) {
            if ((x + y)%2 == 0) {
                OLIVEC_PIXEL(src, x, y) = 0;
            } else {
                OLIVEC_PIXEL(src, x, y) = GREEN_COLOR;
            }
        }
    }

    olivec_sprite_blend(dst, 0, 0, width, height, src);

    return dst;
}

Olivec_Canvas test_sprite_blend_out_of_bounds_cut(void)
{
    size_t width = 128;
    size_t height = 128;
    Olivec_Canvas dst = canvas_alloc(width, height);
    Olivec_Canvas src = olivec_canvas(tsodinPog_pixels, tsodinPog_width, tsodinPog_height, tsodinPog_width);
    olivec_fill(dst, RED_COLOR);
    olivec_sprite_blend(dst, -width/2, -height/2, width, height, src);
    olivec_sprite_blend(dst, width/2, -height/2, width, height, src);
    olivec_sprite_blend(dst, -width/2, height/2, width, height, src);
    olivec_sprite_blend(dst, width/2, height/2, width, height, src);
    return dst;
}

Olivec_Canvas test_sprite_blend_flip(void)
{
    size_t width = 128;
    size_t height = 128;
    Olivec_Canvas dst = canvas_alloc(width, height);
    Olivec_Canvas src = olivec_canvas(tsodinPog_pixels, tsodinPog_width, tsodinPog_height, tsodinPog_width);
    olivec_fill(dst, RED_COLOR);
    olivec_sprite_blend(dst, 0, 0, width/2, height/2, src);
    olivec_sprite_blend(dst, width - 1, 0, -width/2, height/2, src);
    olivec_sprite_blend(dst, 0, height - 1, width/2, -height/2, src);
    olivec_sprite_blend(dst, width - 1, height - 1, -width/2, -height/2, src);
    return dst;
}

Olivec_Canvas test_sprite_blend_flip_cut(void)
{
    size_t width = 128;
    size_t height = 128;
    Olivec_Canvas dst = canvas_alloc(width, height);
    Olivec_Canvas src = olivec_canvas(tsodinPog_pixels, tsodinPog_width, tsodinPog_height, tsodinPog_width);
    olivec_fill(dst, RED_COLOR);
    olivec_sprite_blend(dst, -width/2, -height/2, width, height, src);
    olivec_sprite_blend(dst, width - 1 + width/2, -height/2, -width, height, src);
    olivec_sprite_blend(dst, -width/2, height - 1 + height/2, width, -height, src);
    olivec_sprite_blend(dst, width - 1 + width/2, height - 1 + height/2, -width, -height, src);
    return dst;
}

Olivec_Canvas test_empty_rect(void)
{
    size_t w = 8;
    size_t h = 8;
    Olivec_Canvas dst = canvas_alloc(w, h);
    olivec_fill(dst, BACKGROUND_COLOR);
    olivec_rect(dst, w/2, h/2, 0, 0, FOREGROUND_COLOR);
    return dst;
}

Olivec_Canvas test_sprite_blend_empty_rect(void)
{
    size_t w = 8;
    size_t h = 8;
    Olivec_Canvas dst = canvas_alloc(w, h);
    Olivec_Canvas src = olivec_canvas(tsodinPog_pixels, tsodinPog_width, tsodinPog_height, tsodinPog_width);
    olivec_fill(dst, BACKGROUND_COLOR);
    olivec_sprite_blend(dst, 0, 0, 0, 0, src);
    return dst;
}

Olivec_Canvas test_sprite_blend_null(void)
{
    size_t w = 8;
    size_t h = 8;
    Olivec_Canvas dst = canvas_alloc(w, h);
    olivec_fill(dst, BACKGROUND_COLOR);
    olivec_sprite_blend(dst, 0, 0, w, h, OLIVEC_CANVAS_NULL);
    return dst;
}

Olivec_Canvas test_sprite_blend_vs_copy(void)
{
    Olivec_Canvas tsodinCup = olivec_canvas(tsodinCup_pixels, tsodinCup_width, tsodinCup_height, tsodinCup_width);
    size_t w = tsodinCup.width;
    size_t h = tsodinCup.height*2;
    Olivec_Canvas dst = canvas_alloc(w, h);
    olivec_fill(dst, RED_COLOR);
    olivec_sprite_blend(dst, 0, 0, tsodinCup.width, tsodinCup.height, tsodinCup);
    olivec_sprite_copy(dst, 0, tsodinCup.height, tsodinCup.width, tsodinCup.height, tsodinCup);
    return dst;
}

Olivec_Canvas test_barycentric_overflow(void)
{
    size_t w = 256;
    size_t h = 256;
    Olivec_Canvas dst = canvas_alloc(w, h);
    olivec_fill(dst, 0xFF181818);
    olivec_triangle3c(dst, w/4, h/4, w/2, 0, 0, h, 0xFF0000FF, 0xFF00FF00, 0xFFFF0000);
    return dst;
}

Olivec_Canvas test_triangle_order_flip(void)
{
    size_t w = 256;
    size_t h = 256;
    Olivec_Canvas dst = canvas_alloc(w, h);
    olivec_fill(dst, 0xFF181818);
    olivec_triangle3c(
        dst,
        w/4, h/4,
        0, h,
        w, 0,
        0xFF00FF00,
        0xFFFF0000,
        0xFF0000FF);
    return dst;
}

Olivec_Canvas test_bilinear_interpolation(void)
{
    size_t factor = 2;
    Olivec_Canvas src = olivec_canvas(tsodinPog_pixels, tsodinPog_width, tsodinPog_height, tsodinPog_width);
    Olivec_Canvas dst = canvas_alloc(src.width*factor*2, src.height*factor);
    olivec_fill(dst, RED_COLOR);
    olivec_sprite_copy(dst, 0, 0, src.width*factor, src.height*factor, src);
    olivec_sprite_copy_bilinear(dst, src.width*factor, 0, src.width*factor, src.height*factor, src);
    return dst;
}

Olivec_Canvas test_fill_ellipse(void)
{
    size_t factor = 3;
    Olivec_Canvas dst = canvas_alloc(100*factor, 50*factor);
    olivec_fill(dst, BACKGROUND_COLOR);
    olivec_ellipse(dst, dst.width/2, dst.height/2, dst.width/3, dst.height/3, RED_COLOR);
    return dst;
}

Olivec_Canvas test_line_bug_offset(void)
{
    size_t factor = 3;
    size_t width = 100*factor;
    size_t height = 50*factor;
    Olivec_Canvas dst = canvas_alloc(width, height);
    olivec_fill(dst, BACKGROUND_COLOR);
    int x1 = 50;
    int y1 = 100;
    int x2 = 0;
    int y2 = -100;
    olivec_line(dst, x1, y1, x2, y2, GREEN_COLOR);
    olivec_circle(dst, x1, y1, 5, RED_COLOR);
    return dst;
}

Test_Case test_cases[] = {
    DEFINE_TEST_CASE(fill_rect),
    DEFINE_TEST_CASE(fill_circle),
    DEFINE_TEST_CASE(draw_line),
    DEFINE_TEST_CASE(fill_triangle),
    DEFINE_TEST_CASE(alpha_blending),
    DEFINE_TEST_CASE(checker_example),
    DEFINE_TEST_CASE(circle_example),
    DEFINE_TEST_CASE(lines_example),
    DEFINE_TEST_CASE(hello_world_text_rendering),
    DEFINE_TEST_CASE(lines_circle),
    DEFINE_TEST_CASE(line_edge_cases),
    DEFINE_TEST_CASE(frame),
    DEFINE_TEST_CASE(sprite_blend),
    DEFINE_TEST_CASE(sprite_blend_out_of_bounds_cut),
    DEFINE_TEST_CASE(sprite_blend_flip),
    DEFINE_TEST_CASE(sprite_blend_flip_cut),
    DEFINE_TEST_CASE(sprite_blend_empty_rect),
    DEFINE_TEST_CASE(empty_rect),
    DEFINE_TEST_CASE(sprite_blend_null),
    DEFINE_TEST_CASE(sprite_blend_vs_copy),
    DEFINE_TEST_CASE(triangle_order_flip),
    DEFINE_TEST_CASE(barycentric_overflow),
    DEFINE_TEST_CASE(bilinear_interpolation),
    DEFINE_TEST_CASE(fill_ellipse),
    DEFINE_TEST_CASE(line_bug_offset),
};
#define TEST_CASES_COUNT (sizeof(test_cases)/sizeof(test_cases[0]))

void list_available_tests(void)
{
    fprintf(stderr, "Available tests:\n");
    for (size_t i = 0; i < TEST_CASES_COUNT; ++i) {
        fprintf(stderr, "    %s\n", test_cases[i].id);
    }
}

Test_Case *find_test_case_by_id(const char *id)
{
    for (size_t i = 0; i < TEST_CASES_COUNT; ++i) {
        if (strcmp(test_cases[i].id, id) == 0) {
            return &test_cases[i];
        }
    }
    return NULL;
}
typedef struct {
    int (*run)(const char *program_path, int argc, char **argv);
    const char *id;
    const char *description;
} Subcmd;

void usage(const char *program_path);

int subcmd_run(const char *program_path, int argc, char **argv)
{
    if (argc <= 0) {
        for (size_t i = 0; i < TEST_CASES_COUNT; ++i) {
            if (run_test_case(program_path, &test_cases[i]) == REPLAY_ERRORED) return(1);
            arena_reset(&default_arena);
        }
    } else {
        const char *test_case_id = shift(argv, argc);
        Test_Case *tc = find_test_case_by_id(test_case_id);
        if (tc == NULL) {
            list_available_tests();
            fprintf(stderr, "ERROR: could not find test case `%s`\n", test_case_id);
            return(1);
        }

        if (run_test_case(program_path, tc) == REPLAY_ERRORED) return(1);
    }

    return 0;
}

int subcmd_update(const char *program_path, int argc, char **argv)
{
    UNUSED(program_path);

    if (argc <= 0) {
        for (size_t i = 0; i < TEST_CASES_COUNT; ++i) {
            if (!update_test_case(&test_cases[i])) return(1);
            arena_reset(&default_arena);
        }
    } else {
        const char *test_case_id = shift(argv, argc);
        Test_Case *tc = find_test_case_by_id(test_case_id);
        if (tc == NULL) {
            list_available_tests();
            fprintf(stderr, "ERROR: could not find test case `%s`\n", test_case_id);
            return(1);
        }

        if (!update_test_case(tc)) return(1);
    }

    return 0;
}

int subcmd_list(const char *program_path, int argc, char **argv)
{
    UNUSED(program_path);
    UNUSED(argc);
    UNUSED(argv);
    list_available_tests();
    return 0;
}

int subcmd_help(const char *program_path, int argc, char **argv)
{
    UNUSED(argc);
    UNUSED(argv);
    usage(program_path);
    return 0;
}

#define DEFINE_SUBCMD(name, desc) \
    { \
        .run = subcmd_##name, \
        .id = #name, \
        .description = desc, \
    }

Subcmd subcmds[] = {
    DEFINE_SUBCMD(run, "Run the tests"),
    DEFINE_SUBCMD(update, "Update the tests"),
    DEFINE_SUBCMD(list, "List all available tests"),
    DEFINE_SUBCMD(help, "Print this help message"),
};
#define SUBCMDS_COUNT (sizeof(subcmds)/sizeof(subcmds[0]))

Subcmd *find_subcmd_by_id(const char *id)
{
    for (size_t i = 0; i < SUBCMDS_COUNT; ++i) {
        if (strcmp(subcmds[i].id, id) == 0) {
            return &subcmds[i];
        }
    }
    return NULL;
}

void usage(const char *program_path)
{
    fprintf(stderr, "Usage: %s [Subcommand]\n", program_path);
    fprintf(stderr, "Subcommands:\n");

    int width = 0;
    for (size_t i = 0; i < SUBCMDS_COUNT; ++i) {
        int len = strlen(subcmds[i].id);
        if (width < len) width = len;
    }

    for (size_t i = 0; i < SUBCMDS_COUNT; ++i) {
        fprintf(stderr, "    %-*s - %s\n", width, subcmds[i].id, subcmds[i].description);
    }
}

int main(int argc, char **argv)
{
    int result = 0;

    {
        const char *program_path = shift(argv, argc);

        if (argc <= 0) {
            usage(program_path);
            fprintf(stderr, "ERROR: no subcommand is provided\n");
            return_defer(1);
        }

        const char *subcmd_id = shift(argv, argc);
        Subcmd *subcmd = find_subcmd_by_id(subcmd_id);
        if (subcmd != NULL) {
            return_defer(subcmd->run(program_path, argc, argv));
        } else {
            usage(program_path);
            fprintf(stderr, "ERROR: unknown subcommand `%s`\n", subcmd_id);
            return_defer(1);
        }
    }

defer:
    arena_free(&default_arena);
    return result;
}

```

`tools/obj2c.c`:

```c
#include <assert.h>
#include <stdio.h>
#include <errno.h>
#include <float.h>
#include <limits.h>
#include <string.h>

#define NOB_IMPLEMENTATION
#define NOB_STRIP_PREFIX
#include "nob.h"

typedef struct {
    float x, y;
} Vector2;

Vector2 make_vector2(float x, float y)
{
    Vector2 v2;
    v2.x = x;
    v2.y = y;
    return v2;
}

typedef struct {
    float x, y, z;
} Vector3;

Vector3 make_vector3(float x, float y, float z)
{
    Vector3 v3;
    v3.x = x;
    v3.y = y;
    v3.z = z;
    return v3;
}

typedef struct {
    int *items;
    size_t capacity;
    size_t count;
} Face_Indices;

typedef struct {
    int *items;
    size_t capacity;
    size_t count;
} Vertex_Indices;

typedef struct {
    Vector3 position;
    Face_Indices faces;
    int component;              // 0 means never visited, >0 is the index of the component vertex belongs to
} Vertex;

Vertex make_vertex(float x, float y, float z)
{
    return (Vertex) {
        .position = make_vector3(x, y, z),
    };
}

typedef struct {
    Vertex *items;
    size_t capacity;
    size_t count;
} Vertices;

#define VERTICES_PER_FACE 3

typedef struct {
    int v[VERTICES_PER_FACE];
    int vt[VERTICES_PER_FACE];
    int vn[VERTICES_PER_FACE];
} Face;

Face make_face(int v1, int v2, int v3, int vt1, int vt2, int vt3, int vn1, int vn2, int vn3)
{
    static_assert(VERTICES_PER_FACE == 3, "");
    Face f = {
        .v  = {v1, v2, v3},
        .vt = {vt1, vt2, vt3},
        .vn = {vn1, vn2, vn3},
    };
    return f;
}

typedef struct {
    Face *items;
    size_t capacity;
    size_t count;
} Faces;

typedef struct {
    Vector3 *items;
    size_t capacity;
    size_t count;
} Normals;

typedef struct {
    Vector2 *items;
    size_t capacity;
    size_t count;
} TexCoords;

typedef struct {
    int *items;
    size_t count;
    size_t capacity;
} Component_Indices;

bool is_deleted_face(Vertices vertices, Face face, Component_Indices delete_components)
{
    for (size_t i = 0; i < VERTICES_PER_FACE; ++i) {
        // TODO: @perf if this is too slow due to too many deleted components you can always just pre-sort the indices and do a binary search
        for (size_t j = 0; j < delete_components.count; ++j) {
            if (vertices.items[face.v[i]].component == delete_components.items[j]) {
                return true;
            }
        }
    }
    return false;
}

void generate_code(FILE *out, Vertices vertices, TexCoords texcoords, Normals normals, Faces faces, Component_Indices delete_components)
{
    fprintf(out, "#ifndef OBJ_H_\n");
    fprintf(out, "#define OBJ_H_\n");
    fprintf(out, "#define vertices_count %zu\n", vertices.count);
    if (vertices.count == 0) {
        fprintf(out, "static const float vertices[1][3] = {0};\n");
    } else {
        fprintf(out, "static const float vertices[][3] = {\n");
        for (size_t i = 0; i < vertices.count; ++i) {
            Vector3 v = vertices.items[i].position;
            fprintf(out, "    {%f, %f, %f},\n", v.x, v.y, v.z);
        }
        fprintf(out, "};\n");
    }

    fprintf(out, "#define texcoords_count %zu\n", texcoords.count);
    if (texcoords.count == 0) {
        fprintf(out, "static const float texcoords[1][3] = {0};\n");
    } else {
        fprintf(out, "static const float texcoords[][3] = {\n");
        for (size_t i = 0; i < texcoords.count; ++i) {
            Vector2 vt = texcoords.items[i];
            fprintf(out, "    {%f, %f},\n", vt.x, vt.y);
        }
        fprintf(out, "};\n");
    }

    fprintf(out, "#define normals_count %zu\n", normals.count);
    if (normals.count == 0) {
        fprintf(out, "static const float normals[1][3] = {0};\n");
    } else {
        fprintf(out, "static const float normals[][3] = {\n");
        for (size_t i = 0; i < normals.count; ++i) {
            Vector3 vn = normals.items[i];
            fprintf(out, "    {%f, %f, %f},\n", vn.x, vn.y, vn.z);
        }
        fprintf(out, "};\n");
    }

    size_t visible_faces_count = 0;
    for (size_t i = 0; i < faces.count; ++i) {
        if (!is_deleted_face(vertices, faces.items[i], delete_components)) {
            visible_faces_count += 1;
        }
    }

    fprintf(out, "#define faces_count %zu\n", visible_faces_count);
    if (visible_faces_count == 0) {
        fprintf(out, "static const int faces[1][9] = {0};\n");
    } else {
        fprintf(out, "static const int faces[%zu][9] = {\n", visible_faces_count);
        for (size_t i = 0; i < faces.count; ++i) {
            if (!is_deleted_face(vertices, faces.items[i], delete_components)) {
                Face f = faces.items[i];
                fprintf(out, "    {%d, %d, %d, %d, %d, %d, %d, %d, %d},\n", f.v[0], f.v[1], f.v[2], f.vt[0], f.vt[1], f.vt[2], f.vn[0], f.vn[1], f.vn[2]);
            }
        }
        fprintf(out, "};\n");
    }
    fprintf(out, "#endif // OBJ_H_\n");
}

Vector3 remap_object(Vector3 v, float scale, float lx, float hx, float ly, float hy, float lz, float hz)
{
    float cx = lx + (hx - lx)/2;
    float cy = ly + (hy - ly)/2;
    float cz = lz + (hz - lz)/2;
    v.z = (v.z - cz)*scale;
    v.x = (v.x - cx)*scale;
    v.y = (v.y - cy)*scale;
    return v;
}

void usage(const char *program_name)
{
    fprintf(stderr, "Usage: %s [OPTIONS] <INPUT.obj>\n", program_name);
    fprintf(stderr, "Options:\n");
    fprintf(stderr, "    -o    output file path\n");
    fprintf(stderr, "    -s    scale the model\n");
}

void parse_face_triple(String_View *line, int *lf, int *hf, int *v, int *vt, int *vn)
{
    char *endptr;

    *line = sv_trim_left(*line);
    *v = strtol(line->data, &endptr, 10) - 1; // NOTE: -1 is to account for 1-based indexing.
    if (*lf > *v) *lf = *v;
    if (*hf < *v) *hf = *v;
    sv_chop_left(line, endptr - line->data);
    *vt = 0;
    if (line->count > 0 && line->data[0] == '/') {
        sv_chop_left(line, 1);
        *vt = strtol(line->data, &endptr, 10) - 1; // NOTE: -1 is to account for 1-based indexing.
        sv_chop_left(line, endptr - line->data);
    }
    *vn = 0;
    if (line->count > 0 && line->data[0] == '/') {
        sv_chop_left(line, 1);
        *vn = strtol(line->data, &endptr, 10) - 1; // NOTE: -1 is to account for 1-based indexing.
        sv_chop_left(line, endptr - line->data);
    }
    while (line->count > 0 && !isspace(*line->data)) sv_chop_left(line, 1);
}

int unvisited_vertex(Vertices vertices)
{
    for (size_t i = 0; i < vertices.count; ++i) {
        if (!vertices.items[i].component) {
            return (int)i;
        }
    }
    return -1;
}

int main(int argc, char **argv)
{
    int result = 0;

    assert(argc > 0);
    const char *program_name = shift(argv, argc);
    const char *output_file_path = NULL;
    const char *input_file_path = NULL;
    float scale = 0.75;
    Component_Indices delete_components = {0};

    // TODO: consider using https://github.com/tsoding/flag.h in here
    while (argc > 0) {
        const char *flag = shift(argv, argc);
        if (strcmp(flag, "-o") == 0) {
            if (argc <= 0) {
                usage(program_name);
                fprintf(stderr, "ERROR: no value is provided for flag %s\n", flag);
                return_defer(1);
            }

            if (output_file_path != NULL) {
                usage(program_name);
                fprintf(stderr, "ERROR: %s was already provided\n", flag);
                return_defer(1);
            }

            output_file_path = shift(argv, argc);
        } else if (strcmp(flag, "-s") == 0) {
            if (argc <= 0) {
                usage(program_name);
                fprintf(stderr, "ERROR: no value is provided for flag %s\n", flag);
                return_defer(1);
            }

            const char *value = shift(argv, argc);
            scale = strtof(value, NULL);
        } else if (strcmp(flag, "-d") == 0) {
            if (argc <= 0) {
                usage(program_name);
                fprintf(stderr, "ERROR: no value is provided for flag %s\n", flag);
                return_defer(1);
            }

            const char *value = shift(argv, argc);
            da_append(&delete_components, atoi(value));
        } else {
            if (input_file_path != NULL) {
                usage(program_name);
                fprintf(stderr, "ERROR: input file path was already provided\n");
                return_defer(1);
            }
            input_file_path = flag;
        }
    }

    if (input_file_path == NULL) {
        usage(program_name);
        fprintf(stderr, "ERROR: no input file path is provided\n");
        return_defer(1);
    }

    if (output_file_path == NULL) {
        usage(program_name);
        fprintf(stderr, "ERROR: no output file path is provided\n");
        return_defer(1);
    }

    String_Builder buffer = {0};
    if (!read_entire_file(input_file_path, &buffer)) return_defer(1);

    String_View content = sb_to_sv(buffer);
    Vertices vertices = {0};
    TexCoords texcoords = {0};
    Normals normals = {0};
    Faces faces = {0};
    float lx = FLT_MAX, hx = FLT_MIN;
    float ly = FLT_MAX, hy = FLT_MIN;
    float lz = FLT_MAX, hz = FLT_MIN;
    int lf = INT_MAX, hf = INT_MIN;
    bool one_object_encountered = false;
    size_t one_object_line_number = 0;
    for (size_t line_number = 1; content.count > 0; ++line_number) {
        String_View line = sv_trim_left(sv_chop_by_delim(&content, '\n'));
        if (line.count > 0 && *line.data != '#') {
            String_View kind = sv_chop_by_delim(&line, ' ');
            if (sv_eq(kind, sv_from_cstr("v"))) {
                char *endptr;

                line = sv_trim_left(line);
                float x = strtof(line.data, &endptr);
                if (lx > x) lx = x;
                if (hx < x) hx = x;
                sv_chop_left(&line, endptr - line.data);

                line = sv_trim_left(line);
                float y = strtof(line.data, &endptr);
                if (ly > y) ly = y;
                if (hy < y) hy = y;
                sv_chop_left(&line, endptr - line.data);

                line = sv_trim_left(line);
                float z = strtof(line.data, &endptr);
                if (lz > z) lz = z;
                if (hz < z) hz = z;
                sv_chop_left(&line, endptr - line.data);

                da_append(&vertices, make_vertex(x, y, z));
            } else if (sv_eq(kind, sv_from_cstr("f"))) {
                // TODO: This code assumes that we already parsed all of the vertices.
                // Since we don't have any OBJ files in the assets that have faces before
                // vertices, it does not really matter that much. If we ever have any
                // of such OBJ files, it's easy to restructure this loop to support any
                // order of the elements.
                int v1, v2, v3, vt1, vt2, vt3, vn1, vn2, vn3;

                int face_index = faces.count;

                parse_face_triple(&line, &lf, &hf, &v1, &vt1, &vn1);
                da_append(&vertices.items[v1].faces, face_index);

                parse_face_triple(&line, &lf, &hf, &v2, &vt2, &vn2);
                da_append(&vertices.items[v2].faces, face_index);

                parse_face_triple(&line, &lf, &hf, &v3, &vt3, &vn3);
                da_append(&vertices.items[v3].faces, face_index);

                da_append(&faces, make_face(v1, v2, v3, vt1, vt2, vt3, vn1, vn2, vn3));
            } else if (sv_eq(kind, sv_from_cstr("mtllib"))) {
                fprintf(stderr, "%s:%zu: WARNING: mtllib is not supported yet. Ignoring it...\n", input_file_path, line_number);
            } else if (sv_eq(kind, sv_from_cstr("usemtl"))) {
                fprintf(stderr, "%s:%zu: WARNING: usemtl is not supported yet. Ignoring it...\n", input_file_path, line_number);
            } else if (sv_eq(kind, sv_from_cstr("o"))) {
                if (one_object_encountered) {
                    fprintf(stderr, "%s:%zu: ERROR: %s supports only one object as of right now.\n", input_file_path, line_number, program_name);
                    fprintf(stderr, "%s:%zu: NOTE: we already processing this object\n", input_file_path, one_object_line_number);
                    return_defer(1);
                }
                line = sv_trim_left(line);
                String_View name = line;
                fprintf(stderr, "%s:%zu: INFO: processing object `"SV_Fmt"`\n", input_file_path, line_number, SV_Arg(name));
                one_object_encountered = true;
                one_object_line_number = line_number;
            } else if (sv_eq(kind, sv_from_cstr("s"))) {
                fprintf(stderr, "%s:%zu: WARNING: smooth groups are not supported right now. Ignoring them...\n", input_file_path, line_number);
            } else if (sv_eq(kind, sv_from_cstr("vn"))) {
                char *endptr;

                line = sv_trim_left(line);
                float x = strtof(line.data, &endptr);
                sv_chop_left(&line, endptr - line.data);

                line = sv_trim_left(line);
                float y = strtof(line.data, &endptr);
                sv_chop_left(&line, endptr - line.data);

                line = sv_trim_left(line);
                float z = strtof(line.data, &endptr);
                sv_chop_left(&line, endptr - line.data);

                da_append(&normals, make_vector3(x, y, z));
            } else if (sv_eq(kind, sv_from_cstr("vt"))) {
                char *endptr;

                line = sv_trim_left(line);
                float x = strtof(line.data, &endptr);
                sv_chop_left(&line, endptr - line.data);

                line = sv_trim_left(line);
                float y = strtof(line.data, &endptr);
                sv_chop_left(&line, endptr - line.data);

                da_append(&texcoords, make_vector2(x, y));
            } else {
                fprintf(stderr, "%s:%zu: ERROR: unknown kind of entry `"SV_Fmt"`\n", input_file_path, line_number, SV_Arg(kind));
                return_defer(1);
            }
        }
    }

    int min_faces = INT_MAX;
    int max_faces = INT_MIN;

    for (size_t i = 0; i < vertices.count; ++i) {
        int count = vertices.items[i].faces.count;
        if (min_faces > count) min_faces = count;
        if (max_faces < count) max_faces = count;
    }

    size_t comp_count = 0;
    int start = unvisited_vertex(vertices);
    while (start >= 0) {
        comp_count += 1;

        Vertex_Indices wave = {0};
        Vertex_Indices next_wave = {0};

        da_append(&wave, start);
        vertices.items[start].component = comp_count;
        while (wave.count > 0) {
            for (size_t i = 0; i < wave.count; ++i) {
                Vertex *vertex = &vertices.items[wave.items[i]];
                for (size_t j = 0; j < vertex->faces.count; ++j) {
                    for (size_t k = 0; k < VERTICES_PER_FACE; ++k) {
                        int neighbor_index = faces.items[vertex->faces.items[j]].v[k];
                        if (!vertices.items[neighbor_index].component) {
                            da_append(&next_wave, neighbor_index);
                            vertices.items[neighbor_index].component = comp_count;
                        }
                    }
                }
            }
            wave.count = 0;

            Vertex_Indices temp = wave;
            wave = next_wave;
            next_wave = temp;
        }

        start = unvisited_vertex(vertices);
    }

    printf("Input:               %s\n", input_file_path);
    printf("Output:              %s\n", output_file_path);
    printf("Vertices:            %zu (x: %f..%f, y: %f..%f, z: %f..%f)\n", vertices.count, lx, hx, ly, hy, lz, hz);
    printf("Normals:             %zu\n", normals.count);
    printf("Texture Coordinates: %zu\n", texcoords.count);
    printf("Faces:               %zu (index: %d..%d)\n", faces.count, lf, hf);
    printf("Faces per vertex:    %d..%d\n", min_faces, max_faces);
    printf("Components Count:    %zu\n", comp_count);
    printf("Deleted Components:  ");
    for (size_t i = 0; i < delete_components.count; ++i) {
        printf("%d ", delete_components.items[i]);
    }
    printf("\n");

    for (size_t i = 0; i < vertices.count; ++i) {
        vertices.items[i].position = remap_object(vertices.items[i].position, scale, lx, hx, ly, hy, lz, hz);
    }

    FILE *out = fopen(output_file_path, "wb");
    if (out == NULL) {
        fprintf(stderr, "ERROR: Could not write file %s: %s\n", output_file_path, strerror(errno));
        return_defer(1);
    }
    generate_code(out, vertices, texcoords, normals, faces, delete_components);

defer:
    return result;
}

```

`tools/png2c.c`:

```c
#include <assert.h>
#include <stdio.h>
#include <stdlib.h>
#include <stdint.h>
#include <stdbool.h>
#include <string.h>
#include <errno.h>
#include <ctype.h>

#define STB_IMAGE_IMPLEMENTATION
#include "./stb_image.h"

#define NOB_IMPLEMENTATION
#define NOB_STRIP_PREFIX
#include "nob.h"

void usage(FILE *out, const char *program_name)
{
    fprintf(out, "Usage: %s [OPTIONS] <input/file/path.png>\n", program_name);
    fprintf(out, "Options:\n");
    fprintf(out, "    -o <output/file/path.h>\n");
    fprintf(out, "    -n <name>\n");
}

void generate_c_code_from_pixels(FILE *out, uint32_t *data, int x, int y, const char *name)
{
    size_t name_len = strlen(name);
    char *capital_name = malloc(name_len + 1);
    assert(capital_name != NULL && "Buy more RAM, I guess");
    for (size_t i = 0; i < name_len; ++i) {
        capital_name[i] = toupper(name[i]);
    }
    capital_name[name_len] = '\0';

    fprintf(out, "#ifndef %s_H_\n", capital_name);
    fprintf(out, "#define %s_H_\n", capital_name);
    fprintf(out, "size_t %s_width = %d;\n", name, x);
    fprintf(out, "size_t %s_height = %d;\n", name, y);
    fprintf(out, "uint32_t %s_pixels[] = {\n", name);
    size_t length = (size_t)(x * y);
    size_t width = 7;
    for (size_t i = 0; i < (length + width - 1)/width; ++i) {
        fprintf(out, "   ");
        for (size_t j = 0; j < width && i*width + j < length; ++j) {
            fprintf(out, "0x%08X,", data[i*width + j]);
        }
        fprintf(out, "\n");
    }
    fprintf(out, "};\n");
    fprintf(out, "#endif // %s_H_\n", capital_name);

//defer:
    free(capital_name);
}

bool generate_c_file_from_png(const char *input_file_path, const char *output_file_path, const char *name)
{
    bool result = true;

    FILE *out = NULL;
    uint32_t *data = NULL;

    {
        int x, y;
        data = (uint32_t *)stbi_load(input_file_path, &x, &y, NULL, 4);

        if (data == NULL) {
            fprintf(stderr, "ERROR: Could not load file `%s`: %s\n", input_file_path, stbi_failure_reason());
            return_defer(false);
        }

        if (output_file_path) {
            out = fopen(output_file_path, "wb");
            if (out == NULL) {
                fprintf(stderr, "ERROR: could not write to file `%s`: %s\n", output_file_path, strerror(errno));
                return_defer(false);
            }
            generate_c_code_from_pixels(out, data, x, y, name);
        } else {
            generate_c_code_from_pixels(stdout, data, x, y, name);
        }
    }

defer:
    if (out) fclose(out);
    if (data) stbi_image_free(data);
    return result;
}

int main(int argc, char *argv[])
{
    assert(argc > 0);
    const char *program_name = shift(argv, argc);
    const char *output_file_path = NULL;
    const char *input_file_path = NULL;
    const char *name = NULL;

    while (argc > 0) {
        const char *flag = shift(argv, argc);
        if (strcmp(flag, "-o") == 0) {
            if (argc <= 0) {
                usage(stderr, program_name);
                fprintf(stderr, "ERROR: no value is provided for flag %s\n", flag);
                return 1;
            }

            if (output_file_path != NULL) {
                usage(stderr, program_name);
                fprintf(stderr, "ERROR: %s was already provided\n", flag);
                return 1;
            }

            output_file_path = shift(argv, argc);
        } else if (strcmp(flag, "-n") == 0) {
            if (argc <= 0) {
                usage(stderr, program_name);
                fprintf(stderr, "ERROR: no value is provided for flag %s\n", flag);
                return 1;
            }

            if (name != NULL) {
                usage(stderr, program_name);
                fprintf(stderr, "ERROR: %s was already provided\n", flag);
                return 1;
            }

            name = shift(argv, argc);
        } else {
            if (input_file_path != NULL) {
                usage(stderr, program_name);
                fprintf(stderr, "ERROR: input file path was already provided\n");
                return 1;
            }
            input_file_path = flag;
        }
    }

    if (input_file_path == NULL) {
        usage(stderr, program_name);
        fprintf(stderr, "ERROR: expected input file path\n");
        return(1);
    }

    if (name == NULL) {
        name = "png";
    } else {
        size_t n = strlen(name);
        if (n == 0) {
            fprintf(stderr, "ERROR: name cannot be empty\n");
            return 1;
        }

        if (isdigit(name[0])) {
            fprintf(stderr, "ERROR: name cannot start from a digit\n");
            return 1;
        }

        for (size_t i = 0; i < n; ++i) {
            if (!isalnum(name[i]) && name[i] != '_') {
                fprintf(stderr, "ERROR: name can only contains alphanumeric characters and underscores\n");
                return 1;
            }
        }
    }

    if (!generate_c_file_from_png(input_file_path, output_file_path, name)) return 1;

    return 0;
}

```