Project Path: arc_charliewolfe_PointerGuard_gv_6xdqv

Source Tree:

```txt
arc_charliewolfe_PointerGuard_gv_6xdqv
├── PointerGuard
│   ├── GuardedPointer.cpp
│   ├── GuardedPointer.h
│   ├── Main.cpp
│   ├── PointerGuard.cpp
│   ├── PointerGuard.h
│   ├── PointerGuard.vcxproj
│   └── PointerGuard.vcxproj.filters
├── PointerGuard.sln
└── README.md

```

`PointerGuard.sln`:

```sln

Microsoft Visual Studio Solution File, Format Version 12.00
# Visual Studio Version 17
VisualStudioVersion = 17.1.32407.343
MinimumVisualStudioVersion = 10.0.40219.1
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "PointerGuard", "PointerGuard\PointerGuard.vcxproj", "{A8B77ABC-126F-4C09-8677-5316EFB589FB}"
EndProject
Global
	GlobalSection(SolutionConfigurationPlatforms) = preSolution
		Debug|x64 = Debug|x64
		Debug|x86 = Debug|x86
		Release|x64 = Release|x64
		Release|x86 = Release|x86
	EndGlobalSection
	GlobalSection(ProjectConfigurationPlatforms) = postSolution
		{A8B77ABC-126F-4C09-8677-5316EFB589FB}.Debug|x64.ActiveCfg = Debug|x64
		{A8B77ABC-126F-4C09-8677-5316EFB589FB}.Debug|x64.Build.0 = Debug|x64
		{A8B77ABC-126F-4C09-8677-5316EFB589FB}.Debug|x86.ActiveCfg = Debug|Win32
		{A8B77ABC-126F-4C09-8677-5316EFB589FB}.Debug|x86.Build.0 = Debug|Win32
		{A8B77ABC-126F-4C09-8677-5316EFB589FB}.Release|x64.ActiveCfg = Release|x64
		{A8B77ABC-126F-4C09-8677-5316EFB589FB}.Release|x64.Build.0 = Release|x64
		{A8B77ABC-126F-4C09-8677-5316EFB589FB}.Release|x86.ActiveCfg = Release|Win32
		{A8B77ABC-126F-4C09-8677-5316EFB589FB}.Release|x86.Build.0 = Release|Win32
	EndGlobalSection
	GlobalSection(SolutionProperties) = preSolution
		HideSolutionNode = FALSE
	EndGlobalSection
	GlobalSection(ExtensibilityGlobals) = postSolution
		SolutionGuid = {D49472D5-FBDA-4DEC-8F77-015FDD16FD0A}
	EndGlobalSection
EndGlobal

```

`PointerGuard/GuardedPointer.cpp`:

```cpp
#include "GuardedPointer.h"

GuardedPointer::GuardedPointer(
	PVOID PointerToGuard,
	BOOL MonitorReads
) {
	this->Pointer = PointerToGuard;
	this->MonitorReads = MonitorReads;
}

```

`PointerGuard/GuardedPointer.h`:

```h
#pragma once
#include <Windows.h>

struct GuardedPointer {
	PVOID Pointer;
	BOOL MonitorReads;

	GuardedPointer(
		PVOID PointerToGuard,
		BOOL MonitorReads = FALSE
	);
};

```

`PointerGuard/Main.cpp`:

```cpp
#include <stdio.h>
#include <Windows.h>
#include <cassert>
#include "PointerGuard.h"

INT 
main() {
    if (!InitializePointerGuard()) {
        printf("Failed to initialize PointerGuard\n");
        return 1;
    }

    INT DemoInteger = 50;
    PVOID RealPointer = &DemoInteger;
    PVOID FakePointer = CreateGuardedPointer(RealPointer, TRUE);
    printf("Real pointer: 0x%p\n", RealPointer);
    printf("Fake pointer: 0x%p\n", FakePointer);

    INT DereferencedRealPointer = *(INT*)RealPointer;
    INT DereferencedFakePointer = *(INT*)FakePointer;
    printf("Dereferenced real pointer (0x%p): %i\n", RealPointer, DereferencedRealPointer);
    printf("Dereferenced fake pointer (0x%p): %i\n", FakePointer, DereferencedFakePointer);

    assert(DereferencedRealPointer == DereferencedFakePointer);

    printf("\nWriting to the fake pointer...\n");
    *(INT*)FakePointer = 60;
    DereferencedRealPointer = *(INT*)RealPointer;
    DereferencedFakePointer = *(INT*)FakePointer;

    printf("Dereferenced real pointer (0x%p): %i\n", RealPointer, DereferencedRealPointer);
    printf("Dereferenced fake pointer (0x%p): %i\n", FakePointer, DereferencedFakePointer);

    assert(DereferencedRealPointer == DereferencedFakePointer);

    if (!DestroyPointerGuard()) {
        printf("Failed to destroy PointerGuard\n");
        return 1;
    }

    return 0;
}

```

`PointerGuard/PointerGuard.cpp`:

```cpp
#include "PointerGuard.h"
#include <stdio.h>
#include <unordered_map>
#include "GuardedPointer.h"

#define KEY 0xDEAD

PVOID Handle;
std::unordered_map<PVOID, GuardedPointer*> PointerMap;
ULONGLONG CurrentAddress = 0x1000000;

LONG WINAPI
Handler(
	PEXCEPTION_POINTERS ExceptionInfo
) {
	PVOID ExceptionAddress = (PVOID)ExceptionInfo->ContextRecord->Rax;
	if (!PointerMap.count(ExceptionAddress))
		return EXCEPTION_ACCESS_VIOLATION;

	if (PointerMap[ExceptionAddress]->MonitorReads)
		printf("Guarded pointer 0x%p accessed from 0x%p\n", ExceptionInfo->ContextRecord->Rax, ExceptionInfo->ContextRecord->Rip);

	PVOID EncryptedPointer = PointerMap[ExceptionAddress]->Pointer;
	ExceptionInfo->ContextRecord->Rax = (ULONGLONG)EncryptedPointer ^ KEY;

	return EXCEPTION_CONTINUE_EXECUTION;
}

BOOL
InitializePointerGuard() {
	Handle = AddVectoredExceptionHandler(1, Handler);
	if (!Handle)
		return FALSE;
	return TRUE;
}

PVOID
CreateGuardedPointer(
	PVOID PointerToGuard,
	BOOL MonitorReads
) {
	if (PointerMap.count(PointerToGuard))
		return NULL;

	PointerMap[(PVOID)++CurrentAddress] = new GuardedPointer((PVOID)((ULONGLONG)PointerToGuard ^ KEY), MonitorReads);

	return (PVOID)CurrentAddress;
}

BOOL
DestroyPointerGuard() {
	for (auto i = PointerMap.begin(); i != PointerMap.end(); i++)
		delete i->second;

	if (!RemoveVectoredExceptionHandler(Handle))
		return FALSE;
	return TRUE;
}

```

`PointerGuard/PointerGuard.h`:

```h
#pragma once
#include <Windows.h>

BOOL
InitializePointerGuard();

PVOID
CreateGuardedPointer(
	PVOID PointerToGuard,
	BOOL MonitorReads = FALSE
);

BOOL
DestroyPointerGuard();

```

`PointerGuard/PointerGuard.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|Win32">
      <Configuration>Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <VCProjectVersion>16.0</VCProjectVersion>
    <Keyword>Win32Proj</Keyword>
    <ProjectGuid>{a8b77abc-126f-4c09-8677-5316efb589fb}</ProjectGuid>
    <RootNamespace>PointerGuard</RootNamespace>
    <WindowsTargetPlatformVersion>10.0</WindowsTargetPlatformVersion>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="Shared">
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <LinkIncremental>true</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <LinkIncremental>false</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <LinkIncremental>true</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <LinkIncremental>false</LinkIncremental>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>WIN32;_DEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>WIN32;NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>_DEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <Optimization>Disabled</Optimization>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemGroup>
    <ClCompile Include="GuardedPointer.cpp" />
    <ClCompile Include="Main.cpp" />
    <ClCompile Include="PointerGuard.cpp" />
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="GuardedPointer.h" />
    <ClInclude Include="PointerGuard.h" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>
```

`PointerGuard/PointerGuard.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="Source Files">
      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
      <Extensions>cpp;c;cc;cxx;c++;cppm;ixx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
    </Filter>
    <Filter Include="Header Files">
      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
      <Extensions>h;hh;hpp;hxx;h++;hm;inl;inc;ipp;xsd</Extensions>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="Main.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="PointerGuard.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="GuardedPointer.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="PointerGuard.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="GuardedPointer.h">
      <Filter>Header Files</Filter>
    </ClInclude>
  </ItemGroup>
</Project>
```

`README.md`:

```md
# PointerGuard
PointerGuard is a proof-of-concept tool used to create 'guarded' pointers which disguise pointer addresses, monitor reads/writes, and prevent access from external processes.

## Explanation
PointerGuard is implemented using a Vectored Exception Handler (VEH).

### Disguise Pointers
When a guarded pointer is created, it is assigned an invalid (disguised) address. Once the invalid pointer is dereferenced, an access violation is thrown to be caught by our VEH. If the exception handler determines that the access violation was caused from a guarded pointer, the register containing the invalid pointer will be replaced with the real pointer and execution will continue. 

### Monitor reads/writes
PointerGuard can be used to determine when and where a guarded pointer is dereferenced from. In the provided code, this is done by printing the instruction pointer (`RIP`) each time a guarded pointer is dereferenced.

### Prevent external access
When an external process tries to read our guarded pointer (e.g. using `ReadProcessMemory`), the VEH will not be triggered and the address will be recognized as invalid. 

## Example Output
```
Real pointer: 0x00000067FBD9F834
Fake pointer: 0x0000000001000001
Guarded pointer 0x0000000001000001 accessed from 0x00007FF790B114E0
Dereferenced real pointer (0x00000067FBD9F834): 50
Dereferenced fake pointer (0x0000000001000001): 50 
                                                                                                                                                   
Writing to the fake pointer...
Guarded pointer 0x0000000001000001 accessed from 0x00007FF790B11550
Guarded pointer 0x0000000001000001 accessed from 0x00007FF790B11563
Dereferenced real pointer (0x00000067FBD9F834): 60
Dereferenced fake pointer (0x0000000001000001): 60
```

## Build
Build as an x64 executable using Visual Studio 2022.

## Note
The binaries were only tested on Windows 10 21H1.

Code Optimization must be disabled (/Od).

```