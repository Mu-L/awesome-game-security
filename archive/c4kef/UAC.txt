Project Path: arc_c4kef_UAC_c1a62dqc

Source Tree:

```txt
arc_c4kef_UAC_c1a62dqc
├── KernelAntiCheat
│   ├── Funcs
│   │   ├── Hardware
│   │   │   ├── HardwareInfo.c
│   │   │   └── HardwareInfo.h
│   │   ├── Protects
│   │   │   ├── ScanBigPool.c
│   │   │   ├── ScanCodeIntegrity.c
│   │   │   ├── ScanDispatchDrivers.c
│   │   │   ├── ScanHV.c
│   │   │   ├── ScanPIDDB.c
│   │   │   ├── ScanPerfectInjector.c
│   │   │   ├── ScanPhysMemHandles.c
│   │   │   ├── ScanSSDTHooks.c
│   │   │   ├── ScanSysThreads.c
│   │   │   └── ScanUnloadedDrivers.c
│   │   ├── Signature
│   │   │   ├── ValidateSignature.c
│   │   │   └── ValidateSignature.h
│   │   ├── funcs.h
│   │   ├── log.c
│   │   ├── log.h
│   │   ├── utils.c
│   │   └── utils.h
│   ├── KernelAntiCheat.vcxproj
│   ├── KernelAntiCheat.vcxproj.filters
│   ├── Natives
│   │   ├── Hde
│   │   │   ├── hde64.c
│   │   │   ├── hde64.h
│   │   │   └── table64.h
│   │   ├── Imports.h
│   │   ├── NativeEnums.h
│   │   ├── NativeStructs.h
│   │   ├── PEStructs.h
│   │   ├── Windows
│   │   │   ├── RAIIUtilites.c
│   │   │   ├── RAIIUtilites.h
│   │   │   └── ci.h
│   │   └── stdint.h
│   └── entry.c
├── Libs
│   └── ci.lib
├── README.md
└── UAC.sln

```

`KernelAntiCheat/Funcs/Hardware/HardwareInfo.c`:

```c
#include "HardwareInfo.h"
#include "../../Natives/Imports.h"
#include "..\log.h"

PSYSTEM_BOOT_ENVIRONMENT_INFORMATION GetBootUUID()
{
	NTSTATUS status = STATUS_SUCCESS;
	ULONG neededSize = 0;

	neededSize = PAGE_SIZE;

	PSYSTEM_BOOT_ENVIRONMENT_INFORMATION pBootInfo;

	if (pBootInfo = (PSYSTEM_BOOT_ENVIRONMENT_INFORMATION)ExAllocatePoolWithTag(NonPagedPool, neededSize, POOL_TAG)) {
		NTSTATUS r;
		if (NT_SUCCESS(r = ZwQuerySystemInformation(SystemBootEnvironmentInformation, pBootInfo, neededSize, 0))) 
		{
			return pBootInfo;
		}
		else
		{
			DPRINT_LOG("(%s) r = 0x%X", __FUNCTION__, r);
		}
	}
	return NULL;
}
```

`KernelAntiCheat/Funcs/Hardware/HardwareInfo.h`:

```h
#pragma once
#include "../../Funcs/utils.h"

PSYSTEM_BOOT_ENVIRONMENT_INFORMATION GetBootUUID();
```

`KernelAntiCheat/Funcs/Protects/ScanBigPool.c`:

```c
#include "..\funcs.h"
#include "..\log.h"

BOOL ScanBigPool()
{
	ULONG len = 4 * 1024 * 1024;
	PVOID mem = ExAllocatePoolWithTag(NonPagedPool, len, POOL_TAG);
	NTSTATUS status = STATUS_SUCCESS;
	if (NT_SUCCESS(status = ZwQuerySystemInformation(SystemBigPoolInformation, mem, len, &len))) {
		PSYSTEM_BIGPOOL_INFORMATION pBuf = (PSYSTEM_BIGPOOL_INFORMATION)(mem);
		for (ULONG i = 0; i < pBuf->Count; i++) {
			__try {
				if (pBuf->AllocatedInfo[i].TagUlong == 'SldT') {
					DPRINT_LOG("(%s) [FLAG] TdlS pooltag detected", __FUNCTION__);
					PVOID page = MmMapIoSpaceEx(MmGetPhysicalAddress((void*)pBuf->AllocatedInfo[i].VirtualAddress), PAGE_SIZE, PAGE_READWRITE);
					if (page)
					{
						PULONG hash = *(PULONG)((uintptr_t)page + 0x184);
						if (hash == 0x0B024BC8B48 || hash == 0x0C8931AEB)
						{
							MmUnmapIoSpace(page, PAGE_SIZE);
							DPRINT_LOG("(%s) [DETECT] 0x0B024BC8B48 found at pool + 0x184", __FUNCTION__);
							return TRUE;
						}

						MmUnmapIoSpace(page, PAGE_SIZE);
					}
				}
			}
			__except (EXCEPTION_EXECUTE_HANDLER) {
				DPRINT_LOG("(%s) Access Violation was raised.", __FUNCTION__);
			}
		}
	}
	else
	{
		DPRINT_LOG("(%s) Failed to get pool information! Code: 0x%x", __FUNCTION__, status);
	}

	ExFreePoolWithTag(mem, POOL_TAG);
	return FALSE;
}
```

`KernelAntiCheat/Funcs/Protects/ScanCodeIntegrity.c`:

```c
#include "..\funcs.h"
#include "..\log.h"
#include "..\..\Natives\Hde\hde64.h"

HANDLE FileHandle;

LONG FindEntryCiOptions( PVOID MappedBase,  ULONG_PTR KernelBase,  PULONG_PTR gCiOptionsAddress)
{
	*gCiOptionsAddress = 0;

	ULONG i;
	LONG Relative = 0;
	hde64s hs;

	const PUCHAR CiInitialize = (GetProcAddress((ULONG_PTR)(MappedBase), "CiInitialize"));
	if (!CiInitialize)
		return 0;

	i = 0;
	ULONG j = 0;
	do
	{
		if (CiInitialize[i] == 0xE8)
			j++;

		if (j > 1)
		{
			Relative = *(PLONG)(CiInitialize + i + 1);
			break;
		}

		hde64_disasm(CiInitialize + i, &hs);
		if (hs.flags & F_ERROR)
			break;
		i += hs.len;

	} while (i < 256);

	const PUCHAR CipInitialize = CiInitialize + i + 5 + Relative;
	i = 0;
	do
	{
		if (*(PUSHORT)(CipInitialize + i) == 0x0d89)
		{
			Relative = *(PLONG)(CipInitialize + i + 2);
			break;
		}
		hde64_disasm(CipInitialize + i, &hs);
		if (hs.flags & F_ERROR)
			break;
		i += hs.len;

	} while (i < 256);

	const PUCHAR MappedCiOptions = CipInitialize + i + 6 + Relative;

	*gCiOptionsAddress = KernelBase + MappedCiOptions - (PUCHAR)(MappedBase);

	return Relative;
}

BOOL CheckDSEHack()
{
	PVOID CiOptionsAddress = 0;
	PVOID MappedBase = 0;
	SIZE_T ViewSize = 0;
	NTSTATUS Status = LoadLibrary(L"\\??\\C:\\Windows\\System32\\ci.dll", &MappedBase, &ViewSize);
	if (!NT_SUCCESS(Status))
	{
		DPRINT_LOG("(%s) Failed to map: 0x%X", __FUNCTION__, Status);
		return FALSE;
	}

	ULONG_PTR CiDllBase = GetModuleBaseAddress("CI.dll");
	if (!CiDllBase)
	{
		ZwUnmapViewOfSection(NtCurrentProcess(), MappedBase);
		DPRINT_LOG("(%s) CI.dll not found in kernel space!", __FUNCTION__);
		return FALSE;
	}

	ULONG_PTR gCiOptionsAddress;

	const LONG Relative = FindEntryCiOptions(MappedBase, CiDllBase, &gCiOptionsAddress);
	if (Relative != 0)
	{
		CiOptionsAddress = (PVOID)(gCiOptionsAddress);
		Status = STATUS_SUCCESS;
	}
	else
	{
		DPRINT_LOG("(%s) entry to CI!CiOptions not found!", __FUNCTION__);
		Status = STATUS_NOT_FOUND;
	}

	ZwUnmapViewOfSection(NtCurrentProcess(), MappedBase);

	int CiOptionsValue = 0x6;
	if (NT_SUCCESS(Status))
	{
		CiOptionsValue = *(int*)CiOptionsAddress;
	}

	return CiOptionsValue != 0x6;
}

BOOL CheckTestMode()
{
	SYSTEM_CODEINTEGRITY_INFORMATION sci = { 0 };
	ULONG dwcbSz = 0;
	sci.Length = sizeof(sci);
	NtQuerySystemInformation(SystemCodeIntegrityInformation, &sci, sizeof(sci), &dwcbSz);
	return sci.CodeIntegrityOptions != CODEINTEGRITY_OPTION_ENABLED;
}

BOOL ScanCodeIntegrity() 
{
	BOOL testMode = CheckTestMode();
	BOOL dseCheck = CheckDSEHack();

	if (testMode)
	{
		DPRINT_LOG("(%s) [DETECT] enabled test mode", __FUNCTION__);
	}

	if (dseCheck)
	{
		DPRINT_LOG("(%s) [DETECT] u are using DSE hacks", __FUNCTION__);
	}

	return dseCheck || testMode;
}
```

`KernelAntiCheat/Funcs/Protects/ScanDispatchDrivers.c`:

```c
#include "..\funcs.h"
#include "..\log.h"

BOOL ScanDispatchDrivers(PSYSTEM_MODULE_INFORMATION pModuleList)
{
	NTSTATUS status = STATUS_SUCCESS;
	HANDLE hDir;
	UNICODE_STRING str;
	OBJECT_ATTRIBUTES oa;
	RtlInitUnicodeString(&str, L"\\Driver");
	InitializeObjectAttributes(&oa, &str, OBJ_CASE_INSENSITIVE | OBJ_KERNEL_HANDLE, (HANDLE)NULL, (PSECURITY_DESCRIPTOR)NULL);
	if (!NT_SUCCESS(status = ZwOpenDirectoryObject(&hDir, DIRECTORY_QUERY, &oa))) {
		DPRINT_LOG("(%s) Failed to open \\Driver directory object, code: 0x%X", __FUNCTION__, status);
		return FALSE;
	}

	PVOID Obj;
	if (!NT_SUCCESS(status = ObReferenceObjectByHandle(hDir, DIRECTORY_QUERY, NULL, KernelMode, &Obj, NULL))) {
		DPRINT_LOG("(%s) ObReferenceObjectByHandle failed, code: 0x%X", __FUNCTION__, status);
		return FALSE;
	}
	NtClose(hDir);

	POBJECT_TYPE obj_type = ObGetObjectType(Obj);
	ObDereferenceObject(Obj);

	HANDLE h;
	if (!NT_SUCCESS(status = ObOpenObjectByName(&oa, obj_type, KernelMode, NULL, DIRECTORY_QUERY, NULL, &h))) {
		DPRINT_LOG("(%s) ObOpenObjectByName failed, code: 0x%X", __FUNCTION__, status);
		return FALSE;
	}

	POBJDIR_INFORMATION dir_info = (POBJDIR_INFORMATION)ExAllocatePoolWithTag(NonPagedPool, PAGE_SIZE, POOL_TAG);
	ULONG    ulContext = 0;

	ULONG returned_bytes;
	_ZwQueryDirectoryObject zwQDO = FindModule(L"ZwQueryDirectoryObject");

	if (!zwQDO)
	{
		DPRINT_LOG("(%s) ZwQueryDirectoryObject not found.", __FUNCTION__);
		return FALSE;
	}

	while (NT_SUCCESS(zwQDO(h, dir_info, PAGE_SIZE, TRUE, FALSE, &ulContext, &returned_bytes))) 
	{
		PDRIVER_OBJECT pObj;
		wchar_t wsDriverName[100] = L"\\Driver\\";
		wcscat(wsDriverName, dir_info->ObjectName.Buffer);
		UNICODE_STRING ObjName;
		ObjName.Length = ObjName.MaximumLength = wcslen(wsDriverName) * 2;
		ObjName.Buffer = wsDriverName;

		if (NT_SUCCESS(ObReferenceObjectByName(&ObjName, OBJ_KERNEL_HANDLE | OBJ_CASE_INSENSITIVE, NULL, NULL, *IoDriverObjectType, KernelMode, NULL, (PVOID*)&pObj))) {
			UNICODE_STRING path;
			wchar_t w_path[2048];
			UNICODE_STRING DriverName = pObj->DriverName;
			if (!NT_SUCCESS(IoQueryFullDriverPath(pObj, &path)))
			{
				RtlInitUnicodeString(&path, L"not found");
				DPRINT_LOG("(%s) [FLAG] %wZ driver has not found path", __FUNCTION__, DriverName);
			}
			else
			{
				swprintf(w_path, L"%wZ", path);
			}

			if (IsAddressOutsideModuleList(pModuleList, (uintptr_t)(pObj->MajorFunction[IRP_MJ_DEVICE_CONTROL])))
			{
				ObDereferenceObject(pObj);
				DPRINT_LOG("(%s) [DETECT] %wZ driver has spoofed driver dispatch", __FUNCTION__, DriverName);
				return TRUE;
			}

			if (IsAddressOutsideModuleList(pModuleList, (uintptr_t)pObj->DriverStart))
			{
				ObDereferenceObject(pObj);
				DPRINT_LOG("(%s) [DETECT] %wZ driver has spoofed DriverStart", __FUNCTION__, DriverName);
				return TRUE;
			}

			//flags detection
			uintptr_t dd = (uintptr_t)(pObj->MajorFunction[IRP_MJ_DEVICE_CONTROL]);
			if ((dd < (uintptr_t)pObj->DriverStart || dd >(uintptr_t)pObj->DriverStart + pObj->DriverSize))
			{
				ObDereferenceObject(pObj);
				if (!CheckSignedFile(w_path))
				{
					DPRINT_LOG("(%s) [FLAG] %wZ driver has spoofed driver dispatch, path = %wZ", __FUNCTION__, DriverName, path);
				}
				continue;
			}

			if (IsAddressOutsideModuleList(pModuleList, (uintptr_t)(pObj->FastIoDispatch)))
			{
				ObDereferenceObject(pObj);
				if (!CheckSignedFile(w_path))
				{
					DPRINT_LOG("(%s) [FLAG] %wZ driver has spoofed FastIoDispatch", __FUNCTION__, DriverName);
				}
				continue;
			}
			ObDereferenceObject(pObj);
		}
	}
	ZwClose(h);
	return FALSE;
}
```

`KernelAntiCheat/Funcs/Protects/ScanHV.c`:

```c
#include "..\funcs.h"
#include "..\log.h"

static inline unsigned long long rdtsc_diff_vmexit() {
	ULONG64 t1 = __rdtsc();
	int r[4];
	__cpuid(r, 1);
	return __rdtsc() - t1;
}

int cpu_rdtsc_force_vmexit() {
	int i;
	unsigned long long avg = 0;
	for (i = 0; i < 10; i++) {
		avg = avg + rdtsc_diff_vmexit();
		SleepThread(500);
	}
	avg = avg / 10;
	return (avg < 1000 && avg > 0) ? FALSE : TRUE;
}

BOOL IsHV()
{
	if (cpu_rdtsc_force_vmexit()) {
		return TRUE;
	}

	__try {
		__vmx_vmread(NULL, NULL);
	}
	__except (EXCEPTION_EXECUTE_HANDLER) {

	}
	return FALSE;
}

BOOL IsLazyHV()
{
	__try
	{
		cr0_t cr0;
		cr0.full = __readcr0();

		cr0.numeric_error = !cr0.numeric_error;
		cr0.protection_enable = 0;

		__writecr0(cr0.full);

		return TRUE;
	}
	__except (EXCEPTION_EXECUTE_HANDLER)
	{
	}

	{
		cr0_t old_cr0;
		old_cr0.full = __readcr0();

		__try
		{
			//_disable();

			{
				cr0_t cr0 = old_cr0;
				cr0.numeric_error = !cr0.numeric_error;
				__writecr0(cr0.full);

				cr0.full = __readcr0();

				if (cr0.numeric_error == old_cr0.numeric_error)
				{
					//_enable();
					return TRUE;
				}
			}

			__writecr0(old_cr0.full);
		}
		__except (EXCEPTION_EXECUTE_HANDLER)
		{
			//_enable();
			return TRUE;
		}

		//_enable();
	}

	__try
	{
		__writecr4(__readcr4() | (1 << 23));

		return TRUE;
	}
	__except (EXCEPTION_EXECUTE_HANDLER)
	{
	}

	__try
	{
		__writecr0(__readcr0() | (1 << 23));
	}
	__except (EXCEPTION_EXECUTE_HANDLER)
	{
		return TRUE;
	}

	{
		//_disable();

		cr0_t old_cr0;
		old_cr0.full = __readcr0();

		__try
		{
			cr0_t cr0 = old_cr0;
			cr0.numeric_error = !cr0.numeric_error;
			cr0.protection_enable = 0;
			cr0.write_protect = !cr0.write_protect;
			__writecr0(cr0.full);
		}
		__except (EXCEPTION_EXECUTE_HANDLER)
		{
			cr0_t cr0;
			cr0.full = __readcr0();

			if (cr0.write_protect != old_cr0.write_protect)
			{
				//_enable();

				__writecr0(old_cr0.full);
				return TRUE;
			}
		}

		//_enable();
	}

	return FALSE;
}

BOOL ScanHV()
{
	BOOL isLHV = IsLazyHV();
	BOOL isHV = IsHV();
	if (isLHV)
	{
		DPRINT_LOG("(%s) [DETECT] detected is lazy hypervisor", __FUNCTION__);
	}
	if (isHV)
	{
		DPRINT_LOG("(%s) [DETECT] detected is hypervisor", __FUNCTION__);
	}
	return isLHV || isHV;
}
```

`KernelAntiCheat/Funcs/Protects/ScanPIDDB.c`:

```c
#include "..\funcs.h"
#include "..\log.h"

UCHAR PiDDBLockPtr_sig[] = "\x48\x8D\x0D\x00\x00\x00\x00\xE8\x00\x00\x00\x00\x4C\x8B\x8C";
UCHAR PiDDBCacheTablePtr_sig[] = "\x66\x03\xD2\x48\x8D\x0D";

BOOL LocatePiDDB(PERESOURCE* lock, PRTL_AVL_TABLE* table)
{
	NTSTATUS status = STATUS_SUCCESS;
	PVOID PiDDBLockPtr = NULL, PiDDBCacheTablePtr = NULL;
	if (!NT_SUCCESS(status = ScanSection("PAGE", PiDDBLockPtr_sig, 0, sizeof(PiDDBLockPtr_sig) - 1, (PVOID*)(&PiDDBLockPtr)))) {
		DPRINT_LOG("(%s) Unable to find PiDDBLockPtr sig, code: 0x%X", __FUNCTION__, status);
		return FALSE;
	}

	if (!NT_SUCCESS(status = ScanSection("PAGE", PiDDBCacheTablePtr_sig, 0, sizeof(PiDDBCacheTablePtr_sig) - 1, (PVOID*)(&PiDDBCacheTablePtr)))) {
		DPRINT_LOG("(%s) Unable to find PiDDBCacheTablePtr sig, code: 0x%X", __FUNCTION__, status);
		return FALSE;
	}

	PiDDBCacheTablePtr = (PVOID)((uintptr_t)PiDDBCacheTablePtr + 3);

	*lock = (PERESOURCE)(ResolveRelativeAddress(PiDDBLockPtr, 3, 7));
	*table = (PRTL_AVL_TABLE)(ResolveRelativeAddress(PiDDBCacheTablePtr, 3, 7));

	return TRUE;
}

BOOL ScanPIDDB()
{
	PERESOURCE PiDDBLock; PRTL_AVL_TABLE table;
	if (!LocatePiDDB(&PiDDBLock, &table))
	{
		DPRINT_LOG("(%s) Failed to find piddb!", __FUNCTION__);
		return FALSE;
	}
	ExAcquireResourceExclusiveLite(PiDDBLock, TRUE);
	for (piddbcentry* p = (piddbcentry*)RtlEnumerateGenericTableAvl(table, TRUE);
		p != NULL;
		p = (piddbcentry*)RtlEnumerateGenericTableAvl(table, FALSE)) {
		if (p->TimeDateStamp == 0x5284eac3)//kdmapper
		{
			DPRINT_LOG("(%s) [DETECT] found using kdmapper", __FUNCTION__);
			return TRUE;
		}
		if (p->TimeDateStamp == 0x57CD1415)//drvmap
		{
			DPRINT_LOG("(%s) [DETECT] found using drvmap", __FUNCTION__);
			return TRUE;
		}
	}

	ExReleaseResourceLite(PiDDBLock);
	return FALSE;
}
```

`KernelAntiCheat/Funcs/Protects/ScanPerfectInjector.c`:

```c
#include "..\funcs.h"
#include "..\log.h"
BOOL ScanPerfectInjector()
{
	NTSTATUS status = STATUS_SUCCESS;
	UNICODE_STRING phys_mem_str;
	OBJECT_ATTRIBUTES oaAttributes;
	RtlInitUnicodeString(&phys_mem_str, L"\\Device\\PhysicalMemory");
	InitializeObjectAttributes(&oaAttributes, &phys_mem_str, OBJ_CASE_INSENSITIVE | OBJ_KERNEL_HANDLE, (HANDLE)NULL, (PSECURITY_DESCRIPTOR)NULL);
	HANDLE hPhysMem;
	if (!NT_SUCCESS(status = ZwOpenSection(&hPhysMem, SECTION_ALL_ACCESS, &oaAttributes))) {
		DPRINT_LOG("(%s) Failed to open phys mem section, code: 0x%X", __FUNCTION__, status);
		return FALSE;
	}

	PVOID PhysicalMemoryBegin = NULL;

	PPHYSICAL_MEMORY_RANGE Range = MmGetPhysicalMemoryRanges();
	DWORD64 PhysicalMemorySize = 0;

	while (Range->NumberOfBytes.QuadPart)
	{
		PhysicalMemorySize = max(PhysicalMemorySize, Range->BaseAddress.QuadPart + Range->NumberOfBytes.QuadPart);
		Range++;
	}

	if (!NT_SUCCESS(status = ZwMapViewOfSection(hPhysMem, ZwCurrentProcess(), &PhysicalMemoryBegin, NULL, NULL, NULL, &PhysicalMemorySize, ViewUnmap, NULL, PAGE_READWRITE))) {
		DPRINT_LOG("(%s) ZwMapViewOfSection failed, code: 0x%X", __FUNCTION__, status);
		ZwClose(hPhysMem);
		return FALSE;
	}

	PSYSTEM_PROCESS_INFO processes = GetProcList();
	if (!processes) {
		DPRINT_LOG("(%s) Unable to get process list.", __FUNCTION__);
		ZwUnmapViewOfSection(ZwCurrentProcess(), PhysicalMemoryBegin);
		ZwClose(hPhysMem);
		return FALSE;
	}

	PSYSTEM_PROCESS_INFO walk = processes;
	while (walk->NextEntryOffset)
	{
		KAPC_STATE apcState;

		PEPROCESS process = NULL;
		if (walk->UniqueProcessId != NULL)
		{
			if (NT_SUCCESS(PsLookupProcessByProcessId(walk->UniqueProcessId, &process))) {

				__try {
					KeStackAttachProcess(process, &apcState);
					PVOID cr3 = __readcr3();
					KeUnstackDetachProcess(&apcState);

					PTE_CR3 Cr3 = { cr3 };

					VIRT_ADDR system_range_start = { (uintptr_t)MmSystemRangeStart };

					for (int pml4_index = system_range_start.pml4_index; pml4_index < 512; pml4_index++)
					{
						uint64_t pml4_addr = PFN_TO_PAGE(Cr3.pml4_p) + sizeof(PML4E) * pml4_index;
						if (pml4_addr > PhysicalMemorySize)
						{
							continue;
						}
						PML4E* pml4 = (PML4E*)((uintptr_t)PhysicalMemoryBegin + pml4_addr);
						if (pml4->present && pml4->user) {
							for (int pdpt_index = system_range_start.pdpt_index; pdpt_index < 512; pdpt_index++) {

								uintptr_t pdpte_addr = PFN_TO_PAGE(pml4->pdpt_p) + sizeof(PDPTE) * pdpt_index;
								if (pdpte_addr > PhysicalMemorySize)
								{
									continue;
								}

								PDPTE* pdpte = (PDPTE*)((uintptr_t)PhysicalMemoryBegin + pdpte_addr);
								if (!pdpte->present || !pdpte->user)
								{
									continue;
								}

								DPRINT_LOG("(%s) [DETECT] kernelmode memory mapped to usermode: %wZ", __FUNCTION__, walk->ImageName);

								return TRUE;
							}
						}
					}
				}
				__except (EXCEPTION_EXECUTE_HANDLER) {
					DPRINT_LOG("(%s) unexpected AV in detect PI.", __FUNCTION__);
				}
				ObDereferenceObject(process);
			}
			else
			{
				DPRINT_LOG("(%s) Unable to lookup _EPROCESS from PID %d.", __FUNCTION__, (ULONG)walk->UniqueProcessId);
			}
		}
		walk = (PSYSTEM_PROCESS_INFO)((uintptr_t)walk + walk->NextEntryOffset);
	}

	ExFreePoolWithTag(processes, POOL_TAG);
	ZwUnmapViewOfSection(ZwCurrentProcess(), PhysicalMemoryBegin);
	ZwClose(hPhysMem);
}
```

`KernelAntiCheat/Funcs/Protects/ScanPhysMemHandles.c`:

```c
#include "..\funcs.h"
#include "..\log.h"

BOOL ScanPhysMemHandles()
{
	PSYSTEM_HANDLE_INFORMATION handles = GetHandleList();
	if (!handles) {
		DPRINT_LOG("(%s) Unable to obtahandle list.", __FUNCTION__);
		return FALSE;
	}
	UNICODE_STRING phys_mem_str;
	OBJECT_ATTRIBUTES oaAttributes;
	RtlInitUnicodeString(&phys_mem_str, L"\\Device\\PhysicalMemory");
	InitializeObjectAttributes(&oaAttributes, &phys_mem_str, OBJ_CASE_INSENSITIVE | OBJ_KERNEL_HANDLE, (HANDLE)NULL, (PSECURITY_DESCRIPTOR)NULL);
	HANDLE hPhysMem;
	NTSTATUS ntStatus = ZwOpenSection(&hPhysMem, SECTION_ALL_ACCESS, &oaAttributes);

	PVOID Object;
	if (!NT_SUCCESS(ObReferenceObjectByHandle(hPhysMem, 1, NULL, KernelMode, &Object, NULL))) {
		DPRINT_LOG("(%s) Unablle to get PhyiscalMemory object.", __FUNCTION__);
		ExFreePoolWithTag(handles, POOL_TAG);
		ZwClose(hPhysMem);
		return FALSE;
	}

	ZwClose(hPhysMem);

	__try {
		for (ULONG i = 0; i < handles->uCount; i++) {
			if (handles->Handles[i].uIdProcess == 4)
			{
				continue;
			}
			if (handles->Handles[i].pObject == Object) {
				if (!ObIsKernelHandle((HANDLE)handles->Handles[i].Handle)) {
					DPRINT_LOG("(%s) [DETECT] Usermode PhysicalMemory handle detected, pid = %d, access = 0x%x" __FUNCTION__, handles->Handles[i].uIdProcess, handles->Handles[i].GrantedAccess);
					return TRUE;
				}
			}
		}
	}
	__except (EXCEPTION_EXECUTE_HANDLER) {
		DPRINT_LOG("(%s) Unexpected AV", __FUNCTION__);
	}

	ObDereferenceObject(Object);

	ExFreePoolWithTag(handles, POOL_TAG);
	return FALSE;
}
```

`KernelAntiCheat/Funcs/Protects/ScanSSDTHooks.c`:

```c
#include "..\funcs.h"
#include "..\log.h"

BOOL anomaly_check(MEMORY_BASIC_INFORMATION memory_information)
{
	// REPORT ANY EXECUTABLE PAGE OUTSIDE OF KNOWN MODULES
	if (memory_information.Type == MEM_PRIVATE || memory_information.Type == MEM_MAPPED)
	{
		if (((uint64_t)memory_information.BaseAddress & 0xFF0000000000) != 0x7F0000000000 && // UPPER EQUALS 0x7F
			((uint64_t)memory_information.BaseAddress & 0xFFF000000000) != 0x7F000000000 &&  // UPPER EQUALS 0x7F0
			((uint64_t)memory_information.BaseAddress & 0xFFFFF0000000) != 0x70000000 && // UPPER EQUALS 0x70000
			(uint64_t)memory_information.BaseAddress != 0x3E0000)
		{
			DPRINT("DETECT Anomaly");
			return TRUE;
		}
	}
	return FALSE;
}

BOOL CheckSSDT(PSYSTEM_MODULE_INFORMATION modules)
{
	const unsigned char KiSystemServiceStartPattern[] = { 0x8B, 0xF8, 0xC1, 0xEF, 0x07, 0x83, 0xE7, 0x20, 0x25, 0xFF, 0x0F, 0x00, 0x00 };
	const ULONG signatureSize = sizeof(KiSystemServiceStartPattern);

	NTSTATUS status = STATUS_SUCCESS;
	PSYSTEM_MODULE kernel_module = FindModuleInList("ntoskrnl.exe", modules);

	if (!kernel_module)
	{
		DPRINT_LOG("(%s) not found kernelmodule!", __FUNCTION__);
		return FALSE;
	} 

	uint64_t kernel_start = kernel_module->ImageBase;
	uint64_t kernel_end = (uint64_t)kernel_module->ImageBase + kernel_module->ImageSize - 1;

	for (ULONG KiSSSOffset = 0; KiSSSOffset < kernel_module->ImageSize - signatureSize; KiSSSOffset++)
	{
		if (RtlCompareMemory(((unsigned char*)kernel_start + KiSSSOffset), KiSystemServiceStartPattern, signatureSize) == signatureSize)
		{
			uint64_t address = (uint64_t)((uint64_t)kernel_start + KiSSSOffset + signatureSize);
			LONG relativeOffset = 0;
			if ((*(unsigned char*)address == 0x4c) && (*(unsigned char*)(address + 1) == 0x8d) && (*(unsigned char*)(address + 2) == 0x15))
			{
				relativeOffset = *(LONG*)(address + 3);
			}

			if (relativeOffset == 0)
			{
				DPRINT_LOG("(%s) relativeOffset not found.", __FUNCTION__);
				return FALSE;
			}

			SSDT* pServiceDescriptorTable = (SSDT*)(address + relativeOffset + 7);

			DWORD* kist = pServiceDescriptorTable->KiServiceTable;
			DWORD num_sys_calls = pServiceDescriptorTable->nSystemCalls;

			for (ULONG ulServiceIndex = 0; ulServiceIndex < num_sys_calls; ulServiceIndex++, kist++)
			{
				if (IsAddressOutsideModuleList(modules, kist))
				{
					DPRINT_LOG("(%s) SSDT hook detect by address: %p", __FUNCTION__, kist);
					return TRUE;
				}
			}
		}
	}

	if (IsAddressOutsideModuleList(modules, kernel_start))
	{
		DPRINT("(%s)_1 Kernel detected: %p", __FUNCTION__, (uint64_t*)kernel_start);
	}

	for (uint64_t* kernel = kernel_module->ImageBase; kernel <= kernel_end; kernel++)
	{
		if (IsAddressOutsideModuleList(modules, kernel))
		{
			DPRINT("(%s)_2 Kernel detected: %p", __FUNCTION__, kernel);
		}
	}
	/*MEMORY_BASIC_INFORMATION  memory_information;
	LONG return_length;
	for (uint64_t current_address = kernel_module->ImageBase;
		NtQueryVirtualMemory(PsGetCurrentProcess(), current_address, 0, &memory_information, 0x30, &return_length) >= 0;
		current_address = (uint64_t)memory_information.BaseAddress + memory_information.RegionSize)
	{

		BOOL executable_memory =
			memory_information.State == MEM_COMMIT &&
			(memory_information.Protect == PAGE_EXECUTE ||
				memory_information.Protect == PAGE_EXECUTE_READ ||
				memory_information.Protect == PAGE_EXECUTE_READWRITE);

			BOOL unknown_whitelist =
			memory_information.Protect != PAGE_EXECUTE_READWRITE ||
			memory_information.RegionSize != 100000000;

			if (!executable_memory || !unknown_whitelist)
				continue;

			anomaly_check(memory_information);
	}*/

	return FALSE;
}
```

`KernelAntiCheat/Funcs/Protects/ScanSysThreads.c`:

```c
#include "..\funcs.h"
#include "..\log.h"

BOOL ScanSysThreads(PSYSTEM_MODULE_INFORMATION pModuleList)
{
	SleepThread(1000);
	for (ULONG thrd_id = 4; thrd_id < 0x30000; thrd_id += 4)
	{
		PETHREAD ThreadObj;

		if (!NT_SUCCESS(PsLookupThreadByThreadId((HANDLE)(thrd_id), &ThreadObj)))
		{
			continue;
		}

		if (!PsIsSystemThread(ThreadObj) || ThreadObj == KeGetCurrentThread())//ignore system threads
		{
			continue;
		}

		uintptr_t start_addr;

		GetThreadStartAddress(ThreadObj, &start_addr);

		if (IsAddressOutsideModuleList(pModuleList, start_addr) || (start_addr && (memcmp((void*)start_addr, "\xFF\xE1", 2) == 0)))
		{
			DPRINT_LOG("(%s) Offending stream found: id = %u   address = 0x%X", __FUNCTION__, thrd_id, start_addr);
			return TRUE;
		}
	}
	return FALSE;
}
```

`KernelAntiCheat/Funcs/Protects/ScanUnloadedDrivers.c`:

```c
#include "..\funcs.h"
PUNLOADED_DRIVERS MmUnloadedDrivers;

```

`KernelAntiCheat/Funcs/Signature/ValidateSignature.c`:

```c
#include "ValidateSignature.h"
#include "..\..\Natives\Windows\ci.h"
#include "..\..\Natives\stdint.h"
#define SHA1_IDENTIFIER 0x8004
#define SHA256_IDENTIFIER 0x800C
#define IMAGE_DIRECTORY_ENTRY_SECURITY  4


PVOID RtlImageDirectoryEntryToData(PVOID BaseAddress, BOOLEAN MappedAsImage, USHORT Directory, PULONG Size);
BOOL inRange(const BYTE* rangeStartAddr, const BYTE* rangeEndAddr, const BYTE* addrToCheck);
VOID parsePolicyInfo(const pPolicyInfo policyInfo);
BOOL ciCheckSignedFileWrapper(const LPWIN_CERTIFICATE win_cert, ULONG sizeOfSecurityDirectory);

void validateFileUsingCiValidateFileObject(PFILE_OBJECT fileObject)
{
    KdPrint(("Validating file using CiValidateFileObject...\n"));
    NT_ASSERT(KeGetCurrentIrql() < DISPATCH_LEVEL);

    PolicyInfo signerPolicyInfo;
    PolicyInfo timestampingAuthorityPolicyInfo;
    LARGE_INTEGER signingTime = { 0 };
    int digestSize = 64;
    int digestIdentifier = 0;
    BYTE digestBuffer[64] = { 0 };

    const NTSTATUS status = CiValidateFileObject(
        fileObject,
        0,
        0,
        &signerPolicyInfo,
        &timestampingAuthorityPolicyInfo,
        &signingTime,
        digestBuffer,
        &digestSize,
        &digestIdentifier
    );

    KdPrint(("CiValidateFileObject returned 0x%08X\n", status));
    if (NT_SUCCESS(status))
    {
        parsePolicyInfo(&signerPolicyInfo);
        return;
    }
}

void parsePolicyInfo(const pPolicyInfo policyInfo)
{
    if (policyInfo == NULL)
    {
        KdPrint(("parsePolicyInfo - paramter is null\n"));
        return;
    }

    if (policyInfo->structSize == 0)
    {
        KdPrint(("policy info is empty\n"));
        return;
    }

    if (policyInfo->certChainInfo == NULL)
    {
        KdPrint(("certChainInfo is null\n"));
        return;
    }

    const pCertChainInfoHeader chainInfoHeader = policyInfo->certChainInfo;

    const BYTE* startOfCertChainInfo = (BYTE*)(chainInfoHeader);
    const BYTE* endOfCertChainInfo = (BYTE*)(policyInfo->certChainInfo) + chainInfoHeader->bufferSize;

    if (!inRange(startOfCertChainInfo, endOfCertChainInfo, (BYTE*)chainInfoHeader->ptrToCertChainMembers))
    {
        KdPrint(("chain members out of range\n"));
        return;
    }

    // need to make sure we have enough room to accomodate the chain member struct
    if (!inRange(startOfCertChainInfo, endOfCertChainInfo, (BYTE*)chainInfoHeader->ptrToCertChainMembers + sizeof(CertChainMember)))
    {
        KdPrint(("chain member out of range\n"));
        return;
    }

    // we are interested in the first certificate in the chain - the signer itself
    pCertChainMember signerChainMember = chainInfoHeader->ptrToCertChainMembers;

    KdPrint(("Signer certificate:\n  digest algorithm - 0x%x\n  size - %zu\n  subject - %.*s\n  issuer - %.*s\n", \
        signerChainMember->digestIdetifier, \
        signerChainMember->certificate.size, \
        signerChainMember->subjectName.nameLen, \
        (char*)(signerChainMember->subjectName.pointerToName), \
        signerChainMember->issuerName.nameLen, \
        (char*)(signerChainMember->issuerName.pointerToName))                                            \
    );

    UNREFERENCED_PARAMETER(signerChainMember);
}

BOOL inRange(const BYTE* rangeStartAddr, const BYTE* rangeEndAddr, const BYTE* addrToCheck)
{
    if (addrToCheck > rangeEndAddr || addrToCheck < rangeStartAddr)
    {
        return FALSE;
    }

    return TRUE;
}

```

`KernelAntiCheat/Funcs/Signature/ValidateSignature.h`:

```h
#pragma once

#include <wdm.h>


void validateFileUsingCiValidateFileObject(PFILE_OBJECT FileObject);
void validateFileUsingCiCheckSignedFile(PCUNICODE_STRING imageFileName);

```

`KernelAntiCheat/Funcs/funcs.h`:

```h
#pragma once
#include <intrin.h>
#include "utils.h"
#include "..\Natives\Imports.h"

BOOL ScanSysThreads(PSYSTEM_MODULE_INFORMATION pModuleList);
BOOL ScanBigPool();
BOOL ScanPIDDB();
BOOL ScanHV();
BOOL ScanPhysMemHandles();
BOOL ScanPerfectInjector();
BOOL ScanDispatchDrivers(PSYSTEM_MODULE_INFORMATION pModuleList);
BOOL ScanCodeIntegrity();
BOOL CheckSSDT(PSYSTEM_MODULE_INFORMATION modules);
```

`KernelAntiCheat/Funcs/log.c`:

```c
#include "log.h"
#include "utils.h"
#include <Ntstrsafe.h>

HANDLE g_fHandle;
PCWSTR path_to_log = L"\\??\\C:\\uac_log.txt";
UNICODE_STRING     uniName;
IO_STATUS_BLOCK    ioStatusBlock;
OBJECT_ATTRIBUTES  objAttr;
NTSTATUS ntstatus = STATUS_SUCCESS;

VOID LogWrite(const char* text, ...)
{
    if (!g_fHandle)
    {
        DPRINT("(%s) g_fHandle is null (file not open or not created)", __FUNCTION__);
        return;
    }

    if (KeGetCurrentIrql() != PASSIVE_LEVEL)
    {
        return;
    }

    char tmp[2048];
    va_list(args);
    va_start(args, text);
    vsprintf(tmp, text, args);

    char buffer[2048] = "UAC - ";
    strcat(buffer, tmp);
    strcat(buffer, "\n");

    size_t  cb;
    LARGE_INTEGER ByteOffset;

    ByteOffset.HighPart = -1;
    ByteOffset.LowPart = FILE_WRITE_TO_END_OF_FILE;

    if (NT_SUCCESS(ntstatus = RtlStringCbLengthA(buffer, sizeof(buffer), &cb)))
    {
        if (!NT_SUCCESS(ntstatus = ZwWriteFile(g_fHandle, NULL, NULL, NULL, &ioStatusBlock, buffer, (ULONG)cb, &ByteOffset, NULL)))
        {
            DPRINT("(%s) Error write log, code: 0x%X", __FUNCTION__, ntstatus);
        }
    }
}

VOID LogClose()
{
    ZwClose(g_fHandle);
}

HANDLE LogOpen()
{
    RtlInitUnicodeString(&uniName, path_to_log);
    InitializeObjectAttributes(&objAttr, &uniName, OBJ_CASE_INSENSITIVE | OBJ_KERNEL_HANDLE, NULL, NULL);

    if (KeGetCurrentIrql() != PASSIVE_LEVEL)
    {
        return NULL;
    }

    ZwDeleteFile(&objAttr);
    SleepThread(100);

    if (!NT_SUCCESS(ntstatus = ZwCreateFile(&g_fHandle, GENERIC_WRITE, &objAttr, &ioStatusBlock, NULL, FILE_ATTRIBUTE_NORMAL, 0, FILE_OPEN_IF, FILE_SYNCHRONOUS_IO_NONALERT, NULL, 0)))
    {
        DPRINT("(%s) ZwCreateFile error 0x%X", __FUNCTION__, ntstatus);
        return NULL;
    }

    char buffer[2048] = { "\n_____________UAC Developer platform_____________\nVersion: 1.0\n" };
    size_t  cb;
    LARGE_INTEGER ByteOffset = { 0 };

    if (NT_SUCCESS(ntstatus = RtlStringCbLengthA(buffer, sizeof(buffer), &cb)))
    {
        ntstatus = ZwWriteFile(g_fHandle, NULL, NULL, NULL, &ioStatusBlock, buffer, (ULONG)cb, &ByteOffset, NULL);
    }

    return g_fHandle;
}
```

`KernelAntiCheat/Funcs/log.h`:

```h
#pragma once
#include <ntifs.h>

#define DPRINT_LOG(message, ...) LogWrite(message, __VA_ARGS__);

VOID LogClose();
HANDLE LogOpen();
VOID LogWrite(const char* text, ...);
```

`KernelAntiCheat/Funcs/utils.c`:

```c
#include "log.h"
#include "utils.h"
#include <Ntstrsafe.h>

PVOID g_KernelBase;
ULONG g_KernelSize;

char* JoinText(char* format, ...)
{
    char buff[2048];
    va_list(args);
    va_start(args, format);
    vsprintf(buff, format, args);
    return buff;
}

PVOID GetModuleBaseAddress(PCHAR name)
{
    PVOID addr = 0;

    ULONG size = 0;
    NTSTATUS status = ZwQuerySystemInformation(SystemModuleInformation, 0, 0, &size);
    if (STATUS_INFO_LENGTH_MISMATCH != status) {
        return addr;
    }

    PSYSTEM_MODULE_INFORMATION modules = ExAllocatePoolWithTag(NonPagedPool, size, POOL_TAG);
    if (!modules) {
        return addr;
    }

    if (!NT_SUCCESS(status = ZwQuerySystemInformation(SystemModuleInformation, modules, size, 0))) {
        ExFreePool(modules);
        return addr;
    }

    for (ULONG i = 0; i < modules->NumberOfModules; ++i) {
        SYSTEM_MODULE m = modules->Modules[i];

        if (strstr((PCHAR)m.FullPathName, name)) {
            addr = m.ImageBase;
            break;
        }
    }

    ExFreePool(modules);
    return addr;
}

PVOID GetKernelBase()
{
    NTSTATUS status = STATUS_SUCCESS;
    ULONG bytes = 0;
    PRTL_PROCESS_MODULES pMods = NULL;
    PVOID checkPtr = NULL;
    UNICODE_STRING routineName;

    if (g_KernelBase != NULL)
    {
        return g_KernelBase;
    }

    RtlUnicodeStringInit(&routineName, L"NtOpenFile");

    checkPtr = MmGetSystemRoutineAddress(&routineName);
    if (checkPtr == NULL)
    {
        DPRINT_LOG("(%s) checkPtr is null!", __FUNCTION__);
        return NULL;
    }

    status = ZwQuerySystemInformation(SystemModuleInformation, 0, bytes, &bytes);
    if (bytes == 0)
    {
        DPRINT_LOG("(%s) Invalid SystemModuleInformation size", __FUNCTION__);
        return NULL;
    }

    pMods = (PRTL_PROCESS_MODULES)ExAllocatePoolWithTag(NonPagedPool, bytes, POOL_TAG);

    if (pMods)
    {
        RtlZeroMemory(pMods, bytes);
    }

    status = ZwQuerySystemInformation(SystemModuleInformation, pMods, bytes, &bytes);

    if (NT_SUCCESS(status) && pMods)
    {
        PRTL_PROCESS_MODULE_INFORMATION pMod = pMods->Modules;

        for (ULONG i = 0; i < pMods->NumberOfModules; i++)
        {
            if (checkPtr >= pMod[i].ImageBase &&
                checkPtr < (PVOID)((PUCHAR)pMod[i].ImageBase + pMod[i].ImageSize))
            {
                g_KernelBase = pMod[i].ImageBase;
                break;
            }
        }
    }

    if (pMods)
    {
        ExFreePoolWithTag(pMods, POOL_TAG);
    }

    return g_KernelBase;
}

PVOID GetKernelBaseWithSize(ULONG* Size)
{
    NTSTATUS status = STATUS_SUCCESS;
    ULONG bytes = 0;
    PRTL_PROCESS_MODULES pMods = NULL;
    PVOID checkPtr = NULL;
    UNICODE_STRING routineName;

    if (g_KernelBase != NULL && g_KernelSize != NULL)
    {
        *Size = g_KernelSize;
        return g_KernelBase;
    }

    RtlUnicodeStringInit(&routineName, L"NtOpenFile");

    checkPtr = MmGetSystemRoutineAddress(&routineName);
    if (checkPtr == NULL)
    {
        DPRINT_LOG("(%s) checkPtr is null!", __FUNCTION__);
        return NULL;
    }

    status = ZwQuerySystemInformation(SystemModuleInformation, 0, bytes, &bytes);
    if (bytes == 0)
    {
        DPRINT_LOG("(%s) Invalid SystemModuleInformation size", __FUNCTION__);
        return NULL;
    }

    pMods = (PRTL_PROCESS_MODULES)ExAllocatePoolWithTag(NonPagedPool, bytes, POOL_TAG);

    if (pMods)
    {
        RtlZeroMemory(pMods, bytes);
    }

    status = ZwQuerySystemInformation(SystemModuleInformation, pMods, bytes, &bytes);

    if (NT_SUCCESS(status) && pMods)
    {
        PRTL_PROCESS_MODULE_INFORMATION pMod = pMods->Modules;

        for (ULONG i = 0; i < pMods->NumberOfModules; i++)
        {
            if (checkPtr >= pMod[i].ImageBase && checkPtr < (PVOID)((PUCHAR)pMod[i].ImageBase + pMod[i].ImageSize))
            {
                g_KernelBase = pMod[i].ImageBase;
                g_KernelSize = pMod[i].ImageSize;
                *Size = g_KernelSize;
                break;
            }
        }
    }

    if (pMods)
    {
        ExFreePoolWithTag(pMods, POOL_TAG);
    }

    return g_KernelBase;
}

PVOID GetProcAddress(ULONG_PTR DllBase, PCCH RoutineName)
{
    const PIMAGE_DOS_HEADER DosHeader = (PIMAGE_DOS_HEADER)(DllBase);
    if (DosHeader->e_magic != IMAGE_DOS_SIGNATURE)
        return NULL;
    const PIMAGE_NT_HEADERS NtHeaders = (PIMAGE_NT_HEADERS)(DllBase + DosHeader->e_lfanew);
    if (NtHeaders->Signature != IMAGE_NT_SIGNATURE)
        return NULL;

    const PIMAGE_DATA_DIRECTORY ImageDirectories = HEADER_FIELD(NtHeaders, DataDirectory);
    const ULONG ExportDirRva = ImageDirectories[IMAGE_DIRECTORY_ENTRY_EXPORT].VirtualAddress;
    const ULONG ExportDirSize = ImageDirectories[IMAGE_DIRECTORY_ENTRY_EXPORT].Size;

    const PIMAGE_EXPORT_DIRECTORY ExportDirectory = (PIMAGE_EXPORT_DIRECTORY)(DllBase + ExportDirRva);
    const PULONG AddressOfFunctions = (PULONG)(DllBase + ExportDirectory->AddressOfFunctions);
    const PUSHORT AddressOfNameOrdinals = (PUSHORT)(DllBase + ExportDirectory->AddressOfNameOrdinals);
    const PULONG AddressOfNames = (PULONG)(DllBase + ExportDirectory->AddressOfNames);

    LONG Low = 0;
    LONG Middle = 0;
    LONG High = ExportDirectory->NumberOfNames - 1;

    while (High >= Low)
    {
        Middle = (Low + High) >> 1;
        const LONG Result = strcmp(RoutineName, (PCHAR)(DllBase + AddressOfNames[Middle]));
        if (Result < 0)
            High = Middle - 1;
        else if (Result > 0)
            Low = Middle + 1;
        else
            break;
    }

    if (High < Low || Middle >= (LONG)(ExportDirectory->NumberOfFunctions))
        return NULL;
    const ULONG FunctionRva = AddressOfFunctions[AddressOfNameOrdinals[Middle]];
    if (FunctionRva >= ExportDirRva && FunctionRva < ExportDirRva + ExportDirSize)
        return NULL;

    return (PVOID)(DllBase + FunctionRva);
}

BOOLEAN CheckMask(PCHAR base, PCHAR pattern, PCHAR mask) 
{
    for (; *mask; ++base, ++pattern, ++mask) {
        if (*mask == 'x' && *base != *pattern) {
            return FALSE;
        }
    }

    return TRUE;
}

PVOID FindPattern(PCHAR base, DWORD length, PCHAR pattern, PCHAR mask)
{
    length -= (DWORD)strlen(mask);
    for (DWORD i = 0; i <= length; ++i) {
        PVOID addr = &base[i];
        if (CheckMask(addr, pattern, mask)) {
            return addr;
        }
    }

    return 0;
}

PVOID FindPatternImage(PCHAR base, PCHAR pattern, PCHAR mask)
{
    PVOID match = 0;

    PIMAGE_NT_HEADERS headers = (PIMAGE_NT_HEADERS)(base + ((PIMAGE_DOS_HEADER)base)->e_lfanew);
    PIMAGE_SECTION_HEADER sections = IMAGE_FIRST_SECTION(headers);
    for (DWORD i = 0; i < headers->FileHeader.NumberOfSections; ++i) {
        PIMAGE_SECTION_HEADER section = &sections[i];
        if (*(PINT)section->Name == 'EGAP' || memcmp(section->Name, ".text", 5) == 0) {
            match = FindPattern(base + section->VirtualAddress, section->Misc.VirtualSize, pattern, mask);
            if (match) {
                break;
            }
        }
    }

    return match;
}

NTSTATUS SearchPattern(PCUCHAR pattern, UCHAR wildcard, ULONG_PTR len, const VOID* base, ULONG_PTR size, PVOID* ppFound, int index)
{
    ASSERT(ppFound != NULL && pattern != NULL && base != NULL);

    if (ppFound == NULL || pattern == NULL || base == NULL)
    {
        DPRINT_LOG("(%s) One or more args is null", __FUNCTION__);
        return STATUS_ACCESS_DENIED;
    }
    int cIndex = 0;
    for (ULONG_PTR i = 0; i < size - len; i++)
    {
        BOOLEAN found = TRUE;
        for (ULONG_PTR j = 0; j < len; j++)
        {
            if (pattern[j] != wildcard && pattern[j] != ((PCUCHAR)base)[i + j])
            {
                found = FALSE;
                break;
            }
        }

        if (found != FALSE && cIndex++ == index)
        {
            *ppFound = (PUCHAR)base + i;
            return STATUS_SUCCESS;
        }
    }

    return STATUS_NOT_FOUND;
}

NTSTATUS ScanSection(PCCHAR section, PCUCHAR pattern, UCHAR wildcard, ULONG_PTR len, PVOID* ppFound)
{
    if (ppFound == NULL)
    {
        DPRINT_LOG("(%s) ppFound is null", __FUNCTION__);
        return STATUS_ACCESS_DENIED;
    }

    PVOID base = GetKernelBase();
    if (base == NULL)
    {
        DPRINT_LOG("(%s) base is null", __FUNCTION__);
        return STATUS_ACCESS_DENIED;
    }

    PIMAGE_NT_HEADERS64 pHdr = RtlImageNtHeader(base);
    if (!pHdr)
    {
        DPRINT_LOG("(%s) pHdr is null", __FUNCTION__);
        return STATUS_ACCESS_DENIED;
    }

    PIMAGE_SECTION_HEADER pFirstSection = (PIMAGE_SECTION_HEADER)((uintptr_t)&pHdr->FileHeader + pHdr->FileHeader.SizeOfOptionalHeader + sizeof(IMAGE_FILE_HEADER));

    for (PIMAGE_SECTION_HEADER pSection = pFirstSection; pSection < pFirstSection + pHdr->FileHeader.NumberOfSections; pSection++)
    {
        ANSI_STRING s1, s2;
        RtlInitAnsiString(&s1, section);
        RtlInitAnsiString(&s2, (PCCHAR)pSection->Name);
        if (RtlCompareString(&s1, &s2, TRUE) == 0)
        {
            PVOID ptr = NULL;
            NTSTATUS status = SearchPattern(pattern, wildcard, len, (PUCHAR)base + pSection->VirtualAddress, pSection->Misc.VirtualSize, &ptr, 0);
            if (NT_SUCCESS(status)) {
                *(PULONG64)ppFound = (ULONG_PTR)(ptr);
                return status;
            }
        }
    }
    return STATUS_NOT_FOUND;
}

PSYSTEM_HANDLE_INFORMATION GetHandleList()
{
    NTSTATUS status = STATUS_SUCCESS;
    ULONG neededSize = 0;

    neededSize = 8 * 1024 * 1024;

    PSYSTEM_HANDLE_INFORMATION pHandleList;

    if (pHandleList = (PSYSTEM_HANDLE_INFORMATION)ExAllocatePoolWithTag(NonPagedPool, neededSize, POOL_TAG)) {

        NTSTATUS r;
        if (NT_SUCCESS(r = ZwQuerySystemInformation(SystemHandleInformation, pHandleList, neededSize, 0)))
        {
            return pHandleList;
        }
        else
        {
            DPRINT_LOG("(%s) r = %x", __FUNCTION__, r);
        }
    }
    return NULL;
}

PSYSTEM_PROCESS_INFO GetProcList()
{
    NTSTATUS status = STATUS_SUCCESS;
    ULONG neededSize = 0;

    neededSize = 8 * 1024 * 1024;

    PSYSTEM_PROCESS_INFO pProcessList;

    if (pProcessList = (PSYSTEM_PROCESS_INFO)ExAllocatePoolWithTag(NonPagedPool, neededSize, POOL_TAG)) {

        NTSTATUS r;
        if (NT_SUCCESS(r = ZwQuerySystemInformation(SystemProcessInformation, pProcessList, neededSize, 0)))
        {
            return pProcessList;
        }
        else 
        {
            DPRINT_LOG("(%s) r = 0x%X", __FUNCTION__, r);
        }
    }
    return NULL;

}

PSYSTEM_MODULE_INFORMATION GetKernelModuleList()
{
    NTSTATUS status = STATUS_SUCCESS;
    ULONG neededSize = 0;

    ZwQuerySystemInformation(
        SystemModuleInformation,
        &neededSize,
        0,
        &neededSize
    );

    PSYSTEM_MODULE_INFORMATION pModuleList;

    pModuleList = (PSYSTEM_MODULE_INFORMATION)ExAllocatePoolWithTag(NonPagedPool, neededSize, POOL_TAG);
    if (pModuleList == NULL)
    {
        return FALSE;
    }

    status = ZwQuerySystemInformation(SystemModuleInformation,
        pModuleList,
        neededSize,
        0
    );

    return pModuleList;
}

VOID PrintModuleName(PSYSTEM_MODULE_INFORMATION pModuleList, uintptr_t addr)
{
    if (addr == NULL)
        return;
    __try {
        for (ULONG i = 0; i < pModuleList->NumberOfModules; i++)
        {
            if (addr >= (uintptr_t)(pModuleList->Modules[i].ImageBase) && addr <
                (uintptr_t)(pModuleList->Modules[i].ImageBase) + pModuleList->Modules[i].ImageSize) {
                USHORT name_offset = pModuleList->Modules[i].OffsetToFileName;
                if (name_offset > 256)
                    continue;
                DPRINT_LOG("(%s) module: %s", __FUNCTION__, &pModuleList->Modules[i].FullPathName[name_offset]);
                return;
            }
        }
    }
    __except (EXCEPTION_EXECUTE_HANDLER) {
        DPRINT_LOG("(%s) Access Violation was raised.", __FUNCTION__);
    }
    DPRINT_LOG("(%s) Module: <unknown>", __FUNCTION__);
}

BOOL IsAddressOutsideModuleList(PSYSTEM_MODULE_INFORMATION pModuleList, uint64_t* addr)
{
    if (addr == NULL)
        return FALSE;
    __try {
        for (ULONG i = 0; i < pModuleList->NumberOfModules; i++)
        {
            if (addr >= (uint64_t*)(pModuleList->Modules[i].ImageBase) && addr < (uint64_t*)((uint64_t*)pModuleList->Modules[i].ImageBase + pModuleList->Modules[i].ImageSize - 1)) 
            {
                return FALSE;
            }
        }
    }
    __except (EXCEPTION_EXECUTE_HANDLER) {
        DPRINT_LOG("(%s) Access Violation was raised!", __FUNCTION__);
    }
    return TRUE;
}

PSYSTEM_MODULE FindModuleInList(char* imageName, PSYSTEM_MODULE_INFORMATION pModuleList)
{
    for (int i = 0; i < pModuleList->NumberOfModules; i++)
    {
        if (strstr(pModuleList->Modules[i].FullPathName, imageName) != NULL)
        {
            return &(pModuleList->Modules[i]);
        }
    }
    return NULL;
}

NTSTATUS GetThreadStartAddress(PETHREAD ThreadObj, uintptr_t* pStartAddr)
{
    *pStartAddr = NULL;
    HANDLE hThread;
    NTSTATUS status = STATUS_SUCCESS;
    if (!NT_SUCCESS(status = ObOpenObjectByPointer(ThreadObj, OBJ_KERNEL_HANDLE, NULL, GENERIC_READ, *PsThreadType, KernelMode, &hThread))) {
        DPRINT_LOG("(%s) ObOpenObjectByPointer failed, code: 0x%p", __FUNCTION__, status);
        return status;
    }

    uintptr_t start_addr;
    ULONG returned_bytes;

    if (!NT_SUCCESS(status = NtQueryInformationThread(hThread, ThreadQuerySetWin32StartAddress, &start_addr, sizeof(start_addr), &returned_bytes))) {
        DPRINT_LOG("(%s) NtQueryInformationThread failed, code: 0x%p", __FUNCTION__, status);
        NtClose(hThread);
        return status;
    }

    if (MmIsAddressValid((void*)start_addr))
        *pStartAddr = start_addr;

    NtClose(hThread);

    return status;
}

PVOID FindModule(const wchar_t* NameModule)
{
    UNICODE_STRING routineName;
    RtlInitUnicodeString(&routineName, NameModule);
    return MmGetSystemRoutineAddress(&routineName);
}

NTSTATUS RtlOpenFile(PCWCHAR Filename, PHANDLE FileHandle)
{
    IO_STATUS_BLOCK    ioStatusBlock;
    OBJECT_ATTRIBUTES  objAttr;
    HANDLE t_fHandle;
    UNICODE_STRING uniName;
    RtlInitUnicodeString(&uniName, Filename);

    InitializeObjectAttributes(&objAttr, &uniName, OBJ_CASE_INSENSITIVE, NULL, NULL);

    NTSTATUS ntstatus = NtCreateFile(&t_fHandle, FILE_GENERIC_READ | SYNCHRONIZE, &objAttr, &ioStatusBlock, NULL, FILE_ATTRIBUTE_NORMAL, FILE_SHARE_READ, FILE_OPEN, FILE_NON_DIRECTORY_FILE | FILE_SYNCHRONOUS_IO_NONALERT, NULL, 0);
    *FileHandle = t_fHandle;
    return ntstatus;
}

NTSTATUS LoadLibrary(PCWCHAR Filename, PVOID* ImageBase, PSIZE_T ViewSize)
{
    *ImageBase = NULL;
    *ViewSize = 0;

    HANDLE t_fHandle;

    NTSTATUS Status = RtlOpenFile(Filename, &t_fHandle);
    if (!NT_SUCCESS(Status))
    {
        DPRINT_LOG("(%s) error NtCreateFile: 0x%X", __FUNCTION__, Status);
        return Status;
    }

    HANDLE SectionHandle;
    Status = NtCreateSection(&SectionHandle, STANDARD_RIGHTS_REQUIRED | SECTION_MAP_READ, NULL, NULL, PAGE_READONLY, SEC_IMAGE, t_fHandle);
    if (!NT_SUCCESS(Status))
    {
        DPRINT_LOG("(%s) error NtCreateSection: 0x%X", __FUNCTION__, Status);
        NtClose(t_fHandle);
        return Status;
    }

    Status = ZwMapViewOfSection(SectionHandle, NtCurrentProcess(), ImageBase, 0, 0, NULL, ViewSize, ViewUnmap, 0, PAGE_READONLY);

    if (Status == STATUS_IMAGE_NOT_AT_BASE)
    {
        Status = STATUS_SUCCESS;
    }
    if (!NT_SUCCESS(Status))
    {
        DPRINT_LOG("(%s) error NtMapViewOfSection: 0x%X", __FUNCTION__, Status);
    }

    NtClose(SectionHandle);
    NtClose(t_fHandle);

    return Status;
}

EXTERN_C PVOID ResolveRelativeAddress( PVOID Instruction,  ULONG OffsetOffset,  ULONG InstructionSize)
{
    ULONG_PTR Instr = (ULONG_PTR)Instruction;
    LONG RipOffset = *(PLONG)(Instr + OffsetOffset);
    PVOID ResolvedAddr = (PVOID)(Instr + InstructionSize + RipOffset);

    return ResolvedAddr;
}

VOID SleepThread(LONG milliseconds)
{
    LARGE_INTEGER interval;
    interval.QuadPart = -(10000ll * milliseconds);

    KeDelayExecutionThread(KernelMode, FALSE, &interval);
}

BOOL CheckSignedFile(PWCHAR filePath)
{
    HANDLE FileHandle;
    PFILE_OBJECT fileObject;
    NTSTATUS status = STATUS_SUCCESS;
    NT_ASSERT(KeGetCurrentIrql() < DISPATCH_LEVEL);
    
    if (!NT_SUCCESS(status = RtlOpenFile(filePath, &FileHandle)))
    {
        DPRINT_LOG("(%s) error open file, error code: 0x%X   path = %ws", __FUNCTION__, status, filePath);
        return FALSE;
    }
    
    if (!NT_SUCCESS(status = ObReferenceObjectByHandle(FileHandle, NULL, NULL, KernelMode, &fileObject, NULL))) 
    {
        DPRINT_LOG("(%s) error open handle, error code: 0x%X", __FUNCTION__, status);
        ZwClose(FileHandle);
        return FALSE;
    }

    PolicyInfo signerPolicyInfo;
    PolicyInfo timestampingAuthorityPolicyInfo;
    LARGE_INTEGER signingTime = { 0 };
    int digestSize = 64;
    int digestIdentifier = 0;
    BYTE digestBuffer[64] = { 0 };

    status = CiValidateFileObject(fileObject, 0, 0, &signerPolicyInfo, &timestampingAuthorityPolicyInfo, &signingTime, digestBuffer, &digestSize, &digestIdentifier);

    ZwClose(FileHandle);
    ObReferenceObject(fileObject);

    return NT_SUCCESS(status);
}
```

`KernelAntiCheat/Funcs/utils.h`:

```h
#include <ntifs.h>
#include <windef.h>
#include <classpnp.h>
#include "..\Natives\Imports.h"
#include "..\Natives\Windows\ci.h"

#define DPRINT(message, ...) \
	DbgPrintEx(0, 0, "[UAC] - "); \
	DbgPrintEx(0, 0, message, __VA_ARGS__); \
	DbgPrintEx(0, 0, "\n");

#define DPRINT_STATUS(func_check, status) \
	DbgPrintEx(0, 0, "[UAC] - Scan "); \
	DbgPrintEx(0, 0, func_check); \
	DbgPrintEx(0, 0, ": "); \
	DbgPrintEx(0, 0, status ? "[DETECT]\n" : "[OK]\n"); \

#define POOL_TAG 'ek4C'
#define PAGE_MASK (~(PAGE_SIZE-1))

#define PFN_TO_PAGE(pfn) (pfn << PAGE_SHIFT)
#define PAGE_TO_PFN(pfn) (pfn >> PAGE_SHIFT)

extern POBJECT_TYPE* IoDriverObjectType;

char* JoinText(char* format, ...);

PVOID GetModuleBaseAddress(PCHAR name);

PVOID GetKernelBase();

PVOID GetKernelBaseWithSize(ULONG* Size);

PVOID FindPatternImage(PCHAR base, PCHAR pattern, PCHAR mask);

BOOLEAN CheckMask(PCHAR base, PCHAR pattern, PCHAR mask);

PVOID FindPattern(PCHAR base, DWORD length, PCHAR pattern, PCHAR mask);

NTSTATUS LoadLibrary(PCWCHAR Filename, PVOID* ImageBase, PSIZE_T ViewSize);

NTSTATUS RtlOpenFile(PCWCHAR Filename, PHANDLE FileHandle);

NTSTATUS ScanSection(PCCHAR section, PCUCHAR pattern, UCHAR wildcard, ULONG_PTR len, PVOID* ppFound);

NTSTATUS SearchPattern(PCUCHAR pattern, UCHAR wildcard, ULONG_PTR len, const VOID* base, ULONG_PTR size, PVOID* ppFound, int index);

PSYSTEM_HANDLE_INFORMATION GetHandleList();

PSYSTEM_PROCESS_INFO GetProcList();

PVOID GetProcAddress(ULONG_PTR DllBase, PCCH RoutineName);

VOID PrintModuleName(PSYSTEM_MODULE_INFORMATION pModuleList, uintptr_t addr);

PSYSTEM_MODULE_INFORMATION GetKernelModuleList();

PVOID FindModule(const wchar_t* NameModule);

EXTERN_C PVOID ResolveRelativeAddress( PVOID Instruction,  ULONG OffsetOffset,  ULONG InstructionSize);

VOID SleepThread(LONG milliseconds);

NTSTATUS GetThreadStartAddress(PETHREAD ThreadObj, uintptr_t* pStartAddr);

BOOL IsAddressOutsideModuleList(PSYSTEM_MODULE_INFORMATION pModuleList, uint64_t* addr);

PSYSTEM_MODULE FindModuleInList(char* imageName, PSYSTEM_MODULE_INFORMATION pModuleList);

BOOL CheckSignedFile(PWCHAR filePath);
```

`KernelAntiCheat/KernelAntiCheat.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Win10Debug|x64">
      <Configuration>Win10Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Win10Release|x64">
      <Configuration>Win10Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <ProjectName>KernelAntiCheat</ProjectName>
    <ProjectGuid>{AA863813-E90A-4DF9-B032-839573C0DD54}</ProjectGuid>
    <WindowsTargetPlatformVersion>$(LatestTargetPlatformVersion)</WindowsTargetPlatformVersion>
  </PropertyGroup>
  <PropertyGroup Label="PropertySheets">
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>WDM</DriverType>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Win10Debug|x64'" Label="Configuration">
    <TargetVersion>
    </TargetVersion>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <DriverTargetPlatform>Desktop</DriverTargetPlatform>
    <SupportsPackaging>false</SupportsPackaging>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Win10Release|x64'" Label="Configuration">
    <TargetVersion>
    </TargetVersion>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <DriverTargetPlatform>Desktop</DriverTargetPlatform>
    <SupportsPackaging>false</SupportsPackaging>
    <ALLOW_DATE_TIME>
    </ALLOW_DATE_TIME>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup>
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Win10Debug|x64'">
    <OutDir>..\Build\</OutDir>
    <TimeStampServer>http://timestamp.verisign.com/scripts/timstamp.dll</TimeStampServer>
    <IntDir>..\Build\Cache\</IntDir>
    <TargetName>$(TargetName)</TargetName>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Win10Release|x64'">
    <OutDir>..\Build\</OutDir>
    <IntDir>..\Build\Cache\</IntDir>
    <TargetName>$(TargetName)</TargetName>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Win10Debug|x64'">
    <ClCompile>
      <CompileAs>Default</CompileAs>
      <AdditionalIncludeDirectories>
      </AdditionalIncludeDirectories>
      <PreprocessorDefinitions>%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <SDLCheck>true</SDLCheck>
      <WarningLevel>EnableAllWarnings</WarningLevel>
    </ClCompile>
    <Link>
      <OutputFile>\$(OutDir)\$(TargetName)\$(TargetExt)\</OutputFile>
      <AdditionalDependencies>..\LIbs\ci.lib;%(AdditionalDependencies);$(KernelBufferOverflowLib);$(DDK_LIB_PATH)ntoskrnl.lib;$(DDK_LIB_PATH)hal.lib;$(DDK_LIB_PATH)wmilib.lib</AdditionalDependencies>
      <AdditionalOptions>/integritycheck %(AdditionalOptions)</AdditionalOptions>
    </Link>
    <PostBuildEvent>
      <Command>
      </Command>
    </PostBuildEvent>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Win10Release|x64'">
    <ClCompile>
      <CompileAs>CompileAsC</CompileAs>
      <AdditionalIncludeDirectories>
      </AdditionalIncludeDirectories>
      <PreprocessorDefinitions>%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <WarningLevel>TurnOffAllWarnings</WarningLevel>
      <LanguageStandard>Default</LanguageStandard>
      <Optimization>Disabled</Optimization>
    </ClCompile>
    <Link>
      <OutputFile>$(OutDir)$(TargetName)$(TargetExt)</OutputFile>
      <AdditionalDependencies>..\LIbs\ci.lib;%(AdditionalDependencies);$(KernelBufferOverflowLib);$(DDK_LIB_PATH)ntoskrnl.lib;$(DDK_LIB_PATH)hal.lib;$(DDK_LIB_PATH)wmilib.lib</AdditionalDependencies>
      <EntryPointSymbol>DriverEntry</EntryPointSymbol>
      <AdditionalOptions>/integritycheck %(AdditionalOptions)</AdditionalOptions>
    </Link>
  </ItemDefinitionGroup>
  <ItemGroup>
    <FilesToPackage Include="$(TargetPath)" />
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="entry.c" />
    <ClCompile Include="Funcs\Hardware\HardwareInfo.c" />
    <ClCompile Include="Funcs\log.c" />
    <ClCompile Include="Funcs\Protects\ScanBigPool.c" />
    <ClCompile Include="Funcs\Protects\ScanDispatchDrivers.c" />
    <ClCompile Include="Funcs\Protects\ScanCodeIntegrity.c" />
    <ClCompile Include="Funcs\Protects\ScanHV.c" />
    <ClCompile Include="Funcs\Protects\ScanPerfectInjector.c" />
    <ClCompile Include="Funcs\Protects\ScanPhysMemHandles.c" />
    <ClCompile Include="Funcs\Protects\ScanPIDDB.c" />
    <ClCompile Include="Funcs\Protects\ScanSSDTHooks.c" />
    <ClCompile Include="Funcs\Protects\ScanSysThreads.c" />
    <ClCompile Include="Funcs\utils.c" />
    <ClCompile Include="Natives\Hde\hde64.c" />
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="Funcs\funcs.h" />
    <ClInclude Include="Funcs\Hardware\HardwareInfo.h" />
    <ClInclude Include="Funcs\log.h" />
    <ClInclude Include="Funcs\Protects\ScanUnloadedDrivers.c" />
    <ClInclude Include="Funcs\utils.h" />
    <ClInclude Include="Natives\Hde\hde64.h" />
    <ClInclude Include="Natives\Hde\table64.h" />
    <ClInclude Include="Natives\Imports.h" />
    <ClInclude Include="Natives\NativeEnums.h" />
    <ClInclude Include="Natives\NativeStructs.h" />
    <ClInclude Include="Natives\PEStructs.h" />
    <ClInclude Include="Natives\stdint.h" />
    <ClInclude Include="Natives\Windows\ci.h" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>
```

`KernelAntiCheat/KernelAntiCheat.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <ClCompile Include="Funcs\utils.c">
      <Filter>Funcs</Filter>
    </ClCompile>
    <ClCompile Include="Funcs\Protects\ScanSysThreads.c">
      <Filter>Funcs\Protects</Filter>
    </ClCompile>
    <ClCompile Include="Funcs\Protects\ScanBigPool.c">
      <Filter>Funcs\Protects</Filter>
    </ClCompile>
    <ClCompile Include="Funcs\Protects\ScanPIDDB.c">
      <Filter>Funcs\Protects</Filter>
    </ClCompile>
    <ClCompile Include="Funcs\Protects\ScanHV.c">
      <Filter>Funcs\Protects</Filter>
    </ClCompile>
    <ClCompile Include="Funcs\Protects\ScanPhysMemHandles.c">
      <Filter>Funcs\Protects</Filter>
    </ClCompile>
    <ClCompile Include="Funcs\Protects\ScanPerfectInjector.c">
      <Filter>Funcs\Protects</Filter>
    </ClCompile>
    <ClCompile Include="Funcs\Protects\ScanDispatchDrivers.c">
      <Filter>Funcs\Protects</Filter>
    </ClCompile>
    <ClCompile Include="Funcs\Hardware\HardwareInfo.c">
      <Filter>Funcs\Hardware</Filter>
    </ClCompile>
    <ClCompile Include="entry.c" />
    <ClCompile Include="Funcs\log.c">
      <Filter>Funcs</Filter>
    </ClCompile>
    <ClCompile Include="Natives\Hde\hde64.c">
      <Filter>Natives\Hde</Filter>
    </ClCompile>
    <ClCompile Include="Funcs\Protects\ScanCodeIntegrity.c">
      <Filter>Funcs\Protects</Filter>
    </ClCompile>
    <ClCompile Include="Funcs\Protects\ScanSSDTHooks.c">
      <Filter>Funcs\Protects</Filter>
    </ClCompile>
  </ItemGroup>
  <ItemGroup>
    <Filter Include="Funcs">
      <UniqueIdentifier>{4b53cc74-a67c-4c32-88be-7954cd4a5a1e}</UniqueIdentifier>
    </Filter>
    <Filter Include="Natives">
      <UniqueIdentifier>{9f81114e-7e49-40e8-8d6e-1d315229a48f}</UniqueIdentifier>
    </Filter>
    <Filter Include="Funcs\Protects">
      <UniqueIdentifier>{d3ce92f0-3fe8-4b38-9b10-7b923b80753b}</UniqueIdentifier>
    </Filter>
    <Filter Include="Funcs\Hardware">
      <UniqueIdentifier>{f24084d8-be8f-4e64-aee5-fd4155b64df8}</UniqueIdentifier>
    </Filter>
    <Filter Include="Natives\Hde">
      <UniqueIdentifier>{e9726a29-7cf8-4962-adf7-a081174e00e0}</UniqueIdentifier>
    </Filter>
    <Filter Include="Natives\Windows">
      <UniqueIdentifier>{e3ef8f34-a479-4eb8-b410-680c80058a6b}</UniqueIdentifier>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="Funcs\utils.h">
      <Filter>Funcs</Filter>
    </ClInclude>
    <ClInclude Include="Natives\Imports.h">
      <Filter>Natives</Filter>
    </ClInclude>
    <ClInclude Include="Natives\NativeEnums.h">
      <Filter>Natives</Filter>
    </ClInclude>
    <ClInclude Include="Natives\NativeStructs.h">
      <Filter>Natives</Filter>
    </ClInclude>
    <ClInclude Include="Natives\PEStructs.h">
      <Filter>Natives</Filter>
    </ClInclude>
    <ClInclude Include="Natives\stdint.h">
      <Filter>Natives</Filter>
    </ClInclude>
    <ClInclude Include="Funcs\funcs.h">
      <Filter>Funcs</Filter>
    </ClInclude>
    <ClInclude Include="Funcs\Hardware\HardwareInfo.h">
      <Filter>Funcs\Hardware</Filter>
    </ClInclude>
    <ClInclude Include="Funcs\Protects\ScanUnloadedDrivers.c">
      <Filter>Funcs\Protects</Filter>
    </ClInclude>
    <ClInclude Include="Funcs\log.h">
      <Filter>Funcs</Filter>
    </ClInclude>
    <ClInclude Include="Natives\Hde\hde64.h">
      <Filter>Natives\Hde</Filter>
    </ClInclude>
    <ClInclude Include="Natives\Hde\table64.h">
      <Filter>Natives\Hde</Filter>
    </ClInclude>
    <ClInclude Include="Natives\Windows\ci.h">
      <Filter>Natives\Windows</Filter>
    </ClInclude>
  </ItemGroup>
</Project>
```

`KernelAntiCheat/Natives/Hde/hde64.c`:

```c
/*
 * Hacker Disassembler Engine 64 C
 * Copyright (c) 2008-2009, Vyacheslav Patkov.
 * All rights reserved.
 *
 */

#include "hde64.h"
#include "table64.h"
#include <intrin.h>

unsigned int hde64_disasm(const void *code, hde64s *hs)
{
    uint8_t x, c = 0, *p = (uint8_t *)code, cflags, opcode, pref = 0;
    const uint8_t* ht = hde64_table;
    uint8_t m_mod, m_reg, m_rm, disp_size = 0;
    uint8_t op64 = 0;

    // Avoid using memset to reduce the footprint.
#ifndef _MSC_VER
    memset((uint8_t*)hs, 0, sizeof(hde64s));
#else
    __stosb((uint8_t*)hs, 0, sizeof(hde64s));
#endif

    for (x = 16; x; x--)
        switch (c = *p++) {
            case 0xf3:
                hs->p_rep = c;
                pref |= PRE_F3;
                break;
            case 0xf2:
                hs->p_rep = c;
                pref |= PRE_F2;
                break;
            case 0xf0:
                hs->p_lock = c;
                pref |= PRE_LOCK;
                break;
            case 0x26: case 0x2e: case 0x36:
            case 0x3e: case 0x64: case 0x65:
                hs->p_seg = c;
                pref |= PRE_SEG;
                break;
            case 0x66:
                hs->p_66 = c;
                pref |= PRE_66;
                break;
            case 0x67:
                hs->p_67 = c;
                pref |= PRE_67;
                break;
            default:
                goto pref_done;
        }
  pref_done:

    hs->flags = (uint32_t)pref << 23;

    if (!pref)
        pref |= PRE_NONE;

    if ((c & 0xf0) == 0x40) {
        hs->flags |= F_PREFIX_REX;
        if (((hs->rex_w = (c & 0xf) >> 3)) && (*p & 0xf8) == 0xb8)
            op64++;
        hs->rex_r = (c & 7) >> 2;
        hs->rex_x = (c & 3) >> 1;
        hs->rex_b = c & 1;
        if (((c = *p++) & 0xf0) == 0x40) {
            opcode = c;
            goto error_opcode;
        }
    }

    if ((hs->opcode = c) == 0x0f) {
        hs->opcode2 = c = *p++;
        ht += DELTA_OPCODES;
    } else if (c >= 0xa0 && c <= 0xa3) {
        op64++;
        if (pref & PRE_67)
            pref |= PRE_66;
        else
            pref &= ~PRE_66;
    }

    opcode = c;
    cflags = ht[ht[opcode / 4] + (opcode % 4)];

    if (cflags == C_ERROR) {
      error_opcode:
        hs->flags |= F_ERROR | F_ERROR_OPCODE;
        cflags = 0;
        if ((opcode & -3) == 0x24)
            cflags++;
    }

    x = 0;
    if (cflags & C_GROUP) {
        uint16_t t;
        t = *(uint16_t *)(ht + (cflags & 0x7f));
        cflags = (uint8_t)t;
        x = (uint8_t)(t >> 8);
    }

    if (hs->opcode2) {
        ht = hde64_table + DELTA_PREFIXES;
        if (ht[ht[opcode / 4] + (opcode % 4)] & pref)
            hs->flags |= F_ERROR | F_ERROR_OPCODE;
    }

    if (cflags & C_MODRM) {
        hs->flags |= F_MODRM;
        hs->modrm = c = *p++;
        hs->modrm_mod = m_mod = c >> 6;
        hs->modrm_rm = m_rm = c & 7;
        hs->modrm_reg = m_reg = (c & 0x3f) >> 3;

        if (x && ((x << m_reg) & 0x80))
            hs->flags |= F_ERROR | F_ERROR_OPCODE;

        if (!hs->opcode2 && opcode >= 0xd9 && opcode <= 0xdf) {
            uint8_t t = opcode - 0xd9;
            if (m_mod == 3) {
                ht = hde64_table + DELTA_FPU_MODRM + t*8;
                t = ht[m_reg] << m_rm;
            } else {
                ht = hde64_table + DELTA_FPU_REG;
                t = ht[t] << m_reg;
            }
            if (t & 0x80)
                hs->flags |= F_ERROR | F_ERROR_OPCODE;
        }

        if (pref & PRE_LOCK) {
            if (m_mod == 3) {
                hs->flags |= F_ERROR | F_ERROR_LOCK;
            } else {
                const uint8_t* table_end;
                uint8_t op = opcode;
                if (hs->opcode2) {
                    ht = hde64_table + DELTA_OP2_LOCK_OK;
                    table_end = ht + DELTA_OP_ONLY_MEM - DELTA_OP2_LOCK_OK;
                } else {
                    ht = hde64_table + DELTA_OP_LOCK_OK;
                    table_end = ht + DELTA_OP2_LOCK_OK - DELTA_OP_LOCK_OK;
                    op &= -2;
                }
                for (; ht != table_end; ht++)
                    if (*ht++ == op) {
                        if (!((*ht << m_reg) & 0x80))
                            goto no_lock_error;
                        else
                            break;
                    }
                hs->flags |= F_ERROR | F_ERROR_LOCK;
              no_lock_error:
                ;
            }
        }

        if (hs->opcode2) {
            switch (opcode) {
                case 0x20: case 0x22:
                    m_mod = 3;
                    if (m_reg > 4 || m_reg == 1)
                        goto error_operand;
                    else
                        goto no_error_operand;
                case 0x21: case 0x23:
                    m_mod = 3;
                    if (m_reg == 4 || m_reg == 5)
                        goto error_operand;
                    else
                        goto no_error_operand;
                default:
                    break;
            }
        } else {
            switch (opcode) {
                case 0x8c:
                    if (m_reg > 5)
                        goto error_operand;
                    else
                        goto no_error_operand;
                case 0x8e:
                    if (m_reg == 1 || m_reg > 5)
                        goto error_operand;
                    else
                        goto no_error_operand;
                default:
                    break;
            }
        }

        if (m_mod == 3) {
            const uint8_t *table_end;
            if (hs->opcode2) {
                ht = hde64_table + DELTA_OP2_ONLY_MEM;
                table_end = ht + sizeof(hde64_table) - DELTA_OP2_ONLY_MEM;
            } else {
                ht = hde64_table + DELTA_OP_ONLY_MEM;
                table_end = ht + DELTA_OP2_ONLY_MEM - DELTA_OP_ONLY_MEM;
            }
            for (; ht != table_end; ht += 2)
                if (*ht++ == opcode) {
                    if (*ht++ & pref && !((*ht << m_reg) & 0x80))
                        goto error_operand;
                    else
                        break;
                }
            goto no_error_operand;
        } else if (hs->opcode2) {
            switch (opcode) {
                case 0x50: case 0xd7: case 0xf7:
                    if (pref & (PRE_NONE | PRE_66))
                        goto error_operand;
                    break;
                case 0xd6:
                    if (pref & (PRE_F2 | PRE_F3))
                        goto error_operand;
                    break;
                case 0xc5:
                    goto error_operand;
                default:
                    break;
            }
            goto no_error_operand;
        } else
            goto no_error_operand;

      error_operand:
        hs->flags |= F_ERROR | F_ERROR_OPERAND;
      no_error_operand:

        c = *p++;
        if (m_reg <= 1) {
            if (opcode == 0xf6)
                cflags |= C_IMM8;
            else if (opcode == 0xf7)
                cflags |= C_IMM_P66;
        }

        switch (m_mod) {
            case 0:
                if (pref & PRE_67) {
                    if (m_rm == 6)
                        disp_size = 2;
                } else
                    if (m_rm == 5)
                        disp_size = 4;
                break;
            case 1:
                disp_size = 1;
                break;
            case 2:
                disp_size = 2;
                if (!(pref & PRE_67))
                    disp_size <<= 1;
            default:
                break;
        }

        if (m_mod != 3 && m_rm == 4) {
            hs->flags |= F_SIB;
            p++;
            hs->sib = c;
            hs->sib_scale = c >> 6;
            hs->sib_index = (c & 0x3f) >> 3;
            if ((hs->sib_base = c & 7) == 5 && !(m_mod & 1))
                disp_size = 4;
        }

        p--;
        switch (disp_size) {
            case 1:
                hs->flags |= F_DISP8;
                hs->disp.disp8 = *p;
                break;
            case 2:
                hs->flags |= F_DISP16;
                hs->disp.disp16 = *(uint16_t *)p;
                break;
            case 4:
                hs->flags |= F_DISP32;
                hs->disp.disp32 = *(uint32_t *)p;
            default:
                break;
        }
        p += disp_size;
    } else if (pref & PRE_LOCK)
        hs->flags |= F_ERROR | F_ERROR_LOCK;

    if (cflags & C_IMM_P66) {
        if (cflags & C_REL32) {
            if (pref & PRE_66) {
                hs->flags |= F_IMM16 | F_RELATIVE;
                hs->imm.imm16 = *(uint16_t *)p;
                p += 2;
                goto disasm_done;
            }
            goto rel32_ok;
        }
        if (op64) {
            hs->flags |= F_IMM64;
            hs->imm.imm64 = *(uint64_t *)p;
            p += 8;
        } else if (!(pref & PRE_66)) {
            hs->flags |= F_IMM32;
            hs->imm.imm32 = *(uint32_t *)p;
            p += 4;
        } else
            goto imm16_ok;
    }


    if (cflags & C_IMM16) {
      imm16_ok:
        hs->flags |= F_IMM16;
        hs->imm.imm16 = *(uint16_t *)p;
        p += 2;
    }
    if (cflags & C_IMM8) {
        hs->flags |= F_IMM8;
        hs->imm.imm8 = *p++;
    }

    if (cflags & C_REL32) {
      rel32_ok:
        hs->flags |= F_IMM32 | F_RELATIVE;
        hs->imm.imm32 = *(uint32_t *)p;
        p += 4;
    } else if (cflags & C_REL8) {
        hs->flags |= F_IMM8 | F_RELATIVE;
        hs->imm.imm8 = *p++;
    }

  disasm_done:

    if ((hs->len = (uint8_t)(p-(uint8_t *)code)) > 15) {
        hs->flags |= F_ERROR | F_ERROR_LENGTH;
        hs->len = 15;
    }

    return (unsigned int)hs->len;
}

```

`KernelAntiCheat/Natives/Hde/hde64.h`:

```h
/*
 * Hacker Disassembler Engine 64
 * Copyright (c) 2008-2009, Vyacheslav Patkov.
 * All rights reserved.
 *
 * hde64.h: C/C++ header file
 *
 */

#ifndef _HDE64_H_
#define _HDE64_H_

/* stdint.h - C99 standard header
 * http://en.wikipedia.org/wiki/stdint.h
 *
 * if your compiler doesn't conta"stdint.h" header (for
 * example, Microsoft Visual C++), you can download file:
 *   http://www.azillionmonkeys.com/qed/pstdint.h
 * and change next line to:
 *   #include "pstdint.h"
 */
#include "..\stdint.h"

#define F_MODRM         0x00000001
#define F_SIB           0x00000002
#define F_IMM8          0x00000004
#define F_IMM16         0x00000008
#define F_IMM32         0x00000010
#define F_IMM64         0x00000020
#define F_DISP8         0x00000040
#define F_DISP16        0x00000080
#define F_DISP32        0x00000100
#define F_RELATIVE      0x00000200
#define F_ERROR         0x00001000
#define F_ERROR_OPCODE  0x00002000
#define F_ERROR_LENGTH  0x00004000
#define F_ERROR_LOCK    0x00008000
#define F_ERROR_OPERAND 0x00010000
#define F_PREFIX_REPNZ  0x01000000
#define F_PREFIX_REPX   0x02000000
#define F_PREFIX_REP    0x03000000
#define F_PREFIX_66     0x04000000
#define F_PREFIX_67     0x08000000
#define F_PREFIX_LOCK   0x10000000
#define F_PREFIX_SEG    0x20000000
#define F_PREFIX_REX    0x40000000
#define F_PREFIX_ANY    0x7f000000

#define PREFIX_SEGMENT_CS   0x2e
#define PREFIX_SEGMENT_SS   0x36
#define PREFIX_SEGMENT_DS   0x3e
#define PREFIX_SEGMENT_ES   0x26
#define PREFIX_SEGMENT_FS   0x64
#define PREFIX_SEGMENT_GS   0x65
#define PREFIX_LOCK         0xf0
#define PREFIX_REPNZ        0xf2
#define PREFIX_REPX         0xf3
#define PREFIX_OPERAND_SIZE 0x66
#define PREFIX_ADDRESS_SIZE 0x67

#pragma pack(push,1)

typedef struct {
    uint8_t len;
    uint8_t p_rep;
    uint8_t p_lock;
    uint8_t p_seg;
    uint8_t p_66;
    uint8_t p_67;
    uint8_t rex;
    uint8_t rex_w;
    uint8_t rex_r;
    uint8_t rex_x;
    uint8_t rex_b;
    uint8_t opcode;
    uint8_t opcode2;
    uint8_t modrm;
    uint8_t modrm_mod;
    uint8_t modrm_reg;
    uint8_t modrm_rm;
    uint8_t sib;
    uint8_t sib_scale;
    uint8_t sib_index;
    uint8_t sib_base;
    union {
        uint8_t imm8;
        uint16_t imm16;
        uint32_t imm32;
        uint64_t imm64;
    } imm;
    union {
        uint8_t disp8;
        uint16_t disp16;
        uint32_t disp32;
    } disp;
    uint32_t flags;
} hde64s;

#pragma pack(pop)

#ifdef __cplusplus
extern "C" {
#endif

/* __cdecl */
unsigned int hde64_disasm(const void *code, hde64s *hs);

#ifdef __cplusplus
}
#endif

#endif /* _HDE64_H_ */

```

`KernelAntiCheat/Natives/Hde/table64.h`:

```h
/*
 * Hacker Disassembler Engine 64 C
 * Copyright (c) 2008-2009, Vyacheslav Patkov.
 * All rights reserved.
 *
 */

#pragma once

#define C_NONE    0x00
#define C_MODRM   0x01
#define C_IMM8    0x02
#define C_IMM16   0x04
#define C_IMM_P66 0x10
#define C_REL8    0x20
#define C_REL32   0x40
#define C_GROUP   0x80
#define C_ERROR   0xff

#define PRE_ANY  0x00
#define PRE_NONE 0x01
#define PRE_F2   0x02
#define PRE_F3   0x04
#define PRE_66   0x08
#define PRE_67   0x10
#define PRE_LOCK 0x20
#define PRE_SEG  0x40
#define PRE_ALL  0xff

#define DELTA_OPCODES      0x4a
#define DELTA_FPU_REG      0xfd
#define DELTA_FPU_MODRM    0x104
#define DELTA_PREFIXES     0x13c
#define DELTA_OP_LOCK_OK   0x1ae
#define DELTA_OP2_LOCK_OK  0x1c6
#define DELTA_OP_ONLY_MEM  0x1d8
#define DELTA_OP2_ONLY_MEM 0x1e7

const unsigned char hde64_table[] = {
  0xa5,0xaa,0xa5,0xb8,0xa5,0xaa,0xa5,0xaa,0xa5,0xb8,0xa5,0xb8,0xa5,0xb8,0xa5,
  0xb8,0xc0,0xc0,0xc0,0xc0,0xc0,0xc0,0xc0,0xc0,0xac,0xc0,0xcc,0xc0,0xa1,0xa1,
  0xa1,0xa1,0xb1,0xa5,0xa5,0xa6,0xc0,0xc0,0xd7,0xda,0xe0,0xc0,0xe4,0xc0,0xea,
  0xea,0xe0,0xe0,0x98,0xc8,0xee,0xf1,0xa5,0xd3,0xa5,0xa5,0xa1,0xea,0x9e,0xc0,
  0xc0,0xc2,0xc0,0xe6,0x03,0x7f,0x11,0x7f,0x01,0x7f,0x01,0x3f,0x01,0x01,0xab,
  0x8b,0x90,0x64,0x5b,0x5b,0x5b,0x5b,0x5b,0x92,0x5b,0x5b,0x76,0x90,0x92,0x92,
  0x5b,0x5b,0x5b,0x5b,0x5b,0x5b,0x5b,0x5b,0x5b,0x5b,0x5b,0x5b,0x6a,0x73,0x90,
  0x5b,0x52,0x52,0x52,0x52,0x5b,0x5b,0x5b,0x5b,0x77,0x7c,0x77,0x85,0x5b,0x5b,
  0x70,0x5b,0x7a,0xaf,0x76,0x76,0x5b,0x5b,0x5b,0x5b,0x5b,0x5b,0x5b,0x5b,0x5b,
  0x5b,0x5b,0x86,0x01,0x03,0x01,0x04,0x03,0xd5,0x03,0xd5,0x03,0xcc,0x01,0xbc,
  0x03,0xf0,0x03,0x03,0x04,0x00,0x50,0x50,0x50,0x50,0xff,0x20,0x20,0x20,0x20,
  0x01,0x01,0x01,0x01,0xc4,0x02,0x10,0xff,0xff,0xff,0x01,0x00,0x03,0x11,0xff,
  0x03,0xc4,0xc6,0xc8,0x02,0x10,0x00,0xff,0xcc,0x01,0x01,0x01,0x00,0x00,0x00,
  0x00,0x01,0x01,0x03,0x01,0xff,0xff,0xc0,0xc2,0x10,0x11,0x02,0x03,0x01,0x01,
  0x01,0xff,0xff,0xff,0x00,0x00,0x00,0xff,0x00,0x00,0xff,0xff,0xff,0xff,0x10,
  0x10,0x10,0x10,0x02,0x10,0x00,0x00,0xc6,0xc8,0x02,0x02,0x02,0x02,0x06,0x00,
  0x04,0x00,0x02,0xff,0x00,0xc0,0xc2,0x01,0x01,0x03,0x03,0x03,0xca,0x40,0x00,
  0x0a,0x00,0x04,0x00,0x00,0x00,0x00,0x7f,0x00,0x33,0x01,0x00,0x00,0x00,0x00,
  0x00,0x00,0xff,0xbf,0xff,0xff,0x00,0x00,0x00,0x00,0x07,0x00,0x00,0xff,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xff,0xff,
  0x00,0x00,0x00,0xbf,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x7f,0x00,0x00,
  0xff,0x40,0x40,0x40,0x40,0x41,0x49,0x40,0x40,0x40,0x40,0x4c,0x42,0x40,0x40,
  0x40,0x40,0x40,0x40,0x40,0x40,0x4f,0x44,0x53,0x40,0x40,0x40,0x44,0x57,0x43,
  0x5c,0x40,0x60,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,
  0x40,0x40,0x64,0x66,0x6e,0x6b,0x40,0x40,0x6a,0x46,0x40,0x40,0x44,0x46,0x40,
  0x40,0x5b,0x44,0x40,0x40,0x00,0x00,0x00,0x00,0x06,0x06,0x06,0x06,0x01,0x06,
  0x06,0x02,0x06,0x06,0x00,0x06,0x00,0x0a,0x0a,0x00,0x00,0x00,0x02,0x07,0x07,
  0x06,0x02,0x0d,0x06,0x06,0x06,0x0e,0x05,0x05,0x02,0x02,0x00,0x00,0x04,0x04,
  0x04,0x04,0x05,0x06,0x06,0x06,0x00,0x00,0x00,0x0e,0x00,0x00,0x08,0x00,0x10,
  0x00,0x18,0x00,0x20,0x00,0x28,0x00,0x30,0x00,0x80,0x01,0x82,0x01,0x86,0x00,
  0xf6,0xcf,0xfe,0x3f,0xab,0x00,0xb0,0x00,0xb1,0x00,0xb3,0x00,0xba,0xf8,0xbb,
  0x00,0xc0,0x00,0xc1,0x00,0xc7,0xbf,0x62,0xff,0x00,0x8d,0xff,0x00,0xc4,0xff,
  0x00,0xc5,0xff,0x00,0xff,0xff,0xeb,0x01,0xff,0x0e,0x12,0x08,0x00,0x13,0x09,
  0x00,0x16,0x08,0x00,0x17,0x09,0x00,0x2b,0x09,0x00,0xae,0xff,0x07,0xb2,0xff,
  0x00,0xb4,0xff,0x00,0xb5,0xff,0x00,0xc3,0x01,0x00,0xc7,0xff,0xbf,0xe7,0x08,
  0x00,0xf0,0x02,0x00
};

```

`KernelAntiCheat/Natives/Imports.h`:

```h
#include "NativeEnums.h"
#include "NativeStructs.h"

typedef NTSTATUS(__fastcall* _ZwQueryDirectoryObject)
(
    IN HANDLE DirectoryHandle,
    OUT PVOID Buffer,
    IN ULONG BufferLength,
    IN BOOLEAN ReturnSingleEntry,
    IN BOOLEAN RestartScan,
    IN OUT PULONG Context,
    OUT PULONG ReturnLength OPTIONAL
);

typedef NTSTATUS(NTAPI* _KeSetAffinityThread)
(
    PKTHREAD pKThread,
    KAFFINITY cpuAffinityMask
);

NTSYSAPI
NTSTATUS
NTAPI
NtQuerySystemInformation(
    IN SYSTEM_INFORMATION_CLASS SystemInformationClass,
    OUT PVOID               SystemInformation,
    IN ULONG                SystemInformationLength,
    OUT PULONG              ReturnLength OPTIONAL);

NTSYSAPI
NTSTATUS
NTAPI
MmCheckSystemImage(
    IN  HANDLE ImageFileHandle,
    IN  LOGICAL PurgeSection
);

RUNTIME_FUNCTION RtlLookupFunctionEntry(
    DWORD64               ControlPc,
    PDWORD64              ImageBase,
    PUNWIND_HISTORY_TABLE HistoryTable
);

NTSYSAPI VOID RtlUnwindEx(
    PVOID                 TargetFrame,
    PVOID                 TargetIp,
    PEXCEPTION_RECORD     ExceptionRecord,
    PVOID                 ReturnValue,
    PCONTEXT              ContextRecord,
    PUNWIND_HISTORY_TABLE HistoryTable
);

NTSYSAPI PEXCEPTION_ROUTINE RtlVirtualUnwind(
    PVOID                          HandlerType,
    DWORD64                        ImageBase,
    DWORD64                        ControlPc,
    PRUNTIME_FUNCTION              FunctionEntry,
    PCONTEXT                       ContextRecord,
    PVOID* HandlerData,
    PDWORD64                       EstablisherFrame,
    PKNONVOLATILE_CONTEXT_POINTERS ContextPointers
);

NTSYSAPI
NTSTATUS
NTAPI
NtQueryInformationThread(
    IN HANDLE               ThreadHandle,
    IN THREAD_INFORMATION_CLASS ThreadInformationClass,
    OUT PVOID               ThreadInformation,
    IN ULONG                ThreadInformationLength,
    OUT PULONG              ReturnLength OPTIONAL);

NTSTATUS ObReferenceObjectByName(PUNICODE_STRING objectName, ULONG attributes, PACCESS_STATE accessState, ACCESS_MASK desiredAccess, POBJECT_TYPE objectType, KPROCESSOR_MODE accessMode, PVOID parseContext, PVOID* object);

NTKERNELAPI
NTSTATUS
NTAPI
ObOpenObjectByName(
    _In_ POBJECT_ATTRIBUTES ObjectAttributes,
    _In_ POBJECT_TYPE ObjectType,
    _In_ KPROCESSOR_MODE PreviousMode,
    _In_opt_ PACCESS_STATE AccessState,
    _In_opt_ ACCESS_MASK DesiredAccess,
    _In_opt_ PVOID ParseContext,
    _Out_ PHANDLE Handle
);

NTKERNELAPI
POBJECT_TYPE
NTAPI
ObGetObjectType(
    _In_ PVOID Object
);

NTSYSAPI
NTSTATUS
NTAPI
ZwQuerySystemInformation(
    IN SYSTEM_INFORMATION_CLASS SystemInformationClass,
    OUT PVOID SystemInformation,
    IN ULONG SystemInformationLength,
    OUT PULONG ReturnLength OPTIONAL
);

NTSYSAPI
NTSTATUS
NTAPI
ZwSetSystemInformation(
    IN SYSTEM_INFORMATION_CLASS SystemInformationClass,
    IN PVOID SystemInformation,
    IN ULONG SystemInformationLength
);

NTSYSAPI
NTSTATUS
NTAPI
ZwQueryInformationProcess(
    IN  HANDLE ProcessHandle,
    IN  PROCESSINFOCLASS ProcessInformationClass,
    OUT PVOID ProcessInformation,
    IN  ULONG ProcessInformationLength,
    IN  PULONG ReturnLength
);

NTSYSAPI
NTSTATUS
NTAPI
ZwQueryInformationThread(
    IN HANDLE ThreadHandle,
    IN THREADINFOCLASS ThreadInformationClass,
    OUT PVOID ThreadInformation,
    IN ULONG ThreadInformationLength,
    OUT PULONG ReturnLength OPTIONAL
);

NTSTATUS
NTAPI
ZwCreateThreadEx(
    OUT PHANDLE hThread,
    IN ACCESS_MASK DesiredAccess,
    IN PVOID ObjectAttributes,
    IN HANDLE ProcessHandle,
    IN PVOID lpStartAddress,
    IN PVOID lpParameter,
    IN ULONG Flags,
    IN SIZE_T StackZeroBits,
    IN SIZE_T SizeOfStackCommit,
    IN SIZE_T SizeOfStackReserve,
    IN PNT_PROC_THREAD_ATTRIBUTE_LIST AttributeList
);

NTSTATUS
NTAPI
ZwTerminateThread(
    IN HANDLE ThreadHandle,
    IN NTSTATUS ExitStatus
);



NTKERNELAPI
NTSTATUS
NTAPI
MmCopyVirtualMemory(
    IN PEPROCESS FromProcess,
    IN PVOID FromAddress,
    IN PEPROCESS ToProcess,
    OUT PVOID ToAddress,
    IN SIZE_T BufferSize,
    IN KPROCESSOR_MODE PreviousMode,
    OUT PSIZE_T NumberOfBytesCopied
);

NTKERNELAPI
PPEB
NTAPI
PsGetProcessPeb(IN PEPROCESS Process);

NTKERNELAPI
PVOID
NTAPI
PsGetThreadTeb(IN PETHREAD Thread);

NTKERNELAPI
PVOID
NTAPI
PsGetProcessWow64Process(IN PEPROCESS Process);

NTKERNELAPI
PVOID
NTAPI
PsGetCurrentProcessWow64Process();

NTKERNELAPI
BOOLEAN
NTAPI
KeTestAlertThread(IN KPROCESSOR_MODE AlertMode);

NTKERNELAPI
BOOLEAN
NTAPI
PsIsProtectedProcess(IN PEPROCESS Process);

typedef VOID(NTAPI* PKNORMAL_ROUTINE)(
    PVOID NormalContext,
    PVOID SystemArgument1,
    PVOID SystemArgument2
    );

typedef VOID(NTAPI* PKKERNEL_ROUTINE)(
    PRKAPC Apc,
    PKNORMAL_ROUTINE* NormalRoutine,
    PVOID* NormalContext,
    PVOID* SystemArgument1,
    PVOID* SystemArgument2
    );

typedef VOID(NTAPI* PKRUNDOWN_ROUTINE)(PRKAPC Apc);

NTKERNELAPI
VOID
NTAPI
KeInitializeApc(
    IN PKAPC Apc,
    IN PKTHREAD Thread,
    IN KAPC_ENVIRONMENT ApcStateIndex,
    IN PKKERNEL_ROUTINE KernelRoutine,
    IN PKRUNDOWN_ROUTINE RundownRoutine,
    IN PKNORMAL_ROUTINE NormalRoutine,
    IN KPROCESSOR_MODE ApcMode,
    IN PVOID NormalContext
);

NTKERNELAPI
BOOLEAN
NTAPI
KeInsertQueueApc(
    PKAPC Apc,
    PVOID SystemArgument1,
    PVOID SystemArgument2,
    KPRIORITY Increment
);

NTSYSAPI
PIMAGE_NT_HEADERS
NTAPI
RtlImageNtHeader(PVOID Base);

NTSYSAPI
PVOID
NTAPI
RtlImageDirectoryEntryToData(
    PVOID ImageBase,
    BOOLEAN MappedAsImage,
    USHORT DirectoryEntry,
    PULONG Size
);


NTKERNELAPI
VOID
FASTCALL
ExfUnblockPushLock(
    IN OUT PEX_PUSH_LOCK PushLock,
    IN OUT PVOID WaitBlock
);
```

`KernelAntiCheat/Natives/NativeEnums.h`:

```h
#pragma once
typedef enum _THREAD_INFORMATION_CLASS {
    _ThreadBasicInformation,
    _ThreadTimes,
    _ThreadPriority,
    _ThreadBasePriority,
    _ThreadAffinityMask,
    _ThreadImpersonationToken,
    _ThreadDescriptorTableEntry,
    _ThreadEnableAlignmentFaultFixup,
    _ThreadEventPair,
    _ThreadQuerySetWin32StartAddress,
    _ThreadZeroTlsCell,
    _ThreadPerformanceCount,
    _ThreadAmILastThread,
    _ThreadIdealProcessor,
    _ThreadPriorityBoost,
    _ThreadSetTlsArrayAddress,
    _ThreadIsIoPending,
    _ThreadHideFromDebugger
} THREAD_INFORMATION_CLASS, * PTHREAD_INFORMATION_CLASS;

typedef enum _MEMORY_INFORMATION_CLASS_EX
{
    MemoryBasicInformationEx = 0,
    MemoryWorkingSetInformation = 1,
    MemoryMappedFilenameInformation = 2,
    MemoryRegionInformation = 3,
    MemoryWorkingSetExInformation = 4,
} MEMORY_INFORMATION_CLASS_EX;

typedef enum _PS_PROTECTED_SIGNER
{
    PsProtectedSignerNone = 0,
    PsProtectedSignerAuthenticode = 1,
    PsProtectedSignerCodeGen = 2,
    PsProtectedSignerAntimalware = 3,
    PsProtectedSignerLsa = 4,
    PsProtectedSignerWindows = 5,
    PsProtectedSignerWinTcb = 6,
    PsProtectedSignerMax = 7
} PS_PROTECTED_SIGNER;

typedef enum _PS_PROTECTED_TYPE
{
    PsProtectedTypeNone = 0,
    PsProtectedTypeProtectedLight = 1,
    PsProtectedTypeProtected = 2,
    PsProtectedTypeMax = 3
} PS_PROTECTED_TYPE;

typedef enum _SYSTEM_INFORMATION_CLASS
{
    SystemBasicInformation = 0x0,
    SystemProcessorInformation = 0x1,
    SystemPerformanceInformation = 0x2,
    SystemTimeOfDayInformation = 0x3,
    SystemPathInformation = 0x4,
    SystemProcessInformation = 0x5,
    SystemCallCountInformation = 0x6,
    SystemDeviceInformation = 0x7,
    SystemProcessorPerformanceInformation = 0x8,
    SystemFlagsInformation = 0x9,
    SystemCallTimeInformation = 0xa,
    SystemModuleInformation = 0xb,
    SystemLocksInformation = 0xc,
    SystemStackTraceInformation = 0xd,
    SystemPagedPoolInformation = 0xe,
    SystemNonPagedPoolInformation = 0xf,
    SystemHandleInformation = 0x10,
    SystemObjectInformation = 0x11,
    SystemPageFileInformation = 0x12,
    SystemVdmInstemulInformation = 0x13,
    SystemVdmBopInformation = 0x14,
    SystemFileCacheInformation = 0x15,
    SystemPoolTagInformation = 0x16,
    SystemInterruptInformation = 0x17,
    SystemDpcBehaviorInformation = 0x18,
    SystemFullMemoryInformation = 0x19,
    SystemLoadGdiDriverInformation = 0x1a,
    SystemUnloadGdiDriverInformation = 0x1b,
    SystemTimeAdjustmentInformation = 0x1c,
    SystemSummaryMemoryInformation = 0x1d,
    SystemMirrorMemoryInformation = 0x1e,
    SystemPerformanceTraceInformation = 0x1f,
    SystemObsolete0 = 0x20,
    SystemExceptionInformation = 0x21,
    SystemCrashDumpStateInformation = 0x22,
    SystemKernelDebuggerInformation = 0x23,
    SystemContextSwitchInformation = 0x24,
    SystemRegistryQuotaInformation = 0x25,
    SystemExtendServiceTableInformation = 0x26,
    SystemPrioritySeperation = 0x27,
    SystemVerifierAddDriverInformation = 0x28,
    SystemVerifierRemoveDriverInformation = 0x29,
    SystemProcessorIdleInformation = 0x2a,
    SystemLegacyDriverInformation = 0x2b,
    SystemCurrentTimeZoneInformation = 0x2c,
    SystemLookasideInformation = 0x2d,
    SystemTimeSlipNotification = 0x2e,
    SystemSessionCreate = 0x2f,
    SystemSessionDetach = 0x30,
    SystemSessionInformation = 0x31,
    SystemRangeStartInformation = 0x32,
    SystemVerifierInformation = 0x33,
    SystemVerifierThunkExtend = 0x34,
    SystemSessionProcessInformation = 0x35,
    SystemLoadGdiDriverInSystemSpace = 0x36,
    SystemNumaProcessorMap = 0x37,
    SystemPrefetcherInformation = 0x38,
    SystemExtendedProcessInformation = 0x39,
    SystemRecommendedSharedDataAlignment = 0x3a,
    SystemComPlusPackage = 0x3b,
    SystemNumaAvailableMemory = 0x3c,
    SystemProcessorPowerInformation = 0x3d,
    SystemEmulationBasicInformation = 0x3e,
    SystemEmulationProcessorInformation = 0x3f,
    SystemExtendedHandleInformation = 0x40,
    SystemLostDelayedWriteInformation = 0x41,
    SystemBigPoolInformation = 0x42,
    SystemSessionPoolTagInformation = 0x43,
    SystemSessionMappedViewInformation = 0x44,
    SystemHotpatchInformation = 0x45,
    SystemObjectSecurityMode = 0x46,
    SystemWatchdogTimerHandler = 0x47,
    SystemWatchdogTimerInformation = 0x48,
    SystemLogicalProcessorInformation = 0x49,
    SystemWow64SharedInformationObsolete = 0x4a,
    SystemRegisterFirmwareTableInformationHandler = 0x4b,
    SystemFirmwareTableInformation = 0x4c,
    SystemModuleInformationEx = 0x4d,
    SystemVerifierTriageInformation = 0x4e,
    SystemSuperfetchInformation = 0x4f,
    SystemMemoryListInformation = 0x50,
    SystemFileCacheInformationEx = 0x51,
    SystemThreadPriorityClientIdInformation = 0x52,
    SystemProcessorIdleCycleTimeInformation = 0x53,
    SystemVerifierCancellationInformation = 0x54,
    SystemProcessorPowerInformationEx = 0x55,
    SystemRefTraceInformation = 0x56,
    SystemSpecialPoolInformation = 0x57,
    SystemProcessIdInformation = 0x58,
    SystemErrorPortInformation = 0x59,
    SystemBootEnvironmentInformation = 0x5a,
    SystemHypervisorInformation = 0x5b,
    SystemVerifierInformationEx = 0x5c,
    SystemTimeZoneInformation = 0x5d,
    SystemImageFileExecutionOptionsInformation = 0x5e,
    SystemCoverageInformation = 0x5f,
    SystemPrefetchPatchInformation = 0x60,
    SystemVerifierFaultsInformation = 0x61,
    SystemSystemPartitionInformation = 0x62,
    SystemSystemDiskInformation = 0x63,
    SystemProcessorPerformanceDistribution = 0x64,
    SystemNumaProximityNodeInformation = 0x65,
    SystemDynamicTimeZoneInformation = 0x66,
    SystemCodeIntegrityInformation = 0x67,
    SystemProcessorMicrocodeUpdateInformation = 0x68,
    SystemProcessorBrandString = 0x69,
    SystemVirtualAddressInformation = 0x6a,
    SystemLogicalProcessorAndGroupInformation = 0x6b,
    SystemProcessorCycleTimeInformation = 0x6c,
    SystemStoreInformation = 0x6d,
    SystemRegistryAppendString = 0x6e,
    SystemAitSamplingValue = 0x6f,
    SystemVhdBootInformation = 0x70,
    SystemCpuQuotaInformation = 0x71,
    SystemNativeBasicInformation = 0x72,
    SystemErrorPortTimeouts = 0x73,
    SystemLowPriorityIoInformation = 0x74,
    SystemBootEntropyInformation = 0x75,
    SystemVerifierCountersInformation = 0x76,
    SystemPagedPoolInformationEx = 0x77,
    SystemSystemPtesInformationEx = 0x78,
    SystemNodeDistanceInformation = 0x79,
    SystemAcpiAuditInformation = 0x7a,
    SystemBasicPerformanceInformation = 0x7b,
    SystemQueryPerformanceCounterInformation = 0x7c,
    SystemSessionBigPoolInformation = 0x7d,
    SystemBootGraphicsInformation = 0x7e,
    SystemScrubPhysicalMemoryInformation = 0x7f,
    SystemBadPageInformation = 0x80,
    SystemProcessorProfileControlArea = 0x81,
    SystemCombinePhysicalMemoryInformation = 0x82,
    SystemEntropyInterruptTimingInformation = 0x83,
    SystemConsoleInformation = 0x84,
    SystemPlatformBinaryInformation = 0x85,
    SystemThrottleNotificationInformation = 0x86,
    SystemHypervisorProcessorCountInformation = 0x87,
    SystemDeviceDataInformation = 0x88,
    SystemDeviceDataEnumerationInformation = 0x89,
    SystemMemoryTopologyInformation = 0x8a,
    SystemMemoryChannelInformation = 0x8b,
    SystemBootLogoInformation = 0x8c,
    SystemProcessorPerformanceInformationEx = 0x8d,
    SystemSpare0 = 0x8e,
    SystemSecureBootPolicyInformation = 0x8f,
    SystemPageFileInformationEx = 0x90,
    SystemSecureBootInformation = 0x91,
    SystemEntropyInterruptTimingRawInformation = 0x92,
    SystemPortableWorkspaceEfiLauncherInformation = 0x93,
    SystemFullProcessInformation = 0x94,
    SystemKernelDebuggerInformationEx = 0x95,
    SystemBootMetadataInformation = 0x96,
    SystemSoftRebootInformation = 0x97,
    SystemElamCertificateInformation = 0x98,
    SystemOfflineDumpConfigInformation = 0x99,
    SystemProcessorFeaturesInformation = 0x9a,
    SystemRegistryReconciliationInformation = 0x9b,
    MaxSystemInfoClass = 0x9c,
} SYSTEM_INFORMATION_CLASS;

typedef enum _KAPC_ENVIRONMENT
{
    OriginalApcEnvironment,
    AttachedApcEnvironment,
    CurrentApcEnvironment,
    InsertApcEnvironment
} KAPC_ENVIRONMENT, *PKAPC_ENVIRONMENT;

typedef enum _MI_VAD_TYPE
{
    VadNone,
    VadDevicePhysicalMemory,
    VadImageMap,
    VadAwe,
    VadWriteWatch,
    VadLargePages,
    VadRotatePhysical,
    VadLargePageSection
} MI_VAD_TYPE, *PMI_VAD_TYPE;

typedef enum _MMSYSTEM_PTE_POOL_TYPE
{
    SystemPteSpace,
    NonPagedPoolExpansion,
    MaximumPtePoolTypes
} MMSYSTEM_PTE_POOL_TYPE;
```

`KernelAntiCheat/Natives/NativeStructs.h`:

```h
#pragma once

#include "PEStructs.h"
#include "stdint.h"

#define MAKEINTRESOURCEW(i) ((PWCH)((ULONG_PTR)((USHORT)(i))))

#pragma pack(push, 4)
#define POBJECT PVOID
#define GDI_BATCH_BUFFER_SIZE 310

typedef struct SSDTStruct
{
    DWORD* KiServiceTable;		//SSDT entry 
    DWORD* CounterBaseTable;
    DWORD nSystemCalls;			//nElements SSDT
    DWORD* KiArgumentTable;
} SSDT;


typedef struct _SYSTEM_CODEINTEGRITY_INFORMATION {
    ULONG  Length;
    ULONG  CodeIntegrityOptions;
} SYSTEM_CODEINTEGRITY_INFORMATION, * PSYSTEM_CODEINTEGRITY_INFORMATION;

typedef struct _TEB_ACTIVE_FRAME_CONTEXT
{
    ULONG Flags;
    PSTR FrameName;
} TEB_ACTIVE_FRAME_CONTEXT, * PTEB_ACTIVE_FRAME_CONTEXT;

typedef struct _TEB_ACTIVE_FRAME
{
    ULONG Flags;
    struct _TEB_ACTIVE_FRAME* Previous;
    PTEB_ACTIVE_FRAME_CONTEXT Context;
} TEB_ACTIVE_FRAME, * PTEB_ACTIVE_FRAME;

typedef struct _GDI_TEB_BATCH
{
    ULONG Offset;
    ULONG_PTR HDC;
    ULONG Buffer[GDI_BATCH_BUFFER_SIZE];
} GDI_TEB_BATCH, * PGDI_TEB_BATCH;

typedef struct _ACTIVATION_CONTEXT_STACK
{
    struct _RTL_ACTIVATION_CONTEXT_STACK_FRAME* ActiveFrame;
    LIST_ENTRY FrameListCache;
    ULONG Flags;
    ULONG NextCookieSequenceNumber;
    ULONG StackId;
} ACTIVATION_CONTEXT_STACK, * PACTIVATION_CONTEXT_STACK;

typedef struct _TEB
{
    NT_TIB NtTib;

    PVOID EnvironmentPointer;
    CLIENT_ID ClientId;
    PVOID ActiveRpcHandle;
    PVOID ThreadLocalStoragePointer;
    PPEB ProcessEnvironmentBlock;

    ULONG LastErrorValue;
    ULONG CountOfOwnedCriticalSections;
    PVOID CsrClientThread;
    PVOID Win32ThreadInfo;
    ULONG User32Reserved[26];
    ULONG UserReserved[5];
    PVOID WOW32Reserved;
    LCID CurrentLocale;
    ULONG FpSoftwareStatusRegister;
    PVOID ReservedForDebuggerInstrumentation[16];
#ifdef _WIN64
    PVOID SystemReserved1[30];
#else
    PVOID SystemReserved1[26];
#endif
    CHAR PlaceholderCompatibilityMode;
    CHAR PlaceholderReserved[11];
    ULONG ProxiedProcessId;
    ACTIVATION_CONTEXT_STACK ActivationStack;

    UCHAR WorkingOnBehalfTicket[8];
    NTSTATUS ExceptionCode;

    PACTIVATION_CONTEXT_STACK ActivationContextStackPointer;
    ULONG_PTR InstrumentationCallbackSp;
    ULONG_PTR InstrumentationCallbackPreviousPc;
    ULONG_PTR InstrumentationCallbackPreviousSp;
#ifdef _WIN64
    ULONG TxFsContext;
#endif
    BOOLEAN InstrumentationCallbackDisabled;
#ifndef _WIN64
    UCHAR SpareBytes[23];
    ULONG TxFsContext;
#endif
    GDI_TEB_BATCH GdiTebBatch;
    CLIENT_ID RealClientId;
    HANDLE GdiCachedProcessHandle;
    ULONG GdiClientPID;
    ULONG GdiClientTID;
    PVOID GdiThreadLocalInfo;
    ULONG_PTR Win32ClientInfo[62];
    PVOID glDispatchTable[233];
    ULONG_PTR glReserved1[29];
    PVOID glReserved2;
    PVOID glSectionInfo;
    PVOID glSection;
    PVOID glTable;
    PVOID glCurrentRC;
    PVOID glContext;

    NTSTATUS LastStatusValue;
    UNICODE_STRING StaticUnicodeString;
    WCHAR StaticUnicodeBuffer[261];

    PVOID DeallocationStack;
    PVOID TlsSlots[64];
    LIST_ENTRY TlsLinks;

    PVOID Vdm;
    PVOID ReservedForNtRpc;
    PVOID DbgSsReserved[2];

    ULONG HardErrorMode;
#ifdef _WIN64
    PVOID Instrumentation[11];
#else
    PVOID Instrumentation[9];
#endif
    GUID ActivityId;

    PVOID SubProcessTag;
    PVOID PerflibData;
    PVOID EtwTraceData;
    PVOID WinSockData;
    ULONG GdiBatchCount;

    union
    {
        PROCESSOR_NUMBER CurrentIdealProcessor;
        ULONG IdealProcessorValue;
        struct
        {
            UCHAR ReservedPad0;
            UCHAR ReservedPad1;
            UCHAR ReservedPad2;
            UCHAR IdealProcessor;
        } s1;
    } u1;

    ULONG GuaranteedStackBytes;
    PVOID ReservedForPerf;
    PVOID ReservedForOle;
    ULONG WaitingOnLoaderLock;
    PVOID SavedPriorityState;
    ULONG_PTR ReservedForCodeCoverage;
    PVOID ThreadPoolData;
    PVOID* TlsExpansionSlots;
#ifdef _WIN64
    PVOID DeallocationBStore;
    PVOID BStoreLimit;
#endif
    ULONG MuiGeneration;
    ULONG IsImpersonating;
    PVOID NlsCache;
    PVOID pShimData;
    USHORT HeapVirtualAffinity;
    USHORT LowFragHeapDataSlot;
    HANDLE CurrentTransactionHandle;
    PTEB_ACTIVE_FRAME ActiveFrame;
    PVOID FlsData;

    PVOID PreferredLanguages;
    PVOID UserPrefLanguages;
    PVOID MergedPrefLanguages;
    ULONG MuiImpersonation;

    union
    {
        USHORT CrossTebFlags;
        USHORT SpareCrossTebBits : 16;
    } u2;
    union
    {
        USHORT SameTebFlags;
        struct
        {
            USHORT SafeThunkCall : 1;
            USHORT InDebugPrint : 1;
            USHORT HasFiberData : 1;
            USHORT SkipThreadAttach : 1;
            USHORT WerInShipAssertCode : 1;
            USHORT RanProcessInit : 1;
            USHORT ClonedThread : 1;
            USHORT SuppressDebugMsg : 1;
            USHORT DisableUserStackWalk : 1;
            USHORT RtlExceptionAttached : 1;
            USHORT InitialThread : 1;
            USHORT SessionAware : 1;
            USHORT LoadOwner : 1;
            USHORT LoaderWorker : 1;
            USHORT SkipLoaderInit : 1;
            USHORT SpareSameTebBits : 1;
        } s2;
    } u3;

    PVOID TxnScopeEnterCallback;
    PVOID TxnScopeExitCallback;
    PVOID TxnScopeContext;
    ULONG LockCount;
    LONG WowTebOffset;
    PVOID ResourceRetValue;
    PVOID ReservedForWdf;
    ULONGLONG ReservedForCrt;
    GUID EffectiveContainerId;
} TEB, * PTEB;

typedef struct _RTLP_CURDIR_REF* PRTLP_CURDIR_REF;

typedef struct _RTL_RELATIVE_NAME_U
{
    UNICODE_STRING RelativeName;
    HANDLE ContainingDirectory;
    PRTLP_CURDIR_REF CurDirRef;
} RTL_RELATIVE_NAME_U, * PRTL_RELATIVE_NAME_U;

typedef struct _SYSTEM_HANDLE
{
    ULONG 	uIdProcess;
    UCHAR 	ObjectType;
    UCHAR 	Flags;
    USHORT 	Handle;
    POBJECT 	pObject;
    ACCESS_MASK 	GrantedAccess;
}SYSTEM_HANDLE;

typedef struct _SYSTEM_HANDLE_INFORMATION {
    ULONG			uCount;
    SYSTEM_HANDLE	Handles[ANYSIZE_ARRAY];
} SYSTEM_HANDLE_INFORMATION, * PSYSTEM_HANDLE_INFORMATION;

#pragma pack(pop)

typedef struct _UNLOADED_DRIVERS {
    UNICODE_STRING Name;
    PVOID StartAddress;
    PVOID EndAddress;
    LARGE_INTEGER CurrentTime;
} UNLOADED_DRIVERS, * PUNLOADED_DRIVERS;

typedef struct _SYSTEM_BOOT_ENVIRONMENT_INFORMATION_V1 {
    struct _GUID BootIdentifier;
    enum _FIRMWARE_TYPE FirmwareType;
} SYSTEM_BOOT_ENVIRONMENT_INFORMATION_V1, * PSYSTEM_BOOT_ENVIRONMENT_INFORMATION_V1;

// Size=32
typedef struct _SYSTEM_BOOT_ENVIRONMENT_INFORMATION {
    struct _GUID BootIdentifier;
    enum _FIRMWARE_TYPE FirmwareType;
    unsigned __int64 BootFlags;
} SYSTEM_BOOT_ENVIRONMENT_INFORMATION, * PSYSTEM_BOOT_ENVIRONMENT_INFORMATION;

typedef struct _SYSTEM_BIGPOOL_ENTRY
{
    union {
        uintptr_t VirtualAddress;
        ULONG_PTR NonPaged : 1;
    };
    ULONG_PTR SizeInBytes;
    union {
        UCHAR Tag[4];
        ULONG TagUlong;
    };
} SYSTEM_BIGPOOL_ENTRY, * PSYSTEM_BIGPOOL_ENTRY;

typedef struct _SYSTEM_BIGPOOL_INFORMATION {
    ULONG Count;
    SYSTEM_BIGPOOL_ENTRY AllocatedInfo[ANYSIZE_ARRAY];
} SYSTEM_BIGPOOL_INFORMATION, * PSYSTEM_BIGPOOL_INFORMATION;

typedef struct PiDDBCacheEntry
{
    LIST_ENTRY		List;
    UNICODE_STRING	DriverName;
    ULONG			TimeDateStamp;
    NTSTATUS		LoadStatus;
    char			_0x0028[16]; // data from the shim engine, or uninitialized memory for custom drivers
} piddbcentry;

typedef union _cr0_t
{
    struct
    {
        uint64_t protection_enable : 1;
        uint64_t monitor_coprocessor : 1;
        uint64_t emulation : 1;
        uint64_t task_switched : 1;
        uint64_t extension_type : 1;
        uint64_t numeric_error : 1;
        uint64_t reserved : 10;
        uint64_t write_protect : 1;
        uint64_t reserved_1 : 1;
        uint64_t alignment_mask : 1;
        uint64_t reserved_2 : 10;
        uint64_t not_write_through : 1;
        uint64_t cache_disable : 1;
        uint64_t paging : 1;
        uint64_t reserved_3 : 32;
    };

    uint64_t full;
} cr0_t;

typedef struct _OBJDIR_INFORMATION {
    UNICODE_STRING          ObjectName;
    UNICODE_STRING          ObjectTypeName;
    BYTE                    Data[1];
} OBJDIR_INFORMATION, * POBJDIR_INFORMATION;

typedef union PML4E_ {
    pte_uint64 value;
    struct {
        pte_uint64 present : 1;
        pte_uint64 rw : 1;
        pte_uint64 user : 1;
        pte_uint64 write_through : 1;
        pte_uint64 cache_disable : 1;
        pte_uint64 accessed : 1;
        pte_uint64 ignored_1 : 1;
        pte_uint64 reserved_1 : 1;
        pte_uint64 ignored_2 : 4;
        pte_uint64 pdpt_p : 40;
        pte_uint64 ignored_3 : 11;
        pte_uint64 xd : 1;
    };
} PML4E;

typedef union PDPTE_ {
    pte_uint64 value;
    struct {
        pte_uint64 present : 1;
        pte_uint64 rw : 1;
        pte_uint64 user : 1;
        pte_uint64 write_through : 1;
        pte_uint64 cache_disable : 1;
        pte_uint64 accessed : 1;
        pte_uint64 dirty : 1;
        pte_uint64 page_size : 1;
        pte_uint64 ignored_2 : 4;
        pte_uint64 pd_p : 40;
        pte_uint64 ignored_3 : 11;
        pte_uint64 xd : 1;
    };
} PDPTE;

typedef union CR3_ {
  pte_uint64 value;
  struct {
    pte_uint64 ignored_1     : 3;
    pte_uint64 write_through : 1;
    pte_uint64 cache_disable : 1;
    pte_uint64 ignored_2     : 7;
    pte_uint64 pml4_p        :40;
    pte_uint64 reserved      :12;
  };
} PTE_CR3;

typedef union VIRT_ADDR_ {
  pte_uint64 value;
  void *pointer;
  struct {
    pte_uint64 offset        : 12;
    pte_uint64 pt_index      :  9;
    pte_uint64 pd_index      :  9;
    pte_uint64 pdpt_index    :  9;
    pte_uint64 pml4_index    :  9;
    pte_uint64 reserved      : 16;
  };
} VIRT_ADDR;

typedef struct _KNONVOLATILE_CONTEXT_POINTERS
{
    PULONGLONG dummy;
} KNONVOLATILE_CONTEXT_POINTERS, * PKNONVOLATILE_CONTEXT_POINTERS;

typedef struct _SYSTEM_MODULE {
    HANDLE Section;
    PVOID MappedBase;
    PVOID ImageBase;
    ULONG ImageSize;
    ULONG Flags;
    USHORT LoadOrderIndex;
    USHORT InitOrderIndex;
    USHORT LoadCount;
    USHORT OffsetToFileName;
    UCHAR  FullPathName[MAXIMUM_FILENAME_LENGTH];
} SYSTEM_MODULE, * PSYSTEM_MODULE;

typedef struct _SYSTEM_MODULE_INFORMATION {
    ULONG NumberOfModules;
    SYSTEM_MODULE Modules[1];
} SYSTEM_MODULE_INFORMATION, * PSYSTEM_MODULE_INFORMATION;

typedef struct _SYSTEM_SERVICE_DESCRIPTOR_TABLE 
{
    PULONG_PTR ServiceTableBase;
    PULONG ServiceCounterTableBase;
    ULONG_PTR NumberOfServices;
    PUCHAR ParamTableBase;
} SYSTEM_SERVICE_DESCRIPTOR_TABLE, *PSYSTEM_SERVICE_DESCRIPTOR_TABLE;

typedef union _PS_PROTECTION
{
    UCHAR Level;
    struct
    {
        int Type : 3;
        int Audit : 1;
        int Signer : 4;
    } Flags;
} PS_PROTECTION, *PPS_PROTECTION;

typedef union _KEXECUTE_OPTIONS
{
    struct
    {
        int ExecuteDisable : 1;                     // 0x01
        int ExecuteEnable : 1;                      // 0x02
        int DisableThunkEmulation : 1;              // 0x04
        int Permanent : 1;                          // 0x08
        int ExecuteDispatchEnable : 1;              // 0x10
        int ImageDispatchEnable : 1;                // 0x20
        int DisableExceptionChainValidation : 1;    // 0x40
        int Spare : 1;
    } Flags;

    UCHAR ExecuteOptions;
} KEXECUTE_OPTIONS, *PKEXECUTE_OPTIONS;

typedef struct _EPROCESS_FLAGS2
{
    unsigned int JobNotReallyActive : 1;
    unsigned int AccountingFolded : 1;
    unsigned int NewProcessReported : 1;
    unsigned int ExitProcessReported : 1;
    unsigned int ReportCommitChanges : 1;
    unsigned int LastReportMemory : 1;
    unsigned int ForceWakeCharge : 1;
    unsigned int CrossSessionCreate : 1;
    unsigned int NeedsHandleRundown : 1;
    unsigned int RefTraceEnabled : 1;
    unsigned int DisableDynamicCode : 1;
    unsigned int EmptyJobEvaluated : 1;
    unsigned int DefaultPagePriority : 3;
    unsigned int PrimaryTokenFrozen : 1;
    unsigned int ProcessVerifierTarget : 1;
    unsigned int StackRandomizationDisabled : 1;
    unsigned int AffinityPermanent : 1;
    unsigned int AffinityUpdateEnable : 1;
    unsigned int PropagateNode : 1;
    unsigned int ExplicitAffinity : 1;
    unsigned int ProcessExecutionState : 2;
    unsigned int DisallowStrippedImages : 1;
    unsigned int HighEntropyASLREnabled : 1;
    unsigned int ExtensionPointDisable : 1;
    unsigned int ForceRelocateImages : 1;
    unsigned int ProcessStateChangeRequest : 2;
    unsigned int ProcessStateChangeInProgress : 1;
    unsigned int DisallowWin32kSystemCalls : 1;
} EPROCESS_FLAGS2, *PEPROCESS_FLAGS2;

typedef struct _MITIGATION_FLAGS
{
    unsigned int ControlFlowGuardEnabled : 1;
    unsigned int ControlFlowGuardExportSuppressionEnabled : 1;
    unsigned int ControlFlowGuardStrict : 1;
    unsigned int DisallowStrippedImages : 1;
    unsigned int ForceRelocateImages : 1;
    unsigned int HighEntropyASLREnabled : 1;
    unsigned int StackRandomizationDisabled : 1;
    unsigned int ExtensionPointDisable : 1;
    unsigned int DisableDynamicCode : 1;
    unsigned int DisableDynamicCodeAllowOptOut : 1;
    unsigned int DisableDynamicCodeAllowRemoteDowngrade : 1;
    unsigned int AuditDisableDynamicCode : 1;
    unsigned int DisallowWin32kSystemCalls : 1;
    unsigned int AuditDisallowWin32kSystemCalls : 1;
    unsigned int EnableFilteredWin32kAPIs : 1;
    unsigned int AuditFilteredWin32kAPIs : 1;
    unsigned int DisableNonSystemFonts : 1;
    unsigned int AuditNonSystemFontLoading : 1;
    unsigned int PreferSystem32Images : 1;
    unsigned int ProhibitRemoteImageMap : 1;
    unsigned int AuditProhibitRemoteImageMap : 1;
    unsigned int ProhibitLowILImageMap : 1;
    unsigned int AuditProhibitLowILImageMap : 1;
    unsigned int SignatureMitigationOpt: 1;
    unsigned int AuditBlockNonMicrosoftBinaries : 1;
    unsigned int AuditBlockNonMicrosoftBinariesAllowStore : 1;
    unsigned int LoaderIntegrityContinuityEnabled : 1;
    unsigned int AuditLoaderIntegrityContinuity : 1;
    unsigned int EnableModuleTamperingProtection : 1;
    unsigned int EnableModuleTamperingProtectionNoInherit : 1;
    unsigned int RestrictIndirectBranchPrediction;
    unsigned int IsolateSecurityDomain;
} MITIGATION_FLAGS, *PMITIGATION_FLAGS;

typedef union _EXHANDLE
{
    struct
    {
        int TagBits : 2;
        int Index : 30;
    } u;
    void * GenericHandleOverlay;
    ULONG_PTR Value;
} EXHANDLE, *PEXHANDLE;

#pragma warning(disable : 4214 4201)

#pragma pack(push, 1)
typedef struct _POOL_HEADER // Size=16
{
    union
    {
        struct
        {
            unsigned long PreviousSize : 8; // Size=4 Offset=0 BitOffset=0 BitCount=8
            unsigned long PoolIndex : 8; // Size=4 Offset=0 BitOffset=8 BitCount=8
            unsigned long BlockSize : 8; // Size=4 Offset=0 BitOffset=16 BitCount=8
            unsigned long PoolType : 8; // Size=4 Offset=0 BitOffset=24 BitCount=8
        };
        unsigned long Ulong1; // Size=4 Offset=0
    };
    unsigned long PoolTag; // Size=4 Offset=4
    union
    {
        struct _EPROCESS * ProcessBilled; // Size=8 Offset=8
        struct
        {
            unsigned short AllocatorBackTraceIndex; // Size=2 Offset=8
            unsigned short PoolTagHash; // Size=2 Offset=10
        };
    };
} POOL_HEADER, *PPOOL_HEADER;
#pragma pack(pop)

typedef struct _HANDLE_TABLE_ENTRY // Size=16
{
    union
    {
        ULONG_PTR VolatileLowValue; // Size=8 Offset=0
        ULONG_PTR LowValue; // Size=8 Offset=0
        struct _HANDLE_TABLE_ENTRY_INFO * InfoTable; // Size=8 Offset=0
        struct
        {
            ULONG_PTR Unlocked : 1; // Size=8 Offset=0 BitOffset=0 BitCount=1
            ULONG_PTR RefCnt : 16; // Size=8 Offset=0 BitOffset=1 BitCount=16
            ULONG_PTR Attributes : 3; // Size=8 Offset=0 BitOffset=17 BitCount=3
            ULONG_PTR ObjectPointerBits : 44; // Size=8 Offset=0 BitOffset=20 BitCount=44
        };
    };
    union
    {
        ULONG_PTR HighValue; // Size=8 Offset=8
        struct _HANDLE_TABLE_ENTRY * NextFreeHandleEntry; // Size=8 Offset=8
        union _EXHANDLE LeafHandleValue; // Size=8 Offset=8
        struct
        {
            ULONG GrantedAccessBits : 25; // Size=4 Offset=8 BitOffset=0 BitCount=25
            ULONG NoRightsUpgrade : 1; // Size=4 Offset=8 BitOffset=25 BitCount=1
            ULONG Spare : 6; // Size=4 Offset=8 BitOffset=26 BitCount=6
        };
    };
    ULONG TypeInfo; // Size=4 Offset=12
} HANDLE_TABLE_ENTRY, *PHANDLE_TABLE_ENTRY;



typedef struct _OBJECT_HEADER // Size=56
{
    ULONG_PTR PointerCount; // Size=8 Offset=0
    union
    {
        ULONG_PTR HandleCount; // Size=8 Offset=8
        void * NextToFree; // Size=8 Offset=8
    };
    void* Lock; // Size=8 Offset=16
    UCHAR TypeIndex; // Size=1 Offset=24
    union
    {
        UCHAR TraceFlags; // Size=1 Offset=25
        struct
        {
            UCHAR DbgRefTrace : 1; // Size=1 Offset=25 BitOffset=0 BitCount=1
            UCHAR DbgTracePermanent : 1; // Size=1 Offset=25 BitOffset=1 BitCount=1
        };
    };
    UCHAR InfoMask; // Size=1 Offset=26
    union
    {
        UCHAR Flags; // Size=1 Offset=27
        struct
        {
            UCHAR NewObject : 1; // Size=1 Offset=27 BitOffset=0 BitCount=1
            UCHAR KernelObject : 1; // Size=1 Offset=27 BitOffset=1 BitCount=1
            UCHAR KernelOnlyAccess : 1; // Size=1 Offset=27 BitOffset=2 BitCount=1
            UCHAR ExclusiveObject : 1; // Size=1 Offset=27 BitOffset=3 BitCount=1
            UCHAR PermanentObject : 1; // Size=1 Offset=27 BitOffset=4 BitCount=1
            UCHAR DefaultSecurityQuota : 1; // Size=1 Offset=27 BitOffset=5 BitCount=1
            UCHAR SingleHandleEntry : 1; // Size=1 Offset=27 BitOffset=6 BitCount=1
            UCHAR DeletedInline : 1; // Size=1 Offset=27 BitOffset=7 BitCount=1
        };
    };
    ULONG Spare; // Size=4 Offset=28
    union
    {
        struct _OBJECT_CREATE_INFORMATION * ObjectCreateInfo; // Size=8 Offset=32
        void * QuotaBlockCharged; // Size=8 Offset=32
    };
    void * SecurityDescriptor; // Size=8 Offset=40
    struct _QUAD Body; // Size=8 Offset=48
} OBJECT_HEADER, *POBJECT_HEADER;

typedef union _EX_FAST_REF // Size=8
{
    void * Object;
    struct
    {
        unsigned __int64 RefCnt : 4; 
    };
    unsigned __int64 Value;
} EX_FAST_REF, *PEX_FAST_REF;

typedef struct _CONTROL_AREA // Size=120
{
    struct _SEGMENT * Segment;
    struct _LIST_ENTRY ListHead;
    unsigned __int64 NumberOfSectionReferences;
    unsigned __int64 NumberOfPfnReferences; 
    unsigned __int64 NumberOfMappedViews;
    unsigned __int64 NumberOfUserReferences;
    unsigned long f1; 
    unsigned long f2;
    EX_FAST_REF FilePointer;
    // Other fields
} CONTROL_AREA, *PCONTROL_AREA;

typedef struct _SUBSECTION // Size=56
{
    PCONTROL_AREA ControlArea;
    // Other fields
} SUBSECTION, *PSUBSECTION;

typedef struct _MEMORY_BASIC_INFORMATION_EX
{
    PVOID BaseAddress;
    PVOID AllocationBase;
    ULONG AllocationProtect;
    SIZE_T RegionSize;
    ULONG State;
    ULONG Protect;
    ULONG Type;
} MEMORY_BASIC_INFORMATION_EX, *PMEMORY_BASIC_INFORMATION_EX;

typedef struct _SYSTEM_CALL_COUNT_INFORMATION
{
    ULONG Length;
    ULONG NumberOfTables;
    ULONG limits[2];
 } SYSTEM_CALL_COUNT_INFORMATION, *PSYSTEM_CALL_COUNT_INFORMATION;

typedef struct _SYSTEM_THREAD_INFORMATION
{
    LARGE_INTEGER KernelTime;
    LARGE_INTEGER UserTime;
    LARGE_INTEGER CreateTime;
    ULONG WaitTime;
    PVOID StartAddress;
    CLIENT_ID ClientId;
    KPRIORITY Priority;
    LONG BasePriority;
    ULONG ContextSwitches;
    ULONG ThreadState;
    KWAIT_REASON WaitReason;
}SYSTEM_THREAD_INFORMATION, *PSYSTEM_THREAD_INFORMATION;

typedef struct _THREAD_BASIC_INFORMATION
{
    NTSTATUS ExitStatus;
    PVOID TeUNIaseAddress;
    CLIENT_ID ClientId;
    ULONG_PTR AffinityMask;
    LONG Priority;
    LONG BasePriority;
} THREAD_BASIC_INFORMATION, *PTHREAD_BASIC_INFORMATION;

typedef struct _SYSTEM_PROCESS_INFO
{
    ULONG NextEntryOffset;
    ULONG NumberOfThreads;
    LARGE_INTEGER WorkingSetPrivateSize;
    ULONG HardFaultCount;
    ULONG NumberOfThreadsHighWatermark;
    ULONGLONG CycleTime;
    LARGE_INTEGER CreateTime;
    LARGE_INTEGER UserTime;
    LARGE_INTEGER KernelTime;
    UNICODE_STRING ImageName;
    KPRIORITY BasePriority;
    HANDLE UniqueProcessId;
    HANDLE InheritedFromUniqueProcessId;
    ULONG HandleCount;
    ULONG SessionId;
    ULONG_PTR UniqueProcessKey;
    SIZE_T PeakVirtualSize;
    SIZE_T VirtualSize;
    ULONG PageFaultCount;
    SIZE_T PeakWorkingSetSize;
    SIZE_T WorkingSetSize;
    SIZE_T QuotaPeakPagedPoolUsage;
    SIZE_T QuotaPagedPoolUsage;
    SIZE_T QuotaPeakNonPagedPoolUsage;
    SIZE_T QuotaNonPagedPoolUsage;
    SIZE_T PagefileUsage;
    SIZE_T PeakPagefileUsage;
    SIZE_T PrivatePageCount;
    LARGE_INTEGER ReadOperationCount;
    LARGE_INTEGER WriteOperationCount;
    LARGE_INTEGER OtherOperationCount;
    LARGE_INTEGER ReadTransferCount;
    LARGE_INTEGER WriteTransferCount;
    LARGE_INTEGER OtherTransferCount;
    SYSTEM_THREAD_INFORMATION Threads[1];
}SYSTEM_PROCESS_INFO, *PSYSTEM_PROCESS_INFO;

#pragma warning(disable : 4214)
typedef struct _MMPTE_HARDWARE64
{
    ULONGLONG Valid : 1;
    ULONGLONG Dirty1 : 1;
    ULONGLONG Owner : 1;
    ULONGLONG WriteThrough : 1;
    ULONGLONG CacheDisable : 1;
    ULONGLONG Accessed : 1;
    ULONGLONG Dirty : 1;
    ULONGLONG LargePage : 1;
    ULONGLONG Global : 1;
    ULONGLONG CopyOnWrite : 1;
    ULONGLONG Unused : 1;
    ULONGLONG Write : 1;
    ULONGLONG PageFrameNumber : 36;
    ULONGLONG reserved1 : 4;
    ULONGLONG SoftwareWsIndex : 11;
    ULONGLONG NoExecute : 1;
} MMPTE_HARDWARE64, *PMMPTE_HARDWARE64;

typedef struct _MMPTE 
{
    union  
    {
        ULONG_PTR Long;
        MMPTE_HARDWARE64 Hard;
    } u;
} MMPTE;
typedef MMPTE *PMMPTE;

#pragma warning(default : 4214)

typedef struct _NT_PROC_THREAD_ATTRIBUTE_ENTRY
{
    ULONG Attribute;    // PROC_THREAD_ATTRIBUTE_XXX
    SIZE_T Size;
    ULONG_PTR Value;
    ULONG Unknown;
} NT_PROC_THREAD_ATTRIBUTE_ENTRY, *NT_PPROC_THREAD_ATTRIBUTE_ENTRY;

typedef struct _NT_PROC_THREAD_ATTRIBUTE_LIST
{
    ULONG Length;
    NT_PROC_THREAD_ATTRIBUTE_ENTRY Entry[1];
} NT_PROC_THREAD_ATTRIBUTE_LIST, *PNT_PROC_THREAD_ATTRIBUTE_LIST;


typedef struct _RTL_PROCESS_MODULE_INFORMATION
{
    HANDLE Section;         // Not filled in
    PVOID MappedBase;
    PVOID ImageBase;
    ULONG ImageSize;
    ULONG Flags;
    USHORT LoadOrderIndex;
    USHORT InitOrderIndex;
    USHORT LoadCount;
    USHORT OffsetToFileName;
    UCHAR  FullPathName[MAXIMUM_FILENAME_LENGTH];
} RTL_PROCESS_MODULE_INFORMATION, *PRTL_PROCESS_MODULE_INFORMATION;

typedef struct _RTL_PROCESS_MODULES
{
    ULONG NumberOfModules;
    RTL_PROCESS_MODULE_INFORMATION Modules[1];
} RTL_PROCESS_MODULES, *PRTL_PROCESS_MODULES;

#pragma warning(disable : 4214)
typedef union _MEMORY_WORKING_SET_EX_BLOCK 
{
    ULONG_PTR Flags;
    struct
    {
        ULONG_PTR Valid : 1;
        ULONG_PTR ShareCount : 3;
        ULONG_PTR Win32Protection : 11;
        ULONG_PTR Shared : 1;
        ULONG_PTR Node : 6;
        ULONG_PTR Locked : 1;
        ULONG_PTR LargePage : 1;
        ULONG_PTR Reserved : 7;
        ULONG_PTR Bad : 1;

#if defined(_WIN64)
        ULONG_PTR ReservedUlong : 32;
#endif
    };
} MEMORY_WORKING_SET_EX_BLOCK, *PMEMORY_WORKING_SET_EX_BLOCK;

typedef struct _MEMORY_WORKING_SET_EX_INFORMATION 
{
    PVOID VirtualAddress;
    MEMORY_WORKING_SET_EX_BLOCK VirtualAttributes;
} MEMORY_WORKING_SET_EX_INFORMATION, *PMEMORY_WORKING_SET_EX_INFORMATION;

#pragma warning(default : 4214)


typedef struct _PEB_LDR_DATA 
{
    ULONG Length;
    UCHAR Initialized;
    PVOID SsHandle;
    LIST_ENTRY InLoadOrderModuleList;
    LIST_ENTRY InMemoryOrderModuleList;
    LIST_ENTRY InInitializationOrderModuleList;
} PEB_LDR_DATA, *PPEB_LDR_DATA;

typedef struct _LDR_DATA_TABLE_ENTRY 
{
    LIST_ENTRY InLoadOrderLinks;
    LIST_ENTRY InMemoryOrderLinks;
    LIST_ENTRY InInitializationOrderLinks;
    PVOID DllBase;
    PVOID EntryPoint;
    ULONG SizeOfImage;
    UNICODE_STRING FullDllName;
    UNICODE_STRING BaseDllName;
    ULONG Flags;
    USHORT LoadCount;
    USHORT TlsIndex;
    LIST_ENTRY HashLinks;
    ULONG TimeDateStamp;
} LDR_DATA_TABLE_ENTRY, *PLDR_DATA_TABLE_ENTRY;


typedef struct _PEB 
{
    UCHAR InheritedAddressSpace;
    UCHAR ReadImageFileExecOptions;
    UCHAR BeingDebugged;
    UCHAR BitField;
    PVOID Mutant;
    PVOID ImageBaseAddress;
    PPEB_LDR_DATA Ldr;
    PVOID ProcessParameters;
    PVOID SubSystemData;
    PVOID ProcessHeap;
    PVOID FastPebLock;
    PVOID AtlThunkSListPtr;
    PVOID IFEOKey;
    PVOID CrossProcessFlags;
    PVOID KernelCallbackTable;
    ULONG SystemReserved;
    ULONG AtlThunkSListPtr32;
    PVOID ApiSetMap;
} PEB, *PPEB;

typedef struct _PEB_LDR_DATA32
{
    ULONG Length;
    UCHAR Initialized;
    ULONG SsHandle;
    LIST_ENTRY32 InLoadOrderModuleList;
    LIST_ENTRY32 InMemoryOrderModuleList;
    LIST_ENTRY32 InInitializationOrderModuleList;
} PEB_LDR_DATA32, *PPEB_LDR_DATA32;

typedef struct _LDR_DATA_TABLE_ENTRY32
{
    LIST_ENTRY32 InLoadOrderLinks;
    LIST_ENTRY32 InMemoryOrderLinks;
    LIST_ENTRY32 InInitializationOrderLinks;
    ULONG DllBase;
    ULONG EntryPoint;
    ULONG SizeOfImage;
    UNICODE_STRING32 FullDllName;
    UNICODE_STRING32 BaseDllName;
    ULONG Flags;
    USHORT LoadCount;
    USHORT TlsIndex;
    LIST_ENTRY32 HashLinks;
    ULONG TimeDateStamp;
} LDR_DATA_TABLE_ENTRY32, *PLDR_DATA_TABLE_ENTRY32;

typedef struct _PEB32
{
    UCHAR InheritedAddressSpace;
    UCHAR ReadImageFileExecOptions;
    UCHAR BeingDebugged;
    UCHAR BitField;
    ULONG Mutant;
    ULONG ImageBaseAddress;
    ULONG Ldr;
    ULONG ProcessParameters;
    ULONG SubSystemData;
    ULONG ProcessHeap;
    ULONG FastPebLock;
    ULONG AtlThunkSListPtr;
    ULONG IFEOKey;
    ULONG CrossProcessFlags;
    ULONG UserSharedInfoPtr;
    ULONG SystemReserved;
    ULONG AtlThunkSListPtr32;
    ULONG ApiSetMap;
} PEB32, *PPEB32;

typedef struct _WOW64_PROCESS 
{
    PPEB32 Wow64;
} WOW64_PROCESS, *PWOW64_PROCESS;

typedef union _WOW64_APC_CONTEXT 
{
    struct 
    {
        ULONG Apc32BitContext;
        ULONG Apc32BitRoutine;
    };

    PVOID Apc64BitContext;

} WOW64_APC_CONTEXT, *PWOW64_APC_CONTEXT;

typedef struct _NON_PAGED_DEBUG_INFO
{
    USHORT      Signature;
    USHORT      Flags;
    ULONG       Size;
    USHORT      Machine;
    USHORT      Characteristics;
    ULONG       TimeDateStamp;
    ULONG       CheckSum;
    ULONG       SizeOfImage;
    ULONGLONG   ImageBase;
} NON_PAGED_DEBUG_INFO, *PNON_PAGED_DEBUG_INFO;

typedef struct _KLDR_DATA_TABLE_ENTRY
{
    LIST_ENTRY InLoadOrderLinks;
    PVOID ExceptionTable;
    ULONG ExceptionTableSize;
    // ULONG padding on IA64
    PVOID GpValue;
    PNON_PAGED_DEBUG_INFO NonPagedDebugInfo;
    PVOID DllBase;
    PVOID EntryPoint;
    ULONG SizeOfImage;
    UNICODE_STRING FullDllName;
    UNICODE_STRING BaseDllName;
    ULONG Flags;
    USHORT LoadCount;
    USHORT __Unused5;
    PVOID SectionPointer;
    ULONG CheckSum;
    // ULONG padding on IA64
    PVOID LoadedImports;
    PVOID PatchInformation;
} KLDR_DATA_TABLE_ENTRY, *PKLDR_DATA_TABLE_ENTRY;


//
// This structure is used by the debugger for all targets
// It is the same size as DBGKD_DATA_HEADER on all systems
//
typedef struct _DBGKD_DEBUG_DATA_HEADER64 {

    //
    // Link to other blocks
    //

    LIST_ENTRY64 List;

    //
    // This is a unique tag to identify the owner of the block.
    // If your component only uses one pool tag, use it for this, too.
    //

    ULONG           OwnerTag;

    //
    // This must be initialized to the size of the data block,
    // including this structure.
    //

    ULONG           Size;

} DBGKD_DEBUG_DATA_HEADER64, *PDBGKD_DEBUG_DATA_HEADER64;


//
// This structure is the same size on all systems.  The only field
// which must be translated by the debugger is Header.List.
//

//
// DO NOT ADD OR REMOVE FIELDS FROM THE MIDDLE OF THIS STRUCTURE!!!
//
// If you remove a field, replace it with an "unused" placeholder.
// Do not reuse fields until there has been enough time for old debuggers
// and extensions to age out.
//
typedef struct _KDDEBUGGER_DATA64 {

    DBGKD_DEBUG_DATA_HEADER64 Header;

    //
    // Base address of kernel image
    //

    ULONG64   KernBase;

    //
    // DbgBreakPointWithStatus is a function which takes an argument
    // and hits a breakpoint.  This field contains the address of the
    // breakpoint instruction.  When the debugger sees a breakpoint
    // at this address, it may retrieve the argument from the first
    // argument register, or on x86 the eax register.
    //

    ULONG64   BreakpointWithStatus;       // address of breakpoint

    //
    // Address of the saved context record during a bugcheck
    //
    // N.B. This is an automatic KeBugcheckEx's frame, and
    // is only valid after a bugcheck.
    //

    ULONG64   SavedContext;

    //
    // help for walking stacks with user callbacks:
    //

    //
    // The address of the thread structure is provided the
    // WAIT_STATE_CHANGE packet.  This is the offset from the base of
    // the thread structure to the pointer to the kernel stack frame
    // for the currently active usermode callback.
    //

    USHORT  ThCallbackStack;            // offset thread data

    //
    // these values are offsets into that frame:
    //

    USHORT  NextCallback;               // saved pointer to next callback frame
    USHORT  FramePointer;               // saved frame pointer

    //
    // pad to a quad boundary
    //
    USHORT  PaeEnabled;

    //
    // Address of the kernel callout routine.
    //

    ULONG64   KiCallUserMode;             // kernel routine

    //
    // Address of the usermode entry point for callbacks.
    //

    ULONG64   KeUserCallbackDispatcher;   // address ntdll


    //
    // Addresses of various kernel data structures and lists
    // that are of interest to the kernel debugger.
    //

    ULONG64   PsLoadedModuleList;
    ULONG64   PsActiveProcessHead;
    ULONG64   PspCidTable;

    ULONG64   ExpSystemResourcesList;
    ULONG64   ExpPagedPoolDescriptor;
    ULONG64   ExpNumberOfPagedPools;

    ULONG64   KeTimeIncrement;
    ULONG64   KeBugCheckCallbackListHead;
    ULONG64   KiBugcheckData;

    ULONG64   IopErrorLogListHead;

    ULONG64   ObpRootDirectoryObject;
    ULONG64   ObpTypeObjectType;

    ULONG64   MmSystemCacheStart;
    ULONG64   MmSystemCacheEnd;
    ULONG64   MmSystemCacheWs;

    ULONG64   MmPfnDatabase;
    ULONG64   MmSystemPtesStart;
    ULONG64   MmSystemPtesEnd;
    ULONG64   MmSubsectionBase;
    ULONG64   MmNumberOfPagingFiles;

    ULONG64   MmLowestPhysicalPage;
    ULONG64   MmHighestPhysicalPage;
    ULONG64   MmNumberOfPhysicalPages;

    ULONG64   MmMaximumNonPagedPoolInBytes;
    ULONG64   MmNonPagedSystemStart;
    ULONG64   MmNonPagedPoolStart;
    ULONG64   MmNonPagedPoolEnd;

    ULONG64   MmPagedPoolStart;
    ULONG64   MmPagedPoolEnd;
    ULONG64   MmPagedPoolInformation;
    ULONG64   MmPageSize;

    ULONG64   MmSizeOfPagedPoolInBytes;

    ULONG64   MmTotalCommitLimit;
    ULONG64   MmTotalCommittedPages;
    ULONG64   MmSharedCommit;
    ULONG64   MmDriverCommit;
    ULONG64   MmProcessCommit;
    ULONG64   MmPagedPoolCommit;
    ULONG64   MmExtendedCommit;

    ULONG64   MmZeroedPageListHead;
    ULONG64   MmFreePageListHead;
    ULONG64   MmStandbyPageListHead;
    ULONG64   MmModifiedPageListHead;
    ULONG64   MmModifiedNoWritePageListHead;
    ULONG64   MmAvailablePages;
    ULONG64   MmResidentAvailablePages;

    ULONG64   PoolTrackTable;
    ULONG64   NonPagedPoolDescriptor;

    ULONG64   MmHighestUserAddress;
    ULONG64   MmSystemRangeStart;
    ULONG64   MmUserProbeAddress;

    ULONG64   KdPrintCircularBuffer;
    ULONG64   KdPrintCircularBufferEnd;
    ULONG64   KdPrintWritePointer;
    ULONG64   KdPrintRolloverCount;

    ULONG64   MmLoadedUserImageList;

    // NT 5.1 Addition

    ULONG64   NtBuildLab;
    ULONG64   KiNormalSystemCall;

    // NT 5.0 hotfix addition

    ULONG64   KiProcessorBlock;
    ULONG64   MmUnloadedDrivers;
    ULONG64   MmLastUnloadedDriver;
    ULONG64   MmTriageActionTaken;
    ULONG64   MmSpecialPoolTag;
    ULONG64   KernelVerifier;
    ULONG64   MmVerifierData;
    ULONG64   MmAllocatedNonPagedPool;
    ULONG64   MmPeakCommitment;
    ULONG64   MmTotalCommitLimitMaximum;
    ULONG64   CmNtCSDVersion;

    // NT 5.1 Addition

    ULONG64   MmPhysicalMemoryBlock;
    ULONG64   MmSessionBase;
    ULONG64   MmSessionSize;
    ULONG64   MmSystemParentTablePage;

    // Server 2003 addition

    ULONG64   MmVirtualTranslationBase;

    USHORT    OffsetKThreadNextProcessor;
    USHORT    OffsetKThreadTeb;
    USHORT    OffsetKThreadKernelStack;
    USHORT    OffsetKThreadInitialStack;

    USHORT    OffsetKThreadApcProcess;
    USHORT    OffsetKThreadState;
    USHORT    OffsetKThreadBStore;
    USHORT    OffsetKThreadBStoreLimit;

    USHORT    SizeEProcess;
    USHORT    OffsetEprocessPeb;
    USHORT    OffsetEprocessParentCID;
    USHORT    OffsetEprocessDirectoryTableBase;

    USHORT    SizePrcb;
    USHORT    OffsetPrcbDpcRoutine;
    USHORT    OffsetPrcbCurrentThread;
    USHORT    OffsetPrcbMhz;

    USHORT    OffsetPrcbCpuType;
    USHORT    OffsetPrcbVendorString;
    USHORT    OffsetPrcbProcStateContext;
    USHORT    OffsetPrcbNumber;

    USHORT    SizeEThread;

    ULONG64   KdPrintCircularBufferPtr;
    ULONG64   KdPrintBufferSize;

    ULONG64   KeLoaderBlock;

    USHORT    SizePcr;
    USHORT    OffsetPcrSelfPcr;
    USHORT    OffsetPcrCurrentPrcb;
    USHORT    OffsetPcrContainedPrcb;

    USHORT    OffsetPcrInitialBStore;
    USHORT    OffsetPcrBStoreLimit;
    USHORT    OffsetPcrInitialStack;
    USHORT    OffsetPcrStackLimit;

    USHORT    OffsetPrcbPcrPage;
    USHORT    OffsetPrcbProcStateSpecialReg;
    USHORT    GdtR0Code;
    USHORT    GdtR0Data;

    USHORT    GdtR0Pcr;
    USHORT    GdtR3Code;
    USHORT    GdtR3Data;
    USHORT    GdtR3Teb;

    USHORT    GdtLdt;
    USHORT    GdtTss;
    USHORT    Gdt64R3CmCode;
    USHORT    Gdt64R3CmTeb;

    ULONG64   IopNumTriageDumpDataBlocks;
    ULONG64   IopTriageDumpDataBlocks;

    // Longhorn addition

    ULONG64   VfCrashDataBlock;
    ULONG64   MmBadPagesDetected;
    ULONG64   MmZeroedPageSingleBitErrorsDetected;

    // Windows 7 addition

    ULONG64   EtwpDebuggerData;
    USHORT    OffsetPrcbContext;

    // Windows 8 addition

    USHORT    OffsetPrcbMaxBreakpoints;
    USHORT    OffsetPrcbMaxWatchpoints;

    ULONG     OffsetKThreadStackLimit;
    ULONG     OffsetKThreadStackBase;
    ULONG     OffsetKThreadQueueListEntry;
    ULONG     OffsetEThreadIrpList;

    USHORT    OffsetPrcbIdleThread;
    USHORT    OffsetPrcbNormalDpcState;
    USHORT    OffsetPrcbDpcStack;
    USHORT    OffsetPrcbIsrStack;

    USHORT    SizeKDPC_STACK_FRAME;

    // Windows 8.1 Addition

    USHORT    OffsetKPriQueueThreadListHead;
    USHORT    OffsetKThreadWaitReason;

    // Windows 10 RS1 Addition

    USHORT    Padding;
    ULONG64   PteBase;

    // Windows 10 RS5 Addition

    ULONG64 RetpolineStubFunctionTable;
    ULONG RetpolineStubFunctionTableSize;
    ULONG RetpolineStubOffset;
    ULONG RetpolineStubSize;

} KDDEBUGGER_DATA64, *PKDDEBUGGER_DATA64;


typedef struct _DUMP_HEADER
{
    ULONG Signature;
    ULONG ValidDump;
    ULONG MajorVersion;
    ULONG MinorVersion;
    ULONG_PTR DirectoryTableBase;
    ULONG_PTR PfnDataBase;
    PLIST_ENTRY PsLoadedModuleList;
    PLIST_ENTRY PsActiveProcessHead;
    ULONG MachineImageType;
    ULONG NumberProcessors;
    ULONG BugCheckCode;
    ULONG_PTR BugCheckParameter1;
    ULONG_PTR BugCheckParameter2;
    ULONG_PTR BugCheckParameter3;
    ULONG_PTR BugCheckParameter4;
    CHAR VersionUser[32];
    struct _KDDEBUGGER_DATA64 *KdDebuggerDataBlock;
} DUMP_HEADER, *PDUMP_HEADER;

extern KDDEBUGGER_DATA64 g_KdBlock;
```

`KernelAntiCheat/Natives/PEStructs.h`:

```h
#pragma once
#include "NativeEnums.h"
#include <ntifs.h>

#define IMAGE_DOS_SIGNATURE                     0x5A4D      // MZ
#define IMAGE_NT_SIGNATURE                      0x00004550  // PE00

#define IMAGE_NT_OPTIONAL_HDR32_MAGIC           0x10b
#define IMAGE_NT_OPTIONAL_HDR64_MAGIC           0x20b

#define IMAGE_NUMBEROF_DIRECTORY_ENTRIES        16

#define IMAGE_DIRECTORY_ENTRY_EXPORT             0   // Export Directory
#define IMAGE_DIRECTORY_ENTRY_IMPORT             1   // Import Directory
#define IMAGE_DIRECTORY_ENTRY_RESOURCE           2   // Resource Directory
#define IMAGE_DIRECTORY_ENTRY_EXCEPTION          3   // Exception Directory
#define IMAGE_DIRECTORY_ENTRY_SECURITY           4   // Security Directory
#define IMAGE_DIRECTORY_ENTRY_BASERELOC          5   // Base Relocation Table
#define IMAGE_DIRECTORY_ENTRY_DEBUG              6   // Debug Directory
//      IMAGE_DIRECTORY_ENTRY_COPYRIGHT          7   // (X86 usage)
#define IMAGE_DIRECTORY_ENTRY_ARCHITECTURE       7   // Architecture Specific Data
#define IMAGE_DIRECTORY_ENTRY_GLOBALPTR          8   // RVA of GP
#define IMAGE_DIRECTORY_ENTRY_TLS                9   // TLS Directory
#define IMAGE_DIRECTORY_ENTRY_LOAD_CONFIG       10   // Load Configuration Directory
#define IMAGE_DIRECTORY_ENTRY_BOUND_IMPORT      11   // Bound Import Directory headers
#define IMAGE_DIRECTORY_ENTRY_IAT               12   // Import Address Table
#define IMAGE_DIRECTORY_ENTRY_DELAY_IMPORT      13   // Delay Load Import Descriptors
#define IMAGE_DIRECTORY_ENTRY_COM_DESCRIPTOR    14   // COM Runtime descriptor

#define IMAGE_REL_BASED_ABSOLUTE                0
#define IMAGE_REL_BASED_HIGH                    1
#define IMAGE_REL_BASED_LOW                     2
#define IMAGE_REL_BASED_HIGHLOW                 3
#define IMAGE_REL_BASED_HIGHADJ                 4
#define IMAGE_REL_BASED_MIPS_JMPADDR            5
#define IMAGE_REL_BASED_SECTION                 6
#define IMAGE_REL_BASED_REL32                   7
#define IMAGE_REL_BASED_MIPS_JMPADDR16          9
#define IMAGE_REL_BASED_IA64_IMM64              9
#define IMAGE_REL_BASED_DIR64                   10

#define IMAGE_SIZEOF_BASE_RELOCATION            8


#define IMAGE_FILE_RELOCS_STRIPPED           0x0001  // Relocation info stripped from file.
#define IMAGE_FILE_EXECUTABLE_IMAGE          0x0002  // File is executable  (i.e. no unresolved external references).
#define IMAGE_FILE_LINE_NUMS_STRIPPED        0x0004  // Line nunbers stripped from file.
#define IMAGE_FILE_LOCAL_SYMS_STRIPPED       0x0008  // Local symbols stripped from file.
#define IMAGE_FILE_AGGRESIVE_WS_TRIM         0x0010  // Aggressively trim working set
#define IMAGE_FILE_LARGE_ADDRESS_AWARE       0x0020  // App can handle >2gb addresses
#define IMAGE_FILE_BYTES_REVERSED_LO         0x0080  // Bytes of machine word are reversed.
#define IMAGE_FILE_32BIT_MACHINE             0x0100  // 32 bit word machine.
#define IMAGE_FILE_DEBUG_STRIPPED            0x0200  // Debugging info stripped from file .DBG file
#define IMAGE_FILE_REMOVABLE_RUN_FROM_SWAP   0x0400  // If Image is on removable media, copy and run from the swap file.
#define IMAGE_FILE_NET_RUN_FROM_SWAP         0x0800  // If Image is on Net, copy and run from the swap file.
#define IMAGE_FILE_SYSTEM                    0x1000  // System File.
#define IMAGE_FILE_DLL                       0x2000  // File is a DLL.
#define IMAGE_FILE_UP_SYSTEM_ONLY            0x4000  // File should only be run on a UP machine
#define IMAGE_FILE_BYTES_REVERSED_HI         0x8000  // Bytes of machine word are reversed.

#define IMAGE_FILE_MACHINE_UNKNOWN           0
#define IMAGE_FILE_MACHINE_I386              0x014c  // Intel 386.
#define IMAGE_FILE_MACHINE_R3000             0x0162  // MIPS little-endian, 0x160 big-endian
#define IMAGE_FILE_MACHINE_R4000             0x0166  // MIPS little-endian
#define IMAGE_FILE_MACHINE_R10000            0x0168  // MIPS little-endian
#define IMAGE_FILE_MACHINE_WCEMIPSV2         0x0169  // MIPS little-endian WCE v2
#define IMAGE_FILE_MACHINE_ALPHA             0x0184  // Alpha_AXP
#define IMAGE_FILE_MACHINE_SH3               0x01a2  // SH3 little-endian
#define IMAGE_FILE_MACHINE_SH3DSP            0x01a3
#define IMAGE_FILE_MACHINE_SH3E              0x01a4  // SH3E little-endian
#define IMAGE_FILE_MACHINE_SH4               0x01a6  // SH4 little-endian
#define IMAGE_FILE_MACHINE_SH5               0x01a8  // SH5
#define IMAGE_FILE_MACHINE_ARM               0x01c0  // ARM Little-Endian
#define IMAGE_FILE_MACHINE_THUMB             0x01c2  // ARM Thumb/Thumb-2 Little-Endian
#define IMAGE_FILE_MACHINE_ARMNT             0x01c4  // ARM Thumb-2 Little-Endian
#define IMAGE_FILE_MACHINE_AM33              0x01d3
#define IMAGE_FILE_MACHINE_POWERPC           0x01F0  // IBM PowerPC Little-Endian
#define IMAGE_FILE_MACHINE_POWERPCFP         0x01f1
#define IMAGE_FILE_MACHINE_IA64              0x0200  // Intel 64
#define IMAGE_FILE_MACHINE_MIPS16            0x0266  // MIPS
#define IMAGE_FILE_MACHINE_ALPHA64           0x0284  // ALPHA64
#define IMAGE_FILE_MACHINE_MIPSFPU           0x0366  // MIPS
#define IMAGE_FILE_MACHINE_MIPSFPU16         0x0466  // MIPS
#define IMAGE_FILE_MACHINE_AXP64             IMAGE_FILE_MACHINE_ALPHA64
#define IMAGE_FILE_MACHINE_TRICORE           0x0520  // Infineon
#define IMAGE_FILE_MACHINE_CEF               0x0CEF
#define IMAGE_FILE_MACHINE_EBC               0x0EBC  // EFI Byte Code
#define IMAGE_FILE_MACHINE_AMD64             0x8664  // AMD64 (K8)
#define IMAGE_FILE_MACHINE_M32R              0x9041  // M32R little-endian
#define IMAGE_FILE_MACHINE_CEE               0xC0EE

#define IMAGE_ORDINAL_FLAG64 0x8000000000000000
#define IMAGE_ORDINAL_FLAG32 0x80000000
#define IMAGE_ORDINAL64(Ordinal) (Ordinal & 0xffff)
#define IMAGE_ORDINAL32(Ordinal) (Ordinal & 0xffff)
#define IMAGE_SNAP_BY_ORDINAL64(Ordinal) ((Ordinal & IMAGE_ORDINAL_FLAG64) != 0)
#define IMAGE_SNAP_BY_ORDINAL32(Ordinal) ((Ordinal & IMAGE_ORDINAL_FLAG32) != 0)

//
// Section characteristics.
//
//      IMAGE_SCN_TYPE_REG                   0x00000000  // Reserved.
//      IMAGE_SCN_TYPE_DSECT                 0x00000001  // Reserved.
//      IMAGE_SCN_TYPE_NOLOAD                0x00000002  // Reserved.
//      IMAGE_SCN_TYPE_GROUP                 0x00000004  // Reserved.
#define IMAGE_SCN_TYPE_NO_PAD                0x00000008  // Reserved.
//      IMAGE_SCN_TYPE_COPY                  0x00000010  // Reserved.

#define IMAGE_SCN_CNT_CODE                   0x00000020  // Section contains code.
#define IMAGE_SCN_CNT_INITIALIZED_DATA       0x00000040  // Section contains initialized data.
#define IMAGE_SCN_CNT_UNINITIALIZED_DATA     0x00000080  // Section contains uninitialized data.

#define IMAGE_SCN_LNK_OTHER                  0x00000100  // Reserved.
#define IMAGE_SCN_LNK_INFO                   0x00000200  // Section contains comments or some other type of information.
//      IMAGE_SCN_TYPE_OVER                  0x00000400  // Reserved.
#define IMAGE_SCN_LNK_REMOVE                 0x00000800  // Section contents will not become part of image.
#define IMAGE_SCN_LNK_COMDAT                 0x00001000  // Section contents comdat.
//                                           0x00002000  // Reserved.
//      IMAGE_SCN_MEM_PROTECTED - Obsolete   0x00004000
#define IMAGE_SCN_NO_DEFER_SPEC_EXC          0x00004000  // Reset speculative exceptions handling bits the TLB entries for this section.
#define IMAGE_SCN_GPREL                      0x00008000  // Section content can be accessed relative to GP
#define IMAGE_SCN_MEM_FARDATA                0x00008000
//      IMAGE_SCN_MEM_SYSHEAP  - Obsolete    0x00010000
#define IMAGE_SCN_MEM_PURGEABLE              0x00020000
#define IMAGE_SCN_MEM_16BIT                  0x00020000
#define IMAGE_SCN_MEM_LOCKED                 0x00040000
#define IMAGE_SCN_MEM_PRELOAD                0x00080000

#define IMAGE_SCN_ALIGN_1BYTES               0x00100000  //
#define IMAGE_SCN_ALIGN_2BYTES               0x00200000  //
#define IMAGE_SCN_ALIGN_4BYTES               0x00300000  //
#define IMAGE_SCN_ALIGN_8BYTES               0x00400000  //
#define IMAGE_SCN_ALIGN_16BYTES              0x00500000  // Default alignment if no others are specified.
#define IMAGE_SCN_ALIGN_32BYTES              0x00600000  //
#define IMAGE_SCN_ALIGN_64BYTES              0x00700000  //
#define IMAGE_SCN_ALIGN_128BYTES             0x00800000  //
#define IMAGE_SCN_ALIGN_256BYTES             0x00900000  //
#define IMAGE_SCN_ALIGN_512BYTES             0x00A00000  //
#define IMAGE_SCN_ALIGN_1024BYTES            0x00B00000  //
#define IMAGE_SCN_ALIGN_2048BYTES            0x00C00000  //
#define IMAGE_SCN_ALIGN_4096BYTES            0x00D00000  //
#define IMAGE_SCN_ALIGN_8192BYTES            0x00E00000  //
// Unused                                    0x00F00000
#define IMAGE_SCN_ALIGN_MASK                 0x00F00000

#define IMAGE_SCN_LNK_NRELOC_OVFL            0x01000000  // Section contains extended relocations.
#define IMAGE_SCN_MEM_DISCARDABLE            0x02000000  // Section can be discarded.
#define IMAGE_SCN_MEM_NOT_CACHED             0x04000000  // Section is not cachable.
#define IMAGE_SCN_MEM_NOT_PAGED              0x08000000  // Section is not pageable.
#define IMAGE_SCN_MEM_SHARED                 0x10000000  // Section is shareable.
#define IMAGE_SCN_MEM_EXECUTE                0x20000000  // Section is executable.
#define IMAGE_SCN_MEM_READ                   0x40000000  // Section is readable.
#define IMAGE_SCN_MEM_WRITE                  0x80000000  // Section is writeable.
#define CODEINTEGRITY_OPTION_ENABLED						0x1
#define SEC_IMAGE                   0x01000000  

#define UNWIND_HISTORY_TABLE_SIZE    12

#define IMAGE_FIRST_SECTION( ntheader ) ((PIMAGE_SECTION_HEADER)        \
    ((ULONG_PTR)(ntheader) +                                            \
     FIELD_OFFSET( IMAGE_NT_HEADERS, OptionalHeader ) +                 \
     ((ntheader))->FileHeader.SizeOfOptionalHeader   \
    ))


#define IMAGE32(NtHeaders) ((NtHeaders)->OptionalHeader.Magic == IMAGE_NT_OPTIONAL_HDR32_MAGIC)
#define IMAGE64(NtHeaders) ((NtHeaders)->OptionalHeader.Magic == IMAGE_NT_OPTIONAL_HDR64_MAGIC)

#define HEADER_FIELD(NtHeaders, Field) (IMAGE64(NtHeaders) \
	? ((PIMAGE_NT_HEADERS64)(NtHeaders))->OptionalHeader.Field \
	: ((PIMAGE_NT_HEADERS32)(NtHeaders))->OptionalHeader.Field)

typedef struct _IMAGE_DOS_HEADER
{
    USHORT e_magic;
    USHORT e_cblp;
    USHORT e_cp;
    USHORT e_crlc;
    USHORT e_cparhdr;
    USHORT e_minalloc;
    USHORT e_maxalloc;
    USHORT e_ss;
    USHORT e_sp;
    USHORT e_csum;
    USHORT e_ip;
    USHORT e_cs;
    USHORT e_lfarlc;
    USHORT e_ovno;
    USHORT e_res[4];
    USHORT e_oemid;
    USHORT e_oeminfo;
    USHORT e_res2[10];
    LONG e_lfanew;
} IMAGE_DOS_HEADER, *PIMAGE_DOS_HEADER;

typedef struct _IMAGE_SECTION_HEADER
{
    UCHAR  Name[8];
    union
    {
        ULONG PhysicalAddress;
        ULONG VirtualSize;
    } Misc;
    ULONG VirtualAddress;
    ULONG SizeOfRawData;
    ULONG PointerToRawData;
    ULONG PointerToRelocations;
    ULONG PointerToLinenumbers;
    USHORT  NumberOfRelocations;
    USHORT  NumberOfLinenumbers;
    ULONG Characteristics;
} IMAGE_SECTION_HEADER, *PIMAGE_SECTION_HEADER;

typedef struct _IMAGE_FILE_HEADER // Size=20
{
    USHORT Machine;
    USHORT NumberOfSections;
    ULONG TimeDateStamp;
    ULONG PointerToSymbolTable;
    ULONG NumberOfSymbols;
    USHORT SizeOfOptionalHeader;
    USHORT Characteristics;
} IMAGE_FILE_HEADER, *PIMAGE_FILE_HEADER;

typedef struct _IMAGE_DATA_DIRECTORY
{
    ULONG VirtualAddress;
    ULONG Size;
} IMAGE_DATA_DIRECTORY, *PIMAGE_DATA_DIRECTORY;

typedef struct _IMAGE_OPTIONAL_HEADER64
{
    USHORT Magic;
    UCHAR MajorLinkerVersion;
    UCHAR MinorLinkerVersion;
    ULONG SizeOfCode;
    ULONG SizeOfInitializedData;
    ULONG SizeOfUninitializedData;
    ULONG AddressOfEntryPoint;
    ULONG BaseOfCode;
    ULONGLONG ImageBase;
    ULONG SectionAlignment;
    ULONG FileAlignment;
    USHORT MajorOperatingSystemVersion;
    USHORT MinorOperatingSystemVersion;
    USHORT MajorImageVersion;
    USHORT MinorImageVersion;
    USHORT MajorSubsystemVersion;
    USHORT MinorSubsystemVersion;
    ULONG Win32VersionValue;
    ULONG SizeOfImage;
    ULONG SizeOfHeaders;
    ULONG CheckSum;
    USHORT Subsystem;
    USHORT DllCharacteristics;
    ULONGLONG SizeOfStackReserve;
    ULONGLONG SizeOfStackCommit;
    ULONGLONG SizeOfHeapReserve;
    ULONGLONG SizeOfHeapCommit;
    ULONG LoaderFlags;
    ULONG NumberOfRvaAndSizes;
    struct _IMAGE_DATA_DIRECTORY DataDirectory[IMAGE_NUMBEROF_DIRECTORY_ENTRIES];
} IMAGE_OPTIONAL_HEADER64, *PIMAGE_OPTIONAL_HEADER64;

typedef struct _IMAGE_OPTIONAL_HEADER32
{
    //
    // Standard fields.
    //

    USHORT  Magic;
    UCHAR   MajorLinkerVersion;
    UCHAR   MinorLinkerVersion;
    ULONG   SizeOfCode;
    ULONG   SizeOfInitializedData;
    ULONG   SizeOfUninitializedData;
    ULONG   AddressOfEntryPoint;
    ULONG   BaseOfCode;
    ULONG   BaseOfData;

    //
    // NT additional fields.
    //

    ULONG   ImageBase;
    ULONG   SectionAlignment;
    ULONG   FileAlignment;
    USHORT  MajorOperatingSystemVersion;
    USHORT  MinorOperatingSystemVersion;
    USHORT  MajorImageVersion;
    USHORT  MinorImageVersion;
    USHORT  MajorSubsystemVersion;
    USHORT  MinorSubsystemVersion;
    ULONG   Win32VersionValue;
    ULONG   SizeOfImage;
    ULONG   SizeOfHeaders;
    ULONG   CheckSum;
    USHORT  Subsystem;
    USHORT  DllCharacteristics;
    ULONG   SizeOfStackReserve;
    ULONG   SizeOfStackCommit;
    ULONG   SizeOfHeapReserve;
    ULONG   SizeOfHeapCommit;
    ULONG   LoaderFlags;
    ULONG   NumberOfRvaAndSizes;
    IMAGE_DATA_DIRECTORY DataDirectory[IMAGE_NUMBEROF_DIRECTORY_ENTRIES];
} IMAGE_OPTIONAL_HEADER32, *PIMAGE_OPTIONAL_HEADER32;

typedef struct _IMAGE_NT_HEADERS64
{
    ULONG Signature;
    struct _IMAGE_FILE_HEADER FileHeader;
    struct _IMAGE_OPTIONAL_HEADER64 OptionalHeader;
} IMAGE_NT_HEADERS64, *PIMAGE_NT_HEADERS64;

typedef struct _IMAGE_NT_HEADERS
{
    ULONG Signature;
    IMAGE_FILE_HEADER FileHeader;
    IMAGE_OPTIONAL_HEADER32 OptionalHeader;
} IMAGE_NT_HEADERS;

typedef struct _IMAGE_EXPORT_DIRECTORY {
    ULONG   Characteristics;
    ULONG   TimeDateStamp;
    USHORT  MajorVersion;
    USHORT  MinorVersion;
    ULONG   Name;
    ULONG   Base;
    ULONG   NumberOfFunctions;
    ULONG   NumberOfNames;
    ULONG   AddressOfFunctions;     // RVA from base of image
    ULONG   AddressOfNames;         // RVA from base of image
    ULONG   AddressOfNameOrdinals;  // RVA from base of image
} IMAGE_EXPORT_DIRECTORY, *PIMAGE_EXPORT_DIRECTORY;

typedef struct _IMAGE_BASE_RELOCATION {
    ULONG   VirtualAddress;
    ULONG   SizeOfBlock;
    //  USHORT  TypeOffset[1];
} IMAGE_BASE_RELOCATION;
typedef IMAGE_BASE_RELOCATION UNALIGNED * PIMAGE_BASE_RELOCATION;

typedef struct _IMAGE_IMPORT_BY_NAME {
    USHORT Hint;
    CHAR   Name[1];
} IMAGE_IMPORT_BY_NAME, *PIMAGE_IMPORT_BY_NAME;


// warning C4201: nonstandard extension used : nameless struct/union
#pragma warning (disable : 4201)

typedef struct _IMAGE_IMPORT_DESCRIPTOR 
{
    union {
        ULONG   Characteristics;            // 0 for terminating null import descriptor
        ULONG   OriginalFirstThunk;         // RVA to original unbound IAT (PIMAGE_THUNK_DATA)
    };
    ULONG   TimeDateStamp;                  // 0 if not bound,
    // -1 if bound, and real date\time stamp
    //     IMAGE_DIRECTORY_ENTRY_BOUND_IMPORT (new BIND)
    // O.W. date/time stamp of DLL bound to (Old BIND)

    ULONG   ForwarderChain;                 // -1 if no forwarders
    ULONG   Name;
    ULONG   FirstThunk;                     // RVA to IAT (if bound this IAT has actual addresses)
} IMAGE_IMPORT_DESCRIPTOR;
typedef IMAGE_IMPORT_DESCRIPTOR UNALIGNED *PIMAGE_IMPORT_DESCRIPTOR;


typedef struct _IMAGE_THUNK_DATA64 
{
    union 
    {
        ULONGLONG ForwarderString;  // PBYTE 
        ULONGLONG Function;         // PULONG
        ULONGLONG Ordinal;
        ULONGLONG AddressOfData;    // PIMAGE_IMPORT_BY_NAME
    } u1;
} IMAGE_THUNK_DATA64;
typedef IMAGE_THUNK_DATA64 * PIMAGE_THUNK_DATA64;

typedef struct _IMAGE_THUNK_DATA32
{
    union
    {
        ULONG ForwarderString;      // PBYTE 
        ULONG Function;             // PULONG
        ULONG Ordinal;
        ULONG AddressOfData;        // PIMAGE_IMPORT_BY_NAME
    } u1;
} IMAGE_THUNK_DATA32;
typedef IMAGE_THUNK_DATA32 * PIMAGE_THUNK_DATA32;

typedef struct _IMAGE_RESOURCE_DIRECTORY {
    ULONG   Characteristics;
    ULONG   TimeDateStamp;
    USHORT  MajorVersion;
    USHORT  MinorVersion;
    USHORT  NumberOfNamedEntries;
    USHORT  NumberOfIdEntries;
    //  IMAGE_RESOURCE_DIRECTORY_ENTRY DirectoryEntries[];
} IMAGE_RESOURCE_DIRECTORY, *PIMAGE_RESOURCE_DIRECTORY; 

typedef struct _IMAGE_RESOURCE_DIRECTORY_ENTRY {
    union {
        struct {
            INT NameOffset : 31;
            INT NameIsString : 1;
        } DUMMYSTRUCTNAME;
        ULONG   Name;
        USHORT  Id;
    } DUMMYUNIONNAME;
    union {
        ULONG   OffsetToData;
        struct {
            INT   OffsetToDirectory : 31;
            INT   DataIsDirectory : 1;
        } DUMMYSTRUCTNAME2;
    } DUMMYUNIONNAME2;
} IMAGE_RESOURCE_DIRECTORY_ENTRY, *PIMAGE_RESOURCE_DIRECTORY_ENTRY;

typedef struct _IMAGE_RESOURCE_DATA_ENTRY {
    ULONG OffsetToData;
    ULONG Size;
    ULONG CodePage;
    ULONG Reserved;
} IMAGE_RESOURCE_DATA_ENTRY, *PIMAGE_RESOURCE_DATA_ENTRY;

typedef struct _IMAGE_RUNTIME_FUNCTION_ENTRY {
    ULONG BeginAddress;
    ULONG EndAddress;
    union {
        ULONG UnwindInfoAddress;
        ULONG UnwindData;
    } DUMMYUNIONNAME;
} RUNTIME_FUNCTION, * PRUNTIME_FUNCTION, _IMAGE_RUNTIME_FUNCTION_ENTRY, * _PIMAGE_RUNTIME_FUNCTION_ENTRY;

typedef struct _UNWIND_HISTORY_TABLE_ENTRY
{
    ULONG64 ImageBase;
    PRUNTIME_FUNCTION FunctionEntry;
} UNWIND_HISTORY_TABLE_ENTRY, * PUNWIND_HISTORY_TABLE_ENTRY;

typedef struct _UNWIND_HISTORY_TABLE
{
    ULONG Count;
    UCHAR Search;
    ULONG64 LowAddress;
    ULONG64 HighAddress;
    UNWIND_HISTORY_TABLE_ENTRY Entry[UNWIND_HISTORY_TABLE_SIZE];
} UNWIND_HISTORY_TABLE, * PUNWIND_HISTORY_TABLE;

typedef struct _IMAGE_LOAD_CONFIG_DIRECTORY32 {
    ULONG   Size;
    ULONG   TimeDateStamp;
    USHORT  MajorVersion;
    USHORT  MinorVersion;
    ULONG   GlobalFlagsClear;
    ULONG   GlobalFlagsSet;
    ULONG   CriticalSectionDefaultTimeout;
    ULONG   DeCommitFreeBlockThreshold;
    ULONG   DeCommitTotalFreeThreshold;
    ULONG   LockPrefixTable;                // VA
    ULONG   MaximumAllocationSize;
    ULONG   VirtualMemoryThreshold;
    ULONG   ProcessHeapFlags;
    ULONG   ProcessAffinityMask;
    USHORT  CSDVersion;
    USHORT  Reserved1;
    ULONG   EditList;                       // VA
    ULONG   SecurityCookie;                 // VA
    ULONG   SEHandlerTable;                 // VA
    ULONG   SEHandlerCount;
    ULONG   GuardCFCheckFunctionPointer;    // VA
    ULONG   Reserved2;
    ULONG   GuardCFFunctionTable;           // VA
    ULONG   GuardCFFunctionCount;
    ULONG   GuardFlags;
} IMAGE_LOAD_CONFIG_DIRECTORY32, *PIMAGE_LOAD_CONFIG_DIRECTORY32;

typedef struct _IMAGE_LOAD_CONFIG_DIRECTORY64 {
    ULONG      Size;
    ULONG      TimeDateStamp;
    USHORT     MajorVersion;
    USHORT     MinorVersion;
    ULONG      GlobalFlagsClear;
    ULONG      GlobalFlagsSet;
    ULONG      CriticalSectionDefaultTimeout;
    ULONGLONG  DeCommitFreeBlockThreshold;
    ULONGLONG  DeCommitTotalFreeThreshold;
    ULONGLONG  LockPrefixTable;             // VA
    ULONGLONG  MaximumAllocationSize;
    ULONGLONG  VirtualMemoryThreshold;
    ULONGLONG  ProcessAffinityMask;
    ULONG      ProcessHeapFlags;
    USHORT     CSDVersion;
    USHORT     Reserved1;
    ULONGLONG  EditList;                    // VA
    ULONGLONG  SecurityCookie;              // VA
    ULONGLONG  SEHandlerTable;              // VA
    ULONGLONG  SEHandlerCount;
    ULONGLONG  GuardCFCheckFunctionPointer; // VA
    ULONGLONG  Reserved2;
    ULONGLONG  GuardCFFunctionTable;        // VA
    ULONGLONG  GuardCFFunctionCount;
    ULONG      GuardFlags;
} IMAGE_LOAD_CONFIG_DIRECTORY64, *PIMAGE_LOAD_CONFIG_DIRECTORY64;

typedef struct _IMAGE_TLS_DIRECTORY64 {
    ULONGLONG StartAddressOfRawData;
    ULONGLONG EndAddressOfRawData;
    ULONGLONG AddressOfIndex;         // PULONG
    ULONGLONG AddressOfCallBacks;     // PIMAGE_TLS_CALLBACK *;
    ULONG SizeOfZeroFill;
    union {
        ULONG Characteristics;
        struct {
            INT Reserved0 : 20;
            INT Alignment : 4;
            INT Reserved1 : 8;
        } DUMMYSTRUCTNAME;
    } DUMMYUNIONNAME;

} IMAGE_TLS_DIRECTORY64;

typedef IMAGE_TLS_DIRECTORY64 * PIMAGE_TLS_DIRECTORY64;

typedef struct _IMAGE_TLS_DIRECTORY32 {
    ULONG   StartAddressOfRawData;
    ULONG   EndAddressOfRawData;
    ULONG   AddressOfIndex;             // PULONG
    ULONG   AddressOfCallBacks;         // PIMAGE_TLS_CALLBACK *
    ULONG   SizeOfZeroFill;
    union {
        ULONG Characteristics;
        struct {
            INT Reserved0 : 20;
            INT Alignment : 4;
            INT Reserved1 : 8;
        } DUMMYSTRUCTNAME;
    } DUMMYUNIONNAME;

} IMAGE_TLS_DIRECTORY32;
typedef IMAGE_TLS_DIRECTORY32 * PIMAGE_TLS_DIRECTORY32;


#define ACTCTX_FLAG_PROCESSOR_ARCHITECTURE_VALID    (0x00000001)
#define ACTCTX_FLAG_LANGID_VALID                    (0x00000002)
#define ACTCTX_FLAG_ASSEMBLY_DIRECTORY_VALID        (0x00000004)
#define ACTCTX_FLAG_RESOURCE_NAME_VALID             (0x00000008)
#define ACTCTX_FLAG_SET_PROCESS_DEFAULT             (0x00000010)
#define ACTCTX_FLAG_APPLICATION_NAME_VALID          (0x00000020)
#define ACTCTX_FLAG_SOURCE_IS_ASSEMBLYREF           (0x00000040)
#define ACTCTX_FLAG_HMODULE_VALID                   (0x00000080)

typedef struct tagACTCTXW
{
    ULONG  cbSize;
    ULONG  dwFlags;
    PWCH   lpSource;
    USHORT wProcessorArchitecture;
    USHORT wLangId;
    PWCH   lpAssemblyDirectory;
    PWCH   lpResourceName;
    PWCH   lpApplicationName;
    PVOID  hModule;
} ACTCTXW, *PACTCTXW;

typedef struct tagACTCTXW32
{
    ULONG  cbSize;
    ULONG  dwFlags;
    ULONG  lpSource;
    USHORT wProcessorArchitecture;
    USHORT wLangId;
    ULONG  lpAssemblyDirectory;
    ULONG  lpResourceName;
    ULONG  lpApplicationName;
    ULONG  hModule;
} ACTCTXW32, *PACTCTXW32;

#pragma warning (default : 4201)
```

`KernelAntiCheat/Natives/Windows/RAIIUtilites.c`:

```c
#pragma once
#include "RAIIUtilites.h"

HANDLE OpenFileReadHandleGuard(PCUNICODE_STRING imageFileName)
{
    HANDLE _handle;
    IO_STATUS_BLOCK ioStatusBlock = { 0 };
    OBJECT_ATTRIBUTES  objAttr = { 0 };
    InitializeObjectAttributes(
        &objAttr,
        (PUNICODE_STRING)(imageFileName),
        OBJ_CASE_INSENSITIVE | OBJ_KERNEL_HANDLE,
        NULL,
        NULL);

    const NTSTATUS openFileRet = ZwOpenFile(
        &_handle,
        SYNCHRONIZE | FILE_READ_DATA, // ACCESS_MASK, we use SYNCHRONIZE because we might need to wait on the handle in order to wait for the file to be read
        &objAttr,
        &ioStatusBlock,
        FILE_SHARE_READ,
        FILE_NON_DIRECTORY_FILE | FILE_SYNCHRONOUS_IO_NONALERT // FILE_SYNCHRONOUS_IO_NONALERT so that zwReadfile will pend for us until reading is done
    );

    if (!NT_SUCCESS(openFileRet))
    {
        KdPrint(("failed to open file - openFileRet = %d\n", openFileRet));
        return NULL;
    }

    if (ioStatusBlock.Status != STATUS_SUCCESS || _handle == NULL)
    {
        KdPrint(("ioStatusBlock.Status != STATUS_SUCCESS, or _handle is null\n"));
        return NULL;
    }

    return _handle;
}
HANDLE CreateSectionHandleGuard(HANDLE fileHandle)
{
    HANDLE _handle;
    OBJECT_ATTRIBUTES objectAttributes = { 0 };
    InitializeObjectAttributes(
        &objectAttributes,
        NULL,
        OBJ_KERNEL_HANDLE, // to make sure user mode cannot access this handle
        NULL,
        NULL);

    const NTSTATUS createSectionRet = ZwCreateSection(
        &_handle,
        SECTION_MAP_READ,
        &objectAttributes,
        NULL, // maximum size - use the file size, in order to map the entire file
        PAGE_READONLY,
        SEC_COMMIT, // map as commit and not as SEC_IMAGE, because SEC_IMAGE will not map things which are not needed for the PE - such as resources and certificates
        fileHandle
    );

    if (!NT_SUCCESS(createSectionRet))
    {
        KdPrint(("failed to create section - ZwCreateSection returned %x\n", createSectionRet));
        return NULL;
    }

    return _handle;
}
PVOID OpenSectionObjectGuard(HANDLE sectionHandle)
{
    PVOID _object;
    const NTSTATUS ret = ObReferenceObjectByHandle(
        sectionHandle,
        SECTION_MAP_READ,
        NULL,
        KernelMode,
        &_object,
        NULL
    );

    if (!NT_SUCCESS(ret))
    {
        KdPrint(("ObReferenceObjectByHandle failed -  returned %x\n", ret));
        return NULL;
    }

    return _object;
}
VOID CloseSectionObjectGuard(PVOID _object)
{
    if (_object != NULL)
    {
        ObfDereferenceObject(_object);
    }
}
PVOID MmMapSectionViewGuard(PVOID sectionObject, SIZE_T* _viewSizeGet)
{
    PVOID _baseAddrOfView;
    SIZE_T _viewSize = 0;
    const NTSTATUS ret = MmMapViewInSystemSpace(
        sectionObject,
        &_baseAddrOfView,
        &_viewSize
    );

    if (!NT_SUCCESS(ret))
    {
        KdPrint(("MmMapViewInSystemSpace failed -  returned %x\n", ret));
        return 0;
    }
    *_viewSizeGet = _viewSize;
    return _baseAddrOfView;
}
VOID MmUnmapSectionViewGuard(PVOID _baseAddrOfView)
{
    if (_baseAddrOfView != NULL)
    {
        MmUnmapViewInSystemSpace(_baseAddrOfView);
    }
}
VOID FreePolicyInfoGuard(PolicyInfo _policyInfo)
{
    CiFreePolicyInfo(&_policyInfo);
}
```

`KernelAntiCheat/Natives/Windows/RAIIUtilites.h`:

```h
#pragma once

#include <ntddk.h>
#include <wdm.h>
#include "ci.h"


HANDLE OpenFileReadHandleGuard(PCUNICODE_STRING imageFileName);

HANDLE CreateSectionHandleGuard(HANDLE fileHandle);

PVOID OpenSectionObjectGuard(HANDLE sectionHandle);

VOID CloseSectionObjectGuard(PVOID _object);

PVOID MmMapSectionViewGuard(PVOID sectionObject, SIZE_T* _viewSizeGet);

VOID MmUnmapSectionViewGuard(PVOID _baseAddrOfView);

VOID FreePolicyInfoGuard(PolicyInfo _policyInfo);
```

`KernelAntiCheat/Natives/Windows/ci.h`:

```h
#pragma once

#include <wdm.h>
#include <minwindef.h>

/**
*  This struct was copied from <wintrust.h> and encapsulates a signature used in verifying executable files.
*/
typedef struct _WIN_CERTIFICATE {
    DWORD dwLength;                         // Specifies the length, in bytes, of the signature
    WORD  wRevision;                        // Specifies the certificate revision
    WORD  wCertificateType;                 // Specifies the type of certificate
    BYTE  bCertificate[ANYSIZE_ARRAY];      // An array of certificates
} WIN_CERTIFICATE, * LPWIN_CERTIFICATE;


/**
*  Describes the location (address) and size of a ASN.1 blob within a buffer.
*
*  @note  The data itself is not contained in the struct.
*/
typedef struct _Asn1BlobPtr
{
    int size;               // size of the ASN.1 blob
    PVOID ptrToData;        // where the ASN.1 blob starts
} Asn1BlobPtr, * pAsn1BlobPtr;


/**
*  Describes the location (address) and size of a certificate subject/issuer name, within a buffer.
*
*  @note  The data itself (name) is not contained in the struct.
*
*  @note  the reason for separating these fields into their own struct was to match the padding we
*         observed in CertChainMember struct after the second 'short' field - once you enclose it 
*         into a struct, on x64 bit machines there will be a padding of 4 bytes at the end of the struct,
*         because the largest member of the struct is of size 8 and it dictates the alignment of the struct.
*/
typedef struct _CertificatePartyName
{
    PVOID pointerToName;
    short nameLen;
    short unknown;
} CertificatePartyName, * pCertificatePartyName;


/**
*  Contains various data about a specific certificate in the chain and also points to the actual certificate.
*
*  @note  the digest described in this struct is the digest that was used to create the certificate - not for
*         signing the file.
*
*  @note  The size reserved for digest is 64 byte regardless of the digest type, in order to accomodate SHA2/3's
*         max size of 512bit. The memory is not zeroed, so we must take the actual digestSize into account when
*         reading it.
*/
typedef struct _CertChainMember
{
    int digestIdetifier;                // e.g. 0x800c for SHA256
    int digestSize;                     // e.g. 0x20 for SHA256
    BYTE digestBuffer[64];              // contains the digest itself, where the digest size is dictated by digestSize

    CertificatePartyName subjectName;   // pointer to the subject name
    CertificatePartyName issuerName;    // pointer to the issuer name

    Asn1BlobPtr certificate;            // ptr to actual cert in ASN.1 - including the public key
} CertChainMember, * pCertChainMember;


/**
*  Describes the format of certChainInfo buffer member of PolicyInfo struct. This header maps the types,
*  locations, and quantities of the data which is contained in the buffer.
*
*  @note  when using this struct make sure to check its size first (bufferSize) because it's not guaranteed
*         that all the fields below will exist.
*/
typedef struct _CertChainInfoHeader
{
    // The size of the dynamically allocated buffer
    int bufferSize;

    // points to the start of a series of Asn1Blobs which contain the public keys of the certificates in the chain
    pAsn1BlobPtr ptrToPublicKeys;
    int numberOfPublicKeys;
    
    // points to the start of a series of Asn1Blobs which contain the EKUs
    pAsn1BlobPtr ptrToEkus;
    int numberOfEkus;

    // points to the start of a series of CertChainMembers
    pCertChainMember ptrToCertChainMembers;
    int numberOfCertChainMembers;

    int unknown;

    // ASN.1 blob of authenticated attributes - spcSpOpusInfo, contentType, etc.
    Asn1BlobPtr variousAuthenticodeAttributes;
} CertChainInfoHeader, * pCertChainInfoHeader;


/**
*  Contains information regarding the certificates that were used for signing/timestamping
*
*  @note  you must check structSize before accessing the other members, since some members were added later.
*
*  @note  all structs members, including the length, are populated by ci functions - no need
*         to fill them in adavnce.
*/
typedef struct _PolicyInfo
{
    int structSize;
    NTSTATUS verificationStatus;
    int flags;
    pCertChainInfoHeader certChainInfo; // if not null - contains info about certificate chain
    FILETIME revocationTime;            // when was the certificate revoked (if applicable)
    FILETIME notBeforeTime;             // the certificate is not valid before this time
    FILETIME notAfterTime;              // the certificate is not valid before this time
} PolicyInfo, *pPolicyInfo;


/**
*  Given a file digest and signature of a file, verify the signature and provide information regarding
*  the certificates that was used for signing (the entire certificate chain)
*
*  @note  the function allocates a buffer from the paged pool --> can be used only where IRQL < DISPATCH_LEVEL
*
*  @param  digestBuffer - buffer containing the digest
*
*  @param  digestSize - size of the digest, e.g. 0x20 for SHA256, 0x14 for SHA1
*
*  @param  digestIdentifier - digest algorithm identifier, e.g. 0x800c for SHA256, 0x8004 for SHA1
*
*  @param  winCert - pointer to the start of the security directory
*
*  @param  sizeOfSecurityDirectory - size the security directory
*
*  @param  policyInfoForSigner[out] - PolicyInfo containing information about the signer certificate chain
*
*  @param  signingTime[out] - when the file was signed (FILETIME format)
*
*  @param  policyInfoForTimestampingAuthority[out] - PolicyInfo containing information about the timestamping 
*          authority (TSA) certificate chain
*
*  @return  0 if the file digest in the signature matches the given digest and the signer cetificate is verified.
*           Various error values otherwise, for example:
*           STATUS_INVALID_IMAGE_HASH - the digest does not match the digest in the signature
*           STATUS_IMAGE_CERT_REVOKED - the certificate used for signing the file is revoked
*           STATUS_IMAGE_CERT_EXPIRED - the certificate used for signing the file has expired
*/
__declspec(dllimport) NTSTATUS _stdcall CiCheckSignedFile(
    const PVOID digestBuffer,
    int digestSize,
    int digestIdentifier,
    const LPWIN_CERTIFICATE winCert,
    int sizeOfSecurityDirectory,
    PolicyInfo* policyInfoForSigner,
    LARGE_INTEGER* signingTime,
    PolicyInfo* policyInfoForTimestampingAuthority);


/**
*  Resets a PolicyInfo struct - frees the dynamically allocated buffer in PolicyInfo (certChainInfo) if not null.
*  Zeros the entire PolicyInfo struct.
*
*  @param  policyInfo - the struct to reset.
*
*  @return  the struct which was reset.
*/
__declspec(dllimport) PVOID _stdcall CiFreePolicyInfo(PolicyInfo* policyInfo);


/**
*  Given a file object, verify the signature and provide information regarding
*  the certificates that was used for signing (the entire certificate chain)
*
*  @note  the function allocates memory from the paged pool --> can be used only where IRQL < DISPATCH_LEVEL
*
*  @param  fileObject[in] - fileObject of the PE in question
*
*  @param  a2[in] - unknown, needs to be reversed. 0 is a valid value.
*
*  @param  a3[in] - unknown, needs to be reversed. 0 is a valid value.
*
*  @param  policyInfoForSigner[out] - PolicyInfo containing information about the signer certificate chain
*
*  @param  signingTime[out] - when the file was signed
*
*  @param  policyInfoForTimestampingAuthority[out] - PolicyInfo containing information about the timestamping
*          authority (TSA) certificate chain
*
*  @param  digestBuffer[out] - buffer to be filled with the digest, must be at least 64 bytes
*
*  @param  digestSize[inout] - size of the digest. Must be at leat 64 and will be changed by the function to 
*                              reflect the actual digest length.
*
*  @param  digestIdentifier[out] - digest algorithm identifier, e.g. 0x800c for SHA256, 0x8004 for SHA1
*
*  @return  0 if the file digest in the signature matches the given digest and the signer cetificate is verified.
*           Various error values otherwise, for example:
*           STATUS_INVALID_IMAGE_HASH - the digest does not match the digest in the signature
*           STATUS_IMAGE_CERT_REVOKED - the certificate used for signing the file is revoked
*           STATUS_IMAGE_CERT_EXPIRED - the certificate used for signing the file has expired
*/
__declspec(dllimport) NTSTATUS _stdcall CiValidateFileObject(
    struct _FILE_OBJECT* fileObject,
    int a2,
    int a3,
    PolicyInfo* policyInfoForSigner,
    PolicyInfo* policyInfoForTimestampingAuthority,
    LARGE_INTEGER* signingTime,
    BYTE* digestBuffer,
    int* digestSize,
    int* digestIdentifier
);
```

`KernelAntiCheat/Natives/stdint.h`:

```h
typedef unsigned __int64 pte_uint64;

typedef unsigned char BYTE;

typedef signed char        int8_t;
typedef short              int16_t;
typedef int                int32_t;
typedef long long          int64_t;
typedef unsigned char      uint8_t;
typedef unsigned short     uint16_t;
typedef unsigned int       uint32_t;
typedef unsigned long long uint64_t;

typedef signed char        int_least8_t;
typedef short              int_least16_t;
typedef int                int_least32_t;
typedef long long          int_least64_t;
typedef unsigned char      uint_least8_t;
typedef unsigned short     uint_least16_t;
typedef unsigned int       uint_least32_t;
typedef unsigned long long uint_least64_t;

typedef signed char        int_fast8_t;
typedef int                int_fast16_t;
typedef int                int_fast32_t;
typedef long long          int_fast64_t;
typedef unsigned char      uint_fast8_t;
typedef unsigned int       uint_fast16_t;
typedef unsigned int       uint_fast32_t;
typedef unsigned long long uint_fast64_t;

typedef long long          intmax_t;
typedef unsigned long long uintmax_t;

#define INT8_M        (-127i8 - 1)
#define INT16_M       (-32767i16 - 1)
#define INT32_M       (-2147483647i32 - 1)
#define INT64_M       (-9223372036854775807i64 - 1)
#define INT8_MAX         127i8
#define INT16_MAX        32767i16
#define INT32_MAX        2147483647i32
#define INT64_MAX        9223372036854775807i64
#define UINT8_MAX        0xffui8
#define UINT16_MAX       0xffffui16
#define UINT32_MAX       0xffffffffui32
#define UINT64_MAX       0xffffffffffffffffui64

#define INT_LEAST8_M  INT8_MIN
#define INT_LEAST16_M INT16_MIN
#define INT_LEAST32_M INT32_MIN
#define INT_LEAST64_M INT64_MIN
#define INT_LEAST8_MAX   INT8_MAX
#define INT_LEAST16_MAX  INT16_MAX
#define INT_LEAST32_MAX  INT32_MAX
#define INT_LEAST64_MAX  INT64_MAX
#define UINT_LEAST8_MAX  UINT8_MAX
#define UINT_LEAST16_MAX UINT16_MAX
#define UINT_LEAST32_MAX UINT32_MAX
#define UINT_LEAST64_MAX UINT64_MAX

#define INT_FAST8_M   INT8_MIN
#define INT_FAST16_M  INT32_MIN
#define INT_FAST32_M  INT32_MIN
#define INT_FAST64_M  INT64_MIN
#define INT_FAST8_MAX    INT8_MAX
#define INT_FAST16_MAX   INT32_MAX
#define INT_FAST32_MAX   INT32_MAX
#define INT_FAST64_MAX   INT64_MAX
#define UINT_FAST8_MAX   UINT8_MAX
#define UINT_FAST16_MAX  UINT32_MAX
#define UINT_FAST32_MAX  UINT32_MAX
#define UINT_FAST64_MAX  UINT64_MAX

#ifdef _WIN64
#define INTPTR_M  INT64_MIN
#define INTPTR_MAX   INT64_MAX
#define UINTPTR_MAX  UINT64_MAX
#else
#define INTPTR_M  INT32_MIN
#define INTPTR_MAX   INT32_MAX
#define UINTPTR_MAX  UINT32_MAX
#endif

#define INTMAX_M      INT64_MIN
#define INTMAX_MAX       INT64_MAX
#define UINTMAX_MAX      UINT64_MAX

#define PTRDIFF_M     INTPTR_MIN
#define PTRDIFF_MAX      INTPTR_MAX

#ifndef SIZE_MAX
    // SIZE_MAX definition must match exactly with limits.h for modules support.
#ifdef _WIN64
#define SIZE_MAX 0xffffffffffffffffui64
#else
#define SIZE_MAX 0xffffffffui32
#endif
#endif

#define SIG_ATOMIC_M  INT32_MIN
#define SIG_ATOMIC_MAX   INT32_MAX

#define WCHAR_M       0x0000
#define WCHAR_MAX        0xffff

#define WINT_M        0x0000
#define WINT_MAX         0xffff

#define INT8_C(x)    (x)
#define INT16_C(x)   (x)
#define INT32_C(x)   (x)
#define INT64_C(x)   (x ## LL)

#define UINT8_C(x)   (x)
#define UINT16_C(x)  (x)
#define UINT32_C(x)  (x ## U)
#define UINT64_C(x)  (x ## ULL)

#define INTMAX_C(x)  INT64_C(x)
#define UINTMAX_C(x) UINT64_C(x)
```

`KernelAntiCheat/entry.c`:

```c
#include <ntifs.h>
#include "Funcs/funcs.h"
#include "Funcs/Hardware/HardwareInfo.h"
#include "Funcs/log.h"

VOID WorkThread()
{
	DPRINT_LOG("(%s) Thread is ready", __FUNCTION__);
	DPRINT("(!) Get hardware info...");
	PSYSTEM_BOOT_ENVIRONMENT_INFORMATION pBootInfo = GetBootUUID();
	if (pBootInfo)
	{
		DPRINT("Boot GUID: %08X-%04X-%04X-%02X%02X%02X%02X%02X%02X%02X%02X", pBootInfo->BootIdentifier.Data1, pBootInfo->BootIdentifier.Data2, pBootInfo->BootIdentifier.Data3, pBootInfo->BootIdentifier.Data4[0], pBootInfo->BootIdentifier.Data4[1], pBootInfo->BootIdentifier.Data4[2], pBootInfo->BootIdentifier.Data4[3], pBootInfo->BootIdentifier.Data4[4], pBootInfo->BootIdentifier.Data4[5], pBootInfo->BootIdentifier.Data4[6], pBootInfo->BootIdentifier.Data4[7]);
	}
	else
	{
		DPRINT("Boot GUID: not found");
	}

	DPRINT("(!) Start scaning...");
	DPRINT_LOG("(!) Start scaning...");

	PSYSTEM_MODULE_INFORMATION pModuleList = GetKernelModuleList();

	if (pModuleList)
	{
		DPRINT_LOG("Scan system threads...");
		DPRINT_STATUS("system threads", ScanSysThreads(pModuleList));
		DPRINT_LOG("End scan!");

		DPRINT_LOG("Scan dispatch drivers...");
		DPRINT_STATUS("dispatch drivers", ScanDispatchDrivers(pModuleList));
		DPRINT_LOG("End scan!");

		DPRINT_LOG("Scan ssdt hooks...");
		DPRINT_STATUS("ssdt hooks", CheckSSDT(pModuleList));
		DPRINT_LOG("End scan!");
	}
	else
	{
		DPRINT("(!) Failed to get module list.");
	}

	DPRINT_LOG("Scan big pool...");
	DPRINT_STATUS("big pool", ScanBigPool());
	DPRINT_LOG("End scan!");

	DPRINT_LOG("Scan PiDDB...");
	DPRINT_STATUS("history of modules (PiDDB)", ScanPIDDB());
	DPRINT_LOG("End scan!");

	DPRINT_LOG("Scan Hyper-V...");
	DPRINT_STATUS("Hyper-V", ScanHV());
	DPRINT_LOG("End scan!");

	DPRINT_LOG("Scan phys memory handles...");
	DPRINT_STATUS("physical memory handles", ScanPhysMemHandles());
	DPRINT_LOG("End scan!");

	DPRINT_LOG("Scan perfect injector...");
	DPRINT_STATUS("perfect injector", ScanPerfectInjector());
	DPRINT_LOG("End scan!");

	DPRINT_LOG("Scan code integrity...");
	DPRINT_STATUS("code integrity", ScanCodeIntegrity());
	DPRINT_LOG("End scan!");

	DPRINT("(!) Scaning end!");
	DPRINT_LOG("(!) Scaning end!");

	if (pModuleList)
		ExFreePoolWithTag(pModuleList, POOL_TAG);
}

VOID HookProcessesCreate(PEPROCESS Process, HANDLE ProcessId, PPS_CREATE_NOTIFY_INFO CreateInfo)
{
	UNREFERENCED_PARAMETER(Process);
	UNREFERENCED_PARAMETER(ProcessId);

	if (CreateInfo == NULL) return;

	if (CreateInfo->FileObject == NULL) return;
}

VOID DriverUnload(PDRIVER_OBJECT DriverObject)
{
	PsSetCreateProcessNotifyRoutineEx(HookProcessesCreate, TRUE);
	LogClose();
}


NTSTATUS DriverEntry(PDRIVER_OBJECT DriverObject, PUNICODE_STRING RegistryPath)
{
	UNREFERENCED_PARAMETER(RegistryPath);
	
	NTSTATUS status = STATUS_SUCCESS;
	HANDLE hThread;

	DriverObject->DriverUnload = DriverUnload;

	LogOpen();
	DbgPrintEx(0, 0, "_____________UAC Developer platform_____________\nVersion: 1.0\n");

	DPRINT("Driver is loaded!");
	DPRINT_LOG("(%s) Driver is loaded.", __FUNCTION__);

	if (!NT_SUCCESS(status = PsSetCreateProcessNotifyRoutineEx(HookProcessesCreate, FALSE)))
	{
		DPRINT("(%s) error setup hook to process, code: 0x%X", __FUNCTION__, status);
		LogClose();
		return status;
	}
	
	if (NT_SUCCESS(status = PsCreateSystemThread(&hThread, STANDARD_RIGHTS_ALL, NULL, NULL, NULL, (PKSTART_ROUTINE)&WorkThread, NULL)))
	{
		ZwClose(hThread);
	}
	else
	{
		DPRINT("(%s) Failed to create check thread, code: 0x%X", __FUNCTION__, status);
		LogClose();
		return status;
	}

	return status;
}
```

`README.md`:

```md
# UAC
UAC - Cheat developer platform

A long time ago there was an idea to implement my own anti-cheat that would help me in detecting my shortcomings in the cheat. But the project has not been updated for a long time, etc. Who needs - use

My old trello: https://trello.com/b/ygVabcG5/uac-cheat-developer-platform

```

`UAC.sln`:

```sln

Microsoft Visual Studio Solution File, Format Version 12.00
# Visual Studio Version 16
VisualStudioVersion = 16.0.30717.126
MinimumVisualStudioVersion = 10.0.40219.1
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "KernelAntiCheat", "KernelAntiCheat\KernelAntiCheat.vcxproj", "{AA863813-E90A-4DF9-B032-839573C0DD54}"
EndProject
Global
	GlobalSection(SolutionConfigurationPlatforms) = preSolution
		Debug|ARM = Debug|ARM
		Debug|ARM64 = Debug|ARM64
		Debug|x64 = Debug|x64
		Debug|x86 = Debug|x86
		Release|ARM = Release|ARM
		Release|ARM64 = Release|ARM64
		Release|x64 = Release|x64
		Release|x86 = Release|x86
	EndGlobalSection
	GlobalSection(ProjectConfigurationPlatforms) = postSolution
		{AA863813-E90A-4DF9-B032-839573C0DD54}.Debug|ARM.ActiveCfg = Win10Debug|x64
		{AA863813-E90A-4DF9-B032-839573C0DD54}.Debug|ARM.Build.0 = Win10Debug|x64
		{AA863813-E90A-4DF9-B032-839573C0DD54}.Debug|ARM.Deploy.0 = Win10Debug|x64
		{AA863813-E90A-4DF9-B032-839573C0DD54}.Debug|ARM64.ActiveCfg = Debug|ARM64
		{AA863813-E90A-4DF9-B032-839573C0DD54}.Debug|ARM64.Build.0 = Debug|ARM64
		{AA863813-E90A-4DF9-B032-839573C0DD54}.Debug|ARM64.Deploy.0 = Debug|ARM64
		{AA863813-E90A-4DF9-B032-839573C0DD54}.Debug|x64.ActiveCfg = Debug|x64
		{AA863813-E90A-4DF9-B032-839573C0DD54}.Debug|x64.Build.0 = Debug|x64
		{AA863813-E90A-4DF9-B032-839573C0DD54}.Debug|x64.Deploy.0 = Debug|x64
		{AA863813-E90A-4DF9-B032-839573C0DD54}.Debug|x86.ActiveCfg = Debug|Win32
		{AA863813-E90A-4DF9-B032-839573C0DD54}.Debug|x86.Build.0 = Debug|Win32
		{AA863813-E90A-4DF9-B032-839573C0DD54}.Debug|x86.Deploy.0 = Debug|Win32
		{AA863813-E90A-4DF9-B032-839573C0DD54}.Release|ARM.ActiveCfg = Win10Debug|x64
		{AA863813-E90A-4DF9-B032-839573C0DD54}.Release|ARM.Build.0 = Win10Debug|x64
		{AA863813-E90A-4DF9-B032-839573C0DD54}.Release|ARM.Deploy.0 = Win10Debug|x64
		{AA863813-E90A-4DF9-B032-839573C0DD54}.Release|ARM64.ActiveCfg = Release|ARM64
		{AA863813-E90A-4DF9-B032-839573C0DD54}.Release|ARM64.Build.0 = Release|ARM64
		{AA863813-E90A-4DF9-B032-839573C0DD54}.Release|ARM64.Deploy.0 = Release|ARM64
		{AA863813-E90A-4DF9-B032-839573C0DD54}.Release|x64.ActiveCfg = Win10Release|x64
		{AA863813-E90A-4DF9-B032-839573C0DD54}.Release|x64.Build.0 = Win10Release|x64
		{AA863813-E90A-4DF9-B032-839573C0DD54}.Release|x86.ActiveCfg = Release|Win32
		{AA863813-E90A-4DF9-B032-839573C0DD54}.Release|x86.Build.0 = Release|Win32
		{AA863813-E90A-4DF9-B032-839573C0DD54}.Release|x86.Deploy.0 = Release|Win32
	EndGlobalSection
	GlobalSection(SolutionProperties) = preSolution
		HideSolutionNode = FALSE
	EndGlobalSection
	GlobalSection(ExtensibilityGlobals) = postSolution
		SolutionGuid = {5CFEF320-F924-453B-960B-FB0F1B18E1E5}
	EndGlobalSection
EndGlobal

```