Project Path: arc_namazso_MagicSigner_7r1rnzpq

Source Tree:

```txt
arc_namazso_MagicSigner_7r1rnzpq
├── CMakeLists.txt
├── LICENSE
├── README.md
└── library.cpp

```

`CMakeLists.txt`:

```txt
cmake_minimum_required(VERSION 3.25)

project(MagicSigner)

add_library(${PROJECT_NAME} SHARED library.cpp)

target_link_libraries(${PROJECT_NAME} PRIVATE crypt32)

set_target_properties(${PROJECT_NAME} PROPERTIES OUTPUT_NAME "XmlLite")

target_link_options(${PROJECT_NAME} PRIVATE
        /ENTRY:DllEntry
        /NOCOFFGRPINFO
        /Brepro
        /PDBALTPATH:%_PDB%
        )

```

`LICENSE`:

```
BSD Zero Clause License

Copyright (c) 2023 namazso <admin@namazso.eu>

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.

```

`README.md`:

```md
# MagicSigner

Patcher dll for signtool that allows signing with expired certificates

## Usage

Just place XmlLite.dll next to signtool.exe

## Demo

**Before MagicSigner**

![image](https://github.com/namazso/MagicSigner/assets/8676443/7469f4ee-8f8f-4eda-b703-407e8fe6176b)

**After MagicSigner**

![image](https://github.com/namazso/MagicSigner/assets/8676443/2b6fa4ca-611e-46b2-9917-bf91927d80a3)
![image](https://github.com/namazso/MagicSigner/assets/8676443/b9f28609-6e22-4ab7-a885-142fa526d02e)

## Alternative solutions

You can also just set the clock on your computer back. However that needs admin privileges, and has the tendency to break other apps, because it invalidates all the certificates TLS connections (like HTTPS) uses for the time.

## How to defend against this

Simply apply the [Microsoft vulnerable driver blocklist](https://learn.microsoft.com/en-us/windows/security/threat-protection/windows-defender-application-control/microsoft-recommended-driver-block-rules) which contains all the known leaked certificates.

## License

    BSD Zero Clause License

    Copyright (c) 2023 namazso <admin@namazso.eu>

    Permission to use, copy, modify, and/or distribute this software for any
    purpose with or without fee is hereby granted.

    THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
    REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
    AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
    INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
    LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
    OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
    PERFORMANCE OF THIS SOFTWARE.

```

`library.cpp`:

```cpp
//  Copyright (c) 2023 namazso <admin@namazso.eu>
//  
//  Permission to use, copy, modify, and/or distribute this software for any
//  purpose with or without fee is hereby granted.
//  
//  THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
//  REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
//  AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
//  INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
//  LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
//  OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
//  PERFORMANCE OF THIS SOFTWARE.

#include <Windows.h>

#include <cstdint>

HINSTANCE get_original_dll() {
  static HINSTANCE p{};
  if (!p)
    p = LoadLibraryExA("XmlLite.dll", nullptr, LOAD_LIBRARY_SEARCH_SYSTEM32);
  return p;
}

template <typename Fn>
Fn get_original(const char* name) {
  return (Fn)GetProcAddress(get_original_dll(), name);
}

using fnCreateXmlReader = HRESULT(WINAPI*)(REFIID riid, void** ppvObject, IMalloc* pMalloc);
using fnCreateXmlReaderInputWithEncodingCodePage = HRESULT(WINAPI*)(IUnknown* pInputStream, IMalloc* pMalloc, UINT nEncodingCodePage, BOOL fEncodingHint, LPCWSTR pwszBaseUri, struct IXmlReaderInput** ppInput);
using fnCreateXmlReaderInputWithEncodingName = HRESULT(WINAPI*)(IUnknown* pInputStream, IMalloc* pMalloc, LPCWSTR pwszEncodingName, BOOL fEncodingHint, LPCWSTR pwszBaseUri, struct IXmlReaderInput** ppInput);
using fnCreateXmlWriter = HRESULT(WINAPI*)(REFIID riid, void** ppvObject, IMalloc* pMalloc);
using fnCreateXmlWriterOutputWithEncodingCodePage = HRESULT(WINAPI*)(IUnknown* pOutputStream, IMalloc* pMalloc, UINT nEncodingCodePage, struct IXmlWriterOutput** ppOutput);
using fnCreateXmlWriterOutputWithEncodingName = HRESULT(WINAPI*)(IUnknown* pOutputStream, IMalloc* pMalloc, LPCWSTR pwszEncodingName, struct IXmlWriterOutput** ppOutput);

EXTERN_C __declspec(dllexport) HRESULT STDAPICALLTYPE CreateXmlReader(REFIID riid, void** ppvObject, IMalloc* pMalloc) {
  return get_original<fnCreateXmlReader>("CreateXmlReader")(riid, ppvObject, pMalloc);
}
EXTERN_C __declspec(dllexport) HRESULT STDAPICALLTYPE CreateXmlReaderInputWithEncodingCodePage(IUnknown* pInputStream, IMalloc* pMalloc, UINT nEncodingCodePage, BOOL fEncodingHint, LPCWSTR pwszBaseUri, struct IXmlReaderInput** ppInput) {
  return get_original<fnCreateXmlReaderInputWithEncodingCodePage>("CreateXmlReaderInputWithEncodingCodePage")(pInputStream, pMalloc, nEncodingCodePage, fEncodingHint, pwszBaseUri, ppInput);
}
EXTERN_C __declspec(dllexport) HRESULT STDAPICALLTYPE CreateXmlReaderInputWithEncodingName(IUnknown* pInputStream, IMalloc* pMalloc, LPCWSTR pwszEncodingName, BOOL fEncodingHint, LPCWSTR pwszBaseUri, struct IXmlReaderInput** ppInput) {
  return get_original<fnCreateXmlReaderInputWithEncodingName>("CreateXmlReaderInputWithEncodingName")(pInputStream, pMalloc, pwszEncodingName, fEncodingHint, pwszBaseUri, ppInput);
}
EXTERN_C __declspec(dllexport) HRESULT STDAPICALLTYPE CreateXmlWriter(REFIID riid, void** ppvObject, IMalloc* pMalloc) {
  return get_original<fnCreateXmlWriter>("CreateXmlWriter")(riid, ppvObject, pMalloc);
}
EXTERN_C __declspec(dllexport) HRESULT STDAPICALLTYPE CreateXmlWriterOutputWithEncodingCodePage(IUnknown* pOutputStream, IMalloc* pMalloc, UINT nEncodingCodePage, struct IXmlWriterOutput** ppOutput) {
  return get_original<fnCreateXmlWriterOutputWithEncodingCodePage>("CreateXmlWriterOutputWithEncodingCodePage")(pOutputStream, pMalloc, nEncodingCodePage, ppOutput);
}
EXTERN_C __declspec(dllexport) HRESULT STDAPICALLTYPE CreateXmlWriterOutputWithEncodingName(IUnknown* pOutputStream, IMalloc* pMalloc, LPCWSTR pwszEncodingName, struct IXmlWriterOutput** ppOutput) {
  return get_original<fnCreateXmlWriterOutputWithEncodingName>("CreateXmlWriterOutputWithEncodingName")(pOutputStream, pMalloc, pwszEncodingName, ppOutput);
}

void* follow_jumps(void* p) {
  auto pb = (uint8_t*)p;
  while (true) {
    if (pb[0] == 0xEB) {
      pb += 2 + (intptr_t) * ((int8_t*)&pb[1]);
      continue;
    }
    if (pb[0] == 0xE9) {
      pb += 5 + (intptr_t) * ((int32_t*)&pb[1]);
      continue;
    }
    if (pb[0] == 0xFF && pb[1] == 0x25) {
      pb = *(uint8_t**)(pb + 6 + (intptr_t) * ((int32_t*)&pb[2]));
      continue;
    }
    if (pb[0] == 0x48 && pb[1] == 0xFF && pb[2] == 0x25) {
      pb = *(uint8_t**)(pb + 7 + (intptr_t) * ((int32_t*)&pb[3]));
      continue;
    }
    break;
  }
  return pb;
}

LONG WINAPI hooked_CertVerifyTimeValidity(LPFILETIME pTimeToVerify, PCERT_INFO pCertInfo) {
  return 0;
}

VOID WINAPI hooked_GetSystemTimeAsFileTime(LPFILETIME lpSystemTimeAsFileTime) {
  *lpSystemTimeAsFileTime = {};
}

static BOOL hook(void* fn, void* hook_fn) {
  const auto patch = follow_jumps(fn);

  struct hkstruct {
    uint8_t arr[8] = {0xff, 0x25, 2, 0, 0, 0, 0x90, 0x90};
    void* p{};
  } s;

  s.p = hook_fn;
  SIZE_T w{};
  return WriteProcessMemory((HANDLE)-1, patch, &s, sizeof(s), &w);
}

static void initialize() {
  hook((void*)&CertVerifyTimeValidity, (void*)hooked_CertVerifyTimeValidity);
  hook((void*)&GetSystemTimeAsFileTime, (void*)hooked_GetSystemTimeAsFileTime);
}

extern "C" BOOL WINAPI DllEntry(HINSTANCE, DWORD reason, LPVOID) {
  if (reason == DLL_PROCESS_ATTACH)
    initialize();
  return TRUE;
}

```