Project Path: arc_GravitLauncher_Avanguard_hveikpdz

Source Tree:

```txt
arc_GravitLauncher_Avanguard_hveikpdz
├── # Bindings
│   └── Java
│       └── src
│           └── ru
│               └── zaxar163
│                   ├── GuardBind.java
│                   └── Main.java
├── Avanguard
│   ├── AsmJit
│   │   ├── asmjit
│   │   │   ├── asmjit.h
│   │   │   ├── core
│   │   │   │   ├── arch.h
│   │   │   │   ├── assembler.h
│   │   │   │   ├── build.h
│   │   │   │   ├── builder.h
│   │   │   │   ├── callconv.h
│   │   │   │   ├── codeholder.h
│   │   │   │   ├── compiler.h
│   │   │   │   ├── constpool.h
│   │   │   │   ├── cpuinfo.h
│   │   │   │   ├── datatypes.h
│   │   │   │   ├── emitter.h
│   │   │   │   ├── features.h
│   │   │   │   ├── func.h
│   │   │   │   ├── globals.h
│   │   │   │   ├── inst.h
│   │   │   │   ├── jitallocator.h
│   │   │   │   ├── jitruntime.h
│   │   │   │   ├── jitutils.h
│   │   │   │   ├── logging.h
│   │   │   │   ├── memmgr.h
│   │   │   │   ├── misc_p.h
│   │   │   │   ├── operand.h
│   │   │   │   ├── osutils.h
│   │   │   │   ├── raassignment_p.h
│   │   │   │   ├── rabuilders_p.h
│   │   │   │   ├── radefs_p.h
│   │   │   │   ├── ralocal_p.h
│   │   │   │   ├── rapass_p.h
│   │   │   │   ├── rastack_p.h
│   │   │   │   ├── stringbuilder.h
│   │   │   │   ├── stringutils.h
│   │   │   │   ├── support.h
│   │   │   │   ├── target.h
│   │   │   │   ├── type.h
│   │   │   │   ├── zone.h
│   │   │   │   ├── zonehash.h
│   │   │   │   ├── zonelist.h
│   │   │   │   ├── zonestack.h
│   │   │   │   ├── zonestring.h
│   │   │   │   ├── zonetree.h
│   │   │   │   └── zonevector.h
│   │   │   ├── core.h
│   │   │   ├── x86
│   │   │   │   ├── x86assembler.h
│   │   │   │   ├── x86builder.h
│   │   │   │   ├── x86callconv_p.h
│   │   │   │   ├── x86compiler.h
│   │   │   │   ├── x86emitter.h
│   │   │   │   ├── x86features.h
│   │   │   │   ├── x86globals.h
│   │   │   │   ├── x86instdb.h
│   │   │   │   ├── x86internal_p.h
│   │   │   │   ├── x86logging_p.h
│   │   │   │   ├── x86opcode_p.h
│   │   │   │   ├── x86operand.h
│   │   │   │   ├── x86rapass_p.h
│   │   │   │   └── x86ssetoavx_p.h
│   │   │   └── x86.h
│   │   ├── asmtk
│   │   │   ├── asmparser.cpp
│   │   │   ├── asmparser.h
│   │   │   ├── asmtk.h
│   │   │   ├── asmtokenizer.cpp
│   │   │   ├── asmtokenizer.h
│   │   │   ├── elfdefs.h
│   │   │   ├── globals.h
│   │   │   ├── parserutils.h
│   │   │   └── strtod.h
│   │   └── lib
│   │       ├── x64
│   │       │   ├── asmjit.dbg.x64.lib
│   │       │   └── asmjit.rel.x64.lib
│   │       └── x86
│   │           ├── asmjit.dbg.x86.lib
│   │           └── asmjit.rel.x86.lib
│   ├── Avanguard.cpp
│   ├── Avanguard.rc
│   ├── Avanguard.vcxproj
│   ├── Avanguard.vcxproj.filters
│   ├── AvanguardDefence
│   │   ├── AntiDebugging.cpp
│   │   ├── AntiDebugging.h
│   │   ├── AntiMacros.cpp
│   │   ├── AntiMacros.h
│   │   ├── ApcDispatcher.cpp
│   │   ├── ApcDispatcher.h
│   │   ├── ApcInterceptionRoutine.asm
│   │   ├── ApisetResolver.cpp
│   │   ├── ApisetResolver.h
│   │   ├── AppInitDlls.cpp
│   │   ├── AppInitDlls.h
│   │   ├── AvnApi.cpp
│   │   ├── AvnApi.h
│   │   ├── AvnDefinitions.h
│   │   ├── CheckHook.cpp
│   │   ├── CheckHook.h
│   │   ├── ContextFilter.cpp
│   │   ├── ContextFilter.h
│   │   ├── DACL.cpp
│   │   ├── DACL.h
│   │   ├── Encryption.cpp
│   │   ├── Encryption.h
│   │   ├── HWID.cpp
│   │   ├── HWID.h
│   │   ├── HWIDsUtils.cpp
│   │   ├── HWIDsUtils.h
│   │   ├── HandlesKeeper.cpp
│   │   ├── HandlesKeeper.h
│   │   ├── HeapManager.cpp
│   │   ├── HeapManager.h
│   │   ├── JavaBindings.cpp
│   │   ├── JavaBindings.h
│   │   ├── KeSecuredMemory.cpp
│   │   ├── KeSecuredMemory.h
│   │   ├── KernelUtils.cpp
│   │   ├── KernelUtils.h
│   │   ├── Locks.h
│   │   ├── MemoryCallbacks.cpp
│   │   ├── MemoryCallbacks.h
│   │   ├── MemoryFilter.cpp
│   │   ├── MemoryFilter.h
│   │   ├── MemoryStorage.cpp
│   │   ├── MemoryStorage.h
│   │   ├── Mitigations.cpp
│   │   ├── Mitigations.h
│   │   ├── ModulesCallbacks.cpp
│   │   ├── ModulesCallbacks.h
│   │   ├── ModulesFilter.cpp
│   │   ├── ModulesFilter.h
│   │   ├── ModulesStorage.cpp
│   │   ├── ModulesStorage.h
│   │   ├── ModulesUtils.cpp
│   │   ├── ModulesUtils.h
│   │   ├── PEAnalyzer.cpp
│   │   ├── PEAnalyzer.h
│   │   ├── PEUtils.cpp
│   │   ├── PEUtils.h
│   │   ├── PebTeb.h
│   │   ├── ProcessAPI.cpp
│   │   ├── ProcessAPI.h
│   │   ├── Remapping.cpp
│   │   ├── Remapping.h
│   │   ├── SfcWrapper.cpp
│   │   ├── SfcWrapper.h
│   │   ├── SupportedOS.manifest
│   │   ├── TLS.cpp
│   │   ├── TLS.h
│   │   ├── ThreadsFilter.cpp
│   │   ├── ThreadsFilter.h
│   │   ├── ThreatElimination.cpp
│   │   ├── ThreatElimination.h
│   │   ├── ThreatTypes.h
│   │   ├── WinHooks.cpp
│   │   ├── WinHooks.h
│   │   ├── WinTrusted.cpp
│   │   ├── WinTrusted.h
│   │   ├── hModules.cpp
│   │   └── hModules.h
│   ├── HoShiMin's API
│   │   ├── CodepageAPI.cpp
│   │   ├── CodepageAPI.h
│   │   ├── ColoredConsole.h
│   │   ├── DisasmHelper.cpp
│   │   ├── DisasmHelper.h
│   │   ├── HookHelper.h
│   │   ├── JitHelper.cpp
│   │   ├── JitHelper.h
│   │   ├── StringsAPI.cpp
│   │   └── StringsAPI.h
│   ├── JNI
│   │   ├── include
│   │   │   ├── jni.h
│   │   │   ├── jvmti.h
│   │   │   └── win32
│   │   │       └── jni_md.h
│   │   └── lib
│   │       └── jvm.lib
│   ├── MinHook
│   │   ├── MinHook.h
│   │   ├── libMinHook.x64.lib
│   │   └── libMinHook.x86.lib
│   ├── Zydis
│   │   ├── Zydis
│   │   │   ├── CommonTypes.h
│   │   │   ├── Decoder.h
│   │   │   ├── DecoderTypes.h
│   │   │   ├── Defines.h
│   │   │   ├── Formatter.h
│   │   │   ├── Generated
│   │   │   │   ├── EnumISAExt.h
│   │   │   │   ├── EnumISASet.h
│   │   │   │   ├── EnumInstructionCategory.h
│   │   │   │   └── EnumMnemonic.h
│   │   │   ├── Internal
│   │   │   │   ├── DecoderData.h
│   │   │   │   ├── LibC.h
│   │   │   │   └── SharedData.h
│   │   │   ├── MetaInfo.h
│   │   │   ├── Mnemonic.h
│   │   │   ├── Register.h
│   │   │   ├── SharedTypes.h
│   │   │   ├── Status.h
│   │   │   ├── String.h
│   │   │   ├── Utils.h
│   │   │   └── Zydis.h
│   │   ├── Zydis.dll.x64.dll
│   │   ├── Zydis.dll.x64.lib
│   │   ├── Zydis.dll.x86.dll
│   │   ├── Zydis.dll.x86.lib
│   │   ├── Zydis.km.x32.lib
│   │   ├── Zydis.km.x64.lib
│   │   ├── Zydis.km.x86.lib
│   │   ├── Zydis.x64.lib
│   │   ├── Zydis.x86.lib
│   │   └── ZydisExportConfig.h
│   ├── resource.h
│   ├── stdafx.cpp
│   ├── stdafx.h
│   ├── t1ha
│   │   ├── t1ha.h
│   │   ├── t1ha.x64.lib
│   │   └── t1ha.x86.lib
│   ├── targetver.h
│   └── xorstr
│       └── xorstr.hpp
├── Avanguard.sln
├── EntryPointCryptor
│   ├── EntryPointCryptor.cpp
│   ├── EntryPointCryptor.vcxproj
│   ├── EntryPointCryptor.vcxproj.filters
│   ├── stdafx.cpp
│   ├── stdafx.h
│   └── targetver.h
├── README.md
└── SomeExternalDll
    ├── Exports.def
    ├── SomeExternalDll.cpp
    ├── SomeExternalDll.vcxproj
    ├── SomeExternalDll.vcxproj.filters
    ├── dllmain.cpp
    ├── stdafx.cpp
    ├── stdafx.h
    └── targetver.h

```

`# Bindings/Java/src/ru/zaxar163/GuardBind.java`:

```java
package ru.zaxar163;

import java.io.File;

public final class GuardBind {
	public static enum ThreatType {
        UNKNOWN_THREAT              (0),
        REMOTE_THREAD               (1),
        WINDOWS_HOOKS_INJECTION     (2),
        UNKNOWN_TRACE_LOAD_LIBRARY  (3),
        CONTEXT_MANIPULATION        (4),
        CRITICAL_MODULE_CHANGED     (5),
        UNKNOWN_INTERCEPTION        (6),
        UNKNOWN_MEMORY_REGION       (7),
        UNKNOWN_APC_DESTINATION     (8);

        private final int id;

        ThreatType(int value) {
            id = value;
        }

        public int getValue() { return id; }
        public static ThreatType getThreat(int threatType) {
            return ThreatType.values()[threatType];
        }
    }

    public static interface ThreatNotifier {
    	public boolean call(int threatType);
    }

    /*static {
    	try {
    		init();
    	} catch (Throwable ign) { }
    }*/
    
    public static void init() {
    	init(new File("Avanguard.dll"));
    }
    
    public static void init(File dll) {
    	init(dll.getAbsolutePath());
    }
    
    public static void init(String path) {
    	System.load(path);
    }

    public static native boolean    avnStartDefence();
    public static native void       avnStopDefence();
    public static native boolean    avnIsStarted();
    public static native boolean    avnIsStaticLoaded();
    public static native void       avnEliminateThreat(int threatType);
    public static native long       avnGetCpuid();
	public static native long       avnGetSmbiosId();
	public static native long       avnGetMacId();
	public static native long       avnGetHddId();
    public static native long       avnGetHash(byte[] data);
	public static native void       setCheckTime(int time);
	public static native int        getCheckTime();
	
    public static native void avnRegisterThreatNotifier(ThreatNotifier notifier);
}

```

`# Bindings/Java/src/ru/zaxar163/Main.java`:

```java
package ru.zaxar163;

public class Main {

    public static void main(String[] args) {
    	GuardBind.init();
        GuardBind.avnRegisterThreatNotifier((int threatType) -> {
            System.out.println("Threat " + GuardBind.ThreatType.getThreat(threatType).name());
            return true;
        });
        GuardBind.setCheckTime(5000);
        GuardBind.avnEliminateThreat(GuardBind.ThreatType.REMOTE_THREAD.getValue());
        GuardBind.avnStartDefence();
        while (true) { }
        //GuardBind.avnRegisterThreatNotifier(null);
        //GuardBind.avnEliminateThreat(GuardBind.ThreatType.UNKNOWN_APC_DESTINATION.getValue());
    }
}

```

`Avanguard.sln`:

```sln

Microsoft Visual Studio Solution File, Format Version 12.00
# Visual Studio 15
VisualStudioVersion = 15.0.27019.1
MinimumVisualStudioVersion = 10.0.40219.1
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "Avanguard", "Avanguard\Avanguard.vcxproj", "{540A22E1-D40F-4D6E-9FFA-652E3450D064}"
EndProject
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "SomeExternalDll", "SomeExternalDll\SomeExternalDll.vcxproj", "{209EF3F6-482C-488B-A5CF-5BF8CD637DE6}"
EndProject
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "EntryPointCryptor", "EntryPointCryptor\EntryPointCryptor.vcxproj", "{95B79E39-F7D6-45ED-8DD8-1D2C14188086}"
EndProject
Global
	GlobalSection(SolutionConfigurationPlatforms) = preSolution
		Debug|x64 = Debug|x64
		Debug|x86 = Debug|x86
		Release|x64 = Release|x64
		Release|x86 = Release|x86
	EndGlobalSection
	GlobalSection(ProjectConfigurationPlatforms) = postSolution
		{540A22E1-D40F-4D6E-9FFA-652E3450D064}.Debug|x64.ActiveCfg = Debug|x64
		{540A22E1-D40F-4D6E-9FFA-652E3450D064}.Debug|x64.Build.0 = Debug|x64
		{540A22E1-D40F-4D6E-9FFA-652E3450D064}.Debug|x64.Deploy.0 = Debug|x64
		{540A22E1-D40F-4D6E-9FFA-652E3450D064}.Debug|x86.ActiveCfg = Debug|Win32
		{540A22E1-D40F-4D6E-9FFA-652E3450D064}.Debug|x86.Build.0 = Debug|Win32
		{540A22E1-D40F-4D6E-9FFA-652E3450D064}.Debug|x86.Deploy.0 = Debug|Win32
		{540A22E1-D40F-4D6E-9FFA-652E3450D064}.Release|x64.ActiveCfg = Release|x64
		{540A22E1-D40F-4D6E-9FFA-652E3450D064}.Release|x64.Build.0 = Release|x64
		{540A22E1-D40F-4D6E-9FFA-652E3450D064}.Release|x64.Deploy.0 = Release|x64
		{540A22E1-D40F-4D6E-9FFA-652E3450D064}.Release|x86.ActiveCfg = Release|Win32
		{540A22E1-D40F-4D6E-9FFA-652E3450D064}.Release|x86.Build.0 = Release|Win32
		{540A22E1-D40F-4D6E-9FFA-652E3450D064}.Release|x86.Deploy.0 = Release|Win32
		{209EF3F6-482C-488B-A5CF-5BF8CD637DE6}.Debug|x64.ActiveCfg = Debug|x64
		{209EF3F6-482C-488B-A5CF-5BF8CD637DE6}.Debug|x64.Build.0 = Debug|x64
		{209EF3F6-482C-488B-A5CF-5BF8CD637DE6}.Debug|x86.ActiveCfg = Debug|Win32
		{209EF3F6-482C-488B-A5CF-5BF8CD637DE6}.Debug|x86.Build.0 = Debug|Win32
		{209EF3F6-482C-488B-A5CF-5BF8CD637DE6}.Release|x64.ActiveCfg = Release|x64
		{209EF3F6-482C-488B-A5CF-5BF8CD637DE6}.Release|x64.Build.0 = Release|x64
		{209EF3F6-482C-488B-A5CF-5BF8CD637DE6}.Release|x86.ActiveCfg = Release|Win32
		{209EF3F6-482C-488B-A5CF-5BF8CD637DE6}.Release|x86.Build.0 = Release|Win32
		{95B79E39-F7D6-45ED-8DD8-1D2C14188086}.Debug|x64.ActiveCfg = Debug|x64
		{95B79E39-F7D6-45ED-8DD8-1D2C14188086}.Debug|x64.Build.0 = Debug|x64
		{95B79E39-F7D6-45ED-8DD8-1D2C14188086}.Debug|x86.ActiveCfg = Debug|Win32
		{95B79E39-F7D6-45ED-8DD8-1D2C14188086}.Debug|x86.Build.0 = Debug|Win32
		{95B79E39-F7D6-45ED-8DD8-1D2C14188086}.Release|x64.ActiveCfg = Release|x64
		{95B79E39-F7D6-45ED-8DD8-1D2C14188086}.Release|x64.Build.0 = Release|x64
		{95B79E39-F7D6-45ED-8DD8-1D2C14188086}.Release|x86.ActiveCfg = Release|Win32
		{95B79E39-F7D6-45ED-8DD8-1D2C14188086}.Release|x86.Build.0 = Release|Win32
	EndGlobalSection
	GlobalSection(SolutionProperties) = preSolution
		HideSolutionNode = FALSE
	EndGlobalSection
	GlobalSection(ExtensibilityGlobals) = postSolution
		SolutionGuid = {AE0739EC-7F47-4652-B0BE-7FD7BCF25A33}
	EndGlobalSection
EndGlobal

```

`Avanguard/AsmJit/asmjit/asmjit.h`:

```h
// [AsmJit]
// Complete x86/x64 JIT and Remote Assembler for C++.
//
// [License]
// ZLIB - See LICENSE.md file in the package.

// [Guard]
#ifndef _ASMJIT_ASMJIT_H
#define _ASMJIT_ASMJIT_H

// ============================================================================
// [asmjit_mainpage]
// ============================================================================

//! \mainpage
//!
//! AsmJit Reference Manual
//!
//! Introduction provided by the project page at https://github.com/asmjit/asmjit.

// ============================================================================
// [asmjit_core]
// ============================================================================

//! \defgroup asmjit_core asmjit/core
//! \brief AsmJit Core.

//! \defgroup asmjit_core_api Core API
//! \ingroup asmjit_core

//! \defgroup asmjit_core_func Function API
//! \ingroup asmjit_core

//! \defgroup asmjit_core_jit JIT API
//! \ingroup asmjit_core

//! \defgroup asmjit_core_support Support API
//! \ingroup asmjit_core

//! \defgroup asmjit_core_ra RA Internals
//! \ingroup asmjit_core

// ============================================================================
// [asmjit_x86]
// ============================================================================

//! \defgroup asmjit_x86 asmjit/x86
//! \brief AsmJit X86 backend.

//! \defgroup asmjit_x86_api X86 API
//! \ingroup asmjit_x86

//! \defgroup asmjit_x86_db X86 Database
//! \ingroup asmjit_x86

//! \defgroup asmjit_x86_ra X86 RA
//! \ingroup asmjit_x86

// ============================================================================
// [asmjit_arm]
// ============================================================================

//! \defgroup asmjit_arm asmjit/arm
//! \brief AsmJit ARM backend.

//! \defgroup asmjit_arm_api ARM API
//! \ingroup asmjit_arm

//! \defgroup asmjit_arm_db ARM Database
//! \ingroup asmjit_arm

// ============================================================================
// [Dependencies]
// ============================================================================

#include "./core.h"

#ifdef ASMJIT_BUILD_X86
  #include "./x86.h"
#endif

#ifdef ASMJIT_BUILD_ARM
  #include "./arm.h"
#endif

// [Guard]
#endif // _ASMJIT_ASMJIT_H

```

`Avanguard/AsmJit/asmjit/core.h`:

```h
// [AsmJit]
// Complete x86/x64 JIT and Remote Assembler for C++.
//
// [License]
// ZLIB - See LICENSE.md file in the package.

// [Guard]
#ifndef _ASMJIT_CORE_H
#define _ASMJIT_CORE_H

// [Dependencies]
#include "./core/globals.h"

#include "./core/arch.h"
#include "./core/assembler.h"
#include "./core/builder.h"
#include "./core/callconv.h"
#include "./core/codeholder.h"
#include "./core/compiler.h"
#include "./core/constpool.h"
#include "./core/cpuinfo.h"
#include "./core/datatypes.h"
#include "./core/emitter.h"
#include "./core/features.h"
#include "./core/func.h"
#include "./core/inst.h"
#include "./core/jitallocator.h"
#include "./core/jitruntime.h"
#include "./core/jitutils.h"
#include "./core/logging.h"
#include "./core/memmgr.h"
#include "./core/operand.h"
#include "./core/osutils.h"
#include "./core/stringbuilder.h"
#include "./core/stringutils.h"
#include "./core/support.h"
#include "./core/target.h"
#include "./core/type.h"
#include "./core/zone.h"
#include "./core/zonehash.h"
#include "./core/zonelist.h"
#include "./core/zonetree.h"
#include "./core/zonestack.h"
#include "./core/zonestring.h"
#include "./core/zonevector.h"

// DEPRECATED:
ASMJIT_BEGIN_NAMESPACE

#ifndef ASMJIT_DISABLE_BUILDER
typedef ASMJIT_DEPRECATED(BaseBuilder   CodeBuilder , "Use `BaseBuilder`");
typedef ASMJIT_DEPRECATED(BaseNode      CBNode      , "Use `BaseNode`");
typedef ASMJIT_DEPRECATED(InstNode      CBInst      , "Use `InstNode`");
typedef ASMJIT_DEPRECATED(LabelNode     CBLabel     , "Use `LabelNode`");
typedef ASMJIT_DEPRECATED(AlignNode     CBAlign     , "Use `AlignNode`");
typedef ASMJIT_DEPRECATED(EmbedDataNode CBData      , "Use `EmbedDataNode`");
typedef ASMJIT_DEPRECATED(LabelDataNode CBLabelData , "Use `LabelDataNode`");
typedef ASMJIT_DEPRECATED(ConstPoolNode CBConstPool , "Use `ConstPoolNode`");
typedef ASMJIT_DEPRECATED(CommentNode   CBComment   , "Use `CommentNode`");
typedef ASMJIT_DEPRECATED(SentinelNode  CBSentinel  , "Use `SentinelNode`");
typedef ASMJIT_DEPRECATED(Pass          CBPass      , "Use `Pass`");
#endif

#ifndef ASMJIT_DISABLE_COMPILER
typedef ASMJIT_DEPRECATED(BaseCompiler  CodeCompiler, "Use `BaseCompiler`");
typedef ASMJIT_DEPRECATED(FuncNode      CCFunc      , "Use `FuncNode`");
typedef ASMJIT_DEPRECATED(FuncRetNode   CCFuncRet   , "Use `FuncRetNode`");
typedef ASMJIT_DEPRECATED(FuncCallNode  CCFuncCall  , "Use `FuncCallNode`");
#endif
ASMJIT_END_NAMESPACE

// [Guard]
#endif // _ASMJIT_CORE_H

```

`Avanguard/AsmJit/asmjit/core/arch.h`:

```h
// [AsmJit]
// Complete x86/x64 JIT and Remote Assembler for C++.
//
// [License]
// ZLIB - See LICENSE.md file in the package.

// [Guard]
#ifndef _ASMJIT_CORE_ARCH_H
#define _ASMJIT_CORE_ARCH_H

// [Dependencies]
#include "../core/operand.h"

ASMJIT_BEGIN_NAMESPACE

//! \addtogroup asmjit_core_api
//! \{

// ============================================================================
// [asmjit::ArchInfo]
// ============================================================================

class ArchInfo {
public:
  //! Architecture id.
  enum Id : uint32_t {
    kIdNone  = 0,                        //!< No/Unknown architecture.

    // X86 architectures.
    kIdX86   = 1,                        //!< X86 architecture (32-bit).
    kIdX64   = 2,                        //!< X64 architecture (64-bit) (AMD64).

    // ARM architectures.
    kIdA32   = 3,                        //!< ARM 32-bit architecture (AArch32/ARM/THUMB).
    kIdA64   = 4,                        //!< ARM 64-bit architecture (AArch64).

    //! Architecture detected at compile-time (architecture of the host).
    kIdHost  = ASMJIT_ARCH_X86 == 32 ? kIdX86 :
               ASMJIT_ARCH_X86 == 64 ? kIdX64 :
               ASMJIT_ARCH_ARM == 32 ? kIdA32 :
               ASMJIT_ARCH_ARM == 64 ? kIdA64 : kIdNone
  };

  //! Architecture sub-type or execution mode.
  enum SubType : uint32_t {
    kSubIdNone         = 0,              //!< Default mode (or no specific mode).

    // X86 sub-types.
    kSubIdX86_AVX      = 1,              //!< Code generation uses AVX         by default (VEC instructions).
    kSubIdX86_AVX2     = 2,              //!< Code generation uses AVX2        by default (VEC instructions).
    kSubIdX86_AVX512   = 3,              //!< Code generation uses AVX-512F    by default (+32 vector regs).
    kSubIdX86_AVX512VL = 4,              //!< Code generation uses AVX-512F-VL by default (+VL extensions).

    // ARM sub-types.
    kSubIdA32_Thumb    = 8,              //!< THUMB|THUMBv2 sub-type (only ARM in 32-bit mode).

    #if   (ASMJIT_ARCH_X86) && defined(__AVX512VL__)
    kSubIdHost = kSubIdX86_AVX512VL
    #elif (ASMJIT_ARCH_X86) && defined(__AVX512F__)
    kSubIdHost = kSubIdX86_AVX512
    #elif (ASMJIT_ARCH_X86) && defined(__AVX2__)
    kSubIdHost = kSubIdX86_AVX2
    #elif (ASMJIT_ARCH_X86) && defined(__AVX__)
    kSubIdHost = kSubIdX86_AVX
    #elif (ASMJIT_ARCH_ARM == 32) && (defined(_M_ARMT) || defined(__thumb__) || defined(__thumb2__))
    kSubIdHost = kSubIdA32_Thumb
    #else
    kSubIdHost = 0
    #endif
  };

  // --------------------------------------------------------------------------
  // [Utilities]
  // --------------------------------------------------------------------------

  static inline bool isX86Family(uint32_t archId) noexcept { return archId >= kIdX86 && archId <= kIdX64; }
  static inline bool isArmFamily(uint32_t archId) noexcept { return archId >= kIdA32 && archId <= kIdA64; }

  // --------------------------------------------------------------------------
  // [Construction / Destruction]
  // --------------------------------------------------------------------------

  inline ArchInfo() noexcept : _signature(0) {}
  inline ArchInfo(const ArchInfo& other) noexcept : _signature(other._signature) {}
  inline explicit ArchInfo(uint32_t type, uint32_t subType = kSubIdNone) noexcept { init(type, subType); }

  inline static ArchInfo host() noexcept { return ArchInfo(kIdHost, kSubIdHost); }

  // --------------------------------------------------------------------------
  // [Init / Reset]
  // --------------------------------------------------------------------------

  inline bool isInitialized() const noexcept { return _id != kIdNone; }

  ASMJIT_API void init(uint32_t type, uint32_t subType = kSubIdNone) noexcept;
  inline void reset() noexcept { _signature = 0; }

  // --------------------------------------------------------------------------
  // [Accessors]
  // --------------------------------------------------------------------------

  //! Get architecture id, see `Id`.
  inline uint32_t archId() const noexcept { return _id; }

  //! Get architecture sub-type, see `SubType`.
  //!
  //! X86 & X64
  //! ---------
  //!
  //! Architecture subtype describe the highest instruction-set level that can
  //! be used.
  //!
  //! A32 & A64
  //! ---------
  //!
  //! Architecture mode means the instruction encoding to be used when generating
  //! machine code, thus mode can be used to force generation of THUMB and THUMBv2
  //! encoding or regular ARM encoding.
  inline uint32_t archSubId() const noexcept { return _subId; }

  //! Get whether the architecture is 32-bit.
  inline bool is32Bit() const noexcept { return _gpSize == 4; }
  //! Get whether the architecture is 64-bit.
  inline bool is64Bit() const noexcept { return _gpSize == 8; }

  //! Get whether the architecture is X86, X64, or X32.
  inline bool isX86Family() const noexcept { return isX86Family(_id); }
  //! Get whether the architecture is ARM32 or ARM64.
  inline bool isArmFamily() const noexcept { return isArmFamily(_id); }

  //! Get a size of a general-purpose register.
  inline uint32_t gpSize() const noexcept { return _gpSize; }
  //! Get number of general-purpose registers.
  inline uint32_t gpCount() const noexcept { return _gpCount; }

  // --------------------------------------------------------------------------
  // [Operator Overload]
  // --------------------------------------------------------------------------

  inline ArchInfo& operator=(const ArchInfo& other) noexcept = default;

  inline bool operator==(const ArchInfo& other) const noexcept { return _signature == other._signature; }
  inline bool operator!=(const ArchInfo& other) const noexcept { return _signature != other._signature; }

  // --------------------------------------------------------------------------
  // [Members]
  // --------------------------------------------------------------------------

  union {
    struct {
      uint8_t _id;                       //!< Architecture id.
      uint8_t _subId;                    //!< Architecture sub-id.
      uint8_t _gpSize;                   //!< Default size of a general purpose register.
      uint8_t _gpCount;                  //!< Count of all general purpose registers.
    };
    uint32_t _signature;                 //!< Architecture signature (32-bit int).
  };
};

// ============================================================================
// [asmjit::ArchRegs]
// ============================================================================

//! Information about all architecture registers.
struct ArchRegs {
  //! Register information and signatures indexed by `BaseReg::RegType`.
  RegInfo regInfo[BaseReg::kTypeMax + 1];
  //! Count (maximum) of registers per `BaseReg::RegType`.
  uint8_t regCount[BaseReg::kTypeMax + 1];
  //! Converts RegType to TypeId, see `Type::Id`.
  uint8_t regTypeToTypeId[BaseReg::kTypeMax + 1];
};

// ============================================================================
// [asmjit::ArchUtils]
// ============================================================================

struct ArchUtils {
  ASMJIT_API static Error typeIdToRegInfo(uint32_t archId, uint32_t& typeIdInOut, RegInfo& regInfo) noexcept;
};

//! \}

ASMJIT_END_NAMESPACE

// [Guard]
#endif // _ASMJIT_CORE_ARCH_H

```

`Avanguard/AsmJit/asmjit/core/assembler.h`:

```h
// [AsmJit]
// Complete x86/x64 JIT and Remote Assembler for C++.
//
// [License]
// ZLIB - See LICENSE.md file in the package.

// [Guard]
#ifndef _ASMJIT_CORE_ASSEMBLER_H
#define _ASMJIT_CORE_ASSEMBLER_H

// [Dependencies]
#include "../core/codeholder.h"
#include "../core/datatypes.h"
#include "../core/emitter.h"
#include "../core/operand.h"

ASMJIT_BEGIN_NAMESPACE

//! \addtogroup asmjit_core_api
//! \{

// ============================================================================
// [asmjit::BaseAssembler]
// ============================================================================

//! Base encoder (assembler).
class ASMJIT_VIRTAPI BaseAssembler : public BaseEmitter {
public:
  ASMJIT_NONCOPYABLE(BaseAssembler)
  typedef BaseEmitter Base;

  // --------------------------------------------------------------------------
  // [Construction / Destruction]
  // --------------------------------------------------------------------------

  //! Create a new `BaseAssembler` instance.
  ASMJIT_API BaseAssembler() noexcept;
  //! Destroy the `BaseAssembler` instance.
  ASMJIT_API virtual ~BaseAssembler() noexcept;

  // --------------------------------------------------------------------------
  // [Buffer Management]
  // --------------------------------------------------------------------------

  //! Get the capacity of the current CodeBuffer.
  inline size_t bufferCapacity() const noexcept { return (size_t)(_bufferEnd - _bufferData); }
  //! Get the number of remaining bytes in the current CodeBuffer.
  inline size_t remainingSpace() const noexcept { return (size_t)(_bufferEnd - _bufferPtr); }

  //! Get the current position in the CodeBuffer.
  inline size_t offset() const noexcept { return (size_t)(_bufferPtr - _bufferData); }
  //! Set the current position in the CodeBuffer to `offset`.
  //!
  //! NOTE: The `offset` cannot be outside of the buffer size (even if it's
  //! within buffer's capacity).
  ASMJIT_API Error setOffset(size_t offset);

  //! Get start of the CodeBuffer of the current section.
  inline uint8_t* bufferData() const noexcept { return _bufferData; }
  //! Get end (first invalid byte) of the current section.
  inline uint8_t* bufferEnd() const noexcept { return _bufferEnd; }
  //! Get pointer in the CodeBuffer of the current section.
  inline uint8_t* bufferPtr() const noexcept { return _bufferPtr; }

  // --------------------------------------------------------------------------
  // [Label Management]
  // --------------------------------------------------------------------------

  ASMJIT_API Label newLabel() override;
  ASMJIT_API Label newNamedLabel(const char* name, size_t nameSize = Globals::kNullTerminated, uint32_t type = Label::kTypeGlobal, uint32_t parentId = 0) override;
  ASMJIT_API Error bind(const Label& label) override;

  // --------------------------------------------------------------------------
  // [Emit (Low-Level)]
  // --------------------------------------------------------------------------

  using BaseEmitter::_emit;

  ASMJIT_API Error _emit(uint32_t instId, const Operand_& o0, const Operand_& o1, const Operand_& o2, const Operand_& o3, const Operand_& o4, const Operand_& o5) override;
  ASMJIT_API Error _emitOpArray(uint32_t instId, const Operand_* operands, size_t count) override;

protected:
  #ifndef ASMJIT_DISABLE_LOGGING
  void _emitLog(
    uint32_t instId, uint32_t options, const Operand_& o0, const Operand_& o1, const Operand_& o2, const Operand_& o3,
    uint32_t relSize, uint32_t immSize, uint8_t* afterCursor);

  Error _emitFailed(
    Error err,
    uint32_t instId, uint32_t options, const Operand_& o0, const Operand_& o1, const Operand_& o2, const Operand_& o3);
  #else
  inline Error _emitFailed(
    uint32_t err,
    uint32_t instId, uint32_t options, const Operand_& o0, const Operand_& o1, const Operand_& o2, const Operand_& o3) {

    ASMJIT_UNUSED(instId);
    ASMJIT_UNUSED(options);
    ASMJIT_UNUSED(o0);
    ASMJIT_UNUSED(o1);
    ASMJIT_UNUSED(o2);
    ASMJIT_UNUSED(o3);

    resetInstOptions();
    resetInlineComment();
    return reportError(err);
  }
  #endif
public:

  // --------------------------------------------------------------------------
  // [Embed]
  // --------------------------------------------------------------------------

  ASMJIT_API Error embed(const void* data, uint32_t size) override;
  ASMJIT_API Error embedLabel(const Label& label) override;
  ASMJIT_API Error embedConstPool(const Label& label, const ConstPool& pool) override;

  // --------------------------------------------------------------------------
  // [Comment]
  // --------------------------------------------------------------------------

  ASMJIT_API Error comment(const char* data, size_t size = Globals::kNullTerminated) override;

  // --------------------------------------------------------------------------
  // [Events]
  // --------------------------------------------------------------------------

  ASMJIT_API Error onAttach(CodeHolder* code) noexcept override;
  ASMJIT_API Error onDetach(CodeHolder* code) noexcept override;

  // --------------------------------------------------------------------------
  // [Members]
  // --------------------------------------------------------------------------

  SectionEntry* _section;                //!< Current section where the assembling happens.
  uint8_t* _bufferData;                  //!< Start of the CodeBuffer of the current section.
  uint8_t* _bufferEnd;                   //!< End (first invalid byte) of the current section.
  uint8_t* _bufferPtr;                   //!< Pointer in the CodeBuffer of the current section.
  Operand_ _op4;                         //!< 5th operand data, used only temporarily.
  Operand_ _op5;                         //!< 6th operand data, used only temporarily.
};

// ============================================================================
// [asmjit::AsmBufferWriter]
// ============================================================================

// TODO: Better name, should not be here, maybe hide from public API completely?
class AsmBufferWriter {
public:
  ASMJIT_INLINE explicit AsmBufferWriter(BaseAssembler* a) noexcept
    : _cursor(a->_bufferPtr) {}

  ASMJIT_INLINE Error ensureSpace(BaseAssembler* a, size_t n) noexcept {
    size_t remainingSpace = (size_t)(a->_bufferEnd - _cursor);
    if (ASMJIT_UNLIKELY(remainingSpace < n)) {
      CodeBuffer& buffer = a->_section->_buffer;
      Error err = a->_code->growBuffer(&buffer, n);
      if (ASMJIT_UNLIKELY(err))
        return a->reportError(err);
      _cursor = a->_bufferPtr;
    }
    return kErrorOk;
  }

  ASMJIT_INLINE uint8_t* cursor() const noexcept {
    return _cursor;
  }

  ASMJIT_INLINE size_t offset(uint8_t* from) const noexcept {
    ASMJIT_ASSERT(_cursor >= from);
    return (size_t)(_cursor - from);
  }

  ASMJIT_INLINE void advance(size_t n) noexcept {
    _cursor += n;
  }

  template<typename T>
  ASMJIT_INLINE void emit8(T val) noexcept {
    typedef typename std::make_unsigned<T>::type U;
    _cursor[0] = uint8_t(U(val) & U(0xFF));
    _cursor++;
  }

  template<typename T, typename Y>
  ASMJIT_INLINE void emit8If(T val, Y cond) noexcept {
    typedef typename std::make_unsigned<T>::type U;
    ASMJIT_ASSERT(size_t(cond) <= 1u);

    _cursor[0] = uint8_t(U(val) & U(0xFF));
    _cursor += size_t(cond);
  }

  template<typename T>
  ASMJIT_INLINE void emit16uLE(T val) noexcept {
    typedef typename std::make_unsigned<T>::type U;
    Support::writeU16uLE(_cursor, uint32_t(U(val) & 0xFFFFu));
    _cursor += 2;
  }

  template<typename T>
  ASMJIT_INLINE void emit16uBE(T val) noexcept {
    typedef typename std::make_unsigned<T>::type U;
    Support::writeU16uBE(_cursor, uint32_t(U(val) & 0xFFFFu));
    _cursor += 2;
  }

  template<typename T>
  ASMJIT_INLINE void emit32uLE(T val) noexcept {
    typedef typename std::make_unsigned<T>::type U;
    Support::writeU32uLE(_cursor, uint32_t(U(val) & 0xFFFFFFFFu));
    _cursor += 4;
  }

  template<typename T>
  ASMJIT_INLINE void emit32uBE(T val) noexcept {
    typedef typename std::make_unsigned<T>::type U;
    Support::writeU32uBE(_cursor, uint32_t(U(val) & 0xFFFFFFFFu));
    _cursor += 4;
  }

  ASMJIT_INLINE void emitData(const void* data, size_t size) noexcept {
    ASMJIT_ASSERT(size != 0);
    std::memcpy(_cursor, data, size);
    _cursor += size;
  }

  ASMJIT_INLINE void emitZeros(size_t size) noexcept {
    ASMJIT_ASSERT(size != 0);
    std::memset(_cursor, 0, size);
    _cursor += size;
  }

  ASMJIT_INLINE void done(BaseAssembler* a) noexcept {
    CodeBuffer& buffer = a->_section->_buffer;
    size_t newSize = (size_t)(_cursor - a->_bufferData);
    ASMJIT_ASSERT(newSize <= buffer.capacity());

    a->_bufferPtr = _cursor;
    buffer._size = std::max(buffer._size, newSize);
  }

  uint8_t* _cursor;
};

//! \}

ASMJIT_END_NAMESPACE

// [Guard]
#endif // _ASMJIT_CORE_ASSEMBLER_H

```

`Avanguard/AsmJit/asmjit/core/build.h`:

```h
// [AsmJit]
// Complete x86/x64 JIT and Remote Assembler for C++.
//
// [License]
// ZLIB - See LICENSE.md file in the package.

// AsmJit Static Builds and Embedding
// ----------------------------------
//
// These definitions can be used to enable static library build. Embed is used
// when AsmJit's source code is embedded directly in another project, implies
// static build as well.
//
// #define ASMJIT_BUILD_EMBED        // Asmjit is embedded (implies ASMJIT_BUILD_STATIC).
// #define ASMJIT_BUILD_STATIC       // Enable static-library build.

// AsmJit Build Mode
// -----------------
//
// These definitions control the build mode and tracing support. The build mode
// should be auto-detected at compile time, but it's possible to override it in
// case that the auto-detection fails.
//
// Tracing is a feature that is never compiled by default and it's only used to
// debug AsmJit itself.
//
// #define ASMJIT_BUILD_DEBUG        // Always use debug-mode   (ASMJIT_ASSERT enabled).
// #define ASMJIT_BUILD_RELEASE      // Always use release-mode (ASMJIT_ASSERT disabled).

// AsmJit Build Backends
// ---------------------
//
// These definitions control which backends to compile. If none of these is
// defined AsmJit will use host architecture by default (for JIT code generation).
//
// #define ASMJIT_BUILD_X86          // Enable X86 targets (X86 and X86_64).
// #define ASMJIT_BUILD_ARM          // Enable ARM targets (ARM and AArch64).
// #define ASMJIT_BUILD_HOST         // Enable targets based on target arch (default).

// AsmJit Build Options
// --------------------
//
// Flags can be defined to disable standard features. These are handy especially
// when building AsmJit statically and some features are not needed or unwanted
// (like BaseCompiler).
//
// AsmJit features are enabled by default.
// #define ASMJIT_DISABLE_COMPILER   // Disable BaseCompiler (completely).
// #define ASMJIT_DISABLE_JIT        // Disable JIT memory manager and JitRuntime.
// #define ASMJIT_DISABLE_LOGGING    // Disable logging and formatting (completely).
// #define ASMJIT_DISABLE_TEXT       // Disable everything that contains text
//                                   // representation (instructions, errors, ...).
// #define ASMJIT_DISABLE_INST_API   // Disable API related to instruction database
//                                   // (validation, cpu features, rw-info, etc).

// [Guard]
#ifndef _ASMJIT_CORE_BUILD_H
#define _ASMJIT_CORE_BUILD_H

// ============================================================================
// [asmjit::Build - Globals - Version]
// ============================================================================

#define ASMJIT_LIBRARY_VERSION 0x010200 /* 1.2.0 */

// ============================================================================
// [asmjit::Build - Globals - Deprecated]
// ============================================================================

// DEPRECATED: Will be removed from v1.4+.
#if defined(ASMJIT_EMBED)
  #pragma message("'ASMJIT_EMBED' is deprecated, use 'ASMJIT_BUILD_EMBED'")
  #define ASMJIT_BUILD_EMBED
#endif

#if defined(ASMJIT_STATIC)
  #pragma message("'ASMJIT_STATIC' is deprecated, use 'ASMJIT_BUILD_STATIC'")
  #define ASMJIT_BUILD_STATIC
#endif

#if defined(ASMJIT_DISABLE_LOGGER)
  #pragma message("'ASMJIT_DISABLE_LOGGER' is deprecated, use 'ASMJIT_DISABLE_LOGGING'")
  #define ASMJIT_DISABLE_LOGGING
#endif

// ============================================================================
// [asmjit::Build - Globals - Build Mode]
// ============================================================================

// Detect ASMJIT_BUILD_DEBUG and ASMJIT_BUILD_RELEASE if not defined.
#if !defined(ASMJIT_BUILD_DEBUG) && !defined(ASMJIT_BUILD_RELEASE)
  #if !defined(NDEBUG)
    #define ASMJIT_BUILD_DEBUG
  #else
    #define ASMJIT_BUILD_RELEASE
  #endif
#endif

// Prevent compile-time errors caused by misconfiguration.
#if defined(ASMJIT_DISABLE_TEXT) && !defined(ASMJIT_DISABLE_LOGGING)
  #error "[asmjit] ASMJIT_DISABLE_TEXT requires ASMJIT_DISABLE_LOGGING to be defined."
#endif

// ============================================================================
// [asmjit::Build - Globals - Target Operating System]
// ============================================================================

#if defined(_WIN32)
  #define ASMJIT_OS_WINDOWS    1
#else
  #define ASMJIT_OS_WINDOWS    0
#endif

#if defined(__linux__) || defined(__ANDROID__)
  #define ASMJIT_OS_LINUX      1
#else
  #define ASMJIT_OS_LINUX      0
#endif

#if defined(__ANDROID__)
  #define ASMJIT_OS_ANDROID    1
#else
  #define ASMJIT_OS_ANDROID    0
#endif

#if defined(__APPLE__)
  #define ASMJIT_OS_MAC        1
#else
  #define ASMJIT_OS_MAC        0
#endif

#if defined(__FreeBSD__) || defined(__NetBSD__)    || \
    defined(__OpenBSD__) || defined(__DragonFly__) || \
    defined(__bsdi__)
  #define ASMJIT_OS_BSD        1
#else
  #define ASMJIT_OS_BSD        0
#endif

#define ASMJIT_OS_POSIX        (!ASMJIT_OS_WINDOWS)

// ============================================================================
// [asmjit::Build - Globals - Target Architecture]
// ============================================================================

#if defined(_M_X64) || defined(__amd64) || defined(__x86_64) || defined(__x86_64__)
  #define ASMJIT_ARCH_X86      64
#elif defined(_M_IX86) || defined(__i386) || defined(__i386__)
  #define ASMJIT_ARCH_X86      32
#else
  #define ASMJIT_ARCH_X86      0
#endif

#if defined(__ARM64__) || defined(__aarch64__)
  #define ASMJIT_ARCH_ARM      64
#elif (defined(_M_ARM  ) || defined(__arm    ) || defined(__thumb__ ) || \
       defined(_M_ARMT ) || defined(__arm__  ) || defined(__thumb2__))
  #define ASMJIT_ARCH_ARM      32
#else
  #define ASMJIT_ARCH_ARM      0
#endif

#if defined(_MIPS_ARCH_MIPS64) || defined(__mips64)
  #define ASMJIT_ARCH_MIPS     64
#elif defined(_MIPS_ARCH_MIPS32) || defined(_M_MRX000) || defined(__mips) || defined(__mips__)
  #define ASMJIT_ARCH_MIPS     32
#else
  #define ASMJIT_ARCH_MIPS     0
#endif

#define ASMJIT_ARCH_BITS       (ASMJIT_ARCH_X86 | ASMJIT_ARCH_ARM | ASMJIT_ARCH_MIPS)
#if ASMJIT_ARCH_BITS == 0
  #undef ASMJIT_ARCH_BITS
  #if defined (__LP64__) || defined(_LP64)
    #define ASMJIT_ARCH_BITS   64
  #else
    #define ASMJIT_ARCH_BITS   32
  #endif
#endif

#if (defined(__ARMEB__))  || \
    (defined(__MIPSEB__)) || \
    (defined(__BYTE_ORDER__) && (__BYTE_ORDER__ == __ORDER_BIG_ENDIAN__))
  #define ASMJIT_ARCH_LE       0
  #define ASMJIT_ARCH_BE       1
#else
  #define ASMJIT_ARCH_LE       1
  #define ASMJIT_ARCH_BE       0
#endif

// Build host architecture if no architecture is selected.
#if !defined(ASMJIT_BUILD_HOST) && \
    !defined(ASMJIT_BUILD_X86)  && \
    !defined(ASMJIT_BUILD_ARM)
  #define ASMJIT_BUILD_HOST
#endif

// Detect host architecture if building only for host.
#if ASMJIT_ARCH_X86 && defined(ASMJIT_BUILD_HOST) && !defined(ASMJIT_BUILD_X86)
  #define ASMJIT_BUILD_X86
#endif

#if ASMJIT_ARCH_ARM && defined(ASMJIT_BUILD_HOST) && !defined(ASMJIT_BUILD_ARM)
  #define ASMJIT_BUILD_ARM
#endif

// ============================================================================
// [asmjit::Build - Globals - C++ Compiler and Features Detection]
// ============================================================================

#define ASMJIT_CXX_CLANG       0
#define ASMJIT_CXX_INTEL       0
#define ASMJIT_CXX_GNU_ONLY    0
#define ASMJIT_CXX_MSC_ONLY    0
#define ASMJIT_CXX_MAKE_VER(MAJOR, MINOR, PATCH) ((MAJOR) * 10000000 + (MINOR) * 100000 + (PATCH))

#if defined(__INTEL_COMPILER)
  // Intel compiler pretends to be GNU or MSC, so it must be checked first.
  //   https://software.intel.com/en-us/articles/c0x-features-supported-by-intel-c-compiler
  //   https://software.intel.com/en-us/articles/c14-features-supported-by-intel-c-compiler
  //   https://software.intel.com/en-us/articles/c17-features-supported-by-intel-c-compiler
  #undef ASMJIT_CXX_INTEL
  #define ASMJIT_CXX_INTEL ASMJIT_CXX_MAKE_VER(__INTEL_COMPILER / 100, (__INTEL_COMPILER / 10) % 10, __INTEL_COMPILER % 10)
#elif defined(_MSC_VER) && defined(_MSC_FULL_VER)
  // MSC compiler:
  //   https://msdn.microsoft.com/en-us/library/hh567368.aspx
  //
  // Version List:
  //   16.00.0 == VS2010
  //   17.00.0 == VS2012
  //   18.00.0 == VS2013
  //   19.00.0 == VS2015
  //   19.10.0 == VS2017
  #undef ASMJIT_CXX_MSC_ONLY
  #if _MSC_VER == _MSC_FULL_VER / 10000
    #define ASMJIT_CXX_MSC_ONLY ASMJIT_CXX_MAKE_VER(_MSC_VER / 100, _MSC_VER % 100, _MSC_FULL_VER % 10000)
  #else
    #define ASMJIT_CXX_MSC_ONLY ASMJIT_CXX_MAKE_VER(_MSC_VER / 100, (_MSC_FULL_VER / 100000) % 100, _MSC_FULL_VER % 100000)
  #endif
#elif defined(__clang_major__) && defined(__clang_minor__) && defined(__clang_patchlevel__)
  // Clang compiler:
  #undef ASMJIT_CXX_CLANG
  #define ASMJIT_CXX_CLANG ASMJIT_CXX_MAKE_VER(__clang_major__, __clang_minor__, __clang_patchlevel__)
#elif defined(__GNUC__) && defined(__GNUC_MINOR__) && defined(__GNUC_PATCHLEVEL__)
  // GNU compiler:
  //   https://gcc.gnu.org/projects/cxx-status.html
  #undef ASMJIT_CXX_GNU_ONLY
  #define ASMJIT_CXX_GNU_ONLY ASMJIT_CXX_MAKE_VER(__GNUC__, __GNUC_MINOR__, __GNUC_PATCHLEVEL__)
#endif

// GNU [Compatibility] - GNU compiler or compatible.
#if defined(__GNUC__) && defined(__GNUC_MINOR__) && defined(__GNUC_PATCHLEVEL__)
  #define ASMJIT_CXX_GNU ASMJIT_CXX_MAKE_VER(__GNUC__, __GNUC_MINOR__, __GNUC_PATCHLEVEL__)
#else
  #define ASMJIT_CXX_GNU ASMJIT_CXX_GNU_ONLY
#endif

// MSC [Compatibility] - MSC compiler or compatible.
#if !ASMJIT_CXX_MSC_ONLY && defined(_MSC_VER)
  #define ASMJIT_CXX_MSC ASMJIT_CXX_MAKE_VER(_MSC_VER / 100, _MSC_VER % 100, 0)
#else
  #define ASMJIT_CXX_MSC ASMJIT_CXX_MSC_ONLY
#endif

// Compiler features detection macros.
#if ASMJIT_CXX_CLANG && defined(__has_builtin)
  #define ASMJIT_CXX_HAS_BUILTIN(NAME, CHECK) (__has_builtin(NAME))
#else
  #define ASMJIT_CXX_HAS_BUILTIN(NAME, CHECK) (!(!(CHECK)))
#endif

#if ASMJIT_CXX_CLANG && defined(__has_extension)
  #define ASMJIT_CXX_HAS_FEATURE(NAME, CHECK) (__has_extension(NAME))
#elif ASMJIT_CXX_CLANG && defined(__has_feature)
  #define ASMJIT_CXX_HAS_FEATURE(NAME, CHECK) (__has_feature(NAME))
#else
  #define ASMJIT_CXX_HAS_FEATURE(NAME, CHECK) (!(!(CHECK)))
#endif

#if ASMJIT_CXX_CLANG && defined(__has_attribute)
  #define ASMJIT_CXX_HAS_ATTRIBUTE(NAME, CHECK) (__has_attribute(NAME))
#else
  #define ASMJIT_CXX_HAS_ATTRIBUTE(NAME, CHECK) (!(!(CHECK)))
#endif

#if ASMJIT_CXX_CLANG && defined(__has_cpp_attribute)
  #define ASMJIT_CXX_HAS_CPP_ATTRIBUTE(NAME, CHECK) (__has_cpp_attribute(NAME))
#else
  #define ASMJIT_CXX_HAS_CPP_ATTRIBUTE(NAME, CHECK) (!(!(CHECK)))
#endif

// Compiler features by vendor.
#if defined(ASMJIT_CXX_MSC_ONLY) && !defined(_NATIVE_WCHAR_T_DEFINED)
  #define ASMJIT_CXX_HAS_NATIVE_WCHAR_T 0
#else
  #define ASMJIT_CXX_HAS_NATIVE_WCHAR_T 1
#endif

#define ASMJIT_CXX_HAS_UNICODE_LITERALS \
  ASMJIT_CXX_HAS_FEATURE(cxx_unicode_literals, ( \
                        (ASMJIT_CXX_INTEL    >= ASMJIT_CXX_MAKE_VER(14, 0, 0)) || \
                        (ASMJIT_CXX_MSC_ONLY >= ASMJIT_CXX_MAKE_VER(19, 0, 0)) || \
                        (ASMJIT_CXX_GNU_ONLY >= ASMJIT_CXX_MAKE_VER(4 , 5, 0) && __cplusplus >= 201103L) ))

// SEVERE: VS2015 handles constexpr's incorrectly in case a struct contains a
//         union. There is no workaround known other than rewriting the whole
//         code.
//         VS2017 has a similar bug, but it can be workarounded.
#if ASMJIT_CXX_MSC_ONLY && ASMJIT_CXX_MSC_ONLY < ASMJIT_CXX_MAKE_VER(19, 10, 0)
  #error "[asmjit] At least VS2017 is required due to a severe bug in VS2015's 'constexpr', please upgrade your compiler."
#endif

// ============================================================================
// [asmjit::Build - Globals - API Decorators & Language Extensions]
// ============================================================================

// ASMJIT_BUILD_EMBED implies ASMJIT_BUILD_STATIC.
#if defined(ASMJIT_BUILD_EMBED) && !defined(ASMJIT_BUILD_STATIC)
  #define ASMJIT_BUILD_STATIC
#endif

// API (Export / Import).
#if !defined(ASMJIT_API) && !defined(ASMJIT_BUILD_STATIC)
  #if ASMJIT_OS_WINDOWS && (ASMJIT_CXX_MSC || defined(__MINGW32__))
    #if defined(ASMJIT_EXPORTS)
      #define ASMJIT_API __declspec(dllexport)
    #else
      #define ASMJIT_API __declspec(dllimport)
    #endif
  #elif ASMJIT_OS_WINDOWS && ASMJIT_CXX_GNU
    #if defined(ASMJIT_EXPORTS)
      #define ASMJIT_API __attribute__((__dllexport__))
    #else
      #define ASMJIT_API __attribute__((__dllimport__))
    #endif
  #elif ASMJIT_CXX_GNU >= ASMJIT_CXX_MAKE_VER(4, 0, 0)
    #define ASMJIT_API __attribute__((__visibility__("default")))
  #endif
#endif

#if !defined(ASMJIT_API)
  #define ASMJIT_API
#endif

#if !defined(ASMJIT_VARAPI)
  #define ASMJIT_VARAPI extern ASMJIT_API
#endif

// This is basically a workaround. When using MSVC and marking class as DLL
// export everything gets exported, which is unwanted in most projects. MSVC
// automatically exports typeinfo and vtable if at least one symbol of the
// class is exported. However, GCC has some strange behavior that even if
// one or more symbol is exported it doesn't export typeinfo unless the
// class itself is decorated with "visibility(default)" (i.e. ASMJIT_API).
#if ASMJIT_CXX_GNU && !ASMJIT_OS_WINDOWS
  #define ASMJIT_VIRTAPI ASMJIT_API
#else
  #define ASMJIT_VIRTAPI
#endif

// Function attributes.
#if (ASMJIT_CXX_GNU >= ASMJIT_CXX_MAKE_VER(4, 4, 0) && !defined(__MINGW32__))
  #define ASMJIT_INLINE inline __attribute__((__always_inline__))
#elif ASMJIT_CXX_MSC
  #define ASMJIT_INLINE __forceinline
#else
  #define ASMJIT_INLINE inline
#endif

#if ASMJIT_CXX_GNU
  #define ASMJIT_NOINLINE __attribute__((__noinline__))
  #define ASMJIT_NORETURN __attribute__((__noreturn__))
#elif ASMJIT_CXX_MSC
  #define ASMJIT_NOINLINE __declspec(noinline)
  #define ASMJIT_NORETURN __declspec(noreturn)
#else
  #define ASMJIT_NOINLINE
  #define ASMJIT_NORETURN
#endif

// Calling conventions.
#if ASMJIT_ARCH_X86 == 32 && ASMJIT_CXX_GNU
  #define ASMJIT_CDECL __attribute__((__cdecl__))
  #define ASMJIT_STDCALL __attribute__((__stdcall__))
  #define ASMJIT_FASTCALL __attribute__((__fastcall__))
  #define ASMJIT_REGPARM(N) __attribute__((__regparm__(N)))
#elif ASMJIT_ARCH_X86 == 32 && ASMJIT_CXX_MSC
  #define ASMJIT_CDECL __cdecl
  #define ASMJIT_STDCALL __stdcall
  #define ASMJIT_FASTCALL __fastcall
  #define ASMJIT_REGPARM(N)
#else
  #define ASMJIT_CDECL
  #define ASMJIT_STDCALL
  #define ASMJIT_FASTCALL
  #define ASMJIT_REGPARM(N)
#endif

// Type alignment (not allowed by C++11 'alignas' keyword).
#if ASMJIT_CXX_GNU
  #define ASMJIT_ALIGN_TYPE(TYPE, N) __attribute__((__aligned__(N))) TYPE
#elif ASMJIT_CXX_MSC
  #define ASMJIT_ALIGN_TYPE(TYPE, N) __declspec(align(N)) TYPE
#else
  #define ASMJIT_ALIGN_TYPE(TYPE, N) TYPE
#endif

// Annotations.
#if ASMJIT_CXX_HAS_BUILTIN(__builtin_expect, ASMJIT_CXX_GNU >= ASMJIT_CXX_MAKE_VER(3, 0, 0))
  #define ASMJIT_LIKELY(...) __builtin_expect(!!(__VA_ARGS__), 1)
  #define ASMJIT_UNLIKELY(...) __builtin_expect(!!(__VA_ARGS__), 0)
#else
  #define ASMJIT_LIKELY(...) (__VA_ARGS__)
  #define ASMJIT_UNLIKELY(...) (__VA_ARGS__)
#endif

#if ASMJIT_CXX_CLANG && __cplusplus >= 201103L
  #define ASMJIT_FALLTHROUGH [[clang::fallthrough]]
#elif ASMJIT_CXX_GNU_ONLY >= ASMJIT_CXX_MAKE_VER(7, 0, 0)
  #define ASMJIT_FALLTHROUGH __attribute__((__fallthrough__))
#else
  #define ASMJIT_FALLTHROUGH ((void)0) /* fallthrough */
#endif

#define ASMJIT_UNUSED(X) (void)(X)

// Utilities.
#define ASMJIT_OFFSET_OF(STRUCT, MEMBER) ((int)(intptr_t)((const char*)&((const STRUCT*)0x1)->MEMBER) - 1)
#define ASMJIT_ARRAY_SIZE(X) uint32_t(sizeof(X) / sizeof(X[0]))

#if ASMJIT_CXX_HAS_ATTRIBUTE(attribute_deprecated_with_message, ASMJIT_CXX_GNU >= ASMJIT_CXX_MAKE_VER(4, 5, 0))
  #define ASMJIT_DEPRECATED(DECL, MESSAGE) DECL __attribute__((__deprecated__(MESSAGE)))
#elif ASMJIT_MSC
  #define ASMJIT_DEPRECATED(DECL, MESSAGE) __declspec(deprecated(MESSAGE)) DECL
#else
  #define ASMJIT_DEPRECATED(DECL, MESSAGE) DECL
#endif

#if ASMJIT_CXX_HAS_ATTRIBUTE(no_sanitize, 0)
  #define ASMJIT_CXX_NO_SANITIZE_UNDEFINED __attribute__((__no_sanitize__("undefined")))
#elif ASMJIT_CXX_GNU_ONLY >= ASMJIT_CXX_MAKE_VER(4, 9, 0)
  #define ASMJIT_CXX_NO_SANITIZE_UNDEFINED __attribute__((__no_sanitize_undefined__))
#else
  #define ASMJIT_CXX_NO_SANITIZE_UNDEFINED
#endif

// ============================================================================
// [asmjit::Build - Globals - Begin-Namespace / End-Namespace]
// ============================================================================

#if ASMJIT_CXX_CLANG
  #define ASMJIT_BEGIN_NAMESPACE                                               \
    namespace asmjit {                                                         \
      _Pragma("clang diagnostic push")                                         \
      _Pragma("clang diagnostic ignored \"-Wconstant-logical-operand\"")       \
      _Pragma("clang diagnostic ignored \"-Wunnamed-type-template-args\"")
  #define ASMJIT_END_NAMESPACE                                                 \
      _Pragma("clang diagnostic pop")                                          \
    }
#endif

#if ASMJIT_CXX_GNU_ONLY
  // Nothing atm.
#endif

#if ASMJIT_CXX_MSC_ONLY
  #define ASMJIT_BEGIN_NAMESPACE                                               \
    namespace asmjit {                                                         \
      __pragma(warning(push))                                                  \
      __pragma(warning(disable: 4127)) /* conditional expression is constant*/ \
      __pragma(warning(disable: 4201)) /* nameless struct/union             */
  #define ASMJIT_END_NAMESPACE                                                 \
      __pragma(warning(pop))                                                   \
    }
#endif

#ifndef ASMJIT_BEGIN_NAMESPACE
  #define ASMJIT_BEGIN_NAMESPACE namespace asmjit {
  #define ASMJIT_END_NAMESPACE }
#endif

#define ASMJIT_BEGIN_SUB_NAMESPACE(NAMESPACE)                                 \
  ASMJIT_BEGIN_NAMESPACE                                                      \
  namespace NAMESPACE {

#define ASMJIT_END_SUB_NAMESPACE                                              \
  }                                                                           \
  ASMJIT_END_NAMESPACE

// ============================================================================
// [asmjit::Build - Globals - Utilities]
// ============================================================================

#define ASMJIT_NONCOPYABLE(...)                                               \
  private:                                                                    \
    __VA_ARGS__(const __VA_ARGS__& other) = delete;                           \
    __VA_ARGS__& operator=(const __VA_ARGS__& other) = delete;                \
  public:

#define ASMJIT_NONCONSTRUCTIBLE(...)                                          \
  private:                                                                    \
    __VA_ARGS__() = delete;                                                   \
    __VA_ARGS__(const __VA_ARGS__& other) = delete;                           \
    __VA_ARGS__& operator=(const __VA_ARGS__& other) = delete;                \
  public:

// ============================================================================
// [asmjit::Build - Globals - Build-Only]
// ============================================================================

// Internal macros that are only used when building AsmJit itself.
#ifdef ASMJIT_EXPORTS
  #if !defined(ASMJIT_BUILD_DEBUG) && ASMJIT_CXX_HAS_ATTRIBUTE(__optimize__, ASMJIT_CXX_GNU >= ASMJIT_CXX_MAKE_VER(4, 4, 0))
    #define ASMJIT_FAVOR_SIZE  __attribute__((__optimize__("Os")))
    #define ASMJIT_FAVOR_SPEED __attribute__((__optimize__("O3")))
  #else
    #define ASMJIT_FAVOR_SIZE
    #define ASMJIT_FAVOR_SPEED
  #endif

  // Only turn-off these warnings when building asmjit itself.
  #ifdef _MSC_VER
    #ifndef _CRT_SECURE_NO_DEPRECATE
      #define _CRT_SECURE_NO_DEPRECATE
    #endif
    #ifndef _CRT_SECURE_NO_WARNINGS
      #define _CRT_SECURE_NO_WARNINGS
    #endif
  #endif
#endif

// ============================================================================
// [asmjit::Build - Globals - Dependencies]
// ============================================================================

// We really want std-types as globals.
#include <stddef.h>
#include <stdint.h>
#include <stdlib.h>

#include <algorithm>
#include <cstdarg>
#include <cstdio>
#include <cstring>
#include <cstdlib>
#include <limits>
#include <new>
#include <type_traits>
#include <utility>

#if ASMJIT_OS_WINDOWS
  #ifndef WIN32_LEAN_AND_MEAN
    #define WIN32_LEAN_AND_MEAN
    #define ASMJIT_UNDEF_WIN32_LEAN_AND_MEAN
  #endif
  #ifndef NOMINMAX
    #define NOMINMAX
    #define ASMJIT_UNDEF_NOMINMAX
  #endif
  #include <windows.h>
  #ifdef ASMJIT_UNDEF_NOMINMAX
    #undef NOMINMAX
    #undef ASMJIT_UNDEF_NOMINMAX
  #endif
  #ifdef ASMJIT_UNDEF_WIN32_LEAN_AND_MEAN
    #undef WIN32_LEAN_AND_MEAN
    #undef ASMJIT_UNDEF_WIN32_LEAN_AND_MEAN
 #endif
#endif

#if ASMJIT_OS_POSIX
  #include <pthread.h>
#endif

// ============================================================================
// [asmjit::Build - Globals - Unit Testing Boilerplate]
// ============================================================================

// IDE: Make sure '#ifdef'ed unit tests are properly highlighted.
#if defined(__INTELLISENSE__) && !defined(ASMJIT_BUILD_TEST)
  #define ASMJIT_BUILD_TEST
#endif

// IDE: Make sure '#ifdef'ed unit tests are not disabled by IDE.
#if defined(ASMJIT_BUILD_TEST)
  #include "../../../test/broken.h"
#endif

// [Guard]
#endif // _ASMJIT_CORE_BUILD_H

```

`Avanguard/AsmJit/asmjit/core/builder.h`:

```h
// [AsmJit]
// Complete x86/x64 JIT and Remote Assembler for C++.
//
// [License]
// ZLIB - See LICENSE.md file in the package.

// [Guard]
#ifndef _ASMJIT_CORE_BUILDER_H
#define _ASMJIT_CORE_BUILDER_H

#include "../core/build.h"
#ifndef ASMJIT_DISABLE_BUILDER

// [Dependencies]
#include "../core/assembler.h"
#include "../core/codeholder.h"
#include "../core/constpool.h"
#include "../core/inst.h"
#include "../core/operand.h"
#include "../core/stringbuilder.h"
#include "../core/support.h"
#include "../core/zone.h"
#include "../core/zonevector.h"

ASMJIT_BEGIN_NAMESPACE

// ============================================================================
// [Forward Declarations]
// ============================================================================

class BaseNode;
class InstNode;
class LabelNode;
class AlignNode;
class EmbedDataNode;
class LabelDataNode;
class ConstPoolNode;
class CommentNode;
class SentinelNode;
class Pass;

//! \addtogroup asmjit_core_api
//! \{

// ============================================================================
// [asmjit::BaseBuilder]
// ============================================================================

class ASMJIT_VIRTAPI BaseBuilder : public BaseEmitter {
public:
  ASMJIT_NONCOPYABLE(BaseBuilder)
  typedef BaseEmitter Base;

  // --------------------------------------------------------------------------
  // [Construction / Destruction]
  // --------------------------------------------------------------------------

  //! Create a new `BaseBuilder` instance.
  ASMJIT_API BaseBuilder() noexcept;
  //! Destroy the `BaseBuilder` instance.
  ASMJIT_API virtual ~BaseBuilder() noexcept;

  // --------------------------------------------------------------------------
  // [Node Management]
  // --------------------------------------------------------------------------

  //! Get the first node.
  inline BaseNode* firstNode() const noexcept { return _firstNode; }
  //! Get the last node.
  inline BaseNode* lastNode() const noexcept { return _lastNode; }

  //! \internal
  template<typename T>
  inline T* newNodeT() noexcept {
    return _allocator.newT<T>(this);
  }

  //! \internal
  template<typename T, typename... ArgsT>
  inline T* newNodeT(ArgsT&&... args) noexcept {
    return _allocator.newT<T>(this, std::forward<ArgsT>(args)...);
  }

  //! Create a new `LabelNode`.
  ASMJIT_API LabelNode* newLabelNode() noexcept;
  //! Create a new `AlignNode`.
  ASMJIT_API AlignNode* newAlignNode(uint32_t alignMode, uint32_t alignment) noexcept;
  //! Create a new `EmbedDataNode`.
  ASMJIT_API EmbedDataNode* newEmbedDataNode(const void* data, uint32_t size) noexcept;
  //! Create a new `ConstPoolNode`.
  ASMJIT_API ConstPoolNode* newConstPoolNode() noexcept;
  //! Create a new `CommentNode`.
  ASMJIT_API CommentNode* newCommentNode(const char* data, size_t size) noexcept;

  ASMJIT_API InstNode* newInstNode(uint32_t instId, uint32_t instOptions, const Operand_& o0) noexcept;
  ASMJIT_API InstNode* newInstNode(uint32_t instId, uint32_t instOptions, const Operand_& o0, const Operand_& o1) noexcept;
  ASMJIT_API InstNode* newInstNode(uint32_t instId, uint32_t instOptions, const Operand_& o0, const Operand_& o1, const Operand_& o2) noexcept;
  ASMJIT_API InstNode* newInstNode(uint32_t instId, uint32_t instOptions, const Operand_& o0, const Operand_& o1, const Operand_& o2, const Operand_& o3) noexcept;
  ASMJIT_API InstNode* newInstNodeRaw(uint32_t instId, uint32_t instOptions, uint32_t opCount) noexcept;

  //! Add `node` after the current and set current to `node`.
  ASMJIT_API BaseNode* addNode(BaseNode* node) noexcept;
  //! Insert the given `node` after `ref`.
  ASMJIT_API BaseNode* addAfter(BaseNode* node, BaseNode* ref) noexcept;
  //! Insert the given `node` before `ref`.
  ASMJIT_API BaseNode* addBefore(BaseNode* node, BaseNode* ref) noexcept;
  //! Remove the given `node`.
  ASMJIT_API BaseNode* removeNode(BaseNode* node) noexcept;
  //! Remove multiple nodes.
  ASMJIT_API void removeNodes(BaseNode* first, BaseNode* last) noexcept;

  //! Get current node.
  //!
  //! \note If this method returns null it means that nothing has been
  //! emitted yet.
  inline BaseNode* cursor() const noexcept { return _cursor; }
  //! Set the current node without returning the previous node.
  inline void _setCursor(BaseNode* node) noexcept { _cursor = node; }
  //! Set the current node to `node` and return the previous one.
  ASMJIT_API BaseNode* setCursor(BaseNode* node) noexcept;

  // --------------------------------------------------------------------------
  // [Label Management]
  // --------------------------------------------------------------------------

  //! Get a vector of LabelNode nodes.
  //!
  //! NOTE: If a label of some index is not associated with `BaseBuilder` it
  //! would be null, so always check for nulls if you iterate over the vector.
  inline const ZoneVector<LabelNode*>& labelNodes() const noexcept { return _labelNodes; }

  //! Get `LabelNode` by `id`.
  ASMJIT_API Error labelNodeOf(LabelNode** pOut, uint32_t id) noexcept;
  //! Get `LabelNode` by `label`.
  inline Error labelNodeOf(LabelNode** pOut, const Label& label) noexcept { return labelNodeOf(pOut, label.id()); }

  //! \internal
  ASMJIT_API Error registerLabelNode(LabelNode* node) noexcept;

  ASMJIT_API Label newLabel() override;
  ASMJIT_API Label newNamedLabel(
    const char* name,
    size_t nameSize = Globals::kNullTerminated,
    uint32_t type = Label::kTypeGlobal,
    uint32_t parentId = 0) override;
  ASMJIT_API Error bind(const Label& label) override;

  // --------------------------------------------------------------------------
  // [Pass Management]
  // --------------------------------------------------------------------------

  //! Get a vector of Pass objects that will be executed by `runPasses()`.
  inline const ZoneVector<Pass*>& passes() const noexcept { return _passes; }

  //! Like `new(std::nothrow) T(...)`, but allocated by `Zone`.
  template<typename T>
  inline T* newPassT() noexcept { return _codeZone.newT<T>(); }

  //! Like `new(std::nothrow) T(...)`, but allocated by `Zone`.
  template<typename T, typename... ArgsT>
  inline T* newPassT(ArgsT&&... args) noexcept { return _codeZone.newT<T>(std::forward<ArgsT>(args)...); }

  template<typename T>
  inline Error addPassT() noexcept { return addPass(newPassT<T>()); }

  template<typename T, typename... ArgsT>
  inline Error addPassT(ArgsT&&... args) noexcept { return addPass(newPassT<T, ArgsT...>(std::forward<ArgsT>(args)...)); }

  //! Get a `Pass` by name.
  ASMJIT_API Pass* passByName(const char* name) const noexcept;
  //! Add `pass` to the list of passes.
  ASMJIT_API Error addPass(Pass* pass) noexcept;
  //! Remove `pass` from the list of passes and delete it.
  ASMJIT_API Error deletePass(Pass* pass) noexcept;

  //! Run all passes in order.
  ASMJIT_API Error runPasses();

  // --------------------------------------------------------------------------
  // [Emit]
  // --------------------------------------------------------------------------

  ASMJIT_API Error _emit(uint32_t instId, const Operand_& o0, const Operand_& o1, const Operand_& o2, const Operand_& o3) override;
  ASMJIT_API Error _emit(uint32_t instId, const Operand_& o0, const Operand_& o1, const Operand_& o2, const Operand_& o3, const Operand_& o4, const Operand_& o5) override;

  // --------------------------------------------------------------------------
  // [Align]
  // --------------------------------------------------------------------------

  ASMJIT_API Error align(uint32_t alignMode, uint32_t alignment) override;

  // --------------------------------------------------------------------------
  // [Embed]
  // --------------------------------------------------------------------------

  ASMJIT_API Error embed(const void* data, uint32_t size) override;
  ASMJIT_API Error embedLabel(const Label& label) override;
  ASMJIT_API Error embedConstPool(const Label& label, const ConstPool& pool) override;

  // --------------------------------------------------------------------------
  // [Comment]
  // --------------------------------------------------------------------------

  ASMJIT_API Error comment(const char* data, size_t size = Globals::kNullTerminated) override;

  // --------------------------------------------------------------------------
  // [Serialize]
  // --------------------------------------------------------------------------

  //! Serialize everything the `BaseBuilder` or `BaseCompiler` contains to
  //! another `BaseEmitter`, which would usually be `BaseAssembler`.
  ASMJIT_API Error serialize(BaseEmitter* dst);

  // --------------------------------------------------------------------------
  // [Logging]
  // --------------------------------------------------------------------------

  #ifndef ASMJIT_DISABLE_LOGGING
  ASMJIT_API Error dump(StringBuilder& sb, uint32_t flags = 0) const noexcept;
  #endif

  // --------------------------------------------------------------------------
  // [Events]
  // --------------------------------------------------------------------------

  ASMJIT_API Error onAttach(CodeHolder* code) noexcept override;
  ASMJIT_API Error onDetach(CodeHolder* code) noexcept override;

  // --------------------------------------------------------------------------
  // [Members]
  // --------------------------------------------------------------------------

  Zone _codeZone;                        //!< Base zone used to allocate nodes and `Pass`.
  Zone _dataZone;                        //!< Data zone used to allocate data and names.
  Zone _passZone;                        //!< Pass zone, passed to `Pass::run()`.
  ZoneAllocator _allocator;              //!< Allocator that uses `_codeZone`.

  ZoneVector<Pass*> _passes;             //!< Array of `Pass` objects.
  ZoneVector<LabelNode*> _labelNodes;    //!< Maps label indexes to `LabelNode` nodes.

  BaseNode* _firstNode;                  //!< First node of the current section.
  BaseNode* _lastNode;                   //!< Last node of the current section.
  BaseNode* _cursor;                     //!< Current node (cursor).

  uint32_t _nodeFlags;                   //!< Flags assigned to each new node.
};

// ============================================================================
// [asmjit::BaseNode]
// ============================================================================

//! Base node.
//!
//! Every node represents a building-block used by `BaseBuilder`. It can be
//! instruction, data, label, comment, directive, or any other high-level
//! representation that can be transformed to the building blocks mentioned.
//! Every class that inherits `BaseBuilder` can define its own nodes that it
//! can lower to basic nodes.
class BaseNode {
public:
  ASMJIT_NONCOPYABLE(BaseNode)

  //! Type of link, used to index `_link[2]` data.
  enum LinkType : uint32_t {
    kLinkPrev       = 0,                 //!< Previous node in a double-linked list.
    kLinkNext       = 1,                 //!< Next node in a double-linked list.
    kLinkCount      = 2                  //!< Count of node links (must be 2 as it's a double-linked list)
  };

  //! Type of `BaseNode`.
  enum NodeType : uint32_t {
    kNodeNone       = 0,                 //!< Invalid node (internal, don't use).

    // [BaseBuilder]
    kNodeInst       = 1,                 //!< Node is `InstNode` or `InstExNode`.
    kNodeLabel      = 2,                 //!< Node is `LabelNode`.
    kNodeAlign      = 3,                 //!< Node is `AlignNode`.
    kNodeEmbedData  = 4,                 //!< Node is `EmbedDataNode`.
    kNodeLabelData  = 5,                 //!< Node is `LabelDataNode`.
    kNodeConstPool  = 6,                 //!< Node is `ConstPoolNode`.
    kNodeComment    = 7,                 //!< Node is `CommentNode`.
    kNodeSentinel   = 8,                 //!< Node is `SentinelNode`.

    // [BaseCompiler]
    kNodeFunc       = 16,                //!< Node is `FuncNode`     (acts as LabelNode).
    kNodeFuncRet    = 17,                //!< Node is `FuncRetNode`  (acts as BaseNode).
    kNodeFuncCall   = 18,                //!< Node is `FuncCallNode` (acts as InstNode).

    // [UserDefined]
    kNodeUser       = 32                 //!< First id of a user-defined node.
  };

  //! Node flags, specify what the node is and/or does.
  enum Flags : uint32_t {
    kFlagIsCode          = 0x01u,        //!< Node is code that can be executed (instruction, label, align, etc...).
    kFlagIsData          = 0x02u,        //!< Node is data that cannot be executed (data, const-pool, etc...).
    kFlagIsInformative   = 0x04u,        //!< Node is informative, can be removed and ignored.
    kFlagIsRemovable     = 0x08u,        //!< Node can be safely removed if unreachable.
    kFlagHasNoEffect     = 0x20u,        //!< Node does nothing when executed (label, align, explicit nop).

    kFlagActsAsInst      = 0x40u,        //!< Node is an instruction or acts as it.
    kFlagActsAsLabel     = 0x80u         //!< Node is a label or acts as it.
  };

  // --------------------------------------------------------------------------
  // [Construction / Destruction]
  // --------------------------------------------------------------------------

  //! Create a new `BaseNode` - always use `BaseBuilder` to allocate nodes.
  ASMJIT_INLINE BaseNode(BaseBuilder* cb, uint32_t type, uint32_t flags = 0) noexcept {
    _link[kLinkPrev] = nullptr;
    _link[kLinkNext] = nullptr;
    _any._nodeType = uint8_t(type);
    _any._nodeFlags = uint8_t(flags | cb->_nodeFlags);
    _any._reserved0 = 0;
    _any._reserved1 = 0;
    _position = 0;
    _passData = nullptr;
    _inlineComment = nullptr;
  }

  // --------------------------------------------------------------------------
  // [Accessors]
  // --------------------------------------------------------------------------

  inline BaseNode* link(size_t where) const noexcept {
    ASMJIT_ASSERT(where < kLinkCount);
    return _link[where];
  }

  //! Get previous node.
  inline BaseNode* prev() const noexcept { return _link[kLinkPrev]; }
  //! Get next node.
  inline BaseNode* next() const noexcept { return _link[kLinkNext]; }

  //! Set previous node (internal, use public BaseBuilder API to manage nodes).
  inline void _setPrev(BaseNode* node) noexcept { _link[kLinkPrev] = node; }
  //! Set next node (internal, use public BaseBuilder API to do manage nodes).
  inline void _setNext(BaseNode* node) noexcept { _link[kLinkNext] = node; }

  //! Get the node type, see `NodeType`.
  inline uint32_t type() const noexcept { return _any._nodeType; }
  //! Set the node type, see `NodeType` (internal).
  inline void setType(uint32_t type) noexcept { _any._nodeType = uint8_t(type); }

  inline bool isInst() const noexcept { return hasFlag(kFlagActsAsInst); }
  inline bool isLabel() const noexcept { return hasFlag(kFlagActsAsLabel); }
  inline bool isAlign() const noexcept { return type() == kNodeAlign; }
  inline bool isEmbedData() const noexcept { return type() == kNodeEmbedData; }
  inline bool isLabelData() const noexcept { return type() == kNodeLabelData; }
  inline bool isConstPool() const noexcept { return type() == kNodeConstPool; }
  inline bool isComment() const noexcept { return type() == kNodeComment; }
  inline bool isSentinel() const noexcept { return type() == kNodeSentinel; }

  inline bool isFunc() const noexcept { return type() == kNodeFunc; }
  inline bool isFuncRet() const noexcept { return type() == kNodeFuncRet; }
  inline bool isFuncCall() const noexcept { return type() == kNodeFuncCall; }

  //! Get the node flags.
  inline uint32_t flags() const noexcept { return _any._nodeFlags; }
  //! Get whether the instruction has flag `flag`.
  inline bool hasFlag(uint32_t flag) const noexcept { return (uint32_t(_any._nodeFlags) & flag) != 0; }
  //! Set node flags to `flags`.
  inline void setFlags(uint32_t flags) noexcept { _any._nodeFlags = uint8_t(flags); }
  //! Add instruction `flags`.
  inline void addFlags(uint32_t flags) noexcept { _any._nodeFlags = uint8_t(_any._nodeFlags | flags); }
  //! Clear instruction `flags`.
  inline void clearFlags(uint32_t flags) noexcept { _any._nodeFlags = uint8_t(_any._nodeFlags & (flags ^ 0xFF)); }

  //! Get whether the node is code that can be executed.
  inline bool isCode() const noexcept { return hasFlag(kFlagIsCode); }
  //! Get whether the node is data that cannot be executed.
  inline bool isData() const noexcept { return hasFlag(kFlagIsData); }
  //! Get whether the node is informative only (is never encoded like comment, etc...).
  inline bool isInformative() const noexcept { return hasFlag(kFlagIsInformative); }
  //! Get whether the node is removable if it's in an unreachable code block.
  inline bool isRemovable() const noexcept { return hasFlag(kFlagIsRemovable); }

  //! The node has no effect when executed (label, .align, nop, ...).
  inline bool hasNoEffect() const noexcept { return hasFlag(kFlagHasNoEffect); }

  //! Get whether the node has a position.
  inline bool hasPosition() const noexcept { return _position != 0; }
  //! Get node position.
  inline uint32_t position() const noexcept { return _position; }
  //! Set node position.
  inline void setPosition(uint32_t position) noexcept { _position = position; }

  //! Get whether the node has associated work-data.
  inline bool hasPassData() const noexcept { return _passData != nullptr; }
  //! Get work-data - data used during processing & transformations.
  template<typename T>
  inline T* passData() const noexcept { return (T*)_passData; }
  //! Set work-data to `data`.
  template<typename T>
  inline void setPassData(T* data) noexcept { _passData = (void*)data; }
  //! Reset work-data to null.
  inline void resetPassData() noexcept { _passData = nullptr; }

  //! Get whether the node has an inline comment.
  inline bool hasInlineComment() const noexcept { return _inlineComment != nullptr; }
  //! Get an inline comment string.
  inline const char* inlineComment() const noexcept { return _inlineComment; }
  //! Set an inline comment string to `s`.
  inline void setInlineComment(const char* s) noexcept { _inlineComment = s; }
  //! Set an inline comment string to null.
  inline void resetInlineComment() noexcept { _inlineComment = nullptr; }

  //! Cast this node to `T*`.
  template<typename T>
  inline T* as() noexcept { return static_cast<T*>(this); }
  //! Cast this node to `const T*`.
  template<typename T>
  inline const T* as() const noexcept { return static_cast<const T*>(this); }

  // --------------------------------------------------------------------------
  // [Members]
  // --------------------------------------------------------------------------

  BaseNode* _link[2];                    //!< Links (previous and next nodes).

  struct AnyData {
    uint8_t _nodeType;                   //!< Node type, see `NodeType`.
    uint8_t _nodeFlags;                  //!< Node flags.
    uint8_t _reserved0;
    uint8_t _reserved1;
  };

  struct InstData {
    uint8_t _nodeType;                   //!< Node type, see `NodeType`.
    uint8_t _nodeFlags;                  //!< Node flags.
    uint8_t _opCount;                    //!< Number of operands.
    uint8_t _opCapacity;                 //!< Maximum number of operands (capacity).
  };

  struct SentinelData {
    uint8_t _nodeType;                   //!< Node type, see `NodeType`.
    uint8_t _nodeFlags;                  //!< Node flags.
    uint8_t _sentinelType;               //!< Sentinel type.
    uint8_t _reserved0;
  };

  union {
    AnyData _any;
    InstData _inst;
    SentinelData _sentinel;
  };

  uint32_t _position;                    //!< Node position in code (should be unique).
  void* _passData;                       //!< Data used exclusively by the current `Pass`.
  const char* _inlineComment;            //!< Inline comment or null if not used.
};

// ============================================================================
// [asmjit::InstNode]
// ============================================================================

//! Instruction node.
//!
//! Wraps an instruction with its options and operands.
class InstNode : public BaseNode {
public:
  ASMJIT_NONCOPYABLE(InstNode)

  enum : uint32_t {
    //! Count of embedded operands per `InstNode` that are always allocated as
    //! a part of the instruction. Minimum embedded operands is 4, but in 32-bit
    //! more pointers are smaller and we can embed 5. The rest (up to 6 operands)
    //! is always stored in `InstExNode`.
    kBaseOpCapacity = uint32_t((128 - sizeof(BaseNode) - sizeof(BaseInst)) / sizeof(Operand_))
  };

  static inline uint32_t capacityOfOpCount(uint32_t opCount) noexcept {
    return opCount <= kBaseOpCapacity ? kBaseOpCapacity : Globals::kMaxOpCount;
  }

  static inline size_t nodeSizeOfOpCapacity(uint32_t opCapacity) noexcept {
    size_t base = sizeof(InstNode) - kBaseOpCapacity * sizeof(Operand);
    return base + opCapacity * sizeof(Operand);
  }

  // --------------------------------------------------------------------------
  // [Construction / Destruction]
  // --------------------------------------------------------------------------

  //! Create a new `InstNode` instance.
  ASMJIT_INLINE InstNode(BaseBuilder* cb, uint32_t instId, uint32_t options, uint32_t opCount, uint32_t opCapacity = kBaseOpCapacity) noexcept
    : BaseNode(cb, kNodeInst, kFlagIsCode | kFlagIsRemovable | kFlagActsAsInst),
      _baseInst(instId, options) {
    _inst._opCapacity = uint8_t(opCapacity);
    _inst._opCount = uint8_t(opCount);
  }

  // --------------------------------------------------------------------------
  // [Init]
  // --------------------------------------------------------------------------

  //! Reset all built-in operands, including `extraReg`.
  inline void _resetOps() noexcept {
    _baseInst.resetExtraReg();
    for (uint32_t i = 0, count = opCapacity(); i < count; i++)
      _opArray[i].reset();
  }

  // --------------------------------------------------------------------------
  // [Accessors]
  // --------------------------------------------------------------------------

  inline BaseInst& baseInst() noexcept { return _baseInst; }
  inline const BaseInst& baseInst() const noexcept { return _baseInst; }

  //! Get the instruction id, see `BaseInst::Id`.
  inline uint32_t id() const noexcept { return _baseInst.id(); }
  //! Set the instruction id to `id`, see `BaseInst::Id`.
  inline void setId(uint32_t id) noexcept { _baseInst.setId(id); }

  //! Get instruction options.
  inline uint32_t instOptions() const noexcept { return _baseInst.options(); }
  //! Set instruction options.
  inline void setInstOptions(uint32_t options) noexcept { _baseInst.setOptions(options); }
  //! Add instruction options.
  inline void addInstOptions(uint32_t options) noexcept { _baseInst.addOptions(options); }
  //! Clear instruction options.
  inline void clearInstOptions(uint32_t options) noexcept { _baseInst.clearOptions(options); }

  //! Get whether the node has an extra register operand.
  inline bool hasExtraReg() const noexcept { return _baseInst.hasExtraReg(); }
  //! Get extra register operand.
  inline RegOnly& extraReg() noexcept { return _baseInst.extraReg(); }
  //! \overload
  inline const RegOnly& extraReg() const noexcept { return _baseInst.extraReg(); }
  //! Set extra register operand to `reg`.
  inline void setExtraReg(const BaseReg& reg) noexcept { _baseInst.setExtraReg(reg); }
  //! Set extra register operand to `reg`.
  inline void setExtraReg(const RegOnly& reg) noexcept { _baseInst.setExtraReg(reg); }
  //! Reset extra register operand.
  inline void resetExtraReg() noexcept { _baseInst.resetExtraReg(); }

  //! Get operands count.
  inline uint32_t opCount() const noexcept { return _inst._opCount; }
  //! Get operands capacity.
  inline uint32_t opCapacity() const noexcept { return _inst._opCapacity; }

  //! Set operands count.
  inline void setOpCount(uint32_t opCount) noexcept { _inst._opCount = uint8_t(opCount); }

  //! Get operands array.
  inline Operand* operands() noexcept { return (Operand*)_opArray; }
  //! Get operands array (const).
  inline const Operand* operands() const noexcept { return (const Operand*)_opArray; }

  inline Operand& opType(uint32_t index) noexcept {
    ASMJIT_ASSERT(index < opCapacity());
    return _opArray[index].as<Operand>();
  }

  inline const Operand& opType(uint32_t index) const noexcept {
    ASMJIT_ASSERT(index < opCapacity());
    return _opArray[index].as<Operand>();
  }

  inline void setOp(uint32_t index, const Operand_& op) noexcept {
    ASMJIT_ASSERT(index < opCapacity());
    _opArray[index].copyFrom(op);
  }

  inline void resetOp(uint32_t index) noexcept {
    ASMJIT_ASSERT(index < opCapacity());
    _opArray[index].reset();
  }

  // --------------------------------------------------------------------------
  // [Utilities]
  // --------------------------------------------------------------------------

  inline bool hasOpType(uint32_t opType) const noexcept {
    for (uint32_t i = 0, count = opCount(); i < count; i++)
      if (_opArray[i].opType() == opType)
        return true;
    return false;
  }

  inline bool hasRegOp() const noexcept { return hasOpType(Operand::kOpReg); }
  inline bool hasMemOp() const noexcept { return hasOpType(Operand::kOpMem); }
  inline bool hasImmOp() const noexcept { return hasOpType(Operand::kOpImm); }
  inline bool hasLabelOp() const noexcept { return hasOpType(Operand::kOpLabel); }

  inline uint32_t indexOfOpType(uint32_t opType) const noexcept {
    uint32_t i = 0;
    uint32_t count = opCount();

    while (i < count) {
      if (_opArray[i].opType() == opType)
        break;
      i++;
    }

    return i;
  }

  inline uint32_t indexOfMemOp() const noexcept { return indexOfOpType(Operand::kOpMem); }
  inline uint32_t indexOfImmOp() const noexcept { return indexOfOpType(Operand::kOpImm); }
  inline uint32_t indexOfLabelOp() const noexcept { return indexOfOpType(Operand::kOpLabel); }

  // --------------------------------------------------------------------------
  // [Rewrite]
  // --------------------------------------------------------------------------

  inline uint32_t* _getRewriteArray() noexcept { return &_baseInst._extraReg._id; }
  inline const uint32_t* _getRewriteArray() const noexcept { return &_baseInst._extraReg._id; }

  ASMJIT_INLINE uint32_t getRewriteIndex(const uint32_t* id) const noexcept {
    const uint32_t* array = _getRewriteArray();
    ASMJIT_ASSERT(array <= id);

    size_t index = (size_t)(id - array);
    ASMJIT_ASSERT(index < 32);

    return uint32_t(index);
  }

  ASMJIT_INLINE void rewriteIdAtIndex(uint32_t index, uint32_t id) noexcept {
    uint32_t* array = _getRewriteArray();
    array[index] = id;
  }

  // --------------------------------------------------------------------------
  // [Members]
  // --------------------------------------------------------------------------

  BaseInst _baseInst;                    //!< Base instruction data.
  Operand_ _opArray[kBaseOpCapacity];    //!< First 4 or 5 operands (indexed from 0).
};

// ============================================================================
// [asmjit::InstExNode]
// ============================================================================

class InstExNode : public InstNode {
public:
  ASMJIT_NONCOPYABLE(InstExNode)

  // --------------------------------------------------------------------------
  // [Construction / Destruction]
  // --------------------------------------------------------------------------

  //! Create a new `InstExNode` instance.
  inline InstExNode(BaseBuilder* cb, uint32_t instId, uint32_t options, uint32_t opCapacity = Globals::kMaxOpCount) noexcept
    : InstNode(cb, instId, options, opCapacity) {}

  // --------------------------------------------------------------------------
  // [Members]
  // --------------------------------------------------------------------------

  //! Continued `_opArray[]` to hold up to `kMaxOpCount` operands.
  Operand_ _opArrayEx[Globals::kMaxOpCount - kBaseOpCapacity];
};

// ============================================================================
// [asmjit::LabelNode]
// ============================================================================

//! Label node.
class LabelNode : public BaseNode {
public:
  ASMJIT_NONCOPYABLE(LabelNode)

  // --------------------------------------------------------------------------
  // [Construction / Destruction]
  // --------------------------------------------------------------------------

  //! Create a new `LabelNode` instance.
  inline LabelNode(BaseBuilder* cb, uint32_t id = 0) noexcept
    : BaseNode(cb, kNodeLabel, kFlagHasNoEffect | kFlagActsAsLabel),
      _id(id) {}

  // --------------------------------------------------------------------------
  // [Accessors]
  // --------------------------------------------------------------------------

  //! Get the label id.
  inline uint32_t id() const noexcept { return _id; }
  //! Get the label as `Label` operand.
  inline Label label() const noexcept { return Label(_id); }

  // --------------------------------------------------------------------------
  // [Members]
  // --------------------------------------------------------------------------

  uint32_t _id;
};

// ============================================================================
// [asmjit::AlignNode]
// ============================================================================

//! Align directive (BaseBuilder).
//!
//! Wraps `.align` directive.
class AlignNode : public BaseNode {
public:
  ASMJIT_NONCOPYABLE(AlignNode)

  // --------------------------------------------------------------------------
  // [Construction / Destruction]
  // --------------------------------------------------------------------------

  //! Create a new `AlignNode` instance.
  inline AlignNode(BaseBuilder* cb, uint32_t alignMode, uint32_t alignment) noexcept
    : BaseNode(cb, kNodeAlign, kFlagIsCode | kFlagHasNoEffect),
      _alignMode(alignMode),
      _alignment(alignment) {}

  // --------------------------------------------------------------------------
  // [Accessors]
  // --------------------------------------------------------------------------

  //! Get align mode.
  inline uint32_t alignMode() const noexcept { return _alignMode; }
  //! Set align mode to `alignMode`.
  inline void setAlignMode(uint32_t alignMode) noexcept { _alignMode = alignMode; }

  //! Get align offset in bytes.
  inline uint32_t alignment() const noexcept { return _alignment; }
  //! Set align offset in bytes to `offset`.
  inline void setAlignment(uint32_t alignment) noexcept { _alignment = alignment; }

  // --------------------------------------------------------------------------
  // [Members]
  // --------------------------------------------------------------------------

  uint32_t _alignMode;                   //!< Align mode, see `AlignMode`.
  uint32_t _alignment;                   //!< Alignment (in bytes).
};

// ============================================================================
// [asmjit::EmbedDataNode]
// ============================================================================

//! Embed data node.
//!
//! Wraps `.data` directive. The node contains data that will be placed at the
//! node's position in the assembler stream. The data is considered to be RAW;
//! no analysis nor byte-order conversion is performed on RAW data.
class EmbedDataNode : public BaseNode {
public:
  ASMJIT_NONCOPYABLE(EmbedDataNode)

  enum : uint32_t {
    kInlineBufferSize = uint32_t(64 - sizeof(BaseNode) - 4)
  };

  // --------------------------------------------------------------------------
  // [Construction / Destruction]
  // --------------------------------------------------------------------------

  //! Create a new `EmbedDataNode` instance.
  inline EmbedDataNode(BaseBuilder* cb, void* data, uint32_t size) noexcept
    : BaseNode(cb, kNodeEmbedData, kFlagIsData) {

    if (size <= kInlineBufferSize) {
      if (data)
        std::memcpy(_buf, data, size);
    }
    else {
      _externalPtr = static_cast<uint8_t*>(data);
    }
    _size = size;
  }

  // --------------------------------------------------------------------------
  // [Accessors]
  // --------------------------------------------------------------------------

  //! Get pointer to the data.
  inline uint8_t* data() const noexcept { return _size <= kInlineBufferSize ? const_cast<uint8_t*>(_buf) : _externalPtr; }
  //! Get size of the data.
  inline uint32_t size() const noexcept { return _size; }

  // --------------------------------------------------------------------------
  // [Members]
  // --------------------------------------------------------------------------

  union {
    struct {
      uint8_t _buf[kInlineBufferSize];   //!< Embedded data buffer.
      uint32_t _size;                    //!< Size of the data.
    };
    struct {
      uint8_t* _externalPtr;             //!< Pointer to external data.
    };
  };
};

// ============================================================================
// [asmjit::LabelDataNode]
// ============================================================================

//! Label data node.
class LabelDataNode : public BaseNode {
public:
  ASMJIT_NONCOPYABLE(LabelDataNode)

  // --------------------------------------------------------------------------
  // [Construction / Destruction]
  // --------------------------------------------------------------------------

  //! Create a new `LabelDataNode` instance.
  inline LabelDataNode(BaseBuilder* cb, uint32_t id = 0) noexcept
    : BaseNode(cb, kNodeLabelData, kFlagIsData),
      _id(id) {}

  // --------------------------------------------------------------------------
  // [Interface]
  // --------------------------------------------------------------------------

  //! Get the label id.
  inline uint32_t id() const noexcept { return _id; }
  //! Set the label id (use with caution, improper use can break a lot of things).
  inline void setId(uint32_t id) noexcept { _id = id; }

  //! Get the label as `Label` operand.
  inline Label label() const noexcept { return Label(_id); }

  // --------------------------------------------------------------------------
  // [Members]
  // --------------------------------------------------------------------------

  uint32_t _id;
};

// ============================================================================
// [asmjit::ConstPoolNode]
// ============================================================================

class ConstPoolNode : public LabelNode {
public:
  ASMJIT_NONCOPYABLE(ConstPoolNode)

  // --------------------------------------------------------------------------
  // [Construction / Destruction]
  // --------------------------------------------------------------------------

  //! Create a new `ConstPoolNode` instance.
  inline ConstPoolNode(BaseBuilder* cb, uint32_t id = 0) noexcept
    : LabelNode(cb, id),
      _constPool(&cb->_codeZone) {

    setType(kNodeConstPool);
    addFlags(kFlagIsData);
    clearFlags(kFlagIsCode | kFlagHasNoEffect);
  }

  // --------------------------------------------------------------------------
  // [Interface]
  // --------------------------------------------------------------------------

  //! Get whether the constant-pool is empty.
  inline bool empty() const noexcept { return _constPool.empty(); }
  //! Get the size of the constant-pool in bytes.
  inline size_t size() const noexcept { return _constPool.size(); }
  //! Get minimum alignment.
  inline size_t alignment() const noexcept { return _constPool.alignment(); }

  //! Get the wrapped `ConstPool` instance.
  inline ConstPool& constPool() noexcept { return _constPool; }
  //! Get the wrapped `ConstPool` instance (const).
  inline const ConstPool& constPool() const noexcept { return _constPool; }

  //! See `ConstPool::add()`.
  inline Error add(const void* data, size_t size, size_t& dstOffset) noexcept {
    return _constPool.add(data, size, dstOffset);
  }

  // --------------------------------------------------------------------------
  // [Members]
  // --------------------------------------------------------------------------

  ConstPool _constPool;
};

// ============================================================================
// [asmjit::CommentNode]
// ============================================================================

//! Comment node.
class CommentNode : public BaseNode {
public:
  ASMJIT_NONCOPYABLE(CommentNode)

  // --------------------------------------------------------------------------
  // [Construction / Destruction]
  // --------------------------------------------------------------------------

  //! Create a new `CommentNode` instance.
  inline CommentNode(BaseBuilder* cb, const char* comment) noexcept
    : BaseNode(cb, kNodeComment, kFlagIsInformative | kFlagHasNoEffect | kFlagIsRemovable) {
    _inlineComment = comment;
  }
};

// ============================================================================
// [asmjit::SentinelNode]
// ============================================================================

//! Sentinel node.
//!
//! Sentinel is a marker that is completely ignored by the code builder. It's
//! used to remember a position in a code as it never gets removed by any pass.
class SentinelNode : public BaseNode {
public:
  ASMJIT_NONCOPYABLE(SentinelNode)

  //! Type of the sentinel (purery informative purpose).
  enum SentinelType : uint32_t {
    kSentinelUnknown = 0u,
    kSentinelFuncEnd = 1u
  };

  // --------------------------------------------------------------------------
  // [Construction / Destruction]
  // --------------------------------------------------------------------------

  //! Create a new `SentinelNode` instance.
  inline SentinelNode(BaseBuilder* cb, uint32_t sentinelType = kSentinelUnknown) noexcept
    : BaseNode(cb, kNodeSentinel, kFlagIsInformative | kFlagHasNoEffect) {

    _sentinel._sentinelType = uint8_t(sentinelType);
  }

  // --------------------------------------------------------------------------
  // [Accessors]
  // --------------------------------------------------------------------------

  inline uint32_t sentinelType() const noexcept { return _sentinel._sentinelType; }
  inline void setSentinelType(uint32_t type) noexcept { _sentinel._sentinelType = uint8_t(type); }
};

// ============================================================================
// [asmjit::Pass]
// ============================================================================

//! Pass can be used to implement code transformations, analysis, and lowering.
class ASMJIT_VIRTAPI Pass {
public:
  ASMJIT_NONCOPYABLE(Pass);

  // --------------------------------------------------------------------------
  // [Construction / Destruction]
  // --------------------------------------------------------------------------

  ASMJIT_API Pass(const char* name) noexcept;
  ASMJIT_API virtual ~Pass() noexcept;

  // --------------------------------------------------------------------------
  // [Interface]
  // --------------------------------------------------------------------------

  //! Process the code stored in BaseBuilder.
  //!
  //! This is the only function that is called by the `BaseBuilder` to process
  //! the code. It passes `zone`, which will be reset after the `run()` returns
  //! by `BaseBuilder`.
  virtual Error run(Zone* zone, Logger* logger) noexcept = 0;

  // --------------------------------------------------------------------------
  // [Accessors]
  // --------------------------------------------------------------------------

  inline const BaseBuilder* cb() const noexcept { return _cb; }
  inline const char* name() const noexcept { return _name; }

  // --------------------------------------------------------------------------
  // [Members]
  // --------------------------------------------------------------------------

  BaseBuilder* _cb;                      //!< BaseBuilder this pass is assigned to.
  const char* _name;                     //!< Name of the pass.
};

//! \}

ASMJIT_END_NAMESPACE

// [Guard]
#endif // !ASMJIT_DISABLE_BUILDER
#endif // _ASMJIT_CORE_BUILDER_H

```

`Avanguard/AsmJit/asmjit/core/callconv.h`:

```h
// [AsmJit]
// Complete x86/x64 JIT and Remote Assembler for C++.
//
// [License]
// ZLIB - See LICENSE.md file in the package.

// [Guard]
#ifndef _ASMJIT_CORE_CALLCONV_H
#define _ASMJIT_CORE_CALLCONV_H

// [Dependencies]
#include "../core/arch.h"
#include "../core/operand.h"
#include "../core/support.h"

ASMJIT_BEGIN_NAMESPACE

//! \addtogroup asmjit_core_func
//! \{

// ============================================================================
// [asmjit::CallConv]
// ============================================================================

//! Function calling convention.
//!
//! Function calling convention is a scheme that defines how function parameters
//! are passed and how function returns its result. AsmJit defines a variety of
//! architecture and OS specific calling conventions and also provides a compile
//! time detection to make the code-generation easier.
struct CallConv {
  //! Calling convention id.
  enum Id : uint32_t {
    //! None or invalid (can't be used).
    kIdNone = 0,

    // ------------------------------------------------------------------------
    // [Universal]
    // ------------------------------------------------------------------------

    // TODO: To make this possible we need to know target ARCH and ABI.

    /*

    // Universal calling conventions are applicable to any target and are
    // converted to target dependent conventions at runtime. The purpose of
    // these conventions is to make using functions less target dependent.

    kIdCDecl = 1,
    kIdStdCall = 2,
    kIdFastCall = 3,

    //! AsmJit specific calling convention designed for calling functions
    //! inside a multimedia code that don't use many registers internally,
    //! but are long enough to be called and not inlined. These functions are
    //! usually used to calculate trigonometric functions, logarithms, etc...
    kIdLightCall2 = 10,
    kIdLightCall3 = 11,
    kIdLightCall4 = 12,
    */

    // ------------------------------------------------------------------------
    // [X86]
    // ------------------------------------------------------------------------

    //! X86 `__cdecl` calling convention (used by C runtime and libraries).
    kIdX86CDecl = 16,
    //! X86 `__stdcall` calling convention (used mostly by WinAPI).
    kIdX86StdCall = 17,
    //! X86 `__thiscall` calling convention (MSVC/Intel).
    kIdX86MsThisCall = 18,
    //! X86 `__fastcall` convention (MSVC/Intel).
    kIdX86MsFastCall = 19,
    //! X86 `__fastcall` convention (GCC and Clang).
    kIdX86GccFastCall = 20,
    //! X86 `regparm(1)` convention (GCC and Clang).
    kIdX86GccRegParm1 = 21,
    //! X86 `regparm(2)` convention (GCC and Clang).
    kIdX86GccRegParm2 = 22,
    //! X86 `regparm(3)` convention (GCC and Clang).
    kIdX86GccRegParm3 = 23,

    kIdX86LightCall2 = 29,
    kIdX86LightCall3 = 30,
    kIdX86LightCall4 = 31,

    //! X64 calling convention - WIN64-ABI.
    kIdX86Win64 = 32,
    //! X64 calling convention - SystemV / AMD64-ABI.
    kIdX86SysV64 = 33,

    kIdX64LightCall2 = 45,
    kIdX64LightCall3 = 46,
    kIdX64LightCall4 = 47,

    // ------------------------------------------------------------------------
    // [ARM]
    // ------------------------------------------------------------------------

    //! Legacy calling convention, floating point arguments are passed via GP registers.
    kIdArm32SoftFP = 48,
    //! Modern calling convention, uses VFP registers to pass floating point arguments.
    kIdArm32HardFP = 49,

    // ------------------------------------------------------------------------
    // [Internal]
    // ------------------------------------------------------------------------

    _kIdX86Start = 16,  //!< \internal
    _kIdX86End = 31,    //!< \internal

    _kIdX64Start = 32,  //!< \internal
    _kIdX64End = 47,    //!< \internal

    _kIdArmStart = 48,  //!< \internal
    _kIdArmEnd = 49,    //!< \internal

    // ------------------------------------------------------------------------
    // [Host]
    // ------------------------------------------------------------------------

    #if defined(ASMJIT_DOCGEN)

    //! Default calling convention based on the current C++ compiler's settings.
    //!
    //! NOTE: This should be always the same as `kIdHostCDecl`, but some
    //! compilers allow to override the default calling convention. Overriding
    //! is not detected at the moment.
    kIdHost          = DETECTED_AT_COMPILE_TIME,
    //! Default CDECL calling convention based on the current C++ compiler's settings.
    kIdHostCDecl     = DETECTED_AT_COMPILE_TIME,
    //! Default STDCALL calling convention based on the current C++ compiler's settings.
    //!
    //! NOTE: If not defined by the host then it's the same as `kIdHostCDecl`.
    kIdHostStdCall   = DETECTED_AT_COMPILE_TIME,
    //! Compatibility for `__fastcall` calling convention.
    //!
    //! NOTE: If not defined by the host then it's the same as `kIdHostCDecl`.
    kIdHostFastCall  = DETECTED_AT_COMPILE_TIME

    #elif ASMJIT_ARCH_X86 == 32

    kIdHost          = kIdX86CDecl,
    kIdHostCDecl     = kIdX86CDecl,
    kIdHostStdCall   = kIdX86StdCall,
    kIdHostFastCall  = ASMJIT_CXX_MSC ? kIdX86MsFastCall  :
                       ASMJIT_CXX_GNU ? kIdX86GccFastCall : kIdNone,
    kIdHostLightCall2 = kIdX86LightCall2,
    kIdHostLightCall3 = kIdX86LightCall3,
    kIdHostLightCall4 = kIdX86LightCall4

    #elif ASMJIT_ARCH_X86 == 64

    kIdHost          = ASMJIT_OS_WINDOWS ? kIdX86Win64 : kIdX86SysV64,
    kIdHostCDecl     = kIdHost, // Doesn't exist, redirected to host.
    kIdHostStdCall   = kIdHost, // Doesn't exist, redirected to host.
    kIdHostFastCall  = kIdHost, // Doesn't exist, redirected to host.
    kIdHostLightCall2 = kIdX64LightCall2,
    kIdHostLightCall3 = kIdX64LightCall3,
    kIdHostLightCall4 = kIdX64LightCall4

    #elif ASMJIT_ARCH_ARM == 32

    #if defined(__SOFTFP__)
    kIdHost          = kIdArm32SoftFP,
    #else
    kIdHost          = kIdArm32HardFP,
    #endif
    // These don't exist on ARM.
    kIdHostCDecl     = kIdHost, // Doesn't exist, redirected to host.
    kIdHostStdCall   = kIdHost, // Doesn't exist, redirected to host.
    kIdHostFastCall  = kIdHost  // Doesn't exist, redirected to host.

    #else

    kIdHost          = kIdNone,
    kIdHostCDecl     = kIdHost,
    kIdHostStdCall   = kIdHost,
    kIdHostFastCall  = kIdHost

    #endif
  };

  //! Strategy used to assign registers to function arguments.
  //!
  //! This is AsmJit specific. It basically describes how AsmJit should convert
  //! the function arguments defined by `FuncSignature` into register IDs and
  //! stack offsets. The default strategy `kStrategyDefault` assigns registers
  //! and then stack whereas `kStrategyWin64` strategy does register shadowing
  //! as defined by WIN64 calling convention - it applies to 64-bit calling
  //! conventions only.
  enum Strategy : uint32_t {
    kStrategyDefault     = 0,            //!< Default register assignment strategy.
    kStrategyWin64       = 1             //!< WIN64 specific register assignment strategy.
  };

  //! Calling convention flags.
  enum Flags : uint32_t {
    kFlagCalleePopsStack = 0x01,         //!< Callee is responsible for cleaning up the stack.
    kFlagPassFloatsByVec = 0x02,         //!< Pass F32 and F64 arguments by VEC128 register.
    kFlagVectorCall      = 0x04,         //!< This is a '__vectorcall' calling convention.
    kFlagIndirectVecArgs = 0x08          //!< Pass vector arguments indirectly (as a pointer).
  };

  //! Internal limits of AsmJit's CallConv.
  enum Limits : uint32_t {
    kMaxRegArgsPerGroup  = 16
  };

  //! Passed registers' order.
  union RegOrder {
    uint8_t id[kMaxRegArgsPerGroup];     //!< Passed registers, ordered.
    uint32_t packed[(kMaxRegArgsPerGroup + 3) / 4];
  };

  // --------------------------------------------------------------------------
  // [Utilities]
  // --------------------------------------------------------------------------

  static inline bool isX86Family(uint32_t ccId) noexcept { return ccId >= _kIdX86Start && ccId <= _kIdX64End; }
  static inline bool isArmFamily(uint32_t ccId) noexcept { return ccId >= _kIdArmStart && ccId <= _kIdArmEnd; }

  // --------------------------------------------------------------------------
  // [Init / Reset]
  // --------------------------------------------------------------------------

  ASMJIT_API Error init(uint32_t ccId) noexcept;

  inline void reset() noexcept {
    std::memset(this, 0, sizeof(*this));
    std::memset(_passedOrder, 0xFF, sizeof(_passedOrder));
  }

  // --------------------------------------------------------------------------
  // [Accessors]
  // --------------------------------------------------------------------------

  //! Get calling convention id, see `Id`.
  inline uint32_t id() const noexcept { return _id; }
  //! Set calling convention id, see `Id`.
  inline void setId(uint32_t id) noexcept { _id = uint8_t(id); }

  //! Get architecture type.
  inline uint32_t archId() const noexcept { return _archId; }
  //! Set architecture type.
  inline void setArchType(uint32_t archId) noexcept { _archId = uint8_t(archId); }

  //! Get a strategy used to assign registers to arguments, see `Strategy`.
  inline uint32_t strategy() const noexcept { return _strategy; }
  //! Set a strategy used to assign registers to arguments, see `Strategy`.
  inline void setStrategy(uint32_t strategy) noexcept { _strategy = uint8_t(strategy); }

  //! Get whether the calling convention has the given `flag` set.
  inline bool hasFlag(uint32_t flag) const noexcept { return (uint32_t(_flags) & flag) != 0; }
  //! Get calling convention flags, see `Flags`.
  inline uint32_t flags() const noexcept { return _flags; }
  //! Add calling convention flags, see `Flags`.
  inline void setFlags(uint32_t flag) noexcept { _flags = uint8_t(flag); };
  //! Add calling convention flags, see `Flags`.
  inline void addFlags(uint32_t flags) noexcept { _flags = uint8_t(_flags | flags); };

  //! Get whether this calling convention specifies 'RedZone'.
  inline bool hasRedZone() const noexcept { return _redZoneSize != 0; }
  //! Get whether this calling convention specifies 'SpillZone'.
  inline bool hasSpillZone() const noexcept { return _spillZoneSize != 0; }

  //! Get size of 'RedZone'.
  inline uint32_t redZoneSize() const noexcept { return _redZoneSize; }
  //! Get size of 'SpillZone'.
  inline uint32_t spillZoneSize() const noexcept { return _spillZoneSize; }

  //! Set size of 'RedZone'.
  inline void setRedZoneSize(uint32_t size) noexcept { _redZoneSize = uint8_t(size); }
  //! Set size of 'SpillZone'.
  inline void setSpillZoneSize(uint32_t size) noexcept { _spillZoneSize = uint8_t(size); }

  //! Get a natural stack alignment.
  inline uint32_t naturalStackAlignment() const noexcept { return _naturalStackAlignment; }
  //! Set a natural stack alignment.
  //!
  //! This function can be used to override the default stack alignment in case
  //! that you know that it's alignment is different. For example it allows to
  //! implement custom calling conventions that guarantee higher stack alignment.
  inline void setNaturalStackAlignment(uint32_t value) noexcept { _naturalStackAlignment = uint8_t(value); }

  inline const uint8_t* passedOrder(uint32_t group) const noexcept {
    ASMJIT_ASSERT(group < BaseReg::kGroupVirt);
    return _passedOrder[group].id;
  }

  inline uint32_t passedRegs(uint32_t group) const noexcept {
    ASMJIT_ASSERT(group < BaseReg::kGroupVirt);
    return _passedRegs[group];
  }

  inline void _setPassedPacked(uint32_t group, uint32_t p0, uint32_t p1, uint32_t p2, uint32_t p3) noexcept {
    ASMJIT_ASSERT(group < BaseReg::kGroupVirt);

    _passedOrder[group].packed[0] = p0;
    _passedOrder[group].packed[1] = p1;
    _passedOrder[group].packed[2] = p2;
    _passedOrder[group].packed[3] = p3;
  }

  inline void setPassedToNone(uint32_t group) noexcept {
    ASMJIT_ASSERT(group < BaseReg::kGroupVirt);

    _setPassedPacked(group, 0xFFFFFFFFu, 0xFFFFFFFFu, 0xFFFFFFFFu, 0xFFFFFFFFu);
    _passedRegs[group] = 0u;
  }

  inline void setPassedOrder(uint32_t group, uint32_t a0, uint32_t a1 = 0xFF, uint32_t a2 = 0xFF, uint32_t a3 = 0xFF, uint32_t a4 = 0xFF, uint32_t a5 = 0xFF, uint32_t a6 = 0xFF, uint32_t a7 = 0xFF) noexcept {
    ASMJIT_ASSERT(group < BaseReg::kGroupVirt);

    // NOTE: This should always be called with all arguments known at compile time,
    // so even if it looks scary it should be translated into few instructions.
    _setPassedPacked(group, Support::bytepack32_4x8(a0, a1, a2, a3),
                            Support::bytepack32_4x8(a4, a5, a6, a7),
                            0xFFFFFFFFu,
                            0xFFFFFFFFu);

    _passedRegs[group] = (a0 != 0xFF ? 1u << a0 : 0u) |
                         (a1 != 0xFF ? 1u << a1 : 0u) |
                         (a2 != 0xFF ? 1u << a2 : 0u) |
                         (a3 != 0xFF ? 1u << a3 : 0u) |
                         (a4 != 0xFF ? 1u << a4 : 0u) |
                         (a5 != 0xFF ? 1u << a5 : 0u) |
                         (a6 != 0xFF ? 1u << a6 : 0u) |
                         (a7 != 0xFF ? 1u << a7 : 0u) ;
  }

  inline uint32_t preservedRegs(uint32_t group) const noexcept {
    ASMJIT_ASSERT(group < BaseReg::kGroupVirt);
    return _preservedRegs[group];
  }

  inline void setPreservedRegs(uint32_t group, uint32_t regs) noexcept {
    ASMJIT_ASSERT(group < BaseReg::kGroupVirt);
    _preservedRegs[group] = regs;
  }

  // --------------------------------------------------------------------------
  // [Members]
  // --------------------------------------------------------------------------

  uint8_t _id;                           //!< Calling convention id, see `Id`.
  uint8_t _archId;                       //!< Architecture id (see `ArchInfo::Id`).
  uint8_t _strategy;                     //!< Register assignment strategy.
  uint8_t _flags;                        //!< Flags.

  uint8_t _redZoneSize;                  //!< Red zone size (AMD64 == 128 bytes).
  uint8_t _spillZoneSize;                //!< Spill zone size (WIN64 == 32 bytes).
  uint8_t _naturalStackAlignment;        //!< Natural stack alignment as defined by OS/ABI.
  uint8_t _reserved[1];

  uint32_t _passedRegs[BaseReg::kGroupVirt];    //!< Mask of all passed registers, per group.
  uint32_t _preservedRegs[BaseReg::kGroupVirt]; //!< Mask of all preserved registers, per group.
  RegOrder _passedOrder[BaseReg::kGroupVirt];   //!< Passed registers' order, per group.
};

//! \}

ASMJIT_END_NAMESPACE

// [Guard]
#endif // _ASMJIT_CORE_CALLCONV_H

```

`Avanguard/AsmJit/asmjit/core/codeholder.h`:

```h
// [AsmJit]
// Complete x86/x64 JIT and Remote Assembler for C++.
//
// [License]
// ZLIB - See LICENSE.md file in the package.

// [Guard]
#ifndef _ASMJIT_CORE_CODEHOLDER_H
#define _ASMJIT_CORE_CODEHOLDER_H

// [Dependencies]
#include "../core/arch.h"
#include "../core/datatypes.h"
#include "../core/memmgr.h"
#include "../core/operand.h"
#include "../core/stringutils.h"
#include "../core/support.h"
#include "../core/target.h"
#include "../core/zone.h"
#include "../core/zonehash.h"
#include "../core/zonestring.h"
#include "../core/zonevector.h"

ASMJIT_BEGIN_NAMESPACE

//! \addtogroup asmjit_core_api
//! \{

// ============================================================================
// [Forward Declarations]
// ============================================================================

class BaseEmitter;
class CodeHolder;
class Logger;

// ============================================================================
// [asmjit::AlignMode]
// ============================================================================

//! Align mode.
enum AlignMode : uint32_t {
  kAlignCode  = 0,                       //!< Align executable code.
  kAlignData  = 1,                       //!< Align non-executable code.
  kAlignZero  = 2,                       //!< Align by a sequence of zeros.
  kAlignCount = 3                        //!< Count of alignment modes.
};

// ============================================================================
// [asmjit::ErrorHandler]
// ============================================================================

//! Error handler can be used to override the default behavior of error handling
//! available to all classes that inherit `BaseEmitter`.
//!
//! Override `ErrorHandler::handleError()` to implement your own error handler.
class ASMJIT_VIRTAPI ErrorHandler {
public:
  // --------------------------------------------------------------------------
  // [Construction / Destruction]
  // --------------------------------------------------------------------------

  //! Create a new `ErrorHandler` instance.
  ASMJIT_API ErrorHandler() noexcept;
  //! Destroy the `ErrorHandler` instance.
  ASMJIT_API virtual ~ErrorHandler() noexcept;

  // --------------------------------------------------------------------------
  // [Handle Error]
  // --------------------------------------------------------------------------

  //! Error handler (must be reimplemented).
  //!
  //! Error handler is called after an error happened and before it's propagated
  //! to the caller. There are multiple ways how the error handler can be used:
  //!
  //! 1. User-based error handling without throwing exception or using C's
  //!    `longjmp()`. This is for users that don't use exceptions and want
  //!    customized error handling.
  //!
  //! 2. Throwing an exception. AsmJit doesn't use exceptions and is completely
  //!    exception-safe, but you can throw exception from your error handler if
  //!    this way is the preferred way of handling errors in your project.
  //!
  //! 3. Using plain old C's `setjmp()` and `longjmp()`. Asmjit always puts
  //!    `BaseEmitter` to a consistent state before calling `handleError()`
  //!    so `longjmp()` can be used without any issues to cancel the code
  //!    generation if an error occurred. There is no difference between
  //!    exceptions and `longjmp()` from AsmJit's perspective, however,
  //!    never jump outside of `CodeHolder` and `BaseEmitter` scope as you
  //!    would leak memory.
  virtual void handleError(Error err, const char* message, BaseEmitter* origin) = 0;
};

// ============================================================================
// [asmjit::CodeBuffer]
// ============================================================================

//! Code or data buffer.
struct CodeBuffer {
  enum Flags : uint32_t {
    kFlagIsExternal       = 0x00000001u, //!< Buffer is external (not allocated by asmjit).
    kFlagIsFixed          = 0x00000002u  //!< Buffer is fixed (cannot be reallocated).
  };

  // --------------------------------------------------------------------------
  // [Accessors]
  // --------------------------------------------------------------------------

  inline uint32_t flags() const noexcept { return _flags; }
  inline bool hasFlag(uint32_t flag) const noexcept { return (_flags & flag) != 0; }

  inline bool isAllocated() const noexcept { return _data != nullptr; }
  inline bool isFixed() const noexcept { return hasFlag(kFlagIsFixed); }
  inline bool isExternal() const noexcept { return hasFlag(kFlagIsExternal); }

  inline uint8_t* data() noexcept { return _data; }
  inline const uint8_t* data() const noexcept { return _data; }

  inline bool empty() const noexcept { return !_size; }
  inline size_t size() const noexcept { return _size; }
  inline size_t capacity() const noexcept { return _capacity; }

  // --------------------------------------------------------------------------
  // [Members]
  // --------------------------------------------------------------------------

  uint8_t* _data;                        //!< The content of the buffer (data).
  size_t _size;                          //!< Number of bytes of `data` used.
  size_t _capacity;                      //!< Buffer capacity (in bytes).
  uint32_t _flags;                       //!< Buffer flags.
};

// ============================================================================
// [asmjit::SectionEntry]
// ============================================================================

//! Section entry.
class SectionEntry {
public:
  enum Id : uint32_t {
    kInvalidId       = 0xFFFFFFFFu       //!< Invalid section id.
  };

  //! Section flags.
  enum Flags : uint32_t {
    kFlagExec        = 0x00000001u,      //!< Executable (.text sections).
    kFlagConst       = 0x00000002u,      //!< Read-only (.text and .data sections).
    kFlagZero        = 0x00000004u,      //!< Zero initialized by the loader (BSS).
    kFlagInfo        = 0x00000008u,      //!< Info / comment flag.
    kFlagImplicit    = 0x80000000u       //!< Section created implicitly and can be deleted by `Target`.
  };

  // --------------------------------------------------------------------------
  // [Accessors]
  // --------------------------------------------------------------------------

  inline uint32_t id() const noexcept { return _id; }
  inline const char* name() const noexcept { return _name.str; }

  inline void _setDefaultName(char c0 = 0, char c1 = 0, char c2 = 0, char c3 = 0,
                              char c4 = 0, char c5 = 0, char c6 = 0, char c7 = 0) noexcept {
    _name.u32[0] = Support::bytepack32_4x8(uint8_t(c0), uint8_t(c1), uint8_t(c2), uint8_t(c3));
    _name.u32[1] = Support::bytepack32_4x8(uint8_t(c4), uint8_t(c5), uint8_t(c6), uint8_t(c7));
  }

  inline uint32_t flags() const noexcept { return _flags; }
  inline uint32_t alignment() const noexcept { return _alignment; }
  inline size_t virtualSize() const noexcept { return _virtualSize; }
  inline size_t physicalSize() const noexcept { return _buffer.size(); }

  inline bool hasFlag(uint32_t flag) const noexcept { return (_flags & flag) != 0; }
  inline void addFlags(uint32_t flags) noexcept { _flags |= flags; }
  inline void clearFlags(uint32_t flags) noexcept { _flags &= ~flags; }

  inline void setAlignment(uint32_t alignment) noexcept { _alignment = alignment; }
  inline void setVirtualSize(uint32_t size) noexcept { _virtualSize = size; }

  inline CodeBuffer& buffer() noexcept { return _buffer; }
  inline const CodeBuffer& buffer() const noexcept { return _buffer; }

  // --------------------------------------------------------------------------
  // [Members]
  // --------------------------------------------------------------------------

  uint32_t _id;                          //!< Section id.
  uint32_t _flags;                       //!< Section flags.
  uint32_t _alignment;                   //!< Section alignment requirements (0 if no requirements).
  uint32_t _virtualSize;                 //!< Virtual size of the section (zero initialized mostly).
  StaticString<36> _name;                //!< Section name (max 35 characters, PE allows max 8).
  CodeBuffer _buffer;                    //!< Code or data buffer.
};

// ============================================================================
// [asmjit::LabelLink]
// ============================================================================

//! Data structure used to link unbound labels.
struct LabelLink {
  LabelLink* prev;                       //!< Previous link (single-linked list).
  uint32_t sectionId;                    //!< Section id.
  uint32_t relocId;                      //!< Relocation id or RelocEntry::kInvalidId.
  size_t offset;                         //!< Label offset relative to the start of the section.
  intptr_t rel;                          //!< Inlined rel8/rel32.
};

// ============================================================================
// [asmjit::LabelEntry]
// ============================================================================

//! Label entry.
//!
//! Contains the following properties:
//!   * Label id - This is the only thing that is set to the `Label` operand.
//!   * Label name - Optional, used mostly to create executables and libraries.
//!   * Label type - Type of the label, default `Label::kTypeAnonymous`.
//!   * Label parent id - Derived from many assemblers that allow to define a
//!       local label that falls under a global label. This allows to define
//!       many labels of the same name that have different parent (global) label.
//!   * Offset - offset of the label bound by `Assembler`.
//!   * Links - single-linked list that contains locations of code that has
//!       to be patched when the label gets bound. Every use of unbound label
//!       adds one link to `_links` list.
//!   * HVal - Hash value of label's name and optionally parentId.
//!   * HashNext - Hash-table implementation detail.
class LabelEntry : public ZoneHashNode {
public:
  // NOTE: Label id is stored in `_customData`, which is provided by ZoneHashNode
  // to fill a padding that a C++ compiler targeting 64-bit CPU will add to align
  // the structure to 64-bits.

  //! Get label id.
  inline uint32_t id() const noexcept { return _customData; }
  //! Set label id (internal, used only by `CodeHolder`).
  inline void _setId(uint32_t id) noexcept { _customData = id; }

  //! Get label type, see `Label::LabelType`.
  inline uint32_t type() const noexcept { return _type; }
  //! Get label flags, returns 0 at the moment.
  inline uint32_t flags() const noexcept { return _flags; }

  inline bool hasParent() const noexcept { return _parentId != 0; }
  //! Get label's parent id.
  inline uint32_t parentId() const noexcept { return _parentId; }
  //! Get label's section id where it's bound to (or `SectionEntry::kInvalidId` if it's not bound yet).
  inline uint32_t sectionId() const noexcept { return _sectionId; }

  //! Get whether the label has name.
  inline bool hasName() const noexcept { return !_name.empty(); }

  //! Get the label's name.
  //!
  //! NOTE: Local labels will return their local name without their parent
  //! part, for example ".L1".
  inline const char* name() const noexcept { return _name.data(); }

  //! Get size of label's name.
  //!
  //! NOTE: Label name is always null terminated, so you can use `strlen()` to
  //! get it, however, it's also cached in `LabelEntry` itself, so if you want
  //! to know the size the fastest way is to call `LabelEntry::nameSize()`.
  inline uint32_t nameSize() const noexcept { return _name.size(); }

  //! Get whether the label is bound.
  inline bool isBound() const noexcept { return _sectionId != SectionEntry::kInvalidId; }
  //! Get the label offset (only useful if the label is bound).
  inline intptr_t offset() const noexcept { return _offset; }

  //! Get the hash-value of label's name and its parent label (if any).
  //!
  //! Label hash is calculated as `HASH(Name) ^ ParentId`. The hash function
  //! is implemented in `hashString::hashString()` and `StringUtils::hashRound()`.
  inline uint32_t hashCode() const noexcept { return _hashCode; }

  // ------------------------------------------------------------------------
  // [Members]
  // ------------------------------------------------------------------------

  // Let's round the size of `LabelEntry` to 64 bytes (as `ZoneAllocator` has
  // granularity of 32 bytes anyway). This gives `_name` the remaining space,
  // which is should be 16 bytes on 64-bit and 28 bytes on 32-bit architectures.
  static constexpr uint32_t kStaticNameSize =
    64 - (sizeof(ZoneHashNode) + 16 + sizeof(intptr_t) + sizeof(LabelLink*));

  uint8_t _type;                         //!< Label type, see `Label::LabelType`.
  uint8_t _flags;                        //!< Must be zero.
  uint16_t _reserved16;                  //!< Reserved.
  uint32_t _parentId;                    //!< Label parent id or zero.
  uint32_t _sectionId;                   //!< Section id or `SectionEntry::kInvalidId`.
  uint32_t _reserved32;                  //!< Reserved.
  intptr_t _offset;                      //!< Label offset.
  LabelLink* _links;                     //!< Label links.
  ZoneString<kStaticNameSize> _name;     //!< Label name.
};

// ============================================================================
// [asmjit::RelocEntry]
// ============================================================================

//! Relocation entry.
struct RelocEntry {
  enum Id : uint32_t {
    kInvalidId       = 0xFFFFFFFFu       //!< Invalid relocation id.
  };

  //! Relocation type.
  enum RelocType : uint32_t {
    kTypeNone        = 0,                //!< Deleted entry (no relocation).
    kTypeAbsToAbs    = 1,                //!< Relocate absolute to absolute.
    kTypeRelToAbs    = 2,                //!< Relocate relative to absolute.
    kTypeAbsToRel    = 3,                //!< Relocate absolute to relative.
    kTypeTrampoline  = 4                 //!< Relocate absolute to relative or use trampoline.
  };

  // ------------------------------------------------------------------------
  // [Accessors]
  // ------------------------------------------------------------------------

  inline uint32_t id() const noexcept { return _id; }

  inline uint32_t type() const noexcept { return _type; }
  inline uint32_t size() const noexcept { return _size; }

  inline uint32_t sourceSectionId() const noexcept { return _sourceSectionId; }
  inline uint32_t targetSectionId() const noexcept { return _targetSectionId; }

  inline uint64_t sourceOffset() const noexcept { return _sourceOffset; }
  inline uint64_t payload() const noexcept { return _payload; }

  // ------------------------------------------------------------------------
  // [Members]
  // ------------------------------------------------------------------------

  uint32_t _id;                          //!< Relocation id.
  uint8_t _type;                         //!< Type of the relocation.
  uint8_t _size;                         //!< Size of the relocation (1, 2, 4 or 8 bytes).
  uint8_t _reserved[2];                  //!< Reserved.
  uint32_t _sourceSectionId;             //!< Source section id.
  uint32_t _targetSectionId;             //!< Destination section id.
  uint64_t _sourceOffset;                //!< Source offset (relative to start of the section).
  uint64_t _payload;                     //!< Payload (target offset, target address, etc).
};

// ============================================================================
// [asmjit::CodeHolder]
// ============================================================================

//! Contains basic information about the target architecture plus its settings,
//! and holds code & data (including sections, labels, and relocation information).
//! CodeHolder can store both binary and intermediate representation of assembly,
//! which can be generated by `BaseAssembler` and/or `BaseBuilder`.
//!
//! NOTE: `CodeHolder` has ability to attach an `ErrorHandler`, however, the
//! error handler is not triggered by `CodeHolder` itself, it's only used by
//! emitters attached to `CodeHolder`.
class CodeHolder {
public:
  ASMJIT_NONCOPYABLE(CodeHolder)

  // --------------------------------------------------------------------------
  // [Construction / Destruction]
  // --------------------------------------------------------------------------

  //! Create an uninitialized CodeHolder (you must init() it before it can be used).
  ASMJIT_API CodeHolder() noexcept;
  //! Destroy the CodeHolder.
  ASMJIT_API ~CodeHolder() noexcept;

  // --------------------------------------------------------------------------
  // [Init / Reset]
  // --------------------------------------------------------------------------

  inline bool isInitialized() const noexcept { return _codeInfo.isInitialized(); }

  //! Initialize to CodeHolder to hold code described by `codeInfo`.
  ASMJIT_API Error init(const CodeInfo& info) noexcept;
  //! Detach all code-generators attached and reset the `CodeHolder`.
  ASMJIT_API void reset(uint32_t resetPolicy = Globals::kResetSoft) noexcept;

  // --------------------------------------------------------------------------
  // [Attach / Detach]
  // --------------------------------------------------------------------------

  //! Attach an emitter to this `CodeHolder`.
  ASMJIT_API Error attach(BaseEmitter* emitter) noexcept;
  //! Detach an emitter from this `CodeHolder`.
  ASMJIT_API Error detach(BaseEmitter* emitter) noexcept;

  // --------------------------------------------------------------------------
  // [Accessors]
  // --------------------------------------------------------------------------

  inline ZoneAllocator* allocator() const noexcept { return const_cast<ZoneAllocator*>(&_allocator); }
  inline const ZoneVector<BaseEmitter*>& emitters() const noexcept { return _emitters; }

  // --------------------------------------------------------------------------
  // [Code / Arch]
  // --------------------------------------------------------------------------

  //! Get architecture information, see `ArchInfo`.
  inline const ArchInfo& archInfo() const noexcept { return _codeInfo.archInfo(); }
  //! Get code/target information, see `CodeInfo`.
  inline const CodeInfo& codeInfo() const noexcept { return _codeInfo; }

  //! Get the target's architecture type.
  inline uint32_t archId() const noexcept { return archInfo().archId(); }
  //! Get the target's architecture sub-type.
  inline uint32_t archSubId() const noexcept { return archInfo().archSubId(); }

  //! Get whether a static base-address is set.
  inline bool hasBaseAddress() const noexcept { return _codeInfo.hasBaseAddress(); }
  //! Get a static base-address (uint64_t).
  inline uint64_t baseAddress() const noexcept { return _codeInfo.baseAddress(); }

  // --------------------------------------------------------------------------
  // [Emitter Options]
  // --------------------------------------------------------------------------

  //! Get global hints, internally propagated to all code emitters attached.
  inline uint32_t emitterOptions() const noexcept { return _emitterOptions; }

  // --------------------------------------------------------------------------
  // [Result Information]
  // --------------------------------------------------------------------------

  //! Get the size code & data of all sections.
  ASMJIT_API size_t codeSize() const noexcept;

  //! Get size of all possible trampolines.
  //!
  //! Trampolines are needed to successfully generate relative jumps to absolute
  //! addresses. This value is only non-zero if jmp of call instructions were
  //! used with immediate operand (this means jumping or calling an absolute
  //! address directly).
  inline size_t getTrampolinesSize() const noexcept { return _trampolinesSize; }

  // --------------------------------------------------------------------------
  // [Logging & Error Handling]
  // --------------------------------------------------------------------------

  //! Get the attached logger.
  inline Logger* logger() const noexcept { return _logger; }
  //! Attach a `logger` to CodeHolder and propagate it to all attached code emitters.
  ASMJIT_API void setLogger(Logger* logger) noexcept;
  //! Reset the logger (does nothing if not attached).
  inline void resetLogger() noexcept { setLogger(nullptr); }

  //! Get whether the global error handler is attached.
  inline bool hasErrorHandler() const noexcept { return _errorHandler != nullptr; }
  //! Get the global error handler.
  inline ErrorHandler* errorHandler() const noexcept { return _errorHandler; }
  //! Set the global error handler.
  inline void setErrorHandler(ErrorHandler* handler) noexcept { _errorHandler = handler; }
  //! Reset the global error handler (does nothing if not attached).
  inline void resetErrorHandler() noexcept { setErrorHandler(nullptr); }

  // --------------------------------------------------------------------------
  // [Sections]
  // --------------------------------------------------------------------------

  //! Get array of `SectionEntry*` records.
  inline const ZoneVector<SectionEntry*>& sectionEntries() const noexcept { return _sectionEntries; }
  //! Get a section entry of the given index.
  inline SectionEntry* sectionEntry(uint32_t index) const noexcept { return _sectionEntries[index]; }
  //! Get the number of sections.
  inline uint32_t sectionCount() const noexcept { return _sectionEntries.size(); }

  ASMJIT_API Error growBuffer(CodeBuffer* cb, size_t n) noexcept;
  ASMJIT_API Error reserveBuffer(CodeBuffer* cb, size_t n) noexcept;

  // --------------------------------------------------------------------------
  // [Labels & Symbols]
  // --------------------------------------------------------------------------

  //! Create a new anonymous label and return its id in `idOut`.
  //!
  //! Returns `Error`, does not report error to `ErrorHandler`.
  ASMJIT_API Error newLabelId(uint32_t& idOut) noexcept;

  //! Create a new named label label-type `type`.
  //!
  //! Returns `Error`, does not report error to `ErrorHandler`.
  ASMJIT_API Error newNamedLabelId(uint32_t& idOut, const char* name, size_t nameSize, uint32_t type, uint32_t parentId) noexcept;

  //! Get a label id by name.
  ASMJIT_API uint32_t labelIdByName(const char* name, size_t nameSize = Globals::kNullTerminated, uint32_t parentId = 0) noexcept;

  inline Label labelByName(const char* name, size_t nameSize = Globals::kNullTerminated, uint32_t parentId = 0) noexcept {
    return Label(labelIdByName(name, nameSize, parentId));
  }

  //! Create a new label-link used to store information about yet unbound labels.
  //!
  //! Returns `null` if the allocation failed.
  ASMJIT_API LabelLink* newLabelLink(LabelEntry* le, uint32_t sectionId, size_t offset, intptr_t rel) noexcept;

  //! Get array of `LabelEntry*` records.
  inline const ZoneVector<LabelEntry*>& labelEntries() const noexcept { return _labelEntries; }

  //! Get information about a label of the given `id`.
  inline LabelEntry* labelEntry(uint32_t id) const noexcept {
    uint32_t index = Operand::unpackId(id);
    return index < _labelEntries.size() ? _labelEntries[index] : static_cast<LabelEntry*>(nullptr);
  }
  //! Get information about the given `label`.
  inline LabelEntry* labelEntry(const Label& label) const noexcept {
    return labelEntry(label.id());
  }

  //! Get a `label` offset or -1 if the label is not yet bound.
  inline intptr_t labelOffset(uint32_t id) const noexcept {
    ASMJIT_ASSERT(isLabelValid(id));
    return _labelEntries[Operand::unpackId(id)]->offset();
  }
  //! Get a `label` offset or -1 if the label is not yet bound.
  inline intptr_t labelOffset(const Label& label) const noexcept {
    return labelOffset(label.id());
  }

  //! Get number of labels created.
  inline uint32_t labelCount() const noexcept { return _labelEntries.size(); }
  //! Get number of label references, which are unresolved at the moment.
  inline uint32_t unresolvedLabelCount() const noexcept { return _unresolvedLabelCount; }

  //! Get whether the label having `id` is valid (i.e. created by `newLabelId()`).
  inline bool isLabelValid(uint32_t labelId) const noexcept {
    uint32_t index = Operand::unpackId(labelId);
    return index < _labelEntries.size();
  }
  //! Get whether the `label` is valid (i.e. created by `newLabelId()`).
  inline bool isLabelValid(const Label& label) const noexcept {
    return isLabelValid(label.id());
  }

  //! \overload
  inline bool isLabelBound(uint32_t id) const noexcept {
    uint32_t index = Operand::unpackId(id);
    return index < _labelEntries.size() && _labelEntries[index]->isBound();
  }
  //! Get whether the `label` is already bound.
  //!
  //! Returns `false` if the `label` is not valid.
  inline bool isLabelBound(const Label& label) const noexcept {
    return isLabelBound(label.id());
  }

  // --------------------------------------------------------------------------
  // [Relocations]
  // --------------------------------------------------------------------------

  //! Get whether the code contains relocation entries.
  inline bool hasRelocEntries() const noexcept { return !_relocations.empty(); }
  //! Get array of `RelocEntry*` records.
  inline const ZoneVector<RelocEntry*>& relocEntries() const noexcept { return _relocations; }

  //! Get reloc entry of a given `id`.
  inline RelocEntry* relocEntry(uint32_t id) const noexcept { return _relocations[id]; }

  //! Create a new relocation entry of type `type` and size `size`.
  //!
  //! Additional fields can be set after the relocation entry was created.
  ASMJIT_API Error newRelocEntry(RelocEntry** dst, uint32_t type, uint32_t size) noexcept;

  //! Relocate the code to `baseAddress` and copy it to `dst`.
  //!
  //! \param dst Contains the location where the relocated code should be
  //! copied. The pointer can be address returned by virtual memory allocator
  //! or any other address that has sufficient space.
  //!
  //! \param baseAddress Base address used for relocation. `JitRuntime` always
  //! sets the `baseAddress` to be the same as `dst`.
  //!
  //! \return The number of bytes actually used. If the code emitter reserved
  //! space for possible trampolines, but didn't use it, the number of bytes
  //! used can actually be less than the expected worst case. Virtual memory
  //! allocator can shrink the memory it allocated initially.
  //!
  //! A given buffer will be overwritten, to get the number of bytes required,
  //! use `codeSize()`.
  ASMJIT_API size_t relocate(void* dst, uint64_t baseAddress = Globals::kNoBaseAddress) const noexcept;

  // --------------------------------------------------------------------------
  // [Members]
  // --------------------------------------------------------------------------

  CodeInfo _codeInfo;                    //!< Basic information about the code (architecture and other info).
  uint32_t _emitterOptions;              //!< Emitter options, propagated to all emitters when changed.

  Logger* _logger;                       //!< Attached `Logger`, used by all consumers.
  ErrorHandler* _errorHandler;           //!< Attached `ErrorHandler`.

  uint32_t _unresolvedLabelCount;        //!< Count of label references which were not resolved.
  uint32_t _trampolinesSize;             //!< Size of all possible trampolines.

  Zone _zone;                            //!< Code zone (used to allocate core structures).
  ZoneAllocator _allocator;              //!< Zone allocator, used to manage internal containers.

  ZoneVector<BaseEmitter*> _emitters;    //!< Attached code emitters.
  ZoneVector<SectionEntry*> _sectionEntries; //!< Section entries.
  ZoneVector<LabelEntry*> _labelEntries; //!< Label entries.
  ZoneVector<RelocEntry*> _relocations;  //!< Relocation entries.
  ZoneHash<LabelEntry> _namedLabels;     //!< Label name -> LabelEntry (only named labels).
};

//! \}

ASMJIT_END_NAMESPACE

// [Guard]
#endif // _ASMJIT_CORE_CODEHOLDER_H

```

`Avanguard/AsmJit/asmjit/core/compiler.h`:

```h
// [AsmJit]
// Complete x86/x64 JIT and Remote Assembler for C++.
//
// [License]
// ZLIB - See LICENSE.md file in the package.

// [Guard]
#ifndef _ASMJIT_CORE_COMPILER_H
#define _ASMJIT_CORE_COMPILER_H

#include "../core/build.h"
#ifndef ASMJIT_DISABLE_COMPILER

// [Dependencies]
#include "../core/assembler.h"
#include "../core/builder.h"
#include "../core/constpool.h"
#include "../core/func.h"
#include "../core/inst.h"
#include "../core/operand.h"
#include "../core/support.h"
#include "../core/zone.h"
#include "../core/zonevector.h"

ASMJIT_BEGIN_NAMESPACE

// ============================================================================
// [Forward Declarations]
// ============================================================================

struct RATiedReg;
class RAWorkReg;

class FuncNode;
class FuncRetNode;
class FuncCallNode;

//! \addtogroup asmjit_core_api
//! \{

// ============================================================================
// [asmjit::VirtReg]
// ============================================================================

//! Virtual register data (BaseCompiler).
class VirtReg {
public:
  ASMJIT_NONCOPYABLE(VirtReg)

  // --------------------------------------------------------------------------
  // [Init / Reset]
  // --------------------------------------------------------------------------

  inline VirtReg(uint32_t id, uint32_t signature, uint32_t virtSize, uint32_t alignment, uint32_t typeId) noexcept
    : _id(id),
      _virtSize(virtSize),
      _alignment(uint8_t(alignment)),
      _typeId(uint8_t(typeId)),
      _weight(1),
      _isFixed(false),
      _isStack(false),
      _reserved(0),
      _name(),
      _workReg(nullptr) { _info._signature = signature; }

  // --------------------------------------------------------------------------
  // [Accessors]
  // --------------------------------------------------------------------------

  //! Get VirtReg id.
  inline uint32_t id() const noexcept { return _id; }

  //! Get VirtReg name.
  inline const char* name() const noexcept { return _name.data(); }
  //! Get VirtReg name size.
  inline uint32_t nameSize() const noexcept { return _name.size(); }

  //! Get register information that wraps the register signature.
  inline const RegInfo& info() const noexcept { return _info; }
  //! Get a physical register type.
  inline uint32_t type() const noexcept { return _info.type(); }
  //! Get a physical register group.
  inline uint32_t group() const noexcept { return _info.group(); }
  //! Get a physical register size.
  inline uint32_t regSize() const noexcept { return _info.size(); }
  //! Get a register signature of this virtual register.
  inline uint32_t signature() const noexcept { return _info.signature(); }

  //! Get virtual-register's size.
  inline uint32_t virtSize() const noexcept { return _virtSize; }
  //! Get virtual-register's alignment.
  inline uint32_t alignment() const noexcept { return _alignment; }

  //! Get a register's TypeId, see `Type::Id`.
  inline uint32_t typeId() const noexcept { return _typeId; }

  //! Get VirtReg's weight - register allocator can use it as explicit hint for alloc/spill decisions.
  inline uint32_t weight() const noexcept { return _weight; }
  //! Set VirtReg's weight (0 to 255) - register allocator can use it as explicit hint for alloc/spill decisions.
  inline void setWeight(uint32_t weight) noexcept { _weight = uint8_t(weight); }

  //! Get whether the `VirtReg` is always allocated to a fixed physical register (and never reallocated).
  //!
  //! NOTE: This is only used for special purposes and it's mostly internal.
  inline bool isFixed() const noexcept { return bool(_isFixed); }

  //! Get whether the `VirtReg` is only memory allocated on the stack.
  //!
  //! NOTE: It's an error if stack is accessed as a register.
  inline bool isStack() const noexcept { return bool(_isStack); }

  inline bool hasWorkReg() const noexcept { return _workReg != nullptr; }
  inline RAWorkReg* workReg() const noexcept { return _workReg; }
  inline void setWorkReg(RAWorkReg* workReg) noexcept { _workReg = workReg; }
  inline void resetWorkReg() noexcept { _workReg = nullptr; }

  // --------------------------------------------------------------------------
  // [Members]
  // --------------------------------------------------------------------------

  uint32_t _id;                          //!< VirtReg id.
  RegInfo _info;                         //!< VirtReg info (signature).
  uint32_t _virtSize;                    //!< VirtReg size (can be smaller than `regInfo._size`).
  uint8_t _alignment;                    //!< VirtReg alignment (for spilling).
  uint8_t _typeId;                       //!< Type-id.
  uint8_t _weight;                       //!< VirtReg weight for alloc/spill decisions.
  uint8_t _isFixed : 1;                  //!< True if this is a fixed register, never reallocated.
  uint8_t _isStack : 1;                  //!< True if the virtual register is only used as a stack (never accessed as register).
  uint8_t _reserved : 6;

  ZoneString<16> _name;                 //!< VirtReg name (user provided or automatically generated).

  // -------------------------------------------------------------------------
  // The following members are used exclusively by RAPass. They are initialized
  // when the VirtReg is created to NULL pointers and then changed during RAPass
  // execution. RAPass sets them back to NULL before it returns.
  // -------------------------------------------------------------------------

  RAWorkReg* _workReg;                   //!< Reference to `RAWorkReg`, used during register allocation.
};

// ============================================================================
// [asmjit::BaseCompiler]
// ============================================================================

//! Code emitter that uses virtual registers and performs register allocation.
//!
//! Compiler is a high-level code-generation tool that provides register
//! allocation and automatic handling of function calling conventions. It was
//! primarily designed for merging multiple parts of code into a function
//! without worrying about registers and function calling conventions.
//!
//! BaseCompiler can be used, with a minimum effort, to handle 32-bit and 64-bit
//! code at the same time.
//!
//! BaseCompiler is based on BaseBuilder and contains all the features it
//! provides. It means that the code it stores can be modified (removed, added,
//! injected) and analyzed. When the code is finalized the compiler can emit
//! the code into an Assembler to translate the abstract representation into a
//! machine code.
class ASMJIT_VIRTAPI BaseCompiler : public BaseBuilder {
public:
  ASMJIT_NONCOPYABLE(BaseCompiler)
  typedef BaseBuilder Base;

  // --------------------------------------------------------------------------
  // [Construction / Destruction]
  // --------------------------------------------------------------------------

  //! Create a new `BaseCompiler` instance.
  ASMJIT_API BaseCompiler() noexcept;
  //! Destroy the `BaseCompiler` instance.
  ASMJIT_API virtual ~BaseCompiler() noexcept;

  // --------------------------------------------------------------------------
  // [Func]
  // --------------------------------------------------------------------------

  //! Get the current function.
  inline FuncNode* func() const noexcept { return _func; }

  //! Create a new `FuncNode`.
  ASMJIT_API FuncNode* newFunc(const FuncSignature& sign) noexcept;
  //! Add a function `node` to the stream.
  ASMJIT_API FuncNode* addFunc(FuncNode* func);
  //! Add a new function.
  ASMJIT_API FuncNode* addFunc(const FuncSignature& sign);
  //! Emit a sentinel that marks the end of the current function.
  ASMJIT_API Error endFunc();

  // --------------------------------------------------------------------------
  // [Ret]
  // --------------------------------------------------------------------------

  //! Create a new `FuncRetNode`.
  ASMJIT_API FuncRetNode* newRet(const Operand_& o0, const Operand_& o1) noexcept;
  //! Add a new `FuncRetNode`.
  ASMJIT_API FuncRetNode* addRet(const Operand_& o0, const Operand_& o1) noexcept;

  // --------------------------------------------------------------------------
  // [Call]
  // --------------------------------------------------------------------------

  //! Create a new `FuncCallNode`.
  ASMJIT_API FuncCallNode* newCall(uint32_t instId, const Operand_& o0, const FuncSignature& sign) noexcept;
  //! Add a new `FuncCallNode`.
  ASMJIT_API FuncCallNode* addCall(uint32_t instId, const Operand_& o0, const FuncSignature& sign) noexcept;

  // --------------------------------------------------------------------------
  // [Args]
  // --------------------------------------------------------------------------

  //! Set a function argument at `argIndex` to `reg`.
  ASMJIT_API Error setArg(uint32_t argIndex, const BaseReg& reg);

  // --------------------------------------------------------------------------
  // [VirtReg / Stack]
  // --------------------------------------------------------------------------

  //! Create a new virtual register representing the given `typeId` and `signature`.
  ASMJIT_API VirtReg* newVirtReg(uint32_t typeId, uint32_t signature, const char* name) noexcept;

  ASMJIT_API Error _newReg(BaseReg& out, uint32_t typeId, const char* name = nullptr);
  ASMJIT_API Error _newReg(BaseReg& out, uint32_t typeId, const char* fmt, std::va_list ap);

  ASMJIT_API Error _newReg(BaseReg& out, const BaseReg& ref, const char* name = nullptr);
  ASMJIT_API Error _newReg(BaseReg& out, const BaseReg& ref, const char* fmt, std::va_list ap);

  ASMJIT_API Error _newStack(BaseMem& out, uint32_t size, uint32_t alignment, const char* name = nullptr);
  ASMJIT_API Error _newConst(BaseMem& out, uint32_t scope, const void* data, size_t size);

  //! Get whether the given `id` is a valid virtual register id.
  inline bool isVirtIdValid(uint32_t id) const noexcept {
    uint32_t index = Operand::unpackId(id);
    return index < _vRegArray.size();
  }
  //! Get whether the given `reg` is a valid virtual register having a valid id.
  inline bool isVirtRegValid(const BaseReg& reg) const noexcept {
    return isVirtIdValid(reg.id());
  }

  //! Get `VirtReg` associated with the given `id`.
  inline VirtReg* virtRegById(uint32_t id) const noexcept {
    uint32_t index = Operand::unpackId(id);
    ASMJIT_ASSERT(index < _vRegArray.size());
    return _vRegArray[index];
  }
  //! Get `VirtReg` associated with the given `reg`.
  inline VirtReg* virtRegByReg(const BaseReg& reg) const noexcept { return virtRegById(reg.id()); }
  //! Get `VirtReg` associated with the given `index`.
  inline VirtReg* virtRegByIndex(uint32_t index) const noexcept { return _vRegArray[index]; }

  //! Get an array of all virtual registers managed by `BaseCompiler`.
  inline const ZoneVector<VirtReg*>& virtRegs() const noexcept { return _vRegArray; }

  //! Rename variable `reg` to `name`.
  //!
  //! NOTE: Only new name will appear in the logger.
  ASMJIT_API void rename(BaseReg& reg, const char* fmt, ...);

  // TODO:
  inline void alloc(BaseReg& reg) { ASMJIT_UNUSED(reg); }
  inline void spill(BaseReg& reg) { ASMJIT_UNUSED(reg); }

  // --------------------------------------------------------------------------
  // [Events]
  // --------------------------------------------------------------------------

  ASMJIT_API Error onAttach(CodeHolder* code) noexcept override;
  ASMJIT_API Error onDetach(CodeHolder* code) noexcept override;

  // --------------------------------------------------------------------------
  // [Members]
  // --------------------------------------------------------------------------

  FuncNode* _func;                       //!< Current function.

  Zone _vRegZone;                        //!< Allocates `VirtReg` objects.
  ZoneVector<VirtReg*> _vRegArray;       //!< Stores array of `VirtReg` pointers.

  ConstPoolNode* _localConstPool;        //!< Local constant pool, flushed at the end of each function.
  ConstPoolNode* _globalConstPool;       //!< Global constant pool, flushed by `finalize()`.
};

// ============================================================================
// [asmjit::FuncNode]
// ============================================================================

//! Function entry (BaseCompiler).
class FuncNode : public LabelNode {
public:
  ASMJIT_NONCOPYABLE(FuncNode)

  // --------------------------------------------------------------------------
  // [Construction / Destruction]
  // --------------------------------------------------------------------------

  //! Create a new `FuncNode` instance.
  //!
  //! Always use `BaseCompiler::addFunc()` to create `FuncNode`.
  ASMJIT_INLINE FuncNode(BaseBuilder* cb) noexcept
    : LabelNode(cb),
      _funcDetail(),
      _frame(),
      _exitNode(nullptr),
      _end(nullptr),
      _args(nullptr) {
    setType(kNodeFunc);
  }

  // --------------------------------------------------------------------------
  // [Accessors]
  // --------------------------------------------------------------------------

  //! Get function exit `LabelNode`.
  inline LabelNode* exitNode() const noexcept { return _exitNode; }
  //! Get function exit label.
  inline Label exitLabel() const noexcept { return _exitNode->label(); }

  //! Get "End of Func" sentinel.
  inline SentinelNode* endNode() const noexcept { return _end; }

  //! Get function declaration.
  inline FuncDetail& detail() noexcept { return _funcDetail; }
  //! Get function declaration.
  inline const FuncDetail& detail() const noexcept { return _funcDetail; }

  //! Get function frame.
  inline FuncFrame& frame() noexcept { return _frame; }
  //! Get function frame.
  inline const FuncFrame& frame() const noexcept { return _frame; }

  //! Get arguments count.
  inline uint32_t argCount() const noexcept { return _funcDetail.argCount(); }
  //! Get returns count.
  inline uint32_t retCount() const noexcept { return _funcDetail.retCount(); }

  //! Get arguments list.
  inline VirtReg** args() const noexcept { return _args; }

  //! Get argument at `i`.
  inline VirtReg* arg(uint32_t i) const noexcept {
    ASMJIT_ASSERT(i < argCount());
    return _args[i];
  }

  //! Set argument at `i`.
  inline void setArg(uint32_t i, VirtReg* vReg) noexcept {
    ASMJIT_ASSERT(i < argCount());
    _args[i] = vReg;
  }

  //! Reset argument at `i`.
  inline void resetArg(uint32_t i) noexcept {
    ASMJIT_ASSERT(i < argCount());
    _args[i] = nullptr;
  }

  inline uint32_t attributes() const noexcept { return _frame.attributes(); }
  inline void addAttributes(uint32_t attrs) noexcept { _frame.addAttributes(attrs); }

  // --------------------------------------------------------------------------
  // [Members]
  // --------------------------------------------------------------------------

  FuncDetail _funcDetail;                //!< Function detail.
  FuncFrame _frame;                      //!< Function frame.

  LabelNode* _exitNode;                  //!< Function exit (label).
  SentinelNode* _end;                    //!< Function end (sentinel).

  VirtReg** _args;                       //!< Arguments array as `VirtReg`.
};

// ============================================================================
// [asmjit::FuncRetNode]
// ============================================================================

//! Function return (BaseCompiler).
class FuncRetNode : public InstNode {
public:
  ASMJIT_NONCOPYABLE(FuncRetNode)

  // --------------------------------------------------------------------------
  // [Construction / Destruction]
  // --------------------------------------------------------------------------

  //! Create a new `FuncRetNode` instance.
  inline FuncRetNode(BaseBuilder* cb) noexcept : InstNode(cb, BaseInst::kIdAbstract, 0, 0) {
    _any._nodeType = kNodeFuncRet;
  }
};

// ============================================================================
// [asmjit::FuncCallNode]
// ============================================================================

//! Function call (BaseCompiler).
class FuncCallNode : public InstNode {
public:
  ASMJIT_NONCOPYABLE(FuncCallNode)

  // --------------------------------------------------------------------------
  // [Construction / Destruction]
  // --------------------------------------------------------------------------

  //! Create a new `FuncCallNode` instance.
  inline FuncCallNode(BaseBuilder* cb, uint32_t instId, uint32_t options) noexcept
    : InstNode(cb, instId, options, kBaseOpCapacity),
      _funcDetail(),
      _args(nullptr) {
    setType(kNodeFuncCall);
    _resetOps();
    _rets[0].reset();
    _rets[1].reset();
    addFlags(kFlagIsRemovable);
  }

  // --------------------------------------------------------------------------
  // [Signature]
  // --------------------------------------------------------------------------

  //! Set function signature.
  inline Error setSignature(const FuncSignature& sign) noexcept {
    return _funcDetail.init(sign);
  }

  // --------------------------------------------------------------------------
  // [Accessors]
  // --------------------------------------------------------------------------

  //! Get function declaration.
  inline FuncDetail& detail() noexcept { return _funcDetail; }
  //! Get function declaration.
  inline const FuncDetail& detail() const noexcept { return _funcDetail; }

  //! Get target operand.
  inline Operand& target() noexcept { return _opArray[0].as<Operand>(); }
  //! \overload
  inline const Operand& target() const noexcept { return _opArray[0].as<Operand>(); }

  //! Get number of function arguments.
  inline uint32_t argCount() const noexcept { return _funcDetail.argCount(); }
  //! Get number of function returns.
  inline uint32_t retCount() const noexcept { return _funcDetail.retCount(); }

  //! Get return at `i`.
  inline Operand& ret(uint32_t i = 0) noexcept {
    ASMJIT_ASSERT(i < 2);
    return _rets[i].as<Operand>();
  }
  //! \overload
  inline const Operand& ret(uint32_t i = 0) const noexcept {
    ASMJIT_ASSERT(i < 2);
    return _rets[i].as<Operand>();
  }

  //! Get argument at `i`.
  inline Operand& arg(uint32_t i) noexcept {
    ASMJIT_ASSERT(i < kFuncArgCountLoHi);
    return _args[i].as<Operand>();
  }
  //! \overload
  inline const Operand& arg(uint32_t i) const noexcept {
    ASMJIT_ASSERT(i < kFuncArgCountLoHi);
    return _args[i].as<Operand>();
  }

  //! Set argument at `i` to `op`.
  ASMJIT_API bool _setArg(uint32_t i, const Operand_& op) noexcept;
  //! Set return at `i` to `op`.
  ASMJIT_API bool _setRet(uint32_t i, const Operand_& op) noexcept;

  //! Set argument at `i` to `reg`.
  inline bool setArg(uint32_t i, const BaseReg& reg) noexcept { return _setArg(i, reg); }
  //! Set argument at `i` to `imm`.
  inline bool setArg(uint32_t i, const Imm& imm) noexcept { return _setArg(i, imm); }

  //! Set return at `i` to `var`.
  inline bool setRet(uint32_t i, const BaseReg& reg) noexcept { return _setRet(i, reg); }

  // --------------------------------------------------------------------------
  // [Members]
  // --------------------------------------------------------------------------

  FuncDetail _funcDetail;                //!< Function detail.
  Operand_ _rets[2];                     //!< Returns.
  Operand_* _args;                       //!< Arguments.
};

// ============================================================================
// [asmjit::FuncPass]
// ============================================================================

class ASMJIT_VIRTAPI FuncPass : public Pass {
public:
  ASMJIT_NONCOPYABLE(FuncPass)
  typedef Pass Base;

  ASMJIT_API FuncPass(const char* name) noexcept;

  // --------------------------------------------------------------------------
  // [Run]
  // --------------------------------------------------------------------------

  //! Calls `runOnFunction()` on each `FuncNode` node found.
  ASMJIT_API Error run(Zone* zone, Logger* logger) noexcept override;

  //! Called once per `FuncNode`.
  virtual Error runOnFunction(Zone* zone, Logger* logger, FuncNode* func) noexcept = 0;

  // --------------------------------------------------------------------------
  // [Accessors]
  // --------------------------------------------------------------------------

  //! Get the associated `BaseCompiler`.
  inline BaseCompiler* cc() const noexcept { return static_cast<BaseCompiler*>(_cb); }
};

//! \}

ASMJIT_END_NAMESPACE

// [Guard]
#endif // !ASMJIT_DISABLE_COMPILER
#endif // _ASMJIT_CORE_COMPILER_H

```

`Avanguard/AsmJit/asmjit/core/constpool.h`:

```h
// [AsmJit]
// Complete x86/x64 JIT and Remote Assembler for C++.
//
// [License]
// ZLIB - See LICENSE.md file in the package.

// [Guard]
#ifndef _ASMJIT_CORE_CONSTPOOL_H
#define _ASMJIT_CORE_CONSTPOOL_H

// [Dependencies]
#include "../core/zone.h"
#include "../core/zonetree.h"

ASMJIT_BEGIN_NAMESPACE

//! \addtogroup asmjit_core_api
//! \{

// ============================================================================
// [asmjit::ConstPool]
// ============================================================================

//! Constant pool.
class ConstPool {
public:
  ASMJIT_NONCOPYABLE(ConstPool)

  //! Constant pool scope.
  enum Scope : uint32_t {
    //! Local constant, always embedded right after the current function.
    kScopeLocal = 0,
    //! Global constant, embedded at the end of the currently compiled code.
    kScopeGlobal = 1
  };

  //! Index of a given size in const-pool table.
  enum Index : uint32_t {
    kIndex1 = 0,
    kIndex2 = 1,
    kIndex4 = 2,
    kIndex8 = 3,
    kIndex16 = 4,
    kIndex32 = 5,
    kIndexCount = 6
  };

  //! Zone-allocated const-pool gap created by two differently aligned constants.
  struct Gap {
    Gap* _next;                          //!< Pointer to the next gap
    size_t _offset;                      //!< Offset of the gap.
    size_t _size;                        //!< Remaining bytes of the gap (basically a gap size).
  };

  //! Zone-allocated const-pool node.
  class Node : public ZoneTreeNodeT<Node> {
  public:
    ASMJIT_NONCOPYABLE(Node)

    inline Node(size_t offset, bool shared) noexcept
      : ZoneTreeNodeT<Node>(),
        _shared(shared),
        _offset(uint32_t(offset)) {}

    inline void* data() const noexcept {
      return static_cast<void*>(const_cast<ConstPool::Node*>(this) + 1);
    }

    uint32_t _shared : 1;                //!< If this constant is shared with another.
    uint32_t _offset;                    //!< Data offset from the beginning of the pool.
  };

  class Compare {
  public:
    inline Compare(size_t dataSize) noexcept
      : _dataSize(dataSize) {}

    inline int operator()(const Node& a, const Node& b) const noexcept {
      return std::memcmp(a.data(), b.data(), _dataSize);
    }

    inline int operator()(const Node& a, const void* data) const noexcept {
      return std::memcmp(a.data(), data, _dataSize);
    }

    size_t _dataSize;
  };

  // --------------------------------------------------------------------------
  // [Tree]
  // --------------------------------------------------------------------------

  //! \internal
  //!
  //! Zone-allocated const-pool tree.
  struct Tree {
    // --------------------------------------------------------------------------
    // [Construction / Destruction]
    // --------------------------------------------------------------------------

    inline explicit Tree(size_t dataSize = 0) noexcept
      : _tree(),
        _size(0),
        _dataSize(dataSize) {}

    // --------------------------------------------------------------------------
    // [Reset]
    // --------------------------------------------------------------------------

    inline void reset() noexcept {
      _tree.reset();
      _size = 0;
    }

    // --------------------------------------------------------------------------
    // [Accessors]
    // --------------------------------------------------------------------------

    inline bool empty() const noexcept { return _size == 0; }
    inline size_t size() const noexcept { return _size; }

    inline void setDataSize(size_t dataSize) noexcept {
      ASMJIT_ASSERT(empty());
      _dataSize = dataSize;
    }

    // --------------------------------------------------------------------------
    // [Ops]
    // --------------------------------------------------------------------------

    inline Node* get(const void* data) noexcept {
      Compare cmp(_dataSize);
      return _tree.get(data, cmp);
    }

    inline void insert(Node* node) noexcept {
      Compare cmp(_dataSize);
      _tree.insert(node, cmp);
      _size++;
    }

    // --------------------------------------------------------------------------
    // [ForEach]
    // --------------------------------------------------------------------------

    template<typename Visitor>
    inline void forEach(Visitor& visitor) const noexcept {
      Node* node = _tree.root();
      if (!node) return;

      Node* stack[Globals::kMaxTreeHeight];
      size_t top = 0;

      for (;;) {
        Node* left = node->left();
        if (left != nullptr) {
          ASMJIT_ASSERT(top != Globals::kMaxTreeHeight);
          stack[top++] = node;

          node = left;
          continue;
        }

        for (;;) {
          visitor(node);
          node = node->right();

          if (node != nullptr)
            break;

          if (top == 0)
            return;

          node = stack[--top];
        }
      }
    }

    // --------------------------------------------------------------------------
    // [Helpers]
    // --------------------------------------------------------------------------

    static inline Node* _newNode(Zone* zone, const void* data, size_t size, size_t offset, bool shared) noexcept {
      Node* node = zone->allocT<Node>(sizeof(Node) + size);
      if (ASMJIT_UNLIKELY(!node)) return nullptr;

      node = new(node) Node(offset, shared);
      std::memcpy(node->data(), data, size);
      return node;
    }

    // --------------------------------------------------------------------------
    // [Members]
    // --------------------------------------------------------------------------

    ZoneTree<Node> _tree;                //!< RB tree.
    size_t _size;                        //!< Size of the tree (number of nodes).
    size_t _dataSize;                    //!< Size of the data.
  };

  // --------------------------------------------------------------------------
  // [Construction / Destruction]
  // --------------------------------------------------------------------------

  ASMJIT_API ConstPool(Zone* zone) noexcept;
  ASMJIT_API ~ConstPool() noexcept;

  // --------------------------------------------------------------------------
  // [Reset]
  // --------------------------------------------------------------------------

  ASMJIT_API void reset(Zone* zone) noexcept;

  // --------------------------------------------------------------------------
  // [Ops]
  // --------------------------------------------------------------------------

  //! Get whether the constant-pool is empty.
  inline bool empty() const noexcept { return _size == 0; }
  //! Get the size of the constant-pool in bytes.
  inline size_t size() const noexcept { return _size; }
  //! Get minimum alignment.
  inline size_t alignment() const noexcept { return _alignment; }

  //! Add a constant to the constant pool.
  //!
  //! The constant must have known size, which is 1, 2, 4, 8, 16 or 32 bytes.
  //! The constant is added to the pool only if it doesn't not exist, otherwise
  //! cached value is returned.
  //!
  //! AsmJit is able to subdivide added constants, so for example if you add
  //! 8-byte constant 0x1122334455667788 it will create the following slots:
  //!
  //!   8-byte: 0x1122334455667788
  //!   4-byte: 0x11223344, 0x55667788
  //!
  //! The reason is that when combining MMX/SSE/AVX code some patterns are used
  //! frequently. However, AsmJit is not able to reallocate a constant that has
  //! been already added. For example if you try to add 4-byte constant and then
  //! 8-byte constant having the same 4-byte pattern as the previous one, two
  //! independent slots will be generated by the pool.
  ASMJIT_API Error add(const void* data, size_t size, size_t& dstOffset) noexcept;

  // --------------------------------------------------------------------------
  // [Fill]
  // --------------------------------------------------------------------------

  //! Fill the destination with the constants from the pool.
  ASMJIT_API void fill(void* dst) const noexcept;

  // --------------------------------------------------------------------------
  // [Members]
  // --------------------------------------------------------------------------

  Zone* _zone;                           //!< Zone allocator.
  Tree _tree[kIndexCount];               //!< Tree per size.
  Gap* _gaps[kIndexCount];               //!< Gaps per size.
  Gap* _gapPool;                         //!< Gaps pool

  size_t _size;                          //!< Size of the pool (in bytes).
  size_t _alignment;                     //!< Required pool alignment.
};

//! \}

ASMJIT_END_NAMESPACE

// [Guard]
#endif // _ASMJIT_CORE_CONSTPOOL_H

```

`Avanguard/AsmJit/asmjit/core/cpuinfo.h`:

```h
// [AsmJit]
// Complete x86/x64 JIT and Remote Assembler for C++.
//
// [License]
// ZLIB - See LICENSE.md file in the package.

// [Guard]
#ifndef _ASMJIT_CORE_CPUINFO_H
#define _ASMJIT_CORE_CPUINFO_H

// [Dependencies]
#include "../core/arch.h"
#include "../core/features.h"
#include "../core/stringutils.h"

ASMJIT_BEGIN_NAMESPACE

//! \addtogroup asmjit_core_support
//! \{

// ============================================================================
// [asmjit::CpuInfo]
// ============================================================================

//! CPU information.
class CpuInfo {
public:
  // --------------------------------------------------------------------------
  // [X86Info]
  // --------------------------------------------------------------------------

  struct X86Data {
    uint32_t _processorType;             //!< Processor type.
    uint32_t _brandIndex;                //!< Brand index.
    uint32_t _maxLogicalProcessors;      //!< Maximum number of addressable IDs for logical processors.
  };

  // --------------------------------------------------------------------------
  // [Construction / Destruction]
  // --------------------------------------------------------------------------

  inline CpuInfo() noexcept { reset(); }
  inline CpuInfo(const CpuInfo& other) noexcept = default;

  // --------------------------------------------------------------------------
  // [Init / Reset]
  // --------------------------------------------------------------------------

  //! Initialize CpuInfo to the given architecture, see `ArchInfo`.
  inline void initArch(uint32_t archId, uint32_t archMode = 0) noexcept {
    _archInfo.init(archId, archMode);
  }

  inline void reset() noexcept { std::memset(this, 0, sizeof(*this)); }

  // --------------------------------------------------------------------------
  // [Accessors]
  // --------------------------------------------------------------------------

  //! Get generic architecture information.
  inline const ArchInfo& archInfo() const noexcept { return _archInfo; }
  //! Get CPU architecture type, see `ArchInfo::Id`.
  inline uint32_t archId() const noexcept { return _archInfo.archId(); }
  //! Get CPU architecture sub-type, see `ArchInfo::SubType`.
  inline uint32_t archSubId() const noexcept { return _archInfo.archSubId(); }

  //! Get CPU family ID.
  inline uint32_t familyId() const noexcept { return _familyId; }
  //! Get CPU model ID.
  inline uint32_t modelId() const noexcept { return _modelId; }
  //! Get CPU stepping.
  inline uint32_t stepping() const noexcept { return _stepping; }

  //! Get the size of a cache line flush.
  inline uint32_t cacheLineSize() const noexcept { return _cacheLineSize; }
  //! Get number of hardware threads available.
  inline uint32_t hwThreadCount() const noexcept { return _hwThreadCount; }

  //! Get CPU vendor.
  inline const char* vendor() const noexcept { return _vendor.str; }
  //! Check whether the CPU vendor is equal to string `s`.
  inline bool isVendor(const char* s) const noexcept { return _vendor.test(s); }

  //! Get CPU brand string.
  inline const char* brand() const noexcept { return _brand.str; }

  //! Get all CPU features as `BaseFeatures`, cast to your arch-specific class if needed.
  template<typename T = BaseFeatures>
  inline const T& features() const noexcept { return _features.as<T>(); }

  //! Get whether CPU has a `feature`.
  inline bool hasFeature(uint32_t featureId) const noexcept { return _features.has(featureId); }
  //! Add a CPU `feature`.
  inline CpuInfo& addFeature(uint32_t featureId) noexcept { _features.add(featureId); return *this; }

  //! Get CPU type.
  inline uint32_t x86ProcessorType() const noexcept { return _x86Data._processorType; }
  //! Get CPU brand index.
  inline uint32_t x86BrandIndex() const noexcept { return _x86Data._brandIndex; }
  //! Get the number of maximum logical processors.
  inline uint32_t x86MaxLogicalProcessors() const noexcept { return _x86Data._maxLogicalProcessors; }

  // --------------------------------------------------------------------------
  // [Statics]
  // --------------------------------------------------------------------------

  //! Get the host CPU information.
  ASMJIT_API static const CpuInfo& host() noexcept;

  // --------------------------------------------------------------------------
  // [Operator Overload]
  // --------------------------------------------------------------------------

  inline CpuInfo& operator=(const CpuInfo& other) noexcept = default;

  // --------------------------------------------------------------------------
  // [Members]
  // --------------------------------------------------------------------------

  ArchInfo _archInfo;                    //!< CPU architecture information.
  uint32_t _familyId;                    //!< CPU family ID.
  uint32_t _modelId;                     //!< CPU model ID.
  uint32_t _stepping;                    //!< CPU stepping.
  uint32_t _cacheLineSize;               //!< Cache line size (in bytes).
  uint32_t _hwThreadCount;               //!< Number of hardware threads.

  StaticString<16> _vendor;              //!< CPU vendor string.
  StaticString<64> _brand;               //!< CPU brand string.
  BaseFeatures _features;                //!< CPU features.

  // Architecture specific data.
  X86Data _x86Data;
};

//! \}

ASMJIT_END_NAMESPACE

// [Guard]
#endif // _ASMJIT_CORE_CPUINFO_H

```

`Avanguard/AsmJit/asmjit/core/datatypes.h`:

```h
// [AsmJit]
// Complete x86/x64 JIT and Remote Assembler for C++.
//
// [License]
// ZLIB - See LICENSE.md file in the package.

// [Guard]
#ifndef _ASMJIT_CORE_DATATYPES_H
#define _ASMJIT_CORE_DATATYPES_H

// [Dependencies]
#include "../core/globals.h"

ASMJIT_BEGIN_NAMESPACE

//! \addtogroup asmjit_core_api
//! \{

// ============================================================================
// [asmjit::Data64]
// ============================================================================

//! 64-bit data useful for creating SIMD constants.
union Data64 {
  // --------------------------------------------------------------------------
  // [Construction / Destruction]
  // --------------------------------------------------------------------------

  //! Set all eight 8-bit signed integers.
  static inline Data64 fromI8(int8_t x0) noexcept {
    Data64 self;
    self.setI8(x0);
    return self;
  }

  //! Set all eight 8-bit unsigned integers.
  static inline Data64 fromU8(uint8_t x0) noexcept {
    Data64 self;
    self.setU8(x0);
    return self;
  }

  //! Set all eight 8-bit signed integers.
  static inline Data64 fromI8(
    int8_t x0, int8_t x1, int8_t x2, int8_t x3, int8_t x4, int8_t x5, int8_t x6, int8_t x7) noexcept {

    Data64 self;
    self.setI8(x0, x1, x2, x3, x4, x5, x6, x7);
    return self;
  }

  //! Set all eight 8-bit unsigned integers.
  static inline Data64 fromU8(
    uint8_t x0, uint8_t x1, uint8_t x2, uint8_t x3, uint8_t x4, uint8_t x5, uint8_t x6, uint8_t x7) noexcept {

    Data64 self;
    self.setU8(x0, x1, x2, x3, x4, x5, x6, x7);
    return self;
  }

  //! Set all four 16-bit signed integers.
  static inline Data64 fromI16(int16_t x0) noexcept {
    Data64 self;
    self.setI16(x0);
    return self;
  }

  //! Set all four 16-bit unsigned integers.
  static inline Data64 fromU16(uint16_t x0) noexcept {
    Data64 self;
    self.setU16(x0);
    return self;
  }

  //! Set all four 16-bit signed integers.
  static inline Data64 fromI16(int16_t x0, int16_t x1, int16_t x2, int16_t x3) noexcept {
    Data64 self;
    self.setI16(x0, x1, x2, x3);
    return self;
  }

  //! Set all four 16-bit unsigned integers.
  static inline Data64 fromU16(uint16_t x0, uint16_t x1, uint16_t x2, uint16_t x3) noexcept {
    Data64 self;
    self.setU16(x0, x1, x2, x3);
    return self;
  }

  //! Set all two 32-bit signed integers.
  static inline Data64 fromI32(int32_t x0) noexcept {
    Data64 self;
    self.setI32(x0);
    return self;
  }

  //! Set all two 32-bit unsigned integers.
  static inline Data64 fromU32(uint32_t x0) noexcept {
    Data64 self;
    self.setU32(x0);
    return self;
  }

  //! Set all two 32-bit signed integers.
  static inline Data64 fromI32(int32_t x0, int32_t x1) noexcept {
    Data64 self;
    self.setI32(x0, x1);
    return self;
  }

  //! Set all two 32-bit unsigned integers.
  static inline Data64 fromU32(uint32_t x0, uint32_t x1) noexcept {
    Data64 self;
    self.setU32(x0, x1);
    return self;
  }

  //! Set 64-bit signed integer.
  static inline Data64 fromI64(int64_t x0) noexcept {
    Data64 self;
    self.setI64(x0);
    return self;
  }

  //! Set 64-bit unsigned integer.
  static inline Data64 fromU64(uint64_t x0) noexcept {
    Data64 self;
    self.setU64(x0);
    return self;
  }

  //! Set all two SP-FP values.
  static inline Data64 fromF32(float x0) noexcept {
    Data64 self;
    self.setF32(x0);
    return self;
  }

  //! Set all two SP-FP values.
  static inline Data64 fromF32(float x0, float x1) noexcept {
    Data64 self;
    self.setF32(x0, x1);
    return self;
  }

  //! Set all two SP-FP values.
  static inline Data64 fromF64(double x0) noexcept {
    Data64 self;
    self.setF64(x0);
    return self;
  }

  // --------------------------------------------------------------------------
  // [Accessors]
  // --------------------------------------------------------------------------

  //! Set all eight 8-bit signed integers.
  inline void setI8(int8_t x0) noexcept {
    setU8(uint8_t(x0));
  }

  //! Set all eight 8-bit unsigned integers.
  inline void setU8(uint8_t x0) noexcept {
    if (ASMJIT_ARCH_BITS >= 64) {
      uint64_t xq = uint64_t(x0) * 0x0101010101010101u;
      uq[0] = xq;
    }
    else {
      uint32_t xd = uint32_t(x0) * 0x01010101u;
      ud[0] = xd;
      ud[1] = xd;
    }
  }

  //! Set all eight 8-bit signed integers.
  inline void setI8(
    int8_t x0, int8_t x1, int8_t x2, int8_t x3, int8_t x4, int8_t x5, int8_t x6, int8_t x7) noexcept {

    sb[0] = x0; sb[1] = x1; sb[2] = x2; sb[3] = x3;
    sb[4] = x4; sb[5] = x5; sb[6] = x6; sb[7] = x7;
  }

  //! Set all eight 8-bit unsigned integers.
  inline void setU8(
    uint8_t x0, uint8_t x1, uint8_t x2, uint8_t x3, uint8_t x4, uint8_t x5, uint8_t x6, uint8_t x7) noexcept {

    ub[0] = x0; ub[1] = x1; ub[2] = x2; ub[3] = x3;
    ub[4] = x4; ub[5] = x5; ub[6] = x6; ub[7] = x7;
  }

  //! Set all four 16-bit signed integers.
  inline void setI16(int16_t x0) noexcept {
    setU16(uint16_t(x0));
  }

  //! Set all four 16-bit unsigned integers.
  inline void setU16(uint16_t x0) noexcept {
    if (ASMJIT_ARCH_BITS >= 64) {
      uint64_t xq = uint64_t(x0) * 0x0001000100010001u;
      uq[0] = xq;
    }
    else {
      uint32_t xd = uint32_t(x0) * 0x00010001u;
      ud[0] = xd;
      ud[1] = xd;
    }
  }

  //! Set all four 16-bit signed integers.
  inline void setI16(int16_t x0, int16_t x1, int16_t x2, int16_t x3) noexcept {
    sw[0] = x0; sw[1] = x1; sw[2] = x2; sw[3] = x3;
  }

  //! Set all four 16-bit unsigned integers.
  inline void setU16(uint16_t x0, uint16_t x1, uint16_t x2, uint16_t x3) noexcept {
    uw[0] = x0; uw[1] = x1; uw[2] = x2; uw[3] = x3;
  }

  //! Set all two 32-bit signed integers.
  inline void setI32(int32_t x0) noexcept {
    sd[0] = x0; sd[1] = x0;
  }

  //! Set all two 32-bit unsigned integers.
  inline void setU32(uint32_t x0) noexcept {
    ud[0] = x0; ud[1] = x0;
  }

  //! Set all two 32-bit signed integers.
  inline void setI32(int32_t x0, int32_t x1) noexcept {
    sd[0] = x0; sd[1] = x1;
  }

  //! Set all two 32-bit unsigned integers.
  inline void setU32(uint32_t x0, uint32_t x1) noexcept {
    ud[0] = x0; ud[1] = x1;
  }

  //! Set 64-bit signed integer.
  inline void setI64(int64_t x0) noexcept {
    sq[0] = x0;
  }

  //! Set 64-bit unsigned integer.
  inline void setU64(uint64_t x0) noexcept {
    uq[0] = x0;
  }

  //! Set all two SP-FP values.
  inline void setF32(float x0) noexcept {
    sf[0] = x0; sf[1] = x0;
  }

  //! Set all two SP-FP values.
  inline void setF32(float x0, float x1) noexcept {
    sf[0] = x0; sf[1] = x1;
  }

  //! Set all two SP-FP values.
  inline void setF64(double x0) noexcept {
    df[0] = x0;
  }

  // --------------------------------------------------------------------------
  // [Members]
  // --------------------------------------------------------------------------

  //! Array of eight 8-bit signed integers.
  int8_t sb[8];
  //! Array of eight 8-bit unsigned integers.
  uint8_t ub[8];
  //! Array of four 16-bit signed integers.
  int16_t sw[4];
  //! Array of four 16-bit unsigned integers.
  uint16_t uw[4];
  //! Array of two 32-bit signed integers.
  int32_t sd[2];
  //! Array of two 32-bit unsigned integers.
  uint32_t ud[2];
  //! Array of one 64-bit signed integer.
  int64_t sq[1];
  //! Array of one 64-bit unsigned integer.
  uint64_t uq[1];

  //! Array of two SP-FP values.
  float sf[2];
  //! Array of one DP-FP value.
  double df[1];
};

// ============================================================================
// [asmjit::Data128]
// ============================================================================

//! 128-bit data useful for creating SIMD constants.
union Data128 {
  // --------------------------------------------------------------------------
  // [Construction / Destruction]
  // --------------------------------------------------------------------------

  //! Set all sixteen 8-bit signed integers.
  static inline Data128 fromI8(int8_t x0) noexcept {
    Data128 self;
    self.setI8(x0);
    return self;
  }

  //! Set all sixteen 8-bit unsigned integers.
  static inline Data128 fromU8(uint8_t x0) noexcept {
    Data128 self;
    self.setU8(x0);
    return self;
  }

  //! Set all sixteen 8-bit signed integers.
  static inline Data128 fromI8(
    int8_t x0 , int8_t x1 , int8_t x2 , int8_t x3 ,
    int8_t x4 , int8_t x5 , int8_t x6 , int8_t x7 ,
    int8_t x8 , int8_t x9 , int8_t x10, int8_t x11,
    int8_t x12, int8_t x13, int8_t x14, int8_t x15) noexcept {

    Data128 self;
    self.setI8(x0, x1, x2, x3, x4, x5, x6, x7, x8, x9, x10, x11, x12, x13, x14, x15);
    return self;
  }

  //! Set all sixteen 8-bit unsigned integers.
  static inline Data128 fromU8(
    uint8_t x0 , uint8_t x1 , uint8_t x2 , uint8_t x3 ,
    uint8_t x4 , uint8_t x5 , uint8_t x6 , uint8_t x7 ,
    uint8_t x8 , uint8_t x9 , uint8_t x10, uint8_t x11,
    uint8_t x12, uint8_t x13, uint8_t x14, uint8_t x15) noexcept {

    Data128 self;
    self.setU8(x0, x1, x2, x3, x4, x5, x6, x7, x8, x9, x10, x11, x12, x13, x14, x15);
    return self;
  }

  //! Set all eight 16-bit signed integers.
  static inline Data128 fromI16(int16_t x0) noexcept {
    Data128 self;
    self.setI16(x0);
    return self;
  }

  //! Set all eight 16-bit unsigned integers.
  static inline Data128 fromU16(uint16_t x0) noexcept {
    Data128 self;
    self.setU16(x0);
    return self;
  }

  //! Set all eight 16-bit signed integers.
  static inline Data128 fromI16(
    int16_t x0, int16_t x1, int16_t x2, int16_t x3, int16_t x4, int16_t x5, int16_t x6, int16_t x7) noexcept {

    Data128 self;
    self.setI16(x0, x1, x2, x3, x4, x5, x6, x7);
    return self;
  }

  //! Set all eight 16-bit unsigned integers.
  static inline Data128 fromU16(
    uint16_t x0, uint16_t x1, uint16_t x2, uint16_t x3, uint16_t x4, uint16_t x5, uint16_t x6, uint16_t x7) noexcept {

    Data128 self;
    self.setU16(x0, x1, x2, x3, x4, x5, x6, x7);
    return self;
  }

  //! Set all four 32-bit signed integers.
  static inline Data128 fromI32(int32_t x0) noexcept {
    Data128 self;
    self.setI32(x0);
    return self;
  }

  //! Set all four 32-bit unsigned integers.
  static inline Data128 fromU32(uint32_t x0) noexcept {
    Data128 self;
    self.setU32(x0);
    return self;
  }

  //! Set all four 32-bit signed integers.
  static inline Data128 fromI32(int32_t x0, int32_t x1, int32_t x2, int32_t x3) noexcept {
    Data128 self;
    self.setI32(x0, x1, x2, x3);
    return self;
  }

  //! Set all four 32-bit unsigned integers.
  static inline Data128 fromU32(uint32_t x0, uint32_t x1, uint32_t x2, uint32_t x3) noexcept {
    Data128 self;
    self.setU32(x0, x1, x2, x3);
    return self;
  }

  //! Set all two 64-bit signed integers.
  static inline Data128 fromI64(int64_t x0) noexcept {
    Data128 self;
    self.setI64(x0);
    return self;
  }

  //! Set all two 64-bit unsigned integers.
  static inline Data128 fromU64(uint64_t x0) noexcept {
    Data128 self;
    self.setU64(x0);
    return self;
  }

  //! Set all two 64-bit signed integers.
  static inline Data128 fromI64(int64_t x0, int64_t x1) noexcept {
    Data128 self;
    self.setI64(x0, x1);
    return self;
  }

  //! Set all two 64-bit unsigned integers.
  static inline Data128 fromU64(uint64_t x0, uint64_t x1) noexcept {
    Data128 self;
    self.setU64(x0, x1);
    return self;
  }

  //! Set all four SP-FP floats.
  static inline Data128 fromF32(float x0) noexcept {
    Data128 self;
    self.setF32(x0);
    return self;
  }

  //! Set all four SP-FP floats.
  static inline Data128 fromF32(float x0, float x1, float x2, float x3) noexcept {
    Data128 self;
    self.setF32(x0, x1, x2, x3);
    return self;
  }

  //! Set all two DP-FP floats.
  static inline Data128 fromF64(double x0) noexcept {
    Data128 self;
    self.setF64(x0);
    return self;
  }

  //! Set all two DP-FP floats.
  static inline Data128 fromF64(double x0, double x1) noexcept {
    Data128 self;
    self.setF64(x0, x1);
    return self;
  }

  // --------------------------------------------------------------------------
  // [Accessors]
  // --------------------------------------------------------------------------

  //! Set all sixteen 8-bit signed integers.
  inline void setI8(int8_t x0) noexcept {
    setU8(uint8_t(x0));
  }

  //! Set all sixteen 8-bit unsigned integers.
  inline void setU8(uint8_t x0) noexcept  {
    if (ASMJIT_ARCH_BITS >= 64) {
      uint64_t xq = uint64_t(x0) * 0x0101010101010101u;
      uq[0] = xq;
      uq[1] = xq;
    }
    else {
      uint32_t xd = uint32_t(x0) * 0x01010101u;
      ud[0] = xd;
      ud[1] = xd;
      ud[2] = xd;
      ud[3] = xd;
    }
  }

  //! Set all sixteen 8-bit signed integers.
  inline void setI8(
    int8_t x0 , int8_t x1 , int8_t x2 , int8_t x3 ,
    int8_t x4 , int8_t x5 , int8_t x6 , int8_t x7 ,
    int8_t x8 , int8_t x9 , int8_t x10, int8_t x11,
    int8_t x12, int8_t x13, int8_t x14, int8_t x15) noexcept  {

    sb[0 ] = x0 ; sb[1 ] = x1 ; sb[2 ] = x2 ; sb[3 ] = x3 ;
    sb[4 ] = x4 ; sb[5 ] = x5 ; sb[6 ] = x6 ; sb[7 ] = x7 ;
    sb[8 ] = x8 ; sb[9 ] = x9 ; sb[10] = x10; sb[11] = x11;
    sb[12] = x12; sb[13] = x13; sb[14] = x14; sb[15] = x15;
  }

  //! Set all sixteen 8-bit unsigned integers.
  inline void setU8(
    uint8_t x0 , uint8_t x1 , uint8_t x2 , uint8_t x3 ,
    uint8_t x4 , uint8_t x5 , uint8_t x6 , uint8_t x7 ,
    uint8_t x8 , uint8_t x9 , uint8_t x10, uint8_t x11,
    uint8_t x12, uint8_t x13, uint8_t x14, uint8_t x15) noexcept {

    ub[0 ] = x0 ; ub[1 ] = x1 ; ub[2 ] = x2 ; ub[3 ] = x3 ;
    ub[4 ] = x4 ; ub[5 ] = x5 ; ub[6 ] = x6 ; ub[7 ] = x7 ;
    ub[8 ] = x8 ; ub[9 ] = x9 ; ub[10] = x10; ub[11] = x11;
    ub[12] = x12; ub[13] = x13; ub[14] = x14; ub[15] = x15;
  }

  //! Set all eight 16-bit signed integers.
  inline void setI16(int16_t x0) noexcept {
    setU16(uint16_t(x0));
  }

  //! Set all eight 16-bit unsigned integers.
  inline void setU16(uint16_t x0) noexcept {
    if (ASMJIT_ARCH_BITS >= 64) {
      uint64_t xq = uint64_t(x0) * 0x0001000100010001u;
      uq[0] = xq;
      uq[1] = xq;
    }
    else {
      uint32_t xd = uint32_t(x0) * 0x00010001u;
      ud[0] = xd;
      ud[1] = xd;
      ud[2] = xd;
      ud[3] = xd;
    }
  }

  //! Set all eight 16-bit signed integers.
  inline void setI16(
    int16_t x0, int16_t x1, int16_t x2, int16_t x3, int16_t x4, int16_t x5, int16_t x6, int16_t x7) noexcept {

    sw[0] = x0; sw[1] = x1; sw[2] = x2; sw[3] = x3;
    sw[4] = x4; sw[5] = x5; sw[6] = x6; sw[7] = x7;
  }

  //! Set all eight 16-bit unsigned integers.
  inline void setU16(
    uint16_t x0, uint16_t x1, uint16_t x2, uint16_t x3, uint16_t x4, uint16_t x5, uint16_t x6, uint16_t x7) noexcept {

    uw[0] = x0; uw[1] = x1; uw[2] = x2; uw[3] = x3;
    uw[4] = x4; uw[5] = x5; uw[6] = x6; uw[7] = x7;
  }

  //! Set all four 32-bit signed integers.
  inline void setI32(int32_t x0) noexcept {
    setU32(uint32_t(x0));
  }

  //! Set all four 32-bit unsigned integers.
  inline void setU32(uint32_t x0) noexcept {
    if (ASMJIT_ARCH_BITS >= 64) {
      uint64_t t = (uint64_t(x0) << 32) + x0;
      uq[0] = t;
      uq[1] = t;
    }
    else {
      ud[0] = x0;
      ud[1] = x0;
      ud[2] = x0;
      ud[3] = x0;
    }
  }

  //! Set all four 32-bit signed integers.
  inline void setI32(int32_t x0, int32_t x1, int32_t x2, int32_t x3) noexcept {
    sd[0] = x0; sd[1] = x1; sd[2] = x2; sd[3] = x3;
  }

  //! Set all four 32-bit unsigned integers.
  inline void setU32(uint32_t x0, uint32_t x1, uint32_t x2, uint32_t x3) noexcept {
    ud[0] = x0; ud[1] = x1; ud[2] = x2; ud[3] = x3;
  }

  //! Set all two 64-bit signed integers.
  inline void setI64(int64_t x0) noexcept {
    sq[0] = x0; sq[1] = x0;
  }

  //! Set all two 64-bit unsigned integers.
  inline void setU64(uint64_t x0) noexcept {
    uq[0] = x0; uq[1] = x0;
  }

  //! Set all two 64-bit signed integers.
  inline void setI64(int64_t x0, int64_t x1) noexcept {
    sq[0] = x0; sq[1] = x1;
  }

  //! Set all two 64-bit unsigned integers.
  inline void setU64(uint64_t x0, uint64_t x1) noexcept {
    uq[0] = x0; uq[1] = x1;
  }

  //! Set all four SP-FP floats.
  inline void setF32(float x0) noexcept {
    sf[0] = x0; sf[1] = x0; sf[2] = x0; sf[3] = x0;
  }

  //! Set all four SP-FP floats.
  inline void setF32(float x0, float x1, float x2, float x3) noexcept {
    sf[0] = x0; sf[1] = x1; sf[2] = x2; sf[3] = x3;
  }

  //! Set all two DP-FP floats.
  inline void setF64(double x0) noexcept {
    df[0] = x0; df[1] = x0;
  }

  //! Set all two DP-FP floats.
  inline void setF64(double x0, double x1) noexcept {
    df[0] = x0; df[1] = x1;
  }

  // --------------------------------------------------------------------------
  // [Members]
  // --------------------------------------------------------------------------

  //! Array of sixteen 8-bit signed integers.
  int8_t sb[16];
  //! Array of sixteen 8-bit unsigned integers.
  uint8_t ub[16];
  //! Array of eight 16-bit signed integers.
  int16_t sw[8];
  //! Array of eight 16-bit unsigned integers.
  uint16_t uw[8];
  //! Array of four 32-bit signed integers.
  int32_t sd[4];
  //! Array of four 32-bit unsigned integers.
  uint32_t ud[4];
  //! Array of two 64-bit signed integers.
  int64_t sq[2];
  //! Array of two 64-bit unsigned integers.
  uint64_t uq[2];

  //! Array of four 32-bit single precision floating points.
  float sf[4];
  //! Array of two 64-bit double precision floating points.
  double df[2];
};

// ============================================================================
// [asmjit::Data256]
// ============================================================================

//! 256-bit data useful for creating SIMD constants.
union Data256 {
  // --------------------------------------------------------------------------
  // [Construction / Destruction]
  // --------------------------------------------------------------------------

  //! Set all thirty two 8-bit signed integers.
  static inline Data256 fromI8(int8_t x0) noexcept {
    Data256 self;
    self.setI8(x0);
    return self;
  }

  //! Set all thirty two 8-bit unsigned integers.
  static inline Data256 fromU8(uint8_t x0) noexcept {
    Data256 self;
    self.setU8(x0);
    return self;
  }

  //! Set all thirty two 8-bit signed integers.
  static inline Data256 fromI8(
    int8_t x0 , int8_t x1 , int8_t x2 , int8_t x3 ,
    int8_t x4 , int8_t x5 , int8_t x6 , int8_t x7 ,
    int8_t x8 , int8_t x9 , int8_t x10, int8_t x11,
    int8_t x12, int8_t x13, int8_t x14, int8_t x15,
    int8_t x16, int8_t x17, int8_t x18, int8_t x19,
    int8_t x20, int8_t x21, int8_t x22, int8_t x23,
    int8_t x24, int8_t x25, int8_t x26, int8_t x27,
    int8_t x28, int8_t x29, int8_t x30, int8_t x31) noexcept {

    Data256 self;
    self.setI8(
      x0,  x1 , x2 , x3 , x4 , x5 , x6 , x7 , x8 , x9 , x10, x11, x12, x13, x14, x15,
      x16, x17, x18, x19, x20, x21, x22, x23, x24, x25, x26, x27, x28, x29, x30, x31);
    return self;
  }

  //! Set all thirty two 8-bit unsigned integers.
  static inline Data256 fromU8(
    uint8_t x0 , uint8_t x1 , uint8_t x2 , uint8_t x3 ,
    uint8_t x4 , uint8_t x5 , uint8_t x6 , uint8_t x7 ,
    uint8_t x8 , uint8_t x9 , uint8_t x10, uint8_t x11,
    uint8_t x12, uint8_t x13, uint8_t x14, uint8_t x15,
    uint8_t x16, uint8_t x17, uint8_t x18, uint8_t x19,
    uint8_t x20, uint8_t x21, uint8_t x22, uint8_t x23,
    uint8_t x24, uint8_t x25, uint8_t x26, uint8_t x27,
    uint8_t x28, uint8_t x29, uint8_t x30, uint8_t x31) noexcept {

    Data256 self;
    self.setU8(
      x0,  x1 , x2 , x3 , x4 , x5 , x6 , x7 , x8 , x9 , x10, x11, x12, x13, x14, x15,
      x16, x17, x18, x19, x20, x21, x22, x23, x24, x25, x26, x27, x28, x29, x30, x31);
    return self;
  }

  //! Set all sixteen 16-bit signed integers.
  static inline Data256 fromI16(int16_t x0) noexcept {
    Data256 self;
    self.setI16(x0);
    return self;
  }

  //! Set all sixteen 16-bit unsigned integers.
  static inline Data256 fromU16(uint16_t x0) noexcept {
    Data256 self;
    self.setU16(x0);
    return self;
  }

  //! Set all sixteen 16-bit signed integers.
  static inline Data256 fromI16(
    int16_t x0, int16_t x1, int16_t x2 , int16_t x3 , int16_t x4 , int16_t x5 , int16_t x6 , int16_t x7 ,
    int16_t x8, int16_t x9, int16_t x10, int16_t x11, int16_t x12, int16_t x13, int16_t x14, int16_t x15) noexcept {

    Data256 self;
    self.setI16(x0, x1, x2, x3, x4, x5, x6, x7, x8, x9, x10, x11, x12, x13, x14, x15);
    return self;
  }

  //! Set all sixteen 16-bit unsigned integers.
  static inline Data256 fromU16(
    uint16_t x0, uint16_t x1, uint16_t x2 , uint16_t x3 , uint16_t x4 , uint16_t x5 , uint16_t x6 , uint16_t x7 ,
    uint16_t x8, uint16_t x9, uint16_t x10, uint16_t x11, uint16_t x12, uint16_t x13, uint16_t x14, uint16_t x15) noexcept {

    Data256 self;
    self.setU16(x0, x1, x2, x3, x4, x5, x6, x7, x8, x9, x10, x11, x12, x13, x14, x15);
    return self;
  }

  //! Set all eight 32-bit signed integers.
  static inline Data256 fromI32(int32_t x0) noexcept {
    Data256 self;
    self.setI32(x0);
    return self;
  }

  //! Set all eight 32-bit unsigned integers.
  static inline Data256 fromU32(uint32_t x0) noexcept {
    Data256 self;
    self.setU32(x0);
    return self;
  }

  //! Set all eight 32-bit signed integers.
  static inline Data256 fromI32(
    int32_t x0, int32_t x1, int32_t x2, int32_t x3,
    int32_t x4, int32_t x5, int32_t x6, int32_t x7) noexcept {

    Data256 self;
    self.setI32(x0, x1, x2, x3, x4, x5, x6, x7);
    return self;
  }

  //! Set all eight 32-bit unsigned integers.
  static inline Data256 fromU32(
    uint32_t x0, uint32_t x1, uint32_t x2, uint32_t x3,
    uint32_t x4, uint32_t x5, uint32_t x6, uint32_t x7) noexcept {

    Data256 self;
    self.setU32(x0, x1, x2, x3, x4, x5, x6, x7);
    return self;
  }

  //! Set all four 64-bit signed integers.
  static inline Data256 fromI64(int64_t x0) noexcept {
    Data256 self;
    self.setI64(x0);
    return self;
  }

  //! Set all four 64-bit unsigned integers.
  static inline Data256 fromU64(uint64_t x0) noexcept {
    Data256 self;
    self.setU64(x0);
    return self;
  }

  //! Set all four 64-bit signed integers.
  static inline Data256 fromI64(int64_t x0, int64_t x1, int64_t x2, int64_t x3) noexcept {
    Data256 self;
    self.setI64(x0, x1, x2, x3);
    return self;
  }

  //! Set all four 64-bit unsigned integers.
  static inline Data256 fromU64(uint64_t x0, uint64_t x1, uint64_t x2, uint64_t x3) noexcept {
    Data256 self;
    self.setU64(x0, x1, x2, x3);
    return self;
  }

  //! Set all eight SP-FP floats.
  static inline Data256 fromF32(float x0) noexcept {
    Data256 self;
    self.setF32(x0);
    return self;
  }

  //! Set all eight SP-FP floats.
  static inline Data256 fromF32(
    float x0, float x1, float x2, float x3,
    float x4, float x5, float x6, float x7) noexcept {

    Data256 self;
    self.setF32(x0, x1, x2, x3, x4, x5, x6, x7);
    return self;
  }

  //! Set all four DP-FP floats.
  static inline Data256 fromF64(double x0) noexcept {
    Data256 self;
    self.setF64(x0);
    return self;
  }

  //! Set all four DP-FP floats.
  static inline Data256 fromF64(double x0, double x1, double x2, double x3) noexcept {
    Data256 self;
    self.setF64(x0, x1, x2, x3);
    return self;
  }

  // --------------------------------------------------------------------------
  // [Accessors]
  // --------------------------------------------------------------------------

  //! Set all thirty two 8-bit signed integers.
  inline void setI8(int8_t x0) noexcept {
    setU8(uint8_t(x0));
  }

  //! Set all thirty two 8-bit unsigned integers.
  inline void setU8(uint8_t x0) noexcept {
    if (ASMJIT_ARCH_BITS >= 64) {
      uint64_t xq = uint64_t(x0) * 0x0101010101010101u;
      uq[0] = xq;
      uq[1] = xq;
      uq[2] = xq;
      uq[3] = xq;
    }
    else {
      uint32_t xd = uint32_t(x0) * 0x01010101u;
      ud[0] = xd;
      ud[1] = xd;
      ud[2] = xd;
      ud[3] = xd;
      ud[4] = xd;
      ud[5] = xd;
      ud[6] = xd;
      ud[7] = xd;
    }
  }

  //! Set all thirty two 8-bit signed integers.
  inline void setI8(
    int8_t x0 , int8_t x1 , int8_t x2 , int8_t x3 ,
    int8_t x4 , int8_t x5 , int8_t x6 , int8_t x7 ,
    int8_t x8 , int8_t x9 , int8_t x10, int8_t x11,
    int8_t x12, int8_t x13, int8_t x14, int8_t x15,
    int8_t x16, int8_t x17, int8_t x18, int8_t x19,
    int8_t x20, int8_t x21, int8_t x22, int8_t x23,
    int8_t x24, int8_t x25, int8_t x26, int8_t x27,
    int8_t x28, int8_t x29, int8_t x30, int8_t x31) noexcept {

    sb[0 ] = x0 ; sb[1 ] = x1 ; sb[2 ] = x2 ; sb[3 ] = x3 ;
    sb[4 ] = x4 ; sb[5 ] = x5 ; sb[6 ] = x6 ; sb[7 ] = x7 ;
    sb[8 ] = x8 ; sb[9 ] = x9 ; sb[10] = x10; sb[11] = x11;
    sb[12] = x12; sb[13] = x13; sb[14] = x14; sb[15] = x15;
    sb[16] = x16; sb[17] = x17; sb[18] = x18; sb[19] = x19;
    sb[20] = x20; sb[21] = x21; sb[22] = x22; sb[23] = x23;
    sb[24] = x24; sb[25] = x25; sb[26] = x26; sb[27] = x27;
    sb[28] = x28; sb[29] = x29; sb[30] = x30; sb[31] = x31;
  }

  //! Set all thirty two 8-bit unsigned integers.
  inline void setU8(
    uint8_t x0 , uint8_t x1 , uint8_t x2 , uint8_t x3 ,
    uint8_t x4 , uint8_t x5 , uint8_t x6 , uint8_t x7 ,
    uint8_t x8 , uint8_t x9 , uint8_t x10, uint8_t x11,
    uint8_t x12, uint8_t x13, uint8_t x14, uint8_t x15,
    uint8_t x16, uint8_t x17, uint8_t x18, uint8_t x19,
    uint8_t x20, uint8_t x21, uint8_t x22, uint8_t x23,
    uint8_t x24, uint8_t x25, uint8_t x26, uint8_t x27,
    uint8_t x28, uint8_t x29, uint8_t x30, uint8_t x31) noexcept {

    ub[0 ] = x0 ; ub[1 ] = x1 ; ub[2 ] = x2 ; ub[3 ] = x3 ;
    ub[4 ] = x4 ; ub[5 ] = x5 ; ub[6 ] = x6 ; ub[7 ] = x7 ;
    ub[8 ] = x8 ; ub[9 ] = x9 ; ub[10] = x10; ub[11] = x11;
    ub[12] = x12; ub[13] = x13; ub[14] = x14; ub[15] = x15;
    ub[16] = x16; ub[17] = x17; ub[18] = x18; ub[19] = x19;
    ub[20] = x20; ub[21] = x21; ub[22] = x22; ub[23] = x23;
    ub[24] = x24; ub[25] = x25; ub[26] = x26; ub[27] = x27;
    ub[28] = x28; ub[29] = x29; ub[30] = x30; ub[31] = x31;
  }

  //! Set all sixteen 16-bit signed integers.
  inline void setI16(int16_t x0) noexcept {
    setU16(uint16_t(x0));
  }

  //! Set all eight 16-bit unsigned integers.
  inline void setU16(uint16_t x0) noexcept {
    if (ASMJIT_ARCH_BITS >= 64) {
      uint64_t xq = uint64_t(x0) * 0x0001000100010001u;
      uq[0] = xq;
      uq[1] = xq;
      uq[2] = xq;
      uq[3] = xq;
    }
    else {
      uint32_t xd = uint32_t(x0) * 0x00010001u;
      ud[0] = xd;
      ud[1] = xd;
      ud[2] = xd;
      ud[3] = xd;
      ud[4] = xd;
      ud[5] = xd;
      ud[6] = xd;
      ud[7] = xd;
    }
  }

  //! Set all sixteen 16-bit signed integers.
  inline void setI16(
    int16_t x0, int16_t x1, int16_t x2 , int16_t x3 , int16_t x4 , int16_t x5 , int16_t x6 , int16_t x7,
    int16_t x8, int16_t x9, int16_t x10, int16_t x11, int16_t x12, int16_t x13, int16_t x14, int16_t x15) noexcept {

    sw[0 ] = x0 ; sw[1 ] = x1 ; sw[2 ] = x2 ; sw[3 ] = x3 ;
    sw[4 ] = x4 ; sw[5 ] = x5 ; sw[6 ] = x6 ; sw[7 ] = x7 ;
    sw[8 ] = x8 ; sw[9 ] = x9 ; sw[10] = x10; sw[11] = x11;
    sw[12] = x12; sw[13] = x13; sw[14] = x14; sw[15] = x15;
  }

  //! Set all sixteen 16-bit unsigned integers.
  inline void setU16(
    uint16_t x0, uint16_t x1, uint16_t x2 , uint16_t x3 , uint16_t x4 , uint16_t x5 , uint16_t x6 , uint16_t x7,
    uint16_t x8, uint16_t x9, uint16_t x10, uint16_t x11, uint16_t x12, uint16_t x13, uint16_t x14, uint16_t x15) noexcept {

    uw[0 ] = x0 ; uw[1 ] = x1 ; uw[2 ] = x2 ; uw[3 ] = x3 ;
    uw[4 ] = x4 ; uw[5 ] = x5 ; uw[6 ] = x6 ; uw[7 ] = x7 ;
    uw[8 ] = x8 ; uw[9 ] = x9 ; uw[10] = x10; uw[11] = x11;
    uw[12] = x12; uw[13] = x13; uw[14] = x14; uw[15] = x15;
  }

  //! Set all eight 32-bit signed integers.
  inline void setI32(int32_t x0) noexcept {
    setU32(uint32_t(x0));
  }

  //! Set all eight 32-bit unsigned integers.
  inline void setU32(uint32_t x0) noexcept {
    if (ASMJIT_ARCH_BITS >= 64) {
      uint64_t xq = (uint64_t(x0) << 32) + x0;
      uq[0] = xq;
      uq[1] = xq;
      uq[2] = xq;
      uq[3] = xq;
    }
    else {
      ud[0] = x0;
      ud[1] = x0;
      ud[2] = x0;
      ud[3] = x0;
      ud[4] = x0;
      ud[5] = x0;
      ud[6] = x0;
      ud[7] = x0;
    }
  }

  //! Set all eight 32-bit signed integers.
  inline void setI32(
    int32_t x0, int32_t x1, int32_t x2, int32_t x3,
    int32_t x4, int32_t x5, int32_t x6, int32_t x7) noexcept {

    sd[0] = x0; sd[1] = x1; sd[2] = x2; sd[3] = x3;
    sd[4] = x4; sd[5] = x5; sd[6] = x6; sd[7] = x7;
  }

  //! Set all eight 32-bit unsigned integers.
  inline void setU32(
    uint32_t x0, uint32_t x1, uint32_t x2, uint32_t x3,
    uint32_t x4, uint32_t x5, uint32_t x6, uint32_t x7) noexcept {

    ud[0] = x0; ud[1] = x1; ud[2] = x2; ud[3] = x3;
    ud[4] = x4; ud[5] = x5; ud[6] = x6; ud[7] = x7;
  }

  //! Set all four 64-bit signed integers.
  inline void setI64(int64_t x0) noexcept {
    sq[0] = x0; sq[1] = x0; sq[2] = x0; sq[3] = x0;
  }

  //! Set all four 64-bit unsigned integers.
  inline void setU64(uint64_t x0) noexcept {
    uq[0] = x0; uq[1] = x0; uq[2] = x0; uq[3] = x0;
  }

  //! Set all four 64-bit signed integers.
  inline void setI64(int64_t x0, int64_t x1, int64_t x2, int64_t x3) noexcept {
    sq[0] = x0; sq[1] = x1; sq[2] = x2; sq[3] = x3;
  }

  //! Set all four 64-bit unsigned integers.
  inline void setU64(uint64_t x0, uint64_t x1, uint64_t x2, uint64_t x3) noexcept {
    uq[0] = x0; uq[1] = x1; uq[2] = x2; uq[3] = x3;
  }

  //! Set all eight SP-FP floats.
  inline void setF32(float x0) noexcept {
    sf[0] = x0; sf[1] = x0; sf[2] = x0; sf[3] = x0;
    sf[4] = x0; sf[5] = x0; sf[6] = x0; sf[7] = x0;
  }

  //! Set all eight SP-FP floats.
  inline void setF32(
    float x0, float x1, float x2, float x3,
    float x4, float x5, float x6, float x7) noexcept {

    sf[0] = x0; sf[1] = x1; sf[2] = x2; sf[3] = x3;
    sf[4] = x4; sf[5] = x5; sf[6] = x6; sf[7] = x7;
  }

  //! Set all four DP-FP floats.
  inline void setF64(double x0) noexcept {
    df[0] = x0; df[1] = x0; df[2] = x0; df[3] = x0;
  }

  //! Set all four DP-FP floats.
  inline void setF64(double x0, double x1, double x2, double x3) noexcept {
    df[0] = x0; df[1] = x1; df[2] = x2; df[3] = x3;
  }

  // --------------------------------------------------------------------------
  // [Members]
  // --------------------------------------------------------------------------

  //! Array of thirty two 8-bit signed integers.
  int8_t sb[32];
  //! Array of thirty two 8-bit unsigned integers.
  uint8_t ub[32];
  //! Array of sixteen 16-bit signed integers.
  int16_t sw[16];
  //! Array of sixteen 16-bit unsigned integers.
  uint16_t uw[16];
  //! Array of eight 32-bit signed integers.
  int32_t sd[8];
  //! Array of eight 32-bit unsigned integers.
  uint32_t ud[8];
  //! Array of four 64-bit signed integers.
  int64_t sq[4];
  //! Array of four 64-bit unsigned integers.
  uint64_t uq[4];

  //! Array of eight 32-bit single precision floating points.
  float sf[8];
  //! Array of four 64-bit double precision floating points.
  double df[4];
};

//! \}

ASMJIT_END_NAMESPACE

// [Guard]
#endif // _ASMJIT_CORE_DATATYPES_H

```

`Avanguard/AsmJit/asmjit/core/emitter.h`:

```h
// [AsmJit]
// Complete x86/x64 JIT and Remote Assembler for C++.
//
// [License]
// ZLIB - See LICENSE.md file in the package.

// [Guard]
#ifndef _ASMJIT_CORE_EMITTER_H
#define _ASMJIT_CORE_EMITTER_H

// [Dependencies]
#include "../core/arch.h"
#include "../core/inst.h"
#include "../core/operand.h"
#include "../core/codeholder.h"

ASMJIT_BEGIN_NAMESPACE

//! \addtogroup asmjit_core_api
//! \{

// ============================================================================
// [Forward Declarations]
// ============================================================================

class ConstPool;
class FuncFrame;
class FuncArgsAssignment;

// ============================================================================
// [asmjit::BaseEmitter]
// ============================================================================

//! Provides a base foundation to emit code - specialized by `Assembler` and
//! `BaseBuilder`.
class ASMJIT_VIRTAPI BaseEmitter {
public:
  //! Emitter type.
  enum EmitterType : uint32_t {
    kTypeNone      = 0,
    kTypeAssembler = 1,
    kTypeBuilder   = 2,
    kTypeCompiler  = 3,
    kTypeCount     = 4
  };

  //! Emitter flags.
  enum Flags : uint32_t {
    kFlagFinalized = 0x4000u,            //!< Code emitter is finalized.
    kFlagDestroyed = 0x8000u             //!< Code emitter was destroyed.
  };

  //! Emitter options.
  enum Options : uint32_t {
    //! Logging is enabled, `BaseEmitter::logger()` must return a valid logger.
    kOptionLoggingEnabled   = 0x00000001u,

    //! Stricly validate each instruction before it's emitted.
    kOptionStrictValidation = 0x00000002u,

    //! Emit optimized code-alignment sequences.
    //!
    //! Default `false`.
    //!
    //! X86 Specific
    //! ------------
    //!
    //! Default align sequence used by X86 architecture is one-byte (0x90)
    //! opcode that is often shown by disassemblers as NOP. However there are
    //! more optimized align sequences for 2-11 bytes that may execute faster
    //! on certain CPUs. If this feature is enabled AsmJit will generate
    //! specialized sequences for alignment between 2 to 11 bytes.
    kOptionOptimizedAlign = 0x00000004u,

    //! Emit jump-prediction hints.
    //!
    //! Default `false`.
    //!
    //! X86 Specific
    //! ------------
    //!
    //! Jump prediction is usually based on the direction of the jump. If the
    //! jump is backward it is usually predicted as taken; and if the jump is
    //! forward it is usually predicted as not-taken. The reason is that loops
    //! generally use backward jumps and conditions usually use forward jumps.
    //! However this behavior can be overridden by using instruction prefixes.
    //! If this option is enabled these hints will be emitted.
    //!
    //! This feature is disabled by default, because the only processor that
    //! used to take into consideration prediction hints was P4. Newer processors
    //! implement heuristics for branch prediction and ignore static hints. This
    //! means that this feature can be used for annotation purposes.
    kOptionPredictedJumps = 0x00000008u
  };

  // --------------------------------------------------------------------------
  // [Construction / Destruction]
  // --------------------------------------------------------------------------

  ASMJIT_API explicit BaseEmitter(uint32_t type) noexcept;
  ASMJIT_API virtual ~BaseEmitter() noexcept;

  // --------------------------------------------------------------------------
  // [Cast]
  // --------------------------------------------------------------------------

  template<typename T>
  inline T* as() noexcept { return reinterpret_cast<T*>(this); }

  template<typename T>
  inline const T* as() const noexcept { return reinterpret_cast<const T*>(this); }

  // --------------------------------------------------------------------------
  // [Emitter Type & Flags]
  // --------------------------------------------------------------------------

  //! Get the type of this BaseEmitter, see `EmitterType`.
  inline uint32_t emitterType() const noexcept { return _type; }
  inline uint32_t emitterFlags() const noexcept { return _flags; }

  inline bool isAssembler() const noexcept { return _type == kTypeAssembler; }
  inline bool isBuilder() const noexcept { return _type >= kTypeBuilder; }
  inline bool isCompiler() const noexcept { return _type == kTypeCompiler; }

  inline bool hasFlag(uint32_t flag) const noexcept { return (_flags & flag) != 0; }
  inline bool isFinalized() const noexcept { return hasFlag(kFlagFinalized); }
  inline bool isDestroyed() const noexcept { return hasFlag(kFlagDestroyed); }

  inline void _addFlags(uint32_t flags) noexcept { _flags = uint16_t(_flags | flags); }
  inline void _clearFlags(uint32_t flags) noexcept { _flags = uint16_t(_flags & ~flags); }

  // --------------------------------------------------------------------------
  // [Target Information]
  // --------------------------------------------------------------------------

  //! Get `CodeHolder` this emitter is attached to.
  inline CodeHolder* code() const noexcept { return _code; }
  //! Get information about the code, see `CodeInfo`.
  inline const CodeInfo& codeInfo() const noexcept { return _codeInfo; }
  //! Get information about the architecture, see `ArchInfo`.
  inline const ArchInfo& archInfo() const noexcept { return _codeInfo.archInfo(); }

  //! Get whether the target architecture is 32-bit.
  inline bool is32Bit() const noexcept { return archInfo().is32Bit(); }
  //! Get whether the target architecture is 64-bit.
  inline bool is64Bit() const noexcept { return archInfo().is64Bit(); }

  //! Get the target architecture type.
  inline uint32_t archId() const noexcept { return archInfo().archId(); }
  //! Get the target architecture sub-type.
  inline uint32_t archSubId() const noexcept { return archInfo().archSubId(); }
  //! Get the target architecture's GP register size (4 or 8 bytes).
  inline uint32_t gpSize() const noexcept { return archInfo().gpSize(); }
  //! Get the number of target GP registers.
  inline uint32_t gpCount() const noexcept { return archInfo().gpCount(); }

  // --------------------------------------------------------------------------
  // [Initialization / Finalization]
  // --------------------------------------------------------------------------

  //! Get whether the BaseEmitter is initialized (i.e. attached to the `CodeHolder`).
  inline bool isInitialized() const noexcept { return _code != nullptr; }

  ASMJIT_API virtual Error finalize();

  // --------------------------------------------------------------------------
  // [Emitter Options]
  // --------------------------------------------------------------------------

  //! Get whether the `option` is present in emitter options.
  inline bool hasEmitterOption(uint32_t option) const noexcept { return (_emitterOptions & option) != 0; }
  //! Get emitter options.
  inline uint32_t emitterOptions() const noexcept { return _emitterOptions; }

  inline void addEmitterOptions(uint32_t options) noexcept {
    _emitterOptions |= options;
    onUpdateGlobalInstOptions();
  }

  inline void clearEmitterOptions(uint32_t options) noexcept {
    _emitterOptions &= ~options;
    onUpdateGlobalInstOptions();
  }

  //! Get global instruction options.
  //!
  //! Default instruction options are merged with instruction options before the
  //! instruction is encoded. These options have some bits reserved that are used
  //! for error handling, logging, and strict validation. Other options are globals that
  //! affect each instruction, for example if VEX3 is set globally, it will all
  //! instructions, even those that don't have such option set.
  inline uint32_t globalInstOptions() const noexcept { return _globalInstOptions; }

  // --------------------------------------------------------------------------
  // [Error Handling]
  // --------------------------------------------------------------------------

  //! Get whether the local error handler is attached.
  inline bool hasErrorHandler() const noexcept { return _errorHandler != nullptr; }
  //! Get the local error handler.
  inline ErrorHandler* errorHandler() const noexcept { return _errorHandler; }
  //! Set the local error handler.
  inline void setErrorHandler(ErrorHandler* handler) noexcept { _errorHandler = handler; }
  //! Reset the local error handler (does nothing if not attached).
  inline void resetErrorHandler() noexcept { setErrorHandler(nullptr); }

  //! Handle the given error in the following way:
  //!   1. Get either BaseEmitter's (preferred) or CodeHolder's ErrorHandler.
  //!   2. If exists, call `ErrorHandler::handleError(error, message, this)`.
  //!   3. Return the given `err` if ErrorHandler haven't thrown.
  ASMJIT_API Error reportError(Error err, const char* message = nullptr);

  // --------------------------------------------------------------------------
  // [Instruction Properties - Affect the Next Instruction to be Emitted]
  // --------------------------------------------------------------------------

  //! Get options of the next instruction.
  inline uint32_t instOptions() const noexcept { return _instOptions; }
  //! Set options of the next instruction.
  inline void setInstOptions(uint32_t options) noexcept { _instOptions = options; }
  //! Add options of the next instruction.
  inline void addInstOptions(uint32_t options) noexcept { _instOptions |= options; }
  //! Reset options of the next instruction.
  inline void resetInstOptions() noexcept { _instOptions = 0; }

  //! Get whether the extra register operand is valid.
  inline bool hasExtraReg() const noexcept { return _extraReg.isReg(); }
  //! Get an extra operand that will be used by the next instruction (architecture specific).
  inline const RegOnly& extraReg() const noexcept { return _extraReg; }
  //! Set an extra operand that will be used by the next instruction (architecture specific).
  inline void setExtraReg(const BaseReg& reg) noexcept { _extraReg.init(reg); }
  //! Set an extra operand that will be used by the next instruction (architecture specific).
  inline void setExtraReg(const RegOnly& reg) noexcept { _extraReg.init(reg); }
  //! Reset an extra operand that will be used by the next instruction (architecture specific).
  inline void resetExtraReg() noexcept { _extraReg.reset(); }

  //! Get annotation of the next instruction.
  inline const char* inlineComment() const noexcept { return _inlineComment; }
  //! Set annotation of the next instruction.
  //!
  //! NOTE: This string is set back to null by `_emit()`, but until that it has
  //! to remain valid as `BaseEmitter` is not required to make a copy of it (and
  //! it would be slow to do that for each instruction).
  inline void setInlineComment(const char* s) noexcept { _inlineComment = s; }
  //! Reset annotation of the next instruction to null.
  inline void resetInlineComment() noexcept { _inlineComment = nullptr; }

  // --------------------------------------------------------------------------
  // [Label Management]
  // --------------------------------------------------------------------------

  //! Create a new label.
  virtual Label newLabel() = 0;
  //! Create a new named label.
  virtual Label newNamedLabel(
    const char* name,
    size_t nameSize = Globals::kNullTerminated,
    uint32_t type = Label::kTypeGlobal,
    uint32_t parentId = 0) = 0;

  //! Get a label by name.
  //!
  //! Returns invalid Label in case that the name is invalid or label was not found.
  //!
  //! NOTE: This function doesn't trigger ErrorHandler in case the name is invalid
  //! or no such label exist. You must always check the validity of the `Label` returned.
  ASMJIT_API Label labelByName(
    const char* name,
    size_t nameSize = Globals::kNullTerminated,
    uint32_t parentId = 0) noexcept;

  //! Bind the `label` to the current position of the current section.
  //!
  //! NOTE: Attempt to bind the same label multiple times will return an error.
  virtual Error bind(const Label& label) = 0;

  //! Get whether the label `id` is valid (i.e. registered).
  ASMJIT_API bool isLabelValid(uint32_t id) const noexcept;
  //! Get whether the `label` is valid (i.e. registered).
  inline bool isLabelValid(const Label& label) const noexcept { return isLabelValid(label.id()); }

  // --------------------------------------------------------------------------
  // [Emit - Low-Level]
  // --------------------------------------------------------------------------

  // NOTE: These `emit()` helpers are designed to address a code-bloat generated
  // by C++ compilers to call a function having many arguments. Each parameter to
  // `_emit()` requires some code to pass it, which means that if we default to 4
  // operand parameters in `_emit()` and instId the C++ compiler would have to
  // generate a virtual function call having 5 parameters, which is quite a lot.
  // Since by default asm instructions have 2 to 3 operands it's better to
  // introduce helpers that pass those and fill out the remaining operands.

  #define OP const Operand_&
  #define NONE Globals::none

  //! Emit an instruction.
  ASMJIT_NOINLINE Error emit(uint32_t instId) { return _emit(instId, NONE, NONE, NONE, NONE); }
  //! \overload
  ASMJIT_NOINLINE Error emit(uint32_t instId, OP o0) { return _emit(instId, o0, NONE, NONE, NONE); }
  //! \overload
  ASMJIT_NOINLINE Error emit(uint32_t instId, OP o0, OP o1) { return _emit(instId, o0, o1, NONE, NONE); }
  //! \overload
  ASMJIT_NOINLINE Error emit(uint32_t instId, OP o0, OP o1, OP o2) { return _emit(instId, o0, o1, o2, NONE); }
  //! \overload
  inline Error emit(uint32_t instId, OP o0, OP o1, OP o2, OP o3) { return _emit(instId, o0, o1, o2, o3); }
  //! \overload
  inline Error emit(uint32_t instId, OP o0, OP o1, OP o2, OP o3, OP o4) { return _emit(instId, o0, o1, o2, o3, o4, NONE); }
  //! \overload
  inline Error emit(uint32_t instId, OP o0, OP o1, OP o2, OP o3, OP o4, OP o5) { return _emit(instId, o0, o1, o2, o3, o4, o5); }

  //! \overload
  ASMJIT_NOINLINE Error emit(uint32_t instId, int o0) { return _emit(instId, Imm(o0), NONE, NONE, NONE); }
  //! \overload
  ASMJIT_NOINLINE Error emit(uint32_t instId, OP o0, int o1) { return _emit(instId, o0, Imm(o1), NONE, NONE); }
  //! \overload
  ASMJIT_NOINLINE Error emit(uint32_t instId, OP o0, OP o1, int o2) { return _emit(instId, o0, o1, Imm(o2), NONE); }
  //! \overload
  ASMJIT_NOINLINE Error emit(uint32_t instId, OP o0, OP o1, OP o2, int o3) { return _emit(instId, o0, o1, o2, Imm(o3)); }
  //! \overload
  ASMJIT_NOINLINE Error emit(uint32_t instId, OP o0, OP o1, OP o2, OP o3, int o4) { return _emit(instId, o0, o1, o2, o3, Imm(o4), NONE); }
  //! \overload
  ASMJIT_NOINLINE Error emit(uint32_t instId, OP o0, OP o1, OP o2, OP o3, OP o4, int o5) { return _emit(instId, o0, o1, o2, o3, o4, Imm(o5)); }

  //! \overload
  ASMJIT_NOINLINE Error emit(uint32_t instId, int64_t o0) { return _emit(instId, Imm(o0), NONE, NONE, NONE); }
  //! \overload
  ASMJIT_NOINLINE Error emit(uint32_t instId, OP o0, int64_t o1) { return _emit(instId, o0, Imm(o1), NONE, NONE); }
  //! \overload
  ASMJIT_NOINLINE Error emit(uint32_t instId, OP o0, OP o1, int64_t o2) { return _emit(instId, o0, o1, Imm(o2), NONE); }
  //! \overload
  ASMJIT_NOINLINE Error emit(uint32_t instId, OP o0, OP o1, OP o2, int64_t o3) { return _emit(instId, o0, o1, o2, Imm(o3)); }
  //! \overload
  ASMJIT_NOINLINE Error emit(uint32_t instId, OP o0, OP o1, OP o2, OP o3, int64_t o4) { return _emit(instId, o0, o1, o2, o3, Imm(o4), NONE); }
  //! \overload
  ASMJIT_NOINLINE Error emit(uint32_t instId, OP o0, OP o1, OP o2, OP o3, OP o4, int64_t o5) { return _emit(instId, o0, o1, o2, o3, o4, Imm(o5)); }

  //! \overload
  inline Error emit(uint32_t instId, unsigned int o0) { return emit(instId, int64_t(o0)); }
  //! \overload
  inline Error emit(uint32_t instId, OP o0, unsigned int o1) { return emit(instId, o0, int64_t(o1)); }
  //! \overload
  inline Error emit(uint32_t instId, OP o0, OP o1, unsigned int o2) { return emit(instId, o0, o1, int64_t(o2)); }
  //! \overload
  inline Error emit(uint32_t instId, OP o0, OP o1, OP o2, unsigned int o3) { return emit(instId, o0, o1, o2, int64_t(o3)); }
  //! \overload
  inline Error emit(uint32_t instId, OP o0, OP o1, OP o2, OP o3, unsigned int o4) { return emit(instId, o0, o1, o2, o3, int64_t(o4)); }
  //! \overload
  inline Error emit(uint32_t instId, OP o0, OP o1, OP o2, OP o3, OP o4, unsigned int o5) { return emit(instId, o0, o1, o2, o3, o4, int64_t(o5)); }

  //! \overload
  inline Error emit(uint32_t instId, uint64_t o0) { return emit(instId, int64_t(o0)); }
  //! \overload
  inline Error emit(uint32_t instId, OP o0, uint64_t o1) { return emit(instId, o0, int64_t(o1)); }
  //! \overload
  inline Error emit(uint32_t instId, OP o0, OP o1, uint64_t o2) { return emit(instId, o0, o1, int64_t(o2)); }
  //! \overload
  inline Error emit(uint32_t instId, OP o0, OP o1, OP o2, uint64_t o3) { return emit(instId, o0, o1, o2, int64_t(o3)); }
  //! \overload
  inline Error emit(uint32_t instId, OP o0, OP o1, OP o2, OP o3, uint64_t o4) { return emit(instId, o0, o1, o2, o3, int64_t(o4)); }
  //! \overload
  inline Error emit(uint32_t instId, OP o0, OP o1, OP o2, OP o3, OP o4, uint64_t o5) { return emit(instId, o0, o1, o2, o3, o4, int64_t(o5)); }

  #undef NONE
  #undef OP

  inline Error emitOpArray(uint32_t instId, const Operand_* operands, size_t count) { return _emitOpArray(instId, operands, count); }

  inline Error emitInst(const BaseInst& inst, const Operand_* operands, size_t count) {
    setInstOptions(inst.options());
    setExtraReg(inst.extraReg());
    return _emitOpArray(inst.id(), operands, count);
  }

  // --------------------------------------------------------------------------
  // [Emit - Virtual]
  // --------------------------------------------------------------------------

  //! Emit instruction having max 4 operands.
  virtual Error _emit(uint32_t instId, const Operand_& o0, const Operand_& o1, const Operand_& o2, const Operand_& o3) = 0;
  //! Emit instruction having max 6 operands.
  virtual Error _emit(uint32_t instId, const Operand_& o0, const Operand_& o1, const Operand_& o2, const Operand_& o3, const Operand_& o4, const Operand_& o5) = 0;
  //! Emit instruction having operands stored in array.
  virtual Error _emitOpArray(uint32_t instId, const Operand_* operands, size_t count);

  // --------------------------------------------------------------------------
  // [Emit - High-Level]
  // --------------------------------------------------------------------------

  ASMJIT_API Error emitProlog(const FuncFrame& layout);
  ASMJIT_API Error emitEpilog(const FuncFrame& layout);
  ASMJIT_API Error emitArgsAssignment(const FuncFrame& layout, const FuncArgsAssignment& args);

  // --------------------------------------------------------------------------
  // [Align]
  // --------------------------------------------------------------------------

  //! Align to the `alignment` specified.
  //!
  //! The sequence that is used to fill the gap between the aligned location
  //! and the current location depends on the align `mode`, see `AlignMode`.
  virtual Error align(uint32_t alignMode, uint32_t alignment) = 0;

  // --------------------------------------------------------------------------
  // [Embed]
  // --------------------------------------------------------------------------

  //! Embed raw data into the code-buffer.
  virtual Error embed(const void* data, uint32_t size) = 0;

  //! Embed absolute label address as data (4 or 8 bytes).
  virtual Error embedLabel(const Label& label) = 0;

  //! Embed a constant pool into the code-buffer in the following steps:
  //!   1. Align by using kAlignData to the minimum `pool` alignment.
  //!   2. Bind `label` so it's bound to an aligned location.
  //!   3. Emit constant pool data.
  virtual Error embedConstPool(const Label& label, const ConstPool& pool) = 0;

  // --------------------------------------------------------------------------
  // [Comment]
  // --------------------------------------------------------------------------

  //! Emit comment from string `data` with an optional comment `size` parameter.
  virtual Error comment(const char* data, size_t size = Globals::kNullTerminated) = 0;

  //! Emit comment from a formatted string `fmt`.
  ASMJIT_API Error commentf(const char* fmt, ...);
  //! Emit comment from a formatted string `fmt` (va_list version).
  ASMJIT_API Error commentv(const char* fmt, std::va_list ap);

  // --------------------------------------------------------------------------
  // [Events]
  // --------------------------------------------------------------------------

  //! Called after the emitter was attached to `CodeHolder`.
  virtual Error onAttach(CodeHolder* code) noexcept = 0;
  //! Called after the emitter was detached from `CodeHolder`.
  virtual Error onDetach(CodeHolder* code) noexcept = 0;

  //! Called to update `_globalInstOptions` based on `_emitterOptions`.
  //!
  //! This function should only touch one bit `BaseInst::kOptionReserved`, which
  //! is used to handle errors and special-cases in a way that minimizes branching.
  ASMJIT_API void onUpdateGlobalInstOptions() noexcept;

  // --------------------------------------------------------------------------
  // [Members]
  // --------------------------------------------------------------------------

  uint8_t _type;                         //!< See `EmitterType`.
  uint8_t _reserved;                     //!< Reserved
  uint16_t _flags;                       //!< See `Flags`.

  CodeHolder* _code;                     //!< CodeHolder the BaseEmitter is attached to.
  ErrorHandler* _errorHandler;           //!< Attached `ErrorHandler`.

  CodeInfo _codeInfo;                    //!< Basic information about the code (matches CodeHolder::_codeInfo).
  RegInfo _gpRegInfo;                    //!< Native GP register signature and signature related information.

  uint32_t _emitterOptions;              //!< Emitter options, always in sync with CodeHolder.
  uint32_t _privateData;                 //!< Internal private data used freely by any BaseEmitter.

  uint32_t _instOptions;                 //!< Next instruction options                (affects the next instruction).
  uint32_t _globalInstOptions;           //!< Global Instruction options              (combined with `_instOptions` by `emit...()`).
  RegOnly _extraReg;                     //!< Extra register (op-mask {k} on AVX-512) (affects the next instruction).
  const char* _inlineComment;            //!< Inline comment of the next instruction  (affects the next instruction).
};

//! \}

ASMJIT_END_NAMESPACE

// [Guard]
#endif // _ASMJIT_CORE_EMITTER_H

```

`Avanguard/AsmJit/asmjit/core/features.h`:

```h
// [AsmJit]
// Complete x86/x64 JIT and Remote Assembler for C++.
//
// [License]
// ZLIB - See LICENSE.md file in the package.

// [Guard]
#ifndef _ASMJIT_CORE_FEATURES_H
#define _ASMJIT_CORE_FEATURES_H

// [Dependencies]
#include "../core/support.h"

ASMJIT_BEGIN_NAMESPACE

//! \addtogroup asmjit_core_api
//! \{

// ============================================================================
// [asmjit::BaseFeatures]
// ============================================================================

class BaseFeatures {
public:
  typedef Support::BitWord BitWord;

  enum : uint32_t {
    kMaxFeatures = 128,
    kBitWordSizeInBits = Support::kBitWordSizeInBits,
    kNumBitWords = kMaxFeatures / kBitWordSizeInBits
  };

  // --------------------------------------------------------------------------
  // [Construction / Destruction]
  // --------------------------------------------------------------------------

  inline BaseFeatures() noexcept { reset(); }
  inline BaseFeatures(const BaseFeatures& other) noexcept = default;

  // --------------------------------------------------------------------------
  // [Reset]
  // --------------------------------------------------------------------------

  inline void reset() noexcept {
    for (size_t i = 0; i < kNumBitWords; i++)
      _bits[i] = 0;
  }

  // --------------------------------------------------------------------------
  // [Cast]
  // --------------------------------------------------------------------------

  template<typename T>
  inline T& as() noexcept { return static_cast<T&>(*this); }

  template<typename T>
  inline const T& as() const noexcept { return static_cast<const T&>(*this); }

  // --------------------------------------------------------------------------
  // [Accessors]
  // --------------------------------------------------------------------------

  //! Get all features as `BitWord` array.
  inline BitWord* bits() noexcept { return _bits; }
  //! Get all features as `BitWord` array (const).
  inline const BitWord* bits() const noexcept { return _bits; }

  //! Get whether feature `featureId` is present.
  inline bool has(uint32_t featureId) const noexcept {
    ASMJIT_ASSERT(featureId < kMaxFeatures);

    uint32_t idx = featureId / kBitWordSizeInBits;
    uint32_t bit = featureId % kBitWordSizeInBits;

    return bool((_bits[idx] >> bit) & 0x1);
  }

  //! Get whether all features as defined by `other` are  present.
  inline bool hasAll(const BaseFeatures& other) const noexcept {
    for (uint32_t i = 0; i < kNumBitWords; i++)
      if ((_bits[i] & other._bits[i]) != other._bits[i])
        return false;
    return true;
  }

  // --------------------------------------------------------------------------
  // [Operations]
  // --------------------------------------------------------------------------

  //! Add a CPU `feature`.
  inline void add(uint32_t featureId) noexcept {
    ASMJIT_ASSERT(featureId < kMaxFeatures);

    uint32_t idx = featureId / kBitWordSizeInBits;
    uint32_t bit = featureId % kBitWordSizeInBits;

    _bits[idx] |= BitWord(1) << bit;
  }

  template<typename... ArgsT>
  inline void add(uint32_t featureId, ArgsT... otherIds) noexcept {
    add(featureId);
    add(otherIds...);
  }

  //! Remove a CPU `featureId`.
  inline void remove(uint32_t featureId) noexcept {
    ASMJIT_ASSERT(featureId < kMaxFeatures);

    uint32_t idx = featureId / kBitWordSizeInBits;
    uint32_t bit = featureId % kBitWordSizeInBits;

    _bits[idx] &= ~(BitWord(1) << bit);
  }

  template<typename... ArgsT>
  inline void remove(uint32_t featureId, ArgsT... otherIds) noexcept {
    remove(featureId);
    remove(otherIds...);
  }

  inline bool eq(const BaseFeatures& other) const noexcept {
    for (size_t i = 0; i < kNumBitWords; i++)
      if (_bits[i] != other._bits[i])
        return false;
    return true;
  }


  // --------------------------------------------------------------------------
  // [Operator Overload]
  // --------------------------------------------------------------------------

  inline BaseFeatures& operator=(const BaseFeatures& other) noexcept = default;

  inline bool operator==(const BaseFeatures& other) noexcept { return  eq(other); }
  inline bool operator!=(const BaseFeatures& other) noexcept { return !eq(other); }

  // --------------------------------------------------------------------------
  // [Members]
  // --------------------------------------------------------------------------

  BitWord _bits[kNumBitWords];
};

//! \}

ASMJIT_END_NAMESPACE

// [Guard]
#endif // _ASMJIT_CORE_FEATURES_H

```

`Avanguard/AsmJit/asmjit/core/func.h`:

```h
// [AsmJit]
// Complete x86/x64 JIT and Remote Assembler for C++.
//
// [License]
// ZLIB - See LICENSE.md file in the package.

// [Guard]
#ifndef _ASMJIT_CORE_FUNC_H
#define _ASMJIT_CORE_FUNC_H

// [Dependencies]
#include "../core/arch.h"
#include "../core/callconv.h"
#include "../core/operand.h"
#include "../core/type.h"
#include "../core/support.h"

ASMJIT_BEGIN_NAMESPACE

//! \addtogroup asmjit_core_func
//! \{

// ============================================================================
// [asmjit::FuncArgIndex]
// ============================================================================

//! Function argument index (lo/hi).
enum FuncArgIndex : uint32_t {
  //! Maximum number of function arguments supported by AsmJit.
  kFuncArgCount = Globals::kMaxFuncArgs,
  //! Extended maximum number of arguments (used internally).
  kFuncArgCountLoHi = kFuncArgCount * 2,

  //! Index to the LO part of function argument (default).
  //!
  //! This value is typically omitted and added only if there is HI argument
  //! accessed.
  kFuncArgLo = 0,

  //! Index to the HI part of function argument.
  //!
  //! HI part of function argument depends on target architecture. On x86 it's
  //! typically used to transfer 64-bit integers (they form a pair of 32-bit
  //! integers).
  kFuncArgHi = kFuncArgCount
};

// ============================================================================
// [asmjit::FuncSignature]
// ============================================================================

//! Function signature.
//!
//! Contains information about function return type, count of arguments and
//! their TypeIds. Function signature is a low level structure which doesn't
//! contain platform specific or calling convention specific information.
struct FuncSignature {
  enum {
    //! Doesn't have variable number of arguments (`...`).
    kNoVarArgs = 0xFF
  };

  // --------------------------------------------------------------------------
  // [Init / Reset]
  // --------------------------------------------------------------------------

  //! Initialize the function signature.
  inline void init(uint32_t ccId, uint32_t ret, const uint8_t* args, uint32_t argCount) noexcept {
    ASMJIT_ASSERT(ccId <= 0xFF);
    ASMJIT_ASSERT(argCount <= 0xFF);

    _callConv = uint8_t(ccId);
    _argCount = uint8_t(argCount);
    _vaIndex = kNoVarArgs;
    _ret = uint8_t(ret);
    _args = args;
  }

  inline void reset() noexcept { std::memset(this, 0, sizeof(*this)); }

  // --------------------------------------------------------------------------
  // [Accessors]
  // --------------------------------------------------------------------------

  //! Get the function's calling convention.
  inline uint32_t callConv() const noexcept { return _callConv; }

  //! Get whether the function has variable number of arguments (...).
  inline bool hasVarArgs() const noexcept { return _vaIndex != kNoVarArgs; }
  //! Get the variable arguments (...) index, `kNoVarArgs` if none.
  inline uint32_t vaIndex() const noexcept { return _vaIndex; }

  //! Get the number of function arguments.
  inline uint32_t argCount() const noexcept { return _argCount; }

  inline bool hasRet() const noexcept { return _ret != Type::kIdVoid; }
  //! Get the return value type.
  inline uint32_t ret() const noexcept { return _ret; }

  //! Get the type of the argument at index `i`.
  inline uint32_t arg(uint32_t i) const noexcept {
    ASMJIT_ASSERT(i < _argCount);
    return _args[i];
  }
  //! Get the array of function arguments' types.
  inline const uint8_t* args() const noexcept { return _args; }

  // --------------------------------------------------------------------------
  // [Members]
  // --------------------------------------------------------------------------

  uint8_t _callConv;                     //!< Calling convention id.
  uint8_t _argCount;                     //!< Count of arguments.
  uint8_t _vaIndex;                      //!< Index of a first VA or `kNoVarArgs`.
  uint8_t _ret;                          //!< Return value TypeId.
  const uint8_t* _args;                  //!< Function arguments TypeIds.
};

// ============================================================================
// [asmjit::FuncSignatureT]
// ============================================================================

template<typename... RET_ARGS>
class FuncSignatureT : public FuncSignature {
public:
  inline FuncSignatureT(uint32_t ccId = CallConv::kIdHost) noexcept {
    static const uint8_t ret_args[] = { (uint8_t(Type::IdOfT<RET_ARGS>::kTypeId))... };
    init(ccId, ret_args[0], ret_args + 1, uint32_t(ASMJIT_ARRAY_SIZE(ret_args) - 1));
  }
};

// ============================================================================
// [asmjit::FuncSignatureBuilder]
// ============================================================================

//! Function signature builder.
class FuncSignatureBuilder : public FuncSignature {
public:
  // --------------------------------------------------------------------------
  // [Construction / Destruction]
  // --------------------------------------------------------------------------

  inline FuncSignatureBuilder(uint32_t ccId = CallConv::kIdHost) noexcept {
    init(ccId, Type::kIdVoid, _builderArgList, 0);
  }

  // --------------------------------------------------------------------------
  // [Accessors]
  // --------------------------------------------------------------------------

  inline void setCallConv(uint32_t ccId) noexcept { _callConv = uint8_t(ccId); }

  //! Set the return type to `retType`.
  inline void setRet(uint32_t retType) noexcept { _ret = uint8_t(retType); }
  //! Set the return type based on `T`.
  template<typename T>
  inline void setRetT() noexcept { setRet(Type::IdOfT<T>::kTypeId); }

  //! Set the argument at index `index` to `argType`.
  inline void setArg(uint32_t index, uint32_t argType) noexcept {
    ASMJIT_ASSERT(index < _argCount);
    _builderArgList[index] = uint8_t(argType);
  }
  //! Set the argument at index `i` to the type based on `T`.
  template<typename T>
  inline void setArgT(uint32_t index) noexcept { setArg(index, Type::IdOfT<T>::kTypeId); }

  //! Append an argument of `type` to the function prototype.
  inline void addArg(uint32_t type) noexcept {
    ASMJIT_ASSERT(_argCount < kFuncArgCount);
    _builderArgList[_argCount++] = uint8_t(type);
  }
  //! Append an argument of type based on `T` to the function prototype.
  template<typename T>
  inline void addArgT() noexcept { addArg(Type::IdOfT<T>::kTypeId); }

  // --------------------------------------------------------------------------
  // [Members]
  // --------------------------------------------------------------------------

  uint8_t _builderArgList[kFuncArgCount];
};

// ============================================================================
// [asmjit::FuncValue]
// ============================================================================

//! Argument or return value as defined by `FuncSignature`, but with register
//! or stack address (and other metadata) assigned to it.
struct FuncValue {
  enum Parts : uint32_t {
    kTypeIdShift      = 0,             //!< TypeId shift.
    kTypeIdMask       = 0x000000FFu,   //!< TypeId mask.

    kFlagIsReg        = 0x00000100u,   //!< Passed by register.
    kFlagIsStack      = 0x00000200u,   //!< Passed by stack.
    kFlagIsIndirect   = 0x00000400u,   //!< Passed indirectly by reference (internally a pointer).
    kFlagIsDone       = 0x00000800u,   //!< Used internally by arguments allocator.

    kStackOffsetShift = 12,            //!< Stack offset shift.
    kStackOffsetMask  = 0xFFFFF000u,   //!< Stack offset mask (must occupy MSB bits).

    kRegIdShift       = 16,            //!< RegId shift.
    kRegIdMask        = 0x00FF0000u,   //!< RegId mask.

    kRegTypeShift     = 24,            //!< RegType shift.
    kRegTypeMask      = 0xFF000000u    //!< RegType mask.
  };

  // --------------------------------------------------------------------------
  // [Init / Reset]
  // --------------------------------------------------------------------------

  // These initialize the whole `FuncValue` to either register or stack. Useful
  // when you know all of these properties and wanna just set it up.

  //! Initialize this in/out by a given `typeId`.
  inline void initTypeId(uint32_t typeId) noexcept {
    _data = typeId << kTypeIdShift;
  }

  inline void initReg(uint32_t regType, uint32_t regId, uint32_t typeId, uint32_t flags = 0) noexcept {
    _data = (regType << kRegTypeShift) | (regId << kRegIdShift) | (typeId << kTypeIdShift) | kFlagIsReg | flags;
  }

  inline void initStack(int32_t offset, uint32_t typeId) noexcept {
    _data = (uint32_t(offset) << kStackOffsetShift) | (typeId << kTypeIdShift) | kFlagIsStack;
  }

  //! Reset the value to its unassigned state.
  inline void reset() noexcept { _data = 0; }

  // --------------------------------------------------------------------------
  // [Assign]
  // --------------------------------------------------------------------------

  // These initialize only part of `FuncValue`, useful when building `FuncValue`
  // incrementally. The caller should first init the type-id by caliing `initTypeId`
  // and then continue building either register or stack.

  inline void assignRegData(uint32_t regType, uint32_t regId) noexcept {
    ASMJIT_ASSERT((_data & (kRegTypeMask | kRegIdMask)) == 0);
    _data |= (regType << kRegTypeShift) | (regId << kRegIdShift) | kFlagIsReg;
  }

  inline void assignStackOffset(int32_t offset) noexcept {
    ASMJIT_ASSERT((_data & kStackOffsetMask) == 0);
    _data |= (uint32_t(offset) << kStackOffsetShift) | kFlagIsStack;
  }

  // --------------------------------------------------------------------------
  // [Accessors]
  // --------------------------------------------------------------------------

  inline void _replaceValue(uint32_t mask, uint32_t value) noexcept { _data = (_data & ~mask) | value; }

  //! Get whether the `FuncValue` has a flag `flag` set.
  inline bool hasFlag(uint32_t flag) const noexcept { return (_data & flag) != 0; }
  //! Add `flags` to `FuncValue`.
  inline void addFlags(uint32_t flags) noexcept { _data |= flags; }
  //! Clear `flags` of `FuncValue`.
  inline void clearFlags(uint32_t flags) noexcept { _data &= ~flags; }

  //! Get whether this value is initialized (i.e. contains a valid data).
  inline bool isInitialized() const noexcept { return _data != 0; }
  //! Get whether this argument is passed by register.
  inline bool isReg() const noexcept { return hasFlag(kFlagIsReg); }
  //! Get whether this argument is passed by stack.
  inline bool isStack() const noexcept { return hasFlag(kFlagIsStack); }
  //! Get whether this argument is passed by register.
  inline bool isAssigned() const noexcept { return hasFlag(kFlagIsReg | kFlagIsStack); }
  //! Get whether this argument is passed through a pointer (used by WIN64 to pass XMM|YMM|ZMM).
  inline bool isIndirect() const noexcept { return hasFlag(kFlagIsIndirect); }

  inline bool isDone() const noexcept { return hasFlag(kFlagIsDone); }

  //! Get a register type of the register used to pass function argument or return value.
  inline uint32_t regType() const noexcept { return (_data & kRegTypeMask) >> kRegTypeShift; }
  //! Set a register type of the register used to pass function argument or return value.
  inline void setRegType(uint32_t regType) noexcept { _replaceValue(kRegTypeMask, regType << kRegTypeShift); }

  //! Get a physical id of the register used to pass function argument or return value.
  inline uint32_t regId() const noexcept { return (_data & kRegIdMask) >> kRegIdShift; }
  //! Set a physical id of the register used to pass function argument or return value.
  inline void setRegId(uint32_t regId) noexcept { _replaceValue(kRegIdMask, regId << kRegIdShift); }

  //! Get a stack offset of this argument.
  inline int32_t stackOffset() const noexcept { return int32_t(_data & kStackOffsetMask) >> kStackOffsetShift; }
  //! Set a stack offset of this argument.
  inline void setStackOffset(int32_t offset) noexcept { _replaceValue(kStackOffsetMask, uint32_t(offset) << kStackOffsetShift); }

  //! Get a TypeId of this argument or return value.
  inline bool hasTypeId() const noexcept { return (_data & kTypeIdMask) != 0; }
  //! Get a TypeId of this argument or return value.
  inline uint32_t typeId() const noexcept { return (_data & kTypeIdMask) >> kTypeIdShift; }
  //! Set a TypeId of this argument or return value.
  inline void setTypeId(uint32_t typeId) noexcept { _replaceValue(kTypeIdMask, typeId << kTypeIdShift); }

  // --------------------------------------------------------------------------
  // [Members]
  // --------------------------------------------------------------------------

  uint32_t _data;
};

// ============================================================================
// [asmjit::FuncDetail]
// ============================================================================

//! Function detail - CallConv and expanded FuncSignature.
//!
//! Function details is architecture and OS dependent representation of function.
//! It contains calling convention and expanded function signature so all
//! arguments have assigned either register type & id or stack address.
class FuncDetail {
public:
  // --------------------------------------------------------------------------
  // [Construction / Destruction]
  // --------------------------------------------------------------------------

  inline FuncDetail() noexcept { reset(); }
  inline FuncDetail(const FuncDetail& other) noexcept = default;

  // --------------------------------------------------------------------------
  // [Init / Reset]
  // --------------------------------------------------------------------------

  //! Initialize this `FuncDetail` to the given signature.
  ASMJIT_API Error init(const FuncSignature& sign);
  inline void reset() noexcept { std::memset(this, 0, sizeof(*this)); }

  // --------------------------------------------------------------------------
  // [Accessors - Calling Convention]
  // --------------------------------------------------------------------------

  //! Get the function's calling convention, see `CallConv`.
  inline const CallConv& callConv() const noexcept { return _callConv; }

  //! Get CallConv flags, see `CallConv::Flags`.
  inline uint32_t flags() const noexcept { return _callConv.flags(); }
  //! Check if a CallConv `flag` is set, see `CallConv::Flags`.
  inline bool hasFlag(uint32_t ccFlag) const noexcept { return _callConv.hasFlag(ccFlag); }

  // --------------------------------------------------------------------------
  // [Accessors - Arguments and Return]
  // --------------------------------------------------------------------------

  //! Get count of function return values.
  inline uint32_t retCount() const noexcept { return _retCount; }
  //! Get the number of function arguments.
  inline uint32_t argCount() const noexcept { return _argCount; }

  //! Get whether the function has a return value.
  inline bool hasRet() const noexcept { return _retCount != 0; }
  //! Get function return value.
  inline FuncValue& ret(uint32_t index = 0) noexcept {
    ASMJIT_ASSERT(index < ASMJIT_ARRAY_SIZE(_rets));
    return _rets[index];
  }
  //! Get function return value (const).
  inline const FuncValue& ret(uint32_t index = 0) const noexcept {
    ASMJIT_ASSERT(index < ASMJIT_ARRAY_SIZE(_rets));
    return _rets[index];
  }

  //! Get function arguments array.
  inline FuncValue* args() noexcept { return _args; }
  //! Get function arguments array (const).
  inline const FuncValue* args() const noexcept { return _args; }

  inline bool hasArg(uint32_t index) const noexcept {
    ASMJIT_ASSERT(index < kFuncArgCountLoHi);
    return _args[index].isInitialized();
  }

  //! Get function argument at index `index`.
  inline FuncValue& arg(uint32_t index) noexcept {
    ASMJIT_ASSERT(index < kFuncArgCountLoHi);
    return _args[index];
  }

  //! Get function argument at index `index`.
  inline const FuncValue& arg(uint32_t index) const noexcept {
    ASMJIT_ASSERT(index < kFuncArgCountLoHi);
    return _args[index];
  }

  inline void resetArg(uint32_t index) noexcept {
    ASMJIT_ASSERT(index < kFuncArgCountLoHi);
    _args[index].reset();
  }

  //! Get whether the function passes one or more argument by stack.
  inline bool hasStackArgs() const noexcept { return _argStackSize != 0; }
  //! Get stack size needed for function arguments passed on the stack.
  inline uint32_t argStackSize() const noexcept { return _argStackSize; }

  inline uint32_t redZoneSize() const noexcept { return _callConv.redZoneSize(); }
  inline uint32_t spillZoneSize() const noexcept { return _callConv.spillZoneSize(); }
  inline uint32_t naturalStackAlignment() const noexcept { return _callConv.naturalStackAlignment(); }

  inline uint32_t passedRegs(uint32_t group) const noexcept { return _callConv.passedRegs(group); }
  inline uint32_t preservedRegs(uint32_t group) const noexcept { return _callConv.preservedRegs(group); }

  inline uint32_t usedRegs(uint32_t group) const noexcept {
    ASMJIT_ASSERT(group < BaseReg::kGroupVirt);
    return _usedRegs[group];
  }

  inline void addUsedRegs(uint32_t group, uint32_t regs) noexcept {
    ASMJIT_ASSERT(group < BaseReg::kGroupVirt);
    _usedRegs[group] |= regs;
  }

  // --------------------------------------------------------------------------
  // [Members]
  // --------------------------------------------------------------------------

  CallConv _callConv;                    //!< Calling convention.
  uint8_t _argCount;                     //!< Number of function arguments.
  uint8_t _retCount;                     //!< Number of function return values.
  uint16_t _reserved;                    //!< Reserved.
  uint32_t _usedRegs[BaseReg::kGroupVirt];//!< Registers that contains arguments.
  uint32_t _argStackSize;                //!< Size of arguments passed by stack.
  FuncValue _rets[2];                    //!< Function return values.
  FuncValue _args[kFuncArgCountLoHi];    //!< Function arguments.
};

// ============================================================================
// [asmjit::FuncFrame]
// ============================================================================

//! Function frame.
//!
//! Function frame is used directly by prolog and epilog insertion (PEI) utils.
//! It provides information necessary to insert a proper and ABI comforming
//! prolog and epilog. Function frame calculation is based on `CallConv` and
//! other function attributes.
//!
//! Function Frame Structure
//! ------------------------
//!
//! Various properties can contribute to the size and structure of the function
//! frame. The function frame in most cases won't use all of the properties
//! illustrated (for example Spill Zone and Red Zone are never used together).
//!
//!   +-----------------------------+
//!   | Arguments Passed by Stack   |
//!   +-----------------------------+
//!   | Spill Zone                  |
//!   +-----------------------------+ <- Stack offset (args) starts from here.
//!   | Return Address if Pushed    |
//!   +-----------------------------+ <- Stack pointer (SP) upon entry.
//!   | Save/Restore Stack.         |
//!   +-----------------------------+-----------------------------+
//!   | Local Stack                 |                             |
//!   +-----------------------------+          Final Stack        |
//!   | Call Stack                  |                             |
//!   +-----------------------------+-----------------------------+
//!   | Red Zone                    |
//!   +-----------------------------+
class FuncFrame {
public:
  enum Group : uint32_t {
    kGroupVirt = BaseReg::kGroupVirt
  };

  enum Tag : uint32_t {
    kTagInvalidOffset     = 0xFFFFFFFFu  //!< Tag used to inform that some offset is invalid.
  };

  //! Attributes are designed in a way that all are initially false, and user
  //! or FuncFrame finalizer adds them when necessary.
  enum Attributes : uint32_t {
    kAttrHasPreservedFP   = 0x00000001u, //!< Preserve frame pointer (don't omit FP).
    kAttrHasFuncCalls     = 0x00000002u, //!< Function calls other functions (is not leaf).

    kAttrX86AvxEnabled    = 0x00010000u, //!< Use AVX instead of SSE for all operations (X86).
    kAttrX86AvxCleanup    = 0x00020000u, //!< Emit VZEROUPPER instruction in epilog (X86).
    kAttrX86MmxCleanup    = 0x00040000u, //!< Emit EMMS instruction in epilog (X86).

    kAttrAlignedVecSR     = 0x40000000u, //!< Function has aligned save/restore of vector registers.
    kAttrIsFinalized      = 0x80000000u  //!< FuncFrame is finalized and can be used by PEI.
  };

  // --------------------------------------------------------------------------
  // [Construction / Destruction]
  // --------------------------------------------------------------------------

  inline FuncFrame() noexcept { reset(); }
  inline FuncFrame(const FuncFrame& other) noexcept = default;

  // --------------------------------------------------------------------------
  // [Init / Reset / Finalize]
  // --------------------------------------------------------------------------

  ASMJIT_API Error init(const FuncDetail& func) noexcept;
  ASMJIT_API Error finalize() noexcept;

  inline void reset() noexcept {
    std::memset(this, 0, sizeof(FuncFrame));
    _spRegId = BaseReg::kIdBad;
    _saRegId = BaseReg::kIdBad;
    _daOffset = kTagInvalidOffset;
  }

  // --------------------------------------------------------------------------
  // [Accessors]
  // --------------------------------------------------------------------------

  //! Get the target architecture of the function frame.
  inline uint32_t archId() const noexcept { return _archId; }

  //! Get FuncFrame attributes, see `Attributes`.
  inline uint32_t attributes() const noexcept { return _attributes; }
  //! Check if the FuncFame contains an attribute `attr`.
  inline bool hasAttribute(uint32_t attr) const noexcept { return (_attributes & attr) != 0; }
  //! Add attributes `attrs` to the FuncFrame.
  inline void addAttributes(uint32_t attrs) noexcept { _attributes |= attrs; }
  //! Clear attributes `attrs` from the FrameFrame.
  inline void clearAttributes(uint32_t attrs) noexcept { _attributes &= ~attrs; }

  //! Get whether the function preserves frame pointer (EBP|ESP on X86).
  inline bool hasPreservedFP() const noexcept { return hasAttribute(kAttrHasPreservedFP); }
  //! Enable preserved frame pointer.
  inline void setPreservedFP() noexcept { addAttributes(kAttrHasPreservedFP); }
  //! Disable preserved frame pointer.
  inline void resetPreservedFP() noexcept { clearAttributes(kAttrHasPreservedFP); }

  //! Get whether the function calls other functions.
  inline bool hasFuncCalls() const noexcept { return hasAttribute(kAttrHasFuncCalls); }
  //! Set `kFlagHasCalls` to true.
  inline void setFuncCalls() noexcept { addAttributes(kAttrHasFuncCalls); }
  //! Set `kFlagHasCalls` to false.
  inline void resetFuncCalls() noexcept { clearAttributes(kAttrHasFuncCalls); }

  //! Get whether the function contains AVX cleanup - 'vzeroupper' instruction in epilog.
  inline bool hasAvxCleanup() const noexcept { return hasAttribute(kAttrX86AvxCleanup); }
  //! Enable AVX cleanup.
  inline void setAvxCleanup() noexcept { addAttributes(kAttrX86AvxCleanup); }
  //! Disable AVX cleanup.
  inline void resetAvxCleanup() noexcept { clearAttributes(kAttrX86AvxCleanup); }

  //! Get whether the function contains AVX cleanup - 'vzeroupper' instruction in epilog.
  inline bool isAvxEnabled() const noexcept { return hasAttribute(kAttrX86AvxEnabled); }
  //! Enable AVX cleanup.
  inline void setAvxEnabled() noexcept { addAttributes(kAttrX86AvxEnabled); }
  //! Disable AVX cleanup.
  inline void resetAvxEnabled() noexcept { clearAttributes(kAttrX86AvxEnabled); }

  //! Get whether the function contains MMX cleanup - 'emms' instruction in epilog.
  inline bool hasMmxCleanup() const noexcept { return hasAttribute(kAttrX86MmxCleanup); }
  //! Enable MMX cleanup.
  inline void setMmxCleanup() noexcept { addAttributes(kAttrX86MmxCleanup); }
  //! Disable MMX cleanup.
  inline void resetMmxCleanup() noexcept { clearAttributes(kAttrX86MmxCleanup); }

  //! Get whether the function uses call stack.
  inline bool hasCallStack() const noexcept { return _callStackSize != 0; }
  //! Get whether the function uses local stack.
  inline bool hasLocalStack() const noexcept { return _localStackSize != 0; }
  //! Get whether vector registers can be saved and restored by using aligned reads and writes.
  inline bool hasAlignedVecSR() const noexcept { return hasAttribute(kAttrAlignedVecSR); }
  //! Get whether the function has to align stack dynamically.
  inline bool hasDynamicAlignment() const noexcept { return _finalStackAlignment >= _minDynamicAlignment; }

  //! Get whether this calling convention specifies 'RedZone'.
  inline bool hasRedZone() const noexcept { return _redZoneSize != 0; }
  //! Get whether this calling convention specifies 'SpillZone'.
  inline bool hasSpillZone() const noexcept { return _spillZoneSize != 0; }

  //! Get size of 'RedZone'.
  inline uint32_t redZoneSize() const noexcept { return _redZoneSize; }
  //! Get size of 'SpillZone'.
  inline uint32_t spillZoneSize() const noexcept { return _spillZoneSize; }
  //! Get natural stack alignment (guaranteed stack alignment upon entry).
  inline uint32_t naturalStackAlignment() const noexcept { return _naturalStackAlignment; }
  //! Get natural stack alignment (guaranteed stack alignment upon entry).
  inline uint32_t minDynamicAlignment() const noexcept { return _minDynamicAlignment; }

  //! Get whether the callee must adjust SP before returning (X86-STDCALL only)
  inline bool hasCalleeStackCleanup() const noexcept { return _calleeStackCleanup != 0; }
  //! Get home many bytes of the stack the the callee must adjust before returning (X86-STDCALL only)
  inline uint32_t calleeStackCleanup() const noexcept { return _calleeStackCleanup; }

  //! Get call stack alignment.
  inline uint32_t callStackAlignment() const noexcept { return _callStackAlignment; }
  //! Get local stack alignment.
  inline uint32_t localStackAlignment() const noexcept { return _localStackAlignment; }
  //! Get final stack alignment (the maximum value of call, local, and natural stack alignments).
  inline uint32_t finalStackAlignment() const noexcept { return _finalStackAlignment; }

  //! Set call stack alignment.
  //!
  //! NOTE: This also updates the final stack alignment.
  inline void setCallStackAlignment(uint32_t alignment) noexcept {
    _callStackAlignment = uint8_t(alignment);
    _finalStackAlignment = std::max(_naturalStackAlignment, std::max(_callStackAlignment, _localStackAlignment));
  }

  //! Set local stack alignment.
  //!
  //! NOTE: This also updates the final stack alignment.
  inline void setLocalStackAlignment(uint32_t value) noexcept {
    _localStackAlignment = uint8_t(value);
    _finalStackAlignment = std::max(_naturalStackAlignment, std::max(_callStackAlignment, _localStackAlignment));
  }

  //! Combine call stack alignment with `alignment`, updating it to the greater value.
  //!
  //! NOTE: This also updates the final stack alignment.
  inline void updateCallStackAlignment(uint32_t alignment) noexcept {
    _callStackAlignment = uint8_t(std::max<uint32_t>(_callStackAlignment, alignment));
    _finalStackAlignment = std::max(_finalStackAlignment, _callStackAlignment);
  }

  //! Combine local stack alignment with `alignment`, updating it to the greater value.
  //!
  //! NOTE: This also updates the final stack alignment.
  inline void updateLocalStackAlignment(uint32_t alignment) noexcept {
    _localStackAlignment = uint8_t(std::max<uint32_t>(_localStackAlignment, alignment));
    _finalStackAlignment = std::max(_finalStackAlignment, _localStackAlignment);
  }

  //! Get call stack size.
  inline uint32_t callStackSize() const noexcept { return _callStackSize; }
  //! Get local stack size.
  inline uint32_t localStackSize() const noexcept { return _localStackSize; }

  //! Set call stack size.
  inline void setCallStackSize(uint32_t size) noexcept { _callStackSize = size; }
  //! Set local stack size.
  inline void setLocalStackSize(uint32_t size) noexcept { _localStackSize = size; }

  //! Combine call stack size with `size`, updating it to the greater value.
  inline void updateCallStackSize(uint32_t size) noexcept { _callStackSize = std::max(_callStackSize, size); }
  //! Combine local stack size with `size`, updating it to the greater value.
  inline void updateLocalStackSize(uint32_t size) noexcept { _localStackSize = std::max(_localStackSize, size); }

  //! Get final stack size (only valid after the FuncFrame is finalized).
  inline uint32_t finalStackSize() const noexcept { return _finalStackSize; }

  //! Get an offset to access the local stack (non-zero only if call stack is used).
  inline uint32_t localStackOffset() const noexcept { return _localStackOffset; }

  //! Get whether the function prolog/epilog requires a memory slot for storing unaligned SP.
  inline bool hasDAOffset() const noexcept { return _daOffset != kTagInvalidOffset; }
  //! Get a memory offset used to store DA (dynamic alignment) slot (relative to SP).
  inline uint32_t daOffset() const noexcept { return _daOffset; }

  inline uint32_t saOffset(uint32_t regId) const noexcept {
    return regId == _spRegId ? saOffsetFromSP()
                             : saOffsetFromSA();
  }

  inline uint32_t saOffsetFromSP() const noexcept { return _saOffsetFromSP; }
  inline uint32_t saOffsetFromSA() const noexcept { return _saOffsetFromSA; }

  //! Get which registers (by `group`) are saved/restored in prolog/epilog, respectively.
  inline uint32_t dirtyRegs(uint32_t group) const noexcept {
    ASMJIT_ASSERT(group < BaseReg::kGroupVirt);
    return _dirtyRegs[group];
  }

  //! Set which registers (by `group`) are saved/restored in prolog/epilog, respectively.
  inline void setDirtyRegs(uint32_t group, uint32_t regs) noexcept {
    ASMJIT_ASSERT(group < BaseReg::kGroupVirt);
    _dirtyRegs[group] = regs;
  }

  //! Add registers (by `group`) to saved/restored registers.
  inline void addDirtyRegs(uint32_t group, uint32_t regs) noexcept {
    ASMJIT_ASSERT(group < BaseReg::kGroupVirt);
    _dirtyRegs[group] |= regs;
  }

  inline void setAllDirty() noexcept {
    _dirtyRegs[0] = 0xFFFFFFFFu;
    _dirtyRegs[1] = 0xFFFFFFFFu;
    _dirtyRegs[2] = 0xFFFFFFFFu;
    _dirtyRegs[3] = 0xFFFFFFFFu;
  }

  inline void setAllDirty(uint32_t group) noexcept {
    ASMJIT_ASSERT(group < BaseReg::kGroupVirt);
    _dirtyRegs[group] = 0xFFFFFFFFu;
  }

  inline uint32_t savedRegs(uint32_t group) const noexcept {
    ASMJIT_ASSERT(group < BaseReg::kGroupVirt);
    return _dirtyRegs[group] & _preservedRegs[group];
  }

  inline uint32_t preservedRegs(uint32_t group) const noexcept {
    ASMJIT_ASSERT(group < BaseReg::kGroupVirt);
    return _preservedRegs[group];
  }

  inline bool hasSARegId() const noexcept { return _saRegId != BaseReg::kIdBad; }
  inline uint32_t saRegId() const noexcept { return _saRegId; }
  inline void setSARegId(uint32_t regId) { _saRegId = uint8_t(regId); }
  inline void resetSARegId() { setSARegId(BaseReg::kIdBad); }

  //! Get stack size required to save GP registers.
  inline uint32_t gpSaveSize() const noexcept { return _gpSaveSize; }
  //! Get stack size required to save other than GP registers (MM, XMM|YMM|ZMM, K, VFP, etc...).
  inline uint32_t nonGpSaveSize() const noexcept { return _nonGpSaveSize; }

  inline uint32_t gpSaveOffset() const noexcept { return _gpSaveOffset; }
  inline uint32_t nonGpSaveOffset() const noexcept { return _nonGpSaveOffset; }

  inline bool hasStackAdjustment() const noexcept { return _stackAdjustment != 0; }
  inline uint32_t stackAdjustment() const noexcept { return _stackAdjustment; }

  // --------------------------------------------------------------------------
  // [Members]
  // --------------------------------------------------------------------------

  uint32_t _attributes;                  //!< Function attributes.

  uint8_t _archId;                       //!< Architecture ID.
  uint8_t _spRegId;                      //!< SP register ID (to access call stack and local stack).
  uint8_t _saRegId;                      //!< SA register ID (to access stack arguments).

  uint8_t _redZoneSize;                  //!< Red zone size (copied from CallConv).
  uint8_t _spillZoneSize;                //!< Spill zone size (copied from CallConv).
  uint8_t _naturalStackAlignment;        //!< Natural stack alignment (copied from CallConv).
  uint8_t _minDynamicAlignment;      //!< Minimum stack alignment to turn on dynamic alignment.

  uint8_t _callStackAlignment;           //!< Call stack alignment.
  uint8_t _localStackAlignment;          //!< Local stack alignment.
  uint8_t _finalStackAlignment;          //!< Final stack alignment.

  uint16_t _calleeStackCleanup;          //!< Adjustment of the stack before returning (X86-STDCALL).

  uint32_t _callStackSize;               //!< Call stack size.
  uint32_t _localStackSize;              //!< Local stack size.
  uint32_t _finalStackSize;              //!< Final stack size (sum of call stack and local stack).

  uint32_t _localStackOffset;            //!< Local stack offset (non-zero only if call stack is used).
  uint32_t _daOffset;                    //!< Offset relative to SP that contains previous SP (before alignment).
  uint32_t _saOffsetFromSP;              //!< Offset of the first stack argument relative to SP.
  uint32_t _saOffsetFromSA;              //!< Offset of the first stack argument relative to SA (_saRegId or FP).

  uint32_t _stackAdjustment;             //!< Local stack adjustment in prolog/epilog.

  uint32_t _dirtyRegs[BaseReg::kGroupVirt];     //!< Registers that are dirty.
  uint32_t _preservedRegs[BaseReg::kGroupVirt]; //!< Registers that must be preserved (copied from CallConv).

  uint16_t _gpSaveSize;                  //!< Final stack size required to save GP regs.
  uint16_t _nonGpSaveSize;               //!< Final Stack size required to save other than GP regs.
  uint32_t _gpSaveOffset;                //!< Final offset where saved GP regs are stored.
  uint32_t _nonGpSaveOffset;             //!< Final offset where saved other than GP regs are stored.
};

// ============================================================================
// [asmjit::FuncArgsAssignment]
// ============================================================================

//! A helper class that can be used to assign a physical register for each
//! function argument. Use with `BaseEmitter::emitArgsAssignment()`.
class FuncArgsAssignment {
public:
  enum {
    kArgCount = kFuncArgCountLoHi
  };

  inline explicit FuncArgsAssignment(const FuncDetail* fd = nullptr) noexcept { reset(fd); }

  inline FuncArgsAssignment(const FuncArgsAssignment& other) noexcept {
    std::memcpy(this, &other, sizeof(*this));
  }

  // --------------------------------------------------------------------------
  // [Init / Reset]
  // --------------------------------------------------------------------------

  inline void reset(const FuncDetail* fd = nullptr) noexcept {
    _funcDetail = fd;
    _saRegId = uint8_t(BaseReg::kIdBad);
    std::memset(_reserved, 0, sizeof(_reserved));
    std::memset(_args, 0, sizeof(_args));
  }

  // --------------------------------------------------------------------------
  // [Accessors]
  // --------------------------------------------------------------------------

  inline const FuncDetail* funcDetail() const noexcept { return _funcDetail; }
  inline void setFuncDetail(const FuncDetail* fd) noexcept { _funcDetail = fd; }

  inline bool hasSARegId() const noexcept { return _saRegId != BaseReg::kIdBad; }
  inline uint32_t saRegId() const noexcept { return _saRegId; }
  inline void setSARegId(uint32_t regId) { _saRegId = uint8_t(regId); }
  inline void resetSARegId() { _saRegId = uint8_t(BaseReg::kIdBad); }

  inline FuncValue& arg(uint32_t index) noexcept {
    ASMJIT_ASSERT(index < ASMJIT_ARRAY_SIZE(_args));
    return _args[index];
  }
  inline const FuncValue& arg(uint32_t index) const noexcept {
    ASMJIT_ASSERT(index < ASMJIT_ARRAY_SIZE(_args));
    return _args[index];
  }

  inline bool isAssigned(uint32_t argIndex) const noexcept {
    ASMJIT_ASSERT(argIndex < ASMJIT_ARRAY_SIZE(_args));
    return _args[argIndex].isAssigned();
  }

  inline void assignReg(uint32_t argIndex, const BaseReg& reg, uint32_t typeId = Type::kIdVoid) noexcept {
    ASMJIT_ASSERT(argIndex < ASMJIT_ARRAY_SIZE(_args));
    ASMJIT_ASSERT(reg.isPhysReg());
    _args[argIndex].initReg(reg.type(), reg.id(), typeId);
  }

  inline void assignReg(uint32_t argIndex, uint32_t regType, uint32_t regId, uint32_t typeId = Type::kIdVoid) noexcept {
    ASMJIT_ASSERT(argIndex < ASMJIT_ARRAY_SIZE(_args));
    _args[argIndex].initReg(regType, regId, typeId);
  }

  inline void assignStack(uint32_t argIndex, int32_t offset, uint32_t typeId = Type::kIdVoid) {
    ASMJIT_ASSERT(argIndex < ASMJIT_ARRAY_SIZE(_args));
    _args[argIndex].initStack(offset, typeId);
  }

  // NOTE: All `assignAll()` methods are shortcuts to assign all arguments at
  // once, however, since registers are passed all at once these initializers
  // don't provide any way to pass TypeId and/or to keep any argument between
  // the arguments passed unassigned.
  inline void assignAll(const BaseReg& a0) noexcept {
    assignReg(0, a0);
  }

  inline void assignAll(const BaseReg& a0, const BaseReg& a1) noexcept {
    assignReg(0, a0);
    assignReg(1, a1);
  }

  inline void assignAll(const BaseReg& a0, const BaseReg& a1, const BaseReg& a2) noexcept {
    assignReg(0, a0);
    assignReg(1, a1);
    assignReg(2, a2);
  }

  inline void assignAll(const BaseReg& a0, const BaseReg& a1, const BaseReg& a2, const BaseReg& a3) noexcept {
    assignReg(0, a0);
    assignReg(1, a1);
    assignReg(2, a2);
    assignReg(3, a3);
  }

  inline void assignAll(const BaseReg& a0, const BaseReg& a1, const BaseReg& a2, const BaseReg& a3, const BaseReg& a4) noexcept {
    assignReg(0, a0);
    assignReg(1, a1);
    assignReg(2, a2);
    assignReg(3, a3);
    assignReg(4, a4);
  }

  inline void assignAll(const BaseReg& a0, const BaseReg& a1, const BaseReg& a2, const BaseReg& a3, const BaseReg& a4, const BaseReg& a5) noexcept {
    assignReg(0, a0);
    assignReg(1, a1);
    assignReg(2, a2);
    assignReg(3, a3);
    assignReg(4, a4);
    assignReg(5, a5);
  }

  inline void assignAll(const BaseReg& a0, const BaseReg& a1, const BaseReg& a2, const BaseReg& a3, const BaseReg& a4, const BaseReg& a5, const BaseReg& a6) noexcept {
    assignReg(0, a0);
    assignReg(1, a1);
    assignReg(2, a2);
    assignReg(3, a3);
    assignReg(4, a4);
    assignReg(5, a5);
    assignReg(6, a6);
  }

  inline void assignAll(const BaseReg& a0, const BaseReg& a1, const BaseReg& a2, const BaseReg& a3, const BaseReg& a4, const BaseReg& a5, const BaseReg& a6, const BaseReg& a7) noexcept {
    assignReg(0, a0);
    assignReg(1, a1);
    assignReg(2, a2);
    assignReg(3, a3);
    assignReg(4, a4);
    assignReg(5, a5);
    assignReg(6, a6);
    assignReg(7, a7);
  }

  // --------------------------------------------------------------------------
  // [Utilities]
  // --------------------------------------------------------------------------

  //! Update `FuncFrame` based on function's arguments assignment.
  //!
  //! NOTE: You MUST call this in orher to use `BaseEmitter::emitArgsAssignment()`,
  //! otherwise the FuncFrame would not contain the information necessary to
  //! assign all arguments into the registers and/or stack specified.
  ASMJIT_API Error updateFuncFrame(FuncFrame& frame) const noexcept;

  // --------------------------------------------------------------------------
  // [Members]
  // --------------------------------------------------------------------------

  const FuncDetail* _funcDetail;         //!< Function detail.
  uint8_t _saRegId;                      //!< Register that can be used to access arguments passed by stack.
  uint8_t _reserved[3];                  //!< \internal
  FuncValue _args[kArgCount];            //!< Mapping of each function argument.
};

//! \}

ASMJIT_END_NAMESPACE

// [Guard]
#endif // _ASMJIT_CORE_FUNC_H

```

`Avanguard/AsmJit/asmjit/core/globals.h`:

```h
// [AsmJit]
// Complete x86/x64 JIT and Remote Assembler for C++.
//
// [License]
// ZLIB - See LICENSE.md file in the package.

// [Guard]
#ifndef _ASMJIT_CORE_GLOBALS_H
#define _ASMJIT_CORE_GLOBALS_H

// [Dependencies]
#include "../core/build.h"

ASMJIT_BEGIN_NAMESPACE

//! \addtogroup asmjit_core_api
//! \{

// ============================================================================
// [asmjit::Globals]
// ============================================================================

namespace Globals {

// ============================================================================
// [asmjit::Globals::<global>]
// ============================================================================

//! Host memory allocator overhead.
constexpr uint32_t kMemAllocOverhead = uint32_t(sizeof(intptr_t) * 4);

//! Host memory allocator alignment.
constexpr uint32_t kMemAllocAlignment = 8;

//! Aggressive growing strategy threshold.
constexpr uint32_t kAllocThreshold = 8192 * 1024;

//! Maximum height of RB-Tree is:
//!
//!   `2 * log2(n + 1)`.
//!
//! Size of RB node is at least two pointers (without data),
//! so a theoretical architecture limit would be:
//!
//!   `2 * log2(addressableMemorySize / sizeof(Node) + 1)`
//!
//! Which yields 30 on 32-bit arch and 61 on 64-bit arch.
//! The final value was adjusted by +1 for safety reasons.
constexpr uint32_t kMaxTreeHeight = (ASMJIT_ARCH_BITS == 32 ? 30 : 61) + 1;

//! Maximum number of operands per a single instruction.
constexpr uint32_t kMaxOpCount = 6;

// TODO: Use this one.
constexpr uint32_t kMaxFuncArgs = 16;

//! Maximum number of physical registers AsmJit can use per register group.
constexpr uint32_t kMaxPhysRegs = 32;

//! Maximum alignment.
constexpr uint32_t kMaxAlignment = 64;

//! Maximum label or symbol size in bytes.
constexpr uint32_t kMaxLabelNameSize = 2048;

//! Maximum size of comment.
constexpr uint32_t kMaxCommentSize = 1024;

//! Returned by `indexOf()` and similar when working with containers that use 32-bit index/size.
constexpr uint32_t kNotFound = std::numeric_limits<uint32_t>::max();

//! The size of the string is not known, but the string is null terminated.
constexpr size_t kNullTerminated = std::numeric_limits<size_t>::max();

//! Invalid base address.
constexpr uint64_t kNoBaseAddress = ~uint64_t(0);

// ============================================================================
// [asmjit::Globals::ByteOrder]
// ============================================================================

//! Byte order.
enum ByteOrder : uint32_t {
  kByteOrderLE      = 0,
  kByteOrderBE      = 1,
  kByteOrderNative  = ASMJIT_ARCH_LE ? kByteOrderLE : kByteOrderBE,
  kByteOrderSwapped = ASMJIT_ARCH_LE ? kByteOrderBE : kByteOrderLE
};

// ============================================================================
// [asmjit::Globals::ResetPolicy]
// ============================================================================

//! Reset policy used by most `reset()` functions.
enum ResetPolicy : uint32_t {
  //! Soft reset, doesn't deallocate memory (default).
  kResetSoft = 0,
  //! Hard reset, releases all memory used, if any.
  kResetHard = 1
};

// ============================================================================
// [asmjit::Globals::Link]
// ============================================================================

enum Link : uint32_t {
  kLinkLeft  = 0,
  kLinkRight = 1,

  kLinkPrev  = 0,
  kLinkNext  = 1,

  kLinkFirst = 0,
  kLinkLast  = 1,

  kLinkCount = 2
};

struct Init_ {};
struct NoInit_ {};

constexpr Init_ Init {};
constexpr NoInit_ NoInit {};

} // Globals namespace

// ============================================================================
// [asmjit::Error]
// ============================================================================

//! AsmJit error type (uint32_t).
typedef uint32_t Error;

//! AsmJit error codes.
enum ErrorCode : uint32_t {
  //! No error (success).
  kErrorOk = 0,

  //! Heap memory allocation failed.
  kErrorNoHeapMemory,

  //! Virtual memory allocation failed.
  kErrorNoVirtualMemory,

  //! Invalid argument.
  kErrorInvalidArgument,

  //! Invalid state.
  //!
  //! If this error is returned it means that either you are doing something
  //! wrong or AsmJit caught itself by doing something wrong. This error should
  //! never be ignored.
  kErrorInvalidState,

  //! Invalid or incompatible architecture.
  kErrorInvalidArch,

  //! The object is not initialized.
  kErrorNotInitialized,
  //! The object is already initialized.
  kErrorAlreadyInitialized,

  //! Built-in feature was disabled at compile time and it's not available.
  kErrorFeatureNotEnabled,

  //! No code generated.
  //!
  //! Returned by runtime if the `CodeHolder` contains no code.
  kErrorNoCodeGenerated,
  //! Code generated is larger than allowed.
  kErrorCodeTooLarge,

  //! Invalid directive.
  kErrorInvalidDirective,
  //! Attempt to use uninitialized label.
  kErrorInvalidLabel,
  //! Label index overflow - a single `Assembler` instance can hold more than
  //! 2 billion labels (2147483391 to be exact). If there is an attempt to
  //! create more labels this error is returned.
  kErrorLabelIndexOverflow,
  //! Label is already bound.
  kErrorLabelAlreadyBound,
  //! Label is already defined (named labels).
  kErrorLabelAlreadyDefined,
  //! Label name is too long.
  kErrorLabelNameTooLong,
  //! Label must always be local if it's anonymous (without a name).
  kErrorInvalidLabelName,
  //! Parent id passed to `CodeHolder::newNamedLabelId()` was invalid.
  kErrorInvalidParentLabel,
  //! Parent id specified for a non-local (global) label.
  kErrorNonLocalLabelCantHaveParent,

  //! Relocation index overflow.
  kErrorRelocIndexOverflow,
  //! Invalid relocation entry.
  kErrorInvalidRelocEntry,

  //! Invalid instruction.
  kErrorInvalidInstruction,
  //! Invalid register type.
  kErrorInvalidRegType,
  //! Invalid register group.
  kErrorInvalidRegGroup,
  //! Invalid register's physical id.
  kErrorInvalidPhysId,
  //! Invalid register's virtual id.
  kErrorInvalidVirtId,
  //! Invalid prefix combination.
  kErrorInvalidPrefixCombination,
  //! Invalid LOCK prefix.
  kErrorInvalidLockPrefix,
  //! Invalid XACQUIRE prefix.
  kErrorInvalidXAcquirePrefix,
  //! Invalid XRELEASE prefix.
  kErrorInvalidXReleasePrefix,
  //! Invalid REP prefix.
  kErrorInvalidRepPrefix,
  //! Invalid REX prefix.
  kErrorInvalidRexPrefix,
  //! Invalid mask register (not 'k').
  kErrorInvalidKMaskReg,
  //! Invalid {k} use (not supported by the instruction).
  kErrorInvalidKMaskUse,
  //! Invalid {k}{z} use (not supported by the instruction).
  kErrorInvalidKZeroUse,
  //! Invalid broadcast - Currently only related to invalid use of AVX-512 {1tox}.
  kErrorInvalidBroadcast,
  //! Invalid 'embedded-rounding' {er} or 'suppress-all-exceptions' {sae} (AVX-512).
  kErrorInvalidEROrSAE,
  //! Invalid address used (not encodable).
  kErrorInvalidAddress,
  //! Invalid index register used in memory address (not encodable).
  kErrorInvalidAddressIndex,
  //! Invalid address scale (not encodable).
  kErrorInvalidAddressScale,
  //! Invalid use of 64-bit address.
  kErrorInvalidAddress64Bit,
  //! Invalid displacement (not encodable).
  kErrorInvalidDisplacement,
  //! Invalid segment (X86).
  kErrorInvalidSegment,

  //! Invalid immediate (out of bounds on X86 and invalid pattern on ARM).
  kErrorInvalidImmediate,

  //! Invalid operand size.
  kErrorInvalidOperandSize,
  //! Ambiguous operand size (memory has zero size while it's required to determine the operation type.
  kErrorAmbiguousOperandSize,
  //! Mismatching operand size (size of multiple operands doesn't match the operation size).
  kErrorOperandSizeMismatch,

  //! Invalid option.
  kErrorInvalidOption,
  //! Option already defined.
  kErrorOptionAlreadyDefined,

  //! Invalid TypeId.
  kErrorInvalidTypeId,
  //! Invalid use of a 8-bit GPB-HIGH register.
  kErrorInvalidUseOfGpbHi,
  //! Invalid use of a 64-bit GPQ register in 32-bit mode.
  kErrorInvalidUseOfGpq,
  //! Invalid use of an 80-bit float (Type::kIdF80).
  kErrorInvalidUseOfF80,
  //! Some registers in the instruction muse be consecutive (some ARM and AVX512 neural-net instructions).
  kErrorNotConsecutiveRegs,

  //! AsmJit requires a physical register, but no one is available.
  kErrorNoMorePhysRegs,
  //! A variable has been assigned more than once to a function argument (BaseCompiler).
  kErrorOverlappedRegs,
  //! Invalid register to hold stack arguments offset.
  kErrorOverlappingStackRegWithRegArg,

  //! Count of AsmJit error codes.
  kErrorCount
};

// ============================================================================
// [asmjit::PointerCast]
// ============================================================================

namespace AsmJitInternal {
  //! Cast designed to cast between function and void* pointers.
  template<typename Dst, typename Src>
  static inline Dst ptr_cast(Src p) noexcept { return (Dst)p; }
}

template<typename Func>
static inline Func ptr_as_func(void* func) noexcept { return AsmJitInternal::ptr_cast<Func, void*>(func); }
template<typename Func>
static inline void* func_as_ptr(Func func) noexcept { return AsmJitInternal::ptr_cast<void*, Func>(func); }

// ============================================================================
// [asmjit::DebugUtils]
// ============================================================================

namespace DebugUtils {

//! Returns the error `err` passed.
//!
//! Provided for debugging purposes. Putting a breakpoint inside `errored` can
//! help with tracing the origin of any error reported / returned by AsmJit.
static constexpr Error errored(Error err) noexcept { return err; }

//! Get a printable version of `asmjit::Error` code.
ASMJIT_API const char* errorAsString(Error err) noexcept;

//! Called to output debugging message(s).
ASMJIT_API void debugOutput(const char* str) noexcept;

//! Called on assertion failure.
//!
//! \param file Source file name where it happened.
//! \param line Line in the source file.
//! \param msg Message to display.
//!
//! If you have problems with assertions put a breakpoint at assertionFailed()
//! function (asmjit/core/globals.cpp) and check the call stack to locate the
//! failing code.
ASMJIT_API void ASMJIT_NORETURN assertionFailed(const char* file, int line, const char* msg) noexcept;

#if defined(ASMJIT_BUILD_DEBUG)
  #define ASMJIT_ASSERT(EXP)                                           \
    do {                                                               \
      if (ASMJIT_LIKELY(EXP))                                          \
        break;                                                         \
      ::asmjit::DebugUtils::assertionFailed(__FILE__, __LINE__, #EXP); \
    } while (0)
#else
  #define ASMJIT_ASSERT(EXP) ((void)0)
#endif

//! \internal
//!
//! Used by AsmJit to propagate a possible `Error` produced by `...` to the caller.
#define ASMJIT_PROPAGATE(...)               \
  do {                                      \
    ::asmjit::Error _err = __VA_ARGS__;     \
    if (ASMJIT_UNLIKELY(_err))              \
      return _err;                          \
  } while (0)

} // DebugUtils namespace

//! \}

ASMJIT_END_NAMESPACE

// [Guard]
#endif // _ASMJIT_CORE_GLOBALS_H

```

`Avanguard/AsmJit/asmjit/core/inst.h`:

```h
// [AsmJit]
// Complete x86/x64 JIT and Remote Assembler for C++.
//
// [License]
// ZLIB - See LICENSE.md file in the package.

// [Guard]
#ifndef _ASMJIT_CORE_INST_H
#define _ASMJIT_CORE_INST_H

// [Dependencies]
#include "../core/cpuinfo.h"
#include "../core/operand.h"

ASMJIT_BEGIN_NAMESPACE

//! \addtogroup asmjit_core_api
//! \{

// ============================================================================
// [asmjit::OpInfo]
// ============================================================================

//! Operand information.
struct OpInfo {
  //! Operand flags.
  //!
  //! Flags describe how the operand is accessed and some additional information.
  enum Flags : uint32_t {
    kRead                 = 0x00000001u, //!< Operand is Read.
    kWrite                = 0x00000002u, //!< Operand is Written.
    kRW                   = 0x00000003u, //!< Operand is ReadWrite.
    kUse                  = 0x00000004u, //!< Operand is either Read or ReadWrite.
    kOut                  = 0x00000008u  //!< Operand is always WriteOnly (not Read nor ReadWrite).
  };

  // --------------------------------------------------------------------------
  // [Accessors]
  // --------------------------------------------------------------------------

  inline bool hasFlag(uint32_t flag) const noexcept { return (_flags & flag) != 0; }
  inline uint32_t flags() const noexcept { return _flags; }

  inline bool isRead() const noexcept { return hasFlag(kRead); }
  inline bool isWrite() const noexcept { return hasFlag(kWrite); }

  inline bool isReadOnly() const noexcept { return (_flags & kRW) == kRead; }
  inline bool isWriteOnly() const noexcept { return (_flags & kRW) == kWrite; }
  inline bool isReadWrite() const noexcept { return (_flags & kRW) == kRW; }

  inline bool isUse() const noexcept { return hasFlag(kUse); }
  inline bool isOut() const noexcept { return hasFlag(kOut); }

  inline bool hasPhysId() const noexcept { return _physId != BaseReg::kIdBad; }
  inline uint32_t physId() const noexcept { return _physId; }

  // --------------------------------------------------------------------------
  // [Members]
  // --------------------------------------------------------------------------

  uint16_t _flags;                       //!< Operand flags, see `Flags`.
  uint8_t _physId;                       //!< Operand must be in this physical register.
  uint8_t _reserved;                     //!< Reserved for future use.
};

//! Operand Read/Write information, used by `InstRWInfo`.
struct OpRWInfo {
  //! Flags describe how the operand is accessed and some additional information.
  enum Flags : uint32_t {
    kRead               = 0x00000001u, //!< Operand is Read.
    kWrite              = 0x00000002u, //!< Operand is Written.
    kRW                 = 0x00000003u, //!< Operand is ReadWrite.
    kUse                = 0x00000004u, //!< Operand is either Read or ReadWrite.
    kOut                = 0x00000008u, //!< Operand is always WriteOnly (not Read nor ReadWrite).
    kZExt               = 0x00000010u  //!< The output is zero extended to a native register size.
  };

  inline bool hasFlag(uint32_t flag) const noexcept { return (_flags & flag) != 0; }
  inline uint32_t flags() const noexcept { return _flags; }

  inline bool isRead() const noexcept { return hasFlag(kRead); }
  inline bool isWrite() const noexcept { return hasFlag(kWrite); }
  inline bool isReadWrite() const noexcept { return (_flags & kRW) == kRW; }
  inline bool isReadOnly() const noexcept { return (_flags & kRW) == kRead; }
  inline bool isWriteOnly() const noexcept { return (_flags & kRW) == kWrite; }

  inline bool isUse() const noexcept { return hasFlag(kUse); }
  inline bool isOut() const noexcept { return hasFlag(kOut); }

  inline bool hasPhysId() const noexcept { return _physId != BaseReg::kIdBad; }
  inline uint32_t physId() const noexcept { return _physId; }

  inline uint32_t index() const noexcept { return _index; }
  inline uint32_t width() const noexcept { return _width; }

  uint8_t _flags;                      //!< Read/Write flags.
  uint8_t _physId;                     //!< Physical register index, if required.
  uint8_t _index;                      //!< Read/write register index [in bytes], `_index` is ignored if the operand is memory.
  uint8_t _width;                      //!< Read/Write register/memory width [in bytes], zero means native width or imm/rel width.
};

//! Instruction Read/Write information.
struct InstRWInfo {
  uint32_t flags;
  OpRWInfo extraReg;
  OpRWInfo operands[Globals::kMaxOpCount];
};

// ============================================================================
// [asmjit::BaseInst]
// ============================================================================

//! Instruction id, options, and extraReg in a single structure. This structure
//! exists mainly to simplify analysis and validation API that requires `BaseInst`
//! and `Operand[]` array.
class BaseInst {
public:
  enum Id : uint32_t {
    kIdNone               = 0x00000000u, //!< Invalid or uninitialized instruction id.
    kIdAbstract           = 0x80000000u  //!< Abstract instruction (BaseBuilder and BaseCompiler).
  };

  enum Options : uint32_t {
    //! Used internally by emitters for handling errors and rare cases.
    kOptionReserved       = 0x00000001u,

    //! Used only by Assembler to mark that `_op4` and `_op5` are used (internal).
    kOptionOp4Op5Used     = 0x00000002u,

    //! Prevents following a jump during compilation (BaseCompiler).
    kOptionUnfollow       = 0x00000010u,

    //! Overwrite the destination operand(s) (BaseCompiler).
    //!
    //! Hint that is important for register liveness analysis. It tells the
    //! compiler that the destination operand will be overwritten now or by
    //! adjacent instructions. BaseCompiler knows when a register is completely
    //! overwritten by a single instruction, for example you don't have to
    //! mark "movaps" or "pxor x, x", however, if a pair of instructions is
    //! used and the first of them doesn't completely overwrite the content
    //! of the destination, BaseCompiler fails to mark that register as dead.
    //!
    //! X86 Specific
    //! ------------
    //!
    //!   - All instructions that always overwrite at least the size of the
    //!     register the virtual-register uses , for example "mov", "movq",
    //!     "movaps" don't need the overwrite option to be used - conversion,
    //!     shuffle, and other miscellaneous instructions included.
    //!
    //!   - All instructions that clear the destination register if all operands
    //!     are the same, for example "xor x, x", "pcmpeqb x x", etc...
    //!
    //!   - Consecutive instructions that partially overwrite the variable until
    //!     there is no old content require `BaseCompiler::overwrite()` to be used.
    //!     Some examples (not always the best use cases thought):
    //!
    //!     - `movlps xmm0, ?` followed by `movhps xmm0, ?` and vice versa
    //!     - `movlpd xmm0, ?` followed by `movhpd xmm0, ?` and vice versa
    //!     - `mov al, ?` followed by `and ax, 0xFF`
    //!     - `mov al, ?` followed by `mov ah, al`
    //!     - `pinsrq xmm0, ?, 0` followed by `pinsrq xmm0, ?, 1`
    //!
    //!   - If allocated variable is used temporarily for scalar operations. For
    //!     example if you allocate a full vector like `x86::Compiler::newXmm()`
    //!     and then use that vector for scalar operations you should use
    //!     `overwrite()` directive:
    //!
    //!     - `sqrtss x, y` - only LO element of `x` is changed, if you don't
    //!       use HI elements, use `compiler.overwrite().sqrtss(x, y)`.
    kOptionOverwrite      = 0x00000020u,

    kOptionShortForm      = 0x00000040u, //!< Emit short-form of the instruction.
    kOptionLongForm       = 0x00000080u, //!< Emit long-form of the instruction.

    kOptionTaken          = 0x00000100u, //!< Conditional jump is likely to be taken.
    kOptionNotTaken       = 0x00000200u  //!< Conditional jump is unlikely to be taken.
  };

  //! Control type.
  enum ControlType : uint32_t {
    kControlNone          = 0u,          //!< No control type (doesn't jump).
    kControlJump          = 1u,          //!< Unconditional jump.
    kControlBranch        = 2u,          //!< Conditional jump (branch).
    kControlCall          = 3u,          //!< Function call.
    kControlReturn        = 4u           //!< Function return.
  };

  // ------------------------------------------------------------------------
  // [Init / Destroy]
  // ------------------------------------------------------------------------

  inline explicit BaseInst(uint32_t id = 0, uint32_t options = 0) noexcept
    : _id(id),
      _options(options),
      _extraReg() {}

  inline BaseInst(uint32_t id, uint32_t options, const RegOnly& extraReg) noexcept
    : _id(id),
      _options(options),
      _extraReg(extraReg) {}

  inline BaseInst(uint32_t id, uint32_t options, const BaseReg& extraReg) noexcept
    : _id(id),
      _options(options),
      _extraReg { extraReg.signature(), extraReg.id() } {}

  // ------------------------------------------------------------------------
  // [Accessors]
  // ------------------------------------------------------------------------

  inline uint32_t id() const noexcept { return _id; }
  inline void setId(uint32_t id) noexcept { _id = id; }
  inline void resetId() noexcept { _id = 0; }

  inline uint32_t options() const noexcept { return _options; }
  inline void setOptions(uint32_t options) noexcept { _options = options; }
  inline void addOptions(uint32_t options) noexcept { _options |= options; }
  inline void clearOptions(uint32_t options) noexcept { _options &= ~options; }
  inline void resetOptions() noexcept { _options = 0; }

  inline bool hasExtraReg() const noexcept { return _extraReg.isReg(); }
  inline RegOnly& extraReg() noexcept { return _extraReg; }
  inline const RegOnly& extraReg() const noexcept { return _extraReg; }
  inline void setExtraReg(const BaseReg& reg) noexcept { _extraReg.init(reg); }
  inline void setExtraReg(const RegOnly& reg) noexcept { _extraReg.init(reg); }
  inline void resetExtraReg() noexcept { _extraReg.reset(); }

  // --------------------------------------------------------------------------
  // [API]
  // --------------------------------------------------------------------------

  #ifndef ASMJIT_DISABLE_INST_API
  //! Validate the given instruction.
  ASMJIT_API static Error validate(uint32_t archId, const BaseInst& inst, const Operand_* operands, uint32_t count) noexcept;

  //! Get Read/Write information of the given instruction.
  ASMJIT_API static Error queryRWInfo(uint32_t archId, const BaseInst& inst, const Operand_* operands, uint32_t count, InstRWInfo& out) noexcept;

  //! Get CPU features required by the given instruction.
  ASMJIT_API static Error queryFeatures(uint32_t archId, const BaseInst& inst, const Operand_* operands, uint32_t count, BaseFeatures& out) noexcept;
  #endif

  // ------------------------------------------------------------------------
  // [Members]
  // ------------------------------------------------------------------------

  uint32_t _id;
  uint32_t _options;
  RegOnly _extraReg;
};

//! \}

ASMJIT_END_NAMESPACE

// [Guard]
#endif // _ASMJIT_CORE_INST_H

```

`Avanguard/AsmJit/asmjit/core/jitallocator.h`:

```h
// [AsmJit]
// Complete x86/x64 JIT and Remote Assembler for C++.
//
// [License]
// ZLIB - See LICENSE.md file in the package.

// [Guard]
#ifndef _ASMJIT_CORE_JITALLOCATOR_H
#define _ASMJIT_CORE_JITALLOCATOR_H

#include "../core/build.h"
#ifndef ASMJIT_DISABLE_JIT

// [Dependencies]
#include "../core/globals.h"
#include "../core/osutils.h"
#include "../core/zonelist.h"
#include "../core/zonetree.h"

ASMJIT_BEGIN_NAMESPACE

//! \addtogroup asmjit_core_jit
//! \{

// ============================================================================
// [asmjit::JitAllocator]
// ============================================================================

//! A simple implementation of memory manager that uses `JitUtils::virtualAlloc()`
//! and `JitUtils::virtualRelease()` to manage executable memory.
//!
//! Implementation notes:
//!
//! - Granularity of allocated blocks is different than granularity for a typical
//!   C malloc. There are several memory pools having a different granularity to
//!   make as little waste as possible.
//!
//! - The allocator doesn't store any information in executable memory, instead,
//!   the implementation uses two bit-vectors to manage allocated memory of each
//!   block. The first bit-vector called 'used' is used to track used memory
//!   (where each bit represents memory size defined by granularity) and the second
//!   bit vector called 'stop' is used as a sentinel to mark where the allocated
//!   area ends.
//!
//! - Internally, the allocator also uses RB tree to keep track of all blocks
//!   across all polls. Each inserted block is added to the tree so it can be
//!   queried fast during `release()` and `shrink()`.
class JitAllocator {
public:
  ASMJIT_NONCOPYABLE(JitAllocator)

  enum Limits : uint32_t {
    //! Number of pools that contain blocks.
    //!
    //! Each pool increases granularity twice to make memory management more
    //! efficient. Ideal number of pools appears to be 3 to 4 as it distributes
    //! small and large functions properly.
    kPoolCount = 3,

    //! Minimum granularity (and the default granularity for pool #0).
    kMinGranularity = 64,

    //! Minimum block size (64kB).
    kMinBlockSize = 1024 * 64,

    //! Maximum block size (1MB).
    kMaxBlockSize = 1024 * 1024
  };

  enum Flags : uint32_t {
    //! Always mark unused memory by fill-pattern.
    kFlagSecureMode = 0x80000000u
  };

  class Block;

  class Pool {
  public:
    ASMJIT_NONCOPYABLE(Pool)

    inline Pool() noexcept
      : _blocks(),
        _cursor(nullptr),
        _blockCount(0),
        _granularity(0),
        _granularityLog2(0),
        _reserved(0),
        _totalAreaSize(0),
        _totalAreaUsed(0),
        _totalOverheadBytes(0) {}

    inline void reset() noexcept {
      _blocks.reset();
      _cursor = nullptr;
      _blockCount = 0;
      _totalAreaSize = 0;
      _totalAreaUsed = 0;
      _totalOverheadBytes = 0;
    }

    inline uint32_t granularity() const noexcept { return _granularity; }
    inline void setGranularity(uint32_t granularity) noexcept {
      ASMJIT_ASSERT(granularity < 65536u);
      _granularity = uint16_t(granularity);
      _granularityLog2 = uint8_t(Support::ctz(granularity));
    }

    inline size_t byteSizeFromAreaSize(uint32_t areaSize) const noexcept { return size_t(areaSize) * _granularity; }
    inline uint32_t areaSizeFromByteSize(size_t size) const noexcept { return uint32_t((size + _granularity - 1) >> _granularityLog2); }

    inline size_t bitWordCountFromAreaSize(uint32_t areaSize) const noexcept {
      using Support::kBitWordSizeInBits;
      return Support::alignUp<size_t>(areaSize, kBitWordSizeInBits) / kBitWordSizeInBits;
    }

    ZoneList<Block> _blocks;             //!< Double linked list of blocks.
    Block* _cursor;                      //!< Where to start looking first.

    uint32_t _blockCount;                //!< Count of blocks.
    uint16_t _granularity;               //!< Allocation granularity.
    uint8_t _granularityLog2;            //!< Log2(_granularity).
    uint8_t _reserved;

    size_t _totalAreaSize;               //!< Number of bits reserved across all blocks.
    size_t _totalAreaUsed;               //!< Number of bits used across all blocks.
    size_t _totalOverheadBytes;          //!< Overhead of all blocks (in bytes).
  };

  class Block : public ZoneTreeNodeT<Block>,
                public ZoneListNode<Block> {
  public:
    ASMJIT_NONCOPYABLE(Block)

    enum Flags {
      kFlagDirty           = 0x80000000u //!< Block is dirty (some members needs update).
    };

    inline Block(Pool* pool,
                 uint8_t* virtMem,
                 size_t blockSize,
                 Support::BitWord* usedBitVector,
                 Support::BitWord* stopBitVector,
                 uint32_t areaSize) noexcept
      : ZoneTreeNodeT(),
        _pool(pool),
        _virtMem(virtMem),
        _blockSize(blockSize),
        _flags(0),
        _areaSize(areaSize),
        _areaUsed(0),
        _largestUnusedArea(areaSize),
        _searchStart(0),
        _searchEnd(areaSize),
        _usedBitVector(usedBitVector),
        _stopBitVector(stopBitVector) {}

    inline Pool* pool() const noexcept { return _pool; }

    inline uint8_t* virtMem() const noexcept { return _virtMem; }
    inline size_t blockSize() const noexcept { return _blockSize; }

    inline uint32_t flags() const noexcept { return _flags; }
    inline bool hasFlag(uint32_t flag) const noexcept { return (_flags & flag) != 0; }
    inline void addFlags(uint32_t flags) noexcept { _flags |= flags; }
    inline void clearFlags(uint32_t flags) noexcept { _flags &= ~flags; }

    inline uint32_t areaSize() const noexcept { return _areaSize; }
    inline uint32_t areaUsed() const noexcept { return _areaUsed; }

    inline uint32_t areaAvailable() const noexcept { return areaSize() - areaUsed(); }
    inline uint32_t largestUnusedArea() const noexcept { return _largestUnusedArea; }

    inline void increaseUsedArea(uint32_t areaSize) noexcept {
      _areaUsed += areaSize;
      _pool->_totalAreaUsed += areaSize;
    }

    inline void decreaseUsedArea(uint32_t areaSize) noexcept {
      _areaUsed -= areaSize;
      _pool->_totalAreaUsed -= areaSize;
    }

    // RBTree default CMP uses '<' and '>' operators.
    inline bool operator<(const Block& other) const noexcept { return virtMem() < other.virtMem(); }
    inline bool operator>(const Block& other) const noexcept { return virtMem() > other.virtMem(); }

    // Special implementation for querying blocks by `key`, which must be in `[virtMem, virtMem + blockSize)` range.
    inline bool operator<(const uint8_t* key) const noexcept { return virtMem() + blockSize() <= key; }
    inline bool operator>(const uint8_t* key) const noexcept { return virtMem() > key; }

    Pool* _pool;                         //!< Link to the pool that owns this block.
    uint8_t* _virtMem;                   //!< Virtual memory address.
    size_t _blockSize;                   //!< Virtual memory size (block size) [bytes].

    uint32_t _flags;                     //!< Block flags.
    uint32_t _areaSize;                  //!< Size of the whole block area (bit-vector size).
    uint32_t _areaUsed;                  //!< Used area (number of bits in bit-vector used).
    uint32_t _largestUnusedArea;         //!< The largest unused continuous area in the bit-vector (or `_areaSize` to initiate rescan).
    uint32_t _searchStart;               //!< Start of a search range (for unused bits).
    uint32_t _searchEnd;                 //!< End of a search range (for unused bits).

    Support::BitWord* _usedBitVector;   //!< Used bit-vector (0 = unused    , 1 = used).
    Support::BitWord* _stopBitVector;   //!< Stop bit-vector (0 = don't care, 1 = stop).
  };

  struct Statistics {
    inline void reset() noexcept {
      _blockCount = 0;
      _usedSize = 0;
      _reservedSize = 0;
      _overheadSize = 0;
    }

    //! Get count of blocks managed by `JitAllocator`.
    inline size_t blockCount() const noexcept { return _blockCount; }

    //! Get how many bytes are currently used.
    inline size_t usedSize() const noexcept { return _usedSize; }
    //! Number of bytes unused by the allocator at the moment.
    inline size_t unusedSize() const noexcept { return _reservedSize - _usedSize; }
    //! Total number of bytes bytes reserved by the allocator (sum of sizes of all blocks).
    inline size_t reservedSize() const noexcept { return _reservedSize; }
    //! Number of bytes the allocator needs to manage the allocated memory.
    inline size_t overheadSize() const noexcept { return _overheadSize; }

    inline double usedSizeAsPercent() const noexcept {
      return (double(usedSize()) / (double(reservedSize()) + 1e-16)) * 100.0;
    }

    inline double unusedSizeAsPercent() const noexcept {
      return (double(unusedSize()) / (double(reservedSize()) + 1e-16)) * 100.0;
    }

    inline double overheadSizeAsPercent() const noexcept {
      return (double(overheadSize()) / (double(reservedSize()) + 1e-16)) * 100.0;
    }

    size_t _blockCount;                  //!< Number of blocks `JitAllocator` maintains.
    size_t _usedSize;                    //!< How many bytes are currently used / allocated.
    size_t _reservedSize;                //!< How many bytes are currently reserved by the allocator.
    size_t _overheadSize;                //!< Allocation overhead (in bytes) required to maintain all blocks.
  };

  // --------------------------------------------------------------------------
  // [Construction / Destruction]
  // --------------------------------------------------------------------------

  //! Create a `JitAllocator` instance.
  ASMJIT_API JitAllocator() noexcept;
  //! Destroy the `JitAllocator` instance and release all blocks held.
  ASMJIT_API ~JitAllocator() noexcept;

  // --------------------------------------------------------------------------
  // [Reset]
  // --------------------------------------------------------------------------

  //! Free all allocated memory - makes all pointers returned by `alloc()` invalid.
  ASMJIT_API void reset() noexcept;

  // --------------------------------------------------------------------------
  // [Accessors]
  // --------------------------------------------------------------------------

  //! Get allocation flags, see `Flags`.
  inline uint32_t flags() const noexcept { return _flags; }
  //! Get whether the allocator has the given `flag` set.
  inline bool hasFlag(uint32_t flag) const noexcept { return (_flags & flag) != 0; }

  //! Get a page size (smallest possible allocable chunk of virtual memory).
  inline uint32_t pageSize() const noexcept { return _pageSize; }
  //! Get a minimum block size (a minimum size of block that the allocator would allocate).
  inline uint32_t blockSize() const noexcept { return _blockSize; }

  //! Get a pattern that is used to fill unused memory if `kFlagSecureMode` is enabled.
  inline uint32_t fillPattern() const noexcept { return _fillPattern; }

  //! Get allocation statistics.
  ASMJIT_API Statistics statistics() const noexcept;

  // --------------------------------------------------------------------------
  // [Alloc / Release]
  // --------------------------------------------------------------------------

  //! Allocate `size` bytes of virtual memory.
  ASMJIT_API void* alloc(size_t size) noexcept;
  //! Release a memory returned by `alloc()`.
  ASMJIT_API Error release(void* p) noexcept;
  //! Free extra memory allocated with `p` by restricting it to `newSize` size.
  ASMJIT_API Error shrink(void* p, size_t newSize) noexcept;

  // --------------------------------------------------------------------------
  // [Members]
  // --------------------------------------------------------------------------

  uint32_t _flags;                       //!< Allocator flags, see `Flags`.
  uint32_t _pageSize;                    //!< System page size (also a minimum block size).
  uint32_t _blockSize;                   //!< Default block size.
  uint32_t _fillPattern;                 //!< A pattern that is used to fill unused memory if secure mode is enabled.

  mutable Lock _lock;                    //!< Lock for thread safety.
  ZoneTree<Block> _tree;                 //!< Blocks from all pools in RBTree.
  Pool _pools[kPoolCount];               //!< Allocator pools.
};

//! \}

ASMJIT_END_NAMESPACE

#endif
#endif

```

`Avanguard/AsmJit/asmjit/core/jitruntime.h`:

```h
// [AsmJit]
// Complete x86/x64 JIT and Remote Assembler for C++.
//
// [License]
// ZLIB - See LICENSE.md file in the package.

// [Guard]
#ifndef _ASMJIT_CORE_JITRUNTIME_H
#define _ASMJIT_CORE_JITRUNTIME_H

#include "../core/build.h"
#ifndef ASMJIT_DISABLE_JIT

#include "../core/codeholder.h"
#include "../core/jitallocator.h"
#include "../core/target.h"

ASMJIT_BEGIN_NAMESPACE

class CodeHolder;

//! \addtogroup asmjit_core_jit
//! \{

// ============================================================================
// [asmjit::JitRuntime]
// ============================================================================

//! JIT execution runtime is a special `Target` that is designed to store and
//! execute the generated code.
class ASMJIT_VIRTAPI JitRuntime : public Target {
public:
  ASMJIT_NONCOPYABLE(JitRuntime)

  // --------------------------------------------------------------------------
  // [Construction / Destruction]
  // --------------------------------------------------------------------------

  //! Create a `JitRuntime` instance.
  ASMJIT_API JitRuntime() noexcept;
  //! Destroy the `JitRuntime` instance.
  ASMJIT_API virtual ~JitRuntime() noexcept;

  // --------------------------------------------------------------------------
  // [Accessors]
  // --------------------------------------------------------------------------

  //! Get `JitAllocator` of the runtime.
  inline JitAllocator* allocator() const noexcept { return const_cast<JitAllocator*>(&_allocator); }

  // --------------------------------------------------------------------------
  // [Add / Release]
  // --------------------------------------------------------------------------

  // NOTE: To allow passing function pointers to `add()` and `release()` the
  // virtual methods are prefixed with `_` and called from templates instead.

  //! Allocate a memory needed for a code stored in the `CodeHolder` and
  //! relocate it to the target location.
  //!
  //! The beginning of the memory allocated for the function is returned in
  //! `dst`. If failed the `Error` code is returned and `dst` is set to null
  //! (this means that you don't have to set it to null before calling `add()`).
  template<typename Func>
  inline Error add(Func* dst, CodeHolder* code) noexcept {
    return _add(AsmJitInternal::ptr_cast<void**, Func*>(dst), code);
  }

  //! Release `p` which was obtained by calling `add()`.
  template<typename Func>
  inline Error release(Func p) noexcept {
    return _release(AsmJitInternal::ptr_cast<void*, Func>(p));
  }

  //! Type-unsafe version of `add()`.
  ASMJIT_API virtual Error _add(void** dst, CodeHolder* code) noexcept;

  //! Type-unsafe version of `release()`.
  ASMJIT_API virtual Error _release(void* p) noexcept;

  //! Flush an instruction cache.
  //!
  //! This member function is called after the code has been copied to the
  //! destination buffer. It is only useful for JIT code generation as it
  //! causes a flush of the processor's cache.
  //!
  //! Flushing is basically a NOP under X86, but is needed by architectures
  //! that do not have a transparent instruction cache like ARM.
  //!
  //! This function can also be overridden to improve compatibility with tools
  //! such as Valgrind, however, it's not an official part of AsmJit.
  ASMJIT_API virtual void flush(const void* p, size_t size) noexcept;

  // --------------------------------------------------------------------------
  // [Members]
  // --------------------------------------------------------------------------

  //! Virtual memory allocator.
  JitAllocator _allocator;
};

//! \}

ASMJIT_END_NAMESPACE

#endif
#endif

```

`Avanguard/AsmJit/asmjit/core/jitutils.h`:

```h
// [AsmJit]
// Complete x86/x64 JIT and Remote Assembler for C++.
//
// [License]
// ZLIB - See LICENSE.md file in the package.

// [Guard]
#ifndef _ASMJIT_CORE_JITUTILS_H
#define _ASMJIT_CORE_JITUTILS_H

#include "../core/build.h"
#ifndef ASMJIT_DISABLE_JIT

// [Dependencies]
#include "../core/globals.h"

ASMJIT_BEGIN_NAMESPACE

//! \addtogroup asmjit_core_jit
//! \{

// ============================================================================
// [asmjit::JitUtils]
// ============================================================================

//! JIT utilities that provide virtual memory allocation.
namespace JitUtils {

//! Memory access flags.
enum VirtMemFlags : uint32_t {
  kVirtMemNoFlags         = 0x00000000u, //!< No access flags.
  kVirtMemWrite           = 0x00000001u, //!< Memory is writable.
  kVirtMemExecute         = 0x00000002u, //!< Memory is executable.

  kVirtMemWriteExecute    = kVirtMemWrite |
                            kVirtMemExecute
};

//! Virtual memory information.
struct MemInfo {
  uint32_t pageSize;                     //!< Virtual memory page size.
  uint32_t pageGranularity;              //!< Virtual memory page granularity.
};

//! Get virtual memory information, see `JitUtils::MemInfo` for more details.
ASMJIT_API MemInfo memInfo() noexcept;

//! Allocate virtual memory.
//!
//! NOTE: `size` should be aligned to page size, use `memInfo()` to obtain it.
ASMJIT_API void* virtualAlloc(size_t size, uint32_t vmFlags) noexcept;

//! Release virtual memory previously allocated by `JitUtils::virtualAlloc()`.
ASMJIT_API Error virtualRelease(void* p, size_t size) noexcept;

} // JitUtils

//! \}

ASMJIT_END_NAMESPACE

#endif
#endif

```

`Avanguard/AsmJit/asmjit/core/logging.h`:

```h
// [AsmJit]
// Complete x86/x64 JIT and Remote Assembler for C++.
//
// [License]
// ZLIB - See LICENSE.md file in the package.

// [Guard]
#ifndef _ASMJIT_CORE_LOGGING_H
#define _ASMJIT_CORE_LOGGING_H

// [Dependencies]
#include "../core/inst.h"
#include "../core/stringbuilder.h"

ASMJIT_BEGIN_NAMESPACE

//! \addtogroup asmjit_core_api
//! \{

#ifndef ASMJIT_DISABLE_LOGGING

// ============================================================================
// [Forward Declarations]
// ============================================================================

class BaseEmitter;
class BaseReg;
class Logger;
struct Operand_;

#ifndef ASMJIT_DISABLE_BUILDER
class BaseBuilder;
class BaseNode;
#endif

// ============================================================================
// [asmjit::FormatOptions]
// ============================================================================

class FormatOptions {
public:
  enum Flags : uint32_t {
    kFlagMachineCode      = 0x00000001u, //!< Show also binary form of each logged instruction (assembler).
    kFlagExplainImms      = 0x00000002u, //!< Show a text explanation of some immediate values.
    kFlagHexImms          = 0x00000004u, //!< Use hexadecimal notation of immediate values.
    kFlagHexOffsets       = 0x00000008u, //!< Use hexadecimal notation of address offsets.
    kFlagRegCasts         = 0x00000010u, //!< Show casts between virtual register types (compiler).
    kFlagPositions        = 0x00000020u, //!< Show positions associated with nodes (compiler).
    kFlagAnnotations      = 0x00000040u, //!< Annotate nodes that are lowered by passes.
    // TODO: These must go, keep this only for formatting.
    kFlagDebugPasses      = 0x00000080u, //!< Show an additional output from passes.
    kFlagDebugRA          = 0x00000100u  //!< Show an additional output from RA.
  };

  enum IndentationType : uint32_t {
    kIndentationCode      = 0u,          //!< Indentation used for instructions and directives.
    kIndentationLabel     = 1u,          //!< Indentation used for labels and function nodes.
    kIndentationComment   = 2u,          //!< Indentation used for comments (not inline comments).
    kIndentationReserved  = 3u
  };

  // --------------------------------------------------------------------------
  // [Construction / Destruction]
  // --------------------------------------------------------------------------

  constexpr FormatOptions() noexcept
    : _flags(0),
      _indentation { 0, 0, 0, 0 } {}

  constexpr FormatOptions(const FormatOptions& other) noexcept = default;
  inline FormatOptions& operator=(const FormatOptions& other) noexcept = default;

  // --------------------------------------------------------------------------
  // [Reset]
  // --------------------------------------------------------------------------

  inline void reset() noexcept {
    _flags = 0;
    _indentation[0] = 0;
    _indentation[1] = 0;
    _indentation[2] = 0;
    _indentation[3] = 0;
  }

  // --------------------------------------------------------------------------
  // [Accessors]
  // --------------------------------------------------------------------------

  constexpr uint32_t flags() const noexcept { return _flags; }
  constexpr bool hasFlag(uint32_t flag) const noexcept { return (_flags & flag) != 0; }
  inline void setFlags(uint32_t flags) noexcept { _flags = flags; }
  inline void addFlags(uint32_t flags) noexcept { _flags |= flags; }
  inline void clearFlags(uint32_t flags) noexcept { _flags &= ~flags; }

  constexpr uint8_t indentation(uint32_t type) const noexcept { return _indentation[type]; }
  inline void setIndentation(uint32_t type, uint32_t n) noexcept { _indentation[type] = uint8_t(n); }
  inline void resetIndentation(uint32_t type) noexcept { _indentation[type] = uint8_t(0); }

  // --------------------------------------------------------------------------
  // [Members]
  // --------------------------------------------------------------------------

  uint32_t _flags;
  uint8_t _indentation[4];
};

// ============================================================================
// [asmjit::Logger]
// ============================================================================

//! Abstract logging interface and helpers.
//!
//! This class can be inherited and reimplemented to fit into your logging
//! subsystem. When reimplementing use `Logger::_log()` method to log into
//! a custom stream.
//!
//! There are two `Logger` implementations offered by AsmJit:
//!   - `FileLogger` - allows to log into `std::FILE*`.
//!   - `StringLogger` - logs into a `StringBuilder`.
class ASMJIT_VIRTAPI Logger {
public:
  ASMJIT_NONCOPYABLE(Logger)

  // --------------------------------------------------------------------------
  // [Construction / Destruction]
  // --------------------------------------------------------------------------

  //! Create a `Logger` instance.
  ASMJIT_API Logger() noexcept;
  //! Destroy the `Logger` instance.
  ASMJIT_API virtual ~Logger() noexcept;

  // --------------------------------------------------------------------------
  // [Logging]
  // --------------------------------------------------------------------------

  //! Log `str` - must be reimplemented.
  virtual Error _log(const char* data, size_t size) noexcept = 0;

  //! Log a string `str`, which is either null terminated or having size `size`.
  inline Error log(const char* data, size_t size = Globals::kNullTerminated) noexcept { return _log(data, size); }
  //! Log a content of a `StringBuilder` `str`.
  inline Error log(const StringBuilder& str) noexcept { return _log(str.data(), str.size()); }

  //! Format the message by using `std::snprintf()` and then send to `log()`.
  ASMJIT_API Error logf(const char* fmt, ...) noexcept;
  //! Format the message by using `std::vsnprintf()` and then send to `log()`.
  ASMJIT_API Error logv(const char* fmt, std::va_list ap) noexcept;
  //! Log binary data.
  ASMJIT_API Error logBinary(const void* data, size_t size) noexcept;

  // --------------------------------------------------------------------------
  // [Options]
  // --------------------------------------------------------------------------

  inline FormatOptions& options() noexcept { return _options; }
  inline const FormatOptions& options() const noexcept { return _options; }

  inline uint32_t flags() const noexcept { return _options.flags(); }
  inline bool hasFlag(uint32_t flag) const noexcept { return _options.hasFlag(flag); }
  inline void setFlags(uint32_t flags) noexcept { _options.setFlags(flags); }
  inline void addFlags(uint32_t flags) noexcept { _options.addFlags(flags); }
  inline void clearFlags(uint32_t flags) noexcept { _options.clearFlags(flags); }

  inline uint32_t indentation(uint32_t type) const noexcept { return _options.indentation(type); }
  inline void setIndentation(uint32_t type, uint32_t n) noexcept { _options.setIndentation(type, n); }
  inline void resetIndentation(uint32_t type) noexcept { _options.resetIndentation(type); }

  // --------------------------------------------------------------------------
  // [Members]
  // --------------------------------------------------------------------------

  //! Log options.
  FormatOptions _options;
};

// ============================================================================
// [asmjit::FileLogger]
// ============================================================================

//! Logger that can log to a `std::FILE*`.
class ASMJIT_VIRTAPI FileLogger : public Logger {
public:
  ASMJIT_NONCOPYABLE(FileLogger)

  // --------------------------------------------------------------------------
  // [Construction / Destruction]
  // --------------------------------------------------------------------------

  //! Create a new `FileLogger` that logs to `std::FILE*`.
  ASMJIT_API FileLogger(std::FILE* file = nullptr) noexcept;
  //! Destroy the `FileLogger`.
  ASMJIT_API virtual ~FileLogger() noexcept;

  // --------------------------------------------------------------------------
  // [Accessors]
  // --------------------------------------------------------------------------

  //! Get the logging output stream or null if the logger has no output stream.
  inline std::FILE* file() const noexcept { return _file; }

  //! Set the logging output stream to `stream` or null.
  //!
  //! NOTE: If the `file` is null the logging will be disabled. When a logger
  //! is attached to `CodeHolder` or any emitter the logging API will always
  //! be called regardless of the output file. This means that if you really
  //! want to disable logging at emitter level you must not attach a logger
  //! to it.
  inline void setFile(std::FILE* file) noexcept { _file = file; }

  // --------------------------------------------------------------------------
  // [Logging]
  // --------------------------------------------------------------------------

  ASMJIT_API Error _log(const char* data, size_t size = Globals::kNullTerminated) noexcept override;

  // --------------------------------------------------------------------------
  // [Members]
  // --------------------------------------------------------------------------

  std::FILE* _file;
};

// ============================================================================
// [asmjit::StringLogger]
// ============================================================================

//! Logger that stores everything in an internal string buffer.
class ASMJIT_VIRTAPI StringLogger : public Logger {
public:
  ASMJIT_NONCOPYABLE(StringLogger)

  // --------------------------------------------------------------------------
  // [Construction / Destruction]
  // --------------------------------------------------------------------------

  //! Create new `StringLogger`.
  ASMJIT_API StringLogger() noexcept;
  //! Destroy the `StringLogger`.
  ASMJIT_API virtual ~StringLogger() noexcept;

  // --------------------------------------------------------------------------
  // [Accessors]
  // --------------------------------------------------------------------------

  //! Get `char*` pointer which represents string buffer.
  //!
  //! The pointer is owned by `StringLogger`, it can't be modified or freed.
  inline const char* data() const noexcept { return _content.data(); }
  //! Get the size of the string returned by `data()`.
  inline size_t size() const noexcept { return _content.size(); }

  //! Clear the internal buffer.
  inline void clear() noexcept { _content.clear(); }

  // --------------------------------------------------------------------------
  // [Logging]
  // --------------------------------------------------------------------------

  ASMJIT_API Error _log(const char* data, size_t size = Globals::kNullTerminated) noexcept override;

  // --------------------------------------------------------------------------
  // [Members]
  // --------------------------------------------------------------------------

  //! Output string.
  StringBuilder _content;
};

// ============================================================================
// [asmjit::Logging]
// ============================================================================

struct Logging {
  ASMJIT_API static Error formatRegister(
    StringBuilder& sb,
    uint32_t flags,
    const BaseEmitter* emitter,
    uint32_t archId,
    uint32_t regType,
    uint32_t regId) noexcept;

  ASMJIT_API static Error formatLabel(
    StringBuilder& sb,
    uint32_t flags,
    const BaseEmitter* emitter,
    uint32_t labelId) noexcept;

  ASMJIT_API static Error formatOperand(
    StringBuilder& sb,
    uint32_t flags,
    const BaseEmitter* emitter,
    uint32_t archId,
    const Operand_& op) noexcept;

  ASMJIT_API static Error formatInstruction(
    StringBuilder& sb,
    uint32_t flags,
    const BaseEmitter* emitter,
    uint32_t archId,
    const BaseInst& inst, const Operand_* operands, uint32_t count) noexcept;

  ASMJIT_API static Error formatTypeId(
    StringBuilder& sb,
    uint32_t typeId) noexcept;

  #ifndef ASMJIT_DISABLE_BUILDER
  ASMJIT_API static Error formatNode(
    StringBuilder& sb,
    uint32_t flags,
    const BaseBuilder* cb,
    const BaseNode* node_) noexcept;
  #endif

  // Only used by AsmJit internals, not available to users.
  #if defined(ASMJIT_EXPORTS)
  enum {
    // Has to be big to be able to hold all metadata compiler can assign to a
    // single instruction.
    kMaxInstLineSize = 44,
    kMaxBinarySize = 26
  };

  static Error formatLine(
    StringBuilder& sb,
    const uint8_t* binData, size_t binSize, size_t dispSize, size_t immSize, const char* comment) noexcept;
  #endif
};
#endif

//! \}

ASMJIT_END_NAMESPACE

// [Guard]
#endif // _ASMJIT_CORE_LOGGER_H

```

`Avanguard/AsmJit/asmjit/core/memmgr.h`:

```h
// [AsmJit]
// Complete x86/x64 JIT and Remote Assembler for C++.
//
// [License]
// ZLIB - See LICENSE.md file in the package.

// [Guard]
#ifndef _ASMJIT_CORE_MEMMGR_H
#define _ASMJIT_CORE_MEMMGR_H

// [Dependencies]
#include "../core/support.h"

ASMJIT_BEGIN_NAMESPACE

//! \addtogroup asmjit_core_support
//! \{

//! Memory management.
namespace MemMgr {

// ============================================================================
// [asmjit::MemMgr - Alloc / Release]
// ============================================================================

#if defined(ASMJIT_CUSTOM_ALLOC)   && \
    defined(ASMJIT_CUSTOM_REALLOC) && \
    defined(ASMJIT_CUSTOM_FREE)

static inline void* alloc(size_t size) noexcept { return ASMJIT_CUSTOM_ALLOC(size); }
static inline void* realloc(void* p, size_t size) noexcept { return ASMJIT_CUSTOM_REALLOC(p, size); }
static inline void release(void* p) noexcept { ASMJIT_CUSTOM_FREE(p); }

#elif !defined(ASMJIT_CUSTOM_ALLOC)   && \
      !defined(ASMJIT_CUSTOM_REALLOC) && \
      !defined(ASMJIT_CUSTOM_FREE)

static inline void* alloc(size_t size) noexcept { return std::malloc(size); }
static inline void* realloc(void* p, size_t size) noexcept { return std::realloc(p, size); }
static inline void release(void* p) noexcept { std::free(p); }

#else
#error "[asmjit] You must provide either none or all of ASMJIT_CUSTOM_[ALLOC|REALLOC|FREE]"
#endif

} // MemMgr namespace

//! \}

ASMJIT_END_NAMESPACE

// [Guard]
#endif // _ASMJIT_CORE_MEMMGR_H

```

`Avanguard/AsmJit/asmjit/core/misc_p.h`:

```h
// [AsmJit]
// Complete x86/x64 JIT and Remote Assembler for C++.
//
// [License]
// ZLIB - See LICENSE.md file in the package.

// [Guard]
#ifndef _ASMJIT_CORE_MISC_P_H
#define _ASMJIT_CORE_MISC_P_H

// [Dependencies]
#include "../core/build.h"

ASMJIT_BEGIN_NAMESPACE

//! \internal
//! \addtogroup asmjit_core_support
//! \{

#define ASMJIT_LOOKUP_TABLE_8(T, I) T((I)), T((I+1)), T((I+2)), T((I+3)), T((I+4)), T((I+5)), T((I+6)), T((I+7))
#define ASMJIT_LOOKUP_TABLE_16(T, I) ASMJIT_LOOKUP_TABLE_8(T, I), ASMJIT_LOOKUP_TABLE_8(T, I + 8)
#define ASMJIT_LOOKUP_TABLE_32(T, I) ASMJIT_LOOKUP_TABLE_16(T, I), ASMJIT_LOOKUP_TABLE_16(T, I + 16)
#define ASMJIT_LOOKUP_TABLE_64(T, I) ASMJIT_LOOKUP_TABLE_32(T, I), ASMJIT_LOOKUP_TABLE_32(T, I + 32)
#define ASMJIT_LOOKUP_TABLE_128(T, I) ASMJIT_LOOKUP_TABLE_64(T, I), ASMJIT_LOOKUP_TABLE_64(T, I + 64)
#define ASMJIT_LOOKUP_TABLE_256(T, I) ASMJIT_LOOKUP_TABLE_128(T, I), ASMJIT_LOOKUP_TABLE_128(T, I + 128)
#define ASMJIT_LOOKUP_TABLE_512(T, I) ASMJIT_LOOKUP_TABLE_256(T, I), ASMJIT_LOOKUP_TABLE_256(T, I + 256)
#define ASMJIT_LOOKUP_TABLE_1024(T, I) ASMJIT_LOOKUP_TABLE_512(T, I), ASMJIT_LOOKUP_TABLE_512(T, I + 512)

//! \}

ASMJIT_END_NAMESPACE

// [Guard]
#endif // _ASMJIT_CORE_MISC_P_H

```

`Avanguard/AsmJit/asmjit/core/operand.h`:

```h
// [AsmJit]
// Complete x86/x64 JIT and Remote Assembler for C++.
//
// [License]
// ZLIB - See LICENSE.md file in the package.

// [Guard]
#ifndef _ASMJIT_CORE_OPERAND_H
#define _ASMJIT_CORE_OPERAND_H

// [Dependencies]
#include "../core/support.h"

ASMJIT_BEGIN_NAMESPACE

//! \addtogroup asmjit_core_api
//! \{

// ============================================================================
// [asmjit::Operand_]
// ============================================================================

//! Constructor-less `Operand`.
//!
//! Contains no initialization code and can be used safely to define an array
//! of operands that won't be initialized. This is an `Operand` compatible
//! data structure designed to be statically initialized, static const, or to
//! be used by the user to define an array of operands without having them
//! default initialized.
//!
//! The key difference between `Operand` and `Operand_`:
//!
//! ```
//! Operand_ xArray[10]; // Not initialized, contains garbage.
//! Operand  yArray[10]; // All operands initialized to none.
//! ```
struct Operand_ {
  // --------------------------------------------------------------------------
  // [Operand Type]
  // --------------------------------------------------------------------------

  //! Operand types that can be encoded in `Operand`.
  enum OpType : uint32_t {
    kOpNone  = 0,                        //!< Not an operand or not initialized.
    kOpReg   = 1,                        //!< Operand is a register.
    kOpMem   = 2,                        //!< Operand is a memory.
    kOpImm   = 3,                        //!< Operand is an immediate value.
    kOpLabel = 4                         //!< Operand is a label.
  };
  static_assert(kOpMem == kOpReg + 1, "asmjit::Operand requires `kOpMem` to be `kOpReg+1`.");

  // --------------------------------------------------------------------------
  // [Operand Signature (Bits)]
  // --------------------------------------------------------------------------

  enum SignatureBits : uint32_t {
    // Operand type (3 least significant bits).
    // |........|........|........|.....XXX|
    kSignatureOpShift           = 0,
    kSignatureOpBits            = 0x07u,
    kSignatureOpMask            = kSignatureOpBits << kSignatureOpShift,

    // Register type (5 bits).
    // |........|........|........|XXXXX...|
    kSignatureRegTypeShift      = 3,
    kSignatureRegTypeBits       = 0x1Fu,
    kSignatureRegTypeMask       = kSignatureRegTypeBits << kSignatureRegTypeShift,

    // Register group (4 bits).
    // |........|........|....XXXX|........|
    kSignatureRegGroupShift     = 8,
    kSignatureRegGroupBits      = 0x0Fu,
    kSignatureRegGroupMask      = kSignatureRegGroupBits << kSignatureRegGroupShift,

    // Memory base type (5 bits).
    // |........|........|........|XXXXX...|
    kSignatureMemBaseTypeShift  = 3,
    kSignatureMemBaseTypeBits   = 0x1Fu,
    kSignatureMemBaseTypeMask   = kSignatureMemBaseTypeBits << kSignatureMemBaseTypeShift,

    // Memory index type (5 bits).
    // |........|........|...XXXXX|........|
    kSignatureMemIndexTypeShift = 8,
    kSignatureMemIndexTypeBits  = 0x1Fu,
    kSignatureMemIndexTypeMask  = kSignatureMemIndexTypeBits << kSignatureMemIndexTypeShift,

    // Memory base+index combined (10 bits).
    // |........|........|...XXXXX|XXXXX...|
    kSignatureMemBaseIndexShift = 3,
    kSignatureMemBaseIndexBits  = 0x3FFu,
    kSignatureMemBaseIndexMask  = kSignatureMemBaseIndexBits << kSignatureMemBaseIndexShift,

    // Memory address type (2 bits).
    // |........|........|.XX.....|........|
    kSignatureMemAddrTypeShift  = 13,
    kSignatureMemAddrTypeBits   = 0x03u,
    kSignatureMemAddrTypeMask   = kSignatureMemAddrTypeBits << kSignatureMemAddrTypeShift,

    // This memory operand represents a home-slot or stack (BaseCompiler).
    // |........|........|X.......|........|
    kSignatureMemRegHomeShift   = 15,
    kSignatureMemRegHomeBits    = 0x01u,
    kSignatureMemRegHomeFlag    = kSignatureMemRegHomeBits << kSignatureMemRegHomeShift,

    // Operand size (8 most significant bits).
    // |XXXXXXXX|........|........|........|
    kSignatureSizeShift         = 24,
    kSignatureSizeBits          = 0xFFu,
    kSignatureSizeMask          = kSignatureSizeBits << kSignatureSizeShift
  };

  // --------------------------------------------------------------------------
  // [Operand Id]
  // --------------------------------------------------------------------------

  //! Operand id helpers useful for id <-> index translation.
  enum PackedId : uint32_t {
    //! Minimum valid packed-id.
    kPackedIdMin    = 0x00000100u,
    //! Maximum valid packed-id.
    kPackedIdMax    = 0xFFFFFFFFu,
    //! Count of valid packed-ids.
    kPackedIdCount  = uint32_t(kPackedIdMax - kPackedIdMin + 1)
  };

  // --------------------------------------------------------------------------
  // [Operand Utilities]
  // --------------------------------------------------------------------------

  //! Get whether the given `id` is a valid packed-id that can be used by Operand.
  //! Packed ids are those equal or greater than `kPackedIdMin` and lesser or
  //! equal to `kPackedIdMax`. This concept was created to support virtual
  //! registers and to make them distinguishable from physical ones. It allows
  //! a single uint32_t to contain either physical register id or virtual
  //! register id represented as `packed-id`. This concept is used also for
  //! labels to make the API consistent.
  static ASMJIT_INLINE bool isPackedId(uint32_t id) noexcept { return id - kPackedIdMin < uint32_t(kPackedIdCount); }
  //! Convert a real-id into a packed-id that can be stored in Operand.
  static ASMJIT_INLINE uint32_t packId(uint32_t id) noexcept { return id + kPackedIdMin; }
  //! Convert a packed-id back to real-id.
  static ASMJIT_INLINE uint32_t unpackId(uint32_t id) noexcept { return id - kPackedIdMin; }

  // --------------------------------------------------------------------------
  // [Operand Data]
  // --------------------------------------------------------------------------

  //! Any operand.
  struct AnyData {
    uint32_t signature;                  //!< Type of the operand (see `OpType`) and other data.
    uint32_t id;                         //!< Operand id or `0`.
    uint32_t p32_2;                      //!< \internal
    uint32_t p32_3;                      //!< \internal
  };

  //! Register operand data.
  struct RegData {
    uint32_t signature;                  //!< Type of the operand (always `kOpReg`) and other data.
    uint32_t id;                         //!< Physical or virtual register id.
    uint32_t p32_2;                      //!< \internal
    uint32_t p32_3;                      //!< \internal
  };

  //! Memory operand data.
  struct MemData {
    uint32_t signature;                  //!< Type of the operand (always `kOpMem`) and other data.
    uint32_t base;                       //!< BASE register id or HIGH part of 64-bit offset.
    uint32_t index;                      //!< INDEX register id.
    uint32_t offsetLo32;                 //!< LOW part of 64-bit offset (or 32-bit offset).
  };

  //! Immediate operand data.
  struct ImmData {
    uint32_t signature;                  //!< Type of the operand (always `kOpImm`) and other data.
    uint32_t id;                         //!< Immediate id (always `0`).

    union {
      uint64_t u64;                      //!< 64-bit unsigned integer.
      int64_t  i64;                      //!< 64-bit signed integer.
      double   f64;                      //!< 64-bit floating point.

      uint32_t u32[2];                   //!< 32-bit unsigned integer (2x).
      int32_t  i32[2];                   //!< 32-bit signed integer (2x).
      float    f32[2];                   //!< 32-bit floating point (2x).
    } value;
  };

  //! Label operand data.
  struct LabelData {
    uint32_t signature;                  //!< Type of the operand (always `kOpLabel`) and other data.
    uint32_t id;                         //!< Label id (`0` if not initialized).
    uint32_t p32_2;                      //!< \internal
    uint32_t p32_3;                      //!< \internal
  };

  // --------------------------------------------------------------------------
  // [Init & Reset]
  // --------------------------------------------------------------------------

  //! \internal
  inline void _initReg(uint32_t signature, uint32_t rId) noexcept {
    _reg.signature = signature;
    _reg.id = rId;
    _p64[1] = 0;
  }

  //! \internal
  //!
  //! Initialize the operand from `other` (used by operator overloads).
  inline void copyFrom(const Operand_& other) noexcept { std::memcpy(this, &other, sizeof(Operand_)); }

  //! Reset the `Operand` to none.
  //!
  //! None operand is defined the following way:
  //!   - Its signature is zero (kOpNone, and the rest zero as well).
  //!   - Its id is `0`.
  //!   - The reserved8_4 field is set to `0`.
  //!   - The reserved12_4 field is set to zero.
  //!
  //! In other words, reset operands have all members set to zero. Reset operand
  //! must match the Operand state right after its construction. Alternatively,
  //! if you have an array of operands, you can simply use `std::memset()`.
  //!
  //! ```
  //! using namespace asmjit;
  //!
  //! Operand a;
  //! Operand b;
  //! assert(a == b);
  //!
  //! b = x86::eax;
  //! assert(a != b);
  //!
  //! b.reset();
  //! assert(a == b);
  //!
  //! std::memset(&b, 0, sizeof(Operand));
  //! assert(a == b);
  //! ```
  inline void reset() noexcept {
    _p64[0] = 0;
    _p64[1] = 0;
  }

  // --------------------------------------------------------------------------
  // [Cast]
  // --------------------------------------------------------------------------

  //! Cast this operand to `T` type.
  template<typename T>
  inline T& as() noexcept { return static_cast<T&>(*this); }

  //! Cast this operand to `T` type (const).
  template<typename T>
  inline const T& as() const noexcept { return static_cast<const T&>(*this); }

  // --------------------------------------------------------------------------
  // [Accessors]
  // --------------------------------------------------------------------------

  //! Get whether the operand matches the given signature `sign`.
  constexpr bool hasSignature(uint32_t signature) const noexcept { return _any.signature == signature; }
  //! Get whether the operand matches a signature of the `other` operand.
  constexpr bool hasSignature(const Operand_& other) const noexcept { return _any.signature == other.signature(); }

  //! Get a 32-bit operand signature.
  //!
  //! Signature is first 4 bytes of the operand data. It's used mostly for
  //! operand checking as it's much faster to check 4 bytes at once than having
  //! to check these bytes individually.
  constexpr uint32_t signature() const noexcept { return _any.signature; }

  //! Set the operand signature (see `signature()`).
  //!
  //! Improper use of `setSignature()` can lead to hard-to-debug errors.
  inline void setSignature(uint32_t signature) noexcept { _any.signature = signature; }

  //! Checks if the signature contains at least one bit set of `bits`.
  constexpr bool _hasSignatureData(uint32_t bits) const noexcept { return (_any.signature & bits) != 0; }
  //! Unpacks information from operand's signature.
  constexpr uint32_t _signatureData(uint32_t bits, uint32_t shift) const noexcept { return (_any.signature >> shift) & bits; }

  //! \internal
  //!
  //! Packs information to operand's signature.
  inline void _setSignatureData(uint32_t value, uint32_t bits, uint32_t shift) noexcept {
    ASMJIT_ASSERT(value <= bits);
    _any.signature = (_any.signature & ~(bits << shift)) | (value << shift);
  }

  inline void _addSignatureData(uint32_t data) noexcept { _any.signature |= data; }

  //! Clears specified bits in operand's signature.
  inline void _clearSignatureData(uint32_t bits, uint32_t shift) noexcept { _any.signature &= ~(bits << shift); }

  //! Get type of the operand, see `OpType`.
  constexpr uint32_t opType() const noexcept { return _signatureData(kSignatureOpBits, kSignatureOpShift); }
  //! Get whether the operand is none (`kOpNone`).
  constexpr bool isNone() const noexcept { return _any.signature == 0; }
  //! Get whether the operand is a register (`kOpReg`).
  constexpr bool isReg() const noexcept { return opType() == kOpReg; }
  //! Get whether the operand is a memory location (`kOpMem`).
  constexpr bool isMem() const noexcept { return opType() == kOpMem; }
  //! Get whether the operand is an immediate (`kOpImm`).
  constexpr bool isImm() const noexcept { return opType() == kOpImm; }
  //! Get whether the operand is a label (`kOpLabel`).
  constexpr bool isLabel() const noexcept { return opType() == kOpLabel; }

  //! Get whether the operand is a physical register.
  constexpr bool isPhysReg() const noexcept { return isReg() && _reg.id < 0xFFu; }
  //! Get whether the operand is a virtual register.
  constexpr bool isVirtReg() const noexcept { return isReg() && _reg.id > 0xFFu; }

  //! Get whether the operand specifies a size (i.e. the size is not zero).
  constexpr bool hasSize() const noexcept { return _hasSignatureData(kSignatureSizeMask); }
  //! Get whether the size of the operand matches `size`.
  constexpr bool hasSize(uint32_t s) const noexcept { return size() == s; }

  //! Get size of the operand (in bytes).
  //!
  //! The value returned depends on the operand type:
  //!   * None  - Should always return zero size.
  //!   * Reg   - Should always return the size of the register. If the register
  //!             size depends on architecture (like `x86::CReg` and `x86::DReg`)
  //!             the size returned should be the greatest possible (so it should
  //!             return 64-bit size in such case).
  //!   * Mem   - Size is optional and will be in most cases zero.
  //!   * Imm   - Should always return zero size.
  //!   * Label - Should always return zero size.
  constexpr uint32_t size() const noexcept { return _signatureData(kSignatureSizeBits, kSignatureSizeShift); }

  //! Get the operand id.
  //!
  //! The value returned should be interpreted accordingly to the operand type:
  //!   * None  - Should be `0`.
  //!   * Reg   - Physical or virtual register id.
  //!   * Mem   - Multiple meanings - BASE address (register or label id), or
  //!             high value of a 64-bit absolute address.
  //!   * Imm   - Should be `0`.
  //!   * Label - Label id if it was created by using `newLabel()` or `0`
  //!             if the label is invalid or uninitialized.
  constexpr uint32_t id() const noexcept { return _any.id; }

  //! Get whether the operand is 100% equal to `other`.
  constexpr bool isEqual(const Operand_& other) const noexcept {
    return (_p64[0] == other._p64[0]) &
           (_p64[1] == other._p64[1]) ;
  }

  //! Get whether the operand is a register matching `rType`.
  constexpr bool isReg(uint32_t rType) const noexcept {
    return (_any.signature & (kSignatureOpMask | kSignatureRegTypeMask)) ==
           ((kOpReg << kSignatureOpShift) | (rType << kSignatureRegTypeShift));
  }

  //! Get whether the operand is register and of `rType` and `rId`.
  constexpr bool isReg(uint32_t rType, uint32_t rId) const noexcept {
    return isReg(rType) && id() == rId;
  }

  //! Get whether the operand is a register or memory.
  constexpr bool isRegOrMem() const noexcept {
    return Support::isBetween<uint32_t>(opType(), kOpReg, kOpMem);
  }

  // --------------------------------------------------------------------------
  // [Operator Overload]
  // --------------------------------------------------------------------------

  template<typename T> constexpr bool operator==(const T& other) const noexcept { return  isEqual(other); }
  template<typename T> constexpr bool operator!=(const T& other) const noexcept { return !isEqual(other); }

  // --------------------------------------------------------------------------
  // [Members]
  // --------------------------------------------------------------------------

  union {
    uint32_t _p32[4];                    //!< Operand packed into four 32-bit integers.
    uint64_t _p64[2];                    //!< Operand packed into two 64-bit integers.

    AnyData _any;                        //!< Generic data.
    RegData _reg;                        //!< Physical or virtual register data.
    MemData _mem;                        //!< Memory address data.
    ImmData _imm;                        //!< Immediate value data.
    LabelData _label;                    //!< Label data.
  };
};

// ============================================================================
// [asmjit::Operand]
// ============================================================================

//! Operand can contain register, memory location, immediate, or label.
class Operand : public Operand_ {
public:
  // --------------------------------------------------------------------------
  // [Construction / Destruction]
  // --------------------------------------------------------------------------

  //! Create `Operand_::kOpNone` operand (all values initialized to zeros).
  constexpr Operand() noexcept
    : Operand_{{{ kOpNone, 0u, 0u, 0u }}} {}

  //! Create a cloned `other` operand.
  constexpr Operand(const Operand& other) noexcept
    : Operand_(other) {}

  //! Create a cloned `other` operand.
  constexpr explicit Operand(const Operand_& other)
    : Operand_(other) {}

  //! Create an operand initialized to raw `[p0, p1, p2, p3]` values.
  constexpr Operand(Globals::Init_, uint32_t p0, uint32_t p1, uint32_t p2, uint32_t p3) noexcept
    : Operand_{{{ p0, p1, p2, p3 }}} {}

  //! Create an uninitialized operand (dangerous).
  inline explicit Operand(Globals::NoInit_) noexcept {}

  // --------------------------------------------------------------------------
  // [Clone]
  // --------------------------------------------------------------------------

  //! Clone the `Operand`.
  constexpr Operand clone() const noexcept { return Operand(*this); }

  // --------------------------------------------------------------------------
  // [Operator Overload]
  // --------------------------------------------------------------------------

  inline Operand& operator=(const Operand_& other) noexcept { copyFrom(other); return *this; }
};

static_assert(sizeof(Operand) == 16, "asmjit::Operand must be exactly 16 bytes long");

namespace Globals {
  static constexpr const Operand none;
}

// ============================================================================
// [asmjit::Label]
// ============================================================================

//! Label (jump target or data location).
//!
//! Label represents a location in code typically used as a jump target, but
//! may be also a reference to some data or a static variable. Label has to be
//! explicitly created by BaseEmitter.
//!
//! Example of using labels:
//!
//! ~~~
//! // Create some emitter (for example x86::Assembler).
//! x86::Assembler a;
//!
//! // Create Label instance.
//! Label L1 = a.newLabel();
//!
//! // ... your code ...
//!
//! // Using label.
//! a.jump(L1);
//!
//! // ... your code ...
//!
//! // Bind label to the current position, see `BaseEmitter::bind()`.
//! a.bind(L1);
//! ~~~
class Label : public Operand {
public:
  //! Type of the Label.
  enum LabelType : uint32_t {
    kTypeAnonymous = 0,                  //!< Anonymous (unnamed) label.
    kTypeLocal     = 1,                  //!< Local label (always has parentId).
    kTypeGlobal    = 2,                  //!< Global label (never has parentId).
    kTypeCount     = 3                   //!< Number of label types.
  };

  // TODO: Find a better place, find a better name.
  enum {
    //! Label tag is used as a sub-type, forming a unique signature across all
    //! operand types as 0x1 is never associated with any register (reg-type).
    //! This means that a memory operand's BASE register can be constructed
    //! from virtually any operand (register vs. label) by just assigning its
    //! type (reg type or label-tag) and operand id.
    kLabelTag = 0x1
  };

  // --------------------------------------------------------------------------
  // [Construction / Destruction]
  // --------------------------------------------------------------------------

  //! Create a label operand without ID (you must set the ID to make it valid).
  constexpr Label() noexcept
    : Operand(Globals::Init, kOpLabel, 0, 0, 0) {}

  //! Create a cloned label operand of `other` .
  constexpr Label(const Label& other) noexcept
    : Operand(other) {}

  //! Create a label operand of the given `id`.
  constexpr explicit Label(uint32_t id) noexcept
    : Operand(Globals::Init, kOpLabel, id, 0, 0) {}

  inline explicit Label(Globals::NoInit_) noexcept
    : Operand(Globals::NoInit) {}

  // --------------------------------------------------------------------------
  // [Reset]
  // --------------------------------------------------------------------------

  //! Reset label, will reset all properties and set its ID to `0`.
  inline void reset() noexcept {
    _label.signature = kOpLabel;
    _label.id = 0;
    _p64[1] = 0;
  }

  // --------------------------------------------------------------------------
  // [Label Specific]
  // --------------------------------------------------------------------------

  //! Get whether the label was created by BaseEmitter and has an assigned id.
  constexpr bool isValid() const noexcept { return _label.id != 0; }
  //! Set label id.
  inline void setId(uint32_t id) noexcept { _label.id = id; }

  // --------------------------------------------------------------------------
  // [Operator Overload]
  // --------------------------------------------------------------------------

  inline Label& operator=(const Label& other) noexcept = default;
};

// ============================================================================
// [asmjit::BaseRegTraits]
// ============================================================================

//! \internal
struct BaseRegTraits {
  static constexpr uint32_t kValid  = 0; //!< RegType is not valid by default.
  static constexpr uint32_t kCount  = 0; //!< Count of registers (0 if none).
  static constexpr uint32_t kTypeId = 0; //!< Everything is void by default.

  static constexpr uint32_t kType   = 0; //!< Zero type by default.
  static constexpr uint32_t kGroup  = 0; //!< Zero group by default.
  static constexpr uint32_t kSize   = 0; //!< No size by default.

  //! Empty signature by default.
  static constexpr uint32_t kSignature = Operand::kOpReg;
};

//! \internal
//!
//! Adds a template specialization for `REG_TYPE` into the local `RegTraits`.
#define ASMJIT_DEFINE_REG_TRAITS(REG, REG_TYPE, GROUP, SIZE, COUNT, TYPE_ID)  \
template<>                                                                    \
struct RegTraits<REG_TYPE> {                                                  \
  typedef REG RegT;                                                           \
                                                                              \
  static constexpr uint32_t kValid = 1;                                       \
  static constexpr uint32_t kCount = COUNT;                                   \
  static constexpr uint32_t kTypeId = TYPE_ID;                                \
                                                                              \
  static constexpr uint32_t kType = REG_TYPE;                                 \
  static constexpr uint32_t kGroup = GROUP;                                   \
  static constexpr uint32_t kSize = SIZE;                                     \
                                                                              \
  static constexpr uint32_t kSignature =                                      \
    (Operand::kOpReg << Operand::kSignatureOpShift      ) |                   \
    (kType           << Operand::kSignatureRegTypeShift ) |                   \
    (kGroup          << Operand::kSignatureRegGroupShift) |                   \
    (kSize           << Operand::kSignatureSizeShift    ) ;                   \
}


// ============================================================================
// [asmjit::BaseReg]
// ============================================================================

//! \internal
//!
//! Adds constructors, and member functions to a class implementing abstract
//! register. Abstract register is register that doesn't have type or signature
//! yet, it's a base class like `x86::Reg` or `arm::Reg`.
#define ASMJIT_DEFINE_ABSTRACT_REG(REG, BASE)                                 \
public:                                                                       \
  /*! Default constructor that only setups basics. */                         \
  constexpr REG() noexcept                                                    \
    : BASE(kSignature, kIdBad) {}                                             \
                                                                              \
  /*! Copy the `other` REG register operand. */                               \
  constexpr REG(const REG& other) noexcept                                    \
    : BASE(other) {}                                                          \
                                                                              \
  /*! Copy the `other` REG register operand having its id set to `rId` */     \
  constexpr REG(const BaseReg& other, uint32_t rId) noexcept                  \
    : BASE(other, rId) {}                                                     \
                                                                              \
  /*! Create a REG register operand based on `signature` and `rId`. */        \
  constexpr REG(uint32_t signature, uint32_t rId) noexcept                    \
    : BASE(signature, rId) {}                                                 \
                                                                              \
  /*! Create a completely uninitialized REG register operand (garbage). */    \
  inline explicit REG(Globals::NoInit_) noexcept                              \
    : BASE(Globals::NoInit) {}                                                \
                                                                              \
  /*! Create a new register from register type and id. */                     \
  static inline REG fromTypeAndId(uint32_t rType, uint32_t rId) noexcept {    \
    return REG(signatureOf(rType), rId);                                      \
  }                                                                           \
                                                                              \
  /*! Clone the register operand. */                                          \
  constexpr REG clone() const noexcept { return REG(*this); }                 \
                                                                              \
  inline REG& operator=(const REG& other) noexcept = default;

#define ASMJIT_DEFINE_FINAL_REG(REG, BASE, TRAITS)                            \
public:                                                                       \
  static constexpr uint32_t kThisType  = TRAITS::kType;                       \
  static constexpr uint32_t kThisGroup = TRAITS::kGroup;                      \
  static constexpr uint32_t kThisSize  = TRAITS::kSize;                       \
  static constexpr uint32_t kSignature = TRAITS::kSignature;                  \
                                                                              \
  ASMJIT_DEFINE_ABSTRACT_REG(REG, BASE)                                       \
                                                                              \
  /*! Create a REG register with `rId`. */                                    \
  constexpr explicit REG(uint32_t rId) noexcept                               \
    : BASE(kSignature, rId) {}

//! Structure that allows to extract a register information based on the signature.
//!
//! This information is compatible with operand's signature (32-bit integer)
//! and `RegInfo` just provides easy way to access it.
struct RegInfo {
  inline void reset() noexcept { _signature = 0; }
  inline void setSignature(uint32_t signature) noexcept { _signature = signature; }

  constexpr bool isValid() const noexcept { return _signature != 0; }
  constexpr uint32_t signature() const noexcept { return _signature; }
  constexpr uint32_t opType() const noexcept { return (_signature >> Operand::kSignatureOpShift) & Operand::kSignatureOpBits; }
  constexpr uint32_t group() const noexcept { return (_signature >> Operand::kSignatureRegGroupShift) & Operand::kSignatureRegGroupBits; }
  constexpr uint32_t type() const noexcept { return (_signature >> Operand::kSignatureRegTypeShift) & Operand::kSignatureRegTypeBits; }
  constexpr uint32_t size() const noexcept { return (_signature >> Operand::kSignatureSizeShift) & Operand::kSignatureSizeBits; }

  uint32_t _signature;
};

//! Physical/Virtual register operand.
class BaseReg : public Operand {
public:
  //! Architecture neutral register types.
  //!
  //! These must be reused by any platform that contains that types. All GP
  //! and VEC registers are also allowed by design to be part of a BASE|INDEX
  //! of a memory operand.
  enum RegType : uint32_t {
    kTypeNone       = 0,                 //!< No register - unused, invalid, multiple meanings.
    // (1 is used as a LabelTag)
    kTypeGp8Lo      = 2,                 //!< 8-bit low general purpose register (X86).
    kTypeGp8Hi      = 3,                 //!< 8-bit high general purpose register (X86).
    kTypeGp16       = 4,                 //!< 16-bit general purpose register (X86).
    kTypeGp32       = 5,                 //!< 32-bit general purpose register (X86|ARM).
    kTypeGp64       = 6,                 //!< 64-bit general purpose register (X86|ARM).
    kTypeVec32      = 7,                 //!< 32-bit view of a vector register (ARM).
    kTypeVec64      = 8,                 //!< 64-bit view of a vector register (ARM).
    kTypeVec128     = 9,                 //!< 128-bit view of a vector register (X86|ARM).
    kTypeVec256     = 10,                //!< 256-bit view of a vector register (X86).
    kTypeVec512     = 11,                //!< 512-bit view of a vector register (X86).
    kTypeVec1024    = 12,                //!< 1024-bit view of a vector register (future).
    kTypeOther0     = 13,                //!< Other0 register, should match `kOther0` group.
    kTypeOther1     = 14,                //!< Other1 register, should match `kOther1` group.
    kTypeIP         = 15,                //!< Universal id of IP/PC register (if separate).
    kTypeCustom     = 16,                //!< Start of platform dependent register types (must be honored).
    kTypeMax        = 31                 //!< Maximum possible register id of all architectures.
  };

  //! Register group (architecture neutral), and some limits.
  enum RegGroup : uint32_t {
    kGroupGp        = 0,                 //!< General purpose register group compatible with all backends.
    kGroupVec       = 1,                 //!< Vector register group compatible with all backends.
    kGroupOther0    = 2,
    kGroupOther1    = 3,
    kGroupVirt      = 4,                 //!< Count of register groups used by virtual registers.
    kGroupCount     = 16                 //!< Count of register groups used by physical registers.
  };

  enum Id : uint32_t {
    kIdBad          = 0xFFu               //!< None or any register (mostly internal).
  };

  static constexpr uint32_t kSignature = kOpReg;

  // --------------------------------------------------------------------------
  // [Construction / Destruction]
  // --------------------------------------------------------------------------

  //! Create a dummy register operand.
  constexpr BaseReg() noexcept
    : Operand(Globals::Init, kSignature, kIdBad, 0, 0) {}

  //! Create a new register operand which is the same as `other` .
  constexpr BaseReg(const BaseReg& other) noexcept
    : Operand(other) {}

  //! Create a new register operand compatible with `other`, but with a different `rId`.
  constexpr BaseReg(const BaseReg& other, uint32_t rId) noexcept
    : Operand(Globals::Init, other._any.signature, rId, 0, 0) {}

  //! Create a register initialized to `signature` and `rId`.
  constexpr BaseReg(uint32_t signature, uint32_t rId) noexcept
    : Operand(Globals::Init, signature, rId, 0, 0) {}

  inline explicit BaseReg(Globals::NoInit_) noexcept
    : Operand(Globals::NoInit) {}

  // --------------------------------------------------------------------------
  // [Reg Specific]
  // --------------------------------------------------------------------------

  //! Get whether this register is the same as `other`.
  //!
  //! This is just an optimization. Registers by default only use the first
  //! 8 bytes of the Operand, so this method takes advantage of this knowledge
  //! and only compares these 8 bytes. If both operands were created correctly
  //! then `isEqual()` and `isSame()` should give the same answer, however, if
  //! some one of the two operand contains a garbage or other metadata in the
  //! upper 8 bytes then `isSame()` may return `true` in cases where `isEqual()`
  //! returns false.
  constexpr bool isSame(const BaseReg& other) const noexcept { return _p64[0] == other._p64[0]; }

  //! Get whether the register is valid (either virtual or physical).
  constexpr bool isValid() const noexcept { return (_any.signature != 0) & (_any.id != kIdBad); }

  //! Get whether this is a physical register.
  constexpr bool isPhysReg() const noexcept { return _reg.id < kIdBad; }
  //! Get whether this is a virtual register.
  constexpr bool isVirtReg() const noexcept { return _reg.id > kIdBad; }

  //! Get whether the register type matches `type` - same as `isReg(type)`, provided for convenience.
  constexpr bool isType(uint32_t type) const noexcept { return (_any.signature & kSignatureRegTypeMask) == (type << kSignatureRegTypeShift); }
  //! Get whether the register group matches `group`.
  constexpr bool isGroup(uint32_t group) const noexcept { return (_any.signature & kSignatureRegGroupMask) == (group << kSignatureRegGroupShift); }

  //! Get whether the register is a general purpose register (any size).
  constexpr bool isGp() const noexcept { return isGroup(kGroupGp); }
  //! Get whether the register is a vector register.
  constexpr bool isVec() const noexcept { return isGroup(kGroupVec); }

  using Operand_::isReg;

  //! Same as `isType()`, provided for convenience.
  constexpr bool isReg(uint32_t rType) const noexcept { return isType(rType); }
  //! Get whether the register type matches `type` and register id matches `rId`.
  constexpr bool isReg(uint32_t rType, uint32_t rId) const noexcept { return isType(rType) && id() == rId; }

  //! Get the register type.
  constexpr uint32_t type() const noexcept { return _signatureData(kSignatureRegTypeBits, kSignatureRegTypeShift); }
  //! Get the register group.
  constexpr uint32_t group() const noexcept { return _signatureData(kSignatureRegGroupBits, kSignatureRegGroupShift); }

  //! Clone the register operand.
  constexpr BaseReg clone() const noexcept { return BaseReg(*this); }

  //! Cast this register to `RegT` by also changing its signature.
  //!
  //! NOTE: Improper use of `cloneAs()` can lead to hard-to-debug errors.
  template<typename RegT>
  constexpr RegT cloneAs() const noexcept { return RegT(RegT::kSignature, id()); }

  //! Cast this register to `other` by also changing its signature.
  //!
  //! NOTE: Improper use of `cloneAs()` can lead to hard-to-debug errors.
  template<typename RegT>
  constexpr RegT cloneAs(const RegT& other) const noexcept { return RegT(other.signature(), id()); }

  //! Set the register id to `rId`.
  inline void setId(uint32_t rId) noexcept { _reg.id = rId; }

  //! Set a 32-bit operand signature based on traits of `RegT`.
  template<typename RegT>
  inline void setSignatureT() noexcept { _any.signature = RegT::kSignature; }

  //! Set register's `signature` and `rId`.
  inline void setSignatureAndId(uint32_t signature, uint32_t rId) noexcept {
    _reg.signature = signature;
    _reg.id = rId;
  }

  // --------------------------------------------------------------------------
  // [Reg Statics]
  // --------------------------------------------------------------------------

  static inline bool isGp(const Operand_& op) noexcept {
    // Check operand type and register group. Not interested in register type and size.
    const uint32_t kSgn = (kOpReg   << kSignatureOpShift      ) |
                          (kGroupGp << kSignatureRegGroupShift) ;
    return (op.signature() & (kSignatureOpMask | kSignatureRegGroupMask)) == kSgn;
  }

  //! Get whether the `op` operand is either a low or high 8-bit GPB register.
  static inline bool isVec(const Operand_& op) noexcept {
    // Check operand type and register group. Not interested in register type and size.
    const uint32_t kSgn = (kOpReg    << kSignatureOpShift      ) |
                          (kGroupVec << kSignatureRegGroupShift) ;
    return (op.signature() & (kSignatureOpMask | kSignatureRegGroupMask)) == kSgn;
  }

  static inline bool isGp(const Operand_& op, uint32_t rId) noexcept { return isGp(op) & (op.id() == rId); }
  static inline bool isVec(const Operand_& op, uint32_t rId) noexcept { return isVec(op) & (op.id() == rId); }
};

// ============================================================================
// [asmjit::RegOnly]
// ============================================================================

//! RegOnly is 8-byte version of `BaseReg` that only allows to store only register.
//! This class was designed to decrease the space consumed by each extra "operand"
//! in `BaseEmitter` and `InstNode` classes.
struct RegOnly {
  // --------------------------------------------------------------------------
  // [Init / Reset]
  // --------------------------------------------------------------------------

  //! Initialize the `RegOnly` instance to hold register `signature` and `id`.
  inline void init(uint32_t signature, uint32_t id) noexcept {
    _signature = signature;
    _id = id;
  }

  inline void init(const BaseReg& reg) noexcept { init(reg.signature(), reg.id()); }
  inline void init(const RegOnly& reg) noexcept { init(reg.signature(), reg.id()); }

  //! Reset the `RegOnly` to none.
  inline void reset() noexcept { init(0, 0); }

  // --------------------------------------------------------------------------
  // [Accessors]
  // --------------------------------------------------------------------------

  //! Get whether the `ExtraReg` is none (same as calling `Operand_::isNone()`).
  constexpr bool isNone() const noexcept { return _signature == 0; }
  //! Get whether the register is valid (either virtual or physical).
  constexpr bool isReg() const noexcept { return _signature != 0; }

  //! Get whether this is a physical register.
  constexpr bool isPhysReg() const noexcept { return _id < BaseReg::kIdBad; }
  //! Get whether this is a virtual register (used by `BaseCompiler`).
  constexpr bool isVirtReg() const noexcept { return _id > BaseReg::kIdBad; }

  //! Get the register signature or 0.
  constexpr uint32_t signature() const noexcept { return _signature; }
  //! Get the register id or 0.
  constexpr uint32_t id() const noexcept { return _id; }

  //! Set the register id.
  inline void setId(uint32_t id) noexcept { _id = id; }

  //! \internal
  //!
  //! Unpacks information from operand's signature.
  constexpr uint32_t _signatureData(uint32_t bits, uint32_t shift) const noexcept { return (_signature >> shift) & bits; }

  //! Get the register type.
  constexpr uint32_t type() const noexcept { return _signatureData(Operand::kSignatureRegTypeBits, Operand::kSignatureRegTypeShift); }
  //! Get constexpr register group.
  constexpr uint32_t group() const noexcept { return _signatureData(Operand::kSignatureRegGroupBits, Operand::kSignatureRegGroupShift); }

  // --------------------------------------------------------------------------
  // [ToReg]
  // --------------------------------------------------------------------------

  //! Convert back to `RegT` operand.
  template<typename RegT>
  constexpr RegT toReg() const noexcept { return RegT(_signature, _id); }

  // --------------------------------------------------------------------------
  // [Members]
  // --------------------------------------------------------------------------

  //! Type of the operand, either `kOpNone` or `kOpReg`.
  uint32_t _signature;
  //! Physical or virtual register id.
  uint32_t _id;
};

// ============================================================================
// [asmjit::BaseMem]
// ============================================================================

//! Base class for all memory operands.
//!
//! NOTE: It's tricky to pack all possible cases that define a memory operand
//! into just 16 bytes. The `BaseMem` splits data into the following parts:
//!
//!   BASE   - Base register or label - requires 36 bits total. 4 bits are used to
//!            encode the type of the BASE operand (label vs. register type) and
//!            the remaining 32 bits define the BASE id, which can be a physical or
//!            virtual register index. If BASE type is zero, which is never used as
//!            a register-type and label doesn't use it as well then BASE field
//!            contains a high DWORD of a possible 64-bit absolute address, which is
//!            possible on X64.
//!
//!   INDEX  - Index register (or theoretically Label, which doesn't make sense).
//!            Encoding is similar to BASE - it also requires 36 bits and splits
//!            the encoding to INDEX type (4 bits defining the register type) and
//!            id (32-bits).
//!
//!   OFFSET - A relative offset of the address. Basically if BASE is specified
//!            the relative displacement adjusts BASE and an optional INDEX. if
//!            BASE is not specified then the OFFSET should be considered as ABSOLUTE
//!            address (at least on X86). In that case its low 32 bits are stored in
//!            DISPLACEMENT field and the remaining high 32 bits are stored in BASE.
//!
//!   OTHER  - There is rest 8 bits that can be used for whatever purpose. The
//!            x86::Mem operand uses these bits to store segment override prefix and
//!            index shift (scale).
class BaseMem : public Operand {
public:
  enum AddrType : uint32_t {
    kAddrTypeDefault = 0,
    kAddrTypeAbs     = 1,
    kAddrTypeRel     = 2,
    kAddrTypeWrt     = 3
  };

  // Shortcuts.
  enum SignatureMem : uint32_t {
    kSignatureMemAbs = kAddrTypeAbs << kSignatureMemAddrTypeShift,
    kSignatureMemRel = kAddrTypeRel << kSignatureMemAddrTypeShift,
    kSignatureMemWrt = kAddrTypeWrt << kSignatureMemAddrTypeShift
  };

  // --------------------------------------------------------------------------
  // [Construction / Destruction]
  // --------------------------------------------------------------------------

  //! Construct a default `BaseMem` operand, that points to [0].
  constexpr BaseMem() noexcept
    : Operand(Globals::Init, kOpMem, 0, 0, 0) {}

  //! Construct a `BaseMem` operand that is a clone of `other`.
  constexpr BaseMem(const BaseMem& other) noexcept
    : Operand(other) {}

  //! Construct a `BaseMem` operand from `MemData`.
  constexpr explicit BaseMem(const MemData& data) noexcept
    : Operand(Globals::Init, data.signature, data.base, data.index, data.offsetLo32) {}

  constexpr BaseMem(Globals::Init_, uint32_t baseType, uint32_t baseId, uint32_t indexType, uint32_t indexId, int32_t off, uint32_t size, uint32_t flags) noexcept
    : Operand(Globals::Init,
              kOpMem | (baseType  << kSignatureMemBaseTypeShift )
                     | (indexType << kSignatureMemIndexTypeShift)
                     | (size      << kSignatureSizeShift        )
                     | flags,
              baseId,
              indexId,
              uint32_t(off)) {}

  inline explicit BaseMem(Globals::NoInit_) noexcept
    : Operand(Globals::NoInit) {}

  // --------------------------------------------------------------------------
  // [Init / Reset]
  // --------------------------------------------------------------------------

  //! Reset the memory operand - after reset the memory points to [0].
  inline void reset() noexcept {
    _any.signature = kOpMem;
    _any.id = 0;
    _p64[1] = 0;
  }

  // --------------------------------------------------------------------------
  // [Mem Specific]
  // --------------------------------------------------------------------------

  //! Clone `BaseMem` operand.
  constexpr BaseMem clone() const noexcept { return BaseMem(*this); }

  constexpr uint32_t addrType() const noexcept { return _signatureData(kSignatureMemAddrTypeBits, kSignatureMemAddrTypeShift); }
  inline void setAddrType(uint32_t addrType) noexcept { return _setSignatureData(addrType, kSignatureMemAddrTypeBits, kSignatureMemAddrTypeShift); }
  inline void resetAddrType() noexcept { return _clearSignatureData(kSignatureMemAddrTypeBits, kSignatureMemAddrTypeShift); }

  constexpr bool isAbs() const noexcept { return addrType() == kAddrTypeAbs; }
  inline void setAbs() noexcept { setAddrType(kAddrTypeAbs); }

  constexpr bool isRel() const noexcept { return addrType() == kAddrTypeRel; }
  inline void setRel() noexcept { setAddrType(kAddrTypeRel); }

  constexpr bool isWrt() const noexcept { return addrType() == kAddrTypeWrt; }
  inline void setWrt() noexcept { setAddrType(kAddrTypeWrt); }

  constexpr bool isRegHome() const noexcept { return _hasSignatureData(kSignatureMemRegHomeFlag); }
  inline void setRegHome() noexcept { _any.signature |= kSignatureMemRegHomeFlag; }
  inline void clearRegHome() noexcept { _any.signature &= ~kSignatureMemRegHomeFlag; }

  //! Get whether the memory operand has a BASE register or label specified.
  constexpr bool hasBase() const noexcept { return (_any.signature & kSignatureMemBaseTypeMask) != 0; }
  //! Get whether the memory operand has an INDEX register specified.
  constexpr bool hasIndex() const noexcept { return (_any.signature & kSignatureMemIndexTypeMask) != 0; }
  //! Get whether the memory operand has BASE and INDEX register.
  constexpr bool hasBaseOrIndex() const noexcept { return (_any.signature & kSignatureMemBaseIndexMask) != 0; }
  //! Get whether the memory operand has BASE and INDEX register.
  constexpr bool hasBaseAndIndex() const noexcept { return (_any.signature & kSignatureMemBaseTypeMask) != 0 && (_any.signature & kSignatureMemIndexTypeMask) != 0; }

  //! Get whether the BASE operand is a register (registers start after `kLabelTag`).
  constexpr bool hasBaseReg() const noexcept { return (_any.signature & kSignatureMemBaseTypeMask) > (Label::kLabelTag << kSignatureMemBaseTypeShift); }
  //! Get whether the BASE operand is a label.
  constexpr bool hasBaseLabel() const noexcept { return (_any.signature & kSignatureMemBaseTypeMask) == (Label::kLabelTag << kSignatureMemBaseTypeShift); }
  //! Get whether the INDEX operand is a register (registers start after `kLabelTag`).
  constexpr bool hasIndexReg() const noexcept { return (_any.signature & kSignatureMemIndexTypeMask) > (Label::kLabelTag << kSignatureMemIndexTypeShift); }

  //! Get type of a BASE register (0 if this memory operand doesn't use the BASE register).
  //!
  //! NOTE: If the returned type is one (a value never associated to a register
  //! type) the BASE is not register, but it's a label. One equals to `kLabelTag`.
  //! You should always check `hasBaseLabel()` before using `baseId()` result.
  constexpr uint32_t baseType() const noexcept { return _signatureData(kSignatureMemBaseTypeBits, kSignatureMemBaseTypeShift); }
  //! Get type of an INDEX register (0 if this memory operand doesn't use the INDEX register).
  constexpr uint32_t indexType() const noexcept { return _signatureData(kSignatureMemIndexTypeBits, kSignatureMemIndexTypeShift); }
  //! This is used internally for BASE+INDEX validation.
  constexpr uint32_t baseAndIndexTypes() const noexcept { return _signatureData(kSignatureMemBaseIndexBits, kSignatureMemBaseIndexShift); }

  //! Get both BASE (4:0 bits) and INDEX (9:5 bits) types combined into a single integer.
  //!
  //! Get id of the BASE register or label (if the BASE was specified as label).
  constexpr uint32_t baseId() const noexcept { return _mem.base; }
  //! Get id of the INDEX register.
  constexpr uint32_t indexId() const noexcept { return _mem.index; }

  //! Set id of the BASE register (without modifying its type).
  inline void setBaseId(uint32_t rId) noexcept { _mem.base = rId; }
  //! Set id of the INDEX register (without modifying its type).
  inline void setIndexId(uint32_t rId) noexcept { _mem.index = rId; }

  inline void setBase(const BaseReg& base) noexcept { return _setBase(base.type(), base.id()); }
  inline void setIndex(const BaseReg& index) noexcept { return _setIndex(index.type(), index.id()); }

  inline void _setBase(uint32_t rType, uint32_t rId) noexcept {
    _setSignatureData(rType, kSignatureMemBaseTypeBits, kSignatureMemBaseTypeShift);
    _mem.base = rId;
  }

  inline void _setIndex(uint32_t rType, uint32_t rId) noexcept {
    _setSignatureData(rType, kSignatureMemIndexTypeBits, kSignatureMemIndexTypeShift);
    _mem.index = rId;
  }

  //! Reset the memory operand's BASE register / label.
  inline void resetBase() noexcept { _setBase(0, 0); }
  //! Reset the memory operand's INDEX register.
  inline void resetIndex() noexcept { _setIndex(0, 0); }

  //! Set memory operand size.
  inline void setSize(uint32_t size) noexcept {
    _setSignatureData(size, kSignatureSizeBits, kSignatureSizeShift);
  }

  //! Get whether the memory operand has a 64-bit offset or absolute address.
  //!
  //! If this is true then `hasBase()` must always report false.
  constexpr bool isOffset64Bit() const noexcept { return baseType() == 0; }

  //! Get whether the memory operand has a non-zero offset or absolute address.
  constexpr bool hasOffset() const noexcept {
    return (_mem.offsetLo32 | uint32_t(_mem.base & Support::bitMaskFromBool<uint32_t>(isOffset64Bit()))) != 0;
  }

  //! Get a 64-bit offset or absolute address.
  constexpr int64_t offset() const noexcept {
    return isOffset64Bit() ? int64_t(uint64_t(_mem.offsetLo32) | (uint64_t(_mem.base) << 32))
                           : int64_t(int32_t(_mem.offsetLo32)); // Sign extend 32-bit offset.
  }

  //! Get a lower part of a 64-bit offset or absolute address.
  constexpr int32_t offsetLo32() const noexcept { return int32_t(_mem.offsetLo32); }
  //! Get a higher part of a 64-bit offset or absolute address.
  //!
  //! NOTE: This function is UNSAFE and returns garbage if `isOffset64Bit()`
  //! returns false. Never use it blindly without checking it first.
  constexpr int32_t offsetHi32() const noexcept { return int32_t(_mem.base); }

  //! Set a 64-bit offset or an absolute address to `offset`.
  //!
  //! NOTE: This functions attempts to set both high and low parts of a 64-bit
  //! offset, however, if the operand has a BASE register it will store only the
  //! low 32 bits of the offset / address as there is no way to store both BASE
  //! and 64-bit offset, and there is currently no architecture that has such
  //! capability targeted by AsmJit.
  inline void setOffset(int64_t offset) noexcept {
    uint32_t lo = uint32_t(uint64_t(offset) & 0xFFFFFFFFu);
    uint32_t hi = uint32_t(uint64_t(offset) >> 32);
    uint32_t hiMsk = Support::bitMaskFromBool<uint32_t>(isOffset64Bit());

    _mem.offsetLo32 = lo;
    _mem.base = (hi & hiMsk) | (_mem.base & ~hiMsk);
  }
  //! Set a low 32-bit offset to `offset` (don't use without knowing how BaseMem works).
  inline void setOffsetLo32(int32_t offset) noexcept { _mem.offsetLo32 = uint32_t(offset); }

  //! Adjust the offset by `offset`.
  //!
  //! NOTE: This is a fast function that doesn't use the HI 32-bits of a
  //! 64-bit offset. Use it only if you know that there is a BASE register
  //! and the offset is only 32 bits anyway.

  //! Adjust the offset by a 64-bit `offset`.
  inline void addOffset(int64_t offset) noexcept {
    if (isOffset64Bit()) {
      int64_t result = offset + int64_t(uint64_t(_mem.offsetLo32) | (uint64_t(_mem.base) << 32));
      _mem.offsetLo32 = uint32_t(uint64_t(result) & 0xFFFFFFFFu);
      _mem.base       = uint32_t(uint64_t(result) >> 32);
    }
    else {
      _mem.offsetLo32 += uint32_t(uint64_t(offset) & 0xFFFFFFFFu);
    }
  }
  //! Add `offset` to a low 32-bit offset part (don't use without knowing how BaseMem works).
  inline void addOffsetLo32(int32_t offset) noexcept { _mem.offsetLo32 += uint32_t(offset); }

  //! Reset the memory offset to zero.
  inline void resetOffset() noexcept { setOffset(0); }
  //! Reset the lo part of memory offset to zero (don't use without knowing how BaseMem works).
  inline void resetOffsetLo32() noexcept { setOffsetLo32(0); }

  // --------------------------------------------------------------------------
  // [Operator Overload]
  // --------------------------------------------------------------------------

  inline BaseMem& operator=(const BaseMem& other) noexcept { copyFrom(other); return *this; }
};

// ============================================================================
// [asmjit::Imm]
// ============================================================================

//! Immediate operand.
//!
//! Immediate operand is usually part of instruction itself. It's inlined after
//! or before the instruction opcode. Immediates can be only signed or unsigned
//! integers.
//!
//! To create an immediate operand use `asmjit::imm()` helper, which can be used
//! with any type, not just the default 64-bit int.
class Imm : public Operand {
public:
  // --------------------------------------------------------------------------
  // [Construction / Destruction]
  // --------------------------------------------------------------------------

  //! Create a new immediate value (initial value is 0).
  constexpr Imm() noexcept
    : Operand(Globals::Init, kOpImm, 0, 0, 0) {}

  //! Create a new immediate value from `other`.
  constexpr Imm(const Imm& other) noexcept
    : Operand(other) {}

  //! Create a new signed immediate value, assigning the value to `val`.
  constexpr explicit Imm(int64_t val) noexcept
    : Operand(Globals::Init, kOpImm, 0, Support::unpackU32At0(val), Support::unpackU32At1(val)) {}

  inline explicit Imm(Globals::NoInit_) noexcept
    : Operand(Globals::NoInit) {}

  // --------------------------------------------------------------------------
  // [Immediate Specific]
  // --------------------------------------------------------------------------

  //! Clone `Imm` operand.
  constexpr Imm clone() const noexcept { return Imm(*this); }

  //! Get whether the immediate can be casted to 8-bit signed integer.
  constexpr bool isI8() const noexcept { return Support::isI8(_imm.value.i64); }
  //! Get whether the immediate can be casted to 8-bit unsigned integer.
  constexpr bool isU8() const noexcept { return Support::isU8(_imm.value.i64); }
  //! Get whether the immediate can be casted to 16-bit signed integer.
  constexpr bool isI16() const noexcept { return Support::isI16(_imm.value.i64); }
  //! Get whether the immediate can be casted to 16-bit unsigned integer.
  constexpr bool isU16() const noexcept { return Support::isU16(_imm.value.i64); }
  //! Get whether the immediate can be casted to 32-bit signed integer.
  constexpr bool isI32() const noexcept { return Support::isI32(_imm.value.i64); }
  //! Get whether the immediate can be casted to 32-bit unsigned integer.
  constexpr bool isU32() const noexcept { return Support::isU32(_imm.value.i64); }

  //! Get immediate value as 8-bit signed integer.
  constexpr int8_t i8() const noexcept { return int8_t(i32() & 0xFF); }
  //! Get immediate value as 8-bit unsigned integer.
  constexpr uint8_t u8() const noexcept { return uint8_t(u32() & 0xFFu); }
  //! Get immediate value as 16-bit signed integer.
  constexpr int16_t i16() const noexcept { return int16_t(i32() & 0xFFFF);}
  //! Get immediate value as 16-bit unsigned integer.
  constexpr uint16_t u16() const noexcept { return uint16_t(u32() & 0xFFFFu);}
  //! Get immediate value as 32-bit signed integer.
  constexpr int32_t i32() const noexcept { return i32Lo(); }
  //! Get low 32-bit signed integer.
  constexpr int32_t i32Lo() const noexcept { return _imm.value.i32[ASMJIT_ARCH_LE ? 0 : 1]; }
  //! Get high 32-bit signed integer.
  constexpr int32_t i32Hi() const noexcept { return _imm.value.i32[ASMJIT_ARCH_LE ? 1 : 0]; }
  //! Get immediate value as 32-bit unsigned integer.
  constexpr uint32_t u32() const noexcept { return u32Lo(); }
  //! Get low 32-bit signed integer.
  constexpr uint32_t u32Lo() const noexcept { return _imm.value.u32[ASMJIT_ARCH_LE ? 0 : 1]; }
  //! Get high 32-bit signed integer.
  constexpr uint32_t u32Hi() const noexcept { return _imm.value.u32[ASMJIT_ARCH_LE ? 1 : 0]; }
  //! Get immediate value as 64-bit signed integer.
  constexpr int64_t i64() const noexcept { return _imm.value.i64; }
  //! Get immediate value as 64-bit unsigned integer.
  constexpr uint64_t u64() const noexcept { return _imm.value.u64; }
  //! Get immediate value as `intptr_t`.
  constexpr intptr_t iptr() const noexcept { return (sizeof(intptr_t) == sizeof(int64_t)) ? intptr_t(i64()) : intptr_t(i32()); }
  //! Get immediate value as `uintptr_t`.
  constexpr uintptr_t uptr() const noexcept { return (sizeof(uintptr_t) == sizeof(uint64_t)) ? uintptr_t(u64()) : uintptr_t(u32()); }

  //! Set immediate value to 8-bit signed integer `val`.
  inline void setI8(int8_t val) noexcept { _imm.value.i64 = int64_t(val); }
  //! Set immediate value to 8-bit unsigned integer `val`.
  inline void setU8(uint8_t val) noexcept { _imm.value.u64 = uint64_t(val); }
  //! Set immediate value to 16-bit signed integer `val`.
  inline void setI16(int16_t val) noexcept { _imm.value.i64 = int64_t(val); }
  //! Set immediate value to 16-bit unsigned integer `val`.
  inline void setU16(uint16_t val) noexcept { _imm.value.u64 = uint64_t(val); }
  //! Set immediate value to 32-bit signed integer `val`.
  inline void setI32(int32_t val) noexcept { _imm.value.i64 = int64_t(val); }
  //! Set immediate value to 32-bit unsigned integer `val`.
  inline void setU32(uint32_t val) noexcept { _imm.value.u64 = uint64_t(val); }
  //! Set immediate value to 64-bit signed integer `val`.
  inline void setI64(int64_t val) noexcept { _imm.value.i64 = val; }
  //! Set immediate value to 64-bit unsigned integer `val`.
  inline void setU64(uint64_t val) noexcept { _imm.value.u64 = val; }
  //! Set immediate value to intptr_t `val`.
  inline void setIPtr(intptr_t val) noexcept { _imm.value.i64 = int64_t(val); }
  //! Set immediate value to uintptr_t `val`.
  inline void setUPtr(uintptr_t val) noexcept { _imm.value.u64 = uint64_t(val); }

  //! Set immediate value to `val`.
  template<typename T>
  inline void setValue(T val) noexcept { setI64(int64_t(Support::asNormalized(val))); }

  // --------------------------------------------------------------------------
  // [Float]
  // --------------------------------------------------------------------------

  inline void setFloat(float f) noexcept {
    _imm.value.f32[ASMJIT_ARCH_LE ? 0 : 1] = f;
    _imm.value.u32[ASMJIT_ARCH_LE ? 1 : 0] = 0;
  }

  inline void setDouble(double d) noexcept {
    _imm.value.f64 = d;
  }

  // --------------------------------------------------------------------------
  // [Sign Extend / Zero Extend]
  // --------------------------------------------------------------------------

  inline void signExtend8Bits() noexcept { _imm.value.i64 = int64_t(int8_t(_imm.value.u64 & 0x000000FFu)); }
  inline void signExtend16Bits() noexcept { _imm.value.i64 = int64_t(int16_t(_imm.value.u64 & 0x0000FFFFu)); }
  inline void signExtend32Bits() noexcept { _imm.value.i64 = int64_t(int32_t(_imm.value.u64 & 0xFFFFFFFFu)); }

  inline void zeroExtend8Bits() noexcept { _imm.value.u64 = _imm.value.u64 & 0x000000FFu; }
  inline void zeroExtend16Bits() noexcept { _imm.value.u64 = _imm.value.u64 & 0x0000FFFFu; }
  inline void zeroExtend32Bits() noexcept { _imm.value.u64 = _imm.value.u64 & 0xFFFFFFFFu; }

  // --------------------------------------------------------------------------
  // [Operator Overload]
  // --------------------------------------------------------------------------

  //! Assign `other` to the immediate operand.
  inline Imm& operator=(const Imm& other) noexcept { copyFrom(other); return *this; }
};

//! Create an immediate operand.
//!
//! Using `imm(x)` is much better than `Imm(x)` as this is a template which
//! can accept any integer including pointers and function pointers.
template<typename T>
constexpr Imm imm(T val) noexcept { return Imm(int64_t(Support::asNormalized(val))); }

//! \}

ASMJIT_END_NAMESPACE

// [Guard]
#endif // _ASMJIT_CORE_OPERAND_H

```

`Avanguard/AsmJit/asmjit/core/osutils.h`:

```h
// [AsmJit]
// Complete x86/x64 JIT and Remote Assembler for C++.
//
// [License]
// ZLIB - See LICENSE.md file in the package.

// [Guard]
#ifndef _ASMJIT_CORE_OSUTILS_H
#define _ASMJIT_CORE_OSUTILS_H

// [Dependencies]
#include "../core/globals.h"

ASMJIT_BEGIN_NAMESPACE

//! \addtogroup asmjit_core_support
//! \{

// ============================================================================
// [asmjit::OSUtils]
// ============================================================================

//! Operating system utilities.
namespace OSUtils {
  //! Get the current CPU tick count, used for benchmarking (1ms resolution).
  ASMJIT_API uint32_t getTickCount() noexcept;
};

// ============================================================================
// [asmjit::Lock]
// ============================================================================

//! \internal
//!
//! Lock.
class Lock {
public:
  ASMJIT_NONCOPYABLE(Lock)

  #if ASMJIT_OS_WINDOWS

  typedef CRITICAL_SECTION Handle;

  inline Lock() noexcept { InitializeCriticalSection(&_handle); }
  inline ~Lock() noexcept { DeleteCriticalSection(&_handle); }

  inline void lock() noexcept { EnterCriticalSection(&_handle); }
  inline void unlock() noexcept { LeaveCriticalSection(&_handle); }

  Handle _handle;

  #elif ASMJIT_OS_POSIX && !defined(__EMSCRIPTEN__)

  typedef pthread_mutex_t Handle;

  inline Lock() noexcept { pthread_mutex_init(&_handle, nullptr); }
  inline ~Lock() noexcept { pthread_mutex_destroy(&_handle); }

  inline void lock() noexcept { pthread_mutex_lock(&_handle); }
  inline void unlock() noexcept { pthread_mutex_unlock(&_handle); }

  Handle _handle;

  #else

  #if !defined(__EMSCRIPTEN__)
  #pragma message("asmjit::Lock doesn't have implementation for your target OS.")
  #endif

  // Browser or other unsupported OS.
  inline Lock() noexcept {}
  inline ~Lock() noexcept {}

  inline void lock() noexcept {}
  inline void unlock() noexcept {}

  #endif
};

// ============================================================================
// [asmjit::ScopedLock]
// ============================================================================

//! \internal
//!
//! Scoped lock.
struct ScopedLock {
  ASMJIT_NONCOPYABLE(ScopedLock)

  inline ScopedLock(Lock& target) noexcept : _target(target) { _target.lock(); }
  inline ~ScopedLock() noexcept { _target.unlock(); }

  Lock& _target;
};

//! \}

ASMJIT_END_NAMESPACE

// [Guard]
#endif // _ASMJIT_CORE_OSUTILS_H

```

`Avanguard/AsmJit/asmjit/core/raassignment_p.h`:

```h
// [AsmJit]
// Complete x86/x64 JIT and Remote Assembler for C++.
//
// [License]
// ZLIB - See LICENSE.md file in the package.

// [Guard]
#ifndef _ASMJIT_CORE_RAASSIGNMENT_P_H
#define _ASMJIT_CORE_RAASSIGNMENT_P_H

#include "../core/build.h"
#ifndef ASMJIT_DISABLE_COMPILER

// [Dependencies]
#include "../core/radefs_p.h"

ASMJIT_BEGIN_NAMESPACE

//! \addtogroup asmjit_core_ra
//! \{

// ============================================================================
// [asmjit::RAAssignment]
// ============================================================================

class RAAssignment {
  ASMJIT_NONCOPYABLE(RAAssignment)

public:
  enum Ids : uint32_t {
    kPhysNone = 0xFF,
    kWorkNone = RAWorkReg::kIdNone
  };

  enum DirtyBit : uint32_t {
    kClean = 0,
    kDirty = 1
  };

  // --------------------------------------------------------------------------
  // [Layout]
  // --------------------------------------------------------------------------

  struct Layout {
    inline void reset() noexcept {
      physIndex.reset();
      physCount.reset();
      physTotal = 0;
      workCount = 0;
      workRegs = nullptr;
    }

    RARegIndex physIndex;                //!< Index of architecture registers per group.
    RARegCount physCount;                //!< Count of architecture registers per group.
    uint32_t physTotal;                  //!< Count of physical registers of all groups.
    uint32_t workCount;                  //!< Count of work registers.
    const RAWorkRegs* workRegs;          //!< WorkRegs data (vector).
  };

  // --------------------------------------------------------------------------
  // [PhysToWorkMap]
  // --------------------------------------------------------------------------

  struct PhysToWorkMap {
    static inline size_t sizeOf(uint32_t count) noexcept {
      return sizeof(PhysToWorkMap) - sizeof(uint32_t) + size_t(count) * sizeof(uint32_t);
    }

    inline void reset(uint32_t count) noexcept {
      assigned.reset();
      dirty.reset();

      for (uint32_t i = 0; i < count; i++)
        workIds[i] = kWorkNone;
    }

    inline void copyFrom(const PhysToWorkMap* other, uint32_t count) noexcept {
      size_t size = sizeOf(count);
      std::memcpy(this, other, size);
    }

    RARegMask assigned;                  //!< Assigned registers (each bit represents one physical reg).
    RARegMask dirty;                     //!< Dirty registers (spill slot out of sync or no spill slot).
    uint32_t workIds[1 /* ... */];       //!< PhysReg to WorkReg mapping.
  };

  // --------------------------------------------------------------------------
  // [WorkToPhysMap]
  // --------------------------------------------------------------------------

  struct WorkToPhysMap {
    static inline size_t sizeOf(uint32_t count) noexcept {
      return size_t(count) * sizeof(uint8_t);
    }

    inline void reset(uint32_t count) noexcept {
      for (uint32_t i = 0; i < count; i++)
        physIds[i] = kPhysNone;
    }

    inline void copyFrom(const WorkToPhysMap* other, uint32_t count) noexcept {
      size_t size = sizeOf(count);
      if (ASMJIT_LIKELY(size))
        std::memcpy(this, other, size);
    }

    uint8_t physIds[1 /* ... */];        //!< WorkReg to PhysReg mapping
  };

  // --------------------------------------------------------------------------
  // [Construction / Destruction]
  // --------------------------------------------------------------------------

  inline RAAssignment() noexcept {
    _layout.reset();
    resetMaps();
  }

  // --------------------------------------------------------------------------
  // [Init / Reset]
  // --------------------------------------------------------------------------

  inline void initLayout(const RARegCount& physCount, const RAWorkRegs& workRegs) noexcept {
    // Layout must be initialized before data.
    ASMJIT_ASSERT(_physToWorkMap == nullptr);
    ASMJIT_ASSERT(_workToPhysMap == nullptr);

    _layout.physIndex.buildIndexes(physCount);
    _layout.physCount = physCount;
    _layout.physTotal = uint32_t(_layout.physIndex[BaseReg::kGroupVirt - 1]) +
                        uint32_t(_layout.physCount[BaseReg::kGroupVirt - 1]) ;
    _layout.workCount = workRegs.size();
    _layout.workRegs = &workRegs;
  }

  inline void initMaps(PhysToWorkMap* physToWorkMap, WorkToPhysMap* workToPhysMap) noexcept {
    _physToWorkMap = physToWorkMap;
    _workToPhysMap = workToPhysMap;
    for (uint32_t group = 0; group < BaseReg::kGroupVirt; group++)
      _physToWorkIds[group] = physToWorkMap->workIds + _layout.physIndex.get(group);
  }

  inline void resetMaps() noexcept {
    _physToWorkMap = nullptr;
    _workToPhysMap = nullptr;
    for (uint32_t group = 0; group < BaseReg::kGroupVirt; group++)
      _physToWorkIds[group] = nullptr;
  }

  // --------------------------------------------------------------------------
  // [Accessors]
  // --------------------------------------------------------------------------

  inline PhysToWorkMap* physToWorkMap() const noexcept { return _physToWorkMap; }
  inline WorkToPhysMap* workToPhysMap() const noexcept { return _workToPhysMap; }

  inline RARegMask& assigned() noexcept { return _physToWorkMap->assigned; }
  inline const RARegMask& assigned() const noexcept { return _physToWorkMap->assigned; }
  inline uint32_t assigned(uint32_t group) const noexcept { return _physToWorkMap->assigned[group]; }

  inline RARegMask& dirty() noexcept { return _physToWorkMap->dirty; }
  inline const RARegMask& dirty() const noexcept { return _physToWorkMap->dirty; }
  inline uint32_t dirty(uint32_t group) const noexcept { return _physToWorkMap->dirty[group]; }

  inline uint32_t workToPhysId(uint32_t group, uint32_t workId) const noexcept {
    ASMJIT_UNUSED(group);
    ASMJIT_ASSERT(workId != kWorkNone);
    ASMJIT_ASSERT(workId < _layout.workCount);
    return _workToPhysMap->physIds[workId];
  }

  inline uint32_t physToWorkId(uint32_t group, uint32_t physId) const noexcept {
    ASMJIT_ASSERT(physId < Globals::kMaxPhysRegs);
    return _physToWorkIds[group][physId];
  }

  inline bool isPhysAssigned(uint32_t group, uint32_t physId) const noexcept {
    ASMJIT_ASSERT(physId < Globals::kMaxPhysRegs);
    return Support::bitTest(_physToWorkMap->assigned[group], physId);
  }

  inline bool isPhysDirty(uint32_t group, uint32_t physId) const noexcept {
    ASMJIT_ASSERT(physId < Globals::kMaxPhysRegs);
    return Support::bitTest(_physToWorkMap->dirty[group], physId);
  }

  // --------------------------------------------------------------------------
  // [Assignment]
  // --------------------------------------------------------------------------

  // These are low-level allocation helpers that are used to update the current
  // mappings between physical and virt/work registers and also to update masks
  // that represent allocated and dirty registers. These functions don't emit
  // any code; they are only used to update and keep all mappings in sync.

  //! Assign [VirtReg/WorkReg] to a physical register.
  ASMJIT_INLINE void assign(uint32_t group, uint32_t workId, uint32_t physId, uint32_t dirty) noexcept {
    ASMJIT_ASSERT(workToPhysId(group, workId) == kPhysNone);
    ASMJIT_ASSERT(physToWorkId(group, physId) == kWorkNone);
    ASMJIT_ASSERT(!isPhysAssigned(group, physId));
    ASMJIT_ASSERT(!isPhysDirty(group, physId));

    _workToPhysMap->physIds[workId] = uint8_t(physId);
    _physToWorkIds[group][physId] = workId;

    uint32_t regMask = Support::mask(physId);
    _physToWorkMap->assigned[group] |= regMask;
    _physToWorkMap->dirty[group] |= regMask & Support::bitMaskFromBool<uint32_t>(dirty);

    verify();
  }

  //! Reassign [VirtReg/WorkReg] to `dstPhysId` from `srcPhysId`.
  ASMJIT_INLINE void reassign(uint32_t group, uint32_t workId, uint32_t dstPhysId, uint32_t srcPhysId) noexcept {
    ASMJIT_ASSERT(dstPhysId != srcPhysId);
    ASMJIT_ASSERT(workToPhysId(group, workId) == srcPhysId);
    ASMJIT_ASSERT(physToWorkId(group, srcPhysId) == workId);
    ASMJIT_ASSERT(isPhysAssigned(group, srcPhysId) == true);
    ASMJIT_ASSERT(isPhysAssigned(group, dstPhysId) == false);

    _workToPhysMap->physIds[workId] = uint8_t(dstPhysId);
    _physToWorkIds[group][srcPhysId] = kWorkNone;
    _physToWorkIds[group][dstPhysId] = workId;

    uint32_t srcMask = Support::mask(srcPhysId);
    uint32_t dstMask = Support::mask(dstPhysId);

    uint32_t dirty = (_physToWorkMap->dirty[group] & srcMask) != 0;
    uint32_t regMask = dstMask | srcMask;

    _physToWorkMap->assigned[group] ^= regMask;
    _physToWorkMap->dirty[group] ^= regMask & Support::bitMaskFromBool<uint32_t>(dirty);

    verify();
  }

  ASMJIT_INLINE void swap(uint32_t group, uint32_t aWorkId, uint32_t aPhysId, uint32_t bWorkId, uint32_t bPhysId) noexcept {
    ASMJIT_ASSERT(aPhysId != bPhysId);
    ASMJIT_ASSERT(workToPhysId(group, aWorkId) == aPhysId);
    ASMJIT_ASSERT(workToPhysId(group, bWorkId) == bPhysId);
    ASMJIT_ASSERT(physToWorkId(group, aPhysId) == aWorkId);
    ASMJIT_ASSERT(physToWorkId(group, bPhysId) == bWorkId);
    ASMJIT_ASSERT(isPhysAssigned(group, aPhysId));
    ASMJIT_ASSERT(isPhysAssigned(group, bPhysId));

    _workToPhysMap->physIds[aWorkId] = uint8_t(bPhysId);
    _workToPhysMap->physIds[bWorkId] = uint8_t(aPhysId);
    _physToWorkIds[group][aPhysId] = bWorkId;
    _physToWorkIds[group][bPhysId] = aWorkId;

    uint32_t aMask = Support::mask(aPhysId);
    uint32_t bMask = Support::mask(bPhysId);

    uint32_t flipMask = Support::bitMaskFromBool<uint32_t>(
      ((_physToWorkMap->dirty[group] & aMask) != 0) ^
      ((_physToWorkMap->dirty[group] & bMask) != 0));

    uint32_t regMask = aMask | bMask;
    _physToWorkMap->dirty[group] ^= regMask & flipMask;

    verify();
  }

  //! Unassign [VirtReg/WorkReg] from a physical register.
  ASMJIT_INLINE void unassign(uint32_t group, uint32_t workId, uint32_t physId) noexcept {
    ASMJIT_ASSERT(physId < Globals::kMaxPhysRegs);
    ASMJIT_ASSERT(workToPhysId(group, workId) == physId);
    ASMJIT_ASSERT(physToWorkId(group, physId) == workId);
    ASMJIT_ASSERT(isPhysAssigned(group, physId));

    _workToPhysMap->physIds[workId] = kPhysNone;
    _physToWorkIds[group][physId] = kWorkNone;

    uint32_t regMask = Support::mask(physId);
    _physToWorkMap->assigned[group] &= ~regMask;
    _physToWorkMap->dirty[group] &= ~regMask;

    verify();
  }

  inline void makeClean(uint32_t group, uint32_t workId, uint32_t physId) noexcept {
    ASMJIT_UNUSED(workId);

    uint32_t regMask = Support::mask(physId);
    _physToWorkMap->dirty[group] &= ~regMask;
  }

  inline void makeDirty(uint32_t group, uint32_t workId, uint32_t physId) noexcept {
    ASMJIT_UNUSED(workId);

    uint32_t regMask = Support::mask(physId);
    _physToWorkMap->dirty[group] |= regMask;
  }

  // --------------------------------------------------------------------------
  // [Copy / Swap]
  // --------------------------------------------------------------------------

  inline void copyFrom(const PhysToWorkMap* physToWorkMap, const WorkToPhysMap* workToPhysMap) noexcept {
    std::memcpy(_physToWorkMap, physToWorkMap, PhysToWorkMap::sizeOf(_layout.physTotal));
    std::memcpy(_workToPhysMap, workToPhysMap, WorkToPhysMap::sizeOf(_layout.workCount));
  }

  inline void copyFrom(const RAAssignment& other) noexcept {
    copyFrom(other.physToWorkMap(), other.workToPhysMap());
  }

  inline void swapWith(RAAssignment& other) noexcept {
    std::swap(_workToPhysMap, other._workToPhysMap);
    std::swap(_physToWorkMap, other._physToWorkMap);

    for (uint32_t group = 0; group < BaseReg::kGroupVirt; group++)
      std::swap(_physToWorkIds[group], other._physToWorkIds[group]);
  }

  // --------------------------------------------------------------------------
  // [Equals]
  // --------------------------------------------------------------------------

  // Not really useful outside of debugging.
  bool equals(const RAAssignment& other) const noexcept {
    // Layout should always match.
    if (_layout.physIndex != other._layout.physIndex ||
        _layout.physCount != other._layout.physCount ||
        _layout.physTotal != other._layout.physTotal ||
        _layout.workCount != other._layout.workCount ||
        _layout.workRegs  != other._layout.workRegs)
      return false;

    uint32_t physTotal = _layout.physTotal;
    uint32_t workCount = _layout.workCount;

    for (uint32_t physId = 0; physId < physTotal; physId++) {
      uint32_t thisWorkId = _physToWorkMap->workIds[physId];
      uint32_t otherWorkId = other._physToWorkMap->workIds[physId];
      if (thisWorkId != otherWorkId)
        return false;
    }

    for (uint32_t workId = 0; workId < workCount; workId++) {
      uint32_t thisPhysId = _workToPhysMap->physIds[workId];
      uint32_t otherPhysId = other._workToPhysMap->physIds[workId];
      if (thisPhysId != otherPhysId)
        return false;
    }

    if (_physToWorkMap->assigned != other._physToWorkMap->assigned ||
        _physToWorkMap->dirty    != other._physToWorkMap->dirty    )
      return false;

    return true;
  }

  // --------------------------------------------------------------------------
  // [Verify]
  // --------------------------------------------------------------------------

#if defined(ASMJIT_BUILD_DEBUG)
  ASMJIT_NOINLINE void verify() noexcept {
    // Verify WorkToPhysMap.
    {
      for (uint32_t workId = 0; workId < _layout.workCount; workId++) {
        uint32_t physId = _workToPhysMap->physIds[workId];
        if (physId != kPhysNone) {
          const RAWorkReg* workReg = _layout.workRegs->at(workId);
          uint32_t group = workReg->group();
          ASMJIT_ASSERT(_physToWorkIds[group][physId] == workId);
        }
      }
    }

    // Verify PhysToWorkMap.
    {
      for (uint32_t group = 0; group < BaseReg::kGroupVirt; group++) {
        uint32_t physCount = _layout.physCount[group];
        for (uint32_t physId = 0; physId < physCount; physId++) {
          uint32_t workId = _physToWorkIds[group][physId];
          if (workId != kWorkNone) {
            ASMJIT_ASSERT(_workToPhysMap->physIds[workId] == physId);
          }
        }
      }
    }
  }
#else
  inline void verify() noexcept {}
#endif

  // --------------------------------------------------------------------------
  // [Members]
  // --------------------------------------------------------------------------

  Layout _layout;                        //!< Physical registers layout.
  WorkToPhysMap* _workToPhysMap;         //!< WorkReg to PhysReg mapping.
  PhysToWorkMap* _physToWorkMap;         //!< PhysReg to WorkReg mapping and assigned/dirty bits.
  uint32_t* _physToWorkIds[BaseReg::kGroupVirt]; //!< Optimization to translate PhysRegs to WorkRegs faster.
};
//! \}

ASMJIT_END_NAMESPACE

// [Guard]
#endif // !ASMJIT_DISABLE_COMPILER
#endif // _ASMJIT_CORE_RAASSIGNMENT_P_H

```

`Avanguard/AsmJit/asmjit/core/rabuilders_p.h`:

```h
// [AsmJit]
// Complete x86/x64 JIT and Remote Assembler for C++.
//
// [License]
// ZLIB - See LICENSE.md file in the package.

// [Guard]
#ifndef _ASMJIT_CORE_RABUILDERS_P_H
#define _ASMJIT_CORE_RABUILDERS_P_H

#include "../core/build.h"
#ifndef ASMJIT_DISABLE_COMPILER

// [Dependencies]
#include "../core/rapass_p.h"

ASMJIT_BEGIN_NAMESPACE

//! \addtogroup asmjit_core_ra
//! \{

// ============================================================================
// [asmjit::RACFGBuilder]
// ============================================================================

template<typename This>
class RACFGBuilder {
public:
  inline RACFGBuilder(RAPass* pass) noexcept
    : _pass(pass),
      _cc(pass->cc()),
      _curBlock(nullptr),
      _retBlock(nullptr) {}

  inline BaseCompiler* cc() const noexcept { return _cc; }

  Error run() noexcept {
    ASMJIT_RA_LOG_INIT(
      Logger* logger = _pass->debugLogger();
      uint32_t flags = FormatOptions::kFlagPositions;
      RABlock* lastPrintedBlock = nullptr;
      StringBuilderTmp<512> sb;
    );
    ASMJIT_RA_LOG_FORMAT("[RAPass::BuildCFG]\n");

    FuncNode* func = _pass->func();
    BaseNode* node = nullptr;

    // Create entry and exit blocks.
    _retBlock = _pass->newBlockOrExistingAt(func->exitNode(), &node);
    if (ASMJIT_UNLIKELY(!_retBlock))
      return DebugUtils::errored(kErrorNoHeapMemory);
    ASMJIT_PROPAGATE(_pass->addExitBlock(_retBlock));

    if (node != func) {
      _curBlock = _pass->newBlock();
      if (ASMJIT_UNLIKELY(!_curBlock))
        return DebugUtils::errored(kErrorNoHeapMemory);
    }
    else {
      // Function that has no code at all.
      _curBlock = _retBlock;
    }

    ASMJIT_PROPAGATE(_pass->addBlock(_curBlock));

    RARegsStats blockRegStats;
    blockRegStats.reset();
    RAInstBuilder ib;

    bool hasCode = false;
    uint32_t exitLabelId = func->exitNode()->id();

    ASMJIT_RA_LOG_COMPLEX({
      flags |= logger->flags();

      Logging::formatNode(sb, flags, cc(), func);
      logger->logf("  %s\n", sb.data());

      lastPrintedBlock = _curBlock;
      logger->logf("  {#%u}\n", lastPrintedBlock->blockId());
    });

    node = func->next();
    if (ASMJIT_UNLIKELY(!node))
      return DebugUtils::errored(kErrorInvalidState);

    _curBlock->setFirst(node);
    _curBlock->setLast(node);

    for (;;) {
      BaseNode* next = node->next();
      ASMJIT_ASSERT(!node->hasPosition());

      if (node->isInst()) {
        if (ASMJIT_UNLIKELY(!_curBlock)) {
          // If this code is unreachable then it has to be removed.
          ASMJIT_RA_LOG_COMPLEX({
            sb.clear();
            Logging::formatNode(sb, flags, cc(), node);
            logger->logf("  <Removed> %s\n", sb.data());
          });
          cc()->removeNode(node);
          node = next;
          continue;
        }
        else {
          // Handle `InstNode`, `FuncCallNode`, and `FuncRetNode`. All of
          // these share the `InstNode` interface and contain operands.
          hasCode = true;

          ASMJIT_RA_LOG_COMPLEX({
            sb.clear();
            Logging::formatNode(sb, flags, cc(), node);
            logger->logf("    %s\n", sb.data());
          });

          InstNode* inst = node->as<InstNode>();
          uint32_t controlType = BaseInst::kControlNone;

          ib.reset();
          ASMJIT_PROPAGATE(static_cast<This*>(this)->onInst(inst, controlType, ib));

          uint32_t nodeType = inst->type();
          if (nodeType != BaseNode::kNodeInst) {
            if (nodeType == BaseNode::kNodeFuncCall) {
              ASMJIT_PROPAGATE(static_cast<This*>(this)->onCall(inst->as<FuncCallNode>(), ib));
            }
            else if (nodeType == BaseNode::kNodeFuncRet) {
              ASMJIT_PROPAGATE(static_cast<This*>(this)->onRet(inst->as<FuncRetNode>(), ib));
              controlType = BaseInst::kControlReturn;
            }
            else {
              return DebugUtils::errored(kErrorInvalidInstruction);
            }
          }

          ASMJIT_PROPAGATE(_pass->assignRAInst(inst, _curBlock, ib));
          blockRegStats.combineWith(ib._stats);

          if (controlType != BaseInst::kControlNone) {
            // Support for conditional and unconditional jumps.
            if (controlType == BaseInst::kControlJump || controlType == BaseInst::kControlBranch) {
              // Jmp/Jcc/Call/Loop/etc...
              uint32_t opCount = inst->opCount();
              const Operand* opArray = inst->operands();

              // The last operand must be label (this supports also instructions
              // like jecx in explicit form).
              if (ASMJIT_UNLIKELY(opCount == 0 || !opArray[opCount - 1].isLabel()))
                return DebugUtils::errored(kErrorInvalidState);

              LabelNode* cbLabel;
              ASMJIT_PROPAGATE(cc()->labelNodeOf(&cbLabel, opArray[opCount - 1].as<Label>()));

              RABlock* targetBlock = _pass->newBlockOrExistingAt(cbLabel);
              if (ASMJIT_UNLIKELY(!targetBlock))
                return DebugUtils::errored(kErrorNoHeapMemory);

              _curBlock->setLast(node);
              _curBlock->addFlags(RABlock::kFlagHasTerminator);
              _curBlock->makeConstructed(blockRegStats);
              ASMJIT_PROPAGATE(_curBlock->appendSuccessor(targetBlock));

              if (controlType == BaseInst::kControlJump) {
                // Unconditional jump makes the code after the jump unreachable,
                // which will be removed instantly during the CFG construction;
                // as we cannot allocate registers for instructions that are not
                // part of any block. Of course we can leave these instructions
                // as they are, however, that would only postpone the problem as
                // assemblers can't encode instructions that use virtual registers.
                _curBlock = nullptr;
              }
              else {
                node = next;
                if (ASMJIT_UNLIKELY(!node))
                  return DebugUtils::errored(kErrorInvalidState);

                RABlock* consecutiveBlock;
                if (node->type() == BaseNode::kNodeLabel) {
                  if (node->hasPassData()) {
                    consecutiveBlock = node->passData<RABlock>();
                  }
                  else {
                    consecutiveBlock = _pass->newBlock(node);
                    if (ASMJIT_UNLIKELY(!consecutiveBlock))
                      return DebugUtils::errored(kErrorNoHeapMemory);
                    node->setPassData<RABlock>(consecutiveBlock);
                  }
                }
                else {
                  consecutiveBlock = _pass->newBlock(node);
                  if (ASMJIT_UNLIKELY(!consecutiveBlock))
                    return DebugUtils::errored(kErrorNoHeapMemory);
                }

                _curBlock->addFlags(RABlock::kFlagHasConsecutive);
                ASMJIT_PROPAGATE(_curBlock->prependSuccessor(consecutiveBlock));

                _curBlock = consecutiveBlock;
                hasCode = false;
                blockRegStats.reset();

                if (_curBlock->isConstructed())
                  break;
                ASMJIT_PROPAGATE(_pass->addBlock(consecutiveBlock));

                ASMJIT_RA_LOG_COMPLEX({
                  lastPrintedBlock = _curBlock;
                  logger->logf("  {#%u}\n", lastPrintedBlock->blockId());
                });

                continue;
              }
            }

            if (controlType == BaseInst::kControlReturn) {
              _curBlock->setLast(node);
              _curBlock->makeConstructed(blockRegStats);
              ASMJIT_PROPAGATE(_curBlock->appendSuccessor(_retBlock));

              _curBlock = nullptr;
            }
          }
        }
      }
      else if (node->type() == BaseNode::kNodeLabel) {
        if (!_curBlock) {
          // If the current code is unreachable the label makes it reachable again.
          _curBlock = node->passData<RABlock>();
          if (_curBlock) {
            // If the label has a block assigned we can either continue with
            // it or skip it if the block has been constructed already.
            if (_curBlock->isConstructed())
              break;
          }
          else {
            // No block assigned, to create a new one, and assign it.
            _curBlock = _pass->newBlock(node);
            if (ASMJIT_UNLIKELY(!_curBlock))
              return DebugUtils::errored(kErrorNoHeapMemory);
            node->setPassData<RABlock>(_curBlock);
          }

          hasCode = false;
          blockRegStats.reset();
          ASMJIT_PROPAGATE(_pass->addBlock(_curBlock));
        }
        else {
          if (node->hasPassData()) {
            RABlock* consecutive = node->passData<RABlock>();
            if (_curBlock == consecutive) {
              // The label currently processed is part of the current block. This
              // is only possible for multiple labels that are right next to each
              // other, or are separated by non-code nodes like directives and comments.
              if (ASMJIT_UNLIKELY(hasCode))
                return DebugUtils::errored(kErrorInvalidState);
            }
            else {
              // Label makes the current block constructed. There is a chance that the
              // Label is not used, but we don't know that at this point. In the worst
              // case there would be two blocks next to each other, it's just fine.
              ASMJIT_ASSERT(_curBlock->last() != node);
              _curBlock->setLast(node->prev());
              _curBlock->addFlags(RABlock::kFlagHasConsecutive);
              _curBlock->makeConstructed(blockRegStats);

              ASMJIT_PROPAGATE(_curBlock->appendSuccessor(consecutive));
              ASMJIT_PROPAGATE(_pass->addBlock(consecutive));

              _curBlock = consecutive;
              hasCode = false;
              blockRegStats.reset();
            }
          }
          else {
            // First time we see this label.
            if (hasCode) {
              // Cannot continue the current block if it already contains some
              // code. We need to create a new block and make it a successor.
              ASMJIT_ASSERT(_curBlock->last() != node);
              _curBlock->setLast(node->prev());
              _curBlock->addFlags(RABlock::kFlagHasConsecutive);
              _curBlock->makeConstructed(blockRegStats);

              RABlock* consecutive = _pass->newBlock(node);
              if (ASMJIT_UNLIKELY(!consecutive))
                return DebugUtils::errored(kErrorNoHeapMemory);

              ASMJIT_PROPAGATE(_curBlock->appendSuccessor(consecutive));
              ASMJIT_PROPAGATE(_pass->addBlock(consecutive));

              _curBlock = consecutive;
              hasCode = false;
              blockRegStats.reset();
            }

            node->setPassData<RABlock>(_curBlock);
          }
        }

        ASMJIT_RA_LOG_COMPLEX({
          if (_curBlock && _curBlock != lastPrintedBlock) {
            lastPrintedBlock = _curBlock;
            logger->logf("  {#%u}\n", lastPrintedBlock->blockId());
          }

          sb.clear();
          Logging::formatNode(sb, flags, cc(), node);
          logger->logf("  %s\n", sb.data());
        });

        // Unlikely: Assume that the exit label is reached only once per function.
        if (ASMJIT_UNLIKELY(node->as<LabelNode>()->id() == exitLabelId)) {
          _curBlock->setLast(node);
          _curBlock->makeConstructed(blockRegStats);
          ASMJIT_PROPAGATE(_pass->addExitBlock(_curBlock));

          _curBlock = nullptr;
        }
      }
      else {
        ASMJIT_RA_LOG_COMPLEX({
          sb.clear();
          Logging::formatNode(sb, flags, cc(), node);
          logger->logf("    %s\n", sb.data());
        });

        if (node->type() == BaseNode::kNodeSentinel) {
          if (node == func->endNode()) {
            // Make sure we didn't flow here if this is the end of the function sentinel.
            if (ASMJIT_UNLIKELY(_curBlock))
              return DebugUtils::errored(kErrorInvalidState);
            break;
          }
        }
        else if (node->type() == BaseNode::kNodeFunc) {
          // RAPass can only compile a single function at a time. If we
          // encountered a function it must be the current one, bail if not.
          if (ASMJIT_UNLIKELY(node != func))
            return DebugUtils::errored(kErrorInvalidState);
          // PASS if this is the first node.
        }
        else {
          // PASS if this is a non-interesting or unknown node.
        }
      }

      // Advance to the next node.
      node = next;

      // NOTE: We cannot encounter a NULL node, because every function must be
      // terminated by a sentinel (`stop`) node. If we encountered a NULL node it
      // means that something went wrong and this node list is corrupted; bail in
      // such case.
      if (ASMJIT_UNLIKELY(!node))
        return DebugUtils::errored(kErrorInvalidState);
    }

    if (_pass->hasDanglingBlocks())
      return DebugUtils::errored(kErrorInvalidState);

    return kErrorOk;
  }

  RAPass* _pass;
  BaseCompiler* _cc;
  RABlock* _curBlock;
  RABlock* _retBlock;
};

//! \}

ASMJIT_END_NAMESPACE

// [Guard]
#endif // !ASMJIT_DISABLE_COMPILER
#endif // _ASMJIT_CORE_RABUILDERS_P_H

```

`Avanguard/AsmJit/asmjit/core/radefs_p.h`:

```h
// [AsmJit]
// Complete x86/x64 JIT and Remote Assembler for C++.
//
// [License]
// ZLIB - See LICENSE.md file in the package.

// [Guard]
#ifndef _ASMJIT_CORE_RADEFS_P_H
#define _ASMJIT_CORE_RADEFS_P_H

#include "../core/build.h"
#ifndef ASMJIT_DISABLE_COMPILER

// [Dependencies]
#include "../core/compiler.h"
#include "../core/logging.h"
#include "../core/support.h"
#include "../core/zone.h"
#include "../core/zonevector.h"

ASMJIT_BEGIN_NAMESPACE

//! \addtogroup asmjit_core_ra
//! \{

// ============================================================================
// [Logging]
// ============================================================================

#ifndef ASMJIT_DISABLE_LOGGING
# define ASMJIT_RA_LOG_INIT(...) __VA_ARGS__
# define ASMJIT_RA_LOG_FORMAT(...)  \
  do {                              \
    if (logger)                     \
      logger->logf(__VA_ARGS__);    \
  } while (0)
# define ASMJIT_RA_LOG_COMPLEX(...) \
  do {                              \
    if (logger) {                   \
      __VA_ARGS__                   \
    }                               \
  } while (0)
#else
# define ASMJIT_RA_LOG_INIT(...) ((void)0)
# define ASMJIT_RA_LOG_FORMAT(...) ((void)0)
# define ASMJIT_RA_LOG_COMPLEX(...) ((void)0)
#endif

// ============================================================================
// [Forward Declarations]
// ============================================================================

class RAPass;
class RABlock;
struct RAStackSlot;

typedef ZoneVector<RABlock*> RABlocks;
typedef ZoneVector<RAWorkReg*> RAWorkRegs;

// ============================================================================
// [asmjit::RAStrategy]
// ============================================================================

struct RAStrategy {
  enum StrategyType : uint32_t {
    kStrategySimple  = 0,
    kStrategyComplex = 1
  };

  inline RAStrategy() noexcept { reset(); }
  inline void reset() noexcept { std::memset(this, 0, sizeof(*this)); }

  inline uint32_t type() const noexcept { return _type; }
  inline void setType(uint32_t type) noexcept { _type = uint8_t(type); }

  inline bool isSimple() const noexcept { return _type == kStrategySimple; }
  inline bool isComplex() const noexcept { return _type >= kStrategyComplex; }

  uint8_t _type;
};

// ============================================================================
// [asmjit::RAArchTraits]
// ============================================================================

//! Traits.
struct RAArchTraits {
  enum Flags : uint32_t {
    //! Registers can be swapped by a single instruction.
    kHasSwap = 0x01u
  };

  // --------------------------------------------------------------------------
  // [Init / Reset]
  // --------------------------------------------------------------------------

  inline RAArchTraits() noexcept { reset(); }
  inline void reset() noexcept { std::memset(_flags, 0, sizeof(_flags)); }

  // --------------------------------------------------------------------------
  // [Accessors]
  // --------------------------------------------------------------------------

  inline bool hasFlag(uint32_t group, uint32_t flag) const noexcept { return (_flags[group] & flag) != 0; }
  inline bool hasSwap(uint32_t group) const noexcept { return hasFlag(group, kHasSwap); }

  inline uint8_t& operator[](uint32_t group) noexcept {
    ASMJIT_ASSERT(group < BaseReg::kGroupVirt);
    return _flags[group];
  }

  inline const uint8_t& operator[](uint32_t group) const noexcept {
    ASMJIT_ASSERT(group < BaseReg::kGroupVirt);
    return _flags[group];
  }

  // --------------------------------------------------------------------------
  // [Members]
  // --------------------------------------------------------------------------

  uint8_t _flags[BaseReg::kGroupVirt];
};

// ============================================================================
// [asmjit::RARegCount]
// ============================================================================

//! Count of virtual or physical registers per group.
//!
//! NOTE: This class uses 8-bit integers to represent counters, it's only used
//! in places where this is sufficient - for example total count of machine's
//! physical registers, count of virtual registers per instruction, etc. There
//! is also `RALiveCount`, which uses 32-bit integers and is indeed much safer.
struct RARegCount {
  // --------------------------------------------------------------------------
  // [Reset]
  // --------------------------------------------------------------------------

  //! Reset all counters to zero.
  inline void reset() noexcept { _packed = 0; }

  // --------------------------------------------------------------------------
  // [Operators]
  // --------------------------------------------------------------------------

  //! Get register count by a register `group`.
  inline uint32_t get(uint32_t group) const noexcept {
    ASMJIT_ASSERT(group < BaseReg::kGroupVirt);

    uint32_t shift = Support::byteShiftOfDWordStruct(group);
    return (_packed >> shift) & uint32_t(0xFF);
  }

  //! Set register count by a register `group`.
  inline void set(uint32_t group, uint32_t n) noexcept {
    ASMJIT_ASSERT(group < BaseReg::kGroupVirt);
    ASMJIT_ASSERT(n <= 0xFF);

    uint32_t shift = Support::byteShiftOfDWordStruct(group);
    _packed = (_packed & ~uint32_t(0xFF << shift)) + (n << shift);
  }

  //! Add register count by a register `group`.
  inline void add(uint32_t group, uint32_t n = 1) noexcept {
    ASMJIT_ASSERT(group < BaseReg::kGroupVirt);
    ASMJIT_ASSERT(0xFF - uint32_t(_regs[group]) >= n);

    uint32_t shift = Support::byteShiftOfDWordStruct(group);
    _packed += n << shift;
  }

  // --------------------------------------------------------------------------
  // [Operator OVerload]
  // --------------------------------------------------------------------------

  inline uint8_t& operator[](uint32_t index) noexcept {
    ASMJIT_ASSERT(index < BaseReg::kGroupVirt);
    return _regs[index];
  }

  inline const uint8_t& operator[](uint32_t index) const noexcept {
    ASMJIT_ASSERT(index < BaseReg::kGroupVirt);
    return _regs[index];
  }

  inline RARegCount& operator=(const RARegCount& other) noexcept = default;

  inline bool operator==(const RARegCount& other) const noexcept { return _packed == other._packed; }
  inline bool operator!=(const RARegCount& other) const noexcept { return _packed != other._packed; }

  // --------------------------------------------------------------------------
  // [Members]
  // --------------------------------------------------------------------------

  union {
    uint8_t _regs[4];
    uint32_t _packed;
  };
};

struct RARegIndex : public RARegCount {
  //! Build register indexes based on the given `count` of registers.
  inline void buildIndexes(const RARegCount& count) noexcept {
    uint32_t x = uint32_t(count._regs[0]);
    uint32_t y = uint32_t(count._regs[1]) + x;
    uint32_t z = uint32_t(count._regs[2]) + y;

    ASMJIT_ASSERT(y <= 0xFF);
    ASMJIT_ASSERT(z <= 0xFF);
    _packed = Support::bytepack32_4x8(0, x, y, z);
  }
};

// ============================================================================
// [asmjit::RARegMask]
// ============================================================================

//! Registers mask.
struct RARegMask {
  // --------------------------------------------------------------------------
  // [Consturction / Destruction]
  // --------------------------------------------------------------------------

  inline void init(const RARegMask& other) noexcept {
    for (uint32_t i = 0; i < BaseReg::kGroupVirt; i++)
      _masks[i] = other._masks[i];
  }

  //! Reset all register masks to zero.
  inline void reset() noexcept {
    for (uint32_t i = 0; i < BaseReg::kGroupVirt; i++)
      _masks[i] = 0;
  }

  // --------------------------------------------------------------------------
  // [IsEmpty / Has]
  // --------------------------------------------------------------------------

  //! Get whether all register masks are zero (empty).
  inline bool empty() const noexcept {
    uint32_t m = 0;
    for (uint32_t i = 0; i < BaseReg::kGroupVirt; i++)
      m |= _masks[i];
    return m == 0;
  }

  inline bool has(uint32_t group, uint32_t mask = 0xFFFFFFFFu) const noexcept {
    ASMJIT_ASSERT(group < BaseReg::kGroupVirt);
    return (_masks[group] & mask) != 0;
  }

  // --------------------------------------------------------------------------
  // [Operators]
  // --------------------------------------------------------------------------

  template<class Operator>
  inline void op(const RARegMask& other) noexcept {
    for (uint32_t i = 0; i < BaseReg::kGroupVirt; i++)
      _masks[i] = Operator::op(_masks[i], other._masks[i]);
  }

  template<class Operator>
  inline void op(uint32_t group, uint32_t input) noexcept {
    _masks[group] = Operator::op(_masks[group], input);
  }

  // --------------------------------------------------------------------------
  // [Operator Overload]
  // --------------------------------------------------------------------------

  inline uint32_t& operator[](uint32_t index) noexcept {
    ASMJIT_ASSERT(index < BaseReg::kGroupVirt);
    return _masks[index];
  }

  inline const uint32_t& operator[](uint32_t index) const noexcept {
    ASMJIT_ASSERT(index < BaseReg::kGroupVirt);
    return _masks[index];
  }

  inline RARegMask& operator=(const RARegMask& other) noexcept = default;

  inline bool operator==(const RARegMask& other) const noexcept {
    return _masks[0] == other._masks[0] &&
           _masks[1] == other._masks[1] &&
           _masks[2] == other._masks[2] &&
           _masks[3] == other._masks[3] ;
  }

  inline bool operator!=(const RARegMask& other) const noexcept {
    return !operator==(other);
  }

  // --------------------------------------------------------------------------
  // [Members]
  // --------------------------------------------------------------------------

  uint32_t _masks[BaseReg::kGroupVirt];
};

// ============================================================================
// [asmjit::RARegsStats]
// ============================================================================

//! Information associated with each instruction, propagated to blocks, loops,
//! and the whole function. This information can be used to do minor decisions
//! before the register allocator tries to do its job. For example to use fast
//! register allocation inside a block or loop it cannot have clobbered and/or
//! fixed registers, etc...
struct RARegsStats {
  enum Index : uint32_t {
    kIndexUsed       = 0,
    kIndexFixed      = 8,
    kIndexClobbered  = 16
  };

  enum Mask : uint32_t {
    kMaskUsed        = 0xFFu << kIndexUsed,
    kMaskFixed       = 0xFFu << kIndexFixed,
    kMaskClobbered   = 0xFFu << kIndexClobbered
  };

  inline void reset() noexcept { _packed = 0; }
  inline void combineWith(const RARegsStats& other) noexcept { _packed |= other._packed; }

  inline bool hasUsed() const noexcept { return (_packed & kMaskUsed) != 0u; }
  inline bool hasUsed(uint32_t group) const noexcept { return (_packed & Support::mask(kIndexUsed + group)) != 0u; }
  inline void makeUsed(uint32_t group) noexcept { _packed |= Support::mask(kIndexUsed + group); }

  inline bool hasFixed() const noexcept { return (_packed & kMaskFixed) != 0u; }
  inline bool hasFixed(uint32_t group) const noexcept { return (_packed & Support::mask(kIndexFixed + group)) != 0u; }
  inline void makeFixed(uint32_t group) noexcept { _packed |= Support::mask(kIndexFixed + group); }

  inline bool hasClobbered() const noexcept { return (_packed & kMaskClobbered) != 0u; }
  inline bool hasClobbered(uint32_t group) const noexcept { return (_packed & Support::mask(kIndexClobbered + group)) != 0u; }
  inline void makeClobbered(uint32_t group) noexcept { _packed |= Support::mask(kIndexClobbered + group); }

  uint32_t _packed;
};

// ============================================================================
// [asmjit::RALiveCount]
// ============================================================================

//! Count of live register, per group.
class RALiveCount {
public:
  // --------------------------------------------------------------------------
  // [Construction / Destruction]
  // --------------------------------------------------------------------------

  inline RALiveCount() noexcept { reset(); }
  inline RALiveCount(const RALiveCount& other) noexcept { init(other); }

  inline void init(const RALiveCount& other) noexcept {
    for (uint32_t group = 0; group < BaseReg::kGroupVirt; group++)
      n[group] = other.n[group];
  }

  inline void reset() noexcept {
    for (uint32_t group = 0; group < BaseReg::kGroupVirt; group++)
      n[group] = 0;
  }

  // --------------------------------------------------------------------------
  // [Ops]
  // --------------------------------------------------------------------------

  template<class Operator>
  inline void op(const RALiveCount& other) noexcept {
    for (uint32_t group = 0; group < BaseReg::kGroupVirt; group++)
      n[group] = Operator::op(n[group], other.n[group]);
  }

  inline RALiveCount& operator=(const RALiveCount& other) noexcept = default;

  inline uint32_t& operator[](uint32_t group) noexcept { return n[group]; }
  inline const uint32_t& operator[](uint32_t group) const noexcept { return n[group]; }

  // --------------------------------------------------------------------------
  // [Members]
  // --------------------------------------------------------------------------

  uint32_t n[BaseReg::kGroupVirt];
};

// ============================================================================
// [asmjit::LiveInterval]
// ============================================================================

struct LiveInterval {
  enum Misc : uint32_t {
    kNaN = 0,
    kInf = 0xFFFFFFFFu
  };

  // --------------------------------------------------------------------------
  // [Construction / Destruction]
  // --------------------------------------------------------------------------

  inline LiveInterval() noexcept : a(0), b(0) {}
  inline LiveInterval(uint32_t a, uint32_t b) noexcept : a(a), b(b) {}
  inline LiveInterval(const LiveInterval& other) noexcept : a(other.a), b(other.b) {}

  inline void init(uint32_t aVal, uint32_t bVal) noexcept {
    a = aVal;
    b = bVal;
  }
  inline void init(const LiveInterval& other) noexcept { init(other.a, other.b); }
  inline void reset() noexcept { init(0, 0); }

  // --------------------------------------------------------------------------
  // [Accessors]
  // --------------------------------------------------------------------------

  inline bool isValid() const noexcept { return a < b; }
  inline uint32_t width() const noexcept { return b - a; }

  // --------------------------------------------------------------------------
  // [Members]
  // --------------------------------------------------------------------------

  uint32_t a, b;
};

// ============================================================================
// [asmjit::RALiveSpan<T>]
// ============================================================================

template<typename T>
class RALiveSpan : public LiveInterval, public T {
public:
  typedef T DataType;

  // --------------------------------------------------------------------------
  // [Construction / Destruction]
  // --------------------------------------------------------------------------

  inline RALiveSpan() noexcept : LiveInterval(), T() {}
  inline RALiveSpan(const RALiveSpan<T>& other) noexcept : LiveInterval(other), T() {}
  inline RALiveSpan(const LiveInterval& interval, const T& data) noexcept : LiveInterval(interval), T(data) {}
  inline RALiveSpan(uint32_t a, uint32_t b) noexcept : LiveInterval(a, b), T() {}
  inline RALiveSpan(uint32_t a, uint32_t b, const T& data) noexcept : LiveInterval(a, b), T(data) {}

  inline void init(const RALiveSpan<T>& other) noexcept {
    LiveInterval::init(static_cast<const LiveInterval&>(other));
    T::init(static_cast<const T&>(other));
  }

  inline void init(const RALiveSpan<T>& span, const T& data) noexcept {
    LiveInterval::init(static_cast<const LiveInterval&>(span));
    T::init(data);
  }

  inline void init(const LiveInterval& interval, const T& data) noexcept {
    LiveInterval::init(interval);
    T::init(data);
  }
};

// ============================================================================
// [asmjit::RALiveSpans<T>]
// ============================================================================

template<typename T>
class RALiveSpans {
public:
  ASMJIT_NONCOPYABLE(RALiveSpans<T>)

  typedef typename T::DataType DataType;

  // --------------------------------------------------------------------------
  // [Construction / Destruction]
  // --------------------------------------------------------------------------

  inline RALiveSpans() noexcept : _data() {}

  // --------------------------------------------------------------------------
  // [Reset]
  // --------------------------------------------------------------------------

  inline void reset() noexcept { _data.reset(); }
  inline void release(ZoneAllocator* allocator) noexcept { _data.release(allocator); }

  // --------------------------------------------------------------------------
  // [Interface]
  // --------------------------------------------------------------------------

  inline bool empty() const noexcept { return _data.empty(); }
  inline uint32_t size() const noexcept { return _data.size(); }

  inline T* data() noexcept { return _data.data(); }
  inline const T* data() const noexcept { return _data.data(); }

  inline void swap(RALiveSpans<T>& other) noexcept { _data.swap(other._data); }

  inline bool isOpen() const noexcept {
    uint32_t size = _data.size();
    return size > 0 && _data[size - 1].b == LiveInterval::kInf;
  }

  //! Open the current live span.
  ASMJIT_INLINE Error openAt(ZoneAllocator* allocator, uint32_t start, uint32_t end) noexcept {
    bool wasOpen;
    return openAt(allocator, start, end, wasOpen);
  }

  ASMJIT_INLINE Error openAt(ZoneAllocator* allocator, uint32_t start, uint32_t end, bool& wasOpen) noexcept {
    uint32_t size = _data.size();
    wasOpen = false;

    if (size > 0) {
      T& last = _data[size - 1];
      if (last.b >= start) {
        wasOpen = last.b > start;
        last.b = end;
        return kErrorOk;
      }
    }

    return _data.append(allocator, T(start, end));
  }

  inline void closeAt(uint32_t end) noexcept {
    ASMJIT_ASSERT(!empty());

    uint32_t size = _data.size();
    _data[size - 1].b = end;
  }

  //! Returns the sum of width of all spans.
  //!
  //! NOTE: Don't overuse, this iterates over all spans so it's O(N).
  //! It should be only called once and then cached.
  ASMJIT_INLINE uint32_t width() const noexcept {
    uint32_t width = 0;
    for (const T& span : _data)
      width += span.width();
    return width;
  }

  inline T& operator[](uint32_t index) noexcept { return _data[index]; }
  inline const T& operator[](uint32_t index) const noexcept { return _data[index]; }

  inline bool intersects(const RALiveSpans<T>& other) const noexcept {
    return intersects(*this, other);
  }

  ASMJIT_INLINE Error nonOverlappingUnionOf(ZoneAllocator* allocator, const RALiveSpans<T>& x, const RALiveSpans<T>& y, const DataType& yData) noexcept {
    uint32_t finalSize = x.size() + y.size();
    ASMJIT_PROPAGATE(_data.reserve(allocator, finalSize));

    T* dstPtr = _data.data();
    const T* xSpan = x.data();
    const T* ySpan = y.data();

    const T* xEnd = xSpan + x.size();
    const T* yEnd = ySpan + y.size();

    // Loop until we have intersection or either `xSpan == xEnd` or `ySpan == yEnd`,
    // which means that there is no intersection. We advance either `xSpan` or `ySpan`
    // depending on their ranges.
    if (xSpan != xEnd && ySpan != yEnd) {
      uint32_t xa, ya;
      xa = xSpan->a;
      for (;;) {
        while (ySpan->b <= xa) {
          dstPtr->init(*ySpan, yData);
          dstPtr++;
          if (++ySpan == yEnd)
            goto Done;
        }

        ya = ySpan->a;
        while (xSpan->b <= ya) {
          *dstPtr++ = *xSpan;
          if (++xSpan == xEnd)
            goto Done;
        }

        // We know that `xSpan->b > ySpan->a`, so check if `ySpan->b > xSpan->a`.
        xa = xSpan->a;
        if (ySpan->b > xa)
          return 0xFFFFFFFFu;
      }
    }

  Done:
    while (xSpan != xEnd) {
      *dstPtr++ = *xSpan++;
    }

    while (ySpan != yEnd) {
      dstPtr->init(*ySpan, yData);
      dstPtr++;
      ySpan++;
    }

    _data._setEndPtr(dstPtr);
    return kErrorOk;
  }

  static ASMJIT_INLINE bool intersects(const RALiveSpans<T>& x, const RALiveSpans<T>& y) noexcept {
    const T* xSpan = x.data();
    const T* ySpan = y.data();

    const T* xEnd = xSpan + x.size();
    const T* yEnd = ySpan + y.size();

    // Loop until we have intersection or either `xSpan == xEnd` or `ySpan == yEnd`,
    // which means that there is no intersection. We advance either `xSpan` or `ySpan`
    // depending on their end positions.
    if (xSpan == xEnd || ySpan == yEnd)
      return false;

    uint32_t xa, ya;
    xa = xSpan->a;

    for (;;) {
      while (ySpan->b <= xa)
        if (++ySpan == yEnd)
          return false;

      ya = ySpan->a;
      while (xSpan->b <= ya)
        if (++xSpan == xEnd)
          return false;

      // We know that `xSpan->b > ySpan->a`, so check if `ySpan->b > xSpan->a`.
      xa = xSpan->a;
      if (ySpan->b > xa)
        return true;
    }
  }

  // --------------------------------------------------------------------------
  // [Members]
  // --------------------------------------------------------------------------

  ZoneVector<T> _data;
};

// ============================================================================
// [asmjit::RALiveStats]
// ============================================================================

//! Statistics about a register liveness.
class RALiveStats {
public:
  inline RALiveStats()
    : _width(0),
      _freq(0.0f) {}

  // --------------------------------------------------------------------------
  // [Accessors]
  // --------------------------------------------------------------------------

  inline uint32_t width() const noexcept { return _width; }
  inline float freq() const noexcept { return _freq; }

  // --------------------------------------------------------------------------
  // [Members]
  // --------------------------------------------------------------------------

  uint32_t _width;
  float _freq;
};

// ============================================================================
// [asmjit::LiveRegData]
// ============================================================================

struct LiveRegData {
  inline LiveRegData() noexcept : id(BaseReg::kIdBad) {}
  inline explicit LiveRegData(uint32_t id) noexcept : id(id) {}
  inline explicit LiveRegData(const LiveRegData& other) noexcept : id(other.id) {}

  inline void init(const LiveRegData& other) noexcept { id = other.id; }

  inline bool operator==(const LiveRegData& other) const noexcept { return id == other.id; }
  inline bool operator!=(const LiveRegData& other) const noexcept { return id != other.id; }

  // --------------------------------------------------------------------------
  // [Members]
  // --------------------------------------------------------------------------

  uint32_t id;
};

typedef RALiveSpan<LiveRegData> LiveRegSpan;
typedef RALiveSpans<LiveRegSpan> LiveRegSpans;

// ============================================================================
// [asmjit::RATiedReg]
// ============================================================================

//! Tied register merges one ore more register operand into a single entity. It
//! contains information about its access (Read|Write) and allocation slots
//! (Use|Out) that are used by the register allocator and liveness analysis.
struct RATiedReg {
  //! Flags.
  //!
  //! Register access information is encoded in 4 flags in total:
  //!
  //!   - `kRead`  - Register is Read    (ReadWrite if combined with `kWrite`).
  //!   - `kWrite` - Register is Written (ReadWrite if combined with `kRead`).
  //!   - `kUse`   - Encoded as Read or ReadWrite.
  //!   - `kOut`   - Encoded as WriteOnly.
  //!
  //! Let's describe all of these on two X86 instructions:
  //!
  //!   - ADD x{R|W|Use},  x{R|Use}              -> {x:R|W|Use            }
  //!   - LEA x{  W|Out}, [x{R|Use} + x{R|Out}]  -> {x:R|W|Use|Out        }
  //!   - ADD x{R|W|Use},  y{R|Use}              -> {x:R|W|Use     y:R|Use}
  //!   - LEA x{  W|Out}, [x{R|Use} + y{R|Out}]  -> {x:R|W|Use|Out y:R|Use}
  //!
  //! It should be obvious from the example above how these flags get created.
  //! Each operand contains READ/WRITE information, which is then merged to
  //! RATiedReg's flags. However, we also need to represent the possitility to
  //! use see the operation as two independent operations - USE and OUT, because
  //! the register allocator will first allocate USE registers, and then assign
  //! OUT registers independently of USE registers.
  enum Flags : uint32_t {
    kRead        = OpInfo::kRead,        //!< Register is read.
    kWrite       = OpInfo::kWrite,       //!< Register is written.
    kRW          = OpInfo::kRW,          //!< Register read and written.
    kUse         = OpInfo::kUse,         //!< Register has a USE slot (Read/ReadWrite).
    kOut         = OpInfo::kOut,         //!< Register has an OUT slot (WriteOnly).

    kUseFixed    = 0x00000010u,          //!< Register has a fixed USE slot.
    kOutFixed    = 0x00000020u,          //!< Register has a fixed OUT slot.

    // TODO: Maybe we don't need these at all.
    kUseCall     = 0x00000040u,          //!< Function-call register argument (USE).
    kOutCall     = 0x00000080u,          //!< Function-call register return (OUT).

    kUseDone     = 0x00000100u,          //!< Register USE slot has been allocated.
    kOutDone     = 0x00000200u,          //!< Register OUT slot has been allocated

    kLast        = 0x00000400u,          //!< Last occurrence of this VirtReg in basic block.
    kKill        = 0x00000800u,          //!< Kill this VirtReg after use.

    // Architecture specific flags are used during RATiedReg building to ensure
    // that architecture-specific constraints are handled properly. These flags
    // are not really needed after RATiedReg[] is built and copied to `RAInst`.

    kX86Gpb      = 0x00001000u           //!< This tied references GPB-LO or GPB-HI.
  };

  // --------------------------------------------------------------------------
  // [Init / Reset]
  // --------------------------------------------------------------------------

  ASMJIT_INLINE void init(uint32_t workId, uint32_t flags, uint32_t allocableRegs, uint32_t useId, uint32_t useRewriteMask, uint32_t outId, uint32_t outRewriteMask) noexcept {
    _workId = workId;
    _flags = flags;
    _allocableRegs = allocableRegs;
    _useRewriteMask = useRewriteMask;
    _outRewriteMask = outRewriteMask;
    _refCount = 1;
    _useId = uint8_t(useId);
    _outId = uint8_t(outId);
    _reserved = 0;
  }

  // --------------------------------------------------------------------------
  // [Accessors]
  // --------------------------------------------------------------------------

  //! Get the associated WorkReg id.
  inline uint32_t workId() const noexcept { return _workId; }

  //! Check if the given `flag` is set, see `Flags`.
  inline bool hasFlag(uint32_t flag) const noexcept { return (_flags & flag) != 0; }

  //! Get tied register flags, see `Flags`.
  inline uint32_t flags() const noexcept { return _flags; }
  //! Add tied register flags, see `Flags`.
  inline void addFlags(uint32_t flags) noexcept { _flags |= flags; }

  //! Get whether the register is read (writes `true` also if it's Read/Write).
  inline bool isRead() const noexcept { return hasFlag(kRead); }
  //! Get whether the register is written (writes `true` also if it's Read/Write).
  inline bool isWrite() const noexcept { return hasFlag(kWrite); }
  //! Get whether the register is read only.
  inline bool isReadOnly() const noexcept { return (_flags & kRW) == kRead; }
  //! Get whether the register is write only.
  inline bool isWriteOnly() const noexcept { return (_flags & kRW) == kWrite; }
  //! Get whether the register is read and written.
  inline bool isReadWrite() const noexcept { return (_flags & kRW) == kRW; }

  //! Get whether the tied register has use operand (Read/ReadWrite).
  inline bool isUse() const noexcept { return hasFlag(kUse); }
  //! Get whether the tied register has out operand (Write).
  inline bool isOut() const noexcept { return hasFlag(kOut); }

  inline void makeReadOnly() noexcept {
    _flags = (_flags & ~(kOut | kWrite)) | kUse;
    _useRewriteMask |= _outRewriteMask;
    _outRewriteMask = 0;
  }

  inline void makeWriteOnly() noexcept {
    _flags = (_flags & ~(kUse | kRead)) | kOut;
    _outRewriteMask |= _useRewriteMask;
    _useRewriteMask = 0;
  }

  //! Get whether this register (and the instruction it's part of) appears last in the basic block.
  inline bool isLast() const noexcept { return hasFlag(kLast); }
  //! Get whether this register should be killed after USEd and/or OUTed.
  inline bool isKill() const noexcept { return hasFlag(kKill); }

  //! Get whether this register is OUT or KILL (used internally by local register allocator).
  inline bool isOutOrKill() const noexcept { return hasFlag(kOut | kKill); }

  inline uint32_t allocableRegs() const noexcept { return _allocableRegs; }

  inline uint32_t refCount() const noexcept { return _refCount; }
  inline void addRefCount(uint32_t n = 1) noexcept { _refCount = uint8_t(_refCount + n); }

  //! Get whether the register must be allocated to a fixed physical register before it's used.
  inline bool hasUseId() const noexcept { return _useId != BaseReg::kIdBad; }
  //! Get whether the register must be allocated to a fixed physical register before it's written.
  inline bool hasOutId() const noexcept { return _outId != BaseReg::kIdBad; }

  //! Get a physical register used for 'use' operation.
  inline uint32_t useId() const noexcept { return _useId; }
  //! Get a physical register used for 'out' operation.
  inline uint32_t outId() const noexcept { return _outId; }

  inline uint32_t useRewriteMask() const noexcept { return _useRewriteMask; }
  inline uint32_t outRewriteMask() const noexcept { return _outRewriteMask; }

  //! Set a physical register used for 'use' operation.
  inline void setUseId(uint32_t index) noexcept { _useId = uint8_t(index); }
  //! Set a physical register used for 'out' operation.
  inline void setOutId(uint32_t index) noexcept { _outId = uint8_t(index); }

  inline bool isUseDone() const noexcept { return hasFlag(kUseDone); }
  inline bool isOutDone() const noexcept { return hasFlag(kUseDone); }

  inline void markUseDone() noexcept { addFlags(kUseDone); }
  inline void markOutDone() noexcept { addFlags(kUseDone); }

  // --------------------------------------------------------------------------
  // [Operator Overload]
  // --------------------------------------------------------------------------

  inline RATiedReg& operator=(const RATiedReg& other) noexcept = default;

  // --------------------------------------------------------------------------
  // [Members]
  // --------------------------------------------------------------------------

  uint32_t _workId;                      //!< WorkReg id.
  uint32_t _flags;                       //!< Allocation flags.
  uint32_t _allocableRegs;               //!< Registers where input {R|X} can be allocated to.
  uint32_t _useRewriteMask;              //!< Indexes used to rewrite USE regs.
  uint32_t _outRewriteMask;              //!< Indexes used to rewrite OUT regs.

  union {
    struct {
      uint8_t _refCount;                 //!< How many times the VirtReg is referenced in all operands.
      uint8_t _useId;                    //!< Physical register for use operation (ReadOnly / ReadWrite).
      uint8_t _outId;                    //!< Physical register for out operation (WriteOnly).
      uint8_t _reserved;                 //!< Index of OUT operand or 0xFF if none.
    };
    uint32_t _packed;                    //!< Packed data.
  };
};

// ============================================================================
// [asmjit::RAWorkReg]
// ============================================================================

class RAWorkReg {
public:
  ASMJIT_NONCOPYABLE(RAWorkReg)

  enum Ids : uint32_t {
    kIdNone               = 0xFFFFFFFFu
  };

  enum Flags : uint32_t {
    kFlagCoalesced        = 0x00000001u, //!< Has been coalesced to another WorkReg.
    kFlagStackUsed        = 0x00000002u, //!< Stack slot has to be allocated.
    kFlagStackPreferred   = 0x00000004u, //!< Stack allocation is preferred.
    kFlagStackArgToStack  = 0x00000008u, //!< Marked for stack argument reassignment.

    // TODO: Used?
    kFlagDirtyStats       = 0x80000000u
  };

  enum ArgIndex : uint32_t {
    kNoArgIndex      = 0xFFu
  };

  // --------------------------------------------------------------------------
  // [Construction / Destruction]
  // --------------------------------------------------------------------------

  ASMJIT_INLINE RAWorkReg(VirtReg* vReg, uint32_t workId) noexcept
    : _workId(workId),
      _virtId(vReg->id()),
      _virtReg(vReg),
      _tiedReg(nullptr),
      _stackSlot(nullptr),
      _info(vReg->info()),
      _flags(kFlagDirtyStats),
      _allocatedMask(0),
      _argIndex(kNoArgIndex),
      _homeId(BaseReg::kIdBad),
      _liveSpans(),
      _liveStats(),
      _refs() {}

  // --------------------------------------------------------------------------
  // [Accessors]
  // --------------------------------------------------------------------------

  inline uint32_t workId() const noexcept { return _workId; }
  inline uint32_t virtId() const noexcept { return _virtId; }

  inline const char* name() const noexcept { return _virtReg->name(); }
  inline uint32_t nameSize() const noexcept { return _virtReg->nameSize(); }

  inline uint32_t typeId() const noexcept { return _virtReg->typeId(); }

  inline bool hasFlag(uint32_t flag) const noexcept { return (_flags & flag) != 0; }
  inline uint32_t flags() const noexcept { return _flags; }
  inline void addFlags(uint32_t flags) noexcept { _flags |= flags; }

  inline bool isStackUsed() const noexcept { return hasFlag(kFlagStackUsed); }
  inline void markStackUsed() noexcept { addFlags(kFlagStackUsed); }

  inline bool isStackPreferred() const noexcept { return hasFlag(kFlagStackPreferred); }
  inline void markStackPreferred() noexcept { addFlags(kFlagStackPreferred); }

  //! Get whether this RAWorkReg has been coalesced with another one (cannot be used anymore).
  inline bool isCoalesced() const noexcept { return hasFlag(kFlagCoalesced); }

  inline const RegInfo& info() const noexcept { return _info; }
  inline uint32_t group() const noexcept { return _info.group(); }

  inline VirtReg* virtReg() const noexcept { return _virtReg; }

  inline bool hasTiedReg() const noexcept { return _tiedReg != nullptr; }
  inline RATiedReg* tiedReg() const noexcept { return _tiedReg; }
  inline void setTiedReg(RATiedReg* tiedReg) noexcept { _tiedReg = tiedReg; }
  inline void resetTiedReg() noexcept { _tiedReg = nullptr; }

  inline bool hasStackSlot() const noexcept { return _stackSlot != nullptr; }
  inline RAStackSlot* stackSlot() const noexcept { return _stackSlot; }

  inline LiveRegSpans& liveSpans() noexcept { return _liveSpans; }
  inline const LiveRegSpans& liveSpans() const noexcept { return _liveSpans; }

  inline RALiveStats& liveStats() noexcept { return _liveStats; }
  inline const RALiveStats& liveStats() const noexcept { return _liveStats; }

  inline bool hasArgIndex() const noexcept { return _argIndex != kNoArgIndex; }
  inline uint32_t argIndex() const noexcept { return _argIndex; }
  inline void setArgIndex(uint32_t index) noexcept { _argIndex = uint8_t(index); }

  inline bool hasHomeId() const noexcept { return _homeId != BaseReg::kIdBad; }
  inline uint32_t homeId() const noexcept { return _homeId; }
  inline void setHomeId(uint32_t physId) noexcept { _homeId = uint8_t(physId); }

  inline uint32_t allocatedMask() const noexcept { return _allocatedMask; }
  inline void addAllocatedMask(uint32_t mask) noexcept { _allocatedMask |= mask; }

  // --------------------------------------------------------------------------
  // [Members]
  // --------------------------------------------------------------------------

  uint32_t _workId;                      //!< RAPass specific ID used during analysis and allocation.
  uint32_t _virtId;                      //!< Copy of ID used by `VirtReg`.

  VirtReg* _virtReg;                     //!< Permanent association with `VirtReg`.
  RATiedReg* _tiedReg;                   //!< Temporary association with `RATiedReg`.
  RAStackSlot* _stackSlot;               //!< Stack slot associated with the register.

  RegInfo _info;                         //!< Copy of a signature used by `VirtReg`.
  uint32_t _flags;                       //!< RAPass specific flags used during analysis and allocation.
  uint32_t _allocatedMask;               //!< IDs of all physical registers this WorkReg has been allocated to.

  uint8_t _argIndex;                     //!< Argument index (or kNoStackArgIndex if none).
  uint8_t _homeId;                       //!< Global home register ID (if any).

  LiveRegSpans _liveSpans;               //!< Live spans of the `VirtReg`.
  RALiveStats _liveStats;                //!< Live statistics.

  ZoneVector<BaseNode*> _refs;           //!< All nodes that read/write this VirtReg/WorkReg.
  ZoneVector<BaseNode*> _writes;         //!< All nodes that write to this VirtReg/WorkReg.
};

//! \}

ASMJIT_END_NAMESPACE

// [Guard]
#endif // !ASMJIT_DISABLE_COMPILER
#endif // _ASMJIT_CORE_RADEFS_P_H

```

`Avanguard/AsmJit/asmjit/core/ralocal_p.h`:

```h
// [AsmJit]
// Complete x86/x64 JIT and Remote Assembler for C++.
//
// [License]
// ZLIB - See LICENSE.md file in the package.

// [Guard]
#ifndef _ASMJIT_CORE_RALOCAL_P_H
#define _ASMJIT_CORE_RALOCAL_P_H

#include "../core/build.h"
#ifndef ASMJIT_DISABLE_COMPILER

// [Dependencies]
#include "../core/raassignment_p.h"
#include "../core/radefs_p.h"
#include "../core/rapass_p.h"
#include "../core/support.h"

ASMJIT_BEGIN_NAMESPACE

//! \addtogroup asmjit_core_ra
//! \{

// ============================================================================
// [asmjit::RALocalAllocator]
// ============================================================================

//! Local register allocator.
class RALocalAllocator {
public:
  ASMJIT_NONCOPYABLE(RALocalAllocator)

  typedef RAAssignment::PhysToWorkMap PhysToWorkMap;
  typedef RAAssignment::WorkToPhysMap WorkToPhysMap;

  // --------------------------------------------------------------------------
  // [Init / Reset]
  // --------------------------------------------------------------------------

  inline RALocalAllocator(RAPass* pass) noexcept
    : _pass(pass),
      _cc(pass->cc()),
      _archTraits(pass->_archTraits),
      _availableRegs(pass->_availableRegs),
      _clobberedRegs(),
      _curAssignment(),
      _block(nullptr),
      _node(nullptr),
      _raInst(nullptr),
      _tiedTotal(),
      _tiedCount() {}

  Error init() noexcept;

  // --------------------------------------------------------------------------
  // [Accessors]
  // --------------------------------------------------------------------------

  inline RAWorkReg* workRegById(uint32_t workId) const noexcept { return _pass->workRegById(workId); }
  inline PhysToWorkMap* physToWorkMap() const noexcept { return _curAssignment.physToWorkMap(); }
  inline WorkToPhysMap* workToPhysMap() const noexcept { return _curAssignment.workToPhysMap(); }

  // --------------------------------------------------------------------------
  // [Block]
  // --------------------------------------------------------------------------

  //! Get the currently processed block.
  inline RABlock* block() const noexcept { return _block; }
  //! Set the currently processed block.
  inline void setBlock(RABlock* block) noexcept { _block = block; }

  // --------------------------------------------------------------------------
  // [Instruction]
  // --------------------------------------------------------------------------

  //! Get the currently processed `InstNode`.
  inline InstNode* node() const noexcept { return _node; }
  //! Get the currently processed `RAInst`.
  inline RAInst* raInst() const noexcept { return _raInst; }

  //! Get all tied regs.
  inline RATiedReg* tiedRegs() const noexcept { return _raInst->tiedRegs(); }
  //! Get grouped tied regs.
  inline RATiedReg* tiedRegs(uint32_t group) const noexcept { return _raInst->tiedRegs(group); }

  //! Get TiedReg count (all).
  inline uint32_t tiedCount() const noexcept { return _tiedTotal; }
  //! Get TiedReg count (per class).
  inline uint32_t tiedCount(uint32_t group) const noexcept { return _tiedCount.get(group); }

  inline bool isGroupUsed(uint32_t group) const noexcept { return _tiedCount[group] != 0; }

  // --------------------------------------------------------------------------
  // [Assignment]
  // --------------------------------------------------------------------------

  Error makeInitialAssignment() noexcept;

  Error replaceAssignment(
    const PhysToWorkMap* physToWorkMap,
    const WorkToPhysMap* workToPhysMap) noexcept;

  //! Switch to the given assignment by reassigning all register and emitting
  //! code that reassigns them. This is always used to switch to a previously
  //! stored assignment.
  //!
  //! If `tryMode` is true then the final assignment doesn't have to be exactly
  //! same as specified by `dstPhysToWorkMap` and `dstWorkToPhysMap`. This mode
  //! is only used before conditional jumps that already have assignment to
  //! generate a code sequence that is always executed regardless of the flow.
  Error switchToAssignment(
    PhysToWorkMap* dstPhysToWorkMap,
    WorkToPhysMap* dstWorkToPhysMap,
    const ZoneBitVector& liveIn,
    bool dstReadOnly,
    bool tryMode) noexcept;

  // --------------------------------------------------------------------------
  // [Allocation]
  // --------------------------------------------------------------------------

  Error allocInst(InstNode* cbInst) noexcept;
  Error allocBranch(InstNode* cbInst, RABlock* target, RABlock* cont) noexcept;

  // --------------------------------------------------------------------------
  // [Decision Making]
  // --------------------------------------------------------------------------

  enum CostModel : uint32_t {
    kCostOfFrequency = 1048576,
    kCostOfDirtyFlag = kCostOfFrequency / 4
  };

  inline uint32_t costByFrequency(float freq) const noexcept {
    return uint32_t(int32_t(freq * float(kCostOfFrequency)));
  }

  inline uint32_t calculateSpillCost(uint32_t group, uint32_t workId, uint32_t assignedId) const noexcept {
    RAWorkReg* workReg = workRegById(workId);
    uint32_t cost = costByFrequency(workReg->liveStats().freq());

    if (_curAssignment.isPhysDirty(group, assignedId))
      cost += kCostOfDirtyFlag;

    return cost;
  }

  //! Decide on register assignment.
  uint32_t decideOnAssignment(uint32_t group, uint32_t workId, uint32_t assignedId, uint32_t allocableRegs) const noexcept;

  //! Decide on whether to MOVE or SPILL the given WorkReg.
  //!
  //! The function must return either `RAAssignment::kPhysNone`, which means that
  //! the WorkReg should be spilled, or a valid physical register ID, which means
  //! that the register should be moved to that physical register instead.
  uint32_t decideOnUnassignment(uint32_t group, uint32_t workId, uint32_t assignedId, uint32_t allocableRegs) const noexcept;

  //! Decide on best spill given a register mask `spillableRegs`
  uint32_t decideOnSpillFor(uint32_t group, uint32_t workId, uint32_t spillableRegs, uint32_t* spillWorkId) const noexcept;

  // --------------------------------------------------------------------------
  // [Emit]
  // --------------------------------------------------------------------------

  //! Emit a move between a destination and source register, and fix the register assignment.
  inline Error onMoveReg(uint32_t group, uint32_t workId, uint32_t dstPhysId, uint32_t srcPhysId) noexcept {
    if (dstPhysId == srcPhysId) return kErrorOk;
    _curAssignment.reassign(group, workId, dstPhysId, srcPhysId);
    return _pass->onEmitMove(workId, dstPhysId, srcPhysId);
  }

  //! Emit a swap between two physical registers and fix their assignment.
  //!
  //! NOTE: Target must support this operation otherwise this would ASSERT.
  inline Error onSwapReg(uint32_t group, uint32_t aWorkId, uint32_t aPhysId, uint32_t bWorkId, uint32_t bPhysId) noexcept {
    _curAssignment.swap(group, aWorkId, aPhysId, bWorkId, bPhysId);
    return _pass->onEmitSwap(aWorkId, aPhysId, bWorkId, bPhysId);
  }

  //! Emit a load from [VirtReg/WorkReg]'s spill slot to a physical register and make it assigned and clean.
  inline Error onLoadReg(uint32_t group, uint32_t workId, uint32_t physId) noexcept {
    _curAssignment.assign(group, workId, physId, RAAssignment::kClean);
    return _pass->onEmitLoad(workId, physId);
  }

  //! Emit a save a physical register to a [VirtReg/WorkReg]'s spill slot, keep it assigned, and make it clean.
  inline Error onSaveReg(uint32_t group, uint32_t workId, uint32_t physId) noexcept {
    ASMJIT_ASSERT(_curAssignment.workToPhysId(group, workId) == physId);
    ASMJIT_ASSERT(_curAssignment.physToWorkId(group, physId) == workId);

    _curAssignment.makeClean(group, workId, physId);
    return _pass->onEmitSave(workId, physId);
  }

  //! Assign a register, the content of it is undefined at this point.
  inline Error onAssignReg(uint32_t group, uint32_t workId, uint32_t physId, uint32_t dirty) noexcept {
    _curAssignment.assign(group, workId, physId, dirty);
    return kErrorOk;
  }

  //! Spill variable/register, saves the content to the memory-home if modified.
  inline Error onSpillReg(uint32_t group, uint32_t workId, uint32_t physId) noexcept {
    if (_curAssignment.isPhysDirty(group, physId))
      ASMJIT_PROPAGATE(onSaveReg(group, workId, physId));
    return onKillReg(group, workId, physId);
  }

  inline Error onDirtyReg(uint32_t group, uint32_t workId, uint32_t physId) noexcept {
    _curAssignment.makeDirty(group, workId, physId);
    return kErrorOk;
  }

  inline Error onKillReg(uint32_t group, uint32_t workId, uint32_t physId) noexcept {
    _curAssignment.unassign(group, workId, physId);
    return kErrorOk;
  }

  // --------------------------------------------------------------------------
  // [Members]
  // --------------------------------------------------------------------------

  RAPass* _pass;                         //!< Link to `RAPass`.
  BaseCompiler* _cc;                     //!< Link to `BaseCompiler`.

  RAArchTraits _archTraits;              //!< Architecture traits.
  RARegMask _availableRegs;              //!< Registers available to the allocator.
  RARegMask _clobberedRegs;              //!< Registers clobbered by the allocator.

  RAAssignment _curAssignment;           //!< Register assignment (current).
  RAAssignment _tmpAssignment;           //!< Register assignment used temporarily during assignment switches.

  RABlock* _block;                       //!< Link to the current `RABlock`.
  InstNode* _node;                       //!< InstNode.
  RAInst* _raInst;                       //!< RA instruction.

  uint32_t _tiedTotal;                   //!< Count of all TiedReg's.
  RARegCount _tiedCount;                 //!< TiedReg's total counter.
};

//! \}

ASMJIT_END_NAMESPACE

// [Guard]
#endif // !ASMJIT_DISABLE_COMPILER
#endif // _ASMJIT_CORE_RALOCAL_P_H

```

`Avanguard/AsmJit/asmjit/core/rapass_p.h`:

```h
// [AsmJit]
// Complete x86/x64 JIT and Remote Assembler for C++.
//
// [License]
// ZLIB - See LICENSE.md file in the package.

// [Guard]
#ifndef _ASMJIT_CORE_RAPASS_P_H
#define _ASMJIT_CORE_RAPASS_P_H

#include "../core/build.h"
#ifndef ASMJIT_DISABLE_COMPILER

// [Dependencies]
#include "../core/raassignment_p.h"
#include "../core/radefs_p.h"
#include "../core/rastack_p.h"

ASMJIT_BEGIN_NAMESPACE

//! \addtogroup asmjit_core_ra
//! \{

// ============================================================================
// [asmjit::RABlock]
// ============================================================================

class RABlock {
public:
  ASMJIT_NONCOPYABLE(RABlock)

  enum Id : uint32_t {
    kUnassignedId         = 0xFFFFFFFFu
  };

  enum Flags : uint32_t {
    kFlagIsConstructed    = 0x00000001u, //!< Block has been constructed from nodes.
    kFlagIsReachable      = 0x00000002u, //!< Block is reachable (set by `buildViews()`).
    kFlagIsAllocated      = 0x00000004u, //!< Block has been allocated.
    kFlagIsFuncExit       = 0x00000008u, //!< Block is a function-exit.

    kFlagHasTerminator    = 0x00000010u, //!< Block has a terminator (jump, conditional jump, ret).
    kFlagHasConsecutive   = 0x00000020u, //!< Block naturally flows to the next block.
    kFlagHasFixedRegs     = 0x00000040u, //!< Block contains fixed registers (precolored).
    kFlagHasFuncCalls     = 0x00000080u  //!< Block contains function calls.
  };

  enum LiveType : uint32_t {
    kLiveIn               = 0,
    kLiveOut              = 1,
    kLiveGen              = 2,
    kLiveKill             = 3,
    kLiveCount            = 4
  };

  // --------------------------------------------------------------------------
  // [Typedefs]
  // --------------------------------------------------------------------------

  typedef RAAssignment::PhysToWorkMap PhysToWorkMap;
  typedef RAAssignment::WorkToPhysMap WorkToPhysMap;

  // --------------------------------------------------------------------------
  // [Construction / Destruction]
  // --------------------------------------------------------------------------

  inline RABlock(RAPass* ra) noexcept
    : _ra(ra),
      _blockId(kUnassignedId),
      _flags(0),
      _first(nullptr),
      _last(nullptr),
      _firstPosition(0),
      _endPosition(0),
      _weight(0),
      _povOrder(kUnassignedId),
      _regsStats(),
      _maxLiveCount(),
      _timestamp(0),
      _idom(nullptr),
      _predecessors(),
      _successors(),
      _entryPhysToWorkMap(nullptr),
      _entryWorkToPhysMap(nullptr) {}

  // --------------------------------------------------------------------------
  // [Accessors]
  // --------------------------------------------------------------------------

  inline RAPass* pass() const noexcept { return _ra; }
  inline ZoneAllocator* allocator() const noexcept;

  inline uint32_t blockId() const noexcept { return _blockId; }
  inline uint32_t flags() const noexcept { return _flags; }

  inline bool hasFlag(uint32_t flag) const noexcept { return (_flags & flag) != 0; }
  inline void addFlags(uint32_t flags) noexcept { _flags |= flags; }

  inline bool isAssigned() const noexcept { return _blockId != kUnassignedId; }

  inline bool isConstructed() const noexcept { return hasFlag(kFlagIsConstructed); }
  inline bool isReachable() const noexcept { return hasFlag(kFlagIsReachable); }
  inline bool isAllocated() const noexcept { return hasFlag(kFlagIsAllocated); }
  inline bool isFuncExit() const noexcept { return hasFlag(kFlagIsFuncExit); }

  inline void makeConstructed(const RARegsStats& regStats) noexcept {
    _flags |= kFlagIsConstructed;
    _regsStats.combineWith(regStats);
  }

  inline void makeReachable() noexcept { _flags |= kFlagIsReachable; }
  inline void makeAllocated() noexcept { _flags |= kFlagIsAllocated; }

  inline const RARegsStats& regsStats() const noexcept { return _regsStats; }

  inline bool hasTerminator() const noexcept { return hasFlag(kFlagHasTerminator); }
  inline bool hasConsecutive() const noexcept { return hasFlag(kFlagHasConsecutive); }

  inline bool hasPredecessors() const noexcept { return !_predecessors.empty(); }
  inline bool hasSuccessors() const noexcept { return !_successors.empty(); }

  inline const RABlocks& predecessors() const noexcept { return _predecessors; }
  inline const RABlocks& successors() const noexcept { return _successors; }

  inline BaseNode* first() const noexcept { return _first; }
  inline BaseNode* last() const noexcept { return _last; }

  inline void setFirst(BaseNode* node) noexcept { _first = node; }
  inline void setLast(BaseNode* node) noexcept { _last = node; }

  inline uint32_t firstPosition() const noexcept { return _firstPosition; }
  inline void setFirstPosition(uint32_t position) noexcept { _firstPosition = position; }

  inline uint32_t endPosition() const noexcept { return _endPosition; }
  inline void setEndPosition(uint32_t position) noexcept { _endPosition = position; }

  inline uint32_t povOrder() const noexcept { return _povOrder; }

  inline uint64_t timestamp() const noexcept { return _timestamp; }
  inline bool hasTimestamp(uint64_t ts) const noexcept { return _timestamp == ts; }
  inline void setTimestamp(uint64_t ts) const noexcept { _timestamp = ts; }
  inline void resetTimestamp() const noexcept { _timestamp = 0; }

  inline RABlock* consecutive() const noexcept { return hasConsecutive() ? _successors[0] : nullptr; }

  inline RABlock* iDom() noexcept { return _idom; }
  inline const RABlock* iDom() const noexcept { return _idom; }
  inline void setIDom(RABlock* block) noexcept { _idom = block; }

  inline ZoneBitVector& liveIn() noexcept { return _liveBits[kLiveIn]; }
  inline const ZoneBitVector& liveIn() const noexcept { return _liveBits[kLiveIn]; }

  inline ZoneBitVector& liveOut() noexcept { return _liveBits[kLiveOut]; }
  inline const ZoneBitVector& liveOut() const noexcept { return _liveBits[kLiveOut]; }

  inline ZoneBitVector& gen() noexcept { return _liveBits[kLiveGen]; }
  inline const ZoneBitVector& gen() const noexcept { return _liveBits[kLiveGen]; }

  inline ZoneBitVector& kill() noexcept { return _liveBits[kLiveKill]; }
  inline const ZoneBitVector& kill() const noexcept { return _liveBits[kLiveKill]; }

  inline Error resizeLiveBits(uint32_t size) noexcept {
    ASMJIT_PROPAGATE(_liveBits[kLiveIn  ].resize(allocator(), size));
    ASMJIT_PROPAGATE(_liveBits[kLiveOut ].resize(allocator(), size));
    ASMJIT_PROPAGATE(_liveBits[kLiveGen ].resize(allocator(), size));
    ASMJIT_PROPAGATE(_liveBits[kLiveKill].resize(allocator(), size));
    return kErrorOk;
  }

  inline bool hasEntryAssignment() const noexcept { return _entryPhysToWorkMap != nullptr; }
  inline WorkToPhysMap* entryWorkToPhysMap() const noexcept { return _entryWorkToPhysMap; }
  inline PhysToWorkMap* entryPhysToWorkMap() const noexcept { return _entryPhysToWorkMap; }

  inline void setEntryAssignment(PhysToWorkMap* physToWorkMap, WorkToPhysMap* workToPhysMap) noexcept {
    _entryPhysToWorkMap = physToWorkMap;
    _entryWorkToPhysMap = workToPhysMap;
  }

  // --------------------------------------------------------------------------
  // [Control Flow]
  // --------------------------------------------------------------------------

  //! Adds a successor to this block, and predecessor to `successor`, making
  //! connection on both sides.
  //!
  //! This API must be used to manage successors and predecessors, never manage
  //! it manually.
  Error appendSuccessor(RABlock* successor) noexcept;

  //! Similar to `appendSuccessor()`, but does prepend instead append.
  //!
  //! This function is used to add a natural flow (always first) to the block.
  Error prependSuccessor(RABlock* successor) noexcept;

  // --------------------------------------------------------------------------
  // [Members]
  // --------------------------------------------------------------------------

  RAPass* _ra;                           //!< Register allocator pass.

  uint32_t _blockId;                     //!< Block id (indexed from zero).
  uint32_t _flags;                       //!< Block flags, see `Flags`.

  BaseNode* _first;                      //!< First `BaseNode` of this block (inclusive).
  BaseNode* _last;                       //!< Last `BaseNode` of this block (inclusive).

  uint32_t _firstPosition;               //!< Initial position of this block (inclusive).
  uint32_t _endPosition;                 //!< End position of this block (exclusive).

  uint32_t _weight;                      //!< Weight of this block (default 0, each loop adds one).
  uint32_t _povOrder;                    //!< Post-order view order, used during POV construction.
  RARegsStats _regsStats;                //!< Basic statistics about registers.
  RALiveCount _maxLiveCount;             //!< Maximum live-count per register group.

  mutable uint64_t _timestamp;           //!< Timestamp (used by block visitors).
  RABlock* _idom;                        //!< Immediate dominator of this block.

  RABlocks _predecessors;                //!< Block predecessors.
  RABlocks _successors;                  //!< Block successors.

  // TODO: Used?
  RABlocks _doms;

  ZoneBitVector _liveBits[kLiveCount];   //!< Liveness in/out/use/kill.

  PhysToWorkMap* _entryPhysToWorkMap;    //!< Register assignment (PhysToWork) on entry.
  WorkToPhysMap* _entryWorkToPhysMap;    //!< Register assignment (WorkToPhys) on entry.
};

// ============================================================================
// [asmjit::RAInst]
// ============================================================================

//! Register allocator's data associated with each `InstNode`.
class RAInst {
public:
  ASMJIT_NONCOPYABLE(RAInst)

  enum Flags : uint32_t {
    kFlagIsTerminator = 0x00000001u
  };

  static inline size_t sizeOf(uint32_t tiedRegCount) noexcept {
    return sizeof(RAInst) - sizeof(RATiedReg) + tiedRegCount * sizeof(RATiedReg);
  }

  ASMJIT_INLINE RAInst(RABlock* block, uint32_t flags, uint32_t tiedTotal, const RARegMask& clobberedRegs) noexcept {
    _block = block;
    _flags = flags;
    _tiedTotal = tiedTotal;
    _tiedIndex.reset();
    _tiedCount.reset();
    _liveCount.reset();
    _usedRegs.reset();
    _clobberedRegs = clobberedRegs;
  }

  // --------------------------------------------------------------------------
  // [Accessors]
  // --------------------------------------------------------------------------

  //! Get the instruction flags.
  inline uint32_t flags() const noexcept { return _flags; }
  //! Get whether the instruction has flag `flag`.
  inline bool hasFlag(uint32_t flag) const noexcept { return (_flags & flag) != 0; }
  //! Set instruction flags to `flags`.
  inline void setFlags(uint32_t flags) noexcept { _flags = flags; }
  //! Add instruction `flags`.
  inline void addFlags(uint32_t flags) noexcept { _flags |= flags; }
  //! Clear instruction `flags`.
  inline void clearFlags(uint32_t flags) noexcept { _flags &= ~flags; }

  //! Get whether the node is code that can be executed.
  inline bool isTerminator() const noexcept { return hasFlag(kFlagIsTerminator); }

  inline RABlock* block() const noexcept { return _block; }

  //! Get tied registers (all).
  inline RATiedReg* tiedRegs() const noexcept { return const_cast<RATiedReg*>(_tiedRegs); }
  //! Get tied registers for a given `group`.
  inline RATiedReg* tiedRegs(uint32_t group) const noexcept { return const_cast<RATiedReg*>(_tiedRegs) + _tiedIndex.get(group); }

   //! Get count of all tied registers.
  inline uint32_t tiedCount() const noexcept { return _tiedTotal; }
  //! Get count of tied registers of a given `group`.
  inline uint32_t tiedCount(uint32_t group) const noexcept { return _tiedCount[group]; }

  //! Get `RATiedReg` at the specified `index`.
  inline RATiedReg* tiedAt(uint32_t index) const noexcept {
    ASMJIT_ASSERT(index < _tiedTotal);
    return tiedRegs() + index;
  }

  //! Get `RATiedReg` at the specified index for a given register `group`.
  inline RATiedReg* tiedOf(uint32_t group, uint32_t index) const noexcept {
    ASMJIT_ASSERT(index < _tiedCount._regs[group]);
    return tiedRegs(group) + index;
  }

  inline void setTiedAt(uint32_t index, RATiedReg& tied) noexcept {
    ASMJIT_ASSERT(index < _tiedTotal);
    _tiedRegs[index] = tied;
  }

  // --------------------------------------------------------------------------
  // [Members]
  // --------------------------------------------------------------------------

  RABlock* _block;                       //!< Parent block.
  uint32_t _flags;                       //!< Flags.
  uint32_t _tiedTotal;                   //!< Total count of RATiedReg's.
  RARegIndex _tiedIndex;                 //!< Index of RATiedReg's per register group.
  RARegCount _tiedCount;                 //!< Count of RATiedReg's per register group.
  RALiveCount _liveCount;                //!< Number of live, and thus interfering VirtReg's at this point.
  RARegMask _usedRegs;                   //!< Fixed physical registers used.
  RARegMask _clobberedRegs;              //!< Clobbered registers (by a function call).
  RATiedReg _tiedRegs[1];                //!< Tied registers.
};

// ============================================================================
// [asmjit::RAInstBuilder]
// ============================================================================

//! A helper class that is used to build an array of RATiedReg items that are
//! then copied to `RAInst`.
class RAInstBuilder {
public:
  ASMJIT_NONCOPYABLE(RAInstBuilder)

  // --------------------------------------------------------------------------
  // [Init / Reset]
  // --------------------------------------------------------------------------

  inline RAInstBuilder() noexcept { reset(); }

  inline void init() noexcept { reset(); }
  inline void reset() noexcept {
    _count.reset();
    _stats.reset();
    _used.reset();
    _clobbered.reset();
    _cur = _tiedRegs;
  }

  // --------------------------------------------------------------------------
  // [Accessors]
  // --------------------------------------------------------------------------

  inline uint32_t flags() const noexcept { return _flags; }
  inline void addFlags(uint32_t flags) noexcept { _flags |= flags; }

  //! Get the number of tied registers added to the builder.
  inline uint32_t tiedRegCount() const noexcept { return uint32_t((size_t)(_cur - _tiedRegs)); }

  //! Get a tied register at index `index`.
  inline RATiedReg* operator[](uint32_t index) noexcept {
    ASMJIT_ASSERT(index < tiedRegCount());
    return &_tiedRegs[index];
  }

  //! Get a tied register at index `index` (const).
  inline const RATiedReg* operator[](uint32_t index) const noexcept {
    ASMJIT_ASSERT(index < tiedRegCount());
    return &_tiedRegs[index];
  }

  // --------------------------------------------------------------------------
  // [Ops]
  // --------------------------------------------------------------------------

  ASMJIT_INLINE Error add(RAWorkReg* workReg, uint32_t flags, uint32_t allocable, uint32_t useId, uint32_t useRewriteMask, uint32_t outId, uint32_t outRewriteMask) noexcept {
    uint32_t group = workReg->group();
    RATiedReg* tiedReg = workReg->tiedReg();

    if (useId != BaseReg::kIdBad) {
      _stats.makeFixed(group);
      _used[group] |= Support::mask(useId);
      flags |= RATiedReg::kUseFixed;
    }

    if (outId != BaseReg::kIdBad) {
      _clobbered[group] |= Support::mask(outId);
      flags |= RATiedReg::kOutFixed;
    }

    _flags |= flags;
    _stats.makeUsed(group);

    if (!tiedReg) {
      // Could happen when the builder is not reset properly after each instruction.
      ASMJIT_ASSERT(tiedRegCount() < ASMJIT_ARRAY_SIZE(_tiedRegs));

      tiedReg = _cur++;
      tiedReg->init(workReg->workId(), flags, allocable, useId, useRewriteMask, outId, outRewriteMask);
      workReg->setTiedReg(tiedReg);

      _count.add(group);
      return kErrorOk;
    }
    else {
      // TODO: What about `useId`, in that case we should perform a move outside and ban coalescing.
      if (ASMJIT_UNLIKELY(outId != BaseReg::kIdBad)) {
        if (ASMJIT_UNLIKELY(tiedReg->hasOutId()))
          return DebugUtils::errored(kErrorOverlappedRegs);

        tiedReg->setOutId(outId);
        // TODO: ? _used[group] |= Support::mask(outId);
      }

      tiedReg->addRefCount();
      tiedReg->addFlags(flags);
      tiedReg->_allocableRegs &= allocable;
      tiedReg->_useRewriteMask |= useRewriteMask;
      tiedReg->_outRewriteMask |= outRewriteMask;
      return kErrorOk;
    }
  }

  // --------------------------------------------------------------------------
  // [Members]
  // --------------------------------------------------------------------------

  uint32_t _flags;                       //!< Flags combined from all RATiedReg's.
  RARegCount _count;
  RARegsStats _stats;

  RARegMask _used;
  RARegMask _clobbered;

  RATiedReg* _cur;                       //!< Current tied register in `_tiedRegs`.
  RATiedReg _tiedRegs[128];              //!< Array of temporary tied registers.
};

// ============================================================================
// [asmjit::RAPass]
// ============================================================================

//! Register allocation pass used by `BaseCompiler`.
class RAPass : public FuncPass {
public:
  ASMJIT_NONCOPYABLE(RAPass)
  typedef FuncPass Base;

  // --------------------------------------------------------------------------
  // [Typedefs]
  // --------------------------------------------------------------------------

  typedef RAAssignment::PhysToWorkMap PhysToWorkMap;
  typedef RAAssignment::WorkToPhysMap WorkToPhysMap;

  // --------------------------------------------------------------------------
  // [Construction / Destruction]
  // --------------------------------------------------------------------------

  RAPass() noexcept;
  virtual ~RAPass() noexcept;

  // --------------------------------------------------------------------------
  // [Accessors]
  // --------------------------------------------------------------------------

  //! Get `Logger` passed to `runOnFunction()`.
  inline Logger* logger() const noexcept { return _logger; }
  //! Get `Logger` passed to `runOnFunction()` or null if `kOptionDebugPasses` is not set.
  inline Logger* debugLogger() const noexcept { return _debugLogger; }

  //! Get `Zone` passed to `runOnFunction()`.
  inline Zone* zone() const noexcept { return _allocator.zone(); }
  //! Get `ZoneAllocator` used by the register allocator.
  inline ZoneAllocator* allocator() const noexcept { return const_cast<ZoneAllocator*>(&_allocator); }

  //! Get function node.
  inline FuncNode* func() const noexcept { return _func; }
  //! Get stop node.
  inline BaseNode* stop() const noexcept { return _stop; }

  //! Get extra block.
  inline BaseNode* extraBlock() const noexcept { return _extraBlock; }
  //! Set extra block.
  inline void setExtraBlock(BaseNode* node) noexcept { _extraBlock = node; }

  inline uint32_t endPosition() const noexcept { return _instructionCount * 2; }

  inline const RARegMask& availableRegs() const noexcept { return _availableRegs; }
  inline const RARegMask& cloberredRegs() const noexcept { return _clobberedRegs; }

  inline void makeUnavailable(uint32_t group, uint32_t regId) noexcept {
    _availableRegs[group] &= ~Support::mask(regId);
    _availableRegCount[group]--;
  }

  // --------------------------------------------------------------------------
  // [RunOnFunction / RunAllocation]
  // --------------------------------------------------------------------------

  //! Run the register allocator for the given `func`.
  Error runOnFunction(Zone* zone, Logger* logger, FuncNode* func) noexcept override;

  //! Perform all allocation steps sequentially, called by `runOnFunction()`.
  Error onPerformAllSteps() noexcept;

  // --------------------------------------------------------------------------
  // [OnInit / OnDone]
  // --------------------------------------------------------------------------

  //! Called by `runOnFunction()` before the register allocation to initialize
  //! architecture-specific data and constraints.
  virtual void onInit() noexcept = 0;

  //! Called by `runOnFunction()` after register allocation to clean everything
  //! up. Called even if the register allocation failed.
  virtual void onDone() noexcept = 0;

  // --------------------------------------------------------------------------
  // [CFG - Basic Block Management]
  // --------------------------------------------------------------------------

  //! Get entry block.
  inline RABlock* entryBlock() noexcept {
    ASMJIT_ASSERT(!_blocks.empty());
    return _blocks[0];
  }

  //! Get entry block (const).
  inline const RABlock* entryBlock() const noexcept {
    ASMJIT_ASSERT(!_blocks.empty());
    return _blocks[0];
  }

  //! Get count of basic blocks (returns size of `_blocks` array).
  inline uint32_t blockCount() const noexcept { return _blocks.size(); }
  //! Get count of reachable basic blocks (returns size of `_pov` array).
  inline uint32_t reachableBlockCount() const noexcept { return _pov.size(); }

  //! Get whether the CFG has dangling blocks - these were created by `newBlock()`,
  //! but not added to CFG through `addBlocks()`. If `true` is returned and the
  //! CFG is constructed it means that something is missing and it's incomplete.
  //!
  //! NOTE: This is only used to check if the number of created blocks matches
  //! the number of added blocks.
  inline bool hasDanglingBlocks() const noexcept { return _createdBlockCount != blockCount(); }

  //! Get a next timestamp to be used to mark CFG blocks.
  inline uint64_t nextTimestamp() const noexcept { return ++_lastTimestamp; }

  //! Creates a new `RABlock` instance.
  //!
  //! NOTE: New blocks don't have ID assigned until they are added to the block
  //! array by calling `addBlock()`.
  RABlock* newBlock(BaseNode* initialNode = nullptr) noexcept;

  //! Tries to find a neighboring LabelNode (without going through code) that is
  //! already connected with `RABlock`. If no label is found then a new RABlock
  //! is created and assigned to all possible labels in a backward direction.
  RABlock* newBlockOrExistingAt(LabelNode* cbLabel, BaseNode** stoppedAt = nullptr) noexcept;

  //! Add the given `block` to the block list and assign it a unique block id.
  Error addBlock(RABlock* block) noexcept;

  inline Error addExitBlock(RABlock* block) noexcept {
    block->addFlags(RABlock::kFlagIsFuncExit);
    return _exits.append(allocator(), block);
  }

  ASMJIT_INLINE RAInst* newRAInst(RABlock* block, uint32_t flags, uint32_t tiedRegCount, const RARegMask& clobberedRegs) noexcept {
    return new(zone()->alloc(RAInst::sizeOf(tiedRegCount))) RAInst(block, flags, tiedRegCount, clobberedRegs);
  }

  ASMJIT_INLINE Error assignRAInst(BaseNode* node, RABlock* block, RAInstBuilder& ib) noexcept {
    uint32_t tiedRegCount = ib.tiedRegCount();
    RAInst* raInst = newRAInst(block, ib.flags(), tiedRegCount, ib._clobbered);

    if (ASMJIT_UNLIKELY(!raInst))
      return DebugUtils::errored(kErrorNoHeapMemory);

    RARegIndex index;
    index.buildIndexes(ib._count);

    raInst->_tiedIndex = index;
    raInst->_tiedCount = ib._count;

    for (uint32_t i = 0; i < tiedRegCount; i++) {
      RATiedReg* tiedReg = ib[i];
      RAWorkReg* workReg = workRegById(tiedReg->workId());

      workReg->resetTiedReg();
      uint32_t group = workReg->group();

      if (tiedReg->hasUseId()) {
        block->addFlags(RABlock::kFlagHasFixedRegs);
        raInst->_usedRegs[group] |= Support::mask(tiedReg->useId());
      }

      if (tiedReg->hasOutId()) {
        block->addFlags(RABlock::kFlagHasFixedRegs);
      }

      RATiedReg& dst = raInst->_tiedRegs[index[group]++];
      dst = *tiedReg;
      dst._allocableRegs &= ~ib._used[group];
    }

    node->setPassData<RAInst>(raInst);
    return kErrorOk;
  }

  // --------------------------------------------------------------------------
  // [CFG - Build CFG]
  // --------------------------------------------------------------------------

  //! Traverse the whole function and do the following:
  //!
  //!   1. Construct CFG (represented by `RABlock`) by populating `_blocks` and
  //!      `_exits`. Blocks describe the control flow of the function and contain
  //!      some additional information that is used by the register allocator.
  //!
  //!   2. Remove unreachable code immediately. This is not strictly necessary
  //!      for BaseCompiler itself as the register allocator cannot reach such
  //!      nodes, but keeping instructions that use virtual registers would fail
  //!      during instruction encoding phase (Assembler).
  //!
  //!   3. `RAInst` is created for each `InstNode` or compatible. It contains
  //!      information that is essential for further analysis and register
  //!      allocation.
  //!
  //! Use `RACFGBuilder` template that provides the necessary boilerplate.
  virtual Error buildCFG() noexcept = 0;

  // --------------------------------------------------------------------------
  // [CFG - Views Order]
  // --------------------------------------------------------------------------

  //! Construct CFG views (only POV at the moment).
  Error buildViews() noexcept;

  // --------------------------------------------------------------------------
  // [CFG - Dominators]
  // --------------------------------------------------------------------------

  // Terminology:
  //   - A node `X` dominates a node `Z` if any path from the entry point to
  //     `Z` has to go through `X`.
  //   - A node `Z` post-dominates a node `X` if any path from `X` to the end
  //     of the graph has to go through `Z`.

  //! Construct a dominator-tree from CFG.
  Error buildDominators() noexcept;

  //! \internal
  bool _strictlyDominates(const RABlock* a, const RABlock* b) const noexcept;
  //! \internal
  const RABlock* _nearestCommonDominator(const RABlock* a, const RABlock* b) const noexcept;

  //! Get whether basic block `a` dominates `b` - non-strict, returns true when `a == b`.
  inline bool dominates(const RABlock* a, const RABlock* b) const noexcept { return a == b ? true : _strictlyDominates(a, b); }
  //! Get whether basic block `a` dominates `b` - strict dominance check, returns false when `a == b`.
  inline bool strictlyDominates(const RABlock* a, const RABlock* b) const noexcept { return a == b ? false : _strictlyDominates(a, b); }

  //! Get a nearest common dominator of `a` and `b`.
  inline RABlock* nearestCommonDominator(RABlock* a, RABlock* b) const noexcept { return const_cast<RABlock*>(_nearestCommonDominator(a, b)); }
  //! Get a nearest common dominator of `a` and `b` (const).
  inline const RABlock* nearestCommonDominator(const RABlock* a, const RABlock* b) const noexcept { return _nearestCommonDominator(a, b); }

  // --------------------------------------------------------------------------
  // [CFG - Utilities]
  // --------------------------------------------------------------------------

  Error removeUnreachableBlocks() noexcept;

  //! Returns `node` or some node after that is ideal for beginning a new block.
  //! This function is mostly used after a conditional or unconditional jump to
  //! select the successor node. In some cases the next node could be a label,
  //! which means it could have assigned some block already.
  BaseNode* findSuccessorStartingAt(BaseNode* node) noexcept;

  //! Returns `true` of the `node` can flow to `target` without reaching code
  //! nor data. It's used to eliminate jumps to labels that are next right to
  //! them.
  bool isNextTo(BaseNode* node, BaseNode* target) noexcept;

  // --------------------------------------------------------------------------
  // [Registers - Management]
  // --------------------------------------------------------------------------

  //! Get a native size of a general-purpose register.
  inline uint32_t gpSize() const noexcept { return _sp.size(); }
  inline uint32_t availableRegCount(uint32_t group) const noexcept { return _availableRegCount[group]; }

  inline RAWorkReg* workRegById(uint32_t workId) const noexcept { return _workRegs[workId]; }

  inline RAWorkRegs& workRegs() noexcept { return _workRegs; }
  inline RAWorkRegs& workRegs(uint32_t group) noexcept { return _workRegsOfGroup[group]; }

  inline const RAWorkRegs& workRegs() const noexcept { return _workRegs; }
  inline const RAWorkRegs& workRegs(uint32_t group) const noexcept { return _workRegsOfGroup[group]; }

  inline uint32_t workRegCount() const noexcept { return _workRegs.size(); }
  inline uint32_t workRegCount(uint32_t group) const noexcept { return _workRegsOfGroup[group].size(); }

  inline void _buildPhysIndex() noexcept {
    _physRegIndex.buildIndexes(_physRegCount);
    _physRegTotal = uint32_t(_physRegIndex[BaseReg::kGroupVirt - 1]) +
                    uint32_t(_physRegCount[BaseReg::kGroupVirt - 1]) ;
  }
  inline uint32_t physRegIndex(uint32_t group) const noexcept { return _physRegIndex[group]; }
  inline uint32_t physRegTotal() const noexcept { return _physRegTotal; }

  Error _asWorkReg(VirtReg* vReg, RAWorkReg** out) noexcept;

  //! Creates `RAWorkReg` data for the given `vReg`. The function does nothing
  //! if `vReg` already contains link to `RAWorkReg`. Called by `constructBlocks()`.
  inline Error asWorkReg(VirtReg* vReg, RAWorkReg** out) noexcept {
    *out = vReg->workReg();
    return *out ? kErrorOk : _asWorkReg(vReg, out);
  }

  inline Error virtIndexAsWorkReg(uint32_t vIndex, RAWorkReg** out) noexcept {
    const ZoneVector<VirtReg*>& virtRegs = cc()->virtRegs();
    if (ASMJIT_UNLIKELY(vIndex >= virtRegs.size()))
      return DebugUtils::errored(kErrorInvalidVirtId);
    return asWorkReg(virtRegs[vIndex], out);
  }

  inline RAStackSlot* getOrCreateStackSlot(RAWorkReg* workReg) noexcept {
    RAStackSlot* slot = workReg->stackSlot();
    if (slot) return slot;

    slot = _stackAllocator.newSlot(_sp.id(), workReg->virtReg()->virtSize(), workReg->virtReg()->alignment(), 0);
    workReg->_stackSlot = slot;
    workReg->markStackUsed();
    return slot;
  }

  inline BaseMem workRegAsMem(RAWorkReg* workReg) noexcept {
    getOrCreateStackSlot(workReg);
    return BaseMem(Globals::Init, _sp.type(), workReg->virtId(), BaseReg::kTypeNone, 0, 0, 0, BaseMem::kSignatureMemRegHomeFlag);
  }

  WorkToPhysMap* newWorkToPhysMap() noexcept;
  PhysToWorkMap* newPhysToWorkMap() noexcept;

  inline PhysToWorkMap* clonePhysToWorkMap(const PhysToWorkMap* map) noexcept {
    size_t size = PhysToWorkMap::sizeOf(_physRegTotal);
    return static_cast<PhysToWorkMap*>(zone()->dupAligned(map, size, sizeof(uint32_t)));
  }

  inline WorkToPhysMap* cloneWorkToPhysMap(const WorkToPhysMap* map) noexcept {
    size_t size = WorkToPhysMap::sizeOf(_workRegs.size());
    if (ASMJIT_UNLIKELY(size == 0))
      return const_cast<WorkToPhysMap*>(map);
    return static_cast<WorkToPhysMap*>(zone()->dup(map, size));
  }

  // --------------------------------------------------------------------------
  // [Registers - Liveness Analysis and Statistics]
  // --------------------------------------------------------------------------

  //! 1. Calculate GEN/KILL/IN/OUT of each block.
  //! 2. Calculate live spans and basic statistics of each work register.
  Error buildLiveness() noexcept;

  // --------------------------------------------------------------------------
  // [Allocation - Global]
  // --------------------------------------------------------------------------

  //! Run a global register allocator.
  Error runGlobalAllocator() noexcept;

  Error binPack(uint32_t group) noexcept;

  // --------------------------------------------------------------------------
  // [Allocation - Local]
  // --------------------------------------------------------------------------

  //! Run a local register allocator.
  Error runLocalAllocator() noexcept;
  Error setBlockEntryAssignment(RABlock* block, const RABlock* fromBlock, const RAAssignment& fromAssignment) noexcept;

  // --------------------------------------------------------------------------
  // [Allocation - Prolog / Epilog]
  // --------------------------------------------------------------------------

  Error updateStackFrame() noexcept;
  Error _markStackArgsToKeep() noexcept;
  Error _updateStackArgs() noexcept;
  Error insertPrologEpilog() noexcept;

  // --------------------------------------------------------------------------
  // [Rewriter]
  // --------------------------------------------------------------------------

  Error rewrite() noexcept;
  Error _rewrite(BaseNode* first, BaseNode* stop) noexcept;

  // --------------------------------------------------------------------------
  // [Logging]
  // --------------------------------------------------------------------------

  #ifndef ASMJIT_DISABLE_LOGGING
  Error annotateCode() noexcept;

  Error _logBlockIds(const RABlocks& blocks) noexcept;
  Error _dumpBlockLiveness(StringBuilder& sb, const RABlock* block) noexcept;
  Error _dumpLiveSpans(StringBuilder& sb) noexcept;
  #endif

  // --------------------------------------------------------------------------
  // [Emit]
  // --------------------------------------------------------------------------

  virtual Error onEmitMove(uint32_t workId, uint32_t dstPhysId, uint32_t srcPhysId) noexcept = 0;
  virtual Error onEmitSwap(uint32_t aWorkId, uint32_t aPhysId, uint32_t bWorkId, uint32_t bPhysId) noexcept = 0;

  virtual Error onEmitLoad(uint32_t workId, uint32_t dstPhysId) noexcept = 0;
  virtual Error onEmitSave(uint32_t workId, uint32_t srcPhysId) noexcept = 0;

  virtual Error onEmitJump(const Label& label) noexcept = 0;

  // --------------------------------------------------------------------------
  // [Members]
  // --------------------------------------------------------------------------

  ZoneAllocator _allocator;              //!< Allocator that uses zone passed to `runOnFunction()`.
  Logger* _logger;                       //!< Logger, disabled if null.
  Logger* _debugLogger;                  //!< Debug logger, non-null only if `kOptionDebugPasses` option is set.
  uint32_t _loggerFlags;                 //!< Logger flags.

  FuncNode* _func;                       //!< Function being processed.
  BaseNode* _stop;                       //!< Stop node.
  BaseNode* _extraBlock;                 //!< Node that is used to insert extra code after the function body.

  RABlocks _blocks;                      //!< Blocks (first block is the entry, always exists).
  RABlocks _exits;                       //!< Function exit blocks (usually one, but can contain more).
  RABlocks _pov;                         //!< Post order view (POV).

  uint32_t _instructionCount;            //!< Number of instruction nodes.
  uint32_t _createdBlockCount;           //!< Number of created blocks (internal).
  mutable uint64_t _lastTimestamp;       //!< Timestamp generator (incremental).

  RAArchTraits _archTraits;              //!< Architecture traits.
  RARegIndex _physRegIndex;              //!< Index to physical registers in `RAAssignment::PhysToWorkMap`.
  RARegCount _physRegCount;              //!< Count of physical registers in `RAAssignment::PhysToWorkMap`.
  uint32_t _physRegTotal;                //!< Total number of physical registers.

  RARegMask _availableRegs;              //!< Registers available for allocation.
  RARegCount _availableRegCount;         //!< Count of physical registers per group.

  RARegMask _clobberedRegs;              //!< Registers clobbered by the function.

  RAWorkRegs _workRegs;                  //!< Work registers (registers used by the function).
  RAWorkRegs _workRegsOfGroup[BaseReg::kGroupVirt];

  RAStrategy _strategy[BaseReg::kGroupVirt]; //!< Register allocation strategy.
  RALiveCount _globalMaxLiveCount;       //!< Global max live-count (from all blocks).

  BaseReg _sp;                           //!< Stack pointer.
  BaseReg _fp;                           //!< Frame pointer.
  RAStackAllocator _stackAllocator;      //!< Stack manager.
  FuncArgsAssignment _argsAssignment;    //!< Function arguments mapper.
  uint32_t _numStackArgsToStackSlots;    //!< Some StackArgs have to be assigned to StackSlots.

  StringBuilderTmp<80> _tmpString;       //!< Temporary string builder used to format comments.
  uint32_t _maxWorkRegNameSize;          //!< Maximum name-size computed from all WorkReg's.
};

inline ZoneAllocator* RABlock::allocator() const noexcept { return _ra->allocator(); }

//! \}

ASMJIT_END_NAMESPACE

// [Guard]
#endif // !ASMJIT_DISABLE_COMPILER
#endif // _ASMJIT_CORE_RAPASS_P_H

```

`Avanguard/AsmJit/asmjit/core/rastack_p.h`:

```h
// [AsmJit]
// Complete x86/x64 JIT and Remote Assembler for C++.
//
// [License]
// ZLIB - See LICENSE.md file in the package.

// [Guard]
#ifndef _ASMJIT_CORE_RASTACK_P_H
#define _ASMJIT_CORE_RASTACK_P_H

#include "../core/build.h"
#ifndef ASMJIT_DISABLE_COMPILER

// [Dependencies]
#include "../core/radefs_p.h"

ASMJIT_BEGIN_NAMESPACE

//! \addtogroup asmjit_core_ra
//! \{

// ============================================================================
// [asmjit::RAStackSlot]
// ============================================================================

//! Stack slot.
struct RAStackSlot {
  enum Flags : uint32_t {
    // TODO: kFlagRegHome is apparently not used, but isRegHome() is.
    kFlagRegHome          = 0x00000001u, //!< Stack slot is register home slot.
    kFlagStackArg         = 0x00000002u  //!< Stack slot position matches argument passed via stack.
  };

  enum ArgIndex : uint32_t {
    kNoArgIndex = 0xFF
  };

  // --------------------------------------------------------------------------
  // [Accessors]
  // --------------------------------------------------------------------------

  inline uint32_t baseRegId() const noexcept { return _baseRegId; }
  inline void setBaseRegId(uint32_t id) noexcept { _baseRegId = uint8_t(id); }

  inline uint32_t size() const noexcept { return _size; }
  inline uint32_t alignment() const noexcept { return _alignment; }

  inline uint32_t flags() const noexcept { return _flags; }
  inline void addFlags(uint32_t flags) noexcept { _flags |= flags; }
  inline bool isRegHome() const noexcept { return (_flags & kFlagRegHome) != 0; }
  inline bool isStackArg() const noexcept { return (_flags & kFlagStackArg) != 0; }

  inline uint32_t useCount() const noexcept { return _useCount; }
  inline void addUseCount(uint32_t n = 1) noexcept { _useCount += n; }

  inline uint32_t weight() const noexcept { return _weight; }
  inline void setWeight(uint32_t weight) noexcept { _weight = weight; }

  inline int32_t offset() const noexcept { return _offset; }
  inline void setOffset(int32_t offset) noexcept { _offset = offset; }

  // --------------------------------------------------------------------------
  // [Members]
  // --------------------------------------------------------------------------

  uint8_t _baseRegId;                    //!< Base register used to address the stack.
  uint8_t _alignment;                    //!< Minimum alignment required by the slot.
  uint8_t _reserved[2];                  //!< Reserved for future use.
  uint32_t _size;                        //!< Size of memory required by the slot.
  uint32_t _flags;                       //!< Slot flags.

  uint32_t _useCount;                    //!< Usage counter (one unit equals one memory access).
  uint32_t _weight;                      //!< Weight of the slot (calculated by `calculateStackFrame()`).
  int32_t _offset;                       //!< Stack offset (calculated by `calculateStackFrame()`).
};

typedef ZoneVector<RAStackSlot*> RAStackSlots;

// ============================================================================
// [asmjit::RAStackAllocator]
// ============================================================================

//! Stack allocator.
class RAStackAllocator {
public:
  ASMJIT_NONCOPYABLE(RAStackAllocator)

  enum Size : uint32_t {
    kSize1     = 0,
    kSize2     = 1,
    kSize4     = 2,
    kSize8     = 3,
    kSize16    = 4,
    kSize32    = 5,
    kSize64    = 6,
    kSizeCount = 7
  };

  inline RAStackAllocator() noexcept
    : _allocator(nullptr),
      _bytesUsed(0),
      _stackSize(0),
      _alignment(1),
      _slots() {}

  // --------------------------------------------------------------------------
  // [Init / Reset]
  // --------------------------------------------------------------------------

  inline void reset(ZoneAllocator* allocator) noexcept {
    _allocator = allocator;
    _bytesUsed = 0;
    _stackSize = 0;
    _alignment = 1;
    _slots.reset();
  }

  // --------------------------------------------------------------------------
  // [Accessors]
  // --------------------------------------------------------------------------

  inline ZoneAllocator* allocator() const noexcept { return _allocator; }

  inline uint32_t bytesUsed() const noexcept { return _bytesUsed; }
  inline uint32_t stackSize() const noexcept { return _stackSize; }
  inline uint32_t alignment() const noexcept { return _alignment; }

  inline RAStackSlots& slots() noexcept { return _slots; }
  inline const RAStackSlots& slots() const noexcept { return _slots; }
  inline uint32_t slotCount() const noexcept { return _slots.size(); }

  // --------------------------------------------------------------------------
  // [Slots]
  // --------------------------------------------------------------------------

  RAStackSlot* newSlot(uint32_t baseRegId, uint32_t size, uint32_t alignment, uint32_t flags = 0) noexcept;

  // --------------------------------------------------------------------------
  // [Utilities]
  // --------------------------------------------------------------------------

  Error calculateStackFrame() noexcept;
  Error adjustSlotOffsets(int32_t offset) noexcept;

  // --------------------------------------------------------------------------
  // [Members]
  // --------------------------------------------------------------------------

  ZoneAllocator* _allocator;             //!< Allocator used to allocate internal data.
  uint32_t _bytesUsed;                   //!< Count of bytes used by all slots.
  uint32_t _stackSize;                   //!< Calculated stack size (can be a bit greater than `_bytesUsed`).
  uint32_t _alignment;                   //!< Minimum stack alignment.
  RAStackSlots _slots;                   //!< Stack slots vector.
};

//! \}

ASMJIT_END_NAMESPACE

// [Guard]
#endif // !ASMJIT_DISABLE_COMPILER
#endif // _ASMJIT_CORE_RASTACK_P_H

```

`Avanguard/AsmJit/asmjit/core/stringbuilder.h`:

```h
// [AsmJit]
// Complete x86/x64 JIT and Remote Assembler for C++.
//
// [License]
// ZLIB - See LICENSE.md file in the package.

// [Guard]
#ifndef _ASMJIT_CORE_STRINGBUILDER_H
#define _ASMJIT_CORE_STRINGBUILDER_H

// [Dependencies]
#include "../core/memmgr.h"
#include "../core/zone.h"

ASMJIT_BEGIN_NAMESPACE

//! \addtogroup asmjit_core_support
//! \{

// ============================================================================
// [asmjit::StringBuilder]
// ============================================================================

//! String builder.
//!
//! String builder was designed to be able to build a string using append like
//! operation to append numbers, other strings, or signle characters. It can
//! allocate it's own buffer or use a buffer created on the stack.
//!
//! String builder contains method specific to AsmJit functionality, used for
//! logging or HTML output.
class StringBuilder {
public:
  ASMJIT_NONCOPYABLE(StringBuilder)

  //! \internal
  //!
  //! String operation.
  enum StringOp : uint32_t {
    kStringOpSet           = 0,           //!< Replace the current string by a given content.
    kStringOpAppend        = 1            //!< Append a given content to the current string.
  };

  //! \internal
  //!
  //! String format flags.
  enum StringFormatFlags : uint32_t {
    kStringFormatShowSign  = 0x00000001u,
    kStringFormatShowSpace = 0x00000002u,
    kStringFormatAlternate = 0x00000004u,
    kStringFormatSigned    = 0x80000000u
  };

  // --------------------------------------------------------------------------
  // [Construction / Destruction]
  // --------------------------------------------------------------------------

  inline StringBuilder() noexcept
    : _data(_embedded),
      _size(0),
      _capacity(0),
      _embeddedUInt(0) {}

  inline StringBuilder(Globals::Init_, size_t embeddedCapacity) noexcept
    : _data(_embedded),
      _size(0),
      _capacity(embeddedCapacity),
      _embeddedUInt(0) {}

  inline ~StringBuilder() noexcept {
    if (!isEmbedded())
      MemMgr::release(_data);
  }

  // --------------------------------------------------------------------------
  // [Accessors]
  // --------------------------------------------------------------------------

  //! Get null-terminated string data.
  inline char* data() noexcept { return _data; }
  //! Get null-terminated string data (const).
  inline const char* data() const noexcept { return _data; }

  //! Get whether the string is empty.
  inline bool empty() const noexcept { return _size == 0; }
  //! Get size.
  inline size_t size() const noexcept { return _size; }
  //! Get capacity.
  inline size_t capacity() const noexcept { return _capacity; }

  //! Get whether the string is using a small embedded buffer which is not dynamically allocated.
  inline bool isEmbedded() const noexcept { return _data == _embedded; }

  // --------------------------------------------------------------------------
  // [Prepare / Reserve]
  // --------------------------------------------------------------------------

  //! Prepare to set/append.
  ASMJIT_API char* prepare(uint32_t op, size_t size) noexcept;

  //! Reserve `to` bytes in string builder.
  ASMJIT_API Error reserve(size_t to) noexcept;

  // --------------------------------------------------------------------------
  // [Clear / Truncate]
  // --------------------------------------------------------------------------

  //! Clear the content in String builder.
  inline void clear() noexcept {
    _size = 0;
    _data[0] = '\0';
  }

  //! Truncate the string to `maxLen` characters.
  inline void truncate(size_t maxLen) noexcept {
    _size = std::min<size_t>(_size, maxLen);
  }

  // --------------------------------------------------------------------------
  // [Op]
  // --------------------------------------------------------------------------

  ASMJIT_API Error _opString(uint32_t op, const char* str, size_t size = Globals::kNullTerminated) noexcept;
  ASMJIT_API Error _opVFormat(uint32_t op, const char* fmt, std::va_list ap) noexcept;
  ASMJIT_API Error _opChar(uint32_t op, char c) noexcept;
  ASMJIT_API Error _opChars(uint32_t op, char c, size_t n) noexcept;
  ASMJIT_API Error _opNumber(uint32_t op, uint64_t i, uint32_t base = 0, size_t width = 0, uint32_t flags = 0) noexcept;
  ASMJIT_API Error _opHex(uint32_t op, const void* data, size_t size, char separator = '\0') noexcept;

  // --------------------------------------------------------------------------
  // [Set]
  // --------------------------------------------------------------------------

  //! Replace the current string with `str` having `size` characters (or possibly null terminated).
  inline Error setString(const char* str, size_t size = Globals::kNullTerminated) noexcept {
    return _opString(kStringOpSet, str, size);
  }

  //! Replace the current content by a formatted string `fmt`.
  inline Error setFormat(const char* fmt, ...) noexcept {
    Error result;
    std::va_list ap;

    va_start(ap, fmt);
    result = _opVFormat(kStringOpSet, fmt, ap);
    va_end(ap);

    return result;
  }

  //! Replace the current content by a formatted string `fmt` (va_list version).
  inline Error setFormatVA(const char* fmt, std::va_list ap) noexcept {
    return _opVFormat(kStringOpSet, fmt, ap);
  }

  //! Replace the current content by a single `c` character.
  inline Error setChar(char c) noexcept {
    return _opChar(kStringOpSet, c);
  }

  //! Replace the current content by `c` character `n` times.
  inline Error setChars(char c, size_t n) noexcept {
    return _opChars(kStringOpSet, c, n);
  }

  //! Replace the current content by a formatted integer `i` (signed).
  inline Error setInt(uint64_t i, uint32_t base = 0, size_t width = 0, uint32_t flags = 0) noexcept {
    return _opNumber(kStringOpSet, i, base, width, flags | kStringFormatSigned);
  }

  //! Replace the current content by a formatted integer `i` (unsigned).
  inline Error setUInt(uint64_t i, uint32_t base = 0, size_t width = 0, uint32_t flags = 0) noexcept {
    return _opNumber(kStringOpSet, i, base, width, flags);
  }

  //! Replace the current content by the given `data` converted to a HEX string.
  inline Error setHex(const void* data, size_t size, char separator = '\0') noexcept {
    return _opHex(kStringOpSet, data, size, separator);
  }

  // --------------------------------------------------------------------------
  // [Append]
  // --------------------------------------------------------------------------

  //! Append string `str` of size `size` (or possibly null terminated).
  inline Error appendString(const char* str, size_t size = Globals::kNullTerminated) noexcept {
    return _opString(kStringOpAppend, str, size);
  }

  //! Append a formatted string `fmt`.
  inline Error appendFormat(const char* fmt, ...) noexcept {
    Error result;
    std::va_list ap;

    va_start(ap, fmt);
    result = _opVFormat(kStringOpAppend, fmt, ap);
    va_end(ap);

    return result;
  }

  //! Append a formatted string `fmt` (va_list version).
  inline Error appendFormatVA(const char* fmt, std::va_list ap) noexcept {
    return _opVFormat(kStringOpAppend, fmt, ap);
  }

  //! Append a single `c` character.
  inline Error appendChar(char c) noexcept {
    return _opChar(kStringOpAppend, c);
  }

  //! Append `c` character `n` times.
  inline Error appendChars(char c, size_t n) noexcept {
    return _opChars(kStringOpAppend, c, n);
  }

  ASMJIT_API Error padEnd(size_t n, char c = ' ') noexcept;

  //! Append `i`.
  inline Error appendInt(int64_t i, uint32_t base = 0, size_t width = 0, uint32_t flags = 0) noexcept {
    return _opNumber(kStringOpAppend, uint64_t(i), base, width, flags | kStringFormatSigned);
  }

  //! Append `i`.
  inline Error appendUInt(uint64_t i, uint32_t base = 0, size_t width = 0, uint32_t flags = 0) noexcept {
    return _opNumber(kStringOpAppend, i, base, width, flags);
  }

  //! Append the given `data` converted to a HEX string.
  inline Error appendHex(const void* data, size_t size, char separator = '\0') noexcept {
    return _opHex(kStringOpAppend, data, size, separator);
  }

  // --------------------------------------------------------------------------
  // [Eq]
  // --------------------------------------------------------------------------

  //! Check for equality with other `str` of size `size`.
  ASMJIT_API bool eq(const char* str, size_t size = Globals::kNullTerminated) const noexcept;
  //! Check for equality with `other`.
  inline bool eq(const StringBuilder& other) const noexcept { return eq(other._data, other._size); }

  // --------------------------------------------------------------------------
  // [Operator Overload]
  // --------------------------------------------------------------------------

  inline bool operator==(const StringBuilder& other) const noexcept { return  eq(other); }
  inline bool operator!=(const StringBuilder& other) const noexcept { return !eq(other); }

  inline bool operator==(const char* str) const noexcept { return  eq(str); }
  inline bool operator!=(const char* str) const noexcept { return !eq(str); }

  // --------------------------------------------------------------------------
  // [Members]
  // --------------------------------------------------------------------------

  char* _data;                           //!< String data.
  size_t _size;                          //!< String size.
  size_t _capacity;                      //!< String capacity.

  union {
    uintptr_t _embeddedUInt;             //!< Embedded data casted to `uintptr_t`.
    char _embedded[sizeof(uintptr_t)];   //!< Embedded data for very small strings.
  };
};

// ============================================================================
// [asmjit::StringBuilderTmp]
// ============================================================================

//! Temporary string builder, has statically allocated `N` bytes.
template<size_t N>
class StringBuilderTmp : public StringBuilder {
public:
  ASMJIT_NONCOPYABLE(StringBuilderTmp<N>)

  // --------------------------------------------------------------------------
  // [Construction / Destruction]
  // --------------------------------------------------------------------------

  inline StringBuilderTmp() noexcept
    : StringBuilder(Globals::Init, ASMJIT_ARRAY_SIZE(_embedded) + ASMJIT_ARRAY_SIZE(_embeddedTmp)) {}

  // --------------------------------------------------------------------------
  // [Members]
  // --------------------------------------------------------------------------

  //! Embedded data (temporary extension to the `_embedded` data).
  char _embeddedTmp[size_t(N + 1 + sizeof(intptr_t)) & ~size_t(sizeof(intptr_t) - 1)];
};

//! \}

ASMJIT_END_NAMESPACE

// [Guard]
#endif // _ASMJIT_CORE_STRINGBUILDER_H

```

`Avanguard/AsmJit/asmjit/core/stringutils.h`:

```h
// [AsmJit]
// Complete x86/x64 JIT and Remote Assembler for C++.
//
// [License]
// ZLIB - See LICENSE.md file in the package.

// [Guard]
#ifndef _ASMJIT_CORE_STRINGUTILS_H
#define _ASMJIT_CORE_STRINGUTILS_H

// [Dependencies]
#include "../core/globals.h"

ASMJIT_BEGIN_NAMESPACE

//! \addtogroup asmjit_core_support
//! \{

// ============================================================================
// [asmjit::StaticString]
// ============================================================================

template<size_t N>
union StaticString {
  enum : uint32_t {
    kNumU32 = uint32_t((N + sizeof(uint32_t) - 1) / sizeof(uint32_t))
  };

  inline bool test(const char* other) const noexcept { return std::strcmp(str, other) == 0; }

  char str[kNumU32 * sizeof(uint32_t)];
  uint32_t u32[kNumU32];
};

// ============================================================================
// [asmjit::StringUtils]
// ============================================================================

namespace StringUtils {
  // \internal
  static constexpr uint32_t hashRound(uint32_t hash, uint32_t c) noexcept { return hash * 65599 + c; }

  // Get a hash of the given string `data` of size `size`. Size must be valid
  // as this function doesn't check for a null terminator and allows it in the
  // middle of the string.
  static inline uint32_t hashString(const char* data, size_t size) noexcept {
    uint32_t hashCode = 0;
    for (uint32_t i = 0; i < size; i++)
      hashCode = hashRound(hashCode, uint8_t(data[i]));
    return hashCode;
  }

  static ASMJIT_INLINE size_t strLen(const char* s, size_t maxSize) noexcept {
    size_t i = 0;
    while (i < maxSize && s[i] != '\0')
      i++;
    return i;
  }

  static ASMJIT_INLINE const char* findPackedString(const char* p, uint32_t id) noexcept {
    uint32_t i = 0;
    while (i < id) {
      while (p[0])
        p++;
      p++;
      i++;
    }
    return p;
  }

  //! Compare two instruction names.
  //!
  //! `a` is a null terminated instruction name from arch-specific `nameData[]` table.
  //! `b` is a non-null terminated instruction name passed to `Inst::idByName()`.
  static ASMJIT_INLINE int cmpInstName(const char* a, const char* b, size_t size) noexcept {
    for (size_t i = 0; i < size; i++) {
      int c = int(uint8_t(a[i])) - int(uint8_t(b[i]));
      if (c != 0) return c;
    }
    return int(uint8_t(a[size]));
  }
}

//! \}

ASMJIT_END_NAMESPACE

// [Guard]
#endif // _ASMJIT_CORE_STRINGUTILS_H

```

`Avanguard/AsmJit/asmjit/core/support.h`:

```h
// [AsmJit]
// Complete x86/x64 JIT and Remote Assembler for C++.
//
// [License]
// ZLIB - See LICENSE.md file in the package.

// [Guard]
#ifndef _ASMJIT_CORE_SUPPORT_H
#define _ASMJIT_CORE_SUPPORT_H

// [Dependencies]
#include "../core/globals.h"

#if ASMJIT_CXX_MSC
  #include <intrin.h>
#endif

ASMJIT_BEGIN_NAMESPACE

//! \addtogroup asmjit_core_support
//! \{

//! \internal
//!
//! Contains support classes and functions that may be used by AsmJit source
//! and header files. Anything defined here is considered internal and should
//! not be used outside of AsmJit and related projects like AsmTK.
namespace Support {

// ============================================================================
// [asmjit::Support - Architecture Features & Constraints]
// ============================================================================

using Globals::kByteOrderLE;
using Globals::kByteOrderBE;
using Globals::kByteOrderNative;

static constexpr bool kUnalignedAccess16 = ASMJIT_ARCH_X86 != 0;
static constexpr bool kUnalignedAccess32 = ASMJIT_ARCH_X86 != 0;
static constexpr bool kUnalignedAccess64 = ASMJIT_ARCH_X86 != 0;

// ============================================================================
// [asmjit::Support - Internal]
// ============================================================================

namespace Internal {
  template<typename T, size_t Alignment>
  struct AlignedInt {};

  template<> struct AlignedInt<uint16_t, 1> { typedef uint16_t ASMJIT_ALIGN_TYPE(T, 1); };
  template<> struct AlignedInt<uint16_t, 2> { typedef uint16_t T; };
  template<> struct AlignedInt<uint32_t, 1> { typedef uint32_t ASMJIT_ALIGN_TYPE(T, 1); };
  template<> struct AlignedInt<uint32_t, 2> { typedef uint32_t ASMJIT_ALIGN_TYPE(T, 2); };
  template<> struct AlignedInt<uint32_t, 4> { typedef uint32_t T; };
  template<> struct AlignedInt<uint64_t, 1> { typedef uint64_t ASMJIT_ALIGN_TYPE(T, 1); };
  template<> struct AlignedInt<uint64_t, 2> { typedef uint64_t ASMJIT_ALIGN_TYPE(T, 2); };
  template<> struct AlignedInt<uint64_t, 4> { typedef uint64_t ASMJIT_ALIGN_TYPE(T, 4); };
  template<> struct AlignedInt<uint64_t, 8> { typedef uint64_t T; };

  // IntBySize - Make an int-type by size (signed or unsigned) that is the
  //             same as types defined by <stdint.h>.
  // Int32Or64 - Make an int-type that has at least 32 bits: [u]int[32|64]_t.

  template<size_t SIZE, int IS_SIGNED>
  struct IntBySize {}; // Fail if not specialized.

  template<> struct IntBySize<1, 0> { typedef uint8_t  Type; };
  template<> struct IntBySize<1, 1> { typedef int8_t   Type; };
  template<> struct IntBySize<2, 0> { typedef uint16_t Type; };
  template<> struct IntBySize<2, 1> { typedef int16_t  Type; };
  template<> struct IntBySize<4, 0> { typedef uint32_t Type; };
  template<> struct IntBySize<4, 1> { typedef int32_t  Type; };
  template<> struct IntBySize<8, 0> { typedef uint64_t Type; };
  template<> struct IntBySize<8, 1> { typedef int64_t  Type; };

  template<typename T, int IS_SIGNED = std::is_signed<T>::value>
  struct Int32Or64 : public IntBySize<sizeof(T) <= 4 ? size_t(4) : sizeof(T), IS_SIGNED> {};
}

// ============================================================================
// [asmjit::Support - FastUInt8]
// ============================================================================

#if ASMJIT_ARCH_X86
typedef uint8_t FastUInt8;
#else
typedef unsigned int FastUInt8;
#endif

// ============================================================================
// [asmjit::Support - IntBySize / Int32Or64]
// ============================================================================

//! Cast an integer `x` to either `int32_t` or `int64_t` depending on `T`.
template<typename T>
constexpr typename Internal::Int32Or64<T, 1>::Type asInt(T x) noexcept { return (typename Internal::Int32Or64<T, 1>::Type)x; }

//! Cast an integer `x` to either `uint32_t` or `uint64_t` depending on `T`.
template<typename T>
constexpr typename Internal::Int32Or64<T, 0>::Type asUInt(T x) noexcept { return (typename Internal::Int32Or64<T, 0>::Type)x; }

//! Cast an integer `x` to either `int32_t`, uint32_t`, `int64_t`, or `uint64_t` depending on `T`.
template<typename T>
constexpr typename Internal::Int32Or64<T>::Type asNormalized(T x) noexcept { return (typename Internal::Int32Or64<T>::Type)x; }

// ============================================================================
// [asmjit::Support - BitCast]
// ============================================================================

namespace Internal {
  template<typename DstT, typename SrcT>
  union BitCast {
    constexpr BitCast(SrcT src) noexcept : src(src) {}
    SrcT src;
    DstT dst;
  };
}

//! Bit-cast `SrcT` to `DstT`.
//!
//! Useful to bitcast between integer and floating point.
template<typename DstT, typename SrcT>
constexpr DstT bitCast(const SrcT& x) noexcept { return Internal::BitCast<DstT, SrcT>(x).dst; }

// ============================================================================
// [asmjit::Support - BitSizeOf]
// ============================================================================

template<typename T>
constexpr uint32_t bitSizeOf() noexcept { return uint32_t(sizeof(T) * 8u); }

// ============================================================================
// [asmjit::Support - BitWord]
// ============================================================================

//! Storage used to store a pack of bits (should by compatible with a machine word).
typedef Internal::IntBySize<sizeof(uintptr_t), 0>::Type BitWord;

//! Number of bits stored in a single `BitWord`.
constexpr uint32_t kBitWordSizeInBits = bitSizeOf<BitWord>();

// ============================================================================
// [asmjit::Support - BitUtilities]
// ============================================================================

//! Returns `0 - x` in a safe way (no undefined behavior), works for unsigned numbers as well.
template<typename T>
constexpr T neg(const T& x) noexcept {
  typedef typename std::make_unsigned<T>::type U;
  return T(U(0) - U(x));
}

template<typename T>
constexpr T allOnes() noexcept { return neg<T>(T(1)); }

//! Returns `x << y` (shift left logical) by explicitly casting `x` to an unsigned type and back.
template<typename X, typename Y>
constexpr X shl(const X& x, const Y& y) noexcept {
  typedef typename std::make_unsigned<X>::type U;
  return X(U(x) << y);
}

//! Returns `x >> y` (shift right logical) by explicitly casting `x` to an unsigned type and back.
template<typename X, typename Y>
constexpr X shr(const X& x, const Y& y) noexcept {
  typedef typename std::make_unsigned<X>::type U;
  return X(U(x) >> y);
}

//! Returns `x >> y` (shift right arithmetic) by explicitly casting `x` to a signed type and back.
template<typename X, typename Y>
constexpr X sar(const X& x, const Y& y) noexcept {
  typedef typename std::make_signed<X>::type S;
  return X(S(x) >> y);
}

//! Returns `x | (x >> y)` - helper used by some bit manipulation helpers.
template<typename X, typename Y>
constexpr X or_shr(const X& x, const Y& y) noexcept { return X(x | shr(x, y)); }

//! Returns `x & -x` - extracts lowest set isolated bit (like BLSI instruction).
template<typename T>
constexpr T blsi(T x) noexcept {
  typedef typename std::make_unsigned<T>::type U;
  return T(U(x) & neg(U(x)));
}

//! Returns `x & (x - 1)` - resets lowest set bit (like BLSR instruction).
template<typename T>
constexpr T blsr(T x) noexcept {
  typedef typename std::make_unsigned<T>::type U;
  return T(U(x) & (U(x) - U(1)));
}

//! Generate a trailing bit-mask that has `n` least significant (trailing) bits set.
template<typename T, typename CountT>
constexpr T lsbMask(CountT n) noexcept {
  typedef typename std::make_unsigned<T>::type U;
  return (sizeof(U) < sizeof(uintptr_t))
    ? T(U((uintptr_t(1) << n) - uintptr_t(1)))
    // Shifting more bits than the type provides is UNDEFINED BEHAVIOR.
    // In such case we trash the result by ORing it with a mask that has
    // all bits set and discards the UNDEFINED RESULT of the shift.
    : T(((U(1) << n) - U(1u)) | neg(U(n >= CountT(bitSizeOf<T>()))));
}

//! Get whether `x` has Nth bit set.
template<typename T, typename IndexT>
constexpr bool bitTest(T x, IndexT n) noexcept {
  typedef typename std::make_unsigned<T>::type U;
  return (U(x) & (U(1) << n)) != 0;
}

//! Get whether the `x` is a power of two (only one bit is set).
template<typename T>
constexpr bool isPowerOf2(T x) noexcept {
  typedef typename std::make_unsigned<T>::type U;
  return x && !(U(x) & (U(x) - U(1)));
}

//! Return a bit-mask that has `x` bit set.
template<typename T>
constexpr uint32_t mask(T x) noexcept { return (1u << x); }

//! Return a bit-mask that has `x` bit set (multiple arguments).
template<typename T, typename... ArgsT>
constexpr uint32_t mask(T x, ArgsT... args) noexcept { return mask(x) | mask(args...); }

//! Convert a boolean value `b` to zero or full mask (all bits set).
template<typename DstT, typename SrcT>
constexpr DstT bitMaskFromBool(SrcT b) noexcept {
  typedef typename std::make_unsigned<DstT>::type U;
  return DstT(U(0) - U(b));
}

namespace Internal {
  // Fill all trailing bits right from the first most significant bit set.
  constexpr uint8_t fillTrailingBitsImpl(uint8_t x) noexcept { return or_shr(or_shr(or_shr(x, 1), 2), 4); }
  // Fill all trailing bits right from the first most significant bit set.
  constexpr uint16_t fillTrailingBitsImpl(uint16_t x) noexcept { return or_shr(or_shr(or_shr(or_shr(x, 1), 2), 4), 8); }
  // Fill all trailing bits right from the first most significant bit set.
  constexpr uint32_t fillTrailingBitsImpl(uint32_t x) noexcept { return or_shr(or_shr(or_shr(or_shr(or_shr(x, 1), 2), 4), 8), 16); }
  // Fill all trailing bits right from the first most significant bit set.
  constexpr uint64_t fillTrailingBitsImpl(uint64_t x) noexcept { return or_shr(or_shr(or_shr(or_shr(or_shr(or_shr(x, 1), 2), 4), 8), 16), 32); }
}

// Fill all trailing bits right from the first most significant bit set.
template<typename T>
constexpr T fillTrailingBits(const T& x) noexcept {
  typedef typename std::make_unsigned<T>::type U;
  return T(Internal::fillTrailingBitsImpl(U(x)));
}

// ============================================================================
// [asmjit::Support - CTZ]
// ============================================================================

namespace Internal {
  constexpr uint32_t ctzGenericImpl(uint32_t xAndNegX) noexcept {
    return 31 - ((xAndNegX & 0x0000FFFFu) ? 16 : 0)
              - ((xAndNegX & 0x00FF00FFu) ?  8 : 0)
              - ((xAndNegX & 0x0F0F0F0Fu) ?  4 : 0)
              - ((xAndNegX & 0x33333333u) ?  2 : 0)
              - ((xAndNegX & 0x55555555u) ?  1 : 0);
  }

  constexpr uint32_t ctzGenericImpl(uint64_t xAndNegX) noexcept {
    return 63 - ((xAndNegX & 0x00000000FFFFFFFFu) ? 32 : 0)
              - ((xAndNegX & 0x0000FFFF0000FFFFu) ? 16 : 0)
              - ((xAndNegX & 0x00FF00FF00FF00FFu) ?  8 : 0)
              - ((xAndNegX & 0x0F0F0F0F0F0F0F0Fu) ?  4 : 0)
              - ((xAndNegX & 0x3333333333333333u) ?  2 : 0)
              - ((xAndNegX & 0x5555555555555555u) ?  1 : 0);
  }

  template<typename T>
  constexpr T ctzGeneric(T x) noexcept {
    return ctzGenericImpl(x & neg(x));
  }

  static ASMJIT_INLINE uint32_t ctz(uint32_t x) noexcept {
    #if ASMJIT_CXX_MSC && (ASMJIT_ARCH_X86 || ASMJIT_ARCH_ARM)
    unsigned long i;
    _BitScanForward(&i, x);
    return uint32_t(i);
    #elif ASMJIT_CXX_GNU
    return uint32_t(__builtin_ctz(x));
    #else
    return ctzGeneric(x);
    #endif
  }

  static ASMJIT_INLINE uint32_t ctz(uint64_t x) noexcept {
    #if ASMJIT_CXX_MSC && (ASMJIT_ARCH_X86 == 64 || ASMJIT_ARCH_ARM == 64)
    unsigned long i;
    _BitScanForward64(&i, x);
    return uint32_t(i);
    #elif ASMJIT_CXX_GNU
    return uint32_t(__builtin_ctzll(x));
    #else
    return (uint32_t)ctzGeneric(x);
    #endif
  }
}

//! Count trailing zeros in `x` (returns a position of a first bit set in `x`).
//!
//! NOTE: The input MUST NOT be zero, otherwise the result is undefined.
template<typename T>
static inline uint32_t ctz(T x) noexcept { return Internal::ctz(asUInt(x)); }

template<uint64_t N>
struct StaticCtz {
  enum {
    _kTmp1 = 0      + (((N            ) & uint64_t(0xFFFFFFFFu)) == 0 ? 32 : 0),
    _kTmp2 = _kTmp1 + (((N >> (_kTmp1)) & uint64_t(0x0000FFFFu)) == 0 ? 16 : 0),
    _kTmp3 = _kTmp2 + (((N >> (_kTmp2)) & uint64_t(0x000000FFu)) == 0 ?  8 : 0),
    _kTmp4 = _kTmp3 + (((N >> (_kTmp3)) & uint64_t(0x0000000Fu)) == 0 ?  4 : 0),
    _kTmp5 = _kTmp4 + (((N >> (_kTmp4)) & uint64_t(0x00000003u)) == 0 ?  2 : 0),
    kValue = _kTmp5 + (((N >> (_kTmp5)) & uint64_t(0x00000001u)) == 0 ?  1 : 0)
  };
};

template<>
struct StaticCtz<0> {}; // Undefined.

template<uint64_t N>
constexpr uint32_t staticCtz() noexcept { return StaticCtz<N>::kValue; }

// ============================================================================
// [asmjit::Support - PopCnt]
// ============================================================================

// Based on the following resource:
//   http://graphics.stanford.edu/~seander/bithacks.html
//
// Alternatively, for a very small number of bits in `x`:
//   uint32_t n = 0;
//   while (x) {
//     x &= x - 1;
//     n++;
//   }
//   return n;

static inline uint32_t _popcntGeneric(uint32_t x) noexcept {
  x = x - ((x >> 1) & 0x55555555u);
  x = (x & 0x33333333u) + ((x >> 2) & 0x33333333u);
  return (((x + (x >> 4)) & 0x0F0F0F0Fu) * 0x01010101u) >> 24;
}

static inline uint32_t _popcntGeneric(uint64_t x) noexcept {
  if (ASMJIT_ARCH_BITS >= 64) {
    x = x - ((x >> 1) & 0x5555555555555555u);
    x = (x & 0x3333333333333333u) + ((x >> 2) & 0x3333333333333333u);
    return uint32_t((((x + (x >> 4)) & 0x0F0F0F0F0F0F0F0Fu) * 0x0101010101010101u) >> 56);
  }
  else {
    return _popcntGeneric(uint32_t(x >> 32)) +
           _popcntGeneric(uint32_t(x & 0xFFFFFFFFu));
  }
}

static inline uint32_t _popcntImpl(uint32_t x) noexcept {
  #if ASMJIT_CXX_GNU
  return uint32_t(__builtin_popcount(x));
  #else
  return _popcntGeneric(asUInt(x));
  #endif
}

static inline uint32_t _popcntImpl(uint64_t x) noexcept {
  #if ASMJIT_CXX_GNU
  return uint32_t(__builtin_popcountll(x));
  #else
  return _popcntGeneric(asUInt(x));
  #endif
}

//! Get count of bits in `x`.
template<typename T>
static inline uint32_t popcnt(T x) noexcept { return _popcntImpl(asUInt(x)); }

// ============================================================================
// [asmjit::Support - SignExtend]
// ============================================================================

template<typename T>
constexpr T signExtendI8(T imm) noexcept { return int64_t(int8_t(imm & T(0xFF))); }

template<typename T>
constexpr T signExtendI16(T imm) noexcept { return int64_t(int16_t(imm & T(0xFFFF))); }

template<typename T>
constexpr T signExtendI32(T imm) noexcept { return int64_t(int32_t(imm & T(0xFFFFFFFF))); }

// ============================================================================
// [asmjit::Support - Alignment]
// ============================================================================

template<typename X, typename Y>
constexpr bool isAligned(X base, Y alignment) noexcept {
  typedef typename Internal::IntBySize<sizeof(X), 0>::Type U;
  return ((U)base % (U)alignment) == 0;
}

template<typename X, typename Y>
constexpr X alignUp(X x, Y alignment) noexcept {
  typedef typename Internal::IntBySize<sizeof(X), 0>::Type U;
  return (X)( ((U)x + ((U)(alignment) - 1u)) & ~((U)(alignment) - 1u) );
}

template<typename X, typename Y>
constexpr X alignDown(X x, Y alignment) noexcept {
  typedef typename Internal::IntBySize<sizeof(X), 0>::Type U;
  return (X)( (U)x & ~((U)(alignment) - 1u) );
}

//! Get zero or a positive difference between `base` and `base` when aligned to `alignment`.
template<typename X, typename Y>
constexpr typename Internal::IntBySize<sizeof(X), 0>::Type alignUpDiff(X base, Y alignment) noexcept {
  typedef typename Internal::IntBySize<sizeof(X), 0>::Type U;
  return alignUp(U(base), alignment) - U(base);
}

template<typename T>
constexpr T alignUpPowerOf2(T x) noexcept {
  typedef typename Internal::IntBySize<sizeof(T), 0>::Type U;
  return (T)(fillTrailingBits(U(x) - 1u) + 1u);
}

// ============================================================================
// [asmjit::Support - NumGranularized]
// ============================================================================

//! Calculate the number of elements that would be required if `base` is
//! granularized by `granularity`. This function can be used to calculate
//! the number of BitWords to represent N bits, for example.
template<typename X, typename Y>
constexpr X numGranularized(X base, Y granularity) noexcept {
  typedef typename Internal::IntBySize<sizeof(X), 0>::Type U;
  return X((U(base) + U(granularity) - 1) / U(granularity));
}

// ============================================================================
// [asmjit::Support - IsBetween]
// ============================================================================

//! Get whether `x` is greater than or equal to `a` and lesses than or equal to `b`.
template<typename T>
constexpr bool isBetween(const T& x, const T& a, const T& b) noexcept {
  return x >= a && x <= b;
}

// ============================================================================
// [asmjit::Support - IsInt / IsUInt]
// ============================================================================

//! Get whether the given integer `x` can be casted to a 4-bit signed integer.
template<typename T>
constexpr bool isInt4(T x) noexcept {
  typedef typename std::make_signed<T>::type S;
  typedef typename std::make_unsigned<T>::type U;

  return std::is_signed<T>::value ? isBetween<S>(S(x), -8, 7)
                                  : U(x) <= U(7u);
}

//! Get whether the given integer `x` can be casted to an 8-bit signed integer.
template<typename T>
constexpr bool isI8(T x) noexcept {
  typedef typename std::make_signed<T>::type S;
  typedef typename std::make_unsigned<T>::type U;

  return std::is_signed<T>::value ? sizeof(T) <= 1 || isBetween<S>(S(x), -128, 127)
                                  : U(x) <= U(127u);
}

//! Get whether the given integer `x` can be casted to a 16-bit signed integer.
template<typename T>
constexpr bool isI16(T x) noexcept {
  typedef typename std::make_signed<T>::type S;
  typedef typename std::make_unsigned<T>::type U;

  return std::is_signed<T>::value ? sizeof(T) <= 2 || isBetween<S>(S(x), -32768, 32767)
                                  : sizeof(T) <= 1 || U(x) <= U(32767u);
}

//! Get whether the given integer `x` can be casted to a 32-bit signed integer.
template<typename T>
constexpr bool isI32(T x) noexcept {
  typedef typename std::make_signed<T>::type S;
  typedef typename std::make_unsigned<T>::type U;

  return std::is_signed<T>::value ? sizeof(T) <= 4 || isBetween<S>(S(x), -2147483647 - 1, 2147483647)
                                  : sizeof(T) <= 2 || U(x) <= U(2147483647u);
}

//! Get whether the given integer `x` can be casted to a 4-bit unsigned integer.
template<typename T>
constexpr bool isUInt4(T x) noexcept {
  typedef typename std::make_unsigned<T>::type U;

  return std::is_signed<T>::value ? x >= T(0) && x <= T(15)
                                  : U(x) <= U(15u);
}

//! Get whether the given integer `x` can be casted to an 8-bit unsigned integer.
template<typename T>
constexpr bool isU8(T x) noexcept {
  typedef typename std::make_unsigned<T>::type U;

  return std::is_signed<T>::value ? (sizeof(T) <= 1 || T(x) <= T(255)) && x >= T(0)
                                  : (sizeof(T) <= 1 || U(x) <= U(255u));
}

//! Get whether the given integer `x` can be casted to a 12-bit unsigned integer (ARM specific).
template<typename T>
constexpr bool isUInt12(T x) noexcept {
  typedef typename std::make_unsigned<T>::type U;

  return std::is_signed<T>::value ? (sizeof(T) <= 1 || T(x) <= T(4095)) && x >= T(0)
                                  : (sizeof(T) <= 1 || U(x) <= U(4095u));
}

//! Get whether the given integer `x` can be casted to a 16-bit unsigned integer.
template<typename T>
constexpr bool isU16(T x) noexcept {
  typedef typename std::make_unsigned<T>::type U;

  return std::is_signed<T>::value ? (sizeof(T) <= 2 || T(x) <= T(65535)) && x >= T(0)
                                  : (sizeof(T) <= 2 || U(x) <= U(65535u));
}

//! Get whether the given integer `x` can be casted to a 32-bit unsigned integer.
template<typename T>
constexpr bool isU32(T x) noexcept {
  typedef typename std::make_unsigned<T>::type U;

  return std::is_signed<T>::value ? (sizeof(T) <= 4 || T(x) <= T(4294967295u)) && x >= T(0)
                                  : (sizeof(T) <= 4 || U(x) <= U(4294967295u));
}

// ============================================================================
// [asmjit::Support - ByteSwap]
// ============================================================================

static inline uint32_t byteswap32(uint32_t x) noexcept {
  #if ASMJIT_CXX_MSC
    return uint32_t(_byteswap_ulong(x));
  #elif ASMJIT_CXX_GNU
    return __builtin_bswap32(x);
  #else
    return (x << 24) | (x >> 24) | ((x << 8) & 0x00FF0000u) | ((x >> 8) & 0x0000FF00);
  #endif
}

// ============================================================================
// [asmjit::Support - BytePack / Unpack]
// ============================================================================

//! Pack four 8-bit integer into a 32-bit integer as it is an array of `{b0,b1,b2,b3}`.
constexpr uint32_t bytepack32_4x8(uint32_t a, uint32_t b, uint32_t c, uint32_t d) noexcept {
  return ASMJIT_ARCH_LE ? (a | (b << 8) | (c << 16) | (d << 24))
                        : (d | (c << 8) | (b << 16) | (a << 24)) ;
}

template<typename T>
constexpr uint32_t unpackU32At0(T x) noexcept { return ASMJIT_ARCH_LE ? uint32_t(uint64_t(x) & 0xFFFFFFFFu) : uint32_t(uint64_t(x) >> 32); }
template<typename T>
constexpr uint32_t unpackU32At1(T x) noexcept { return ASMJIT_ARCH_BE ? uint32_t(uint64_t(x) & 0xFFFFFFFFu) : uint32_t(uint64_t(x) >> 32); }

// ============================================================================
// [asmjit::Support - Position of byte (in bit-shift)]
// ============================================================================

static inline uint32_t byteShiftOfDWordStruct(uint32_t index) noexcept {
  return ASMJIT_ARCH_LE ? index * 8 : (uint32_t(sizeof(uint32_t)) - 1u - index) * 8;
}

// ============================================================================
// [asmjit::Support - ASCII]
// ============================================================================

template<typename T>
constexpr T asciiToLower(T c) noexcept { return c ^ (T(c >= T('A') && c <= T('Z')) << 5); }

template<typename T>
constexpr T asciiToUpper(T c) noexcept { return c ^ (T(c >= T('a') && c <= T('z')) << 5); }

// ============================================================================
// [asmjit::Support - Read / Write]
// ============================================================================

static inline uint32_t readU8(const void* p) noexcept { return uint32_t(static_cast<const uint8_t*>(p)[0]); }
static inline int32_t readI8(const void* p) noexcept { return int32_t(static_cast<const int8_t*>(p)[0]); }

template<uint32_t BO, size_t Alignment>
static inline uint32_t readU16x(const void* p) noexcept {
  if (BO == kByteOrderNative && (kUnalignedAccess16 || Alignment >= 2)) {
    typedef typename Internal::AlignedInt<uint16_t, Alignment>::T U16AlignedToN;
    return uint32_t(static_cast<const U16AlignedToN*>(p)[0]);
  }
  else {
    uint32_t hi = readU8(static_cast<const uint8_t*>(p) + (BO == kByteOrderLE ? 1 : 0));
    uint32_t lo = readU8(static_cast<const uint8_t*>(p) + (BO == kByteOrderLE ? 0 : 1));
    return shl(hi, 8) | lo;
  }
}

template<uint32_t BO, size_t Alignment>
static inline int32_t readI16x(const void* p) noexcept {
  if (BO == kByteOrderNative && (kUnalignedAccess16 || Alignment >= 2)) {
    typedef typename Internal::AlignedInt<uint16_t, Alignment>::T U16AlignedToN;
    return int32_t(int16_t(static_cast<const U16AlignedToN*>(p)[0]));
  }
  else {
    int32_t hi = readI8(static_cast<const uint8_t*>(p) + (BO == kByteOrderLE ? 1 : 0));
    int32_t lo = readU8(static_cast<const uint8_t*>(p) + (BO == kByteOrderLE ? 0 : 1));
    return shl(hi, 8) | lo;
  }
}

template<uint32_t BO = kByteOrderNative>
static inline uint32_t readU24u(const void* p) noexcept {
  uint32_t b0 = readU8(static_cast<const uint8_t*>(p) + (BO == kByteOrderLE ? 2 : 0));
  uint32_t b1 = readU8(static_cast<const uint8_t*>(p) + (BO == kByteOrderLE ? 1 : 1));
  uint32_t b2 = readU8(static_cast<const uint8_t*>(p) + (BO == kByteOrderLE ? 0 : 2));
  return shl(b0, 16) | shl(b1, 8) | b2;
}

template<uint32_t BO, size_t Alignment>
static inline uint32_t readU32x(const void* p) noexcept {
  if (kUnalignedAccess32 || Alignment >= 4) {
    typedef typename Internal::AlignedInt<uint32_t, Alignment>::T U32AlignedToN;
    uint32_t x = static_cast<const U32AlignedToN*>(p)[0];
    return BO == kByteOrderNative ? x : byteswap32(x);
  }
  else {
    uint32_t hi = readU16x<BO, Alignment >= 2 ? size_t(2) : Alignment>(static_cast<const uint8_t*>(p) + (BO == kByteOrderLE ? 2 : 0));
    uint32_t lo = readU16x<BO, Alignment >= 2 ? size_t(2) : Alignment>(static_cast<const uint8_t*>(p) + (BO == kByteOrderLE ? 0 : 2));
    return shl(hi, 16) | lo;
  }
}

template<uint32_t BO, size_t Alignment>
static inline uint64_t readU64x(const void* p) noexcept {
  if (BO == kByteOrderNative && (kUnalignedAccess64 || Alignment >= 8)) {
    typedef typename Internal::AlignedInt<uint64_t, Alignment>::T U64AlignedToN;
    return static_cast<const U64AlignedToN*>(p)[0];
  }
  else {
    uint32_t hi = readU32x<BO, Alignment >= 4 ? size_t(4) : Alignment>(static_cast<const uint8_t*>(p) + (BO == kByteOrderLE ? 4 : 0));
    uint32_t lo = readU32x<BO, Alignment >= 4 ? size_t(4) : Alignment>(static_cast<const uint8_t*>(p) + (BO == kByteOrderLE ? 0 : 4));
    return shl(uint64_t(hi), 32) | lo;
  }
}

template<uint32_t BO, size_t Alignment>
static inline int32_t readI32x(const void* p) noexcept { return int32_t(readU32x<BO, Alignment>(p)); }

template<uint32_t BO, size_t Alignment>
static inline int64_t readI64x(const void* p) noexcept { return int64_t(readU64x<BO, Alignment>(p)); }

template<size_t Alignment> static inline int32_t readI16xLE(const void* p) noexcept { return readI16x<kByteOrderLE, Alignment>(p); }
template<size_t Alignment> static inline int32_t readI16xBE(const void* p) noexcept { return readI16x<kByteOrderBE, Alignment>(p); }
template<size_t Alignment> static inline uint32_t readU16xLE(const void* p) noexcept { return readU16x<kByteOrderLE, Alignment>(p); }
template<size_t Alignment> static inline uint32_t readU16xBE(const void* p) noexcept { return readU16x<kByteOrderBE, Alignment>(p); }
template<size_t Alignment> static inline int32_t readI32xLE(const void* p) noexcept { return readI32x<kByteOrderLE, Alignment>(p); }
template<size_t Alignment> static inline int32_t readI32xBE(const void* p) noexcept { return readI32x<kByteOrderBE, Alignment>(p); }
template<size_t Alignment> static inline uint32_t readU32xLE(const void* p) noexcept { return readU32x<kByteOrderLE, Alignment>(p); }
template<size_t Alignment> static inline uint32_t readU32xBE(const void* p) noexcept { return readU32x<kByteOrderBE, Alignment>(p); }
template<size_t Alignment> static inline int64_t readI64xLE(const void* p) noexcept { return readI64x<kByteOrderLE, Alignment>(p); }
template<size_t Alignment> static inline int64_t readI64xBE(const void* p) noexcept { return readI64x<kByteOrderBE, Alignment>(p); }
template<size_t Alignment> static inline uint64_t readU64xLE(const void* p) noexcept { return readU64x<kByteOrderLE, Alignment>(p); }
template<size_t Alignment> static inline uint64_t readU64xBE(const void* p) noexcept { return readU64x<kByteOrderBE, Alignment>(p); }

static inline int32_t readI16a(const void* p) noexcept { return readI16x<kByteOrderNative, 2>(p); }
static inline int32_t readI16u(const void* p) noexcept { return readI16x<kByteOrderNative, 1>(p); }
static inline uint32_t readU16a(const void* p) noexcept { return readU16x<kByteOrderNative, 2>(p); }
static inline uint32_t readU16u(const void* p) noexcept { return readU16x<kByteOrderNative, 1>(p); }

static inline int32_t readI16aLE(const void* p) noexcept { return readI16xLE<2>(p); }
static inline int32_t readI16uLE(const void* p) noexcept { return readI16xLE<1>(p); }
static inline uint32_t readU16aLE(const void* p) noexcept { return readU16xLE<2>(p); }
static inline uint32_t readU16uLE(const void* p) noexcept { return readU16xLE<1>(p); }

static inline int32_t readI16aBE(const void* p) noexcept { return readI16xBE<2>(p); }
static inline int32_t readI16uBE(const void* p) noexcept { return readI16xBE<1>(p); }
static inline uint32_t readU16aBE(const void* p) noexcept { return readU16xBE<2>(p); }
static inline uint32_t readU16uBE(const void* p) noexcept { return readU16xBE<1>(p); }

static inline uint32_t readU24uLE(const void* p) noexcept { return readU24u<kByteOrderLE>(p); }
static inline uint32_t readU24uBE(const void* p) noexcept { return readU24u<kByteOrderBE>(p); }

static inline int32_t readI32a(const void* p) noexcept { return readI32x<kByteOrderNative, 4>(p); }
static inline int32_t readI32u(const void* p) noexcept { return readI32x<kByteOrderNative, 1>(p); }
static inline uint32_t readU32a(const void* p) noexcept { return readU32x<kByteOrderNative, 4>(p); }
static inline uint32_t readU32u(const void* p) noexcept { return readU32x<kByteOrderNative, 1>(p); }

static inline int32_t readI32aLE(const void* p) noexcept { return readI32xLE<4>(p); }
static inline int32_t readI32uLE(const void* p) noexcept { return readI32xLE<1>(p); }
static inline uint32_t readU32aLE(const void* p) noexcept { return readU32xLE<4>(p); }
static inline uint32_t readU32uLE(const void* p) noexcept { return readU32xLE<1>(p); }

static inline int32_t readI32aBE(const void* p) noexcept { return readI32xBE<4>(p); }
static inline int32_t readI32uBE(const void* p) noexcept { return readI32xBE<1>(p); }
static inline uint32_t readU32aBE(const void* p) noexcept { return readU32xBE<4>(p); }
static inline uint32_t readU32uBE(const void* p) noexcept { return readU32xBE<1>(p); }

static inline int64_t readI64a(const void* p) noexcept { return readI64x<kByteOrderNative, 8>(p); }
static inline int64_t readI64u(const void* p) noexcept { return readI64x<kByteOrderNative, 1>(p); }
static inline uint64_t readU64a(const void* p) noexcept { return readU64x<kByteOrderNative, 8>(p); }
static inline uint64_t readU64u(const void* p) noexcept { return readU64x<kByteOrderNative, 1>(p); }

static inline int64_t readI64aLE(const void* p) noexcept { return readI64xLE<8>(p); }
static inline int64_t readI64uLE(const void* p) noexcept { return readI64xLE<1>(p); }
static inline uint64_t readU64aLE(const void* p) noexcept { return readU64xLE<8>(p); }
static inline uint64_t readU64uLE(const void* p) noexcept { return readU64xLE<1>(p); }

static inline int64_t readI64aBE(const void* p) noexcept { return readI64xBE<8>(p); }
static inline int64_t readI64uBE(const void* p) noexcept { return readI64xBE<1>(p); }
static inline uint64_t readU64aBE(const void* p) noexcept { return readU64xBE<8>(p); }
static inline uint64_t readU64uBE(const void* p) noexcept { return readU64xBE<1>(p); }

static inline void writeU8(void* p, uint32_t x) noexcept { static_cast<uint8_t*>(p)[0] = uint8_t(x & 0xFFu); }
static inline void writeI8(void* p, int32_t x) noexcept { static_cast<uint8_t*>(p)[0] = uint8_t(x & 0xFF); }

template<uint32_t BO, size_t Alignment>
static inline void writeU16x(void* p, uint32_t x) noexcept {
  if (BO == kByteOrderNative && (kUnalignedAccess16 || Alignment >= 2)) {
    typedef typename Internal::AlignedInt<uint16_t, Alignment>::T U16AlignedToN;
    static_cast<U16AlignedToN*>(p)[0] = uint16_t(x & 0xFFFFu);
  }
  else {
    static_cast<uint8_t*>(p)[0] = uint8_t((x >> (BO == kByteOrderLE ? 0 : 8)) & 0xFFu);
    static_cast<uint8_t*>(p)[1] = uint8_t((x >> (BO == kByteOrderLE ? 8 : 0)) & 0xFFu);
  }
}

template<uint32_t BO = kByteOrderNative>
static inline void writeU24u(void* p, uint32_t v) noexcept {
  static_cast<uint8_t*>(p)[0] = uint8_t((v >> (BO == kByteOrderLE ?  0 : 16)) & 0xFFu);
  static_cast<uint8_t*>(p)[1] = uint8_t((v >> (BO == kByteOrderLE ?  8 :  8)) & 0xFFu);
  static_cast<uint8_t*>(p)[2] = uint8_t((v >> (BO == kByteOrderLE ? 16 :  0)) & 0xFFu);
}

template<uint32_t BO, size_t Alignment>
static inline void writeU32x(void* p, uint32_t x) noexcept {
  if (kUnalignedAccess32 || Alignment >= 4) {
    typedef typename Internal::AlignedInt<uint32_t, Alignment>::T U32AlignedToN;
    static_cast<U32AlignedToN*>(p)[0] = (BO == kByteOrderNative) ? x : Support::byteswap32(x);
  }
  else {
    writeU16x<BO, Alignment >= 2 ? size_t(2) : Alignment>(static_cast<uint8_t*>(p) + 0, x >> (BO == kByteOrderLE ?  0 : 16));
    writeU16x<BO, Alignment >= 2 ? size_t(2) : Alignment>(static_cast<uint8_t*>(p) + 2, x >> (BO == kByteOrderLE ? 16 :  0));
  }
}

template<uint32_t BO, size_t Alignment>
static inline void writeU64x(void* p, uint64_t x) noexcept {
  if (BO == kByteOrderNative && (kUnalignedAccess64 || Alignment >= 8)) {
    typedef typename Internal::AlignedInt<uint64_t, Alignment>::T U64AlignedToN;
    static_cast<U64AlignedToN*>(p)[0] = x;
  }
  else {
    writeU32x<BO, Alignment >= 4 ? size_t(4) : Alignment>(static_cast<uint8_t*>(p) + 0, uint32_t((x >> (BO == kByteOrderLE ?  0 : 32)) & 0xFFFFFFFFu));
    writeU32x<BO, Alignment >= 4 ? size_t(4) : Alignment>(static_cast<uint8_t*>(p) + 4, uint32_t((x >> (BO == kByteOrderLE ? 32 :  0)) & 0xFFFFFFFFu));
  }
}

template<uint32_t BO, size_t Alignment> static inline void writeI16x(void* p, int32_t x) noexcept { writeU16x<BO, Alignment>(p, uint32_t(x)); }
template<uint32_t BO, size_t Alignment> static inline void writeI32x(void* p, int32_t x) noexcept { writeU32x<BO, Alignment>(p, uint32_t(x)); }
template<uint32_t BO, size_t Alignment> static inline void writeI64x(void* p, int64_t x) noexcept { writeU64x<BO, Alignment>(p, uint64_t(x)); }

template<size_t Alignment> static inline void writeI16xLE(void* p, int32_t x) noexcept { writeI16x<kByteOrderLE, Alignment>(p, x); }
template<size_t Alignment> static inline void writeI16xBE(void* p, int32_t x) noexcept { writeI16x<kByteOrderBE, Alignment>(p, x); }
template<size_t Alignment> static inline void writeU16xLE(void* p, uint32_t x) noexcept { writeU16x<kByteOrderLE, Alignment>(p, x); }
template<size_t Alignment> static inline void writeU16xBE(void* p, uint32_t x) noexcept { writeU16x<kByteOrderBE, Alignment>(p, x); }

template<size_t Alignment> static inline void writeI32xLE(void* p, int32_t x) noexcept { writeI32x<kByteOrderLE, Alignment>(p, x); }
template<size_t Alignment> static inline void writeI32xBE(void* p, int32_t x) noexcept { writeI32x<kByteOrderBE, Alignment>(p, x); }
template<size_t Alignment> static inline void writeU32xLE(void* p, uint32_t x) noexcept { writeU32x<kByteOrderLE, Alignment>(p, x); }
template<size_t Alignment> static inline void writeU32xBE(void* p, uint32_t x) noexcept { writeU32x<kByteOrderBE, Alignment>(p, x); }

template<size_t Alignment> static inline void writeI64xLE(void* p, int64_t x) noexcept { writeI64x<kByteOrderLE, Alignment>(p, x); }
template<size_t Alignment> static inline void writeI64xBE(void* p, int64_t x) noexcept { writeI64x<kByteOrderBE, Alignment>(p, x); }
template<size_t Alignment> static inline void writeU64xLE(void* p, uint64_t x) noexcept { writeU64x<kByteOrderLE, Alignment>(p, x); }
template<size_t Alignment> static inline void writeU64xBE(void* p, uint64_t x) noexcept { writeU64x<kByteOrderBE, Alignment>(p, x); }

static inline void writeI16a(void* p, int32_t x) noexcept { writeI16x<kByteOrderNative, 2>(p, x); }
static inline void writeI16u(void* p, int32_t x) noexcept { writeI16x<kByteOrderNative, 1>(p, x); }
static inline void writeU16a(void* p, uint32_t x) noexcept { writeU16x<kByteOrderNative, 2>(p, x); }
static inline void writeU16u(void* p, uint32_t x) noexcept { writeU16x<kByteOrderNative, 1>(p, x); }

static inline void writeI16aLE(void* p, int32_t x) noexcept { writeI16xLE<2>(p, x); }
static inline void writeI16uLE(void* p, int32_t x) noexcept { writeI16xLE<1>(p, x); }
static inline void writeU16aLE(void* p, uint32_t x) noexcept { writeU16xLE<2>(p, x); }
static inline void writeU16uLE(void* p, uint32_t x) noexcept { writeU16xLE<1>(p, x); }

static inline void writeI16aBE(void* p, int32_t x) noexcept { writeI16xBE<2>(p, x); }
static inline void writeI16uBE(void* p, int32_t x) noexcept { writeI16xBE<1>(p, x); }
static inline void writeU16aBE(void* p, uint32_t x) noexcept { writeU16xBE<2>(p, x); }
static inline void writeU16uBE(void* p, uint32_t x) noexcept { writeU16xBE<1>(p, x); }

static inline void writeU24uLE(void* p, uint32_t v) noexcept { writeU24u<kByteOrderLE>(p, v); }
static inline void writeU24uBE(void* p, uint32_t v) noexcept { writeU24u<kByteOrderBE>(p, v); }

static inline void writeI32a(void* p, int32_t x) noexcept { writeI32x<kByteOrderNative, 4>(p, x); }
static inline void writeI32u(void* p, int32_t x) noexcept { writeI32x<kByteOrderNative, 1>(p, x); }
static inline void writeU32a(void* p, uint32_t x) noexcept { writeU32x<kByteOrderNative, 4>(p, x); }
static inline void writeU32u(void* p, uint32_t x) noexcept { writeU32x<kByteOrderNative, 1>(p, x); }

static inline void writeI32aLE(void* p, int32_t x) noexcept { writeI32xLE<4>(p, x); }
static inline void writeI32uLE(void* p, int32_t x) noexcept { writeI32xLE<1>(p, x); }
static inline void writeU32aLE(void* p, uint32_t x) noexcept { writeU32xLE<4>(p, x); }
static inline void writeU32uLE(void* p, uint32_t x) noexcept { writeU32xLE<1>(p, x); }

static inline void writeI32aBE(void* p, int32_t x) noexcept { writeI32xBE<4>(p, x); }
static inline void writeI32uBE(void* p, int32_t x) noexcept { writeI32xBE<1>(p, x); }
static inline void writeU32aBE(void* p, uint32_t x) noexcept { writeU32xBE<4>(p, x); }
static inline void writeU32uBE(void* p, uint32_t x) noexcept { writeU32xBE<1>(p, x); }

static inline void writeI64a(void* p, int64_t x) noexcept { writeI64x<kByteOrderNative, 8>(p, x); }
static inline void writeI64u(void* p, int64_t x) noexcept { writeI64x<kByteOrderNative, 1>(p, x); }
static inline void writeU64a(void* p, uint64_t x) noexcept { writeU64x<kByteOrderNative, 8>(p, x); }
static inline void writeU64u(void* p, uint64_t x) noexcept { writeU64x<kByteOrderNative, 1>(p, x); }

static inline void writeI64aLE(void* p, int64_t x) noexcept { writeI64xLE<8>(p, x); }
static inline void writeI64uLE(void* p, int64_t x) noexcept { writeI64xLE<1>(p, x); }
static inline void writeU64aLE(void* p, uint64_t x) noexcept { writeU64xLE<8>(p, x); }
static inline void writeU64uLE(void* p, uint64_t x) noexcept { writeU64xLE<1>(p, x); }

static inline void writeI64aBE(void* p, int64_t x) noexcept { writeI64xBE<8>(p, x); }
static inline void writeI64uBE(void* p, int64_t x) noexcept { writeI64xBE<1>(p, x); }
static inline void writeU64aBE(void* p, uint64_t x) noexcept { writeU64xBE<8>(p, x); }
static inline void writeU64uBE(void* p, uint64_t x) noexcept { writeU64xBE<1>(p, x); }

// ============================================================================
// [asmjit::Support - Operators]
// ============================================================================

struct Set    { template<typename T> static inline T op(T x, T y) noexcept { ASMJIT_UNUSED(x); return  y; } };
struct SetNot { template<typename T> static inline T op(T x, T y) noexcept { ASMJIT_UNUSED(x); return ~y; } };
struct And    { template<typename T> static inline T op(T x, T y) noexcept { return  x &  y; } };
struct AndNot { template<typename T> static inline T op(T x, T y) noexcept { return  x & ~y; } };
struct NotAnd { template<typename T> static inline T op(T x, T y) noexcept { return ~x &  y; } };
struct Or     { template<typename T> static inline T op(T x, T y) noexcept { return  x |  y; } };
struct Xor    { template<typename T> static inline T op(T x, T y) noexcept { return  x ^  y; } };
struct Add    { template<typename T> static inline T op(T x, T y) noexcept { return  x +  y; } };
struct Sub    { template<typename T> static inline T op(T x, T y) noexcept { return  x -  y; } };
struct Min    { template<typename T> static inline T op(T x, T y) noexcept { return std::min<T>(x, y); } };
struct Max    { template<typename T> static inline T op(T x, T y) noexcept { return std::max<T>(x, y); } };

// ============================================================================
// [asmjit::Support - BitWordIterator]
// ============================================================================

//! Iterates over each bit in a number which is set to 1.
//!
//! Example of use:
//!
//! ```
//! uint32_t bitsToIterate = 0x110F;
//! Support::BitWordIterator<uint32_t> it(bitsToIterate);
//!
//! while (it.hasNext()) {
//!   uint32_t bitIndex = it.next();
//!   std::printf("Bit at %u is set\n", unsigned(bitIndex));
//! }
//! ```
template<typename T>
class BitWordIterator {
public:
  inline explicit BitWordIterator(T bitWord) noexcept
    : _bitWord(bitWord) {}

  inline void init(T bitWord) noexcept { _bitWord = bitWord; }
  inline bool hasNext() const noexcept { return _bitWord != 0; }

  inline uint32_t next() noexcept {
    ASMJIT_ASSERT(_bitWord != 0);
    uint32_t index = ctz(_bitWord);
    _bitWord ^= T(1u) << index;
    return index;
  }

  T _bitWord;
};

// ============================================================================
// [asmjit::Support - BitVectorOps]
// ============================================================================

namespace Internal {
  template<typename T, class OperatorT, class FullWordOpT>
  static inline void bitVectorOp(T* buf, size_t index, size_t count) noexcept {
    if (count == 0)
      return;

    const size_t kTSizeInBits = bitSizeOf<T>();
    size_t vecIndex = index / kTSizeInBits; // T[]
    size_t bitIndex = index % kTSizeInBits; // T[][]

    buf += vecIndex;

    // The first BitWord requires special handling to preserve bits outside the fill region.
    const T kFillMask = allOnes<T>();
    size_t firstNBits = std::min<size_t>(kTSizeInBits - bitIndex, count);

    buf[0] = OperatorT::op(buf[0], (kFillMask >> (kTSizeInBits - firstNBits)) << bitIndex);
    buf++;
    count -= firstNBits;

    // All bits between the first and last affected BitWords can be just filled.
    while (count >= kTSizeInBits) {
      buf[0] = FullWordOpT::op(buf[0], kFillMask);
      buf++;
      count -= kTSizeInBits;
    }

    // The last BitWord requires special handling as well
    if (count)
      buf[0] = OperatorT::op(buf[0], kFillMask >> (kTSizeInBits - count));
  }
}

//! Set bit in a bit-vector `buf` at `index`.
template<typename T>
static inline bool bitVectorGetBit(T* buf, size_t index) noexcept {
  const size_t kTSizeInBits = bitSizeOf<T>();

  size_t vecIndex = index / kTSizeInBits;
  size_t bitIndex = index % kTSizeInBits;

  return bool((buf[vecIndex] >> bitIndex) & 0x1u);
}

//! Set bit in a bit-vector `buf` at `index` to `value`.
template<typename T>
static inline void bitVectorSetBit(T* buf, size_t index, bool value) noexcept {
  const size_t kTSizeInBits = bitSizeOf<T>();

  size_t vecIndex = index / kTSizeInBits;
  size_t bitIndex = index % kTSizeInBits;

  T bitMask = T(1u) << bitIndex;
  if (value)
    buf[vecIndex] |= bitMask;
  else
    buf[vecIndex] &= ~bitMask;
}

//! Set bit in a bit-vector `buf` at `index` to `value`.
template<typename T>
static inline void bitVectorFlipBit(T* buf, size_t index) noexcept {
  const size_t kTSizeInBits = bitSizeOf<T>();

  size_t vecIndex = index / kTSizeInBits;
  size_t bitIndex = index % kTSizeInBits;

  T bitMask = T(1u) << bitIndex;
  buf[vecIndex] ^= bitMask;
}

//! Fill `count` bits in bit-vector `buf` starting at bit-index `index`.
template<typename T>
static inline void bitVectorFill(T* buf, size_t index, size_t count) noexcept { Internal::bitVectorOp<T, Or, Set>(buf, index, count); }

//! Clear `count` bits in bit-vector `buf` starting at bit-index `index`.
template<typename T>
static inline void bitVectorClear(T* buf, size_t index, size_t count) noexcept { Internal::bitVectorOp<T, AndNot, SetNot>(buf, index, count); }

template<typename T>
static inline size_t bitVectorIndexOf(T* buf, size_t start, bool value) noexcept {
  const size_t kTSizeInBits = bitSizeOf<T>();
  size_t vecIndex = start / kTSizeInBits; // T[]
  size_t bitIndex = start % kTSizeInBits; // T[][]

  T* p = buf + vecIndex;

  // We always look for zeros, if value is `true` we have to flip all bits before the search.
  const T kFillMask = allOnes<T>();
  const T kFlipMask = value ? T(0) : kFillMask;

  // The first BitWord requires special handling as there are some bits we want to ignore.
  T bits = (*p ^ kFlipMask) & (kFillMask << bitIndex);
  for (;;) {
    if (bits)
      return (size_t)(p - buf) * kTSizeInBits + ctz(bits);
    bits = *++p ^ kFlipMask;
  }
}

// ============================================================================
// [asmjit::Support - BitVectorIterator]
// ============================================================================

template<typename T>
class BitVectorIterator {
public:
  ASMJIT_INLINE BitVectorIterator(const T* data, size_t numBitWords, size_t start = 0) noexcept {
    init(data, numBitWords, start);
  }

  ASMJIT_INLINE void init(const T* data, size_t numBitWords, size_t start = 0) noexcept {
    const T* ptr = data + (start / bitSizeOf<T>());
    size_t idx = alignDown(start, bitSizeOf<T>());
    size_t end = numBitWords * bitSizeOf<T>();

    T bitWord = T(0);
    if (idx < end) {
      bitWord = *ptr++ & (allOnes<T>() << (start % bitSizeOf<T>()));
      while (!bitWord && (idx += bitSizeOf<T>()) < end)
        bitWord = *ptr++;
    }

    _ptr = ptr;
    _idx = idx;
    _end = end;
    _current = bitWord;
  }

  ASMJIT_INLINE bool hasNext() const noexcept {
    return _current != T(0);
  }

  ASMJIT_INLINE size_t next() noexcept {
    T bitWord = _current;
    ASMJIT_ASSERT(bitWord != T(0));

    uint32_t bit = ctz(bitWord);
    bitWord ^= T(1u) << bit;

    size_t n = _idx + bit;
    while (!bitWord && (_idx += bitSizeOf<T>()) < _end)
      bitWord = *_ptr++;

    _current = bitWord;
    return n;
  }

  ASMJIT_INLINE size_t peekNext() const noexcept {
    ASMJIT_ASSERT(_current != T(0));
    return _idx + ctz(_current);
  }

  const T* _ptr;
  size_t _idx;
  size_t _end;
  T _current;
};

// ============================================================================
// [asmjit::Support - BitVectorFlipIterator]
// ============================================================================

template<typename T>
class BitVectorFlipIterator {
public:
  ASMJIT_INLINE BitVectorFlipIterator(const T* data, size_t numBitWords, size_t start = 0, T xorMask = 0) noexcept {
    init(data, numBitWords, start, xorMask);
  }

  ASMJIT_INLINE void init(const T* data, size_t numBitWords, size_t start = 0, T xorMask = 0) noexcept {
    const T* ptr = data + (start / bitSizeOf<T>());
    size_t idx = alignDown(start, bitSizeOf<T>());
    size_t end = numBitWords * bitSizeOf<T>();

    T bitWord = T(0);
    if (idx < end) {
      bitWord = (*ptr++ ^ xorMask) & (allOnes<T>() << (start % bitSizeOf<T>()));
      while (!bitWord && (idx += bitSizeOf<T>()) < end)
        bitWord = *ptr++ ^ xorMask;
    }

    _ptr = ptr;
    _idx = idx;
    _end = end;
    _current = bitWord;
    _xorMask = xorMask;
  }

  ASMJIT_INLINE bool hasNext() const noexcept {
    return _current != T(0);
  }

  ASMJIT_INLINE size_t next() noexcept {
    T bitWord = _current;
    ASMJIT_ASSERT(bitWord != T(0));

    uint32_t bit = ctz(bitWord);
    bitWord ^= T(1u) << bit;

    size_t n = _idx + bit;
    while (!bitWord && (_idx += bitSizeOf<T>()) < _end)
      bitWord = *_ptr++ ^ _xorMask;

    _current = bitWord;
    return n;
  }

  ASMJIT_INLINE size_t nextAndFlip() noexcept {
    T bitWord = _current;
    ASMJIT_ASSERT(bitWord != T(0));

    uint32_t bit = ctz(bitWord);
    bitWord ^= allOnes<T>() << bit;
    _xorMask ^= allOnes<T>();

    size_t n = _idx + bit;
    while (!bitWord && (_idx += bitSizeOf<T>()) < _end)
      bitWord = *_ptr++ ^ _xorMask;

    _current = bitWord;
    return n;
  }

  ASMJIT_INLINE size_t peekNext() const noexcept {
    ASMJIT_ASSERT(_current != T(0));
    return _idx + ctz(_current);
  }

  const T* _ptr;
  size_t _idx;
  size_t _end;
  T _current;
  T _xorMask;
};

// ============================================================================
// [asmjit::Support - BitVectorOpIterator]
// ============================================================================

template<typename T, class OperatorT>
class BitVectorOpIterator {
public:
  static constexpr uint32_t kTSizeInBits = bitSizeOf<T>();

  ASMJIT_INLINE BitVectorOpIterator(const T* aData, const T* bData, size_t numBitWords, size_t start = 0) noexcept {
    init(aData, bData, numBitWords, start);
  }

  ASMJIT_INLINE void init(const T* aData, const T* bData, size_t numBitWords, size_t start = 0) noexcept {
    const T* aPtr = aData + (start / bitSizeOf<T>());
    const T* bPtr = bData + (start / bitSizeOf<T>());
    size_t idx = alignDown(start, bitSizeOf<T>());
    size_t end = numBitWords * bitSizeOf<T>();

    T bitWord = T(0);
    if (idx < end) {
      bitWord = OperatorT::op(*aPtr++, *bPtr++) & (allOnes<T>() << (start % bitSizeOf<T>()));
      while (!bitWord && (idx += kTSizeInBits) < end)
        bitWord = OperatorT::op(*aPtr++, *bPtr++);
    }

    _aPtr = aPtr;
    _bPtr = bPtr;
    _idx = idx;
    _end = end;
    _current = bitWord;
  }

  ASMJIT_INLINE bool hasNext() noexcept {
    return _current != T(0);
  }

  ASMJIT_INLINE size_t next() noexcept {
    T bitWord = _current;
    ASMJIT_ASSERT(bitWord != T(0));

    uint32_t bit = ctz(bitWord);
    bitWord ^= T(1u) << bit;

    size_t n = _idx + bit;
    while (!bitWord && (_idx += kTSizeInBits) < _end)
      bitWord = OperatorT::op(*_aPtr++, *_bPtr++);

    _current = bitWord;
    return n;
  }

  const T* _aPtr;
  const T* _bPtr;
  size_t _idx;
  size_t _end;
  T _current;
};

// ============================================================================
// [asmjit::Support - Sorting]
// ============================================================================

//! Sort order.
enum SortOrder : uint32_t {
  kSortAscending  = 0, //!< Ascending.
  kSortDescending = 1  //!< Descending.
};

//! A helper class that provides comparison of any user-defined type that
//! implements `<` and `>` operators (primitive types are supported as well).
template<uint32_t Order = kSortAscending>
struct Compare {
  template<typename A, typename B>
  inline int operator()(const A& a, const B& b) const noexcept {
    return (Order == kSortAscending) ? (a < b ? -1 : a > b ?  1 : 0)
                                     : (a < b ?  1 : a > b ? -1 : 0);
  }
};

//! Insertion sort.
template<typename T, typename CompareT = Compare<kSortAscending>>
static inline void iSort(T* base, size_t size, const CompareT& cmp = CompareT()) noexcept {
  for (T* pm = base + 1; pm < base + size; pm++)
    for (T* pl = pm; pl > base && cmp(pl[-1], pl[0]) > 0; pl--)
      std::swap(pl[-1], pl[0]);
}

namespace Internal {
  //! Quick-sort implementation.
  template<typename T, class CompareT>
  struct QSortImpl {
    static constexpr size_t kStackSize = 64 * 2;
    static constexpr size_t kISortThreshold = 7;

    // Based on "PDCLib - Public Domain C Library" and rewritten to C++.
    static void sort(T* base, size_t size, const CompareT& cmp) noexcept {
      T* end = base + size;
      T* stack[kStackSize];
      T** stackptr = stack;

      for (;;) {
        if ((size_t)(end - base) > kISortThreshold) {
          // We work from second to last - first will be pivot element.
          T* pi = base + 1;
          T* pj = end - 1;
          std::swap(base[(size_t)(end - base) / 2], base[0]);

          if (cmp(*pi  , *pj  ) > 0) std::swap(*pi  , *pj  );
          if (cmp(*base, *pj  ) > 0) std::swap(*base, *pj  );
          if (cmp(*pi  , *base) > 0) std::swap(*pi  , *base);

          // Now we have the median for pivot element, entering main loop.
          for (;;) {
            while (pi < pj   && cmp(*++pi, *base) < 0) continue; // Move `i` right until `*i >= pivot`.
            while (pj > base && cmp(*--pj, *base) > 0) continue; // Move `j` left  until `*j <= pivot`.

            if (pi > pj) break;
            std::swap(*pi, *pj);
          }

          // Move pivot into correct place.
          std::swap(*base, *pj);

          // Larger subfile base / end to stack, sort smaller.
          if (pj - base > end - pi) {
            // Left is larger.
            *stackptr++ = base;
            *stackptr++ = pj;
            base = pi;
          }
          else {
            // Right is larger.
            *stackptr++ = pi;
            *stackptr++ = end;
            end = pj;
          }
          ASMJIT_ASSERT(stackptr <= stack + kStackSize);
        }
        else {
          iSort(base, (size_t)(end - base), cmp);
          if (stackptr == stack)
            break;
          end = *--stackptr;
          base = *--stackptr;
        }
      }
    }
  };
}

//! Quick sort implementation.
//!
//! The main reason to provide a custom qsort implementation is that we needed
//! something that will never throw `bad_alloc` exception. This implementation
//! doesn't use dynamic memory allocation.
template<typename T, class CompareT = Compare<kSortAscending>>
static inline void qSort(T* base, size_t size, const CompareT& cmp = CompareT()) noexcept {
  Internal::QSortImpl<T, CompareT>::sort(base, size, cmp);
}

// ============================================================================
// [asmjit::Support - Iterators]
// ============================================================================

template<typename T>
class Iterator {
public:
  constexpr Iterator(T* p) noexcept : _p(p) {}
  constexpr Iterator(const Iterator& other) noexcept = default;

  inline Iterator& operator=(const Iterator& other) noexcept = default;

  inline Iterator operator+(size_t n) const noexcept { return Iterator(_p + n); }
  inline Iterator operator-(size_t n) const noexcept { return Iterator(_p - n); }

  inline Iterator& operator+=(size_t n) noexcept { _p += n; return *this; }
  inline Iterator& operator-=(size_t n) noexcept { _p -= n; return *this; }

  inline Iterator& operator++() noexcept { return operator+=(1); }
  inline Iterator& operator--() noexcept { return operator-=(1); }

  inline Iterator operator++(int) noexcept { T* prev = _p; operator+=(1); return Iterator(prev); }
  inline Iterator operator--(int) noexcept { T* prev = _p; operator-=(1); return Iterator(prev); }

  inline bool operator==(const Iterator& other) noexcept { return _p == other._p; }
  inline bool operator!=(const Iterator& other) noexcept { return _p != other._p; }

  inline T& operator*() const noexcept { return _p[0]; }

  T* _p;
};

template<typename T>
class ReverseIterator {
public:
  constexpr ReverseIterator(T* p) noexcept : _p(p) {}
  constexpr ReverseIterator(const ReverseIterator& other) noexcept = default;

  inline ReverseIterator& operator=(const ReverseIterator& other) noexcept = default;

  inline ReverseIterator operator+(size_t n) const noexcept { return ReverseIterator(_p + n); }
  inline ReverseIterator operator-(size_t n) const noexcept { return ReverseIterator(_p - n); }

  inline ReverseIterator& operator+=(size_t n) noexcept { _p -= n; return *this; }
  inline ReverseIterator& operator-=(size_t n) noexcept { _p += n; return *this; }

  inline ReverseIterator& operator++() noexcept { return operator+=(1); }
  inline ReverseIterator& operator--() noexcept { return operator-=(1); }

  inline ReverseIterator operator++(int) noexcept { T* prev = _p; operator+=(1); return ReverseIterator(prev); }
  inline ReverseIterator operator--(int) noexcept { T* prev = _p; operator-=(1); return ReverseIterator(prev); }

  inline bool operator==(const ReverseIterator& other) noexcept { return _p == other._p; }
  inline bool operator!=(const ReverseIterator& other) noexcept { return _p != other._p; }

  inline T& operator*() const noexcept { return _p[-1]; }

  T* _p;
};

// ============================================================================
// [asmjit::Support::Temporary]
// ============================================================================

//! Used to pass a temporary buffer to:
//!
//!   - Containers that use user-passed buffer as an initial storage (still can grow).
//!   - Zone allocator that would use the temporary buffer as a first block.
struct Temporary {
  // --------------------------------------------------------------------------
  // [Construction / Destruction]
  // --------------------------------------------------------------------------

  constexpr Temporary(const Temporary& other) noexcept = default;
  constexpr Temporary(void* data, size_t size) noexcept
    : _data(data),
      _size(size) {}

  // --------------------------------------------------------------------------
  // [Accessors]
  // --------------------------------------------------------------------------

  //! Get the storage.
  template<typename T = void>
  constexpr T* data() const noexcept { return static_cast<T*>(_data); }
  //! Get the storage size (capacity).
  constexpr size_t size() const noexcept { return _size; }

  // --------------------------------------------------------------------------
  // [Operator Overload]
  // --------------------------------------------------------------------------

  inline Temporary& operator=(const Temporary& other) noexcept = default;

  // --------------------------------------------------------------------------
  // [Members]
  // --------------------------------------------------------------------------

  void* _data;
  size_t _size;
};

} // Support namespace

//! \}

ASMJIT_END_NAMESPACE

// [Guard]
#endif // _ASMJIT_CORE_SUPPORT_H

```

`Avanguard/AsmJit/asmjit/core/target.h`:

```h
// [AsmJit]
// Complete x86/x64 JIT and Remote Assembler for C++.
//
// [License]
// ZLIB - See LICENSE.md file in the package.

// [Guard]
#ifndef _ASMJIT_CORE_TARGET_H
#define _ASMJIT_CORE_TARGET_H

// [Dependencies]
#include "../core/arch.h"
#include "../core/func.h"

ASMJIT_BEGIN_NAMESPACE

//! \addtogroup asmjit_core_api
//! \{

// ============================================================================
// [asmjit::CodeInfo]
// ============================================================================

//! Basic information about a code (or target). It describes its architecture,
//! code generation mode (or optimization level), and base address.
class CodeInfo {
public:
  // --------------------------------------------------------------------------
  // [Construction / Destruction]
  // --------------------------------------------------------------------------

  inline CodeInfo() noexcept
    : _archInfo(),
      _stackAlignment(0),
      _cdeclCallConv(CallConv::kIdNone),
      _stdCallConv(CallConv::kIdNone),
      _fastCallConv(CallConv::kIdNone),
      _baseAddress(Globals::kNoBaseAddress) {}

  inline explicit CodeInfo(uint32_t archId, uint32_t archMode = 0, uint64_t baseAddress = Globals::kNoBaseAddress) noexcept
    : _archInfo(archId, archMode),
      _stackAlignment(0),
      _cdeclCallConv(CallConv::kIdNone),
      _stdCallConv(CallConv::kIdNone),
      _fastCallConv(CallConv::kIdNone),
      _baseAddress(baseAddress) {}

  inline CodeInfo(const CodeInfo& other) noexcept { init(other); }

  // --------------------------------------------------------------------------
  // [Init / Reset]
  // --------------------------------------------------------------------------

  inline bool isInitialized() const noexcept {
    return _archInfo.archId() != ArchInfo::kIdNone;
  }

  inline void init(const CodeInfo& other) noexcept {
    std::memcpy(this, &other, sizeof(*this));
  }

  inline void init(uint32_t archId, uint32_t archMode = 0, uint64_t baseAddress = Globals::kNoBaseAddress) noexcept {
    _archInfo.init(archId, archMode);
    _stackAlignment = 0;
    _cdeclCallConv = CallConv::kIdNone;
    _stdCallConv = CallConv::kIdNone;
    _fastCallConv = CallConv::kIdNone;
    _baseAddress = baseAddress;
  }

  inline void reset() noexcept {
    _archInfo.reset();
    _stackAlignment = 0;
    _cdeclCallConv = CallConv::kIdNone;
    _stdCallConv = CallConv::kIdNone;
    _fastCallConv = CallConv::kIdNone;
    _baseAddress = Globals::kNoBaseAddress;
  }

  // --------------------------------------------------------------------------
  // [Architecture Information]
  // --------------------------------------------------------------------------

  //! Get architecture information, see `ArchInfo`.
  inline const ArchInfo& archInfo() const noexcept { return _archInfo; }

  //! Get architecture type, see `ArchInfo::Id`.
  inline uint32_t archId() const noexcept { return _archInfo.archId(); }
  //! Get architecture sub-type, see `ArchInfo::SubId`.
  inline uint32_t archSubId() const noexcept { return _archInfo.archSubId(); }
  //! Get a size of a GP register of the architecture the code is using.
  inline uint32_t gpSize() const noexcept { return _archInfo.gpSize(); }
  //! Get number of GP registers available of the architecture the code is using.
  inline uint32_t gpCount() const noexcept { return _archInfo.gpCount(); }

  // --------------------------------------------------------------------------
  // [High-Level Information]
  // --------------------------------------------------------------------------

  //! Get a natural stack alignment that must be honored (or 0 if not known).
  inline uint32_t stackAlignment() const noexcept { return _stackAlignment; }
  //! Set a natural stack alignment that must be honored.
  inline void setStackAlignment(uint32_t sa) noexcept { _stackAlignment = uint8_t(sa); }

  inline uint32_t cdeclCallConv() const noexcept { return _cdeclCallConv; }
  inline void setCdeclCallConv(uint32_t cc) noexcept { _cdeclCallConv = uint8_t(cc); }

  inline uint32_t stdCallConv() const noexcept { return _stdCallConv; }
  inline void setStdCallConv(uint32_t cc) noexcept { _stdCallConv = uint8_t(cc); }

  inline uint32_t fastCallConv() const noexcept { return _fastCallConv; }
  inline void setFastCallConv(uint32_t cc) noexcept { _fastCallConv = uint8_t(cc); }

  // --------------------------------------------------------------------------
  // [Addressing Information]
  // --------------------------------------------------------------------------

  inline bool hasBaseAddress() const noexcept { return _baseAddress != Globals::kNoBaseAddress; }
  inline uint64_t baseAddress() const noexcept { return _baseAddress; }
  inline void setBaseAddress(uint64_t p) noexcept { _baseAddress = p; }
  inline void resetBaseAddress() noexcept { _baseAddress = Globals::kNoBaseAddress; }

  // --------------------------------------------------------------------------
  // [Operator Overload]
  // --------------------------------------------------------------------------

  inline CodeInfo& operator=(const CodeInfo& other) noexcept = default;

  inline bool operator==(const CodeInfo& other) const noexcept { return std::memcmp(this, &other, sizeof(*this)) == 0; }
  inline bool operator!=(const CodeInfo& other) const noexcept { return std::memcmp(this, &other, sizeof(*this)) != 0; }

  // --------------------------------------------------------------------------
  // [Members]
  // --------------------------------------------------------------------------

  ArchInfo _archInfo;                    //!< Architecture information.
  uint8_t _stackAlignment;               //!< Natural stack alignment (ARCH+OS).
  uint8_t _cdeclCallConv;                //!< Default CDECL calling convention.
  uint8_t _stdCallConv;                  //!< Default STDCALL calling convention.
  uint8_t _fastCallConv;                 //!< Default FASTCALL calling convention.
  uint64_t _baseAddress;                 //!< Base address.
};

// ============================================================================
// [asmjit::Target]
// ============================================================================

//! Target is an abstract class that describes a compilation (asm) target.
class ASMJIT_VIRTAPI Target {
public:
  ASMJIT_NONCOPYABLE(Target)

  enum TargetType : uint32_t {
    kTargetNone   = 0,
    kTargetJit    = 1
  };

  // --------------------------------------------------------------------------
  // [Construction / Destruction]
  // --------------------------------------------------------------------------

  //! Create a `Target` instance.
  ASMJIT_API Target() noexcept;
  //! Destroy the `Target` instance.
  ASMJIT_API virtual ~Target() noexcept;

  // --------------------------------------------------------------------------
  // [Accessors]
  // --------------------------------------------------------------------------

  //! Get CodeInfo of this runtime.
  //!
  //! CodeInfo can be used to setup a CodeHolder in case you plan to generate a
  //! code compatible and executable by this Runtime.
  inline const CodeInfo& codeInfo() const noexcept { return _codeInfo; }

  //! Get the Runtime's architecture type, see `ArchInfo::Id`.
  inline uint32_t archId() const noexcept { return _codeInfo.archId(); }
  //! Get the Runtime's architecture sub-type, see `ArchInfo::SubId`.
  inline uint32_t archSubId() const noexcept { return _codeInfo.archSubId(); }

  //! Get target type, see `TargetType`.
  inline uint32_t targetType() const noexcept { return _targetType; }

  // --------------------------------------------------------------------------
  // [Members]
  // --------------------------------------------------------------------------

  uint8_t _targetType;                   //!< Tartget type, see `TargetType`.
  uint8_t _reserved[7];                  //!< \internal

  CodeInfo _codeInfo;                    //!< Basic information about the Runtime's code.
};

//! \}

ASMJIT_END_NAMESPACE

// [Guard]
#endif // _ASMJIT_CORE_TARGET_H

```

`Avanguard/AsmJit/asmjit/core/type.h`:

```h
// [AsmJit]
// Complete x86/x64 JIT and Remote Assembler for C++.
//
// [License]
// ZLIB - See LICENSE.md file in the package.

// [Guard]
#ifndef _ASMJIT_CORE_TYPE_H
#define _ASMJIT_CORE_TYPE_H

// [Dependencies]
#include "../core/globals.h"

ASMJIT_BEGIN_NAMESPACE

//! \addtogroup asmjit_core_api
//! \{

// ============================================================================
// [asmjit::Type]
// ============================================================================

namespace Type {

//! TypeId.
//!
//! This is an additional information that can be used to describe a value-type
//! of physical or virtual register. it's used mostly by BaseCompiler to describe
//! register representation (the group of data stored in the register and the
//! width used) and it's also used by APIs that allow to describe and work with
//! function signatures.
enum Id : uint32_t {
  kIdVoid         = 0,

  _kIdBaseStart   = 32,
  _kIdBaseEnd     = 44,

  _kIdIntStart    = 32,
  _kIdIntEnd      = 41,

  kIdIntPtr       = 32,
  kIdUIntPtr      = 33,

  kIdI8           = 34,
  kIdU8           = 35,
  kIdI16          = 36,
  kIdU16          = 37,
  kIdI32          = 38,
  kIdU32          = 39,
  kIdI64          = 40,
  kIdU64          = 41,

  _kIdFloatStart  = 42,
  _kIdFloatEnd    = 44,

  kIdF32          = 42,
  kIdF64          = 43,
  kIdF80          = 44,

  _kIdMaskStart   = 45,
  _kIdMaskEnd     = 48,

  kIdMask8        = 45,
  kIdMask16       = 46,
  kIdMask32       = 47,
  kIdMask64       = 48,

  _kIdMmxStart    = 49,
  _kIdMmxEnd      = 50,

  kIdMmx32        = 49,
  kIdMmx64        = 50,

  _kIdVec32Start  = 51,
  _kIdVec32End    = 60,

  kIdI8x4         = 51,
  kIdU8x4         = 52,
  kIdI16x2        = 53,
  kIdU16x2        = 54,
  kIdI32x1        = 55,
  kIdU32x1        = 56,
  kIdF32x1        = 59,

  _kIdVec64Start  = 61,
  _kIdVec64End    = 70,

  kIdI8x8         = 61,
  kIdU8x8         = 62,
  kIdI16x4        = 63,
  kIdU16x4        = 64,
  kIdI32x2        = 65,
  kIdU32x2        = 66,
  kIdI64x1        = 67,
  kIdU64x1        = 68,
  kIdF32x2        = 69,
  kIdF64x1        = 70,

  _kIdVec128Start = 71,
  _kIdVec128End   = 80,

  kIdI8x16        = 71,
  kIdU8x16        = 72,
  kIdI16x8        = 73,
  kIdU16x8        = 74,
  kIdI32x4        = 75,
  kIdU32x4        = 76,
  kIdI64x2        = 77,
  kIdU64x2        = 78,
  kIdF32x4        = 79,
  kIdF64x2        = 80,

  _kIdVec256Start = 81,
  _kIdVec256End   = 90,

  kIdI8x32        = 81,
  kIdU8x32        = 82,
  kIdI16x16       = 83,
  kIdU16x16       = 84,
  kIdI32x8        = 85,
  kIdU32x8        = 86,
  kIdI64x4        = 87,
  kIdU64x4        = 88,
  kIdF32x8        = 89,
  kIdF64x4        = 90,

  _kIdVec512Start = 91,
  _kIdVec512End   = 100,

  kIdI8x64        = 91,
  kIdU8x64        = 92,
  kIdI16x32       = 93,
  kIdU16x32       = 94,
  kIdI32x16       = 95,
  kIdU32x16       = 96,
  kIdI64x8        = 97,
  kIdU64x8        = 98,
  kIdF32x16       = 99,
  kIdF64x8        = 100,

  kIdCount        = 101,
  kIdMax          = 255
};

struct TypeData {
  uint8_t baseOf[kIdMax + 1];
  uint8_t sizeOf[kIdMax + 1];
};
ASMJIT_VARAPI const TypeData _typeData;

static constexpr bool isVoid(uint32_t typeId) noexcept { return typeId == 0; }
static constexpr bool isValid(uint32_t typeId) noexcept { return typeId >= _kIdIntStart && typeId <= _kIdVec512End; }
static constexpr bool isBase(uint32_t typeId) noexcept { return typeId >= _kIdBaseStart && typeId <= _kIdBaseEnd; }
static constexpr bool isAbstract(uint32_t typeId) noexcept { return typeId >= kIdIntPtr && typeId <= kIdUIntPtr; }

static constexpr bool isInt(uint32_t typeId) noexcept { return typeId >= _kIdIntStart && typeId <= _kIdIntEnd; }
static constexpr bool isI8(uint32_t typeId) noexcept { return typeId == kIdI8; }
static constexpr bool isU8(uint32_t typeId) noexcept { return typeId == kIdU8; }
static constexpr bool isI16(uint32_t typeId) noexcept { return typeId == kIdI16; }
static constexpr bool isU16(uint32_t typeId) noexcept { return typeId == kIdU16; }
static constexpr bool isI32(uint32_t typeId) noexcept { return typeId == kIdI32; }
static constexpr bool isU32(uint32_t typeId) noexcept { return typeId == kIdU32; }
static constexpr bool isI64(uint32_t typeId) noexcept { return typeId == kIdI64; }
static constexpr bool isU64(uint32_t typeId) noexcept { return typeId == kIdU64; }

static constexpr bool isGp8(uint32_t typeId) noexcept { return typeId >= kIdI8 && typeId <= kIdU8; }
static constexpr bool isGp16(uint32_t typeId) noexcept { return typeId >= kIdI16 && typeId <= kIdU16; }
static constexpr bool isGp32(uint32_t typeId) noexcept { return typeId >= kIdI32 && typeId <= kIdU32; }
static constexpr bool isGp64(uint32_t typeId) noexcept { return typeId >= kIdI64 && typeId <= kIdU64; }

static constexpr bool isFloat(uint32_t typeId) noexcept { return typeId >= _kIdFloatStart && typeId <= _kIdFloatEnd; }
static constexpr bool isF32(uint32_t typeId) noexcept { return typeId == kIdF32; }
static constexpr bool isF64(uint32_t typeId) noexcept { return typeId == kIdF64; }
static constexpr bool isF80(uint32_t typeId) noexcept { return typeId == kIdF80; }

static constexpr bool isMask(uint32_t typeId) noexcept { return typeId >= _kIdMaskStart && typeId <= _kIdMaskEnd; }
static constexpr bool isMask8(uint32_t typeId) noexcept { return typeId == kIdMask8; }
static constexpr bool isMask16(uint32_t typeId) noexcept { return typeId == kIdMask16; }
static constexpr bool isMask32(uint32_t typeId) noexcept { return typeId == kIdMask32; }
static constexpr bool isMask64(uint32_t typeId) noexcept { return typeId == kIdMask64; }

static constexpr bool isMmx(uint32_t typeId) noexcept { return typeId >= _kIdMmxStart && typeId <= _kIdMmxEnd; }
static constexpr bool isMmx32(uint32_t typeId) noexcept { return typeId == kIdMmx32; }
static constexpr bool isMmx64(uint32_t typeId) noexcept { return typeId == kIdMmx64; }

static constexpr bool isVec(uint32_t typeId) noexcept { return typeId >= _kIdVec32Start && typeId <= _kIdVec512End; }
static constexpr bool isVec32(uint32_t typeId) noexcept { return typeId >= _kIdVec32Start && typeId <= _kIdVec32End; }
static constexpr bool isVec64(uint32_t typeId) noexcept { return typeId >= _kIdVec64Start && typeId <= _kIdVec64End; }
static constexpr bool isVec128(uint32_t typeId) noexcept { return typeId >= _kIdVec128Start && typeId <= _kIdVec128End; }
static constexpr bool isVec256(uint32_t typeId) noexcept { return typeId >= _kIdVec256Start && typeId <= _kIdVec256End; }
static constexpr bool isVec512(uint32_t typeId) noexcept { return typeId >= _kIdVec512Start && typeId <= _kIdVec512End; }

//! IdOfT<> template allows to get a TypeId of a C++ type.
template<typename T> struct IdOfT {}; // Fail if not specialized.

template<typename T> struct IdOfT<T*> {
  static constexpr uint32_t kTypeId = kIdUIntPtr;
};

template<typename T>
struct IdOfIntT {
  static constexpr uint32_t kTypeId =
    sizeof(T) == 1 ? (std::is_signed<T>::value ? kIdI8  : kIdU8 ) :
    sizeof(T) == 2 ? (std::is_signed<T>::value ? kIdI16 : kIdU16) :
    sizeof(T) == 4 ? (std::is_signed<T>::value ? kIdI32 : kIdU32) :
    sizeof(T) == 8 ? (std::is_signed<T>::value ? kIdI64 : kIdU64) : kIdVoid;
};

template<uint32_t TYPE_ID>
struct BaseOfTypeId {
  static constexpr uint32_t kTypeId =
    isBase  (TYPE_ID) ? TYPE_ID :
    isMask8 (TYPE_ID) ? kIdU8   :
    isMask16(TYPE_ID) ? kIdU16  :
    isMask32(TYPE_ID) ? kIdU32  :
    isMask64(TYPE_ID) ? kIdU64  :
    isMmx32 (TYPE_ID) ? kIdI32  :
    isMmx64 (TYPE_ID) ? kIdI64  :
    isVec32 (TYPE_ID) ? TYPE_ID + kIdI8 - _kIdVec32Start  :
    isVec64 (TYPE_ID) ? TYPE_ID + kIdI8 - _kIdVec64Start  :
    isVec128(TYPE_ID) ? TYPE_ID + kIdI8 - _kIdVec128Start :
    isVec256(TYPE_ID) ? TYPE_ID + kIdI8 - _kIdVec256Start :
    isVec512(TYPE_ID) ? TYPE_ID + kIdI8 - _kIdVec512Start : 0;
};

template<uint32_t TYPE_ID>
struct SizeOfTypeId {
  static constexpr uint32_t kTypeSize =
    isI8    (TYPE_ID) ?  1 :
    isU8    (TYPE_ID) ?  1 :
    isI16   (TYPE_ID) ?  2 :
    isU16   (TYPE_ID) ?  2 :
    isI32   (TYPE_ID) ?  4 :
    isU32   (TYPE_ID) ?  4 :
    isI64   (TYPE_ID) ?  8 :
    isU64   (TYPE_ID) ?  8 :
    isF32   (TYPE_ID) ?  4 :
    isF64   (TYPE_ID) ?  8 :
    isF80   (TYPE_ID) ? 10 :
    isMask8 (TYPE_ID) ?  1 :
    isMask16(TYPE_ID) ?  2 :
    isMask32(TYPE_ID) ?  4 :
    isMask64(TYPE_ID) ?  8 :
    isMmx32 (TYPE_ID) ?  4 :
    isMmx64 (TYPE_ID) ?  8 :
    isVec32 (TYPE_ID) ?  4 :
    isVec64 (TYPE_ID) ?  8 :
    isVec128(TYPE_ID) ? 16 :
    isVec256(TYPE_ID) ? 32 :
    isVec512(TYPE_ID) ? 64 : 0;
};

static inline uint32_t baseOf(uint32_t typeId) noexcept {
  ASMJIT_ASSERT(typeId <= kIdMax);
  return _typeData.baseOf[typeId];
}

static inline uint32_t sizeOf(uint32_t typeId) noexcept {
  ASMJIT_ASSERT(typeId <= kIdMax);
  return _typeData.sizeOf[typeId];
}

//! Get an offset to convert a `kIntPtr` and `kUIntPtr` TypeId into a
//! type that matches `gpSize` (general-purpose register size). If you
//! find such TypeId it's then only about adding the offset to it.
//!
//! For example:
//! ~~~
//! uint32_t gpSize = '4' or '8';
//! uint32_t deabstractDelta = Type::deabstractDeltaOfSize(gpSize);
//!
//! uint32_t typeId = 'some type-id';
//!
//! // Normalize some typeId into a non-abstract typeId.
//! if (Type::isAbstract(typeId)) typeId += deabstractDelta;
//!
//! // The same, but by using Type::deabstract() function.
//! typeId = Type::deabstract(typeId, deabstractDelta);
//! ~~~
static constexpr uint32_t deabstractDeltaOfSize(uint32_t gpSize) noexcept {
  return gpSize >= 8 ? kIdI64 - kIdIntPtr : kIdI32 - kIdIntPtr;
}

static constexpr uint32_t deabstract(uint32_t typeId, uint32_t deabstractDelta) noexcept {
  return isAbstract(typeId) ? typeId + deabstractDelta : typeId;
}

struct Bool {};                          //!< bool as C++ type-name.
struct I8   {};                          //!< int8_t as C++ type-name.
struct U8   {};                          //!< uint8_t as C++ type-name.
struct I16  {};                          //!< int16_t as C++ type-name.
struct U16  {};                          //!< uint16_t as C++ type-name.
struct I32  {};                          //!< int32_t as C++ type-name.
struct U32  {};                          //!< uint32_t as C++ type-name.
struct I64  {};                          //!< int64_t as C++ type-name.
struct U64  {};                          //!< uint64_t as C++ type-name.
struct IPtr {};                          //!< intptr_t as C++ type-name.
struct UPtr {};                          //!< uintptr_t as C++ type-name.
struct F32  {};                          //!< float as C++ type-name.
struct F64  {};                          //!< double as C++ type-name.

} // Type namespace

// ============================================================================
// [ASMJIT_DEFINE_TYPE_ID]
// ============================================================================

#define ASMJIT_DEFINE_TYPE_ID(T, TYPE_ID)        \
namespace Type {                                 \
  template<>                                     \
  struct IdOfT<T> {                              \
    static constexpr uint32_t kTypeId = TYPE_ID; \
  };                                             \
}

ASMJIT_DEFINE_TYPE_ID(bool              , IdOfIntT<bool              >::kTypeId);
ASMJIT_DEFINE_TYPE_ID(char              , IdOfIntT<char              >::kTypeId);
ASMJIT_DEFINE_TYPE_ID(signed char       , IdOfIntT<signed char       >::kTypeId);
ASMJIT_DEFINE_TYPE_ID(unsigned char     , IdOfIntT<unsigned char     >::kTypeId);
ASMJIT_DEFINE_TYPE_ID(short             , IdOfIntT<short             >::kTypeId);
ASMJIT_DEFINE_TYPE_ID(unsigned short    , IdOfIntT<unsigned short    >::kTypeId);
ASMJIT_DEFINE_TYPE_ID(int               , IdOfIntT<int               >::kTypeId);
ASMJIT_DEFINE_TYPE_ID(unsigned int      , IdOfIntT<unsigned int      >::kTypeId);
ASMJIT_DEFINE_TYPE_ID(long              , IdOfIntT<long              >::kTypeId);
ASMJIT_DEFINE_TYPE_ID(unsigned long     , IdOfIntT<unsigned long     >::kTypeId);
ASMJIT_DEFINE_TYPE_ID(long long         , IdOfIntT<long long         >::kTypeId);
ASMJIT_DEFINE_TYPE_ID(unsigned long long, IdOfIntT<unsigned long long>::kTypeId);

#if ASMJIT_CXX_HAS_NATIVE_WCHAR_T
ASMJIT_DEFINE_TYPE_ID(wchar_t           , IdOfIntT<wchar_t           >::kTypeId);
#endif

#if ASMJIT_CXX_HAS_UNICODE_LITERALS
ASMJIT_DEFINE_TYPE_ID(char16_t          , IdOfIntT<char16_t          >::kTypeId);
ASMJIT_DEFINE_TYPE_ID(char32_t          , IdOfIntT<char32_t          >::kTypeId);
#endif

ASMJIT_DEFINE_TYPE_ID(void              , kIdVoid);
ASMJIT_DEFINE_TYPE_ID(float             , kIdF32);
ASMJIT_DEFINE_TYPE_ID(double            , kIdF64);

ASMJIT_DEFINE_TYPE_ID(Bool              , kIdU8);
ASMJIT_DEFINE_TYPE_ID(I8                , kIdI8);
ASMJIT_DEFINE_TYPE_ID(U8                , kIdU8);
ASMJIT_DEFINE_TYPE_ID(I16               , kIdI16);
ASMJIT_DEFINE_TYPE_ID(U16               , kIdU16);
ASMJIT_DEFINE_TYPE_ID(I32               , kIdI32);
ASMJIT_DEFINE_TYPE_ID(U32               , kIdU32);
ASMJIT_DEFINE_TYPE_ID(I64               , kIdI64);
ASMJIT_DEFINE_TYPE_ID(U64               , kIdU64);
ASMJIT_DEFINE_TYPE_ID(IPtr              , kIdIntPtr);
ASMJIT_DEFINE_TYPE_ID(UPtr              , kIdUIntPtr);
ASMJIT_DEFINE_TYPE_ID(F32               , kIdF32);
ASMJIT_DEFINE_TYPE_ID(F64               , kIdF64);

//! \}

ASMJIT_END_NAMESPACE

// [Guard]
#endif // _ASMJIT_CORE_TYPE_H

```

`Avanguard/AsmJit/asmjit/core/zone.h`:

```h
// [AsmJit]
// Complete x86/x64 JIT and Remote Assembler for C++.
//
// [License]
// ZLIB - See LICENSE.md file in the package.

// [Guard]
#ifndef _ASMJIT_CORE_ZONE_H
#define _ASMJIT_CORE_ZONE_H

// [Dependencies]
#include "../core/support.h"

ASMJIT_BEGIN_NAMESPACE

//! \addtogroup asmjit_core_support
//! \{

// ============================================================================
// [asmjit::Zone]
// ============================================================================

//! Zone memory.
//!
//! Zone is an incremental memory allocator that allocates memory by simply
//! incrementing a pointer. It allocates blocks of memory by using C's `malloc()`,
//! but divides these blocks into smaller segments requested by calling
//! `Zone::alloc()` and friends.
//!
//! Zone has no function to release the allocated memory. It has to be released
//! all at once by calling `reset()`. If you need a more friendly allocator that
//! also supports `release()`, consider using `Zone` with `ZoneAllocator`.
class Zone {
public:
  ASMJIT_NONCOPYABLE(Zone)

  //! \internal
  //!
  //! A single block of memory managed by `Zone`.
  struct Block {
    inline uint8_t* data() const noexcept {
      return const_cast<uint8_t*>(reinterpret_cast<const uint8_t*>(this) + sizeof(*this));
    }

    Block* prev;                         //!< Link to the previous block.
    Block* next;                         //!< Link to the next block.
    size_t size;                         //!< Size of the block.
  };

  enum Limits : size_t {
    kBlockSize = sizeof(Block),
    kBlockOverhead = Globals::kMemAllocOverhead + kBlockSize,

    kMinBlockSize = 64, // The number is ridiculously small, but still possible.
    kMaxBlockSize = size_t(1) << (sizeof(size_t) * 8 - 4 - 1),
    kMinAlignment = 1,
    kMaxAlignment = 64
  };

  static ASMJIT_API const Block _zeroBlock;

  // --------------------------------------------------------------------------
  // [Construction / Destruction]
  // --------------------------------------------------------------------------

  //! Create a new Zone.
  //!
  //! The `blockSize` parameter describes the default size of the block. If the
  //! `size` parameter passed to `alloc()` is greater than the default size
  //! `Zone` will allocate and use a larger block, but it will not change the
  //! default `blockSize`.
  //!
  //! It's not required, but it's good practice to set `blockSize` to a
  //! reasonable value that depends on the usage of `Zone`. Greater block sizes
  //! are generally safer and perform better than unreasonably low block sizes.
  ASMJIT_INLINE explicit Zone(size_t blockSize, size_t blockAlignment = 1) noexcept {
    _init(blockSize, blockAlignment, nullptr);
  }

  ASMJIT_INLINE Zone(size_t blockSize, size_t blockAlignment, const Support::Temporary& temporary) noexcept {
    _init(blockSize, blockAlignment, &temporary);
  }

  //! Move an existing `Zone`.
  //!
  //! NOTE: You cannot move an existing `ZoneTmp` as it uses embedded storage.
  //! Attempting to move `ZoneTmp` would result in assertion failure in debug
  //! mode and undefined behavior in release mode.
  ASMJIT_INLINE Zone(Zone&& other) noexcept
    : _ptr(other._ptr),
      _end(other._end),
      _block(other._block),
      _packedData(other._packedData) {
    ASMJIT_ASSERT(!other.isTemporary());
    other._block = const_cast<Block*>(&_zeroBlock);
    other._ptr = other._block->data();
    other._end = other._block->data();
  }


  //! Destroy the `Zone` instance.
  //!
  //! This will destroy the `Zone` instance and release all blocks of memory
  //! allocated by it. It performs implicit `reset(Globals::kResetHard)`.
  ASMJIT_INLINE ~Zone() noexcept { reset(Globals::kResetHard); }

  // --------------------------------------------------------------------------
  // [Init / Reset]
  // --------------------------------------------------------------------------

  ASMJIT_API void _init(size_t blockSize, size_t blockAlignment, const Support::Temporary* temporary) noexcept;

  //! Reset the `Zone` invalidating all blocks allocated.
  //!
  //! See `Globals::ResetPolicy` for more details.
  ASMJIT_API void reset(uint32_t resetPolicy = Globals::kResetSoft) noexcept;

  // --------------------------------------------------------------------------
  // [Accessors]
  // --------------------------------------------------------------------------

  //! Get whether this `Zone` is actually a `ZoneTmp` that uses temporary memory.
  ASMJIT_INLINE bool isTemporary() const noexcept { return _isTemporary != 0; }

  //! Get the default block size.
  ASMJIT_INLINE size_t blockSize() const noexcept { return _blockSize; }
  //! Get the default block alignment.
  ASMJIT_INLINE size_t blockAlignment() const noexcept { return size_t(1) << _blockAlignmentShift; }
  //! Get remaining size of the current block.
  ASMJIT_INLINE size_t remainingSize() const noexcept { return (size_t)(_end - _ptr); }

  //! Get the current zone cursor (dangerous).
  //!
  //! This is a function that can be used to get exclusive access to the current
  //! block's memory buffer.
  template<typename T = uint8_t>
  ASMJIT_INLINE T* ptr() noexcept { return reinterpret_cast<T*>(_ptr); }
  //! Get the end of the current zone block, only useful if you use `ptr()`.
  template<typename T = uint8_t>
  ASMJIT_INLINE T* end() noexcept { return reinterpret_cast<T*>(_end); }

  //! Set the current zone pointer to `ptr` (must be within the current block).
  template<typename T>
  ASMJIT_INLINE void setPtr(T* ptr) noexcept {
    uint8_t* p = reinterpret_cast<uint8_t*>(ptr);
    ASMJIT_ASSERT(p >= _ptr && p <= _end);
    _ptr = p;
  }

  //! Set the end zone pointer to `end` (must be within the current block).
  template<typename T>
  ASMJIT_INLINE void setEnd(T* end) noexcept {
    uint8_t* p = reinterpret_cast<uint8_t*>(end);
    ASMJIT_ASSERT(p >= _ptr && p <= _end);
    _end = p;
  }

  // --------------------------------------------------------------------------
  // [Utilities]
  // --------------------------------------------------------------------------

  //! Align the current pointer to `alignment`.
  ASMJIT_INLINE void align(size_t alignment) noexcept {
    _ptr = std::min(Support::alignUp(_ptr, alignment), _end);
  }

  //! Ensure the remaining size is at least equal or greater than `size`.
  //!
  //! NOTE: This function doesn't respect any alignment. If you need to ensure
  //! there is enough room for an aligned allocation you need to call `align()`
  //! before calling `ensure()`.
  ASMJIT_INLINE Error ensure(size_t size) noexcept {
    if (size <= remainingSize())
      return kErrorOk;
    else
      return _alloc(0, 1) ? kErrorOk : DebugUtils::errored(kErrorNoHeapMemory);
  }

  ASMJIT_INLINE void _assignBlock(Block* block) noexcept {
    size_t alignment = blockAlignment();
    _ptr = Support::alignUp(block->data(), alignment);
    _end = Support::alignDown(block->data() + block->size, alignment);
    _block = block;
  }

  ASMJIT_INLINE void _assignZeroBlock() noexcept {
    Block* block = const_cast<Block*>(&_zeroBlock);
    _ptr = block->data();
    _end = block->data();
    _block = block;
  }

  // --------------------------------------------------------------------------
  // [Alloc]
  // --------------------------------------------------------------------------

  //! Allocate the requested memory specified by `size`.
  //!
  //! Pointer returned is valid until the `Zone` instance is destroyed or reset
  //! by calling `reset()`. If you plan to make an instance of C++ from the
  //! given pointer use placement `new` and `delete` operators:
  //!
  //! ~~~
  //! using namespace asmjit;
  //!
  //! class Object { ... };
  //!
  //! // Create Zone with default block size of approximately 65536 bytes.
  //! Zone zone(65536 - Zone::kBlockOverhead);
  //!
  //! // Create your objects using zone object allocating, for example:
  //! Object* obj = static_cast<Object*>( zone.alloc(sizeof(Object)) );
  //
  //! if (!obj) {
  //!   // Handle out of memory error.
  //! }
  //!
  //! // Placement `new` and `delete` operators can be used to instantiate it.
  //! new(obj) Object();
  //!
  //! // ... lifetime of your objects ...
  //!
  //! // To destroy the instance (if required).
  //! obj->~Object();
  //!
  //! // Reset or destroy `Zone`.
  //! zone.reset();
  //! ~~~
  ASMJIT_INLINE void* alloc(size_t size) noexcept {
    if (ASMJIT_UNLIKELY(size > remainingSize()))
      return _alloc(size, 1);

    uint8_t* ptr = _ptr;
    _ptr += size;
    return static_cast<void*>(ptr);
  }

  //! Allocate the requested memory specified by `size` and `alignment`.
  ASMJIT_INLINE void* alloc(size_t size, size_t alignment) noexcept {
    ASMJIT_ASSERT(Support::isPowerOf2(alignment));
    uint8_t* ptr = Support::alignUp(_ptr, alignment);

    if (size > (size_t)(_end - ptr))
      return _alloc(size, alignment);

    _ptr = ptr + size;
    return static_cast<void*>(ptr);
  }

  //! Allocate the requested memory specified by `size` without doing any checks.
  //!
  //! Can only be called if `remainingSize()` returns size at least equal to `size`.
  ASMJIT_INLINE void* allocNoCheck(size_t size) noexcept {
    ASMJIT_ASSERT(remainingSize() >= size);

    uint8_t* ptr = _ptr;
    _ptr += size;
    return static_cast<void*>(ptr);
  }

  //! Allocate the requested memory specified by `size` and `alignment` without doing any checks.
  //!
  //! Performs the same operation as `Zone::allocNoCheck(size)` with `alignment` applied.
  ASMJIT_INLINE void* allocNoCheck(size_t size, size_t alignment) noexcept {
    ASMJIT_ASSERT(Support::isPowerOf2(alignment));

    uint8_t* ptr = Support::alignUp(_ptr, alignment);
    ASMJIT_ASSERT(size <= (size_t)(_end - ptr));

    _ptr = ptr + size;
    return static_cast<void*>(ptr);
  }

  //! Allocate `size` bytes of zeroed memory. See `alloc()` for more details.
  ASMJIT_API void* allocZeroed(size_t size, size_t alignment = 1) noexcept;

  //! Like `alloc()`, but the return pointer is casted to `T*`.
  template<typename T>
  ASMJIT_INLINE T* allocT(size_t size = sizeof(T), size_t alignment = alignof(T)) noexcept {
    return static_cast<T*>(alloc(size, alignment));
  }

  //! Like `allocNoCheck()`, but the return pointer is casted to `T*`.
  template<typename T>
  ASMJIT_INLINE T* allocNoCheckT(size_t size = sizeof(T), size_t alignment = alignof(T)) noexcept {
    return static_cast<T*>(allocNoCheck(size, alignment));
  }

  //! Like `allocZeroed()`, but the return pointer is casted to `T*`.
  template<typename T>
  ASMJIT_INLINE T* allocZeroedT(size_t size = sizeof(T), size_t alignment = alignof(T)) noexcept {
    return static_cast<T*>(allocZeroed(size, alignment));
  }

  //! Like `new(std::nothrow) T(...)`, but allocated by `Zone`.
  template<typename T>
  ASMJIT_INLINE T* newT() noexcept {
    void* p = alloc(sizeof(T), alignof(T));
    if (ASMJIT_UNLIKELY(!p))
      return nullptr;
    return new(p) T();
  }

  //! Like `new(std::nothrow) T(...)`, but allocated by `Zone`.
  template<typename T, typename... ArgsT>
  ASMJIT_INLINE T* newT(ArgsT&&... args) noexcept {
    void* p = alloc(sizeof(T), alignof(T));
    if (ASMJIT_UNLIKELY(!p))
      return nullptr;
    return new(p) T(std::forward<ArgsT>(args)...);
  }

  //! \internal
  ASMJIT_API void* _alloc(size_t size, size_t alignment) noexcept;

  //! Helper to duplicate data.
  ASMJIT_API void* dup(const void* data, size_t size, bool nullTerminate = false) noexcept;

  //! Helper to duplicate data.
  ASMJIT_INLINE void* dupAligned(const void* data, size_t size, size_t alignment, bool nullTerminate = false) noexcept {
    align(alignment);
    return dup(data, size, nullTerminate);
  }

  //! Helper to duplicate a formatted string, maximum size is 256 bytes.
  ASMJIT_API char* sformat(const char* str, ...) noexcept;

  // --------------------------------------------------------------------------
  // [Swap]
  // --------------------------------------------------------------------------

  ASMJIT_INLINE void swapWith(Zone& other) noexcept {
    // This could lead to a disaster.
    ASMJIT_ASSERT(!this->isTemporary());
    ASMJIT_ASSERT(!other.isTemporary());

    std::swap(_ptr, other._ptr);
    std::swap(_end, other._end);
    std::swap(_block, other._block);
    std::swap(_packedData, other._packedData);
  }

  // --------------------------------------------------------------------------
  // [Members]
  // --------------------------------------------------------------------------

  uint8_t* _ptr;                         //!< Pointer in the current block.
  uint8_t* _end;                         //!< End of the current block.
  Block* _block;                         //!< Current block.

  #if ASMJIT_ARCH_BITS >= 64
  union {
    struct {
      size_t _blockSize : 60;            //!< Default block size.
      size_t _isTemporary : 1;           //!< First block is temporary (ZoneTmp).
      size_t _blockAlignmentShift : 3;   //!< Block alignment (1 << alignment).
    };
    size_t _packedData;
  };
  #else
  union {
    struct {
      size_t _blockSize : 28;            //!< Default block size.
      size_t _isTemporary : 1;           //!< First block is temporary (ZoneTmp).
      size_t _blockAlignmentShift : 3;   //!< Block alignment (1 << alignment).
    };
    size_t _packedData;
  };
  #endif

};

// ============================================================================
// [b2d::ZoneTmp]
// ============================================================================

template<size_t N>
class ZoneTmp : public Zone {
public:
  ASMJIT_NONCOPYABLE(ZoneTmp<N>)

  ASMJIT_INLINE explicit ZoneTmp(size_t blockSize, size_t blockAlignment = 1) noexcept
    : Zone(blockSize, blockAlignment, Support::Temporary(_storage.data, N)) {}

  struct Storage {
    char data[N];
  } _storage;
};

// ============================================================================
// [asmjit::ZoneAllocator]
// ============================================================================

//! Zone-based memory allocator that uses an existing `Zone` and provides a
//! `release()` functionality on top of it. It uses `Zone` only for chunks
//! that can be pooled, and uses libc `malloc()` for chunks that are large.
//!
//! The advantage of ZoneAllocator is that it can allocate small chunks of memory
//! really fast, and these chunks, when released, will be reused by consecutive
//! calls to `alloc()`. Also, since ZoneAllocator uses `Zone`, you can turn any
//! `Zone` into a `ZoneAllocator`, and use it in your `Pass` when necessary.
//!
//! ZoneAllocator is used by AsmJit containers to make containers having only
//! few elements fast (and lightweight) and to allow them to grow and use
//! dynamic blocks when require more storage.
class ZoneAllocator {
public:
  ASMJIT_NONCOPYABLE(ZoneAllocator)

  enum {
    // In short, we pool chunks of these sizes:
    //   [32, 64, 96, 128, 192, 256, 320, 384, 448, 512]

    //! How many bytes per a low granularity pool (has to be at least 16).
    kLoGranularity = 32,
    //! Number of slots of a low granularity pool.
    kLoCount = 4,
    //! Maximum size of a block that can be allocated in a low granularity pool.
    kLoMaxSize = kLoGranularity * kLoCount,

    //! How many bytes per a high granularity pool.
    kHiGranularity = 64,
    //! Number of slots of a high granularity pool.
    kHiCount = 6,
    //! Maximum size of a block that can be allocated in a high granularity pool.
    kHiMaxSize = kLoMaxSize + kHiGranularity * kHiCount,

    //! Alignment of every pointer returned by `alloc()`.
    kBlockAlignment = kLoGranularity
  };

  //! Single-linked list used to store unused chunks.
  struct Slot {
    //! Link to a next slot in a single-linked list.
    Slot* next;
  };

  //! A block of memory that has been allocated dynamically and is not part of
  //! block-list used by the allocator. This is used to keep track of all these
  //! blocks so they can be freed by `reset()` if not freed explicitly.
  struct DynamicBlock {
    DynamicBlock* prev;
    DynamicBlock* next;
  };

  // --------------------------------------------------------------------------
  // [Construction / Destruction]
  // --------------------------------------------------------------------------

  //! Create a new `ZoneAllocator`.
  //!
  //! NOTE: To use it, you must first `init()` it.
  inline ZoneAllocator() noexcept {
    std::memset(this, 0, sizeof(*this));
  }

  //! Create a new `ZoneAllocator` initialized to use `zone`.
  inline explicit ZoneAllocator(Zone* zone) noexcept {
    std::memset(this, 0, sizeof(*this));
    _zone = zone;
  }

  //! Destroy the `ZoneAllocator`.
  inline ~ZoneAllocator() noexcept { reset(); }

  // --------------------------------------------------------------------------
  // [Init / Reset]
  // --------------------------------------------------------------------------

  //! Get whether the `ZoneAllocator` is initialized (i.e. has `Zone`).
  inline bool isInitialized() const noexcept { return _zone != nullptr; }

  //! Convenience method to initialize the `ZoneAllocator` with `zone`.
  //!
  //! It's the same as calling `reset(zone)`.
  inline void init(Zone* zone) noexcept { reset(zone); }

  //! Reset this `ZoneAllocator` and also forget about the current `Zone` which
  //! is attached (if any). Reset optionally attaches a new `zone` passed, or
  //! keeps the `ZoneAllocator` in an uninitialized state, if `zone` is null.
  ASMJIT_API void reset(Zone* zone = nullptr) noexcept;

  // --------------------------------------------------------------------------
  // [Accessors]
  // --------------------------------------------------------------------------

  //! Get the `Zone` the allocator is using, or null if it's not initialized.
  inline Zone* zone() const noexcept { return _zone; }

  // --------------------------------------------------------------------------
  // [Utilities]
  // --------------------------------------------------------------------------

  //! \internal
  //!
  //! Get the slot index to be used for `size`. Returns `true` if a valid slot
  //! has been written to `slot` and `allocatedSize` has been filled with slot
  //! exact size (`allocatedSize` can be equal or slightly greater than `size`).
  static ASMJIT_INLINE bool _getSlotIndex(size_t size, uint32_t& slot) noexcept {
    ASMJIT_ASSERT(size > 0);
    if (size > kHiMaxSize)
      return false;

    if (size <= kLoMaxSize)
      slot = uint32_t((size - 1) / kLoGranularity);
    else
      slot = uint32_t((size - kLoMaxSize - 1) / kHiGranularity) + kLoCount;

    return true;
  }

  //! \overload
  static ASMJIT_INLINE bool _getSlotIndex(size_t size, uint32_t& slot, size_t& allocatedSize) noexcept {
    ASMJIT_ASSERT(size > 0);
    if (size > kHiMaxSize)
      return false;

    if (size <= kLoMaxSize) {
      slot = uint32_t((size - 1) / kLoGranularity);
      allocatedSize = Support::alignUp(size, kLoGranularity);
    }
    else {
      slot = uint32_t((size - kLoMaxSize - 1) / kHiGranularity) + kLoCount;
      allocatedSize = Support::alignUp(size, kHiGranularity);
    }

    return true;
  }

  // --------------------------------------------------------------------------
  // [Alloc / Release]
  // --------------------------------------------------------------------------

  ASMJIT_API void* _alloc(size_t size, size_t& allocatedSize) noexcept;
  ASMJIT_API void* _allocZeroed(size_t size, size_t& allocatedSize) noexcept;
  ASMJIT_API void _releaseDynamic(void* p, size_t size) noexcept;

  //! Allocate `size` bytes of memory, ideally from an available pool.
  //!
  //! NOTE: `size` can't be zero, it will assert in debug mode in such case.
  inline void* alloc(size_t size) noexcept {
    ASMJIT_ASSERT(isInitialized());
    size_t allocatedSize;
    return _alloc(size, allocatedSize);
  }

  //! Like `alloc(size)`, but provides a second argument `allocatedSize` that
  //! provides a way to know how big the block returned actually is. This is
  //! useful for containers to prevent growing too early.
  inline void* alloc(size_t size, size_t& allocatedSize) noexcept {
    ASMJIT_ASSERT(isInitialized());
    return _alloc(size, allocatedSize);
  }

  //! Like `alloc()`, but the return pointer is casted to `T*`.
  template<typename T>
  inline T* allocT(size_t size = sizeof(T)) noexcept {
    return static_cast<T*>(alloc(size));
  }

  //! Like `alloc(size)`, but returns zeroed memory.
  inline void* allocZeroed(size_t size) noexcept {
    ASMJIT_ASSERT(isInitialized());
    size_t allocatedSize;
    return _allocZeroed(size, allocatedSize);
  }

  //! Like `alloc(size, allocatedSize)`, but returns zeroed memory.
  inline void* allocZeroed(size_t size, size_t& allocatedSize) noexcept {
    ASMJIT_ASSERT(isInitialized());
    return _allocZeroed(size, allocatedSize);
  }

  //! Like `allocZeroed()`, but the return pointer is casted to `T*`.
  template<typename T>
  inline T* allocZeroedT(size_t size = sizeof(T)) noexcept {
    return static_cast<T*>(allocZeroed(size));
  }

  //! Like `new(std::nothrow) T(...)`, but allocated by `Zone`.
  template<typename T>
  inline T* newT() noexcept {
    void* p = allocT<T>();
    if (ASMJIT_UNLIKELY(!p))
      return nullptr;
    return new(p) T();
  }
  //! Like `new(std::nothrow) T(...)`, but allocated by `Zone`.
  template<typename T, typename... ArgsT>
  inline T* newT(ArgsT&&... args) noexcept {
    void* p = allocT<T>();
    if (ASMJIT_UNLIKELY(!p))
      return nullptr;
    return new(p) T(std::forward<ArgsT>(args)...);
  }

  //! Release the memory previously allocated by `alloc()`. The `size` argument
  //! has to be the same as used to call `alloc()` or `allocatedSize` returned
  //! by `alloc()`.
  inline void release(void* p, size_t size) noexcept {
    ASMJIT_ASSERT(isInitialized());
    ASMJIT_ASSERT(p != nullptr);
    ASMJIT_ASSERT(size != 0);

    uint32_t slot;
    if (_getSlotIndex(size, slot)) {
      static_cast<Slot*>(p)->next = static_cast<Slot*>(_slots[slot]);
      _slots[slot] = static_cast<Slot*>(p);
    }
    else {
      _releaseDynamic(p, size);
    }
  }

  // --------------------------------------------------------------------------
  // [Members]
  // --------------------------------------------------------------------------

  Zone* _zone;                           //!< Zone used to allocate memory that fits into slots.
  Slot* _slots[kLoCount + kHiCount];     //!< Indexed slots containing released memory.
  DynamicBlock* _dynamicBlocks;          //!< Dynamic blocks for larger allocations (no slots).
};

//! \}

ASMJIT_END_NAMESPACE

// [Guard]
#endif // _ASMJIT_CORE_ZONE_H

```

`Avanguard/AsmJit/asmjit/core/zonehash.h`:

```h
// [AsmJit]
// Complete x86/x64 JIT and Remote Assembler for C++.
//
// [License]
// ZLIB - See LICENSE.md file in the package.

// [Guard]
#ifndef _ASMJIT_CORE_ZONEHASH_H
#define _ASMJIT_CORE_ZONEHASH_H

// [Dependencies]
#include "../core/zone.h"

ASMJIT_BEGIN_NAMESPACE

//! \addtogroup asmjit_core_support
//! \{

// ============================================================================
// [asmjit::ZoneHashNode]
// ============================================================================

//! Node used by `ZoneHash<>` template.
//!
//! You must provide function `bool eq(const Key& key)` in order to make
//! `ZoneHash::get()` working.
class ZoneHashNode {
public:
  ASMJIT_NONCOPYABLE(ZoneHashNode)

  inline ZoneHashNode(uint32_t hashCode = 0) noexcept
    : _hashNext(nullptr),
      _hashCode(hashCode),
      _customData(0) {}

  ZoneHashNode* _hashNext;               //!< Next node in the chain, null if it terminates the chain.
  uint32_t _hashCode;                    //!< Precalculated hash-code of key.
  uint32_t _customData;                  //!< Padding, can be reused by any Node that inherits `ZoneHashNode`.
};

// ============================================================================
// [asmjit::ZoneHashBase]
// ============================================================================

class ZoneHashBase {
public:
  ASMJIT_NONCOPYABLE(ZoneHashBase)

  // --------------------------------------------------------------------------
  // [Construction / Destruction]
  // --------------------------------------------------------------------------

  inline ZoneHashBase() noexcept {
    _size = 0;
    _bucketsCount = 1;
    _bucketsGrow = 1;
    _data = _embedded;
    _embedded[0] = nullptr;
  }

  inline ZoneHashBase(ZoneHashBase&& other) noexcept {
    _size = other._size;
    _bucketsCount = other._bucketsCount;
    _bucketsGrow = other._bucketsGrow;
    _data = other._data;
    _embedded[0] = other._embedded[0];

    if (_data == other._embedded) _data = _embedded;
  }

  // --------------------------------------------------------------------------
  // [Init / Reset]
  // --------------------------------------------------------------------------

  inline void reset() noexcept {
    _size = 0;
    _bucketsCount = 1;
    _bucketsGrow = 1;
    _data = _embedded;
    _embedded[0] = nullptr;
  }

  inline void release(ZoneAllocator* allocator) noexcept {
    ZoneHashNode** oldData = _data;
    if (oldData != _embedded)
      allocator->release(oldData, _bucketsCount * sizeof(ZoneHashNode*));
    reset();
  }

  // --------------------------------------------------------------------------
  // [Accessors]
  // --------------------------------------------------------------------------

  inline bool empty() const noexcept { return _size == 0; }
  inline size_t size() const noexcept { return _size; }

  // --------------------------------------------------------------------------
  // [Ops]
  // --------------------------------------------------------------------------

  ASMJIT_API void _rehash(ZoneAllocator* allocator, uint32_t newCount) noexcept;
  ASMJIT_API ZoneHashNode* _insert(ZoneAllocator* allocator, ZoneHashNode* node) noexcept;
  ASMJIT_API ZoneHashNode* _remove(ZoneAllocator* allocator, ZoneHashNode* node) noexcept;

  // --------------------------------------------------------------------------
  // [Swap]
  // --------------------------------------------------------------------------

  inline void swapWith(ZoneHashBase& other) noexcept {
    std::swap(_size, other._size);
    std::swap(_bucketsCount, other._bucketsCount);
    std::swap(_bucketsGrow, other._bucketsGrow);
    std::swap(_data, other._data);
    std::swap(_embedded[0], other._embedded[0]);

    if (_data == other._embedded) _data = _embedded;
    if (other._data == _embedded) other._data = other._embedded;
  }

  // --------------------------------------------------------------------------
  // [Members]
  // --------------------------------------------------------------------------

  size_t _size;                          //!< Count of records inserted into the hash table.
  uint32_t _bucketsCount;                //!< Count of hash buckets.
  uint32_t _bucketsGrow;                 //!< When buckets array should grow.

  ZoneHashNode** _data;                  //!< Buckets data.
  ZoneHashNode* _embedded[1];            //!< Embedded data, used by empty hash tables.
};

// ============================================================================
// [asmjit::ZoneHash]
// ============================================================================

//! Low-level hash table specialized for storing string keys and POD values.
//!
//! This hash table allows duplicates to be inserted (the API is so low
//! level that it's up to you if you allow it or not, as you should first
//! `get()` the node and then modify it or insert a new node by using `insert()`,
//! depending on the intention).
template<typename NodeT>
class ZoneHash : public ZoneHashBase {
public:
  ASMJIT_NONCOPYABLE(ZoneHash<NodeT>)

  typedef NodeT Node;

  inline ZoneHash() noexcept
    : ZoneHashBase() {}

  inline ZoneHash(ZoneHash&& other) noexcept
    : ZoneHash(other) {}

  template<typename KeyT>
  inline NodeT* get(const KeyT& key) const noexcept {
    uint32_t hMod = key.hashCode() % _bucketsCount;
    NodeT* node = static_cast<NodeT*>(_data[hMod]);

    while (node && !key.matches(node))
      node = static_cast<NodeT*>(node->_hashNext);
    return node;
  }

  inline NodeT* insert(ZoneAllocator* allocator, NodeT* node) noexcept { return static_cast<NodeT*>(_insert(allocator, node)); }
  inline NodeT* remove(ZoneAllocator* allocator, NodeT* node) noexcept { return static_cast<NodeT*>(_remove(allocator, node)); }

  inline void swapWith(ZoneHash& other) noexcept { ZoneHashBase::swapWith(other); }
};

//! \}

ASMJIT_END_NAMESPACE

// [Guard]
#endif // _ASMJIT_CORE_ZONEHASH_H

```

`Avanguard/AsmJit/asmjit/core/zonelist.h`:

```h
// [AsmJit]
// Complete x86/x64 JIT and Remote Assembler for C++.
//
// [License]
// ZLIB - See LICENSE.md file in the package.

// [Guard]
#ifndef _ASMJIT_CORE_ZONELIST_H
#define _ASMJIT_CORE_ZONELIST_H

// [Dependencies]
#include "../core/support.h"

ASMJIT_BEGIN_NAMESPACE

//! \addtogroup asmjit_core_support
//! \{

// ============================================================================
// [asmjit::ZoneListNode]
// ============================================================================

template<typename NodeT>
class ZoneListNode {
public:
  ASMJIT_NONCOPYABLE(ZoneListNode)

  inline ZoneListNode() noexcept
    : _listNodes { nullptr, nullptr } {}

  inline ZoneListNode(ZoneListNode&& other) noexcept
    : _listNodes { other._listNodes[0], other._listNodes[1] } {}

  inline bool hasPrev() const noexcept { return _listNodes[Globals::kLinkPrev] != nullptr; }
  inline bool hasNext() const noexcept { return _listNodes[Globals::kLinkNext] != nullptr; }

  inline NodeT* prev() const noexcept { return _listNodes[Globals::kLinkPrev]; }
  inline NodeT* next() const noexcept { return _listNodes[Globals::kLinkNext]; }

  // --------------------------------------------------------------------------
  // [Members]
  // --------------------------------------------------------------------------

  NodeT* _listNodes[Globals::kLinkCount];
};

// ============================================================================
// [asmjit::ZoneList<T>]
// ============================================================================

template <typename NodeT>
class ZoneList {
public:
  ASMJIT_NONCOPYABLE(ZoneList)

  inline ZoneList() noexcept
    : _bounds { nullptr, nullptr } {}

  inline ZoneList(ZoneList&& other) noexcept
    : _bounds { other._bounds[0], other._bounds[1] } {}

  // --------------------------------------------------------------------------
  // [Reset]
  // --------------------------------------------------------------------------

  inline void reset() noexcept {
    _bounds[0] = nullptr;
    _bounds[1] = nullptr;
  }

  // --------------------------------------------------------------------------
  // [Accessors]
  // --------------------------------------------------------------------------

  inline bool empty() const noexcept { return _bounds[0] == nullptr; }
  inline NodeT* first() const noexcept { return _bounds[Globals::kLinkFirst]; }
  inline NodeT* last() const noexcept { return _bounds[Globals::kLinkLast]; }

  // --------------------------------------------------------------------------
  // [Operations]
  // --------------------------------------------------------------------------

  // Can be used to both prepend and append.
  inline void _addNode(NodeT* node, size_t dir) noexcept {
    NodeT* prev = _bounds[dir];

    node->_listNodes[!dir] = prev;
    _bounds[dir] = node;
    if (prev)
      prev->_listNodes[dir] = node;
    else
      _bounds[!dir] = node;
  }

  // Can be used to both prepend and append.
  inline void _insertNode(NodeT* ref, NodeT* node, size_t dir) noexcept {
    ASMJIT_ASSERT(ref != nullptr);

    NodeT* prev = ref;
    NodeT* next = ref->_listNodes[dir];

    prev->_listNodes[dir] = node;
    if (next)
      next->_listNodes[!dir] = node;
    else
      _bounds[dir] = node;

    node->_listNodes[!dir] = prev;
    node->_listNodes[ dir] = next;
  }

  inline void append(NodeT* node) noexcept { _addNode(node, Globals::kLinkLast); }
  inline void prepend(NodeT* node) noexcept { _addNode(node, Globals::kLinkFirst); }

  inline void insertAfter(NodeT* ref, NodeT* node) noexcept { _insertNode(ref, node, Globals::kLinkNext); }
  inline void insertBefore(NodeT* ref, NodeT* node) noexcept { _insertNode(ref, node, Globals::kLinkPrev); }

  inline NodeT* unlink(NodeT* node) noexcept {
    NodeT* prev = node->prev();
    NodeT* next = node->next();

    if (prev) { prev->_listNodes[Globals::kLinkNext] = next; node->_listNodes[0] = nullptr; } else { _bounds[Globals::kLinkFirst] = next; }
    if (next) { next->_listNodes[Globals::kLinkPrev] = prev; node->_listNodes[1] = nullptr; } else { _bounds[Globals::kLinkLast ] = prev; }

    node->_listNodes[0] = nullptr;
    node->_listNodes[1] = nullptr;

    return node;
  }

  inline NodeT* popFirst() noexcept {
    NodeT* node = _bounds[Globals::kLinkFirst];
    ASMJIT_ASSERT(node != nullptr);

    NodeT* next = node->next();
    _bounds[Globals::kLinkFirst] = next;

    if (next) {
      next->_listNodes[Globals::kLinkPrev] = nullptr;
      node->_listNodes[Globals::kLinkNext] = nullptr;
    }
    else {
      _bounds[Globals::kLinkLast] = nullptr;
    }

    return node;
  }

  inline NodeT* pop() noexcept {
    NodeT* node = _bounds[Globals::kLinkLast];
    ASMJIT_ASSERT(node != nullptr);

    NodeT* prev = node->prev();
    _bounds[Globals::kLinkLast] = prev;

    if (prev) {
      prev->_listNodes[Globals::kLinkNext] = nullptr;
      node->_listNodes[Globals::kLinkPrev] = nullptr;
    }
    else {
      _bounds[Globals::kLinkFirst] = nullptr;
    }

    return node;
  }

  // --------------------------------------------------------------------------
  // [Swap]
  // --------------------------------------------------------------------------

  inline void swapWith(ZoneList& other) noexcept {
    std::swap(_bounds[0], other._bounds[0]);
    std::swap(_bounds[1], other._bounds[1]);
  }

  // --------------------------------------------------------------------------
  // [Members]
  // --------------------------------------------------------------------------

  NodeT* _bounds[Globals::kLinkCount];
};

//! \}

ASMJIT_END_NAMESPACE

// [Guard]
#endif // _ASMJIT_CORE_ZONELIST_H

```

`Avanguard/AsmJit/asmjit/core/zonestack.h`:

```h
// [AsmJit]
// Complete x86/x64 JIT and Remote Assembler for C++.
//
// [License]
// ZLIB - See LICENSE.md file in the package.

// [Guard]
#ifndef _ASMJIT_CORE_ZONESTACK_H
#define _ASMJIT_CORE_ZONESTACK_H

// [Dependencies]
#include "../core/zone.h"

ASMJIT_BEGIN_NAMESPACE

//! \addtogroup asmjit_core_support
//! \{

// ============================================================================
// [asmjit::ZoneStackBase]
// ============================================================================

class ZoneStackBase {
public:
  ASMJIT_NONCOPYABLE(ZoneStackBase)

  static constexpr uint32_t kBlockSize = ZoneAllocator::kHiMaxSize;

  struct Block {
    inline bool empty() const noexcept { return _start == _end; }
    inline Block* prev() const noexcept { return _link[Globals::kLinkLeft]; }
    inline Block* next() const noexcept { return _link[Globals::kLinkRight]; }

    inline void setPrev(Block* block) noexcept { _link[Globals::kLinkLeft] = block; }
    inline void setNext(Block* block) noexcept { _link[Globals::kLinkRight] = block; }

    template<typename T>
    inline T* start() const noexcept { return static_cast<T*>(_start); }
    template<typename T>
    inline void setStart(T* start) noexcept { _start = static_cast<void*>(start); }

    template<typename T>
    inline T* end() const noexcept { return (T*)_end; }
    template<typename T>
    inline void setEnd(T* end) noexcept { _end = (void*)end; }

    template<typename T>
    inline T* data() const noexcept { return (T*)((uint8_t*)(this) + sizeof(Block)); }

    template<typename T>
    inline bool canPrepend() const noexcept { return _start > data<void>(); }

    template<typename T>
    inline bool canAppend() const noexcept {
      size_t kNumBlockItems = (kBlockSize - sizeof(Block)) / sizeof(T);
      size_t kStartBlockIndex = sizeof(Block);
      size_t kEndBlockIndex = kStartBlockIndex + kNumBlockItems * sizeof(T);

      return (uintptr_t)_end <= ((uintptr_t)this + kEndBlockIndex - sizeof(T));
    }

    Block* _link[Globals::kLinkCount];   //!< Next and previous blocks.
    void* _start;                        //!< Pointer to the start of the array.
    void* _end;                          //!< Pointer to the end of the array.
  };

  // --------------------------------------------------------------------------
  // [Construction / Destruction]
  // --------------------------------------------------------------------------

  inline ZoneStackBase() noexcept {
    _allocator = nullptr;
    _block[0] = nullptr;
    _block[1] = nullptr;
  }
  inline ~ZoneStackBase() noexcept { reset(); }

  // --------------------------------------------------------------------------
  // [Init / Reset]
  // --------------------------------------------------------------------------

  inline bool isInitialized() const noexcept { return _allocator != nullptr; }
  ASMJIT_API Error _init(ZoneAllocator* allocator, size_t middleIndex) noexcept;
  inline Error reset() noexcept { return _init(nullptr, 0); }

  // --------------------------------------------------------------------------
  // [Accessors]
  // --------------------------------------------------------------------------

  //! Get a `ZoneAllocator` attached to this container.
  inline ZoneAllocator* allocator() const noexcept { return _allocator; }

  inline bool empty() const noexcept {
    ASMJIT_ASSERT(isInitialized());
    return _block[0]->start<void>() == _block[1]->end<void>();
  }

  // --------------------------------------------------------------------------
  // [Ops]
  // --------------------------------------------------------------------------

  ASMJIT_API Error _prepareBlock(uint32_t side, size_t initialIndex) noexcept;
  ASMJIT_API void _cleanupBlock(uint32_t side, size_t middleIndex) noexcept;

  // --------------------------------------------------------------------------
  // [Members]
  // --------------------------------------------------------------------------

  ZoneAllocator* _allocator;             //!< Allocator used to allocate data.
  Block* _block[Globals::kLinkCount];    //!< First and last blocks.
};

// ============================================================================
// [asmjit::ZoneStack<T>]
// ============================================================================

template<typename T>
class ZoneStack : public ZoneStackBase {
public:
  ASMJIT_NONCOPYABLE(ZoneStack<T>)

  enum : uint32_t {
    kNumBlockItems   = uint32_t((kBlockSize - sizeof(Block)) / sizeof(T)),
    kStartBlockIndex = uint32_t(sizeof(Block)),
    kMidBlockIndex   = uint32_t(kStartBlockIndex + (kNumBlockItems / 2) * sizeof(T)),
    kEndBlockIndex   = uint32_t(kStartBlockIndex + (kNumBlockItems    ) * sizeof(T))
  };

  // --------------------------------------------------------------------------
  // [Construction / Destruction]
  // --------------------------------------------------------------------------

  inline ZoneStack() noexcept {}
  inline ~ZoneStack() noexcept {}

  // --------------------------------------------------------------------------
  // [Init / Reset]
  // --------------------------------------------------------------------------

  inline Error init(ZoneAllocator* allocator) noexcept { return _init(allocator, kMidBlockIndex); }

  // --------------------------------------------------------------------------
  // [Ops]
  // --------------------------------------------------------------------------

  ASMJIT_INLINE Error prepend(T item) noexcept {
    ASMJIT_ASSERT(isInitialized());
    Block* block = _block[Globals::kLinkFirst];

    if (!block->canPrepend<T>()) {
      ASMJIT_PROPAGATE(_prepareBlock(Globals::kLinkFirst, kEndBlockIndex));
      block = _block[Globals::kLinkFirst];
    }

    T* ptr = block->start<T>() - 1;
    ASMJIT_ASSERT(ptr >= block->data<T>() && ptr <= block->data<T>() + (kNumBlockItems - 1));
    *ptr = item;
    block->setStart<T>(ptr);
    return kErrorOk;
  }

  ASMJIT_INLINE Error append(T item) noexcept {
    ASMJIT_ASSERT(isInitialized());
    Block* block = _block[Globals::kLinkLast];

    if (!block->canAppend<T>()) {
      ASMJIT_PROPAGATE(_prepareBlock(Globals::kLinkLast, kStartBlockIndex));
      block = _block[Globals::kLinkLast];
    }

    T* ptr = block->end<T>();
    ASMJIT_ASSERT(ptr >= block->data<T>() && ptr <= block->data<T>() + (kNumBlockItems - 1));

    *ptr++ = item;
    block->setEnd(ptr);
    return kErrorOk;
  }

  ASMJIT_INLINE T popFirst() noexcept {
    ASMJIT_ASSERT(isInitialized());
    ASMJIT_ASSERT(!empty());

    Block* block = _block[Globals::kLinkFirst];
    ASMJIT_ASSERT(!block->empty());

    T* ptr = block->start<T>();
    T item = *ptr++;

    block->setStart(ptr);
    if (block->empty())
      _cleanupBlock(Globals::kLinkFirst, kMidBlockIndex);

    return item;
  }

  ASMJIT_INLINE T pop() noexcept {
    ASMJIT_ASSERT(isInitialized());
    ASMJIT_ASSERT(!empty());

    Block* block = _block[Globals::kLinkLast];
    ASMJIT_ASSERT(!block->empty());

    T* ptr = block->end<T>();
    T item = *--ptr;
    ASMJIT_ASSERT(ptr >= block->data<T>());
    ASMJIT_ASSERT(ptr >= block->start<T>());

    block->setEnd(ptr);
    if (block->empty())
      _cleanupBlock(Globals::kLinkLast, kMidBlockIndex);

    return item;
  }
};

//! \}

ASMJIT_END_NAMESPACE

// [Guard]
#endif // _ASMJIT_CORE_ZONESTACK_H

```

`Avanguard/AsmJit/asmjit/core/zonestring.h`:

```h
// [AsmJit]
// Complete x86/x64 JIT and Remote Assembler for C++.
//
// [License]
// ZLIB - See LICENSE.md file in the package.

// [Guard]
#ifndef _ASMJIT_CORE_SMALLSTRING_H
#define _ASMJIT_CORE_SMALLSTRING_H

// [Dependencies]
#include "../core/globals.h"
#include "../core/zone.h"

ASMJIT_BEGIN_NAMESPACE

//! \addtogroup asmjit_core_support
//! \{

// ============================================================================
// [asmjit::ZoneStringBase]
// ============================================================================

struct ZoneStringBase {
  inline void reset() noexcept {
    _dummy = nullptr;
    _external = nullptr;
  }

  Error setData(Zone* zone, uint32_t maxEmbeddedSize, const char* str, size_t size) noexcept {
    if (size == Globals::kNullTerminated)
      size = std::strlen(str);

    if (size <= maxEmbeddedSize) {
      std::memcpy(_embedded, str, size);
      _embedded[size] = '\0';
    }
    else {
      char* external = static_cast<char*>(zone->dup(str, size, true));
      if (ASMJIT_UNLIKELY(!external))
        return DebugUtils::errored(kErrorNoHeapMemory);
      _external = external;
    }

    _size = uint32_t(size);
    return kErrorOk;
  }

  // --------------------------------------------------------------------------
  // [Members]
  // --------------------------------------------------------------------------

  union {
    struct {
      uint32_t _size;
      char _embedded[sizeof(void*) * 2 - 4];
    };
    struct {
      void* _dummy;
      char* _external;
    };
  };
};

// ============================================================================
// [asmjit::ZoneString<N>]
// ============================================================================

//! Small string is a template that helps to create strings that can be either
//! statically allocated if they are small, or externally allocated in case
//! their size exceeds the limit. The `N` represents the size of the whole
//! `ZoneString` structure, based on that size the maximum size of the internal
//! buffer is determined.
template<size_t N>
class ZoneString {
public:
  static constexpr uint32_t kWholeSize =
    (N > sizeof(ZoneStringBase)) ? uint32_t(N) : uint32_t(sizeof(ZoneStringBase));
  static constexpr uint32_t kMaxEmbeddedSize = kWholeSize - 5;

  // --------------------------------------------------------------------------
  // [Construction / Destruction]
  // --------------------------------------------------------------------------

  inline ZoneString() noexcept { reset(); }
  inline void reset() noexcept { _base.reset(); }

  // --------------------------------------------------------------------------
  // [Accessors]
  // --------------------------------------------------------------------------

  inline const char* data() const noexcept { return _base._size <= kMaxEmbeddedSize ? _base._embedded : _base._external; }
  inline bool empty() const noexcept { return _base._size == 0; }
  inline uint32_t size() const noexcept { return _base._size; }

  inline bool isEmbedded() const noexcept { return _base._size <= kMaxEmbeddedSize; }

  inline Error setData(Zone* zone, const char* data, size_t size) noexcept {
    return _base.setData(zone, kMaxEmbeddedSize, data, size);
  }

  // --------------------------------------------------------------------------
  // [Members]
  // --------------------------------------------------------------------------

  union {
    ZoneStringBase _base;
    char _wholeData[kWholeSize];
  };
};

//! \}

ASMJIT_END_NAMESPACE

// [Guard]
#endif // _ASMJIT_CORE_SMALLSTRING_H

```

`Avanguard/AsmJit/asmjit/core/zonetree.h`:

```h
// [AsmJit]
// Complete x86/x64 JIT and Remote Assembler for C++.
//
// [License]
// ZLIB - See LICENSE.md file in the package.

// [Guard]
#ifndef _ASMJIT_CORE_ZONETREE_H
#define _ASMJIT_CORE_ZONETREE_H

// [Dependencies]
#include "../core/support.h"

ASMJIT_BEGIN_NAMESPACE

//! \addtogroup asmjit_core_support
//! \{

// ============================================================================
// [asmjit::ZoneTreeNode]
// ============================================================================

//! RB-Tree node.
//!
//! The color is stored in a least significant bit of the `left` node.
//!
//! WARNING: Always use accessors to access left and right children.
class ZoneTreeNode {
public:
  ASMJIT_NONCOPYABLE(ZoneTreeNode)

  static constexpr uintptr_t kRedMask = 0x1;
  static constexpr uintptr_t kPtrMask = ~kRedMask;

  inline ZoneTreeNode() noexcept
    : _rbNodeData { 0, 0 } {}

  // --------------------------------------------------------------------------
  // [Accessors]
  // --------------------------------------------------------------------------

  inline bool hasChild(size_t i) const noexcept { return _rbNodeData[i] > kRedMask; }
  inline bool hasLeft() const noexcept { return _rbNodeData[0] > kRedMask; }
  inline bool hasRight() const noexcept { return _rbNodeData[1] != 0; }

  inline ZoneTreeNode* _getChild(size_t i) const noexcept { return (ZoneTreeNode*)(_rbNodeData[i] & kPtrMask); }
  inline ZoneTreeNode* _getLeft() const noexcept { return (ZoneTreeNode*)(_rbNodeData[0] & kPtrMask); }
  inline ZoneTreeNode* _getRight() const noexcept { return (ZoneTreeNode*)(_rbNodeData[1]); }

  inline void _setChild(size_t i, ZoneTreeNode* node) noexcept { _rbNodeData[i] = (_rbNodeData[i] & kRedMask) | (uintptr_t)node; }
  inline void _setLeft(ZoneTreeNode* node) noexcept { _rbNodeData[0] = (_rbNodeData[0] & kRedMask) | (uintptr_t)node; }
  inline void _setRight(ZoneTreeNode* node) noexcept { _rbNodeData[1] = (uintptr_t)node; }

  template<typename T = ZoneTreeNode>
  inline T* child(size_t i) const noexcept { return static_cast<T*>(_getChild(i)); }
  template<typename T = ZoneTreeNode>
  inline T* left() const noexcept { return static_cast<T*>(_getLeft()); }
  template<typename T = ZoneTreeNode>
  inline T* right() const noexcept { return static_cast<T*>(_getRight()); }

  inline bool isRed() const noexcept { return static_cast<bool>(_rbNodeData[0] & kRedMask); }
  inline void _makeRed() noexcept { _rbNodeData[0] |= kRedMask; }
  inline void _makeBlack() noexcept { _rbNodeData[0] &= kPtrMask; }

  //! Get whether the node is RED (RED node must be non-null and must have RED flag set).
  static inline bool _isValidRed(ZoneTreeNode* node) noexcept { return node && node->isRed(); }

  // --------------------------------------------------------------------------
  // [Members]
  // --------------------------------------------------------------------------

  uintptr_t _rbNodeData[Globals::kLinkCount];
};

//! RB-Tree typed to `NodeT`.
template<typename NodeT>
class ZoneTreeNodeT : public ZoneTreeNode {
public:
  ASMJIT_NONCOPYABLE(ZoneTreeNodeT)

  inline ZoneTreeNodeT() noexcept
    : ZoneTreeNode() {}

  inline NodeT* child(size_t i) const noexcept { return static_cast<NodeT*>(_getChild(i)); }
  inline NodeT* left() const noexcept { return static_cast<NodeT*>(_getLeft()); }
  inline NodeT* right() const noexcept { return static_cast<NodeT*>(_getRight()); }
};

// ============================================================================
// [asmjit::ZoneTree]
// ============================================================================

//! RB-Tree.
template<typename NodeT>
class ZoneTree {
public:
  ASMJIT_NONCOPYABLE(ZoneTree)

  typedef NodeT Node;

  // --------------------------------------------------------------------------
  // [Construction / Destruction]
  // --------------------------------------------------------------------------

  inline ZoneTree() noexcept
    : _root(nullptr) {}

  inline ZoneTree(ZoneTree&& other) noexcept
    : _root(other._root) {}

  // --------------------------------------------------------------------------
  // [Accessors]
  // --------------------------------------------------------------------------

  inline bool empty() const noexcept { return _root == nullptr; }
  inline NodeT* root() const noexcept { return static_cast<NodeT*>(_root); }

  // --------------------------------------------------------------------------
  // [Reset]
  // --------------------------------------------------------------------------

  inline void reset() noexcept { _root = nullptr; }

  // --------------------------------------------------------------------------
  // [Operations]
  // --------------------------------------------------------------------------

  template<typename CompareT = Support::Compare<Support::kSortAscending>>
  void insert(NodeT* node, const CompareT& cmp = CompareT()) noexcept {
    // Node to insert must not contain garbage.
    ASMJIT_ASSERT(!node->hasLeft());
    ASMJIT_ASSERT(!node->hasRight());
    ASMJIT_ASSERT(!node->isRed());

    if (!_root) {
      _root = node;
      return;
    }

    ZoneTreeNode head;         // False root node,
    head._setRight(_root);     // having root on the right.

    ZoneTreeNode* g = nullptr; // Grandparent.
    ZoneTreeNode* p = nullptr; // Parent.
    ZoneTreeNode* t = &head;   // Iterator.
    ZoneTreeNode* q = _root;   // Query.

    size_t dir = 0;            // Direction for accessing child nodes.
    size_t last = 0;           // Not needed to initialize, but makes some tools happy.

    node->_makeRed();          // New nodes are always red and violations fixed appropriately.

    // Search down the tree.
    for (;;) {
      if (!q) {
        // Insert new node at the bottom.
        q = node;
        p->_setChild(dir, node);
      }
      else if (_isValidRed(q->_getLeft()) && _isValidRed(q->_getRight())) {
        // Color flip.
        q->_makeRed();
        q->_getLeft()->_makeBlack();
        q->_getRight()->_makeBlack();
      }

      // Fix red violation.
      if (_isValidRed(q) && _isValidRed(p))
        t->_setChild(t->_getRight() == g,
                     q == p->_getChild(last) ? _singleRotate(g, !last) : _doubleRotate(g, !last));

      // Stop if found.
      if (q == node)
        break;

      last = dir;
      dir = cmp(*static_cast<NodeT*>(q), *static_cast<NodeT*>(node)) < 0;

      // Update helpers.
      if (g) t = g;

      g = p;
      p = q;
      q = q->_getChild(dir);
    }

    // Update root and make it black.
    _root = static_cast<NodeT*>(head._getRight());
    _root->_makeBlack();
  }

  //! Remove node from RBTree.
  template<typename CompareT = Support::Compare<Support::kSortAscending>>
  void remove(ZoneTreeNode* node, const CompareT& cmp = CompareT()) noexcept {
    ZoneTreeNode head;           // False root node,
    head._setRight(_root);       // having root on the right.

    ZoneTreeNode* g = nullptr;   // Grandparent.
    ZoneTreeNode* p = nullptr;   // Parent.
    ZoneTreeNode* q = &head;     // Query.

    ZoneTreeNode* f  = nullptr;  // Found item.
    ZoneTreeNode* gf = nullptr;  // Found grandparent.
    size_t dir = 1;              // Direction (0 or 1).

    // Search and push a red down.
    while (q->hasChild(dir)) {
      size_t last = dir;

      // Update helpers.
      g = p;
      p = q;
      q = q->_getChild(dir);
      dir = cmp(*static_cast<NodeT*>(q), *static_cast<NodeT*>(node)) < 0;

      // Save found node.
      if (q == node) {
        f = q;
        gf = g;
      }

      // Push the red node down.
      if (!_isValidRed(q) && !_isValidRed(q->_getChild(dir))) {
        if (_isValidRed(q->_getChild(!dir))) {
          ZoneTreeNode* child = _singleRotate(q, dir);
          p->_setChild(last, child);
          p = child;
        }
        else if (!_isValidRed(q->_getChild(!dir)) && p->_getChild(!last)) {
          ZoneTreeNode* s = p->_getChild(!last);
          if (!_isValidRed(s->_getChild(!last)) && !_isValidRed(s->_getChild(last))) {
            // Color flip.
            p->_makeBlack();
            s->_makeRed();
            q->_makeRed();
          }
          else {
            size_t dir2 = g->_getRight() == p;
            ZoneTreeNode* child = g->_getChild(dir2);

            if (_isValidRed(s->_getChild(last))) {
              child = _doubleRotate(p, last);
              g->_setChild(dir2, child);
            }
            else if (_isValidRed(s->_getChild(!last))) {
              child = _singleRotate(p, last);
              g->_setChild(dir2, child);
            }

            // Ensure correct coloring.
            q->_makeRed();
            child->_makeRed();
            child->_getLeft()->_makeBlack();
            child->_getRight()->_makeBlack();
          }
        }
      }
    }

    // Replace and remove.
    ASMJIT_ASSERT(f != nullptr);
    ASMJIT_ASSERT(f != &head);
    ASMJIT_ASSERT(q != &head);

    p->_setChild(p->_getRight() == q,
                 q->_getChild(q->_getLeft() == nullptr));

    // NOTE: The original algorithm used a trick to just copy 'key/value' to
    // `f` and mark `q` for deletion. But this is unacceptable here as we
    // really want to destroy the passed `node`. So, we really have to make
    // sure that we really removed `f` and not `q` from the tree.
    if (f != q) {
      ASMJIT_ASSERT(f != &head);
      ASMJIT_ASSERT(f != gf);

      ZoneTreeNode* n = gf ? gf : &head;
      dir = (n == &head) ? 1  : cmp(*static_cast<NodeT*>(n), *static_cast<NodeT*>(node)) < 0;

      for (;;) {
        if (n->_getChild(dir) == f) {
          n->_setChild(dir, q);
          // RAW copy, including the color.
          q->_rbNodeData[0] = f->_rbNodeData[0];
          q->_rbNodeData[1] = f->_rbNodeData[1];
          break;
        }

        n = n->_getChild(dir);

        // Cannot be true as we know that it must reach `f` in few iterations.
        ASMJIT_ASSERT(n != nullptr);
        dir = cmp(*static_cast<NodeT*>(n), *static_cast<NodeT*>(node)) < 0;
      }
    }

    // Update root and make it black.
    _root = static_cast<NodeT*>(head._getRight());
    if (_root) _root->_makeBlack();
  }

  template<typename KeyT, typename CompareT = Support::Compare<Support::kSortAscending>>
  ASMJIT_INLINE NodeT* get(const KeyT& key, const CompareT& cmp = CompareT()) const noexcept {
    ZoneTreeNode* node = _root;
    while (node) {
      auto result = cmp(*static_cast<const NodeT*>(node), key);
      if (result == 0) break;

      // Go left or right depending on the `result`.
      node = node->_getChild(result < 0);
    }
    return static_cast<NodeT*>(node);
  }

  // --------------------------------------------------------------------------
  // [Swap]
  // --------------------------------------------------------------------------

  inline void swapWith(ZoneTree& other) noexcept {
    std::swap(_root, other._root);
  }

  // --------------------------------------------------------------------------
  // [Internal]
  // --------------------------------------------------------------------------

  static inline bool _isValidRed(ZoneTreeNode* node) noexcept { return ZoneTreeNode::_isValidRed(node); }

  //! Single rotation.
  static ASMJIT_INLINE ZoneTreeNode* _singleRotate(ZoneTreeNode* root, size_t dir) noexcept {
    ZoneTreeNode* save = root->_getChild(!dir);
    root->_setChild(!dir, save->_getChild(dir));
    save->_setChild( dir, root);
    root->_makeRed();
    save->_makeBlack();
    return save;
  }

  //! Double rotation.
  static ASMJIT_INLINE ZoneTreeNode* _doubleRotate(ZoneTreeNode* root, size_t dir) noexcept {
    root->_setChild(!dir, _singleRotate(root->_getChild(!dir), !dir));
    return _singleRotate(root, dir);
  }

  // --------------------------------------------------------------------------
  // [Members]
  // --------------------------------------------------------------------------

  NodeT* _root;
};

//! \}

ASMJIT_END_NAMESPACE

// [Guard]
#endif // _ASMJIT_CORE_ZONETREE_H

```

`Avanguard/AsmJit/asmjit/core/zonevector.h`:

```h
// [AsmJit]
// Complete x86/x64 JIT and Remote Assembler for C++.
//
// [License]
// ZLIB - See LICENSE.md file in the package.

// [Guard]
#ifndef _ASMJIT_CORE_ZONEVECTOR_H
#define _ASMJIT_CORE_ZONEVECTOR_H

// [Dependencies]
#include "../core/support.h"
#include "../core/zone.h"

ASMJIT_BEGIN_NAMESPACE

//! \addtogroup asmjit_core_support
//! \{

// ============================================================================
// [asmjit::ZoneVectorBase]
// ============================================================================

//! \internal
class ZoneVectorBase {
public:
  ASMJIT_NONCOPYABLE(ZoneVectorBase)

  // STL compatibility;
  typedef uint32_t size_type;
  typedef ptrdiff_t difference_type;

protected:
  // --------------------------------------------------------------------------
  // [Construction / Destruction]
  // --------------------------------------------------------------------------

  //! Create a new instance of `ZoneVectorBase`.
  inline ZoneVectorBase() noexcept
    : _data(nullptr),
      _size(0),
      _capacity(0) {}

  inline ZoneVectorBase(ZoneVectorBase&& other) noexcept
    : _data(other._data),
      _size(other._size),
      _capacity(other._capacity) {}

  // --------------------------------------------------------------------------
  // [Accessors]
  // --------------------------------------------------------------------------

public:
  //! Get whether the vector is empty.
  inline bool empty() const noexcept { return _size == 0; }
  //! Get vector size.
  inline size_type size() const noexcept { return _size; }
  //! Get vector capacity.
  inline size_type capacity() const noexcept { return _capacity; }

  // --------------------------------------------------------------------------
  // [Ops]
  // --------------------------------------------------------------------------

  //! Makes the vector empty (won't change the capacity or data pointer).
  inline void clear() noexcept { _size = 0; }
  //! Reset the vector data and set its `size` to zero.
  inline void reset() noexcept {
    _data = nullptr;
    _size = 0;
    _capacity = 0;
  }

  //! Truncate the vector to at most `n` items.
  inline void truncate(size_type n) noexcept {
    _size = std::min(_size, n);
  }

  //! Set size of the vector to `n`. Used internally by some algorithms.
  inline void _setSize(size_type n) noexcept {
    ASMJIT_ASSERT(n <= _capacity);
    _size = n;
  }

  // --------------------------------------------------------------------------
  // [Memory Management]
  // --------------------------------------------------------------------------

protected:
  inline void _release(ZoneAllocator* allocator, uint32_t sizeOfT) noexcept {
    if (_data != nullptr) {
      allocator->release(_data, _capacity * sizeOfT);
      reset();
    }
  }

  ASMJIT_API Error _grow(ZoneAllocator* allocator, uint32_t sizeOfT, uint32_t n) noexcept;
  ASMJIT_API Error _resize(ZoneAllocator* allocator, uint32_t sizeOfT, uint32_t n) noexcept;
  ASMJIT_API Error _reserve(ZoneAllocator* allocator, uint32_t sizeOfT, uint32_t n) noexcept;

  // --------------------------------------------------------------------------
  // [Swap]
  // --------------------------------------------------------------------------

  inline void swapWith(ZoneVectorBase& other) noexcept {
    std::swap(_data, other._data);
    std::swap(_size, other._size);
    std::swap(_capacity, other._capacity);
  }

  // --------------------------------------------------------------------------
  // [Members]
  // --------------------------------------------------------------------------

public:
  void* _data;                           //!< Vector data (untyped).
  size_type _size;                       //!< Size of the vector.
  size_type _capacity;                   //!< Capacity of the vector.
};

// ============================================================================
// [asmjit::ZoneVector<T>]
// ============================================================================

//! Template used to store and manage array of Zone allocated data.
//!
//! This template has these advantages over other std::vector<>:
//! - Always non-copyable (designed to be non-copyable, we want it).
//! - No copy-on-write (some implementations of STL can use it).
//! - Optimized for working only with POD types.
//! - Uses ZoneAllocator, thus small vectors are basically for free.
template <typename T>
class ZoneVector : public ZoneVectorBase {
public:
  ASMJIT_NONCOPYABLE(ZoneVector<T>)

  // STL compatibility;
  typedef T value_type;
  typedef T* pointer;
  typedef const T* const_pointer;
  typedef T& reference;
  typedef const T& const_reference;

  typedef Support::Iterator<T> iterator;
  typedef Support::Iterator<const T> const_iterator;
  typedef Support::ReverseIterator<T> reverse_iterator;
  typedef Support::ReverseIterator<const T> const_reverse_iterator;

  // --------------------------------------------------------------------------
  // [Construction / Destruction]
  // --------------------------------------------------------------------------

  inline ZoneVector() noexcept : ZoneVectorBase() {}
  inline ZoneVector(ZoneVector&& other) noexcept : ZoneVector(other) {}

  // --------------------------------------------------------------------------
  // [Accessors]
  // --------------------------------------------------------------------------

  //! Get data.
  inline T* data() noexcept { return static_cast<T*>(_data); }
  //! \overload
  inline const T* data() const noexcept { return static_cast<const T*>(_data); }

  //! Get item at index `i` (const).
  inline const T& at(uint32_t i) const noexcept {
    ASMJIT_ASSERT(i < _size);
    return data()[i];
  }

  inline void _setEndPtr(T* p) noexcept {
    ASMJIT_ASSERT(p >= data() && p <= data() + _capacity);
    _setSize(uint32_t((uintptr_t)(p - data())));
  }

  // --------------------------------------------------------------------------
  // [Iterators]
  // --------------------------------------------------------------------------

  // STL compatibility.
  inline iterator begin() noexcept { return iterator(data()); };
  inline const_iterator begin() const noexcept { return const_iterator(data()); };

  inline iterator end() noexcept { return iterator(data() + _size); };
  inline const_iterator end() const noexcept { return const_iterator(data() + _size); };

  inline reverse_iterator rbegin() noexcept { return reverse_iterator(data()); };
  inline const_reverse_iterator rbegin() const noexcept { return const_reverse_iterator(data()); };

  inline reverse_iterator rend() noexcept { return reverse_iterator(data() + _size); };
  inline const_reverse_iterator rend() const noexcept { return const_reverse_iterator(data() + _size); };

  inline const_iterator cbegin() const noexcept { return const_iterator(data()); };
  inline const_iterator cend() const noexcept { return const_iterator(data() + _size); };

  inline const_reverse_iterator crbegin() const noexcept { return const_reverse_iterator(data()); };
  inline const_reverse_iterator crend() const noexcept { return const_reverse_iterator(data() + _size); };

  // --------------------------------------------------------------------------
  // [Operations]
  // --------------------------------------------------------------------------

  //! Prepend `item` to the vector.
  inline Error prepend(ZoneAllocator* allocator, const T& item) noexcept {
    if (ASMJIT_UNLIKELY(_size == _capacity))
      ASMJIT_PROPAGATE(grow(allocator, 1));

    std::memmove(static_cast<T*>(_data) + 1, _data, size_t(_size) * sizeof(T));
    std::memcpy(_data, &item, sizeof(T));

    _size++;
    return kErrorOk;
  }

  //! Insert an `item` at the specified `index`.
  inline Error insert(ZoneAllocator* allocator, uint32_t index, const T& item) noexcept {
    ASMJIT_ASSERT(index <= _size);

    if (ASMJIT_UNLIKELY(_size == _capacity))
      ASMJIT_PROPAGATE(grow(allocator, 1));

    T* dst = static_cast<T*>(_data) + index;
    std::memmove(dst + 1, dst, size_t(_size - index) * sizeof(T));
    std::memcpy(dst, &item, sizeof(T));
    _size++;

    return kErrorOk;
  }

  //! Append `item` to the vector.
  inline Error append(ZoneAllocator* allocator, const T& item) noexcept {
    if (ASMJIT_UNLIKELY(_size == _capacity))
      ASMJIT_PROPAGATE(grow(allocator, 1));

    std::memcpy(static_cast<T*>(_data) + _size, &item, sizeof(T));
    _size++;

    return kErrorOk;
  }

  inline Error concat(ZoneAllocator* allocator, const ZoneVector<T>& other) noexcept {
    uint32_t size = other._size;
    if (_capacity - _size < size)
      ASMJIT_PROPAGATE(grow(allocator, size));

    if (size) {
      std::memcpy(static_cast<T*>(_data) + _size, other._data, size_t(size) * sizeof(T));
      _size += size;
    }

    return kErrorOk;
  }

  //! Prepend `item` to the vector (unsafe case).
  //!
  //! Can only be used together with `willGrow()`. If `willGrow(N)` returns
  //! `kErrorOk` then N elements can be added to the vector without checking
  //! if there is a place for them. Used mostly internally.
  inline void prependUnsafe(const T& item) noexcept {
    ASMJIT_ASSERT(_size < _capacity);
    T* data = static_cast<T*>(_data);

    if (_size)
      std::memmove(data + 1, data, size_t(_size) * sizeof(T));

    std::memcpy(data, &item, sizeof(T));
    _size++;
  }

  //! Append `item` to the vector (unsafe case).
  //!
  //! Can only be used together with `willGrow()`. If `willGrow(N)` returns
  //! `kErrorOk` then N elements can be added to the vector without checking
  //! if there is a place for them. Used mostly internally.
  inline void appendUnsafe(const T& item) noexcept {
    ASMJIT_ASSERT(_size < _capacity);

    std::memcpy(static_cast<T*>(_data) + _size, &item, sizeof(T));
    _size++;
  }

  //! Concatenate all items of `other` at the end of the vector.
  inline void concatUnsafe(const ZoneVector<T>& other) noexcept {
    uint32_t size = other._size;
    ASMJIT_ASSERT(_capacity - _size >= size);

    if (size) {
      std::memcpy(static_cast<T*>(_data) + _size, other._data, size_t(size) * sizeof(T));
      _size += size;
    }
  }

  //! Get index of `val` or `Globals::kNotFound` if not found.
  inline uint32_t indexOf(const T& val) const noexcept {
    const T* data = static_cast<const T*>(_data);
    uint32_t size = _size;

    for (uint32_t i = 0; i < size; i++)
      if (data[i] == val)
        return i;
    return Globals::kNotFound;
  }

  //! Get whether the vector contains `val`.
  inline bool contains(const T& val) const noexcept {
    return indexOf(val) != Globals::kNotFound;
  }

  //! Remove item at index `i`.
  inline void removeAt(uint32_t i) noexcept {
    ASMJIT_ASSERT(i < _size);

    T* data = static_cast<T*>(_data) + i;
    uint32_t size = --_size - i;

    if (size)
      std::memmove(data, data + 1, size_t(size) * sizeof(T));
  }

  inline T pop() noexcept {
    ASMJIT_ASSERT(_size > 0);

    uint32_t index = --_size;
    return data()[index];
  }

  //! Swap this pod-vector with `other`.
  inline void swap(ZoneVector<T>& other) noexcept {
    std::swap(_size, other._size);
    std::swap(_capacity, other._capacity);
    std::swap(_data, other._data);
  }

  template<typename CompareT = Support::Compare<Support::kSortAscending>>
  inline void sort(const CompareT& cmp = CompareT()) noexcept {
    Support::qSort<T, CompareT>(data(), size(), cmp);
  }

  //! Get item at index `i`.
  inline T& operator[](uint32_t i) noexcept {
    ASMJIT_ASSERT(i < _size);
    return data()[i];
  }

  //! Get item at index `i`.
  inline const T& operator[](uint32_t i) const noexcept {
    ASMJIT_ASSERT(i < _size);
    return data()[i];
  }

  inline T& first() noexcept { return operator[](0); }
  inline const T& first() const noexcept { return operator[](0); }

  inline T& last() noexcept { return operator[](_size - 1); }
  inline const T& last() const noexcept { return operator[](_size - 1); }

  // --------------------------------------------------------------------------
  // [Memory Management]
  // --------------------------------------------------------------------------

  //! Release the memory held by `ZoneVector<T>` back to the `allocator`.
  inline void release(ZoneAllocator* allocator) noexcept {
    _release(allocator, sizeof(T));
  }

  //! Called to grow the buffer to fit at least `n` elements more.
  inline Error grow(ZoneAllocator* allocator, uint32_t n) noexcept {
    return ZoneVectorBase::_grow(allocator, sizeof(T), n);
  }

  //! Resize the vector to hold `n` elements.
  //!
  //! If `n` is greater than the current size then the additional elements'
  //! content will be initialized to zero. If `n` is less than the current
  //! size then the vector will be truncated to exactly `n` elements.
  inline Error resize(ZoneAllocator* allocator, uint32_t n) noexcept {
    return ZoneVectorBase::_resize(allocator, sizeof(T), n);
  }

  //! Realloc internal array to fit at least `n` items.
  inline Error reserve(ZoneAllocator* allocator, uint32_t n) noexcept {
    return n > _capacity ? ZoneVectorBase::_reserve(allocator, sizeof(T), n) : Error(kErrorOk);
  }

  inline Error willGrow(ZoneAllocator* allocator, uint32_t n = 1) noexcept {
    return _capacity - _size < n ? grow(allocator, n) : Error(kErrorOk);
  }

  // --------------------------------------------------------------------------
  // [Swap]
  // --------------------------------------------------------------------------

  inline void swapWith(ZoneVector<T>& other) noexcept {
    ZoneVectorBase::swapWith(other);
  }
};

// ============================================================================
// [asmjit::ZoneBitVector]
// ============================================================================

class ZoneBitVector {
public:
  ASMJIT_NONCOPYABLE(ZoneBitVector)

  typedef Support::BitWord BitWord;
  static constexpr uint32_t kBitWordSizeInBits = Support::kBitWordSizeInBits;

  static inline uint32_t _wordsPerBits(uint32_t nBits) noexcept {
    return ((nBits + kBitWordSizeInBits - 1) / kBitWordSizeInBits);
  }

  static inline void _zeroBits(BitWord* dst, uint32_t nBitWords) noexcept {
    for (uint32_t i = 0; i < nBitWords; i++)
      dst[i] = 0;
  }

  static inline void _fillBits(BitWord* dst, uint32_t nBitWords) noexcept {
    for (uint32_t i = 0; i < nBitWords; i++)
      dst[i] = ~BitWord(0);
  }

  static inline void _copyBits(BitWord* dst, const BitWord* src, uint32_t nBitWords) noexcept {
    for (uint32_t i = 0; i < nBitWords; i++)
      dst[i] = src[i];
  }

  // --------------------------------------------------------------------------
  // [Construction / Destruction]
  // --------------------------------------------------------------------------

  inline ZoneBitVector() noexcept
    : _data(nullptr),
      _size(0),
      _capacity(0) {}

  inline ZoneBitVector(ZoneBitVector&& other) noexcept
    : _data(other._data),
      _size(other._size),
      _capacity(other._capacity) {}

  // --------------------------------------------------------------------------
  // [Accessors]
  // --------------------------------------------------------------------------

  //! Get whether the bit-vector is empty (has no bits).
  inline bool empty() const noexcept { return _size == 0; }
  //! Get a size of this bit-vector (in bits).
  inline uint32_t size() const noexcept { return _size; }
  //! Get a capacity of this bit-vector (in bits).
  inline uint32_t capacity() const noexcept { return _capacity; }

  //! Get a count of `BitWord[]` array need to store all bits.
  inline uint32_t sizeInBitWords() const noexcept { return _wordsPerBits(_size); }
  //! Get a count of `BitWord[]` array need to store all bits.
  inline uint32_t capacityInBitWords() const noexcept { return _wordsPerBits(_capacity); }

  //! Get data.
  inline BitWord* data() noexcept { return _data; }
  //! \overload
  inline const BitWord* data() const noexcept { return _data; }

  // --------------------------------------------------------------------------
  // [Operations]
  // --------------------------------------------------------------------------

  inline void clear() noexcept {
    _size = 0;
  }

  inline void reset() noexcept {
    _data = nullptr;
    _size = 0;
    _capacity = 0;
  }

  inline void truncate(uint32_t newSize) noexcept {
    _size = std::min(_size, newSize);
    _clearUnusedBits();
  }

  inline bool bitAt(uint32_t index) const noexcept {
    ASMJIT_ASSERT(index < _size);
    return Support::bitVectorGetBit(_data, index);
  }

  inline void setBit(uint32_t index, bool value) noexcept {
    ASMJIT_ASSERT(index < _size);
    Support::bitVectorSetBit(_data, index, value);
  }

  inline void flipBit(uint32_t index) noexcept {
    ASMJIT_ASSERT(index < _size);
    Support::bitVectorFlipBit(_data, index);
  }

  ASMJIT_INLINE Error append(ZoneAllocator* allocator, bool value) noexcept {
    uint32_t index = _size;
    if (ASMJIT_UNLIKELY(index >= _capacity))
      return _append(allocator, value);

    uint32_t idx = index / kBitWordSizeInBits;
    uint32_t bit = index % kBitWordSizeInBits;

    if (bit == 0)
      _data[idx] = BitWord(value) << bit;
    else
      _data[idx] |= BitWord(value) << bit;

    _size++;
    return kErrorOk;
  }

  ASMJIT_API Error copyFrom(ZoneAllocator* allocator, const ZoneBitVector& other) noexcept;

  inline void clearAll() noexcept {
    _zeroBits(_data, _wordsPerBits(_size));
  }

  inline void fillAll() noexcept {
    _fillBits(_data, _wordsPerBits(_size));
    _clearUnusedBits();
  }

  inline void clearBits(uint32_t start, uint32_t count) noexcept {
    ASMJIT_ASSERT(start <= _size);
    ASMJIT_ASSERT(_size - start >= count);

    Support::bitVectorClear(_data, start, count);
  }

  inline void fillBits(uint32_t start, uint32_t count) noexcept {
    ASMJIT_ASSERT(start <= _size);
    ASMJIT_ASSERT(_size - start >= count);

    Support::bitVectorFill(_data, start, count);
  }

  //! Perform a logical bitwise AND between bits specified in this array and bits
  //! in `other`. If `other` has less bits than `this` then all remaining bits are
  //! set to zero.
  //!
  //! NOTE: The size of the BitVector is unaffected by this operation.
  inline void and_(const ZoneBitVector& other) noexcept {
    BitWord* dst = _data;
    const BitWord* src = other._data;

    uint32_t thisBitWordCount = sizeInBitWords();
    uint32_t otherBitWordCount = other.sizeInBitWords();
    uint32_t commonBitWordCount = std::min(thisBitWordCount, otherBitWordCount);

    uint32_t i = 0;
    while (i < commonBitWordCount) {
      dst[i] = dst[i] & src[i];
      i++;
    }

    while (i < thisBitWordCount) {
      dst[i] = 0;
      i++;
    }
  }

  //! Perform a logical bitwise AND between bits specified in this array and
  //! negated bits in `other`. If `other` has less bits than `this` then all
  //! remaining bits are kept intact.
  //!
  //! NOTE: The size of the BitVector is unaffected by this operation.
  inline void andNot(const ZoneBitVector& other) noexcept {
    BitWord* dst = _data;
    const BitWord* src = other._data;

    uint32_t commonBitWordCount = _wordsPerBits(std::min(_size, other._size));
    for (uint32_t i = 0; i < commonBitWordCount; i++)
      dst[i] = dst[i] & ~src[i];
  }

  //! Perform a logical bitwise OP between bits specified in this array and bits
  //! in `other`. If `other` has less bits than `this` then all remaining bits
  //! are kept intact.
  //!
  //! NOTE: The size of the BitVector is unaffected by this operation.
  inline void or_(const ZoneBitVector& other) noexcept {
    BitWord* dst = _data;
    const BitWord* src = other._data;

    uint32_t commonBitWordCount = _wordsPerBits(std::min(_size, other._size));
    for (uint32_t i = 0; i < commonBitWordCount; i++)
      dst[i] = dst[i] | src[i];
    _clearUnusedBits();
  }

  inline void _clearUnusedBits() noexcept {
    uint32_t idx = _size / kBitWordSizeInBits;
    uint32_t bit = _size % kBitWordSizeInBits;

    if (!bit) return;
    _data[idx] &= (BitWord(1) << bit) - 1u;
  }

  inline bool eq(const ZoneBitVector& other) const noexcept {
    if (_size != other._size)
      return false;

    const BitWord* aData = _data;
    const BitWord* bData = other._data;
    uint32_t numBitWords = _wordsPerBits(_size);

    for (uint32_t i = 0; i < numBitWords; i++)
      if (aData[i] != bData[i])
        return false;
    return true;
  }

  inline bool operator==(const ZoneBitVector& other) const noexcept { return  eq(other); }
  inline bool operator!=(const ZoneBitVector& other) const noexcept { return !eq(other); }

  // --------------------------------------------------------------------------
  // [Memory Management]
  // --------------------------------------------------------------------------

  inline void release(ZoneAllocator* allocator) noexcept {
    if (!_data) return;
    allocator->release(_data, _capacity / 8);
    reset();
  }

  inline Error resize(ZoneAllocator* allocator, uint32_t newSize, bool newBitsValue = false) noexcept {
    return _resize(allocator, newSize, newSize, newBitsValue);
  }

  ASMJIT_API Error _resize(ZoneAllocator* allocator, uint32_t newSize, uint32_t idealCapacity, bool newBitsValue) noexcept;
  ASMJIT_API Error _append(ZoneAllocator* allocator, bool value) noexcept;

  // --------------------------------------------------------------------------
  // [Swap]
  // --------------------------------------------------------------------------

  inline void swapWith(ZoneBitVector& other) noexcept {
    std::swap(_data, other._data);
    std::swap(_size, other._size);
    std::swap(_capacity, other._capacity);
  }

  // --------------------------------------------------------------------------
  // [Iterators]
  // --------------------------------------------------------------------------

  class ForEachBitSet : public Support::BitVectorIterator<BitWord> {
  public:
    ASMJIT_INLINE explicit ForEachBitSet(const ZoneBitVector& bitVector) noexcept
      : Support::BitVectorIterator<BitWord>(bitVector.data(), bitVector.sizeInBitWords()) {}
  };

  template<class Operator>
  class ForEachBitOp : public Support::BitVectorOpIterator<BitWord, Operator> {
  public:
    ASMJIT_INLINE ForEachBitOp(const ZoneBitVector& a, const ZoneBitVector& b) noexcept
      : Support::BitVectorOpIterator<BitWord, Operator>(a.data(), b.data(), a.sizeInBitWords()) {
      ASMJIT_ASSERT(a.size() == b.size());
    }
  };

  // --------------------------------------------------------------------------
  // [Members]
  // --------------------------------------------------------------------------

  BitWord* _data;                        //!< Bits.
  uint32_t _size;                        //!< Size of the bit-vector (in bits).
  uint32_t _capacity;                    //!< Capacity of the bit-vector (in bits).
};

//! \}

ASMJIT_END_NAMESPACE

// [Guard]
#endif // _ASMJIT_CORE_ZONEVECTOR_H

```

`Avanguard/AsmJit/asmjit/x86.h`:

```h
// [AsmJit]
// Complete x86/x64 JIT and Remote Assembler for C++.
//
// [License]
// ZLIB - See LICENSE.md file in the package.

// [Guard]
#ifndef _ASMJIT_X86_H
#define _ASMJIT_X86_H

// [Dependencies]
#include "./core.h"

#include "./x86/x86assembler.h"
#include "./x86/x86builder.h"
#include "./x86/x86compiler.h"
#include "./x86/x86emitter.h"
#include "./x86/x86features.h"
#include "./x86/x86globals.h"
#include "./x86/x86instdb.h"
#include "./x86/x86operand.h"

// DEPRECATED:
ASMJIT_BEGIN_NAMESPACE
typedef ASMJIT_DEPRECATED(x86::Reg  X86Reg  , "Use x86::Reg");
typedef ASMJIT_DEPRECATED(x86::Mem  X86Mem  , "Use x86::Mem");
typedef ASMJIT_DEPRECATED(x86::Gp   X86Gp   , "Use x86::Xmm");
typedef ASMJIT_DEPRECATED(x86::Gpb  X86Gpb  , "Use x86::Gpb");
typedef ASMJIT_DEPRECATED(x86::Gpw  X86Gpw  , "Use x86::Gpw");
typedef ASMJIT_DEPRECATED(x86::Gpd  X86Gpd  , "Use x86::Gpd");
typedef ASMJIT_DEPRECATED(x86::Gpq  X86Gpq  , "Use x86::Gpq");
typedef ASMJIT_DEPRECATED(x86::Vec  X86Vec  , "Use x86::Vec");
typedef ASMJIT_DEPRECATED(x86::Xmm  X86Xmm  , "Use x86::Xmm");
typedef ASMJIT_DEPRECATED(x86::Ymm  X86Ymm  , "Use x86::Ymm");
typedef ASMJIT_DEPRECATED(x86::Zmm  X86Zmm  , "Use x86::Zmm");
typedef ASMJIT_DEPRECATED(x86::Mm   X86Mm   , "Use x86::Mm");
typedef ASMJIT_DEPRECATED(x86::KReg X86KReg , "Use x86::KReg");
typedef ASMJIT_DEPRECATED(x86::SReg X86Seg  , "Use x86::SReg");
typedef ASMJIT_DEPRECATED(x86::CReg X86CReg , "Use x86::CReg");
typedef ASMJIT_DEPRECATED(x86::DReg X86DReg , "Use x86::DReg");
typedef ASMJIT_DEPRECATED(x86::St   X86Fp   , "Use x86::St");
typedef ASMJIT_DEPRECATED(x86::Bnd  X86Bnd  , "Use x86::Bnd");
typedef ASMJIT_DEPRECATED(x86::Rip  X86Rip  , "Use x86::Rip");
ASMJIT_END_NAMESPACE

// [Guard]
#endif // _ASMJIT_X86_H

```

`Avanguard/AsmJit/asmjit/x86/x86assembler.h`:

```h
// [AsmJit]
// Complete x86/x64 JIT and Remote Assembler for C++.
//
// [License]
// ZLIB - See LICENSE.md file in the package.

// [Guard]
#ifndef _ASMJIT_X86_X86ASSEMBLER_H
#define _ASMJIT_X86_X86ASSEMBLER_H

// [Dependencies]
#include "../core/assembler.h"
#include "../x86/x86emitter.h"
#include "../x86/x86operand.h"

ASMJIT_BEGIN_SUB_NAMESPACE(x86)

//! \addtogroup asmjit_x86_api
//! \{

// ============================================================================
// [asmjit::Assembler]
// ============================================================================

//! Assembler (X86).
//!
//! Emits X86 machine-code into buffers managed by `CodeHolder`.
class ASMJIT_VIRTAPI Assembler
  : public BaseAssembler,
    public EmitterImplicitT<Assembler> {
public:
  ASMJIT_NONCOPYABLE(Assembler)
  typedef BaseAssembler Base;

  // --------------------------------------------------------------------------
  // [Construction / Destruction]
  // --------------------------------------------------------------------------

  ASMJIT_API explicit Assembler(CodeHolder* code = nullptr) noexcept;
  ASMJIT_API virtual ~Assembler() noexcept;

  // --------------------------------------------------------------------------
  // [Internal]
  // --------------------------------------------------------------------------

  // NOTE: x86::Assembler uses _privateData to store 'address-override' bit that
  // is used to decide whether to emit address-override (67H) prefix based on
  // the memory BASE+INDEX registers. It's either `kX86MemInfo_67H_X86` or
  // `kX86MemInfo_67H_X64`.
  inline uint32_t _addressOverrideMask() const noexcept { return _privateData; }
  inline void _setAddressOverrideMask(uint32_t m) noexcept { _privateData = m; }

  // --------------------------------------------------------------------------
  // [Emit (Low-Level)]
  // --------------------------------------------------------------------------

  using BaseEmitter::_emit;

  ASMJIT_API Error _emit(uint32_t instId, const Operand_& o0, const Operand_& o1, const Operand_& o2, const Operand_& o3) override;

  // --------------------------------------------------------------------------
  // [Align]
  // --------------------------------------------------------------------------

  ASMJIT_API Error align(uint32_t alignMode, uint32_t alignment) override;

  // --------------------------------------------------------------------------
  // [Events]
  // --------------------------------------------------------------------------

  ASMJIT_API Error onAttach(CodeHolder* code) noexcept override;
  ASMJIT_API Error onDetach(CodeHolder* code) noexcept override;
};

//! \}

ASMJIT_END_SUB_NAMESPACE

// [Guard]
#endif // _ASMJIT_X86_X86ASSEMBLER_H

```

`Avanguard/AsmJit/asmjit/x86/x86builder.h`:

```h
// [AsmJit]
// Complete x86/x64 JIT and Remote Assembler for C++.
//
// [License]
// ZLIB - See LICENSE.md file in the package.

// [Guard]
#ifndef _ASMJIT_X86_X86BUILDER_H
#define _ASMJIT_X86_X86BUILDER_H

#include "../core/build.h"
#ifndef ASMJIT_DISABLE_BUILDER

// [Dependencies]
#include "../core/builder.h"
#include "../core/datatypes.h"
#include "../x86/x86emitter.h"

ASMJIT_BEGIN_SUB_NAMESPACE(x86)

//! \addtogroup asmjit_x86_api
//! \{

// ============================================================================
// [asmjit::x86::Builder]
// ============================================================================

//! Architecture-dependent asm-builder (X86).
class ASMJIT_VIRTAPI Builder
  : public BaseBuilder,
    public EmitterImplicitT<Builder> {
public:
  ASMJIT_NONCOPYABLE(Builder)
  typedef BaseBuilder Base;

  // --------------------------------------------------------------------------
  // [Construction / Destruction]
  // --------------------------------------------------------------------------

  ASMJIT_API explicit Builder(CodeHolder* code = nullptr) noexcept;
  ASMJIT_API virtual ~Builder() noexcept;

  // --------------------------------------------------------------------------
  // [Finalize]
  // --------------------------------------------------------------------------

  ASMJIT_API Error finalize() override;

  // --------------------------------------------------------------------------
  // [Events]
  // --------------------------------------------------------------------------

  ASMJIT_API Error onAttach(CodeHolder* code) noexcept override;
};

//! \}

ASMJIT_END_SUB_NAMESPACE

// [Guard]
#endif // !ASMJIT_DISABLE_BUILDER
#endif // _ASMJIT_X86_X86BUILDER_H

```

`Avanguard/AsmJit/asmjit/x86/x86callconv_p.h`:

```h
// [AsmJit]
// Complete x86/x64 JIT and Remote Assembler for C++.
//
// [License]
// ZLIB - See LICENSE.md file in the package.

#ifndef _ASMJIT_X86_X86CALLCONV_P_H
#define _ASMJIT_X86_X86CALLCONV_P_H

#include "../core/callconv.h"

ASMJIT_BEGIN_SUB_NAMESPACE(x86)

//! \addtogroup asmjit_x86_api
//! \{

// ============================================================================
// [asmjit::x86::CallConvInternal]
// ============================================================================

//! \internal
//!
//! X86-specific function API (calling conventions and other utilities).
namespace CallConvInternal {
  //! Initialize `CallConv` structure (X86 specific).
  Error init(CallConv& cc, uint32_t ccId) noexcept;
}

//! \}

ASMJIT_END_SUB_NAMESPACE

// [Guard]
#endif // _ASMJIT_X86_X86CALLCONV_P_H

```

`Avanguard/AsmJit/asmjit/x86/x86compiler.h`:

```h
// [AsmJit]
// Complete x86/x64 JIT and Remote Assembler for C++.
//
// [License]
// ZLIB - See LICENSE.md file in the package.

// [Guard]
#ifndef _ASMJIT_X86_X86COMPILER_H
#define _ASMJIT_X86_X86COMPILER_H

#include "../core/build.h"
#ifndef ASMJIT_DISABLE_COMPILER

// [Dependencies]
#include "../core/compiler.h"
#include "../core/datatypes.h"
#include "../core/type.h"
#include "../x86/x86emitter.h"

ASMJIT_BEGIN_SUB_NAMESPACE(x86)

//! \addtogroup asmjit_x86_api
//! \{

// ============================================================================
// [asmjit::x86::Compiler]
// ============================================================================

//! Architecture-dependent asm-compiler (X86).
class ASMJIT_VIRTAPI Compiler
  : public BaseCompiler,
    public EmitterExplicitT<Compiler> {
public:
  ASMJIT_NONCOPYABLE(Compiler)
  typedef BaseCompiler Base;

  // --------------------------------------------------------------------------
  // [Construction / Destruction]
  // --------------------------------------------------------------------------

  ASMJIT_API explicit Compiler(CodeHolder* code = nullptr) noexcept;
  ASMJIT_API virtual ~Compiler() noexcept;

  // --------------------------------------------------------------------------
  // [Finalize]
  // --------------------------------------------------------------------------

  ASMJIT_API Error finalize() override;

  // --------------------------------------------------------------------------
  // [VirtReg]
  // --------------------------------------------------------------------------

#ifndef ASMJIT_DISABLE_LOGGING
# define ASMJIT_NEW_REG(OUT, PARAM, NAME_FMT)                 \
    std::va_list ap;                                          \
    va_start(ap, NAME_FMT);                                   \
    _newReg(OUT, PARAM, NAME_FMT, ap);                        \
    va_end(ap)
#else
# define ASMJIT_NEW_REG(OUT, PARAM, NAME_FMT)                 \
    ASMJIT_UNUSED(NAME_FMT);                                  \
    _newReg(OUT, PARAM, nullptr)
#endif

#define ASMJIT_NEW_REG_USER(FUNC, REG)                        \
    inline REG FUNC(uint32_t typeId) {                        \
      REG reg(Globals::NoInit);                               \
      _newReg(reg, typeId, nullptr);                          \
      return reg;                                             \
    }                                                         \
                                                              \
    inline REG FUNC(uint32_t typeId, const char* fmt, ...) {  \
      REG reg(Globals::NoInit);                               \
      ASMJIT_NEW_REG(reg, typeId, fmt);                       \
      return reg;                                             \
    }

#define ASMJIT_NEW_REG_AUTO(FUNC, REG, TYPE_ID)               \
    inline REG FUNC() {                                       \
      REG reg(Globals::NoInit);                               \
      _newReg(reg, TYPE_ID, nullptr);                         \
      return reg;                                             \
    }                                                         \
                                                              \
    inline REG FUNC(const char* fmt, ...) {                   \
      REG reg(Globals::NoInit);                               \
      ASMJIT_NEW_REG(reg, TYPE_ID, fmt);                      \
      return reg;                                             \
    }

  template<typename RegT>
  inline RegT newSimilarReg(const RegT& ref) {
    RegT reg(Globals::NoInit);
    _newReg(reg, ref, nullptr);
    return reg;
  }

  template<typename RegT>
  inline RegT newSimilarReg(const RegT& ref, const char* fmt, ...) {
    RegT reg(Globals::NoInit);
    ASMJIT_NEW_REG(reg, ref, fmt);
    return reg;
  }

  ASMJIT_NEW_REG_USER(newReg    , Reg )
  ASMJIT_NEW_REG_USER(newGp     , Gp  )
  ASMJIT_NEW_REG_USER(newVec    , Vec )
  ASMJIT_NEW_REG_USER(newK      , KReg)

  ASMJIT_NEW_REG_AUTO(newI8     , Gp  , Type::kIdI8     )
  ASMJIT_NEW_REG_AUTO(newU8     , Gp  , Type::kIdU8     )
  ASMJIT_NEW_REG_AUTO(newI16    , Gp  , Type::kIdI16    )
  ASMJIT_NEW_REG_AUTO(newU16    , Gp  , Type::kIdU16    )
  ASMJIT_NEW_REG_AUTO(newI32    , Gp  , Type::kIdI32    )
  ASMJIT_NEW_REG_AUTO(newU32    , Gp  , Type::kIdU32    )
  ASMJIT_NEW_REG_AUTO(newI64    , Gp  , Type::kIdI64    )
  ASMJIT_NEW_REG_AUTO(newU64    , Gp  , Type::kIdU64    )
  ASMJIT_NEW_REG_AUTO(newInt8   , Gp  , Type::kIdI8     )
  ASMJIT_NEW_REG_AUTO(newUInt8  , Gp  , Type::kIdU8     )
  ASMJIT_NEW_REG_AUTO(newInt16  , Gp  , Type::kIdI16    )
  ASMJIT_NEW_REG_AUTO(newUInt16 , Gp  , Type::kIdU16    )
  ASMJIT_NEW_REG_AUTO(newInt32  , Gp  , Type::kIdI32    )
  ASMJIT_NEW_REG_AUTO(newUInt32 , Gp  , Type::kIdU32    )
  ASMJIT_NEW_REG_AUTO(newInt64  , Gp  , Type::kIdI64    )
  ASMJIT_NEW_REG_AUTO(newUInt64 , Gp  , Type::kIdU64    )
  ASMJIT_NEW_REG_AUTO(newIntPtr , Gp  , Type::kIdIntPtr )
  ASMJIT_NEW_REG_AUTO(newUIntPtr, Gp  , Type::kIdUIntPtr)

  ASMJIT_NEW_REG_AUTO(newGpb    , Gp  , Type::kIdU8     )
  ASMJIT_NEW_REG_AUTO(newGpw    , Gp  , Type::kIdU16    )
  ASMJIT_NEW_REG_AUTO(newGpd    , Gp  , Type::kIdU32    )
  ASMJIT_NEW_REG_AUTO(newGpq    , Gp  , Type::kIdU64    )
  ASMJIT_NEW_REG_AUTO(newGpz    , Gp  , Type::kIdUIntPtr)
  ASMJIT_NEW_REG_AUTO(newXmm    , Xmm , Type::kIdI32x4  )
  ASMJIT_NEW_REG_AUTO(newXmmSs  , Xmm , Type::kIdF32x1  )
  ASMJIT_NEW_REG_AUTO(newXmmSd  , Xmm , Type::kIdF64x1  )
  ASMJIT_NEW_REG_AUTO(newXmmPs  , Xmm , Type::kIdF32x4  )
  ASMJIT_NEW_REG_AUTO(newXmmPd  , Xmm , Type::kIdF64x2  )
  ASMJIT_NEW_REG_AUTO(newYmm    , Ymm , Type::kIdI32x8  )
  ASMJIT_NEW_REG_AUTO(newYmmPs  , Ymm , Type::kIdF32x8  )
  ASMJIT_NEW_REG_AUTO(newYmmPd  , Ymm , Type::kIdF64x4  )
  ASMJIT_NEW_REG_AUTO(newZmm    , Zmm , Type::kIdI32x16 )
  ASMJIT_NEW_REG_AUTO(newZmmPs  , Zmm , Type::kIdF32x16 )
  ASMJIT_NEW_REG_AUTO(newZmmPd  , Zmm , Type::kIdF64x8  )
  ASMJIT_NEW_REG_AUTO(newMm     , Mm  , Type::kIdMmx64  )
  ASMJIT_NEW_REG_AUTO(newKb     , KReg, Type::kIdMask8  )
  ASMJIT_NEW_REG_AUTO(newKw     , KReg, Type::kIdMask16 )
  ASMJIT_NEW_REG_AUTO(newKd     , KReg, Type::kIdMask32 )
  ASMJIT_NEW_REG_AUTO(newKq     , KReg, Type::kIdMask64 )

#undef ASMJIT_NEW_REG_AUTO
#undef ASMJIT_NEW_REG_USER
#undef ASMJIT_NEW_REG

  // --------------------------------------------------------------------------
  // [Stack]
  // --------------------------------------------------------------------------

  //! Create a new memory chunk allocated on the current function's stack.
  inline Mem newStack(uint32_t size, uint32_t alignment, const char* name = nullptr) {
    Mem m(Globals::NoInit);
    _newStack(m, size, alignment, name);
    return m;
  }

  // --------------------------------------------------------------------------
  // [Const]
  // --------------------------------------------------------------------------

  //! Put data to a constant-pool and get a memory reference to it.
  inline Mem newConst(uint32_t scope, const void* data, size_t size) {
    Mem m(Globals::NoInit);
    _newConst(m, scope, data, size);
    return m;
  }

  //! Put a BYTE `val` to a constant-pool.
  inline Mem newByteConst(uint32_t scope, uint8_t val) noexcept { return newConst(scope, &val, 1); }
  //! Put a WORD `val` to a constant-pool.
  inline Mem newWordConst(uint32_t scope, uint16_t val) noexcept { return newConst(scope, &val, 2); }
  //! Put a DWORD `val` to a constant-pool.
  inline Mem newDWordConst(uint32_t scope, uint32_t val) noexcept { return newConst(scope, &val, 4); }
  //! Put a QWORD `val` to a constant-pool.
  inline Mem newQWordConst(uint32_t scope, uint64_t val) noexcept { return newConst(scope, &val, 8); }

  //! Put a WORD `val` to a constant-pool.
  inline Mem newInt16Const(uint32_t scope, int16_t val) noexcept { return newConst(scope, &val, 2); }
  //! Put a WORD `val` to a constant-pool.
  inline Mem newUInt16Const(uint32_t scope, uint16_t val) noexcept { return newConst(scope, &val, 2); }
  //! Put a DWORD `val` to a constant-pool.
  inline Mem newInt32Const(uint32_t scope, int32_t val) noexcept { return newConst(scope, &val, 4); }
  //! Put a DWORD `val` to a constant-pool.
  inline Mem newUInt32Const(uint32_t scope, uint32_t val) noexcept { return newConst(scope, &val, 4); }
  //! Put a QWORD `val` to a constant-pool.
  inline Mem newInt64Const(uint32_t scope, int64_t val) noexcept { return newConst(scope, &val, 8); }
  //! Put a QWORD `val` to a constant-pool.
  inline Mem newUInt64Const(uint32_t scope, uint64_t val) noexcept { return newConst(scope, &val, 8); }

  //! Put a SP-FP `val` to a constant-pool.
  inline Mem newFloatConst(uint32_t scope, float val) noexcept { return newConst(scope, &val, 4); }
  //! Put a DP-FP `val` to a constant-pool.
  inline Mem newDoubleConst(uint32_t scope, double val) noexcept { return newConst(scope, &val, 8); }

  //! Put a MMX `val` to a constant-pool.
  inline Mem newMmConst(uint32_t scope, const Data64& val) noexcept { return newConst(scope, &val, 8); }
  //! Put a XMM `val` to a constant-pool.
  inline Mem newXmmConst(uint32_t scope, const Data128& val) noexcept { return newConst(scope, &val, 16); }
  //! Put a YMM `val` to a constant-pool.
  inline Mem newYmmConst(uint32_t scope, const Data256& val) noexcept { return newConst(scope, &val, 32); }

  // --------------------------------------------------------------------------
  // [Instruction Options]
  // --------------------------------------------------------------------------

  //! Force the compiler to not follow the conditional or unconditional jump.
  inline Compiler& unfollow() noexcept { _instOptions |= Inst::kOptionUnfollow; return *this; }
  //! Tell the compiler that the destination variable will be overwritten.
  inline Compiler& overwrite() noexcept { _instOptions |= Inst::kOptionOverwrite; return *this; }

  // --------------------------------------------------------------------------
  // [Emit]
  // --------------------------------------------------------------------------

  //! Call a function.
  inline FuncCallNode* call(const Gp& dst, const FuncSignature& sign) { return addCall(Inst::kIdCall, dst, sign); }
  //! \overload
  inline FuncCallNode* call(const Mem& dst, const FuncSignature& sign) { return addCall(Inst::kIdCall, dst, sign); }
  //! \overload
  inline FuncCallNode* call(const Label& label, const FuncSignature& sign) { return addCall(Inst::kIdCall, label, sign); }
  //! \overload
  inline FuncCallNode* call(const Imm& dst, const FuncSignature& sign) { return addCall(Inst::kIdCall, dst, sign); }
  //! \overload
  inline FuncCallNode* call(uint64_t dst, const FuncSignature& sign) { return addCall(Inst::kIdCall, Imm(int64_t(dst)), sign); }

  //! Return.
  inline FuncRetNode* ret() { return addRet(Operand(), Operand()); }
  //! \overload
  inline FuncRetNode* ret(const BaseReg& o0) { return addRet(o0, Operand()); }
  //! \overload
  inline FuncRetNode* ret(const BaseReg& o0, const BaseReg& o1) { return addRet(o0, o1); }

  // --------------------------------------------------------------------------
  // [Events]
  // --------------------------------------------------------------------------

  ASMJIT_API Error onAttach(CodeHolder* code) noexcept override;
};

//! \}

ASMJIT_END_SUB_NAMESPACE

// [Guard]
#endif // !ASMJIT_DISABLE_COMPILER
#endif // _ASMJIT_X86_X86COMPILER_H

```

`Avanguard/AsmJit/asmjit/x86/x86emitter.h`:

```h
// [AsmJit]
// Complete x86/x64 JIT and Remote Assembler for C++.
//
// [License]
// ZLIB - See LICENSE.md file in the package.

// [Guard]
#ifndef _ASMJIT_X86_X86EMITTER_H
#define _ASMJIT_X86_X86EMITTER_H

// [Dependencies]
#include "../core/emitter.h"
#include "../core/support.h"
#include "../x86/x86globals.h"
#include "../x86/x86operand.h"

ASMJIT_BEGIN_SUB_NAMESPACE(x86)

//! \addtogroup asmjit_x86_api
//! \{

// ============================================================================
// [asmjit::x86::EmitterExplicitT]
// ============================================================================

//! \internal
//! \{

#define ASMJIT_INST_0x(NAME, ID) \
  inline Error NAME() { return _emitter()->emit(Inst::kId##ID); }

#define ASMJIT_INST_1x(NAME, ID, T0) \
  inline Error NAME(const T0& o0) { return _emitter()->emit(Inst::kId##ID, o0); }

#define ASMJIT_INST_1i(NAME, ID, T0) \
  inline Error NAME(const T0& o0) { return _emitter()->emit(Inst::kId##ID, o0); } \
  inline Error NAME(int o0) { return _emitter()->emit(Inst::kId##ID, Support::asInt(o0)); } \
  inline Error NAME(unsigned int o0) { return _emitter()->emit(Inst::kId##ID, Support::asInt(o0)); } \
  inline Error NAME(int64_t o0) { return _emitter()->emit(Inst::kId##ID, Support::asInt(o0)); } \
  inline Error NAME(uint64_t o0) { return _emitter()->emit(Inst::kId##ID, Support::asInt(o0)); }

#define ASMJIT_INST_1c(NAME, ID, CONV, T0) \
  inline Error NAME(uint32_t cc, const T0& o0) { return _emitter()->emit(CONV(cc), o0); } \
  inline Error NAME##a(const T0& o0) { return _emitter()->emit(Inst::kId##ID##a, o0); } \
  inline Error NAME##ae(const T0& o0) { return _emitter()->emit(Inst::kId##ID##ae, o0); } \
  inline Error NAME##b(const T0& o0) { return _emitter()->emit(Inst::kId##ID##b, o0); } \
  inline Error NAME##be(const T0& o0) { return _emitter()->emit(Inst::kId##ID##be, o0); } \
  inline Error NAME##c(const T0& o0) { return _emitter()->emit(Inst::kId##ID##c, o0); } \
  inline Error NAME##e(const T0& o0) { return _emitter()->emit(Inst::kId##ID##e, o0); } \
  inline Error NAME##g(const T0& o0) { return _emitter()->emit(Inst::kId##ID##g, o0); } \
  inline Error NAME##ge(const T0& o0) { return _emitter()->emit(Inst::kId##ID##ge, o0); } \
  inline Error NAME##l(const T0& o0) { return _emitter()->emit(Inst::kId##ID##l, o0); } \
  inline Error NAME##le(const T0& o0) { return _emitter()->emit(Inst::kId##ID##le, o0); } \
  inline Error NAME##na(const T0& o0) { return _emitter()->emit(Inst::kId##ID##na, o0); } \
  inline Error NAME##nae(const T0& o0) { return _emitter()->emit(Inst::kId##ID##nae, o0); } \
  inline Error NAME##nb(const T0& o0) { return _emitter()->emit(Inst::kId##ID##nb, o0); } \
  inline Error NAME##nbe(const T0& o0) { return _emitter()->emit(Inst::kId##ID##nbe, o0); } \
  inline Error NAME##nc(const T0& o0) { return _emitter()->emit(Inst::kId##ID##nc, o0); } \
  inline Error NAME##ne(const T0& o0) { return _emitter()->emit(Inst::kId##ID##ne, o0); } \
  inline Error NAME##ng(const T0& o0) { return _emitter()->emit(Inst::kId##ID##ng, o0); } \
  inline Error NAME##nge(const T0& o0) { return _emitter()->emit(Inst::kId##ID##nge, o0); } \
  inline Error NAME##nl(const T0& o0) { return _emitter()->emit(Inst::kId##ID##nl, o0); } \
  inline Error NAME##nle(const T0& o0) { return _emitter()->emit(Inst::kId##ID##nle, o0); } \
  inline Error NAME##no(const T0& o0) { return _emitter()->emit(Inst::kId##ID##no, o0); } \
  inline Error NAME##np(const T0& o0) { return _emitter()->emit(Inst::kId##ID##np, o0); } \
  inline Error NAME##ns(const T0& o0) { return _emitter()->emit(Inst::kId##ID##ns, o0); } \
  inline Error NAME##nz(const T0& o0) { return _emitter()->emit(Inst::kId##ID##nz, o0); } \
  inline Error NAME##o(const T0& o0) { return _emitter()->emit(Inst::kId##ID##o, o0); } \
  inline Error NAME##p(const T0& o0) { return _emitter()->emit(Inst::kId##ID##p, o0); } \
  inline Error NAME##pe(const T0& o0) { return _emitter()->emit(Inst::kId##ID##pe, o0); } \
  inline Error NAME##po(const T0& o0) { return _emitter()->emit(Inst::kId##ID##po, o0); } \
  inline Error NAME##s(const T0& o0) { return _emitter()->emit(Inst::kId##ID##s, o0); } \
  inline Error NAME##z(const T0& o0) { return _emitter()->emit(Inst::kId##ID##z, o0); }

#define ASMJIT_INST_2x(NAME, ID, T0, T1) \
  inline Error NAME(const T0& o0, const T1& o1) { return _emitter()->emit(Inst::kId##ID, o0, o1); }

#define ASMJIT_INST_2i(NAME, ID, T0, T1) \
  inline Error NAME(const T0& o0, const T1& o1) { return _emitter()->emit(Inst::kId##ID, o0, o1); } \
  inline Error NAME(const T0& o0, int o1) { return _emitter()->emit(Inst::kId##ID, o0, Support::asInt(o1)); } \
  inline Error NAME(const T0& o0, unsigned int o1) { return _emitter()->emit(Inst::kId##ID, o0, Support::asInt(o1)); } \
  inline Error NAME(const T0& o0, int64_t o1) { return _emitter()->emit(Inst::kId##ID, o0, Support::asInt(o1)); } \
  inline Error NAME(const T0& o0, uint64_t o1) { return _emitter()->emit(Inst::kId##ID, o0, Support::asInt(o1)); }

#define ASMJIT_INST_2c(NAME, ID, CONV, T0, T1) \
  inline Error NAME(uint32_t cc, const T0& o0, const T1& o1) { return _emitter()->emit(CONV(cc), o0, o1); } \
  inline Error NAME##a(const T0& o0, const T1& o1) { return _emitter()->emit(Inst::kId##ID##a, o0, o1); } \
  inline Error NAME##ae(const T0& o0, const T1& o1) { return _emitter()->emit(Inst::kId##ID##ae, o0, o1); } \
  inline Error NAME##b(const T0& o0, const T1& o1) { return _emitter()->emit(Inst::kId##ID##b, o0, o1); } \
  inline Error NAME##be(const T0& o0, const T1& o1) { return _emitter()->emit(Inst::kId##ID##be, o0, o1); } \
  inline Error NAME##c(const T0& o0, const T1& o1) { return _emitter()->emit(Inst::kId##ID##c, o0, o1); } \
  inline Error NAME##e(const T0& o0, const T1& o1) { return _emitter()->emit(Inst::kId##ID##e, o0, o1); } \
  inline Error NAME##g(const T0& o0, const T1& o1) { return _emitter()->emit(Inst::kId##ID##g, o0, o1); } \
  inline Error NAME##ge(const T0& o0, const T1& o1) { return _emitter()->emit(Inst::kId##ID##ge, o0, o1); } \
  inline Error NAME##l(const T0& o0, const T1& o1) { return _emitter()->emit(Inst::kId##ID##l, o0, o1); } \
  inline Error NAME##le(const T0& o0, const T1& o1) { return _emitter()->emit(Inst::kId##ID##le, o0, o1); } \
  inline Error NAME##na(const T0& o0, const T1& o1) { return _emitter()->emit(Inst::kId##ID##na, o0, o1); } \
  inline Error NAME##nae(const T0& o0, const T1& o1) { return _emitter()->emit(Inst::kId##ID##nae, o0, o1); } \
  inline Error NAME##nb(const T0& o0, const T1& o1) { return _emitter()->emit(Inst::kId##ID##nb, o0, o1); } \
  inline Error NAME##nbe(const T0& o0, const T1& o1) { return _emitter()->emit(Inst::kId##ID##nbe, o0, o1); } \
  inline Error NAME##nc(const T0& o0, const T1& o1) { return _emitter()->emit(Inst::kId##ID##nc, o0, o1); } \
  inline Error NAME##ne(const T0& o0, const T1& o1) { return _emitter()->emit(Inst::kId##ID##ne, o0, o1); } \
  inline Error NAME##ng(const T0& o0, const T1& o1) { return _emitter()->emit(Inst::kId##ID##ng, o0, o1); } \
  inline Error NAME##nge(const T0& o0, const T1& o1) { return _emitter()->emit(Inst::kId##ID##nge, o0, o1); } \
  inline Error NAME##nl(const T0& o0, const T1& o1) { return _emitter()->emit(Inst::kId##ID##nl, o0, o1); } \
  inline Error NAME##nle(const T0& o0, const T1& o1) { return _emitter()->emit(Inst::kId##ID##nle, o0, o1); } \
  inline Error NAME##no(const T0& o0, const T1& o1) { return _emitter()->emit(Inst::kId##ID##no, o0, o1); } \
  inline Error NAME##np(const T0& o0, const T1& o1) { return _emitter()->emit(Inst::kId##ID##np, o0, o1); } \
  inline Error NAME##ns(const T0& o0, const T1& o1) { return _emitter()->emit(Inst::kId##ID##ns, o0, o1); } \
  inline Error NAME##nz(const T0& o0, const T1& o1) { return _emitter()->emit(Inst::kId##ID##nz, o0, o1); } \
  inline Error NAME##o(const T0& o0, const T1& o1) { return _emitter()->emit(Inst::kId##ID##o, o0, o1); } \
  inline Error NAME##p(const T0& o0, const T1& o1) { return _emitter()->emit(Inst::kId##ID##p, o0, o1); } \
  inline Error NAME##pe(const T0& o0, const T1& o1) { return _emitter()->emit(Inst::kId##ID##pe, o0, o1); } \
  inline Error NAME##po(const T0& o0, const T1& o1) { return _emitter()->emit(Inst::kId##ID##po, o0, o1); } \
  inline Error NAME##s(const T0& o0, const T1& o1) { return _emitter()->emit(Inst::kId##ID##s, o0, o1); } \
  inline Error NAME##z(const T0& o0, const T1& o1) { return _emitter()->emit(Inst::kId##ID##z, o0, o1); }

#define ASMJIT_INST_3x(NAME, ID, T0, T1, T2) \
  inline Error NAME(const T0& o0, const T1& o1, const T2& o2) { return _emitter()->emit(Inst::kId##ID, o0, o1, o2); }

#define ASMJIT_INST_3i(NAME, ID, T0, T1, T2) \
  inline Error NAME(const T0& o0, const T1& o1, const T2& o2) { return _emitter()->emit(Inst::kId##ID, o0, o1, o2); } \
  inline Error NAME(const T0& o0, const T1& o1, int o2) { return _emitter()->emit(Inst::kId##ID, o0, o1, Support::asInt(o2)); } \
  inline Error NAME(const T0& o0, const T1& o1, unsigned int o2) { return _emitter()->emit(Inst::kId##ID, o0, o1, Support::asInt(o2)); } \
  inline Error NAME(const T0& o0, const T1& o1, int64_t o2) { return _emitter()->emit(Inst::kId##ID, o0, o1, Support::asInt(o2)); } \
  inline Error NAME(const T0& o0, const T1& o1, uint64_t o2) { return _emitter()->emit(Inst::kId##ID, o0, o1, Support::asInt(o2)); }

#define ASMJIT_INST_3ii(NAME, ID, T0, T1, T2) \
  inline Error NAME(const T0& o0, const T1& o1, const T2& o2) { return _emitter()->emit(Inst::kId##ID, o0, o1, o2); } \
  inline Error NAME(const T0& o0, int o1, int o2) { return _emitter()->emit(Inst::kId##ID, o0, Imm(o1), Support::asInt(o2)); }

#define ASMJIT_INST_4x(NAME, ID, T0, T1, T2, T3) \
  inline Error NAME(const T0& o0, const T1& o1, const T2& o2, const T3& o3) { return _emitter()->emit(Inst::kId##ID, o0, o1, o2, o3); }

#define ASMJIT_INST_4i(NAME, ID, T0, T1, T2, T3) \
  inline Error NAME(const T0& o0, const T1& o1, const T2& o2, const T3& o3) { return _emitter()->emit(Inst::kId##ID, o0, o1, o2, o3); } \
  inline Error NAME(const T0& o0, const T1& o1, const T2& o2, int o3) { return _emitter()->emit(Inst::kId##ID, o0, o1, o2, Support::asInt(o3)); } \
  inline Error NAME(const T0& o0, const T1& o1, const T2& o2, unsigned int o3) { return _emitter()->emit(Inst::kId##ID, o0, o1, o2, Support::asInt(o3)); } \
  inline Error NAME(const T0& o0, const T1& o1, const T2& o2, int64_t o3) { return _emitter()->emit(Inst::kId##ID, o0, o1, o2, Support::asInt(o3)); } \
  inline Error NAME(const T0& o0, const T1& o1, const T2& o2, uint64_t o3) { return _emitter()->emit(Inst::kId##ID, o0, o1, o2, Support::asInt(o3)); }

#define ASMJIT_INST_4ii(NAME, ID, T0, T1, T2, T3) \
  inline Error NAME(const T0& o0, const T1& o1, const T2& o2, const T3& o3) { return _emitter()->emit(Inst::kId##ID, o0, o1, o2, o3); } \
  inline Error NAME(const T0& o0, const T1& o1, int o2, int o3) { return _emitter()->emit(Inst::kId##ID, o0, o1, Imm(o2), Support::asInt(o3)); }

#define ASMJIT_INST_5x(NAME, ID, T0, T1, T2, T3, T4) \
  inline Error NAME(const T0& o0, const T1& o1, const T2& o2, const T3& o3, const T4& o4) { return _emitter()->emit(Inst::kId##ID, o0, o1, o2, o3, o4); }

#define ASMJIT_INST_5i(NAME, ID, T0, T1, T2, T3, T4) \
  inline Error NAME(const T0& o0, const T1& o1, const T2& o2, const T3& o3, const T4& o4) { return _emitter()->emit(Inst::kId##ID, o0, o1, o2, o3, o4); } \
  inline Error NAME(const T0& o0, const T1& o1, const T2& o2, const T3& o3, int o4) { return _emitter()->emit(Inst::kId##ID, o0, o1, o2, o3, Support::asInt(o4)); } \
  inline Error NAME(const T0& o0, const T1& o1, const T2& o2, const T3& o3, unsigned int o4) { return _emitter()->emit(Inst::kId##ID, o0, o1, o2, o3, Support::asInt(o4)); } \
  inline Error NAME(const T0& o0, const T1& o1, const T2& o2, const T3& o3, int64_t o4) { return _emitter()->emit(Inst::kId##ID, o0, o1, o2, o3, Support::asInt(o4)); } \
  inline Error NAME(const T0& o0, const T1& o1, const T2& o2, const T3& o3, uint64_t o4) { return _emitter()->emit(Inst::kId##ID, o0, o1, o2, o3, Support::asInt(o4)); }

#define ASMJIT_INST_6x(NAME, ID, T0, T1, T2, T3, T4, T5) \
  inline Error NAME(const T0& o0, const T1& o1, const T2& o2, const T3& o3, const T4& o4, const T5& o5) { return _emitter()->emit(Inst::kId##ID, o0, o1, o2, o3, o4, o5); }

//! \}

template<typename This>
struct EmitterExplicitT {
  // These typedefs are used to describe implicit operands passed explicitly.
  typedef Gp AL;
  typedef Gp AH;
  typedef Gp CL;
  typedef Gp AX;
  typedef Gp DX;

  typedef Gp EAX;
  typedef Gp EBX;
  typedef Gp ECX;
  typedef Gp EDX;

  typedef Gp RAX;
  typedef Gp RBX;
  typedef Gp RCX;
  typedef Gp RDX;

  typedef Gp ZAX;
  typedef Gp ZBX;
  typedef Gp ZCX;
  typedef Gp ZDX;

  typedef Mem DS_ZAX; // ds:[zax]
  typedef Mem DS_ZDI; // ds:[zdi]
  typedef Mem ES_ZDI; // es:[zdi]
  typedef Mem DS_ZSI; // ds:[zsi]

  typedef Xmm XMM0;

  // --------------------------------------------------------------------------
  // [Accessors]
  // --------------------------------------------------------------------------

  // These two are unfortunately reported by the sanitizer. We know what we do,
  // however, the sanitizer doesn't. I have tried to use reinterpret_cast instead,
  // but that would generate bad code when compiled by MSC.
  ASMJIT_CXX_NO_SANITIZE_UNDEFINED inline This* _emitter() noexcept { return static_cast<This*>(this); }
  ASMJIT_CXX_NO_SANITIZE_UNDEFINED inline const This* _emitter() const noexcept { return static_cast<const This*>(this); }

  //! Get either GPD or GPQ register of index `id` depending on the current architecture.
  inline Gp gpz(uint32_t id) const noexcept { return Gp(_emitter()->_gpRegInfo.signature(), id); }

  inline Gp zax() const noexcept { return Gp(_emitter()->_gpRegInfo.signature(), Gp::kIdAx); }
  inline Gp zcx() const noexcept { return Gp(_emitter()->_gpRegInfo.signature(), Gp::kIdCx); }
  inline Gp zdx() const noexcept { return Gp(_emitter()->_gpRegInfo.signature(), Gp::kIdDx); }
  inline Gp zbx() const noexcept { return Gp(_emitter()->_gpRegInfo.signature(), Gp::kIdBx); }
  inline Gp zsp() const noexcept { return Gp(_emitter()->_gpRegInfo.signature(), Gp::kIdSp); }
  inline Gp zbp() const noexcept { return Gp(_emitter()->_gpRegInfo.signature(), Gp::kIdBp); }
  inline Gp zsi() const noexcept { return Gp(_emitter()->_gpRegInfo.signature(), Gp::kIdSi); }
  inline Gp zdi() const noexcept { return Gp(_emitter()->_gpRegInfo.signature(), Gp::kIdDi); }

  //! Create a target dependent pointer of which base register's id is `baseId`.
  inline Mem ptr_base(uint32_t baseId, int32_t off = 0, uint32_t size = 0) const noexcept {
    uint32_t baseType = _emitter()->_gpRegInfo.type();
    uint32_t flags = 0;
    return Mem(Globals::Init, baseType, baseId, 0, 0, off, size, flags);
  }

  inline Mem ptr_zax(int32_t off = 0, uint32_t size = 0) const noexcept { return ptr_base(Gp::kIdAx, off, size); }
  inline Mem ptr_zcx(int32_t off = 0, uint32_t size = 0) const noexcept { return ptr_base(Gp::kIdCx, off, size); }
  inline Mem ptr_zdx(int32_t off = 0, uint32_t size = 0) const noexcept { return ptr_base(Gp::kIdDx, off, size); }
  inline Mem ptr_zbx(int32_t off = 0, uint32_t size = 0) const noexcept { return ptr_base(Gp::kIdBx, off, size); }
  inline Mem ptr_zsp(int32_t off = 0, uint32_t size = 0) const noexcept { return ptr_base(Gp::kIdSp, off, size); }
  inline Mem ptr_zbp(int32_t off = 0, uint32_t size = 0) const noexcept { return ptr_base(Gp::kIdBp, off, size); }
  inline Mem ptr_zsi(int32_t off = 0, uint32_t size = 0) const noexcept { return ptr_base(Gp::kIdSi, off, size); }
  inline Mem ptr_zdi(int32_t off = 0, uint32_t size = 0) const noexcept { return ptr_base(Gp::kIdDi, off, size); }

  //! Create an `intptr_t` memory operand depending on the current architecture.
  inline Mem intptr_ptr(const Gp& base, int32_t offset = 0) const noexcept {
    uint32_t nativeGpSize = static_cast<const This*>(this)->gpSize();
    return Mem(base, offset, nativeGpSize);
  }
  //! \overload
  inline Mem intptr_ptr(const Gp& base, const Gp& index, uint32_t shift = 0, int32_t offset = 0) const noexcept {
    uint32_t nativeGpSize = static_cast<const This*>(this)->gpSize();
    return Mem(base, index, shift, offset, nativeGpSize);
  }
  //! \overload
  inline Mem intptr_ptr(const Gp& base, const Vec& index, uint32_t shift = 0, int32_t offset = 0) const noexcept {
    uint32_t nativeGpSize = static_cast<const This*>(this)->gpSize();
    return Mem(base, index, shift, offset, nativeGpSize);
  }
  //! \overload
  inline Mem intptr_ptr(const Label& base, int32_t offset = 0) const noexcept {
    uint32_t nativeGpSize = static_cast<const This*>(this)->gpSize();
    return Mem(base, offset, nativeGpSize);
  }
  //! \overload
  inline Mem intptr_ptr(const Label& base, const Gp& index, uint32_t shift, int32_t offset = 0) const noexcept {
    uint32_t nativeGpSize = static_cast<const This*>(this)->gpSize();
    return Mem(base, index, shift, offset, nativeGpSize);
  }
  //! \overload
  inline Mem intptr_ptr(const Label& base, const Vec& index, uint32_t shift, int32_t offset = 0) const noexcept {
    uint32_t nativeGpSize = static_cast<const This*>(this)->gpSize();
    return Mem(base, index, shift, offset, nativeGpSize);
  }
  //! \overload
  inline Mem intptr_ptr(const Rip& rip, int32_t offset = 0) const noexcept {
    uint32_t nativeGpSize = static_cast<const This*>(this)->gpSize();
    return Mem(rip, offset, nativeGpSize);
  }
  //! \overload
  inline Mem intptr_ptr(uint64_t base) const noexcept {
    uint32_t nativeGpSize = static_cast<const This*>(this)->gpSize();
    return Mem(base, nativeGpSize);
  }
  //! \overload
  inline Mem intptr_ptr(uint64_t base, const Gp& index, uint32_t shift = 0) const noexcept {
    uint32_t nativeGpSize = static_cast<const This*>(this)->gpSize();
    return Mem(base, index, shift, nativeGpSize);
  }
  //! \overload
  inline Mem intptr_ptr_abs(uint64_t base) const noexcept {
    uint32_t nativeGpSize = static_cast<const This*>(this)->gpSize();
    return Mem(base, nativeGpSize, BaseMem::kSignatureMemAbs);
  }
  //! \overload
  inline Mem intptr_ptr_abs(uint64_t base, const Gp& index, uint32_t shift = 0) const noexcept {
    uint32_t nativeGpSize = static_cast<const This*>(this)->gpSize();
    return Mem(base, index, shift, nativeGpSize, BaseMem::kSignatureMemAbs);
  }

  // --------------------------------------------------------------------------
  // [Embed]
  // --------------------------------------------------------------------------

  //! Add 8-bit integer data to the instruction stream.
  inline Error db(uint8_t x) { return static_cast<This*>(this)->embed(&x, 1); }
  //! Add 16-bit integer data to the instruction stream.
  inline Error dw(uint16_t x) { return static_cast<This*>(this)->embed(&x, 2); }
  //! Add 32-bit integer data to the instruction stream.
  inline Error dd(uint32_t x) { return static_cast<This*>(this)->embed(&x, 4); }
  //! Add 64-bit integer data to the instruction stream.
  inline Error dq(uint64_t x) { return static_cast<This*>(this)->embed(&x, 8); }

  //! Add 8-bit integer data to the instruction stream.
  inline Error dint8(int8_t x) { return static_cast<This*>(this)->embed(&x, sizeof(int8_t)); }
  //! Add 8-bit integer data to the instruction stream.
  inline Error duint8(uint8_t x) { return static_cast<This*>(this)->embed(&x, sizeof(uint8_t)); }

  //! Add 16-bit integer data to the instruction stream.
  inline Error dint16(int16_t x) { return static_cast<This*>(this)->embed(&x, sizeof(int16_t)); }
  //! Add 16-bit integer data to the instruction stream.
  inline Error duint16(uint16_t x) { return static_cast<This*>(this)->embed(&x, sizeof(uint16_t)); }

  //! Add 32-bit integer data to the instruction stream.
  inline Error dint32(int32_t x) { return static_cast<This*>(this)->embed(&x, sizeof(int32_t)); }
  //! Add 32-bit integer data to the instruction stream.
  inline Error duint32(uint32_t x) { return static_cast<This*>(this)->embed(&x, sizeof(uint32_t)); }

  //! Add 64-bit integer data to the instruction stream.
  inline Error dint64(int64_t x) { return static_cast<This*>(this)->embed(&x, sizeof(int64_t)); }
  //! Add 64-bit integer data to the instruction stream.
  inline Error duint64(uint64_t x) { return static_cast<This*>(this)->embed(&x, sizeof(uint64_t)); }

  //! Add float data to the instruction stream.
  inline Error dfloat(float x) { return static_cast<This*>(this)->embed(&x, sizeof(float)); }
  //! Add double data to the instruction stream.
  inline Error ddouble(double x) { return static_cast<This*>(this)->embed(&x, sizeof(double)); }

  //! Add MMX data to the instruction stream.
  inline Error dmm(const Data64& x) { return static_cast<This*>(this)->embed(&x, sizeof(Data64)); }
  //! Add XMM data to the instruction stream.
  inline Error dxmm(const Data128& x) { return static_cast<This*>(this)->embed(&x, sizeof(Data128)); }
  //! Add YMM data to the instruction stream.
  inline Error dymm(const Data256& x) { return static_cast<This*>(this)->embed(&x, sizeof(Data256)); }

  //! Add data in a given structure instance to the instruction stream.
  template<typename T>
  inline Error dstruct(const T& x) { return static_cast<This*>(this)->embed(&x, uint32_t(sizeof(T))); }

  // --------------------------------------------------------------------------
  // [Options]
  // --------------------------------------------------------------------------

protected:
  inline This& _addInstOptions(uint32_t options) noexcept {
    static_cast<This*>(this)->addInstOptions(options);
    return *static_cast<This*>(this);
  }

public:
  //! Force short form of jmp/jcc instruction.
  inline This& short_() noexcept { return _addInstOptions(Inst::kOptionShortForm); }
  //! Force long form of jmp/jcc instruction.
  inline This& long_() noexcept { return _addInstOptions(Inst::kOptionLongForm); }

  //! Condition is likely to be taken (has only benefit on P4).
  inline This& taken() noexcept { return _addInstOptions(Inst::kOptionTaken); }
  //! Condition is unlikely to be taken (has only benefit on P4).
  inline This& notTaken() noexcept { return _addInstOptions(Inst::kOptionNotTaken); }

  //! Use LOCK prefix.
  inline This& lock() noexcept { return _addInstOptions(Inst::kOptionLock); }

  //! Use REP/REPZ prefix.
  inline This& rep(const Gp& zcx) noexcept {
    static_cast<This*>(this)->_extraReg.init(zcx);
    return _addInstOptions(Inst::kOptionRep);
  }
  //! Use REP/REPE prefix.
  inline This& repe(const Gp& zcx) noexcept { return rep(zcx); }
  //! Use REP/REPE prefix.
  inline This& repz(const Gp& zcx) noexcept { return rep(zcx); }

  //! Use REPNE prefix.
  inline This& repne(const Gp& zcx) noexcept {
    static_cast<This*>(this)->_extraReg.init(zcx);
    return _addInstOptions(Inst::kOptionRepne);
  }
  //! Use REPNE prefix.
  inline This& repnz(const Gp& zcx) noexcept { return repne(zcx); }

  //! Prefer MOD_MR encoding over MOD_RM (the default) when encoding instruction
  //! that allows both. This option is only applicable to instructions where both
  //! operands are registers.
  inline This& mod_mr() noexcept { return _addInstOptions(Inst::kOptionModMR); }

  //! Force REX prefix to be emitted even when it's not needed (X86_64).
  //!
  //! NOTE: Don't use when using high 8-bit registers as REX prefix makes them
  //! inaccessible and `x86::Assembler` would faild to encode such instruction.
  inline This& rex() noexcept { return _addInstOptions(Inst::kOptionRex);}

  //! Force REX.B prefix (X64) [It exists for special purposes only].
  inline This& rex_b() noexcept { return _addInstOptions(Inst::kOptionOpCodeB); }
  //! Force REX.X prefix (X64) [It exists for special purposes only].
  inline This& rex_x() noexcept { return _addInstOptions(Inst::kOptionOpCodeX); }
  //! Force REX.R prefix (X64) [It exists for special purposes only].
  inline This& rex_r() noexcept { return _addInstOptions(Inst::kOptionOpCodeR); }
  //! Force REX.W prefix (X64) [It exists for special purposes only].
  inline This& rex_w() noexcept { return _addInstOptions(Inst::kOptionOpCodeW); }

  //! Force 3-byte VEX prefix (AVX+).
  inline This& vex3() noexcept { return _addInstOptions(Inst::kOptionVex3); }
  //! Force 4-byte EVEX prefix (AVX512+).
  inline This& evex() noexcept { return _addInstOptions(Inst::kOptionEvex); }

  //! Use zeroing instead of merging (AVX512+).
  inline This& z() noexcept { return _addInstOptions(Inst::kOptionZMask); }

  //! Suppress all exceptions (AVX512+).
  inline This& sae() noexcept { return _addInstOptions(Inst::kOptionSAE); }
  //! Static rounding mode {rn} (round-to-nearest even) and {sae} (AVX512+).
  inline This& rn_sae() noexcept { return _addInstOptions(Inst::kOptionER | Inst::kOptionRN_SAE); }
  //! Static rounding mode {rd} (round-down, toward -inf) and {sae} (AVX512+).
  inline This& rd_sae() noexcept { return _addInstOptions(Inst::kOptionER | Inst::kOptionRD_SAE); }
  //! Static rounding mode {ru} (round-up, toward +inf) and {sae} (AVX512+).
  inline This& ru_sae() noexcept { return _addInstOptions(Inst::kOptionER | Inst::kOptionRU_SAE); }
  //! Static rounding mode {rz} (round-toward-zero, truncate) and {sae} (AVX512+).
  inline This& rz_sae() noexcept { return _addInstOptions(Inst::kOptionER | Inst::kOptionRZ_SAE); }

  // --------------------------------------------------------------------------
  // [General Purpose and Non-SIMD Instructions]
  // --------------------------------------------------------------------------

  ASMJIT_INST_2x(adc, Adc, Gp, Gp)                                     // ANY
  ASMJIT_INST_2x(adc, Adc, Gp, Mem)                                    // ANY
  ASMJIT_INST_2i(adc, Adc, Gp, Imm)                                    // ANY
  ASMJIT_INST_2x(adc, Adc, Mem, Gp)                                    // ANY
  ASMJIT_INST_2i(adc, Adc, Mem, Imm)                                   // ANY
  ASMJIT_INST_2x(adcx, Adcx, Gp, Gp)                                   // ADX
  ASMJIT_INST_2x(adcx, Adcx, Gp, Mem)                                  // ADX
  ASMJIT_INST_2x(add, Add, Gp, Gp)                                     // ANY
  ASMJIT_INST_2x(add, Add, Gp, Mem)                                    // ANY
  ASMJIT_INST_2i(add, Add, Gp, Imm)                                    // ANY
  ASMJIT_INST_2x(add, Add, Mem, Gp)                                    // ANY
  ASMJIT_INST_2i(add, Add, Mem, Imm)                                   // ANY
  ASMJIT_INST_2x(adox, Adox, Gp, Gp)                                   // ADX
  ASMJIT_INST_2x(adox, Adox, Gp, Mem)                                  // ADX
  ASMJIT_INST_2x(and_, And, Gp, Gp)                                    // ANY
  ASMJIT_INST_2x(and_, And, Gp, Mem)                                   // ANY
  ASMJIT_INST_2i(and_, And, Gp, Imm)                                   // ANY
  ASMJIT_INST_2x(and_, And, Mem, Gp)                                   // ANY
  ASMJIT_INST_2i(and_, And, Mem, Imm)                                  // ANY
  ASMJIT_INST_3x(andn, Andn, Gp, Gp, Gp)                               // BMI
  ASMJIT_INST_3x(andn, Andn, Gp, Gp, Mem)                              // BMI
  ASMJIT_INST_2x(arpl, Arpl, Gp, Gp)                                   // X86
  ASMJIT_INST_2x(arpl, Arpl, Mem, Gp)                                  // X86
  ASMJIT_INST_3x(bextr, Bextr, Gp, Gp, Gp)                             // BMI
  ASMJIT_INST_3x(bextr, Bextr, Gp, Mem, Gp)                            // BMI
  ASMJIT_INST_2x(blcfill, Blcfill, Gp, Gp)                             // TBM
  ASMJIT_INST_2x(blcfill, Blcfill, Gp, Mem)                            // TBM
  ASMJIT_INST_2x(blci, Blci, Gp, Gp)                                   // TBM
  ASMJIT_INST_2x(blci, Blci, Gp, Mem)                                  // TBM
  ASMJIT_INST_2x(blcic, Blcic, Gp, Gp)                                 // TBM
  ASMJIT_INST_2x(blcic, Blcic, Gp, Mem)                                // TBM
  ASMJIT_INST_2x(blcmsk, Blcmsk, Gp, Gp)                               // TBM
  ASMJIT_INST_2x(blcmsk, Blcmsk, Gp, Mem)                              // TBM
  ASMJIT_INST_2x(blcs, Blcs, Gp, Gp)                                   // TBM
  ASMJIT_INST_2x(blcs, Blcs, Gp, Mem)                                  // TBM
  ASMJIT_INST_2x(blsfill, Blsfill, Gp, Gp)                             // TBM
  ASMJIT_INST_2x(blsfill, Blsfill, Gp, Mem)                            // TBM
  ASMJIT_INST_2x(blsi, Blsi, Gp, Gp)                                   // BMI
  ASMJIT_INST_2x(blsi, Blsi, Gp, Mem)                                  // BMI
  ASMJIT_INST_2x(blsic, Blsic, Gp, Gp)                                 // TBM
  ASMJIT_INST_2x(blsic, Blsic, Gp, Mem)                                // TBM
  ASMJIT_INST_2x(blsmsk, Blsmsk, Gp, Gp)                               // BMI
  ASMJIT_INST_2x(blsmsk, Blsmsk, Gp, Mem)                              // BMI
  ASMJIT_INST_2x(blsr, Blsr, Gp, Gp)                                   // BMI
  ASMJIT_INST_2x(blsr, Blsr, Gp, Mem)                                  // BMI
  ASMJIT_INST_2x(bndcl, Bndcl, Bnd, Gp)                                // MPX
  ASMJIT_INST_2x(bndcl, Bndcl, Bnd, Mem)                               // MPX
  ASMJIT_INST_2x(bndcn, Bndcn, Bnd, Gp)                                // MPX
  ASMJIT_INST_2x(bndcn, Bndcn, Bnd, Mem)                               // MPX
  ASMJIT_INST_2x(bndcu, Bndcu, Bnd, Gp)                                // MPX
  ASMJIT_INST_2x(bndcu, Bndcu, Bnd, Mem)                               // MPX
  ASMJIT_INST_2x(bndldx, Bndldx, Bnd, Mem)                             // MPX
  ASMJIT_INST_2x(bndmk, Bndmk, Bnd, Mem)                               // MPX
  ASMJIT_INST_2x(bndmov, Bndmov, Bnd, Bnd)                             // MPX
  ASMJIT_INST_2x(bndmov, Bndmov, Bnd, Mem)                             // MPX
  ASMJIT_INST_2x(bndmov, Bndmov, Mem, Bnd)                             // MPX
  ASMJIT_INST_2x(bndstx, Bndstx, Mem, Bnd)                             // MPX
  ASMJIT_INST_2x(bound, Bound, Gp, Mem)                                // X86
  ASMJIT_INST_2x(bsf, Bsf, Gp, Gp)                                     // ANY
  ASMJIT_INST_2x(bsf, Bsf, Gp, Mem)                                    // ANY
  ASMJIT_INST_2x(bsr, Bsr, Gp, Gp)                                     // ANY
  ASMJIT_INST_2x(bsr, Bsr, Gp, Mem)                                    // ANY
  ASMJIT_INST_1x(bswap, Bswap, Gp)                                     // ANY
  ASMJIT_INST_2x(bt, Bt, Gp, Gp)                                       // ANY
  ASMJIT_INST_2i(bt, Bt, Gp, Imm)                                      // ANY
  ASMJIT_INST_2x(bt, Bt, Mem, Gp)                                      // ANY
  ASMJIT_INST_2i(bt, Bt, Mem, Imm)                                     // ANY
  ASMJIT_INST_2x(btc, Btc, Gp, Gp)                                     // ANY
  ASMJIT_INST_2i(btc, Btc, Gp, Imm)                                    // ANY
  ASMJIT_INST_2x(btc, Btc, Mem, Gp)                                    // ANY
  ASMJIT_INST_2i(btc, Btc, Mem, Imm)                                   // ANY
  ASMJIT_INST_2x(btr, Btr, Gp, Gp)                                     // ANY
  ASMJIT_INST_2i(btr, Btr, Gp, Imm)                                    // ANY
  ASMJIT_INST_2x(btr, Btr, Mem, Gp)                                    // ANY
  ASMJIT_INST_2i(btr, Btr, Mem, Imm)                                   // ANY
  ASMJIT_INST_2x(bts, Bts, Gp, Gp)                                     // ANY
  ASMJIT_INST_2i(bts, Bts, Gp, Imm)                                    // ANY
  ASMJIT_INST_2x(bts, Bts, Mem, Gp)                                    // ANY
  ASMJIT_INST_2i(bts, Bts, Mem, Imm)                                   // ANY
  ASMJIT_INST_3x(bzhi, Bzhi, Gp, Gp, Gp)                               // BMI2
  ASMJIT_INST_3x(bzhi, Bzhi, Gp, Mem, Gp)                              // BMI2
  ASMJIT_INST_1x(cbw, Cbw, AX)                                         // ANY       [EXPLICIT] AX      <- Sign Extend AL
  ASMJIT_INST_2x(cdq, Cdq, EDX, EAX)                                   // ANY       [EXPLICIT] EDX:EAX <- Sign Extend EAX
  ASMJIT_INST_1x(cdqe, Cdqe, EAX)                                      // X64       [EXPLICIT] RAX     <- Sign Extend EAX
  ASMJIT_INST_2x(cqo, Cqo, RDX, RAX)                                   // X64       [EXPLICIT] RDX:RAX <- Sign Extend RAX
  ASMJIT_INST_2x(cwd, Cwd, DX, AX)                                     // ANY       [EXPLICIT] DX:AX   <- Sign Extend AX
  ASMJIT_INST_1x(cwde, Cwde, EAX)                                      // ANY       [EXPLICIT] EAX     <- Sign Extend AX
  ASMJIT_INST_1x(call, Call, Gp)                                       // ANY
  ASMJIT_INST_1x(call, Call, Mem)                                      // ANY
  ASMJIT_INST_1x(call, Call, Label)                                    // ANY
  ASMJIT_INST_1i(call, Call, Imm)                                      // ANY
  ASMJIT_INST_0x(clac, Clac)                                           // SMAP
  ASMJIT_INST_0x(clc, Clc)                                             // ANY
  ASMJIT_INST_0x(cld, Cld)                                             // ANY
  ASMJIT_INST_1x(clflush, Clflush, Mem)                                // CLFLUSH
  ASMJIT_INST_1x(clflushopt, Clflushopt, Mem)                          // CLFLUSH_OPT
  ASMJIT_INST_0x(cli, Cli)                                             // ANY
  ASMJIT_INST_0x(clts, Clts)                                           // ANY
  ASMJIT_INST_1x(clwb, Clwb, Mem)                                      // CLWB
  ASMJIT_INST_1x(clzero, Clzero, DS_ZAX)                               // CLZERO    [EXPLICIT]
  ASMJIT_INST_0x(cmc, Cmc)                                             // ANY
  ASMJIT_INST_2c(cmov, Cmov, Inst::cmovccFromCond, Gp, Gp)             // CMOV
  ASMJIT_INST_2c(cmov, Cmov, Inst::cmovccFromCond, Gp, Mem)            // CMOV
  ASMJIT_INST_2x(cmp, Cmp, Gp, Gp)                                     // ANY
  ASMJIT_INST_2x(cmp, Cmp, Gp, Mem)                                    // ANY
  ASMJIT_INST_2i(cmp, Cmp, Gp, Imm)                                    // ANY
  ASMJIT_INST_2x(cmp, Cmp, Mem, Gp)                                    // ANY
  ASMJIT_INST_2i(cmp, Cmp, Mem, Imm)                                   // ANY
  ASMJIT_INST_2x(cmps, Cmps, DS_ZSI, ES_ZDI)                           // ANY       [EXPLICIT]
  ASMJIT_INST_3x(cmpxchg, Cmpxchg, Gp, Gp, ZAX)                        // I486      [EXPLICIT]
  ASMJIT_INST_3x(cmpxchg, Cmpxchg, Mem, Gp, ZAX)                       // I486      [EXPLICIT]
  ASMJIT_INST_5x(cmpxchg16b, Cmpxchg16b, Mem, RDX, RAX, RCX, RBX);     // CMPXCHG16B[EXPLICIT] m == EDX:EAX ? m <- ECX:EBX
  ASMJIT_INST_5x(cmpxchg8b, Cmpxchg8b, Mem, EDX, EAX, ECX, EBX);       // CMPXCHG8B [EXPLICIT] m == RDX:RAX ? m <- RCX:RBX
  ASMJIT_INST_4x(cpuid, Cpuid, EAX, EBX, ECX, EDX)                     // I486      [EXPLICIT] EAX:EBX:ECX:EDX  <- CPUID[EAX:ECX]
  ASMJIT_INST_2x(crc32, Crc32, Gp, Gp)                                 // SSE4_2
  ASMJIT_INST_2x(crc32, Crc32, Gp, Mem)                                // SSE4_2
  ASMJIT_INST_1x(daa, Daa, Gp)                                         // X86       [EXPLICIT]
  ASMJIT_INST_1x(das, Das, Gp)                                         // X86       [EXPLICIT]
  ASMJIT_INST_1x(dec, Dec, Gp)                                         // ANY
  ASMJIT_INST_1x(dec, Dec, Mem)                                        // ANY
  ASMJIT_INST_2x(div, Div, Gp, Gp)                                     // ANY       [EXPLICIT]  AH[Rem]: AL[Quot] <- AX / r8
  ASMJIT_INST_2x(div, Div, Gp, Mem)                                    // ANY       [EXPLICIT]  AH[Rem]: AL[Quot] <- AX / m8
  ASMJIT_INST_3x(div, Div, Gp, Gp, Gp)                                 // ANY       [EXPLICIT] xDX[Rem]:xAX[Quot] <- xDX:xAX / r16|r32|r64
  ASMJIT_INST_3x(div, Div, Gp, Gp, Mem)                                // ANY       [EXPLICIT] xDX[Rem]:xAX[Quot] <- xDX:xAX / m16|m32|m64
  ASMJIT_INST_0x(emms, Emms)                                           // MMX
  ASMJIT_INST_2x(enter, Enter, Imm, Imm)                               // ANY
  ASMJIT_INST_1x(fxrstor, Fxrstor, Mem)                                // FXSR
  ASMJIT_INST_1x(fxrstor64, Fxrstor64, Mem)                            // FXSR
  ASMJIT_INST_1x(fxsave, Fxsave, Mem)                                  // FXSR
  ASMJIT_INST_1x(fxsave64, Fxsave64, Mem)                              // FXSR
  ASMJIT_INST_0x(hlt, Hlt)                                             // ANY
  ASMJIT_INST_2x(idiv, Idiv, Gp, Gp)                                   // ANY       [EXPLICIT]  AH[Rem]: AL[Quot] <- AX / r8
  ASMJIT_INST_2x(idiv, Idiv, Gp, Mem)                                  // ANY       [EXPLICIT]  AH[Rem]: AL[Quot] <- AX / m8
  ASMJIT_INST_3x(idiv, Idiv, Gp, Gp, Gp)                               // ANY       [EXPLICIT] xDX[Rem]:xAX[Quot] <- xDX:xAX / r16|r32|r64
  ASMJIT_INST_3x(idiv, Idiv, Gp, Gp, Mem)                              // ANY       [EXPLICIT] xDX[Rem]:xAX[Quot] <- xDX:xAX / m16|m32|m64
  ASMJIT_INST_2x(imul, Imul, Gp, Gp)                                   // ANY       [EXPLICIT] AX <- AL * r8 | ra <- ra * rb
  ASMJIT_INST_2x(imul, Imul, Gp, Mem)                                  // ANY       [EXPLICIT] AX <- AL * m8 | ra <- ra * m16|m32|m64
  ASMJIT_INST_2i(imul, Imul, Gp, Imm)                                  // ANY
  ASMJIT_INST_3i(imul, Imul, Gp, Gp, Imm)                              // ANY
  ASMJIT_INST_3i(imul, Imul, Gp, Mem, Imm)                             // ANY
  ASMJIT_INST_3x(imul, Imul, Gp, Gp, Gp)                               // ANY       [EXPLICIT] xDX:xAX <- xAX * r16|r32|r64
  ASMJIT_INST_3x(imul, Imul, Gp, Gp, Mem)                              // ANY       [EXPLICIT] xDX:xAX <- xAX * m16|m32|m64
  ASMJIT_INST_2i(in, In, ZAX, Imm)                                     // ANY
  ASMJIT_INST_2x(in, In, ZAX, DX)                                      // ANY
  ASMJIT_INST_1x(inc, Inc, Gp)                                         // ANY
  ASMJIT_INST_1x(inc, Inc, Mem)                                        // ANY
  ASMJIT_INST_2x(ins, Ins, ES_ZDI, DX)                                 // ANY
  ASMJIT_INST_1i(int_, Int, Imm)                                       // ANY
  ASMJIT_INST_0x(int3, Int3)                                           // ANY
  ASMJIT_INST_0x(into, Into)                                           // ANY
  ASMJIT_INST_0x(invd, Invd)                                           // ANY
  ASMJIT_INST_1x(invlpg, Invlpg, Mem)                                  // ANY
  ASMJIT_INST_2x(invpcid, Invpcid, Gp, Mem)                            // ANY
  ASMJIT_INST_1c(j, J, Inst::jccFromCond, Label)                       // ANY
  ASMJIT_INST_1c(j, J, Inst::jccFromCond, Imm)                         // ANY
  ASMJIT_INST_1c(j, J, Inst::jccFromCond, uint64_t)                    // ANY
  ASMJIT_INST_2x(jecxz, Jecxz, Gp, Label)                              // ANY       [EXPLICIT] Short jump if CX/ECX/RCX is zero.
  ASMJIT_INST_2x(jecxz, Jecxz, Gp, Imm)                                // ANY       [EXPLICIT] Short jump if CX/ECX/RCX is zero.
  ASMJIT_INST_2x(jecxz, Jecxz, Gp, uint64_t)                           // ANY       [EXPLICIT] Short jump if CX/ECX/RCX is zero.
  ASMJIT_INST_1x(jmp, Jmp, Gp)                                         // ANY
  ASMJIT_INST_1x(jmp, Jmp, Mem)                                        // ANY
  ASMJIT_INST_1x(jmp, Jmp, Label)                                      // ANY
  ASMJIT_INST_1x(jmp, Jmp, Imm)                                        // ANY
  ASMJIT_INST_1x(jmp, Jmp, uint64_t)                                   // ANY
  ASMJIT_INST_1x(lahf, Lahf, AH)                                       // LAHFSAHF  [EXPLICIT] AH <- EFL
  ASMJIT_INST_2x(lar, Lar, Gp, Gp)                                     // ANY
  ASMJIT_INST_2x(lar, Lar, Gp, Mem)                                    // ANY
  ASMJIT_INST_1x(ldmxcsr, Ldmxcsr, Mem)                                // SSE
  ASMJIT_INST_2x(lds, Lds, Gp, Mem)                                    // X86
  ASMJIT_INST_2x(lea, Lea, Gp, Mem)                                    // ANY
  ASMJIT_INST_0x(leave, Leave)                                         // ANY
  ASMJIT_INST_2x(les, Les, Gp, Mem)                                    // X86
  ASMJIT_INST_0x(lfence, Lfence)                                       // SSE2
  ASMJIT_INST_2x(lfs, Lfs, Gp, Mem)                                    // ANY
  ASMJIT_INST_1x(lgdt, Lgdt, Mem)                                      // ANY
  ASMJIT_INST_2x(lgs, Lgs, Gp, Mem)                                    // ANY
  ASMJIT_INST_1x(lidt, Lidt, Mem)                                      // ANY
  ASMJIT_INST_1x(lldt, Lldt, Gp)                                       // ANY
  ASMJIT_INST_1x(lldt, Lldt, Mem)                                      // ANY
  ASMJIT_INST_1x(lmsw, Lmsw, Gp)                                       // ANY
  ASMJIT_INST_1x(lmsw, Lmsw, Mem)                                      // ANY
  ASMJIT_INST_2x(lods, Lods, ZAX, DS_ZSI)                              // ANY       [EXPLICIT]
  ASMJIT_INST_2x(loop, Loop, ZCX, Label)                               // ANY       [EXPLICIT] Decrement xCX; short jump if xCX != 0.
  ASMJIT_INST_2x(loop, Loop, ZCX, Imm)                                 // ANY       [EXPLICIT] Decrement xCX; short jump if xCX != 0.
  ASMJIT_INST_2x(loop, Loop, ZCX, uint64_t)                            // ANY       [EXPLICIT] Decrement xCX; short jump if xCX != 0.
  ASMJIT_INST_2x(loope, Loope, ZCX, Label)                             // ANY       [EXPLICIT] Decrement xCX; short jump if xCX != 0 && ZF == 1.
  ASMJIT_INST_2x(loope, Loope, ZCX, Imm)                               // ANY       [EXPLICIT] Decrement xCX; short jump if xCX != 0 && ZF == 1.
  ASMJIT_INST_2x(loope, Loope, ZCX, uint64_t)                          // ANY       [EXPLICIT] Decrement xCX; short jump if xCX != 0 && ZF == 1.
  ASMJIT_INST_2x(loopne, Loopne, ZCX, Label)                           // ANY       [EXPLICIT] Decrement xCX; short jump if xCX != 0 && ZF == 0.
  ASMJIT_INST_2x(loopne, Loopne, ZCX, Imm)                             // ANY       [EXPLICIT] Decrement xCX; short jump if xCX != 0 && ZF == 0.
  ASMJIT_INST_2x(loopne, Loopne, ZCX, uint64_t)                        // ANY       [EXPLICIT] Decrement xCX; short jump if xCX != 0 && ZF == 0.
  ASMJIT_INST_2x(lsl, Lsl, Gp, Gp)                                     // ANY
  ASMJIT_INST_2x(lsl, Lsl, Gp, Mem)                                    // ANY
  ASMJIT_INST_2x(lss, Lss, Gp, Mem)                                    // ANY
  ASMJIT_INST_1x(ltr, Ltr, Gp)                                         // ANY
  ASMJIT_INST_1x(ltr, Ltr, Mem)                                        // ANY
  ASMJIT_INST_2x(lzcnt, Lzcnt, Gp, Gp)                                 // LZCNT
  ASMJIT_INST_2x(lzcnt, Lzcnt, Gp, Mem)                                // LZCNT
  ASMJIT_INST_0x(mfence, Mfence)                                       // SSE2
  ASMJIT_INST_2x(mov, Mov, Gp, Gp)                                     // ANY
  ASMJIT_INST_2x(mov, Mov, Gp, Mem)                                    // ANY
  ASMJIT_INST_2i(mov, Mov, Gp, Imm)                                    // ANY
  ASMJIT_INST_2x(mov, Mov, Mem, Gp)                                    // ANY
  ASMJIT_INST_2i(mov, Mov, Mem, Imm)                                   // ANY
  ASMJIT_INST_2x(mov, Mov, Gp, CReg)                                   // ANY
  ASMJIT_INST_2x(mov, Mov, CReg, Gp)                                   // ANY
  ASMJIT_INST_2x(mov, Mov, Gp, DReg)                                   // ANY
  ASMJIT_INST_2x(mov, Mov, DReg, Gp)                                   // ANY
  ASMJIT_INST_2x(mov, Mov, Gp, SReg)                                   // ANY
  ASMJIT_INST_2x(mov, Mov, Mem, SReg)                                  // ANY
  ASMJIT_INST_2x(mov, Mov, SReg, Gp)                                   // ANY
  ASMJIT_INST_2x(mov, Mov, SReg, Mem)                                  // ANY
  ASMJIT_INST_2x(movbe, Movbe, Gp, Mem)                                // MOVBE
  ASMJIT_INST_2x(movbe, Movbe, Mem, Gp)                                // MOVBE
  ASMJIT_INST_2x(movnti, Movnti, Mem, Gp)                              // SSE2
  ASMJIT_INST_2x(movs, Movs, ES_ZDI, DS_ZSI)                           // ANY       [EXPLICIT]
  ASMJIT_INST_2x(movsx, Movsx, Gp, Gp)                                 // ANY
  ASMJIT_INST_2x(movsx, Movsx, Gp, Mem)                                // ANY
  ASMJIT_INST_2x(movsxd, Movsxd, Gp, Gp)                               // X64
  ASMJIT_INST_2x(movsxd, Movsxd, Gp, Mem)                              // X64
  ASMJIT_INST_2x(movzx, Movzx, Gp, Gp)                                 // ANY
  ASMJIT_INST_2x(movzx, Movzx, Gp, Mem)                                // ANY
  ASMJIT_INST_2x(mul, Mul, AX, Gp)                                     // ANY       [EXPLICIT] AX      <-  AL * r8
  ASMJIT_INST_2x(mul, Mul, AX, Mem)                                    // ANY       [EXPLICIT] AX      <-  AL * m8
  ASMJIT_INST_3x(mul, Mul, ZDX, ZAX, Gp)                               // ANY       [EXPLICIT] xDX:xAX <- xAX * r16|r32|r64
  ASMJIT_INST_3x(mul, Mul, ZDX, ZAX, Mem)                              // ANY       [EXPLICIT] xDX:xAX <- xAX * m16|m32|m64
  ASMJIT_INST_4x(mulx, Mulx, Gp, Gp, Gp, ZDX)                          // BMI2      [EXPLICIT]
  ASMJIT_INST_4x(mulx, Mulx, Gp, Gp, Mem, ZDX)                         // BMI2      [EXPLICIT]
  ASMJIT_INST_1x(neg, Neg, Gp)                                         // ANY
  ASMJIT_INST_1x(neg, Neg, Mem)                                        // ANY
  ASMJIT_INST_0x(nop, Nop)                                             // ANY
  ASMJIT_INST_1x(not_, Not, Gp)                                        // ANY
  ASMJIT_INST_1x(not_, Not, Mem)                                       // ANY
  ASMJIT_INST_2x(or_, Or, Gp, Gp)                                      // ANY
  ASMJIT_INST_2x(or_, Or, Gp, Mem)                                     // ANY
  ASMJIT_INST_2i(or_, Or, Gp, Imm)                                     // ANY
  ASMJIT_INST_2x(or_, Or, Mem, Gp)                                     // ANY
  ASMJIT_INST_2i(or_, Or, Mem, Imm)                                    // ANY
  ASMJIT_INST_2x(out, Out, Imm, ZAX)                                   // ANY
  ASMJIT_INST_2i(out, Out, DX, ZAX)                                    // ANY
  ASMJIT_INST_2i(outs, Outs, DX, DS_ZSI)                               // ANY
  ASMJIT_INST_0x(pause, Pause)                                         // SSE2
  ASMJIT_INST_3x(pdep, Pdep, Gp, Gp, Gp)                               // BMI2
  ASMJIT_INST_3x(pdep, Pdep, Gp, Gp, Mem)                              // BMI2
  ASMJIT_INST_3x(pext, Pext, Gp, Gp, Gp)                               // BMI2
  ASMJIT_INST_3x(pext, Pext, Gp, Gp, Mem)                              // BMI2
  ASMJIT_INST_0x(pcommit, Pcommit)                                     // PCOMMIT
  ASMJIT_INST_1x(pop, Pop, Gp)                                         // ANY
  ASMJIT_INST_1x(pop, Pop, Mem)                                        // ANY
  ASMJIT_INST_1x(pop, Pop, SReg);                                      // ANY
  ASMJIT_INST_0x(popa, Popa)                                           // X86
  ASMJIT_INST_0x(popad, Popad)                                         // X86
  ASMJIT_INST_2x(popcnt, Popcnt, Gp, Gp)                               // POPCNT
  ASMJIT_INST_2x(popcnt, Popcnt, Gp, Mem)                              // POPCNT
  ASMJIT_INST_0x(popf, Popf)                                           // ANY
  ASMJIT_INST_0x(popfd, Popfd)                                         // X86
  ASMJIT_INST_0x(popfq, Popfq)                                         // X64
  ASMJIT_INST_1x(prefetch, Prefetch, Mem)                              // 3DNOW
  ASMJIT_INST_1x(prefetchnta, Prefetchnta, Mem)                        // SSE
  ASMJIT_INST_1x(prefetcht0, Prefetcht0, Mem)                          // SSE
  ASMJIT_INST_1x(prefetcht1, Prefetcht1, Mem)                          // SSE
  ASMJIT_INST_1x(prefetcht2, Prefetcht2, Mem)                          // SSE
  ASMJIT_INST_1x(prefetchw, Prefetchw, Mem)                            // PREFETCHW
  ASMJIT_INST_1x(prefetchwt1, Prefetchwt1, Mem)                        // PREFETCHW1
  ASMJIT_INST_1x(push, Push, Gp)                                       // ANY
  ASMJIT_INST_1x(push, Push, Mem)                                      // ANY
  ASMJIT_INST_1x(push, Push, SReg)                                     // ANY
  ASMJIT_INST_1i(push, Push, Imm)                                      // ANY
  ASMJIT_INST_0x(pusha, Pusha)                                         // X86
  ASMJIT_INST_0x(pushad, Pushad)                                       // X86
  ASMJIT_INST_0x(pushf, Pushf)                                         // ANY
  ASMJIT_INST_0x(pushfd, Pushfd)                                       // X86
  ASMJIT_INST_0x(pushfq, Pushfq)                                       // X64
  ASMJIT_INST_2x(rcl, Rcl, Gp, CL)                                     // ANY
  ASMJIT_INST_2x(rcl, Rcl, Mem, CL)                                    // ANY
  ASMJIT_INST_2i(rcl, Rcl, Gp, Imm)                                    // ANY
  ASMJIT_INST_2i(rcl, Rcl, Mem, Imm)                                   // ANY
  ASMJIT_INST_2x(rcr, Rcr, Gp, CL)                                     // ANY
  ASMJIT_INST_2x(rcr, Rcr, Mem, CL)                                    // ANY
  ASMJIT_INST_2i(rcr, Rcr, Gp, Imm)                                    // ANY
  ASMJIT_INST_2i(rcr, Rcr, Mem, Imm)                                   // ANY
  ASMJIT_INST_1x(rdfsbase, Rdfsbase, Gp)                               // FSGSBASE
  ASMJIT_INST_1x(rdgsbase, Rdgsbase, Gp)                               // FSGSBASE
  ASMJIT_INST_1x(rdrand, Rdrand, Gp)                                   // RDRAND
  ASMJIT_INST_1x(rdseed, Rdseed, Gp)                                   // RDSEED
  ASMJIT_INST_3x(rdmsr, Rdmsr, EDX, EAX, ECX)                          // MSR       [EXPLICIT] RDX:EAX     <- MSR[ECX]
  ASMJIT_INST_3x(rdpmc, Rdpmc, EDX, EAX, ECX)                          // ANY       [EXPLICIT] RDX:EAX     <- PMC[ECX]
  ASMJIT_INST_2x(rdtsc, Rdtsc, EDX, EAX)                               // RDTSC     [EXPLICIT] EDX:EAX     <- Counter
  ASMJIT_INST_3x(rdtscp, Rdtscp, EDX, EAX, ECX)                        // RDTSCP    [EXPLICIT] EDX:EAX:EXC <- Counter
  ASMJIT_INST_2x(rol, Rol, Gp, CL)                                     // ANY
  ASMJIT_INST_2x(rol, Rol, Mem, CL)                                    // ANY
  ASMJIT_INST_2i(rol, Rol, Gp, Imm)                                    // ANY
  ASMJIT_INST_2i(rol, Rol, Mem, Imm)                                   // ANY
  ASMJIT_INST_2x(ror, Ror, Gp, CL)                                     // ANY
  ASMJIT_INST_2x(ror, Ror, Mem, CL)                                    // ANY
  ASMJIT_INST_2i(ror, Ror, Gp, Imm)                                    // ANY
  ASMJIT_INST_2i(ror, Ror, Mem, Imm)                                   // ANY
  ASMJIT_INST_3i(rorx, Rorx, Gp, Gp, Imm)                              // BMI2
  ASMJIT_INST_3i(rorx, Rorx, Gp, Mem, Imm)                             // BMI2
  ASMJIT_INST_0x(rsm, Rsm)                                             // X86
  ASMJIT_INST_2x(sbb, Sbb, Gp, Gp)                                     // ANY
  ASMJIT_INST_2x(sbb, Sbb, Gp, Mem)                                    // ANY
  ASMJIT_INST_2i(sbb, Sbb, Gp, Imm)                                    // ANY
  ASMJIT_INST_2x(sbb, Sbb, Mem, Gp)                                    // ANY
  ASMJIT_INST_2i(sbb, Sbb, Mem, Imm)                                   // ANY
  ASMJIT_INST_1x(sahf, Sahf, AH)                                       // LAHFSAHF  [EXPLICIT] EFL <- AH
  ASMJIT_INST_2x(sal, Sal, Gp, CL)                                     // ANY
  ASMJIT_INST_2x(sal, Sal, Mem, CL)                                    // ANY
  ASMJIT_INST_2i(sal, Sal, Gp, Imm)                                    // ANY
  ASMJIT_INST_2i(sal, Sal, Mem, Imm)                                   // ANY
  ASMJIT_INST_2x(sar, Sar, Gp, CL)                                     // ANY
  ASMJIT_INST_2x(sar, Sar, Mem, CL)                                    // ANY
  ASMJIT_INST_2i(sar, Sar, Gp, Imm)                                    // ANY
  ASMJIT_INST_2i(sar, Sar, Mem, Imm)                                   // ANY
  ASMJIT_INST_3x(sarx, Sarx, Gp, Gp, Gp)                               // BMI2
  ASMJIT_INST_3x(sarx, Sarx, Gp, Mem, Gp)                              // BMI2
  ASMJIT_INST_2x(scas, Scas, ZAX, ES_ZDI)                              // ANY       [EXPLICIT]
  ASMJIT_INST_1c(set, Set, Inst::setccFromCond, Gp)                    // ANY
  ASMJIT_INST_1c(set, Set, Inst::setccFromCond, Mem)                   // ANY
  ASMJIT_INST_0x(sfence, Sfence)                                       // SSE
  ASMJIT_INST_1x(sgdt, Sgdt, Mem)                                      // ANY
  ASMJIT_INST_2x(shl, Shl, Gp, CL)                                     // ANY
  ASMJIT_INST_2x(shl, Shl, Mem, CL)                                    // ANY
  ASMJIT_INST_2i(shl, Shl, Gp, Imm)                                    // ANY
  ASMJIT_INST_2i(shl, Shl, Mem, Imm)                                   // ANY
  ASMJIT_INST_3x(shlx, Shlx, Gp, Gp, Gp)                               // BMI2
  ASMJIT_INST_3x(shlx, Shlx, Gp, Mem, Gp)                              // BMI2
  ASMJIT_INST_2x(shr, Shr, Gp, CL)                                     // ANY
  ASMJIT_INST_2x(shr, Shr, Mem, CL)                                    // ANY
  ASMJIT_INST_2i(shr, Shr, Gp, Imm)                                    // ANY
  ASMJIT_INST_2i(shr, Shr, Mem, Imm)                                   // ANY
  ASMJIT_INST_3x(shrx, Shrx, Gp, Gp, Gp)                               // BMI2
  ASMJIT_INST_3x(shrx, Shrx, Gp, Mem, Gp)                              // BMI2
  ASMJIT_INST_3x(shld, Shld, Gp, Gp, CL)                               // ANY
  ASMJIT_INST_3x(shld, Shld, Mem, Gp, CL)                              // ANY
  ASMJIT_INST_3i(shld, Shld, Gp, Gp, Imm)                              // ANY
  ASMJIT_INST_3i(shld, Shld, Mem, Gp, Imm)                             // ANY
  ASMJIT_INST_3x(shrd, Shrd, Gp, Gp, CL)                               // ANY
  ASMJIT_INST_3x(shrd, Shrd, Mem, Gp, CL)                              // ANY
  ASMJIT_INST_3i(shrd, Shrd, Gp, Gp, Imm)                              // ANY
  ASMJIT_INST_3i(shrd, Shrd, Mem, Gp, Imm)                             // ANY
  ASMJIT_INST_1x(sidt, Sidt, Mem)                                      // ANY
  ASMJIT_INST_1x(sldt, Sldt, Gp)                                       // ANY
  ASMJIT_INST_1x(sldt, Sldt, Mem)                                      // ANY
  ASMJIT_INST_1x(smsw, Smsw, Gp)                                       // ANY
  ASMJIT_INST_1x(smsw, Smsw, Mem)                                      // ANY
  ASMJIT_INST_0x(stac, Stac)                                           // SMAP
  ASMJIT_INST_0x(stc, Stc)                                             // ANY
  ASMJIT_INST_0x(std, Std)                                             // ANY
  ASMJIT_INST_0x(sti, Sti)                                             // ANY
  ASMJIT_INST_1x(stmxcsr, Stmxcsr, Mem)                                // SSE
  ASMJIT_INST_2x(stos, Stos, ES_ZDI, ZAX)                              // ANY       [EXPLICIT]
  ASMJIT_INST_1x(str, Str, Gp)                                         // ANY
  ASMJIT_INST_1x(str, Str, Mem)                                        // ANY
  ASMJIT_INST_2x(sub, Sub, Gp, Gp)                                     // ANY
  ASMJIT_INST_2x(sub, Sub, Gp, Mem)                                    // ANY
  ASMJIT_INST_2i(sub, Sub, Gp, Imm)                                    // ANY
  ASMJIT_INST_2x(sub, Sub, Mem, Gp)                                    // ANY
  ASMJIT_INST_2i(sub, Sub, Mem, Imm)                                   // ANY
  ASMJIT_INST_0x(swapgs, Swapgs)                                       // X64
  ASMJIT_INST_2x(t1mskc, T1mskc, Gp, Gp)                               // TBM
  ASMJIT_INST_2x(t1mskc, T1mskc, Gp, Mem)                              // TBM
  ASMJIT_INST_2x(test, Test, Gp, Gp)                                   // ANY
  ASMJIT_INST_2i(test, Test, Gp, Imm)                                  // ANY
  ASMJIT_INST_2x(test, Test, Mem, Gp)                                  // ANY
  ASMJIT_INST_2i(test, Test, Mem, Imm)                                 // ANY
  ASMJIT_INST_2x(tzcnt, Tzcnt, Gp, Gp)                                 // BMI
  ASMJIT_INST_2x(tzcnt, Tzcnt, Gp, Mem)                                // BMI
  ASMJIT_INST_2x(tzmsk, Tzmsk, Gp, Gp)                                 // TBM
  ASMJIT_INST_2x(tzmsk, Tzmsk, Gp, Mem)                                // TBM
  ASMJIT_INST_0x(ud2, Ud2)                                             // ANY
  ASMJIT_INST_1x(verr, Verr, Gp)                                       // ANY
  ASMJIT_INST_1x(verr, Verr, Mem)                                      // ANY
  ASMJIT_INST_1x(verw, Verw, Gp)                                       // ANY
  ASMJIT_INST_1x(verw, Verw, Mem)                                      // ANY
  ASMJIT_INST_1x(wrfsbase, Wrfsbase, Gp)                               // FSGSBASE
  ASMJIT_INST_1x(wrgsbase, Wrgsbase, Gp)                               // FSGSBASE
  ASMJIT_INST_3x(wrmsr, Wrmsr, EDX, EAX, ECX)                          // MSR       [EXPLICIT] RDX:EAX     -> MSR[ECX]
  ASMJIT_INST_0x(xabort, Xabort)                                       // RTM
  ASMJIT_INST_2x(xadd, Xadd, Gp, Gp)                                   // ANY
  ASMJIT_INST_2x(xadd, Xadd, Mem, Gp)                                  // ANY
  ASMJIT_INST_1x(xbegin, Xbegin, Label)                                // RTM
  ASMJIT_INST_1x(xbegin, Xbegin, Imm)                                  // RTM
  ASMJIT_INST_1x(xbegin, Xbegin, uint64_t)                             // RTM
  ASMJIT_INST_2x(xchg, Xchg, Gp, Gp)                                   // ANY
  ASMJIT_INST_2x(xchg, Xchg, Mem, Gp)                                  // ANY
  ASMJIT_INST_2x(xchg, Xchg, Gp, Mem)                                  // ANY
  ASMJIT_INST_0x(xend, Xend)                                           // RTM
  ASMJIT_INST_3x(xgetbv, Xgetbv, EDX, EAX, ECX)                        // XSAVE     [EXPLICIT] EDX:EAX <- XCR[ECX]
  ASMJIT_INST_2x(xor_, Xor, Gp, Gp)                                    // ANY
  ASMJIT_INST_2x(xor_, Xor, Gp, Mem)                                   // ANY
  ASMJIT_INST_2i(xor_, Xor, Gp, Imm)                                   // ANY
  ASMJIT_INST_2x(xor_, Xor, Mem, Gp)                                   // ANY
  ASMJIT_INST_2i(xor_, Xor, Mem, Imm)                                  // ANY
  ASMJIT_INST_3x(xsetbv, Xsetbv, EDX, EAX, ECX)                        // XSAVE     [EXPLICIT] XCR[ECX] <- EDX:EAX
  ASMJIT_INST_0x(xtest, Xtest)                                         // TSX

  // --------------------------------------------------------------------------
  // [FPU Instructions]
  // --------------------------------------------------------------------------

  ASMJIT_INST_0x(f2xm1, F2xm1)                                         // FPU
  ASMJIT_INST_0x(fabs, Fabs)                                           // FPU
  ASMJIT_INST_2x(fadd, Fadd, St, St)                                   // FPU
  ASMJIT_INST_1x(fadd, Fadd, Mem)                                      // FPU
  ASMJIT_INST_1x(faddp, Faddp, St)                                     // FPU
  ASMJIT_INST_0x(faddp, Faddp)                                         // FPU
  ASMJIT_INST_1x(fbld, Fbld, Mem)                                      // FPU
  ASMJIT_INST_1x(fbstp, Fbstp, Mem)                                    // FPU
  ASMJIT_INST_0x(fchs, Fchs)                                           // FPU
  ASMJIT_INST_0x(fclex, Fclex)                                         // FPU
  ASMJIT_INST_1x(fcmovb, Fcmovb, St)                                   // FPU
  ASMJIT_INST_1x(fcmovbe, Fcmovbe, St)                                 // FPU
  ASMJIT_INST_1x(fcmove, Fcmove, St)                                   // FPU
  ASMJIT_INST_1x(fcmovnb, Fcmovnb, St)                                 // FPU
  ASMJIT_INST_1x(fcmovnbe, Fcmovnbe, St)                               // FPU
  ASMJIT_INST_1x(fcmovne, Fcmovne, St)                                 // FPU
  ASMJIT_INST_1x(fcmovnu, Fcmovnu, St)                                 // FPU
  ASMJIT_INST_1x(fcmovu, Fcmovu, St)                                   // FPU
  ASMJIT_INST_1x(fcom, Fcom, St)                                       // FPU
  ASMJIT_INST_0x(fcom, Fcom)                                           // FPU
  ASMJIT_INST_1x(fcom, Fcom, Mem)                                      // FPU
  ASMJIT_INST_1x(fcomp, Fcomp, St)                                     // FPU
  ASMJIT_INST_0x(fcomp, Fcomp)                                         // FPU
  ASMJIT_INST_1x(fcomp, Fcomp, Mem)                                    // FPU
  ASMJIT_INST_0x(fcompp, Fcompp)                                       // FPU
  ASMJIT_INST_1x(fcomi, Fcomi, St)                                     // FPU
  ASMJIT_INST_1x(fcomip, Fcomip, St)                                   // FPU
  ASMJIT_INST_0x(fcos, Fcos)                                           // FPU
  ASMJIT_INST_0x(fdecstp, Fdecstp)                                     // FPU
  ASMJIT_INST_2x(fdiv, Fdiv, St, St)                                   // FPU
  ASMJIT_INST_1x(fdiv, Fdiv, Mem)                                      // FPU
  ASMJIT_INST_1x(fdivp, Fdivp, St)                                     // FPU
  ASMJIT_INST_0x(fdivp, Fdivp)                                         // FPU
  ASMJIT_INST_2x(fdivr, Fdivr, St, St)                                 // FPU
  ASMJIT_INST_1x(fdivr, Fdivr, Mem)                                    // FPU
  ASMJIT_INST_1x(fdivrp, Fdivrp, St)                                   // FPU
  ASMJIT_INST_0x(fdivrp, Fdivrp)                                       // FPU
  ASMJIT_INST_1x(ffree, Ffree, St)                                     // FPU
  ASMJIT_INST_1x(fiadd, Fiadd, Mem)                                    // FPU
  ASMJIT_INST_1x(ficom, Ficom, Mem)                                    // FPU
  ASMJIT_INST_1x(ficomp, Ficomp, Mem)                                  // FPU
  ASMJIT_INST_1x(fidiv, Fidiv, Mem)                                    // FPU
  ASMJIT_INST_1x(fidivr, Fidivr, Mem)                                  // FPU
  ASMJIT_INST_1x(fild, Fild, Mem)                                      // FPU
  ASMJIT_INST_1x(fimul, Fimul, Mem)                                    // FPU
  ASMJIT_INST_0x(fincstp, Fincstp)                                     // FPU
  ASMJIT_INST_0x(finit, Finit)                                         // FPU
  ASMJIT_INST_1x(fisub, Fisub, Mem)                                    // FPU
  ASMJIT_INST_1x(fisubr, Fisubr, Mem)                                  // FPU
  ASMJIT_INST_0x(fninit, Fninit)                                       // FPU
  ASMJIT_INST_1x(fist, Fist, Mem)                                      // FPU
  ASMJIT_INST_1x(fistp, Fistp, Mem)                                    // FPU
  ASMJIT_INST_1x(fisttp, Fisttp, Mem)                                  // FPU+SSE3
  ASMJIT_INST_1x(fld, Fld, Mem)                                        // FPU
  ASMJIT_INST_1x(fld, Fld, St)                                         // FPU
  ASMJIT_INST_0x(fld1, Fld1)                                           // FPU
  ASMJIT_INST_0x(fldl2t, Fldl2t)                                       // FPU
  ASMJIT_INST_0x(fldl2e, Fldl2e)                                       // FPU
  ASMJIT_INST_0x(fldpi, Fldpi)                                         // FPU
  ASMJIT_INST_0x(fldlg2, Fldlg2)                                       // FPU
  ASMJIT_INST_0x(fldln2, Fldln2)                                       // FPU
  ASMJIT_INST_0x(fldz, Fldz)                                           // FPU
  ASMJIT_INST_1x(fldcw, Fldcw, Mem)                                    // FPU
  ASMJIT_INST_1x(fldenv, Fldenv, Mem)                                  // FPU
  ASMJIT_INST_2x(fmul, Fmul, St, St)                                   // FPU
  ASMJIT_INST_1x(fmul, Fmul, Mem)                                      // FPU
  ASMJIT_INST_1x(fmulp, Fmulp, St)                                     // FPU
  ASMJIT_INST_0x(fmulp, Fmulp)                                         // FPU
  ASMJIT_INST_0x(fnclex, Fnclex)                                       // FPU
  ASMJIT_INST_0x(fnop, Fnop)                                           // FPU
  ASMJIT_INST_1x(fnsave, Fnsave, Mem)                                  // FPU
  ASMJIT_INST_1x(fnstenv, Fnstenv, Mem)                                // FPU
  ASMJIT_INST_1x(fnstcw, Fnstcw, Mem)                                  // FPU
  ASMJIT_INST_0x(fpatan, Fpatan)                                       // FPU
  ASMJIT_INST_0x(fprem, Fprem)                                         // FPU
  ASMJIT_INST_0x(fprem1, Fprem1)                                       // FPU
  ASMJIT_INST_0x(fptan, Fptan)                                         // FPU
  ASMJIT_INST_0x(frndint, Frndint)                                     // FPU
  ASMJIT_INST_1x(frstor, Frstor, Mem)                                  // FPU
  ASMJIT_INST_1x(fsave, Fsave, Mem)                                    // FPU
  ASMJIT_INST_0x(fscale, Fscale)                                       // FPU
  ASMJIT_INST_0x(fsin, Fsin)                                           // FPU
  ASMJIT_INST_0x(fsincos, Fsincos)                                     // FPU
  ASMJIT_INST_0x(fsqrt, Fsqrt)                                         // FPU
  ASMJIT_INST_1x(fst, Fst, Mem)                                        // FPU
  ASMJIT_INST_1x(fst, Fst, St)                                         // FPU
  ASMJIT_INST_1x(fstp, Fstp, Mem)                                      // FPU
  ASMJIT_INST_1x(fstp, Fstp, St)                                       // FPU
  ASMJIT_INST_1x(fstcw, Fstcw, Mem)                                    // FPU
  ASMJIT_INST_1x(fstenv, Fstenv, Mem)                                  // FPU
  ASMJIT_INST_2x(fsub, Fsub, St, St)                                   // FPU
  ASMJIT_INST_1x(fsub, Fsub, Mem)                                      // FPU
  ASMJIT_INST_1x(fsubp, Fsubp, St)                                     // FPU
  ASMJIT_INST_0x(fsubp, Fsubp)                                         // FPU
  ASMJIT_INST_2x(fsubr, Fsubr, St, St)                                 // FPU
  ASMJIT_INST_1x(fsubr, Fsubr, Mem)                                    // FPU
  ASMJIT_INST_1x(fsubrp, Fsubrp, St)                                   // FPU
  ASMJIT_INST_0x(fsubrp, Fsubrp)                                       // FPU
  ASMJIT_INST_0x(ftst, Ftst)                                           // FPU
  ASMJIT_INST_1x(fucom, Fucom, St)                                     // FPU
  ASMJIT_INST_0x(fucom, Fucom)                                         // FPU
  ASMJIT_INST_1x(fucomi, Fucomi, St)                                   // FPU
  ASMJIT_INST_1x(fucomip, Fucomip, St)                                 // FPU
  ASMJIT_INST_1x(fucomp, Fucomp, St)                                   // FPU
  ASMJIT_INST_0x(fucomp, Fucomp)                                       // FPU
  ASMJIT_INST_0x(fucompp, Fucompp)                                     // FPU
  ASMJIT_INST_0x(fwait, Fwait)                                         // FPU
  ASMJIT_INST_0x(fxam, Fxam)                                           // FPU
  ASMJIT_INST_1x(fxch, Fxch, St)                                       // FPU
  ASMJIT_INST_0x(fxtract, Fxtract)                                     // FPU
  ASMJIT_INST_0x(fyl2x, Fyl2x)                                         // FPU
  ASMJIT_INST_0x(fyl2xp1, Fyl2xp1)                                     // FPU
  ASMJIT_INST_1x(fstsw, Fstsw, Gp)                                     // FPU
  ASMJIT_INST_1x(fstsw, Fstsw, Mem)                                    // FPU
  ASMJIT_INST_1x(fnstsw, Fnstsw, Gp)                                   // FPU
  ASMJIT_INST_1x(fnstsw, Fnstsw, Mem)                                  // FPU

  // --------------------------------------------------------------------------
  // [MMX & SSE Instructions]
  // --------------------------------------------------------------------------

  ASMJIT_INST_2x(addpd, Addpd, Xmm, Xmm)                               // SSE2
  ASMJIT_INST_2x(addpd, Addpd, Xmm, Mem)                               // SSE2
  ASMJIT_INST_2x(addps, Addps, Xmm, Xmm)                               // SSE
  ASMJIT_INST_2x(addps, Addps, Xmm, Mem)                               // SSE
  ASMJIT_INST_2x(addsd, Addsd, Xmm, Xmm)                               // SSE2
  ASMJIT_INST_2x(addsd, Addsd, Xmm, Mem)                               // SSE2
  ASMJIT_INST_2x(addss, Addss, Xmm, Xmm)                               // SSE
  ASMJIT_INST_2x(addss, Addss, Xmm, Mem)                               // SSE
  ASMJIT_INST_2x(addsubpd, Addsubpd, Xmm, Xmm)                         // SSE3
  ASMJIT_INST_2x(addsubpd, Addsubpd, Xmm, Mem)                         // SSE3
  ASMJIT_INST_2x(addsubps, Addsubps, Xmm, Xmm)                         // SSE3
  ASMJIT_INST_2x(addsubps, Addsubps, Xmm, Mem)                         // SSE3
  ASMJIT_INST_2x(andnpd, Andnpd, Xmm, Xmm)                             // SSE2
  ASMJIT_INST_2x(andnpd, Andnpd, Xmm, Mem)                             // SSE2
  ASMJIT_INST_2x(andnps, Andnps, Xmm, Xmm)                             // SSE
  ASMJIT_INST_2x(andnps, Andnps, Xmm, Mem)                             // SSE
  ASMJIT_INST_2x(andpd, Andpd, Xmm, Xmm)                               // SSE2
  ASMJIT_INST_2x(andpd, Andpd, Xmm, Mem)                               // SSE2
  ASMJIT_INST_2x(andps, Andps, Xmm, Xmm)                               // SSE
  ASMJIT_INST_2x(andps, Andps, Xmm, Mem)                               // SSE
  ASMJIT_INST_3i(blendpd, Blendpd, Xmm, Xmm, Imm)                      // SSE4_1
  ASMJIT_INST_3i(blendpd, Blendpd, Xmm, Mem, Imm)                      // SSE4_1
  ASMJIT_INST_3i(blendps, Blendps, Xmm, Xmm, Imm)                      // SSE4_1
  ASMJIT_INST_3i(blendps, Blendps, Xmm, Mem, Imm)                      // SSE4_1
  ASMJIT_INST_3x(blendvpd, Blendvpd, Xmm, Xmm, XMM0)                   // SSE4_1 [EXPLICIT]
  ASMJIT_INST_3x(blendvpd, Blendvpd, Xmm, Mem, XMM0)                   // SSE4_1 [EXPLICIT]
  ASMJIT_INST_3x(blendvps, Blendvps, Xmm, Xmm, XMM0)                   // SSE4_1 [EXPLICIT]
  ASMJIT_INST_3x(blendvps, Blendvps, Xmm, Mem, XMM0)                   // SSE4_1 [EXPLICIT]
  ASMJIT_INST_3i(cmppd, Cmppd, Xmm, Xmm, Imm)                          // SSE2
  ASMJIT_INST_3i(cmppd, Cmppd, Xmm, Mem, Imm)                          // SSE2
  ASMJIT_INST_3i(cmpps, Cmpps, Xmm, Xmm, Imm)                          // SSE
  ASMJIT_INST_3i(cmpps, Cmpps, Xmm, Mem, Imm)                          // SSE
  ASMJIT_INST_3i(cmpsd, Cmpsd, Xmm, Xmm, Imm)                          // SSE2
  ASMJIT_INST_3i(cmpsd, Cmpsd, Xmm, Mem, Imm)                          // SSE2
  ASMJIT_INST_3i(cmpss, Cmpss, Xmm, Xmm, Imm)                          // SSE
  ASMJIT_INST_3i(cmpss, Cmpss, Xmm, Mem, Imm)                          // SSE
  ASMJIT_INST_2x(comisd, Comisd, Xmm, Xmm)                             // SSE2
  ASMJIT_INST_2x(comisd, Comisd, Xmm, Mem)                             // SSE2
  ASMJIT_INST_2x(comiss, Comiss, Xmm, Xmm)                             // SSE
  ASMJIT_INST_2x(comiss, Comiss, Xmm, Mem)                             // SSE
  ASMJIT_INST_2x(cvtdq2pd, Cvtdq2pd, Xmm, Xmm)                         // SSE2
  ASMJIT_INST_2x(cvtdq2pd, Cvtdq2pd, Xmm, Mem)                         // SSE2
  ASMJIT_INST_2x(cvtdq2ps, Cvtdq2ps, Xmm, Xmm)                         // SSE2
  ASMJIT_INST_2x(cvtdq2ps, Cvtdq2ps, Xmm, Mem)                         // SSE2
  ASMJIT_INST_2x(cvtpd2dq, Cvtpd2dq, Xmm, Xmm)                         // SSE2
  ASMJIT_INST_2x(cvtpd2dq, Cvtpd2dq, Xmm, Mem)                         // SSE2
  ASMJIT_INST_2x(cvtpd2pi, Cvtpd2pi, Mm, Xmm)                          // SSE2
  ASMJIT_INST_2x(cvtpd2pi, Cvtpd2pi, Mm, Mem)                          // SSE2
  ASMJIT_INST_2x(cvtpd2ps, Cvtpd2ps, Xmm, Xmm)                         // SSE2
  ASMJIT_INST_2x(cvtpd2ps, Cvtpd2ps, Xmm, Mem)                         // SSE2
  ASMJIT_INST_2x(cvtpi2pd, Cvtpi2pd, Xmm, Mm)                          // SSE2
  ASMJIT_INST_2x(cvtpi2pd, Cvtpi2pd, Xmm, Mem)                         // SSE2
  ASMJIT_INST_2x(cvtpi2ps, Cvtpi2ps, Xmm, Mm)                          // SSE
  ASMJIT_INST_2x(cvtpi2ps, Cvtpi2ps, Xmm, Mem)                         // SSE
  ASMJIT_INST_2x(cvtps2dq, Cvtps2dq, Xmm, Xmm)                         // SSE2
  ASMJIT_INST_2x(cvtps2dq, Cvtps2dq, Xmm, Mem)                         // SSE2
  ASMJIT_INST_2x(cvtps2pd, Cvtps2pd, Xmm, Xmm)                         // SSE2
  ASMJIT_INST_2x(cvtps2pd, Cvtps2pd, Xmm, Mem)                         // SSE2
  ASMJIT_INST_2x(cvtps2pi, Cvtps2pi, Mm, Xmm)                          // SSE
  ASMJIT_INST_2x(cvtps2pi, Cvtps2pi, Mm, Mem)                          // SSE
  ASMJIT_INST_2x(cvtsd2si, Cvtsd2si, Gp, Xmm)                          // SSE2
  ASMJIT_INST_2x(cvtsd2si, Cvtsd2si, Gp, Mem)                          // SSE2
  ASMJIT_INST_2x(cvtsd2ss, Cvtsd2ss, Xmm, Xmm)                         // SSE2
  ASMJIT_INST_2x(cvtsd2ss, Cvtsd2ss, Xmm, Mem)                         // SSE2
  ASMJIT_INST_2x(cvtsi2sd, Cvtsi2sd, Xmm, Gp)                          // SSE2
  ASMJIT_INST_2x(cvtsi2sd, Cvtsi2sd, Xmm, Mem)                         // SSE2
  ASMJIT_INST_2x(cvtsi2ss, Cvtsi2ss, Xmm, Gp)                          // SSE
  ASMJIT_INST_2x(cvtsi2ss, Cvtsi2ss, Xmm, Mem)                         // SSE
  ASMJIT_INST_2x(cvtss2sd, Cvtss2sd, Xmm, Xmm)                         // SSE2
  ASMJIT_INST_2x(cvtss2sd, Cvtss2sd, Xmm, Mem)                         // SSE2
  ASMJIT_INST_2x(cvtss2si, Cvtss2si, Gp, Xmm)                          // SSE
  ASMJIT_INST_2x(cvtss2si, Cvtss2si, Gp, Mem)                          // SSE
  ASMJIT_INST_2x(cvttpd2pi, Cvttpd2pi, Mm, Xmm)                        // SSE2
  ASMJIT_INST_2x(cvttpd2pi, Cvttpd2pi, Mm, Mem)                        // SSE2
  ASMJIT_INST_2x(cvttpd2dq, Cvttpd2dq, Xmm, Xmm)                       // SSE2
  ASMJIT_INST_2x(cvttpd2dq, Cvttpd2dq, Xmm, Mem)                       // SSE2
  ASMJIT_INST_2x(cvttps2dq, Cvttps2dq, Xmm, Xmm)                       // SSE2
  ASMJIT_INST_2x(cvttps2dq, Cvttps2dq, Xmm, Mem)                       // SSE2
  ASMJIT_INST_2x(cvttps2pi, Cvttps2pi, Mm, Xmm)                        // SSE
  ASMJIT_INST_2x(cvttps2pi, Cvttps2pi, Mm, Mem)                        // SSE
  ASMJIT_INST_2x(cvttsd2si, Cvttsd2si, Gp, Xmm)                        // SSE2
  ASMJIT_INST_2x(cvttsd2si, Cvttsd2si, Gp, Mem)                        // SSE2
  ASMJIT_INST_2x(cvttss2si, Cvttss2si, Gp, Xmm)                        // SSE
  ASMJIT_INST_2x(cvttss2si, Cvttss2si, Gp, Mem)                        // SSE
  ASMJIT_INST_2x(divpd, Divpd, Xmm, Xmm)                               // SSE2
  ASMJIT_INST_2x(divpd, Divpd, Xmm, Mem)                               // SSE2
  ASMJIT_INST_2x(divps, Divps, Xmm, Xmm)                               // SSE
  ASMJIT_INST_2x(divps, Divps, Xmm, Mem)                               // SSE
  ASMJIT_INST_2x(divsd, Divsd, Xmm, Xmm)                               // SSE2
  ASMJIT_INST_2x(divsd, Divsd, Xmm, Mem)                               // SSE2
  ASMJIT_INST_2x(divss, Divss, Xmm, Xmm)                               // SSE
  ASMJIT_INST_2x(divss, Divss, Xmm, Mem)                               // SSE
  ASMJIT_INST_3i(dppd, Dppd, Xmm, Xmm, Imm)                            // SSE4_1
  ASMJIT_INST_3i(dppd, Dppd, Xmm, Mem, Imm)                            // SSE4_1
  ASMJIT_INST_3i(dpps, Dpps, Xmm, Xmm, Imm)                            // SSE4_1
  ASMJIT_INST_3i(dpps, Dpps, Xmm, Mem, Imm)                            // SSE4_1
  ASMJIT_INST_3i(extractps, Extractps, Gp, Xmm, Imm)                   // SSE4_1
  ASMJIT_INST_3i(extractps, Extractps, Mem, Xmm, Imm)                  // SSE4_1
  ASMJIT_INST_2x(extrq, Extrq, Xmm, Xmm)                               // SSE4A
  ASMJIT_INST_3ii(extrq, Extrq, Xmm, Imm, Imm)                         // SSE4A
  ASMJIT_INST_2x(haddpd, Haddpd, Xmm, Xmm)                             // SSE3
  ASMJIT_INST_2x(haddpd, Haddpd, Xmm, Mem)                             // SSE3
  ASMJIT_INST_2x(haddps, Haddps, Xmm, Xmm)                             // SSE3
  ASMJIT_INST_2x(haddps, Haddps, Xmm, Mem)                             // SSE3
  ASMJIT_INST_2x(hsubpd, Hsubpd, Xmm, Xmm)                             // SSE3
  ASMJIT_INST_2x(hsubpd, Hsubpd, Xmm, Mem)                             // SSE3
  ASMJIT_INST_2x(hsubps, Hsubps, Xmm, Xmm)                             // SSE3
  ASMJIT_INST_2x(hsubps, Hsubps, Xmm, Mem)                             // SSE3
  ASMJIT_INST_3i(insertps, Insertps, Xmm, Xmm, Imm)                    // SSE4_1
  ASMJIT_INST_3i(insertps, Insertps, Xmm, Mem, Imm)                    // SSE4_1
  ASMJIT_INST_2x(insertq, Insertq, Xmm, Xmm)                           // SSE4A
  ASMJIT_INST_4ii(insertq, Insertq, Xmm, Xmm, Imm, Imm)                // SSE4A
  ASMJIT_INST_2x(lddqu, Lddqu, Xmm, Mem)                               // SSE3
  ASMJIT_INST_3x(maskmovq, Maskmovq, Mm, Mm, DS_ZDI)                   // SSE  [EXPLICIT]
  ASMJIT_INST_3x(maskmovdqu, Maskmovdqu, Xmm, Xmm, DS_ZDI)             // SSE2 [EXPLICIT]
  ASMJIT_INST_2x(maxpd, Maxpd, Xmm, Xmm)                               // SSE2
  ASMJIT_INST_2x(maxpd, Maxpd, Xmm, Mem)                               // SSE2
  ASMJIT_INST_2x(maxps, Maxps, Xmm, Xmm)                               // SSE
  ASMJIT_INST_2x(maxps, Maxps, Xmm, Mem)                               // SSE
  ASMJIT_INST_2x(maxsd, Maxsd, Xmm, Xmm)                               // SSE2
  ASMJIT_INST_2x(maxsd, Maxsd, Xmm, Mem)                               // SSE2
  ASMJIT_INST_2x(maxss, Maxss, Xmm, Xmm)                               // SSE
  ASMJIT_INST_2x(maxss, Maxss, Xmm, Mem)                               // SSE
  ASMJIT_INST_2x(minpd, Minpd, Xmm, Xmm)                               // SSE2
  ASMJIT_INST_2x(minpd, Minpd, Xmm, Mem)                               // SSE2
  ASMJIT_INST_2x(minps, Minps, Xmm, Xmm)                               // SSE
  ASMJIT_INST_2x(minps, Minps, Xmm, Mem)                               // SSE
  ASMJIT_INST_2x(minsd, Minsd, Xmm, Xmm)                               // SSE2
  ASMJIT_INST_2x(minsd, Minsd, Xmm, Mem)                               // SSE2
  ASMJIT_INST_2x(minss, Minss, Xmm, Xmm)                               // SSE
  ASMJIT_INST_2x(minss, Minss, Xmm, Mem)                               // SSE
  ASMJIT_INST_2x(movapd, Movapd, Xmm, Xmm)                             // SSE2
  ASMJIT_INST_2x(movapd, Movapd, Xmm, Mem)                             // SSE2
  ASMJIT_INST_2x(movapd, Movapd, Mem, Xmm)                             // SSE2
  ASMJIT_INST_2x(movaps, Movaps, Xmm, Xmm)                             // SSE
  ASMJIT_INST_2x(movaps, Movaps, Xmm, Mem)                             // SSE
  ASMJIT_INST_2x(movaps, Movaps, Mem, Xmm)                             // SSE
  ASMJIT_INST_2x(movd, Movd, Mem, Mm)                                  // MMX
  ASMJIT_INST_2x(movd, Movd, Mem, Xmm)                                 // SSE
  ASMJIT_INST_2x(movd, Movd, Gp, Mm)                                   // MMX
  ASMJIT_INST_2x(movd, Movd, Gp, Xmm)                                  // SSE
  ASMJIT_INST_2x(movd, Movd, Mm, Mem)                                  // MMX
  ASMJIT_INST_2x(movd, Movd, Xmm, Mem)                                 // SSE
  ASMJIT_INST_2x(movd, Movd, Mm, Gp)                                   // MMX
  ASMJIT_INST_2x(movd, Movd, Xmm, Gp)                                  // SSE
  ASMJIT_INST_2x(movddup, Movddup, Xmm, Xmm)                           // SSE3
  ASMJIT_INST_2x(movddup, Movddup, Xmm, Mem)                           // SSE3
  ASMJIT_INST_2x(movdq2q, Movdq2q, Mm, Xmm)                            // SSE2
  ASMJIT_INST_2x(movdqa, Movdqa, Xmm, Xmm)                             // SSE2
  ASMJIT_INST_2x(movdqa, Movdqa, Xmm, Mem)                             // SSE2
  ASMJIT_INST_2x(movdqa, Movdqa, Mem, Xmm)                             // SSE2
  ASMJIT_INST_2x(movdqu, Movdqu, Xmm, Xmm)                             // SSE2
  ASMJIT_INST_2x(movdqu, Movdqu, Xmm, Mem)                             // SSE2
  ASMJIT_INST_2x(movdqu, Movdqu, Mem, Xmm)                             // SSE2
  ASMJIT_INST_2x(movhlps, Movhlps, Xmm, Xmm)                           // SSE
  ASMJIT_INST_2x(movhpd, Movhpd, Xmm, Mem)                             // SSE2
  ASMJIT_INST_2x(movhpd, Movhpd, Mem, Xmm)                             // SSE2
  ASMJIT_INST_2x(movhps, Movhps, Xmm, Mem)                             // SSE
  ASMJIT_INST_2x(movhps, Movhps, Mem, Xmm)                             // SSE
  ASMJIT_INST_2x(movlhps, Movlhps, Xmm, Xmm)                           // SSE
  ASMJIT_INST_2x(movlpd, Movlpd, Xmm, Mem)                             // SSE2
  ASMJIT_INST_2x(movlpd, Movlpd, Mem, Xmm)                             // SSE2
  ASMJIT_INST_2x(movlps, Movlps, Xmm, Mem)                             // SSE
  ASMJIT_INST_2x(movlps, Movlps, Mem, Xmm)                             // SSE
  ASMJIT_INST_2x(movmskps, Movmskps, Gp, Xmm)                          // SSE2
  ASMJIT_INST_2x(movmskpd, Movmskpd, Gp, Xmm)                          // SSE2
  ASMJIT_INST_2x(movntdq, Movntdq, Mem, Xmm)                           // SSE2
  ASMJIT_INST_2x(movntdqa, Movntdqa, Xmm, Mem)                         // SSE4_1
  ASMJIT_INST_2x(movntpd, Movntpd, Mem, Xmm)                           // SSE2
  ASMJIT_INST_2x(movntps, Movntps, Mem, Xmm)                           // SSE
  ASMJIT_INST_2x(movntsd, Movntsd, Mem, Xmm)                           // SSE4A
  ASMJIT_INST_2x(movntss, Movntss, Mem, Xmm)                           // SSE4A
  ASMJIT_INST_2x(movntq, Movntq, Mem, Mm)                              // SSE
  ASMJIT_INST_2x(movq, Movq, Mm, Mm)                                   // MMX
  ASMJIT_INST_2x(movq, Movq, Xmm, Xmm)                                 // SSE
  ASMJIT_INST_2x(movq, Movq, Mem, Mm)                                  // MMX
  ASMJIT_INST_2x(movq, Movq, Mem, Xmm)                                 // SSE
  ASMJIT_INST_2x(movq, Movq, Mm, Mem)                                  // MMX
  ASMJIT_INST_2x(movq, Movq, Xmm, Mem)                                 // SSE
  ASMJIT_INST_2x(movq, Movq, Gp, Mm)                                   // MMX
  ASMJIT_INST_2x(movq, Movq, Gp, Xmm)                                  // SSE+X64.
  ASMJIT_INST_2x(movq, Movq, Mm, Gp)                                   // MMX
  ASMJIT_INST_2x(movq, Movq, Xmm, Gp)                                  // SSE+X64.
  ASMJIT_INST_2x(movq2dq, Movq2dq, Xmm, Mm)                            // SSE2
  ASMJIT_INST_2x(movsd, Movsd, Xmm, Xmm)                               // SSE2
  ASMJIT_INST_2x(movsd, Movsd, Xmm, Mem)                               // SSE2
  ASMJIT_INST_2x(movsd, Movsd, Mem, Xmm)                               // SSE2
  ASMJIT_INST_2x(movshdup, Movshdup, Xmm, Xmm)                         // SSE3
  ASMJIT_INST_2x(movshdup, Movshdup, Xmm, Mem)                         // SSE3
  ASMJIT_INST_2x(movsldup, Movsldup, Xmm, Xmm)                         // SSE3
  ASMJIT_INST_2x(movsldup, Movsldup, Xmm, Mem)                         // SSE3
  ASMJIT_INST_2x(movss, Movss, Xmm, Xmm)                               // SSE
  ASMJIT_INST_2x(movss, Movss, Xmm, Mem)                               // SSE
  ASMJIT_INST_2x(movss, Movss, Mem, Xmm)                               // SSE
  ASMJIT_INST_2x(movupd, Movupd, Xmm, Xmm)                             // SSE2
  ASMJIT_INST_2x(movupd, Movupd, Xmm, Mem)                             // SSE2
  ASMJIT_INST_2x(movupd, Movupd, Mem, Xmm)                             // SSE2
  ASMJIT_INST_2x(movups, Movups, Xmm, Xmm)                             // SSE
  ASMJIT_INST_2x(movups, Movups, Xmm, Mem)                             // SSE
  ASMJIT_INST_2x(movups, Movups, Mem, Xmm)                             // SSE
  ASMJIT_INST_3i(mpsadbw, Mpsadbw, Xmm, Xmm, Imm)                      // SSE4_1
  ASMJIT_INST_3i(mpsadbw, Mpsadbw, Xmm, Mem, Imm)                      // SSE4_1
  ASMJIT_INST_2x(mulpd, Mulpd, Xmm, Xmm)                               // SSE2
  ASMJIT_INST_2x(mulpd, Mulpd, Xmm, Mem)                               // SSE2
  ASMJIT_INST_2x(mulps, Mulps, Xmm, Xmm)                               // SSE
  ASMJIT_INST_2x(mulps, Mulps, Xmm, Mem)                               // SSE
  ASMJIT_INST_2x(mulsd, Mulsd, Xmm, Xmm)                               // SSE2
  ASMJIT_INST_2x(mulsd, Mulsd, Xmm, Mem)                               // SSE2
  ASMJIT_INST_2x(mulss, Mulss, Xmm, Xmm)                               // SSE
  ASMJIT_INST_2x(mulss, Mulss, Xmm, Mem)                               // SSE
  ASMJIT_INST_2x(orpd, Orpd, Xmm, Xmm)                                 // SSE2
  ASMJIT_INST_2x(orpd, Orpd, Xmm, Mem)                                 // SSE2
  ASMJIT_INST_2x(orps, Orps, Xmm, Xmm)                                 // SSE
  ASMJIT_INST_2x(orps, Orps, Xmm, Mem)                                 // SSE
  ASMJIT_INST_2x(packssdw, Packssdw, Mm, Mm)                           // MMX
  ASMJIT_INST_2x(packssdw, Packssdw, Mm, Mem)                          // MMX
  ASMJIT_INST_2x(packssdw, Packssdw, Xmm, Xmm)                         // SSE2
  ASMJIT_INST_2x(packssdw, Packssdw, Xmm, Mem)                         // SSE2
  ASMJIT_INST_2x(packsswb, Packsswb, Mm, Mm)                           // MMX
  ASMJIT_INST_2x(packsswb, Packsswb, Mm, Mem)                          // MMX
  ASMJIT_INST_2x(packsswb, Packsswb, Xmm, Xmm)                         // SSE2
  ASMJIT_INST_2x(packsswb, Packsswb, Xmm, Mem)                         // SSE2
  ASMJIT_INST_2x(packusdw, Packusdw, Xmm, Xmm)                         // SSE4_1
  ASMJIT_INST_2x(packusdw, Packusdw, Xmm, Mem)                         // SSE4_1
  ASMJIT_INST_2x(packuswb, Packuswb, Mm, Mm)                           // MMX
  ASMJIT_INST_2x(packuswb, Packuswb, Mm, Mem)                          // MMX
  ASMJIT_INST_2x(packuswb, Packuswb, Xmm, Xmm)                         // SSE2
  ASMJIT_INST_2x(packuswb, Packuswb, Xmm, Mem)                         // SSE2
  ASMJIT_INST_2x(pabsb, Pabsb, Mm, Mm)                                 // SSSE3
  ASMJIT_INST_2x(pabsb, Pabsb, Mm, Mem)                                // SSSE3
  ASMJIT_INST_2x(pabsb, Pabsb, Xmm, Xmm)                               // SSSE3
  ASMJIT_INST_2x(pabsb, Pabsb, Xmm, Mem)                               // SSSE3
  ASMJIT_INST_2x(pabsd, Pabsd, Mm, Mm)                                 // SSSE3
  ASMJIT_INST_2x(pabsd, Pabsd, Mm, Mem)                                // SSSE3
  ASMJIT_INST_2x(pabsd, Pabsd, Xmm, Xmm)                               // SSSE3
  ASMJIT_INST_2x(pabsd, Pabsd, Xmm, Mem)                               // SSSE3
  ASMJIT_INST_2x(pabsw, Pabsw, Mm, Mm)                                 // SSSE3
  ASMJIT_INST_2x(pabsw, Pabsw, Mm, Mem)                                // SSSE3
  ASMJIT_INST_2x(pabsw, Pabsw, Xmm, Xmm)                               // SSSE3
  ASMJIT_INST_2x(pabsw, Pabsw, Xmm, Mem)                               // SSSE3
  ASMJIT_INST_2x(paddb, Paddb, Mm, Mm)                                 // MMX
  ASMJIT_INST_2x(paddb, Paddb, Mm, Mem)                                // MMX
  ASMJIT_INST_2x(paddb, Paddb, Xmm, Xmm)                               // SSE2
  ASMJIT_INST_2x(paddb, Paddb, Xmm, Mem)                               // SSE2
  ASMJIT_INST_2x(paddd, Paddd, Mm, Mm)                                 // MMX
  ASMJIT_INST_2x(paddd, Paddd, Mm, Mem)                                // MMX
  ASMJIT_INST_2x(paddd, Paddd, Xmm, Xmm)                               // SSE2
  ASMJIT_INST_2x(paddd, Paddd, Xmm, Mem)                               // SSE2
  ASMJIT_INST_2x(paddq, Paddq, Mm, Mm)                                 // SSE2
  ASMJIT_INST_2x(paddq, Paddq, Mm, Mem)                                // SSE2
  ASMJIT_INST_2x(paddq, Paddq, Xmm, Xmm)                               // SSE2
  ASMJIT_INST_2x(paddq, Paddq, Xmm, Mem)                               // SSE2
  ASMJIT_INST_2x(paddsb, Paddsb, Mm, Mm)                               // MMX
  ASMJIT_INST_2x(paddsb, Paddsb, Mm, Mem)                              // MMX
  ASMJIT_INST_2x(paddsb, Paddsb, Xmm, Xmm)                             // SSE2
  ASMJIT_INST_2x(paddsb, Paddsb, Xmm, Mem)                             // SSE2
  ASMJIT_INST_2x(paddsw, Paddsw, Mm, Mm)                               // MMX
  ASMJIT_INST_2x(paddsw, Paddsw, Mm, Mem)                              // MMX
  ASMJIT_INST_2x(paddsw, Paddsw, Xmm, Xmm)                             // SSE2
  ASMJIT_INST_2x(paddsw, Paddsw, Xmm, Mem)                             // SSE2
  ASMJIT_INST_2x(paddusb, Paddusb, Mm, Mm)                             // MMX
  ASMJIT_INST_2x(paddusb, Paddusb, Mm, Mem)                            // MMX
  ASMJIT_INST_2x(paddusb, Paddusb, Xmm, Xmm)                           // SSE2
  ASMJIT_INST_2x(paddusb, Paddusb, Xmm, Mem)                           // SSE2
  ASMJIT_INST_2x(paddusw, Paddusw, Mm, Mm)                             // MMX
  ASMJIT_INST_2x(paddusw, Paddusw, Mm, Mem)                            // MMX
  ASMJIT_INST_2x(paddusw, Paddusw, Xmm, Xmm)                           // SSE2
  ASMJIT_INST_2x(paddusw, Paddusw, Xmm, Mem)                           // SSE2
  ASMJIT_INST_2x(paddw, Paddw, Mm, Mm)                                 // MMX
  ASMJIT_INST_2x(paddw, Paddw, Mm, Mem)                                // MMX
  ASMJIT_INST_2x(paddw, Paddw, Xmm, Xmm)                               // SSE2
  ASMJIT_INST_2x(paddw, Paddw, Xmm, Mem)                               // SSE2
  ASMJIT_INST_3i(palignr, Palignr, Mm, Mm, Imm)                        // SSSE3
  ASMJIT_INST_3i(palignr, Palignr, Mm, Mem, Imm)                       // SSSE3
  ASMJIT_INST_3i(palignr, Palignr, Xmm, Xmm, Imm)                      // SSSE3
  ASMJIT_INST_3i(palignr, Palignr, Xmm, Mem, Imm)                      // SSSE3
  ASMJIT_INST_2x(pand, Pand, Mm, Mm)                                   // MMX
  ASMJIT_INST_2x(pand, Pand, Mm, Mem)                                  // MMX
  ASMJIT_INST_2x(pand, Pand, Xmm, Xmm)                                 // SSE2
  ASMJIT_INST_2x(pand, Pand, Xmm, Mem)                                 // SSE2
  ASMJIT_INST_2x(pandn, Pandn, Mm, Mm)                                 // MMX
  ASMJIT_INST_2x(pandn, Pandn, Mm, Mem)                                // MMX
  ASMJIT_INST_2x(pandn, Pandn, Xmm, Xmm)                               // SSE2
  ASMJIT_INST_2x(pandn, Pandn, Xmm, Mem)                               // SSE2
  ASMJIT_INST_2x(pavgb, Pavgb, Mm, Mm)                                 // SSE
  ASMJIT_INST_2x(pavgb, Pavgb, Mm, Mem)                                // SSE
  ASMJIT_INST_2x(pavgb, Pavgb, Xmm, Xmm)                               // SSE2
  ASMJIT_INST_2x(pavgb, Pavgb, Xmm, Mem)                               // SSE2
  ASMJIT_INST_2x(pavgw, Pavgw, Mm, Mm)                                 // SSE
  ASMJIT_INST_2x(pavgw, Pavgw, Mm, Mem)                                // SSE
  ASMJIT_INST_2x(pavgw, Pavgw, Xmm, Xmm)                               // SSE2
  ASMJIT_INST_2x(pavgw, Pavgw, Xmm, Mem)                               // SSE2
  ASMJIT_INST_3x(pblendvb, Pblendvb, Xmm, Xmm, XMM0)                   // SSE4_1 [EXPLICIT]
  ASMJIT_INST_3x(pblendvb, Pblendvb, Xmm, Mem, XMM0)                   // SSE4_1 [EXPLICIT]
  ASMJIT_INST_3i(pblendw, Pblendw, Xmm, Xmm, Imm)                      // SSE4_1
  ASMJIT_INST_3i(pblendw, Pblendw, Xmm, Mem, Imm)                      // SSE4_1
  ASMJIT_INST_3i(pclmulqdq, Pclmulqdq, Xmm, Xmm, Imm)                  // PCLMULQDQ.
  ASMJIT_INST_3i(pclmulqdq, Pclmulqdq, Xmm, Mem, Imm)                  // PCLMULQDQ.
  ASMJIT_INST_6x(pcmpestri, Pcmpestri, Xmm, Xmm, Imm, ECX, EAX, EDX)   // SSE4_2 [EXPLICIT]
  ASMJIT_INST_6x(pcmpestri, Pcmpestri, Xmm, Mem, Imm, ECX, EAX, EDX)   // SSE4_2 [EXPLICIT]
  ASMJIT_INST_6x(pcmpestrm, Pcmpestrm, Xmm, Xmm, Imm, XMM0, EAX, EDX)  // SSE4_2 [EXPLICIT]
  ASMJIT_INST_6x(pcmpestrm, Pcmpestrm, Xmm, Mem, Imm, XMM0, EAX, EDX)  // SSE4_2 [EXPLICIT]
  ASMJIT_INST_2x(pcmpeqb, Pcmpeqb, Mm, Mm)                             // MMX
  ASMJIT_INST_2x(pcmpeqb, Pcmpeqb, Mm, Mem)                            // MMX
  ASMJIT_INST_2x(pcmpeqb, Pcmpeqb, Xmm, Xmm)                           // SSE2
  ASMJIT_INST_2x(pcmpeqb, Pcmpeqb, Xmm, Mem)                           // SSE2
  ASMJIT_INST_2x(pcmpeqd, Pcmpeqd, Mm, Mm)                             // MMX
  ASMJIT_INST_2x(pcmpeqd, Pcmpeqd, Mm, Mem)                            // MMX
  ASMJIT_INST_2x(pcmpeqd, Pcmpeqd, Xmm, Xmm)                           // SSE2
  ASMJIT_INST_2x(pcmpeqd, Pcmpeqd, Xmm, Mem)                           // SSE2
  ASMJIT_INST_2x(pcmpeqq, Pcmpeqq, Xmm, Xmm)                           // SSE4_1
  ASMJIT_INST_2x(pcmpeqq, Pcmpeqq, Xmm, Mem)                           // SSE4_1
  ASMJIT_INST_2x(pcmpeqw, Pcmpeqw, Mm, Mm)                             // MMX
  ASMJIT_INST_2x(pcmpeqw, Pcmpeqw, Mm, Mem)                            // MMX
  ASMJIT_INST_2x(pcmpeqw, Pcmpeqw, Xmm, Xmm)                           // SSE2
  ASMJIT_INST_2x(pcmpeqw, Pcmpeqw, Xmm, Mem)                           // SSE2
  ASMJIT_INST_2x(pcmpgtb, Pcmpgtb, Mm, Mm)                             // MMX
  ASMJIT_INST_2x(pcmpgtb, Pcmpgtb, Mm, Mem)                            // MMX
  ASMJIT_INST_2x(pcmpgtb, Pcmpgtb, Xmm, Xmm)                           // SSE2
  ASMJIT_INST_2x(pcmpgtb, Pcmpgtb, Xmm, Mem)                           // SSE2
  ASMJIT_INST_2x(pcmpgtd, Pcmpgtd, Mm, Mm)                             // MMX
  ASMJIT_INST_2x(pcmpgtd, Pcmpgtd, Mm, Mem)                            // MMX
  ASMJIT_INST_2x(pcmpgtd, Pcmpgtd, Xmm, Xmm)                           // SSE2
  ASMJIT_INST_2x(pcmpgtd, Pcmpgtd, Xmm, Mem)                           // SSE2
  ASMJIT_INST_2x(pcmpgtq, Pcmpgtq, Xmm, Xmm)                           // SSE4_2.
  ASMJIT_INST_2x(pcmpgtq, Pcmpgtq, Xmm, Mem)                           // SSE4_2.
  ASMJIT_INST_2x(pcmpgtw, Pcmpgtw, Mm, Mm)                             // MMX
  ASMJIT_INST_2x(pcmpgtw, Pcmpgtw, Mm, Mem)                            // MMX
  ASMJIT_INST_2x(pcmpgtw, Pcmpgtw, Xmm, Xmm)                           // SSE2
  ASMJIT_INST_2x(pcmpgtw, Pcmpgtw, Xmm, Mem)                           // SSE2
  ASMJIT_INST_4x(pcmpistri, Pcmpistri, Xmm, Xmm, Imm, ECX)             // SSE4_2 [EXPLICIT]
  ASMJIT_INST_4x(pcmpistri, Pcmpistri, Xmm, Mem, Imm, ECX)             // SSE4_2 [EXPLICIT]
  ASMJIT_INST_4x(pcmpistrm, Pcmpistrm, Xmm, Xmm, Imm, XMM0)            // SSE4_2 [EXPLICIT]
  ASMJIT_INST_4x(pcmpistrm, Pcmpistrm, Xmm, Mem, Imm, XMM0)            // SSE4_2 [EXPLICIT]
  ASMJIT_INST_3i(pextrb, Pextrb, Gp, Xmm, Imm)                         // SSE4_1
  ASMJIT_INST_3i(pextrb, Pextrb, Mem, Xmm, Imm)                        // SSE4_1
  ASMJIT_INST_3i(pextrd, Pextrd, Gp, Xmm, Imm)                         // SSE4_1
  ASMJIT_INST_3i(pextrd, Pextrd, Mem, Xmm, Imm)                        // SSE4_1
  ASMJIT_INST_3i(pextrq, Pextrq, Gp, Xmm, Imm)                         // SSE4_1
  ASMJIT_INST_3i(pextrq, Pextrq, Mem, Xmm, Imm)                        // SSE4_1
  ASMJIT_INST_3i(pextrw, Pextrw, Gp, Mm, Imm)                          // SSE
  ASMJIT_INST_3i(pextrw, Pextrw, Gp, Xmm, Imm)                         // SSE2
  ASMJIT_INST_3i(pextrw, Pextrw, Mem, Xmm, Imm)                        // SSE4_1
  ASMJIT_INST_2x(phaddd, Phaddd, Mm, Mm)                               // SSSE3
  ASMJIT_INST_2x(phaddd, Phaddd, Mm, Mem)                              // SSSE3
  ASMJIT_INST_2x(phaddd, Phaddd, Xmm, Xmm)                             // SSSE3
  ASMJIT_INST_2x(phaddd, Phaddd, Xmm, Mem)                             // SSSE3
  ASMJIT_INST_2x(phaddsw, Phaddsw, Mm, Mm)                             // SSSE3
  ASMJIT_INST_2x(phaddsw, Phaddsw, Mm, Mem)                            // SSSE3
  ASMJIT_INST_2x(phaddsw, Phaddsw, Xmm, Xmm)                           // SSSE3
  ASMJIT_INST_2x(phaddsw, Phaddsw, Xmm, Mem)                           // SSSE3
  ASMJIT_INST_2x(phaddw, Phaddw, Mm, Mm)                               // SSSE3
  ASMJIT_INST_2x(phaddw, Phaddw, Mm, Mem)                              // SSSE3
  ASMJIT_INST_2x(phaddw, Phaddw, Xmm, Xmm)                             // SSSE3
  ASMJIT_INST_2x(phaddw, Phaddw, Xmm, Mem)                             // SSSE3
  ASMJIT_INST_2x(phminposuw, Phminposuw, Xmm, Xmm)                     // SSE4_1
  ASMJIT_INST_2x(phminposuw, Phminposuw, Xmm, Mem)                     // SSE4_1
  ASMJIT_INST_2x(phsubd, Phsubd, Mm, Mm)                               // SSSE3
  ASMJIT_INST_2x(phsubd, Phsubd, Mm, Mem)                              // SSSE3
  ASMJIT_INST_2x(phsubd, Phsubd, Xmm, Xmm)                             // SSSE3
  ASMJIT_INST_2x(phsubd, Phsubd, Xmm, Mem)                             // SSSE3
  ASMJIT_INST_2x(phsubsw, Phsubsw, Mm, Mm)                             // SSSE3
  ASMJIT_INST_2x(phsubsw, Phsubsw, Mm, Mem)                            // SSSE3
  ASMJIT_INST_2x(phsubsw, Phsubsw, Xmm, Xmm)                           // SSSE3
  ASMJIT_INST_2x(phsubsw, Phsubsw, Xmm, Mem)                           // SSSE3
  ASMJIT_INST_2x(phsubw, Phsubw, Mm, Mm)                               // SSSE3
  ASMJIT_INST_2x(phsubw, Phsubw, Mm, Mem)                              // SSSE3
  ASMJIT_INST_2x(phsubw, Phsubw, Xmm, Xmm)                             // SSSE3
  ASMJIT_INST_2x(phsubw, Phsubw, Xmm, Mem)                             // SSSE3
  ASMJIT_INST_3i(pinsrb, Pinsrb, Xmm, Gp, Imm)                         // SSE4_1
  ASMJIT_INST_3i(pinsrb, Pinsrb, Xmm, Mem, Imm)                        // SSE4_1
  ASMJIT_INST_3i(pinsrd, Pinsrd, Xmm, Gp, Imm)                         // SSE4_1
  ASMJIT_INST_3i(pinsrd, Pinsrd, Xmm, Mem, Imm)                        // SSE4_1
  ASMJIT_INST_3i(pinsrq, Pinsrq, Xmm, Gp, Imm)                         // SSE4_1
  ASMJIT_INST_3i(pinsrq, Pinsrq, Xmm, Mem, Imm)                        // SSE4_1
  ASMJIT_INST_3i(pinsrw, Pinsrw, Mm, Gp, Imm)                          // SSE
  ASMJIT_INST_3i(pinsrw, Pinsrw, Mm, Mem, Imm)                         // SSE
  ASMJIT_INST_3i(pinsrw, Pinsrw, Xmm, Gp, Imm)                         // SSE2
  ASMJIT_INST_3i(pinsrw, Pinsrw, Xmm, Mem, Imm)                        // SSE2
  ASMJIT_INST_2x(pmaddubsw, Pmaddubsw, Mm, Mm)                         // SSSE3
  ASMJIT_INST_2x(pmaddubsw, Pmaddubsw, Mm, Mem)                        // SSSE3
  ASMJIT_INST_2x(pmaddubsw, Pmaddubsw, Xmm, Xmm)                       // SSSE3
  ASMJIT_INST_2x(pmaddubsw, Pmaddubsw, Xmm, Mem)                       // SSSE3
  ASMJIT_INST_2x(pmaddwd, Pmaddwd, Mm, Mm)                             // MMX
  ASMJIT_INST_2x(pmaddwd, Pmaddwd, Mm, Mem)                            // MMX
  ASMJIT_INST_2x(pmaddwd, Pmaddwd, Xmm, Xmm)                           // SSE2
  ASMJIT_INST_2x(pmaddwd, Pmaddwd, Xmm, Mem)                           // SSE2
  ASMJIT_INST_2x(pmaxsb, Pmaxsb, Xmm, Xmm)                             // SSE4_1
  ASMJIT_INST_2x(pmaxsb, Pmaxsb, Xmm, Mem)                             // SSE4_1
  ASMJIT_INST_2x(pmaxsd, Pmaxsd, Xmm, Xmm)                             // SSE4_1
  ASMJIT_INST_2x(pmaxsd, Pmaxsd, Xmm, Mem)                             // SSE4_1
  ASMJIT_INST_2x(pmaxsw, Pmaxsw, Mm, Mm)                               // SSE
  ASMJIT_INST_2x(pmaxsw, Pmaxsw, Mm, Mem)                              // SSE
  ASMJIT_INST_2x(pmaxsw, Pmaxsw, Xmm, Xmm)                             // SSE2
  ASMJIT_INST_2x(pmaxsw, Pmaxsw, Xmm, Mem)                             // SSE2
  ASMJIT_INST_2x(pmaxub, Pmaxub, Mm, Mm)                               // SSE
  ASMJIT_INST_2x(pmaxub, Pmaxub, Mm, Mem)                              // SSE
  ASMJIT_INST_2x(pmaxub, Pmaxub, Xmm, Xmm)                             // SSE2
  ASMJIT_INST_2x(pmaxub, Pmaxub, Xmm, Mem)                             // SSE2
  ASMJIT_INST_2x(pmaxud, Pmaxud, Xmm, Xmm)                             // SSE4_1
  ASMJIT_INST_2x(pmaxud, Pmaxud, Xmm, Mem)                             // SSE4_1
  ASMJIT_INST_2x(pmaxuw, Pmaxuw, Xmm, Xmm)                             // SSE4_1
  ASMJIT_INST_2x(pmaxuw, Pmaxuw, Xmm, Mem)                             // SSE4_1
  ASMJIT_INST_2x(pminsb, Pminsb, Xmm, Xmm)                             // SSE4_1
  ASMJIT_INST_2x(pminsb, Pminsb, Xmm, Mem)                             // SSE4_1
  ASMJIT_INST_2x(pminsd, Pminsd, Xmm, Xmm)                             // SSE4_1
  ASMJIT_INST_2x(pminsd, Pminsd, Xmm, Mem)                             // SSE4_1
  ASMJIT_INST_2x(pminsw, Pminsw, Mm, Mm)                               // SSE
  ASMJIT_INST_2x(pminsw, Pminsw, Mm, Mem)                              // SSE
  ASMJIT_INST_2x(pminsw, Pminsw, Xmm, Xmm)                             // SSE2
  ASMJIT_INST_2x(pminsw, Pminsw, Xmm, Mem)                             // SSE2
  ASMJIT_INST_2x(pminub, Pminub, Mm, Mm)                               // SSE
  ASMJIT_INST_2x(pminub, Pminub, Mm, Mem)                              // SSE
  ASMJIT_INST_2x(pminub, Pminub, Xmm, Xmm)                             // SSE2
  ASMJIT_INST_2x(pminub, Pminub, Xmm, Mem)                             // SSE2
  ASMJIT_INST_2x(pminud, Pminud, Xmm, Xmm)                             // SSE4_1
  ASMJIT_INST_2x(pminud, Pminud, Xmm, Mem)                             // SSE4_1
  ASMJIT_INST_2x(pminuw, Pminuw, Xmm, Xmm)                             // SSE4_1
  ASMJIT_INST_2x(pminuw, Pminuw, Xmm, Mem)                             // SSE4_1
  ASMJIT_INST_2x(pmovmskb, Pmovmskb, Gp, Mm)                           // SSE
  ASMJIT_INST_2x(pmovmskb, Pmovmskb, Gp, Xmm)                          // SSE2
  ASMJIT_INST_2x(pmovsxbd, Pmovsxbd, Xmm, Xmm)                         // SSE4_1
  ASMJIT_INST_2x(pmovsxbd, Pmovsxbd, Xmm, Mem)                         // SSE4_1
  ASMJIT_INST_2x(pmovsxbq, Pmovsxbq, Xmm, Xmm)                         // SSE4_1
  ASMJIT_INST_2x(pmovsxbq, Pmovsxbq, Xmm, Mem)                         // SSE4_1
  ASMJIT_INST_2x(pmovsxbw, Pmovsxbw, Xmm, Xmm)                         // SSE4_1
  ASMJIT_INST_2x(pmovsxbw, Pmovsxbw, Xmm, Mem)                         // SSE4_1
  ASMJIT_INST_2x(pmovsxdq, Pmovsxdq, Xmm, Xmm)                         // SSE4_1
  ASMJIT_INST_2x(pmovsxdq, Pmovsxdq, Xmm, Mem)                         // SSE4_1
  ASMJIT_INST_2x(pmovsxwd, Pmovsxwd, Xmm, Xmm)                         // SSE4_1
  ASMJIT_INST_2x(pmovsxwd, Pmovsxwd, Xmm, Mem)                         // SSE4_1
  ASMJIT_INST_2x(pmovsxwq, Pmovsxwq, Xmm, Xmm)                         // SSE4_1
  ASMJIT_INST_2x(pmovsxwq, Pmovsxwq, Xmm, Mem)                         // SSE4_1
  ASMJIT_INST_2x(pmovzxbd, Pmovzxbd, Xmm, Xmm)                         // SSE4_1
  ASMJIT_INST_2x(pmovzxbd, Pmovzxbd, Xmm, Mem)                         // SSE4_1
  ASMJIT_INST_2x(pmovzxbq, Pmovzxbq, Xmm, Xmm)                         // SSE4_1
  ASMJIT_INST_2x(pmovzxbq, Pmovzxbq, Xmm, Mem)                         // SSE4_1
  ASMJIT_INST_2x(pmovzxbw, Pmovzxbw, Xmm, Xmm)                         // SSE4_1
  ASMJIT_INST_2x(pmovzxbw, Pmovzxbw, Xmm, Mem)                         // SSE4_1
  ASMJIT_INST_2x(pmovzxdq, Pmovzxdq, Xmm, Xmm)                         // SSE4_1
  ASMJIT_INST_2x(pmovzxdq, Pmovzxdq, Xmm, Mem)                         // SSE4_1
  ASMJIT_INST_2x(pmovzxwd, Pmovzxwd, Xmm, Xmm)                         // SSE4_1
  ASMJIT_INST_2x(pmovzxwd, Pmovzxwd, Xmm, Mem)                         // SSE4_1
  ASMJIT_INST_2x(pmovzxwq, Pmovzxwq, Xmm, Xmm)                         // SSE4_1
  ASMJIT_INST_2x(pmovzxwq, Pmovzxwq, Xmm, Mem)                         // SSE4_1
  ASMJIT_INST_2x(pmuldq, Pmuldq, Xmm, Xmm)                             // SSE4_1
  ASMJIT_INST_2x(pmuldq, Pmuldq, Xmm, Mem)                             // SSE4_1
  ASMJIT_INST_2x(pmulhrsw, Pmulhrsw, Mm, Mm)                           // SSSE3
  ASMJIT_INST_2x(pmulhrsw, Pmulhrsw, Mm, Mem)                          // SSSE3
  ASMJIT_INST_2x(pmulhrsw, Pmulhrsw, Xmm, Xmm)                         // SSSE3
  ASMJIT_INST_2x(pmulhrsw, Pmulhrsw, Xmm, Mem)                         // SSSE3
  ASMJIT_INST_2x(pmulhw, Pmulhw, Mm, Mm)                               // MMX
  ASMJIT_INST_2x(pmulhw, Pmulhw, Mm, Mem)                              // MMX
  ASMJIT_INST_2x(pmulhw, Pmulhw, Xmm, Xmm)                             // SSE2
  ASMJIT_INST_2x(pmulhw, Pmulhw, Xmm, Mem)                             // SSE2
  ASMJIT_INST_2x(pmulhuw, Pmulhuw, Mm, Mm)                             // SSE
  ASMJIT_INST_2x(pmulhuw, Pmulhuw, Mm, Mem)                            // SSE
  ASMJIT_INST_2x(pmulhuw, Pmulhuw, Xmm, Xmm)                           // SSE2
  ASMJIT_INST_2x(pmulhuw, Pmulhuw, Xmm, Mem)                           // SSE2
  ASMJIT_INST_2x(pmulld, Pmulld, Xmm, Xmm)                             // SSE4_1
  ASMJIT_INST_2x(pmulld, Pmulld, Xmm, Mem)                             // SSE4_1
  ASMJIT_INST_2x(pmullw, Pmullw, Mm, Mm)                               // MMX
  ASMJIT_INST_2x(pmullw, Pmullw, Mm, Mem)                              // MMX
  ASMJIT_INST_2x(pmullw, Pmullw, Xmm, Xmm)                             // SSE2
  ASMJIT_INST_2x(pmullw, Pmullw, Xmm, Mem)                             // SSE2
  ASMJIT_INST_2x(pmuludq, Pmuludq, Mm, Mm)                             // SSE2
  ASMJIT_INST_2x(pmuludq, Pmuludq, Mm, Mem)                            // SSE2
  ASMJIT_INST_2x(pmuludq, Pmuludq, Xmm, Xmm)                           // SSE2
  ASMJIT_INST_2x(pmuludq, Pmuludq, Xmm, Mem)                           // SSE2
  ASMJIT_INST_2x(por, Por, Mm, Mm)                                     // MMX
  ASMJIT_INST_2x(por, Por, Mm, Mem)                                    // MMX
  ASMJIT_INST_2x(por, Por, Xmm, Xmm)                                   // SSE2
  ASMJIT_INST_2x(por, Por, Xmm, Mem)                                   // SSE2
  ASMJIT_INST_2x(psadbw, Psadbw, Mm, Mm)                               // SSE
  ASMJIT_INST_2x(psadbw, Psadbw, Mm, Mem)                              // SSE
  ASMJIT_INST_2x(psadbw, Psadbw, Xmm, Xmm)                             // SSE
  ASMJIT_INST_2x(psadbw, Psadbw, Xmm, Mem)                             // SSE
  ASMJIT_INST_2x(pslld, Pslld, Mm, Mm)                                 // MMX
  ASMJIT_INST_2x(pslld, Pslld, Mm, Mem)                                // MMX
  ASMJIT_INST_2i(pslld, Pslld, Mm, Imm)                                // MMX
  ASMJIT_INST_2x(pslld, Pslld, Xmm, Xmm)                               // SSE2
  ASMJIT_INST_2x(pslld, Pslld, Xmm, Mem)                               // SSE2
  ASMJIT_INST_2i(pslld, Pslld, Xmm, Imm)                               // SSE2
  ASMJIT_INST_2i(pslldq, Pslldq, Xmm, Imm)                             // SSE2
  ASMJIT_INST_2x(psllq, Psllq, Mm, Mm)                                 // MMX
  ASMJIT_INST_2x(psllq, Psllq, Mm, Mem)                                // MMX
  ASMJIT_INST_2i(psllq, Psllq, Mm, Imm)                                // MMX
  ASMJIT_INST_2x(psllq, Psllq, Xmm, Xmm)                               // SSE2
  ASMJIT_INST_2x(psllq, Psllq, Xmm, Mem)                               // SSE2
  ASMJIT_INST_2i(psllq, Psllq, Xmm, Imm)                               // SSE2
  ASMJIT_INST_2x(psllw, Psllw, Mm, Mm)                                 // MMX
  ASMJIT_INST_2x(psllw, Psllw, Mm, Mem)                                // MMX
  ASMJIT_INST_2i(psllw, Psllw, Mm, Imm)                                // MMX
  ASMJIT_INST_2x(psllw, Psllw, Xmm, Xmm)                               // SSE2
  ASMJIT_INST_2x(psllw, Psllw, Xmm, Mem)                               // SSE2
  ASMJIT_INST_2i(psllw, Psllw, Xmm, Imm)                               // SSE2
  ASMJIT_INST_2x(psrad, Psrad, Mm, Mm)                                 // MMX
  ASMJIT_INST_2x(psrad, Psrad, Mm, Mem)                                // MMX
  ASMJIT_INST_2i(psrad, Psrad, Mm, Imm)                                // MMX
  ASMJIT_INST_2x(psrad, Psrad, Xmm, Xmm)                               // SSE2
  ASMJIT_INST_2x(psrad, Psrad, Xmm, Mem)                               // SSE2
  ASMJIT_INST_2i(psrad, Psrad, Xmm, Imm)                               // SSE2
  ASMJIT_INST_2x(psraw, Psraw, Mm, Mm)                                 // MMX
  ASMJIT_INST_2x(psraw, Psraw, Mm, Mem)                                // MMX
  ASMJIT_INST_2i(psraw, Psraw, Mm, Imm)                                // MMX
  ASMJIT_INST_2x(psraw, Psraw, Xmm, Xmm)                               // SSE2
  ASMJIT_INST_2x(psraw, Psraw, Xmm, Mem)                               // SSE2
  ASMJIT_INST_2i(psraw, Psraw, Xmm, Imm)                               // SSE2
  ASMJIT_INST_2x(pshufb, Pshufb, Mm, Mm)                               // SSSE3
  ASMJIT_INST_2x(pshufb, Pshufb, Mm, Mem)                              // SSSE3
  ASMJIT_INST_2x(pshufb, Pshufb, Xmm, Xmm)                             // SSSE3
  ASMJIT_INST_2x(pshufb, Pshufb, Xmm, Mem)                             // SSSE3
  ASMJIT_INST_3i(pshufd, Pshufd, Xmm, Xmm, Imm)                        // SSE2
  ASMJIT_INST_3i(pshufd, Pshufd, Xmm, Mem, Imm)                        // SSE2
  ASMJIT_INST_3i(pshufhw, Pshufhw, Xmm, Xmm, Imm)                      // SSE2
  ASMJIT_INST_3i(pshufhw, Pshufhw, Xmm, Mem, Imm)                      // SSE2
  ASMJIT_INST_3i(pshuflw, Pshuflw, Xmm, Xmm, Imm)                      // SSE2
  ASMJIT_INST_3i(pshuflw, Pshuflw, Xmm, Mem, Imm)                      // SSE2
  ASMJIT_INST_3i(pshufw, Pshufw, Mm, Mm, Imm)                          // SSE
  ASMJIT_INST_3i(pshufw, Pshufw, Mm, Mem, Imm)                         // SSE
  ASMJIT_INST_2x(psignb, Psignb, Mm, Mm)                               // SSSE3
  ASMJIT_INST_2x(psignb, Psignb, Mm, Mem)                              // SSSE3
  ASMJIT_INST_2x(psignb, Psignb, Xmm, Xmm)                             // SSSE3
  ASMJIT_INST_2x(psignb, Psignb, Xmm, Mem)                             // SSSE3
  ASMJIT_INST_2x(psignd, Psignd, Mm, Mm)                               // SSSE3
  ASMJIT_INST_2x(psignd, Psignd, Mm, Mem)                              // SSSE3
  ASMJIT_INST_2x(psignd, Psignd, Xmm, Xmm)                             // SSSE3
  ASMJIT_INST_2x(psignd, Psignd, Xmm, Mem)                             // SSSE3
  ASMJIT_INST_2x(psignw, Psignw, Mm, Mm)                               // SSSE3
  ASMJIT_INST_2x(psignw, Psignw, Mm, Mem)                              // SSSE3
  ASMJIT_INST_2x(psignw, Psignw, Xmm, Xmm)                             // SSSE3
  ASMJIT_INST_2x(psignw, Psignw, Xmm, Mem)                             // SSSE3
  ASMJIT_INST_2x(psrld, Psrld, Mm, Mm)                                 // MMX
  ASMJIT_INST_2x(psrld, Psrld, Mm, Mem)                                // MMX
  ASMJIT_INST_2i(psrld, Psrld, Mm, Imm)                                // MMX
  ASMJIT_INST_2x(psrld, Psrld, Xmm, Xmm)                               // SSE2
  ASMJIT_INST_2x(psrld, Psrld, Xmm, Mem)                               // SSE2
  ASMJIT_INST_2i(psrld, Psrld, Xmm, Imm)                               // SSE2
  ASMJIT_INST_2i(psrldq, Psrldq, Xmm, Imm)                             // SSE2
  ASMJIT_INST_2x(psrlq, Psrlq, Mm, Mm)                                 // MMX
  ASMJIT_INST_2x(psrlq, Psrlq, Mm, Mem)                                // MMX
  ASMJIT_INST_2i(psrlq, Psrlq, Mm, Imm)                                // MMX
  ASMJIT_INST_2x(psrlq, Psrlq, Xmm, Xmm)                               // SSE2
  ASMJIT_INST_2x(psrlq, Psrlq, Xmm, Mem)                               // SSE2
  ASMJIT_INST_2i(psrlq, Psrlq, Xmm, Imm)                               // SSE2
  ASMJIT_INST_2x(psrlw, Psrlw, Mm, Mm)                                 // MMX
  ASMJIT_INST_2x(psrlw, Psrlw, Mm, Mem)                                // MMX
  ASMJIT_INST_2i(psrlw, Psrlw, Mm, Imm)                                // MMX
  ASMJIT_INST_2x(psrlw, Psrlw, Xmm, Xmm)                               // SSE2
  ASMJIT_INST_2x(psrlw, Psrlw, Xmm, Mem)                               // SSE2
  ASMJIT_INST_2i(psrlw, Psrlw, Xmm, Imm)                               // SSE2
  ASMJIT_INST_2x(psubb, Psubb, Mm, Mm)                                 // MMX
  ASMJIT_INST_2x(psubb, Psubb, Mm, Mem)                                // MMX
  ASMJIT_INST_2x(psubb, Psubb, Xmm, Xmm)                               // SSE2
  ASMJIT_INST_2x(psubb, Psubb, Xmm, Mem)                               // SSE2
  ASMJIT_INST_2x(psubd, Psubd, Mm, Mm)                                 // MMX
  ASMJIT_INST_2x(psubd, Psubd, Mm, Mem)                                // MMX
  ASMJIT_INST_2x(psubd, Psubd, Xmm, Xmm)                               // SSE2
  ASMJIT_INST_2x(psubd, Psubd, Xmm, Mem)                               // SSE2
  ASMJIT_INST_2x(psubq, Psubq, Mm, Mm)                                 // SSE2
  ASMJIT_INST_2x(psubq, Psubq, Mm, Mem)                                // SSE2
  ASMJIT_INST_2x(psubq, Psubq, Xmm, Xmm)                               // SSE2
  ASMJIT_INST_2x(psubq, Psubq, Xmm, Mem)                               // SSE2
  ASMJIT_INST_2x(psubsb, Psubsb, Mm, Mm)                               // MMX
  ASMJIT_INST_2x(psubsb, Psubsb, Mm, Mem)                              // MMX
  ASMJIT_INST_2x(psubsb, Psubsb, Xmm, Xmm)                             // SSE2
  ASMJIT_INST_2x(psubsb, Psubsb, Xmm, Mem)                             // SSE2
  ASMJIT_INST_2x(psubsw, Psubsw, Mm, Mm)                               // MMX
  ASMJIT_INST_2x(psubsw, Psubsw, Mm, Mem)                              // MMX
  ASMJIT_INST_2x(psubsw, Psubsw, Xmm, Xmm)                             // SSE2
  ASMJIT_INST_2x(psubsw, Psubsw, Xmm, Mem)                             // SSE2
  ASMJIT_INST_2x(psubusb, Psubusb, Mm, Mm)                             // MMX
  ASMJIT_INST_2x(psubusb, Psubusb, Mm, Mem)                            // MMX
  ASMJIT_INST_2x(psubusb, Psubusb, Xmm, Xmm)                           // SSE2
  ASMJIT_INST_2x(psubusb, Psubusb, Xmm, Mem)                           // SSE2
  ASMJIT_INST_2x(psubusw, Psubusw, Mm, Mm)                             // MMX
  ASMJIT_INST_2x(psubusw, Psubusw, Mm, Mem)                            // MMX
  ASMJIT_INST_2x(psubusw, Psubusw, Xmm, Xmm)                           // SSE2
  ASMJIT_INST_2x(psubusw, Psubusw, Xmm, Mem)                           // SSE2
  ASMJIT_INST_2x(psubw, Psubw, Mm, Mm)                                 // MMX
  ASMJIT_INST_2x(psubw, Psubw, Mm, Mem)                                // MMX
  ASMJIT_INST_2x(psubw, Psubw, Xmm, Xmm)                               // SSE2
  ASMJIT_INST_2x(psubw, Psubw, Xmm, Mem)                               // SSE2
  ASMJIT_INST_2x(ptest, Ptest, Xmm, Xmm)                               // SSE4_1
  ASMJIT_INST_2x(ptest, Ptest, Xmm, Mem)                               // SSE4_1
  ASMJIT_INST_2x(punpckhbw, Punpckhbw, Mm, Mm)                         // MMX
  ASMJIT_INST_2x(punpckhbw, Punpckhbw, Mm, Mem)                        // MMX
  ASMJIT_INST_2x(punpckhbw, Punpckhbw, Xmm, Xmm)                       // SSE2
  ASMJIT_INST_2x(punpckhbw, Punpckhbw, Xmm, Mem)                       // SSE2
  ASMJIT_INST_2x(punpckhdq, Punpckhdq, Mm, Mm)                         // MMX
  ASMJIT_INST_2x(punpckhdq, Punpckhdq, Mm, Mem)                        // MMX
  ASMJIT_INST_2x(punpckhdq, Punpckhdq, Xmm, Xmm)                       // SSE2
  ASMJIT_INST_2x(punpckhdq, Punpckhdq, Xmm, Mem)                       // SSE2
  ASMJIT_INST_2x(punpckhqdq, Punpckhqdq, Xmm, Xmm)                     // SSE2
  ASMJIT_INST_2x(punpckhqdq, Punpckhqdq, Xmm, Mem)                     // SSE2
  ASMJIT_INST_2x(punpckhwd, Punpckhwd, Mm, Mm)                         // MMX
  ASMJIT_INST_2x(punpckhwd, Punpckhwd, Mm, Mem)                        // MMX
  ASMJIT_INST_2x(punpckhwd, Punpckhwd, Xmm, Xmm)                       // SSE2
  ASMJIT_INST_2x(punpckhwd, Punpckhwd, Xmm, Mem)                       // SSE2
  ASMJIT_INST_2x(punpcklbw, Punpcklbw, Mm, Mm)                         // MMX
  ASMJIT_INST_2x(punpcklbw, Punpcklbw, Mm, Mem)                        // MMX
  ASMJIT_INST_2x(punpcklbw, Punpcklbw, Xmm, Xmm)                       // SSE2
  ASMJIT_INST_2x(punpcklbw, Punpcklbw, Xmm, Mem)                       // SSE2
  ASMJIT_INST_2x(punpckldq, Punpckldq, Mm, Mm)                         // MMX
  ASMJIT_INST_2x(punpckldq, Punpckldq, Mm, Mem)                        // MMX
  ASMJIT_INST_2x(punpckldq, Punpckldq, Xmm, Xmm)                       // SSE2
  ASMJIT_INST_2x(punpckldq, Punpckldq, Xmm, Mem)                       // SSE2
  ASMJIT_INST_2x(punpcklqdq, Punpcklqdq, Xmm, Xmm)                     // SSE2
  ASMJIT_INST_2x(punpcklqdq, Punpcklqdq, Xmm, Mem)                     // SSE2
  ASMJIT_INST_2x(punpcklwd, Punpcklwd, Mm, Mm)                         // MMX
  ASMJIT_INST_2x(punpcklwd, Punpcklwd, Mm, Mem)                        // MMX
  ASMJIT_INST_2x(punpcklwd, Punpcklwd, Xmm, Xmm)                       // SSE2
  ASMJIT_INST_2x(punpcklwd, Punpcklwd, Xmm, Mem)                       // SSE2
  ASMJIT_INST_2x(pxor, Pxor, Mm, Mm)                                   // MMX
  ASMJIT_INST_2x(pxor, Pxor, Mm, Mem)                                  // MMX
  ASMJIT_INST_2x(pxor, Pxor, Xmm, Xmm)                                 // SSE2
  ASMJIT_INST_2x(pxor, Pxor, Xmm, Mem)                                 // SSE2
  ASMJIT_INST_2x(rcpps, Rcpps, Xmm, Xmm)                               // SSE
  ASMJIT_INST_2x(rcpps, Rcpps, Xmm, Mem)                               // SSE
  ASMJIT_INST_2x(rcpss, Rcpss, Xmm, Xmm)                               // SSE
  ASMJIT_INST_2x(rcpss, Rcpss, Xmm, Mem)                               // SSE
  ASMJIT_INST_3i(roundpd, Roundpd, Xmm, Xmm, Imm)                      // SSE4_1
  ASMJIT_INST_3i(roundpd, Roundpd, Xmm, Mem, Imm)                      // SSE4_1
  ASMJIT_INST_3i(roundps, Roundps, Xmm, Xmm, Imm)                      // SSE4_1
  ASMJIT_INST_3i(roundps, Roundps, Xmm, Mem, Imm)                      // SSE4_1
  ASMJIT_INST_3i(roundsd, Roundsd, Xmm, Xmm, Imm)                      // SSE4_1
  ASMJIT_INST_3i(roundsd, Roundsd, Xmm, Mem, Imm)                      // SSE4_1
  ASMJIT_INST_3i(roundss, Roundss, Xmm, Xmm, Imm)                      // SSE4_1
  ASMJIT_INST_3i(roundss, Roundss, Xmm, Mem, Imm)                      // SSE4_1
  ASMJIT_INST_2x(rsqrtps, Rsqrtps, Xmm, Xmm)                           // SSE
  ASMJIT_INST_2x(rsqrtps, Rsqrtps, Xmm, Mem)                           // SSE
  ASMJIT_INST_2x(rsqrtss, Rsqrtss, Xmm, Xmm)                           // SSE
  ASMJIT_INST_2x(rsqrtss, Rsqrtss, Xmm, Mem)                           // SSE
  ASMJIT_INST_3i(shufpd, Shufpd, Xmm, Xmm, Imm)                        // SSE2
  ASMJIT_INST_3i(shufpd, Shufpd, Xmm, Mem, Imm)                        // SSE2
  ASMJIT_INST_3i(shufps, Shufps, Xmm, Xmm, Imm)                        // SSE
  ASMJIT_INST_3i(shufps, Shufps, Xmm, Mem, Imm)                        // SSE
  ASMJIT_INST_2x(sqrtpd, Sqrtpd, Xmm, Xmm)                             // SSE2
  ASMJIT_INST_2x(sqrtpd, Sqrtpd, Xmm, Mem)                             // SSE2
  ASMJIT_INST_2x(sqrtps, Sqrtps, Xmm, Xmm)                             // SSE
  ASMJIT_INST_2x(sqrtps, Sqrtps, Xmm, Mem)                             // SSE
  ASMJIT_INST_2x(sqrtsd, Sqrtsd, Xmm, Xmm)                             // SSE2
  ASMJIT_INST_2x(sqrtsd, Sqrtsd, Xmm, Mem)                             // SSE2
  ASMJIT_INST_2x(sqrtss, Sqrtss, Xmm, Xmm)                             // SSE
  ASMJIT_INST_2x(sqrtss, Sqrtss, Xmm, Mem)                             // SSE
  ASMJIT_INST_2x(subpd, Subpd, Xmm, Xmm)                               // SSE2
  ASMJIT_INST_2x(subpd, Subpd, Xmm, Mem)                               // SSE2
  ASMJIT_INST_2x(subps, Subps, Xmm, Xmm)                               // SSE
  ASMJIT_INST_2x(subps, Subps, Xmm, Mem)                               // SSE
  ASMJIT_INST_2x(subsd, Subsd, Xmm, Xmm)                               // SSE2
  ASMJIT_INST_2x(subsd, Subsd, Xmm, Mem)                               // SSE2
  ASMJIT_INST_2x(subss, Subss, Xmm, Xmm)                               // SSE
  ASMJIT_INST_2x(subss, Subss, Xmm, Mem)                               // SSE
  ASMJIT_INST_2x(ucomisd, Ucomisd, Xmm, Xmm)                           // SSE2
  ASMJIT_INST_2x(ucomisd, Ucomisd, Xmm, Mem)                           // SSE2
  ASMJIT_INST_2x(ucomiss, Ucomiss, Xmm, Xmm)                           // SSE
  ASMJIT_INST_2x(ucomiss, Ucomiss, Xmm, Mem)                           // SSE
  ASMJIT_INST_2x(unpckhpd, Unpckhpd, Xmm, Xmm)                         // SSE2
  ASMJIT_INST_2x(unpckhpd, Unpckhpd, Xmm, Mem)                         // SSE2
  ASMJIT_INST_2x(unpckhps, Unpckhps, Xmm, Xmm)                         // SSE
  ASMJIT_INST_2x(unpckhps, Unpckhps, Xmm, Mem)                         // SSE
  ASMJIT_INST_2x(unpcklpd, Unpcklpd, Xmm, Xmm)                         // SSE2
  ASMJIT_INST_2x(unpcklpd, Unpcklpd, Xmm, Mem)                         // SSE2
  ASMJIT_INST_2x(unpcklps, Unpcklps, Xmm, Xmm)                         // SSE
  ASMJIT_INST_2x(unpcklps, Unpcklps, Xmm, Mem)                         // SSE
  ASMJIT_INST_2x(xorpd, Xorpd, Xmm, Xmm)                               // SSE2
  ASMJIT_INST_2x(xorpd, Xorpd, Xmm, Mem)                               // SSE2
  ASMJIT_INST_2x(xorps, Xorps, Xmm, Xmm)                               // SSE
  ASMJIT_INST_2x(xorps, Xorps, Xmm, Mem)                               // SSE

  // -------------------------------------------------------------------------
  // [3DNOW & GEODE]
  // -------------------------------------------------------------------------

  ASMJIT_INST_2x(pavgusb, Pavgusb, Mm, Mm)                             // 3DNOW
  ASMJIT_INST_2x(pavgusb, Pavgusb, Mm, Mem)                            // 3DNOW
  ASMJIT_INST_2x(pf2id, Pf2id, Mm, Mm)                                 // 3DNOW
  ASMJIT_INST_2x(pf2id, Pf2id, Mm, Mem)                                // 3DNOW
  ASMJIT_INST_2x(pf2iw, Pf2iw, Mm, Mm)                                 // 3DNOW
  ASMJIT_INST_2x(pf2iw, Pf2iw, Mm, Mem)                                // 3DNOW
  ASMJIT_INST_2x(pfacc, Pfacc, Mm, Mm)                                 // 3DNOW
  ASMJIT_INST_2x(pfacc, Pfacc, Mm, Mem)                                // 3DNOW
  ASMJIT_INST_2x(pfadd, Pfadd, Mm, Mm)                                 // 3DNOW
  ASMJIT_INST_2x(pfadd, Pfadd, Mm, Mem)                                // 3DNOW
  ASMJIT_INST_2x(pfcmpeq, Pfcmpeq, Mm, Mm)                             // 3DNOW
  ASMJIT_INST_2x(pfcmpeq, Pfcmpeq, Mm, Mem)                            // 3DNOW
  ASMJIT_INST_2x(pfcmpge, Pfcmpge, Mm, Mm)                             // 3DNOW
  ASMJIT_INST_2x(pfcmpge, Pfcmpge, Mm, Mem)                            // 3DNOW
  ASMJIT_INST_2x(pfcmpgt, Pfcmpgt, Mm, Mm)                             // 3DNOW
  ASMJIT_INST_2x(pfcmpgt, Pfcmpgt, Mm, Mem)                            // 3DNOW
  ASMJIT_INST_2x(pfmax, Pfmax, Mm, Mm)                                 // 3DNOW
  ASMJIT_INST_2x(pfmax, Pfmax, Mm, Mem)                                // 3DNOW
  ASMJIT_INST_2x(pfmin, Pfmin, Mm, Mm)                                 // 3DNOW
  ASMJIT_INST_2x(pfmin, Pfmin, Mm, Mem)                                // 3DNOW
  ASMJIT_INST_2x(pfmul, Pfmul, Mm, Mm)                                 // 3DNOW
  ASMJIT_INST_2x(pfmul, Pfmul, Mm, Mem)                                // 3DNOW
  ASMJIT_INST_2x(pfnacc, Pfnacc, Mm, Mm)                               // 3DNOW
  ASMJIT_INST_2x(pfnacc, Pfnacc, Mm, Mem)                              // 3DNOW
  ASMJIT_INST_2x(pfpnacc, Pfpnacc, Mm, Mm)                             // 3DNOW
  ASMJIT_INST_2x(pfpnacc, Pfpnacc, Mm, Mem)                            // 3DNOW
  ASMJIT_INST_2x(pfrcp, Pfrcp, Mm, Mm)                                 // 3DNOW
  ASMJIT_INST_2x(pfrcp, Pfrcp, Mm, Mem)                                // 3DNOW
  ASMJIT_INST_2x(pfrcpit1, Pfrcpit1, Mm, Mm)                           // 3DNOW
  ASMJIT_INST_2x(pfrcpit1, Pfrcpit1, Mm, Mem)                          // 3DNOW
  ASMJIT_INST_2x(pfrcpit2, Pfrcpit2, Mm, Mm)                           // 3DNOW
  ASMJIT_INST_2x(pfrcpit2, Pfrcpit2, Mm, Mem)                          // 3DNOW
  ASMJIT_INST_2x(pfrcpv, Pfrcpv, Mm, Mm)                               // GEODE
  ASMJIT_INST_2x(pfrcpv, Pfrcpv, Mm, Mem)                              // GEODE
  ASMJIT_INST_2x(pfrsqit1, Pfrsqit1, Mm, Mm)                           // 3DNOW
  ASMJIT_INST_2x(pfrsqit1, Pfrsqit1, Mm, Mem)                          // 3DNOW
  ASMJIT_INST_2x(pfrsqrt, Pfrsqrt, Mm, Mm)                             // 3DNOW
  ASMJIT_INST_2x(pfrsqrt, Pfrsqrt, Mm, Mem)                            // 3DNOW
  ASMJIT_INST_2x(pfrsqrtv, Pfrsqrtv, Mm, Mm)                           // GEODE
  ASMJIT_INST_2x(pfrsqrtv, Pfrsqrtv, Mm, Mem)                          // GEODE
  ASMJIT_INST_2x(pfsub, Pfsub, Mm, Mm)                                 // 3DNOW
  ASMJIT_INST_2x(pfsub, Pfsub, Mm, Mem)                                // 3DNOW
  ASMJIT_INST_2x(pfsubr, Pfsubr, Mm, Mm)                               // 3DNOW
  ASMJIT_INST_2x(pfsubr, Pfsubr, Mm, Mem)                              // 3DNOW
  ASMJIT_INST_2x(pi2fd, Pi2fd, Mm, Mm)                                 // 3DNOW
  ASMJIT_INST_2x(pi2fd, Pi2fd, Mm, Mem)                                // 3DNOW
  ASMJIT_INST_2x(pi2fw, Pi2fw, Mm, Mm)                                 // 3DNOW
  ASMJIT_INST_2x(pi2fw, Pi2fw, Mm, Mem)                                // 3DNOW
  ASMJIT_INST_2x(pmulhrw, Pmulhrw, Mm, Mm)                             // 3DNOW
  ASMJIT_INST_2x(pmulhrw, Pmulhrw, Mm, Mem)                            // 3DNOW
  ASMJIT_INST_2x(pswapd, Pswapd, Mm, Mm)                               // 3DNOW
  ASMJIT_INST_2x(pswapd, Pswapd, Mm, Mem)                              // 3DNOW
  ASMJIT_INST_0x(femms, Femms)                                         // 3DNOW

  // --------------------------------------------------------------------------
  // [AESNI]
  // --------------------------------------------------------------------------

  ASMJIT_INST_2x(aesdec, Aesdec, Xmm, Xmm)                             // AESNI
  ASMJIT_INST_2x(aesdec, Aesdec, Xmm, Mem)                             // AESNI
  ASMJIT_INST_2x(aesdeclast, Aesdeclast, Xmm, Xmm)                     // AESNI
  ASMJIT_INST_2x(aesdeclast, Aesdeclast, Xmm, Mem)                     // AESNI
  ASMJIT_INST_2x(aesenc, Aesenc, Xmm, Xmm)                             // AESNI
  ASMJIT_INST_2x(aesenc, Aesenc, Xmm, Mem)                             // AESNI
  ASMJIT_INST_2x(aesenclast, Aesenclast, Xmm, Xmm)                     // AESNI
  ASMJIT_INST_2x(aesenclast, Aesenclast, Xmm, Mem)                     // AESNI
  ASMJIT_INST_2x(aesimc, Aesimc, Xmm, Xmm)                             // AESNI
  ASMJIT_INST_2x(aesimc, Aesimc, Xmm, Mem)                             // AESNI
  ASMJIT_INST_3i(aeskeygenassist, Aeskeygenassist, Xmm, Xmm, Imm)      // AESNI
  ASMJIT_INST_3i(aeskeygenassist, Aeskeygenassist, Xmm, Mem, Imm)      // AESNI

  // --------------------------------------------------------------------------
  // [SHA]
  // --------------------------------------------------------------------------

  ASMJIT_INST_2x(sha1msg1, Sha1msg1, Xmm, Xmm)                         // SHA
  ASMJIT_INST_2x(sha1msg1, Sha1msg1, Xmm, Mem)                         // SHA
  ASMJIT_INST_2x(sha1msg2, Sha1msg2, Xmm, Xmm)                         // SHA
  ASMJIT_INST_2x(sha1msg2, Sha1msg2, Xmm, Mem)                         // SHA
  ASMJIT_INST_2x(sha1nexte, Sha1nexte, Xmm, Xmm)                       // SHA
  ASMJIT_INST_2x(sha1nexte, Sha1nexte, Xmm, Mem)                       // SHA
  ASMJIT_INST_3i(sha1rnds4, Sha1rnds4, Xmm, Xmm, Imm)                  // SHA
  ASMJIT_INST_3i(sha1rnds4, Sha1rnds4, Xmm, Mem, Imm)                  // SHA
  ASMJIT_INST_2x(sha256msg1, Sha256msg1, Xmm, Xmm)                     // SHA
  ASMJIT_INST_2x(sha256msg1, Sha256msg1, Xmm, Mem)                     // SHA
  ASMJIT_INST_2x(sha256msg2, Sha256msg2, Xmm, Xmm)                     // SHA
  ASMJIT_INST_2x(sha256msg2, Sha256msg2, Xmm, Mem)                     // SHA
  ASMJIT_INST_3x(sha256rnds2, Sha256rnds2, Xmm, Xmm, XMM0)             // SHA [EXPLICIT]
  ASMJIT_INST_3x(sha256rnds2, Sha256rnds2, Xmm, Mem, XMM0)             // SHA [EXPLICIT]

  // --------------------------------------------------------------------------
  // [AVX...AVX512]
  // --------------------------------------------------------------------------

  ASMJIT_INST_3x(kaddb, Kaddb, KReg, KReg, KReg)                       // AVX512_DQ
  ASMJIT_INST_3x(kaddd, Kaddd, KReg, KReg, KReg)                       // AVX512_BW
  ASMJIT_INST_3x(kaddq, Kaddq, KReg, KReg, KReg)                       // AVX512_BW
  ASMJIT_INST_3x(kaddw, Kaddw, KReg, KReg, KReg)                       // AVX512_DQ
  ASMJIT_INST_3x(kandb, Kandb, KReg, KReg, KReg)                       // AVX512_DQ
  ASMJIT_INST_3x(kandd, Kandd, KReg, KReg, KReg)                       // AVX512_BW
  ASMJIT_INST_3x(kandnb, Kandnb, KReg, KReg, KReg)                     // AVX512_DQ
  ASMJIT_INST_3x(kandnd, Kandnd, KReg, KReg, KReg)                     // AVX512_BW
  ASMJIT_INST_3x(kandnq, Kandnq, KReg, KReg, KReg)                     // AVX512_BW
  ASMJIT_INST_3x(kandnw, Kandnw, KReg, KReg, KReg)                     // AVX512_F
  ASMJIT_INST_3x(kandq, Kandq, KReg, KReg, KReg)                       // AVX512_BW
  ASMJIT_INST_3x(kandw, Kandw, KReg, KReg, KReg)                       // AVX512_F
  ASMJIT_INST_2x(kmovb, Kmovb, KReg, KReg)                             // AVX512_DQ
  ASMJIT_INST_2x(kmovb, Kmovb, KReg, Mem)                              // AVX512_DQ
  ASMJIT_INST_2x(kmovb, Kmovb, KReg, Gp)                               // AVX512_DQ
  ASMJIT_INST_2x(kmovb, Kmovb, Mem, KReg)                              // AVX512_DQ
  ASMJIT_INST_2x(kmovb, Kmovb, Gp, KReg)                               // AVX512_DQ
  ASMJIT_INST_2x(kmovd, Kmovd, KReg, KReg)                             // AVX512_BW
  ASMJIT_INST_2x(kmovd, Kmovd, KReg, Mem)                              // AVX512_BW
  ASMJIT_INST_2x(kmovd, Kmovd, KReg, Gp)                               // AVX512_BW
  ASMJIT_INST_2x(kmovd, Kmovd, Mem, KReg)                              // AVX512_BW
  ASMJIT_INST_2x(kmovd, Kmovd, Gp, KReg)                               // AVX512_BW
  ASMJIT_INST_2x(kmovq, Kmovq, KReg, KReg)                             // AVX512_BW
  ASMJIT_INST_2x(kmovq, Kmovq, KReg, Mem)                              // AVX512_BW
  ASMJIT_INST_2x(kmovq, Kmovq, KReg, Gp)                               // AVX512_BW
  ASMJIT_INST_2x(kmovq, Kmovq, Mem, KReg)                              // AVX512_BW
  ASMJIT_INST_2x(kmovq, Kmovq, Gp, KReg)                               // AVX512_BW
  ASMJIT_INST_2x(kmovw, Kmovw, KReg, KReg)                             // AVX512_F
  ASMJIT_INST_2x(kmovw, Kmovw, KReg, Mem)                              // AVX512_F
  ASMJIT_INST_2x(kmovw, Kmovw, KReg, Gp)                               // AVX512_F
  ASMJIT_INST_2x(kmovw, Kmovw, Mem, KReg)                              // AVX512_F
  ASMJIT_INST_2x(kmovw, Kmovw, Gp, KReg)                               // AVX512_F
  ASMJIT_INST_2x(knotb, Knotb, KReg, KReg)                             // AVX512_DQ
  ASMJIT_INST_2x(knotd, Knotd, KReg, KReg)                             // AVX512_BW
  ASMJIT_INST_2x(knotq, Knotq, KReg, KReg)                             // AVX512_BW
  ASMJIT_INST_2x(knotw, Knotw, KReg, KReg)                             // AVX512_F
  ASMJIT_INST_3x(korb, Korb, KReg, KReg, KReg)                         // AVX512_DQ
  ASMJIT_INST_3x(kord, Kord, KReg, KReg, KReg)                         // AVX512_BW
  ASMJIT_INST_3x(korq, Korq, KReg, KReg, KReg)                         // AVX512_BW
  ASMJIT_INST_2x(kortestb, Kortestb, KReg, KReg)                       // AVX512_DQ
  ASMJIT_INST_2x(kortestd, Kortestd, KReg, KReg)                       // AVX512_BW
  ASMJIT_INST_2x(kortestq, Kortestq, KReg, KReg)                       // AVX512_BW
  ASMJIT_INST_2x(kortestw, Kortestw, KReg, KReg)                       // AVX512_F
  ASMJIT_INST_3x(korw, Korw, KReg, KReg, KReg)                         // AVX512_F
  ASMJIT_INST_3i(kshiftlb, Kshiftlb, KReg, KReg, Imm)                  // AVX512_DQ
  ASMJIT_INST_3i(kshiftld, Kshiftld, KReg, KReg, Imm)                  // AVX512_BW
  ASMJIT_INST_3i(kshiftlq, Kshiftlq, KReg, KReg, Imm)                  // AVX512_BW
  ASMJIT_INST_3i(kshiftlw, Kshiftlw, KReg, KReg, Imm)                  // AVX512_F
  ASMJIT_INST_3i(kshiftrb, Kshiftrb, KReg, KReg, Imm)                  // AVX512_DQ
  ASMJIT_INST_3i(kshiftrd, Kshiftrd, KReg, KReg, Imm)                  // AVX512_BW
  ASMJIT_INST_3i(kshiftrq, Kshiftrq, KReg, KReg, Imm)                  // AVX512_BW
  ASMJIT_INST_3i(kshiftrw, Kshiftrw, KReg, KReg, Imm)                  // AVX512_F
  ASMJIT_INST_2x(ktestb, Ktestb, KReg, KReg)                           // AVX512_DQ
  ASMJIT_INST_2x(ktestd, Ktestd, KReg, KReg)                           // AVX512_BW
  ASMJIT_INST_2x(ktestq, Ktestq, KReg, KReg)                           // AVX512_BW
  ASMJIT_INST_2x(ktestw, Ktestw, KReg, KReg)                           // AVX512_DQ
  ASMJIT_INST_3x(kunpckbw, Kunpckbw, KReg, KReg, KReg)                 // AVX512_F
  ASMJIT_INST_3x(kunpckdq, Kunpckdq, KReg, KReg, KReg)                 // AVX512_BW
  ASMJIT_INST_3x(kunpckwd, Kunpckwd, KReg, KReg, KReg)                 // AVX512_BW
  ASMJIT_INST_3x(kxnorb, Kxnorb, KReg, KReg, KReg)                     // AVX512_DQ
  ASMJIT_INST_3x(kxnord, Kxnord, KReg, KReg, KReg)                     // AVX512_BW
  ASMJIT_INST_3x(kxnorq, Kxnorq, KReg, KReg, KReg)                     // AVX512_BW
  ASMJIT_INST_3x(kxnorw, Kxnorw, KReg, KReg, KReg)                     // AVX512_F
  ASMJIT_INST_3x(kxorb, Kxorb, KReg, KReg, KReg)                       // AVX512_DQ
  ASMJIT_INST_3x(kxord, Kxord, KReg, KReg, KReg)                       // AVX512_BW
  ASMJIT_INST_3x(kxorq, Kxorq, KReg, KReg, KReg)                       // AVX512_BW
  ASMJIT_INST_3x(kxorw, Kxorw, KReg, KReg, KReg)                       // AVX512_F
  ASMJIT_INST_6x(v4fmaddps, V4fmaddps, Zmm, Zmm, Zmm, Zmm, Zmm, Mem)   // AVX512_4FMAPS{kz}
  ASMJIT_INST_6x(v4fmaddss, V4fmaddss, Xmm, Xmm, Xmm, Xmm, Xmm, Mem)   // AVX512_4FMAPS{kz}
  ASMJIT_INST_6x(v4fnmaddps, V4fnmaddps, Zmm, Zmm, Zmm, Zmm, Zmm, Mem) // AVX512_4FMAPS{kz}
  ASMJIT_INST_6x(v4fnmaddss, V4fnmaddss, Xmm, Xmm, Xmm, Xmm, Xmm, Mem) // AVX512_4FMAPS{kz}
  ASMJIT_INST_3x(vaddpd, Vaddpd, Xmm, Xmm, Xmm)                        // AVX  AVX512_F{kz|b64}-VL
  ASMJIT_INST_3x(vaddpd, Vaddpd, Xmm, Xmm, Mem)                        // AVX  AVX512_F{kz|b64}-VL
  ASMJIT_INST_3x(vaddpd, Vaddpd, Ymm, Ymm, Ymm)                        // AVX  AVX512_F{kz|b64}-VL
  ASMJIT_INST_3x(vaddpd, Vaddpd, Ymm, Ymm, Mem)                        // AVX  AVX512_F{kz|b64}-VL
  ASMJIT_INST_3x(vaddpd, Vaddpd, Zmm, Zmm, Zmm)                        //      AVX512_F{kz|er|b64}
  ASMJIT_INST_3x(vaddpd, Vaddpd, Zmm, Zmm, Mem)                        //      AVX512_F{kz|er|b64}
  ASMJIT_INST_3x(vaddps, Vaddps, Xmm, Xmm, Xmm)                        // AVX  AVX512_F{kz|b32}-VL
  ASMJIT_INST_3x(vaddps, Vaddps, Xmm, Xmm, Mem)                        // AVX  AVX512_F{kz|b32}-VL
  ASMJIT_INST_3x(vaddps, Vaddps, Ymm, Ymm, Ymm)                        // AVX  AVX512_F{kz|b32}-VL
  ASMJIT_INST_3x(vaddps, Vaddps, Ymm, Ymm, Mem)                        // AVX  AVX512_F{kz|b32}-VL
  ASMJIT_INST_3x(vaddps, Vaddps, Zmm, Zmm, Zmm)                        //      AVX512_F{kz|er|b32}
  ASMJIT_INST_3x(vaddps, Vaddps, Zmm, Zmm, Mem)                        //      AVX512_F{kz|er|b32}
  ASMJIT_INST_3x(vaddsd, Vaddsd, Xmm, Xmm, Xmm)                        // AVX  AVX512_F{kz|er}
  ASMJIT_INST_3x(vaddsd, Vaddsd, Xmm, Xmm, Mem)                        // AVX  AVX512_F{kz|er}
  ASMJIT_INST_3x(vaddss, Vaddss, Xmm, Xmm, Xmm)                        // AVX  AVX512_F{kz|er}
  ASMJIT_INST_3x(vaddss, Vaddss, Xmm, Xmm, Mem)                        // AVX  AVX512_F{kz|er}
  ASMJIT_INST_3x(vaddsubpd, Vaddsubpd, Xmm, Xmm, Xmm)                  // AVX
  ASMJIT_INST_3x(vaddsubpd, Vaddsubpd, Xmm, Xmm, Mem)                  // AVX
  ASMJIT_INST_3x(vaddsubpd, Vaddsubpd, Ymm, Ymm, Ymm)                  // AVX
  ASMJIT_INST_3x(vaddsubpd, Vaddsubpd, Ymm, Ymm, Mem)                  // AVX
  ASMJIT_INST_3x(vaddsubps, Vaddsubps, Xmm, Xmm, Xmm)                  // AVX
  ASMJIT_INST_3x(vaddsubps, Vaddsubps, Xmm, Xmm, Mem)                  // AVX
  ASMJIT_INST_3x(vaddsubps, Vaddsubps, Ymm, Ymm, Ymm)                  // AVX
  ASMJIT_INST_3x(vaddsubps, Vaddsubps, Ymm, Ymm, Mem)                  // AVX
  ASMJIT_INST_3x(vaesdec, Vaesdec, Xmm, Xmm, Xmm)                      // AVX
  ASMJIT_INST_3x(vaesdec, Vaesdec, Xmm, Xmm, Mem)                      // AVX
  ASMJIT_INST_3x(vaesdec, Vaesdec, Ymm, Ymm, Ymm)                      // VAES AVX512_VL
  ASMJIT_INST_3x(vaesdec, Vaesdec, Ymm, Ymm, Mem)                      // VAES AVX512_VL
  ASMJIT_INST_3x(vaesdec, Vaesdec, Zmm, Zmm, Zmm)                      // VAES
  ASMJIT_INST_3x(vaesdec, Vaesdec, Zmm, Zmm, Mem)                      // VAES
  ASMJIT_INST_3x(vaesdeclast, Vaesdeclast, Xmm, Xmm, Xmm)              // AVX
  ASMJIT_INST_3x(vaesdeclast, Vaesdeclast, Xmm, Xmm, Mem)              // AVX
  ASMJIT_INST_3x(vaesdeclast, Vaesdeclast, Ymm, Ymm, Ymm)              // VAES AVX512_VL
  ASMJIT_INST_3x(vaesdeclast, Vaesdeclast, Ymm, Ymm, Mem)              // VAES AVX512_VL
  ASMJIT_INST_3x(vaesdeclast, Vaesdeclast, Zmm, Zmm, Zmm)              // VAES
  ASMJIT_INST_3x(vaesdeclast, Vaesdeclast, Zmm, Zmm, Mem)              // VAES
  ASMJIT_INST_3x(vaesenc, Vaesenc, Xmm, Xmm, Xmm)                      // AVX
  ASMJIT_INST_3x(vaesenc, Vaesenc, Xmm, Xmm, Mem)                      // AVX
  ASMJIT_INST_3x(vaesenc, Vaesenc, Ymm, Ymm, Ymm)                      // VAES AVX512_VL
  ASMJIT_INST_3x(vaesenc, Vaesenc, Ymm, Ymm, Mem)                      // VAES AVX512_VL
  ASMJIT_INST_3x(vaesenc, Vaesenc, Zmm, Zmm, Zmm)                      // VAES
  ASMJIT_INST_3x(vaesenc, Vaesenc, Zmm, Zmm, Mem)                      // VAES
  ASMJIT_INST_3x(vaesenclast, Vaesenclast, Xmm, Xmm, Xmm)              // AVX
  ASMJIT_INST_3x(vaesenclast, Vaesenclast, Xmm, Xmm, Mem)              // AVX
  ASMJIT_INST_3x(vaesenclast, Vaesenclast, Ymm, Ymm, Ymm)              // VAES AVX512_VL
  ASMJIT_INST_3x(vaesenclast, Vaesenclast, Ymm, Ymm, Mem)              // VAES AVX512_VL
  ASMJIT_INST_3x(vaesenclast, Vaesenclast, Zmm, Zmm, Zmm)              // VAES
  ASMJIT_INST_3x(vaesenclast, Vaesenclast, Zmm, Zmm, Mem)              // VAES
  ASMJIT_INST_2x(vaesimc, Vaesimc, Xmm, Xmm)                           // AVX
  ASMJIT_INST_2x(vaesimc, Vaesimc, Xmm, Mem)                           // AVX
  ASMJIT_INST_3i(vaeskeygenassist, Vaeskeygenassist, Xmm, Xmm, Imm)    // AVX
  ASMJIT_INST_3i(vaeskeygenassist, Vaeskeygenassist, Xmm, Mem, Imm)    // AVX
  ASMJIT_INST_4i(valignd, Valignd, Xmm, Xmm, Xmm, Imm)                 //      AVX512_F{kz|b32}-VL
  ASMJIT_INST_4i(valignd, Valignd, Xmm, Xmm, Mem, Imm)                 //      AVX512_F{kz|b32}-VL
  ASMJIT_INST_4i(valignd, Valignd, Ymm, Ymm, Ymm, Imm)                 //      AVX512_F{kz|b32}-VL
  ASMJIT_INST_4i(valignd, Valignd, Ymm, Ymm, Mem, Imm)                 //      AVX512_F{kz|b32}-VL
  ASMJIT_INST_4i(valignd, Valignd, Zmm, Zmm, Zmm, Imm)                 //      AVX512_F{kz|b32}
  ASMJIT_INST_4i(valignd, Valignd, Zmm, Zmm, Mem, Imm)                 //      AVX512_F{kz|b32}
  ASMJIT_INST_4i(valignq, Valignq, Xmm, Xmm, Xmm, Imm)                 //      AVX512_F{kz|b64}-VL
  ASMJIT_INST_4i(valignq, Valignq, Xmm, Xmm, Mem, Imm)                 //      AVX512_F{kz|b64}-VL
  ASMJIT_INST_4i(valignq, Valignq, Ymm, Ymm, Ymm, Imm)                 //      AVX512_F{kz|b64}-VL
  ASMJIT_INST_4i(valignq, Valignq, Ymm, Ymm, Mem, Imm)                 //      AVX512_F{kz|b64}-VL
  ASMJIT_INST_4i(valignq, Valignq, Zmm, Zmm, Zmm, Imm)                 //      AVX512_F{kz|b64}
  ASMJIT_INST_4i(valignq, Valignq, Zmm, Zmm, Mem, Imm)                 //      AVX512_F{kz|b64}
  ASMJIT_INST_3x(vandnpd, Vandnpd, Xmm, Xmm, Xmm)                      // AVX  AVX512_DQ{kz|b64}-VL
  ASMJIT_INST_3x(vandnpd, Vandnpd, Xmm, Xmm, Mem)                      // AVX  AVX512_DQ{kz|b64}-VL
  ASMJIT_INST_3x(vandnpd, Vandnpd, Ymm, Ymm, Ymm)                      // AVX  AVX512_DQ{kz|b64}-VL
  ASMJIT_INST_3x(vandnpd, Vandnpd, Ymm, Ymm, Mem)                      // AVX  AVX512_DQ{kz|b64}-VL
  ASMJIT_INST_3x(vandnpd, Vandnpd, Zmm, Zmm, Zmm)                      //      AVX512_DQ{kz|b64}
  ASMJIT_INST_3x(vandnpd, Vandnpd, Zmm, Zmm, Mem)                      //      AVX512_DQ{kz|b64}
  ASMJIT_INST_3x(vandnps, Vandnps, Xmm, Xmm, Xmm)                      // AVX  AVX512_DQ{kz|b32}-VL
  ASMJIT_INST_3x(vandnps, Vandnps, Xmm, Xmm, Mem)                      // AVX  AVX512_DQ{kz|b32}-VL
  ASMJIT_INST_3x(vandnps, Vandnps, Ymm, Ymm, Ymm)                      // AVX  AVX512_DQ{kz|b32}-VL
  ASMJIT_INST_3x(vandnps, Vandnps, Ymm, Ymm, Mem)                      // AVX  AVX512_DQ{kz|b32}-VL
  ASMJIT_INST_3x(vandnps, Vandnps, Zmm, Zmm, Zmm)                      //      AVX512_DQ{kz|b32}
  ASMJIT_INST_3x(vandnps, Vandnps, Zmm, Zmm, Mem)                      //      AVX512_DQ{kz|b32}
  ASMJIT_INST_3x(vandpd, Vandpd, Xmm, Xmm, Xmm)                        // AVX  AVX512_DQ{kz|b64}-VL
  ASMJIT_INST_3x(vandpd, Vandpd, Xmm, Xmm, Mem)                        // AVX  AVX512_DQ{kz|b64}-VL
  ASMJIT_INST_3x(vandpd, Vandpd, Ymm, Ymm, Ymm)                        // AVX  AVX512_DQ{kz|b64}-VL
  ASMJIT_INST_3x(vandpd, Vandpd, Ymm, Ymm, Mem)                        // AVX  AVX512_DQ{kz|b64}-VL
  ASMJIT_INST_3x(vandpd, Vandpd, Zmm, Zmm, Zmm)                        //      AVX512_DQ{kz|b64}
  ASMJIT_INST_3x(vandpd, Vandpd, Zmm, Zmm, Mem)                        //      AVX512_DQ{kz|b64}
  ASMJIT_INST_3x(vandps, Vandps, Xmm, Xmm, Xmm)                        // AVX  AVX512_DQ{kz|b32}-VL
  ASMJIT_INST_3x(vandps, Vandps, Xmm, Xmm, Mem)                        // AVX  AVX512_DQ{kz|b32}-VL
  ASMJIT_INST_3x(vandps, Vandps, Ymm, Ymm, Ymm)                        // AVX  AVX512_DQ{kz|b32}-VL
  ASMJIT_INST_3x(vandps, Vandps, Ymm, Ymm, Mem)                        // AVX  AVX512_DQ{kz|b32}-VL
  ASMJIT_INST_3x(vandps, Vandps, Zmm, Zmm, Zmm)                        //      AVX512_DQ{kz|b32}
  ASMJIT_INST_3x(vandps, Vandps, Zmm, Zmm, Mem)                        //      AVX512_DQ{kz|b32}
  ASMJIT_INST_3x(vblendmb, Vblendmb, Xmm, Xmm, Xmm)                    //      AVX512_BW{kz}-VL
  ASMJIT_INST_3x(vblendmb, Vblendmb, Xmm, Xmm, Mem)                    //      AVX512_BW{kz}-VL
  ASMJIT_INST_3x(vblendmb, Vblendmb, Ymm, Ymm, Ymm)                    //      AVX512_BW{kz}-VL
  ASMJIT_INST_3x(vblendmb, Vblendmb, Ymm, Ymm, Mem)                    //      AVX512_BW{kz}-VL
  ASMJIT_INST_3x(vblendmb, Vblendmb, Zmm, Zmm, Zmm)                    //      AVX512_BW{kz}
  ASMJIT_INST_3x(vblendmb, Vblendmb, Zmm, Zmm, Mem)                    //      AVX512_BW{kz}
  ASMJIT_INST_3x(vblendmd, Vblendmd, Xmm, Xmm, Xmm)                    //      AVX512_F{kz|b32}-VL
  ASMJIT_INST_3x(vblendmd, Vblendmd, Xmm, Xmm, Mem)                    //      AVX512_F{kz|b32}-VL
  ASMJIT_INST_3x(vblendmd, Vblendmd, Ymm, Ymm, Ymm)                    //      AVX512_F{kz|b32}-VL
  ASMJIT_INST_3x(vblendmd, Vblendmd, Ymm, Ymm, Mem)                    //      AVX512_F{kz|b32}-VL
  ASMJIT_INST_3x(vblendmd, Vblendmd, Zmm, Zmm, Zmm)                    //      AVX512_F{kz|b32}
  ASMJIT_INST_3x(vblendmd, Vblendmd, Zmm, Zmm, Mem)                    //      AVX512_F{kz|b32}
  ASMJIT_INST_3x(vblendmpd, Vblendmpd, Xmm, Xmm, Xmm)                  //      AVX512_F{kz|b64}-VL
  ASMJIT_INST_3x(vblendmpd, Vblendmpd, Xmm, Xmm, Mem)                  //      AVX512_F{kz|b64}-VL
  ASMJIT_INST_3x(vblendmpd, Vblendmpd, Ymm, Ymm, Ymm)                  //      AVX512_F{kz|b64}-VL
  ASMJIT_INST_3x(vblendmpd, Vblendmpd, Ymm, Ymm, Mem)                  //      AVX512_F{kz|b64}-VL
  ASMJIT_INST_3x(vblendmpd, Vblendmpd, Zmm, Zmm, Zmm)                  //      AVX512_F{kz|b64}
  ASMJIT_INST_3x(vblendmpd, Vblendmpd, Zmm, Zmm, Mem)                  //      AVX512_F{kz|b64}
  ASMJIT_INST_3x(vblendmps, Vblendmps, Xmm, Xmm, Xmm)                  //      AVX512_F{kz|b32}-VL
  ASMJIT_INST_3x(vblendmps, Vblendmps, Xmm, Xmm, Mem)                  //      AVX512_F{kz|b32}-VL
  ASMJIT_INST_3x(vblendmps, Vblendmps, Ymm, Ymm, Ymm)                  //      AVX512_F{kz|b32}-VL
  ASMJIT_INST_3x(vblendmps, Vblendmps, Ymm, Ymm, Mem)                  //      AVX512_F{kz|b32}-VL
  ASMJIT_INST_3x(vblendmps, Vblendmps, Zmm, Zmm, Zmm)                  //      AVX512_F{kz|b32}
  ASMJIT_INST_3x(vblendmps, Vblendmps, Zmm, Zmm, Mem)                  //      AVX512_F{kz|b32}
  ASMJIT_INST_3x(vblendmq, Vblendmq, Xmm, Xmm, Xmm)                    //      AVX512_F{kz|b64}-VL
  ASMJIT_INST_3x(vblendmq, Vblendmq, Xmm, Xmm, Mem)                    //      AVX512_F{kz|b64}-VL
  ASMJIT_INST_3x(vblendmq, Vblendmq, Ymm, Ymm, Ymm)                    //      AVX512_F{kz|b64}-VL
  ASMJIT_INST_3x(vblendmq, Vblendmq, Ymm, Ymm, Mem)                    //      AVX512_F{kz|b64}-VL
  ASMJIT_INST_3x(vblendmq, Vblendmq, Zmm, Zmm, Zmm)                    //      AVX512_F{kz|b64}
  ASMJIT_INST_3x(vblendmq, Vblendmq, Zmm, Zmm, Mem)                    //      AVX512_F{kz|b64}
  ASMJIT_INST_3x(vblendmw, Vblendmw, Xmm, Xmm, Xmm)                    //      AVX512_BW{kz}-VL
  ASMJIT_INST_3x(vblendmw, Vblendmw, Xmm, Xmm, Mem)                    //      AVX512_BW{kz}-VL
  ASMJIT_INST_3x(vblendmw, Vblendmw, Ymm, Ymm, Ymm)                    //      AVX512_BW{kz}-VL
  ASMJIT_INST_3x(vblendmw, Vblendmw, Ymm, Ymm, Mem)                    //      AVX512_BW{kz}-VL
  ASMJIT_INST_3x(vblendmw, Vblendmw, Zmm, Zmm, Zmm)                    //      AVX512_BW{kz}
  ASMJIT_INST_3x(vblendmw, Vblendmw, Zmm, Zmm, Mem)                    //      AVX512_BW{kz}
  ASMJIT_INST_4i(vblendpd, Vblendpd, Xmm, Xmm, Xmm, Imm)               // AVX
  ASMJIT_INST_4i(vblendpd, Vblendpd, Xmm, Xmm, Mem, Imm)               // AVX
  ASMJIT_INST_4i(vblendpd, Vblendpd, Ymm, Ymm, Ymm, Imm)               // AVX
  ASMJIT_INST_4i(vblendpd, Vblendpd, Ymm, Ymm, Mem, Imm)               // AVX
  ASMJIT_INST_4i(vblendps, Vblendps, Xmm, Xmm, Xmm, Imm)               // AVX
  ASMJIT_INST_4i(vblendps, Vblendps, Xmm, Xmm, Mem, Imm)               // AVX
  ASMJIT_INST_4i(vblendps, Vblendps, Ymm, Ymm, Ymm, Imm)               // AVX
  ASMJIT_INST_4i(vblendps, Vblendps, Ymm, Ymm, Mem, Imm)               // AVX
  ASMJIT_INST_4x(vblendvpd, Vblendvpd, Xmm, Xmm, Xmm, Xmm)             // AVX
  ASMJIT_INST_4x(vblendvpd, Vblendvpd, Xmm, Xmm, Mem, Xmm)             // AVX
  ASMJIT_INST_4x(vblendvpd, Vblendvpd, Ymm, Ymm, Ymm, Ymm)             // AVX
  ASMJIT_INST_4x(vblendvpd, Vblendvpd, Ymm, Ymm, Mem, Ymm)             // AVX
  ASMJIT_INST_4x(vblendvps, Vblendvps, Xmm, Xmm, Xmm, Xmm)             // AVX
  ASMJIT_INST_4x(vblendvps, Vblendvps, Xmm, Xmm, Mem, Xmm)             // AVX
  ASMJIT_INST_4x(vblendvps, Vblendvps, Ymm, Ymm, Ymm, Ymm)             // AVX
  ASMJIT_INST_4x(vblendvps, Vblendvps, Ymm, Ymm, Mem, Ymm)             // AVX
  ASMJIT_INST_2x(vbroadcastf128, Vbroadcastf128, Ymm, Mem)             // AVX
  ASMJIT_INST_2x(vbroadcastf32x2, Vbroadcastf32x2, Ymm, Xmm)           //      AVX512_DQ{kz}-VL
  ASMJIT_INST_2x(vbroadcastf32x2, Vbroadcastf32x2, Ymm, Mem)           //      AVX512_DQ{kz}-VL
  ASMJIT_INST_2x(vbroadcastf32x2, Vbroadcastf32x2, Zmm, Xmm)           //      AVX512_DQ{kz}
  ASMJIT_INST_2x(vbroadcastf32x2, Vbroadcastf32x2, Zmm, Mem)           //      AVX512_DQ{kz}
  ASMJIT_INST_2x(vbroadcastf32x4, Vbroadcastf32x4, Ymm, Mem)           //      AVX512_F{kz}
  ASMJIT_INST_2x(vbroadcastf32x4, Vbroadcastf32x4, Zmm, Mem)           //      AVX512_F{kz}
  ASMJIT_INST_2x(vbroadcastf32x8, Vbroadcastf32x8, Zmm, Mem)           //      AVX512_DQ{kz}
  ASMJIT_INST_2x(vbroadcastf64x2, Vbroadcastf64x2, Ymm, Mem)           //      AVX512_DQ{kz}-VL
  ASMJIT_INST_2x(vbroadcastf64x2, Vbroadcastf64x2, Zmm, Mem)           //      AVX512_DQ{kz}
  ASMJIT_INST_2x(vbroadcastf64x4, Vbroadcastf64x4, Zmm, Mem)           //      AVX512_F{kz}
  ASMJIT_INST_2x(vbroadcasti128, Vbroadcasti128, Ymm, Mem)             // AVX2
  ASMJIT_INST_2x(vbroadcasti32x2, Vbroadcasti32x2, Xmm, Xmm)           //      AVX512_DQ{kz}-VL
  ASMJIT_INST_2x(vbroadcasti32x2, Vbroadcasti32x2, Xmm, Mem)           //      AVX512_DQ{kz}-VL
  ASMJIT_INST_2x(vbroadcasti32x2, Vbroadcasti32x2, Ymm, Xmm)           //      AVX512_DQ{kz}-VL
  ASMJIT_INST_2x(vbroadcasti32x2, Vbroadcasti32x2, Ymm, Mem)           //      AVX512_DQ{kz}-VL
  ASMJIT_INST_2x(vbroadcasti32x2, Vbroadcasti32x2, Zmm, Xmm)           //      AVX512_DQ{kz}
  ASMJIT_INST_2x(vbroadcasti32x2, Vbroadcasti32x2, Zmm, Mem)           //      AVX512_DQ{kz}
  ASMJIT_INST_2x(vbroadcasti32x4, Vbroadcasti32x4, Ymm, Mem)           //      AVX512_F{kz}-VL
  ASMJIT_INST_2x(vbroadcasti32x4, Vbroadcasti32x4, Zmm, Mem)           //      AVX512_F{kz}
  ASMJIT_INST_2x(vbroadcasti32x8, Vbroadcasti32x8, Zmm, Mem)           //      AVX512_DQ{kz}
  ASMJIT_INST_2x(vbroadcasti64x2, Vbroadcasti64x2, Ymm, Xmm)           //      AVX512_DQ{kz}-VL
  ASMJIT_INST_2x(vbroadcasti64x2, Vbroadcasti64x2, Ymm, Mem)           //      AVX512_DQ{kz}-VL
  ASMJIT_INST_2x(vbroadcasti64x2, Vbroadcasti64x2, Zmm, Xmm)           //      AVX512_DQ{kz}
  ASMJIT_INST_2x(vbroadcasti64x2, Vbroadcasti64x2, Zmm, Mem)           //      AVX512_DQ{kz}
  ASMJIT_INST_2x(vbroadcasti64x4, Vbroadcasti64x4, Zmm, Xmm)           //      AVX512_F{kz}
  ASMJIT_INST_2x(vbroadcasti64x4, Vbroadcasti64x4, Zmm, Mem)           //      AVX512_F{kz}
  ASMJIT_INST_2x(vbroadcastsd, Vbroadcastsd, Ymm, Mem)                 // AVX  AVX512_F{kz}-VL
  ASMJIT_INST_2x(vbroadcastsd, Vbroadcastsd, Ymm, Xmm)                 // AVX2 AVX512_F{kz}-VL
  ASMJIT_INST_2x(vbroadcastsd, Vbroadcastsd, Zmm, Xmm)                 //      AVX512_F{kz}
  ASMJIT_INST_2x(vbroadcastsd, Vbroadcastsd, Zmm, Mem)                 //      AVX512_F{kz}
  ASMJIT_INST_2x(vbroadcastss, Vbroadcastss, Xmm, Mem)                 // AVX  AVX512_F{kz}-VL
  ASMJIT_INST_2x(vbroadcastss, Vbroadcastss, Xmm, Xmm)                 // AVX2 AVX512_F{kz}-VL
  ASMJIT_INST_2x(vbroadcastss, Vbroadcastss, Ymm, Mem)                 // AVX  AVX512_F{kz}
  ASMJIT_INST_2x(vbroadcastss, Vbroadcastss, Ymm, Xmm)                 // AVX2 AVX512_F{kz}
  ASMJIT_INST_2x(vbroadcastss, Vbroadcastss, Zmm, Xmm)                 //      AVX512_F{kz}-VL
  ASMJIT_INST_2x(vbroadcastss, Vbroadcastss, Zmm, Mem)                 //      AVX512_F{kz}-VL
  ASMJIT_INST_4i(vcmppd, Vcmppd, Xmm, Xmm, Xmm, Imm)                   // AVX
  ASMJIT_INST_4i(vcmppd, Vcmppd, Xmm, Xmm, Mem, Imm)                   // AVX
  ASMJIT_INST_4i(vcmppd, Vcmppd, Ymm, Ymm, Ymm, Imm)                   // AVX
  ASMJIT_INST_4i(vcmppd, Vcmppd, Ymm, Ymm, Mem, Imm)                   // AVX
  ASMJIT_INST_4i(vcmppd, Vcmppd, KReg, Xmm, Xmm, Imm)                  //      AVX512_F{kz|b64}-VL
  ASMJIT_INST_4i(vcmppd, Vcmppd, KReg, Xmm, Mem, Imm)                  //      AVX512_F{kz|b64}-VL
  ASMJIT_INST_4i(vcmppd, Vcmppd, KReg, Ymm, Ymm, Imm)                  //      AVX512_F{kz|b64}-VL
  ASMJIT_INST_4i(vcmppd, Vcmppd, KReg, Ymm, Mem, Imm)                  //      AVX512_F{kz|b64}-VL
  ASMJIT_INST_4i(vcmppd, Vcmppd, KReg, Zmm, Zmm, Imm)                  //      AVX512_F{kz|sae|b64}
  ASMJIT_INST_4i(vcmppd, Vcmppd, KReg, Zmm, Mem, Imm)                  //      AVX512_F{kz|sae|b64}
  ASMJIT_INST_4i(vcmpps, Vcmpps, Xmm, Xmm, Xmm, Imm)                   // AVX
  ASMJIT_INST_4i(vcmpps, Vcmpps, Xmm, Xmm, Mem, Imm)                   // AVX
  ASMJIT_INST_4i(vcmpps, Vcmpps, Ymm, Ymm, Ymm, Imm)                   // AVX
  ASMJIT_INST_4i(vcmpps, Vcmpps, Ymm, Ymm, Mem, Imm)                   // AVX
  ASMJIT_INST_4i(vcmpps, Vcmpps, KReg, Xmm, Xmm, Imm)                  //      AVX512_F{kz|b32}-VL
  ASMJIT_INST_4i(vcmpps, Vcmpps, KReg, Xmm, Mem, Imm)                  //      AVX512_F{kz|b32}-VL
  ASMJIT_INST_4i(vcmpps, Vcmpps, KReg, Ymm, Ymm, Imm)                  //      AVX512_F{kz|b32}-VL
  ASMJIT_INST_4i(vcmpps, Vcmpps, KReg, Ymm, Mem, Imm)                  //      AVX512_F{kz|b32}-VL
  ASMJIT_INST_4i(vcmpps, Vcmpps, KReg, Zmm, Zmm, Imm)                  //      AVX512_F{kz|sae|b32}
  ASMJIT_INST_4i(vcmpps, Vcmpps, KReg, Zmm, Mem, Imm)                  //      AVX512_F{kz|sae|b32}
  ASMJIT_INST_4i(vcmpsd, Vcmpsd, Xmm, Xmm, Xmm, Imm)                   // AVX
  ASMJIT_INST_4i(vcmpsd, Vcmpsd, Xmm, Xmm, Mem, Imm)                   // AVX
  ASMJIT_INST_4i(vcmpsd, Vcmpsd, KReg, Xmm, Xmm, Imm)                  //      AVX512_F{kz|sae}
  ASMJIT_INST_4i(vcmpsd, Vcmpsd, KReg, Xmm, Mem, Imm)                  //      AVX512_F{kz|sae}
  ASMJIT_INST_4i(vcmpss, Vcmpss, Xmm, Xmm, Xmm, Imm)                   // AVX
  ASMJIT_INST_4i(vcmpss, Vcmpss, Xmm, Xmm, Mem, Imm)                   // AVX
  ASMJIT_INST_4i(vcmpss, Vcmpss, KReg, Xmm, Xmm, Imm)                  //      AVX512_F{kz|sae}
  ASMJIT_INST_4i(vcmpss, Vcmpss, KReg, Xmm, Mem, Imm)                  //      AVX512_F{kz|sae}
  ASMJIT_INST_2x(vcomisd, Vcomisd, Xmm, Xmm)                           // AVX  AVX512_F{sae}
  ASMJIT_INST_2x(vcomisd, Vcomisd, Xmm, Mem)                           // AVX  AVX512_F{sae}
  ASMJIT_INST_2x(vcomiss, Vcomiss, Xmm, Xmm)                           // AVX  AVX512_F{sae}
  ASMJIT_INST_2x(vcomiss, Vcomiss, Xmm, Mem)                           // AVX  AVX512_F{sae}
  ASMJIT_INST_2x(vcompresspd, Vcompresspd, Xmm, Xmm)                   //      AVX512_F{kz}-VL
  ASMJIT_INST_2x(vcompresspd, Vcompresspd, Mem, Xmm)                   //      AVX512_F{kz}-VL
  ASMJIT_INST_2x(vcompresspd, Vcompresspd, Ymm, Ymm)                   //      AVX512_F{kz}-VL
  ASMJIT_INST_2x(vcompresspd, Vcompresspd, Mem, Ymm)                   //      AVX512_F{kz}-VL
  ASMJIT_INST_2x(vcompresspd, Vcompresspd, Zmm, Zmm)                   //      AVX512_F{kz}
  ASMJIT_INST_2x(vcompresspd, Vcompresspd, Mem, Zmm)                   //      AVX512_F{kz}
  ASMJIT_INST_2x(vcompressps, Vcompressps, Xmm, Xmm)                   //      AVX512_F{kz}-VL
  ASMJIT_INST_2x(vcompressps, Vcompressps, Mem, Xmm)                   //      AVX512_F{kz}-VL
  ASMJIT_INST_2x(vcompressps, Vcompressps, Ymm, Ymm)                   //      AVX512_F{kz}-VL
  ASMJIT_INST_2x(vcompressps, Vcompressps, Mem, Ymm)                   //      AVX512_F{kz}-VL
  ASMJIT_INST_2x(vcompressps, Vcompressps, Zmm, Zmm)                   //      AVX512_F{kz}
  ASMJIT_INST_2x(vcompressps, Vcompressps, Mem, Zmm)                   //      AVX512_F{kz}
  ASMJIT_INST_2x(vcvtdq2pd, Vcvtdq2pd, Xmm, Xmm)                       // AVX  AVX512_F{kz|b32}-VL
  ASMJIT_INST_2x(vcvtdq2pd, Vcvtdq2pd, Xmm, Mem)                       // AVX  AVX512_F{kz|b32}-VL
  ASMJIT_INST_2x(vcvtdq2pd, Vcvtdq2pd, Ymm, Xmm)                       // AVX  AVX512_F{kz|b32}-VL
  ASMJIT_INST_2x(vcvtdq2pd, Vcvtdq2pd, Ymm, Mem)                       // AVX  AVX512_F{kz|b32}-VL
  ASMJIT_INST_2x(vcvtdq2pd, Vcvtdq2pd, Zmm, Ymm)                       //      AVX512_F{kz|b32}
  ASMJIT_INST_2x(vcvtdq2pd, Vcvtdq2pd, Zmm, Mem)                       //      AVX512_F{kz|b32}
  ASMJIT_INST_2x(vcvtdq2ps, Vcvtdq2ps, Xmm, Xmm)                       // AVX  AVX512_F{kz|b32}-VL
  ASMJIT_INST_2x(vcvtdq2ps, Vcvtdq2ps, Xmm, Mem)                       // AVX  AVX512_F{kz|b32}-VL
  ASMJIT_INST_2x(vcvtdq2ps, Vcvtdq2ps, Ymm, Ymm)                       // AVX  AVX512_F{kz|b32}-VL
  ASMJIT_INST_2x(vcvtdq2ps, Vcvtdq2ps, Ymm, Mem)                       // AVX  AVX512_F{kz|b32}-VL
  ASMJIT_INST_2x(vcvtdq2ps, Vcvtdq2ps, Zmm, Zmm)                       //      AVX512_F{kz|er|b32}
  ASMJIT_INST_2x(vcvtdq2ps, Vcvtdq2ps, Zmm, Mem)                       //      AVX512_F{kz|er|b32}
  ASMJIT_INST_2x(vcvtpd2dq, Vcvtpd2dq, Xmm, Xmm)                       // AVX  AVX512_F{kz|b64}-VL
  ASMJIT_INST_2x(vcvtpd2dq, Vcvtpd2dq, Xmm, Mem)                       // AVX  AVX512_F{kz|b64}-VL
  ASMJIT_INST_2x(vcvtpd2dq, Vcvtpd2dq, Xmm, Ymm)                       // AVX  AVX512_F{kz|b64}-VL
  ASMJIT_INST_2x(vcvtpd2dq, Vcvtpd2dq, Ymm, Zmm)                       //      AVX512_F{kz|er|b64}
  ASMJIT_INST_2x(vcvtpd2dq, Vcvtpd2dq, Ymm, Mem)                       //      AVX512_F{kz|er|b64}
  ASMJIT_INST_2x(vcvtpd2ps, Vcvtpd2ps, Xmm, Xmm)                       // AVX  AVX512_F{kz|b64}-VL
  ASMJIT_INST_2x(vcvtpd2ps, Vcvtpd2ps, Xmm, Mem)                       // AVX  AVX512_F{kz|b64}-VL
  ASMJIT_INST_2x(vcvtpd2ps, Vcvtpd2ps, Xmm, Ymm)                       // AVX  AVX512_F{kz|b64}-VL
  ASMJIT_INST_2x(vcvtpd2ps, Vcvtpd2ps, Ymm, Zmm)                       //      AVX512_F{kz|er|b64}
  ASMJIT_INST_2x(vcvtpd2ps, Vcvtpd2ps, Ymm, Mem)                       //      AVX512_F{kz|er|b64}
  ASMJIT_INST_2x(vcvtpd2qq, Vcvtpd2qq, Xmm, Xmm)                       //      AVX512_DQ{kz|b64}-VL
  ASMJIT_INST_2x(vcvtpd2qq, Vcvtpd2qq, Xmm, Mem)                       //      AVX512_DQ{kz|b64}-VL
  ASMJIT_INST_2x(vcvtpd2qq, Vcvtpd2qq, Ymm, Ymm)                       //      AVX512_DQ{kz|b64}-VL
  ASMJIT_INST_2x(vcvtpd2qq, Vcvtpd2qq, Ymm, Mem)                       //      AVX512_DQ{kz|b64}-VL
  ASMJIT_INST_2x(vcvtpd2qq, Vcvtpd2qq, Zmm, Zmm)                       //      AVX512_DQ{kz|er|b64}
  ASMJIT_INST_2x(vcvtpd2qq, Vcvtpd2qq, Zmm, Mem)                       //      AVX512_DQ{kz|er|b64}
  ASMJIT_INST_2x(vcvtpd2udq, Vcvtpd2udq, Xmm, Xmm)                     //      AVX512_F{kz|b64}-VL
  ASMJIT_INST_2x(vcvtpd2udq, Vcvtpd2udq, Xmm, Mem)                     //      AVX512_F{kz|b64}-VL
  ASMJIT_INST_2x(vcvtpd2udq, Vcvtpd2udq, Xmm, Ymm)                     //      AVX512_F{kz|b64}-VL
  ASMJIT_INST_2x(vcvtpd2udq, Vcvtpd2udq, Ymm, Zmm)                     //      AVX512_F{kz|er|b64}
  ASMJIT_INST_2x(vcvtpd2udq, Vcvtpd2udq, Ymm, Mem)                     //      AVX512_F{kz|er|b64}
  ASMJIT_INST_2x(vcvtpd2uqq, Vcvtpd2uqq, Xmm, Xmm)                     //      AVX512_DQ{kz|b64}-VL
  ASMJIT_INST_2x(vcvtpd2uqq, Vcvtpd2uqq, Xmm, Mem)                     //      AVX512_DQ{kz|b64}-VL
  ASMJIT_INST_2x(vcvtpd2uqq, Vcvtpd2uqq, Ymm, Ymm)                     //      AVX512_DQ{kz|b64}-VL
  ASMJIT_INST_2x(vcvtpd2uqq, Vcvtpd2uqq, Ymm, Mem)                     //      AVX512_DQ{kz|b64}-VL
  ASMJIT_INST_2x(vcvtpd2uqq, Vcvtpd2uqq, Zmm, Zmm)                     //      AVX512_DQ{kz|er|b64}
  ASMJIT_INST_2x(vcvtpd2uqq, Vcvtpd2uqq, Zmm, Mem)                     //      AVX512_DQ{kz|er|b64}
  ASMJIT_INST_2x(vcvtph2ps, Vcvtph2ps, Xmm, Xmm)                       // F16C AVX512_F{kz}-VL
  ASMJIT_INST_2x(vcvtph2ps, Vcvtph2ps, Xmm, Mem)                       // F16C AVX512_F{kz}-VL
  ASMJIT_INST_2x(vcvtph2ps, Vcvtph2ps, Ymm, Xmm)                       // F16C AVX512_F{kz}-VL
  ASMJIT_INST_2x(vcvtph2ps, Vcvtph2ps, Ymm, Mem)                       // F16C AVX512_F{kz}-VL
  ASMJIT_INST_2x(vcvtph2ps, Vcvtph2ps, Zmm, Ymm)                       //      AVX512_F{kz|sae}
  ASMJIT_INST_2x(vcvtph2ps, Vcvtph2ps, Zmm, Mem)                       //      AVX512_F{kz|sae}
  ASMJIT_INST_2x(vcvtps2dq, Vcvtps2dq, Xmm, Xmm)                       // AVX  AVX512_F{kz|b32}-VL
  ASMJIT_INST_2x(vcvtps2dq, Vcvtps2dq, Xmm, Mem)                       // AVX  AVX512_F{kz|b32}-VL
  ASMJIT_INST_2x(vcvtps2dq, Vcvtps2dq, Ymm, Ymm)                       // AVX  AVX512_F{kz|b32}-VL
  ASMJIT_INST_2x(vcvtps2dq, Vcvtps2dq, Ymm, Mem)                       // AVX  AVX512_F{kz|b32}-VL
  ASMJIT_INST_2x(vcvtps2dq, Vcvtps2dq, Zmm, Zmm)                       //      AVX512_F{kz|er|b32}
  ASMJIT_INST_2x(vcvtps2dq, Vcvtps2dq, Zmm, Mem)                       //      AVX512_F{kz|er|b32}
  ASMJIT_INST_2x(vcvtps2pd, Vcvtps2pd, Xmm, Xmm)                       // AVX  AVX512_F{kz|b32}-VL
  ASMJIT_INST_2x(vcvtps2pd, Vcvtps2pd, Xmm, Mem)                       // AVX  AVX512_F{kz|b32}-VL
  ASMJIT_INST_2x(vcvtps2pd, Vcvtps2pd, Ymm, Xmm)                       // AVX  AVX512_F{kz|b32}-VL
  ASMJIT_INST_2x(vcvtps2pd, Vcvtps2pd, Ymm, Mem)                       // AVX  AVX512_F{kz|b32}-VL
  ASMJIT_INST_2x(vcvtps2pd, Vcvtps2pd, Zmm, Ymm)                       //      AVX512_F{kz|er|b32}
  ASMJIT_INST_2x(vcvtps2pd, Vcvtps2pd, Zmm, Mem)                       //      AVX512_F{kz|er|b32}
  ASMJIT_INST_3i(vcvtps2ph, Vcvtps2ph, Xmm, Xmm, Imm)                  // F16C AVX512_F{kz}-VL
  ASMJIT_INST_3i(vcvtps2ph, Vcvtps2ph, Mem, Xmm, Imm)                  // F16C AVX512_F{kz}-VL
  ASMJIT_INST_3i(vcvtps2ph, Vcvtps2ph, Xmm, Ymm, Imm)                  // F16C AVX512_F{kz}-VL
  ASMJIT_INST_3i(vcvtps2ph, Vcvtps2ph, Mem, Ymm, Imm)                  // F16C AVX512_F{kz}-VL
  ASMJIT_INST_3i(vcvtps2ph, Vcvtps2ph, Ymm, Zmm, Imm)                  //      AVX512_F{kz|sae}
  ASMJIT_INST_3i(vcvtps2ph, Vcvtps2ph, Mem, Zmm, Imm)                  //      AVX512_F{kz|sae}
  ASMJIT_INST_2x(vcvtps2qq, Vcvtps2qq, Xmm, Xmm)                       //      AVX512_DQ{kz|b32}-VL
  ASMJIT_INST_2x(vcvtps2qq, Vcvtps2qq, Xmm, Mem)                       //      AVX512_DQ{kz|b32}-VL
  ASMJIT_INST_2x(vcvtps2qq, Vcvtps2qq, Ymm, Xmm)                       //      AVX512_DQ{kz|b32}-VL
  ASMJIT_INST_2x(vcvtps2qq, Vcvtps2qq, Ymm, Mem)                       //      AVX512_DQ{kz|b32}-VL
  ASMJIT_INST_2x(vcvtps2qq, Vcvtps2qq, Zmm, Ymm)                       //      AVX512_DQ{kz|er|b32}
  ASMJIT_INST_2x(vcvtps2qq, Vcvtps2qq, Zmm, Mem)                       //      AVX512_DQ{kz|er|b32}
  ASMJIT_INST_2x(vcvtps2udq, Vcvtps2udq, Xmm, Xmm)                     //      AVX512_F{kz|b32}-VL
  ASMJIT_INST_2x(vcvtps2udq, Vcvtps2udq, Xmm, Mem)                     //      AVX512_F{kz|b32}-VL
  ASMJIT_INST_2x(vcvtps2udq, Vcvtps2udq, Ymm, Ymm)                     //      AVX512_F{kz|b32}-VL
  ASMJIT_INST_2x(vcvtps2udq, Vcvtps2udq, Ymm, Mem)                     //      AVX512_F{kz|b32}-VL
  ASMJIT_INST_2x(vcvtps2udq, Vcvtps2udq, Zmm, Zmm)                     //      AVX512_F{kz|er|b32}
  ASMJIT_INST_2x(vcvtps2udq, Vcvtps2udq, Zmm, Mem)                     //      AVX512_F{kz|er|b32}
  ASMJIT_INST_2x(vcvtps2uqq, Vcvtps2uqq, Xmm, Xmm)                     //      AVX512_DQ{kz|b32}-VL
  ASMJIT_INST_2x(vcvtps2uqq, Vcvtps2uqq, Xmm, Mem)                     //      AVX512_DQ{kz|b32}-VL
  ASMJIT_INST_2x(vcvtps2uqq, Vcvtps2uqq, Ymm, Xmm)                     //      AVX512_DQ{kz|b32}-VL
  ASMJIT_INST_2x(vcvtps2uqq, Vcvtps2uqq, Ymm, Mem)                     //      AVX512_DQ{kz|b32}-VL
  ASMJIT_INST_2x(vcvtps2uqq, Vcvtps2uqq, Zmm, Ymm)                     //      AVX512_DQ{kz|er|b32}
  ASMJIT_INST_2x(vcvtps2uqq, Vcvtps2uqq, Zmm, Mem)                     //      AVX512_DQ{kz|er|b32}
  ASMJIT_INST_2x(vcvtqq2pd, Vcvtqq2pd, Xmm, Xmm)                       //      AVX512_DQ{kz|b64}-VL
  ASMJIT_INST_2x(vcvtqq2pd, Vcvtqq2pd, Xmm, Mem)                       //      AVX512_DQ{kz|b64}-VL
  ASMJIT_INST_2x(vcvtqq2pd, Vcvtqq2pd, Ymm, Ymm)                       //      AVX512_DQ{kz|b64}-VL
  ASMJIT_INST_2x(vcvtqq2pd, Vcvtqq2pd, Ymm, Mem)                       //      AVX512_DQ{kz|b64}-VL
  ASMJIT_INST_2x(vcvtqq2pd, Vcvtqq2pd, Zmm, Zmm)                       //      AVX512_DQ{kz|er|b64}
  ASMJIT_INST_2x(vcvtqq2pd, Vcvtqq2pd, Zmm, Mem)                       //      AVX512_DQ{kz|er|b64}
  ASMJIT_INST_2x(vcvtqq2ps, Vcvtqq2ps, Xmm, Xmm)                       //      AVX512_DQ{kz|b64}-VL
  ASMJIT_INST_2x(vcvtqq2ps, Vcvtqq2ps, Xmm, Mem)                       //      AVX512_DQ{kz|b64}-VL
  ASMJIT_INST_2x(vcvtqq2ps, Vcvtqq2ps, Xmm, Ymm)                       //      AVX512_DQ{kz|b64}-VL
  ASMJIT_INST_2x(vcvtqq2ps, Vcvtqq2ps, Ymm, Zmm)                       //      AVX512_DQ{kz|er|b64}
  ASMJIT_INST_2x(vcvtqq2ps, Vcvtqq2ps, Ymm, Mem)                       //      AVX512_DQ{kz|er|b64}
  ASMJIT_INST_2x(vcvtsd2si, Vcvtsd2si, Gp, Xmm)                        // AVX  AVX512_F{er}
  ASMJIT_INST_2x(vcvtsd2si, Vcvtsd2si, Gp, Mem)                        // AVX  AVX512_F{er}
  ASMJIT_INST_3x(vcvtsd2ss, Vcvtsd2ss, Xmm, Xmm, Xmm)                  // AVX  AVX512_F{kz|er}
  ASMJIT_INST_3x(vcvtsd2ss, Vcvtsd2ss, Xmm, Xmm, Mem)                  // AVX  AVX512_F{kz|er}
  ASMJIT_INST_2x(vcvtsd2usi, Vcvtsd2usi, Gp, Xmm)                      //      AVX512_F{er}
  ASMJIT_INST_2x(vcvtsd2usi, Vcvtsd2usi, Gp, Mem)                      //      AVX512_F{er}
  ASMJIT_INST_3x(vcvtsi2sd, Vcvtsi2sd, Xmm, Xmm, Gp)                   // AVX  AVX512_F{er}
  ASMJIT_INST_3x(vcvtsi2sd, Vcvtsi2sd, Xmm, Xmm, Mem)                  // AVX  AVX512_F{er}
  ASMJIT_INST_3x(vcvtsi2ss, Vcvtsi2ss, Xmm, Xmm, Gp)                   // AVX  AVX512_F{er}
  ASMJIT_INST_3x(vcvtsi2ss, Vcvtsi2ss, Xmm, Xmm, Mem)                  // AVX  AVX512_F{er}
  ASMJIT_INST_3x(vcvtss2sd, Vcvtss2sd, Xmm, Xmm, Xmm)                  // AVX  AVX512_F{kz|sae}
  ASMJIT_INST_3x(vcvtss2sd, Vcvtss2sd, Xmm, Xmm, Mem)                  // AVX  AVX512_F{kz|sae}
  ASMJIT_INST_2x(vcvtss2si, Vcvtss2si, Gp, Xmm)                        // AVX  AVX512_F{er}
  ASMJIT_INST_2x(vcvtss2si, Vcvtss2si, Gp, Mem)                        // AVX  AVX512_F{er}
  ASMJIT_INST_2x(vcvtss2usi, Vcvtss2usi, Gp, Xmm)                      //      AVX512_F{er}
  ASMJIT_INST_2x(vcvtss2usi, Vcvtss2usi, Gp, Mem)                      //      AVX512_F{er}
  ASMJIT_INST_2x(vcvttpd2dq, Vcvttpd2dq, Xmm, Xmm)                     // AVX  AVX512_F{kz|b64}-VL
  ASMJIT_INST_2x(vcvttpd2dq, Vcvttpd2dq, Xmm, Mem)                     // AVX  AVX512_F{kz|b64}-VL
  ASMJIT_INST_2x(vcvttpd2dq, Vcvttpd2dq, Xmm, Ymm)                     // AVX  AVX512_F{kz|b64}-VL
  ASMJIT_INST_2x(vcvttpd2dq, Vcvttpd2dq, Ymm, Zmm)                     //      AVX512_F{kz|sae|b64}
  ASMJIT_INST_2x(vcvttpd2dq, Vcvttpd2dq, Ymm, Mem)                     //      AVX512_F{kz|sae|b64}
  ASMJIT_INST_2x(vcvttpd2qq, Vcvttpd2qq, Xmm, Xmm)                     //      AVX512_F{kz|b64}-VL
  ASMJIT_INST_2x(vcvttpd2qq, Vcvttpd2qq, Xmm, Mem)                     //      AVX512_F{kz|b64}-VL
  ASMJIT_INST_2x(vcvttpd2qq, Vcvttpd2qq, Ymm, Ymm)                     //      AVX512_F{kz|b64}-VL
  ASMJIT_INST_2x(vcvttpd2qq, Vcvttpd2qq, Ymm, Mem)                     //      AVX512_F{kz|b64}-VL
  ASMJIT_INST_2x(vcvttpd2qq, Vcvttpd2qq, Zmm, Zmm)                     //      AVX512_F{kz|sae|b64}
  ASMJIT_INST_2x(vcvttpd2qq, Vcvttpd2qq, Zmm, Mem)                     //      AVX512_F{kz|sae|b64}
  ASMJIT_INST_2x(vcvttpd2udq, Vcvttpd2udq, Xmm, Xmm)                   //      AVX512_F{kz|b64}-VL
  ASMJIT_INST_2x(vcvttpd2udq, Vcvttpd2udq, Xmm, Mem)                   //      AVX512_F{kz|b64}-VL
  ASMJIT_INST_2x(vcvttpd2udq, Vcvttpd2udq, Xmm, Ymm)                   //      AVX512_F{kz|b64}-VL
  ASMJIT_INST_2x(vcvttpd2udq, Vcvttpd2udq, Ymm, Zmm)                   //      AVX512_F{kz|sae|b64}
  ASMJIT_INST_2x(vcvttpd2udq, Vcvttpd2udq, Ymm, Mem)                   //      AVX512_F{kz|sae|b64}
  ASMJIT_INST_2x(vcvttpd2uqq, Vcvttpd2uqq, Xmm, Xmm)                   //      AVX512_DQ{kz|b64}-VL
  ASMJIT_INST_2x(vcvttpd2uqq, Vcvttpd2uqq, Xmm, Mem)                   //      AVX512_DQ{kz|b64}-VL
  ASMJIT_INST_2x(vcvttpd2uqq, Vcvttpd2uqq, Ymm, Ymm)                   //      AVX512_DQ{kz|b64}-VL
  ASMJIT_INST_2x(vcvttpd2uqq, Vcvttpd2uqq, Ymm, Mem)                   //      AVX512_DQ{kz|b64}-VL
  ASMJIT_INST_2x(vcvttpd2uqq, Vcvttpd2uqq, Zmm, Zmm)                   //      AVX512_DQ{kz|sae|b64}
  ASMJIT_INST_2x(vcvttpd2uqq, Vcvttpd2uqq, Zmm, Mem)                   //      AVX512_DQ{kz|sae|b64}
  ASMJIT_INST_2x(vcvttps2dq, Vcvttps2dq, Xmm, Xmm)                     // AVX  AVX512_F{kz|b32}-VL
  ASMJIT_INST_2x(vcvttps2dq, Vcvttps2dq, Xmm, Mem)                     // AVX  AVX512_F{kz|b32}-VL
  ASMJIT_INST_2x(vcvttps2dq, Vcvttps2dq, Ymm, Ymm)                     // AVX  AVX512_F{kz|b32}-VL
  ASMJIT_INST_2x(vcvttps2dq, Vcvttps2dq, Ymm, Mem)                     // AVX  AVX512_F{kz|b32}-VL
  ASMJIT_INST_2x(vcvttps2dq, Vcvttps2dq, Zmm, Zmm)                     //      AVX512_F{kz|sae|b32}
  ASMJIT_INST_2x(vcvttps2dq, Vcvttps2dq, Zmm, Mem)                     //      AVX512_F{kz|sae|b32}
  ASMJIT_INST_2x(vcvttps2qq, Vcvttps2qq, Xmm, Xmm)                     //      AVX512_DQ{kz|b32}-VL
  ASMJIT_INST_2x(vcvttps2qq, Vcvttps2qq, Xmm, Mem)                     //      AVX512_DQ{kz|b32}-VL
  ASMJIT_INST_2x(vcvttps2qq, Vcvttps2qq, Ymm, Xmm)                     //      AVX512_DQ{kz|b32}-VL
  ASMJIT_INST_2x(vcvttps2qq, Vcvttps2qq, Ymm, Mem)                     //      AVX512_DQ{kz|b32}-VL
  ASMJIT_INST_2x(vcvttps2qq, Vcvttps2qq, Zmm, Ymm)                     //      AVX512_DQ{kz|sae|b32}
  ASMJIT_INST_2x(vcvttps2qq, Vcvttps2qq, Zmm, Mem)                     //      AVX512_DQ{kz|sae|b32}
  ASMJIT_INST_2x(vcvttps2udq, Vcvttps2udq, Xmm, Xmm)                   //      AVX512_F{kz|b32}-VL
  ASMJIT_INST_2x(vcvttps2udq, Vcvttps2udq, Xmm, Mem)                   //      AVX512_F{kz|b32}-VL
  ASMJIT_INST_2x(vcvttps2udq, Vcvttps2udq, Ymm, Ymm)                   //      AVX512_F{kz|b32}-VL
  ASMJIT_INST_2x(vcvttps2udq, Vcvttps2udq, Ymm, Mem)                   //      AVX512_F{kz|b32}-VL
  ASMJIT_INST_2x(vcvttps2udq, Vcvttps2udq, Zmm, Zmm)                   //      AVX512_F{kz|sae|b32}
  ASMJIT_INST_2x(vcvttps2udq, Vcvttps2udq, Zmm, Mem)                   //      AVX512_F{kz|sae|b32}
  ASMJIT_INST_2x(vcvttps2uqq, Vcvttps2uqq, Xmm, Xmm)                   //      AVX512_DQ{kz|b32}-VL
  ASMJIT_INST_2x(vcvttps2uqq, Vcvttps2uqq, Xmm, Mem)                   //      AVX512_DQ{kz|b32}-VL
  ASMJIT_INST_2x(vcvttps2uqq, Vcvttps2uqq, Ymm, Xmm)                   //      AVX512_DQ{kz|b32}-VL
  ASMJIT_INST_2x(vcvttps2uqq, Vcvttps2uqq, Ymm, Mem)                   //      AVX512_DQ{kz|b32}-VL
  ASMJIT_INST_2x(vcvttps2uqq, Vcvttps2uqq, Zmm, Ymm)                   //      AVX512_DQ{kz|sae|b32}
  ASMJIT_INST_2x(vcvttps2uqq, Vcvttps2uqq, Zmm, Mem)                   //      AVX512_DQ{kz|sae|b32}
  ASMJIT_INST_2x(vcvttsd2si, Vcvttsd2si, Gp, Xmm)                      // AVX  AVX512_F{sae}
  ASMJIT_INST_2x(vcvttsd2si, Vcvttsd2si, Gp, Mem)                      // AVX  AVX512_F{sae}
  ASMJIT_INST_2x(vcvttsd2usi, Vcvttsd2usi, Gp, Xmm)                    //      AVX512_F{sae}
  ASMJIT_INST_2x(vcvttsd2usi, Vcvttsd2usi, Gp, Mem)                    //      AVX512_F{sae}
  ASMJIT_INST_2x(vcvttss2si, Vcvttss2si, Gp, Xmm)                      // AVX  AVX512_F{sae}
  ASMJIT_INST_2x(vcvttss2si, Vcvttss2si, Gp, Mem)                      // AVX  AVX512_F{sae}
  ASMJIT_INST_2x(vcvttss2usi, Vcvttss2usi, Gp, Xmm)                    //      AVX512_F{sae}
  ASMJIT_INST_2x(vcvttss2usi, Vcvttss2usi, Gp, Mem)                    //      AVX512_F{sae}
  ASMJIT_INST_2x(vcvtudq2pd, Vcvtudq2pd, Xmm, Xmm)                     //      AVX512_F{kz|b32}-VL
  ASMJIT_INST_2x(vcvtudq2pd, Vcvtudq2pd, Xmm, Mem)                     //      AVX512_F{kz|b32}-VL
  ASMJIT_INST_2x(vcvtudq2pd, Vcvtudq2pd, Ymm, Xmm)                     //      AVX512_F{kz|b32}-VL
  ASMJIT_INST_2x(vcvtudq2pd, Vcvtudq2pd, Ymm, Mem)                     //      AVX512_F{kz|b32}-VL
  ASMJIT_INST_2x(vcvtudq2pd, Vcvtudq2pd, Zmm, Ymm)                     //      AVX512_F{kz|b32}
  ASMJIT_INST_2x(vcvtudq2pd, Vcvtudq2pd, Zmm, Mem)                     //      AVX512_F{kz|b32}
  ASMJIT_INST_2x(vcvtudq2ps, Vcvtudq2ps, Xmm, Xmm)                     //      AVX512_F{kz|b32}-VL
  ASMJIT_INST_2x(vcvtudq2ps, Vcvtudq2ps, Xmm, Mem)                     //      AVX512_F{kz|b32}-VL
  ASMJIT_INST_2x(vcvtudq2ps, Vcvtudq2ps, Ymm, Ymm)                     //      AVX512_F{kz|b32}-VL
  ASMJIT_INST_2x(vcvtudq2ps, Vcvtudq2ps, Ymm, Mem)                     //      AVX512_F{kz|b32}-VL
  ASMJIT_INST_2x(vcvtudq2ps, Vcvtudq2ps, Zmm, Zmm)                     //      AVX512_F{kz|er|b32}
  ASMJIT_INST_2x(vcvtudq2ps, Vcvtudq2ps, Zmm, Mem)                     //      AVX512_F{kz|er|b32}
  ASMJIT_INST_2x(vcvtuqq2pd, Vcvtuqq2pd, Xmm, Xmm)                     //      AVX512_DQ{kz|b64}-VL
  ASMJIT_INST_2x(vcvtuqq2pd, Vcvtuqq2pd, Xmm, Mem)                     //      AVX512_DQ{kz|b64}-VL
  ASMJIT_INST_2x(vcvtuqq2pd, Vcvtuqq2pd, Ymm, Ymm)                     //      AVX512_DQ{kz|b64}-VL
  ASMJIT_INST_2x(vcvtuqq2pd, Vcvtuqq2pd, Ymm, Mem)                     //      AVX512_DQ{kz|b64}-VL
  ASMJIT_INST_2x(vcvtuqq2pd, Vcvtuqq2pd, Zmm, Zmm)                     //      AVX512_DQ{kz|er|b64}
  ASMJIT_INST_2x(vcvtuqq2pd, Vcvtuqq2pd, Zmm, Mem)                     //      AVX512_DQ{kz|er|b64}
  ASMJIT_INST_2x(vcvtuqq2ps, Vcvtuqq2ps, Xmm, Xmm)                     //      AVX512_DQ{kz|b64}-VL
  ASMJIT_INST_2x(vcvtuqq2ps, Vcvtuqq2ps, Xmm, Mem)                     //      AVX512_DQ{kz|b64}-VL
  ASMJIT_INST_2x(vcvtuqq2ps, Vcvtuqq2ps, Xmm, Ymm)                     //      AVX512_DQ{kz|b64}-VL
  ASMJIT_INST_2x(vcvtuqq2ps, Vcvtuqq2ps, Ymm, Zmm)                     //      AVX512_DQ{kz|er|b64}
  ASMJIT_INST_2x(vcvtuqq2ps, Vcvtuqq2ps, Ymm, Mem)                     //      AVX512_DQ{kz|er|b64}
  ASMJIT_INST_3x(vcvtusi2sd, Vcvtusi2sd, Xmm, Xmm, Gp)                 //      AVX512_F{er}
  ASMJIT_INST_3x(vcvtusi2sd, Vcvtusi2sd, Xmm, Xmm, Mem)                //      AVX512_F{er}
  ASMJIT_INST_3x(vcvtusi2ss, Vcvtusi2ss, Xmm, Xmm, Gp)                 //      AVX512_F{er}
  ASMJIT_INST_3x(vcvtusi2ss, Vcvtusi2ss, Xmm, Xmm, Mem)                //      AVX512_F{er}
  ASMJIT_INST_4i(vdbpsadbw, Vdbpsadbw, Xmm, Xmm, Xmm, Imm)             //      AVX512_BW{kz}-VL
  ASMJIT_INST_4i(vdbpsadbw, Vdbpsadbw, Xmm, Xmm, Mem, Imm)             //      AVX512_BW{kz}-VL
  ASMJIT_INST_4i(vdbpsadbw, Vdbpsadbw, Ymm, Ymm, Ymm, Imm)             //      AVX512_BW{kz}-VL
  ASMJIT_INST_4i(vdbpsadbw, Vdbpsadbw, Ymm, Ymm, Mem, Imm)             //      AVX512_BW{kz}-VL
  ASMJIT_INST_4i(vdbpsadbw, Vdbpsadbw, Zmm, Zmm, Zmm, Imm)             //      AVX512_BW{kz}
  ASMJIT_INST_4i(vdbpsadbw, Vdbpsadbw, Zmm, Zmm, Mem, Imm)             //      AVX512_BW{kz}
  ASMJIT_INST_3x(vdivpd, Vdivpd, Xmm, Xmm, Xmm)                        // AVX  AVX512_F{kz|b64}-VL
  ASMJIT_INST_3x(vdivpd, Vdivpd, Xmm, Xmm, Mem)                        // AVX  AVX512_F{kz|b64}-VL
  ASMJIT_INST_3x(vdivpd, Vdivpd, Ymm, Ymm, Ymm)                        // AVX  AVX512_F{kz|b64}-VL
  ASMJIT_INST_3x(vdivpd, Vdivpd, Ymm, Ymm, Mem)                        // AVX  AVX512_F{kz|b64}-VL
  ASMJIT_INST_3x(vdivpd, Vdivpd, Zmm, Zmm, Zmm)                        //      AVX512_F{kz|er|b64}
  ASMJIT_INST_3x(vdivpd, Vdivpd, Zmm, Zmm, Mem)                        //      AVX512_F{kz|er|b64}
  ASMJIT_INST_3x(vdivps, Vdivps, Xmm, Xmm, Xmm)                        // AVX  AVX512_F{kz|b32}-VL
  ASMJIT_INST_3x(vdivps, Vdivps, Xmm, Xmm, Mem)                        // AVX  AVX512_F{kz|b32}-VL
  ASMJIT_INST_3x(vdivps, Vdivps, Ymm, Ymm, Ymm)                        // AVX  AVX512_F{kz|b32}-VL
  ASMJIT_INST_3x(vdivps, Vdivps, Ymm, Ymm, Mem)                        // AVX  AVX512_F{kz|b32}-VL
  ASMJIT_INST_3x(vdivps, Vdivps, Zmm, Zmm, Zmm)                        //      AVX512_F{kz|er|b32}
  ASMJIT_INST_3x(vdivps, Vdivps, Zmm, Zmm, Mem)                        //      AVX512_F{kz|er|b32}
  ASMJIT_INST_3x(vdivsd, Vdivsd, Xmm, Xmm, Xmm)                        // AVX  AVX512_F{kz|er}
  ASMJIT_INST_3x(vdivsd, Vdivsd, Xmm, Xmm, Mem)                        // AVX  AVX512_F{kz|er}
  ASMJIT_INST_3x(vdivss, Vdivss, Xmm, Xmm, Xmm)                        // AVX  AVX512_F{kz|er}
  ASMJIT_INST_3x(vdivss, Vdivss, Xmm, Xmm, Mem)                        // AVX  AVX512_F{kz|er}
  ASMJIT_INST_4i(vdppd, Vdppd, Xmm, Xmm, Xmm, Imm)                     // AVX
  ASMJIT_INST_4i(vdppd, Vdppd, Xmm, Xmm, Mem, Imm)                     // AVX
  ASMJIT_INST_4i(vdpps, Vdpps, Xmm, Xmm, Xmm, Imm)                     // AVX
  ASMJIT_INST_4i(vdpps, Vdpps, Xmm, Xmm, Mem, Imm)                     // AVX
  ASMJIT_INST_4i(vdpps, Vdpps, Ymm, Ymm, Ymm, Imm)                     // AVX
  ASMJIT_INST_4i(vdpps, Vdpps, Ymm, Ymm, Mem, Imm)                     // AVX
  ASMJIT_INST_2x(vexp2pd, Vexp2pd, Zmm, Zmm)                           //      AVX512_ER{kz|sae|b64}
  ASMJIT_INST_2x(vexp2pd, Vexp2pd, Zmm, Mem)                           //      AVX512_ER{kz|sae|b64}
  ASMJIT_INST_2x(vexp2ps, Vexp2ps, Zmm, Zmm)                           //      AVX512_ER{kz|sae|b32}
  ASMJIT_INST_2x(vexp2ps, Vexp2ps, Zmm, Mem)                           //      AVX512_ER{kz|sae|b32}
  ASMJIT_INST_2x(vexpandpd, Vexpandpd, Xmm, Xmm)                       //      AVX512_F{kz}-VL
  ASMJIT_INST_2x(vexpandpd, Vexpandpd, Xmm, Mem)                       //      AVX512_F{kz}-VL
  ASMJIT_INST_2x(vexpandpd, Vexpandpd, Ymm, Ymm)                       //      AVX512_F{kz}-VL
  ASMJIT_INST_2x(vexpandpd, Vexpandpd, Ymm, Mem)                       //      AVX512_F{kz}-VL
  ASMJIT_INST_2x(vexpandpd, Vexpandpd, Zmm, Zmm)                       //      AVX512_F{kz}
  ASMJIT_INST_2x(vexpandpd, Vexpandpd, Zmm, Mem)                       //      AVX512_F{kz}
  ASMJIT_INST_2x(vexpandps, Vexpandps, Xmm, Xmm)                       //      AVX512_F{kz}-VL
  ASMJIT_INST_2x(vexpandps, Vexpandps, Xmm, Mem)                       //      AVX512_F{kz}-VL
  ASMJIT_INST_2x(vexpandps, Vexpandps, Ymm, Ymm)                       //      AVX512_F{kz}-VL
  ASMJIT_INST_2x(vexpandps, Vexpandps, Ymm, Mem)                       //      AVX512_F{kz}-VL
  ASMJIT_INST_2x(vexpandps, Vexpandps, Zmm, Zmm)                       //      AVX512_F{kz}
  ASMJIT_INST_2x(vexpandps, Vexpandps, Zmm, Mem)                       //      AVX512_F{kz}
  ASMJIT_INST_3i(vextractf128, Vextractf128, Xmm, Ymm, Imm)            // AVX
  ASMJIT_INST_3i(vextractf128, Vextractf128, Mem, Ymm, Imm)            // AVX
  ASMJIT_INST_3i(vextractf32x4, Vextractf32x4, Xmm, Ymm, Imm)          //      AVX512_F{kz}-VL
  ASMJIT_INST_3i(vextractf32x4, Vextractf32x4, Mem, Ymm, Imm)          //      AVX512_F{kz}-VL
  ASMJIT_INST_3i(vextractf32x4, Vextractf32x4, Xmm, Zmm, Imm)          //      AVX512_F{kz}
  ASMJIT_INST_3i(vextractf32x4, Vextractf32x4, Mem, Zmm, Imm)          //      AVX512_F{kz}
  ASMJIT_INST_3i(vextractf32x8, Vextractf32x8, Ymm, Zmm, Imm)          //      AVX512_DQ{kz}
  ASMJIT_INST_3i(vextractf32x8, Vextractf32x8, Mem, Zmm, Imm)          //      AVX512_DQ{kz}
  ASMJIT_INST_3i(vextractf64x2, Vextractf64x2, Xmm, Ymm, Imm)          //      AVX512_DQ{kz}-VL
  ASMJIT_INST_3i(vextractf64x2, Vextractf64x2, Mem, Ymm, Imm)          //      AVX512_DQ{kz}-VL
  ASMJIT_INST_3i(vextractf64x2, Vextractf64x2, Xmm, Zmm, Imm)          //      AVX512_DQ{kz}
  ASMJIT_INST_3i(vextractf64x2, Vextractf64x2, Mem, Zmm, Imm)          //      AVX512_DQ{kz}
  ASMJIT_INST_3i(vextractf64x4, Vextractf64x4, Ymm, Zmm, Imm)          //      AVX512_F{kz}
  ASMJIT_INST_3i(vextractf64x4, Vextractf64x4, Mem, Zmm, Imm)          //      AVX512_F{kz}
  ASMJIT_INST_3i(vextracti128, Vextracti128, Xmm, Ymm, Imm)            // AVX2
  ASMJIT_INST_3i(vextracti128, Vextracti128, Mem, Ymm, Imm)            // AVX2
  ASMJIT_INST_3i(vextracti32x4, Vextracti32x4, Xmm, Ymm, Imm)          //      AVX512_F{kz}-VL
  ASMJIT_INST_3i(vextracti32x4, Vextracti32x4, Mem, Ymm, Imm)          //      AVX512_F{kz}-VL
  ASMJIT_INST_3i(vextracti32x4, Vextracti32x4, Xmm, Zmm, Imm)          //      AVX512_F{kz}
  ASMJIT_INST_3i(vextracti32x4, Vextracti32x4, Mem, Zmm, Imm)          //      AVX512_F{kz}
  ASMJIT_INST_3i(vextracti32x8, Vextracti32x8, Ymm, Zmm, Imm)          //      AVX512_DQ{kz}
  ASMJIT_INST_3i(vextracti32x8, Vextracti32x8, Mem, Zmm, Imm)          //      AVX512_DQ{kz}
  ASMJIT_INST_3i(vextracti64x2, Vextracti64x2, Xmm, Ymm, Imm)          //      AVX512_DQ{kz}-VL
  ASMJIT_INST_3i(vextracti64x2, Vextracti64x2, Mem, Ymm, Imm)          //      AVX512_DQ{kz}-VL
  ASMJIT_INST_3i(vextracti64x2, Vextracti64x2, Xmm, Zmm, Imm)          //      AVX512_DQ{kz}
  ASMJIT_INST_3i(vextracti64x2, Vextracti64x2, Mem, Zmm, Imm)          //      AVX512_DQ{kz}
  ASMJIT_INST_3i(vextracti64x4, Vextracti64x4, Ymm, Zmm, Imm)          //      AVX512_F{kz}
  ASMJIT_INST_3i(vextracti64x4, Vextracti64x4, Mem, Zmm, Imm)          //      AVX512_F{kz}
  ASMJIT_INST_3i(vextractps, Vextractps, Gp, Xmm, Imm)                 // AVX  AVX512_F
  ASMJIT_INST_3i(vextractps, Vextractps, Mem, Xmm, Imm)                // AVX  AVX512_F
  ASMJIT_INST_4i(vfixupimmpd, Vfixupimmpd, Xmm, Xmm, Xmm, Imm)         //      AVX512_F{kz|b64}-VL
  ASMJIT_INST_4i(vfixupimmpd, Vfixupimmpd, Xmm, Xmm, Mem, Imm)         //      AVX512_F{kz|b64}-VL
  ASMJIT_INST_4i(vfixupimmpd, Vfixupimmpd, Ymm, Ymm, Ymm, Imm)         //      AVX512_F{kz|b64}-VL
  ASMJIT_INST_4i(vfixupimmpd, Vfixupimmpd, Ymm, Ymm, Mem, Imm)         //      AVX512_F{kz|b64}-VL
  ASMJIT_INST_4i(vfixupimmpd, Vfixupimmpd, Zmm, Zmm, Zmm, Imm)         //      AVX512_F{kz|sae|b64}
  ASMJIT_INST_4i(vfixupimmpd, Vfixupimmpd, Zmm, Zmm, Mem, Imm)         //      AVX512_F{kz|sae|b64}
  ASMJIT_INST_4i(vfixupimmps, Vfixupimmps, Xmm, Xmm, Xmm, Imm)         //      AVX512_F{kz|b32}-VL
  ASMJIT_INST_4i(vfixupimmps, Vfixupimmps, Xmm, Xmm, Mem, Imm)         //      AVX512_F{kz|b32}-VL
  ASMJIT_INST_4i(vfixupimmps, Vfixupimmps, Ymm, Ymm, Ymm, Imm)         //      AVX512_F{kz|b32}-VL
  ASMJIT_INST_4i(vfixupimmps, Vfixupimmps, Ymm, Ymm, Mem, Imm)         //      AVX512_F{kz|b32}-VL
  ASMJIT_INST_4i(vfixupimmps, Vfixupimmps, Zmm, Zmm, Zmm, Imm)         //      AVX512_F{kz|sae|b32}
  ASMJIT_INST_4i(vfixupimmps, Vfixupimmps, Zmm, Zmm, Mem, Imm)         //      AVX512_F{kz|sae|b32}
  ASMJIT_INST_4i(vfixupimmsd, Vfixupimmsd, Xmm, Xmm, Xmm, Imm)         //      AVX512_F{kz|sae}
  ASMJIT_INST_4i(vfixupimmsd, Vfixupimmsd, Xmm, Xmm, Mem, Imm)         //      AVX512_F{kz|sae}
  ASMJIT_INST_4i(vfixupimmss, Vfixupimmss, Xmm, Xmm, Xmm, Imm)         //      AVX512_F{kz|sae}
  ASMJIT_INST_4i(vfixupimmss, Vfixupimmss, Xmm, Xmm, Mem, Imm)         //      AVX512_F{kz|sae}
  ASMJIT_INST_3x(vfmadd132pd, Vfmadd132pd, Xmm, Xmm, Xmm)              // FMA  AVX512_F{kz|b64}-VL
  ASMJIT_INST_3x(vfmadd132pd, Vfmadd132pd, Xmm, Xmm, Mem)              // FMA  AVX512_F{kz|b64}-VL
  ASMJIT_INST_3x(vfmadd132pd, Vfmadd132pd, Ymm, Ymm, Ymm)              // FMA  AVX512_F{kz|b64}-VL
  ASMJIT_INST_3x(vfmadd132pd, Vfmadd132pd, Ymm, Ymm, Mem)              // FMA  AVX512_F{kz|b64}-VL
  ASMJIT_INST_3x(vfmadd132pd, Vfmadd132pd, Zmm, Zmm, Zmm)              // FMA  AVX512_F{kz|er|b64}
  ASMJIT_INST_3x(vfmadd132pd, Vfmadd132pd, Zmm, Zmm, Mem)              // FMA  AVX512_F{kz|er|b64}
  ASMJIT_INST_3x(vfmadd132ps, Vfmadd132ps, Xmm, Xmm, Xmm)              // FMA  AVX512_F{kz|b32}-VL
  ASMJIT_INST_3x(vfmadd132ps, Vfmadd132ps, Xmm, Xmm, Mem)              // FMA  AVX512_F{kz|b32}-VL
  ASMJIT_INST_3x(vfmadd132ps, Vfmadd132ps, Ymm, Ymm, Ymm)              // FMA  AVX512_F{kz|b32}-VL
  ASMJIT_INST_3x(vfmadd132ps, Vfmadd132ps, Ymm, Ymm, Mem)              // FMA  AVX512_F{kz|b32}-VL
  ASMJIT_INST_3x(vfmadd132ps, Vfmadd132ps, Zmm, Zmm, Zmm)              // FMA  AVX512_F{kz|er|b32}
  ASMJIT_INST_3x(vfmadd132ps, Vfmadd132ps, Zmm, Zmm, Mem)              // FMA  AVX512_F{kz|er|b32}
  ASMJIT_INST_3x(vfmadd132sd, Vfmadd132sd, Xmm, Xmm, Xmm)              // FMA  AVX512_F{kz|er}
  ASMJIT_INST_3x(vfmadd132sd, Vfmadd132sd, Xmm, Xmm, Mem)              // FMA  AVX512_F{kz|er}
  ASMJIT_INST_3x(vfmadd132ss, Vfmadd132ss, Xmm, Xmm, Xmm)              // FMA  AVX512_F{kz|er}
  ASMJIT_INST_3x(vfmadd132ss, Vfmadd132ss, Xmm, Xmm, Mem)              // FMA  AVX512_F{kz|er}
  ASMJIT_INST_3x(vfmadd213pd, Vfmadd213pd, Xmm, Xmm, Xmm)              // FMA  AVX512_F{kz|b64}-VL
  ASMJIT_INST_3x(vfmadd213pd, Vfmadd213pd, Xmm, Xmm, Mem)              // FMA  AVX512_F{kz|b64}-VL
  ASMJIT_INST_3x(vfmadd213pd, Vfmadd213pd, Ymm, Ymm, Ymm)              // FMA  AVX512_F{kz|b64}-VL
  ASMJIT_INST_3x(vfmadd213pd, Vfmadd213pd, Ymm, Ymm, Mem)              // FMA  AVX512_F{kz|b64}-VL
  ASMJIT_INST_3x(vfmadd213pd, Vfmadd213pd, Zmm, Zmm, Zmm)              // FMA  AVX512_F{kz|er|b64}
  ASMJIT_INST_3x(vfmadd213pd, Vfmadd213pd, Zmm, Zmm, Mem)              // FMA  AVX512_F{kz|er|b64}
  ASMJIT_INST_3x(vfmadd213ps, Vfmadd213ps, Xmm, Xmm, Xmm)              // FMA  AVX512_F{kz|b32}-VL
  ASMJIT_INST_3x(vfmadd213ps, Vfmadd213ps, Xmm, Xmm, Mem)              // FMA  AVX512_F{kz|b32}-VL
  ASMJIT_INST_3x(vfmadd213ps, Vfmadd213ps, Ymm, Ymm, Ymm)              // FMA  AVX512_F{kz|b32}-VL
  ASMJIT_INST_3x(vfmadd213ps, Vfmadd213ps, Ymm, Ymm, Mem)              // FMA  AVX512_F{kz|b32}-VL
  ASMJIT_INST_3x(vfmadd213ps, Vfmadd213ps, Zmm, Zmm, Zmm)              // FMA  AVX512_F{kz|er|b32}
  ASMJIT_INST_3x(vfmadd213ps, Vfmadd213ps, Zmm, Zmm, Mem)              // FMA  AVX512_F{kz|er|b32}
  ASMJIT_INST_3x(vfmadd213sd, Vfmadd213sd, Xmm, Xmm, Xmm)              // FMA  AVX512_F{kz|er}
  ASMJIT_INST_3x(vfmadd213sd, Vfmadd213sd, Xmm, Xmm, Mem)              // FMA  AVX512_F{kz|er}
  ASMJIT_INST_3x(vfmadd213ss, Vfmadd213ss, Xmm, Xmm, Xmm)              // FMA  AVX512_F{kz|er}
  ASMJIT_INST_3x(vfmadd213ss, Vfmadd213ss, Xmm, Xmm, Mem)              // FMA  AVX512_F{kz|er}
  ASMJIT_INST_3x(vfmadd231pd, Vfmadd231pd, Xmm, Xmm, Xmm)              // FMA  AVX512_F{kz|b64}-VL
  ASMJIT_INST_3x(vfmadd231pd, Vfmadd231pd, Xmm, Xmm, Mem)              // FMA  AVX512_F{kz|b64}-VL
  ASMJIT_INST_3x(vfmadd231pd, Vfmadd231pd, Ymm, Ymm, Ymm)              // FMA  AVX512_F{kz|b64}-VL
  ASMJIT_INST_3x(vfmadd231pd, Vfmadd231pd, Ymm, Ymm, Mem)              // FMA  AVX512_F{kz|b64}-VL
  ASMJIT_INST_3x(vfmadd231pd, Vfmadd231pd, Zmm, Zmm, Zmm)              // FMA  AVX512_F{kz|er|b64}
  ASMJIT_INST_3x(vfmadd231pd, Vfmadd231pd, Zmm, Zmm, Mem)              // FMA  AVX512_F{kz|er|b64}
  ASMJIT_INST_3x(vfmadd231ps, Vfmadd231ps, Xmm, Xmm, Xmm)              // FMA  AVX512_F{kz|b32}-VL
  ASMJIT_INST_3x(vfmadd231ps, Vfmadd231ps, Xmm, Xmm, Mem)              // FMA  AVX512_F{kz|b32}-VL
  ASMJIT_INST_3x(vfmadd231ps, Vfmadd231ps, Ymm, Ymm, Ymm)              // FMA  AVX512_F{kz|b32}-VL
  ASMJIT_INST_3x(vfmadd231ps, Vfmadd231ps, Ymm, Ymm, Mem)              // FMA  AVX512_F{kz|b32}-VL
  ASMJIT_INST_3x(vfmadd231ps, Vfmadd231ps, Zmm, Zmm, Zmm)              // FMA  AVX512_F{kz|er|b32}
  ASMJIT_INST_3x(vfmadd231ps, Vfmadd231ps, Zmm, Zmm, Mem)              // FMA  AVX512_F{kz|er|b32}
  ASMJIT_INST_3x(vfmadd231sd, Vfmadd231sd, Xmm, Xmm, Xmm)              // FMA  AVX512_F{kz|er}
  ASMJIT_INST_3x(vfmadd231sd, Vfmadd231sd, Xmm, Xmm, Mem)              // FMA  AVX512_F{kz|er}
  ASMJIT_INST_3x(vfmadd231ss, Vfmadd231ss, Xmm, Xmm, Xmm)              // FMA  AVX512_F{kz|er}
  ASMJIT_INST_3x(vfmadd231ss, Vfmadd231ss, Xmm, Xmm, Mem)              // FMA  AVX512_F{kz|er}
  ASMJIT_INST_3x(vfmaddsub132pd, Vfmaddsub132pd, Xmm, Xmm, Xmm)        // FMA  AVX512_F{kz|b64}-VL
  ASMJIT_INST_3x(vfmaddsub132pd, Vfmaddsub132pd, Xmm, Xmm, Mem)        // FMA  AVX512_F{kz|b64}-VL
  ASMJIT_INST_3x(vfmaddsub132pd, Vfmaddsub132pd, Ymm, Ymm, Ymm)        // FMA  AVX512_F{kz|b64}-VL
  ASMJIT_INST_3x(vfmaddsub132pd, Vfmaddsub132pd, Ymm, Ymm, Mem)        // FMA  AVX512_F{kz|b64}-VL
  ASMJIT_INST_3x(vfmaddsub132pd, Vfmaddsub132pd, Zmm, Zmm, Zmm)        // FMA  AVX512_F{kz|er|b64}
  ASMJIT_INST_3x(vfmaddsub132pd, Vfmaddsub132pd, Zmm, Zmm, Mem)        // FMA  AVX512_F{kz|er|b64}
  ASMJIT_INST_3x(vfmaddsub132ps, Vfmaddsub132ps, Xmm, Xmm, Xmm)        // FMA  AVX512_F{kz|b32}-VL
  ASMJIT_INST_3x(vfmaddsub132ps, Vfmaddsub132ps, Xmm, Xmm, Mem)        // FMA  AVX512_F{kz|b32}-VL
  ASMJIT_INST_3x(vfmaddsub132ps, Vfmaddsub132ps, Ymm, Ymm, Ymm)        // FMA  AVX512_F{kz|b32}-VL
  ASMJIT_INST_3x(vfmaddsub132ps, Vfmaddsub132ps, Ymm, Ymm, Mem)        // FMA  AVX512_F{kz|b32}-VL
  ASMJIT_INST_3x(vfmaddsub132ps, Vfmaddsub132ps, Zmm, Zmm, Zmm)        // FMA  AVX512_F{kz|er|b32}
  ASMJIT_INST_3x(vfmaddsub132ps, Vfmaddsub132ps, Zmm, Zmm, Mem)        // FMA  AVX512_F{kz|er|b32}
  ASMJIT_INST_3x(vfmaddsub213pd, Vfmaddsub213pd, Xmm, Xmm, Xmm)        // FMA  AVX512_F{kz|b64}-VL
  ASMJIT_INST_3x(vfmaddsub213pd, Vfmaddsub213pd, Xmm, Xmm, Mem)        // FMA  AVX512_F{kz|b64}-VL
  ASMJIT_INST_3x(vfmaddsub213pd, Vfmaddsub213pd, Ymm, Ymm, Ymm)        // FMA  AVX512_F{kz|b64}-VL
  ASMJIT_INST_3x(vfmaddsub213pd, Vfmaddsub213pd, Ymm, Ymm, Mem)        // FMA  AVX512_F{kz|b64}-VL
  ASMJIT_INST_3x(vfmaddsub213pd, Vfmaddsub213pd, Zmm, Zmm, Zmm)        // FMA  AVX512_F{kz|er|b64}
  ASMJIT_INST_3x(vfmaddsub213pd, Vfmaddsub213pd, Zmm, Zmm, Mem)        // FMA  AVX512_F{kz|er|b64}
  ASMJIT_INST_3x(vfmaddsub213ps, Vfmaddsub213ps, Xmm, Xmm, Xmm)        // FMA  AVX512_F{kz|b32}-VL
  ASMJIT_INST_3x(vfmaddsub213ps, Vfmaddsub213ps, Xmm, Xmm, Mem)        // FMA  AVX512_F{kz|b32}-VL
  ASMJIT_INST_3x(vfmaddsub213ps, Vfmaddsub213ps, Ymm, Ymm, Ymm)        // FMA  AVX512_F{kz|b32}-VL
  ASMJIT_INST_3x(vfmaddsub213ps, Vfmaddsub213ps, Ymm, Ymm, Mem)        // FMA  AVX512_F{kz|b32}-VL
  ASMJIT_INST_3x(vfmaddsub213ps, Vfmaddsub213ps, Zmm, Zmm, Zmm)        // FMA  AVX512_F{kz|er|b32}
  ASMJIT_INST_3x(vfmaddsub213ps, Vfmaddsub213ps, Zmm, Zmm, Mem)        // FMA  AVX512_F{kz|er|b32}
  ASMJIT_INST_3x(vfmaddsub231pd, Vfmaddsub231pd, Xmm, Xmm, Xmm)        // FMA  AVX512_F{kz|b64}-VL
  ASMJIT_INST_3x(vfmaddsub231pd, Vfmaddsub231pd, Xmm, Xmm, Mem)        // FMA  AVX512_F{kz|b64}-VL
  ASMJIT_INST_3x(vfmaddsub231pd, Vfmaddsub231pd, Ymm, Ymm, Ymm)        // FMA  AVX512_F{kz|b64}-VL
  ASMJIT_INST_3x(vfmaddsub231pd, Vfmaddsub231pd, Ymm, Ymm, Mem)        // FMA  AVX512_F{kz|b64}-VL
  ASMJIT_INST_3x(vfmaddsub231pd, Vfmaddsub231pd, Zmm, Zmm, Zmm)        // FMA  AVX512_F{kz|er|b64}
  ASMJIT_INST_3x(vfmaddsub231pd, Vfmaddsub231pd, Zmm, Zmm, Mem)        // FMA  AVX512_F{kz|er|b64}
  ASMJIT_INST_3x(vfmaddsub231ps, Vfmaddsub231ps, Xmm, Xmm, Xmm)        // FMA  AVX512_F{kz|b32}-VL
  ASMJIT_INST_3x(vfmaddsub231ps, Vfmaddsub231ps, Xmm, Xmm, Mem)        // FMA  AVX512_F{kz|b32}-VL
  ASMJIT_INST_3x(vfmaddsub231ps, Vfmaddsub231ps, Ymm, Ymm, Ymm)        // FMA  AVX512_F{kz|b32}-VL
  ASMJIT_INST_3x(vfmaddsub231ps, Vfmaddsub231ps, Ymm, Ymm, Mem)        // FMA  AVX512_F{kz|b32}-VL
  ASMJIT_INST_3x(vfmaddsub231ps, Vfmaddsub231ps, Zmm, Zmm, Zmm)        // FMA  AVX512_F{kz|er|b32}
  ASMJIT_INST_3x(vfmaddsub231ps, Vfmaddsub231ps, Zmm, Zmm, Mem)        // FMA  AVX512_F{kz|er|b32}
  ASMJIT_INST_3x(vfmsub132pd, Vfmsub132pd, Xmm, Xmm, Xmm)              // FMA  AVX512_F{kz|b64}-VL
  ASMJIT_INST_3x(vfmsub132pd, Vfmsub132pd, Xmm, Xmm, Mem)              // FMA  AVX512_F{kz|b64}-VL
  ASMJIT_INST_3x(vfmsub132pd, Vfmsub132pd, Ymm, Ymm, Ymm)              // FMA  AVX512_F{kz|b64}-VL
  ASMJIT_INST_3x(vfmsub132pd, Vfmsub132pd, Ymm, Ymm, Mem)              // FMA  AVX512_F{kz|b64}-VL
  ASMJIT_INST_3x(vfmsub132pd, Vfmsub132pd, Zmm, Zmm, Zmm)              // FMA  AVX512_F{kz|er|b64}
  ASMJIT_INST_3x(vfmsub132pd, Vfmsub132pd, Zmm, Zmm, Mem)              // FMA  AVX512_F{kz|er|b64}
  ASMJIT_INST_3x(vfmsub132ps, Vfmsub132ps, Xmm, Xmm, Xmm)              // FMA  AVX512_F{kz|b32}-VL
  ASMJIT_INST_3x(vfmsub132ps, Vfmsub132ps, Xmm, Xmm, Mem)              // FMA  AVX512_F{kz|b32}-VL
  ASMJIT_INST_3x(vfmsub132ps, Vfmsub132ps, Ymm, Ymm, Ymm)              // FMA  AVX512_F{kz|b32}-VL
  ASMJIT_INST_3x(vfmsub132ps, Vfmsub132ps, Ymm, Ymm, Mem)              // FMA  AVX512_F{kz|b32}-VL
  ASMJIT_INST_3x(vfmsub132ps, Vfmsub132ps, Zmm, Zmm, Zmm)              // FMA  AVX512_F{kz|er|b32}
  ASMJIT_INST_3x(vfmsub132ps, Vfmsub132ps, Zmm, Zmm, Mem)              // FMA  AVX512_F{kz|er|b32}
  ASMJIT_INST_3x(vfmsub132sd, Vfmsub132sd, Xmm, Xmm, Xmm)              // FMA  AVX512_F{kz|er}
  ASMJIT_INST_3x(vfmsub132sd, Vfmsub132sd, Xmm, Xmm, Mem)              // FMA  AVX512_F{kz|er}
  ASMJIT_INST_3x(vfmsub132ss, Vfmsub132ss, Xmm, Xmm, Xmm)              // FMA  AVX512_F{kz|er}
  ASMJIT_INST_3x(vfmsub132ss, Vfmsub132ss, Xmm, Xmm, Mem)              // FMA  AVX512_F{kz|er}
  ASMJIT_INST_3x(vfmsub213pd, Vfmsub213pd, Xmm, Xmm, Xmm)              // FMA  AVX512_F{kz|b64}-VL
  ASMJIT_INST_3x(vfmsub213pd, Vfmsub213pd, Xmm, Xmm, Mem)              // FMA  AVX512_F{kz|b64}-VL
  ASMJIT_INST_3x(vfmsub213pd, Vfmsub213pd, Ymm, Ymm, Ymm)              // FMA  AVX512_F{kz|b64}-VL
  ASMJIT_INST_3x(vfmsub213pd, Vfmsub213pd, Ymm, Ymm, Mem)              // FMA  AVX512_F{kz|b64}-VL
  ASMJIT_INST_3x(vfmsub213pd, Vfmsub213pd, Zmm, Zmm, Zmm)              // FMA  AVX512_F{kz|er|b64}
  ASMJIT_INST_3x(vfmsub213pd, Vfmsub213pd, Zmm, Zmm, Mem)              // FMA  AVX512_F{kz|er|b64}
  ASMJIT_INST_3x(vfmsub213ps, Vfmsub213ps, Xmm, Xmm, Xmm)              // FMA  AVX512_F{kz|b32}-VL
  ASMJIT_INST_3x(vfmsub213ps, Vfmsub213ps, Xmm, Xmm, Mem)              // FMA  AVX512_F{kz|b32}-VL
  ASMJIT_INST_3x(vfmsub213ps, Vfmsub213ps, Ymm, Ymm, Ymm)              // FMA  AVX512_F{kz|b32}-VL
  ASMJIT_INST_3x(vfmsub213ps, Vfmsub213ps, Ymm, Ymm, Mem)              // FMA  AVX512_F{kz|b32}-VL
  ASMJIT_INST_3x(vfmsub213ps, Vfmsub213ps, Zmm, Zmm, Zmm)              // FMA  AVX512_F{kz|er|b32}
  ASMJIT_INST_3x(vfmsub213ps, Vfmsub213ps, Zmm, Zmm, Mem)              // FMA  AVX512_F{kz|er|b32}
  ASMJIT_INST_3x(vfmsub213sd, Vfmsub213sd, Xmm, Xmm, Xmm)              // FMA  AVX512_F{kz|er}
  ASMJIT_INST_3x(vfmsub213sd, Vfmsub213sd, Xmm, Xmm, Mem)              // FMA  AVX512_F{kz|er}
  ASMJIT_INST_3x(vfmsub213ss, Vfmsub213ss, Xmm, Xmm, Xmm)              // FMA  AVX512_F{kz|er}
  ASMJIT_INST_3x(vfmsub213ss, Vfmsub213ss, Xmm, Xmm, Mem)              // FMA  AVX512_F{kz|er}
  ASMJIT_INST_3x(vfmsub231pd, Vfmsub231pd, Xmm, Xmm, Xmm)              // FMA  AVX512_F{kz|b64}-VL
  ASMJIT_INST_3x(vfmsub231pd, Vfmsub231pd, Xmm, Xmm, Mem)              // FMA  AVX512_F{kz|b64}-VL
  ASMJIT_INST_3x(vfmsub231pd, Vfmsub231pd, Ymm, Ymm, Ymm)              // FMA  AVX512_F{kz|b64}-VL
  ASMJIT_INST_3x(vfmsub231pd, Vfmsub231pd, Ymm, Ymm, Mem)              // FMA  AVX512_F{kz|b64}-VL
  ASMJIT_INST_3x(vfmsub231pd, Vfmsub231pd, Zmm, Zmm, Zmm)              // FMA  AVX512_F{kz|er|b64}
  ASMJIT_INST_3x(vfmsub231pd, Vfmsub231pd, Zmm, Zmm, Mem)              // FMA  AVX512_F{kz|er|b64}
  ASMJIT_INST_3x(vfmsub231ps, Vfmsub231ps, Xmm, Xmm, Xmm)              // FMA  AVX512_F{kz|b32}-VL
  ASMJIT_INST_3x(vfmsub231ps, Vfmsub231ps, Xmm, Xmm, Mem)              // FMA  AVX512_F{kz|b32}-VL
  ASMJIT_INST_3x(vfmsub231ps, Vfmsub231ps, Ymm, Ymm, Ymm)              // FMA  AVX512_F{kz|b32}-VL
  ASMJIT_INST_3x(vfmsub231ps, Vfmsub231ps, Ymm, Ymm, Mem)              // FMA  AVX512_F{kz|b32}-VL
  ASMJIT_INST_3x(vfmsub231ps, Vfmsub231ps, Zmm, Zmm, Zmm)              // FMA  AVX512_F{kz|er|b32}
  ASMJIT_INST_3x(vfmsub231ps, Vfmsub231ps, Zmm, Zmm, Mem)              // FMA  AVX512_F{kz|er|b32}
  ASMJIT_INST_3x(vfmsub231sd, Vfmsub231sd, Xmm, Xmm, Xmm)              // FMA  AVX512_F{kz|er}
  ASMJIT_INST_3x(vfmsub231sd, Vfmsub231sd, Xmm, Xmm, Mem)              // FMA  AVX512_F{kz|er}
  ASMJIT_INST_3x(vfmsub231ss, Vfmsub231ss, Xmm, Xmm, Xmm)              // FMA  AVX512_F{kz|er}
  ASMJIT_INST_3x(vfmsub231ss, Vfmsub231ss, Xmm, Xmm, Mem)              // FMA  AVX512_F{kz|er}
  ASMJIT_INST_3x(vfmsubadd132pd, Vfmsubadd132pd, Xmm, Xmm, Xmm)        // FMA  AVX512_F{kz|b64}-VL
  ASMJIT_INST_3x(vfmsubadd132pd, Vfmsubadd132pd, Xmm, Xmm, Mem)        // FMA  AVX512_F{kz|b64}-VL
  ASMJIT_INST_3x(vfmsubadd132pd, Vfmsubadd132pd, Ymm, Ymm, Ymm)        // FMA  AVX512_F{kz|b64}-VL
  ASMJIT_INST_3x(vfmsubadd132pd, Vfmsubadd132pd, Ymm, Ymm, Mem)        // FMA  AVX512_F{kz|b64}-VL
  ASMJIT_INST_3x(vfmsubadd132pd, Vfmsubadd132pd, Zmm, Zmm, Zmm)        // FMA  AVX512_F{kz|er|b64}
  ASMJIT_INST_3x(vfmsubadd132pd, Vfmsubadd132pd, Zmm, Zmm, Mem)        // FMA  AVX512_F{kz|er|b64}
  ASMJIT_INST_3x(vfmsubadd132ps, Vfmsubadd132ps, Xmm, Xmm, Xmm)        // FMA  AVX512_F{kz|b32}-VL
  ASMJIT_INST_3x(vfmsubadd132ps, Vfmsubadd132ps, Xmm, Xmm, Mem)        // FMA  AVX512_F{kz|b32}-VL
  ASMJIT_INST_3x(vfmsubadd132ps, Vfmsubadd132ps, Ymm, Ymm, Ymm)        // FMA  AVX512_F{kz|b32}-VL
  ASMJIT_INST_3x(vfmsubadd132ps, Vfmsubadd132ps, Ymm, Ymm, Mem)        // FMA  AVX512_F{kz|b32}-VL
  ASMJIT_INST_3x(vfmsubadd132ps, Vfmsubadd132ps, Zmm, Zmm, Zmm)        // FMA  AVX512_F{kz|er|b32}
  ASMJIT_INST_3x(vfmsubadd132ps, Vfmsubadd132ps, Zmm, Zmm, Mem)        // FMA  AVX512_F{kz|er|b32}
  ASMJIT_INST_3x(vfmsubadd213pd, Vfmsubadd213pd, Xmm, Xmm, Xmm)        // FMA  AVX512_F{kz|b64}-VL
  ASMJIT_INST_3x(vfmsubadd213pd, Vfmsubadd213pd, Xmm, Xmm, Mem)        // FMA  AVX512_F{kz|b64}-VL
  ASMJIT_INST_3x(vfmsubadd213pd, Vfmsubadd213pd, Ymm, Ymm, Ymm)        // FMA  AVX512_F{kz|b64}-VL
  ASMJIT_INST_3x(vfmsubadd213pd, Vfmsubadd213pd, Ymm, Ymm, Mem)        // FMA  AVX512_F{kz|b64}-VL
  ASMJIT_INST_3x(vfmsubadd213pd, Vfmsubadd213pd, Zmm, Zmm, Zmm)        // FMA  AVX512_F{kz|er|b64}
  ASMJIT_INST_3x(vfmsubadd213pd, Vfmsubadd213pd, Zmm, Zmm, Mem)        // FMA  AVX512_F{kz|er|b64}
  ASMJIT_INST_3x(vfmsubadd213ps, Vfmsubadd213ps, Xmm, Xmm, Xmm)        // FMA  AVX512_F{kz|b32}-VL
  ASMJIT_INST_3x(vfmsubadd213ps, Vfmsubadd213ps, Xmm, Xmm, Mem)        // FMA  AVX512_F{kz|b32}-VL
  ASMJIT_INST_3x(vfmsubadd213ps, Vfmsubadd213ps, Ymm, Ymm, Ymm)        // FMA  AVX512_F{kz|b32}-VL
  ASMJIT_INST_3x(vfmsubadd213ps, Vfmsubadd213ps, Ymm, Ymm, Mem)        // FMA  AVX512_F{kz|b32}-VL
  ASMJIT_INST_3x(vfmsubadd213ps, Vfmsubadd213ps, Zmm, Zmm, Zmm)        // FMA  AVX512_F{kz|er|b32}
  ASMJIT_INST_3x(vfmsubadd213ps, Vfmsubadd213ps, Zmm, Zmm, Mem)        // FMA  AVX512_F{kz|er|b32}
  ASMJIT_INST_3x(vfmsubadd231pd, Vfmsubadd231pd, Xmm, Xmm, Xmm)        // FMA  AVX512_F{kz|b64}-VL
  ASMJIT_INST_3x(vfmsubadd231pd, Vfmsubadd231pd, Xmm, Xmm, Mem)        // FMA  AVX512_F{kz|b64}-VL
  ASMJIT_INST_3x(vfmsubadd231pd, Vfmsubadd231pd, Ymm, Ymm, Ymm)        // FMA  AVX512_F{kz|b64}-VL
  ASMJIT_INST_3x(vfmsubadd231pd, Vfmsubadd231pd, Ymm, Ymm, Mem)        // FMA  AVX512_F{kz|b64}-VL
  ASMJIT_INST_3x(vfmsubadd231pd, Vfmsubadd231pd, Zmm, Zmm, Zmm)        // FMA  AVX512_F{kz|er|b64}
  ASMJIT_INST_3x(vfmsubadd231pd, Vfmsubadd231pd, Zmm, Zmm, Mem)        // FMA  AVX512_F{kz|er|b64}
  ASMJIT_INST_3x(vfmsubadd231ps, Vfmsubadd231ps, Xmm, Xmm, Xmm)        // FMA  AVX512_F{kz|b32}-VL
  ASMJIT_INST_3x(vfmsubadd231ps, Vfmsubadd231ps, Xmm, Xmm, Mem)        // FMA  AVX512_F{kz|b32}-VL
  ASMJIT_INST_3x(vfmsubadd231ps, Vfmsubadd231ps, Ymm, Ymm, Ymm)        // FMA  AVX512_F{kz|b32}-VL
  ASMJIT_INST_3x(vfmsubadd231ps, Vfmsubadd231ps, Ymm, Ymm, Mem)        // FMA  AVX512_F{kz|b32}-VL
  ASMJIT_INST_3x(vfmsubadd231ps, Vfmsubadd231ps, Zmm, Zmm, Zmm)        // FMA  AVX512_F{kz|er|b32}
  ASMJIT_INST_3x(vfmsubadd231ps, Vfmsubadd231ps, Zmm, Zmm, Mem)        // FMA  AVX512_F{kz|er|b32}
  ASMJIT_INST_3x(vfnmadd132pd, Vfnmadd132pd, Xmm, Xmm, Xmm)            // FMA  AVX512_F{kz|b64}-VL
  ASMJIT_INST_3x(vfnmadd132pd, Vfnmadd132pd, Xmm, Xmm, Mem)            // FMA  AVX512_F{kz|b64}-VL
  ASMJIT_INST_3x(vfnmadd132pd, Vfnmadd132pd, Ymm, Ymm, Ymm)            // FMA  AVX512_F{kz|b64}-VL
  ASMJIT_INST_3x(vfnmadd132pd, Vfnmadd132pd, Ymm, Ymm, Mem)            // FMA  AVX512_F{kz|b64}-VL
  ASMJIT_INST_3x(vfnmadd132pd, Vfnmadd132pd, Zmm, Zmm, Zmm)            // FMA  AVX512_F{kz|er|b64}
  ASMJIT_INST_3x(vfnmadd132pd, Vfnmadd132pd, Zmm, Zmm, Mem)            // FMA  AVX512_F{kz|er|b64}
  ASMJIT_INST_3x(vfnmadd132ps, Vfnmadd132ps, Xmm, Xmm, Xmm)            // FMA  AVX512_F{kz|b32}-VL
  ASMJIT_INST_3x(vfnmadd132ps, Vfnmadd132ps, Xmm, Xmm, Mem)            // FMA  AVX512_F{kz|b32}-VL
  ASMJIT_INST_3x(vfnmadd132ps, Vfnmadd132ps, Ymm, Ymm, Ymm)            // FMA  AVX512_F{kz|b32}-VL
  ASMJIT_INST_3x(vfnmadd132ps, Vfnmadd132ps, Ymm, Ymm, Mem)            // FMA  AVX512_F{kz|b32}-VL
  ASMJIT_INST_3x(vfnmadd132ps, Vfnmadd132ps, Zmm, Zmm, Zmm)            // FMA  AVX512_F{kz|er|b32}
  ASMJIT_INST_3x(vfnmadd132ps, Vfnmadd132ps, Zmm, Zmm, Mem)            // FMA  AVX512_F{kz|er|b32}
  ASMJIT_INST_3x(vfnmadd132sd, Vfnmadd132sd, Xmm, Xmm, Xmm)            // FMA  AVX512_F{kz|er}
  ASMJIT_INST_3x(vfnmadd132sd, Vfnmadd132sd, Xmm, Xmm, Mem)            // FMA  AVX512_F{kz|er}
  ASMJIT_INST_3x(vfnmadd132ss, Vfnmadd132ss, Xmm, Xmm, Xmm)            // FMA  AVX512_F{kz|er}
  ASMJIT_INST_3x(vfnmadd132ss, Vfnmadd132ss, Xmm, Xmm, Mem)            // FMA  AVX512_F{kz|er}
  ASMJIT_INST_3x(vfnmadd213pd, Vfnmadd213pd, Xmm, Xmm, Xmm)            // FMA  AVX512_F{kz|b64}-VL
  ASMJIT_INST_3x(vfnmadd213pd, Vfnmadd213pd, Xmm, Xmm, Mem)            // FMA  AVX512_F{kz|b64}-VL
  ASMJIT_INST_3x(vfnmadd213pd, Vfnmadd213pd, Ymm, Ymm, Ymm)            // FMA  AVX512_F{kz|b64}-VL
  ASMJIT_INST_3x(vfnmadd213pd, Vfnmadd213pd, Ymm, Ymm, Mem)            // FMA  AVX512_F{kz|b64}-VL
  ASMJIT_INST_3x(vfnmadd213pd, Vfnmadd213pd, Zmm, Zmm, Zmm)            // FMA  AVX512_F{kz|er|b64}
  ASMJIT_INST_3x(vfnmadd213pd, Vfnmadd213pd, Zmm, Zmm, Mem)            // FMA  AVX512_F{kz|er|b64}
  ASMJIT_INST_3x(vfnmadd213ps, Vfnmadd213ps, Xmm, Xmm, Xmm)            // FMA  AVX512_F{kz|b32}-VL
  ASMJIT_INST_3x(vfnmadd213ps, Vfnmadd213ps, Xmm, Xmm, Mem)            // FMA  AVX512_F{kz|b32}-VL
  ASMJIT_INST_3x(vfnmadd213ps, Vfnmadd213ps, Ymm, Ymm, Ymm)            // FMA  AVX512_F{kz|b32}-VL
  ASMJIT_INST_3x(vfnmadd213ps, Vfnmadd213ps, Ymm, Ymm, Mem)            // FMA  AVX512_F{kz|b32}-VL
  ASMJIT_INST_3x(vfnmadd213ps, Vfnmadd213ps, Zmm, Zmm, Zmm)            // FMA  AVX512_F{kz|er|b32}
  ASMJIT_INST_3x(vfnmadd213ps, Vfnmadd213ps, Zmm, Zmm, Mem)            // FMA  AVX512_F{kz|er|b32}
  ASMJIT_INST_3x(vfnmadd213sd, Vfnmadd213sd, Xmm, Xmm, Xmm)            // FMA  AVX512_F{kz|er}
  ASMJIT_INST_3x(vfnmadd213sd, Vfnmadd213sd, Xmm, Xmm, Mem)            // FMA  AVX512_F{kz|er}
  ASMJIT_INST_3x(vfnmadd213ss, Vfnmadd213ss, Xmm, Xmm, Xmm)            // FMA  AVX512_F{kz|er}
  ASMJIT_INST_3x(vfnmadd213ss, Vfnmadd213ss, Xmm, Xmm, Mem)            // FMA  AVX512_F{kz|er}
  ASMJIT_INST_3x(vfnmadd231pd, Vfnmadd231pd, Xmm, Xmm, Xmm)            // FMA  AVX512_F{kz|b64}-VL
  ASMJIT_INST_3x(vfnmadd231pd, Vfnmadd231pd, Xmm, Xmm, Mem)            // FMA  AVX512_F{kz|b64}-VL
  ASMJIT_INST_3x(vfnmadd231pd, Vfnmadd231pd, Ymm, Ymm, Ymm)            // FMA  AVX512_F{kz|b64}-VL
  ASMJIT_INST_3x(vfnmadd231pd, Vfnmadd231pd, Ymm, Ymm, Mem)            // FMA  AVX512_F{kz|b64}-VL
  ASMJIT_INST_3x(vfnmadd231pd, Vfnmadd231pd, Zmm, Zmm, Zmm)            // FMA  AVX512_F{kz|er|b64}
  ASMJIT_INST_3x(vfnmadd231pd, Vfnmadd231pd, Zmm, Zmm, Mem)            // FMA  AVX512_F{kz|er|b64}
  ASMJIT_INST_3x(vfnmadd231ps, Vfnmadd231ps, Xmm, Xmm, Xmm)            // FMA  AVX512_F{kz|b32}-VL
  ASMJIT_INST_3x(vfnmadd231ps, Vfnmadd231ps, Xmm, Xmm, Mem)            // FMA  AVX512_F{kz|b32}-VL
  ASMJIT_INST_3x(vfnmadd231ps, Vfnmadd231ps, Ymm, Ymm, Ymm)            // FMA  AVX512_F{kz|b32}-VL
  ASMJIT_INST_3x(vfnmadd231ps, Vfnmadd231ps, Ymm, Ymm, Mem)            // FMA  AVX512_F{kz|b32}-VL
  ASMJIT_INST_3x(vfnmadd231ps, Vfnmadd231ps, Zmm, Zmm, Zmm)            // FMA  AVX512_F{kz|er|b32}
  ASMJIT_INST_3x(vfnmadd231ps, Vfnmadd231ps, Zmm, Zmm, Mem)            // FMA  AVX512_F{kz|er|b32}
  ASMJIT_INST_3x(vfnmadd231sd, Vfnmadd231sd, Xmm, Xmm, Xmm)            // FMA  AVX512_F{kz|er}
  ASMJIT_INST_3x(vfnmadd231sd, Vfnmadd231sd, Xmm, Xmm, Mem)            // FMA  AVX512_F{kz|er}
  ASMJIT_INST_3x(vfnmadd231ss, Vfnmadd231ss, Xmm, Xmm, Xmm)            // FMA  AVX512_F{kz|er}
  ASMJIT_INST_3x(vfnmadd231ss, Vfnmadd231ss, Xmm, Xmm, Mem)            // FMA  AVX512_F{kz|er}
  ASMJIT_INST_3x(vfnmsub132pd, Vfnmsub132pd, Xmm, Xmm, Xmm)            // FMA  AVX512_F{kz|b64}-VL
  ASMJIT_INST_3x(vfnmsub132pd, Vfnmsub132pd, Xmm, Xmm, Mem)            // FMA  AVX512_F{kz|b64}-VL
  ASMJIT_INST_3x(vfnmsub132pd, Vfnmsub132pd, Ymm, Ymm, Ymm)            // FMA  AVX512_F{kz|b64}-VL
  ASMJIT_INST_3x(vfnmsub132pd, Vfnmsub132pd, Ymm, Ymm, Mem)            // FMA  AVX512_F{kz|b64}-VL
  ASMJIT_INST_3x(vfnmsub132pd, Vfnmsub132pd, Zmm, Zmm, Zmm)            // FMA  AVX512_F{kz|er|b64}
  ASMJIT_INST_3x(vfnmsub132pd, Vfnmsub132pd, Zmm, Zmm, Mem)            // FMA  AVX512_F{kz|er|b64}
  ASMJIT_INST_3x(vfnmsub132ps, Vfnmsub132ps, Xmm, Xmm, Xmm)            // FMA  AVX512_F{kz|b32}-VL
  ASMJIT_INST_3x(vfnmsub132ps, Vfnmsub132ps, Xmm, Xmm, Mem)            // FMA  AVX512_F{kz|b32}-VL
  ASMJIT_INST_3x(vfnmsub132ps, Vfnmsub132ps, Ymm, Ymm, Ymm)            // FMA  AVX512_F{kz|b32}-VL
  ASMJIT_INST_3x(vfnmsub132ps, Vfnmsub132ps, Ymm, Ymm, Mem)            // FMA  AVX512_F{kz|b32}-VL
  ASMJIT_INST_3x(vfnmsub132ps, Vfnmsub132ps, Zmm, Zmm, Zmm)            // FMA  AVX512_F{kz|er|b32}
  ASMJIT_INST_3x(vfnmsub132ps, Vfnmsub132ps, Zmm, Zmm, Mem)            // FMA  AVX512_F{kz|er|b32}
  ASMJIT_INST_3x(vfnmsub132sd, Vfnmsub132sd, Xmm, Xmm, Xmm)            // FMA  AVX512_F{kz|er}
  ASMJIT_INST_3x(vfnmsub132sd, Vfnmsub132sd, Xmm, Xmm, Mem)            // FMA  AVX512_F{kz|er}
  ASMJIT_INST_3x(vfnmsub132ss, Vfnmsub132ss, Xmm, Xmm, Xmm)            // FMA  AVX512_F{kz|er}
  ASMJIT_INST_3x(vfnmsub132ss, Vfnmsub132ss, Xmm, Xmm, Mem)            // FMA  AVX512_F{kz|er}
  ASMJIT_INST_3x(vfnmsub213pd, Vfnmsub213pd, Xmm, Xmm, Xmm)            // FMA  AVX512_F{kz|b64}-VL
  ASMJIT_INST_3x(vfnmsub213pd, Vfnmsub213pd, Xmm, Xmm, Mem)            // FMA  AVX512_F{kz|b64}-VL
  ASMJIT_INST_3x(vfnmsub213pd, Vfnmsub213pd, Ymm, Ymm, Ymm)            // FMA  AVX512_F{kz|b64}-VL
  ASMJIT_INST_3x(vfnmsub213pd, Vfnmsub213pd, Ymm, Ymm, Mem)            // FMA  AVX512_F{kz|b64}-VL
  ASMJIT_INST_3x(vfnmsub213pd, Vfnmsub213pd, Zmm, Zmm, Zmm)            // FMA  AVX512_F{kz|er|b64}
  ASMJIT_INST_3x(vfnmsub213pd, Vfnmsub213pd, Zmm, Zmm, Mem)            // FMA  AVX512_F{kz|er|b64}
  ASMJIT_INST_3x(vfnmsub213ps, Vfnmsub213ps, Xmm, Xmm, Xmm)            // FMA  AVX512_F{kz|b32}-VL
  ASMJIT_INST_3x(vfnmsub213ps, Vfnmsub213ps, Xmm, Xmm, Mem)            // FMA  AVX512_F{kz|b32}-VL
  ASMJIT_INST_3x(vfnmsub213ps, Vfnmsub213ps, Ymm, Ymm, Ymm)            // FMA  AVX512_F{kz|b32}-VL
  ASMJIT_INST_3x(vfnmsub213ps, Vfnmsub213ps, Ymm, Ymm, Mem)            // FMA  AVX512_F{kz|b32}-VL
  ASMJIT_INST_3x(vfnmsub213ps, Vfnmsub213ps, Zmm, Zmm, Zmm)            // FMA  AVX512_F{kz|er|b32}
  ASMJIT_INST_3x(vfnmsub213ps, Vfnmsub213ps, Zmm, Zmm, Mem)            // FMA  AVX512_F{kz|er|b32}
  ASMJIT_INST_3x(vfnmsub213sd, Vfnmsub213sd, Xmm, Xmm, Xmm)            // FMA  AVX512_F{kz|er}
  ASMJIT_INST_3x(vfnmsub213sd, Vfnmsub213sd, Xmm, Xmm, Mem)            // FMA  AVX512_F{kz|er}
  ASMJIT_INST_3x(vfnmsub213ss, Vfnmsub213ss, Xmm, Xmm, Xmm)            // FMA  AVX512_F{kz|er}
  ASMJIT_INST_3x(vfnmsub213ss, Vfnmsub213ss, Xmm, Xmm, Mem)            // FMA  AVX512_F{kz|er}
  ASMJIT_INST_3x(vfnmsub231pd, Vfnmsub231pd, Xmm, Xmm, Xmm)            // FMA  AVX512_F{kz|b64}-VL
  ASMJIT_INST_3x(vfnmsub231pd, Vfnmsub231pd, Xmm, Xmm, Mem)            // FMA  AVX512_F{kz|b64}-VL
  ASMJIT_INST_3x(vfnmsub231pd, Vfnmsub231pd, Ymm, Ymm, Ymm)            // FMA  AVX512_F{kz|b64}-VL
  ASMJIT_INST_3x(vfnmsub231pd, Vfnmsub231pd, Ymm, Ymm, Mem)            // FMA  AVX512_F{kz|b64}-VL
  ASMJIT_INST_3x(vfnmsub231pd, Vfnmsub231pd, Zmm, Zmm, Zmm)            // FMA  AVX512_F{kz|er|b64}
  ASMJIT_INST_3x(vfnmsub231pd, Vfnmsub231pd, Zmm, Zmm, Mem)            // FMA  AVX512_F{kz|er|b64}
  ASMJIT_INST_3x(vfnmsub231ps, Vfnmsub231ps, Xmm, Xmm, Xmm)            // FMA  AVX512_F{kz|b32}-VL
  ASMJIT_INST_3x(vfnmsub231ps, Vfnmsub231ps, Xmm, Xmm, Mem)            // FMA  AVX512_F{kz|b32}-VL
  ASMJIT_INST_3x(vfnmsub231ps, Vfnmsub231ps, Ymm, Ymm, Ymm)            // FMA  AVX512_F{kz|b32}-VL
  ASMJIT_INST_3x(vfnmsub231ps, Vfnmsub231ps, Ymm, Ymm, Mem)            // FMA  AVX512_F{kz|b32}-VL
  ASMJIT_INST_3x(vfnmsub231ps, Vfnmsub231ps, Zmm, Zmm, Zmm)            // FMA  AVX512_F{kz|er|b32}
  ASMJIT_INST_3x(vfnmsub231ps, Vfnmsub231ps, Zmm, Zmm, Mem)            // FMA  AVX512_F{kz|er|b32}
  ASMJIT_INST_3x(vfnmsub231sd, Vfnmsub231sd, Xmm, Xmm, Xmm)            // FMA  AVX512_F{kz|er}
  ASMJIT_INST_3x(vfnmsub231sd, Vfnmsub231sd, Xmm, Xmm, Mem)            // FMA  AVX512_F{kz|er}
  ASMJIT_INST_3x(vfnmsub231ss, Vfnmsub231ss, Xmm, Xmm, Xmm)            // FMA  AVX512_F{kz|er}
  ASMJIT_INST_3x(vfnmsub231ss, Vfnmsub231ss, Xmm, Xmm, Mem)            // FMA  AVX512_F{kz|er}
  ASMJIT_INST_3i(vfpclasspd, Vfpclasspd, KReg, Xmm, Imm)               //      AVX512_DQ{k|b64}-VL
  ASMJIT_INST_3i(vfpclasspd, Vfpclasspd, KReg, Mem, Imm)               //      AVX512_DQ{k|b64} AVX512_DQ{k|b64}-VL
  ASMJIT_INST_3i(vfpclasspd, Vfpclasspd, KReg, Ymm, Imm)               //      AVX512_DQ{k|b64}-VL
  ASMJIT_INST_3i(vfpclasspd, Vfpclasspd, KReg, Zmm, Imm)               //      AVX512_DQ{k|b64}
  ASMJIT_INST_3i(vfpclassps, Vfpclassps, KReg, Xmm, Imm)               //      AVX512_DQ{k|b32}-VL
  ASMJIT_INST_3i(vfpclassps, Vfpclassps, KReg, Mem, Imm)               //      AVX512_DQ{k|b32} AVX512_DQ{k|b32}-VL
  ASMJIT_INST_3i(vfpclassps, Vfpclassps, KReg, Ymm, Imm)               //      AVX512_DQ{k|b32}-VL
  ASMJIT_INST_3i(vfpclassps, Vfpclassps, KReg, Zmm, Imm)               //      AVX512_DQ{k|b32}
  ASMJIT_INST_3i(vfpclasssd, Vfpclasssd, KReg, Xmm, Imm)               //      AVX512_DQ{k}
  ASMJIT_INST_3i(vfpclasssd, Vfpclasssd, KReg, Mem, Imm)               //      AVX512_DQ{k}
  ASMJIT_INST_3i(vfpclassss, Vfpclassss, KReg, Xmm, Imm)               //      AVX512_DQ{k}
  ASMJIT_INST_3i(vfpclassss, Vfpclassss, KReg, Mem, Imm)               //      AVX512_DQ{k}
  ASMJIT_INST_3x(vgatherdpd, Vgatherdpd, Xmm, Mem, Xmm)                // AVX2
  ASMJIT_INST_3x(vgatherdpd, Vgatherdpd, Ymm, Mem, Ymm)                // AVX2
  ASMJIT_INST_2x(vgatherdpd, Vgatherdpd, Xmm, Mem)                     //      AVX512_F{k}-VL
  ASMJIT_INST_2x(vgatherdpd, Vgatherdpd, Ymm, Mem)                     //      AVX512_F{k}-VL
  ASMJIT_INST_2x(vgatherdpd, Vgatherdpd, Zmm, Mem)                     //      AVX512_F{k}
  ASMJIT_INST_3x(vgatherdps, Vgatherdps, Xmm, Mem, Xmm)                // AVX2
  ASMJIT_INST_3x(vgatherdps, Vgatherdps, Ymm, Mem, Ymm)                // AVX2
  ASMJIT_INST_2x(vgatherdps, Vgatherdps, Xmm, Mem)                     //      AVX512_F{k}-VL
  ASMJIT_INST_2x(vgatherdps, Vgatherdps, Ymm, Mem)                     //      AVX512_F{k}-VL
  ASMJIT_INST_2x(vgatherdps, Vgatherdps, Zmm, Mem)                     //      AVX512_F{k}
  ASMJIT_INST_1x(vgatherpf0dpd, Vgatherpf0dpd, Mem)                    //      AVX512_PF{k}
  ASMJIT_INST_1x(vgatherpf0dps, Vgatherpf0dps, Mem)                    //      AVX512_PF{k}
  ASMJIT_INST_1x(vgatherpf0qpd, Vgatherpf0qpd, Mem)                    //      AVX512_PF{k}
  ASMJIT_INST_1x(vgatherpf0qps, Vgatherpf0qps, Mem)                    //      AVX512_PF{k}
  ASMJIT_INST_1x(vgatherpf1dpd, Vgatherpf1dpd, Mem)                    //      AVX512_PF{k}
  ASMJIT_INST_1x(vgatherpf1dps, Vgatherpf1dps, Mem)                    //      AVX512_PF{k}
  ASMJIT_INST_1x(vgatherpf1qpd, Vgatherpf1qpd, Mem)                    //      AVX512_PF{k}
  ASMJIT_INST_1x(vgatherpf1qps, Vgatherpf1qps, Mem)                    //      AVX512_PF{k}
  ASMJIT_INST_3x(vgatherqpd, Vgatherqpd, Xmm, Mem, Xmm)                // AVX2
  ASMJIT_INST_3x(vgatherqpd, Vgatherqpd, Ymm, Mem, Ymm)                // AVX2
  ASMJIT_INST_2x(vgatherqpd, Vgatherqpd, Xmm, Mem)                     //      AVX512_F{k}-VL
  ASMJIT_INST_2x(vgatherqpd, Vgatherqpd, Ymm, Mem)                     //      AVX512_F{k}-VL
  ASMJIT_INST_2x(vgatherqpd, Vgatherqpd, Zmm, Mem)                     //      AVX512_F{k}
  ASMJIT_INST_3x(vgatherqps, Vgatherqps, Xmm, Mem, Xmm)                // AVX2
  ASMJIT_INST_2x(vgatherqps, Vgatherqps, Xmm, Mem)                     //      AVX512_F{k}-VL
  ASMJIT_INST_2x(vgatherqps, Vgatherqps, Ymm, Mem)                     //      AVX512_F{k}-VL
  ASMJIT_INST_2x(vgatherqps, Vgatherqps, Zmm, Mem)                     //      AVX512_F{k}
  ASMJIT_INST_2x(vgetexppd, Vgetexppd, Xmm, Xmm)                       //      AVX512_F{kz|b64}-VL
  ASMJIT_INST_2x(vgetexppd, Vgetexppd, Xmm, Mem)                       //      AVX512_F{kz|b64}-VL
  ASMJIT_INST_2x(vgetexppd, Vgetexppd, Ymm, Ymm)                       //      AVX512_F{kz|b64}-VL
  ASMJIT_INST_2x(vgetexppd, Vgetexppd, Ymm, Mem)                       //      AVX512_F{kz|b64}-VL
  ASMJIT_INST_2x(vgetexppd, Vgetexppd, Zmm, Zmm)                       //      AVX512_F{kz|sae|b64}
  ASMJIT_INST_2x(vgetexppd, Vgetexppd, Zmm, Mem)                       //      AVX512_F{kz|sae|b64}
  ASMJIT_INST_2x(vgetexpps, Vgetexpps, Xmm, Xmm)                       //      AVX512_F{kz|b32}-VL
  ASMJIT_INST_2x(vgetexpps, Vgetexpps, Xmm, Mem)                       //      AVX512_F{kz|b32}-VL
  ASMJIT_INST_2x(vgetexpps, Vgetexpps, Ymm, Ymm)                       //      AVX512_F{kz|b32}-VL
  ASMJIT_INST_2x(vgetexpps, Vgetexpps, Ymm, Mem)                       //      AVX512_F{kz|b32}-VL
  ASMJIT_INST_2x(vgetexpps, Vgetexpps, Zmm, Zmm)                       //      AVX512_F{kz|sae|b32}
  ASMJIT_INST_2x(vgetexpps, Vgetexpps, Zmm, Mem)                       //      AVX512_F{kz|sae|b32}
  ASMJIT_INST_3x(vgetexpsd, Vgetexpsd, Xmm, Xmm, Xmm)                  //      AVX512_F{kz|sae}
  ASMJIT_INST_3x(vgetexpsd, Vgetexpsd, Xmm, Xmm, Mem)                  //      AVX512_F{kz|sae}
  ASMJIT_INST_3x(vgetexpss, Vgetexpss, Xmm, Xmm, Xmm)                  //      AVX512_F{kz|sae}
  ASMJIT_INST_3x(vgetexpss, Vgetexpss, Xmm, Xmm, Mem)                  //      AVX512_F{kz|sae}
  ASMJIT_INST_3i(vgetmantpd, Vgetmantpd, Xmm, Xmm, Imm)                //      AVX512_F{kz|b64}-VL
  ASMJIT_INST_3i(vgetmantpd, Vgetmantpd, Xmm, Mem, Imm)                //      AVX512_F{kz|b64}-VL
  ASMJIT_INST_3i(vgetmantpd, Vgetmantpd, Ymm, Ymm, Imm)                //      AVX512_F{kz|b64}-VL
  ASMJIT_INST_3i(vgetmantpd, Vgetmantpd, Ymm, Mem, Imm)                //      AVX512_F{kz|b64}-VL
  ASMJIT_INST_3i(vgetmantpd, Vgetmantpd, Zmm, Zmm, Imm)                //      AVX512_F{kz|sae|b64}
  ASMJIT_INST_3i(vgetmantpd, Vgetmantpd, Zmm, Mem, Imm)                //      AVX512_F{kz|sae|b64}
  ASMJIT_INST_3i(vgetmantps, Vgetmantps, Xmm, Xmm, Imm)                //      AVX512_F{kz|b32}-VL
  ASMJIT_INST_3i(vgetmantps, Vgetmantps, Xmm, Mem, Imm)                //      AVX512_F{kz|b32}-VL
  ASMJIT_INST_3i(vgetmantps, Vgetmantps, Ymm, Ymm, Imm)                //      AVX512_F{kz|b32}-VL
  ASMJIT_INST_3i(vgetmantps, Vgetmantps, Ymm, Mem, Imm)                //      AVX512_F{kz|b32}-VL
  ASMJIT_INST_3i(vgetmantps, Vgetmantps, Zmm, Zmm, Imm)                //      AVX512_F{kz|sae|b32}
  ASMJIT_INST_3i(vgetmantps, Vgetmantps, Zmm, Mem, Imm)                //      AVX512_F{kz|sae|b32}
  ASMJIT_INST_4i(vgetmantsd, Vgetmantsd, Xmm, Xmm, Xmm, Imm)           //      AVX512_F{kz|sae}
  ASMJIT_INST_4i(vgetmantsd, Vgetmantsd, Xmm, Xmm, Mem, Imm)           //      AVX512_F{kz|sae}
  ASMJIT_INST_4i(vgetmantss, Vgetmantss, Xmm, Xmm, Xmm, Imm)           //      AVX512_F{kz|sae}
  ASMJIT_INST_4i(vgetmantss, Vgetmantss, Xmm, Xmm, Mem, Imm)           //      AVX512_F{kz|sae}
  ASMJIT_INST_3x(vhaddpd, Vhaddpd, Xmm, Xmm, Xmm)                      // AVX
  ASMJIT_INST_3x(vhaddpd, Vhaddpd, Xmm, Xmm, Mem)                      // AVX
  ASMJIT_INST_3x(vhaddpd, Vhaddpd, Ymm, Ymm, Ymm)                      // AVX
  ASMJIT_INST_3x(vhaddpd, Vhaddpd, Ymm, Ymm, Mem)                      // AVX
  ASMJIT_INST_3x(vhaddps, Vhaddps, Xmm, Xmm, Xmm)                      // AVX
  ASMJIT_INST_3x(vhaddps, Vhaddps, Xmm, Xmm, Mem)                      // AVX
  ASMJIT_INST_3x(vhaddps, Vhaddps, Ymm, Ymm, Ymm)                      // AVX
  ASMJIT_INST_3x(vhaddps, Vhaddps, Ymm, Ymm, Mem)                      // AVX
  ASMJIT_INST_3x(vhsubpd, Vhsubpd, Xmm, Xmm, Xmm)                      // AVX
  ASMJIT_INST_3x(vhsubpd, Vhsubpd, Xmm, Xmm, Mem)                      // AVX
  ASMJIT_INST_3x(vhsubpd, Vhsubpd, Ymm, Ymm, Ymm)                      // AVX
  ASMJIT_INST_3x(vhsubpd, Vhsubpd, Ymm, Ymm, Mem)                      // AVX
  ASMJIT_INST_3x(vhsubps, Vhsubps, Xmm, Xmm, Xmm)                      // AVX
  ASMJIT_INST_3x(vhsubps, Vhsubps, Xmm, Xmm, Mem)                      // AVX
  ASMJIT_INST_3x(vhsubps, Vhsubps, Ymm, Ymm, Ymm)                      // AVX
  ASMJIT_INST_3x(vhsubps, Vhsubps, Ymm, Ymm, Mem)                      // AVX
  ASMJIT_INST_4i(vinsertf128, Vinsertf128, Ymm, Ymm, Xmm, Imm)         // AVX
  ASMJIT_INST_4i(vinsertf128, Vinsertf128, Ymm, Ymm, Mem, Imm)         // AVX
  ASMJIT_INST_4i(vinsertf32x4, Vinsertf32x4, Ymm, Ymm, Xmm, Imm)       //      AVX512_F{kz}-VL
  ASMJIT_INST_4i(vinsertf32x4, Vinsertf32x4, Ymm, Ymm, Mem, Imm)       //      AVX512_F{kz}-VL
  ASMJIT_INST_4i(vinsertf32x4, Vinsertf32x4, Zmm, Zmm, Xmm, Imm)       //      AVX512_F{kz}
  ASMJIT_INST_4i(vinsertf32x4, Vinsertf32x4, Zmm, Zmm, Mem, Imm)       //      AVX512_F{kz}
  ASMJIT_INST_4i(vinsertf32x8, Vinsertf32x8, Zmm, Zmm, Ymm, Imm)       //      AVX512_DQ{kz}
  ASMJIT_INST_4i(vinsertf32x8, Vinsertf32x8, Zmm, Zmm, Mem, Imm)       //      AVX512_DQ{kz}
  ASMJIT_INST_4i(vinsertf64x2, Vinsertf64x2, Ymm, Ymm, Xmm, Imm)       //      AVX512_DQ{kz}-VL
  ASMJIT_INST_4i(vinsertf64x2, Vinsertf64x2, Ymm, Ymm, Mem, Imm)       //      AVX512_DQ{kz}-VL
  ASMJIT_INST_4i(vinsertf64x2, Vinsertf64x2, Zmm, Zmm, Xmm, Imm)       //      AVX512_DQ{kz}
  ASMJIT_INST_4i(vinsertf64x2, Vinsertf64x2, Zmm, Zmm, Mem, Imm)       //      AVX512_DQ{kz}
  ASMJIT_INST_4i(vinsertf64x4, Vinsertf64x4, Zmm, Zmm, Ymm, Imm)       //      AVX512_F{kz}
  ASMJIT_INST_4i(vinsertf64x4, Vinsertf64x4, Zmm, Zmm, Mem, Imm)       //      AVX512_F{kz}
  ASMJIT_INST_4i(vinserti128, Vinserti128, Ymm, Ymm, Xmm, Imm)         // AVX2
  ASMJIT_INST_4i(vinserti128, Vinserti128, Ymm, Ymm, Mem, Imm)         // AVX2
  ASMJIT_INST_4i(vinserti32x4, Vinserti32x4, Ymm, Ymm, Xmm, Imm)       //      AVX512_F{kz}-VL
  ASMJIT_INST_4i(vinserti32x4, Vinserti32x4, Ymm, Ymm, Mem, Imm)       //      AVX512_F{kz}-VL
  ASMJIT_INST_4i(vinserti32x4, Vinserti32x4, Zmm, Zmm, Xmm, Imm)       //      AVX512_F{kz}
  ASMJIT_INST_4i(vinserti32x4, Vinserti32x4, Zmm, Zmm, Mem, Imm)       //      AVX512_F{kz}
  ASMJIT_INST_4i(vinserti32x8, Vinserti32x8, Zmm, Zmm, Ymm, Imm)       //      AVX512_DQ{kz}
  ASMJIT_INST_4i(vinserti32x8, Vinserti32x8, Zmm, Zmm, Mem, Imm)       //      AVX512_DQ{kz}
  ASMJIT_INST_4i(vinserti64x2, Vinserti64x2, Ymm, Ymm, Xmm, Imm)       //      AVX512_DQ{kz}-VL
  ASMJIT_INST_4i(vinserti64x2, Vinserti64x2, Ymm, Ymm, Mem, Imm)       //      AVX512_DQ{kz}-VL
  ASMJIT_INST_4i(vinserti64x2, Vinserti64x2, Zmm, Zmm, Xmm, Imm)       //      AVX512_DQ{kz}
  ASMJIT_INST_4i(vinserti64x2, Vinserti64x2, Zmm, Zmm, Mem, Imm)       //      AVX512_DQ{kz}
  ASMJIT_INST_4i(vinserti64x4, Vinserti64x4, Zmm, Zmm, Ymm, Imm)       //      AVX512_F{kz}
  ASMJIT_INST_4i(vinserti64x4, Vinserti64x4, Zmm, Zmm, Mem, Imm)       //      AVX512_F{kz}
  ASMJIT_INST_4i(vinsertps, Vinsertps, Xmm, Xmm, Xmm, Imm)             // AVX  AVX512_F
  ASMJIT_INST_4i(vinsertps, Vinsertps, Xmm, Xmm, Mem, Imm)             // AVX  AVX512_F
  ASMJIT_INST_2x(vlddqu, Vlddqu, Xmm, Mem)                             // AVX
  ASMJIT_INST_2x(vlddqu, Vlddqu, Ymm, Mem)                             // AVX
  ASMJIT_INST_1x(vldmxcsr, Vldmxcsr, Mem)                              // AVX
  ASMJIT_INST_3x(vmaskmovdqu, Vmaskmovdqu, Xmm, Xmm, DS_ZDI)           // AVX  [EXPLICIT]
  ASMJIT_INST_3x(vmaskmovpd, Vmaskmovpd, Mem, Xmm, Xmm)                // AVX
  ASMJIT_INST_3x(vmaskmovpd, Vmaskmovpd, Mem, Ymm, Ymm)                // AVX
  ASMJIT_INST_3x(vmaskmovpd, Vmaskmovpd, Xmm, Xmm, Mem)                // AVX
  ASMJIT_INST_3x(vmaskmovpd, Vmaskmovpd, Ymm, Ymm, Mem)                // AVX
  ASMJIT_INST_3x(vmaskmovps, Vmaskmovps, Mem, Xmm, Xmm)                // AVX
  ASMJIT_INST_3x(vmaskmovps, Vmaskmovps, Mem, Ymm, Ymm)                // AVX
  ASMJIT_INST_3x(vmaskmovps, Vmaskmovps, Xmm, Xmm, Mem)                // AVX
  ASMJIT_INST_3x(vmaskmovps, Vmaskmovps, Ymm, Ymm, Mem)                // AVX
  ASMJIT_INST_3x(vmaxpd, Vmaxpd, Xmm, Xmm, Xmm)                        // AVX  AVX512_F{kz|b64}-VL
  ASMJIT_INST_3x(vmaxpd, Vmaxpd, Xmm, Xmm, Mem)                        // AVX  AVX512_F{kz|b64}-VL
  ASMJIT_INST_3x(vmaxpd, Vmaxpd, Ymm, Ymm, Ymm)                        // AVX  AVX512_F{kz|b64}-VL
  ASMJIT_INST_3x(vmaxpd, Vmaxpd, Ymm, Ymm, Mem)                        // AVX  AVX512_F{kz|b64}-VL
  ASMJIT_INST_3x(vmaxpd, Vmaxpd, Zmm, Zmm, Zmm)                        //      AVX512_F{kz|sae|b64}
  ASMJIT_INST_3x(vmaxpd, Vmaxpd, Zmm, Zmm, Mem)                        //      AVX512_F{kz|sae|b64}
  ASMJIT_INST_3x(vmaxps, Vmaxps, Xmm, Xmm, Xmm)                        // AVX  AVX512_F{kz|b32}-VL
  ASMJIT_INST_3x(vmaxps, Vmaxps, Xmm, Xmm, Mem)                        // AVX  AVX512_F{kz|b32}-VL
  ASMJIT_INST_3x(vmaxps, Vmaxps, Ymm, Ymm, Ymm)                        // AVX  AVX512_F{kz|b32}-VL
  ASMJIT_INST_3x(vmaxps, Vmaxps, Ymm, Ymm, Mem)                        // AVX  AVX512_F{kz|b32}-VL
  ASMJIT_INST_3x(vmaxps, Vmaxps, Zmm, Zmm, Zmm)                        //      AVX512_F{kz|sae|b32}
  ASMJIT_INST_3x(vmaxps, Vmaxps, Zmm, Zmm, Mem)                        //      AVX512_F{kz|sae|b32}
  ASMJIT_INST_3x(vmaxsd, Vmaxsd, Xmm, Xmm, Xmm)                        // AVX  AVX512_F{kz|sae}-VL
  ASMJIT_INST_3x(vmaxsd, Vmaxsd, Xmm, Xmm, Mem)                        // AVX  AVX512_F{kz|sae}-VL
  ASMJIT_INST_3x(vmaxss, Vmaxss, Xmm, Xmm, Xmm)                        // AVX  AVX512_F{kz|sae}-VL
  ASMJIT_INST_3x(vmaxss, Vmaxss, Xmm, Xmm, Mem)                        // AVX  AVX512_F{kz|sae}-VL
  ASMJIT_INST_3x(vminpd, Vminpd, Xmm, Xmm, Xmm)                        // AVX  AVX512_F{kz|b64}-VL
  ASMJIT_INST_3x(vminpd, Vminpd, Xmm, Xmm, Mem)                        // AVX  AVX512_F{kz|b64}-VL
  ASMJIT_INST_3x(vminpd, Vminpd, Ymm, Ymm, Ymm)                        // AVX  AVX512_F{kz|b64}-VL
  ASMJIT_INST_3x(vminpd, Vminpd, Ymm, Ymm, Mem)                        // AVX  AVX512_F{kz|b64}-VL
  ASMJIT_INST_3x(vminpd, Vminpd, Zmm, Zmm, Zmm)                        //      AVX512_F{kz|sae|b64}
  ASMJIT_INST_3x(vminpd, Vminpd, Zmm, Zmm, Mem)                        //      AVX512_F{kz|sae|b64}
  ASMJIT_INST_3x(vminps, Vminps, Xmm, Xmm, Xmm)                        // AVX  AVX512_F{kz|b32}-VL
  ASMJIT_INST_3x(vminps, Vminps, Xmm, Xmm, Mem)                        // AVX  AVX512_F{kz|b32}-VL
  ASMJIT_INST_3x(vminps, Vminps, Ymm, Ymm, Ymm)                        // AVX  AVX512_F{kz|b32}-VL
  ASMJIT_INST_3x(vminps, Vminps, Ymm, Ymm, Mem)                        // AVX  AVX512_F{kz|b32}-VL
  ASMJIT_INST_3x(vminps, Vminps, Zmm, Zmm, Zmm)                        //      AVX512_F{kz|sae|b32}
  ASMJIT_INST_3x(vminps, Vminps, Zmm, Zmm, Mem)                        //      AVX512_F{kz|sae|b32}
  ASMJIT_INST_3x(vminsd, Vminsd, Xmm, Xmm, Xmm)                        // AVX  AVX512_F{kz|sae}-VL
  ASMJIT_INST_3x(vminsd, Vminsd, Xmm, Xmm, Mem)                        // AVX  AVX512_F{kz|sae}-VL
  ASMJIT_INST_3x(vminss, Vminss, Xmm, Xmm, Xmm)                        // AVX  AVX512_F{kz|sae}-VL
  ASMJIT_INST_3x(vminss, Vminss, Xmm, Xmm, Mem)                        // AVX  AVX512_F{kz|sae}-VL
  ASMJIT_INST_2x(vmovapd, Vmovapd, Xmm, Xmm)                           // AVX  AVX512_F{kz}-VL
  ASMJIT_INST_2x(vmovapd, Vmovapd, Xmm, Mem)                           // AVX  AVX512_F{kz}-VL
  ASMJIT_INST_2x(vmovapd, Vmovapd, Mem, Xmm)                           // AVX  AVX512_F{kz}-VL
  ASMJIT_INST_2x(vmovapd, Vmovapd, Ymm, Ymm)                           // AVX  AVX512_F{kz}-VL
  ASMJIT_INST_2x(vmovapd, Vmovapd, Ymm, Mem)                           // AVX  AVX512_F{kz}-VL
  ASMJIT_INST_2x(vmovapd, Vmovapd, Mem, Ymm)                           // AVX  AVX512_F{kz}-VL
  ASMJIT_INST_2x(vmovapd, Vmovapd, Zmm, Zmm)                           //      AVX512_F{kz}
  ASMJIT_INST_2x(vmovapd, Vmovapd, Zmm, Mem)                           //      AVX512_F{kz}
  ASMJIT_INST_2x(vmovapd, Vmovapd, Mem, Zmm)                           //      AVX512_F{kz}
  ASMJIT_INST_2x(vmovaps, Vmovaps, Xmm, Xmm)                           // AVX  AVX512_F{kz}-VL
  ASMJIT_INST_2x(vmovaps, Vmovaps, Xmm, Mem)                           // AVX  AVX512_F{kz}-VL
  ASMJIT_INST_2x(vmovaps, Vmovaps, Mem, Xmm)                           // AVX  AVX512_F{kz}-VL
  ASMJIT_INST_2x(vmovaps, Vmovaps, Ymm, Ymm)                           // AVX  AVX512_F{kz}-VL
  ASMJIT_INST_2x(vmovaps, Vmovaps, Ymm, Mem)                           // AVX  AVX512_F{kz}-VL
  ASMJIT_INST_2x(vmovaps, Vmovaps, Mem, Ymm)                           // AVX  AVX512_F{kz}-VL
  ASMJIT_INST_2x(vmovaps, Vmovaps, Zmm, Zmm)                           //      AVX512_F{kz}
  ASMJIT_INST_2x(vmovaps, Vmovaps, Zmm, Mem)                           //      AVX512_F{kz}
  ASMJIT_INST_2x(vmovaps, Vmovaps, Mem, Zmm)                           //      AVX512_F{kz}
  ASMJIT_INST_2x(vmovd, Vmovd, Gp, Xmm)                                // AVX  AVX512_F
  ASMJIT_INST_2x(vmovd, Vmovd, Mem, Xmm)                               // AVX  AVX512_F
  ASMJIT_INST_2x(vmovd, Vmovd, Xmm, Gp)                                // AVX  AVX512_F
  ASMJIT_INST_2x(vmovd, Vmovd, Xmm, Mem)                               // AVX  AVX512_F
  ASMJIT_INST_2x(vmovddup, Vmovddup, Xmm, Xmm)                         // AVX  AVX512_F{kz}-VL
  ASMJIT_INST_2x(vmovddup, Vmovddup, Xmm, Mem)                         // AVX  AVX512_F{kz}-VL
  ASMJIT_INST_2x(vmovddup, Vmovddup, Ymm, Ymm)                         // AVX  AVX512_F{kz}-VL
  ASMJIT_INST_2x(vmovddup, Vmovddup, Ymm, Mem)                         // AVX  AVX512_F{kz}-VL
  ASMJIT_INST_2x(vmovddup, Vmovddup, Zmm, Zmm)                         //      AVX512_F{kz}
  ASMJIT_INST_2x(vmovddup, Vmovddup, Zmm, Mem)                         //      AVX512_F{kz}
  ASMJIT_INST_2x(vmovdqa, Vmovdqa, Xmm, Xmm)                           // AVX
  ASMJIT_INST_2x(vmovdqa, Vmovdqa, Xmm, Mem)                           // AVX
  ASMJIT_INST_2x(vmovdqa, Vmovdqa, Mem, Xmm)                           // AVX
  ASMJIT_INST_2x(vmovdqa, Vmovdqa, Ymm, Ymm)                           // AVX
  ASMJIT_INST_2x(vmovdqa, Vmovdqa, Ymm, Mem)                           // AVX
  ASMJIT_INST_2x(vmovdqa, Vmovdqa, Mem, Ymm)                           // AVX
  ASMJIT_INST_2x(vmovdqa32, Vmovdqa32, Xmm, Xmm)                       //      AVX512_F{kz}-VL
  ASMJIT_INST_2x(vmovdqa32, Vmovdqa32, Xmm, Mem)                       //      AVX512_F{kz}-VL
  ASMJIT_INST_2x(vmovdqa32, Vmovdqa32, Mem, Xmm)                       //      AVX512_F{kz}-VL
  ASMJIT_INST_2x(vmovdqa32, Vmovdqa32, Ymm, Ymm)                       //      AVX512_F{kz}-VL
  ASMJIT_INST_2x(vmovdqa32, Vmovdqa32, Ymm, Mem)                       //      AVX512_F{kz}-VL
  ASMJIT_INST_2x(vmovdqa32, Vmovdqa32, Mem, Ymm)                       //      AVX512_F{kz}-VL
  ASMJIT_INST_2x(vmovdqa32, Vmovdqa32, Zmm, Zmm)                       //      AVX512_F{kz}
  ASMJIT_INST_2x(vmovdqa32, Vmovdqa32, Zmm, Mem)                       //      AVX512_F{kz}
  ASMJIT_INST_2x(vmovdqa32, Vmovdqa32, Mem, Zmm)                       //      AVX512_F{kz}
  ASMJIT_INST_2x(vmovdqa64, Vmovdqa64, Xmm, Xmm)                       //      AVX512_F{kz}-VL
  ASMJIT_INST_2x(vmovdqa64, Vmovdqa64, Xmm, Mem)                       //      AVX512_F{kz}-VL
  ASMJIT_INST_2x(vmovdqa64, Vmovdqa64, Mem, Xmm)                       //      AVX512_F{kz}-VL
  ASMJIT_INST_2x(vmovdqa64, Vmovdqa64, Ymm, Ymm)                       //      AVX512_F{kz}-VL
  ASMJIT_INST_2x(vmovdqa64, Vmovdqa64, Ymm, Mem)                       //      AVX512_F{kz}-VL
  ASMJIT_INST_2x(vmovdqa64, Vmovdqa64, Mem, Ymm)                       //      AVX512_F{kz}-VL
  ASMJIT_INST_2x(vmovdqa64, Vmovdqa64, Zmm, Zmm)                       //      AVX512_F{kz}
  ASMJIT_INST_2x(vmovdqa64, Vmovdqa64, Zmm, Mem)                       //      AVX512_F{kz}
  ASMJIT_INST_2x(vmovdqa64, Vmovdqa64, Mem, Zmm)                       //      AVX512_F{kz}
  ASMJIT_INST_2x(vmovdqu, Vmovdqu, Xmm, Xmm)                           // AVX
  ASMJIT_INST_2x(vmovdqu, Vmovdqu, Xmm, Mem)                           // AVX
  ASMJIT_INST_2x(vmovdqu, Vmovdqu, Mem, Xmm)                           // AVX
  ASMJIT_INST_2x(vmovdqu, Vmovdqu, Ymm, Ymm)                           // AVX
  ASMJIT_INST_2x(vmovdqu, Vmovdqu, Ymm, Mem)                           // AVX
  ASMJIT_INST_2x(vmovdqu, Vmovdqu, Mem, Ymm)                           // AVX
  ASMJIT_INST_2x(vmovdqu16, Vmovdqu16, Xmm, Xmm)                       //      AVX512_BW{kz}-VL
  ASMJIT_INST_2x(vmovdqu16, Vmovdqu16, Xmm, Mem)                       //      AVX512_BW{kz}-VL
  ASMJIT_INST_2x(vmovdqu16, Vmovdqu16, Mem, Xmm)                       //      AVX512_BW{kz}-VL
  ASMJIT_INST_2x(vmovdqu16, Vmovdqu16, Ymm, Ymm)                       //      AVX512_BW{kz}-VL
  ASMJIT_INST_2x(vmovdqu16, Vmovdqu16, Ymm, Mem)                       //      AVX512_BW{kz}-VL
  ASMJIT_INST_2x(vmovdqu16, Vmovdqu16, Mem, Ymm)                       //      AVX512_BW{kz}-VL
  ASMJIT_INST_2x(vmovdqu16, Vmovdqu16, Zmm, Zmm)                       //      AVX512_BW{kz}
  ASMJIT_INST_2x(vmovdqu16, Vmovdqu16, Zmm, Mem)                       //      AVX512_BW{kz}
  ASMJIT_INST_2x(vmovdqu16, Vmovdqu16, Mem, Zmm)                       //      AVX512_BW{kz}
  ASMJIT_INST_2x(vmovdqu32, Vmovdqu32, Xmm, Xmm)                       //      AVX512_F{kz}-VL
  ASMJIT_INST_2x(vmovdqu32, Vmovdqu32, Xmm, Mem)                       //      AVX512_F{kz}-VL
  ASMJIT_INST_2x(vmovdqu32, Vmovdqu32, Mem, Xmm)                       //      AVX512_F{kz}-VL
  ASMJIT_INST_2x(vmovdqu32, Vmovdqu32, Ymm, Ymm)                       //      AVX512_F{kz}-VL
  ASMJIT_INST_2x(vmovdqu32, Vmovdqu32, Ymm, Mem)                       //      AVX512_F{kz}-VL
  ASMJIT_INST_2x(vmovdqu32, Vmovdqu32, Mem, Ymm)                       //      AVX512_F{kz}-VL
  ASMJIT_INST_2x(vmovdqu32, Vmovdqu32, Zmm, Zmm)                       //      AVX512_F{kz}
  ASMJIT_INST_2x(vmovdqu32, Vmovdqu32, Zmm, Mem)                       //      AVX512_F{kz}
  ASMJIT_INST_2x(vmovdqu32, Vmovdqu32, Mem, Zmm)                       //      AVX512_F{kz}
  ASMJIT_INST_2x(vmovdqu64, Vmovdqu64, Xmm, Xmm)                       //      AVX512_F{kz}-VL
  ASMJIT_INST_2x(vmovdqu64, Vmovdqu64, Xmm, Mem)                       //      AVX512_F{kz}-VL
  ASMJIT_INST_2x(vmovdqu64, Vmovdqu64, Mem, Xmm)                       //      AVX512_F{kz}-VL
  ASMJIT_INST_2x(vmovdqu64, Vmovdqu64, Ymm, Ymm)                       //      AVX512_F{kz}-VL
  ASMJIT_INST_2x(vmovdqu64, Vmovdqu64, Ymm, Mem)                       //      AVX512_F{kz}-VL
  ASMJIT_INST_2x(vmovdqu64, Vmovdqu64, Mem, Ymm)                       //      AVX512_F{kz}-VL
  ASMJIT_INST_2x(vmovdqu64, Vmovdqu64, Zmm, Zmm)                       //      AVX512_F{kz}
  ASMJIT_INST_2x(vmovdqu64, Vmovdqu64, Zmm, Mem)                       //      AVX512_F{kz}
  ASMJIT_INST_2x(vmovdqu64, Vmovdqu64, Mem, Zmm)                       //      AVX512_F{kz}
  ASMJIT_INST_2x(vmovdqu8, Vmovdqu8, Xmm, Xmm)                         //      AVX512_BW{kz}-VL
  ASMJIT_INST_2x(vmovdqu8, Vmovdqu8, Xmm, Mem)                         //      AVX512_BW{kz}-VL
  ASMJIT_INST_2x(vmovdqu8, Vmovdqu8, Mem, Xmm)                         //      AVX512_BW{kz}-VL
  ASMJIT_INST_2x(vmovdqu8, Vmovdqu8, Ymm, Ymm)                         //      AVX512_BW{kz}-VL
  ASMJIT_INST_2x(vmovdqu8, Vmovdqu8, Ymm, Mem)                         //      AVX512_BW{kz}-VL
  ASMJIT_INST_2x(vmovdqu8, Vmovdqu8, Mem, Ymm)                         //      AVX512_BW{kz}-VL
  ASMJIT_INST_2x(vmovdqu8, Vmovdqu8, Zmm, Zmm)                         //      AVX512_BW{kz}
  ASMJIT_INST_2x(vmovdqu8, Vmovdqu8, Zmm, Mem)                         //      AVX512_BW{kz}
  ASMJIT_INST_2x(vmovdqu8, Vmovdqu8, Mem, Zmm)                         //      AVX512_BW{kz}
  ASMJIT_INST_3x(vmovhlps, Vmovhlps, Xmm, Xmm, Xmm)                    // AVX  AVX512_F
  ASMJIT_INST_2x(vmovhpd, Vmovhpd, Mem, Xmm)                           // AVX  AVX512_F
  ASMJIT_INST_3x(vmovhpd, Vmovhpd, Xmm, Xmm, Mem)                      // AVX  AVX512_F
  ASMJIT_INST_2x(vmovhps, Vmovhps, Mem, Xmm)                           // AVX  AVX512_F
  ASMJIT_INST_3x(vmovhps, Vmovhps, Xmm, Xmm, Mem)                      // AVX  AVX512_F
  ASMJIT_INST_3x(vmovlhps, Vmovlhps, Xmm, Xmm, Xmm)                    // AVX  AVX512_F
  ASMJIT_INST_2x(vmovlpd, Vmovlpd, Mem, Xmm)                           // AVX  AVX512_F
  ASMJIT_INST_3x(vmovlpd, Vmovlpd, Xmm, Xmm, Mem)                      // AVX  AVX512_F
  ASMJIT_INST_2x(vmovlps, Vmovlps, Mem, Xmm)                           // AVX  AVX512_F
  ASMJIT_INST_3x(vmovlps, Vmovlps, Xmm, Xmm, Mem)                      // AVX  AVX512_F
  ASMJIT_INST_2x(vmovmskpd, Vmovmskpd, Gp, Xmm)                        // AVX
  ASMJIT_INST_2x(vmovmskpd, Vmovmskpd, Gp, Ymm)                        // AVX
  ASMJIT_INST_2x(vmovmskps, Vmovmskps, Gp, Xmm)                        // AVX
  ASMJIT_INST_2x(vmovmskps, Vmovmskps, Gp, Ymm)                        // AVX
  ASMJIT_INST_2x(vmovntdq, Vmovntdq, Mem, Xmm)                         // AVX  AVX512_F-VL
  ASMJIT_INST_2x(vmovntdq, Vmovntdq, Mem, Ymm)                         // AVX  AVX512_F-VL
  ASMJIT_INST_2x(vmovntdq, Vmovntdq, Mem, Zmm)                         //      AVX512_F
  ASMJIT_INST_2x(vmovntdqa, Vmovntdqa, Xmm, Mem)                       // AVX  AVX512_F-VL
  ASMJIT_INST_2x(vmovntdqa, Vmovntdqa, Ymm, Mem)                       // AVX2 AVX512_F-VL
  ASMJIT_INST_2x(vmovntdqa, Vmovntdqa, Zmm, Mem)                       //      AVX512_F
  ASMJIT_INST_2x(vmovntpd, Vmovntpd, Mem, Xmm)                         // AVX  AVX512_F-VL
  ASMJIT_INST_2x(vmovntpd, Vmovntpd, Mem, Ymm)                         // AVX  AVX512_F-VL
  ASMJIT_INST_2x(vmovntpd, Vmovntpd, Mem, Zmm)                         //      AVX512_F
  ASMJIT_INST_2x(vmovntps, Vmovntps, Mem, Xmm)                         // AVX  AVX512_F-VL
  ASMJIT_INST_2x(vmovntps, Vmovntps, Mem, Ymm)                         // AVX  AVX512_F-VL
  ASMJIT_INST_2x(vmovntps, Vmovntps, Mem, Zmm)                         //      AVX512_F
  ASMJIT_INST_2x(vmovq, Vmovq, Gp, Xmm)                                // AVX  AVX512_F
  ASMJIT_INST_2x(vmovq, Vmovq, Mem, Xmm)                               // AVX  AVX512_F
  ASMJIT_INST_2x(vmovq, Vmovq, Xmm, Mem)                               // AVX  AVX512_F
  ASMJIT_INST_2x(vmovq, Vmovq, Xmm, Gp)                                // AVX  AVX512_F
  ASMJIT_INST_2x(vmovq, Vmovq, Xmm, Xmm)                               // AVX  AVX512_F
  ASMJIT_INST_2x(vmovsd, Vmovsd, Mem, Xmm)                             // AVX  AVX512_F
  ASMJIT_INST_2x(vmovsd, Vmovsd, Xmm, Mem)                             // AVX  AVX512_F{kz}
  ASMJIT_INST_3x(vmovsd, Vmovsd, Xmm, Xmm, Xmm)                        // AVX  AVX512_F{kz}
  ASMJIT_INST_2x(vmovshdup, Vmovshdup, Xmm, Xmm)                       // AVX  AVX512_F{kz}-VL
  ASMJIT_INST_2x(vmovshdup, Vmovshdup, Xmm, Mem)                       // AVX  AVX512_F{kz}-VL
  ASMJIT_INST_2x(vmovshdup, Vmovshdup, Ymm, Ymm)                       // AVX  AVX512_F{kz}-VL
  ASMJIT_INST_2x(vmovshdup, Vmovshdup, Ymm, Mem)                       // AVX  AVX512_F{kz}-VL
  ASMJIT_INST_2x(vmovshdup, Vmovshdup, Zmm, Zmm)                       //      AVX512_F{kz}
  ASMJIT_INST_2x(vmovshdup, Vmovshdup, Zmm, Mem)                       //      AVX512_F{kz}
  ASMJIT_INST_2x(vmovsldup, Vmovsldup, Xmm, Xmm)                       // AVX  AVX512_F{kz}-VL
  ASMJIT_INST_2x(vmovsldup, Vmovsldup, Xmm, Mem)                       // AVX  AVX512_F{kz}-VL
  ASMJIT_INST_2x(vmovsldup, Vmovsldup, Ymm, Ymm)                       // AVX  AVX512_F{kz}-VL
  ASMJIT_INST_2x(vmovsldup, Vmovsldup, Ymm, Mem)                       // AVX  AVX512_F{kz}-VL
  ASMJIT_INST_2x(vmovsldup, Vmovsldup, Zmm, Zmm)                       //      AVX512_F{kz}
  ASMJIT_INST_2x(vmovsldup, Vmovsldup, Zmm, Mem)                       //      AVX512_F{kz}
  ASMJIT_INST_2x(vmovss, Vmovss, Mem, Xmm)                             // AVX  AVX512_F
  ASMJIT_INST_2x(vmovss, Vmovss, Xmm, Mem)                             // AVX  AVX512_F{kz}
  ASMJIT_INST_3x(vmovss, Vmovss, Xmm, Xmm, Xmm)                        // AVX  AVX512_F{kz}
  ASMJIT_INST_2x(vmovupd, Vmovupd, Xmm, Xmm)                           // AVX  AVX512_F{kz}-VL
  ASMJIT_INST_2x(vmovupd, Vmovupd, Xmm, Mem)                           // AVX  AVX512_F{kz}-VL
  ASMJIT_INST_2x(vmovupd, Vmovupd, Mem, Xmm)                           // AVX  AVX512_F{kz}-VL
  ASMJIT_INST_2x(vmovupd, Vmovupd, Ymm, Ymm)                           // AVX  AVX512_F{kz}-VL
  ASMJIT_INST_2x(vmovupd, Vmovupd, Ymm, Mem)                           // AVX  AVX512_F{kz}-VL
  ASMJIT_INST_2x(vmovupd, Vmovupd, Mem, Ymm)                           // AVX  AVX512_F{kz}-VL
  ASMJIT_INST_2x(vmovupd, Vmovupd, Zmm, Zmm)                           //      AVX512_F{kz}
  ASMJIT_INST_2x(vmovupd, Vmovupd, Zmm, Mem)                           //      AVX512_F{kz}
  ASMJIT_INST_2x(vmovupd, Vmovupd, Mem, Zmm)                           //      AVX512_F{kz}
  ASMJIT_INST_2x(vmovups, Vmovups, Xmm, Xmm)                           // AVX  AVX512_F{kz}-VL
  ASMJIT_INST_2x(vmovups, Vmovups, Xmm, Mem)                           // AVX  AVX512_F{kz}-VL
  ASMJIT_INST_2x(vmovups, Vmovups, Mem, Xmm)                           // AVX  AVX512_F{kz}-VL
  ASMJIT_INST_2x(vmovups, Vmovups, Ymm, Ymm)                           // AVX  AVX512_F{kz}-VL
  ASMJIT_INST_2x(vmovups, Vmovups, Ymm, Mem)                           // AVX  AVX512_F{kz}-VL
  ASMJIT_INST_2x(vmovups, Vmovups, Mem, Ymm)                           // AVX  AVX512_F{kz}-VL
  ASMJIT_INST_2x(vmovups, Vmovups, Zmm, Zmm)                           //      AVX512_F{kz}
  ASMJIT_INST_2x(vmovups, Vmovups, Zmm, Mem)                           //      AVX512_F{kz}
  ASMJIT_INST_2x(vmovups, Vmovups, Mem, Zmm)                           //      AVX512_F{kz}
  ASMJIT_INST_4i(vmpsadbw, Vmpsadbw, Xmm, Xmm, Xmm, Imm)               // AVX
  ASMJIT_INST_4i(vmpsadbw, Vmpsadbw, Xmm, Xmm, Mem, Imm)               // AVX
  ASMJIT_INST_4i(vmpsadbw, Vmpsadbw, Ymm, Ymm, Ymm, Imm)               // AVX2
  ASMJIT_INST_4i(vmpsadbw, Vmpsadbw, Ymm, Ymm, Mem, Imm)               // AVX2
  ASMJIT_INST_3x(vmulpd, Vmulpd, Xmm, Xmm, Xmm)                        // AVX  AVX512_F{kz|b64}-VL
  ASMJIT_INST_3x(vmulpd, Vmulpd, Xmm, Xmm, Mem)                        // AVX  AVX512_F{kz|b64}-VL
  ASMJIT_INST_3x(vmulpd, Vmulpd, Ymm, Ymm, Ymm)                        // AVX2 AVX512_F{kz|b64}-VL
  ASMJIT_INST_3x(vmulpd, Vmulpd, Ymm, Ymm, Mem)                        // AVX2 AVX512_F{kz|b64}-VL
  ASMJIT_INST_3x(vmulpd, Vmulpd, Zmm, Zmm, Zmm)                        //      AVX512_F{kz|er|b64}
  ASMJIT_INST_3x(vmulpd, Vmulpd, Zmm, Zmm, Mem)                        //      AVX512_F{kz|er|b64}
  ASMJIT_INST_3x(vmulps, Vmulps, Xmm, Xmm, Xmm)                        // AVX  AVX512_F{kz|b32}-VL
  ASMJIT_INST_3x(vmulps, Vmulps, Xmm, Xmm, Mem)                        // AVX  AVX512_F{kz|b32}-VL
  ASMJIT_INST_3x(vmulps, Vmulps, Ymm, Ymm, Ymm)                        // AVX2 AVX512_F{kz|b32}-VL
  ASMJIT_INST_3x(vmulps, Vmulps, Ymm, Ymm, Mem)                        // AVX2 AVX512_F{kz|b32}-VL
  ASMJIT_INST_3x(vmulps, Vmulps, Zmm, Zmm, Zmm)                        //      AVX512_F{kz|er|b32}
  ASMJIT_INST_3x(vmulps, Vmulps, Zmm, Zmm, Mem)                        //      AVX512_F{kz|er|b32}
  ASMJIT_INST_3x(vmulsd, Vmulsd, Xmm, Xmm, Xmm)                        // AVX  AVX512_F{kz|er}
  ASMJIT_INST_3x(vmulsd, Vmulsd, Xmm, Xmm, Mem)                        // AVX  AVX512_F{kz|er}
  ASMJIT_INST_3x(vmulss, Vmulss, Xmm, Xmm, Xmm)                        // AVX  AVX512_F{kz|er}
  ASMJIT_INST_3x(vmulss, Vmulss, Xmm, Xmm, Mem)                        // AVX  AVX512_F{kz|er}
  ASMJIT_INST_3x(vorpd, Vorpd, Xmm, Xmm, Xmm)                          // AVX  AVX512_DQ{kz|b64}-VL
  ASMJIT_INST_3x(vorpd, Vorpd, Xmm, Xmm, Mem)                          // AVX  AVX512_DQ{kz|b64}-VL
  ASMJIT_INST_3x(vorpd, Vorpd, Ymm, Ymm, Ymm)                          // AVX  AVX512_DQ{kz|b64}-VL
  ASMJIT_INST_3x(vorpd, Vorpd, Ymm, Ymm, Mem)                          // AVX  AVX512_DQ{kz|b64}-VL
  ASMJIT_INST_3x(vorpd, Vorpd, Zmm, Zmm, Zmm)                          //      AVX512_DQ{kz|b64}
  ASMJIT_INST_3x(vorpd, Vorpd, Zmm, Zmm, Mem)                          //      AVX512_DQ{kz|b64}
  ASMJIT_INST_3x(vorps, Vorps, Xmm, Xmm, Xmm)                          // AVX  AVX512_F{kz|b32}-VL
  ASMJIT_INST_3x(vorps, Vorps, Xmm, Xmm, Mem)                          // AVX  AVX512_F{kz|b32}-VL
  ASMJIT_INST_3x(vorps, Vorps, Ymm, Ymm, Ymm)                          // AVX  AVX512_F{kz|b32}-VL
  ASMJIT_INST_3x(vorps, Vorps, Ymm, Ymm, Mem)                          // AVX  AVX512_F{kz|b32}-VL
  ASMJIT_INST_3x(vorps, Vorps, Zmm, Zmm, Zmm)                          //      AVX512_F{kz|b32}
  ASMJIT_INST_3x(vorps, Vorps, Zmm, Zmm, Mem)                          //      AVX512_F{kz|b32}
  ASMJIT_INST_6x(vp4dpwssd, Vp4dpwssd, Zmm, Zmm, Zmm, Zmm, Zmm, Mem)   // AVX512_4FMAPS{kz}
  ASMJIT_INST_6x(vp4dpwssds, Vp4dpwssds, Zmm, Zmm, Zmm, Zmm, Zmm, Mem) // AVX512_4FMAPS{kz}
  ASMJIT_INST_2x(vpabsb, Vpabsb, Xmm, Xmm)                             // AVX  AVX512_BW{kz}-VL
  ASMJIT_INST_2x(vpabsb, Vpabsb, Xmm, Mem)                             // AVX  AVX512_BW{kz}-VL
  ASMJIT_INST_2x(vpabsb, Vpabsb, Ymm, Ymm)                             // AVX2 AVX512_BW{kz}-VL
  ASMJIT_INST_2x(vpabsb, Vpabsb, Ymm, Mem)                             // AVX2 AVX512_BW{kz}-VL
  ASMJIT_INST_2x(vpabsb, Vpabsb, Zmm, Zmm)                             //      AVX512_BW{kz}
  ASMJIT_INST_2x(vpabsb, Vpabsb, Zmm, Mem)                             //      AVX512_BW{kz}
  ASMJIT_INST_2x(vpabsd, Vpabsd, Xmm, Xmm)                             // AVX  AVX512_F{kz}-VL
  ASMJIT_INST_2x(vpabsd, Vpabsd, Xmm, Mem)                             // AVX  AVX512_F{kz}-VL
  ASMJIT_INST_2x(vpabsd, Vpabsd, Ymm, Ymm)                             // AVX2 AVX512_F{kz}-VL
  ASMJIT_INST_2x(vpabsd, Vpabsd, Ymm, Mem)                             // AVX2 AVX512_F{kz}-VL
  ASMJIT_INST_2x(vpabsd, Vpabsd, Zmm, Zmm)                             //      AVX512_F{kz}
  ASMJIT_INST_2x(vpabsd, Vpabsd, Zmm, Mem)                             //      AVX512_F{kz}
  ASMJIT_INST_2x(vpabsq, Vpabsq, Xmm, Xmm)                             //      AVX512_F{kz}-VL
  ASMJIT_INST_2x(vpabsq, Vpabsq, Xmm, Mem)                             //      AVX512_F{kz}-VL
  ASMJIT_INST_2x(vpabsq, Vpabsq, Ymm, Ymm)                             //      AVX512_F{kz}-VL
  ASMJIT_INST_2x(vpabsq, Vpabsq, Ymm, Mem)                             //      AVX512_F{kz}-VL
  ASMJIT_INST_2x(vpabsq, Vpabsq, Zmm, Zmm)                             //      AVX512_F{kz}
  ASMJIT_INST_2x(vpabsq, Vpabsq, Zmm, Mem)                             //      AVX512_F{kz}
  ASMJIT_INST_2x(vpabsw, Vpabsw, Xmm, Xmm)                             // AVX  AVX512_BW{kz}-VL
  ASMJIT_INST_2x(vpabsw, Vpabsw, Xmm, Mem)                             // AVX  AVX512_BW{kz}-VL
  ASMJIT_INST_2x(vpabsw, Vpabsw, Ymm, Ymm)                             // AVX2 AVX512_BW{kz}-VL
  ASMJIT_INST_2x(vpabsw, Vpabsw, Ymm, Mem)                             // AVX2 AVX512_BW{kz}-VL
  ASMJIT_INST_2x(vpabsw, Vpabsw, Zmm, Zmm)                             //      AVX512_BW{kz}
  ASMJIT_INST_2x(vpabsw, Vpabsw, Zmm, Mem)                             //      AVX512_BW{kz}
  ASMJIT_INST_3x(vpackssdw, Vpackssdw, Xmm, Xmm, Xmm)                  // AVX  AVX512_BW{kz|b32}-VL
  ASMJIT_INST_3x(vpackssdw, Vpackssdw, Xmm, Xmm, Mem)                  // AVX  AVX512_BW{kz|b32}-VL
  ASMJIT_INST_3x(vpackssdw, Vpackssdw, Ymm, Ymm, Ymm)                  // AVX2 AVX512_BW{kz|b32}-VL
  ASMJIT_INST_3x(vpackssdw, Vpackssdw, Ymm, Ymm, Mem)                  // AVX2 AVX512_BW{kz|b32}-VL
  ASMJIT_INST_3x(vpackssdw, Vpackssdw, Zmm, Zmm, Zmm)                  //      AVX512_BW{kz|b32}
  ASMJIT_INST_3x(vpackssdw, Vpackssdw, Zmm, Zmm, Mem)                  //      AVX512_BW{kz|b32}
  ASMJIT_INST_3x(vpacksswb, Vpacksswb, Xmm, Xmm, Xmm)                  // AVX  AVX512_BW{kz}-VL
  ASMJIT_INST_3x(vpacksswb, Vpacksswb, Xmm, Xmm, Mem)                  // AVX  AVX512_BW{kz}-VL
  ASMJIT_INST_3x(vpacksswb, Vpacksswb, Ymm, Ymm, Ymm)                  // AVX2 AVX512_BW{kz}-VL
  ASMJIT_INST_3x(vpacksswb, Vpacksswb, Ymm, Ymm, Mem)                  // AVX2 AVX512_BW{kz}-VL
  ASMJIT_INST_3x(vpacksswb, Vpacksswb, Zmm, Zmm, Zmm)                  //      AVX512_BW{kz}
  ASMJIT_INST_3x(vpacksswb, Vpacksswb, Zmm, Zmm, Mem)                  //      AVX512_BW{kz}
  ASMJIT_INST_3x(vpackusdw, Vpackusdw, Xmm, Xmm, Xmm)                  // AVX  AVX512_BW{kz|b32}-VL
  ASMJIT_INST_3x(vpackusdw, Vpackusdw, Xmm, Xmm, Mem)                  // AVX  AVX512_BW{kz|b32}-VL
  ASMJIT_INST_3x(vpackusdw, Vpackusdw, Ymm, Ymm, Ymm)                  // AVX2 AVX512_BW{kz|b32}-VL
  ASMJIT_INST_3x(vpackusdw, Vpackusdw, Ymm, Ymm, Mem)                  // AVX2 AVX512_BW{kz|b32}-VL
  ASMJIT_INST_3x(vpackusdw, Vpackusdw, Zmm, Zmm, Zmm)                  //      AVX512_BW{kz|b32}
  ASMJIT_INST_3x(vpackusdw, Vpackusdw, Zmm, Zmm, Mem)                  //      AVX512_BW{kz|b32}
  ASMJIT_INST_3x(vpackuswb, Vpackuswb, Xmm, Xmm, Xmm)                  // AVX  AVX512_BW{kz}-VL
  ASMJIT_INST_3x(vpackuswb, Vpackuswb, Xmm, Xmm, Mem)                  // AVX  AVX512_BW{kz}-VL
  ASMJIT_INST_3x(vpackuswb, Vpackuswb, Ymm, Ymm, Ymm)                  // AVX2 AVX512_BW{kz}-VL
  ASMJIT_INST_3x(vpackuswb, Vpackuswb, Ymm, Ymm, Mem)                  // AVX2 AVX512_BW{kz}-VL
  ASMJIT_INST_3x(vpackuswb, Vpackuswb, Zmm, Zmm, Zmm)                  //      AVX512_BW{kz}
  ASMJIT_INST_3x(vpackuswb, Vpackuswb, Zmm, Zmm, Mem)                  //      AVX512_BW{kz}
  ASMJIT_INST_3x(vpaddb, Vpaddb, Xmm, Xmm, Xmm)                        // AVX  AVX512_BW{kz}-VL
  ASMJIT_INST_3x(vpaddb, Vpaddb, Xmm, Xmm, Mem)                        // AVX  AVX512_BW{kz}-VL
  ASMJIT_INST_3x(vpaddb, Vpaddb, Ymm, Ymm, Ymm)                        // AVX2 AVX512_BW{kz}-VL
  ASMJIT_INST_3x(vpaddb, Vpaddb, Ymm, Ymm, Mem)                        // AVX2 AVX512_BW{kz}-VL
  ASMJIT_INST_3x(vpaddb, Vpaddb, Zmm, Zmm, Zmm)                        //      AVX512_BW{kz}
  ASMJIT_INST_3x(vpaddb, Vpaddb, Zmm, Zmm, Mem)                        //      AVX512_BW{kz}
  ASMJIT_INST_3x(vpaddd, Vpaddd, Xmm, Xmm, Xmm)                        // AVX  AVX512_F{kz|b32}-VL
  ASMJIT_INST_3x(vpaddd, Vpaddd, Xmm, Xmm, Mem)                        // AVX  AVX512_F{kz|b32}-VL
  ASMJIT_INST_3x(vpaddd, Vpaddd, Ymm, Ymm, Ymm)                        // AVX2 AVX512_F{kz|b32}-VL
  ASMJIT_INST_3x(vpaddd, Vpaddd, Ymm, Ymm, Mem)                        // AVX2 AVX512_F{kz|b32}-VL
  ASMJIT_INST_3x(vpaddd, Vpaddd, Zmm, Zmm, Zmm)                        //      AVX512_F{kz|b32}
  ASMJIT_INST_3x(vpaddd, Vpaddd, Zmm, Zmm, Mem)                        //      AVX512_F{kz|b32}
  ASMJIT_INST_3x(vpaddq, Vpaddq, Xmm, Xmm, Xmm)                        // AVX  AVX512_F{kz|b64}-VL
  ASMJIT_INST_3x(vpaddq, Vpaddq, Xmm, Xmm, Mem)                        // AVX  AVX512_F{kz|b64}-VL
  ASMJIT_INST_3x(vpaddq, Vpaddq, Ymm, Ymm, Ymm)                        // AVX2 AVX512_F{kz|b64}-VL
  ASMJIT_INST_3x(vpaddq, Vpaddq, Ymm, Ymm, Mem)                        // AVX2 AVX512_F{kz|b64}-VL
  ASMJIT_INST_3x(vpaddq, Vpaddq, Zmm, Zmm, Zmm)                        //      AVX512_F{kz|b64}
  ASMJIT_INST_3x(vpaddq, Vpaddq, Zmm, Zmm, Mem)                        //      AVX512_F{kz|b64}
  ASMJIT_INST_3x(vpaddsb, Vpaddsb, Xmm, Xmm, Xmm)                      // AVX  AVX512_BW{kz}-VL
  ASMJIT_INST_3x(vpaddsb, Vpaddsb, Xmm, Xmm, Mem)                      // AVX  AVX512_BW{kz}-VL
  ASMJIT_INST_3x(vpaddsb, Vpaddsb, Ymm, Ymm, Ymm)                      // AVX2 AVX512_BW{kz}-VL
  ASMJIT_INST_3x(vpaddsb, Vpaddsb, Ymm, Ymm, Mem)                      // AVX2 AVX512_BW{kz}-VL
  ASMJIT_INST_3x(vpaddsb, Vpaddsb, Zmm, Zmm, Zmm)                      //      AVX512_BW{kz}
  ASMJIT_INST_3x(vpaddsb, Vpaddsb, Zmm, Zmm, Mem)                      //      AVX512_BW{kz}
  ASMJIT_INST_3x(vpaddsw, Vpaddsw, Xmm, Xmm, Xmm)                      // AVX  AVX512_BW{kz}-VL
  ASMJIT_INST_3x(vpaddsw, Vpaddsw, Xmm, Xmm, Mem)                      // AVX  AVX512_BW{kz}-VL
  ASMJIT_INST_3x(vpaddsw, Vpaddsw, Ymm, Ymm, Ymm)                      // AVX2 AVX512_BW{kz}-VL
  ASMJIT_INST_3x(vpaddsw, Vpaddsw, Ymm, Ymm, Mem)                      // AVX2 AVX512_BW{kz}-VL
  ASMJIT_INST_3x(vpaddsw, Vpaddsw, Zmm, Zmm, Zmm)                      //      AVX512_BW{kz}
  ASMJIT_INST_3x(vpaddsw, Vpaddsw, Zmm, Zmm, Mem)                      //      AVX512_BW{kz}
  ASMJIT_INST_3x(vpaddusb, Vpaddusb, Xmm, Xmm, Xmm)                    // AVX  AVX512_BW{kz}-VL
  ASMJIT_INST_3x(vpaddusb, Vpaddusb, Xmm, Xmm, Mem)                    // AVX  AVX512_BW{kz}-VL
  ASMJIT_INST_3x(vpaddusb, Vpaddusb, Ymm, Ymm, Ymm)                    // AVX2 AVX512_BW{kz}-VL
  ASMJIT_INST_3x(vpaddusb, Vpaddusb, Ymm, Ymm, Mem)                    // AVX2 AVX512_BW{kz}-VL
  ASMJIT_INST_3x(vpaddusb, Vpaddusb, Zmm, Zmm, Zmm)                    //      AVX512_BW{kz}
  ASMJIT_INST_3x(vpaddusb, Vpaddusb, Zmm, Zmm, Mem)                    //      AVX512_BW{kz}
  ASMJIT_INST_3x(vpaddusw, Vpaddusw, Xmm, Xmm, Xmm)                    // AVX  AVX512_BW{kz}-VL
  ASMJIT_INST_3x(vpaddusw, Vpaddusw, Xmm, Xmm, Mem)                    // AVX  AVX512_BW{kz}-VL
  ASMJIT_INST_3x(vpaddusw, Vpaddusw, Ymm, Ymm, Ymm)                    // AVX2 AVX512_BW{kz}-VL
  ASMJIT_INST_3x(vpaddusw, Vpaddusw, Ymm, Ymm, Mem)                    // AVX2 AVX512_BW{kz}-VL
  ASMJIT_INST_3x(vpaddusw, Vpaddusw, Zmm, Zmm, Zmm)                    //      AVX512_BW{kz}
  ASMJIT_INST_3x(vpaddusw, Vpaddusw, Zmm, Zmm, Mem)                    //      AVX512_BW{kz}
  ASMJIT_INST_3x(vpaddw, Vpaddw, Xmm, Xmm, Xmm)                        // AVX  AVX512_BW{kz}-VL
  ASMJIT_INST_3x(vpaddw, Vpaddw, Xmm, Xmm, Mem)                        // AVX  AVX512_BW{kz}-VL
  ASMJIT_INST_3x(vpaddw, Vpaddw, Ymm, Ymm, Ymm)                        // AVX2 AVX512_BW{kz}-VL
  ASMJIT_INST_3x(vpaddw, Vpaddw, Ymm, Ymm, Mem)                        // AVX2 AVX512_BW{kz}-VL
  ASMJIT_INST_3x(vpaddw, Vpaddw, Zmm, Zmm, Zmm)                        //      AVX512_BW{kz}
  ASMJIT_INST_3x(vpaddw, Vpaddw, Zmm, Zmm, Mem)                        //      AVX512_BW{kz}
  ASMJIT_INST_4i(vpalignr, Vpalignr, Xmm, Xmm, Xmm, Imm)               // AVX  AVX512_BW{kz}-VL
  ASMJIT_INST_4i(vpalignr, Vpalignr, Xmm, Xmm, Mem, Imm)               // AVX  AVX512_BW{kz}-VL
  ASMJIT_INST_4i(vpalignr, Vpalignr, Ymm, Ymm, Ymm, Imm)               // AVX2 AVX512_BW{kz}-VL
  ASMJIT_INST_4i(vpalignr, Vpalignr, Ymm, Ymm, Mem, Imm)               // AVX2 AVX512_BW{kz}-VL
  ASMJIT_INST_4i(vpalignr, Vpalignr, Zmm, Zmm, Zmm, Imm)               //      AVX512_BW{kz}
  ASMJIT_INST_4i(vpalignr, Vpalignr, Zmm, Zmm, Mem, Imm)               //      AVX512_BW{kz}
  ASMJIT_INST_3x(vpand, Vpand, Xmm, Xmm, Xmm)                          // AVX
  ASMJIT_INST_3x(vpand, Vpand, Xmm, Xmm, Mem)                          // AVX
  ASMJIT_INST_3x(vpand, Vpand, Ymm, Ymm, Ymm)                          // AVX2
  ASMJIT_INST_3x(vpand, Vpand, Ymm, Ymm, Mem)                          // AVX2
  ASMJIT_INST_3x(vpandd, Vpandd, Xmm, Xmm, Xmm)                        //      AVX512_F{kz|b32}-VL
  ASMJIT_INST_3x(vpandd, Vpandd, Xmm, Xmm, Mem)                        //      AVX512_F{kz|b32}-VL
  ASMJIT_INST_3x(vpandd, Vpandd, Ymm, Ymm, Ymm)                        //      AVX512_F{kz|b32}-VL
  ASMJIT_INST_3x(vpandd, Vpandd, Ymm, Ymm, Mem)                        //      AVX512_F{kz|b32}-VL
  ASMJIT_INST_3x(vpandd, Vpandd, Zmm, Zmm, Zmm)                        //      AVX512_F{kz|b32}
  ASMJIT_INST_3x(vpandd, Vpandd, Zmm, Zmm, Mem)                        //      AVX512_F{kz|b32}
  ASMJIT_INST_3x(vpandn, Vpandn, Xmm, Xmm, Xmm)                        // AVX
  ASMJIT_INST_3x(vpandn, Vpandn, Xmm, Xmm, Mem)                        // AVX
  ASMJIT_INST_3x(vpandn, Vpandn, Ymm, Ymm, Ymm)                        // AVX2
  ASMJIT_INST_3x(vpandn, Vpandn, Ymm, Ymm, Mem)                        // AVX2
  ASMJIT_INST_3x(vpandnd, Vpandnd, Xmm, Xmm, Xmm)                      //      AVX512_F{kz|b32}-VL
  ASMJIT_INST_3x(vpandnd, Vpandnd, Xmm, Xmm, Mem)                      //      AVX512_F{kz|b32}-VL
  ASMJIT_INST_3x(vpandnd, Vpandnd, Ymm, Ymm, Ymm)                      //      AVX512_F{kz|b32}-VL
  ASMJIT_INST_3x(vpandnd, Vpandnd, Ymm, Ymm, Mem)                      //      AVX512_F{kz|b32}-VL
  ASMJIT_INST_3x(vpandnd, Vpandnd, Zmm, Zmm, Zmm)                      //      AVX512_F{kz|b32}
  ASMJIT_INST_3x(vpandnd, Vpandnd, Zmm, Zmm, Mem)                      //      AVX512_F{kz|b32}
  ASMJIT_INST_3x(vpandnq, Vpandnq, Xmm, Xmm, Xmm)                      //      AVX512_F{kz|b64}-VL
  ASMJIT_INST_3x(vpandnq, Vpandnq, Xmm, Xmm, Mem)                      //      AVX512_F{kz|b64}-VL
  ASMJIT_INST_3x(vpandnq, Vpandnq, Ymm, Ymm, Ymm)                      //      AVX512_F{kz|b64}-VL
  ASMJIT_INST_3x(vpandnq, Vpandnq, Ymm, Ymm, Mem)                      //      AVX512_F{kz|b64}-VL
  ASMJIT_INST_3x(vpandnq, Vpandnq, Zmm, Zmm, Zmm)                      //      AVX512_F{kz|b64}
  ASMJIT_INST_3x(vpandnq, Vpandnq, Zmm, Zmm, Mem)                      //      AVX512_F{kz|b64}
  ASMJIT_INST_3x(vpandq, Vpandq, Xmm, Xmm, Xmm)                        //      AVX512_F{kz|b64}-VL
  ASMJIT_INST_3x(vpandq, Vpandq, Xmm, Xmm, Mem)                        //      AVX512_F{kz|b64}-VL
  ASMJIT_INST_3x(vpandq, Vpandq, Ymm, Ymm, Ymm)                        //      AVX512_F{kz|b64}-VL
  ASMJIT_INST_3x(vpandq, Vpandq, Ymm, Ymm, Mem)                        //      AVX512_F{kz|b64}-VL
  ASMJIT_INST_3x(vpandq, Vpandq, Zmm, Zmm, Zmm)                        //      AVX512_F{kz|b64}
  ASMJIT_INST_3x(vpandq, Vpandq, Zmm, Zmm, Mem)                        //      AVX512_F{kz|b64}
  ASMJIT_INST_3x(vpavgb, Vpavgb, Xmm, Xmm, Xmm)                        // AVX  AVX512_BW{kz}-VL
  ASMJIT_INST_3x(vpavgb, Vpavgb, Xmm, Xmm, Mem)                        // AVX  AVX512_BW{kz}-VL
  ASMJIT_INST_3x(vpavgb, Vpavgb, Ymm, Ymm, Ymm)                        // AVX  AVX512_BW{kz}-VL
  ASMJIT_INST_3x(vpavgb, Vpavgb, Ymm, Ymm, Mem)                        // AVX  AVX512_BW{kz}-VL
  ASMJIT_INST_3x(vpavgb, Vpavgb, Zmm, Zmm, Zmm)                        //      AVX512_BW{kz}
  ASMJIT_INST_3x(vpavgb, Vpavgb, Zmm, Zmm, Mem)                        //      AVX512_BW{kz}
  ASMJIT_INST_3x(vpavgw, Vpavgw, Xmm, Xmm, Xmm)                        // AVX2 AVX512_BW{kz}-VL
  ASMJIT_INST_3x(vpavgw, Vpavgw, Xmm, Xmm, Mem)                        // AVX2 AVX512_BW{kz}-VL
  ASMJIT_INST_3x(vpavgw, Vpavgw, Ymm, Ymm, Ymm)                        // AVX2 AVX512_BW{kz}-VL
  ASMJIT_INST_3x(vpavgw, Vpavgw, Ymm, Ymm, Mem)                        // AVX2 AVX512_BW{kz}-VL
  ASMJIT_INST_3x(vpavgw, Vpavgw, Zmm, Zmm, Zmm)                        //      AVX512_BW{kz}
  ASMJIT_INST_3x(vpavgw, Vpavgw, Zmm, Zmm, Mem)                        //      AVX512_BW{kz}
  ASMJIT_INST_4i(vpblendd, Vpblendd, Xmm, Xmm, Xmm, Imm)               // AVX2
  ASMJIT_INST_4i(vpblendd, Vpblendd, Xmm, Xmm, Mem, Imm)               // AVX2
  ASMJIT_INST_4i(vpblendd, Vpblendd, Ymm, Ymm, Ymm, Imm)               // AVX2
  ASMJIT_INST_4i(vpblendd, Vpblendd, Ymm, Ymm, Mem, Imm)               // AVX2
  ASMJIT_INST_4x(vpblendvb, Vpblendvb, Xmm, Xmm, Xmm, Xmm)             // AVX
  ASMJIT_INST_4x(vpblendvb, Vpblendvb, Xmm, Xmm, Mem, Xmm)             // AVX
  ASMJIT_INST_4x(vpblendvb, Vpblendvb, Ymm, Ymm, Ymm, Ymm)             // AVX2
  ASMJIT_INST_4x(vpblendvb, Vpblendvb, Ymm, Ymm, Mem, Ymm)             // AVX2
  ASMJIT_INST_4i(vpblendw, Vpblendw, Xmm, Xmm, Xmm, Imm)               // AVX
  ASMJIT_INST_4i(vpblendw, Vpblendw, Xmm, Xmm, Mem, Imm)               // AVX
  ASMJIT_INST_4i(vpblendw, Vpblendw, Ymm, Ymm, Ymm, Imm)               // AVX2
  ASMJIT_INST_4i(vpblendw, Vpblendw, Ymm, Ymm, Mem, Imm)               // AVX2
  ASMJIT_INST_2x(vpbroadcastb, Vpbroadcastb, Xmm, Xmm)                 // AVX2 AVX512_BW{kz}-VL
  ASMJIT_INST_2x(vpbroadcastb, Vpbroadcastb, Xmm, Mem)                 // AVX2 AVX512_BW{kz}-VL
  ASMJIT_INST_2x(vpbroadcastb, Vpbroadcastb, Ymm, Xmm)                 // AVX2 AVX512_BW{kz}-VL
  ASMJIT_INST_2x(vpbroadcastb, Vpbroadcastb, Ymm, Mem)                 // AVX2 AVX512_BW{kz}-VL
  ASMJIT_INST_2x(vpbroadcastb, Vpbroadcastb, Xmm, Gp)                  //      AVX512_BW{kz}-VL
  ASMJIT_INST_2x(vpbroadcastb, Vpbroadcastb, Ymm, Gp)                  //      AVX512_BW{kz}-VL
  ASMJIT_INST_2x(vpbroadcastb, Vpbroadcastb, Zmm, Gp)                  //      AVX512_BW{kz}
  ASMJIT_INST_2x(vpbroadcastb, Vpbroadcastb, Zmm, Xmm)                 //      AVX512_BW{kz}
  ASMJIT_INST_2x(vpbroadcastb, Vpbroadcastb, Zmm, Mem)                 //      AVX512_BW{kz}
  ASMJIT_INST_2x(vpbroadcastd, Vpbroadcastd, Xmm, Xmm)                 // AVX2 AVX512_F{kz}-VL
  ASMJIT_INST_2x(vpbroadcastd, Vpbroadcastd, Xmm, Mem)                 // AVX2 AVX512_F{kz}-VL
  ASMJIT_INST_2x(vpbroadcastd, Vpbroadcastd, Ymm, Xmm)                 // AVX2 AVX512_F{kz}-VL
  ASMJIT_INST_2x(vpbroadcastd, Vpbroadcastd, Ymm, Mem)                 // AVX2 AVX512_F{kz}-VL
  ASMJIT_INST_2x(vpbroadcastd, Vpbroadcastd, Xmm, Gp)                  //      AVX512_F{kz}-VL
  ASMJIT_INST_2x(vpbroadcastd, Vpbroadcastd, Ymm, Gp)                  //      AVX512_F{kz}-VL
  ASMJIT_INST_2x(vpbroadcastd, Vpbroadcastd, Zmm, Gp)                  //      AVX512_F{kz}
  ASMJIT_INST_2x(vpbroadcastd, Vpbroadcastd, Zmm, Xmm)                 //      AVX512_F{kz}
  ASMJIT_INST_2x(vpbroadcastd, Vpbroadcastd, Zmm, Mem)                 //      AVX512_F{kz}
  ASMJIT_INST_2x(vpbroadcastmb2d, Vpbroadcastmb2d, Xmm, KReg)          //      AVX512_CD-VL
  ASMJIT_INST_2x(vpbroadcastmb2d, Vpbroadcastmb2d, Ymm, KReg)          //      AVX512_CD-VL
  ASMJIT_INST_2x(vpbroadcastmb2d, Vpbroadcastmb2d, Zmm, KReg)          //      AVX512_CD
  ASMJIT_INST_2x(vpbroadcastmb2q, Vpbroadcastmb2q, Xmm, KReg)          //      AVX512_CD-VL
  ASMJIT_INST_2x(vpbroadcastmb2q, Vpbroadcastmb2q, Ymm, KReg)          //      AVX512_CD-VL
  ASMJIT_INST_2x(vpbroadcastmb2q, Vpbroadcastmb2q, Zmm, KReg)          //      AVX512_CD
  ASMJIT_INST_2x(vpbroadcastq, Vpbroadcastq, Xmm, Xmm)                 // AVX2 AVX512_F{kz}-VL
  ASMJIT_INST_2x(vpbroadcastq, Vpbroadcastq, Xmm, Mem)                 // AVX2 AVX512_F{kz}-VL
  ASMJIT_INST_2x(vpbroadcastq, Vpbroadcastq, Ymm, Xmm)                 // AVX2 AVX512_F{kz}-VL
  ASMJIT_INST_2x(vpbroadcastq, Vpbroadcastq, Ymm, Mem)                 // AVX2 AVX512_F{kz}-VL
  ASMJIT_INST_2x(vpbroadcastq, Vpbroadcastq, Xmm, Gp)                  //      AVX512_F{kz}-VL
  ASMJIT_INST_2x(vpbroadcastq, Vpbroadcastq, Ymm, Gp)                  //      AVX512_F{kz}-VL
  ASMJIT_INST_2x(vpbroadcastq, Vpbroadcastq, Zmm, Gp)                  //      AVX512_F{kz}
  ASMJIT_INST_2x(vpbroadcastq, Vpbroadcastq, Zmm, Xmm)                 //      AVX512_F{kz}
  ASMJIT_INST_2x(vpbroadcastq, Vpbroadcastq, Zmm, Mem)                 //      AVX512_F{kz}
  ASMJIT_INST_2x(vpbroadcastw, Vpbroadcastw, Xmm, Xmm)                 // AVX2 AVX512_BW{kz}-VL
  ASMJIT_INST_2x(vpbroadcastw, Vpbroadcastw, Xmm, Mem)                 // AVX2 AVX512_BW{kz}-VL
  ASMJIT_INST_2x(vpbroadcastw, Vpbroadcastw, Ymm, Xmm)                 // AVX2 AVX512_BW{kz}-VL
  ASMJIT_INST_2x(vpbroadcastw, Vpbroadcastw, Ymm, Mem)                 // AVX2 AVX512_BW{kz}-VL
  ASMJIT_INST_2x(vpbroadcastw, Vpbroadcastw, Xmm, Gp)                  //      AVX512_BW{kz}-VL
  ASMJIT_INST_2x(vpbroadcastw, Vpbroadcastw, Ymm, Gp)                  //      AVX512_BW{kz}-VL
  ASMJIT_INST_2x(vpbroadcastw, Vpbroadcastw, Zmm, Gp)                  //      AVX512_BW{kz}
  ASMJIT_INST_2x(vpbroadcastw, Vpbroadcastw, Zmm, Xmm)                 //      AVX512_BW{kz}
  ASMJIT_INST_2x(vpbroadcastw, Vpbroadcastw, Zmm, Mem)                 //      AVX512_BW{kz}
  ASMJIT_INST_4i(vpclmulqdq, Vpclmulqdq, Xmm, Xmm, Xmm, Imm)           // AVX  AVX512_F-VL
  ASMJIT_INST_4i(vpclmulqdq, Vpclmulqdq, Xmm, Xmm, Mem, Imm)           // AVX  AVX512_F-VL
  ASMJIT_INST_4i(vpclmulqdq, Vpclmulqdq, Ymm, Ymm, Ymm, Imm)           //      AVX512_F-VL VPCLMULQDQ
  ASMJIT_INST_4i(vpclmulqdq, Vpclmulqdq, Ymm, Ymm, Mem, Imm)           //      AVX512_F-VL VPCLMULQDQ
  ASMJIT_INST_4i(vpclmulqdq, Vpclmulqdq, Zmm, Zmm, Zmm, Imm)           //      AVX512_F    VPCLMULQDQ
  ASMJIT_INST_4i(vpclmulqdq, Vpclmulqdq, Zmm, Zmm, Mem, Imm)           //      AVX512_F    VPCLMULQDQ
  ASMJIT_INST_4i(vpcmpb, Vpcmpb, KReg, Xmm, Xmm, Imm)                  //      AVX512_BW{k}-VL
  ASMJIT_INST_4i(vpcmpb, Vpcmpb, KReg, Xmm, Mem, Imm)                  //      AVX512_BW{k}-VL
  ASMJIT_INST_4i(vpcmpb, Vpcmpb, KReg, Ymm, Ymm, Imm)                  //      AVX512_BW{k}-VL
  ASMJIT_INST_4i(vpcmpb, Vpcmpb, KReg, Ymm, Mem, Imm)                  //      AVX512_BW{k}-VL
  ASMJIT_INST_4i(vpcmpb, Vpcmpb, KReg, Zmm, Zmm, Imm)                  //      AVX512_BW{k}
  ASMJIT_INST_4i(vpcmpb, Vpcmpb, KReg, Zmm, Mem, Imm)                  //      AVX512_BW{k}
  ASMJIT_INST_4i(vpcmpd, Vpcmpd, KReg, Xmm, Xmm, Imm)                  //      AVX512_F{k|b32}-VL
  ASMJIT_INST_4i(vpcmpd, Vpcmpd, KReg, Xmm, Mem, Imm)                  //      AVX512_F{k|b32}-VL
  ASMJIT_INST_4i(vpcmpd, Vpcmpd, KReg, Ymm, Ymm, Imm)                  //      AVX512_F{k|b32}-VL
  ASMJIT_INST_4i(vpcmpd, Vpcmpd, KReg, Ymm, Mem, Imm)                  //      AVX512_F{k|b32}-VL
  ASMJIT_INST_4i(vpcmpd, Vpcmpd, KReg, Zmm, Zmm, Imm)                  //      AVX512_F{k|b32}
  ASMJIT_INST_4i(vpcmpd, Vpcmpd, KReg, Zmm, Mem, Imm)                  //      AVX512_F{k|b32}
  ASMJIT_INST_3x(vpcmpeqb, Vpcmpeqb, Xmm, Xmm, Xmm)                    // AVX
  ASMJIT_INST_3x(vpcmpeqb, Vpcmpeqb, Xmm, Xmm, Mem)                    // AVX
  ASMJIT_INST_3x(vpcmpeqb, Vpcmpeqb, Ymm, Ymm, Ymm)                    // AVX2
  ASMJIT_INST_3x(vpcmpeqb, Vpcmpeqb, Ymm, Ymm, Mem)                    // AVX2
  ASMJIT_INST_3x(vpcmpeqb, Vpcmpeqb, KReg, Xmm, Xmm)                   //      AVX512_BW{k}-VL
  ASMJIT_INST_3x(vpcmpeqb, Vpcmpeqb, KReg, Xmm, Mem)                   //      AVX512_BW{k}-VL
  ASMJIT_INST_3x(vpcmpeqb, Vpcmpeqb, KReg, Ymm, Ymm)                   //      AVX512_BW{k}-VL
  ASMJIT_INST_3x(vpcmpeqb, Vpcmpeqb, KReg, Ymm, Mem)                   //      AVX512_BW{k}-VL
  ASMJIT_INST_3x(vpcmpeqb, Vpcmpeqb, KReg, Zmm, Zmm)                   //      AVX512_BW{k}
  ASMJIT_INST_3x(vpcmpeqb, Vpcmpeqb, KReg, Zmm, Mem)                   //      AVX512_BW{k}
  ASMJIT_INST_3x(vpcmpeqd, Vpcmpeqd, Xmm, Xmm, Xmm)                    // AVX
  ASMJIT_INST_3x(vpcmpeqd, Vpcmpeqd, Xmm, Xmm, Mem)                    // AVX
  ASMJIT_INST_3x(vpcmpeqd, Vpcmpeqd, Ymm, Ymm, Ymm)                    // AVX2
  ASMJIT_INST_3x(vpcmpeqd, Vpcmpeqd, Ymm, Ymm, Mem)                    // AVX2
  ASMJIT_INST_3x(vpcmpeqd, Vpcmpeqd, KReg, Xmm, Xmm)                   //      AVX512_F{k|b32}-VL
  ASMJIT_INST_3x(vpcmpeqd, Vpcmpeqd, KReg, Xmm, Mem)                   //      AVX512_F{k|b32}-VL
  ASMJIT_INST_3x(vpcmpeqd, Vpcmpeqd, KReg, Ymm, Ymm)                   //      AVX512_F{k|b32}-VL
  ASMJIT_INST_3x(vpcmpeqd, Vpcmpeqd, KReg, Ymm, Mem)                   //      AVX512_F{k|b32}-VL
  ASMJIT_INST_3x(vpcmpeqd, Vpcmpeqd, KReg, Zmm, Zmm)                   //      AVX512_F{k|b32}
  ASMJIT_INST_3x(vpcmpeqd, Vpcmpeqd, KReg, Zmm, Mem)                   //      AVX512_F{k|b32}
  ASMJIT_INST_3x(vpcmpeqq, Vpcmpeqq, Xmm, Xmm, Xmm)                    // AVX
  ASMJIT_INST_3x(vpcmpeqq, Vpcmpeqq, Xmm, Xmm, Mem)                    // AVX
  ASMJIT_INST_3x(vpcmpeqq, Vpcmpeqq, Ymm, Ymm, Ymm)                    // AVX2
  ASMJIT_INST_3x(vpcmpeqq, Vpcmpeqq, Ymm, Ymm, Mem)                    // AVX2
  ASMJIT_INST_3x(vpcmpeqq, Vpcmpeqq, KReg, Xmm, Xmm)                   //      AVX512_F{k|b64}-VL
  ASMJIT_INST_3x(vpcmpeqq, Vpcmpeqq, KReg, Xmm, Mem)                   //      AVX512_F{k|b64}-VL
  ASMJIT_INST_3x(vpcmpeqq, Vpcmpeqq, KReg, Ymm, Ymm)                   //      AVX512_F{k|b64}-VL
  ASMJIT_INST_3x(vpcmpeqq, Vpcmpeqq, KReg, Ymm, Mem)                   //      AVX512_F{k|b64}-VL
  ASMJIT_INST_3x(vpcmpeqq, Vpcmpeqq, KReg, Zmm, Zmm)                   //      AVX512_F{k|b64}
  ASMJIT_INST_3x(vpcmpeqq, Vpcmpeqq, KReg, Zmm, Mem)                   //      AVX512_F{k|b64}
  ASMJIT_INST_3x(vpcmpeqw, Vpcmpeqw, Xmm, Xmm, Xmm)                    // AVX
  ASMJIT_INST_3x(vpcmpeqw, Vpcmpeqw, Xmm, Xmm, Mem)                    // AVX
  ASMJIT_INST_3x(vpcmpeqw, Vpcmpeqw, Ymm, Ymm, Ymm)                    // AVX2
  ASMJIT_INST_3x(vpcmpeqw, Vpcmpeqw, Ymm, Ymm, Mem)                    // AVX2
  ASMJIT_INST_3x(vpcmpeqw, Vpcmpeqw, KReg, Xmm, Xmm)                   //      AVX512_BW{k}-VL
  ASMJIT_INST_3x(vpcmpeqw, Vpcmpeqw, KReg, Xmm, Mem)                   //      AVX512_BW{k}-VL
  ASMJIT_INST_3x(vpcmpeqw, Vpcmpeqw, KReg, Ymm, Ymm)                   //      AVX512_BW{k}-VL
  ASMJIT_INST_3x(vpcmpeqw, Vpcmpeqw, KReg, Ymm, Mem)                   //      AVX512_BW{k}-VL
  ASMJIT_INST_3x(vpcmpeqw, Vpcmpeqw, KReg, Zmm, Zmm)                   //      AVX512_BW{k}
  ASMJIT_INST_3x(vpcmpeqw, Vpcmpeqw, KReg, Zmm, Mem)                   //      AVX512_BW{k}
  ASMJIT_INST_6x(vpcmpestri, Vpcmpestri, Xmm, Xmm, Imm, ECX, EAX, EDX) // AVX  [EXPLICIT]
  ASMJIT_INST_6x(vpcmpestri, Vpcmpestri, Xmm, Mem, Imm, ECX, EAX, EDX) // AVX  [EXPLICIT]
  ASMJIT_INST_6x(vpcmpestrm, Vpcmpestrm, Xmm, Xmm, Imm, XMM0, EAX, EDX)// AVX  [EXPLICIT]
  ASMJIT_INST_6x(vpcmpestrm, Vpcmpestrm, Xmm, Mem, Imm, XMM0, EAX, EDX)// AVX  [EXPLICIT]
  ASMJIT_INST_3x(vpcmpgtb, Vpcmpgtb, Xmm, Xmm, Xmm)                    // AVX
  ASMJIT_INST_3x(vpcmpgtb, Vpcmpgtb, Xmm, Xmm, Mem)                    // AVX
  ASMJIT_INST_3x(vpcmpgtb, Vpcmpgtb, Ymm, Ymm, Ymm)                    // AVX2
  ASMJIT_INST_3x(vpcmpgtb, Vpcmpgtb, Ymm, Ymm, Mem)                    // AVX2
  ASMJIT_INST_3x(vpcmpgtb, Vpcmpgtb, KReg, Xmm, Xmm)                   //      AVX512_BW{k}-VL
  ASMJIT_INST_3x(vpcmpgtb, Vpcmpgtb, KReg, Xmm, Mem)                   //      AVX512_BW{k}-VL
  ASMJIT_INST_3x(vpcmpgtb, Vpcmpgtb, KReg, Ymm, Ymm)                   //      AVX512_BW{k}-VL
  ASMJIT_INST_3x(vpcmpgtb, Vpcmpgtb, KReg, Ymm, Mem)                   //      AVX512_BW{k}-VL
  ASMJIT_INST_3x(vpcmpgtb, Vpcmpgtb, KReg, Zmm, Zmm)                   //      AVX512_BW{k}
  ASMJIT_INST_3x(vpcmpgtb, Vpcmpgtb, KReg, Zmm, Mem)                   //      AVX512_BW{k}
  ASMJIT_INST_3x(vpcmpgtd, Vpcmpgtd, Xmm, Xmm, Xmm)                    // AVX
  ASMJIT_INST_3x(vpcmpgtd, Vpcmpgtd, Xmm, Xmm, Mem)                    // AVX
  ASMJIT_INST_3x(vpcmpgtd, Vpcmpgtd, Ymm, Ymm, Ymm)                    // AVX2
  ASMJIT_INST_3x(vpcmpgtd, Vpcmpgtd, Ymm, Ymm, Mem)                    // AVX2
  ASMJIT_INST_3x(vpcmpgtd, Vpcmpgtd, KReg, Xmm, Xmm)                   //      AVX512_F{k|b32}-VL
  ASMJIT_INST_3x(vpcmpgtd, Vpcmpgtd, KReg, Xmm, Mem)                   //      AVX512_F{k|b32}-VL
  ASMJIT_INST_3x(vpcmpgtd, Vpcmpgtd, KReg, Ymm, Ymm)                   //      AVX512_F{k|b32}-VL
  ASMJIT_INST_3x(vpcmpgtd, Vpcmpgtd, KReg, Ymm, Mem)                   //      AVX512_F{k|b32}-VL
  ASMJIT_INST_3x(vpcmpgtd, Vpcmpgtd, KReg, Zmm, Zmm)                   //      AVX512_F{k|b32}
  ASMJIT_INST_3x(vpcmpgtd, Vpcmpgtd, KReg, Zmm, Mem)                   //      AVX512_F{k|b32}
  ASMJIT_INST_3x(vpcmpgtq, Vpcmpgtq, Xmm, Xmm, Xmm)                    // AVX
  ASMJIT_INST_3x(vpcmpgtq, Vpcmpgtq, Xmm, Xmm, Mem)                    // AVX
  ASMJIT_INST_3x(vpcmpgtq, Vpcmpgtq, Ymm, Ymm, Ymm)                    // AVX2
  ASMJIT_INST_3x(vpcmpgtq, Vpcmpgtq, Ymm, Ymm, Mem)                    // AVX2
  ASMJIT_INST_3x(vpcmpgtq, Vpcmpgtq, KReg, Xmm, Xmm)                   //      AVX512_F{k|b64}-VL
  ASMJIT_INST_3x(vpcmpgtq, Vpcmpgtq, KReg, Xmm, Mem)                   //      AVX512_F{k|b64}-VL
  ASMJIT_INST_3x(vpcmpgtq, Vpcmpgtq, KReg, Ymm, Ymm)                   //      AVX512_F{k|b64}-VL
  ASMJIT_INST_3x(vpcmpgtq, Vpcmpgtq, KReg, Ymm, Mem)                   //      AVX512_F{k|b64}-VL
  ASMJIT_INST_3x(vpcmpgtq, Vpcmpgtq, KReg, Zmm, Zmm)                   //      AVX512_F{k|b64}
  ASMJIT_INST_3x(vpcmpgtq, Vpcmpgtq, KReg, Zmm, Mem)                   //      AVX512_F{k|b64}
  ASMJIT_INST_3x(vpcmpgtw, Vpcmpgtw, Xmm, Xmm, Xmm)                    // AVX
  ASMJIT_INST_3x(vpcmpgtw, Vpcmpgtw, Xmm, Xmm, Mem)                    // AVX
  ASMJIT_INST_3x(vpcmpgtw, Vpcmpgtw, Ymm, Ymm, Ymm)                    // AVX2
  ASMJIT_INST_3x(vpcmpgtw, Vpcmpgtw, Ymm, Ymm, Mem)                    // AVX2
  ASMJIT_INST_3x(vpcmpgtw, Vpcmpgtw, KReg, Xmm, Xmm)                   //      AVX512_BW{k}-VL
  ASMJIT_INST_3x(vpcmpgtw, Vpcmpgtw, KReg, Xmm, Mem)                   //      AVX512_BW{k}-VL
  ASMJIT_INST_3x(vpcmpgtw, Vpcmpgtw, KReg, Ymm, Ymm)                   //      AVX512_BW{k}-VL
  ASMJIT_INST_3x(vpcmpgtw, Vpcmpgtw, KReg, Ymm, Mem)                   //      AVX512_BW{k}-VL
  ASMJIT_INST_3x(vpcmpgtw, Vpcmpgtw, KReg, Zmm, Zmm)                   //      AVX512_BW{k}
  ASMJIT_INST_3x(vpcmpgtw, Vpcmpgtw, KReg, Zmm, Mem)                   //      AVX512_BW{k}
  ASMJIT_INST_4x(vpcmpistri, Vpcmpistri, Xmm, Xmm, Imm, ECX)           // AVX  [EXPLICIT]
  ASMJIT_INST_4x(vpcmpistri, Vpcmpistri, Xmm, Mem, Imm, ECX)           // AVX  [EXPLICIT]
  ASMJIT_INST_4x(vpcmpistrm, Vpcmpistrm, Xmm, Xmm, Imm, XMM0)          // AVX  [EXPLICIT]
  ASMJIT_INST_4x(vpcmpistrm, Vpcmpistrm, Xmm, Mem, Imm, XMM0)          // AVX  [EXPLICIT]
  ASMJIT_INST_4i(vpcmpq, Vpcmpq, KReg, Xmm, Xmm, Imm)                  //      AVX512_F{k|b64}-VL
  ASMJIT_INST_4i(vpcmpq, Vpcmpq, KReg, Xmm, Mem, Imm)                  //      AVX512_F{k|b64}-VL
  ASMJIT_INST_4i(vpcmpq, Vpcmpq, KReg, Ymm, Ymm, Imm)                  //      AVX512_F{k|b64}-VL
  ASMJIT_INST_4i(vpcmpq, Vpcmpq, KReg, Ymm, Mem, Imm)                  //      AVX512_F{k|b64}-VL
  ASMJIT_INST_4i(vpcmpq, Vpcmpq, KReg, Zmm, Zmm, Imm)                  //      AVX512_F{k|b64}
  ASMJIT_INST_4i(vpcmpq, Vpcmpq, KReg, Zmm, Mem, Imm)                  //      AVX512_F{k|b64}
  ASMJIT_INST_4i(vpcmpub, Vpcmpub, KReg, Xmm, Xmm, Imm)                //      AVX512_BW{k}-VL
  ASMJIT_INST_4i(vpcmpub, Vpcmpub, KReg, Xmm, Mem, Imm)                //      AVX512_BW{k}-VL
  ASMJIT_INST_4i(vpcmpub, Vpcmpub, KReg, Ymm, Ymm, Imm)                //      AVX512_BW{k}-VL
  ASMJIT_INST_4i(vpcmpub, Vpcmpub, KReg, Ymm, Mem, Imm)                //      AVX512_BW{k}-VL
  ASMJIT_INST_4i(vpcmpub, Vpcmpub, KReg, Zmm, Zmm, Imm)                //      AVX512_BW{k}
  ASMJIT_INST_4i(vpcmpub, Vpcmpub, KReg, Zmm, Mem, Imm)                //      AVX512_BW{k}
  ASMJIT_INST_4i(vpcmpud, Vpcmpud, KReg, Xmm, Xmm, Imm)                //      AVX512_F{k|b32}-VL
  ASMJIT_INST_4i(vpcmpud, Vpcmpud, KReg, Xmm, Mem, Imm)                //      AVX512_F{k|b32}-VL
  ASMJIT_INST_4i(vpcmpud, Vpcmpud, KReg, Ymm, Ymm, Imm)                //      AVX512_F{k|b32}-VL
  ASMJIT_INST_4i(vpcmpud, Vpcmpud, KReg, Ymm, Mem, Imm)                //      AVX512_F{k|b32}-VL
  ASMJIT_INST_4i(vpcmpud, Vpcmpud, KReg, Zmm, Zmm, Imm)                //      AVX512_F{k|b32}
  ASMJIT_INST_4i(vpcmpud, Vpcmpud, KReg, Zmm, Mem, Imm)                //      AVX512_F{k|b32}
  ASMJIT_INST_4i(vpcmpuq, Vpcmpuq, KReg, Xmm, Xmm, Imm)                //      AVX512_F{k|b64}-VL
  ASMJIT_INST_4i(vpcmpuq, Vpcmpuq, KReg, Xmm, Mem, Imm)                //      AVX512_F{k|b64}-VL
  ASMJIT_INST_4i(vpcmpuq, Vpcmpuq, KReg, Ymm, Ymm, Imm)                //      AVX512_F{k|b64}-VL
  ASMJIT_INST_4i(vpcmpuq, Vpcmpuq, KReg, Ymm, Mem, Imm)                //      AVX512_F{k|b64}-VL
  ASMJIT_INST_4i(vpcmpuq, Vpcmpuq, KReg, Zmm, Zmm, Imm)                //      AVX512_F{k|b64}
  ASMJIT_INST_4i(vpcmpuq, Vpcmpuq, KReg, Zmm, Mem, Imm)                //      AVX512_F{k|b64}
  ASMJIT_INST_4i(vpcmpuw, Vpcmpuw, KReg, Xmm, Xmm, Imm)                //      AVX512_BW{k|b64}-VL
  ASMJIT_INST_4i(vpcmpuw, Vpcmpuw, KReg, Xmm, Mem, Imm)                //      AVX512_BW{k|b64}-VL
  ASMJIT_INST_4i(vpcmpuw, Vpcmpuw, KReg, Ymm, Ymm, Imm)                //      AVX512_BW{k|b64}-VL
  ASMJIT_INST_4i(vpcmpuw, Vpcmpuw, KReg, Ymm, Mem, Imm)                //      AVX512_BW{k|b64}-VL
  ASMJIT_INST_4i(vpcmpuw, Vpcmpuw, KReg, Zmm, Zmm, Imm)                //      AVX512_BW{k|b64}
  ASMJIT_INST_4i(vpcmpuw, Vpcmpuw, KReg, Zmm, Mem, Imm)                //      AVX512_BW{k|b64}
  ASMJIT_INST_4i(vpcmpw, Vpcmpw, KReg, Xmm, Xmm, Imm)                  //      AVX512_BW{k|b64}-VL
  ASMJIT_INST_4i(vpcmpw, Vpcmpw, KReg, Xmm, Mem, Imm)                  //      AVX512_BW{k|b64}-VL
  ASMJIT_INST_4i(vpcmpw, Vpcmpw, KReg, Ymm, Ymm, Imm)                  //      AVX512_BW{k|b64}-VL
  ASMJIT_INST_4i(vpcmpw, Vpcmpw, KReg, Ymm, Mem, Imm)                  //      AVX512_BW{k|b64}-VL
  ASMJIT_INST_4i(vpcmpw, Vpcmpw, KReg, Zmm, Zmm, Imm)                  //      AVX512_BW{k|b64}
  ASMJIT_INST_4i(vpcmpw, Vpcmpw, KReg, Zmm, Mem, Imm)                  //      AVX512_BW{k|b64}
  ASMJIT_INST_2x(vpcompressb, Vpcompressb, Xmm, Xmm)                   //      AVX512_VBMI2{kz}-VL
  ASMJIT_INST_2x(vpcompressb, Vpcompressb, Mem, Xmm)                   //      AVX512_VBMI2{kz}-VL
  ASMJIT_INST_2x(vpcompressb, Vpcompressb, Ymm, Ymm)                   //      AVX512_VBMI2{kz}-VL
  ASMJIT_INST_2x(vpcompressb, Vpcompressb, Mem, Ymm)                   //      AVX512_VBMI2{kz}-VL
  ASMJIT_INST_2x(vpcompressb, Vpcompressb, Zmm, Zmm)                   //      AVX512_VBMI2{kz}
  ASMJIT_INST_2x(vpcompressb, Vpcompressb, Mem, Zmm)                   //      AVX512_VBMI2{kz}
  ASMJIT_INST_2x(vpcompressd, Vpcompressd, Xmm, Xmm)                   //      AVX512_F{kz}-VL
  ASMJIT_INST_2x(vpcompressd, Vpcompressd, Mem, Xmm)                   //      AVX512_F{kz}-VL
  ASMJIT_INST_2x(vpcompressd, Vpcompressd, Ymm, Ymm)                   //      AVX512_F{kz}-VL
  ASMJIT_INST_2x(vpcompressd, Vpcompressd, Mem, Ymm)                   //      AVX512_F{kz}-VL
  ASMJIT_INST_2x(vpcompressd, Vpcompressd, Zmm, Zmm)                   //      AVX512_F{kz}
  ASMJIT_INST_2x(vpcompressd, Vpcompressd, Mem, Zmm)                   //      AVX512_F{kz}
  ASMJIT_INST_2x(vpcompressq, Vpcompressq, Xmm, Xmm)                   //      AVX512_F{kz}-VL
  ASMJIT_INST_2x(vpcompressq, Vpcompressq, Mem, Xmm)                   //      AVX512_F{kz}-VL
  ASMJIT_INST_2x(vpcompressq, Vpcompressq, Ymm, Ymm)                   //      AVX512_F{kz}-VL
  ASMJIT_INST_2x(vpcompressq, Vpcompressq, Mem, Ymm)                   //      AVX512_F{kz}-VL
  ASMJIT_INST_2x(vpcompressq, Vpcompressq, Zmm, Zmm)                   //      AVX512_F{kz}
  ASMJIT_INST_2x(vpcompressq, Vpcompressq, Mem, Zmm)                   //      AVX512_F{kz}
  ASMJIT_INST_2x(vpcompressw, Vpcompressw, Xmm, Xmm)                   //      AVX512_VBMI2{kz}-VL
  ASMJIT_INST_2x(vpcompressw, Vpcompressw, Mem, Xmm)                   //      AVX512_VBMI2{kz}-VL
  ASMJIT_INST_2x(vpcompressw, Vpcompressw, Ymm, Ymm)                   //      AVX512_VBMI2{kz}-VL
  ASMJIT_INST_2x(vpcompressw, Vpcompressw, Mem, Ymm)                   //      AVX512_VBMI2{kz}-VL
  ASMJIT_INST_2x(vpcompressw, Vpcompressw, Zmm, Zmm)                   //      AVX512_VBMI2{kz}
  ASMJIT_INST_2x(vpcompressw, Vpcompressw, Mem, Zmm)                   //      AVX512_VBMI2{kz}
  ASMJIT_INST_2x(vpconflictd, Vpconflictd, Xmm, Xmm)                   //      AVX512_CD{kz|b32}-VL
  ASMJIT_INST_2x(vpconflictd, Vpconflictd, Xmm, Mem)                   //      AVX512_CD{kz|b32}-VL
  ASMJIT_INST_2x(vpconflictd, Vpconflictd, Ymm, Ymm)                   //      AVX512_CD{kz|b32}-VL
  ASMJIT_INST_2x(vpconflictd, Vpconflictd, Ymm, Mem)                   //      AVX512_CD{kz|b32}-VL
  ASMJIT_INST_2x(vpconflictd, Vpconflictd, Zmm, Zmm)                   //      AVX512_CD{kz|b32}
  ASMJIT_INST_2x(vpconflictd, Vpconflictd, Zmm, Mem)                   //      AVX512_CD{kz|b32}
  ASMJIT_INST_2x(vpconflictq, Vpconflictq, Xmm, Xmm)                   //      AVX512_CD{kz|b32}-VL
  ASMJIT_INST_2x(vpconflictq, Vpconflictq, Xmm, Mem)                   //      AVX512_CD{kz|b32}-VL
  ASMJIT_INST_2x(vpconflictq, Vpconflictq, Ymm, Ymm)                   //      AVX512_CD{kz|b32}-VL
  ASMJIT_INST_2x(vpconflictq, Vpconflictq, Ymm, Mem)                   //      AVX512_CD{kz|b32}-VL
  ASMJIT_INST_2x(vpconflictq, Vpconflictq, Zmm, Zmm)                   //      AVX512_CD{kz|b32}
  ASMJIT_INST_2x(vpconflictq, Vpconflictq, Zmm, Mem)                   //      AVX512_CD{kz|b32}
  ASMJIT_INST_4i(vperm2f128, Vperm2f128, Ymm, Ymm, Ymm, Imm)           // AVX
  ASMJIT_INST_4i(vperm2f128, Vperm2f128, Ymm, Ymm, Mem, Imm)           // AVX
  ASMJIT_INST_4i(vperm2i128, Vperm2i128, Ymm, Ymm, Ymm, Imm)           // AVX2
  ASMJIT_INST_4i(vperm2i128, Vperm2i128, Ymm, Ymm, Mem, Imm)           // AVX2
  ASMJIT_INST_3x(vpermb, Vpermb, Xmm, Xmm, Xmm)                        //      AVX512_VBMI{kz}-VL
  ASMJIT_INST_3x(vpermb, Vpermb, Xmm, Xmm, Mem)                        //      AVX512_VBMI{kz}-VL
  ASMJIT_INST_3x(vpermb, Vpermb, Ymm, Ymm, Ymm)                        //      AVX512_VBMI{kz}-VL
  ASMJIT_INST_3x(vpermb, Vpermb, Ymm, Ymm, Mem)                        //      AVX512_VBMI{kz}-VL
  ASMJIT_INST_3x(vpermb, Vpermb, Zmm, Zmm, Zmm)                        //      AVX512_VBMI{kz}
  ASMJIT_INST_3x(vpermb, Vpermb, Zmm, Zmm, Mem)                        //      AVX512_VBMI{kz}
  ASMJIT_INST_3x(vpermd, Vpermd, Ymm, Ymm, Ymm)                        // AVX2 AVX512_F{kz|b32}-VL
  ASMJIT_INST_3x(vpermd, Vpermd, Ymm, Ymm, Mem)                        // AVX2 AVX512_F{kz|b32}-VL
  ASMJIT_INST_3x(vpermd, Vpermd, Zmm, Zmm, Zmm)                        //      AVX512_F{kz|b32}-VL
  ASMJIT_INST_3x(vpermd, Vpermd, Zmm, Zmm, Mem)                        //      AVX512_F{kz|b32}-VL
  ASMJIT_INST_3x(vpermi2b, Vpermi2b, Xmm, Xmm, Xmm)                    //      AVX512_VBMI{kz}-VL
  ASMJIT_INST_3x(vpermi2b, Vpermi2b, Xmm, Xmm, Mem)                    //      AVX512_VBMI{kz}-VL
  ASMJIT_INST_3x(vpermi2b, Vpermi2b, Ymm, Ymm, Ymm)                    //      AVX512_VBMI{kz}-VL
  ASMJIT_INST_3x(vpermi2b, Vpermi2b, Ymm, Ymm, Mem)                    //      AVX512_VBMI{kz}-VL
  ASMJIT_INST_3x(vpermi2b, Vpermi2b, Zmm, Zmm, Zmm)                    //      AVX512_VBMI{kz}
  ASMJIT_INST_3x(vpermi2b, Vpermi2b, Zmm, Zmm, Mem)                    //      AVX512_VBMI{kz}
  ASMJIT_INST_3x(vpermi2d, Vpermi2d, Xmm, Xmm, Xmm)                    //      AVX512_F{kz|b32}-VL
  ASMJIT_INST_3x(vpermi2d, Vpermi2d, Xmm, Xmm, Mem)                    //      AVX512_F{kz|b32}-VL
  ASMJIT_INST_3x(vpermi2d, Vpermi2d, Ymm, Ymm, Ymm)                    //      AVX512_F{kz|b32}-VL
  ASMJIT_INST_3x(vpermi2d, Vpermi2d, Ymm, Ymm, Mem)                    //      AVX512_F{kz|b32}-VL
  ASMJIT_INST_3x(vpermi2d, Vpermi2d, Zmm, Zmm, Zmm)                    //      AVX512_F{kz|b32}
  ASMJIT_INST_3x(vpermi2d, Vpermi2d, Zmm, Zmm, Mem)                    //      AVX512_F{kz|b32}
  ASMJIT_INST_3x(vpermi2pd, Vpermi2pd, Xmm, Xmm, Xmm)                  //      AVX512_F{kz|b64}-VL
  ASMJIT_INST_3x(vpermi2pd, Vpermi2pd, Xmm, Xmm, Mem)                  //      AVX512_F{kz|b64}-VL
  ASMJIT_INST_3x(vpermi2pd, Vpermi2pd, Ymm, Ymm, Ymm)                  //      AVX512_F{kz|b64}-VL
  ASMJIT_INST_3x(vpermi2pd, Vpermi2pd, Ymm, Ymm, Mem)                  //      AVX512_F{kz|b64}-VL
  ASMJIT_INST_3x(vpermi2pd, Vpermi2pd, Zmm, Zmm, Zmm)                  //      AVX512_F{kz|b64}
  ASMJIT_INST_3x(vpermi2pd, Vpermi2pd, Zmm, Zmm, Mem)                  //      AVX512_F{kz|b64}
  ASMJIT_INST_3x(vpermi2ps, Vpermi2ps, Xmm, Xmm, Xmm)                  //      AVX512_F{kz|b32}-VL
  ASMJIT_INST_3x(vpermi2ps, Vpermi2ps, Xmm, Xmm, Mem)                  //      AVX512_F{kz|b32}-VL
  ASMJIT_INST_3x(vpermi2ps, Vpermi2ps, Ymm, Ymm, Ymm)                  //      AVX512_F{kz|b32}-VL
  ASMJIT_INST_3x(vpermi2ps, Vpermi2ps, Ymm, Ymm, Mem)                  //      AVX512_F{kz|b32}-VL
  ASMJIT_INST_3x(vpermi2ps, Vpermi2ps, Zmm, Zmm, Zmm)                  //      AVX512_F{kz|b32}
  ASMJIT_INST_3x(vpermi2ps, Vpermi2ps, Zmm, Zmm, Mem)                  //      AVX512_F{kz|b32}
  ASMJIT_INST_3x(vpermi2q, Vpermi2q, Xmm, Xmm, Xmm)                    //      AVX512_F{kz|b64}-VL
  ASMJIT_INST_3x(vpermi2q, Vpermi2q, Xmm, Xmm, Mem)                    //      AVX512_F{kz|b64}-VL
  ASMJIT_INST_3x(vpermi2q, Vpermi2q, Ymm, Ymm, Ymm)                    //      AVX512_F{kz|b64}-VL
  ASMJIT_INST_3x(vpermi2q, Vpermi2q, Ymm, Ymm, Mem)                    //      AVX512_F{kz|b64}-VL
  ASMJIT_INST_3x(vpermi2q, Vpermi2q, Zmm, Zmm, Zmm)                    //      AVX512_F{kz|b64}
  ASMJIT_INST_3x(vpermi2q, Vpermi2q, Zmm, Zmm, Mem)                    //      AVX512_F{kz|b64}
  ASMJIT_INST_3x(vpermi2w, Vpermi2w, Xmm, Xmm, Xmm)                    //      AVX512_BW{kz}-VL
  ASMJIT_INST_3x(vpermi2w, Vpermi2w, Xmm, Xmm, Mem)                    //      AVX512_BW{kz}-VL
  ASMJIT_INST_3x(vpermi2w, Vpermi2w, Ymm, Ymm, Ymm)                    //      AVX512_BW{kz}-VL
  ASMJIT_INST_3x(vpermi2w, Vpermi2w, Ymm, Ymm, Mem)                    //      AVX512_BW{kz}-VL
  ASMJIT_INST_3x(vpermi2w, Vpermi2w, Zmm, Zmm, Zmm)                    //      AVX512_BW{kz}
  ASMJIT_INST_3x(vpermi2w, Vpermi2w, Zmm, Zmm, Mem)                    //      AVX512_BW{kz}
  ASMJIT_INST_3x(vpermilpd, Vpermilpd, Xmm, Xmm, Xmm)                  // AVX  AVX512_F{kz|b64}-VL
  ASMJIT_INST_3x(vpermilpd, Vpermilpd, Xmm, Xmm, Mem)                  // AVX  AVX512_F{kz|b64}-VL
  ASMJIT_INST_3i(vpermilpd, Vpermilpd, Xmm, Xmm, Imm)                  // AVX  AVX512_F{kz|b64}-VL
  ASMJIT_INST_3i(vpermilpd, Vpermilpd, Xmm, Mem, Imm)                  // AVX  AVX512_F{kz|b64}-VL
  ASMJIT_INST_3x(vpermilpd, Vpermilpd, Ymm, Ymm, Ymm)                  // AVX  AVX512_F{kz|b64}-VL
  ASMJIT_INST_3x(vpermilpd, Vpermilpd, Ymm, Ymm, Mem)                  // AVX  AVX512_F{kz|b64}-VL
  ASMJIT_INST_3i(vpermilpd, Vpermilpd, Ymm, Ymm, Imm)                  // AVX  AVX512_F{kz|b64}-VL
  ASMJIT_INST_3i(vpermilpd, Vpermilpd, Ymm, Mem, Imm)                  // AVX  AVX512_F{kz|b64}-VL
  ASMJIT_INST_3x(vpermilpd, Vpermilpd, Zmm, Zmm, Zmm)                  //      AVX512_F{kz|b64}
  ASMJIT_INST_3x(vpermilpd, Vpermilpd, Zmm, Zmm, Mem)                  //      AVX512_F{kz|b64}
  ASMJIT_INST_3i(vpermilpd, Vpermilpd, Zmm, Zmm, Imm)                  //      AVX512_F{kz|b64}
  ASMJIT_INST_3i(vpermilpd, Vpermilpd, Zmm, Mem, Imm)                  //      AVX512_F{kz|b64}
  ASMJIT_INST_3x(vpermilps, Vpermilps, Xmm, Xmm, Xmm)                  // AVX  AVX512_F{kz|b64}-VL
  ASMJIT_INST_3x(vpermilps, Vpermilps, Xmm, Xmm, Mem)                  // AVX  AVX512_F{kz|b64}-VL
  ASMJIT_INST_3i(vpermilps, Vpermilps, Xmm, Xmm, Imm)                  // AVX  AVX512_F{kz|b64}-VL
  ASMJIT_INST_3i(vpermilps, Vpermilps, Xmm, Mem, Imm)                  // AVX  AVX512_F{kz|b64}-VL
  ASMJIT_INST_3x(vpermilps, Vpermilps, Ymm, Ymm, Ymm)                  // AVX  AVX512_F{kz|b64}-VL
  ASMJIT_INST_3x(vpermilps, Vpermilps, Ymm, Ymm, Mem)                  // AVX  AVX512_F{kz|b64}-VL
  ASMJIT_INST_3i(vpermilps, Vpermilps, Ymm, Ymm, Imm)                  // AVX  AVX512_F{kz|b64}-VL
  ASMJIT_INST_3i(vpermilps, Vpermilps, Ymm, Mem, Imm)                  // AVX  AVX512_F{kz|b64}-VL
  ASMJIT_INST_3x(vpermilps, Vpermilps, Zmm, Zmm, Zmm)                  //      AVX512_F{kz|b64}
  ASMJIT_INST_3x(vpermilps, Vpermilps, Zmm, Zmm, Mem)                  //      AVX512_F{kz|b64}
  ASMJIT_INST_3i(vpermilps, Vpermilps, Zmm, Zmm, Imm)                  //      AVX512_F{kz|b64}
  ASMJIT_INST_3i(vpermilps, Vpermilps, Zmm, Mem, Imm)                  //      AVX512_F{kz|b64}
  ASMJIT_INST_3i(vpermpd, Vpermpd, Ymm, Ymm, Imm)                      // AVX2
  ASMJIT_INST_3i(vpermpd, Vpermpd, Ymm, Mem, Imm)                      // AVX2
  ASMJIT_INST_3x(vpermps, Vpermps, Ymm, Ymm, Ymm)                      // AVX2
  ASMJIT_INST_3x(vpermps, Vpermps, Ymm, Ymm, Mem)                      // AVX2
  ASMJIT_INST_3i(vpermq, Vpermq, Ymm, Ymm, Imm)                        // AVX2 AVX512_F{kz|b64}-VL
  ASMJIT_INST_3i(vpermq, Vpermq, Ymm, Mem, Imm)                        // AVX2 AVX512_F{kz|b64}-VL
  ASMJIT_INST_3x(vpermq, Vpermq, Ymm, Ymm, Ymm)                        //      AVX512_F{kz|b64}-VL
  ASMJIT_INST_3x(vpermq, Vpermq, Ymm, Ymm, Mem)                        //      AVX512_F{kz|b64}-VL
  ASMJIT_INST_3x(vpermq, Vpermq, Zmm, Zmm, Zmm)                        //      AVX512_F{kz|b64}-VL
  ASMJIT_INST_3x(vpermq, Vpermq, Zmm, Zmm, Mem)                        //      AVX512_F{kz|b64}-VL
  ASMJIT_INST_3i(vpermq, Vpermq, Zmm, Zmm, Imm)                        //      AVX512_F{kz|b64}-VL
  ASMJIT_INST_3i(vpermq, Vpermq, Zmm, Mem, Imm)                        //      AVX512_F{kz|b64}-VL
  ASMJIT_INST_3x(vpermt2b, Vpermt2b, Xmm, Xmm, Xmm)                    //      AVX512_VBMI{kz}-VL
  ASMJIT_INST_3x(vpermt2b, Vpermt2b, Xmm, Xmm, Mem)                    //      AVX512_VBMI{kz}-VL
  ASMJIT_INST_3x(vpermt2b, Vpermt2b, Ymm, Ymm, Ymm)                    //      AVX512_VBMI{kz}-VL
  ASMJIT_INST_3x(vpermt2b, Vpermt2b, Ymm, Ymm, Mem)                    //      AVX512_VBMI{kz}-VL
  ASMJIT_INST_3x(vpermt2b, Vpermt2b, Zmm, Zmm, Zmm)                    //      AVX512_VBMI{kz}
  ASMJIT_INST_3x(vpermt2b, Vpermt2b, Zmm, Zmm, Mem)                    //      AVX512_VBMI{kz}
  ASMJIT_INST_3x(vpermt2d, Vpermt2d, Xmm, Xmm, Xmm)                    //      AVX512_F{kz|b32}-VL
  ASMJIT_INST_3x(vpermt2d, Vpermt2d, Xmm, Xmm, Mem)                    //      AVX512_F{kz|b32}-VL
  ASMJIT_INST_3x(vpermt2d, Vpermt2d, Ymm, Ymm, Ymm)                    //      AVX512_F{kz|b32}-VL
  ASMJIT_INST_3x(vpermt2d, Vpermt2d, Ymm, Ymm, Mem)                    //      AVX512_F{kz|b32}-VL
  ASMJIT_INST_3x(vpermt2d, Vpermt2d, Zmm, Zmm, Zmm)                    //      AVX512_F{kz|b32}
  ASMJIT_INST_3x(vpermt2d, Vpermt2d, Zmm, Zmm, Mem)                    //      AVX512_F{kz|b32}
  ASMJIT_INST_3x(vpermt2pd, Vpermt2pd, Xmm, Xmm, Xmm)                  //      AVX512_F{kz|b64}-VL
  ASMJIT_INST_3x(vpermt2pd, Vpermt2pd, Xmm, Xmm, Mem)                  //      AVX512_F{kz|b64}-VL
  ASMJIT_INST_3x(vpermt2pd, Vpermt2pd, Ymm, Ymm, Ymm)                  //      AVX512_F{kz|b64}-VL
  ASMJIT_INST_3x(vpermt2pd, Vpermt2pd, Ymm, Ymm, Mem)                  //      AVX512_F{kz|b64}-VL
  ASMJIT_INST_3x(vpermt2pd, Vpermt2pd, Zmm, Zmm, Zmm)                  //      AVX512_F{kz|b64}
  ASMJIT_INST_3x(vpermt2pd, Vpermt2pd, Zmm, Zmm, Mem)                  //      AVX512_F{kz|b64}
  ASMJIT_INST_3x(vpermt2ps, Vpermt2ps, Xmm, Xmm, Xmm)                  //      AVX512_F{kz|b32}-VL
  ASMJIT_INST_3x(vpermt2ps, Vpermt2ps, Xmm, Xmm, Mem)                  //      AVX512_F{kz|b32}-VL
  ASMJIT_INST_3x(vpermt2ps, Vpermt2ps, Ymm, Ymm, Ymm)                  //      AVX512_F{kz|b32}-VL
  ASMJIT_INST_3x(vpermt2ps, Vpermt2ps, Ymm, Ymm, Mem)                  //      AVX512_F{kz|b32}-VL
  ASMJIT_INST_3x(vpermt2ps, Vpermt2ps, Zmm, Zmm, Zmm)                  //      AVX512_F{kz|b32}
  ASMJIT_INST_3x(vpermt2ps, Vpermt2ps, Zmm, Zmm, Mem)                  //      AVX512_F{kz|b32}
  ASMJIT_INST_3x(vpermt2q, Vpermt2q, Xmm, Xmm, Xmm)                    //      AVX512_F{kz|b64}-VL
  ASMJIT_INST_3x(vpermt2q, Vpermt2q, Xmm, Xmm, Mem)                    //      AVX512_F{kz|b64}-VL
  ASMJIT_INST_3x(vpermt2q, Vpermt2q, Ymm, Ymm, Ymm)                    //      AVX512_F{kz|b64}-VL
  ASMJIT_INST_3x(vpermt2q, Vpermt2q, Ymm, Ymm, Mem)                    //      AVX512_F{kz|b64}-VL
  ASMJIT_INST_3x(vpermt2q, Vpermt2q, Zmm, Zmm, Zmm)                    //      AVX512_F{kz|b64}
  ASMJIT_INST_3x(vpermt2q, Vpermt2q, Zmm, Zmm, Mem)                    //      AVX512_F{kz|b64}
  ASMJIT_INST_3x(vpermt2w, Vpermt2w, Xmm, Xmm, Xmm)                    //      AVX512_BW{kz}-VL
  ASMJIT_INST_3x(vpermt2w, Vpermt2w, Xmm, Xmm, Mem)                    //      AVX512_BW{kz}-VL
  ASMJIT_INST_3x(vpermt2w, Vpermt2w, Ymm, Ymm, Ymm)                    //      AVX512_BW{kz}-VL
  ASMJIT_INST_3x(vpermt2w, Vpermt2w, Ymm, Ymm, Mem)                    //      AVX512_BW{kz}-VL
  ASMJIT_INST_3x(vpermt2w, Vpermt2w, Zmm, Zmm, Zmm)                    //      AVX512_BW{kz}
  ASMJIT_INST_3x(vpermt2w, Vpermt2w, Zmm, Zmm, Mem)                    //      AVX512_BW{kz}
  ASMJIT_INST_3x(vpermw, Vpermw, Xmm, Xmm, Xmm)                        //      AVX512_BW{kz}-VL
  ASMJIT_INST_3x(vpermw, Vpermw, Xmm, Xmm, Mem)                        //      AVX512_BW{kz}-VL
  ASMJIT_INST_3x(vpermw, Vpermw, Ymm, Ymm, Ymm)                        //      AVX512_BW{kz}-VL
  ASMJIT_INST_3x(vpermw, Vpermw, Ymm, Ymm, Mem)                        //      AVX512_BW{kz}-VL
  ASMJIT_INST_3x(vpermw, Vpermw, Zmm, Zmm, Zmm)                        //      AVX512_BW{kz}
  ASMJIT_INST_3x(vpermw, Vpermw, Zmm, Zmm, Mem)                        //      AVX512_BW{kz}
  ASMJIT_INST_2x(vpexpandb, Vpexpandb, Xmm, Xmm)                       //      AVX512_VBMI2{kz}-VL
  ASMJIT_INST_2x(vpexpandb, Vpexpandb, Xmm, Mem)                       //      AVX512_VBMI2{kz}-VL
  ASMJIT_INST_2x(vpexpandb, Vpexpandb, Ymm, Ymm)                       //      AVX512_VBMI2{kz}-VL
  ASMJIT_INST_2x(vpexpandb, Vpexpandb, Ymm, Mem)                       //      AVX512_VBMI2{kz}-VL
  ASMJIT_INST_2x(vpexpandb, Vpexpandb, Zmm, Zmm)                       //      AVX512_VBMI2{kz}
  ASMJIT_INST_2x(vpexpandb, Vpexpandb, Zmm, Mem)                       //      AVX512_VBMI2{kz}
  ASMJIT_INST_2x(vpexpandd, Vpexpandd, Xmm, Xmm)                       //      AVX512_F{kz}-VL
  ASMJIT_INST_2x(vpexpandd, Vpexpandd, Xmm, Mem)                       //      AVX512_F{kz}-VL
  ASMJIT_INST_2x(vpexpandd, Vpexpandd, Ymm, Ymm)                       //      AVX512_F{kz}-VL
  ASMJIT_INST_2x(vpexpandd, Vpexpandd, Ymm, Mem)                       //      AVX512_F{kz}-VL
  ASMJIT_INST_2x(vpexpandd, Vpexpandd, Zmm, Zmm)                       //      AVX512_F{kz}
  ASMJIT_INST_2x(vpexpandd, Vpexpandd, Zmm, Mem)                       //      AVX512_F{kz}
  ASMJIT_INST_2x(vpexpandq, Vpexpandq, Xmm, Xmm)                       //      AVX512_F{kz}-VL
  ASMJIT_INST_2x(vpexpandq, Vpexpandq, Xmm, Mem)                       //      AVX512_F{kz}-VL
  ASMJIT_INST_2x(vpexpandq, Vpexpandq, Ymm, Ymm)                       //      AVX512_F{kz}-VL
  ASMJIT_INST_2x(vpexpandq, Vpexpandq, Ymm, Mem)                       //      AVX512_F{kz}-VL
  ASMJIT_INST_2x(vpexpandq, Vpexpandq, Zmm, Zmm)                       //      AVX512_F{kz}
  ASMJIT_INST_2x(vpexpandq, Vpexpandq, Zmm, Mem)                       //      AVX512_F{kz}
  ASMJIT_INST_2x(vpexpandw, Vpexpandw, Xmm, Xmm)                       //      AVX512_VBMI2{kz}-VL
  ASMJIT_INST_2x(vpexpandw, Vpexpandw, Xmm, Mem)                       //      AVX512_VBMI2{kz}-VL
  ASMJIT_INST_2x(vpexpandw, Vpexpandw, Ymm, Ymm)                       //      AVX512_VBMI2{kz}-VL
  ASMJIT_INST_2x(vpexpandw, Vpexpandw, Ymm, Mem)                       //      AVX512_VBMI2{kz}-VL
  ASMJIT_INST_2x(vpexpandw, Vpexpandw, Zmm, Zmm)                       //      AVX512_VBMI2{kz}
  ASMJIT_INST_2x(vpexpandw, Vpexpandw, Zmm, Mem)                       //      AVX512_VBMI2{kz}
  ASMJIT_INST_3i(vpextrb, Vpextrb, Gp, Xmm, Imm)                       // AVX  AVX512_BW
  ASMJIT_INST_3i(vpextrb, Vpextrb, Mem, Xmm, Imm)                      // AVX  AVX512_BW
  ASMJIT_INST_3i(vpextrd, Vpextrd, Gp, Xmm, Imm)                       // AVX  AVX512_DQ
  ASMJIT_INST_3i(vpextrd, Vpextrd, Mem, Xmm, Imm)                      // AVX  AVX512_DQ
  ASMJIT_INST_3i(vpextrq, Vpextrq, Gp, Xmm, Imm)                       // AVX  AVX512_DQ
  ASMJIT_INST_3i(vpextrq, Vpextrq, Mem, Xmm, Imm)                      // AVX  AVX512_DQ
  ASMJIT_INST_3i(vpextrw, Vpextrw, Gp, Xmm, Imm)                       // AVX  AVX512_BW
  ASMJIT_INST_3i(vpextrw, Vpextrw, Mem, Xmm, Imm)                      // AVX  AVX512_BW
  ASMJIT_INST_3x(vpgatherdd, Vpgatherdd, Xmm, Mem, Xmm)                // AVX2
  ASMJIT_INST_3x(vpgatherdd, Vpgatherdd, Ymm, Mem, Ymm)                // AVX2
  ASMJIT_INST_2x(vpgatherdd, Vpgatherdd, Xmm, Mem)                     //      AVX512_F{k}-VL
  ASMJIT_INST_2x(vpgatherdd, Vpgatherdd, Ymm, Mem)                     //      AVX512_F{k}-VL
  ASMJIT_INST_2x(vpgatherdd, Vpgatherdd, Zmm, Mem)                     //      AVX512_F{k}
  ASMJIT_INST_3x(vpgatherdq, Vpgatherdq, Xmm, Mem, Xmm)                // AVX2
  ASMJIT_INST_3x(vpgatherdq, Vpgatherdq, Ymm, Mem, Ymm)                // AVX2
  ASMJIT_INST_2x(vpgatherdq, Vpgatherdq, Xmm, Mem)                     //      AVX512_F{k}-VL
  ASMJIT_INST_2x(vpgatherdq, Vpgatherdq, Ymm, Mem)                     //      AVX512_F{k}-VL
  ASMJIT_INST_2x(vpgatherdq, Vpgatherdq, Zmm, Mem)                     //      AVX512_F{k}
  ASMJIT_INST_3x(vpgatherqd, Vpgatherqd, Xmm, Mem, Xmm)                // AVX2
  ASMJIT_INST_2x(vpgatherqd, Vpgatherqd, Xmm, Mem)                     //      AVX512_F{k}-VL
  ASMJIT_INST_2x(vpgatherqd, Vpgatherqd, Ymm, Mem)                     //      AVX512_F{k}-VL
  ASMJIT_INST_2x(vpgatherqd, Vpgatherqd, Zmm, Mem)                     //      AVX512_F{k}
  ASMJIT_INST_3x(vpgatherqq, Vpgatherqq, Xmm, Mem, Xmm)                // AVX2
  ASMJIT_INST_3x(vpgatherqq, Vpgatherqq, Ymm, Mem, Ymm)                // AVX2
  ASMJIT_INST_2x(vpgatherqq, Vpgatherqq, Xmm, Mem)                     //      AVX512_F{k}-VL
  ASMJIT_INST_2x(vpgatherqq, Vpgatherqq, Ymm, Mem)                     //      AVX512_F{k}-VL
  ASMJIT_INST_2x(vpgatherqq, Vpgatherqq, Zmm, Mem)                     //      AVX512_F{k}
  ASMJIT_INST_3x(vphaddd, Vphaddd, Xmm, Xmm, Xmm)                      // AVX
  ASMJIT_INST_3x(vphaddd, Vphaddd, Xmm, Xmm, Mem)                      // AVX
  ASMJIT_INST_3x(vphaddd, Vphaddd, Ymm, Ymm, Ymm)                      // AVX2
  ASMJIT_INST_3x(vphaddd, Vphaddd, Ymm, Ymm, Mem)                      // AVX2
  ASMJIT_INST_3x(vphaddsw, Vphaddsw, Xmm, Xmm, Xmm)                    // AVX
  ASMJIT_INST_3x(vphaddsw, Vphaddsw, Xmm, Xmm, Mem)                    // AVX
  ASMJIT_INST_3x(vphaddsw, Vphaddsw, Ymm, Ymm, Ymm)                    // AVX2
  ASMJIT_INST_3x(vphaddsw, Vphaddsw, Ymm, Ymm, Mem)                    // AVX2
  ASMJIT_INST_3x(vphaddw, Vphaddw, Xmm, Xmm, Xmm)                      // AVX
  ASMJIT_INST_3x(vphaddw, Vphaddw, Xmm, Xmm, Mem)                      // AVX
  ASMJIT_INST_3x(vphaddw, Vphaddw, Ymm, Ymm, Ymm)                      // AVX2
  ASMJIT_INST_3x(vphaddw, Vphaddw, Ymm, Ymm, Mem)                      // AVX2
  ASMJIT_INST_2x(vphminposuw, Vphminposuw, Xmm, Xmm)                   // AVX
  ASMJIT_INST_2x(vphminposuw, Vphminposuw, Xmm, Mem)                   // AVX
  ASMJIT_INST_3x(vphsubd, Vphsubd, Xmm, Xmm, Xmm)                      // AVX
  ASMJIT_INST_3x(vphsubd, Vphsubd, Xmm, Xmm, Mem)                      // AVX
  ASMJIT_INST_3x(vphsubd, Vphsubd, Ymm, Ymm, Ymm)                      // AVX2
  ASMJIT_INST_3x(vphsubd, Vphsubd, Ymm, Ymm, Mem)                      // AVX2
  ASMJIT_INST_3x(vphsubsw, Vphsubsw, Xmm, Xmm, Xmm)                    // AVX
  ASMJIT_INST_3x(vphsubsw, Vphsubsw, Xmm, Xmm, Mem)                    // AVX
  ASMJIT_INST_3x(vphsubsw, Vphsubsw, Ymm, Ymm, Ymm)                    // AVX2
  ASMJIT_INST_3x(vphsubsw, Vphsubsw, Ymm, Ymm, Mem)                    // AVX2
  ASMJIT_INST_3x(vphsubw, Vphsubw, Xmm, Xmm, Xmm)                      // AVX
  ASMJIT_INST_3x(vphsubw, Vphsubw, Xmm, Xmm, Mem)                      // AVX
  ASMJIT_INST_3x(vphsubw, Vphsubw, Ymm, Ymm, Ymm)                      // AVX2
  ASMJIT_INST_3x(vphsubw, Vphsubw, Ymm, Ymm, Mem)                      // AVX2
  ASMJIT_INST_4i(vpinsrb, Vpinsrb, Xmm, Xmm, Gp, Imm)                  // AVX  AVX512_BW{kz}
  ASMJIT_INST_4i(vpinsrb, Vpinsrb, Xmm, Xmm, Mem, Imm)                 // AVX  AVX512_BW{kz}
  ASMJIT_INST_4i(vpinsrd, Vpinsrd, Xmm, Xmm, Gp, Imm)                  // AVX  AVX512_DQ{kz}
  ASMJIT_INST_4i(vpinsrd, Vpinsrd, Xmm, Xmm, Mem, Imm)                 // AVX  AVX512_DQ{kz}
  ASMJIT_INST_4i(vpinsrq, Vpinsrq, Xmm, Xmm, Gp, Imm)                  // AVX  AVX512_DQ{kz}
  ASMJIT_INST_4i(vpinsrq, Vpinsrq, Xmm, Xmm, Mem, Imm)                 // AVX  AVX512_DQ{kz}
  ASMJIT_INST_4i(vpinsrw, Vpinsrw, Xmm, Xmm, Gp, Imm)                  // AVX  AVX512_BW{kz}
  ASMJIT_INST_4i(vpinsrw, Vpinsrw, Xmm, Xmm, Mem, Imm)                 // AVX  AVX512_BW{kz}
  ASMJIT_INST_2x(vplzcntd, Vplzcntd, Xmm, Xmm)                         //      AVX512_CD{kz|b32}-VL
  ASMJIT_INST_2x(vplzcntd, Vplzcntd, Xmm, Mem)                         //      AVX512_CD{kz|b32}-VL
  ASMJIT_INST_2x(vplzcntd, Vplzcntd, Ymm, Ymm)                         //      AVX512_CD{kz|b32}-VL
  ASMJIT_INST_2x(vplzcntd, Vplzcntd, Ymm, Mem)                         //      AVX512_CD{kz|b32}-VL
  ASMJIT_INST_2x(vplzcntd, Vplzcntd, Zmm, Zmm)                         //      AVX512_CD{kz|b32}
  ASMJIT_INST_2x(vplzcntd, Vplzcntd, Zmm, Mem)                         //      AVX512_CD{kz|b32}
  ASMJIT_INST_2x(vplzcntq, Vplzcntq, Xmm, Xmm)                         //      AVX512_CD{kz|b64}-VL
  ASMJIT_INST_2x(vplzcntq, Vplzcntq, Xmm, Mem)                         //      AVX512_CD{kz|b64}-VL
  ASMJIT_INST_2x(vplzcntq, Vplzcntq, Ymm, Ymm)                         //      AVX512_CD{kz|b64}-VL
  ASMJIT_INST_2x(vplzcntq, Vplzcntq, Ymm, Mem)                         //      AVX512_CD{kz|b64}-VL
  ASMJIT_INST_2x(vplzcntq, Vplzcntq, Zmm, Zmm)                         //      AVX512_CD{kz|b64}
  ASMJIT_INST_2x(vplzcntq, Vplzcntq, Zmm, Mem)                         //      AVX512_CD{kz|b64}
  ASMJIT_INST_3x(vpmadd52huq, Vpmadd52huq, Xmm, Xmm, Xmm)              //      AVX512_IFMA{kz|b64}-VL
  ASMJIT_INST_3x(vpmadd52huq, Vpmadd52huq, Xmm, Xmm, Mem)              //      AVX512_IFMA{kz|b64}-VL
  ASMJIT_INST_3x(vpmadd52huq, Vpmadd52huq, Ymm, Ymm, Ymm)              //      AVX512_IFMA{kz|b64}-VL
  ASMJIT_INST_3x(vpmadd52huq, Vpmadd52huq, Ymm, Ymm, Mem)              //      AVX512_IFMA{kz|b64}-VL
  ASMJIT_INST_3x(vpmadd52huq, Vpmadd52huq, Zmm, Zmm, Zmm)              //      AVX512_IFMA{kz|b64}
  ASMJIT_INST_3x(vpmadd52huq, Vpmadd52huq, Zmm, Zmm, Mem)              //      AVX512_IFMA{kz|b64}
  ASMJIT_INST_3x(vpmadd52luq, Vpmadd52luq, Xmm, Xmm, Xmm)              //      AVX512_IFMA{kz|b64}-VL
  ASMJIT_INST_3x(vpmadd52luq, Vpmadd52luq, Xmm, Xmm, Mem)              //      AVX512_IFMA{kz|b64}-VL
  ASMJIT_INST_3x(vpmadd52luq, Vpmadd52luq, Ymm, Ymm, Ymm)              //      AVX512_IFMA{kz|b64}-VL
  ASMJIT_INST_3x(vpmadd52luq, Vpmadd52luq, Ymm, Ymm, Mem)              //      AVX512_IFMA{kz|b64}-VL
  ASMJIT_INST_3x(vpmadd52luq, Vpmadd52luq, Zmm, Zmm, Zmm)              //      AVX512_IFMA{kz|b64}
  ASMJIT_INST_3x(vpmadd52luq, Vpmadd52luq, Zmm, Zmm, Mem)              //      AVX512_IFMA{kz|b64}
  ASMJIT_INST_3x(vpmaddubsw, Vpmaddubsw, Xmm, Xmm, Xmm)                // AVX  AVX512_BW{kz}-VL
  ASMJIT_INST_3x(vpmaddubsw, Vpmaddubsw, Xmm, Xmm, Mem)                // AVX  AVX512_BW{kz}-VL
  ASMJIT_INST_3x(vpmaddubsw, Vpmaddubsw, Ymm, Ymm, Ymm)                // AVX2 AVX512_BW{kz}-VL
  ASMJIT_INST_3x(vpmaddubsw, Vpmaddubsw, Ymm, Ymm, Mem)                // AVX2 AVX512_BW{kz}-VL
  ASMJIT_INST_3x(vpmaddubsw, Vpmaddubsw, Zmm, Zmm, Zmm)                //      AVX512_BW{kz}
  ASMJIT_INST_3x(vpmaddubsw, Vpmaddubsw, Zmm, Zmm, Mem)                //      AVX512_BW{kz}
  ASMJIT_INST_3x(vpmaddwd, Vpmaddwd, Xmm, Xmm, Xmm)                    // AVX  AVX512_BW{kz}-VL
  ASMJIT_INST_3x(vpmaddwd, Vpmaddwd, Xmm, Xmm, Mem)                    // AVX  AVX512_BW{kz}-VL
  ASMJIT_INST_3x(vpmaddwd, Vpmaddwd, Ymm, Ymm, Ymm)                    // AVX2 AVX512_BW{kz}-VL
  ASMJIT_INST_3x(vpmaddwd, Vpmaddwd, Ymm, Ymm, Mem)                    // AVX2 AVX512_BW{kz}-VL
  ASMJIT_INST_3x(vpmaddwd, Vpmaddwd, Zmm, Zmm, Zmm)                    //      AVX512_BW{kz}
  ASMJIT_INST_3x(vpmaddwd, Vpmaddwd, Zmm, Zmm, Mem)                    //      AVX512_BW{kz}
  ASMJIT_INST_3x(vpmaskmovd, Vpmaskmovd, Mem, Xmm, Xmm)                // AVX2
  ASMJIT_INST_3x(vpmaskmovd, Vpmaskmovd, Mem, Ymm, Ymm)                // AVX2
  ASMJIT_INST_3x(vpmaskmovd, Vpmaskmovd, Xmm, Xmm, Mem)                // AVX2
  ASMJIT_INST_3x(vpmaskmovd, Vpmaskmovd, Ymm, Ymm, Mem)                // AVX2
  ASMJIT_INST_3x(vpmaskmovq, Vpmaskmovq, Mem, Xmm, Xmm)                // AVX2
  ASMJIT_INST_3x(vpmaskmovq, Vpmaskmovq, Mem, Ymm, Ymm)                // AVX2
  ASMJIT_INST_3x(vpmaskmovq, Vpmaskmovq, Xmm, Xmm, Mem)                // AVX2
  ASMJIT_INST_3x(vpmaskmovq, Vpmaskmovq, Ymm, Ymm, Mem)                // AVX2
  ASMJIT_INST_3x(vpmaxsb, Vpmaxsb, Xmm, Xmm, Xmm)                      // AVX  AVX512_BW{kz}-VL
  ASMJIT_INST_3x(vpmaxsb, Vpmaxsb, Xmm, Xmm, Mem)                      // AVX  AVX512_BW{kz}-VL
  ASMJIT_INST_3x(vpmaxsb, Vpmaxsb, Ymm, Ymm, Ymm)                      // AVX2 AVX512_BW{kz}-VL
  ASMJIT_INST_3x(vpmaxsb, Vpmaxsb, Ymm, Ymm, Mem)                      // AVX2 AVX512_BW{kz}-VL
  ASMJIT_INST_3x(vpmaxsb, Vpmaxsb, Zmm, Zmm, Zmm)                      //      AVX512_BW{kz}
  ASMJIT_INST_3x(vpmaxsb, Vpmaxsb, Zmm, Zmm, Mem)                      //      AVX512_BW{kz}
  ASMJIT_INST_3x(vpmaxsd, Vpmaxsd, Xmm, Xmm, Xmm)                      // AVX  AVX512_F{kz|b32}-VL
  ASMJIT_INST_3x(vpmaxsd, Vpmaxsd, Xmm, Xmm, Mem)                      // AVX  AVX512_F{kz|b32}-VL
  ASMJIT_INST_3x(vpmaxsd, Vpmaxsd, Ymm, Ymm, Ymm)                      // AVX2 AVX512_F{kz|b32}-VL
  ASMJIT_INST_3x(vpmaxsd, Vpmaxsd, Ymm, Ymm, Mem)                      // AVX2 AVX512_F{kz|b32}-VL
  ASMJIT_INST_3x(vpmaxsd, Vpmaxsd, Zmm, Zmm, Zmm)                      //      AVX512_F{kz|b32}
  ASMJIT_INST_3x(vpmaxsd, Vpmaxsd, Zmm, Zmm, Mem)                      //      AVX512_F{kz|b32}
  ASMJIT_INST_3x(vpmaxsq, Vpmaxsq, Xmm, Xmm, Xmm)                      //      AVX512_F{kz|b64}-VL
  ASMJIT_INST_3x(vpmaxsq, Vpmaxsq, Xmm, Xmm, Mem)                      //      AVX512_F{kz|b64}-VL
  ASMJIT_INST_3x(vpmaxsq, Vpmaxsq, Ymm, Ymm, Ymm)                      //      AVX512_F{kz|b64}-VL
  ASMJIT_INST_3x(vpmaxsq, Vpmaxsq, Ymm, Ymm, Mem)                      //      AVX512_F{kz|b64}-VL
  ASMJIT_INST_3x(vpmaxsq, Vpmaxsq, Zmm, Zmm, Zmm)                      //      AVX512_F{kz|b64}
  ASMJIT_INST_3x(vpmaxsq, Vpmaxsq, Zmm, Zmm, Mem)                      //      AVX512_F{kz|b64}
  ASMJIT_INST_3x(vpmaxsw, Vpmaxsw, Xmm, Xmm, Xmm)                      // AVX  AVX512_BW{kz}-VL
  ASMJIT_INST_3x(vpmaxsw, Vpmaxsw, Xmm, Xmm, Mem)                      // AVX  AVX512_BW{kz}-VL
  ASMJIT_INST_3x(vpmaxsw, Vpmaxsw, Ymm, Ymm, Ymm)                      // AVX2 AVX512_BW{kz}-VL
  ASMJIT_INST_3x(vpmaxsw, Vpmaxsw, Ymm, Ymm, Mem)                      // AVX2 AVX512_BW{kz}-VL
  ASMJIT_INST_3x(vpmaxsw, Vpmaxsw, Zmm, Zmm, Zmm)                      //      AVX512_BW{kz}
  ASMJIT_INST_3x(vpmaxsw, Vpmaxsw, Zmm, Zmm, Mem)                      //      AVX512_BW{kz}
  ASMJIT_INST_3x(vpmaxub, Vpmaxub, Xmm, Xmm, Xmm)                      // AVX  AVX512_BW{kz}-VL
  ASMJIT_INST_3x(vpmaxub, Vpmaxub, Xmm, Xmm, Mem)                      // AVX  AVX512_BW{kz}-VL
  ASMJIT_INST_3x(vpmaxub, Vpmaxub, Ymm, Ymm, Ymm)                      // AVX2 AVX512_BW{kz}-VL
  ASMJIT_INST_3x(vpmaxub, Vpmaxub, Ymm, Ymm, Mem)                      // AVX2 AVX512_BW{kz}-VL
  ASMJIT_INST_3x(vpmaxub, Vpmaxub, Zmm, Zmm, Zmm)                      //      AVX512_BW{kz}
  ASMJIT_INST_3x(vpmaxub, Vpmaxub, Zmm, Zmm, Mem)                      //      AVX512_BW{kz}
  ASMJIT_INST_3x(vpmaxud, Vpmaxud, Xmm, Xmm, Xmm)                      // AVX  AVX512_F{kz|b32}-VL
  ASMJIT_INST_3x(vpmaxud, Vpmaxud, Xmm, Xmm, Mem)                      // AVX  AVX512_F{kz|b32}-VL
  ASMJIT_INST_3x(vpmaxud, Vpmaxud, Ymm, Ymm, Ymm)                      // AVX2 AVX512_F{kz|b32}-VL
  ASMJIT_INST_3x(vpmaxud, Vpmaxud, Ymm, Ymm, Mem)                      // AVX2 AVX512_F{kz|b32}-VL
  ASMJIT_INST_3x(vpmaxud, Vpmaxud, Zmm, Zmm, Zmm)                      //      AVX512_F{kz|b32}
  ASMJIT_INST_3x(vpmaxud, Vpmaxud, Zmm, Zmm, Mem)                      //      AVX512_F{kz|b32}
  ASMJIT_INST_3x(vpmaxuq, Vpmaxuq, Xmm, Xmm, Xmm)                      //      AVX512_F{kz|b64}-VL
  ASMJIT_INST_3x(vpmaxuq, Vpmaxuq, Xmm, Xmm, Mem)                      //      AVX512_F{kz|b64}-VL
  ASMJIT_INST_3x(vpmaxuq, Vpmaxuq, Ymm, Ymm, Ymm)                      //      AVX512_F{kz|b64}-VL
  ASMJIT_INST_3x(vpmaxuq, Vpmaxuq, Ymm, Ymm, Mem)                      //      AVX512_F{kz|b64}-VL
  ASMJIT_INST_3x(vpmaxuq, Vpmaxuq, Zmm, Zmm, Zmm)                      //      AVX512_F{kz|b64}
  ASMJIT_INST_3x(vpmaxuq, Vpmaxuq, Zmm, Zmm, Mem)                      //      AVX512_F{kz|b64}
  ASMJIT_INST_3x(vpmaxuw, Vpmaxuw, Xmm, Xmm, Xmm)                      // AVX  AVX512_BW{kz}-VL
  ASMJIT_INST_3x(vpmaxuw, Vpmaxuw, Xmm, Xmm, Mem)                      // AVX  AVX512_BW{kz}-VL
  ASMJIT_INST_3x(vpmaxuw, Vpmaxuw, Ymm, Ymm, Ymm)                      // AVX2 AVX512_BW{kz}-VL
  ASMJIT_INST_3x(vpmaxuw, Vpmaxuw, Ymm, Ymm, Mem)                      // AVX2 AVX512_BW{kz}-VL
  ASMJIT_INST_3x(vpmaxuw, Vpmaxuw, Zmm, Zmm, Zmm)                      //      AVX512_BW{kz}
  ASMJIT_INST_3x(vpmaxuw, Vpmaxuw, Zmm, Zmm, Mem)                      //      AVX512_BW{kz}
  ASMJIT_INST_3x(vpminsb, Vpminsb, Xmm, Xmm, Xmm)                      // AVX  AVX512_BW{kz}-VL
  ASMJIT_INST_3x(vpminsb, Vpminsb, Xmm, Xmm, Mem)                      // AVX  AVX512_BW{kz}-VL
  ASMJIT_INST_3x(vpminsb, Vpminsb, Ymm, Ymm, Ymm)                      // AVX2 AVX512_BW{kz}-VL
  ASMJIT_INST_3x(vpminsb, Vpminsb, Ymm, Ymm, Mem)                      // AVX2 AVX512_BW{kz}-VL
  ASMJIT_INST_3x(vpminsb, Vpminsb, Zmm, Zmm, Zmm)                      //      AVX512_BW{kz}
  ASMJIT_INST_3x(vpminsb, Vpminsb, Zmm, Zmm, Mem)                      //      AVX512_BW{kz}
  ASMJIT_INST_3x(vpminsd, Vpminsd, Xmm, Xmm, Xmm)                      // AVX  AVX512_F{kz|b32}-VL
  ASMJIT_INST_3x(vpminsd, Vpminsd, Xmm, Xmm, Mem)                      // AVX  AVX512_F{kz|b32}-VL
  ASMJIT_INST_3x(vpminsd, Vpminsd, Ymm, Ymm, Ymm)                      // AVX2 AVX512_F{kz|b32}-VL
  ASMJIT_INST_3x(vpminsd, Vpminsd, Ymm, Ymm, Mem)                      // AVX2 AVX512_F{kz|b32}-VL
  ASMJIT_INST_3x(vpminsd, Vpminsd, Zmm, Zmm, Zmm)                      //      AVX512_F{kz|b32}
  ASMJIT_INST_3x(vpminsd, Vpminsd, Zmm, Zmm, Mem)                      //      AVX512_F{kz|b32}
  ASMJIT_INST_3x(vpminsq, Vpminsq, Xmm, Xmm, Xmm)                      //      AVX512_F{kz|b64}-VL
  ASMJIT_INST_3x(vpminsq, Vpminsq, Xmm, Xmm, Mem)                      //      AVX512_F{kz|b64}-VL
  ASMJIT_INST_3x(vpminsq, Vpminsq, Ymm, Ymm, Ymm)                      //      AVX512_F{kz|b64}-VL
  ASMJIT_INST_3x(vpminsq, Vpminsq, Ymm, Ymm, Mem)                      //      AVX512_F{kz|b64}-VL
  ASMJIT_INST_3x(vpminsq, Vpminsq, Zmm, Zmm, Zmm)                      //      AVX512_F{kz|b64}
  ASMJIT_INST_3x(vpminsq, Vpminsq, Zmm, Zmm, Mem)                      //      AVX512_F{kz|b64}
  ASMJIT_INST_3x(vpminsw, Vpminsw, Xmm, Xmm, Xmm)                      // AVX  AVX512_BW{kz}-VL
  ASMJIT_INST_3x(vpminsw, Vpminsw, Xmm, Xmm, Mem)                      // AVX  AVX512_BW{kz}-VL
  ASMJIT_INST_3x(vpminsw, Vpminsw, Ymm, Ymm, Ymm)                      // AVX2 AVX512_BW{kz}-VL
  ASMJIT_INST_3x(vpminsw, Vpminsw, Ymm, Ymm, Mem)                      // AVX2 AVX512_BW{kz}-VL
  ASMJIT_INST_3x(vpminsw, Vpminsw, Zmm, Zmm, Zmm)                      //      AVX512_BW{kz}
  ASMJIT_INST_3x(vpminsw, Vpminsw, Zmm, Zmm, Mem)                      //      AVX512_BW{kz}
  ASMJIT_INST_3x(vpminub, Vpminub, Xmm, Xmm, Xmm)                      // AVX  AVX512_BW{kz}-VL
  ASMJIT_INST_3x(vpminub, Vpminub, Xmm, Xmm, Mem)                      // AVX  AVX512_BW{kz}-VL
  ASMJIT_INST_3x(vpminub, Vpminub, Ymm, Ymm, Ymm)                      // AVX2 AVX512_BW{kz}-VL
  ASMJIT_INST_3x(vpminub, Vpminub, Ymm, Ymm, Mem)                      // AVX2 AVX512_BW{kz}-VL
  ASMJIT_INST_3x(vpminub, Vpminub, Zmm, Zmm, Zmm)                      //      AVX512_BW{kz}
  ASMJIT_INST_3x(vpminub, Vpminub, Zmm, Zmm, Mem)                      //      AVX512_BW{kz}
  ASMJIT_INST_3x(vpminud, Vpminud, Xmm, Xmm, Xmm)                      // AVX  AVX512_F{kz|b32}-VL
  ASMJIT_INST_3x(vpminud, Vpminud, Xmm, Xmm, Mem)                      // AVX  AVX512_F{kz|b32}-VL
  ASMJIT_INST_3x(vpminud, Vpminud, Ymm, Ymm, Ymm)                      // AVX2 AVX512_F{kz|b32}-VL
  ASMJIT_INST_3x(vpminud, Vpminud, Ymm, Ymm, Mem)                      // AVX2 AVX512_F{kz|b32}-VL
  ASMJIT_INST_3x(vpminud, Vpminud, Zmm, Zmm, Zmm)                      //      AVX512_F{kz|b32}
  ASMJIT_INST_3x(vpminud, Vpminud, Zmm, Zmm, Mem)                      //      AVX512_F{kz|b32}
  ASMJIT_INST_3x(vpminuq, Vpminuq, Xmm, Xmm, Xmm)                      //      AVX512_F{kz|b64}-VL
  ASMJIT_INST_3x(vpminuq, Vpminuq, Xmm, Xmm, Mem)                      //      AVX512_F{kz|b64}-VL
  ASMJIT_INST_3x(vpminuq, Vpminuq, Ymm, Ymm, Ymm)                      //      AVX512_F{kz|b64}-VL
  ASMJIT_INST_3x(vpminuq, Vpminuq, Ymm, Ymm, Mem)                      //      AVX512_F{kz|b64}-VL
  ASMJIT_INST_3x(vpminuq, Vpminuq, Zmm, Zmm, Zmm)                      //      AVX512_F{kz|b64}
  ASMJIT_INST_3x(vpminuq, Vpminuq, Zmm, Zmm, Mem)                      //      AVX512_F{kz|b64}
  ASMJIT_INST_3x(vpminuw, Vpminuw, Xmm, Xmm, Xmm)                      // AVX  AVX512_BW{kz}-VL
  ASMJIT_INST_3x(vpminuw, Vpminuw, Xmm, Xmm, Mem)                      // AVX  AVX512_BW{kz}-VL
  ASMJIT_INST_3x(vpminuw, Vpminuw, Ymm, Ymm, Ymm)                      // AVX2 AVX512_BW{kz}-VL
  ASMJIT_INST_3x(vpminuw, Vpminuw, Ymm, Ymm, Mem)                      // AVX2 AVX512_BW{kz}-VL
  ASMJIT_INST_3x(vpminuw, Vpminuw, Zmm, Zmm, Zmm)                      //      AVX512_BW{kz}
  ASMJIT_INST_3x(vpminuw, Vpminuw, Zmm, Zmm, Mem)                      //      AVX512_BW{kz}
  ASMJIT_INST_2x(vpmovb2m, Vpmovb2m, KReg, Xmm)                        //      AVX512_BW-VL
  ASMJIT_INST_2x(vpmovb2m, Vpmovb2m, KReg, Ymm)                        //      AVX512_BW-VL
  ASMJIT_INST_2x(vpmovb2m, Vpmovb2m, KReg, Zmm)                        //      AVX512_BW
  ASMJIT_INST_2x(vpmovd2m, Vpmovd2m, KReg, Xmm)                        //      AVX512_DQ-VL
  ASMJIT_INST_2x(vpmovd2m, Vpmovd2m, KReg, Ymm)                        //      AVX512_DQ-VL
  ASMJIT_INST_2x(vpmovd2m, Vpmovd2m, KReg, Zmm)                        //      AVX512_DQ
  ASMJIT_INST_2x(vpmovdb, Vpmovdb, Xmm, Xmm)                           //      AVX512_F{kz}-VL
  ASMJIT_INST_2x(vpmovdb, Vpmovdb, Mem, Xmm)                           //      AVX512_F{kz}-VL
  ASMJIT_INST_2x(vpmovdb, Vpmovdb, Xmm, Ymm)                           //      AVX512_F{kz}-VL
  ASMJIT_INST_2x(vpmovdb, Vpmovdb, Mem, Ymm)                           //      AVX512_F{kz}-VL
  ASMJIT_INST_2x(vpmovdb, Vpmovdb, Xmm, Zmm)                           //      AVX512_F{kz}
  ASMJIT_INST_2x(vpmovdb, Vpmovdb, Mem, Zmm)                           //      AVX512_F{kz}
  ASMJIT_INST_2x(vpmovdw, Vpmovdw, Xmm, Xmm)                           //      AVX512_F{kz}-VL
  ASMJIT_INST_2x(vpmovdw, Vpmovdw, Mem, Xmm)                           //      AVX512_F{kz}-VL
  ASMJIT_INST_2x(vpmovdw, Vpmovdw, Xmm, Ymm)                           //      AVX512_F{kz}-VL
  ASMJIT_INST_2x(vpmovdw, Vpmovdw, Mem, Ymm)                           //      AVX512_F{kz}-VL
  ASMJIT_INST_2x(vpmovdw, Vpmovdw, Ymm, Zmm)                           //      AVX512_F{kz}
  ASMJIT_INST_2x(vpmovdw, Vpmovdw, Mem, Zmm)                           //      AVX512_F{kz}
  ASMJIT_INST_2x(vpmovm2b, Vpmovm2b, Xmm, KReg)                        //      AVX512_BW-VL
  ASMJIT_INST_2x(vpmovm2b, Vpmovm2b, Ymm, KReg)                        //      AVX512_BW-VL
  ASMJIT_INST_2x(vpmovm2b, Vpmovm2b, Zmm, KReg)                        //      AVX512_BW
  ASMJIT_INST_2x(vpmovm2d, Vpmovm2d, Xmm, KReg)                        //      AVX512_DQ-VL
  ASMJIT_INST_2x(vpmovm2d, Vpmovm2d, Ymm, KReg)                        //      AVX512_DQ-VL
  ASMJIT_INST_2x(vpmovm2d, Vpmovm2d, Zmm, KReg)                        //      AVX512_DQ
  ASMJIT_INST_2x(vpmovm2q, Vpmovm2q, Xmm, KReg)                        //      AVX512_DQ-VL
  ASMJIT_INST_2x(vpmovm2q, Vpmovm2q, Ymm, KReg)                        //      AVX512_DQ-VL
  ASMJIT_INST_2x(vpmovm2q, Vpmovm2q, Zmm, KReg)                        //      AVX512_DQ
  ASMJIT_INST_2x(vpmovm2w, Vpmovm2w, Xmm, KReg)                        //      AVX512_BW-VL
  ASMJIT_INST_2x(vpmovm2w, Vpmovm2w, Ymm, KReg)                        //      AVX512_BW-VL
  ASMJIT_INST_2x(vpmovm2w, Vpmovm2w, Zmm, KReg)                        //      AVX512_BW
  ASMJIT_INST_2x(vpmovmskb, Vpmovmskb, Gp, Xmm)                        // AVX
  ASMJIT_INST_2x(vpmovmskb, Vpmovmskb, Gp, Ymm)                        // AVX2
  ASMJIT_INST_2x(vpmovq2m, Vpmovq2m, KReg, Xmm)                        //      AVX512_DQ-VL
  ASMJIT_INST_2x(vpmovq2m, Vpmovq2m, KReg, Ymm)                        //      AVX512_DQ-VL
  ASMJIT_INST_2x(vpmovq2m, Vpmovq2m, KReg, Zmm)                        //      AVX512_DQ
  ASMJIT_INST_2x(vpmovqb, Vpmovqb, Xmm, Xmm)                           //      AVX512_F{kz}-VL
  ASMJIT_INST_2x(vpmovqb, Vpmovqb, Mem, Xmm)                           //      AVX512_F{kz}-VL
  ASMJIT_INST_2x(vpmovqb, Vpmovqb, Xmm, Ymm)                           //      AVX512_F{kz}-VL
  ASMJIT_INST_2x(vpmovqb, Vpmovqb, Mem, Ymm)                           //      AVX512_F{kz}-VL
  ASMJIT_INST_2x(vpmovqb, Vpmovqb, Xmm, Zmm)                           //      AVX512_F{kz}
  ASMJIT_INST_2x(vpmovqb, Vpmovqb, Mem, Zmm)                           //      AVX512_F{kz}
  ASMJIT_INST_2x(vpmovqd, Vpmovqd, Xmm, Xmm)                           //      AVX512_F{kz}-VL
  ASMJIT_INST_2x(vpmovqd, Vpmovqd, Mem, Xmm)                           //      AVX512_F{kz}-VL
  ASMJIT_INST_2x(vpmovqd, Vpmovqd, Xmm, Ymm)                           //      AVX512_F{kz}-VL
  ASMJIT_INST_2x(vpmovqd, Vpmovqd, Mem, Ymm)                           //      AVX512_F{kz}-VL
  ASMJIT_INST_2x(vpmovqd, Vpmovqd, Ymm, Zmm)                           //      AVX512_F{kz}
  ASMJIT_INST_2x(vpmovqd, Vpmovqd, Mem, Zmm)                           //      AVX512_F{kz}
  ASMJIT_INST_2x(vpmovqw, Vpmovqw, Xmm, Xmm)                           //      AVX512_F{kz}-VL
  ASMJIT_INST_2x(vpmovqw, Vpmovqw, Mem, Xmm)                           //      AVX512_F{kz}-VL
  ASMJIT_INST_2x(vpmovqw, Vpmovqw, Xmm, Ymm)                           //      AVX512_F{kz}-VL
  ASMJIT_INST_2x(vpmovqw, Vpmovqw, Mem, Ymm)                           //      AVX512_F{kz}-VL
  ASMJIT_INST_2x(vpmovqw, Vpmovqw, Xmm, Zmm)                           //      AVX512_F{kz}
  ASMJIT_INST_2x(vpmovqw, Vpmovqw, Mem, Zmm)                           //      AVX512_F{kz}
  ASMJIT_INST_2x(vpmovsdb, Vpmovsdb, Xmm, Xmm)                         //      AVX512_F{kz}-VL
  ASMJIT_INST_2x(vpmovsdb, Vpmovsdb, Mem, Xmm)                         //      AVX512_F{kz}-VL
  ASMJIT_INST_2x(vpmovsdb, Vpmovsdb, Xmm, Ymm)                         //      AVX512_F{kz}-VL
  ASMJIT_INST_2x(vpmovsdb, Vpmovsdb, Mem, Ymm)                         //      AVX512_F{kz}-VL
  ASMJIT_INST_2x(vpmovsdb, Vpmovsdb, Xmm, Zmm)                         //      AVX512_F{kz}
  ASMJIT_INST_2x(vpmovsdb, Vpmovsdb, Mem, Zmm)                         //      AVX512_F{kz}
  ASMJIT_INST_2x(vpmovsdw, Vpmovsdw, Xmm, Xmm)                         //      AVX512_F{kz}-VL
  ASMJIT_INST_2x(vpmovsdw, Vpmovsdw, Mem, Xmm)                         //      AVX512_F{kz}-VL
  ASMJIT_INST_2x(vpmovsdw, Vpmovsdw, Xmm, Ymm)                         //      AVX512_F{kz}-VL
  ASMJIT_INST_2x(vpmovsdw, Vpmovsdw, Mem, Ymm)                         //      AVX512_F{kz}-VL
  ASMJIT_INST_2x(vpmovsdw, Vpmovsdw, Ymm, Zmm)                         //      AVX512_F{kz}
  ASMJIT_INST_2x(vpmovsdw, Vpmovsdw, Mem, Zmm)                         //      AVX512_F{kz}
  ASMJIT_INST_2x(vpmovsqb, Vpmovsqb, Xmm, Xmm)                         //      AVX512_F{kz}-VL
  ASMJIT_INST_2x(vpmovsqb, Vpmovsqb, Mem, Xmm)                         //      AVX512_F{kz}-VL
  ASMJIT_INST_2x(vpmovsqb, Vpmovsqb, Xmm, Ymm)                         //      AVX512_F{kz}-VL
  ASMJIT_INST_2x(vpmovsqb, Vpmovsqb, Mem, Ymm)                         //      AVX512_F{kz}-VL
  ASMJIT_INST_2x(vpmovsqb, Vpmovsqb, Xmm, Zmm)                         //      AVX512_F{kz}
  ASMJIT_INST_2x(vpmovsqb, Vpmovsqb, Mem, Zmm)                         //      AVX512_F{kz}
  ASMJIT_INST_2x(vpmovsqd, Vpmovsqd, Xmm, Xmm)                         //      AVX512_F{kz}-VL
  ASMJIT_INST_2x(vpmovsqd, Vpmovsqd, Mem, Xmm)                         //      AVX512_F{kz}-VL
  ASMJIT_INST_2x(vpmovsqd, Vpmovsqd, Xmm, Ymm)                         //      AVX512_F{kz}-VL
  ASMJIT_INST_2x(vpmovsqd, Vpmovsqd, Mem, Ymm)                         //      AVX512_F{kz}-VL
  ASMJIT_INST_2x(vpmovsqd, Vpmovsqd, Ymm, Zmm)                         //      AVX512_F{kz}
  ASMJIT_INST_2x(vpmovsqd, Vpmovsqd, Mem, Zmm)                         //      AVX512_F{kz}
  ASMJIT_INST_2x(vpmovsqw, Vpmovsqw, Xmm, Xmm)                         //      AVX512_F{kz}-VL
  ASMJIT_INST_2x(vpmovsqw, Vpmovsqw, Mem, Xmm)                         //      AVX512_F{kz}-VL
  ASMJIT_INST_2x(vpmovsqw, Vpmovsqw, Xmm, Ymm)                         //      AVX512_F{kz}-VL
  ASMJIT_INST_2x(vpmovsqw, Vpmovsqw, Mem, Ymm)                         //      AVX512_F{kz}-VL
  ASMJIT_INST_2x(vpmovsqw, Vpmovsqw, Xmm, Zmm)                         //      AVX512_F{kz}
  ASMJIT_INST_2x(vpmovsqw, Vpmovsqw, Mem, Zmm)                         //      AVX512_F{kz}
  ASMJIT_INST_2x(vpmovswb, Vpmovswb, Xmm, Xmm)                         //      AVX512_BW{kz}-VL
  ASMJIT_INST_2x(vpmovswb, Vpmovswb, Mem, Xmm)                         //      AVX512_BW{kz}-VL
  ASMJIT_INST_2x(vpmovswb, Vpmovswb, Xmm, Ymm)                         //      AVX512_BW{kz}-VL
  ASMJIT_INST_2x(vpmovswb, Vpmovswb, Mem, Ymm)                         //      AVX512_BW{kz}-VL
  ASMJIT_INST_2x(vpmovswb, Vpmovswb, Ymm, Zmm)                         //      AVX512_BW{kz}
  ASMJIT_INST_2x(vpmovswb, Vpmovswb, Mem, Zmm)                         //      AVX512_BW{kz}
  ASMJIT_INST_2x(vpmovsxbd, Vpmovsxbd, Xmm, Xmm)                       // AVX  AVX512_F{kz}-VL
  ASMJIT_INST_2x(vpmovsxbd, Vpmovsxbd, Xmm, Mem)                       // AVX  AVX512_F{kz}-VL
  ASMJIT_INST_2x(vpmovsxbd, Vpmovsxbd, Ymm, Xmm)                       // AVX2 AVX512_F{kz}-VL
  ASMJIT_INST_2x(vpmovsxbd, Vpmovsxbd, Ymm, Mem)                       // AVX2 AVX512_F{kz}-VL
  ASMJIT_INST_2x(vpmovsxbd, Vpmovsxbd, Zmm, Xmm)                       //      AVX512_F{kz}
  ASMJIT_INST_2x(vpmovsxbd, Vpmovsxbd, Zmm, Mem)                       //      AVX512_F{kz}
  ASMJIT_INST_2x(vpmovsxbq, Vpmovsxbq, Xmm, Xmm)                       // AVX  AVX512_F{kz}-VL
  ASMJIT_INST_2x(vpmovsxbq, Vpmovsxbq, Xmm, Mem)                       // AVX  AVX512_F{kz}-VL
  ASMJIT_INST_2x(vpmovsxbq, Vpmovsxbq, Ymm, Xmm)                       // AVX2 AVX512_F{kz}-VL
  ASMJIT_INST_2x(vpmovsxbq, Vpmovsxbq, Ymm, Mem)                       // AVX2 AVX512_F{kz}-VL
  ASMJIT_INST_2x(vpmovsxbq, Vpmovsxbq, Zmm, Xmm)                       //      AVX512_F{kz}
  ASMJIT_INST_2x(vpmovsxbq, Vpmovsxbq, Zmm, Mem)                       //      AVX512_F{kz}
  ASMJIT_INST_2x(vpmovsxbw, Vpmovsxbw, Xmm, Xmm)                       // AVX  AVX512_BW{kz}-VL
  ASMJIT_INST_2x(vpmovsxbw, Vpmovsxbw, Xmm, Mem)                       // AVX  AVX512_BW{kz}-VL
  ASMJIT_INST_2x(vpmovsxbw, Vpmovsxbw, Ymm, Xmm)                       // AVX2 AVX512_BW{kz}-VL
  ASMJIT_INST_2x(vpmovsxbw, Vpmovsxbw, Ymm, Mem)                       // AVX2 AVX512_BW{kz}-VL
  ASMJIT_INST_2x(vpmovsxbw, Vpmovsxbw, Zmm, Ymm)                       //      AVX512_BW{kz}
  ASMJIT_INST_2x(vpmovsxbw, Vpmovsxbw, Zmm, Mem)                       //      AVX512_BW{kz}
  ASMJIT_INST_2x(vpmovsxdq, Vpmovsxdq, Xmm, Xmm)                       // AVX  AVX512_F{kz}-VL
  ASMJIT_INST_2x(vpmovsxdq, Vpmovsxdq, Xmm, Mem)                       // AVX  AVX512_F{kz}-VL
  ASMJIT_INST_2x(vpmovsxdq, Vpmovsxdq, Ymm, Xmm)                       // AVX2 AVX512_F{kz}-VL
  ASMJIT_INST_2x(vpmovsxdq, Vpmovsxdq, Ymm, Mem)                       // AVX2 AVX512_F{kz}-VL
  ASMJIT_INST_2x(vpmovsxdq, Vpmovsxdq, Zmm, Ymm)                       //      AVX512_F{kz}
  ASMJIT_INST_2x(vpmovsxdq, Vpmovsxdq, Zmm, Mem)                       //      AVX512_F{kz}
  ASMJIT_INST_2x(vpmovsxwd, Vpmovsxwd, Xmm, Xmm)                       // AVX  AVX512_F{kz}-VL
  ASMJIT_INST_2x(vpmovsxwd, Vpmovsxwd, Xmm, Mem)                       // AVX  AVX512_F{kz}-VL
  ASMJIT_INST_2x(vpmovsxwd, Vpmovsxwd, Ymm, Xmm)                       // AVX2 AVX512_F{kz}-VL
  ASMJIT_INST_2x(vpmovsxwd, Vpmovsxwd, Ymm, Mem)                       // AVX2 AVX512_F{kz}-VL
  ASMJIT_INST_2x(vpmovsxwd, Vpmovsxwd, Zmm, Ymm)                       //      AVX512_F{kz}
  ASMJIT_INST_2x(vpmovsxwd, Vpmovsxwd, Zmm, Mem)                       //      AVX512_F{kz}
  ASMJIT_INST_2x(vpmovsxwq, Vpmovsxwq, Xmm, Xmm)                       // AVX  AVX512_F{kz}-VL
  ASMJIT_INST_2x(vpmovsxwq, Vpmovsxwq, Xmm, Mem)                       // AVX  AVX512_F{kz}-VL
  ASMJIT_INST_2x(vpmovsxwq, Vpmovsxwq, Ymm, Xmm)                       // AVX2 AVX512_F{kz}-VL
  ASMJIT_INST_2x(vpmovsxwq, Vpmovsxwq, Ymm, Mem)                       // AVX2 AVX512_F{kz}-VL
  ASMJIT_INST_2x(vpmovsxwq, Vpmovsxwq, Zmm, Xmm)                       //      AVX512_F{kz}
  ASMJIT_INST_2x(vpmovsxwq, Vpmovsxwq, Zmm, Mem)                       //      AVX512_F{kz}
  ASMJIT_INST_2x(vpmovusdb, Vpmovusdb, Xmm, Xmm)                       //      AVX512_F{kz}-VL
  ASMJIT_INST_2x(vpmovusdb, Vpmovusdb, Mem, Xmm)                       //      AVX512_F{kz}-VL
  ASMJIT_INST_2x(vpmovusdb, Vpmovusdb, Xmm, Ymm)                       //      AVX512_F{kz}-VL
  ASMJIT_INST_2x(vpmovusdb, Vpmovusdb, Mem, Ymm)                       //      AVX512_F{kz}-VL
  ASMJIT_INST_2x(vpmovusdb, Vpmovusdb, Xmm, Zmm)                       //      AVX512_F{kz}
  ASMJIT_INST_2x(vpmovusdb, Vpmovusdb, Mem, Zmm)                       //      AVX512_F{kz}
  ASMJIT_INST_2x(vpmovusdw, Vpmovusdw, Xmm, Xmm)                       //      AVX512_F{kz}-VL
  ASMJIT_INST_2x(vpmovusdw, Vpmovusdw, Mem, Xmm)                       //      AVX512_F{kz}-VL
  ASMJIT_INST_2x(vpmovusdw, Vpmovusdw, Xmm, Ymm)                       //      AVX512_F{kz}-VL
  ASMJIT_INST_2x(vpmovusdw, Vpmovusdw, Mem, Ymm)                       //      AVX512_F{kz}-VL
  ASMJIT_INST_2x(vpmovusdw, Vpmovusdw, Ymm, Zmm)                       //      AVX512_F{kz}
  ASMJIT_INST_2x(vpmovusdw, Vpmovusdw, Mem, Zmm)                       //      AVX512_F{kz}
  ASMJIT_INST_2x(vpmovusqb, Vpmovusqb, Xmm, Xmm)                       //      AVX512_F{kz}-VL
  ASMJIT_INST_2x(vpmovusqb, Vpmovusqb, Mem, Xmm)                       //      AVX512_F{kz}-VL
  ASMJIT_INST_2x(vpmovusqb, Vpmovusqb, Xmm, Ymm)                       //      AVX512_F{kz}-VL
  ASMJIT_INST_2x(vpmovusqb, Vpmovusqb, Mem, Ymm)                       //      AVX512_F{kz}-VL
  ASMJIT_INST_2x(vpmovusqb, Vpmovusqb, Xmm, Zmm)                       //      AVX512_F{kz}
  ASMJIT_INST_2x(vpmovusqb, Vpmovusqb, Mem, Zmm)                       //      AVX512_F{kz}
  ASMJIT_INST_2x(vpmovusqd, Vpmovusqd, Xmm, Xmm)                       //      AVX512_F{kz}-VL
  ASMJIT_INST_2x(vpmovusqd, Vpmovusqd, Mem, Xmm)                       //      AVX512_F{kz}-VL
  ASMJIT_INST_2x(vpmovusqd, Vpmovusqd, Xmm, Ymm)                       //      AVX512_F{kz}-VL
  ASMJIT_INST_2x(vpmovusqd, Vpmovusqd, Mem, Ymm)                       //      AVX512_F{kz}-VL
  ASMJIT_INST_2x(vpmovusqd, Vpmovusqd, Ymm, Zmm)                       //      AVX512_F{kz}
  ASMJIT_INST_2x(vpmovusqd, Vpmovusqd, Mem, Zmm)                       //      AVX512_F{kz}
  ASMJIT_INST_2x(vpmovusqw, Vpmovusqw, Xmm, Xmm)                       //      AVX512_F{kz}-VL
  ASMJIT_INST_2x(vpmovusqw, Vpmovusqw, Mem, Xmm)                       //      AVX512_F{kz}-VL
  ASMJIT_INST_2x(vpmovusqw, Vpmovusqw, Xmm, Ymm)                       //      AVX512_F{kz}-VL
  ASMJIT_INST_2x(vpmovusqw, Vpmovusqw, Mem, Ymm)                       //      AVX512_F{kz}-VL
  ASMJIT_INST_2x(vpmovusqw, Vpmovusqw, Xmm, Zmm)                       //      AVX512_F{kz}
  ASMJIT_INST_2x(vpmovusqw, Vpmovusqw, Mem, Zmm)                       //      AVX512_F{kz}
  ASMJIT_INST_2x(vpmovuswb, Vpmovuswb, Xmm, Xmm)                       //      AVX512_BW{kz}-VL
  ASMJIT_INST_2x(vpmovuswb, Vpmovuswb, Mem, Xmm)                       //      AVX512_BW{kz}-VL
  ASMJIT_INST_2x(vpmovuswb, Vpmovuswb, Xmm, Ymm)                       //      AVX512_BW{kz}-VL
  ASMJIT_INST_2x(vpmovuswb, Vpmovuswb, Mem, Ymm)                       //      AVX512_BW{kz}-VL
  ASMJIT_INST_2x(vpmovuswb, Vpmovuswb, Ymm, Zmm)                       //      AVX512_BW{kz}
  ASMJIT_INST_2x(vpmovuswb, Vpmovuswb, Mem, Zmm)                       //      AVX512_BW{kz}
  ASMJIT_INST_2x(vpmovw2m, Vpmovw2m, KReg, Xmm)                        //      AVX512_BW-VL
  ASMJIT_INST_2x(vpmovw2m, Vpmovw2m, KReg, Ymm)                        //      AVX512_BW-VL
  ASMJIT_INST_2x(vpmovw2m, Vpmovw2m, KReg, Zmm)                        //      AVX512_BW
  ASMJIT_INST_2x(vpmovwb, Vpmovwb, Xmm, Xmm)                           //      AVX512_BW{kz}-VL
  ASMJIT_INST_2x(vpmovwb, Vpmovwb, Mem, Xmm)                           //      AVX512_BW{kz}-VL
  ASMJIT_INST_2x(vpmovwb, Vpmovwb, Xmm, Ymm)                           //      AVX512_BW{kz}-VL
  ASMJIT_INST_2x(vpmovwb, Vpmovwb, Mem, Ymm)                           //      AVX512_BW{kz}-VL
  ASMJIT_INST_2x(vpmovwb, Vpmovwb, Ymm, Zmm)                           //      AVX512_BW{kz}
  ASMJIT_INST_2x(vpmovwb, Vpmovwb, Mem, Zmm)                           //      AVX512_BW{kz}
  ASMJIT_INST_2x(vpmovzxbd, Vpmovzxbd, Xmm, Xmm)                       // AVX  AVX512_F{kz}-VL
  ASMJIT_INST_2x(vpmovzxbd, Vpmovzxbd, Xmm, Mem)                       // AVX  AVX512_F{kz}-VL
  ASMJIT_INST_2x(vpmovzxbd, Vpmovzxbd, Ymm, Xmm)                       // AVX2 AVX512_F{kz}-VL
  ASMJIT_INST_2x(vpmovzxbd, Vpmovzxbd, Ymm, Mem)                       // AVX2 AVX512_F{kz}-VL
  ASMJIT_INST_2x(vpmovzxbd, Vpmovzxbd, Zmm, Xmm)                       //      AVX512_F{kz}
  ASMJIT_INST_2x(vpmovzxbd, Vpmovzxbd, Zmm, Mem)                       //      AVX512_F{kz}
  ASMJIT_INST_2x(vpmovzxbq, Vpmovzxbq, Xmm, Xmm)                       // AVX  AVX512_F{kz}-VL
  ASMJIT_INST_2x(vpmovzxbq, Vpmovzxbq, Xmm, Mem)                       // AVX  AVX512_F{kz}-VL
  ASMJIT_INST_2x(vpmovzxbq, Vpmovzxbq, Ymm, Xmm)                       // AVX2 AVX512_F{kz}-VL
  ASMJIT_INST_2x(vpmovzxbq, Vpmovzxbq, Ymm, Mem)                       // AVX2 AVX512_F{kz}-VL
  ASMJIT_INST_2x(vpmovzxbq, Vpmovzxbq, Zmm, Xmm)                       //      AVX512_F{kz}
  ASMJIT_INST_2x(vpmovzxbq, Vpmovzxbq, Zmm, Mem)                       //      AVX512_F{kz}
  ASMJIT_INST_2x(vpmovzxbw, Vpmovzxbw, Xmm, Xmm)                       // AVX  AVX512_BW{kz}-VL
  ASMJIT_INST_2x(vpmovzxbw, Vpmovzxbw, Xmm, Mem)                       // AVX  AVX512_BW{kz}-VL
  ASMJIT_INST_2x(vpmovzxbw, Vpmovzxbw, Ymm, Xmm)                       // AVX2 AVX512_BW{kz}-VL
  ASMJIT_INST_2x(vpmovzxbw, Vpmovzxbw, Ymm, Mem)                       // AVX2 AVX512_BW{kz}-VL
  ASMJIT_INST_2x(vpmovzxbw, Vpmovzxbw, Zmm, Ymm)                       //      AVX512_BW{kz}
  ASMJIT_INST_2x(vpmovzxbw, Vpmovzxbw, Zmm, Mem)                       //      AVX512_BW{kz}
  ASMJIT_INST_2x(vpmovzxdq, Vpmovzxdq, Xmm, Xmm)                       // AVX  AVX512_F{kz}-VL
  ASMJIT_INST_2x(vpmovzxdq, Vpmovzxdq, Xmm, Mem)                       // AVX  AVX512_F{kz}-VL
  ASMJIT_INST_2x(vpmovzxdq, Vpmovzxdq, Ymm, Xmm)                       // AVX2 AVX512_F{kz}-VL
  ASMJIT_INST_2x(vpmovzxdq, Vpmovzxdq, Ymm, Mem)                       // AVX2 AVX512_F{kz}-VL
  ASMJIT_INST_2x(vpmovzxdq, Vpmovzxdq, Zmm, Ymm)                       //      AVX512_F{kz}
  ASMJIT_INST_2x(vpmovzxdq, Vpmovzxdq, Zmm, Mem)                       //      AVX512_F{kz}
  ASMJIT_INST_2x(vpmovzxwd, Vpmovzxwd, Xmm, Xmm)                       // AVX  AVX512_F{kz}-VL
  ASMJIT_INST_2x(vpmovzxwd, Vpmovzxwd, Xmm, Mem)                       // AVX  AVX512_F{kz}-VL
  ASMJIT_INST_2x(vpmovzxwd, Vpmovzxwd, Ymm, Xmm)                       // AVX2 AVX512_F{kz}-VL
  ASMJIT_INST_2x(vpmovzxwd, Vpmovzxwd, Ymm, Mem)                       // AVX2 AVX512_F{kz}-VL
  ASMJIT_INST_2x(vpmovzxwd, Vpmovzxwd, Zmm, Ymm)                       //      AVX512_F{kz}
  ASMJIT_INST_2x(vpmovzxwd, Vpmovzxwd, Zmm, Mem)                       //      AVX512_F{kz}
  ASMJIT_INST_2x(vpmovzxwq, Vpmovzxwq, Xmm, Xmm)                       // AVX  AVX512_F{kz}-VL
  ASMJIT_INST_2x(vpmovzxwq, Vpmovzxwq, Xmm, Mem)                       // AVX  AVX512_F{kz}-VL
  ASMJIT_INST_2x(vpmovzxwq, Vpmovzxwq, Ymm, Xmm)                       // AVX2 AVX512_F{kz}-VL
  ASMJIT_INST_2x(vpmovzxwq, Vpmovzxwq, Ymm, Mem)                       // AVX2 AVX512_F{kz}-VL
  ASMJIT_INST_2x(vpmovzxwq, Vpmovzxwq, Zmm, Xmm)                       //      AVX512_F{kz}
  ASMJIT_INST_2x(vpmovzxwq, Vpmovzxwq, Zmm, Mem)                       //      AVX512_F{kz}
  ASMJIT_INST_3x(vpmuldq, Vpmuldq, Xmm, Xmm, Xmm)                      // AVX  AVX512_F{kz|b64}-VL
  ASMJIT_INST_3x(vpmuldq, Vpmuldq, Xmm, Xmm, Mem)                      // AVX  AVX512_F{kz|b64}-VL
  ASMJIT_INST_3x(vpmuldq, Vpmuldq, Ymm, Ymm, Ymm)                      // AVX2 AVX512_F{kz|b64}-VL
  ASMJIT_INST_3x(vpmuldq, Vpmuldq, Ymm, Ymm, Mem)                      // AVX2 AVX512_F{kz|b64}-VL
  ASMJIT_INST_3x(vpmuldq, Vpmuldq, Zmm, Zmm, Zmm)                      //      AVX512_F{kz|b64}
  ASMJIT_INST_3x(vpmuldq, Vpmuldq, Zmm, Zmm, Mem)                      //      AVX512_F{kz|b64}
  ASMJIT_INST_3x(vpmulhrsw, Vpmulhrsw, Xmm, Xmm, Xmm)                  // AVX  AVX512_BW{kz}-VL
  ASMJIT_INST_3x(vpmulhrsw, Vpmulhrsw, Xmm, Xmm, Mem)                  // AVX  AVX512_BW{kz}-VL
  ASMJIT_INST_3x(vpmulhrsw, Vpmulhrsw, Ymm, Ymm, Ymm)                  // AVX2 AVX512_BW{kz}-VL
  ASMJIT_INST_3x(vpmulhrsw, Vpmulhrsw, Ymm, Ymm, Mem)                  // AVX2 AVX512_BW{kz}-VL
  ASMJIT_INST_3x(vpmulhrsw, Vpmulhrsw, Zmm, Zmm, Zmm)                  //      AVX512_BW{kz}
  ASMJIT_INST_3x(vpmulhrsw, Vpmulhrsw, Zmm, Zmm, Mem)                  //      AVX512_BW{kz}
  ASMJIT_INST_3x(vpmulhuw, Vpmulhuw, Xmm, Xmm, Xmm)                    // AVX  AVX512_BW{kz}-VL
  ASMJIT_INST_3x(vpmulhuw, Vpmulhuw, Xmm, Xmm, Mem)                    // AVX  AVX512_BW{kz}-VL
  ASMJIT_INST_3x(vpmulhuw, Vpmulhuw, Ymm, Ymm, Ymm)                    // AVX2 AVX512_BW{kz}-VL
  ASMJIT_INST_3x(vpmulhuw, Vpmulhuw, Ymm, Ymm, Mem)                    // AVX2 AVX512_BW{kz}-VL
  ASMJIT_INST_3x(vpmulhuw, Vpmulhuw, Zmm, Zmm, Zmm)                    //      AVX512_BW{kz}
  ASMJIT_INST_3x(vpmulhuw, Vpmulhuw, Zmm, Zmm, Mem)                    //      AVX512_BW{kz}
  ASMJIT_INST_3x(vpmulhw, Vpmulhw, Xmm, Xmm, Xmm)                      // AVX  AVX512_BW{kz}-VL
  ASMJIT_INST_3x(vpmulhw, Vpmulhw, Xmm, Xmm, Mem)                      // AVX  AVX512_BW{kz}-VL
  ASMJIT_INST_3x(vpmulhw, Vpmulhw, Ymm, Ymm, Ymm)                      // AVX2 AVX512_BW{kz}-VL
  ASMJIT_INST_3x(vpmulhw, Vpmulhw, Ymm, Ymm, Mem)                      // AVX2 AVX512_BW{kz}-VL
  ASMJIT_INST_3x(vpmulhw, Vpmulhw, Zmm, Zmm, Zmm)                      //      AVX512_BW{kz}
  ASMJIT_INST_3x(vpmulhw, Vpmulhw, Zmm, Zmm, Mem)                      //      AVX512_BW{kz}
  ASMJIT_INST_3x(vpmulld, Vpmulld, Xmm, Xmm, Xmm)                      // AVX  AVX512_F{kz|b32}-VL
  ASMJIT_INST_3x(vpmulld, Vpmulld, Xmm, Xmm, Mem)                      // AVX  AVX512_F{kz|b32}-VL
  ASMJIT_INST_3x(vpmulld, Vpmulld, Ymm, Ymm, Ymm)                      // AVX2 AVX512_F{kz|b32}-VL
  ASMJIT_INST_3x(vpmulld, Vpmulld, Ymm, Ymm, Mem)                      // AVX2 AVX512_F{kz|b32}-VL
  ASMJIT_INST_3x(vpmulld, Vpmulld, Zmm, Zmm, Zmm)                      //      AVX512_F{kz|b32}
  ASMJIT_INST_3x(vpmulld, Vpmulld, Zmm, Zmm, Mem)                      //      AVX512_F{kz|b32}
  ASMJIT_INST_3x(vpmullq, Vpmullq, Xmm, Xmm, Xmm)                      //      AVX512_DQ{kz|b64}-VL
  ASMJIT_INST_3x(vpmullq, Vpmullq, Xmm, Xmm, Mem)                      //      AVX512_DQ{kz|b64}-VL
  ASMJIT_INST_3x(vpmullq, Vpmullq, Ymm, Ymm, Ymm)                      //      AVX512_DQ{kz|b64}-VL
  ASMJIT_INST_3x(vpmullq, Vpmullq, Ymm, Ymm, Mem)                      //      AVX512_DQ{kz|b64}-VL
  ASMJIT_INST_3x(vpmullq, Vpmullq, Zmm, Zmm, Zmm)                      //      AVX512_DQ{kz|b64}
  ASMJIT_INST_3x(vpmullq, Vpmullq, Zmm, Zmm, Mem)                      //      AVX512_DQ{kz|b64}
  ASMJIT_INST_3x(vpmullw, Vpmullw, Xmm, Xmm, Xmm)                      // AVX  AVX512_BW{kz}-VL
  ASMJIT_INST_3x(vpmullw, Vpmullw, Xmm, Xmm, Mem)                      // AVX  AVX512_BW{kz}-VL
  ASMJIT_INST_3x(vpmullw, Vpmullw, Ymm, Ymm, Ymm)                      // AVX2 AVX512_BW{kz}-VL
  ASMJIT_INST_3x(vpmullw, Vpmullw, Ymm, Ymm, Mem)                      // AVX2 AVX512_BW{kz}-VL
  ASMJIT_INST_3x(vpmullw, Vpmullw, Zmm, Zmm, Zmm)                      //      AVX512_BW{kz}
  ASMJIT_INST_3x(vpmullw, Vpmullw, Zmm, Zmm, Mem)                      //      AVX512_BW{kz}
  ASMJIT_INST_3x(vpmultishiftqb, Vpmultishiftqb, Xmm, Xmm, Xmm)        //      AVX512_VBMI{kz|b64}-VL
  ASMJIT_INST_3x(vpmultishiftqb, Vpmultishiftqb, Xmm, Xmm, Mem)        //      AVX512_VBMI{kz|b64}-VL
  ASMJIT_INST_3x(vpmultishiftqb, Vpmultishiftqb, Ymm, Ymm, Ymm)        //      AVX512_VBMI{kz|b64}-VL
  ASMJIT_INST_3x(vpmultishiftqb, Vpmultishiftqb, Ymm, Ymm, Mem)        //      AVX512_VBMI{kz|b64}-VL
  ASMJIT_INST_3x(vpmultishiftqb, Vpmultishiftqb, Zmm, Zmm, Zmm)        //      AVX512_VBMI{kz|b64}
  ASMJIT_INST_3x(vpmultishiftqb, Vpmultishiftqb, Zmm, Zmm, Mem)        //      AVX512_VBMI{kz|b64}
  ASMJIT_INST_3x(vpmuludq, Vpmuludq, Xmm, Xmm, Xmm)                    // AVX  AVX512_F{kz|b64}-VL
  ASMJIT_INST_3x(vpmuludq, Vpmuludq, Xmm, Xmm, Mem)                    // AVX  AVX512_F{kz|b64}-VL
  ASMJIT_INST_3x(vpmuludq, Vpmuludq, Ymm, Ymm, Ymm)                    // AVX2 AVX512_F{kz|b64}-VL
  ASMJIT_INST_3x(vpmuludq, Vpmuludq, Ymm, Ymm, Mem)                    // AVX2 AVX512_F{kz|b64}-VL
  ASMJIT_INST_3x(vpmuludq, Vpmuludq, Zmm, Zmm, Zmm)                    //      AVX512_F{kz|b64}
  ASMJIT_INST_3x(vpmuludq, Vpmuludq, Zmm, Zmm, Mem)                    //      AVX512_F{kz|b64}
  ASMJIT_INST_2x(vpopcntb, Vpopcntb, Xmm, Xmm)                         //      AVX512_BITALG{kz|b32}-VL
  ASMJIT_INST_2x(vpopcntb, Vpopcntb, Xmm, Mem)                         //      AVX512_BITALG{kz|b32}-VL
  ASMJIT_INST_2x(vpopcntb, Vpopcntb, Ymm, Ymm)                         //      AVX512_BITALG{kz|b32}-VL
  ASMJIT_INST_2x(vpopcntb, Vpopcntb, Ymm, Mem)                         //      AVX512_BITALG{kz|b32}-VL
  ASMJIT_INST_2x(vpopcntb, Vpopcntb, Zmm, Zmm)                         //      AVX512_BITALG{kz|b32}
  ASMJIT_INST_2x(vpopcntb, Vpopcntb, Zmm, Mem)                         //      AVX512_BITALG{kz|b32}
  ASMJIT_INST_2x(vpopcntd, Vpopcntd, Xmm, Xmm)                         //      AVX512_VPOPCNTDQ{kz|b32}-VL
  ASMJIT_INST_2x(vpopcntd, Vpopcntd, Xmm, Mem)                         //      AVX512_VPOPCNTDQ{kz|b32}-VL
  ASMJIT_INST_2x(vpopcntd, Vpopcntd, Ymm, Ymm)                         //      AVX512_VPOPCNTDQ{kz|b32}-VL
  ASMJIT_INST_2x(vpopcntd, Vpopcntd, Ymm, Mem)                         //      AVX512_VPOPCNTDQ{kz|b32}-VL
  ASMJIT_INST_2x(vpopcntd, Vpopcntd, Zmm, Zmm)                         //      AVX512_VPOPCNTDQ{kz|b32}
  ASMJIT_INST_2x(vpopcntd, Vpopcntd, Zmm, Mem)                         //      AVX512_VPOPCNTDQ{kz|b32}
  ASMJIT_INST_2x(vpopcntq, Vpopcntq, Xmm, Xmm)                         //      AVX512_VPOPCNTDQ{kz|b64}-VL
  ASMJIT_INST_2x(vpopcntq, Vpopcntq, Xmm, Mem)                         //      AVX512_VPOPCNTDQ{kz|b64}-VL
  ASMJIT_INST_2x(vpopcntq, Vpopcntq, Ymm, Ymm)                         //      AVX512_VPOPCNTDQ{kz|b64}-VL
  ASMJIT_INST_2x(vpopcntq, Vpopcntq, Ymm, Mem)                         //      AVX512_VPOPCNTDQ{kz|b64}-VL
  ASMJIT_INST_2x(vpopcntq, Vpopcntq, Zmm, Zmm)                         //      AVX512_VPOPCNTDQ{kz|b64}
  ASMJIT_INST_2x(vpopcntq, Vpopcntq, Zmm, Mem)                         //      AVX512_VPOPCNTDQ{kz|b64}
  ASMJIT_INST_2x(vpopcntw, Vpopcntw, Xmm, Xmm)                         //      AVX512_BITALG{kz|b32}-VL
  ASMJIT_INST_2x(vpopcntw, Vpopcntw, Xmm, Mem)                         //      AVX512_BITALG{kz|b32}-VL
  ASMJIT_INST_2x(vpopcntw, Vpopcntw, Ymm, Ymm)                         //      AVX512_BITALG{kz|b32}-VL
  ASMJIT_INST_2x(vpopcntw, Vpopcntw, Ymm, Mem)                         //      AVX512_BITALG{kz|b32}-VL
  ASMJIT_INST_2x(vpopcntw, Vpopcntw, Zmm, Zmm)                         //      AVX512_BITALG{kz|b32}
  ASMJIT_INST_2x(vpopcntw, Vpopcntw, Zmm, Mem)                         //      AVX512_BITALG{kz|b32}
  ASMJIT_INST_3x(vpor, Vpor, Xmm, Xmm, Xmm)                            // AVX
  ASMJIT_INST_3x(vpor, Vpor, Xmm, Xmm, Mem)                            // AVX
  ASMJIT_INST_3x(vpor, Vpor, Ymm, Ymm, Ymm)                            // AVX2
  ASMJIT_INST_3x(vpor, Vpor, Ymm, Ymm, Mem)                            // AVX2
  ASMJIT_INST_3x(vpord, Vpord, Xmm, Xmm, Xmm)                          //      AVX512_F{kz|b32}-VL
  ASMJIT_INST_3x(vpord, Vpord, Xmm, Xmm, Mem)                          //      AVX512_F{kz|b32}-VL
  ASMJIT_INST_3x(vpord, Vpord, Ymm, Ymm, Ymm)                          //      AVX512_F{kz|b32}-VL
  ASMJIT_INST_3x(vpord, Vpord, Ymm, Ymm, Mem)                          //      AVX512_F{kz|b32}-VL
  ASMJIT_INST_3x(vpord, Vpord, Zmm, Zmm, Zmm)                          //      AVX512_F{kz|b32}
  ASMJIT_INST_3x(vpord, Vpord, Zmm, Zmm, Mem)                          //      AVX512_F{kz|b32}
  ASMJIT_INST_3x(vporq, Vporq, Xmm, Xmm, Xmm)                          //      AVX512_F{kz|b64}-VL
  ASMJIT_INST_3x(vporq, Vporq, Xmm, Xmm, Mem)                          //      AVX512_F{kz|b64}-VL
  ASMJIT_INST_3x(vporq, Vporq, Ymm, Ymm, Ymm)                          //      AVX512_F{kz|b64}-VL
  ASMJIT_INST_3x(vporq, Vporq, Ymm, Ymm, Mem)                          //      AVX512_F{kz|b64}-VL
  ASMJIT_INST_3x(vporq, Vporq, Zmm, Zmm, Zmm)                          //      AVX512_F{kz|b64}
  ASMJIT_INST_3x(vporq, Vporq, Zmm, Zmm, Mem)                          //      AVX512_F{kz|b64}
  ASMJIT_INST_3i(vprold, Vprold, Xmm, Xmm, Imm)                        //      AVX512_F{kz|b32}-VL
  ASMJIT_INST_3i(vprold, Vprold, Xmm, Mem, Imm)                        //      AVX512_F{kz|b32}-VL
  ASMJIT_INST_3i(vprold, Vprold, Ymm, Ymm, Imm)                        //      AVX512_F{kz|b32}-VL
  ASMJIT_INST_3i(vprold, Vprold, Ymm, Mem, Imm)                        //      AVX512_F{kz|b32}-VL
  ASMJIT_INST_3i(vprold, Vprold, Zmm, Zmm, Imm)                        //      AVX512_F{kz|b32}
  ASMJIT_INST_3i(vprold, Vprold, Zmm, Mem, Imm)                        //      AVX512_F{kz|b32}
  ASMJIT_INST_3i(vprolq, Vprolq, Xmm, Xmm, Imm)                        //      AVX512_F{kz|b64}-VL
  ASMJIT_INST_3i(vprolq, Vprolq, Xmm, Mem, Imm)                        //      AVX512_F{kz|b64}-VL
  ASMJIT_INST_3i(vprolq, Vprolq, Ymm, Ymm, Imm)                        //      AVX512_F{kz|b64}-VL
  ASMJIT_INST_3i(vprolq, Vprolq, Ymm, Mem, Imm)                        //      AVX512_F{kz|b64}-VL
  ASMJIT_INST_3i(vprolq, Vprolq, Zmm, Zmm, Imm)                        //      AVX512_F{kz|b64}
  ASMJIT_INST_3i(vprolq, Vprolq, Zmm, Mem, Imm)                        //      AVX512_F{kz|b64}
  ASMJIT_INST_3x(vprolvd, Vprolvd, Xmm, Xmm, Xmm)                      //      AVX512_F{kz|b32}-VL
  ASMJIT_INST_3x(vprolvd, Vprolvd, Xmm, Xmm, Mem)                      //      AVX512_F{kz|b32}-VL
  ASMJIT_INST_3x(vprolvd, Vprolvd, Ymm, Ymm, Ymm)                      //      AVX512_F{kz|b32}-VL
  ASMJIT_INST_3x(vprolvd, Vprolvd, Ymm, Ymm, Mem)                      //      AVX512_F{kz|b32}-VL
  ASMJIT_INST_3x(vprolvd, Vprolvd, Zmm, Zmm, Zmm)                      //      AVX512_F{kz|b32}
  ASMJIT_INST_3x(vprolvd, Vprolvd, Zmm, Zmm, Mem)                      //      AVX512_F{kz|b32}
  ASMJIT_INST_3x(vprolvq, Vprolvq, Xmm, Xmm, Xmm)                      //      AVX512_F{kz|b64}-VL
  ASMJIT_INST_3x(vprolvq, Vprolvq, Xmm, Xmm, Mem)                      //      AVX512_F{kz|b64}-VL
  ASMJIT_INST_3x(vprolvq, Vprolvq, Ymm, Ymm, Ymm)                      //      AVX512_F{kz|b64}-VL
  ASMJIT_INST_3x(vprolvq, Vprolvq, Ymm, Ymm, Mem)                      //      AVX512_F{kz|b64}-VL
  ASMJIT_INST_3x(vprolvq, Vprolvq, Zmm, Zmm, Zmm)                      //      AVX512_F{kz|b64}
  ASMJIT_INST_3x(vprolvq, Vprolvq, Zmm, Zmm, Mem)                      //      AVX512_F{kz|b64}
  ASMJIT_INST_3i(vprord, Vprord, Xmm, Xmm, Imm)                        //      AVX512_F{kz|b32}-VL
  ASMJIT_INST_3i(vprord, Vprord, Xmm, Mem, Imm)                        //      AVX512_F{kz|b32}-VL
  ASMJIT_INST_3i(vprord, Vprord, Ymm, Ymm, Imm)                        //      AVX512_F{kz|b32}-VL
  ASMJIT_INST_3i(vprord, Vprord, Ymm, Mem, Imm)                        //      AVX512_F{kz|b32}-VL
  ASMJIT_INST_3i(vprord, Vprord, Zmm, Zmm, Imm)                        //      AVX512_F{kz|b32}
  ASMJIT_INST_3i(vprord, Vprord, Zmm, Mem, Imm)                        //      AVX512_F{kz|b32}
  ASMJIT_INST_3i(vprorq, Vprorq, Xmm, Xmm, Imm)                        //      AVX512_F{kz|b64}-VL
  ASMJIT_INST_3i(vprorq, Vprorq, Xmm, Mem, Imm)                        //      AVX512_F{kz|b64}-VL
  ASMJIT_INST_3i(vprorq, Vprorq, Ymm, Ymm, Imm)                        //      AVX512_F{kz|b64}-VL
  ASMJIT_INST_3i(vprorq, Vprorq, Ymm, Mem, Imm)                        //      AVX512_F{kz|b64}-VL
  ASMJIT_INST_3i(vprorq, Vprorq, Zmm, Zmm, Imm)                        //      AVX512_F{kz|b64}
  ASMJIT_INST_3i(vprorq, Vprorq, Zmm, Mem, Imm)                        //      AVX512_F{kz|b64}
  ASMJIT_INST_3x(vprorvd, Vprorvd, Xmm, Xmm, Xmm)                      //      AVX512_F{kz|b32}-VL
  ASMJIT_INST_3x(vprorvd, Vprorvd, Xmm, Xmm, Mem)                      //      AVX512_F{kz|b32}-VL
  ASMJIT_INST_3x(vprorvd, Vprorvd, Ymm, Ymm, Ymm)                      //      AVX512_F{kz|b32}-VL
  ASMJIT_INST_3x(vprorvd, Vprorvd, Ymm, Ymm, Mem)                      //      AVX512_F{kz|b32}-VL
  ASMJIT_INST_3x(vprorvd, Vprorvd, Zmm, Zmm, Zmm)                      //      AVX512_F{kz|b32}
  ASMJIT_INST_3x(vprorvd, Vprorvd, Zmm, Zmm, Mem)                      //      AVX512_F{kz|b32}
  ASMJIT_INST_3x(vprorvq, Vprorvq, Xmm, Xmm, Xmm)                      //      AVX512_F{kz|b64}-VL
  ASMJIT_INST_3x(vprorvq, Vprorvq, Xmm, Xmm, Mem)                      //      AVX512_F{kz|b64}-VL
  ASMJIT_INST_3x(vprorvq, Vprorvq, Ymm, Ymm, Ymm)                      //      AVX512_F{kz|b64}-VL
  ASMJIT_INST_3x(vprorvq, Vprorvq, Ymm, Ymm, Mem)                      //      AVX512_F{kz|b64}-VL
  ASMJIT_INST_3x(vprorvq, Vprorvq, Zmm, Zmm, Zmm)                      //      AVX512_F{kz|b64}
  ASMJIT_INST_3x(vprorvq, Vprorvq, Zmm, Zmm, Mem)                      //      AVX512_F{kz|b64}
  ASMJIT_INST_3x(vpsadbw, Vpsadbw, Xmm, Xmm, Xmm)                      // AVX  AVX512_BW-VL
  ASMJIT_INST_3x(vpsadbw, Vpsadbw, Xmm, Xmm, Mem)                      // AVX  AVX512_BW-VL
  ASMJIT_INST_3x(vpsadbw, Vpsadbw, Ymm, Ymm, Ymm)                      // AVX2 AVX512_BW-VL
  ASMJIT_INST_3x(vpsadbw, Vpsadbw, Ymm, Ymm, Mem)                      // AVX2 AVX512_BW-VL
  ASMJIT_INST_3x(vpsadbw, Vpsadbw, Zmm, Zmm, Zmm)                      //      AVX512_BW
  ASMJIT_INST_3x(vpsadbw, Vpsadbw, Zmm, Zmm, Mem)                      //      AVX512_BW
  ASMJIT_INST_2x(vpscatterdd, Vpscatterdd, Mem, Xmm)                   //      AVX512_F{k}-VL
  ASMJIT_INST_2x(vpscatterdd, Vpscatterdd, Mem, Ymm)                   //      AVX512_F{k}-VL
  ASMJIT_INST_2x(vpscatterdd, Vpscatterdd, Mem, Zmm)                   //      AVX512_F{k}
  ASMJIT_INST_2x(vpscatterdq, Vpscatterdq, Mem, Xmm)                   //      AVX512_F{k}-VL
  ASMJIT_INST_2x(vpscatterdq, Vpscatterdq, Mem, Ymm)                   //      AVX512_F{k}-VL
  ASMJIT_INST_2x(vpscatterdq, Vpscatterdq, Mem, Zmm)                   //      AVX512_F{k}
  ASMJIT_INST_2x(vpscatterqd, Vpscatterqd, Mem, Xmm)                   //      AVX512_F{k}-VL
  ASMJIT_INST_2x(vpscatterqd, Vpscatterqd, Mem, Ymm)                   //      AVX512_F{k}
  ASMJIT_INST_2x(vpscatterqq, Vpscatterqq, Mem, Xmm)                   //      AVX512_F{k}-VL
  ASMJIT_INST_2x(vpscatterqq, Vpscatterqq, Mem, Ymm)                   //      AVX512_F{k}-VL
  ASMJIT_INST_2x(vpscatterqq, Vpscatterqq, Mem, Zmm)                   //      AVX512_F{k}
  ASMJIT_INST_4i(vpshldd, Vpshldd, Xmm, Xmm, Xmm, Imm)                 //      AVX512_VBMI2{kz}-VL
  ASMJIT_INST_4i(vpshldd, Vpshldd, Xmm, Xmm, Mem, Imm)                 //      AVX512_VBMI2{kz}-VL
  ASMJIT_INST_4i(vpshldd, Vpshldd, Ymm, Ymm, Ymm, Imm)                 //      AVX512_VBMI2{kz}-VL
  ASMJIT_INST_4i(vpshldd, Vpshldd, Ymm, Ymm, Mem, Imm)                 //      AVX512_VBMI2{kz}-VL
  ASMJIT_INST_4i(vpshldd, Vpshldd, Zmm, Zmm, Zmm, Imm)                 //      AVX512_VBMI2{kz}
  ASMJIT_INST_4i(vpshldd, Vpshldd, Zmm, Zmm, Mem, Imm)                 //      AVX512_VBMI2{kz}
  ASMJIT_INST_3x(vpshldvd, Vpshldvd, Xmm, Xmm, Xmm)                    //      AVX512_VBMI2{kz}-VL
  ASMJIT_INST_3x(vpshldvd, Vpshldvd, Xmm, Xmm, Mem)                    //      AVX512_VBMI2{kz}-VL
  ASMJIT_INST_3x(vpshldvd, Vpshldvd, Ymm, Ymm, Ymm)                    //      AVX512_VBMI2{kz}-VL
  ASMJIT_INST_3x(vpshldvd, Vpshldvd, Ymm, Ymm, Mem)                    //      AVX512_VBMI2{kz}-VL
  ASMJIT_INST_3x(vpshldvd, Vpshldvd, Zmm, Zmm, Zmm)                    //      AVX512_VBMI2{kz}
  ASMJIT_INST_3x(vpshldvd, Vpshldvd, Zmm, Zmm, Mem)                    //      AVX512_VBMI2{kz}
  ASMJIT_INST_3x(vpshldvq, Vpshldvq, Xmm, Xmm, Xmm)                    //      AVX512_VBMI2{kz}-VL
  ASMJIT_INST_3x(vpshldvq, Vpshldvq, Xmm, Xmm, Mem)                    //      AVX512_VBMI2{kz}-VL
  ASMJIT_INST_3x(vpshldvq, Vpshldvq, Ymm, Ymm, Ymm)                    //      AVX512_VBMI2{kz}-VL
  ASMJIT_INST_3x(vpshldvq, Vpshldvq, Ymm, Ymm, Mem)                    //      AVX512_VBMI2{kz}-VL
  ASMJIT_INST_3x(vpshldvq, Vpshldvq, Zmm, Zmm, Zmm)                    //      AVX512_VBMI2{kz}
  ASMJIT_INST_3x(vpshldvq, Vpshldvq, Zmm, Zmm, Mem)                    //      AVX512_VBMI2{kz}
  ASMJIT_INST_3x(vpshldvw, Vpshldvw, Xmm, Xmm, Xmm)                    //      AVX512_VBMI2{kz}-VL
  ASMJIT_INST_3x(vpshldvw, Vpshldvw, Xmm, Xmm, Mem)                    //      AVX512_VBMI2{kz}-VL
  ASMJIT_INST_3x(vpshldvw, Vpshldvw, Ymm, Ymm, Ymm)                    //      AVX512_VBMI2{kz}-VL
  ASMJIT_INST_3x(vpshldvw, Vpshldvw, Ymm, Ymm, Mem)                    //      AVX512_VBMI2{kz}-VL
  ASMJIT_INST_3x(vpshldvw, Vpshldvw, Zmm, Zmm, Zmm)                    //      AVX512_VBMI2{kz}
  ASMJIT_INST_3x(vpshldvw, Vpshldvw, Zmm, Zmm, Mem)                    //      AVX512_VBMI2{kz}
  ASMJIT_INST_4i(vpshrdd, Vpshrdd, Xmm, Xmm, Xmm, Imm)                 //      AVX512_VBMI2{kz}-VL
  ASMJIT_INST_4i(vpshrdd, Vpshrdd, Xmm, Xmm, Mem, Imm)                 //      AVX512_VBMI2{kz}-VL
  ASMJIT_INST_4i(vpshrdd, Vpshrdd, Ymm, Ymm, Ymm, Imm)                 //      AVX512_VBMI2{kz}-VL
  ASMJIT_INST_4i(vpshrdd, Vpshrdd, Ymm, Ymm, Mem, Imm)                 //      AVX512_VBMI2{kz}-VL
  ASMJIT_INST_4i(vpshrdd, Vpshrdd, Zmm, Zmm, Zmm, Imm)                 //      AVX512_VBMI2{kz}
  ASMJIT_INST_4i(vpshrdd, Vpshrdd, Zmm, Zmm, Mem, Imm)                 //      AVX512_VBMI2{kz}
  ASMJIT_INST_3x(vpshrdvd, Vpshrdvd, Xmm, Xmm, Xmm)                    //      AVX512_VBMI2{kz}-VL
  ASMJIT_INST_3x(vpshrdvd, Vpshrdvd, Xmm, Xmm, Mem)                    //      AVX512_VBMI2{kz}-VL
  ASMJIT_INST_3x(vpshrdvd, Vpshrdvd, Ymm, Ymm, Ymm)                    //      AVX512_VBMI2{kz}-VL
  ASMJIT_INST_3x(vpshrdvd, Vpshrdvd, Ymm, Ymm, Mem)                    //      AVX512_VBMI2{kz}-VL
  ASMJIT_INST_3x(vpshrdvd, Vpshrdvd, Zmm, Zmm, Zmm)                    //      AVX512_VBMI2{kz}
  ASMJIT_INST_3x(vpshrdvd, Vpshrdvd, Zmm, Zmm, Mem)                    //      AVX512_VBMI2{kz}
  ASMJIT_INST_3x(vpshrdvq, Vpshrdvq, Xmm, Xmm, Xmm)                    //      AVX512_VBMI2{kz}-VL
  ASMJIT_INST_3x(vpshrdvq, Vpshrdvq, Xmm, Xmm, Mem)                    //      AVX512_VBMI2{kz}-VL
  ASMJIT_INST_3x(vpshrdvq, Vpshrdvq, Ymm, Ymm, Ymm)                    //      AVX512_VBMI2{kz}-VL
  ASMJIT_INST_3x(vpshrdvq, Vpshrdvq, Ymm, Ymm, Mem)                    //      AVX512_VBMI2{kz}-VL
  ASMJIT_INST_3x(vpshrdvq, Vpshrdvq, Zmm, Zmm, Zmm)                    //      AVX512_VBMI2{kz}
  ASMJIT_INST_3x(vpshrdvq, Vpshrdvq, Zmm, Zmm, Mem)                    //      AVX512_VBMI2{kz}
  ASMJIT_INST_3x(vpshrdvw, Vpshrdvw, Xmm, Xmm, Xmm)                    //      AVX512_VBMI2{kz}-VL
  ASMJIT_INST_3x(vpshrdvw, Vpshrdvw, Xmm, Xmm, Mem)                    //      AVX512_VBMI2{kz}-VL
  ASMJIT_INST_3x(vpshrdvw, Vpshrdvw, Ymm, Ymm, Ymm)                    //      AVX512_VBMI2{kz}-VL
  ASMJIT_INST_3x(vpshrdvw, Vpshrdvw, Ymm, Ymm, Mem)                    //      AVX512_VBMI2{kz}-VL
  ASMJIT_INST_3x(vpshrdvw, Vpshrdvw, Zmm, Zmm, Zmm)                    //      AVX512_VBMI2{kz}
  ASMJIT_INST_3x(vpshrdvw, Vpshrdvw, Zmm, Zmm, Mem)                    //      AVX512_VBMI2{kz}
  ASMJIT_INST_4i(vpshrdw, Vpshrdw, Xmm, Xmm, Xmm, Imm)                 //      AVX512_VBMI2{kz}-VL
  ASMJIT_INST_4i(vpshrdw, Vpshrdw, Xmm, Xmm, Mem, Imm)                 //      AVX512_VBMI2{kz}-VL
  ASMJIT_INST_4i(vpshrdw, Vpshrdw, Ymm, Ymm, Ymm, Imm)                 //      AVX512_VBMI2{kz}-VL
  ASMJIT_INST_4i(vpshrdw, Vpshrdw, Ymm, Ymm, Mem, Imm)                 //      AVX512_VBMI2{kz}-VL
  ASMJIT_INST_4i(vpshrdw, Vpshrdw, Zmm, Zmm, Zmm, Imm)                 //      AVX512_VBMI2{kz}
  ASMJIT_INST_4i(vpshrdw, Vpshrdw, Zmm, Zmm, Mem, Imm)                 //      AVX512_VBMI2{kz}
  ASMJIT_INST_3x(vpshufb, Vpshufb, Xmm, Xmm, Xmm)                      // AVX  AVX512_BW{kz}-VL
  ASMJIT_INST_3x(vpshufb, Vpshufb, Xmm, Xmm, Mem)                      // AVX  AVX512_BW{kz}-VL
  ASMJIT_INST_3x(vpshufb, Vpshufb, Ymm, Ymm, Ymm)                      // AVX2 AVX512_BW{kz}-VL
  ASMJIT_INST_3x(vpshufb, Vpshufb, Ymm, Ymm, Mem)                      // AVX2 AVX512_BW{kz}-VL
  ASMJIT_INST_3x(vpshufb, Vpshufb, Zmm, Zmm, Zmm)                      //      AVX512_BW{kz}
  ASMJIT_INST_3x(vpshufb, Vpshufb, Zmm, Zmm, Mem)                      //      AVX512_BW{kz}
  ASMJIT_INST_3x(vpshufbitqmb, Vpshufbitqmb, KReg, Xmm, Xmm)           //      AVX512_BITALG{k}-VL
  ASMJIT_INST_3x(vpshufbitqmb, Vpshufbitqmb, KReg, Xmm, Mem)           //      AVX512_BITALG{k}-VL
  ASMJIT_INST_3x(vpshufbitqmb, Vpshufbitqmb, KReg, Ymm, Ymm)           //      AVX512_BITALG{k}-VL
  ASMJIT_INST_3x(vpshufbitqmb, Vpshufbitqmb, KReg, Ymm, Mem)           //      AVX512_BITALG{k}-VL
  ASMJIT_INST_3x(vpshufbitqmb, Vpshufbitqmb, KReg, Zmm, Zmm)           //      AVX512_BITALG{k}
  ASMJIT_INST_3x(vpshufbitqmb, Vpshufbitqmb, KReg, Zmm, Mem)           //      AVX512_BITALG{k}
  ASMJIT_INST_3i(vpshufd, Vpshufd, Xmm, Xmm, Imm)                      // AVX  AVX512_F{kz|b32}-VL
  ASMJIT_INST_3i(vpshufd, Vpshufd, Xmm, Mem, Imm)                      // AVX  AVX512_F{kz|b32}-VL
  ASMJIT_INST_3i(vpshufd, Vpshufd, Ymm, Ymm, Imm)                      // AVX2 AVX512_F{kz|b32}-VL
  ASMJIT_INST_3i(vpshufd, Vpshufd, Ymm, Mem, Imm)                      // AVX2 AVX512_F{kz|b32}-VL
  ASMJIT_INST_3i(vpshufd, Vpshufd, Zmm, Zmm, Imm)                      //      AVX512_F{kz|b32}
  ASMJIT_INST_3i(vpshufd, Vpshufd, Zmm, Mem, Imm)                      //      AVX512_F{kz|b32}
  ASMJIT_INST_3i(vpshufhw, Vpshufhw, Xmm, Xmm, Imm)                    // AVX  AVX512_BW{kz}-VL
  ASMJIT_INST_3i(vpshufhw, Vpshufhw, Xmm, Mem, Imm)                    // AVX  AVX512_BW{kz}-VL
  ASMJIT_INST_3i(vpshufhw, Vpshufhw, Ymm, Ymm, Imm)                    // AVX2 AVX512_BW{kz}-VL
  ASMJIT_INST_3i(vpshufhw, Vpshufhw, Ymm, Mem, Imm)                    // AVX2 AVX512_BW{kz}-VL
  ASMJIT_INST_3i(vpshufhw, Vpshufhw, Zmm, Zmm, Imm)                    //      AVX512_BW{kz}
  ASMJIT_INST_3i(vpshufhw, Vpshufhw, Zmm, Mem, Imm)                    //      AVX512_BW{kz}
  ASMJIT_INST_3i(vpshuflw, Vpshuflw, Xmm, Xmm, Imm)                    // AVX  AVX512_BW{kz}-VL
  ASMJIT_INST_3i(vpshuflw, Vpshuflw, Xmm, Mem, Imm)                    // AVX  AVX512_BW{kz}-VL
  ASMJIT_INST_3i(vpshuflw, Vpshuflw, Ymm, Ymm, Imm)                    // AVX2 AVX512_BW{kz}-VL
  ASMJIT_INST_3i(vpshuflw, Vpshuflw, Ymm, Mem, Imm)                    // AVX2 AVX512_BW{kz}-VL
  ASMJIT_INST_3i(vpshuflw, Vpshuflw, Zmm, Zmm, Imm)                    //      AVX512_BW{kz}
  ASMJIT_INST_3i(vpshuflw, Vpshuflw, Zmm, Mem, Imm)                    //      AVX512_BW{kz}
  ASMJIT_INST_3x(vpsignb, Vpsignb, Xmm, Xmm, Xmm)                      // AVX
  ASMJIT_INST_3x(vpsignb, Vpsignb, Xmm, Xmm, Mem)                      // AVX
  ASMJIT_INST_3x(vpsignb, Vpsignb, Ymm, Ymm, Ymm)                      // AVX2
  ASMJIT_INST_3x(vpsignb, Vpsignb, Ymm, Ymm, Mem)                      // AVX2
  ASMJIT_INST_3x(vpsignd, Vpsignd, Xmm, Xmm, Xmm)                      // AVX
  ASMJIT_INST_3x(vpsignd, Vpsignd, Xmm, Xmm, Mem)                      // AVX
  ASMJIT_INST_3x(vpsignd, Vpsignd, Ymm, Ymm, Ymm)                      // AVX2
  ASMJIT_INST_3x(vpsignd, Vpsignd, Ymm, Ymm, Mem)                      // AVX2
  ASMJIT_INST_3x(vpsignw, Vpsignw, Xmm, Xmm, Xmm)                      // AVX
  ASMJIT_INST_3x(vpsignw, Vpsignw, Xmm, Xmm, Mem)                      // AVX
  ASMJIT_INST_3x(vpsignw, Vpsignw, Ymm, Ymm, Ymm)                      // AVX2
  ASMJIT_INST_3x(vpsignw, Vpsignw, Ymm, Ymm, Mem)                      // AVX2
  ASMJIT_INST_3i(vpslld, Vpslld, Xmm, Xmm, Imm)                        // AVX  AVX512_F{kz|b32}-VL
  ASMJIT_INST_3x(vpslld, Vpslld, Xmm, Xmm, Xmm)                        // AVX  AVX512_F{kz}-VL
  ASMJIT_INST_3x(vpslld, Vpslld, Xmm, Xmm, Mem)                        // AVX  AVX512_F{kz}-VL
  ASMJIT_INST_3i(vpslld, Vpslld, Ymm, Ymm, Imm)                        // AVX2 AVX512_F{kz|b32}-VL
  ASMJIT_INST_3x(vpslld, Vpslld, Ymm, Ymm, Xmm)                        // AVX2 AVX512_F{kz}-VL
  ASMJIT_INST_3x(vpslld, Vpslld, Ymm, Ymm, Mem)                        // AVX2 AVX512_F{kz}-VL
  ASMJIT_INST_3i(vpslld, Vpslld, Xmm, Mem, Imm)                        //      AVX512_F{kz|b32}-VL
  ASMJIT_INST_3i(vpslld, Vpslld, Ymm, Mem, Imm)                        //      AVX512_F{kz|b32}-VL
  ASMJIT_INST_3x(vpslld, Vpslld, Zmm, Zmm, Xmm)                        //      AVX512_F{kz}
  ASMJIT_INST_3x(vpslld, Vpslld, Zmm, Zmm, Mem)                        //      AVX512_F{kz}
  ASMJIT_INST_3i(vpslld, Vpslld, Zmm, Zmm, Imm)                        //      AVX512_F{kz|b32}
  ASMJIT_INST_3i(vpslld, Vpslld, Zmm, Mem, Imm)                        //      AVX512_F{kz|b32}
  ASMJIT_INST_3i(vpslldq, Vpslldq, Xmm, Xmm, Imm)                      // AVX  AVX512_BW-VL
  ASMJIT_INST_3i(vpslldq, Vpslldq, Ymm, Ymm, Imm)                      // AVX2 AVX512_BW-VL
  ASMJIT_INST_3i(vpslldq, Vpslldq, Xmm, Mem, Imm)                      //      AVX512_BW-VL
  ASMJIT_INST_3i(vpslldq, Vpslldq, Ymm, Mem, Imm)                      //      AVX512_BW-VL
  ASMJIT_INST_3i(vpslldq, Vpslldq, Zmm, Zmm, Imm)                      //      AVX512_BW
  ASMJIT_INST_3i(vpslldq, Vpslldq, Zmm, Mem, Imm)                      //      AVX512_BW
  ASMJIT_INST_3i(vpsllq, Vpsllq, Xmm, Xmm, Imm)                        // AVX  AVX512_F{kz|b64}-VL
  ASMJIT_INST_3x(vpsllq, Vpsllq, Xmm, Xmm, Xmm)                        // AVX  AVX512_F{kz}-VL
  ASMJIT_INST_3x(vpsllq, Vpsllq, Xmm, Xmm, Mem)                        // AVX  AVX512_F{kz}-VL
  ASMJIT_INST_3i(vpsllq, Vpsllq, Ymm, Ymm, Imm)                        // AVX2 AVX512_F{kz|b64}-VL
  ASMJIT_INST_3x(vpsllq, Vpsllq, Ymm, Ymm, Xmm)                        // AVX2 AVX512_F{kz}-VL
  ASMJIT_INST_3x(vpsllq, Vpsllq, Ymm, Ymm, Mem)                        // AVX2 AVX512_F{kz}-VL
  ASMJIT_INST_3i(vpsllq, Vpsllq, Xmm, Mem, Imm)                        //      AVX512_F{kz|b64}-VL
  ASMJIT_INST_3i(vpsllq, Vpsllq, Ymm, Mem, Imm)                        //      AVX512_F{kz|b64}-VL
  ASMJIT_INST_3x(vpsllq, Vpsllq, Zmm, Zmm, Xmm)                        //      AVX512_F{kz}
  ASMJIT_INST_3x(vpsllq, Vpsllq, Zmm, Zmm, Mem)                        //      AVX512_F{kz}
  ASMJIT_INST_3i(vpsllq, Vpsllq, Zmm, Zmm, Imm)                        //      AVX512_F{kz|b64}
  ASMJIT_INST_3i(vpsllq, Vpsllq, Zmm, Mem, Imm)                        //      AVX512_F{kz|b64}
  ASMJIT_INST_3x(vpsllvd, Vpsllvd, Xmm, Xmm, Xmm)                      // AVX2 AVX512_F{kz|b32}-VL
  ASMJIT_INST_3x(vpsllvd, Vpsllvd, Xmm, Xmm, Mem)                      // AVX2 AVX512_F{kz|b32}-VL
  ASMJIT_INST_3x(vpsllvd, Vpsllvd, Ymm, Ymm, Ymm)                      // AVX2 AVX512_F{kz|b32}-VL
  ASMJIT_INST_3x(vpsllvd, Vpsllvd, Ymm, Ymm, Mem)                      // AVX2 AVX512_F{kz|b32}-VL
  ASMJIT_INST_3x(vpsllvd, Vpsllvd, Zmm, Zmm, Zmm)                      //      AVX512_F{kz|b32}
  ASMJIT_INST_3x(vpsllvd, Vpsllvd, Zmm, Zmm, Mem)                      //      AVX512_F{kz|b32}
  ASMJIT_INST_3x(vpsllvq, Vpsllvq, Xmm, Xmm, Xmm)                      // AVX2 AVX512_F{kz|b64}-VL
  ASMJIT_INST_3x(vpsllvq, Vpsllvq, Xmm, Xmm, Mem)                      // AVX2 AVX512_F{kz|b64}-VL
  ASMJIT_INST_3x(vpsllvq, Vpsllvq, Ymm, Ymm, Ymm)                      // AVX2 AVX512_F{kz|b64}-VL
  ASMJIT_INST_3x(vpsllvq, Vpsllvq, Ymm, Ymm, Mem)                      // AVX2 AVX512_F{kz|b64}-VL
  ASMJIT_INST_3x(vpsllvq, Vpsllvq, Zmm, Zmm, Zmm)                      //      AVX512_F{kz|b64}
  ASMJIT_INST_3x(vpsllvq, Vpsllvq, Zmm, Zmm, Mem)                      //      AVX512_F{kz|b64}
  ASMJIT_INST_3x(vpsllvw, Vpsllvw, Xmm, Xmm, Xmm)                      //      AVX512_BW{kz}-VL
  ASMJIT_INST_3x(vpsllvw, Vpsllvw, Xmm, Xmm, Mem)                      //      AVX512_BW{kz}-VL
  ASMJIT_INST_3x(vpsllvw, Vpsllvw, Ymm, Ymm, Ymm)                      //      AVX512_BW{kz}-VL
  ASMJIT_INST_3x(vpsllvw, Vpsllvw, Ymm, Ymm, Mem)                      //      AVX512_BW{kz}-VL
  ASMJIT_INST_3x(vpsllvw, Vpsllvw, Zmm, Zmm, Zmm)                      //      AVX512_BW{kz}
  ASMJIT_INST_3x(vpsllvw, Vpsllvw, Zmm, Zmm, Mem)                      //      AVX512_BW{kz}
  ASMJIT_INST_3i(vpsllw, Vpsllw, Xmm, Xmm, Imm)                        // AVX  AVX512_BW{kz}-VL
  ASMJIT_INST_3x(vpsllw, Vpsllw, Xmm, Xmm, Xmm)                        // AVX  AVX512_BW{kz}-VL
  ASMJIT_INST_3x(vpsllw, Vpsllw, Xmm, Xmm, Mem)                        // AVX  AVX512_BW{kz}-VL
  ASMJIT_INST_3i(vpsllw, Vpsllw, Ymm, Ymm, Imm)                        // AVX2 AVX512_BW{kz}-VL
  ASMJIT_INST_3x(vpsllw, Vpsllw, Ymm, Ymm, Xmm)                        // AVX2 AVX512_BW{kz}-VL
  ASMJIT_INST_3x(vpsllw, Vpsllw, Ymm, Ymm, Mem)                        // AVX2 AVX512_BW{kz}-VL
  ASMJIT_INST_3i(vpsllw, Vpsllw, Xmm, Mem, Imm)                        //      AVX512_BW{kz}-VL
  ASMJIT_INST_3i(vpsllw, Vpsllw, Ymm, Mem, Imm)                        //      AVX512_BW{kz}-VL
  ASMJIT_INST_3x(vpsllw, Vpsllw, Zmm, Zmm, Xmm)                        //      AVX512_BW{kz}
  ASMJIT_INST_3x(vpsllw, Vpsllw, Zmm, Zmm, Mem)                        //      AVX512_BW{kz}
  ASMJIT_INST_3i(vpsllw, Vpsllw, Zmm, Zmm, Imm)                        //      AVX512_BW{kz}
  ASMJIT_INST_3i(vpsllw, Vpsllw, Zmm, Mem, Imm)                        //      AVX512_BW{kz}
  ASMJIT_INST_3i(vpsrad, Vpsrad, Xmm, Xmm, Imm)                        // AVX  AVX512_F{kz|b32}-VL
  ASMJIT_INST_3x(vpsrad, Vpsrad, Xmm, Xmm, Xmm)                        // AVX  AVX512_F{kz}-VL
  ASMJIT_INST_3x(vpsrad, Vpsrad, Xmm, Xmm, Mem)                        // AVX  AVX512_F{kz}-VL
  ASMJIT_INST_3i(vpsrad, Vpsrad, Ymm, Ymm, Imm)                        // AVX2 AVX512_F{kz|b32}-VL
  ASMJIT_INST_3x(vpsrad, Vpsrad, Ymm, Ymm, Xmm)                        // AVX2 AVX512_F{kz}-VL
  ASMJIT_INST_3x(vpsrad, Vpsrad, Ymm, Ymm, Mem)                        // AVX2 AVX512_F{kz}-VL
  ASMJIT_INST_3i(vpsrad, Vpsrad, Xmm, Mem, Imm)                        //      AVX512_F{kz|b32}-VL
  ASMJIT_INST_3i(vpsrad, Vpsrad, Ymm, Mem, Imm)                        //      AVX512_F{kz|b32}-VL
  ASMJIT_INST_3x(vpsrad, Vpsrad, Zmm, Zmm, Xmm)                        //      AVX512_F{kz}
  ASMJIT_INST_3x(vpsrad, Vpsrad, Zmm, Zmm, Mem)                        //      AVX512_F{kz}
  ASMJIT_INST_3i(vpsrad, Vpsrad, Zmm, Zmm, Imm)                        //      AVX512_F{kz|b32}
  ASMJIT_INST_3i(vpsrad, Vpsrad, Zmm, Mem, Imm)                        //      AVX512_F{kz|b32}
  ASMJIT_INST_3x(vpsraq, Vpsraq, Xmm, Xmm, Xmm)                        //      AVX512_F{kz}-VL
  ASMJIT_INST_3x(vpsraq, Vpsraq, Xmm, Xmm, Mem)                        //      AVX512_F{kz}-VL
  ASMJIT_INST_3i(vpsraq, Vpsraq, Xmm, Xmm, Imm)                        //      AVX512_F{kz|b64}-VL
  ASMJIT_INST_3i(vpsraq, Vpsraq, Xmm, Mem, Imm)                        //      AVX512_F{kz|b64}-VL
  ASMJIT_INST_3x(vpsraq, Vpsraq, Ymm, Ymm, Xmm)                        //      AVX512_F{kz}-VL
  ASMJIT_INST_3x(vpsraq, Vpsraq, Ymm, Ymm, Mem)                        //      AVX512_F{kz}-VL
  ASMJIT_INST_3i(vpsraq, Vpsraq, Ymm, Ymm, Imm)                        //      AVX512_F{kz|b64}-VL
  ASMJIT_INST_3i(vpsraq, Vpsraq, Ymm, Mem, Imm)                        //      AVX512_F{kz|b64}-VL
  ASMJIT_INST_3x(vpsraq, Vpsraq, Zmm, Zmm, Xmm)                        //      AVX512_F{kz}
  ASMJIT_INST_3x(vpsraq, Vpsraq, Zmm, Zmm, Mem)                        //      AVX512_F{kz}
  ASMJIT_INST_3i(vpsraq, Vpsraq, Zmm, Zmm, Imm)                        //      AVX512_F{kz|b64}
  ASMJIT_INST_3i(vpsraq, Vpsraq, Zmm, Mem, Imm)                        //      AVX512_F{kz|b64}
  ASMJIT_INST_3x(vpsravd, Vpsravd, Xmm, Xmm, Xmm)                      // AVX2 AVX512_F{kz|b32}-VL
  ASMJIT_INST_3x(vpsravd, Vpsravd, Xmm, Xmm, Mem)                      // AVX2 AVX512_F{kz|b32}-VL
  ASMJIT_INST_3x(vpsravd, Vpsravd, Ymm, Ymm, Ymm)                      // AVX2 AVX512_F{kz|b32}-VL
  ASMJIT_INST_3x(vpsravd, Vpsravd, Ymm, Ymm, Mem)                      // AVX2 AVX512_F{kz|b32}-VL
  ASMJIT_INST_3x(vpsravd, Vpsravd, Zmm, Zmm, Zmm)                      //      AVX512_F{kz|b32}
  ASMJIT_INST_3x(vpsravd, Vpsravd, Zmm, Zmm, Mem)                      //      AVX512_F{kz|b32}
  ASMJIT_INST_3x(vpsravq, Vpsravq, Xmm, Xmm, Xmm)                      //      AVX512_F{kz|b64}-VL
  ASMJIT_INST_3x(vpsravq, Vpsravq, Xmm, Xmm, Mem)                      //      AVX512_F{kz|b64}-VL
  ASMJIT_INST_3x(vpsravq, Vpsravq, Ymm, Ymm, Ymm)                      //      AVX512_F{kz|b64}-VL
  ASMJIT_INST_3x(vpsravq, Vpsravq, Ymm, Ymm, Mem)                      //      AVX512_F{kz|b64}-VL
  ASMJIT_INST_3x(vpsravq, Vpsravq, Zmm, Zmm, Zmm)                      //      AVX512_F{kz|b64}
  ASMJIT_INST_3x(vpsravq, Vpsravq, Zmm, Zmm, Mem)                      //      AVX512_F{kz|b64}
  ASMJIT_INST_3x(vpsravw, Vpsravw, Xmm, Xmm, Xmm)                      //      AVX512_BW{kz}-VL
  ASMJIT_INST_3x(vpsravw, Vpsravw, Xmm, Xmm, Mem)                      //      AVX512_BW{kz}-VL
  ASMJIT_INST_3x(vpsravw, Vpsravw, Ymm, Ymm, Ymm)                      //      AVX512_BW{kz}-VL
  ASMJIT_INST_3x(vpsravw, Vpsravw, Ymm, Ymm, Mem)                      //      AVX512_BW{kz}-VL
  ASMJIT_INST_3x(vpsravw, Vpsravw, Zmm, Zmm, Zmm)                      //      AVX512_BW{kz}
  ASMJIT_INST_3x(vpsravw, Vpsravw, Zmm, Zmm, Mem)                      //      AVX512_BW{kz}
  ASMJIT_INST_3i(vpsraw, Vpsraw, Xmm, Xmm, Imm)                        // AVX  AVX512_BW{kz}-VL
  ASMJIT_INST_3x(vpsraw, Vpsraw, Xmm, Xmm, Xmm)                        // AVX  AVX512_BW{kz}-VL
  ASMJIT_INST_3x(vpsraw, Vpsraw, Xmm, Xmm, Mem)                        // AVX  AVX512_BW{kz}-VL
  ASMJIT_INST_3i(vpsraw, Vpsraw, Ymm, Ymm, Imm)                        // AVX2 AVX512_BW{kz}-VL
  ASMJIT_INST_3x(vpsraw, Vpsraw, Ymm, Ymm, Xmm)                        // AVX2 AVX512_BW{kz}-VL
  ASMJIT_INST_3x(vpsraw, Vpsraw, Ymm, Ymm, Mem)                        // AVX2 AVX512_BW{kz}-VL
  ASMJIT_INST_3i(vpsraw, Vpsraw, Xmm, Mem, Imm)                        //      AVX512_BW{kz}-VL
  ASMJIT_INST_3i(vpsraw, Vpsraw, Ymm, Mem, Imm)                        //      AVX512_BW{kz}-VL
  ASMJIT_INST_3x(vpsraw, Vpsraw, Zmm, Zmm, Xmm)                        //      AVX512_BW{kz}
  ASMJIT_INST_3x(vpsraw, Vpsraw, Zmm, Zmm, Mem)                        //      AVX512_BW{kz}
  ASMJIT_INST_3i(vpsraw, Vpsraw, Zmm, Zmm, Imm)                        //      AVX512_BW{kz}
  ASMJIT_INST_3i(vpsraw, Vpsraw, Zmm, Mem, Imm)                        //      AVX512_BW{kz}
  ASMJIT_INST_3i(vpsrld, Vpsrld, Xmm, Xmm, Imm)                        // AVX  AVX512_F{kz|b32}-VL
  ASMJIT_INST_3x(vpsrld, Vpsrld, Xmm, Xmm, Xmm)                        // AVX  AVX512_F{kz}-VL
  ASMJIT_INST_3x(vpsrld, Vpsrld, Xmm, Xmm, Mem)                        // AVX  AVX512_F{kz}-VL
  ASMJIT_INST_3i(vpsrld, Vpsrld, Ymm, Ymm, Imm)                        // AVX2 AVX512_F{kz|b32}-VL
  ASMJIT_INST_3x(vpsrld, Vpsrld, Ymm, Ymm, Xmm)                        // AVX2 AVX512_F{kz}-VL
  ASMJIT_INST_3x(vpsrld, Vpsrld, Ymm, Ymm, Mem)                        // AVX2 AVX512_F{kz}-VL
  ASMJIT_INST_3i(vpsrld, Vpsrld, Xmm, Mem, Imm)                        //      AVX512_F{kz|b32}-VL
  ASMJIT_INST_3i(vpsrld, Vpsrld, Ymm, Mem, Imm)                        //      AVX512_F{kz|b32}-VL
  ASMJIT_INST_3x(vpsrld, Vpsrld, Zmm, Zmm, Xmm)                        //      AVX512_F{kz}
  ASMJIT_INST_3x(vpsrld, Vpsrld, Zmm, Zmm, Mem)                        //      AVX512_F{kz}
  ASMJIT_INST_3i(vpsrld, Vpsrld, Zmm, Zmm, Imm)                        //      AVX512_F{kz|b32}
  ASMJIT_INST_3i(vpsrld, Vpsrld, Zmm, Mem, Imm)                        //      AVX512_F{kz|b32}
  ASMJIT_INST_3i(vpsrldq, Vpsrldq, Xmm, Xmm, Imm)                      // AVX  AVX512_BW-VL
  ASMJIT_INST_3i(vpsrldq, Vpsrldq, Ymm, Ymm, Imm)                      // AVX2 AVX512_BW-VL
  ASMJIT_INST_3i(vpsrldq, Vpsrldq, Xmm, Mem, Imm)                      //      AVX512_BW-VL
  ASMJIT_INST_3i(vpsrldq, Vpsrldq, Ymm, Mem, Imm)                      //      AVX512_BW-VL
  ASMJIT_INST_3i(vpsrldq, Vpsrldq, Zmm, Zmm, Imm)                      //      AVX512_BW
  ASMJIT_INST_3i(vpsrldq, Vpsrldq, Zmm, Mem, Imm)                      //      AVX512_BW
  ASMJIT_INST_3i(vpsrlq, Vpsrlq, Xmm, Xmm, Imm)                        // AVX  AVX512_F{kz|b64}-VL
  ASMJIT_INST_3x(vpsrlq, Vpsrlq, Xmm, Xmm, Xmm)                        // AVX  AVX512_F{kz}-VL
  ASMJIT_INST_3x(vpsrlq, Vpsrlq, Xmm, Xmm, Mem)                        // AVX  AVX512_F{kz}-VL
  ASMJIT_INST_3i(vpsrlq, Vpsrlq, Ymm, Ymm, Imm)                        // AVX2 AVX512_F{kz|b64}-VL
  ASMJIT_INST_3x(vpsrlq, Vpsrlq, Ymm, Ymm, Xmm)                        // AVX2 AVX512_F{kz}-VL
  ASMJIT_INST_3x(vpsrlq, Vpsrlq, Ymm, Ymm, Mem)                        // AVX2 AVX512_F{kz}-VL
  ASMJIT_INST_3i(vpsrlq, Vpsrlq, Xmm, Mem, Imm)                        //      AVX512_F{kz|b64}-VL
  ASMJIT_INST_3i(vpsrlq, Vpsrlq, Ymm, Mem, Imm)                        //      AVX512_F{kz|b64}-VL
  ASMJIT_INST_3x(vpsrlq, Vpsrlq, Zmm, Zmm, Xmm)                        //      AVX512_F{kz}
  ASMJIT_INST_3x(vpsrlq, Vpsrlq, Zmm, Zmm, Mem)                        //      AVX512_F{kz}
  ASMJIT_INST_3i(vpsrlq, Vpsrlq, Zmm, Zmm, Imm)                        //      AVX512_F{kz|b64}
  ASMJIT_INST_3i(vpsrlq, Vpsrlq, Zmm, Mem, Imm)                        //      AVX512_F{kz|b64}
  ASMJIT_INST_3x(vpsrlvd, Vpsrlvd, Xmm, Xmm, Xmm)                      // AVX2 AVX512_F{kz|b32}-VL
  ASMJIT_INST_3x(vpsrlvd, Vpsrlvd, Xmm, Xmm, Mem)                      // AVX2 AVX512_F{kz|b32}-VL
  ASMJIT_INST_3x(vpsrlvd, Vpsrlvd, Ymm, Ymm, Ymm)                      // AVX2 AVX512_F{kz|b32}-VL
  ASMJIT_INST_3x(vpsrlvd, Vpsrlvd, Ymm, Ymm, Mem)                      // AVX2 AVX512_F{kz|b32}-VL
  ASMJIT_INST_3x(vpsrlvd, Vpsrlvd, Zmm, Zmm, Zmm)                      //      AVX512_F{kz|b32}
  ASMJIT_INST_3x(vpsrlvd, Vpsrlvd, Zmm, Zmm, Mem)                      //      AVX512_F{kz|b32}
  ASMJIT_INST_3x(vpsrlvq, Vpsrlvq, Xmm, Xmm, Xmm)                      // AVX2 AVX512_F{kz|b64}-VL
  ASMJIT_INST_3x(vpsrlvq, Vpsrlvq, Xmm, Xmm, Mem)                      // AVX2 AVX512_F{kz|b64}-VL
  ASMJIT_INST_3x(vpsrlvq, Vpsrlvq, Ymm, Ymm, Ymm)                      // AVX2 AVX512_F{kz|b64}-VL
  ASMJIT_INST_3x(vpsrlvq, Vpsrlvq, Ymm, Ymm, Mem)                      // AVX2 AVX512_F{kz|b64}-VL
  ASMJIT_INST_3x(vpsrlvq, Vpsrlvq, Zmm, Zmm, Zmm)                      //      AVX512_F{kz|b64}
  ASMJIT_INST_3x(vpsrlvq, Vpsrlvq, Zmm, Zmm, Mem)                      //      AVX512_F{kz|b64}
  ASMJIT_INST_3x(vpsrlvw, Vpsrlvw, Xmm, Xmm, Xmm)                      //      AVX512_BW{kz}-VL
  ASMJIT_INST_3x(vpsrlvw, Vpsrlvw, Xmm, Xmm, Mem)                      //      AVX512_BW{kz}-VL
  ASMJIT_INST_3x(vpsrlvw, Vpsrlvw, Ymm, Ymm, Ymm)                      //      AVX512_BW{kz}-VL
  ASMJIT_INST_3x(vpsrlvw, Vpsrlvw, Ymm, Ymm, Mem)                      //      AVX512_BW{kz}-VL
  ASMJIT_INST_3x(vpsrlvw, Vpsrlvw, Zmm, Zmm, Zmm)                      //      AVX512_BW{kz}
  ASMJIT_INST_3x(vpsrlvw, Vpsrlvw, Zmm, Zmm, Mem)                      //      AVX512_BW{kz}
  ASMJIT_INST_3i(vpsrlw, Vpsrlw, Xmm, Xmm, Imm)                        // AVX  AVX512_BW{kz}-VL
  ASMJIT_INST_3x(vpsrlw, Vpsrlw, Xmm, Xmm, Xmm)                        // AVX  AVX512_BW{kz}-VL
  ASMJIT_INST_3x(vpsrlw, Vpsrlw, Xmm, Xmm, Mem)                        // AVX  AVX512_BW{kz}-VL
  ASMJIT_INST_3i(vpsrlw, Vpsrlw, Ymm, Ymm, Imm)                        // AVX2 AVX512_BW{kz}-VL
  ASMJIT_INST_3x(vpsrlw, Vpsrlw, Ymm, Ymm, Xmm)                        // AVX2 AVX512_BW{kz}-VL
  ASMJIT_INST_3x(vpsrlw, Vpsrlw, Ymm, Ymm, Mem)                        // AVX2 AVX512_BW{kz}-VL
  ASMJIT_INST_3i(vpsrlw, Vpsrlw, Xmm, Mem, Imm)                        //      AVX512_BW{kz}-VL
  ASMJIT_INST_3i(vpsrlw, Vpsrlw, Ymm, Mem, Imm)                        //      AVX512_BW{kz}-VL
  ASMJIT_INST_3x(vpsrlw, Vpsrlw, Zmm, Zmm, Xmm)                        //      AVX512_BW{kz}
  ASMJIT_INST_3x(vpsrlw, Vpsrlw, Zmm, Zmm, Mem)                        //      AVX512_BW{kz}
  ASMJIT_INST_3i(vpsrlw, Vpsrlw, Zmm, Zmm, Imm)                        //      AVX512_BW{kz}
  ASMJIT_INST_3i(vpsrlw, Vpsrlw, Zmm, Mem, Imm)                        //      AVX512_BW{kz}
  ASMJIT_INST_3x(vpsubb, Vpsubb, Xmm, Xmm, Xmm)                        // AVX  AVX512_BW{kz}-VL
  ASMJIT_INST_3x(vpsubb, Vpsubb, Xmm, Xmm, Mem)                        // AVX  AVX512_BW{kz}-VL
  ASMJIT_INST_3x(vpsubb, Vpsubb, Ymm, Ymm, Ymm)                        // AVX2 AVX512_BW{kz}-VL
  ASMJIT_INST_3x(vpsubb, Vpsubb, Ymm, Ymm, Mem)                        // AVX2 AVX512_BW{kz}-VL
  ASMJIT_INST_3x(vpsubb, Vpsubb, Zmm, Zmm, Zmm)                        //      AVX512_BW{kz}
  ASMJIT_INST_3x(vpsubb, Vpsubb, Zmm, Zmm, Mem)                        //      AVX512_BW{kz}
  ASMJIT_INST_3x(vpsubd, Vpsubd, Xmm, Xmm, Xmm)                        // AVX  AVX512_F{kz|b32}-VL
  ASMJIT_INST_3x(vpsubd, Vpsubd, Xmm, Xmm, Mem)                        // AVX  AVX512_F{kz|b32}-VL
  ASMJIT_INST_3x(vpsubd, Vpsubd, Ymm, Ymm, Ymm)                        // AVX2 AVX512_F{kz|b32}-VL
  ASMJIT_INST_3x(vpsubd, Vpsubd, Ymm, Ymm, Mem)                        // AVX2 AVX512_F{kz|b32}-VL
  ASMJIT_INST_3x(vpsubd, Vpsubd, Zmm, Zmm, Zmm)                        //      AVX512_F{kz|b32}
  ASMJIT_INST_3x(vpsubd, Vpsubd, Zmm, Zmm, Mem)                        //      AVX512_F{kz|b32}
  ASMJIT_INST_3x(vpsubq, Vpsubq, Xmm, Xmm, Xmm)                        // AVX  AVX512_F{kz|b64}-VL
  ASMJIT_INST_3x(vpsubq, Vpsubq, Xmm, Xmm, Mem)                        // AVX  AVX512_F{kz|b64}-VL
  ASMJIT_INST_3x(vpsubq, Vpsubq, Ymm, Ymm, Ymm)                        // AVX2 AVX512_F{kz|b64}-VL
  ASMJIT_INST_3x(vpsubq, Vpsubq, Ymm, Ymm, Mem)                        // AVX2 AVX512_F{kz|b64}-VL
  ASMJIT_INST_3x(vpsubq, Vpsubq, Zmm, Zmm, Zmm)                        //      AVX512_F{kz|b64}
  ASMJIT_INST_3x(vpsubq, Vpsubq, Zmm, Zmm, Mem)                        //      AVX512_F{kz|b64}
  ASMJIT_INST_3x(vpsubsb, Vpsubsb, Xmm, Xmm, Xmm)                      // AVX  AVX512_BW{kz}-VL
  ASMJIT_INST_3x(vpsubsb, Vpsubsb, Xmm, Xmm, Mem)                      // AVX  AVX512_BW{kz}-VL
  ASMJIT_INST_3x(vpsubsb, Vpsubsb, Ymm, Ymm, Ymm)                      // AVX2 AVX512_BW{kz}-VL
  ASMJIT_INST_3x(vpsubsb, Vpsubsb, Ymm, Ymm, Mem)                      // AVX2 AVX512_BW{kz}-VL
  ASMJIT_INST_3x(vpsubsb, Vpsubsb, Zmm, Zmm, Zmm)                      //      AVX512_BW{kz}
  ASMJIT_INST_3x(vpsubsb, Vpsubsb, Zmm, Zmm, Mem)                      //      AVX512_BW{kz}
  ASMJIT_INST_3x(vpsubsw, Vpsubsw, Xmm, Xmm, Xmm)                      // AVX  AVX512_BW{kz}-VL
  ASMJIT_INST_3x(vpsubsw, Vpsubsw, Xmm, Xmm, Mem)                      // AVX  AVX512_BW{kz}-VL
  ASMJIT_INST_3x(vpsubsw, Vpsubsw, Ymm, Ymm, Ymm)                      // AVX2 AVX512_BW{kz}-VL
  ASMJIT_INST_3x(vpsubsw, Vpsubsw, Ymm, Ymm, Mem)                      // AVX2 AVX512_BW{kz}-VL
  ASMJIT_INST_3x(vpsubsw, Vpsubsw, Zmm, Zmm, Zmm)                      //      AVX512_BW{kz}
  ASMJIT_INST_3x(vpsubsw, Vpsubsw, Zmm, Zmm, Mem)                      //      AVX512_BW{kz}
  ASMJIT_INST_3x(vpsubusb, Vpsubusb, Xmm, Xmm, Xmm)                    // AVX  AVX512_BW{kz}-VL
  ASMJIT_INST_3x(vpsubusb, Vpsubusb, Xmm, Xmm, Mem)                    // AVX  AVX512_BW{kz}-VL
  ASMJIT_INST_3x(vpsubusb, Vpsubusb, Ymm, Ymm, Ymm)                    // AVX2 AVX512_BW{kz}-VL
  ASMJIT_INST_3x(vpsubusb, Vpsubusb, Ymm, Ymm, Mem)                    // AVX2 AVX512_BW{kz}-VL
  ASMJIT_INST_3x(vpsubusb, Vpsubusb, Zmm, Zmm, Zmm)                    //      AVX512_BW{kz}
  ASMJIT_INST_3x(vpsubusb, Vpsubusb, Zmm, Zmm, Mem)                    //      AVX512_BW{kz}
  ASMJIT_INST_3x(vpsubusw, Vpsubusw, Xmm, Xmm, Xmm)                    // AVX  AVX512_BW{kz}-VL
  ASMJIT_INST_3x(vpsubusw, Vpsubusw, Xmm, Xmm, Mem)                    // AVX  AVX512_BW{kz}-VL
  ASMJIT_INST_3x(vpsubusw, Vpsubusw, Ymm, Ymm, Ymm)                    // AVX2 AVX512_BW{kz}-VL
  ASMJIT_INST_3x(vpsubusw, Vpsubusw, Ymm, Ymm, Mem)                    // AVX2 AVX512_BW{kz}-VL
  ASMJIT_INST_3x(vpsubusw, Vpsubusw, Zmm, Zmm, Zmm)                    //      AVX512_BW{kz}
  ASMJIT_INST_3x(vpsubusw, Vpsubusw, Zmm, Zmm, Mem)                    //      AVX512_BW{kz}
  ASMJIT_INST_3x(vpsubw, Vpsubw, Xmm, Xmm, Xmm)                        // AVX  AVX512_BW{kz}-VL
  ASMJIT_INST_3x(vpsubw, Vpsubw, Xmm, Xmm, Mem)                        // AVX  AVX512_BW{kz}-VL
  ASMJIT_INST_3x(vpsubw, Vpsubw, Ymm, Ymm, Ymm)                        // AVX2 AVX512_BW{kz}-VL
  ASMJIT_INST_3x(vpsubw, Vpsubw, Ymm, Ymm, Mem)                        // AVX2 AVX512_BW{kz}-VL
  ASMJIT_INST_3x(vpsubw, Vpsubw, Zmm, Zmm, Zmm)                        //      AVX512_BW{kz}
  ASMJIT_INST_3x(vpsubw, Vpsubw, Zmm, Zmm, Mem)                        //      AVX512_BW{kz}
  ASMJIT_INST_4i(vpternlogd, Vpternlogd, Xmm, Xmm, Xmm, Imm)           //      AVX512_F{kz|b32}-VL
  ASMJIT_INST_4i(vpternlogd, Vpternlogd, Xmm, Xmm, Mem, Imm)           //      AVX512_F{kz|b32}-VL
  ASMJIT_INST_4i(vpternlogd, Vpternlogd, Ymm, Ymm, Ymm, Imm)           //      AVX512_F{kz|b32}-VL
  ASMJIT_INST_4i(vpternlogd, Vpternlogd, Ymm, Ymm, Mem, Imm)           //      AVX512_F{kz|b32}-VL
  ASMJIT_INST_4i(vpternlogd, Vpternlogd, Zmm, Zmm, Zmm, Imm)           //      AVX512_F{kz|b32}
  ASMJIT_INST_4i(vpternlogd, Vpternlogd, Zmm, Zmm, Mem, Imm)           //      AVX512_F{kz|b32}
  ASMJIT_INST_4i(vpternlogq, Vpternlogq, Xmm, Xmm, Xmm, Imm)           //      AVX512_F{kz|b64}-VL
  ASMJIT_INST_4i(vpternlogq, Vpternlogq, Xmm, Xmm, Mem, Imm)           //      AVX512_F{kz|b64}-VL
  ASMJIT_INST_4i(vpternlogq, Vpternlogq, Ymm, Ymm, Ymm, Imm)           //      AVX512_F{kz|b64}-VL
  ASMJIT_INST_4i(vpternlogq, Vpternlogq, Ymm, Ymm, Mem, Imm)           //      AVX512_F{kz|b64}-VL
  ASMJIT_INST_4i(vpternlogq, Vpternlogq, Zmm, Zmm, Zmm, Imm)           //      AVX512_F{kz|b64}
  ASMJIT_INST_4i(vpternlogq, Vpternlogq, Zmm, Zmm, Mem, Imm)           //      AVX512_F{kz|b64}
  ASMJIT_INST_2x(vptest, Vptest, Xmm, Xmm)                             // AVX
  ASMJIT_INST_2x(vptest, Vptest, Xmm, Mem)                             // AVX
  ASMJIT_INST_2x(vptest, Vptest, Ymm, Ymm)                             // AVX
  ASMJIT_INST_2x(vptest, Vptest, Ymm, Mem)                             // AVX
  ASMJIT_INST_3x(vptestmb, Vptestmb, KReg, Xmm, Xmm)                   //      AVX512_BW{k}-VL
  ASMJIT_INST_3x(vptestmb, Vptestmb, KReg, Xmm, Mem)                   //      AVX512_BW{k}-VL
  ASMJIT_INST_3x(vptestmb, Vptestmb, KReg, Ymm, Ymm)                   //      AVX512_BW{k}-VL
  ASMJIT_INST_3x(vptestmb, Vptestmb, KReg, Ymm, Mem)                   //      AVX512_BW{k}-VL
  ASMJIT_INST_3x(vptestmb, Vptestmb, KReg, Zmm, Zmm)                   //      AVX512_BW{k}
  ASMJIT_INST_3x(vptestmb, Vptestmb, KReg, Zmm, Mem)                   //      AVX512_BW{k}
  ASMJIT_INST_3x(vptestmd, Vptestmd, KReg, Xmm, Xmm)                   //      AVX512_F{k|b32}-VL
  ASMJIT_INST_3x(vptestmd, Vptestmd, KReg, Xmm, Mem)                   //      AVX512_F{k|b32}-VL
  ASMJIT_INST_3x(vptestmd, Vptestmd, KReg, Ymm, Ymm)                   //      AVX512_F{k|b32}-VL
  ASMJIT_INST_3x(vptestmd, Vptestmd, KReg, Ymm, Mem)                   //      AVX512_F{k|b32}-VL
  ASMJIT_INST_3x(vptestmd, Vptestmd, KReg, Zmm, Zmm)                   //      AVX512_F{k|b32}
  ASMJIT_INST_3x(vptestmd, Vptestmd, KReg, Zmm, Mem)                   //      AVX512_F{k|b32}
  ASMJIT_INST_3x(vptestmq, Vptestmq, KReg, Xmm, Xmm)                   //      AVX512_F{k|b64}-VL
  ASMJIT_INST_3x(vptestmq, Vptestmq, KReg, Xmm, Mem)                   //      AVX512_F{k|b64}-VL
  ASMJIT_INST_3x(vptestmq, Vptestmq, KReg, Ymm, Ymm)                   //      AVX512_F{k|b64}-VL
  ASMJIT_INST_3x(vptestmq, Vptestmq, KReg, Ymm, Mem)                   //      AVX512_F{k|b64}-VL
  ASMJIT_INST_3x(vptestmq, Vptestmq, KReg, Zmm, Zmm)                   //      AVX512_F{k|b64}
  ASMJIT_INST_3x(vptestmq, Vptestmq, KReg, Zmm, Mem)                   //      AVX512_F{k|b64}
  ASMJIT_INST_3x(vptestmw, Vptestmw, KReg, Xmm, Xmm)                   //      AVX512_BW{k}-VL
  ASMJIT_INST_3x(vptestmw, Vptestmw, KReg, Xmm, Mem)                   //      AVX512_BW{k}-VL
  ASMJIT_INST_3x(vptestmw, Vptestmw, KReg, Ymm, Ymm)                   //      AVX512_BW{k}-VL
  ASMJIT_INST_3x(vptestmw, Vptestmw, KReg, Ymm, Mem)                   //      AVX512_BW{k}-VL
  ASMJIT_INST_3x(vptestmw, Vptestmw, KReg, Zmm, Zmm)                   //      AVX512_BW{k}
  ASMJIT_INST_3x(vptestmw, Vptestmw, KReg, Zmm, Mem)                   //      AVX512_BW{k}
  ASMJIT_INST_3x(vptestnmb, Vptestnmb, KReg, Xmm, Xmm)                 //      AVX512_BW{k}-VL
  ASMJIT_INST_3x(vptestnmb, Vptestnmb, KReg, Xmm, Mem)                 //      AVX512_BW{k}-VL
  ASMJIT_INST_3x(vptestnmb, Vptestnmb, KReg, Ymm, Ymm)                 //      AVX512_BW{k}-VL
  ASMJIT_INST_3x(vptestnmb, Vptestnmb, KReg, Ymm, Mem)                 //      AVX512_BW{k}-VL
  ASMJIT_INST_3x(vptestnmb, Vptestnmb, KReg, Zmm, Zmm)                 //      AVX512_BW{k}
  ASMJIT_INST_3x(vptestnmb, Vptestnmb, KReg, Zmm, Mem)                 //      AVX512_BW{k}
  ASMJIT_INST_3x(vptestnmd, Vptestnmd, KReg, Xmm, Xmm)                 //      AVX512_F{k|b32}-VL
  ASMJIT_INST_3x(vptestnmd, Vptestnmd, KReg, Xmm, Mem)                 //      AVX512_F{k|b32}-VL
  ASMJIT_INST_3x(vptestnmd, Vptestnmd, KReg, Ymm, Ymm)                 //      AVX512_F{k|b32}-VL
  ASMJIT_INST_3x(vptestnmd, Vptestnmd, KReg, Ymm, Mem)                 //      AVX512_F{k|b32}-VL
  ASMJIT_INST_3x(vptestnmd, Vptestnmd, KReg, Zmm, Zmm)                 //      AVX512_F{k|b32}
  ASMJIT_INST_3x(vptestnmd, Vptestnmd, KReg, Zmm, Mem)                 //      AVX512_F{k|b32}
  ASMJIT_INST_3x(vptestnmq, Vptestnmq, KReg, Xmm, Xmm)                 //      AVX512_F{k|b64}-VL
  ASMJIT_INST_3x(vptestnmq, Vptestnmq, KReg, Xmm, Mem)                 //      AVX512_F{k|b64}-VL
  ASMJIT_INST_3x(vptestnmq, Vptestnmq, KReg, Ymm, Ymm)                 //      AVX512_F{k|b64}-VL
  ASMJIT_INST_3x(vptestnmq, Vptestnmq, KReg, Ymm, Mem)                 //      AVX512_F{k|b64}-VL
  ASMJIT_INST_3x(vptestnmq, Vptestnmq, KReg, Zmm, Zmm)                 //      AVX512_F{k|b64}
  ASMJIT_INST_3x(vptestnmq, Vptestnmq, KReg, Zmm, Mem)                 //      AVX512_F{k|b64}
  ASMJIT_INST_3x(vptestnmw, Vptestnmw, KReg, Xmm, Xmm)                 //      AVX512_BW{k}-VL
  ASMJIT_INST_3x(vptestnmw, Vptestnmw, KReg, Xmm, Mem)                 //      AVX512_BW{k}-VL
  ASMJIT_INST_3x(vptestnmw, Vptestnmw, KReg, Ymm, Ymm)                 //      AVX512_BW{k}-VL
  ASMJIT_INST_3x(vptestnmw, Vptestnmw, KReg, Ymm, Mem)                 //      AVX512_BW{k}-VL
  ASMJIT_INST_3x(vptestnmw, Vptestnmw, KReg, Zmm, Zmm)                 //      AVX512_BW{k}
  ASMJIT_INST_3x(vptestnmw, Vptestnmw, KReg, Zmm, Mem)                 //      AVX512_BW{k}
  ASMJIT_INST_3x(vpunpckhbw, Vpunpckhbw, Xmm, Xmm, Xmm)                // AVX  AVX512_BW{kz}-VL
  ASMJIT_INST_3x(vpunpckhbw, Vpunpckhbw, Xmm, Xmm, Mem)                // AVX  AVX512_BW{kz}-VL
  ASMJIT_INST_3x(vpunpckhbw, Vpunpckhbw, Ymm, Ymm, Ymm)                // AVX2 AVX512_BW{kz}-VL
  ASMJIT_INST_3x(vpunpckhbw, Vpunpckhbw, Ymm, Ymm, Mem)                // AVX2 AVX512_BW{kz}-VL
  ASMJIT_INST_3x(vpunpckhbw, Vpunpckhbw, Zmm, Zmm, Zmm)                //      AVX512_BW{kz}
  ASMJIT_INST_3x(vpunpckhbw, Vpunpckhbw, Zmm, Zmm, Mem)                //      AVX512_BW{kz}
  ASMJIT_INST_3x(vpunpckhdq, Vpunpckhdq, Xmm, Xmm, Xmm)                // AVX  AVX512_F{kz|b32}-VL
  ASMJIT_INST_3x(vpunpckhdq, Vpunpckhdq, Xmm, Xmm, Mem)                // AVX  AVX512_F{kz|b32}-VL
  ASMJIT_INST_3x(vpunpckhdq, Vpunpckhdq, Ymm, Ymm, Ymm)                // AVX2 AVX512_F{kz|b32}-VL
  ASMJIT_INST_3x(vpunpckhdq, Vpunpckhdq, Ymm, Ymm, Mem)                // AVX2 AVX512_F{kz|b32}-VL
  ASMJIT_INST_3x(vpunpckhdq, Vpunpckhdq, Zmm, Zmm, Zmm)                //      AVX512_F{kz|b32}
  ASMJIT_INST_3x(vpunpckhdq, Vpunpckhdq, Zmm, Zmm, Mem)                //      AVX512_F{kz|b32}
  ASMJIT_INST_3x(vpunpckhqdq, Vpunpckhqdq, Xmm, Xmm, Xmm)              // AVX  AVX512_F{kz|b64}-VL
  ASMJIT_INST_3x(vpunpckhqdq, Vpunpckhqdq, Xmm, Xmm, Mem)              // AVX  AVX512_F{kz|b64}-VL
  ASMJIT_INST_3x(vpunpckhqdq, Vpunpckhqdq, Ymm, Ymm, Ymm)              // AVX2 AVX512_F{kz|b64}-VL
  ASMJIT_INST_3x(vpunpckhqdq, Vpunpckhqdq, Ymm, Ymm, Mem)              // AVX2 AVX512_F{kz|b64}-VL
  ASMJIT_INST_3x(vpunpckhqdq, Vpunpckhqdq, Zmm, Zmm, Zmm)              //      AVX512_F{kz|b64}
  ASMJIT_INST_3x(vpunpckhqdq, Vpunpckhqdq, Zmm, Zmm, Mem)              //      AVX512_F{kz|b64}
  ASMJIT_INST_3x(vpunpckhwd, Vpunpckhwd, Xmm, Xmm, Xmm)                // AVX  AVX512_BW{kz}-VL
  ASMJIT_INST_3x(vpunpckhwd, Vpunpckhwd, Xmm, Xmm, Mem)                // AVX  AVX512_BW{kz}-VL
  ASMJIT_INST_3x(vpunpckhwd, Vpunpckhwd, Ymm, Ymm, Ymm)                // AVX2 AVX512_BW{kz}-VL
  ASMJIT_INST_3x(vpunpckhwd, Vpunpckhwd, Ymm, Ymm, Mem)                // AVX2 AVX512_BW{kz}-VL
  ASMJIT_INST_3x(vpunpckhwd, Vpunpckhwd, Zmm, Zmm, Zmm)                //      AVX512_BW{kz}
  ASMJIT_INST_3x(vpunpckhwd, Vpunpckhwd, Zmm, Zmm, Mem)                //      AVX512_BW{kz}
  ASMJIT_INST_3x(vpunpcklbw, Vpunpcklbw, Xmm, Xmm, Xmm)                // AVX  AVX512_BW{kz}-VL
  ASMJIT_INST_3x(vpunpcklbw, Vpunpcklbw, Xmm, Xmm, Mem)                // AVX  AVX512_BW{kz}-VL
  ASMJIT_INST_3x(vpunpcklbw, Vpunpcklbw, Ymm, Ymm, Ymm)                // AVX2 AVX512_BW{kz}-VL
  ASMJIT_INST_3x(vpunpcklbw, Vpunpcklbw, Ymm, Ymm, Mem)                // AVX2 AVX512_BW{kz}-VL
  ASMJIT_INST_3x(vpunpcklbw, Vpunpcklbw, Zmm, Zmm, Zmm)                //      AVX512_BW{kz}
  ASMJIT_INST_3x(vpunpcklbw, Vpunpcklbw, Zmm, Zmm, Mem)                //      AVX512_BW{kz}
  ASMJIT_INST_3x(vpunpckldq, Vpunpckldq, Xmm, Xmm, Xmm)                // AVX  AVX512_F{kz|b32}-VL
  ASMJIT_INST_3x(vpunpckldq, Vpunpckldq, Xmm, Xmm, Mem)                // AVX  AVX512_F{kz|b32}-VL
  ASMJIT_INST_3x(vpunpckldq, Vpunpckldq, Ymm, Ymm, Ymm)                // AVX2 AVX512_F{kz|b32}-VL
  ASMJIT_INST_3x(vpunpckldq, Vpunpckldq, Ymm, Ymm, Mem)                // AVX2 AVX512_F{kz|b32}-VL
  ASMJIT_INST_3x(vpunpckldq, Vpunpckldq, Zmm, Zmm, Zmm)                //      AVX512_F{kz|b32}
  ASMJIT_INST_3x(vpunpckldq, Vpunpckldq, Zmm, Zmm, Mem)                //      AVX512_F{kz|b32}
  ASMJIT_INST_3x(vpunpcklqdq, Vpunpcklqdq, Xmm, Xmm, Xmm)              // AVX  AVX512_F{kz|b64}-VL
  ASMJIT_INST_3x(vpunpcklqdq, Vpunpcklqdq, Xmm, Xmm, Mem)              // AVX  AVX512_F{kz|b64}-VL
  ASMJIT_INST_3x(vpunpcklqdq, Vpunpcklqdq, Ymm, Ymm, Ymm)              // AVX2 AVX512_F{kz|b64}-VL
  ASMJIT_INST_3x(vpunpcklqdq, Vpunpcklqdq, Ymm, Ymm, Mem)              // AVX2 AVX512_F{kz|b64}-VL
  ASMJIT_INST_3x(vpunpcklqdq, Vpunpcklqdq, Zmm, Zmm, Zmm)              //      AVX512_F{kz|b64}
  ASMJIT_INST_3x(vpunpcklqdq, Vpunpcklqdq, Zmm, Zmm, Mem)              //      AVX512_F{kz|b64}
  ASMJIT_INST_3x(vpunpcklwd, Vpunpcklwd, Xmm, Xmm, Xmm)                // AVX  AVX512_BW{kz}-VL
  ASMJIT_INST_3x(vpunpcklwd, Vpunpcklwd, Xmm, Xmm, Mem)                // AVX  AVX512_BW{kz}-VL
  ASMJIT_INST_3x(vpunpcklwd, Vpunpcklwd, Ymm, Ymm, Ymm)                // AVX2 AVX512_BW{kz}-VL
  ASMJIT_INST_3x(vpunpcklwd, Vpunpcklwd, Ymm, Ymm, Mem)                // AVX2 AVX512_BW{kz}-VL
  ASMJIT_INST_3x(vpunpcklwd, Vpunpcklwd, Zmm, Zmm, Zmm)                //      AVX512_BW{kz}
  ASMJIT_INST_3x(vpunpcklwd, Vpunpcklwd, Zmm, Zmm, Mem)                //      AVX512_BW{kz}
  ASMJIT_INST_3x(vpxor, Vpxor, Xmm, Xmm, Xmm)                          // AVX
  ASMJIT_INST_3x(vpxor, Vpxor, Xmm, Xmm, Mem)                          // AVX
  ASMJIT_INST_3x(vpxor, Vpxor, Ymm, Ymm, Ymm)                          // AVX2
  ASMJIT_INST_3x(vpxor, Vpxor, Ymm, Ymm, Mem)                          // AVX2
  ASMJIT_INST_3x(vpxord, Vpxord, Xmm, Xmm, Xmm)                        //      AVX512_F{kz|b32}-VL
  ASMJIT_INST_3x(vpxord, Vpxord, Xmm, Xmm, Mem)                        //      AVX512_F{kz|b32}-VL
  ASMJIT_INST_3x(vpxord, Vpxord, Ymm, Ymm, Ymm)                        //      AVX512_F{kz|b32}-VL
  ASMJIT_INST_3x(vpxord, Vpxord, Ymm, Ymm, Mem)                        //      AVX512_F{kz|b32}-VL
  ASMJIT_INST_3x(vpxord, Vpxord, Zmm, Zmm, Zmm)                        //      AVX512_F{kz|b32}
  ASMJIT_INST_3x(vpxord, Vpxord, Zmm, Zmm, Mem)                        //      AVX512_F{kz|b32}
  ASMJIT_INST_3x(vpxorq, Vpxorq, Xmm, Xmm, Xmm)                        //      AVX512_F{kz|b64}-VL
  ASMJIT_INST_3x(vpxorq, Vpxorq, Xmm, Xmm, Mem)                        //      AVX512_F{kz|b64}-VL
  ASMJIT_INST_3x(vpxorq, Vpxorq, Ymm, Ymm, Ymm)                        //      AVX512_F{kz|b64}-VL
  ASMJIT_INST_3x(vpxorq, Vpxorq, Ymm, Ymm, Mem)                        //      AVX512_F{kz|b64}-VL
  ASMJIT_INST_3x(vpxorq, Vpxorq, Zmm, Zmm, Zmm)                        //      AVX512_F{kz|b64}
  ASMJIT_INST_3x(vpxorq, Vpxorq, Zmm, Zmm, Mem)                        //      AVX512_F{kz|b64}
  ASMJIT_INST_4i(vrangepd, Vrangepd, Xmm, Xmm, Xmm, Imm)               //      AVX512_DQ{kz|b64}-VL
  ASMJIT_INST_4i(vrangepd, Vrangepd, Xmm, Xmm, Mem, Imm)               //      AVX512_DQ{kz|b64}-VL
  ASMJIT_INST_4i(vrangepd, Vrangepd, Ymm, Ymm, Ymm, Imm)               //      AVX512_DQ{kz|b64}-VL
  ASMJIT_INST_4i(vrangepd, Vrangepd, Ymm, Ymm, Mem, Imm)               //      AVX512_DQ{kz|b64}-VL
  ASMJIT_INST_4i(vrangepd, Vrangepd, Zmm, Zmm, Zmm, Imm)               //      AVX512_DQ{kz|sae|b64}
  ASMJIT_INST_4i(vrangepd, Vrangepd, Zmm, Zmm, Mem, Imm)               //      AVX512_DQ{kz|sae|b64}
  ASMJIT_INST_4i(vrangeps, Vrangeps, Xmm, Xmm, Xmm, Imm)               //      AVX512_DQ{kz|b32}-VL
  ASMJIT_INST_4i(vrangeps, Vrangeps, Xmm, Xmm, Mem, Imm)               //      AVX512_DQ{kz|b32}-VL
  ASMJIT_INST_4i(vrangeps, Vrangeps, Ymm, Ymm, Ymm, Imm)               //      AVX512_DQ{kz|b32}-VL
  ASMJIT_INST_4i(vrangeps, Vrangeps, Ymm, Ymm, Mem, Imm)               //      AVX512_DQ{kz|b32}-VL
  ASMJIT_INST_4i(vrangeps, Vrangeps, Zmm, Zmm, Zmm, Imm)               //      AVX512_DQ{kz|sae|b32}
  ASMJIT_INST_4i(vrangeps, Vrangeps, Zmm, Zmm, Mem, Imm)               //      AVX512_DQ{kz|sae|b32}
  ASMJIT_INST_4i(vrangesd, Vrangesd, Xmm, Xmm, Xmm, Imm)               //      AVX512_DQ{kz|sae}
  ASMJIT_INST_4i(vrangesd, Vrangesd, Xmm, Xmm, Mem, Imm)               //      AVX512_DQ{kz|sae}
  ASMJIT_INST_4i(vrangess, Vrangess, Xmm, Xmm, Xmm, Imm)               //      AVX512_DQ{kz|sae}
  ASMJIT_INST_4i(vrangess, Vrangess, Xmm, Xmm, Mem, Imm)               //      AVX512_DQ{kz|sae}
  ASMJIT_INST_2x(vrcp14pd, Vrcp14pd, Xmm, Xmm)                         //      AVX512_F{kz|b64}-VL
  ASMJIT_INST_2x(vrcp14pd, Vrcp14pd, Xmm, Mem)                         //      AVX512_F{kz|b64}-VL
  ASMJIT_INST_2x(vrcp14pd, Vrcp14pd, Ymm, Ymm)                         //      AVX512_F{kz|b64}-VL
  ASMJIT_INST_2x(vrcp14pd, Vrcp14pd, Ymm, Mem)                         //      AVX512_F{kz|b64}-VL
  ASMJIT_INST_2x(vrcp14pd, Vrcp14pd, Zmm, Zmm)                         //      AVX512_F{kz|b64}
  ASMJIT_INST_2x(vrcp14pd, Vrcp14pd, Zmm, Mem)                         //      AVX512_F{kz|b64}
  ASMJIT_INST_2x(vrcp14ps, Vrcp14ps, Xmm, Xmm)                         //      AVX512_F{kz|b32}-VL
  ASMJIT_INST_2x(vrcp14ps, Vrcp14ps, Xmm, Mem)                         //      AVX512_F{kz|b32}-VL
  ASMJIT_INST_2x(vrcp14ps, Vrcp14ps, Ymm, Ymm)                         //      AVX512_F{kz|b32}-VL
  ASMJIT_INST_2x(vrcp14ps, Vrcp14ps, Ymm, Mem)                         //      AVX512_F{kz|b32}-VL
  ASMJIT_INST_2x(vrcp14ps, Vrcp14ps, Zmm, Zmm)                         //      AVX512_F{kz|b32}
  ASMJIT_INST_2x(vrcp14ps, Vrcp14ps, Zmm, Mem)                         //      AVX512_F{kz|b32}
  ASMJIT_INST_3x(vrcp14sd, Vrcp14sd, Xmm, Xmm, Xmm)                    //      AVX512_F{kz}
  ASMJIT_INST_3x(vrcp14sd, Vrcp14sd, Xmm, Xmm, Mem)                    //      AVX512_F{kz}
  ASMJIT_INST_3x(vrcp14ss, Vrcp14ss, Xmm, Xmm, Xmm)                    //      AVX512_F{kz}
  ASMJIT_INST_3x(vrcp14ss, Vrcp14ss, Xmm, Xmm, Mem)                    //      AVX512_F{kz}
  ASMJIT_INST_2x(vrcp28pd, Vrcp28pd, Zmm, Zmm)                         //      AVX512_ER{kz|sae|b64}
  ASMJIT_INST_2x(vrcp28pd, Vrcp28pd, Zmm, Mem)                         //      AVX512_ER{kz|sae|b64}
  ASMJIT_INST_2x(vrcp28ps, Vrcp28ps, Zmm, Zmm)                         //      AVX512_ER{kz|sae|b32}
  ASMJIT_INST_2x(vrcp28ps, Vrcp28ps, Zmm, Mem)                         //      AVX512_ER{kz|sae|b32}
  ASMJIT_INST_3x(vrcp28sd, Vrcp28sd, Xmm, Xmm, Xmm)                    //      AVX512_ER{kz|sae}
  ASMJIT_INST_3x(vrcp28sd, Vrcp28sd, Xmm, Xmm, Mem)                    //      AVX512_ER{kz|sae}
  ASMJIT_INST_3x(vrcp28ss, Vrcp28ss, Xmm, Xmm, Xmm)                    //      AVX512_ER{kz|sae}
  ASMJIT_INST_3x(vrcp28ss, Vrcp28ss, Xmm, Xmm, Mem)                    //      AVX512_ER{kz|sae}
  ASMJIT_INST_2x(vrcpps, Vrcpps, Xmm, Xmm)                             // AVX
  ASMJIT_INST_2x(vrcpps, Vrcpps, Xmm, Mem)                             // AVX
  ASMJIT_INST_2x(vrcpps, Vrcpps, Ymm, Ymm)                             // AVX
  ASMJIT_INST_2x(vrcpps, Vrcpps, Ymm, Mem)                             // AVX
  ASMJIT_INST_3x(vrcpss, Vrcpss, Xmm, Xmm, Xmm)                        // AVX
  ASMJIT_INST_3x(vrcpss, Vrcpss, Xmm, Xmm, Mem)                        // AVX
  ASMJIT_INST_3i(vreducepd, Vreducepd, Xmm, Xmm, Imm)                  //      AVX512_DQ{kz|b64}-VL
  ASMJIT_INST_3i(vreducepd, Vreducepd, Xmm, Mem, Imm)                  //      AVX512_DQ{kz|b64}-VL
  ASMJIT_INST_3i(vreducepd, Vreducepd, Ymm, Ymm, Imm)                  //      AVX512_DQ{kz|b64}-VL
  ASMJIT_INST_3i(vreducepd, Vreducepd, Ymm, Mem, Imm)                  //      AVX512_DQ{kz|b64}-VL
  ASMJIT_INST_3i(vreducepd, Vreducepd, Zmm, Zmm, Imm)                  //      AVX512_DQ{kz|b64}
  ASMJIT_INST_3i(vreducepd, Vreducepd, Zmm, Mem, Imm)                  //      AVX512_DQ{kz|b64}
  ASMJIT_INST_3i(vreduceps, Vreduceps, Xmm, Xmm, Imm)                  //      AVX512_DQ{kz|b32}-VL
  ASMJIT_INST_3i(vreduceps, Vreduceps, Xmm, Mem, Imm)                  //      AVX512_DQ{kz|b32}-VL
  ASMJIT_INST_3i(vreduceps, Vreduceps, Ymm, Ymm, Imm)                  //      AVX512_DQ{kz|b32}-VL
  ASMJIT_INST_3i(vreduceps, Vreduceps, Ymm, Mem, Imm)                  //      AVX512_DQ{kz|b32}-VL
  ASMJIT_INST_3i(vreduceps, Vreduceps, Zmm, Zmm, Imm)                  //      AVX512_DQ{kz|b32}
  ASMJIT_INST_3i(vreduceps, Vreduceps, Zmm, Mem, Imm)                  //      AVX512_DQ{kz|b32}
  ASMJIT_INST_4i(vreducesd, Vreducesd, Xmm, Xmm, Xmm, Imm)             //      AVX512_DQ{kz}
  ASMJIT_INST_4i(vreducesd, Vreducesd, Xmm, Xmm, Mem, Imm)             //      AVX512_DQ{kz}
  ASMJIT_INST_4i(vreducess, Vreducess, Xmm, Xmm, Xmm, Imm)             //      AVX512_DQ{kz}
  ASMJIT_INST_4i(vreducess, Vreducess, Xmm, Xmm, Mem, Imm)             //      AVX512_DQ{kz}
  ASMJIT_INST_3i(vrndscalepd, Vrndscalepd, Xmm, Xmm, Imm)              //      AVX512_F{kz|b64}-VL
  ASMJIT_INST_3i(vrndscalepd, Vrndscalepd, Xmm, Mem, Imm)              //      AVX512_F{kz|b64}-VL
  ASMJIT_INST_3i(vrndscalepd, Vrndscalepd, Ymm, Ymm, Imm)              //      AVX512_F{kz|b64}-VL
  ASMJIT_INST_3i(vrndscalepd, Vrndscalepd, Ymm, Mem, Imm)              //      AVX512_F{kz|b64}-VL
  ASMJIT_INST_3i(vrndscalepd, Vrndscalepd, Zmm, Zmm, Imm)              //      AVX512_F{kz|sae|b64}
  ASMJIT_INST_3i(vrndscalepd, Vrndscalepd, Zmm, Mem, Imm)              //      AVX512_F{kz|sae|b64}
  ASMJIT_INST_3i(vrndscaleps, Vrndscaleps, Xmm, Xmm, Imm)              //      AVX512_F{kz|b32}-VL
  ASMJIT_INST_3i(vrndscaleps, Vrndscaleps, Xmm, Mem, Imm)              //      AVX512_F{kz|b32}-VL
  ASMJIT_INST_3i(vrndscaleps, Vrndscaleps, Ymm, Ymm, Imm)              //      AVX512_F{kz|b32}-VL
  ASMJIT_INST_3i(vrndscaleps, Vrndscaleps, Ymm, Mem, Imm)              //      AVX512_F{kz|b32}-VL
  ASMJIT_INST_3i(vrndscaleps, Vrndscaleps, Zmm, Zmm, Imm)              //      AVX512_F{kz|sae|b32}
  ASMJIT_INST_3i(vrndscaleps, Vrndscaleps, Zmm, Mem, Imm)              //      AVX512_F{kz|sae|b32}
  ASMJIT_INST_4i(vrndscalesd, Vrndscalesd, Xmm, Xmm, Xmm, Imm)         //      AVX512_F{kz|sae}
  ASMJIT_INST_4i(vrndscalesd, Vrndscalesd, Xmm, Xmm, Mem, Imm)         //      AVX512_F{kz|sae}
  ASMJIT_INST_4i(vrndscaless, Vrndscaless, Xmm, Xmm, Xmm, Imm)         //      AVX512_F{kz|sae}
  ASMJIT_INST_4i(vrndscaless, Vrndscaless, Xmm, Xmm, Mem, Imm)         //      AVX512_F{kz|sae}
  ASMJIT_INST_3i(vroundpd, Vroundpd, Xmm, Xmm, Imm)                    // AVX
  ASMJIT_INST_3i(vroundpd, Vroundpd, Xmm, Mem, Imm)                    // AVX
  ASMJIT_INST_3i(vroundpd, Vroundpd, Ymm, Ymm, Imm)                    // AVX
  ASMJIT_INST_3i(vroundpd, Vroundpd, Ymm, Mem, Imm)                    // AVX
  ASMJIT_INST_3i(vroundps, Vroundps, Xmm, Xmm, Imm)                    // AVX
  ASMJIT_INST_3i(vroundps, Vroundps, Xmm, Mem, Imm)                    // AVX
  ASMJIT_INST_3i(vroundps, Vroundps, Ymm, Ymm, Imm)                    // AVX
  ASMJIT_INST_3i(vroundps, Vroundps, Ymm, Mem, Imm)                    // AVX
  ASMJIT_INST_4i(vroundsd, Vroundsd, Xmm, Xmm, Xmm, Imm)               // AVX
  ASMJIT_INST_4i(vroundsd, Vroundsd, Xmm, Xmm, Mem, Imm)               // AVX
  ASMJIT_INST_4i(vroundss, Vroundss, Xmm, Xmm, Xmm, Imm)               // AVX
  ASMJIT_INST_4i(vroundss, Vroundss, Xmm, Xmm, Mem, Imm)               // AVX
  ASMJIT_INST_2x(vrsqrt14pd, Vrsqrt14pd, Xmm, Xmm)                     //      AVX512_F{kz|b64}-VL
  ASMJIT_INST_2x(vrsqrt14pd, Vrsqrt14pd, Xmm, Mem)                     //      AVX512_F{kz|b64}-VL
  ASMJIT_INST_2x(vrsqrt14pd, Vrsqrt14pd, Ymm, Ymm)                     //      AVX512_F{kz|b64}-VL
  ASMJIT_INST_2x(vrsqrt14pd, Vrsqrt14pd, Ymm, Mem)                     //      AVX512_F{kz|b64}-VL
  ASMJIT_INST_2x(vrsqrt14pd, Vrsqrt14pd, Zmm, Zmm)                     //      AVX512_F{kz|b64}
  ASMJIT_INST_2x(vrsqrt14pd, Vrsqrt14pd, Zmm, Mem)                     //      AVX512_F{kz|b64}
  ASMJIT_INST_2x(vrsqrt14ps, Vrsqrt14ps, Xmm, Xmm)                     //      AVX512_F{kz|b32}-VL
  ASMJIT_INST_2x(vrsqrt14ps, Vrsqrt14ps, Xmm, Mem)                     //      AVX512_F{kz|b32}-VL
  ASMJIT_INST_2x(vrsqrt14ps, Vrsqrt14ps, Ymm, Ymm)                     //      AVX512_F{kz|b32}-VL
  ASMJIT_INST_2x(vrsqrt14ps, Vrsqrt14ps, Ymm, Mem)                     //      AVX512_F{kz|b32}-VL
  ASMJIT_INST_2x(vrsqrt14ps, Vrsqrt14ps, Zmm, Zmm)                     //      AVX512_F{kz|b32}
  ASMJIT_INST_2x(vrsqrt14ps, Vrsqrt14ps, Zmm, Mem)                     //      AVX512_F{kz|b32}
  ASMJIT_INST_3x(vrsqrt14sd, Vrsqrt14sd, Xmm, Xmm, Xmm)                //      AVX512_F{kz}
  ASMJIT_INST_3x(vrsqrt14sd, Vrsqrt14sd, Xmm, Xmm, Mem)                //      AVX512_F{kz}
  ASMJIT_INST_3x(vrsqrt14ss, Vrsqrt14ss, Xmm, Xmm, Xmm)                //      AVX512_F{kz}
  ASMJIT_INST_3x(vrsqrt14ss, Vrsqrt14ss, Xmm, Xmm, Mem)                //      AVX512_F{kz}
  ASMJIT_INST_2x(vrsqrt28pd, Vrsqrt28pd, Zmm, Zmm)                     //      AVX512_ER{kz|sae|b64}
  ASMJIT_INST_2x(vrsqrt28pd, Vrsqrt28pd, Zmm, Mem)                     //      AVX512_ER{kz|sae|b64}
  ASMJIT_INST_2x(vrsqrt28ps, Vrsqrt28ps, Zmm, Zmm)                     //      AVX512_ER{kz|sae|b32}
  ASMJIT_INST_2x(vrsqrt28ps, Vrsqrt28ps, Zmm, Mem)                     //      AVX512_ER{kz|sae|b32}
  ASMJIT_INST_3x(vrsqrt28sd, Vrsqrt28sd, Xmm, Xmm, Xmm)                //      AVX512_ER{kz|sae}
  ASMJIT_INST_3x(vrsqrt28sd, Vrsqrt28sd, Xmm, Xmm, Mem)                //      AVX512_ER{kz|sae}
  ASMJIT_INST_3x(vrsqrt28ss, Vrsqrt28ss, Xmm, Xmm, Xmm)                //      AVX512_ER{kz|sae}
  ASMJIT_INST_3x(vrsqrt28ss, Vrsqrt28ss, Xmm, Xmm, Mem)                //      AVX512_ER{kz|sae}
  ASMJIT_INST_2x(vrsqrtps, Vrsqrtps, Xmm, Xmm)                         // AVX
  ASMJIT_INST_2x(vrsqrtps, Vrsqrtps, Xmm, Mem)                         // AVX
  ASMJIT_INST_2x(vrsqrtps, Vrsqrtps, Ymm, Ymm)                         // AVX
  ASMJIT_INST_2x(vrsqrtps, Vrsqrtps, Ymm, Mem)                         // AVX
  ASMJIT_INST_3x(vrsqrtss, Vrsqrtss, Xmm, Xmm, Xmm)                    // AVX
  ASMJIT_INST_3x(vrsqrtss, Vrsqrtss, Xmm, Xmm, Mem)                    // AVX
  ASMJIT_INST_3x(vscalefpd, Vscalefpd, Xmm, Xmm, Xmm)                  //      AVX512_F{kz|b64}-VL
  ASMJIT_INST_3x(vscalefpd, Vscalefpd, Xmm, Xmm, Mem)                  //      AVX512_F{kz|b64}-VL
  ASMJIT_INST_3x(vscalefpd, Vscalefpd, Ymm, Ymm, Ymm)                  //      AVX512_F{kz|b64}-VL
  ASMJIT_INST_3x(vscalefpd, Vscalefpd, Ymm, Ymm, Mem)                  //      AVX512_F{kz|b64}-VL
  ASMJIT_INST_3x(vscalefpd, Vscalefpd, Zmm, Zmm, Zmm)                  //      AVX512_F{kz|er|b64}
  ASMJIT_INST_3x(vscalefpd, Vscalefpd, Zmm, Zmm, Mem)                  //      AVX512_F{kz|er|b64}
  ASMJIT_INST_3x(vscalefps, Vscalefps, Xmm, Xmm, Xmm)                  //      AVX512_F{kz|b32}-VL
  ASMJIT_INST_3x(vscalefps, Vscalefps, Xmm, Xmm, Mem)                  //      AVX512_F{kz|b32}-VL
  ASMJIT_INST_3x(vscalefps, Vscalefps, Ymm, Ymm, Ymm)                  //      AVX512_F{kz|b32}-VL
  ASMJIT_INST_3x(vscalefps, Vscalefps, Ymm, Ymm, Mem)                  //      AVX512_F{kz|b32}-VL
  ASMJIT_INST_3x(vscalefps, Vscalefps, Zmm, Zmm, Zmm)                  //      AVX512_F{kz|er|b32}
  ASMJIT_INST_3x(vscalefps, Vscalefps, Zmm, Zmm, Mem)                  //      AVX512_F{kz|er|b32}
  ASMJIT_INST_3x(vscalefsd, Vscalefsd, Xmm, Xmm, Xmm)                  //      AVX512_F{kz|er}
  ASMJIT_INST_3x(vscalefsd, Vscalefsd, Xmm, Xmm, Mem)                  //      AVX512_F{kz|er}
  ASMJIT_INST_3x(vscalefss, Vscalefss, Xmm, Xmm, Xmm)                  //      AVX512_F{kz|er}
  ASMJIT_INST_3x(vscalefss, Vscalefss, Xmm, Xmm, Mem)                  //      AVX512_F{kz|er}
  ASMJIT_INST_2x(vscatterdpd, Vscatterdpd, Mem, Xmm)                   //      AVX512_F{k}-VL
  ASMJIT_INST_2x(vscatterdpd, Vscatterdpd, Mem, Ymm)                   //      AVX512_F{k}-VL
  ASMJIT_INST_2x(vscatterdpd, Vscatterdpd, Mem, Zmm)                   //      AVX512_F{k}
  ASMJIT_INST_2x(vscatterdps, Vscatterdps, Mem, Xmm)                   //      AVX512_F{k}-VL
  ASMJIT_INST_2x(vscatterdps, Vscatterdps, Mem, Ymm)                   //      AVX512_F{k}-VL
  ASMJIT_INST_2x(vscatterdps, Vscatterdps, Mem, Zmm)                   //      AVX512_F{k}
  ASMJIT_INST_1x(vscatterpf0dpd, Vscatterpf0dpd, Mem)                  //      AVX512_PF{k}
  ASMJIT_INST_1x(vscatterpf0dps, Vscatterpf0dps, Mem)                  //      AVX512_PF{k}
  ASMJIT_INST_1x(vscatterpf0qpd, Vscatterpf0qpd, Mem)                  //      AVX512_PF{k}
  ASMJIT_INST_1x(vscatterpf0qps, Vscatterpf0qps, Mem)                  //      AVX512_PF{k}
  ASMJIT_INST_1x(vscatterpf1dpd, Vscatterpf1dpd, Mem)                  //      AVX512_PF{k}
  ASMJIT_INST_1x(vscatterpf1dps, Vscatterpf1dps, Mem)                  //      AVX512_PF{k}
  ASMJIT_INST_1x(vscatterpf1qpd, Vscatterpf1qpd, Mem)                  //      AVX512_PF{k}
  ASMJIT_INST_1x(vscatterpf1qps, Vscatterpf1qps, Mem)                  //      AVX512_PF{k}
  ASMJIT_INST_2x(vscatterqpd, Vscatterqpd, Mem, Xmm)                   //      AVX512_F{k}-VL
  ASMJIT_INST_2x(vscatterqpd, Vscatterqpd, Mem, Ymm)                   //      AVX512_F{k}-VL
  ASMJIT_INST_2x(vscatterqpd, Vscatterqpd, Mem, Zmm)                   //      AVX512_F{k}
  ASMJIT_INST_2x(vscatterqps, Vscatterqps, Mem, Xmm)                   //      AVX512_F{k}-VL
  ASMJIT_INST_2x(vscatterqps, Vscatterqps, Mem, Ymm)                   //      AVX512_F{k}
  ASMJIT_INST_4i(vshuff32x4, Vshuff32x4, Ymm, Ymm, Ymm, Imm)           //      AVX512_F{kz|b32}-VL
  ASMJIT_INST_4i(vshuff32x4, Vshuff32x4, Ymm, Ymm, Mem, Imm)           //      AVX512_F{kz|b32}-VL
  ASMJIT_INST_4i(vshuff32x4, Vshuff32x4, Zmm, Zmm, Zmm, Imm)           //      AVX512_F{kz|b32}
  ASMJIT_INST_4i(vshuff32x4, Vshuff32x4, Zmm, Zmm, Mem, Imm)           //      AVX512_F{kz|b32}
  ASMJIT_INST_4i(vshuff64x2, Vshuff64x2, Ymm, Ymm, Ymm, Imm)           //      AVX512_F{kz|b64}-VL
  ASMJIT_INST_4i(vshuff64x2, Vshuff64x2, Ymm, Ymm, Mem, Imm)           //      AVX512_F{kz|b64}-VL
  ASMJIT_INST_4i(vshuff64x2, Vshuff64x2, Zmm, Zmm, Zmm, Imm)           //      AVX512_F{kz|b64}
  ASMJIT_INST_4i(vshuff64x2, Vshuff64x2, Zmm, Zmm, Mem, Imm)           //      AVX512_F{kz|b64}
  ASMJIT_INST_4i(vshufi32x4, Vshufi32x4, Ymm, Ymm, Ymm, Imm)           //      AVX512_F{kz|b32}-VL
  ASMJIT_INST_4i(vshufi32x4, Vshufi32x4, Ymm, Ymm, Mem, Imm)           //      AVX512_F{kz|b32}-VL
  ASMJIT_INST_4i(vshufi32x4, Vshufi32x4, Zmm, Zmm, Zmm, Imm)           //      AVX512_F{kz|b32}
  ASMJIT_INST_4i(vshufi32x4, Vshufi32x4, Zmm, Zmm, Mem, Imm)           //      AVX512_F{kz|b32}
  ASMJIT_INST_4i(vshufi64x2, Vshufi64x2, Ymm, Ymm, Ymm, Imm)           //      AVX512_F{kz|b64}-VL
  ASMJIT_INST_4i(vshufi64x2, Vshufi64x2, Ymm, Ymm, Mem, Imm)           //      AVX512_F{kz|b64}-VL
  ASMJIT_INST_4i(vshufi64x2, Vshufi64x2, Zmm, Zmm, Zmm, Imm)           //      AVX512_F{kz|b64}
  ASMJIT_INST_4i(vshufi64x2, Vshufi64x2, Zmm, Zmm, Mem, Imm)           //      AVX512_F{kz|b64}
  ASMJIT_INST_4i(vshufpd, Vshufpd, Xmm, Xmm, Xmm, Imm)                 // AVX  AVX512_F{kz|b32}-VL
  ASMJIT_INST_4i(vshufpd, Vshufpd, Xmm, Xmm, Mem, Imm)                 // AVX  AVX512_F{kz|b32}-VL
  ASMJIT_INST_4i(vshufpd, Vshufpd, Ymm, Ymm, Ymm, Imm)                 // AVX  AVX512_F{kz|b32}-VL
  ASMJIT_INST_4i(vshufpd, Vshufpd, Ymm, Ymm, Mem, Imm)                 // AVX  AVX512_F{kz|b32}-VL
  ASMJIT_INST_4i(vshufpd, Vshufpd, Zmm, Zmm, Zmm, Imm)                 //      AVX512_F{kz|b32}
  ASMJIT_INST_4i(vshufpd, Vshufpd, Zmm, Zmm, Mem, Imm)                 //      AVX512_F{kz|b32}
  ASMJIT_INST_4i(vshufps, Vshufps, Xmm, Xmm, Xmm, Imm)                 // AVX  AVX512_F{kz|b64}-VL
  ASMJIT_INST_4i(vshufps, Vshufps, Xmm, Xmm, Mem, Imm)                 // AVX  AVX512_F{kz|b64}-VL
  ASMJIT_INST_4i(vshufps, Vshufps, Ymm, Ymm, Ymm, Imm)                 // AVX  AVX512_F{kz|b64}-VL
  ASMJIT_INST_4i(vshufps, Vshufps, Ymm, Ymm, Mem, Imm)                 // AVX  AVX512_F{kz|b64}-VL
  ASMJIT_INST_4i(vshufps, Vshufps, Zmm, Zmm, Zmm, Imm)                 //      AVX512_F{kz|b64}
  ASMJIT_INST_4i(vshufps, Vshufps, Zmm, Zmm, Mem, Imm)                 //      AVX512_F{kz|b64}
  ASMJIT_INST_2x(vsqrtpd, Vsqrtpd, Xmm, Xmm)                           // AVX  AVX512_F{kz|b64}-VL
  ASMJIT_INST_2x(vsqrtpd, Vsqrtpd, Xmm, Mem)                           // AVX  AVX512_F{kz|b64}-VL
  ASMJIT_INST_2x(vsqrtpd, Vsqrtpd, Ymm, Ymm)                           // AVX  AVX512_F{kz|b64}-VL
  ASMJIT_INST_2x(vsqrtpd, Vsqrtpd, Ymm, Mem)                           // AVX  AVX512_F{kz|b64}-VL
  ASMJIT_INST_2x(vsqrtpd, Vsqrtpd, Zmm, Zmm)                           //      AVX512_F{kz|er|b64}
  ASMJIT_INST_2x(vsqrtpd, Vsqrtpd, Zmm, Mem)                           //      AVX512_F{kz|er|b64}
  ASMJIT_INST_2x(vsqrtps, Vsqrtps, Xmm, Xmm)                           // AVX  AVX512_F{kz|b32}-VL
  ASMJIT_INST_2x(vsqrtps, Vsqrtps, Xmm, Mem)                           // AVX  AVX512_F{kz|b32}-VL
  ASMJIT_INST_2x(vsqrtps, Vsqrtps, Ymm, Ymm)                           // AVX  AVX512_F{kz|b32}-VL
  ASMJIT_INST_2x(vsqrtps, Vsqrtps, Ymm, Mem)                           // AVX  AVX512_F{kz|b32}-VL
  ASMJIT_INST_2x(vsqrtps, Vsqrtps, Zmm, Zmm)                           //      AVX512_F{kz|er|b32}
  ASMJIT_INST_2x(vsqrtps, Vsqrtps, Zmm, Mem)                           //      AVX512_F{kz|er|b32}
  ASMJIT_INST_3x(vsqrtsd, Vsqrtsd, Xmm, Xmm, Xmm)                      // AVX  AVX512_F{kz|er}
  ASMJIT_INST_3x(vsqrtsd, Vsqrtsd, Xmm, Xmm, Mem)                      // AVX  AVX512_F{kz|er}
  ASMJIT_INST_3x(vsqrtss, Vsqrtss, Xmm, Xmm, Xmm)                      // AVX  AVX512_F{kz|er}
  ASMJIT_INST_3x(vsqrtss, Vsqrtss, Xmm, Xmm, Mem)                      // AVX  AVX512_F{kz|er}
  ASMJIT_INST_1x(vstmxcsr, Vstmxcsr, Mem)                              // AVX
  ASMJIT_INST_3x(vsubpd, Vsubpd, Xmm, Xmm, Xmm)                        // AVX  AVX512_F{kz|b64}-VL
  ASMJIT_INST_3x(vsubpd, Vsubpd, Xmm, Xmm, Mem)                        // AVX  AVX512_F{kz|b64}-VL
  ASMJIT_INST_3x(vsubpd, Vsubpd, Ymm, Ymm, Ymm)                        // AVX2 AVX512_F{kz|b64}-VL
  ASMJIT_INST_3x(vsubpd, Vsubpd, Ymm, Ymm, Mem)                        // AVX2 AVX512_F{kz|b64}-VL
  ASMJIT_INST_3x(vsubpd, Vsubpd, Zmm, Zmm, Zmm)                        //      AVX512_F{kz|er|b64}
  ASMJIT_INST_3x(vsubpd, Vsubpd, Zmm, Zmm, Mem)                        //      AVX512_F{kz|er|b64}
  ASMJIT_INST_3x(vsubps, Vsubps, Xmm, Xmm, Xmm)                        // AVX  AVX512_F{kz|b32}-VL
  ASMJIT_INST_3x(vsubps, Vsubps, Xmm, Xmm, Mem)                        // AVX  AVX512_F{kz|b32}-VL
  ASMJIT_INST_3x(vsubps, Vsubps, Ymm, Ymm, Ymm)                        // AVX2 AVX512_F{kz|b32}-VL
  ASMJIT_INST_3x(vsubps, Vsubps, Ymm, Ymm, Mem)                        // AVX2 AVX512_F{kz|b32}-VL
  ASMJIT_INST_3x(vsubps, Vsubps, Zmm, Zmm, Zmm)                        //      AVX512_F{kz|er|b32}
  ASMJIT_INST_3x(vsubps, Vsubps, Zmm, Zmm, Mem)                        //      AVX512_F{kz|er|b32}
  ASMJIT_INST_3x(vsubsd, Vsubsd, Xmm, Xmm, Xmm)                        // AVX  AVX512_F{kz|er}
  ASMJIT_INST_3x(vsubsd, Vsubsd, Xmm, Xmm, Mem)                        // AVX  AVX512_F{kz|er}
  ASMJIT_INST_3x(vsubss, Vsubss, Xmm, Xmm, Xmm)                        // AVX  AVX512_F{kz|er}
  ASMJIT_INST_3x(vsubss, Vsubss, Xmm, Xmm, Mem)                        // AVX  AVX512_F{kz|er}
  ASMJIT_INST_2x(vtestpd, Vtestpd, Xmm, Xmm)                           // AVX
  ASMJIT_INST_2x(vtestpd, Vtestpd, Xmm, Mem)                           // AVX
  ASMJIT_INST_2x(vtestpd, Vtestpd, Ymm, Ymm)                           // AVX
  ASMJIT_INST_2x(vtestpd, Vtestpd, Ymm, Mem)                           // AVX
  ASMJIT_INST_2x(vtestps, Vtestps, Xmm, Xmm)                           // AVX
  ASMJIT_INST_2x(vtestps, Vtestps, Xmm, Mem)                           // AVX
  ASMJIT_INST_2x(vtestps, Vtestps, Ymm, Ymm)                           // AVX
  ASMJIT_INST_2x(vtestps, Vtestps, Ymm, Mem)                           // AVX
  ASMJIT_INST_2x(vucomisd, Vucomisd, Xmm, Xmm)                         // AVX  AVX512_F{sae}
  ASMJIT_INST_2x(vucomisd, Vucomisd, Xmm, Mem)                         // AVX  AVX512_F{sae}
  ASMJIT_INST_2x(vucomiss, Vucomiss, Xmm, Xmm)                         // AVX  AVX512_F{sae}
  ASMJIT_INST_2x(vucomiss, Vucomiss, Xmm, Mem)                         // AVX  AVX512_F{sae}
  ASMJIT_INST_3x(vunpckhpd, Vunpckhpd, Xmm, Xmm, Xmm)                  // AVX  AVX512_F{kz|b64}-VL
  ASMJIT_INST_3x(vunpckhpd, Vunpckhpd, Xmm, Xmm, Mem)                  // AVX  AVX512_F{kz|b64}-VL
  ASMJIT_INST_3x(vunpckhpd, Vunpckhpd, Ymm, Ymm, Ymm)                  // AVX  AVX512_F{kz|b64}-VL
  ASMJIT_INST_3x(vunpckhpd, Vunpckhpd, Ymm, Ymm, Mem)                  // AVX  AVX512_F{kz|b64}-VL
  ASMJIT_INST_3x(vunpckhpd, Vunpckhpd, Zmm, Zmm, Zmm)                  //      AVX512_F{kz|b64}
  ASMJIT_INST_3x(vunpckhpd, Vunpckhpd, Zmm, Zmm, Mem)                  //      AVX512_F{kz|b64}
  ASMJIT_INST_3x(vunpckhps, Vunpckhps, Xmm, Xmm, Xmm)                  // AVX  AVX512_F{kz|b32}-VL
  ASMJIT_INST_3x(vunpckhps, Vunpckhps, Xmm, Xmm, Mem)                  // AVX  AVX512_F{kz|b32}-VL
  ASMJIT_INST_3x(vunpckhps, Vunpckhps, Ymm, Ymm, Ymm)                  // AVX  AVX512_F{kz|b32}-VL
  ASMJIT_INST_3x(vunpckhps, Vunpckhps, Ymm, Ymm, Mem)                  // AVX  AVX512_F{kz|b32}-VL
  ASMJIT_INST_3x(vunpckhps, Vunpckhps, Zmm, Zmm, Zmm)                  //      AVX512_F{kz|b32}
  ASMJIT_INST_3x(vunpckhps, Vunpckhps, Zmm, Zmm, Mem)                  //      AVX512_F{kz|b32}
  ASMJIT_INST_3x(vunpcklpd, Vunpcklpd, Xmm, Xmm, Xmm)                  // AVX  AVX512_F{kz|b64}-VL
  ASMJIT_INST_3x(vunpcklpd, Vunpcklpd, Xmm, Xmm, Mem)                  // AVX  AVX512_F{kz|b64}-VL
  ASMJIT_INST_3x(vunpcklpd, Vunpcklpd, Ymm, Ymm, Ymm)                  // AVX  AVX512_F{kz|b64}-VL
  ASMJIT_INST_3x(vunpcklpd, Vunpcklpd, Ymm, Ymm, Mem)                  // AVX  AVX512_F{kz|b64}-VL
  ASMJIT_INST_3x(vunpcklpd, Vunpcklpd, Zmm, Zmm, Zmm)                  //      AVX512_F{kz|b64}
  ASMJIT_INST_3x(vunpcklpd, Vunpcklpd, Zmm, Zmm, Mem)                  //      AVX512_F{kz|b64}
  ASMJIT_INST_3x(vunpcklps, Vunpcklps, Xmm, Xmm, Xmm)                  // AVX  AVX512_F{kz|b32}-VL
  ASMJIT_INST_3x(vunpcklps, Vunpcklps, Xmm, Xmm, Mem)                  // AVX  AVX512_F{kz|b32}-VL
  ASMJIT_INST_3x(vunpcklps, Vunpcklps, Ymm, Ymm, Ymm)                  // AVX  AVX512_F{kz|b32}-VL
  ASMJIT_INST_3x(vunpcklps, Vunpcklps, Ymm, Ymm, Mem)                  // AVX  AVX512_F{kz|b32}-VL
  ASMJIT_INST_3x(vunpcklps, Vunpcklps, Zmm, Zmm, Zmm)                  //      AVX512_F{kz|b32}
  ASMJIT_INST_3x(vunpcklps, Vunpcklps, Zmm, Zmm, Mem)                  //      AVX512_F{kz|b32}
  ASMJIT_INST_3x(vxorpd, Vxorpd, Xmm, Xmm, Xmm)                        // AVX  AVX512_DQ{kz|b64}-VL
  ASMJIT_INST_3x(vxorpd, Vxorpd, Xmm, Xmm, Mem)                        // AVX  AVX512_DQ{kz|b64}-VL
  ASMJIT_INST_3x(vxorpd, Vxorpd, Ymm, Ymm, Ymm)                        // AVX  AVX512_DQ{kz|b64}-VL
  ASMJIT_INST_3x(vxorpd, Vxorpd, Ymm, Ymm, Mem)                        // AVX  AVX512_DQ{kz|b64}-VL
  ASMJIT_INST_3x(vxorpd, Vxorpd, Zmm, Zmm, Zmm)                        //      AVX512_DQ{kz|b64}
  ASMJIT_INST_3x(vxorpd, Vxorpd, Zmm, Zmm, Mem)                        //      AVX512_DQ{kz|b64}
  ASMJIT_INST_3x(vxorps, Vxorps, Xmm, Xmm, Xmm)                        // AVX  AVX512_DQ{kz|b32}-VL
  ASMJIT_INST_3x(vxorps, Vxorps, Xmm, Xmm, Mem)                        // AVX  AVX512_DQ{kz|b32}-VL
  ASMJIT_INST_3x(vxorps, Vxorps, Ymm, Ymm, Ymm)                        // AVX  AVX512_DQ{kz|b32}-VL
  ASMJIT_INST_3x(vxorps, Vxorps, Ymm, Ymm, Mem)                        // AVX  AVX512_DQ{kz|b32}-VL
  ASMJIT_INST_3x(vxorps, Vxorps, Zmm, Zmm, Zmm)                        //      AVX512_DQ{kz|b32}
  ASMJIT_INST_3x(vxorps, Vxorps, Zmm, Zmm, Mem)                        //      AVX512_DQ{kz|b32}
  ASMJIT_INST_0x(vzeroall, Vzeroall)                                   // AVX
  ASMJIT_INST_0x(vzeroupper, Vzeroupper)                               // AVX

  // --------------------------------------------------------------------------
  // [FMA4]
  // --------------------------------------------------------------------------

  ASMJIT_INST_4x(vfmaddpd, Vfmaddpd, Xmm, Xmm, Xmm, Xmm)               // FMA4
  ASMJIT_INST_4x(vfmaddpd, Vfmaddpd, Xmm, Xmm, Mem, Xmm)               // FMA4
  ASMJIT_INST_4x(vfmaddpd, Vfmaddpd, Xmm, Xmm, Xmm, Mem)               // FMA4
  ASMJIT_INST_4x(vfmaddpd, Vfmaddpd, Ymm, Ymm, Ymm, Ymm)               // FMA4
  ASMJIT_INST_4x(vfmaddpd, Vfmaddpd, Ymm, Ymm, Mem, Ymm)               // FMA4
  ASMJIT_INST_4x(vfmaddpd, Vfmaddpd, Ymm, Ymm, Ymm, Mem)               // FMA4
  ASMJIT_INST_4x(vfmaddps, Vfmaddps, Xmm, Xmm, Xmm, Xmm)               // FMA4
  ASMJIT_INST_4x(vfmaddps, Vfmaddps, Xmm, Xmm, Mem, Xmm)               // FMA4
  ASMJIT_INST_4x(vfmaddps, Vfmaddps, Xmm, Xmm, Xmm, Mem)               // FMA4
  ASMJIT_INST_4x(vfmaddps, Vfmaddps, Ymm, Ymm, Ymm, Ymm)               // FMA4
  ASMJIT_INST_4x(vfmaddps, Vfmaddps, Ymm, Ymm, Mem, Ymm)               // FMA4
  ASMJIT_INST_4x(vfmaddps, Vfmaddps, Ymm, Ymm, Ymm, Mem)               // FMA4
  ASMJIT_INST_4x(vfmaddsd, Vfmaddsd, Xmm, Xmm, Xmm, Xmm)               // FMA4
  ASMJIT_INST_4x(vfmaddsd, Vfmaddsd, Xmm, Xmm, Mem, Xmm)               // FMA4
  ASMJIT_INST_4x(vfmaddsd, Vfmaddsd, Xmm, Xmm, Xmm, Mem)               // FMA4
  ASMJIT_INST_4x(vfmaddss, Vfmaddss, Xmm, Xmm, Xmm, Xmm)               // FMA4
  ASMJIT_INST_4x(vfmaddss, Vfmaddss, Xmm, Xmm, Mem, Xmm)               // FMA4
  ASMJIT_INST_4x(vfmaddss, Vfmaddss, Xmm, Xmm, Xmm, Mem)               // FMA4
  ASMJIT_INST_4x(vfmaddsubpd, Vfmaddsubpd, Xmm, Xmm, Xmm, Xmm)         // FMA4
  ASMJIT_INST_4x(vfmaddsubpd, Vfmaddsubpd, Xmm, Xmm, Mem, Xmm)         // FMA4
  ASMJIT_INST_4x(vfmaddsubpd, Vfmaddsubpd, Xmm, Xmm, Xmm, Mem)         // FMA4
  ASMJIT_INST_4x(vfmaddsubpd, Vfmaddsubpd, Ymm, Ymm, Ymm, Ymm)         // FMA4
  ASMJIT_INST_4x(vfmaddsubpd, Vfmaddsubpd, Ymm, Ymm, Mem, Ymm)         // FMA4
  ASMJIT_INST_4x(vfmaddsubpd, Vfmaddsubpd, Ymm, Ymm, Ymm, Mem)         // FMA4
  ASMJIT_INST_4x(vfmaddsubps, Vfmaddsubps, Xmm, Xmm, Xmm, Xmm)         // FMA4
  ASMJIT_INST_4x(vfmaddsubps, Vfmaddsubps, Xmm, Xmm, Mem, Xmm)         // FMA4
  ASMJIT_INST_4x(vfmaddsubps, Vfmaddsubps, Xmm, Xmm, Xmm, Mem)         // FMA4
  ASMJIT_INST_4x(vfmaddsubps, Vfmaddsubps, Ymm, Ymm, Ymm, Ymm)         // FMA4
  ASMJIT_INST_4x(vfmaddsubps, Vfmaddsubps, Ymm, Ymm, Mem, Ymm)         // FMA4
  ASMJIT_INST_4x(vfmaddsubps, Vfmaddsubps, Ymm, Ymm, Ymm, Mem)         // FMA4
  ASMJIT_INST_4x(vfmsubaddpd, Vfmsubaddpd, Xmm, Xmm, Xmm, Xmm)         // FMA4
  ASMJIT_INST_4x(vfmsubaddpd, Vfmsubaddpd, Xmm, Xmm, Mem, Xmm)         // FMA4
  ASMJIT_INST_4x(vfmsubaddpd, Vfmsubaddpd, Xmm, Xmm, Xmm, Mem)         // FMA4
  ASMJIT_INST_4x(vfmsubaddpd, Vfmsubaddpd, Ymm, Ymm, Ymm, Ymm)         // FMA4
  ASMJIT_INST_4x(vfmsubaddpd, Vfmsubaddpd, Ymm, Ymm, Mem, Ymm)         // FMA4
  ASMJIT_INST_4x(vfmsubaddpd, Vfmsubaddpd, Ymm, Ymm, Ymm, Mem)         // FMA4
  ASMJIT_INST_4x(vfmsubaddps, Vfmsubaddps, Xmm, Xmm, Xmm, Xmm)         // FMA4
  ASMJIT_INST_4x(vfmsubaddps, Vfmsubaddps, Xmm, Xmm, Mem, Xmm)         // FMA4
  ASMJIT_INST_4x(vfmsubaddps, Vfmsubaddps, Xmm, Xmm, Xmm, Mem)         // FMA4
  ASMJIT_INST_4x(vfmsubaddps, Vfmsubaddps, Ymm, Ymm, Ymm, Ymm)         // FMA4
  ASMJIT_INST_4x(vfmsubaddps, Vfmsubaddps, Ymm, Ymm, Mem, Ymm)         // FMA4
  ASMJIT_INST_4x(vfmsubaddps, Vfmsubaddps, Ymm, Ymm, Ymm, Mem)         // FMA4
  ASMJIT_INST_4x(vfmsubpd, Vfmsubpd, Xmm, Xmm, Xmm, Xmm)               // FMA4
  ASMJIT_INST_4x(vfmsubpd, Vfmsubpd, Xmm, Xmm, Mem, Xmm)               // FMA4
  ASMJIT_INST_4x(vfmsubpd, Vfmsubpd, Xmm, Xmm, Xmm, Mem)               // FMA4
  ASMJIT_INST_4x(vfmsubpd, Vfmsubpd, Ymm, Ymm, Ymm, Ymm)               // FMA4
  ASMJIT_INST_4x(vfmsubpd, Vfmsubpd, Ymm, Ymm, Mem, Ymm)               // FMA4
  ASMJIT_INST_4x(vfmsubpd, Vfmsubpd, Ymm, Ymm, Ymm, Mem)               // FMA4
  ASMJIT_INST_4x(vfmsubps, Vfmsubps, Xmm, Xmm, Xmm, Xmm)               // FMA4
  ASMJIT_INST_4x(vfmsubps, Vfmsubps, Xmm, Xmm, Mem, Xmm)               // FMA4
  ASMJIT_INST_4x(vfmsubps, Vfmsubps, Xmm, Xmm, Xmm, Mem)               // FMA4
  ASMJIT_INST_4x(vfmsubps, Vfmsubps, Ymm, Ymm, Ymm, Ymm)               // FMA4
  ASMJIT_INST_4x(vfmsubps, Vfmsubps, Ymm, Ymm, Mem, Ymm)               // FMA4
  ASMJIT_INST_4x(vfmsubps, Vfmsubps, Ymm, Ymm, Ymm, Mem)               // FMA4
  ASMJIT_INST_4x(vfmsubsd, Vfmsubsd, Xmm, Xmm, Xmm, Xmm)               // FMA4
  ASMJIT_INST_4x(vfmsubsd, Vfmsubsd, Xmm, Xmm, Mem, Xmm)               // FMA4
  ASMJIT_INST_4x(vfmsubsd, Vfmsubsd, Xmm, Xmm, Xmm, Mem)               // FMA4
  ASMJIT_INST_4x(vfmsubss, Vfmsubss, Xmm, Xmm, Xmm, Xmm)               // FMA4
  ASMJIT_INST_4x(vfmsubss, Vfmsubss, Xmm, Xmm, Mem, Xmm)               // FMA4
  ASMJIT_INST_4x(vfmsubss, Vfmsubss, Xmm, Xmm, Xmm, Mem)               // FMA4
  ASMJIT_INST_4x(vfnmaddpd, Vfnmaddpd, Xmm, Xmm, Xmm, Xmm)             // FMA4
  ASMJIT_INST_4x(vfnmaddpd, Vfnmaddpd, Xmm, Xmm, Mem, Xmm)             // FMA4
  ASMJIT_INST_4x(vfnmaddpd, Vfnmaddpd, Xmm, Xmm, Xmm, Mem)             // FMA4
  ASMJIT_INST_4x(vfnmaddpd, Vfnmaddpd, Ymm, Ymm, Ymm, Ymm)             // FMA4
  ASMJIT_INST_4x(vfnmaddpd, Vfnmaddpd, Ymm, Ymm, Mem, Ymm)             // FMA4
  ASMJIT_INST_4x(vfnmaddpd, Vfnmaddpd, Ymm, Ymm, Ymm, Mem)             // FMA4
  ASMJIT_INST_4x(vfnmaddps, Vfnmaddps, Xmm, Xmm, Xmm, Xmm)             // FMA4
  ASMJIT_INST_4x(vfnmaddps, Vfnmaddps, Xmm, Xmm, Mem, Xmm)             // FMA4
  ASMJIT_INST_4x(vfnmaddps, Vfnmaddps, Xmm, Xmm, Xmm, Mem)             // FMA4
  ASMJIT_INST_4x(vfnmaddps, Vfnmaddps, Ymm, Ymm, Ymm, Ymm)             // FMA4
  ASMJIT_INST_4x(vfnmaddps, Vfnmaddps, Ymm, Ymm, Mem, Ymm)             // FMA4
  ASMJIT_INST_4x(vfnmaddps, Vfnmaddps, Ymm, Ymm, Ymm, Mem)             // FMA4
  ASMJIT_INST_4x(vfnmaddsd, Vfnmaddsd, Xmm, Xmm, Xmm, Xmm)             // FMA4
  ASMJIT_INST_4x(vfnmaddsd, Vfnmaddsd, Xmm, Xmm, Mem, Xmm)             // FMA4
  ASMJIT_INST_4x(vfnmaddsd, Vfnmaddsd, Xmm, Xmm, Xmm, Mem)             // FMA4
  ASMJIT_INST_4x(vfnmaddss, Vfnmaddss, Xmm, Xmm, Xmm, Xmm)             // FMA4
  ASMJIT_INST_4x(vfnmaddss, Vfnmaddss, Xmm, Xmm, Mem, Xmm)             // FMA4
  ASMJIT_INST_4x(vfnmaddss, Vfnmaddss, Xmm, Xmm, Xmm, Mem)             // FMA4
  ASMJIT_INST_4x(vfnmsubpd, Vfnmsubpd, Xmm, Xmm, Xmm, Xmm)             // FMA4
  ASMJIT_INST_4x(vfnmsubpd, Vfnmsubpd, Xmm, Xmm, Mem, Xmm)             // FMA4
  ASMJIT_INST_4x(vfnmsubpd, Vfnmsubpd, Xmm, Xmm, Xmm, Mem)             // FMA4
  ASMJIT_INST_4x(vfnmsubpd, Vfnmsubpd, Ymm, Ymm, Ymm, Ymm)             // FMA4
  ASMJIT_INST_4x(vfnmsubpd, Vfnmsubpd, Ymm, Ymm, Mem, Ymm)             // FMA4
  ASMJIT_INST_4x(vfnmsubpd, Vfnmsubpd, Ymm, Ymm, Ymm, Mem)             // FMA4
  ASMJIT_INST_4x(vfnmsubps, Vfnmsubps, Xmm, Xmm, Xmm, Xmm)             // FMA4
  ASMJIT_INST_4x(vfnmsubps, Vfnmsubps, Xmm, Xmm, Mem, Xmm)             // FMA4
  ASMJIT_INST_4x(vfnmsubps, Vfnmsubps, Xmm, Xmm, Xmm, Mem)             // FMA4
  ASMJIT_INST_4x(vfnmsubps, Vfnmsubps, Ymm, Ymm, Ymm, Ymm)             // FMA4
  ASMJIT_INST_4x(vfnmsubps, Vfnmsubps, Ymm, Ymm, Mem, Ymm)             // FMA4
  ASMJIT_INST_4x(vfnmsubps, Vfnmsubps, Ymm, Ymm, Ymm, Mem)             // FMA4
  ASMJIT_INST_4x(vfnmsubsd, Vfnmsubsd, Xmm, Xmm, Xmm, Xmm)             // FMA4
  ASMJIT_INST_4x(vfnmsubsd, Vfnmsubsd, Xmm, Xmm, Mem, Xmm)             // FMA4
  ASMJIT_INST_4x(vfnmsubsd, Vfnmsubsd, Xmm, Xmm, Xmm, Mem)             // FMA4
  ASMJIT_INST_4x(vfnmsubss, Vfnmsubss, Xmm, Xmm, Xmm, Xmm)             // FMA4
  ASMJIT_INST_4x(vfnmsubss, Vfnmsubss, Xmm, Xmm, Mem, Xmm)             // FMA4
  ASMJIT_INST_4x(vfnmsubss, Vfnmsubss, Xmm, Xmm, Xmm, Mem)             // FMA4

  // --------------------------------------------------------------------------
  // [XOP]
  // --------------------------------------------------------------------------

  ASMJIT_INST_2x(vfrczpd, Vfrczpd, Xmm, Xmm)                           // XOP
  ASMJIT_INST_2x(vfrczpd, Vfrczpd, Xmm, Mem)                           // XOP
  ASMJIT_INST_2x(vfrczpd, Vfrczpd, Ymm, Ymm)                           // XOP
  ASMJIT_INST_2x(vfrczpd, Vfrczpd, Ymm, Mem)                           // XOP
  ASMJIT_INST_2x(vfrczps, Vfrczps, Xmm, Xmm)                           // XOP
  ASMJIT_INST_2x(vfrczps, Vfrczps, Xmm, Mem)                           // XOP
  ASMJIT_INST_2x(vfrczps, Vfrczps, Ymm, Ymm)                           // XOP
  ASMJIT_INST_2x(vfrczps, Vfrczps, Ymm, Mem)                           // XOP
  ASMJIT_INST_2x(vfrczsd, Vfrczsd, Xmm, Xmm)                           // XOP
  ASMJIT_INST_2x(vfrczsd, Vfrczsd, Xmm, Mem)                           // XOP
  ASMJIT_INST_2x(vfrczss, Vfrczss, Xmm, Xmm)                           // XOP
  ASMJIT_INST_2x(vfrczss, Vfrczss, Xmm, Mem)                           // XOP
  ASMJIT_INST_4x(vpcmov, Vpcmov, Xmm, Xmm, Xmm, Xmm)                   // XOP
  ASMJIT_INST_4x(vpcmov, Vpcmov, Xmm, Xmm, Mem, Xmm)                   // XOP
  ASMJIT_INST_4x(vpcmov, Vpcmov, Xmm, Xmm, Xmm, Mem)                   // XOP
  ASMJIT_INST_4x(vpcmov, Vpcmov, Ymm, Ymm, Ymm, Ymm)                   // XOP
  ASMJIT_INST_4x(vpcmov, Vpcmov, Ymm, Ymm, Mem, Ymm)                   // XOP
  ASMJIT_INST_4x(vpcmov, Vpcmov, Ymm, Ymm, Ymm, Mem)                   // XOP
  ASMJIT_INST_4i(vpcomb, Vpcomb, Xmm, Xmm, Xmm, Imm)                   // XOP
  ASMJIT_INST_4i(vpcomb, Vpcomb, Xmm, Xmm, Mem, Imm)                   // XOP
  ASMJIT_INST_4i(vpcomd, Vpcomd, Xmm, Xmm, Xmm, Imm)                   // XOP
  ASMJIT_INST_4i(vpcomd, Vpcomd, Xmm, Xmm, Mem, Imm)                   // XOP
  ASMJIT_INST_4i(vpcomq, Vpcomq, Xmm, Xmm, Xmm, Imm)                   // XOP
  ASMJIT_INST_4i(vpcomq, Vpcomq, Xmm, Xmm, Mem, Imm)                   // XOP
  ASMJIT_INST_4i(vpcomw, Vpcomw, Xmm, Xmm, Xmm, Imm)                   // XOP
  ASMJIT_INST_4i(vpcomw, Vpcomw, Xmm, Xmm, Mem, Imm)                   // XOP
  ASMJIT_INST_4i(vpcomub, Vpcomub, Xmm, Xmm, Xmm, Imm)                 // XOP
  ASMJIT_INST_4i(vpcomub, Vpcomub, Xmm, Xmm, Mem, Imm)                 // XOP
  ASMJIT_INST_4i(vpcomud, Vpcomud, Xmm, Xmm, Xmm, Imm)                 // XOP
  ASMJIT_INST_4i(vpcomud, Vpcomud, Xmm, Xmm, Mem, Imm)                 // XOP
  ASMJIT_INST_4i(vpcomuq, Vpcomuq, Xmm, Xmm, Xmm, Imm)                 // XOP
  ASMJIT_INST_4i(vpcomuq, Vpcomuq, Xmm, Xmm, Mem, Imm)                 // XOP
  ASMJIT_INST_4i(vpcomuw, Vpcomuw, Xmm, Xmm, Xmm, Imm)                 // XOP
  ASMJIT_INST_4i(vpcomuw, Vpcomuw, Xmm, Xmm, Mem, Imm)                 // XOP
  ASMJIT_INST_5i(vpermil2pd, Vpermil2pd, Xmm, Xmm, Xmm, Xmm, Imm)      // XOP
  ASMJIT_INST_5i(vpermil2pd, Vpermil2pd, Xmm, Xmm, Mem, Xmm, Imm)      // XOP
  ASMJIT_INST_5i(vpermil2pd, Vpermil2pd, Xmm, Xmm, Xmm, Mem, Imm)      // XOP
  ASMJIT_INST_5i(vpermil2pd, Vpermil2pd, Ymm, Ymm, Ymm, Ymm, Imm)      // XOP
  ASMJIT_INST_5i(vpermil2pd, Vpermil2pd, Ymm, Ymm, Mem, Ymm, Imm)      // XOP
  ASMJIT_INST_5i(vpermil2pd, Vpermil2pd, Ymm, Ymm, Ymm, Mem, Imm)      // XOP
  ASMJIT_INST_5i(vpermil2ps, Vpermil2ps, Xmm, Xmm, Xmm, Xmm, Imm)      // XOP
  ASMJIT_INST_5i(vpermil2ps, Vpermil2ps, Xmm, Xmm, Mem, Xmm, Imm)      // XOP
  ASMJIT_INST_5i(vpermil2ps, Vpermil2ps, Xmm, Xmm, Xmm, Mem, Imm)      // XOP
  ASMJIT_INST_5i(vpermil2ps, Vpermil2ps, Ymm, Ymm, Ymm, Ymm, Imm)      // XOP
  ASMJIT_INST_5i(vpermil2ps, Vpermil2ps, Ymm, Ymm, Mem, Ymm, Imm)      // XOP
  ASMJIT_INST_5i(vpermil2ps, Vpermil2ps, Ymm, Ymm, Ymm, Mem, Imm)      // XOP
  ASMJIT_INST_2x(vphaddbd, Vphaddbd, Xmm, Xmm)                         // XOP
  ASMJIT_INST_2x(vphaddbd, Vphaddbd, Xmm, Mem)                         // XOP
  ASMJIT_INST_2x(vphaddbq, Vphaddbq, Xmm, Xmm)                         // XOP
  ASMJIT_INST_2x(vphaddbq, Vphaddbq, Xmm, Mem)                         // XOP
  ASMJIT_INST_2x(vphaddbw, Vphaddbw, Xmm, Xmm)                         // XOP
  ASMJIT_INST_2x(vphaddbw, Vphaddbw, Xmm, Mem)                         // XOP
  ASMJIT_INST_2x(vphadddq, Vphadddq, Xmm, Xmm)                         // XOP
  ASMJIT_INST_2x(vphadddq, Vphadddq, Xmm, Mem)                         // XOP
  ASMJIT_INST_2x(vphaddwd, Vphaddwd, Xmm, Xmm)                         // XOP
  ASMJIT_INST_2x(vphaddwd, Vphaddwd, Xmm, Mem)                         // XOP
  ASMJIT_INST_2x(vphaddwq, Vphaddwq, Xmm, Xmm)                         // XOP
  ASMJIT_INST_2x(vphaddwq, Vphaddwq, Xmm, Mem)                         // XOP
  ASMJIT_INST_2x(vphaddubd, Vphaddubd, Xmm, Xmm)                       // XOP
  ASMJIT_INST_2x(vphaddubd, Vphaddubd, Xmm, Mem)                       // XOP
  ASMJIT_INST_2x(vphaddubq, Vphaddubq, Xmm, Xmm)                       // XOP
  ASMJIT_INST_2x(vphaddubq, Vphaddubq, Xmm, Mem)                       // XOP
  ASMJIT_INST_2x(vphaddubw, Vphaddubw, Xmm, Xmm)                       // XOP
  ASMJIT_INST_2x(vphaddubw, Vphaddubw, Xmm, Mem)                       // XOP
  ASMJIT_INST_2x(vphaddudq, Vphaddudq, Xmm, Xmm)                       // XOP
  ASMJIT_INST_2x(vphaddudq, Vphaddudq, Xmm, Mem)                       // XOP
  ASMJIT_INST_2x(vphadduwd, Vphadduwd, Xmm, Xmm)                       // XOP
  ASMJIT_INST_2x(vphadduwd, Vphadduwd, Xmm, Mem)                       // XOP
  ASMJIT_INST_2x(vphadduwq, Vphadduwq, Xmm, Xmm)                       // XOP
  ASMJIT_INST_2x(vphadduwq, Vphadduwq, Xmm, Mem)                       // XOP
  ASMJIT_INST_2x(vphsubbw, Vphsubbw, Xmm, Xmm)                         // XOP
  ASMJIT_INST_2x(vphsubbw, Vphsubbw, Xmm, Mem)                         // XOP
  ASMJIT_INST_2x(vphsubdq, Vphsubdq, Xmm, Xmm)                         // XOP
  ASMJIT_INST_2x(vphsubdq, Vphsubdq, Xmm, Mem)                         // XOP
  ASMJIT_INST_2x(vphsubwd, Vphsubwd, Xmm, Xmm)                         // XOP
  ASMJIT_INST_2x(vphsubwd, Vphsubwd, Xmm, Mem)                         // XOP
  ASMJIT_INST_4x(vpmacsdd, Vpmacsdd, Xmm, Xmm, Xmm, Xmm)               // XOP
  ASMJIT_INST_4x(vpmacsdd, Vpmacsdd, Xmm, Xmm, Mem, Xmm)               // XOP
  ASMJIT_INST_4x(vpmacsdqh, Vpmacsdqh, Xmm, Xmm, Xmm, Xmm)             // XOP
  ASMJIT_INST_4x(vpmacsdqh, Vpmacsdqh, Xmm, Xmm, Mem, Xmm)             // XOP
  ASMJIT_INST_4x(vpmacsdql, Vpmacsdql, Xmm, Xmm, Xmm, Xmm)             // XOP
  ASMJIT_INST_4x(vpmacsdql, Vpmacsdql, Xmm, Xmm, Mem, Xmm)             // XOP
  ASMJIT_INST_4x(vpmacswd, Vpmacswd, Xmm, Xmm, Xmm, Xmm)               // XOP
  ASMJIT_INST_4x(vpmacswd, Vpmacswd, Xmm, Xmm, Mem, Xmm)               // XOP
  ASMJIT_INST_4x(vpmacsww, Vpmacsww, Xmm, Xmm, Xmm, Xmm)               // XOP
  ASMJIT_INST_4x(vpmacsww, Vpmacsww, Xmm, Xmm, Mem, Xmm)               // XOP
  ASMJIT_INST_4x(vpmacssdd, Vpmacssdd, Xmm, Xmm, Xmm, Xmm)             // XOP
  ASMJIT_INST_4x(vpmacssdd, Vpmacssdd, Xmm, Xmm, Mem, Xmm)             // XOP
  ASMJIT_INST_4x(vpmacssdqh, Vpmacssdqh, Xmm, Xmm, Xmm, Xmm)           // XOP
  ASMJIT_INST_4x(vpmacssdqh, Vpmacssdqh, Xmm, Xmm, Mem, Xmm)           // XOP
  ASMJIT_INST_4x(vpmacssdql, Vpmacssdql, Xmm, Xmm, Xmm, Xmm)           // XOP
  ASMJIT_INST_4x(vpmacssdql, Vpmacssdql, Xmm, Xmm, Mem, Xmm)           // XOP
  ASMJIT_INST_4x(vpmacsswd, Vpmacsswd, Xmm, Xmm, Xmm, Xmm)             // XOP
  ASMJIT_INST_4x(vpmacsswd, Vpmacsswd, Xmm, Xmm, Mem, Xmm)             // XOP
  ASMJIT_INST_4x(vpmacssww, Vpmacssww, Xmm, Xmm, Xmm, Xmm)             // XOP
  ASMJIT_INST_4x(vpmacssww, Vpmacssww, Xmm, Xmm, Mem, Xmm)             // XOP
  ASMJIT_INST_4x(vpmadcsswd, Vpmadcsswd, Xmm, Xmm, Xmm, Xmm)           // XOP
  ASMJIT_INST_4x(vpmadcsswd, Vpmadcsswd, Xmm, Xmm, Mem, Xmm)           // XOP
  ASMJIT_INST_4x(vpmadcswd, Vpmadcswd, Xmm, Xmm, Xmm, Xmm)             // XOP
  ASMJIT_INST_4x(vpmadcswd, Vpmadcswd, Xmm, Xmm, Mem, Xmm)             // XOP
  ASMJIT_INST_4x(vpperm, Vpperm, Xmm, Xmm, Xmm, Xmm)                   // XOP
  ASMJIT_INST_4x(vpperm, Vpperm, Xmm, Xmm, Mem, Xmm)                   // XOP
  ASMJIT_INST_4x(vpperm, Vpperm, Xmm, Xmm, Xmm, Mem)                   // XOP
  ASMJIT_INST_3x(vprotb, Vprotb, Xmm, Xmm, Xmm)                        // XOP
  ASMJIT_INST_3x(vprotb, Vprotb, Xmm, Mem, Xmm)                        // XOP
  ASMJIT_INST_3x(vprotb, Vprotb, Xmm, Xmm, Mem)                        // XOP
  ASMJIT_INST_3i(vprotb, Vprotb, Xmm, Xmm, Imm)                        // XOP
  ASMJIT_INST_3i(vprotb, Vprotb, Xmm, Mem, Imm)                        // XOP
  ASMJIT_INST_3x(vprotd, Vprotd, Xmm, Xmm, Xmm)                        // XOP
  ASMJIT_INST_3x(vprotd, Vprotd, Xmm, Mem, Xmm)                        // XOP
  ASMJIT_INST_3x(vprotd, Vprotd, Xmm, Xmm, Mem)                        // XOP
  ASMJIT_INST_3i(vprotd, Vprotd, Xmm, Xmm, Imm)                        // XOP
  ASMJIT_INST_3i(vprotd, Vprotd, Xmm, Mem, Imm)                        // XOP
  ASMJIT_INST_3x(vprotq, Vprotq, Xmm, Xmm, Xmm)                        // XOP
  ASMJIT_INST_3x(vprotq, Vprotq, Xmm, Mem, Xmm)                        // XOP
  ASMJIT_INST_3x(vprotq, Vprotq, Xmm, Xmm, Mem)                        // XOP
  ASMJIT_INST_3i(vprotq, Vprotq, Xmm, Xmm, Imm)                        // XOP
  ASMJIT_INST_3i(vprotq, Vprotq, Xmm, Mem, Imm)                        // XOP
  ASMJIT_INST_3x(vprotw, Vprotw, Xmm, Xmm, Xmm)                        // XOP
  ASMJIT_INST_3x(vprotw, Vprotw, Xmm, Mem, Xmm)                        // XOP
  ASMJIT_INST_3x(vprotw, Vprotw, Xmm, Xmm, Mem)                        // XOP
  ASMJIT_INST_3i(vprotw, Vprotw, Xmm, Xmm, Imm)                        // XOP
  ASMJIT_INST_3i(vprotw, Vprotw, Xmm, Mem, Imm)                        // XOP
  ASMJIT_INST_3x(vpshab, Vpshab, Xmm, Xmm, Xmm)                        // XOP
  ASMJIT_INST_3x(vpshab, Vpshab, Xmm, Mem, Xmm)                        // XOP
  ASMJIT_INST_3x(vpshab, Vpshab, Xmm, Xmm, Mem)                        // XOP
  ASMJIT_INST_3x(vpshad, Vpshad, Xmm, Xmm, Xmm)                        // XOP
  ASMJIT_INST_3x(vpshad, Vpshad, Xmm, Mem, Xmm)                        // XOP
  ASMJIT_INST_3x(vpshad, Vpshad, Xmm, Xmm, Mem)                        // XOP
  ASMJIT_INST_3x(vpshaq, Vpshaq, Xmm, Xmm, Xmm)                        // XOP
  ASMJIT_INST_3x(vpshaq, Vpshaq, Xmm, Mem, Xmm)                        // XOP
  ASMJIT_INST_3x(vpshaq, Vpshaq, Xmm, Xmm, Mem)                        // XOP
  ASMJIT_INST_3x(vpshaw, Vpshaw, Xmm, Xmm, Xmm)                        // XOP
  ASMJIT_INST_3x(vpshaw, Vpshaw, Xmm, Mem, Xmm)                        // XOP
  ASMJIT_INST_3x(vpshaw, Vpshaw, Xmm, Xmm, Mem)                        // XOP
  ASMJIT_INST_3x(vpshlb, Vpshlb, Xmm, Xmm, Xmm)                        // XOP
  ASMJIT_INST_3x(vpshlb, Vpshlb, Xmm, Mem, Xmm)                        // XOP
  ASMJIT_INST_3x(vpshlb, Vpshlb, Xmm, Xmm, Mem)                        // XOP
  ASMJIT_INST_3x(vpshld, Vpshld, Xmm, Xmm, Xmm)                        // XOP
  ASMJIT_INST_3x(vpshld, Vpshld, Xmm, Mem, Xmm)                        // XOP
  ASMJIT_INST_3x(vpshld, Vpshld, Xmm, Xmm, Mem)                        // XOP
  ASMJIT_INST_3x(vpshlq, Vpshlq, Xmm, Xmm, Xmm)                        // XOP
  ASMJIT_INST_3x(vpshlq, Vpshlq, Xmm, Mem, Xmm)                        // XOP
  ASMJIT_INST_3x(vpshlq, Vpshlq, Xmm, Xmm, Mem)                        // XOP
  ASMJIT_INST_3x(vpshlw, Vpshlw, Xmm, Xmm, Xmm)                        // XOP
  ASMJIT_INST_3x(vpshlw, Vpshlw, Xmm, Mem, Xmm)                        // XOP
  ASMJIT_INST_3x(vpshlw, Vpshlw, Xmm, Xmm, Mem)                        // XOP
};

// ============================================================================
// [asmjit::x86::EmitterImplicitT]
// ============================================================================

template<typename This>
struct EmitterImplicitT : public EmitterExplicitT<This> {
  // --------------------------------------------------------------------------
  // [Options]
  // --------------------------------------------------------------------------

  //! Use REP/REPE prefix.
  inline This& rep() noexcept { return EmitterExplicitT<This>::_addInstOptions(Inst::kOptionRep); }
  //! Use REP/REPE prefix.
  inline This& repe() noexcept { return rep(); }
  //! Use REP/REPE prefix.
  inline This& repz() noexcept { return rep(); }

  //! Use REPNE prefix.
  inline This& repne() noexcept { return EmitterExplicitT<This>::_addInstOptions(Inst::kOptionRepne); }
  //! Use REPNE prefix.
  inline This& repnz() noexcept { return repne(); }

  // --------------------------------------------------------------------------
  // [General Purpose and Non-SIMD Instructions]
  // --------------------------------------------------------------------------

  using EmitterExplicitT<This>::_emitter;

  // TODO: xrstor and xsave don't have explicit variants yet.
  using EmitterExplicitT<This>::cbw;
  using EmitterExplicitT<This>::cdq;
  using EmitterExplicitT<This>::cdqe;
  using EmitterExplicitT<This>::clzero;
  using EmitterExplicitT<This>::cqo;
  using EmitterExplicitT<This>::cwd;
  using EmitterExplicitT<This>::cwde;
  using EmitterExplicitT<This>::cmpsd;
  using EmitterExplicitT<This>::cmpxchg;
  using EmitterExplicitT<This>::cmpxchg8b;
  using EmitterExplicitT<This>::cmpxchg16b;
  using EmitterExplicitT<This>::cpuid;
  using EmitterExplicitT<This>::div;
  using EmitterExplicitT<This>::idiv;
  using EmitterExplicitT<This>::imul;
  using EmitterExplicitT<This>::jecxz;
  using EmitterExplicitT<This>::lahf;
  using EmitterExplicitT<This>::mulx;
  using EmitterExplicitT<This>::movsd;
  using EmitterExplicitT<This>::mul;
  using EmitterExplicitT<This>::rdmsr;
  using EmitterExplicitT<This>::rdpmc;
  using EmitterExplicitT<This>::rdtsc;
  using EmitterExplicitT<This>::rdtscp;
  using EmitterExplicitT<This>::sahf;
  using EmitterExplicitT<This>::wrmsr;
  using EmitterExplicitT<This>::xgetbv;
  using EmitterExplicitT<This>::xsetbv;

  ASMJIT_INST_0x(cbw, Cbw)                                             // ANY       [IMPLICIT] AX      <- Sign Extend AL
  ASMJIT_INST_0x(cdq, Cdq)                                             // ANY       [IMPLICIT] EDX:EAX <- Sign Extend EAX
  ASMJIT_INST_0x(cdqe, Cdqe)                                           // X64       [IMPLICIT] RAX     <- Sign Extend EAX
  ASMJIT_INST_0x(clzero, Clzero)                                       // CLZERO    [IMPLICIT]
  ASMJIT_INST_2x(cmpxchg, Cmpxchg, Gp, Gp)                             // I486      [IMPLICIT]
  ASMJIT_INST_2x(cmpxchg, Cmpxchg, Mem, Gp)                            // I486      [IMPLICIT]
  ASMJIT_INST_1x(cmpxchg16b, Cmpxchg16b, Mem)                          // CMPXCHG8B [IMPLICIT] m == RDX:RAX ? m <- RCX:RBX
  ASMJIT_INST_1x(cmpxchg8b, Cmpxchg8b, Mem)                            // CMPXCHG16B[IMPLICIT] m == EDX:EAX ? m <- ECX:EBX
  ASMJIT_INST_0x(cpuid, Cpuid)                                         // I486      [IMPLICIT] EAX:EBX:ECX:EDX  <- CPUID[EAX:ECX]
  ASMJIT_INST_0x(cqo, Cqo)                                             // X64       [IMPLICIT] RDX:RAX <- Sign Extend RAX
  ASMJIT_INST_0x(cwd, Cwd)                                             // ANY       [IMPLICIT] DX:AX   <- Sign Extend AX
  ASMJIT_INST_0x(cwde, Cwde)                                           // ANY       [IMPLICIT] EAX     <- Sign Extend AX
  ASMJIT_INST_0x(daa, Daa)
  ASMJIT_INST_0x(das, Das)
  ASMJIT_INST_1x(div, Div, Gp)                                         // ANY       [IMPLICIT] {AH[Rem]: AL[Quot] <- AX / r8} {xDX[Rem]:xAX[Quot] <- DX:AX / r16|r32|r64}
  ASMJIT_INST_1x(div, Div, Mem)                                        // ANY       [IMPLICIT] {AH[Rem]: AL[Quot] <- AX / m8} {xDX[Rem]:xAX[Quot] <- DX:AX / m16|m32|m64}
  ASMJIT_INST_1x(idiv, Idiv, Gp)                                       // ANY       [IMPLICIT] {AH[Rem]: AL[Quot] <- AX / r8} {xDX[Rem]:xAX[Quot] <- DX:AX / r16|r32|r64}
  ASMJIT_INST_1x(idiv, Idiv, Mem)                                      // ANY       [IMPLICIT] {AH[Rem]: AL[Quot] <- AX / m8} {xDX[Rem]:xAX[Quot] <- DX:AX / m16|m32|m64}
  ASMJIT_INST_1x(imul, Imul, Gp)                                       // ANY       [IMPLICIT] {AX <- AL * r8} {xAX:xDX <- xAX * r16|r32|r64}
  ASMJIT_INST_1x(imul, Imul, Mem)                                      // ANY       [IMPLICIT] {AX <- AL * m8} {xAX:xDX <- xAX * m16|m32|m64}
  ASMJIT_INST_0x(iret, Iret)                                           // ANY       [IMPLICIT]
  ASMJIT_INST_0x(iretd, Iretd)                                         // ANY       [IMPLICIT]
  ASMJIT_INST_0x(iretq, Iretq)                                         // X64       [IMPLICIT]
  ASMJIT_INST_0x(iretw, Iretw)                                         // ANY       [IMPLICIT]
  ASMJIT_INST_1x(jecxz, Jecxz, Label)                                  // ANY       [IMPLICIT] Short jump if CX/ECX/RCX is zero.
  ASMJIT_INST_1x(jecxz, Jecxz, Imm)                                    // ANY       [IMPLICIT] Short jump if CX/ECX/RCX is zero.
  ASMJIT_INST_1x(jecxz, Jecxz, uint64_t)                               // ANY       [IMPLICIT] Short jump if CX/ECX/RCX is zero.
  ASMJIT_INST_0x(lahf, Lahf)                                           // LAHFSAHF  [IMPLICIT] AH <- EFL
  ASMJIT_INST_1x(loop, Loop, Label)                                    // ANY       [IMPLICIT] Decrement xCX; short jump if xCX != 0.
  ASMJIT_INST_1x(loop, Loop, Imm)                                      // ANY       [IMPLICIT] Decrement xCX; short jump if xCX != 0.
  ASMJIT_INST_1x(loop, Loop, uint64_t)                                 // ANY       [IMPLICIT] Decrement xCX; short jump if xCX != 0.
  ASMJIT_INST_1x(loope, Loope, Label)                                  // ANY       [IMPLICIT] Decrement xCX; short jump if xCX != 0 && ZF == 1.
  ASMJIT_INST_1x(loope, Loope, Imm)                                    // ANY       [IMPLICIT] Decrement xCX; short jump if xCX != 0 && ZF == 1.
  ASMJIT_INST_1x(loope, Loope, uint64_t)                               // ANY       [IMPLICIT] Decrement xCX; short jump if xCX != 0 && ZF == 1.
  ASMJIT_INST_1x(loopne, Loopne, Label)                                // ANY       [IMPLICIT] Decrement xCX; short jump if xCX != 0 && ZF == 0.
  ASMJIT_INST_1x(loopne, Loopne, Imm)                                  // ANY       [IMPLICIT] Decrement xCX; short jump if xCX != 0 && ZF == 0.
  ASMJIT_INST_1x(loopne, Loopne, uint64_t)                             // ANY       [IMPLICIT] Decrement xCX; short jump if xCX != 0 && ZF == 0.
  ASMJIT_INST_1x(mul, Mul, Gp)                                         // ANY       [IMPLICIT] {AX <- AL * r8} {xDX:xAX <- xAX * r16|r32|r64}
  ASMJIT_INST_1x(mul, Mul, Mem)                                        // ANY       [IMPLICIT] {AX <- AL * m8} {xDX:xAX <- xAX * m16|m32|m64}
  ASMJIT_INST_3x(mulx, Mulx, Gp, Gp, Gp)                               // BMI2      [IMPLICIT]
  ASMJIT_INST_3x(mulx, Mulx, Gp, Gp, Mem)                              // BMI2      [IMPLICIT]
  ASMJIT_INST_0x(rdmsr, Rdmsr)                                         // ANY       [IMPLICIT]
  ASMJIT_INST_0x(rdpmc, Rdpmc)                                         // ANY       [IMPLICIT]
  ASMJIT_INST_0x(rdtsc, Rdtsc)                                         // RDTSC     [IMPLICIT] EDX:EAX <- CNT
  ASMJIT_INST_0x(rdtscp, Rdtscp)                                       // RDTSCP    [IMPLICIT] EDX:EAX:EXC <- CNT
  ASMJIT_INST_0x(ret, Ret)
  ASMJIT_INST_1i(ret, Ret, Imm)
  ASMJIT_INST_0x(sahf, Sahf)                                           // LAHFSAHF  [IMPLICIT] EFL <- AH
  ASMJIT_INST_0x(syscall, Syscall)                                     // X64       [IMPLICIT]
  ASMJIT_INST_0x(sysenter, Sysenter)                                   // X64       [IMPLICIT]
  ASMJIT_INST_0x(sysexit, Sysexit)                                     // X64       [IMPLICIT]
  ASMJIT_INST_0x(sysexit64, Sysexit64)                                 // X64       [IMPLICIT]
  ASMJIT_INST_0x(sysret, Sysret)                                       // X64       [IMPLICIT]
  ASMJIT_INST_0x(sysret64, Sysret64)                                   // X64       [IMPLICIT]
  ASMJIT_INST_0x(wrmsr, Wrmsr)                                         // ANY       [IMPLICIT]
  ASMJIT_INST_0x(xgetbv, Xgetbv)                                       // XSAVE     [IMPLICIT] EDX:EAX <- XCR[ECX]
  ASMJIT_INST_0x(xlatb, Xlatb)                                         // ANY       [IMPLICIT]
  ASMJIT_INST_1x(xrstor, Xrstor, Mem)                                  // XSAVE     [IMPLICIT]
  ASMJIT_INST_1x(xrstor64, Xrstor64, Mem)                              // XSAVE+X64 [IMPLICIT]
  ASMJIT_INST_1x(xrstors, Xrstors, Mem)                                // XSAVE     [IMPLICIT]
  ASMJIT_INST_1x(xrstors64, Xrstors64, Mem)                            // XSAVE+X64 [IMPLICIT]
  ASMJIT_INST_1x(xsave, Xsave, Mem)                                    // XSAVE     [IMPLICIT]
  ASMJIT_INST_1x(xsave64, Xsave64, Mem)                                // XSAVE+X64 [IMPLICIT]
  ASMJIT_INST_1x(xsavec, Xsavec, Mem)                                  // XSAVE     [IMPLICIT]
  ASMJIT_INST_1x(xsavec64, Xsavec64, Mem)                              // XSAVE+X64 [IMPLICIT]
  ASMJIT_INST_1x(xsaveopt, Xsaveopt, Mem)                              // XSAVE     [IMPLICIT]
  ASMJIT_INST_1x(xsaveopt64, Xsaveopt64, Mem)                          // XSAVE+X64 [IMPLICIT]
  ASMJIT_INST_1x(xsaves, Xsaves, Mem)                                  // XSAVE     [IMPLICIT]
  ASMJIT_INST_1x(xsaves64, Xsaves64, Mem)                              // XSAVE+X64 [IMPLICIT]
  ASMJIT_INST_0x(xsetbv, Xsetbv)                                       // XSAVE     [IMPLICIT] XCR[ECX] <- EDX:EAX

  // String instructions aliases.
  inline Error cmpsb() { return _emitter()->emit(Inst::kIdCmps, EmitterExplicitT<This>::ptr_zsi(0, 1), EmitterExplicitT<This>::ptr_zdi(0, 1)); }
  inline Error cmpsd() { return _emitter()->emit(Inst::kIdCmps, EmitterExplicitT<This>::ptr_zsi(0, 4), EmitterExplicitT<This>::ptr_zdi(0, 4)); }
  inline Error cmpsq() { return _emitter()->emit(Inst::kIdCmps, EmitterExplicitT<This>::ptr_zsi(0, 8), EmitterExplicitT<This>::ptr_zdi(0, 8)); }
  inline Error cmpsw() { return _emitter()->emit(Inst::kIdCmps, EmitterExplicitT<This>::ptr_zsi(0, 2), EmitterExplicitT<This>::ptr_zdi(0, 2)); }

  inline Error lodsb() { return _emitter()->emit(Inst::kIdLods, al , EmitterExplicitT<This>::ptr_zdi(0, 1)); }
  inline Error lodsd() { return _emitter()->emit(Inst::kIdLods, eax, EmitterExplicitT<This>::ptr_zdi(0, 4)); }
  inline Error lodsq() { return _emitter()->emit(Inst::kIdLods, rax, EmitterExplicitT<This>::ptr_zdi(0, 8)); }
  inline Error lodsw() { return _emitter()->emit(Inst::kIdLods, ax , EmitterExplicitT<This>::ptr_zdi(0, 2)); }

  inline Error movsb() { return _emitter()->emit(Inst::kIdMovs, EmitterExplicitT<This>::ptr_zdi(0, 1), EmitterExplicitT<This>::ptr_zsi(0, 1)); }
  inline Error movsd() { return _emitter()->emit(Inst::kIdMovs, EmitterExplicitT<This>::ptr_zdi(0, 4), EmitterExplicitT<This>::ptr_zsi(0, 4)); }
  inline Error movsq() { return _emitter()->emit(Inst::kIdMovs, EmitterExplicitT<This>::ptr_zdi(0, 8), EmitterExplicitT<This>::ptr_zsi(0, 8)); }
  inline Error movsw() { return _emitter()->emit(Inst::kIdMovs, EmitterExplicitT<This>::ptr_zdi(0, 2), EmitterExplicitT<This>::ptr_zsi(0, 2)); }

  inline Error scasb() { return _emitter()->emit(Inst::kIdScas, al , EmitterExplicitT<This>::ptr_zdi(0, 1)); }
  inline Error scasd() { return _emitter()->emit(Inst::kIdScas, eax, EmitterExplicitT<This>::ptr_zdi(0, 4)); }
  inline Error scasq() { return _emitter()->emit(Inst::kIdScas, rax, EmitterExplicitT<This>::ptr_zdi(0, 8)); }
  inline Error scasw() { return _emitter()->emit(Inst::kIdScas, ax , EmitterExplicitT<This>::ptr_zdi(0, 2)); }

  inline Error stosb() { return _emitter()->emit(Inst::kIdStos, EmitterExplicitT<This>::ptr_zdi(0, 1), al ); }
  inline Error stosd() { return _emitter()->emit(Inst::kIdStos, EmitterExplicitT<This>::ptr_zdi(0, 4), eax); }
  inline Error stosq() { return _emitter()->emit(Inst::kIdStos, EmitterExplicitT<This>::ptr_zdi(0, 8), rax); }
  inline Error stosw() { return _emitter()->emit(Inst::kIdStos, EmitterExplicitT<This>::ptr_zdi(0, 2), ax ); }

  // --------------------------------------------------------------------------
  // [MONITOR|MWAIT]
  // --------------------------------------------------------------------------

  ASMJIT_INST_0x(monitor, Monitor)
  ASMJIT_INST_0x(monitorx, Monitorx)
  ASMJIT_INST_0x(mwait, Mwait)
  ASMJIT_INST_0x(mwaitx, Mwaitx)

  // --------------------------------------------------------------------------
  // [MMX & SSE Instructions]
  // --------------------------------------------------------------------------

  using EmitterExplicitT<This>::blendvpd;
  using EmitterExplicitT<This>::blendvps;
  using EmitterExplicitT<This>::maskmovq;
  using EmitterExplicitT<This>::maskmovdqu;
  using EmitterExplicitT<This>::pblendvb;
  using EmitterExplicitT<This>::pcmpestri;
  using EmitterExplicitT<This>::pcmpestrm;
  using EmitterExplicitT<This>::pcmpistri;
  using EmitterExplicitT<This>::pcmpistrm;

  ASMJIT_INST_2x(blendvpd, Blendvpd, Xmm, Xmm)                         // SSE4_1 [IMPLICIT]
  ASMJIT_INST_2x(blendvpd, Blendvpd, Xmm, Mem)                         // SSE4_1 [IMPLICIT]
  ASMJIT_INST_2x(blendvps, Blendvps, Xmm, Xmm)                         // SSE4_1 [IMPLICIT]
  ASMJIT_INST_2x(blendvps, Blendvps, Xmm, Mem)                         // SSE4_1 [IMPLICIT]
  ASMJIT_INST_2x(pblendvb, Pblendvb, Xmm, Xmm)                         // SSE4_1 [IMPLICIT]
  ASMJIT_INST_2x(pblendvb, Pblendvb, Xmm, Mem)                         // SSE4_1 [IMPLICIT]
  ASMJIT_INST_2x(maskmovq, Maskmovq, Mm, Mm)                           // SSE    [IMPLICIT]
  ASMJIT_INST_2x(maskmovdqu, Maskmovdqu, Xmm, Xmm)                     // SSE2   [IMPLICIT]
  ASMJIT_INST_3i(pcmpestri, Pcmpestri, Xmm, Xmm, Imm)                  // SSE4_1 [IMPLICIT]
  ASMJIT_INST_3i(pcmpestri, Pcmpestri, Xmm, Mem, Imm)                  // SSE4_1 [IMPLICIT]
  ASMJIT_INST_3i(pcmpestrm, Pcmpestrm, Xmm, Xmm, Imm)                  // SSE4_1 [IMPLICIT]
  ASMJIT_INST_3i(pcmpestrm, Pcmpestrm, Xmm, Mem, Imm)                  // SSE4_1 [IMPLICIT]
  ASMJIT_INST_3i(pcmpistri, Pcmpistri, Xmm, Xmm, Imm)                  // SSE4_1 [IMPLICIT]
  ASMJIT_INST_3i(pcmpistri, Pcmpistri, Xmm, Mem, Imm)                  // SSE4_1 [IMPLICIT]
  ASMJIT_INST_3i(pcmpistrm, Pcmpistrm, Xmm, Xmm, Imm)                  // SSE4_1 [IMPLICIT]
  ASMJIT_INST_3i(pcmpistrm, Pcmpistrm, Xmm, Mem, Imm)                  // SSE4_1 [IMPLICIT]

  // --------------------------------------------------------------------------
  // [SHA]
  // --------------------------------------------------------------------------

  using EmitterExplicitT<This>::sha256rnds2;

  ASMJIT_INST_2x(sha256rnds2, Sha256rnds2, Xmm, Xmm)                   // SHA [IMPLICIT]
  ASMJIT_INST_2x(sha256rnds2, Sha256rnds2, Xmm, Mem)                   // SHA [IMPLICIT]

  // --------------------------------------------------------------------------
  // [AVX...AVX512]
  // --------------------------------------------------------------------------

  using EmitterExplicitT<This>::vmaskmovdqu;
  using EmitterExplicitT<This>::vpcmpestri;
  using EmitterExplicitT<This>::vpcmpestrm;
  using EmitterExplicitT<This>::vpcmpistri;
  using EmitterExplicitT<This>::vpcmpistrm;

  ASMJIT_INST_2x(vmaskmovdqu, Vmaskmovdqu, Xmm, Xmm)                   // AVX  [IMPLICIT]
  ASMJIT_INST_3i(vpcmpestri, Vpcmpestri, Xmm, Xmm, Imm)                // AVX  [IMPLICIT]
  ASMJIT_INST_3i(vpcmpestri, Vpcmpestri, Xmm, Mem, Imm)                // AVX  [IMPLICIT]
  ASMJIT_INST_3i(vpcmpestrm, Vpcmpestrm, Xmm, Xmm, Imm)                // AVX  [IMPLICIT]
  ASMJIT_INST_3i(vpcmpestrm, Vpcmpestrm, Xmm, Mem, Imm)                // AVX  [IMPLICIT]
  ASMJIT_INST_3i(vpcmpistri, Vpcmpistri, Xmm, Xmm, Imm)                // AVX  [IMPLICIT]
  ASMJIT_INST_3i(vpcmpistri, Vpcmpistri, Xmm, Mem, Imm)                // AVX  [IMPLICIT]
  ASMJIT_INST_3i(vpcmpistrm, Vpcmpistrm, Xmm, Xmm, Imm)                // AVX  [IMPLICIT]
  ASMJIT_INST_3i(vpcmpistrm, Vpcmpistrm, Xmm, Mem, Imm)                // AVX  [IMPLICIT]
};

#undef ASMJIT_INST_0x
#undef ASMJIT_INST_1x
#undef ASMJIT_INST_1i
#undef ASMJIT_INST_1c
#undef ASMJIT_INST_2x
#undef ASMJIT_INST_2i
#undef ASMJIT_INST_2c
#undef ASMJIT_INST_3x
#undef ASMJIT_INST_3i
#undef ASMJIT_INST_3ii
#undef ASMJIT_INST_4x
#undef ASMJIT_INST_4i
#undef ASMJIT_INST_4ii
#undef ASMJIT_INST_5x
#undef ASMJIT_INST_5i
#undef ASMJIT_INST_6x

// ============================================================================
// [asmjit::x86::Emitter]
// ============================================================================

//! Emitter (X86).
//!
//! NOTE: This class cannot be instantiated, you can only cast to it and use
//! it as emitter that emits to either `x86::Assembler`, `x86::Builder`, or
//! `x86::Compiler` (use with caution with `x86::Compiler` as it requires virtual
//! registers).
class Emitter : public BaseEmitter, public EmitterImplicitT<Emitter> {
  ASMJIT_NONCONSTRUCTIBLE(Emitter)
};

//! \}

ASMJIT_END_SUB_NAMESPACE

// [Guard]
#endif // _ASMJIT_X86_X86EMITTER_H

```

`Avanguard/AsmJit/asmjit/x86/x86features.h`:

```h
// [AsmJit]
// Complete x86/x64 JIT and Remote Assembler for C++.
//
// [License]
// ZLIB - See LICENSE.md file in the package.

// [Guard]
#ifndef _ASMJIT_X86_X86FEATURES_H
#define _ASMJIT_X86_X86FEATURES_H

// [Dependencies]
#include "../core/features.h"

ASMJIT_BEGIN_SUB_NAMESPACE(x86)

//! \addtogroup asmjit_x86_api
//! \{

// ============================================================================
// [asmjit::x86::Features]
// ============================================================================

//! CPU features (X86).
class Features : public BaseFeatures {
public:
  //! CPU feature ID.
  enum Id : uint32_t {
    kNone = 0,                 //!< No feature (never set, used internally).

    kMT,                       //!< CPU has multi-threading capabilities.
    kNX,                       //!< CPU has Not-Execute-Bit aka DEP (data-execution prevention).

    k3DNOW,                    //!< CPU has 3DNOW            (3DNOW base instructions) [AMD].
    k3DNOW2,                   //!< CPU has 3DNOW2           (enhanced 3DNOW) [AMD].
    kADX,                      //!< CPU has ADX              (multi-precision add-carry instruction extensions).
    kAESNI,                    //!< CPU has AESNI            (AES encode/decode instructions).
    kALTMOVCR8,                //!< CPU has LOCK MOV R<->CR0 (supports `MOV R<->CR8` via `LOCK MOV R<->CR0` in 32-bit mode) [AMD].
    kAVX,                      //!< CPU has AVX              (advanced vector extensions).
    kAVX2,                     //!< CPU has AVX2             (advanced vector extensions 2).
    kAVX512_4FMAPS,            //!< CPU has AVX512_FMAPS     (FMA packed single).
    kAVX512_4VNNIW,            //!< CPU has AVX512_VNNIW     (vector NN instructions word variable precision).
    kAVX512_BITALG,            //!< CPU has AVX512_BITALG    (VPOPCNT[B|W], VPSHUFBITQMB).
    kAVX512_BW,                //!< CPU has AVX512_BW        (packed BYTE|WORD).
    kAVX512_CDI,               //!< CPU has AVX512_CDI       (conflict detection).
    kAVX512_DQ,                //!< CPU has AVX512_DQ        (packed DWORD|QWORD).
    kAVX512_ERI,               //!< CPU has AVX512_ERI       (exponential and reciprocal).
    kAVX512_F,                 //!< CPU has AVX512_F         (AVX512 foundation).
    kAVX512_IFMA,              //!< CPU has AVX512_IFMA      (integer fused-multiply-add using 52-bit precision).
    kAVX512_PFI,               //!< CPU has AVX512_PFI       (prefetch instructions).
    kAVX512_VBMI,              //!< CPU has AVX512_VBMI      (vector byte manipulation).
    kAVX512_VBMI2,             //!< CPU has AVX512_VBMI2     (vector byte manipulation 2).
    kAVX512_VL,                //!< CPU has AVX512_VL        (vector length extensions).
    kAVX512_VNNI,              //!< CPU has AVX512_VNNI.
    kAVX512_VPOPCNTDQ,         //!< CPU has AVX512_VPOPCNTDQ (VPOPCNT[D|Q] instructions).
    kBMI,                      //!< CPU has BMI              (bit manipulation instructions #1).
    kBMI2,                     //!< CPU has BMI2             (bit manipulation instructions #2).
    kCLFLUSH,                  //!< CPU has CLFUSH.
    kCLFLUSHOPT,               //!< CPU has CLFUSHOPT.
    kCLWB,                     //!< CPU has CLWB.
    kCLZERO,                   //!< CPU has CLZERO.
    kCMOV,                     //!< CPU has CMOV             (CMOV and FCMOV instructions).
    kCMPXCHG16B,               //!< CPU has CMPXCHG16B       (compare-exchange 16 bytes) [X86_64].
    kCMPXCHG8B,                //!< CPU has CMPXCHG8B        (compare-exchange 8 bytes).
    kERMS,                     //!< CPU has ERMS             (enhanced REP MOVSB/STOSB).
    kF16C,                     //!< CPU has F16C.
    kFMA,                      //!< CPU has FMA              (fused-multiply-add 3 operand form).
    kFMA4,                     //!< CPU has FMA4             (fused-multiply-add 4 operand form).
    kFPU,                      //!< CPU has FPU              (FPU support).
    kFSGSBASE,                 //!< CPU has FSGSBASE.
    kFXSR,                     //!< CPU has FXSR             (FXSAVE/FXRSTOR instructions).
    kFXSROPT,                  //!< CPU has FXSROTP          (FXSAVE/FXRSTOR is optimized).
    kGEODE,                    //!< CPU has GEODE extensions (3DNOW additions).
    kGFNI,                     //!< CPU has GFNI             (Galois field instructions).
    kHLE,                      //!< CPU has HLE.
    kI486,                     //!< CPU has I486 features    (I486+ support).
    kLAHFSAHF,                 //!< CPU has LAHF/SAHF        (LAHF/SAHF in 64-bit mode) [X86_64].
    kLWP,                      //!< CPU has LWP              (lightweight profiling) [AMD].
    kLZCNT,                    //!< CPU has LZCNT            (LZCNT instruction).
    kMMX,                      //!< CPU has MMX              (MMX base instructions).
    kMMX2,                     //!< CPU has MMX2             (MMX extensions or MMX2).
    kMONITOR,                  //!< CPU has MONITOR          (MONITOR/MWAIT instructions).
    kMONITORX,                 //!< CPU has MONITORX         (MONITORX/MWAITX instructions).
    kMOVBE,                    //!< CPU has MOVBE            (move with byte-order swap).
    kMPX,                      //!< CPU has MPX              (memory protection extensions).
    kMSR,                      //!< CPU has MSR              (RDMSR/WRMSR instructions).
    kMSSE,                     //!< CPU has MSSE             (misaligned SSE support).
    kOSXSAVE,                  //!< CPU has OSXSAVE          (XSAVE enabled by OS).
    kPCLMULQDQ,                //!< CPU has PCLMULQDQ        (packed carry-less multiplication).
    kPCOMMIT,                  //!< CPU has PCOMMIT.
    kPOPCNT,                   //!< CPU has POPCNT           (POPCNT instruction).
    kPREFETCHW,                //!< CPU has PREFETCHW.
    kPREFETCHWT1,              //!< CPU has PREFETCHWT1.
    kRDRAND,                   //!< CPU has RDRAND.
    kRDSEED,                   //!< CPU has RDSEED.
    kRDTSC,                    //!< CPU has RDTSC.
    kRDTSCP,                   //!< CPU has RDTSCP.
    kRTM,                      //!< CPU has RTM.
    kSHA,                      //!< CPU has SHA              (SHA-1 and SHA-256 instructions).
    kSKINIT,                   //!< CPU has SKINIT           (SKINIT/STGI instructions) [AMD].
    kSMAP,                     //!< CPU has SMAP             (supervisor-mode access prevention).
    kSMEP,                     //!< CPU has SMEP             (supervisor-mode execution prevention).
    kSMX,                      //!< CPU has SMX              (safer mode extensions).
    kSSE,                      //!< CPU has SSE.
    kSSE2,                     //!< CPU has SSE2.
    kSSE3,                     //!< CPU has SSE3.
    kSSE4_1,                   //!< CPU has SSE4.1.
    kSSE4_2,                   //!< CPU has SSE4.2.
    kSSE4A,                    //!< CPU has SSE4A [AMD].
    kSSSE3,                    //!< CPU has SSSE3.
    kSVM,                      //!< CPU has SVM              (virtualization) [AMD].
    kTBM,                      //!< CPU has TBM              (trailing bit manipulation) [AMD].
    kTSX,                      //!< CPU has TSX.
    kVAES,                     //!< CPU has VAES             (vector AES 256|512 bit support).
    kVMX,                      //!< CPU has VMX              (virtualization) [INTEL].
    kVPCLMULQDQ,               //!< CPU has VPCLMULQDQ       (vector PCLMULQDQ 256|512-bit support).
    kXOP,                      //!< CPU has XOP              (XOP instructions) [AMD].
    kXSAVE,                    //!< CPU has XSAVE.
    kXSAVEC,                   //!< CPU has XSAVEC.
    kXSAVEOPT,                 //!< CPU has XSAVEOPT.
    kXSAVES,                   //!< CPU has XSAVES.

    kCount                     //!< Count of X86 CPU features.
  };

  // --------------------------------------------------------------------------
  // [Construction / Destruction]
  // --------------------------------------------------------------------------

  inline Features() noexcept
    : BaseFeatures() {}
  inline Features(const Features& other) noexcept
    : BaseFeatures(other) {}

  // --------------------------------------------------------------------------
  // [Accessors]
  // --------------------------------------------------------------------------

  #define ASMJIT_X86_FEATURE(FEATURE) \
    inline bool has##FEATURE() const noexcept { return has(k##FEATURE); }

  ASMJIT_X86_FEATURE(MT)
  ASMJIT_X86_FEATURE(NX)

  ASMJIT_X86_FEATURE(3DNOW)
  ASMJIT_X86_FEATURE(3DNOW2)
  ASMJIT_X86_FEATURE(ADX)
  ASMJIT_X86_FEATURE(AESNI)
  ASMJIT_X86_FEATURE(ALTMOVCR8)
  ASMJIT_X86_FEATURE(AVX)
  ASMJIT_X86_FEATURE(AVX2)
  ASMJIT_X86_FEATURE(AVX512_4FMAPS)
  ASMJIT_X86_FEATURE(AVX512_4VNNIW)
  ASMJIT_X86_FEATURE(AVX512_BITALG)
  ASMJIT_X86_FEATURE(AVX512_BW)
  ASMJIT_X86_FEATURE(AVX512_CDI)
  ASMJIT_X86_FEATURE(AVX512_DQ)
  ASMJIT_X86_FEATURE(AVX512_ERI)
  ASMJIT_X86_FEATURE(AVX512_F)
  ASMJIT_X86_FEATURE(AVX512_IFMA)
  ASMJIT_X86_FEATURE(AVX512_PFI)
  ASMJIT_X86_FEATURE(AVX512_VBMI)
  ASMJIT_X86_FEATURE(AVX512_VBMI2)
  ASMJIT_X86_FEATURE(AVX512_VL)
  ASMJIT_X86_FEATURE(AVX512_VNNI)
  ASMJIT_X86_FEATURE(AVX512_VPOPCNTDQ)
  ASMJIT_X86_FEATURE(BMI)
  ASMJIT_X86_FEATURE(BMI2)
  ASMJIT_X86_FEATURE(CLFLUSH)
  ASMJIT_X86_FEATURE(CLFLUSHOPT)
  ASMJIT_X86_FEATURE(CLWB)
  ASMJIT_X86_FEATURE(CLZERO)
  ASMJIT_X86_FEATURE(CMOV)
  ASMJIT_X86_FEATURE(CMPXCHG16B)
  ASMJIT_X86_FEATURE(CMPXCHG8B)
  ASMJIT_X86_FEATURE(ERMS)
  ASMJIT_X86_FEATURE(F16C)
  ASMJIT_X86_FEATURE(FMA)
  ASMJIT_X86_FEATURE(FMA4)
  ASMJIT_X86_FEATURE(FPU)
  ASMJIT_X86_FEATURE(FSGSBASE)
  ASMJIT_X86_FEATURE(FXSR)
  ASMJIT_X86_FEATURE(FXSROPT)
  ASMJIT_X86_FEATURE(GEODE)
  ASMJIT_X86_FEATURE(GFNI)
  ASMJIT_X86_FEATURE(HLE)
  ASMJIT_X86_FEATURE(I486)
  ASMJIT_X86_FEATURE(LAHFSAHF)
  ASMJIT_X86_FEATURE(LWP)
  ASMJIT_X86_FEATURE(LZCNT)
  ASMJIT_X86_FEATURE(MMX)
  ASMJIT_X86_FEATURE(MMX2)
  ASMJIT_X86_FEATURE(MONITOR)
  ASMJIT_X86_FEATURE(MONITORX)
  ASMJIT_X86_FEATURE(MOVBE)
  ASMJIT_X86_FEATURE(MPX)
  ASMJIT_X86_FEATURE(MSR)
  ASMJIT_X86_FEATURE(MSSE)
  ASMJIT_X86_FEATURE(OSXSAVE)
  ASMJIT_X86_FEATURE(PCLMULQDQ)
  ASMJIT_X86_FEATURE(PCOMMIT)
  ASMJIT_X86_FEATURE(POPCNT)
  ASMJIT_X86_FEATURE(PREFETCHW)
  ASMJIT_X86_FEATURE(PREFETCHWT1)
  ASMJIT_X86_FEATURE(RDRAND)
  ASMJIT_X86_FEATURE(RDSEED)
  ASMJIT_X86_FEATURE(RDTSC)
  ASMJIT_X86_FEATURE(RDTSCP)
  ASMJIT_X86_FEATURE(RTM)
  ASMJIT_X86_FEATURE(SHA)
  ASMJIT_X86_FEATURE(SKINIT)
  ASMJIT_X86_FEATURE(SMAP)
  ASMJIT_X86_FEATURE(SMEP)
  ASMJIT_X86_FEATURE(SMX)
  ASMJIT_X86_FEATURE(SSE)
  ASMJIT_X86_FEATURE(SSE2)
  ASMJIT_X86_FEATURE(SSE3)
  ASMJIT_X86_FEATURE(SSSE3)
  ASMJIT_X86_FEATURE(SSE4A)
  ASMJIT_X86_FEATURE(SSE4_1)
  ASMJIT_X86_FEATURE(SSE4_2)
  ASMJIT_X86_FEATURE(SVM)
  ASMJIT_X86_FEATURE(TBM)
  ASMJIT_X86_FEATURE(TSX)
  ASMJIT_X86_FEATURE(XSAVE)
  ASMJIT_X86_FEATURE(XSAVEC)
  ASMJIT_X86_FEATURE(XSAVEOPT)
  ASMJIT_X86_FEATURE(XSAVES)
  ASMJIT_X86_FEATURE(VAES)
  ASMJIT_X86_FEATURE(VMX)
  ASMJIT_X86_FEATURE(VPCLMULQDQ)
  ASMJIT_X86_FEATURE(XOP)

  #undef ASMJIT_X86_FEATURE

  // --------------------------------------------------------------------------
  // [Operator Overload]
  // --------------------------------------------------------------------------

  inline Features& operator=(const Features& other) noexcept = default;
};

//! \}

ASMJIT_END_SUB_NAMESPACE

// [Guard]
#endif // _ASMJIT_X86_X86FEATURES_H

```

`Avanguard/AsmJit/asmjit/x86/x86globals.h`:

```h
// [AsmJit]
// Complete x86/x64 JIT and Remote Assembler for C++.
//
// [License]
// ZLIB - See LICENSE.md file in the package.

// [Guard]
#ifndef _ASMJIT_X86_X86GLOBALS_H
#define _ASMJIT_X86_X86GLOBALS_H

// [Dependencies]
#include "../core/arch.h"
#include "../core/inst.h"

ASMJIT_BEGIN_SUB_NAMESPACE(x86)

//! \addtogroup asmjit_x86_api
//! \{

// ============================================================================
// [asmjit::x86::Cond]
// ============================================================================

namespace Cond {
  //! Condition code.
  enum Value : uint32_t {
    kO                    = 0x00u,       //!<                 OF==1
    kNO                   = 0x01u,       //!<                 OF==0
    kB                    = 0x02u,       //!< CF==1                  (unsigned < )
    kC                    = 0x02u,       //!< CF==1
    kNAE                  = 0x02u,       //!< CF==1                  (unsigned < )
    kAE                   = 0x03u,       //!< CF==0                  (unsigned >=)
    kNB                   = 0x03u,       //!< CF==0                  (unsigned >=)
    kNC                   = 0x03u,       //!< CF==0
    kE                    = 0x04u,       //!<         ZF==1          (any_sign ==)
    kZ                    = 0x04u,       //!<         ZF==1          (any_sign ==)
    kNE                   = 0x05u,       //!<         ZF==0          (any_sign !=)
    kNZ                   = 0x05u,       //!<         ZF==0          (any_sign !=)
    kBE                   = 0x06u,       //!< CF==1 | ZF==1          (unsigned <=)
    kNA                   = 0x06u,       //!< CF==1 | ZF==1          (unsigned <=)
    kA                    = 0x07u,       //!< CF==0 & ZF==0          (unsigned > )
    kNBE                  = 0x07u,       //!< CF==0 & ZF==0          (unsigned > )
    kS                    = 0x08u,       //!<                 SF==1  (is negative)
    kNS                   = 0x09u,       //!<                 SF==0  (is positive or zero)
    kP                    = 0x0Au,       //!< PF==1
    kPE                   = 0x0Au,       //!< PF==1
    kPO                   = 0x0Bu,       //!< PF==0
    kNP                   = 0x0Bu,       //!< PF==0
    kL                    = 0x0Cu,       //!<                 SF!=OF (signed   < )
    kNGE                  = 0x0Cu,       //!<                 SF!=OF (signed   < )
    kGE                   = 0x0Du,       //!<                 SF==OF (signed   >=)
    kNL                   = 0x0Du,       //!<                 SF==OF (signed   >=)
    kLE                   = 0x0Eu,       //!<         ZF==1 | SF!=OF (signed   <=)
    kNG                   = 0x0Eu,       //!<         ZF==1 | SF!=OF (signed   <=)
    kG                    = 0x0Fu,       //!<         ZF==0 & SF==OF (signed   > )
    kNLE                  = 0x0Fu,       //!<         ZF==0 & SF==OF (signed   > )
    kCount                = 0x10u,

    kSign                 = kS,          //!< Sign.
    kNotSign              = kNS,         //!< Not Sign.

    kOverflow             = kO,          //!< Signed overflow.
    kNotOverflow          = kNO,         //!< Not signed overflow.

    kEqual                = kE,          //!< Equal      `a == b`.
    kNotEqual             = kNE,         //!< Not Equal  `a != b`.

    kSignedLT             = kL,          //!< Signed     `a <  b`.
    kSignedLE             = kLE,         //!< Signed     `a <= b`.
    kSignedGT             = kG,          //!< Signed     `a >  b`.
    kSignedGE             = kGE,         //!< Signed     `a >= b`.

    kUnsignedLT           = kB,          //!< Unsigned   `a <  b`.
    kUnsignedLE           = kBE,         //!< Unsigned   `a <= b`.
    kUnsignedGT           = kA,          //!< Unsigned   `a >  b`.
    kUnsignedGE           = kAE,         //!< Unsigned   `a >= b`.

    kZero                 = kZ,
    kNotZero              = kNZ,

    kNegative             = kS,
    kPositive             = kNS,

    kParityEven           = kP,
    kParityOdd            = kPO
  };

  static constexpr uint8_t reverseTable[kCount] = {
    kO, kNO, kA , kBE, // O|NO|B |AE
    kE, kNE, kAE, kB , // E|NE|BE|A
    kS, kNS, kPE, kPO, // S|NS|PE|PO
    kG, kLE, kGE, kL   // L|GE|LE|G
  };

  //! Reverse a condition code (reverses the corresponding operands of a comparison).
  static constexpr uint32_t reverse(uint32_t cond) noexcept { return reverseTable[cond]; }
  //! Negate a condition code.
  static constexpr uint32_t negate(uint32_t cond) noexcept { return cond ^ 1u; }
}

// ============================================================================
// [asmjit::x86::Inst]
// ============================================================================

//! Instruction (X86).
//!
//! NOTE: Only used to hold x86-specific enumerations and static functions.
struct Inst : public BaseInst {
  //! Instruction id (X86).
  enum Id : uint32_t {
    // ${InstId:Begin}
    kIdNone = 0,
    kIdAaa,                              // [X86]
    kIdAad,                              // [X86]
    kIdAam,                              // [X86]
    kIdAas,                              // [X86]
    kIdAdc,                              // [ANY]
    kIdAdcx,                             // [ANY] {ADX}
    kIdAdd,                              // [ANY]
    kIdAddpd,                            // [ANY] {SSE2}
    kIdAddps,                            // [ANY] {SSE}
    kIdAddsd,                            // [ANY] {SSE2}
    kIdAddss,                            // [ANY] {SSE}
    kIdAddsubpd,                         // [ANY] {SSE3}
    kIdAddsubps,                         // [ANY] {SSE3}
    kIdAdox,                             // [ANY] {ADX}
    kIdAesdec,                           // [ANY] {AESNI}
    kIdAesdeclast,                       // [ANY] {AESNI}
    kIdAesenc,                           // [ANY] {AESNI}
    kIdAesenclast,                       // [ANY] {AESNI}
    kIdAesimc,                           // [ANY] {AESNI}
    kIdAeskeygenassist,                  // [ANY] {AESNI}
    kIdAnd,                              // [ANY]
    kIdAndn,                             // [ANY] {BMI}
    kIdAndnpd,                           // [ANY] {SSE2}
    kIdAndnps,                           // [ANY] {SSE}
    kIdAndpd,                            // [ANY] {SSE2}
    kIdAndps,                            // [ANY] {SSE}
    kIdArpl,                             // [X86]
    kIdBextr,                            // [ANY] {BMI}
    kIdBlcfill,                          // [ANY] {TBM}
    kIdBlci,                             // [ANY] {TBM}
    kIdBlcic,                            // [ANY] {TBM}
    kIdBlcmsk,                           // [ANY] {TBM}
    kIdBlcs,                             // [ANY] {TBM}
    kIdBlendpd,                          // [ANY] {SSE4_1}
    kIdBlendps,                          // [ANY] {SSE4_1}
    kIdBlendvpd,                         // [ANY] {SSE4_1}
    kIdBlendvps,                         // [ANY] {SSE4_1}
    kIdBlsfill,                          // [ANY] {TBM}
    kIdBlsi,                             // [ANY] {BMI}
    kIdBlsic,                            // [ANY] {TBM}
    kIdBlsmsk,                           // [ANY] {BMI}
    kIdBlsr,                             // [ANY] {BMI}
    kIdBndcl,                            // [ANY] {MPX}
    kIdBndcn,                            // [ANY] {MPX}
    kIdBndcu,                            // [ANY] {MPX}
    kIdBndldx,                           // [ANY] {MPX}
    kIdBndmk,                            // [ANY] {MPX}
    kIdBndmov,                           // [ANY] {MPX}
    kIdBndstx,                           // [ANY] {MPX}
    kIdBound,                            // [X86]
    kIdBsf,                              // [ANY]
    kIdBsr,                              // [ANY]
    kIdBswap,                            // [ANY]
    kIdBt,                               // [ANY]
    kIdBtc,                              // [ANY]
    kIdBtr,                              // [ANY]
    kIdBts,                              // [ANY]
    kIdBzhi,                             // [ANY] {BMI2}
    kIdCall,                             // [ANY]
    kIdCbw,                              // [ANY]
    kIdCdq,                              // [ANY]
    kIdCdqe,                             // [X64]
    kIdClac,                             // [ANY] {SMAP}
    kIdClc,                              // [ANY]
    kIdCld,                              // [ANY]
    kIdClflush,                          // [ANY] {CLFLUSH}
    kIdClflushopt,                       // [ANY] {CLFLUSHOPT}
    kIdCli,                              // [ANY]
    kIdClts,                             // [ANY]
    kIdClwb,                             // [ANY] {CLWB}
    kIdClzero,                           // [ANY] {CLZERO}
    kIdCmc,                              // [ANY]
    kIdCmova,                            // [ANY] {CMOV}
    kIdCmovae,                           // [ANY] {CMOV}
    kIdCmovb,                            // [ANY] {CMOV}
    kIdCmovbe,                           // [ANY] {CMOV}
    kIdCmovc,                            // [ANY] {CMOV}
    kIdCmove,                            // [ANY] {CMOV}
    kIdCmovg,                            // [ANY] {CMOV}
    kIdCmovge,                           // [ANY] {CMOV}
    kIdCmovl,                            // [ANY] {CMOV}
    kIdCmovle,                           // [ANY] {CMOV}
    kIdCmovna,                           // [ANY] {CMOV}
    kIdCmovnae,                          // [ANY] {CMOV}
    kIdCmovnb,                           // [ANY] {CMOV}
    kIdCmovnbe,                          // [ANY] {CMOV}
    kIdCmovnc,                           // [ANY] {CMOV}
    kIdCmovne,                           // [ANY] {CMOV}
    kIdCmovng,                           // [ANY] {CMOV}
    kIdCmovnge,                          // [ANY] {CMOV}
    kIdCmovnl,                           // [ANY] {CMOV}
    kIdCmovnle,                          // [ANY] {CMOV}
    kIdCmovno,                           // [ANY] {CMOV}
    kIdCmovnp,                           // [ANY] {CMOV}
    kIdCmovns,                           // [ANY] {CMOV}
    kIdCmovnz,                           // [ANY] {CMOV}
    kIdCmovo,                            // [ANY] {CMOV}
    kIdCmovp,                            // [ANY] {CMOV}
    kIdCmovpe,                           // [ANY] {CMOV}
    kIdCmovpo,                           // [ANY] {CMOV}
    kIdCmovs,                            // [ANY] {CMOV}
    kIdCmovz,                            // [ANY] {CMOV}
    kIdCmp,                              // [ANY]
    kIdCmppd,                            // [ANY] {SSE2}
    kIdCmpps,                            // [ANY] {SSE}
    kIdCmps,                             // [ANY]
    kIdCmpsd,                            // [ANY] {SSE2}
    kIdCmpss,                            // [ANY] {SSE}
    kIdCmpxchg,                          // [ANY] {I486}
    kIdCmpxchg16b,                       // [X64] {CMPXCHG16B}
    kIdCmpxchg8b,                        // [ANY] {CMPXCHG8B}
    kIdComisd,                           // [ANY] {SSE2}
    kIdComiss,                           // [ANY] {SSE}
    kIdCpuid,                            // [ANY] {I486}
    kIdCqo,                              // [X64]
    kIdCrc32,                            // [ANY] {SSE4_2}
    kIdCvtdq2pd,                         // [ANY] {SSE2}
    kIdCvtdq2ps,                         // [ANY] {SSE2}
    kIdCvtpd2dq,                         // [ANY] {SSE2}
    kIdCvtpd2pi,                         // [ANY] {SSE2}
    kIdCvtpd2ps,                         // [ANY] {SSE2}
    kIdCvtpi2pd,                         // [ANY] {SSE2}
    kIdCvtpi2ps,                         // [ANY] {SSE}
    kIdCvtps2dq,                         // [ANY] {SSE2}
    kIdCvtps2pd,                         // [ANY] {SSE2}
    kIdCvtps2pi,                         // [ANY] {SSE}
    kIdCvtsd2si,                         // [ANY] {SSE2}
    kIdCvtsd2ss,                         // [ANY] {SSE2}
    kIdCvtsi2sd,                         // [ANY] {SSE2}
    kIdCvtsi2ss,                         // [ANY] {SSE}
    kIdCvtss2sd,                         // [ANY] {SSE2}
    kIdCvtss2si,                         // [ANY] {SSE}
    kIdCvttpd2dq,                        // [ANY] {SSE2}
    kIdCvttpd2pi,                        // [ANY] {SSE2}
    kIdCvttps2dq,                        // [ANY] {SSE2}
    kIdCvttps2pi,                        // [ANY] {SSE}
    kIdCvttsd2si,                        // [ANY] {SSE2}
    kIdCvttss2si,                        // [ANY] {SSE}
    kIdCwd,                              // [ANY]
    kIdCwde,                             // [ANY]
    kIdDaa,                              // [X86]
    kIdDas,                              // [X86]
    kIdDec,                              // [ANY]
    kIdDiv,                              // [ANY]
    kIdDivpd,                            // [ANY] {SSE2}
    kIdDivps,                            // [ANY] {SSE}
    kIdDivsd,                            // [ANY] {SSE2}
    kIdDivss,                            // [ANY] {SSE}
    kIdDppd,                             // [ANY] {SSE4_1}
    kIdDpps,                             // [ANY] {SSE4_1}
    kIdEmms,                             // [ANY] {MMX}
    kIdEnter,                            // [ANY]
    kIdExtractps,                        // [ANY] {SSE4_1}
    kIdExtrq,                            // [ANY] {SSE4A}
    kIdF2xm1,                            // [ANY]
    kIdFabs,                             // [ANY]
    kIdFadd,                             // [ANY]
    kIdFaddp,                            // [ANY]
    kIdFbld,                             // [ANY]
    kIdFbstp,                            // [ANY]
    kIdFchs,                             // [ANY]
    kIdFclex,                            // [ANY]
    kIdFcmovb,                           // [ANY] {CMOV}
    kIdFcmovbe,                          // [ANY] {CMOV}
    kIdFcmove,                           // [ANY] {CMOV}
    kIdFcmovnb,                          // [ANY] {CMOV}
    kIdFcmovnbe,                         // [ANY] {CMOV}
    kIdFcmovne,                          // [ANY] {CMOV}
    kIdFcmovnu,                          // [ANY] {CMOV}
    kIdFcmovu,                           // [ANY] {CMOV}
    kIdFcom,                             // [ANY]
    kIdFcomi,                            // [ANY]
    kIdFcomip,                           // [ANY]
    kIdFcomp,                            // [ANY]
    kIdFcompp,                           // [ANY]
    kIdFcos,                             // [ANY]
    kIdFdecstp,                          // [ANY]
    kIdFdiv,                             // [ANY]
    kIdFdivp,                            // [ANY]
    kIdFdivr,                            // [ANY]
    kIdFdivrp,                           // [ANY]
    kIdFemms,                            // [ANY] {3DNOW}
    kIdFfree,                            // [ANY]
    kIdFiadd,                            // [ANY]
    kIdFicom,                            // [ANY]
    kIdFicomp,                           // [ANY]
    kIdFidiv,                            // [ANY]
    kIdFidivr,                           // [ANY]
    kIdFild,                             // [ANY]
    kIdFimul,                            // [ANY]
    kIdFincstp,                          // [ANY]
    kIdFinit,                            // [ANY]
    kIdFist,                             // [ANY]
    kIdFistp,                            // [ANY]
    kIdFisttp,                           // [ANY] {SSE3}
    kIdFisub,                            // [ANY]
    kIdFisubr,                           // [ANY]
    kIdFld,                              // [ANY]
    kIdFld1,                             // [ANY]
    kIdFldcw,                            // [ANY]
    kIdFldenv,                           // [ANY]
    kIdFldl2e,                           // [ANY]
    kIdFldl2t,                           // [ANY]
    kIdFldlg2,                           // [ANY]
    kIdFldln2,                           // [ANY]
    kIdFldpi,                            // [ANY]
    kIdFldz,                             // [ANY]
    kIdFmul,                             // [ANY]
    kIdFmulp,                            // [ANY]
    kIdFnclex,                           // [ANY]
    kIdFninit,                           // [ANY]
    kIdFnop,                             // [ANY]
    kIdFnsave,                           // [ANY]
    kIdFnstcw,                           // [ANY]
    kIdFnstenv,                          // [ANY]
    kIdFnstsw,                           // [ANY]
    kIdFpatan,                           // [ANY]
    kIdFprem,                            // [ANY]
    kIdFprem1,                           // [ANY]
    kIdFptan,                            // [ANY]
    kIdFrndint,                          // [ANY]
    kIdFrstor,                           // [ANY]
    kIdFsave,                            // [ANY]
    kIdFscale,                           // [ANY]
    kIdFsin,                             // [ANY]
    kIdFsincos,                          // [ANY]
    kIdFsqrt,                            // [ANY]
    kIdFst,                              // [ANY]
    kIdFstcw,                            // [ANY]
    kIdFstenv,                           // [ANY]
    kIdFstp,                             // [ANY]
    kIdFstsw,                            // [ANY]
    kIdFsub,                             // [ANY]
    kIdFsubp,                            // [ANY]
    kIdFsubr,                            // [ANY]
    kIdFsubrp,                           // [ANY]
    kIdFtst,                             // [ANY]
    kIdFucom,                            // [ANY]
    kIdFucomi,                           // [ANY]
    kIdFucomip,                          // [ANY]
    kIdFucomp,                           // [ANY]
    kIdFucompp,                          // [ANY]
    kIdFwait,                            // [ANY]
    kIdFxam,                             // [ANY]
    kIdFxch,                             // [ANY]
    kIdFxrstor,                          // [ANY] {FXSR}
    kIdFxrstor64,                        // [X64] {FXSR}
    kIdFxsave,                           // [ANY] {FXSR}
    kIdFxsave64,                         // [X64] {FXSR}
    kIdFxtract,                          // [ANY]
    kIdFyl2x,                            // [ANY]
    kIdFyl2xp1,                          // [ANY]
    kIdHaddpd,                           // [ANY] {SSE3}
    kIdHaddps,                           // [ANY] {SSE3}
    kIdHlt,                              // [ANY]
    kIdHsubpd,                           // [ANY] {SSE3}
    kIdHsubps,                           // [ANY] {SSE3}
    kIdIdiv,                             // [ANY]
    kIdImul,                             // [ANY]
    kIdIn,                               // [ANY]
    kIdInc,                              // [ANY]
    kIdIns,                              // [ANY]
    kIdInsertps,                         // [ANY] {SSE4_1}
    kIdInsertq,                          // [ANY] {SSE4A}
    kIdInt,                              // [ANY]
    kIdInt3,                             // [ANY]
    kIdInto,                             // [X86]
    kIdInvd,                             // [ANY] {I486}
    kIdInvlpg,                           // [ANY] {I486}
    kIdInvpcid,                          // [ANY] {I486}
    kIdIret,                             // [ANY]
    kIdIretd,                            // [ANY]
    kIdIretq,                            // [X64]
    kIdIretw,                            // [ANY]
    kIdJa,                               // [ANY]
    kIdJae,                              // [ANY]
    kIdJb,                               // [ANY]
    kIdJbe,                              // [ANY]
    kIdJc,                               // [ANY]
    kIdJe,                               // [ANY]
    kIdJecxz,                            // [ANY]
    kIdJg,                               // [ANY]
    kIdJge,                              // [ANY]
    kIdJl,                               // [ANY]
    kIdJle,                              // [ANY]
    kIdJmp,                              // [ANY]
    kIdJna,                              // [ANY]
    kIdJnae,                             // [ANY]
    kIdJnb,                              // [ANY]
    kIdJnbe,                             // [ANY]
    kIdJnc,                              // [ANY]
    kIdJne,                              // [ANY]
    kIdJng,                              // [ANY]
    kIdJnge,                             // [ANY]
    kIdJnl,                              // [ANY]
    kIdJnle,                             // [ANY]
    kIdJno,                              // [ANY]
    kIdJnp,                              // [ANY]
    kIdJns,                              // [ANY]
    kIdJnz,                              // [ANY]
    kIdJo,                               // [ANY]
    kIdJp,                               // [ANY]
    kIdJpe,                              // [ANY]
    kIdJpo,                              // [ANY]
    kIdJs,                               // [ANY]
    kIdJz,                               // [ANY]
    kIdKaddb,                            // [ANY] {AVX512_DQ}
    kIdKaddd,                            // [ANY] {AVX512_BW}
    kIdKaddq,                            // [ANY] {AVX512_BW}
    kIdKaddw,                            // [ANY] {AVX512_DQ}
    kIdKandb,                            // [ANY] {AVX512_DQ}
    kIdKandd,                            // [ANY] {AVX512_BW}
    kIdKandnb,                           // [ANY] {AVX512_DQ}
    kIdKandnd,                           // [ANY] {AVX512_BW}
    kIdKandnq,                           // [ANY] {AVX512_BW}
    kIdKandnw,                           // [ANY] {AVX512_F}
    kIdKandq,                            // [ANY] {AVX512_BW}
    kIdKandw,                            // [ANY] {AVX512_F}
    kIdKmovb,                            // [ANY] {AVX512_DQ}
    kIdKmovd,                            // [ANY] {AVX512_BW}
    kIdKmovq,                            // [ANY] {AVX512_BW}
    kIdKmovw,                            // [ANY] {AVX512_F}
    kIdKnotb,                            // [ANY] {AVX512_DQ}
    kIdKnotd,                            // [ANY] {AVX512_BW}
    kIdKnotq,                            // [ANY] {AVX512_BW}
    kIdKnotw,                            // [ANY] {AVX512_F}
    kIdKorb,                             // [ANY] {AVX512_DQ}
    kIdKord,                             // [ANY] {AVX512_BW}
    kIdKorq,                             // [ANY] {AVX512_BW}
    kIdKortestb,                         // [ANY] {AVX512_DQ}
    kIdKortestd,                         // [ANY] {AVX512_BW}
    kIdKortestq,                         // [ANY] {AVX512_BW}
    kIdKortestw,                         // [ANY] {AVX512_F}
    kIdKorw,                             // [ANY] {AVX512_F}
    kIdKshiftlb,                         // [ANY] {AVX512_DQ}
    kIdKshiftld,                         // [ANY] {AVX512_BW}
    kIdKshiftlq,                         // [ANY] {AVX512_BW}
    kIdKshiftlw,                         // [ANY] {AVX512_F}
    kIdKshiftrb,                         // [ANY] {AVX512_DQ}
    kIdKshiftrd,                         // [ANY] {AVX512_BW}
    kIdKshiftrq,                         // [ANY] {AVX512_BW}
    kIdKshiftrw,                         // [ANY] {AVX512_F}
    kIdKtestb,                           // [ANY] {AVX512_DQ}
    kIdKtestd,                           // [ANY] {AVX512_BW}
    kIdKtestq,                           // [ANY] {AVX512_BW}
    kIdKtestw,                           // [ANY] {AVX512_DQ}
    kIdKunpckbw,                         // [ANY] {AVX512_F}
    kIdKunpckdq,                         // [ANY] {AVX512_BW}
    kIdKunpckwd,                         // [ANY] {AVX512_BW}
    kIdKxnorb,                           // [ANY] {AVX512_DQ}
    kIdKxnord,                           // [ANY] {AVX512_BW}
    kIdKxnorq,                           // [ANY] {AVX512_BW}
    kIdKxnorw,                           // [ANY] {AVX512_F}
    kIdKxorb,                            // [ANY] {AVX512_DQ}
    kIdKxord,                            // [ANY] {AVX512_BW}
    kIdKxorq,                            // [ANY] {AVX512_BW}
    kIdKxorw,                            // [ANY] {AVX512_F}
    kIdLahf,                             // [ANY] {LAHFSAHF}
    kIdLar,                              // [ANY]
    kIdLddqu,                            // [ANY] {SSE3}
    kIdLdmxcsr,                          // [ANY] {SSE}
    kIdLds,                              // [X86]
    kIdLea,                              // [ANY]
    kIdLeave,                            // [ANY]
    kIdLes,                              // [X86]
    kIdLfence,                           // [ANY] {SSE2}
    kIdLfs,                              // [ANY]
    kIdLgdt,                             // [ANY]
    kIdLgs,                              // [ANY]
    kIdLidt,                             // [ANY]
    kIdLldt,                             // [ANY]
    kIdLmsw,                             // [ANY]
    kIdLods,                             // [ANY]
    kIdLoop,                             // [ANY]
    kIdLoope,                            // [ANY]
    kIdLoopne,                           // [ANY]
    kIdLsl,                              // [ANY]
    kIdLss,                              // [ANY]
    kIdLtr,                              // [ANY]
    kIdLzcnt,                            // [ANY] {LZCNT}
    kIdMaskmovdqu,                       // [ANY] {SSE2}
    kIdMaskmovq,                         // [ANY] {MMX2}
    kIdMaxpd,                            // [ANY] {SSE2}
    kIdMaxps,                            // [ANY] {SSE}
    kIdMaxsd,                            // [ANY] {SSE2}
    kIdMaxss,                            // [ANY] {SSE}
    kIdMfence,                           // [ANY] {SSE2}
    kIdMinpd,                            // [ANY] {SSE2}
    kIdMinps,                            // [ANY] {SSE}
    kIdMinsd,                            // [ANY] {SSE2}
    kIdMinss,                            // [ANY] {SSE}
    kIdMonitor,                          // [ANY] {MONITOR}
    kIdMonitorx,                         // [ANY] {MONITORX}
    kIdMov,                              // [ANY]
    kIdMovapd,                           // [ANY] {SSE2}
    kIdMovaps,                           // [ANY] {SSE}
    kIdMovbe,                            // [ANY] {MOVBE}
    kIdMovd,                             // [ANY] {MMX|SSE2}
    kIdMovddup,                          // [ANY] {SSE3}
    kIdMovdq2q,                          // [ANY] {SSE2}
    kIdMovdqa,                           // [ANY] {SSE2}
    kIdMovdqu,                           // [ANY] {SSE2}
    kIdMovhlps,                          // [ANY] {SSE}
    kIdMovhpd,                           // [ANY] {SSE2}
    kIdMovhps,                           // [ANY] {SSE}
    kIdMovlhps,                          // [ANY] {SSE}
    kIdMovlpd,                           // [ANY] {SSE2}
    kIdMovlps,                           // [ANY] {SSE}
    kIdMovmskpd,                         // [ANY] {SSE2}
    kIdMovmskps,                         // [ANY] {SSE}
    kIdMovntdq,                          // [ANY] {SSE2}
    kIdMovntdqa,                         // [ANY] {SSE4_1}
    kIdMovnti,                           // [ANY] {SSE2}
    kIdMovntpd,                          // [ANY] {SSE2}
    kIdMovntps,                          // [ANY] {SSE}
    kIdMovntq,                           // [ANY] {MMX2}
    kIdMovntsd,                          // [ANY] {SSE4A}
    kIdMovntss,                          // [ANY] {SSE4A}
    kIdMovq,                             // [ANY] {MMX|SSE2}
    kIdMovq2dq,                          // [ANY] {SSE2}
    kIdMovs,                             // [ANY]
    kIdMovsd,                            // [ANY] {SSE2}
    kIdMovshdup,                         // [ANY] {SSE3}
    kIdMovsldup,                         // [ANY] {SSE3}
    kIdMovss,                            // [ANY] {SSE}
    kIdMovsx,                            // [ANY]
    kIdMovsxd,                           // [X64]
    kIdMovupd,                           // [ANY] {SSE2}
    kIdMovups,                           // [ANY] {SSE}
    kIdMovzx,                            // [ANY]
    kIdMpsadbw,                          // [ANY] {SSE4_1}
    kIdMul,                              // [ANY]
    kIdMulpd,                            // [ANY] {SSE2}
    kIdMulps,                            // [ANY] {SSE}
    kIdMulsd,                            // [ANY] {SSE2}
    kIdMulss,                            // [ANY] {SSE}
    kIdMulx,                             // [ANY] {BMI2}
    kIdMwait,                            // [ANY] {MONITOR}
    kIdMwaitx,                           // [ANY] {MONITORX}
    kIdNeg,                              // [ANY]
    kIdNop,                              // [ANY]
    kIdNot,                              // [ANY]
    kIdOr,                               // [ANY]
    kIdOrpd,                             // [ANY] {SSE2}
    kIdOrps,                             // [ANY] {SSE}
    kIdOut,                              // [ANY]
    kIdOuts,                             // [ANY]
    kIdPabsb,                            // [ANY] {SSSE3}
    kIdPabsd,                            // [ANY] {SSSE3}
    kIdPabsw,                            // [ANY] {SSSE3}
    kIdPackssdw,                         // [ANY] {MMX|SSE2}
    kIdPacksswb,                         // [ANY] {MMX|SSE2}
    kIdPackusdw,                         // [ANY] {SSE4_1}
    kIdPackuswb,                         // [ANY] {MMX|SSE2}
    kIdPaddb,                            // [ANY] {MMX|SSE2}
    kIdPaddd,                            // [ANY] {MMX|SSE2}
    kIdPaddq,                            // [ANY] {SSE2}
    kIdPaddsb,                           // [ANY] {MMX|SSE2}
    kIdPaddsw,                           // [ANY] {MMX|SSE2}
    kIdPaddusb,                          // [ANY] {MMX|SSE2}
    kIdPaddusw,                          // [ANY] {MMX|SSE2}
    kIdPaddw,                            // [ANY] {MMX|SSE2}
    kIdPalignr,                          // [ANY] {SSE3}
    kIdPand,                             // [ANY] {MMX|SSE2}
    kIdPandn,                            // [ANY] {MMX|SSE2}
    kIdPause,                            // [ANY]
    kIdPavgb,                            // [ANY] {MMX2|SSE2}
    kIdPavgusb,                          // [ANY] {3DNOW}
    kIdPavgw,                            // [ANY] {MMX2|SSE2}
    kIdPblendvb,                         // [ANY] {SSE4_1}
    kIdPblendw,                          // [ANY] {SSE4_1}
    kIdPclmulqdq,                        // [ANY] {PCLMULQDQ}
    kIdPcmpeqb,                          // [ANY] {MMX|SSE2}
    kIdPcmpeqd,                          // [ANY] {MMX|SSE2}
    kIdPcmpeqq,                          // [ANY] {SSE4_1}
    kIdPcmpeqw,                          // [ANY] {MMX|SSE2}
    kIdPcmpestri,                        // [ANY] {SSE4_2}
    kIdPcmpestrm,                        // [ANY] {SSE4_2}
    kIdPcmpgtb,                          // [ANY] {MMX|SSE2}
    kIdPcmpgtd,                          // [ANY] {MMX|SSE2}
    kIdPcmpgtq,                          // [ANY] {SSE4_2}
    kIdPcmpgtw,                          // [ANY] {MMX|SSE2}
    kIdPcmpistri,                        // [ANY] {SSE4_2}
    kIdPcmpistrm,                        // [ANY] {SSE4_2}
    kIdPcommit,                          // [ANY] {PCOMMIT}
    kIdPdep,                             // [ANY] {BMI2}
    kIdPext,                             // [ANY] {BMI2}
    kIdPextrb,                           // [ANY] {SSE4_1}
    kIdPextrd,                           // [ANY] {SSE4_1}
    kIdPextrq,                           // [X64] {SSE4_1}
    kIdPextrw,                           // [ANY] {MMX2|SSE2|SSE4_1}
    kIdPf2id,                            // [ANY] {3DNOW}
    kIdPf2iw,                            // [ANY] {3DNOW2}
    kIdPfacc,                            // [ANY] {3DNOW}
    kIdPfadd,                            // [ANY] {3DNOW}
    kIdPfcmpeq,                          // [ANY] {3DNOW}
    kIdPfcmpge,                          // [ANY] {3DNOW}
    kIdPfcmpgt,                          // [ANY] {3DNOW}
    kIdPfmax,                            // [ANY] {3DNOW}
    kIdPfmin,                            // [ANY] {3DNOW}
    kIdPfmul,                            // [ANY] {3DNOW}
    kIdPfnacc,                           // [ANY] {3DNOW2}
    kIdPfpnacc,                          // [ANY] {3DNOW2}
    kIdPfrcp,                            // [ANY] {3DNOW}
    kIdPfrcpit1,                         // [ANY] {3DNOW}
    kIdPfrcpit2,                         // [ANY] {3DNOW}
    kIdPfrcpv,                           // [ANY] {GEODE}
    kIdPfrsqit1,                         // [ANY] {3DNOW}
    kIdPfrsqrt,                          // [ANY] {3DNOW}
    kIdPfrsqrtv,                         // [ANY] {GEODE}
    kIdPfsub,                            // [ANY] {3DNOW}
    kIdPfsubr,                           // [ANY] {3DNOW}
    kIdPhaddd,                           // [ANY] {SSSE3}
    kIdPhaddsw,                          // [ANY] {SSSE3}
    kIdPhaddw,                           // [ANY] {SSSE3}
    kIdPhminposuw,                       // [ANY] {SSE4_1}
    kIdPhsubd,                           // [ANY] {SSSE3}
    kIdPhsubsw,                          // [ANY] {SSSE3}
    kIdPhsubw,                           // [ANY] {SSSE3}
    kIdPi2fd,                            // [ANY] {3DNOW}
    kIdPi2fw,                            // [ANY] {3DNOW2}
    kIdPinsrb,                           // [ANY] {SSE4_1}
    kIdPinsrd,                           // [ANY] {SSE4_1}
    kIdPinsrq,                           // [X64] {SSE4_1}
    kIdPinsrw,                           // [ANY] {MMX2|SSE2}
    kIdPmaddubsw,                        // [ANY] {SSSE3}
    kIdPmaddwd,                          // [ANY] {MMX|SSE2}
    kIdPmaxsb,                           // [ANY] {SSE4_1}
    kIdPmaxsd,                           // [ANY] {SSE4_1}
    kIdPmaxsw,                           // [ANY] {MMX2|SSE2}
    kIdPmaxub,                           // [ANY] {MMX2|SSE2}
    kIdPmaxud,                           // [ANY] {SSE4_1}
    kIdPmaxuw,                           // [ANY] {SSE4_1}
    kIdPminsb,                           // [ANY] {SSE4_1}
    kIdPminsd,                           // [ANY] {SSE4_1}
    kIdPminsw,                           // [ANY] {MMX2|SSE2}
    kIdPminub,                           // [ANY] {MMX2|SSE2}
    kIdPminud,                           // [ANY] {SSE4_1}
    kIdPminuw,                           // [ANY] {SSE4_1}
    kIdPmovmskb,                         // [ANY] {MMX2|SSE2}
    kIdPmovsxbd,                         // [ANY] {SSE4_1}
    kIdPmovsxbq,                         // [ANY] {SSE4_1}
    kIdPmovsxbw,                         // [ANY] {SSE4_1}
    kIdPmovsxdq,                         // [ANY] {SSE4_1}
    kIdPmovsxwd,                         // [ANY] {SSE4_1}
    kIdPmovsxwq,                         // [ANY] {SSE4_1}
    kIdPmovzxbd,                         // [ANY] {SSE4_1}
    kIdPmovzxbq,                         // [ANY] {SSE4_1}
    kIdPmovzxbw,                         // [ANY] {SSE4_1}
    kIdPmovzxdq,                         // [ANY] {SSE4_1}
    kIdPmovzxwd,                         // [ANY] {SSE4_1}
    kIdPmovzxwq,                         // [ANY] {SSE4_1}
    kIdPmuldq,                           // [ANY] {SSE4_1}
    kIdPmulhrsw,                         // [ANY] {SSSE3}
    kIdPmulhrw,                          // [ANY] {3DNOW}
    kIdPmulhuw,                          // [ANY] {MMX2|SSE2}
    kIdPmulhw,                           // [ANY] {MMX|SSE2}
    kIdPmulld,                           // [ANY] {SSE4_1}
    kIdPmullw,                           // [ANY] {MMX|SSE2}
    kIdPmuludq,                          // [ANY] {SSE2}
    kIdPop,                              // [ANY]
    kIdPopa,                             // [X86]
    kIdPopad,                            // [X86]
    kIdPopcnt,                           // [ANY] {POPCNT}
    kIdPopf,                             // [ANY]
    kIdPopfd,                            // [X86]
    kIdPopfq,                            // [X64]
    kIdPor,                              // [ANY] {MMX|SSE2}
    kIdPrefetch,                         // [ANY] {3DNOW}
    kIdPrefetchnta,                      // [ANY] {MMX2}
    kIdPrefetcht0,                       // [ANY] {MMX2}
    kIdPrefetcht1,                       // [ANY] {MMX2}
    kIdPrefetcht2,                       // [ANY] {MMX2}
    kIdPrefetchw,                        // [ANY] {PREFETCHW}
    kIdPrefetchwt1,                      // [ANY] {PREFETCHWT1}
    kIdPsadbw,                           // [ANY] {MMX2|SSE2}
    kIdPshufb,                           // [ANY] {SSSE3}
    kIdPshufd,                           // [ANY] {SSE2}
    kIdPshufhw,                          // [ANY] {SSE2}
    kIdPshuflw,                          // [ANY] {SSE2}
    kIdPshufw,                           // [ANY] {MMX2}
    kIdPsignb,                           // [ANY] {SSSE3}
    kIdPsignd,                           // [ANY] {SSSE3}
    kIdPsignw,                           // [ANY] {SSSE3}
    kIdPslld,                            // [ANY] {MMX|SSE2}
    kIdPslldq,                           // [ANY] {SSE2}
    kIdPsllq,                            // [ANY] {MMX|SSE2}
    kIdPsllw,                            // [ANY] {MMX|SSE2}
    kIdPsrad,                            // [ANY] {MMX|SSE2}
    kIdPsraw,                            // [ANY] {MMX|SSE2}
    kIdPsrld,                            // [ANY] {MMX|SSE2}
    kIdPsrldq,                           // [ANY] {SSE2}
    kIdPsrlq,                            // [ANY] {MMX|SSE2}
    kIdPsrlw,                            // [ANY] {MMX|SSE2}
    kIdPsubb,                            // [ANY] {MMX|SSE2}
    kIdPsubd,                            // [ANY] {MMX|SSE2}
    kIdPsubq,                            // [ANY] {SSE2}
    kIdPsubsb,                           // [ANY] {MMX|SSE2}
    kIdPsubsw,                           // [ANY] {MMX|SSE2}
    kIdPsubusb,                          // [ANY] {MMX|SSE2}
    kIdPsubusw,                          // [ANY] {MMX|SSE2}
    kIdPsubw,                            // [ANY] {MMX|SSE2}
    kIdPswapd,                           // [ANY] {3DNOW2}
    kIdPtest,                            // [ANY] {SSE4_1}
    kIdPunpckhbw,                        // [ANY] {MMX|SSE2}
    kIdPunpckhdq,                        // [ANY] {MMX|SSE2}
    kIdPunpckhqdq,                       // [ANY] {SSE2}
    kIdPunpckhwd,                        // [ANY] {MMX|SSE2}
    kIdPunpcklbw,                        // [ANY] {MMX|SSE2}
    kIdPunpckldq,                        // [ANY] {MMX|SSE2}
    kIdPunpcklqdq,                       // [ANY] {SSE2}
    kIdPunpcklwd,                        // [ANY] {MMX|SSE2}
    kIdPush,                             // [ANY]
    kIdPusha,                            // [X86]
    kIdPushad,                           // [X86]
    kIdPushf,                            // [ANY]
    kIdPushfd,                           // [X86]
    kIdPushfq,                           // [X64]
    kIdPxor,                             // [ANY] {MMX|SSE2}
    kIdRcl,                              // [ANY]
    kIdRcpps,                            // [ANY] {SSE}
    kIdRcpss,                            // [ANY] {SSE}
    kIdRcr,                              // [ANY]
    kIdRdfsbase,                         // [X64] {FSGSBASE}
    kIdRdgsbase,                         // [X64] {FSGSBASE}
    kIdRdmsr,                            // [ANY] {MSR}
    kIdRdpmc,                            // [ANY]
    kIdRdrand,                           // [ANY] {RDRAND}
    kIdRdseed,                           // [ANY] {RDSEED}
    kIdRdtsc,                            // [ANY] {RDTSC}
    kIdRdtscp,                           // [ANY] {RDTSCP}
    kIdRet,                              // [ANY]
    kIdRol,                              // [ANY]
    kIdRor,                              // [ANY]
    kIdRorx,                             // [ANY] {BMI2}
    kIdRoundpd,                          // [ANY] {SSE4_1}
    kIdRoundps,                          // [ANY] {SSE4_1}
    kIdRoundsd,                          // [ANY] {SSE4_1}
    kIdRoundss,                          // [ANY] {SSE4_1}
    kIdRsm,                              // [X86]
    kIdRsqrtps,                          // [ANY] {SSE}
    kIdRsqrtss,                          // [ANY] {SSE}
    kIdSahf,                             // [ANY] {LAHFSAHF}
    kIdSal,                              // [ANY]
    kIdSar,                              // [ANY]
    kIdSarx,                             // [ANY] {BMI2}
    kIdSbb,                              // [ANY]
    kIdScas,                             // [ANY]
    kIdSeta,                             // [ANY]
    kIdSetae,                            // [ANY]
    kIdSetb,                             // [ANY]
    kIdSetbe,                            // [ANY]
    kIdSetc,                             // [ANY]
    kIdSete,                             // [ANY]
    kIdSetg,                             // [ANY]
    kIdSetge,                            // [ANY]
    kIdSetl,                             // [ANY]
    kIdSetle,                            // [ANY]
    kIdSetna,                            // [ANY]
    kIdSetnae,                           // [ANY]
    kIdSetnb,                            // [ANY]
    kIdSetnbe,                           // [ANY]
    kIdSetnc,                            // [ANY]
    kIdSetne,                            // [ANY]
    kIdSetng,                            // [ANY]
    kIdSetnge,                           // [ANY]
    kIdSetnl,                            // [ANY]
    kIdSetnle,                           // [ANY]
    kIdSetno,                            // [ANY]
    kIdSetnp,                            // [ANY]
    kIdSetns,                            // [ANY]
    kIdSetnz,                            // [ANY]
    kIdSeto,                             // [ANY]
    kIdSetp,                             // [ANY]
    kIdSetpe,                            // [ANY]
    kIdSetpo,                            // [ANY]
    kIdSets,                             // [ANY]
    kIdSetz,                             // [ANY]
    kIdSfence,                           // [ANY] {MMX2}
    kIdSgdt,                             // [ANY]
    kIdSha1msg1,                         // [ANY] {SHA}
    kIdSha1msg2,                         // [ANY] {SHA}
    kIdSha1nexte,                        // [ANY] {SHA}
    kIdSha1rnds4,                        // [ANY] {SHA}
    kIdSha256msg1,                       // [ANY] {SHA}
    kIdSha256msg2,                       // [ANY] {SHA}
    kIdSha256rnds2,                      // [ANY] {SHA}
    kIdShl,                              // [ANY]
    kIdShld,                             // [ANY]
    kIdShlx,                             // [ANY] {BMI2}
    kIdShr,                              // [ANY]
    kIdShrd,                             // [ANY]
    kIdShrx,                             // [ANY] {BMI2}
    kIdShufpd,                           // [ANY] {SSE2}
    kIdShufps,                           // [ANY] {SSE}
    kIdSidt,                             // [ANY]
    kIdSldt,                             // [ANY]
    kIdSmsw,                             // [ANY]
    kIdSqrtpd,                           // [ANY] {SSE2}
    kIdSqrtps,                           // [ANY] {SSE}
    kIdSqrtsd,                           // [ANY] {SSE2}
    kIdSqrtss,                           // [ANY] {SSE}
    kIdStac,                             // [ANY] {SMAP}
    kIdStc,                              // [ANY]
    kIdStd,                              // [ANY]
    kIdSti,                              // [ANY]
    kIdStmxcsr,                          // [ANY] {SSE}
    kIdStos,                             // [ANY]
    kIdStr,                              // [ANY]
    kIdSub,                              // [ANY]
    kIdSubpd,                            // [ANY] {SSE2}
    kIdSubps,                            // [ANY] {SSE}
    kIdSubsd,                            // [ANY] {SSE2}
    kIdSubss,                            // [ANY] {SSE}
    kIdSwapgs,                           // [X64]
    kIdSyscall,                          // [X64]
    kIdSysenter,                         // [ANY]
    kIdSysexit,                          // [ANY]
    kIdSysexit64,                        // [ANY]
    kIdSysret,                           // [X64]
    kIdSysret64,                         // [X64]
    kIdT1mskc,                           // [ANY] {TBM}
    kIdTest,                             // [ANY]
    kIdTzcnt,                            // [ANY] {BMI}
    kIdTzmsk,                            // [ANY] {TBM}
    kIdUcomisd,                          // [ANY] {SSE2}
    kIdUcomiss,                          // [ANY] {SSE}
    kIdUd2,                              // [ANY]
    kIdUnpckhpd,                         // [ANY] {SSE2}
    kIdUnpckhps,                         // [ANY] {SSE}
    kIdUnpcklpd,                         // [ANY] {SSE2}
    kIdUnpcklps,                         // [ANY] {SSE}
    kIdV4fmaddps,                        // [ANY] {AVX512_4FMAPS}
    kIdV4fmaddss,                        // [ANY] {AVX512_4FMAPS}
    kIdV4fnmaddps,                       // [ANY] {AVX512_4FMAPS}
    kIdV4fnmaddss,                       // [ANY] {AVX512_4FMAPS}
    kIdVaddpd,                           // [ANY] {AVX|AVX512_F+VL}
    kIdVaddps,                           // [ANY] {AVX|AVX512_F+VL}
    kIdVaddsd,                           // [ANY] {AVX|AVX512_F}
    kIdVaddss,                           // [ANY] {AVX|AVX512_F}
    kIdVaddsubpd,                        // [ANY] {AVX}
    kIdVaddsubps,                        // [ANY] {AVX}
    kIdVaesdec,                          // [ANY] {AESNI|AVX|AVX512_F|VAES+VL}
    kIdVaesdeclast,                      // [ANY] {AESNI|AVX|AVX512_F|VAES+VL}
    kIdVaesenc,                          // [ANY] {AESNI|AVX|AVX512_F|VAES+VL}
    kIdVaesenclast,                      // [ANY] {AESNI|AVX|AVX512_F|VAES+VL}
    kIdVaesimc,                          // [ANY] {AESNI|AVX}
    kIdVaeskeygenassist,                 // [ANY] {AESNI|AVX}
    kIdValignd,                          // [ANY] {AVX512_F+VL}
    kIdValignq,                          // [ANY] {AVX512_F+VL}
    kIdVandnpd,                          // [ANY] {AVX|AVX512_DQ+VL}
    kIdVandnps,                          // [ANY] {AVX|AVX512_DQ+VL}
    kIdVandpd,                           // [ANY] {AVX|AVX512_DQ+VL}
    kIdVandps,                           // [ANY] {AVX|AVX512_DQ+VL}
    kIdVblendmb,                         // [ANY] {AVX512_BW+VL}
    kIdVblendmd,                         // [ANY] {AVX512_F+VL}
    kIdVblendmpd,                        // [ANY] {AVX512_F+VL}
    kIdVblendmps,                        // [ANY] {AVX512_F+VL}
    kIdVblendmq,                         // [ANY] {AVX512_F+VL}
    kIdVblendmw,                         // [ANY] {AVX512_BW+VL}
    kIdVblendpd,                         // [ANY] {AVX}
    kIdVblendps,                         // [ANY] {AVX}
    kIdVblendvpd,                        // [ANY] {AVX}
    kIdVblendvps,                        // [ANY] {AVX}
    kIdVbroadcastf128,                   // [ANY] {AVX}
    kIdVbroadcastf32x2,                  // [ANY] {AVX512_DQ+VL}
    kIdVbroadcastf32x4,                  // [ANY] {AVX512_F}
    kIdVbroadcastf32x8,                  // [ANY] {AVX512_DQ}
    kIdVbroadcastf64x2,                  // [ANY] {AVX512_DQ+VL}
    kIdVbroadcastf64x4,                  // [ANY] {AVX512_F}
    kIdVbroadcasti128,                   // [ANY] {AVX2}
    kIdVbroadcasti32x2,                  // [ANY] {AVX512_DQ+VL}
    kIdVbroadcasti32x4,                  // [ANY] {AVX512_F+VL}
    kIdVbroadcasti32x8,                  // [ANY] {AVX512_DQ}
    kIdVbroadcasti64x2,                  // [ANY] {AVX512_DQ+VL}
    kIdVbroadcasti64x4,                  // [ANY] {AVX512_F}
    kIdVbroadcastsd,                     // [ANY] {AVX|AVX2|AVX512_F+VL}
    kIdVbroadcastss,                     // [ANY] {AVX|AVX2|AVX512_F+VL}
    kIdVcmppd,                           // [ANY] {AVX|AVX512_F+VL}
    kIdVcmpps,                           // [ANY] {AVX|AVX512_F+VL}
    kIdVcmpsd,                           // [ANY] {AVX|AVX512_F}
    kIdVcmpss,                           // [ANY] {AVX|AVX512_F}
    kIdVcomisd,                          // [ANY] {AVX|AVX512_F}
    kIdVcomiss,                          // [ANY] {AVX|AVX512_F}
    kIdVcompresspd,                      // [ANY] {AVX512_F+VL}
    kIdVcompressps,                      // [ANY] {AVX512_F+VL}
    kIdVcvtdq2pd,                        // [ANY] {AVX|AVX512_F+VL}
    kIdVcvtdq2ps,                        // [ANY] {AVX|AVX512_F+VL}
    kIdVcvtpd2dq,                        // [ANY] {AVX|AVX512_F+VL}
    kIdVcvtpd2ps,                        // [ANY] {AVX|AVX512_F+VL}
    kIdVcvtpd2qq,                        // [ANY] {AVX512_DQ+VL}
    kIdVcvtpd2udq,                       // [ANY] {AVX512_F+VL}
    kIdVcvtpd2uqq,                       // [ANY] {AVX512_DQ+VL}
    kIdVcvtph2ps,                        // [ANY] {AVX512_F|F16C+VL}
    kIdVcvtps2dq,                        // [ANY] {AVX|AVX512_F+VL}
    kIdVcvtps2pd,                        // [ANY] {AVX|AVX512_F+VL}
    kIdVcvtps2ph,                        // [ANY] {AVX512_F|F16C+VL}
    kIdVcvtps2qq,                        // [ANY] {AVX512_DQ+VL}
    kIdVcvtps2udq,                       // [ANY] {AVX512_F+VL}
    kIdVcvtps2uqq,                       // [ANY] {AVX512_DQ+VL}
    kIdVcvtqq2pd,                        // [ANY] {AVX512_DQ+VL}
    kIdVcvtqq2ps,                        // [ANY] {AVX512_DQ+VL}
    kIdVcvtsd2si,                        // [ANY] {AVX|AVX512_F}
    kIdVcvtsd2ss,                        // [ANY] {AVX|AVX512_F}
    kIdVcvtsd2usi,                       // [ANY] {AVX512_F}
    kIdVcvtsi2sd,                        // [ANY] {AVX|AVX512_F}
    kIdVcvtsi2ss,                        // [ANY] {AVX|AVX512_F}
    kIdVcvtss2sd,                        // [ANY] {AVX|AVX512_F}
    kIdVcvtss2si,                        // [ANY] {AVX|AVX512_F}
    kIdVcvtss2usi,                       // [ANY] {AVX512_F}
    kIdVcvttpd2dq,                       // [ANY] {AVX|AVX512_F+VL}
    kIdVcvttpd2qq,                       // [ANY] {AVX512_F+VL}
    kIdVcvttpd2udq,                      // [ANY] {AVX512_F+VL}
    kIdVcvttpd2uqq,                      // [ANY] {AVX512_DQ+VL}
    kIdVcvttps2dq,                       // [ANY] {AVX|AVX512_F+VL}
    kIdVcvttps2qq,                       // [ANY] {AVX512_DQ+VL}
    kIdVcvttps2udq,                      // [ANY] {AVX512_F+VL}
    kIdVcvttps2uqq,                      // [ANY] {AVX512_DQ+VL}
    kIdVcvttsd2si,                       // [ANY] {AVX|AVX512_F}
    kIdVcvttsd2usi,                      // [ANY] {AVX512_F}
    kIdVcvttss2si,                       // [ANY] {AVX|AVX512_F}
    kIdVcvttss2usi,                      // [ANY] {AVX512_F}
    kIdVcvtudq2pd,                       // [ANY] {AVX512_F+VL}
    kIdVcvtudq2ps,                       // [ANY] {AVX512_F+VL}
    kIdVcvtuqq2pd,                       // [ANY] {AVX512_DQ+VL}
    kIdVcvtuqq2ps,                       // [ANY] {AVX512_DQ+VL}
    kIdVcvtusi2sd,                       // [ANY] {AVX512_F}
    kIdVcvtusi2ss,                       // [ANY] {AVX512_F}
    kIdVdbpsadbw,                        // [ANY] {AVX512_BW+VL}
    kIdVdivpd,                           // [ANY] {AVX|AVX512_F+VL}
    kIdVdivps,                           // [ANY] {AVX|AVX512_F+VL}
    kIdVdivsd,                           // [ANY] {AVX|AVX512_F}
    kIdVdivss,                           // [ANY] {AVX|AVX512_F}
    kIdVdppd,                            // [ANY] {AVX}
    kIdVdpps,                            // [ANY] {AVX}
    kIdVerr,                             // [ANY]
    kIdVerw,                             // [ANY]
    kIdVexp2pd,                          // [ANY] {AVX512_ERI}
    kIdVexp2ps,                          // [ANY] {AVX512_ERI}
    kIdVexpandpd,                        // [ANY] {AVX512_F+VL}
    kIdVexpandps,                        // [ANY] {AVX512_F+VL}
    kIdVextractf128,                     // [ANY] {AVX}
    kIdVextractf32x4,                    // [ANY] {AVX512_F+VL}
    kIdVextractf32x8,                    // [ANY] {AVX512_DQ}
    kIdVextractf64x2,                    // [ANY] {AVX512_DQ+VL}
    kIdVextractf64x4,                    // [ANY] {AVX512_F}
    kIdVextracti128,                     // [ANY] {AVX2}
    kIdVextracti32x4,                    // [ANY] {AVX512_F+VL}
    kIdVextracti32x8,                    // [ANY] {AVX512_DQ}
    kIdVextracti64x2,                    // [ANY] {AVX512_DQ+VL}
    kIdVextracti64x4,                    // [ANY] {AVX512_F}
    kIdVextractps,                       // [ANY] {AVX|AVX512_F}
    kIdVfixupimmpd,                      // [ANY] {AVX512_F+VL}
    kIdVfixupimmps,                      // [ANY] {AVX512_F+VL}
    kIdVfixupimmsd,                      // [ANY] {AVX512_F}
    kIdVfixupimmss,                      // [ANY] {AVX512_F}
    kIdVfmadd132pd,                      // [ANY] {AVX512_F|FMA+VL}
    kIdVfmadd132ps,                      // [ANY] {AVX512_F|FMA+VL}
    kIdVfmadd132sd,                      // [ANY] {AVX512_F|FMA}
    kIdVfmadd132ss,                      // [ANY] {AVX512_F|FMA}
    kIdVfmadd213pd,                      // [ANY] {AVX512_F|FMA+VL}
    kIdVfmadd213ps,                      // [ANY] {AVX512_F|FMA+VL}
    kIdVfmadd213sd,                      // [ANY] {AVX512_F|FMA}
    kIdVfmadd213ss,                      // [ANY] {AVX512_F|FMA}
    kIdVfmadd231pd,                      // [ANY] {AVX512_F|FMA+VL}
    kIdVfmadd231ps,                      // [ANY] {AVX512_F|FMA+VL}
    kIdVfmadd231sd,                      // [ANY] {AVX512_F|FMA}
    kIdVfmadd231ss,                      // [ANY] {AVX512_F|FMA}
    kIdVfmaddpd,                         // [ANY] {FMA4}
    kIdVfmaddps,                         // [ANY] {FMA4}
    kIdVfmaddsd,                         // [ANY] {FMA4}
    kIdVfmaddss,                         // [ANY] {FMA4}
    kIdVfmaddsub132pd,                   // [ANY] {AVX512_F|FMA+VL}
    kIdVfmaddsub132ps,                   // [ANY] {AVX512_F|FMA+VL}
    kIdVfmaddsub213pd,                   // [ANY] {AVX512_F|FMA+VL}
    kIdVfmaddsub213ps,                   // [ANY] {AVX512_F|FMA+VL}
    kIdVfmaddsub231pd,                   // [ANY] {AVX512_F|FMA+VL}
    kIdVfmaddsub231ps,                   // [ANY] {AVX512_F|FMA+VL}
    kIdVfmaddsubpd,                      // [ANY] {FMA4}
    kIdVfmaddsubps,                      // [ANY] {FMA4}
    kIdVfmsub132pd,                      // [ANY] {AVX512_F|FMA+VL}
    kIdVfmsub132ps,                      // [ANY] {AVX512_F|FMA+VL}
    kIdVfmsub132sd,                      // [ANY] {AVX512_F|FMA}
    kIdVfmsub132ss,                      // [ANY] {AVX512_F|FMA}
    kIdVfmsub213pd,                      // [ANY] {AVX512_F|FMA+VL}
    kIdVfmsub213ps,                      // [ANY] {AVX512_F|FMA+VL}
    kIdVfmsub213sd,                      // [ANY] {AVX512_F|FMA}
    kIdVfmsub213ss,                      // [ANY] {AVX512_F|FMA}
    kIdVfmsub231pd,                      // [ANY] {AVX512_F|FMA+VL}
    kIdVfmsub231ps,                      // [ANY] {AVX512_F|FMA+VL}
    kIdVfmsub231sd,                      // [ANY] {AVX512_F|FMA}
    kIdVfmsub231ss,                      // [ANY] {AVX512_F|FMA}
    kIdVfmsubadd132pd,                   // [ANY] {AVX512_F|FMA+VL}
    kIdVfmsubadd132ps,                   // [ANY] {AVX512_F|FMA+VL}
    kIdVfmsubadd213pd,                   // [ANY] {AVX512_F|FMA+VL}
    kIdVfmsubadd213ps,                   // [ANY] {AVX512_F|FMA+VL}
    kIdVfmsubadd231pd,                   // [ANY] {AVX512_F|FMA+VL}
    kIdVfmsubadd231ps,                   // [ANY] {AVX512_F|FMA+VL}
    kIdVfmsubaddpd,                      // [ANY] {FMA4}
    kIdVfmsubaddps,                      // [ANY] {FMA4}
    kIdVfmsubpd,                         // [ANY] {FMA4}
    kIdVfmsubps,                         // [ANY] {FMA4}
    kIdVfmsubsd,                         // [ANY] {FMA4}
    kIdVfmsubss,                         // [ANY] {FMA4}
    kIdVfnmadd132pd,                     // [ANY] {AVX512_F|FMA+VL}
    kIdVfnmadd132ps,                     // [ANY] {AVX512_F|FMA+VL}
    kIdVfnmadd132sd,                     // [ANY] {AVX512_F|FMA}
    kIdVfnmadd132ss,                     // [ANY] {AVX512_F|FMA}
    kIdVfnmadd213pd,                     // [ANY] {AVX512_F|FMA+VL}
    kIdVfnmadd213ps,                     // [ANY] {AVX512_F|FMA+VL}
    kIdVfnmadd213sd,                     // [ANY] {AVX512_F|FMA}
    kIdVfnmadd213ss,                     // [ANY] {AVX512_F|FMA}
    kIdVfnmadd231pd,                     // [ANY] {AVX512_F|FMA+VL}
    kIdVfnmadd231ps,                     // [ANY] {AVX512_F|FMA+VL}
    kIdVfnmadd231sd,                     // [ANY] {AVX512_F|FMA}
    kIdVfnmadd231ss,                     // [ANY] {AVX512_F|FMA}
    kIdVfnmaddpd,                        // [ANY] {FMA4}
    kIdVfnmaddps,                        // [ANY] {FMA4}
    kIdVfnmaddsd,                        // [ANY] {FMA4}
    kIdVfnmaddss,                        // [ANY] {FMA4}
    kIdVfnmsub132pd,                     // [ANY] {AVX512_F|FMA+VL}
    kIdVfnmsub132ps,                     // [ANY] {AVX512_F|FMA+VL}
    kIdVfnmsub132sd,                     // [ANY] {AVX512_F|FMA}
    kIdVfnmsub132ss,                     // [ANY] {AVX512_F|FMA}
    kIdVfnmsub213pd,                     // [ANY] {AVX512_F|FMA+VL}
    kIdVfnmsub213ps,                     // [ANY] {AVX512_F|FMA+VL}
    kIdVfnmsub213sd,                     // [ANY] {AVX512_F|FMA}
    kIdVfnmsub213ss,                     // [ANY] {AVX512_F|FMA}
    kIdVfnmsub231pd,                     // [ANY] {AVX512_F|FMA+VL}
    kIdVfnmsub231ps,                     // [ANY] {AVX512_F|FMA+VL}
    kIdVfnmsub231sd,                     // [ANY] {AVX512_F|FMA}
    kIdVfnmsub231ss,                     // [ANY] {AVX512_F|FMA}
    kIdVfnmsubpd,                        // [ANY] {FMA4}
    kIdVfnmsubps,                        // [ANY] {FMA4}
    kIdVfnmsubsd,                        // [ANY] {FMA4}
    kIdVfnmsubss,                        // [ANY] {FMA4}
    kIdVfpclasspd,                       // [ANY] {AVX512_DQ+VL}
    kIdVfpclassps,                       // [ANY] {AVX512_DQ+VL}
    kIdVfpclasssd,                       // [ANY] {AVX512_DQ}
    kIdVfpclassss,                       // [ANY] {AVX512_DQ}
    kIdVfrczpd,                          // [ANY] {XOP}
    kIdVfrczps,                          // [ANY] {XOP}
    kIdVfrczsd,                          // [ANY] {XOP}
    kIdVfrczss,                          // [ANY] {XOP}
    kIdVgatherdpd,                       // [ANY] {AVX2|AVX512_F+VL}
    kIdVgatherdps,                       // [ANY] {AVX2|AVX512_F+VL}
    kIdVgatherpf0dpd,                    // [ANY] {AVX512_PFI}
    kIdVgatherpf0dps,                    // [ANY] {AVX512_PFI}
    kIdVgatherpf0qpd,                    // [ANY] {AVX512_PFI}
    kIdVgatherpf0qps,                    // [ANY] {AVX512_PFI}
    kIdVgatherpf1dpd,                    // [ANY] {AVX512_PFI}
    kIdVgatherpf1dps,                    // [ANY] {AVX512_PFI}
    kIdVgatherpf1qpd,                    // [ANY] {AVX512_PFI}
    kIdVgatherpf1qps,                    // [ANY] {AVX512_PFI}
    kIdVgatherqpd,                       // [ANY] {AVX2|AVX512_F+VL}
    kIdVgatherqps,                       // [ANY] {AVX2|AVX512_F+VL}
    kIdVgetexppd,                        // [ANY] {AVX512_F+VL}
    kIdVgetexpps,                        // [ANY] {AVX512_F+VL}
    kIdVgetexpsd,                        // [ANY] {AVX512_F}
    kIdVgetexpss,                        // [ANY] {AVX512_F}
    kIdVgetmantpd,                       // [ANY] {AVX512_F+VL}
    kIdVgetmantps,                       // [ANY] {AVX512_F+VL}
    kIdVgetmantsd,                       // [ANY] {AVX512_F}
    kIdVgetmantss,                       // [ANY] {AVX512_F}
    kIdVhaddpd,                          // [ANY] {AVX}
    kIdVhaddps,                          // [ANY] {AVX}
    kIdVhsubpd,                          // [ANY] {AVX}
    kIdVhsubps,                          // [ANY] {AVX}
    kIdVinsertf128,                      // [ANY] {AVX}
    kIdVinsertf32x4,                     // [ANY] {AVX512_F+VL}
    kIdVinsertf32x8,                     // [ANY] {AVX512_DQ}
    kIdVinsertf64x2,                     // [ANY] {AVX512_DQ+VL}
    kIdVinsertf64x4,                     // [ANY] {AVX512_F}
    kIdVinserti128,                      // [ANY] {AVX2}
    kIdVinserti32x4,                     // [ANY] {AVX512_F+VL}
    kIdVinserti32x8,                     // [ANY] {AVX512_DQ}
    kIdVinserti64x2,                     // [ANY] {AVX512_DQ+VL}
    kIdVinserti64x4,                     // [ANY] {AVX512_F}
    kIdVinsertps,                        // [ANY] {AVX|AVX512_F}
    kIdVlddqu,                           // [ANY] {AVX}
    kIdVldmxcsr,                         // [ANY] {AVX}
    kIdVmaskmovdqu,                      // [ANY] {AVX}
    kIdVmaskmovpd,                       // [ANY] {AVX}
    kIdVmaskmovps,                       // [ANY] {AVX}
    kIdVmaxpd,                           // [ANY] {AVX|AVX512_F+VL}
    kIdVmaxps,                           // [ANY] {AVX|AVX512_F+VL}
    kIdVmaxsd,                           // [ANY] {AVX|AVX512_F+VL}
    kIdVmaxss,                           // [ANY] {AVX|AVX512_F+VL}
    kIdVminpd,                           // [ANY] {AVX|AVX512_F+VL}
    kIdVminps,                           // [ANY] {AVX|AVX512_F+VL}
    kIdVminsd,                           // [ANY] {AVX|AVX512_F+VL}
    kIdVminss,                           // [ANY] {AVX|AVX512_F+VL}
    kIdVmovapd,                          // [ANY] {AVX|AVX512_F+VL}
    kIdVmovaps,                          // [ANY] {AVX|AVX512_F+VL}
    kIdVmovd,                            // [ANY] {AVX|AVX512_F}
    kIdVmovddup,                         // [ANY] {AVX|AVX512_F+VL}
    kIdVmovdqa,                          // [ANY] {AVX}
    kIdVmovdqa32,                        // [ANY] {AVX512_F+VL}
    kIdVmovdqa64,                        // [ANY] {AVX512_F+VL}
    kIdVmovdqu,                          // [ANY] {AVX}
    kIdVmovdqu16,                        // [ANY] {AVX512_BW+VL}
    kIdVmovdqu32,                        // [ANY] {AVX512_F+VL}
    kIdVmovdqu64,                        // [ANY] {AVX512_F+VL}
    kIdVmovdqu8,                         // [ANY] {AVX512_BW+VL}
    kIdVmovhlps,                         // [ANY] {AVX|AVX512_F}
    kIdVmovhpd,                          // [ANY] {AVX|AVX512_F}
    kIdVmovhps,                          // [ANY] {AVX|AVX512_F}
    kIdVmovlhps,                         // [ANY] {AVX|AVX512_F}
    kIdVmovlpd,                          // [ANY] {AVX|AVX512_F}
    kIdVmovlps,                          // [ANY] {AVX|AVX512_F}
    kIdVmovmskpd,                        // [ANY] {AVX}
    kIdVmovmskps,                        // [ANY] {AVX}
    kIdVmovntdq,                         // [ANY] {AVX|AVX512_F+VL}
    kIdVmovntdqa,                        // [ANY] {AVX|AVX2|AVX512_F+VL}
    kIdVmovntpd,                         // [ANY] {AVX|AVX512_F+VL}
    kIdVmovntps,                         // [ANY] {AVX|AVX512_F+VL}
    kIdVmovq,                            // [ANY] {AVX|AVX512_F}
    kIdVmovsd,                           // [ANY] {AVX|AVX512_F}
    kIdVmovshdup,                        // [ANY] {AVX|AVX512_F+VL}
    kIdVmovsldup,                        // [ANY] {AVX|AVX512_F+VL}
    kIdVmovss,                           // [ANY] {AVX|AVX512_F}
    kIdVmovupd,                          // [ANY] {AVX|AVX512_F+VL}
    kIdVmovups,                          // [ANY] {AVX|AVX512_F+VL}
    kIdVmpsadbw,                         // [ANY] {AVX|AVX2}
    kIdVmulpd,                           // [ANY] {AVX|AVX512_F+VL}
    kIdVmulps,                           // [ANY] {AVX|AVX512_F+VL}
    kIdVmulsd,                           // [ANY] {AVX|AVX512_F}
    kIdVmulss,                           // [ANY] {AVX|AVX512_F}
    kIdVorpd,                            // [ANY] {AVX|AVX512_DQ+VL}
    kIdVorps,                            // [ANY] {AVX|AVX512_DQ+VL}
    kIdVp4dpwssd,                        // [ANY] {AVX512_4VNNIW}
    kIdVp4dpwssds,                       // [ANY] {AVX512_4VNNIW}
    kIdVpabsb,                           // [ANY] {AVX|AVX2|AVX512_BW+VL}
    kIdVpabsd,                           // [ANY] {AVX|AVX2|AVX512_F+VL}
    kIdVpabsq,                           // [ANY] {AVX512_F+VL}
    kIdVpabsw,                           // [ANY] {AVX|AVX2|AVX512_BW+VL}
    kIdVpackssdw,                        // [ANY] {AVX|AVX2|AVX512_BW+VL}
    kIdVpacksswb,                        // [ANY] {AVX|AVX2|AVX512_BW+VL}
    kIdVpackusdw,                        // [ANY] {AVX|AVX2|AVX512_BW+VL}
    kIdVpackuswb,                        // [ANY] {AVX|AVX2|AVX512_BW+VL}
    kIdVpaddb,                           // [ANY] {AVX|AVX2|AVX512_BW+VL}
    kIdVpaddd,                           // [ANY] {AVX|AVX2|AVX512_F+VL}
    kIdVpaddq,                           // [ANY] {AVX|AVX2|AVX512_F+VL}
    kIdVpaddsb,                          // [ANY] {AVX|AVX2|AVX512_BW+VL}
    kIdVpaddsw,                          // [ANY] {AVX|AVX2|AVX512_BW+VL}
    kIdVpaddusb,                         // [ANY] {AVX|AVX2|AVX512_BW+VL}
    kIdVpaddusw,                         // [ANY] {AVX|AVX2|AVX512_BW+VL}
    kIdVpaddw,                           // [ANY] {AVX|AVX2|AVX512_BW+VL}
    kIdVpalignr,                         // [ANY] {AVX|AVX2|AVX512_BW+VL}
    kIdVpand,                            // [ANY] {AVX|AVX2}
    kIdVpandd,                           // [ANY] {AVX512_F+VL}
    kIdVpandn,                           // [ANY] {AVX|AVX2}
    kIdVpandnd,                          // [ANY] {AVX512_F+VL}
    kIdVpandnq,                          // [ANY] {AVX512_F+VL}
    kIdVpandq,                           // [ANY] {AVX512_F+VL}
    kIdVpavgb,                           // [ANY] {AVX|AVX2|AVX512_BW+VL}
    kIdVpavgw,                           // [ANY] {AVX|AVX2|AVX512_BW+VL}
    kIdVpblendd,                         // [ANY] {AVX2}
    kIdVpblendvb,                        // [ANY] {AVX|AVX2}
    kIdVpblendw,                         // [ANY] {AVX|AVX2}
    kIdVpbroadcastb,                     // [ANY] {AVX2|AVX512_BW+VL}
    kIdVpbroadcastd,                     // [ANY] {AVX2|AVX512_F+VL}
    kIdVpbroadcastmb2d,                  // [ANY] {AVX512_CDI+VL}
    kIdVpbroadcastmb2q,                  // [ANY] {AVX512_CDI+VL}
    kIdVpbroadcastq,                     // [ANY] {AVX2|AVX512_F+VL}
    kIdVpbroadcastw,                     // [ANY] {AVX2|AVX512_BW+VL}
    kIdVpclmulqdq,                       // [ANY] {AVX|AVX512_F|PCLMULQDQ|VPCLMULQDQ+VL}
    kIdVpcmov,                           // [ANY] {XOP}
    kIdVpcmpb,                           // [ANY] {AVX512_BW+VL}
    kIdVpcmpd,                           // [ANY] {AVX512_F+VL}
    kIdVpcmpeqb,                         // [ANY] {AVX|AVX2|AVX512_BW+VL}
    kIdVpcmpeqd,                         // [ANY] {AVX|AVX2|AVX512_F+VL}
    kIdVpcmpeqq,                         // [ANY] {AVX|AVX2|AVX512_F+VL}
    kIdVpcmpeqw,                         // [ANY] {AVX|AVX2|AVX512_BW+VL}
    kIdVpcmpestri,                       // [ANY] {AVX}
    kIdVpcmpestrm,                       // [ANY] {AVX}
    kIdVpcmpgtb,                         // [ANY] {AVX|AVX2|AVX512_BW+VL}
    kIdVpcmpgtd,                         // [ANY] {AVX|AVX2|AVX512_F+VL}
    kIdVpcmpgtq,                         // [ANY] {AVX|AVX2|AVX512_F+VL}
    kIdVpcmpgtw,                         // [ANY] {AVX|AVX2|AVX512_BW+VL}
    kIdVpcmpistri,                       // [ANY] {AVX}
    kIdVpcmpistrm,                       // [ANY] {AVX}
    kIdVpcmpq,                           // [ANY] {AVX512_F+VL}
    kIdVpcmpub,                          // [ANY] {AVX512_BW+VL}
    kIdVpcmpud,                          // [ANY] {AVX512_F+VL}
    kIdVpcmpuq,                          // [ANY] {AVX512_F+VL}
    kIdVpcmpuw,                          // [ANY] {AVX512_BW+VL}
    kIdVpcmpw,                           // [ANY] {AVX512_BW+VL}
    kIdVpcomb,                           // [ANY] {XOP}
    kIdVpcomd,                           // [ANY] {XOP}
    kIdVpcompressb,                      // [ANY] {AVX512_VBMI2+VL}
    kIdVpcompressd,                      // [ANY] {AVX512_F+VL}
    kIdVpcompressq,                      // [ANY] {AVX512_F+VL}
    kIdVpcompressw,                      // [ANY] {AVX512_VBMI2+VL}
    kIdVpcomq,                           // [ANY] {XOP}
    kIdVpcomub,                          // [ANY] {XOP}
    kIdVpcomud,                          // [ANY] {XOP}
    kIdVpcomuq,                          // [ANY] {XOP}
    kIdVpcomuw,                          // [ANY] {XOP}
    kIdVpcomw,                           // [ANY] {XOP}
    kIdVpconflictd,                      // [ANY] {AVX512_CDI+VL}
    kIdVpconflictq,                      // [ANY] {AVX512_CDI+VL}
    kIdVperm2f128,                       // [ANY] {AVX}
    kIdVperm2i128,                       // [ANY] {AVX2}
    kIdVpermb,                           // [ANY] {AVX512_VBMI+VL}
    kIdVpermd,                           // [ANY] {AVX2|AVX512_F+VL}
    kIdVpermi2b,                         // [ANY] {AVX512_VBMI+VL}
    kIdVpermi2d,                         // [ANY] {AVX512_F+VL}
    kIdVpermi2pd,                        // [ANY] {AVX512_F+VL}
    kIdVpermi2ps,                        // [ANY] {AVX512_F+VL}
    kIdVpermi2q,                         // [ANY] {AVX512_F+VL}
    kIdVpermi2w,                         // [ANY] {AVX512_BW+VL}
    kIdVpermil2pd,                       // [ANY] {XOP}
    kIdVpermil2ps,                       // [ANY] {XOP}
    kIdVpermilpd,                        // [ANY] {AVX|AVX512_F+VL}
    kIdVpermilps,                        // [ANY] {AVX|AVX512_F+VL}
    kIdVpermpd,                          // [ANY] {AVX2}
    kIdVpermps,                          // [ANY] {AVX2}
    kIdVpermq,                           // [ANY] {AVX2|AVX512_F+VL}
    kIdVpermt2b,                         // [ANY] {AVX512_VBMI+VL}
    kIdVpermt2d,                         // [ANY] {AVX512_F+VL}
    kIdVpermt2pd,                        // [ANY] {AVX512_F+VL}
    kIdVpermt2ps,                        // [ANY] {AVX512_F+VL}
    kIdVpermt2q,                         // [ANY] {AVX512_F+VL}
    kIdVpermt2w,                         // [ANY] {AVX512_BW+VL}
    kIdVpermw,                           // [ANY] {AVX512_BW+VL}
    kIdVpexpandb,                        // [ANY] {AVX512_VBMI2+VL}
    kIdVpexpandd,                        // [ANY] {AVX512_F+VL}
    kIdVpexpandq,                        // [ANY] {AVX512_F+VL}
    kIdVpexpandw,                        // [ANY] {AVX512_VBMI2+VL}
    kIdVpextrb,                          // [ANY] {AVX|AVX512_BW}
    kIdVpextrd,                          // [ANY] {AVX|AVX512_DQ}
    kIdVpextrq,                          // [X64] {AVX|AVX512_DQ}
    kIdVpextrw,                          // [ANY] {AVX|AVX512_BW}
    kIdVpgatherdd,                       // [ANY] {AVX2|AVX512_F+VL}
    kIdVpgatherdq,                       // [ANY] {AVX2|AVX512_F+VL}
    kIdVpgatherqd,                       // [ANY] {AVX2|AVX512_F+VL}
    kIdVpgatherqq,                       // [ANY] {AVX2|AVX512_F+VL}
    kIdVphaddbd,                         // [ANY] {XOP}
    kIdVphaddbq,                         // [ANY] {XOP}
    kIdVphaddbw,                         // [ANY] {XOP}
    kIdVphaddd,                          // [ANY] {AVX|AVX2}
    kIdVphadddq,                         // [ANY] {XOP}
    kIdVphaddsw,                         // [ANY] {AVX|AVX2}
    kIdVphaddubd,                        // [ANY] {XOP}
    kIdVphaddubq,                        // [ANY] {XOP}
    kIdVphaddubw,                        // [ANY] {XOP}
    kIdVphaddudq,                        // [ANY] {XOP}
    kIdVphadduwd,                        // [ANY] {XOP}
    kIdVphadduwq,                        // [ANY] {XOP}
    kIdVphaddw,                          // [ANY] {AVX|AVX2}
    kIdVphaddwd,                         // [ANY] {XOP}
    kIdVphaddwq,                         // [ANY] {XOP}
    kIdVphminposuw,                      // [ANY] {AVX}
    kIdVphsubbw,                         // [ANY] {XOP}
    kIdVphsubd,                          // [ANY] {AVX|AVX2}
    kIdVphsubdq,                         // [ANY] {XOP}
    kIdVphsubsw,                         // [ANY] {AVX|AVX2}
    kIdVphsubw,                          // [ANY] {AVX|AVX2}
    kIdVphsubwd,                         // [ANY] {XOP}
    kIdVpinsrb,                          // [ANY] {AVX|AVX512_BW}
    kIdVpinsrd,                          // [ANY] {AVX|AVX512_DQ}
    kIdVpinsrq,                          // [X64] {AVX|AVX512_DQ}
    kIdVpinsrw,                          // [ANY] {AVX|AVX512_BW}
    kIdVplzcntd,                         // [ANY] {AVX512_CDI+VL}
    kIdVplzcntq,                         // [ANY] {AVX512_CDI+VL}
    kIdVpmacsdd,                         // [ANY] {XOP}
    kIdVpmacsdqh,                        // [ANY] {XOP}
    kIdVpmacsdql,                        // [ANY] {XOP}
    kIdVpmacssdd,                        // [ANY] {XOP}
    kIdVpmacssdqh,                       // [ANY] {XOP}
    kIdVpmacssdql,                       // [ANY] {XOP}
    kIdVpmacsswd,                        // [ANY] {XOP}
    kIdVpmacssww,                        // [ANY] {XOP}
    kIdVpmacswd,                         // [ANY] {XOP}
    kIdVpmacsww,                         // [ANY] {XOP}
    kIdVpmadcsswd,                       // [ANY] {XOP}
    kIdVpmadcswd,                        // [ANY] {XOP}
    kIdVpmadd52huq,                      // [ANY] {AVX512_IFMA+VL}
    kIdVpmadd52luq,                      // [ANY] {AVX512_IFMA+VL}
    kIdVpmaddubsw,                       // [ANY] {AVX|AVX2|AVX512_BW+VL}
    kIdVpmaddwd,                         // [ANY] {AVX|AVX2|AVX512_BW+VL}
    kIdVpmaskmovd,                       // [ANY] {AVX2}
    kIdVpmaskmovq,                       // [ANY] {AVX2}
    kIdVpmaxsb,                          // [ANY] {AVX|AVX2|AVX512_BW+VL}
    kIdVpmaxsd,                          // [ANY] {AVX|AVX2|AVX512_F+VL}
    kIdVpmaxsq,                          // [ANY] {AVX512_F+VL}
    kIdVpmaxsw,                          // [ANY] {AVX|AVX2|AVX512_BW+VL}
    kIdVpmaxub,                          // [ANY] {AVX|AVX2|AVX512_BW+VL}
    kIdVpmaxud,                          // [ANY] {AVX|AVX2|AVX512_F+VL}
    kIdVpmaxuq,                          // [ANY] {AVX512_F+VL}
    kIdVpmaxuw,                          // [ANY] {AVX|AVX2|AVX512_BW+VL}
    kIdVpminsb,                          // [ANY] {AVX|AVX2|AVX512_BW+VL}
    kIdVpminsd,                          // [ANY] {AVX|AVX2|AVX512_F+VL}
    kIdVpminsq,                          // [ANY] {AVX512_F+VL}
    kIdVpminsw,                          // [ANY] {AVX|AVX2|AVX512_BW+VL}
    kIdVpminub,                          // [ANY] {AVX|AVX2|AVX512_BW+VL}
    kIdVpminud,                          // [ANY] {AVX|AVX2|AVX512_F+VL}
    kIdVpminuq,                          // [ANY] {AVX512_F+VL}
    kIdVpminuw,                          // [ANY] {AVX|AVX2|AVX512_BW+VL}
    kIdVpmovb2m,                         // [ANY] {AVX512_BW+VL}
    kIdVpmovd2m,                         // [ANY] {AVX512_DQ+VL}
    kIdVpmovdb,                          // [ANY] {AVX512_F+VL}
    kIdVpmovdw,                          // [ANY] {AVX512_F+VL}
    kIdVpmovm2b,                         // [ANY] {AVX512_BW+VL}
    kIdVpmovm2d,                         // [ANY] {AVX512_DQ+VL}
    kIdVpmovm2q,                         // [ANY] {AVX512_DQ+VL}
    kIdVpmovm2w,                         // [ANY] {AVX512_BW+VL}
    kIdVpmovmskb,                        // [ANY] {AVX|AVX2}
    kIdVpmovq2m,                         // [ANY] {AVX512_DQ+VL}
    kIdVpmovqb,                          // [ANY] {AVX512_F+VL}
    kIdVpmovqd,                          // [ANY] {AVX512_F+VL}
    kIdVpmovqw,                          // [ANY] {AVX512_F+VL}
    kIdVpmovsdb,                         // [ANY] {AVX512_F+VL}
    kIdVpmovsdw,                         // [ANY] {AVX512_F+VL}
    kIdVpmovsqb,                         // [ANY] {AVX512_F+VL}
    kIdVpmovsqd,                         // [ANY] {AVX512_F+VL}
    kIdVpmovsqw,                         // [ANY] {AVX512_F+VL}
    kIdVpmovswb,                         // [ANY] {AVX512_BW+VL}
    kIdVpmovsxbd,                        // [ANY] {AVX|AVX2|AVX512_F+VL}
    kIdVpmovsxbq,                        // [ANY] {AVX|AVX2|AVX512_F+VL}
    kIdVpmovsxbw,                        // [ANY] {AVX|AVX2|AVX512_BW+VL}
    kIdVpmovsxdq,                        // [ANY] {AVX|AVX2|AVX512_F+VL}
    kIdVpmovsxwd,                        // [ANY] {AVX|AVX2|AVX512_F+VL}
    kIdVpmovsxwq,                        // [ANY] {AVX|AVX2|AVX512_F+VL}
    kIdVpmovusdb,                        // [ANY] {AVX512_F+VL}
    kIdVpmovusdw,                        // [ANY] {AVX512_F+VL}
    kIdVpmovusqb,                        // [ANY] {AVX512_F+VL}
    kIdVpmovusqd,                        // [ANY] {AVX512_F+VL}
    kIdVpmovusqw,                        // [ANY] {AVX512_F+VL}
    kIdVpmovuswb,                        // [ANY] {AVX512_BW+VL}
    kIdVpmovw2m,                         // [ANY] {AVX512_BW+VL}
    kIdVpmovwb,                          // [ANY] {AVX512_BW+VL}
    kIdVpmovzxbd,                        // [ANY] {AVX|AVX2|AVX512_F+VL}
    kIdVpmovzxbq,                        // [ANY] {AVX|AVX2|AVX512_F+VL}
    kIdVpmovzxbw,                        // [ANY] {AVX|AVX2|AVX512_BW+VL}
    kIdVpmovzxdq,                        // [ANY] {AVX|AVX2|AVX512_F+VL}
    kIdVpmovzxwd,                        // [ANY] {AVX|AVX2|AVX512_F+VL}
    kIdVpmovzxwq,                        // [ANY] {AVX|AVX2|AVX512_F+VL}
    kIdVpmuldq,                          // [ANY] {AVX|AVX2|AVX512_F+VL}
    kIdVpmulhrsw,                        // [ANY] {AVX|AVX2|AVX512_BW+VL}
    kIdVpmulhuw,                         // [ANY] {AVX|AVX2|AVX512_BW+VL}
    kIdVpmulhw,                          // [ANY] {AVX|AVX2|AVX512_BW+VL}
    kIdVpmulld,                          // [ANY] {AVX|AVX2|AVX512_F+VL}
    kIdVpmullq,                          // [ANY] {AVX512_DQ+VL}
    kIdVpmullw,                          // [ANY] {AVX|AVX2|AVX512_BW+VL}
    kIdVpmultishiftqb,                   // [ANY] {AVX512_VBMI+VL}
    kIdVpmuludq,                         // [ANY] {AVX|AVX2|AVX512_F+VL}
    kIdVpopcntb,                         // [ANY] {AVX512_BITALG+VL}
    kIdVpopcntd,                         // [ANY] {AVX512_VPOPCNTDQ+VL}
    kIdVpopcntq,                         // [ANY] {AVX512_VPOPCNTDQ+VL}
    kIdVpopcntw,                         // [ANY] {AVX512_BITALG+VL}
    kIdVpor,                             // [ANY] {AVX|AVX2}
    kIdVpord,                            // [ANY] {AVX512_F+VL}
    kIdVporq,                            // [ANY] {AVX512_F+VL}
    kIdVpperm,                           // [ANY] {XOP}
    kIdVprold,                           // [ANY] {AVX512_F+VL}
    kIdVprolq,                           // [ANY] {AVX512_F+VL}
    kIdVprolvd,                          // [ANY] {AVX512_F+VL}
    kIdVprolvq,                          // [ANY] {AVX512_F+VL}
    kIdVprord,                           // [ANY] {AVX512_F+VL}
    kIdVprorq,                           // [ANY] {AVX512_F+VL}
    kIdVprorvd,                          // [ANY] {AVX512_F+VL}
    kIdVprorvq,                          // [ANY] {AVX512_F+VL}
    kIdVprotb,                           // [ANY] {XOP}
    kIdVprotd,                           // [ANY] {XOP}
    kIdVprotq,                           // [ANY] {XOP}
    kIdVprotw,                           // [ANY] {XOP}
    kIdVpsadbw,                          // [ANY] {AVX|AVX2|AVX512_BW+VL}
    kIdVpscatterdd,                      // [ANY] {AVX512_F+VL}
    kIdVpscatterdq,                      // [ANY] {AVX512_F+VL}
    kIdVpscatterqd,                      // [ANY] {AVX512_F+VL}
    kIdVpscatterqq,                      // [ANY] {AVX512_F+VL}
    kIdVpshab,                           // [ANY] {XOP}
    kIdVpshad,                           // [ANY] {XOP}
    kIdVpshaq,                           // [ANY] {XOP}
    kIdVpshaw,                           // [ANY] {XOP}
    kIdVpshlb,                           // [ANY] {XOP}
    kIdVpshld,                           // [ANY] {XOP}
    kIdVpshldd,                          // [ANY] {AVX512_VBMI2+VL}
    kIdVpshldq,                          // [ANY] {AVX512_VBMI2+VL}
    kIdVpshldvd,                         // [ANY] {AVX512_VBMI2+VL}
    kIdVpshldvq,                         // [ANY] {AVX512_VBMI2+VL}
    kIdVpshldvw,                         // [ANY] {AVX512_VBMI2+VL}
    kIdVpshldw,                          // [ANY] {AVX512_VBMI2+VL}
    kIdVpshlq,                           // [ANY] {XOP}
    kIdVpshlw,                           // [ANY] {XOP}
    kIdVpshrdd,                          // [ANY] {AVX512_VBMI2+VL}
    kIdVpshrdq,                          // [ANY] {AVX512_VBMI2+VL}
    kIdVpshrdvd,                         // [ANY] {AVX512_VBMI2+VL}
    kIdVpshrdvq,                         // [ANY] {AVX512_VBMI2+VL}
    kIdVpshrdvw,                         // [ANY] {AVX512_VBMI2+VL}
    kIdVpshrdw,                          // [ANY] {AVX512_VBMI2+VL}
    kIdVpshufb,                          // [ANY] {AVX|AVX2|AVX512_BW+VL}
    kIdVpshufbitqmb,                     // [ANY] {AVX512_BITALG+VL}
    kIdVpshufd,                          // [ANY] {AVX|AVX2|AVX512_F+VL}
    kIdVpshufhw,                         // [ANY] {AVX|AVX2|AVX512_BW+VL}
    kIdVpshuflw,                         // [ANY] {AVX|AVX2|AVX512_BW+VL}
    kIdVpsignb,                          // [ANY] {AVX|AVX2}
    kIdVpsignd,                          // [ANY] {AVX|AVX2}
    kIdVpsignw,                          // [ANY] {AVX|AVX2}
    kIdVpslld,                           // [ANY] {AVX|AVX2|AVX512_F+VL}
    kIdVpslldq,                          // [ANY] {AVX|AVX2|AVX512_BW+VL}
    kIdVpsllq,                           // [ANY] {AVX|AVX2|AVX512_F+VL}
    kIdVpsllvd,                          // [ANY] {AVX2|AVX512_F+VL}
    kIdVpsllvq,                          // [ANY] {AVX2|AVX512_F+VL}
    kIdVpsllvw,                          // [ANY] {AVX512_BW+VL}
    kIdVpsllw,                           // [ANY] {AVX|AVX2|AVX512_BW+VL}
    kIdVpsrad,                           // [ANY] {AVX|AVX2|AVX512_F+VL}
    kIdVpsraq,                           // [ANY] {AVX512_F+VL}
    kIdVpsravd,                          // [ANY] {AVX2|AVX512_F+VL}
    kIdVpsravq,                          // [ANY] {AVX512_F+VL}
    kIdVpsravw,                          // [ANY] {AVX512_BW+VL}
    kIdVpsraw,                           // [ANY] {AVX|AVX2|AVX512_BW+VL}
    kIdVpsrld,                           // [ANY] {AVX|AVX2|AVX512_F+VL}
    kIdVpsrldq,                          // [ANY] {AVX|AVX2|AVX512_BW+VL}
    kIdVpsrlq,                           // [ANY] {AVX|AVX2|AVX512_F+VL}
    kIdVpsrlvd,                          // [ANY] {AVX2|AVX512_F+VL}
    kIdVpsrlvq,                          // [ANY] {AVX2|AVX512_F+VL}
    kIdVpsrlvw,                          // [ANY] {AVX512_BW+VL}
    kIdVpsrlw,                           // [ANY] {AVX|AVX2|AVX512_BW+VL}
    kIdVpsubb,                           // [ANY] {AVX|AVX2|AVX512_BW+VL}
    kIdVpsubd,                           // [ANY] {AVX|AVX2|AVX512_F+VL}
    kIdVpsubq,                           // [ANY] {AVX|AVX2|AVX512_F+VL}
    kIdVpsubsb,                          // [ANY] {AVX|AVX2|AVX512_BW+VL}
    kIdVpsubsw,                          // [ANY] {AVX|AVX2|AVX512_BW+VL}
    kIdVpsubusb,                         // [ANY] {AVX|AVX2|AVX512_BW+VL}
    kIdVpsubusw,                         // [ANY] {AVX|AVX2|AVX512_BW+VL}
    kIdVpsubw,                           // [ANY] {AVX|AVX2|AVX512_BW+VL}
    kIdVpternlogd,                       // [ANY] {AVX512_F+VL}
    kIdVpternlogq,                       // [ANY] {AVX512_F+VL}
    kIdVptest,                           // [ANY] {AVX}
    kIdVptestmb,                         // [ANY] {AVX512_BW+VL}
    kIdVptestmd,                         // [ANY] {AVX512_F+VL}
    kIdVptestmq,                         // [ANY] {AVX512_F+VL}
    kIdVptestmw,                         // [ANY] {AVX512_BW+VL}
    kIdVptestnmb,                        // [ANY] {AVX512_BW+VL}
    kIdVptestnmd,                        // [ANY] {AVX512_F+VL}
    kIdVptestnmq,                        // [ANY] {AVX512_F+VL}
    kIdVptestnmw,                        // [ANY] {AVX512_BW+VL}
    kIdVpunpckhbw,                       // [ANY] {AVX|AVX2|AVX512_BW+VL}
    kIdVpunpckhdq,                       // [ANY] {AVX|AVX2|AVX512_F+VL}
    kIdVpunpckhqdq,                      // [ANY] {AVX|AVX2|AVX512_F+VL}
    kIdVpunpckhwd,                       // [ANY] {AVX|AVX2|AVX512_BW+VL}
    kIdVpunpcklbw,                       // [ANY] {AVX|AVX2|AVX512_BW+VL}
    kIdVpunpckldq,                       // [ANY] {AVX|AVX2|AVX512_F+VL}
    kIdVpunpcklqdq,                      // [ANY] {AVX|AVX2|AVX512_F+VL}
    kIdVpunpcklwd,                       // [ANY] {AVX|AVX2|AVX512_BW+VL}
    kIdVpxor,                            // [ANY] {AVX|AVX2}
    kIdVpxord,                           // [ANY] {AVX512_F+VL}
    kIdVpxorq,                           // [ANY] {AVX512_F+VL}
    kIdVrangepd,                         // [ANY] {AVX512_DQ+VL}
    kIdVrangeps,                         // [ANY] {AVX512_DQ+VL}
    kIdVrangesd,                         // [ANY] {AVX512_DQ}
    kIdVrangess,                         // [ANY] {AVX512_DQ}
    kIdVrcp14pd,                         // [ANY] {AVX512_F+VL}
    kIdVrcp14ps,                         // [ANY] {AVX512_F+VL}
    kIdVrcp14sd,                         // [ANY] {AVX512_F}
    kIdVrcp14ss,                         // [ANY] {AVX512_F}
    kIdVrcp28pd,                         // [ANY] {AVX512_ERI}
    kIdVrcp28ps,                         // [ANY] {AVX512_ERI}
    kIdVrcp28sd,                         // [ANY] {AVX512_ERI}
    kIdVrcp28ss,                         // [ANY] {AVX512_ERI}
    kIdVrcpps,                           // [ANY] {AVX}
    kIdVrcpss,                           // [ANY] {AVX}
    kIdVreducepd,                        // [ANY] {AVX512_DQ+VL}
    kIdVreduceps,                        // [ANY] {AVX512_DQ+VL}
    kIdVreducesd,                        // [ANY] {AVX512_DQ}
    kIdVreducess,                        // [ANY] {AVX512_DQ}
    kIdVrndscalepd,                      // [ANY] {AVX512_F+VL}
    kIdVrndscaleps,                      // [ANY] {AVX512_F+VL}
    kIdVrndscalesd,                      // [ANY] {AVX512_F}
    kIdVrndscaless,                      // [ANY] {AVX512_F}
    kIdVroundpd,                         // [ANY] {AVX}
    kIdVroundps,                         // [ANY] {AVX}
    kIdVroundsd,                         // [ANY] {AVX}
    kIdVroundss,                         // [ANY] {AVX}
    kIdVrsqrt14pd,                       // [ANY] {AVX512_F+VL}
    kIdVrsqrt14ps,                       // [ANY] {AVX512_F+VL}
    kIdVrsqrt14sd,                       // [ANY] {AVX512_F}
    kIdVrsqrt14ss,                       // [ANY] {AVX512_F}
    kIdVrsqrt28pd,                       // [ANY] {AVX512_ERI}
    kIdVrsqrt28ps,                       // [ANY] {AVX512_ERI}
    kIdVrsqrt28sd,                       // [ANY] {AVX512_ERI}
    kIdVrsqrt28ss,                       // [ANY] {AVX512_ERI}
    kIdVrsqrtps,                         // [ANY] {AVX}
    kIdVrsqrtss,                         // [ANY] {AVX}
    kIdVscalefpd,                        // [ANY] {AVX512_F+VL}
    kIdVscalefps,                        // [ANY] {AVX512_F+VL}
    kIdVscalefsd,                        // [ANY] {AVX512_F}
    kIdVscalefss,                        // [ANY] {AVX512_F}
    kIdVscatterdpd,                      // [ANY] {AVX512_F+VL}
    kIdVscatterdps,                      // [ANY] {AVX512_F+VL}
    kIdVscatterpf0dpd,                   // [ANY] {AVX512_PFI}
    kIdVscatterpf0dps,                   // [ANY] {AVX512_PFI}
    kIdVscatterpf0qpd,                   // [ANY] {AVX512_PFI}
    kIdVscatterpf0qps,                   // [ANY] {AVX512_PFI}
    kIdVscatterpf1dpd,                   // [ANY] {AVX512_PFI}
    kIdVscatterpf1dps,                   // [ANY] {AVX512_PFI}
    kIdVscatterpf1qpd,                   // [ANY] {AVX512_PFI}
    kIdVscatterpf1qps,                   // [ANY] {AVX512_PFI}
    kIdVscatterqpd,                      // [ANY] {AVX512_F+VL}
    kIdVscatterqps,                      // [ANY] {AVX512_F+VL}
    kIdVshuff32x4,                       // [ANY] {AVX512_F+VL}
    kIdVshuff64x2,                       // [ANY] {AVX512_F+VL}
    kIdVshufi32x4,                       // [ANY] {AVX512_F+VL}
    kIdVshufi64x2,                       // [ANY] {AVX512_F+VL}
    kIdVshufpd,                          // [ANY] {AVX|AVX512_F+VL}
    kIdVshufps,                          // [ANY] {AVX|AVX512_F+VL}
    kIdVsqrtpd,                          // [ANY] {AVX|AVX512_F+VL}
    kIdVsqrtps,                          // [ANY] {AVX|AVX512_F+VL}
    kIdVsqrtsd,                          // [ANY] {AVX|AVX512_F}
    kIdVsqrtss,                          // [ANY] {AVX|AVX512_F}
    kIdVstmxcsr,                         // [ANY] {AVX}
    kIdVsubpd,                           // [ANY] {AVX|AVX512_F+VL}
    kIdVsubps,                           // [ANY] {AVX|AVX512_F+VL}
    kIdVsubsd,                           // [ANY] {AVX|AVX512_F}
    kIdVsubss,                           // [ANY] {AVX|AVX512_F}
    kIdVtestpd,                          // [ANY] {AVX}
    kIdVtestps,                          // [ANY] {AVX}
    kIdVucomisd,                         // [ANY] {AVX|AVX512_F}
    kIdVucomiss,                         // [ANY] {AVX|AVX512_F}
    kIdVunpckhpd,                        // [ANY] {AVX|AVX512_F+VL}
    kIdVunpckhps,                        // [ANY] {AVX|AVX512_F+VL}
    kIdVunpcklpd,                        // [ANY] {AVX|AVX512_F+VL}
    kIdVunpcklps,                        // [ANY] {AVX|AVX512_F+VL}
    kIdVxorpd,                           // [ANY] {AVX|AVX512_DQ+VL}
    kIdVxorps,                           // [ANY] {AVX|AVX512_DQ+VL}
    kIdVzeroall,                         // [ANY] {AVX}
    kIdVzeroupper,                       // [ANY] {AVX}
    kIdWbinvd,                           // [ANY]
    kIdWrfsbase,                         // [X64] {FSGSBASE}
    kIdWrgsbase,                         // [X64] {FSGSBASE}
    kIdWrmsr,                            // [ANY] {MSR}
    kIdXabort,                           // [ANY] {RTM}
    kIdXadd,                             // [ANY] {I486}
    kIdXbegin,                           // [ANY] {RTM}
    kIdXchg,                             // [ANY]
    kIdXend,                             // [ANY] {RTM}
    kIdXgetbv,                           // [ANY] {XSAVE}
    kIdXlatb,                            // [ANY]
    kIdXor,                              // [ANY]
    kIdXorpd,                            // [ANY] {SSE2}
    kIdXorps,                            // [ANY] {SSE}
    kIdXrstor,                           // [ANY] {XSAVE}
    kIdXrstor64,                         // [X64] {XSAVE}
    kIdXrstors,                          // [ANY] {XSAVES}
    kIdXrstors64,                        // [X64] {XSAVES}
    kIdXsave,                            // [ANY] {XSAVE}
    kIdXsave64,                          // [X64] {XSAVE}
    kIdXsavec,                           // [ANY] {XSAVEC}
    kIdXsavec64,                         // [X64] {XSAVEC}
    kIdXsaveopt,                         // [ANY] {XSAVEOPT}
    kIdXsaveopt64,                       // [X64] {XSAVEOPT}
    kIdXsaves,                           // [ANY] {XSAVES}
    kIdXsaves64,                         // [X64] {XSAVES}
    kIdXsetbv,                           // [ANY] {XSAVE}
    kIdXtest,                            // [ANY] {TSX}
    _kIdCount
    // ${InstId:End}
  };

  //! Instruction options (X86).
  enum Options : uint32_t {
    kOptionVex3           = 0x00000400u, //!< Use 3-byte VEX prefix if possible (AVX) (must be 0x00000400).
    kOptionModMR          = 0x00000800u, //!< Use ModMR instead of ModRM when it's available.
    kOptionEvex           = 0x00001000u, //!< Use 4-byte EVEX prefix if possible (AVX-512) (must be 0x00001000).

    kOptionLock           = 0x00002000u, //!< LOCK prefix (lock-enabled instructions only).
    kOptionRep            = 0x00004000u, //!< REP prefix (string instructions only).
    kOptionRepne          = 0x00008000u, //!< REPNE prefix (string instructions only).

    kOptionXAcquire       = 0x00010000u, //!< XACQUIRE prefix (only allowed instructions).
    kOptionXRelease       = 0x00020000u, //!< XRELEASE prefix (only allowed instructions).

    kOptionER             = 0x00040000u, //!< AVX-512: embedded-rounding {er} and implicit {sae}.
    kOptionSAE            = 0x00080000u, //!< AVX-512: suppress-all-exceptions {sae}.
    kOptionRN_SAE         = 0x00000000u, //!< AVX-512: round-to-nearest (even)      {rn-sae} (bits 00).
    kOptionRD_SAE         = 0x00200000u, //!< AVX-512: round-down (toward -inf)     {rd-sae} (bits 01).
    kOptionRU_SAE         = 0x00400000u, //!< AVX-512: round-up (toward +inf)       {ru-sae} (bits 10).
    kOptionRZ_SAE         = 0x00600000u, //!< AVX-512: round-toward-zero (truncate) {rz-sae} (bits 11).
    kOptionZMask          = 0x00800000u, //!< AVX-512: Use zeroing {k}{z} instead of merging {k}.
    _kOptionAvx512Mask    = 0x00FC0000u, //!< AVX-512: Mask of all possible AVX-512 options except EVEX prefix flag.

    kOptionOpCodeB        = 0x01000000u, //!< REX.B and/or VEX.B field (X64).
    kOptionOpCodeX        = 0x02000000u, //!< REX.X and/or VEX.X field (X64).
    kOptionOpCodeR        = 0x04000000u, //!< REX.R and/or VEX.R field (X64).
    kOptionOpCodeW        = 0x08000000u, //!< REX.W and/or VEX.W field (X64).
    kOptionRex            = 0x40000000u, //!< Force REX prefix (X64).
    _kOptionInvalidRex    = 0x80000000u  //!< Invalid REX prefix (set by X86 or when AH|BH|CH|DH regs are used on X64).
  };

  // --------------------------------------------------------------------------
  // [Statics]
  // --------------------------------------------------------------------------

  //! Get whether the `instId` is defined (counts also Inst::kIdNone, which must be zero).
  static inline bool isDefinedId(uint32_t instId) noexcept { return instId < _kIdCount; }

  //! Get a 'kmov?' instruction from a `size`.
  static inline uint32_t kmovFromSize(uint32_t size) noexcept {
    switch (size) {
      case  1: return kIdKmovb;
      case  2: return kIdKmovw;
      case  4: return kIdKmovd;
      case  8: return kIdKmovq;
      default: return kIdNone;
    }
  }

  #define ASMJIT_INST_FROM_COND(ID) \
    ID##o, ID##no, ID##b , ID##ae,  \
    ID##e, ID##ne, ID##be, ID##a ,  \
    ID##s, ID##ns, ID##pe, ID##po,  \
    ID##l, ID##ge, ID##le, ID##g
  static constexpr uint16_t jccTable[] = { ASMJIT_INST_FROM_COND(Inst::kIdJ) };
  static constexpr uint16_t setccTable[] = { ASMJIT_INST_FROM_COND(Inst::kIdSet) };
  static constexpr uint16_t cmovccTable[] = { ASMJIT_INST_FROM_COND(Inst::kIdCmov) };
  #undef ASMJIT_INST_FROM_COND

  //! Translate a condition code `cond` to a `jcc` instruction id.
  static constexpr uint32_t jccFromCond(uint32_t cond) noexcept { return jccTable[cond]; }
  //! Translate a condition code `cond` to a `setcc` instruction id.
  static constexpr uint32_t setccFromCond(uint32_t cond) noexcept { return setccTable[cond]; }
  //! Translate a condition code `cond` to a `cmovcc` instruction id.
  static constexpr uint32_t cmovccFromCond(uint32_t cond) noexcept { return cmovccTable[cond]; }
};

// ============================================================================
// [asmjit::x86::FpuWord]
// ============================================================================

//! FPU control and status word (X86).
namespace FpuWord {
  //! FPU status word.
  enum Status : uint32_t {
    kStatusInvalid        = 0x0001u,
    kStatusDenormalized   = 0x0002u,
    kStatusDivByZero      = 0x0004u,
    kStatusOverflow       = 0x0008u,
    kStatusUnderflow      = 0x0010u,
    kStatusPrecision      = 0x0020u,
    kStatusStackFault     = 0x0040u,
    kStatusInterrupt      = 0x0080u,
    kStatusC0             = 0x0100u,
    kStatusC1             = 0x0200u,
    kStatusC2             = 0x0400u,
    kStatusTop            = 0x3800u,
    kStatusC3             = 0x4000u,
    kStatusBusy           = 0x8000u
  };

  //! FPU control word.
  enum Control : uint32_t {
    // Bits 0-5.
    kControlEM_Mask       = 0x003Fu,
    kControlEM_Invalid    = 0x0001u,
    kControlEM_Denormal   = 0x0002u,
    kControlEM_DivByZero  = 0x0004u,
    kControlEM_Overflow   = 0x0008u,
    kControlEM_Underflow  = 0x0010u,
    kControlEM_Inexact    = 0x0020u,

    // Bits 8-9.
    kControlPC_Mask       = 0x0300u,
    kControlPC_Float      = 0x0000u,
    kControlPC_Reserved   = 0x0100u,
    kControlPC_Double     = 0x0200u,
    kControlPC_Extended   = 0x0300u,

    // Bits 10-11.
    kControlRC_Mask       = 0x0C00u,
    kControlRC_Nearest    = 0x0000u,
    kControlRC_Down       = 0x0400u,
    kControlRC_Up         = 0x0800u,
    kControlRC_Truncate   = 0x0C00u,

    // Bit 12.
    kControlIC_Mask       = 0x1000u,
    kControlIC_Projective = 0x0000u,
    kControlIC_Affine     = 0x1000u
  };
}

// ============================================================================
// [asmjit::x86::SpecialRegs]
// ============================================================================

// TODO: Move into a namespace.
//! Flags describing special registers and/or their parts.
enum SpecialRegs : uint32_t {
  kSpecialReg_FLAGS_CF    = 0x00000001u, //!< [R|E]FLAGS - Carry flag.
  kSpecialReg_FLAGS_PF    = 0x00000002u, //!< [R|E]FLAGS - Parity flag.
  kSpecialReg_FLAGS_AF    = 0x00000004u, //!< [R|E]FLAGS - Adjust flag.
  kSpecialReg_FLAGS_ZF    = 0x00000008u, //!< [R|E]FLAGS - Zero flag.
  kSpecialReg_FLAGS_SF    = 0x00000010u, //!< [R|E]FLAGS - Sign flag.
  kSpecialReg_FLAGS_TF    = 0x00000020u, //!< [R|E]FLAGS - Trap flag.
  kSpecialReg_FLAGS_IF    = 0x00000040u, //!< [R|E]FLAGS - Interrupt enable flag.
  kSpecialReg_FLAGS_DF    = 0x00000080u, //!< [R|E]FLAGS - Direction flag.
  kSpecialReg_FLAGS_OF    = 0x00000100u, //!< [R|E]FLAGS - Overflow flag.
  kSpecialReg_FLAGS_AC    = 0x00000200u, //!< [R|E]FLAGS - Alignment check.
  kSpecialReg_FLAGS_SYS   = 0x00000400u, //!< [R|E]FLAGS - System flags.

  kSpecialReg_X87CW_EXC   = 0x00000800u, //!< X87 Control Word - Exception control.
  kSpecialReg_X87CW_PC    = 0x00001000u, //!< X87 Control Word - Precision control.
  kSpecialReg_X87CW_RC    = 0x00002000u, //!< X87 Control Word - Rounding control.

  kSpecialReg_X87SW_EXC   = 0x00004000u, //!< X87 Status Word - Exception flags.
  kSpecialReg_X87SW_C0    = 0x00008000u, //!< X87 Status Word - C0 flag.
  kSpecialReg_X87SW_C1    = 0x00010000u, //!< X87 Status Word - C1 flag.
  kSpecialReg_X87SW_C2    = 0x00020000u, //!< X87 Status Word - C2 flag.
  kSpecialReg_X87SW_TOP   = 0x00040000u, //!< X87 Status Word - Top of the FPU stack.
  kSpecialReg_X87SW_C3    = 0x00080000u, //!< X87 Status Word - C3 flag.

  kSpecialReg_MSR         = 0x00100000u, //!< MSR register.
  kSpecialReg_XCR         = 0x00200000u  //!< XCR register.
};

// ============================================================================
// [asmjit::x86::Predicate]
// ============================================================================

//! Contains predicates used by SIMD instructions (X86).
namespace Predicate {
  //! A predicate used by CMP[PD|PS|SD|SS] instructions.
  enum Cmp : uint32_t {
    kCmpEQ                = 0x00u,       //!< Equal             (Quiet).
    kCmpLT                = 0x01u,       //!< Less              (Signaling).
    kCmpLE                = 0x02u,       //!< Less/Equal        (Signaling).
    kCmpUNORD             = 0x03u,       //!< Unordered         (Quiet).
    kCmpNEQ               = 0x04u,       //!< Not Equal         (Quiet).
    kCmpNLT               = 0x05u,       //!< Not Less          (Signaling).
    kCmpNLE               = 0x06u,       //!< Not Less/Equal    (Signaling).
    kCmpORD               = 0x07u        //!< Ordered           (Quiet).
  };

  //! A predicate used by [V]PCMP[I|E]STR[I|M] instructions.
  enum PCmpStr : uint32_t {
    // Source data format:
    kPCmpStrUB            = 0x00u << 0,  //!< The source data format is unsigned bytes.
    kPCmpStrUW            = 0x01u << 0,  //!< The source data format is unsigned words.
    kPCmpStrSB            = 0x02u << 0,  //!< The source data format is signed bytes.
    kPCmpStrSW            = 0x03u << 0,  //!< The source data format is signed words.

    // Aggregation operation:
    kPCmpStrEqualAny      = 0x00u << 2,  //!< The arithmetic comparison is "equal".
    kPCmpStrRanges        = 0x01u << 2,  //!< The arithmetic comparison is “greater than or equal”
                                         //!< between even indexed elements and “less than or equal”
                                         //!< between odd indexed elements.
    kPCmpStrEqualEach     = 0x02u << 2,  //!< The arithmetic comparison is "equal".
    kPCmpStrEqualOrdered  = 0x03u << 2,  //!< The arithmetic comparison is "equal".

    // Polarity:
    kPCmpStrPosPolarity   = 0x00u << 4,  //!< IntRes2 = IntRes1.
    kPCmpStrNegPolarity   = 0x01u << 4,  //!< IntRes2 = -1 XOR IntRes1.
    kPCmpStrPosMasked     = 0x02u << 4,  //!< IntRes2 = IntRes1.
    kPCmpStrNegMasked     = 0x03u << 4,  //!< IntRes2[i] = second[i] == invalid ? IntRes1[i] : ~IntRes1[i].

    // Output selection (pcmpstri):
    kPCmpStrOutputLSI     = 0x00u << 6,  //!< The index returned to ECX is of the least significant set bit in IntRes2.
    kPCmpStrOutputMSI     = 0x01u << 6,  //!< The index returned to ECX is of the most significant set bit in IntRes2.

    // Output selection (pcmpstrm):
    kPCmpStrBitMask       = 0x00u << 6,  //!< IntRes2 is returned as the mask to the least significant bits of XMM0.
    kPCmpStrIndexMask     = 0x01u << 6   //!< IntRes2 is expanded into a byte/word mask and placed in XMM0.
  };

  //! A predicate used by ROUND[PD|PS|SD|SS] instructions.
  enum Round : uint32_t {
    kRoundNearest         = 0x00u,       //!< Round to nearest (even).
    kRoundDown            = 0x01u,       //!< Round to down toward -INF (floor),
    kRoundUp              = 0x02u,       //!< Round to up toward +INF (ceil).
    kRoundTrunc           = 0x03u,       //!< Round toward zero (truncate).
    kRoundCurrent         = 0x04u,       //!< Round to the current rounding mode set (ignores other RC bits).
    kRoundInexact         = 0x08u        //!< Avoids inexact exception, if set.
  };

  //! A predicate used by VCMP[PD|PS|SD|SS] instructions.
  //!
  //! The first 8 values are compatible with `Cmp`.
  enum VCmp : uint32_t {
    kVCmpEQ_OQ            = kCmpEQ,      //!< Equal             (Quiet    , Ordered).
    kVCmpLT_OS            = kCmpLT,      //!< Less              (Signaling, Ordered).
    kVCmpLE_OS            = kCmpLE,      //!< Less/Equal        (Signaling, Ordered).
    kVCmpUNORD_Q          = kCmpUNORD,   //!< Unordered         (Quiet).
    kVCmpNEQ_UQ           = kCmpNEQ,     //!< Not Equal         (Quiet    , Unordered).
    kVCmpNLT_US           = kCmpNLT,     //!< Not Less          (Signaling, Unordered).
    kVCmpNLE_US           = kCmpNLE,     //!< Not Less/Equal    (Signaling, Unordered).
    kVCmpORD_Q            = kCmpORD,     //!< Ordered           (Quiet).
    kVCmpEQ_UQ            = 0x08u,       //!< Equal             (Quiet    , Unordered).
    kVCmpNGE_US           = 0x09u,       //!< Not Greater/Equal (Signaling, Unordered).
    kVCmpNGT_US           = 0x0Au,       //!< Not Greater       (Signaling, Unordered).
    kVCmpFALSE_OQ         = 0x0Bu,       //!< False             (Quiet    , Ordered).
    kVCmpNEQ_OQ           = 0x0Cu,       //!< Not Equal         (Quiet    , Ordered).
    kVCmpGE_OS            = 0x0Du,       //!< Greater/Equal     (Signaling, Ordered).
    kVCmpGT_OS            = 0x0Eu,       //!< Greater           (Signaling, Ordered).
    kVCmpTRUE_UQ          = 0x0Fu,       //!< True              (Quiet    , Unordered).
    kVCmpEQ_OS            = 0x10u,       //!< Equal             (Signaling, Ordered).
    kVCmpLT_OQ            = 0x11u,       //!< Less              (Quiet    , Ordered).
    kVCmpLE_OQ            = 0x12u,       //!< Less/Equal        (Quiet    , Ordered).
    kVCmpUNORD_S          = 0x13u,       //!< Unordered         (Signaling).
    kVCmpNEQ_US           = 0x14u,       //!< Not Equal         (Signaling, Unordered).
    kVCmpNLT_UQ           = 0x15u,       //!< Not Less          (Quiet    , Unordered).
    kVCmpNLE_UQ           = 0x16u,       //!< Not Less/Equal    (Quiet    , Unordered).
    kVCmpORD_S            = 0x17u,       //!< Ordered           (Signaling).
    kVCmpEQ_US            = 0x18u,       //!< Equal             (Signaling, Unordered).
    kVCmpNGE_UQ           = 0x19u,       //!< Not Greater/Equal (Quiet    , Unordered).
    kVCmpNGT_UQ           = 0x1Au,       //!< Not Greater       (Quiet    , Unordered).
    kVCmpFALSE_OS         = 0x1Bu,       //!< False             (Signaling, Ordered).
    kVCmpNEQ_OS           = 0x1Cu,       //!< Not Equal         (Signaling, Ordered).
    kVCmpGE_OQ            = 0x1Du,       //!< Greater/Equal     (Quiet    , Ordered).
    kVCmpGT_OQ            = 0x1Eu,       //!< Greater           (Quiet    , Ordered).
    kVCmpTRUE_US          = 0x1Fu        //!< True              (Signaling, Unordered).
  };

  //! A predicate used by VFIXUPIMM[PD|PS|SD|SS] instructions (AVX-512).
  enum VFixupImm : uint32_t {
    kVFixupImmZEOnZero    = 0x01u,
    kVFixupImmIEOnZero    = 0x02u,
    kVFixupImmZEOnOne     = 0x04u,
    kVFixupImmIEOnOne     = 0x08u,
    kVFixupImmIEOnSNaN    = 0x10u,
    kVFixupImmIEOnNInf    = 0x20u,
    kVFixupImmIEOnNegative= 0x40u,
    kVFixupImmIEOnPInf    = 0x80u
  };

  //! A predicate used by VFPCLASS[PD|PS|SD|SS] instructions (AVX-512).
  enum VFPClass : uint32_t {
    kVFPClassQNaN         = 0x00u,
    kVFPClassPZero        = 0x01u,
    kVFPClassNZero        = 0x02u,
    kVFPClassPInf         = 0x03u,
    kVFPClassNInf         = 0x04u,
    kVFPClassDenormal     = 0x05u,
    kVFPClassNegative     = 0x06u,
    kVFPClassSNaN         = 0x07u
  };

  //! A predicate used by VGETMANT[PD|PS|SD|SS] instructions (AVX-512).
  enum VGetMant : uint32_t {
    kVGetMant1To2         = 0x00u,
    kVGetMant1Div2To2     = 0x01u,
    kVGetMant1Div2To1     = 0x02u,
    kVGetMant3Div4To3Div2 = 0x03u,
    kVGetMantNoSign       = 0x04u,
    kVGetMantQNaNIfSign   = 0x08u
  };

  //! A predicate used by VPCMP[U][B|W|D|Q] instructions (AVX-512).
  enum VPCmp : uint32_t {
    kVPCmpEQ              = 0x00u,       //!< Equal.
    kVPCmpLT              = 0x01u,       //!< Less.
    kVPCmpLE              = 0x02u,       //!< Less/Equal.
    kVPCmpFALSE           = 0x03u,       //!< False.
    kVPCmpNE              = 0x04u,       //!< Not Equal.
    kVPCmpGE              = 0x05u,       //!< Greater/Equal.
    kVPCmpGT              = 0x06u,       //!< Greater.
    kVPCmpTRUE            = 0x07u        //!< True.
  };

  //! A predicate used by VPCOM[U][B|W|D|Q] instructions (XOP).
  enum VPCom : uint32_t {
    kVPComLT              = 0x00u,       //!< Less.
    kVPComLE              = 0x01u,       //!< Less/Equal
    kVPComGT              = 0x02u,       //!< Greater.
    kVPComGE              = 0x03u,       //!< Greater/Equal.
    kVPComEQ              = 0x04u,       //!< Equal.
    kVPComNE              = 0x05u,       //!< Not Equal.
    kVPComFALSE           = 0x06u,       //!< False.
    kVPComTRUE            = 0x07u        //!< True.
  };

  //! A predicate used by VRANGE[PD|PS|SD|SS] instructions (AVX-512).
  enum VRange : uint32_t {
    kVRangeSelectMin      = 0x00u,       //!< Select minimum value.
    kVRangeSelectMax      = 0x01u,       //!< Select maximum value.
    kVRangeSelectAbsMin   = 0x02u,       //!< Select minimum absolute value.
    kVRangeSelectAbsMax   = 0x03u,       //!< Select maximum absolute value.
    kVRangeSignSrc1       = 0x00u,       //!< Select sign of SRC1.
    kVRangeSignSrc2       = 0x04u,       //!< Select sign of SRC2.
    kVRangeSign0          = 0x08u,       //!< Set sign to 0.
    kVRangeSign1          = 0x0Cu        //!< Set sign to 1.
  };

  //! A predicate used by VREDUCE[PD|PS|SD|SS] instructions (AVX-512).
  enum VReduce : uint32_t {
    kVReduceRoundCurrent  = 0x00u,       //!< Round to the current mode set.
    kVReduceRoundEven     = 0x04u,       //!< Round to nearest even.
    kVReduceRoundDown     = 0x05u,       //!< Round down.
    kVReduceRoundUp       = 0x06u,       //!< Round up.
    kVReduceRoundTrunc    = 0x07u,       //!< Truncate.
    kVReduceSuppress      = 0x08u        //!< Suppress exceptions.
  };

  //! Pack a shuffle constant to be used by SSE/AVX/AVX-512 instructions (2 values).
  //!
  //! \param a Position of the first  component [0, 1].
  //! \param b Position of the second component [0, 1].
  //!
  //! Shuffle constants can be used to encode an immediate for these instructions:
  //!   - `shufpd`
  static constexpr uint32_t shuf(uint32_t a, uint32_t b) noexcept {
    return (a << 1) | b;
  }

  //! Pack a shuffle constant to be used by SSE/AVX/AVX-512 instructions (4 values).
  //!
  //! \param a Position of the first  component [0, 3].
  //! \param b Position of the second component [0, 3].
  //! \param c Position of the third  component [0, 3].
  //! \param d Position of the fourth component [0, 3].
  //!
  //! Shuffle constants can be used to encode an immediate for these instructions:
  //!   - `pshufw()`
  //!   - `pshufd()`
  //!   - `pshuflw()`
  //!   - `pshufhw()`
  //!   - `shufps()`
  static constexpr uint32_t shuf(uint32_t a, uint32_t b, uint32_t c, uint32_t d) noexcept {
    return (a << 6) | (b << 4) | (c << 2) | d;
  }
}

// ============================================================================
// [asmjit::x86::TLog]
// ============================================================================

//! Bitwise ternary logic between 3 operands introduced by AVX-512 (X86).
namespace TLog {
  //! A predicate that can be used to create a common predicate for VPTERNLOG[D|Q].
  enum Operator : uint32_t {
    k0                    = 0x00u,
    k1                    = 0xFFu,
    kA                    = 0xF0u,
    kB                    = 0xCCu,
    kC                    = 0xAAu,
    kNotA                 = kA ^ 0xFFu,
    kNotB                 = kB ^ 0xFFu,
    kNotC                 = kC ^ 0xFFu,

    kAB                   = kA & kB,
    kAC                   = kA & kC,
    kBC                   = kB & kC,
    kNotAB                = kAB ^ 0xFFu,
    kNotAC                = kAC ^ 0xFFu,
    kNotBC                = kBC ^ 0xFFu,

    kABC                  = kA & kB & kC,
    kNotABC               = kABC ^ 0xFFu
  };

  //! Create an immediate that can be used by VPTERNLOG[D|Q] instructions.
  static constexpr uint32_t make(uint32_t b000, uint32_t b001, uint32_t b010, uint32_t b011, uint32_t b100, uint32_t b101, uint32_t b110, uint32_t b111) noexcept {
    return (b000 << 0) | (b001 << 1) | (b010 << 2) | (b011 << 3) | (b100 << 4) | (b101 << 5) | (b110 << 6) | (b111 << 7);
  }

  //! Create an immediate that can be used by VPTERNLOG[D|Q] instructions.
  static constexpr uint32_t value(uint32_t x) noexcept { return x & 0xFF; }
  //! Negate an immediate that can be used by VPTERNLOG[D|Q] instructions.
  static constexpr uint32_t negate(uint32_t x) noexcept { return x ^ 0xFF; }
  //! Create an if/else logic that can be used by VPTERNLOG[D|Q] instructions.
  static constexpr uint32_t ifElse(uint32_t condition, uint32_t a, uint32_t b) noexcept { return (condition & a) | (negate(condition) & b); }
}

//! \}

ASMJIT_END_SUB_NAMESPACE

// [Guard]
#endif // _ASMJIT_X86_X86GLOBALS_H

```

`Avanguard/AsmJit/asmjit/x86/x86instdb.h`:

```h
// [AsmJit]
// Complete x86/x64 JIT and Remote Assembler for C++.
//
// [License]
// ZLIB - See LICENSE.md file in the package.

// [Guard]
#ifndef _ASMJIT_X86_X86INSTDB_H
#define _ASMJIT_X86_X86INSTDB_H

// [Dependencies]
#include "../x86/x86globals.h"

ASMJIT_BEGIN_SUB_NAMESPACE(x86)

//! \addtogroup asmjit_x86_db
//! \{

//! Instruction database (X86).
namespace InstDB {

// ============================================================================
// [asmjit::x86::InstDB::ArchMask]
// ============================================================================

//! Architecture mask.
enum ArchMask : uint32_t {
  kArchMaskNone           = 0x00u,       //!< No arch (invalid).
  kArchMaskX86            = 0x01u,       //!< X86 mode supported.
  kArchMaskX64            = 0x02u        //!< X64 mode supported.
};

static inline uint32_t archMaskFromArchId(uint32_t archId) noexcept {
  return archId == ArchInfo::kIdX86 ? kArchMaskX86 :
         archId == ArchInfo::kIdX64 ? kArchMaskX64 : kArchMaskNone;
}

// ============================================================================
// [asmjit::x86::InstDB::OpFlags]
// ============================================================================

//! Operand flags (X86).
enum OpFlags : uint32_t {
  kOpNone                 = 0x00000000u, //!< No flags.

  kOpGpbLo                = 0x00000001u, //!< Operand can be low 8-bit GPB register.
  kOpGpbHi                = 0x00000002u, //!< Operand can be high 8-bit GPB register.
  kOpGpw                  = 0x00000004u, //!< Operand can be 16-bit GPW register.
  kOpGpd                  = 0x00000008u, //!< Operand can be 32-bit GPD register.
  kOpGpq                  = 0x00000010u, //!< Operand can be 64-bit GPQ register.
  kOpXmm                  = 0x00000020u, //!< Operand can be 128-bit XMM register.
  kOpYmm                  = 0x00000040u, //!< Operand can be 256-bit YMM register.
  kOpZmm                  = 0x00000080u, //!< Operand can be 512-bit ZMM register.
  kOpMm                   = 0x00000100u, //!< Operand can be 64-bit MM register.
  kOpKReg                 = 0x00000200u, //!< Operand can be 64-bit K register.
  kOpSReg                 = 0x00000400u, //!< Operand can be SReg (segment register).
  kOpCReg                 = 0x00000800u, //!< Operand can be CReg (control register).
  kOpDReg                 = 0x00001000u, //!< Operand can be DReg (debug register).
  kOpSt                   = 0x00002000u, //!< Operand can be 80-bit ST register (FPU).
  kOpBnd                  = 0x00004000u, //!< Operand can be 128-bit BND register.
  kOpAllRegs              = 0x00007FFFu, //!< Combination of all possible registers.

  kOpU4                   = 0x00010000u, //!< Operand can be unsigned 4-bit  immediate.
  kOpI8                   = 0x00020000u, //!< Operand can be signed   8-bit  immediate.
  kOpU8                   = 0x00040000u, //!< Operand can be unsigned 8-bit  immediate.
  kOpI16                  = 0x00080000u, //!< Operand can be signed   16-bit immediate.
  kOpU16                  = 0x00100000u, //!< Operand can be unsigned 16-bit immediate.
  kOpI32                  = 0x00200000u, //!< Operand can be signed   32-bit immediate.
  kOpU32                  = 0x00400000u, //!< Operand can be unsigned 32-bit immediate.
  kOpI64                  = 0x00800000u, //!< Operand can be signed   64-bit immediate.
  kOpU64                  = 0x01000000u, //!< Operand can be unsigned 64-bit immediate.
  kOpAllImm               = 0x01FF0000u, //!< Operand can be any immediate.

  kOpMem                  = 0x02000000u, //!< Operand can be a scalar memory pointer.
  kOpVm                   = 0x04000000u, //!< Operand can be a vector memory pointer.

  kOpRel8                 = 0x08000000u, //!< Operand can be relative 8-bit  displacement.
  kOpRel32                = 0x10000000u, //!< Operand can be relative 32-bit displacement.

  kOpR                    = 0x20000000u, //!< Operand is read.
  kOpW                    = 0x40000000u, //!< Operand is written.
  kOpX                    = 0x60000000u, //!< Operand is read & written.
  kOpImplicit             = 0x80000000u  //!< Operand is implicit.
};

// ============================================================================
// [asmjit::x86::InstDB::MemFlags]
// ============================================================================

//! Memory operand flags (X86).
enum MemFlags : uint32_t {
  // NOTE: Instruction uses either scalar or vector memory operands, they never
  // collide. This allows us to share bits between "M" and "Vm" enums.

  kMemOpAny               = 0x0001u,     //!< Operand can be any scalar memory pointer.
  kMemOpM8                = 0x0002u,     //!< Operand can be an 8-bit memory pointer.
  kMemOpM16               = 0x0004u,     //!< Operand can be a 16-bit memory pointer.
  kMemOpM32               = 0x0008u,     //!< Operand can be a 32-bit memory pointer.
  kMemOpM48               = 0x0010u,     //!< Operand can be a 32-bit memory pointer.
  kMemOpM64               = 0x0020u,     //!< Operand can be a 64-bit memory pointer.
  kMemOpM80               = 0x0040u,     //!< Operand can be an 80-bit memory pointer.
  kMemOpM128              = 0x0080u,     //!< Operand can be a 128-bit memory pointer.
  kMemOpM256              = 0x0100u,     //!< Operand can be a 256-bit memory pointer.
  kMemOpM512              = 0x0200u,     //!< Operand can be a 512-bit memory pointer.
  kMemOpM1024             = 0x0400u,     //!< Operand can be a 1024-bit memory pointer.

  kMemOpVm32x             = 0x0002u,     //!< Operand can be a vm32x (vector) pointer.
  kMemOpVm32y             = 0x0004u,     //!< Operand can be a vm32y (vector) pointer.
  kMemOpVm32z             = 0x0008u,     //!< Operand can be a vm32z (vector) pointer.
  kMemOpVm64x             = 0x0020u,     //!< Operand can be a vm64x (vector) pointer.
  kMemOpVm64y             = 0x0040u,     //!< Operand can be a vm64y (vector) pointer.
  kMemOpVm64z             = 0x0080u,     //!< Operand can be a vm64z (vector) pointer.

  kMemOpBaseOnly          = 0x0800u,     //!< Only memory base is allowed (no index, no offset).
  kMemOpDs                = 0x1000u,     //!< Implicit memory operand's DS segment.
  kMemOpEs                = 0x2000u,     //!< Implicit memory operand's ES segment.

  kMemOpMib               = 0x4000u      //!< Operand must be MIB (base+index) pointer.
};

// ============================================================================
// [asmjit::x86::InstDB::Encoding]
// ============================================================================

//! Instruction encoding (X86).
enum EncodingId : uint32_t {
  kEncodingNone = 0,                     //!< Never used.
  kEncodingX86Op,                        //!< X86 [OP].
  kEncodingX86Op_O,                      //!< X86 [OP] (opcode and /0-7).
  kEncodingX86Op_O_I8,                   //!< X86 [OP] (opcode and /0-7 + 8-bit immediate).
  kEncodingX86Op_xAX,                    //!< X86 [OP] (implicit or explicit '?AX' form).
  kEncodingX86Op_xDX_xAX,                //!< X86 [OP] (implicit or explicit '?DX, ?AX' form).
  kEncodingX86Op_ZAX,                    //!< X86 [OP] (implicit or explicit '[EAX|RAX]' form).
  kEncodingX86I_xAX,                     //!< X86 [I] (implicit or explicit '?AX' form).
  kEncodingX86M,                         //!< X86 [M] (handles 2|4|8-bytes size).
  kEncodingX86M_NoSize,                  //!< X86 [M] (doesn't handle any size).
  kEncodingX86M_GPB,                     //!< X86 [M] (handles single-byte size).
  kEncodingX86M_GPB_MulDiv,              //!< X86 [M] (like GPB, handles implicit|explicit MUL|DIV|IDIV).
  kEncodingX86M_Only,                    //!< X86 [M] (restricted to memory operand of any size).
  kEncodingX86Rm,                        //!< X86 [RM] (doesn't handle single-byte size).
  kEncodingX86Rm_Raw66H,                 //!< X86 [RM] (used by LZCNT, POPCNT, and TZCNT).
  kEncodingX86Rm_NoRexW,                 //!< X86 [RM] (doesn't add REX.W prefix if 64-bit reg is used).
  kEncodingX86Mr,                        //!< X86 [MR] (doesn't handle single-byte size).
  kEncodingX86Mr_NoSize,                 //!< X86 [MR] (doesn't handle any size).
  kEncodingX86Arith,                     //!< X86 adc, add, and, cmp, or, sbb, sub, xor.
  kEncodingX86Bswap,                     //!< X86 bswap.
  kEncodingX86Bt,                        //!< X86 bt, btc, btr, bts.
  kEncodingX86Call,                      //!< X86 call.
  kEncodingX86Cmpxchg,                   //!< X86 [MR] cmpxchg.
  kEncodingX86Cmpxchg8b_16b,             //!< X86 [MR] cmpxchg8b, cmpxchg16b.
  kEncodingX86Crc,                       //!< X86 crc32.
  kEncodingX86Enter,                     //!< X86 enter.
  kEncodingX86Imul,                      //!< X86 imul.
  kEncodingX86In,                        //!< X86 in.
  kEncodingX86Ins,                       //!< X86 ins[b|q|d].
  kEncodingX86IncDec,                    //!< X86 inc, dec.
  kEncodingX86Int,                       //!< X86 int (interrupt).
  kEncodingX86Jcc,                       //!< X86 jcc.
  kEncodingX86JecxzLoop,                 //!< X86 jcxz, jecxz, jrcxz, loop, loope, loopne.
  kEncodingX86Jmp,                       //!< X86 jmp.
  kEncodingX86JmpRel,                    //!< X86 xbegin.
  kEncodingX86Lea,                       //!< X86 lea.
  kEncodingX86Mov,                       //!< X86 mov (all possible cases).
  kEncodingX86MovsxMovzx,                //!< X86 movsx, movzx.
  kEncodingX86Out,                       //!< X86 out.
  kEncodingX86Outs,                      //!< X86 out[b|q|d].
  kEncodingX86Push,                      //!< X86 push.
  kEncodingX86Pop,                       //!< X86 pop.
  kEncodingX86Ret,                       //!< X86 ret.
  kEncodingX86Rot,                       //!< X86 rcl, rcr, rol, ror, sal, sar, shl, shr.
  kEncodingX86Set,                       //!< X86 setcc.
  kEncodingX86ShldShrd,                  //!< X86 shld, shrd.
  kEncodingX86StrRm,                     //!< X86 lods.
  kEncodingX86StrMr,                     //!< X86 scas, stos.
  kEncodingX86StrMm,                     //!< X86 cmps, movs.
  kEncodingX86Test,                      //!< X86 test.
  kEncodingX86Xadd,                      //!< X86 xadd.
  kEncodingX86Xchg,                      //!< X86 xchg.
  kEncodingX86Fence,                     //!< X86 lfence, mfence, sfence.
  kEncodingX86Bndmov,                    //!< X86 [RM|MR] (used by BNDMOV).
  kEncodingFpuOp,                        //!< FPU [OP].
  kEncodingFpuArith,                     //!< FPU fadd, fdiv, fdivr, fmul, fsub, fsubr.
  kEncodingFpuCom,                       //!< FPU fcom, fcomp.
  kEncodingFpuFldFst,                    //!< FPU fld, fst, fstp.
  kEncodingFpuM,                         //!< FPU fiadd, ficom, ficomp, fidiv, fidivr, fild, fimul, fist, fistp, fisttp, fisub, fisubr.
  kEncodingFpuR,                         //!< FPU fcmov, fcomi, fcomip, ffree, fucom, fucomi, fucomip, fucomp, fxch.
  kEncodingFpuRDef,                      //!< FPU faddp, fdivp, fdivrp, fmulp, fsubp, fsubrp.
  kEncodingFpuStsw,                      //!< FPU fnstsw, Fstsw.
  kEncodingExtRm,                        //!< EXT [RM].
  kEncodingExtRm_XMM0,                   //!< EXT [RM<XMM0>].
  kEncodingExtRm_ZDI,                    //!< EXT [RM<ZDI>].
  kEncodingExtRm_P,                      //!< EXT [RM] (propagates 66H if the instruction uses XMM register).
  kEncodingExtRm_Wx,                     //!< EXT [RM] (propagates REX.W if GPQ is used).
  kEncodingExtRmRi,                      //!< EXT [RM|RI].
  kEncodingExtRmRi_P,                    //!< EXT [RM|RI] (propagates 66H if the instruction uses XMM register).
  kEncodingExtRmi,                       //!< EXT [RMI].
  kEncodingExtRmi_P,                     //!< EXT [RMI] (propagates 66H if the instruction uses XMM register).
  kEncodingExtPextrw,                    //!< EXT pextrw.
  kEncodingExtExtract,                   //!< EXT pextrb, pextrd, pextrq, extractps.
  kEncodingExtMov,                       //!< EXT mov?? - #1:[MM|XMM, MM|XMM|Mem] #2:[MM|XMM|Mem, MM|XMM].
  kEncodingExtMovnti,                    //!< EXT movnti.
  kEncodingExtMovbe,                     //!< EXT movbe.
  kEncodingExtMovd,                      //!< EXT movd.
  kEncodingExtMovq,                      //!< EXT movq.
  kEncodingExtExtrq,                     //!< EXT extrq (SSE4A).
  kEncodingExtInsertq,                   //!< EXT insrq (SSE4A).
  kEncodingExt3dNow,                     //!< EXT [RMI] (3DNOW specific).
  kEncodingVexOp,                        //!< VEX [OP].
  kEncodingVexKmov,                      //!< VEX [RM|MR] (used by kmov[b|w|d|q]).
  kEncodingVexM,                         //!< VEX|EVEX [M].
  kEncodingVexM_VM,                      //!< VEX|EVEX [M] (propagates VEX|EVEX.L, VSIB support).
  kEncodingVexMr_Lx,                     //!< VEX|EVEX [MR] (propagates VEX|EVEX.L if YMM used).
  kEncodingVexMr_VM,                     //!< VEX|EVEX [MR] (propagates VEX|EVEX.L, VSIB support).
  kEncodingVexMri,                       //!< VEX|EVEX [MRI].
  kEncodingVexMri_Lx,                    //!< VEX|EVEX [MRI] (propagates VEX|EVEX.L if YMM used).
  kEncodingVexRm,                        //!< VEX|EVEX [RM].
  kEncodingVexRm_ZDI,                    //!< VEX|EVEX [RM<ZDI>].
  kEncodingVexRm_Wx,                     //!< VEX|EVEX [RM] (propagates VEX|EVEX.W if GPQ used).
  kEncodingVexRm_Lx,                     //!< VEX|EVEX [RM] (propagates VEX|EVEX.L if YMM used).
  kEncodingVexRm_VM,                     //!< VEX|EVEX [RM] (propagates VEX|EVEX.L, VSIB support).
  kEncodingVexRm_T1_4X,                  //!<     EVEX [RM] (used by NN instructions that use RM-T1_4X encoding).
  kEncodingVexRmi,                       //!< VEX|EVEX [RMI].
  kEncodingVexRmi_Wx,                    //!< VEX|EVEX [RMI] (propagates VEX|EVEX.W if GPQ used).
  kEncodingVexRmi_Lx,                    //!< VEX|EVEX [RMI] (propagates VEX|EVEX.L if YMM used).
  kEncodingVexRvm,                       //!< VEX|EVEX [RVM].
  kEncodingVexRvm_Wx,                    //!< VEX|EVEX [RVM] (propagates VEX|EVEX.W if GPQ used).
  kEncodingVexRvm_ZDX_Wx,                //!< VEX|EVEX [RVM<ZDX>] (propagates VEX|EVEX.W if GPQ used).
  kEncodingVexRvm_Lx,                    //!< VEX|EVEX [RVM] (propagates VEX|EVEX.L if YMM used).
  kEncodingVexRvmr,                      //!< VEX|EVEX [RVMR].
  kEncodingVexRvmr_Lx,                   //!< VEX|EVEX [RVMR] (propagates VEX|EVEX.L if YMM used).
  kEncodingVexRvmi,                      //!< VEX|EVEX [RVMI].
  kEncodingVexRvmi_Lx,                   //!< VEX|EVEX [RVMI] (propagates VEX|EVEX.L if YMM used).
  kEncodingVexRmv,                       //!< VEX|EVEX [RMV].
  kEncodingVexRmv_Wx,                    //!< VEX|EVEX [RMV] (propagates VEX|EVEX.W if GPQ used).
  kEncodingVexRmv_VM,                    //!< VEX|EVEX [RMV] (propagates VEX|EVEX.L, VSIB support).
  kEncodingVexRmvRm_VM,                  //!< VEX|EVEX [RMV|RM] (propagates VEX|EVEX.L, VSIB support).
  kEncodingVexRmvi,                      //!< VEX|EVEX [RMVI].
  kEncodingVexRmMr,                      //!< VEX|EVEX [RM|MR].
  kEncodingVexRmMr_Lx,                   //!< VEX|EVEX [RM|MR] (propagates VEX|EVEX.L if YMM used).
  kEncodingVexRvmRmv,                    //!< VEX|EVEX [RVM|RMV].
  kEncodingVexRvmRmi,                    //!< VEX|EVEX [RVM|RMI].
  kEncodingVexRvmRmi_Lx,                 //!< VEX|EVEX [RVM|RMI] (propagates VEX|EVEX.L if YMM used).
  kEncodingVexRvmRmvRmi,                 //!< VEX|EVEX [RVM|RMV|RMI].
  kEncodingVexRvmMr,                     //!< VEX|EVEX [RVM|MR].
  kEncodingVexRvmMvr,                    //!< VEX|EVEX [RVM|MVR].
  kEncodingVexRvmMvr_Lx,                 //!< VEX|EVEX [RVM|MVR] (propagates VEX|EVEX.L if YMM used).
  kEncodingVexRvmVmi,                    //!< VEX|EVEX [RVM|VMI].
  kEncodingVexRvmVmi_Lx,                 //!< VEX|EVEX [RVM|VMI] (propagates VEX|EVEX.L if YMM used).
  kEncodingVexVm,                        //!< VEX|EVEX [VM].
  kEncodingVexVm_Wx,                     //!< VEX|EVEX [VM] (propagates VEX|EVEX.W if GPQ used).
  kEncodingVexVmi,                       //!< VEX|EVEX [VMI].
  kEncodingVexVmi_Lx,                    //!< VEX|EVEX [VMI] (propagates VEX|EVEX.L if YMM used).
  kEncodingVexEvexVmi_Lx,                //!< VEX|EVEX [VMI] (special, used by vpsrldq and vpslldq)
  kEncodingVexRvrmRvmr,                  //!< VEX|EVEX [RVRM|RVMR].
  kEncodingVexRvrmRvmr_Lx,               //!< VEX|EVEX [RVRM|RVMR] (propagates VEX|EVEX.L if YMM used).
  kEncodingVexRvrmiRvmri_Lx,             //!< VEX|EVEX [RVRMI|RVMRI] (propagates VEX|EVEX.L if YMM used).
  kEncodingVexMovdMovq,                  //!< VEX|EVEX vmovd, vmovq.
  kEncodingVexMovssMovsd,                //!< VEX|EVEX vmovss, vmovsd.
  kEncodingFma4,                         //!< FMA4 [R, R, R/M, R/M].
  kEncodingFma4_Lx,                      //!< FMA4 [R, R, R/M, R/M] (propagates AVX.L if YMM used).
  kEncodingCount                         //!< Count of instruction encodings.
};

// ============================================================================
// [asmjit::x86::InstDB::Flags]
// ============================================================================

//! Instruction flags (X86).
//!
//! Details about instruction encoding, operation, features, and some limitations.
enum Flags : uint32_t {
  kFlagNone               = 0x00000000u, //!< No flags.

  // Operand's Use
  // -------------
  //
  // These flags describe the use of 1st and/or 1st+2nd operands. This allows
  // to fast calculate which operands are read, written, or read and written.
  //
  // In some cases this information is not reliable, because AsmJit uses data
  // generated by a script that merges usually more than one instruction into
  // one AsmJit instruction as some X86 instructions uses more encodings to
  // describe the same operation. In such case `kFlagUseComplex` is set and
  // AsmJit will use different approach to calculate operand's use flags.

  kFlagUseA               = 0x00000001u, //!< Use flags are ambiguous as USE information couldn't be flattened.
  kFlagUseR               = 0x00000002u, //!< 1st operand is R (read), read-only if `kFlagOpW` isn't set.
  kFlagUseW               = 0x00000004u, //!< 1st operand is W (written), write-only if `kFlagOpR` isn't set.
  kFlagUseX               = 0x00000006u, //!< 1st operand is X (read-write).
  kFlagUseXX              = 0x00000008u, //!< 1st and 2nd operands are XX (read & written) (XCHG, XADD).

  kFlagFixedReg           = 0x00000010u, //!< Some operand uses fixed register.
  kFlagFixedMem           = 0x00000020u, //!< Some operand uses fixed register to access memory (EAX|RAX, EDI|RDI, ESI|RSI).
  kFlagFixedRM            = 0x00000030u, //!< Combination of `kFlagUseFixedReg` and `kFlagUseFixedMem`.

  kFlagVolatile           = 0x00000040u,
  kFlagPrivileged         = 0x00000080u, //!< This is a privileged operation that cannot run in user mode.

  // Instruction Family
  // ------------------
  //
  // Instruction family information.

  kFlagFpu                = 0x00000100u, //!< Instruction that accesses FPU registers.
  kFlagMmx                = 0x00000200u, //!< Instruction that accesses MMX registers (including 3DNOW and GEODE) and EMMS.
  kFlagVec                = 0x00000400u, //!< Instruction that accesses XMM registers (SSE, AVX, AVX512).

  // Prefixes and Encoding Flags
  // ---------------------------
  //
  // These describe optional X86 prefixes that can be used to change the instruction's operation.

  kFlagRep                = 0x00001000u, //!< Instruction can be prefixed with using the REP/REPE/REPZ prefix.
  kFlagRepne              = 0x00002000u, //!< Instruction can be prefixed with using the REPNE/REPNZ prefix.
  kFlagLock               = 0x00004000u, //!< Instruction can be prefixed with using the LOCK prefix.
  kFlagXAcquire           = 0x00008000u, //!< Instruction can be prefixed with using the XACQUIRE prefix.
  kFlagXRelease           = 0x00010000u, //!< Instruction can be prefixed with using the XRELEASE prefix.
  kFlagMib                = 0x00020000u, //!< Instruction uses MIB (BNDLDX|BNDSTX) to encode two registers.
  kFlagVsib               = 0x00040000u, //!< Instruction uses VSIB instead of legacy SIB.
  kFlagVex                = 0x00080000u, //!< Instruction can be encoded by VEX|XOP (AVX|AVX2|BMI|XOP|...).
  kFlagEvex               = 0x00100000u, //!< Instruction can be encoded by EVEX (AVX512).

  // FPU Flags
  // ---------
  //
  // Used to tell the encoder which memory operand sizes are encodable.

  kFlagFpuM16             = 0x00200000u, //!< FPU instruction can address `word_ptr` (shared with M10).
  kFlagFpuM32             = 0x00400000u, //!< FPU instruction can address `dword_ptr`.
  kFlagFpuM64             = 0x00800000u, //!< FPU instruction can address `qword_ptr`.
  kFlagFpuM80             = 0x00200000u, //!< FPU instruction can address `tword_ptr` (shared with M2).

  // AVX and AVX515 Flags
  // --------------------
  //
  // If both `kFlagPrefixVex` and `kFlagPrefixEvex` flags are specified it
  // means that the instructions can be encoded by either VEX or EVEX prefix.
  // In that case AsmJit checks global options and also instruction options
  // to decide whether to emit VEX or EVEX prefix.

  kFlagAvx512_            = 0x00000000u, //!< Internally used in tables, has no meaning.
  kFlagAvx512K            = 0x01000000u, //!< Supports masking {k1..k7}.
  kFlagAvx512Z            = 0x02000000u, //!< Supports zeroing {z}, must be used together with `kAvx512k`.
  kFlagAvx512ER           = 0x04000000u, //!< Supports 'embedded-rounding' {er} with implicit {sae},
  kFlagAvx512SAE          = 0x08000000u, //!< Supports 'suppress-all-exceptions' {sae}.
  kFlagAvx512B32          = 0x10000000u, //!< Supports 32-bit broadcast 'b32'.
  kFlagAvx512B64          = 0x20000000u, //!< Supports 64-bit broadcast 'b64'.
  kFlagAvx512T4X          = 0x80000000u, //!< Operates on a vector of consecutive registers (AVX512_4FMAPS and AVX512_4VNNIW).

  // Combinations used by instruction tables to make AVX512 definitions more compact.
  kFlagAvx512KZ            = kFlagAvx512K         | kFlagAvx512Z,
  kFlagAvx512ER_SAE        = kFlagAvx512ER        | kFlagAvx512SAE,
  kFlagAvx512KZ_SAE        = kFlagAvx512KZ        | kFlagAvx512SAE,
  kFlagAvx512KZ_SAE_B32    = kFlagAvx512KZ_SAE    | kFlagAvx512B32,
  kFlagAvx512KZ_SAE_B64    = kFlagAvx512KZ_SAE    | kFlagAvx512B64,

  kFlagAvx512KZ_ER_SAE     = kFlagAvx512KZ        | kFlagAvx512ER_SAE,
  kFlagAvx512KZ_ER_SAE_B32 = kFlagAvx512KZ_ER_SAE | kFlagAvx512B32,
  kFlagAvx512KZ_ER_SAE_B64 = kFlagAvx512KZ_ER_SAE | kFlagAvx512B64,

  kFlagAvx512K_B32         = kFlagAvx512K         | kFlagAvx512B32,
  kFlagAvx512K_B64         = kFlagAvx512K         | kFlagAvx512B64,
  kFlagAvx512KZ_B32        = kFlagAvx512KZ        | kFlagAvx512B32,
  kFlagAvx512KZ_B64        = kFlagAvx512KZ        | kFlagAvx512B64
};

// ============================================================================
// [asmjit::x86::InstDB::SpecialCases]
// ============================================================================

//! Cases that require special handling.
enum SpecialCases : uint32_t {
  kSpecialCaseMovCrDr     = 0x00000001u, //!< `MOV REG <-> CREG|DREG` - Defined/Undefined flags, L0/L3 privilege levels.
  kSpecialCaseMovSsSd     = 0x00000002u  //!< `MOVSS|MOVSD XMM, [MEM]` - Destination operand is completely overwritten.
};

// ============================================================================
// [asmjit::x86::InstDB::OperationFlags]
// ============================================================================

//! Used to describe what the instruction does and some of its quirks.
enum OperationFlags : uint32_t {
  kOperationVolatile      = 0x00000001u  //!< Hint for instruction schedulers to never reorder this instruction (side effects, memory barrier, etc).
};

// ============================================================================
// [asmjit::x86::InstDB::SingleRegCase]
// ============================================================================

enum SingleRegCase : uint32_t {
  kSingleRegNone          = 0,           //!< No special handling.
  kSingleRegRO            = 1,           //!< Operands become read-only  - `REG & REG` and similar.
  kSingleRegWO            = 2            //!< Operands become write-only - `REG ^ REG` and similar.
};

ASMJIT_VARAPI const char _nameData[];

// ============================================================================
// [asmjit::x86::InstDB::OpSignature]
// ============================================================================

//! Operand signature (X86).
//!
//! Contains all possible operand combinations, memory size information, and
//! a fixed register id (or `BaseReg::kIdBad` if fixed id isn't required).
struct OpSignature {
  uint32_t opFlags;                      //!< Operand flags.
  uint16_t memFlags;                     //!< Memory flags.
  uint8_t extFlags;                      //!< Extra flags.
  uint8_t regMask;                       //!< Mask of possible register IDs.
};

ASMJIT_VARAPI const OpSignature _opSignatureTable[];

// ============================================================================
// [asmjit::x86::InstDB::InstSignature]
// ============================================================================

//! Instruction signature (X86).
//!
//! Contains a sequence of operands' combinations and other metadata that defines
//! a single instruction. This data is used by instruction validator.
struct InstSignature {
  uint8_t opCount  : 3;                  //!< Count of operands in `opIndex` (0..6).
  uint8_t archMask : 2;                  //!< Architecture mask of this record.
  uint8_t implicit : 3;                  //!< Number of implicit operands.
  uint8_t reserved;                      //!< Reserved for future use.
  uint8_t operands[Globals::kMaxOpCount];//!< Indexes to `OpSignature` table.
};

ASMJIT_VARAPI const InstSignature _instSignatureTable[];

// ============================================================================
// [asmjit::x86::InstDB::CommonInfo]
// ============================================================================

//! Instruction common information (X86)
//!
//! Aggregated information shared across one or more instruction.
struct CommonInfo {
  // --------------------------------------------------------------------------
  // [Accessors]
  // --------------------------------------------------------------------------

  //! Get all instruction flags, see `InstInfo::Flags`.
  inline uint32_t flags() const noexcept { return _flags; }
  //! Get whether the instruction has a `flag`, see `InstInfo::Flags`.
  inline bool hasFlag(uint32_t flag) const noexcept { return (_flags & flag) != 0; }

  //! Get whether the instruction is FPU instruction.
  inline bool isFpu() const noexcept { return hasFlag(kFlagFpu); }
  //! Get whether the instruction is MMX/3DNOW instruction that accesses MMX registers (includes EMMS and FEMMS).
  inline bool isMmx() const noexcept { return hasFlag(kFlagMmx); }
  //! Get whether the instruction is SSE|AVX|AVX512 instruction that accesses XMM|YMM|ZMM registers.
  inline bool isVec() const noexcept { return hasFlag(kFlagVec); }
  //! Get whether the instruction is SSE+ (SSE4.2, AES, SHA included) instruction that accesses XMM registers.
  inline bool isSse() const noexcept { return (flags() & (kFlagVec | kFlagVex | kFlagEvex)) == kFlagVec; }
  //! Get whether the instruction is AVX+ (FMA included) instruction that accesses XMM|YMM|ZMM registers.
  inline bool isAvx() const noexcept { return isVec() && isVexOrEvex(); }

  //! Get whether the instruction can be prefixed with LOCK prefix.
  inline bool hasLockPrefix() const noexcept { return hasFlag(kFlagLock); }
  //! Get whether the instruction can be prefixed with REP (REPE|REPZ) prefix.
  inline bool hasRepPrefix() const noexcept { return hasFlag(kFlagRep); }
  //! Get whether the instruction can be prefixed with REPNE (REPNZ) prefix.
  inline bool hasRepnePrefix() const noexcept { return hasFlag(kFlagRepne); }
  //! Get whether the instruction can be prefixed with XACQUIRE prefix.
  inline bool hasXAcquirePrefix() const noexcept { return hasFlag(kFlagXAcquire); }
  //! Get whether the instruction can be prefixed with XRELEASE prefix.
  inline bool hasXReleasePrefix() const noexcept { return hasFlag(kFlagXRelease); }

  //! Get whether the instruction uses MIB.
  inline bool isMibOp() const noexcept { return hasFlag(kFlagMib); }
  //! Get whether the instruction uses VSIB.
  inline bool isVsibOp() const noexcept { return hasFlag(kFlagVsib); }
  //! Get whether the instruction uses VEX (can be set together with EVEX if both are encodable).
  inline bool isVex() const noexcept { return hasFlag(kFlagVex); }
  //! Get whether the instruction uses EVEX (can be set together with VEX if both are encodable).
  inline bool isEvex() const noexcept { return hasFlag(kFlagEvex); }
  //! Get whether the instruction uses EVEX (can be set together with VEX if both are encodable).
  inline bool isVexOrEvex() const noexcept { return hasFlag(kFlagVex | kFlagEvex); }

  //! Get whether the instruction supports AVX512 masking {k}.
  inline bool hasAvx512K() const noexcept { return hasFlag(kFlagAvx512K); }
  //! Get whether the instruction supports AVX512 zeroing {k}{z}.
  inline bool hasAvx512Z() const noexcept { return hasFlag(kFlagAvx512Z); }
  //! Get whether the instruction supports AVX512 embedded-rounding {er}.
  inline bool hasAvx512ER() const noexcept { return hasFlag(kFlagAvx512ER); }
  //! Get whether the instruction supports AVX512 suppress-all-exceptions {sae}.
  inline bool hasAvx512SAE() const noexcept { return hasFlag(kFlagAvx512SAE); }
  //! Get whether the instruction supports AVX512 broadcast (either 32-bit or 64-bit).
  inline bool hasAvx512B() const noexcept { return hasFlag(kFlagAvx512B32 | kFlagAvx512B64); }
  //! Get whether the instruction supports AVX512 broadcast (32-bit).
  inline bool hasAvx512B32() const noexcept { return hasFlag(kFlagAvx512B32); }
  //! Get whether the instruction supports AVX512 broadcast (64-bit).
  inline bool hasAvx512B64() const noexcept { return hasFlag(kFlagAvx512B64); }

  //! Get the destination index of WRITE operation.
  inline uint32_t writeIndex() const noexcept { return _writeIndex; }
  //! Get the number of bytes that will be written by a WRITE operation.
  //!
  //! This information is required by a liveness analysis to mark virtual
  //! registers dead even if the instruction doesn't completely overwrite
  //! the whole register. If the analysis keeps which bytes are completely
  //! overwritten by the instruction it can find the where a register becomes
  //! dead by simply checking if the instruction overwrites all remaining
  //! bytes.
  inline uint32_t writeSize() const noexcept { return _writeSize; }

  inline uint32_t signatureIndex() const noexcept { return _iSignatureIndex; }
  inline uint32_t signatureCount() const noexcept { return _iSignatureCount; }

  inline const InstSignature* signatureData() const noexcept { return _instSignatureTable + _iSignatureIndex; }
  inline const InstSignature* signatureEnd() const noexcept { return _instSignatureTable + _iSignatureIndex + _iSignatureCount; }

  //! Get the control-flow type of the instruction.
  inline uint32_t controlType() const noexcept { return _controlType; }

  inline uint32_t singleRegCase() const noexcept { return _singleRegCase; }
  inline uint32_t specialCases() const noexcept { return _specialCases; }

  // --------------------------------------------------------------------------
  // [Members]
  // --------------------------------------------------------------------------

  uint32_t _flags;                       //!< Instruction flags.
  uint32_t _writeIndex         :  8;     //!< First DST byte of a WRITE operation (default 0).
  uint32_t _writeSize          : 24;     //!< Number of bytes to be written in DST.

  uint32_t _iSignatureIndex    : 11;     //!< First `InstSignature` entry in the database.
  uint32_t _iSignatureCount    :  5;     //!< Number of relevant `ISignature` entries.
  uint32_t _controlType        :  3;     //!< Control type, see `ControlType`.
  uint32_t _singleRegCase      :  2;     //!< Specifies what happens if all source operands share the same register.
  uint32_t _specialCases       :  4;     //!< Special cases.
  uint32_t _reserved           :  7;     //!< Reserved.
};

ASMJIT_VARAPI const CommonInfo _commonInfoTable[];

// ============================================================================
// [asmjit::x86::InstDB::ExecutionInfo]
// ============================================================================

//! Detailed data about instruction's operation, requirements, and side-effects.
struct ExecutionInfo {
  // --------------------------------------------------------------------------
  // [Accessors]
  // --------------------------------------------------------------------------

  ASMJIT_INLINE bool hasFeature(uint32_t feature) const noexcept {
    for (uint32_t i = 0; i < ASMJIT_ARRAY_SIZE(_features); i++)
      if (feature == _features[i])
        return true;
    return false;
  }

  inline uint32_t specialRegsR() const noexcept { return _specialRegsR; }
  inline uint32_t specialRegsW() const noexcept { return _specialRegsW; }

  inline const uint8_t* featuresData() const noexcept { return _features; }
  inline const uint8_t* featuresEnd() const noexcept { return _features + ASMJIT_ARRAY_SIZE(_features); }

  // --------------------------------------------------------------------------
  // [Members]
  // --------------------------------------------------------------------------

  uint16_t _flags;                     //!< Operation flags.
  uint8_t _features[6];                //!< Features vector.
  uint32_t _specialRegsR;              //!< Special registers read.
  uint32_t _specialRegsW;              //!< Special registers written.
};

ASMJIT_VARAPI const ExecutionInfo _executionInfoTable[];

// ============================================================================
// [asmjit::x86::InstDB::InstInfo]
// ============================================================================

//! Instruction information (X86).
struct InstInfo {
  // --------------------------------------------------------------------------
  // [Accessors]
  // --------------------------------------------------------------------------

  //! Get instruction name (null terminated).
  //!
  //! NOTE: If AsmJit was compiled with `ASMJIT_DISABLE_TEXT` then this will
  //! return an empty string (null terminated string of zero size).
  inline const char* name() const noexcept { return _nameData + _nameDataIndex; };

  //! Get common information, see `CommonInfo`.
  inline const CommonInfo& commonInfo() const noexcept { return _commonInfoTable[_commonInfoIndex]; }
  //! Get execution information, see `ExecutionInfo`.
  inline const ExecutionInfo& executionInfo() const noexcept { return _executionInfoTable[_executionInfoIndex]; }

  //! Get whether the instruction has flag `flag`, see `Flags`.
  inline bool hasFlag(uint32_t flag) const noexcept { return commonInfo().hasFlag(flag); }
  //! Get instruction flags, see `Flags`.
  inline uint32_t flags() const noexcept { return commonInfo().flags(); }

  //! Get whether the instruction is FPU instruction.
  inline bool isFpu() const noexcept { return commonInfo().isFpu(); }
  //! Get whether the instruction is MMX/3DNOW instruction that accesses MMX registers (includes EMMS and FEMMS).
  inline bool isMmx() const noexcept { return commonInfo().isMmx(); }
  //! Get whether the instruction is SSE|AVX|AVX512 instruction that accesses XMM|YMM|ZMM registers.
  inline bool isVec() const noexcept { return commonInfo().isVec(); }
  //! Get whether the instruction is SSE+ (SSE4.2, AES, SHA included) instruction that accesses XMM registers.
  inline bool isSse() const noexcept { return commonInfo().isSse(); }
  //! Get whether the instruction is AVX+ (FMA included) instruction that accesses XMM|YMM|ZMM registers.
  inline bool isAvx() const noexcept { return commonInfo().isAvx(); }

  //! Get whether the instruction can be prefixed with LOCK prefix.
  inline bool hasLockPrefix() const noexcept { return commonInfo().hasLockPrefix(); }
  //! Get whether the instruction can be prefixed with REP (REPE|REPZ) prefix.
  inline bool hasRepPrefix() const noexcept { return commonInfo().hasRepPrefix(); }
  //! Get whether the instruction can be prefixed with REPNE (REPNZ) prefix.
  inline bool hasRepnePrefix() const noexcept { return commonInfo().hasRepnePrefix(); }
  //! Get whether the instruction can be prefixed with XACQUIRE prefix.
  inline bool hasXAcquirePrefix() const noexcept { return commonInfo().hasXAcquirePrefix(); }
  //! Get whether the instruction can be prefixed with XRELEASE prefix.
  inline bool hasXReleasePrefix() const noexcept { return commonInfo().hasXReleasePrefix(); }

  //! Get whether the instruction uses MIB.
  inline bool isMibOp() const noexcept { return hasFlag(kFlagMib); }
  //! Get whether the instruction uses VSIB.
  inline bool isVsibOp() const noexcept { return hasFlag(kFlagVsib); }
  //! Get whether the instruction uses VEX (can be set together with EVEX if both are encodable).
  inline bool isVex() const noexcept { return hasFlag(kFlagVex); }
  //! Get whether the instruction uses EVEX (can be set together with VEX if both are encodable).
  inline bool isEvex() const noexcept { return hasFlag(kFlagEvex); }
  //! Get whether the instruction uses EVEX (can be set together with VEX if both are encodable).
  inline bool isVexOrEvex() const noexcept { return hasFlag(kFlagVex | kFlagEvex); }

  //! Get whether the instruction supports AVX512 masking {k}.
  inline bool hasAvx512K() const noexcept { return hasFlag(kFlagAvx512K); }
  //! Get whether the instruction supports AVX512 zeroing {k}{z}.
  inline bool hasAvx512Z() const noexcept { return hasFlag(kFlagAvx512Z); }
  //! Get whether the instruction supports AVX512 embedded-rounding {er}.
  inline bool hasAvx512ER() const noexcept { return hasFlag(kFlagAvx512ER); }
  //! Get whether the instruction supports AVX512 suppress-all-exceptions {sae}.
  inline bool hasAvx512SAE() const noexcept { return hasFlag(kFlagAvx512SAE); }
  //! Get whether the instruction supports AVX512 broadcast (either 32-bit or 64-bit).
  inline bool hasAvx512B() const noexcept { return hasFlag(kFlagAvx512B32 | kFlagAvx512B64); }
  //! Get whether the instruction supports AVX512 broadcast (32-bit).
  inline bool hasAvx512B32() const noexcept { return hasFlag(kFlagAvx512B32); }
  //! Get whether the instruction supports AVX512 broadcast (64-bit).
  inline bool hasAvx512B64() const noexcept { return hasFlag(kFlagAvx512B64); }

  //! Get whether 1st operand is read-only.
  inline bool isUseR() const noexcept { return (flags() & kFlagUseX) == kFlagUseR; }
  //! Get whether 1st operand is write-only.
  inline bool isUseW() const noexcept { return (flags() & kFlagUseX) == kFlagUseW; }
  //! Get whether 1st operand is read-write.
  inline bool isUseX() const noexcept { return (flags() & kFlagUseX) == kFlagUseX; }
  //! Get whether 1st and 2nd operands are read-write.
  inline bool isUseXX() const noexcept { return hasFlag(kFlagUseXX); }

  inline bool hasFixedReg() const noexcept { return hasFlag(kFlagFixedReg); }
  inline bool hasFixedMem() const noexcept { return hasFlag(kFlagFixedMem); }
  inline bool hasFixedRM() const noexcept { return hasFlag(kFlagFixedRM); }

  //! Get the control-flow type of the instruction.
  inline uint32_t controlType() const noexcept { return commonInfo().controlType(); }
  inline uint32_t singleRegCase() const noexcept { return commonInfo().singleRegCase(); }
  inline uint32_t specialCases() const noexcept { return commonInfo().specialCases(); }

  inline uint32_t signatureIndex() const noexcept { return commonInfo().signatureIndex(); }
  inline uint32_t signatureCount() const noexcept { return commonInfo().signatureCount(); }

  inline const InstSignature* signatureData() const noexcept { return commonInfo().signatureData(); }
  inline const InstSignature* signatureEnd() const noexcept { return commonInfo().signatureEnd(); }

  // --------------------------------------------------------------------------
  // [Members]
  // --------------------------------------------------------------------------

  uint32_t _nameDataIndex      : 14;     //!< Index to `_nameData`.
  uint32_t _commonInfoIndex    : 10;     //!< Index to `_commonInfoTable`.
  uint32_t _executionInfoIndex : 8;      //!< Index to `_executionInfoTable`.
};

ASMJIT_VARAPI const InstInfo _instInfoTable[];

#if defined(ASMJIT_EXPORTS)
// TODO: Should not be part of the API, don't export.
ASMJIT_VARAPI const uint8_t _encodingTable[];
ASMJIT_VARAPI const uint32_t _mainOpcodeTable[];
ASMJIT_VARAPI const uint8_t _altOpcodeIndex[];
ASMJIT_VARAPI const uint32_t _altOpcodeTable[];

static inline uint32_t encodingFromId(uint32_t instId) noexcept {
  ASMJIT_ASSERT(Inst::isDefinedId(instId));
  return _encodingTable[instId];
}

static inline uint32_t mainOpcodeFromId(uint32_t instId) noexcept {
  ASMJIT_ASSERT(Inst::isDefinedId(instId));
  return _mainOpcodeTable[instId];
}

static inline uint32_t altOpcodeFromId(uint32_t instId) noexcept {
  ASMJIT_ASSERT(Inst::isDefinedId(instId));
  return _altOpcodeTable[_altOpcodeIndex[instId]];
}
#endif

#ifndef ASMJIT_DISABLE_TEXT
//! Get an instruction ID from a given instruction `name`.
//!
//! NOTE: Instruction name MUST BE in lowercase, otherwise there will be no
//! match. If there is an exact match the instruction id is returned, otherwise
//! `kInvalidInstId` (zero) is returned instead. The given `name` doesn't have
//! to be null-terminated if `nameSize` is provided.
ASMJIT_API uint32_t idByName(const char* name, size_t nameSize = Globals::kNullTerminated) noexcept;

//! Get an instruction name from a given instruction id `instId`.
ASMJIT_API const char* nameById(uint32_t instId) noexcept;
#endif

inline const InstInfo& infoById(uint32_t instId) noexcept {
  ASMJIT_ASSERT(Inst::isDefinedId(instId));
  return _instInfoTable[instId];
}

} // InstDB namespace

// ============================================================================
// [asmjit::x86::InstInternal]
// ============================================================================

#if defined(ASMJIT_EXPORTS)
//! \internal
//!
//! Implements API provided by `BaseInst` (X86).
namespace InstInternal {
  #ifndef ASMJIT_DISABLE_INST_API
  Error validate(uint32_t archId, const BaseInst& inst, const Operand_* operands, uint32_t count) noexcept;
  Error queryRWInfo(uint32_t archId, const BaseInst& inst, const Operand_* operands, uint32_t count, InstRWInfo& out) noexcept;
  Error queryFeatures(uint32_t archId, const BaseInst& inst, const Operand_* operands, uint32_t count, BaseFeatures& out) noexcept;
  #endif
};
#endif

//! \}

ASMJIT_END_SUB_NAMESPACE

// [Guard]
#endif // _ASMJIT_X86_X86INSTDB_H

```

`Avanguard/AsmJit/asmjit/x86/x86internal_p.h`:

```h
// [AsmJit]
// Complete x86/x64 JIT and Remote Assembler for C++.
//
// [License]
// ZLIB - See LICENSE.md file in the package.

// [Guard]
#ifndef _ASMJIT_X86_X86INTERNAL_P_H
#define _ASMJIT_X86_X86INTERNAL_P_H

#include "../core/build.h"

// [Dependencies]
#include "../core/func.h"
#include "../x86/x86emitter.h"
#include "../x86/x86operand.h"

ASMJIT_BEGIN_SUB_NAMESPACE(x86)

//! \addtogroup asmjit_x86_api
//! \{

// ============================================================================
// [asmjit::X86Internal]
// ============================================================================

//! \internal
//!
//! X86 utilities used at multiple places, not part of public API, not exported.
struct X86Internal {
  //! Initialize `FuncDetail` (X86 specific).
  static Error initFuncDetail(FuncDetail& func, const FuncSignature& sign, uint32_t gpSize) noexcept;

  //! Initialize `FuncFrame` (X86 specific).
  static Error initFuncFrame(FuncFrame& frame, const FuncDetail& func) noexcept;

  //! Finalize `FuncFrame` (X86 specific).
  static Error finalizeFuncFrame(FuncFrame& frame) noexcept;

  static Error argsToFuncFrame(const FuncArgsAssignment& args, FuncFrame& frame) noexcept;

  //! Emit function prolog.
  static Error emitProlog(Emitter* emitter, const FuncFrame& frame);

  //! Emit function epilog.
  static Error emitEpilog(Emitter* emitter, const FuncFrame& frame);

  //! Emit a pure move operation between two registers or the same type or
  //! between a register and its home slot. This function does not handle
  //! register conversion.
  static Error emitRegMove(Emitter* emitter,
    const Operand_& dst_,
    const Operand_& src_, uint32_t typeId, bool avxEnabled, const char* comment = nullptr);

  //! Emit move from a function argument (either register or stack) to a register.
  //!
  //! This function can handle the necessary conversion from one argument to
  //! another, and from one register type to another, if it's possible. Any
  //! attempt of conversion that requires third register of a different group
  //! (for example conversion from K to MMX) will fail.
  static Error emitArgMove(Emitter* emitter,
    const Reg& dst_, uint32_t dstTypeId,
    const Operand_& src_, uint32_t srcTypeId, bool avxEnabled, const char* comment = nullptr);

  static Error emitArgsAssignment(Emitter* emitter, const FuncFrame& frame, const FuncArgsAssignment& args);
};

//! \}

ASMJIT_END_SUB_NAMESPACE

// [Guard]
#endif // _ASMJIT_X86_X86INTERNAL_P_H

```

`Avanguard/AsmJit/asmjit/x86/x86logging_p.h`:

```h
// [AsmJit]
// Complete x86/x64 JIT and Remote Assembler for C++.
//
// [License]
// ZLIB - See LICENSE.md file in the package.

// [Guard]
#ifndef _ASMJIT_X86_X86LOGGING_P_H
#define _ASMJIT_X86_X86LOGGING_P_H

#include "../core/build.h"
#ifndef ASMJIT_DISABLE_LOGGING

// [Dependencies]
#include "../core/logging.h"
#include "../core/stringbuilder.h"
#include "../x86/x86globals.h"

ASMJIT_BEGIN_SUB_NAMESPACE(x86)

//! \addtogroup asmjit_x86_api
//! \{

// ============================================================================
// [asmjit::x86::LoggingInternal]
// ============================================================================

namespace LoggingInternal {
  Error formatRegister(
    StringBuilder& sb,
    uint32_t flags,
    const BaseEmitter* emitter,
    uint32_t archId,
    uint32_t regType,
    uint32_t regId) noexcept;

  Error formatOperand(
    StringBuilder& sb,
    uint32_t flags,
    const BaseEmitter* emitter,
    uint32_t archId,
    const Operand_& op) noexcept;

  Error formatInstruction(
    StringBuilder& sb,
    uint32_t flags,
    const BaseEmitter* emitter,
    uint32_t archId,
    const BaseInst& inst, const Operand_* operands, uint32_t count) noexcept;
};

//! \}

ASMJIT_END_SUB_NAMESPACE

// [Guard]
#endif // !ASMJIT_DISABLE_LOGGING
#endif // _ASMJIT_X86_X86LOGGING_P_H

```

`Avanguard/AsmJit/asmjit/x86/x86opcode_p.h`:

```h
// [AsmJit]
// Complete x86/x64 JIT and Remote Assembler for C++.
//
// [License]
// ZLIB - See LICENSE.md file in the package.

// [Guard]
#ifndef _ASMJIT_X86_X86OPCODE_P_H
#define _ASMJIT_X86_X86OPCODE_P_H

// [Dependencies]
#include "../core/logging.h"
#include "../core/stringbuilder.h"
#include "../x86/x86globals.h"

ASMJIT_BEGIN_SUB_NAMESPACE(x86)

//! \addtogroup asmjit_x86_api
//! \{

// ============================================================================
// [asmjit::x86::Opcode]
// ============================================================================

//! \internal
//!
//! Helper class to store and manipulate X86 opcodes.
//!
//! The first 8 least significant bits describe the opcode byte as defined in
//! ISA manuals, all other bits describe other properties like prefixes, see
//! `Opcode::Bits` for more information.
struct Opcode {
  //! Describes a meaning of all bits of AsmJit's 32-bit opcode value.
  //!
  //! This schema is AsmJit specific and has been designed to allow encoding of
  //! all X86 instructions available. X86, MMX, and SSE+ instructions always use
  //! `MM` and `PP` fields, which are encoded to corresponding prefixes needed
  //! by X86 or SIMD instructions. AVX+ instructions embed `MMMMM` and `PP` fields
  //! in a VEX prefix, and AVX-512 instructions embed `MM` and `PP` in EVEX prefix.
  //!
  //! The instruction opcode definition uses 1 or 2 bytes as an opcode value. 1
  //! byte is needed by most of the instructions, 2 bytes are only used by legacy
  //! X87-FPU instructions. This means that a second byte is free to by used by
  //! instructions encoded by using VEX and/or EVEX prefix.
  //!
  //! The fields description:
  //!
  //! - `MM` field is used to encode prefixes needed by the instruction or as
  //!   a part of VEX/EVEX prefix. Described as `mm` and `mmmmm` in instruction
  //!   manuals.
  //!
  //!   NOTE: Since `MM` field is defined as `mmmmm` (5 bits), but only 2 least
  //!   significant bits are used by VEX and EVEX prefixes, and additional 4th
  //!   bit is used by XOP prefix, AsmJit uses the 3rd and 5th bit for it's own
  //!   purposes. These bits will probably never be used in future encodings as
  //!   AVX512 uses only `000mm` from `mmmmm`.
  //!
  //! - `PP` field is used to encode prefixes needed by the instruction or as a
  //!   part of VEX/EVEX prefix. Described as `pp` in instruction manuals.
  //!
  //! - `LL` field is used exclusively by AVX+ and AVX512+ instruction sets. It
  //!   describes vector size, which is `L.128` for XMM register, `L.256` for
  //!   for YMM register, and `L.512` for ZMM register. The `LL` field is omitted
  //!   in case that instruction supports multiple vector lengths, however, if the
  //!   instruction requires specific `L` value it must be specified as a part of
  //!   the opcode.
  //!
  //!   NOTE: `LL` having value `11` is not defined yet.
  //!
  //! - `W` field is the most complicated. It was added by 64-bit architecture
  //!   to promote default operation width (instructions that perform 32-bit
  //!   operation by default require to override the width to 64-bit explicitly).
  //!   There is nothing wrong on this, however, some instructions introduced
  //!   implicit `W` override, for example a `cdqe` instruction is basically a
  //!   `cwde` instruction with overridden `W` (set to 1). There are some others
  //!   in the base X86 instruction set. More recent instruction sets started
  //!   using `W` field more often:
  //!
  //!   - AVX instructions started using `W` field as an extended opcode for FMA,
  //!     GATHER, PERM, and other instructions. It also uses `W` field to override
  //!     the default operation width in instructions like `vmovq`.
  //!
  //!   - AVX-512 instructions started using `W` field as an extended opcode for
  //!     all new instructions. This wouldn't have been an issue if the `W` field
  //!     of AVX-512 have matched AVX, but this is not always the case.
  //!
  //! - `O` field is an extended opcode field (3 bits) embedded in ModR/M BYTE.
  //!
  //! - `CDSHL` and `CDTT` fields describe 'compressed-displacement'. `CDSHL` is
  //!   defined for each instruction that is AVX-512 encodable (EVEX) and contains
  //!   a base N shift (base shift to perform the calculation). The `CDTT` field
  //!   is derived from instruction specification and describes additional shift
  //!   to calculate the final `CDSHL` that will be used in SIB byte.
  //!
  //! NOTE: Don't reorder any fields here, the shifts and masks were defined
  //! carefully to make encoding of X86 instructions fast, especially to construct
  //! REX, VEX, and EVEX prefixes in the most efficient way. Changing values defined
  //! by these enums many cause AsmJit to emit invalid binary representations of
  //! instructions passed to `x86::Assembler::_emit`.
  enum Bits : uint32_t {
    // MM & VEX & EVEX & XOP
    // ---------------------
    //
    // Two meanings:
    //  * Part of a legacy opcode (prefixes emitted before the main opcode byte).
    //  * `MMMMM` field in VEX|EVEX|XOP instruction.
    //
    // AVX reserves 5 bits for `MMMMM` field, however AVX instructions only use
    // 2 bits and XOP 3 bits. AVX-512 shrinks `MMMMM` field into `MM` so it's
    // safe to assume that bits [4:2] of `MM` field won't be used in future
    // extensions, which will most probably use EVEX encoding. AsmJit divides
    // MM field into this layout:
    //
    // [1:0] - Used to describe 0F, 0F38 and 0F3A legacy prefix bytes and
    //         2 bits of MM field.
    // [2]   - Used to force 3-BYTE VEX prefix, but then cleared to zero before
    //         the prefix is emitted. This bit is not used by any instruction
    //         so it can be used for any purpose by AsmJit. Also, this bit is
    //         used as an extension to `MM` field describing 0F|0F38|0F3A to also
    //         describe 0F01 as used by some legacy instructions (instructions
    //         not using VEX/EVEX prefix).
    // [3]   - Required by XOP instructions, so we use this bit also to indicate
    //         that this is a XOP opcode.
    kMM_Shift      = 8,
    kMM_Mask       = 0x1Fu << kMM_Shift,
    kMM_00         = 0x00u << kMM_Shift,
    kMM_0F         = 0x01u << kMM_Shift,
    kMM_0F38       = 0x02u << kMM_Shift,
    kMM_0F3A       = 0x03u << kMM_Shift,   // Described also as XOP.M3 in AMD manuals.
    kMM_0F01       = 0x04u << kMM_Shift,   // AsmJit way to describe 0F01 (never VEX/EVEX).

    // `XOP` field is only used to force XOP prefix instead of VEX3 prefix. We
    // know that only XOP encoding uses bit 0b1000 of MM field and that no VEX
    // and EVEX instruction uses such bit, so we can use this bit to force XOP
    // prefix to be emitted instead of VEX3 prefix. See `x86VEXPrefix` defined
    // in `x86assembler.cpp`.
    kMM_XOP08      = 0x08u << kMM_Shift,   // XOP.M8.
    kMM_XOP09      = 0x09u << kMM_Shift,   // XOP.M9.

    kMM_IsXOP_Shift= kMM_Shift + 3,
    kMM_IsXOP      = kMM_XOP08,

    // NOTE: Force VEX3 allows to force to emit VEX3 instead of VEX2 in some
    // cases (similar to forcing REX prefix). Force EVEX will force emitting
    // EVEX prefix instead of VEX2|VEX3. EVEX-only instructions will have
    // ForceEvex always set, however. instructions that can be encoded by
    // either VEX or EVEX prefix shall not have ForceEvex set.

    kMM_ForceVex3  = 0x04u << kMM_Shift,   // Force 3-BYTE VEX prefix.
    kMM_ForceEvex  = 0x10u << kMM_Shift,   // Force 4-BYTE EVEX prefix.

    // FPU_2B - Second-Byte of the Opcode used by FPU
    // ----------------------------------------------
    //
    // Second byte opcode. This BYTE is ONLY used by FPU instructions and
    // collides with 3 bits from `MM` and 5 bits from 'CDSHL' and 'CDTT'.
    // It's fine as FPU and AVX512 flags are never used at the same time.
    kFPU_2B_Shift  = 10,
    kFPU_2B_Mask   = 0xFF << kFPU_2B_Shift,

    // CDSHL & CDTT
    // ------------
    //
    // Compressed displacement bits.
    //
    // Each opcode defines the base size (N) shift:
    //   [0]: BYTE  (1 byte).
    //   [1]: WORD  (2 bytes).
    //   [2]: DWORD (4 bytes - float/int32).
    //   [3]: QWORD (8 bytes - double/int64).
    //   [4]: OWORD (16 bytes - used by FV|FVM|M128).
    //
    // Which is then scaled by the instruction's TT (TupleType) into possible:
    //   [5]: YWORD (32 bytes)
    //   [6]: ZWORD (64 bytes)
    //
    // These bits are then adjusted before calling EmitModSib or EmitModVSib.
    kCDSHL_Shift   = 13,
    kCDSHL_Mask    = 0x7u << kCDSHL_Shift,

    kCDSHL__       = 0x0u << kCDSHL_Shift, // Base element size not used.
    kCDSHL_0       = 0x0u << kCDSHL_Shift, // N << 0.
    kCDSHL_1       = 0x1u << kCDSHL_Shift, // N << 1.
    kCDSHL_2       = 0x2u << kCDSHL_Shift, // N << 2.
    kCDSHL_3       = 0x3u << kCDSHL_Shift, // N << 3.
    kCDSHL_4       = 0x4u << kCDSHL_Shift, // N << 4.
    kCDSHL_5       = 0x5u << kCDSHL_Shift, // N << 5.

    // Compressed displacement tuple-type (specific to AsmJit).
    //
    // Since we store the base offset independently of CDTT we can simplify the
    // number of 'TUPLE_TYPE' groups significantly and just handle special cases.
    kCDTT_Shift    = 16,
    kCDTT_Mask     = 0x3u << kCDTT_Shift,
    kCDTT_None     = 0x0u << kCDTT_Shift,  // Does nothing.
    kCDTT_ByLL     = 0x1u << kCDTT_Shift,  // Scales by LL (1x 2x 4x).
    kCDTT_T1W      = 0x2u << kCDTT_Shift,  // Used to add 'W' to the shift.
    kCDTT_DUP      = 0x3u << kCDTT_Shift,  // Special 'VMOVDDUP' case.

    // Aliases that match names used in instruction manuals.
    kCDTT__        = kCDTT_None,
    kCDTT_FV       = kCDTT_ByLL,
    kCDTT_HV       = kCDTT_ByLL,
    kCDTT_FVM      = kCDTT_ByLL,
    kCDTT_T1S      = kCDTT_None,
    kCDTT_T1F      = kCDTT_None,
    kCDTT_T1_4X    = kCDTT_None,
    kCDTT_T2       = kCDTT_None,
    kCDTT_T4       = kCDTT_None,
    kCDTT_T8       = kCDTT_None,
    kCDTT_HVM      = kCDTT_ByLL,
    kCDTT_QVM      = kCDTT_ByLL,
    kCDTT_OVM      = kCDTT_ByLL,
    kCDTT_128      = kCDTT_None,

    kCDTT_T4X      = kCDTT_T1_4X,          // Alias to have only 3 letters.

    // `O` Field in MorR/M
    // -------------------

    kO_Shift       = 18,
    kO_Mask        = 0x7u << kO_Shift,

    kO__           = 0x0u,
    kO_0           = 0x0u << kO_Shift,
    kO_1           = 0x1u << kO_Shift,
    kO_2           = 0x2u << kO_Shift,
    kO_3           = 0x3u << kO_Shift,
    kO_4           = 0x4u << kO_Shift,
    kO_5           = 0x5u << kO_Shift,
    kO_6           = 0x6u << kO_Shift,
    kO_7           = 0x7u << kO_Shift,

    // `PP` Field
    // ----------
    //
    // These fields are stored deliberately right after each other as it makes
    // it easier to construct VEX prefix from the opcode value stored in the
    // instruction database.
    //
    // Two meanings:
    //   * "PP" field in AVX/XOP/AVX-512 instruction.
    //   * Mandatory Prefix in legacy encoding.
    //
    // AVX reserves 2 bits for `PP` field, but AsmJit extends the storage by 1
    // more bit that is used to emit 9B prefix for some X87-FPU instructions.

    kPP_Shift      = 21,
    kPP_VEXMask    = 0x03u << kPP_Shift,   // PP field mask used by VEX/EVEX.
    kPP_FPUMask    = 0x07u << kPP_Shift,   // Mask used by EMIT_PP, also includes '0x9B'.
    kPP_00         = 0x00u << kPP_Shift,
    kPP_66         = 0x01u << kPP_Shift,
    kPP_F3         = 0x02u << kPP_Shift,
    kPP_F2         = 0x03u << kPP_Shift,

    kPP_9B         = 0x07u << kPP_Shift,   // AsmJit specific to emit FPU's '9B' byte.

    // REX|VEX|EVEX B|X|R|W Bits
    // -------------------------
    //
    // NOTE: REX.[B|X|R] are never stored within the opcode itself, they are
    // reserved by AsmJit are are added dynamically to the opcode to represent
    // [REX|VEX|EVEX].[B|X|R] bits. REX.W can be stored in DB as it's sometimes
    // part of the opcode itself.

    // These must be binary compatible with instruction options.
    kREX_Shift     = 24,
    kREX_Mask      = 0x0Fu << kREX_Shift,
    kB             = 0x01u << kREX_Shift,  // Never stored in DB, used by encoder.
    kX             = 0x02u << kREX_Shift,  // Never stored in DB, used by encoder.
    kR             = 0x04u << kREX_Shift,  // Never stored in DB, used by encoder.
    kW             = 0x08u << kREX_Shift,
    kW_Shift       = kREX_Shift + 3,

    kW__           = 0u << kW_Shift,       // REX.W/VEX.W is unspecified.
    kW_x           = 0u << kW_Shift,       // REX.W/VEX.W is based on instruction operands.
    kW_I           = 0u << kW_Shift,       // REX.W/VEX.W is ignored (WIG).
    kW_0           = 0u << kW_Shift,       // REX.W/VEX.W is 0 (W0).
    kW_1           = 1u << kW_Shift,       // REX.W/VEX.W is 1 (W1).

    // EVEX.W Field
    // ------------
    //
    // `W` field used by EVEX instruction encoding.

    kEvex_W_Shift  = 28,
    kEvex_W_Mask   = 1u << kEvex_W_Shift,

    kEvex_W__      = 0u << kEvex_W_Shift,  // EVEX.W is unspecified (not EVEX instruction).
    kEvex_W_x      = 0u << kEvex_W_Shift,  // EVEX.W is based on instruction operands.
    kEvex_W_I      = 0u << kEvex_W_Shift,  // EVEX.W is ignored (WIG).
    kEvex_W_0      = 0u << kEvex_W_Shift,  // EVEX.W is 0 (W0).
    kEvex_W_1      = 1u << kEvex_W_Shift,  // EVEX.W is 1 (W1).

    // `L` or `LL` field in AVX/XOP/AVX-512
    // ------------------------------------
    //
    // VEX/XOP prefix can only use the first bit `L.128` or `L.256`. EVEX prefix
    // prefix makes it possible to use also `L.512`.
    //
    // If the instruction set manual describes an instruction by `LIG` it means
    // that the `L` field is ignored and AsmJit defaults to `0` in such case.
    kLL_Shift      = 29,
    kLL_Mask       = 0x3u << kLL_Shift,

    kLL__          = 0x0u << kLL_Shift,    // LL is unspecified.
    kLL_x          = 0x0u << kLL_Shift,    // LL is based on instruction operands.
    kLL_I          = 0x0u << kLL_Shift,    // LL is ignored (LIG).
    kLL_0          = 0x0u << kLL_Shift,    // LL is 0 (L.128).
    kLL_1          = 0x1u << kLL_Shift,    // LL is 1 (L.256).
    kLL_2          = 0x2u << kLL_Shift,    // LL is 2 (L.512).

    // Opcode Combinations
    // -------------------

    k0      = 0,                           // '__' (no prefix, used internally).
    k000000 = kPP_00 | kMM_00,             // '__' (no prefix, to be the same width as others).
    k000F00 = kPP_00 | kMM_0F,             // '0F'
    k000F01 = kPP_00 | kMM_0F01,           // '0F01'
    k000F0F = kPP_00 | kMM_0F,             // '0F0F' - 3DNOW, equal to 0x0F, must have special encoding to take effect.
    k000F38 = kPP_00 | kMM_0F38,           // '0F38'
    k000F3A = kPP_00 | kMM_0F3A,           // '0F3A'
    k660000 = kPP_66 | kMM_00,             // '66'
    k660F00 = kPP_66 | kMM_0F,             // '660F'
    k660F38 = kPP_66 | kMM_0F38,           // '660F38'
    k660F3A = kPP_66 | kMM_0F3A,           // '660F3A'
    kF20000 = kPP_F2 | kMM_00,             // 'F2'
    kF20F00 = kPP_F2 | kMM_0F,             // 'F20F'
    kF20F38 = kPP_F2 | kMM_0F38,           // 'F20F38'
    kF20F3A = kPP_F2 | kMM_0F3A,           // 'F20F3A'
    kF30000 = kPP_F3 | kMM_00,             // 'F3'
    kF30F00 = kPP_F3 | kMM_0F,             // 'F30F'
    kF30F38 = kPP_F3 | kMM_0F38,           // 'F30F38'
    kF30F3A = kPP_F3 | kMM_0F3A,           // 'F30F3A'
    kFPU_00 = kPP_00 | kMM_00,             // '__' (FPU)
    kFPU_9B = kPP_9B | kMM_00,             // '9B' (FPU)
    kXOP_M8 = kPP_00 | kMM_XOP08,          // 'M8' (XOP)
    kXOP_M9 = kPP_00 | kMM_XOP09           // 'M9' (XOP)
  };

  // --------------------------------------------------------------------------
  // [Opcode Builder]
  // --------------------------------------------------------------------------

  inline uint32_t get() const noexcept { return v; }
  inline Opcode& add(uint32_t x) noexcept { return operator+=(x); }

  inline Opcode& add66h() noexcept { return operator|=(kPP_66); }
  template<typename T>
  inline Opcode& add66hIf(T exp) noexcept { return operator|=(uint32_t(exp) << kPP_Shift); }
  template<typename T>
  inline Opcode& add66hBySize(T size) noexcept { return add66hIf(size == 2); }

  inline Opcode& addW() noexcept { return operator|=(kW); }
  template<typename T>
  inline Opcode& addWIf(T exp) noexcept { return operator|=(uint32_t(exp) << kW_Shift); }
  template<typename T>
  inline Opcode& addWBySize(T size) noexcept { return addWIf(size == 8); }

  template<typename T>
  ASMJIT_INLINE Opcode& addPrefixBySize(T size) noexcept {
    static const uint32_t mask[16] = {
      0,          // #0
      0,          // #1 -> nothing (already handled or not possible)
      kPP_66,     // #2 -> 66H
      0,          // #3
      0,          // #4 -> nothing
      0,          // #5
      0,          // #6
      0,          // #7
      kW          // #8 -> REX.W
    };
    return operator|=(mask[size & 0xF]);
  }

  template<typename T>
  ASMJIT_INLINE Opcode& addArithBySize(T size) noexcept {
    static const uint32_t mask[16] = {
      0,          // #0
      0,          // #1 -> nothing
      1 | kPP_66, // #2 -> NOT_BYTE_OP(1) and 66H
      0,          // #3
      1,          // #4 -> NOT_BYTE_OP(1)
      0,          // #5
      0,          // #6
      0,          // #7
      1 | kW      // #8 -> NOT_BYTE_OP(1) and REX.W
    };
    return operator|=(mask[size & 0xF]);
  }

  //! Extract `O` field from the opcode.
  ASMJIT_INLINE uint32_t extractO() const noexcept {
    return (v >> kO_Shift) & 0x07;
  }

  //! Extract `REX` prefix from opcode combined with `options`.
  ASMJIT_INLINE uint32_t extractRex(uint32_t options) const noexcept {
    // kREX was designed in a way that when shifted there will be no bytes
    // set except REX.[B|X|R|W]. The returned value forms a real REX prefix byte.
    // This case should be unit-tested as well.
    return (v | options) >> kREX_Shift;
  }

  ASMJIT_INLINE uint32_t extractLLMM(uint32_t options) const noexcept {
    uint32_t x = v       & (kLL_Mask | kMM_Mask);
    uint32_t y = options & (Inst::kOptionVex3 | Inst::kOptionEvex);
    return (x | y) >> kMM_Shift;
  }

  inline Opcode& operator =(uint32_t x) noexcept { v  = x; return *this; }
  inline Opcode& operator+=(uint32_t x) noexcept { v += x; return *this; }
  inline Opcode& operator-=(uint32_t x) noexcept { v -= x; return *this; }
  inline Opcode& operator&=(uint32_t x) noexcept { v &= x; return *this; }
  inline Opcode& operator|=(uint32_t x) noexcept { v |= x; return *this; }
  inline Opcode& operator^=(uint32_t x) noexcept { v ^= x; return *this; }

  inline uint32_t operator&(uint32_t x) const noexcept { return v & x; }
  inline uint32_t operator|(uint32_t x) const noexcept { return v | x; }
  inline uint32_t operator^(uint32_t x) const noexcept { return v ^ x; }
  inline uint32_t operator<<(uint32_t x) const noexcept { return v << x; }
  inline uint32_t operator>>(uint32_t x) const noexcept { return v >> x; }

  // --------------------------------------------------------------------------
  // [Members]
  // --------------------------------------------------------------------------

  uint32_t v;
};

//! \}

ASMJIT_END_SUB_NAMESPACE

// [Guard]
#endif // _ASMJIT_X86_X86OPCODE_P_H

```

`Avanguard/AsmJit/asmjit/x86/x86operand.h`:

```h
// [AsmJit]
// Complete x86/x64 JIT and Remote Assembler for C++.
//
// [License]
// ZLIB - See LICENSE.md file in the package.

// [Guard]
#ifndef _ASMJIT_X86_OPERAND_H
#define _ASMJIT_X86_OPERAND_H

// [Dependencies]
#include "../core/arch.h"
#include "../core/operand.h"
#include "../core/type.h"
#include "../x86/x86globals.h"

ASMJIT_BEGIN_SUB_NAMESPACE(x86)

// ============================================================================
// [Forward Declarations]
// ============================================================================

class Reg;
class Mem;

class Gp;
class Gpb;
class GpbLo;
class GpbHi;
class Gpw;
class Gpd;
class Gpq;
class Vec;
class Xmm;
class Ymm;
class Zmm;
class Mm;
class KReg;
class SReg;
class CReg;
class DReg;
class St;
class Bnd;
class Rip;

//! \addtogroup asmjit_x86_api
//! \{

// ============================================================================
// [asmjit::x86::RegTraits]
// ============================================================================

//! Register traits (X86).
//!
//! Register traits contains information about a particular register type. It's
//! used by asmjit to setup register information on-the-fly and to populate
//! tables that contain register information (this way it's possible to change
//! register types and groups without having to reorder these tables).
template<uint32_t REG_TYPE>
struct RegTraits : public BaseRegTraits {};

// <--------------------+-----+-------------------------+------------------------+---+---+----------------+
//                      | Reg |        Reg-Type         |        Reg-Group       |Sz |Cnt|     TypeId     |
// <--------------------+-----+-------------------------+------------------------+---+---+----------------+
ASMJIT_DEFINE_REG_TRAITS(GpbLo, BaseReg::kTypeGp8Lo     , BaseReg::kGroupGp      , 1 , 16, Type::kIdI8    );
ASMJIT_DEFINE_REG_TRAITS(GpbHi, BaseReg::kTypeGp8Hi     , BaseReg::kGroupGp      , 1 , 4 , Type::kIdI8    );
ASMJIT_DEFINE_REG_TRAITS(Gpw  , BaseReg::kTypeGp16      , BaseReg::kGroupGp      , 2 , 16, Type::kIdI16   );
ASMJIT_DEFINE_REG_TRAITS(Gpd  , BaseReg::kTypeGp32      , BaseReg::kGroupGp      , 4 , 16, Type::kIdI32   );
ASMJIT_DEFINE_REG_TRAITS(Gpq  , BaseReg::kTypeGp64      , BaseReg::kGroupGp      , 8 , 16, Type::kIdI64   );
ASMJIT_DEFINE_REG_TRAITS(Xmm  , BaseReg::kTypeVec128    , BaseReg::kGroupVec     , 16, 32, Type::kIdI32x4 );
ASMJIT_DEFINE_REG_TRAITS(Ymm  , BaseReg::kTypeVec256    , BaseReg::kGroupVec     , 32, 32, Type::kIdI32x8 );
ASMJIT_DEFINE_REG_TRAITS(Zmm  , BaseReg::kTypeVec512    , BaseReg::kGroupVec     , 64, 32, Type::kIdI32x16);
ASMJIT_DEFINE_REG_TRAITS(Mm   , BaseReg::kTypeOther0    , BaseReg::kGroupOther0  , 8 , 8 , Type::kIdMmx64 );
ASMJIT_DEFINE_REG_TRAITS(KReg , BaseReg::kTypeOther1    , BaseReg::kGroupOther1  , 0 , 8 , Type::kIdVoid  );
ASMJIT_DEFINE_REG_TRAITS(SReg , BaseReg::kTypeCustom + 0, BaseReg::kGroupVirt + 0, 2 , 7 , Type::kIdVoid  );
ASMJIT_DEFINE_REG_TRAITS(CReg , BaseReg::kTypeCustom + 1, BaseReg::kGroupVirt + 1, 0 , 16, Type::kIdVoid  );
ASMJIT_DEFINE_REG_TRAITS(DReg , BaseReg::kTypeCustom + 2, BaseReg::kGroupVirt + 2, 0 , 16, Type::kIdVoid  );
ASMJIT_DEFINE_REG_TRAITS(St   , BaseReg::kTypeCustom + 3, BaseReg::kGroupVirt + 3, 10, 8 , Type::kIdF80   );
ASMJIT_DEFINE_REG_TRAITS(Bnd  , BaseReg::kTypeCustom + 4, BaseReg::kGroupVirt + 4, 16, 4 , Type::kIdVoid  );
ASMJIT_DEFINE_REG_TRAITS(Rip  , BaseReg::kTypeIP        , BaseReg::kGroupVirt + 5, 0 , 1 , Type::kIdVoid  );

// ============================================================================
// [asmjit::x86::Reg]
// ============================================================================

//! Register (X86).
class Reg : public BaseReg {
public:
  ASMJIT_DEFINE_ABSTRACT_REG(Reg, BaseReg)

  //! Register type.
  enum RegType : uint32_t {
    kTypeNone  = BaseReg::kTypeNone,     //!< No register type or invalid register.
    kTypeGpbLo = BaseReg::kTypeGp8Lo,    //!< Low GPB register (AL, BL, CL, DL, ...).
    kTypeGpbHi = BaseReg::kTypeGp8Hi,    //!< High GPB register (AH, BH, CH, DH only).
    kTypeGpw   = BaseReg::kTypeGp16,     //!< GPW register.
    kTypeGpd   = BaseReg::kTypeGp32,     //!< GPD register.
    kTypeGpq   = BaseReg::kTypeGp64,     //!< GPQ register (64-bit).
    kTypeXmm   = BaseReg::kTypeVec128,   //!< XMM register (SSE+).
    kTypeYmm   = BaseReg::kTypeVec256,   //!< YMM register (AVX+).
    kTypeZmm   = BaseReg::kTypeVec512,   //!< ZMM register (AVX512+).
    kTypeMm    = BaseReg::kTypeOther0,   //!< MMX register.
    kTypeKReg  = BaseReg::kTypeOther1,   //!< K register (AVX512+).
    kTypeSReg  = BaseReg::kTypeCustom+0, //!< Segment register (None, ES, CS, SS, DS, FS, GS).
    kTypeCReg  = BaseReg::kTypeCustom+1, //!< Control register (CR).
    kTypeDReg  = BaseReg::kTypeCustom+2, //!< Debug register (DR).
    kTypeSt    = BaseReg::kTypeCustom+3, //!< FPU (x87) register.
    kTypeBnd   = BaseReg::kTypeCustom+4, //!< Bound register (BND).
    kTypeRip   = BaseReg::kTypeIP,       //!< Instruction pointer (EIP, RIP).
    kTypeCount = BaseReg::kTypeCustom+5  //!< Count of register types.
  };

  //! Register group.
  enum RegGroup : uint32_t {
    kGroupGp   = BaseReg::kGroupGp,      //!< GP register group or none (universal).
    kGroupVec  = BaseReg::kGroupVec,     //!< XMM|YMM|ZMM register group (universal).
    kGroupMm   = BaseReg::kGroupOther0,  //!< MMX register group (legacy).
    kGroupKReg = BaseReg::kGroupOther1,  //!< K register group.

    // These are not managed by BaseCompiler nor used by Func-API:
    kGroupSReg = BaseReg::kGroupVirt+0,  //!< Segment register group.
    kGroupCReg = BaseReg::kGroupVirt+1,  //!< Control register group.
    kGroupDReg = BaseReg::kGroupVirt+2,  //!< Debug register group.
    kGroupSt   = BaseReg::kGroupVirt+3,  //!< FPU register group.
    kGroupBnd  = BaseReg::kGroupVirt+4,  //!< Bound register group.
    kGroupRip  = BaseReg::kGroupVirt+5,  //!< Instrucion pointer (IP).
    kGroupCount                          //!< Count of all register groups.
  };

  //! Get whether the register is a GPB register (8-bit).
  constexpr bool isGpb() const noexcept { return size() == 1; }
  //! Get whether the register is a low GPB register (8-bit).
  constexpr bool isGpbLo() const noexcept { return hasSignature(RegTraits<kTypeGpbLo>::kSignature); }
  //! Get whether the register is a high GPB register (8-bit).
  constexpr bool isGpbHi() const noexcept { return hasSignature(RegTraits<kTypeGpbHi>::kSignature); }
  //! Get whether the register is a GPW register (16-bit).
  constexpr bool isGpw() const noexcept { return hasSignature(RegTraits<kTypeGpw>::kSignature); }
  //! Get whether the register is a GPD register (32-bit).
  constexpr bool isGpd() const noexcept { return hasSignature(RegTraits<kTypeGpd>::kSignature); }
  //! Get whether the register is a GPQ register (64-bit).
  constexpr bool isGpq() const noexcept { return hasSignature(RegTraits<kTypeGpq>::kSignature); }
  //! Get whether the register is an XMM register (128-bit).
  constexpr bool isXmm() const noexcept { return hasSignature(RegTraits<kTypeXmm>::kSignature); }
  //! Get whether the register is a YMM register (256-bit).
  constexpr bool isYmm() const noexcept { return hasSignature(RegTraits<kTypeYmm>::kSignature); }
  //! Get whether the register is a ZMM register (512-bit).
  constexpr bool isZmm() const noexcept { return hasSignature(RegTraits<kTypeZmm>::kSignature); }
  //! Get whether the register is an MMX register (64-bit).
  constexpr bool isMm() const noexcept { return hasSignature(RegTraits<kTypeMm>::kSignature); }
  //! Get whether the register is a K register (64-bit).
  constexpr bool isKReg() const noexcept { return hasSignature(RegTraits<kTypeKReg>::kSignature); }
  //! Get whether the register is a segment register.
  constexpr bool isSReg() const noexcept { return hasSignature(RegTraits<kTypeSReg>::kSignature); }
  //! Get whether the register is a control register.
  constexpr bool isCReg() const noexcept { return hasSignature(RegTraits<kTypeCReg>::kSignature); }
  //! Get whether the register is a debug register.
  constexpr bool isDReg() const noexcept { return hasSignature(RegTraits<kTypeDReg>::kSignature); }
  //! Get whether the register is an FPU register (80-bit).
  constexpr bool isSt() const noexcept { return hasSignature(RegTraits<kTypeSt>::kSignature); }
  //! Get whether the register is a bound register.
  constexpr bool isBnd() const noexcept { return hasSignature(RegTraits<kTypeBnd>::kSignature); }
  //! Get whether the register is RIP.
  constexpr bool isRip() const noexcept { return hasSignature(RegTraits<kTypeRip>::kSignature); }

  template<uint32_t REG_TYPE>
  inline void setRegT(uint32_t rId) noexcept {
    setSignature(RegTraits<REG_TYPE>::kSignature);
    setId(rId);
  }

  inline void setTypeAndId(uint32_t rType, uint32_t rId) noexcept {
    ASMJIT_ASSERT(rType < kTypeCount);
    setSignature(signatureOf(rType));
    setId(rId);
  }

  static inline uint32_t groupOf(uint32_t rType) noexcept;
  template<uint32_t REG_TYPE>
  static inline uint32_t groupOfT() noexcept { return RegTraits<REG_TYPE>::kGroup; }

  static inline uint32_t typeIdOf(uint32_t rType) noexcept;
  template<uint32_t REG_TYPE>
  static inline uint32_t typeIdOfT() noexcept { return RegTraits<REG_TYPE>::kTypeId; }

  static inline uint32_t signatureOf(uint32_t rType) noexcept;
  template<uint32_t REG_TYPE>
  static inline uint32_t signatureOfT() noexcept { return RegTraits<REG_TYPE>::kSignature; }

  static inline uint32_t signatureOfVecByType(uint32_t typeId) noexcept {
    return typeId <= Type::_kIdVec128End ? RegTraits<kTypeXmm>::kSignature :
           typeId <= Type::_kIdVec256End ? RegTraits<kTypeYmm>::kSignature : RegTraits<kTypeZmm>::kSignature;
  }

  static inline uint32_t signatureOfVecBySize(uint32_t size) noexcept {
    return size <= 16 ? RegTraits<kTypeXmm>::kSignature :
           size <= 32 ? RegTraits<kTypeYmm>::kSignature : RegTraits<kTypeZmm>::kSignature;
  }

  //! Get whether the `op` operand is either a low or high 8-bit GPB register.
  static inline bool isGpb(const Operand_& op) noexcept {
    // Check operand type, register group, and size. Not interested in register type.
    const uint32_t kSgn = (Operand::kOpReg << kSignatureOpShift  ) |
                          (1               << kSignatureSizeShift) ;
    return (op.signature() & (kSignatureOpMask | kSignatureSizeMask)) == kSgn;
  }

  static inline bool isGpbLo(const Operand_& op) noexcept { return op.as<Reg>().isGpbLo(); }
  static inline bool isGpbHi(const Operand_& op) noexcept { return op.as<Reg>().isGpbHi(); }
  static inline bool isGpw(const Operand_& op) noexcept { return op.as<Reg>().isGpw(); }
  static inline bool isGpd(const Operand_& op) noexcept { return op.as<Reg>().isGpd(); }
  static inline bool isGpq(const Operand_& op) noexcept { return op.as<Reg>().isGpq(); }
  static inline bool isXmm(const Operand_& op) noexcept { return op.as<Reg>().isXmm(); }
  static inline bool isYmm(const Operand_& op) noexcept { return op.as<Reg>().isYmm(); }
  static inline bool isZmm(const Operand_& op) noexcept { return op.as<Reg>().isZmm(); }
  static inline bool isMm(const Operand_& op) noexcept { return op.as<Reg>().isMm(); }
  static inline bool isKReg(const Operand_& op) noexcept { return op.as<Reg>().isKReg(); }
  static inline bool isSReg(const Operand_& op) noexcept { return op.as<Reg>().isSReg(); }
  static inline bool isCReg(const Operand_& op) noexcept { return op.as<Reg>().isCReg(); }
  static inline bool isDReg(const Operand_& op) noexcept { return op.as<Reg>().isDReg(); }
  static inline bool isSt(const Operand_& op) noexcept { return op.as<Reg>().isSt(); }
  static inline bool isBnd(const Operand_& op) noexcept { return op.as<Reg>().isBnd(); }
  static inline bool isRip(const Operand_& op) noexcept { return op.as<Reg>().isRip(); }

  static inline bool isGpb(const Operand_& op, uint32_t rId) noexcept { return isGpb(op) & (op.id() == rId); }
  static inline bool isGpbLo(const Operand_& op, uint32_t rId) noexcept { return isGpbLo(op) & (op.id() == rId); }
  static inline bool isGpbHi(const Operand_& op, uint32_t rId) noexcept { return isGpbHi(op) & (op.id() == rId); }
  static inline bool isGpw(const Operand_& op, uint32_t rId) noexcept { return isGpw(op) & (op.id() == rId); }
  static inline bool isGpd(const Operand_& op, uint32_t rId) noexcept { return isGpd(op) & (op.id() == rId); }
  static inline bool isGpq(const Operand_& op, uint32_t rId) noexcept { return isGpq(op) & (op.id() == rId); }
  static inline bool isXmm(const Operand_& op, uint32_t rId) noexcept { return isXmm(op) & (op.id() == rId); }
  static inline bool isYmm(const Operand_& op, uint32_t rId) noexcept { return isYmm(op) & (op.id() == rId); }
  static inline bool isZmm(const Operand_& op, uint32_t rId) noexcept { return isZmm(op) & (op.id() == rId); }
  static inline bool isMm(const Operand_& op, uint32_t rId) noexcept { return isMm(op) & (op.id() == rId); }
  static inline bool isKReg(const Operand_& op, uint32_t rId) noexcept { return isKReg(op) & (op.id() == rId); }
  static inline bool isSReg(const Operand_& op, uint32_t rId) noexcept { return isSReg(op) & (op.id() == rId); }
  static inline bool isCReg(const Operand_& op, uint32_t rId) noexcept { return isCReg(op) & (op.id() == rId); }
  static inline bool isDReg(const Operand_& op, uint32_t rId) noexcept { return isDReg(op) & (op.id() == rId); }
  static inline bool isSt(const Operand_& op, uint32_t rId) noexcept { return isSt(op) & (op.id() == rId); }
  static inline bool isBnd(const Operand_& op, uint32_t rId) noexcept { return isBnd(op) & (op.id() == rId); }
  static inline bool isRip(const Operand_& op, uint32_t rId) noexcept { return isRip(op) & (op.id() == rId); }
};

//! General purpose register (X86).
class Gp : public Reg {
public:
  ASMJIT_DEFINE_ABSTRACT_REG(Gp, Reg)

  //! Physical id (X86).
  //!
  //! NOTE: Register indexes have been reduced to only support general purpose
  //! registers. There is no need to have enumerations with number suffix that
  //! expands to the exactly same value as the suffix value itself.
  enum Id : uint32_t {
    kIdAx  = 0,  //!< Physical id of AL|AH|AX|EAX|RAX registers.
    kIdCx  = 1,  //!< Physical id of CL|CH|CX|ECX|RCX registers.
    kIdDx  = 2,  //!< Physical id of DL|DH|DX|EDX|RDX registers.
    kIdBx  = 3,  //!< Physical id of BL|BH|BX|EBX|RBX registers.
    kIdSp  = 4,  //!< Physical id of SPL|SP|ESP|RSP registers.
    kIdBp  = 5,  //!< Physical id of BPL|BP|EBP|RBP registers.
    kIdSi  = 6,  //!< Physical id of SIL|SI|ESI|RSI registers.
    kIdDi  = 7,  //!< Physical id of DIL|DI|EDI|RDI registers.
    kIdR8  = 8,  //!< Physical id of R8B|R8W|R8D|R8 registers (64-bit only).
    kIdR9  = 9,  //!< Physical id of R9B|R9W|R9D|R9 registers (64-bit only).
    kIdR10 = 10, //!< Physical id of R10B|R10W|R10D|R10 registers (64-bit only).
    kIdR11 = 11, //!< Physical id of R11B|R11W|R11D|R11 registers (64-bit only).
    kIdR12 = 12, //!< Physical id of R12B|R12W|R12D|R12 registers (64-bit only).
    kIdR13 = 13, //!< Physical id of R13B|R13W|R13D|R13 registers (64-bit only).
    kIdR14 = 14, //!< Physical id of R14B|R14W|R14D|R14 registers (64-bit only).
    kIdR15 = 15  //!< Physical id of R15B|R15W|R15D|R15 registers (64-bit only).
  };

  //! Cast this register to 8-bit (LO) part.
  constexpr GpbLo r8() const noexcept;
  //! Cast this register to 8-bit (LO) part.
  constexpr GpbLo r8Lo() const noexcept;
  //! Cast this register to 8-bit (HI) part.
  constexpr GpbHi r8Hi() const noexcept;
  //! Cast this register to 16-bit.
  constexpr Gpw r16() const noexcept;
  //! Cast this register to 32-bit.
  constexpr Gpd r32() const noexcept;
  //! Cast this register to 64-bit.
  constexpr Gpq r64() const noexcept;
};

//! Vector register (XMM|YMM|ZMM) (X86).
class Vec : public Reg {
  ASMJIT_DEFINE_ABSTRACT_REG(Vec, Reg)

  //! Cast this register to XMM (clone).
  constexpr Xmm xmm() const noexcept;
  //! Cast this register to YMM.
  constexpr Ymm ymm() const noexcept;
  //! Cast this register to ZMM.
  constexpr Zmm zmm() const noexcept;
};

//! Segment register (X86).
class SReg : public Reg {
  ASMJIT_DEFINE_FINAL_REG(SReg, Reg, RegTraits<kTypeSReg>)

  //! X86 segment id.
  enum Id : uint32_t {
    kIdNone = 0, //!< No segment (default).
    kIdEs   = 1, //!< ES segment.
    kIdCs   = 2, //!< CS segment.
    kIdSs   = 3, //!< SS segment.
    kIdDs   = 4, //!< DS segment.
    kIdFs   = 5, //!< FS segment.
    kIdGs   = 6, //!< GS segment.

    //! Count of  segment registers supported by AsmJit.
    //!
    //! NOTE: X86 architecture has 6 segment registers - ES, CS, SS, DS, FS, GS.
    //! X64 architecture lowers them down to just FS and GS. AsmJit supports 7
    //! segment registers - all addressable in both  and X64 modes and one
    //! extra called `SReg::kIdNone`, which is AsmJit specific and means that
    //! there is no segment register specified.
    kIdCount = 7
  };
};

//! GPB low or high register (X86).
class Gpb : public Gp { ASMJIT_DEFINE_ABSTRACT_REG(Gpb, Gp) };
//! GPB low register (X86).
class GpbLo : public Gpb { ASMJIT_DEFINE_FINAL_REG(GpbLo, Gpb, RegTraits<kTypeGpbLo>) };
//! GPB high register (X86).
class GpbHi : public Gpb { ASMJIT_DEFINE_FINAL_REG(GpbHi, Gpb, RegTraits<kTypeGpbHi>) };
//! GPW register (X86).
class Gpw : public Gp { ASMJIT_DEFINE_FINAL_REG(Gpw, Gp, RegTraits<kTypeGpw>) };
//! GPD register (X86).
class Gpd : public Gp { ASMJIT_DEFINE_FINAL_REG(Gpd, Gp, RegTraits<kTypeGpd>) };
//! GPQ register (X86_64).
class Gpq : public Gp { ASMJIT_DEFINE_FINAL_REG(Gpq, Gp, RegTraits<kTypeGpq>) };
//! 128-bit XMM register (SSE+).
class Xmm : public Vec { ASMJIT_DEFINE_FINAL_REG(Xmm, Vec, RegTraits<kTypeXmm>) };
//! 256-bit YMM register (AVX+).
class Ymm : public Vec { ASMJIT_DEFINE_FINAL_REG(Ymm, Vec, RegTraits<kTypeYmm>) };
//! 512-bit ZMM register (AVX512+).
class Zmm : public Vec { ASMJIT_DEFINE_FINAL_REG(Zmm, Vec, RegTraits<kTypeZmm>) };
//! 64-bit MMX register (MMX+).
class Mm : public Reg { ASMJIT_DEFINE_FINAL_REG(Mm, Reg, RegTraits<kTypeMm>) };
//! 64-bit K register (AVX512+).
class KReg : public Reg { ASMJIT_DEFINE_FINAL_REG(KReg, Reg, RegTraits<kTypeKReg>) };
//! 32-bit or 64-bit control register (X86).
class CReg : public Reg { ASMJIT_DEFINE_FINAL_REG(CReg, Reg, RegTraits<kTypeCReg>) };
//! 32-bit or 64-bit debug register (X86).
class DReg : public Reg { ASMJIT_DEFINE_FINAL_REG(DReg, Reg, RegTraits<kTypeDReg>) };
//! 80-bit FPU register (X86).
class St : public Reg { ASMJIT_DEFINE_FINAL_REG(St, Reg, RegTraits<kTypeSt>) };
//! 128-bit BND register (BND+).
class Bnd : public Reg { ASMJIT_DEFINE_FINAL_REG(Bnd, Reg, RegTraits<kTypeBnd>) };
//! RIP register (X86).
class Rip : public Reg { ASMJIT_DEFINE_FINAL_REG(Rip, Reg, RegTraits<kTypeRip>) };

constexpr GpbLo Gp::r8() const noexcept { return GpbLo(id()); }
constexpr GpbLo Gp::r8Lo() const noexcept { return GpbLo(id()); }
constexpr GpbHi Gp::r8Hi() const noexcept { return GpbHi(id()); }
constexpr Gpw Gp::r16() const noexcept { return Gpw(id()); }
constexpr Gpd Gp::r32() const noexcept { return Gpd(id()); }
constexpr Gpq Gp::r64() const noexcept { return Gpq(id()); }
constexpr Xmm Vec::xmm() const noexcept { return Xmm(*this, id()); }
constexpr Ymm Vec::ymm() const noexcept { return Ymm(*this, id()); }
constexpr Zmm Vec::zmm() const noexcept { return Zmm(*this, id()); }

// ============================================================================
// [asmjit::x86::Mem]
// ============================================================================

//! Memory operand ().
class Mem : public BaseMem {
public:
  //! Additional bits of operand's signature used by `Mem`.
  enum AdditionalBits : uint32_t {
    kSignatureMemSegmentShift   = 16,
    kSignatureMemSegmentBits    = 0x07u,
    kSignatureMemSegmentMask    = kSignatureMemSegmentBits << kSignatureMemSegmentShift,

    kSignatureMemShiftShift     = 19,
    kSignatureMemShiftBits      = 0x03u,
    kSignatureMemShiftMask      = kSignatureMemShiftBits << kSignatureMemShiftShift,

    kSignatureMemBroadcastShift = 21,
    kSignatureMemBroadcastBits  = 0x7u,
    kSignatureMemBroadcastMask  = kSignatureMemBroadcastBits << kSignatureMemBroadcastShift
  };

  enum Broadcast : uint32_t {
    kBroadcast1To1              = 0,
    kBroadcast1To2              = 1,
    kBroadcast1To4              = 2,
    kBroadcast1To8              = 3,
    kBroadcast1To16             = 4,
    kBroadcast1To32             = 5,
    kBroadcast1To64             = 6
  };

  // --------------------------------------------------------------------------
  // [Construction / Destruction]
  // --------------------------------------------------------------------------

  //! Construct a default `Mem` operand that points to [0].
  constexpr Mem() noexcept
    : BaseMem() {}

  constexpr Mem(const Mem& other) noexcept
    : BaseMem(other) {}

  constexpr Mem(const Label& base, int32_t off, uint32_t size = 0, uint32_t flags = 0) noexcept
    : BaseMem(Globals::Init, Label::kLabelTag, base.id(), 0, 0, off, size, flags) {}

  constexpr Mem(const Label& base, const BaseReg& index, uint32_t shift, int32_t off, uint32_t size = 0, uint32_t flags = 0) noexcept
    : BaseMem(Globals::Init, Label::kLabelTag, base.id(), index.type(), index.id(), off, size, flags | (shift << kSignatureMemShiftShift)) {}

  constexpr Mem(const BaseReg& base, int32_t off, uint32_t size = 0, uint32_t flags = 0) noexcept
    : BaseMem(Globals::Init, base.type(), base.id(), 0, 0, off, size, flags) {}

  constexpr Mem(const BaseReg& base, const BaseReg& index, uint32_t shift, int32_t off, uint32_t size = 0, uint32_t flags = 0) noexcept
    : BaseMem(Globals::Init, base.type(), base.id(), index.type(), index.id(), off, size, flags | (shift << kSignatureMemShiftShift)) {}

  constexpr Mem(uint64_t base, uint32_t size = 0, uint32_t flags = 0) noexcept
    : BaseMem(Globals::Init, 0, uint32_t(base >> 32), 0, 0, int32_t(uint32_t(base & 0xFFFFFFFFu)), size, flags) {}

  constexpr Mem(uint64_t base, const BaseReg& index, uint32_t shift = 0, uint32_t size = 0, uint32_t flags = 0) noexcept
    : BaseMem(Globals::Init, 0, uint32_t(base >> 32), index.type(), index.id(), int32_t(uint32_t(base & 0xFFFFFFFFu)), size, flags | (shift << kSignatureMemShiftShift)) {}

  //! Construct a `Mem` operand from `MemData`.
  constexpr explicit Mem(const MemData& data) noexcept
    : BaseMem(data) {}

  constexpr Mem(Globals::Init_, uint32_t baseType, uint32_t baseId, uint32_t indexType, uint32_t indexId, int32_t off, uint32_t size, uint32_t flags) noexcept
    : BaseMem(Globals::Init, baseType, baseId, indexType, indexId, off, size, flags) {}

  inline explicit Mem(Globals::NoInit_) noexcept
    : BaseMem(Globals::NoInit) {}

  //! Clone the memory operand.
  constexpr Mem clone() const noexcept { return Mem(*this); }

  //! Get new memory operand adjusted by `off`.
  inline Mem cloneAdjusted(int64_t off) const noexcept {
    Mem result(*this);
    result.addOffset(off);
    return result;
  }

  constexpr Mem _1to1() const noexcept { return Mem(MemData { (_any.signature & ~kSignatureMemBroadcastMask) | (kBroadcast1To1 << kSignatureMemBroadcastShift), _any.id, _any.p32_2, _any.p32_3 }); }
  constexpr Mem _1to2() const noexcept { return Mem(MemData { (_any.signature & ~kSignatureMemBroadcastMask) | (kBroadcast1To2 << kSignatureMemBroadcastShift), _any.id, _any.p32_2, _any.p32_3 }); }
  constexpr Mem _1to4() const noexcept { return Mem(MemData { (_any.signature & ~kSignatureMemBroadcastMask) | (kBroadcast1To4 << kSignatureMemBroadcastShift), _any.id, _any.p32_2, _any.p32_3 }); }
  constexpr Mem _1to8() const noexcept { return Mem(MemData { (_any.signature & ~kSignatureMemBroadcastMask) | (kBroadcast1To8 << kSignatureMemBroadcastShift), _any.id, _any.p32_2, _any.p32_3 }); }
  constexpr Mem _1to16() const noexcept { return Mem(MemData { (_any.signature & ~kSignatureMemBroadcastMask) | (kBroadcast1To16 << kSignatureMemBroadcastShift), _any.id, _any.p32_2, _any.p32_3 }); }
  constexpr Mem _1to32() const noexcept { return Mem(MemData { (_any.signature & ~kSignatureMemBroadcastMask) | (kBroadcast1To32 << kSignatureMemBroadcastShift), _any.id, _any.p32_2, _any.p32_3 }); }
  constexpr Mem _1to64() const noexcept { return Mem(MemData { (_any.signature & ~kSignatureMemBroadcastMask) | (kBroadcast1To64 << kSignatureMemBroadcastShift), _any.id, _any.p32_2, _any.p32_3 }); }

  // --------------------------------------------------------------------------
  // [Mem]
  // --------------------------------------------------------------------------

  using BaseMem::setIndex;

  inline void setIndex(const BaseReg& index, uint32_t shift) noexcept {
    setIndex(index);
    setShift(shift);
  }

  //! Get whether the memory operand has a segment override.
  constexpr bool hasSegment() const noexcept { return _hasSignatureData(kSignatureMemSegmentMask); }
  //! Get associated segment override as `SReg` operand.
  constexpr SReg segment() const noexcept { return SReg(segmentId()); }
  //! Get segment override as id, see `SReg::Id`.
  constexpr uint32_t segmentId() const noexcept { return _signatureData(kSignatureMemSegmentBits, kSignatureMemSegmentShift); }

  //! Set the segment override to `seg`.
  inline void setSegment(const SReg& seg) noexcept { setSegment(seg.id()); }
  //! Set the segment override to `id`.
  inline void setSegment(uint32_t rId) noexcept { _setSignatureData(rId, kSignatureMemSegmentBits, kSignatureMemSegmentShift); }
  //! Reset the segment override.
  inline void resetSegment() noexcept { _any.signature &= ~kSignatureMemSegmentMask; }

  //! Get whether the memory operand has shift (aka scale) constant.
  constexpr bool hasShift() const noexcept { return _hasSignatureData(kSignatureMemShiftMask); }
  //! Get the memory operand's shift (aka scale) constant.
  constexpr uint32_t shift() const noexcept { return _signatureData(kSignatureMemShiftBits, kSignatureMemShiftShift); }
  //! Set the memory operand's shift (aka scale) constant.
  inline void setShift(uint32_t shift) noexcept { _setSignatureData(shift, kSignatureMemShiftBits, kSignatureMemShiftShift); }
  //! Reset the memory operand's shift (aka scale) constant to zero.
  inline void resetShift() noexcept { _any.signature &= ~kSignatureMemShiftMask; }

  //! Get whether the memory operand has broadcast {1tox}.
  constexpr bool hasBroadcast() const noexcept { return _hasSignatureData(kSignatureMemBroadcastMask); }
  //! Get the memory operand's broadcast.
  constexpr uint32_t getBroadcast() const noexcept { return _signatureData(kSignatureMemBroadcastBits, kSignatureMemBroadcastShift); }
  //! Set the memory operand's broadcast.
  inline void setBroadcast(uint32_t bcst) noexcept { _setSignatureData(bcst, kSignatureMemBroadcastBits, kSignatureMemBroadcastShift); }
  //! Reset the memory operand's broadcast to none.
  inline void resetBroadcast() noexcept { _any.signature &= ~kSignatureMemBroadcastMask; }

  // --------------------------------------------------------------------------
  // [Operator Overload]
  // --------------------------------------------------------------------------

  inline Mem& operator=(const Mem& other) noexcept = default;
};

// ============================================================================
// [asmjit::x86::OpData]
// ============================================================================

struct OpData {
  //! Information about all architecture registers.
  ArchRegs archRegs;
};
ASMJIT_VARAPI const OpData opData;

inline uint32_t Reg::groupOf(uint32_t rType) noexcept {
  ASMJIT_ASSERT(rType <= BaseReg::kTypeMax);
  return opData.archRegs.regInfo[rType].group();
}

inline uint32_t Reg::typeIdOf(uint32_t rType) noexcept {
  ASMJIT_ASSERT(rType <= BaseReg::kTypeMax);
  return opData.archRegs.regTypeToTypeId[rType];
}

// ... Reg methods that require `opData`.
inline uint32_t Reg::signatureOf(uint32_t rType) noexcept {
  ASMJIT_ASSERT(rType <= BaseReg::kTypeMax);
  return opData.archRegs.regInfo[rType].signature();
}

// ============================================================================
// [asmjit::x86::regs]
// ============================================================================

namespace regs {
namespace {

//! Create an 8-bit low GPB register operand.
static constexpr GpbLo gpb(uint32_t rId) noexcept { return GpbLo(rId); }
//! Create an 8-bit low GPB register operand.
static constexpr GpbLo gpb_lo(uint32_t rId) noexcept { return GpbLo(rId); }
//! Create an 8-bit high GPB register operand.
static constexpr GpbHi gpb_hi(uint32_t rId) noexcept { return GpbHi(rId); }
//! Create a 16-bit GPW register operand.
static constexpr Gpw gpw(uint32_t rId) noexcept { return Gpw(rId); }
//! Create a 32-bit GPD register operand.
static constexpr Gpd gpd(uint32_t rId) noexcept { return Gpd(rId); }
//! Create a 64-bit GPQ register operand (64-bit).
static constexpr Gpq gpq(uint32_t rId) noexcept { return Gpq(rId); }
//! Create a 128-bit XMM register operand.
static constexpr Xmm xmm(uint32_t rId) noexcept { return Xmm(rId); }
//! Create a 256-bit YMM register operand.
static constexpr Ymm ymm(uint32_t rId) noexcept { return Ymm(rId); }
//! Create a 512-bit ZMM register operand.
static constexpr Zmm zmm(uint32_t rId) noexcept { return Zmm(rId); }
//! Create a 64-bit Mm register operand.
static constexpr Mm mm(uint32_t rId) noexcept { return Mm(rId); }
//! Create a 64-bit K register operand.
static constexpr KReg k(uint32_t rId) noexcept { return KReg(rId); }
//! Create a 32-bit or 64-bit control register operand.
static constexpr CReg cr(uint32_t rId) noexcept { return CReg(rId); }
//! Create a 32-bit or 64-bit debug register operand.
static constexpr DReg dr(uint32_t rId) noexcept { return DReg(rId); }
//! Create an 80-bit st register operand.
static constexpr St st(uint32_t rId) noexcept { return St(rId); }
//! Create a 128-bit bound register operand.
static constexpr Bnd bnd(uint32_t rId) noexcept { return Bnd(rId); }

static constexpr Gp al(GpbLo::kSignature, Gp::kIdAx);
static constexpr Gp bl(GpbLo::kSignature, Gp::kIdBx);
static constexpr Gp cl(GpbLo::kSignature, Gp::kIdCx);
static constexpr Gp dl(GpbLo::kSignature, Gp::kIdDx);
static constexpr Gp spl(GpbLo::kSignature, Gp::kIdSp);
static constexpr Gp bpl(GpbLo::kSignature, Gp::kIdBp);
static constexpr Gp sil(GpbLo::kSignature, Gp::kIdSi);
static constexpr Gp dil(GpbLo::kSignature, Gp::kIdDi);
static constexpr Gp r8b(GpbLo::kSignature, Gp::kIdR8);
static constexpr Gp r9b(GpbLo::kSignature, Gp::kIdR9);
static constexpr Gp r10b(GpbLo::kSignature, Gp::kIdR10);
static constexpr Gp r11b(GpbLo::kSignature, Gp::kIdR11);
static constexpr Gp r12b(GpbLo::kSignature, Gp::kIdR12);
static constexpr Gp r13b(GpbLo::kSignature, Gp::kIdR13);
static constexpr Gp r14b(GpbLo::kSignature, Gp::kIdR14);
static constexpr Gp r15b(GpbLo::kSignature, Gp::kIdR15);

static constexpr Gp ah(GpbHi::kSignature, Gp::kIdAx);
static constexpr Gp bh(GpbHi::kSignature, Gp::kIdBx);
static constexpr Gp ch(GpbHi::kSignature, Gp::kIdCx);
static constexpr Gp dh(GpbHi::kSignature, Gp::kIdDx);

static constexpr Gp ax(Gpw::kSignature, Gp::kIdAx);
static constexpr Gp bx(Gpw::kSignature, Gp::kIdBx);
static constexpr Gp cx(Gpw::kSignature, Gp::kIdCx);
static constexpr Gp dx(Gpw::kSignature, Gp::kIdDx);
static constexpr Gp sp(Gpw::kSignature, Gp::kIdSp);
static constexpr Gp bp(Gpw::kSignature, Gp::kIdBp);
static constexpr Gp si(Gpw::kSignature, Gp::kIdSi);
static constexpr Gp di(Gpw::kSignature, Gp::kIdDi);
static constexpr Gp r8w(Gpw::kSignature, Gp::kIdR8);
static constexpr Gp r9w(Gpw::kSignature, Gp::kIdR9);
static constexpr Gp r10w(Gpw::kSignature, Gp::kIdR10);
static constexpr Gp r11w(Gpw::kSignature, Gp::kIdR11);
static constexpr Gp r12w(Gpw::kSignature, Gp::kIdR12);
static constexpr Gp r13w(Gpw::kSignature, Gp::kIdR13);
static constexpr Gp r14w(Gpw::kSignature, Gp::kIdR14);
static constexpr Gp r15w(Gpw::kSignature, Gp::kIdR15);

static constexpr Gp eax(Gpd::kSignature, Gp::kIdAx);
static constexpr Gp ebx(Gpd::kSignature, Gp::kIdBx);
static constexpr Gp ecx(Gpd::kSignature, Gp::kIdCx);
static constexpr Gp edx(Gpd::kSignature, Gp::kIdDx);
static constexpr Gp esp(Gpd::kSignature, Gp::kIdSp);
static constexpr Gp ebp(Gpd::kSignature, Gp::kIdBp);
static constexpr Gp esi(Gpd::kSignature, Gp::kIdSi);
static constexpr Gp edi(Gpd::kSignature, Gp::kIdDi);
static constexpr Gp r8d(Gpd::kSignature, Gp::kIdR8);
static constexpr Gp r9d(Gpd::kSignature, Gp::kIdR9);
static constexpr Gp r10d(Gpd::kSignature, Gp::kIdR10);
static constexpr Gp r11d(Gpd::kSignature, Gp::kIdR11);
static constexpr Gp r12d(Gpd::kSignature, Gp::kIdR12);
static constexpr Gp r13d(Gpd::kSignature, Gp::kIdR13);
static constexpr Gp r14d(Gpd::kSignature, Gp::kIdR14);
static constexpr Gp r15d(Gpd::kSignature, Gp::kIdR15);

static constexpr Gp rax(Gpq::kSignature, Gp::kIdAx);
static constexpr Gp rbx(Gpq::kSignature, Gp::kIdBx);
static constexpr Gp rcx(Gpq::kSignature, Gp::kIdCx);
static constexpr Gp rdx(Gpq::kSignature, Gp::kIdDx);
static constexpr Gp rsp(Gpq::kSignature, Gp::kIdSp);
static constexpr Gp rbp(Gpq::kSignature, Gp::kIdBp);
static constexpr Gp rsi(Gpq::kSignature, Gp::kIdSi);
static constexpr Gp rdi(Gpq::kSignature, Gp::kIdDi);
static constexpr Gp r8(Gpq::kSignature, Gp::kIdR8);
static constexpr Gp r9(Gpq::kSignature, Gp::kIdR9);
static constexpr Gp r10(Gpq::kSignature, Gp::kIdR10);
static constexpr Gp r11(Gpq::kSignature, Gp::kIdR11);
static constexpr Gp r12(Gpq::kSignature, Gp::kIdR12);
static constexpr Gp r13(Gpq::kSignature, Gp::kIdR13);
static constexpr Gp r14(Gpq::kSignature, Gp::kIdR14);
static constexpr Gp r15(Gpq::kSignature, Gp::kIdR15);

static constexpr Xmm xmm0(0);
static constexpr Xmm xmm1(1);
static constexpr Xmm xmm2(2);
static constexpr Xmm xmm3(3);
static constexpr Xmm xmm4(4);
static constexpr Xmm xmm5(5);
static constexpr Xmm xmm6(6);
static constexpr Xmm xmm7(7);
static constexpr Xmm xmm8(8);
static constexpr Xmm xmm9(9);
static constexpr Xmm xmm10(10);
static constexpr Xmm xmm11(11);
static constexpr Xmm xmm12(12);
static constexpr Xmm xmm13(13);
static constexpr Xmm xmm14(14);
static constexpr Xmm xmm15(15);
static constexpr Xmm xmm16(16);
static constexpr Xmm xmm17(17);
static constexpr Xmm xmm18(18);
static constexpr Xmm xmm19(19);
static constexpr Xmm xmm20(20);
static constexpr Xmm xmm21(21);
static constexpr Xmm xmm22(22);
static constexpr Xmm xmm23(23);
static constexpr Xmm xmm24(24);
static constexpr Xmm xmm25(25);
static constexpr Xmm xmm26(26);
static constexpr Xmm xmm27(27);
static constexpr Xmm xmm28(28);
static constexpr Xmm xmm29(29);
static constexpr Xmm xmm30(30);
static constexpr Xmm xmm31(31);

static constexpr Ymm ymm0(0);
static constexpr Ymm ymm1(1);
static constexpr Ymm ymm2(2);
static constexpr Ymm ymm3(3);
static constexpr Ymm ymm4(4);
static constexpr Ymm ymm5(5);
static constexpr Ymm ymm6(6);
static constexpr Ymm ymm7(7);
static constexpr Ymm ymm8(8);
static constexpr Ymm ymm9(9);
static constexpr Ymm ymm10(10);
static constexpr Ymm ymm11(11);
static constexpr Ymm ymm12(12);
static constexpr Ymm ymm13(13);
static constexpr Ymm ymm14(14);
static constexpr Ymm ymm15(15);
static constexpr Ymm ymm16(16);
static constexpr Ymm ymm17(17);
static constexpr Ymm ymm18(18);
static constexpr Ymm ymm19(19);
static constexpr Ymm ymm20(20);
static constexpr Ymm ymm21(21);
static constexpr Ymm ymm22(22);
static constexpr Ymm ymm23(23);
static constexpr Ymm ymm24(24);
static constexpr Ymm ymm25(25);
static constexpr Ymm ymm26(26);
static constexpr Ymm ymm27(27);
static constexpr Ymm ymm28(28);
static constexpr Ymm ymm29(29);
static constexpr Ymm ymm30(30);
static constexpr Ymm ymm31(31);

static constexpr Zmm zmm0(0);
static constexpr Zmm zmm1(1);
static constexpr Zmm zmm2(2);
static constexpr Zmm zmm3(3);
static constexpr Zmm zmm4(4);
static constexpr Zmm zmm5(5);
static constexpr Zmm zmm6(6);
static constexpr Zmm zmm7(7);
static constexpr Zmm zmm8(8);
static constexpr Zmm zmm9(9);
static constexpr Zmm zmm10(10);
static constexpr Zmm zmm11(11);
static constexpr Zmm zmm12(12);
static constexpr Zmm zmm13(13);
static constexpr Zmm zmm14(14);
static constexpr Zmm zmm15(15);
static constexpr Zmm zmm16(16);
static constexpr Zmm zmm17(17);
static constexpr Zmm zmm18(18);
static constexpr Zmm zmm19(19);
static constexpr Zmm zmm20(20);
static constexpr Zmm zmm21(21);
static constexpr Zmm zmm22(22);
static constexpr Zmm zmm23(23);
static constexpr Zmm zmm24(24);
static constexpr Zmm zmm25(25);
static constexpr Zmm zmm26(26);
static constexpr Zmm zmm27(27);
static constexpr Zmm zmm28(28);
static constexpr Zmm zmm29(29);
static constexpr Zmm zmm30(30);
static constexpr Zmm zmm31(31);

static constexpr Mm mm0(0);
static constexpr Mm mm1(1);
static constexpr Mm mm2(2);
static constexpr Mm mm3(3);
static constexpr Mm mm4(4);
static constexpr Mm mm5(5);
static constexpr Mm mm6(6);
static constexpr Mm mm7(7);

static constexpr KReg k0(0);
static constexpr KReg k1(1);
static constexpr KReg k2(2);
static constexpr KReg k3(3);
static constexpr KReg k4(4);
static constexpr KReg k5(5);
static constexpr KReg k6(6);
static constexpr KReg k7(7);

static constexpr SReg no_seg(SReg::kIdNone);
static constexpr SReg es(SReg::kIdEs);
static constexpr SReg cs(SReg::kIdCs);
static constexpr SReg ss(SReg::kIdSs);
static constexpr SReg ds(SReg::kIdDs);
static constexpr SReg fs(SReg::kIdFs);
static constexpr SReg gs(SReg::kIdGs);

static constexpr CReg cr0(0);
static constexpr CReg cr1(1);
static constexpr CReg cr2(2);
static constexpr CReg cr3(3);
static constexpr CReg cr4(4);
static constexpr CReg cr5(5);
static constexpr CReg cr6(6);
static constexpr CReg cr7(7);
static constexpr CReg cr8(8);
static constexpr CReg cr9(9);
static constexpr CReg cr10(10);
static constexpr CReg cr11(11);
static constexpr CReg cr12(12);
static constexpr CReg cr13(13);
static constexpr CReg cr14(14);
static constexpr CReg cr15(15);

static constexpr DReg dr0(0);
static constexpr DReg dr1(1);
static constexpr DReg dr2(2);
static constexpr DReg dr3(3);
static constexpr DReg dr4(4);
static constexpr DReg dr5(5);
static constexpr DReg dr6(6);
static constexpr DReg dr7(7);
static constexpr DReg dr8(8);
static constexpr DReg dr9(9);
static constexpr DReg dr10(10);
static constexpr DReg dr11(11);
static constexpr DReg dr12(12);
static constexpr DReg dr13(13);
static constexpr DReg dr14(14);
static constexpr DReg dr15(15);

static constexpr St st0(0);
static constexpr St st1(1);
static constexpr St st2(2);
static constexpr St st3(3);
static constexpr St st4(4);
static constexpr St st5(5);
static constexpr St st6(6);
static constexpr St st7(7);

static constexpr Bnd bnd0(0);
static constexpr Bnd bnd1(1);
static constexpr Bnd bnd2(2);
static constexpr Bnd bnd3(3);

static constexpr Rip rip(0);

} // anonymous namespace
} // regs namespace

// Make `x86::regs` accessible through `x86` namespace as well.
using namespace regs;

// ============================================================================
// [asmjit::x86::ptr]
// ============================================================================

//! Create a `[base.reg + offset]` memory operand.
static constexpr Mem ptr(const Gp& base, int32_t offset = 0, uint32_t size = 0) noexcept {
  return Mem(base, offset, size);
}
//! Create a `[base.reg + (index << shift) + offset]` memory operand (scalar index).
static constexpr Mem ptr(const Gp& base, const Gp& index, uint32_t shift = 0, int32_t offset = 0, uint32_t size = 0) noexcept {
  return Mem(base, index, shift, offset, size);
}
//! Create a `[base.reg + (index << shift) + offset]` memory operand (vector index).
static constexpr Mem ptr(const Gp& base, const Vec& index, uint32_t shift = 0, int32_t offset = 0, uint32_t size = 0) noexcept {
  return Mem(base, index, shift, offset, size);
}

//! Create a `[base + offset]` memory operand.
static constexpr Mem ptr(const Label& base, int32_t offset = 0, uint32_t size = 0) noexcept {
  return Mem(base, offset, size);
}
//! Create a `[base + (index << shift) + offset]` memory operand.
static constexpr Mem ptr(const Label& base, const Gp& index, uint32_t shift, int32_t offset = 0, uint32_t size = 0) noexcept {
  return Mem(base, index, shift, offset, size);
}
//! Create a `[base + (index << shift) + offset]` memory operand.
static constexpr Mem ptr(const Label& base, const Vec& index, uint32_t shift, int32_t offset = 0, uint32_t size = 0) noexcept {
  return Mem(base, index, shift, offset, size);
}

//! Create `[rip + offset]` memory operand.
static constexpr Mem ptr(const Rip& rip_, int32_t offset = 0, uint32_t size = 0) noexcept {
  return Mem(rip_, offset, size);
}

//! Create an `[base]` absolute memory operand.
static constexpr Mem ptr(uint64_t base, uint32_t size = 0) noexcept {
  return Mem(base, size);
}
//! Create an `[abs + (index.reg << shift)]` absolute memory operand.
static constexpr Mem ptr(uint64_t base, const Reg& index, uint32_t shift = 0, uint32_t size = 0) noexcept {
  return Mem(base, index, shift, size);
}
//! Create an `[abs + (index.reg << shift)]` absolute memory operand.
static constexpr Mem ptr(uint64_t base, const Vec& index, uint32_t shift = 0, uint32_t size = 0) noexcept {
  return Mem(base, index, shift, size);
}

//! \internal
#define ASMJIT_MEM_PTR(FUNC, SIZE)                                                    \
  /*! Create a `[base + offset]` memory operand. */                                   \
  static constexpr Mem FUNC(const Gp& base, int32_t offset = 0) noexcept {            \
    return Mem(base, offset, SIZE);                                                   \
  }                                                                                   \
  /*! Create a `[base + (index << shift) + offset]` memory operand. */                \
  static constexpr Mem FUNC(const Gp& base, const Gp& index, uint32_t shift = 0, int32_t offset = 0) noexcept { \
    return Mem(base, index, shift, offset, SIZE);                                     \
  }                                                                                   \
  /*! Create a `[base + (vec_index << shift) + offset]` memory operand. */            \
  static constexpr Mem FUNC(const Gp& base, const Vec& index, uint32_t shift = 0, int32_t offset = 0) noexcept { \
    return Mem(base, index, shift, offset, SIZE);                                     \
  }                                                                                   \
  /*! Create a `[base + offset]` memory operand. */                                   \
  static constexpr Mem FUNC(const Label& base, int32_t offset = 0) noexcept {         \
    return Mem(base, offset, SIZE);                                                   \
  }                                                                                   \
  /*! Create a `[base + (index << shift) + offset]` memory operand. */                \
  static constexpr Mem FUNC(const Label& base, const Gp& index, uint32_t shift, int32_t offset = 0) noexcept { \
    return Mem(base, index, shift, offset, SIZE);                                     \
  }                                                                                   \
  /*! Create a `[rip + offset]` memory operand. */                                    \
  static constexpr Mem FUNC(const Rip& rip_, int32_t offset = 0) noexcept {           \
    return Mem(rip_, offset, SIZE);                                                   \
  }                                                                                   \
  /*! Create a `[base + offset]` memory operand. */                                   \
  static constexpr Mem FUNC(uint64_t base) noexcept {                                 \
    return Mem(base, SIZE);                                                           \
  }                                                                                   \
  /*! Create a `[base + (index << shift) + offset]` memory operand. */                \
  static constexpr Mem FUNC(uint64_t base, const Gp& index, uint32_t shift = 0) noexcept { \
    return Mem(base, index, shift, SIZE);                                             \
  }                                                                                   \
  /*! Create a `[base + (vec_index << shift) + offset]` memory operand. */            \
  static constexpr Mem FUNC(uint64_t base, const Vec& index, uint32_t shift = 0) noexcept { \
    return Mem(base, index, shift, SIZE, BaseMem::kSignatureMemAbs);                  \
  }                                                                                   \
  /*! Create a `[base + offset]` memory operand. */                                   \
  static constexpr Mem FUNC##_abs(uint64_t base) noexcept {                           \
    return Mem(base, SIZE);                                                           \
  }                                                                                   \
  /*! Create a `[base + (index << shift) + offset]` memory operand. */                \
  static constexpr Mem FUNC##_abs(uint64_t base, const Gp& index, uint32_t shift = 0) noexcept { \
    return Mem(base, index, shift, SIZE, BaseMem::kSignatureMemAbs);                  \
  }                                                                                   \
  /*! Create a `[base + (vec_index << shift) + offset]` memory operand. */            \
  static constexpr Mem FUNC##_abs(uint64_t base, const Vec& index, uint32_t shift = 0) noexcept { \
    return Mem(base, index, shift, SIZE, BaseMem::kSignatureMemAbs);                  \
  }

// Define memory operand constructors that use platform independent naming.
ASMJIT_MEM_PTR(ptr_8, 1)
ASMJIT_MEM_PTR(ptr_16, 2)
ASMJIT_MEM_PTR(ptr_32, 4)
ASMJIT_MEM_PTR(ptr_48, 6)
ASMJIT_MEM_PTR(ptr_64, 8)
ASMJIT_MEM_PTR(ptr_80, 10)
ASMJIT_MEM_PTR(ptr_128, 16)
ASMJIT_MEM_PTR(ptr_256, 32)
ASMJIT_MEM_PTR(ptr_512, 64)

// Define memory operand constructors that use X86 architecture-specific conventions.
ASMJIT_MEM_PTR(byte_ptr, 1)
ASMJIT_MEM_PTR(word_ptr, 2)
ASMJIT_MEM_PTR(dword_ptr, 4)
ASMJIT_MEM_PTR(qword_ptr, 8)
ASMJIT_MEM_PTR(tword_ptr, 10)
ASMJIT_MEM_PTR(oword_ptr, 16)
ASMJIT_MEM_PTR(dqword_ptr, 16)
ASMJIT_MEM_PTR(qqword_ptr, 32)
ASMJIT_MEM_PTR(xmmword_ptr, 16)
ASMJIT_MEM_PTR(ymmword_ptr, 32)
ASMJIT_MEM_PTR(zmmword_ptr, 64)

#undef ASMJIT_MEM_PTR

//! \}

ASMJIT_END_SUB_NAMESPACE

// ============================================================================
// [asmjit::Type::IdOfT<x86::Reg>]
// ============================================================================

ASMJIT_BEGIN_NAMESPACE

ASMJIT_DEFINE_TYPE_ID(x86::Gpb, kIdI8);
ASMJIT_DEFINE_TYPE_ID(x86::Gpw, kIdI16);
ASMJIT_DEFINE_TYPE_ID(x86::Gpd, kIdI32);
ASMJIT_DEFINE_TYPE_ID(x86::Gpq, kIdI64);
ASMJIT_DEFINE_TYPE_ID(x86::Mm , kIdMmx64);
ASMJIT_DEFINE_TYPE_ID(x86::Xmm, kIdI32x4);
ASMJIT_DEFINE_TYPE_ID(x86::Ymm, kIdI32x8);
ASMJIT_DEFINE_TYPE_ID(x86::Zmm, kIdI32x16);

ASMJIT_END_NAMESPACE

// [Guard]
#endif // _ASMJIT_X86_OPERAND_H

```

`Avanguard/AsmJit/asmjit/x86/x86rapass_p.h`:

```h
// [AsmJit]
// Complete x86/x64 JIT and Remote Assembler for C++.
//
// [License]
// ZLIB - See LICENSE.md file in the package.

// [Guard]
#ifndef _ASMJIT_X86_X86RAPASS_P_H
#define _ASMJIT_X86_X86RAPASS_P_H

#include "../core/build.h"
#ifndef ASMJIT_DISABLE_COMPILER

// [Dependencies]
#include "../core/compiler.h"
#include "../core/rabuilders_p.h"
#include "../core/rapass_p.h"
#include "../x86/x86assembler.h"
#include "../x86/x86compiler.h"

ASMJIT_BEGIN_SUB_NAMESPACE(x86)

//! \addtogroup asmjit_x86_ra
//! \{

// ============================================================================
// [asmjit::X86RAPass]
// ============================================================================

//! \internal
//!
//! X86 register allocation pass.
//!
//! Takes care of generating function prologs and epilogs, and also performs
//! register allocation.
class X86RAPass : public RAPass {
public:
  ASMJIT_NONCOPYABLE(X86RAPass)
  typedef RAPass Base;

  // --------------------------------------------------------------------------
  // [Construction / Destruction]
  // --------------------------------------------------------------------------

  X86RAPass() noexcept;
  virtual ~X86RAPass() noexcept;

  // --------------------------------------------------------------------------
  // [Accessors]
  // --------------------------------------------------------------------------

  //! Get compiler as `x86::Compiler`.
  inline Compiler* cc() const noexcept { return static_cast<Compiler*>(_cb); }

  // --------------------------------------------------------------------------
  // [OnInit / OnDone]
  // --------------------------------------------------------------------------

  void onInit() noexcept override;
  void onDone() noexcept override;

  // --------------------------------------------------------------------------
  // [CFG]
  // --------------------------------------------------------------------------

  Error buildCFG() noexcept override;

  // --------------------------------------------------------------------------
  // [Emit]
  // --------------------------------------------------------------------------

  Error onEmitMove(uint32_t workId, uint32_t dstPhysId, uint32_t srcPhysId) noexcept override;
  Error onEmitSwap(uint32_t aWorkId, uint32_t aPhysId, uint32_t bWorkId, uint32_t bPhysId) noexcept override;

  Error onEmitLoad(uint32_t workId, uint32_t dstPhysId) noexcept override;
  Error onEmitSave(uint32_t workId, uint32_t srcPhysId) noexcept override;

  Error onEmitJump(const Label& label) noexcept override;

  // --------------------------------------------------------------------------
  // [Members]
  // --------------------------------------------------------------------------

  bool _avxEnabled;
};

//! \}

ASMJIT_END_SUB_NAMESPACE

// [Guard]
#endif // !ASMJIT_DISABLE_COMPILER
#endif // _ASMJIT_X86_X86RAPASS_P_H

```

`Avanguard/AsmJit/asmjit/x86/x86ssetoavx_p.h`:

```h
// [AsmJit]
// Complete x86/x64 JIT and Remote Assembler for C++.
//
// [License]
// ZLIB - See LICENSE.md file in the package.

// [Guard]
#ifndef _ASMJIT_X86_X86SSETOAVX_P_H
#define _ASMJIT_X86_X86SSETOAVX_P_H

#include "../core/build.h"
#ifndef ASMJIT_DISABLE_BUILDER

// [Dependencies]
#include "../core/support.h"
#include "../x86/x86builder.h"

ASMJIT_BEGIN_SUB_NAMESPACE(x86)

//! \addtogroup asmjit_x86_api
//! \{

// ============================================================================
// [asmjit::x86::SseToAvxData]
// ============================================================================

//! Contains data that can be used to convert SSE to AVX or vice versa.
struct SseToAvxData {
  //! Conversion mode.
  enum Mode : uint32_t {
    kModeNone       = 0,                 //!< No conversion possible.
    kModeMove       = 1,                 //!< No change (no operands changed).
    kModeMoveIfMem  = 2,                 //!< No change if the second operand is mem, extend otherwise.
    kModeExtend     = 3,                 //!< The first SSE operand becomes first and second AVX operand.
    kModeBlend      = 4                  //!< Special case for 'vblendvpd', 'vblendvps', and 'vpblendvb'.
  };

  inline uint32_t mode() const noexcept { return _mode; }
  inline int32_t delta() const noexcept { return _delta; }

  uint16_t _mode :  3;                   //!< SSE to AVX conversion mode, see `Mode`.
  int16_t _delta : 13;                   //!< Delta to get the counterpart SSE/AVX instruction.
};

// ============================================================================
// [asmjit::x86::SseToAvxPass]
// ============================================================================

class SseToAvxPass final : public Pass {
public:
  ASMJIT_NONCOPYABLE(SseToAvxPass)
  typedef Pass Base;

  SseToAvxPass() noexcept;
  Error run(Zone* zone, Logger* logger) noexcept override;

  enum ProbeMask : uint32_t {
    kProbeMmx  = 1u << Reg::kTypeMm,     //!< Instruction uses MMX registers.
    kProbeXmm  = 1u << Reg::kTypeXmm     //!< Instruction uses XMM registers.
  };

  static inline uint32_t probeRegs(const Operand* operands, uint32_t count) noexcept {
    uint32_t mask = 0;
    for (uint32_t i = 0; i < count; i++) {
      const Operand& op = operands[i];
      if (!op.isReg()) continue;
      mask |= Support::mask(op.as<BaseReg>().type());
    }
    return mask;
  }

  // --------------------------------------------------------------------------
  // [Members]
  // --------------------------------------------------------------------------

  bool _translated;
};

//! \}

ASMJIT_END_SUB_NAMESPACE

// [Guard]
#endif // !ASMJIT_DISABLE_BUILDER
#endif // _ASMJIT_X86_X86SSETOAVX_P_H

```

`Avanguard/AsmJit/asmtk/asmparser.cpp`:

```cpp
// [AsmTk]
// Assembler toolkit based on AsmJit.
//
// [License]
// Zlib - See LICENSE.md file in the package.

#include "stdafx.h"

// [Dependencies]
#include "./asmparser.h"
#include "./parserutils.h"

namespace asmtk {

using namespace asmjit;

// ============================================================================
// [asmtk::X86Directive]
// ============================================================================

enum X86Directive : uint32_t {
  kX86DirectiveNone  = 0,
  kX86DirectiveAlign,
  kX86DirectiveDB,
  kX86DirectiveDW,
  kX86DirectiveDD,
  kX86DirectiveDQ
};

// ============================================================================
// [asmtk::X86Alias]
// ============================================================================

enum X86Alias : uint32_t {
  kX86AliasStart = 0x00010000U,

  kX86AliasMovabs = kX86AliasStart,

  kX86AliasInsb,
  kX86AliasInsd,
  kX86AliasInsw,

  kX86AliasOutsb,
  kX86AliasOutsd,
  kX86AliasOutsw,

  kX86AliasCmpsb,
  kX86AliasCmpsd,
  kX86AliasCmpsq,
  kX86AliasCmpsw,

  kX86AliasMovsb,
  kX86AliasMovsd,
  kX86AliasMovsq,
  kX86AliasMovsw,

  kX86AliasLodsb,
  kX86AliasLodsd,
  kX86AliasLodsq,
  kX86AliasLodsw,

  kX86AliasScasb,
  kX86AliasScasd,
  kX86AliasScasq,
  kX86AliasScasw,

  kX86AliasStosb,
  kX86AliasStosd,
  kX86AliasStosq,
  kX86AliasStosw
};

// ============================================================================
// [asmtk::AsmParser]
// ============================================================================

AsmParser::AsmParser(BaseEmitter* emitter) noexcept
  : _emitter(emitter),
    _currentCommandOffset(0),
    _unknownSymbolHandler(NULL),
    _unknownSymbolHandlerData(NULL) {}
AsmParser::~AsmParser() noexcept {}

// ============================================================================
// [asmtk::AsmParser - Input]
// ============================================================================

uint32_t AsmParser::nextToken(AsmToken* token, uint32_t flags) noexcept {
  return _tokenizer.next(token, flags);
}

void AsmParser::putTokenBack(AsmToken* token) noexcept {
  _tokenizer.putBack(token);
}

// ============================================================================
// [asmtk::AsmParser - Parse]
// ============================================================================

static void strToLower(uint8_t* dst, const uint8_t* src, size_t size) noexcept{
  for (size_t i = 0; i < size; i++)
    dst[i] = Support::asciiToLower<uint8_t>(uint8_t(src[i]));
}

#define COMB_CHAR_2(a, b) \
  ((uint32_t(a) << 8) | uint32_t(b))

#define COMB_CHAR_4(a, b, c, d) \
  ((uint32_t(a) << 24) | (uint32_t(b) << 16) | (uint32_t(c) << 8) | uint32_t(d))

static bool x86ParseRegister(Operand_& op, const uint8_t* s, size_t size) noexcept {
  constexpr uint32_t kMinSize = 2;
  constexpr uint32_t kMaxSize = 5;

  if (size < kMinSize || size > kMaxSize) return false;
  const uint8_t* sEnd = s + size;

  uint32_t c0 = Support::asciiToLower<uint32_t>(s[0]);
  uint32_t c1 = Support::asciiToLower<uint32_t>(s[1]);
  uint32_t c2 = size > 2 ? Support::asciiToLower<uint32_t>(s[2]) : uint32_t(0);
  uint32_t cn = (c0 << 8) + c1;

  uint32_t rType = x86::Reg::kTypeNone;
  uint32_t rId = 0;

  static const uint8_t gpLetterToRegIndex[] = {
    uint8_t(x86::Gp::kIdAx), // a
    uint8_t(x86::Gp::kIdBx), // b
    uint8_t(x86::Gp::kIdCx), // c
    uint8_t(x86::Gp::kIdDx)  // d
  };

  static const uint8_t srLetterToRegIndex[] = {
    uint8_t(x86::Reg::kIdBad), // a
    uint8_t(x86::Reg::kIdBad), // b
    uint8_t(x86::SReg::kIdCs), // c
    uint8_t(x86::SReg::kIdDs), // d
    uint8_t(x86::SReg::kIdEs), // e
    uint8_t(x86::SReg::kIdFs), // f
    uint8_t(x86::SReg::kIdGs), // g
    uint8_t(x86::Reg::kIdBad), // h
    uint8_t(x86::Reg::kIdBad), // i
    uint8_t(x86::Reg::kIdBad), // j
    uint8_t(x86::Reg::kIdBad), // k
    uint8_t(x86::Reg::kIdBad), // l
    uint8_t(x86::Reg::kIdBad), // m
    uint8_t(x86::Reg::kIdBad), // n
    uint8_t(x86::Reg::kIdBad), // o
    uint8_t(x86::Reg::kIdBad), // p
    uint8_t(x86::Reg::kIdBad), // q
    uint8_t(x86::Reg::kIdBad), // r
    uint8_t(x86::SReg::kIdSs)  // s
  };

  // [AL|BL|CL|DL]
  // [AH|BH|CH|DH]
  // [AX|BX|CX|DX]
  // [ES|CS|SS|DS|FS|GS]
  if (size == 2 && Support::isBetween<uint32_t>(c0, 'a', 's')) {
    if (c0 <= 'd') {
      rId = gpLetterToRegIndex[c0 - 'a'];

      rType = x86::Reg::kTypeGpbLo;
      if (c1 == 'l') goto Done;

      rType = x86::Reg::kTypeGpbHi;
      if (c1 == 'h') goto Done;

      rType = x86::Reg::kTypeGpw;
      if (c1 == 'x') goto Done;
    }

    if (c1 == 's') {
      rId = srLetterToRegIndex[c0 - 'a'];
      rType = x86::Reg::kTypeSReg;

      if (rId != x86::Reg::kIdBad)
        goto Done;
    }

    rType = x86::Reg::kTypeGpw;
    goto TrySpBpSiDi;
  }

  // [SP|BP|SI|DI]
  // [SPL|BPL|SIL|DIL]
  // [EAX|EBX|ECX|EDX|ESP|EBP|EDI|ESI]
  // [RAX|RBX|RCX|RDX|RSP|RBP|RDI|RSI]
  // [RIP]
  if (size == 3) {
    if (c2 == 'l') {
      rType = x86::Reg::kTypeGpbLo;
      goto TrySpBpSiDi;
    }

    if (c0 == 'e' || c0 == 'r') {
      cn = (c1 << 8) | c2;
      rType = (c0 == 'e') ? x86::Reg::kTypeGpd : x86::Reg::kTypeGpq;

      if (c0 == 'r' && cn == COMB_CHAR_2('i', 'p')) {
        rType = x86::Reg::kTypeRip;
        goto Done;
      }

      if (cn == COMB_CHAR_2('a', 'x')) { rId = x86::Gp::kIdAx; goto Done; }
      if (cn == COMB_CHAR_2('d', 'x')) { rId = x86::Gp::kIdDx; goto Done; }
      if (cn == COMB_CHAR_2('b', 'x')) { rId = x86::Gp::kIdBx; goto Done; }
      if (cn == COMB_CHAR_2('c', 'x')) { rId = x86::Gp::kIdCx; goto Done; }

TrySpBpSiDi:
      if (cn == COMB_CHAR_2('s', 'p')) { rId = x86::Gp::kIdSp; goto Done; }
      if (cn == COMB_CHAR_2('b', 'p')) { rId = x86::Gp::kIdBp; goto Done; }
      if (cn == COMB_CHAR_2('s', 'i')) { rId = x86::Gp::kIdSi; goto Done; }
      if (cn == COMB_CHAR_2('d', 'i')) { rId = x86::Gp::kIdDi; goto Done; }
    }
  }

  // [R?|R?B|R?W|R?D]
  if (c0 == 'r') {
    s++;
    rType = x86::Reg::kTypeGpq;

    // Handle 'b', 'w', and 'd' suffixes.
    c2 = Support::asciiToLower<uint32_t>(sEnd[-1]);
    if (c2 == 'b')
      rType = x86::Reg::kTypeGpbLo;
    else if (c2 == 'w')
      rType = x86::Reg::kTypeGpw;
    else if (c2 == 'd')
      rType = x86::Reg::kTypeGpd;
    sEnd -= (rType != x86::Reg::kTypeGpq);
  }
  // [XMM?|YMM?|ZMM?]
  else if (c0 >= 'x' && c0 <= 'z' && c1 == 'm' && c2 == 'm') {
    s += 3;
    rType = x86::Reg::kTypeXmm + (c0 - 'x');
  }
  // [K?]
  else if (c0 == 'k') {
    s++;
    rType = x86::Reg::kTypeKReg;
  }
  // [ST?|FP?]
  else if ((c0 == 's' && c1 == 't') | (c0 == 'f' && c1 == 'p')) {
    s += 2;
    rType = x86::Reg::kTypeSt;
  }
  // [MM?]
  else if (c0 == 'm' && c1 == 'm') {
    s += 2;
    rType = x86::Reg::kTypeMm;
  }
  // [BND?]
  else if (c0 == 'b' && c1 == 'n' && c2 == 'd') {
    s += 3;
    rType = x86::Reg::kTypeBnd;
  }
  // [CR?]
  else if (c0 == 'c' && c1 == 'r') {
    s += 2;
    rType = x86::Reg::kTypeCReg;
  }
  // [DR?]
  else if (c0 == 'd' && c1 == 'r') {
    s += 2;
    rType = x86::Reg::kTypeDReg;
  }
  else {
    return false;
  }

  // Parse the register index.
  rId = uint32_t(s[0]) - '0';
  if (rId >= 10) return false;

  if (++s < sEnd) {
    c0 = uint32_t(*s++) - '0';
    if (c0 >= 10) return false;
    rId = rId * 10 + c0;

    // Maximum register
    if (rId >= 32) return false;
  }

  // Fail if the whole input wasn't parsed.
  if (s != sEnd) return false;

  // Fail if the register index is greater than allowed.
  if (rId >= x86::opData.archRegs.regCount[rType]) return false;

Done:
  op._initReg(x86::opData.archRegs.regInfo[rType].signature(), rId);
  return true;
}

static uint32_t x86ParseSize(const uint8_t* s, size_t size) noexcept {
  constexpr uint32_t kMinSize = 4;
  constexpr uint32_t kMaxSize = 7;

  if (size < kMinSize || size > kMaxSize)
    return 0;

  // Start from the end.
  ParserUtils::WordParser suffix;
  suffix.addLowercasedChar(s + size - 4, 0);
  suffix.addLowercasedChar(s + size - 4, 1);
  suffix.addLowercasedChar(s + size - 4, 2);
  suffix.addLowercasedChar(s + size - 4, 3);

  if (suffix.test('w', 'o', 'r', 'd')) {
    // Parsed 'word'.
    if (size == 4) return 2;

    // Sizes of length '5':
    ParserUtils::WordParser wordSize;
    wordSize.addLowercasedChar(s, 0);

    if (size == 5) {
      // Check the most common first.
      if (wordSize.test('d')) return 4;
      if (wordSize.test('q')) return 8;
      if (wordSize.test('o')) return 16;
      if (wordSize.test('x')) return 16;
      if (wordSize.test('y')) return 32;
      if (wordSize.test('z')) return 64;

      // `fword` (aka far word, 16:32 m48 pointer) and `tword` (m80).
      if (wordSize.test('f')) return 6;
      if (wordSize.test('t')) return 10;
    }

    // Sizes of length '6':
    wordSize.addLowercasedChar(s, 1);
    if (size == 6) {
      if (wordSize.test('m', 'm')) return 8;
      if (wordSize.test('d', 'q')) return 16;
      if (wordSize.test('q', 'q')) return 32;
    }

    // Sizes of length '7':
    wordSize.addLowercasedChar(s, 2);
    if (size == 7) {
      if (wordSize.test('x', 'm', 'm')) return 16;
      if (wordSize.test('y', 'm', 'm')) return 32;
      if (wordSize.test('z', 'm', 'm')) return 64;
    }
  }

  // Parsed 'byte'.
  if (suffix.test('b', 'y', 't', 'e'))
    return size == 4 ? 1 : 0;

  return 0;
}

static Error asmHandleSymbol(AsmParser& parser, Operand_& dst, const uint8_t* name, size_t size) noexcept {
  Label L = parser._emitter->labelByName(reinterpret_cast<const char*>(name), size);

  if (!L.isValid()) {
    if (parser._unknownSymbolHandler) {
      Error err = parser._unknownSymbolHandler(&parser, static_cast<Operand*>(&dst), reinterpret_cast<const char*>(name), size);
      if (err)
        return err;

      if (!dst.isNone())
        return kErrorOk;
    }

    L = parser._emitter->newNamedLabel(reinterpret_cast<const char*>(name), size);
    if (!L.isValid()) return DebugUtils::errored(kErrorNoHeapMemory);
  }

  dst = L;
  return kErrorOk;
}

static Error x86ParseOperand(AsmParser& parser, Operand_& dst, AsmToken* token) noexcept {
  uint32_t type = token->type;
  uint32_t memSize = 0;
  Operand seg;

  // Symbol, could be register, memory operand size, or label.
  if (type == AsmToken::kSym) {
    // Try register.
    if (x86ParseRegister(dst, token->data, token->size)) {
      if (!dst.as<x86::Reg>().isSReg())
        return kErrorOk;

      // A segment register followed by a colon (':') describes a segment of a
      // memory operand - in such case we store the segment and jump to MemOp.
      AsmToken tTmp;
      if (parser.nextToken(token) == AsmToken::kColon &&
          parser.nextToken(&tTmp) == AsmToken::kLBracket) {
        seg = dst;
        goto MemOp;
      }
      parser.putTokenBack(token);
      return kErrorOk;
    }

    // Try memory size specifier.
    memSize = x86ParseSize(token->data, token->size);
    if (memSize) {
      type = parser.nextToken(token);

      // The specifier may be followed by 'ptr', skip it in such case.
      if (type == AsmToken::kSym &&
          token->size == 3 &&
          Support::asciiToLower<uint32_t>(token->data[0]) == 'p' &&
          Support::asciiToLower<uint32_t>(token->data[1]) == 't' &&
          Support::asciiToLower<uint32_t>(token->data[2]) == 'r') {
        type = parser.nextToken(token);
      }

      // Jump to memory operand if we encountered '['.
      if (type == AsmToken::kLBracket)
        goto MemOp;

      // Parse segment prefix otherwise.
      if (type == AsmToken::kSym) {
        // Segment register.
        if (!x86ParseRegister(seg, token->data, token->size) || !seg.as<x86::Reg>().isSReg())
          return DebugUtils::errored(kErrorInvalidAddress);

        type = parser.nextToken(token);
        if (type != AsmToken::kColon)
          return DebugUtils::errored(kErrorInvalidAddress);

        type = parser.nextToken(token);
        if (type == AsmToken::kLBracket)
          goto MemOp;
      }

      return DebugUtils::errored(kErrorInvalidAddress);
    }

    // Must be label/symbol.
    return asmHandleSymbol(parser, dst, token->data, token->size);
  }

  // Memory address - parse opening '['.
  if (type == AsmToken::kLBracket) {
MemOp:
    Operand base;
    Operand index;

    uint32_t shift = 0;
    uint32_t flags = 0;
    uint64_t offset = 0;

    // Parse address prefix - 'abs'.
    type = parser.nextToken(token);
    if (type == AsmToken::kSym) {
      if (token->size == 3) {
        ParserUtils::WordParser addrMode;
        addrMode.addLowercasedChar(token->data, 0);
        addrMode.addLowercasedChar(token->data, 1);
        addrMode.addLowercasedChar(token->data, 2);

        if (addrMode.test('a', 'b', 's')) {
          flags |= BaseMem::kSignatureMemAbs;
          type = parser.nextToken(token);
        }
        else if (addrMode.test('r', 'e', 'l')) {
          flags |= BaseMem::kSignatureMemRel;
          type = parser.nextToken(token);
        }
        else if (addrMode.test('w', 'r', 't')) {
          flags |= BaseMem::kSignatureMemWrt;
          type = parser.nextToken(token);
        }
      }
    }

    // Parse "[base] + [index [* scale]] + [offset]" or "[base + [offset]], [index [* scale]]" parts.
    bool commaSeparated = false;
    uint32_t opType = AsmToken::kAdd;

    for (;;) {
      if (type == AsmToken::kSym) {
        if (opType != AsmToken::kAdd)
          return DebugUtils::errored(kErrorInvalidAddress);

        Operand op;
        if (!x86ParseRegister(op, token->data, token->size)) {
          // No label after 'base' is allowed.
          if (!base.isNone())
            return DebugUtils::errored(kErrorInvalidAddress);

          ASMJIT_PROPAGATE(asmHandleSymbol(parser, op, token->data, token->size));
        }

        type = parser.nextToken(token);
        opType = AsmToken::kInvalid;

        if (type != AsmToken::kMul) {
          // Prefer base, then index.
          if (base.isNone() && !commaSeparated)
            base = op;
          else if (index.isNone())
            index = op;
          else
            return DebugUtils::errored(kErrorInvalidAddress);
          continue;
        }
        else {
          // Must be index.
          if (base.isLabel() || !index.isNone())
            return DebugUtils::errored(kErrorInvalidAddress);

          index = op;
          type = parser.nextToken(token);
          if (type != AsmToken::kU64)
            return DebugUtils::errored(kErrorInvalidAddressScale);

          switch (token->u64) {
            case 1: shift = 0; break;
            case 2: shift = 1; break;
            case 4: shift = 2; break;
            case 8: shift = 3; break;
            default:
              return DebugUtils::errored(kErrorInvalidAddressScale);
          }
        }
      }
      else if (type == AsmToken::kU64) {
        if (opType == AsmToken::kAdd) {
          offset += token->u64;
          opType = AsmToken::kInvalid;
        }
        else if (opType == AsmToken::kSub) {
          offset -= token->u64;
          opType = AsmToken::kInvalid;
        }
        else {
          return DebugUtils::errored(kErrorInvalidAddress);
        }
      }
      else if (type == AsmToken::kAdd) {
        if (opType == AsmToken::kInvalid)
          opType = type;
      }
      else if (type == AsmToken::kSub) {
        if (opType == AsmToken::kInvalid)
          opType = type;
        else
          opType = opType == AsmToken::kSub ? AsmToken::kAdd : AsmToken::kSub;
      }
      else if (type == AsmToken::kRBracket) {
        if (opType != AsmToken::kInvalid)
          return DebugUtils::errored(kErrorInvalidAddress);

        // Reverse base and index if base is a vector register.
        if (x86::Reg::isVec(base)) {
          if (index.isReg())
            return DebugUtils::errored(kErrorInvalidAddress);
          std::swap(base, index);
        }

        if (!base.isNone()) {
          if (!Support::isI32<int64_t>(int64_t(offset)) &&
              !Support::isU32<int64_t>(int64_t(offset)))
            return DebugUtils::errored(kErrorInvalidAddress64Bit);

          int32_t disp32 = int32_t(offset & 0xFFFFFFFFU);
          if (base.isLabel())
            dst = x86::ptr(base.as<Label>(), disp32);
          else if (!index.isReg())
            dst = x86::ptr(base.as<x86::Gp>(), disp32);
          else
            dst = x86::ptr(base.as<x86::Gp>(), index.as<x86::Gp>(), shift, disp32);
        }
        else {
          if (!index.isReg())
            dst = x86::ptr(offset);
          else
            dst = x86::ptr(offset, index.as<x86::Gp>(), shift);
        }

        dst.as<x86::Mem>().setSize(memSize);
        dst._addSignatureData(flags);

        if (seg.isReg())
          dst.as<x86::Mem>().setSegment(seg.as<x86::SReg>());

        return kErrorOk;
        break;
      }
      else if (type == AsmToken::kComma) {
        if (commaSeparated)
          return DebugUtils::errored(kErrorInvalidAddress);

        opType = AsmToken::kAdd;
        commaSeparated = true;
      }
      else {
        return DebugUtils::errored(kErrorInvalidAddress);
      }

      type = parser.nextToken(token);
    }
  }

  // Immediate.
  if (type == AsmToken::kU64 || type == AsmToken::kSub) {
    bool negative = (type == AsmToken::kSub);
    if (negative) {
      type = parser.nextToken(token);
      if (type != AsmToken::kU64)
        return DebugUtils::errored(kErrorInvalidState);
    }

    dst = imm(negative ? -token->i64 : token->i64);
    return kErrorOk;
  }

  return DebugUtils::errored(kErrorInvalidState);
}

static uint32_t x86ParseInstOption(const uint8_t* s, size_t size) noexcept {
  constexpr uint32_t kMinSize = 3;
  constexpr uint32_t kMaxSize = 8;

  if (size < kMinSize || size > kMaxSize)
    return 0;

  ParserUtils::WordParser word;

  // Options of length '3':
  word.addLowercasedChar(s, 0);
  word.addLowercasedChar(s, 1);
  word.addLowercasedChar(s, 2);
  if (size == 3) {
    if (word.test('r', 'e', 'p')) return x86::Inst::kOptionRep;
    if (word.test('r', 'e', 'x')) return x86::Inst::kOptionRex;
    return 0;
  }

  // Options of length '4':
  word.addLowercasedChar(s, 3);
  if (size == 4) {
    if (word.test('l', 'o', 'c', 'k')) return x86::Inst::kOptionLock;
    if (word.test('r', 'e', 'p', 'z')) return x86::Inst::kOptionRep;
    if (word.test('r', 'e', 'p', 'e')) return x86::Inst::kOptionRep;
    if (word.test('l', 'o', 'n', 'g')) return x86::Inst::kOptionLongForm;
    if (word.test('v', 'e', 'x', '3')) return x86::Inst::kOptionVex3;
    if (word.test('e', 'v', 'e', 'x')) return x86::Inst::kOptionEvex;
    return 0;
  }

  // Options of length '5':
  word.addLowercasedChar(s, 4);
  if (size == 5) {
    if (word.test('r', 'e', 'p', 'n', 'e')) return x86::Inst::kOptionRepne;
    if (word.test('r', 'e', 'p', 'n', 'z')) return x86::Inst::kOptionRepne;
    if (word.test('s', 'h', 'o', 'r', 't')) return x86::Inst::kOptionShortForm;
    if (word.test('m', 'o', 'd', 'm', 'r')) return x86::Inst::kOptionModMR;
    return 0;
  }

  // Options of length '8':
  word.addLowercasedChar(s, 5);
  word.addLowercasedChar(s, 6);
  word.addLowercasedChar(s, 7);
  if (size == 8) {
    if (word.test('x', 'a', 'c', 'q', 'u', 'i', 'r', 'e')) return x86::Inst::kOptionXAcquire;
    if (word.test('x', 'r', 'e', 'l', 'e', 'a', 's', 'e')) return x86::Inst::kOptionXRelease;
    return 0;
  }

  return 0;
}

static uint32_t x86ParseAvx512Option(const uint8_t* s, size_t size) noexcept {
  constexpr uint32_t kMinSize = 3;
  constexpr uint32_t kMaxSize = 6;

  if (size < kMinSize || size > kMaxSize)
    return 0;

  ParserUtils::WordParser word;

  // Options of length '3':
  word.addLowercasedChar(s, 0);
  word.addLowercasedChar(s, 1);
  word.addLowercasedChar(s, 2);
  if (size == 3) {
    if (word.test('s', 'a', 'e')) return x86::Inst::kOptionSAE;
    return 0;
  }

  if (size < 6)
    return 0;

  // Options of length '6':
  word.addLowercasedChar(s, 3);
  word.addLowercasedChar(s, 4);
  word.addLowercasedChar(s, 5);
  if (size == 6) {
    if (word.test('r', 'n', '-', 's', 'a', 'e')) return x86::Inst::kOptionER | x86::Inst::kOptionRN_SAE;
    if (word.test('r', 'd', '-', 's', 'a', 'e')) return x86::Inst::kOptionER | x86::Inst::kOptionRD_SAE;
    if (word.test('r', 'u', '-', 's', 'a', 'e')) return x86::Inst::kOptionER | x86::Inst::kOptionRU_SAE;
    if (word.test('r', 'z', '-', 's', 'a', 'e')) return x86::Inst::kOptionER | x86::Inst::kOptionRZ_SAE;
    return 0;
  }

  return 0;
}

static uint32_t x86ParseAvx512Broadcast(const uint8_t* s, size_t size) noexcept {
  constexpr uint32_t kMinSize = 4;
  constexpr uint32_t kMaxSize = 5;

  if (size < kMinSize || size > kMaxSize)
    return 0;

  ParserUtils::WordParser word;

  // Broadcast option of length '4':
  word.addLowercasedChar(s, 0);
  word.addLowercasedChar(s, 1);
  word.addLowercasedChar(s, 2);
  word.addLowercasedChar(s, 3);
  if (size == 4) {
    if (word.test('1', 't', 'o', '2')) return x86::Mem::kBroadcast1To2;
    if (word.test('1', 't', 'o', '4')) return x86::Mem::kBroadcast1To4;
    if (word.test('1', 't', 'o', '8')) return x86::Mem::kBroadcast1To8;
    return 0;
  }

  // Broadcast option of length '5':
  word.addLowercasedChar(s, 4);
  if (size == 5) {
    if (word.test('1', 't', 'o', '1', '6')) return x86::Mem::kBroadcast1To16;
    if (word.test('1', 't', 'o', '3', '2')) return x86::Mem::kBroadcast1To32;
    if (word.test('1', 't', 'o', '6', '4')) return x86::Mem::kBroadcast1To64;
    return 0;
  }

  return 0;
}

static uint32_t x86ParseDirective(const uint8_t* s, size_t size) noexcept {
  if (size < 2)
    return 0;

  ParserUtils::WordParser word;
  word.addLowercasedChar(s, 0);
  word.addLowercasedChar(s, 1);

  if (size == 2) {
    if (word.test('d', 'b')) return kX86DirectiveDB;
    if (word.test('d', 'w')) return kX86DirectiveDW;
    if (word.test('d', 'd')) return kX86DirectiveDD;
    if (word.test('d', 'q')) return kX86DirectiveDQ;
    return 0;
  }

  if (size < 5)
    return 0;

  word.addLowercasedChar(s, 2);
  word.addLowercasedChar(s, 3);
  word.addLowercasedChar(s, 4);
  if (size == 5) {
    if (word.test('a', 'l', 'i', 'g', 'n')) return kX86DirectiveAlign;
    return 0;
  }

  return 0;
}

static uint32_t x86ParseAlias(const uint8_t* s, size_t size) noexcept {
  if (size < 3)
    return x86::Inst::kIdNone;

  ParserUtils::WordParser word;
  word.addLowercasedChar(s, 0);
  word.addLowercasedChar(s, 1);
  word.addLowercasedChar(s, 2);
  if (size == 3) {
    if (word.test('s', 'a', 'l')) return x86::Inst::kIdShl;
    return x86::Inst::kIdNone;
  }

  word.addLowercasedChar(s, 3);
  if (size == 4) {
    if (word.test('i', 'n', 's', 'b')) return kX86AliasInsb;
    if (word.test('i', 'n', 's', 'w')) return kX86AliasInsw;
    if (word.test('i', 'n', 's', 'd')) return kX86AliasInsd;
    return x86::Inst::kIdNone;
  }

  word.addLowercasedChar(s, 4);
  if (size == 5) {
    if (word.test('c', 'm', 'p', 's', 'b')) return kX86AliasCmpsb;
    if (word.test('c', 'm', 'p', 's', 'w')) return kX86AliasCmpsw;
    if (word.test('c', 'm', 'p', 's', 'd')) return kX86AliasCmpsd;
    if (word.test('c', 'm', 'p', 's', 'q')) return kX86AliasCmpsq;

    if (word.test('l', 'o', 'd', 's', 'b')) return kX86AliasLodsb;
    if (word.test('l', 'o', 'd', 's', 'w')) return kX86AliasLodsw;
    if (word.test('l', 'o', 'd', 's', 'd')) return kX86AliasLodsd;
    if (word.test('l', 'o', 'd', 's', 'q')) return kX86AliasLodsq;

    if (word.test('m', 'o', 'v', 's', 'b')) return kX86AliasMovsb;
    if (word.test('m', 'o', 'v', 's', 'w')) return kX86AliasMovsw;
    if (word.test('m', 'o', 'v', 's', 'd')) return kX86AliasMovsd;
    if (word.test('m', 'o', 'v', 's', 'q')) return kX86AliasMovsq;

    if (word.test('s', 'c', 'a', 's', 'b')) return kX86AliasScasb;
    if (word.test('s', 'c', 'a', 's', 'w')) return kX86AliasScasw;
    if (word.test('s', 'c', 'a', 's', 'd')) return kX86AliasScasd;
    if (word.test('s', 'c', 'a', 's', 'q')) return kX86AliasScasq;

    if (word.test('s', 't', 'o', 's', 'b')) return kX86AliasStosb;
    if (word.test('s', 't', 'o', 's', 'w')) return kX86AliasStosw;
    if (word.test('s', 't', 'o', 's', 'd')) return kX86AliasStosd;
    if (word.test('s', 't', 'o', 's', 'q')) return kX86AliasStosq;

    if (word.test('o', 'u', 't', 's', 'b')) return kX86AliasOutsb;
    if (word.test('o', 'u', 't', 's', 'w')) return kX86AliasOutsw;
    if (word.test('o', 'u', 't', 's', 'd')) return kX86AliasOutsd;

    return x86::Inst::kIdNone;
  }

  word.addLowercasedChar(s, 5);
  if (size == 6) {
    if (word.test('m', 'o', 'v', 'a', 'b', 's')) return kX86AliasMovabs;
  }

  return x86::Inst::kIdNone;
}

static Error x86ParseInstruction(AsmParser& parser, uint32_t& instId, uint32_t& options, AsmToken* token) noexcept {
  for (;;) {
    size_t size = token->size;
    uint8_t lower[32];

    if (size > ASMJIT_ARRAY_SIZE(lower))
      return DebugUtils::errored(kErrorInvalidInstruction);

    strToLower(lower, token->data, size);

    // Try to match instruction alias, as there are some tricky ones.
    instId = x86ParseAlias(lower, size);
    if (instId == x86::Inst::kIdNone) {
      // If that didn't work out, try to match instruction as defined by AsmJit.
      instId = x86::InstDB::idByName(reinterpret_cast<char*>(lower), size);
    }

    if (instId == x86::Inst::kIdNone) {
      // Maybe it's an option / prefix?
      uint32_t option = x86ParseInstOption(lower, size);
      if (!(option))
        return DebugUtils::errored(kErrorInvalidInstruction);

      // Refuse to parse the same option specified multiple times.
      if (ASMJIT_UNLIKELY(options & option))
        return DebugUtils::errored(kErrorOptionAlreadyDefined);

      options |= option;
      if (parser.nextToken(token) != AsmToken::kSym)
        return DebugUtils::errored(kErrorInvalidInstruction);
    }
    else {
      // Ok, we have an instruction. Now let's parse the next token and decide if
      // it belongs to the instruction or not. This is required to parse things
      // such "jmp short" although we prefer "short jmp" (but the former is valid
      // in other assemblers).
      if (parser.nextToken(token) == AsmToken::kSym) {
        size = token->size;
        if (size <= ASMJIT_ARRAY_SIZE(lower)) {
          strToLower(lower, token->data, size);
          uint32_t option = x86ParseInstOption(lower, size);
          if (option == x86::Inst::kOptionShortForm) {
            options |= option;
            return kErrorOk;
          }
        }
      }

      parser.putTokenBack(token);
      return kErrorOk;
    }
  }
}

static Error x86FixupInstruction(AsmParser& parser, BaseInst& inst, Operand_* operands, uint32_t& count) noexcept {
  uint32_t i;

  uint32_t& instId = inst._id;
  uint32_t& options = inst._options;

  if (instId >= kX86AliasStart) {
    x86::Emitter* emitter = static_cast<x86::Emitter*>(parser._emitter);
    uint32_t memSize = 0;
    bool isStr = false;

    switch (instId) {
      case kX86AliasMovabs:
        // 'movabs' is basically the longest 'mov'.
        instId = x86::Inst::kIdMov;
        options |= x86::Inst::kOptionLongForm;
        break;

      case kX86AliasInsb: memSize = 1; instId = x86::Inst::kIdIns; isStr = true; break;
      case kX86AliasInsd: memSize = 4; instId = x86::Inst::kIdIns; isStr = true; break;
      case kX86AliasInsw: memSize = 2; instId = x86::Inst::kIdIns; isStr = true; break;

      case kX86AliasOutsb: memSize = 1; instId = x86::Inst::kIdOuts; isStr = true; break;
      case kX86AliasOutsd: memSize = 4; instId = x86::Inst::kIdOuts; isStr = true; break;
      case kX86AliasOutsw: memSize = 2; instId = x86::Inst::kIdOuts; isStr = true; break;

      case kX86AliasCmpsb: memSize = 1; instId = x86::Inst::kIdCmps; isStr = true; break;
      case kX86AliasCmpsd: memSize = 4;
        isStr = count == 0 || (count == 2 && operands[0].isMem() && operands[1].isMem());
        instId = isStr ? x86::Inst::kIdCmps : x86::Inst::kIdCmpsd;
        break;
      case kX86AliasCmpsq: memSize = 8; instId = x86::Inst::kIdCmps; isStr = true; break;
      case kX86AliasCmpsw: memSize = 2; instId = x86::Inst::kIdCmps; isStr = true; break;

      case kX86AliasMovsb: memSize = 1; instId = x86::Inst::kIdMovs; isStr = true; break;
      case kX86AliasMovsd: memSize = 4;
        isStr = count == 0 || (count == 2 && operands[0].isMem() && operands[1].isMem());
        instId = isStr ? x86::Inst::kIdMovs : x86::Inst::kIdMovsd;
        break;
      case kX86AliasMovsq: memSize = 8; instId = x86::Inst::kIdMovs; isStr = true; break;
      case kX86AliasMovsw: memSize = 2; instId = x86::Inst::kIdMovs; isStr = true; break;

      case kX86AliasLodsb: memSize = 1; instId = x86::Inst::kIdLods; isStr = true; break;
      case kX86AliasLodsd: memSize = 4; instId = x86::Inst::kIdLods; isStr = true; break;
      case kX86AliasLodsq: memSize = 8; instId = x86::Inst::kIdLods; isStr = true; break;
      case kX86AliasLodsw: memSize = 2; instId = x86::Inst::kIdLods; isStr = true; break;

      case kX86AliasScasb: memSize = 1; instId = x86::Inst::kIdScas; isStr = true; break;
      case kX86AliasScasd: memSize = 4; instId = x86::Inst::kIdScas; isStr = true; break;
      case kX86AliasScasq: memSize = 8; instId = x86::Inst::kIdScas; isStr = true; break;
      case kX86AliasScasw: memSize = 2; instId = x86::Inst::kIdScas; isStr = true; break;

      case kX86AliasStosb: memSize = 1; instId = x86::Inst::kIdStos; isStr = true; break;
      case kX86AliasStosd: memSize = 4; instId = x86::Inst::kIdStos; isStr = true; break;
      case kX86AliasStosq: memSize = 8; instId = x86::Inst::kIdStos; isStr = true; break;
      case kX86AliasStosw: memSize = 2; instId = x86::Inst::kIdStos; isStr = true; break;
        break;
    }

    if (isStr) {
      if (count == 0) {
        uint32_t sign = memSize == 1 ? uint32_t(x86::GpbLo::kSignature) :
                        memSize == 2 ? uint32_t(x86::Gpw::kSignature) :
                        memSize == 4 ? uint32_t(x86::Gpd::kSignature) :
                                       uint32_t(x86::Gpq::kSignature) ;

        // String instructions aliases.
        count = 2;
        switch (instId) {
          case x86::Inst::kIdCmps: operands[0] = emitter->ptr_zsi(); operands[1] = emitter->ptr_zdi(); break;
          case x86::Inst::kIdMovs: operands[0] = emitter->ptr_zdi(); operands[1] = emitter->ptr_zsi(); break;
          case x86::Inst::kIdLods:
          case x86::Inst::kIdScas: operands[0] = BaseReg(sign, x86::Gp::kIdAx); operands[1] = emitter->ptr_zdi(); break;
          case x86::Inst::kIdStos: operands[0] = emitter->ptr_zdi(); operands[1] = BaseReg(sign, x86::Gp::kIdAx); break;
        }
      }

      for (i = 0; i < count; i++) {
        if (operands[i].isMem()) {
          x86::Mem& mem = operands[i].as<x86::Mem>();

          if (mem.size() == 0)
            mem.setSize(memSize);

          if (mem.baseId() == x86::Gp::kIdDi && mem.segmentId() == x86::SReg::kIdEs)
            mem.resetSegment();
        }
      }
    }
  }

  for (i = 0; i < count; i++) {
    Operand_& op = operands[i];

    // If the parsed memory segment is the default one, remove it. AsmJit
    // always emits segment-override if the segment is specified, this is
    // good on AsmJit side, but causes problems here as it's not necessary
    // to emit 'ds:' everywhere if the input contains it (and it's common).
    if (op.isMem() && op.as<x86::Mem>().hasSegment()) {
      x86::Mem& mem = op.as<x86::Mem>();

      // Default to `ds` segment for most instructions.
      uint32_t defaultSeg = x86::SReg::kIdDs;

      // Default to `ss` segment if the operand has esp|rsp or ebp|rbp base.
      if (mem.hasBaseReg()) {
        if (mem.baseId() == x86::Gp::kIdSp || mem.baseId() == x86::Gp::kIdBp)
          defaultSeg = x86::SReg::kIdSs;
      }

      if (mem.segmentId() == defaultSeg)
        mem.resetSegment();
    }
  }

  return kErrorOk;
}

Error AsmParser::parse(const char* input, size_t size) noexcept {
  setInput(input, size);
  while (!isEndOfInput())
    ASMJIT_PROPAGATE(parseCommand());
  return kErrorOk;
}

Error AsmParser::parseCommand() noexcept {
  AsmToken token;
  uint32_t tType = nextToken(&token);

  _currentCommandOffset = (size_t)(reinterpret_cast<const char*>(token.data) - input());

  if (tType == AsmToken::kSym) {
    AsmToken tmp;

    tType = nextToken(&tmp);
    if (tType == AsmToken::kColon) {
      // Parse label.
      Label dst;
      ASMJIT_PROPAGATE(asmHandleSymbol(*this, dst, token.data, token.size));
      ASMJIT_PROPAGATE(_emitter->bind(dst));
      return kErrorOk;
    }

    if (token.data[0] == '.') {
      // Parse directive (instructions never start with '.').
      uint32_t directive = x86ParseDirective(token.data + 1, token.size - 1);

      if (directive == kX86DirectiveAlign) {
        if (tType != AsmToken::kU64)
          return DebugUtils::errored(kErrorInvalidState);

        if (tmp.u64 > std::numeric_limits<uint32_t>::max() || !Support::isPowerOf2(tmp.u64))
          return DebugUtils::errored(kErrorInvalidState);

        ASMJIT_PROPAGATE(_emitter->align(kAlignCode, uint32_t(tmp.u64)));

        tType = nextToken(&token);
        // Fall through as we would like to see EOL or EOF.
      }
      else if (directive >= kX86DirectiveDB && directive <= kX86DirectiveDQ) {
        if (tType != AsmToken::kU64)
          return DebugUtils::errored(kErrorInvalidState);

        uint32_t nBytes   = (directive == kX86DirectiveDB) ? 1 :
                            (directive == kX86DirectiveDW) ? 2 :
                            (directive == kX86DirectiveDD) ? 4 : 8;
        uint64_t maxValue = Support::lsbMask<uint64_t>(nBytes * 8);

        StringBuilderTmp<512> db;
        for (;;) {
          if (tType != AsmToken::kU64)
            return DebugUtils::errored(kErrorInvalidState);

          if (tmp.u64 > maxValue)
            return DebugUtils::errored(kErrorInvalidImmediate);

          db.appendString(reinterpret_cast<const char*>(tmp.valueBytes), nBytes);

          tType = nextToken(&tmp);
          if (tType != AsmToken::kComma)
            break;

          tType = nextToken(&tmp);
        }

        ASMJIT_PROPAGATE(_emitter->embed(db.data(), (uint32_t)db.size()));
      }
      else {
        return DebugUtils::errored(kErrorInvalidDirective);
      }
    }
    else {
      // Parse instruction.
      putTokenBack(&tmp);

      BaseInst inst;
      ASMJIT_PROPAGATE(x86ParseInstruction(*this, inst._id, inst._options, &token));

      // Parse operands.
      uint32_t count = 0;
      Operand_ operands[6];
      x86::Mem* memOp = nullptr;

      for (;;) {
        tType = nextToken(&token);

        // Instruction without operands...
        if ((tType == AsmToken::kNL || tType == AsmToken::kEnd) && count == 0)
          break;

        // Parse {AVX-512} options that act as operand (valid syntax).
        if (tType == AsmToken::kLCurl) {
          uint32_t kAllowed = x86::Inst::kOptionER     |
                              x86::Inst::kOptionSAE    |
                              x86::Inst::kOptionRN_SAE |
                              x86::Inst::kOptionRD_SAE |
                              x86::Inst::kOptionRU_SAE |
                              x86::Inst::kOptionRZ_SAE ;

          tType = nextToken(&tmp, AsmTokenizer::kParseSymbol | AsmTokenizer::kParseDashes);
          if (tType != AsmToken::kSym && tType != AsmToken::kNSym)
            return DebugUtils::errored(kErrorInvalidState);

          tType = nextToken(&token);
          if (tType != AsmToken::kRCurl)
            return DebugUtils::errored(kErrorInvalidState);

          uint32_t option = x86ParseAvx512Option(tmp.data, tmp.size);
          if (!option || (option & ~kAllowed) != 0)
            return DebugUtils::errored(kErrorInvalidOption);

          uint32_t& options = inst._options;
          if (options & option)
            return DebugUtils::errored(kErrorOptionAlreadyDefined);

          options |= option;
          tType = nextToken(&token);
        }
        else {
          if (count == ASMJIT_ARRAY_SIZE(operands))
            return DebugUtils::errored(kErrorInvalidInstruction);

          // Parse operand.
          ASMJIT_PROPAGATE(x86ParseOperand(*this, operands[count], &token));

          if (operands[count].isMem())
            memOp = static_cast<x86::Mem*>(&operands[count]);

          // Parse {AVX-512} option(s) immediately next to the operand.
          tType = nextToken(&token);
          if (tType == AsmToken::kLCurl) {
            uint32_t& options = inst._options;
            do {
              tType = nextToken(&tmp, AsmTokenizer::kParseSymbol | AsmTokenizer::kParseDashes);
              if (tType != AsmToken::kSym && tType != AsmToken::kNSym)
                return DebugUtils::errored(kErrorInvalidState);

              tType = nextToken(&token);
              if (tType != AsmToken::kRCurl)
                return DebugUtils::errored(kErrorInvalidState);

              uint32_t maskRegId = 0;
              uint32_t size = (uint32_t)tmp.size;
              const uint8_t* str = tmp.data;

              if (size == 2 && (str[0] == 'k' || str[1] == 'K') && (maskRegId = (str[1] - (uint8_t)'0')) < 8) {
                RegOnly& extraReg = inst._extraReg;
                if (count != 0)
                  return DebugUtils::errored(kErrorInvalidOption);

                if (!extraReg.isNone())
                  return DebugUtils::errored(kErrorOptionAlreadyDefined);

                extraReg.init(x86::KReg(maskRegId));
              }
              else if (size == 1 && (str[0] == 'z' || str[1] == 'Z')) {
                if (count != 0)
                  return DebugUtils::errored(kErrorInvalidOption);

                if (options & x86::Inst::kOptionZMask)
                  return DebugUtils::errored(kErrorOptionAlreadyDefined);

                options |= x86::Inst::kOptionZMask;
              }
              else {
                uint32_t option = x86ParseAvx512Option(str, size);
                if (option) {
                  if (options & option)
                    return DebugUtils::errored(kErrorOptionAlreadyDefined);
                  options |= option;
                }
                else {
                  uint32_t bcst = x86ParseAvx512Broadcast(str, size);
                  if (!bcst)
                    return DebugUtils::errored(kErrorInvalidOption);

                  if (bcst && (!memOp || memOp->hasBroadcast()))
                    return DebugUtils::errored(kErrorInvalidBroadcast);

                  memOp->setBroadcast(bcst);
                }
              }

              tType = nextToken(&token);
            } while (tType == AsmToken::kLCurl);
          }

          count++;
        }

        if (tType == AsmToken::kComma)
          continue;

        if (tType == AsmToken::kNL || tType == AsmToken::kEnd)
          break;

        return DebugUtils::errored(kErrorInvalidState);
      }

      ASMJIT_PROPAGATE(x86FixupInstruction(*this, inst, operands, count));
      ASMJIT_PROPAGATE(BaseInst::validate(_emitter->archId(), inst, operands, count));

      _emitter->setInstOptions(inst.options());
      _emitter->setExtraReg(inst.extraReg());
      ASMJIT_PROPAGATE(_emitter->emitOpArray(inst.id(), operands, count));
    }
  }

  if (tType == AsmToken::kNL)
    return kErrorOk;

  if (tType == AsmToken::kEnd) {
    _endOfInput = true;
    return kErrorOk;
  }

  return DebugUtils::errored(kErrorInvalidState);
}

} // asmtk namespace

```

`Avanguard/AsmJit/asmtk/asmparser.h`:

```h
// [AsmTk]
// Assembler toolkit based on AsmJit.
//
// [License]
// Zlib - See LICENSE.md file in the package.

// [Guard]
#ifndef _ASMTK_ASMPARSER_H
#define _ASMTK_ASMPARSER_H

// [Dependencies]
#include "./strtod.h"
#include "./asmtokenizer.h"

namespace asmtk {

// ============================================================================
// [asmtk::AsmParser]
// ============================================================================

//! Asm parser.
class AsmParser {
public:
  typedef Error (ASMJIT_CDECL* UnknownSymbolHandler)(AsmParser* parser, asmjit::Operand* out, const char* name, size_t size);

  AsmParser(asmjit::BaseEmitter* emitter) noexcept;
  ~AsmParser() noexcept;

  // --------------------------------------------------------------------------
  // [Accessors]
  // --------------------------------------------------------------------------

  inline asmjit::BaseEmitter* emitter() const noexcept { return _emitter; }

  // --------------------------------------------------------------------------
  // [Input]
  // --------------------------------------------------------------------------

  inline const char* input() const noexcept { return reinterpret_cast<const char*>(_tokenizer._input); }
  inline bool setInput(const char* input, size_t size = asmjit::Globals::kNullTerminated) noexcept {
    if (size == asmjit::Globals::kNullTerminated)
      size = ::strlen(input);

    _tokenizer.setInput(reinterpret_cast<const uint8_t*>(input), size);
    _currentCommandOffset = 0;
    _endOfInput = (size == 0);

    return _endOfInput;
  }

  inline bool isEndOfInput() const noexcept { return _endOfInput; }
  inline size_t currentCommandOffset() const noexcept { return _currentCommandOffset; }

  uint32_t nextToken(AsmToken* token, uint32_t flags = 0) noexcept;
  void putTokenBack(AsmToken* token) noexcept;

  // --------------------------------------------------------------------------
  // [UnknownSymbolHandler]
  // --------------------------------------------------------------------------

  inline UnknownSymbolHandler unknownSymbolHandler() const noexcept { return _unknownSymbolHandler; }
  inline void* unknownSymbolHandlerData() const noexcept { return _unknownSymbolHandlerData; }

  inline void setUnknownSymbolHandler(UnknownSymbolHandler handler, void* data = nullptr) noexcept {
    _unknownSymbolHandler = handler;
    _unknownSymbolHandlerData = data;
  }

  inline void resetUnknownSymbolHandler() {
    setUnknownSymbolHandler((UnknownSymbolHandler)nullptr, nullptr);
  }

  // --------------------------------------------------------------------------
  // [Parsing]
  // --------------------------------------------------------------------------

  //! Universal method that setups the input and then calls `parseLine()` until
  //! the end is reached. It returns `kErrorOk` on success (which means that all
  //! commands were parsed successfully), otherwise and error code describing
  //! the problem.
  Error parse(const char* input, size_t size = asmjit::Globals::kNullTerminated) noexcept;

  Error parseCommand() noexcept;

  // --------------------------------------------------------------------------
  // [Members]
  // --------------------------------------------------------------------------

  asmjit::BaseEmitter* _emitter;
  AsmTokenizer _tokenizer;

  size_t _currentCommandOffset;
  bool _endOfInput;

  UnknownSymbolHandler _unknownSymbolHandler;
  void* _unknownSymbolHandlerData;
};

} // asmtk namespace

// [Guard]
#endif // _ASMTK_ASMPARSER_H

```

`Avanguard/AsmJit/asmtk/asmtk.h`:

```h
// [AsmTk]
// Assembler toolkit based on AsmJit.
//
// [License]
// Zlib - See LICENSE.md file in the package.

// [Guard]
#ifndef _ASMTK_ASMTK_H
#define _ASMTK_ASMTK_H

// [Dependencies]
#include "./globals.h"

#include "./asmparser.h"
#include "./asmtokenizer.h"
#include "./elfdefs.h"

// [Guard]
#endif // _ASMTK_ASMTK_H

```

`Avanguard/AsmJit/asmtk/asmtokenizer.cpp`:

```cpp
// [AsmTk]
// Assembler toolkit based on AsmJit.
//
// [License]
// Zlib - See LICENSE.md file in the package.

#include "stdafx.h"

// [Dependencies]
#include "./asmtokenizer.h"

namespace asmtk {

// ============================================================================
// [asmtk::CharKind / CharMap]
// ============================================================================

enum CharKind : uint32_t {
  // Digit [0-9], HEX [A-F] and the remaining ASCII [G-Z].
  kChar0x0, kChar0x1, kChar0x2, kChar0x3, kChar0x4, kChar0x5, kChar0x6, kChar0x7,
  kChar0x8, kChar0x9, kChar0xA, kChar0xB, kChar0xC, kChar0xD, kChar0xE, kChar0xF,
  kCharAxG, kCharAxH, kCharAxI, kCharAxJ, kCharAxK, kCharAxL, kCharAxM, kCharAxN,
  kCharAxO, kCharAxP, kCharAxQ, kCharAxR, kCharAxS, kCharAxT, kCharAxU, kCharAxV,
  kCharAxW, kCharAxX, kCharAxY, kCharAxZ,

  kCharUnd, // Underscore
  kCharSym, // Special characters that can be considered a symbol [$@_].
  kCharUsd, // Dollar sign.
  kCharDsh, // Dash.
  kCharPcn, // Punctuation.
  kCharSpc, // Space.
  kCharExt, // Extended ASCII character (0x80 and above), acts as non-recognized.
  kCharInv  // Invalid (non-recognized) character.
};

#define C(ID) uint8_t(kChar##ID)
static const uint8_t CharMap[] = {
  C(Inv), C(Inv), C(Inv), C(Inv), C(Inv), C(Inv), C(Inv), C(Inv), // 000-007 ........ | All invalid.
  C(Inv), C(Spc), C(Spc), C(Spc), C(Spc), C(Spc), C(Inv), C(Inv), // 008-015 .     .. | Spaces 0x9-0xD.
  C(Inv), C(Inv), C(Inv), C(Inv), C(Inv), C(Inv), C(Inv), C(Inv), // 016-023 ........ | All invalid.
  C(Inv), C(Inv), C(Inv), C(Inv), C(Inv), C(Inv), C(Inv), C(Inv), // 024-031 ........ | All invalid.
  C(Spc), C(Pcn), C(Pcn), C(Pcn), C(Usd), C(Pcn), C(Pcn), C(Pcn), // 032-039  !"#$%&' |
  C(Pcn), C(Pcn), C(Pcn), C(Pcn), C(Pcn), C(Dsh), C(Pcn), C(Pcn), // 040-047 ()*+,-./ |
  C(0x0), C(0x1), C(0x2), C(0x3), C(0x4), C(0x5), C(0x6), C(0x7), // 048-055 01234567 |
  C(0x8), C(0x9), C(Pcn), C(Pcn), C(Pcn), C(Pcn), C(Pcn), C(Pcn), // 056-063 89:;<=>? |
  C(Sym), C(0xA), C(0xB), C(0xC), C(0xD), C(0xE), C(0xF), C(AxG), // 064-071 @ABCDEFG |
  C(AxH), C(AxI), C(AxJ), C(AxK), C(AxL), C(AxM), C(AxN), C(AxO), // 072-079 HIJKLMNO |
  C(AxP), C(AxQ), C(AxR), C(AxS), C(AxT), C(AxU), C(AxV), C(AxW), // 080-087 PQRSTUVW |
  C(AxX), C(AxY), C(AxZ), C(Pcn), C(Pcn), C(Pcn), C(Pcn), C(Und), // 088-095 XYZ[\]^_ |
  C(Pcn), C(0xA), C(0xB), C(0xC), C(0xD), C(0xE), C(0xF), C(AxG), // 096-103 `abcdefg |
  C(AxH), C(AxI), C(AxJ), C(AxK), C(AxL), C(AxM), C(AxN), C(AxO), // 104-111 hijklmno |
  C(AxP), C(AxQ), C(AxR), C(AxS), C(AxT), C(AxU), C(AxV), C(AxW), // 112-119 pqrstuvw |
  C(AxX), C(AxY), C(AxZ), C(Pcn), C(Pcn), C(Pcn), C(Pcn), C(Inv), // 120-127 xyz{|}~  |
  C(Ext), C(Ext), C(Ext), C(Ext), C(Ext), C(Ext), C(Ext), C(Ext), // 128-135 ........ | Extended.
  C(Ext), C(Ext), C(Ext), C(Ext), C(Ext), C(Ext), C(Ext), C(Ext), // 136-143 ........ |
  C(Ext), C(Ext), C(Ext), C(Ext), C(Ext), C(Ext), C(Ext), C(Ext), // 144-151 ........ |
  C(Ext), C(Ext), C(Ext), C(Ext), C(Ext), C(Ext), C(Ext), C(Ext), // 152-159 ........ |
  C(Ext), C(Ext), C(Ext), C(Ext), C(Ext), C(Ext), C(Ext), C(Ext), // 160-167 ........ |
  C(Ext), C(Ext), C(Ext), C(Ext), C(Ext), C(Ext), C(Ext), C(Ext), // 168-175 ........ |
  C(Ext), C(Ext), C(Ext), C(Ext), C(Ext), C(Ext), C(Ext), C(Ext), // 176-183 ........ |
  C(Ext), C(Ext), C(Ext), C(Ext), C(Ext), C(Ext), C(Ext), C(Ext), // 184-191 ........ |
  C(Ext), C(Ext), C(Ext), C(Ext), C(Ext), C(Ext), C(Ext), C(Ext), // 192-199 ........ |
  C(Ext), C(Ext), C(Ext), C(Ext), C(Ext), C(Ext), C(Ext), C(Ext), // 200-207 ........ |
  C(Ext), C(Ext), C(Ext), C(Ext), C(Ext), C(Ext), C(Ext), C(Ext), // 208-215 ........ |
  C(Ext), C(Ext), C(Ext), C(Ext), C(Ext), C(Ext), C(Ext), C(Ext), // 216-223 ........ |
  C(Ext), C(Ext), C(Ext), C(Ext), C(Ext), C(Ext), C(Ext), C(Ext), // 224-231 ........ |
  C(Ext), C(Ext), C(Ext), C(Ext), C(Ext), C(Ext), C(Ext), C(Ext), // 232-239 ........ |
  C(Ext), C(Ext), C(Ext), C(Ext), C(Ext), C(Ext), C(Ext), C(Ext), // 240-247 ........ |
  C(Ext), C(Ext), C(Ext), C(Ext), C(Ext), C(Ext), C(Ext), C(Ext)  // 248-255 ........ |
};
#undef C

// ============================================================================
// [asmtk::AsmTokenizer]
// ============================================================================

AsmTokenizer::AsmTokenizer()
  : _input(NULL),
    _end(NULL),
    _cur(NULL),
    _stodctx() {}

uint32_t AsmTokenizer::next(AsmToken* token, uint32_t flags) {
  const uint8_t* cur = _cur;
  const uint8_t* end = _end;

  // Skip spaces.
  const uint8_t* start = cur;
  if (cur == end)
    return token->setData(AsmToken::kEnd, start, cur);

  uint32_t c = cur[0];
  uint32_t m = CharMap[c];

  // --------------------------------------------------------------------------
  // [Whitespaces]
  // --------------------------------------------------------------------------

  if (m == kCharSpc) {
    do {
      cur++;
      if (c == '\n') goto NL;
      if (cur == end) goto End;

      c = cur[0];
      m = CharMap[c];
    } while (m == kCharSpc);
  }

  // --------------------------------------------------------------------------
  // [Comment]
  // --------------------------------------------------------------------------

  if (c == ';') {
    for (;;) {
      if (++cur == end)
        goto End;
      c = cur[0];
      if (c == '\n')
        goto NL;
    }
  }

  // The beginning of the token.
  start = cur;

  // --------------------------------------------------------------------------
  // [Prefixes]
  // --------------------------------------------------------------------------

  if (c == '$') {
    if (++cur == end) {
      _cur = cur;
      return token->setData(AsmToken::kSym, start, cur);
    }

    flags |= kStateDollarPrefix;
    c = cur[0];
    m = CharMap[c];
  }
  else if (c == '.') {
    if (++cur == end) {
      _cur = cur;
      return token->setData(AsmToken::kInvalid, start, cur);
    }

    flags |= kStateDotPrefix;
    c = cur[0];
    m = CharMap[c];
  }

  // --------------------------------------------------------------------------
  // [Number]
  // --------------------------------------------------------------------------

  // Only parse numbers if we are not forced to always parse numbers as symbols.
  if (!(flags & (kParseSymbol | kStateDotPrefix))) {
    // The number either starts with [0..9], which could contain an optional
    // [0x|0b] prefixes, or $[0-9], which is a hexadecimal prefix as well.
    if (m <= kChar0x9) {
      uint64_t val = m;
      uint32_t base = 10;
      uint32_t shift = 0;

      if (++cur == end) {
        _cur = cur;
        token->u64 = val;
        return token->setData(AsmToken::kU64, start, cur);
      }

      // Parse a binary or hexadecimal number prefixed by [$|0x|0b].
      c = cur[0];
      m = CharMap[c];

      if (val == 0 || (flags & kStateDollarPrefix) != 0) {
        if (flags & kStateDollarPrefix) {
          // Hexadecimal number.
          base = 16;
          shift = 4;
          flags |= kStateNumberPrefix;
        }
        else {
          // Parse 'b' or 'x'.
          if (m == kChar0xB || m == kCharAxX) {
            base = 16;
            shift = 4;
            flags |= kStateNumberPrefix;

            if (m == kChar0xB) {
              base = 2;
              shift = 1;
            }

            // There must be at least one valid digit.
            if (++cur == end)
              goto Invalid;

            c = cur[0];
            m = CharMap[c];
          }
          else {
            // Octal number if there is no prefix.
            base = 8;
            shift = 3;
            goto ParseDigits;
          }

          if (m >= base)
            goto Invalid;
        }

        while (m < base) {
          val = (val << shift) | m;
          if (++cur == end) break;

          c = cur[0];
          m = CharMap[c];
        }

        if (cur != end && m <= kCharUnd)
          goto Invalid;

        _cur = cur;
        token->u64 = val;
        return token->setData(AsmToken::kU64, start, cur);
      }

      // Parse a decimal number or prepare for parsing a binary/octal/hexadecimal
      // number if a suffix follows. Since we parse suffix at the end we perform
      // decimal parsing now.
ParseDigits:
      {
        uint32_t highestDigit = uint32_t(val);

        for (;;) {
          c -= uint32_t('0');
          if (c < 10) {
            val = val * 10 + c;
            highestDigit = std::max<uint32_t>(highestDigit, c);

            if (++cur == end)
              break;
            c = cur[0];
            continue;
          }
          m = CharMap[c + uint32_t('0')];

          if (m <= kChar0xF) {
            // Parse an optional 'b' suffix (otherwise it's a hexadecimal number).
            if (m == 0xB && highestDigit <= 1) {
              if (++cur != end) {
                c = cur[0];
                m = CharMap[c];
                if (m <= kChar0xF)
                  goto ParseHex;
              }

              base = 2;
              shift = 1;
              flags |= kStateNumberSuffix;
            }
            else {
ParseHex:
              highestDigit = 0xF;

              while (++cur != end) {
                c = cur[0];
                m = CharMap[c];
                if (m > kChar0xF)
                  break;
              }
            }
          }
          break;
        }

        if (cur != end && m <= kCharUnd) {
          // Parse optional [h|o|q] suffixes.
          if (m == kCharAxH) {
            base = 16;
            shift = 4;

            cur++;
            flags |= kStateNumberSuffix;
          }
          else if (m == kCharAxO || m == kCharAxQ) {
            base = 8;
            shift = 3;

            cur++;
            flags |= kStateNumberSuffix;
          }
          else {
            goto Invalid;
          }

          if (cur != end) {
            c = cur[0];
            m = CharMap[c];

            if (m <= kCharUnd)
              goto Invalid;
          }
        }

        if (highestDigit >= base)
          goto Invalid;

        if (base != 10) {
          const uint8_t* altCur = start;
          const uint8_t* altEnd = cur - ((flags & kStateNumberSuffix) != 0);

          val = 0;
          while (altCur != altEnd) {
            val <<= shift;
            val += CharMap[*altCur++];
          }
        }
      }

      _cur = cur;
      token->u64 = val;
      return token->setData(AsmToken::kU64, start, cur);
    }
  }

  // --------------------------------------------------------------------------
  // [Symbol]
  // --------------------------------------------------------------------------

  if (m <= kCharUsd) {
    uint32_t mSymMax = flags & kParseDashes ? kCharDsh : kCharUsd;

    while (++cur != end) {
      c = cur[0];
      m = CharMap[c];

      if (m <= mSymMax)
        continue;

      break;
    }

    _cur = cur;
    return token->setData(AsmToken::kSym, start, cur);
  }

  // --------------------------------------------------------------------------
  // [Parse Punctuation]
  // --------------------------------------------------------------------------

  if (m <= kCharPcn) {
    uint32_t type = AsmToken::kOther;
    switch (c) {
      case '{': type = AsmToken::kLCurl   ; break;
      case '}': type = AsmToken::kRCurl   ; break;
      case '[': type = AsmToken::kLBracket; break;
      case ']': type = AsmToken::kRBracket; break;
      case '(': type = AsmToken::kLParen  ; break;
      case ')': type = AsmToken::kRParen  ; break;
      case '+': type = AsmToken::kAdd     ; break;
      case '-': type = AsmToken::kSub     ; break;
      case '*': type = AsmToken::kMul     ; break;
      case '/': type = AsmToken::kDiv     ; break;
      case ',': type = AsmToken::kComma   ; break;
      case ':': type = AsmToken::kColon   ; break;
    }
    _cur = ++cur;
    return token->setData(type, start, cur);
  }

Invalid:
  _cur = cur;
  return token->setData(AsmToken::kInvalid, start, cur);

NL:
  _cur = cur;
  return token->setData(AsmToken::kNL, start, cur);

End:
  _cur = cur;
  return token->setData(AsmToken::kEnd, start, cur);
}

} // asmtk namespace

```

`Avanguard/AsmJit/asmtk/asmtokenizer.h`:

```h
// [AsmTk]
// Assembler toolkit based on AsmJit.
//
// [License]
// Zlib - See LICENSE.md file in the package.

// [Guard]
#ifndef _ASMTK_ASMTOKENIZER_H
#define _ASMTK_ASMTOKENIZER_H

// [Dependencies]
#include "./globals.h"
#include "./strtod.h"

namespace asmtk {

// ============================================================================
// [asmtk::AsmToken]
// ============================================================================

struct AsmToken {
  enum Type : uint32_t {
    kEnd,
    kNL,
    kSym,
    kNSym,
    kU64,
    kF64,
    kLCurl,
    kRCurl,
    kLBracket,
    kRBracket,
    kLParen,
    kRParen,
    kAdd,
    kSub,
    kMul,
    kDiv,
    kComma,
    kColon,
    kOther,
    kInvalid
  };

  inline bool is(char c0) {
    return size == 1 && data[0] == c0;
  }
  inline bool is(char c0, char c1) {
    return size == 2 && data[0] == c0 && data[1] == c1;
  }
  inline bool is(char c0, char c1, char c2) {
    return size == 3 && data[0] == c0 && data[1] == c1 && data[2] == c2;
  }
  inline bool is(char c0, char c1, char c2, char c3) {
    return size == 4 && data[0] == c0 && data[1] == c1 && data[2] == c2 && data[3] == c3;
  }
  inline bool is(char c0, char c1, char c2, char c3, char c4) {
    return size == 5 && data[0] == c0 && data[1] == c1 && data[2] == c2 && data[3] == c3 && data[4] == c4;
  }

  inline void reset() {
    type = kEnd;
    data = nullptr;
    size = 0;
    u64 = 0;
  }

  inline uint32_t setData(uint32_t type, const uint8_t* data, size_t size) {
    this->data = data;
    this->size = size;
    this->type = type;
    return type;
  }

  inline uint32_t setData(uint32_t type, const uint8_t* data, const uint8_t* end) {
    return setData(type, data, (size_t)(end - data));
  }

  uint32_t type;
  const uint8_t* data;
  size_t size;

  union {
    double f64;
    int64_t i64;
    uint64_t u64;
    uint8_t valueBytes[8];
  };
};

// ============================================================================
// [asmtk::AsmTokenizer]
// ============================================================================

class AsmTokenizer {
public:
  //! Tokenizer options.
  enum ParseFlags : uint32_t {
    kParseSymbol          = 0x00000001U, //!< Don't attempt to parse number (always parse symbol).
    kParseDashes          = 0x00000002U  //!< Consider dashes as text in a parsed symbol.
  };

  //! Flags used during tokenization (cannot be used as options).
  enum StateFlags : uint32_t {
    kStateDotPrefix       = 0x10000000U, //!< Parsed '.' prefix.
    kStateDollarPrefix    = 0x20000000U, //!< Parsed '$' prefix.
    kStateNumberPrefix    = 0x40000000U, //!< Parsed number prefix [0b|0x].
    kStateNumberSuffix    = 0x80000000U  //!< Parsed number suffix [b|o|q|h].
  };

  AsmTokenizer();
  uint32_t next(AsmToken* token, uint32_t flags = 0);
  inline void putBack(AsmToken* token) { _cur = token->data; }

  inline void setInput(const uint8_t* input, size_t size) {
    _input = input;
    _end = input + size;
    _cur = input;
  }

  const uint8_t* _input;
  const uint8_t* _end;
  const uint8_t* _cur;

  StrToD _stodctx;
};

} // asmtk namespace

// [Guard]
#endif // _ASMTK_ASMTOKENIZER_H

```

`Avanguard/AsmJit/asmtk/elfdefs.h`:

```h
// [AsmTk]
// Assembler toolkit based on AsmJit.
//
// [License]
// Zlib - See LICENSE.md file in the package.

// [Guard]
#ifndef _ASMTK_ELFDEFS_H
#define _ASMTK_ELFDEFS_H

// [Dependencies]
#include "./globals.h"

namespace asmtk {

enum ElfFileType : uint32_t {
  kElfFileType_NONE         = 0,
  kElfFileType_REL          = 1,
  kElfFileType_EXEC         = 2,
  kElfFileType_DYN          = 3,
  kElfFileType_CORE         = 4,
  kElfFileType_LOPROC       = 0xFF00,
  kElfFileType_HIPROC       = 0xFFFF
};

enum ElfFileVersion : uint32_t {
  kElfFileVersion_NONE      = 0,
  kElfFileVersion_CURRENT   = 1
};

enum ElfFileClass : uint32_t {
  kElfFileClass_NONE        = 0,
  kElfFileClass_32          = 1,
  kElfFileClass_64          = 2
};

enum ElfFileEncoding : uint32_t {
  ElfFileEncoding_NONE      = 0,
  ElfFileEncoding_LE        = 1,
  ElfFileEncoding_BE        = 2
};

enum ElfMachineType : uint32_t {
  kElfMachineType_NONE      = 0,
  kElfMachineType_X86       = 3,
  kElfMachineType_ARM       = 40,
  kElfMachineType_X86_64    = 62
};

enum ElfOSABI : uint32_t {
  kElfOSABI_NONE            = 0,         //!< UNIX System V ABI.
  kElfOSABI_HPUX            = 1,
  kElfOSABI_NETBSD          = 2,
  kElfOSABI_GNU             = 3,         //!< GNU/Linux.
  kElfOSABI_HURD            = 4,
  kElfOSABI_SOLARIS         = 6,
  kElfOSABI_AIX             = 7,
  kElfOSABI_IRIX            = 8,
  kElfOSABI_FREEBSD         = 9,
  kElfOSABI_TRU64           = 10,
  kElfOSABI_MODESTO         = 11,
  kElfOSABI_OPENBSD         = 12,
  kElfOSABI_OPENVMS         = 13,
  kElfOSABI_NSK             = 14,
  kElfOSABI_AROS            = 15,
  kElfOSABI_FENIXOS         = 16,
  kElfOSABI_CLOUDABI        = 17,
  kElfOSABI_ARM             = 97,
  kElfOSABI_STANDALONE      = 255
};

struct ElfIdentData {
  uint8_t magic[4];
  uint8_t classType;
  uint8_t dataType;
  uint8_t version;
  uint8_t abi;
  uint8_t abiVersion;
  uint8_t reserved[7];
};

template<typename ElfPtrT>
struct ElfFileData {
  ElfIdentData ident;
  uint16_t type;
  uint16_t machine;
  uint32_t version;
  ElfPtrT entry;
  ElfPtrT phOffset;
  ElfPtrT shOffset;
  uint32_t flags;
  uint16_t ehSize;
  uint16_t phEntSize;
  uint16_t phNum;
  uint16_t shEndSize;
  uint16_t shNum;
  uint16_t shStrNdx;
};

typedef ElfFileData<uint32_t> ElfFileData32;
typedef ElfFileData<uint64_t> ElfFileData64;

template<typename ElfPtrT>
struct ElfProgramData {};

template<>
struct ElfProgramData<uint32_t> {
  uint32_t type;     //!< Segment type.
  uint32_t offset;   //!< Segment offset.
  uint32_t vaddr;    //!< Virtual address.
  uint32_t paddr;    //!< Physical address.
  uint32_t fileSize; //!< Size of file image (or zero).
  uint32_t memSize;  //!< Size of memory image (or zero).
  uint32_t flags;    //!< Segment flags.
  uint32_t align;    //!< Segment alignment.
};

template<>
struct ElfProgramData<uint64_t> {
  uint32_t type;     //!< Segment type.
  uint32_t flags;    //!< Segment flags.
  uint64_t offset;   //!< Segment offset.
  uint64_t vaddr;    //!< Virtual address.
  uint64_t paddr;    //!< Physical address.
  uint64_t fileSize; //!< Size of file image (or zero).
  uint64_t memSize;  //!< Size of memory image (or zero).
  uint64_t align;    //!< Segment alignment.
};

typedef ElfProgramData<uint32_t> ElfProgramData32;
typedef ElfProgramData<uint64_t> ElfProgramData64;

template<typename ElfPtrT>
struct ElfSectionData {
  uint32_t name;     //!< Section name (index).
  uint32_t type;     //!< Section type.
  ElfPtrT flags;     //!< Section flags.
  ElfPtrT addr;      //!< Section address.
  ElfPtrT offset;    //!< Section file-offset.
  ElfPtrT size;      //!< Section size.
  uint32_t link;
  uint32_t info;
  ElfPtrT addrAlign;
  ElfPtrT entSize;
};
typedef ElfSectionData<uint32_t> ElfSectionData32;
typedef ElfSectionData<uint64_t> ElfSectionData64;

template<typename ElfPtrT>
struct ElfSymbolData {};

template<>
struct ElfSymbolData<uint32_t> {
  uint32_t name;     //!< Symbol name (index).
  uint32_t value;    //!< Symbol address.
  uint32_t size;     //!< Symbol size.
  uint8_t info;      //!< Symbol information.
  uint8_t reserved;  //!< Reserved (zero).
  uint16_t shndx;    //!< Section index.
};

template<>
struct ElfSymbolData<uint64_t> {
  uint32_t name;     //!< Symbol name (index).
  uint8_t info;      //!< Symbol information.
  uint8_t other;     //!< Reserved (zero).
  uint16_t shndx;    //!< Section index.
  uint64_t value;    //!< Symbol address.
  uint64_t size;     //!< Symbol size.
};

typedef ElfSymbolData<uint32_t> ElfSymbolData32;
typedef ElfSymbolData<uint64_t> ElfSymbolData64;

} // asmtk namespace

// [Guard]
#endif // _ASMTK_ELFDEFS_H

```

`Avanguard/AsmJit/asmtk/globals.h`:

```h
// [AsmTk]
// Assembler toolkit based on AsmJit.
//
// [License]
// Zlib - See LICENSE.md file in the package.

// [Guard]
#ifndef _ASMTK_GLOBALS_H
#define _ASMTK_GLOBALS_H

#include <asmjit/asmjit.h>

#include <stdint.h>
#include <algorithm>
#include <cstdlib>
#include <cstring>

namespace asmtk {

// ============================================================================
// [asmtk::Types]
// ============================================================================


using asmjit::Error;

} // asmtk namespace

// [Guard]
#endif // _ASMTK_GLOBALS_H

```

`Avanguard/AsmJit/asmtk/parserutils.h`:

```h
// [AsmTk]
// Assembler toolkit based on AsmJit.
//
// [License]
// Zlib - See LICENSE.md file in the package.

// [Guard]
#ifndef _ASMTK_PARSERUTILS_H
#define _ASMTK_PARSERUTILS_H

#include <asmjit/asmjit.h>

#include <stdint.h>
#include <algorithm>
#include <cstdlib>
#include <cstring>

namespace asmtk {
namespace ParserUtils {

// ============================================================================
// [asmtk::ParserUtils::WordParser]
// ============================================================================

class WordParser {
public:
  #if ASMJIT_ARCH_BITS == 32
  typedef uint32_t Value;
  #else
  typedef uint64_t Value;
  #endif

  static constexpr uint32_t kNumValues =
    uint32_t((8 + sizeof(Value) - 1) / sizeof(Value));

  constexpr WordParser() noexcept
    : _value { 0 } {}

  inline void reset() noexcept {
    for (size_t i = 0; i < ASMJIT_ARRAY_SIZE(_value); i++)
      _value[i] = 0;
  }

  template<typename T>
  inline void addChar(const T* input, size_t i) noexcept {
    size_t nIndex = i / sizeof(Value);
    size_t nByte  = i % sizeof(Value);
    _value[nIndex] |= Value(uint8_t(input[i])) << (nByte * 8U);
  }

  template<typename T>
  inline void addLowercasedChar(const T* input, size_t i) noexcept {
    size_t nIndex = i / sizeof(Value);
    size_t nByte  = i % sizeof(Value);
    _value[nIndex] |= Value(asmjit::Support::asciiToLower(uint8_t(input[i]))) << (nByte * 8U);
  }

  inline bool test(char x0, char x1 = '\0', char x2 = '\0', char x3 = '\0') const noexcept {
    uint32_t pattern0 = (uint32_t(uint8_t(x0)) <<  0) |
                        (uint32_t(uint8_t(x1)) <<  8) |
                        (uint32_t(uint8_t(x2)) << 16) |
                        (uint32_t(uint8_t(x3)) << 24) ;
    return uint32_t(_value[0] & 0xFFFFFFFFU) == pattern0;
  }

  inline bool test(char x0, char x1, char x2, char x3,
                   char x4, char x5 = '\0', char x6 = '\0', char x7 = '\0') const noexcept {
    uint32_t pattern0 = (uint32_t(uint8_t(x0)) <<  0) |
                        (uint32_t(uint8_t(x1)) <<  8) |
                        (uint32_t(uint8_t(x2)) << 16) |
                        (uint32_t(uint8_t(x3)) << 24) ;
    uint32_t pattern1 = (uint32_t(uint8_t(x4)) <<  0) |
                        (uint32_t(uint8_t(x5)) <<  8) |
                        (uint32_t(uint8_t(x6)) << 16) |
                        (uint32_t(uint8_t(x7)) << 24) ;
    #if ASMJIT_ARCH_BITS == 32
    return (_value[0] == pattern0) &
           (_value[1] == pattern1) ;
    #else
    return (_value[0] == (uint64_t(pattern0) | (uint64_t(pattern1) << 32)));
    #endif
  }

  Value _value[kNumValues];
};

} // ParserUtils
} // asmtk namespace

// [Guard]
#endif // _ASMTK_PARSERUTILS_H

```

`Avanguard/AsmJit/asmtk/strtod.h`:

```h
// [AsmTk]
// Assembler toolkit based on AsmJit.
//
// [License]
// Zlib - See LICENSE.md file in the package.

// [Guard]
#ifndef _ASMTK_STRTOD_H
#define _ASMTK_STRTOD_H

// [Dependencies]
#include "./globals.h"

#if ASMJIT_OS_WINDOWS
  #define ASMTK_STRTOD_MSLOCALE
  #include <locale.h>
  #include <stdlib.h>
#else
  #define ASMTK_STRTOD_XLOCALE
  #include <locale.h>
  #include <stdlib.h>
  #if ASMJIT_OS_BSD || ASMJIT_OS_MAC
    // xlocale.h is not available on Linux anymore, it uses <locale.h>.
    #include <xlocale.h>
  #endif
#endif

namespace asmtk {

// ============================================================================
// [asmtk::StrToD]
// ============================================================================

class StrToD {
public:
#if defined(ASMTK_STRTOD_MSLOCALE)
  inline StrToD() { handle = _create_locale(LC_ALL, "C"); }
  inline ~StrToD() { _free_locale(handle); }

  inline bool isOk() const { return handle != NULL; }
  inline double conv(const char* s, char** end) const { return _strtod_l(s, end, handle); }

  _locale_t handle;
#elif defined(ASMTK_STRTOD_XLOCALE)
  inline StrToD() { handle = newlocale(LC_ALL_MASK, "C", NULL); }
  inline ~StrToD() { freelocale(handle); }

  inline bool isOk() const { return handle != NULL; }
  inline double conv(const char* s, char** end) const { return strtod_l(s, end, handle); }

  locale_t handle;
#else
  // Time bomb!
  inline bool isOk() const { return true; }
  inline double conv(const char* s, char** end) const { return strtod(s, end); }
#endif
};

} // asmtk namespace

// [Guard]
#endif // _ASMTK_STRTOD_H

```

`Avanguard/Avanguard.cpp`:

```cpp
#include "stdafx.h"

#include <functional>
#include <clocale>

#include "AvnDefinitions.h"
#include "AntiMacros.h"
#include "ThreadsFilter.h"
#include "ModulesFilter.h"
#include "PEAnalyzer.h"
#include "ModulesCallbacks.h"
#include "ModulesStorage.h"
#include "MemoryCallbacks.h"
#include "CheckHook.h"
#include "ProcessAPI.h"
#include "PebTeb.h"
#include "Mitigations.h"
#include "AppInitDlls.h"
#include "WinTrusted.h"
#include "ApcDispatcher.h"
#include "DACL.h"
#include "ModulesUtils.h"
#include "ContextFilter.h"
#include "HWIDsUtils.h"
#include "ThreatElimination.h"
#include "Remapping.h"
#include "HandlesKeeper.h"

#include "SfcWrapper.h"

#include "HoShiMin's API\\StringsAPI.h"
#include "HoShiMin's API\\DisasmHelper.h"
#include "HoShiMin's API\\JitHelper.h"

#include <intrin.h>

#ifdef SELF_REMAPPING
// Be ready for self-remapping code:
#pragma comment(linker, "/ALIGN:65536")
#endif

#include "AvnApi.h"
extern AVN_API AvnApi;
extern VOID AvnInitializeApi();
extern "C" __declspec(dllexport) const PAVN_API Stub = &AvnApi;

BOOL IsAvnStarted = FALSE;
BOOL IsAvnStaticLoaded = FALSE;

#ifdef DEBUG_OUTPUT
static HANDLE hLog = CreateFile(XORSTR(L"AvnLog.log"), FILE_WRITE_ACCESS, FILE_SHARE_READ | FILE_SHARE_WRITE, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);

void Log(const std::wstring& Text) {
    if (hLog == INVALID_HANDLE_VALUE) return;

    static BOOL Initialized = FALSE;
    static CRITICAL_SECTION CriticalSection;
    if (!Initialized) {
        InitializeCriticalSectionAndSpinCount(&CriticalSection, 0xC0000000);
        Initialized = TRUE;
    }

    int size = sizeof(std::wstring::value_type);
    std::wstring ToWrite = XORSTR(L"[PID: ") + ValToWideStr(GetCurrentProcessId()) + XORSTR(L"] ") + Text + L"\r\n";

    EnterCriticalSection(&CriticalSection);
    DWORD BytesWritten;
    WriteFile(hLog, ToWrite.c_str(), (DWORD)ToWrite.length() * sizeof(std::wstring::value_type), &BytesWritten, NULL);
    FlushFileBuffers(hLog);
    LeaveCriticalSection(&CriticalSection);
}

VOID DisassembleAndLog(PVOID Address, BYTE InstructionsCount) {
    disassemble([](void* Code, void* Address, unsigned int InstructionLength, char* Disassembly) -> bool {
        std::wstring Bytes;
        for (unsigned int i = 0; i < InstructionLength; i++) {
            Bytes += ValToWideHex(*((PBYTE)Code + i), 2, FALSE);
            if (i != InstructionLength - 1) Bytes += L" ";
        }
        Bytes = FillRightWide(Bytes, 22, L' ');
        Log(L"\t\t" + ValToWideHex(Address, 16) + L"\t" + Bytes + L"\t" + AnsiToWide(Disassembly));
        return true;
    }, Address, Address, InstructionsCount);
}
#else
#define Log(Argument) UNREFERENCED_PARAMETER(Argument)
#define DisassembleAndLog(Address, InstructionsCount)
#endif

#ifdef SELF_REMAPPING
VOID RemapAvnExecutableSections() {
    const BOOL Status = RemapModule(hModules::hCurrent(), TRUE);
    Log(Status ? XORSTR(L"[v] Module successfully remapped") : XORSTR(L"[x] Unable to remap module!"));
}
#endif

#ifdef TIMERED_CHECKINGS
typedef NTSTATUS(NTAPI *_RtlCreateTimerQueue)(
    _Out_ PHANDLE TimerQueueHandle
    );

typedef NTSTATUS(NTAPI *_RtlDeleteTimerQueue)(
    _In_ HANDLE TimerQueueHandle
    );

typedef NTSTATUS(NTAPI *_RtlCreateTimer)(
    _In_ HANDLE 	TimerQueueHandle,
    _Out_ PHANDLE 	Handle,
    _In_ WAITORTIMERCALLBACKFUNC Function,
    _In_ PVOID 	Context,
    _In_ DWORD 	DueTime,
    _In_ DWORD 	Period,
    _In_ ULONG 	Flags
    );


typedef NTSTATUS(NTAPI *_RtlDeleteTimer)(
    _In_ HANDLE TimerQueueHandle,
    _In_ HANDLE TimerHandle,
    _In_ HANDLE CompletionEvent
    );

const _RtlCreateTimerQueue RtlCreateTimerQueue = (_RtlCreateTimerQueue)hModules::QueryAddress(hModules::hNtdll(), "RtlCreateTimerQueue");
const _RtlDeleteTimerQueue RtlDeleteTimerQueue = (_RtlDeleteTimerQueue)hModules::QueryAddress(hModules::hNtdll(), "RtlDeleteTimerQueue");
const _RtlCreateTimer RtlCreateTimer = (_RtlCreateTimer)hModules::QueryAddress(hModules::hNtdll(), "RtlCreateTimer");
const _RtlDeleteTimer RtlDeleteTimer = (_RtlDeleteTimer)hModules::QueryAddress(hModules::hNtdll(), "RtlDeleteTimer");
#endif

#ifdef THREADS_FILTER
static PVOID RestrictedAddresses[] = {
    hModules::QueryAddress(hModules::hNtdll(), XORSTR("LdrLoadDll")),
    hModules::QueryAddress(hModules::hKernel32(), XORSTR("LoadLibraryA")),
    hModules::QueryAddress(hModules::hKernel32(), XORSTR("LoadLibraryW")),
    hModules::QueryAddress(hModules::hKernel32(), XORSTR("LoadLibraryExA")),
    hModules::QueryAddress(hModules::hKernel32(), XORSTR("LoadLibraryExW")),
    hModules::QueryAddress(hModules::hKernelBase(), XORSTR("LoadLibraryA")),
    hModules::QueryAddress(hModules::hKernelBase(), XORSTR("LoadLibraryW")),
    hModules::QueryAddress(hModules::hKernelBase(), XORSTR("LoadLibraryExA")),
    hModules::QueryAddress(hModules::hKernelBase(), XORSTR("LoadLibraryExW"))
};

BOOL IsThreadAllowed(PVOID EntryPoint) {
    HMODULE hModule = GetModuleBase(EntryPoint);

    if (hModule != NULL) {
        if (hModule == hModules::hNtdll() ||
            hModule == hModules::hKernel32() ||
            hModule == hModules::hKernelBase()
            ) {
            for (PVOID Address : RestrictedAddresses)
                if (Address == EntryPoint) return FALSE;
        }
#ifdef MODULES_FILTER
        return ValidModulesStorage.IsModuleInStorage(hModule);
#else
        return TRUE;
#endif
    }
#ifdef MEMORY_FILTER
    else {
        return VMStorage.IsMemoryInMap(EntryPoint);
    }
#else
    return TRUE;
#endif
}

BOOL CALLBACK OnThreadCreated(
    PCONTEXT Context,
    BOOL ThreadIsLocal
) {
#ifdef _AMD64_
    PVOID EntryPoint = (PVOID)Context->Rcx;
#else
    PVOID EntryPoint = (PVOID)Context->Eax;
#endif

    if (!ThreadIsLocal && !(ThreadIsLocal = IsThreadAllowed(EntryPoint))) {
        Log(XORSTR(L"[x] Thread ") + ValToWideStr(GetCurrentThreadId()) + XORSTR(L" is blocked!"));
        EliminateThreat(avnRemoteThread, NULL, etContinue);
    }

#ifdef MITIGATIONS
    Mitigations::SetThreadAllowedDynamicCode();
#endif
    return ThreadIsLocal;
}
#endif

#ifdef WINDOWS_HOOKS_FILTER
BOOL CALLBACK OnWindowsHookLoadLibrary(PUNICODE_STRING ModuleFileName) {
    static std::unordered_set<UINT64> BlockedLibs;

    std::wstring Path(ModuleFileName->Buffer);
    std::wstring Name(LowerCase(ExtractFileName(Path)));

    UINT64 NameHash = t1ha(Name.c_str(), Name.length() * sizeof(std::wstring::value_type), 0x1EE7C0DEC0FFEE);
    if (BlockedLibs.find(NameHash) != BlockedLibs.end()) return FALSE;

    Log(XORSTR(L"[!] Attempt to load ") + Path + XORSTR(L" through the windows hooks!"));

    DWORD LastError = GetLastError();
    BOOL IsFileAllowed = Sfc::IsFileProtected(ModuleFileName->Buffer);
    Log(IsFileAllowed ? (XORSTR(L"[v] Module ") + Path + XORSTR(L" allowed!")) : (XORSTR(L"[!] Module ") + Path + XORSTR(L" not a system module!")));
    if (IsFileAllowed) return TRUE;

    if (!IsFileAllowed) {
        Log(XORSTR(L"[i] Checking the sign of ") + Path);
        IsFileAllowed = IsFileSigned(ModuleFileName->Buffer, FALSE);
    }

    if (!IsFileAllowed) {
        Log(XORSTR(L"[i] Checking the path of ") + Path);
        LowerCaseRef(Path);
        IsFileAllowed = true;
    }

    if (!IsFileAllowed) BlockedLibs.emplace(NameHash);

    Log(IsFileAllowed ? (XORSTR(L"[v] Module ") + Path + XORSTR(L" allowed!")) : (XORSTR(L"[x] Module ") + Path + XORSTR(L" is blocked!")));

    if (!IsFileAllowed) EliminateThreat(avnWindowsHooksInjection, NULL, etContinue);
    return IsFileAllowed;
}
#endif

#ifdef STACKTRACE_CHECK
BOOL CALLBACK OnUnknownTraceLoadLibrary(PVOID Address, PUNICODE_STRING ModuleFileName) {
    Log(XORSTR(L"[x] Unknown trace entry ") + ValToWideHex(Address, 16) + XORSTR(L" on load module ") + std::wstring(ModuleFileName->Buffer));
    EliminateThreat(avnUnknownTraceLoadLibrary, NULL, etTerminate);
    return FALSE;
}
#endif

#ifdef CONTEXT_FILTER
BOOL IsTraceValid() {
    const ULONG TraceSize = 30;
    PVOID Trace[TraceSize];
    ULONG Captured = CaptureStackBackTrace(0, TraceSize, Trace, NULL);
    for (unsigned int i = 0; i < Captured; i++) {
        HMODULE hModule = GetModuleBase(Trace[i]);
        if (hModule != NULL) {
            if (!ValidModulesStorage.IsModuleInStorage(hModule)) {
                Log(XORSTR(L"[x] Context manipulation from unknown module ") + GetModuleName(hModule));
                return FALSE;
            }
        }
        else {
            if (!VMStorage.IsMemoryInMap(Trace[i])) {
                Log(XORSTR(L"[x] Context manipulation from unknown memory ") + ValToWideHex(Trace[i], 16));
                return FALSE;
            }
        }
    }
    return TRUE;
}

NTSTATUS NTAPI PreNtContinue(IN PBOOL SkipOriginalCall, PCONTEXT Context, BOOL TestAlert) {
    if (!IsTraceValid()) {
        Log(XORSTR(L"[x] PreNtContinue detected unknown trace element!"));
        EliminateThreat(avnContextManipulation, NULL, etTerminate);
        *SkipOriginalCall = TRUE;
        return STATUS_ACCESS_DENIED;
    }
    return STATUS_SUCCESS;
}

NTSTATUS NTAPI PreSetContext(IN PBOOL SkipOriginalCall, HANDLE ThreadHandle, PCONTEXT Context) {
    if (!IsTraceValid()) {
        Log(XORSTR(L"[x] PreSetContext detected unknown trace element!"));
        EliminateThreat(avnContextManipulation, NULL, etTerminate);
        *SkipOriginalCall = TRUE;
        return STATUS_ACCESS_DENIED;
    }
    return STATUS_SUCCESS;
}
#endif

BOOL IsModuleRestricted(LPCWSTR ModuleName) {
    const LPCWSTR RestrictedModules[] = CRITICAL_MODULES;

    BOOL IsLibProtected = FALSE;
    for (const LPCWSTR RestrictedModule : RestrictedModules) {
        if (wcscmp(ModuleName, RestrictedModule) == 0) {
            IsLibProtected = TRUE;
            break;
        }
    }

    return IsLibProtected;
}

#ifdef TIMERED_CHECKINGS
VOID CALLBACK TimerCallback(PVOID Parameter, BOOLEAN TimerOrWaitFired) {
    AvnApi.AvnLock();
    if (!IsAvnStarted) {
        AvnApi.AvnUnlock();
        return;
    }

#ifdef FIND_CHANGED_MODULES
    ValidModulesStorage.FindChangedModules([](const MODULE_INFO& ModuleInfo) -> bool {
        if (IsModuleRestricted(ModuleInfo.Name.c_str())) {
            Log(XORSTR(L"[x] Critical module ") + ModuleInfo.Name + XORSTR(L" was changed!"));
            EliminateThreat(avnCriticalModuleChanged, NULL, etTerminate);
            return true;
        }

        HMODULE hTarget = (HMODULE)ModuleInfo.BaseAddress;
        BOOL ValidModulesHooked = TRUE;

        // Проверяем таблицы экспортов:
        PEAnalyzer pe(hTarget, FALSE);
        const EXPORTS_INFO& Exports = pe.GetExportsInfo();
        for (const auto& Export : Exports.Exports) {
            PVOID Source = Export.VA;
            PVOID Destination = FindHookDestination(Source);
            if (Destination == NULL) continue;
            HMODULE hModule = GetModuleBase(Destination);
            if (hModule != NULL) {
                if (!ValidModulesStorage.IsModuleInStorage(hModule)) {
                    Log(
                        XORSTR(L"[x] Unknown destination module: ") +
                        GetModuleName(hTarget) +
                        XORSTR(L"!") +
                        AnsiToWide(Export.Name) +
                        XORSTR(L" -> ") +
                        GetModuleName(hModule) +
                        XORSTR(L"!") +
                        ValToWideHex(Destination, 16)
                    );
                    DisassembleAndLog(Destination, 16);
                    ValidModulesHooked = FALSE;
                }
            }
            else if (!VMStorage.IsMemoryInMap(Destination)) {
                Log(
                    XORSTR(L"[x] Unknown hook destination: ") +
                    GetModuleName(hTarget) +
                    XORSTR(L"!") +
                    AnsiToWide(Export.Name) +
                    XORSTR(L" -> ") +
                    ValToWideHex(Destination, 16)
                );
                DisassembleAndLog(Destination, 16);
                ValidModulesHooked = FALSE;
            }
        }

        // Если перехват совершили из доверенных модулей:
        if (ValidModulesHooked)
            ValidModulesStorage.RecalcModuleHash(hTarget);
        else
            EliminateThreat(avnUnknownInterception, NULL, etTerminate);

        return true;
    });
#endif

#ifdef FIND_UNKNOWN_MEMORY
    EnumerateMemoryRegions(GetCurrentProcess(), [](const PMEMORY_BASIC_INFORMATION MemoryInfo) -> bool {
        if (MemoryInfo->Protect & EXECUTABLE_MEMORY) {
            if (GetModuleBase(MemoryInfo->BaseAddress) == NULL && !VMStorage.IsMemoryInMap(MemoryInfo->BaseAddress)) {
                Log(XORSTR(L"[x] Unknown memory ") + ValToWideHex(MemoryInfo->BaseAddress, 16));
                DisassembleAndLog(MemoryInfo->BaseAddress, 16);
                EliminateThreat(avnUnknownMemoryRegion, NULL, etTerminate);
            }
        }
        return true;
    });
#endif

#ifdef HANDLES_KEEPER
    static HandlesKeeper* hKeeper = NULL;
    if (!hKeeper) hKeeper = new HandlesKeeper();
    if (hKeeper) {
        hKeeper->EnumHandles(
            IsWindowsVistaOrGreater() ? OB_TYPE_PROCESS : OB_TYPE_PROCESS_XP,
            TRUE,
            [](PREMOTE_HANDLE_INFO HandleInfo, OUT PBOOL NeedToCloseSource) -> void {
                *NeedToCloseSource = HandleInfo->RemoteProcessId != HandleInfo->CurrentProcessId;
            }
        );
    }
#endif

    AvnApi.AvnUnlock();
}
#endif


#ifdef STRICT_DACLs
BOOL SetupDACLs() {
    DACL Dacl(GetCurrentProcess());
    const ULONG AccessRights =
        WRITE_DAC | WRITE_OWNER |
        PROCESS_CREATE_PROCESS | PROCESS_CREATE_THREAD |
        PROCESS_DUP_HANDLE | PROCESS_QUERY_INFORMATION |
        PROCESS_SET_QUOTA | PROCESS_SET_INFORMATION |
        PROCESS_VM_OPERATION | PROCESS_VM_READ | PROCESS_VM_WRITE |
        PROCESS_SUSPEND_RESUME;
    Dacl.Deny(sidCurrentUser, AccessRights);
    Dacl.Allow(sidEveryone, ~AccessRights & 0x1FFF);
    Dacl.Allow(sidSystem, PROCESS_ALL_ACCESS);
    Dacl.Allow(sidAdministrators, PROCESS_ALL_ACCESS);
    return Dacl.Apply();
}
#endif

#ifdef TIMERED_CHECKINGS
int timeTstDelay = DEFALT_TIMER_INTERVAL;

int getTstTime() {
	return timeTstDelay;
}
void setTstTime(int time) {
	timeTstDelay = time;
}

BOOL OperateTimeredCheckings(BOOL DesiredState) {
    static HANDLE TimerQueue;
    static HANDLE TimerHandle;
    static BOOL Activated = FALSE;

    if (DesiredState == Activated) return TRUE;

    if (DesiredState) {
        NTSTATUS Status;
        if (NT_SUCCESS(Status = RtlCreateTimerQueue(&TimerQueue))) {
            if (NT_SUCCESS(Status = RtlCreateTimer(
                TimerQueue,
                &TimerHandle,
                TimerCallback,
                NULL,
                TIMER_INTERVAL,
                TIMER_INTERVAL,
                WT_EXECUTELONGFUNCTION
            ))) {
                Log(XORSTR(L"[v] Periodic check enabled"));
                Activated = TRUE;
                return TRUE;
            }
            else {
                Log(XORSTR(L"[x] Unable to create timer: ") + ValToWideHex(Status, 8));
                RtlDeleteTimerQueue(TimerQueue);
            }
        }
        else {
            Log(XORSTR(L"[x] Unable to create timer queue: ") + ValToWideHex(Status, 8));
        }
    }
    else {
        RtlDeleteTimer(TimerQueue, TimerHandle, INVALID_HANDLE_VALUE);
        RtlDeleteTimerQueue(TimerQueue);
        Activated = FALSE;
        return TRUE;
    }
    return FALSE;
}
#endif

BOOL AvnStartDefence() {
    if (IsAvnStarted) return TRUE;

    // For safety purposes, temporal:
    if (!IsWindows7OrGreater()) return TRUE; // It is no more constant things than temporal
    Log(XORSTR(L"[v] Win7 or greater"));

    SwitchThreadsExecutionStatus(Suspend);
    Log(XORSTR(L"[i] All threads were stopped"));

#ifdef STRICT_DACLs
    SetupDACLs();
#endif

#ifdef THREADS_FILTER
    SetupThreadsFilter(NULL, OnThreadCreated);
    Log(XORSTR(L"[v] Threads filter setted up"));
#endif

#ifdef MITIGATIONS
    // Для корректной работы JIT необходимо включить фильтр потоков!
    Mitigations::SetProhibitDynamicCode(TRUE);
    Mitigations::SetThreadAllowedDynamicCode();
    Log(XORSTR(L"[v] Mitigations enabled"));
#endif

#ifdef SKIP_APP_INIT_DLLS
    //if (IsWindows8Point1OrGreater()) PebSetProcessProtected(TRUE, TRUE);
    AppInitDlls::DisableAppInitDlls();
    Log(XORSTR(L"[v] AppInitDlls intercepted"));
#endif

    Sfc::Initialize();
    InitWinTrust();

#ifdef MODULES_FILTER
    ModulesFilter::SetupFilterCallbacks(PreLoadModuleCallback);
    ModulesFilter::SetupNotificationCallbacks(DllNotificationRoutine);
    ModulesFilter::EnableModulesFilter();
    ModulesFilter::EnableDllNotification();
    Log(XORSTR(L"[v] Modules filters setted up"));

#ifdef WINDOWS_HOOKS_FILTER
    SetupWindowsHooksFilter(OnWindowsHookLoadLibrary);
    Log(XORSTR(L"[v] Windows hooks filter setted up"));
#endif
#ifdef STACKTRACE_CHECK
    SetupUnknownTraceLoadCallback(OnUnknownTraceLoadLibrary);
    Log(XORSTR(L"[v] Stacktrace check on loading modules enabled"));
#endif
#endif

#ifdef APC_FILTER
    ApcDispatcher::EnableApcFilter();
    ApcDispatcher::SetupApcCallback([](PVOID ApcProc, PVOID RetAddr) -> BOOL {
        const BOOL IsApcAllowed = GetModuleBase(ApcProc) != NULL;
        Log(IsApcAllowed ? XORSTR(L"[i] Allowed APC queried!") : XORSTR(L"[x] APC disallowed!"));
        if (!IsApcAllowed) EliminateThreat(avnUnknownApcDestination, NULL, etContinue);
        return IsApcAllowed;
    });
    Log(XORSTR(L"[v] APC filters setted up"));
#endif

#ifdef MEMORY_FILTER
    SetupMemoryCallbacks(
        PreNtAllocateVirtualMemory,
        PostNtAllocateVirtualMemory,
        PreNtProtectVirtualMemory,
        PostNtProtectVirtualMemory,
        PreNtFreeVirtualMemory,
        PostNtFreeVirtualMemory
        // PreNtMapViewOfSection,
        // PostNtMapViewOfSection,
        // PreNtUnmapViewOfSection,
        // PostNtUnmapViewOfSection
    );
    Log(XORSTR(L"[v] Memory filter setted up"));
#endif

#ifdef CONTEXT_FILTER
    ContextFilter::SetupContextCallbacks(PreNtContinue, PreSetContext);
    ContextFilter::EnableContextFilter();
    Log(XORSTR(L"[v] Context filter setted up"));
#endif

#ifdef MODULES_FILTER
    ValidModulesStorage.RecalcModulesHashes();
    Log(XORSTR(L"[v] Modules checksums recalculated"));
#endif

#ifdef MEMORY_FILTER
    VMStorage.ReloadMemoryRegions();
    Log(XORSTR(L"[v] Memory regions reloaded"));
#endif

#ifdef SELF_REMAPPING
    RemapAvnExecutableSections();
#endif

    IsAvnStarted = TRUE;

    SwitchThreadsExecutionStatus(Resume);
    Log(XORSTR(L"[i] All threads were resumed"));

#ifdef TIMERED_CHECKINGS
    OperateTimeredCheckings(TRUE);
#endif

#ifdef SKIP_VIRTUAL_INPUT
    VirtualInput::SetupFilter(HkMouse);
    VirtualInput::SetupFilter(HkKeyboard);
#endif

    return TRUE;
}

VOID AvnStopDefence() {
    if (!IsAvnStarted) return;
    AvnApi.AvnLock();

#ifdef SKIP_VIRTUAL_INPUT
    VirtualInput::RemoveFilter(HkMouse);
    VirtualInput::RemoveFilter(HkKeyboard);
#endif

#ifdef TIMERED_CHECKINGS
    OperateTimeredCheckings(FALSE);
#endif

#ifdef CONTEXT_FILTER
    ContextFilter::DisableContextFilter();
#endif

#ifdef APC_FILTER
    ApcDispatcher::DisableApcFilter();
#endif

#ifdef MODULES_FILTER		
    ModulesFilter::DisableDllNotification();
    ModulesFilter::DisableModulesFilter();
#endif

#ifdef THREADS_FILTER
    RemoveThreadsFilter();
#endif

#ifdef MEMORY_FILTER
    RemoveMemoryCallbacks();
#endif

    IsAvnStarted = FALSE;
    AvnApi.AvnUnlock();
}


typedef NTSTATUS(NTAPI *_NtQueueApcThread) (
    IN HANDLE               ThreadHandle,
    IN PIO_APC_ROUTINE      ApcRoutine,
    IN PVOID                ApcRoutineContext OPTIONAL,
    IN PIO_STATUS_BLOCK     ApcStatusBlock OPTIONAL,
    IN ULONG                ApcReserved OPTIONAL
    );
auto NtQueueApcThread = static_cast<_NtQueueApcThread>(hModules::QueryAddress(hModules::hNtdll(), XORSTR("NtQueueApcThread")));

VOID NTAPI ApcInitialization(
    IN PVOID ApcContext,
    IN PIO_STATUS_BLOCK IoStatusBlock,
    IN ULONG Reserved
) {
    Log(XORSTR(L"[v] Startup APC delivered"));
    AvnStartDefence();
}

LONG CALLBACK ExceptionHandler(IN PEXCEPTION_POINTERS ExceptionInfo) {
    const auto ExceptionRecord = ExceptionInfo->ExceptionRecord;
    if (GetModuleBase(ExceptionRecord->ExceptionAddress) != hModules::hCurrent()) return EXCEPTION_CONTINUE_SEARCH;
    Log(
        std::wstring(XORSTR(L"[x] Exception catched!\r\n")) +
        XORSTR(L"\tCode: ") + ValToWideHex(ExceptionRecord->ExceptionCode, 8) + L"\r\n" +
        XORSTR(L"\tAddress: ") + ValToWideHex(ExceptionRecord->ExceptionAddress, sizeof(SIZE_T) * 2) +
        XORSTR(L"\tModule: ") + GetModuleName(ExceptionRecord->ExceptionAddress)
    );
    DisassembleAndLog(ExceptionRecord->ExceptionAddress, 8);
    return EXCEPTION_CONTINUE_SEARCH;
}

VOID WINAPI AvnInit(HMODULE hModule, DWORD dwReason, LPCONTEXT lpContext) {
    //AddVectoredExceptionHandler(TRUE, ExceptionHandler);
    Log(XORSTR(L"[v] Avn initial phase"));
    hModules::_hCurrent = hModule;
    IsAvnStaticLoaded = (lpContext != NULL);
    AvnInitializeApi();
    if (IsAvnStaticLoaded) NtQueueApcThread(
        NtCurrentThread(),
        static_cast<PIO_APC_ROUTINE>(ApcInitialization),
        static_cast<PVOID>(hModule),
        NULL,
        0
    );
}

VOID WINAPI AvnDeinit() {
    AvnStopDefence();
    Log(XORSTR(L"[v] Avn shutted down. Good bye!"));
}

__declspec(code_seg(".stub"))
BOOL APIENTRY DllMain(HMODULE hModule, DWORD dwReason, LPCONTEXT lpContext) {
    switch (dwReason) {
    case DLL_PROCESS_ATTACH: {
        typedef VOID(WINAPI *_AvnInit)(HMODULE hModule, DWORD dwReason, LPCONTEXT Context);

#ifdef _AMD64_
        AsmJIT JIT(asmjit::ArchInfo::kIdX64);
        JIT.Add(XORSTR("mov rax, ") + ValToAnsiStr(reinterpret_cast<SIZE_T>(AvnInit)));
        JIT.Add(XORSTR("jmp rax"));
#else
        AsmJIT JIT(asmjit::ArchInfo::kIdX86);
        JIT.Add(XORSTR("mov eax, ") + ValToAnsiStr((SIZE_T)AvnInit));
        JIT.Add(XORSTR("jmp eax"));
#endif
        JIT.Build();
        static_cast<_AvnInit>(JIT.MakeCallable())(hModule, dwReason, lpContext);
        break;
    }

    case DLL_PROCESS_DETACH: {
        AvnDeinit();
        break;
    }
    }

    return TRUE;
}


```

`Avanguard/Avanguard.rc`:

```rc
// Microsoft Visual C++ generated resource script.
//
#include "resource.h"

#define APSTUDIO_READONLY_SYMBOLS
/////////////////////////////////////////////////////////////////////////////
//
// Generated from the TEXTINCLUDE 2 resource.
//
#include "winres.h"

/////////////////////////////////////////////////////////////////////////////
#undef APSTUDIO_READONLY_SYMBOLS

/////////////////////////////////////////////////////////////////////////////
// Русский (Россия) resources

#if !defined(AFX_RESOURCE_DLL) || defined(AFX_TARG_RUS)
LANGUAGE LANG_RUSSIAN, SUBLANG_DEFAULT

#ifdef APSTUDIO_INVOKED
/////////////////////////////////////////////////////////////////////////////
//
// TEXTINCLUDE
//

1 TEXTINCLUDE 
BEGIN
    "resource.h\0"
END

2 TEXTINCLUDE 
BEGIN
    "#include ""winres.h""\r\n"
    "\0"
END

3 TEXTINCLUDE 
BEGIN
    "\r\n"
    "\0"
END

#endif    // APSTUDIO_INVOKED


/////////////////////////////////////////////////////////////////////////////
//
// Version
//

VS_VERSION_INFO VERSIONINFO
 FILEVERSION 1,0,0,0
 PRODUCTVERSION 1,0,0,0
 FILEFLAGSMASK 0x3fL
#ifdef _DEBUG
 FILEFLAGS 0x1L
#else
 FILEFLAGS 0x0L
#endif
 FILEOS 0x40004L
 FILETYPE 0x2L
 FILESUBTYPE 0x0L
BEGIN
    BLOCK "StringFileInfo"
    BEGIN
        BLOCK "040904b0"
        BEGIN
            VALUE "CompanyName", "Kernel-Bridge Inc. | https://kernel-bridge.ru"
            VALUE "FileDescription", "The Win32 Anti-Intrusion Library"
            VALUE "FileVersion", "1.0.0.0"
            VALUE "InternalName", "Avanguard.dll"
            VALUE "LegalCopyright", "Copyright (C) 2018"
            VALUE "OriginalFilename", "Avanguard.dll"
            VALUE "ProductName", "TWAIL | Avanguard Defence"
            VALUE "ProductVersion", "1.0.0.0"
        END
    END
    BLOCK "VarFileInfo"
    BEGIN
        VALUE "Translation", 0x409, 1200
    END
END

#endif    // Русский (Россия) resources
/////////////////////////////////////////////////////////////////////////////



#ifndef APSTUDIO_INVOKED
/////////////////////////////////////////////////////////////////////////////
//
// Generated from the TEXTINCLUDE 3 resource.
//


/////////////////////////////////////////////////////////////////////////////
#endif    // not APSTUDIO_INVOKED


```

`Avanguard/Avanguard.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" ToolsVersion="15.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|Win32">
      <Configuration>Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <VCProjectVersion>15.0</VCProjectVersion>
    <ProjectGuid>{540A22E1-D40F-4D6E-9FFA-652E3450D064}</ProjectGuid>
    <Keyword>Win32Proj</Keyword>
    <RootNamespace>Avanguard</RootNamespace>
    <WindowsTargetPlatformVersion>10.0.17134.0</WindowsTargetPlatformVersion>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
    <ConfigurationType>DynamicLibrary</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <CharacterSet>Unicode</CharacterSet>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <PlatformToolset>v141</PlatformToolset>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
    <ConfigurationType>DynamicLibrary</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v141</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
    <WholeProgramOptimization>true</WholeProgramOptimization>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <ConfigurationType>DynamicLibrary</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v141</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
    <WholeProgramOptimization>false</WholeProgramOptimization>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <ConfigurationType>DynamicLibrary</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v141</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
    <WholeProgramOptimization>true</WholeProgramOptimization>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
    <Import Project="$(VCTargetsPath)\BuildCustomizations\masm.props" />
  </ImportGroup>
  <ImportGroup Label="Shared">
  </ImportGroup>
  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <IncludePath>.\MinHook;.\AvanguardDefence;.\AsmJit;.\AsmJit\asmjit;.\AsmJit\asmtk;.\HoShiMin's API;.\t1ha;.\;.\Zydis;.\JNI\include;.\JNI\include\win32;$(IncludePath)</IncludePath>
    <LibraryPath>.\Zydis;.\JNI\lib;$(LibraryPath)</LibraryPath>
    <IntDir>$(Platform)\$(Configuration)\Bin\$(ProjectName)\</IntDir>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <IncludePath>.\MinHook;.\AvanguardDefence;.\AsmJit;.\AsmJit\asmjit;.\AsmJit\asmtk;.\HoShiMin's API;.\t1ha;.\;.\Zydis;.\JNI\include;.\JNI\include\win32;$(IncludePath)</IncludePath>
    <LibraryPath>.\Zydis;.\JNI\lib;$(LibraryPath)</LibraryPath>
    <IntDir>$(Platform)\$(Configuration)\Bin\$(ProjectName)\</IntDir>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <IncludePath>.\MinHook;.\AvanguardDefence;.\AsmJit;.\AsmJit\asmjit;.\AsmJit\asmtk;.\HoShiMin's API;.\t1ha;.\;.\Zydis;.\JNI\include;.\JNI\include\win32;$(IncludePath)</IncludePath>
    <LibraryPath>.\Zydis;.\JNI\lib;$(LibraryPath)</LibraryPath>
    <IntDir>$(Platform)\$(Configuration)\Bin\$(ProjectName)\</IntDir>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <IncludePath>.\MinHook;.\AvanguardDefence;.\AsmJit;.\AsmJit\asmjit;.\AsmJit\asmtk;.\HoShiMin's API;.\t1ha;.\;.\Zydis;.\JNI\include;.\JNI\include\win32;$(IncludePath)</IncludePath>
    <LibraryPath>.\Zydis;.\JNI\lib;$(LibraryPath)</LibraryPath>
    <IntDir>$(Platform)\$(Configuration)\Bin\$(ProjectName)\</IntDir>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <ClCompile>
      <PrecompiledHeader>Use</PrecompiledHeader>
      <WarningLevel>Level3</WarningLevel>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>WIN32;_DEBUG;AVANGUARD_EXPORTS;_WINDOWS;_USRDLL;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <RuntimeLibrary>MultiThreadedDebug</RuntimeLibrary>
      <MultiProcessorCompilation>true</MultiProcessorCompilation>
      <LanguageStandard>stdcpplatest</LanguageStandard>
      <StringPooling>true</StringPooling>
      <DebugInformationFormat>ProgramDatabase</DebugInformationFormat>
      <WholeProgramOptimization>false</WholeProgramOptimization>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <IgnoreSpecificDefaultLibraries>msvcrt;libcmt</IgnoreSpecificDefaultLibraries>
      <SectionAlignment>
      </SectionAlignment>
      <DelayLoadDLLs>user32.dll;shell32.dll;advapi32.dll;iphlpapi.dll</DelayLoadDLLs>
      <ModuleDefinitionFile>
      </ModuleDefinitionFile>
    </Link>
    <MASM>
      <MakeAllSymbolsPublic>true</MakeAllSymbolsPublic>
    </MASM>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <ClCompile>
      <PrecompiledHeader>Use</PrecompiledHeader>
      <WarningLevel>Level3</WarningLevel>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>_DEBUG;AVANGUARD_EXPORTS;_WINDOWS;_USRDLL;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <RuntimeLibrary>MultiThreadedDebug</RuntimeLibrary>
      <ControlFlowGuard>false</ControlFlowGuard>
      <LanguageStandard>stdcpplatest</LanguageStandard>
      <StringPooling>true</StringPooling>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <IgnoreSpecificDefaultLibraries>msvcrt;libcmt</IgnoreSpecificDefaultLibraries>
      <SectionAlignment>
      </SectionAlignment>
      <DelayLoadDLLs>user32.dll;shell32.dll;advapi32.dll;iphlpapi.dll</DelayLoadDLLs>
      <ModuleDefinitionFile>
      </ModuleDefinitionFile>
    </Link>
    <MASM>
      <MakeAllSymbolsPublic>true</MakeAllSymbolsPublic>
    </MASM>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <ClCompile>
      <PrecompiledHeader>Use</PrecompiledHeader>
      <WarningLevel>Level3</WarningLevel>
      <Optimization>Full</Optimization>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>WIN32;NDEBUG;AVANGUARD_EXPORTS;_WINDOWS;_USRDLL;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <RuntimeLibrary>MultiThreaded</RuntimeLibrary>
      <InlineFunctionExpansion>AnySuitable</InlineFunctionExpansion>
      <FavorSizeOrSpeed>Speed</FavorSizeOrSpeed>
      <OmitFramePointers>true</OmitFramePointers>
      <EnableFiberSafeOptimizations>true</EnableFiberSafeOptimizations>
      <StringPooling>true</StringPooling>
      <EnableEnhancedInstructionSet>StreamingSIMDExtensions2</EnableEnhancedInstructionSet>
      <MultiProcessorCompilation>true</MultiProcessorCompilation>
      <LanguageStandard>stdcpplatest</LanguageStandard>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>false</GenerateDebugInformation>
      <IgnoreSpecificDefaultLibraries>msvcrt</IgnoreSpecificDefaultLibraries>
      <SectionAlignment>
      </SectionAlignment>
      <DelayLoadDLLs>user32.dll;shell32.dll;advapi32.dll;iphlpapi.dll</DelayLoadDLLs>
      <ModuleDefinitionFile>
      </ModuleDefinitionFile>
      <SetChecksum>true</SetChecksum>
    </Link>
    <MASM>
      <MakeAllSymbolsPublic>true</MakeAllSymbolsPublic>
    </MASM>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <ClCompile>
      <PrecompiledHeader>Use</PrecompiledHeader>
      <WarningLevel>Level3</WarningLevel>
      <Optimization>Full</Optimization>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>NDEBUG;AVANGUARD_EXPORTS;_WINDOWS;_USRDLL;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <RuntimeLibrary>MultiThreaded</RuntimeLibrary>
      <InlineFunctionExpansion>AnySuitable</InlineFunctionExpansion>
      <FavorSizeOrSpeed>Speed</FavorSizeOrSpeed>
      <OmitFramePointers>true</OmitFramePointers>
      <EnableFiberSafeOptimizations>true</EnableFiberSafeOptimizations>
      <StringPooling>true</StringPooling>
      <MultiProcessorCompilation>true</MultiProcessorCompilation>
      <LanguageStandard>stdcpplatest</LanguageStandard>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>false</GenerateDebugInformation>
      <IgnoreSpecificDefaultLibraries>msvcrt</IgnoreSpecificDefaultLibraries>
      <SectionAlignment>
      </SectionAlignment>
      <DelayLoadDLLs>user32.dll;shell32.dll;advapi32.dll;iphlpapi.dll</DelayLoadDLLs>
      <ModuleDefinitionFile>
      </ModuleDefinitionFile>
      <SetChecksum>true</SetChecksum>
    </Link>
    <MASM>
      <MakeAllSymbolsPublic>true</MakeAllSymbolsPublic>
    </MASM>
  </ItemDefinitionGroup>
  <ItemGroup>
    <ClInclude Include="AsmJit\asmjit\asmjit.h" />
    <ClInclude Include="AsmJit\asmjit\core.h" />
    <ClInclude Include="AsmJit\asmjit\core\arch.h" />
    <ClInclude Include="AsmJit\asmjit\core\assembler.h" />
    <ClInclude Include="AsmJit\asmjit\core\build.h" />
    <ClInclude Include="AsmJit\asmjit\core\builder.h" />
    <ClInclude Include="AsmJit\asmjit\core\callconv.h" />
    <ClInclude Include="AsmJit\asmjit\core\codeholder.h" />
    <ClInclude Include="AsmJit\asmjit\core\compiler.h" />
    <ClInclude Include="AsmJit\asmjit\core\constpool.h" />
    <ClInclude Include="AsmJit\asmjit\core\cpuinfo.h" />
    <ClInclude Include="AsmJit\asmjit\core\datatypes.h" />
    <ClInclude Include="AsmJit\asmjit\core\emitter.h" />
    <ClInclude Include="AsmJit\asmjit\core\features.h" />
    <ClInclude Include="AsmJit\asmjit\core\func.h" />
    <ClInclude Include="AsmJit\asmjit\core\globals.h" />
    <ClInclude Include="AsmJit\asmjit\core\inst.h" />
    <ClInclude Include="AsmJit\asmjit\core\jitallocator.h" />
    <ClInclude Include="AsmJit\asmjit\core\jitruntime.h" />
    <ClInclude Include="AsmJit\asmjit\core\jitutils.h" />
    <ClInclude Include="AsmJit\asmjit\core\logging.h" />
    <ClInclude Include="AsmJit\asmjit\core\memmgr.h" />
    <ClInclude Include="AsmJit\asmjit\core\misc_p.h" />
    <ClInclude Include="AsmJit\asmjit\core\operand.h" />
    <ClInclude Include="AsmJit\asmjit\core\osutils.h" />
    <ClInclude Include="AsmJit\asmjit\core\raassignment_p.h" />
    <ClInclude Include="AsmJit\asmjit\core\rabuilders_p.h" />
    <ClInclude Include="AsmJit\asmjit\core\radefs_p.h" />
    <ClInclude Include="AsmJit\asmjit\core\ralocal_p.h" />
    <ClInclude Include="AsmJit\asmjit\core\rapass_p.h" />
    <ClInclude Include="AsmJit\asmjit\core\rastack_p.h" />
    <ClInclude Include="AsmJit\asmjit\core\stringbuilder.h" />
    <ClInclude Include="AsmJit\asmjit\core\stringutils.h" />
    <ClInclude Include="AsmJit\asmjit\core\support.h" />
    <ClInclude Include="AsmJit\asmjit\core\target.h" />
    <ClInclude Include="AsmJit\asmjit\core\type.h" />
    <ClInclude Include="AsmJit\asmjit\core\zone.h" />
    <ClInclude Include="AsmJit\asmjit\core\zonehash.h" />
    <ClInclude Include="AsmJit\asmjit\core\zonelist.h" />
    <ClInclude Include="AsmJit\asmjit\core\zonestack.h" />
    <ClInclude Include="AsmJit\asmjit\core\zonestring.h" />
    <ClInclude Include="AsmJit\asmjit\core\zonetree.h" />
    <ClInclude Include="AsmJit\asmjit\core\zonevector.h" />
    <ClInclude Include="AsmJit\asmjit\x86.h" />
    <ClInclude Include="AsmJit\asmjit\x86\x86assembler.h" />
    <ClInclude Include="AsmJit\asmjit\x86\x86builder.h" />
    <ClInclude Include="AsmJit\asmjit\x86\x86callconv_p.h" />
    <ClInclude Include="AsmJit\asmjit\x86\x86compiler.h" />
    <ClInclude Include="AsmJit\asmjit\x86\x86emitter.h" />
    <ClInclude Include="AsmJit\asmjit\x86\x86features.h" />
    <ClInclude Include="AsmJit\asmjit\x86\x86globals.h" />
    <ClInclude Include="AsmJit\asmjit\x86\x86instdb.h" />
    <ClInclude Include="AsmJit\asmjit\x86\x86internal_p.h" />
    <ClInclude Include="AsmJit\asmjit\x86\x86logging_p.h" />
    <ClInclude Include="AsmJit\asmjit\x86\x86opcode_p.h" />
    <ClInclude Include="AsmJit\asmjit\x86\x86operand.h" />
    <ClInclude Include="AsmJit\asmjit\x86\x86rapass_p.h" />
    <ClInclude Include="AsmJit\asmjit\x86\x86ssetoavx_p.h" />
    <ClInclude Include="AsmJit\asmtk\asmparser.h" />
    <ClInclude Include="AsmJit\asmtk\asmtk.h" />
    <ClInclude Include="AsmJit\asmtk\asmtokenizer.h" />
    <ClInclude Include="AsmJit\asmtk\elfdefs.h" />
    <ClInclude Include="AsmJit\asmtk\globals.h" />
    <ClInclude Include="AsmJit\asmtk\parserutils.h" />
    <ClInclude Include="AsmJit\asmtk\strtod.h" />
    <ClInclude Include="AvanguardDefence\AntiDebugging.h" />
    <ClInclude Include="AvanguardDefence\AntiMacros.h" />
    <ClInclude Include="AvanguardDefence\ApcDispatcher.h" />
    <ClInclude Include="AvanguardDefence\ApisetResolver.h" />
    <ClInclude Include="AvanguardDefence\AppInitDlls.h" />
    <ClInclude Include="AvanguardDefence\AvnApi.h" />
    <ClInclude Include="AvanguardDefence\AvnDefinitions.h" />
    <ClInclude Include="AvanguardDefence\CheckHook.h" />
    <ClInclude Include="AvanguardDefence\ContextFilter.h" />
    <ClInclude Include="AvanguardDefence\DACL.h" />
    <ClInclude Include="AvanguardDefence\Encryption.h" />
    <ClInclude Include="AvanguardDefence\HandlesKeeper.h" />
    <ClInclude Include="AvanguardDefence\HeapManager.h" />
    <ClInclude Include="AvanguardDefence\HWID.h" />
    <ClInclude Include="AvanguardDefence\HWIDsUtils.h" />
    <ClInclude Include="AvanguardDefence\JavaBindings.h" />
    <ClInclude Include="AvanguardDefence\KernelUtils.h" />
    <ClInclude Include="AvanguardDefence\KeSecuredMemory.h" />
    <ClInclude Include="AvanguardDefence\Locks.h" />
    <ClInclude Include="AvanguardDefence\MemoryCallbacks.h" />
    <ClInclude Include="AvanguardDefence\MemoryFilter.h" />
    <ClInclude Include="AvanguardDefence\MemoryStorage.h" />
    <ClInclude Include="AvanguardDefence\Mitigations.h" />
    <ClInclude Include="AvanguardDefence\ModulesCallbacks.h" />
    <ClInclude Include="AvanguardDefence\ModulesFilter.h" />
    <ClInclude Include="AvanguardDefence\hModules.h" />
    <ClInclude Include="AvanguardDefence\ModulesStorage.h" />
    <ClInclude Include="AvanguardDefence\ModulesUtils.h" />
    <ClInclude Include="AvanguardDefence\PEAnalyzer.h" />
    <ClInclude Include="AvanguardDefence\PebTeb.h" />
    <ClInclude Include="AvanguardDefence\PEUtils.h" />
    <ClInclude Include="AvanguardDefence\ProcessAPI.h" />
    <ClInclude Include="AvanguardDefence\Remapping.h" />
    <ClInclude Include="AvanguardDefence\SfcWrapper.h" />
    <ClInclude Include="AvanguardDefence\ThreadsFilter.h" />
    <ClInclude Include="AvanguardDefence\ThreatElimination.h" />
    <ClInclude Include="AvanguardDefence\ThreatTypes.h" />
    <ClInclude Include="AvanguardDefence\TLS.h" />
    <ClInclude Include="AvanguardDefence\WinHooks.h" />
    <ClInclude Include="AvanguardDefence\WinTrusted.h" />
    <ClInclude Include="HoShiMin%27s API\CodepageAPI.h" />
    <ClInclude Include="HoShiMin%27s API\ColoredConsole.h" />
    <ClInclude Include="HoShiMin%27s API\DisasmHelper.h" />
    <ClInclude Include="HoShiMin%27s API\HookHelper.h" />
    <ClInclude Include="HoShiMin%27s API\JitHelper.h" />
    <ClInclude Include="HoShiMin%27s API\StringsAPI.h" />
    <ClInclude Include="JNI\include\jni.h" />
    <ClInclude Include="JNI\include\jvmti.h" />
    <ClInclude Include="JNI\include\win32\jni_md.h" />
    <ClInclude Include="MinHook\MinHook.h" />
    <ClInclude Include="resource.h" />
    <ClInclude Include="stdafx.h" />
    <ClInclude Include="t1ha\t1ha.h" />
    <ClInclude Include="targetver.h" />
    <ClInclude Include="xorstr\xorstr.hpp" />
    <ClInclude Include="Zydis\ZydisExportConfig.h" />
    <ClInclude Include="Zydis\Zydis\CommonTypes.h" />
    <ClInclude Include="Zydis\Zydis\Decoder.h" />
    <ClInclude Include="Zydis\Zydis\DecoderTypes.h" />
    <ClInclude Include="Zydis\Zydis\Defines.h" />
    <ClInclude Include="Zydis\Zydis\Formatter.h" />
    <ClInclude Include="Zydis\Zydis\Generated\EnumInstructionCategory.h" />
    <ClInclude Include="Zydis\Zydis\Generated\EnumISAExt.h" />
    <ClInclude Include="Zydis\Zydis\Generated\EnumISASet.h" />
    <ClInclude Include="Zydis\Zydis\Generated\EnumMnemonic.h" />
    <ClInclude Include="Zydis\Zydis\Internal\DecoderData.h" />
    <ClInclude Include="Zydis\Zydis\Internal\LibC.h" />
    <ClInclude Include="Zydis\Zydis\Internal\SharedData.h" />
    <ClInclude Include="Zydis\Zydis\MetaInfo.h" />
    <ClInclude Include="Zydis\Zydis\Mnemonic.h" />
    <ClInclude Include="Zydis\Zydis\Register.h" />
    <ClInclude Include="Zydis\Zydis\SharedTypes.h" />
    <ClInclude Include="Zydis\Zydis\Status.h" />
    <ClInclude Include="Zydis\Zydis\String.h" />
    <ClInclude Include="Zydis\Zydis\Utils.h" />
    <ClInclude Include="Zydis\Zydis\Zydis.h" />
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="AsmJit\asmtk\asmparser.cpp" />
    <ClCompile Include="AsmJit\asmtk\asmtokenizer.cpp" />
    <ClCompile Include="Avanguard.cpp" />
    <ClCompile Include="AvanguardDefence\AntiDebugging.cpp" />
    <ClCompile Include="AvanguardDefence\AntiMacros.cpp" />
    <ClCompile Include="AvanguardDefence\ApcDispatcher.cpp" />
    <ClCompile Include="AvanguardDefence\ApisetResolver.cpp" />
    <ClCompile Include="AvanguardDefence\AppInitDlls.cpp" />
    <ClCompile Include="AvanguardDefence\AvnApi.cpp" />
    <ClCompile Include="AvanguardDefence\CheckHook.cpp" />
    <ClCompile Include="AvanguardDefence\ContextFilter.cpp" />
    <ClCompile Include="AvanguardDefence\DACL.cpp" />
    <ClCompile Include="AvanguardDefence\Encryption.cpp" />
    <ClCompile Include="AvanguardDefence\HandlesKeeper.cpp" />
    <ClCompile Include="AvanguardDefence\HeapManager.cpp" />
    <ClCompile Include="AvanguardDefence\HWID.cpp" />
    <ClCompile Include="AvanguardDefence\HWIDsUtils.cpp" />
    <ClCompile Include="AvanguardDefence\JavaBindings.cpp" />
    <ClCompile Include="AvanguardDefence\KernelUtils.cpp" />
    <ClCompile Include="AvanguardDefence\KeSecuredMemory.cpp" />
    <ClCompile Include="AvanguardDefence\MemoryCallbacks.cpp" />
    <ClCompile Include="AvanguardDefence\MemoryFilter.cpp" />
    <ClCompile Include="AvanguardDefence\MemoryStorage.cpp" />
    <ClCompile Include="AvanguardDefence\Mitigations.cpp" />
    <ClCompile Include="AvanguardDefence\ModulesCallbacks.cpp" />
    <ClCompile Include="AvanguardDefence\ModulesFilter.cpp" />
    <ClCompile Include="AvanguardDefence\hModules.cpp" />
    <ClCompile Include="AvanguardDefence\ModulesStorage.cpp" />
    <ClCompile Include="AvanguardDefence\ModulesUtils.cpp" />
    <ClCompile Include="AvanguardDefence\PEAnalyzer.cpp" />
    <ClCompile Include="AvanguardDefence\PEUtils.cpp" />
    <ClCompile Include="AvanguardDefence\ProcessAPI.cpp" />
    <ClCompile Include="AvanguardDefence\Remapping.cpp" />
    <ClCompile Include="AvanguardDefence\SfcWrapper.cpp" />
    <ClCompile Include="AvanguardDefence\ThreadsFilter.cpp" />
    <ClCompile Include="AvanguardDefence\ThreatElimination.cpp" />
    <ClCompile Include="AvanguardDefence\TLS.cpp" />
    <ClCompile Include="AvanguardDefence\WinHooks.cpp" />
    <ClCompile Include="AvanguardDefence\WinTrusted.cpp" />
    <ClCompile Include="HoShiMin%27s API\CodepageAPI.cpp" />
    <ClCompile Include="HoShiMin%27s API\DisasmHelper.cpp" />
    <ClCompile Include="HoShiMin%27s API\JitHelper.cpp" />
    <ClCompile Include="HoShiMin%27s API\StringsAPI.cpp" />
    <ClCompile Include="stdafx.cpp">
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">Create</PrecompiledHeader>
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">Create</PrecompiledHeader>
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">Create</PrecompiledHeader>
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Release|x64'">Create</PrecompiledHeader>
    </ClCompile>
  </ItemGroup>
  <ItemGroup>
    <Manifest Include="AvanguardDefence\SupportedOS.manifest" />
  </ItemGroup>
  <ItemGroup>
    <Library Include="AsmJit\lib\x64\asmjit.dbg.x64.lib">
      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">true</ExcludedFromBuild>
      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">true</ExcludedFromBuild>
      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">false</ExcludedFromBuild>
      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Release|x64'">true</ExcludedFromBuild>
    </Library>
    <Library Include="AsmJit\lib\x64\asmjit.rel.x64.lib">
      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">true</ExcludedFromBuild>
      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">true</ExcludedFromBuild>
      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">true</ExcludedFromBuild>
      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Release|x64'">false</ExcludedFromBuild>
    </Library>
    <Library Include="AsmJit\lib\x86\asmjit.dbg.x86.lib">
      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">false</ExcludedFromBuild>
      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">true</ExcludedFromBuild>
      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">true</ExcludedFromBuild>
      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Release|x64'">true</ExcludedFromBuild>
    </Library>
    <Library Include="AsmJit\lib\x86\asmjit.rel.x86.lib">
      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">true</ExcludedFromBuild>
      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">false</ExcludedFromBuild>
      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">true</ExcludedFromBuild>
      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Release|x64'">true</ExcludedFromBuild>
    </Library>
    <Library Include="JNI\lib\jvm.lib" />
    <Library Include="MinHook\libMinHook.x64.lib">
      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">true</ExcludedFromBuild>
      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">true</ExcludedFromBuild>
    </Library>
    <Library Include="MinHook\libMinHook.x86.lib">
      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">true</ExcludedFromBuild>
      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Release|x64'">true</ExcludedFromBuild>
    </Library>
    <Library Include="t1ha\t1ha.x64.lib">
      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">true</ExcludedFromBuild>
      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">true</ExcludedFromBuild>
    </Library>
    <Library Include="t1ha\t1ha.x86.lib">
      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">true</ExcludedFromBuild>
      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Release|x64'">true</ExcludedFromBuild>
    </Library>
    <Library Include="Zydis\Zydis.x86.lib">
      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">true</ExcludedFromBuild>
      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Release|x64'">true</ExcludedFromBuild>
    </Library>
    <Library Include="Zydis\Zydis.x64.lib">
      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">true</ExcludedFromBuild>
      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">true</ExcludedFromBuild>
    </Library>
  </ItemGroup>
  <ItemGroup>
    <MASM Include="AvanguardDefence\ApcInterceptionRoutine.asm">
      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">true</ExcludedFromBuild>
      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">true</ExcludedFromBuild>
    </MASM>
  </ItemGroup>
  <ItemGroup>
    <ResourceCompile Include="Avanguard.rc" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
    <Import Project="$(VCTargetsPath)\BuildCustomizations\masm.targets" />
  </ImportGroup>
</Project>
```

`Avanguard/Avanguard.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="Исходные файлы">
      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
      <Extensions>cpp;c;cc;cxx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
    </Filter>
    <Filter Include="Файлы заголовков">
      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
      <Extensions>h;hh;hpp;hxx;hm;inl;inc;xsd</Extensions>
    </Filter>
    <Filter Include="Файлы ресурсов">
      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav;mfcribbon-ms</Extensions>
    </Filter>
    <Filter Include="AvanguardDefence">
      <UniqueIdentifier>{6adc7958-fde9-40a3-956f-4cf74665b37b}</UniqueIdentifier>
    </Filter>
    <Filter Include="AvanguardDefence\AntiMacros">
      <UniqueIdentifier>{749d4c7b-7c24-4a1b-82d3-b00514895611}</UniqueIdentifier>
    </Filter>
    <Filter Include="AvanguardDefence\AntiDebugging">
      <UniqueIdentifier>{3cd43e2b-f6c8-4f49-9cf5-0e32fabc5f48}</UniqueIdentifier>
    </Filter>
    <Filter Include="AvanguardDefence\Encryption">
      <UniqueIdentifier>{af465c5f-32d5-4b29-8a30-d94a07f0fdf4}</UniqueIdentifier>
    </Filter>
    <Filter Include="AvanguardDefence\HandlesKeeper">
      <UniqueIdentifier>{082e7e22-3303-43f6-aa22-93195a6618fe}</UniqueIdentifier>
    </Filter>
    <Filter Include="AvanguardDefence\KernelUtils">
      <UniqueIdentifier>{4b0c476c-4d47-4fa3-9638-5fc6124552a3}</UniqueIdentifier>
    </Filter>
    <Filter Include="AvanguardDefence\KeSecuredMemory">
      <UniqueIdentifier>{1706bbef-c551-4b8d-9dfd-1dd366767045}</UniqueIdentifier>
    </Filter>
    <Filter Include="AvanguardDefence\ModulesFilter">
      <UniqueIdentifier>{eadb8fcf-485b-4223-8d3e-139a065945c3}</UniqueIdentifier>
    </Filter>
    <Filter Include="AvanguardDefence\ThreadsFilter">
      <UniqueIdentifier>{fc5ed613-e5a2-42c0-b0b2-af7038d5da99}</UniqueIdentifier>
    </Filter>
    <Filter Include="AvanguardDefence\ProcessAPI">
      <UniqueIdentifier>{da23b007-6bee-46c2-8b3b-7e6dc716e2e9}</UniqueIdentifier>
    </Filter>
    <Filter Include="AvanguardDefence\TLS">
      <UniqueIdentifier>{3a4d5f17-db52-4ba6-8fcc-4f126ce9e52b}</UniqueIdentifier>
    </Filter>
    <Filter Include="AvanguardDefence\PEAnalyzer">
      <UniqueIdentifier>{74616d1f-adc8-4f4f-94da-277559068de1}</UniqueIdentifier>
    </Filter>
    <Filter Include="HoShiMin%27s API">
      <UniqueIdentifier>{ad1b6dfb-5345-4c67-972a-e2203ce9b5f9}</UniqueIdentifier>
    </Filter>
    <Filter Include="AvanguardDefence\PebTeb">
      <UniqueIdentifier>{c28374da-3662-42a2-b95a-0c3e6f36182f}</UniqueIdentifier>
    </Filter>
    <Filter Include="t1ha">
      <UniqueIdentifier>{8be81dfc-0562-464d-8582-f6946227d111}</UniqueIdentifier>
    </Filter>
    <Filter Include="AvanguardDefence\ApiSet">
      <UniqueIdentifier>{177c2950-d9fc-4c2c-b226-470131f9cd91}</UniqueIdentifier>
    </Filter>
    <Filter Include="AvanguardDefence\MemoryFilter">
      <UniqueIdentifier>{4a74a33e-47b4-4ee6-8b5a-32efc6c93ec9}</UniqueIdentifier>
    </Filter>
    <Filter Include="Zydis">
      <UniqueIdentifier>{4e741c4f-6fbf-4601-888f-0cf68b8ab578}</UniqueIdentifier>
    </Filter>
    <Filter Include="Zydis\Zydis">
      <UniqueIdentifier>{30e5d7b0-865e-48e2-af7b-fb76cc5dd70c}</UniqueIdentifier>
    </Filter>
    <Filter Include="AvanguardDefence\CheckHook">
      <UniqueIdentifier>{a2a47bfb-7617-4e34-ba66-1217541d4525}</UniqueIdentifier>
    </Filter>
    <Filter Include="AvanguardDefence\AppInitDlls">
      <UniqueIdentifier>{9c21c2b9-f20a-4af2-9713-a1550fcaa9dc}</UniqueIdentifier>
    </Filter>
    <Filter Include="AvanguardDefence\MitigationsPolicy">
      <UniqueIdentifier>{db2afae7-25e2-4731-9c51-517b3c67c199}</UniqueIdentifier>
    </Filter>
    <Filter Include="AvanguardDefence\WinTrust">
      <UniqueIdentifier>{226420cf-a960-4892-adda-3b40a3aafca0}</UniqueIdentifier>
    </Filter>
    <Filter Include="AvanguardDefence\KiUserApcDispatcher">
      <UniqueIdentifier>{32ff76a0-9a07-427e-8fdb-cf75d32c84b2}</UniqueIdentifier>
    </Filter>
    <Filter Include="MinHook">
      <UniqueIdentifier>{f26cf68d-3769-48ac-bdc2-8acddf3084f9}</UniqueIdentifier>
    </Filter>
    <Filter Include="AvanguardDefence\hModules">
      <UniqueIdentifier>{a1960df9-d7b9-40d3-87f1-fb776b8b2c2d}</UniqueIdentifier>
    </Filter>
    <Filter Include="AvanguardDefence\WinHooks">
      <UniqueIdentifier>{016ca3b7-63ff-4a6c-8c3e-9a9a6aeaba75}</UniqueIdentifier>
    </Filter>
    <Filter Include="AvanguardDefence\AvnApi">
      <UniqueIdentifier>{d9840127-c9a9-460e-a533-3383ac1f4817}</UniqueIdentifier>
    </Filter>
    <Filter Include="AvanguardDefence\DACL">
      <UniqueIdentifier>{32543f7d-5657-416d-a860-c8b41bde96ec}</UniqueIdentifier>
    </Filter>
    <Filter Include="AvanguardDefence\HWIDs">
      <UniqueIdentifier>{5bc7e5f2-2713-4825-b2cf-2a0d62acbc45}</UniqueIdentifier>
    </Filter>
    <Filter Include="AvanguardDefence\ContextFilter">
      <UniqueIdentifier>{10fd8230-76bd-44cf-b844-9ba86253c200}</UniqueIdentifier>
    </Filter>
    <Filter Include="AvanguardDefence\ModulesUtils">
      <UniqueIdentifier>{bb626324-6a72-4934-b81f-bdff93b29666}</UniqueIdentifier>
    </Filter>
    <Filter Include="AvanguardDefence\JavaSupport">
      <UniqueIdentifier>{d8350677-f267-4851-8aca-b08fccb610a0}</UniqueIdentifier>
    </Filter>
    <Filter Include="AvanguardDefence\JavaSupport\JavaBindings">
      <UniqueIdentifier>{ead8c17d-fc94-41a6-8dd2-684bf5083a1d}</UniqueIdentifier>
    </Filter>
    <Filter Include="AvanguardDefence\JavaSupport\JNI">
      <UniqueIdentifier>{dba1cf9e-2cb5-4946-99e1-a97224fd7322}</UniqueIdentifier>
    </Filter>
    <Filter Include="AvanguardDefence\JavaSupport\JNI\include">
      <UniqueIdentifier>{a33e2f6f-d88d-4fe2-b6de-afdb7df1be53}</UniqueIdentifier>
    </Filter>
    <Filter Include="AvanguardDefence\JavaSupport\JNI\include\win32">
      <UniqueIdentifier>{1174c18f-1e9d-420d-928e-0e55b8e673a4}</UniqueIdentifier>
    </Filter>
    <Filter Include="AvanguardDefence\JavaSupport\JNI\lib">
      <UniqueIdentifier>{175266db-1a9b-47c8-88e4-50f1c67dea24}</UniqueIdentifier>
    </Filter>
    <Filter Include="AvanguardDefence\ThreatEliminating">
      <UniqueIdentifier>{daef30ed-f65b-46c7-9132-f85a8f4150b4}</UniqueIdentifier>
    </Filter>
    <Filter Include="AvanguardDefence\Locks">
      <UniqueIdentifier>{424cf323-88fe-4496-86e6-34e346fc5d88}</UniqueIdentifier>
    </Filter>
    <Filter Include="xorstr">
      <UniqueIdentifier>{b367007d-0b07-41ec-ac61-0d5bf602450d}</UniqueIdentifier>
    </Filter>
    <Filter Include="AvanguardDefence\Remapping">
      <UniqueIdentifier>{41b12e1b-6447-4043-ab06-78229bb6773f}</UniqueIdentifier>
    </Filter>
    <Filter Include="AsmJit">
      <UniqueIdentifier>{a2ec44ba-8a35-460f-862b-3bb0f4c149ec}</UniqueIdentifier>
    </Filter>
    <Filter Include="AsmJit\asmjit">
      <UniqueIdentifier>{445ef729-a3c1-4793-856e-f477c403b890}</UniqueIdentifier>
    </Filter>
    <Filter Include="AsmJit\asmtk">
      <UniqueIdentifier>{b156cf73-b734-457f-8c56-ddefb512bb2c}</UniqueIdentifier>
    </Filter>
    <Filter Include="AsmJit\asmjit\core">
      <UniqueIdentifier>{e4bdabf4-85f7-4a67-966e-8a88972aa573}</UniqueIdentifier>
    </Filter>
    <Filter Include="AsmJit\asmjit\x86">
      <UniqueIdentifier>{bf32da44-aa62-4cec-b867-c488775ccb7a}</UniqueIdentifier>
    </Filter>
    <Filter Include="AsmJit\lib">
      <UniqueIdentifier>{0562acd5-a43d-4783-9ae4-0c567fd33618}</UniqueIdentifier>
    </Filter>
    <Filter Include="AsmJit\lib\x86">
      <UniqueIdentifier>{8aa3e682-23f5-43b9-a746-1587443396b4}</UniqueIdentifier>
    </Filter>
    <Filter Include="AsmJit\lib\x64">
      <UniqueIdentifier>{4a56dffc-0b39-4395-8e57-6f46ecf435b4}</UniqueIdentifier>
    </Filter>
    <Filter Include="AvanguardDefence\Sfc">
      <UniqueIdentifier>{0bd6839a-4fb3-454e-a0ac-35eb293370d5}</UniqueIdentifier>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="stdafx.h">
      <Filter>Файлы заголовков</Filter>
    </ClInclude>
    <ClInclude Include="targetver.h">
      <Filter>Файлы заголовков</Filter>
    </ClInclude>
    <ClInclude Include="AvanguardDefence\AntiDebugging.h">
      <Filter>AvanguardDefence\AntiDebugging</Filter>
    </ClInclude>
    <ClInclude Include="AvanguardDefence\AntiMacros.h">
      <Filter>AvanguardDefence\AntiMacros</Filter>
    </ClInclude>
    <ClInclude Include="AvanguardDefence\Encryption.h">
      <Filter>AvanguardDefence\Encryption</Filter>
    </ClInclude>
    <ClInclude Include="AvanguardDefence\HandlesKeeper.h">
      <Filter>AvanguardDefence\HandlesKeeper</Filter>
    </ClInclude>
    <ClInclude Include="AvanguardDefence\HeapManager.h">
      <Filter>AvanguardDefence\HandlesKeeper</Filter>
    </ClInclude>
    <ClInclude Include="AvanguardDefence\KernelUtils.h">
      <Filter>AvanguardDefence\KernelUtils</Filter>
    </ClInclude>
    <ClInclude Include="AvanguardDefence\KeSecuredMemory.h">
      <Filter>AvanguardDefence\KeSecuredMemory</Filter>
    </ClInclude>
    <ClInclude Include="AvanguardDefence\ThreadsFilter.h">
      <Filter>AvanguardDefence\ThreadsFilter</Filter>
    </ClInclude>
    <ClInclude Include="AvanguardDefence\ModulesFilter.h">
      <Filter>AvanguardDefence\ModulesFilter</Filter>
    </ClInclude>
    <ClInclude Include="AvanguardDefence\PEUtils.h">
      <Filter>AvanguardDefence\Encryption</Filter>
    </ClInclude>
    <ClInclude Include="AvanguardDefence\TLS.h">
      <Filter>AvanguardDefence\TLS</Filter>
    </ClInclude>
    <ClInclude Include="AvanguardDefence\PEAnalyzer.h">
      <Filter>AvanguardDefence\PEAnalyzer</Filter>
    </ClInclude>
    <ClInclude Include="HoShiMin%27s API\StringsAPI.h">
      <Filter>HoShiMin%27s API</Filter>
    </ClInclude>
    <ClInclude Include="HoShiMin%27s API\ColoredConsole.h">
      <Filter>HoShiMin%27s API</Filter>
    </ClInclude>
    <ClInclude Include="AvanguardDefence\PebTeb.h">
      <Filter>AvanguardDefence\PebTeb</Filter>
    </ClInclude>
    <ClInclude Include="AvanguardDefence\ApisetResolver.h">
      <Filter>AvanguardDefence\ApiSet</Filter>
    </ClInclude>
    <ClInclude Include="AvanguardDefence\MemoryFilter.h">
      <Filter>AvanguardDefence\MemoryFilter</Filter>
    </ClInclude>
    <ClInclude Include="t1ha\t1ha.h">
      <Filter>t1ha</Filter>
    </ClInclude>
    <ClInclude Include="HoShiMin%27s API\HookHelper.h">
      <Filter>HoShiMin%27s API</Filter>
    </ClInclude>
    <ClInclude Include="AvanguardDefence\MemoryCallbacks.h">
      <Filter>AvanguardDefence\MemoryFilter</Filter>
    </ClInclude>
    <ClInclude Include="AvanguardDefence\ModulesCallbacks.h">
      <Filter>AvanguardDefence\ModulesFilter</Filter>
    </ClInclude>
    <ClInclude Include="AvanguardDefence\MemoryStorage.h">
      <Filter>AvanguardDefence\MemoryFilter</Filter>
    </ClInclude>
    <ClInclude Include="AvanguardDefence\ModulesStorage.h">
      <Filter>AvanguardDefence\ModulesFilter</Filter>
    </ClInclude>
    <ClInclude Include="Zydis\ZydisExportConfig.h">
      <Filter>Zydis</Filter>
    </ClInclude>
    <ClInclude Include="Zydis\Zydis\Zydis.h">
      <Filter>Zydis\Zydis</Filter>
    </ClInclude>
    <ClInclude Include="Zydis\Zydis\CommonTypes.h">
      <Filter>Zydis\Zydis</Filter>
    </ClInclude>
    <ClInclude Include="Zydis\Zydis\Decoder.h">
      <Filter>Zydis\Zydis</Filter>
    </ClInclude>
    <ClInclude Include="Zydis\Zydis\Internal\DecoderData.h">
      <Filter>Zydis\Zydis</Filter>
    </ClInclude>
    <ClInclude Include="Zydis\Zydis\DecoderTypes.h">
      <Filter>Zydis\Zydis</Filter>
    </ClInclude>
    <ClInclude Include="Zydis\Zydis\Defines.h">
      <Filter>Zydis\Zydis</Filter>
    </ClInclude>
    <ClInclude Include="Zydis\Zydis\Generated\EnumInstructionCategory.h">
      <Filter>Zydis\Zydis</Filter>
    </ClInclude>
    <ClInclude Include="Zydis\Zydis\Generated\EnumISAExt.h">
      <Filter>Zydis\Zydis</Filter>
    </ClInclude>
    <ClInclude Include="Zydis\Zydis\Generated\EnumISASet.h">
      <Filter>Zydis\Zydis</Filter>
    </ClInclude>
    <ClInclude Include="Zydis\Zydis\Generated\EnumMnemonic.h">
      <Filter>Zydis\Zydis</Filter>
    </ClInclude>
    <ClInclude Include="Zydis\Zydis\Formatter.h">
      <Filter>Zydis\Zydis</Filter>
    </ClInclude>
    <ClInclude Include="Zydis\Zydis\Internal\LibC.h">
      <Filter>Zydis\Zydis</Filter>
    </ClInclude>
    <ClInclude Include="Zydis\Zydis\MetaInfo.h">
      <Filter>Zydis\Zydis</Filter>
    </ClInclude>
    <ClInclude Include="Zydis\Zydis\Mnemonic.h">
      <Filter>Zydis\Zydis</Filter>
    </ClInclude>
    <ClInclude Include="Zydis\Zydis\Register.h">
      <Filter>Zydis\Zydis</Filter>
    </ClInclude>
    <ClInclude Include="Zydis\Zydis\Internal\SharedData.h">
      <Filter>Zydis\Zydis</Filter>
    </ClInclude>
    <ClInclude Include="Zydis\Zydis\SharedTypes.h">
      <Filter>Zydis\Zydis</Filter>
    </ClInclude>
    <ClInclude Include="Zydis\Zydis\Status.h">
      <Filter>Zydis\Zydis</Filter>
    </ClInclude>
    <ClInclude Include="Zydis\Zydis\String.h">
      <Filter>Zydis\Zydis</Filter>
    </ClInclude>
    <ClInclude Include="Zydis\Zydis\Utils.h">
      <Filter>Zydis\Zydis</Filter>
    </ClInclude>
    <ClInclude Include="HoShiMin%27s API\DisasmHelper.h">
      <Filter>HoShiMin%27s API</Filter>
    </ClInclude>
    <ClInclude Include="AvanguardDefence\CheckHook.h">
      <Filter>AvanguardDefence\CheckHook</Filter>
    </ClInclude>
    <ClInclude Include="AvanguardDefence\Mitigations.h">
      <Filter>AvanguardDefence\MitigationsPolicy</Filter>
    </ClInclude>
    <ClInclude Include="AvanguardDefence\AppInitDlls.h">
      <Filter>AvanguardDefence\AppInitDlls</Filter>
    </ClInclude>
    <ClInclude Include="AvanguardDefence\WinTrusted.h">
      <Filter>AvanguardDefence\WinTrust</Filter>
    </ClInclude>
    <ClInclude Include="AvanguardDefence\ApcDispatcher.h">
      <Filter>AvanguardDefence\KiUserApcDispatcher</Filter>
    </ClInclude>
    <ClInclude Include="MinHook\MinHook.h">
      <Filter>MinHook</Filter>
    </ClInclude>
    <ClInclude Include="AvanguardDefence\hModules.h">
      <Filter>AvanguardDefence\hModules</Filter>
    </ClInclude>
    <ClInclude Include="AvanguardDefence\WinHooks.h">
      <Filter>AvanguardDefence\WinHooks</Filter>
    </ClInclude>
    <ClInclude Include="AvanguardDefence\AvnDefinitions.h">
      <Filter>AvanguardDefence</Filter>
    </ClInclude>
    <ClInclude Include="AvanguardDefence\AvnApi.h">
      <Filter>AvanguardDefence\AvnApi</Filter>
    </ClInclude>
    <ClInclude Include="AvanguardDefence\DACL.h">
      <Filter>AvanguardDefence\DACL</Filter>
    </ClInclude>
    <ClInclude Include="AvanguardDefence\HWID.h">
      <Filter>AvanguardDefence\HWIDs</Filter>
    </ClInclude>
    <ClInclude Include="AvanguardDefence\ContextFilter.h">
      <Filter>AvanguardDefence\ContextFilter</Filter>
    </ClInclude>
    <ClInclude Include="AvanguardDefence\ModulesUtils.h">
      <Filter>AvanguardDefence\ModulesUtils</Filter>
    </ClInclude>
    <ClInclude Include="AvanguardDefence\ProcessAPI.h">
      <Filter>AvanguardDefence\ProcessAPI</Filter>
    </ClInclude>
    <ClInclude Include="AvanguardDefence\HWIDsUtils.h">
      <Filter>AvanguardDefence\HWIDs</Filter>
    </ClInclude>
    <ClInclude Include="AvanguardDefence\JavaBindings.h">
      <Filter>AvanguardDefence\JavaSupport\JavaBindings</Filter>
    </ClInclude>
    <ClInclude Include="JNI\include\win32\jni_md.h">
      <Filter>AvanguardDefence\JavaSupport\JNI\include\win32</Filter>
    </ClInclude>
    <ClInclude Include="JNI\include\jni.h">
      <Filter>AvanguardDefence\JavaSupport\JNI\include</Filter>
    </ClInclude>
    <ClInclude Include="JNI\include\jvmti.h">
      <Filter>AvanguardDefence\JavaSupport\JNI\include</Filter>
    </ClInclude>
    <ClInclude Include="HoShiMin%27s API\CodepageAPI.h">
      <Filter>HoShiMin%27s API</Filter>
    </ClInclude>
    <ClInclude Include="AvanguardDefence\ThreatTypes.h">
      <Filter>AvanguardDefence\ThreatEliminating</Filter>
    </ClInclude>
    <ClInclude Include="AvanguardDefence\ThreatElimination.h">
      <Filter>AvanguardDefence\ThreatEliminating</Filter>
    </ClInclude>
    <ClInclude Include="AvanguardDefence\Locks.h">
      <Filter>AvanguardDefence\Locks</Filter>
    </ClInclude>
    <ClInclude Include="xorstr\xorstr.hpp">
      <Filter>xorstr</Filter>
    </ClInclude>
    <ClInclude Include="AvanguardDefence\Remapping.h">
      <Filter>AvanguardDefence\Remapping</Filter>
    </ClInclude>
    <ClInclude Include="AsmJit\asmjit\asmjit.h">
      <Filter>AsmJit\asmjit</Filter>
    </ClInclude>
    <ClInclude Include="AsmJit\asmjit\core.h">
      <Filter>AsmJit\asmjit</Filter>
    </ClInclude>
    <ClInclude Include="AsmJit\asmjit\x86.h">
      <Filter>AsmJit\asmjit</Filter>
    </ClInclude>
    <ClInclude Include="AsmJit\asmjit\core\arch.h">
      <Filter>AsmJit\asmjit\core</Filter>
    </ClInclude>
    <ClInclude Include="AsmJit\asmjit\core\assembler.h">
      <Filter>AsmJit\asmjit\core</Filter>
    </ClInclude>
    <ClInclude Include="AsmJit\asmjit\core\build.h">
      <Filter>AsmJit\asmjit\core</Filter>
    </ClInclude>
    <ClInclude Include="AsmJit\asmjit\core\builder.h">
      <Filter>AsmJit\asmjit\core</Filter>
    </ClInclude>
    <ClInclude Include="AsmJit\asmjit\core\callconv.h">
      <Filter>AsmJit\asmjit\core</Filter>
    </ClInclude>
    <ClInclude Include="AsmJit\asmjit\core\codeholder.h">
      <Filter>AsmJit\asmjit\core</Filter>
    </ClInclude>
    <ClInclude Include="AsmJit\asmjit\core\compiler.h">
      <Filter>AsmJit\asmjit\core</Filter>
    </ClInclude>
    <ClInclude Include="AsmJit\asmjit\core\constpool.h">
      <Filter>AsmJit\asmjit\core</Filter>
    </ClInclude>
    <ClInclude Include="AsmJit\asmjit\core\cpuinfo.h">
      <Filter>AsmJit\asmjit\core</Filter>
    </ClInclude>
    <ClInclude Include="AsmJit\asmjit\core\datatypes.h">
      <Filter>AsmJit\asmjit\core</Filter>
    </ClInclude>
    <ClInclude Include="AsmJit\asmjit\core\emitter.h">
      <Filter>AsmJit\asmjit\core</Filter>
    </ClInclude>
    <ClInclude Include="AsmJit\asmjit\core\features.h">
      <Filter>AsmJit\asmjit\core</Filter>
    </ClInclude>
    <ClInclude Include="AsmJit\asmjit\core\func.h">
      <Filter>AsmJit\asmjit\core</Filter>
    </ClInclude>
    <ClInclude Include="AsmJit\asmjit\core\globals.h">
      <Filter>AsmJit\asmjit\core</Filter>
    </ClInclude>
    <ClInclude Include="AsmJit\asmjit\core\inst.h">
      <Filter>AsmJit\asmjit\core</Filter>
    </ClInclude>
    <ClInclude Include="AsmJit\asmjit\core\jitallocator.h">
      <Filter>AsmJit\asmjit\core</Filter>
    </ClInclude>
    <ClInclude Include="AsmJit\asmjit\core\jitruntime.h">
      <Filter>AsmJit\asmjit\core</Filter>
    </ClInclude>
    <ClInclude Include="AsmJit\asmjit\core\jitutils.h">
      <Filter>AsmJit\asmjit\core</Filter>
    </ClInclude>
    <ClInclude Include="AsmJit\asmjit\core\logging.h">
      <Filter>AsmJit\asmjit\core</Filter>
    </ClInclude>
    <ClInclude Include="AsmJit\asmjit\core\memmgr.h">
      <Filter>AsmJit\asmjit\core</Filter>
    </ClInclude>
    <ClInclude Include="AsmJit\asmjit\core\misc_p.h">
      <Filter>AsmJit\asmjit\core</Filter>
    </ClInclude>
    <ClInclude Include="AsmJit\asmjit\core\operand.h">
      <Filter>AsmJit\asmjit\core</Filter>
    </ClInclude>
    <ClInclude Include="AsmJit\asmjit\core\osutils.h">
      <Filter>AsmJit\asmjit\core</Filter>
    </ClInclude>
    <ClInclude Include="AsmJit\asmjit\core\raassignment_p.h">
      <Filter>AsmJit\asmjit\core</Filter>
    </ClInclude>
    <ClInclude Include="AsmJit\asmjit\core\rabuilders_p.h">
      <Filter>AsmJit\asmjit\core</Filter>
    </ClInclude>
    <ClInclude Include="AsmJit\asmjit\core\radefs_p.h">
      <Filter>AsmJit\asmjit\core</Filter>
    </ClInclude>
    <ClInclude Include="AsmJit\asmjit\core\ralocal_p.h">
      <Filter>AsmJit\asmjit\core</Filter>
    </ClInclude>
    <ClInclude Include="AsmJit\asmjit\core\rapass_p.h">
      <Filter>AsmJit\asmjit\core</Filter>
    </ClInclude>
    <ClInclude Include="AsmJit\asmjit\core\rastack_p.h">
      <Filter>AsmJit\asmjit\core</Filter>
    </ClInclude>
    <ClInclude Include="AsmJit\asmjit\core\stringbuilder.h">
      <Filter>AsmJit\asmjit\core</Filter>
    </ClInclude>
    <ClInclude Include="AsmJit\asmjit\core\stringutils.h">
      <Filter>AsmJit\asmjit\core</Filter>
    </ClInclude>
    <ClInclude Include="AsmJit\asmjit\core\support.h">
      <Filter>AsmJit\asmjit\core</Filter>
    </ClInclude>
    <ClInclude Include="AsmJit\asmjit\core\target.h">
      <Filter>AsmJit\asmjit\core</Filter>
    </ClInclude>
    <ClInclude Include="AsmJit\asmjit\core\type.h">
      <Filter>AsmJit\asmjit\core</Filter>
    </ClInclude>
    <ClInclude Include="AsmJit\asmjit\core\zone.h">
      <Filter>AsmJit\asmjit\core</Filter>
    </ClInclude>
    <ClInclude Include="AsmJit\asmjit\core\zonehash.h">
      <Filter>AsmJit\asmjit\core</Filter>
    </ClInclude>
    <ClInclude Include="AsmJit\asmjit\core\zonelist.h">
      <Filter>AsmJit\asmjit\core</Filter>
    </ClInclude>
    <ClInclude Include="AsmJit\asmjit\core\zonestack.h">
      <Filter>AsmJit\asmjit\core</Filter>
    </ClInclude>
    <ClInclude Include="AsmJit\asmjit\core\zonestring.h">
      <Filter>AsmJit\asmjit\core</Filter>
    </ClInclude>
    <ClInclude Include="AsmJit\asmjit\core\zonetree.h">
      <Filter>AsmJit\asmjit\core</Filter>
    </ClInclude>
    <ClInclude Include="AsmJit\asmjit\core\zonevector.h">
      <Filter>AsmJit\asmjit\core</Filter>
    </ClInclude>
    <ClInclude Include="AsmJit\asmjit\x86\x86assembler.h">
      <Filter>AsmJit\asmjit\x86</Filter>
    </ClInclude>
    <ClInclude Include="AsmJit\asmjit\x86\x86builder.h">
      <Filter>AsmJit\asmjit\x86</Filter>
    </ClInclude>
    <ClInclude Include="AsmJit\asmjit\x86\x86callconv_p.h">
      <Filter>AsmJit\asmjit\x86</Filter>
    </ClInclude>
    <ClInclude Include="AsmJit\asmjit\x86\x86compiler.h">
      <Filter>AsmJit\asmjit\x86</Filter>
    </ClInclude>
    <ClInclude Include="AsmJit\asmjit\x86\x86emitter.h">
      <Filter>AsmJit\asmjit\x86</Filter>
    </ClInclude>
    <ClInclude Include="AsmJit\asmjit\x86\x86features.h">
      <Filter>AsmJit\asmjit\x86</Filter>
    </ClInclude>
    <ClInclude Include="AsmJit\asmjit\x86\x86globals.h">
      <Filter>AsmJit\asmjit\x86</Filter>
    </ClInclude>
    <ClInclude Include="AsmJit\asmjit\x86\x86instdb.h">
      <Filter>AsmJit\asmjit\x86</Filter>
    </ClInclude>
    <ClInclude Include="AsmJit\asmjit\x86\x86internal_p.h">
      <Filter>AsmJit\asmjit\x86</Filter>
    </ClInclude>
    <ClInclude Include="AsmJit\asmjit\x86\x86logging_p.h">
      <Filter>AsmJit\asmjit\x86</Filter>
    </ClInclude>
    <ClInclude Include="AsmJit\asmjit\x86\x86opcode_p.h">
      <Filter>AsmJit\asmjit\x86</Filter>
    </ClInclude>
    <ClInclude Include="AsmJit\asmjit\x86\x86operand.h">
      <Filter>AsmJit\asmjit\x86</Filter>
    </ClInclude>
    <ClInclude Include="AsmJit\asmjit\x86\x86rapass_p.h">
      <Filter>AsmJit\asmjit\x86</Filter>
    </ClInclude>
    <ClInclude Include="AsmJit\asmjit\x86\x86ssetoavx_p.h">
      <Filter>AsmJit\asmjit\x86</Filter>
    </ClInclude>
    <ClInclude Include="AsmJit\asmtk\asmparser.h">
      <Filter>AsmJit\asmtk</Filter>
    </ClInclude>
    <ClInclude Include="AsmJit\asmtk\asmtk.h">
      <Filter>AsmJit\asmtk</Filter>
    </ClInclude>
    <ClInclude Include="AsmJit\asmtk\asmtokenizer.h">
      <Filter>AsmJit\asmtk</Filter>
    </ClInclude>
    <ClInclude Include="AsmJit\asmtk\elfdefs.h">
      <Filter>AsmJit\asmtk</Filter>
    </ClInclude>
    <ClInclude Include="AsmJit\asmtk\globals.h">
      <Filter>AsmJit\asmtk</Filter>
    </ClInclude>
    <ClInclude Include="AsmJit\asmtk\parserutils.h">
      <Filter>AsmJit\asmtk</Filter>
    </ClInclude>
    <ClInclude Include="AsmJit\asmtk\strtod.h">
      <Filter>AsmJit\asmtk</Filter>
    </ClInclude>
    <ClInclude Include="HoShiMin%27s API\JitHelper.h">
      <Filter>HoShiMin%27s API</Filter>
    </ClInclude>
    <ClInclude Include="AvanguardDefence\SfcWrapper.h">
      <Filter>AvanguardDefence\Sfc</Filter>
    </ClInclude>
    <ClInclude Include="resource.h">
      <Filter>Файлы заголовков</Filter>
    </ClInclude>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="stdafx.cpp">
      <Filter>Исходные файлы</Filter>
    </ClCompile>
    <ClCompile Include="Avanguard.cpp">
      <Filter>Исходные файлы</Filter>
    </ClCompile>
    <ClCompile Include="AvanguardDefence\AntiDebugging.cpp">
      <Filter>AvanguardDefence\AntiDebugging</Filter>
    </ClCompile>
    <ClCompile Include="AvanguardDefence\AntiMacros.cpp">
      <Filter>AvanguardDefence\AntiMacros</Filter>
    </ClCompile>
    <ClCompile Include="AvanguardDefence\Encryption.cpp">
      <Filter>AvanguardDefence\Encryption</Filter>
    </ClCompile>
    <ClCompile Include="AvanguardDefence\HandlesKeeper.cpp">
      <Filter>AvanguardDefence\HandlesKeeper</Filter>
    </ClCompile>
    <ClCompile Include="AvanguardDefence\HeapManager.cpp">
      <Filter>AvanguardDefence\HandlesKeeper</Filter>
    </ClCompile>
    <ClCompile Include="AvanguardDefence\KernelUtils.cpp">
      <Filter>AvanguardDefence\KernelUtils</Filter>
    </ClCompile>
    <ClCompile Include="AvanguardDefence\KeSecuredMemory.cpp">
      <Filter>AvanguardDefence\KeSecuredMemory</Filter>
    </ClCompile>
    <ClCompile Include="AvanguardDefence\ThreadsFilter.cpp">
      <Filter>AvanguardDefence\ThreadsFilter</Filter>
    </ClCompile>
    <ClCompile Include="AvanguardDefence\ModulesFilter.cpp">
      <Filter>AvanguardDefence\ModulesFilter</Filter>
    </ClCompile>
    <ClCompile Include="AvanguardDefence\PEUtils.cpp">
      <Filter>AvanguardDefence\Encryption</Filter>
    </ClCompile>
    <ClCompile Include="AvanguardDefence\ProcessAPI.cpp">
      <Filter>AvanguardDefence\ProcessAPI</Filter>
    </ClCompile>
    <ClCompile Include="AvanguardDefence\TLS.cpp">
      <Filter>AvanguardDefence\TLS</Filter>
    </ClCompile>
    <ClCompile Include="AvanguardDefence\PEAnalyzer.cpp">
      <Filter>AvanguardDefence\PEAnalyzer</Filter>
    </ClCompile>
    <ClCompile Include="HoShiMin%27s API\StringsAPI.cpp">
      <Filter>HoShiMin%27s API</Filter>
    </ClCompile>
    <ClCompile Include="AvanguardDefence\ApisetResolver.cpp">
      <Filter>AvanguardDefence\ApiSet</Filter>
    </ClCompile>
    <ClCompile Include="AvanguardDefence\MemoryFilter.cpp">
      <Filter>AvanguardDefence\MemoryFilter</Filter>
    </ClCompile>
    <ClCompile Include="AvanguardDefence\MemoryCallbacks.cpp">
      <Filter>AvanguardDefence\MemoryFilter</Filter>
    </ClCompile>
    <ClCompile Include="AvanguardDefence\ModulesCallbacks.cpp">
      <Filter>AvanguardDefence\ModulesFilter</Filter>
    </ClCompile>
    <ClCompile Include="AvanguardDefence\MemoryStorage.cpp">
      <Filter>AvanguardDefence\MemoryFilter</Filter>
    </ClCompile>
    <ClCompile Include="AvanguardDefence\ModulesStorage.cpp">
      <Filter>AvanguardDefence\ModulesFilter</Filter>
    </ClCompile>
    <ClCompile Include="HoShiMin%27s API\DisasmHelper.cpp">
      <Filter>HoShiMin%27s API</Filter>
    </ClCompile>
    <ClCompile Include="AvanguardDefence\CheckHook.cpp">
      <Filter>AvanguardDefence\CheckHook</Filter>
    </ClCompile>
    <ClCompile Include="AvanguardDefence\Mitigations.cpp">
      <Filter>AvanguardDefence\MitigationsPolicy</Filter>
    </ClCompile>
    <ClCompile Include="AvanguardDefence\AppInitDlls.cpp">
      <Filter>AvanguardDefence\AppInitDlls</Filter>
    </ClCompile>
    <ClCompile Include="AvanguardDefence\WinTrusted.cpp">
      <Filter>AvanguardDefence\WinTrust</Filter>
    </ClCompile>
    <ClCompile Include="AvanguardDefence\ApcDispatcher.cpp">
      <Filter>AvanguardDefence\KiUserApcDispatcher</Filter>
    </ClCompile>
    <ClCompile Include="AvanguardDefence\hModules.cpp">
      <Filter>AvanguardDefence\hModules</Filter>
    </ClCompile>
    <ClCompile Include="AvanguardDefence\WinHooks.cpp">
      <Filter>AvanguardDefence\WinHooks</Filter>
    </ClCompile>
    <ClCompile Include="AvanguardDefence\AvnApi.cpp">
      <Filter>AvanguardDefence\AvnApi</Filter>
    </ClCompile>
    <ClCompile Include="AvanguardDefence\DACL.cpp">
      <Filter>AvanguardDefence\DACL</Filter>
    </ClCompile>
    <ClCompile Include="AvanguardDefence\HWID.cpp">
      <Filter>AvanguardDefence\HWIDs</Filter>
    </ClCompile>
    <ClCompile Include="AvanguardDefence\ContextFilter.cpp">
      <Filter>AvanguardDefence\ContextFilter</Filter>
    </ClCompile>
    <ClCompile Include="AvanguardDefence\ModulesUtils.cpp">
      <Filter>AvanguardDefence\ModulesUtils</Filter>
    </ClCompile>
    <ClCompile Include="AvanguardDefence\HWIDsUtils.cpp">
      <Filter>AvanguardDefence\HWIDs</Filter>
    </ClCompile>
    <ClCompile Include="AvanguardDefence\JavaBindings.cpp">
      <Filter>AvanguardDefence\JavaSupport\JavaBindings</Filter>
    </ClCompile>
    <ClCompile Include="HoShiMin%27s API\CodepageAPI.cpp">
      <Filter>HoShiMin%27s API</Filter>
    </ClCompile>
    <ClCompile Include="AvanguardDefence\ThreatElimination.cpp">
      <Filter>AvanguardDefence\ThreatEliminating</Filter>
    </ClCompile>
    <ClCompile Include="AvanguardDefence\Remapping.cpp">
      <Filter>AvanguardDefence\Remapping</Filter>
    </ClCompile>
    <ClCompile Include="AsmJit\asmtk\asmparser.cpp">
      <Filter>AsmJit\asmtk</Filter>
    </ClCompile>
    <ClCompile Include="AsmJit\asmtk\asmtokenizer.cpp">
      <Filter>AsmJit\asmtk</Filter>
    </ClCompile>
    <ClCompile Include="HoShiMin%27s API\JitHelper.cpp">
      <Filter>HoShiMin%27s API</Filter>
    </ClCompile>
    <ClCompile Include="AvanguardDefence\SfcWrapper.cpp">
      <Filter>AvanguardDefence\Sfc</Filter>
    </ClCompile>
  </ItemGroup>
  <ItemGroup>
    <Manifest Include="AvanguardDefence\SupportedOS.manifest">
      <Filter>Файлы ресурсов</Filter>
    </Manifest>
  </ItemGroup>
  <ItemGroup>
    <Library Include="t1ha\t1ha.x64.lib">
      <Filter>t1ha</Filter>
    </Library>
    <Library Include="Zydis\Zydis.x64.lib">
      <Filter>Zydis</Filter>
    </Library>
    <Library Include="MinHook\libMinHook.x64.lib">
      <Filter>MinHook</Filter>
    </Library>
    <Library Include="MinHook\libMinHook.x86.lib">
      <Filter>MinHook</Filter>
    </Library>
    <Library Include="t1ha\t1ha.x86.lib">
      <Filter>t1ha</Filter>
    </Library>
    <Library Include="Zydis\Zydis.x86.lib">
      <Filter>Zydis</Filter>
    </Library>
    <Library Include="JNI\lib\jvm.lib">
      <Filter>AvanguardDefence\JavaSupport\JNI\lib</Filter>
    </Library>
    <Library Include="AsmJit\lib\x86\asmjit.dbg.x86.lib">
      <Filter>AsmJit\lib\x86</Filter>
    </Library>
    <Library Include="AsmJit\lib\x86\asmjit.rel.x86.lib">
      <Filter>AsmJit\lib\x86</Filter>
    </Library>
    <Library Include="AsmJit\lib\x64\asmjit.dbg.x64.lib">
      <Filter>AsmJit\lib\x64</Filter>
    </Library>
    <Library Include="AsmJit\lib\x64\asmjit.rel.x64.lib">
      <Filter>AsmJit\lib\x64</Filter>
    </Library>
  </ItemGroup>
  <ItemGroup>
    <MASM Include="AvanguardDefence\ApcInterceptionRoutine.asm">
      <Filter>AvanguardDefence\KiUserApcDispatcher</Filter>
    </MASM>
  </ItemGroup>
  <ItemGroup>
    <ResourceCompile Include="Avanguard.rc">
      <Filter>Файлы ресурсов</Filter>
    </ResourceCompile>
  </ItemGroup>
</Project>
```

`Avanguard/AvanguardDefence/AntiDebugging.cpp`:

```cpp
#include "stdafx.h"
#include "AntiDebugging.h"

// Заколачиваем нули в PE-заголовок:
VOID ErasePEHeader(HMODULE hModule) {
    if (hModule == NULL) return;
#define PE_HEADER_SIZE 4 
    DWORD OldProtect;
    if (!VirtualProtect(hModule, PE_HEADER_SIZE, PAGE_READWRITE, &OldProtect)) return;
    ZeroMemory(hModule, PE_HEADER_SIZE);
    VirtualProtect(hModule, PE_HEADER_SIZE, OldProtect, &OldProtect);
}



VOID ChangeImageSize(HMODULE hModule, DWORD NewSize) {
    NTDEFINES::PPEB Peb = GetPEB(); // Получаем PEB
    NTDEFINES::PPEB_LDR_DATA PebLdrData = (NTDEFINES::PPEB_LDR_DATA)Peb->Ldr; // PEB->LDR_DATA - структура с инфой о модулях

    // Эта структура - двусвязный список, обходим его весь, пока не найдём наш модуль:
    NTDEFINES::PLDR_MODULE ListEntry = (NTDEFINES::PLDR_MODULE)PebLdrData->InLoadOrderModuleList.Flink;
    while (ListEntry && ListEntry->BaseAddress) {
        NTDEFINES::PLDR_MODULE LdrModule = (NTDEFINES::PLDR_MODULE)ListEntry;
        if (LdrModule->BaseAddress == hModule) { // Нашли наш модуль
            LdrModule->SizeOfImage = NewSize; // Выставляем новый размер модуля
            break;
        }
        ListEntry = (NTDEFINES::PLDR_MODULE)LdrModule->InLoadOrderModuleList.Flink;
    }
}

// Чистилка юникод-строк:
VOID DBG_CONVENTION FlushUnicodeString(PUNICODE_STRING UnicodeString) {
    UnicodeString->Buffer = NULL;
    UnicodeString->Length = 0;
    UnicodeString->MaximumLength = 0;
}

VOID FlushLdrData() {
    // Получаем указатели на PEB и LDR_DATA:
    NTDEFINES::PPEB Peb = GetPEB();
    NTDEFINES::PPEB_LDR_DATA PebLdrData = (NTDEFINES::PPEB_LDR_DATA)Peb->Ldr;

    // Чистим командную строку и путь к главному модулю:
    FlushUnicodeString(&Peb->ProcessParameters->CommandLine);
    FlushUnicodeString(&Peb->ProcessParameters->ImagePathName);

    // Обходим двусвязный список модулей:
    NTDEFINES::PLDR_MODULE ListEntry = (NTDEFINES::PLDR_MODULE)PebLdrData->InLoadOrderModuleList.Flink;
    while (ListEntry && ListEntry->BaseAddress) {
        NTDEFINES::PLDR_MODULE LdrModule = ListEntry;

        // У каждого чистим заголовок:
        ErasePEHeader((HMODULE)LdrModule->BaseAddress);
        
        // Стираем размер модуля, точку входа и адрес загрузки:
        LdrModule->SizeOfImage = 0;
        LdrModule->BaseAddress = 0x00000000;
        LdrModule->EntryPoint = 0x00000000;

        // Стираем имена модулей:
        FlushUnicodeString(&LdrModule->BaseDllName);
        FlushUnicodeString(&LdrModule->FullDllName);
        
        // Идём на следующий элемент в списке:
        ListEntry = (NTDEFINES::PLDR_MODULE)ListEntry->InLoadOrderModuleList.Flink;
    }
}

VOID DestroyDbgUiRemoteBreakin() {
    PVOID DbgUiRemoteBreakin = hModules::QueryAddress(hModules::hNtdll(), XORSTR("DbgUiRemoteBreakin"));
    if (DbgUiRemoteBreakin) {
        DWORD OldProtect;
        VirtualProtect(DbgUiRemoteBreakin, sizeof(DWORD), PAGE_EXECUTE_READWRITE, &OldProtect);
        *(PDWORD)DbgUiRemoteBreakin = 0x1EE7C0DE; // Ломаем функцию
        VirtualProtect(DbgUiRemoteBreakin, sizeof(DWORD), OldProtect, &OldProtect);
    }
}
```

`Avanguard/AvanguardDefence/AntiDebugging.h`:

```h
#pragma once

#include "PebTeb.h"
#include <intrin.h>

// https://wasm.in/threads/antiotladochnye-trjuki.15571/

#pragma comment(lib, "ntdll.lib")

/*
    Функции очистки PE-заголовков: при подключении к процессу отладчик
    попытается распарсить структуры PEB (Process Environment Block) и
    TEB (Thread Env. Block), где хранится вся информация о процессе
    на момент его создания: командная строка, список модулей и много что
    ещё - большая часть из той информации, что в ядре хранится
    в структуре EPROCESS. Если стереть информацию об адресах загрузки
    модулей из LDR-структур - отладчик не сможет понять, где точка входа.

    Определения PEB:
    - Из проекта ReactOS: https://doxygen.reactos.org/d0/d53/struct__PEB.html
    - Из Process Hacker'a: http://processhacker.sourceforge.net/doc/struct___p_e_b32.html

    Получить PEB:
    PPEB Peb32 = (PPEB)__readfsdword(0x30); // Для 32х-битных процессов (в 64х-битных Windows у Wow64-прцессов есть и Peb32, и Peb64)
    PPEB Peb64 = (PPEB)__readgsqword(0x60); // Для 64х-битных процессов

    Статья на хабре: https://habrahabr.ru/post/187226/
    Инфа из вики: https://en.wikipedia.org/wiki/Process_Environment_Block

    ErasePEHeader - стирает заголовок у выбранного модуля (использовать можно)
    FlushLdrFata - то же, что и ErasePEHeader, только для ВСЕХ модулей (использовать НЕЛЬЗЯ, т.к. ломается программа)
    ChangeImageSize - изменяет размер образа в заголовке, вводит в ступор многие отладчики
*/
VOID ErasePEHeader(HMODULE hModule);
VOID FlushLdrData();
VOID ChangeImageSize(HMODULE hModule, DWORD NewSize);

/*
    При подключении отладчика в отлаживаемом процессе вызывается
    функция DbgUiRemoteBreakin (ntdll.dll). Испортив её, мы сломаем процесс
    при попытке подключения к нему отладчика. По адресу функции
    записываю 4 байта 0x1EE7C0DE
*/
VOID DestroyDbgUiRemoteBreakin();

// С таким соглашением у нас будут работать функции антиотладки: 
// встраиваемые, и для скорости аргументы (если есть) идут в регистрах
#define DBG_CONVENTION __forceinline __fastcall

/*
    Эти два трюка основаны на результате функций IsDebuggerPresent и
    CheckRemoteDebuggerPresent (kernel32.dll) - возвращают TRUE/FALSE
    в зависимости от того, присоединён ли отладчик к нашему процессу
*/
BOOL DBG_CONVENTION CheckRDP();
BOOL DBG_CONVENTION CheckIDP();

/*
    Функция IsDebuggerPresent считывает поле "BeingDebugged" в PEB,
    функция CheckPebIDP считывает это поле напрямую из памяти
*/
BOOL DBG_CONVENTION CheckPebIDP();

/*
    Отлаживаемый процесс получает характеристику в виде специальных
    флагов в PEB->NtGlobalFlag - эти флаги необходимы для валидации кучи
    в случае её разрушения из-за, например, неправильных указателей, 
    переданных в delete. Отладчик должен уметь детектить такие ошибки,
    поэтому для кучи выставляются 3 флага валидации: FLG_HEAP_ENABLE_TAIL_CHECK,
    FLG_HEAP_ENABLE_FREE_CHECK и FLG_HEAP_VALIDATE_PARAMETERS. Если эти флаги есть - 
    процесс отлаживают.
*/
BOOL DBG_CONVENTION CheckNtGlobalFlag();

// Отцепляем текущий поток от отладчика: NtSetInformationThread(ThreadHideFromDebugger, ...)
VOID DBG_CONVENTION DetachFromDebugger(OPTIONAL HANDLE hThread = NULL);

/*
    Функцией NtQueryInformationProcess получаю сразу 3 отладочных характеристики из
    ядерной структуры EPROCESS: :
    наличие отладочного порта (через который отладчик и процесс обмениваются сообщениями),
    флага отладки и хэндла объекта отладчика:
*/
BOOL DBG_CONVENTION CheckDebugPortPresent();
BOOL DBG_CONVENTION CheckDebugFlagsPresent();
BOOL DBG_CONVENTION CheckDebugObjectPresent();

// Проверка на наличие ядерного отладчика (например, WinDBG + Kd через COM-порт на виртуалке или LiveKd):
// NtQuerySystemInformation(..., SystemKernelDebuggerInformation, ...)
BOOL DBG_CONVENTION CheckKernelDebuggerPresent();

/*
    Трюк основан на применении маски вывода отладочных сообщений.
    Если процесс отлаживается, функция NtSetDbgFilterState должна
    вернуть STATUS_SUCCESS (0x00000000).
    Статья: https://repo.palkeo.com/repositories/ivanlefou/todo/NtSetDebugFilterState.pdf
    НО! На Windows 10 она возвращает STATUS_SUCCESS даже когда отладчика нет.
    Поэтому очень НЕ рекомендуется использовать её в продакшне.
*/
BOOL DBG_CONVENTION CheckDbgFilterState(); // Поосторожнее с желаниями

// Смотрим, взведён ли флаг трассировки: EFLAGS -> [TrapFlag bit]:
BOOL DBG_CONVENTION CheckTrapFlag();

/*
    Следующий блок трюков основан на различном поведении инструкций
    и исключений при наличии отладчика и без него
*/

// Обработка исключений:

// Закрываем невалидный хэндл. С отладчиком будет вызвано исключение, без отладчика - не будет:
BOOL DBG_CONVENTION CheckNtClose();

// DbgBreakPoint из ntdll.dll - если есть отладчик, будет обработано как точка остановки,
// если отладчика нет - будет вызвано исключение, которое мы поймаем через __try..__except:
BOOL DBG_CONVENTION CheckDbgBreakPoint();

/*
    Генерим исключение через NtRaiseException:
    без отладчика попадём в __except:
*/
BOOL DBG_CONVENTION CheckNtRaiseException(); // Не использовать!

#ifdef _X86_

// Аналогично предыдущему пункту, только через непосредственный инлайн машинного кода 0xCC (точка остановки):
BOOL DBG_CONVENTION CheckInt3byCC();

/*
    Точка остановки - третье прерывание - может быть закодировано
    или через отдельную инструкцию (0xCC, мнемоники нет),
    или в явном виде через прерывание (0xCD 0x03 -> int 0x03),
    действует аналогично двум предыдущим пунктам, НО поведение
    обработчика прерывания в новых версиях Windows было изменено,
    и работать именно этот трюк не будет:
*/
BOOL DBG_CONVENTION CheckInt3byCD03(); // Не использовать!

/*
    Прерывание 0x2C - если отладчик есть, в EDX будет -1,
    без отладчика в EDX адрес следующей инструкции:
*/
BOOL DBG_CONVENTION CheckInt2C(); // Не использовать!

/*
    Источники:
    - https://forum.reverse4you.org/showthread.php?t=1329
    - http://resources.infosecinstitute.com/step-by-step-tutorial-on-reverse-engineering-malware-the-zeroaccessmaxsmiscer-crimeware-rootkit/
    Трюк с расщеплением байта: после прерывания 0x2D
    следующий байт будет пропущен, что вызовет исключение,
    которое без отладчика будет передано программе (__try..__except),
    а с отладчиком будет передану ему:
*/
BOOL DBG_CONVENTION CheckInt2D();

/*
    Точка остановки, аналог взведения TrapFlag в EFLAGS,
    включает пошаговое исполнение. Если отладчика нет - эксепшн,
    который мы ловим в __try..__except:
*/
BOOL DBG_CONVENTION CheckFrostPointF1(); // Не использовать!

/*
    Взводим флаг трассировки (бит TrapFlag в EFLAGS),
    без отладчика попадём в __except, с отладчиком
    исключения не будет:
*/
BOOL DBG_CONVENTION CheckTrapException(); // Не использовать!

#endif

// Импорты NativeAPI:

extern "C"
__declspec(dllimport)
NTSTATUS __stdcall 
NtSetInformationThread(
    HANDLE hThread, 
    THREAD_INFORMATION_CLASS ThreadInformationClass, 
    PVOID ThreadInformation, 
    ULONG ThreadInformationLength
);

extern "C"
__declspec(dllimport)
NTSTATUS __stdcall
NtSetDebugFilterState(
    ULONG ComponentId,
    ULONG Level,
    BOOLEAN State
);

extern "C"
__declspec(dllimport)
NTSTATUS __stdcall
DbgBreakPoint();


extern "C"
__declspec(dllimport)
NTSTATUS __stdcall
NtRaiseException(
    PEXCEPTION_RECORD ExceptionRecord,
    PCONTEXT ThreadContext,
    BOOLEAN HandleException
);

// Определения энумов и андок-структур http://hex.pp.ua/nt/
namespace NTDEFINES {
    typedef enum _THREAD_INFORMATION_CLASS {
        ThreadBasicInformation,
        ThreadTimes,
        ThreadPriority,
        ThreadBasePriority,
        ThreadAffinityMask,
        ThreadImpersonationToken,
        ThreadDescriptorTableEntry,
        ThreadEnableAlignmentFaultFixup,
        ThreadEventPair,
        ThreadQuerySetWin32StartAddress,
        ThreadZeroTlsCell,
        ThreadPerformanceCount,
        ThreadAmILastThread,
        ThreadIdealProcessor,
        ThreadPriorityBoost,
        ThreadSetTlsArrayAddress,
        ThreadIsIoPending,
        ThreadHideFromDebugger
    } THREAD_INFORMATION_CLASS, *PTHREAD_INFORMATION_CLASS;

    typedef enum _PROCESS_INFORMATION_CLASS {
        ProcessBasicInformation,
        ProcessQuotaLimits,
        ProcessIoCounters,
        ProcessVmCounters,
        ProcessTimes,
        ProcessBasePriority,
        ProcessRaisePriority,
        ProcessDebugPort,
        ProcessExceptionPort,
        ProcessAccessToken,
        ProcessLdtInformation,
        ProcessLdtSize,
        ProcessDefaultHardErrorMode,
        ProcessIoPortHandlers,
        ProcessPooledUsageAndLimits,
        ProcessWorkingSetWatch,
        ProcessUserModeIOPL,
        ProcessEnableAlignmentFaultFixup,
        ProcessPriorityClass,
        ProcessWx86Information,
        ProcessHandleCount,
        ProcessAffinityMask,
        ProcessPriorityBoost,
        ProcessDeviceMap,
        ProcessSessionInformation,
        ProcessForegroundInformation,
        ProcessWow64Information,
        ProcessImageFileName,
        ProcessLUIDDeviceMapsEnabled,
        ProcessBreakOnTermination,
        ProcessDebugObjectHandle,
        ProcessDebugFlags,
        ProcessHandleTracing,
        ProcessIoPriority,
        ProcessExecuteFlags,
        ProcessTlsInformation,
        ProcessCookie,
        ProcessImageInformation,
        ProcessCycleTime,
        ProcessPagePriority,
        ProcessInstrumentationCallback,
        ProcessThreadStackAllocation,
        ProcessWorkingSetWatchEx,
        ProcessImageFileNameWin32,
        ProcessImageFileMapping,
        ProcessAffinityUpdateMode,
        ProcessMemoryAllocationMode,
        ProcessGroupInformation,
        ProcessTokenVirtualizationEnabled,
        ProcessOwnerInformation,
        ProcessWindowInformation,
        ProcessHandleInformation,
        ProcessMitigationPolicy,
        ProcessDynamicFunctionTableInformation,
        ProcessHandleCheckingMode,
        ProcessKeepAliveCount,
        ProcessRevokeFileHandles,
        ProcessWorkingSetControl,
        ProcessHandleTable,
        ProcessCheckStackExtentsMode,
        ProcessCommandLineInformation,
        ProcessProtectionInformation,
        MaxProcessInfoClass
    } PROCESS_INFORMATION_CLASS, *PPROCESS_INFORMATION_CLASS;

    typedef enum _SYSTEM_INFORMATION_CLASS {
        SystemBasicInformation,
        SystemProcessorInformation,
        SystemPerformanceInformation,
        SystemTimeOfDayInformation,
        SystemPathInformation,
        SystemProcessInformation,
        SystemCallCountInformation,
        SystemDeviceInformation,
        SystemProcessorPerformanceInformation,
        SystemFlagsInformation,
        SystemCallTimeInformation,
        SystemModuleInformation,
        SystemLocksInformation,
        SystemStackTraceInformation,
        SystemPagedPoolInformation,
        SystemNonPagedPoolInformation,
        SystemHandleInformation,
        SystemObjectInformation,
        SystemPageFileInformation,
        SystemVdmInstemulInformation,
        SystemVdmBopInformation,
        SystemFileCacheInformation,
        SystemPoolTagInformation,
        SystemInterruptInformation,
        SystemDpcBehaviorInformation,
        SystemFullMemoryInformation,
        SystemLoadGdiDriverInformation,
        SystemUnloadGdiDriverInformation,
        SystemTimeAdjustmentInformation,
        SystemSummaryMemoryInformation,
        SystemMirrorMemoryInformation,
        SystemPerformanceTraceInformation,
        SystemObsolete0,
        SystemExceptionInformation,
        SystemCrashDumpStateInformation,
        SystemKernelDebuggerInformation
    } SYSTEM_INFORMATION_CLASS, *PSYSTEM_INFORMATION_CLASS;
}

typedef struct _SYSTEM_KERNEL_DEBUGGER_INFORMATION {
    BOOLEAN DebuggerEnabled;
    BOOLEAN DebuggerNotPresent;
} SYSTEM_KERNEL_DEBUGGER_INFORMATION, *PSYSTEM_KERNEL_DEBUGGER_INFORMATION;

BOOL DBG_CONVENTION CheckRDP() {
    BOOL RemoteDebuggerPresent;
    CheckRemoteDebuggerPresent(GetCurrentProcess(), &RemoteDebuggerPresent);
    return RemoteDebuggerPresent;
}

BOOL DBG_CONVENTION CheckIDP() {
    return IsDebuggerPresent();
}

BOOL DBG_CONVENTION CheckPebIDP() {
    return GetPEB()->BeingDebugged;
}

BOOL DBG_CONVENTION CheckNtGlobalFlag() {
#define FLG_HEAP_ENABLE_TAIL_CHECK		(0x10)
#define FLG_HEAP_ENABLE_FREE_CHECK		(0x20)
#define FLG_HEAP_VALIDATE_PARAMETERS	(0x40)
#define DBG_SUMMARY_FLAG	(FLG_HEAP_ENABLE_TAIL_CHECK | FLG_HEAP_ENABLE_FREE_CHECK | FLG_HEAP_VALIDATE_PARAMETERS)

#ifdef _AMD64_
#define NT_GLOBAL_FLAG_OFFSET 0x68
#else
#define NT_GLOBAL_FLAG_OFFSET 0xBC
#endif

    DWORD NtGlobalFlag = *(PDWORD)((PBYTE)GetPEB() + NT_GLOBAL_FLAG_OFFSET);
    return (NtGlobalFlag & DBG_SUMMARY_FLAG) != 0;
}

VOID DBG_CONVENTION DetachFromDebugger(OPTIONAL HANDLE hThread) {
    NtSetInformationThread(hThread == NULL ? GetCurrentThread() : hThread, (THREAD_INFORMATION_CLASS)NTDEFINES::ThreadHideFromDebugger, NULL, 0);
}

BOOL DBG_CONVENTION CheckDebugPortPresent() {
    HANDLE DebugPort;
    NtQueryInformationProcess(GetCurrentProcess(), (PROCESSINFOCLASS)NTDEFINES::ProcessDebugPort, &DebugPort, sizeof(DebugPort), NULL);
    return DebugPort != NULL;
}

BOOL DBG_CONVENTION CheckDebugFlagsPresent() {
    BOOL NoDebugInherit = FALSE;
    NtQueryInformationProcess(GetCurrentProcess(), (PROCESSINFOCLASS)NTDEFINES::ProcessDebugFlags, &NoDebugInherit, sizeof(NoDebugInherit), NULL);
    return !NoDebugInherit;
}

BOOL DBG_CONVENTION CheckDebugObjectPresent() {
    HANDLE DebugObjectHandle;
    NtQueryInformationProcess(GetCurrentProcess(), (PROCESSINFOCLASS)NTDEFINES::ProcessDebugObjectHandle, &DebugObjectHandle, sizeof(DebugObjectHandle), NULL);
    return DebugObjectHandle != NULL;
}

BOOL DBG_CONVENTION CheckKernelDebuggerPresent() {
    // Проверяем взведённость системных флажков, отвечающих за наличие ядерного отладчика:
    SYSTEM_KERNEL_DEBUGGER_INFORMATION SystemKernelDebuggerInfo;
    NtQuerySystemInformation((SYSTEM_INFORMATION_CLASS)NTDEFINES::SystemKernelDebuggerInformation, &SystemKernelDebuggerInfo, sizeof(SystemKernelDebuggerInfo), NULL);
    return SystemKernelDebuggerInfo.DebuggerEnabled && !SystemKernelDebuggerInfo.DebuggerNotPresent;
}

BOOL DBG_CONVENTION CheckDbgFilterState() {
    // Сбрасываем фильтрацию отладочных сообщений:
    return NtSetDebugFilterState(0, 0, TRUE) == ERROR_SUCCESS;
}

BOOL DBG_CONVENTION CheckNtClose() {
    __try {
        NtClose((HANDLE)0x1EE7C0DE); // Закрываем невалидный хэндл
        return FALSE; // Исключений не было, отладчика нет
    } __except(EXCEPTION_EXECUTE_HANDLER) {
        return TRUE; // Было сгенерено исключение, есть отладчик
    }
}

BOOL DBG_CONVENTION CheckDbgBreakPoint() {
    __try {
        DbgBreakPoint(); // Генерация брейкпоинта через NativeAPI
        return TRUE; // Брейкпоинт обработан, есть отладчик
    } __except (EXCEPTION_EXECUTE_HANDLER) {
        return FALSE; // Брейкпоинт не обработан, отладчика нет
    }
}

BOOL DBG_CONVENTION CheckNtRaiseException() {
    __try {
        CONTEXT Context;
        RtlCaptureContext(&Context);

        EXCEPTION_RECORD ExceptionRecord;
        ExceptionRecord.ExceptionCode = EXCEPTION_INVALID_HANDLE;
        ExceptionRecord.ExceptionFlags = 0; // EXCEPTION_CONTINUABLE
        ExceptionRecord.ExceptionAddress = 0x00000000;
        ExceptionRecord.ExceptionRecord = &ExceptionRecord;
        ExceptionRecord.NumberParameters = 0;
        
        NtRaiseException(&ExceptionRecord, &Context, TRUE); // Поднимаем исключение
        return TRUE; // Обработано, есть отладчик
    } __except (EXCEPTION_EXECUTE_HANDLER) {
        return FALSE; // Не обработано, отладчика нет
    }
}

#ifdef _X86_

BOOL DBG_CONVENTION CheckInt3byCC() {
    __try {
        __asm __emit 0xCC; // int 0x03 (0xCC)
        return TRUE; // Брейкпоинт обработан, есть отладчик
    } __except (EXCEPTION_EXECUTE_HANDLER) {
        return FALSE; // Брейкпоинт не обработан, отладчика нет
    }
}

BOOL DBG_CONVENTION CheckInt3byCD03() {
    __try {
        __asm {
            nop
            __emit 0xCD // --+
            __emit 0x03 // --+--> int 03h (0xCD 0x03)
            nop
        }
        return TRUE; // Брейкпоинт обработан, есть отладчик
    } __except (EXCEPTION_EXECUTE_HANDLER) {
        return FALSE; // Брейкпоинт не обработан, отладчика нет
    }
}

BOOL DBG_CONVENTION CheckInt2C() {
    __try {
        DWORD _EDX = 0;
        __asm {
            int 0x2C
            mov _EDX, edx
        }
        return _EDX == 0xFFFFFFFF; // Если есть отладчик, EDX равен -1
    } __except (EXCEPTION_EXECUTE_HANDLER) {
        return FALSE;
    }
}

BOOL DBG_CONVENTION CheckInt2D() {
    __try {
        __asm {
            int 0x2D // Пропуск байта
            nop
        }
        return TRUE; // Исключение обработано отладчиком
    } __except (EXCEPTION_EXECUTE_HANDLER) {
        return FALSE; // Отладчика нет, исключение не обработано
    }
}

BOOL DBG_CONVENTION CheckFrostPointF1() {
    __try {
        __asm __emit 0xF1; // Машинный код точки заморозки (0xF1)
        return TRUE; // Обработано (Single-Step), есть отладчик
    } __except (EXCEPTION_EXECUTE_HANDLER) {
        return FALSE; // Нет отладчика, исключение не обработано
    }
}

BOOL DBG_CONVENTION CheckTrapException() {
    __try {
        __asm {
            pushfd	// Кладём EFLAGS на стек
            or [esp], 0x100 // Взводим TrapFlag
            popfd	// Загружаем новый EFLAGS
            nop		// Здесь должен быть Single-Step
        }
        return TRUE; // Исключение обработано отладчиком, нас отлаживают
    }
    __except (EXCEPTION_EXECUTE_HANDLER) {
        return FALSE; // Исключение не обработано, отладчика нет
    }
}

BOOL DBG_CONVENTION CheckTrapFlag() {
    BOOL TrapFlag = FALSE;
    __asm {
        pushfd			// Кладём на стек регистр флагов
        pop eax			// Со стека в EAX
        and eax, 0x100	// Проверяем взведённость бита TrapFlag
        mov TrapFlag, eax 
    }
    return TrapFlag; // Если флаг не взведён - всё ок, нас не трассируют
}

#endif
```

`Avanguard/AvanguardDefence/AntiMacros.cpp`:

```cpp
#include "stdafx.h"
#include "AntiMacros.h"

HHOOK VirtualInput::hMouseHook = NULL;
HHOOK VirtualInput::hKeyboardHook = NULL;
_HkFilterCallback VirtualInput::OnVirtualMouseCallback = NULL;
_HkFilterCallback VirtualInput::OnVirtualKeyboardCallback = NULL;

LRESULT CALLBACK VirtualInput::LowLevelMouseProc(
    _In_ int    nCode,
    _In_ WPARAM wParam,
    _In_ LPMSLLHOOKSTRUCT lParam
) {
    return (nCode >= 0) && (lParam->flags & LLMHF_INJECTED) 
        ? (OnVirtualMouseCallback 
            ? (OnVirtualMouseCallback(nCode, wParam, (LPARAM)lParam) == HK_EVENT_RESULT::HkEventPass 
                ? CallNextHookEx(hMouseHook, nCode, wParam, (LPARAM)lParam) 
                : HK_EVENT_RESULT::HkEventCancel) 
            : HK_EVENT_RESULT::HkEventCancel)
        : CallNextHookEx(hMouseHook, nCode, wParam, (LPARAM)lParam);
}

LRESULT CALLBACK VirtualInput::LowLevelKeyboardProc(
    _In_ int    nCode,
    _In_ WPARAM wParam,
    _In_ LPKBDLLHOOKSTRUCT lParam
) {
    return (nCode >= 0) && (lParam->flags & LLKHF_INJECTED)
        ? (OnVirtualKeyboardCallback
            ? (OnVirtualKeyboardCallback(nCode, wParam, (LPARAM)lParam) == HK_EVENT_RESULT::HkEventPass
                ? CallNextHookEx(hKeyboardHook, nCode, wParam, (LPARAM)lParam)
                : HK_EVENT_RESULT::HkEventCancel)
            : HK_EVENT_RESULT::HkEventCancel)
        : CallNextHookEx(hKeyboardHook, nCode, wParam, (LPARAM)lParam);
}

BOOL VirtualInput::SetupFilter(HOOK_TYPE HookType, IN OPTIONAL _HkFilterCallback OnVirtualEventCallback) {
    switch (HookType) {
    case HkKeyboard:
        OnVirtualKeyboardCallback = OnVirtualEventCallback;
        if (hKeyboardHook == NULL)
            hKeyboardHook = SetWindowsHookEx(WH_KEYBOARD_LL, (HOOKPROC)LowLevelKeyboardProc, NULL, 0);
        return hKeyboardHook != NULL;

    case HkMouse:
        OnVirtualMouseCallback = OnVirtualEventCallback;
        if (hMouseHook == NULL)
            hMouseHook = SetWindowsHookEx(WH_MOUSE_LL, (HOOKPROC)LowLevelMouseProc, NULL, 0);
        return hMouseHook != NULL;

    default:
        return FALSE;
    }
}

BOOL VirtualInput::RemoveFilter(HOOK_TYPE HookType) {
    BOOL Status = TRUE;
    switch (HookType) {
    case HkKeyboard:
        if (hKeyboardHook) {
            Status = UnhookWindowsHookEx(hKeyboardHook);
            if (Status) hKeyboardHook = NULL;
        }
    case HkMouse:
        if (hMouseHook) {
            Status = UnhookWindowsHookEx(hMouseHook);
            if (Status) hMouseHook = NULL;
        }
        break;
    default:
        Status = FALSE;
    }
    return Status;
}
```

`Avanguard/AvanguardDefence/AntiMacros.h`:

```h
#pragma once

#include <Windows.h>

enum HOOK_TYPE {
    HkKeyboard,
    HkMouse
};

enum HK_EVENT_RESULT {
    HkEventPass,
    HkEventCancel
};

typedef HK_EVENT_RESULT (CALLBACK *_HkFilterCallback)(
    int nCode,
    WPARAM wParam,
    LPARAM lParam // LPMSLLHOOKSTRUCT или LPKBDLLHOOKSTRUCT
);

class VirtualInput final {
private:
    static HHOOK hMouseHook;
    static HHOOK hKeyboardHook;
    static _HkFilterCallback OnVirtualMouseCallback;
    static _HkFilterCallback OnVirtualKeyboardCallback;
    static LRESULT CALLBACK LowLevelMouseProc(int nCode, WPARAM wParam, LPMSLLHOOKSTRUCT lParam);
    static LRESULT CALLBACK LowLevelKeyboardProc(int nCode, WPARAM wParam, LPKBDLLHOOKSTRUCT lParam);
public:
    // Если OnVirtualEventCallback == NULL, отменяет весь виртуальный ввод:
    static BOOL SetupFilter(HOOK_TYPE HookType, IN OPTIONAL _HkFilterCallback OnVirtualEventCallback = NULL);
    static BOOL RemoveFilter(HOOK_TYPE HookType);
};
```

`Avanguard/AvanguardDefence/ApcDispatcher.cpp`:

```cpp
#include "stdafx.h"
#include "ApcDispatcher.h"

typedef NTSTATUS(NTAPI *_NtContinue)(
    IN PCONTEXT	ThreadContext,
    IN BOOLEAN	RaiseAlert
);

const _NtContinue NtContinue = (_NtContinue)hModules::QueryAddress(hModules::hNtdll(), XORSTR("NtContinue"));
const _NtTestAlert NtTestAlert = (_NtTestAlert)hModules::QueryAddress(hModules::hNtdll(), XORSTR("NtTestAlert"));

static PVOID pKiUserApcDispatcher;
static _ApcCallback ApcCallback = NULL;

#ifdef _AMD64_
extern "C" void KiUserApcHandler();
extern "C" PVOID OrgnlKiUserApcDispatcher;

PVOID OrgnlKiUserApcDispatcher;

extern "C"
BOOL NTAPI ApcHandler(PCONTEXT Context) {
    PVOID ApcProc = (PVOID)Context->P1Home;
    PVOID ReturnAddress = (PVOID)Context->Rip;
    if (ApcCallback) 
        if (ApcCallback(ApcProc, ReturnAddress))
            return TRUE;
    return NT_SUCCESS(NtContinue(Context, FALSE));
}
#else 
typedef VOID (NTAPI *_KiUserApcDispatcher)(
    PVOID NormalRoutine, 
    PVOID SystemArgument1, 
    PVOID SystemArgument2, 
    CONTEXT Context
);

_KiUserApcDispatcher OrgnlKiUserApcDispatcher;

__declspec(naked)
VOID NTAPI HkdKiUserApcDispatcher(
    PVOID NormalRoutine,	// ApcProc
    PVOID SystemArgument1,	// Argument
    PVOID SystemArgument2,
    CONTEXT Context
) {
    __asm {
// Выравниваем базу аргументов:
        push ebp
        mov ebp, esp
        
// Вызываем каллбэк:
        mov eax, ApcCallback
        test eax, eax
        jz Continue
        mov ecx, Context.Eip
        mov eax, NormalRoutine
        push ecx
        push eax
        call ApcCallback
        test eax, eax
        jz Continue // Возвращаемся без вызова APC
        
// Возвращаем стек в исходное состояние:
        mov esp, ebp
        pop ebp

// Уходим на KiUserApcDispatcher:
        jmp OrgnlKiUserApcDispatcher
        ret // Если что-то пойдёт не так

Continue:
        lea ecx, Context // Запоминаем адрес Context
        
// Возвращаем стек в исходное состояние:
        mov esp, ebp
        pop ebp

        push FALSE
        push ecx
        call NtContinue // Отсюда мы уже не вернёмся
        ret // А вдруг?
    }
}
#endif

BOOL ApcDispatcher::Initialized = FALSE;

BOOL ApcDispatcher::EnableApcFilter() {
    if (Initialized) return TRUE;
    
    MH_Initialize();
    pKiUserApcDispatcher = hModules::QueryAddress(hModules::hNtdll(), XORSTR("KiUserApcDispatcher"));
#ifdef _AMD64_
    MH_STATUS MhStatus = MH_CreateHook(pKiUserApcDispatcher, &KiUserApcHandler, (LPVOID*)&OrgnlKiUserApcDispatcher);
#else
    MH_STATUS MhStatus = MH_CreateHook(pKiUserApcDispatcher, HkdKiUserApcDispatcher, (LPVOID*)&OrgnlKiUserApcDispatcher);
#endif
    if (MhStatus == MH_OK) MhStatus = MH_EnableHook(pKiUserApcDispatcher);
    if (MhStatus != MH_OK) MH_RemoveHook(pKiUserApcDispatcher);

    return Initialized = MhStatus == MH_OK;
}

VOID ApcDispatcher::DisableApcFilter() {
    if (!Initialized) return;
    MH_DisableHook(pKiUserApcDispatcher);
    MH_RemoveHook(pKiUserApcDispatcher);
    ApcDispatcher::Initialized = FALSE;
}

VOID ApcDispatcher::SetupApcCallback(_ApcCallback Callback) {
    ApcCallback = Callback;
}
```

`Avanguard/AvanguardDefence/ApcDispatcher.h`:

```h
#pragma once

#include <winternl.h>
#include "hModules.h"
#include "..\\HoShiMin's API\\HookHelper.h"

/*
    ApcProc - APC-процедура
    Continue - адрес возврата на продолжение
*/

typedef NTSTATUS(NTAPI *_NtTestAlert)();
extern const _NtTestAlert NtTestAlert;

typedef BOOL (NTAPI *_ApcCallback)(PVOID ApcProc, PVOID Continue);

class ApcDispatcher final {
private:
    static BOOL Initialized;
public:
    static VOID SetupApcCallback(_ApcCallback Callback);
    static BOOL EnableApcFilter();
    static VOID DisableApcFilter();
};
```

`Avanguard/AvanguardDefence/ApcInterceptionRoutine.asm`:

```asm
EXTERN ApcHandler: PROC
EXTERN OrgnlKiUserApcDispatcher: PROC

PUBLIC KiUserApcHandler

.CODE
    KiUserApcHandler PROC
        push rax
        push rcx
        mov rcx, rsp
        add rcx, 16
        call ApcHandler
        test rax, rax
        pop rcx
        pop rax
        jz Exit
        mov rax, OrgnlKiUserApcDispatcher
        mov rax, [rax]
        jmp rax
Exit:
        ret
    KiUserApcHandler ENDP

END
```

`Avanguard/AvanguardDefence/ApisetResolver.cpp`:

```cpp
#include "stdafx.h"
#include "ApisetResolver.h"

#pragma region APISET v2

typedef struct _API_SET_NAMESPACE2 {
    ULONG Version;
    ULONG Count;
    // API_SET_NAMESPACE_ENTRY Descriptor[0];
} API_SET_NAMESPACE2, *PAPI_SET_NAMESPACE2;

typedef struct _API_SET_NAMESPACE_ENTRY2 {
    ULONG NameOffset;
    ULONG NameLength;
    ULONG RedirectorOffset;
} API_SET_NAMESPACE_ENTRY2, *PAPI_SET_NAMESPACE_ENTRY2;

typedef struct _API_SET_REDIRECTOR2 {
    ULONG NumberOfRedirections;
    // API_SET_VALUE_ENTRY Entries[0];
} API_SET_REDIRECTOR2, *PAPI_SET_REDIRECTOR2;

#pragma pack(push)
#pragma pack(4)
typedef struct _API_SET_VALUE_ENTRY2 {
    ULONG	NameOffset;
    USHORT	NameLength;
    ULONG	ValueOffset;
    USHORT	ValueLength;
} API_SET_VALUE_ENTRY2, *PAPI_SET_VALUE_ENTRY2;
#pragma pack(pop)

#pragma endregion

#pragma region APISET v4

typedef struct _API_SET_NAMESPACE4 {
    ULONG Version; 
    ULONG Size;
    ULONG Flags;
    ULONG Count;
    // API_SET_NAMESPACE_ENTRY4 Array[0];
} API_SET_NAMESPACE4, *PAPI_SET_NAMESPACE4;

typedef struct _API_SET_NAMESPACE_ENTRY4 {
    ULONG Flags;
    ULONG NameOffset;
    ULONG NameLength;
    ULONG AliasOffset;
    ULONG AliasLength;
    ULONG DataOffset; // Offset to API_SET_VALUE_ENTRY4
} API_SET_NAMESPACE_ENTRY4, *PAPI_SET_NAMESPACE_ENTRY4;

typedef struct _API_SET_VALUE_ENTRY4 {
    ULONG Flags;
    ULONG NumberOfRedirections;
    // API_SET_VALUE_ENTRY4 Array[0];
} API_SET_VALUE_ENTRY4, *PAPI_SET_VALUE_ENTRY4;

typedef struct _API_SET_VALUE_INFO4 {
    ULONG Flags;
    ULONG NameOffset;
    ULONG NameLength;
    ULONG ValueOffset;
    ULONG ValueLength;
} API_SET_VALUE_INFO4, *PAPI_SET_VALUE_INFO4;

#pragma endregion

#pragma region APISET v6

typedef struct _API_SET_NAMESPACE6 {
    ULONG Version;
    ULONG Size;
    ULONG Flags;
    ULONG Count;
    ULONG EntryOffset;
    ULONG HashOffset;
    ULONG HashFactor;
} API_SET_NAMESPACE6, *PAPI_SET_NAMESPACE6;

typedef struct _API_SET_HASH_ENTRY6 {
    ULONG Hash;
    ULONG Index;
} API_SET_HASH_ENTRY6, *PAPI_SET_HASH_ENTRY6;

typedef struct _API_SET_NAMESPACE_ENTRY6 {
    ULONG Flags;
    ULONG NameOffset;
    ULONG NameLength;
    ULONG HashedLength;
    ULONG ValueOffset;
    ULONG ValueCount;
} API_SET_NAMESPACE_ENTRY6, *PAPI_SET_NAMESPACE_ENTRY6;

typedef struct _API_SET_VALUE_ENTRY6 {
    ULONG Flags;
    ULONG NameOffset;
    ULONG NameLength;
    ULONG ValueOffset;
    ULONG ValueLength;
} API_SET_VALUE_ENTRY6, *PAPI_SET_VALUE_ENTRY6;

#pragma endregion

VLIBS_MAP* VLibsMap = NULL;

// PAPI_SET_NAMESPACE:
PVOID GetApiSetPtr() {
#ifdef _AMD64_
    return *(PVOID*)((PBYTE)GetPEB() + 0x68);
#else
    return *(PVOID*)((PBYTE)GetPEB() + 0x38);
#endif
}

void InsertVLib(const std::wstring& VLibName, const REAL_LIBS_SET& LibsSet) {
    const std::wstring DllPostfix(L".dll");
    const std::wstring ApiPrefix(L"api-");
    const std::wstring ExtPrefix(L"ext-");

    std::wstring NormalizedVLibName = LowerCase(VLibName);
    if (!EndsWith(NormalizedVLibName, DllPostfix)) NormalizedVLibName += DllPostfix;

    if (StartsWith(NormalizedVLibName, ApiPrefix) || StartsWith(NormalizedVLibName, ExtPrefix)) {
        VLibsMap->emplace(NormalizedVLibName, LibsSet);
        return;
    }

    VLibsMap->emplace(NormalizedVLibName, LibsSet);
    VLibsMap->emplace(ApiPrefix + NormalizedVLibName, LibsSet);
    VLibsMap->emplace(ExtPrefix + NormalizedVLibName, LibsSet);
}

void _FillApiSetMap2() {
    WCHAR Buffer[MAX_PATH];

    PAPI_SET_NAMESPACE2 ApiSetMap = (PAPI_SET_NAMESPACE2)GetApiSetPtr();
    PAPI_SET_NAMESPACE_ENTRY2 ApiSetNsEntry = (PAPI_SET_NAMESPACE_ENTRY2)((PBYTE)ApiSetMap + sizeof(*ApiSetMap));
    for (unsigned int i = 0; i < ApiSetMap->Count; i++) {
        RtlMoveMemory(Buffer, (LPWSTR)((PBYTE)ApiSetMap + ApiSetNsEntry->NameOffset), ApiSetNsEntry->NameLength);
        Buffer[ApiSetNsEntry->NameLength / sizeof(WCHAR)] = (WCHAR)0x0000;

        std::wstring VLibName(Buffer);

        REAL_LIBS_SET RealLibsSet;

        PAPI_SET_REDIRECTOR2 Redirector = (PAPI_SET_REDIRECTOR2)((PBYTE)ApiSetMap + ApiSetNsEntry->RedirectorOffset);
        PAPI_SET_VALUE_ENTRY2 Value = (PAPI_SET_VALUE_ENTRY2)((PBYTE)Redirector + sizeof(*Redirector));
        for (unsigned int j = 0; j < Redirector->NumberOfRedirections; j++) {
            if (Value->ValueOffset == 0 && Value->ValueLength == 0) {
                Value++;
                continue;
            }

            RtlMoveMemory(Buffer, (LPWSTR)((PBYTE)ApiSetMap + Value->ValueOffset), Value->ValueLength);
            Buffer[Value->ValueLength / sizeof(WCHAR)] = (WCHAR)0x0000;
            RealLibsSet.emplace(Buffer);
            Value++;
        }

        InsertVLib(VLibName, RealLibsSet);
        ApiSetNsEntry++;
    }
}

void _FillApiSetMap4() {
    WCHAR Buffer[MAX_PATH];

    PAPI_SET_NAMESPACE4 ApiSetMap = (PAPI_SET_NAMESPACE4)GetApiSetPtr();
    PAPI_SET_NAMESPACE_ENTRY4 ApiSetNsEntry = (PAPI_SET_NAMESPACE_ENTRY4)((PBYTE)ApiSetMap + sizeof(*ApiSetMap));
    for (unsigned int i = 0; i < ApiSetMap->Count; i++) {
        RtlMoveMemory(Buffer, (LPWSTR)((PBYTE)ApiSetMap + ApiSetNsEntry->NameOffset), ApiSetNsEntry->NameLength);
        Buffer[ApiSetNsEntry->NameLength / sizeof(WCHAR)] = (WCHAR)0x0000;

        std::wstring VLibName(Buffer);

        PAPI_SET_VALUE_ENTRY4 ValueEntry =
            (PAPI_SET_VALUE_ENTRY4)((PBYTE)ApiSetMap + ApiSetNsEntry->DataOffset);
        ULONG RedirectionsCount = ValueEntry->NumberOfRedirections;
        PAPI_SET_VALUE_INFO4 ValueInfo = (PAPI_SET_VALUE_INFO4)((PBYTE)ValueEntry + sizeof(*ValueEntry));

        REAL_LIBS_SET RealLibsSet;
        for (unsigned int j = 0; j < RedirectionsCount; j++) {
            if (ValueInfo->ValueOffset == 0 && ValueInfo->ValueLength == 0) {
                ValueInfo++;
                continue;
            }

            RtlMoveMemory(Buffer, ((PBYTE)ApiSetMap + ValueInfo->ValueOffset), ValueInfo->ValueLength);
            Buffer[ValueInfo->ValueLength / sizeof(WCHAR)] = (WCHAR)0x0000;

            RealLibsSet.emplace(Buffer);
            ValueInfo++;
        }

        InsertVLib(VLibName, RealLibsSet);
        ApiSetNsEntry++;
    }
}

void _FillApiSetMap6() {
    WCHAR Buffer[MAX_PATH];

    PAPI_SET_NAMESPACE6 ApiSetMap = (PAPI_SET_NAMESPACE6)GetApiSetPtr();
    PAPI_SET_NAMESPACE_ENTRY6 ApiSetNsEntry =
        (PAPI_SET_NAMESPACE_ENTRY6)((PBYTE)ApiSetMap + sizeof(*ApiSetMap));
    for (unsigned int i = 0; i < ApiSetMap->Count; i++) {
        RtlMoveMemory(Buffer, (LPWSTR)((PBYTE)ApiSetMap + ApiSetNsEntry->NameOffset), ApiSetNsEntry->NameLength);
        Buffer[ApiSetNsEntry->NameLength / sizeof(WCHAR)] = (WCHAR)0x0000;

        std::wstring VLibName(Buffer);

        ULONG RedirectionsCount = ApiSetNsEntry->ValueCount;
        PAPI_SET_VALUE_ENTRY6 ValueEntry =
            (PAPI_SET_VALUE_ENTRY6)((PBYTE)ApiSetMap + ApiSetNsEntry->ValueOffset);

        REAL_LIBS_SET RealLibsSet;
        for (unsigned int j = 0; j < RedirectionsCount; j++) {
            if (ValueEntry->ValueOffset == 0 && ValueEntry->ValueLength == 0) {
                ValueEntry++;
                continue;
            }
            
            RtlMoveMemory(Buffer, ((PBYTE)ApiSetMap + ValueEntry->ValueOffset), ValueEntry->ValueLength);
            Buffer[ValueEntry->ValueLength / sizeof(WCHAR)] = (WCHAR)0x0000;

            RealLibsSet.emplace(Buffer);
            ValueEntry++;
        }

        InsertVLib(VLibName, RealLibsSet);
        ApiSetNsEntry++;
    }
}

void FillApiSetMap() {
    if (VLibsMap == NULL)
        VLibsMap = new VLIBS_MAP();

    static bool Filled = false;
    if (Filled) return;

    if (!IsWindows7OrGreater()) {
        Filled = true;
        return;
    }

    ULONG Version = *(PULONG)GetApiSetPtr();
    switch (Version) {
    case 2:
        _FillApiSetMap2();
        break;
    case 4:
        _FillApiSetMap4();
        break;
    case 6:
        _FillApiSetMap6();
        break;
    default:
        std::exception("Unknown ApiSet version!");
    }

    Filled = true;
}

const VLIBS_MAP* GetVLibsMap() {
    FillApiSetMap();
    return VLibsMap;
}

bool ResolveDllName(const std::wstring& DllName, REAL_LIBS_SET& ResolvedNames) {
    std::wstring Name = ExtractFileName(DllName);
    LowerCaseRef(Name);

    ResolvedNames.clear();

    FillApiSetMap();
    
    const auto& Entry = VLibsMap->find(Name);
    bool Resolved = Entry != VLibsMap->end();
    if (Resolved) ResolvedNames = Entry->second;
    return Resolved;
}
```

`Avanguard/AvanguardDefence/ApisetResolver.h`:

```h
#pragma once

#include <Windows.h>
#include <VersionHelpers.h>

#include <string>
#include <unordered_map>
#include <unordered_set>

#include "PebTeb.h"
#include "..\\HoShiMin's API\\StringsAPI.h"

// VirtualLibName -> std::set<RealLibName>:
typedef std::unordered_set<std::wstring> REAL_LIBS_SET;
typedef std::unordered_map<std::wstring, REAL_LIBS_SET> VLIBS_MAP;

const VLIBS_MAP* GetVLibsMap();
bool ResolveDllName(const std::wstring& DllName, REAL_LIBS_SET& ResolvedNames);
```

`Avanguard/AvanguardDefence/AppInitDlls.cpp`:

```cpp
#include "stdafx.h"
#include "AppInitDlls.h"

BOOL AppInitDlls::Enabled = FALSE;
BOOL AppInitDlls::Initialized = FALSE;
HOOK_INFO AppInitDlls::HookInfo;

INTERCEPTION(VOID, WINAPI, LoadAppInitDlls) {
    return;
}

BOOL AppInitDlls::Initialize() {
    if (Initialized) return TRUE;
    HookInfo = INTERCEPTION_ENTRY(
        hModules::QueryAddress(hModules::hKernel32(), XORSTR("LoadAppInitDlls")),
        LoadAppInitDlls
    );
    return Initialized = HookInfo.TargetProc != NULL;
}

BOOL AppInitDlls::DisableAppInitDlls() {
    if (!Initialized && !Initialize()) return FALSE;
    if (Enabled) return TRUE;
    MH_Initialize();
    return Enabled = HookEmAll(&HookInfo, 1);
}

VOID AppInitDlls::EnableAppInitDlls() {
    if (!Initialized && !Initialize()) return;
    if (Enabled) {
        UnHookEmAll(&HookInfo, 1);
        Enabled = FALSE;
    }
}
```

`Avanguard/AvanguardDefence/AppInitDlls.h`:

```h
#pragma once

#include "hModules.h"
#include "..\\HoShiMin's API\\HookHelper.h"

class AppInitDlls final {
private:
    static BOOL Enabled;
    static BOOL Initialized;
    static HOOK_INFO HookInfo;
    static BOOL Initialize();
public:
    static BOOL DisableAppInitDlls();
    static VOID EnableAppInitDlls();
};
```

`Avanguard/AvanguardDefence/AvnApi.cpp`:

```cpp
#include "stdafx.h"
#include "AvnApi.h"

#include "WinTrusted.h"
#include "ModulesCallbacks.h"
#include "MemoryCallbacks.h"
#include "HWIDsUtils.h"
#include "ThreatElimination.h"

#include "SfcWrapper.h"

AVN_API AvnApi;
static CRITICAL_SECTION CriticalSection;

extern BOOL AvnStartDefence();
extern VOID AvnStopDefence();
extern BOOL IsAvnStarted;
extern BOOL IsAvnStaticLoaded;

BOOL WINAPI AvnStart() {
    return AvnStartDefence();
}

VOID WINAPI AvnStop() {
    AvnStopDefence();
}

BOOL WINAPI AvnIsStarted() {
    return IsAvnStarted;
}

BOOL WINAPI AvnIsStaticLoaded() {
    return IsAvnStaticLoaded;
}

VOID WINAPI AvnRegisterThreatNotifier(OPTIONAL _AvnThreatNotifier Notifier) {
    SetupNotificationRoutine(Notifier);
}

VOID WINAPI AvnEliminateThreat(AVN_THREAT Threat, OPTIONAL PVOID Data) {
    EliminateThreat(Threat, Data, etTerminate);
}

VOID WINAPI AvnLock() {
    EnterCriticalSection(&CriticalSection);
}

VOID WINAPI AvnUnlock() {
    LeaveCriticalSection(&CriticalSection);
}

VOID WINAPI AvnRehashModule(HMODULE hModule) {
#ifdef MODULES_FILTER
    ValidModulesStorage.RecalcModuleHash(hModule);
#else
    return;
#endif
}

BOOL WINAPI AvnIsModuleValid(HMODULE hModule) {
#ifdef MODULES_FILTER
    return ValidModulesStorage.IsCodeSectionsValid(hModule);
#else
    return TRUE;
#endif
}

BOOL WINAPI AvnIsFileProtected(LPCWSTR FilePath) {
    return Sfc::IsFileProtected(FilePath);
}

BOOL WINAPI AvnIsFileSigned(LPCWSTR FilePath, BOOL CheckRevocation) {
    return IsFileSigned(FilePath, CheckRevocation);
}

BOOL WINAPI AvnVerifyEmbeddedSignature(LPCWSTR FilePath) {
    return IsFileSigned(FilePath, TRUE);
    //return VerifyEmbeddedSignature(FilePath);
}

BOOL WINAPI AvnIsAddressAllowed(PVOID Address, BOOL IncludeJitMemory) {
    MEMORY_BASIC_INFORMATION MemoryInfo = { 0 };
    VirtualQuery(Address, &MemoryInfo, sizeof(MemoryInfo));
    if ((MemoryInfo.Protect & EXECUTABLE_MEMORY) == 0) return TRUE;

    HMODULE hModule = GetModuleBase(Address);
    if (hModule == NULL) {
#ifdef MEMORY_FILTER
        if (!IncludeJitMemory) return FALSE;
        return VMStorage.IsMemoryInMap(Address);
#else
        return FALSE;
#endif
    }
    return ValidModulesStorage.IsModuleInStorage(hModule);
}

UINT64 WINAPI AvnGetCpuid() {
    return HWIDs::GetCpuid();
}

UINT64 WINAPI AvnGetSmbiosId() {
    return HWIDs::GetSmbiosId();
}

UINT64 WINAPI AvnGetMacId() {
    return HWIDs::GetMacId();
}

UINT64 WINAPI AvnGetHddId() {
    return HWIDs::GetHddId();
}

UINT64 WINAPI AvnHash(PVOID Data, ULONG Size) {
    return t1ha(Data, Size, 0x1EE7C0DEC0FFEE);
}

#ifdef TIMERED_CHECKINGS

VOID WINAPI AvnSetCheckTime(INT check_time) {
	setTstTime((int)check_time);
}

INT WINAPI AvnGetCheckTime() {
	return (INT)getTstTime();
}

#endif

VOID AvnInitializeApi() {
    InitializeCriticalSectionAndSpinCount(&CriticalSection, 0xC0000000);
    AvnApi.AvnStart                     = AvnStart;
    AvnApi.AvnStop                      = AvnStop;
    AvnApi.AvnIsStarted                 = AvnIsStarted;
    AvnApi.AvnIsStaticLoaded            = AvnIsStaticLoaded;
    AvnApi.AvnRegisterThreatNotifier    = AvnRegisterThreatNotifier;
    AvnApi.AvnEliminateThreat           = AvnEliminateThreat;
    AvnApi.AvnLock                      = AvnLock;
    AvnApi.AvnUnlock                    = AvnUnlock;
    AvnApi.AvnRehashModule              = AvnRehashModule;
    AvnApi.AvnIsModuleValid             = AvnIsModuleValid;
    AvnApi.AvnIsFileProtected           = AvnIsFileProtected;
    AvnApi.AvnIsFileSigned              = AvnIsFileSigned;
    AvnApi.AvnVerifyEmbeddedSignature   = AvnVerifyEmbeddedSignature;
    AvnApi.AvnIsAddressAllowed          = AvnIsAddressAllowed;
#ifdef TIMERED_CHECKINGS
	AvnApi.AvnGetCheckTime              = AvnGetCheckTime;
	AvnApi.AvnSetCheckTime              = AvnSetCheckTime;
#endif
    AvnApi.AvnGetCpuid                  = AvnGetCpuid;
    AvnApi.AvnGetSmbiosId               = AvnGetSmbiosId;
    AvnApi.AvnGetMacId                  = AvnGetMacId;
    AvnApi.AvnGetHddId                  = AvnGetHddId;
    AvnApi.AvnHash                      = AvnHash;
}
```

`Avanguard/AvanguardDefence/AvnApi.h`:

```h
#pragma once

#include <Windows.h>
#include "ThreatTypes.h"
#include "AvnDefinitions.h"

typedef BOOL    (WINAPI *_AvnStart)();
typedef VOID    (WINAPI *_AvnStop)();
typedef BOOL    (WINAPI *_AvnIsStarted)();
typedef BOOL    (WINAPI *_AvnIsStaticLoaded)();
typedef VOID    (WINAPI *_AvnRegisterThreatNotifier)(OPTIONAL _AvnThreatNotifier Notifier);
typedef VOID    (WINAPI *_AvnEliminateThreat)(AVN_THREAT Threat, OPTIONAL PVOID Data);
typedef VOID    (WINAPI *_AvnLock)();
typedef VOID    (WINAPI *_AvnUnlock)();
typedef VOID    (WINAPI *_AvnRehashModule)(HMODULE hModule);
typedef BOOL    (WINAPI *_AvnIsModuleValid)(HMODULE hModule);
typedef BOOL    (WINAPI *_AvnIsFileProtected)(LPCWSTR FilePath);
typedef BOOL    (WINAPI *_AvnIsFileSigned)(LPCWSTR FilePath, BOOL CheckRevocation);
typedef BOOL    (WINAPI *_AvnVerifyEmbeddedSignature)(LPCWSTR FilePath);
typedef BOOL    (WINAPI *_AvnIsAddressAllowed)(PVOID Address, BOOL IncludeJitMemory);
#ifdef TIMERED_CHECKINGS
typedef INT     (WINAPI *_AvnGetCheckTime)();
typedef VOID    (WINAPI *_AvnSetCheckTime)(INT check_time);
#endif
typedef UINT64  (WINAPI *_AvnGetCpuid)();
typedef UINT64  (WINAPI *_AvnGetSmbiosId)();
typedef UINT64  (WINAPI *_AvnGetMacId)();
typedef UINT64  (WINAPI *_AvnGetHddId)();
typedef UINT64  (WINAPI *_AvnHash)(PVOID Data, ULONG Size);

typedef struct _AVN_API {
    _AvnStart                   AvnStart;                   // Synchronized
    _AvnStop                    AvnStop;                    // Synchronized
    _AvnIsStarted               AvnIsStarted;               // Doesn't need synchronization
    _AvnIsStaticLoaded          AvnIsStaticLoaded;          // Doesn't need synchronization
    _AvnRegisterThreatNotifier  AvnRegisterThreatNotifier;  // Doesn't need synchronization
    _AvnEliminateThreat         AvnEliminateThreat;         // Doesn't need synchronization
    _AvnLock                    AvnLock;
    _AvnUnlock                  AvnUnlock;
    _AvnRehashModule            AvnRehashModule;
    _AvnIsModuleValid           AvnIsModuleValid;
    _AvnIsFileProtected         AvnIsFileProtected;
    _AvnIsFileSigned            AvnIsFileSigned;
    _AvnVerifyEmbeddedSignature AvnVerifyEmbeddedSignature;
    _AvnIsAddressAllowed        AvnIsAddressAllowed;
#ifdef TIMERED_CHECKINGS
	_AvnGetCheckTime            AvnGetCheckTime;
	_AvnSetCheckTime            AvnSetCheckTime;
#endif
    _AvnGetCpuid                AvnGetCpuid;                 // Doesn't need synchronization
    _AvnGetSmbiosId             AvnGetSmbiosId;              // Doesn't need synchronization
    _AvnGetMacId                AvnGetMacId;                 // Doesn't need synchronization
    _AvnGetHddId                AvnGetHddId;                 // Doesn't need synchronization
    _AvnHash                    AvnHash;                     // Doesn't need synchronization
} AVN_API, *PAVN_API;
```

`Avanguard/AvanguardDefence/AvnDefinitions.h`:

```h
#pragma once

//#define DEBUG_OUTPUT /* Дебаг вывод */

//#define SELF_REMAPPING /* Ремаппинг кодовой секции Avanguard.dll с RX-правами, beta */

//#define SKIP_VIRTUAL_INPUT /* Анти-кликеры и анти-макросы */

#define STRICT_DACLs        /* Урезать права, с которыми могут открыть наш процесс */
//#define MITIGATIONS       /* Сажает FPS с JIT'ом */
#define SKIP_APP_INIT_DLLS  /* Предотвращать инжект через AppInitDlls */
#define THREADS_FILTER      /* Предотвращать инжект через CreateRemoteThread */
//#define MODULES_FILTER      /* Собирать информацию о загружаемых модулях */
#define APC_FILTER          /* Предотвращать инжект через APC */
//#define MEMORY_FILTER       /* Собирать информацию о выделенной памяти */
//#define STACKTRACE_CHECK    /* Если есть JIT, использовать ТОЛЬКО с MEMORY_FILTER */

#define JAVA_BINDINGS   /* Поддержка привязки к Java через JNI */

#ifdef MODULES_FILTER
    // Предотвращать инжект через оконные хуки:
    #define WINDOWS_HOOKS_FILTER
#endif

#if defined MODULES_FILTER && defined MEMORY_FILTER
    // Отслеживать угон контекста:
    #define CONTEXT_FILTER
#endif
#define CRITICAL_MODULES { L"jvm.dll", L"java.dll" }
#ifdef TIMERED_CHECKINGS
    // Период проверки:
	#define DEFALT_TIMER_INTERVAL 3000
    #ifdef MODULES_FILTER
        #define FIND_CHANGED_MODULES /* Искать модифицированные модули */
        #ifdef FIND_CHANGED_MODULES
            // Модули, в которых не допускается модификация:
            #define CRITICAL_MODULES { L"jvm.dll", L"java.dll" }
        #endif
    #endif

    #ifdef MEMORY_FILTER
        // Искать память, выделенную из чужих процессов:
        #define FIND_UNKNOWN_MEMORY
    #endif

    // Закрывать свои хэндлы в чужих процессах:
    //#define HANDLES_KEEPER
#endif

/* Не менять! Используется программой. */
#ifdef TIMERED_CHECKINGS
	int getTstTime();
	void setTstTime(int);
	#define TIMER_INTERVAL getTstTime()
#endif

```

`Avanguard/AvanguardDefence/CheckHook.cpp`:

```cpp
#include "stdafx.h"
#include "CheckHook.h"

#define GetAbsolutePtr(InstrPtr, AddrOffset) (*(PVOID*)((PBYTE)InstrPtr + (AddrOffset)))
#define Relative2Absolute(InstrPtr, AddrOffset, InstrLength) (PVOID)((SIZE_T)InstrPtr + (*(PLONG)((PBYTE)InstrPtr + AddrOffset)) + InstrLength)

PVOID FollowTheWhiteRabbit(PVOID Address) {
#ifdef _X86_
    // Проверка на сплайсинг через jmp (0xE9):
    if (*(PBYTE)Address == 0xE9) return Relative2Absolute(Address, 1, 5);

    // Проверка на push -> ret:
    if (*(PBYTE)Address == 0x68 && *((PBYTE)Address + 5) == 0xC3) return GetAbsolutePtr(Address, 1);

    // Проверка на mov eax, Addr -> jmp eax:
    if (*(PBYTE)Address == 0xB8 && *(PWORD)((PBYTE)Address + 5) == 0xE0FF) return GetAbsolutePtr(Address, 1);

    // Проверка на jmp cs:Address:
    if (*(PWORD)Address == 0xFF2E) return GetAbsolutePtr(Address, 2);
#endif

#ifdef _AMD64_
    // Проверка на сплайсинг через jmp (0xE9):
    if (*(PBYTE)Address == 0xE9) return Relative2Absolute(Address, 1, 5);

    // Проверка на mov rax, Addr -> jmp rax:
    if (*(PWORD)Address == 0xB849 && *(PWORD)((PBYTE)Address + 10) == 0xE0FF) return GetAbsolutePtr(Address, 2);

    // Проверка на jmp cs:Address:
    if (*(PWORD)Address == 0x25FF && *(PULONG)((PBYTE)Address + 2) == 0x00000000) return GetAbsolutePtr(Address, 6);

    // Проверка на jmp [rip + 0xNNNNNNNN]:
    if (*(PWORD)Address == 0x25FF && *(PULONG)((PBYTE)Address + 2) != 0x00000000) return Relative2Absolute(Address, 2, 6);

    // Проверка на mov rax, Address -> push rax -> ret:
    if (*(PWORD)Address == 0xB848 && *(PWORD)((PBYTE)Address + 10) == 0xC350) return GetAbsolutePtr(Address, 2);
#endif

    return NULL; // The rabbit's hole has no end...
}

PVOID FindHookDestination(PVOID Address) {
    PVOID JumpTo = FollowTheWhiteRabbit(Address);
    if (JumpTo == NULL) return NULL;

    do {
        PVOID Trampoline = FollowTheWhiteRabbit(JumpTo);
        if (Trampoline == NULL) return JumpTo;
        JumpTo = Trampoline;
    } while (JumpTo);
    return JumpTo;
}
```

`Avanguard/AvanguardDefence/CheckHook.h`:

```h
#pragma once

#include <Windows.h>

// Получить адрес прыжка, если он есть:
PVOID FollowTheWhiteRabbit(PVOID Address);

// Получить конечный адрес:
PVOID FindHookDestination(PVOID Address);
```

`Avanguard/AvanguardDefence/ContextFilter.cpp`:

```cpp
#include "stdafx.h"
#include "ContextFilter.h"

BOOL ContextFilter::Initialized = FALSE;
BOOL ContextFilter::Enabled = FALSE;
HOOK_INFO ContextFilter::HookInfo[2] = { 0 };
_NtContinue ContextFilter::NtContinue = NULL;
_NtContinue ContextFilter::OrgnlNtContinue = NULL;
_NtSetContextThread ContextFilter::NtSetContextThread = NULL;
_NtSetContextThread ContextFilter::OrgnlNtSetContextThread = NULL;
_NtContinueCallback ContextFilter::NtContinueCallback = NULL;
_PreNtSetContextThread ContextFilter::PreSetContext = NULL;
_PostNtSetContextThread ContextFilter::PostSetContext = NULL;

BOOL ContextFilter::Initialize() {
    if (Initialized) return TRUE;
    NtContinue = (_NtContinue)hModules::QueryAddress(hModules::hNtdll(), XORSTR("NtContinue"));
    NtSetContextThread = (_NtSetContextThread)hModules::QueryAddress(hModules::hNtdll(), XORSTR("NtSetContextThread"));

    HookInfo[0] = INTERCEPTION_ENTRY(NtContinue, NtContinue);
    HookInfo[1] = INTERCEPTION_ENTRY(NtSetContextThread, NtSetContextThread);

    return Initialized = NtContinue && NtSetContextThread;
}

NTSTATUS NTAPI ContextFilter::HkdNtContinue(PCONTEXT Context, BOOL TestAlert) {
    PRE_FILTRATE_TO(
        NTSTATUS, Status, NtContinue, NtContinueCallback,
        Context, TestAlert
    );
    return Status;
}

NTSTATUS NTAPI ContextFilter::HkdNtSetContextThread(HANDLE ThreadHandle, PCONTEXT Context) {
    FILTRATE_TO(
        NTSTATUS, Status, NtSetContextThread, PreSetContext, PostSetContext,
        ThreadHandle, Context
    );
    return Status;
}

BOOL ContextFilter::EnableContextFilter() {
    if (!Initialized && !Initialize()) return FALSE;
    if (Enabled) return TRUE;

    MH_Initialize();
    return Enabled = HookEmAll(HookInfo, sizeof(HookInfo) / sizeof(HookInfo[0]));
}

VOID ContextFilter::DisableContextFilter() {
    if (!Initialized && !Initialize()) return;
    if (!Enabled) return;
    UnHookEmAll(HookInfo, sizeof(HookInfo) / sizeof(HookInfo[0]));
    Enabled = FALSE;
}

VOID ContextFilter::SetupContextCallbacks(
    OPTIONAL _NtContinueCallback PreNtContinue,
    OPTIONAL _PreNtSetContextThread PreNtSetContextThread,
    OPTIONAL _PostNtSetContextThread PostNtSetContextThread
) {
    NtContinueCallback = PreNtContinue;
    PreSetContext = PreNtSetContextThread;
    PostSetContext = PostNtSetContextThread;
}



```

`Avanguard/AvanguardDefence/ContextFilter.h`:

```h
#pragma once

#include <Windows.h>
#include "hModules.h"
#include "..\\HoShiMin's API\\HookHelper.h"

typedef NTSTATUS(NTAPI *_NtContinue)(PCONTEXT Context, BOOL TestAlert);
typedef NTSTATUS(NTAPI *_NtSetContextThread)(HANDLE ThreadHandle, PCONTEXT Context);

typedef NTSTATUS(NTAPI *_NtContinueCallback)(
    OUT PBOOL SkipOriginalCall,
    PCONTEXT Context,
    BOOL TestAlert
);

typedef NTSTATUS(NTAPI *_PreNtSetContextThread)(
    OUT PBOOL SkipOriginalCall,
    HANDLE ThreadHandle,
    PCONTEXT Context
);

typedef NTSTATUS(NTAPI *_PostNtSetContextThread)(
    IN NTSTATUS ReturnValue,
    HANDLE ThreadHandle,
    PCONTEXT Context
);

class ContextFilter final {
private:
    static BOOL Initialized, Enabled;
    static BOOL Initialize();
    static HOOK_INFO HookInfo[2];
    static _NtContinue NtContinue, OrgnlNtContinue;
    static _NtSetContextThread NtSetContextThread, OrgnlNtSetContextThread;
    static _NtContinueCallback NtContinueCallback;
    static _PreNtSetContextThread PreSetContext;
    static _PostNtSetContextThread PostSetContext;
    static NTSTATUS NTAPI HkdNtContinue(PCONTEXT Context, BOOL TestAlert);
    static NTSTATUS NTAPI HkdNtSetContextThread(HANDLE ThreadHandle, PCONTEXT Context);
public:
    static VOID SetupContextCallbacks(
        OPTIONAL _NtContinueCallback PreNtContinue = NULL, 
        OPTIONAL _PreNtSetContextThread PreNtSetContextThread = NULL,
        OPTIONAL _PostNtSetContextThread PostNtSetContextThread = NULL
    );
    static BOOL EnableContextFilter();
    static VOID DisableContextFilter();
};
```

`Avanguard/AvanguardDefence/DACL.cpp`:

```cpp
#include "stdafx.h"
#include "DACL.h"

DACL::DACL(HANDLE hObject) {
    this->hObject = hObject;
    SidCurrentUser = AllocCurrentUserSid();
    SidEveryone = AllocEveryoneSid();
    SidSystem = AllocSystemSid();
    SidAdministrators = AllocAdministratorsSid();
}

DACL::~DACL() {
    if (TokenInfo) delete[] TokenInfo;
    if (SidEveryone) FreeSid(SidEveryone);
    if (SidSystem) FreeSid(SidSystem);
    if (SidAdministrators) FreeSid(SidAdministrators);
}



PSID DACL::AllocCurrentUserSid() {
    PSID Sid = NULL;
    BOOL Status = FALSE;

    HANDLE hToken;
    Status = OpenProcessToken(GetCurrentProcess(), TOKEN_READ, &hToken);
    if (!Status) goto Exit;

    // Получаем размер инфы токена:
    DWORD Size = 0;
    GetTokenInformation(hToken, TokenUser, NULL, 0, &Size);
    if (!Size) goto Exit;

    // Выделяем память под инфу о токене:
    TokenInfo = (PTOKEN_USER)new BYTE[Size];
    if (TokenInfo == NULL) goto Exit;

    // Получаем инфу о токене:
    Status = GetTokenInformation(hToken, TokenUser, TokenInfo, Size, &Size);
    if (!Status) goto Exit;

    // Получаем SID текущего пользователя:
    Sid = TokenInfo->User.Sid;

Exit:
    CloseHandle(hToken);

    return Sid;
}

PSID DACL::AllocEveryoneSid() {
    PSID Sid = NULL;
    BOOL Status = FALSE;
    SID_IDENTIFIER_AUTHORITY SidIdentifier = SECURITY_WORLD_SID_AUTHORITY;
    Status = AllocateAndInitializeSid(&SidIdentifier, 1, SECURITY_WORLD_RID, 0, 0, 0, 0, 0, 0, 0, &Sid);
    return Status ? Sid : NULL;
}

PSID DACL::AllocSystemSid() {
    PSID Sid = NULL;
    BOOL Status = FALSE;
    SID_IDENTIFIER_AUTHORITY SidIdentifier = SECURITY_NT_AUTHORITY;
    Status = AllocateAndInitializeSid(&SidIdentifier, 1, SECURITY_LOCAL_SYSTEM_RID, 0, 0, 0, 0, 0, 0, 0, &Sid);
    return Status ? Sid : NULL;
}

PSID DACL::AllocAdministratorsSid() {
    PSID Sid = NULL;
    BOOL Status = FALSE;
    SID_IDENTIFIER_AUTHORITY SidIdentifier = SECURITY_NT_AUTHORITY;
    Status = AllocateAndInitializeSid(&SidIdentifier, 2, SECURITY_BUILTIN_DOMAIN_RID, DOMAIN_ALIAS_RID_ADMINS, 0, 0, 0, 0, 0, 0, &Sid);
    return Status ? Sid : NULL;
}

PSID DACL::GetSid(SID_OBJECT SidObject) {
    switch (SidObject) {
    case sidCurrentUser: return SidCurrentUser;
    case sidEveryone: return SidEveryone;
    case sidSystem: return SidSystem;
    case sidAdministrators: return SidAdministrators;
    default: return FALSE;
    }
}



BOOL DACL::Allow(SID_OBJECT SidObject, ULONG AccessRights) {
    PSID Sid = GetSid(SidObject);
    if (Sid == NULL) return FALSE;

    DACL_CAPABILITY Capability;
    Capability.Sid = Sid;
    Capability.SidAction = SID_ACTION::Allow;
    Capability.AccessRights = AccessRights;
    DACLs.emplace_back(Capability);
    return TRUE;
}

BOOL DACL::Deny(SID_OBJECT SidObject, ULONG AccessRights) {
    PSID Sid = GetSid(SidObject);
    if (Sid == NULL) return FALSE;

    DACL_CAPABILITY Capability;
    Capability.Sid = Sid;
    Capability.SidAction = SID_ACTION::Deny;
    Capability.AccessRights = AccessRights;
    DACLs.emplace_back(Capability);
    return TRUE;
}

BOOL DACL::Apply() {
    // Рассчитываем суммарный размер ACL:
    DWORD AclSize = sizeof(ACL);
    for (const auto& Capability : DACLs) {
        AclSize += GetLengthSid(Capability.Sid) - sizeof(DWORD);
        switch (Capability.SidAction) {
        case SID_ACTION::Allow:
            AclSize += sizeof(ACCESS_ALLOWED_ACE);
            break;
        case SID_ACTION::Deny:
            AclSize += sizeof(ACCESS_DENIED_ACE);
            break;
        }
    }

    BOOL Status = FALSE;

    // Выделяем память под DACL:
    PACL Dacl = (PACL)new BYTE[AclSize];
    if (Dacl == NULL) return Status;

    // Инициализируем DACL:
    Status = InitializeAcl(Dacl, AclSize, ACL_REVISION);
    if (!Status) goto Exit;

    // Устанавливаем правила:
    for (const auto& Capability : DACLs) {
        switch (Capability.SidAction) {
        case SID_ACTION::Allow:
            Status = AddAccessAllowedAce(Dacl, ACL_REVISION, Capability.AccessRights, Capability.Sid);
            break;
        case SID_ACTION::Deny:
            Status = AddAccessDeniedAce(Dacl, ACL_REVISION, Capability.AccessRights, Capability.Sid);
            break;
        default:
            Status = FALSE;
        }
        if (!Status) goto Exit;
    }

    // Создаём SECURITY_DESCRIPTOR:
    SECURITY_DESCRIPTOR SecurityDescriptor;
    Status = InitializeSecurityDescriptor(&SecurityDescriptor, SECURITY_DESCRIPTOR_REVISION);
    if (!Status) goto Exit;

    Status = SetSecurityDescriptorDacl(&SecurityDescriptor, TRUE, Dacl, FALSE);
    if (!Status) goto Exit;

    // Устанавливаем SECURITY_DESCRIPTOR:
    DWORD Result = SetSecurityInfo(
        hObject,
        SE_KERNEL_OBJECT,
        OWNER_SECURITY_INFORMATION | DACL_SECURITY_INFORMATION,
        SidCurrentUser,
        NULL,
        Dacl,
        NULL
    );
    Status = Result == ERROR_SUCCESS;

Exit:
    delete[] Dacl;
    return Status;
}
```

`Avanguard/AvanguardDefence/DACL.h`:

```h
#pragma once

#include <Windows.h>
#include <AclAPI.h>

#include <vector>

typedef enum _SID_OBJECT {
    sidCurrentUser,
    sidEveryone,
    sidSystem,
    sidAdministrators
} SID_OBJECT, *PSID_OBJECT;

typedef enum _SID_ACTION {
    Allow,
    Deny
} SID_ACTION, *PSID_ACTION;

typedef struct _DACL_CAPABILITY {
    PSID Sid;
    SID_ACTION SidAction;
    DWORD AccessRights;
} DACL_CAPABILITY, *PDACL_CAPABILITY;

class DACL {
private:
    HANDLE hObject;

    PTOKEN_USER TokenInfo = NULL;
    PSID SidCurrentUser, SidEveryone, SidSystem, SidAdministrators;
    std::vector<DACL_CAPABILITY> DACLs;

    PSID AllocCurrentUserSid();
    PSID AllocEveryoneSid();
    PSID AllocSystemSid();
    PSID AllocAdministratorsSid();

    PSID GetSid(SID_OBJECT SidObject);
public:
    DACL(HANDLE hObject);
    ~DACL();
    
    BOOL Allow(SID_OBJECT SidObject, ULONG AccessRights);
    BOOL Deny(SID_OBJECT SidObject, ULONG AccessRights);
    BOOL Apply();
};
```

`Avanguard/AvanguardDefence/Encryption.cpp`:

```cpp
#include "stdafx.h"
#include "Encryption.h"

#define UNLOCK_MEM(Address, Size, pOldProtect) VirtualProtect((Address), (Size), PAGE_EXECUTE_READWRITE, (pOldProtect))
#define RESTORE_MEM(Address, Size, OldProtect) VirtualProtect((Address), (Size), (OldProtect), (&OldProtect))

PVOID FASTCALL FindSignature(PVOID StartAddress, PVOID Signature) {
    UINT64	CryptHigh = *(PUINT64)Signature;
    ULONG	CryptLow = *(PULONG)((PUINT64)Signature + 1);
    PBYTE Address = (PBYTE)StartAddress;
    while ((*(PUINT64)Address != CryptHigh) || (*(PULONG)(Address + 8) != CryptLow)) Address++;
    return Address;
}

VOID FORCEINLINE FASTCALL FastXOR(PCODE_BLOCK_INFO CodeBlock) {
    PBYTE DataFinalAddress = (PBYTE)CodeBlock->Address + CodeBlock->Size;
    for (PBYTE pData = (PBYTE)CodeBlock->Address; pData < DataFinalAddress; pData++) {
        *pData ^= ENCRYPTION_KEY;
    }
}


enum RELOCS_SWITCH_TYPE {
    AddRelocs,
    SubRelocs
};

VOID FORCEINLINE FASTCALL FixupRelocs(RELOCS_SET &RelocsSet, RELOCS_SWITCH_TYPE SwitchType) {
    DWORD Delta = (DWORD)ModuleInfo.Delta;

    switch (SwitchType) {
    case AddRelocs:
        for (PDWORD Address : RelocsSet) {
            *Address += Delta;
        }
        break;

    case SubRelocs:
        for (PDWORD Address : RelocsSet) {
            *Address -= Delta;
        }
        break;
    }
}

VOID FASTCALL EncryptDecrypt(PCODE_BLOCK_INFO CodeBlock, RELOCS_SET &RelocsSet) {
#ifndef CODEPAGES_ARE_WRITEABLE
    DWORD OldProtect;
    UNLOCK_MEM(CodeBlock->Address, CodeBlock->Size, &OldProtect);
#endif

    FixupRelocs(RelocsSet, SubRelocs);
    FastXOR(CodeBlock);
    FixupRelocs(RelocsSet, AddRelocs);

#ifndef CODEPAGES_ARE_WRITEABLE
    RESTORE_MEM(CodeBlock->Address, CodeBlock->Size, OldProtect);
#endif
}

```

`Avanguard/AvanguardDefence/Encryption.h`:

```h
#pragma once

#include <Windows.h>
#include <vector>
#include "PEUtils.h"

#define ENABLE_ENCRYPTION

#define ENCRYPTION_KEY 0xAA

PVOID FASTCALL FindSignature(PVOID StartAddress, PVOID Signature);

VOID FASTCALL EncryptDecrypt(PCODE_BLOCK_INFO CodeBlock, RELOCS_SET &RelocsSet);

#ifdef ENABLE_ENCRYPTION

#define $90 __nop();
#define $CC __debugbreak();

#define CRYPT_SIGNATURE_BEGIN	$CC $CC $90 $90 $CC $90 $CC $90 $CC $CC $90 $90
#define CRYPT_SIGNATURE_END		$90 $90 $CC $CC $90 $CC $90 $CC $90 $90 $CC $CC 

#ifdef _AMD64_

#define CRYPT_SIG_LENGTH 12
const unsigned char
CryptSigStart[CRYPT_SIG_LENGTH] = { 0xCC, 0xCC, 0x90, 0x90, 0xCC, 0x90, 0xCC, 0x90, 0xCC, 0xCC, 0x90, 0x90 },
CryptSigStop[CRYPT_SIG_LENGTH] = { 0x90, 0x90, 0xCC, 0xCC, 0x90, 0xCC, 0x90, 0xCC, 0x90, 0x90, 0xCC, 0xCC };

VOID FORCEINLINE InsertTrampoline(PVOID From, PVOID To) {
    // Relative Jump (E9 XX XX XX XX):
#define TRAMPOLINE_LENGTH 5

#ifndef CODEPAGES_ARE_WRITEABLE
    DWORD OldProtect;
    VirtualProtect(From, TRAMPOLINE_LENGTH, PAGE_EXECUTE_READWRITE, &OldProtect);
#endif
    ULONG RelJmp32Offset = (ULONG)((SIZE_T)To - (SIZE_T)From - TRAMPOLINE_LENGTH);
    *(PBYTE)From = 0xE9;
    *(PULONG)((PBYTE)From + 1) = RelJmp32Offset;

#undef TRAMPOLINE_LENGTH
}

#define ENCRYPT_START(BlockID)																				\
    static volatile BOOL Initialized##BlockID = FALSE;														\
    static BOOL IsEncrypted##BlockID = FALSE, CSInitialized##BlockID = FALSE;								\
    static CRITICAL_SECTION CriticalSection##BlockID;														\
    static RELOCS_SET RelocsSet##BlockID;																	\
    static CODE_BLOCK_INFO CodeBlock##BlockID;																\
    if (!(BOOL)InterlockedCompareExchange((PULONG)&Initialized##BlockID, (ULONG)TRUE, (ULONG)FALSE)) {		\
        InitializeCriticalSection(&CriticalSection##BlockID);												\
        EnterCriticalSection(&CriticalSection##BlockID);													\
        CSInitialized##BlockID = TRUE;																		\
        CONTEXT Context##BlockID;																			\
        RtlCaptureContext(&Context##BlockID);																\
        PVOID StartAddress##BlockID = FindSignature((PVOID)Context##BlockID.Rip, (PVOID)&CryptSigStart);	\
        PVOID CodeAddress##BlockID = (PVOID)((PBYTE)StartAddress##BlockID + CRYPT_SIG_LENGTH);				\
        PVOID StopAddress##BlockID = FindSignature(CodeAddress##BlockID, (PVOID)&CryptSigStop);				\
        SIZE_T CodeSize##BlockID = (SIZE_T)StopAddress##BlockID - (SIZE_T)CodeAddress##BlockID;				\
        CodeBlock##BlockID.Address = CodeAddress##BlockID;													\
        CodeBlock##BlockID.Size = CodeSize##BlockID;														\
        InsertTrampoline(StartAddress##BlockID, CodeAddress##BlockID);										\
        InsertTrampoline(StopAddress##BlockID, (PVOID)((PBYTE)StopAddress##BlockID + CRYPT_SIG_LENGTH));	\
        FillRelocsSet(&CodeBlock##BlockID, RelocsSet##BlockID);												\
    } else {																								\
        while (!CSInitialized##BlockID);																	\
        EnterCriticalSection(&CriticalSection##BlockID);													\
    }																										\
    if (!IsEncrypted##BlockID) EncryptDecrypt(&CodeBlock##BlockID, RelocsSet##BlockID);						\
    IsEncrypted##BlockID = TRUE;																			\
    CRYPT_SIGNATURE_BEGIN;																					

#define ENCRYPT_END(BlockID)																				\
    CRYPT_SIGNATURE_END;																					\
    if (IsEncrypted##BlockID) EncryptDecrypt(&CodeBlock##BlockID, RelocsSet##BlockID);						\
    IsEncrypted##BlockID = FALSE;																			\
    LeaveCriticalSection(&CriticalSection##BlockID);

#define ENCRYPT(BlockID, Code)	\
    ENCRYPT_START(BlockID);		\
    Code;						\
    ENCRYPT_END(BlockID);

#endif

#ifdef _X86_

#define ENCRYPT_START(BlockID)																				\
    static volatile BOOL Initialized##BlockID = FALSE;														\
    static BOOL IsEncrypted##BlockID = FALSE, CSInitialized##BlockID = FALSE;								\
    static CRITICAL_SECTION CriticalSection##BlockID;														\
    static CODE_BLOCK_INFO CodeBlock##BlockID;																\
    static RELOCS_SET RelocsSet##BlockID;																	\
    if (!(BOOL)InterlockedCompareExchange((PULONG)&Initialized##BlockID, (ULONG)TRUE, (ULONG)FALSE)) {		\
        InitializeCriticalSection(&CriticalSection##BlockID);												\
        EnterCriticalSection(&CriticalSection##BlockID);													\
        CSInitialized##BlockID = TRUE;																		\
        PVOID StartAddress##BlockID, StopAddress##BlockID;													\
        __asm { mov StartAddress##BlockID, offset Start##BlockID }											\
        __asm { mov StopAddress##BlockID, offset SigStop##BlockID }											\
        ULONG CodeSize##BlockID = (ULONG)StopAddress##BlockID - (ULONG)StartAddress##BlockID;				\
        CodeBlock##BlockID.Address	= StartAddress##BlockID;												\
        CodeBlock##BlockID.Size		= CodeSize##BlockID;													\
        FillRelocsSet(&CodeBlock##BlockID, RelocsSet##BlockID);												\
    } else {																								\
        while (!CSInitialized##BlockID);																	\
        EnterCriticalSection(&CriticalSection##BlockID);													\
    }																										\
    if (!IsEncrypted##BlockID) EncryptDecrypt(&CodeBlock##BlockID, RelocsSet##BlockID);						\
    IsEncrypted##BlockID = TRUE;																			\
    goto Start##BlockID;																					\
    CRYPT_SIGNATURE_BEGIN;																					\
Start##BlockID:

#define ENCRYPT_END(BlockID)																				\
    goto Stop##BlockID;																						\
SigStop##BlockID:																							\
    CRYPT_SIGNATURE_END;																					\
Stop##BlockID:																								\
    if (IsEncrypted##BlockID) EncryptDecrypt(&CodeBlock##BlockID, RelocsSet##BlockID);						\
    IsEncrypted##BlockID = FALSE;																			\
    LeaveCriticalSection(&CriticalSection##BlockID);

#define ENCRYPT(BlockID, Code)	\
    ENCRYPT_START(BlockID);		\
    Code;						\
    ENCRYPT_END(BlockID);

#endif

#else
#define ENCRYPT_START(BlockID)
#define ENCRYPT_END(BlockID)
#define ENCRYPT(BlockID, Code) Code;
#endif
```

`Avanguard/AvanguardDefence/HWID.cpp`:

```cpp
#include "stdafx.h"
#include "HWID.h"

BOOL GetHddInfo(BYTE PhysicalDriveNumber, OUT PHDD_INFO pHddInfo) {
    
    if (pHddInfo == NULL) return FALSE;
    ZeroMemory(pHddInfo, sizeof(HDD_INFO)); // Чистим выходную структуру

    // Имя девайса (жёсткого диска):
    WCHAR PhysicalDrivePath[48] = { 0 };
    swprintf_s(PhysicalDrivePath, L"\\\\.\\PhysicalDrive%d", PhysicalDriveNumber);

    // Открываем диск как файл для получения инфы:
    HANDLE hDrive = CreateFile(
        PhysicalDrivePath,
        GENERIC_READ,
        FILE_SHARE_READ,
        NULL,
        OPEN_EXISTING,
        FILE_ATTRIBUTE_DEVICE,
        NULL
    );

    if (hDrive == INVALID_HANDLE_VALUE) return FALSE;

    // Указываем, какую инфу хотим получить:
    STORAGE_PROPERTY_QUERY PropQuery;
    ZeroMemory(&PropQuery, sizeof(PropQuery));
    PropQuery.QueryType  = PropertyStandardQuery;
    PropQuery.PropertyId = StorageDeviceProperty;

    // Чистим дескриптор девайса:
    STORAGE_DEVICE_DESCRIPTOR DeviceDescriptor;
    ZeroMemory(&DeviceDescriptor, sizeof(DeviceDescriptor));

    DWORD BytesReturned = 0;

    // Вызываем, чтобы получить необходимый размер структуры:
    BOOL Status = DeviceIoControl(
        hDrive,
        IOCTL_STORAGE_QUERY_PROPERTY,
        &PropQuery,
        sizeof(PropQuery),
        &DeviceDescriptor,
        sizeof(DeviceDescriptor),
        &BytesReturned,
        NULL
    );

    if (!Status) goto Exit;

    // Вызываем с полным размером структуры:
    PSTORAGE_DEVICE_DESCRIPTOR pDeviceDescriptor = (PSTORAGE_DEVICE_DESCRIPTOR) new BYTE[DeviceDescriptor.Size];
    Status = DeviceIoControl(
        hDrive,
        IOCTL_STORAGE_QUERY_PROPERTY,
        &PropQuery,
        sizeof(PropQuery),
        pDeviceDescriptor,
        DeviceDescriptor.Size,
        &BytesReturned,
        NULL
    );

    if (!Status) {
        delete[] pDeviceDescriptor;
        goto Exit;
    }

    // Получили структуру, внутри которой по смещениям лежат строковые данные,
    // получаем указатели на них и возвращаем в структуре (саму структуру НЕ освобождаем!)

    ULONG VendorIdOffset        = pDeviceDescriptor->VendorIdOffset;
    ULONG ProductIdOffset       = pDeviceDescriptor->ProductIdOffset;
    ULONG ProductRevisionOffset = pDeviceDescriptor->ProductRevisionOffset;
    ULONG SerialNumberOffset    = pDeviceDescriptor->SerialNumberOffset;

    pHddInfo->VendorId = VendorIdOffset != 0 && VendorIdOffset < DeviceDescriptor.Size 
        ? (LPCSTR)pDeviceDescriptor + VendorIdOffset 
        : NULL;
    pHddInfo->ProductId = ProductIdOffset != 0 && ProductIdOffset < DeviceDescriptor.Size 
        ? (LPCSTR)pDeviceDescriptor + ProductIdOffset
        : NULL;
    pHddInfo->ProductRevision = ProductRevisionOffset != 0 && ProductRevisionOffset < DeviceDescriptor.Size 
        ? (LPCSTR)pDeviceDescriptor + ProductRevisionOffset
        : NULL;
    pHddInfo->SerialNumber = SerialNumberOffset	!= 0 && SerialNumberOffset < DeviceDescriptor.Size 
        ? (LPCSTR)pDeviceDescriptor + SerialNumberOffset
        : NULL;

    pHddInfo->HddInfoDataContainer = pDeviceDescriptor;

Exit:
    CloseHandle(hDrive);
    return Status;
}

VOID FreeHddInfo(IN OUT PHDD_INFO pHddInfo) {
    // Освобождаем структуру, полученную в GetHddInfo:
    if (pHddInfo == NULL) return;
    delete[] pHddInfo->HddInfoDataContainer;
    ZeroMemory(pHddInfo, sizeof(HDD_INFO));
}



// 24 бита:
typedef struct _CPUID {
    unsigned Vendor		: 1; // 0 = Intel, 1 = AMD
    unsigned BaseFamily	: 4;
    unsigned BaseModel	: 4;
    unsigned Stepping	: 4;
    unsigned BrandID	: 8;
    unsigned MMX		: 1;
    unsigned SSE1		: 1;
    unsigned SSE2		: 1;
    unsigned SSE3		: 1;
    unsigned SSSE3		: 1;
    unsigned SSE41		: 1;
    unsigned SSE42		: 1;
    unsigned RDTSCP		: 1;
    unsigned AVX		: 1;
    unsigned AES		: 1;
    unsigned FMA		: 1;
} CPUID, *PCPUID;

typedef struct _CPUID_INFO {
    DWORD EAX;
    DWORD EBX;
    DWORD ECX;
    DWORD EDX;
} CPUID_INFO, *PCPUID_INFO;

#define IsBitSet(Value, BitNumber)	((Value & (1 << BitNumber)) != 0)
#define Shr(Value, BitsCount)		(Value >> BitsCount)

/*
    Номера битов и вектора CPUID взяты из спецификаций:
    - AMD CPUID Specification
    - Intel(R) Processor Identification and the CPUID Instruction
*/
DWORD GetCPUID() {
    CPUID CPU = { 0 };
    CPUID_INFO CPUIDInfo = { 0 };

// Номера векторов CPUID:
#define CPUID_VENDOR	0x00000000
#define CPUID_FEATURES	0x00000001
#define CPUID_RDTSCP	0x80000001

// Хэши (XOR) вендоров (AuthenticAMD/GenuineIntel) - EBX ^ ECX ^ EDX:
#define INTEL_VENDOR_HASH	0x506E7F40
#define AMD_VENDOR_HASH		0x454D5A47

// Номера битов и смещения в регистрах CPUID_FEATURES (off* = offset, bn* = bit number):
// EAX:
#define offStepping 0 // [0..4]
#define offModel	4 // [0..4]	
#define offFamily	8 // [0..4]

// EBX:
#define offBrandID 0 // [0..7]

// ECX:
#define	bnSSE3	0
#define	bnSSSE3	9
#define	bnFMA	12
#define	bnSSE41	19
#define	bnSSE42	20
#define	bnAES	25
#define	bnAVX	28

// EDX:
#define	bnMMX	23
#define	bnSSE1	25
#define	bnSSE2	26

// Номера битов в регистрах CPUID_RDTSCP:
// EDX:
#define bnRDTSCP 27

    // Processor Vendor:
    __cpuid((int*)&CPUIDInfo, CPUID_VENDOR);
    DWORD VendorSignature = CPUIDInfo.EBX ^ CPUIDInfo.ECX ^ CPUIDInfo.EDX;
    switch (VendorSignature) {
    case INTEL_VENDOR_HASH	: CPU.Vendor = 0; break;
    case AMD_VENDOR_HASH	: CPU.Vendor = 1; break;
    }

    // CPU Features:
    __cpuid((int*)&CPUIDInfo, CPUID_FEATURES);
    CPU.BaseFamily	= Shr(CPUIDInfo.EAX, offFamily);
    CPU.BaseModel	= Shr(CPUIDInfo.EAX, offModel);
    CPU.Stepping	= Shr(CPUIDInfo.EAX, offStepping);

    CPU.BrandID = Shr(CPUIDInfo.EBX, offBrandID);

    CPU.SSE3	= IsBitSet(CPUIDInfo.ECX, bnSSE3);
    CPU.SSSE3	= IsBitSet(CPUIDInfo.ECX, bnSSSE3);
    CPU.FMA		= IsBitSet(CPUIDInfo.ECX, bnFMA);
    CPU.SSE41	= IsBitSet(CPUIDInfo.ECX, bnSSE41);
    CPU.SSE42	= IsBitSet(CPUIDInfo.ECX, bnSSE42);
    CPU.AES		= IsBitSet(CPUIDInfo.ECX, bnAES);
    CPU.AVX		= IsBitSet(CPUIDInfo.ECX, bnAVX);

    CPU.MMX		= IsBitSet(CPUIDInfo.EDX, bnMMX);
    CPU.SSE1	= IsBitSet(CPUIDInfo.EDX, bnSSE1);
    CPU.SSE2	= IsBitSet(CPUIDInfo.EDX, bnSSE2);

    // RDTSCP Support:
    __cpuid((int*)&CPUIDInfo, CPUID_RDTSCP);
    CPU.RDTSCP	= IsBitSet(CPUIDInfo.EDX, bnRDTSCP);

    return *(PDWORD)&CPU;
}


ULONGLONG GetMAC() {
    ULONGLONG MAC = 0;

    // Получаем размер буфера:
    ULONG AdaptersInfoSize = 0;
    DWORD Status = GetAdaptersInfo(NULL, &AdaptersInfoSize);
    if (Status != ERROR_BUFFER_OVERFLOW && AdaptersInfoSize == 0) return MAC;

    // Получаем инфу об адаптерах:
    PIP_ADAPTER_INFO AdapterInfo;
    AdapterInfo = (PIP_ADAPTER_INFO)malloc(AdaptersInfoSize);
    if (AdapterInfo == NULL) return MAC;
    Status = GetAdaptersInfo(AdapterInfo, &AdaptersInfoSize);
    if (Status != NO_ERROR) goto Exit;

    memcpy(&MAC, AdapterInfo->Address, AdapterInfo->AddressLength);

Exit:
    free(AdapterInfo);
    return MAC;
}

/*
    У каждой строковой инфы есть свой порядковый номер,
    последняя строка заканчивается двойным нуль-терминатором.
    Ищем строку по её порядковому номеру, который получаем из

*/
LPCSTR __fastcall FindStringByNumber(LPCSTR Base, BYTE StringNumber) {
    if (StringNumber <= 1) return Base;
    StringNumber--;
    for (int i = 0; i < StringNumber; i++) {
        Base = Base + strlen(Base) + 1;
    }
    return Base;
}

/*
    Переход на следующий блок относительно текущего:
    передаём произвольный адрес в текущем блоке текстовых данных 
    и отсчитываем до первых встреченных двух нуль-терминаторов:
*/
PVOID __fastcall GoToNextBlock(PVOID CurrentBlockEntireAddress) {
    PBYTE Address = (PBYTE)CurrentBlockEntireAddress;
    while (*(PWORD)Address != 0) Address++;
    return Address += 2;
}

// Вытаскиваем инфу о биосе:
PVOID ParseBIOSInfo(IN PBIOS_INFO BIOSInfo, OUT PFIRMWARE_INFO FirmwareInfo) {
    FirmwareInfo->BIOSData.BIOSInfo = BIOSInfo;

    LPCSTR BIOSTextData = (LPCSTR)BIOSInfo + BIOSInfo->Length;
    FirmwareInfo->BIOSData.Vendor		= FindStringByNumber(BIOSTextData, BIOSInfo->Vendor);
    FirmwareInfo->BIOSData.BIOSVersion	= FindStringByNumber(BIOSTextData, BIOSInfo->BIOSVersion);
    FirmwareInfo->BIOSData.ReleaseDate	= FindStringByNumber(BIOSTextData, BIOSInfo->BIOSReleaseDate);

    return GoToNextBlock((PVOID)BIOSTextData);
}

// Парсим системную инфу:
PVOID ParseSystemInfo(IN PSM_SYSTEM_INFO SystemInfo, OUT PFIRMWARE_INFO FirmwareInfo) {
    FirmwareInfo->SystemData.SystemInfo = SystemInfo;

    LPCSTR SystemInfoTextData = (LPCSTR)SystemInfo + SystemInfo->Length;
    FirmwareInfo->SystemData.Manufacturer	= FindStringByNumber(SystemInfoTextData, SystemInfo->Manufacturer);
    FirmwareInfo->SystemData.ProductName	= FindStringByNumber(SystemInfoTextData, SystemInfo->ProductName);
    FirmwareInfo->SystemData.Version		= FindStringByNumber(SystemInfoTextData, SystemInfo->Version);
    FirmwareInfo->SystemData.SerialNumber	= FindStringByNumber(SystemInfoTextData, SystemInfo->SerialNumber);
    FirmwareInfo->SystemData.SKUNumber		= FindStringByNumber(SystemInfoTextData, SystemInfo->SKUNumber);
    FirmwareInfo->SystemData.Family			= FindStringByNumber(SystemInfoTextData, SystemInfo->Family);

    return GoToNextBlock((PVOID)SystemInfoTextData);
}

// Парсим инфу о материнской плате:
PVOID ParseBoardInfo(IN PBASEBOARD_INFO BaseboardInfo, OUT PFIRMWARE_INFO FirmwareInfo) {
    FirmwareInfo->BaseboardData.BaseboardInfo = BaseboardInfo;

    LPCSTR BaseboardTextData = (LPCSTR)BaseboardInfo + BaseboardInfo->Length;
    FirmwareInfo->BaseboardData.Manufacturer		= FindStringByNumber(BaseboardTextData, BaseboardInfo->Manufacturer);
    FirmwareInfo->BaseboardData.Product				= FindStringByNumber(BaseboardTextData, BaseboardInfo->Product);
    FirmwareInfo->BaseboardData.Version				= FindStringByNumber(BaseboardTextData, BaseboardInfo->Version);
    FirmwareInfo->BaseboardData.SerialNumber		= FindStringByNumber(BaseboardTextData, BaseboardInfo->SerialNumber);
    FirmwareInfo->BaseboardData.AssetTag			= FindStringByNumber(BaseboardTextData, BaseboardInfo->AssetTag);
    FirmwareInfo->BaseboardData.LocationInChassis	= FindStringByNumber(BaseboardTextData, BaseboardInfo->LocationInChassis);

    return GoToNextBlock((PVOID)BaseboardTextData);
}

typedef UINT (WINAPI *_GetSystemFirmwareTable)(
    _In_ DWORD FirmwareTableProviderSignature,
    _In_ DWORD FirmwareTableID,
    _Out_writes_bytes_to_opt_(BufferSize, return) PVOID pFirmwareTableBuffer,
    _In_ DWORD BufferSize
);

_GetSystemFirmwareTable __GetSystemFirmwareTable = 
    (_GetSystemFirmwareTable)hModules::QueryAddress(hModules::hKernel32(), XORSTR("GetSystemFirmwareTable"));

BOOL GetFirmwareInfo(OUT PFIRMWARE_INFO FirmwareInfo) {
    if (FirmwareInfo == NULL) return FALSE;
    if (__GetSystemFirmwareTable == NULL) return FALSE;

    ZeroMemory(FirmwareInfo, sizeof(FIRMWARE_INFO));

    const DWORD ProviderSignature = 'RSMB'; // RawSMBIOS

    // Получаем размер:
    UINT RequiredSize = __GetSystemFirmwareTable(ProviderSignature, NULL, NULL, 0);
    if (RequiredSize == 0) return NULL;
    
    // Получаем Raw SMBIOS:
    PRAW_SMBIOS_DATA SMBIOS = (PRAW_SMBIOS_DATA) new BYTE[RequiredSize];
    UINT WrittenBytes = __GetSystemFirmwareTable(ProviderSignature, NULL, SMBIOS, RequiredSize);
    if (WrittenBytes > RequiredSize) {
        delete[] SMBIOS;
        return FALSE;
    }

    FirmwareInfo->RawSMBIOSData = SMBIOS;

// Номера блоков данных:
#define SIG_BIOS		0
#define SIG_SYSINFO		1
#define SIG_BASEBOARD	2

    // Обходим весь блок памяти и ищем структуры по их номерам:
    PVOID Address = SMBIOS->SMBIOSTableData;
    PVOID MaximumAddress = (PBYTE)Address + SMBIOS->Length;
    while (Address < MaximumAddress) {
        switch (*(PBYTE)Address) {
        case SIG_BIOS		: Address = ParseBIOSInfo((PBIOS_INFO)Address, FirmwareInfo); break;
        case SIG_SYSINFO	: Address = ParseSystemInfo((PSM_SYSTEM_INFO)Address, FirmwareInfo); break;
        case SIG_BASEBOARD	: Address = ParseBoardInfo((PBASEBOARD_INFO)Address, FirmwareInfo); break;
        default: Address = GoToNextBlock((PVOID)((PBYTE)Address + *((PBYTE)Address + 1)));
        }		
    }

    return TRUE;
}

VOID FreeFirmwareInfo(IN OUT PFIRMWARE_INFO FirmwareInfo) {
    // Освобождаем память, выделенную в GetFirmwareInfo:
    if (FirmwareInfo == NULL || FirmwareInfo->RawSMBIOSData == NULL) return;
    delete[] FirmwareInfo->RawSMBIOSData;
    ZeroMemory(FirmwareInfo, sizeof(FIRMWARE_INFO));
}

// Получить размер в байтах для переменной из реестра:
DWORD GetRegValueDataSize(HKEY hKey, LPWSTR ValueName, OUT OPTIONAL PDWORD ValueType) {
    DWORD Length = 0;
    DWORD Type = 0;
    if (RegQueryValueEx(hKey, ValueName, NULL, &Type, NULL, &Length) == ERROR_SUCCESS) {
        if (ValueType) *ValueType = Type;
        return Length;
    }
    return 0;
}

// Получить строковое значение из реестра:
LPWSTR GetRegValue(HKEY hKey, LPWSTR ValueName) {
    DWORD Type;
    DWORD ValueSize = GetRegValueDataSize(hKey, ValueName, NULL);
    if (ValueSize == 0) return NULL;
    LPWSTR Data = (LPWSTR) new BYTE[ValueSize];
    if (RegQueryValueEx(hKey, ValueName, NULL, &Type, (LPBYTE)Data, &ValueSize) == ERROR_SUCCESS) {
        return Data;
    } else {
        delete[] Data;
        return NULL;
    }
}

// Получаем информацию из реестра:
BOOL GetRegFirmwareInfo(OUT PREG_FIRMWARE_INFO RegFirmwareInfo) {
    if (RegFirmwareInfo == NULL) return FALSE;
    ZeroMemory(RegFirmwareInfo, sizeof(REG_FIRMWARE_INFO));

    HKEY hKey;
    const LPWSTR KeyPath = L"HARDWARE\\DESCRIPTION\\System\\BIOS"; // Ключ с инфой о биосе
    ULONG Status = RegOpenKeyEx(HKEY_LOCAL_MACHINE, KeyPath, NULL, KEY_READ | KEY_WOW64_64KEY, &hKey);

    if (Status != ERROR_SUCCESS) return FALSE;

    // Имена значений с информацией о биосе - аналог полей в структуре BIOS_INFO в SMBIOS:
    const LPWSTR BaseBoardProductValueName	= L"BaseBoardProduct";
    const LPWSTR BaseBoardRevisionValueName	= L"BaseBoardVersion";
    const LPWSTR BIOSReleaseDateValueName	= L"BIOSReleaseDate";
    const LPWSTR BIOSVendorValueName		= L"BIOSVendor";
    const LPWSTR BIOSVersionValueName		= L"BIOSVersion";

    RegFirmwareInfo->BaseboardProduct	= GetRegValue(hKey, BaseBoardProductValueName);
    RegFirmwareInfo->BaseboardVersion	= GetRegValue(hKey, BaseBoardRevisionValueName);
    RegFirmwareInfo->BIOSReleaseDate	= GetRegValue(hKey, BIOSReleaseDateValueName);
    RegFirmwareInfo->BIOSVendor			= GetRegValue(hKey, BIOSVendorValueName);
    RegFirmwareInfo->BIOSVersion		= GetRegValue(hKey, BIOSVersionValueName);

    RegCloseKey(hKey);
    return TRUE;
}

VOID FreeEntry(LPWSTR RegFirmwareInfoEntry) {
    // Освобождаем память, выделенную для строковой переменной из реестра:
    if (RegFirmwareInfoEntry) delete[] RegFirmwareInfoEntry;
}

// Освобождаем память, выделенную в GetRegFirmwareInfo:
VOID FreeRegFirmwareInfo(IN PREG_FIRMWARE_INFO RegFirmwareInfo) {
    FreeEntry(RegFirmwareInfo->BaseboardProduct);
    FreeEntry(RegFirmwareInfo->BaseboardVersion);
    FreeEntry(RegFirmwareInfo->BIOSReleaseDate);
    FreeEntry(RegFirmwareInfo->BIOSVendor);
    FreeEntry(RegFirmwareInfo->BIOSVersion);
}
```

`Avanguard/AvanguardDefence/HWID.h`:

```h
#pragma once

#include <Windows.h>
#include <intrin.h>
#include <stdio.h>

#include <iphlpapi.h>
#pragma comment(lib, "IPHLPAPI.lib")

// Структура информации о HDD:
typedef struct _HDD_INFO {
    LPCSTR	VendorId;
    LPCSTR	ProductId;
    LPCSTR	ProductRevision;
    LPCSTR	SerialNumber;
    PVOID	HddInfoDataContainer;	// Указатель на выделенный в GetHddInfo
                                    // блок памяти, где лежат VendorId,
                                    // ProductId, Revision и SN (все они указывают 
                                    // внутрь этого блока) - этот блок
                                    // освобождается в FreeHddInfo
} HDD_INFO, *PHDD_INFO;

BOOL GetHddInfo(BYTE PhysicalDriveNumber, OUT PHDD_INFO pHddInfo);
VOID FreeHddInfo(IN OUT PHDD_INFO pHddInfo);

DWORD GetCPUID();
ULONGLONG GetMAC();

#pragma warning(push)
#pragma warning(disable: 4200) // Отключаем предупреждение на массив нулевой длины
typedef struct _RAW_SMBIOS_DATA {
    BYTE	Used20CallingMethod;
    BYTE	SMBIOSMajorVersion;
    BYTE	SMBIOSMinorVersion;
    BYTE	DmiRevision;
    DWORD	Length;
    BYTE	SMBIOSTableData[];
} RAW_SMBIOS_DATA, *PRAW_SMBIOS_DATA;
#pragma warning(pop)

typedef ULONGLONG QWORD;

#pragma pack(push, 1) // Отключаем выравнивание
typedef struct _Type0 {
// SMBIOS 2.0+:
    BYTE	Type;
    BYTE	Length;
    WORD	Handle;
    BYTE	Vendor;
    BYTE	BIOSVersion;
    WORD	BIOSStartingAddressSegment;
    BYTE	BIOSReleaseDate;
    BYTE	BIOSROMSize;
    QWORD	BIOSCharacteristics;
// SMBIOS 2.4+:
    WORD	BIOSCharacteristicsExt;
    BYTE	SystemBIOSMajorRelease;
    BYTE	SystemBIOSMinorRelease;
    BYTE	EmbeddedControllerFirmwareMajorRelease;
    BYTE	EmbeddedControllerFirmwareMinorRelease;
// SMBIOS 3.1+:
    // WORD	ExtendedBIOSROMSize;
} BIOS_INFO, *PBIOS_INFO;


typedef struct _Type1 {
// SMBIOS 2.0+:
    BYTE	Type;
    BYTE	Length;
    WORD	Handle;
    BYTE	Manufacturer;
    BYTE	ProductName;
    BYTE	Version;
    BYTE	SerialNumber;
// SMBIOS 2.1+:
    BYTE	UUID[16];
    BYTE	WakeUpTime;
// SMBIOS 2.4+:
    BYTE	SKUNumber;
    BYTE	Family;
} SM_SYSTEM_INFO, *PSM_SYSTEM_INFO;

#pragma warning(push)
#pragma warning(disable: 4200)
typedef struct _Type2 {
    BYTE	Type;
    BYTE	Length;
    WORD	Handle;
    BYTE	Manufacturer;
    BYTE	Product;
    BYTE	Version;
    BYTE	SerialNumber;
    BYTE	AssetTag;
    BYTE	FeatureFlags;
    BYTE	LocationInChassis;
    WORD	ChassisHandle;
    BYTE	BoardType;
    BYTE	NumberOfContainedObjectHandles;
    WORD	ContainedObjectHandles[];
} BASEBOARD_INFO, *PBASEBOARD_INFO;
#pragma warning(pop)

typedef struct _Type3 {
    // To be done... когда-нибудь...
} MEMORY_DEVICE_INFO, *PMEMORY_DEVICE_INFO;
#pragma pack(pop)

// Дальше идут структуры сборной инфы из SMBIOS,
// все строковые переменные освобождаются в 
// FreeFirmwareInfo вместе с хранящим их блоком

// Инфа о BIOS'e:
typedef struct _BIOS_FIRMWARE_DATA {
    PBIOS_INFO BIOSInfo;
// SMBIOS 2.0+:
    LPCSTR Vendor;
    LPCSTR BIOSVersion;
    LPCSTR ReleaseDate;
} BIOS_FIRMWARE_DATA, *PBIOS_FIRMWARE_DATA;

// Сборная инфа о системе:
typedef struct _SYSTEM_FIRMWARE_DATA {
    PSM_SYSTEM_INFO SystemInfo;
// SMBIOS 2.0+:
    LPCSTR Manufacturer;
    LPCSTR ProductName;
    LPCSTR Version;
    LPCSTR SerialNumber;
// SMBIOS 2.4+:
    LPCSTR SKUNumber;
    LPCSTR Family;
} SYSTEM_FIRMWARE_DATA, *PSYSTEM_FIRMWARE_DATA;

// Информация о матплате:
typedef struct _BASEBOARD_FIRMWARE_DATA {
    PBASEBOARD_INFO BaseboardInfo;
    LPCSTR Manufacturer;
    LPCSTR Product;
    LPCSTR Version;
    LPCSTR SerialNumber;
    LPCSTR AssetTag;
    LPCSTR LocationInChassis;
} BASEBOARD_FIRMWARE_DATA, *PFIRMWARE_BASEBOARD_DATA;


// Основная структура, где собрано всё:
typedef struct _FIRMWARE_INFO {
    PRAW_SMBIOS_DATA		RawSMBIOSData;
    BIOS_FIRMWARE_DATA		BIOSData;
    SYSTEM_FIRMWARE_DATA	SystemData;
    BASEBOARD_FIRMWARE_DATA	BaseboardData;
} FIRMWARE_INFO, *PFIRMWARE_INFO;

BOOL GetFirmwareInfo(OUT PFIRMWARE_INFO FirmwareInfo);
VOID FreeFirmwareInfo(IN OUT PFIRMWARE_INFO FirmwareInfo);

// Дальше идут функции, читающие информацию из реестра вместо SMBIOS:

typedef struct _REG_FIRMWARE_INFO {
    LPWSTR BaseboardProduct;
    LPWSTR BaseboardVersion;
    LPWSTR BIOSReleaseDate;
    LPWSTR BIOSVendor;
    LPWSTR BIOSVersion;
} REG_FIRMWARE_INFO, *PREG_FIRMWARE_INFO;

BOOL GetRegFirmwareInfo(OUT PREG_FIRMWARE_INFO RegFirmwareInfo);
VOID FreeRegFirmwareInfo(IN PREG_FIRMWARE_INFO RegFirmwareInfo);
```

`Avanguard/AvanguardDefence/HWIDsUtils.cpp`:

```cpp
#include "stdafx.h"
#include "HWID.h"
#include "..\\t1ha\\t1ha.h"

#include <string>

#include "HWIDsUtils.h"

static void AddHwidEntry(std::string& Hwid, const char* Entry) {
    if (Entry) Hwid += (Entry);
}


UINT64 HWIDs::GetCpuid() {
    return GetCPUID();
}

UINT64 HWIDs::GetSmbiosId() {
    std::string Hwid;

    FIRMWARE_INFO Firmware = { 0 };
    if (!GetFirmwareInfo(&Firmware)) return 0;

    // Baseboard:
    AddHwidEntry(Hwid, Firmware.BaseboardData.AssetTag);
    AddHwidEntry(Hwid, Firmware.BaseboardData.LocationInChassis);
    AddHwidEntry(Hwid, Firmware.BaseboardData.Manufacturer);
    AddHwidEntry(Hwid, Firmware.BaseboardData.Product);
    AddHwidEntry(Hwid, Firmware.BaseboardData.SerialNumber);
    AddHwidEntry(Hwid, Firmware.BaseboardData.Version);

    // BIOS:
    AddHwidEntry(Hwid, Firmware.BIOSData.BIOSVersion);
    AddHwidEntry(Hwid, Firmware.BIOSData.ReleaseDate);
    AddHwidEntry(Hwid, Firmware.BIOSData.Vendor);

    // SystemInfo:
    AddHwidEntry(Hwid, Firmware.SystemData.Family);
    AddHwidEntry(Hwid, Firmware.SystemData.Manufacturer);
    AddHwidEntry(Hwid, Firmware.SystemData.ProductName);
    AddHwidEntry(Hwid, Firmware.SystemData.SerialNumber);
    AddHwidEntry(Hwid, Firmware.SystemData.SKUNumber);
    AddHwidEntry(Hwid, Firmware.SystemData.Version);

    FreeFirmwareInfo(&Firmware);

    return t1ha(Hwid.c_str(), Hwid.length(), 0x1EE7C0DEC0FFEE);
}

UINT64 HWIDs::GetMacId() {
    return GetMAC();
}

UINT64 HWIDs::GetHddId() {
    HDD_INFO HddInfo = { 0 };
    if (!GetHddInfo(0, &HddInfo)) return 0;
    constexpr UINT64 T1haSeed = 0x1EE7C0DEC0FFEE;
    UINT64 HddId = 0;
    if (HddInfo.VendorId) 
        HddId ^= t1ha(HddInfo.VendorId, strlen(HddInfo.VendorId), T1haSeed);
    if (HddInfo.ProductId)
        HddId ^= t1ha(HddInfo.ProductId, strlen(HddInfo.ProductId), T1haSeed);
    if (HddInfo.ProductRevision)
        HddId ^= t1ha(HddInfo.ProductRevision, strlen(HddInfo.ProductRevision), T1haSeed);
    if (HddInfo.SerialNumber)
        HddId ^= t1ha(HddInfo.SerialNumber, strlen(HddInfo.SerialNumber), T1haSeed);
    FreeHddInfo(&HddInfo);
    return HddId;
}
```

`Avanguard/AvanguardDefence/HWIDsUtils.h`:

```h
#pragma once

class HWIDs final {
public:
    static UINT64 GetCpuid();
    static UINT64 GetSmbiosId();
    static UINT64 GetMacId();
    static UINT64 GetHddId();
};
```

`Avanguard/AvanguardDefence/HandlesKeeper.cpp`:

```cpp
#include "stdafx.h"
#include "HandlesKeeper.h"

typedef struct _SYSTEM_HANDLE_TABLE_ENTRY_INFO_EX {
    PVOID Object;
    ULONG_PTR UniqueProcessId;
    ULONG_PTR HandleValue;
    ULONG GrantedAccess;
    USHORT CreatorBackTraceIndex;
    USHORT ObjectTypeIndex;
    ULONG HandleAttributes;
    ULONG Reserved;
} SYSTEM_HANDLE_TABLE_ENTRY_INFO_EX, *PSYSTEM_HANDLE_TABLE_ENTRY_INFO_EX;

#pragma warning(push)
#pragma warning(disable: 4200)
typedef struct _SYSTEM_HANDLE_INFORMATION_EX {
    ULONG_PTR NumberOfHandles;
    ULONG_PTR Reserved;
    SYSTEM_HANDLE_TABLE_ENTRY_INFO_EX Handles[0];
} SYSTEM_HANDLE_INFORMATION_EX, *PSYSTEM_HANDLE_INFORMATION_EX;
#pragma warning(pop)

#define SystemExtendedHandleInformation 0x40

HandlesKeeper::HandlesKeeper() {
    AllocReAllocFreeHeap(&MemBlock, HeapGranularity);
}

HandlesKeeper::~HandlesKeeper() {
    AllocReAllocFreeHeap(&MemBlock, 0);
}

NTSTATUS HandlesKeeper::EnumHandles(OB_TYPES Type, BOOL SkipSelfHandles, _EnumHandlesCallback Callback) {
    if (Callback == NULL) return STATUS_SUCCESS;

    NTSTATUS Status;

    ULONG ReturnLength;
    while (
        Status = NtQuerySystemInformation(
            (SYSTEM_INFORMATION_CLASS)SystemExtendedHandleInformation,
            MemBlock.Buffer,
            MemBlock.Size,
            &ReturnLength
        )
        ==
        STATUS_INFO_LENGTH_MISMATCH
    ) {
        AllocReAllocFreeHeap(&MemBlock, MemBlock.Size + HeapGranularity);
    }

    if (Status != STATUS_SUCCESS) return Status;

    REMOTE_HANDLE_INFO HandleInfo;
    HandleInfo.CurrentProcessId = CurrentProcessId;
    HandleInfo.hCurrentProcess = hCurrentProcess;

    PSYSTEM_HANDLE_INFORMATION_EX Handles = (PSYSTEM_HANDLE_INFORMATION_EX)MemBlock.Buffer;

    for (unsigned int i = 0; i < Handles->NumberOfHandles; i++) {
        PSYSTEM_HANDLE_TABLE_ENTRY_INFO_EX Entry = &Handles->Handles[i];
        HandleInfo.ObjectType = Entry->ObjectTypeIndex;
        if ((Type == OB_TYPE_ALL) || (HandleInfo.ObjectType == (USHORT)Type)) {
            // Если хэндл открыт в нашем процессе - пропускаем:
            HandleInfo.RemoteProcessId = (ULONG)Entry->UniqueProcessId;

            // Если найденный хэндл в нашем процессе - пропускаем:
            if (SkipSelfHandles && (HandleInfo.RemoteProcessId == CurrentProcessId)) continue;

            // Открываем процесс, в котором открыт хэндл:
            HANDLE hProcess = OpenProcess(PROCESS_DUP_HANDLE, FALSE, HandleInfo.RemoteProcessId);
            if (hProcess == NULL) continue;

            HANDLE hRemoteHandle = (HANDLE)Entry->HandleValue;
            
            // Копируем к себе хэндл с правами оригинала:
            BOOL Status = DuplicateHandle(hProcess, hRemoteHandle, hCurrentProcess, &HandleInfo.hObject, 0, FALSE, DUPLICATE_SAME_ACCESS);
            if (!Status) goto Continue;

            // Вызываем каллбэк:
            BOOL NeedToCloseSource = FALSE;
            HandleInfo.hRemoteProcess = hProcess;
            HandleInfo.GrantedAccess = Entry->GrantedAccess;
            HandleInfo.HandleAttributes = Entry->HandleAttributes;
            Callback(&HandleInfo, &NeedToCloseSource);
            
            // Если нужно закрыть оригинальный хэндл - закрываем:
            if (NeedToCloseSource) {
                CloseHandle(HandleInfo.hObject);
                Status = DuplicateHandle(hProcess, hRemoteHandle, hCurrentProcess, &HandleInfo.hObject, 0, FALSE, DUPLICATE_CLOSE_SOURCE);
                if (!Status) goto Continue;
            }

            CloseHandle(HandleInfo.hObject);

Continue:
            CloseHandle(hProcess);
        }
    }

    return STATUS_SUCCESS;
}
```

`Avanguard/AvanguardDefence/HandlesKeeper.h`:

```h
#pragma once

#include "HeapManager.h"

#include <Psapi.h>

#pragma warning(push)
#pragma warning(disable: 4005)
#include <winternl.h>
#include <ntstatus.h>
#pragma warning(pop)

#pragma comment(lib, "ntdll.lib")

typedef enum _OB_TYPES {
    OB_TYPE_ALL = -1,
    OB_TYPE_PROCESS_XP = 5,
    OB_TYPE_PROCESS = 7,
} OB_TYPES, *POB_TYPES;

typedef struct _REMOTE_HANDLE_INFO {
    HANDLE hRemoteProcess;
    HANDLE hCurrentProcess;
    HANDLE hObject;
    ULONG RemoteProcessId;
    ULONG CurrentProcessId;
    ULONG GrantedAccess;
    ULONG HandleAttributes;
    USHORT ObjectType;
} REMOTE_HANDLE_INFO, *PREMOTE_HANDLE_INFO;

typedef VOID (__fastcall *_EnumHandlesCallback)(PREMOTE_HANDLE_INFO HandleInfo, OUT PBOOL NeedToCloseSource);

class HandlesKeeper {
private:
    const ULONG HeapGranularity = 0x200000;
    HEAP_MEMBLOCK MemBlock = { 0 };

    HANDLE hCurrentProcess = GetCurrentProcess();
    ULONG CurrentProcessId = GetCurrentProcessId();
public:	
    HandlesKeeper();
    ~HandlesKeeper();

    NTSTATUS EnumHandles(OB_TYPES Type, BOOL SkipSelfHandles, _EnumHandlesCallback Callback);
};
```

`Avanguard/AvanguardDefence/HeapManager.cpp`:

```cpp
#include "stdafx.h"
#include "HeapManager.h"

BOOL AllocReAllocFreeHeap(PHEAP_MEMBLOCK MemBlock, ULONG Size) {
    if (MemBlock == NULL) return FALSE;
    if (Size == 0) {
        if (MemBlock->Initialized) {
            HeapFree(GetProcessHeap(), 0, MemBlock->Buffer);
            ZeroMemory(MemBlock, sizeof(*MemBlock));
        }
        return TRUE;
    }

    if (MemBlock->Initialized && MemBlock->Size == Size) return TRUE;

    if (!MemBlock->Initialized || MemBlock->Buffer == NULL) {
        MemBlock->Buffer = HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, Size);
        if (MemBlock->Buffer == NULL) return FALSE;
        MemBlock->Size = Size;
        MemBlock->Initialized = TRUE;
        return TRUE;
    }

    PVOID ReallocatedBuffer = HeapReAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, MemBlock->Buffer, Size);
    if (!ReallocatedBuffer) return FALSE;

    MemBlock->Buffer = ReallocatedBuffer;
    MemBlock->Size = Size;
    MemBlock->Initialized = TRUE;

    return TRUE;
}
```

`Avanguard/AvanguardDefence/HeapManager.h`:

```h
#pragma once

#include <Windows.h>

typedef struct _HEAP_MEMBLOCK {
    PVOID Buffer;
    ULONG Size;
    BOOL Initialized;
} HEAP_MEMBLOCK, *PHEAP_MEMBLOCK;

BOOL AllocReAllocFreeHeap(PHEAP_MEMBLOCK MemBlock, ULONG Size);
```

`Avanguard/AvanguardDefence/JavaBindings.cpp`:

```cpp
#include "stdafx.h"

#include "AvnDefinitions.h"

#ifdef JAVA_BINDINGS

#pragma comment(lib, "jvm.lib")

#include "HWIDsUtils.h"
#include "ThreatTypes.h"
#include "ThreatElimination.h"
#include "t1ha.h"

#include "JavaBindings.h"

static BOOL _IsJavaBinded = FALSE;

extern BOOL AvnStartDefence();
extern VOID AvnStopDefence();
extern BOOL IsAvnStarted;
extern BOOL IsAvnStaticLoaded;

static JavaVM* _vm = NULL;
static JNIEnv* _env = NULL;
static jclass _klass = NULL;
static jmethodID _notifier = NULL;

jboolean JNICALL avnStartDefence(JNIEnv* env, jclass klass) {
    return (jboolean)AvnStartDefence();
}

void JNICALL avnStopDefence(JNIEnv* env, jclass klass) {
    AvnStopDefence();
}

jboolean JNICALL avnIsStarted(JNIEnv* env, jclass klass) {
    return (jboolean)IsAvnStarted;
}

jboolean JNICALL avnIsStaticLoaded(JNIEnv* env, jclass klass) {
    return (jboolean)IsAvnStaticLoaded;
}

void JNICALL avnEliminateThreat(JNIEnv* env, jclass klass, jint threat) {
    EliminateThreat((AVN_THREAT)threat, NULL, etTerminate);
}

jlong JNICALL avnGetCpuid(JNIEnv* env, jclass klass) {
    return (jlong)HWIDs::GetCpuid();
}

jlong JNICALL avnGetSmbiosId(JNIEnv* env, jclass klass) {
    return (jlong)HWIDs::GetSmbiosId();
}

jlong JNICALL avnGetMacId(JNIEnv* env, jclass klass) {
    return (jlong)HWIDs::GetMacId();
}

jlong JNICALL avnGetHddId(JNIEnv* env, jclass klass) {
    return (jlong)HWIDs::GetHddId();
}

jlong JNICALL avnGetHash(JNIEnv* env, jclass klass, jbyteArray data) {
    jsize length = env->GetArrayLength(data);
    jbyte* buffer = (jbyte*)new jbyte[length];
    env->GetByteArrayRegion(data, 0, length, buffer);
    jlong hash = (jlong)t1ha(buffer, length, 0x1EE7C0DEC0FFEE);
    delete[] buffer;
    return hash;
}

void JNICALL avnRegisterNotifier(JNIEnv* env, jclass klass, jobject callback) {
    if (callback == NULL) {
        _klass = NULL;
        _notifier = NULL;
        return;
    }
    _klass = env->GetObjectClass(callback);
    _notifier = env->GetMethodID(_klass, "call", "(I)Z");
}

#ifdef TIMERED_CHECKINGS
void JNICALL setCheckTime(JNIEnv* env, jclass klass, jint timeCheck) {
    setTstTime((int)timeCheck);
}

jint JNICALL getCheckTime(JNIEnv* env, jclass klass) {
    return (jint)getTstTime();
}
#endif

jint JNICALL JNI_OnLoad(JavaVM* vm, void* reserved) {
    JNIEnv* env;
    jint status;

    status = vm->GetEnv((void**)&env, JNI_VERSION_1_8);
    if (status != JNI_OK)
        if (status == JNI_EDETACHED) 
            status = vm->AttachCurrentThread((void**)&env, NULL);
        else
            return JNI_ERR;

    if (status != JNI_OK) return JNI_ERR;

    jclass binding = env->FindClass("ru/zaxar163/GuardBind");
    const JNINativeMethod methods[] = {
        { "avnStartDefence"     , "()Z"     , (void*)avnStartDefence },
        { "avnStopDefence"      , "()V"     , (void*)avnStopDefence },
        { "avnIsStarted"        , "()Z"     , (void*)avnIsStarted },
        { "avnIsStaticLoaded"   , "()Z"     , (void*)avnIsStaticLoaded },
        { "avnEliminateThreat"  , "(I)V"    , (void*)avnEliminateThreat },
        { "avnGetCpuid"         , "()J"     , (void*)avnGetCpuid },
        { "avnGetSmbiosId"      , "()J"     , (void*)avnGetSmbiosId },
        { "avnGetMacId"         , "()J"     , (void*)avnGetMacId },
        { "avnGetHddId"         , "()J"     , (void*)avnGetHddId },
        { "avnGetHash"          , "([B)J"   , (void*)avnGetHash },
#ifdef TIMERED_CHECKINGS
        { "setCheckTime"          , "(I)V"   , (void*)setCheckTime },
        { "getCheckTime"          , "()I"   , (void*)getCheckTime },
#endif
        { "avnRegisterThreatNotifier", "(Lru/zaxar163/GuardBind$ThreatNotifier;)V", (void*)avnRegisterNotifier }
    };
    
    status = env->RegisterNatives(binding, methods, sizeof(methods) / sizeof(methods[0]));
    if (status != JNI_OK) return JNI_ERR;

    _vm = vm;
    _env = env;
    _IsJavaBinded = TRUE;
    return JNI_VERSION_1_8;
}

BOOL IsJavaBinded() {
    return _IsJavaBinded;
}

AVN_ET_ACTION CallJavaNotifier(AVN_THREAT Threat) {
    if (_vm == NULL || _env == NULL || _klass == NULL || _notifier == NULL) return etNotSpecified;

    jint status = _vm->AttachCurrentThread((void**)&_env, NULL);
    if (status != JNI_OK) return etNotSpecified;

    return _env->CallBooleanMethod(_klass, _notifier, (int)Threat)
        ? etContinue
        : etTerminate;
}

#endif
```

`Avanguard/AvanguardDefence/JavaBindings.h`:

```h
#pragma once

#include "AvnDefinitions.h"

#ifdef JAVA_BINDINGS

#include "jni.h"
#include "ThreatElimination.h"
#include "ThreatTypes.h"

JNIEXPORT 
jint JNICALL JNI_OnLoad(JavaVM* vm, void* reserved);

BOOL IsJavaBinded();
AVN_ET_ACTION CallJavaNotifier(AVN_THREAT Threat);

#endif
```

`Avanguard/AvanguardDefence/KeSecuredMemory.cpp`:

```cpp
#include "stdafx.h"
#include "KeSecuredMemory.h"

typedef BOOL (WINAPI *_AddSecureMemoryCacheCallback)(
    PSECURE_MEMORY_CACHE_CALLBACK Callback
);

typedef BOOL (WINAPI *_RemoveSecureMemoryCacheCallback)(
    PSECURE_MEMORY_CACHE_CALLBACK Callback
);

_KeSecuredMemoryCallback MmCallback = NULL;
BOOL MmCallbackIsActive = FALSE;

BOOLEAN CALLBACK SecureMemoryCacheCallback(
    _In_ PVOID  Addr,
    _In_ SIZE_T Range
) {
    return MmCallback ? MmCallback(Addr, Range) : TRUE;
}

BOOL SetupSecuredMemoryCallback(_KeSecuredMemoryCallback Callback) {
    static _AddSecureMemoryCacheCallback UAddSecureMemoryCacheCallback = NULL;
    if (UAddSecureMemoryCacheCallback) {
        UAddSecureMemoryCacheCallback = (_AddSecureMemoryCacheCallback)
            GetProcAddress(GetModuleHandle(L"kernel32.dll"), "AddSecureMemoryCacheCallback");
        if (UAddSecureMemoryCacheCallback == NULL) return FALSE;
    }

    if (Callback == NULL) {
        if (MmCallbackIsActive)
            return RemoveSecuredMemoryCallback();
        return FALSE;
    }
    
    MmCallback = Callback;
    if (!MmCallbackIsActive)
        return MmCallbackIsActive = UAddSecureMemoryCacheCallback(SecureMemoryCacheCallback);
    return TRUE;
}

BOOL RemoveSecuredMemoryCallback() {
    static _RemoveSecureMemoryCacheCallback URemoveSecureMemoryCacheCallback = NULL;
    if (URemoveSecureMemoryCacheCallback) {
        URemoveSecureMemoryCacheCallback = (_RemoveSecureMemoryCacheCallback)
            GetProcAddress(GetModuleHandle(L"kernel32.dll"), "RemoveSecureMemoryCacheCallback");
        if (URemoveSecureMemoryCacheCallback == NULL) return FALSE;
    }
    return MmCallbackIsActive = !URemoveSecureMemoryCacheCallback(SecureMemoryCacheCallback);
}
```

`Avanguard/AvanguardDefence/KeSecuredMemory.h`:

```h
#pragma once

#include <Windows.h>

// Работает, начиная с Vista SP1.
// На версиях ниже вызов всегда вернёт FALSE.

typedef BOOLEAN (CALLBACK *_KeSecuredMemoryCallback) (
    PVOID Address, SIZE_T Range
);

/*
    Устанавливает и удаляет каллбэки на изменение
    атрибутов доступа или освобождение защищённой памяти.
    Чтобы защитить память, необходимо в ядре вызвать
    функцию MmSecureVirtualMemory (необходим драйвер).

    Если указанная в параметрах каллбэка память была защищена,
    каллбэк обязан закрыть все отображения и вернуть TRUE.
    Если указанная в параметрах каллбэка память не попадает
    в защищённый диапазон, каллбэк должен вернуть FALSE.
*/
BOOL SetupSecuredMemoryCallback(_KeSecuredMemoryCallback Callback);
BOOL RemoveSecuredMemoryCallback();


```

`Avanguard/AvanguardDefence/KernelUtils.cpp`:

```cpp
#include "stdafx.h"
#include "KernelUtils.h"

VOID ReplaceString(std::wstring &Text, const std::wstring &Source, const std::wstring &Destination) {
    for (size_t Index = 0; Index = Text.find(Source, Index), Index != std::wstring::npos;) {
        Text.replace(Index, Source.length(), Destination);
        Index += Destination.length();
    }
}

std::wstring GetSpecialFolderPath(ULONG SpecialFolder) {
    WCHAR LocalPath[MAX_PATH];
    BOOL Status = SUCCEEDED(SHGetFolderPath(0, SpecialFolder, 0, SHGFP_TYPE_CURRENT, (LPWSTR)&LocalPath[0]));
    return Status ? LocalPath : L"";
}

typedef BOOL(WINAPI *_EnumDeviceDrivers)(OUT PVOID* Buffer, IN DWORD BufferSize, OUT PDWORD BytesReturned);
typedef DWORD(WINAPI *_GetDeviceDriverFileName)(IN PVOID ImageBase, OUT LPTSTR FileName, IN DWORD Size);
_EnumDeviceDrivers       UniversalEnumDeviceDrivers = (_EnumDeviceDrivers)NULL;
_GetDeviceDriverFileName UniversalGetDeviceDriverFileName = (_GetDeviceDriverFileName)NULL;

BOOL InitK32DeviceDriverFunctions() {
    static BOOL IsK32Initialized = FALSE;
    if (IsK32Initialized) return TRUE;

    HMODULE hKernel32 = GetModuleHandle(L"kernel32.dll");

    UniversalEnumDeviceDrivers = (_EnumDeviceDrivers)GetProcAddress(hKernel32, "K32EnumDeviceDrivers");
    UniversalGetDeviceDriverFileName = (_GetDeviceDriverFileName)GetProcAddress(hKernel32, "K32GetDeviceDriverFileNameW");
    if ((UniversalEnumDeviceDrivers == NULL) || (UniversalGetDeviceDriverFileName == NULL)) {
        HMODULE hPsapi = GetModuleHandle(L"Psapi.dll");
        if (hPsapi == NULL) hPsapi = LoadLibrary(L"Psapi.dll");
        if (hPsapi == NULL) return FALSE;

        UniversalEnumDeviceDrivers = (_EnumDeviceDrivers)GetProcAddress(hPsapi, "EnumDeviceDrivers");
        UniversalGetDeviceDriverFileName = (_GetDeviceDriverFileName)GetProcAddress(hPsapi, "GetDeviceDriverFileNameW");
    }
    return IsK32Initialized = ((UniversalEnumDeviceDrivers != NULL) && (UniversalGetDeviceDriverFileName != NULL));
}

BOOL UEnumDeviceDrivers(OUT PVOID* Buffer, IN DWORD BufferSize, OUT PDWORD BytesReturned) {
    if (!InitK32DeviceDriverFunctions()) return FALSE;
    return UniversalEnumDeviceDrivers(Buffer, BufferSize, BytesReturned);
}

BOOL UGetDeviceDriverFileName(IN PVOID ImageBase, OUT LPTSTR FileName, IN DWORD Size) {
    if (!InitK32DeviceDriverFunctions()) return FALSE;
    return UniversalGetDeviceDriverFileName(ImageBase, FileName, Size);
}

BOOL GetKernelModulesList(DRIVERS_LIST& DriversList) {
    DriversList.clear();
    BOOL Status = FALSE;
    DRIVER_INFO DriverInfo;
    std::wstring WindowsPath = GetSpecialFolderPath(CSIDL_WINDOWS);

    DWORD RequiredBufferSize = 0;
    UEnumDeviceDrivers(NULL, 0, &RequiredBufferSize);

    PVOID* Buffer = (PVOID*)new BYTE[RequiredBufferSize];

    DWORD BytesReturned = 0;
    if (!UEnumDeviceDrivers(Buffer, RequiredBufferSize, &BytesReturned))
        goto Exit;

    // Перебираем все драйвера:
    WCHAR Path[MAX_PATH];
    ULONG DriversCount = BytesReturned / sizeof(PVOID);
    DriversList.reserve(DriversCount);
    for (unsigned int i = 0; i < DriversCount; i++) {
        DriverInfo.BaseAddress = Buffer[i];
        DriverInfo.Path = UGetDeviceDriverFileName(DriverInfo.BaseAddress, &Path[0], MAX_PATH) != 0
            ? Path
            : L"";
        ReplaceString(DriverInfo.Path, std::wstring(L"\\SystemRoot"), WindowsPath);
        DriversList.push_back(DriverInfo);
    }

Exit:
    delete[] Buffer;
    return Status;
}

PVOID GetKernelBaseAddress() {
    DWORD RequiredBufferSize = 0;
    UEnumDeviceDrivers(NULL, 0, &RequiredBufferSize);

    if (RequiredBufferSize == 0) return NULL;

    PVOID* Buffer = (PVOID*)new BYTE[RequiredBufferSize];

    DWORD BytesReturned = 0;

    if (!UEnumDeviceDrivers(Buffer, RequiredBufferSize, &BytesReturned)) {
        delete[] Buffer;
        return NULL;
    }

    PVOID KernelBaseAddress = BytesReturned > 0 ? Buffer[0] : NULL;
    delete[] Buffer;
    return KernelBaseAddress;
}

std::wstring GetKernelPath() {
    std::wstring WindowsPath = GetSpecialFolderPath(CSIDL_WINDOWS);
    std::wstring KernelPath = GetKernelModulePath(GetKernelBaseAddress());
    ReplaceString(KernelPath, std::wstring(L"\\SystemRoot"), WindowsPath);
    return KernelPath;
}

std::wstring GetKernelModulePath(PVOID BaseAddress) {
    if (BaseAddress == NULL) return L"";

    CONST DWORD CharactersCount = 256;
    WCHAR Buffer[CharactersCount];

    return 
        UGetDeviceDriverFileName(
            BaseAddress, 
            &Buffer[0], 
            CharactersCount
        ) 
        ? Buffer 
        : L"";
}
```

`Avanguard/AvanguardDefence/KernelUtils.h`:

```h
#pragma once

#include <vector>
#include <string>
#include <ShlObj.h>
#include <Windows.h>

typedef struct _DRIVER_INFO {
    PVOID BaseAddress;
    std::wstring Path;
} DRIVER_INFO, *PDRIVER_INFO;

// Получить список загруженных драйверов и модулей ядра:
typedef std::vector<DRIVER_INFO> DRIVERS_LIST;
BOOL GetKernelModulesList(DRIVERS_LIST& DriversList);

// Получить базовый адрес загрузки ntoskrnl.exe:
PVOID GetKernelBaseAddress();

// Получить путь к файлу ntoskrnl.exe:
std::wstring GetKernelPath();

// Получить путь к модулю ядра по его адресу загрузки:
std::wstring GetKernelModulePath(PVOID BaseAddress);

// Динамически импортируемые функции из psapi.dll/kernel32.dll:
BOOL UEnumDeviceDrivers(OUT PVOID* Buffer, IN DWORD BufferSize, OUT PDWORD BytesReturned);
BOOL UGetDeviceDriverFileName(IN PVOID ImageBase, OUT LPTSTR FileName, IN DWORD Size);
```

`Avanguard/AvanguardDefence/Locks.h`:

```h
#pragma once

#include <Windows.h>

class CSLock final {
private:
    CRITICAL_SECTION CriticalSection;
public:
    inline CSLock(ULONG SpinCount = 0xC0DE5AFE) {
        if (SpinCount)
            InitializeCriticalSectionAndSpinCount(&CriticalSection, SpinCount);
        else
            InitializeCriticalSection(&CriticalSection);
    }

    inline ~CSLock() { 
        DeleteCriticalSection(&CriticalSection); 
    }
    
    inline bool TryLock() {
        TryEnterCriticalSection(&CriticalSection);
    }

    inline void Lock() { 
        EnterCriticalSection(&CriticalSection); 
    }

    inline void Unlock() { 
        LeaveCriticalSection(&CriticalSection); 
    }
};
```

`Avanguard/AvanguardDefence/MemoryCallbacks.cpp`:

```cpp
#include "stdafx.h"
#include "MemoryCallbacks.h"

MemoryStorage VMStorage;

static const ULONG CurrentProcessId = GetCurrentProcessId();

NTSTATUS NTAPI PreNtAllocateVirtualMemory(
    OUT		PBOOL		SkipOriginalCall,
    IN		HANDLE		ProcessHandle,
    IN OUT	PVOID*		BaseAddress,
    IN		ULONG_PTR	ZeroBits,
    IN OUT	PSIZE_T		RegionSize,
    IN		ULONG		AllocationType,
    IN		ULONG		Protect
) {
    return 0;
}

NTSTATUS NTAPI PostNtAllocateVirtualMemory(
    IN		NTSTATUS	ReturnValue,
    IN		HANDLE		ProcessHandle,
    IN OUT	PVOID*		BaseAddress,
    IN		ULONG_PTR	ZeroBits,
    IN OUT	PSIZE_T		RegionSize,
    IN		ULONG		AllocationType,
    IN		ULONG		Protect
) {
    if (GetProcessId(ProcessHandle) != CurrentProcessId) return ReturnValue;
    if ((NT_SUCCESS(ReturnValue)) && (Protect & EXECUTABLE_MEMORY))
        VMStorage.ProcessAllocation(*BaseAddress);
    return ReturnValue;
}



NTSTATUS NTAPI PreNtProtectVirtualMemory(
    OUT		PBOOL		SkipOriginalCall,
    IN		HANDLE		ProcessHandle,
    IN OUT	PVOID*		BaseAddress,
    IN OUT	PULONG		NumberOfBytesToProtect,
    IN		ULONG		NewAccessProtection,
    OUT		PULONG		OldAccessProtection
) {
    return 0;
}

NTSTATUS NTAPI PostNtProtectVirtualMemory(
    IN		NTSTATUS	ReturnValue,
    IN		HANDLE		ProcessHandle,
    IN OUT	PVOID*		BaseAddress,
    IN OUT	PULONG		NumberOfBytesToProtect,
    IN		ULONG		NewAccessProtection,
    OUT		PULONG		OldAccessProtection
) {
    if (GetProcessId(ProcessHandle) != CurrentProcessId) return ReturnValue;
    if (NT_SUCCESS(ReturnValue)) {
        // Неисполняемую сделали исполняемой:
        if ((NewAccessProtection & EXECUTABLE_MEMORY) && !(*OldAccessProtection & EXECUTABLE_MEMORY)) {
            VMStorage.ProcessAllocation(*BaseAddress);
        }
/*
        else
        // Исполняемую сделали неисполняемой:
        if (!(NewAccessProtection & EXECUTABLE_MEMORY) && (*OldAccessProtection & EXECUTABLE_MEMORY)) {
            VMStorage.ProcessFreeing(*BaseAddress);
        }
*/
    }
    return ReturnValue;
}



NTSTATUS NTAPI PreNtFreeVirtualMemory(
    OUT		PBOOL		SkipOriginalCall,
    IN		HANDLE		ProcessHandle,
    IN OUT	PVOID*		BaseAddress,
    IN OUT	PSIZE_T		RegionSize,
    IN		ULONG		FreeType
) {
    return 0;
}

NTSTATUS NTAPI PostNtFreeVirtualMemory(
    IN		NTSTATUS	ReturnValue,
    IN		HANDLE		ProcessHandle,
    IN OUT	PVOID*		BaseAddress,
    IN OUT	PSIZE_T		RegionSize,
    IN		ULONG		FreeType
) {
    if (GetProcessId(ProcessHandle) != CurrentProcessId) return ReturnValue;
    if (FreeType != MEM_RELEASE) return ReturnValue;
    if (NT_SUCCESS(ReturnValue))
        VMStorage.ProcessFreeing(*BaseAddress);
    return ReturnValue;
}

/*
NTSTATUS NTAPI PreNtMapViewOfSection(
    OUT				PBOOL			SkipOriginalCall,
    IN				HANDLE			SectionHandle,
    IN				HANDLE			ProcessHandle,
    IN OUT			PVOID*			BaseAddress,
    IN				ULONG_PTR		ZeroBits,
    IN				SIZE_T			CommitSize,
    IN OUT OPTIONAL	PLARGE_INTEGER	SectionOffset,
    IN OUT			PSIZE_T			ViewSize,
    IN				SECTION_INHERIT	InheritDisposition,
    IN				ULONG			AllocationType,
    IN				ULONG			Win32Protect
) {
    return 0;
}

NTSTATUS NTAPI PostNtMapViewOfSection(
    IN				NTSTATUS		ReturnValue,
    IN				HANDLE			SectionHandle,
    IN				HANDLE			ProcessHandle,
    IN OUT			PVOID*			BaseAddress,
    IN				ULONG_PTR		ZeroBits,
    IN				SIZE_T			CommitSize,
    IN OUT OPTIONAL	PLARGE_INTEGER	SectionOffset,
    IN OUT			PSIZE_T			ViewSize,
    IN				SECTION_INHERIT	InheritDisposition,
    IN				ULONG			AllocationType,
    IN				ULONG			Win32Protect
) {
    if (GetProcessId(ProcessHandle) != CurrentProcessId) return ReturnValue;
    if ((NT_SUCCESS(ReturnValue)) && (Win32Protect & EXECUTABLE_MEMORY)) {
        VMStorage.ProcessAllocation(*BaseAddress);
    }
    return ReturnValue;
}


NTSTATUS NTAPI PreNtUnmapViewOfSection(
    OUT			PBOOL	SkipOriginalCall,
    IN			HANDLE	ProcessHandle,
    IN OPTIONAL	PVOID	BaseAddress
) {
    return 0;
}

NTSTATUS NTAPI PostNtUnmapViewOfSection(
    IN			NTSTATUS	ReturnValue,
    IN			HANDLE		ProcessHandle,
    IN OPTIONAL	PVOID		BaseAddress
) {
    if (GetProcessId(ProcessHandle) != CurrentProcessId) return ReturnValue;
    if (NT_SUCCESS(ReturnValue))
        VMStorage.ProcessFreeing(BaseAddress);
    return ReturnValue;
}
*/
```

`Avanguard/AvanguardDefence/MemoryCallbacks.h`:

```h
#pragma once

#include "MemoryFilter.h"
#include "MemoryStorage.h"
#include "Mitigations.h"

extern MemoryStorage VMStorage;

NTSTATUS NTAPI PreNtAllocateVirtualMemory(
    OUT		PBOOL		SkipOriginalCall,
    IN		HANDLE		ProcessHandle,
    IN OUT	PVOID*		BaseAddress,
    IN		ULONG_PTR	ZeroBits,
    IN OUT	PSIZE_T		RegionSize,
    IN		ULONG		AllocationType,
    IN		ULONG		Protect
);

NTSTATUS NTAPI PostNtAllocateVirtualMemory(
    IN		NTSTATUS	ReturnValue,
    IN		HANDLE		ProcessHandle,
    IN OUT	PVOID*		BaseAddress,
    IN		ULONG_PTR	ZeroBits,
    IN OUT	PSIZE_T		RegionSize,
    IN		ULONG		AllocationType,
    IN		ULONG		Protect
);

NTSTATUS NTAPI PreNtProtectVirtualMemory(
    OUT		PBOOL		SkipOriginalCall,
    IN		HANDLE		ProcessHandle,
    IN OUT	PVOID*		BaseAddress,
    IN OUT	PULONG		NumberOfBytesToProtect,
    IN		ULONG		NewAccessProtection,
    OUT		PULONG		OldAccessProtection
);

NTSTATUS NTAPI PostNtProtectVirtualMemory(
    IN		NTSTATUS	ReturnValue,
    IN		HANDLE		ProcessHandle,
    IN OUT	PVOID*		BaseAddress,
    IN OUT	PULONG		NumberOfBytesToProtect,
    IN		ULONG		NewAccessProtection,
    OUT		PULONG		OldAccessProtection
);

NTSTATUS NTAPI PreNtFreeVirtualMemory(
    OUT		PBOOL		SkipOriginalCall,
    IN		HANDLE		ProcessHandle,
    IN OUT	PVOID*		BaseAddress,
    IN OUT	PSIZE_T		RegionSize,
    IN		ULONG		FreeType
);

NTSTATUS NTAPI PostNtFreeVirtualMemory(
    IN		NTSTATUS	ReturnValue,
    IN		HANDLE		ProcessHandle,
    IN OUT	PVOID*		BaseAddress,
    IN OUT	PSIZE_T		RegionSize,
    IN		ULONG		FreeType
);

/*
NTSTATUS NTAPI PreNtMapViewOfSection(
    OUT				PBOOL			SkipOriginalCall,
    IN				HANDLE			SectionHandle,
    IN				HANDLE			ProcessHandle,
    IN OUT			PVOID*			BaseAddress,
    IN				ULONG_PTR		ZeroBits,
    IN				SIZE_T			CommitSize,
    IN OUT OPTIONAL	PLARGE_INTEGER	SectionOffset,
    IN OUT			PSIZE_T			ViewSize,
    IN				SECTION_INHERIT	InheritDisposition,
    IN				ULONG			AllocationType,
    IN				ULONG			Win32Protect
);

NTSTATUS NTAPI PostNtMapViewOfSection(
    IN				NTSTATUS		ReturnValue,
    IN				HANDLE			SectionHandle,
    IN				HANDLE			ProcessHandle,
    IN OUT			PVOID*			BaseAddress,
    IN				ULONG_PTR		ZeroBits,
    IN				SIZE_T			CommitSize,
    IN OUT OPTIONAL	PLARGE_INTEGER	SectionOffset,
    IN OUT			PSIZE_T			ViewSize,
    IN				SECTION_INHERIT	InheritDisposition,
    IN				ULONG			AllocationType,
    IN				ULONG			Win32Protect
);

NTSTATUS NTAPI PreNtUnmapViewOfSection(
    OUT			PBOOL	SkipOriginalCall,
    IN			HANDLE	ProcessHandle,
    IN OPTIONAL	PVOID	BaseAddress
);

NTSTATUS NTAPI PostNtUnmapViewOfSection(
    IN			NTSTATUS	ReturnValue,
    IN			HANDLE		ProcessHandle,
    IN OPTIONAL	PVOID		BaseAddress
);
*/
```

`Avanguard/AvanguardDefence/MemoryFilter.cpp`:

```cpp
#include "stdafx.h"
#include "MemoryFilter.h"


// Because of possible loader-locks we shouldn't filtrate the NtMap[Unmap]ViewOfSection!
/*
FILTRATION(
    NTSTATUS, NTAPI, NtMapViewOfSection,
    IN				HANDLE			SectionHandle,
    IN				HANDLE			ProcessHandle,
    IN OUT			PVOID*			BaseAddress,
    IN				ULONG_PTR		ZeroBits,
    IN				SIZE_T			CommitSize,
    IN OUT OPTIONAL	PLARGE_INTEGER	SectionOffset,
    IN OUT			PSIZE_T			ViewSize,
    IN				SECTION_INHERIT	InheritDisposition,
    IN				ULONG			AllocationType,
    IN				ULONG			Win32Protect
) {
    FILTRATE(
        NTSTATUS, Status, NtMapViewOfSection,
        SectionHandle, ProcessHandle, BaseAddress, ZeroBits, CommitSize, 
        SectionOffset, ViewSize, InheritDisposition, AllocationType, Win32Protect
    );
    return Status;
}

FILTRATION(
    NTSTATUS, NTAPI, NtUnmapViewOfSection,
    IN			HANDLE ProcessHandle,
    IN OPTIONAL	PVOID  BaseAddress
) {
    FILTRATE(
        NTSTATUS, Status, NtUnmapViewOfSection, 
        ProcessHandle, BaseAddress
    );
    return Status;
}
*/

FILTRATION(
    NTSTATUS, NTAPI, NtAllocateVirtualMemory,
    IN		HANDLE		ProcessHandle,
    IN OUT	PVOID*		BaseAddress,
    IN		ULONG_PTR	ZeroBits,
    IN OUT	PSIZE_T		RegionSize,
    IN		ULONG		AllocationType,
    IN		ULONG		Protect
) {
    FILTRATE(
        NTSTATUS, Status, NtAllocateVirtualMemory,
        ProcessHandle, BaseAddress, ZeroBits, RegionSize, AllocationType, Protect
    );
    return Status;
}



FILTRATION(
    NTSTATUS, NTAPI, NtProtectVirtualMemory,
    IN		HANDLE	ProcessHandle,
    IN OUT	PVOID*	BaseAddress,
    IN OUT	PULONG	NumberOfBytesToProtect,
    IN		ULONG	NewAccessProtection,
    OUT		PULONG	OldAccessProtection
) {
    FILTRATE(
        NTSTATUS, Status, NtProtectVirtualMemory,
        ProcessHandle, BaseAddress, NumberOfBytesToProtect, NewAccessProtection, OldAccessProtection
    );
    return Status;
}

FILTRATION(
    NTSTATUS, NTAPI, NtFreeVirtualMemory,
    IN		HANDLE	ProcessHandle,
    IN OUT	PVOID*	BaseAddress,
    IN OUT	PSIZE_T	RegionSize,
    IN		ULONG	FreeType
) {
    FILTRATE(
        NTSTATUS, Status, NtFreeVirtualMemory,
        ProcessHandle, BaseAddress, RegionSize, FreeType
    );
    return Status;
}

BOOL IsMemHooksInitialized = FALSE;

const PVOID pNtAllocateVirtualMemory = hModules::QueryAddress(hModules::hNtdll(), XORSTR("NtAllocateVirtualMemory"));
const PVOID pNtProtectVirtualMemory = hModules::QueryAddress(hModules::hNtdll(), XORSTR("NtProtectVirtualMemory"));
const PVOID pNtFreeVirtualMemory = hModules::QueryAddress(hModules::hNtdll(), XORSTR("NtFreeVirtualMemory"));
//const PVOID pNtMapViewOfSection = hModules::QueryAddress(hModules::hNtdll(), XORSTR("NtMapViewOfSection"));
//const PVOID pNtUnmapViewOfSection = hModules::QueryAddress(hModules::hNtdll(), XORSTR("NtUnmapViewOfSection"));

HOOK_INFO HooksInfo[] = {
    INTERCEPTION_ENTRY(pNtAllocateVirtualMemory, NtAllocateVirtualMemory),
    INTERCEPTION_ENTRY(pNtProtectVirtualMemory, NtProtectVirtualMemory),
    INTERCEPTION_ENTRY(pNtFreeVirtualMemory, NtFreeVirtualMemory),
    //INTERCEPTION_ENTRY(pNtMapViewOfSection, NtMapViewOfSection),
    //INTERCEPTION_ENTRY(pNtUnmapViewOfSection, NtUnmapViewOfSection)
};

BOOL SetupMemoryCallbacks(
    _AllocMemoryPreCallback		AllocPreCallback,
    _AllocMemoryPostCallback	AllocPostCallback,
    _ProtectMemoryPreCallback	ProtectPreCallback,
    _ProtectMemoryPostCallback	ProtectPostCallback,
    _FreeMemoryPreCallback		FreePreCallback,
    _FreeMemoryPostCallback		FreePostCallback
    //_MapMemoryPreCallback		MapPreCallback,
    //_MapMemoryPostCallback	MapPostCallback,
    //_UnmapMemoryPreCallback	UnmapPreCallback,
    //_UnmapMemoryPostCallback	UnmapPostCallback
) {
    DEFINE_FILTERS(NtAllocateVirtualMemory, AllocPreCallback, AllocPostCallback);
    DEFINE_FILTERS(NtProtectVirtualMemory, ProtectPreCallback, ProtectPostCallback);
    DEFINE_FILTERS(NtFreeVirtualMemory, FreePreCallback, FreePostCallback);
    //DEFINE_FILTERS(NtMapViewOfSection, MapPreCallback, MapPostCallback);
    //DEFINE_FILTERS(NtUnmapViewOfSection, UnmapPreCallback, UnmapPostCallback);

    if (IsMemHooksInitialized) return TRUE;

    IsMemHooksInitialized = HookEmAll(HooksInfo, sizeof(HooksInfo) / sizeof(HOOK_INFO));
    return IsMemHooksInitialized;
}

VOID RemoveMemoryCallbacks() {
    if (IsMemHooksInitialized)
        UnHookEmAll(HooksInfo, sizeof(HooksInfo) / sizeof(HOOK_INFO));
}
```

`Avanguard/AvanguardDefence/MemoryFilter.h`:

```h
#pragma once

#include "hModules.h"
#include "..\\HoShiMin's API\\HookHelper.h"

typedef NTSTATUS (CALLBACK *_AllocMemoryPreCallback) (
    OUT		PBOOL		SkipOriginalCall,
    IN		HANDLE		ProcessHandle,
    IN OUT	PVOID*		BaseAddress,
    IN		ULONG_PTR	ZeroBits,
    IN OUT	PSIZE_T		RegionSize,
    IN		ULONG		AllocationType,
    IN		ULONG		Protect
);

typedef NTSTATUS (CALLBACK *_AllocMemoryPostCallback) (
    IN		NTSTATUS	ReturnValue,
    IN		HANDLE		ProcessHandle,
    IN OUT	PVOID*		BaseAddress,
    IN		ULONG_PTR	ZeroBits,
    IN OUT	PSIZE_T		RegionSize,
    IN		ULONG		AllocationType,
    IN		ULONG		Protect
);


typedef NTSTATUS (CALLBACK *_ProtectMemoryPreCallback) (
    OUT		PBOOL		SkipOriginalCall,
    IN		HANDLE		ProcessHandle,
    IN OUT	PVOID*		BaseAddress,
    IN OUT	PULONG		NumberOfBytesToProtect,
    IN		ULONG		NewAccessProtection,
    OUT		PULONG		OldAccessProtection
);

typedef NTSTATUS (CALLBACK *_ProtectMemoryPostCallback) (
    IN		NTSTATUS	ReturnValue,
    IN		HANDLE		ProcessHandle,
    IN OUT	PVOID*		BaseAddress,
    IN OUT	PULONG		NumberOfBytesToProtect,
    IN		ULONG		NewAccessProtection,
    OUT		PULONG		OldAccessProtection
);


typedef NTSTATUS (CALLBACK *_FreeMemoryPreCallback) (
    OUT		PBOOL		SkipOriginalCall,
    IN		HANDLE		ProcessHandle,
    IN OUT	PVOID*		BaseAddress,
    IN OUT	PSIZE_T		RegionSize,
    IN		ULONG		FreeType
);

typedef NTSTATUS (CALLBACK *_FreeMemoryPostCallback) (
    IN		NTSTATUS	ReturnValue,
    IN		HANDLE		ProcessHandle,
    IN OUT	PVOID*		BaseAddress,
    IN OUT	PSIZE_T		RegionSize,
    IN		ULONG		FreeType
);

// Because of possible loader-locks we shouldn't filtrate the NtMap[Unmap]ViewOfSection!
/*
enum SECTION_INHERIT {
    ViewShare,
    ViewUnmap
};

typedef NTSTATUS (CALLBACK *_MapMemoryPreCallback) (
    OUT				PBOOL			SkipOriginalCall,
    IN				HANDLE			SectionHandle,
    IN				HANDLE			ProcessHandle,
    IN OUT			PVOID*			BaseAddress,
    IN				ULONG_PTR		ZeroBits,
    IN				SIZE_T			CommitSize,
    IN OUT OPTIONAL	PLARGE_INTEGER	SectionOffset,
    IN OUT			PSIZE_T			ViewSize,
    IN				SECTION_INHERIT	InheritDisposition,
    IN				ULONG			AllocationType,
    IN				ULONG			Win32Protect
);

typedef NTSTATUS (CALLBACK *_MapMemoryPostCallback) (
    IN				NTSTATUS		ReturnValue,
    IN				HANDLE			SectionHandle,
    IN				HANDLE			ProcessHandle,
    IN OUT			PVOID*			BaseAddress,
    IN				ULONG_PTR		ZeroBits,
    IN				SIZE_T			CommitSize,
    IN OUT OPTIONAL	PLARGE_INTEGER	SectionOffset,
    IN OUT			PSIZE_T			ViewSize,
    IN				SECTION_INHERIT	InheritDisposition,
    IN				ULONG			AllocationType,
    IN				ULONG			Win32Protect
);

typedef NTSTATUS (CALLBACK *_UnmapMemoryPreCallback) (
    OUT			PBOOL	SkipOriginalCall,
    IN			HANDLE	ProcessHandle,
    IN OPTIONAL	PVOID	BaseAddress
);

typedef NTSTATUS (CALLBACK *_UnmapMemoryPostCallback) (
    IN			NTSTATUS	ReturnValue,
    IN			HANDLE		ProcessHandle,
    IN OPTIONAL	PVOID		BaseAddress
);
*/


BOOL SetupMemoryCallbacks(
    _AllocMemoryPreCallback		AllocPreCallback,
    _AllocMemoryPostCallback	AllocPostCallback,
    _ProtectMemoryPreCallback	ProtectPreCallback,
    _ProtectMemoryPostCallback	ProtectPostCallback,
    _FreeMemoryPreCallback		FreePreCallback,
    _FreeMemoryPostCallback		FreePostCallback
    //_MapMemoryPreCallback		MapPreCallback,
    //_MapMemoryPostCallback	MapPostCallback,
    //_UnmapMemoryPreCallback	UnmapPreCallback,
    //_UnmapMemoryPostCallback	UnmapPostCallback
);

VOID RemoveMemoryCallbacks();
```

`Avanguard/AvanguardDefence/MemoryStorage.cpp`:

```cpp
#include "stdafx.h"
#include "MemoryStorage.h"

size_t inline AlignDown(size_t Value, size_t Factor) {
    return Value & ~(Factor - 1);
}

size_t inline AlignUp(size_t Value, size_t Factor) {
    return AlignDown(Value - 1, Factor) + Factor;
}

MemoryStorage::MemoryStorage() {
    ReloadMemoryRegions();
}

MemoryStorage::~MemoryStorage() {
    MemoryMap.clear();
}

void MemoryStorage::AddRegion(PVOID Address) {
    MEMORY_BASIC_INFORMATION MemoryInfo;
    QueryVirtualMemory(Address, &MemoryInfo);
    MemoryMap[MemoryInfo.AllocationBase] = TRUE;
}

void MemoryStorage::RemoveRegion(PVOID Address) {
    MEMORY_BASIC_INFORMATION MemoryInfo;
    QueryVirtualMemory(Address, &MemoryInfo);
    if (MemoryMap.find(MemoryInfo.AllocationBase) != MemoryMap.end())
        MemoryMap[MemoryInfo.AllocationBase] = FALSE;
}

void MemoryStorage::ReloadMemoryRegions() {
    MemoryMap.clear();
    EnumerateMemoryRegions(GetCurrentProcess(), [this](const PMEMORY_BASIC_INFORMATION Info) -> bool {
        if (Info->Protect & EXECUTABLE_MEMORY) 
            AddRegion(Info->BaseAddress);
        return true;
    });
}

void MemoryStorage::ProcessAllocation(PVOID Base) {
    AddRegion(Base);
}

void MemoryStorage::ProcessFreeing(PVOID Base) {
    RemoveRegion(Base);
}

bool MemoryStorage::IsMemoryInMap(PVOID Address) {
    MEMORY_BASIC_INFORMATION MemoryInfo;
    QueryVirtualMemory(Address, &MemoryInfo);
    return MemoryMap.find(MemoryInfo.AllocationBase) != MemoryMap.end();
}
```

`Avanguard/AvanguardDefence/MemoryStorage.h`:

```h
#pragma once

#include <algorithm>
#include <concurrent_unordered_map.h>

#include "ProcessAPI.h"
#include "Locks.h"

#define PAGE_SIZE 4096
#define EXECUTABLE_MEMORY (PAGE_EXECUTE | PAGE_EXECUTE_READ | PAGE_EXECUTE_READWRITE | PAGE_EXECUTE_WRITECOPY)

class MemoryStorage {
private:
    concurrency::concurrent_unordered_map<PVOID, BOOL> MemoryMap; // BaseAddress -> Present
    void AddRegion(PVOID Address);
    void RemoveRegion(PVOID Address);
public:
    MemoryStorage();
    ~MemoryStorage();

    void ReloadMemoryRegions();

    void ProcessAllocation(PVOID Base);
    void ProcessFreeing(PVOID Base);
    bool IsMemoryInMap(PVOID Address);
};
```

`Avanguard/AvanguardDefence/Mitigations.cpp`:

```cpp
#include "stdafx.h"
#include "Mitigations.h"

BOOL Mitigations::Initialized = FALSE;

_SetThreadInformation Mitigations::__SetThreadInformation;
_SetProcessMitigationPolicy Mitigations::__SetProcessMitigationPolicy;

BOOL Mitigations::Initialize() {
#if (_WIN32_WINNT > _WIN32_WINNT_WINBLUE)
    if (!IsWindows8Point1OrGreater()) return FALSE;
    if (Initialized) return TRUE;
    __SetThreadInformation = (_SetThreadInformation)hModules::QueryAddress(hModules::hKernel32(), XORSTR("SetThreadInformation"));
    __SetProcessMitigationPolicy = (_SetProcessMitigationPolicy)hModules::QueryAddress(hModules::hKernel32(), XORSTR("SetProcessMitigationPolicy"));
    return Initialized = __SetThreadInformation && __SetProcessMitigationPolicy;
#else
    return FALSE;
#endif
}

BOOL Mitigations::SetProhibitDynamicCode(BOOL AllowThreadsOptOut) {
#if (_WIN32_WINNT > _WIN32_WINNT_WINBLUE)
    if (!Initialized && !Initialize()) return FALSE;

    PROCESS_MITIGATION_DYNAMIC_CODE_POLICY Policy = { 0 };
    Policy.ProhibitDynamicCode = TRUE;
    Policy.AllowThreadOptOut = AllowThreadsOptOut;
    return __SetProcessMitigationPolicy(
        ProcessDynamicCodePolicy,
        &Policy,
        sizeof(Policy)
    );
#else
    return FALSE;
#endif
}

BOOL Mitigations::SetThreadAllowedDynamicCode() {
#if (_WIN32_WINNT > _WIN32_WINNT_WINBLUE)
    if (!Initialized && !Initialize()) return FALSE;

#define THREAD_DYNAMIC_CODE_ALLOW 1
    DWORD Policy = THREAD_DYNAMIC_CODE_ALLOW;
    BOOL Status = __SetThreadInformation(GetCurrentThread(), ThreadDynamicCodePolicy, &Policy, sizeof(Policy));
    return Status;
#undef THREAD_DYNAMIC_CODE_ALLOW
#else
    return FALSE;
#endif
}
```

`Avanguard/AvanguardDefence/Mitigations.h`:

```h
#pragma once

#include <winternl.h>
#include <processthreadsapi.h>
#include <VersionHelpers.h>

#include "hModules.h"

typedef BOOL (WINAPI *_SetThreadInformation)(
    HANDLE hThread,
    THREAD_INFORMATION_CLASS ThreadInformationClass,
    LPVOID ThreadInformation,
    DWORD ThreadInformationSize
);

typedef BOOL (WINAPI *_SetProcessMitigationPolicy)(
    PROCESS_MITIGATION_POLICY	MitigationPolicy,
    PVOID						lpBuffer,
    SIZE_T						dwLength
);

class Mitigations final {
private:
    static BOOL Initialized;
    static _SetThreadInformation __SetThreadInformation;
    static _SetProcessMitigationPolicy __SetProcessMitigationPolicy;
    static BOOL Initialize();
public:
    static BOOL SetProhibitDynamicCode(BOOL AllowThreadsOptOut);
    static BOOL SetThreadAllowedDynamicCode();
};
```

`Avanguard/AvanguardDefence/ModulesCallbacks.cpp`:

```cpp
#include "stdafx.h"
#include "ModulesCallbacks.h"

#include "AvnApi.h"
extern AVN_API AvnApi;

ModulesStorage ValidModulesStorage(TRUE);

static _OnWindowsHookLoad WinHookLoadCallback;
static _OnUnknownTraceLoad UnknownTraceLoadCallback;

NTSTATUS CALLBACK PreLoadModuleCallback(
    OUT PBOOL			SkipOriginalCall,
    IN PWCHAR			PathToFile,
    IN PULONG			Flags,
    IN PUNICODE_STRING	ModuleFileName,
    OUT PHANDLE			ModuleHandle
) {
#if defined WINDOWS_HOOKS_FILTER || defined STACKTRACE_CHECK
    AvnApi.AvnLock();

#ifdef WINDOWS_HOOKS_FILTER
    if (WinHooks::IsCalledFromWinHook() && WinHookLoadCallback) 
        *SkipOriginalCall = !WinHookLoadCallback(ModuleFileName);
#endif

    if (!*SkipOriginalCall) {
#ifdef STACKTRACE_CHECK
        const int TraceCount = 35;
        PVOID Ptrs[TraceCount];
        USHORT Captured = CaptureStackBackTrace(0, TraceCount, Ptrs, NULL);
        for (unsigned short i = 0; i < Captured; i++) {
            PVOID Address = Ptrs[i];
            HMODULE hModule = GetModuleBase(Address);
#ifdef MEMORY_FILTER
            BOOL IsAddressAllowed = hModule == NULL 
                ? VMStorage.IsMemoryInMap(Address) 
                : ValidModulesStorage.IsModuleInStorage(hModule);
#else
            BOOL IsAddressAllowed = hModule != NULL 
                ? ValidModulesStorage.IsModuleInStorage(hModule) 
                : FALSE;
#endif
            if (!IsAddressAllowed && *SkipOriginalCall && UnknownTraceLoadCallback) 
                *SkipOriginalCall = !UnknownTraceLoadCallback(Address, ModuleFileName);
        }
#endif
    }

    AvnApi.AvnUnlock();
#endif
    
    return STATUS_SUCCESS;
}

VOID CALLBACK DllNotificationRoutine(
    LDR_NOTIFICATION_REASON Reason,
    IN PLDR_DLL_NOTIFICATION_DATA NotificationData,
    IN PCONTEXT Context
) {
    switch (Reason) {
    case LdrModuleLoaded:
        ValidModulesStorage.AddModule((HMODULE)NotificationData->DllBase);
        break;

    case LdrModuleUnloaded:
        ValidModulesStorage.RemoveModule((HMODULE)NotificationData->DllBase);
        break;
    }
}

VOID SetupWindowsHooksFilter(_OnWindowsHookLoad Callback) {
    WinHookLoadCallback = Callback;
}

VOID SetupUnknownTraceLoadCallback(_OnUnknownTraceLoad Callback) {
    UnknownTraceLoadCallback = Callback;
}
```

`Avanguard/AvanguardDefence/ModulesCallbacks.h`:

```h
#pragma once

#include "AvnDefinitions.h"
#include "PebTeb.h"
#include "ModulesFilter.h"
#include "ModulesStorage.h"
#include "MemoryCallbacks.h"
#include "WinHooks.h"

#include "..\\HoShiMin's API\\ColoredConsole.h"
#include "..\\HoShiMin's API\\DisasmHelper.h"

#include <set>
#include <vector>

extern ModulesStorage ValidModulesStorage;

NTSTATUS CALLBACK PreLoadModuleCallback(
    OUT PBOOL			SkipOriginalCall,
    IN PWCHAR			PathToFile,
    IN PULONG			Flags,
    IN PUNICODE_STRING	ModuleFileName,
    OUT PHANDLE			ModuleHandle
);

VOID CALLBACK DllNotificationRoutine(
    LDR_NOTIFICATION_REASON Reason,
    IN PLDR_DLL_NOTIFICATION_DATA NotificationData,
    IN PCONTEXT Context
);

// Вернуть FALSE для отмены загрузки модуля:
typedef BOOL(CALLBACK *_OnWindowsHookLoad)(PUNICODE_STRING ModuleFileName);
typedef BOOL(CALLBACK *_OnUnknownTraceLoad)(PVOID Address, PUNICODE_STRING ModuleFileName);

VOID SetupWindowsHooksFilter(_OnWindowsHookLoad Callback);
VOID SetupUnknownTraceLoadCallback(_OnUnknownTraceLoad Callback);
```

`Avanguard/AvanguardDefence/ModulesFilter.cpp`:

```cpp
#include "stdafx.h"
#include "ModulesFilter.h"

BOOL				ModulesFilter::Enabled		= FALSE;
BOOL				ModulesFilter::Initialized	= FALSE;
HOOK_INFO			ModulesFilter::HookInfo[2]	= { 0 };
PVOID				ModulesFilter::Cookie = NULL;

_LdrLoadDll			ModulesFilter::LdrLoadDll	= NULL;
_LdrUnloadDll		ModulesFilter::LdrUnloadDll	= NULL;
_LdrLoadDll			ModulesFilter::OrgnlLdrLoadDll	 = NULL;
_LdrUnloadDll		ModulesFilter::OrgnlLdrUnloadDll = NULL;

_PreLoadCallback	ModulesFilter::PreLoadCallback		= NULL;
_PostLoadCallback	ModulesFilter::PostLoadCallback		= NULL;
_PreUnloadCallback	ModulesFilter::PreUnloadCallback	= NULL;
_PostUnloadCallback	ModulesFilter::PostUnloadCallback	= NULL;

_LdrRegisterDllNotification		ModulesFilter::LdrRegisterDllNotification	= NULL;
_LdrUnregisterDllNotification	ModulesFilter::LdrUnregisterDllNotification = NULL;
_DllNotificationRoutine			ModulesFilter::DllNotificationRoutine		= NULL;

BOOL ModulesFilter::Initialize() {
    if (Initialized) return TRUE;

    LdrRegisterDllNotification =
        (_LdrRegisterDllNotification)hModules::QueryAddress(hModules::hNtdll(), XORSTR("LdrRegisterDllNotification"));
    LdrUnregisterDllNotification =
        (_LdrUnregisterDllNotification)hModules::QueryAddress(hModules::hNtdll(), XORSTR("LdrUnregisterDllNotification"));
    
    LdrLoadDll = (_LdrLoadDll)hModules::QueryAddress(hModules::hNtdll(), XORSTR("LdrLoadDll"));
    LdrUnloadDll = (_LdrUnloadDll)hModules::QueryAddress(hModules::hNtdll(), XORSTR("LdrUnloadDll"));

    HookInfo[0] = INTERCEPTION_ENTRY(LdrLoadDll, LdrLoadDll);
    HookInfo[1] = INTERCEPTION_ENTRY(LdrUnloadDll, LdrUnloadDll);

    return Initialized = LdrLoadDll && LdrUnloadDll;
}



NTSTATUS ModulesFilter::HkdLdrLoadDll(
    IN PWCHAR			PathToFile,
    IN PULONG			Flags,
    IN PUNICODE_STRING	ModuleFileName,
    OUT PHANDLE			ModuleHandle
) {
    FILTRATE_TO(
        NTSTATUS, Status, LdrLoadDll, PreLoadCallback, PostLoadCallback,
        PathToFile, Flags, ModuleFileName, ModuleHandle	
    );
    return Status;
}

NTSTATUS ModulesFilter::HkdLdrUnloadDll(
    IN HANDLE ModuleHandle
) {
    FILTRATE_TO(
        NTSTATUS, Status, LdrUnloadDll, PreUnloadCallback, PostUnloadCallback,
        ModuleHandle
    );
    return Status;
}



VOID CALLBACK ModulesFilter::LdrDllNotificationFunction(
    _In_		ULONG						NotificationReason,
    _In_		PLDR_DLL_NOTIFICATION_DATA	NotificationData,
    _In_opt_	PVOID						Context
) {
    if (DllNotificationRoutine)
        DllNotificationRoutine((LDR_NOTIFICATION_REASON)NotificationReason, NotificationData, (PCONTEXT)Context);
}



BOOL ModulesFilter::EnableModulesFilter() {
    if (!Initialized && !Initialize()) return FALSE;
    if (Enabled) return TRUE;

    MH_Initialize();
    return Enabled = HookEmAll(HookInfo, sizeof(HookInfo) / sizeof(HookInfo[0]));
}

VOID ModulesFilter::DisableModulesFilter() {
    if (!Initialized && !Initialize()) return;
    if (!Enabled) return;
    UnHookEmAll(HookInfo, sizeof(HookInfo) / sizeof(HookInfo[0]));
    Enabled = FALSE;
}

BOOL ModulesFilter::EnableDllNotification() {
    if (!Initialized && !Initialize()) return FALSE;
    if (Cookie) return TRUE;

    if (LdrRegisterDllNotification)
        return LdrRegisterDllNotification(
            0,
            LdrDllNotificationFunction,
            NULL,
            &Cookie
        ) == STATUS_SUCCESS;
    return FALSE;
}

VOID ModulesFilter::DisableDllNotification() {
    if (!Initialized && !Initialize()) return;
    if (Cookie == NULL) return;

    if (LdrUnregisterDllNotification)
        LdrUnregisterDllNotification(Cookie);
}

VOID ModulesFilter::SetupFilterCallbacks(
    OPTIONAL _PreLoadCallback PreLoad,
    OPTIONAL _PostLoadCallback PostLoad,
    OPTIONAL _PreUnloadCallback PreUnload,
    OPTIONAL _PostUnloadCallback PostUnload
) {
    PreLoadCallback = PreLoad;
    PostLoadCallback = PostLoad;
    PreUnloadCallback = PreUnload;
    PostUnloadCallback = PostUnload;
}

VOID ModulesFilter::SetupNotificationCallbacks(
    OPTIONAL _DllNotificationRoutine Callback
) {
    DllNotificationRoutine = Callback;
}
```

`Avanguard/AvanguardDefence/ModulesFilter.h`:

```h
#pragma once

#include <Windows.h>
#pragma warning(push)
#pragma warning(disable: 4005)
#include <winternl.h>
#include <ntstatus.h>
#pragma warning(pop)

#include "hModules.h"

#include "..\\HoShiMin's API\\HookHelper.h"

/* Системные определения */

typedef NTSTATUS (NTAPI *_LdrLoadDll) (
    IN PWCHAR			PathToFile,
    IN PULONG			Flags,
    IN PUNICODE_STRING	ModuleFileName,
    OUT PHANDLE			ModuleHandle
);

typedef NTSTATUS (NTAPI *_LdrUnloadDll) (
    IN HANDLE ModuleHandle
);

#define LDR_DLL_NOTIFICATION_REASON_LOADED		1
#define LDR_DLL_NOTIFICATION_REASON_UNLOADED	2

typedef struct _LDR_DLL_NOTIFICATION_DATA {
    ULONG Flags;					// Reserved.
    PCUNICODE_STRING FullDllName;	// The full path name of the DLL module.
    PCUNICODE_STRING BaseDllName;	// The base file name of the DLL module.
    PVOID DllBase;					// A pointer to the base address for the DLL in memory.
    ULONG SizeOfImage;				// The size of the DLL image, in bytes.
} LDR_DLL_NOTIFICATION_DATA, *PLDR_DLL_NOTIFICATION_DATA;

typedef VOID (CALLBACK *PLDR_DLL_NOTIFICATION_FUNCTION) (
    _In_		ULONG						NotificationReason,
    _In_		PLDR_DLL_NOTIFICATION_DATA	NotificationData,
    _In_opt_	PVOID						Context
);

typedef NTSTATUS (NTAPI *_LdrRegisterDllNotification) (
    _In_		ULONG							Flags,
    _In_		PLDR_DLL_NOTIFICATION_FUNCTION	NotificationFunction,
    _In_opt_	PVOID							Context,
    _Out_		PVOID							*Cookie
);

typedef NTSTATUS (NTAPI *_LdrUnregisterDllNotification) (
    _In_ PVOID Cookie
);

/* Пользовательские определения фильтров и каллбэков */

enum LDR_NOTIFICATION_REASON {
    LdrModuleLoaded = 1,
    LdrModuleUnloaded = 2
};

typedef VOID (CALLBACK *_DllNotificationRoutine) (
    LDR_NOTIFICATION_REASON Reason,
    IN PLDR_DLL_NOTIFICATION_DATA NotificationData,
    IN PCONTEXT Context
);

typedef NTSTATUS (CALLBACK *_PreLoadCallback) (
    OUT PBOOL			SkipOriginalCall,
    IN PWCHAR			PathToFile,
    IN PULONG			Flags,
    IN PUNICODE_STRING	ModuleFileName,
    OUT PHANDLE			ModuleHandle
);

typedef NTSTATUS (CALLBACK *_PostLoadCallback) (
    IN NTSTATUS			ReturnValue,
    IN PWCHAR			PathToFile,
    IN PULONG			Flags,
    IN PUNICODE_STRING	ModuleFileName,
    OUT PHANDLE			ModuleHandle
);

typedef NTSTATUS (CALLBACK *_PreUnloadCallback) (
    OUT PBOOL SkipOriginalCall,
    IN HANDLE ModuleHandle
);

typedef NTSTATUS (CALLBACK *_PostUnloadCallback) (
    IN NTSTATUS ReturnValue,
    IN HANDLE ModuleHandle
);

class ModulesFilter final {
private:
    // Состояние объекта:
    static BOOL Enabled;
    static BOOL Initialized;
    static HOOK_INFO HookInfo[2];
    static PVOID Cookie;

    static BOOL Initialize();

    // Оригинальные функции:
    static _LdrLoadDll LdrLoadDll, OrgnlLdrLoadDll;
    static _LdrUnloadDll LdrUnloadDll, OrgnlLdrUnloadDll;
    static _LdrRegisterDllNotification LdrRegisterDllNotification;
    static _LdrUnregisterDllNotification LdrUnregisterDllNotification;
    
    // Каллбэки:
    static _PreLoadCallback PreLoadCallback;
    static _PostLoadCallback PostLoadCallback;
    static _PreUnloadCallback PreUnloadCallback;
    static _PostUnloadCallback PostUnloadCallback;
    static _DllNotificationRoutine DllNotificationRoutine;

    // Функции-фильтры и нотификаторы:
    static NTSTATUS NTAPI HkdLdrLoadDll(
        IN PWCHAR			PathToFile,
        IN PULONG			Flags,
        IN PUNICODE_STRING	ModuleFileName,
        OUT PHANDLE			ModuleHandle
    );
    static NTSTATUS NTAPI HkdLdrUnloadDll(
        IN HANDLE ModuleHandle
    );
    static VOID CALLBACK LdrDllNotificationFunction(
        _In_		ULONG						NotificationReason,
        _In_		PLDR_DLL_NOTIFICATION_DATA	NotificationData,
        _In_opt_	PVOID						Context
    );
public:
    static BOOL EnableModulesFilter();
    static VOID DisableModulesFilter();
    static BOOL EnableDllNotification();
    static VOID DisableDllNotification();
    static VOID SetupFilterCallbacks(
        OPTIONAL _PreLoadCallback PreLoad = NULL,
        OPTIONAL _PostLoadCallback PostLoad = NULL,
        OPTIONAL _PreUnloadCallback PreUnload = NULL,
        OPTIONAL _PostUnloadCallback PostUnload = NULL
    );
    static VOID SetupNotificationCallbacks(
        OPTIONAL _DllNotificationRoutine Callback
    );
};
```

`Avanguard/AvanguardDefence/ModulesStorage.cpp`:

```cpp
#include "stdafx.h"
#include "ModulesStorage.h"

#include <functional>
#include <apiset.h>

ModulesStorage::ModulesStorage(BOOL CollectModulesInfo) {
    if (CollectModulesInfo) FillModulesInfo();
}

ModulesStorage::~ModulesStorage() {
    LoadedModules.clear();
}

void ModulesStorage::AnalyzeExecutableSections(const PEAnalyzer& pe, MODULE_INFO& ModuleInfo) {
    const SECTIONS_SET& Sections = pe.GetSectionsInfo();
    ModuleInfo.ExecutableSections.clear();
    for (const auto& Section : Sections) {
        DWORD SecType = Section.Characteristics;
        if (((SecType & IMAGE_SCN_CNT_CODE) == IMAGE_SCN_CNT_CODE) ||
            ((SecType & IMAGE_SCN_MEM_EXECUTE) == IMAGE_SCN_MEM_EXECUTE)) 
        {
            EXECUTABLE_SECTION_INFO SectionInfo;
            SectionInfo.BaseAddress = (PVOID)((SIZE_T)(pe.GetLocalBase()) + Section.OffsetInMemory);
            SectionInfo.Size = Section.SizeInMemory;
            ModuleInfo.ExecutableSections.push_back(SectionInfo);
        }
    }
    ModuleInfo.Checksum = CalculateChecksum(ModuleInfo.ExecutableSections);
}


std::wstring ModulesStorage::GetNormalizedName(const std::wstring& Path) {
    std::wstring Name = LowerCase(ExtractFileName(Path));
    if (EndsWith(Name, DllPostfix) || EndsWith(Name, ExePostfix)) return Name;
    return Name += DllPostfix;
}

void ModulesStorage::FillModulesInfo() {
    LoadedModules.clear();

    Lock();
    EnumerateModules([this](NTDEFINES::PLDR_MODULE Module) -> bool {
        std::wstring ModuleName = GetNormalizedName(std::wstring(Module->BaseDllName.Buffer));

        PEAnalyzer pe((HMODULE)Module->BaseAddress, FALSE);
        MODULE_INFO ModuleInfo;
        ModuleInfo.BaseAddress = Module->BaseAddress;
        ModuleInfo.Name = ModuleName;
        AnalyzeExecutableSections(pe, ModuleInfo);
        LoadedModules.emplace((HMODULE)Module->BaseAddress, ModuleInfo);
        
        return true;
    });
    Unlock();
}

UINT64 ModulesStorage::CalculateChecksum(const EXEC_SECTIONS_SET& Sections) {
    UINT64 Checksum = 0;
    for (const auto& Section : Sections) 
        Checksum ^= t1ha(Section.BaseAddress, Section.Size, 0x1EE7C0DEC0FFEE);
    return Checksum;
}

BOOL ModulesStorage::IsCodeSectionsValid(HMODULE hModule) {
    Lock();
    BOOL IsModuleValid = FALSE;
    auto& Module = LoadedModules.find(hModule);
    if (Module == LoadedModules.end()) goto Exit;
    UINT64 Checksum = CalculateChecksum(Module->second.ExecutableSections);
    IsModuleValid = Module->second.Checksum == Checksum;
Exit:
    Unlock();
    return IsModuleValid;
}

void ModulesStorage::RecalcModuleHash(HMODULE hModule) {
    Lock();
    auto& Module = LoadedModules.find(hModule);
    if (Module == LoadedModules.end()) goto Exit;
    Module->second.Checksum = CalculateChecksum(Module->second.ExecutableSections);
Exit:
    Unlock();
}

void ModulesStorage::RecalcModulesHashes() {
    Lock();
    for (auto& Entry : LoadedModules) {
        Entry.second.Checksum = CalculateChecksum(Entry.second.ExecutableSections);
    }
    Unlock();
}

void ModulesStorage::FindChangedModules(OnChangedModuleCallback Callback) {
    if (!Callback) return;
    Lock();
    for (const auto& Entry : LoadedModules) {
        if (Entry.second.Checksum != CalculateChecksum(Entry.second.ExecutableSections)) {
            if (!Callback(Entry.second)) goto Exit;
        }
    }
Exit:
    Unlock();
}

BOOL ModulesStorage::IsModuleInStorage(HMODULE hModule) {
    Lock();
    BOOL IsInStorage = LoadedModules.find(hModule) != LoadedModules.end();
    Unlock();
    return IsInStorage;
}

void ModulesStorage::AddModule(HMODULE hModule) {
    if (hModule == NULL) return;
    std::wstring Name = GetNormalizedName(GetModuleName(hModule));
    
    Lock();
    PEAnalyzer pe(hModule, FALSE);
    MODULE_INFO ModuleInfo;
    ModuleInfo.BaseAddress = (PVOID)hModule;
    ModuleInfo.Name = Name;
    AnalyzeExecutableSections(pe, ModuleInfo);
    LoadedModules.emplace(hModule, ModuleInfo);
    Unlock();
}

void ModulesStorage::RemoveModule(HMODULE hModule) {
    Lock();
    LoadedModules.erase(hModule);
    Unlock();
}

void ModulesStorage::Lock() {
    Locker.Lock();
}

void ModulesStorage::Unlock() {
    Locker.Unlock();
}
```

`Avanguard/AvanguardDefence/ModulesStorage.h`:

```h
#pragma once

#include "PebTeb.h"
#include "PEAnalyzer.h"
#include "ModulesUtils.h"
#include "Locks.h"

#include "..\\t1ha\\t1ha.h"
#include "..\\HoShiMin's API\\StringsAPI.h"

#include <functional>

typedef struct _EXECUTABLE_SECTION_INFO {
    PVOID BaseAddress;
    ULONG Size;
} EXECUTABLE_SECTION_INFO, *PEXECUTABLE_SECTION_INFO;

typedef std::vector<EXECUTABLE_SECTION_INFO> EXEC_SECTIONS_SET;

typedef struct _MODULE_INFO {
    PVOID BaseAddress;
    EXEC_SECTIONS_SET ExecutableSections;
    std::wstring Name;
    UINT64 Checksum;
} MODULE_INFO, *PMODULE_INFO;


typedef std::function<bool(const MODULE_INFO& ModuleInfo)> OnChangedModuleCallback;

class ModulesStorage {
private:
    CSLock Locker;

    const std::wstring DllPostfix = std::wstring(L".dll");
    const std::wstring ExePostfix = std::wstring(L".exe");

    std::unordered_map<HMODULE, MODULE_INFO> LoadedModules;

    UINT64 CalculateChecksum(const EXEC_SECTIONS_SET& Sections);
    std::wstring GetNormalizedName(const std::wstring& Path);
    void AnalyzeExecutableSections(const PEAnalyzer& pe, MODULE_INFO& ModuleInfo);
public:
    ModulesStorage(BOOL CollectModulesInfo);
    ~ModulesStorage();

    BOOL IsCodeSectionsValid(HMODULE hModule);
    void RecalcModuleHash(HMODULE hModule);
    void RecalcModulesHashes();
    void FindChangedModules(OnChangedModuleCallback Callback);

    void FillModulesInfo();

    BOOL IsModuleInStorage(HMODULE hModule);

    void AddModule(HMODULE hModule);
    void RemoveModule(HMODULE hModule);

    void Lock();
    void Unlock();
};
```

`Avanguard/AvanguardDefence/ModulesUtils.cpp`:

```cpp
#include "stdafx.h"
#include "ModulesUtils.h"

HMODULE GetModuleBase(PVOID Pointer) {
    HMODULE hModule = NULL;
    EnumerateModules([&](const NTDEFINES::PLDR_MODULE Module) -> bool {
        bool Status = 
            Pointer >= Module->BaseAddress && 
            Pointer < static_cast<PBYTE>(Module->BaseAddress) + Module->SizeOfImage;
        if (Status) hModule = static_cast<HMODULE>(Module->BaseAddress);
        return !Status;
    });

    return hModule;
/*
    BOOL Status = GetModuleHandleEx(
        GET_MODULE_HANDLE_EX_FLAG_FROM_ADDRESS | GET_MODULE_HANDLE_EX_FLAG_UNCHANGED_REFCOUNT,
        (LPCWSTR)Pointer,
        &hModule
    );
    return Status ? hModule : NULL;
*/
}

std::wstring GetModuleName(PVOID AddressOrBase) {
    std::wstring Result;
    EnumerateModules([&](const NTDEFINES::PLDR_MODULE Module) -> bool {
        bool Status = 
            AddressOrBase >= Module->BaseAddress && 
            AddressOrBase < static_cast<PBYTE>(Module->BaseAddress) + Module->SizeOfImage;
        PUNICODE_STRING String = &Module->BaseDllName;
        ULONG Length = String->Length / 2;
        if (Status && String->Buffer && Length) {
            Result.resize(Length);
            CopyMemory(const_cast<LPWSTR>(Result.c_str()), String->Buffer, Length * sizeof(WCHAR));
        }
        return !Status;
    });
    return Result;
}

std::wstring GetModulePath(PVOID AddressOrBase) {
    std::wstring Result;
    EnumerateModules([&](const NTDEFINES::PLDR_MODULE Module) -> bool {
        bool Status = 
            AddressOrBase >= Module->BaseAddress && 
            AddressOrBase < static_cast<PBYTE>(Module->BaseAddress) + Module->SizeOfImage;
        PUNICODE_STRING String = &Module->FullDllName;
        ULONG Length = String->Length / 2;
        if (Status && String->Buffer && Length) {
            Result.resize(Length);
            wcscpy_s(const_cast<LPWSTR>(Result.c_str()), Length, String->Buffer);
        }
        return !Status;
    });
    return Result;
}

void EnumerateModules(EnumerateModulesCallback Callback) {
    if (Callback == NULL) return;

    NTDEFINES::PPEB Peb = GetPEB();
    NTDEFINES::PPEB_LDR_DATA LdrData = (NTDEFINES::PPEB_LDR_DATA)Peb->Ldr;

    NTDEFINES::PLDR_MODULE ListEntry = (NTDEFINES::PLDR_MODULE)LdrData->InLoadOrderModuleList.Flink;
    while (ListEntry && ListEntry->BaseAddress) {
        if (!Callback(ListEntry)) break;
        ListEntry = (NTDEFINES::PLDR_MODULE)ListEntry->InLoadOrderModuleList.Flink;
    }
}
```

`Avanguard/AvanguardDefence/ModulesUtils.h`:

```h
#pragma once

#include <Windows.h>
#include <string>
#include <functional>

#include "PebTeb.h"

HMODULE GetModuleBase(PVOID Pointer);
std::wstring GetModuleName(PVOID AddressOrBase);
std::wstring GetModulePath(PVOID AddressOrBase);

typedef std::function<bool(NTDEFINES::PLDR_MODULE Module)> EnumerateModulesCallback;
void EnumerateModules(EnumerateModulesCallback Callback);
```

`Avanguard/AvanguardDefence/PEAnalyzer.cpp`:

```cpp
#include "stdafx.h"
#include "PEAnalyzer.h"

#define RELOCS_OFFSET_MASK 0b0000111111111111 /* Младшие 12 бит */ 

#define FORCED_FILE_ALIGNMENT		0x200
#define MINIMAL_SECTION_ALIGNMENT	0x1000

size_t inline AlignDown(size_t Value, size_t Factor) {
    return Value & ~(Factor - 1);
}

size_t inline AlignUp(size_t Value, size_t Factor) {
    return AlignDown(Value - 1, Factor) + Factor;
}

SIZE_T PEAnalyzer::Rva2Offset(SIZE_T Rva) const {
    if (!IsRawModule) return Rva;
/*
    Offset = SectionRAW + (RVA - SectionRVA)
    1. Находим, какой секции принадлежит RVA
    2. Вычисляем смещение от начала секции
    3. Прибавляем смещение к физическому адресу секции в файле
*/
    for (const auto& Section : Sections) {
        SIZE_T SectionBase, SectionSize, SectionOffset;
        if (NeedToAlign) {
            SectionBase = AlignDown((SIZE_T)Section.OffsetInMemory, SectionAlignment);
            SIZE_T AlignedFileSize, AlignedSectionSize;
            AlignedFileSize		= AlignUp(Section.SizeOnDisk, FileAlignment);
            AlignedSectionSize	= AlignUp(Section.SizeInMemory, SectionAlignment);
            SectionSize			= AlignedFileSize > AlignedSectionSize ? AlignedSectionSize : AlignedFileSize;
            SectionOffset		= AlignDown(Section.OffsetInFile, FORCED_FILE_ALIGNMENT);
        } else {
            SectionBase = (SIZE_T)Section.OffsetInMemory;
            SectionSize = Section.SizeOnDisk > Section.SizeInMemory ? Section.SizeInMemory : Section.SizeOnDisk;
            SectionOffset = Section.OffsetInFile;
        }

        if ((Rva >= SectionBase) && (Rva < SectionBase + SectionSize)) {
            return (SectionOffset + (Rva - SectionBase));
        }
    }

    return 0;
}

void PEAnalyzer::FillSectionsInfo() {
    // Собираем инфу о секциях:
    Sections.clear();
    WORD NumberOfSections = NtHeaders->FileHeader.NumberOfSections;
    PIMAGE_SECTION_HEADER SectionHeader = IMAGE_FIRST_SECTION(NtHeaders);
    for (unsigned short i = 0; i < NumberOfSections; i++, SectionHeader++) {
        SECTION_INFO SectionInfo;
        SectionInfo.OffsetInMemory = SectionHeader->VirtualAddress;
        SectionInfo.OffsetInFile = SectionHeader->PointerToRawData;
        SectionInfo.SizeInMemory = SectionHeader->Misc.VirtualSize;
        SectionInfo.SizeOnDisk = SectionHeader->SizeOfRawData;
        SectionInfo.Characteristics = SectionHeader->Characteristics;
        SectionInfo.NumberOfRelocs = SectionHeader->NumberOfRelocations;
        memcpy(&SectionInfo.Name, &SectionHeader->Name, SEC_NAME_SIZE);
        SectionInfo.Name[SEC_NAME_SIZE] = NULL;
        Sections.push_back(SectionInfo);
    }
}

void PEAnalyzer::FillRelocsInfo() {
    // Собираем инфу о релоках:
    Relocs.clear();
    PIMAGE_DATA_DIRECTORY RelocsDir =
        (PIMAGE_DATA_DIRECTORY)&OptionalHeader->DataDirectory[IMAGE_DIRECTORY_ENTRY_BASERELOC];

    if (RelocsDir->Size == 0) return;

    PIMAGE_BASE_RELOCATION Relocs = (PIMAGE_BASE_RELOCATION)((PBYTE)LocalBase + Rva2Offset(RelocsDir->VirtualAddress));
    PIMAGE_BASE_RELOCATION RelocsFinalAddress = (PIMAGE_BASE_RELOCATION)((PBYTE)Relocs + RelocsDir->Size);
    while (Relocs < RelocsFinalAddress) {
        DWORD RelocsRva = Relocs->VirtualAddress;

        DWORD RelocsCount = (Relocs->SizeOfBlock - sizeof(IMAGE_BASE_RELOCATION)) / sizeof(WORD);
        PWORD RelocEntry = (PWORD)((PBYTE)Relocs + sizeof(IMAGE_BASE_RELOCATION));
        for (unsigned int i = 0; i < RelocsCount; i++, RelocEntry++) {
            WORD Reloc = *RelocEntry;
            RELOC_INFO RelocInfo;
            RelocInfo.Rva = RelocsRva + (Reloc & RELOCS_OFFSET_MASK);
            RelocInfo.Type = (BYTE)(Reloc >> 12);
            this->Relocs.push_back(RelocInfo);
        }

        Relocs = (PIMAGE_BASE_RELOCATION)((PBYTE)Relocs + Relocs->SizeOfBlock);
    }
}

void PEAnalyzer::FillImportsSet(
    PIMAGE_THUNK_DATA Thunk, 
    PIMAGE_THUNK_DATA OriginalThunk, 
    OUT IMPORTS_SET& ImportsSet
) {
    ImportsSet.clear();
    while (Thunk->u1.AddressOfData) {
        PIMAGE_IMPORT_BY_NAME NamedImport = (PIMAGE_IMPORT_BY_NAME)((PBYTE)LocalBase + Rva2Offset(OriginalThunk->u1.AddressOfData));

        static const SIZE_T OrdinalPresentMask = (SIZE_T)0x80 << (SIZE_T)((sizeof(SIZE_T) - 1) * 8);
        static const SIZE_T OrdinalMask = OrdinalPresentMask - 1;

        IMPORT_INFO ImportInfo;
        ImportInfo.FT = (PVOID)Thunk->u1.Function;
        ImportInfo.OFT = (PVOID)OriginalThunk->u1.Function;
        ImportInfo.IsOrdinalImport = ((SIZE_T)ImportInfo.OFT & OrdinalPresentMask) == OrdinalPresentMask;
        if (ImportInfo.IsOrdinalImport) {
            ImportInfo.Ordinal = (SIZE_T)ImportInfo.OFT & OrdinalMask;
            ImportInfo.Hint = 0;
        }
        else {
            ImportInfo.Ordinal = 0;
            ImportInfo.Hint = NamedImport->Hint;
            ImportInfo.Name = NamedImport->Name;
        }
        ImportsSet.push_back(ImportInfo);

        Thunk++;
        OriginalThunk++;
    }
}

void PEAnalyzer::FillImportsInfo() {
    // Парсим таблицу импорта:
    Imports.clear();
    PIMAGE_DATA_DIRECTORY ImportDir =
        (PIMAGE_DATA_DIRECTORY)&OptionalHeader->DataDirectory[IMAGE_DIRECTORY_ENTRY_IMPORT];

    if (ImportDir->Size == 0) return;

    PIMAGE_IMPORT_DESCRIPTOR Imports = (PIMAGE_IMPORT_DESCRIPTOR)((PBYTE)LocalBase + Rva2Offset(ImportDir->VirtualAddress));
    while (Imports->FirstThunk != 0) {
        LPCSTR LibraryName = (LPCSTR)((PBYTE)LocalBase + Rva2Offset(Imports->Name));

        IMPORTS_SET ImportsSet;

        PIMAGE_THUNK_DATA Thunk = (PIMAGE_THUNK_DATA)((PBYTE)LocalBase + Rva2Offset(Imports->FirstThunk));
        PIMAGE_THUNK_DATA OriginalThunk = (PIMAGE_THUNK_DATA)((PBYTE)LocalBase + Rva2Offset(Imports->OriginalFirstThunk));
        FillImportsSet(Thunk, OriginalThunk, ImportsSet);

        this->Imports.emplace(LibraryName, ImportsSet);
        Imports++;
    }
}

void PEAnalyzer::FillDelayedImportsInfo() {
    // Парсим таблицу отложенного импорта:
    DelayedImports.clear();
    PIMAGE_DATA_DIRECTORY DelayedImportDir =
        (PIMAGE_DATA_DIRECTORY)&OptionalHeader->DataDirectory[IMAGE_DIRECTORY_ENTRY_DELAY_IMPORT];

    if (DelayedImportDir->Size == 0) return;

    PIMAGE_DELAYLOAD_DESCRIPTOR DelayedImports =
        (PIMAGE_DELAYLOAD_DESCRIPTOR)((PBYTE)LocalBase + Rva2Offset(DelayedImportDir->VirtualAddress));
    while (DelayedImports->DllNameRVA != 0) {
        LPCSTR LibraryName = (LPCSTR)((PBYTE)LocalBase + Rva2Offset(DelayedImports->DllNameRVA));

        DELAYED_IMPORT_INFO DelayedImportInfo;
        DelayedImportInfo.Attributes = DelayedImports->Attributes.AllAttributes;
        DelayedImportInfo.hModule = *(HMODULE*)((PBYTE)LocalBase + Rva2Offset(DelayedImports->ModuleHandleRVA));
        DelayedImportInfo.DllName = LibraryName;

        PIMAGE_THUNK_DATA Thunk = (PIMAGE_THUNK_DATA)((PBYTE)LocalBase + Rva2Offset(DelayedImports->ImportAddressTableRVA));
        PIMAGE_THUNK_DATA OriginalThunk = (PIMAGE_THUNK_DATA)((PBYTE)LocalBase + Rva2Offset(DelayedImports->ImportNameTableRVA));
        FillImportsSet(Thunk, OriginalThunk, DelayedImportInfo.Imports);

        this->DelayedImports.push_back(DelayedImportInfo);
        DelayedImports++;
    }
}

void PEAnalyzer::FillExportsInfo() {
    // Парсим экспорты:
    Exports.TimeStamp = 0;
    Exports.NumberOfNames = 0;

    Exports.Name.clear();
    Exports.Exports.clear();
    PIMAGE_DATA_DIRECTORY ExportDir =
        (PIMAGE_DATA_DIRECTORY)&OptionalHeader->DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT];

    if (ExportDir->Size == 0) return;
    
    PIMAGE_EXPORT_DIRECTORY Exports = (PIMAGE_EXPORT_DIRECTORY)((PBYTE)LocalBase + Rva2Offset(ExportDir->VirtualAddress));

    this->Exports.TimeStamp = Exports->TimeDateStamp;
    this->Exports.NumberOfNames = Exports->NumberOfNames;
    this->Exports.NumberOfFunctions = Exports->NumberOfFunctions;
    this->Exports.Name = (LPCSTR)((PBYTE)LocalBase + Rva2Offset(Exports->Name));

    PWORD OrdinalsArray = (PWORD)((PBYTE)LocalBase + Rva2Offset(Exports->AddressOfNameOrdinals));

    PDWORD NamesArray = (PDWORD)((PBYTE)LocalBase + Rva2Offset(Exports->AddressOfNames));
    PDWORD FunctionsArray = (PDWORD)((PBYTE)LocalBase + Rva2Offset(Exports->AddressOfFunctions));

    DWORD OrdinalBase = Exports->Base;

    std::unordered_map<WORD, unsigned int> OrdinalsMap; // Ordinal -> Ordinal index
    OrdinalsMap.reserve(Exports->NumberOfNames);
    for (unsigned int NameNumber = 0; NameNumber < Exports->NumberOfNames; NameNumber++) {
        OrdinalsMap.emplace(*(OrdinalsArray + NameNumber), NameNumber);
    }

    for (unsigned int FunctionNumber = 0; FunctionNumber < Exports->NumberOfFunctions; FunctionNumber++) {
        DWORD FunctionAddress = *(FunctionsArray + FunctionNumber);

        EXPORT_INFO ExportInfo;
        ExportInfo.VA = (PBYTE)LocalBase + FunctionAddress;
        ExportInfo.RVA = FunctionAddress;
        ExportInfo.Ordinal = Exports->Base + FunctionNumber;

        auto OrdinalEntry = OrdinalsMap.find(FunctionNumber);
        ExportInfo.OrdinalExport = OrdinalEntry == OrdinalsMap.end();
        if (!ExportInfo.OrdinalExport) {
            unsigned int NameNumber = OrdinalEntry->second;
            LPCSTR FunctionName = (LPCSTR)((PBYTE)LocalBase + Rva2Offset(*(NamesArray + NameNumber)));
            ExportInfo.Name = FunctionName;
        }

        this->Exports.Exports.push_back(ExportInfo);
    }
}

PEAnalyzer::PEAnalyzer() {
    Clear();
}

PEAnalyzer::PEAnalyzer(HMODULE hModule, BOOL RawModule) {
    LoadModule(hModule, RawModule);
}

PEAnalyzer::~PEAnalyzer() {
    Clear();
}

BOOL PEAnalyzer::LoadModule(HMODULE hModule, BOOL RawModule) {
    Clear();

    if (hModule == NULL) return FALSE;

    IsRawModule = RawModule;

    DosHeader = (PIMAGE_DOS_HEADER)hModule;
    NtHeaders = (PIMAGE_NT_HEADERS)((PBYTE)hModule + DosHeader->e_lfanew);

    if (!ValidatePESignatures()) {
        Clear();
        return FALSE;
    }

    OptionalHeader = &NtHeaders->OptionalHeader;

#ifdef _WIN64
    if (OptionalHeader->Magic != PE64_SIGNATURE)
        throw std::exception("PE image must be 64-bit!");
#elif _WIN32
    if (OptionalHeader->Magic != PE32_SIGNATURE)
        throw std::exception("PE image must be 32-bit!");
#endif

    LocalBase = !RawModule ? hModule : (PVOID)OptionalHeader->ImageBase;

    ImageBase = (PVOID)OptionalHeader->ImageBase;
    EntryPoint = (PBYTE)ImageBase + OptionalHeader->AddressOfEntryPoint;

    FileAlignment = OptionalHeader->FileAlignment;
    SectionAlignment = OptionalHeader->SectionAlignment;
    NeedToAlign = SectionAlignment >= MINIMAL_SECTION_ALIGNMENT;

    FillSectionsInfo();
    FillRelocsInfo();
    FillImportsInfo();
    FillDelayedImportsInfo();
    FillExportsInfo();

    return TRUE;
}

void PEAnalyzer::Clear() {
    IsRawModule = FALSE;
    IsValidPESignatures = FALSE;
    DosHeader = NULL;
    NtHeaders = NULL;
    OptionalHeader = NULL;
    LocalBase = NULL;
    ImageBase = NULL;
    EntryPoint = NULL;
    NeedToAlign = FALSE;
    FileAlignment = 0;
    SectionAlignment = 0;
    Sections.clear();
    Relocs.clear();
    Imports.clear();
    DelayedImports.clear();
    Exports.TimeStamp = 0;
    Exports.NumberOfNames = 0;
    Exports.NumberOfFunctions = 0;
    Exports.Name.clear();
    Exports.Exports.clear();
}

BOOL PEAnalyzer::ValidatePESignatures() {
    return IsValidPESignatures = (DosHeader->e_magic == MZ_SIGNATURE) && (NtHeaders->Signature == PE_SIGNATURE);
}
```

`Avanguard/AvanguardDefence/PEAnalyzer.h`:

```h
#pragma once

#include <vector>
#include <unordered_map>
#include <Windows.h>

/*
    RAW или Offset - смещение от начала файла
    RVA - смещение в загруженном модуле в памяти
    VA = ImageBase + RVA - реальный адрес чего-либо в памяти модуля
    RVA -> Offset: SectionRAW + (RVA - SectionRVA)
                                            ^- Хранится в заголовке секции
*/

#define MZ_SIGNATURE 0x5A4D // MZ
#define PE_SIGNATURE 0x4550 // PE

#define PE32_SIGNATURE 0x010B
#define PE64_SIGNATURE 0x020B

#define SEC_NAME_SIZE 8

typedef struct _SECTION_INFO {
    DWORD OffsetInMemory;
    DWORD OffsetInFile;
    DWORD SizeInMemory;
    DWORD SizeOnDisk;
    DWORD Characteristics;
    WORD NumberOfRelocs;
    CHAR Name[SEC_NAME_SIZE + 1];
} SECTION_INFO, *PSECTION_INFO;

typedef std::vector<SECTION_INFO> SECTIONS_SET;

typedef struct _RELOC_INFO {
    DWORD Rva; // Page RVA + Offset
    BYTE Type;
} RELOC_INFO, *PRELOC_INFO;

typedef std::vector<RELOC_INFO> RELOCS_SET;

typedef struct _IMPORT_INFO {
    PVOID OFT; // OFT = OriginalFirstThunk
    PVOID FT; // FT = FirstThunk, адрес в IAT (реальный адрес в памяти)
    BOOL IsOrdinalImport;
    SIZE_T Ordinal;
    WORD Hint;
    std::string Name;
} IMPORT_INFO, *PIMPORT_INFO;

typedef std::vector<IMPORT_INFO> IMPORTS_SET;
typedef std::unordered_map<std::string, IMPORTS_SET> IMPORTS_MAP; // LibName -> Imports

typedef struct _DELAYED_IMPORT_INFO {
    DWORD Attributes;
    HMODULE hModule;
    std::string DllName;
    IMPORTS_SET Imports;
} DELAYED_IMPORT_INFO, *PDELAYED_IMPORT_INFO;

typedef std::vector<DELAYED_IMPORT_INFO> DELAYED_IMPORTS_SET;

typedef struct _EXPORT_INFO {
    PVOID VA;
    DWORD RVA;
    DWORD Ordinal;
    BOOL OrdinalExport;
    std::string Name;
} EXPORT_INFO, *PEXPORT_INFO;

typedef std::vector<EXPORT_INFO> EXPORTS_SET;

typedef struct _EXPORTS_INFO {
    DWORD TimeStamp;
    DWORD NumberOfNames;
    DWORD NumberOfFunctions;
    std::string Name;
    EXPORTS_SET Exports;
} EXPORTS_INFO, *PEXPORTS_INFO;

class PEAnalyzer {
private:
    BOOL IsRawModule;
    BOOL IsValidPESignatures;

    PIMAGE_DOS_HEADER DosHeader;
    PIMAGE_NT_HEADERS NtHeaders;
    PIMAGE_OPTIONAL_HEADER OptionalHeader;

    PVOID LocalBase;

    PVOID ImageBase;
    PVOID EntryPoint;

    BOOL NeedToAlign;
    DWORD FileAlignment;
    DWORD SectionAlignment;

    SECTIONS_SET Sections;
    RELOCS_SET Relocs;
    IMPORTS_MAP Imports;
    DELAYED_IMPORTS_SET DelayedImports;
    EXPORTS_INFO Exports;

    BOOL ValidatePESignatures();

    void FillSectionsInfo();
    void FillRelocsInfo();
    void FillImportsInfo();
    void FillDelayedImportsInfo();
    void FillExportsInfo();

    void FillImportsSet(PIMAGE_THUNK_DATA Thunk, PIMAGE_THUNK_DATA OriginalThunk, OUT IMPORTS_SET& ImportsSet);
public:
    PEAnalyzer();
    PEAnalyzer(HMODULE hModule, BOOL RawModule);
    ~PEAnalyzer();

    BOOL LoadModule(HMODULE hModule, BOOL RawModule);

    void Clear();

    const SECTIONS_SET& GetSectionsInfo() const { return Sections; }
    const RELOCS_SET& GetRelocsInfo() const { return Relocs; }
    const IMPORTS_MAP& GetImportsInfo() const { return Imports; }
    const DELAYED_IMPORTS_SET& GetDelayedImports() const { return DelayedImports; }
    const EXPORTS_INFO& GetExportsInfo() const { return Exports; }

    PVOID GetImageBase() const { return ImageBase; }
    PVOID GetLocalBase() const { return LocalBase; }
    PVOID GetEntryPoint() const { return EntryPoint; }

    PIMAGE_DOS_HEADER GetDosHeader() const { return DosHeader; }
    PIMAGE_NT_HEADERS GetNtHeaders() const { return NtHeaders; }
    PIMAGE_OPTIONAL_HEADER GetOptionalHeader() const { return OptionalHeader; }

    BOOL IsValidPE() const { return IsValidPESignatures; };

    SIZE_T Rva2Offset(SIZE_T Rva) const;
};
```

`Avanguard/AvanguardDefence/PEUtils.cpp`:

```cpp
#include "stdafx.h"
#include "PEUtils.h"

// Информация о модуле,
// заполняется в CryptInitializeModuleInfo:
MODULE_INFO ModuleInfo = {
    NULL, NULL, { 0 }, 0xFFFFFFFF
};

// Получаем разницу между ImageBase и фактическим адресом загрузки:
ULONGLONG FASTCALL GetImageLoadDelta(HMODULE hModule) {
#define FILE_NAME_LEN 1024
    WCHAR FileName[FILE_NAME_LEN];
    DWORD FileNameSize = GetModuleFileName(hModule, FileName, FILE_NAME_LEN);

    HANDLE hFile = CreateFile(FileName, FILE_READ_ACCESS, FILE_SHARE_READ, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
    DWORD FileSize = GetFileSize(hFile, NULL);
    PVOID Buffer = new BYTE[FileSize];
    ReadFile(hFile, Buffer, FileSize, &FileSize, NULL);
    CloseHandle(hFile);

    PIMAGE_DOS_HEADER DosHeader = (PIMAGE_DOS_HEADER)Buffer;
    if (DosHeader->e_magic != MZ_SIGNATURE) return 0;
    PIMAGE_NT_HEADERS NtHeaders = (PIMAGE_NT_HEADERS)((PBYTE)Buffer + DosHeader->e_lfanew);
    if (NtHeaders->Signature != PE_SIGNATURE) return 0;

    PIMAGE_OPTIONAL_HEADER OptionalHeader = &NtHeaders->OptionalHeader;
    ULONGLONG ImageBase = OptionalHeader->ImageBase;

    delete[] Buffer;
    return (ULONGLONG)(hModule - ImageBase);
}

BOOL FASTCALL QueryModuleInfo(IN OUT PMODULE_INFO ModuleInfo) {
    HMODULE hModule = ModuleInfo->hModule;

    PIMAGE_DOS_HEADER DosHeader = (PIMAGE_DOS_HEADER)hModule;
    if (DosHeader->e_magic != MZ_SIGNATURE) return FALSE;
    PIMAGE_NT_HEADERS NtHeaders = (PIMAGE_NT_HEADERS)((PBYTE)hModule + DosHeader->e_lfanew);
    if (NtHeaders->Signature != PE_SIGNATURE) return FALSE;

    PIMAGE_OPTIONAL_HEADER OptionalHeader = &NtHeaders->OptionalHeader;
    ModuleInfo->EntryPoint = (PBYTE)hModule + OptionalHeader->AddressOfEntryPoint;

#ifdef CODEPAGES_ARE_WRITEABLE
    // Ставим секциям права на запись:
    ULONG NumberOfSections = NtHeaders->FileHeader.NumberOfSections;
    PIMAGE_SECTION_HEADER SectionHeader = IMAGE_FIRST_SECTION(NtHeaders);
    for (unsigned int i = 0; i < NumberOfSections; i++, SectionHeader++) {
        PVOID SectionAddress = (PBYTE)hModule + SectionHeader->VirtualAddress;
        ULONG SectionSize = SectionHeader->Misc.VirtualSize;
        MEMORY_BASIC_INFORMATION MemoryInfo;
        ZeroMemory(&MemoryInfo, sizeof(MemoryInfo));
        if (VirtualQuery(SectionAddress, &MemoryInfo, sizeof(MemoryInfo))) {
            DWORD Protect = MemoryInfo.Protect;
            if ((Protect == PAGE_EXECUTE) || (Protect == PAGE_EXECUTE_READ)) {
                VirtualProtect(SectionAddress, SectionSize, PAGE_EXECUTE_READWRITE, &Protect);
            }
        }
    }
#endif

    PIMAGE_DATA_DIRECTORY RelocsDir = (PIMAGE_DATA_DIRECTORY)&OptionalHeader->DataDirectory[IMAGE_DIRECTORY_ENTRY_BASERELOC];
    DWORD RelocsDirSize = RelocsDir->Size;

    PIMAGE_BASE_RELOCATION Relocs = (PIMAGE_BASE_RELOCATION)((PBYTE)hModule + RelocsDir->VirtualAddress);
    PIMAGE_BASE_RELOCATION FinalAddress = (PIMAGE_BASE_RELOCATION)((PBYTE)Relocs + RelocsDirSize);

    ModuleInfo->RelocsTableInfo.Size = RelocsDirSize;
    ModuleInfo->RelocsTableInfo.Relocs = Relocs;
    ModuleInfo->RelocsTableInfo.FinalAddress = FinalAddress;
    
    return TRUE;
}

// Инициализируем информацию о модуле:
VOID CryptInitializeModuleInfo(HMODULE hCurrentModule) {
    HMODULE hModule = hCurrentModule == NULL ? GetModuleHandle(NULL) : hCurrentModule;
    ModuleInfo.hModule = hModule;
    ModuleInfo.Delta = GetImageLoadDelta(ModuleInfo.hModule);
    QueryModuleInfo(&ModuleInfo);
}

#define PAGE_SIZE 4096
#define RELOCS_OFFSET_MASK 0b0000111111111111 /* Младшие 12 бит */ 

// Получаем список релоков для блока кода:
VOID FASTCALL FillRelocsSet(PCODE_BLOCK_INFO CodeBlockInfo, RELOCS_SET &RelocsSet) {
    RelocsSet.clear();
    
    PVOID Address	= CodeBlockInfo->Address;
    SIZE_T CodeSize	= CodeBlockInfo->Size;
    PVOID FinalCodeAddress = (PVOID)((PBYTE)Address + CodeSize);

    HMODULE hModule = ModuleInfo.hModule;

    PIMAGE_BASE_RELOCATION Relocs = ModuleInfo.RelocsTableInfo.Relocs;
    PIMAGE_BASE_RELOCATION FinalAddress = ModuleInfo.RelocsTableInfo.FinalAddress;

    // Идём по таблице релоков:
    while (Relocs < FinalAddress) {
        PDWORD RelocsBaseAddress = (PDWORD)((PBYTE)hModule + Relocs->VirtualAddress);
        if (RelocsBaseAddress >= FinalCodeAddress) break; // Если адрес релоков выше нашего блока - можем выходить

        DWORD RelocsCount = (Relocs->SizeOfBlock - sizeof(IMAGE_BASE_RELOCATION)) / sizeof(WORD);

        // Попал ли наш адрес в страницу блока релоков:
        PBYTE RelocsFinalAddress = (PBYTE)RelocsBaseAddress + PAGE_SIZE;
        if (Address >= RelocsBaseAddress && Address < RelocsFinalAddress) {
            RelocsSet.reserve(RelocsCount - (RelocsSet.capacity() - RelocsSet.size()));
            PWORD RelocEntry = (PWORD)((PBYTE)Relocs + sizeof(IMAGE_BASE_RELOCATION));
            
            for (unsigned int i = 0; i < RelocsCount; i++, RelocEntry++) {
                PDWORD AddressToFix = (PDWORD)((PBYTE)RelocsBaseAddress + ((*RelocEntry) & RELOCS_OFFSET_MASK));

                // Если релок попадает в наш блок кода:
                if (AddressToFix >= Address && AddressToFix < FinalCodeAddress)
                    RelocsSet.push_back(AddressToFix);
            }
        }

        // На следующий блок релоков:
        Relocs = (PIMAGE_BASE_RELOCATION)((PBYTE)Relocs + Relocs->SizeOfBlock);
    }
}

#undef RELOCS_OFFSET_MASK
#undef PAGE_SIZE
```

`Avanguard/AvanguardDefence/PEUtils.h`:

```h
#pragma once

#include <Windows.h>
#include <winnt.h>
#include <vector>

#define CODEPAGES_ARE_WRITEABLE

#define MZ_SIGNATURE 0x5A4D // MZ
#define PE_SIGNATURE 0x4550 // PE

#define FASTCALL __fastcall

typedef struct _RELOCS_TABLE_INFO {
    PIMAGE_BASE_RELOCATION Relocs;
    PIMAGE_BASE_RELOCATION FinalAddress;
    DWORD Size;
} RELOCS_TABLE_INFO, *PRELOCS_TABLE_INFO;

typedef struct MODULE_INFO {
    HMODULE hModule; // Адрес загрузки текущего модуля
    PVOID EntryPoint; // Точка входа
    RELOCS_TABLE_INFO RelocsTableInfo; // Инфа о таблице релоков
    ULONGLONG Delta; // Разница между ImageBase и фактическим адресом загрузки
} MODULE_INFO, *PMODULE_INFO;

// Информация о модуле,
// заполняется в CryptInitializeModuleInfo:
extern MODULE_INFO ModuleInfo;

// Информация о шифруемом блоке кода:
typedef struct _CODE_BLOCK_INFO {
    PVOID	Address;
    SIZE_T	Size;
} CODE_BLOCK_INFO, *PCODE_BLOCK_INFO;

// Набор релоков для блока кода (НЕ для модуля):
typedef std::vector<PDWORD> RELOCS_SET;

VOID CryptInitializeModuleInfo(HMODULE hCurrentModule = NULL);
VOID FASTCALL FillRelocsSet(PCODE_BLOCK_INFO CodeBlockInfo, RELOCS_SET &RelocsSet);
```

`Avanguard/AvanguardDefence/PebTeb.h`:

```h
#pragma once

#include <Windows.h>
#include <winternl.h>

namespace NTDEFINES {
// For the old SDK support:
#if (_WIN32_WINNT <= 0x0603)
    typedef struct _CLIENT_ID {
        HANDLE UniqueProcess;
        HANDLE UniqueThread;
    } CLIENT_ID;
#endif

    typedef struct _PEB_LDR_DATA {
        ULONG                   Length;
        BOOLEAN                 Initialized;
        PVOID                   SsHandle;
        LIST_ENTRY              InLoadOrderModuleList;
        LIST_ENTRY              InMemoryOrderModuleList;
        LIST_ENTRY              InInitializationOrderModuleList;
    } PEB_LDR_DATA, *PPEB_LDR_DATA;

    typedef struct _LDR_MODULE {
        LIST_ENTRY              InLoadOrderModuleList;
        LIST_ENTRY              InMemoryOrderModuleList;
        LIST_ENTRY              InInitializationOrderModuleList;
        PVOID                   BaseAddress;
        PVOID                   EntryPoint;
        ULONG                   SizeOfImage;
        UNICODE_STRING          FullDllName;
        UNICODE_STRING          BaseDllName;
        ULONG                   Flags;
        SHORT                   LoadCount;
        SHORT                   TlsIndex;
        LIST_ENTRY              HashTableEntry;
        ULONG                   TimeDateStamp;
    } LDR_MODULE, *PLDR_MODULE;

    typedef struct _RTL_USER_PROCESS_PARAMETERS *PRTL_USER_PROCESS_PARAMETERS;
    typedef struct _RTL_CRITICAL_SECTION *PRTL_CRITICAL_SECTION;
    
    #define GDI_HANDLE_BUFFER_SIZE32 34
    #define GDI_HANDLE_BUFFER_SIZE64 60

    #ifdef _WIN64
        #define GDI_HANDLE_BUFFER_SIZE GDI_HANDLE_BUFFER_SIZE64
    #else
        #define GDI_HANDLE_BUFFER_SIZE GDI_HANDLE_BUFFER_SIZE32
    #endif

    typedef ULONG GDI_HANDLE_BUFFER[GDI_HANDLE_BUFFER_SIZE];
    typedef ULONG GDI_HANDLE_BUFFER32[GDI_HANDLE_BUFFER_SIZE32];
    typedef ULONG GDI_HANDLE_BUFFER64[GDI_HANDLE_BUFFER_SIZE64];

    // symbols
    typedef struct _PEB {
        BOOLEAN InheritedAddressSpace;
        BOOLEAN ReadImageFileExecOptions;
        BOOLEAN BeingDebugged;
        union {
            BOOLEAN BitField;
            struct {
                BOOLEAN ImageUsesLargePages : 1;
                BOOLEAN IsProtectedProcess : 1;
                BOOLEAN IsImageDynamicallyRelocated : 1;
                BOOLEAN SkipPatchingUser32Forwarders : 1;
                BOOLEAN IsPackagedProcess : 1;
                BOOLEAN IsAppContainer : 1;
                BOOLEAN IsProtectedProcessLight : 1;
                BOOLEAN SpareBits : 1;
            };
        };
        HANDLE Mutant;
        PVOID ImageBaseAddress;
        PPEB_LDR_DATA Ldr;
        PRTL_USER_PROCESS_PARAMETERS ProcessParameters;
        PVOID SubSystemData;
        PVOID ProcessHeap;
        PRTL_CRITICAL_SECTION FastPebLock;
        PVOID AtlThunkSListPtr;
        PVOID IFEOKey;
        union {
            ULONG CrossProcessFlags;
            struct {
                ULONG ProcessInJob : 1;
                ULONG ProcessInitializing : 1;
                ULONG ProcessUsingVEH : 1;
                ULONG ProcessUsingVCH : 1;
                ULONG ProcessUsingFTH : 1;
                ULONG ReservedBits0 : 27;
            };
            ULONG EnvironmentUpdateCount;
        };
        union {
            PVOID KernelCallbackTable;
            PVOID UserSharedInfoPtr;
        };
        ULONG SystemReserved[1];
        ULONG AtlThunkSListPtr32;
        PVOID ApiSetMap;
        ULONG TlsExpansionCounter;
        PVOID TlsBitmap;
        ULONG TlsBitmapBits[2];
        PVOID ReadOnlySharedMemoryBase;
        PVOID HotpatchInformation;
        PVOID *ReadOnlyStaticServerData;
        PVOID AnsiCodePageData;
        PVOID OemCodePageData;
        PVOID UnicodeCaseTableData;

        ULONG NumberOfProcessors;
        ULONG NtGlobalFlag;

        LARGE_INTEGER CriticalSectionTimeout;
        SIZE_T HeapSegmentReserve;
        SIZE_T HeapSegmentCommit;
        SIZE_T HeapDeCommitTotalFreeThreshold;
        SIZE_T HeapDeCommitFreeBlockThreshold;

        ULONG NumberOfHeaps;
        ULONG MaximumNumberOfHeaps;
        PVOID *ProcessHeaps;

        PVOID GdiSharedHandleTable;
        PVOID ProcessStarterHelper;
        ULONG GdiDCAttributeList;

        PRTL_CRITICAL_SECTION LoaderLock;

        ULONG OSMajorVersion;
        ULONG OSMinorVersion;
        USHORT OSBuildNumber;
        USHORT OSCSDVersion;
        ULONG OSPlatformId;
        ULONG ImageSubsystem;
        ULONG ImageSubsystemMajorVersion;
        ULONG ImageSubsystemMinorVersion;
        ULONG_PTR ImageProcessAffinityMask;
        GDI_HANDLE_BUFFER GdiHandleBuffer;
        PVOID PostProcessInitRoutine;
    
        PVOID TlsExpansionBitmap;
        ULONG TlsExpansionBitmapBits[32];

        ULONG SessionId;

        ULARGE_INTEGER AppCompatFlags;
        ULARGE_INTEGER AppCompatFlagsUser;
        PVOID pShimData;
        PVOID AppCompatInfo;

        UNICODE_STRING CSDVersion;

        PVOID ActivationContextData;
        PVOID ProcessAssemblyStorageMap;
        PVOID SystemDefaultActivationContextData;
        PVOID SystemAssemblyStorageMap;
        
        SIZE_T MinimumStackCommit;
    
        PVOID *FlsCallback;
        LIST_ENTRY FlsListHead;
        PVOID FlsBitmap;
        ULONG FlsBitmapBits[FLS_MAXIMUM_AVAILABLE / (sizeof(ULONG) * 8)];
        ULONG FlsHighIndex;

        PVOID WerRegistrationData;
        PVOID WerShipAssertPtr;
        PVOID pContextData;
        PVOID pImageHeaderHash;
        union {
            ULONG TracingFlags;
            struct {
                ULONG HeapTracingEnabled : 1;
                ULONG CritSecTracingEnabled : 1;
                ULONG LibLoaderTracingEnabled : 1;
                ULONG SpareTracingBits : 29;
            };
        };
        ULONGLONG CsrServerReadOnlySharedMemoryBase;
    } PEB, *PPEB;
    
    #define GDI_BATCH_BUFFER_SIZE 310

    typedef struct _GDI_TEB_BATCH {
        ULONG Offset;
        ULONG_PTR HDC;
        ULONG Buffer[GDI_BATCH_BUFFER_SIZE];
    } GDI_TEB_BATCH, *PGDI_TEB_BATCH;
    

    typedef struct _TEB_ACTIVE_FRAME_CONTEXT {
        ULONG Flags;
        PSTR FrameName;
    } TEB_ACTIVE_FRAME_CONTEXT, *PTEB_ACTIVE_FRAME_CONTEXT;
    
    typedef struct _TEB_ACTIVE_FRAME {
        ULONG Flags;
        struct _TEB_ACTIVE_FRAME *Previous;
        PTEB_ACTIVE_FRAME_CONTEXT Context;
    } TEB_ACTIVE_FRAME, *PTEB_ACTIVE_FRAME;
    
    
    typedef struct _TEB {
        NT_TIB NtTib;

        PVOID EnvironmentPointer;
        CLIENT_ID ClientId;
        PVOID ActiveRpcHandle;
        PVOID ThreadLocalStoragePointer;
        PPEB ProcessEnvironmentBlock;

        ULONG LastErrorValue;
        ULONG CountOfOwnedCriticalSections;
        PVOID CsrClientThread;
        PVOID Win32ThreadInfo;
        ULONG User32Reserved[26];
        ULONG UserReserved[5];
        PVOID WOW32Reserved;
        LCID CurrentLocale;
        ULONG FpSoftwareStatusRegister;
        PVOID SystemReserved1[54];
        NTSTATUS ExceptionCode;
        PVOID ActivationContextStackPointer;
        #ifdef _WIN64
            UCHAR SpareBytes[24];
        #else
            UCHAR SpareBytes[36];
        #endif
        ULONG TxFsContext;

        GDI_TEB_BATCH GdiTebBatch;
        CLIENT_ID RealClientId;
        HANDLE GdiCachedProcessHandle;
        ULONG GdiClientPID;
        ULONG GdiClientTID;
        PVOID GdiThreadLocalInfo;
        ULONG_PTR Win32ClientInfo[62];
        PVOID glDispatchTable[233];
        ULONG_PTR glReserved1[29];
        PVOID glReserved2;
        PVOID glSectionInfo;
        PVOID glSection;
        PVOID glTable;
        PVOID glCurrentRC;
        PVOID glContext;

        NTSTATUS LastStatusValue;
        UNICODE_STRING StaticUnicodeString;
        WCHAR StaticUnicodeBuffer[261];

        PVOID DeallocationStack;
        PVOID TlsSlots[64];
        LIST_ENTRY TlsLinks;

        PVOID Vdm;
        PVOID ReservedForNtRpc;
        PVOID DbgSsReserved[2];

        ULONG HardErrorMode;
        #ifdef _WIN64
            PVOID Instrumentation[11];
        #else
            PVOID Instrumentation[9];
        #endif
        GUID ActivityId;

        PVOID SubProcessTag;
        PVOID EtwLocalData;
        PVOID EtwTraceData;
        PVOID WinSockData;
        ULONG GdiBatchCount;

        union {
            PROCESSOR_NUMBER CurrentIdealProcessor;
            ULONG IdealProcessorValue;
            struct {
                UCHAR ReservedPad0;
                UCHAR ReservedPad1;
                UCHAR ReservedPad2;
                UCHAR IdealProcessor;
            };
        };

        ULONG GuaranteedStackBytes;
        PVOID ReservedForPerf;
        PVOID ReservedForOle;
        ULONG WaitingOnLoaderLock;
        PVOID SavedPriorityState;
        ULONG_PTR SoftPatchPtr1;
        PVOID ThreadPoolData;
        PVOID *TlsExpansionSlots;
        #ifdef _WIN64
            PVOID DeallocationBStore;
            PVOID BStoreLimit;
        #endif
        ULONG MuiGeneration;
        ULONG IsImpersonating;
        PVOID NlsCache;
        PVOID pShimData;
        ULONG HeapVirtualAffinity;
        HANDLE CurrentTransactionHandle;
        PTEB_ACTIVE_FRAME ActiveFrame;
        PVOID FlsData;

        PVOID PreferredLanguages;
        PVOID UserPrefLanguages;
        PVOID MergedPrefLanguages;
        ULONG MuiImpersonation;
        union {
            USHORT CrossTebFlags;
            USHORT SpareCrossTebBits : 16;
        };
        union {
            USHORT SameTebFlags;
            struct {
                USHORT SafeThunkCall : 1;
                USHORT InDebugPrint : 1;
                USHORT HasFiberData : 1;
                USHORT SkipThreadAttach : 1;
                USHORT WerInShipAssertCode : 1;
                USHORT RanProcessInit : 1;
                USHORT ClonedThread : 1;
                USHORT SuppressDebugMsg : 1;
                USHORT DisableUserStackWalk : 1;
                USHORT RtlExceptionAttached : 1;
                USHORT InitialThread : 1;
                USHORT SessionAware : 1;
                USHORT SpareSameTebBits : 4;
            };
        };

        PVOID TxnScopeEnterCallback;
        PVOID TxnScopeExitCallback;
        PVOID TxnScopeContext;
        ULONG LockCount;
        ULONG SpareUlong0;
        PVOID ResourceRetValue;
        PVOID ReservedForWdf;
    } TEB, *PTEB;
}

NTDEFINES::PPEB FORCEINLINE GetPEB() {
#ifdef _AMD64_
    return (NTDEFINES::PPEB)__readgsqword(0x60);
#else
    return (NTDEFINES::PPEB)__readfsdword(0x30);
#endif
}

NTDEFINES::PTEB FORCEINLINE GetTEB() {
#ifdef _AMD64_
    return (NTDEFINES::PTEB)__readgsqword(0x30);
#else
    return (NTDEFINES::PTEB)__readfsdword(0x18);
#endif
}

VOID FORCEINLINE PebSetProcessProtected(BOOLEAN IsProtected, OPTIONAL BOOLEAN PPL = FALSE) {
    NTDEFINES::PPEB Peb = GetPEB();
    Peb->IsProtectedProcess = IsProtected;
    Peb->IsProtectedProcessLight = PPL;
}
```

`Avanguard/AvanguardDefence/ProcessAPI.cpp`:

```cpp
#include "stdafx.h"
#include "ProcessAPI.h"

typedef struct _PROCESS_BASIC_INFORMATION32 {
    ULONG ExitStatus;
    PVOID PebBaseAddress;
    ULONG AffinityMask;
    ULONG BasePriority;
    ULONG UniqueProcessId;
    ULONG ParentProcessId;
} PROCESS_BASIC_INFORMATION32, *PPROCESS_BASIC_INFORMATION32;

typedef struct _PROCESS_BASIC_INFORMATION64 {
    ULONG ExitStatus;
    ULONG Reserved0;
    UINT64 PebBaseAddress;
    UINT64 AffinityMask;
    ULONG BasePriority;
    ULONG Reserved1;
    UINT64 UniqueProcessId;
    UINT64 ParentProcessId;
} PROCESS_BASIC_INFORMATION64, *PPROCESS_BASIC_INFORMATION64;

typedef struct _PROCESS_BASIC_INFORMATION_WOW64 {
    UINT64 Wow64PebBaseAddress;
} PROCESS_BASIC_INFORMATION_WOW64, *PPROCESS_BASIC_INFORMATION_WOW64;


typedef BOOL (WINAPI *_IsWow64Process)(HANDLE hProcess, OUT PBOOL Wow64Process);

BOOL __IsWow64Process__(HANDLE hProcess, OUT PBOOL Wow64Process) {
    _IsWow64Process __IsWow64Process = (_IsWow64Process)GetProcAddress(GetModuleHandle(L"kernel32.dll"), "IsWow64Process");
    return __IsWow64Process ? __IsWow64Process(hProcess, Wow64Process) : FALSE;
}

BOOL Is64BitWindows() {
#ifdef _AMD64_
    return TRUE;
#else
    BOOL Wow64Process;
    return IsWow64Process(GetCurrentProcess(), &Wow64Process) && Wow64Process;
#endif
}

typedef NTSTATUS (NTAPI *_NtWow64QueryInformationProcess64)(
    HANDLE hProcess,
    PROCESSINFOCLASS ProcessInformationClass,
    PVOID ProcessInformation,
    ULONG ProcessInformationLength,
    OUT PUINT64 ReturnLength
);

NTSTATUS NtWow64QueryInformationProcess64(
    HANDLE hProcess, 
    PROCESSINFOCLASS ProcessInformationClass, 
    PVOID ProcessInformation, 
    ULONG ProcessInformationLength,
    OUT PUINT64 ReturnLength
) {
#ifdef _AMD64_
    if (ReturnLength) *ReturnLength = 0;
    return NtQueryInformationProcess(hProcess, ProcessInformationClass, ProcessInformation, ProcessInformationLength, (PULONG)ReturnLength);
#else
    static _NtWow64QueryInformationProcess64
        __NtWow64QueryInformationProcess64 =
        (_NtWow64QueryInformationProcess64)GetProcAddress(GetModuleHandle(L"ntdll.dll"), "NtWow64QueryInformationProcess64");

    if (__NtWow64QueryInformationProcess64 == NULL) return STATUS_UNSUCCESSFUL;

    return __NtWow64QueryInformationProcess64(hProcess, ProcessInformationClass, ProcessInformation, ProcessInformationLength, ReturnLength);
#endif
}

BOOL Is64BitProcess(HANDLE hProcess) {
    if (Is64BitWindows()) {
        BOOL Wow64Process;
        __IsWow64Process__(hProcess, &Wow64Process);
        return !Wow64Process;
    } else{
        return FALSE;
    }
}

BOOL GetProcessBasicInfo(HANDLE hProcess, OUT PPROCESS_BASIC_INFO ProcessBasicInfo) {
    if (ProcessBasicInfo == NULL) return FALSE;
    
    if (Is64BitProcess(hProcess)) {
        PROCESS_BASIC_INFORMATION64 ProcessBasicInfo64;
        UINT64 ReturnLength;
        NTSTATUS Status = NtWow64QueryInformationProcess64(hProcess, ProcessBasicInformation, &ProcessBasicInfo64, sizeof(ProcessBasicInfo64), &ReturnLength);
        if (Status != STATUS_SUCCESS) return FALSE;

        ProcessBasicInfo->ExitStatus = ProcessBasicInfo64.ExitStatus;
        ProcessBasicInfo->AffinityMask = ProcessBasicInfo64.AffinityMask;
        ProcessBasicInfo->BasePriority = ProcessBasicInfo64.BasePriority;
        ProcessBasicInfo->UniqueProcessId = ProcessBasicInfo64.UniqueProcessId;
        ProcessBasicInfo->ParentProcessId = ProcessBasicInfo64.ParentProcessId;
    } else {
#ifdef _AMD64_
        PROCESS_BASIC_INFORMATION64 ProcessBasicInfoX;
#else
        PROCESS_BASIC_INFORMATION32 ProcessBasicInfoX;
#endif
        ULONG ReturnLength;
        NTSTATUS Status = NtQueryInformationProcess(hProcess, ProcessBasicInformation, &ProcessBasicInfoX, sizeof(ProcessBasicInfoX), &ReturnLength);
        if (Status != STATUS_SUCCESS) return FALSE;
        
        ProcessBasicInfo->ExitStatus = ProcessBasicInfoX.ExitStatus;
        ProcessBasicInfo->AffinityMask = ProcessBasicInfoX.AffinityMask;
        ProcessBasicInfo->BasePriority = ProcessBasicInfoX.BasePriority;
        ProcessBasicInfo->UniqueProcessId = ProcessBasicInfoX.UniqueProcessId;
        ProcessBasicInfo->ParentProcessId = ProcessBasicInfoX.ParentProcessId;
    }

    return TRUE;
}

typedef NTSTATUS (NTAPI *_NtQueryVirtualMemory)(
    IN				HANDLE						ProcessHandle,
    IN OPTIONAL		PVOID						BaseAddress,
    IN				MEMORY_INFORMATION_CLASS	MemoryInformationClass,
    OUT				PVOID						MemoryInformation,
    IN				SIZE_T						MemoryInformationLength,
    OUT OPTIONAL	PSIZE_T						ReturnLength
);

NTSTATUS NTAPI __NtQueryVirtualMemory(
    IN				HANDLE						ProcessHandle,
    IN OPTIONAL		PVOID						BaseAddress,
    IN				MEMORY_INFORMATION_CLASS	MemoryInformationClass,
    OUT				PVOID						MemoryInformation,
    IN				SIZE_T						MemoryInformationLength,
    OUT OPTIONAL	PSIZE_T						ReturnLength
) {
    static _NtQueryVirtualMemory __dNtQueryVirtualMemory = NULL;
    if (__dNtQueryVirtualMemory == NULL) __dNtQueryVirtualMemory = 
        (_NtQueryVirtualMemory)GetProcAddress(GetModuleHandle(L"ntdll.dll"), "NtQueryVirtualMemory");
    return __dNtQueryVirtualMemory(ProcessHandle, BaseAddress, MemoryInformationClass, MemoryInformation, MemoryInformationLength, ReturnLength);
}

VOID EnumerateMemoryRegions(
    HANDLE hProcess, 
    _MapCallback Callback
) {
    if (Callback == NULL) return;
    MEMORY_BASIC_INFORMATION Info;
    SIZE_T Address = NULL;
    SIZE_T ReturnLength = 0;
    while (NT_SUCCESS(__NtQueryVirtualMemory(
        hProcess,
        (PVOID)Address,
        MemoryBasicInformation,
        &Info,
        sizeof(Info),
        &ReturnLength
    ))) {
        if (!Callback(&Info)) return;
        Address += Info.RegionSize;
    }
}

BOOL SwitchThreadsExecutionStatus(EXECUTION_STATUS ExecutionStatus) {
    HANDLE hSnapThreads = CreateToolhelp32Snapshot(TH32CS_SNAPTHREAD, GetCurrentProcessId());
    if (hSnapThreads == INVALID_HANDLE_VALUE) return FALSE;

    THREADENTRY32 ThreadInfo;
    ThreadInfo.dwSize = sizeof(ThreadInfo);

    DWORD CurrentThreadId = GetCurrentThreadId();
    DWORD CurrentProcessId = GetCurrentProcessId();
    if (Thread32First(hSnapThreads, &ThreadInfo)) do {
        if (ThreadInfo.th32OwnerProcessID != CurrentProcessId) continue;
        if (ThreadInfo.th32ThreadID == CurrentThreadId) continue;
        HANDLE hThread = OpenThread(THREAD_SUSPEND_RESUME, FALSE, ThreadInfo.th32ThreadID);
        if (hThread == NULL) continue;
        switch (ExecutionStatus) {
        case Suspend:
            SuspendThread(hThread);
            break;
        case Resume:
            ResumeThread(hThread);
            break;
        }
        CloseHandle(hThread);
    } while (Thread32Next(hSnapThreads, &ThreadInfo));

    CloseHandle(hSnapThreads);
    return TRUE;
}

BOOL EnumerateThreads(_ThreadCallback ThreadCallback) {
    HANDLE hSnapThreads = CreateToolhelp32Snapshot(TH32CS_SNAPTHREAD, GetCurrentProcessId());
    if (hSnapThreads == INVALID_HANDLE_VALUE) return FALSE;

    THREADENTRY32 ThreadInfo;
    ThreadInfo.dwSize = sizeof(ThreadInfo);

    ULONG ProcessId = GetCurrentProcessId();
    if (Thread32First(hSnapThreads, &ThreadInfo)) do {
        if (ThreadInfo.th32OwnerProcessID != ProcessId) continue;
        if (!ThreadCallback(ThreadInfo.th32ThreadID)) goto Exit;
    } while (Thread32Next(hSnapThreads, &ThreadInfo));

Exit:
    CloseHandle(hSnapThreads);
    return TRUE;
}
```

`Avanguard/AvanguardDefence/ProcessAPI.h`:

```h
#pragma once

#include <Windows.h>
#include <TlHelp32.h>
#include <functional>

#pragma warning(push)
#pragma warning(disable: 4005)
#include <winternl.h>
#include <ntstatus.h>
#pragma warning(pop)

__forceinline
HANDLE PID2H(ULONG ProcessId, DWORD DesiredAccess = PROCESS_ALL_ACCESS) {
    return OpenProcess(DesiredAccess, FALSE, ProcessId);
}

BOOL Is64BitWindows();
BOOL Is64BitProcess(HANDLE hProcess);

typedef struct _PROCESS_BASIC_INFO {
    ULONG ExitStatus;
    UINT64 AffinityMask;
    ULONG BasePriority;
    UINT64 UniqueProcessId;
    UINT64 ParentProcessId;
} PROCESS_BASIC_INFO, *PPROCESS_BASIC_INFO;

BOOL GetProcessBasicInfo(HANDLE hProcess, OUT PPROCESS_BASIC_INFO ProcessBasicInfo);

typedef enum _MEMORY_INFORMATION_CLASS {
    MemoryBasicInformation,
    MemoryWorkingSetList,
    MemorySectionName,
    MemoryBasicVlmInformation
} MEMORY_INFORMATION_CLASS;

typedef std::function<bool(const PMEMORY_BASIC_INFORMATION)> _MapCallback;

VOID EnumerateMemoryRegions(
    HANDLE hProcess, 
    _MapCallback Callback
);

typedef enum _EXECUTION_STATUS {
    Suspend,
    Resume
} EXECUTION_STATUS, *PEXECUTION_STATUS;

BOOL SwitchThreadsExecutionStatus(EXECUTION_STATUS ExecutionStatus);

typedef std::function<bool(ULONG ThreadId)> _ThreadCallback;
BOOL EnumerateThreads(_ThreadCallback ThreadCallback);

NTSTATUS NTAPI __NtQueryVirtualMemory(
    IN				HANDLE						ProcessHandle,
    IN OPTIONAL		PVOID						BaseAddress,
    IN				MEMORY_INFORMATION_CLASS	MemoryInformationClass,
    OUT				PVOID						MemoryInformation,
    IN				SIZE_T						MemoryInformationLength,
    OUT OPTIONAL	PSIZE_T						ReturnLength
);

#define NtCurrentProcess()	(HANDLE)(-1)
#define NtCurrentThread()	(HANDLE)(-2)

BOOL FORCEINLINE QueryVirtualMemory(
    IN PVOID Address, 
    OUT PMEMORY_BASIC_INFORMATION MemoryInfo
) {
    SIZE_T ReturnLength;
    return NT_SUCCESS(__NtQueryVirtualMemory(
        NtCurrentProcess(),
        Address,
        MemoryBasicInformation,
        MemoryInfo,
        sizeof(MEMORY_BASIC_INFORMATION),
        &ReturnLength
    ));
}
```

`Avanguard/AvanguardDefence/Remapping.cpp`:

```cpp
#include "stdafx.h"
#include <Windows.h>

#include "Remapping.h"
#include "hModules.h"
#include "PEAnalyzer.h"

#include <vector>

typedef struct _SEC_INFO {
    PVOID OriginalAddress;
    PVOID ShadowAddress;
    SIZE_T Size;
    BOOL Executable;
    BOOL Writeable;
} SEC_INFO, *PSEC_INFO;

typedef BOOL(WINAPI *_UnmapViewOfFile)(PVOID Address);
typedef BOOL(WINAPI *_MapViewOfFileEx)(HANDLE hMapping, DWORD Access, DWORD OffsetHigh, DWORD OffsetLow, SIZE_T BytesToMap, PVOID TargetAddress);

typedef struct _REMAP_PARAMETERS {
    HANDLE hMapping;
    HMODULE hModule;
    PVOID Shadow;
    _UnmapViewOfFile UnmapViewOfFile;
    _MapViewOfFileEx MapViewOfFileEx;
    PSEC_INFO SecInfo;
    SIZE_T SectionsCount;
} REMAP_PARAMETERS, *PREMAP_PARAMETERS;

static VOID RemapSections(PREMAP_PARAMETERS RemapParameters) {
    BOOL Status = RemapParameters->UnmapViewOfFile(RemapParameters->hModule);
    if (!Status) return;

    // Map of sections:
    for (SIZE_T i = 0; i < RemapParameters->SectionsCount; i++) {
        PSEC_INFO Section = RemapParameters->SecInfo + i;
        DWORD Access = Section->Executable ? FILE_MAP_READ | FILE_MAP_EXECUTE : FILE_MAP_READ;
        if (Section->Writeable) Access |= FILE_MAP_WRITE;
        RemapParameters->MapViewOfFileEx(
            RemapParameters->hMapping,
            Access,
            0, 
            (DWORD)((SIZE_T)Section->OriginalAddress - (SIZE_T)RemapParameters->hModule),
            Section->Size,
            Section->OriginalAddress
        );
    }

    // Map of PE-header:
    RemapParameters->MapViewOfFileEx(RemapParameters->hMapping, FILE_MAP_READ, 0, 0, USN_PAGE_SIZE, RemapParameters->hModule);
}

BOOL RemapModule(HMODULE hModule, BOOL UnmapShadowMemory) {

    PEAnalyzer pe(hModule, FALSE);
    const DWORD ImageSize = pe.GetOptionalHeader()->SizeOfImage;

    // Создаём объект отображения:
    const HANDLE hMapping = const_cast<const HANDLE>(CreateFileMapping(NULL, NULL, PAGE_EXECUTE_READWRITE, 0, ImageSize, NULL));
    if (hMapping == NULL) return FALSE;

    // Мапим отображение для теневой памяти:
    PVOID Shadow = MapViewOfFile(hMapping, FILE_MAP_ALL_ACCESS | FILE_MAP_EXECUTE, 0, 0, ImageSize);
    if (Shadow == NULL) {
        CloseHandle(hMapping);
        return FALSE;
    }

    // Копируем PE-заголовок:
    CopyMemory(Shadow, hModule, USN_PAGE_SIZE);

    std::vector<SEC_INFO> SectionsInfo;
    const auto& Sections = pe.GetSectionsInfo();
    for (const auto& Section : Sections) {
        DWORD SecType = Section.Characteristics;
        SEC_INFO SecInfo = { 0 };
        SecInfo.OriginalAddress = (PVOID)((PBYTE)hModule + Section.OffsetInMemory);
        SecInfo.ShadowAddress = (PVOID)((PBYTE)Shadow + Section.OffsetInMemory);
        SecInfo.Size = Section.SizeInMemory;
        SecInfo.Executable = ((SecType & IMAGE_SCN_CNT_CODE) == IMAGE_SCN_CNT_CODE) || ((SecType & IMAGE_SCN_MEM_EXECUTE) == IMAGE_SCN_MEM_EXECUTE);
        SecInfo.Writeable = (SecType & IMAGE_SCN_MEM_WRITE) == IMAGE_SCN_MEM_WRITE;
        CopyMemory(SecInfo.ShadowAddress, SecInfo.OriginalAddress, SecInfo.Size);
        SectionsInfo.emplace_back(SecInfo);
    }

    REMAP_PARAMETERS RemapParameters = { 0 };
    RemapParameters.hMapping = hMapping;
    RemapParameters.hModule = hModule;
    RemapParameters.Shadow = Shadow;
    RemapParameters.UnmapViewOfFile = (_UnmapViewOfFile)hModules::QueryAddress(hModules::hKernel32(), XORSTR("UnmapViewOfFile"));
    RemapParameters.MapViewOfFileEx = (_MapViewOfFileEx)hModules::QueryAddress(hModules::hKernel32(), XORSTR("MapViewOfFileEx"));
    RemapParameters.SecInfo = &*SectionsInfo.begin();
    RemapParameters.SectionsCount = SectionsInfo.size();

    typedef PVOID(WINAPI *_RemapSections)(PREMAP_PARAMETERS RemapParameters);
    _RemapSections RemapSectionsShadow = (_RemapSections)((PBYTE)Shadow + ((PBYTE)&RemapSections - (PBYTE)hModule));
    RemapSectionsShadow(&RemapParameters);

    // Размапливаем теневую память:
    if (UnmapShadowMemory) UnmapViewOfFile(Shadow);
    
    CloseHandle(hMapping);

    return TRUE;
}
```

`Avanguard/AvanguardDefence/Remapping.h`:

```h
#pragma once

BOOL RemapModule(HMODULE hModule, BOOL UnmapShadowMemory);
```

`Avanguard/AvanguardDefence/SfcWrapper.cpp`:

```cpp
#include "stdafx.h"
#include <Windows.h>
#include <Sfc.h>

#include "SfcWrapper.h"
#include "xorstr/xorstr.hpp"

BOOL Sfc::Initialized = FALSE;
_SfcIsFileProtected Sfc::__SfcIsFileProtected = NULL;

BOOL Sfc::Initialize() {
    if (Initialized) return TRUE;
    HMODULE hSfc = GetModuleHandle(XORSTR(L"sfc.dll"));
    if (!hSfc) hSfc = LoadLibrary(XORSTR(L"sfc.dll"));
    if (!hSfc) hSfc = LoadLibrary(XORSTR(L"sfc_os.dll"));
    if (hSfc) __SfcIsFileProtected = reinterpret_cast<_SfcIsFileProtected>(
        GetProcAddress(hSfc, XORSTR("SfcIsFileProtected"))
    );
    Initialized = TRUE;
    return __SfcIsFileProtected != NULL;
}

BOOL Sfc::IsFileProtected(LPCWSTR Path) {
    if (!Initialized) Initialize();
    return __SfcIsFileProtected ? __SfcIsFileProtected(NULL, Path) : FALSE;
}


```

`Avanguard/AvanguardDefence/SfcWrapper.h`:

```h
#pragma once

using _SfcIsFileProtected = BOOL (WINAPI*)(HANDLE RpcHandle, LPCWSTR Path);

class Sfc final {
private:
    static _SfcIsFileProtected __SfcIsFileProtected;
    static BOOL Initialized;
public:
    static BOOL Initialize();
    static BOOL IsFileProtected(LPCWSTR Path);
};
```

`Avanguard/AvanguardDefence/SupportedOS.manifest`:

```manifest
<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<assembly manifestVersion="1.0" xmlns="urn:schemas-microsoft-com:asm.v1" xmlns:asmv3="urn:schemas-microsoft-com:asm.v3">
    <description>Avanguard Defence</description>
    <trustInfo xmlns="urn:schemas-microsoft-com:asm.v3">
        <security>
            <requestedPrivileges>
                <requestedExecutionLevel
                    level="asInvoker"
                    uiAccess="false"
                />	
            </requestedPrivileges>
        </security>
    </trustInfo>
    <compatibility xmlns="urn:schemas-microsoft-com:compatibility.v1"> 
        <application> 
            <!-- Windows 10 --> 
            <supportedOS Id="{8e0f7a12-bfb3-4fe8-b9a5-48fd50a15a9a}"/>
            <!-- Windows 8.1 -->
            <supportedOS Id="{1f676c76-80e1-4239-95bb-83d0f6d0da78}"/>
            <!-- Windows Vista -->
            <supportedOS Id="{e2011457-1546-43c5-a5fe-008deee3d3f0}"/> 
            <!-- Windows 7 -->
            <supportedOS Id="{35138b9a-5d96-4fbd-8e2d-a2440225f93a}"/>
            <!-- Windows 8 -->
            <supportedOS Id="{4a2f28e3-53b9-4441-ba9c-d69d4a4a6e38}"/>
        </application> 
    </compatibility>
</assembly>
```

`Avanguard/AvanguardDefence/TLS.cpp`:

```cpp
#include "stdafx.h"
#include "TLS.h"

int TlsMain();

// Получаем фактическую точку входа:
PVOID GetEntryPoint(HMODULE hModule) {
    PIMAGE_DOS_HEADER DosHeader = (PIMAGE_DOS_HEADER)hModule;
    PIMAGE_NT_HEADERS NtHeaders = (PIMAGE_NT_HEADERS)((PBYTE)hModule + DosHeader->e_lfanew);
    PIMAGE_OPTIONAL_HEADER OptionalHeader = &NtHeaders->OptionalHeader;
    return (PBYTE)hModule + OptionalHeader->AddressOfEntryPoint;
}

// Получаем HMODULE текущего модуля:
HMODULE GetCurrentModule() {
    HMODULE hModule = NULL;
    GetModuleHandleEx(
        GET_MODULE_HANDLE_EX_FLAG_FROM_ADDRESS,
        (LPCTSTR)GetCurrentModule,
        &hModule
    );
    return hModule;
}

// hModule текущего модуля:
static HMODULE hInstance = GetCurrentModule();

VOID WINAPI TlsCallback(HMODULE hModule, DWORD Reason, PCONTEXT Context) {
    if (hInstance == NULL) hInstance = GetCurrentModule();
    if (hModule != hInstance || Reason != DLL_PROCESS_ATTACH) return;

    static BOOL IsCrtInitialized = FALSE;

    if (!IsCrtInitialized) { // Сюда мы ещё вернёмся
        IsCrtInitialized = TRUE;
        _EntryPoint EntryPoint = (_EntryPoint)GetEntryPoint(hInstance);
        if (EntryPoint) EntryPoint();
        return;
    }

    // Не позволим выйти из каллбэка:
    int Status;
    __try {
        Status = TlsMain();
    } __except (EXCEPTION_EXECUTE_HANDLER) {
        Status = 0xFFFFFFFF;
    }

    // ExitProcess(Status);
}

int TlsMain() {
    return 0;
}
```

`Avanguard/AvanguardDefence/TLS.h`:

```h
#pragma once

#include <Windows.h>

// #define USE_TLS_ENTRY

/*
    В TLS-каллбэке нельзя использовать CRT,
    прилинкованную статически (/MT), т.к. в
    этом случае CRT инициализируется в EntryPoint,
    который на момент вызова TLS-каллбэка ещё не вызван.

    Чтобы это обойти, из TLS-каллбэка передадим управление
    в EntryPoint, который инициализирует CRT и передаст
    управление в main(), откуда прыгнем обратно в TLS-каллбэк -
    таким образом, основное выполнение программы начнётся с TLS-каллбэка,
    а не с main().
*/

typedef VOID (__cdecl *_EntryPoint)();

#ifdef USE_TLS_ENTRY

extern HMODULE hInstance;
VOID WINAPI TlsCallback(HMODULE hModule, DWORD Reason, PCONTEXT Context);

#define Return2Tls() TlsCallback(hInstance, DLL_PROCESS_ATTACH, NULL)

#ifdef _WIN64
#pragma comment (linker, "/include:_tls_used")
#pragma comment (linker, "/include:_XLB")
#pragma const_seg(".CRT$XLB")
extern "C" const PIMAGE_TLS_CALLBACK _XLB = (PIMAGE_TLS_CALLBACK)TlsCallback;
#pragma const_seg()
#else
#pragma comment (linker, "/include:__tls_used")
#pragma comment (linker, "/include:__XLB")
#pragma data_seg(".CRT$XLB")
extern "C" PIMAGE_TLS_CALLBACK _XLB = (PIMAGE_TLS_CALLBACK)TlsCallback;
#pragma data_seg()
#endif

#endif
```

`Avanguard/AvanguardDefence/ThreadsFilter.cpp`:

```cpp
#include "stdafx.h"
#include "ThreadsFilter.h"

#pragma warning(push)
#pragma warning(disable: 4312)

// For the old SDK support:
#if (_WIN32_WINNT <= 0x0603)
typedef struct _CLIENT_ID {
    HANDLE UniqueProcess;
    HANDLE UniqueThread;
} CLIENT_ID;
#endif

namespace {
    BOOL IsThreadsHooksInitialized = FALSE;

    _ThreadCreatedCallback OnThreadCreate = NULL;
    _ValidThreadCreatedCallback OnValidThreadCreate = NULL;

    CSLock Locker;
    std::unordered_set<HANDLE> LocalThreads;

    typedef NTSTATUS(NTAPI *_NtTerminateThread)(HANDLE hThread, NTSTATUS ExitStatus);
    const _NtTerminateThread NtTerminateThread =
        (_NtTerminateThread)hModules::QueryAddress(hModules::hNtdll(), XORSTR("NtTerminateThread"));

    typedef DWORD(WINAPI *_GetThreadId)(HANDLE hProcess);
    const _GetThreadId __GetThreadId = 
        (_GetThreadId)hModules::QueryAddress(hModules::hKernel32(), XORSTR("GetThreadId"));
}



INTERCEPTION(VOID, NTAPI, LdrInitializeThunk, PCONTEXT Context) {
    HANDLE ThreadId = (HANDLE)GetCurrentThreadId();

    Locker.Lock();
    BOOL IsLocalThread = LocalThreads.find(ThreadId) != LocalThreads.end();
    BOOL Allow = OnThreadCreate ? OnThreadCreate(Context, IsLocalThread) : IsLocalThread;
    Locker.Unlock();

    if (!Allow) {
        NtTerminateThread(GetCurrentThread(), 0);
        ZeroMemory(Context, sizeof(*Context));
    }

    OrgnlLdrInitializeThunk(Context);
}

typedef struct _INITIAL_TEB {
    PVOID StackBase;
    PVOID StackLimit;
    PVOID StackCommit;
    PVOID StackCommitMax;
    PVOID StackReserved;
} INITIAL_TEB, *PINITIAL_TEB;

INTERCEPTION(NTSTATUS, NTAPI, NtCreateThread,
    OUT PHANDLE				ThreadHandle,
    IN ACCESS_MASK			DesiredAccess,
    IN POBJECT_ATTRIBUTES	ObjectAttributes OPTIONAL,
    IN HANDLE				ProcessHandle,
    OUT CLIENT_ID*			ClientId,
    IN PCONTEXT				ThreadContext,
    IN PINITIAL_TEB			InitialTeb,
    IN BOOLEAN				CreateSuspended
) {
    Locker.Lock();

    CLIENT_ID LocalClientId = { 0 };
    NTSTATUS Status = OrgnlNtCreateThread(
        ThreadHandle,
        DesiredAccess,
        ObjectAttributes,
        ProcessHandle,
        &LocalClientId,
        ThreadContext,
        InitialTeb,
        CreateSuspended
    );

    if (NT_SUCCESS(Status)) {
        HANDLE ThreadId = LocalClientId.UniqueThread;
        LocalThreads.emplace(ThreadId);
#ifdef _AMD64_
        if (OnValidThreadCreate) OnValidThreadCreate(ThreadId, (PVOID)ThreadContext->Rcx, (PVOID)ThreadContext->Rdx);
#else
        if (OnValidThreadCreate) OnValidThreadCreate(ThreadId, (PVOID)ThreadContext->Eax, (PVOID)ThreadContext->Ebx);
#endif
    }
    if (ClientId) *ClientId = LocalClientId;

    Locker.Unlock();

    return Status;
}


typedef struct _THREAD_INTERNAL_INFO {
    ULONG Flags;
    ULONG BufferSize;
    PVOID Buffer;
    ULONG Unknown;
} CLIENT_INFO, TEB_INFO, *PCLIENT_INFO, *PTEB_INFO;

typedef struct _THREAD_INFO {
    ULONG		Length;
    CLIENT_INFO	Client;
    TEB_INFO	TEB;
} THREAD_INFO, *PTHREAD_INFO;

INTERCEPTION(NTSTATUS, NTAPI, NtCreateThreadEx,
    OUT PHANDLE					ThreadHandle,
    IN  ACCESS_MASK				DesiredAccess,
    IN  POBJECT_ATTRIBUTES		ObjectAttributes,
    IN  HANDLE					ProcessHandle,
    IN  LPTHREAD_START_ROUTINE	lpStartAddress,
    IN  LPVOID					lpParameter,
    IN  BOOL					CreateSuspended,
    IN  SIZE_T					StackZeroBits,
    IN  SIZE_T					SizeOfStackCommit,
    IN  SIZE_T					SizeOfstackReserve,
    OUT PTHREAD_INFO			ThreadInfo
) {
    Locker.Lock();

    NTSTATUS Status = OrgnlNtCreateThreadEx(
        ThreadHandle,
        DesiredAccess,
        ObjectAttributes,
        ProcessHandle,
        lpStartAddress,
        lpParameter,
        CreateSuspended,
        StackZeroBits,
        SizeOfStackCommit,
        SizeOfstackReserve,
        ThreadInfo
    );

    if (NT_SUCCESS(Status) && (GetProcessId(ProcessHandle) == GetCurrentProcessId())) {
        HANDLE ThreadId = (HANDLE)__GetThreadId(*ThreadHandle);
        LocalThreads.emplace(ThreadId);
        if (OnValidThreadCreate) OnValidThreadCreate(ThreadId, lpStartAddress, lpParameter);
    }
    
    Locker.Unlock();
    return Status;
}


INTERCEPTION(NTSTATUS, NTAPI, NtTerminateThread,
    IN HANDLE ThreadHandle,
    IN NTSTATUS ExitStatus
) {
    HANDLE ThreadId = (HANDLE)__GetThreadId(ThreadHandle);
    BOOL IsCurrentThread = ThreadId == (HANDLE)GetCurrentThreadId();

    BOOL ThreadExists;
    Locker.Lock();
    ThreadExists = LocalThreads.find(ThreadId) != LocalThreads.end();
    if (ThreadExists) LocalThreads.erase(ThreadId);
    Locker.Unlock();

    NTSTATUS Status = OrgnlNtTerminateThread(ThreadHandle, ExitStatus);

    if (!NT_SUCCESS(Status)) {
        if (ThreadExists) {
            Locker.Lock();
            LocalThreads.emplace(ThreadId);
            Locker.Unlock();
        }
    }

    return Status;
}


const PVOID pNtCreateThread = hModules::QueryAddress(hModules::hNtdll(), XORSTR("NtCreateThread"));
const PVOID pNtCreateThreadEx = hModules::QueryAddress(hModules::hNtdll(), XORSTR("NtCreateThreadEx"));
const PVOID pNtTerminateThread = hModules::QueryAddress(hModules::hNtdll(), XORSTR("NtTerminateThread"));
const PVOID pLdrInitializeThunk = hModules::QueryAddress(hModules::hNtdll(), XORSTR("LdrInitializeThunk"));

HOOK_INFO ThreadsHooksInfo[] = {
    INTERCEPTION_ENTRY(pLdrInitializeThunk, LdrInitializeThunk),
    INTERCEPTION_ENTRY(pNtCreateThread, NtCreateThread),
    INTERCEPTION_ENTRY(pNtCreateThreadEx, NtCreateThreadEx),
    INTERCEPTION_ENTRY(pNtTerminateThread, NtTerminateThread)
};


BOOL SetupThreadsFilter(
    _ValidThreadCreatedCallback ValidThreadCreatedCallback,
    _ThreadCreatedCallback ThreadCreatedCallback
) {
    OnThreadCreate = ThreadCreatedCallback;
    OnValidThreadCreate = ValidThreadCreatedCallback;

    if (!IsThreadsHooksInitialized) {
        LocalThreads.clear();
        IsThreadsHooksInitialized = HookEmAll(ThreadsHooksInfo, sizeof(ThreadsHooksInfo) / sizeof(ThreadsHooksInfo[0]));
    }
    return IsThreadsHooksInitialized;
}

VOID RemoveThreadsFilter() {
    if (IsThreadsHooksInitialized) 
        UnHookEmAll(ThreadsHooksInfo, sizeof(ThreadsHooksInfo) / sizeof(ThreadsHooksInfo[0]));
    IsThreadsHooksInitialized = FALSE;
}

#pragma warning(pop)
```

`Avanguard/AvanguardDefence/ThreadsFilter.h`:

```h
#pragma once

#include <winternl.h>
#include <intrin.h>

#include "hModules.h"
#include "..\\HoShiMin's API\\HookHelper.h"
#include "Locks.h"

#include <unordered_set>

/*
    LdrInitializeThunk - точка создания потока:
        x32:
         - EAX - процедура потока
         - EBX - аргумент
        x64:
         - RCX - процедура потока
         - RDX - аргумент
*/

// Каллбэк создания потока через CreateThread:
typedef VOID (CALLBACK *_ValidThreadCreatedCallback) (
    IN HANDLE ThreadId,
    IN PVOID EntryPoint,
    IN PVOID Parameter
);

// Каллбэк LdrInitializeThunk для всех потоков.
// Возвратить TRUE, если поток разрешить к исполнению,
// или FALSE, если поток необходимо завершить:
typedef BOOL (CALLBACK *_ThreadCreatedCallback) (
    PCONTEXT Context,
    BOOL ThreadIsLocal
);

BOOL SetupThreadsFilter(
    _ValidThreadCreatedCallback ValidThreadCreatedCallback,
    _ThreadCreatedCallback ThreadCreatedCallback
);

VOID RemoveThreadsFilter();
```

`Avanguard/AvanguardDefence/ThreatElimination.cpp`:

```cpp
#include "stdafx.h"
#include "AvnDefinitions.h"
#include "JavaBindings.h"
#include "ThreatTypes.h"
#include "hModules.h"
#include "ThreatElimination.h"

static _AvnThreatNotifier _ThreatCallback = NULL;

typedef NTSTATUS (NTAPI *_NtContinue)(PCONTEXT Context, BOOL TestAlert);
static const _NtContinue NtContinue = (_NtContinue)hModules::QueryAddress(hModules::hNtdll(), XORSTR("NtContinue"));

[[noreturn]]
VOID TerminateInternal() {
    __fastfail(0);
    CONTEXT Context; // Stay uninitialized
    NtContinue(&Context, FALSE);
}

VOID EliminateThreat(AVN_THREAT Threat, OPTIONAL PVOID Data, AVN_ET_ACTION Action) 
{
    if (_ThreatCallback)
        if (_ThreatCallback(Threat, Data)) return;
#ifdef JAVA_BINDINGS
    if (CallJavaNotifier(Threat) == etContinue) return;
#endif

    if (Action != etTerminate) return;

    CONTEXT Context = { 0 };
    RtlCaptureContext(&Context);
#ifdef _AMD64_
    Context.Rip = (SIZE_T)TerminateInternal;
#else
    Context.Eip = (SIZE_T)TerminateInternal;
#endif
    NtContinue(&Context, FALSE);
}

VOID SetupNotificationRoutine(_AvnThreatNotifier ThreatCallback) {
    _ThreatCallback = ThreatCallback;
}
```

`Avanguard/AvanguardDefence/ThreatElimination.h`:

```h
#pragma once

#include "ThreatTypes.h"

VOID SetupNotificationRoutine(_AvnThreatNotifier ThreatCallback);

enum AVN_ET_ACTION {
    etContinue,
    etTerminate,
    etNotSpecified
};

VOID EliminateThreat(AVN_THREAT Threat, OPTIONAL PVOID Data, AVN_ET_ACTION Action);
```

`Avanguard/AvanguardDefence/ThreatTypes.h`:

```h
#pragma once

#include <Windows.h>

typedef enum _AVN_THREAT {
    avnUnknownThreat,
    avnRemoteThread,
    avnWindowsHooksInjection,
    avnUnknownTraceLoadLibrary,
    avnContextManipulation,
    avnCriticalModuleChanged,
    avnUnknownInterception,
    avnUnknownMemoryRegion,
    avnUnknownApcDestination
} AVN_THREAT, *PAVN_THREAT;

// Return TRUE - continue execution
// Return FALSE - terminate process
typedef BOOL(WINAPI *_AvnThreatNotifier)(
    AVN_THREAT Threat,
    OPTIONAL PVOID Data
);
```

`Avanguard/AvanguardDefence/WinHooks.cpp`:

```cpp
#include "stdafx.h"
#include "WinHooks.h"

#include "../HoShiMin's API/DisasmHelper.h"

SIZE_T GetFuncSize(PVOID BaseAddress, unsigned int InstructionsCount) {
    SIZE_T Result = 0;
    disassemble([&](void* Code, void* BaseAddress, unsigned int InstructionLength, char* Disassembly) -> bool {
        Result += InstructionLength;
        return strstr(Disassembly, "ret") == 0;
    }, BaseAddress, BaseAddress, InstructionsCount);
    return Result;
}

BOOL WinHooks::Initialized = FALSE;
PVOID WinHooks::__ClientLoadLibrary = NULL;
std::vector<PVOID> WinHooks::KernelCallbacks;

BOOL WinHooks::Initialize() {
    if (Initialized) return TRUE;

    PVOID* KernelCallbackTable = (PVOID*)(GetPEB()->KernelCallbackTable);
    if (KernelCallbackTable == NULL) return FALSE;

    HMODULE hModule = GetModuleBase(*KernelCallbackTable);
    if (hModule == NULL) return FALSE;

    for (unsigned int i = 0; GetModuleBase(KernelCallbackTable[i]) == hModule; i++)
        KernelCallbacks.emplace_back(KernelCallbackTable[i]);
    std::sort(KernelCallbacks.begin(), KernelCallbacks.end());

    return Initialized = KernelCallbacks.size() > 0;
}

BOOL WinHooks::IsCalledFromWinHook() {
    if (!Initialized && !Initialize()) return FALSE;

    BOOL Status = FALSE;

    const int TracesCount = 50; // Max is USHRT_MAX

    PVOID Ptrs[TracesCount];
    USHORT Captured = CaptureStackBackTrace(0, TracesCount, Ptrs, NULL);

    if (__ClientLoadLibrary) {
        for (unsigned short i = 0; i < Captured; i++) if (Ptrs[i] == __ClientLoadLibrary) {
            Status = TRUE;
            goto AddressFound;
        }
    } else {
        for (unsigned short i = 0; i < Captured; i++) {
            PVOID Address = Ptrs[i];
            for (unsigned int j = 0; j < KernelCallbacks.size() - 1; j++) {
                if (
                    ((SIZE_T)Address >= (SIZE_T)KernelCallbacks[j]) && 
                    ((SIZE_T)Address < (SIZE_T)KernelCallbacks[j] + GetFuncSize(KernelCallbacks[j], 999999))
                ) {
                    Status = TRUE;
                    __ClientLoadLibrary = Address;
                    goto AddressFound;
                }
            }
        }
    }
AddressFound:
    return Status;
}
```

`Avanguard/AvanguardDefence/WinHooks.h`:

```h
#pragma once

#include <Windows.h>
#include <vector>
#include <algorithm>

#include "PebTeb.h"
#include "ModulesUtils.h"

/*
    Принцип работы оконных хуков:
    1.	Ставим хук в инжектируемой библиотеке через
        SetWindowsHookEx
    2.	Атакуемое приложение получает сообщение
        через NtUserPeekMessage (user32.dll на Win7 и win32u.dll на Win10), 
        спускается в ядро (syscall)
    3.	Ядро вызывает юзермодный каллбэк с индексом в качестве аргумента
    4.	Аргумент - индекс функции __ClientLoadLibrary в PEB->KernelCallbacks 
    5.	Функция находится в user32.dll/win32u.dll и внутри вызывает LoadLibrary
*/

class WinHooks final {
private:
    static BOOL Initialized;
    static PVOID __ClientLoadLibrary;
    static std::vector<PVOID> KernelCallbacks;
    static BOOL Initialize();
public:
    static BOOL IsCalledFromWinHook();
};
```

`Avanguard/AvanguardDefence/WinTrusted.cpp`:

```cpp
#include "stdafx.h"
#include <Windows.h>
#include <WinTrust.h>
#include <Softpub.h>
//#include <wincrypt.h>
//#include <mscat.h>

#include "WinTrusted.h"

#include "xorstr/xorstr.hpp"

//#pragma comment(lib, "wintrust.lib")
//#pragma comment(lib, "crypt32.lib")

namespace {
    using _WinVerifyTrust = LONG(WINAPI*)(HWND hwnd, GUID* pgActionID, LPVOID pWVTData);
    _WinVerifyTrust __WinVerifyTrust = NULL;
}

BOOL InitWinTrust() {
    if (__WinVerifyTrust != NULL) return TRUE;
    HMODULE hWinTrust = GetModuleHandle(XORSTR(L"wintrust.dll"));
    if (!hWinTrust) hWinTrust = LoadLibrary(XORSTR(L"wintrust.dll"));
    if (hWinTrust) __WinVerifyTrust = reinterpret_cast<_WinVerifyTrust>(
        GetProcAddress(hWinTrust, XORSTR("WinVerifyTrust"))    
    );
    return __WinVerifyTrust != NULL;
}

BOOL IsFileSigned(LPCWSTR FilePath, BOOL CheckRevocation) {
    if (!InitWinTrust()) return FALSE;

    WINTRUST_FILE_INFO FileInfo = { 0 };
    FileInfo.cbStruct = sizeof(FileInfo);
    FileInfo.pcwszFilePath = FilePath;

    WINTRUST_DATA WinTrustData = { 0 };
    WinTrustData.cbStruct = sizeof(WinTrustData);
    WinTrustData.dwUIChoice = WTD_UI_NONE;
    WinTrustData.fdwRevocationChecks = CheckRevocation ? WTD_REVOKE_WHOLECHAIN : WTD_REVOKE_NONE;
    WinTrustData.dwUnionChoice = WTD_CHOICE_FILE;
    WinTrustData.pFile = &FileInfo;

    GUID ActionGUID = WINTRUST_ACTION_GENERIC_VERIFY_V2;

    return __WinVerifyTrust(NULL, &ActionGUID, &WinTrustData) == ERROR_SUCCESS;
}

/*
BOOL VerifyEmbeddedSignature(LPCWSTR FilePath) {
    WINTRUST_FILE_INFO FileInfo = { 0 };
    FileInfo.cbStruct = sizeof(WINTRUST_FILE_INFO);
    FileInfo.pcwszFilePath = FilePath;
    
    WINTRUST_DATA WinTrustData = { 0 };
    WinTrustData.cbStruct = sizeof(WINTRUST_DATA);
    WinTrustData.dwUnionChoice = WTD_CHOICE_FILE;
    WinTrustData.pFile = &FileInfo;
    WinTrustData.dwUIChoice = WTD_UI_NONE;
    WinTrustData.fdwRevocationChecks = WTD_REVOKE_NONE;
    WinTrustData.dwProvFlags = WTD_SAFER_FLAG;

    GUID ActionGUID = WINTRUST_ACTION_GENERIC_VERIFY_V2;

    LONG Status = WinVerifyTrust(NULL, &ActionGUID, &WinTrustData);

    if (Status == ERROR_SUCCESS) return TRUE;

    // If it failed, try to verify using the catalog files:

    HANDLE hFile = CreateFileW(FilePath, GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
    if (hFile == INVALID_HANDLE_VALUE) return FALSE;

    BYTE HashData[100];
    DWORD HashSize = sizeof(HashData);
    if (!CryptCATAdminCalcHashFromFileHandle(hFile, &HashSize, HashData, 0)) {
        CloseHandle(hFile);
        return FALSE;
    }

    // Create a string form of the hash (used later in MemberTag):
    LPWSTR MemberTag = new WCHAR[HashSize * 2 + 1];
    for (DWORD HashIterator = 0; HashIterator < HashSize; HashIterator++) {
        wsprintfW(&MemberTag[HashIterator * 2], L"%02X", HashData[HashIterator]);
    }

    HCATADMIN hCatAdmin;
    GUID DriverActionGuid = DRIVER_ACTION_VERIFY;
    if (!CryptCATAdminAcquireContext(&hCatAdmin, &DriverActionGuid, 0)) {
        CloseHandle(hFile);
        return FALSE;
    }

    // Find the catalog which contains the hash:
    HCATINFO hCatInfo = CryptCATAdminEnumCatalogFromHash(hCatAdmin, HashData, HashSize, 0, NULL);
    if (hCatInfo) {
        CATALOG_INFO CatalogInfo = { 0 };
        CryptCATCatalogInfoFromContext(hCatInfo, &CatalogInfo, 0);

        WINTRUST_CATALOG_INFO WinTrustCatalogInfo = { 0 };
        WinTrustCatalogInfo.cbStruct = sizeof(WINTRUST_CATALOG_INFO);
        WinTrustCatalogInfo.pcwszCatalogFilePath = CatalogInfo.wszCatalogFile;
        WinTrustCatalogInfo.pcwszMemberFilePath = FilePath;
        WinTrustCatalogInfo.pcwszMemberTag = MemberTag;

        ZeroMemory(&WinTrustData, sizeof(WinTrustData));
        WinTrustData.cbStruct = sizeof(WINTRUST_DATA);
        WinTrustData.dwUnionChoice = WTD_CHOICE_CATALOG;
        WinTrustData.pCatalog = &WinTrustCatalogInfo;
        WinTrustData.dwUIChoice = WTD_UI_NONE;
        WinTrustData.fdwRevocationChecks = WTD_STATEACTION_VERIFY;
        
        Status = WinVerifyTrust(NULL, &ActionGUID, &WinTrustData);
            
        CryptCATAdminReleaseCatalogContext(hCatAdmin, hCatInfo, 0);
    }

    CryptCATAdminReleaseContext(hCatAdmin, 0);
    delete[] MemberTag;
    CloseHandle(hFile);

    return Status == ERROR_SUCCESS;
}
*/
```

`Avanguard/AvanguardDefence/WinTrusted.h`:

```h
#pragma once

BOOL InitWinTrust();
BOOL IsFileSigned(LPCWSTR FilePath, BOOL CheckRevocation);
//BOOL VerifyEmbeddedSignature(LPCWSTR FilePath);
```

`Avanguard/AvanguardDefence/hModules.cpp`:

```cpp
#include "stdafx.h"
#include "hModules.h"

HMODULE hModules::_hNtdll = NULL;
HMODULE hModules::_hKernelBase = NULL;
HMODULE hModules::_hKernel32 = NULL;
HMODULE hModules::_hProcess = NULL;
HMODULE hModules::_hCurrent = NULL; // Should to be initialized in DllMain
_GetProcAddress hModules::_XoredQueryAddress = NULL;
```

`Avanguard/AvanguardDefence/hModules.h`:

```h
#pragma once

#include <Windows.h>

typedef PVOID (WINAPI *_GetProcAddress)(HMODULE hModule, LPCSTR ProcName);

class hModules final {
private:
    static BOOL Initialized;
    static HMODULE _hNtdll;
    static HMODULE _hKernelBase;
    static HMODULE _hKernel32;
    static HMODULE _hProcess;
    static _GetProcAddress _XoredQueryAddress;
public:
    static HMODULE _hCurrent; // Current module
    static inline HMODULE hNtdll();
    static inline HMODULE hKernelBase();
    static inline HMODULE hKernel32();
    static inline HMODULE hProcess();
    static inline HMODULE hCurrent();
    static inline PVOID WINAPI QueryAddress(HMODULE hModule, LPCSTR ProcName);
};



#define GET_HMODULE(VarName, LibName) VarName ? VarName : VarName = GetModuleHandle(LibName)

inline HMODULE hModules::hNtdll() {
    return GET_HMODULE(_hNtdll, L"ntdll.dll");
}

inline HMODULE hModules::hKernelBase() {
    return GET_HMODULE(_hKernelBase, L"kernelbase.dll");
}

inline HMODULE hModules::hKernel32() {
    return GET_HMODULE(_hKernel32, L"kernel32.dll");
}

inline HMODULE hModules::hProcess() {
    return GET_HMODULE(_hProcess, NULL);
}

inline HMODULE hModules::hCurrent() {
    return _hCurrent;
}

inline PVOID WINAPI hModules::QueryAddress(HMODULE hModule, LPCSTR ProcName) {
    return GetProcAddress(hModule, ProcName);
    const SIZE_T Key = (SIZE_T)0xF3C2A713B4340C2A;
    if (!_XoredQueryAddress)
        _XoredQueryAddress = (_GetProcAddress)((SIZE_T)GetProcAddress(hKernel32(), "GetProcAddress") ^ Key);
    return ((_GetProcAddress)((SIZE_T)_XoredQueryAddress ^ Key))(hModule, ProcName);
}

#undef GET_HMODULE
```

`Avanguard/HoShiMin's API/CodepageAPI.cpp`:

```cpp
#include "stdafx.h"
#include "CodepageAPI.h"

std::string WideToAnsi32(const std::wstring &WideString, WORD CodePage) {
    if (WideString.empty()) return std::string();

    int Length = WideCharToMultiByte(
        CodePage,
        WC_COMPOSITECHECK | WC_DISCARDNS | WC_SEPCHARS | WC_DEFAULTCHAR,
        WideString.c_str(),
        -1,
        NULL,
        0,
        NULL,
        NULL
    );

    if (Length == 0) return std::string();

    std::string Result;
    Result.resize(Length - 1);

    WideCharToMultiByte(
        CodePage,
        WC_COMPOSITECHECK | WC_DISCARDNS | WC_SEPCHARS | WC_DEFAULTCHAR,
        WideString.c_str(),
        -1,
        (LPSTR)Result.c_str(),
        Length - 1,
        NULL,
        NULL
    );

    return Result;
}

std::wstring AnsiToWide32(const std::string &AnsiString, WORD CodePage) {
    if (AnsiString.empty()) return std::wstring();

    int Length = MultiByteToWideChar(
        CodePage,
        MB_PRECOMPOSED,
        AnsiString.c_str(),
        -1,
        NULL,
        0
    );

    if (Length == 0) return std::wstring();

    std::wstring Result;
    Result.resize(Length - 1);

    MultiByteToWideChar(
        CodePage,
        MB_PRECOMPOSED,
        AnsiString.c_str(),
        -1,
        (LPWSTR)Result.c_str(),
        Length - 1
    );

    return Result;
}

std::string StrOemToAnsi(const std::string &String) {
    if (String.empty()) return std::string();

    unsigned int Length = (unsigned int)String.length();

    std::string Result;
    Result.resize(Length);

    OemToAnsiBuff(String.c_str(), (LPSTR)Result.c_str(), Length);
    return Result;
}

std::string StrAnsiToOem(const std::string &String) {
    if (String.empty()) return std::string();

    unsigned int Length = (unsigned int)String.length();

    std::string Result;
    Result.resize(Length);

    AnsiToOemBuff(String.c_str(), (LPSTR)Result.c_str(), Length);
    return Result;
}

VOID ConvertToAnsi(LPSTR OEM) {
    OemToAnsi((LPSTR)OEM, OEM);
}

VOID ConvertToOem(LPSTR Ansi) {
    AnsiToOem((LPSTR)Ansi, Ansi);
}
```

`Avanguard/HoShiMin's API/CodepageAPI.h`:

```h
#pragma once

#include <Windows.h>
#include <string>

std::string WideToAnsi32(const std::wstring &WideString, WORD CodePage = CP_ACP);
std::wstring AnsiToWide32(const std::string &AnsiString, WORD CodePage = CP_ACP);

std::string StrOemToAnsi(const std::string &String);
std::string StrAnsiToOem(const std::string &String);

VOID ConvertToAnsi(LPSTR OEM);
VOID ConvertToOem(LPSTR Ansi);
```

`Avanguard/HoShiMin's API/ColoredConsole.h`:

```h
#pragma once

#include <Windows.h>

void inline pclr(unsigned short attributes) {
    static HANDLE hConsole = NULL;
    if (!hConsole) hConsole = GetStdHandle(STD_OUTPUT_HANDLE);
    SetConsoleTextAttribute(hConsole, attributes);
}

#define B_YELLOW	(FOREGROUND_GREEN | FOREGROUND_RED | FOREGROUND_INTENSITY)
#define B_RED		(FOREGROUND_RED | FOREGROUND_INTENSITY)
#define B_GREEN		(FOREGROUND_GREEN | FOREGROUND_INTENSITY)
#define B_BLUE		(FOREGROUND_BLUE | FOREGROUND_INTENSITY)
#define B_WHITE		(FOREGROUND_RED | FOREGROUND_GREEN | FOREGROUND_BLUE | FOREGROUND_INTENSITY)

#define YELLOW	(FOREGROUND_GREEN)
#define RED		(FOREGROUND_RED)
#define GREEN	(FOREGROUND_GREEN)
#define BLUE	(FOREGROUND_BLUE)
#define WHITE	(FOREGROUND_RED | FOREGROUND_GREEN | FOREGROUND_BLUE)

#define $BY ); pclr(B_YELLOW); printf(
#define $BR ); pclr(B_RED); printf(
#define $BG ); pclr(B_GREEN); printf(
#define $BB ); pclr(B_BLUE); printf(
#define $BW ); pclr(B_WHITE); printf(

#define $Y ); pclr(YELLOW); printf(
#define $R ); pclr(RED); printf(
#define $G ); pclr(GREEN); printf(
#define $B ); pclr(BLUE); printf(
#define $W ); pclr(WHITE); printf(

#define $fill(...) , __VA_ARGS__); printf(
```

`Avanguard/HoShiMin's API/DisasmHelper.cpp`:

```cpp
#include "stdafx.h"

#define ZYDIS_STATIC_DEFINE
#include "..\\Zydis\\Zydis\\Zydis.h"

#include <string>

#include "DisasmHelper.h"

std::string disassemble(
    _OnDisassembleCallback callback,
    void* code,
    void* base_address,
    int instructions_count,
    CODE_ARCH arch
) {
    if (arch == arch_native) {
#ifdef _AMD64_
        arch = arch_x64;
#else if defined _X86_
        arch = arch_x86;
#endif
    }

    // Initialize decoder context:
    ZydisDecoder decoder;
    switch (arch) {
    case arch_x86:
        ZydisDecoderInit(&decoder, ZYDIS_MACHINE_MODE_LEGACY_32, ZYDIS_ADDRESS_WIDTH_32);
        break;
    case arch_x64:
        ZydisDecoderInit(&decoder, ZYDIS_MACHINE_MODE_LONG_64, ZYDIS_ADDRESS_WIDTH_64);
        break;
    default:
        return std::string("Invalid architecture type");
    }

    ZydisFormatter formatter;
    ZydisFormatterInit(&formatter, ZYDIS_FORMATTER_STYLE_INTEL);

    std::string result;
    int instructions_counter = 0;

    uint64_t instructionPointer = (uint64_t)base_address;
    uint8_t* readPointer = (uint8_t*)code;
    size_t length = (size_t)instructions_count * 24;
    ZydisDecodedInstruction instruction;
    while (ZYDIS_SUCCESS(ZydisDecoderDecodeBuffer(&decoder, readPointer, length, instructionPointer, &instruction))) {
        if (instructions_counter == instructions_count) break;

        char buffer[256];
        ZydisFormatterFormatInstruction(&formatter, &instruction, buffer, sizeof(buffer));

        char address[32];
        sprintf_s(address, "0x%016I64X\t", (uint64_t)instructionPointer);
        result += std::string(address) + buffer + std::string("\r\n");

        if (callback)
            if (!callback((void*)readPointer, (void*)instructionPointer, instruction.length, buffer)) break;

        readPointer += instruction.length;
        length -= instruction.length;
        instructionPointer += instruction.length;

        instructions_counter++;
    }

    return result;
}
```

`Avanguard/HoShiMin's API/DisasmHelper.h`:

```h
#pragma once

#include <functional>

typedef enum _CODE_ARCH {
    arch_x86,
    arch_x64,
    arch_native
} CODE_ARCH, *PCODE_ARCH;

typedef std::function<bool(
    void* Code,
    void* BaseAddress,
    unsigned int InstructionLength,
    char* Disassembly
)> _OnDisassembleCallback;

std::string disassemble(
    _OnDisassembleCallback callback,
    void* code,
    void* base_address,
    int instructions_count,
    CODE_ARCH arch = arch_native
);
```

`Avanguard/HoShiMin's API/HookHelper.h`:

```h
#pragma once

#include <Windows.h>
#include "..\\MinHook\\MinHook.h"

typedef struct _HOOK_INFO {
    PVOID	TargetProc;
    PVOID	HookProc;
    PVOID*	OriginalProc;
} HOOK_INFO, *PHOOK_INFO;

VOID FORCEINLINE UnHookEmAll(const PHOOK_INFO HookInfoArray, ULONG EntriesCount) {
    for (unsigned int i = 0; i < EntriesCount; i++) {
        MH_DisableHook(HookInfoArray[i].TargetProc);
        MH_RemoveHook(HookInfoArray[i].TargetProc);
    }
}

static BOOL HookEmAll(const PHOOK_INFO HookInfoArray, ULONG EntriesCount) {
    MH_STATUS MhStatus;
    MhStatus = MH_Initialize();
    if (MhStatus != MH_OK && MhStatus != MH_ERROR_ALREADY_INITIALIZED) return FALSE;

    for (unsigned int i = 0; i < EntriesCount; i++) {
        MhStatus = MH_CreateHook(HookInfoArray[i].TargetProc, HookInfoArray[i].HookProc, HookInfoArray[i].OriginalProc);
        if (MhStatus != MH_OK) {
            UnHookEmAll(HookInfoArray, i);
            return FALSE;
        }
        MhStatus = MH_EnableHook(HookInfoArray[i].TargetProc);
        if (MhStatus != MH_OK) {
            MH_RemoveHook(HookInfoArray[i].TargetProc);
            UnHookEmAll(HookInfoArray, i);
            return FALSE;
        }
    }

    return TRUE;
}

#define INTERCEPTION_ENTRY(Address, FunctionName) { Address, (LPVOID)Hkd##FunctionName, (LPVOID*)&Orgnl##FunctionName }

#define INTERCEPT(Address, FunctionName) \
MH_CreateHook(Address, (LPVOID)Hkd##FunctionName, (LPVOID*)&Orgnl##FunctionName)

#define ENABLE_HOOK(Address) \
MH_EnableHook(Address)

class HookStorage final {
private:
    BOOL Enabled;
    PVOID Target;
    PVOID Detour;
    PVOID Original;
public:
    HookStorage(PVOID TargetFunction, PVOID DetourFunction, BOOL InitialState = TRUE) : Enabled(FALSE) {
        Target = TargetFunction;
        Detour = DetourFunction;
        MH_Initialize();
        MH_CreateHook(Target, Detour, &Original);
        if (InitialState) Enable();
    }

    ~HookStorage() {
        Disable();
        MH_RemoveHook(Target);
    }

    PVOID GetTargetAddress() const { return Target; }
    PVOID GetDetourAddress() const { return Detour; }
    PVOID GetOriginalAddress() const { return Original; }

    BOOL IsEnabled() const { return Enabled; }

    BOOL Enable() {
        return Enabled = MH_EnableHook(Target) == MH_OK;
    }

    BOOL Disable() {
        return !(Enabled = !(MH_DisableHook(Target) == MH_OK));
    }
};


#define Hook(ReturnType, Convention, FunctionName, Address, InitialState, ...)  \
    typedef ReturnType(Convention *_##FunctionName) (__VA_ARGS__);              \
    static ReturnType Convention Hkd##FunctionName(__VA_ARGS__);                \
    HookStorage HkStrg##FunctionName(Address, Hkd##FunctionName, InitialState); \
    static ReturnType Convention Hkd##FunctionName(__VA_ARGS__)

#define OriginalCall(FunctionName, ...) ((_##FunctionName)((HkStrg##FunctionName).GetOriginalAddress()))(__VA_ARGS__)
#define EnableHook(FunctionName) (HkStrg##FunctionName).Enable()
#define DisableHook(FunctionName) (HkStrg##FunctionName).Disable()

#define INTERCEPTION(ReturnType, Convention, FunctionName, ...)     \
    typedef ReturnType (Convention *_##FunctionName) (__VA_ARGS__); \
    static _##FunctionName Orgnl##FunctionName;                     \
    static ReturnType Convention Hkd##FunctionName(__VA_ARGS__)

#define FILTRATION(ReturnType, Convention, FunctionName, ...)                                       \
    typedef ReturnType (Convention *_##FunctionName) (__VA_ARGS__);                                 \
    typedef ReturnType (Convention *_Pre##FunctionName) (OUT PBOOL SkipOriginalCall, __VA_ARGS__);  \
    typedef ReturnType (Convention *_Post##FunctionName) (IN ReturnType ReturnValue, __VA_ARGS__);  \
    static _##FunctionName Orgnl##FunctionName;                                                     \
    static _Pre##FunctionName pPre##FunctionName = NULL;                                            \
    static _Post##FunctionName pPost##FunctionName = NULL;                                          \
    static ReturnType Convention Hkd##FunctionName(__VA_ARGS__)

#define FILTRATE(ReturnType, ResultVarName, FunctionName, ...)                                  \
    BOOL SkipOriginalCall = FALSE;                                                              \
    ReturnType ResultVarName;                                                                   \
    if (pPre##FunctionName) ResultVarName = pPre##FunctionName(&SkipOriginalCall, __VA_ARGS__); \
    if (SkipOriginalCall) goto Post;                                                            \
    ResultVarName = Orgnl##FunctionName(__VA_ARGS__);                                           \
Post:                                                                                           \
    if (pPost##FunctionName) ResultVarName = pPost##FunctionName(ResultVarName, __VA_ARGS__);	

#define FILTRATE_TO(ReturnType, ResultVarName, FunctionName, PreCallback, PostCallback, ...)    \
    BOOL SkipOriginalCall = FALSE;                                                              \
    ReturnType ResultVarName;                                                                   \
    if (PreCallback) ResultVarName = PreCallback(&SkipOriginalCall, __VA_ARGS__);               \
    if (SkipOriginalCall) goto Post;                                                            \
    ResultVarName = Orgnl##FunctionName(__VA_ARGS__);                                           \
Post:                                                                                           \
    if (PostCallback) ResultVarName = PostCallback(ResultVarName, __VA_ARGS__);	

#define PRE_FILTRATE_TO(ReturnType, ResultVarName, FunctionName, PreCallback, ...)  \
    BOOL SkipOriginalCall = FALSE;                                                  \
    ReturnType ResultVarName;                                                       \
    if (PreCallback) ResultVarName = PreCallback(&SkipOriginalCall, __VA_ARGS__);   \
    if (SkipOriginalCall) goto Post;                                                \
    ResultVarName = Orgnl##FunctionName(__VA_ARGS__);                               \
Post:																							

#define DEFINE_FILTERS(FunctionName, PreCallback, PostCallback) \
    pPre##FunctionName = PreCallback;                           \
    pPost##FunctionName = PostCallback;
```

`Avanguard/HoShiMin's API/JitHelper.cpp`:

```cpp
#include "stdafx.h"

#include "JitHelper.h"

AsmJIT::AsmJIT(uint32_t ArchId, uint32_t ArchMode, uint64_t BaseAddress) 
: CodeInfo(ArchId, ArchMode, BaseAddress), CodeBuffer(NULL), CodeSize(0)
{
    CodeHolder.init(CodeInfo);
}

AsmJIT::~AsmJIT() {
    FreeCallable();
}

void AsmJIT::Add(const char* Instruction) {
    (CodeListing.append(Instruction)).append("\n");
}

void AsmJIT::Add(const std::string& Instruction) {
    Add(Instruction.c_str());
}

asmjit::Error AsmJIT::Build() {
    FreeCallable();
    asmjit::x86::Assembler Assembler(&CodeHolder);
    asmtk::AsmParser Parser(&Assembler);
    asmjit::Error Error = Parser.parse(CodeListing.c_str());
    asmjit::CodeBuffer& Buffer = CodeHolder.sectionEntry(0)->buffer();
    CodeBuffer = Buffer.data();
    CodeSize = Buffer.size();
    return Error;
}
```

`Avanguard/HoShiMin's API/JitHelper.h`:

```h
#pragma once

#include <string>
#include <asmtk.h>

#include <Windows.h>

class AsmJIT final {
private:
    asmjit::CodeInfo CodeInfo;
    asmjit::CodeHolder CodeHolder;
    std::string CodeListing;
    void* CodeBuffer;
    void* CallableBuffer;
    size_t CodeSize;
public:
    void* MakeCallable() {
        if (CallableBuffer) return CallableBuffer;
        void* CallableBuffer = VirtualAlloc(NULL, CodeSize, MEM_RESERVE | MEM_COMMIT, PAGE_EXECUTE_READWRITE);
        MoveMemory(CallableBuffer, CodeBuffer, CodeSize);
        return CallableBuffer;
    }

    void FreeCallable() {
        if (!CallableBuffer) return;
        VirtualFree(CallableBuffer, 0, MEM_RELEASE);
        CallableBuffer = NULL;
    }

    AsmJIT(uint32_t archId, uint32_t archMode = 0, uint64_t baseAddress = asmjit::Globals::kNoBaseAddress);
    ~AsmJIT();
    void Add(const char* Instruction);
    void Add(const std::string& Instruction);
    asmjit::Error Build();

    void* GetPtr() { return CodeBuffer; };
    size_t GetSize() { return CodeSize; };
};
```

`Avanguard/HoShiMin's API/StringsAPI.cpp`:

```cpp
#include "stdafx.h"
#include "StringsAPI.h"

template<typename T>
bool SimpleReplaceString(T& Text, const T& Source, const T& Destination) {
    size_t SourceLength = Source.length();
    size_t DestinationLength = Destination.length();
    bool WasReplaced = false;

    for (size_t Index = 0; Index = Text.find(Source, Index), Index != T::npos;) {
        Text.replace(Index, SourceLength, Destination);
        Index += DestinationLength;
        WasReplaced = true;
    }

    return WasReplaced;
}

template<typename T>
bool SelectiveReplaceString(T& Text, const T& Source, const T& Destination) {
    size_t TextLength = Text.length();
    size_t SourceLength = Source.length();
    size_t DestinationLength = Destination.length();
    bool WasReplaced = false;

    T Environment;
    Environment.resize(DestinationLength);
    char* EnvironmentPtr = (char*)Environment.c_str();

    for (size_t Index = 0; Index = Text.find(Source, Index), Index != T::npos;) {
        if (DestinationLength <= TextLength - Index) {
            // Safe, but slower (require <iterator>):
            //Environment.clear();
            //std::copy(Text.begin() + Index, Text.begin() + Index + DestinationLength, std::back_inserter(Environment));
            
            // UNSAFE, but faster:
            Text.copy(EnvironmentPtr, DestinationLength, Index);
            
            if (Environment == Destination) {
                Index += DestinationLength;
                continue;
            }
        }
        Text.replace(Index, SourceLength, Destination);
        Index += DestinationLength;
        TextLength = Text.length();
        WasReplaced = true;
    }
    
    return WasReplaced;
};

template<typename T>
T ReplaceString(
    const T& Text,
    const T& Source,
    const T& Destination,
    bool* WasReplaced,
    REPLACING_METHOD ReplacingMethod
) {
    T Data(Text);

    bool _WasReplaced;

    switch (ReplacingMethod) {
    case METHOD_SIMPLE:
        _WasReplaced = SimpleReplaceString(Data, Source, Destination);
        break;
    case METHOD_SELECTIVE:
        _WasReplaced = SelectiveReplaceString(Data, Source, Destination);
        break;
    default:
        _WasReplaced = false;
    }

    if (WasReplaced) *WasReplaced = _WasReplaced;
    return Data;
}

std::string GetXMLParameter(const std::string& Data, const std::string& Parameter) {
    std::string StartParamBracket("<" + Parameter + ">");
    size_t StartPos = Data.find(StartParamBracket);
    if (StartPos != std::string::npos) {
        size_t EndPos = Data.find("</" + Parameter + ">", StartPos);
        if (EndPos != std::string::npos) {
            size_t ParamStartPosition = StartPos + StartParamBracket.length();
            size_t ParamSize = EndPos - ParamStartPosition;
            
            std::string Result;
            Result.resize(ParamSize);
            Data.copy((char*)Result.c_str(), ParamSize, ParamStartPosition);
            return Result;
        }
    }
    
    return std::string();
}

template<typename T>
T TrimLeft(const T& String, bool TrimTabs) {
    if (String.empty()) return String;
    
    int Length = String.length();
    
    if (TrimTabs) {
        for (int i = 0; i < Length; i++) {
            char Symbol = (char)String[i];
            if ((Symbol != ' ') && (Symbol != (char)0x09)) return String.substr(i);
        }
    } else {
        for (int i = 0; i < Length; i++) {
            if ((char)String[i] != ' ') return String.substr(i);
        }
    }

    return String;
}

template<typename T>
T TrimRight(const T& String, bool TrimTabs) {
    if (String.empty()) return String;

    int Length = String.length() - 1;

    if (TrimTabs) {
        for (int i = Length; i >= 0; i--) {
            char Symbol = (char)String[i];
            if ((Symbol != ' ') && (Symbol != (char)0x09)) return String.substr(0, i + 1);
        }
    } else {
        for (int i = Length; i >= 0; i--) {
            if ((char)String[i] != ' ') return String.substr(0, i + 1);
        }
    }

    return String;
}

template<typename T>
T Trim(const T& String, bool TrimTabs) {
    return TrimLeft(TrimRight(String, TrimTabs), TrimTabs);
}

template <typename T>
T _ExtractFileName(const T& path, size_t slash_pos, size_t backslash_pos) {
    size_t delim_pos;
    if ((backslash_pos != T::npos) && (slash_pos != T::npos)) {
        delim_pos = backslash_pos > slash_pos ? backslash_pos : slash_pos;
    } else {
        delim_pos = backslash_pos != T::npos ? backslash_pos : slash_pos;
    }

    if (delim_pos == T::npos) return path;

    delim_pos++;
    size_t remainder = path.length() - delim_pos;
    if (remainder == 0) return T();

    return path.c_str() + delim_pos;
}

template <>
std::string ExtractFileName<std::string>(const std::string& path) {
    size_t slash_pos = path.rfind("/");
    size_t backslash_pos = path.rfind("\\");
    return _ExtractFileName(path, slash_pos, backslash_pos);
}

template <>
std::wstring ExtractFileName<std::wstring>(const std::wstring& path) {
    size_t slash_pos = path.rfind(L"/");
    size_t backslash_pos = path.rfind(L"\\");
    return _ExtractFileName(path, slash_pos, backslash_pos);
}

template <typename T>
T _ExtractFilePath(const T& path, size_t slash_pos, size_t backslash_pos) {
    size_t delim_pos;
    if ((backslash_pos != T::npos) && (slash_pos != T::npos)) {
        delim_pos = backslash_pos > slash_pos ? backslash_pos : slash_pos;
    } else {
        delim_pos = backslash_pos != T::npos ? backslash_pos : slash_pos;
    }

    if (delim_pos == T::npos) return T();

    delim_pos++;
    size_t remainder = path.length() - delim_pos;
    if (remainder == 0) return T();

    T file_path;
    std::copy(path.begin(), path.begin() + delim_pos, std::back_inserter(file_path));
    return file_path;
}

template <>
std::string ExtractFilePath<std::string>(const std::string& path) {
    size_t slash_pos = path.rfind("/");
    size_t backslash_pos = path.rfind("\\");
    return _ExtractFilePath(path, slash_pos, backslash_pos);
}

template <>
std::wstring ExtractFilePath<std::wstring>(const std::wstring& path) {
    size_t slash_pos = path.rfind(L"/");
    size_t backslash_pos = path.rfind(L"\\");
    return _ExtractFilePath(path, slash_pos, backslash_pos);
}
```

`Avanguard/HoShiMin's API/StringsAPI.h`:

```h
#pragma once

#define _SCL_SECURE_NO_WARNINGS
#define _SILENCE_CXX17_CODECVT_HEADER_DEPRECATION_WARNING

#include <string>
#include <sstream>
#include <codecvt>
#include <algorithm>
#include <iomanip>

/*
// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

* Simple - простой метод :
    Text = aFFabFFabc
        Source = ab
        Destination = abc

        Result = aFFabcFFabcc

// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

* Selective - избирательный метод :
    Text = aFFabFFabc
        Source = ab
        Destination = abc

        Result = aFFabcFFabc - крайняя последовательность такая же, как
        заменяющая строка(abc), поэтому её не трогаем

// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
*/

// Замена подстроки в строке; 
// возвращает true, если была хотя бы одна замена:
template<typename T>
bool SimpleReplaceString(T& Text, const T& Source, const T& Destination);

template<typename T>
bool SelectiveReplaceString(T& Text, const T& Source, const T& Destination);

typedef enum _REPLACING_METHOD {
    METHOD_SIMPLE,
    METHOD_SELECTIVE
} REPLACING_METHOD;

template<typename T>
T ReplaceString(
    const T& Text,
    const T& Source,
    const T& Destination,
    bool* WasReplaced,
    REPLACING_METHOD ReplacingMethod
);

std::string GetXMLParameter(const std::string &Data, const std::string &Parameter);

template <typename T>
inline std::string ValToAnsiStr(const T& Value) {
    std::ostringstream OutputStringStream;
    OutputStringStream << Value;
    return std::string(OutputStringStream.str());
}

template <typename T>
inline std::wstring ValToWideStr(const T& Value) {
    std::wostringstream OutputStringStream;
    OutputStringStream << Value;
    return std::wstring(OutputStringStream.str());
}

template <typename T>
inline std::string ValToAnsiHex(const T& Value, unsigned char Length, bool AddPrefix = true) {
    std::ostringstream OutputStringStream;
    if (AddPrefix)
        OutputStringStream << "0x" << std::uppercase << std::setfill('0') << std::setw(Length) << std::hex << Value;
    else
        OutputStringStream << std::uppercase << std::setfill('0') << std::setw(Length) << std::hex << Value;
    return std::string(OutputStringStream.str());
}

template <typename T>
inline std::wstring ValToWideHex(const T& Value, unsigned char Length, bool AddPrefix = true) {
    std::wostringstream OutputStringStream;
    if (AddPrefix)
        OutputStringStream << L"0x" << std::uppercase << std::setfill(L'0') << std::setw(Length) << std::hex << Value;
    else
        OutputStringStream << std::uppercase << std::setfill(L'0') << std::setw(Length) << std::hex << Value;
    return std::wstring(OutputStringStream.str());
}

template <typename T>
inline std::string FillLeftAnsi(const T& Value, unsigned char Length, char Filler) {
    std::ostringstream OutputStringStream;
    OutputStringStream << std::right << std::setfill(Filler) << std::setw(Length) << Value;
    return std::string(OutputStringStream.str());
}

template <typename T>
inline std::string FillRightAnsi(const T& Value, unsigned char Length, char Filler) {
    std::ostringstream OutputStringStream;
    OutputStringStream << std::left << std::setfill(Filler) << std::setw(Length) << Value;
    return std::string(OutputStringStream.str());
}

template <typename T>
inline std::wstring FillLeftWide(const T& Value, unsigned char Length, wchar_t Filler) {
    std::wostringstream OutputStringStream;
    OutputStringStream << std::right << std::setfill(Filler) << std::setw(Length) << Value;
    return std::wstring(OutputStringStream.str());
}

template <typename T>
inline std::wstring FillRightWide(const T& Value, unsigned char Length, wchar_t Filler) {
    std::wostringstream OutputStringStream;
    OutputStringStream << std::left << std::setfill(Filler) << std::setw(Length) << Value;
    return std::wstring(OutputStringStream.str());
}

template <typename T>
inline T StrToVal(const std::string& String) {
    std::istringstream InputStringStream(String);
    T Result;
    InputStringStream >> Result;
    return Result;
}


inline std::string WideToAnsi(const std::wstring& wide) {
    std::wstring_convert<std::codecvt_utf8_utf16<wchar_t>> converter;
    return converter.to_bytes(wide);
}

inline std::wstring AnsiToWide(const std::string& ansi) {
    std::wstring_convert<std::codecvt_utf8_utf16<wchar_t>> converter;
    return converter.from_bytes(ansi);
}

template <typename T>
inline void LowerCaseRef(T& str) {
    std::transform(str.begin(), str.end(), str.begin(), ::tolower);
}

template <typename T>
inline void UpperCaseRef(T& str) {
    std::transform(str.begin(), str.end(), str.begin(), ::toupper);
}

template <typename T>
inline T LowerCase(T str) {
    std::transform(str.begin(), str.end(), str.begin(), ::tolower);
    return str;
}

template <typename T>
inline T UpperCase(T str) {
    std::transform(str.begin(), str.end(), str.begin(), ::toupper);
    return str;
}

template <typename T>
bool StartsWith(const T& value, const T& beginning) {
    return (beginning.size() <= value.size()) && std::equal(beginning.begin(), beginning.end(), value.begin());
}

template <typename T>
bool EndsWith(const T& value, const T& ending) {
    return (ending.size() <= value.size()) && std::equal(ending.rbegin(), ending.rend(), value.rbegin());
}

template<typename T>
T TrimLeft(const T& String, bool TrimTabs);

template<typename T>
T TrimRight(const T& String, bool TrimTabs);

template<typename T>
T Trim(const T& String, bool TrimTabs);

template <typename T>
T ExtractFileName(const T& path);

template <typename T>
T ExtractFilePath(const T& path);
```

`Avanguard/JNI/include/jni.h`:

```h
/*
 * Copyright (c) 1996, 2013, Oracle and/or its affiliates. All rights reserved.
 * ORACLE PROPRIETARY/CONFIDENTIAL. Use is subject to license terms.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 */

/*
 * We used part of Netscape's Java Runtime Interface (JRI) as the starting
 * point of our design and implementation.
 */

/******************************************************************************
 * Java Runtime Interface
 * Copyright (c) 1996 Netscape Communications Corporation. All rights reserved.
 *****************************************************************************/

#ifndef _JAVASOFT_JNI_H_
#define _JAVASOFT_JNI_H_

#include <stdio.h>
#include <stdarg.h>

/* jni_md.h contains the machine-dependent typedefs for jbyte, jint
   and jlong */

#include "jni_md.h"

#ifdef __cplusplus
extern "C" {
#endif

/*
 * JNI Types
 */

#ifndef JNI_TYPES_ALREADY_DEFINED_IN_JNI_MD_H

typedef unsigned char   jboolean;
typedef unsigned short  jchar;
typedef short           jshort;
typedef float           jfloat;
typedef double          jdouble;

typedef jint            jsize;

#ifdef __cplusplus

class _jobject {};
class _jclass : public _jobject {};
class _jthrowable : public _jobject {};
class _jstring : public _jobject {};
class _jarray : public _jobject {};
class _jbooleanArray : public _jarray {};
class _jbyteArray : public _jarray {};
class _jcharArray : public _jarray {};
class _jshortArray : public _jarray {};
class _jintArray : public _jarray {};
class _jlongArray : public _jarray {};
class _jfloatArray : public _jarray {};
class _jdoubleArray : public _jarray {};
class _jobjectArray : public _jarray {};

typedef _jobject *jobject;
typedef _jclass *jclass;
typedef _jthrowable *jthrowable;
typedef _jstring *jstring;
typedef _jarray *jarray;
typedef _jbooleanArray *jbooleanArray;
typedef _jbyteArray *jbyteArray;
typedef _jcharArray *jcharArray;
typedef _jshortArray *jshortArray;
typedef _jintArray *jintArray;
typedef _jlongArray *jlongArray;
typedef _jfloatArray *jfloatArray;
typedef _jdoubleArray *jdoubleArray;
typedef _jobjectArray *jobjectArray;

#else

struct _jobject;

typedef struct _jobject *jobject;
typedef jobject jclass;
typedef jobject jthrowable;
typedef jobject jstring;
typedef jobject jarray;
typedef jarray jbooleanArray;
typedef jarray jbyteArray;
typedef jarray jcharArray;
typedef jarray jshortArray;
typedef jarray jintArray;
typedef jarray jlongArray;
typedef jarray jfloatArray;
typedef jarray jdoubleArray;
typedef jarray jobjectArray;

#endif

typedef jobject jweak;

typedef union jvalue {
    jboolean z;
    jbyte    b;
    jchar    c;
    jshort   s;
    jint     i;
    jlong    j;
    jfloat   f;
    jdouble  d;
    jobject  l;
} jvalue;

struct _jfieldID;
typedef struct _jfieldID *jfieldID;

struct _jmethodID;
typedef struct _jmethodID *jmethodID;

/* Return values from jobjectRefType */
typedef enum _jobjectType {
     JNIInvalidRefType    = 0,
     JNILocalRefType      = 1,
     JNIGlobalRefType     = 2,
     JNIWeakGlobalRefType = 3
} jobjectRefType;


#endif /* JNI_TYPES_ALREADY_DEFINED_IN_JNI_MD_H */

/*
 * jboolean constants
 */

#define JNI_FALSE 0
#define JNI_TRUE 1

/*
 * possible return values for JNI functions.
 */

#define JNI_OK           0                 /* success */
#define JNI_ERR          (-1)              /* unknown error */
#define JNI_EDETACHED    (-2)              /* thread detached from the VM */
#define JNI_EVERSION     (-3)              /* JNI version error */
#define JNI_ENOMEM       (-4)              /* not enough memory */
#define JNI_EEXIST       (-5)              /* VM already created */
#define JNI_EINVAL       (-6)              /* invalid arguments */

/*
 * used in ReleaseScalarArrayElements
 */

#define JNI_COMMIT 1
#define JNI_ABORT 2

/*
 * used in RegisterNatives to describe native method name, signature,
 * and function pointer.
 */

typedef struct {
    char *name;
    char *signature;
    void *fnPtr;
} JNINativeMethod;

/*
 * JNI Native Method Interface.
 */

struct JNINativeInterface_;

struct JNIEnv_;

#ifdef __cplusplus
typedef JNIEnv_ JNIEnv;
#else
typedef const struct JNINativeInterface_ *JNIEnv;
#endif

/*
 * JNI Invocation Interface.
 */

struct JNIInvokeInterface_;

struct JavaVM_;

#ifdef __cplusplus
typedef JavaVM_ JavaVM;
#else
typedef const struct JNIInvokeInterface_ *JavaVM;
#endif

struct JNINativeInterface_ {
    void *reserved0;
    void *reserved1;
    void *reserved2;

    void *reserved3;
    jint (JNICALL *GetVersion)(JNIEnv *env);

    jclass (JNICALL *DefineClass)
      (JNIEnv *env, const char *name, jobject loader, const jbyte *buf,
       jsize len);
    jclass (JNICALL *FindClass)
      (JNIEnv *env, const char *name);

    jmethodID (JNICALL *FromReflectedMethod)
      (JNIEnv *env, jobject method);
    jfieldID (JNICALL *FromReflectedField)
      (JNIEnv *env, jobject field);

    jobject (JNICALL *ToReflectedMethod)
      (JNIEnv *env, jclass cls, jmethodID methodID, jboolean isStatic);

    jclass (JNICALL *GetSuperclass)
      (JNIEnv *env, jclass sub);
    jboolean (JNICALL *IsAssignableFrom)
      (JNIEnv *env, jclass sub, jclass sup);

    jobject (JNICALL *ToReflectedField)
      (JNIEnv *env, jclass cls, jfieldID fieldID, jboolean isStatic);

    jint (JNICALL *Throw)
      (JNIEnv *env, jthrowable obj);
    jint (JNICALL *ThrowNew)
      (JNIEnv *env, jclass clazz, const char *msg);
    jthrowable (JNICALL *ExceptionOccurred)
      (JNIEnv *env);
    void (JNICALL *ExceptionDescribe)
      (JNIEnv *env);
    void (JNICALL *ExceptionClear)
      (JNIEnv *env);
    void (JNICALL *FatalError)
      (JNIEnv *env, const char *msg);

    jint (JNICALL *PushLocalFrame)
      (JNIEnv *env, jint capacity);
    jobject (JNICALL *PopLocalFrame)
      (JNIEnv *env, jobject result);

    jobject (JNICALL *NewGlobalRef)
      (JNIEnv *env, jobject lobj);
    void (JNICALL *DeleteGlobalRef)
      (JNIEnv *env, jobject gref);
    void (JNICALL *DeleteLocalRef)
      (JNIEnv *env, jobject obj);
    jboolean (JNICALL *IsSameObject)
      (JNIEnv *env, jobject obj1, jobject obj2);
    jobject (JNICALL *NewLocalRef)
      (JNIEnv *env, jobject ref);
    jint (JNICALL *EnsureLocalCapacity)
      (JNIEnv *env, jint capacity);

    jobject (JNICALL *AllocObject)
      (JNIEnv *env, jclass clazz);
    jobject (JNICALL *NewObject)
      (JNIEnv *env, jclass clazz, jmethodID methodID, ...);
    jobject (JNICALL *NewObjectV)
      (JNIEnv *env, jclass clazz, jmethodID methodID, va_list args);
    jobject (JNICALL *NewObjectA)
      (JNIEnv *env, jclass clazz, jmethodID methodID, const jvalue *args);

    jclass (JNICALL *GetObjectClass)
      (JNIEnv *env, jobject obj);
    jboolean (JNICALL *IsInstanceOf)
      (JNIEnv *env, jobject obj, jclass clazz);

    jmethodID (JNICALL *GetMethodID)
      (JNIEnv *env, jclass clazz, const char *name, const char *sig);

    jobject (JNICALL *CallObjectMethod)
      (JNIEnv *env, jobject obj, jmethodID methodID, ...);
    jobject (JNICALL *CallObjectMethodV)
      (JNIEnv *env, jobject obj, jmethodID methodID, va_list args);
    jobject (JNICALL *CallObjectMethodA)
      (JNIEnv *env, jobject obj, jmethodID methodID, const jvalue * args);

    jboolean (JNICALL *CallBooleanMethod)
      (JNIEnv *env, jobject obj, jmethodID methodID, ...);
    jboolean (JNICALL *CallBooleanMethodV)
      (JNIEnv *env, jobject obj, jmethodID methodID, va_list args);
    jboolean (JNICALL *CallBooleanMethodA)
      (JNIEnv *env, jobject obj, jmethodID methodID, const jvalue * args);

    jbyte (JNICALL *CallByteMethod)
      (JNIEnv *env, jobject obj, jmethodID methodID, ...);
    jbyte (JNICALL *CallByteMethodV)
      (JNIEnv *env, jobject obj, jmethodID methodID, va_list args);
    jbyte (JNICALL *CallByteMethodA)
      (JNIEnv *env, jobject obj, jmethodID methodID, const jvalue *args);

    jchar (JNICALL *CallCharMethod)
      (JNIEnv *env, jobject obj, jmethodID methodID, ...);
    jchar (JNICALL *CallCharMethodV)
      (JNIEnv *env, jobject obj, jmethodID methodID, va_list args);
    jchar (JNICALL *CallCharMethodA)
      (JNIEnv *env, jobject obj, jmethodID methodID, const jvalue *args);

    jshort (JNICALL *CallShortMethod)
      (JNIEnv *env, jobject obj, jmethodID methodID, ...);
    jshort (JNICALL *CallShortMethodV)
      (JNIEnv *env, jobject obj, jmethodID methodID, va_list args);
    jshort (JNICALL *CallShortMethodA)
      (JNIEnv *env, jobject obj, jmethodID methodID, const jvalue *args);

    jint (JNICALL *CallIntMethod)
      (JNIEnv *env, jobject obj, jmethodID methodID, ...);
    jint (JNICALL *CallIntMethodV)
      (JNIEnv *env, jobject obj, jmethodID methodID, va_list args);
    jint (JNICALL *CallIntMethodA)
      (JNIEnv *env, jobject obj, jmethodID methodID, const jvalue *args);

    jlong (JNICALL *CallLongMethod)
      (JNIEnv *env, jobject obj, jmethodID methodID, ...);
    jlong (JNICALL *CallLongMethodV)
      (JNIEnv *env, jobject obj, jmethodID methodID, va_list args);
    jlong (JNICALL *CallLongMethodA)
      (JNIEnv *env, jobject obj, jmethodID methodID, const jvalue *args);

    jfloat (JNICALL *CallFloatMethod)
      (JNIEnv *env, jobject obj, jmethodID methodID, ...);
    jfloat (JNICALL *CallFloatMethodV)
      (JNIEnv *env, jobject obj, jmethodID methodID, va_list args);
    jfloat (JNICALL *CallFloatMethodA)
      (JNIEnv *env, jobject obj, jmethodID methodID, const jvalue *args);

    jdouble (JNICALL *CallDoubleMethod)
      (JNIEnv *env, jobject obj, jmethodID methodID, ...);
    jdouble (JNICALL *CallDoubleMethodV)
      (JNIEnv *env, jobject obj, jmethodID methodID, va_list args);
    jdouble (JNICALL *CallDoubleMethodA)
      (JNIEnv *env, jobject obj, jmethodID methodID, const jvalue *args);

    void (JNICALL *CallVoidMethod)
      (JNIEnv *env, jobject obj, jmethodID methodID, ...);
    void (JNICALL *CallVoidMethodV)
      (JNIEnv *env, jobject obj, jmethodID methodID, va_list args);
    void (JNICALL *CallVoidMethodA)
      (JNIEnv *env, jobject obj, jmethodID methodID, const jvalue * args);

    jobject (JNICALL *CallNonvirtualObjectMethod)
      (JNIEnv *env, jobject obj, jclass clazz, jmethodID methodID, ...);
    jobject (JNICALL *CallNonvirtualObjectMethodV)
      (JNIEnv *env, jobject obj, jclass clazz, jmethodID methodID,
       va_list args);
    jobject (JNICALL *CallNonvirtualObjectMethodA)
      (JNIEnv *env, jobject obj, jclass clazz, jmethodID methodID,
       const jvalue * args);

    jboolean (JNICALL *CallNonvirtualBooleanMethod)
      (JNIEnv *env, jobject obj, jclass clazz, jmethodID methodID, ...);
    jboolean (JNICALL *CallNonvirtualBooleanMethodV)
      (JNIEnv *env, jobject obj, jclass clazz, jmethodID methodID,
       va_list args);
    jboolean (JNICALL *CallNonvirtualBooleanMethodA)
      (JNIEnv *env, jobject obj, jclass clazz, jmethodID methodID,
       const jvalue * args);

    jbyte (JNICALL *CallNonvirtualByteMethod)
      (JNIEnv *env, jobject obj, jclass clazz, jmethodID methodID, ...);
    jbyte (JNICALL *CallNonvirtualByteMethodV)
      (JNIEnv *env, jobject obj, jclass clazz, jmethodID methodID,
       va_list args);
    jbyte (JNICALL *CallNonvirtualByteMethodA)
      (JNIEnv *env, jobject obj, jclass clazz, jmethodID methodID,
       const jvalue *args);

    jchar (JNICALL *CallNonvirtualCharMethod)
      (JNIEnv *env, jobject obj, jclass clazz, jmethodID methodID, ...);
    jchar (JNICALL *CallNonvirtualCharMethodV)
      (JNIEnv *env, jobject obj, jclass clazz, jmethodID methodID,
       va_list args);
    jchar (JNICALL *CallNonvirtualCharMethodA)
      (JNIEnv *env, jobject obj, jclass clazz, jmethodID methodID,
       const jvalue *args);

    jshort (JNICALL *CallNonvirtualShortMethod)
      (JNIEnv *env, jobject obj, jclass clazz, jmethodID methodID, ...);
    jshort (JNICALL *CallNonvirtualShortMethodV)
      (JNIEnv *env, jobject obj, jclass clazz, jmethodID methodID,
       va_list args);
    jshort (JNICALL *CallNonvirtualShortMethodA)
      (JNIEnv *env, jobject obj, jclass clazz, jmethodID methodID,
       const jvalue *args);

    jint (JNICALL *CallNonvirtualIntMethod)
      (JNIEnv *env, jobject obj, jclass clazz, jmethodID methodID, ...);
    jint (JNICALL *CallNonvirtualIntMethodV)
      (JNIEnv *env, jobject obj, jclass clazz, jmethodID methodID,
       va_list args);
    jint (JNICALL *CallNonvirtualIntMethodA)
      (JNIEnv *env, jobject obj, jclass clazz, jmethodID methodID,
       const jvalue *args);

    jlong (JNICALL *CallNonvirtualLongMethod)
      (JNIEnv *env, jobject obj, jclass clazz, jmethodID methodID, ...);
    jlong (JNICALL *CallNonvirtualLongMethodV)
      (JNIEnv *env, jobject obj, jclass clazz, jmethodID methodID,
       va_list args);
    jlong (JNICALL *CallNonvirtualLongMethodA)
      (JNIEnv *env, jobject obj, jclass clazz, jmethodID methodID,
       const jvalue *args);

    jfloat (JNICALL *CallNonvirtualFloatMethod)
      (JNIEnv *env, jobject obj, jclass clazz, jmethodID methodID, ...);
    jfloat (JNICALL *CallNonvirtualFloatMethodV)
      (JNIEnv *env, jobject obj, jclass clazz, jmethodID methodID,
       va_list args);
    jfloat (JNICALL *CallNonvirtualFloatMethodA)
      (JNIEnv *env, jobject obj, jclass clazz, jmethodID methodID,
       const jvalue *args);

    jdouble (JNICALL *CallNonvirtualDoubleMethod)
      (JNIEnv *env, jobject obj, jclass clazz, jmethodID methodID, ...);
    jdouble (JNICALL *CallNonvirtualDoubleMethodV)
      (JNIEnv *env, jobject obj, jclass clazz, jmethodID methodID,
       va_list args);
    jdouble (JNICALL *CallNonvirtualDoubleMethodA)
      (JNIEnv *env, jobject obj, jclass clazz, jmethodID methodID,
       const jvalue *args);

    void (JNICALL *CallNonvirtualVoidMethod)
      (JNIEnv *env, jobject obj, jclass clazz, jmethodID methodID, ...);
    void (JNICALL *CallNonvirtualVoidMethodV)
      (JNIEnv *env, jobject obj, jclass clazz, jmethodID methodID,
       va_list args);
    void (JNICALL *CallNonvirtualVoidMethodA)
      (JNIEnv *env, jobject obj, jclass clazz, jmethodID methodID,
       const jvalue * args);

    jfieldID (JNICALL *GetFieldID)
      (JNIEnv *env, jclass clazz, const char *name, const char *sig);

    jobject (JNICALL *GetObjectField)
      (JNIEnv *env, jobject obj, jfieldID fieldID);
    jboolean (JNICALL *GetBooleanField)
      (JNIEnv *env, jobject obj, jfieldID fieldID);
    jbyte (JNICALL *GetByteField)
      (JNIEnv *env, jobject obj, jfieldID fieldID);
    jchar (JNICALL *GetCharField)
      (JNIEnv *env, jobject obj, jfieldID fieldID);
    jshort (JNICALL *GetShortField)
      (JNIEnv *env, jobject obj, jfieldID fieldID);
    jint (JNICALL *GetIntField)
      (JNIEnv *env, jobject obj, jfieldID fieldID);
    jlong (JNICALL *GetLongField)
      (JNIEnv *env, jobject obj, jfieldID fieldID);
    jfloat (JNICALL *GetFloatField)
      (JNIEnv *env, jobject obj, jfieldID fieldID);
    jdouble (JNICALL *GetDoubleField)
      (JNIEnv *env, jobject obj, jfieldID fieldID);

    void (JNICALL *SetObjectField)
      (JNIEnv *env, jobject obj, jfieldID fieldID, jobject val);
    void (JNICALL *SetBooleanField)
      (JNIEnv *env, jobject obj, jfieldID fieldID, jboolean val);
    void (JNICALL *SetByteField)
      (JNIEnv *env, jobject obj, jfieldID fieldID, jbyte val);
    void (JNICALL *SetCharField)
      (JNIEnv *env, jobject obj, jfieldID fieldID, jchar val);
    void (JNICALL *SetShortField)
      (JNIEnv *env, jobject obj, jfieldID fieldID, jshort val);
    void (JNICALL *SetIntField)
      (JNIEnv *env, jobject obj, jfieldID fieldID, jint val);
    void (JNICALL *SetLongField)
      (JNIEnv *env, jobject obj, jfieldID fieldID, jlong val);
    void (JNICALL *SetFloatField)
      (JNIEnv *env, jobject obj, jfieldID fieldID, jfloat val);
    void (JNICALL *SetDoubleField)
      (JNIEnv *env, jobject obj, jfieldID fieldID, jdouble val);

    jmethodID (JNICALL *GetStaticMethodID)
      (JNIEnv *env, jclass clazz, const char *name, const char *sig);

    jobject (JNICALL *CallStaticObjectMethod)
      (JNIEnv *env, jclass clazz, jmethodID methodID, ...);
    jobject (JNICALL *CallStaticObjectMethodV)
      (JNIEnv *env, jclass clazz, jmethodID methodID, va_list args);
    jobject (JNICALL *CallStaticObjectMethodA)
      (JNIEnv *env, jclass clazz, jmethodID methodID, const jvalue *args);

    jboolean (JNICALL *CallStaticBooleanMethod)
      (JNIEnv *env, jclass clazz, jmethodID methodID, ...);
    jboolean (JNICALL *CallStaticBooleanMethodV)
      (JNIEnv *env, jclass clazz, jmethodID methodID, va_list args);
    jboolean (JNICALL *CallStaticBooleanMethodA)
      (JNIEnv *env, jclass clazz, jmethodID methodID, const jvalue *args);

    jbyte (JNICALL *CallStaticByteMethod)
      (JNIEnv *env, jclass clazz, jmethodID methodID, ...);
    jbyte (JNICALL *CallStaticByteMethodV)
      (JNIEnv *env, jclass clazz, jmethodID methodID, va_list args);
    jbyte (JNICALL *CallStaticByteMethodA)
      (JNIEnv *env, jclass clazz, jmethodID methodID, const jvalue *args);

    jchar (JNICALL *CallStaticCharMethod)
      (JNIEnv *env, jclass clazz, jmethodID methodID, ...);
    jchar (JNICALL *CallStaticCharMethodV)
      (JNIEnv *env, jclass clazz, jmethodID methodID, va_list args);
    jchar (JNICALL *CallStaticCharMethodA)
      (JNIEnv *env, jclass clazz, jmethodID methodID, const jvalue *args);

    jshort (JNICALL *CallStaticShortMethod)
      (JNIEnv *env, jclass clazz, jmethodID methodID, ...);
    jshort (JNICALL *CallStaticShortMethodV)
      (JNIEnv *env, jclass clazz, jmethodID methodID, va_list args);
    jshort (JNICALL *CallStaticShortMethodA)
      (JNIEnv *env, jclass clazz, jmethodID methodID, const jvalue *args);

    jint (JNICALL *CallStaticIntMethod)
      (JNIEnv *env, jclass clazz, jmethodID methodID, ...);
    jint (JNICALL *CallStaticIntMethodV)
      (JNIEnv *env, jclass clazz, jmethodID methodID, va_list args);
    jint (JNICALL *CallStaticIntMethodA)
      (JNIEnv *env, jclass clazz, jmethodID methodID, const jvalue *args);

    jlong (JNICALL *CallStaticLongMethod)
      (JNIEnv *env, jclass clazz, jmethodID methodID, ...);
    jlong (JNICALL *CallStaticLongMethodV)
      (JNIEnv *env, jclass clazz, jmethodID methodID, va_list args);
    jlong (JNICALL *CallStaticLongMethodA)
      (JNIEnv *env, jclass clazz, jmethodID methodID, const jvalue *args);

    jfloat (JNICALL *CallStaticFloatMethod)
      (JNIEnv *env, jclass clazz, jmethodID methodID, ...);
    jfloat (JNICALL *CallStaticFloatMethodV)
      (JNIEnv *env, jclass clazz, jmethodID methodID, va_list args);
    jfloat (JNICALL *CallStaticFloatMethodA)
      (JNIEnv *env, jclass clazz, jmethodID methodID, const jvalue *args);

    jdouble (JNICALL *CallStaticDoubleMethod)
      (JNIEnv *env, jclass clazz, jmethodID methodID, ...);
    jdouble (JNICALL *CallStaticDoubleMethodV)
      (JNIEnv *env, jclass clazz, jmethodID methodID, va_list args);
    jdouble (JNICALL *CallStaticDoubleMethodA)
      (JNIEnv *env, jclass clazz, jmethodID methodID, const jvalue *args);

    void (JNICALL *CallStaticVoidMethod)
      (JNIEnv *env, jclass cls, jmethodID methodID, ...);
    void (JNICALL *CallStaticVoidMethodV)
      (JNIEnv *env, jclass cls, jmethodID methodID, va_list args);
    void (JNICALL *CallStaticVoidMethodA)
      (JNIEnv *env, jclass cls, jmethodID methodID, const jvalue * args);

    jfieldID (JNICALL *GetStaticFieldID)
      (JNIEnv *env, jclass clazz, const char *name, const char *sig);
    jobject (JNICALL *GetStaticObjectField)
      (JNIEnv *env, jclass clazz, jfieldID fieldID);
    jboolean (JNICALL *GetStaticBooleanField)
      (JNIEnv *env, jclass clazz, jfieldID fieldID);
    jbyte (JNICALL *GetStaticByteField)
      (JNIEnv *env, jclass clazz, jfieldID fieldID);
    jchar (JNICALL *GetStaticCharField)
      (JNIEnv *env, jclass clazz, jfieldID fieldID);
    jshort (JNICALL *GetStaticShortField)
      (JNIEnv *env, jclass clazz, jfieldID fieldID);
    jint (JNICALL *GetStaticIntField)
      (JNIEnv *env, jclass clazz, jfieldID fieldID);
    jlong (JNICALL *GetStaticLongField)
      (JNIEnv *env, jclass clazz, jfieldID fieldID);
    jfloat (JNICALL *GetStaticFloatField)
      (JNIEnv *env, jclass clazz, jfieldID fieldID);
    jdouble (JNICALL *GetStaticDoubleField)
      (JNIEnv *env, jclass clazz, jfieldID fieldID);

    void (JNICALL *SetStaticObjectField)
      (JNIEnv *env, jclass clazz, jfieldID fieldID, jobject value);
    void (JNICALL *SetStaticBooleanField)
      (JNIEnv *env, jclass clazz, jfieldID fieldID, jboolean value);
    void (JNICALL *SetStaticByteField)
      (JNIEnv *env, jclass clazz, jfieldID fieldID, jbyte value);
    void (JNICALL *SetStaticCharField)
      (JNIEnv *env, jclass clazz, jfieldID fieldID, jchar value);
    void (JNICALL *SetStaticShortField)
      (JNIEnv *env, jclass clazz, jfieldID fieldID, jshort value);
    void (JNICALL *SetStaticIntField)
      (JNIEnv *env, jclass clazz, jfieldID fieldID, jint value);
    void (JNICALL *SetStaticLongField)
      (JNIEnv *env, jclass clazz, jfieldID fieldID, jlong value);
    void (JNICALL *SetStaticFloatField)
      (JNIEnv *env, jclass clazz, jfieldID fieldID, jfloat value);
    void (JNICALL *SetStaticDoubleField)
      (JNIEnv *env, jclass clazz, jfieldID fieldID, jdouble value);

    jstring (JNICALL *NewString)
      (JNIEnv *env, const jchar *unicode, jsize len);
    jsize (JNICALL *GetStringLength)
      (JNIEnv *env, jstring str);
    const jchar *(JNICALL *GetStringChars)
      (JNIEnv *env, jstring str, jboolean *isCopy);
    void (JNICALL *ReleaseStringChars)
      (JNIEnv *env, jstring str, const jchar *chars);

    jstring (JNICALL *NewStringUTF)
      (JNIEnv *env, const char *utf);
    jsize (JNICALL *GetStringUTFLength)
      (JNIEnv *env, jstring str);
    const char* (JNICALL *GetStringUTFChars)
      (JNIEnv *env, jstring str, jboolean *isCopy);
    void (JNICALL *ReleaseStringUTFChars)
      (JNIEnv *env, jstring str, const char* chars);


    jsize (JNICALL *GetArrayLength)
      (JNIEnv *env, jarray array);

    jobjectArray (JNICALL *NewObjectArray)
      (JNIEnv *env, jsize len, jclass clazz, jobject init);
    jobject (JNICALL *GetObjectArrayElement)
      (JNIEnv *env, jobjectArray array, jsize index);
    void (JNICALL *SetObjectArrayElement)
      (JNIEnv *env, jobjectArray array, jsize index, jobject val);

    jbooleanArray (JNICALL *NewBooleanArray)
      (JNIEnv *env, jsize len);
    jbyteArray (JNICALL *NewByteArray)
      (JNIEnv *env, jsize len);
    jcharArray (JNICALL *NewCharArray)
      (JNIEnv *env, jsize len);
    jshortArray (JNICALL *NewShortArray)
      (JNIEnv *env, jsize len);
    jintArray (JNICALL *NewIntArray)
      (JNIEnv *env, jsize len);
    jlongArray (JNICALL *NewLongArray)
      (JNIEnv *env, jsize len);
    jfloatArray (JNICALL *NewFloatArray)
      (JNIEnv *env, jsize len);
    jdoubleArray (JNICALL *NewDoubleArray)
      (JNIEnv *env, jsize len);

    jboolean * (JNICALL *GetBooleanArrayElements)
      (JNIEnv *env, jbooleanArray array, jboolean *isCopy);
    jbyte * (JNICALL *GetByteArrayElements)
      (JNIEnv *env, jbyteArray array, jboolean *isCopy);
    jchar * (JNICALL *GetCharArrayElements)
      (JNIEnv *env, jcharArray array, jboolean *isCopy);
    jshort * (JNICALL *GetShortArrayElements)
      (JNIEnv *env, jshortArray array, jboolean *isCopy);
    jint * (JNICALL *GetIntArrayElements)
      (JNIEnv *env, jintArray array, jboolean *isCopy);
    jlong * (JNICALL *GetLongArrayElements)
      (JNIEnv *env, jlongArray array, jboolean *isCopy);
    jfloat * (JNICALL *GetFloatArrayElements)
      (JNIEnv *env, jfloatArray array, jboolean *isCopy);
    jdouble * (JNICALL *GetDoubleArrayElements)
      (JNIEnv *env, jdoubleArray array, jboolean *isCopy);

    void (JNICALL *ReleaseBooleanArrayElements)
      (JNIEnv *env, jbooleanArray array, jboolean *elems, jint mode);
    void (JNICALL *ReleaseByteArrayElements)
      (JNIEnv *env, jbyteArray array, jbyte *elems, jint mode);
    void (JNICALL *ReleaseCharArrayElements)
      (JNIEnv *env, jcharArray array, jchar *elems, jint mode);
    void (JNICALL *ReleaseShortArrayElements)
      (JNIEnv *env, jshortArray array, jshort *elems, jint mode);
    void (JNICALL *ReleaseIntArrayElements)
      (JNIEnv *env, jintArray array, jint *elems, jint mode);
    void (JNICALL *ReleaseLongArrayElements)
      (JNIEnv *env, jlongArray array, jlong *elems, jint mode);
    void (JNICALL *ReleaseFloatArrayElements)
      (JNIEnv *env, jfloatArray array, jfloat *elems, jint mode);
    void (JNICALL *ReleaseDoubleArrayElements)
      (JNIEnv *env, jdoubleArray array, jdouble *elems, jint mode);

    void (JNICALL *GetBooleanArrayRegion)
      (JNIEnv *env, jbooleanArray array, jsize start, jsize l, jboolean *buf);
    void (JNICALL *GetByteArrayRegion)
      (JNIEnv *env, jbyteArray array, jsize start, jsize len, jbyte *buf);
    void (JNICALL *GetCharArrayRegion)
      (JNIEnv *env, jcharArray array, jsize start, jsize len, jchar *buf);
    void (JNICALL *GetShortArrayRegion)
      (JNIEnv *env, jshortArray array, jsize start, jsize len, jshort *buf);
    void (JNICALL *GetIntArrayRegion)
      (JNIEnv *env, jintArray array, jsize start, jsize len, jint *buf);
    void (JNICALL *GetLongArrayRegion)
      (JNIEnv *env, jlongArray array, jsize start, jsize len, jlong *buf);
    void (JNICALL *GetFloatArrayRegion)
      (JNIEnv *env, jfloatArray array, jsize start, jsize len, jfloat *buf);
    void (JNICALL *GetDoubleArrayRegion)
      (JNIEnv *env, jdoubleArray array, jsize start, jsize len, jdouble *buf);

    void (JNICALL *SetBooleanArrayRegion)
      (JNIEnv *env, jbooleanArray array, jsize start, jsize l, const jboolean *buf);
    void (JNICALL *SetByteArrayRegion)
      (JNIEnv *env, jbyteArray array, jsize start, jsize len, const jbyte *buf);
    void (JNICALL *SetCharArrayRegion)
      (JNIEnv *env, jcharArray array, jsize start, jsize len, const jchar *buf);
    void (JNICALL *SetShortArrayRegion)
      (JNIEnv *env, jshortArray array, jsize start, jsize len, const jshort *buf);
    void (JNICALL *SetIntArrayRegion)
      (JNIEnv *env, jintArray array, jsize start, jsize len, const jint *buf);
    void (JNICALL *SetLongArrayRegion)
      (JNIEnv *env, jlongArray array, jsize start, jsize len, const jlong *buf);
    void (JNICALL *SetFloatArrayRegion)
      (JNIEnv *env, jfloatArray array, jsize start, jsize len, const jfloat *buf);
    void (JNICALL *SetDoubleArrayRegion)
      (JNIEnv *env, jdoubleArray array, jsize start, jsize len, const jdouble *buf);

    jint (JNICALL *RegisterNatives)
      (JNIEnv *env, jclass clazz, const JNINativeMethod *methods,
       jint nMethods);
    jint (JNICALL *UnregisterNatives)
      (JNIEnv *env, jclass clazz);

    jint (JNICALL *MonitorEnter)
      (JNIEnv *env, jobject obj);
    jint (JNICALL *MonitorExit)
      (JNIEnv *env, jobject obj);

    jint (JNICALL *GetJavaVM)
      (JNIEnv *env, JavaVM **vm);

    void (JNICALL *GetStringRegion)
      (JNIEnv *env, jstring str, jsize start, jsize len, jchar *buf);
    void (JNICALL *GetStringUTFRegion)
      (JNIEnv *env, jstring str, jsize start, jsize len, char *buf);

    void * (JNICALL *GetPrimitiveArrayCritical)
      (JNIEnv *env, jarray array, jboolean *isCopy);
    void (JNICALL *ReleasePrimitiveArrayCritical)
      (JNIEnv *env, jarray array, void *carray, jint mode);

    const jchar * (JNICALL *GetStringCritical)
      (JNIEnv *env, jstring string, jboolean *isCopy);
    void (JNICALL *ReleaseStringCritical)
      (JNIEnv *env, jstring string, const jchar *cstring);

    jweak (JNICALL *NewWeakGlobalRef)
       (JNIEnv *env, jobject obj);
    void (JNICALL *DeleteWeakGlobalRef)
       (JNIEnv *env, jweak ref);

    jboolean (JNICALL *ExceptionCheck)
       (JNIEnv *env);

    jobject (JNICALL *NewDirectByteBuffer)
       (JNIEnv* env, void* address, jlong capacity);
    void* (JNICALL *GetDirectBufferAddress)
       (JNIEnv* env, jobject buf);
    jlong (JNICALL *GetDirectBufferCapacity)
       (JNIEnv* env, jobject buf);

    /* New JNI 1.6 Features */

    jobjectRefType (JNICALL *GetObjectRefType)
        (JNIEnv* env, jobject obj);
};

/*
 * We use inlined functions for C++ so that programmers can write:
 *
 *    env->FindClass("java/lang/String")
 *
 * in C++ rather than:
 *
 *    (*env)->FindClass(env, "java/lang/String")
 *
 * in C.
 */

struct JNIEnv_ {
    const struct JNINativeInterface_ *functions;
#ifdef __cplusplus

    jint GetVersion() {
        return functions->GetVersion(this);
    }
    jclass DefineClass(const char *name, jobject loader, const jbyte *buf,
                       jsize len) {
        return functions->DefineClass(this, name, loader, buf, len);
    }
    jclass FindClass(const char *name) {
        return functions->FindClass(this, name);
    }
    jmethodID FromReflectedMethod(jobject method) {
        return functions->FromReflectedMethod(this,method);
    }
    jfieldID FromReflectedField(jobject field) {
        return functions->FromReflectedField(this,field);
    }

    jobject ToReflectedMethod(jclass cls, jmethodID methodID, jboolean isStatic) {
        return functions->ToReflectedMethod(this, cls, methodID, isStatic);
    }

    jclass GetSuperclass(jclass sub) {
        return functions->GetSuperclass(this, sub);
    }
    jboolean IsAssignableFrom(jclass sub, jclass sup) {
        return functions->IsAssignableFrom(this, sub, sup);
    }

    jobject ToReflectedField(jclass cls, jfieldID fieldID, jboolean isStatic) {
        return functions->ToReflectedField(this,cls,fieldID,isStatic);
    }

    jint Throw(jthrowable obj) {
        return functions->Throw(this, obj);
    }
    jint ThrowNew(jclass clazz, const char *msg) {
        return functions->ThrowNew(this, clazz, msg);
    }
    jthrowable ExceptionOccurred() {
        return functions->ExceptionOccurred(this);
    }
    void ExceptionDescribe() {
        functions->ExceptionDescribe(this);
    }
    void ExceptionClear() {
        functions->ExceptionClear(this);
    }
    void FatalError(const char *msg) {
        functions->FatalError(this, msg);
    }

    jint PushLocalFrame(jint capacity) {
        return functions->PushLocalFrame(this,capacity);
    }
    jobject PopLocalFrame(jobject result) {
        return functions->PopLocalFrame(this,result);
    }

    jobject NewGlobalRef(jobject lobj) {
        return functions->NewGlobalRef(this,lobj);
    }
    void DeleteGlobalRef(jobject gref) {
        functions->DeleteGlobalRef(this,gref);
    }
    void DeleteLocalRef(jobject obj) {
        functions->DeleteLocalRef(this, obj);
    }

    jboolean IsSameObject(jobject obj1, jobject obj2) {
        return functions->IsSameObject(this,obj1,obj2);
    }

    jobject NewLocalRef(jobject ref) {
        return functions->NewLocalRef(this,ref);
    }
    jint EnsureLocalCapacity(jint capacity) {
        return functions->EnsureLocalCapacity(this,capacity);
    }

    jobject AllocObject(jclass clazz) {
        return functions->AllocObject(this,clazz);
    }
    jobject NewObject(jclass clazz, jmethodID methodID, ...) {
        va_list args;
        jobject result;
        va_start(args, methodID);
        result = functions->NewObjectV(this,clazz,methodID,args);
        va_end(args);
        return result;
    }
    jobject NewObjectV(jclass clazz, jmethodID methodID,
                       va_list args) {
        return functions->NewObjectV(this,clazz,methodID,args);
    }
    jobject NewObjectA(jclass clazz, jmethodID methodID,
                       const jvalue *args) {
        return functions->NewObjectA(this,clazz,methodID,args);
    }

    jclass GetObjectClass(jobject obj) {
        return functions->GetObjectClass(this,obj);
    }
    jboolean IsInstanceOf(jobject obj, jclass clazz) {
        return functions->IsInstanceOf(this,obj,clazz);
    }

    jmethodID GetMethodID(jclass clazz, const char *name,
                          const char *sig) {
        return functions->GetMethodID(this,clazz,name,sig);
    }

    jobject CallObjectMethod(jobject obj, jmethodID methodID, ...) {
        va_list args;
        jobject result;
        va_start(args,methodID);
        result = functions->CallObjectMethodV(this,obj,methodID,args);
        va_end(args);
        return result;
    }
    jobject CallObjectMethodV(jobject obj, jmethodID methodID,
                        va_list args) {
        return functions->CallObjectMethodV(this,obj,methodID,args);
    }
    jobject CallObjectMethodA(jobject obj, jmethodID methodID,
                        const jvalue * args) {
        return functions->CallObjectMethodA(this,obj,methodID,args);
    }

    jboolean CallBooleanMethod(jobject obj,
                               jmethodID methodID, ...) {
        va_list args;
        jboolean result;
        va_start(args,methodID);
        result = functions->CallBooleanMethodV(this,obj,methodID,args);
        va_end(args);
        return result;
    }
    jboolean CallBooleanMethodV(jobject obj, jmethodID methodID,
                                va_list args) {
        return functions->CallBooleanMethodV(this,obj,methodID,args);
    }
    jboolean CallBooleanMethodA(jobject obj, jmethodID methodID,
                                const jvalue * args) {
        return functions->CallBooleanMethodA(this,obj,methodID, args);
    }

    jbyte CallByteMethod(jobject obj, jmethodID methodID, ...) {
        va_list args;
        jbyte result;
        va_start(args,methodID);
        result = functions->CallByteMethodV(this,obj,methodID,args);
        va_end(args);
        return result;
    }
    jbyte CallByteMethodV(jobject obj, jmethodID methodID,
                          va_list args) {
        return functions->CallByteMethodV(this,obj,methodID,args);
    }
    jbyte CallByteMethodA(jobject obj, jmethodID methodID,
                          const jvalue * args) {
        return functions->CallByteMethodA(this,obj,methodID,args);
    }

    jchar CallCharMethod(jobject obj, jmethodID methodID, ...) {
        va_list args;
        jchar result;
        va_start(args,methodID);
        result = functions->CallCharMethodV(this,obj,methodID,args);
        va_end(args);
        return result;
    }
    jchar CallCharMethodV(jobject obj, jmethodID methodID,
                          va_list args) {
        return functions->CallCharMethodV(this,obj,methodID,args);
    }
    jchar CallCharMethodA(jobject obj, jmethodID methodID,
                          const jvalue * args) {
        return functions->CallCharMethodA(this,obj,methodID,args);
    }

    jshort CallShortMethod(jobject obj, jmethodID methodID, ...) {
        va_list args;
        jshort result;
        va_start(args,methodID);
        result = functions->CallShortMethodV(this,obj,methodID,args);
        va_end(args);
        return result;
    }
    jshort CallShortMethodV(jobject obj, jmethodID methodID,
                            va_list args) {
        return functions->CallShortMethodV(this,obj,methodID,args);
    }
    jshort CallShortMethodA(jobject obj, jmethodID methodID,
                            const jvalue * args) {
        return functions->CallShortMethodA(this,obj,methodID,args);
    }

    jint CallIntMethod(jobject obj, jmethodID methodID, ...) {
        va_list args;
        jint result;
        va_start(args,methodID);
        result = functions->CallIntMethodV(this,obj,methodID,args);
        va_end(args);
        return result;
    }
    jint CallIntMethodV(jobject obj, jmethodID methodID,
                        va_list args) {
        return functions->CallIntMethodV(this,obj,methodID,args);
    }
    jint CallIntMethodA(jobject obj, jmethodID methodID,
                        const jvalue * args) {
        return functions->CallIntMethodA(this,obj,methodID,args);
    }

    jlong CallLongMethod(jobject obj, jmethodID methodID, ...) {
        va_list args;
        jlong result;
        va_start(args,methodID);
        result = functions->CallLongMethodV(this,obj,methodID,args);
        va_end(args);
        return result;
    }
    jlong CallLongMethodV(jobject obj, jmethodID methodID,
                          va_list args) {
        return functions->CallLongMethodV(this,obj,methodID,args);
    }
    jlong CallLongMethodA(jobject obj, jmethodID methodID,
                          const jvalue * args) {
        return functions->CallLongMethodA(this,obj,methodID,args);
    }

    jfloat CallFloatMethod(jobject obj, jmethodID methodID, ...) {
        va_list args;
        jfloat result;
        va_start(args,methodID);
        result = functions->CallFloatMethodV(this,obj,methodID,args);
        va_end(args);
        return result;
    }
    jfloat CallFloatMethodV(jobject obj, jmethodID methodID,
                            va_list args) {
        return functions->CallFloatMethodV(this,obj,methodID,args);
    }
    jfloat CallFloatMethodA(jobject obj, jmethodID methodID,
                            const jvalue * args) {
        return functions->CallFloatMethodA(this,obj,methodID,args);
    }

    jdouble CallDoubleMethod(jobject obj, jmethodID methodID, ...) {
        va_list args;
        jdouble result;
        va_start(args,methodID);
        result = functions->CallDoubleMethodV(this,obj,methodID,args);
        va_end(args);
        return result;
    }
    jdouble CallDoubleMethodV(jobject obj, jmethodID methodID,
                        va_list args) {
        return functions->CallDoubleMethodV(this,obj,methodID,args);
    }
    jdouble CallDoubleMethodA(jobject obj, jmethodID methodID,
                        const jvalue * args) {
        return functions->CallDoubleMethodA(this,obj,methodID,args);
    }

    void CallVoidMethod(jobject obj, jmethodID methodID, ...) {
        va_list args;
        va_start(args,methodID);
        functions->CallVoidMethodV(this,obj,methodID,args);
        va_end(args);
    }
    void CallVoidMethodV(jobject obj, jmethodID methodID,
                         va_list args) {
        functions->CallVoidMethodV(this,obj,methodID,args);
    }
    void CallVoidMethodA(jobject obj, jmethodID methodID,
                         const jvalue * args) {
        functions->CallVoidMethodA(this,obj,methodID,args);
    }

    jobject CallNonvirtualObjectMethod(jobject obj, jclass clazz,
                                       jmethodID methodID, ...) {
        va_list args;
        jobject result;
        va_start(args,methodID);
        result = functions->CallNonvirtualObjectMethodV(this,obj,clazz,
                                                        methodID,args);
        va_end(args);
        return result;
    }
    jobject CallNonvirtualObjectMethodV(jobject obj, jclass clazz,
                                        jmethodID methodID, va_list args) {
        return functions->CallNonvirtualObjectMethodV(this,obj,clazz,
                                                      methodID,args);
    }
    jobject CallNonvirtualObjectMethodA(jobject obj, jclass clazz,
                                        jmethodID methodID, const jvalue * args) {
        return functions->CallNonvirtualObjectMethodA(this,obj,clazz,
                                                      methodID,args);
    }

    jboolean CallNonvirtualBooleanMethod(jobject obj, jclass clazz,
                                         jmethodID methodID, ...) {
        va_list args;
        jboolean result;
        va_start(args,methodID);
        result = functions->CallNonvirtualBooleanMethodV(this,obj,clazz,
                                                         methodID,args);
        va_end(args);
        return result;
    }
    jboolean CallNonvirtualBooleanMethodV(jobject obj, jclass clazz,
                                          jmethodID methodID, va_list args) {
        return functions->CallNonvirtualBooleanMethodV(this,obj,clazz,
                                                       methodID,args);
    }
    jboolean CallNonvirtualBooleanMethodA(jobject obj, jclass clazz,
                                          jmethodID methodID, const jvalue * args) {
        return functions->CallNonvirtualBooleanMethodA(this,obj,clazz,
                                                       methodID, args);
    }

    jbyte CallNonvirtualByteMethod(jobject obj, jclass clazz,
                                   jmethodID methodID, ...) {
        va_list args;
        jbyte result;
        va_start(args,methodID);
        result = functions->CallNonvirtualByteMethodV(this,obj,clazz,
                                                      methodID,args);
        va_end(args);
        return result;
    }
    jbyte CallNonvirtualByteMethodV(jobject obj, jclass clazz,
                                    jmethodID methodID, va_list args) {
        return functions->CallNonvirtualByteMethodV(this,obj,clazz,
                                                    methodID,args);
    }
    jbyte CallNonvirtualByteMethodA(jobject obj, jclass clazz,
                                    jmethodID methodID, const jvalue * args) {
        return functions->CallNonvirtualByteMethodA(this,obj,clazz,
                                                    methodID,args);
    }

    jchar CallNonvirtualCharMethod(jobject obj, jclass clazz,
                                   jmethodID methodID, ...) {
        va_list args;
        jchar result;
        va_start(args,methodID);
        result = functions->CallNonvirtualCharMethodV(this,obj,clazz,
                                                      methodID,args);
        va_end(args);
        return result;
    }
    jchar CallNonvirtualCharMethodV(jobject obj, jclass clazz,
                                    jmethodID methodID, va_list args) {
        return functions->CallNonvirtualCharMethodV(this,obj,clazz,
                                                    methodID,args);
    }
    jchar CallNonvirtualCharMethodA(jobject obj, jclass clazz,
                                    jmethodID methodID, const jvalue * args) {
        return functions->CallNonvirtualCharMethodA(this,obj,clazz,
                                                    methodID,args);
    }

    jshort CallNonvirtualShortMethod(jobject obj, jclass clazz,
                                     jmethodID methodID, ...) {
        va_list args;
        jshort result;
        va_start(args,methodID);
        result = functions->CallNonvirtualShortMethodV(this,obj,clazz,
                                                       methodID,args);
        va_end(args);
        return result;
    }
    jshort CallNonvirtualShortMethodV(jobject obj, jclass clazz,
                                      jmethodID methodID, va_list args) {
        return functions->CallNonvirtualShortMethodV(this,obj,clazz,
                                                     methodID,args);
    }
    jshort CallNonvirtualShortMethodA(jobject obj, jclass clazz,
                                      jmethodID methodID, const jvalue * args) {
        return functions->CallNonvirtualShortMethodA(this,obj,clazz,
                                                     methodID,args);
    }

    jint CallNonvirtualIntMethod(jobject obj, jclass clazz,
                                 jmethodID methodID, ...) {
        va_list args;
        jint result;
        va_start(args,methodID);
        result = functions->CallNonvirtualIntMethodV(this,obj,clazz,
                                                     methodID,args);
        va_end(args);
        return result;
    }
    jint CallNonvirtualIntMethodV(jobject obj, jclass clazz,
                                  jmethodID methodID, va_list args) {
        return functions->CallNonvirtualIntMethodV(this,obj,clazz,
                                                   methodID,args);
    }
    jint CallNonvirtualIntMethodA(jobject obj, jclass clazz,
                                  jmethodID methodID, const jvalue * args) {
        return functions->CallNonvirtualIntMethodA(this,obj,clazz,
                                                   methodID,args);
    }

    jlong CallNonvirtualLongMethod(jobject obj, jclass clazz,
                                   jmethodID methodID, ...) {
        va_list args;
        jlong result;
        va_start(args,methodID);
        result = functions->CallNonvirtualLongMethodV(this,obj,clazz,
                                                      methodID,args);
        va_end(args);
        return result;
    }
    jlong CallNonvirtualLongMethodV(jobject obj, jclass clazz,
                                    jmethodID methodID, va_list args) {
        return functions->CallNonvirtualLongMethodV(this,obj,clazz,
                                                    methodID,args);
    }
    jlong CallNonvirtualLongMethodA(jobject obj, jclass clazz,
                                    jmethodID methodID, const jvalue * args) {
        return functions->CallNonvirtualLongMethodA(this,obj,clazz,
                                                    methodID,args);
    }

    jfloat CallNonvirtualFloatMethod(jobject obj, jclass clazz,
                                     jmethodID methodID, ...) {
        va_list args;
        jfloat result;
        va_start(args,methodID);
        result = functions->CallNonvirtualFloatMethodV(this,obj,clazz,
                                                       methodID,args);
        va_end(args);
        return result;
    }
    jfloat CallNonvirtualFloatMethodV(jobject obj, jclass clazz,
                                      jmethodID methodID,
                                      va_list args) {
        return functions->CallNonvirtualFloatMethodV(this,obj,clazz,
                                                     methodID,args);
    }
    jfloat CallNonvirtualFloatMethodA(jobject obj, jclass clazz,
                                      jmethodID methodID,
                                      const jvalue * args) {
        return functions->CallNonvirtualFloatMethodA(this,obj,clazz,
                                                     methodID,args);
    }

    jdouble CallNonvirtualDoubleMethod(jobject obj, jclass clazz,
                                       jmethodID methodID, ...) {
        va_list args;
        jdouble result;
        va_start(args,methodID);
        result = functions->CallNonvirtualDoubleMethodV(this,obj,clazz,
                                                        methodID,args);
        va_end(args);
        return result;
    }
    jdouble CallNonvirtualDoubleMethodV(jobject obj, jclass clazz,
                                        jmethodID methodID,
                                        va_list args) {
        return functions->CallNonvirtualDoubleMethodV(this,obj,clazz,
                                                      methodID,args);
    }
    jdouble CallNonvirtualDoubleMethodA(jobject obj, jclass clazz,
                                        jmethodID methodID,
                                        const jvalue * args) {
        return functions->CallNonvirtualDoubleMethodA(this,obj,clazz,
                                                      methodID,args);
    }

    void CallNonvirtualVoidMethod(jobject obj, jclass clazz,
                                  jmethodID methodID, ...) {
        va_list args;
        va_start(args,methodID);
        functions->CallNonvirtualVoidMethodV(this,obj,clazz,methodID,args);
        va_end(args);
    }
    void CallNonvirtualVoidMethodV(jobject obj, jclass clazz,
                                   jmethodID methodID,
                                   va_list args) {
        functions->CallNonvirtualVoidMethodV(this,obj,clazz,methodID,args);
    }
    void CallNonvirtualVoidMethodA(jobject obj, jclass clazz,
                                   jmethodID methodID,
                                   const jvalue * args) {
        functions->CallNonvirtualVoidMethodA(this,obj,clazz,methodID,args);
    }

    jfieldID GetFieldID(jclass clazz, const char *name,
                        const char *sig) {
        return functions->GetFieldID(this,clazz,name,sig);
    }

    jobject GetObjectField(jobject obj, jfieldID fieldID) {
        return functions->GetObjectField(this,obj,fieldID);
    }
    jboolean GetBooleanField(jobject obj, jfieldID fieldID) {
        return functions->GetBooleanField(this,obj,fieldID);
    }
    jbyte GetByteField(jobject obj, jfieldID fieldID) {
        return functions->GetByteField(this,obj,fieldID);
    }
    jchar GetCharField(jobject obj, jfieldID fieldID) {
        return functions->GetCharField(this,obj,fieldID);
    }
    jshort GetShortField(jobject obj, jfieldID fieldID) {
        return functions->GetShortField(this,obj,fieldID);
    }
    jint GetIntField(jobject obj, jfieldID fieldID) {
        return functions->GetIntField(this,obj,fieldID);
    }
    jlong GetLongField(jobject obj, jfieldID fieldID) {
        return functions->GetLongField(this,obj,fieldID);
    }
    jfloat GetFloatField(jobject obj, jfieldID fieldID) {
        return functions->GetFloatField(this,obj,fieldID);
    }
    jdouble GetDoubleField(jobject obj, jfieldID fieldID) {
        return functions->GetDoubleField(this,obj,fieldID);
    }

    void SetObjectField(jobject obj, jfieldID fieldID, jobject val) {
        functions->SetObjectField(this,obj,fieldID,val);
    }
    void SetBooleanField(jobject obj, jfieldID fieldID,
                         jboolean val) {
        functions->SetBooleanField(this,obj,fieldID,val);
    }
    void SetByteField(jobject obj, jfieldID fieldID,
                      jbyte val) {
        functions->SetByteField(this,obj,fieldID,val);
    }
    void SetCharField(jobject obj, jfieldID fieldID,
                      jchar val) {
        functions->SetCharField(this,obj,fieldID,val);
    }
    void SetShortField(jobject obj, jfieldID fieldID,
                       jshort val) {
        functions->SetShortField(this,obj,fieldID,val);
    }
    void SetIntField(jobject obj, jfieldID fieldID,
                     jint val) {
        functions->SetIntField(this,obj,fieldID,val);
    }
    void SetLongField(jobject obj, jfieldID fieldID,
                      jlong val) {
        functions->SetLongField(this,obj,fieldID,val);
    }
    void SetFloatField(jobject obj, jfieldID fieldID,
                       jfloat val) {
        functions->SetFloatField(this,obj,fieldID,val);
    }
    void SetDoubleField(jobject obj, jfieldID fieldID,
                        jdouble val) {
        functions->SetDoubleField(this,obj,fieldID,val);
    }

    jmethodID GetStaticMethodID(jclass clazz, const char *name,
                                const char *sig) {
        return functions->GetStaticMethodID(this,clazz,name,sig);
    }

    jobject CallStaticObjectMethod(jclass clazz, jmethodID methodID,
                             ...) {
        va_list args;
        jobject result;
        va_start(args,methodID);
        result = functions->CallStaticObjectMethodV(this,clazz,methodID,args);
        va_end(args);
        return result;
    }
    jobject CallStaticObjectMethodV(jclass clazz, jmethodID methodID,
                              va_list args) {
        return functions->CallStaticObjectMethodV(this,clazz,methodID,args);
    }
    jobject CallStaticObjectMethodA(jclass clazz, jmethodID methodID,
                              const jvalue *args) {
        return functions->CallStaticObjectMethodA(this,clazz,methodID,args);
    }

    jboolean CallStaticBooleanMethod(jclass clazz,
                                     jmethodID methodID, ...) {
        va_list args;
        jboolean result;
        va_start(args,methodID);
        result = functions->CallStaticBooleanMethodV(this,clazz,methodID,args);
        va_end(args);
        return result;
    }
    jboolean CallStaticBooleanMethodV(jclass clazz,
                                      jmethodID methodID, va_list args) {
        return functions->CallStaticBooleanMethodV(this,clazz,methodID,args);
    }
    jboolean CallStaticBooleanMethodA(jclass clazz,
                                      jmethodID methodID, const jvalue *args) {
        return functions->CallStaticBooleanMethodA(this,clazz,methodID,args);
    }

    jbyte CallStaticByteMethod(jclass clazz,
                               jmethodID methodID, ...) {
        va_list args;
        jbyte result;
        va_start(args,methodID);
        result = functions->CallStaticByteMethodV(this,clazz,methodID,args);
        va_end(args);
        return result;
    }
    jbyte CallStaticByteMethodV(jclass clazz,
                                jmethodID methodID, va_list args) {
        return functions->CallStaticByteMethodV(this,clazz,methodID,args);
    }
    jbyte CallStaticByteMethodA(jclass clazz,
                                jmethodID methodID, const jvalue *args) {
        return functions->CallStaticByteMethodA(this,clazz,methodID,args);
    }

    jchar CallStaticCharMethod(jclass clazz,
                               jmethodID methodID, ...) {
        va_list args;
        jchar result;
        va_start(args,methodID);
        result = functions->CallStaticCharMethodV(this,clazz,methodID,args);
        va_end(args);
        return result;
    }
    jchar CallStaticCharMethodV(jclass clazz,
                                jmethodID methodID, va_list args) {
        return functions->CallStaticCharMethodV(this,clazz,methodID,args);
    }
    jchar CallStaticCharMethodA(jclass clazz,
                                jmethodID methodID, const jvalue *args) {
        return functions->CallStaticCharMethodA(this,clazz,methodID,args);
    }

    jshort CallStaticShortMethod(jclass clazz,
                                 jmethodID methodID, ...) {
        va_list args;
        jshort result;
        va_start(args,methodID);
        result = functions->CallStaticShortMethodV(this,clazz,methodID,args);
        va_end(args);
        return result;
    }
    jshort CallStaticShortMethodV(jclass clazz,
                                  jmethodID methodID, va_list args) {
        return functions->CallStaticShortMethodV(this,clazz,methodID,args);
    }
    jshort CallStaticShortMethodA(jclass clazz,
                                  jmethodID methodID, const jvalue *args) {
        return functions->CallStaticShortMethodA(this,clazz,methodID,args);
    }

    jint CallStaticIntMethod(jclass clazz,
                             jmethodID methodID, ...) {
        va_list args;
        jint result;
        va_start(args,methodID);
        result = functions->CallStaticIntMethodV(this,clazz,methodID,args);
        va_end(args);
        return result;
    }
    jint CallStaticIntMethodV(jclass clazz,
                              jmethodID methodID, va_list args) {
        return functions->CallStaticIntMethodV(this,clazz,methodID,args);
    }
    jint CallStaticIntMethodA(jclass clazz,
                              jmethodID methodID, const jvalue *args) {
        return functions->CallStaticIntMethodA(this,clazz,methodID,args);
    }

    jlong CallStaticLongMethod(jclass clazz,
                               jmethodID methodID, ...) {
        va_list args;
        jlong result;
        va_start(args,methodID);
        result = functions->CallStaticLongMethodV(this,clazz,methodID,args);
        va_end(args);
        return result;
    }
    jlong CallStaticLongMethodV(jclass clazz,
                                jmethodID methodID, va_list args) {
        return functions->CallStaticLongMethodV(this,clazz,methodID,args);
    }
    jlong CallStaticLongMethodA(jclass clazz,
                                jmethodID methodID, const jvalue *args) {
        return functions->CallStaticLongMethodA(this,clazz,methodID,args);
    }

    jfloat CallStaticFloatMethod(jclass clazz,
                                 jmethodID methodID, ...) {
        va_list args;
        jfloat result;
        va_start(args,methodID);
        result = functions->CallStaticFloatMethodV(this,clazz,methodID,args);
        va_end(args);
        return result;
    }
    jfloat CallStaticFloatMethodV(jclass clazz,
                                  jmethodID methodID, va_list args) {
        return functions->CallStaticFloatMethodV(this,clazz,methodID,args);
    }
    jfloat CallStaticFloatMethodA(jclass clazz,
                                  jmethodID methodID, const jvalue *args) {
        return functions->CallStaticFloatMethodA(this,clazz,methodID,args);
    }

    jdouble CallStaticDoubleMethod(jclass clazz,
                                   jmethodID methodID, ...) {
        va_list args;
        jdouble result;
        va_start(args,methodID);
        result = functions->CallStaticDoubleMethodV(this,clazz,methodID,args);
        va_end(args);
        return result;
    }
    jdouble CallStaticDoubleMethodV(jclass clazz,
                                    jmethodID methodID, va_list args) {
        return functions->CallStaticDoubleMethodV(this,clazz,methodID,args);
    }
    jdouble CallStaticDoubleMethodA(jclass clazz,
                                    jmethodID methodID, const jvalue *args) {
        return functions->CallStaticDoubleMethodA(this,clazz,methodID,args);
    }

    void CallStaticVoidMethod(jclass cls, jmethodID methodID, ...) {
        va_list args;
        va_start(args,methodID);
        functions->CallStaticVoidMethodV(this,cls,methodID,args);
        va_end(args);
    }
    void CallStaticVoidMethodV(jclass cls, jmethodID methodID,
                               va_list args) {
        functions->CallStaticVoidMethodV(this,cls,methodID,args);
    }
    void CallStaticVoidMethodA(jclass cls, jmethodID methodID,
                               const jvalue * args) {
        functions->CallStaticVoidMethodA(this,cls,methodID,args);
    }

    jfieldID GetStaticFieldID(jclass clazz, const char *name,
                              const char *sig) {
        return functions->GetStaticFieldID(this,clazz,name,sig);
    }
    jobject GetStaticObjectField(jclass clazz, jfieldID fieldID) {
        return functions->GetStaticObjectField(this,clazz,fieldID);
    }
    jboolean GetStaticBooleanField(jclass clazz, jfieldID fieldID) {
        return functions->GetStaticBooleanField(this,clazz,fieldID);
    }
    jbyte GetStaticByteField(jclass clazz, jfieldID fieldID) {
        return functions->GetStaticByteField(this,clazz,fieldID);
    }
    jchar GetStaticCharField(jclass clazz, jfieldID fieldID) {
        return functions->GetStaticCharField(this,clazz,fieldID);
    }
    jshort GetStaticShortField(jclass clazz, jfieldID fieldID) {
        return functions->GetStaticShortField(this,clazz,fieldID);
    }
    jint GetStaticIntField(jclass clazz, jfieldID fieldID) {
        return functions->GetStaticIntField(this,clazz,fieldID);
    }
    jlong GetStaticLongField(jclass clazz, jfieldID fieldID) {
        return functions->GetStaticLongField(this,clazz,fieldID);
    }
    jfloat GetStaticFloatField(jclass clazz, jfieldID fieldID) {
        return functions->GetStaticFloatField(this,clazz,fieldID);
    }
    jdouble GetStaticDoubleField(jclass clazz, jfieldID fieldID) {
        return functions->GetStaticDoubleField(this,clazz,fieldID);
    }

    void SetStaticObjectField(jclass clazz, jfieldID fieldID,
                        jobject value) {
      functions->SetStaticObjectField(this,clazz,fieldID,value);
    }
    void SetStaticBooleanField(jclass clazz, jfieldID fieldID,
                        jboolean value) {
      functions->SetStaticBooleanField(this,clazz,fieldID,value);
    }
    void SetStaticByteField(jclass clazz, jfieldID fieldID,
                        jbyte value) {
      functions->SetStaticByteField(this,clazz,fieldID,value);
    }
    void SetStaticCharField(jclass clazz, jfieldID fieldID,
                        jchar value) {
      functions->SetStaticCharField(this,clazz,fieldID,value);
    }
    void SetStaticShortField(jclass clazz, jfieldID fieldID,
                        jshort value) {
      functions->SetStaticShortField(this,clazz,fieldID,value);
    }
    void SetStaticIntField(jclass clazz, jfieldID fieldID,
                        jint value) {
      functions->SetStaticIntField(this,clazz,fieldID,value);
    }
    void SetStaticLongField(jclass clazz, jfieldID fieldID,
                        jlong value) {
      functions->SetStaticLongField(this,clazz,fieldID,value);
    }
    void SetStaticFloatField(jclass clazz, jfieldID fieldID,
                        jfloat value) {
      functions->SetStaticFloatField(this,clazz,fieldID,value);
    }
    void SetStaticDoubleField(jclass clazz, jfieldID fieldID,
                        jdouble value) {
      functions->SetStaticDoubleField(this,clazz,fieldID,value);
    }

    jstring NewString(const jchar *unicode, jsize len) {
        return functions->NewString(this,unicode,len);
    }
    jsize GetStringLength(jstring str) {
        return functions->GetStringLength(this,str);
    }
    const jchar *GetStringChars(jstring str, jboolean *isCopy) {
        return functions->GetStringChars(this,str,isCopy);
    }
    void ReleaseStringChars(jstring str, const jchar *chars) {
        functions->ReleaseStringChars(this,str,chars);
    }

    jstring NewStringUTF(const char *utf) {
        return functions->NewStringUTF(this,utf);
    }
    jsize GetStringUTFLength(jstring str) {
        return functions->GetStringUTFLength(this,str);
    }
    const char* GetStringUTFChars(jstring str, jboolean *isCopy) {
        return functions->GetStringUTFChars(this,str,isCopy);
    }
    void ReleaseStringUTFChars(jstring str, const char* chars) {
        functions->ReleaseStringUTFChars(this,str,chars);
    }

    jsize GetArrayLength(jarray array) {
        return functions->GetArrayLength(this,array);
    }

    jobjectArray NewObjectArray(jsize len, jclass clazz,
                                jobject init) {
        return functions->NewObjectArray(this,len,clazz,init);
    }
    jobject GetObjectArrayElement(jobjectArray array, jsize index) {
        return functions->GetObjectArrayElement(this,array,index);
    }
    void SetObjectArrayElement(jobjectArray array, jsize index,
                               jobject val) {
        functions->SetObjectArrayElement(this,array,index,val);
    }

    jbooleanArray NewBooleanArray(jsize len) {
        return functions->NewBooleanArray(this,len);
    }
    jbyteArray NewByteArray(jsize len) {
        return functions->NewByteArray(this,len);
    }
    jcharArray NewCharArray(jsize len) {
        return functions->NewCharArray(this,len);
    }
    jshortArray NewShortArray(jsize len) {
        return functions->NewShortArray(this,len);
    }
    jintArray NewIntArray(jsize len) {
        return functions->NewIntArray(this,len);
    }
    jlongArray NewLongArray(jsize len) {
        return functions->NewLongArray(this,len);
    }
    jfloatArray NewFloatArray(jsize len) {
        return functions->NewFloatArray(this,len);
    }
    jdoubleArray NewDoubleArray(jsize len) {
        return functions->NewDoubleArray(this,len);
    }

    jboolean * GetBooleanArrayElements(jbooleanArray array, jboolean *isCopy) {
        return functions->GetBooleanArrayElements(this,array,isCopy);
    }
    jbyte * GetByteArrayElements(jbyteArray array, jboolean *isCopy) {
        return functions->GetByteArrayElements(this,array,isCopy);
    }
    jchar * GetCharArrayElements(jcharArray array, jboolean *isCopy) {
        return functions->GetCharArrayElements(this,array,isCopy);
    }
    jshort * GetShortArrayElements(jshortArray array, jboolean *isCopy) {
        return functions->GetShortArrayElements(this,array,isCopy);
    }
    jint * GetIntArrayElements(jintArray array, jboolean *isCopy) {
        return functions->GetIntArrayElements(this,array,isCopy);
    }
    jlong * GetLongArrayElements(jlongArray array, jboolean *isCopy) {
        return functions->GetLongArrayElements(this,array,isCopy);
    }
    jfloat * GetFloatArrayElements(jfloatArray array, jboolean *isCopy) {
        return functions->GetFloatArrayElements(this,array,isCopy);
    }
    jdouble * GetDoubleArrayElements(jdoubleArray array, jboolean *isCopy) {
        return functions->GetDoubleArrayElements(this,array,isCopy);
    }

    void ReleaseBooleanArrayElements(jbooleanArray array,
                                     jboolean *elems,
                                     jint mode) {
        functions->ReleaseBooleanArrayElements(this,array,elems,mode);
    }
    void ReleaseByteArrayElements(jbyteArray array,
                                  jbyte *elems,
                                  jint mode) {
        functions->ReleaseByteArrayElements(this,array,elems,mode);
    }
    void ReleaseCharArrayElements(jcharArray array,
                                  jchar *elems,
                                  jint mode) {
        functions->ReleaseCharArrayElements(this,array,elems,mode);
    }
    void ReleaseShortArrayElements(jshortArray array,
                                   jshort *elems,
                                   jint mode) {
        functions->ReleaseShortArrayElements(this,array,elems,mode);
    }
    void ReleaseIntArrayElements(jintArray array,
                                 jint *elems,
                                 jint mode) {
        functions->ReleaseIntArrayElements(this,array,elems,mode);
    }
    void ReleaseLongArrayElements(jlongArray array,
                                  jlong *elems,
                                  jint mode) {
        functions->ReleaseLongArrayElements(this,array,elems,mode);
    }
    void ReleaseFloatArrayElements(jfloatArray array,
                                   jfloat *elems,
                                   jint mode) {
        functions->ReleaseFloatArrayElements(this,array,elems,mode);
    }
    void ReleaseDoubleArrayElements(jdoubleArray array,
                                    jdouble *elems,
                                    jint mode) {
        functions->ReleaseDoubleArrayElements(this,array,elems,mode);
    }

    void GetBooleanArrayRegion(jbooleanArray array,
                               jsize start, jsize len, jboolean *buf) {
        functions->GetBooleanArrayRegion(this,array,start,len,buf);
    }
    void GetByteArrayRegion(jbyteArray array,
                            jsize start, jsize len, jbyte *buf) {
        functions->GetByteArrayRegion(this,array,start,len,buf);
    }
    void GetCharArrayRegion(jcharArray array,
                            jsize start, jsize len, jchar *buf) {
        functions->GetCharArrayRegion(this,array,start,len,buf);
    }
    void GetShortArrayRegion(jshortArray array,
                             jsize start, jsize len, jshort *buf) {
        functions->GetShortArrayRegion(this,array,start,len,buf);
    }
    void GetIntArrayRegion(jintArray array,
                           jsize start, jsize len, jint *buf) {
        functions->GetIntArrayRegion(this,array,start,len,buf);
    }
    void GetLongArrayRegion(jlongArray array,
                            jsize start, jsize len, jlong *buf) {
        functions->GetLongArrayRegion(this,array,start,len,buf);
    }
    void GetFloatArrayRegion(jfloatArray array,
                             jsize start, jsize len, jfloat *buf) {
        functions->GetFloatArrayRegion(this,array,start,len,buf);
    }
    void GetDoubleArrayRegion(jdoubleArray array,
                              jsize start, jsize len, jdouble *buf) {
        functions->GetDoubleArrayRegion(this,array,start,len,buf);
    }

    void SetBooleanArrayRegion(jbooleanArray array, jsize start, jsize len,
                               const jboolean *buf) {
        functions->SetBooleanArrayRegion(this,array,start,len,buf);
    }
    void SetByteArrayRegion(jbyteArray array, jsize start, jsize len,
                            const jbyte *buf) {
        functions->SetByteArrayRegion(this,array,start,len,buf);
    }
    void SetCharArrayRegion(jcharArray array, jsize start, jsize len,
                            const jchar *buf) {
        functions->SetCharArrayRegion(this,array,start,len,buf);
    }
    void SetShortArrayRegion(jshortArray array, jsize start, jsize len,
                             const jshort *buf) {
        functions->SetShortArrayRegion(this,array,start,len,buf);
    }
    void SetIntArrayRegion(jintArray array, jsize start, jsize len,
                           const jint *buf) {
        functions->SetIntArrayRegion(this,array,start,len,buf);
    }
    void SetLongArrayRegion(jlongArray array, jsize start, jsize len,
                            const jlong *buf) {
        functions->SetLongArrayRegion(this,array,start,len,buf);
    }
    void SetFloatArrayRegion(jfloatArray array, jsize start, jsize len,
                             const jfloat *buf) {
        functions->SetFloatArrayRegion(this,array,start,len,buf);
    }
    void SetDoubleArrayRegion(jdoubleArray array, jsize start, jsize len,
                              const jdouble *buf) {
        functions->SetDoubleArrayRegion(this,array,start,len,buf);
    }

    jint RegisterNatives(jclass clazz, const JNINativeMethod *methods,
                         jint nMethods) {
        return functions->RegisterNatives(this,clazz,methods,nMethods);
    }
    jint UnregisterNatives(jclass clazz) {
        return functions->UnregisterNatives(this,clazz);
    }

    jint MonitorEnter(jobject obj) {
        return functions->MonitorEnter(this,obj);
    }
    jint MonitorExit(jobject obj) {
        return functions->MonitorExit(this,obj);
    }

    jint GetJavaVM(JavaVM **vm) {
        return functions->GetJavaVM(this,vm);
    }

    void GetStringRegion(jstring str, jsize start, jsize len, jchar *buf) {
        functions->GetStringRegion(this,str,start,len,buf);
    }
    void GetStringUTFRegion(jstring str, jsize start, jsize len, char *buf) {
        functions->GetStringUTFRegion(this,str,start,len,buf);
    }

    void * GetPrimitiveArrayCritical(jarray array, jboolean *isCopy) {
        return functions->GetPrimitiveArrayCritical(this,array,isCopy);
    }
    void ReleasePrimitiveArrayCritical(jarray array, void *carray, jint mode) {
        functions->ReleasePrimitiveArrayCritical(this,array,carray,mode);
    }

    const jchar * GetStringCritical(jstring string, jboolean *isCopy) {
        return functions->GetStringCritical(this,string,isCopy);
    }
    void ReleaseStringCritical(jstring string, const jchar *cstring) {
        functions->ReleaseStringCritical(this,string,cstring);
    }

    jweak NewWeakGlobalRef(jobject obj) {
        return functions->NewWeakGlobalRef(this,obj);
    }
    void DeleteWeakGlobalRef(jweak ref) {
        functions->DeleteWeakGlobalRef(this,ref);
    }

    jboolean ExceptionCheck() {
        return functions->ExceptionCheck(this);
    }

    jobject NewDirectByteBuffer(void* address, jlong capacity) {
        return functions->NewDirectByteBuffer(this, address, capacity);
    }
    void* GetDirectBufferAddress(jobject buf) {
        return functions->GetDirectBufferAddress(this, buf);
    }
    jlong GetDirectBufferCapacity(jobject buf) {
        return functions->GetDirectBufferCapacity(this, buf);
    }
    jobjectRefType GetObjectRefType(jobject obj) {
        return functions->GetObjectRefType(this, obj);
    }

#endif /* __cplusplus */
};

typedef struct JavaVMOption {
    char *optionString;
    void *extraInfo;
} JavaVMOption;

typedef struct JavaVMInitArgs {
    jint version;

    jint nOptions;
    JavaVMOption *options;
    jboolean ignoreUnrecognized;
} JavaVMInitArgs;

typedef struct JavaVMAttachArgs {
    jint version;

    char *name;
    jobject group;
} JavaVMAttachArgs;

/* These will be VM-specific. */

#define JDK1_2
#define JDK1_4

/* End VM-specific. */

struct JNIInvokeInterface_ {
    void *reserved0;
    void *reserved1;
    void *reserved2;

    jint (JNICALL *DestroyJavaVM)(JavaVM *vm);

    jint (JNICALL *AttachCurrentThread)(JavaVM *vm, void **penv, void *args);

    jint (JNICALL *DetachCurrentThread)(JavaVM *vm);

    jint (JNICALL *GetEnv)(JavaVM *vm, void **penv, jint version);

    jint (JNICALL *AttachCurrentThreadAsDaemon)(JavaVM *vm, void **penv, void *args);
};

struct JavaVM_ {
    const struct JNIInvokeInterface_ *functions;
#ifdef __cplusplus

    jint DestroyJavaVM() {
        return functions->DestroyJavaVM(this);
    }
    jint AttachCurrentThread(void **penv, void *args) {
        return functions->AttachCurrentThread(this, penv, args);
    }
    jint DetachCurrentThread() {
        return functions->DetachCurrentThread(this);
    }

    jint GetEnv(void **penv, jint version) {
        return functions->GetEnv(this, penv, version);
    }
    jint AttachCurrentThreadAsDaemon(void **penv, void *args) {
        return functions->AttachCurrentThreadAsDaemon(this, penv, args);
    }
#endif
};

#ifdef _JNI_IMPLEMENTATION_
#define _JNI_IMPORT_OR_EXPORT_ JNIEXPORT
#else
#define _JNI_IMPORT_OR_EXPORT_ JNIIMPORT
#endif
_JNI_IMPORT_OR_EXPORT_ jint JNICALL
JNI_GetDefaultJavaVMInitArgs(void *args);

_JNI_IMPORT_OR_EXPORT_ jint JNICALL
JNI_CreateJavaVM(JavaVM **pvm, void **penv, void *args);

_JNI_IMPORT_OR_EXPORT_ jint JNICALL
JNI_GetCreatedJavaVMs(JavaVM **, jsize, jsize *);

/* Defined by native libraries. */
JNIEXPORT jint JNICALL
JNI_OnLoad(JavaVM *vm, void *reserved);

JNIEXPORT void JNICALL
JNI_OnUnload(JavaVM *vm, void *reserved);

#define JNI_VERSION_1_1 0x00010001
#define JNI_VERSION_1_2 0x00010002
#define JNI_VERSION_1_4 0x00010004
#define JNI_VERSION_1_6 0x00010006
#define JNI_VERSION_1_8 0x00010008

#ifdef __cplusplus
} /* extern "C" */
#endif /* __cplusplus */

#endif /* !_JAVASOFT_JNI_H_ */

```

`Avanguard/JNI/include/jvmti.h`:

```h
/*
 * Copyright (c) 2003, 2011, Oracle and/or its affiliates. All rights reserved.
 * ORACLE PROPRIETARY/CONFIDENTIAL. Use is subject to license terms.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 */

    /* AUTOMATICALLY GENERATED FILE - DO NOT EDIT */


    /* Include file for the Java(tm) Virtual Machine Tool Interface */

#ifndef _JAVA_JVMTI_H_
#define _JAVA_JVMTI_H_

#include "jni.h"

#ifdef __cplusplus
extern "C" {
#endif

enum {
    JVMTI_VERSION_1   = 0x30010000,
    JVMTI_VERSION_1_0 = 0x30010000,
    JVMTI_VERSION_1_1 = 0x30010100,
    JVMTI_VERSION_1_2 = 0x30010200,

    JVMTI_VERSION = 0x30000000 + (1 * 0x10000) + (2 * 0x100) + 1  /* version: 1.2.1 */
};

JNIEXPORT jint JNICALL
Agent_OnLoad(JavaVM *vm, char *options, void *reserved);

JNIEXPORT jint JNICALL
Agent_OnAttach(JavaVM* vm, char* options, void* reserved);

JNIEXPORT void JNICALL
Agent_OnUnload(JavaVM *vm);

    /* Forward declaration of the environment */

struct _jvmtiEnv;

struct jvmtiInterface_1_;

#ifdef __cplusplus
typedef _jvmtiEnv jvmtiEnv;
#else
typedef const struct jvmtiInterface_1_ *jvmtiEnv;
#endif /* __cplusplus */

/* Derived Base Types */

typedef jobject jthread;
typedef jobject jthreadGroup;
typedef jlong jlocation;
struct _jrawMonitorID;
typedef struct _jrawMonitorID *jrawMonitorID;
typedef struct JNINativeInterface_ jniNativeInterface;

    /* Constants */


    /* Thread State Flags */

enum {
    JVMTI_THREAD_STATE_ALIVE = 0x0001,
    JVMTI_THREAD_STATE_TERMINATED = 0x0002,
    JVMTI_THREAD_STATE_RUNNABLE = 0x0004,
    JVMTI_THREAD_STATE_BLOCKED_ON_MONITOR_ENTER = 0x0400,
    JVMTI_THREAD_STATE_WAITING = 0x0080,
    JVMTI_THREAD_STATE_WAITING_INDEFINITELY = 0x0010,
    JVMTI_THREAD_STATE_WAITING_WITH_TIMEOUT = 0x0020,
    JVMTI_THREAD_STATE_SLEEPING = 0x0040,
    JVMTI_THREAD_STATE_IN_OBJECT_WAIT = 0x0100,
    JVMTI_THREAD_STATE_PARKED = 0x0200,
    JVMTI_THREAD_STATE_SUSPENDED = 0x100000,
    JVMTI_THREAD_STATE_INTERRUPTED = 0x200000,
    JVMTI_THREAD_STATE_IN_NATIVE = 0x400000,
    JVMTI_THREAD_STATE_VENDOR_1 = 0x10000000,
    JVMTI_THREAD_STATE_VENDOR_2 = 0x20000000,
    JVMTI_THREAD_STATE_VENDOR_3 = 0x40000000
};

    /* java.lang.Thread.State Conversion Masks */

enum {
    JVMTI_JAVA_LANG_THREAD_STATE_MASK = JVMTI_THREAD_STATE_TERMINATED | JVMTI_THREAD_STATE_ALIVE | JVMTI_THREAD_STATE_RUNNABLE | JVMTI_THREAD_STATE_BLOCKED_ON_MONITOR_ENTER | JVMTI_THREAD_STATE_WAITING | JVMTI_THREAD_STATE_WAITING_INDEFINITELY | JVMTI_THREAD_STATE_WAITING_WITH_TIMEOUT,
    JVMTI_JAVA_LANG_THREAD_STATE_NEW = 0,
    JVMTI_JAVA_LANG_THREAD_STATE_TERMINATED = JVMTI_THREAD_STATE_TERMINATED,
    JVMTI_JAVA_LANG_THREAD_STATE_RUNNABLE = JVMTI_THREAD_STATE_ALIVE | JVMTI_THREAD_STATE_RUNNABLE,
    JVMTI_JAVA_LANG_THREAD_STATE_BLOCKED = JVMTI_THREAD_STATE_ALIVE | JVMTI_THREAD_STATE_BLOCKED_ON_MONITOR_ENTER,
    JVMTI_JAVA_LANG_THREAD_STATE_WAITING = JVMTI_THREAD_STATE_ALIVE | JVMTI_THREAD_STATE_WAITING | JVMTI_THREAD_STATE_WAITING_INDEFINITELY,
    JVMTI_JAVA_LANG_THREAD_STATE_TIMED_WAITING = JVMTI_THREAD_STATE_ALIVE | JVMTI_THREAD_STATE_WAITING | JVMTI_THREAD_STATE_WAITING_WITH_TIMEOUT
};

    /* Thread Priority Constants */

enum {
    JVMTI_THREAD_MIN_PRIORITY = 1,
    JVMTI_THREAD_NORM_PRIORITY = 5,
    JVMTI_THREAD_MAX_PRIORITY = 10
};

    /* Heap Filter Flags */

enum {
    JVMTI_HEAP_FILTER_TAGGED = 0x4,
    JVMTI_HEAP_FILTER_UNTAGGED = 0x8,
    JVMTI_HEAP_FILTER_CLASS_TAGGED = 0x10,
    JVMTI_HEAP_FILTER_CLASS_UNTAGGED = 0x20
};

    /* Heap Visit Control Flags */

enum {
    JVMTI_VISIT_OBJECTS = 0x100,
    JVMTI_VISIT_ABORT = 0x8000
};

    /* Heap Reference Enumeration */

typedef enum {
    JVMTI_HEAP_REFERENCE_CLASS = 1,
    JVMTI_HEAP_REFERENCE_FIELD = 2,
    JVMTI_HEAP_REFERENCE_ARRAY_ELEMENT = 3,
    JVMTI_HEAP_REFERENCE_CLASS_LOADER = 4,
    JVMTI_HEAP_REFERENCE_SIGNERS = 5,
    JVMTI_HEAP_REFERENCE_PROTECTION_DOMAIN = 6,
    JVMTI_HEAP_REFERENCE_INTERFACE = 7,
    JVMTI_HEAP_REFERENCE_STATIC_FIELD = 8,
    JVMTI_HEAP_REFERENCE_CONSTANT_POOL = 9,
    JVMTI_HEAP_REFERENCE_SUPERCLASS = 10,
    JVMTI_HEAP_REFERENCE_JNI_GLOBAL = 21,
    JVMTI_HEAP_REFERENCE_SYSTEM_CLASS = 22,
    JVMTI_HEAP_REFERENCE_MONITOR = 23,
    JVMTI_HEAP_REFERENCE_STACK_LOCAL = 24,
    JVMTI_HEAP_REFERENCE_JNI_LOCAL = 25,
    JVMTI_HEAP_REFERENCE_THREAD = 26,
    JVMTI_HEAP_REFERENCE_OTHER = 27
} jvmtiHeapReferenceKind;

    /* Primitive Type Enumeration */

typedef enum {
    JVMTI_PRIMITIVE_TYPE_BOOLEAN = 90,
    JVMTI_PRIMITIVE_TYPE_BYTE = 66,
    JVMTI_PRIMITIVE_TYPE_CHAR = 67,
    JVMTI_PRIMITIVE_TYPE_SHORT = 83,
    JVMTI_PRIMITIVE_TYPE_INT = 73,
    JVMTI_PRIMITIVE_TYPE_LONG = 74,
    JVMTI_PRIMITIVE_TYPE_FLOAT = 70,
    JVMTI_PRIMITIVE_TYPE_DOUBLE = 68
} jvmtiPrimitiveType;

    /* Heap Object Filter Enumeration */

typedef enum {
    JVMTI_HEAP_OBJECT_TAGGED = 1,
    JVMTI_HEAP_OBJECT_UNTAGGED = 2,
    JVMTI_HEAP_OBJECT_EITHER = 3
} jvmtiHeapObjectFilter;

    /* Heap Root Kind Enumeration */

typedef enum {
    JVMTI_HEAP_ROOT_JNI_GLOBAL = 1,
    JVMTI_HEAP_ROOT_SYSTEM_CLASS = 2,
    JVMTI_HEAP_ROOT_MONITOR = 3,
    JVMTI_HEAP_ROOT_STACK_LOCAL = 4,
    JVMTI_HEAP_ROOT_JNI_LOCAL = 5,
    JVMTI_HEAP_ROOT_THREAD = 6,
    JVMTI_HEAP_ROOT_OTHER = 7
} jvmtiHeapRootKind;

    /* Object Reference Enumeration */

typedef enum {
    JVMTI_REFERENCE_CLASS = 1,
    JVMTI_REFERENCE_FIELD = 2,
    JVMTI_REFERENCE_ARRAY_ELEMENT = 3,
    JVMTI_REFERENCE_CLASS_LOADER = 4,
    JVMTI_REFERENCE_SIGNERS = 5,
    JVMTI_REFERENCE_PROTECTION_DOMAIN = 6,
    JVMTI_REFERENCE_INTERFACE = 7,
    JVMTI_REFERENCE_STATIC_FIELD = 8,
    JVMTI_REFERENCE_CONSTANT_POOL = 9
} jvmtiObjectReferenceKind;

    /* Iteration Control Enumeration */

typedef enum {
    JVMTI_ITERATION_CONTINUE = 1,
    JVMTI_ITERATION_IGNORE = 2,
    JVMTI_ITERATION_ABORT = 0
} jvmtiIterationControl;

    /* Class Status Flags */

enum {
    JVMTI_CLASS_STATUS_VERIFIED = 1,
    JVMTI_CLASS_STATUS_PREPARED = 2,
    JVMTI_CLASS_STATUS_INITIALIZED = 4,
    JVMTI_CLASS_STATUS_ERROR = 8,
    JVMTI_CLASS_STATUS_ARRAY = 16,
    JVMTI_CLASS_STATUS_PRIMITIVE = 32
};

    /* Event Enable/Disable */

typedef enum {
    JVMTI_ENABLE = 1,
    JVMTI_DISABLE = 0
} jvmtiEventMode;

    /* Extension Function/Event Parameter Types */

typedef enum {
    JVMTI_TYPE_JBYTE = 101,
    JVMTI_TYPE_JCHAR = 102,
    JVMTI_TYPE_JSHORT = 103,
    JVMTI_TYPE_JINT = 104,
    JVMTI_TYPE_JLONG = 105,
    JVMTI_TYPE_JFLOAT = 106,
    JVMTI_TYPE_JDOUBLE = 107,
    JVMTI_TYPE_JBOOLEAN = 108,
    JVMTI_TYPE_JOBJECT = 109,
    JVMTI_TYPE_JTHREAD = 110,
    JVMTI_TYPE_JCLASS = 111,
    JVMTI_TYPE_JVALUE = 112,
    JVMTI_TYPE_JFIELDID = 113,
    JVMTI_TYPE_JMETHODID = 114,
    JVMTI_TYPE_CCHAR = 115,
    JVMTI_TYPE_CVOID = 116,
    JVMTI_TYPE_JNIENV = 117
} jvmtiParamTypes;

    /* Extension Function/Event Parameter Kinds */

typedef enum {
    JVMTI_KIND_IN = 91,
    JVMTI_KIND_IN_PTR = 92,
    JVMTI_KIND_IN_BUF = 93,
    JVMTI_KIND_ALLOC_BUF = 94,
    JVMTI_KIND_ALLOC_ALLOC_BUF = 95,
    JVMTI_KIND_OUT = 96,
    JVMTI_KIND_OUT_BUF = 97
} jvmtiParamKind;

    /* Timer Kinds */

typedef enum {
    JVMTI_TIMER_USER_CPU = 30,
    JVMTI_TIMER_TOTAL_CPU = 31,
    JVMTI_TIMER_ELAPSED = 32
} jvmtiTimerKind;

    /* Phases of execution */

typedef enum {
    JVMTI_PHASE_ONLOAD = 1,
    JVMTI_PHASE_PRIMORDIAL = 2,
    JVMTI_PHASE_START = 6,
    JVMTI_PHASE_LIVE = 4,
    JVMTI_PHASE_DEAD = 8
} jvmtiPhase;

    /* Version Interface Types */

enum {
    JVMTI_VERSION_INTERFACE_JNI = 0x00000000,
    JVMTI_VERSION_INTERFACE_JVMTI = 0x30000000
};

    /* Version Masks */

enum {
    JVMTI_VERSION_MASK_INTERFACE_TYPE = 0x70000000,
    JVMTI_VERSION_MASK_MAJOR = 0x0FFF0000,
    JVMTI_VERSION_MASK_MINOR = 0x0000FF00,
    JVMTI_VERSION_MASK_MICRO = 0x000000FF
};

    /* Version Shifts */

enum {
    JVMTI_VERSION_SHIFT_MAJOR = 16,
    JVMTI_VERSION_SHIFT_MINOR = 8,
    JVMTI_VERSION_SHIFT_MICRO = 0
};

    /* Verbose Flag Enumeration */

typedef enum {
    JVMTI_VERBOSE_OTHER = 0,
    JVMTI_VERBOSE_GC = 1,
    JVMTI_VERBOSE_CLASS = 2,
    JVMTI_VERBOSE_JNI = 4
} jvmtiVerboseFlag;

    /* JLocation Format Enumeration */

typedef enum {
    JVMTI_JLOCATION_JVMBCI = 1,
    JVMTI_JLOCATION_MACHINEPC = 2,
    JVMTI_JLOCATION_OTHER = 0
} jvmtiJlocationFormat;

    /* Resource Exhaustion Flags */

enum {
    JVMTI_RESOURCE_EXHAUSTED_OOM_ERROR = 0x0001,
    JVMTI_RESOURCE_EXHAUSTED_JAVA_HEAP = 0x0002,
    JVMTI_RESOURCE_EXHAUSTED_THREADS = 0x0004
};

    /* Errors */

typedef enum {
    JVMTI_ERROR_NONE = 0,
    JVMTI_ERROR_INVALID_THREAD = 10,
    JVMTI_ERROR_INVALID_THREAD_GROUP = 11,
    JVMTI_ERROR_INVALID_PRIORITY = 12,
    JVMTI_ERROR_THREAD_NOT_SUSPENDED = 13,
    JVMTI_ERROR_THREAD_SUSPENDED = 14,
    JVMTI_ERROR_THREAD_NOT_ALIVE = 15,
    JVMTI_ERROR_INVALID_OBJECT = 20,
    JVMTI_ERROR_INVALID_CLASS = 21,
    JVMTI_ERROR_CLASS_NOT_PREPARED = 22,
    JVMTI_ERROR_INVALID_METHODID = 23,
    JVMTI_ERROR_INVALID_LOCATION = 24,
    JVMTI_ERROR_INVALID_FIELDID = 25,
    JVMTI_ERROR_NO_MORE_FRAMES = 31,
    JVMTI_ERROR_OPAQUE_FRAME = 32,
    JVMTI_ERROR_TYPE_MISMATCH = 34,
    JVMTI_ERROR_INVALID_SLOT = 35,
    JVMTI_ERROR_DUPLICATE = 40,
    JVMTI_ERROR_NOT_FOUND = 41,
    JVMTI_ERROR_INVALID_MONITOR = 50,
    JVMTI_ERROR_NOT_MONITOR_OWNER = 51,
    JVMTI_ERROR_INTERRUPT = 52,
    JVMTI_ERROR_INVALID_CLASS_FORMAT = 60,
    JVMTI_ERROR_CIRCULAR_CLASS_DEFINITION = 61,
    JVMTI_ERROR_FAILS_VERIFICATION = 62,
    JVMTI_ERROR_UNSUPPORTED_REDEFINITION_METHOD_ADDED = 63,
    JVMTI_ERROR_UNSUPPORTED_REDEFINITION_SCHEMA_CHANGED = 64,
    JVMTI_ERROR_INVALID_TYPESTATE = 65,
    JVMTI_ERROR_UNSUPPORTED_REDEFINITION_HIERARCHY_CHANGED = 66,
    JVMTI_ERROR_UNSUPPORTED_REDEFINITION_METHOD_DELETED = 67,
    JVMTI_ERROR_UNSUPPORTED_VERSION = 68,
    JVMTI_ERROR_NAMES_DONT_MATCH = 69,
    JVMTI_ERROR_UNSUPPORTED_REDEFINITION_CLASS_MODIFIERS_CHANGED = 70,
    JVMTI_ERROR_UNSUPPORTED_REDEFINITION_METHOD_MODIFIERS_CHANGED = 71,
    JVMTI_ERROR_UNMODIFIABLE_CLASS = 79,
    JVMTI_ERROR_NOT_AVAILABLE = 98,
    JVMTI_ERROR_MUST_POSSESS_CAPABILITY = 99,
    JVMTI_ERROR_NULL_POINTER = 100,
    JVMTI_ERROR_ABSENT_INFORMATION = 101,
    JVMTI_ERROR_INVALID_EVENT_TYPE = 102,
    JVMTI_ERROR_ILLEGAL_ARGUMENT = 103,
    JVMTI_ERROR_NATIVE_METHOD = 104,
    JVMTI_ERROR_CLASS_LOADER_UNSUPPORTED = 106,
    JVMTI_ERROR_OUT_OF_MEMORY = 110,
    JVMTI_ERROR_ACCESS_DENIED = 111,
    JVMTI_ERROR_WRONG_PHASE = 112,
    JVMTI_ERROR_INTERNAL = 113,
    JVMTI_ERROR_UNATTACHED_THREAD = 115,
    JVMTI_ERROR_INVALID_ENVIRONMENT = 116,
    JVMTI_ERROR_MAX = 116
} jvmtiError;

    /* Event IDs */

typedef enum {
    JVMTI_MIN_EVENT_TYPE_VAL = 50,
    JVMTI_EVENT_VM_INIT = 50,
    JVMTI_EVENT_VM_DEATH = 51,
    JVMTI_EVENT_THREAD_START = 52,
    JVMTI_EVENT_THREAD_END = 53,
    JVMTI_EVENT_CLASS_FILE_LOAD_HOOK = 54,
    JVMTI_EVENT_CLASS_LOAD = 55,
    JVMTI_EVENT_CLASS_PREPARE = 56,
    JVMTI_EVENT_VM_START = 57,
    JVMTI_EVENT_EXCEPTION = 58,
    JVMTI_EVENT_EXCEPTION_CATCH = 59,
    JVMTI_EVENT_SINGLE_STEP = 60,
    JVMTI_EVENT_FRAME_POP = 61,
    JVMTI_EVENT_BREAKPOINT = 62,
    JVMTI_EVENT_FIELD_ACCESS = 63,
    JVMTI_EVENT_FIELD_MODIFICATION = 64,
    JVMTI_EVENT_METHOD_ENTRY = 65,
    JVMTI_EVENT_METHOD_EXIT = 66,
    JVMTI_EVENT_NATIVE_METHOD_BIND = 67,
    JVMTI_EVENT_COMPILED_METHOD_LOAD = 68,
    JVMTI_EVENT_COMPILED_METHOD_UNLOAD = 69,
    JVMTI_EVENT_DYNAMIC_CODE_GENERATED = 70,
    JVMTI_EVENT_DATA_DUMP_REQUEST = 71,
    JVMTI_EVENT_MONITOR_WAIT = 73,
    JVMTI_EVENT_MONITOR_WAITED = 74,
    JVMTI_EVENT_MONITOR_CONTENDED_ENTER = 75,
    JVMTI_EVENT_MONITOR_CONTENDED_ENTERED = 76,
    JVMTI_EVENT_RESOURCE_EXHAUSTED = 80,
    JVMTI_EVENT_GARBAGE_COLLECTION_START = 81,
    JVMTI_EVENT_GARBAGE_COLLECTION_FINISH = 82,
    JVMTI_EVENT_OBJECT_FREE = 83,
    JVMTI_EVENT_VM_OBJECT_ALLOC = 84,
    JVMTI_MAX_EVENT_TYPE_VAL = 84
} jvmtiEvent;


    /* Pre-Declarations */
struct _jvmtiThreadInfo;
typedef struct _jvmtiThreadInfo jvmtiThreadInfo;
struct _jvmtiMonitorStackDepthInfo;
typedef struct _jvmtiMonitorStackDepthInfo jvmtiMonitorStackDepthInfo;
struct _jvmtiThreadGroupInfo;
typedef struct _jvmtiThreadGroupInfo jvmtiThreadGroupInfo;
struct _jvmtiFrameInfo;
typedef struct _jvmtiFrameInfo jvmtiFrameInfo;
struct _jvmtiStackInfo;
typedef struct _jvmtiStackInfo jvmtiStackInfo;
struct _jvmtiHeapReferenceInfoField;
typedef struct _jvmtiHeapReferenceInfoField jvmtiHeapReferenceInfoField;
struct _jvmtiHeapReferenceInfoArray;
typedef struct _jvmtiHeapReferenceInfoArray jvmtiHeapReferenceInfoArray;
struct _jvmtiHeapReferenceInfoConstantPool;
typedef struct _jvmtiHeapReferenceInfoConstantPool jvmtiHeapReferenceInfoConstantPool;
struct _jvmtiHeapReferenceInfoStackLocal;
typedef struct _jvmtiHeapReferenceInfoStackLocal jvmtiHeapReferenceInfoStackLocal;
struct _jvmtiHeapReferenceInfoJniLocal;
typedef struct _jvmtiHeapReferenceInfoJniLocal jvmtiHeapReferenceInfoJniLocal;
struct _jvmtiHeapReferenceInfoReserved;
typedef struct _jvmtiHeapReferenceInfoReserved jvmtiHeapReferenceInfoReserved;
union _jvmtiHeapReferenceInfo;
typedef union _jvmtiHeapReferenceInfo jvmtiHeapReferenceInfo;
struct _jvmtiHeapCallbacks;
typedef struct _jvmtiHeapCallbacks jvmtiHeapCallbacks;
struct _jvmtiClassDefinition;
typedef struct _jvmtiClassDefinition jvmtiClassDefinition;
struct _jvmtiMonitorUsage;
typedef struct _jvmtiMonitorUsage jvmtiMonitorUsage;
struct _jvmtiLineNumberEntry;
typedef struct _jvmtiLineNumberEntry jvmtiLineNumberEntry;
struct _jvmtiLocalVariableEntry;
typedef struct _jvmtiLocalVariableEntry jvmtiLocalVariableEntry;
struct _jvmtiParamInfo;
typedef struct _jvmtiParamInfo jvmtiParamInfo;
struct _jvmtiExtensionFunctionInfo;
typedef struct _jvmtiExtensionFunctionInfo jvmtiExtensionFunctionInfo;
struct _jvmtiExtensionEventInfo;
typedef struct _jvmtiExtensionEventInfo jvmtiExtensionEventInfo;
struct _jvmtiTimerInfo;
typedef struct _jvmtiTimerInfo jvmtiTimerInfo;
struct _jvmtiAddrLocationMap;
typedef struct _jvmtiAddrLocationMap jvmtiAddrLocationMap;

    /* Function Types */

typedef void (JNICALL *jvmtiStartFunction)
    (jvmtiEnv* jvmti_env, JNIEnv* jni_env, void* arg);

typedef jint (JNICALL *jvmtiHeapIterationCallback)
    (jlong class_tag, jlong size, jlong* tag_ptr, jint length, void* user_data);

typedef jint (JNICALL *jvmtiHeapReferenceCallback)
    (jvmtiHeapReferenceKind reference_kind, const jvmtiHeapReferenceInfo* reference_info, jlong class_tag, jlong referrer_class_tag, jlong size, jlong* tag_ptr, jlong* referrer_tag_ptr, jint length, void* user_data);

typedef jint (JNICALL *jvmtiPrimitiveFieldCallback)
    (jvmtiHeapReferenceKind kind, const jvmtiHeapReferenceInfo* info, jlong object_class_tag, jlong* object_tag_ptr, jvalue value, jvmtiPrimitiveType value_type, void* user_data);

typedef jint (JNICALL *jvmtiArrayPrimitiveValueCallback)
    (jlong class_tag, jlong size, jlong* tag_ptr, jint element_count, jvmtiPrimitiveType element_type, const void* elements, void* user_data);

typedef jint (JNICALL *jvmtiStringPrimitiveValueCallback)
    (jlong class_tag, jlong size, jlong* tag_ptr, const jchar* value, jint value_length, void* user_data);

typedef jint (JNICALL *jvmtiReservedCallback)
    ();

typedef jvmtiIterationControl (JNICALL *jvmtiHeapObjectCallback)
    (jlong class_tag, jlong size, jlong* tag_ptr, void* user_data);

typedef jvmtiIterationControl (JNICALL *jvmtiHeapRootCallback)
    (jvmtiHeapRootKind root_kind, jlong class_tag, jlong size, jlong* tag_ptr, void* user_data);

typedef jvmtiIterationControl (JNICALL *jvmtiStackReferenceCallback)
    (jvmtiHeapRootKind root_kind, jlong class_tag, jlong size, jlong* tag_ptr, jlong thread_tag, jint depth, jmethodID method, jint slot, void* user_data);

typedef jvmtiIterationControl (JNICALL *jvmtiObjectReferenceCallback)
    (jvmtiObjectReferenceKind reference_kind, jlong class_tag, jlong size, jlong* tag_ptr, jlong referrer_tag, jint referrer_index, void* user_data);

typedef jvmtiError (JNICALL *jvmtiExtensionFunction)
    (jvmtiEnv* jvmti_env,  ...);

typedef void (JNICALL *jvmtiExtensionEvent)
    (jvmtiEnv* jvmti_env,  ...);


    /* Structure Types */
struct _jvmtiThreadInfo {
    char* name;
    jint priority;
    jboolean is_daemon;
    jthreadGroup thread_group;
    jobject context_class_loader;
};
struct _jvmtiMonitorStackDepthInfo {
    jobject monitor;
    jint stack_depth;
};
struct _jvmtiThreadGroupInfo {
    jthreadGroup parent;
    char* name;
    jint max_priority;
    jboolean is_daemon;
};
struct _jvmtiFrameInfo {
    jmethodID method;
    jlocation location;
};
struct _jvmtiStackInfo {
    jthread thread;
    jint state;
    jvmtiFrameInfo* frame_buffer;
    jint frame_count;
};
struct _jvmtiHeapReferenceInfoField {
    jint index;
};
struct _jvmtiHeapReferenceInfoArray {
    jint index;
};
struct _jvmtiHeapReferenceInfoConstantPool {
    jint index;
};
struct _jvmtiHeapReferenceInfoStackLocal {
    jlong thread_tag;
    jlong thread_id;
    jint depth;
    jmethodID method;
    jlocation location;
    jint slot;
};
struct _jvmtiHeapReferenceInfoJniLocal {
    jlong thread_tag;
    jlong thread_id;
    jint depth;
    jmethodID method;
};
struct _jvmtiHeapReferenceInfoReserved {
    jlong reserved1;
    jlong reserved2;
    jlong reserved3;
    jlong reserved4;
    jlong reserved5;
    jlong reserved6;
    jlong reserved7;
    jlong reserved8;
};
union _jvmtiHeapReferenceInfo {
    jvmtiHeapReferenceInfoField field;
    jvmtiHeapReferenceInfoArray array;
    jvmtiHeapReferenceInfoConstantPool constant_pool;
    jvmtiHeapReferenceInfoStackLocal stack_local;
    jvmtiHeapReferenceInfoJniLocal jni_local;
    jvmtiHeapReferenceInfoReserved other;
};
struct _jvmtiHeapCallbacks {
    jvmtiHeapIterationCallback heap_iteration_callback;
    jvmtiHeapReferenceCallback heap_reference_callback;
    jvmtiPrimitiveFieldCallback primitive_field_callback;
    jvmtiArrayPrimitiveValueCallback array_primitive_value_callback;
    jvmtiStringPrimitiveValueCallback string_primitive_value_callback;
    jvmtiReservedCallback reserved5;
    jvmtiReservedCallback reserved6;
    jvmtiReservedCallback reserved7;
    jvmtiReservedCallback reserved8;
    jvmtiReservedCallback reserved9;
    jvmtiReservedCallback reserved10;
    jvmtiReservedCallback reserved11;
    jvmtiReservedCallback reserved12;
    jvmtiReservedCallback reserved13;
    jvmtiReservedCallback reserved14;
    jvmtiReservedCallback reserved15;
};
struct _jvmtiClassDefinition {
    jclass klass;
    jint class_byte_count;
    const unsigned char* class_bytes;
};
struct _jvmtiMonitorUsage {
    jthread owner;
    jint entry_count;
    jint waiter_count;
    jthread* waiters;
    jint notify_waiter_count;
    jthread* notify_waiters;
};
struct _jvmtiLineNumberEntry {
    jlocation start_location;
    jint line_number;
};
struct _jvmtiLocalVariableEntry {
    jlocation start_location;
    jint length;
    char* name;
    char* signature;
    char* generic_signature;
    jint slot;
};
struct _jvmtiParamInfo {
    char* name;
    jvmtiParamKind kind;
    jvmtiParamTypes base_type;
    jboolean null_ok;
};
struct _jvmtiExtensionFunctionInfo {
    jvmtiExtensionFunction func;
    char* id;
    char* short_description;
    jint param_count;
    jvmtiParamInfo* params;
    jint error_count;
    jvmtiError* errors;
};
struct _jvmtiExtensionEventInfo {
    jint extension_event_index;
    char* id;
    char* short_description;
    jint param_count;
    jvmtiParamInfo* params;
};
struct _jvmtiTimerInfo {
    jlong max_value;
    jboolean may_skip_forward;
    jboolean may_skip_backward;
    jvmtiTimerKind kind;
    jlong reserved1;
    jlong reserved2;
};
struct _jvmtiAddrLocationMap {
    const void* start_address;
    jlocation location;
};

typedef struct {
    unsigned int can_tag_objects : 1;
    unsigned int can_generate_field_modification_events : 1;
    unsigned int can_generate_field_access_events : 1;
    unsigned int can_get_bytecodes : 1;
    unsigned int can_get_synthetic_attribute : 1;
    unsigned int can_get_owned_monitor_info : 1;
    unsigned int can_get_current_contended_monitor : 1;
    unsigned int can_get_monitor_info : 1;
    unsigned int can_pop_frame : 1;
    unsigned int can_redefine_classes : 1;
    unsigned int can_signal_thread : 1;
    unsigned int can_get_source_file_name : 1;
    unsigned int can_get_line_numbers : 1;
    unsigned int can_get_source_debug_extension : 1;
    unsigned int can_access_local_variables : 1;
    unsigned int can_maintain_original_method_order : 1;
    unsigned int can_generate_single_step_events : 1;
    unsigned int can_generate_exception_events : 1;
    unsigned int can_generate_frame_pop_events : 1;
    unsigned int can_generate_breakpoint_events : 1;
    unsigned int can_suspend : 1;
    unsigned int can_redefine_any_class : 1;
    unsigned int can_get_current_thread_cpu_time : 1;
    unsigned int can_get_thread_cpu_time : 1;
    unsigned int can_generate_method_entry_events : 1;
    unsigned int can_generate_method_exit_events : 1;
    unsigned int can_generate_all_class_hook_events : 1;
    unsigned int can_generate_compiled_method_load_events : 1;
    unsigned int can_generate_monitor_events : 1;
    unsigned int can_generate_vm_object_alloc_events : 1;
    unsigned int can_generate_native_method_bind_events : 1;
    unsigned int can_generate_garbage_collection_events : 1;
    unsigned int can_generate_object_free_events : 1;
    unsigned int can_force_early_return : 1;
    unsigned int can_get_owned_monitor_stack_depth_info : 1;
    unsigned int can_get_constant_pool : 1;
    unsigned int can_set_native_method_prefix : 1;
    unsigned int can_retransform_classes : 1;
    unsigned int can_retransform_any_class : 1;
    unsigned int can_generate_resource_exhaustion_heap_events : 1;
    unsigned int can_generate_resource_exhaustion_threads_events : 1;
    unsigned int : 7;
    unsigned int : 16;
    unsigned int : 16;
    unsigned int : 16;
    unsigned int : 16;
    unsigned int : 16;
} jvmtiCapabilities;


    /* Event Definitions */

typedef void (JNICALL *jvmtiEventReserved)(void);


typedef void (JNICALL *jvmtiEventBreakpoint)
    (jvmtiEnv *jvmti_env,
     JNIEnv* jni_env,
     jthread thread,
     jmethodID method,
     jlocation location);

typedef void (JNICALL *jvmtiEventClassFileLoadHook)
    (jvmtiEnv *jvmti_env,
     JNIEnv* jni_env,
     jclass class_being_redefined,
     jobject loader,
     const char* name,
     jobject protection_domain,
     jint class_data_len,
     const unsigned char* class_data,
     jint* new_class_data_len,
     unsigned char** new_class_data);

typedef void (JNICALL *jvmtiEventClassLoad)
    (jvmtiEnv *jvmti_env,
     JNIEnv* jni_env,
     jthread thread,
     jclass klass);

typedef void (JNICALL *jvmtiEventClassPrepare)
    (jvmtiEnv *jvmti_env,
     JNIEnv* jni_env,
     jthread thread,
     jclass klass);

typedef void (JNICALL *jvmtiEventCompiledMethodLoad)
    (jvmtiEnv *jvmti_env,
     jmethodID method,
     jint code_size,
     const void* code_addr,
     jint map_length,
     const jvmtiAddrLocationMap* map,
     const void* compile_info);

typedef void (JNICALL *jvmtiEventCompiledMethodUnload)
    (jvmtiEnv *jvmti_env,
     jmethodID method,
     const void* code_addr);

typedef void (JNICALL *jvmtiEventDataDumpRequest)
    (jvmtiEnv *jvmti_env);

typedef void (JNICALL *jvmtiEventDynamicCodeGenerated)
    (jvmtiEnv *jvmti_env,
     const char* name,
     const void* address,
     jint length);

typedef void (JNICALL *jvmtiEventException)
    (jvmtiEnv *jvmti_env,
     JNIEnv* jni_env,
     jthread thread,
     jmethodID method,
     jlocation location,
     jobject exception,
     jmethodID catch_method,
     jlocation catch_location);

typedef void (JNICALL *jvmtiEventExceptionCatch)
    (jvmtiEnv *jvmti_env,
     JNIEnv* jni_env,
     jthread thread,
     jmethodID method,
     jlocation location,
     jobject exception);

typedef void (JNICALL *jvmtiEventFieldAccess)
    (jvmtiEnv *jvmti_env,
     JNIEnv* jni_env,
     jthread thread,
     jmethodID method,
     jlocation location,
     jclass field_klass,
     jobject object,
     jfieldID field);

typedef void (JNICALL *jvmtiEventFieldModification)
    (jvmtiEnv *jvmti_env,
     JNIEnv* jni_env,
     jthread thread,
     jmethodID method,
     jlocation location,
     jclass field_klass,
     jobject object,
     jfieldID field,
     char signature_type,
     jvalue new_value);

typedef void (JNICALL *jvmtiEventFramePop)
    (jvmtiEnv *jvmti_env,
     JNIEnv* jni_env,
     jthread thread,
     jmethodID method,
     jboolean was_popped_by_exception);

typedef void (JNICALL *jvmtiEventGarbageCollectionFinish)
    (jvmtiEnv *jvmti_env);

typedef void (JNICALL *jvmtiEventGarbageCollectionStart)
    (jvmtiEnv *jvmti_env);

typedef void (JNICALL *jvmtiEventMethodEntry)
    (jvmtiEnv *jvmti_env,
     JNIEnv* jni_env,
     jthread thread,
     jmethodID method);

typedef void (JNICALL *jvmtiEventMethodExit)
    (jvmtiEnv *jvmti_env,
     JNIEnv* jni_env,
     jthread thread,
     jmethodID method,
     jboolean was_popped_by_exception,
     jvalue return_value);

typedef void (JNICALL *jvmtiEventMonitorContendedEnter)
    (jvmtiEnv *jvmti_env,
     JNIEnv* jni_env,
     jthread thread,
     jobject object);

typedef void (JNICALL *jvmtiEventMonitorContendedEntered)
    (jvmtiEnv *jvmti_env,
     JNIEnv* jni_env,
     jthread thread,
     jobject object);

typedef void (JNICALL *jvmtiEventMonitorWait)
    (jvmtiEnv *jvmti_env,
     JNIEnv* jni_env,
     jthread thread,
     jobject object,
     jlong timeout);

typedef void (JNICALL *jvmtiEventMonitorWaited)
    (jvmtiEnv *jvmti_env,
     JNIEnv* jni_env,
     jthread thread,
     jobject object,
     jboolean timed_out);

typedef void (JNICALL *jvmtiEventNativeMethodBind)
    (jvmtiEnv *jvmti_env,
     JNIEnv* jni_env,
     jthread thread,
     jmethodID method,
     void* address,
     void** new_address_ptr);

typedef void (JNICALL *jvmtiEventObjectFree)
    (jvmtiEnv *jvmti_env,
     jlong tag);

typedef void (JNICALL *jvmtiEventResourceExhausted)
    (jvmtiEnv *jvmti_env,
     JNIEnv* jni_env,
     jint flags,
     const void* reserved,
     const char* description);

typedef void (JNICALL *jvmtiEventSingleStep)
    (jvmtiEnv *jvmti_env,
     JNIEnv* jni_env,
     jthread thread,
     jmethodID method,
     jlocation location);

typedef void (JNICALL *jvmtiEventThreadEnd)
    (jvmtiEnv *jvmti_env,
     JNIEnv* jni_env,
     jthread thread);

typedef void (JNICALL *jvmtiEventThreadStart)
    (jvmtiEnv *jvmti_env,
     JNIEnv* jni_env,
     jthread thread);

typedef void (JNICALL *jvmtiEventVMDeath)
    (jvmtiEnv *jvmti_env,
     JNIEnv* jni_env);

typedef void (JNICALL *jvmtiEventVMInit)
    (jvmtiEnv *jvmti_env,
     JNIEnv* jni_env,
     jthread thread);

typedef void (JNICALL *jvmtiEventVMObjectAlloc)
    (jvmtiEnv *jvmti_env,
     JNIEnv* jni_env,
     jthread thread,
     jobject object,
     jclass object_klass,
     jlong size);

typedef void (JNICALL *jvmtiEventVMStart)
    (jvmtiEnv *jvmti_env,
     JNIEnv* jni_env);

    /* Event Callback Structure */

typedef struct {
                              /*   50 : VM Initialization Event */
    jvmtiEventVMInit VMInit;
                              /*   51 : VM Death Event */
    jvmtiEventVMDeath VMDeath;
                              /*   52 : Thread Start */
    jvmtiEventThreadStart ThreadStart;
                              /*   53 : Thread End */
    jvmtiEventThreadEnd ThreadEnd;
                              /*   54 : Class File Load Hook */
    jvmtiEventClassFileLoadHook ClassFileLoadHook;
                              /*   55 : Class Load */
    jvmtiEventClassLoad ClassLoad;
                              /*   56 : Class Prepare */
    jvmtiEventClassPrepare ClassPrepare;
                              /*   57 : VM Start Event */
    jvmtiEventVMStart VMStart;
                              /*   58 : Exception */
    jvmtiEventException Exception;
                              /*   59 : Exception Catch */
    jvmtiEventExceptionCatch ExceptionCatch;
                              /*   60 : Single Step */
    jvmtiEventSingleStep SingleStep;
                              /*   61 : Frame Pop */
    jvmtiEventFramePop FramePop;
                              /*   62 : Breakpoint */
    jvmtiEventBreakpoint Breakpoint;
                              /*   63 : Field Access */
    jvmtiEventFieldAccess FieldAccess;
                              /*   64 : Field Modification */
    jvmtiEventFieldModification FieldModification;
                              /*   65 : Method Entry */
    jvmtiEventMethodEntry MethodEntry;
                              /*   66 : Method Exit */
    jvmtiEventMethodExit MethodExit;
                              /*   67 : Native Method Bind */
    jvmtiEventNativeMethodBind NativeMethodBind;
                              /*   68 : Compiled Method Load */
    jvmtiEventCompiledMethodLoad CompiledMethodLoad;
                              /*   69 : Compiled Method Unload */
    jvmtiEventCompiledMethodUnload CompiledMethodUnload;
                              /*   70 : Dynamic Code Generated */
    jvmtiEventDynamicCodeGenerated DynamicCodeGenerated;
                              /*   71 : Data Dump Request */
    jvmtiEventDataDumpRequest DataDumpRequest;
                              /*   72 */
    jvmtiEventReserved reserved72;
                              /*   73 : Monitor Wait */
    jvmtiEventMonitorWait MonitorWait;
                              /*   74 : Monitor Waited */
    jvmtiEventMonitorWaited MonitorWaited;
                              /*   75 : Monitor Contended Enter */
    jvmtiEventMonitorContendedEnter MonitorContendedEnter;
                              /*   76 : Monitor Contended Entered */
    jvmtiEventMonitorContendedEntered MonitorContendedEntered;
                              /*   77 */
    jvmtiEventReserved reserved77;
                              /*   78 */
    jvmtiEventReserved reserved78;
                              /*   79 */
    jvmtiEventReserved reserved79;
                              /*   80 : Resource Exhausted */
    jvmtiEventResourceExhausted ResourceExhausted;
                              /*   81 : Garbage Collection Start */
    jvmtiEventGarbageCollectionStart GarbageCollectionStart;
                              /*   82 : Garbage Collection Finish */
    jvmtiEventGarbageCollectionFinish GarbageCollectionFinish;
                              /*   83 : Object Free */
    jvmtiEventObjectFree ObjectFree;
                              /*   84 : VM Object Allocation */
    jvmtiEventVMObjectAlloc VMObjectAlloc;
} jvmtiEventCallbacks;


    /* Function Interface */

typedef struct jvmtiInterface_1_ {

  /*   1 :  RESERVED */
  void *reserved1;

  /*   2 : Set Event Notification Mode */
  jvmtiError (JNICALL *SetEventNotificationMode) (jvmtiEnv* env,
    jvmtiEventMode mode,
    jvmtiEvent event_type,
    jthread event_thread,
     ...);

  /*   3 :  RESERVED */
  void *reserved3;

  /*   4 : Get All Threads */
  jvmtiError (JNICALL *GetAllThreads) (jvmtiEnv* env,
    jint* threads_count_ptr,
    jthread** threads_ptr);

  /*   5 : Suspend Thread */
  jvmtiError (JNICALL *SuspendThread) (jvmtiEnv* env,
    jthread thread);

  /*   6 : Resume Thread */
  jvmtiError (JNICALL *ResumeThread) (jvmtiEnv* env,
    jthread thread);

  /*   7 : Stop Thread */
  jvmtiError (JNICALL *StopThread) (jvmtiEnv* env,
    jthread thread,
    jobject exception);

  /*   8 : Interrupt Thread */
  jvmtiError (JNICALL *InterruptThread) (jvmtiEnv* env,
    jthread thread);

  /*   9 : Get Thread Info */
  jvmtiError (JNICALL *GetThreadInfo) (jvmtiEnv* env,
    jthread thread,
    jvmtiThreadInfo* info_ptr);

  /*   10 : Get Owned Monitor Info */
  jvmtiError (JNICALL *GetOwnedMonitorInfo) (jvmtiEnv* env,
    jthread thread,
    jint* owned_monitor_count_ptr,
    jobject** owned_monitors_ptr);

  /*   11 : Get Current Contended Monitor */
  jvmtiError (JNICALL *GetCurrentContendedMonitor) (jvmtiEnv* env,
    jthread thread,
    jobject* monitor_ptr);

  /*   12 : Run Agent Thread */
  jvmtiError (JNICALL *RunAgentThread) (jvmtiEnv* env,
    jthread thread,
    jvmtiStartFunction proc,
    const void* arg,
    jint priority);

  /*   13 : Get Top Thread Groups */
  jvmtiError (JNICALL *GetTopThreadGroups) (jvmtiEnv* env,
    jint* group_count_ptr,
    jthreadGroup** groups_ptr);

  /*   14 : Get Thread Group Info */
  jvmtiError (JNICALL *GetThreadGroupInfo) (jvmtiEnv* env,
    jthreadGroup group,
    jvmtiThreadGroupInfo* info_ptr);

  /*   15 : Get Thread Group Children */
  jvmtiError (JNICALL *GetThreadGroupChildren) (jvmtiEnv* env,
    jthreadGroup group,
    jint* thread_count_ptr,
    jthread** threads_ptr,
    jint* group_count_ptr,
    jthreadGroup** groups_ptr);

  /*   16 : Get Frame Count */
  jvmtiError (JNICALL *GetFrameCount) (jvmtiEnv* env,
    jthread thread,
    jint* count_ptr);

  /*   17 : Get Thread State */
  jvmtiError (JNICALL *GetThreadState) (jvmtiEnv* env,
    jthread thread,
    jint* thread_state_ptr);

  /*   18 : Get Current Thread */
  jvmtiError (JNICALL *GetCurrentThread) (jvmtiEnv* env,
    jthread* thread_ptr);

  /*   19 : Get Frame Location */
  jvmtiError (JNICALL *GetFrameLocation) (jvmtiEnv* env,
    jthread thread,
    jint depth,
    jmethodID* method_ptr,
    jlocation* location_ptr);

  /*   20 : Notify Frame Pop */
  jvmtiError (JNICALL *NotifyFramePop) (jvmtiEnv* env,
    jthread thread,
    jint depth);

  /*   21 : Get Local Variable - Object */
  jvmtiError (JNICALL *GetLocalObject) (jvmtiEnv* env,
    jthread thread,
    jint depth,
    jint slot,
    jobject* value_ptr);

  /*   22 : Get Local Variable - Int */
  jvmtiError (JNICALL *GetLocalInt) (jvmtiEnv* env,
    jthread thread,
    jint depth,
    jint slot,
    jint* value_ptr);

  /*   23 : Get Local Variable - Long */
  jvmtiError (JNICALL *GetLocalLong) (jvmtiEnv* env,
    jthread thread,
    jint depth,
    jint slot,
    jlong* value_ptr);

  /*   24 : Get Local Variable - Float */
  jvmtiError (JNICALL *GetLocalFloat) (jvmtiEnv* env,
    jthread thread,
    jint depth,
    jint slot,
    jfloat* value_ptr);

  /*   25 : Get Local Variable - Double */
  jvmtiError (JNICALL *GetLocalDouble) (jvmtiEnv* env,
    jthread thread,
    jint depth,
    jint slot,
    jdouble* value_ptr);

  /*   26 : Set Local Variable - Object */
  jvmtiError (JNICALL *SetLocalObject) (jvmtiEnv* env,
    jthread thread,
    jint depth,
    jint slot,
    jobject value);

  /*   27 : Set Local Variable - Int */
  jvmtiError (JNICALL *SetLocalInt) (jvmtiEnv* env,
    jthread thread,
    jint depth,
    jint slot,
    jint value);

  /*   28 : Set Local Variable - Long */
  jvmtiError (JNICALL *SetLocalLong) (jvmtiEnv* env,
    jthread thread,
    jint depth,
    jint slot,
    jlong value);

  /*   29 : Set Local Variable - Float */
  jvmtiError (JNICALL *SetLocalFloat) (jvmtiEnv* env,
    jthread thread,
    jint depth,
    jint slot,
    jfloat value);

  /*   30 : Set Local Variable - Double */
  jvmtiError (JNICALL *SetLocalDouble) (jvmtiEnv* env,
    jthread thread,
    jint depth,
    jint slot,
    jdouble value);

  /*   31 : Create Raw Monitor */
  jvmtiError (JNICALL *CreateRawMonitor) (jvmtiEnv* env,
    const char* name,
    jrawMonitorID* monitor_ptr);

  /*   32 : Destroy Raw Monitor */
  jvmtiError (JNICALL *DestroyRawMonitor) (jvmtiEnv* env,
    jrawMonitorID monitor);

  /*   33 : Raw Monitor Enter */
  jvmtiError (JNICALL *RawMonitorEnter) (jvmtiEnv* env,
    jrawMonitorID monitor);

  /*   34 : Raw Monitor Exit */
  jvmtiError (JNICALL *RawMonitorExit) (jvmtiEnv* env,
    jrawMonitorID monitor);

  /*   35 : Raw Monitor Wait */
  jvmtiError (JNICALL *RawMonitorWait) (jvmtiEnv* env,
    jrawMonitorID monitor,
    jlong millis);

  /*   36 : Raw Monitor Notify */
  jvmtiError (JNICALL *RawMonitorNotify) (jvmtiEnv* env,
    jrawMonitorID monitor);

  /*   37 : Raw Monitor Notify All */
  jvmtiError (JNICALL *RawMonitorNotifyAll) (jvmtiEnv* env,
    jrawMonitorID monitor);

  /*   38 : Set Breakpoint */
  jvmtiError (JNICALL *SetBreakpoint) (jvmtiEnv* env,
    jmethodID method,
    jlocation location);

  /*   39 : Clear Breakpoint */
  jvmtiError (JNICALL *ClearBreakpoint) (jvmtiEnv* env,
    jmethodID method,
    jlocation location);

  /*   40 :  RESERVED */
  void *reserved40;

  /*   41 : Set Field Access Watch */
  jvmtiError (JNICALL *SetFieldAccessWatch) (jvmtiEnv* env,
    jclass klass,
    jfieldID field);

  /*   42 : Clear Field Access Watch */
  jvmtiError (JNICALL *ClearFieldAccessWatch) (jvmtiEnv* env,
    jclass klass,
    jfieldID field);

  /*   43 : Set Field Modification Watch */
  jvmtiError (JNICALL *SetFieldModificationWatch) (jvmtiEnv* env,
    jclass klass,
    jfieldID field);

  /*   44 : Clear Field Modification Watch */
  jvmtiError (JNICALL *ClearFieldModificationWatch) (jvmtiEnv* env,
    jclass klass,
    jfieldID field);

  /*   45 : Is Modifiable Class */
  jvmtiError (JNICALL *IsModifiableClass) (jvmtiEnv* env,
    jclass klass,
    jboolean* is_modifiable_class_ptr);

  /*   46 : Allocate */
  jvmtiError (JNICALL *Allocate) (jvmtiEnv* env,
    jlong size,
    unsigned char** mem_ptr);

  /*   47 : Deallocate */
  jvmtiError (JNICALL *Deallocate) (jvmtiEnv* env,
    unsigned char* mem);

  /*   48 : Get Class Signature */
  jvmtiError (JNICALL *GetClassSignature) (jvmtiEnv* env,
    jclass klass,
    char** signature_ptr,
    char** generic_ptr);

  /*   49 : Get Class Status */
  jvmtiError (JNICALL *GetClassStatus) (jvmtiEnv* env,
    jclass klass,
    jint* status_ptr);

  /*   50 : Get Source File Name */
  jvmtiError (JNICALL *GetSourceFileName) (jvmtiEnv* env,
    jclass klass,
    char** source_name_ptr);

  /*   51 : Get Class Modifiers */
  jvmtiError (JNICALL *GetClassModifiers) (jvmtiEnv* env,
    jclass klass,
    jint* modifiers_ptr);

  /*   52 : Get Class Methods */
  jvmtiError (JNICALL *GetClassMethods) (jvmtiEnv* env,
    jclass klass,
    jint* method_count_ptr,
    jmethodID** methods_ptr);

  /*   53 : Get Class Fields */
  jvmtiError (JNICALL *GetClassFields) (jvmtiEnv* env,
    jclass klass,
    jint* field_count_ptr,
    jfieldID** fields_ptr);

  /*   54 : Get Implemented Interfaces */
  jvmtiError (JNICALL *GetImplementedInterfaces) (jvmtiEnv* env,
    jclass klass,
    jint* interface_count_ptr,
    jclass** interfaces_ptr);

  /*   55 : Is Interface */
  jvmtiError (JNICALL *IsInterface) (jvmtiEnv* env,
    jclass klass,
    jboolean* is_interface_ptr);

  /*   56 : Is Array Class */
  jvmtiError (JNICALL *IsArrayClass) (jvmtiEnv* env,
    jclass klass,
    jboolean* is_array_class_ptr);

  /*   57 : Get Class Loader */
  jvmtiError (JNICALL *GetClassLoader) (jvmtiEnv* env,
    jclass klass,
    jobject* classloader_ptr);

  /*   58 : Get Object Hash Code */
  jvmtiError (JNICALL *GetObjectHashCode) (jvmtiEnv* env,
    jobject object,
    jint* hash_code_ptr);

  /*   59 : Get Object Monitor Usage */
  jvmtiError (JNICALL *GetObjectMonitorUsage) (jvmtiEnv* env,
    jobject object,
    jvmtiMonitorUsage* info_ptr);

  /*   60 : Get Field Name (and Signature) */
  jvmtiError (JNICALL *GetFieldName) (jvmtiEnv* env,
    jclass klass,
    jfieldID field,
    char** name_ptr,
    char** signature_ptr,
    char** generic_ptr);

  /*   61 : Get Field Declaring Class */
  jvmtiError (JNICALL *GetFieldDeclaringClass) (jvmtiEnv* env,
    jclass klass,
    jfieldID field,
    jclass* declaring_class_ptr);

  /*   62 : Get Field Modifiers */
  jvmtiError (JNICALL *GetFieldModifiers) (jvmtiEnv* env,
    jclass klass,
    jfieldID field,
    jint* modifiers_ptr);

  /*   63 : Is Field Synthetic */
  jvmtiError (JNICALL *IsFieldSynthetic) (jvmtiEnv* env,
    jclass klass,
    jfieldID field,
    jboolean* is_synthetic_ptr);

  /*   64 : Get Method Name (and Signature) */
  jvmtiError (JNICALL *GetMethodName) (jvmtiEnv* env,
    jmethodID method,
    char** name_ptr,
    char** signature_ptr,
    char** generic_ptr);

  /*   65 : Get Method Declaring Class */
  jvmtiError (JNICALL *GetMethodDeclaringClass) (jvmtiEnv* env,
    jmethodID method,
    jclass* declaring_class_ptr);

  /*   66 : Get Method Modifiers */
  jvmtiError (JNICALL *GetMethodModifiers) (jvmtiEnv* env,
    jmethodID method,
    jint* modifiers_ptr);

  /*   67 :  RESERVED */
  void *reserved67;

  /*   68 : Get Max Locals */
  jvmtiError (JNICALL *GetMaxLocals) (jvmtiEnv* env,
    jmethodID method,
    jint* max_ptr);

  /*   69 : Get Arguments Size */
  jvmtiError (JNICALL *GetArgumentsSize) (jvmtiEnv* env,
    jmethodID method,
    jint* size_ptr);

  /*   70 : Get Line Number Table */
  jvmtiError (JNICALL *GetLineNumberTable) (jvmtiEnv* env,
    jmethodID method,
    jint* entry_count_ptr,
    jvmtiLineNumberEntry** table_ptr);

  /*   71 : Get Method Location */
  jvmtiError (JNICALL *GetMethodLocation) (jvmtiEnv* env,
    jmethodID method,
    jlocation* start_location_ptr,
    jlocation* end_location_ptr);

  /*   72 : Get Local Variable Table */
  jvmtiError (JNICALL *GetLocalVariableTable) (jvmtiEnv* env,
    jmethodID method,
    jint* entry_count_ptr,
    jvmtiLocalVariableEntry** table_ptr);

  /*   73 : Set Native Method Prefix */
  jvmtiError (JNICALL *SetNativeMethodPrefix) (jvmtiEnv* env,
    const char* prefix);

  /*   74 : Set Native Method Prefixes */
  jvmtiError (JNICALL *SetNativeMethodPrefixes) (jvmtiEnv* env,
    jint prefix_count,
    char** prefixes);

  /*   75 : Get Bytecodes */
  jvmtiError (JNICALL *GetBytecodes) (jvmtiEnv* env,
    jmethodID method,
    jint* bytecode_count_ptr,
    unsigned char** bytecodes_ptr);

  /*   76 : Is Method Native */
  jvmtiError (JNICALL *IsMethodNative) (jvmtiEnv* env,
    jmethodID method,
    jboolean* is_native_ptr);

  /*   77 : Is Method Synthetic */
  jvmtiError (JNICALL *IsMethodSynthetic) (jvmtiEnv* env,
    jmethodID method,
    jboolean* is_synthetic_ptr);

  /*   78 : Get Loaded Classes */
  jvmtiError (JNICALL *GetLoadedClasses) (jvmtiEnv* env,
    jint* class_count_ptr,
    jclass** classes_ptr);

  /*   79 : Get Classloader Classes */
  jvmtiError (JNICALL *GetClassLoaderClasses) (jvmtiEnv* env,
    jobject initiating_loader,
    jint* class_count_ptr,
    jclass** classes_ptr);

  /*   80 : Pop Frame */
  jvmtiError (JNICALL *PopFrame) (jvmtiEnv* env,
    jthread thread);

  /*   81 : Force Early Return - Object */
  jvmtiError (JNICALL *ForceEarlyReturnObject) (jvmtiEnv* env,
    jthread thread,
    jobject value);

  /*   82 : Force Early Return - Int */
  jvmtiError (JNICALL *ForceEarlyReturnInt) (jvmtiEnv* env,
    jthread thread,
    jint value);

  /*   83 : Force Early Return - Long */
  jvmtiError (JNICALL *ForceEarlyReturnLong) (jvmtiEnv* env,
    jthread thread,
    jlong value);

  /*   84 : Force Early Return - Float */
  jvmtiError (JNICALL *ForceEarlyReturnFloat) (jvmtiEnv* env,
    jthread thread,
    jfloat value);

  /*   85 : Force Early Return - Double */
  jvmtiError (JNICALL *ForceEarlyReturnDouble) (jvmtiEnv* env,
    jthread thread,
    jdouble value);

  /*   86 : Force Early Return - Void */
  jvmtiError (JNICALL *ForceEarlyReturnVoid) (jvmtiEnv* env,
    jthread thread);

  /*   87 : Redefine Classes */
  jvmtiError (JNICALL *RedefineClasses) (jvmtiEnv* env,
    jint class_count,
    const jvmtiClassDefinition* class_definitions);

  /*   88 : Get Version Number */
  jvmtiError (JNICALL *GetVersionNumber) (jvmtiEnv* env,
    jint* version_ptr);

  /*   89 : Get Capabilities */
  jvmtiError (JNICALL *GetCapabilities) (jvmtiEnv* env,
    jvmtiCapabilities* capabilities_ptr);

  /*   90 : Get Source Debug Extension */
  jvmtiError (JNICALL *GetSourceDebugExtension) (jvmtiEnv* env,
    jclass klass,
    char** source_debug_extension_ptr);

  /*   91 : Is Method Obsolete */
  jvmtiError (JNICALL *IsMethodObsolete) (jvmtiEnv* env,
    jmethodID method,
    jboolean* is_obsolete_ptr);

  /*   92 : Suspend Thread List */
  jvmtiError (JNICALL *SuspendThreadList) (jvmtiEnv* env,
    jint request_count,
    const jthread* request_list,
    jvmtiError* results);

  /*   93 : Resume Thread List */
  jvmtiError (JNICALL *ResumeThreadList) (jvmtiEnv* env,
    jint request_count,
    const jthread* request_list,
    jvmtiError* results);

  /*   94 :  RESERVED */
  void *reserved94;

  /*   95 :  RESERVED */
  void *reserved95;

  /*   96 :  RESERVED */
  void *reserved96;

  /*   97 :  RESERVED */
  void *reserved97;

  /*   98 :  RESERVED */
  void *reserved98;

  /*   99 :  RESERVED */
  void *reserved99;

  /*   100 : Get All Stack Traces */
  jvmtiError (JNICALL *GetAllStackTraces) (jvmtiEnv* env,
    jint max_frame_count,
    jvmtiStackInfo** stack_info_ptr,
    jint* thread_count_ptr);

  /*   101 : Get Thread List Stack Traces */
  jvmtiError (JNICALL *GetThreadListStackTraces) (jvmtiEnv* env,
    jint thread_count,
    const jthread* thread_list,
    jint max_frame_count,
    jvmtiStackInfo** stack_info_ptr);

  /*   102 : Get Thread Local Storage */
  jvmtiError (JNICALL *GetThreadLocalStorage) (jvmtiEnv* env,
    jthread thread,
    void** data_ptr);

  /*   103 : Set Thread Local Storage */
  jvmtiError (JNICALL *SetThreadLocalStorage) (jvmtiEnv* env,
    jthread thread,
    const void* data);

  /*   104 : Get Stack Trace */
  jvmtiError (JNICALL *GetStackTrace) (jvmtiEnv* env,
    jthread thread,
    jint start_depth,
    jint max_frame_count,
    jvmtiFrameInfo* frame_buffer,
    jint* count_ptr);

  /*   105 :  RESERVED */
  void *reserved105;

  /*   106 : Get Tag */
  jvmtiError (JNICALL *GetTag) (jvmtiEnv* env,
    jobject object,
    jlong* tag_ptr);

  /*   107 : Set Tag */
  jvmtiError (JNICALL *SetTag) (jvmtiEnv* env,
    jobject object,
    jlong tag);

  /*   108 : Force Garbage Collection */
  jvmtiError (JNICALL *ForceGarbageCollection) (jvmtiEnv* env);

  /*   109 : Iterate Over Objects Reachable From Object */
  jvmtiError (JNICALL *IterateOverObjectsReachableFromObject) (jvmtiEnv* env,
    jobject object,
    jvmtiObjectReferenceCallback object_reference_callback,
    const void* user_data);

  /*   110 : Iterate Over Reachable Objects */
  jvmtiError (JNICALL *IterateOverReachableObjects) (jvmtiEnv* env,
    jvmtiHeapRootCallback heap_root_callback,
    jvmtiStackReferenceCallback stack_ref_callback,
    jvmtiObjectReferenceCallback object_ref_callback,
    const void* user_data);

  /*   111 : Iterate Over Heap */
  jvmtiError (JNICALL *IterateOverHeap) (jvmtiEnv* env,
    jvmtiHeapObjectFilter object_filter,
    jvmtiHeapObjectCallback heap_object_callback,
    const void* user_data);

  /*   112 : Iterate Over Instances Of Class */
  jvmtiError (JNICALL *IterateOverInstancesOfClass) (jvmtiEnv* env,
    jclass klass,
    jvmtiHeapObjectFilter object_filter,
    jvmtiHeapObjectCallback heap_object_callback,
    const void* user_data);

  /*   113 :  RESERVED */
  void *reserved113;

  /*   114 : Get Objects With Tags */
  jvmtiError (JNICALL *GetObjectsWithTags) (jvmtiEnv* env,
    jint tag_count,
    const jlong* tags,
    jint* count_ptr,
    jobject** object_result_ptr,
    jlong** tag_result_ptr);

  /*   115 : Follow References */
  jvmtiError (JNICALL *FollowReferences) (jvmtiEnv* env,
    jint heap_filter,
    jclass klass,
    jobject initial_object,
    const jvmtiHeapCallbacks* callbacks,
    const void* user_data);

  /*   116 : Iterate Through Heap */
  jvmtiError (JNICALL *IterateThroughHeap) (jvmtiEnv* env,
    jint heap_filter,
    jclass klass,
    const jvmtiHeapCallbacks* callbacks,
    const void* user_data);

  /*   117 :  RESERVED */
  void *reserved117;

  /*   118 :  RESERVED */
  void *reserved118;

  /*   119 :  RESERVED */
  void *reserved119;

  /*   120 : Set JNI Function Table */
  jvmtiError (JNICALL *SetJNIFunctionTable) (jvmtiEnv* env,
    const jniNativeInterface* function_table);

  /*   121 : Get JNI Function Table */
  jvmtiError (JNICALL *GetJNIFunctionTable) (jvmtiEnv* env,
    jniNativeInterface** function_table);

  /*   122 : Set Event Callbacks */
  jvmtiError (JNICALL *SetEventCallbacks) (jvmtiEnv* env,
    const jvmtiEventCallbacks* callbacks,
    jint size_of_callbacks);

  /*   123 : Generate Events */
  jvmtiError (JNICALL *GenerateEvents) (jvmtiEnv* env,
    jvmtiEvent event_type);

  /*   124 : Get Extension Functions */
  jvmtiError (JNICALL *GetExtensionFunctions) (jvmtiEnv* env,
    jint* extension_count_ptr,
    jvmtiExtensionFunctionInfo** extensions);

  /*   125 : Get Extension Events */
  jvmtiError (JNICALL *GetExtensionEvents) (jvmtiEnv* env,
    jint* extension_count_ptr,
    jvmtiExtensionEventInfo** extensions);

  /*   126 : Set Extension Event Callback */
  jvmtiError (JNICALL *SetExtensionEventCallback) (jvmtiEnv* env,
    jint extension_event_index,
    jvmtiExtensionEvent callback);

  /*   127 : Dispose Environment */
  jvmtiError (JNICALL *DisposeEnvironment) (jvmtiEnv* env);

  /*   128 : Get Error Name */
  jvmtiError (JNICALL *GetErrorName) (jvmtiEnv* env,
    jvmtiError error,
    char** name_ptr);

  /*   129 : Get JLocation Format */
  jvmtiError (JNICALL *GetJLocationFormat) (jvmtiEnv* env,
    jvmtiJlocationFormat* format_ptr);

  /*   130 : Get System Properties */
  jvmtiError (JNICALL *GetSystemProperties) (jvmtiEnv* env,
    jint* count_ptr,
    char*** property_ptr);

  /*   131 : Get System Property */
  jvmtiError (JNICALL *GetSystemProperty) (jvmtiEnv* env,
    const char* property,
    char** value_ptr);

  /*   132 : Set System Property */
  jvmtiError (JNICALL *SetSystemProperty) (jvmtiEnv* env,
    const char* property,
    const char* value);

  /*   133 : Get Phase */
  jvmtiError (JNICALL *GetPhase) (jvmtiEnv* env,
    jvmtiPhase* phase_ptr);

  /*   134 : Get Current Thread CPU Timer Information */
  jvmtiError (JNICALL *GetCurrentThreadCpuTimerInfo) (jvmtiEnv* env,
    jvmtiTimerInfo* info_ptr);

  /*   135 : Get Current Thread CPU Time */
  jvmtiError (JNICALL *GetCurrentThreadCpuTime) (jvmtiEnv* env,
    jlong* nanos_ptr);

  /*   136 : Get Thread CPU Timer Information */
  jvmtiError (JNICALL *GetThreadCpuTimerInfo) (jvmtiEnv* env,
    jvmtiTimerInfo* info_ptr);

  /*   137 : Get Thread CPU Time */
  jvmtiError (JNICALL *GetThreadCpuTime) (jvmtiEnv* env,
    jthread thread,
    jlong* nanos_ptr);

  /*   138 : Get Timer Information */
  jvmtiError (JNICALL *GetTimerInfo) (jvmtiEnv* env,
    jvmtiTimerInfo* info_ptr);

  /*   139 : Get Time */
  jvmtiError (JNICALL *GetTime) (jvmtiEnv* env,
    jlong* nanos_ptr);

  /*   140 : Get Potential Capabilities */
  jvmtiError (JNICALL *GetPotentialCapabilities) (jvmtiEnv* env,
    jvmtiCapabilities* capabilities_ptr);

  /*   141 :  RESERVED */
  void *reserved141;

  /*   142 : Add Capabilities */
  jvmtiError (JNICALL *AddCapabilities) (jvmtiEnv* env,
    const jvmtiCapabilities* capabilities_ptr);

  /*   143 : Relinquish Capabilities */
  jvmtiError (JNICALL *RelinquishCapabilities) (jvmtiEnv* env,
    const jvmtiCapabilities* capabilities_ptr);

  /*   144 : Get Available Processors */
  jvmtiError (JNICALL *GetAvailableProcessors) (jvmtiEnv* env,
    jint* processor_count_ptr);

  /*   145 : Get Class Version Numbers */
  jvmtiError (JNICALL *GetClassVersionNumbers) (jvmtiEnv* env,
    jclass klass,
    jint* minor_version_ptr,
    jint* major_version_ptr);

  /*   146 : Get Constant Pool */
  jvmtiError (JNICALL *GetConstantPool) (jvmtiEnv* env,
    jclass klass,
    jint* constant_pool_count_ptr,
    jint* constant_pool_byte_count_ptr,
    unsigned char** constant_pool_bytes_ptr);

  /*   147 : Get Environment Local Storage */
  jvmtiError (JNICALL *GetEnvironmentLocalStorage) (jvmtiEnv* env,
    void** data_ptr);

  /*   148 : Set Environment Local Storage */
  jvmtiError (JNICALL *SetEnvironmentLocalStorage) (jvmtiEnv* env,
    const void* data);

  /*   149 : Add To Bootstrap Class Loader Search */
  jvmtiError (JNICALL *AddToBootstrapClassLoaderSearch) (jvmtiEnv* env,
    const char* segment);

  /*   150 : Set Verbose Flag */
  jvmtiError (JNICALL *SetVerboseFlag) (jvmtiEnv* env,
    jvmtiVerboseFlag flag,
    jboolean value);

  /*   151 : Add To System Class Loader Search */
  jvmtiError (JNICALL *AddToSystemClassLoaderSearch) (jvmtiEnv* env,
    const char* segment);

  /*   152 : Retransform Classes */
  jvmtiError (JNICALL *RetransformClasses) (jvmtiEnv* env,
    jint class_count,
    const jclass* classes);

  /*   153 : Get Owned Monitor Stack Depth Info */
  jvmtiError (JNICALL *GetOwnedMonitorStackDepthInfo) (jvmtiEnv* env,
    jthread thread,
    jint* monitor_info_count_ptr,
    jvmtiMonitorStackDepthInfo** monitor_info_ptr);

  /*   154 : Get Object Size */
  jvmtiError (JNICALL *GetObjectSize) (jvmtiEnv* env,
    jobject object,
    jlong* size_ptr);

  /*   155 : Get Local Instance */
  jvmtiError (JNICALL *GetLocalInstance) (jvmtiEnv* env,
    jthread thread,
    jint depth,
    jobject* value_ptr);

} jvmtiInterface_1;

struct _jvmtiEnv {
    const struct jvmtiInterface_1_ *functions;
#ifdef __cplusplus


  jvmtiError Allocate(jlong size,
            unsigned char** mem_ptr) {
    return functions->Allocate(this, size, mem_ptr);
  }

  jvmtiError Deallocate(unsigned char* mem) {
    return functions->Deallocate(this, mem);
  }

  jvmtiError GetThreadState(jthread thread,
            jint* thread_state_ptr) {
    return functions->GetThreadState(this, thread, thread_state_ptr);
  }

  jvmtiError GetCurrentThread(jthread* thread_ptr) {
    return functions->GetCurrentThread(this, thread_ptr);
  }

  jvmtiError GetAllThreads(jint* threads_count_ptr,
            jthread** threads_ptr) {
    return functions->GetAllThreads(this, threads_count_ptr, threads_ptr);
  }

  jvmtiError SuspendThread(jthread thread) {
    return functions->SuspendThread(this, thread);
  }

  jvmtiError SuspendThreadList(jint request_count,
            const jthread* request_list,
            jvmtiError* results) {
    return functions->SuspendThreadList(this, request_count, request_list, results);
  }

  jvmtiError ResumeThread(jthread thread) {
    return functions->ResumeThread(this, thread);
  }

  jvmtiError ResumeThreadList(jint request_count,
            const jthread* request_list,
            jvmtiError* results) {
    return functions->ResumeThreadList(this, request_count, request_list, results);
  }

  jvmtiError StopThread(jthread thread,
            jobject exception) {
    return functions->StopThread(this, thread, exception);
  }

  jvmtiError InterruptThread(jthread thread) {
    return functions->InterruptThread(this, thread);
  }

  jvmtiError GetThreadInfo(jthread thread,
            jvmtiThreadInfo* info_ptr) {
    return functions->GetThreadInfo(this, thread, info_ptr);
  }

  jvmtiError GetOwnedMonitorInfo(jthread thread,
            jint* owned_monitor_count_ptr,
            jobject** owned_monitors_ptr) {
    return functions->GetOwnedMonitorInfo(this, thread, owned_monitor_count_ptr, owned_monitors_ptr);
  }

  jvmtiError GetOwnedMonitorStackDepthInfo(jthread thread,
            jint* monitor_info_count_ptr,
            jvmtiMonitorStackDepthInfo** monitor_info_ptr) {
    return functions->GetOwnedMonitorStackDepthInfo(this, thread, monitor_info_count_ptr, monitor_info_ptr);
  }

  jvmtiError GetCurrentContendedMonitor(jthread thread,
            jobject* monitor_ptr) {
    return functions->GetCurrentContendedMonitor(this, thread, monitor_ptr);
  }

  jvmtiError RunAgentThread(jthread thread,
            jvmtiStartFunction proc,
            const void* arg,
            jint priority) {
    return functions->RunAgentThread(this, thread, proc, arg, priority);
  }

  jvmtiError SetThreadLocalStorage(jthread thread,
            const void* data) {
    return functions->SetThreadLocalStorage(this, thread, data);
  }

  jvmtiError GetThreadLocalStorage(jthread thread,
            void** data_ptr) {
    return functions->GetThreadLocalStorage(this, thread, data_ptr);
  }

  jvmtiError GetTopThreadGroups(jint* group_count_ptr,
            jthreadGroup** groups_ptr) {
    return functions->GetTopThreadGroups(this, group_count_ptr, groups_ptr);
  }

  jvmtiError GetThreadGroupInfo(jthreadGroup group,
            jvmtiThreadGroupInfo* info_ptr) {
    return functions->GetThreadGroupInfo(this, group, info_ptr);
  }

  jvmtiError GetThreadGroupChildren(jthreadGroup group,
            jint* thread_count_ptr,
            jthread** threads_ptr,
            jint* group_count_ptr,
            jthreadGroup** groups_ptr) {
    return functions->GetThreadGroupChildren(this, group, thread_count_ptr, threads_ptr, group_count_ptr, groups_ptr);
  }

  jvmtiError GetStackTrace(jthread thread,
            jint start_depth,
            jint max_frame_count,
            jvmtiFrameInfo* frame_buffer,
            jint* count_ptr) {
    return functions->GetStackTrace(this, thread, start_depth, max_frame_count, frame_buffer, count_ptr);
  }

  jvmtiError GetAllStackTraces(jint max_frame_count,
            jvmtiStackInfo** stack_info_ptr,
            jint* thread_count_ptr) {
    return functions->GetAllStackTraces(this, max_frame_count, stack_info_ptr, thread_count_ptr);
  }

  jvmtiError GetThreadListStackTraces(jint thread_count,
            const jthread* thread_list,
            jint max_frame_count,
            jvmtiStackInfo** stack_info_ptr) {
    return functions->GetThreadListStackTraces(this, thread_count, thread_list, max_frame_count, stack_info_ptr);
  }

  jvmtiError GetFrameCount(jthread thread,
            jint* count_ptr) {
    return functions->GetFrameCount(this, thread, count_ptr);
  }

  jvmtiError PopFrame(jthread thread) {
    return functions->PopFrame(this, thread);
  }

  jvmtiError GetFrameLocation(jthread thread,
            jint depth,
            jmethodID* method_ptr,
            jlocation* location_ptr) {
    return functions->GetFrameLocation(this, thread, depth, method_ptr, location_ptr);
  }

  jvmtiError NotifyFramePop(jthread thread,
            jint depth) {
    return functions->NotifyFramePop(this, thread, depth);
  }

  jvmtiError ForceEarlyReturnObject(jthread thread,
            jobject value) {
    return functions->ForceEarlyReturnObject(this, thread, value);
  }

  jvmtiError ForceEarlyReturnInt(jthread thread,
            jint value) {
    return functions->ForceEarlyReturnInt(this, thread, value);
  }

  jvmtiError ForceEarlyReturnLong(jthread thread,
            jlong value) {
    return functions->ForceEarlyReturnLong(this, thread, value);
  }

  jvmtiError ForceEarlyReturnFloat(jthread thread,
            jfloat value) {
    return functions->ForceEarlyReturnFloat(this, thread, value);
  }

  jvmtiError ForceEarlyReturnDouble(jthread thread,
            jdouble value) {
    return functions->ForceEarlyReturnDouble(this, thread, value);
  }

  jvmtiError ForceEarlyReturnVoid(jthread thread) {
    return functions->ForceEarlyReturnVoid(this, thread);
  }

  jvmtiError FollowReferences(jint heap_filter,
            jclass klass,
            jobject initial_object,
            const jvmtiHeapCallbacks* callbacks,
            const void* user_data) {
    return functions->FollowReferences(this, heap_filter, klass, initial_object, callbacks, user_data);
  }

  jvmtiError IterateThroughHeap(jint heap_filter,
            jclass klass,
            const jvmtiHeapCallbacks* callbacks,
            const void* user_data) {
    return functions->IterateThroughHeap(this, heap_filter, klass, callbacks, user_data);
  }

  jvmtiError GetTag(jobject object,
            jlong* tag_ptr) {
    return functions->GetTag(this, object, tag_ptr);
  }

  jvmtiError SetTag(jobject object,
            jlong tag) {
    return functions->SetTag(this, object, tag);
  }

  jvmtiError GetObjectsWithTags(jint tag_count,
            const jlong* tags,
            jint* count_ptr,
            jobject** object_result_ptr,
            jlong** tag_result_ptr) {
    return functions->GetObjectsWithTags(this, tag_count, tags, count_ptr, object_result_ptr, tag_result_ptr);
  }

  jvmtiError ForceGarbageCollection() {
    return functions->ForceGarbageCollection(this);
  }

  jvmtiError IterateOverObjectsReachableFromObject(jobject object,
            jvmtiObjectReferenceCallback object_reference_callback,
            const void* user_data) {
    return functions->IterateOverObjectsReachableFromObject(this, object, object_reference_callback, user_data);
  }

  jvmtiError IterateOverReachableObjects(jvmtiHeapRootCallback heap_root_callback,
            jvmtiStackReferenceCallback stack_ref_callback,
            jvmtiObjectReferenceCallback object_ref_callback,
            const void* user_data) {
    return functions->IterateOverReachableObjects(this, heap_root_callback, stack_ref_callback, object_ref_callback, user_data);
  }

  jvmtiError IterateOverHeap(jvmtiHeapObjectFilter object_filter,
            jvmtiHeapObjectCallback heap_object_callback,
            const void* user_data) {
    return functions->IterateOverHeap(this, object_filter, heap_object_callback, user_data);
  }

  jvmtiError IterateOverInstancesOfClass(jclass klass,
            jvmtiHeapObjectFilter object_filter,
            jvmtiHeapObjectCallback heap_object_callback,
            const void* user_data) {
    return functions->IterateOverInstancesOfClass(this, klass, object_filter, heap_object_callback, user_data);
  }

  jvmtiError GetLocalObject(jthread thread,
            jint depth,
            jint slot,
            jobject* value_ptr) {
    return functions->GetLocalObject(this, thread, depth, slot, value_ptr);
  }

  jvmtiError GetLocalInstance(jthread thread,
            jint depth,
            jobject* value_ptr) {
    return functions->GetLocalInstance(this, thread, depth, value_ptr);
  }

  jvmtiError GetLocalInt(jthread thread,
            jint depth,
            jint slot,
            jint* value_ptr) {
    return functions->GetLocalInt(this, thread, depth, slot, value_ptr);
  }

  jvmtiError GetLocalLong(jthread thread,
            jint depth,
            jint slot,
            jlong* value_ptr) {
    return functions->GetLocalLong(this, thread, depth, slot, value_ptr);
  }

  jvmtiError GetLocalFloat(jthread thread,
            jint depth,
            jint slot,
            jfloat* value_ptr) {
    return functions->GetLocalFloat(this, thread, depth, slot, value_ptr);
  }

  jvmtiError GetLocalDouble(jthread thread,
            jint depth,
            jint slot,
            jdouble* value_ptr) {
    return functions->GetLocalDouble(this, thread, depth, slot, value_ptr);
  }

  jvmtiError SetLocalObject(jthread thread,
            jint depth,
            jint slot,
            jobject value) {
    return functions->SetLocalObject(this, thread, depth, slot, value);
  }

  jvmtiError SetLocalInt(jthread thread,
            jint depth,
            jint slot,
            jint value) {
    return functions->SetLocalInt(this, thread, depth, slot, value);
  }

  jvmtiError SetLocalLong(jthread thread,
            jint depth,
            jint slot,
            jlong value) {
    return functions->SetLocalLong(this, thread, depth, slot, value);
  }

  jvmtiError SetLocalFloat(jthread thread,
            jint depth,
            jint slot,
            jfloat value) {
    return functions->SetLocalFloat(this, thread, depth, slot, value);
  }

  jvmtiError SetLocalDouble(jthread thread,
            jint depth,
            jint slot,
            jdouble value) {
    return functions->SetLocalDouble(this, thread, depth, slot, value);
  }

  jvmtiError SetBreakpoint(jmethodID method,
            jlocation location) {
    return functions->SetBreakpoint(this, method, location);
  }

  jvmtiError ClearBreakpoint(jmethodID method,
            jlocation location) {
    return functions->ClearBreakpoint(this, method, location);
  }

  jvmtiError SetFieldAccessWatch(jclass klass,
            jfieldID field) {
    return functions->SetFieldAccessWatch(this, klass, field);
  }

  jvmtiError ClearFieldAccessWatch(jclass klass,
            jfieldID field) {
    return functions->ClearFieldAccessWatch(this, klass, field);
  }

  jvmtiError SetFieldModificationWatch(jclass klass,
            jfieldID field) {
    return functions->SetFieldModificationWatch(this, klass, field);
  }

  jvmtiError ClearFieldModificationWatch(jclass klass,
            jfieldID field) {
    return functions->ClearFieldModificationWatch(this, klass, field);
  }

  jvmtiError GetLoadedClasses(jint* class_count_ptr,
            jclass** classes_ptr) {
    return functions->GetLoadedClasses(this, class_count_ptr, classes_ptr);
  }

  jvmtiError GetClassLoaderClasses(jobject initiating_loader,
            jint* class_count_ptr,
            jclass** classes_ptr) {
    return functions->GetClassLoaderClasses(this, initiating_loader, class_count_ptr, classes_ptr);
  }

  jvmtiError GetClassSignature(jclass klass,
            char** signature_ptr,
            char** generic_ptr) {
    return functions->GetClassSignature(this, klass, signature_ptr, generic_ptr);
  }

  jvmtiError GetClassStatus(jclass klass,
            jint* status_ptr) {
    return functions->GetClassStatus(this, klass, status_ptr);
  }

  jvmtiError GetSourceFileName(jclass klass,
            char** source_name_ptr) {
    return functions->GetSourceFileName(this, klass, source_name_ptr);
  }

  jvmtiError GetClassModifiers(jclass klass,
            jint* modifiers_ptr) {
    return functions->GetClassModifiers(this, klass, modifiers_ptr);
  }

  jvmtiError GetClassMethods(jclass klass,
            jint* method_count_ptr,
            jmethodID** methods_ptr) {
    return functions->GetClassMethods(this, klass, method_count_ptr, methods_ptr);
  }

  jvmtiError GetClassFields(jclass klass,
            jint* field_count_ptr,
            jfieldID** fields_ptr) {
    return functions->GetClassFields(this, klass, field_count_ptr, fields_ptr);
  }

  jvmtiError GetImplementedInterfaces(jclass klass,
            jint* interface_count_ptr,
            jclass** interfaces_ptr) {
    return functions->GetImplementedInterfaces(this, klass, interface_count_ptr, interfaces_ptr);
  }

  jvmtiError GetClassVersionNumbers(jclass klass,
            jint* minor_version_ptr,
            jint* major_version_ptr) {
    return functions->GetClassVersionNumbers(this, klass, minor_version_ptr, major_version_ptr);
  }

  jvmtiError GetConstantPool(jclass klass,
            jint* constant_pool_count_ptr,
            jint* constant_pool_byte_count_ptr,
            unsigned char** constant_pool_bytes_ptr) {
    return functions->GetConstantPool(this, klass, constant_pool_count_ptr, constant_pool_byte_count_ptr, constant_pool_bytes_ptr);
  }

  jvmtiError IsInterface(jclass klass,
            jboolean* is_interface_ptr) {
    return functions->IsInterface(this, klass, is_interface_ptr);
  }

  jvmtiError IsArrayClass(jclass klass,
            jboolean* is_array_class_ptr) {
    return functions->IsArrayClass(this, klass, is_array_class_ptr);
  }

  jvmtiError IsModifiableClass(jclass klass,
            jboolean* is_modifiable_class_ptr) {
    return functions->IsModifiableClass(this, klass, is_modifiable_class_ptr);
  }

  jvmtiError GetClassLoader(jclass klass,
            jobject* classloader_ptr) {
    return functions->GetClassLoader(this, klass, classloader_ptr);
  }

  jvmtiError GetSourceDebugExtension(jclass klass,
            char** source_debug_extension_ptr) {
    return functions->GetSourceDebugExtension(this, klass, source_debug_extension_ptr);
  }

  jvmtiError RetransformClasses(jint class_count,
            const jclass* classes) {
    return functions->RetransformClasses(this, class_count, classes);
  }

  jvmtiError RedefineClasses(jint class_count,
            const jvmtiClassDefinition* class_definitions) {
    return functions->RedefineClasses(this, class_count, class_definitions);
  }

  jvmtiError GetObjectSize(jobject object,
            jlong* size_ptr) {
    return functions->GetObjectSize(this, object, size_ptr);
  }

  jvmtiError GetObjectHashCode(jobject object,
            jint* hash_code_ptr) {
    return functions->GetObjectHashCode(this, object, hash_code_ptr);
  }

  jvmtiError GetObjectMonitorUsage(jobject object,
            jvmtiMonitorUsage* info_ptr) {
    return functions->GetObjectMonitorUsage(this, object, info_ptr);
  }

  jvmtiError GetFieldName(jclass klass,
            jfieldID field,
            char** name_ptr,
            char** signature_ptr,
            char** generic_ptr) {
    return functions->GetFieldName(this, klass, field, name_ptr, signature_ptr, generic_ptr);
  }

  jvmtiError GetFieldDeclaringClass(jclass klass,
            jfieldID field,
            jclass* declaring_class_ptr) {
    return functions->GetFieldDeclaringClass(this, klass, field, declaring_class_ptr);
  }

  jvmtiError GetFieldModifiers(jclass klass,
            jfieldID field,
            jint* modifiers_ptr) {
    return functions->GetFieldModifiers(this, klass, field, modifiers_ptr);
  }

  jvmtiError IsFieldSynthetic(jclass klass,
            jfieldID field,
            jboolean* is_synthetic_ptr) {
    return functions->IsFieldSynthetic(this, klass, field, is_synthetic_ptr);
  }

  jvmtiError GetMethodName(jmethodID method,
            char** name_ptr,
            char** signature_ptr,
            char** generic_ptr) {
    return functions->GetMethodName(this, method, name_ptr, signature_ptr, generic_ptr);
  }

  jvmtiError GetMethodDeclaringClass(jmethodID method,
            jclass* declaring_class_ptr) {
    return functions->GetMethodDeclaringClass(this, method, declaring_class_ptr);
  }

  jvmtiError GetMethodModifiers(jmethodID method,
            jint* modifiers_ptr) {
    return functions->GetMethodModifiers(this, method, modifiers_ptr);
  }

  jvmtiError GetMaxLocals(jmethodID method,
            jint* max_ptr) {
    return functions->GetMaxLocals(this, method, max_ptr);
  }

  jvmtiError GetArgumentsSize(jmethodID method,
            jint* size_ptr) {
    return functions->GetArgumentsSize(this, method, size_ptr);
  }

  jvmtiError GetLineNumberTable(jmethodID method,
            jint* entry_count_ptr,
            jvmtiLineNumberEntry** table_ptr) {
    return functions->GetLineNumberTable(this, method, entry_count_ptr, table_ptr);
  }

  jvmtiError GetMethodLocation(jmethodID method,
            jlocation* start_location_ptr,
            jlocation* end_location_ptr) {
    return functions->GetMethodLocation(this, method, start_location_ptr, end_location_ptr);
  }

  jvmtiError GetLocalVariableTable(jmethodID method,
            jint* entry_count_ptr,
            jvmtiLocalVariableEntry** table_ptr) {
    return functions->GetLocalVariableTable(this, method, entry_count_ptr, table_ptr);
  }

  jvmtiError GetBytecodes(jmethodID method,
            jint* bytecode_count_ptr,
            unsigned char** bytecodes_ptr) {
    return functions->GetBytecodes(this, method, bytecode_count_ptr, bytecodes_ptr);
  }

  jvmtiError IsMethodNative(jmethodID method,
            jboolean* is_native_ptr) {
    return functions->IsMethodNative(this, method, is_native_ptr);
  }

  jvmtiError IsMethodSynthetic(jmethodID method,
            jboolean* is_synthetic_ptr) {
    return functions->IsMethodSynthetic(this, method, is_synthetic_ptr);
  }

  jvmtiError IsMethodObsolete(jmethodID method,
            jboolean* is_obsolete_ptr) {
    return functions->IsMethodObsolete(this, method, is_obsolete_ptr);
  }

  jvmtiError SetNativeMethodPrefix(const char* prefix) {
    return functions->SetNativeMethodPrefix(this, prefix);
  }

  jvmtiError SetNativeMethodPrefixes(jint prefix_count,
            char** prefixes) {
    return functions->SetNativeMethodPrefixes(this, prefix_count, prefixes);
  }

  jvmtiError CreateRawMonitor(const char* name,
            jrawMonitorID* monitor_ptr) {
    return functions->CreateRawMonitor(this, name, monitor_ptr);
  }

  jvmtiError DestroyRawMonitor(jrawMonitorID monitor) {
    return functions->DestroyRawMonitor(this, monitor);
  }

  jvmtiError RawMonitorEnter(jrawMonitorID monitor) {
    return functions->RawMonitorEnter(this, monitor);
  }

  jvmtiError RawMonitorExit(jrawMonitorID monitor) {
    return functions->RawMonitorExit(this, monitor);
  }

  jvmtiError RawMonitorWait(jrawMonitorID monitor,
            jlong millis) {
    return functions->RawMonitorWait(this, monitor, millis);
  }

  jvmtiError RawMonitorNotify(jrawMonitorID monitor) {
    return functions->RawMonitorNotify(this, monitor);
  }

  jvmtiError RawMonitorNotifyAll(jrawMonitorID monitor) {
    return functions->RawMonitorNotifyAll(this, monitor);
  }

  jvmtiError SetJNIFunctionTable(const jniNativeInterface* function_table) {
    return functions->SetJNIFunctionTable(this, function_table);
  }

  jvmtiError GetJNIFunctionTable(jniNativeInterface** function_table) {
    return functions->GetJNIFunctionTable(this, function_table);
  }

  jvmtiError SetEventCallbacks(const jvmtiEventCallbacks* callbacks,
            jint size_of_callbacks) {
    return functions->SetEventCallbacks(this, callbacks, size_of_callbacks);
  }

  jvmtiError SetEventNotificationMode(jvmtiEventMode mode,
            jvmtiEvent event_type,
            jthread event_thread,
             ...) {
    return functions->SetEventNotificationMode(this, mode, event_type, event_thread);
  }

  jvmtiError GenerateEvents(jvmtiEvent event_type) {
    return functions->GenerateEvents(this, event_type);
  }

  jvmtiError GetExtensionFunctions(jint* extension_count_ptr,
            jvmtiExtensionFunctionInfo** extensions) {
    return functions->GetExtensionFunctions(this, extension_count_ptr, extensions);
  }

  jvmtiError GetExtensionEvents(jint* extension_count_ptr,
            jvmtiExtensionEventInfo** extensions) {
    return functions->GetExtensionEvents(this, extension_count_ptr, extensions);
  }

  jvmtiError SetExtensionEventCallback(jint extension_event_index,
            jvmtiExtensionEvent callback) {
    return functions->SetExtensionEventCallback(this, extension_event_index, callback);
  }

  jvmtiError GetPotentialCapabilities(jvmtiCapabilities* capabilities_ptr) {
    return functions->GetPotentialCapabilities(this, capabilities_ptr);
  }

  jvmtiError AddCapabilities(const jvmtiCapabilities* capabilities_ptr) {
    return functions->AddCapabilities(this, capabilities_ptr);
  }

  jvmtiError RelinquishCapabilities(const jvmtiCapabilities* capabilities_ptr) {
    return functions->RelinquishCapabilities(this, capabilities_ptr);
  }

  jvmtiError GetCapabilities(jvmtiCapabilities* capabilities_ptr) {
    return functions->GetCapabilities(this, capabilities_ptr);
  }

  jvmtiError GetCurrentThreadCpuTimerInfo(jvmtiTimerInfo* info_ptr) {
    return functions->GetCurrentThreadCpuTimerInfo(this, info_ptr);
  }

  jvmtiError GetCurrentThreadCpuTime(jlong* nanos_ptr) {
    return functions->GetCurrentThreadCpuTime(this, nanos_ptr);
  }

  jvmtiError GetThreadCpuTimerInfo(jvmtiTimerInfo* info_ptr) {
    return functions->GetThreadCpuTimerInfo(this, info_ptr);
  }

  jvmtiError GetThreadCpuTime(jthread thread,
            jlong* nanos_ptr) {
    return functions->GetThreadCpuTime(this, thread, nanos_ptr);
  }

  jvmtiError GetTimerInfo(jvmtiTimerInfo* info_ptr) {
    return functions->GetTimerInfo(this, info_ptr);
  }

  jvmtiError GetTime(jlong* nanos_ptr) {
    return functions->GetTime(this, nanos_ptr);
  }

  jvmtiError GetAvailableProcessors(jint* processor_count_ptr) {
    return functions->GetAvailableProcessors(this, processor_count_ptr);
  }

  jvmtiError AddToBootstrapClassLoaderSearch(const char* segment) {
    return functions->AddToBootstrapClassLoaderSearch(this, segment);
  }

  jvmtiError AddToSystemClassLoaderSearch(const char* segment) {
    return functions->AddToSystemClassLoaderSearch(this, segment);
  }

  jvmtiError GetSystemProperties(jint* count_ptr,
            char*** property_ptr) {
    return functions->GetSystemProperties(this, count_ptr, property_ptr);
  }

  jvmtiError GetSystemProperty(const char* property,
            char** value_ptr) {
    return functions->GetSystemProperty(this, property, value_ptr);
  }

  jvmtiError SetSystemProperty(const char* property,
            const char* value) {
    return functions->SetSystemProperty(this, property, value);
  }

  jvmtiError GetPhase(jvmtiPhase* phase_ptr) {
    return functions->GetPhase(this, phase_ptr);
  }

  jvmtiError DisposeEnvironment() {
    return functions->DisposeEnvironment(this);
  }

  jvmtiError SetEnvironmentLocalStorage(const void* data) {
    return functions->SetEnvironmentLocalStorage(this, data);
  }

  jvmtiError GetEnvironmentLocalStorage(void** data_ptr) {
    return functions->GetEnvironmentLocalStorage(this, data_ptr);
  }

  jvmtiError GetVersionNumber(jint* version_ptr) {
    return functions->GetVersionNumber(this, version_ptr);
  }

  jvmtiError GetErrorName(jvmtiError error,
            char** name_ptr) {
    return functions->GetErrorName(this, error, name_ptr);
  }

  jvmtiError SetVerboseFlag(jvmtiVerboseFlag flag,
            jboolean value) {
    return functions->SetVerboseFlag(this, flag, value);
  }

  jvmtiError GetJLocationFormat(jvmtiJlocationFormat* format_ptr) {
    return functions->GetJLocationFormat(this, format_ptr);
  }

#endif /* __cplusplus */
};


#ifdef __cplusplus
} /* extern "C" */
#endif /* __cplusplus */

#endif /* !_JAVA_JVMTI_H_ */


```

`Avanguard/JNI/include/win32/jni_md.h`:

```h
/*
 * Copyright (c) 1996, 1998, Oracle and/or its affiliates. All rights reserved.
 * ORACLE PROPRIETARY/CONFIDENTIAL. Use is subject to license terms.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 */

#ifndef _JAVASOFT_JNI_MD_H_
#define _JAVASOFT_JNI_MD_H_

#define JNIEXPORT __declspec(dllexport)
#define JNIIMPORT __declspec(dllimport)
#define JNICALL __stdcall

typedef long jint;
typedef __int64 jlong;
typedef signed char jbyte;

#endif /* !_JAVASOFT_JNI_MD_H_ */

```

`Avanguard/MinHook/MinHook.h`:

```h
/*
 *  MinHook - The Minimalistic API Hooking Library for x64/x86
 *  Copyright (C) 2009-2017 Tsuda Kageyu.
 *  All rights reserved.
 *
 *  Redistribution and use in source and binary forms, with or without
 *  modification, are permitted provided that the following conditions
 *  are met:
 *
 *   1. Redistributions of source code must retain the above copyright
 *      notice, this list of conditions and the following disclaimer.
 *   2. Redistributions in binary form must reproduce the above copyright
 *      notice, this list of conditions and the following disclaimer in the
 *      documentation and/or other materials provided with the distribution.
 *
 *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 *  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
 *  TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
 *  PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER
 *  OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 *  EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 *  PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 *  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
 *  LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 *  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 *  SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

#pragma once

#if !(defined _M_IX86) && !(defined _M_X64) && !(defined __i386__) && !(defined __x86_64__)
    #error MinHook supports only x86 and x64 systems.
#endif

#include <windows.h>

// MinHook Error Codes.
typedef enum MH_STATUS
{
    // Unknown error. Should not be returned.
    MH_UNKNOWN = -1,

    // Successful.
    MH_OK = 0,

    // MinHook is already initialized.
    MH_ERROR_ALREADY_INITIALIZED,

    // MinHook is not initialized yet, or already uninitialized.
    MH_ERROR_NOT_INITIALIZED,

    // The hook for the specified target function is already created.
    MH_ERROR_ALREADY_CREATED,

    // The hook for the specified target function is not created yet.
    MH_ERROR_NOT_CREATED,

    // The hook for the specified target function is already enabled.
    MH_ERROR_ENABLED,

    // The hook for the specified target function is not enabled yet, or already
    // disabled.
    MH_ERROR_DISABLED,

    // The specified pointer is invalid. It points the address of non-allocated
    // and/or non-executable region.
    MH_ERROR_NOT_EXECUTABLE,

    // The specified target function cannot be hooked.
    MH_ERROR_UNSUPPORTED_FUNCTION,

    // Failed to allocate memory.
    MH_ERROR_MEMORY_ALLOC,

    // Failed to change the memory protection.
    MH_ERROR_MEMORY_PROTECT,

    // The specified module is not loaded.
    MH_ERROR_MODULE_NOT_FOUND,

    // The specified function is not found.
    MH_ERROR_FUNCTION_NOT_FOUND
}
MH_STATUS;

// Can be passed as a parameter to MH_EnableHook, MH_DisableHook,
// MH_QueueEnableHook or MH_QueueDisableHook.
#define MH_ALL_HOOKS NULL

#ifdef __cplusplus
extern "C" {
#endif

    // Initialize the MinHook library. You must call this function EXACTLY ONCE
    // at the beginning of your program.
    MH_STATUS WINAPI MH_Initialize(VOID);

    // Uninitialize the MinHook library. You must call this function EXACTLY
    // ONCE at the end of your program.
    MH_STATUS WINAPI MH_Uninitialize(VOID);

    // Creates a Hook for the specified target function, in disabled state.
    // Parameters:
    //   pTarget    [in]  A pointer to the target function, which will be
    //                    overridden by the detour function.
    //   pDetour    [in]  A pointer to the detour function, which will override
    //                    the target function.
    //   ppOriginal [out] A pointer to the trampoline function, which will be
    //                    used to call the original target function.
    //                    This parameter can be NULL.
    MH_STATUS WINAPI MH_CreateHook(LPVOID pTarget, LPVOID pDetour, LPVOID *ppOriginal);

    // Creates a Hook for the specified API function, in disabled state.
    // Parameters:
    //   pszModule  [in]  A pointer to the loaded module name which contains the
    //                    target function.
    //   pszTarget  [in]  A pointer to the target function name, which will be
    //                    overridden by the detour function.
    //   pDetour    [in]  A pointer to the detour function, which will override
    //                    the target function.
    //   ppOriginal [out] A pointer to the trampoline function, which will be
    //                    used to call the original target function.
    //                    This parameter can be NULL.
    MH_STATUS WINAPI MH_CreateHookApi(
        LPCWSTR pszModule, LPCSTR pszProcName, LPVOID pDetour, LPVOID *ppOriginal);

    // Creates a Hook for the specified API function, in disabled state.
    // Parameters:
    //   pszModule  [in]  A pointer to the loaded module name which contains the
    //                    target function.
    //   pszTarget  [in]  A pointer to the target function name, which will be
    //                    overridden by the detour function.
    //   pDetour    [in]  A pointer to the detour function, which will override
    //                    the target function.
    //   ppOriginal [out] A pointer to the trampoline function, which will be
    //                    used to call the original target function.
    //                    This parameter can be NULL.
    //   ppTarget   [out] A pointer to the target function, which will be used
    //                    with other functions.
    //                    This parameter can be NULL.
    MH_STATUS WINAPI MH_CreateHookApiEx(
        LPCWSTR pszModule, LPCSTR pszProcName, LPVOID pDetour, LPVOID *ppOriginal, LPVOID *ppTarget);

    // Removes an already created hook.
    // Parameters:
    //   pTarget [in] A pointer to the target function.
    MH_STATUS WINAPI MH_RemoveHook(LPVOID pTarget);

    // Enables an already created hook.
    // Parameters:
    //   pTarget [in] A pointer to the target function.
    //                If this parameter is MH_ALL_HOOKS, all created hooks are
    //                enabled in one go.
    MH_STATUS WINAPI MH_EnableHook(LPVOID pTarget);

    // Disables an already created hook.
    // Parameters:
    //   pTarget [in] A pointer to the target function.
    //                If this parameter is MH_ALL_HOOKS, all created hooks are
    //                disabled in one go.
    MH_STATUS WINAPI MH_DisableHook(LPVOID pTarget);

    // Queues to enable an already created hook.
    // Parameters:
    //   pTarget [in] A pointer to the target function.
    //                If this parameter is MH_ALL_HOOKS, all created hooks are
    //                queued to be enabled.
    MH_STATUS WINAPI MH_QueueEnableHook(LPVOID pTarget);

    // Queues to disable an already created hook.
    // Parameters:
    //   pTarget [in] A pointer to the target function.
    //                If this parameter is MH_ALL_HOOKS, all created hooks are
    //                queued to be disabled.
    MH_STATUS WINAPI MH_QueueDisableHook(LPVOID pTarget);

    // Applies all queued changes in one go.
    MH_STATUS WINAPI MH_ApplyQueued(VOID);

    // Translates the MH_STATUS to its name as a string.
    const char * WINAPI MH_StatusToString(MH_STATUS status);

#ifdef __cplusplus
}
#endif


```

`Avanguard/Zydis/Zydis/CommonTypes.h`:

```h
/***************************************************************************************************

  Zyan Disassembler Library (Zydis)

  Original Author : Florian Bernd, Joel Höner

 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.

***************************************************************************************************/

/**
 * @file
 * @brief Includes and defines some default datatypes.
 */

#ifndef ZYDIS_COMMONTYPES_H
#define ZYDIS_COMMONTYPES_H

#include <Zydis/Defines.h>

/* ============================================================================================== */
/* Integer types                                                                                  */
/* ============================================================================================== */

#if !defined(ZYDIS_NO_LIBC)
    // If is LibC present, we use stdint types.
#   include <stdint.h>
#   include <stddef.h>
    typedef uint8_t   ZydisU8;
    typedef uint16_t  ZydisU16;
    typedef uint32_t  ZydisU32;
    typedef uint64_t  ZydisU64;
    typedef int8_t    ZydisI8;
    typedef int16_t   ZydisI16;
    typedef int32_t   ZydisI32;
    typedef int64_t   ZydisI64;
    typedef size_t    ZydisUSize;
    typedef ptrdiff_t ZydisISize;
    typedef uintptr_t ZydisUPointer;
    typedef intptr_t  ZydisIPointer;
#else 
    // No LibC, use compiler built-in types / macros.
#   if defined(ZYDIS_MSVC)
        typedef unsigned __int8  ZydisU8;
        typedef unsigned __int16 ZydisU16;
        typedef unsigned __int32 ZydisU32;
        typedef unsigned __int64 ZydisU64;
        typedef   signed __int8  ZydisI8;
        typedef   signed __int16 ZydisI16;
        typedef   signed __int32 ZydisI32;
        typedef   signed __int64 ZydisI64;
#       if _WIN64                
           typedef ZydisU64      ZydisUSize;
           typedef ZydisI64      ZydisISize;
           typedef ZydisU64      ZydisUPointer;
           typedef ZydisI64      ZydisIPointer;
#       else                     
           typedef ZydisU32      ZydisUSize;
           typedef ZydisI32      ZydisISize;
           typedef ZydisU32      ZydisUPointer;
           typedef ZydisI32      ZydisIPointer;
#       endif                    
#   elif defined(ZYDIS_GNUC)     
        typedef __UINT8_TYPE__   ZydisU8;
        typedef __UINT16_TYPE__  ZydisU16;
        typedef __UINT32_TYPE__  ZydisU32;
        typedef __UINT64_TYPE__  ZydisU64;
        typedef __INT8_TYPE__    ZydisI8;
        typedef __INT16_TYPE__   ZydisI16;
        typedef __INT32_TYPE__   ZydisI32;
        typedef __INT64_TYPE__   ZydisI64;
        typedef __SIZE_TYPE__    ZydisUSize;
        typedef __PTRDIFF_TYPE__ ZydisISize;
        typedef __UINTPTR_TYPE__ ZydisUPointer;
        typedef __INTPTR_TYPE__  ZydisIPointer;
#   else
#       error "Unsupported compiler for no-libc mode."
#   endif
#endif

// Verify size assumptions.
ZYDIS_STATIC_ASSERT(sizeof(ZydisU8      ) == 1            );
ZYDIS_STATIC_ASSERT(sizeof(ZydisU16     ) == 2            );
ZYDIS_STATIC_ASSERT(sizeof(ZydisU32     ) == 4            );
ZYDIS_STATIC_ASSERT(sizeof(ZydisU64     ) == 8            );
ZYDIS_STATIC_ASSERT(sizeof(ZydisI8      ) == 1            );
ZYDIS_STATIC_ASSERT(sizeof(ZydisI16     ) == 2            );
ZYDIS_STATIC_ASSERT(sizeof(ZydisI32     ) == 4            );
ZYDIS_STATIC_ASSERT(sizeof(ZydisI64     ) == 8            );
ZYDIS_STATIC_ASSERT(sizeof(ZydisUSize   ) == sizeof(void*)); // TODO: This one is incorrect!
ZYDIS_STATIC_ASSERT(sizeof(ZydisISize   ) == sizeof(void*)); // TODO: This one is incorrect!
ZYDIS_STATIC_ASSERT(sizeof(ZydisUPointer) == sizeof(void*));
ZYDIS_STATIC_ASSERT(sizeof(ZydisIPointer) == sizeof(void*));

// Verify signedness assumptions (relies on size checks above).
ZYDIS_STATIC_ASSERT((ZydisI8 )-1 >> 1 < (ZydisI8 )((ZydisU8 )-1 >> 1));
ZYDIS_STATIC_ASSERT((ZydisI16)-1 >> 1 < (ZydisI16)((ZydisU16)-1 >> 1));
ZYDIS_STATIC_ASSERT((ZydisI32)-1 >> 1 < (ZydisI32)((ZydisU32)-1 >> 1));
ZYDIS_STATIC_ASSERT((ZydisI64)-1 >> 1 < (ZydisI64)((ZydisU64)-1 >> 1));

/* ============================================================================================== */
/* NULL                                                                                           */
/* ============================================================================================== */

#define ZYDIS_NULL ((void*)0)

/* ============================================================================================== */
/* Boolean                                                                                        */
/* ============================================================================================== */

#define ZYDIS_FALSE 0
#define ZYDIS_TRUE  1

/**
 * @briefs  Defines the @c ZydisBool datatype.
 */
typedef ZydisU8 ZydisBool;

/* ============================================================================================== */

#endif /* ZYDIS_COMMONTYPES_H */

```

`Avanguard/Zydis/Zydis/Decoder.h`:

```h
/***************************************************************************************************

  Zyan Disassembler Library (Zydis)

  Original Author : Florian Bernd

 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.

***************************************************************************************************/

/**
 * @file
 * @brief   Functions for decoding instructions.
 */

#ifndef ZYDIS_DECODER_H
#define ZYDIS_DECODER_H

#include <Zydis/CommonTypes.h>
#include <Zydis/DecoderTypes.h>
#include <Zydis/Defines.h>
#include <Zydis/Status.h>

#ifdef __cplusplus
extern "C" {
#endif

/* ============================================================================================== */
/* Enums and types                                                                                */
/* ============================================================================================== */

/* ---------------------------------------------------------------------------------------------- */
/* Decoder mode                                                                                   */
/* ---------------------------------------------------------------------------------------------- */

/**
 * @brief   Defines the @c ZydisDecoderMode datatype.
 */
typedef ZydisU8 ZydisDecoderMode;

/**
 * @brief   Values that represent decoder-modes.
 */
enum ZydisDecoderModes
{
    /**
     * @brief   Enables minimal instruction decoding without semantic analysis.
     * 
     * This mode provides access to the mnemonic, the instruction-length, the effective 
     * operand-size, the effective address-width, some attributes (e.g. `ZYDIS_ATTRIB_IS_RELATIVE`) 
     * and all of the information in the `raw` field of the `ZydisDecodedInstruction` struct.
     * 
     * Operands, most attributes and other specific information (like AVX info) are not 
     * accessible in this mode.
     * 
     * This mode is NOT enabled by default.
     */
    ZYDIS_DECODER_MODE_MINIMAL,
    /**
     * @brief   Enables the AMD-branch mode.
     * 
     * Intel ignores the operand-size override-prefix (`0x66`) for all branches with 32-bit 
     * immediates and forces the operand-size of the instruction to 64-bit in 64-bit mode.
     * In AMD-branch mode `0x66` is not ignored and changes the operand-size and the size of the
     * immediate to 16-bit.
     * 
     * This mode is NOT enabled by default.
     */
    ZYDIS_DECODER_MODE_AMD_BRANCHES,
    /**
     * @brief   Enables KNC compatibility-mode.
     * 
     * KNC and KNL+ chips are sharing opcodes and encodings for some mask-related instructions.
     * Enable this mode to use the old KNC specifications (different mnemonics, operands, ..).
     * 
     * This mode is NOT enabled by default.
     */
    ZYDIS_DECODER_MODE_KNC,
    /**
     * @brief   Enables the MPX mode.
     * 
     * The MPX isa-extension reuses (overrides) some of the widenop instruction opcodes. 
     * 
     * This mode is enabled by default. 
     */
    ZYDIS_DECODER_MODE_MPX,
    /**
     * @brief   Enables the CET mode.
     * 
     * The CET isa-extension reuses (overrides) some of the widenop instruction opcodes. 
     * 
     * This mode is enabled by default.  
     */
    ZYDIS_DECODER_MODE_CET,
    /**
     * @brief   Enables the LZCNT mode.
     * 
     * The LZCNT isa-extension reuses (overrides) some of the widenop instruction opcodes.
     * 
     * This mode is enabled by default.   
     */
    ZYDIS_DECODER_MODE_LZCNT,
    /**
     * @brief   Enables the TZCNT mode.
     * 
     * The TZCNT isa-extension reuses (overrides) some of the widenop instruction opcodes.  
     * 
     * This mode is enabled by default. 
     */
    ZYDIS_DECODER_MODE_TZCNT,
    /**
     * @brief   Maximum value of this enum.
     */
    ZYDIS_DECODER_MODE_MAX_VALUE = ZYDIS_DECODER_MODE_TZCNT
};

/* ---------------------------------------------------------------------------------------------- */
/* Decoder struct                                                                                 */
/* ---------------------------------------------------------------------------------------------- */

/**
 * @brief   Defines the @c ZydisDecoder struct.
 */
typedef struct ZydisDecoder_
{
    ZydisMachineMode machineMode;
    ZydisAddressWidth addressWidth;
    ZydisBool decoderMode[ZYDIS_DECODER_MODE_MAX_VALUE + 1];
} ZydisDecoder;

/* ---------------------------------------------------------------------------------------------- */

/* ============================================================================================== */
/* Exported functions                                                                             */
/* ============================================================================================== */

/**
 * @brief   Initializes the given @c ZydisDecoder instance.
 *
 * @param   decoder         A pointer to the @c ZydisDecoder instance.
 * @param   machineMode     The machine mode.
 * @param   addressWidth    The address width.
 *
 * @return  A zydis status code.
 */
ZYDIS_EXPORT ZydisStatus ZydisDecoderInit(ZydisDecoder* decoder, ZydisMachineMode machineMode, 
    ZydisAddressWidth addressWidth);

/**
 * @brief   Enables or disables the specified decoder-mode.
 *
 * @param   decoder A pointer to the @c ZydisDecoder instance.
 * @param   mode    The decoder mode.
 * @param   enabled `ZYDIS_TRUE` to enable, or `ZYDIS_FALSE` to disable the specified decoder-mode.
 *
 * @return  A zydis status code.
 */
ZYDIS_EXPORT ZydisStatus ZydisDecoderEnableMode(ZydisDecoder* decoder, ZydisDecoderMode mode,
    ZydisBool enabled);

/**
 * @brief   Decodes the instruction in the given input @c buffer.
 *
 * @param   decoder             A pointer to the @c ZydisDecoder instance.
 * @param   buffer              A pointer to the input buffer.
 * @param   bufferLen           The length of the input buffer.
 * @param   instructionPointer  The instruction-pointer.
 * @param   instruction         A pointer to the @c ZydisDecodedInstruction struct, that receives 
 *                              the details about the decoded instruction.
 *
 * @return  A zydis status code. 
 */
ZYDIS_EXPORT ZydisStatus ZydisDecoderDecodeBuffer(const ZydisDecoder* decoder, 
    const void* buffer, ZydisUSize bufferLen, ZydisU64 instructionPointer, 
    ZydisDecodedInstruction* instruction);

/* ============================================================================================== */

#ifdef __cplusplus
}
#endif

#endif /* ZYDIS_DECODER_H */

```

`Avanguard/Zydis/Zydis/DecoderTypes.h`:

```h
/***************************************************************************************************

  Zyan Disassembler Library (Zydis)

  Original Author : Florian Bernd

 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.

***************************************************************************************************/

/**
 * @file
 * @brief   Defines the basic @c ZydisDecodedInstruction and @c ZydisDecodedOperand structs.
 */

#ifndef ZYDIS_INSTRUCTIONINFO_H
#define ZYDIS_INSTRUCTIONINFO_H

#include <Zydis/CommonTypes.h>
#include <Zydis/MetaInfo.h>
#include <Zydis/Mnemonic.h>
#include <Zydis/Register.h>
#include <Zydis/SharedTypes.h>

#ifdef __cplusplus
extern "C" {
#endif

/* ============================================================================================== */
/* Decoded operand                                                                                */
/* ============================================================================================== */

/* ---------------------------------------------------------------------------------------------- */
/* Memory type                                                                                    */
/* ---------------------------------------------------------------------------------------------- */

/**
 * @brief   Defines the @c ZydisMemoryOperandType datatype.
 */
typedef ZydisU8 ZydisMemoryOperandType;

/**
 * @brief   Values that represent memory-operand types.
 */
enum ZydisMemoryOperandTypes
{
    ZYDIS_MEMOP_TYPE_INVALID,
    /**
     * @brief   Normal memory operand.
     */
    ZYDIS_MEMOP_TYPE_MEM,
    /**
     * @brief   The memory operand is only used for address-generation. No real memory-access is
     *          caused.
     */
    ZYDIS_MEMOP_TYPE_AGEN,
    /**
     * @brief   A memory operand using `SIB` addressing form, where the index register is not used  
     *          in address calculation and scale is ignored. No real memory-access is
     *          caused.
     */
    ZYDIS_MEMOP_TYPE_MIB
};

/* ---------------------------------------------------------------------------------------------- */
/* Decoded operand                                                                                */
/* ---------------------------------------------------------------------------------------------- */

/**
 * @brief   Defines the @c ZydisDecodedOperand struct.
 */
typedef struct ZydisDecodedOperand_
{
    /**
     * @brief   The operand-id.
     */
    ZydisU8 id;
    /**
     * @brief   The type of the operand.
     */
    ZydisOperandType type;
    /**
     * @brief   The visibility of the operand.
     */
    ZydisOperandVisibility visibility;
    /**
     * @brief   The operand-action.
     */
    ZydisOperandAction action; 
    /**
     * @brief   The operand-encoding.
     */
    ZydisOperandEncoding encoding;
    /**
     * @brief   The logical size of the operand (in bits).
     */
    ZydisU16 size; 
    /**
     * @brief   The element-type.
     */
    ZydisElementType elementType;
    /**
     * @brief   The size of a single element.
     */
    ZydisElementSize elementSize;
    /**
     * @brief   The number of elements.
     */
    ZydisU16 elementCount;
    /**
     * @brief   Extended info for register-operands.
     */
    struct
    {
        /**
         * @brief   The register value.
         */
        ZydisRegister value; 
        // TODO: AVX512_4VNNIW MULTISOURCE registers
    } reg;
    /**
     * @brief   Extended info for memory-operands.
     */
    struct
    {
        /**
         * @brief   The type of the memory operand.
         */
        ZydisMemoryOperandType type;
        /**
         * @brief   The segment register.
         */
        ZydisRegister segment;
        /**
         * @brief   The base register.
         */
        ZydisRegister base;
        /**
         * @brief   The index register.
         */
        ZydisRegister index;
        /**
         * @brief   The scale factor.
         */
        ZydisU8 scale;
        /**
         * @brief   Extended info for memory-operands with displacement.
         */
        struct
        {
            /**
             * @brief   Signals, if the displacement value is used.
             */
            ZydisBool hasDisplacement;
            /**
             * @brief   The displacement value
             */
            ZydisI64 value;
        } disp;
    } mem;
    /**
     * @brief   Extended info for pointer-operands.
     */
    struct 
    {
        ZydisU16 segment;
        ZydisU32 offset;
    } ptr;
    /**
     * @brief   Extended info for immediate-operands.
     */
    struct
    {
        /**
         * @brief   Signals, if the immediate value is signed.
         */
        ZydisBool isSigned;
        /**
         * @brief   Signals, if the immediate value contains a relative offset. You can use 
         *          @c ZydisCalcAbsoluteAddress to determine the absolute address value.
         */
        ZydisBool isRelative;
        /**
         * @brief   The immediate value.
         */
        union 
        {
            ZydisU64 u;
            ZydisI64 s;         
        } value;
    } imm;
} ZydisDecodedOperand;

/* ---------------------------------------------------------------------------------------------- */

/* ============================================================================================== */
/* Decoded instruction                                                                            */
/* ============================================================================================== */

/* ---------------------------------------------------------------------------------------------- */
/* Instruction attributes                                                                         */
/* ---------------------------------------------------------------------------------------------- */

/**
 * @brief   Defines the @c ZydisInstructionAttributes datatype.
 */
typedef ZydisU64 ZydisInstructionAttributes;

/**
 * @brief   The instruction has the ModRM byte.
 */
#define ZYDIS_ATTRIB_HAS_MODRM                  0x0000000000000001 // (1 <<  0)
/**
 * @brief   The instruction has the SUB byte.
 */
#define ZYDIS_ATTRIB_HAS_SIB                    0x0000000000000002 // (1 <<  1)
/**
 * @brief   The instruction has the REX prefix.
 */
#define ZYDIS_ATTRIB_HAS_REX                    0x0000000000000004 // (1 <<  2)
/**
 * @brief   The instruction has the XOP prefix.
 */
#define ZYDIS_ATTRIB_HAS_XOP                    0x0000000000000008 // (1 <<  3)
/**
 * @brief   The instruction has the VEX prefix.
 */
#define ZYDIS_ATTRIB_HAS_VEX                    0x0000000000000010 // (1 <<  4)
/**
 * @brief   The instruction has the EVEX prefix.
 */
#define ZYDIS_ATTRIB_HAS_EVEX                   0x0000000000000020 // (1 <<  5)
/**
 * @brief   The instruction has the MVEX prefix.
 */
#define ZYDIS_ATTRIB_HAS_MVEX                   0x0000000000000040 // (1 <<  6)
/**
 * @brief   The instruction has one or more operands with position-relative offsets.
 */
#define ZYDIS_ATTRIB_IS_RELATIVE                0x0000000000000080 // (1 <<  7)
/**
 * @brief   The instruction is privileged.
 *
 * Priviliged instructions are any instructions that require a current ring level below 3.
 */
#define ZYDIS_ATTRIB_IS_PRIVILEGED              0x0000000000000100 // (1 <<  8)

/**
 * @brief   The instruction is a far JMP/CALL/RET.
 */
#define ZYDIS_ATTRIB_IS_FAR_BRANCH              0x0000001000000000 // (1 << 36) // TODO: rebase

/**
 * @brief   The instruction accepts the lock prefix (0xF0). 
 */
#define ZYDIS_ATTRIB_ACCEPTS_LOCK               0x0000000000000200 // (1 <<  9)
/**
 * @brief   The instruction accepts the rep prefix (0xF3). 
 */
#define ZYDIS_ATTRIB_ACCEPTS_REP                0x0000000000000400 // (1 << 10)
/**
 * @brief   The instruction accepts the repe/repz prefix (0xF3). 
 */
#define ZYDIS_ATTRIB_ACCEPTS_REPE               0x0000000000000800 // (1 << 11)
/**
 * @brief   The instruction accepts the repe/repz prefix (0xF3). 
 */
#define ZYDIS_ATTRIB_ACCEPTS_REPZ               0x0000000000000800 // (1 << 11)
/**
 * @brief   The instruction accepts the repne/repnz prefix (0xF2). 
 */
#define ZYDIS_ATTRIB_ACCEPTS_REPNE              0x0000000000001000 // (1 << 12)
/**
 * @brief   The instruction accepts the repne/repnz prefix (0xF2). 
 */
#define ZYDIS_ATTRIB_ACCEPTS_REPNZ              0x0000000000001000 // (1 << 12)
/**
 * @brief   The instruction accepts the bound prefix (0xF2). 
 */
#define ZYDIS_ATTRIB_ACCEPTS_BOUND              0x0000000000002000 // (1 << 13)
/**
 * @brief   The instruction accepts the xacquire prefix (0xF2). 
 */
#define ZYDIS_ATTRIB_ACCEPTS_XACQUIRE           0x0000000000004000 // (1 << 14)
/**
 * @brief   The instruction accepts the xrelease prefix (0xF3). 
 */
#define ZYDIS_ATTRIB_ACCEPTS_XRELEASE           0x0000000000008000 // (1 << 15)
/**
 * @brief   The instruction accepts the xacquire/xrelease prefixes (0xF2, 0xF3) without the
 *          lock-prefix (0x0F).
 */
#define ZYDIS_ATTRIB_ACCEPTS_HLE_WITHOUT_LOCK   0x0000000000010000 // (1 << 16)
/**
 * @brief   The instruction accepts branch hints (0x2E, 0x3E).
 */
#define ZYDIS_ATTRIB_ACCEPTS_BRANCH_HINTS       0x0000000000020000 // (1 << 17)
/**
 * @brief   The instruction accepts segment prefixes (0x2E, 0x36, 0x3E, 0x26, 0x64, 0x65).
 */
#define ZYDIS_ATTRIB_ACCEPTS_SEGMENT            0x0000000000040000 // (1 << 18)
/**
 * @brief   The instruction has the lock prefix (0xF0). 
 */
#define ZYDIS_ATTRIB_HAS_LOCK                   0x0000000000080000 // (1 << 19)
/**
 * @brief   The instruction has the rep prefix (0xF3). 
 */
#define ZYDIS_ATTRIB_HAS_REP                    0x0000000000100000 // (1 << 20)
/**
 * @brief   The instruction has the repe/repz prefix (0xF3). 
 */
#define ZYDIS_ATTRIB_HAS_REPE                   0x0000000000200000 // (1 << 21)
/**
 * @brief   The instruction has the repe/repz prefix (0xF3). 
 */
#define ZYDIS_ATTRIB_HAS_REPZ                   0x0000000000200000 // (1 << 21)
/**
 * @brief   The instruction has the repne/repnz prefix (0xF2). 
 */
#define ZYDIS_ATTRIB_HAS_REPNE                  0x0000000000400000 // (1 << 22)
/**
 * @brief   The instruction has the repne/repnz prefix (0xF2). 
 */
#define ZYDIS_ATTRIB_HAS_REPNZ                  0x0000000000400000 // (1 << 22)
/**
 * @brief   The instruction has the bound prefix (0xF2). 
 */
#define ZYDIS_ATTRIB_HAS_BOUND                  0x0000000000800000 // (1 << 23)
/**
 * @brief   The instruction has the xacquire prefix (0xF2). 
 */
#define ZYDIS_ATTRIB_HAS_XACQUIRE               0x0000000001000000 // (1 << 24)
/**
 * @brief   The instruction has the xrelease prefix (0xF3). 
 */
#define ZYDIS_ATTRIB_HAS_XRELEASE               0x0000000002000000 // (1 << 25)
/**
 * @brief   The instruction has the branch-not-taken hint (0x2E). 
 */
#define ZYDIS_ATTRIB_HAS_BRANCH_NOT_TAKEN       0x0000000004000000 // (1 << 26)
/**
 * @brief   The instruction has the branch-taken hint (0x3E). 
 */
#define ZYDIS_ATTRIB_HAS_BRANCH_TAKEN           0x0000000008000000 // (1 << 27)
/**
 * @brief   The instruction has a segment modifier.
 */
#define ZYDIS_ATTRIB_HAS_SEGMENT                0x00000003F0000000
/**
 * @brief   The instruction has the CS segment modifier (0x2E). 
 */
#define ZYDIS_ATTRIB_HAS_SEGMENT_CS             0x0000000010000000 // (1 << 28)
/**
 * @brief   The instruction has the SS segment modifier (0x36). 
 */
#define ZYDIS_ATTRIB_HAS_SEGMENT_SS             0x0000000020000000 // (1 << 29)
/**
 * @brief   The instruction has the DS segment modifier (0x3E). 
 */
#define ZYDIS_ATTRIB_HAS_SEGMENT_DS             0x0000000040000000 // (1 << 30)
/**
 * @brief   The instruction has the ES segment modifier (0x26). 
 */
#define ZYDIS_ATTRIB_HAS_SEGMENT_ES             0x0000000080000000 // (1 << 31)
/**
 * @brief   The instruction has the FS segment modifier (0x64). 
 */
#define ZYDIS_ATTRIB_HAS_SEGMENT_FS             0x0000000100000000 // (1 << 32)
/**
 * @brief   The instruction has the GS segment modifier (0x65). 
 */
#define ZYDIS_ATTRIB_HAS_SEGMENT_GS             0x0000000200000000 // (1 << 33)
/**
 * @brief   The instruction has the operand-size prefix (0x66). 
 */
#define ZYDIS_ATTRIB_HAS_OPERANDSIZE            0x0000000400000000 // (1 << 34) // TODO: rename
/**
 * @brief   The instruction has the address-size prefix (0x67). 
 */
#define ZYDIS_ATTRIB_HAS_ADDRESSSIZE            0x0000000800000000 // (1 << 35) // TODO: rename

/* ---------------------------------------------------------------------------------------------- */
/* R/E/FLAGS info                                                                                 */
/* ---------------------------------------------------------------------------------------------- */

/**
 * @brief   Defines the @c ZydisCPUFlag datatype.
 */
typedef ZydisU8 ZydisCPUFlag;

/**
 * @brief   Defines the @c ZydisCPUFlagMask datatype.
 */
typedef ZydisU32 ZydisCPUFlagMask;

/**
 * @brief   Values that represent CPU-flags.
 */
enum ZydisCPUFlags
{
    /**
     * @brief   Carry flag.
     */
    ZYDIS_CPUFLAG_CF,
    /**
     * @brief   Parity flag.
     */
    ZYDIS_CPUFLAG_PF,
    /**
     * @brief   Adjust flag.
     */
    ZYDIS_CPUFLAG_AF,
    /**
     * @brief   Zero flag.
     */
    ZYDIS_CPUFLAG_ZF,
    /**
     * @brief   Sign flag.
     */
    ZYDIS_CPUFLAG_SF,
    /**
     * @brief   Trap flag.
     */
    ZYDIS_CPUFLAG_TF,
    /**
     * @brief   Interrupt enable flag.
     */
    ZYDIS_CPUFLAG_IF,
    /**
     * @brief   Direction flag.
     */
    ZYDIS_CPUFLAG_DF,
    /**
     * @brief   Overflow flag.
     */
    ZYDIS_CPUFLAG_OF,
    /**
     * @brief   I/O privilege level flag.
     */
    ZYDIS_CPUFLAG_IOPL,
    /**
     * @brief   Nested task flag.
     */
    ZYDIS_CPUFLAG_NT,
    /**
     * @brief   Resume flag.
     */
    ZYDIS_CPUFLAG_RF,
    /**
     * @brief   Virtual 8086 mode flag.
     */
    ZYDIS_CPUFLAG_VM,
    /**
     * @brief   Alignment check.
     */
    ZYDIS_CPUFLAG_AC,
    /**
     * @brief   Virtual interrupt flag.
     */
    ZYDIS_CPUFLAG_VIF,
    /**
     * @brief   Virtual interrupt pending.
     */
    ZYDIS_CPUFLAG_VIP,
    /**
     * @brief   Able to use CPUID instruction.
     */
    ZYDIS_CPUFLAG_ID,
    /**
     * @brief   FPU condition-code flag 0.
     */
    ZYDIS_CPUFLAG_C0,
    /**
     * @brief   FPU condition-code flag 1.
     */
    ZYDIS_CPUFLAG_C1,
    /**
     * @brief   FPU condition-code flag 2.
     */
    ZYDIS_CPUFLAG_C2,
    /**
     * @brief   FPU condition-code flag 3.
     */
    ZYDIS_CPUFLAG_C3,
    /**
     * @brief   Maximum value of this enum.
     */
    ZYDIS_CPUFLAG_MAX_VALUE = ZYDIS_CPUFLAG_C3
};

/**
 * @brief   Defines the @c ZydisCPUFlagAction datatype.
 */
typedef ZydisU8 ZydisCPUFlagAction;

/**
 * @brief   Values that represent CPU-flag actions.
 */
enum ZydisCPUFlagActions
{
    ZYDIS_CPUFLAG_ACTION_NONE,
    ZYDIS_CPUFLAG_ACTION_TESTED,
    ZYDIS_CPUFLAG_ACTION_MODIFIED,
    ZYDIS_CPUFLAG_ACTION_SET_0,
    ZYDIS_CPUFLAG_ACTION_SET_1,
    ZYDIS_CPUFLAG_ACTION_UNDEFINED,
    /**
     * @brief   Maximum value of this enum.
     */
    ZYDIS_CPUFLAG_ACTION_MAX_VALUE = ZYDIS_CPUFLAG_ACTION_UNDEFINED
};

/* ---------------------------------------------------------------------------------------------- */
/* SSE/AVX exception-class                                                                        */
/* ---------------------------------------------------------------------------------------------- */

/**
 * @brief   Defines the @c ZydisExceptionClass datatype.
 */
typedef ZydisU8 ZydisExceptionClass;

/**
 * @brief   Values that represent exception-classes.
 */
enum ZydisExceptionClasses
{
    ZYDIS_EXCEPTION_CLASS_NONE,
    // TODO: FP Exceptions
    ZYDIS_EXCEPTION_CLASS_SSE1,
    ZYDIS_EXCEPTION_CLASS_SSE2,
    ZYDIS_EXCEPTION_CLASS_SSE3,
    ZYDIS_EXCEPTION_CLASS_SSE4,
    ZYDIS_EXCEPTION_CLASS_SSE5,
    ZYDIS_EXCEPTION_CLASS_SSE7,
    ZYDIS_EXCEPTION_CLASS_AVX1,
    ZYDIS_EXCEPTION_CLASS_AVX2,
    ZYDIS_EXCEPTION_CLASS_AVX3,
    ZYDIS_EXCEPTION_CLASS_AVX4,
    ZYDIS_EXCEPTION_CLASS_AVX5,
    ZYDIS_EXCEPTION_CLASS_AVX6,
    ZYDIS_EXCEPTION_CLASS_AVX7,
    ZYDIS_EXCEPTION_CLASS_AVX8,
    ZYDIS_EXCEPTION_CLASS_AVX11,
    ZYDIS_EXCEPTION_CLASS_AVX12,
    ZYDIS_EXCEPTION_CLASS_E1,
    ZYDIS_EXCEPTION_CLASS_E1NF,
    ZYDIS_EXCEPTION_CLASS_E2,
    ZYDIS_EXCEPTION_CLASS_E2NF,
    ZYDIS_EXCEPTION_CLASS_E3,
    ZYDIS_EXCEPTION_CLASS_E3NF,
    ZYDIS_EXCEPTION_CLASS_E4,
    ZYDIS_EXCEPTION_CLASS_E4NF,
    ZYDIS_EXCEPTION_CLASS_E5,
    ZYDIS_EXCEPTION_CLASS_E5NF,
    ZYDIS_EXCEPTION_CLASS_E6,
    ZYDIS_EXCEPTION_CLASS_E6NF,
    ZYDIS_EXCEPTION_CLASS_E7NM,
    ZYDIS_EXCEPTION_CLASS_E7NM128,
    ZYDIS_EXCEPTION_CLASS_E9NF,
    ZYDIS_EXCEPTION_CLASS_E10,
    ZYDIS_EXCEPTION_CLASS_E10NF,
    ZYDIS_EXCEPTION_CLASS_E11,
    ZYDIS_EXCEPTION_CLASS_E11NF,
    ZYDIS_EXCEPTION_CLASS_E12,
    ZYDIS_EXCEPTION_CLASS_E12NP,
    ZYDIS_EXCEPTION_CLASS_K20,
    ZYDIS_EXCEPTION_CLASS_K21,
    /**
     * @brief   Maximum value of this enum.
     */
    ZYDIS_EXCEPTION_CLASS_MAX_VALUE = ZYDIS_EXCEPTION_CLASS_K21
};

/* ---------------------------------------------------------------------------------------------- */
/* AVX vector-length                                                                              */
/* ---------------------------------------------------------------------------------------------- */

/**
 * @brief   Defines the @c ZydisVectorLength datatype.
 */
typedef ZydisU16 ZydisVectorLength;

/**
 * @brief   Values that represent vector-lengths.
 */
enum ZydisVectorLengths
{
    ZYDIS_VECTOR_LENGTH_INVALID =   0,
    ZYDIS_VECTOR_LENGTH_128     = 128,
    ZYDIS_VECTOR_LENGTH_256     = 256,
    ZYDIS_VECTOR_LENGTH_512     = 512,
    /**
     * @brief   Maximum value of this enum.
     */
    ZYDIS_VECTOR_LENGTH_MAX_VALUE = ZYDIS_VECTOR_LENGTH_512
};

/* ---------------------------------------------------------------------------------------------- */
/* AVX mask mode                                                                                  */
/* ---------------------------------------------------------------------------------------------- */

/**
 * @brief   Defines the @c ZydisMaskMode datatype.
 */
typedef ZydisU8 ZydisMaskMode;

/**
 * @brief   Values that represent AVX mask-modes.
 */
enum ZydisMaskModes
{
    ZYDIS_MASK_MODE_INVALID,
    /**
     * @brief   The embedded mask register is used as a merge-mask. This is the default mode for 
     *          all EVEX/MVEX-instructions.
     */
    ZYDIS_MASK_MODE_MERGE,
    /**
     * @brief   The embedded mask register is used as a zero-mask.
     */
    ZYDIS_MASK_MODE_ZERO,
    /**
     * @brief   Maximum value of this enum.
     */
    ZYDIS_MASK_MODE_MAX_VALUE = ZYDIS_MASK_MODE_ZERO
};

/* ---------------------------------------------------------------------------------------------- */
/* AVX broadcast-mode                                                                             */
/* ---------------------------------------------------------------------------------------------- */

/**
 * @brief   Defines the @c ZydisBroadcastMode datatype.
 */
typedef ZydisU8 ZydisBroadcastMode;

/**
 * @brief   Values that represent AVX broadcast-modes.
 */
enum ZydisBroadcastModes
{
    ZYDIS_BROADCAST_MODE_INVALID,
    ZYDIS_BROADCAST_MODE_1_TO_2,
    ZYDIS_BROADCAST_MODE_1_TO_4,
    ZYDIS_BROADCAST_MODE_1_TO_8,
    ZYDIS_BROADCAST_MODE_1_TO_16,
    ZYDIS_BROADCAST_MODE_1_TO_32,
    ZYDIS_BROADCAST_MODE_1_TO_64,
    ZYDIS_BROADCAST_MODE_2_TO_4,
    ZYDIS_BROADCAST_MODE_2_TO_8,
    ZYDIS_BROADCAST_MODE_2_TO_16,
    ZYDIS_BROADCAST_MODE_4_TO_8,
    ZYDIS_BROADCAST_MODE_4_TO_16,
    ZYDIS_BROADCAST_MODE_8_TO_16,
    /**
     * @brief   Maximum value of this enum.
     */
    ZYDIS_BROADCAST_MODE_MAX_VALUE = ZYDIS_BROADCAST_MODE_8_TO_16
};

/* ---------------------------------------------------------------------------------------------- */
/* AVX rounding-mode                                                                              */
/* ---------------------------------------------------------------------------------------------- */

/**
 * @brief   Defines the @c ZydisRoundingMode datatype.
 */
typedef ZydisU8 ZydisRoundingMode;

/**
 * @brief   Values that represent AVX rounding-modes.
 */
enum ZydisRoundingModes
{
    ZYDIS_ROUNDING_MODE_INVALID,
    /**
     * @brief   Round to nearest.
     */
    ZYDIS_ROUNDING_MODE_RN,
    /**
     * @brief   Round down.
     */
    ZYDIS_ROUNDING_MODE_RD,
    /**
     * @brief   Round up.
     */
    ZYDIS_ROUNDING_MODE_RU,
    /**
     * @brief   Round towards zero.
     */
    ZYDIS_ROUNDING_MODE_RZ,
    /**
     * @brief   Maximum value of this enum.
     */
    ZYDIS_ROUNDING_MODE_MAX_VALUE = ZYDIS_ROUNDING_MODE_RZ
};

/* ---------------------------------------------------------------------------------------------- */
/* KNC swizzle-mode                                                                               */
/* ---------------------------------------------------------------------------------------------- */

/**
 * @brief   Defines the @c ZydisSwizzleMode datatype.
 */
typedef ZydisU8 ZydisSwizzleMode;

/**
 * @brief   Values that represent swizzle-modes.
 */
enum ZydisSwizzleModes
{
    ZYDIS_SWIZZLE_MODE_INVALID,
    ZYDIS_SWIZZLE_MODE_DCBA,
    ZYDIS_SWIZZLE_MODE_CDAB,
    ZYDIS_SWIZZLE_MODE_BADC,
    ZYDIS_SWIZZLE_MODE_DACB,
    ZYDIS_SWIZZLE_MODE_AAAA,
    ZYDIS_SWIZZLE_MODE_BBBB,
    ZYDIS_SWIZZLE_MODE_CCCC,
    ZYDIS_SWIZZLE_MODE_DDDD,
    /**
     * @brief   Maximum value of this enum.
     */
    ZYDIS_SWIZZLE_MODE_MAX_VALUE = ZYDIS_SWIZZLE_MODE_DDDD
};

/* ---------------------------------------------------------------------------------------------- */
/* KNC conversion-mode                                                                            */
/* ---------------------------------------------------------------------------------------------- */

/**
 * @brief   Defines the @c ZydisConversionMode datatype.
 */
typedef ZydisU8 ZydisConversionMode;

/**
 * @brief   Values that represent conversion-modes.
 */
enum ZydisConversionModes
{
    ZYDIS_CONVERSION_MODE_INVALID,
    ZYDIS_CONVERSION_MODE_FLOAT16,
    ZYDIS_CONVERSION_MODE_SINT8,
    ZYDIS_CONVERSION_MODE_UINT8,
    ZYDIS_CONVERSION_MODE_SINT16,
    ZYDIS_CONVERSION_MODE_UINT16,
    /**
     * @brief   Maximum value of this enum.
     */
    ZYDIS_CONVERSION_MODE_MAX_VALUE = ZYDIS_CONVERSION_MODE_UINT16
};

/* ---------------------------------------------------------------------------------------------- */
/* Decoded instruction                                                                            */
/* ---------------------------------------------------------------------------------------------- */

/**
 * @brief   Defines the @c ZydisDecodedInstruction struct.
 */
typedef struct ZydisDecodedInstruction_
{
    /**
     * @brief   The machine mode used to decode this instruction.
     */
    ZydisMachineMode machineMode;
    /**
     * @brief   The instruction-mnemonic.
     */
    ZydisMnemonic mnemonic;  
    /**
     * @brief   The length of the decoded instruction.
     */
    ZydisU8 length;
    /**
     * @brief   The raw bytes of the decoded instruction.
     */
    ZydisU8 data[ZYDIS_MAX_INSTRUCTION_LENGTH];
    /**
     * @brief   The instruction-encoding (default, 3DNow, VEX, EVEX, XOP).
     */
    ZydisInstructionEncoding encoding;
    /**
     * @brief   The opcode-map.
     */
    ZydisOpcodeMap opcodeMap;
    /**
     * @brief   The instruction-opcode.
     */
    ZydisU8 opcode;
    /**
     * @brief   The stack width.
     */
    ZydisU8 stackWidth;
    /**
     * @brief   The effective operand width.
     */
    ZydisU8 operandWidth;
    /**
     * @brief   The effective address width.
     */
    ZydisU8 addressWidth;
    /**
     * @brief   The number of instruction-operands.
     */
    ZydisU8 operandCount;
    /**
     * @brief   Detailed info for all instruction operands.
     */
    ZydisDecodedOperand operands[ZYDIS_MAX_OPERAND_COUNT];
    /**
     * @brief  Instruction attributes.
     */
    ZydisInstructionAttributes attributes;
    /**
     * @brief   The instruction address points at the current instruction (based on the initial
     *          instruction pointer).
     */
    ZydisU64 instrAddress;
    /**
     * @brief   Information about accessed CPU flags.
     */
    struct
    {
        /**
         * @brief   The CPU-flag action.
         * 
         * You can call `ZydisGetAccessedFlagsByAction` to get a mask with all flags matching a 
         * specific action.
         */
        ZydisCPUFlagAction action;
    } accessedFlags[ZYDIS_CPUFLAG_MAX_VALUE + 1];
    /**
     * @brief   Extended info for AVX instructions.
     */
    struct
    {
        /**
         * @brief   The AVX vector-length.
         */
        ZydisVectorLength vectorLength;
        /**
         * @brief   Info about the embedded writemask-register.
         */
        struct
        {
            /**
             * @brief   The masking mode.
             */
            ZydisMaskMode mode;
            /**
             * @brief   The mask register.
             */
            ZydisRegister reg;
            /**
             * @brief   Signals, if the mask-register is used as a control mask. 
             */
            ZydisBool isControlMask;
        } mask;
        /**
         * @brief   Contains info about the AVX broadcast.
         */
        struct
        {
            /**
             * @brief   Signals, if the broadcast is a static broadcast.
             * 
             * This is the case for instructions with inbuild broadcast functionality, that is
             * always active and not be controlled by a flag in the XOP/VEX/EVEX/MVEX-prefix.
             */
            ZydisBool isStatic;
            /**
             * @brief   The AVX broadcast-mode.
             */
            ZydisBroadcastMode mode;
        } broadcast;
        /**
         * @brief   Contains info about the AVX rounding.
         */
        struct
        {
            /**
             * @brief   The AVX rounding-mode.
             */
            ZydisRoundingMode mode;    
        } rounding;
        /**
         * @brief   Contains info about the AVX register-swizzle (MVEX only).
         */
        struct
        {
            /**
             * @brief   The AVX register-swizzle mode (MVEX only).
             */
            ZydisSwizzleMode mode;   
        } swizzle;
        /**
         * @brief   Contains info about the AVX data-conversion (MVEX only).
         */
        struct
        {
            /**
             * @brief   The AVX data-conversion mode (MVEX only).
             */
            ZydisConversionMode mode;  
        } conversion;
        /**
         * @brief   Signals, if the sae functionality is enabled for the instruction.
         */
        ZydisBool hasSAE;
        /**
         * @brief   Signals, if the instruction has a memory eviction-hint (MVEX only).
         */
        ZydisBool hasEvictionHint;
    } avx;
    /**
     * @brief   Meta info.
     */
    struct
    {
        /**
         * @brief   The instruction category.
         */
        ZydisInstructionCategory category;
        /**
         * @brief   The ISA-set.
         */
        ZydisISASet isaSet;
        /**
         * @brief   The ISA-set extension.
         */
        ZydisISAExt isaExt;
        /**
         * @brief   The exception class.
         */
        ZydisExceptionClass exceptionClass;
    } meta;
    /**
     * @brief   Extended info about different instruction-parts like ModRM, SIB or 
     *          encoding-prefixes.
     */
    struct
    {
        /**
         * @brief   Detailed info about the legacy prefixes
         */
        struct
        {
            ZydisU8 data[ZYDIS_MAX_INSTRUCTION_LENGTH - 1];
            ZydisU8 count;
            ZydisU8 hasF0;
            ZydisU8 hasF3;
            ZydisU8 hasF2;
            ZydisU8 has2E;
            ZydisU8 has36;
            ZydisU8 has3E;
            ZydisU8 has26;
            ZydisU8 has64;
            ZydisU8 has65;
            ZydisU8 has66;
            ZydisU8 has67;
        } prefixes;
        /**
         * @brief   Detailed info about the REX-prefix.
         */
        struct
        {
            /**
             * @brief   @c TRUE if the prefix got already decoded.
             */
            ZydisBool isDecoded;
            /**
             * @brief   The raw bytes of the prefix.
             */
            ZydisU8 data[1];
            /**
             * @brief   64-bit operand-size promotion.
             */
            ZydisU8 W;
            /**
             * @brief   Extension of the ModRM.reg field.
             */
            ZydisU8 R;
            /**
             * @brief   Extension of the SIB.index field.
             */
            ZydisU8 X;
            /**
             * @brief   Extension of the ModRM.rm, SIB.base, or opcode.reg field.
             */
            ZydisU8 B;
        } rex; 
        /**
         * @brief   Detailed info about the XOP-prefix.
         */
        struct
        {
            /**
             * @brief   @c TRUE if the prefix got already decoded.
             */
            ZydisBool isDecoded;
            /**
             * @brief   The raw bytes of the prefix.
             */
            ZydisU8 data[3];
            /**
             * @brief   Extension of the ModRM.reg field (inverted).
             */
            ZydisU8 R;
            /**
             * @brief   Extension of the SIB.index field (inverted).
             */
            ZydisU8 X;
            /**
             * @brief   Extension of the ModRM.rm, SIB.base, or opcode.reg field (inverted).
             */
            ZydisU8 B;
            /**
             * @brief   Opcode-map specifier.
             */
            ZydisU8 m_mmmm;
            /**
             * @brief   64-bit operand-size promotion or opcode-extension.
             */
            ZydisU8 W;
            /**
             * @brief   NDS register specifier (inverted).
             */
            ZydisU8 vvvv;
            /**
             * @brief   Vector-length specifier.
             */
            ZydisU8 L;
            /**
             * @brief   Compressed legacy prefix.
             */
            ZydisU8 pp;
        } xop;
        /**
         * @brief   Detailed info about the VEX-prefix.
         */
        struct
        {
            /**
             * @brief   @c TRUE if the prefix got already decoded.
             */
            ZydisBool isDecoded;
            /**
             * @brief   The raw bytes of the prefix.
             */
            ZydisU8 data[3];
            /**
             * @brief   Extension of the ModRM.reg field (inverted).
             */
            ZydisU8 R;
            /**
             * @brief   Extension of the SIB.index field (inverted).
             */
            ZydisU8 X;
            /**
             * @brief   Extension of the ModRM.rm, SIB.base, or opcode.reg field (inverted).
             */
            ZydisU8 B;
            /**
             * @brief   Opcode-map specifier.
             */
            ZydisU8 m_mmmm;
            /**
             * @brief   64-bit operand-size promotion or opcode-extension.
             */
            ZydisU8 W;
            /**
             * @brief   NDS register specifier (inverted).
             */
            ZydisU8 vvvv;
            /**
             * @brief   Vector-length specifier.
             */
            ZydisU8 L;
            /**
             * @brief   Compressed legacy prefix.
             */
            ZydisU8 pp;
        } vex;
        /**
         * @brief   Detailed info about the EVEX-prefix.
         */
        struct
        {
            /**
             * @brief   @c TRUE if the prefix got already decoded.
             */
            ZydisBool isDecoded;
            /**
             * @brief   The raw bytes of the prefix.
             */
            ZydisU8 data[4];
            /**
             * @brief   Extension of the ModRM.reg field (inverted).
             */
            ZydisU8 R;
            /**
             * @brief   Extension of the SIB.index/vidx field (inverted).
             */
            ZydisU8 X;
            /**
             * @brief   Extension of the ModRM.rm or SIB.base field (inverted).
             */
            ZydisU8 B;
            /**
             * @brief   High-16 register specifier modifier (inverted).
             */
            ZydisU8 R2;
            /**
             * @brief   Opcode-map specifier.
             */
            ZydisU8 mm;
            /**
             * @brief   64-bit operand-size promotion or opcode-extension.
             */
            ZydisU8 W;
            /**
             * @brief   NDS register specifier (inverted).
             */
            ZydisU8 vvvv;
            /**
             * @brief   Compressed legacy prefix.
             */
            ZydisU8 pp;
            /**
             * @brief   Zeroing/Merging.
             */
            ZydisU8 z;
            /**
             * @brief   Vector-length specifier or rounding-control (most significant bit).
             */
            ZydisU8 L2;
            /**
             * @brief   Vector-length specifier or rounding-control (least significant bit).
             */
            ZydisU8 L;
            /**
             * @brief   Broadcast/RC/SAE Context.
             */
            ZydisU8 b;
            /**
             * @brief   High-16 NDS/VIDX register specifier.
             */
            ZydisU8 V2;
            /**
             * @brief   Embedded opmask register specifier.
             */
            ZydisU8 aaa;
        } evex;
        /**
        * @brief    Detailed info about the MVEX-prefix.
        */
        struct
        {
            /**
             * @brief   @c TRUE if the prefix got already decoded.
             */
            ZydisBool isDecoded;
            /**
             * @brief   The raw bytes of the prefix.
             */
            ZydisU8 data[4];
            /**
             * @brief   Extension of the ModRM.reg field (inverted).
             */
            ZydisU8 R;
            /**
             * @brief   Extension of the SIB.index/vidx field (inverted).
             */
            ZydisU8 X;
            /**
             * @brief   Extension of the ModRM.rm or SIB.base field (inverted).
             */
            ZydisU8 B;
            /**
             * @brief   High-16 register specifier modifier (inverted).
             */
            ZydisU8 R2;
            /**
             * @brief   Opcode-map specifier.
             */
            ZydisU8 mmmm;
            /**
             * @brief   64-bit operand-size promotion or opcode-extension.
             */
            ZydisU8 W;
            /**
             * @brief   NDS register specifier (inverted).
             */
            ZydisU8 vvvv;
            /**
             * @brief   Compressed legacy prefix.
             */
            ZydisU8 pp;
            /**
             * @brief   Non-temporal/eviction hint.
             */
            ZydisU8 E;
            /**
             * @brief   Swizzle/broadcast/up-convert/down-convert/static-rounding controls.
             */
            ZydisU8 SSS;
            /**
             * @brief   High-16 NDS/VIDX register specifier.
             */
            ZydisU8 V2;
            /**
             * @brief   Embedded opmask register specifier.
             */
            ZydisU8 kkk;
        } mvex;
        /**
         * @brief   Detailed info about the ModRM-byte.
         */
        struct
        {
            ZydisBool isDecoded;
            ZydisU8 data[1];
            ZydisU8 mod;
            ZydisU8 reg;
            ZydisU8 rm;
        } modrm;
        /**
         * @brief   Detailed info about the SIB-byte.
         */
        struct
        {
            ZydisBool isDecoded;
            ZydisU8 data[1];
            ZydisU8 scale;
            ZydisU8 index;
            ZydisU8 base;
        } sib;
        /**
         * @brief   Detailed info about displacement-bytes.
         */
        struct
        {
            /**
             * @brief   The displacement value
             */
            ZydisI64 value;
            /**
             * @brief   The physical displacement size, in bits.
             */
            ZydisU8 size;
            /**
             * @brief   The offset of the displacement data, relative to the beginning of the
             *          instruction, in bytes.
             */
            ZydisU8 offset;
        } disp;
        /**
         * @brief   Detailed info about immediate-bytes.
         */
        struct
        {
            /**
             * @brief   Signals, if the immediate value is signed.
             */
            ZydisBool isSigned;  
            /**
             * @brief   Signals, if the immediate value contains a relative offset. You can use 
             *          @c ZydisCalcAbsoluteAddress to determine the absolute address value.
             */
            ZydisBool isRelative;
            /**
             * @brief   The immediate value.
             */
            union
            {  
                ZydisU64 u;
                ZydisI64 s;
            } value;
            /**
             * @brief   The physical immediate size, in bits.
             */
            ZydisU8 size;
            /**
             * @brief   The offset of the immediate data, relative to the beginning of the
             *          instruction, in bytes.
             */
            ZydisU8 offset;
        } imm[2];
    } raw;
} ZydisDecodedInstruction;

/* ---------------------------------------------------------------------------------------------- */

/* ============================================================================================== */

#ifdef __cplusplus
}
#endif

#endif /* ZYDIS_INSTRUCTIONINFO_H */

```

`Avanguard/Zydis/Zydis/Defines.h`:

```h
/***************************************************************************************************

  Zyan Disassembler Library (Zydis)

  Original Author : Florian Bernd

 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.

***************************************************************************************************/

/**
 * @file
 * @brief   General helper and platform detection macros.
 */

#ifndef ZYDIS_DEFINES_H
#define ZYDIS_DEFINES_H

#include <ZydisExportConfig.h>

/* ============================================================================================== */
/* Compiler detection                                                                             */
/* ============================================================================================== */

#if defined(__clang__)
#   define ZYDIS_CLANG
#   define ZYDIS_GNUC
#elif defined(__ICC) || defined(__INTEL_COMPILER)
#   define ZYDIS_ICC
#elif defined(__GNUC__) || defined(__GNUG__)
#   define ZYDIS_GCC
#   define ZYDIS_GNUC
#elif defined(_MSC_VER)
#   define ZYDIS_MSVC
#elif defined(__BORLANDC__)
#   define ZYDIS_BORLAND
#else
#   define ZYDIS_UNKNOWN_COMPILER
#endif

/* ============================================================================================== */
/* Platform detection                                                                             */
/* ============================================================================================== */

#if defined(_WIN32)
#   define ZYDIS_WINDOWS
#elif defined(__APPLE__)
#   define ZYDIS_APPLE
#   define ZYDIS_POSIX
#elif defined(__linux)
#   define ZYDIS_LINUX
#   define ZYDIS_POSIX
#elif defined(__unix)
#   define ZYDIS_UNIX
#   define ZYDIS_POSIX
#elif defined(__posix)
#   define ZYDIS_POSIX
#else
#   define ZYDIS_UNKNOWN_PLATFORM
#endif

/* ============================================================================================== */
/* Architecture detection                                                                         */
/* ============================================================================================== */

#if defined(_M_AMD64) || defined(__x86_64__)
#   define ZYDIS_X64
#elif defined(_M_IX86) || defined(__i386__)
#   define ZYDIS_X86
#elif defined(_M_ARM64) || defined(__aarch64__)
#   define ZYDIS_AARCH64
#elif defined(_M_ARM) || defined(_M_ARMT) || defined(__arm__) || defined(__thumb__)
#   define ZYDIS_ARM
#else
#   error "Unsupported architecture detected"
#endif

/* ============================================================================================== */
/* Debug/Release detection                                                                        */
/* ============================================================================================== */  

#if defined(ZYDIS_MSVC) || defined(ZYDIS_BORLAND)
#   ifdef _DEBUG
#       define ZYDIS_DEBUG
#   else
#       define ZYDIS_RELEASE
#   endif
#elif defined(ZYDIS_GNUC) || defined(ZYDIS_ICC)
#   ifdef NDEBUG
#       define ZYDIS_RELEASE
#   else
#       define ZYDIS_DEBUG
#   endif
#else
#   define ZYDIS_RELEASE
#endif

/* ============================================================================================== */
/* Misc compatibility macros                                                                      */
/* ============================================================================================== */

#if defined(ZYDIS_MSVC) || defined(ZYDIS_BORLAND)
#   define ZYDIS_INLINE __inline 
#else
#   define ZYDIS_INLINE static inline
#endif

/* ============================================================================================== */
/* Debugging and optimization macros                                                              */
/* ============================================================================================== */

#if defined(ZYDIS_NO_LIBC)
#   define ZYDIS_ASSERT(condition)
#else
#   include <assert.h>
#   define ZYDIS_ASSERT(condition) assert(condition)
#endif

#if defined(ZYDIS_RELEASE)
#   if defined(ZYDIS_CLANG) // GCC eagerly evals && RHS, we have to use nested ifs.
#       if __has_builtin(__builtin_unreachable)
#           define ZYDIS_UNREACHABLE __builtin_unreachable()
#       else
#           define ZYDIS_UNREACHABLE for(;;)
#       endif
#   elif defined(ZYDIS_GCC) && ((__GNUC__ == 4 && __GNUC_MINOR__ > 4) || __GNUC__ > 4)
#       define ZYDIS_UNREACHABLE __builtin_unreachable()
#   elif defined(ZYDIS_ICC)
#       ifdef ZYDIS_WINDOWS
#           include <stdlib.h> // "missing return statement" workaround
#           define ZYDIS_UNREACHABLE __assume(0); (void)abort()
#       else
#           define ZYDIS_UNREACHABLE __builtin_unreachable()
#       endif
#   elif defined(ZYDIS_MSVC)
#       define ZYDIS_UNREACHABLE __assume(0)
#   else
#       define ZYDIS_UNREACHABLE for(;;)
#   endif
#elif defined(ZYDIS_NO_LIBC)
#   define ZYDIS_UNREACHABLE for(;;)
#else
#   include <stdlib.h>
#   define ZYDIS_UNREACHABLE { assert(0); abort(); }
#endif

/* ============================================================================================== */
/* Utils                                                                                          */
/* ============================================================================================== */

/**
 * @brief   Compiler-time assertion.
 */
#if __STDC_VERSION__ >= 201112L
#   define ZYDIS_STATIC_ASSERT(x) _Static_assert(x, #x)
#else
#   define ZYDIS_STATIC_ASSERT(x) typedef int ZYDIS_SASSERT_IMPL[(x) ? 1 : -1]
#endif

/**
 * @brief   Declares a bitfield.
 */
#define ZYDIS_BITFIELD(x) : x

/**
 * @brief   Marks the specified parameter as unused.
 */
#define ZYDIS_UNUSED_PARAMETER(x) (void)(x)

/**
 * @brief   Calculates the size of an array.
 */
#define ZYDIS_ARRAY_SIZE(arr) (sizeof(arr) / sizeof(arr[0]))

/* ============================================================================================== */

#endif /* ZYDIS_DEFINES_H */

```

`Avanguard/Zydis/Zydis/Formatter.h`:

```h
/***************************************************************************************************

  Zyan Disassembler Library (Zydis)

  Original Author : Florian Bernd

 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.

***************************************************************************************************/

/**
 * @file
 * @brief   Functions for formatting human-readable instructions.
 */

#ifndef ZYDIS_FORMATTER_H
#define ZYDIS_FORMATTER_H

#include <Zydis/DecoderTypes.h>
#include <Zydis/Defines.h>
#include <Zydis/Status.h>
#include <Zydis/String.h>

#ifdef __cplusplus
extern "C" {
#endif

/* ============================================================================================== */
/* Enums and types                                                                                */
/* ============================================================================================== */

/* ---------------------------------------------------------------------------------------------- */
/* Formatter style                                                                                */
/* ---------------------------------------------------------------------------------------------- */

/**
 * @brief   Defines the `ZydisFormatterStyle` datatype.
 */
typedef ZydisU8 ZydisFormatterStyle;

/**
 * @brief   Values that represent formatter-styles.
 */
enum ZydisFormatterStyles
{
    /**
     * @brief   Generates intel-style disassembly.
     */
    ZYDIS_FORMATTER_STYLE_INTEL,

    /**
     * @brief   Maximum value of this enum.
     */
    ZYDIS_FORMATTER_STYLE_MAX_VALUE = ZYDIS_FORMATTER_STYLE_INTEL
};

/* ---------------------------------------------------------------------------------------------- */
/* Attributes                                                                                     */
/* ---------------------------------------------------------------------------------------------- */

/**
 * @brief   Defines the `ZydisFormatterProperty` datatype.
 */
typedef ZydisU8 ZydisFormatterProperty;

/**
 * @brief   Values that represent formatter-properties.
 */
enum ZydisFormatterProperties
{
    /**
     * @brief   Controls the letter-case. 
     * 
     * Pass `ZYDIS_TRUE` as value to format in uppercase and `ZYDIS_FALSE` to format in lowercase.
     * 
     * The default value is `ZYDIS_FALSE`.
     */
    ZYDIS_FORMATTER_PROP_UPPERCASE,
    /**
     * @brief   Controls the printing of segment prefixes. 
     * 
     * Pass `ZYDIS_TRUE` as value to force the formatter to always print the segment register of 
     * memory-operands or `ZYDIS_FALSE` to ommit implicit DS/SS segments.
     * 
     * The default value is `ZYDIS_FALSE`.
     */
    ZYDIS_FORMATTER_PROP_FORCE_MEMSEG,
    /**
     * @brief   Controls the printing of memory-operand sizes. 
     * 
     * Pass `ZYDIS_TRUE` as value to force the formatter to always print the size of memory-operands 
     * or `ZYDIS_FALSE` to only print it on demand.
     * 
     * The default value is `ZYDIS_FALSE`.
     */
    ZYDIS_FORMATTER_PROP_FORCE_MEMSIZE,

    /**
     * @brief   Controls the format of addresses.
     * 
     * The default value is `ZYDIS_ADDR_FORMAT_ABSOLUTE`.
     */
    ZYDIS_FORMATTER_PROP_ADDR_FORMAT,
    /**
     * @brief   Controls the format of displacement values.
     * 
     * The default value is `ZYDIS_DISP_FORMAT_HEX_SIGNED`.
     */
    ZYDIS_FORMATTER_PROP_DISP_FORMAT,
    /**
     * @brief   Controls the format of immediate values.
     * 
     * The default value is `ZYDIS_IMM_FORMAT_HEX_UNSIGNED`.
     */
    ZYDIS_FORMATTER_PROP_IMM_FORMAT,

    /**
     * @brief   Controls the letter-case of hexadecimal values. 
     * 
     * Pass `ZYDIS_TRUE` as value to format in uppercase and `ZYDIS_FALSE` to format in lowercase.
     * 
     * The default value is `ZYDIS_TRUE`.
     */
    ZYDIS_FORMATTER_PROP_HEX_UPPERCASE,
    /**
     * @brief   Sets the prefix for hexadecimal values.
     * 
     * The default value is `"0x"`.
     */
    ZYDIS_FORMATTER_PROP_HEX_PREFIX,
    /**
     * @brief   Sets the suffix for hexadecimal values.
     * 
     * The default value is `NULL`.
     */
    ZYDIS_FORMATTER_PROP_HEX_SUFFIX,
    /**
     * @brief   Controls the padding (minimum number of chars) of hexadecimal address values.
     * 
     * The default value is `2`.
     */
    ZYDIS_FORMATTER_PROP_HEX_PADDING_ADDR,
    /**
     * @brief   Controls the padding (minimum number of chars) of hexadecimal displacement values.
     * 
     * The default value is `2`.
     */
    ZYDIS_FORMATTER_PROP_HEX_PADDING_DISP,
    /**
     * @brief   Controls the padding (minimum number of chars) of hexadecimal immediate values.
     * 
     * The default value is `2`.
     */
    ZYDIS_FORMATTER_PROP_HEX_PADDING_IMM,

    /**
     * @brief   Maximum value of this enum.
     */
    ZYDIS_FORMATTER_PROP_MAX_VALUE = ZYDIS_FORMATTER_PROP_HEX_PADDING_IMM
};

/* ---------------------------------------------------------------------------------------------- */
/* Address format                                                                                 */
/* ---------------------------------------------------------------------------------------------- */

/**
 * @brief   Values that represent address-formats.
 */
enum ZydisAddressFormat
{   
    /**
     * @brief   Displays absolute addresses instead of relative ones.
     * 
     * Using this value will cause the formatter to invoke `ZYDIS_FORMATTER_HOOK_PRINT_ADDRESS`
     * for every address.
     */
    ZYDIS_ADDR_FORMAT_ABSOLUTE,
    /**
     * @brief   Uses signed hexadecimal values to display relative addresses.
     *          
     * Using this value will cause the formatter to either invoke 
     * `ZYDIS_FORMATTER_HOOK_PRINT_DISP` or `ZYDIS_FORMATTER_HOOK_PRINT_IMM` to format addresses.
     *          
     * Examples:
     * - `"JMP  0x20"`
     * - `"JMP -0x20"`
     */
    ZYDIS_ADDR_FORMAT_RELATIVE_SIGNED,
    /**
     * @brief   Uses unsigned hexadecimal values to display relative addresses.
     * 
     * Using this value will cause the formatter to either invoke 
     * `ZYDIS_FORMATTER_HOOK_PRINT_DISP` or `ZYDIS_FORMATTER_HOOK_PRINT_IMM` to format addresses.          
     *                            
     * Examples:
     * - `"JMP 0x20"`
     * - `"JMP 0xE0"`
     */
    ZYDIS_ADDR_FORMAT_RELATIVE_UNSIGNED,

    /**
     * @brief   Maximum value of this enum.
     */
    ZYDIS_ADDR_FORMAT_MAX_VALUE = ZYDIS_ADDR_FORMAT_RELATIVE_UNSIGNED
};

/* ---------------------------------------------------------------------------------------------- */
/* Displacement format                                                                            */
/* ---------------------------------------------------------------------------------------------- */

/**
 * @brief   Values that represent displacement-formats.
 */
enum ZydisDisplacementFormat
{
    /**
     * @brief   Formats displacements as signed hexadecimal values.
     *          
     * Examples: 
     * - `"MOV EAX, DWORD PTR SS:[ESP+0x400]"`
     * - `"MOV EAX, DWORD PTR SS:[ESP-0x400]"`
     */
    ZYDIS_DISP_FORMAT_HEX_SIGNED,
    /**
     * @brief   Formats displacements as unsigned hexadecimal values.
     *          
     * Examples: 
     * - `"MOV EAX, DWORD PTR SS:[ESP+0x400]"`
     * - `"MOV EAX, DWORD PTR SS:[ESP+0xFFFFFC00]"`
     */
    ZYDIS_DISP_FORMAT_HEX_UNSIGNED,

    /**
     * @brief   Maximum value of this enum.
     */
    ZYDIS_DISP_FORMAT_MAX_VALUE = ZYDIS_DISP_FORMAT_HEX_UNSIGNED
};

/* ---------------------------------------------------------------------------------------------- */
/* Immediate format                                                                               */
/* ---------------------------------------------------------------------------------------------- */

/**
 * @brief   Values that represent formatter immediate-formats.
 */
enum ZydisImmediateFormat
{
    /**
     * @brief   Automatically chooses the most suitable formatting-mode based on the operands
     *          `ZydisOperandInfo.imm.isSigned` attribute.
     */
    ZYDIS_IMM_FORMAT_HEX_AUTO,
    /**
     * @brief   Formats immediates as signed hexadecimal values.
     *          
     * Examples: 
     * - `"MOV EAX, 0x400"`
     * - `"MOV EAX, -0x400"`
     */
    ZYDIS_IMM_FORMAT_HEX_SIGNED,
    /**
     * @brief   Formats immediates as unsigned hexadecimal values.
     *          
     * Examples: 
     * - `"MOV EAX, 0x400"`
     * - `"MOV EAX, 0xFFFFFC00"`
     */
    ZYDIS_IMM_FORMAT_HEX_UNSIGNED,

    /**
     * @brief   Maximum value of this enum.
     */
    ZYDIS_IMM_FORMAT_MAX_VALUE = ZYDIS_IMM_FORMAT_HEX_UNSIGNED
};

/* ---------------------------------------------------------------------------------------------- */
/* Hooks                                                                                          */
/* ---------------------------------------------------------------------------------------------- */

/**
 * @brief   Defines the `ZydisFormatterHookType` datatype.
 */
typedef ZydisU8 ZydisFormatterHookType;

/**
 * @brief   Values that represent formatter hook-types.
 */
enum ZydisFormatterHookTypes
{
    /**
     * @brief   This function is invoked before the formatter formats an instruction.
     */
    ZYDIS_FORMATTER_HOOK_PRE_INSTRUCTION,
    /**
     * @brief   This function is invoked before the formatter formatted an instruction.
     */
    ZYDIS_FORMATTER_HOOK_POST_INSTRUCTION,
    /**
     * @brief   This function is invoked before the formatter formats an operand.
     */
    ZYDIS_FORMATTER_HOOK_PRE_OPERAND,
    /**
     * @brief   This function is invoked before the formatter formatted an operand.
     */
    ZYDIS_FORMATTER_HOOK_POST_OPERAND,

    /**
     * @brief   This function refers to the main formatting function.
     *          
     * Replacing this function allows for complete custom formatting, but indirectly disables all 
     * other hooks except for `ZYDIS_FORMATTER_HOOK_PRE_INSTRUCTION` and 
     * `ZYDIS_FORMATTER_HOOK_POST_INSTRUCTION`. 
     */
    ZYDIS_FORMATTER_HOOK_FORMAT_INSTRUCTION,
    /**
     * @brief   This function is invoked to format a register operand.
     */
    ZYDIS_FORMATTER_HOOK_FORMAT_OPERAND_REG,
    /**
     * @brief   This function is invoked to format a memory operand.
     *
     * Replacing this function might indirectly disable some specific calls to the 
     * `ZYDIS_FORMATTER_HOOK_PRINT_ADDRESS` and `ZYDIS_FORMATTER_HOOK_PRINT_DISP` functions.
     */
    ZYDIS_FORMATTER_HOOK_FORMAT_OPERAND_MEM,
    /**
     * @brief   This function is invoked to format a pointer operand.
     */
    ZYDIS_FORMATTER_HOOK_FORMAT_OPERAND_PTR,
    /**
     * @brief   This function is invoked to format an immediate operand.
     *
     * Replacing this function might indirectly disable some specific calls to the 
     * `ZYDIS_FORMATTER_HOOK_PRINT_ADDRESS` and `ZYDIS_FORMATTER_HOOK_PRINT_IMM` functions.
     */
    ZYDIS_FORMATTER_HOOK_FORMAT_OPERAND_IMM,  

    /**
     * @brief   This function is invoked to print the instruction mnemonic.
     */
    ZYDIS_FORMATTER_HOOK_PRINT_MNEMONIC,
    /**
     * @brief   This function is invoked to print a register.
     */
    ZYDIS_FORMATTER_HOOK_PRINT_REGISTER,
    /**
     * @brief   This function is invoked to print an absolute address.
     */
    ZYDIS_FORMATTER_HOOK_PRINT_ADDRESS,
    /**
     * @brief   This function is invoked to print a memory displacement value.
     */
    ZYDIS_FORMATTER_HOOK_PRINT_DISP,
    /**
     * @brief   This function is invoked to print an immediate value.
     */
    ZYDIS_FORMATTER_HOOK_PRINT_IMM,

    /**
     * @brief   This function is invoked to print the size of a memory operand.
     */
    ZYDIS_FORMATTER_HOOK_PRINT_MEMSIZE,  
    /**
     * @brief   This function is invoked to print the instruction prefixes.
     */
    ZYDIS_FORMATTER_HOOK_PRINT_PREFIXES,
    /**
     * @brief   This function is invoked after formatting an operand to print a `EVEX`/`MVEX` 
     *          decorator.
     */
    ZYDIS_FORMATTER_HOOK_PRINT_DECORATOR,

    /**
     * @brief   Maximum value of this enum.
     */
    ZYDIS_FORMATTER_HOOK_MAX_VALUE = ZYDIS_FORMATTER_HOOK_PRINT_DECORATOR
};

/* ---------------------------------------------------------------------------------------------- */

/**
 * @brief   Defines the `ZydisDecoratorType` datatype.
 */
typedef ZydisU8 ZydisDecoratorType;

/**
 * @brief   Values that represent decorator-types.
 */
enum ZydisDecoratorTypes
{
    ZYDIS_DECORATOR_TYPE_INVALID,
    /**
     * @brief   The embedded-mask decorator.
     */
    ZYDIS_DECORATOR_TYPE_MASK,
    /**
     * @brief   The broadcast decorator.
     */
    ZYDIS_DECORATOR_TYPE_BC,
    /**
     * @brief   The rounding-control decorator.
     */
    ZYDIS_DECORATOR_TYPE_RC,
    /**
     * @brief   The suppress-all-exceptions decorator.
     */
    ZYDIS_DECORATOR_TYPE_SAE,
    /**
     * @brief   The register-swizzle decorator.
     */
    ZYDIS_DECORATOR_TYPE_SWIZZLE,
    /**
     * @brief   The conversion decorator.
     */
    ZYDIS_DECORATOR_TYPE_CONVERSION,
    /**
     * @brief   The eviction-hint decorator.
     */
    ZYDIS_DECORATOR_TYPE_EH,

    /**
     * @brief   Maximum value of this enum.
     */
    ZYDIS_DECORATOR_TYPE_MAX_VALUE = ZYDIS_DECORATOR_TYPE_EH
};

/* ---------------------------------------------------------------------------------------------- */

typedef struct ZydisFormatter_ ZydisFormatter;

/**
 * @brief   Defines the `ZydisFormatterFunc` function pointer.
 *
 * @param   formatter   A pointer to the `ZydisFormatter` instance.
 * @param   string      A pointer to the string.
 * @param   instruction A pointer to the `ZydisDecodedInstruction` struct.
 * @param   userData    A pointer to user-defined data.
 * 
 * @return  A zydis status code.
 * 
 * Returning a status code other than `ZYDIS_STATUS_SUCCESS` will immediately cause the formatting 
 * process to fail.
 * 
 * Returning `ZYDIS_STATUS_SUCCESS` in `ZYDIS_FORMATTER_HOOK_PRINT_PREFIXES` without writing to 
 * the string is valid and signals that the corresponding element should not be printed.
 *
 * This function type is used for:
 * - `ZYDIS_FORMATTER_HOOK_PRE_INSTRUCTION`
 * - `ZYDIS_FORMATTER_HOOK_POST_INSTRUCTION` 
 * - `ZYDIS_FORMATTER_HOOK_FORMAT_INSTRUCTION` 
 * - `ZYDIS_FORMATTER_HOOK_PRINT_MNEMONIC`
 * - `ZYDIS_FORMATTER_HOOK_PRINT_PREFIXES`
 */
typedef ZydisStatus (*ZydisFormatterFunc)(const ZydisFormatter* formatter, 
    ZydisString* string, const ZydisDecodedInstruction* instruction, void* userData);

/**
 * @brief   Defines the `ZydisFormatterOperandFunc` function pointer.
 *
 * @param   formatter   A pointer to the `ZydisFormatter` instance.
 * @param   string      A pointer to the string.
 * @param   instruction A pointer to the `ZydisDecodedInstruction` struct.
 * @param   operand     A pointer to the `ZydisDecodedOperand` struct.
 * @param   userData    A pointer to user-defined data.
 * 
 * @return  A zydis status code. 
 * 
 * Returning a status code other than `ZYDIS_STATUS_SUCCESS` will immediately cause the formatting 
 * process to fail.
 * 
 * Returning `ZYDIS_STATUS_SUCCESS` in one of the `ZYDIS_FORMATTER_HOOK_FORMAT_OPERAND_X` hooks 
 * without writing to the string is valid and will cause the formatter to omit the current 
 * operand.
 * 
 * Returning `ZYDIS_STATUS_SUCCESS` in `ZYDIS_FORMATTER_HOOK_PRINT_MEMSIZE` or 
 * `ZYDIS_FORMATTER_HOOK_PRINT_DECORATOR` without writing to the string is valid and signals that 
 * the corresponding element should not be printed for the current operand.
 *
 * This function type is used for:
 * - `ZYDIS_FORMATTER_HOOK_PRE_OPERAND`
 * - `ZYDIS_FORMATTER_HOOK_POST_OPERAND`
 * - `ZYDIS_FORMATTER_HOOK_FORMAT_OPERAND_REG`
 * - `ZYDIS_FORMATTER_HOOK_FORMAT_OPERAND_MEM`
 * - `ZYDIS_FORMATTER_HOOK_FORMAT_OPERAND_PTR` 
 * - `ZYDIS_FORMATTER_HOOK_FORMAT_OPERAND_IMM`
 * - `ZYDIS_FORMATTER_HOOK_PRINT_DISP`
 * - `ZYDIS_FORMATTER_HOOK_PRINT_IMM`
 * - `ZYDIS_FORMATTER_HOOK_PRINT_MEMSIZE`
 */
typedef ZydisStatus (*ZydisFormatterOperandFunc)(const ZydisFormatter* formatter, 
    ZydisString* string, const ZydisDecodedInstruction* instruction, 
    const ZydisDecodedOperand* operand, void* userData);

 /**
 * @brief   Defines the `ZydisFormatterRegisterFunc` function pointer.
 *
 * @param   formatter   A pointer to the `ZydisFormatter` instance.
 * @param   string      A pointer to the string.
 * @param   instruction A pointer to the `ZydisDecodedInstruction` struct.
 * @param   operand     A pointer to the `ZydisDecodedOperand` struct.
 * @param   reg         The register.
 * @param   userData    A pointer to user-defined data.
 * 
 * @return  Returning a status code other than `ZYDIS_STATUS_SUCCESS` will immediately cause the 
 *          formatting process to fail.
 *
 * This function type is used for:
 * - `ZYDIS_FORMATTER_HOOK_PRINT_REGISTER`.
 */
typedef ZydisStatus (*ZydisFormatterRegisterFunc)(const ZydisFormatter* formatter, 
    ZydisString* string, const ZydisDecodedInstruction* instruction, 
    const ZydisDecodedOperand* operand, ZydisRegister reg, void* userData);

 /**
 * @brief   Defines the `ZydisFormatterAddressFunc` function pointer.
 *
 * @param   formatter   A pointer to the `ZydisFormatter` instance.
 * @param   string      A pointer to the string.
 * @param   instruction A pointer to the `ZydisDecodedInstruction` struct.
 * @param   operand     A pointer to the `ZydisDecodedOperand` struct.
 * @param   address     The address.
 * @param   userData    A pointer to user-defined data.
 * 
 * @return  Returning a status code other than `ZYDIS_STATUS_SUCCESS` will immediately cause the 
 *          formatting process to fail.
 *
 * This function type is used for:
 * - `ZYDIS_FORMATTER_HOOK_PRINT_ADDRESS`
 */
typedef ZydisStatus (*ZydisFormatterAddressFunc)(const ZydisFormatter* formatter, 
    ZydisString* string, const ZydisDecodedInstruction* instruction, 
    const ZydisDecodedOperand* operand, ZydisU64 address, void* userData);

/**
 * @brief   Defines the `ZydisFormatterDecoratorFunc` function pointer.
 *
 * @param   formatter   A pointer to the `ZydisFormatter` instance.
 * @param   string      A pointer to the string.
 * @param   instruction A pointer to the `ZydisDecodedInstruction` struct.
 * @param   operand     A pointer to the `ZydisDecodedOperand` struct.
 * @param   type        The decorator type.
 * @param   userData    A pointer to user-defined data.
 * 
 * @return  Returning a status code other than `ZYDIS_STATUS_SUCCESS` will immediately cause the 
 *          formatting process to fail.
 * 
 * Returning `ZYDIS_STATUS_SUCCESS` without writing to the string is valid and will cause the
 * formatter to omit the current decorator.
 *
 * This function type is used for:
 * - `ZYDIS_FORMATTER_HOOK_PRINT_DECORATOR`
 */
typedef ZydisStatus (*ZydisFormatterDecoratorFunc)(const ZydisFormatter* formatter, 
    ZydisString* string, const ZydisDecodedInstruction* instruction, 
    const ZydisDecodedOperand* operand, ZydisDecoratorType type, void* userData);

/* ---------------------------------------------------------------------------------------------- */
/* Formatter struct                                                                               */
/* ---------------------------------------------------------------------------------------------- */

/**
 * @brief   Defines the `ZydisFormatter` struct.
 */
struct ZydisFormatter_
{
    ZydisLetterCase letterCase;
    ZydisBool forceMemorySegment;
    ZydisBool forceMemorySize;
    ZydisU8 formatAddress;
    ZydisU8 formatDisp;
    ZydisU8 formatImm;
    ZydisBool hexUppercase;
    ZydisString* hexPrefix;
    ZydisString hexPrefixData;
    ZydisString* hexSuffix;
    ZydisString hexSuffixData;
    ZydisU8 hexPaddingAddress;
    ZydisU8 hexPaddingDisp;
    ZydisU8 hexPaddingImm;
    ZydisFormatterFunc funcPreInstruction;
    ZydisFormatterFunc funcPostInstruction;
    ZydisFormatterOperandFunc funcPreOperand;
    ZydisFormatterOperandFunc funcPostOperand;
    ZydisFormatterFunc funcFormatInstruction;
    ZydisFormatterOperandFunc funcFormatOperandReg;
    ZydisFormatterOperandFunc funcFormatOperandMem;
    ZydisFormatterOperandFunc funcFormatOperandPtr;
    ZydisFormatterOperandFunc funcFormatOperandImm;
    ZydisFormatterFunc funcPrintMnemonic;
    ZydisFormatterRegisterFunc funcPrintRegister;
    ZydisFormatterAddressFunc funcPrintAddress;
    ZydisFormatterOperandFunc funcPrintDisp;
    ZydisFormatterOperandFunc funcPrintImm; 
    ZydisFormatterOperandFunc funcPrintMemSize;
    ZydisFormatterFunc funcPrintPrefixes;
    ZydisFormatterDecoratorFunc funcPrintDecorator;
};

/* ---------------------------------------------------------------------------------------------- */

/* ============================================================================================== */
/* Exported functions                                                                             */
/* ============================================================================================== */

/**
 * @brief   Initializes the given `ZydisFormatter` instance.
 *
 * @param   formatter   A pointer to the `ZydisFormatter` instance.
 * @param   style       The formatter style.
 *
 * @return  A zydis status code.
 */
ZYDIS_EXPORT ZydisStatus ZydisFormatterInit(ZydisFormatter* formatter, ZydisFormatterStyle style);

/**
 * @brief   Sets the value of the specified formatter `attribute`.
 *
 * @param   formatter   A pointer to the `ZydisFormatter` instance.
 * @param   property    The id of the formatter-property.
 * @param   value       The new value.
 *
 * @return  A zydis status code.
 */
ZYDIS_EXPORT ZydisStatus ZydisFormatterSetProperty(ZydisFormatter* formatter,
    ZydisFormatterProperty property, ZydisUPointer value);

/**
 * @brief   Replaces a formatter function with a custom callback and/or retrieves the currently
 *          used function.
 *
 * @param   formatter   A pointer to the `ZydisFormatter` instance.
 * @param   hook        The formatter hook-type.
 * @param   callback    A pointer to a variable that contains the pointer of the callback function
 *                      and receives the pointer of the currently used function.
 *
 * @return  A zydis status code.
 * 
 * Call this function with `callback` pointing to a `NULL` value to retrieve the currently used
 * function without replacing it.
 */
ZYDIS_EXPORT ZydisStatus ZydisFormatterSetHook(ZydisFormatter* formatter, 
    ZydisFormatterHookType hook, const void** callback);

/**
 * @brief   Formats the given instruction and writes it into the output buffer.
 *
 * @param   formatter   A pointer to the `ZydisFormatter` instance.
 * @param   instruction A pointer to the `ZydisDecodedInstruction` struct.
 * @param   buffer      A pointer to the output buffer.
 * @param   bufferLen   The length of the output buffer.
 *
 * @return  A zydis status code.
 */
ZYDIS_EXPORT ZydisStatus ZydisFormatterFormatInstruction(const ZydisFormatter* formatter, 
    const ZydisDecodedInstruction* instruction, char* buffer, ZydisUSize bufferLen);

/**
 * @brief   Formats the given instruction and writes it into the output buffer.
 *
 * @param   formatter   A pointer to the `ZydisFormatter` instance.
 * @param   instruction A pointer to the `ZydisDecodedInstruction` struct.
 * @param   buffer      A pointer to the output buffer.
 * @param   bufferLen   The length of the output buffer.
 * @param   userData    A pointer to user-defined data which can be used in custom formatter 
 *                      callbacks.
 *
 * @return  A zydis status code.
 */
ZYDIS_EXPORT ZydisStatus ZydisFormatterFormatInstructionEx(const ZydisFormatter* formatter, 
    const ZydisDecodedInstruction* instruction, char* buffer, ZydisUSize bufferLen, void* userData);

/* ============================================================================================== */

#ifdef __cplusplus
}
#endif

#endif /* ZYDIS_FORMATTER_H */

```

`Avanguard/Zydis/Zydis/Generated/EnumISAExt.h`:

```h
/**
 * @brief   Defines the `ZydisISAExt` datatype.
 */
typedef ZydisU8 ZydisISAExt;

/**
 * @brief   Values that represent `ZydisISAExt` elements.
 */
enum ZydisISAExts
{
    ZYDIS_ISA_EXT_INVALID,
    ZYDIS_ISA_EXT_ADOX_ADCX,
    ZYDIS_ISA_EXT_AES,
    ZYDIS_ISA_EXT_AMD,
    ZYDIS_ISA_EXT_AMD3DNOW,
    ZYDIS_ISA_EXT_AVX,
    ZYDIS_ISA_EXT_AVX2,
    ZYDIS_ISA_EXT_AVX2GATHER,
    ZYDIS_ISA_EXT_AVX512BW_128,
    ZYDIS_ISA_EXT_AVX512BW_128N,
    ZYDIS_ISA_EXT_AVX512BW_256,
    ZYDIS_ISA_EXT_AVX512BW_512,
    ZYDIS_ISA_EXT_AVX512BW_KOP,
    ZYDIS_ISA_EXT_AVX512CD_128,
    ZYDIS_ISA_EXT_AVX512CD_256,
    ZYDIS_ISA_EXT_AVX512CD_512,
    ZYDIS_ISA_EXT_AVX512DQ_128,
    ZYDIS_ISA_EXT_AVX512DQ_128N,
    ZYDIS_ISA_EXT_AVX512DQ_256,
    ZYDIS_ISA_EXT_AVX512DQ_512,
    ZYDIS_ISA_EXT_AVX512DQ_KOP,
    ZYDIS_ISA_EXT_AVX512DQ_SCALAR,
    ZYDIS_ISA_EXT_AVX512ER_512,
    ZYDIS_ISA_EXT_AVX512ER_SCALAR,
    ZYDIS_ISA_EXT_AVX512F_128,
    ZYDIS_ISA_EXT_AVX512F_128N,
    ZYDIS_ISA_EXT_AVX512F_256,
    ZYDIS_ISA_EXT_AVX512F_512,
    ZYDIS_ISA_EXT_AVX512F_KOP,
    ZYDIS_ISA_EXT_AVX512F_SCALAR,
    ZYDIS_ISA_EXT_AVX512PF_512,
    ZYDIS_ISA_EXT_AVX512_4FMAPS_512,
    ZYDIS_ISA_EXT_AVX512_4FMAPS_SCALAR,
    ZYDIS_ISA_EXT_AVX512_4VNNIW_512,
    ZYDIS_ISA_EXT_AVX512_BITALG_128,
    ZYDIS_ISA_EXT_AVX512_BITALG_256,
    ZYDIS_ISA_EXT_AVX512_BITALG_512,
    ZYDIS_ISA_EXT_AVX512_GFNI_128,
    ZYDIS_ISA_EXT_AVX512_GFNI_256,
    ZYDIS_ISA_EXT_AVX512_GFNI_512,
    ZYDIS_ISA_EXT_AVX512_IFMA_128,
    ZYDIS_ISA_EXT_AVX512_IFMA_256,
    ZYDIS_ISA_EXT_AVX512_IFMA_512,
    ZYDIS_ISA_EXT_AVX512_VAES_128,
    ZYDIS_ISA_EXT_AVX512_VAES_256,
    ZYDIS_ISA_EXT_AVX512_VAES_512,
    ZYDIS_ISA_EXT_AVX512_VBMI2_128,
    ZYDIS_ISA_EXT_AVX512_VBMI2_256,
    ZYDIS_ISA_EXT_AVX512_VBMI2_512,
    ZYDIS_ISA_EXT_AVX512_VBMI_128,
    ZYDIS_ISA_EXT_AVX512_VBMI_256,
    ZYDIS_ISA_EXT_AVX512_VBMI_512,
    ZYDIS_ISA_EXT_AVX512_VNNI_128,
    ZYDIS_ISA_EXT_AVX512_VNNI_256,
    ZYDIS_ISA_EXT_AVX512_VNNI_512,
    ZYDIS_ISA_EXT_AVX512_VPCLMULQDQ_128,
    ZYDIS_ISA_EXT_AVX512_VPCLMULQDQ_256,
    ZYDIS_ISA_EXT_AVX512_VPCLMULQDQ_512,
    ZYDIS_ISA_EXT_AVX512_VPOPCNTDQ_512,
    ZYDIS_ISA_EXT_AVXAES,
    ZYDIS_ISA_EXT_BMI1,
    ZYDIS_ISA_EXT_BMI2,
    ZYDIS_ISA_EXT_CET,
    ZYDIS_ISA_EXT_CLFLUSHOPT,
    ZYDIS_ISA_EXT_CLFSH,
    ZYDIS_ISA_EXT_CLWB,
    ZYDIS_ISA_EXT_CLZERO,
    ZYDIS_ISA_EXT_CMOV,
    ZYDIS_ISA_EXT_CMPXCHG16B,
    ZYDIS_ISA_EXT_F16C,
    ZYDIS_ISA_EXT_FAT_NOP,
    ZYDIS_ISA_EXT_FCMOV,
    ZYDIS_ISA_EXT_FMA,
    ZYDIS_ISA_EXT_FMA4,
    ZYDIS_ISA_EXT_FXSAVE,
    ZYDIS_ISA_EXT_FXSAVE64,
    ZYDIS_ISA_EXT_GFNI,
    ZYDIS_ISA_EXT_I186,
    ZYDIS_ISA_EXT_I286PROTECTED,
    ZYDIS_ISA_EXT_I286REAL,
    ZYDIS_ISA_EXT_I386,
    ZYDIS_ISA_EXT_I486,
    ZYDIS_ISA_EXT_I486REAL,
    ZYDIS_ISA_EXT_I86,
    ZYDIS_ISA_EXT_INVPCID,
    ZYDIS_ISA_EXT_KNCE,
    ZYDIS_ISA_EXT_KNCJKBR,
    ZYDIS_ISA_EXT_KNCSTREAM,
    ZYDIS_ISA_EXT_KNCV,
    ZYDIS_ISA_EXT_KNC_MISC,
    ZYDIS_ISA_EXT_KNC_PF_HINT,
    ZYDIS_ISA_EXT_LAHF,
    ZYDIS_ISA_EXT_LONGMODE,
    ZYDIS_ISA_EXT_LZCNT,
    ZYDIS_ISA_EXT_MONITOR,
    ZYDIS_ISA_EXT_MOVBE,
    ZYDIS_ISA_EXT_MPX,
    ZYDIS_ISA_EXT_PAUSE,
    ZYDIS_ISA_EXT_PCLMULQDQ,
    ZYDIS_ISA_EXT_PCONFIG,
    ZYDIS_ISA_EXT_PENTIUMMMX,
    ZYDIS_ISA_EXT_PENTIUMREAL,
    ZYDIS_ISA_EXT_PKU,
    ZYDIS_ISA_EXT_POPCNT,
    ZYDIS_ISA_EXT_PPRO,
    ZYDIS_ISA_EXT_PREFETCHWT1,
    ZYDIS_ISA_EXT_PREFETCH_NOP,
    ZYDIS_ISA_EXT_PT,
    ZYDIS_ISA_EXT_RDPID,
    ZYDIS_ISA_EXT_RDPMC,
    ZYDIS_ISA_EXT_RDRAND,
    ZYDIS_ISA_EXT_RDSEED,
    ZYDIS_ISA_EXT_RDTSCP,
    ZYDIS_ISA_EXT_RDWRFSGS,
    ZYDIS_ISA_EXT_RTM,
    ZYDIS_ISA_EXT_SGX,
    ZYDIS_ISA_EXT_SHA,
    ZYDIS_ISA_EXT_SMAP,
    ZYDIS_ISA_EXT_SMX,
    ZYDIS_ISA_EXT_SSE,
    ZYDIS_ISA_EXT_SSE2,
    ZYDIS_ISA_EXT_SSE2MMX,
    ZYDIS_ISA_EXT_SSE3,
    ZYDIS_ISA_EXT_SSE3X87,
    ZYDIS_ISA_EXT_SSE4,
    ZYDIS_ISA_EXT_SSE42,
    ZYDIS_ISA_EXT_SSEMXCSR,
    ZYDIS_ISA_EXT_SSE_PREFETCH,
    ZYDIS_ISA_EXT_SSSE3,
    ZYDIS_ISA_EXT_SSSE3MMX,
    ZYDIS_ISA_EXT_SVM,
    ZYDIS_ISA_EXT_TBM,
    ZYDIS_ISA_EXT_VAES,
    ZYDIS_ISA_EXT_VMFUNC,
    ZYDIS_ISA_EXT_VPCLMULQDQ,
    ZYDIS_ISA_EXT_VTX,
    ZYDIS_ISA_EXT_X87,
    ZYDIS_ISA_EXT_XOP,
    ZYDIS_ISA_EXT_XSAVE,
    ZYDIS_ISA_EXT_XSAVEC,
    ZYDIS_ISA_EXT_XSAVEOPT,
    ZYDIS_ISA_EXT_XSAVES,
    ZYDIS_ISA_EXT_MAX_VALUE = ZYDIS_ISA_EXT_XSAVES,
    ZYDIS_ISA_EXT_MIN_BITS  = 0x0008
};

```

`Avanguard/Zydis/Zydis/Generated/EnumISASet.h`:

```h
/**
 * @brief   Defines the `ZydisISASet` datatype.
 */
typedef ZydisU8 ZydisISASet;

/**
 * @brief   Values that represent `ZydisISASet` elements.
 */
enum ZydisISASets
{
    ZYDIS_ISA_SET_INVALID,
    ZYDIS_ISA_SET_ADOX_ADCX,
    ZYDIS_ISA_SET_AES,
    ZYDIS_ISA_SET_AMD3DNOW,
    ZYDIS_ISA_SET_AVX,
    ZYDIS_ISA_SET_AVX2,
    ZYDIS_ISA_SET_AVX2GATHER,
    ZYDIS_ISA_SET_AVX512EVEX,
    ZYDIS_ISA_SET_AVX512VEX,
    ZYDIS_ISA_SET_AVXAES,
    ZYDIS_ISA_SET_BASE,
    ZYDIS_ISA_SET_BMI1,
    ZYDIS_ISA_SET_BMI2,
    ZYDIS_ISA_SET_CET,
    ZYDIS_ISA_SET_CLFLUSHOPT,
    ZYDIS_ISA_SET_CLFSH,
    ZYDIS_ISA_SET_CLWB,
    ZYDIS_ISA_SET_CLZERO,
    ZYDIS_ISA_SET_F16C,
    ZYDIS_ISA_SET_FMA,
    ZYDIS_ISA_SET_FMA4,
    ZYDIS_ISA_SET_GFNI,
    ZYDIS_ISA_SET_INVPCID,
    ZYDIS_ISA_SET_KNC,
    ZYDIS_ISA_SET_KNCE,
    ZYDIS_ISA_SET_KNCV,
    ZYDIS_ISA_SET_LONGMODE,
    ZYDIS_ISA_SET_LZCNT,
    ZYDIS_ISA_SET_MMX,
    ZYDIS_ISA_SET_MONITOR,
    ZYDIS_ISA_SET_MOVBE,
    ZYDIS_ISA_SET_MPX,
    ZYDIS_ISA_SET_PAUSE,
    ZYDIS_ISA_SET_PCLMULQDQ,
    ZYDIS_ISA_SET_PCONFIG,
    ZYDIS_ISA_SET_PKU,
    ZYDIS_ISA_SET_PREFETCHWT1,
    ZYDIS_ISA_SET_PT,
    ZYDIS_ISA_SET_RDPID,
    ZYDIS_ISA_SET_RDRAND,
    ZYDIS_ISA_SET_RDSEED,
    ZYDIS_ISA_SET_RDTSCP,
    ZYDIS_ISA_SET_RDWRFSGS,
    ZYDIS_ISA_SET_RTM,
    ZYDIS_ISA_SET_SGX,
    ZYDIS_ISA_SET_SHA,
    ZYDIS_ISA_SET_SMAP,
    ZYDIS_ISA_SET_SMX,
    ZYDIS_ISA_SET_SSE,
    ZYDIS_ISA_SET_SSE2,
    ZYDIS_ISA_SET_SSE3,
    ZYDIS_ISA_SET_SSE4,
    ZYDIS_ISA_SET_SSSE3,
    ZYDIS_ISA_SET_SVM,
    ZYDIS_ISA_SET_TBM,
    ZYDIS_ISA_SET_VAES,
    ZYDIS_ISA_SET_VMFUNC,
    ZYDIS_ISA_SET_VPCLMULQDQ,
    ZYDIS_ISA_SET_VTX,
    ZYDIS_ISA_SET_X87,
    ZYDIS_ISA_SET_XOP,
    ZYDIS_ISA_SET_XSAVE,
    ZYDIS_ISA_SET_XSAVEC,
    ZYDIS_ISA_SET_XSAVEOPT,
    ZYDIS_ISA_SET_XSAVES,
    ZYDIS_ISA_SET_MAX_VALUE = ZYDIS_ISA_SET_XSAVES,
    ZYDIS_ISA_SET_MIN_BITS  = 0x0007
};

```

`Avanguard/Zydis/Zydis/Generated/EnumInstructionCategory.h`:

```h
/**
 * @brief   Defines the `ZydisInstructionCategory` datatype.
 */
typedef ZydisU8 ZydisInstructionCategory;

/**
 * @brief   Values that represent `ZydisInstructionCategory` elements.
 */
enum ZydisInstructionCategories
{
    ZYDIS_CATEGORY_INVALID,
    ZYDIS_CATEGORY_ADOX_ADCX,
    ZYDIS_CATEGORY_AES,
    ZYDIS_CATEGORY_AMD3DNOW,
    ZYDIS_CATEGORY_AVX,
    ZYDIS_CATEGORY_AVX2,
    ZYDIS_CATEGORY_AVX2GATHER,
    ZYDIS_CATEGORY_AVX512,
    ZYDIS_CATEGORY_AVX512_4FMAPS,
    ZYDIS_CATEGORY_AVX512_4VNNIW,
    ZYDIS_CATEGORY_AVX512_BITALG,
    ZYDIS_CATEGORY_AVX512_VBMI,
    ZYDIS_CATEGORY_BINARY,
    ZYDIS_CATEGORY_BITBYTE,
    ZYDIS_CATEGORY_BLEND,
    ZYDIS_CATEGORY_BMI1,
    ZYDIS_CATEGORY_BMI2,
    ZYDIS_CATEGORY_BROADCAST,
    ZYDIS_CATEGORY_CALL,
    ZYDIS_CATEGORY_CET,
    ZYDIS_CATEGORY_CLFLUSHOPT,
    ZYDIS_CATEGORY_CLWB,
    ZYDIS_CATEGORY_CLZERO,
    ZYDIS_CATEGORY_CMOV,
    ZYDIS_CATEGORY_COMPRESS,
    ZYDIS_CATEGORY_COND_BR,
    ZYDIS_CATEGORY_CONFLICT,
    ZYDIS_CATEGORY_CONVERT,
    ZYDIS_CATEGORY_DATAXFER,
    ZYDIS_CATEGORY_DECIMAL,
    ZYDIS_CATEGORY_EXPAND,
    ZYDIS_CATEGORY_FCMOV,
    ZYDIS_CATEGORY_FLAGOP,
    ZYDIS_CATEGORY_FMA4,
    ZYDIS_CATEGORY_GATHER,
    ZYDIS_CATEGORY_GFNI,
    ZYDIS_CATEGORY_IFMA,
    ZYDIS_CATEGORY_INTERRUPT,
    ZYDIS_CATEGORY_IO,
    ZYDIS_CATEGORY_IOSTRINGOP,
    ZYDIS_CATEGORY_KMASK,
    ZYDIS_CATEGORY_KNC,
    ZYDIS_CATEGORY_KNCMASK,
    ZYDIS_CATEGORY_KNCSCALAR,
    ZYDIS_CATEGORY_LOGICAL,
    ZYDIS_CATEGORY_LOGICAL_FP,
    ZYDIS_CATEGORY_LZCNT,
    ZYDIS_CATEGORY_MISC,
    ZYDIS_CATEGORY_MMX,
    ZYDIS_CATEGORY_MPX,
    ZYDIS_CATEGORY_NOP,
    ZYDIS_CATEGORY_PCLMULQDQ,
    ZYDIS_CATEGORY_PCONFIG,
    ZYDIS_CATEGORY_PKU,
    ZYDIS_CATEGORY_POP,
    ZYDIS_CATEGORY_PREFETCH,
    ZYDIS_CATEGORY_PREFETCHWT1,
    ZYDIS_CATEGORY_PT,
    ZYDIS_CATEGORY_PUSH,
    ZYDIS_CATEGORY_RDPID,
    ZYDIS_CATEGORY_RDRAND,
    ZYDIS_CATEGORY_RDSEED,
    ZYDIS_CATEGORY_RDWRFSGS,
    ZYDIS_CATEGORY_RET,
    ZYDIS_CATEGORY_ROTATE,
    ZYDIS_CATEGORY_SCATTER,
    ZYDIS_CATEGORY_SEGOP,
    ZYDIS_CATEGORY_SEMAPHORE,
    ZYDIS_CATEGORY_SETCC,
    ZYDIS_CATEGORY_SGX,
    ZYDIS_CATEGORY_SHA,
    ZYDIS_CATEGORY_SHIFT,
    ZYDIS_CATEGORY_SMAP,
    ZYDIS_CATEGORY_SSE,
    ZYDIS_CATEGORY_STRINGOP,
    ZYDIS_CATEGORY_STTNI,
    ZYDIS_CATEGORY_SYSCALL,
    ZYDIS_CATEGORY_SYSRET,
    ZYDIS_CATEGORY_SYSTEM,
    ZYDIS_CATEGORY_TBM,
    ZYDIS_CATEGORY_UFMA,
    ZYDIS_CATEGORY_UNCOND_BR,
    ZYDIS_CATEGORY_VAES,
    ZYDIS_CATEGORY_VBMI2,
    ZYDIS_CATEGORY_VFMA,
    ZYDIS_CATEGORY_VPCLMULQDQ,
    ZYDIS_CATEGORY_VTX,
    ZYDIS_CATEGORY_WIDENOP,
    ZYDIS_CATEGORY_X87_ALU,
    ZYDIS_CATEGORY_XOP,
    ZYDIS_CATEGORY_XSAVE,
    ZYDIS_CATEGORY_XSAVEOPT,
    ZYDIS_CATEGORY_MAX_VALUE = ZYDIS_CATEGORY_XSAVEOPT,
    ZYDIS_CATEGORY_MIN_BITS  = 0x0007
};

```

`Avanguard/Zydis/Zydis/Generated/EnumMnemonic.h`:

```h
/**
 * @brief   Defines the `ZydisMnemonic` datatype.
 */
typedef ZydisU16 ZydisMnemonic;

/**
 * @brief   Values that represent `ZydisMnemonic` elements.
 */
enum ZydisMnemonics
{
    ZYDIS_MNEMONIC_INVALID,
    ZYDIS_MNEMONIC_AAA,
    ZYDIS_MNEMONIC_AAD,
    ZYDIS_MNEMONIC_AAM,
    ZYDIS_MNEMONIC_AAS,
    ZYDIS_MNEMONIC_ADC,
    ZYDIS_MNEMONIC_ADCX,
    ZYDIS_MNEMONIC_ADD,
    ZYDIS_MNEMONIC_ADDPD,
    ZYDIS_MNEMONIC_ADDPS,
    ZYDIS_MNEMONIC_ADDSD,
    ZYDIS_MNEMONIC_ADDSS,
    ZYDIS_MNEMONIC_ADDSUBPD,
    ZYDIS_MNEMONIC_ADDSUBPS,
    ZYDIS_MNEMONIC_ADOX,
    ZYDIS_MNEMONIC_AESDEC,
    ZYDIS_MNEMONIC_AESDECLAST,
    ZYDIS_MNEMONIC_AESENC,
    ZYDIS_MNEMONIC_AESENCLAST,
    ZYDIS_MNEMONIC_AESIMC,
    ZYDIS_MNEMONIC_AESKEYGENASSIST,
    ZYDIS_MNEMONIC_AND,
    ZYDIS_MNEMONIC_ANDN,
    ZYDIS_MNEMONIC_ANDNPD,
    ZYDIS_MNEMONIC_ANDNPS,
    ZYDIS_MNEMONIC_ANDPD,
    ZYDIS_MNEMONIC_ANDPS,
    ZYDIS_MNEMONIC_ARPL,
    ZYDIS_MNEMONIC_BEXTR,
    ZYDIS_MNEMONIC_BLCFILL,
    ZYDIS_MNEMONIC_BLCI,
    ZYDIS_MNEMONIC_BLCIC,
    ZYDIS_MNEMONIC_BLCMSK,
    ZYDIS_MNEMONIC_BLCS,
    ZYDIS_MNEMONIC_BLENDPD,
    ZYDIS_MNEMONIC_BLENDPS,
    ZYDIS_MNEMONIC_BLENDVPD,
    ZYDIS_MNEMONIC_BLENDVPS,
    ZYDIS_MNEMONIC_BLSFILL,
    ZYDIS_MNEMONIC_BLSI,
    ZYDIS_MNEMONIC_BLSIC,
    ZYDIS_MNEMONIC_BLSMSK,
    ZYDIS_MNEMONIC_BLSR,
    ZYDIS_MNEMONIC_BNDCL,
    ZYDIS_MNEMONIC_BNDCN,
    ZYDIS_MNEMONIC_BNDCU,
    ZYDIS_MNEMONIC_BNDLDX,
    ZYDIS_MNEMONIC_BNDMK,
    ZYDIS_MNEMONIC_BNDMOV,
    ZYDIS_MNEMONIC_BNDSTX,
    ZYDIS_MNEMONIC_BOUND,
    ZYDIS_MNEMONIC_BSF,
    ZYDIS_MNEMONIC_BSR,
    ZYDIS_MNEMONIC_BSWAP,
    ZYDIS_MNEMONIC_BT,
    ZYDIS_MNEMONIC_BTC,
    ZYDIS_MNEMONIC_BTR,
    ZYDIS_MNEMONIC_BTS,
    ZYDIS_MNEMONIC_BZHI,
    ZYDIS_MNEMONIC_CALL,
    ZYDIS_MNEMONIC_CBW,
    ZYDIS_MNEMONIC_CDQ,
    ZYDIS_MNEMONIC_CDQE,
    ZYDIS_MNEMONIC_CLAC,
    ZYDIS_MNEMONIC_CLC,
    ZYDIS_MNEMONIC_CLD,
    ZYDIS_MNEMONIC_CLEVICT0,
    ZYDIS_MNEMONIC_CLEVICT1,
    ZYDIS_MNEMONIC_CLFLUSH,
    ZYDIS_MNEMONIC_CLFLUSHOPT,
    ZYDIS_MNEMONIC_CLGI,
    ZYDIS_MNEMONIC_CLI,
    ZYDIS_MNEMONIC_CLRSSBSY,
    ZYDIS_MNEMONIC_CLTS,
    ZYDIS_MNEMONIC_CLWB,
    ZYDIS_MNEMONIC_CLZERO,
    ZYDIS_MNEMONIC_CMC,
    ZYDIS_MNEMONIC_CMOVB,
    ZYDIS_MNEMONIC_CMOVBE,
    ZYDIS_MNEMONIC_CMOVL,
    ZYDIS_MNEMONIC_CMOVLE,
    ZYDIS_MNEMONIC_CMOVNB,
    ZYDIS_MNEMONIC_CMOVNBE,
    ZYDIS_MNEMONIC_CMOVNL,
    ZYDIS_MNEMONIC_CMOVNLE,
    ZYDIS_MNEMONIC_CMOVNO,
    ZYDIS_MNEMONIC_CMOVNP,
    ZYDIS_MNEMONIC_CMOVNS,
    ZYDIS_MNEMONIC_CMOVNZ,
    ZYDIS_MNEMONIC_CMOVO,
    ZYDIS_MNEMONIC_CMOVP,
    ZYDIS_MNEMONIC_CMOVS,
    ZYDIS_MNEMONIC_CMOVZ,
    ZYDIS_MNEMONIC_CMP,
    ZYDIS_MNEMONIC_CMPPD,
    ZYDIS_MNEMONIC_CMPPS,
    ZYDIS_MNEMONIC_CMPSB,
    ZYDIS_MNEMONIC_CMPSD,
    ZYDIS_MNEMONIC_CMPSQ,
    ZYDIS_MNEMONIC_CMPSS,
    ZYDIS_MNEMONIC_CMPSW,
    ZYDIS_MNEMONIC_CMPXCHG,
    ZYDIS_MNEMONIC_CMPXCHG16B,
    ZYDIS_MNEMONIC_CMPXCHG8B,
    ZYDIS_MNEMONIC_COMISD,
    ZYDIS_MNEMONIC_COMISS,
    ZYDIS_MNEMONIC_CPUID,
    ZYDIS_MNEMONIC_CQO,
    ZYDIS_MNEMONIC_CRC32,
    ZYDIS_MNEMONIC_CVTDQ2PD,
    ZYDIS_MNEMONIC_CVTDQ2PS,
    ZYDIS_MNEMONIC_CVTPD2DQ,
    ZYDIS_MNEMONIC_CVTPD2PI,
    ZYDIS_MNEMONIC_CVTPD2PS,
    ZYDIS_MNEMONIC_CVTPI2PD,
    ZYDIS_MNEMONIC_CVTPI2PS,
    ZYDIS_MNEMONIC_CVTPS2DQ,
    ZYDIS_MNEMONIC_CVTPS2PD,
    ZYDIS_MNEMONIC_CVTPS2PI,
    ZYDIS_MNEMONIC_CVTSD2SI,
    ZYDIS_MNEMONIC_CVTSD2SS,
    ZYDIS_MNEMONIC_CVTSI2SD,
    ZYDIS_MNEMONIC_CVTSI2SS,
    ZYDIS_MNEMONIC_CVTSS2SD,
    ZYDIS_MNEMONIC_CVTSS2SI,
    ZYDIS_MNEMONIC_CVTTPD2DQ,
    ZYDIS_MNEMONIC_CVTTPD2PI,
    ZYDIS_MNEMONIC_CVTTPS2DQ,
    ZYDIS_MNEMONIC_CVTTPS2PI,
    ZYDIS_MNEMONIC_CVTTSD2SI,
    ZYDIS_MNEMONIC_CVTTSS2SI,
    ZYDIS_MNEMONIC_CWD,
    ZYDIS_MNEMONIC_CWDE,
    ZYDIS_MNEMONIC_DAA,
    ZYDIS_MNEMONIC_DAS,
    ZYDIS_MNEMONIC_DEC,
    ZYDIS_MNEMONIC_DELAY,
    ZYDIS_MNEMONIC_DIV,
    ZYDIS_MNEMONIC_DIVPD,
    ZYDIS_MNEMONIC_DIVPS,
    ZYDIS_MNEMONIC_DIVSD,
    ZYDIS_MNEMONIC_DIVSS,
    ZYDIS_MNEMONIC_DPPD,
    ZYDIS_MNEMONIC_DPPS,
    ZYDIS_MNEMONIC_EMMS,
    ZYDIS_MNEMONIC_ENCLS,
    ZYDIS_MNEMONIC_ENCLU,
    ZYDIS_MNEMONIC_ENDBR32,
    ZYDIS_MNEMONIC_ENDBR64,
    ZYDIS_MNEMONIC_ENTER,
    ZYDIS_MNEMONIC_EXTRACTPS,
    ZYDIS_MNEMONIC_F2XM1,
    ZYDIS_MNEMONIC_FABS,
    ZYDIS_MNEMONIC_FADD,
    ZYDIS_MNEMONIC_FADDP,
    ZYDIS_MNEMONIC_FBLD,
    ZYDIS_MNEMONIC_FBSTP,
    ZYDIS_MNEMONIC_FCHS,
    ZYDIS_MNEMONIC_FCMOVB,
    ZYDIS_MNEMONIC_FCMOVBE,
    ZYDIS_MNEMONIC_FCMOVE,
    ZYDIS_MNEMONIC_FCMOVNB,
    ZYDIS_MNEMONIC_FCMOVNBE,
    ZYDIS_MNEMONIC_FCMOVNE,
    ZYDIS_MNEMONIC_FCMOVNU,
    ZYDIS_MNEMONIC_FCMOVU,
    ZYDIS_MNEMONIC_FCOM,
    ZYDIS_MNEMONIC_FCOMI,
    ZYDIS_MNEMONIC_FCOMIP,
    ZYDIS_MNEMONIC_FCOMP,
    ZYDIS_MNEMONIC_FCOMPP,
    ZYDIS_MNEMONIC_FCOS,
    ZYDIS_MNEMONIC_FDECSTP,
    ZYDIS_MNEMONIC_FDISI8087_NOP,
    ZYDIS_MNEMONIC_FDIV,
    ZYDIS_MNEMONIC_FDIVP,
    ZYDIS_MNEMONIC_FDIVR,
    ZYDIS_MNEMONIC_FDIVRP,
    ZYDIS_MNEMONIC_FEMMS,
    ZYDIS_MNEMONIC_FENI8087_NOP,
    ZYDIS_MNEMONIC_FFREE,
    ZYDIS_MNEMONIC_FFREEP,
    ZYDIS_MNEMONIC_FIADD,
    ZYDIS_MNEMONIC_FICOM,
    ZYDIS_MNEMONIC_FICOMP,
    ZYDIS_MNEMONIC_FIDIV,
    ZYDIS_MNEMONIC_FIDIVR,
    ZYDIS_MNEMONIC_FILD,
    ZYDIS_MNEMONIC_FIMUL,
    ZYDIS_MNEMONIC_FINCSTP,
    ZYDIS_MNEMONIC_FIST,
    ZYDIS_MNEMONIC_FISTP,
    ZYDIS_MNEMONIC_FISTTP,
    ZYDIS_MNEMONIC_FISUB,
    ZYDIS_MNEMONIC_FISUBR,
    ZYDIS_MNEMONIC_FLD,
    ZYDIS_MNEMONIC_FLD1,
    ZYDIS_MNEMONIC_FLDCW,
    ZYDIS_MNEMONIC_FLDENV,
    ZYDIS_MNEMONIC_FLDL2E,
    ZYDIS_MNEMONIC_FLDL2T,
    ZYDIS_MNEMONIC_FLDLG2,
    ZYDIS_MNEMONIC_FLDLN2,
    ZYDIS_MNEMONIC_FLDPI,
    ZYDIS_MNEMONIC_FLDZ,
    ZYDIS_MNEMONIC_FMUL,
    ZYDIS_MNEMONIC_FMULP,
    ZYDIS_MNEMONIC_FNCLEX,
    ZYDIS_MNEMONIC_FNINIT,
    ZYDIS_MNEMONIC_FNOP,
    ZYDIS_MNEMONIC_FNSAVE,
    ZYDIS_MNEMONIC_FNSTCW,
    ZYDIS_MNEMONIC_FNSTENV,
    ZYDIS_MNEMONIC_FNSTSW,
    ZYDIS_MNEMONIC_FPATAN,
    ZYDIS_MNEMONIC_FPREM,
    ZYDIS_MNEMONIC_FPREM1,
    ZYDIS_MNEMONIC_FPTAN,
    ZYDIS_MNEMONIC_FRNDINT,
    ZYDIS_MNEMONIC_FRSTOR,
    ZYDIS_MNEMONIC_FSCALE,
    ZYDIS_MNEMONIC_FSETPM287_NOP,
    ZYDIS_MNEMONIC_FSIN,
    ZYDIS_MNEMONIC_FSINCOS,
    ZYDIS_MNEMONIC_FSQRT,
    ZYDIS_MNEMONIC_FST,
    ZYDIS_MNEMONIC_FSTP,
    ZYDIS_MNEMONIC_FSTPNCE,
    ZYDIS_MNEMONIC_FSUB,
    ZYDIS_MNEMONIC_FSUBP,
    ZYDIS_MNEMONIC_FSUBR,
    ZYDIS_MNEMONIC_FSUBRP,
    ZYDIS_MNEMONIC_FTST,
    ZYDIS_MNEMONIC_FUCOM,
    ZYDIS_MNEMONIC_FUCOMI,
    ZYDIS_MNEMONIC_FUCOMIP,
    ZYDIS_MNEMONIC_FUCOMP,
    ZYDIS_MNEMONIC_FUCOMPP,
    ZYDIS_MNEMONIC_FWAIT,
    ZYDIS_MNEMONIC_FXAM,
    ZYDIS_MNEMONIC_FXCH,
    ZYDIS_MNEMONIC_FXRSTOR,
    ZYDIS_MNEMONIC_FXRSTOR64,
    ZYDIS_MNEMONIC_FXSAVE,
    ZYDIS_MNEMONIC_FXSAVE64,
    ZYDIS_MNEMONIC_FXTRACT,
    ZYDIS_MNEMONIC_FYL2X,
    ZYDIS_MNEMONIC_FYL2XP1,
    ZYDIS_MNEMONIC_GETSEC,
    ZYDIS_MNEMONIC_GF2P8AFFINEINVQB,
    ZYDIS_MNEMONIC_GF2P8AFFINEQB,
    ZYDIS_MNEMONIC_GF2P8MULB,
    ZYDIS_MNEMONIC_HADDPD,
    ZYDIS_MNEMONIC_HADDPS,
    ZYDIS_MNEMONIC_HLT,
    ZYDIS_MNEMONIC_HSUBPD,
    ZYDIS_MNEMONIC_HSUBPS,
    ZYDIS_MNEMONIC_IDIV,
    ZYDIS_MNEMONIC_IMUL,
    ZYDIS_MNEMONIC_IN,
    ZYDIS_MNEMONIC_INC,
    ZYDIS_MNEMONIC_INCSSPD,
    ZYDIS_MNEMONIC_INCSSPQ,
    ZYDIS_MNEMONIC_INSB,
    ZYDIS_MNEMONIC_INSD,
    ZYDIS_MNEMONIC_INSERTPS,
    ZYDIS_MNEMONIC_INSW,
    ZYDIS_MNEMONIC_INT,
    ZYDIS_MNEMONIC_INT1,
    ZYDIS_MNEMONIC_INT3,
    ZYDIS_MNEMONIC_INTO,
    ZYDIS_MNEMONIC_INVD,
    ZYDIS_MNEMONIC_INVEPT,
    ZYDIS_MNEMONIC_INVLPG,
    ZYDIS_MNEMONIC_INVLPGA,
    ZYDIS_MNEMONIC_INVPCID,
    ZYDIS_MNEMONIC_INVVPID,
    ZYDIS_MNEMONIC_IRET,
    ZYDIS_MNEMONIC_IRETD,
    ZYDIS_MNEMONIC_IRETQ,
    ZYDIS_MNEMONIC_JB,
    ZYDIS_MNEMONIC_JBE,
    ZYDIS_MNEMONIC_JCXZ,
    ZYDIS_MNEMONIC_JECXZ,
    ZYDIS_MNEMONIC_JKNZD,
    ZYDIS_MNEMONIC_JKZD,
    ZYDIS_MNEMONIC_JL,
    ZYDIS_MNEMONIC_JLE,
    ZYDIS_MNEMONIC_JMP,
    ZYDIS_MNEMONIC_JNB,
    ZYDIS_MNEMONIC_JNBE,
    ZYDIS_MNEMONIC_JNL,
    ZYDIS_MNEMONIC_JNLE,
    ZYDIS_MNEMONIC_JNO,
    ZYDIS_MNEMONIC_JNP,
    ZYDIS_MNEMONIC_JNS,
    ZYDIS_MNEMONIC_JNZ,
    ZYDIS_MNEMONIC_JO,
    ZYDIS_MNEMONIC_JP,
    ZYDIS_MNEMONIC_JRCXZ,
    ZYDIS_MNEMONIC_JS,
    ZYDIS_MNEMONIC_JZ,
    ZYDIS_MNEMONIC_KADDB,
    ZYDIS_MNEMONIC_KADDD,
    ZYDIS_MNEMONIC_KADDQ,
    ZYDIS_MNEMONIC_KADDW,
    ZYDIS_MNEMONIC_KAND,
    ZYDIS_MNEMONIC_KANDB,
    ZYDIS_MNEMONIC_KANDD,
    ZYDIS_MNEMONIC_KANDN,
    ZYDIS_MNEMONIC_KANDNB,
    ZYDIS_MNEMONIC_KANDND,
    ZYDIS_MNEMONIC_KANDNQ,
    ZYDIS_MNEMONIC_KANDNR,
    ZYDIS_MNEMONIC_KANDNW,
    ZYDIS_MNEMONIC_KANDQ,
    ZYDIS_MNEMONIC_KANDW,
    ZYDIS_MNEMONIC_KCONCATH,
    ZYDIS_MNEMONIC_KCONCATL,
    ZYDIS_MNEMONIC_KEXTRACT,
    ZYDIS_MNEMONIC_KMERGE2L1H,
    ZYDIS_MNEMONIC_KMERGE2L1L,
    ZYDIS_MNEMONIC_KMOV,
    ZYDIS_MNEMONIC_KMOVB,
    ZYDIS_MNEMONIC_KMOVD,
    ZYDIS_MNEMONIC_KMOVQ,
    ZYDIS_MNEMONIC_KMOVW,
    ZYDIS_MNEMONIC_KNOT,
    ZYDIS_MNEMONIC_KNOTB,
    ZYDIS_MNEMONIC_KNOTD,
    ZYDIS_MNEMONIC_KNOTQ,
    ZYDIS_MNEMONIC_KNOTW,
    ZYDIS_MNEMONIC_KOR,
    ZYDIS_MNEMONIC_KORB,
    ZYDIS_MNEMONIC_KORD,
    ZYDIS_MNEMONIC_KORQ,
    ZYDIS_MNEMONIC_KORTEST,
    ZYDIS_MNEMONIC_KORTESTB,
    ZYDIS_MNEMONIC_KORTESTD,
    ZYDIS_MNEMONIC_KORTESTQ,
    ZYDIS_MNEMONIC_KORTESTW,
    ZYDIS_MNEMONIC_KORW,
    ZYDIS_MNEMONIC_KSHIFTLB,
    ZYDIS_MNEMONIC_KSHIFTLD,
    ZYDIS_MNEMONIC_KSHIFTLQ,
    ZYDIS_MNEMONIC_KSHIFTLW,
    ZYDIS_MNEMONIC_KSHIFTRB,
    ZYDIS_MNEMONIC_KSHIFTRD,
    ZYDIS_MNEMONIC_KSHIFTRQ,
    ZYDIS_MNEMONIC_KSHIFTRW,
    ZYDIS_MNEMONIC_KTESTB,
    ZYDIS_MNEMONIC_KTESTD,
    ZYDIS_MNEMONIC_KTESTQ,
    ZYDIS_MNEMONIC_KTESTW,
    ZYDIS_MNEMONIC_KUNPCKBW,
    ZYDIS_MNEMONIC_KUNPCKDQ,
    ZYDIS_MNEMONIC_KUNPCKWD,
    ZYDIS_MNEMONIC_KXNOR,
    ZYDIS_MNEMONIC_KXNORB,
    ZYDIS_MNEMONIC_KXNORD,
    ZYDIS_MNEMONIC_KXNORQ,
    ZYDIS_MNEMONIC_KXNORW,
    ZYDIS_MNEMONIC_KXOR,
    ZYDIS_MNEMONIC_KXORB,
    ZYDIS_MNEMONIC_KXORD,
    ZYDIS_MNEMONIC_KXORQ,
    ZYDIS_MNEMONIC_KXORW,
    ZYDIS_MNEMONIC_LAHF,
    ZYDIS_MNEMONIC_LAR,
    ZYDIS_MNEMONIC_LDDQU,
    ZYDIS_MNEMONIC_LDMXCSR,
    ZYDIS_MNEMONIC_LDS,
    ZYDIS_MNEMONIC_LEA,
    ZYDIS_MNEMONIC_LEAVE,
    ZYDIS_MNEMONIC_LES,
    ZYDIS_MNEMONIC_LFENCE,
    ZYDIS_MNEMONIC_LFS,
    ZYDIS_MNEMONIC_LGDT,
    ZYDIS_MNEMONIC_LGS,
    ZYDIS_MNEMONIC_LIDT,
    ZYDIS_MNEMONIC_LLDT,
    ZYDIS_MNEMONIC_LLWPCB,
    ZYDIS_MNEMONIC_LMSW,
    ZYDIS_MNEMONIC_LODSB,
    ZYDIS_MNEMONIC_LODSD,
    ZYDIS_MNEMONIC_LODSQ,
    ZYDIS_MNEMONIC_LODSW,
    ZYDIS_MNEMONIC_LOOP,
    ZYDIS_MNEMONIC_LOOPE,
    ZYDIS_MNEMONIC_LOOPNE,
    ZYDIS_MNEMONIC_LSL,
    ZYDIS_MNEMONIC_LSS,
    ZYDIS_MNEMONIC_LTR,
    ZYDIS_MNEMONIC_LWPINS,
    ZYDIS_MNEMONIC_LWPVAL,
    ZYDIS_MNEMONIC_LZCNT,
    ZYDIS_MNEMONIC_MASKMOVDQU,
    ZYDIS_MNEMONIC_MASKMOVQ,
    ZYDIS_MNEMONIC_MAXPD,
    ZYDIS_MNEMONIC_MAXPS,
    ZYDIS_MNEMONIC_MAXSD,
    ZYDIS_MNEMONIC_MAXSS,
    ZYDIS_MNEMONIC_MFENCE,
    ZYDIS_MNEMONIC_MINPD,
    ZYDIS_MNEMONIC_MINPS,
    ZYDIS_MNEMONIC_MINSD,
    ZYDIS_MNEMONIC_MINSS,
    ZYDIS_MNEMONIC_MONITOR,
    ZYDIS_MNEMONIC_MOV,
    ZYDIS_MNEMONIC_MOVAPD,
    ZYDIS_MNEMONIC_MOVAPS,
    ZYDIS_MNEMONIC_MOVBE,
    ZYDIS_MNEMONIC_MOVD,
    ZYDIS_MNEMONIC_MOVDDUP,
    ZYDIS_MNEMONIC_MOVDQ2Q,
    ZYDIS_MNEMONIC_MOVDQA,
    ZYDIS_MNEMONIC_MOVDQU,
    ZYDIS_MNEMONIC_MOVHLPS,
    ZYDIS_MNEMONIC_MOVHPD,
    ZYDIS_MNEMONIC_MOVHPS,
    ZYDIS_MNEMONIC_MOVLHPS,
    ZYDIS_MNEMONIC_MOVLPD,
    ZYDIS_MNEMONIC_MOVLPS,
    ZYDIS_MNEMONIC_MOVMSKPD,
    ZYDIS_MNEMONIC_MOVMSKPS,
    ZYDIS_MNEMONIC_MOVNTDQ,
    ZYDIS_MNEMONIC_MOVNTDQA,
    ZYDIS_MNEMONIC_MOVNTI,
    ZYDIS_MNEMONIC_MOVNTPD,
    ZYDIS_MNEMONIC_MOVNTPS,
    ZYDIS_MNEMONIC_MOVNTQ,
    ZYDIS_MNEMONIC_MOVQ,
    ZYDIS_MNEMONIC_MOVQ2DQ,
    ZYDIS_MNEMONIC_MOVSB,
    ZYDIS_MNEMONIC_MOVSD,
    ZYDIS_MNEMONIC_MOVSHDUP,
    ZYDIS_MNEMONIC_MOVSLDUP,
    ZYDIS_MNEMONIC_MOVSQ,
    ZYDIS_MNEMONIC_MOVSS,
    ZYDIS_MNEMONIC_MOVSW,
    ZYDIS_MNEMONIC_MOVSX,
    ZYDIS_MNEMONIC_MOVSXD,
    ZYDIS_MNEMONIC_MOVUPD,
    ZYDIS_MNEMONIC_MOVUPS,
    ZYDIS_MNEMONIC_MOVZX,
    ZYDIS_MNEMONIC_MPSADBW,
    ZYDIS_MNEMONIC_MUL,
    ZYDIS_MNEMONIC_MULPD,
    ZYDIS_MNEMONIC_MULPS,
    ZYDIS_MNEMONIC_MULSD,
    ZYDIS_MNEMONIC_MULSS,
    ZYDIS_MNEMONIC_MULX,
    ZYDIS_MNEMONIC_MWAIT,
    ZYDIS_MNEMONIC_NEG,
    ZYDIS_MNEMONIC_NOP,
    ZYDIS_MNEMONIC_NOT,
    ZYDIS_MNEMONIC_OR,
    ZYDIS_MNEMONIC_ORPD,
    ZYDIS_MNEMONIC_ORPS,
    ZYDIS_MNEMONIC_OUT,
    ZYDIS_MNEMONIC_OUTSB,
    ZYDIS_MNEMONIC_OUTSD,
    ZYDIS_MNEMONIC_OUTSW,
    ZYDIS_MNEMONIC_PABSB,
    ZYDIS_MNEMONIC_PABSD,
    ZYDIS_MNEMONIC_PABSW,
    ZYDIS_MNEMONIC_PACKSSDW,
    ZYDIS_MNEMONIC_PACKSSWB,
    ZYDIS_MNEMONIC_PACKUSDW,
    ZYDIS_MNEMONIC_PACKUSWB,
    ZYDIS_MNEMONIC_PADDB,
    ZYDIS_MNEMONIC_PADDD,
    ZYDIS_MNEMONIC_PADDQ,
    ZYDIS_MNEMONIC_PADDSB,
    ZYDIS_MNEMONIC_PADDSW,
    ZYDIS_MNEMONIC_PADDUSB,
    ZYDIS_MNEMONIC_PADDUSW,
    ZYDIS_MNEMONIC_PADDW,
    ZYDIS_MNEMONIC_PALIGNR,
    ZYDIS_MNEMONIC_PAND,
    ZYDIS_MNEMONIC_PANDN,
    ZYDIS_MNEMONIC_PAUSE,
    ZYDIS_MNEMONIC_PAVGB,
    ZYDIS_MNEMONIC_PAVGUSB,
    ZYDIS_MNEMONIC_PAVGW,
    ZYDIS_MNEMONIC_PBLENDVB,
    ZYDIS_MNEMONIC_PBLENDW,
    ZYDIS_MNEMONIC_PCLMULQDQ,
    ZYDIS_MNEMONIC_PCMPEQB,
    ZYDIS_MNEMONIC_PCMPEQD,
    ZYDIS_MNEMONIC_PCMPEQQ,
    ZYDIS_MNEMONIC_PCMPEQW,
    ZYDIS_MNEMONIC_PCMPESTRI,
    ZYDIS_MNEMONIC_PCMPESTRM,
    ZYDIS_MNEMONIC_PCMPGTB,
    ZYDIS_MNEMONIC_PCMPGTD,
    ZYDIS_MNEMONIC_PCMPGTQ,
    ZYDIS_MNEMONIC_PCMPGTW,
    ZYDIS_MNEMONIC_PCMPISTRI,
    ZYDIS_MNEMONIC_PCMPISTRM,
    ZYDIS_MNEMONIC_PCONFIG,
    ZYDIS_MNEMONIC_PDEP,
    ZYDIS_MNEMONIC_PEXT,
    ZYDIS_MNEMONIC_PEXTRB,
    ZYDIS_MNEMONIC_PEXTRD,
    ZYDIS_MNEMONIC_PEXTRQ,
    ZYDIS_MNEMONIC_PEXTRW,
    ZYDIS_MNEMONIC_PF2ID,
    ZYDIS_MNEMONIC_PF2IW,
    ZYDIS_MNEMONIC_PFACC,
    ZYDIS_MNEMONIC_PFADD,
    ZYDIS_MNEMONIC_PFCMPEQ,
    ZYDIS_MNEMONIC_PFCMPGE,
    ZYDIS_MNEMONIC_PFCMPGT,
    ZYDIS_MNEMONIC_PFCPIT1,
    ZYDIS_MNEMONIC_PFMAX,
    ZYDIS_MNEMONIC_PFMIN,
    ZYDIS_MNEMONIC_PFMUL,
    ZYDIS_MNEMONIC_PFNACC,
    ZYDIS_MNEMONIC_PFPNACC,
    ZYDIS_MNEMONIC_PFRCP,
    ZYDIS_MNEMONIC_PFRCPIT2,
    ZYDIS_MNEMONIC_PFRSQIT1,
    ZYDIS_MNEMONIC_PFSQRT,
    ZYDIS_MNEMONIC_PFSUB,
    ZYDIS_MNEMONIC_PFSUBR,
    ZYDIS_MNEMONIC_PHADDD,
    ZYDIS_MNEMONIC_PHADDSW,
    ZYDIS_MNEMONIC_PHADDW,
    ZYDIS_MNEMONIC_PHMINPOSUW,
    ZYDIS_MNEMONIC_PHSUBD,
    ZYDIS_MNEMONIC_PHSUBSW,
    ZYDIS_MNEMONIC_PHSUBW,
    ZYDIS_MNEMONIC_PI2FD,
    ZYDIS_MNEMONIC_PI2FW,
    ZYDIS_MNEMONIC_PINSRB,
    ZYDIS_MNEMONIC_PINSRD,
    ZYDIS_MNEMONIC_PINSRQ,
    ZYDIS_MNEMONIC_PINSRW,
    ZYDIS_MNEMONIC_PMADDUBSW,
    ZYDIS_MNEMONIC_PMADDWD,
    ZYDIS_MNEMONIC_PMAXSB,
    ZYDIS_MNEMONIC_PMAXSD,
    ZYDIS_MNEMONIC_PMAXSW,
    ZYDIS_MNEMONIC_PMAXUB,
    ZYDIS_MNEMONIC_PMAXUD,
    ZYDIS_MNEMONIC_PMAXUW,
    ZYDIS_MNEMONIC_PMINSB,
    ZYDIS_MNEMONIC_PMINSD,
    ZYDIS_MNEMONIC_PMINSW,
    ZYDIS_MNEMONIC_PMINUB,
    ZYDIS_MNEMONIC_PMINUD,
    ZYDIS_MNEMONIC_PMINUW,
    ZYDIS_MNEMONIC_PMOVMSKB,
    ZYDIS_MNEMONIC_PMOVSXBD,
    ZYDIS_MNEMONIC_PMOVSXBQ,
    ZYDIS_MNEMONIC_PMOVSXBW,
    ZYDIS_MNEMONIC_PMOVSXDQ,
    ZYDIS_MNEMONIC_PMOVSXWD,
    ZYDIS_MNEMONIC_PMOVSXWQ,
    ZYDIS_MNEMONIC_PMOVZXBD,
    ZYDIS_MNEMONIC_PMOVZXBQ,
    ZYDIS_MNEMONIC_PMOVZXBW,
    ZYDIS_MNEMONIC_PMOVZXDQ,
    ZYDIS_MNEMONIC_PMOVZXWD,
    ZYDIS_MNEMONIC_PMOVZXWQ,
    ZYDIS_MNEMONIC_PMULDQ,
    ZYDIS_MNEMONIC_PMULHRSW,
    ZYDIS_MNEMONIC_PMULHRW,
    ZYDIS_MNEMONIC_PMULHUW,
    ZYDIS_MNEMONIC_PMULHW,
    ZYDIS_MNEMONIC_PMULLD,
    ZYDIS_MNEMONIC_PMULLW,
    ZYDIS_MNEMONIC_PMULUDQ,
    ZYDIS_MNEMONIC_POP,
    ZYDIS_MNEMONIC_POPA,
    ZYDIS_MNEMONIC_POPAD,
    ZYDIS_MNEMONIC_POPCNT,
    ZYDIS_MNEMONIC_POPF,
    ZYDIS_MNEMONIC_POPFD,
    ZYDIS_MNEMONIC_POPFQ,
    ZYDIS_MNEMONIC_POR,
    ZYDIS_MNEMONIC_PREFETCH,
    ZYDIS_MNEMONIC_PREFETCHNTA,
    ZYDIS_MNEMONIC_PREFETCHT0,
    ZYDIS_MNEMONIC_PREFETCHT1,
    ZYDIS_MNEMONIC_PREFETCHT2,
    ZYDIS_MNEMONIC_PREFETCHW,
    ZYDIS_MNEMONIC_PREFETCHWT1,
    ZYDIS_MNEMONIC_PSADBW,
    ZYDIS_MNEMONIC_PSHUFB,
    ZYDIS_MNEMONIC_PSHUFD,
    ZYDIS_MNEMONIC_PSHUFHW,
    ZYDIS_MNEMONIC_PSHUFLW,
    ZYDIS_MNEMONIC_PSHUFW,
    ZYDIS_MNEMONIC_PSIGNB,
    ZYDIS_MNEMONIC_PSIGND,
    ZYDIS_MNEMONIC_PSIGNW,
    ZYDIS_MNEMONIC_PSLLD,
    ZYDIS_MNEMONIC_PSLLDQ,
    ZYDIS_MNEMONIC_PSLLQ,
    ZYDIS_MNEMONIC_PSLLW,
    ZYDIS_MNEMONIC_PSRAD,
    ZYDIS_MNEMONIC_PSRAW,
    ZYDIS_MNEMONIC_PSRLD,
    ZYDIS_MNEMONIC_PSRLDQ,
    ZYDIS_MNEMONIC_PSRLQ,
    ZYDIS_MNEMONIC_PSRLW,
    ZYDIS_MNEMONIC_PSUBB,
    ZYDIS_MNEMONIC_PSUBD,
    ZYDIS_MNEMONIC_PSUBQ,
    ZYDIS_MNEMONIC_PSUBSB,
    ZYDIS_MNEMONIC_PSUBSW,
    ZYDIS_MNEMONIC_PSUBUSB,
    ZYDIS_MNEMONIC_PSUBUSW,
    ZYDIS_MNEMONIC_PSUBW,
    ZYDIS_MNEMONIC_PSWAPD,
    ZYDIS_MNEMONIC_PTEST,
    ZYDIS_MNEMONIC_PTWRITE,
    ZYDIS_MNEMONIC_PUNPCKHBW,
    ZYDIS_MNEMONIC_PUNPCKHDQ,
    ZYDIS_MNEMONIC_PUNPCKHQDQ,
    ZYDIS_MNEMONIC_PUNPCKHWD,
    ZYDIS_MNEMONIC_PUNPCKLBW,
    ZYDIS_MNEMONIC_PUNPCKLDQ,
    ZYDIS_MNEMONIC_PUNPCKLQDQ,
    ZYDIS_MNEMONIC_PUNPCKLWD,
    ZYDIS_MNEMONIC_PUSH,
    ZYDIS_MNEMONIC_PUSHA,
    ZYDIS_MNEMONIC_PUSHAD,
    ZYDIS_MNEMONIC_PUSHF,
    ZYDIS_MNEMONIC_PUSHFD,
    ZYDIS_MNEMONIC_PUSHFQ,
    ZYDIS_MNEMONIC_PXOR,
    ZYDIS_MNEMONIC_RCL,
    ZYDIS_MNEMONIC_RCPPS,
    ZYDIS_MNEMONIC_RCPSS,
    ZYDIS_MNEMONIC_RCR,
    ZYDIS_MNEMONIC_RDFSBASE,
    ZYDIS_MNEMONIC_RDGSBASE,
    ZYDIS_MNEMONIC_RDMSR,
    ZYDIS_MNEMONIC_RDPID,
    ZYDIS_MNEMONIC_RDPKRU,
    ZYDIS_MNEMONIC_RDPMC,
    ZYDIS_MNEMONIC_RDRAND,
    ZYDIS_MNEMONIC_RDSEED,
    ZYDIS_MNEMONIC_RDSSPD,
    ZYDIS_MNEMONIC_RDSSPQ,
    ZYDIS_MNEMONIC_RDTSC,
    ZYDIS_MNEMONIC_RDTSCP,
    ZYDIS_MNEMONIC_RET,
    ZYDIS_MNEMONIC_ROL,
    ZYDIS_MNEMONIC_ROR,
    ZYDIS_MNEMONIC_RORX,
    ZYDIS_MNEMONIC_ROUNDPD,
    ZYDIS_MNEMONIC_ROUNDPS,
    ZYDIS_MNEMONIC_ROUNDSD,
    ZYDIS_MNEMONIC_ROUNDSS,
    ZYDIS_MNEMONIC_RSM,
    ZYDIS_MNEMONIC_RSQRTPS,
    ZYDIS_MNEMONIC_RSQRTSS,
    ZYDIS_MNEMONIC_RSTORSSP,
    ZYDIS_MNEMONIC_SAHF,
    ZYDIS_MNEMONIC_SALC,
    ZYDIS_MNEMONIC_SAR,
    ZYDIS_MNEMONIC_SARX,
    ZYDIS_MNEMONIC_SAVESSP,
    ZYDIS_MNEMONIC_SBB,
    ZYDIS_MNEMONIC_SCASB,
    ZYDIS_MNEMONIC_SCASD,
    ZYDIS_MNEMONIC_SCASQ,
    ZYDIS_MNEMONIC_SCASW,
    ZYDIS_MNEMONIC_SETB,
    ZYDIS_MNEMONIC_SETBE,
    ZYDIS_MNEMONIC_SETL,
    ZYDIS_MNEMONIC_SETLE,
    ZYDIS_MNEMONIC_SETNB,
    ZYDIS_MNEMONIC_SETNBE,
    ZYDIS_MNEMONIC_SETNL,
    ZYDIS_MNEMONIC_SETNLE,
    ZYDIS_MNEMONIC_SETNO,
    ZYDIS_MNEMONIC_SETNP,
    ZYDIS_MNEMONIC_SETNS,
    ZYDIS_MNEMONIC_SETNZ,
    ZYDIS_MNEMONIC_SETO,
    ZYDIS_MNEMONIC_SETP,
    ZYDIS_MNEMONIC_SETS,
    ZYDIS_MNEMONIC_SETSSBSY,
    ZYDIS_MNEMONIC_SETZ,
    ZYDIS_MNEMONIC_SFENCE,
    ZYDIS_MNEMONIC_SGDT,
    ZYDIS_MNEMONIC_SHA1MSG1,
    ZYDIS_MNEMONIC_SHA1MSG2,
    ZYDIS_MNEMONIC_SHA1NEXTE,
    ZYDIS_MNEMONIC_SHA1RNDS4,
    ZYDIS_MNEMONIC_SHA256MSG1,
    ZYDIS_MNEMONIC_SHA256MSG2,
    ZYDIS_MNEMONIC_SHA256RNDS2,
    ZYDIS_MNEMONIC_SHL,
    ZYDIS_MNEMONIC_SHLD,
    ZYDIS_MNEMONIC_SHLX,
    ZYDIS_MNEMONIC_SHR,
    ZYDIS_MNEMONIC_SHRD,
    ZYDIS_MNEMONIC_SHRX,
    ZYDIS_MNEMONIC_SHUFPD,
    ZYDIS_MNEMONIC_SHUFPS,
    ZYDIS_MNEMONIC_SIDT,
    ZYDIS_MNEMONIC_SKINIT,
    ZYDIS_MNEMONIC_SLDT,
    ZYDIS_MNEMONIC_SLWPCB,
    ZYDIS_MNEMONIC_SMSW,
    ZYDIS_MNEMONIC_SPFLT,
    ZYDIS_MNEMONIC_SQRTPD,
    ZYDIS_MNEMONIC_SQRTPS,
    ZYDIS_MNEMONIC_SQRTSD,
    ZYDIS_MNEMONIC_SQRTSS,
    ZYDIS_MNEMONIC_STAC,
    ZYDIS_MNEMONIC_STC,
    ZYDIS_MNEMONIC_STD,
    ZYDIS_MNEMONIC_STGI,
    ZYDIS_MNEMONIC_STI,
    ZYDIS_MNEMONIC_STMXCSR,
    ZYDIS_MNEMONIC_STOSB,
    ZYDIS_MNEMONIC_STOSD,
    ZYDIS_MNEMONIC_STOSQ,
    ZYDIS_MNEMONIC_STOSW,
    ZYDIS_MNEMONIC_STR,
    ZYDIS_MNEMONIC_SUB,
    ZYDIS_MNEMONIC_SUBPD,
    ZYDIS_MNEMONIC_SUBPS,
    ZYDIS_MNEMONIC_SUBSD,
    ZYDIS_MNEMONIC_SUBSS,
    ZYDIS_MNEMONIC_SWAPGS,
    ZYDIS_MNEMONIC_SYSCALL,
    ZYDIS_MNEMONIC_SYSENTER,
    ZYDIS_MNEMONIC_SYSEXIT,
    ZYDIS_MNEMONIC_SYSRET,
    ZYDIS_MNEMONIC_T1MSKC,
    ZYDIS_MNEMONIC_TEST,
    ZYDIS_MNEMONIC_TZCNT,
    ZYDIS_MNEMONIC_TZCNTI,
    ZYDIS_MNEMONIC_TZMSK,
    ZYDIS_MNEMONIC_UCOMISD,
    ZYDIS_MNEMONIC_UCOMISS,
    ZYDIS_MNEMONIC_UD0,
    ZYDIS_MNEMONIC_UD1,
    ZYDIS_MNEMONIC_UD2,
    ZYDIS_MNEMONIC_UNPCKHPD,
    ZYDIS_MNEMONIC_UNPCKHPS,
    ZYDIS_MNEMONIC_UNPCKLPD,
    ZYDIS_MNEMONIC_UNPCKLPS,
    ZYDIS_MNEMONIC_V4FMADDPS,
    ZYDIS_MNEMONIC_V4FMADDSS,
    ZYDIS_MNEMONIC_V4FNMADDPS,
    ZYDIS_MNEMONIC_V4FNMADDSS,
    ZYDIS_MNEMONIC_VADDNPD,
    ZYDIS_MNEMONIC_VADDNPS,
    ZYDIS_MNEMONIC_VADDPD,
    ZYDIS_MNEMONIC_VADDPS,
    ZYDIS_MNEMONIC_VADDSD,
    ZYDIS_MNEMONIC_VADDSETSPS,
    ZYDIS_MNEMONIC_VADDSS,
    ZYDIS_MNEMONIC_VADDSUBPD,
    ZYDIS_MNEMONIC_VADDSUBPS,
    ZYDIS_MNEMONIC_VAESDEC,
    ZYDIS_MNEMONIC_VAESDECLAST,
    ZYDIS_MNEMONIC_VAESENC,
    ZYDIS_MNEMONIC_VAESENCLAST,
    ZYDIS_MNEMONIC_VAESIMC,
    ZYDIS_MNEMONIC_VAESKEYGENASSIST,
    ZYDIS_MNEMONIC_VALIGND,
    ZYDIS_MNEMONIC_VALIGNQ,
    ZYDIS_MNEMONIC_VANDNPD,
    ZYDIS_MNEMONIC_VANDNPS,
    ZYDIS_MNEMONIC_VANDPD,
    ZYDIS_MNEMONIC_VANDPS,
    ZYDIS_MNEMONIC_VBLENDMPD,
    ZYDIS_MNEMONIC_VBLENDMPS,
    ZYDIS_MNEMONIC_VBLENDPD,
    ZYDIS_MNEMONIC_VBLENDPS,
    ZYDIS_MNEMONIC_VBLENDVPD,
    ZYDIS_MNEMONIC_VBLENDVPS,
    ZYDIS_MNEMONIC_VBROADCASTF128,
    ZYDIS_MNEMONIC_VBROADCASTF32X2,
    ZYDIS_MNEMONIC_VBROADCASTF32X4,
    ZYDIS_MNEMONIC_VBROADCASTF32X8,
    ZYDIS_MNEMONIC_VBROADCASTF64X2,
    ZYDIS_MNEMONIC_VBROADCASTF64X4,
    ZYDIS_MNEMONIC_VBROADCASTI128,
    ZYDIS_MNEMONIC_VBROADCASTI32X2,
    ZYDIS_MNEMONIC_VBROADCASTI32X4,
    ZYDIS_MNEMONIC_VBROADCASTI32X8,
    ZYDIS_MNEMONIC_VBROADCASTI64X2,
    ZYDIS_MNEMONIC_VBROADCASTI64X4,
    ZYDIS_MNEMONIC_VBROADCASTSD,
    ZYDIS_MNEMONIC_VBROADCASTSS,
    ZYDIS_MNEMONIC_VCMPPD,
    ZYDIS_MNEMONIC_VCMPPS,
    ZYDIS_MNEMONIC_VCMPSD,
    ZYDIS_MNEMONIC_VCMPSS,
    ZYDIS_MNEMONIC_VCOMISD,
    ZYDIS_MNEMONIC_VCOMISS,
    ZYDIS_MNEMONIC_VCOMPRESSPD,
    ZYDIS_MNEMONIC_VCOMPRESSPS,
    ZYDIS_MNEMONIC_VCVTDQ2PD,
    ZYDIS_MNEMONIC_VCVTDQ2PS,
    ZYDIS_MNEMONIC_VCVTFXPNTDQ2PS,
    ZYDIS_MNEMONIC_VCVTFXPNTPD2DQ,
    ZYDIS_MNEMONIC_VCVTFXPNTPD2UDQ,
    ZYDIS_MNEMONIC_VCVTFXPNTPS2DQ,
    ZYDIS_MNEMONIC_VCVTFXPNTPS2UDQ,
    ZYDIS_MNEMONIC_VCVTFXPNTUDQ2PS,
    ZYDIS_MNEMONIC_VCVTPD2DQ,
    ZYDIS_MNEMONIC_VCVTPD2PS,
    ZYDIS_MNEMONIC_VCVTPD2QQ,
    ZYDIS_MNEMONIC_VCVTPD2UDQ,
    ZYDIS_MNEMONIC_VCVTPD2UQQ,
    ZYDIS_MNEMONIC_VCVTPH2PS,
    ZYDIS_MNEMONIC_VCVTPS2DQ,
    ZYDIS_MNEMONIC_VCVTPS2PD,
    ZYDIS_MNEMONIC_VCVTPS2PH,
    ZYDIS_MNEMONIC_VCVTPS2QQ,
    ZYDIS_MNEMONIC_VCVTPS2UDQ,
    ZYDIS_MNEMONIC_VCVTPS2UQQ,
    ZYDIS_MNEMONIC_VCVTQQ2PD,
    ZYDIS_MNEMONIC_VCVTQQ2PS,
    ZYDIS_MNEMONIC_VCVTSD2SI,
    ZYDIS_MNEMONIC_VCVTSD2SS,
    ZYDIS_MNEMONIC_VCVTSD2USI,
    ZYDIS_MNEMONIC_VCVTSI2SD,
    ZYDIS_MNEMONIC_VCVTSI2SS,
    ZYDIS_MNEMONIC_VCVTSS2SD,
    ZYDIS_MNEMONIC_VCVTSS2SI,
    ZYDIS_MNEMONIC_VCVTSS2USI,
    ZYDIS_MNEMONIC_VCVTTPD2DQ,
    ZYDIS_MNEMONIC_VCVTTPD2QQ,
    ZYDIS_MNEMONIC_VCVTTPD2UDQ,
    ZYDIS_MNEMONIC_VCVTTPD2UQQ,
    ZYDIS_MNEMONIC_VCVTTPS2DQ,
    ZYDIS_MNEMONIC_VCVTTPS2QQ,
    ZYDIS_MNEMONIC_VCVTTPS2UDQ,
    ZYDIS_MNEMONIC_VCVTTPS2UQQ,
    ZYDIS_MNEMONIC_VCVTTSD2SI,
    ZYDIS_MNEMONIC_VCVTTSD2USI,
    ZYDIS_MNEMONIC_VCVTTSS2SI,
    ZYDIS_MNEMONIC_VCVTTSS2USI,
    ZYDIS_MNEMONIC_VCVTUDQ2PD,
    ZYDIS_MNEMONIC_VCVTUDQ2PS,
    ZYDIS_MNEMONIC_VCVTUQQ2PD,
    ZYDIS_MNEMONIC_VCVTUQQ2PS,
    ZYDIS_MNEMONIC_VCVTUSI2SD,
    ZYDIS_MNEMONIC_VCVTUSI2SS,
    ZYDIS_MNEMONIC_VDBPSADBW,
    ZYDIS_MNEMONIC_VDIVPD,
    ZYDIS_MNEMONIC_VDIVPS,
    ZYDIS_MNEMONIC_VDIVSD,
    ZYDIS_MNEMONIC_VDIVSS,
    ZYDIS_MNEMONIC_VDPPD,
    ZYDIS_MNEMONIC_VDPPS,
    ZYDIS_MNEMONIC_VERR,
    ZYDIS_MNEMONIC_VERW,
    ZYDIS_MNEMONIC_VEXP223PS,
    ZYDIS_MNEMONIC_VEXP2PD,
    ZYDIS_MNEMONIC_VEXP2PS,
    ZYDIS_MNEMONIC_VEXPANDPD,
    ZYDIS_MNEMONIC_VEXPANDPS,
    ZYDIS_MNEMONIC_VEXTRACTF128,
    ZYDIS_MNEMONIC_VEXTRACTF32X4,
    ZYDIS_MNEMONIC_VEXTRACTF32X8,
    ZYDIS_MNEMONIC_VEXTRACTF64X2,
    ZYDIS_MNEMONIC_VEXTRACTF64X4,
    ZYDIS_MNEMONIC_VEXTRACTI128,
    ZYDIS_MNEMONIC_VEXTRACTI32X4,
    ZYDIS_MNEMONIC_VEXTRACTI32X8,
    ZYDIS_MNEMONIC_VEXTRACTI64X2,
    ZYDIS_MNEMONIC_VEXTRACTI64X4,
    ZYDIS_MNEMONIC_VEXTRACTPS,
    ZYDIS_MNEMONIC_VFIXUPIMMPD,
    ZYDIS_MNEMONIC_VFIXUPIMMPS,
    ZYDIS_MNEMONIC_VFIXUPIMMSD,
    ZYDIS_MNEMONIC_VFIXUPIMMSS,
    ZYDIS_MNEMONIC_VFIXUPNANPD,
    ZYDIS_MNEMONIC_VFIXUPNANPS,
    ZYDIS_MNEMONIC_VFMADD132PD,
    ZYDIS_MNEMONIC_VFMADD132PS,
    ZYDIS_MNEMONIC_VFMADD132SD,
    ZYDIS_MNEMONIC_VFMADD132SS,
    ZYDIS_MNEMONIC_VFMADD213PD,
    ZYDIS_MNEMONIC_VFMADD213PS,
    ZYDIS_MNEMONIC_VFMADD213SD,
    ZYDIS_MNEMONIC_VFMADD213SS,
    ZYDIS_MNEMONIC_VFMADD231PD,
    ZYDIS_MNEMONIC_VFMADD231PS,
    ZYDIS_MNEMONIC_VFMADD231SD,
    ZYDIS_MNEMONIC_VFMADD231SS,
    ZYDIS_MNEMONIC_VFMADD233PS,
    ZYDIS_MNEMONIC_VFMADDPD,
    ZYDIS_MNEMONIC_VFMADDPS,
    ZYDIS_MNEMONIC_VFMADDSD,
    ZYDIS_MNEMONIC_VFMADDSS,
    ZYDIS_MNEMONIC_VFMADDSUB132PD,
    ZYDIS_MNEMONIC_VFMADDSUB132PS,
    ZYDIS_MNEMONIC_VFMADDSUB213PD,
    ZYDIS_MNEMONIC_VFMADDSUB213PS,
    ZYDIS_MNEMONIC_VFMADDSUB231PD,
    ZYDIS_MNEMONIC_VFMADDSUB231PS,
    ZYDIS_MNEMONIC_VFMADDSUBPD,
    ZYDIS_MNEMONIC_VFMADDSUBPS,
    ZYDIS_MNEMONIC_VFMSUB132PD,
    ZYDIS_MNEMONIC_VFMSUB132PS,
    ZYDIS_MNEMONIC_VFMSUB132SD,
    ZYDIS_MNEMONIC_VFMSUB132SS,
    ZYDIS_MNEMONIC_VFMSUB213PD,
    ZYDIS_MNEMONIC_VFMSUB213PS,
    ZYDIS_MNEMONIC_VFMSUB213SD,
    ZYDIS_MNEMONIC_VFMSUB213SS,
    ZYDIS_MNEMONIC_VFMSUB231PD,
    ZYDIS_MNEMONIC_VFMSUB231PS,
    ZYDIS_MNEMONIC_VFMSUB231SD,
    ZYDIS_MNEMONIC_VFMSUB231SS,
    ZYDIS_MNEMONIC_VFMSUBADD132PD,
    ZYDIS_MNEMONIC_VFMSUBADD132PS,
    ZYDIS_MNEMONIC_VFMSUBADD213PD,
    ZYDIS_MNEMONIC_VFMSUBADD213PS,
    ZYDIS_MNEMONIC_VFMSUBADD231PD,
    ZYDIS_MNEMONIC_VFMSUBADD231PS,
    ZYDIS_MNEMONIC_VFMSUBADDPD,
    ZYDIS_MNEMONIC_VFMSUBADDPS,
    ZYDIS_MNEMONIC_VFMSUBPD,
    ZYDIS_MNEMONIC_VFMSUBPS,
    ZYDIS_MNEMONIC_VFMSUBSD,
    ZYDIS_MNEMONIC_VFMSUBSS,
    ZYDIS_MNEMONIC_VFNMADD132PD,
    ZYDIS_MNEMONIC_VFNMADD132PS,
    ZYDIS_MNEMONIC_VFNMADD132SD,
    ZYDIS_MNEMONIC_VFNMADD132SS,
    ZYDIS_MNEMONIC_VFNMADD213PD,
    ZYDIS_MNEMONIC_VFNMADD213PS,
    ZYDIS_MNEMONIC_VFNMADD213SD,
    ZYDIS_MNEMONIC_VFNMADD213SS,
    ZYDIS_MNEMONIC_VFNMADD231PD,
    ZYDIS_MNEMONIC_VFNMADD231PS,
    ZYDIS_MNEMONIC_VFNMADD231SD,
    ZYDIS_MNEMONIC_VFNMADD231SS,
    ZYDIS_MNEMONIC_VFNMADDPD,
    ZYDIS_MNEMONIC_VFNMADDPS,
    ZYDIS_MNEMONIC_VFNMADDSD,
    ZYDIS_MNEMONIC_VFNMADDSS,
    ZYDIS_MNEMONIC_VFNMSUB132PD,
    ZYDIS_MNEMONIC_VFNMSUB132PS,
    ZYDIS_MNEMONIC_VFNMSUB132SD,
    ZYDIS_MNEMONIC_VFNMSUB132SS,
    ZYDIS_MNEMONIC_VFNMSUB213PD,
    ZYDIS_MNEMONIC_VFNMSUB213PS,
    ZYDIS_MNEMONIC_VFNMSUB213SD,
    ZYDIS_MNEMONIC_VFNMSUB213SS,
    ZYDIS_MNEMONIC_VFNMSUB231PD,
    ZYDIS_MNEMONIC_VFNMSUB231PS,
    ZYDIS_MNEMONIC_VFNMSUB231SD,
    ZYDIS_MNEMONIC_VFNMSUB231SS,
    ZYDIS_MNEMONIC_VFNMSUBPD,
    ZYDIS_MNEMONIC_VFNMSUBPS,
    ZYDIS_MNEMONIC_VFNMSUBSD,
    ZYDIS_MNEMONIC_VFNMSUBSS,
    ZYDIS_MNEMONIC_VFPCLASSPD,
    ZYDIS_MNEMONIC_VFPCLASSPS,
    ZYDIS_MNEMONIC_VFPCLASSSD,
    ZYDIS_MNEMONIC_VFPCLASSSS,
    ZYDIS_MNEMONIC_VFRCZPD,
    ZYDIS_MNEMONIC_VFRCZPS,
    ZYDIS_MNEMONIC_VFRCZSD,
    ZYDIS_MNEMONIC_VFRCZSS,
    ZYDIS_MNEMONIC_VGATHERDPD,
    ZYDIS_MNEMONIC_VGATHERDPS,
    ZYDIS_MNEMONIC_VGATHERPF0DPD,
    ZYDIS_MNEMONIC_VGATHERPF0DPS,
    ZYDIS_MNEMONIC_VGATHERPF0HINTDPD,
    ZYDIS_MNEMONIC_VGATHERPF0HINTDPS,
    ZYDIS_MNEMONIC_VGATHERPF0QPD,
    ZYDIS_MNEMONIC_VGATHERPF0QPS,
    ZYDIS_MNEMONIC_VGATHERPF1DPD,
    ZYDIS_MNEMONIC_VGATHERPF1DPS,
    ZYDIS_MNEMONIC_VGATHERPF1QPD,
    ZYDIS_MNEMONIC_VGATHERPF1QPS,
    ZYDIS_MNEMONIC_VGATHERQPD,
    ZYDIS_MNEMONIC_VGATHERQPS,
    ZYDIS_MNEMONIC_VGETEXPPD,
    ZYDIS_MNEMONIC_VGETEXPPS,
    ZYDIS_MNEMONIC_VGETEXPSD,
    ZYDIS_MNEMONIC_VGETEXPSS,
    ZYDIS_MNEMONIC_VGETMANTPD,
    ZYDIS_MNEMONIC_VGETMANTPS,
    ZYDIS_MNEMONIC_VGETMANTSD,
    ZYDIS_MNEMONIC_VGETMANTSS,
    ZYDIS_MNEMONIC_VGF2P8AFFINEINVQB,
    ZYDIS_MNEMONIC_VGF2P8AFFINEQB,
    ZYDIS_MNEMONIC_VGF2P8MULB,
    ZYDIS_MNEMONIC_VGMAXABSPS,
    ZYDIS_MNEMONIC_VGMAXPD,
    ZYDIS_MNEMONIC_VGMAXPS,
    ZYDIS_MNEMONIC_VGMINPD,
    ZYDIS_MNEMONIC_VGMINPS,
    ZYDIS_MNEMONIC_VHADDPD,
    ZYDIS_MNEMONIC_VHADDPS,
    ZYDIS_MNEMONIC_VHSUBPD,
    ZYDIS_MNEMONIC_VHSUBPS,
    ZYDIS_MNEMONIC_VINSERTF128,
    ZYDIS_MNEMONIC_VINSERTF32X4,
    ZYDIS_MNEMONIC_VINSERTF32X8,
    ZYDIS_MNEMONIC_VINSERTF64X2,
    ZYDIS_MNEMONIC_VINSERTF64X4,
    ZYDIS_MNEMONIC_VINSERTI128,
    ZYDIS_MNEMONIC_VINSERTI32X4,
    ZYDIS_MNEMONIC_VINSERTI32X8,
    ZYDIS_MNEMONIC_VINSERTI64X2,
    ZYDIS_MNEMONIC_VINSERTI64X4,
    ZYDIS_MNEMONIC_VINSERTPS,
    ZYDIS_MNEMONIC_VLDDQU,
    ZYDIS_MNEMONIC_VLDMXCSR,
    ZYDIS_MNEMONIC_VLOADUNPACKHD,
    ZYDIS_MNEMONIC_VLOADUNPACKHPD,
    ZYDIS_MNEMONIC_VLOADUNPACKHPS,
    ZYDIS_MNEMONIC_VLOADUNPACKHQ,
    ZYDIS_MNEMONIC_VLOADUNPACKLD,
    ZYDIS_MNEMONIC_VLOADUNPACKLPD,
    ZYDIS_MNEMONIC_VLOADUNPACKLPS,
    ZYDIS_MNEMONIC_VLOADUNPACKLQ,
    ZYDIS_MNEMONIC_VLOG2PS,
    ZYDIS_MNEMONIC_VMASKMOVDQU,
    ZYDIS_MNEMONIC_VMASKMOVPD,
    ZYDIS_MNEMONIC_VMASKMOVPS,
    ZYDIS_MNEMONIC_VMAXPD,
    ZYDIS_MNEMONIC_VMAXPS,
    ZYDIS_MNEMONIC_VMAXSD,
    ZYDIS_MNEMONIC_VMAXSS,
    ZYDIS_MNEMONIC_VMCALL,
    ZYDIS_MNEMONIC_VMCLEAR,
    ZYDIS_MNEMONIC_VMFUNC,
    ZYDIS_MNEMONIC_VMINPD,
    ZYDIS_MNEMONIC_VMINPS,
    ZYDIS_MNEMONIC_VMINSD,
    ZYDIS_MNEMONIC_VMINSS,
    ZYDIS_MNEMONIC_VMLAUNCH,
    ZYDIS_MNEMONIC_VMLOAD,
    ZYDIS_MNEMONIC_VMMCALL,
    ZYDIS_MNEMONIC_VMOVAPD,
    ZYDIS_MNEMONIC_VMOVAPS,
    ZYDIS_MNEMONIC_VMOVD,
    ZYDIS_MNEMONIC_VMOVDDUP,
    ZYDIS_MNEMONIC_VMOVDQA,
    ZYDIS_MNEMONIC_VMOVDQA32,
    ZYDIS_MNEMONIC_VMOVDQA64,
    ZYDIS_MNEMONIC_VMOVDQU,
    ZYDIS_MNEMONIC_VMOVDQU16,
    ZYDIS_MNEMONIC_VMOVDQU32,
    ZYDIS_MNEMONIC_VMOVDQU64,
    ZYDIS_MNEMONIC_VMOVDQU8,
    ZYDIS_MNEMONIC_VMOVHLPS,
    ZYDIS_MNEMONIC_VMOVHPD,
    ZYDIS_MNEMONIC_VMOVHPS,
    ZYDIS_MNEMONIC_VMOVLHPS,
    ZYDIS_MNEMONIC_VMOVLPD,
    ZYDIS_MNEMONIC_VMOVLPS,
    ZYDIS_MNEMONIC_VMOVMSKPD,
    ZYDIS_MNEMONIC_VMOVMSKPS,
    ZYDIS_MNEMONIC_VMOVNRAPD,
    ZYDIS_MNEMONIC_VMOVNRAPS,
    ZYDIS_MNEMONIC_VMOVNRNGOAPD,
    ZYDIS_MNEMONIC_VMOVNRNGOAPS,
    ZYDIS_MNEMONIC_VMOVNTDQ,
    ZYDIS_MNEMONIC_VMOVNTDQA,
    ZYDIS_MNEMONIC_VMOVNTPD,
    ZYDIS_MNEMONIC_VMOVNTPS,
    ZYDIS_MNEMONIC_VMOVQ,
    ZYDIS_MNEMONIC_VMOVSD,
    ZYDIS_MNEMONIC_VMOVSHDUP,
    ZYDIS_MNEMONIC_VMOVSLDUP,
    ZYDIS_MNEMONIC_VMOVSS,
    ZYDIS_MNEMONIC_VMOVUPD,
    ZYDIS_MNEMONIC_VMOVUPS,
    ZYDIS_MNEMONIC_VMPSADBW,
    ZYDIS_MNEMONIC_VMPTRLD,
    ZYDIS_MNEMONIC_VMPTRST,
    ZYDIS_MNEMONIC_VMREAD,
    ZYDIS_MNEMONIC_VMRESUME,
    ZYDIS_MNEMONIC_VMRUN,
    ZYDIS_MNEMONIC_VMSAVE,
    ZYDIS_MNEMONIC_VMULPD,
    ZYDIS_MNEMONIC_VMULPS,
    ZYDIS_MNEMONIC_VMULSD,
    ZYDIS_MNEMONIC_VMULSS,
    ZYDIS_MNEMONIC_VMWRITE,
    ZYDIS_MNEMONIC_VMXOFF,
    ZYDIS_MNEMONIC_VMXON,
    ZYDIS_MNEMONIC_VORPD,
    ZYDIS_MNEMONIC_VORPS,
    ZYDIS_MNEMONIC_VP4DPWSSD,
    ZYDIS_MNEMONIC_VP4DPWSSDS,
    ZYDIS_MNEMONIC_VPABSB,
    ZYDIS_MNEMONIC_VPABSD,
    ZYDIS_MNEMONIC_VPABSQ,
    ZYDIS_MNEMONIC_VPABSW,
    ZYDIS_MNEMONIC_VPACKSSDW,
    ZYDIS_MNEMONIC_VPACKSSWB,
    ZYDIS_MNEMONIC_VPACKSTOREHD,
    ZYDIS_MNEMONIC_VPACKSTOREHPD,
    ZYDIS_MNEMONIC_VPACKSTOREHPS,
    ZYDIS_MNEMONIC_VPACKSTOREHQ,
    ZYDIS_MNEMONIC_VPACKSTORELD,
    ZYDIS_MNEMONIC_VPACKSTORELPD,
    ZYDIS_MNEMONIC_VPACKSTORELPS,
    ZYDIS_MNEMONIC_VPACKSTORELQ,
    ZYDIS_MNEMONIC_VPACKUSDW,
    ZYDIS_MNEMONIC_VPACKUSWB,
    ZYDIS_MNEMONIC_VPADCD,
    ZYDIS_MNEMONIC_VPADDB,
    ZYDIS_MNEMONIC_VPADDD,
    ZYDIS_MNEMONIC_VPADDQ,
    ZYDIS_MNEMONIC_VPADDSB,
    ZYDIS_MNEMONIC_VPADDSETCD,
    ZYDIS_MNEMONIC_VPADDSETSD,
    ZYDIS_MNEMONIC_VPADDSW,
    ZYDIS_MNEMONIC_VPADDUSB,
    ZYDIS_MNEMONIC_VPADDUSW,
    ZYDIS_MNEMONIC_VPADDW,
    ZYDIS_MNEMONIC_VPALIGNR,
    ZYDIS_MNEMONIC_VPAND,
    ZYDIS_MNEMONIC_VPANDD,
    ZYDIS_MNEMONIC_VPANDN,
    ZYDIS_MNEMONIC_VPANDND,
    ZYDIS_MNEMONIC_VPANDNQ,
    ZYDIS_MNEMONIC_VPANDQ,
    ZYDIS_MNEMONIC_VPAVGB,
    ZYDIS_MNEMONIC_VPAVGW,
    ZYDIS_MNEMONIC_VPBLENDD,
    ZYDIS_MNEMONIC_VPBLENDMB,
    ZYDIS_MNEMONIC_VPBLENDMD,
    ZYDIS_MNEMONIC_VPBLENDMQ,
    ZYDIS_MNEMONIC_VPBLENDMW,
    ZYDIS_MNEMONIC_VPBLENDVB,
    ZYDIS_MNEMONIC_VPBLENDW,
    ZYDIS_MNEMONIC_VPBROADCASTB,
    ZYDIS_MNEMONIC_VPBROADCASTD,
    ZYDIS_MNEMONIC_VPBROADCASTMB2Q,
    ZYDIS_MNEMONIC_VPBROADCASTMW2D,
    ZYDIS_MNEMONIC_VPBROADCASTQ,
    ZYDIS_MNEMONIC_VPBROADCASTW,
    ZYDIS_MNEMONIC_VPCLMULQDQ,
    ZYDIS_MNEMONIC_VPCMOV,
    ZYDIS_MNEMONIC_VPCMPB,
    ZYDIS_MNEMONIC_VPCMPD,
    ZYDIS_MNEMONIC_VPCMPEQB,
    ZYDIS_MNEMONIC_VPCMPEQD,
    ZYDIS_MNEMONIC_VPCMPEQQ,
    ZYDIS_MNEMONIC_VPCMPEQW,
    ZYDIS_MNEMONIC_VPCMPESTRI,
    ZYDIS_MNEMONIC_VPCMPESTRM,
    ZYDIS_MNEMONIC_VPCMPGTB,
    ZYDIS_MNEMONIC_VPCMPGTD,
    ZYDIS_MNEMONIC_VPCMPGTQ,
    ZYDIS_MNEMONIC_VPCMPGTW,
    ZYDIS_MNEMONIC_VPCMPISTRI,
    ZYDIS_MNEMONIC_VPCMPISTRM,
    ZYDIS_MNEMONIC_VPCMPLTD,
    ZYDIS_MNEMONIC_VPCMPQ,
    ZYDIS_MNEMONIC_VPCMPUB,
    ZYDIS_MNEMONIC_VPCMPUD,
    ZYDIS_MNEMONIC_VPCMPUQ,
    ZYDIS_MNEMONIC_VPCMPUW,
    ZYDIS_MNEMONIC_VPCMPW,
    ZYDIS_MNEMONIC_VPCOMB,
    ZYDIS_MNEMONIC_VPCOMD,
    ZYDIS_MNEMONIC_VPCOMPRESSB,
    ZYDIS_MNEMONIC_VPCOMPRESSD,
    ZYDIS_MNEMONIC_VPCOMPRESSQ,
    ZYDIS_MNEMONIC_VPCOMPRESSW,
    ZYDIS_MNEMONIC_VPCOMQ,
    ZYDIS_MNEMONIC_VPCOMUB,
    ZYDIS_MNEMONIC_VPCOMUD,
    ZYDIS_MNEMONIC_VPCOMUQ,
    ZYDIS_MNEMONIC_VPCOMUW,
    ZYDIS_MNEMONIC_VPCOMW,
    ZYDIS_MNEMONIC_VPCONFLICTD,
    ZYDIS_MNEMONIC_VPCONFLICTQ,
    ZYDIS_MNEMONIC_VPDPBUSD,
    ZYDIS_MNEMONIC_VPDPBUSDS,
    ZYDIS_MNEMONIC_VPDPWSSD,
    ZYDIS_MNEMONIC_VPDPWSSDS,
    ZYDIS_MNEMONIC_VPERM2F128,
    ZYDIS_MNEMONIC_VPERM2I128,
    ZYDIS_MNEMONIC_VPERMB,
    ZYDIS_MNEMONIC_VPERMD,
    ZYDIS_MNEMONIC_VPERMF32X4,
    ZYDIS_MNEMONIC_VPERMI2B,
    ZYDIS_MNEMONIC_VPERMI2D,
    ZYDIS_MNEMONIC_VPERMI2PD,
    ZYDIS_MNEMONIC_VPERMI2PS,
    ZYDIS_MNEMONIC_VPERMI2Q,
    ZYDIS_MNEMONIC_VPERMI2W,
    ZYDIS_MNEMONIC_VPERMIL2PD,
    ZYDIS_MNEMONIC_VPERMIL2PS,
    ZYDIS_MNEMONIC_VPERMILPD,
    ZYDIS_MNEMONIC_VPERMILPS,
    ZYDIS_MNEMONIC_VPERMPD,
    ZYDIS_MNEMONIC_VPERMPS,
    ZYDIS_MNEMONIC_VPERMQ,
    ZYDIS_MNEMONIC_VPERMT2B,
    ZYDIS_MNEMONIC_VPERMT2D,
    ZYDIS_MNEMONIC_VPERMT2PD,
    ZYDIS_MNEMONIC_VPERMT2PS,
    ZYDIS_MNEMONIC_VPERMT2Q,
    ZYDIS_MNEMONIC_VPERMT2W,
    ZYDIS_MNEMONIC_VPERMW,
    ZYDIS_MNEMONIC_VPEXPANDB,
    ZYDIS_MNEMONIC_VPEXPANDD,
    ZYDIS_MNEMONIC_VPEXPANDQ,
    ZYDIS_MNEMONIC_VPEXPANDW,
    ZYDIS_MNEMONIC_VPEXTRB,
    ZYDIS_MNEMONIC_VPEXTRD,
    ZYDIS_MNEMONIC_VPEXTRQ,
    ZYDIS_MNEMONIC_VPEXTRW,
    ZYDIS_MNEMONIC_VPGATHERDD,
    ZYDIS_MNEMONIC_VPGATHERDQ,
    ZYDIS_MNEMONIC_VPGATHERQD,
    ZYDIS_MNEMONIC_VPGATHERQQ,
    ZYDIS_MNEMONIC_VPHADDBD,
    ZYDIS_MNEMONIC_VPHADDBQ,
    ZYDIS_MNEMONIC_VPHADDBW,
    ZYDIS_MNEMONIC_VPHADDD,
    ZYDIS_MNEMONIC_VPHADDDQ,
    ZYDIS_MNEMONIC_VPHADDSW,
    ZYDIS_MNEMONIC_VPHADDUBD,
    ZYDIS_MNEMONIC_VPHADDUBQ,
    ZYDIS_MNEMONIC_VPHADDUBW,
    ZYDIS_MNEMONIC_VPHADDUDQ,
    ZYDIS_MNEMONIC_VPHADDUWD,
    ZYDIS_MNEMONIC_VPHADDUWQ,
    ZYDIS_MNEMONIC_VPHADDW,
    ZYDIS_MNEMONIC_VPHADDWD,
    ZYDIS_MNEMONIC_VPHADDWQ,
    ZYDIS_MNEMONIC_VPHMINPOSUW,
    ZYDIS_MNEMONIC_VPHSUBBW,
    ZYDIS_MNEMONIC_VPHSUBD,
    ZYDIS_MNEMONIC_VPHSUBDQ,
    ZYDIS_MNEMONIC_VPHSUBSW,
    ZYDIS_MNEMONIC_VPHSUBW,
    ZYDIS_MNEMONIC_VPHSUBWD,
    ZYDIS_MNEMONIC_VPINSRB,
    ZYDIS_MNEMONIC_VPINSRD,
    ZYDIS_MNEMONIC_VPINSRQ,
    ZYDIS_MNEMONIC_VPINSRW,
    ZYDIS_MNEMONIC_VPLZCNTD,
    ZYDIS_MNEMONIC_VPLZCNTQ,
    ZYDIS_MNEMONIC_VPMACSDD,
    ZYDIS_MNEMONIC_VPMACSDQH,
    ZYDIS_MNEMONIC_VPMACSDQL,
    ZYDIS_MNEMONIC_VPMACSSDD,
    ZYDIS_MNEMONIC_VPMACSSDQH,
    ZYDIS_MNEMONIC_VPMACSSDQL,
    ZYDIS_MNEMONIC_VPMACSSWD,
    ZYDIS_MNEMONIC_VPMACSSWW,
    ZYDIS_MNEMONIC_VPMACSWD,
    ZYDIS_MNEMONIC_VPMACSWW,
    ZYDIS_MNEMONIC_VPMADCSSWD,
    ZYDIS_MNEMONIC_VPMADCSWD,
    ZYDIS_MNEMONIC_VPMADD231D,
    ZYDIS_MNEMONIC_VPMADD233D,
    ZYDIS_MNEMONIC_VPMADD52HUQ,
    ZYDIS_MNEMONIC_VPMADD52LUQ,
    ZYDIS_MNEMONIC_VPMADDUBSW,
    ZYDIS_MNEMONIC_VPMADDWD,
    ZYDIS_MNEMONIC_VPMASKMOVD,
    ZYDIS_MNEMONIC_VPMASKMOVQ,
    ZYDIS_MNEMONIC_VPMAXSB,
    ZYDIS_MNEMONIC_VPMAXSD,
    ZYDIS_MNEMONIC_VPMAXSQ,
    ZYDIS_MNEMONIC_VPMAXSW,
    ZYDIS_MNEMONIC_VPMAXUB,
    ZYDIS_MNEMONIC_VPMAXUD,
    ZYDIS_MNEMONIC_VPMAXUQ,
    ZYDIS_MNEMONIC_VPMAXUW,
    ZYDIS_MNEMONIC_VPMINSB,
    ZYDIS_MNEMONIC_VPMINSD,
    ZYDIS_MNEMONIC_VPMINSQ,
    ZYDIS_MNEMONIC_VPMINSW,
    ZYDIS_MNEMONIC_VPMINUB,
    ZYDIS_MNEMONIC_VPMINUD,
    ZYDIS_MNEMONIC_VPMINUQ,
    ZYDIS_MNEMONIC_VPMINUW,
    ZYDIS_MNEMONIC_VPMOVB2M,
    ZYDIS_MNEMONIC_VPMOVD2M,
    ZYDIS_MNEMONIC_VPMOVDB,
    ZYDIS_MNEMONIC_VPMOVDW,
    ZYDIS_MNEMONIC_VPMOVM2B,
    ZYDIS_MNEMONIC_VPMOVM2D,
    ZYDIS_MNEMONIC_VPMOVM2Q,
    ZYDIS_MNEMONIC_VPMOVM2W,
    ZYDIS_MNEMONIC_VPMOVMSKB,
    ZYDIS_MNEMONIC_VPMOVQ2M,
    ZYDIS_MNEMONIC_VPMOVQB,
    ZYDIS_MNEMONIC_VPMOVQD,
    ZYDIS_MNEMONIC_VPMOVQW,
    ZYDIS_MNEMONIC_VPMOVSDB,
    ZYDIS_MNEMONIC_VPMOVSDW,
    ZYDIS_MNEMONIC_VPMOVSQB,
    ZYDIS_MNEMONIC_VPMOVSQD,
    ZYDIS_MNEMONIC_VPMOVSQW,
    ZYDIS_MNEMONIC_VPMOVSWB,
    ZYDIS_MNEMONIC_VPMOVSXBD,
    ZYDIS_MNEMONIC_VPMOVSXBQ,
    ZYDIS_MNEMONIC_VPMOVSXBW,
    ZYDIS_MNEMONIC_VPMOVSXDQ,
    ZYDIS_MNEMONIC_VPMOVSXWD,
    ZYDIS_MNEMONIC_VPMOVSXWQ,
    ZYDIS_MNEMONIC_VPMOVUSDB,
    ZYDIS_MNEMONIC_VPMOVUSDW,
    ZYDIS_MNEMONIC_VPMOVUSQB,
    ZYDIS_MNEMONIC_VPMOVUSQD,
    ZYDIS_MNEMONIC_VPMOVUSQW,
    ZYDIS_MNEMONIC_VPMOVUSWB,
    ZYDIS_MNEMONIC_VPMOVW2M,
    ZYDIS_MNEMONIC_VPMOVWB,
    ZYDIS_MNEMONIC_VPMOVZXBD,
    ZYDIS_MNEMONIC_VPMOVZXBQ,
    ZYDIS_MNEMONIC_VPMOVZXBW,
    ZYDIS_MNEMONIC_VPMOVZXDQ,
    ZYDIS_MNEMONIC_VPMOVZXWD,
    ZYDIS_MNEMONIC_VPMOVZXWQ,
    ZYDIS_MNEMONIC_VPMULDQ,
    ZYDIS_MNEMONIC_VPMULHD,
    ZYDIS_MNEMONIC_VPMULHRSW,
    ZYDIS_MNEMONIC_VPMULHUD,
    ZYDIS_MNEMONIC_VPMULHUW,
    ZYDIS_MNEMONIC_VPMULHW,
    ZYDIS_MNEMONIC_VPMULLD,
    ZYDIS_MNEMONIC_VPMULLQ,
    ZYDIS_MNEMONIC_VPMULLW,
    ZYDIS_MNEMONIC_VPMULTISHIFTQB,
    ZYDIS_MNEMONIC_VPMULUDQ,
    ZYDIS_MNEMONIC_VPOPCNTB,
    ZYDIS_MNEMONIC_VPOPCNTD,
    ZYDIS_MNEMONIC_VPOPCNTQ,
    ZYDIS_MNEMONIC_VPOPCNTW,
    ZYDIS_MNEMONIC_VPOR,
    ZYDIS_MNEMONIC_VPORD,
    ZYDIS_MNEMONIC_VPORQ,
    ZYDIS_MNEMONIC_VPPERM,
    ZYDIS_MNEMONIC_VPREFETCH0,
    ZYDIS_MNEMONIC_VPREFETCH1,
    ZYDIS_MNEMONIC_VPREFETCH2,
    ZYDIS_MNEMONIC_VPREFETCHE0,
    ZYDIS_MNEMONIC_VPREFETCHE1,
    ZYDIS_MNEMONIC_VPREFETCHE2,
    ZYDIS_MNEMONIC_VPREFETCHENTA,
    ZYDIS_MNEMONIC_VPREFETCHNTA,
    ZYDIS_MNEMONIC_VPROLD,
    ZYDIS_MNEMONIC_VPROLQ,
    ZYDIS_MNEMONIC_VPROLVD,
    ZYDIS_MNEMONIC_VPROLVQ,
    ZYDIS_MNEMONIC_VPRORD,
    ZYDIS_MNEMONIC_VPRORQ,
    ZYDIS_MNEMONIC_VPRORVD,
    ZYDIS_MNEMONIC_VPRORVQ,
    ZYDIS_MNEMONIC_VPROTB,
    ZYDIS_MNEMONIC_VPROTD,
    ZYDIS_MNEMONIC_VPROTQ,
    ZYDIS_MNEMONIC_VPROTW,
    ZYDIS_MNEMONIC_VPSADBW,
    ZYDIS_MNEMONIC_VPSBBD,
    ZYDIS_MNEMONIC_VPSBBRD,
    ZYDIS_MNEMONIC_VPSCATTERDD,
    ZYDIS_MNEMONIC_VPSCATTERDQ,
    ZYDIS_MNEMONIC_VPSCATTERQD,
    ZYDIS_MNEMONIC_VPSCATTERQQ,
    ZYDIS_MNEMONIC_VPSHAB,
    ZYDIS_MNEMONIC_VPSHAD,
    ZYDIS_MNEMONIC_VPSHAQ,
    ZYDIS_MNEMONIC_VPSHAW,
    ZYDIS_MNEMONIC_VPSHLB,
    ZYDIS_MNEMONIC_VPSHLD,
    ZYDIS_MNEMONIC_VPSHLDD,
    ZYDIS_MNEMONIC_VPSHLDQ,
    ZYDIS_MNEMONIC_VPSHLDVD,
    ZYDIS_MNEMONIC_VPSHLDVQ,
    ZYDIS_MNEMONIC_VPSHLDVW,
    ZYDIS_MNEMONIC_VPSHLDW,
    ZYDIS_MNEMONIC_VPSHLQ,
    ZYDIS_MNEMONIC_VPSHLW,
    ZYDIS_MNEMONIC_VPSHRDD,
    ZYDIS_MNEMONIC_VPSHRDQ,
    ZYDIS_MNEMONIC_VPSHRDVD,
    ZYDIS_MNEMONIC_VPSHRDVQ,
    ZYDIS_MNEMONIC_VPSHRDVW,
    ZYDIS_MNEMONIC_VPSHRDW,
    ZYDIS_MNEMONIC_VPSHUFB,
    ZYDIS_MNEMONIC_VPSHUFBITQMB,
    ZYDIS_MNEMONIC_VPSHUFD,
    ZYDIS_MNEMONIC_VPSHUFHW,
    ZYDIS_MNEMONIC_VPSHUFLW,
    ZYDIS_MNEMONIC_VPSIGNB,
    ZYDIS_MNEMONIC_VPSIGND,
    ZYDIS_MNEMONIC_VPSIGNW,
    ZYDIS_MNEMONIC_VPSLLD,
    ZYDIS_MNEMONIC_VPSLLDQ,
    ZYDIS_MNEMONIC_VPSLLQ,
    ZYDIS_MNEMONIC_VPSLLVD,
    ZYDIS_MNEMONIC_VPSLLVQ,
    ZYDIS_MNEMONIC_VPSLLVW,
    ZYDIS_MNEMONIC_VPSLLW,
    ZYDIS_MNEMONIC_VPSRAD,
    ZYDIS_MNEMONIC_VPSRAQ,
    ZYDIS_MNEMONIC_VPSRAVD,
    ZYDIS_MNEMONIC_VPSRAVQ,
    ZYDIS_MNEMONIC_VPSRAVW,
    ZYDIS_MNEMONIC_VPSRAW,
    ZYDIS_MNEMONIC_VPSRLD,
    ZYDIS_MNEMONIC_VPSRLDQ,
    ZYDIS_MNEMONIC_VPSRLQ,
    ZYDIS_MNEMONIC_VPSRLVD,
    ZYDIS_MNEMONIC_VPSRLVQ,
    ZYDIS_MNEMONIC_VPSRLVW,
    ZYDIS_MNEMONIC_VPSRLW,
    ZYDIS_MNEMONIC_VPSUBB,
    ZYDIS_MNEMONIC_VPSUBD,
    ZYDIS_MNEMONIC_VPSUBQ,
    ZYDIS_MNEMONIC_VPSUBRD,
    ZYDIS_MNEMONIC_VPSUBRSETBD,
    ZYDIS_MNEMONIC_VPSUBSB,
    ZYDIS_MNEMONIC_VPSUBSETBD,
    ZYDIS_MNEMONIC_VPSUBSW,
    ZYDIS_MNEMONIC_VPSUBUSB,
    ZYDIS_MNEMONIC_VPSUBUSW,
    ZYDIS_MNEMONIC_VPSUBW,
    ZYDIS_MNEMONIC_VPTERNLOGD,
    ZYDIS_MNEMONIC_VPTERNLOGQ,
    ZYDIS_MNEMONIC_VPTEST,
    ZYDIS_MNEMONIC_VPTESTMB,
    ZYDIS_MNEMONIC_VPTESTMD,
    ZYDIS_MNEMONIC_VPTESTMQ,
    ZYDIS_MNEMONIC_VPTESTMW,
    ZYDIS_MNEMONIC_VPTESTNMB,
    ZYDIS_MNEMONIC_VPTESTNMD,
    ZYDIS_MNEMONIC_VPTESTNMQ,
    ZYDIS_MNEMONIC_VPTESTNMW,
    ZYDIS_MNEMONIC_VPUNPCKHBW,
    ZYDIS_MNEMONIC_VPUNPCKHDQ,
    ZYDIS_MNEMONIC_VPUNPCKHQDQ,
    ZYDIS_MNEMONIC_VPUNPCKHWD,
    ZYDIS_MNEMONIC_VPUNPCKLBW,
    ZYDIS_MNEMONIC_VPUNPCKLDQ,
    ZYDIS_MNEMONIC_VPUNPCKLQDQ,
    ZYDIS_MNEMONIC_VPUNPCKLWD,
    ZYDIS_MNEMONIC_VPXOR,
    ZYDIS_MNEMONIC_VPXORD,
    ZYDIS_MNEMONIC_VPXORQ,
    ZYDIS_MNEMONIC_VRANGEPD,
    ZYDIS_MNEMONIC_VRANGEPS,
    ZYDIS_MNEMONIC_VRANGESD,
    ZYDIS_MNEMONIC_VRANGESS,
    ZYDIS_MNEMONIC_VRCP14PD,
    ZYDIS_MNEMONIC_VRCP14PS,
    ZYDIS_MNEMONIC_VRCP14SD,
    ZYDIS_MNEMONIC_VRCP14SS,
    ZYDIS_MNEMONIC_VRCP23PS,
    ZYDIS_MNEMONIC_VRCP28PD,
    ZYDIS_MNEMONIC_VRCP28PS,
    ZYDIS_MNEMONIC_VRCP28SD,
    ZYDIS_MNEMONIC_VRCP28SS,
    ZYDIS_MNEMONIC_VRCPPS,
    ZYDIS_MNEMONIC_VRCPSS,
    ZYDIS_MNEMONIC_VREDUCEPD,
    ZYDIS_MNEMONIC_VREDUCEPS,
    ZYDIS_MNEMONIC_VREDUCESD,
    ZYDIS_MNEMONIC_VREDUCESS,
    ZYDIS_MNEMONIC_VRNDFXPNTPD,
    ZYDIS_MNEMONIC_VRNDFXPNTPS,
    ZYDIS_MNEMONIC_VRNDSCALEPD,
    ZYDIS_MNEMONIC_VRNDSCALEPS,
    ZYDIS_MNEMONIC_VRNDSCALESD,
    ZYDIS_MNEMONIC_VRNDSCALESS,
    ZYDIS_MNEMONIC_VROUNDPD,
    ZYDIS_MNEMONIC_VROUNDPS,
    ZYDIS_MNEMONIC_VROUNDSD,
    ZYDIS_MNEMONIC_VROUNDSS,
    ZYDIS_MNEMONIC_VRSQRT14PD,
    ZYDIS_MNEMONIC_VRSQRT14PS,
    ZYDIS_MNEMONIC_VRSQRT14SD,
    ZYDIS_MNEMONIC_VRSQRT14SS,
    ZYDIS_MNEMONIC_VRSQRT23PS,
    ZYDIS_MNEMONIC_VRSQRT28PD,
    ZYDIS_MNEMONIC_VRSQRT28PS,
    ZYDIS_MNEMONIC_VRSQRT28SD,
    ZYDIS_MNEMONIC_VRSQRT28SS,
    ZYDIS_MNEMONIC_VRSQRTPS,
    ZYDIS_MNEMONIC_VRSQRTSS,
    ZYDIS_MNEMONIC_VSCALEFPD,
    ZYDIS_MNEMONIC_VSCALEFPS,
    ZYDIS_MNEMONIC_VSCALEFSD,
    ZYDIS_MNEMONIC_VSCALEFSS,
    ZYDIS_MNEMONIC_VSCALEPS,
    ZYDIS_MNEMONIC_VSCATTERDPD,
    ZYDIS_MNEMONIC_VSCATTERDPS,
    ZYDIS_MNEMONIC_VSCATTERPF0DPD,
    ZYDIS_MNEMONIC_VSCATTERPF0DPS,
    ZYDIS_MNEMONIC_VSCATTERPF0HINTDPD,
    ZYDIS_MNEMONIC_VSCATTERPF0HINTDPS,
    ZYDIS_MNEMONIC_VSCATTERPF0QPD,
    ZYDIS_MNEMONIC_VSCATTERPF0QPS,
    ZYDIS_MNEMONIC_VSCATTERPF1DPD,
    ZYDIS_MNEMONIC_VSCATTERPF1DPS,
    ZYDIS_MNEMONIC_VSCATTERPF1QPD,
    ZYDIS_MNEMONIC_VSCATTERPF1QPS,
    ZYDIS_MNEMONIC_VSCATTERQPD,
    ZYDIS_MNEMONIC_VSCATTERQPS,
    ZYDIS_MNEMONIC_VSHUFF32X4,
    ZYDIS_MNEMONIC_VSHUFF64X2,
    ZYDIS_MNEMONIC_VSHUFI32X4,
    ZYDIS_MNEMONIC_VSHUFI64X2,
    ZYDIS_MNEMONIC_VSHUFPD,
    ZYDIS_MNEMONIC_VSHUFPS,
    ZYDIS_MNEMONIC_VSQRTPD,
    ZYDIS_MNEMONIC_VSQRTPS,
    ZYDIS_MNEMONIC_VSQRTSD,
    ZYDIS_MNEMONIC_VSQRTSS,
    ZYDIS_MNEMONIC_VSTMXCSR,
    ZYDIS_MNEMONIC_VSUBPD,
    ZYDIS_MNEMONIC_VSUBPS,
    ZYDIS_MNEMONIC_VSUBRPD,
    ZYDIS_MNEMONIC_VSUBRPS,
    ZYDIS_MNEMONIC_VSUBSD,
    ZYDIS_MNEMONIC_VSUBSS,
    ZYDIS_MNEMONIC_VTESTPD,
    ZYDIS_MNEMONIC_VTESTPS,
    ZYDIS_MNEMONIC_VUCOMISD,
    ZYDIS_MNEMONIC_VUCOMISS,
    ZYDIS_MNEMONIC_VUNPCKHPD,
    ZYDIS_MNEMONIC_VUNPCKHPS,
    ZYDIS_MNEMONIC_VUNPCKLPD,
    ZYDIS_MNEMONIC_VUNPCKLPS,
    ZYDIS_MNEMONIC_VXORPD,
    ZYDIS_MNEMONIC_VXORPS,
    ZYDIS_MNEMONIC_VZEROALL,
    ZYDIS_MNEMONIC_VZEROUPPER,
    ZYDIS_MNEMONIC_WBINVD,
    ZYDIS_MNEMONIC_WRFSBASE,
    ZYDIS_MNEMONIC_WRGSBASE,
    ZYDIS_MNEMONIC_WRMSR,
    ZYDIS_MNEMONIC_WRPKRU,
    ZYDIS_MNEMONIC_WRSSD,
    ZYDIS_MNEMONIC_WRSSQ,
    ZYDIS_MNEMONIC_WRUSSD,
    ZYDIS_MNEMONIC_WRUSSQ,
    ZYDIS_MNEMONIC_XABORT,
    ZYDIS_MNEMONIC_XADD,
    ZYDIS_MNEMONIC_XBEGIN,
    ZYDIS_MNEMONIC_XCHG,
    ZYDIS_MNEMONIC_XEND,
    ZYDIS_MNEMONIC_XGETBV,
    ZYDIS_MNEMONIC_XLAT,
    ZYDIS_MNEMONIC_XOR,
    ZYDIS_MNEMONIC_XORPD,
    ZYDIS_MNEMONIC_XORPS,
    ZYDIS_MNEMONIC_XRSTOR,
    ZYDIS_MNEMONIC_XRSTOR64,
    ZYDIS_MNEMONIC_XRSTORS,
    ZYDIS_MNEMONIC_XRSTORS64,
    ZYDIS_MNEMONIC_XSAVE,
    ZYDIS_MNEMONIC_XSAVE64,
    ZYDIS_MNEMONIC_XSAVEC,
    ZYDIS_MNEMONIC_XSAVEC64,
    ZYDIS_MNEMONIC_XSAVEOPT,
    ZYDIS_MNEMONIC_XSAVEOPT64,
    ZYDIS_MNEMONIC_XSAVES,
    ZYDIS_MNEMONIC_XSAVES64,
    ZYDIS_MNEMONIC_XSETBV,
    ZYDIS_MNEMONIC_XTEST,
    ZYDIS_MNEMONIC_MAX_VALUE = ZYDIS_MNEMONIC_XTEST,
    ZYDIS_MNEMONIC_MIN_BITS  = 0x000B
};

```

`Avanguard/Zydis/Zydis/Internal/DecoderData.h`:

```h
/***************************************************************************************************

  Zyan Disassembler Library (Zydis)

  Original Author : Florian Bernd

 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.

***************************************************************************************************/

#ifndef ZYDIS_INTERNAL_DECODERDATA_H
#define ZYDIS_INTERNAL_DECODERDATA_H

#include <Zydis/Defines.h>
#include <Zydis/DecoderTypes.h>

#ifdef __cplusplus
extern "C" {
#endif

/* ============================================================================================== */
/* Enums and types                                                                                */
/* ============================================================================================== */

// MSVC does not like types other than (un-)signed int for bitfields
#ifdef ZYDIS_MSVC
#   pragma warning(push)
#   pragma warning(disable:4214)
#endif

#pragma pack(push, 1)

/* ---------------------------------------------------------------------------------------------- */
/* Decoder tree                                                                                   */
/* ---------------------------------------------------------------------------------------------- */

/**
 * @brief   Defines the @c ZydisDecoderTreeNodeType datatype.
 */                                 
typedef ZydisU8 ZydisDecoderTreeNodeType;

/**
 * @brief   Values that represent zydis decoder tree node types.
 */
enum ZydisDecoderTreeNodeTypes
{
    ZYDIS_NODETYPE_INVALID                  = 0x00,
    /**
     * @brief   Reference to an instruction-definition.
     */
    ZYDIS_NODETYPE_DEFINITION_MASK          = 0x80,
    /**
     * @brief   Reference to an XOP-map filter.
     */
    ZYDIS_NODETYPE_FILTER_XOP               = 0x01,
    /**
     * @brief   Reference to an VEX-map filter.
     */
    ZYDIS_NODETYPE_FILTER_VEX               = 0x02,
    /**
     * @brief   Reference to an EVEX/MVEX-map filter.
     */
    ZYDIS_NODETYPE_FILTER_EMVEX             = 0x03,
    /**
     * @brief   Reference to an opcode filter.
     */
    ZYDIS_NODETYPE_FILTER_OPCODE            = 0x04,
    /**
     * @brief   Reference to an instruction-mode filter.
     */
    ZYDIS_NODETYPE_FILTER_MODE              = 0x05,
    /**
     * @brief   Reference to an compacted instruction-mode filter.
     */
    ZYDIS_NODETYPE_FILTER_MODE_COMPACT      = 0x06,
    /**
     * @brief   Reference to a ModRM.mod filter.
     */
    ZYDIS_NODETYPE_FILTER_MODRM_MOD         = 0x07,
    /**
     * @brief   Reference to a compacted ModRM.mod filter.
     */
    ZYDIS_NODETYPE_FILTER_MODRM_MOD_COMPACT = 0x08,
    /**
     * @brief   Reference to a ModRM.reg filter.
     */                                                                                      
    ZYDIS_NODETYPE_FILTER_MODRM_REG         = 0x09,
    /**
     * @brief   Reference to a ModRM.rm filter.
     */
    ZYDIS_NODETYPE_FILTER_MODRM_RM          = 0x0A,
    /**
     * @brief   Reference to a mandatory-prefix filter.
     */
    ZYDIS_NODETYPE_FILTER_MANDATORY_PREFIX  = 0x0B,
    /**
     * @brief   Reference to an operand-size filter.
     */
    ZYDIS_NODETYPE_FILTER_OPERAND_SIZE      = 0x0C,
    /**
     * @brief   Reference to an address-size filter.
     */
    ZYDIS_NODETYPE_FILTER_ADDRESS_SIZE      = 0x0D,
    /**
     * @brief   Reference to a vector-length filter.
     */
    ZYDIS_NODETYPE_FILTER_VECTOR_LENGTH     = 0x0E,
    /**
     * @brief   Reference to an REX/VEX/EVEX.W filter.
     */
    ZYDIS_NODETYPE_FILTER_REX_W             = 0x0F,
    /**
     * @brief   Reference to an REX/VEX/EVEX.B filter.
     */
    ZYDIS_NODETYPE_FILTER_REX_B             = 0x10,
    /**
     * @brief   Reference to an EVEX.b filter.
     */
    ZYDIS_NODETYPE_FILTER_EVEX_B            = 0x11,
    /**
     * @brief   Reference to an MVEX.E filter.
     */
    ZYDIS_NODETYPE_FILTER_MVEX_E            = 0x12,
    /**
     * @brief   Reference to a AMD-mode filter.
     */
    ZYDIS_NODETYPE_FILTER_MODE_AMD          = 0x13,
    /**
     * @brief   Reference to a KNC-mode filter.
     */
    ZYDIS_NODETYPE_FILTER_MODE_KNC          = 0x14,
    /**
     * @brief   Reference to a MPX-mode filter.
     */
    ZYDIS_NODETYPE_FILTER_MODE_MPX          = 0x15,
    /**
     * @brief   Reference to a CET-mode filter.
     */
    ZYDIS_NODETYPE_FILTER_MODE_CET          = 0x16,
    /**
     * @brief   Reference to a LZCNT-mode filter.
     */
    ZYDIS_NODETYPE_FILTER_MODE_LZCNT        = 0x17,
    /**
     * @brief   Reference to a TZCNT-mode filter.
     */
    ZYDIS_NODETYPE_FILTER_MODE_TZCNT        = 0x18
};

/* ---------------------------------------------------------------------------------------------- */

/**
 * @brief   Defines the @c ZydisDecoderTreeNodeValue datatype.
 */
typedef ZydisU16 ZydisDecoderTreeNodeValue;

/* ---------------------------------------------------------------------------------------------- */

/**
 * @brief   Defines the @c ZydisDecoderTreeNode struct.
 */
typedef struct ZydisDecoderTreeNode_
{
    ZydisDecoderTreeNodeType type;
    ZydisDecoderTreeNodeValue value;
} ZydisDecoderTreeNode;

/* ---------------------------------------------------------------------------------------------- */

#pragma pack(pop)

#ifdef ZYDIS_MSVC
#   pragma warning(pop)
#endif

/* ---------------------------------------------------------------------------------------------- */
/* Physical instruction encoding info                                                             */
/* ---------------------------------------------------------------------------------------------- */

/**
 * @brief   Defines the @c ZydisInstructionEncodingFlags datatype.
 */
typedef ZydisU8 ZydisInstructionEncodingFlags;

/**
 * @brief   The instruction has an optional modrm byte.
 */
#define ZYDIS_INSTR_ENC_FLAG_HAS_MODRM      0x01

/**
 * @brief   The instruction has an optional displacement value.
 */
#define ZYDIS_INSTR_ENC_FLAG_HAS_DISP       0x02

/**
 * @brief   The instruction has an optional immediate value.
 */
#define ZYDIS_INSTR_ENC_FLAG_HAS_IMM0       0x04

/**
 * @brief   The instruction has a second optional immediate value.
 */
#define ZYDIS_INSTR_ENC_FLAG_HAS_IMM1       0x08

/**
 * @brief   The instruction ignores the value of `modrm.mod` and always assumes `modrm.mod == 3`
 *          ("reg, reg" - form).
 *          
 *          Instructions with this flag can't have a SIB byte or a displacement value.
 */
#define ZYDIS_INSTR_ENC_FLAG_FORCE_REG_FORM 0x10

/**
 * @brief   Defines the @c ZydisInstructionEncodingInfo struct.
 */
typedef struct ZydisInstructionEncodingInfo_
{
    /**
     * @brief   Contains flags with information about the physical instruction-encoding.  
     */
    ZydisInstructionEncodingFlags flags;
    /**
     * @brief   Displacement info.
     */
    struct
    {
        /**
         * @brief   The size of the displacement value.
         */
        ZydisU8 size[3];
    } disp;
    /**
     * @brief   Immediate info.
     */
    struct
    {
        /**
         * @brief   The size of the immediate value.
         */
        ZydisU8 size[3];
        /**
         * @brief   Signals, if the value is signed.
         */
        ZydisBool isSigned;
        /**
         * @brief   Signals, if the value is a relative offset.
         */
        ZydisBool isRelative;
    } imm[2];
} ZydisInstructionEncodingInfo;

/* ---------------------------------------------------------------------------------------------- */

/* ============================================================================================== */
/* Functions                                                                                      */
/* ============================================================================================== */

/* ---------------------------------------------------------------------------------------------- */
/* Decoder tree                                                                                   */
/* ---------------------------------------------------------------------------------------------- */

/**
 * @brief   Returns the root node of the instruction tree.
 *
 * @return  The root node of the instruction tree.
 */
ZYDIS_NO_EXPORT const ZydisDecoderTreeNode* ZydisDecoderTreeGetRootNode(void);

/**
 * @brief   Returns the child node of @c parent specified by @c index.
 *
 * @param   parent  The parent node.
 * @param   index   The index of the child node to retrieve.
 *                  
 * @return  The specified child node.
 */
ZYDIS_NO_EXPORT const ZydisDecoderTreeNode* ZydisDecoderTreeGetChildNode(
    const ZydisDecoderTreeNode* parent, ZydisU16 index);

/**
 * @brief   Returns information about optional instruction parts (like modrm, displacement or 
 *          immediates) for the instruction that is linked to the given @c node.
 *
 * @param   node    The instruction definition node.
 * @param   info    A pointer to the @c ZydisInstructionParts struct.        
 */
ZYDIS_NO_EXPORT void ZydisGetInstructionEncodingInfo(const ZydisDecoderTreeNode* node, 
    const ZydisInstructionEncodingInfo** info);

/* ---------------------------------------------------------------------------------------------- */

/* ============================================================================================== */

#ifdef __cplusplus
}
#endif

#endif /* ZYDIS_INTERNAL_DECODERDATA_H */

```

`Avanguard/Zydis/Zydis/Internal/LibC.h`:

```h
/***************************************************************************************************

  Zyan Disassembler Library (Zydis)

  Original Author : Joel Höner

 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.

***************************************************************************************************/

#ifndef ZYDIS_INTERNAL_LIBC_H
#define ZYDIS_INTERNAL_LIBC_H

#include <Zydis/Defines.h>

#ifndef ZYDIS_NO_LIBC

/* ============================================================================================== */
/* LibC is available                                                                              */
/* ============================================================================================== */

#   include <string.h>
#   define ZydisMemoryCopy memcpy
#   define ZydisMemorySet  memset
#   define ZydisStrLen     strlen

#else

/* ============================================================================================== */
/* No LibC available, use our own functions                                                       */
/* ============================================================================================== */

/*
 * These implementations are by no means optimized and will be outperformed by pretty much any
 * libc implementation out there. We do not aim towards providing competetive implementations here,
 * but towards providing a last resort fallback for environments without a working libc.
 */

ZYDIS_INLINE void* ZydisMemorySet(void* ptr, int value, ZydisUSize num)
{
    ZydisU8 c = value & 0xff;
    for (ZydisUSize i = 0; i < num; ++i) ((ZydisU8*)ptr)[i] = c;
    return ptr;
}

ZYDIS_INLINE void* ZydisMemoryCopy(void* dst, const void* src, ZydisUSize num)
{
    for (ZydisUSize i = 0; i < num; ++i)
    {
        ((ZydisU8*)dst)[i] = ((const ZydisU8*)src)[i];
    }
    return dst;
}

ZYDIS_INLINE ZydisUSize ZydisStrLen(const char* str)
{
    const char *s;
    for (s = str; *s; ++s);
    return s - str;
}

/* ============================================================================================== */

#endif

#endif /* ZYDIS_INTERNAL_LIBC_H */

```

`Avanguard/Zydis/Zydis/Internal/SharedData.h`:

```h
/***************************************************************************************************

  Zyan Disassembler Library (Zydis)

  Original Author : Florian Bernd

 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.

***************************************************************************************************/

#ifndef ZYDIS_INTERNAL_SHAREDDATA_H
#define ZYDIS_INTERNAL_SHAREDDATA_H

#include <Zydis/Defines.h>
#include <Zydis/Mnemonic.h>
#include <Zydis/Register.h>
#include <Zydis/SharedTypes.h>
#include "Zydis/DecoderTypes.h"

#ifdef __cplusplus
extern "C" {
#endif

/* ============================================================================================== */
/* Enums and types                                                                                */
/* ============================================================================================== */

// MSVC does not like types other than (un-)signed int for bitfields
#ifdef ZYDIS_MSVC
#   pragma warning(push)
#   pragma warning(disable:4214)
#endif

#pragma pack(push, 1)

/* ---------------------------------------------------------------------------------------------- */
/* Operand definition                                                                             */
/* ---------------------------------------------------------------------------------------------- */

/**
 * @brief   Defines the @c ZydisSemanticOperandType datatype.
 */
typedef ZydisU8 ZydisSemanticOperandType;

/**
 * @brief   Values that represent semantic operand-types.
 */
enum ZydisSemanticOperandTypes
{
    ZYDIS_SEMANTIC_OPTYPE_UNUSED,
    ZYDIS_SEMANTIC_OPTYPE_IMPLICIT_REG,
    ZYDIS_SEMANTIC_OPTYPE_IMPLICIT_MEM,
    ZYDIS_SEMANTIC_OPTYPE_IMPLICIT_IMM1,
    ZYDIS_SEMANTIC_OPTYPE_GPR8,
    ZYDIS_SEMANTIC_OPTYPE_GPR16,
    ZYDIS_SEMANTIC_OPTYPE_GPR32,
    ZYDIS_SEMANTIC_OPTYPE_GPR64,
    ZYDIS_SEMANTIC_OPTYPE_GPR16_32_64, 
    ZYDIS_SEMANTIC_OPTYPE_GPR32_32_64,
    ZYDIS_SEMANTIC_OPTYPE_GPR16_32_32, 
    ZYDIS_SEMANTIC_OPTYPE_FPR,
    ZYDIS_SEMANTIC_OPTYPE_MMX,
    ZYDIS_SEMANTIC_OPTYPE_XMM,
    ZYDIS_SEMANTIC_OPTYPE_YMM,
    ZYDIS_SEMANTIC_OPTYPE_ZMM,
    ZYDIS_SEMANTIC_OPTYPE_BND,
    ZYDIS_SEMANTIC_OPTYPE_SREG,
    ZYDIS_SEMANTIC_OPTYPE_CR,
    ZYDIS_SEMANTIC_OPTYPE_DR,
    ZYDIS_SEMANTIC_OPTYPE_MASK,
    ZYDIS_SEMANTIC_OPTYPE_MEM,
    ZYDIS_SEMANTIC_OPTYPE_MEM_VSIBX,
    ZYDIS_SEMANTIC_OPTYPE_MEM_VSIBY,
    ZYDIS_SEMANTIC_OPTYPE_MEM_VSIBZ,
    ZYDIS_SEMANTIC_OPTYPE_IMM,
    ZYDIS_SEMANTIC_OPTYPE_REL,
    ZYDIS_SEMANTIC_OPTYPE_PTR,
    ZYDIS_SEMANTIC_OPTYPE_AGEN,
    ZYDIS_SEMANTIC_OPTYPE_MOFFS,
    ZYDIS_SEMANTIC_OPTYPE_MIB
};

/**
 * @brief   Defines the @c ZydisInternalElementType datatype.
 */
typedef ZydisU8 ZydisInternalElementType;

/**
 * @brief   Values that represent internal element-types.
 */
enum ZydisInternalElementTypes
{
    ZYDIS_IELEMENT_TYPE_INVALID,
    ZYDIS_IELEMENT_TYPE_VARIABLE,
    ZYDIS_IELEMENT_TYPE_STRUCT,
    ZYDIS_IELEMENT_TYPE_INT,
    ZYDIS_IELEMENT_TYPE_UINT,
    ZYDIS_IELEMENT_TYPE_INT1,
    ZYDIS_IELEMENT_TYPE_INT8,
    ZYDIS_IELEMENT_TYPE_INT16,
    ZYDIS_IELEMENT_TYPE_INT32,
    ZYDIS_IELEMENT_TYPE_INT64,
    ZYDIS_IELEMENT_TYPE_UINT8,
    ZYDIS_IELEMENT_TYPE_UINT16,
    ZYDIS_IELEMENT_TYPE_UINT32,
    ZYDIS_IELEMENT_TYPE_UINT64,
    ZYDIS_IELEMENT_TYPE_UINT128,
    ZYDIS_IELEMENT_TYPE_UINT256,
    ZYDIS_IELEMENT_TYPE_FLOAT16,
    ZYDIS_IELEMENT_TYPE_FLOAT32,
    ZYDIS_IELEMENT_TYPE_FLOAT64,
    ZYDIS_IELEMENT_TYPE_FLOAT80,
    ZYDIS_IELEMENT_TYPE_BCD80
};

/**
 * @brief   Defines the @c ZydisOperandDefinition struct.
 */
typedef struct ZydisOperandDefinition_
{
    ZydisSemanticOperandType type           ZYDIS_BITFIELD(5);
    ZydisOperandVisibility visibility       ZYDIS_BITFIELD(2);
    ZydisOperandAction action               ZYDIS_BITFIELD(3);
    ZydisU16 size[3];
    ZydisInternalElementType elementType    ZYDIS_BITFIELD(5);
    union
    {
        ZydisOperandEncoding encoding; 
        struct
        {
            ZydisU8 type                    ZYDIS_BITFIELD(3);
            union
            {
                ZydisRegister reg           ZYDIS_BITFIELD(ZYDIS_REGISTER_MIN_BITS);
                ZydisU8 id                  ZYDIS_BITFIELD(6);
            } reg;
        } reg;
        struct 
        {
            ZydisU8 seg                     ZYDIS_BITFIELD(3);
            ZydisU8 base                    ZYDIS_BITFIELD(3); 
        } mem;
    } op;
} ZydisOperandDefinition;

/**
 * @brief   Values that represent implicit-register types.
 */
enum ZydisImplicitRegisterType
{
    ZYDIS_IMPLREG_TYPE_STATIC,
    ZYDIS_IMPLREG_TYPE_GPR_OSZ,
    ZYDIS_IMPLREG_TYPE_GPR_ASZ,
    ZYDIS_IMPLREG_TYPE_GPR_SSZ,
    ZYDIS_IMPLREG_TYPE_IP_ASZ,
    ZYDIS_IMPLREG_TYPE_IP_SSZ,
    ZYDIS_IMPLREG_TYPE_FLAGS_SSZ
};

/**
 * @brief   Values that represent implicit-memory base-registers.
 */
enum ZydisImplicitMemBase
{
    ZYDIS_IMPLMEM_BASE_ABX,
    ZYDIS_IMPLMEM_BASE_ASP,
    ZYDIS_IMPLMEM_BASE_ABP,
    ZYDIS_IMPLMEM_BASE_ASI,
    ZYDIS_IMPLMEM_BASE_ADI    
};

/* ---------------------------------------------------------------------------------------------- */
/* Instruction definition                                                                         */
/* ---------------------------------------------------------------------------------------------- */

/**
 * @brief   Defines the @c ZydisInternalVectorLength datatype.
 */
typedef ZydisU8 ZydisInternalVectorLength;

/**
 * @brief   Values that represent internal vector-lengths.
 */
enum ZydisInternalVectorLengths
{
    ZYDIS_IVECTOR_LENGTH_DEFAULT,
    ZYDIS_IVECTOR_LENGTH_FIXED_128,
    ZYDIS_IVECTOR_LENGTH_FIXED_256,
    ZYDIS_IVECTOR_LENGTH_FIXED_512
};

/* ---------------------------------------------------------------------------------------------- */

/**
 * @brief   Defines the @c ZydisInternalElementSize datatype.
 */
typedef ZydisU8 ZydisInternalElementSize;

/**
 * @brief   Values that represent internal element-sizes.
 */
enum ZydisInternalElementSizes
{
    ZYDIS_IELEMENT_SIZE_INVALID,
    ZYDIS_IELEMENT_SIZE_8,
    ZYDIS_IELEMENT_SIZE_16,
    ZYDIS_IELEMENT_SIZE_32,
    ZYDIS_IELEMENT_SIZE_64,
    ZYDIS_IELEMENT_SIZE_128
};

/* ---------------------------------------------------------------------------------------------- */

/**
 * @brief   Defines the @c ZydisEVEXFunctionality datatype.
 */
typedef ZydisU8 ZydisEVEXFunctionality;

/**
 * @brief   Values that represent EVEX-functionalities.
 */
enum ZydisEVEXFunctionalities
{
    ZYDIS_EVEX_FUNC_INVALID,
    /**
     * @brief   @c EVEX.b enables broadcast functionality.
     */
    ZYDIS_EVEX_FUNC_BC,
    /**
     * @brief   @c EVEX.b enables embedded-rounding functionality.
     */
    ZYDIS_EVEX_FUNC_RC,
    /**
     * @brief   @c EVEX.b enables sae functionality.
     */
    ZYDIS_EVEX_FUNC_SAE
};

/* ---------------------------------------------------------------------------------------------- */

/**
 * @brief   Defines the @c ZydisEVEXTupleType datatype.
 */
typedef ZydisU8 ZydisEVEXTupleType;

/**
 * @brief   Values that represent EVEX tuple-types.
 */
enum ZydisEVEXTupleTypes
{
    ZYDIS_TUPLETYPE_INVALID,
    /**
     * @brief   Full Vector
     */
    ZYDIS_TUPLETYPE_FV,
    /**
     * @brief   Half Vector
     */
    ZYDIS_TUPLETYPE_HV,
    /**
     * @brief   Full Vector Mem
     */
    ZYDIS_TUPLETYPE_FVM,
    /**
     * @brief   Tuple1 Scalar
     */
    ZYDIS_TUPLETYPE_T1S,
    /**
     * @brief   Tuple1 Fixed
     */
    ZYDIS_TUPLETYPE_T1F,
    /**
     * @brief   Tuple1 4x32
     */
    ZYDIS_TUPLETYPE_T1_4X,
    /**
     * @brief   Gather / Scatter
     */
    ZYDIS_TUPLETYPE_GSCAT,
    /**
     * @brief   Tuple2
     */
    ZYDIS_TUPLETYPE_T2,
    /**
     * @brief   Tuple4
     */
    ZYDIS_TUPLETYPE_T4,
    /**
     * @brief   Tuple8
     */
    ZYDIS_TUPLETYPE_T8,
    /**
     * @brief   Half Mem
     */
    ZYDIS_TUPLETYPE_HVM,
    /**
     * @brief   QuarterMem
     */
    ZYDIS_TUPLETYPE_QVM,
    /**
     * @brief   OctMem
     */
    ZYDIS_TUPLETYPE_OVM,
    /**
     * @brief   Mem128
     */
    ZYDIS_TUPLETYPE_M128,
    /**
     * @brief   MOVDDUP
     */
    ZYDIS_TUPLETYPE_DUP
};

/* ---------------------------------------------------------------------------------------------- */

/**
 * @brief   Defines the @c ZydisMVEXFunctionality datatype.
 */
typedef ZydisU8 ZydisMVEXFunctionality;

/**
 * @brief   Values that represent MVEX-functionalities.
 */
enum ZydisMVEXFunctionalities
{
    /**
     * @brief   @c The MVEX.SSS value is ignored.
     */
    ZYDIS_MVEX_FUNC_IGNORED,
    /**
     * @brief   @c MVEX.SSS must be 000b.
     */
    ZYDIS_MVEX_FUNC_INVALID,
    /**
     * @brief   @c MVEX.SSS controls embedded-rounding functionality.
     */
    ZYDIS_MVEX_FUNC_RC,
    /**
     * @brief   @c MVEX.SSS controls sae functionality.
     */
    ZYDIS_MVEX_FUNC_SAE,
    /**
     * @brief   No special operation (32bit float elements).
     */
    ZYDIS_MVEX_FUNC_F_32,
    /**
     * @brief   No special operation (32bit uint elements).
     */
    ZYDIS_MVEX_FUNC_I_32,
    /**
     * @brief   No special operation (64bit float elements).
     */
    ZYDIS_MVEX_FUNC_F_64,
    /**
     * @brief   No special operation (64bit uint elements).
     */
    ZYDIS_MVEX_FUNC_I_64,
    /**
     * @brief   Sf32(reg) or Si32(reg).
     */
    ZYDIS_MVEX_FUNC_SWIZZLE_32,
    /**
     * @brief   Sf64(reg) or Si64(reg).
     */
    ZYDIS_MVEX_FUNC_SWIZZLE_64,
    /**
     * @brief   Sf32(mem).
     */
    ZYDIS_MVEX_FUNC_SF_32,
    /**
     * @brief   Sf32(mem) broadcast only.
     */
    ZYDIS_MVEX_FUNC_SF_32_BCST,
    /**
     * @brief   Sf32(mem) broadcast 4to16 only.
     */
    ZYDIS_MVEX_FUNC_SF_32_BCST_4TO16,
    /**
     * @brief   Sf64(mem).
     */
    ZYDIS_MVEX_FUNC_SF_64,
    /**
     * @brief   Si32(mem).
     */
    ZYDIS_MVEX_FUNC_SI_32,
    /**
     * @brief   Si32(mem) broadcast only.
     */
    ZYDIS_MVEX_FUNC_SI_32_BCST,
    /**
     * @brief   Si32(mem) broadcast 4to16 only.
     */
    ZYDIS_MVEX_FUNC_SI_32_BCST_4TO16,
    /**
     * @brief   Si64(mem).
     */
    ZYDIS_MVEX_FUNC_SI_64,
    /**
     * @brief   Uf32.
     */
    ZYDIS_MVEX_FUNC_UF_32,
    /**
     * @brief   Uf64.
     */
    ZYDIS_MVEX_FUNC_UF_64,
    /**
     * @brief   Ui32.
     */
    ZYDIS_MVEX_FUNC_UI_32,
    /**
     * @brief   Ui64.
     */
    ZYDIS_MVEX_FUNC_UI_64,
    /**
     * @brief   Df32.
     */
    ZYDIS_MVEX_FUNC_DF_32,
    /**
     * @brief   Df64.
     */
    ZYDIS_MVEX_FUNC_DF_64,
    /**
     * @brief   Di32.
     */
    ZYDIS_MVEX_FUNC_DI_32,
    /**
     * @brief   Di64.
     */
    ZYDIS_MVEX_FUNC_DI_64
};

/* ---------------------------------------------------------------------------------------------- */

/**
 * @brief   Defines the @c ZydisVEXStaticBroadcast datatype.
 */
typedef ZydisU8 ZydisVEXStaticBroadcast;

/**
 * @brief   Values that represent static VEX-broadcasts.
 */
enum ZydisVEXStaticBroadcasts
{
    ZYDIS_VEX_STATIC_BROADCAST_NONE,
    ZYDIS_VEX_STATIC_BROADCAST_1_TO_2,
    ZYDIS_VEX_STATIC_BROADCAST_1_TO_4,
    ZYDIS_VEX_STATIC_BROADCAST_1_TO_8,  
    ZYDIS_VEX_STATIC_BROADCAST_1_TO_16,
    ZYDIS_VEX_STATIC_BROADCAST_1_TO_32,
    ZYDIS_VEX_STATIC_BROADCAST_2_TO_4   
};

/* ---------------------------------------------------------------------------------------------- */

/**
 * @brief   Defines the @c ZydisEVEXStaticBroadcast datatype.
 */
typedef ZydisU8 ZydisEVEXStaticBroadcast;

/**
 * @brief   Values that represent static EVEX-broadcasts.
 */
enum ZydisEVEXStaticBroadcasts
{
    ZYDIS_EVEX_STATIC_BROADCAST_NONE,
    ZYDIS_EVEX_STATIC_BROADCAST_1_TO_2,
    ZYDIS_EVEX_STATIC_BROADCAST_1_TO_4,
    ZYDIS_EVEX_STATIC_BROADCAST_1_TO_8,
    ZYDIS_EVEX_STATIC_BROADCAST_1_TO_16,
    ZYDIS_EVEX_STATIC_BROADCAST_1_TO_32,
    ZYDIS_EVEX_STATIC_BROADCAST_1_TO_64,
    ZYDIS_EVEX_STATIC_BROADCAST_2_TO_4,
    ZYDIS_EVEX_STATIC_BROADCAST_2_TO_8,
    ZYDIS_EVEX_STATIC_BROADCAST_2_TO_16,
    ZYDIS_EVEX_STATIC_BROADCAST_4_TO_8,
    ZYDIS_EVEX_STATIC_BROADCAST_4_TO_16,
    ZYDIS_EVEX_STATIC_BROADCAST_8_TO_16   
};

/* ---------------------------------------------------------------------------------------------- */

/**
 * @brief   Defines the @c ZydisMVEXStaticBroadcast datatype.
 */
typedef ZydisU8 ZydisMVEXStaticBroadcast;

/**
 * @brief   Values that represent static MVEX-broadcasts.
 */
enum ZydisMVEXStaticBroadcasts
{
    ZYDIS_MVEX_STATIC_BROADCAST_NONE,
    ZYDIS_MVEX_STATIC_BROADCAST_1_TO_8,
    ZYDIS_MVEX_STATIC_BROADCAST_1_TO_16,
    ZYDIS_MVEX_STATIC_BROADCAST_4_TO_8,
    ZYDIS_MVEX_STATIC_BROADCAST_4_TO_16
};

/* ---------------------------------------------------------------------------------------------- */

/**
 * @brief   Defines the @c ZydisMaskPolicy datatype.
 */
typedef ZydisU8 ZydisMaskPolicy;

/**
 * @brief   Values that represent AVX mask policies.
 */
enum ZydisMaskPolicies
{
    ZYDIS_MASK_POLICY_INVALID,
    /**
     * @brief   The instruction accepts mask-registers other than the default-mask (K0), but
     *          does not require them.
     */
    ZYDIS_MASK_POLICY_ALLOWED,
    /**
     * @brief   The instruction requires a mask-register other than the default-mask (K0).
     */
    ZYDIS_MASK_POLICY_REQUIRED,
    /**
     * @brief   The instruction does not allow a mask-register other than the default-mask (K0).
     */
    ZYDIS_MASK_POLICY_FORBIDDEN
};

/* ---------------------------------------------------------------------------------------------- */

#define ZYDIS_INSTRUCTION_DEFINITION_BASE \
    ZydisMnemonic mnemonic                  ZYDIS_BITFIELD(ZYDIS_MNEMONIC_MIN_BITS); \
    ZydisU8 operandCount                    ZYDIS_BITFIELD( 4); \
    ZydisU16 operandReference               ZYDIS_BITFIELD(15); \
    ZydisU8 operandSizeMap                  ZYDIS_BITFIELD( 3); \
    ZydisU8 flagsReference                  ZYDIS_BITFIELD( 7); \
    ZydisBool requiresProtectedMode         ZYDIS_BITFIELD( 1); \
    ZydisBool acceptsAddressSizeOverride    ZYDIS_BITFIELD( 1); \
    ZydisInstructionCategory category       ZYDIS_BITFIELD(ZYDIS_CATEGORY_MIN_BITS); \
    ZydisISASet isaSet                      ZYDIS_BITFIELD(ZYDIS_ISA_SET_MIN_BITS); \
    ZydisISAExt isaExt                      ZYDIS_BITFIELD(ZYDIS_ISA_EXT_MIN_BITS); \
    ZydisExceptionClass exceptionClass      ZYDIS_BITFIELD( 6)

#define ZYDIS_INSTRUCTION_DEFINITION_BASE_VECTOR \
    ZYDIS_INSTRUCTION_DEFINITION_BASE; \
    ZydisBool hasNDSNDDOperand              ZYDIS_BITFIELD( 1)

#define ZYDIS_INSTRUCTION_DEFINITION_BASE_VECTOR_EX \
    ZYDIS_INSTRUCTION_DEFINITION_BASE_VECTOR; \
    ZydisBool hasVSIB                       ZYDIS_BITFIELD( 1)

/**
 * @brief   Defines the @c ZydisInstructionDefinition struct.
 */
typedef struct ZydisInstructionDefinition_
{
    ZYDIS_INSTRUCTION_DEFINITION_BASE;
} ZydisInstructionDefinition;

typedef struct ZydisInstructionDefinitionDEFAULT_
{
    ZYDIS_INSTRUCTION_DEFINITION_BASE;
    ZydisBool isPrivileged                  ZYDIS_BITFIELD( 1);
    ZydisBool isFarBranch                   ZYDIS_BITFIELD( 1);
    ZydisBool acceptsLock                   ZYDIS_BITFIELD( 1);
    ZydisBool acceptsREP                    ZYDIS_BITFIELD( 1);
    ZydisBool acceptsREPEREPZ               ZYDIS_BITFIELD( 1);
    ZydisBool acceptsREPNEREPNZ             ZYDIS_BITFIELD( 1);
    ZydisBool acceptsBOUND                  ZYDIS_BITFIELD( 1);
    ZydisBool acceptsXACQUIRE               ZYDIS_BITFIELD( 1);
    ZydisBool acceptsXRELEASE               ZYDIS_BITFIELD( 1);
    ZydisBool acceptsHLEWithoutLock         ZYDIS_BITFIELD( 1);
    ZydisBool acceptsBranchHints            ZYDIS_BITFIELD( 1);
    ZydisBool acceptsSegment                ZYDIS_BITFIELD( 1);
} ZydisInstructionDefinitionDEFAULT;

typedef struct ZydisInstructionDefinition3DNOW_
{
    ZYDIS_INSTRUCTION_DEFINITION_BASE;
} ZydisInstructionDefinition3DNOW;

typedef struct ZydisInstructionDefinitionXOP_
{
    ZYDIS_INSTRUCTION_DEFINITION_BASE_VECTOR;
} ZydisInstructionDefinitionXOP;

typedef struct ZydisInstructionDefinitionVEX_
{
    ZYDIS_INSTRUCTION_DEFINITION_BASE_VECTOR;
    ZydisVEXStaticBroadcast broadcast       ZYDIS_BITFIELD( 3);
} ZydisInstructionDefinitionVEX;

#ifndef ZYDIS_DISABLE_EVEX
typedef struct ZydisInstructionDefinitionEVEX_
{
    ZYDIS_INSTRUCTION_DEFINITION_BASE_VECTOR_EX;
    ZydisInternalVectorLength vectorLength  ZYDIS_BITFIELD( 2);
    ZydisEVEXTupleType tupleType            ZYDIS_BITFIELD( 4);
    ZydisInternalElementSize elementSize    ZYDIS_BITFIELD( 3);
    ZydisEVEXFunctionality functionality    ZYDIS_BITFIELD( 2);
    ZydisMaskPolicy maskPolicy              ZYDIS_BITFIELD( 2);
    ZydisBool acceptsZeroMask               ZYDIS_BITFIELD( 1);
    ZydisBool isControlMask                 ZYDIS_BITFIELD( 1);
    ZydisEVEXStaticBroadcast broadcast      ZYDIS_BITFIELD( 4);
} ZydisInstructionDefinitionEVEX;
#endif

#ifndef ZYDIS_DISABLE_MVEX
typedef struct ZydisInstructionDefinitionMVEX_
{
    ZYDIS_INSTRUCTION_DEFINITION_BASE_VECTOR_EX;
    ZydisMVEXFunctionality functionality    ZYDIS_BITFIELD( 5);
    ZydisMaskPolicy maskPolicy              ZYDIS_BITFIELD( 2);
    ZydisBool hasElementGranularity         ZYDIS_BITFIELD( 1);
    ZydisMVEXStaticBroadcast broadcast      ZYDIS_BITFIELD( 3);
} ZydisInstructionDefinitionMVEX;
#endif

/* ---------------------------------------------------------------------------------------------- */
/* Accessed CPU flags                                                                             */
/* ---------------------------------------------------------------------------------------------- */

typedef struct ZydisAccessedFlags_
{
    ZydisCPUFlagAction action[ZYDIS_CPUFLAG_MAX_VALUE + 1];
} ZydisAccessedFlags;

/* ---------------------------------------------------------------------------------------------- */

#pragma pack(pop)

#ifdef ZYDIS_MSVC
#   pragma warning(pop)
#endif

/* ============================================================================================== */
/* Functions                                                                                      */
/* ============================================================================================== */

/* ---------------------------------------------------------------------------------------------- */
/* Instruction definition                                                                         */
/* ---------------------------------------------------------------------------------------------- */

/**
 * @brief   Returns the instruction-definition with the given `encoding` and `id`.
 *
 * @param   encoding    The instruction-encoding.
 * @param   id          The definition-id.
 * @param   definition  A pointer to the variable that receives a pointer to the instruction-
 *                      definition.
 */
ZYDIS_NO_EXPORT void ZydisGetInstructionDefinition(ZydisInstructionEncoding encoding,
    ZydisU16 id, const ZydisInstructionDefinition** definition);

/* ---------------------------------------------------------------------------------------------- */
/* Operand definition                                                                             */
/* ---------------------------------------------------------------------------------------------- */

/**
 * @brief   Returns the the operand-definitions for the given instruction-`definition`.
 *
 * @param   definition  A pointer to the instruction-definition.
 * @param   operand     A pointer to the variable that receives a pointer to the first operand-
 *                      definition of the instruction.
 *                          
 * @return  The number of operands for the given instruction-definition.
 */
ZYDIS_NO_EXPORT ZydisU8 ZydisGetOperandDefinitions(const ZydisInstructionDefinition* definition, 
    const ZydisOperandDefinition** operand);

/* ---------------------------------------------------------------------------------------------- */
/* Element info                                                                                   */
/* ---------------------------------------------------------------------------------------------- */

/**
 * @brief   Returns the actual type and size of an internal element-type.
 *
 * @param   element The internal element type.
 * @param   type    The actual element type.
 * @param   size    The element size.
 */
ZYDIS_NO_EXPORT void ZydisGetElementInfo(ZydisInternalElementType element, ZydisElementType* type,
    ZydisElementSize* size);

/* ---------------------------------------------------------------------------------------------- */
/* Accessed CPU flags                                                                             */
/* ---------------------------------------------------------------------------------------------- */

/**
 * @brief   Returns the the operand-definitions for the given instruction-`definition`.
 *
 * @param   definition  A pointer to the instruction-definition.
 * @param   flags       A pointer to the variable that receives the `ZydisAccessedFlags` struct.
 */
ZYDIS_NO_EXPORT void ZydisGetAccessedFlags(const ZydisInstructionDefinition* definition,
    const ZydisAccessedFlags** flags);

/* ---------------------------------------------------------------------------------------------- */

/* ============================================================================================== */

#ifdef __cplusplus
}
#endif

#endif /* ZYDIS_INTERNAL_SHAREDDATA_H */

```

`Avanguard/Zydis/Zydis/MetaInfo.h`:

```h
/***************************************************************************************************

  Zyan Disassembler Library (Zydis)

  Original Author : Florian Bernd

 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.

***************************************************************************************************/

/**
 * @file
 * @brief   
 */

#ifndef ZYDIS_METAINFO_H
#define ZYDIS_METAINFO_H

#include <Zydis/Defines.h>
#include <Zydis/CommonTypes.h>

#ifdef __cplusplus
extern "C" {
#endif

/* ============================================================================================== */
/* Enums and types                                                                                */
/* ============================================================================================== */

#include <Zydis/Generated/EnumInstructionCategory.h> 
#include <Zydis/Generated/EnumISASet.h>
#include <Zydis/Generated/EnumISAExt.h>

/* ============================================================================================== */
/* Exported functions                                                                             */
/* ============================================================================================== */

 /**
 * @brief   Returns the specified instruction category string.
 *          
 * @param   category    The instruction category.
 *                      
 * @return  The instruction category string or @c NULL, if an invalid category was passed.
 */
ZYDIS_EXPORT const char* ZydisCategoryGetString(ZydisInstructionCategory category);

/**
 * @brief   Returns the specified isa-set string.
 *          
 * @param   isaSet  The isa-set.
 *                      
 * @return  The isa-set string or @c NULL, if an invalid isa-set was passed.
 */
ZYDIS_EXPORT const char* ZydisISASetGetString(ZydisISASet isaSet);

/**
 * @brief   Returns the specified isa-extension string.
 *          
 * @param   isaExt  The isa-extension.
 *                      
 * @return  The isa-extension string or @c NULL, if an invalid isa-extension was passed.
 */
ZYDIS_EXPORT const char* ZydisISAExtGetString(ZydisISAExt isaExt);

/* ============================================================================================== */

#ifdef __cplusplus
}
#endif

#endif /* ZYDIS_METAINFO_H */

```

`Avanguard/Zydis/Zydis/Mnemonic.h`:

```h
/***************************************************************************************************

  Zyan Disassembler Library (Zydis)

  Original Author : Florian Bernd

 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.

***************************************************************************************************/

/**
 * @file
 * @brief   Mnemonic constant definitions and helper functions.
 */

#ifndef ZYDIS_MNEMONIC_H
#define ZYDIS_MNEMONIC_H

#include <Zydis/CommonTypes.h>
#include <Zydis/String.h>

#ifdef __cplusplus
extern "C" {
#endif

/* ============================================================================================== */
/* Enums and types                                                                                */
/* ============================================================================================== */

#include <Zydis/Generated/EnumMnemonic.h>    

/* ============================================================================================== */
/* Exported functions                                                                             */
/* ============================================================================================== */

/**
 * @brief   Returns the specified instruction mnemonic string.
 *          
 * @param   mnemonic    The mnemonic.
 *                      
 * @return  The instruction mnemonic string or @c NULL, if an invalid mnemonic was passed.
 */
ZYDIS_EXPORT const char* ZydisMnemonicGetString(ZydisMnemonic mnemonic);

/**
 * @brief   Returns the specified instruction mnemonic as `ZydisStaticString`.
 *          
 * @param   mnemonic    The mnemonic.
 *                      
 * @return  The instruction mnemonic string or @c NULL, if an invalid mnemonic was passed.
 * 
 * The `buffer` of the returned struct is guaranteed to be zero-terminated in this special case.
 */
ZYDIS_EXPORT const ZydisStaticString* ZydisMnemonicGetStaticString(ZydisMnemonic mnemonic);

/* ============================================================================================== */

#ifdef __cplusplus
}
#endif

#endif /* ZYDIS_MNEMONIC_H */

```

`Avanguard/Zydis/Zydis/Register.h`:

```h
/***************************************************************************************************

  Zyan Disassembler Library (Zydis)

  Original Author : Florian Bernd

 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.

***************************************************************************************************/

/**
 * @file
 * @brief   Utility functions and constants for registers.
 */

#ifndef ZYDIS_REGISTER_H
#define ZYDIS_REGISTER_H

#include <Zydis/Defines.h>
#include <Zydis/CommonTypes.h>
#include <Zydis/String.h>

#ifdef __cplusplus
extern "C" {
#endif

/* ============================================================================================== */
/* Enums and types                                                                                */
/* ============================================================================================== */

/* ---------------------------------------------------------------------------------------------- */
/* Registers                                                                                      */
/* ---------------------------------------------------------------------------------------------- */

/**
 * @brief   Defines the @c ZydisRegister datatype.
 */
typedef ZydisU8 ZydisRegister;

/**
 * @brief   Values that represent zydis registers.
 */
enum ZydisRegisters
{
    ZYDIS_REGISTER_NONE,

    // General purpose registers  8-bit
    ZYDIS_REGISTER_AL,     ZYDIS_REGISTER_CL,     ZYDIS_REGISTER_DL,    ZYDIS_REGISTER_BL,
    ZYDIS_REGISTER_AH,     ZYDIS_REGISTER_CH,     ZYDIS_REGISTER_DH,    ZYDIS_REGISTER_BH,  
    ZYDIS_REGISTER_SPL,    ZYDIS_REGISTER_BPL,    ZYDIS_REGISTER_SIL,   ZYDIS_REGISTER_DIL,
    ZYDIS_REGISTER_R8B,    ZYDIS_REGISTER_R9B,    ZYDIS_REGISTER_R10B,  ZYDIS_REGISTER_R11B,   
    ZYDIS_REGISTER_R12B,   ZYDIS_REGISTER_R13B,   ZYDIS_REGISTER_R14B,  ZYDIS_REGISTER_R15B,
    // General purpose registers 16-bit
    ZYDIS_REGISTER_AX,     ZYDIS_REGISTER_CX,     ZYDIS_REGISTER_DX,    ZYDIS_REGISTER_BX,     
    ZYDIS_REGISTER_SP,     ZYDIS_REGISTER_BP,     ZYDIS_REGISTER_SI,    ZYDIS_REGISTER_DI,
    ZYDIS_REGISTER_R8W,    ZYDIS_REGISTER_R9W,    ZYDIS_REGISTER_R10W,  ZYDIS_REGISTER_R11W,   
    ZYDIS_REGISTER_R12W,   ZYDIS_REGISTER_R13W,   ZYDIS_REGISTER_R14W,  ZYDIS_REGISTER_R15W,
    // General purpose registers 32-bit
    ZYDIS_REGISTER_EAX,    ZYDIS_REGISTER_ECX,    ZYDIS_REGISTER_EDX,   ZYDIS_REGISTER_EBX,    
    ZYDIS_REGISTER_ESP,    ZYDIS_REGISTER_EBP,    ZYDIS_REGISTER_ESI,   ZYDIS_REGISTER_EDI,
    ZYDIS_REGISTER_R8D,    ZYDIS_REGISTER_R9D,    ZYDIS_REGISTER_R10D,  ZYDIS_REGISTER_R11D,   
    ZYDIS_REGISTER_R12D,   ZYDIS_REGISTER_R13D,   ZYDIS_REGISTER_R14D,  ZYDIS_REGISTER_R15D,
    // General purpose registers 64-bit
    ZYDIS_REGISTER_RAX,    ZYDIS_REGISTER_RCX,    ZYDIS_REGISTER_RDX,   ZYDIS_REGISTER_RBX,    
    ZYDIS_REGISTER_RSP,    ZYDIS_REGISTER_RBP,    ZYDIS_REGISTER_RSI,   ZYDIS_REGISTER_RDI,
    ZYDIS_REGISTER_R8,     ZYDIS_REGISTER_R9,     ZYDIS_REGISTER_R10,   ZYDIS_REGISTER_R11,    
    ZYDIS_REGISTER_R12,    ZYDIS_REGISTER_R13,    ZYDIS_REGISTER_R14,   ZYDIS_REGISTER_R15,
    // Floating point legacy registers
    ZYDIS_REGISTER_ST0,    ZYDIS_REGISTER_ST1,    ZYDIS_REGISTER_ST2,   ZYDIS_REGISTER_ST3,    
    ZYDIS_REGISTER_ST4,    ZYDIS_REGISTER_ST5,    ZYDIS_REGISTER_ST6,   ZYDIS_REGISTER_ST7,
    // Floating point multimedia registers
    ZYDIS_REGISTER_MM0,    ZYDIS_REGISTER_MM1,    ZYDIS_REGISTER_MM2,   ZYDIS_REGISTER_MM3,    
    ZYDIS_REGISTER_MM4,    ZYDIS_REGISTER_MM5,    ZYDIS_REGISTER_MM6,   ZYDIS_REGISTER_MM7,
    // Floating point vector registers 128-bit
    ZYDIS_REGISTER_XMM0,   ZYDIS_REGISTER_XMM1,   ZYDIS_REGISTER_XMM2,  ZYDIS_REGISTER_XMM3,   
    ZYDIS_REGISTER_XMM4,   ZYDIS_REGISTER_XMM5,   ZYDIS_REGISTER_XMM6,  ZYDIS_REGISTER_XMM7,
    ZYDIS_REGISTER_XMM8,   ZYDIS_REGISTER_XMM9,   ZYDIS_REGISTER_XMM10, ZYDIS_REGISTER_XMM11,  
    ZYDIS_REGISTER_XMM12,  ZYDIS_REGISTER_XMM13,  ZYDIS_REGISTER_XMM14, ZYDIS_REGISTER_XMM15,
    ZYDIS_REGISTER_XMM16,  ZYDIS_REGISTER_XMM17,  ZYDIS_REGISTER_XMM18, ZYDIS_REGISTER_XMM19,  
    ZYDIS_REGISTER_XMM20,  ZYDIS_REGISTER_XMM21,  ZYDIS_REGISTER_XMM22, ZYDIS_REGISTER_XMM23,
    ZYDIS_REGISTER_XMM24,  ZYDIS_REGISTER_XMM25,  ZYDIS_REGISTER_XMM26, ZYDIS_REGISTER_XMM27,  
    ZYDIS_REGISTER_XMM28,  ZYDIS_REGISTER_XMM29,  ZYDIS_REGISTER_XMM30, ZYDIS_REGISTER_XMM31,
    // Floating point vector registers 256-bit
    ZYDIS_REGISTER_YMM0,   ZYDIS_REGISTER_YMM1,   ZYDIS_REGISTER_YMM2,  ZYDIS_REGISTER_YMM3,   
    ZYDIS_REGISTER_YMM4,   ZYDIS_REGISTER_YMM5,   ZYDIS_REGISTER_YMM6,  ZYDIS_REGISTER_YMM7,
    ZYDIS_REGISTER_YMM8,   ZYDIS_REGISTER_YMM9,   ZYDIS_REGISTER_YMM10, ZYDIS_REGISTER_YMM11,  
    ZYDIS_REGISTER_YMM12,  ZYDIS_REGISTER_YMM13,  ZYDIS_REGISTER_YMM14, ZYDIS_REGISTER_YMM15,
    ZYDIS_REGISTER_YMM16,  ZYDIS_REGISTER_YMM17,  ZYDIS_REGISTER_YMM18, ZYDIS_REGISTER_YMM19,  
    ZYDIS_REGISTER_YMM20,  ZYDIS_REGISTER_YMM21,  ZYDIS_REGISTER_YMM22, ZYDIS_REGISTER_YMM23,
    ZYDIS_REGISTER_YMM24,  ZYDIS_REGISTER_YMM25,  ZYDIS_REGISTER_YMM26, ZYDIS_REGISTER_YMM27,  
    ZYDIS_REGISTER_YMM28,  ZYDIS_REGISTER_YMM29,  ZYDIS_REGISTER_YMM30, ZYDIS_REGISTER_YMM31,
    // Floating point vector registers 512-bit
    ZYDIS_REGISTER_ZMM0,   ZYDIS_REGISTER_ZMM1,   ZYDIS_REGISTER_ZMM2,  ZYDIS_REGISTER_ZMM3,   
    ZYDIS_REGISTER_ZMM4,   ZYDIS_REGISTER_ZMM5,   ZYDIS_REGISTER_ZMM6,  ZYDIS_REGISTER_ZMM7,
    ZYDIS_REGISTER_ZMM8,   ZYDIS_REGISTER_ZMM9,   ZYDIS_REGISTER_ZMM10, ZYDIS_REGISTER_ZMM11,  
    ZYDIS_REGISTER_ZMM12,  ZYDIS_REGISTER_ZMM13,  ZYDIS_REGISTER_ZMM14, ZYDIS_REGISTER_ZMM15,
    ZYDIS_REGISTER_ZMM16,  ZYDIS_REGISTER_ZMM17,  ZYDIS_REGISTER_ZMM18, ZYDIS_REGISTER_ZMM19,  
    ZYDIS_REGISTER_ZMM20,  ZYDIS_REGISTER_ZMM21,  ZYDIS_REGISTER_ZMM22, ZYDIS_REGISTER_ZMM23,
    ZYDIS_REGISTER_ZMM24,  ZYDIS_REGISTER_ZMM25,  ZYDIS_REGISTER_ZMM26, ZYDIS_REGISTER_ZMM27,  
    ZYDIS_REGISTER_ZMM28,  ZYDIS_REGISTER_ZMM29,  ZYDIS_REGISTER_ZMM30, ZYDIS_REGISTER_ZMM31,
    // Flags registers
    ZYDIS_REGISTER_FLAGS,  ZYDIS_REGISTER_EFLAGS, ZYDIS_REGISTER_RFLAGS,
    // IP registers
    ZYDIS_REGISTER_IP,     ZYDIS_REGISTER_EIP,    ZYDIS_REGISTER_RIP,     
    // Segment registers
    ZYDIS_REGISTER_ES,     ZYDIS_REGISTER_CS,     ZYDIS_REGISTER_SS,    ZYDIS_REGISTER_DS,     
    ZYDIS_REGISTER_FS,     ZYDIS_REGISTER_GS,
    // Table registers
    ZYDIS_REGISTER_GDTR,   ZYDIS_REGISTER_LDTR,   ZYDIS_REGISTER_IDTR,  ZYDIS_REGISTER_TR,
    // Test registers
    ZYDIS_REGISTER_TR0,    ZYDIS_REGISTER_TR1,    ZYDIS_REGISTER_TR2,   ZYDIS_REGISTER_TR3,
    ZYDIS_REGISTER_TR4,    ZYDIS_REGISTER_TR5,    ZYDIS_REGISTER_TR6,   ZYDIS_REGISTER_TR7,
    // Control registers
    ZYDIS_REGISTER_CR0,    ZYDIS_REGISTER_CR1,    ZYDIS_REGISTER_CR2,   ZYDIS_REGISTER_CR3,    
    ZYDIS_REGISTER_CR4,    ZYDIS_REGISTER_CR5,    ZYDIS_REGISTER_CR6,   ZYDIS_REGISTER_CR7,
    ZYDIS_REGISTER_CR8,    ZYDIS_REGISTER_CR9,    ZYDIS_REGISTER_CR10,  ZYDIS_REGISTER_CR11,   
    ZYDIS_REGISTER_CR12,   ZYDIS_REGISTER_CR13,   ZYDIS_REGISTER_CR14,  ZYDIS_REGISTER_CR15,
    // Debug registers
    ZYDIS_REGISTER_DR0,    ZYDIS_REGISTER_DR1,    ZYDIS_REGISTER_DR2,   ZYDIS_REGISTER_DR3,    
    ZYDIS_REGISTER_DR4,    ZYDIS_REGISTER_DR5,    ZYDIS_REGISTER_DR6,   ZYDIS_REGISTER_DR7,
    ZYDIS_REGISTER_DR8,    ZYDIS_REGISTER_DR9,    ZYDIS_REGISTER_DR10,  ZYDIS_REGISTER_DR11,   
    ZYDIS_REGISTER_DR12,   ZYDIS_REGISTER_DR13,   ZYDIS_REGISTER_DR14,  ZYDIS_REGISTER_DR15,
    // Mask registers
    ZYDIS_REGISTER_K0,     ZYDIS_REGISTER_K1,     ZYDIS_REGISTER_K2,    ZYDIS_REGISTER_K3,     
    ZYDIS_REGISTER_K4,     ZYDIS_REGISTER_K5,     ZYDIS_REGISTER_K6,    ZYDIS_REGISTER_K7,
    // Bound registers
    ZYDIS_REGISTER_BND0,   ZYDIS_REGISTER_BND1,   ZYDIS_REGISTER_BND2,  ZYDIS_REGISTER_BND3,
    ZYDIS_REGISTER_BNDCFG, ZYDIS_REGISTER_BNDSTATUS,
    // Misc registers
    ZYDIS_REGISTER_MXCSR,  ZYDIS_REGISTER_PKRU,   ZYDIS_REGISTER_XCR0,

    /**
     * @brief   Maximum value of this enum.
     */
    ZYDIS_REGISTER_MAX_VALUE = ZYDIS_REGISTER_XCR0,
    /**
     * @brief   Minimum amount of bits required to store a value of this enum.
     */
    ZYDIS_REGISTER_MIN_BITS  = 0x0008
};

/* ---------------------------------------------------------------------------------------------- */
/* Register classes                                                                               */
/* ---------------------------------------------------------------------------------------------- */

/**
 * @brief   Defines the @c ZydisRegisterClass datatype.
 */
typedef ZydisU8 ZydisRegisterClass;

/**
 * @brief   Values that represent zydis register-classes.
 */
enum ZydisRegisterClasses
{
    ZYDIS_REGCLASS_INVALID,
    /**
     * @brief   8-bit general-purpose registers.
     */
    ZYDIS_REGCLASS_GPR8,
    /**
     * @brief   16-bit general-purpose registers.
     */
    ZYDIS_REGCLASS_GPR16,
    /**
     * @brief   32-bit general-purpose registers.
     */
    ZYDIS_REGCLASS_GPR32,
    /**
     * @brief   64-bit general-purpose registers.
     */
    ZYDIS_REGCLASS_GPR64,
    /**
     * @brief   Floating point legacy registers.
     */
    ZYDIS_REGCLASS_X87,
    /**
     * @brief   Floating point multimedia registers.
     */
    ZYDIS_REGCLASS_MMX,
    /**
     * @brief   128-bit vector registers.
     */
    ZYDIS_REGCLASS_XMM,
    /**
     * @brief   256-bit vector registers.
     */
    ZYDIS_REGCLASS_YMM,
    /**
     * @brief   512-bit vector registers.
     */
    ZYDIS_REGCLASS_ZMM,
    /**
     * @brief   Flags registers.
     */
    ZYDIS_REGCLASS_FLAGS,
    /**
     * @brief   Instruction-pointer registers.
     */
    ZYDIS_REGCLASS_IP,
    /**
     * @brief   Segment registers.
     */
    ZYDIS_REGCLASS_SEGMENT,
    /**
     * @brief   Test registers.
     */
    ZYDIS_REGCLASS_TEST,
    /**
     * @brief   Control registers.
     */
    ZYDIS_REGCLASS_CONTROL,
    /**
     * @brief   Debug registers.
     */
    ZYDIS_REGCLASS_DEBUG,
    /**
     * @brief   Mask registers.
     */
    ZYDIS_REGCLASS_MASK,
    /**
     * @brief   Bound registers.
     */
    ZYDIS_REGCLASS_BOUND,
    /**
     * @brief   Maximum value of this enum.
     */
    ZYDIS_REGCLASS_MAX_VALUE = ZYDIS_REGCLASS_BOUND
};

/* ---------------------------------------------------------------------------------------------- */
/* Register width                                                                                 */
/* ---------------------------------------------------------------------------------------------- */
    
/**
 * @brief   Defines the @c ZydisRegisterWidth datatype. 
 */
typedef ZydisU16 ZydisRegisterWidth;

/* ---------------------------------------------------------------------------------------------- */

/* ============================================================================================== */
/* Exported functions                                                                             */
/* ============================================================================================== */

/**
 * @brief   Returns the register specified by the @c registerClass and the @c id.
 *
 * @param   registerClass   The register class.
 * @param   id              The register id.
 *
 * @return  The register specified by the @c registerClass and the @c id or @c ZYDIS_REGISTER_NONE,
 *          if an invalid parameter was passed.
 */
ZYDIS_EXPORT ZydisRegister ZydisRegisterEncode(ZydisRegisterClass registerClass, ZydisU8 id);

/**
 * @brief   Returns the id of the specified register.
 *
 * @param   reg The register.
 *
 * @return  The id of the specified register, or -1 if an invalid parameter was passed.
 */
ZYDIS_EXPORT ZydisI16 ZydisRegisterGetId(ZydisRegister reg);

/**
 * @brief   Returns the register-class of the specified register.
 *
 * @param   reg The register.
 *
 * @return  The register-class of the specified register.
 */
ZYDIS_EXPORT ZydisRegisterClass ZydisRegisterGetClass(ZydisRegister reg);

/**
 * @brief   Returns the width of the specified register.
 *
 * @param   reg The register.
 *
 * @return  The width of the specified register.
 */
ZYDIS_EXPORT ZydisRegisterWidth ZydisRegisterGetWidth(ZydisRegister reg);

/**
 * @brief   Returns the width of the specified register in 64-bit mode.
 *
 * @param   reg The register.
 *
 * @return  The width of the specified register.
 */
ZYDIS_EXPORT ZydisRegisterWidth ZydisRegisterGetWidth64(ZydisRegister reg);

/**
 * @brief   Returns the specified register string.
 *
 * @param   reg The register.
 *
 * @return  The register string or @c NULL, if an invalid register was passed.
 */
ZYDIS_EXPORT const char* ZydisRegisterGetString(ZydisRegister reg);

/**
 * @brief   Returns the specified register string as `ZydisStaticString`.
 *
 * @param   reg The register.
 *
 * @return  The register string or @c NULL, if an invalid register was passed.
 * 
 * The `buffer` of the returned struct is guaranteed to be zero-terminated in this special case.
 */
ZYDIS_EXPORT const ZydisStaticString* ZydisRegisterGetStaticString(ZydisRegister reg);

/* ============================================================================================== */

#ifdef __cplusplus
}
#endif

#endif /* ZYDIS_REGISTER_H */

```

`Avanguard/Zydis/Zydis/SharedTypes.h`:

```h
/***************************************************************************************************

  Zyan Disassembler Library (Zydis)

  Original Author : Florian Bernd

 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.

***************************************************************************************************/

/**
 * @file
 * @brief   Defines decoder/encoder-shared macros and types.
 */

#ifndef ZYDIS_SHAREDTYPES_H
#define ZYDIS_SHAREDTYPES_H

#include <Zydis/CommonTypes.h>

#ifdef __cplusplus
extern "C" {
#endif

/* ============================================================================================== */
/* Macros                                                                                         */
/* ============================================================================================== */

/* ---------------------------------------------------------------------------------------------- */
/* Constants                                                                                      */
/* ---------------------------------------------------------------------------------------------- */

#define ZYDIS_MAX_INSTRUCTION_LENGTH 15
#define ZYDIS_MAX_OPERAND_COUNT      10

/* ---------------------------------------------------------------------------------------------- */

/* ============================================================================================== */
/* Enums and types                                                                                */
/* ============================================================================================== */

/* ---------------------------------------------------------------------------------------------- */
/* Machine mode                                                                                   */
/* ---------------------------------------------------------------------------------------------- */

/**
 * @brief   Defines the @c ZydisMachineMode datatype.
 */
typedef ZydisU8 ZydisMachineMode;

/**
 * @brief   Values that represent machine modes.
 */
enum ZydisMachineModes
{
    ZYDIS_MACHINE_MODE_INVALID,
    /**
     * @brief 64 bit mode.
     */
    ZYDIS_MACHINE_MODE_LONG_64,
    /**
     * @brief 32 bit protected mode.
     */
    ZYDIS_MACHINE_MODE_LONG_COMPAT_32,
    /**
     * @brief 16 bit protected mode.
     */
    ZYDIS_MACHINE_MODE_LONG_COMPAT_16,
    /**
     * @brief 32 bit protected mode.
     */
    ZYDIS_MACHINE_MODE_LEGACY_32,
    /**
     * @brief 16 bit protected mode.
     */
    ZYDIS_MACHINE_MODE_LEGACY_16,
    /**
     * @brief 16 bit real mode.
     */
    ZYDIS_MACHINE_MODE_REAL_16,
     /**
     * @brief   Maximum value of this enum.
     */
    ZYDIS_MACHINE_MODE_MAX_VALUE = ZYDIS_MACHINE_MODE_REAL_16
};

/* ---------------------------------------------------------------------------------------------- */
/* Address width                                                                                  */
/* ---------------------------------------------------------------------------------------------- */

/**
 * @brief   Defines the @c ZydisAddressWidth datatype.
 */
typedef ZydisU8 ZydisAddressWidth;

/**
 * @brief   Values that represent address widths.
 */
enum ZydisAddressWidths
{
    ZYDIS_ADDRESS_WIDTH_INVALID         =  0,
    ZYDIS_ADDRESS_WIDTH_16              = 16,
    ZYDIS_ADDRESS_WIDTH_32              = 32,
    ZYDIS_ADDRESS_WIDTH_64              = 64,
    ZYDIS_ADDRESS_WIDTH_MAX_VALUE       = ZYDIS_ADDRESS_WIDTH_64
};

/* ---------------------------------------------------------------------------------------------- */
/* Element types                                                                                  */
/* ---------------------------------------------------------------------------------------------- */

/**
 * @brief   Defines the @c ZydisElementType datatype.
 */
typedef ZydisU8 ZydisElementType;

/**
 * @brief   Values that represent element-types.
 */
enum ZydisElementTypes
{
    ZYDIS_ELEMENT_TYPE_INVALID,
    ZYDIS_ELEMENT_TYPE_STRUCT,
    ZYDIS_ELEMENT_TYPE_UINT,
    ZYDIS_ELEMENT_TYPE_INT,
    ZYDIS_ELEMENT_TYPE_FLOAT16,
    ZYDIS_ELEMENT_TYPE_FLOAT32,
    ZYDIS_ELEMENT_TYPE_FLOAT64,
    ZYDIS_ELEMENT_TYPE_FLOAT80,
    ZYDIS_ELEMENT_TYPE_LONGBCD,
    ZYDIS_ELEMENT_TYPE_MAX_VALUE = ZYDIS_ELEMENT_TYPE_LONGBCD
};

/**
 * @brief   Defines the @c ZydisElementSize datatype.
 */
typedef ZydisU16 ZydisElementSize;

/* ---------------------------------------------------------------------------------------------- */
/* Operand type                                                                                   */
/* ---------------------------------------------------------------------------------------------- */

/**
 * @brief   Defines the @c ZydisOperandType datatype.
 */
typedef ZydisU8 ZydisOperandType;

/**
 * @brief   Values that represent operand-types.
 */
enum ZydisOperandTypes
{
    /**
     * @brief   The operand is not used.
     */
    ZYDIS_OPERAND_TYPE_UNUSED,
    /**
     * @brief   The operand is a register operand.
     */
    ZYDIS_OPERAND_TYPE_REGISTER,
    /**
     * @brief   The operand is a memory operand.
     */
    ZYDIS_OPERAND_TYPE_MEMORY,
    /**
     * @brief   The operand is a pointer operand with a segment:offset lvalue.
     */
    ZYDIS_OPERAND_TYPE_POINTER,
    /**
     * @brief   The operand is an immediate operand.
     */
    ZYDIS_OPERAND_TYPE_IMMEDIATE,
    /**
     * @brief   Maximum value of this enum.
     */
    ZYDIS_OPERAND_TYPE_MAX_VALUE = ZYDIS_OPERAND_TYPE_IMMEDIATE
};

/* ---------------------------------------------------------------------------------------------- */
/* Operand encoding                                                                               */
/* ---------------------------------------------------------------------------------------------- */

/**
 * @brief   Defines the @c ZydisOperandEncoding datatype.
 */
typedef ZydisU8 ZydisOperandEncoding;

/**
 * @brief   Values that represent operand-encodings.
 */
enum ZydisOperandEncodings
{
    ZYDIS_OPERAND_ENCODING_NONE,
    ZYDIS_OPERAND_ENCODING_MODRM_REG,
    ZYDIS_OPERAND_ENCODING_MODRM_RM,
    ZYDIS_OPERAND_ENCODING_OPCODE,
    ZYDIS_OPERAND_ENCODING_NDSNDD,
    ZYDIS_OPERAND_ENCODING_IS4,
    ZYDIS_OPERAND_ENCODING_MASK,
    ZYDIS_OPERAND_ENCODING_DISP8,
    ZYDIS_OPERAND_ENCODING_DISP16,
    ZYDIS_OPERAND_ENCODING_DISP32,
    ZYDIS_OPERAND_ENCODING_DISP64,
    ZYDIS_OPERAND_ENCODING_DISP16_32_64,
    ZYDIS_OPERAND_ENCODING_DISP32_32_64,
    ZYDIS_OPERAND_ENCODING_DISP16_32_32,
    ZYDIS_OPERAND_ENCODING_UIMM8,
    ZYDIS_OPERAND_ENCODING_UIMM16,
    ZYDIS_OPERAND_ENCODING_UIMM32,
    ZYDIS_OPERAND_ENCODING_UIMM64,
    ZYDIS_OPERAND_ENCODING_UIMM16_32_64,
    ZYDIS_OPERAND_ENCODING_UIMM32_32_64,
    ZYDIS_OPERAND_ENCODING_UIMM16_32_32,
    ZYDIS_OPERAND_ENCODING_SIMM8,
    ZYDIS_OPERAND_ENCODING_SIMM16,
    ZYDIS_OPERAND_ENCODING_SIMM32,
    ZYDIS_OPERAND_ENCODING_SIMM64,
    ZYDIS_OPERAND_ENCODING_SIMM16_32_64,
    ZYDIS_OPERAND_ENCODING_SIMM32_32_64,
    ZYDIS_OPERAND_ENCODING_SIMM16_32_32,
    ZYDIS_OPERAND_ENCODING_JIMM8,
    ZYDIS_OPERAND_ENCODING_JIMM16,
    ZYDIS_OPERAND_ENCODING_JIMM32,
    ZYDIS_OPERAND_ENCODING_JIMM64,
    ZYDIS_OPERAND_ENCODING_JIMM16_32_64,
    ZYDIS_OPERAND_ENCODING_JIMM32_32_64,
    ZYDIS_OPERAND_ENCODING_JIMM16_32_32,
    ZYDIS_OPERAND_ENCODING_MAX_VALUE = ZYDIS_OPERAND_ENCODING_JIMM16_32_32
};

/* ---------------------------------------------------------------------------------------------- */
/* Operand visibility                                                                             */
/* ---------------------------------------------------------------------------------------------- */

/**
 * @brief   Defines the @c ZydisOperandVisibility datatype.
 */
typedef ZydisU8 ZydisOperandVisibility;

/**
 * @brief   Values that represent operand-visibilities.
 */
enum ZydisOperandVisibilities
{
    ZYDIS_OPERAND_VISIBILITY_INVALID,
    /**
     * @brief   The operand is explicitly encoded in the instruction. 
     */
    ZYDIS_OPERAND_VISIBILITY_EXPLICIT,
    /**
     * @brief   The operand is part of the opcode, but listed as an operand.
     */
    ZYDIS_OPERAND_VISIBILITY_IMPLICIT,
    /**
     * @brief   The operand is part of the opcode, and not typically listed as an operand.
     */
    ZYDIS_OPERAND_VISIBILITY_HIDDEN,
    /**
     * @brief   Maximum value of this enum.
     */
    ZYDIS_OPERAND_VISIBILITY_MAX_VALUE = ZYDIS_OPERAND_VISIBILITY_HIDDEN
};

/* ---------------------------------------------------------------------------------------------- */
/* Operand action                                                                                 */
/* ---------------------------------------------------------------------------------------------- */

/**
 * @brief   Defines the @c ZydisOperandAction datatype.
 */
typedef ZydisU8 ZydisOperandAction;

/**
 * @brief   Values that represent operand-actions.
 */
enum ZydisOperandActions
{
    ZYDIS_OPERAND_ACTION_INVALID,
    /**
     * @brief   The operand is read by the instruction.
     */
    ZYDIS_OPERAND_ACTION_READ,
    /**
     * @brief   The operand is written by the instruction (must write).
     */
    ZYDIS_OPERAND_ACTION_WRITE,
    /**
     * @brief   The operand is read and written by the instruction (must write).
     */
    ZYDIS_OPERAND_ACTION_READWRITE,
    /**
     * @brief   The operand is conditionally read by the instruction.
     */
    ZYDIS_OPERAND_ACTION_CONDREAD,
    /**
     * @brief   The operand is conditionally written by the instruction (may write).
     */
    ZYDIS_OPERAND_ACTION_CONDWRITE,
    /**
     * @brief   The operand is read and conditionally written by the instruction (may write).
     */
    ZYDIS_OPERAND_ACTION_READ_CONDWRITE,
    /**
     * @brief   The operand is written and conditionally read by the instruction (must write).
     */
    ZYDIS_OPERAND_ACTION_CONDREAD_WRITE,

    /**
     * @brief   Mask combining all writing access flags.
     */
    ZYDIS_OPERAND_ACTION_MASK_WRITE = ZYDIS_OPERAND_ACTION_WRITE |
        ZYDIS_OPERAND_ACTION_READWRITE | ZYDIS_OPERAND_ACTION_CONDWRITE | 
        ZYDIS_OPERAND_ACTION_READ_CONDWRITE | ZYDIS_OPERAND_ACTION_CONDREAD_WRITE,
    /**
     * @brief   Mask combining all reading access flags.
     */
    ZYDIS_OPERAND_ACTION_MASK_READ = ZYDIS_OPERAND_ACTION_READ | ZYDIS_OPERAND_ACTION_READWRITE | 
        ZYDIS_OPERAND_ACTION_CONDREAD | ZYDIS_OPERAND_ACTION_READ_CONDWRITE | 
        ZYDIS_OPERAND_ACTION_CONDREAD_WRITE,

    /**
     * @brief   Maximum value of this enum.
     */
    ZYDIS_OPERAND_ACTION_MAX_VALUE = ZYDIS_OPERAND_ACTION_CONDREAD_WRITE
};

/* ---------------------------------------------------------------------------------------------- */
/* Instruction encoding                                                                           */
/* ---------------------------------------------------------------------------------------------- */

/**
 * @brief   Defines the @c ZydisInstructionEncoding datatype.
 */
typedef ZydisU8 ZydisInstructionEncoding;

/**
 * @brief   Values that represent instruction-encodings.
 */
enum ZydisInstructionEncodings
{
    ZYDIS_INSTRUCTION_ENCODING_INVALID,
    /**
     * @brief   The instruction uses the default encoding.
     */
    ZYDIS_INSTRUCTION_ENCODING_DEFAULT,
    /**
     * @brief   The instruction uses the AMD 3DNow-encoding.
     */
    ZYDIS_INSTRUCTION_ENCODING_3DNOW,
    /**
     * @brief   The instruction uses the AMD XOP-encoding.
     */
    ZYDIS_INSTRUCTION_ENCODING_XOP,
    /**
     * @brief   The instruction uses the VEX-encoding.
     */
    ZYDIS_INSTRUCTION_ENCODING_VEX,
    /**
     * @brief   The instruction uses the EVEX-encoding.
     */
    ZYDIS_INSTRUCTION_ENCODING_EVEX,
    /**
     * @brief   The instruction uses the MVEX-encoding.
     */
    ZYDIS_INSTRUCTION_ENCODING_MVEX,
    /**
     * @brief   Maximum value of this enum.
     */
    ZYDIS_INSTRUCTION_ENCODING_MAX_VALUE = ZYDIS_INSTRUCTION_ENCODING_MVEX
};

/* ---------------------------------------------------------------------------------------------- */
/* Opcode map                                                                                     */
/* ---------------------------------------------------------------------------------------------- */

/**
 * @brief   Defines the @c ZydisOpcodeMap map.
 */
typedef ZydisU8 ZydisOpcodeMap;

/**
 * @brief   Values that represent opcode-maps.
 */
enum ZydisOpcodeMaps
{
    ZYDIS_OPCODE_MAP_DEFAULT,
    ZYDIS_OPCODE_MAP_0F,
    ZYDIS_OPCODE_MAP_0F38,
    ZYDIS_OPCODE_MAP_0F3A,
    ZYDIS_OPCODE_MAP_0F0F,
    ZYDIS_OPCODE_MAP_XOP8,
    ZYDIS_OPCODE_MAP_XOP9,
    ZYDIS_OPCODE_MAP_XOPA,
    ZYDIS_OPCODE_MAP_MAX_VALUE = ZYDIS_OPCODE_MAP_XOP9
};

/* ---------------------------------------------------------------------------------------------- */

/* ============================================================================================== */

#ifdef __cplusplus
}
#endif

#endif /* ZYDIS_SHAREDTYPES_H */

```

`Avanguard/Zydis/Zydis/Status.h`:

```h
/***************************************************************************************************

  Zyan Disassembler Library (Zydis)

  Original Author : Florian Bernd

 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.

***************************************************************************************************/

/**
 * @file
 * @brief   Status code definitions and check macros.
 */

#ifndef ZYDIS_STATUS_H
#define ZYDIS_STATUS_H

#include <Zydis/CommonTypes.h>

#ifdef __cplusplus
extern "C" {
#endif

/* ============================================================================================== */
/* Enums and types                                                                                */
/* ============================================================================================== */

/**
 * @brief   Defines the @c ZydisStatus datatype.
 */
typedef ZydisU32 ZydisStatus;

/**
 * @brief   Values that represent a zydis status-codes.
 */
enum ZydisStatusCodes
{
    /* ------------------------------------------------------------------------------------------ */
    /* General                                                                                    */
    /* ------------------------------------------------------------------------------------------ */

    /**
     * @brief   The operation completed successfully.
     */
    ZYDIS_STATUS_SUCCESS                                                              = 0x00000000,
    /**
     * @brief   An invalid parameter was passed to a function.
     */
    ZYDIS_STATUS_INVALID_PARAMETER,
    /**
     * @brief   An attempt was made to perform an invalid operation.
     */
    ZYDIS_STATUS_INVALID_OPERATION,
    /**
     * @brief   A buffer passed to a function was too small to complete the requested operation.
     */
    ZYDIS_STATUS_INSUFFICIENT_BUFFER_SIZE,

    /* ------------------------------------------------------------------------------------------ */
    /* Decoder                                                                                    */
    /* ------------------------------------------------------------------------------------------ */

    /**
     * @brief   An attempt was made to read data from an input data-source that has no more data 
     *          available.
     */
    ZYDIS_STATUS_NO_MORE_DATA,
    /**
     * @brief   An general error occured while decoding the current instruction. The instruction
     *          might be undefined.
     */
    ZYDIS_STATUS_DECODING_ERROR, 
    /**
     * @brief   The instruction exceeded the maximum length of 15 bytes.
     */
    ZYDIS_STATUS_INSTRUCTION_TOO_LONG,
    /**
     * @brief   The instruction encoded an invalid register.
     */
    ZYDIS_STATUS_BAD_REGISTER,
    /**
     * @brief   A lock-prefix (F0) was found while decoding an instruction that does not support
     *          locking. 
     */
    ZYDIS_STATUS_ILLEGAL_LOCK,
    /**
     * @brief   A legacy-prefix (F2, F3, 66) was found while decoding a XOP/VEX/EVEX/MVEX 
     *          instruction. 
     */
    ZYDIS_STATUS_ILLEGAL_LEGACY_PFX,
    /**
     * @brief   A rex-prefix was found while decoding a XOP/VEX/EVEX/MVEX instruction. 
     */
    ZYDIS_STATUS_ILLEGAL_REX,
    /**
     * @brief   An invalid opcode-map value was found while decoding a XOP/VEX/EVEX/MVEX-prefix.  
     */
    ZYDIS_STATUS_INVALID_MAP,
    /**
     * @brief   An error occured while decoding the EVEX-prefix.  
     */
    ZYDIS_STATUS_MALFORMED_EVEX,
    /**
     * @brief   An error occured while decoding the MVEX-prefix.  
     */
    ZYDIS_STATUS_MALFORMED_MVEX, // TODO: Do we need this?
    /**
     * @brief   An invalid write-mask was specified for an EVEX/MVEX instruction.  
     */
    ZYDIS_STATUS_INVALID_MASK,

    /* ------------------------------------------------------------------------------------------ */
    /* Encoder                                                                                    */
    /* ------------------------------------------------------------------------------------------ */

    ZYDIS_STATUS_IMPOSSIBLE_INSTRUCTION,

    /* ------------------------------------------------------------------------------------------ */
    /* Misc                                                                                       */
    /* ------------------------------------------------------------------------------------------ */

    /**
     * @brief   The base value for user-defined status codes.
     */
    ZYDIS_STATUS_USER                                                                 = 0x10000000

    // Max value entry intentionally omitted since users might 
    // define custom error codes for formatter hooks.
};

/* ============================================================================================== */
/* Macros                                                                                         */
/* ============================================================================================== */

/**
 * @brief   Checks if a zydis operation was successfull.
 *
 * @param   status  The zydis status-code to check.
 */
#define ZYDIS_SUCCESS(status) (status == ZYDIS_STATUS_SUCCESS)

/**
 * @brief   Checks if a zydis operation was successfull and returns the status-code, if not.
 *
 * @param   status  The zydis status-code to check.
 */
#define ZYDIS_CHECK(status) \
    do \
    { \
        ZydisStatus status_038560234 = status; \
        if (!ZYDIS_SUCCESS(status_038560234)) \
        { \
            return status_038560234; \
        } \
    } while (0)

/* ============================================================================================== */

#ifdef __cplusplus
}
#endif

#endif /* ZYDIS_STATUS_H */

```

`Avanguard/Zydis/Zydis/String.h`:

```h
/***************************************************************************************************

  Zyan Disassembler Library (Zydis)

  Original Author : Florian Bernd, Joel Höner

 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.

***************************************************************************************************/

#ifndef ZYDIS_STRING_H
#define ZYDIS_STRING_H

#include <Zydis/CommonTypes.h>
#include <Zydis/Status.h>
#include <Zydis/Internal/LibC.h>

/* ============================================================================================== */
/* Enums and types                                                                                */
/* ============================================================================================== */

/* ---------------------------------------------------------------------------------------------- */
/* String                                                                                         */
/* ---------------------------------------------------------------------------------------------- */

/**
 * @brief   Defines the `ZydisString` struct.
 */
typedef struct ZydisString_ 
{
    /**
     * @brief   The buffer that contains the actual string (0-termination is optional!).
     */
    char *buffer;
    /**
     * @brief   The length of the string (without 0-termination).
     */
    ZydisUSize length;
    /**
     * @brief   The total buffer capacity.
     */
    ZydisUSize capacity;
} ZydisString;

/* ---------------------------------------------------------------------------------------------- */
/* Static string                                                                                  */
/* ---------------------------------------------------------------------------------------------- */

#pragma pack(push, 1)

/**
 * @brief   Defines the `ZydisStaticString` struct. 
 * 
 * This more compact struct is mainly used for internal string-tables to save up some bytes.
 */
typedef struct ZydisStaticString_
{
    /**
     * @brief   The buffer that contains the actual string (0-termination is optional!).
    */
    const char* buffer;
    /**
     * @brief   The length of the string (without 0-termination).
    */
    ZydisU8 length;
} ZydisStaticString;

#pragma pack(pop)

/* ---------------------------------------------------------------------------------------------- */
/* Letter Case                                                                                    */
/* ---------------------------------------------------------------------------------------------- */

/**
 * @brief   Defines the `ZydisLetterCase` datatype.
 */
typedef ZydisU8 ZydisLetterCase;

/**
 * @brief   Values that represent letter cases.
 */
enum ZydisLetterCases
{
    /**
     * @brief   Uses the given text "as is".
     */
    ZYDIS_LETTER_CASE_DEFAULT,
    /**
     * @brief   Converts the given text to lowercase letters.
     */
    ZYDIS_LETTER_CASE_LOWER,
    /**
     * @brief   Converts the given text to uppercase letters.
     */
    ZYDIS_LETTER_CASE_UPPER,

    /**
     * @brief   Maximum value of this enum.
     */
    ZYDIS_LETTER_CASE_MAX_VALUE = ZYDIS_LETTER_CASE_UPPER
};

/* ---------------------------------------------------------------------------------------------- */

/* ============================================================================================== */
/* Macros                                                                                         */
/* ============================================================================================== */

/* ---------------------------------------------------------------------------------------------- */
/* Helper Macros                                                                                  */
/* ---------------------------------------------------------------------------------------------- */

/**
 * @brief   Creates a `ZydisString` struct from a static C-string.
 * 
 * @param   string  The C-string constant. 
 */
#define ZYDIS_MAKE_STRING(string) \
    { (char*)string, sizeof(string) - 1, sizeof(string) - 1 }

/**
 * @brief   Creates a `ZydisStaticString` from a static C-string.
 * 
 * @param   string  The C-string constant. 
 */
#define ZYDIS_MAKE_STATIC_STRING(string) \
    { string, sizeof(string) - 1 }

/* ---------------------------------------------------------------------------------------------- */

/* ============================================================================================== */
/* Functions                                                                                      */
/* ============================================================================================== */

/* ---------------------------------------------------------------------------------------------- */
/* Basic Operations                                                                               */
/* ---------------------------------------------------------------------------------------------- */

/**
 * @brief   Initializes a `ZydisString` struct with a C-string.
 * 
 * @param   string  The string to initialize.
 * @param   value   The C-string constant. 
 * 
 * @return  A zydis status code.
 */
ZYDIS_NO_EXPORT ZYDIS_INLINE ZydisStatus ZydisStringInit(ZydisString* string, char* value)
{
    if (!string || !value)
    {
        return ZYDIS_STATUS_INVALID_PARAMETER;
    }

    const ZydisUSize length = ZydisStrLen(value);
    string->buffer   = value;
    string->length   = length;
    string->capacity = length; 
    
    return ZYDIS_STATUS_SUCCESS;
}

/**
 * @brief   Finalizes a `ZydisString` struct by adding a terminating zero byte.
 * 
 * @param   string  The string to finalize.
 * 
 * @return  A zydis status code.
 */
ZYDIS_NO_EXPORT ZYDIS_INLINE ZydisStatus ZydisStringFinalize(ZydisString* string)
{
    if (!string)
    {
        return ZYDIS_STATUS_INVALID_PARAMETER;
    }
    if (string->length >= string->capacity)
    {
        return ZYDIS_STATUS_INSUFFICIENT_BUFFER_SIZE;
    }

    string->buffer[string->length] = 0;
    return ZYDIS_STATUS_SUCCESS;
}

/* ---------------------------------------------------------------------------------------------- */

/**
 * @brief   Appends a `ZydisString` to another `ZydisString`, converting it to the specified
 *          letter-case.
 *
 * @param   string      The string to append to.
 * @param   text        The string to append.
 * @param   letterCase  The letter case to use.
 *
 * @return  @c ZYDIS_STATUS_SUCCESS, if the function succeeded, or 
 *          @c ZYDIS_STATUS_INSUFFICIENT_BUFFER_SIZE, if the size of the buffer was not 
 *          sufficient to append the given @c text.
 */
ZYDIS_NO_EXPORT ZydisStatus ZydisStringAppendEx(ZydisString* string, const ZydisString* text,
    ZydisLetterCase letterCase);

/**
 * @brief   Appends the given C-string to a `ZydisString`, converting it to the specified
 *          letter-case.
 *
 * @param   string      The string to append to.
 * @param   text        The C-string to append.
 * @param   letterCase  The letter case to use.
 *
 * @return  @c ZYDIS_STATUS_SUCCESS, if the function succeeded, or 
 *          @c ZYDIS_STATUS_INSUFFICIENT_BUFFER_SIZE, if the size of the buffer was not 
 *          sufficient to append the given @c text.
 */
ZYDIS_NO_EXPORT ZYDIS_INLINE ZydisStatus ZydisStringAppendExC(ZydisString* string, 
    const char* text, ZydisLetterCase letterCase)
{
    ZydisString other;
    ZYDIS_CHECK(ZydisStringInit(&other, (char*)text));
    
    return ZydisStringAppendEx(string, &other, letterCase);
}

/**
 * @brief   Appends the given 'ZydisStaticString' to a `ZydisString`, converting it to the 
 *          specified letter-case.
 *
 * @param   string      The string to append to.
 * @param   text        The static-string to append.
 * @param   letterCase  The letter case to use.
 *
 * @return  @c ZYDIS_STATUS_SUCCESS, if the function succeeded, or 
 *          @c ZYDIS_STATUS_INSUFFICIENT_BUFFER_SIZE, if the size of the buffer was not 
 *          sufficient to append the given @c text.
 */
ZYDIS_NO_EXPORT ZYDIS_INLINE ZydisStatus ZydisStringAppendExStatic(ZydisString* string, 
    const ZydisStaticString* text, ZydisLetterCase letterCase)
{
    if (!text || !text->buffer)
    {
        return ZYDIS_STATUS_INVALID_PARAMETER;
    }

    ZydisString other;
    other.buffer = (char*)text->buffer;
    other.length = text->length;
    
    return ZydisStringAppendEx(string, &other, letterCase);
}

/**
 * @brief   Appends a `ZydisString` to another `ZydisString`.
 *
 * @param   string      The string to append to.
 * @param   text        The string to append.
 *
 * @return  @c ZYDIS_STATUS_SUCCESS, if the function succeeded, or 
 *          @c ZYDIS_STATUS_INSUFFICIENT_BUFFER_SIZE, if the size of the buffer was not 
 *          sufficient to append the given @c text.
 */
ZYDIS_NO_EXPORT ZYDIS_INLINE ZydisStatus ZydisStringAppend(ZydisString* string, 
    const ZydisString* text)
{
    return ZydisStringAppendEx(string, text, ZYDIS_LETTER_CASE_DEFAULT);
}

/**
 * @brief   Appends the given C-string to a `ZydisString`.
 *
 * @param   string      The string to append to.
 * @param   text        The C-string to append.
 *
 * @return  @c ZYDIS_STATUS_SUCCESS, if the function succeeded, or 
 *          @c ZYDIS_STATUS_INSUFFICIENT_BUFFER_SIZE, if the size of the buffer was not 
 *          sufficient to append the given @c text.
 */
ZYDIS_NO_EXPORT ZYDIS_INLINE ZydisStatus ZydisStringAppendC(ZydisString* string, const char* text)
{
    ZydisString other;
    ZYDIS_CHECK(ZydisStringInit(&other, (char*)text));
    
    return ZydisStringAppendEx(string, &other, ZYDIS_LETTER_CASE_DEFAULT);
}

/**
 * @brief   Appends the given 'ZydisStaticString' to a `ZydisString`.
 *
 * @param   string      The string to append to.
 * @param   text        The static-string to append.
 *
 * @return  @c ZYDIS_STATUS_SUCCESS, if the function succeeded, or 
 *          @c ZYDIS_STATUS_INSUFFICIENT_BUFFER_SIZE, if the size of the buffer was not 
 *          sufficient to append the given @c text.
 */
ZYDIS_NO_EXPORT ZYDIS_INLINE ZydisStatus ZydisStringAppendStatic(ZydisString* string, 
    const ZydisStaticString* text, ZydisLetterCase letterCase)
{
    if (!text || !text->buffer)
    {
        return ZYDIS_STATUS_INVALID_PARAMETER;
    }

    ZydisString other;
    other.buffer = (char*)text->buffer;
    other.length = text->length;
    
    return ZydisStringAppendEx(string, &other, letterCase);
}

/* ---------------------------------------------------------------------------------------------- */
/* Formatting                                                                                     */
/* ---------------------------------------------------------------------------------------------- */

/**
 * @brief   Formats the given unsigned ordinal @c value to its decimal text-representation and  
 *          appends it to @c s.
 *
 * @param   string          A pointer to the string.
 * @param   value           The value.
 * @param   paddingLength   Padds the converted value with leading zeros, if the number of chars is
 *                          less than the @c paddingLength.
 *
 * @return  @c ZYDIS_STATUS_SUCCESS, if the function succeeded, or 
 *          @c ZYDIS_STATUS_INSUFFICIENT_BUFFER_SIZE, if the size of the buffer was not 
 *          sufficient to append the given @c value.
 *          
 * The string-buffer pointer is increased by the number of chars written, if the call was 
 * successfull.
 */
ZYDIS_NO_EXPORT ZydisStatus ZydisPrintDecU(ZydisString* string, ZydisU64 value, 
    ZydisU8 paddingLength);

/**
 * @brief   Formats the given signed ordinal @c value to its decimal text-representation and   
 *          appends it to @c s.
 *
 * @param   string          A pointer to the string.
 * @param   value           The value.
 * @param   paddingLength   Padds the converted value with leading zeros, if the number of chars is
 *                          less than the @c paddingLength (the sign char is ignored).
 *
 * @return  @c ZYDIS_STATUS_SUCCESS, if the function succeeded, or 
 *          @c ZYDIS_STATUS_INSUFFICIENT_BUFFER_SIZE, if the size of the buffer was not 
 *          sufficient to append the given @c value.
 *          
 * The string-buffer pointer is increased by the number of chars written, if the call was 
 * successfull.
 */
ZYDIS_NO_EXPORT ZydisStatus ZydisPrintDecS(ZydisString* string, ZydisI64 value, 
    ZydisU8 paddingLength);

/**
 * @brief   Formats the given unsigned ordinal @c value to its hexadecimal text-representation and 
 *          appends it to the @c buffer.
 *
 * @param   string          A pointer to the string.
 * @param   value           The value.
 * @param   paddingLength   Padds the converted value with leading zeros, if the number of chars is
 *                          less than the @c paddingLength.
 * @param   uppercase       Set @c TRUE to print the hexadecimal value in uppercase letters instead 
 *                          of lowercase ones.
 * @param   prefix          The string to use as prefix or `NULL`, if not needed.
 * @param   suffix          The string to use as suffix or `NULL`, if not needed.
 *
 * @return  @c ZYDIS_STATUS_SUCCESS, if the function succeeded, or 
 *          @c ZYDIS_STATUS_INSUFFICIENT_BUFFER_SIZE, if the size of the buffer was not 
 *          sufficient to append the given @c value.
 *          
 * The string-buffer pointer is increased by the number of chars written, if the call was 
 * successfull.
 */
ZYDIS_NO_EXPORT ZydisStatus ZydisPrintHexU(ZydisString* string, ZydisU64 value,
    ZydisU8 paddingLength, ZydisBool uppercase, const ZydisString* prefix, 
    const ZydisString* suffix);

/**
 * @brief   Formats the given signed ordinal @c value to its hexadecimal text-representation and 
 *          appends it to the @c buffer.
 *
 * @param   string          A pointer to the string.
 * @param   value           The value.
 * @param   paddingLength   Padds the converted value with leading zeros, if the number of chars is
 *                          less than the @c paddingLength (the sign char is ignored).
 * @param   uppercase       Set @c TRUE to print the hexadecimal value in uppercase letters instead 
 *                          of lowercase ones.
 * @param   prefix          The string to use as prefix or `NULL`, if not needed.
 * @param   suffix          The string to use as suffix or `NULL`, if not needed.
 *
 * @return  @c ZYDIS_STATUS_SUCCESS, if the function succeeded, or 
 *          @c ZYDIS_STATUS_INSUFFICIENT_BUFFER_SIZE, if the size of the buffer was not 
 *          sufficient to append the given @c value.
 *          
 * The string-buffer pointer is increased by the number of chars written, if the call was 
 * successfull.
 */
ZYDIS_NO_EXPORT ZydisStatus ZydisPrintHexS(ZydisString* string, ZydisI64 value, 
    ZydisU8 paddingLength, ZydisBool uppercase, const ZydisString* prefix, 
    const ZydisString* suffix);

/* ---------------------------------------------------------------------------------------------- */

/* ============================================================================================== */

#endif // ZYDIS_STRING_H

```

`Avanguard/Zydis/Zydis/Utils.h`:

```h
/***************************************************************************************************

  Zyan Disassembler Library (Zydis)

  Original Author : Florian Bernd

 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.

***************************************************************************************************/

/**
 * @file
 * @brief   Other utility functions.
 */

#ifndef ZYDIS_UTILS_H
#define ZYDIS_UTILS_H

#include <Zydis/Defines.h>
#include <Zydis/Status.h>
#include <Zydis/DecoderTypes.h>

#ifdef __cplusplus
extern "C" {
#endif

/* ============================================================================================== */
/* Address calculation                                                                            */
/* ============================================================================================== */

/**
 * @brief   Calculates the absolute target-address for the given instruction operand.
 *
 * @param   instruction A pointer to the @c ZydisDecodedInstruction struct.
 * @param   operand     A pointer to the @c ZydisDecodedOperand struct.
 * @param   address     A pointer to the memory that receives the absolute target-address.
 *
 * @return  A zydis status code.
 * 
 * You should use this function in the following cases:
 * - `IMM` operands with relative address (e.g. `JMP`, `CALL`, ...)
 * - `MEM` operands with RIP/EIP-relative address (e.g. `MOV RAX, [RIP+0x12345678]`)
 * - `MEM` operands with absolute address (e.g. `MOV RAX, [0x12345678]`)
 *   - The displacement needs to get truncated and zero extended
 */
ZYDIS_EXPORT ZydisStatus ZydisCalcAbsoluteAddress(const ZydisDecodedInstruction* instruction, 
    const ZydisDecodedOperand* operand, ZydisU64* address);

/* ============================================================================================== */
/* Flags                                                                                          */
/* ============================================================================================== */

/**
 * @brief   Returns a mask of accessed CPU-flags matching the given `action`.
 *
 * @param   instruction A pointer to the @c ZydisDecodedInstruction struct.
 * @param   action      The CPU-flag action.
 * @param   flags       A pointer to the variable that receives the flag mask.
 *
 * @return  A zydis status code.
 */
ZYDIS_EXPORT ZydisStatus ZydisGetAccessedFlagsByAction(const ZydisDecodedInstruction* instruction, 
    ZydisCPUFlagAction action, ZydisCPUFlagMask* flags);

/* ============================================================================================== */

#ifdef __cplusplus
}
#endif

#endif /* ZYDIS_UTILS_H */

```

`Avanguard/Zydis/Zydis/Zydis.h`:

```h
/***************************************************************************************************

  Zyan Disassembler Library (Zydis)

  Original Author : Florian Bernd

 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.

***************************************************************************************************/

/**
 * @file
 * @brief   Master include file, including everything else.
 */

#ifndef ZYDIS_H
#define ZYDIS_H

#include <Zydis/CommonTypes.h>
#include <Zydis/Decoder.h>
#include <Zydis/DecoderTypes.h>
#include <Zydis/Defines.h>
#include <Zydis/Formatter.h>
#include <Zydis/MetaInfo.h>
#include <Zydis/Mnemonic.h>
#include <Zydis/Register.h>   
#include <Zydis/SharedTypes.h>
#include <Zydis/Status.h>
#include <Zydis/String.h>
#include <Zydis/Utils.h>

#ifdef __cplusplus
extern "C" {
#endif

/* ============================================================================================== */
/* Macros                                                                                         */
/* ============================================================================================== */

/* ---------------------------------------------------------------------------------------------- */
/* Constants                                                                                      */
/* ---------------------------------------------------------------------------------------------- */

/**
 * @brief   A macro that defines the zydis version.
 */
#define ZYDIS_VERSION (ZydisU64)0x0002000000000000

/* ---------------------------------------------------------------------------------------------- */
/* Helper macros                                                                                  */
/* ---------------------------------------------------------------------------------------------- */

/**
 * @brief   Extracts the major-part of the zydis version.
 *
 * @param   version The zydis version value
 */
#define ZYDIS_VERSION_MAJOR(version) (ZydisU16)((version & 0xFFFF000000000000) >> 48)

/**
 * @brief   Extracts the minor-part of the zydis version.
 *
 * @param   version The zydis version value
 */
#define ZYDIS_VERSION_MINOR(version) (ZydisU16)((version & 0x0000FFFF00000000) >> 32)

/**
 * @brief   Extracts the patch-part of the zydis version.
 *
 * @param   version The zydis version value
 */
#define ZYDIS_VERSION_PATCH(version) (ZydisU16)((version & 0x00000000FFFF0000) >> 16)

/**
 * @brief   Extracts the build-part of the zydis version.
 *
 * @param   version The zydis version value
 */
#define ZYDIS_VERSION_BUILD(version) (ZydisU16)(version & 0x000000000000FFFF)

/* ---------------------------------------------------------------------------------------------- */

/* ============================================================================================== */
/* Enums and types                                                                                */
/* ============================================================================================== */

/**
 * @brief   Defines the @c ZydisFeature datatype.
 */
typedef ZydisU8 ZydisFeature;

/**
 * @brief   Values that represent zydis features.
 */
enum ZydisFeatures
{
    ZYDIS_FEATURE_EVEX,
    ZYDIS_FEATURE_MVEX,
};

/* ============================================================================================== */
/* Exported functions                                                                             */
/* ============================================================================================== */

/**
 * @brief   Returns the zydis version.
 *
 * @return  The zydis version.
 *          
 * Use the macros provided in this file to extract the major, minor, patch and build part from the 
 * returned version value.
 */
ZYDIS_EXPORT ZydisU64 ZydisGetVersion(void);

/**
 * @brief   Checks, if the specified feature is enabled in the current zydis library instance.
 *
 * @param   feature The feature.
 *
 * @return  @c True if the feature is enabled, @c false if not.
 */
ZYDIS_EXPORT ZydisBool ZydisIsFeatureEnabled(ZydisFeature feature);

/* ============================================================================================== */

#ifdef __cplusplus
}
#endif

#endif /* ZYDIS_H */

```

`Avanguard/Zydis/ZydisExportConfig.h`:

```h

#ifndef ZYDIS_EXPORT_H
#define ZYDIS_EXPORT_H

#ifdef ZYDIS_STATIC_DEFINE
#  define ZYDIS_EXPORT
#  define ZYDIS_NO_EXPORT
#else
#  ifndef ZYDIS_EXPORT
#    ifdef Zydis_EXPORTS
        /* We are building this library */
#      define ZYDIS_EXPORT __declspec(dllexport)
#    else
        /* We are using this library */
#      define ZYDIS_EXPORT __declspec(dllimport)
#    endif
#  endif

#  ifndef ZYDIS_NO_EXPORT
#    define ZYDIS_NO_EXPORT 
#  endif
#endif

#ifndef ZYDIS_DEPRECATED
#  define ZYDIS_DEPRECATED __declspec(deprecated)
#endif

#ifndef ZYDIS_DEPRECATED_EXPORT
#  define ZYDIS_DEPRECATED_EXPORT ZYDIS_EXPORT ZYDIS_DEPRECATED
#endif

#ifndef ZYDIS_DEPRECATED_NO_EXPORT
#  define ZYDIS_DEPRECATED_NO_EXPORT ZYDIS_NO_EXPORT ZYDIS_DEPRECATED
#endif

#if 0 /* DEFINE_NO_DEPRECATED */
#  ifndef ZYDIS_NO_DEPRECATED
#    define ZYDIS_NO_DEPRECATED
#  endif
#endif

#endif

```

`Avanguard/resource.h`:

```h
//{{NO_DEPENDENCIES}}
// Microsoft Visual C++ generated include file.
// Used by Avanguard.rc

// Следующие стандартные значения для новых объектов
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        101
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1001
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif

```

`Avanguard/stdafx.cpp`:

```cpp
#include "stdafx.h"
```

`Avanguard/stdafx.h`:

```h
#pragma once

#define ASMJIT_BUILD_STATIC
#define ASMJIT_BUILD_X86 

#define _SILENCE_CXX17_OLD_ALLOCATOR_MEMBERS_DEPRECATION_WARNING
#define _SILENCE_CXX17_CODECVT_HEADER_DEPRECATION_WARNING

#include "targetver.h"

#include <stdio.h>

#define NOMINMAX
#include "hModules.h"

#ifdef _DEBUG
#define XORSTR(Text) (Text)
#else
#include "xorstr\\xorstr.hpp"
#define XORSTR(Text) (xorstr(Text).crypt_get())
#endif
```

`Avanguard/t1ha/t1ha.h`:

```h
/*
 *  Copyright (c) 2016-2017 Positive Technologies, https://www.ptsecurity.com,
 *  Fast Positive Hash.
 *
 *  Portions Copyright (c) 2010-2017 Leonid Yuriev <leo@yuriev.ru>,
 *  The 1Hippeus project (t1h).
 *
 *  This software is provided 'as-is', without any express or implied
 *  warranty. In no event will the authors be held liable for any damages
 *  arising from the use of this software.
 *
 *  Permission is granted to anyone to use this software for any purpose,
 *  including commercial applications, and to alter it and redistribute it
 *  freely, subject to the following restrictions:
 *
 *  1. The origin of this software must not be misrepresented; you must not
 *     claim that you wrote the original software. If you use this software
 *     in a product, an acknowledgement in the product documentation would be
 *     appreciated but is not required.
 *  2. Altered source versions must be plainly marked as such, and must not be
 *     misrepresented as being the original software.
 *  3. This notice may not be removed or altered from any source distribution.
 */

/*
 * t1ha = { Fast Positive Hash, aka "Позитивный Хэш" }
 * by [Positive Technologies](https://www.ptsecurity.ru)
 *
 * Briefly, it is a 64-bit Hash Function:
 *  1. Created for 64-bit little-endian platforms, in predominantly for x86_64,
 *     but portable and without penalties it can run on any 64-bit CPU.
 *  2. In most cases up to 15% faster than City64, xxHash, mum-hash, metro-hash
 *     and all others portable hash-functions (which do not use specific
 *     hardware tricks).
 *  3. Not suitable for cryptography.
 *
 * The Future will Positive. Всё будет хорошо.
 *
 * ACKNOWLEDGEMENT:
 * The t1ha was originally developed by Leonid Yuriev (Леонид Юрьев)
 * for The 1Hippeus project - zerocopy messaging in the spirit of Sparta!
 */

#pragma once
#include <stddef.h>
#include <stdint.h>

#ifndef __has_attribute
#define __has_attribute(x) (0)
#endif

#ifndef __GNUC_PREREQ
#if defined(__GNUC__) && defined(__GNUC_MINOR__)
#define __GNUC_PREREQ(maj, min)                                                \
  ((__GNUC__ << 16) + __GNUC_MINOR__ >= ((maj) << 16) + (min))
#else
#define __GNUC_PREREQ(maj, min) 0
#endif
#endif /* __GNUC_PREREQ */

#ifndef __CLANG_PREREQ
#ifdef __clang__
#define __CLANG_PREREQ(maj, min)                                               \
  ((__clang_major__ << 16) + __clang_minor__ >= ((maj) << 16) + (min))
#else
#define __CLANG_PREREQ(maj, min) (0)
#endif
#endif /* __CLANG_PREREQ */

#ifndef __dll_export
#if defined(_WIN32) || defined(__CYGWIN__)
#if defined(__GNUC__) || __has_attribute(dllexport)
#define __dll_export __attribute__((dllexport))
#elif defined(_MSC_VER)
#define __dll_export __declspec(dllexport)
#else
#define __dll_export
#endif
#elif defined(__GNUC__) || __has_attribute(visibility)
#define __dll_export __attribute__((visibility("default")))
#else
#define __dll_export
#endif
#endif /* __dll_export */

#ifndef __dll_import
#if defined(_WIN32) || defined(__CYGWIN__)
#if defined(__GNUC__) || __has_attribute(dllimport)
#define __dll_import __attribute__((dllimport))
#elif defined(_MSC_VER)
#define __dll_import __declspec(dllimport)
#else
#define __dll_import
#endif
#else
#define __dll_import
#endif
#endif /* __dll_import */

#if defined(t1ha_EXPORTS)
#define T1HA_API __dll_export
#elif defined(t1ha_IMPORTS)
#define T1HA_API __dll_import
#else
#define T1HA_API
#endif /* T1HA_API */

#ifdef __cplusplus
extern "C" {
#endif

/* The main low-endian version.
 *  - runs faster on 64-bit low-endian platforms,
 *    in other cases may runs slowly.
 *  - returns same result on all architectures and CPUs,
 *    but it is differs from t1ha0(). */
T1HA_API uint64_t t1ha1_le(const void *data, size_t length, uint64_t seed);

/* The big-endian version.
 *  - runs faster on 64-bit big-endian platforms,
 *    in other cases may runs slowly.
 *  - returns same result on all architectures and CPUs,
 *    but it is differs from t1ha0(). */
T1HA_API uint64_t t1ha1_be(const void *data, size_t length, uint64_t seed);

/* The nicname for generic version of "Fast Positive Hash".
 *  - returns same result on all architectures and CPUs.
 *  - created for 64-bit little-endian platforms,
 *    in other cases may runs slowly. */
static __inline uint64_t t1ha(const void *data, size_t length, uint64_t seed) {
  return t1ha1_le(data, length, seed);
}

/* t1ha0() is a facade that selects most quick-and-dirty hash
 * for the current processor.
 *
 * BE CAREFUL!!!  This is means:
 *
 *   1. The quality of hash is a subject for tradeoffs with performance.
 *      So, the quality and strength of t1ha0() may be lower than t1ha1(),
 *      especially on 32-bit targets, but then much faster.
 *      However, guaranteed that it passes all SMHasher tests.
 *
 *   2. No warranty that the hash result will be same for particular
 *      key on another machine or another version of libt1ha.
 *
 *      Briefly, such hash-results and their derivatives, should be
 *      used only in runtime, but should not be persist or transferred
 *      over a network. */

#ifdef __ELF__
T1HA_API uint64_t t1ha0(const void *data, size_t length, uint64_t seed);
#else
T1HA_API extern uint64_t (*t1ha0_funcptr)(const void *data, size_t length,
                                          uint64_t seed);
static __inline uint64_t t1ha0(const void *data, size_t length, uint64_t seed) {
  return t1ha0_funcptr(data, length, seed);
}
#endif /* __ELF__ */

uint64_t t1ha0_32le(const void *data, size_t length, uint64_t seed);
uint64_t t1ha0_32be(const void *data, size_t length, uint64_t seed);

#if defined(__x86_64__) || (defined(_M_IX86) && _MSC_VER > 1800) ||            \
    defined(_M_X64) || defined(i386) || defined(_X86_) || defined(__i386__) || \
    defined(_X86_64_)
uint64_t t1ha0_ia32aes_noavx(const void *data, size_t length, uint64_t seed);
uint64_t t1ha0_ia32aes_avx(const void *data, size_t length, uint64_t seed);
uint64_t t1ha0_ia32aes_avx2(const void *data, size_t length, uint64_t seed);
#endif /* __i386__ || __x86_64__ */

#ifdef __cplusplus
}
#endif

```

`Avanguard/targetver.h`:

```h
#pragma once

// Включение SDKDDKVer.h обеспечивает определение самой последней доступной платформы Windows.

// Если требуется выполнить сборку приложения для предыдущей версии Windows, включите WinSDKVer.h и
// задайте для макроса _WIN32_WINNT значение поддерживаемой платформы перед включением SDKDDKVer.h.

#include <SDKDDKVer.h>

```

`Avanguard/xorstr/xorstr.hpp`:

```hpp
/*
 * Copyright 2017 - 2018 Justas Masiulis
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#define JM_XORSTR_DISABLE_AVX_INTRINSICS

#ifndef JM_XORSTR_HPP
#define JM_XORSTR_HPP

#include <immintrin.h>
#include <type_traits>
#include <cstdint>

#define xorstr(str) ::jm::xor_string<XORSTR_STR(str)>()

#ifdef _MSC_VER
#define XORSTR_FORCEINLINE __forceinline
#else
#define XORSTR_FORCEINLINE __attribute__((always_inline))
#endif

// MSVC - no volatile
// GCC - volatile almost everywhere
// clang - volatile everywhere
#if defined(__clang__)
#define XORSTR_CLANG_VOLATILE volatile
#define XORSTR_VOLATILE volatile
#elif defined(__GNUC__)
#define XORSTR_CLANG_VOLATILE
#define XORSTR_VOLATILE volatile
#else
#define XORSTR_CLANG_VOLATILE
#define XORSTR_VOLATILE
#endif

// these compile time strings were required for an earlier version.
// might not be necessary for current version
#define XORSTR_STRING_EXPAND_10(n, x)                         \
    jm::detail::c_at<n##0>(x), jm::detail::c_at<n##1>(x),     \
        jm::detail::c_at<n##2>(x), jm::detail::c_at<n##3>(x), \
        jm::detail::c_at<n##4>(x), jm::detail::c_at<n##5>(x), \
        jm::detail::c_at<n##6>(x), jm::detail::c_at<n##7>(x), \
        jm::detail::c_at<n##8>(x), jm::detail::c_at<n##9>(x)

#define XORSTR_STRING_EXPAND_100(x)                                   \
    XORSTR_STRING_EXPAND_10(, x), XORSTR_STRING_EXPAND_10(1, x),      \
        XORSTR_STRING_EXPAND_10(2, x), XORSTR_STRING_EXPAND_10(3, x), \
        XORSTR_STRING_EXPAND_10(4, x), XORSTR_STRING_EXPAND_10(5, x), \
        XORSTR_STRING_EXPAND_10(6, x), XORSTR_STRING_EXPAND_10(7, x), \
        XORSTR_STRING_EXPAND_10(8, x), XORSTR_STRING_EXPAND_10(9, x)

#define XORSTR_STR(s)                                     \
    ::jm::detail::string_builder<                         \
        std::decay_t<decltype(*s)>,                       \
        jm::detail::tstring_<std::decay_t<decltype(*s)>>, \
        XORSTR_STRING_EXPAND_100(s)>::type

// disable constant overflow warnings
#ifdef _MSC_VER
#pragma warning(push)
#pragma warning(disable : 4309)
#pragma warning(disable : 4307)
#endif

namespace jm {

    namespace detail {

        template<std::size_t I, std::size_t M, class T>
        constexpr T c_at(const T (&str)[M]) noexcept
        {
            static_assert(M <= 99, "string too large.");
            return (I < M) ? str[I] : 0;
        }

        template<class T, class B, T...>
        struct string_builder;

        template<class T, class B>
        struct string_builder<T, B> {
            using type = B;
        };

        template<class T, template<class, T...> class S, T... Hs, T C, T... Cs>
        struct string_builder<T, S<T, Hs...>, C, Cs...>
            : std::conditional<C == T(0),
                               string_builder<T, S<T, Hs...>>,
                               string_builder<T, S<T, Hs..., C>, Cs...>>::type {
        };

        template<class T, T... Cs>
        struct tstring_ {
            using value_type                           = T;
            constexpr static std::size_t size          = sizeof...(Cs);
            constexpr static value_type  str[size + 1] = { Cs..., '\0' };

            constexpr static std::size_t size_in_bytes() noexcept
            {
                return (size + 1) * sizeof(value_type);
            }
        };

        constexpr std::uint64_t rng_seed() noexcept
        {
            std::uint64_t shifted = 0ull;
            for (int i = 0; i < 8; ++i) {
                shifted <<= 8;
                shifted |= __TIME__[i];
            }
            return shifted;
        }

        template<std::uint64_t S>
        constexpr std::uint32_t pcg32() noexcept
        {
            constexpr auto seed       = rng_seed();
            constexpr auto oldstate   = S * 6364136223846793005ull + (seed | 1);
            std::uint32_t  xorshifted = static_cast<std::uint32_t>(
                ((oldstate >> 18u) ^ oldstate) >> 27u);
            std::uint32_t rot = oldstate >> 59u;
            return (xorshifted >> rot) | (xorshifted << ((1u + ~rot) & 31));
        }

        template<std::size_t S>
        constexpr std::uint64_t key8()
        {
            return (static_cast<std::uint64_t>(detail::pcg32<S>()) << 32) |
                   detail::pcg32<S + 85>();
        }

        template<class T>
        constexpr std::size_t buffer_size()
        {
            constexpr auto x = T::size_in_bytes() / 16;
            return x * 2 + ((T::size_in_bytes() - x * 16) % 16 != 0) * 2;
        }

        // clang and gcc try really hard to place the constants in data
        // sections. to counter that there was a need to create an intermediate
        // constexpr string and then copy it into a non constexpr container with
        // volatile storage so that the constants would be placed directly into
        // code.
        template<class T>
        struct string_storage {
            std::uint64_t storage[buffer_size<T>()];

            template<std::size_t N = 0>
            XORSTR_FORCEINLINE constexpr void _xor()
            {
                if constexpr (N != detail::buffer_size<T>()) {
                    constexpr auto key = key8<N>();
                    storage[N] ^= key;
                    _xor<N + 1>();
                }
            }

            XORSTR_FORCEINLINE constexpr string_storage() : storage{ 0 }
            {
                // puts the string into 64 bit integer blocks in a constexpr
                // fashion
                for (std::size_t i = 0; i < T::size; ++i)
                    storage[i / (8 / sizeof(typename T::value_type))] |=
                        (std::uint64_t(T::str[i])
                         << ((i % (8 / sizeof(typename T::value_type))) * 8 *
                             sizeof(typename T::value_type)));
                // applies the xor encryption
                _xor<0>();
            }
        };

    } // namespace detail

    template<class T>
    struct xor_string {
        XORSTR_VOLATILE std::uint64_t _storage[detail::buffer_size<T>()];

        template<std::size_t N>
        XORSTR_FORCEINLINE void _crypt() noexcept
        {
            if constexpr (detail::buffer_size<T>() > N) {
#ifndef JM_XORSTR_DISABLE_AVX_INTRINSICS
                if constexpr ((detail::buffer_size<T>() - N) >= 4) {
                    // assignments are separate on purpose. Do not replace with
                    // = { ... }
                    XORSTR_CLANG_VOLATILE std::uint64_t keys[4];
                    keys[0] = detail::key8<N + 0>();
                    keys[1] = detail::key8<N + 1>();
                    keys[2] = detail::key8<N + 2>();
                    keys[3] = detail::key8<N + 3>();

                    *(__m256i*)(&_storage[N]) = _mm256_xor_si256(
                        *(__m256i*)(&_storage[N]), *(const __m256i*)(&keys));
                    _crypt<N + 4>();
                }
                else 
#endif
                {
                    XORSTR_VOLATILE std::uint64_t keys[2];
                    keys[0] = detail::key8<N + 0>();
                    keys[1] = detail::key8<N + 1>();

                    *(__m128i*)(&_storage[N]) = _mm_xor_si128(
                        *(__m128i*)(&_storage[N]), *(const __m128i*)(&keys));
                    _crypt<N + 2>();
                }
            }
        }

        template<std::size_t N>
        XORSTR_FORCEINLINE constexpr static std::uint64_t _at()
        {
            // forces compile time evaluation of storage for access
            return std::integral_constant<
                std::uint64_t,
                detail::string_storage<T>{}.storage[N]>::value;
        }

        // loop generates vectorized code which places constants in data dir
        template<std::size_t N>
        void _copy() noexcept
        {
            if constexpr (detail::buffer_size<T>() > N) {
                _storage[N]     = _at<N>();
                _storage[N + 1] = _at<N + 1>();
                _copy<N + 2>();
            }
        }

    public:
        using value_type    = typename T::value_type;
        using size_type     = std::size_t;
        using pointer       = value_type*;
        using const_pointer = const pointer;

        XORSTR_FORCEINLINE xor_string() noexcept { _copy<0>(); }

        constexpr size_type size() const noexcept { return T::size - 1; }

        XORSTR_FORCEINLINE void crypt() noexcept { _crypt<0>(); }

        XORSTR_FORCEINLINE const_pointer get() const noexcept
        {
            return _storage;
        }

        XORSTR_FORCEINLINE const_pointer crypt_get() noexcept
        {
            crypt();
            // C casts are used because buffer may or may not be volatile
            return (const_pointer)(_storage);
        }
    };

} // namespace jm

#ifdef _MSC_VER
#pragma warning(pop)
#endif

#endif // include guard

```

`EntryPointCryptor/EntryPointCryptor.cpp`:

```cpp
// EntryPointCryptor.cpp: определяет точку входа для консольного приложения.
//

#include "stdafx.h"

#include <locale>
#include <codecvt>
#include <string>

#include "PEAnalyzer.h"

typedef struct _MAPPING_INFO {
	HANDLE hFile;
	HANDLE hMapping;
	PVOID Memory;
	ULONG Size;
} MAPPING_INFO, *PMAPPING_INFO;

BOOL MapFile(IN LPWSTR Path, OUT PMAPPING_INFO Mapping) {
	if (Mapping == NULL) return FALSE;
	ZeroMemory(Mapping, sizeof(*Mapping));

	Mapping->hFile = CreateFile(
		Path, 
		GENERIC_READ | GENERIC_WRITE, 
		FILE_SHARE_READ | FILE_SHARE_WRITE, 
		NULL, 
		OPEN_EXISTING, 
		FILE_ATTRIBUTE_NORMAL, 
		NULL
	);

	if (Mapping->hFile == INVALID_HANDLE_VALUE) return NULL;

	Mapping->Size = GetFileSize(Mapping->hFile, NULL);
	Mapping->hMapping = CreateFileMapping(Mapping->hFile, NULL, PAGE_READWRITE, 0, Mapping->Size, NULL);
	if (Mapping->hMapping == NULL) goto CreateMappingError;

	Mapping->Memory = MapViewOfFile(Mapping->hMapping, FILE_MAP_ALL_ACCESS, 0, 0, 0);
	if (Mapping->Memory == NULL) goto MappingError;

	return TRUE;

MappingError:
	CloseHandle(Mapping->hMapping);

CreateMappingError:
	CloseHandle(Mapping->hFile);
	ZeroMemory(Mapping, sizeof(*Mapping));
	return FALSE;
}

VOID UnmapFile(IN PMAPPING_INFO Mapping) {
	if (Mapping == NULL) return;
	if (Mapping->Memory) {
		FlushViewOfFile(Mapping->Memory, Mapping->Size);
		UnmapViewOfFile(Mapping->Memory);
	}
	if (Mapping->hMapping != NULL && Mapping->hMapping != INVALID_HANDLE_VALUE) CloseHandle(Mapping->hMapping);
	if (Mapping->hFile != NULL && Mapping->hFile != INVALID_HANDLE_VALUE) CloseHandle(Mapping->hFile);
	ZeroMemory(Mapping, sizeof(*Mapping));
}

int main(int argc, char* argv[]) {
	if (argc != 2) {
		printf("Please, specify the file path!\r\n");
		return 0;
	}
	
	std::wstring_convert<std::codecvt_utf8_utf16<wchar_t>> converter;
	std::wstring path = converter.from_bytes(argv[1]);

	MAPPING_INFO MappingInfo = { 0 };
	if (!MapFile((LPWSTR)path.c_str(), &MappingInfo)) {
		printf("Unable to map file: %ws\r\n", path.c_str());
		return 0;
	}

	PEAnalyzer pe((HMODULE)MappingInfo.Memory, TRUE);

	SIZE_T EntryPointRva = (SIZE_T)pe.GetEntryPoint() - (SIZE_T)pe.GetImageBase();
	SIZE_T EntryPointRawOffset = pe.Rva2Offset(EntryPointRva);
	PULONGLONG EntryPoint = (PULONGLONG)((SIZE_T)MappingInfo.Memory + EntryPointRawOffset);
 	*EntryPoint ^= 0x1EE7C0DEC0FFEE;

	printf("Successfully XOR'ed!\r\n");

	UnmapFile(&MappingInfo);

    return 0;
}


```

`EntryPointCryptor/EntryPointCryptor.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" ToolsVersion="15.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|Win32">
      <Configuration>Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <VCProjectVersion>15.0</VCProjectVersion>
    <ProjectGuid>{95B79E39-F7D6-45ED-8DD8-1D2C14188086}</ProjectGuid>
    <Keyword>Win32Proj</Keyword>
    <RootNamespace>EntryPointCryptor</RootNamespace>
    <WindowsTargetPlatformVersion>10.0.17134.0</WindowsTargetPlatformVersion>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v141</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v141</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v141</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v141</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="Shared">
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <LinkIncremental>true</LinkIncremental>
    <IncludePath>$(SolutionDir)\Avanguard\AvanguardDefence;$(IncludePath)</IncludePath>
    <SourcePath>$(SolutionDir)\Avanguard\AvanguardDefence;$(VC_SourcePath)</SourcePath>
    <IntDir>$(Platform)\$(Configuration)\Bin\$(ProjectName)</IntDir>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <LinkIncremental>true</LinkIncremental>
    <IncludePath>$(SolutionDir)\Avanguard\AvanguardDefence;$(IncludePath)</IncludePath>
    <SourcePath>$(SolutionDir)\Avanguard\AvanguardDefence;$(VC_SourcePath)</SourcePath>
    <IntDir>$(Platform)\$(Configuration)\Bin\$(ProjectName)\</IntDir>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <LinkIncremental>false</LinkIncremental>
    <IncludePath>$(SolutionDir)\Avanguard\AvanguardDefence;$(IncludePath)</IncludePath>
    <SourcePath>$(SolutionDir)\Avanguard\AvanguardDefence;$(VC_SourcePath)</SourcePath>
    <IntDir>$(Platform)\$(Configuration)\Bin\$(ProjectName)</IntDir>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <LinkIncremental>false</LinkIncremental>
    <IncludePath>$(SolutionDir)\Avanguard\AvanguardDefence;$(IncludePath)</IncludePath>
    <SourcePath>$(SolutionDir)\Avanguard\AvanguardDefence;$(VC_SourcePath)</SourcePath>
    <IntDir>$(Platform)\$(Configuration)\Bin\$(ProjectName)</IntDir>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <ClCompile>
      <PrecompiledHeader>Use</PrecompiledHeader>
      <WarningLevel>Level3</WarningLevel>
      <Optimization>Disabled</Optimization>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>WIN32;_DEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <RuntimeLibrary>MultiThreadedDebug</RuntimeLibrary>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <ClCompile>
      <PrecompiledHeader>Use</PrecompiledHeader>
      <WarningLevel>Level3</WarningLevel>
      <Optimization>Disabled</Optimization>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>_DEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <RuntimeLibrary>MultiThreadedDebug</RuntimeLibrary>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <ClCompile>
      <PrecompiledHeader>Use</PrecompiledHeader>
      <WarningLevel>Level3</WarningLevel>
      <Optimization>MaxSpeed</Optimization>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>WIN32;NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <RuntimeLibrary>MultiThreaded</RuntimeLibrary>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <ClCompile>
      <PrecompiledHeader>Use</PrecompiledHeader>
      <WarningLevel>Level3</WarningLevel>
      <Optimization>MaxSpeed</Optimization>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <RuntimeLibrary>MultiThreaded</RuntimeLibrary>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemGroup>
    <ClInclude Include="..\Avanguard\AvanguardDefence\PEAnalyzer.h" />
    <ClInclude Include="stdafx.h" />
    <ClInclude Include="targetver.h" />
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="..\Avanguard\AvanguardDefence\PEAnalyzer.cpp" />
    <ClCompile Include="EntryPointCryptor.cpp" />
    <ClCompile Include="stdafx.cpp">
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">Create</PrecompiledHeader>
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">Create</PrecompiledHeader>
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">Create</PrecompiledHeader>
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Release|x64'">Create</PrecompiledHeader>
    </ClCompile>
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>
```

`EntryPointCryptor/EntryPointCryptor.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="Исходные файлы">
      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
      <Extensions>cpp;c;cc;cxx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
    </Filter>
    <Filter Include="Файлы заголовков">
      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
      <Extensions>h;hh;hpp;hxx;hm;inl;inc;xsd</Extensions>
    </Filter>
    <Filter Include="Файлы ресурсов">
      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav;mfcribbon-ms</Extensions>
    </Filter>
    <Filter Include="PEAnalyzer">
      <UniqueIdentifier>{f449858a-c831-492c-9c2b-ed6f69f05574}</UniqueIdentifier>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="stdafx.h">
      <Filter>Файлы заголовков</Filter>
    </ClInclude>
    <ClInclude Include="targetver.h">
      <Filter>Файлы заголовков</Filter>
    </ClInclude>
    <ClInclude Include="..\Avanguard\AvanguardDefence\PEAnalyzer.h">
      <Filter>PEAnalyzer</Filter>
    </ClInclude>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="stdafx.cpp">
      <Filter>Исходные файлы</Filter>
    </ClCompile>
    <ClCompile Include="EntryPointCryptor.cpp">
      <Filter>Исходные файлы</Filter>
    </ClCompile>
    <ClCompile Include="..\Avanguard\AvanguardDefence\PEAnalyzer.cpp">
      <Filter>PEAnalyzer</Filter>
    </ClCompile>
  </ItemGroup>
</Project>
```

`EntryPointCryptor/stdafx.cpp`:

```cpp
// stdafx.cpp: исходный файл, содержащий только стандартные включаемые модули
// EntryPointCryptor.pch будет использоваться в качестве предкомпилированного заголовка
// stdafx.obj будет содержать предварительно откомпилированные сведения о типе

#include "stdafx.h"

// TODO: Установите ссылки на любые требующиеся дополнительные заголовки в файле STDAFX.H
// , а не в данном файле

```

`EntryPointCryptor/stdafx.h`:

```h
// stdafx.h: включаемый файл для стандартных системных включаемых файлов
// или включаемых файлов для конкретного проекта, которые часто используются, но
// не часто изменяются
//

#pragma once

#include "targetver.h"

#include <stdio.h>
#include <tchar.h>



// TODO: Установите здесь ссылки на дополнительные заголовки, требующиеся для программы

```

`EntryPointCryptor/targetver.h`:

```h
#pragma once

// Включение SDKDDKVer.h обеспечивает определение самой последней доступной платформы Windows.

// Если требуется выполнить сборку приложения для предыдущей версии Windows, включите WinSDKVer.h и
// задайте для макроса _WIN32_WINNT значение поддерживаемой платформы перед включением SDKDDKVer.h.

#include <SDKDDKVer.h>

```

`README.md`:

```md
# Avanguard
## The Win32 Anti-Intrusion Library  
### This library prevents some of injection techniques, debugging and static analyzing.  
Both x32 and x64 supports and includes:
* Static code encryptor
* Many anti-debugging techniques (WinAPI, NativeAPI, SEH, assembler and memory tricks)
* PE Analyzer
* Memory analyzer
* Call-stack analyzer
* Anti-injection techinques (against of CreateRemoteThread, manual modules mapping, injection through APC, windows hooks, AppInit_DLLs and context switching)
* Memory protection (kernel callbacks, modules remapping)
* Anti-splicing (modules executable sections and imports table verifying)
* Anti-macros (virtual keyboard and mouse input - useful for online games)
* Kernel modules info
* Threads and modules callbacks
* Handles keeper - prevents managing your app from other processes due to close handles of your process in external apps (for example, CheatEngine or another memory editors)
* Support of self-modified code
* TLS support
* DACLs support
* HWIDs collector
* Code-signing certificates and system files checkings
* API for external calls of defence functions

### Using
All you need is to load Avanguard.dll as soon as possible.  
It collects all information about consistence of process, sets up the memory, threads, APCs and modules filters and starts up the protection.  
  
You can use the AvnApi in C++ or any other native language using this code:  
```
#include "AvnApi.h"

HMODULE hAvn = GetModuleHandle(L"Avanguard.dll");
PAVN_API AvnApi = *(PAVN_API*)GetProcAddress(hAvn, "Stub");

AvnApi->Lock();
BOOL IsModuleValid = AvnApi->AvnIsModuleValid(hAvn);
// ... Other AvnApi calls ...
AvnApi->Unlock();
```
If you use the self-modification of modules in your code, you should use this snippet:
```
AvnApi->Lock();
// ... Module modification ...
AvnApi->AvnRehashModule(hChangedModule);
AvnApi->Unlock();
```
You should always use the _Lock()_/_Unlock()_ to AvnApi calls!  
  
Java bindings:
```
public class Main {
    public static void main(String[] args) {
        AvnBind.avnRegisterThreatNotifier((int threatType) -> {
            System.out.println("Threat " + AvnBind.ThreatType.getThreat(threatType).name());
            return true;
        });

        AvnBind.avnEliminateThreat(AvnBind.ThreatType.UNKNOWN_APC_DESTINATION.getValue());

        AvnBind.avnRegisterThreatNotifier(null);
        AvnBind.avnEliminateThreat(AvnBind.ThreatType.UNKNOWN_APC_DESTINATION.getValue());
    }
}
```
Note, that you shall not rename the package name!  
  
C# bindings:
```
using ...;
using AvnApi;

namespace AvnSample
{
    class Program
    {
        static void Main(string[] args)
        {
            AvnApi.AvnApi.Load(@"Avanguard.dll");
            AvnApi.AvnApi.API.AvnStart();
            while (true) ;
        }
    }
}
```
```

`SomeExternalDll/Exports.def`:

```def
LIBRARY SomeExternalDll
EXPORTS
	HookEmAll
	UnHookEmAll

```

`SomeExternalDll/SomeExternalDll.cpp`:

```cpp
#include "stdafx.h"

extern HMODULE hInstance;

HHOOK hHook = NULL;

LRESULT CALLBACK HookProc(int Code, WPARAM wParam, LPARAM lParam) {
	return CallNextHookEx(hHook, Code, wParam, lParam);
}

VOID WINAPI HookEmAll() {
	if (hHook) return;
	hHook = SetWindowsHookEx(WH_DEBUG, HookProc, hInstance, 0);
}

VOID WINAPI UnHookEmAll() {
	if (hHook == NULL) return;
	if (UnhookWindowsHookEx(hHook)) hHook = NULL;
}
```

`SomeExternalDll/SomeExternalDll.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" ToolsVersion="15.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|Win32">
      <Configuration>Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <VCProjectVersion>15.0</VCProjectVersion>
    <ProjectGuid>{209EF3F6-482C-488B-A5CF-5BF8CD637DE6}</ProjectGuid>
    <Keyword>Win32Proj</Keyword>
    <RootNamespace>SomeExternalDll</RootNamespace>
    <WindowsTargetPlatformVersion>10.0.17134.0</WindowsTargetPlatformVersion>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
    <ConfigurationType>DynamicLibrary</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v141</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
    <ConfigurationType>DynamicLibrary</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v141</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <ConfigurationType>DynamicLibrary</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v141</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <ConfigurationType>DynamicLibrary</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v141</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="Shared">
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <LinkIncremental>true</LinkIncremental>
    <IntDir>$(Platform)\$(Configuration)\Bin\$(ProjectName)\</IntDir>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <LinkIncremental>true</LinkIncremental>
    <IntDir>$(Platform)\$(Configuration)\Bin\$(ProjectName)</IntDir>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <LinkIncremental>false</LinkIncremental>
    <IntDir>$(Platform)\$(Configuration)\Bin\$(ProjectName)</IntDir>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <LinkIncremental>false</LinkIncremental>
    <IntDir>$(Platform)\$(Configuration)\Bin\$(ProjectName)</IntDir>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <ClCompile>
      <PrecompiledHeader>Use</PrecompiledHeader>
      <WarningLevel>Level3</WarningLevel>
      <Optimization>Disabled</Optimization>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>_DEBUG;SOMEEXTERNALDLL_EXPORTS;_WINDOWS;_USRDLL;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <RuntimeLibrary>MultiThreaded</RuntimeLibrary>
      <AdditionalOptions>/FS %(AdditionalOptions)</AdditionalOptions>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <ModuleDefinitionFile>Exports.def</ModuleDefinitionFile>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <ClCompile>
      <PrecompiledHeader>Use</PrecompiledHeader>
      <WarningLevel>Level3</WarningLevel>
      <Optimization>Disabled</Optimization>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>WIN32;_DEBUG;SOMEEXTERNALDLL_EXPORTS;_WINDOWS;_USRDLL;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <RuntimeLibrary>MultiThreaded</RuntimeLibrary>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <ModuleDefinitionFile>Exports.def</ModuleDefinitionFile>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <ClCompile>
      <PrecompiledHeader>Use</PrecompiledHeader>
      <WarningLevel>Level3</WarningLevel>
      <Optimization>MaxSpeed</Optimization>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>WIN32;NDEBUG;SOMEEXTERNALDLL_EXPORTS;_WINDOWS;_USRDLL;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <RuntimeLibrary>MultiThreaded</RuntimeLibrary>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <ModuleDefinitionFile>Exports.def</ModuleDefinitionFile>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <ClCompile>
      <PrecompiledHeader>Use</PrecompiledHeader>
      <WarningLevel>Level3</WarningLevel>
      <Optimization>MaxSpeed</Optimization>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>NDEBUG;SOMEEXTERNALDLL_EXPORTS;_WINDOWS;_USRDLL;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <RuntimeLibrary>MultiThreaded</RuntimeLibrary>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <ModuleDefinitionFile>Exports.def</ModuleDefinitionFile>
    </Link>
  </ItemDefinitionGroup>
  <ItemGroup>
    <ClInclude Include="stdafx.h" />
    <ClInclude Include="targetver.h" />
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="dllmain.cpp" />
    <ClCompile Include="SomeExternalDll.cpp" />
    <ClCompile Include="stdafx.cpp">
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">Create</PrecompiledHeader>
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">Create</PrecompiledHeader>
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">Create</PrecompiledHeader>
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Release|x64'">Create</PrecompiledHeader>
    </ClCompile>
  </ItemGroup>
  <ItemGroup>
    <None Include="Exports.def" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>
```

`SomeExternalDll/SomeExternalDll.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="Исходные файлы">
      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
      <Extensions>cpp;c;cc;cxx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
    </Filter>
    <Filter Include="Файлы заголовков">
      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
      <Extensions>h;hh;hpp;hxx;hm;inl;inc;xsd</Extensions>
    </Filter>
    <Filter Include="Файлы ресурсов">
      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav;mfcribbon-ms</Extensions>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="stdafx.h">
      <Filter>Файлы заголовков</Filter>
    </ClInclude>
    <ClInclude Include="targetver.h">
      <Filter>Файлы заголовков</Filter>
    </ClInclude>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="stdafx.cpp">
      <Filter>Исходные файлы</Filter>
    </ClCompile>
    <ClCompile Include="SomeExternalDll.cpp">
      <Filter>Исходные файлы</Filter>
    </ClCompile>
    <ClCompile Include="dllmain.cpp">
      <Filter>Исходные файлы</Filter>
    </ClCompile>
  </ItemGroup>
  <ItemGroup>
    <None Include="Exports.def">
      <Filter>Файлы ресурсов</Filter>
    </None>
  </ItemGroup>
</Project>
```

`SomeExternalDll/dllmain.cpp`:

```cpp
#include "stdafx.h"

HMODULE hInstance;

BOOL APIENTRY DllMain(
	HMODULE		hModule,
	DWORD		dwReason,
	PCONTEXT	lpContext
) {
	if (dwReason == DLL_PROCESS_ATTACH) {
		hInstance = hModule;
	}

	return TRUE;
}
```

`SomeExternalDll/stdafx.cpp`:

```cpp
// stdafx.cpp: исходный файл, содержащий только стандартные включаемые модули
// SomeExternalDll.pch будет использоваться в качестве предкомпилированного заголовка
// stdafx.obj будет содержать предварительно откомпилированные сведения о типе

#include "stdafx.h"

// TODO: Установите ссылки на любые требующиеся дополнительные заголовки в файле STDAFX.H
// , а не в данном файле

```

`SomeExternalDll/stdafx.h`:

```h
// stdafx.h: включаемый файл для стандартных системных включаемых файлов
// или включаемых файлов для конкретного проекта, которые часто используются, но
// не часто изменяются
//

#pragma once

#include "targetver.h"

#define WIN32_LEAN_AND_MEAN             // Исключите редко используемые компоненты из заголовков Windows
// Файлы заголовков Windows:
#include <windows.h>

#include <stdio.h>

// TODO: Установите здесь ссылки на дополнительные заголовки, требующиеся для программы

```

`SomeExternalDll/targetver.h`:

```h
#pragma once

// Включение SDKDDKVer.h обеспечивает определение самой последней доступной платформы Windows.

// Если требуется выполнить сборку приложения для предыдущей версии Windows, включите WinSDKVer.h и
// задайте для макроса _WIN32_WINNT значение поддерживаемой платформы перед включением SDKDDKVer.h.

#include <SDKDDKVer.h>

```