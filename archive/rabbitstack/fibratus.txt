Project Path: arc_rabbitstack_fibratus_u9_79d3r

Source Tree:

```txt
arc_rabbitstack_fibratus_u9_79d3r
├── CODE_OF_CONDUCT.md
├── CONTRIBUTING.md
├── LICENSE.MD
├── README.md
├── build
│   └── msi
│       ├── LICENSE.rtf
│       ├── background.png
│       ├── banner.png
│       ├── fibratus.ico
│       └── fibratus.wxs
├── cmd
│   ├── fibratus
│   │   ├── app
│   │   │   ├── capture
│   │   │   │   └── capture_windows.go
│   │   │   ├── config
│   │   │   │   └── config.go
│   │   │   ├── docs.go
│   │   │   ├── list
│   │   │   │   └── list.go
│   │   │   ├── replay
│   │   │   │   └── replay_windows.go
│   │   │   ├── root.go
│   │   │   ├── rules
│   │   │   │   ├── create.go
│   │   │   │   ├── list.go
│   │   │   │   ├── rules.go
│   │   │   │   └── validate.go
│   │   │   ├── run_windows.go
│   │   │   ├── service
│   │   │   │   ├── control_service_windows.go
│   │   │   │   ├── install_service_windows.go
│   │   │   │   ├── remove_service_windows.go
│   │   │   │   └── status_service_windows.go
│   │   │   ├── stats
│   │   │   │   └── stats.go
│   │   │   └── version.go
│   │   ├── fibratus.exe.manifest
│   │   ├── fibratus.ico
│   │   ├── fibratus.rc
│   │   ├── main_windows.go
│   │   └── version.h
│   └── systray
│       ├── fibratus-systray.exe.manifest
│       ├── fibratus-systray.rc
│       ├── fibratus.ico
│       ├── main_windows.go
│       └── version.h
├── configs
│   ├── fibratus.json
│   └── fibratus.yml
├── docs
│   ├── CNAME
│   ├── README.md
│   ├── _coverpage.md
│   ├── _sidebar.md
│   ├── alerts
│   │   ├── filaments.md
│   │   ├── introduction.md
│   │   ├── senders
│   │   │   ├── eventlog.md
│   │   │   ├── images
│   │   │   │   └── eventlog.gif
│   │   │   ├── mail.md
│   │   │   ├── slack.md
│   │   │   └── systray.md
│   │   └── senders.md
│   ├── captures
│   │   ├── capturing.md
│   │   ├── introduction.md
│   │   └── replaying.md
│   ├── filaments
│   │   ├── executing.md
│   │   ├── internals.md
│   │   ├── introduction.md
│   │   └── writing.md
│   ├── filters
│   │   ├── fields.md
│   │   ├── filtering.md
│   │   ├── functions.md
│   │   ├── images
│   │   │   └── rule-alert.png
│   │   ├── introduction.md
│   │   ├── iterators.md
│   │   ├── operators.md
│   │   ├── prefiltering.md
│   │   └── rules.md
│   ├── images
│   │   ├── fibratus-term.gif
│   │   └── fibratus-term.png
│   ├── index.html
│   ├── kevents
│   │   ├── anatomy.md
│   │   ├── driver.md
│   │   ├── file.md
│   │   ├── handle.md
│   │   ├── image.md
│   │   ├── mem.md
│   │   ├── network.md
│   │   ├── object.md
│   │   ├── process.md
│   │   ├── registry.md
│   │   └── thread.md
│   ├── logo.png
│   ├── nav.md
│   ├── outputs
│   │   ├── console.md
│   │   ├── elasticsearch.md
│   │   ├── eventlog.md
│   │   ├── http.md
│   │   ├── images
│   │   │   ├── eventlog-details.png
│   │   │   └── eventlog-general.png
│   │   ├── introduction.md
│   │   ├── null.md
│   │   └── rabbitmq.md
│   ├── overview
│   │   └── what-is-fibratus.md
│   ├── pe
│   │   ├── introduction.md
│   │   ├── resources.md
│   │   ├── sections.md
│   │   └── symbols.md
│   ├── setup
│   │   ├── cli.md
│   │   ├── configuration.md
│   │   ├── images
│   │   │   └── fibratus-msi.png
│   │   ├── installation.md
│   │   └── quick-start.md
│   ├── themes
│   │   └── fibratus.css
│   ├── transformers
│   │   ├── introduction.md
│   │   ├── remove.md
│   │   ├── rename.md
│   │   ├── replace.md
│   │   ├── tags.md
│   │   └── trim.md
│   ├── troubleshooting
│   │   ├── logs.md
│   │   ├── pprof.md
│   │   └── stats.md
│   └── yara
│       ├── alerts.md
│       ├── introduction.md
│       └── scanning.md
├── filaments
│   ├── README.md
│   ├── top_in_packets.py
│   ├── top_keys.py
│   ├── top_out_packets.py
│   ├── utils
│   │   └── dotdict.py
│   └── watch_files.py
├── go.mod
├── go.sum
├── internal
│   ├── bootstrap
│   │   ├── bootstrap.go
│   │   ├── config.go
│   │   └── source.go
│   ├── etw
│   │   ├── _fixtures
│   │   │   ├── Taskfile.yml
│   │   │   ├── direct-syscall
│   │   │   │   ├── Makefile.msvc
│   │   │   │   └── main.c
│   │   │   ├── indirect-syscall
│   │   │   │   ├── Makefile.msvc
│   │   │   │   └── main.c
│   │   │   ├── mscorlib.dll
│   │   │   └── yara-test.dll
│   │   ├── consumer.go
│   │   ├── processors
│   │   │   ├── chain.go
│   │   │   ├── chain_windows.go
│   │   │   ├── fs_windows.go
│   │   │   ├── fs_windows_test.go
│   │   │   ├── handle_windows.go
│   │   │   ├── handle_windows_test.go
│   │   │   ├── image_windows.go
│   │   │   ├── image_windows_test.go
│   │   │   ├── mem_windows.go
│   │   │   ├── mem_windows_test.go
│   │   │   ├── net_windows.go
│   │   │   ├── net_windows_test.go
│   │   │   ├── processor.go
│   │   │   ├── ps_windows.go
│   │   │   ├── ps_windows_test.go
│   │   │   ├── registry_windows.go
│   │   │   └── registry_windows_test.go
│   │   ├── source.go
│   │   ├── source_test.go
│   │   ├── stackext.go
│   │   ├── stackext_test.go
│   │   ├── trace.go
│   │   └── trace_test.go
│   └── evasion
│       ├── config.go
│       ├── direct_syscall.go
│       ├── direct_syscall_test.go
│       ├── indirect_syscall.go
│       ├── indirect_syscall_test.go
│       ├── scanner.go
│       ├── scanner_test.go
│       └── types.go
├── logo.png
├── make.bat
├── pkg
│   ├── aggregator
│   │   ├── aggregator.go
│   │   ├── aggregator_test.go
│   │   ├── config.go
│   │   ├── submitter.go
│   │   ├── transformers
│   │   │   ├── config.go
│   │   │   ├── remove
│   │   │   │   ├── config.go
│   │   │   │   ├── remove.go
│   │   │   │   └── remove_test.go
│   │   │   ├── rename
│   │   │   │   ├── config.go
│   │   │   │   ├── rename.go
│   │   │   │   └── rename_test.go
│   │   │   ├── replace
│   │   │   │   ├── config.go
│   │   │   │   ├── replace.go
│   │   │   │   └── replace_test.go
│   │   │   ├── tags
│   │   │   │   ├── config.go
│   │   │   │   ├── tags.go
│   │   │   │   └── tags_test.go
│   │   │   ├── transformer.go
│   │   │   └── trim
│   │   │       ├── config.go
│   │   │       ├── trim.go
│   │   │       └── trim_test.go
│   │   ├── worker.go
│   │   └── worker_test.go
│   ├── alertsender
│   │   ├── alert.go
│   │   ├── alert_test.go
│   │   ├── config.go
│   │   ├── eventlog
│   │   │   ├── config.go
│   │   │   ├── eventlog.go
│   │   │   └── eventlog_test.go
│   │   ├── mail
│   │   │   ├── config.go
│   │   │   ├── mail.go
│   │   │   ├── renderer.go
│   │   │   ├── renderer_test.go
│   │   │   └── template.go
│   │   ├── sender.go
│   │   ├── slack
│   │   │   ├── config.go
│   │   │   └── slack.go
│   │   └── systray
│   │       ├── _fixtures
│   │       │   └── fibratus.ico
│   │       ├── config.go
│   │       ├── systray.go
│   │       └── systray_test.go
│   ├── api
│   │   ├── handler
│   │   │   └── config.go
│   │   ├── listener.go
│   │   ├── server.go
│   │   └── server_windows.go
│   ├── callstack
│   │   ├── callstack.go
│   │   └── callstack_test.go
│   ├── cap
│   │   ├── _fixtures
│   │   │   ├── cap.cap
│   │   │   ├── cap1.cap
│   │   │   └── cap2.cap
│   │   ├── config.go
│   │   ├── header.go
│   │   ├── reader.go
│   │   ├── reader_unsupported.go
│   │   ├── reader_windows.go
│   │   ├── reader_windows_test.go
│   │   ├── section
│   │   │   ├── section.go
│   │   │   ├── section_windows.go
│   │   │   └── section_windows_test.go
│   │   ├── types_linux.go
│   │   ├── types_windows.go
│   │   ├── version
│   │   │   └── version_windows.go
│   │   ├── writer.go
│   │   ├── writer_unsupported.go
│   │   ├── writer_windows.go
│   │   └── writer_windows_test.go
│   ├── config
│   │   ├── _fixtures
│   │   │   ├── eventlog-output.yml
│   │   │   ├── fibratus.json
│   │   │   ├── fibratus.yml
│   │   │   ├── filters
│   │   │   │   ├── default-with-template.yml
│   │   │   │   ├── default.yml
│   │   │   │   └── default1.yml
│   │   │   ├── http-output.yml
│   │   │   ├── output.yml
│   │   │   └── transformers.yml
│   │   ├── alertsender.go
│   │   ├── api.go
│   │   ├── config.schema.json
│   │   ├── config_windows.go
│   │   ├── config_windows_test.go
│   │   ├── decoder.go
│   │   ├── eventsource.go
│   │   ├── eventsource_test.go
│   │   ├── filament.go
│   │   ├── filters.go
│   │   ├── filters_test.go
│   │   ├── macros.schema.json
│   │   ├── output.go
│   │   ├── output_test.go
│   │   ├── print.go
│   │   ├── print_test.go
│   │   ├── rules.schema.json
│   │   ├── schema_windows.go
│   │   ├── transformer.go
│   │   ├── transformer_test.go
│   │   ├── validation.go
│   │   └── validation_test.go
│   ├── errors
│   │   ├── errors.go
│   │   └── errors_windows.go
│   ├── event
│   │   ├── _fixtures
│   │   │   └── handles.json
│   │   ├── batch.go
│   │   ├── batch_test.go
│   │   ├── bitset.go
│   │   ├── bitset_test.go
│   │   ├── category.go
│   │   ├── doc.go
│   │   ├── enum.go
│   │   ├── event.go
│   │   ├── event_windows.go
│   │   ├── event_windows_test.go
│   │   ├── flags.go
│   │   ├── flags_test.go
│   │   ├── formatter.go
│   │   ├── formatter_test.go
│   │   ├── formatter_windows.go
│   │   ├── marshaller.go
│   │   ├── marshaller_test.go
│   │   ├── marshaller_windows.go
│   │   ├── metainfo_windows.go
│   │   ├── metainfo_windows_test.go
│   │   ├── param.go
│   │   ├── param_test.go
│   │   ├── param_windows.go
│   │   ├── params
│   │   │   ├── params_windows.go
│   │   │   ├── types.go
│   │   │   └── types_windows.go
│   │   ├── queue.go
│   │   ├── queue_test.go
│   │   ├── sequencer_windows.go
│   │   ├── sequencer_windows_test.go
│   │   ├── stackwalk.go
│   │   ├── stackwalk_test.go
│   │   ├── template.go
│   │   ├── types_windows.go
│   │   └── types_windows_test.go
│   ├── filament
│   │   ├── _fixtures
│   │   │   ├── test_filter.py
│   │   │   ├── test_on_next_event.py
│   │   │   ├── top_hives_io.py
│   │   │   └── top_keys_io_table.py
│   │   ├── cpython
│   │   │   ├── _fixtures
│   │   │   │   └── top_hives_io.py
│   │   │   ├── api.c
│   │   │   ├── api.h
│   │   │   ├── dict.go
│   │   │   ├── dict_test.go
│   │   │   ├── errors.go
│   │   │   ├── gil.go
│   │   │   ├── gil_test.go
│   │   │   ├── interpreter.go
│   │   │   ├── interpreter_test.go
│   │   │   ├── ip.go
│   │   │   ├── module.go
│   │   │   ├── module_test.go
│   │   │   ├── object.go
│   │   │   ├── sequence.go
│   │   │   └── string.go
│   │   ├── dict.go
│   │   ├── dict_test.go
│   │   ├── filament.go
│   │   ├── filament_test.go
│   │   ├── filament_unsupported.go
│   │   ├── table.go
│   │   ├── table_test.go
│   │   └── types.go
│   ├── filter
│   │   ├── accessor.go
│   │   ├── accessor_windows.go
│   │   ├── accessor_windows_test.go
│   │   ├── fields
│   │   │   ├── fields.go
│   │   │   ├── fields_windows.go
│   │   │   └── fields_windows_test.go
│   │   ├── filter.go
│   │   ├── filter_test.go
│   │   ├── filter_windows.go
│   │   ├── ql
│   │   │   ├── ast.go
│   │   │   ├── error.go
│   │   │   ├── error_test.go
│   │   │   ├── expr.go
│   │   │   ├── function.go
│   │   │   ├── function_test.go
│   │   │   ├── functions
│   │   │   │   ├── _fixtures
│   │   │   │   │   └── yara-test.dll
│   │   │   │   ├── base.go
│   │   │   │   ├── base_test.go
│   │   │   │   ├── cidr.go
│   │   │   │   ├── cidr_test.go
│   │   │   │   ├── concat.go
│   │   │   │   ├── concat_test.go
│   │   │   │   ├── count.go
│   │   │   │   ├── count_test.go
│   │   │   │   ├── dir.go
│   │   │   │   ├── dir_test.go
│   │   │   │   ├── entropy.go
│   │   │   │   ├── entropy_test.go
│   │   │   │   ├── ext.go
│   │   │   │   ├── ext_test.go
│   │   │   │   ├── get_reg_value.go
│   │   │   │   ├── get_reg_value_test.go
│   │   │   │   ├── glob.go
│   │   │   │   ├── glob_test.go
│   │   │   │   ├── indexof.go
│   │   │   │   ├── indexof_test.go
│   │   │   │   ├── is_abs.go
│   │   │   │   ├── is_abs_test.go
│   │   │   │   ├── length.go
│   │   │   │   ├── length_test.go
│   │   │   │   ├── lower.go
│   │   │   │   ├── lower_test.go
│   │   │   │   ├── ltrim.go
│   │   │   │   ├── ltrim_test.go
│   │   │   │   ├── md5.go
│   │   │   │   ├── md5_test.go
│   │   │   │   ├── minidump.go
│   │   │   │   ├── regex.go
│   │   │   │   ├── regex_test.go
│   │   │   │   ├── replace.go
│   │   │   │   ├── replace_test.go
│   │   │   │   ├── rtrim.go
│   │   │   │   ├── rtrim_test.go
│   │   │   │   ├── split.go
│   │   │   │   ├── split_test.go
│   │   │   │   ├── substr.go
│   │   │   │   ├── substr_test.go
│   │   │   │   ├── symlink.go
│   │   │   │   ├── symlink_test.go
│   │   │   │   ├── types.go
│   │   │   │   ├── upper.go
│   │   │   │   ├── upper_test.go
│   │   │   │   ├── volume.go
│   │   │   │   ├── volume_test.go
│   │   │   │   ├── yara.go
│   │   │   │   ├── yara_test.go
│   │   │   │   └── yara_unsupported.go
│   │   │   ├── lexer.go
│   │   │   ├── lexer_test.go
│   │   │   ├── literal.go
│   │   │   ├── literal_test.go
│   │   │   ├── parser.go
│   │   │   ├── parser_test.go
│   │   │   ├── token.go
│   │   │   └── visitor.go
│   │   └── util.go
│   ├── fs
│   │   ├── _fixtures
│   │   ├── dev.go
│   │   ├── dev_test.go
│   │   ├── driver.go
│   │   ├── file.go
│   │   ├── file_class.go
│   │   ├── file_test.go
│   │   ├── ntfs
│   │   │   ├── ntfs.go
│   │   │   └── ntfs_test.go
│   │   └── types.go
│   ├── handle
│   │   ├── _fixtures
│   │   ├── alpc.go
│   │   ├── mutant.go
│   │   ├── object.go
│   │   ├── object_test.go
│   │   ├── snapshotter.go
│   │   ├── snapshotter_mock.go
│   │   ├── snapshotter_test.go
│   │   ├── timeout.go
│   │   ├── timeout_test.go
│   │   ├── types
│   │   │   ├── marshaller.go
│   │   │   ├── marshaller_test.go
│   │   │   ├── types.go
│   │   │   └── types_test.go
│   │   └── types.go
│   ├── network
│   │   ├── address.go
│   │   ├── dns.go
│   │   ├── dns_test.go
│   │   └── types.go
│   ├── outputs
│   │   ├── amqp
│   │   │   ├── _fixtures
│   │   │   │   └── garagemq
│   │   │   │       ├── README.md
│   │   │   │       ├── amqp
│   │   │   │       │   ├── constants_generated.go
│   │   │   │       │   ├── extended_constants.go
│   │   │   │       │   ├── methods_generated.go
│   │   │   │       │   ├── readers_writers.go
│   │   │   │       │   └── types.go
│   │   │   │       ├── auth
│   │   │   │       │   └── auth.go
│   │   │   │       ├── binding
│   │   │   │       │   └── binding.go
│   │   │   │       ├── config
│   │   │   │       │   ├── config.go
│   │   │   │       │   └── default.go
│   │   │   │       ├── consumer
│   │   │   │       │   └── consumer.go
│   │   │   │       ├── exchange
│   │   │   │       │   └── exchange.go
│   │   │   │       ├── interfaces
│   │   │   │       │   └── interfaces.go
│   │   │   │       ├── pool
│   │   │   │       │   └── pool.go
│   │   │   │       ├── qos
│   │   │   │       │   └── qos.go
│   │   │   │       ├── queue
│   │   │   │       │   └── queue.go
│   │   │   │       ├── safequeue
│   │   │   │       │   └── safequeue.go
│   │   │   │       └── server
│   │   │   │           ├── basicMethods.go
│   │   │   │           ├── channel.go
│   │   │   │           ├── channelMethods.go
│   │   │   │           ├── confirmMethods.go
│   │   │   │           ├── connection.go
│   │   │   │           ├── connectionMethods.go
│   │   │   │           ├── exchangeMethods.go
│   │   │   │           ├── queueMethods.go
│   │   │   │           ├── server.go
│   │   │   │           └── vhost.go
│   │   │   ├── amqp.go
│   │   │   ├── amqp_test.go
│   │   │   ├── client.go
│   │   │   └── config.go
│   │   ├── client.go
│   │   ├── config.go
│   │   ├── console
│   │   │   ├── config.go
│   │   │   └── console.go
│   │   ├── elasticsearch
│   │   │   ├── config.go
│   │   │   ├── elasticsearch.go
│   │   │   ├── elasticsearch_test.go
│   │   │   ├── index.go
│   │   │   ├── index_test.go
│   │   │   └── template.go
│   │   ├── eventlog
│   │   │   ├── api.go
│   │   │   ├── config.go
│   │   │   ├── eventlog.go
│   │   │   ├── eventlog_test.go
│   │   │   └── mc
│   │   │       └── gen.go
│   │   ├── http
│   │   │   ├── client.go
│   │   │   ├── config.go
│   │   │   ├── http.go
│   │   │   └── http_test.go
│   │   ├── null
│   │   │   ├── config.go
│   │   │   └── null.go
│   │   ├── outputs.go
│   │   └── serializer.go
│   ├── pe
│   │   ├── _fixtures
│   │   │   ├── 054299e09cea38df2b84e6b29348b418.bin
│   │   │   ├── mscorlib.dll
│   │   │   ├── process_overwriting.exe
│   │   │   └── shellcode.bin
│   │   ├── config.go
│   │   ├── doc.go
│   │   ├── header.go
│   │   ├── header_test.go
│   │   ├── marshaller.go
│   │   ├── marshaller_test.go
│   │   ├── parser.go
│   │   ├── parser_test.go
│   │   └── types.go
│   ├── ps
│   │   ├── doc.go
│   │   ├── peb.go
│   │   ├── peb_test.go
│   │   ├── snapshotter.go
│   │   ├── snapshotter_mock.go
│   │   ├── snapshotter_windows.go
│   │   ├── snapshotter_windows_test.go
│   │   └── types
│   │       ├── marshaller_windows.go
│   │       ├── marshaller_windows_test.go
│   │       ├── types.go
│   │       ├── types_windows.go
│   │       └── types_windows_test.go
│   ├── rules
│   │   ├── _fixtures
│   │   │   ├── default
│   │   │   │   ├── microsoft_edge.yml
│   │   │   │   ├── sequence_rule_simple.yml
│   │   │   │   ├── suspicious_domains.yml
│   │   │   │   ├── suspicious_module_loaded.yml
│   │   │   │   ├── suspicious_network_connecting_binaries.yml
│   │   │   │   └── windows_error_reporting_and_wmi_provider_host.yml
│   │   │   ├── field_values
│   │   │   │   ├── correct_category_name_field.yml
│   │   │   │   ├── correct_event_name_field.yml
│   │   │   │   ├── incorrect_category_name_field.yml
│   │   │   │   ├── incorrect_event_name_field.yml
│   │   │   │   └── incorrect_event_name_in_operator.yml
│   │   │   ├── kill_action.yml
│   │   │   ├── merged_filters
│   │   │   │   ├── filter1.yml
│   │   │   │   ├── filter2.yml
│   │   │   │   ├── filter3.yml
│   │   │   │   └── filter4.yml
│   │   │   ├── min_engine_version
│   │   │   │   ├── fail
│   │   │   │   │   ├── filter1.yml
│   │   │   │   │   ├── filter2.yml
│   │   │   │   │   └── filter3.yml
│   │   │   │   └── ok
│   │   │   │       ├── filter1.yml
│   │   │   │       ├── filter2.yml
│   │   │   │       └── filter3.yml
│   │   │   ├── sequence_rule_complex.yml
│   │   │   ├── sequence_rule_ps_uuid.yml
│   │   │   ├── simple_and_sequence_rules
│   │   │   │   ├── command_shell_spawned_chrome_browser.yml
│   │   │   │   ├── powershell_created_temp_file.yml
│   │   │   │   ├── powershell_process_spawned.yml
│   │   │   │   └── spawn_chrome_browser.yml
│   │   │   ├── simple_emit_alert.yml
│   │   │   ├── simple_matches
│   │   │   │   ├── filter1.yml
│   │   │   │   ├── filter2.yml
│   │   │   │   ├── filter3.yml
│   │   │   │   └── filter4.yml
│   │   │   └── simple_matches.yml
│   │   ├── action
│   │   │   ├── alert.go
│   │   │   ├── isolate_windows.go
│   │   │   └── kill_windows.go
│   │   ├── compiler.go
│   │   ├── compiler_test.go
│   │   ├── doc.go
│   │   ├── engine.go
│   │   ├── engine_test.go
│   │   ├── sequence.go
│   │   └── sequence_test.go
│   ├── source
│   │   ├── doc.go
│   │   └── source.go
│   ├── symbolize
│   │   ├── exports.go
│   │   ├── exports_test.go
│   │   ├── resolver.go
│   │   ├── symbolizer.go
│   │   └── symbolizer_test.go
│   ├── sys
│   │   ├── dbghelp.go
│   │   ├── device.go
│   │   ├── device_test.go
│   │   ├── doc.go
│   │   ├── etw
│   │   │   ├── etw.go
│   │   │   ├── types.go
│   │   │   ├── types_test.go
│   │   │   └── zsyscall_windows.go
│   │   ├── fs.go
│   │   ├── handle.go
│   │   ├── mem.go
│   │   ├── object.go
│   │   ├── privilege.go
│   │   ├── process.go
│   │   ├── process_test.go
│   │   ├── rid.go
│   │   ├── shell.go
│   │   ├── syscall.go
│   │   ├── trust.go
│   │   ├── trust_test.go
│   │   ├── util.go
│   │   ├── window.go
│   │   ├── wts.go
│   │   └── zsyscall_windows.go
│   ├── util
│   │   ├── bitmask
│   │   │   └── bitmask.go
│   │   ├── bootid
│   │   │   ├── bootid.go
│   │   │   └── bootid_test.go
│   │   ├── bytes
│   │   │   └── bytes.go
│   │   ├── cmdline
│   │   │   ├── cmdline.go
│   │   │   └── cmdline_test.go
│   │   ├── convert
│   │   │   ├── convert.go
│   │   │   └── convert_test.go
│   │   ├── entropy
│   │   │   └── entropy.go
│   │   ├── eventlog
│   │   │   ├── eventid.go
│   │   │   ├── eventid_test.go
│   │   │   └── eventlog.go
│   │   ├── fasttemplate
│   │   │   ├── doc.go
│   │   │   ├── template.go
│   │   │   └── unsafe.go
│   │   ├── filetime
│   │   │   └── filetime.go
│   │   ├── format
│   │   │   └── format.go
│   │   ├── hashers
│   │   │   └── fnv.go
│   │   ├── hostname
│   │   │   └── hostname_windows.go
│   │   ├── ip
│   │   │   ├── ip.go
│   │   │   └── ip_test.go
│   │   ├── key
│   │   │   ├── key.go
│   │   │   └── key_test.go
│   │   ├── log
│   │   │   ├── _fixtures
│   │   │   │   └── fibratus.log
│   │   │   ├── config.go
│   │   │   ├── logger.go
│   │   │   ├── logger_test.go
│   │   │   └── rotate
│   │   │       └── rotate.go
│   │   ├── loldrivers
│   │   │   ├── _fixtures
│   │   │   │   ├── d.sys
│   │   │   │   └── iomem.sys
│   │   │   ├── client.go
│   │   │   ├── client_test.go
│   │   │   └── types.go
│   │   ├── markdown
│   │   │   ├── strip.go
│   │   │   └── strip_test.go
│   │   ├── multierror
│   │   │   └── multierror.go
│   │   ├── ntstatus
│   │   │   └── status.go
│   │   ├── ports
│   │   │   └── iana_ports.go
│   │   ├── rest
│   │   │   ├── rest.go
│   │   │   └── rest_test.go
│   │   ├── sets
│   │   │   ├── intersection.go
│   │   │   └── intersection_test.go
│   │   ├── signals
│   │   │   └── signals.go
│   │   ├── signature
│   │   │   ├── signature.go
│   │   │   ├── signature_test.go
│   │   │   └── types.go
│   │   ├── spinner
│   │   │   └── spinner.go
│   │   ├── stringcase
│   │   │   ├── camel.go
│   │   │   └── camel_test.go
│   │   ├── term
│   │   │   ├── fb.go
│   │   │   └── term.go
│   │   ├── threadcontext
│   │   │   ├── context.go
│   │   │   └── context_test.go
│   │   ├── tls
│   │   │   └── tls.go
│   │   ├── typesize
│   │   │   └── typesize.go
│   │   ├── utf16
│   │   │   ├── utf16.go
│   │   │   └── utf16_test.go
│   │   ├── va
│   │   │   ├── address.go
│   │   │   ├── address_test.go
│   │   │   ├── region.go
│   │   │   └── region_test.go
│   │   ├── version
│   │   │   └── version.go
│   │   └── wildcard
│   │       ├── wildcard.go
│   │       └── wildcard_test.go
│   └── yara
│       ├── _fixtures
│       │   └── rules
│       │       ├── notepad.yar
│       │       └── regedit.yar
│       ├── config
│       │   ├── config.go
│       │   └── config_test.go
│       ├── scanner.go
│       ├── scanner_test.go
│       ├── scanner_unsupported.go
│       ├── types
│       │   ├── types.go
│       │   └── types_test.go
│       └── types.go
├── pkg-config
│   └── python-37.pc
└── rules
    ├── README.md
    ├── credentail_access_file_access_to_sam_database.yml
    ├── credential_access_credential_manager_access_via_known_tools.yml
    ├── credential_access_lsass_access_from_unsigned_executable.yml
    ├── credential_access_lsass_handle_leak_via_seclogon.yml
    ├── credential_access_lsass_memory_dump_preparation_via_silent_process_exit.yml
    ├── credential_access_lsass_memory_dump_via_minidumpwritedump.yml
    ├── credential_access_lsass_memory_dump_via_wer.yml
    ├── credential_access_lsass_memory_dumping.yml
    ├── credential_access_lsass_process_clone_creation_via_reflection.yml
    ├── credential_access_potential_sam_hive_dumping.yml
    ├── credential_access_remote_thread_creation_into_lsass.yml
    ├── credential_access_suspicious_access_to_active_directory_domain_database.yml
    ├── credential_access_suspicious_access_to_unattended_panther_files.yml
    ├── credential_access_suspicious_access_to_windows_dpapi_master_keys.yml
    ├── credential_access_suspicious_access_to_windows_manager_files.yml
    ├── credential_access_suspicious_access_to_windows_vault_files.yml
    ├── credential_access_suspicious_security_package_loaded_by_lsass.yml
    ├── credential_access_suspicious_vault_client_dll_load.yml
    ├── credential_access_unusual_access_to_ssh_keys.yml
    ├── credential_access_unusual_access_to_web_browser_credential_stores.yml
    ├── credential_access_unusual_access_to_windows_credential_history.yml
    ├── defense_evasion_appdomain_manager_injection_via_clr_search_order_hijacking.yml
    ├── defense_evasion_clear_eventlog.yml
    ├── defense_evasion_dll_loaded_via_apc_queue.yml
    ├── defense_evasion_dll_loaded_via_callback_function.yml
    ├── defense_evasion_dll_loaded_via_ldrpkernel32_overwrite.yml
    ├── defense_evasion_dll_sideloading_via_copied_binary.yml
    ├── defense_evasion_dll_sideloading_via_microsoft_office_dropped_file.yml
    ├── defense_evasion_dotnet_assembly_loaded_by_unmanaged_process.yml
    ├── defense_evasion_hidden_registry_key_creation.yml
    ├── defense_evasion_image_load_via_ntfs_transaction.yml
    ├── defense_evasion_potential_injection_via_dotnet_debugging.yml
    ├── defense_evasion_potential_process_creation_via_shellcode.yml
    ├── defense_evasion_potential_process_injection_via_tainted_memory_section.yml
    ├── defense_evasion_potential_shellcode_execution_via_etw_logger_thread.yml
    ├── defense_evasion_potential_shellcode_injection_via_windows_debugging_api.yml
    ├── defense_evasion_potential_thread_execution_hijacking.yml
    ├── defense_evasion_process_creation_via_direct_syscall.yml
    ├── defense_evasion_process_creation_via_ntfs_transaction.yml
    ├── defense_evasion_process_execution_from_hollowed_memory_section.yml
    ├── defense_evasion_process_execution_from_self_deleting_binary.yml
    ├── defense_evasion_process_spawned_via_remote_thread.yml
    ├── defense_evasion_regsvr32_scriptlet_execution.yml
    ├── defense_evasion_suspicious_access_to_the_hosts_file.yml
    ├── defense_evasion_suspicious_dll_loaded_via_memory_section_mapping.yml
    ├── defense_evasion_suspicious_html_application_script_execution.yml
    ├── defense_evasion_suspicious_object_symbolic_link_creation.yml
    ├── defense_evasion_suspicious_protected_process_execution.yml
    ├── defense_evasion_suspicious_windows_defender_exclusions_registry_modification.yml
    ├── defense_evasion_suspicious_xsl_script_execution.yml
    ├── defense_evasion_system_binary_proxy_execution_via_rundll32.yml
    ├── defense_evasion_thread_context_set_from_unbacked_memory.yml
    ├── defense_evasion_unsigned_dll_injection_via_remote_thread.yml
    ├── defense_evasion_windows_defender_driver_unloading.yml
    ├── defense_evasion_windows_defender_protection_tampering_via_registry.yml
    ├── initial_access_executable_file_creation_from_macro_enabled_microsoft_office_document.yml
    ├── initial_access_execution_via_microsoft_office_process.yml
    ├── initial_access_macro_execution_via_script_interpreter.yml
    ├── initial_access_microsoft_office_file_execution_via_script_interpreter.yml
    ├── initial_access_microsoft_office_file_execution_via_wmi.yml
    ├── initial_access_potential_clickfix_infection_chain.yml
    ├── initial_access_process_spawned_from_macro_enabled_microsoft_office_document.yml
    ├── initial_access_suspicious_dll_loaded_by_microsoft_office_process.yml
    ├── initial_access_suspicious_execution_via_wmi_from_microsoft_office_process.yml
    ├── initial_access_suspicious_microsoft_office_embedded_object.yml
    ├── macros
    │   └── macros.yml
    ├── persistence_executable_file_dropped_by_unsigned_service_dll.yml
    ├── persistence_hidden_local_account_creation.yml
    ├── persistence_network_connection_via_startup_folder_executable_or_script.yml
    ├── persistence_potential_port_monitor_or_print_processor_persistence_via_registry_modification.yml
    ├── persistence_rid_hijacking.yml
    ├── persistence_script_interpreter_or_untrusted_process_persistence.yml
    ├── persistence_suspicious_microsoft_office_addin_loaded.yml
    ├── persistence_suspicious_microsoft_office_template.yml
    ├── persistence_suspicious_netsh_helper_dll_execution.yml
    ├── persistence_suspicious_persistence_via_registry_modification.yml
    ├── persistence_suspicious_port_monitor_loaded.yml
    ├── persistence_suspicious_print_processor_loaded.yml
    ├── persistence_suspicious_startup_shell_folder_modification.yml
    ├── persistence_unusual_file_written_in_startup_folder.yml
    ├── persistence_unusual_process_modified_registry_run_key.yml
    ├── privilege_escalation_potential_privilege_escalation_via_phantom_dll_hijacking.yml
    ├── privilege_escalation_vulnerable_or_malicious_driver_dropped.yml
    ├── privilege_escalation_vulnerable_or_malicious_driver_loaded.yml
    └── rule-alert.png

```

`CODE_OF_CONDUCT.md`:

```md
# Contributor Covenant Code of Conduct

## Our Pledge

We as members, contributors, and leaders pledge to make participation in our
community a harassment-free experience for everyone, regardless of age, body
size, visible or invisible disability, ethnicity, sex characteristics, gender
identity and expression, level of experience, education, socio-economic status,
nationality, personal appearance, race, religion, or sexual identity
and orientation.

We pledge to act and interact in ways that contribute to an open, welcoming,
diverse, inclusive, and healthy community.

## Our Standards

Examples of behavior that contributes to a positive environment for our
community include:

* Demonstrating empathy and kindness toward other people
* Being respectful of differing opinions, viewpoints, and experiences
* Giving and gracefully accepting constructive feedback
* Accepting responsibility and apologizing to those affected by our mistakes,
  and learning from the experience
* Focusing on what is best not just for us as individuals, but for the
  overall community

Examples of unacceptable behavior include:

* The use of sexualized language or imagery, and sexual attention or
  advances of any kind
* Trolling, insulting or derogatory comments, and personal or political attacks
* Public or private harassment
* Publishing others' private information, such as a physical or email
  address, without their explicit permission
* Other conduct which could reasonably be considered inappropriate in a
  professional setting

## Enforcement Responsibilities

Community leaders are responsible for clarifying and enforcing our standards of
acceptable behavior and will take appropriate and fair corrective action in
response to any behavior that they deem inappropriate, threatening, offensive,
or harmful.

Community leaders have the right and responsibility to remove, edit, or reject
comments, commits, code, wiki edits, issues, and other contributions that are
not aligned to this Code of Conduct, and will communicate reasons for moderation
decisions when appropriate.

## Scope

This Code of Conduct applies within all community spaces, and also applies when
an individual is officially representing the community in public spaces.
Examples of representing our community include using an official e-mail address,
posting via an official social media account, or acting as an appointed
representative at an online or offline event.

## Enforcement

Instances of abusive, harassing, or otherwise unacceptable behavior may be
reported to the community leaders responsible for enforcement at
rabbitstack7@gmail.com.
All complaints will be reviewed and investigated promptly and fairly.

All community leaders are obligated to respect the privacy and security of the
reporter of any incident.

## Enforcement Guidelines

Community leaders will follow these Community Impact Guidelines in determining
the consequences for any action they deem in violation of this Code of Conduct:

### 1. Correction

**Community Impact**: Use of inappropriate language or other behavior deemed
unprofessional or unwelcome in the community.

**Consequence**: A private, written warning from community leaders, providing
clarity around the nature of the violation and an explanation of why the
behavior was inappropriate. A public apology may be requested.

### 2. Warning

**Community Impact**: A violation through a single incident or series
of actions.

**Consequence**: A warning with consequences for continued behavior. No
interaction with the people involved, including unsolicited interaction with
those enforcing the Code of Conduct, for a specified period of time. This
includes avoiding interactions in community spaces as well as external channels
like social media. Violating these terms may lead to a temporary or
permanent ban.

### 3. Temporary Ban

**Community Impact**: A serious violation of community standards, including
sustained inappropriate behavior.

**Consequence**: A temporary ban from any sort of interaction or public
communication with the community for a specified period of time. No public or
private interaction with the people involved, including unsolicited interaction
with those enforcing the Code of Conduct, is allowed during this period.
Violating these terms may lead to a permanent ban.

### 4. Permanent Ban

**Community Impact**: Demonstrating a pattern of violation of community
standards, including sustained inappropriate behavior,  harassment of an
individual, or aggression toward or disparagement of classes of individuals.

**Consequence**: A permanent ban from any sort of public interaction within
the community.

## Attribution

This Code of Conduct is adapted from the [Contributor Covenant][homepage],
version 2.0, available at
https://www.contributor-covenant.org/version/2/0/code_of_conduct.html.

Community Impact Guidelines were inspired by [Mozilla's code of conduct
enforcement ladder](https://github.com/mozilla/diversity).

[homepage]: https://www.contributor-covenant.org

For answers to common questions about this code of conduct, see the FAQ at
https://www.contributor-covenant.org/faq. Translations are available at
https://www.contributor-covenant.org/translations.

```

`CONTRIBUTING.md`:

```md
# Contributing

We greatly appreciate you have considered contributing to Fibratus! Please, read carefully through the guidelines before you start the contribution process.

## Introduction

1. **You're familiar with [Github](https://github.com), git, and the pull request workflow**
2. **Make sure you've read Fibratus [docs](https://www.fibratus.io)**
3. If you got an idea about some feature that's not currently in the backlog, please create the [feature request](https://github.com/rabbitstack/fibratus/issues/new) first. The feature request should precisely describe the scope, requirements, and the motivation for the intended changeset

## Your First Contribution

1. [Fork](https://docs.github.com/en/pull-requests/collaborating-with-pull-requests/working-with-forks/fork-a-repo) the Fibratus repository in your own Github account
2. Clone the repository into the location of your choice
3. [Create](https://docs.github.com/en/pull-requests/collaborating-with-pull-requests/proposing-changes-to-your-work-with-pull-requests/creating-and-deleting-branches-within-your-repository) a new Git branch. Give branch a meaningful name.
4. Work on your changes
5. [Submit](https://docs.github.com/en/pull-requests/collaborating-with-pull-requests/proposing-changes-to-your-work-with-pull-requests/creating-a-pull-request-from-a-fork) the branch as a pull request to the upstream Fibratus repository. When submitting the pull request, the title must adhere to the [Conventional Commits](https://www.conventionalcommits.org/en/v1.0.0/) specification. For example, `feat: Add thread start address parameter`. The pull request body is automatically filled with the list of checks describing the type of change that the pull request introduces and specific project areas related to the PR. Please mark the right option with `[x]` and remove any options that don't apply to your changeset. Be generous when communicating the purpose of the pull request, and clearly indicate any notes for the reviewer
6. It is highly recommended to prefix all commit messages pertaining to the pull request with the aforementioned [Conventional Commit](https://www.conventionalcommits.org/en/v1.0.0/) specs. For example:
   1. `feat(event): Add thread start address parameter`
   2. `refactor(filter): Rename start address filter field name`
7. Keep the commit history clean and concise. Let's say you pushed two commits and immediately noticed the first commit contains a typo. If possible, avoid pushing a third commit to fix the typo. Rather adopt the following workflow:
   1. Reset the branch with `git reset --soft HEAD~2`. This makes the `HEAD` point to the commit before our changes were introduced. 
   2. Fix the typo, then stage and commit the first change, and subsequently the second change.
   3. Push force to your branch. `git push -f origin <your-branch-name>`
8. Your pull request will undergo a review process. Core maintainers or contributors should leave comments/suggestions on your pull request and potentially require changes

### Conflicting changes

If your pull request brings conflicting changes, you should follow these steps to resolve the conflicts.

1. Pull the latest changes from the `master` branch
   1. `git checkout master`
   2. `git pull`
2. Checkout back to your branch and rebase on top of the `master` branch
   1. `git checkout <your-branch-name>`
   2. `git rebase master`
3. Work through your conflicts and resolve them. Once you're happy with the result run
   1. `git rebase --continue`
4. Push force to your branch. Be sure to understand the implications and risks of [force-pushing](https://stackoverflow.com/questions/33247309/why-is-it-dangerous-to-do-a-force-push-against-a-remote-repository) 
   1. `git push -f origin <your-branch-name>`

## Development

### Directory Structure

- [`.github`](/.github) Github artifacts
    1. [`/workflows`](/.github/workflows) Github Actions workflows
- [`/build`](/build) Resources for producing software packages
    1. [`msi`](/build/msi) [WiX Toolset](https://wixtoolset.org/) manifest for creating the MSI package
- [`/cmd`](/cmd)
    1. [`/fibratus`](/cmd/fibratus/) - Contains Fibratus entrypoint source file, CLI command implementations and the resource compiler manifest.
    2. [`/systray`](/cmd/systray/) - Systray server implementation. Uses named pipe IPC to pull [systray alertsender](https://www.fibratus.io/#/alerts/senders/systray) messages from the main process.
- [`/configs`](/config) - Configuration files in `yml` and `json` format, included in every release.
- [`/docs`](/docs) - Markdown files for generating the [documentation](https://www.fibratus.io/) site.
- [`/filaments`](/filaments) - The collection of [filaments](https://www.fibratus.io/#/filaments/introduction) that are included in every release.
- [`/internal`](/pkg) - Fibratus internal source.
- [`/pkg`](/pkg) - Fibratus main source.
- [`/pkg-config`](/pkg-config) - [pkg-config](https://www.freedesktop.org/wiki/Software/pkg-config/) descriptors for externalizing the `cgo` flags.
- [`/rules`](/rules) - Detection rules.

### Setting Up The Dev Environment 

- [Download](https://golang.org/dl/) and install the Go toolchain. We love to live on the bleeding edge and regularly bump the Go toolchain in the [CI pipeline](https://github.com/rabbitstack/fibratus/blob/e9e956fd91bb2626ed7cf2fdb5f4d0091312fec3/.github/workflows/master.yml#L13).
- IDE of your choice. [GoLand](https://www.jetbrains.com/go/) is dope. [Go extension](https://code.visualstudio.com/docs/languages/go) for Visual Code does a decent job. Most IDEs can automatically [format and rearrange](https://www.jetbrains.com/help/go/reformat-and-rearrange-code.html) the code abiding by the Go code style standards. This is important to guarantee that your code is in harmony with the Go code style.

#### The Easy Way

No further dependencies are required if you have already installed the Go compiler. Fibratus includes a [`make.bat`](/make.bat) in the root directory of the repo. The `bat` script mimics the [Makefile](https://www.gnu.org/software/make/manual/html_node/Introduction.html) execution workflow. Refer to the [`make.bat`](/make.bat) file for a full list of tasks.

To build the Fibratus binary, run `./make` from the Powershell terminal. The resulting binary is placed inside the `cmd\fibratus` directory. Additionally, `fibratus-systray.exe` binary is generated in the `cmd\systray` directory. It acts as a named pipe server and sends notifications to the systray area from the corresponding alert sender.

#### The Hard Way

To build Fibratus directly from source code you have to satisfy the following dependencies:

- C compiler
- Python headers
- [libyara](https://github.com/VirusTotal/yara/tree/master/libyara)

**Installing dependencies**

1. [Download](https://www.msys2.org/#installation) the `msys2` installer and follow the instructions [here](https://www.msys2.org/).
  - open the `msys2` shell (by default located in `C:\msys2\msys2.exe`). You can also access it from the `MSYS2 64-bit` Start Menu item.
  - install the `MinGW` compiler toolchain along with other dependencies:
    - `pacman -S base-devel mingw-w64-x86_64-openssl mingw-w64-x86_64-gcc mingw-w64-x86_64-pkg-config automake libtool autoconf`
2. [Download](https://www.python.org/ftp/python/3.7.9/python-3.7.9-amd64.exe) and install the `Python 3.7`. Assuming the Python distribution was installed in `C:\Python37`, set the `PKG_CONFIG_PATH` environment variable to the location of the `pkg-config` directory within the `fibratus` directory.
  - `$env:PKG_CONFIG_PATH="<pkg-config absolute path>"`
3. Build `libyara`
  - clone the `yara` repository into the path visible to the `msys2` environment. This is ideally done from the `MSYS2 64-bit` shell.
    - `pacman -S git`
    - `git clone https://github.com/VirusTotal/yara.git`
    - go to the `yara` repository you previously cloned. Run the following commands:
      - `autoreconf -fiv`
      - `./configure --host=x86_64-w64-mingw32`
      - `make install`

**Build flags**

By default, when building Fibratus, the Go compiler is instructed to ignore all features that trigger the [cgo](https://golang.org/cmd/cgo/), but you can control which features are enabled through the following build flags:

- `filament`: compiles Fibratus with filaments support
- `kcap`: compiles Fibratus with support for capturing/replaying kcap files
- `yara`: builds Fibratus with support for [Yara](https://virustotal.github.io/yara/) pattern matching

To produce the Fibratus binary with the filaments support, you would run the following commands from the Powershell terminal:

```
$ $env:TAGS="filament"
$ ./make
```

To create the full-fledged Fibratus binary, activate all build flags:

```
$ $env:TAGS="filament,kcap,yara"
$ ./make
```

### Running For The First Time

By default, Fibratus operates in rule engine mode. It loads the rule set from the `%PROGRAM FILES%\Fibratus\Rules` directory and sends security alerts to [Eventlog](/alerts/senders/eventlog). Optionally, it takes response actions when the rule is fired, such as killing the process.
Alternatively, Fibratus can forward events to [output](/outputs/introduction) sinks, if it started in event forwarding mode.

To start Fibratus in event forwarding mode run the next command from the root directory of this repo:

```
$ .\cmd\fibratus\fibratus.exe run --forward
```

If you want to run Fibratus in rule engine mode, follow the next steps:

- modify the configuration file to set the location to the rule files. Go to the `filters` section, and specify the absolute path to the `Rules` and `Macros` directories of this repository.
  ```
  filters:
    rules:
      # The list of file system paths were rule files are located. Supports glob expressions in path names.
      from-paths:
       - C:\Fibratus\Rules\*.yml
      #from-urls:
    macros:
      # The list of file system paths were macro library files are located. Supports glob expressions in path names.
      from-paths:
       - C:\Fibratus\Rules\Macros\*.yml
  ```
  Change the paths according to the location of your repository.

- start Fibratus passing the path to the configuration file 
  ```
  $ .\cmd\fibratus\fibratus.exe --config-file=configs/fibratus.yml
  ```

### Packaging

[Wix Toolset](https://wixtoolset.org/) is a set of tools that allow creating MSI packages. To bundle all Fibratus components inside the MSI package, it is required that you first install Wix Toolset.

Use the `dotnet` command to install Wix Toolset. If you don't have **.NET runtime** installed, it is possible to fetch it via [choco](https://community.chocolatey.org/) package manager.

```
$ choco install dotnet
$ dotnet tool install --global wix --version 5.0.0
```

Now use the `pkg` target from the `./make.bat` script to build the MSI package.

```
$ ./make.bat pkg
```

The resulting MSI is placed in the `build\msi` directory.

```

`LICENSE.MD`:

```MD
Copyright 2019-2024 by Nedim Sabic Sabic and contributors
https://www.fibratus.io

All Rights Reserved.

Licensed under the Apache License, Version 2.0 (the "License"); you may
not use this file except in compliance with the License. You may obtain
a copy of the License at

http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
License for the specific language governing permissions and limitations
under the License.

```

`README.md`:

```md
<p align="center" >
  <a href="https://www.fibratus.io" >
    <img src="logo.png" alt="Fibratus">
  </a>
</p>

<h2 align="center">Fibratus</h2>

<p align="center">
  Adversary tradecraft detection, protection, and hunting
  <br>
  <a href="https://www.fibratus.io/#/setup/installation"><strong>Get Started »</strong></a>
  <br>
  <br>
  <strong>
    <a href="https://www.fibratus.io">Docs</a>
    &nbsp;&nbsp;&bull;&nbsp;&nbsp;
    <a href="https://github.com/rabbitstack/fibratus/tree/master/rules">Rules</a>
    &nbsp;&nbsp;&bull;&nbsp;&nbsp;
    <a href="https://github.com/rabbitstack/fibratus/tree/master/filaments">Filaments</a>
    &nbsp;&nbsp;&bull;&nbsp;&nbsp;
    <a href="https://github.com/rabbitstack/fibratus/releases">Download</a>
    &nbsp;&nbsp;&bull;&nbsp;&nbsp;
    <a href="https://github.com/rabbitstack/fibratus/discussions">Discussions</a>
  </strong>
</p>

Fibratus detects, protects, and eradicates advanced adversary tradecraft by scrutinizing
and asserting a wide spectrum of system events against a behavior-driven [rule engine](https://www.fibratus.io/#/filters/rules) and [YARA](https://www.fibratus.io/#/yara/introduction) memory scanner.

Events can also be shipped to a wide array of [output sinks](https://www.fibratus.io/#/outputs/introduction) or dumped to [capture](https://www.fibratus.io/#/captures/introduction) files for local inspection and forensics analysis. You can use [filaments](https://www.fibratus.io/#/filaments/introduction) to extend Fibratus with your own arsenal of tools and so leverage the power of the Python ecosystem. 

In a nutshell, the Fibratus mantra is defined by the pillars of **realtime behavior detection**, **memory scanning**, and **forensics** capabilities.


### Installation

- Download the latest [MSI package](https://github.com/rabbitstack/fibratus/releases) and follow the [UI](https://www.fibratus.io/#/setup/installation) wizard or
alternatively install via `msiexec` in silent mode

```
$ msiexec /i fibratus-2.4.0-amd64.msi /qn
```

### Quick start

---

- spin up a command line prompt
- list credentials from the vault by using the `VaultCmd` tool

```
$ VaultCmd.exe /listcreds:"Windows Credentials" /all
```

`Credential discovery via VaultCmd tool` rule should trigger and emit the alert to the [Eventlog](https://www.fibratus.io/#/alerts/senders/eventlog). Check the short demo [here](https://www.fibratus.io/alerts/senders/images/eventlog.gif).

### Documentation

To fully exploit and learn about Fibratus capabilities, read the [docs](https://www.fibratus.io).

### Rules

Detection rules live in the [`rules`](/rules) directory of this repository. The CLI provides a set of
commands to explore the rule catalog, validate the rules, or [create a new rule](https://github.com/rabbitstack/fibratus/tree/master/rules#structure) from the template.

To describe all rules in the catalog, use the `fibratus rules list` command. It is possible to pass the
`-s` flag to show rules summary by MITRE tactics and techniques.

### Contributing

We love contributions. To start contributing to Fibratus, please read our [contribution guidelines](https://github.com/rabbitstack/fibratus/blob/master/CONTRIBUTING.md).

### Code Signing Policy

Free code signing provided by [SignPath.io], certificate by
[SignPath Foundation]. All releases are automatically signed.

[SignPath.io]: https://signpath.io
[SignPath Foundation]: https://signpath.org

---

<p align="center">
  Developed with ❤️ by <strong>Nedim Šabić Šabić</strong>
</p>

```

`build/msi/LICENSE.rtf`:

```rtf
{\rtf1\ansi\ansicpg1252\deff0\nouicompat\deflang1033{\fonttbl{\f0\fnil\fcharset0 Tahoma;}{\f1\fnil Lucida Console;}{\f2\fnil\fcharset0 Calibri;}}
{\colortbl ;\red0\green0\blue0;\red0\green0\blue255;\red255\green255\blue255;}
{\*\generator Riched20 10.0.22621}\viewkind4\uc1 
\pard\box\brdrdash\brdrw0 \cbpat3\sa200\sl276\slmult1\cf1\f0\fs19\lang9 Copyright 2019-2024 by Nedim Sabic Sabic\line\line All Rights Reserved.\line\line Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License. \line You may obtain a copy of the License at\line\line {\cf0{\field{\*\fldinst{HYPERLINK http://www.apache.org/licenses/LICENSE-2.0 }}{\fldrslt{http://www.apache.org/licenses/LICENSE-2.0\ul0\cf0}}}}\f0\fs19\line\line Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR \line CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.\line\f1\par

\pard\sa200\sl276\slmult1\cf0\f2\fs22\par
}
 
```

`build/msi/fibratus.wxs`:

```wxs
<?xml version="1.0" encoding="utf-8"?>
<Wix xmlns="http://wixtoolset.org/schemas/v4/wxs"
  xmlns:ui="http://wixtoolset.org/schemas/v4/wxs/ui"
  xmlns:util="http://wixtoolset.org/schemas/v4/wxs/util">

  <Package Name="Fibratus"
      Version="$(var.VERSION)"
      Manufacturer="Nedim Sabic Sabic &lt;https://www.fibratus.io&gt;"
      UpgradeCode="E81B8794-3277-47F9-BE58-2EF2D20930EC"
      InstallerVersion="200"
      Compressed="yes"
      Language="1033">
    <SummaryInformation Description="Fibratus Installer" />

    <Media Id="1" Cabinet="fibratus.cab" EmbedCab="yes" />

    <Icon Id="Fibratus.ico" SourceFile="fibratus.ico" />

    <Property Id="ARPPRODUCTICON" Value="Fibratus.ico" />

    <MajorUpgrade Schedule="afterInstallInitialize" DowngradeErrorMessage="A later version of [ProductName] is already installed" AllowSameVersionUpgrades="yes" />

    <UI Id="UI">
      <ui:WixUI Id="WixUI_InstallDir" InstallDirectory="INSTALLDIR" />
    </UI>

    <!-- Custom banners -->
    <WixVariable Id="WixUIDialogBmp" Value="background.png" /> <!-- Background bitmap used on the welcome and completion dialogs, should be 493 × 312 pixels -->
    <WixVariable Id="WixUIBannerBmp" Value="banner.png" />  <!-- Top banner, should be 493 × 58 pixels -->

    <Property Id="WIXUI_EXITDIALOGOPTIONALTEXT" Value="You're all set up! Fibratus is running and securing your endpoint." />

    <!-- License -->
    <WixVariable Id="WixUILicenseRtf" Value="LICENSE.rtf"/>

    <!--Files -->
    <ComponentGroup Id="Files" Directory="INSTALLDIR">
      <Files Include="!(bindpath.dir)**">
        <!-- Exclude from harvesting as its need fine-grained authoring in Windows Service -->
        <Exclude Files="!(bindpath.dir)Bin\fibratus.exe" />
      </Files>

      <!-- Windows Service -->
      <Component Directory="BINDIR" Guid="F2C06EDD-C830-4FCD-BAFA-0D15C697EE76">
        <File Source="!(bindpath.dir)Bin\fibratus.exe" />
        <ServiceInstall Name="Fibratus" DisplayName="Fibratus"
            Description="Adversary tradecraft detection, protection, and hunting"
            Account="LocalSystem"
            Type="ownProcess"
            Start="auto"
            ErrorControl="normal" Vital="yes">
          <util:ServiceConfig FirstFailureActionType="restart" SecondFailureActionType="restart"
              ThirdFailureActionType="restart" RestartServiceDelayInSeconds="60" />
        </ServiceInstall>
        <ServiceControl Id="Fibratus" Name="Fibratus" Start="install" Stop="both" Remove="uninstall" Wait="yes" />
      </Component>
    </ComponentGroup>

    <StandardDirectory Id="ProgramFiles64Folder">
      <Directory Id="INSTALLDIR" Name="Fibratus">
        <Component Id="Path" KeyPath="yes" Guid="E81B8794-3277-47F9-BE58-2EF2D20930EC">
          <Environment Id="PATH" Name="PATH" Value="[INSTALLDIR]Bin" Permanent="no" Part="last" Action="set" System="yes" />
        </Component>
        <Directory Id="BINDIR" Name="Bin" />
      </Directory>
    </StandardDirectory>

    <Feature Id="Fibratus" Description="Fibratus" Level="1" ConfigurableDirectory="INSTALLDIR">
      <ComponentGroupRef Id="Files" />
      <ComponentRef Id="Path" />
    </Feature>

    <!-- Enable recovery actions for the Windows Service -->
    <Property Id="ConfigureServiceRecovery" Value="&quot;SC.EXE&quot; failureflag fibratus 1" />
    <CustomAction Id="ConfigureServiceRecovery" BinaryRef="Wix4UtilCA_$(sys.BUILDARCHSHORT)" DllEntry="WixQuietExec" Impersonate="no" Execute="deferred" Return="ignore" />

    <util:CloseApplication Id="CloseSystray" CloseMessage="yes" Target="fibratus-systray.exe" RebootPrompt="no" />

    <InstallExecuteSequence>
      <Custom Action="ConfigureServiceRecovery" After="InstallServices" Condition="NOT REMOVE" />
    </InstallExecuteSequence>

  </Package>
</Wix>

```

`cmd/fibratus/app/capture/capture_windows.go`:

```go
/*
 * Copyright 2019-2020 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package capture

import (
	"github.com/rabbitstack/fibratus/internal/bootstrap"
	"github.com/rabbitstack/fibratus/pkg/config"
	"github.com/rabbitstack/fibratus/pkg/util/multierror"
	"github.com/rabbitstack/fibratus/pkg/util/spinner"
	"github.com/spf13/cobra"
	"time"
)

var Command = &cobra.Command{
	Use:   "capture [filter]",
	Short: "Capture event stream to the cap (capture) file",
	RunE:  capture,
}

var (
	// capture command config
	cfg = config.NewWithOpts(config.WithCapture())
)

func init() {
	cfg.MustViperize(Command)
}

func capture(cmd *cobra.Command, args []string) error {
	spin := spinner.Show("Snapshotting processes and handles")
	defer spin.Stop()
	// the capture will start after all system handles have been
	// enumerated. This gives us a chance to build the handle state
	// before writing the event stream.
	// Make sure to not wait more than a minute if system handle
	// enumeration got stuck or taking too much time to complete
	wait := make(chan struct{}, 1)
	deadline := time.AfterFunc(time.Minute, func() {
		wait <- struct{}{}
	})
	fn := func(total uint64, named uint64) {
		deadline.Stop()
		spin.Stop()
		wait <- struct{}{}
	}
	app, err := bootstrap.NewApp(cfg, bootstrap.WithSignals(), bootstrap.WithDebugPrivilege(),
		bootstrap.WithHandleSnapshotFn(fn))
	if err != nil {
		return err
	}
	<-wait
	if err := app.WriteCapture(args); err != nil {
		return multierror.Wrap(err, app.Shutdown())
	}
	spin = spinner.Show("Capturing")
	app.Wait()
	spin.Stop()
	return app.Shutdown()
}

```

`cmd/fibratus/app/config/config.go`:

```go
/*
 * Copyright 2019-2020 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package config

import (
	"fmt"
	"github.com/rabbitstack/fibratus/internal/bootstrap"
	"github.com/rabbitstack/fibratus/pkg/config"
	errs "github.com/rabbitstack/fibratus/pkg/errors"
	"github.com/rabbitstack/fibratus/pkg/util/rest"
	"github.com/spf13/cobra"
	"os"
)

var Command = &cobra.Command{
	Use:   "config",
	Short: "Show runtime config",
	RunE:  printConfig,
}

var (
	// config command options
	cfg = config.NewWithOpts(config.WithStats())
)

func init() {
	cfg.MustViperize(Command)
}

func printConfig(cmd *cobra.Command, args []string) error {
	if err := bootstrap.InitConfigAndLogger(cfg); err != nil {
		return err
	}
	body, err := rest.Get(rest.WithTransport(cfg.API.Transport), rest.WithURI("config"))
	if err != nil {
		return errs.ErrHTTPServerUnavailable(cfg.API.Transport, err)
	}
	_, err = fmt.Fprintln(os.Stdout, string(body))
	if err != nil {
		return err
	}
	return nil
}

```

`cmd/fibratus/app/docs.go`:

```go
/*
 * Copyright 2019-2020 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package app

import (
	"github.com/spf13/cobra"
	"os/exec"
)

var docsCmd = &cobra.Command{
	Use:   "docs",
	Short: "Open Fibratus docs in the web browser",
	RunE: func(cmd *cobra.Command, args []string) error {
		return exec.Command("rundll32", "url.dll,FileProtocolHandler", "https://www.fibratus.io").Start()
	},
}

```

`cmd/fibratus/app/list/list.go`:

```go
/*
 * Copyright 2019-2020 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package list

import (
	"bufio"
	"fmt"
	"github.com/jedib0t/go-pretty/v6/table"
	"github.com/rabbitstack/fibratus/internal/bootstrap"
	"github.com/rabbitstack/fibratus/pkg/config"
	"github.com/rabbitstack/fibratus/pkg/event"
	"github.com/rabbitstack/fibratus/pkg/filter/fields"
	"github.com/spf13/cobra"
	"os"
	"path/filepath"
	"strings"
)

var Command = &cobra.Command{
	Use:   "list",
	Short: "Show info about filaments, filter fields or event types",
}

var listFilamentsCmd = &cobra.Command{
	Use:   "filaments",
	Short: "List available filaments",
	RunE:  listFilaments,
}

var listFieldsCmd = &cobra.Command{
	Use:   "fields",
	Short: "List available filtering fields",
	Run:   listFields,
}

var listEventsCmd = &cobra.Command{
	Use:   "events",
	Short: "List supported event types",
	Run:   listEvents,
}

var cfg = config.NewWithOpts(config.WithList())

func init() {
	cfg.MustViperize(Command)

	Command.AddCommand(listFilamentsCmd)
	Command.AddCommand(listFieldsCmd)
	Command.AddCommand(listEventsCmd)
}

// listFilaments renders a table with all available filaments.
func listFilaments(cmd *cobra.Command, args []string) error {
	if err := bootstrap.InitConfigAndLogger(cfg); err != nil {
		return err
	}

	dir := cfg.Filament.Path
	if _, err := os.Stat(dir); err != nil {
		if os.IsNotExist(err) {
			return fmt.Errorf("%q directory does not exist", dir)
		}
		return err
	}

	filaments, err := os.ReadDir(dir)
	if err != nil {
		return err
	}

	t := table.NewWriter()
	t.SetOutputMirror(os.Stdout)
	t.AppendHeader(table.Row{"Name", "Description"})
	t.SetStyle(table.StyleLight)

	for _, f := range filaments {
		if f.IsDir() {
			continue
		}
		py, err := os.Open(filepath.Join(dir, f.Name()))
		if err != nil {
			continue
		}
		if filepath.Ext(f.Name()) != ".py" {
			continue
		}

		sn := bufio.NewScanner(py)
		var docStart bool
		var doc string
		for sn.Scan() {
			ln := sn.Text()
			if docStart {
				doc = ln
				break
			}
			if ln == `"""` {
				docStart = true
			}
		}
		_ = py.Close()
		t.AppendRow(table.Row{strings.TrimSuffix(f.Name(), ".py"), doc})
	}
	t.Render()

	return nil
}

// listEvents renders a table with supported event types showing the category
// to which their pertain and a short description of the event.
func listEvents(cmd *cobra.Command, args []string) {
	t := table.NewWriter()
	t.SetOutputMirror(os.Stdout)
	t.AppendHeader(table.Row{"Name", "Category", "Description"})
	t.SetStyle(table.StyleLight)

	for _, ev := range event.GetTypesMeta() {
		t.AppendRow(table.Row{ev.Name, ev.Category, ev.Description})
	}

	t.Render()
}

// listFields renders a table with available filtering fields containing the name,
// description, filter example, and a column indicating if the field is deprecated.
func listFields(cmd *cobra.Command, args []string) {
	t := table.NewWriter()
	t.SetOutputMirror(os.Stdout)
	t.AppendHeader(table.Row{"Name", "Description", "Example", "Deprecation"})
	t.SetStyle(table.StyleLight)

	for _, field := range fields.Get() {
		if field.IsDeprecated() {
			deprecated := fmt.Sprintf("since %s", field.Deprecation.Since)
			t.AppendRow(table.Row{field.Field, field.Desc, strings.Join(field.Examples, ","), deprecated})
		} else {
			t.AppendRow(table.Row{field.Field, field.Desc, strings.Join(field.Examples, ","), ""})
		}
	}
	t.Render()
}

```

`cmd/fibratus/app/replay/replay_windows.go`:

```go
/*
 * Copyright 2019-2020 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package replay

import (
	"context"
	"github.com/rabbitstack/fibratus/internal/bootstrap"
	"github.com/rabbitstack/fibratus/pkg/config"
	"github.com/rabbitstack/fibratus/pkg/util/multierror"
	"github.com/spf13/cobra"
)

var Command = &cobra.Command{
	Use:   "replay",
	Short: "Replay event stream from the cap (capture) file",
	RunE:  replay,
}

var (
	// replay command config
	cfg = config.NewWithOpts(config.WithReplay())
)

func init() {
	cfg.MustViperize(Command)
}

func replay(cmd *cobra.Command, args []string) error {
	app, err := bootstrap.NewApp(cfg, bootstrap.WithSignals(), bootstrap.WithCaptureReplay())
	if err != nil {
		return err
	}
	ctx, cancel := context.WithCancel(context.Background())
	defer cancel()
	if err := app.ReadCapture(ctx, args); err != nil {
		return multierror.Wrap(err, app.Shutdown())
	}
	app.Wait()
	return app.Shutdown()
}

```

`cmd/fibratus/app/root.go`:

```go
/*
 * Copyright 2019-2020 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package app

import (
	"errors"
	"github.com/rabbitstack/fibratus/cmd/fibratus/app/capture"
	"github.com/rabbitstack/fibratus/cmd/fibratus/app/config"
	"github.com/rabbitstack/fibratus/cmd/fibratus/app/list"
	"github.com/rabbitstack/fibratus/cmd/fibratus/app/replay"
	"github.com/rabbitstack/fibratus/cmd/fibratus/app/rules"
	"github.com/rabbitstack/fibratus/cmd/fibratus/app/service"
	"github.com/rabbitstack/fibratus/cmd/fibratus/app/stats"
	"github.com/spf13/cobra"
	"runtime"
)

// RootCmd is the entrance to Fibratus CLI
var RootCmd = &cobra.Command{
	Use:   "fibratus",
	Short: "Adversary tradecraft detection, protection, and hunting",
	Long: `
	Fibratus detects, protects, and erradicates advanced adversary tradecraft by scrutinizing
	and asserting a wide spectrum of system events against a behaviour-driven and YARA memory scanner.
	Events can also be shipped to a wide array of output sinks or dumped to capture files for local inspection
	and forensics analysis. You can use filaments to extend Fibratus with your own arsenal of tools and so
	leverage the power of the Python ecosystem.
	`,
	SilenceUsage: true,
	PersistentPreRunE: func(cmd *cobra.Command, args []string) error {
		if runtime.GOOS != "windows" {
			return errors.New("fibratus can only be run on Windows operating systems")
		}
		if runtime.GOARCH == "386" {
			return errors.New("fibratus can't be run on 32-bits Windows operating systems")
		}
		return nil
	},
}

func init() {
	RootCmd.AddCommand(capture.Command)
	RootCmd.AddCommand(replay.Command)
	RootCmd.AddCommand(service.Command)
	RootCmd.AddCommand(stats.Command)
	RootCmd.AddCommand(config.Command)
	RootCmd.AddCommand(list.Command)
	RootCmd.AddCommand(rules.Command)
	RootCmd.AddCommand(runCmd)
	RootCmd.AddCommand(docsCmd)
	RootCmd.AddCommand(versionCmd)
}

```

`cmd/fibratus/app/rules/create.go`:

```go
/*
 * Copyright 2021-2022 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package rules

import (
	"fmt"
	"github.com/enescakir/emoji"
	"github.com/google/uuid"
	"github.com/rabbitstack/fibratus/pkg/config"
	"github.com/rabbitstack/fibratus/pkg/util/version"
	"os"
	"strings"
	"text/template"
)

var ruleTemplate = `name: {{ .Name }}
id: {{ .ID }}
version: {{ .Version }}
description: |
  Provide a meaningful description that clearly conveys the detection objectives of this rule.
  Good descriptions usually start with "Identifies ..." or "Detects ...".
{{- if .Labels }}
labels:
{{- range $key, $value := .Labels }}
  {{ $key }}: {{ $value }}
{{- end -}}
{{ end }}

condition: >

min-engine-version: {{ .MinEngineVersion }}
`
var tactics = map[string]string{
	"TA0001": "Initial Access",
	"TA0002": "Execution",
	"TA0003": "Persistence",
	"TA0004": "Privilege Escalation",
	"TA0005": "Defense Evasion",
	"TA0006": "Credential Access",
	"TA0007": "Discovery",
	"TA0008": "Lateral Movement",
	"TA0009": "Collection",
	"TA0011": "Command and Control",
	"TA0040": "Impact",
	"TA0042": "Resource Development",
	"TA0043": "Reconnaissance",
}

func createRule(name string) error {
	data := struct {
		*config.FilterConfig
		MinEngineVersion string
	}{
		&config.FilterConfig{
			Name:    name,
			ID:      uuid.New().String(),
			Version: "1.0.0",
		},
		version.Get(),
	}

	if tacticID != "" {
		data.Labels = make(map[string]string)
		data.Labels["tactic.id"] = tacticID
		data.Labels["tactic.name"] = tactics[tacticID]
		data.Labels["tactic.ref"] = fmt.Sprintf("https://attack.mitre.org/tactics/%s/", tacticID)
	}

	tmpl, err := template.New("rule").Parse(ruleTemplate)
	if err != nil {
		return err
	}

	n := fmt.Sprintf("%s.yml", strings.ReplaceAll(strings.ToLower(name), " ", "_"))
	if tacticID != "" {
		n = strings.ReplaceAll(strings.ToLower(tactics[tacticID]), " ", "_") + "_" + n
	}
	f, err := os.Create(n)
	if err != nil {
		return err
	}
	defer f.Close()
	if err := tmpl.Execute(f, data); err != nil {
		return err
	}

	emo("%v created %s. Open the file and craft the rule condition, define an optional action, or fill out other attributes", emoji.Rocket, n)

	return nil
}

```

`cmd/fibratus/app/rules/list.go`:

```go
/*
 * Copyright 2021-2022 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package rules

import (
	"fmt"
	"github.com/enescakir/emoji"
	"github.com/jedib0t/go-pretty/v6/table"
	"github.com/rabbitstack/fibratus/internal/bootstrap"
	"os"
	"strings"
)

func listRules() error {
	if err := bootstrap.InitConfigAndLogger(cfg); err != nil {
		return err
	}
	if err := cfg.Filters.LoadFilters(); err != nil {
		return fmt.Errorf("%v %v", emoji.DisappointedFace, err)
	}
	filters := cfg.GetFilters()
	if len(filters) == 0 {
		return fmt.Errorf("%v no rules found in %s", emoji.DisappointedFace, strings.Join(cfg.Filters.Rules.FromPaths, ","))
	}

	t := table.NewWriter()
	t.SetOutputMirror(os.Stdout)
	t.SetStyle(table.StyleLight)

	// render summary
	if summarized {
		t.AppendHeader(table.Row{"Tactic", "# Rules"})
		t.SetColumnConfigs([]table.ColumnConfig{
			{Name: "Tactic", WidthMin: 50, WidthMax: 50},
			{Name: "#", WidthMin: 50, WidthMax: 50},
		})
		tactics := make(map[string]int)
		techniques := make(map[string]int)
		for _, f := range filters {
			tactics[f.Labels["tactic.name"]]++
			techniques[f.Labels["technique.name"]]++
		}
		tot := 0
		for tac, n := range tactics {
			t.AppendRow(table.Row{tac, n})
			tot += n
		}

		t.AppendSeparator()
		t.AppendRow(table.Row{"TECHNIQUE", "# RULES"})
		t.AppendSeparator()

		for tec, n := range techniques {
			t.AppendRow(table.Row{tec, n})
		}

		t.AppendFooter(table.Row{"TOTAL", tot})
	} else {
		// show all rules
		t.AppendHeader(table.Row{"#", "Rule", "Technique", "Tactic"})
		t.SetColumnConfigs([]table.ColumnConfig{
			{Name: "#", WidthMax: 5},
			{Name: "Rule"},
			{Name: "Technique"},
			{Name: "Tactic", WidthMax: 50},
		})

		n := 0
		tactics := make(map[string]int)
		techniques := make(map[string]int)

		for _, f := range filters {
			tac := f.Labels["tactic.name"]
			tec := f.Labels["technique.name"]
			if _, ok := tactics[tac]; !ok {
				tactics[tac] = 1
			}
			if _, ok := tactics[tec]; !ok {
				techniques[tec] = 1
			}
			t.AppendRow(table.Row{n + 1, f.Name, tec, tac})
			n++
		}

		var (
			totTat int
			totTec int
		)

		for _, n := range tactics {
			totTat += n
		}
		for _, n := range techniques {
			totTec += n
		}

		t.AppendFooter(table.Row{"TOTAL", n, totTec, totTat})
	}

	t.Render()

	return nil
}

```

`cmd/fibratus/app/rules/rules.go`:

```go
/*
 * Copyright 2021-2022 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package rules

import (
	"fmt"
	"github.com/rabbitstack/fibratus/pkg/config"
	"github.com/rabbitstack/fibratus/pkg/util/convert"
	"github.com/spf13/cobra"
	"strings"
)

var Command = &cobra.Command{
	Use:   "rules",
	Short: "Validate, list, or search detection rules",
}

var validateCmd = &cobra.Command{
	Use:   "validate",
	Short: "Validate rules for structural and syntactic correctness",
	RunE:  validate,
}

var listCmd = &cobra.Command{
	Use:   "list",
	Short: "List rules",
	RunE:  list,
}

var createCmd = &cobra.Command{
	Use:   "create",
	Short: "Create a new rule template",
	RunE:  create,
}

var cfg = config.NewWithOpts(config.WithValidate(), config.WithList())

var (
	summarized bool
	tacticID   string
)

func init() {
	cfg.MustViperize(Command)

	Command.AddCommand(validateCmd)

	listCmd.PersistentFlags().BoolVarP(&summarized, "summary", "s", false, "Show rules summary by MITRE tactics and techniques")
	Command.AddCommand(listCmd)

	createCmd.PersistentFlags().StringVarP(&tacticID, "tactic-id", "t", "", "Specifies the MITRE tactic identifier for the rule (e.g. TA0001)")
	Command.AddCommand(createCmd)
}

func validate(cmd *cobra.Command, args []string) error {
	return validateRules()
}

func list(cmd *cobra.Command, args []string) error {
	return listRules()
}

func create(cmd *cobra.Command, args []string) error {
	if len(args) == 0 {
		return fmt.Errorf("rule name is required")
	}
	if tacticID != "" && tactics[tacticID] == "" {
		tacts := fmt.Sprintf("Did you mean any of %s?", strings.Join(convert.MapKeysToSlice(tactics), ", "))
		return fmt.Errorf("invalid tactic id: %s. %s", tacticID, tacts)
	}
	return createRule(args[0])
}

func emo(s string, args ...any) { fmt.Printf(s, args...) }

```

`cmd/fibratus/app/rules/validate.go`:

```go
/*
 * Copyright 2021-2022 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package rules

import (
	"fmt"
	"github.com/enescakir/emoji"
	"github.com/rabbitstack/fibratus/internal/bootstrap"
	"github.com/rabbitstack/fibratus/pkg/filter"
	"github.com/rabbitstack/fibratus/pkg/filter/fields"
	"github.com/rabbitstack/fibratus/pkg/rules"
	"path/filepath"
	"strings"
)

type warning struct {
	rule     string
	messages []string
}

func (w *warning) addMessage(msg string) {
	if w.messages == nil {
		w.messages = make([]string, 0)
	}
	w.messages = append(w.messages, msg)
}

func validateRules() error {
	if err := bootstrap.InitConfigAndLogger(cfg); err != nil {
		return err
	}

	isValidExt := func(path string) bool {
		return filepath.Ext(path) == ".yml" || filepath.Ext(path) == ".yaml"
	}
	// load macros and rules
	for _, m := range cfg.Filters.Macros.FromPaths {
		paths, err := filepath.Glob(m)
		if err != nil {
			return err
		}
		for _, path := range paths {
			if !isValidExt(path) {
				continue
			}
			emo("%v Loading macros from %s\n", emoji.Hook, path)
		}
	}
	if err := cfg.Filters.LoadMacros(); err != nil {
		return fmt.Errorf("%v %v", emoji.DisappointedFace, err)
	}

	for _, r := range cfg.Filters.Rules.FromPaths {
		paths, err := filepath.Glob(r)
		if err != nil {
			return err
		}
		for _, path := range paths {
			if !isValidExt(path) {
				continue
			}
			emo("%v Loading rule %s\n", emoji.Package, path)
		}
	}
	if err := cfg.Filters.LoadFilters(); err != nil {
		return fmt.Errorf("%v %v", emoji.DisappointedFace, err)
	}
	if len(cfg.GetFilters()) == 0 {
		return fmt.Errorf("%v no rules found in %s", emoji.DisappointedFace, strings.Join(cfg.Filters.Rules.FromPaths, ","))
	}

	warnings := make([]warning, 0)

	// validate rules
	for _, rule := range cfg.GetFilters() {
		f := filter.New(rule.Condition, cfg)
		err := f.Compile()
		if err != nil {
			return fmt.Errorf("%v %v", emoji.DisappointedFace, rules.ErrInvalidFilter(rule.Name, err))
		}

		w := warning{rule: rule.Name}
		for _, fld := range f.GetFields() {
			if isDeprecated, dep := fields.IsDeprecated(fld.Name); isDeprecated {
				w.addMessage(fmt.Sprintf("%s field deprecated in favor of %v", fld.Name.String(), dep.Fields))
			}
		}

		if !rule.HasLabel("tactic.id") {
			w.addMessage("tactic.id label is missing")
		}
		if !rule.HasLabel("tactic.name") {
			w.addMessage("tactic.name label is missing")
		}
		if !rule.HasLabel("tactic.ref") {
			w.addMessage("tactic.ref label is missing")
		}
		if !rule.HasLabel("technique.id") {
			w.addMessage("technique.id label is missing")
		}
		if !rule.HasLabel("technique.name") {
			w.addMessage("technique.name label is missing")
		}
		if !rule.HasLabel("technique.ref") {
			w.addMessage("technique.ref label is missing")
		}

		if len(w.messages) > 0 {
			warnings = append(warnings, w)
		}
	}

	for _, warn := range warnings {
		emo("%v %d warning(s) in rule %s:\n", emoji.Warning, len(warn.messages), warn.rule)
		for _, msg := range warn.messages {
			fmt.Printf("  %v %s\n", emoji.Warning, msg)
		}
	}

	emo("%v Validation successful. Ready to go!", emoji.Rocket)
	return nil
}

```

`cmd/fibratus/app/run_windows.go`:

```go
/*
 * Copyright 2019-2020 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package app

import (
	"github.com/rabbitstack/fibratus/internal/bootstrap"
	"github.com/rabbitstack/fibratus/pkg/config"
	"github.com/rabbitstack/fibratus/pkg/util/multierror"
	ver "github.com/rabbitstack/fibratus/pkg/util/version"
	"github.com/spf13/cobra"
)

var runCmd = &cobra.Command{
	Use:     "run [filter]",
	Short:   "Bootstrap fibratus or a filament",
	Aliases: []string{"start"},
	RunE:    run,
	Example: `
	# Run without the filter
	fibratus run

	# Run with the filter that drops all but events produced by the svchost.exe process
	fibratus run ps.name = 'svchost.exe'

	# Run with the filter that traps all events that were generated by process that contains the 'svc' string and specific security identifiers
	fibratus run ps.name contains 'svc' and ps.sid in ('S-1-5-18', 'S-1-5-19')

	# Run the top_keys filament
	fibratus run -f top_keys
	`,
}

var (
	// the run command config
	cfg = config.NewWithOpts(config.WithRun())
)

func init() {
	// initialize flags
	cfg.MustViperize(runCmd)
}

func run(cmd *cobra.Command, args []string) error {
	ver.Set(version)
	app, err := bootstrap.NewApp(cfg, bootstrap.WithSignals(), bootstrap.WithDebugPrivilege())
	if err != nil {
		return err
	}
	if err := app.Run(args); err != nil {
		return multierror.Wrap(err, app.Shutdown())
	}
	app.Wait()
	return app.Shutdown()
}

```

`cmd/fibratus/app/service/control_service_windows.go`:

```go
/*
 * Copyright 2019-2020 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package service

import (
	"fmt"
	"github.com/rabbitstack/fibratus/internal/bootstrap"
	log "github.com/sirupsen/logrus"
	"time"

	"github.com/rabbitstack/fibratus/pkg/config"
	"github.com/spf13/cobra"
	"golang.org/x/sys/windows"
	"golang.org/x/sys/windows/svc"
	"golang.org/x/sys/windows/svc/debug"
	"golang.org/x/sys/windows/svc/eventlog"
	"golang.org/x/sys/windows/svc/mgr"
)

var startCommand = &cobra.Command{
	Use:   "start",
	RunE:  startService,
	Short: "Start fibratus service",
}

var stopCommand = &cobra.Command{
	Use:   "stop",
	RunE:  stopService,
	Short: "Stop fibratus service",
}

var restartCommand = &cobra.Command{
	Use:   "restart",
	RunE:  restartService,
	Short: "Restart fibratus service",
}

var Command = &cobra.Command{
	Use:   "service",
	Short: "Install, remove, and control fibratus service",
}

var (
	// Windows service command config
	cfg = config.NewWithOpts(config.WithRun())

	// windows event logger
	evtlog debug.Log

	// bootstrap application
	app *bootstrap.App
)

func init() {
	// initialize service config
	cfg.MustViperize(startCommand)

	Command.AddCommand(startCommand)
	Command.AddCommand(stopCommand)
	Command.AddCommand(restartCommand)
	Command.AddCommand(statusCommand)

	Command.AddCommand(installCommand)
	Command.AddCommand(removeCommand)
}

func startService(cmd *cobra.Command, args []string) error {
	h, err := windows.OpenSCManager(nil, nil, windows.SC_MANAGER_CONNECT)
	if err != nil {
		return fmt.Errorf("couldn't connect to Windows Service Manager: %v", err)
	}
	m := &mgr.Mgr{Handle: h}
	defer func() {
		_ = m.Disconnect()
	}()
	s, err := windows.OpenService(
		m.Handle,
		windows.StringToUTF16Ptr(svcName),
		windows.SERVICE_START|windows.SERVICE_STOP,
	)
	if err != nil {
		return fmt.Errorf("could not open fibratus service: %v", err)
	}
	scm := &mgr.Service{Name: svcName, Handle: s}
	defer func() {
		_ = scm.Close()
	}()
	err = scm.Start()
	if err != nil {
		return fmt.Errorf("could not start fibratus service: %v", err)
	}

	start := time.Now()
	var status svc.Status
	for time.Since(start) > 5*time.Second {
		status, err = scm.Query()
		if err != nil {
			return fmt.Errorf("failed to get fibratus service status: %v", err)
		}

		if status.State == svc.Running {
			return nil
		}
	}
	return nil
}

func stopService(cmd *cobra.Command, args []string) error {
	return stopSvc()
}

func restartService(cmd *cobra.Command, args []string) error {
	if err := stopSvc(); err != nil {
		return err
	}
	return startService(cmd, args)
}

func stopSvc() error {
	h, err := windows.OpenSCManager(nil, nil, windows.SC_MANAGER_CONNECT)
	if err != nil {
		return fmt.Errorf("couldn't connect to Windows Service Manager: %v", err)
	}
	m := &mgr.Mgr{Handle: h}
	defer func() {
		_ = m.Disconnect()
	}()

	s, err := windows.OpenService(
		m.Handle,
		windows.StringToUTF16Ptr(svcName),
		windows.SERVICE_START|windows.SERVICE_STOP|windows.SERVICE_QUERY_STATUS,
	)
	if err != nil {
		return fmt.Errorf("could not open fibratus service: %v", err)
	}
	scm := &mgr.Service{Name: svcName, Handle: s}
	defer func() {
		_ = scm.Close()
	}()

	status, err := scm.Control(svc.Stop)
	if err != nil {
		return fmt.Errorf("couldn't stop fibratus service: %v", err)
	}
	timeout := time.Now().Add(10 * time.Second)
	for status.State != svc.Stopped {
		if timeout.Before(time.Now()) {
			return fmt.Errorf("timeout waiting for service to go to state=%d", svc.Stopped)
		}
		time.Sleep(300 * time.Millisecond)
		status, err = scm.Query()
		if err != nil {
			return fmt.Errorf("could not retrieve service status: %v", err)
		}
	}
	return nil
}

type fsvc struct{}

func (s *fsvc) Execute(args []string, r <-chan svc.ChangeRequest, changes chan<- svc.Status) (bool, uint32) {
	const cmdsAccepted = svc.AcceptStop | svc.AcceptShutdown
	changes <- svc.Status{State: svc.StartPending}
	changes <- svc.Status{State: svc.Running, Accepts: cmdsAccepted}

	if err := s.run(); err != nil {
		_ = evtlog.Error(0xc000000B, err.Error())
		changes <- svc.Status{State: svc.Stopped}
		return false, 1
	}

loop:
	for {
		c := <-r
		switch c.Cmd {
		case svc.Interrogate:
			changes <- c.CurrentStatus
			time.Sleep(100 * time.Millisecond)
			changes <- c.CurrentStatus
		case svc.Stop:
			break loop
		case svc.Shutdown:
			break loop
		}
	}

	changes <- svc.Status{State: svc.StopPending}
	if app != nil {
		_ = app.Shutdown()
	}
	changes <- svc.Status{State: svc.Stopped}

	return true, 0
}

func (s *fsvc) run() error {
	var err error
	app, err = bootstrap.NewApp(cfg, bootstrap.WithDebugPrivilege())
	if err != nil {
		return err
	}
	return app.Run(nil)
}

// Run runs the service handler.
func Run() {
	var err error
	evtlog, err = eventlog.Open(svcName)
	if err != nil {
		return
	}
	defer func() {
		_ = evtlog.Close()
	}()

	err = svc.Run(svcName, &fsvc{})
	if err != nil {
		log.Error(err)
		_ = evtlog.Error(0xc0000008, err.Error())
		return
	}
}

```

`cmd/fibratus/app/service/install_service_windows.go`:

```go
/*
 * Copyright 2019-2020 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package service

import (
	"errors"
	"fmt"
	"github.com/spf13/cobra"
	"golang.org/x/sys/windows/svc/eventlog"
	"golang.org/x/sys/windows/svc/mgr"
	"os"
)

const svcName = "fibratus"

// ErrServiceAlreadyInstalled indicates the fibratus service is already installed
var ErrServiceAlreadyInstalled = errors.New("fibratus service is already installed")

var installCommand = &cobra.Command{
	Use:   "install",
	Short: "Install fibratus within the Windows service control manager",
	RunE:  installService,
}

func installService(cmd *cobra.Command, args []string) error {
	exe, err := os.Executable()
	if err != nil {
		return err
	}
	m, err := mgr.Connect()
	if err != nil {
		return err
	}
	defer func() {
		_ = m.Disconnect()
	}()
	s, err := m.OpenService(svcName)
	if err == nil {
		if err := s.Close(); err != nil {
			return err
		}
		return ErrServiceAlreadyInstalled
	}

	svccfg := mgr.Config{
		DisplayName: "Fibratus Service",
		Description: "Adversary tradecraft detection, protection, and hunting",
		StartType:   mgr.StartAutomatic,
	}
	s, err = m.CreateService(svcName, exe, svccfg)
	if err != nil {
		return err
	}
	defer func() {
		_ = s.Close()
	}()

	err = eventlog.InstallAsEventCreate(svcName, eventlog.Error|eventlog.Warning|eventlog.Info)
	if err != nil {
		if err := s.Delete(); err != nil {
			return err
		}
		return fmt.Errorf("couldn't create event log record: %v", err)
	}
	return nil
}

```

`cmd/fibratus/app/service/remove_service_windows.go`:

```go
/*
 * Copyright 2019-2020 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package service

import (
	"errors"
	"fmt"
	"github.com/spf13/cobra"
	"golang.org/x/sys/windows/svc/eventlog"
	"golang.org/x/sys/windows/svc/mgr"
)

var removeCommand = &cobra.Command{
	Use:   "remove",
	Short: "Remove fibratus from the Windows service control manager",
	RunE:  removeService,
}

var errServiceNotInstalled = errors.New("fibratus service is not installed")

func removeService(cmd *cobra.Command, args []string) error {
	m, err := mgr.Connect()
	if err != nil {
		return err
	}
	defer func() {
		_ = m.Disconnect()
	}()
	s, err := m.OpenService(svcName)
	if err != nil {
		return errServiceNotInstalled
	}
	defer func() {
		_ = s.Close()
	}()
	err = s.Delete()
	if err != nil {
		return err
	}
	err = eventlog.Remove(svcName)
	if err != nil {
		return fmt.Errorf("couldn't create eventlog remove record: %v", err)
	}
	return nil
}

```

`cmd/fibratus/app/service/status_service_windows.go`:

```go
/*
 * Copyright 2021-2022 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package service

import (
	"fmt"
	"github.com/spf13/cobra"
	"golang.org/x/sys/windows/svc"
	"golang.org/x/sys/windows/svc/mgr"
)

var statusCommand = &cobra.Command{
	Use:   "status",
	Short: "Check the status of the Fibratus service",
	RunE:  statusService,
}

func statusService(cmd *cobra.Command, args []string) error {
	m, err := mgr.Connect()
	if err != nil {
		return err
	}
	defer func() {
		_ = m.Disconnect()
	}()
	s, err := m.OpenService(svcName)
	if err != nil {
		fmt.Printf("Fibratus service is not installed")
		return nil
	}
	defer func() {
		s.Close()
	}()
	status, err := s.Query()
	if err != nil {
		return err
	}
	if status.State != svc.Running {
		fmt.Printf("Fibratus service is not running")
		return nil
	}
	fmt.Printf("Fibratus service is running")
	return nil
}

```

`cmd/fibratus/app/stats/stats.go`:

```go
/*
 * Copyright 2019-2020 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package stats

import (
	"encoding/json"
	"github.com/rabbitstack/fibratus/internal/bootstrap"
	"os"
	"reflect"

	"github.com/jedib0t/go-pretty/v6/table"
	"github.com/rabbitstack/fibratus/pkg/config"
	errs "github.com/rabbitstack/fibratus/pkg/errors"
	"github.com/rabbitstack/fibratus/pkg/util/rest"
	"github.com/spf13/cobra"
)

var Command = &cobra.Command{
	Use:   "stats",
	Short: "Show runtime stats",
	RunE:  stats,
}

var cfg = config.NewWithOpts(config.WithStats())

func init() {
	cfg.MustViperize(Command)
}

// Stats stores runtime statistics that are retrieved from the expvar endpoint.
type Stats struct {
	AggregatorBatchEvents               int            `json:"aggregator.batch.events"`
	AggregatorFlushesCount              int            `json:"aggregator.flushes.count"`
	AggregatorEventErrors               int            `json:"aggregator.event.errors"`
	AggregatorTransformerErrors         map[string]int `json:"aggregator.transformer.errors"`
	AggregatorWorkerClientPublishErrors int            `json:"aggregator.worker.client.publish.errors"`
	FilamentDictErrors                  int            `json:"filament.dict.errors"`
	FilamentEventBatchFlushes           int            `json:"filament.event.batch.flushes"`
	FilamentEventErrors                 map[string]int `json:"filament.event.errors"`
	FilamentEventProcessErrors          int            `json:"filament.event.process.errors"`
	FilterAccessorErrors                map[string]int `json:"filter.accessor.errors"`
	FsFileObjectHandleHits              int            `json:"fs.file.object.handle.hits"`
	FsFileObjectMisses                  int            `json:"fs.file.object.misses"`
	FsFileReleases                      int            `json:"fs.file.releases"`
	FsTotalRundownFiles                 int            `json:"fs.total.rundown.files"`
	HandleDeferredEvictions             int            `json:"handle.deferred.evictions"`
	HandleNameQueryFailures             map[string]int `json:"handle.name.query.failures"`
	HandleSnapshotCount                 int            `json:"handle.snapshot.count"`
	HandleSnapshotBytes                 int            `json:"handle.snapshot.bytes"`
	HandleTypesCount                    int            `json:"handle.types.count"`
	HandleTypeNameMisses                int            `json:"handle.type.name.misses"`
	HandleWaitTimeouts                  int            `json:"handle.wait.timeouts"`
	HostnameErrors                      map[string]int `json:"hostname.errors"`
	CapFlusherErrors                    map[string]int `json:"cap.flusher.errors"`
	CapHandleWriteErrors                int            `json:"cap.handle.write.errors"`
	CapEventUnmarshalErrors             int            `json:"cap.event.unmarshal.errors"`
	CapEventWriteErrors                 int            `json:"cap.event.write.errors"`
	CapEventSourceConsumerErrors        int            `json:"cap.eventsource.consumer.errors"`
	CapOverflowErrors                   int            `json:"cap.overflow.errors"`
	CapReadBytes                        int            `json:"cap.read.bytes"`
	CapReadEvents                       int            `json:"cap.read.events"`
	CapReaderDroppedByFilter            int            `json:"cap.reader.dropped.by.filter"`
	CapReaderHandleUnmarshalErrors      int            `json:"cap.reader.handle.unmarshal.errors"`
	EventProcessorFailures              int            `json:"event.processor.failures"`
	EventSeqInitErrors                  map[string]int `json:"event.seq.init.errors"`
	EventSeqStoreErrors                 int            `json:"event.seq.store.errors"`
	EventTimestampUnmarshalErrors       int            `json:"event.timestamp.unmarshal.errors"`
	EventSourceBuffersRead              int            `json:"eventsource.buffers.read"`
	EventSourceEventsEnqueued           int            `json:"eventsource.events.enqueued"`
	EventSourceEventsDequeued           int            `json:"eventsource.events.dequeued"`
	EventSourceUnknownEvents            int            `json:"eventsource.events.unknown"`
	EventSourceEventsProcessed          int            `json:"eventsource.events.processed"`
	EventSourceExcludedEvents           int            `json:"eventsource.excluded.events"`
	EventSourceEventsFailures           map[string]int `json:"eventsource.events.failures"`
	LoggerErrors                        map[string]int `json:"logger.errors"`
	OutputAMQPChannelFailures           int            `json:"output.amqp.channel.failures"`
	OutputAMQPConnectionFailures        int            `json:"output.amqp.connection.failures"`
	OutputAMQPPublishErrors             int            `json:"output.amqp.publish.errors"`
	OutputConsoleErrors                 int            `json:"output.console.errors"`
	OutputNullBlackholeEvents           int            `json:"output.null.blackhole.events"`
	PeSkippedImages                     int            `json:"pe.skipped.images"`
	PeDirectoryParseErrors              int            `json:"pe.directory.parse.errors"`
	PeVersionResourcesParseErrors       int            `json:"pe.version.resources.parse.errors"`
	ProcessCount                        int            `json:"process.count"`
	ProcessModuleCount                  int            `json:"process.module.count"`
	ProcessLookupFailureCount           map[int]int    `json:"process.lookup.failure.count"`
	ProcessPebReadErrors                int            `json:"process.peb.read.errors"`
	ProcessReaped                       int            `json:"process.reaped"`
	ProcessThreadCount                  int            `json:"process.thread.count"`
	RegistryKcbCount                    int            `json:"registry.kcb.count"`
	RegistryKcbMisses                   int            `json:"registry.kcb.misses"`
	RegistryKeyHandleHits               int            `json:"registry.key.handle.hits"`
	RegistryUnknownKeysCount            int            `json:"registry.unknown.keys.count"`
	StackwalkEnqueued                   int            `json:"stackwalk.enqueued"`
	StackwalkFlushes                    int            `json:"stackwalk.flushes"`
	StackwalkFlushesProcs               map[string]int `json:"stackwalk.flushes.procs"`
	StackwalkFlushesEvents              map[string]int `json:"stackwalk.flushes.events"`
	YaraImageScans                      int            `json:"yara.image.scans"`
	YaraProcScans                       int            `json:"yara.proc.scans"`
	YaraRuleMatches                     int            `json:"yara.rule.matches"`
}

func stats(cmd *cobra.Command, args []string) error {
	if err := bootstrap.InitConfigAndLogger(cfg); err != nil {
		return err
	}
	c := cfg.API
	body, err := rest.Get(rest.WithTransport(c.Transport), rest.WithURI("debug/vars"))
	if err != nil {
		return errs.ErrHTTPServerUnavailable(c.Transport, err)
	}
	var stats Stats
	if err := json.Unmarshal(body, &stats); err != nil {
		return err
	}

	t := table.NewWriter()
	t.SetOutputMirror(os.Stdout)
	t.AppendHeader(table.Row{"Name", "Value"})
	t.SetStyle(table.StyleLight)

	typ := reflect.TypeOf(stats)
	val := reflect.ValueOf(stats)

	for i := 0; i < typ.NumField(); i++ {
		f := typ.Field(i)
		tag := f.Tag.Get("json")

		if tag == "" {
			continue
		}
		if !val.Field(i).CanInterface() {
			continue
		}
		t.AppendRow(table.Row{tag, val.Field(i).Interface()})
	}

	t.Render()

	return nil
}

```

`cmd/fibratus/app/version.go`:

```go
/*
 * Copyright 2019-2020 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package app

import (
	v "github.com/rabbitstack/fibratus/pkg/util/version"
	"github.com/spf13/cobra"
)

var (
	version string // version string
	commit  string // commit hash
	date    string // build date
)

func init() {
	v.Set(version)
}

var versionCmd = &cobra.Command{
	Use:   "version",
	Short: "Show version info",
	Run: func(cmd *cobra.Command, args []string) {
		v.New(version, commit, date).Render()
	},
}

```

`cmd/fibratus/fibratus.exe.manifest`:

```manifest
<assembly xmlns="urn:schemas-microsoft-com:asm.v1" manifestVersion="1.0">
  <trustInfo xmlns="urn:schemas-microsoft-com:asm.v3">
    <security>
      <requestedPrivileges>
        <requestedExecutionLevel level="asInvoker" uiAccess="false"></requestedExecutionLevel>
      </requestedPrivileges>
    </security>
  </trustInfo>
</assembly>
```

`cmd/fibratus/fibratus.rc`:

```rc
#include "version.h"
#define RT_MANIFEST 24

IDI_APP_ICON ICON "fibratus.ico"

#define VS_VERSION_INFO 1
VS_VERSION_INFO VERSIONINFO
 FILEVERSION RC_FILE_VERSION
 PRODUCTVERSION RC_FILE_VERSION
 FILEFLAGSMASK 0x3fL
#ifdef _DEBUG
 FILEFLAGS 0x1L
#else
 FILEFLAGS 0x0L
#endif
 FILEOS 0x40004L
 FILETYPE 0x0L
 FILESUBTYPE 0x0L
BEGIN
    BLOCK "StringFileInfo"
    BEGIN
        BLOCK "040904b0"
        BEGIN
            VALUE "CompanyName", "Fibratus"
            VALUE "FileDescription", "Adversary tradecraft detection, protection, and hunting"
            VALUE "FileVersion", FILE_VERSION_STRING
            VALUE "InternalName", "fibratus"
            VALUE "LegalCopyright", "Copyright (C) 2019-2024"
            VALUE "OriginalFilename", "fibratus.exe"
            VALUE "ProductName", "Fibratus"
            VALUE "ProductVersion", FILE_VERSION_STRING
        END
    END
    BLOCK "VarFileInfo"
    BEGIN
        VALUE "Translation", 0x409, 1200
    END
END

1 RT_MANIFEST "fibratus.exe.manifest"

```

`cmd/fibratus/main_windows.go`:

```go
/*
 * Copyright 2019-2020 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package main

import (
	"fmt"
	"github.com/rabbitstack/fibratus/cmd/fibratus/app"
	"github.com/rabbitstack/fibratus/cmd/fibratus/app/service"
	"golang.org/x/sys/windows/svc"
	"os"
)

func main() {
	// determine if we are running as a Windows Service
	isWinService, err := svc.IsWindowsService()
	if err != nil {
		fmt.Printf("interactive session check failed: %v\n", err)
		os.Exit(-1)
	}
	if isWinService {
		service.Run()
		return
	}
	if err := app.RootCmd.Execute(); err != nil {
		os.Exit(-1)
	}
}

```

`cmd/fibratus/version.h`:

```h
#define RC_FILE_VERSION RC_VER,0

#define STRINGIFY(x) #x
#define TO_STRING(x) STRINGIFY(x)

#define FILE_VERSION_STRING TO_STRING(VER)

```

`cmd/systray/fibratus-systray.exe.manifest`:

```manifest
<assembly xmlns="urn:schemas-microsoft-com:asm.v1" manifestVersion="1.0">
  <trustInfo xmlns="urn:schemas-microsoft-com:asm.v3">
    <security>
      <requestedPrivileges>
        <requestedExecutionLevel level="asInvoker" uiAccess="false"></requestedExecutionLevel>
      </requestedPrivileges>
    </security>
  </trustInfo>
</assembly>

```

`cmd/systray/fibratus-systray.rc`:

```rc
#include "version.h"
#define RT_MANIFEST 24

IDI_APP_ICON ICON "fibratus.ico"

#define VS_VERSION_INFO 1
VS_VERSION_INFO VERSIONINFO
 FILEVERSION RC_FILE_VERSION
 PRODUCTVERSION RC_FILE_VERSION
 FILEFLAGSMASK 0x3fL
#ifdef _DEBUG
 FILEFLAGS 0x1L
#else
 FILEFLAGS 0x0L
#endif
 FILEOS 0x40004L
 FILETYPE 0x0L
 FILESUBTYPE 0x0L
BEGIN
    BLOCK "StringFileInfo"
    BEGIN
        BLOCK "040904b0"
        BEGIN
            VALUE "CompanyName", "Fibratus"
            VALUE "FileDescription", "Fibratus"
            VALUE "FileVersion", FILE_VERSION_STRING
            VALUE "InternalName", "fibratus"
            VALUE "LegalCopyright", "Copyright (C) 2019-2024"
            VALUE "OriginalFilename", "fibratus-systray.exe"
            VALUE "ProductName", "Fibratus"
            VALUE "ProductVersion", FILE_VERSION_STRING
        END
    END
    BLOCK "VarFileInfo"
    BEGIN
        VALUE "Translation", 0x409, 1200
    END
END

1 RT_MANIFEST "fibratus-systray.exe.manifest"

```

`cmd/systray/main_windows.go`:

```go
/*
 * Copyright 2021-2022 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package main

import (
	"encoding/json"
	"errors"
	"fmt"
	"io"
	"net"
	"os"
	"path/filepath"
	"unsafe"

	"github.com/Microsoft/go-winio"
	"github.com/mitchellh/mapstructure"
	"github.com/rabbitstack/fibratus/pkg/alertsender"
	"github.com/rabbitstack/fibratus/pkg/alertsender/systray"
	"github.com/rabbitstack/fibratus/pkg/sys"
	"github.com/rabbitstack/fibratus/pkg/util/log"
	"github.com/rabbitstack/fibratus/pkg/util/signals"
	"github.com/sirupsen/logrus"
	"golang.org/x/sys/windows"
)

const systrayPipe = `\\.\pipe\fibratus-systray`

type MsgType uint8

const (
	Config MsgType = iota
	Balloon
)

var (
	className  = windows.StringToUTF16Ptr("fibratus")
	alertTitle = "Malicious Activity Detected"
)

// Msg represents the data exchanged between systray client/server.
type Msg struct {
	Type MsgType `json:"type"`
	Data any     `json:"data"`
}

func (m Msg) decode(output any) error {
	var decoderConfig = &mapstructure.DecoderConfig{
		Metadata:         nil,
		Result:           output,
		WeaklyTypedInput: true,
		DecodeHook: mapstructure.ComposeDecodeHookFunc(
			mapstructure.StringToTimeDurationHookFunc(),
			mapstructure.StringToSliceHookFunc(","),
			alertsender.StringToSeverityDecodeHook(),
		),
	}
	decoder, err := mapstructure.NewDecoder(decoderConfig)
	if err != nil {
		return err
	}
	return decoder.Decode(m.Data)
}

type Systray struct {
	systrayIcon *sys.SystrayIcon
	window      sys.Hwnd
	config      systray.Config
	quit        chan struct{}
}

func newSystray() (*Systray, error) {
	var mod windows.Handle
	err := windows.GetModuleHandleEx(0, nil, &mod)
	if err != nil {
		return nil, err
	}

	tray := &Systray{quit: signals.Install()}

	hwnd, err := tray.createNotifyIconWindow(mod)
	if err != nil {
		return nil, err
	}
	tray.window = hwnd
	tray.systrayIcon, err = sys.NewSystrayIcon(hwnd)
	if err != nil {
		return nil, err
	}
	ico, err := tray.loadIconFromResource(mod)
	if err != nil {
		return nil, err
	}
	if err := tray.systrayIcon.SetIcon(sys.Hicon(ico)); err != nil {
		return nil, fmt.Errorf("unable to set systray icon: %v", err)
	}
	if err := tray.systrayIcon.SetTooltip("Fibratus"); err != nil {
		return nil, fmt.Errorf("unable to set systray icon tooltip: %v", err)
	}

	return tray, nil
}

func (s *Systray) shutdown() error {
	if s.window.IsValid() {
		s.window.Destroy()
	}
	return s.systrayIcon.Delete()
}

func (s *Systray) createNotifyIconWindow(mod windows.Handle) (sys.Hwnd, error) {
	// register notification icon window class
	var wc sys.WndClassEx
	wc.Size = uint32(unsafe.Sizeof(wc))
	wc.Instance = mod
	wc.WndProc = windows.NewCallback(s.wndProc)
	wc.ClassName = className
	err := sys.RegisterClass(&wc)
	if err != nil {
		return sys.InvalidHwnd, err
	}
	// create the notification icon window
	hwnd, err := sys.CreateWindowEx(
		0,
		className,
		className,
		sys.WindowStyleOverlapped,
		sys.CwUseDefault,
		sys.CwUseDefault,
		100,
		100,
		0,
		0,
		mod,
		0,
	)
	if err != nil {
		return sys.InvalidHwnd, err
	}
	return hwnd, nil
}

func (s *Systray) loadIconFromResource(mod windows.Handle) (windows.Handle, error) {
	// find the icon in the same directory where the binary is loaded
	exe, err := os.Executable()
	if err != nil {
		return windows.InvalidHandle, err
	}
	ico, err := sys.LoadImage(
		mod,
		windows.StringToUTF16Ptr(filepath.Join(filepath.Dir(exe), "fibratus.ico")),
		1, // load icon
		0,
		0,
		sys.LoadResourceDefaultSize|sys.LoadResourceFromFile,
	)
	if err != nil {
		// load stock informational system icon
		var icon sys.ShStockIcon
		icon.Size = uint32(unsafe.Sizeof(icon))
		err := sys.SHGetStockIconInfo(79, 0x000000100, &icon)
		if err != nil {
			return windows.InvalidHandle, fmt.Errorf("unable to load systray icon resource: %v", err)
		}
		ico = windows.Handle(icon.Icon)
	}
	return ico, nil
}

func (s *Systray) handlePipeClient(conn net.Conn) {
	defer conn.Close()
	buf, err := io.ReadAll(conn)
	if err != nil {
		if err != io.EOF {
			logrus.Errorf("pipe read: %v", err)
		}
	}
	if len(buf) == 0 {
		return
	}
	var m Msg
	err = json.Unmarshal(buf, &m)
	if err != nil {
		logrus.Error(err)
		return
	}
	err = s.handleMessage(m)
	if err != nil {
		logrus.Error(err)
	}
}

func (s *Systray) handleMessage(m Msg) error {
	switch m.Type {
	case Config:
		var c systray.Config
		err := m.decode(&c)
		if err != nil {
			logrus.Errorf("unable to decode systray server config: %v", err)
			return err
		}
		s.config = c
	case Balloon:
		var alert alertsender.Alert
		err := m.decode(&alert)
		if err != nil {
			logrus.Errorf("unable to decode alert: %v", err)
			return err
		}
		return s.systrayIcon.ShowBalloonNotification(alertTitle, alert.Title, s.config.Sound, s.config.QuietMode)
	}
	return nil
}

func main() {
	err := log.InitFromConfig(log.Config{Level: "info", LogStdout: true, Formatter: "text"}, "fibratus-systray.log")
	if err != nil {
		fmt.Printf("%v", err)
		os.Exit(1)
	}
	logrus.Info("starting systray server...")
	// spin up the named-pipe server
	l, err := winio.ListenPipe(systrayPipe, nil)
	if err != nil {
		logrus.Fatalf("unable to listen on named pipe: %s: %v", systrayPipe, err)
	}

	tray, err := newSystray()
	if err != nil {
		logrus.Fatalf("unable to create systray: %v", err)
	}

	go func() {
		<-tray.quit
		logrus.Info("shutting down...")
		l.Close()
		err := tray.shutdown()
		if err != nil {
			logrus.Warnf("fail to shutdown: %v", err)
		}
	}()

	// server loop
	for {
		conn, err := l.Accept()
		if err != nil {
			if errors.Is(err, winio.ErrPipeListenerClosed) {
				break
			}
			continue
		}
		go tray.handlePipeClient(conn)
	}
}

func (s *Systray) wndProc(hwnd uintptr, msg uint32, wparam, lparam uintptr) uintptr {
	if msg == sys.WmClose {
		s.quit <- struct{}{}
	}
	return sys.DefWindowProc(hwnd, msg, wparam, lparam)
}

```

`cmd/systray/version.h`:

```h
#define RC_FILE_VERSION RC_VER,0

#define STRINGIFY(x) #x
#define TO_STRING(x) STRINGIFY(x)

#define FILE_VERSION_STRING TO_STRING(VER)

```

`configs/fibratus.json`:

```json
{
  "aggregator": {
    "flush-period": "500ms",
    "flush-timeout": "4s"
  },

  "alertsenders": {
    "mail": {
      "enabled": false
    },

    "slack": {
      "enabled": false
    }
  },

  "api": {
    "transport": "localhost:8090",
    "timeout": "5s"
  },

  "debug-privilege": true,

  "filament": {
    "name": "",
    "flush-period": "200ms"
  },

  "handle": {
    "init-snapshot": true
  },

  "event": {

  },

  "cap": {

  },

  "eventsource": {},
  "logging": {},

  "output": {
    "console": {
      "enabled": true,
      "format": "pretty",
      "kv-delimiter": "->"
    }
  },

  "pe": {},
  "transformers": {},
  "yara": {}
}
```

`configs/fibratus.yml`:

```yml
###################### Fibratus Configuration File #####################################

# =============================== Aggregator ==========================================

# Aggregator is responsible for creating event batches, applying transformers to each event
# present in the batch, and forwarding those batches to the output sinks.
aggregator:
  # Determines the flush period that triggers the flushing of the event batches to output sinks
  flush-period: 500ms

  # Represents the max time to wait before announcing failed flushing of enqueued events when fibratus
  # is stopped
  flush-timeout: 4s

# =============================== Alert senders ========================================

# Alert senders deal with emitting alerts via different channels.
alertsenders:
  # Systray sender sends alerts as notifications to the taskbar status area.
  systray:
    # Enables/disables systray alert sender
    enabled: false

    # Indicates if the associated sound is played when the balloon notification is shown
    sound: true

    # Instructs not to display the balloon notification if the current user is in quiet time.
    # During this time, most notifications should not be sent or shown. This lets a user become
    # accustomed to a new computer system without those distractions. Quiet time also occurs for
    # each user after an operating system upgrade or clean installation.
    quiet-mode: false

  # Mail sender transports the alerts via SMTP protocol.
  mail:
    # Enables/disables mail alert sender
    enabled: false

    # Represents the host of the SMTP server
    #host:

    # Represents the port of the SMTP server
    #port: 587

    # Specifies the username when authenticating to the SMTP server
    #user:

    # Specifies the password when authenticating to the SMTP server
    #password:

    # Specifies the sender's address
    #from:

    # Specifies all the recipients that'll receive the alert
    #to:

    # Specifies the email body content type
    #content-type: text/html

    # Indicates if the alert is rendered with HTML template
    #use-template: true

  # Slack sender transports the alerts to the Slack workspace.
  slack:
    # Enables/disables Slack alert sender
    enabled: false

    # Represents the Webhook URL of the workspace where alerts will be dispatched
    #url:

    # Designates the Slack workspace where alerts will be routed
    #workspace:

    # Is the Slack channel in which to post alerts
    #channel:

    # Represents the emoji icon surrounded in ':' characters for the Slack bot
    #emoji: ""

  # Event Log sender transports alerts to the Windows Event Log.
  eventlog:
    # Enables/disables the event log sender
    enabled: true

    # Enables/disables the verbose mode. In verbose mode, the full event
    # context, including all parameters and the process information are included
    # in the log message.
    verbose: true

     # Specifies the eventlog record format for the alert. Can be pretty|json
    format: pretty

# =============================== API ==================================================

# Settings that influence the behaviour of the HTTP server that exposes a number of endpoints such as
# expvar metrics, internal state, and so on
api:
  # Specifies the underlying transport protocol for the API HTTP server. The transport can either be the
  # named pipe or TCP socket. Default is named pipe but you can override it to expose the API server on
  # TCP address, e.g. 192.168.1.32:8084.
  transport: localhost:8482

  # Represents the timeout interval for the HTTP server responses.
  timeout: 5s

# =============================== General ==============================================

# Indicates whether debug privilege is set in Fibratus process' token. Enabling this security policy allows
# Fibratus to obtain handles of protected processes for the purpose of querying the Process Environment Block
# regions.
debug-privilege: true

# Indicates if event forwarding mode is engaged.
forward: false

# =============================== Filament =============================================

# Filaments are lightweight Python scriplets that are executed on top of the event stream. You can easily
# extend Fibratus with custom features that is encapsulated in filaments. This section controls the behaviour of
# the filament engine.
filament:
  # Specifies the name of the filament that is executed by the run command
  name: ""

  # The directory where all filaments are located. By default, filaments are stored in the ${PROGRAMFILES}/fibratus/filaments directory.
  #path: ${PROGRAMFILES}/fibratus/filaments

  # Determines how often event batches are propagated to the filament callback function
  #flush-period: 200ms

# =============================== Filters ===============================================

# Contains the definition of detection rules. Rules are contained within rule YAML files.
# Rule definitions can reside in the local file system or also can be served over HTTP/S.
# For local file system rule paths, it is possible to use the glob expression to load the
# rules from different directory locations.
filters:
  # Indicates if the rule engine match all strategy is enabled. When the match all strategy
  # is enabled, a single event can trigger multiple rules.
  match-all: true

  rules:
    # Indicates if the rule engine is enabled and rules loaded
    enabled: true

    # The list of file system paths were rule files are located. Supports glob expressions in path names.
    from-paths:
     # - C:\Program Files\Fibratus\Rules\*.yml
    #from-urls:
  macros:
    # The list of file system paths were macro library files are located. Supports glob expressions in path names.
    from-paths:
      #- C:\Program Files\Fibratus\Rules\Macros\*.yml

# =============================== Handle ===============================================

handle:
  # Indicates whether initial handle snapshot is built. The snapshot contains the state of system handles.
  init-snapshot: false
  # Indicates if process handles are collected during startup or when a new process is spawn.
  enumerate-handles: false

# =============================== Evasion ====================================================

# Tweaks for controlling evasion scanner behaviours. Evasion behaviours can represent strong
# IoC (Indicators of Compromise) such as direct syscall or require a combination of fine-tune
# exceptions to reduce the alert fatigue.
evasion:
  # Indicates if evasion detections are enabled global-wise. If disabled, evasion scanner will
  # not try to classify ad-hoc evasion techniques.
  enabled: true

  # Indicates if direct syscall evasion detection is enabled. A direct syscall bypasses Windows
  # API functions and calls the underlying system call directly using the syscall instruction,
  # skipping the NTDLL stub that normally performs the transition to kernel mode.
  #enable-direct-syscall: true

  # Indicates if indirect syscall evasion detection is enabled. Indirect syscall evasion refers
  # to executing the syscall instruction by diverting the execution flow into a legitimate, clean
  # ntdll stub that performs the syscall on process behalf.
  #enable-indirect-syscall: true

# =============================== Event ===============================================

# The following settings control the state of the event.
event:
  # Indicates if threads are serialized as part of the process state
  serialize-threads: false

  # Indicates if modules such as Dynamic Linked Libraries are serialized as part of the process state
  serialize-images: false

  # Indicates if handles are serialized as part of the process state
  serialize-handles: false

  # Indicates if PE (Portable Executable) metadata are serialized as part of the process state
  serialize-pe: false

  # Indicates if environment variables are serialized as part of the process state
  serialize-envs: false

# =============================== Capture =================================================

# Contains the settings that dictate the behaviour of the captures.

cap:
  # Specifies the name of the output cap file. If not empty, capture files are always stored
  # to this file by overwriting any existing capture file
  file: ""

# =============================== Event source ==============================================

# Tweaks for controlling the behaviour of the event source.
eventsource:
  # Determines the maximum number of buffers allocated for the event tracing session's buffer pool
  #max-buffers:

  # Determines the minimum number of buffers allocated for the event tracing session's buffer pool
  #min-buffers:

  # Specifies how often the trace buffers are forcibly flushed
  #flush-interval: 1s

  # Represents the amount of memory allocated for each event tracing session buffer, in kilobytes.
  # The buffer size affects the rate at which buffers fill and must be flushed (small buffer size requires
  # less memory but it increases the rate at which buffers must be flushed)
  #buffer-size:

  # Determines whether thread events are collected by Kernel Logger provider
  #enable-thread: true

  # Determines whether registry events are collected by Kernel Logger provider
  #enable-registry: true

  # Determines whether network events are collected by Kernel Logger provider
  #enable-net: true

  # Determines whether file events are collected by Kernel Logger provider
  #enable-fileio: true

  # Determines whether VA map/unmap events are collected by Kernel Logger provider
  #enable-vamap: true

  # Determines whether image events are collected by Kernel Logger provider
  #enable-image: true

  # Determines whether object manager events (handle creation/destruction) are
  # collected by Kernel Logger provider
  #enable-handle: false

  # Determines whether memory manager events are collected by Kernel Logger provider
  #enable-mem: true

  # Determines whether Audit API calls events are collected
  #enable-audit-api: true

  # Determines whether DNS client events are collected
  #enable-dns: true

  # Determines whether thread pool events are collected
  #enable-threadpool: true

  # Indicates if stack enrichment is enabled for eligible events
  #stack-enrichment: true

  # Determines which events are dropped either by the event name or the process' image
  # name that triggered the event.
  blacklist:
    # Contains a list of event names that are dropped from the event stream
    events:
      - CloseFile
      - RegCloseKey
    # Contains a list of case-sensitive process image names including the extension.
    # Any event originated by the image specified in this list is dropped from the event stream
    # images:
      # - System

# =============================== Logging ================================================

# Contains the tweaks for fine-tuning the behaviour of the log files produced by Fibratus.
logging:
  # Specifies the minimum allowed log level. Anything logged below this log level will
  # not get dumped to a file or stdout stream
  level: info

  # Represents the maximum number of days to retain old log files based on the timestamp
  # encoded in their filename. By default, all log files are retained
  # max-age: 0

  # Specifies the maximum number of old log files to retain
  #max-backups: 15

  # Specifies the maximum size in megabytes of the log file before it gets rotated
  #max-size: 100

  # Represents the log file format. By default, Fibratus will dump the logs in JSON format
  #formatter: json

  # Represents the alternative paths for storing the logs. Logs are usually stored in the
  # same directory where Fibratus was installed
  #path:

  # Indicates whether log lines are written to standard output in addition to writing them to log files
  #log-stdout: false


# =============================== Output ================================================

# Outputs transport the event flowing through event stream to its final destination. Only one output
# can be active at the time. The following section contains available outputs and their preferences.
output:
  # Console output writes the event to standard output stream.
  console:
    # Indicates whether the console output is active
    enabled: true

    # Specifies the console output format. The "pretty" format dictates that formatting is accomplished
    # by replacing the specifiers in the template. The "json" format outputs the event as a raw JSON string
    format: pretty

    # Template that's feed into event formatter. The default event formatter template is:
    #
    # {{ .Seq }} {{ .Timestamp }} - {{ .CPU }} {{ .Process }} ({{ .Pid }}) - {{ .Type }} ({{ .Params }})
    #
    #template:

    # Specifies the separator that's rendered between the event parameter's key and its value.
    #kv-delimiter:

  # Elasticsearch output indexes event bulks into Elasticsearch clusters.
  elasticsearch:
    # Indicates whether the Elasticsearch output is enabled
    enabled: false

    # Defines the URL endpoints of the Elasticsearch nodes
    #servers:
    #  - http://localhost:9200

    # Represents the initial HTTP connection timeout
    #timeout: 5s

    # Specifies when to flush the bulk at the end of the given interval
    #flush-period: 1s

    # Determines the number of workers that commit docs to Elasticsearch
    #bulk-workers: 1

    # Enables/disables nodes health checking
    #healthcheck: true

    # Specifies the interval for checking if the Elasticsearch nodes are available
    #healthcheck-interval: 10s

    # Specifies the timeout for periodic health checks
    #healthcheck-timeout: 5s

    # Identifies the username for the basic HTTP authentication
    #username:

    # Identifies the password for the basic HTTP authentication
    #password:

    # Enables the discovery of all Elasticsearch nodes in the cluster. This avoids populating the list
    # of available Elasticsearch nodes
    #sniff: false

    # Determines if the Elasticsearch trace log is enabled. Useful for troubleshooting
    #trace-log: false

    # Specifies if gzip compression is enabled
    #gzip-compression: false

    # Specifies the name of the index template
    #template-name: fibratus

    # Represents the target index for events. It allows time specifiers to create indices per time frame.
    # For example, fibratus-%Y-%m generates the index name with current year and month time specifiers
    #index-name: fibratus

    # Contains the full JSON body of the index template. For more information refer to
    # https://www.elastic.co/guide/en/elasticsearch/reference/current/index-templates.html
    #template-config:

    # Path to the public/private key file
    #tls-key:

    # Path to certificate file
    #tls-cert:

    # Represents the path of the certificate file that is associated with the Certification Authority (CA)
    #tls-ca:

    # Indicates if the chain and host verification stage is skipped
    #tls-insecure-skip-verify: false

  # Amqp output emits event batches to RabbitMQ brokers.
  amqp:
    # Indicates if the AMQP output is enabled
    enabled: false

    # Represents the AMQP connection string
    #url: amqp://localhost:5672

    # Specifies the AMQP connection timeout
    #timeout: 5s

    # Specifies target exchange name that receives inbound events
    #exchange: fibratus

    # Represents  the AMQP exchange type. Available exchange type include common types are "direct", "fanout",
    # "topic", "header", and "x-consistent-hash"
    #exchange-type: topic

    # Represents the static routing key to link exchanges with queues.
    #routing-key: fibratus

    # Represents the virtual host name
    #vhost: /

    # Indicates if the exchange is marked as durable. Durable exchanges can survive server restarts
    #durable: false

    # Indicates if the server checks whether the exchange already exists and raises an error if it doesn't exist
    #passive: false

    # Determines if a published message is persistent or transient
    #delivery-mode: transient

    # The username for the plain authentication method
    #username:
    # The password for the plain authentication method
    #password:

    # Designates static headers that are added to each published message
    #headers:
    #  env: dev

    # Path to the public/private key file
    #tls-key:

    # Path to certificate file
    #tls-cert:

    # Represents the path of the certificate file that is associated with the Certification Authority (CA)
    #tls-ca:

    # Indicates if the chain and host verification stage is skipped
    #tls-insecure-skip-verify: false

  # HTTP output sends event batches to HTTP servers.
  http:
    # Indicates if the HTTP output is enabled
    enabled: false

    # List of endpoints to which the events are sent
    #endpoints:
    #  - http://localhost:8081

    # Represents the timeout for the HTTP requests
    #timeout: 5s

    # Specifies the HTTP proxy URL. It overrides the HTTP proxy URL as indicated by the environment variables
    #proxy-url: ""

    # The username for HTTP proxy authentication
    #proxy-username: ""

    # The password for HTTP proxy authentication
    #proxy-password: ""

    # Determines the HTTP verb to use in requests
    #method: POST

    # Specifies the event serializer type
    #serializer: json

    # Username for the basic HTTP authentication
    #username: ""

    # Password for the basic HTTP authentication
    #password: ""

    # If enabled, the HTTP body is compressed with gzip compression
    #enable-gzip: false

    # List of arbitrary headers to include in HTTP requests
    #headers:
    #  api-key: ""

    # Path to the public/private key file
    #tls-key:

    # Path to certificate file
    #tls-cert:

    # Represents the path of the certificate file that is associated with the Certification Authority (CA)
    #tls-ca:

    # Indicates if the chain and host verification stage is skipped
    #tls-insecure-skip-verify: false

  # Eventlog output publishes events to Windows Event Log.
  eventlog:
    # Indicates if the Eventlog output is enabled
    enabled: false

    # Specifies the eventlog level
    # level: info

    # Address of the remote eventlog intake
    # remote-host:

    # Go template for rendering the eventlog message
    # template:

# =============================== Portable Executable (PE) =============================

# Tweaks for controlling the fetching of the PE (Portable Executable) metadata from the process' binary image.
pe:
  # Designates whether inspecting PE metadata is allowed.
  enabled: false

  # Contains a list of image names that are excluded from PE parsing
  excluded-images:
    - svchost.exe

  # Determines if resources are read from the PE resource directory
  #read-resources: false

  # Indicates if symbols are read from the PE headers
  #read-symbols: false

  # Indicates if full section inspection is allowed. When se to true, section's individual bytes are
  # consulted for computing section hashes, calculating the entropy, and so on
  #read-sections: false

# Designates the path or a series of paths separated by a semicolon that is used to search
# for symbols files
# symbol-paths: srv*c:\\SymCache*https://msdl.microsoft.com/download/symbols

# Determines if kernel stack addresses are symbolized
# symbolize-kernel-addresses: false

# =============================== Transformers =========================================

# Transformers are responsible for augmenting, parsing or enriching events.
transformers:
  # Remove transformer deletes provided event parameters.
  remove:
    # Indicates if the remove transformer is enabled
    enabled: false

    # Represents the list of parameters that are removed from the event
    #params:
    #  - irp

  # Rename transformer renames parameter from old to new name.
  rename:
    # Indicates if the rename transformer is enabled
    enabled: false

    # Contains the list of old/new mappings. Old represents the original
    # parameter name, while new is the new parameter name
    #params:
    #  - old:
    #    new:

  # Replace transformer replaces all non-overlapping instances of old parameter's value with the new one.
  replace:
    # Indicates if the replace transformer is enabled
    enabled: false

    # Contains the list of parameter replacements. For each target event parameter, the old represent the substring
    # that gets replaced by the new string.
    #replacements:
    #  - param:
    #    old:
    #    new:

  # Tags transformer appends custom key/value pairs to event metadata.
  tags:
    # Indicates if the tags transformer is enabled
    enabled: false

    # Contains the list of tags that are appended to event metadata. Values can be fetched from environment
    # variables by enclosing them in % symbols
    #tags:
    #  - key:
    #    value:

  # Trim transformer removes prefixes/suffixes from event parameter values.
  trim:
    # # Indicates if the trim transformer is enabled
    enabled: false

    # Contains the list of parameters associated with the prefix that is trimmed from the parameter's value
    #prefixes:
    #  - param:
    #    trim:

    # Contains the list of parameters associated with the suffix that is trimmed from the parameter's value
    #suffixes:
    #  - param:
    #    trim:

# =============================== YARA =================================================

# Tweaks that influence the behaviour of the YARA scanner.
yara:
  # Indicates if the YARA scanner is enabled. When enabled, each newly created process is scanned for pattern matches.
  enabled: false

  # Contains rule paths and rule definition information
  rule:
    # Represents the paths within the file system along with the YARA namespace identifier. All directories
    # inside the path are traversed recursively for YARA rule files.
    paths:
      - path: ""
        namespace: ""

    # Represents the string with the rule definition along with the YARA namespace identifier
    strings:
      - string:
        namespace:

  # Specifies templates for the alert text in Go templating language (https://golang.org/pkg/text/template)
  #alert-template:

  # Determines when multiple matches of the same string can be avoided when not necessary
  #fastscan: true

  # Specifies the timeout for the scanner. If the timeout is reached, the scan operation is cancelled
  #scan-timeout: 20s

  # Indicates whether file scanning is disabled. This affects the scan triggered by the image loading, create
  # file, and file mapping operations.
  #skip-files: false

  # Indicates whether scanning on suspicious memory allocations is disabled
  #skip-allocs: false

  # Indicates whether scanning on suspicious mappings of sections is disabled
  #skip-mmaps: false

  # Indicates whether registry value scanning is disabled
  #skip-registry: false

  # Contains the list of the comma-separated file paths that shouldn't be scanned. Wildcard matching is possible
  #excluded-files:
  #  - ?:\\Windows\\System32\\kernel32.dll

  # Contains the list of the comma-separated process image paths that shouldn't be scanned. Wildcard matching is possible.
  #excluded-procs:
  #  - System

```

`docs/CNAME`:

```
www.fibratus.io
```

`docs/README.md`:

```md
# Welcome to Fibratus Docs!

Fibratus documentation is built with [docsify](https://docsify.js.org/#/) site generator. docsify generates the documentation website on the fly by parsing the Markdown files. To preview the docs while you're editing, you can use the `docsify` CLI tool.

- download [Node.JS](https://nodejs.org/en/download/)
- `npm install -g docsify`
- go to the `docs` directory and run `docsify serve`
- browse the docs on `http://localhost:3000`

```

`docs/_coverpage.md`:

```md
<!-- _coverpage.md -->

<div style='margin-top: 150px'>
  <img src='logo.png'></img>
</div>

# fibratus <small>2.4.0</small>

>  Adversary tradecraft detection, protection, and hunting

- <ion-icon class="fast-icon" name="flash"></ion-icon> Runtime behaviour detection
- <ion-icon class="comprehensive-icon" name="magnet"></ion-icon> Forensics capabilities
- <ion-icon class="extensible-icon" name="cube"></ion-icon> Memory scanning

<a href="https://github.com/rabbitstack/fibratus/releases" target="_blank" rel="noopener"><ion-icon name="download"></ion-icon> Download</a>
<a href="#/setup/installation"><ion-icon name="rocket"></ion-icon> Get Started</a>

<div>
  <img src='images/fibratus-term.gif'></img>
</div>

```

`docs/_sidebar.md`:

```md
* <ion-icon name="infinite-outline"></ion-icon> Overview
  * [What is Fibratus?](overview/what-is-fibratus.md)
* <ion-icon name="rocket-outline"></ion-icon> Setup
  * [Installation](setup/installation.md)
  * [Quick Start](setup/quick-start.md)
  * [Configuration](setup/configuration.md)
  * [CLI](setup/cli.md)
* <ion-icon name="apps-outline"></ion-icon> Events
  * [Anatomy Of An Event](kevents/anatomy.md)
  * [Process](kevents/process.md)
  * [Thread](kevents/thread.md)
  * [Image](kevents/image.md)
  * [File](kevents/file.md)
  * [Registry](kevents/registry.md)
  * [Network](kevents/network.md)
  * [Handle](kevents/handle.md)
  * [Object](kevents/object.md)
  * [Driver](kevents/driver.md)
  * [Memory](kevents/mem.md)
* <ion-icon name="filter-outline"></ion-icon> Filters and Rules
  * [Needle In The Haystack](filters/introduction.md)
  * [Prefiltering](filters/prefiltering.md)
  * [Filtering](filters/filtering.md)
  * [Operators](filters/operators.md)
  * [Iterators](filters/iterators.md)
  * [Functions](filters/functions.md)
  * [Rules](filters/rules.md)
  * [Fields](filters/fields.md)
* <ion-icon name="server-outline"></ion-icon> Captures
  * [Immortalizing The Event Flux](captures/introduction.md)
  * [Capturing](captures/capturing.md)
  * [Replaying](captures/replaying.md)
* <ion-icon name="flash-outline"></ion-icon> Filaments
  * [Python Meets Kernel Events](filaments/introduction.md)
  * [Executing](filaments/executing.md)
  * [Internals](filaments/internals.md)
  * [Writing Filaments](filaments/writing.md)
* <ion-icon name="send-outline"></ion-icon> Outputs
  * [Transporting Events](outputs/introduction.md)
  * [Console](outputs/console.md)
  * [Null](outputs/null.md)
  * [RabbitMQ](outputs/rabbitmq.md)
  * [Elasticsearch](outputs/elasticsearch.md)
  * [HTTP](outputs/http.md)
  * [Eventlog](outputs/eventlog.md)
* <ion-icon name="color-wand-outline"></ion-icon> Transformers
  * [Parsing, Enriching, Transforming](transformers/introduction.md)
  * <ion-icon name="remove-circle-outline"></ion-icon> [Remove](transformers/remove.md)
  * <ion-icon name="reload-circle-outline"></ion-icon> [Rename](transformers/rename.md)
  * <ion-icon name="sync-circle-outline"></ion-icon> [Replace](transformers/replace.md)
  * <ion-icon name="pricetags-outline"></ion-icon> [Tags](transformers/tags.md)
  * <ion-icon name="cut-outline"></ion-icon> [Trim](transformers/trim.md)
* <ion-icon name="locate-outline"></ion-icon> Alerts
  * [Firing Alerts](alerts/introduction.md)
  * [Alert Senders](alerts/senders.md)
    * <ion-icon name="mail-unread-outline"></ion-icon> [Mail](alerts/senders/mail.md)
    * <ion-icon name="logo-slack"></ion-icon> [Slack](alerts/senders/slack.md)
    * <ion-icon name="chatbubble"></ion-icon> [Systray](alerts/senders/systray.md)
    * <ion-icon name="server"></ion-icon> [Eventlog](alerts/senders/eventlog.md)
  * [Filament Alerting](alerts/filaments.md)
* <ion-icon name="terminal-outline"></ion-icon> PE
  * [Portable Executable Introspection](/pe/introduction.md)
  * [Sections](/pe/sections.md)
  * [Symbols](/pe/symbols.md)
  * [Resources](/pe/resources.md)
* <ion-icon name="bug-outline"></ion-icon> Yara
  * [Pattern Matching Swiss Knife](/yara/introduction.md)
  * [Scanning Processes](/yara/scanning.md)
  * [Alerts](/yara/alerts.md)
* <ion-icon name="help-buoy-outline"></ion-icon> Troubleshooting
  * [Logs](troubleshooting/logs.md)
  * [Stats](troubleshooting/stats.md)
  * [Profiling](troubleshooting/pprof.md)

```

`docs/alerts/filaments.md`:

```md
# Filament Alerting

Filaments produce alerts by invoking the `emit_alert` function. The alert is propagated to all active alert senders.

The `emit_alert` function accepts two positional and two keyword arguments. Here is the signature of the function:

```python
emit_alert(title, text, severity='normal', tags=[])
```

An example of calling the `emit_alert` function to generate an alert from the filament that detects registry persistence attacks:

```python
emit_alert(
        f'Registry persistence gained via {kevent.kparams.key_name}',
        text(kevent),
        severity='medium',
        tags=['registry persistence']
)
```

```

`docs/alerts/introduction.md`:

```md
# Firing Alerts

Fibratus has the ability to generate security alerts when the detection or [YARA](/yara/scanning) rule matches. Additionally, alerts can be emitted directly from [filaments](/alerts/filaments).

The alert has the following key components:

- **id** the alert identifier represented as UUID.
- **title** summarizes the purpose of the alert.
- **text** is the message that further explains what this alert is about as well as actors involved.
- **tags** contains a sequence of tags for categorizing the alerts.
- **severity** determines the severity of the alert. Possible values are `normal`, `medium`, `critical`.

To send alert notifications, use [alert senders](/alerts/senders).

```

`docs/alerts/senders.md`:

```md
# Alert Senders

You can send alert notifications to your team through email, Slack, or incident response platforms. The notification can be sent to multiple alert senders. Alert senders configuration resides in the `alertsenders` section of the `yml` file.

- [Mail](/alerts/senders/mail)
- [Slack](/alerts/senders/mail)
- [Systray](/alerts/senders/systray)
- [Eventlog](/alerts/senders/eventlog)


```

`docs/alerts/senders/eventlog.md`:

```md
# Eventlog

The `eventlog` alert sender sends alerts to the [Windows Eventlog](https://sematext.com/glossary/what-is-windows-event-log/).

<p align="center">
  <img src="alerts/senders/images/eventlog.gif" style="border-radius: 4px; backdrop-filter: blur(15px) saturate(3); filter: drop-shadow(0 0 0.75rem rgba(30, 30, 30, 0.4));" />
</p>

### Configuration {docsify-ignore}

The `eventlog` alert sender configuration is located in the `alertsenders.eventlog` section.

#### enabled

Indicates whether the `eventlog` alert sender is enabled.

**default**: `true`

#### verbose

Enables/disables the verbose mode. In verbose mode, the full event context, including all parameters and the process information are included
in the log message.

**default**: `true`

```

`docs/alerts/senders/mail.md`:

```md
# Mail

The mail alert sender emits alert notifications through the `SMTP` protocol.
!> If you are using a Gmail SMTP provider, you might need to configure [App Passwords](https://support.google.com/accounts/answer/185833?hl=en) for your account

!> If you are using a Gmail SMTP provider, you might need to configure [App Passwords](https://support.google.com/accounts/answer/185833?hl=en) for your account

### Configuration {docsify-ignore}

The `mail` alert sender configuration is located in the `alertsenders.mail` section.

#### enabled

Indicates if the alert sender is enabled.

**default**: `false`

#### host

Represents the host name of the SMTP server where the alert notification is sent.

#### port

Represents the port number of the SMTP server.

**default**: `25`

#### user

Specifies the user name when authenticating to the SMTP server.

#### password

Specifies the password when authenticating to the SMTP server.

#### from

Determines the sender's email address.

#### to

Specifies the list of the recipient email addresses.

```

`docs/alerts/senders/slack.md`:

```md
# Slack

The `slack` alert sender forwards alerts to Slack workspaces. You'll have to [activate](https://slack.com/intl/en-es/help/articles/115005265063-Incoming-webhooks-for-Slack) incoming webhooks and associate the webhook to your Slack workspace to be able to emit the alerts.

### Configuration {docsify-ignore}

The `slack` alert sender configuration is located in the `alertsenders.slack` section.

#### enabled

Indicates whether the `slack` alert sender is enabled.

**default**: `false`

#### url

Represents the Webhook URL of the workspace where alerts will be dispatched. The Webhook URL has the following format: `https://hooks.slack.com/services/T00000000/B00000000/XXXXXXXXXXXXXXXXXXXXXXXX`.

#### workspace

The name of the Slack workspace where alerts are routed.

#### channel

Is the slack channel in which to post alerts.

#### emoji

Represents the emoji icon surrounded in `:` characters for the Slack bot.

```

`docs/alerts/senders/systray.md`:

```md
# Systray

The `systray` alert sender sends alerts to the systray notification area. 

### Configuration {docsify-ignore}

The `systray` alert sender configuration is located in the `alertsenders.systray` section.

#### enabled

Indicates whether the `systray` alert sender is enabled.

**default**: `false`

#### sound

Indicates if the associated sound is played when the balloon notification is shown.

**default**: `true`

#### quiet-mode

Instructs not to display the balloon notification if the current user is in quiet time. During this time, most notifications should not be sent or shown. This lets a user become accustomed to a new computer system without those distractions. Quiet time also occurs for each user after an operating system upgrade or clean installation.

**default**: `false`

```

`docs/captures/capturing.md`:

```md
# Capturing

Under the hood, captures are written to disk in the form of the [zstd](https://en.wikipedia.org/wiki/Zstandard) compressed streams. zstd provides a compelling balance between the capture file size and the compression runtime overhead.

Each capture file consists of the header that represents the `kcap` magic, major/minor version, and some arbitrary flags. Next, the handle snapshot is stored with all allocated handles followed by kernel events. We can forgo persisting the process snapshot, because it can be reconstructed when replaying the capture and processing the `EnumProcess` events.

Capturing is initiated by running the `fibratus capture` command. The `o` flag, that stands for `output`, specifies the `kcap` file where events are dumped. The capture file is stored in the current working directory. **Any already existing file is overwritten**. To above command would produce a capture and store all events in `events.kcap` file.

```
$ fibratus capture -o events
```

To stop capturing events, hit the `Ctrl-C` key combination. A short summary is displayed indicating the number of captured events, processes, handles, the size of the `kcap` file and so on.

### Filtering {docsify-ignore}

As already explained in [filtering](/filters/filtering), for a fine-grained control over which events are stored in the capture, you can provide a filter expression.

```
$ fibratus capture kevt.category = 'file' -o fs-events
```

```

`docs/captures/introduction.md`:

```md
# Immortalizing The Event Flux

Captures or `kcap` files aim for the capture-once replay-anywhere workflow. Captures contain the full state of processes at the time capture was taken as well as the originated event flux. This makes them a great companion in post-mortem investigations - generate the capture in the honeypot machine, grab the `.kcap` file, and you're ready to dive into the attacker kill chain by replaying the capture file on your laptop.

With captures you "freeze" the shape of the event flux at a certain point in time. Do you need to troubleshoot an network issue and surface the root cause? Or maybe you need to determine what files were written by a malicious process? Replay the capture at any given time and drill down into the event flow to start investigating.

You can harness the power of the filtering engine when replaying captures or even execute a filament on top of captured events.

```

`docs/captures/replaying.md`:

```md
# Replaying

Replaying essentially recovers the handle/process state and consumes the captured event flux. It is important to point out that Fibratus increments the major `kcap` version under relevant changes in the format structure. Because of this, old capture files might not be able to replay due to mismatch of the `kcap` major version digit.

To replay the `kcap` file, you launch the following command.

```
$ fibratus replay -k events
```

### Filtering {docsify-ignore}

To drill down into capture by filtering out valuable events, you can provide a filter.

```
$ fibratus replay file.name contains 'Temp' -k fs-events
```

### Filaments {docsify-ignore}

Another compelling use case stems from running a filament on top of events living in the capture. To run a filament you supply the filament name via the `-f` or `--filament.name` option.

```
$ fibratus replay -f watch_files -k fs-events
```

```

`docs/filaments/executing.md`:

```md
# Executing Filaments

Filaments are bootstrapped via the `fibratus run` command by specifying the filament name. Use the `-f` or `--filament.name` flags to indicate the filament you'd like to run.

```
$ fibratus run -f watch_files
```

The filament will keep running until the keyboard interrupt signal is received. 

### Passing arguments to filaments {docsify-ignore}

Filaments may require additional arguments to execute some conditional logic or set up a filter. Arguments are passed to a filament by specifying a list of comma-separated values after filament name:

```
$ fibratus run -f "watch_files,powershell.exe"
```

This populates the [sys.argv](https://docs.python.org/3/library/sys.html#sys.argv) list with the provided arguments, where `sys.argv[0]` is the filament name.


### Listing filaments {docsify-ignore}

By default, filaments reside within the `%PROGRAMFILES%\Fibratus\Filaments` directory. It is possible to override this location by specifying an alternative directory via the `--filament.path` flag or by editing the config file.

To list available filaments, run the below command.

```
$ fibratus list filaments
```

### Filters {docsify-ignore}

Engaging filters in filaments can be accomplished in two ways:

- the command line argument when running the filament
- the `kfilter` function during filament initialization

If the filter expression is supplied in both the CLI argument and the `kfilter` function, the one set in the latter takes precedence.

```

`docs/filaments/internals.md`:

```md
# Internals

Filaments are scheduled as independent Python Virtual Machines and thus they have their own memory and other resources allocated. Fibratus takes as an input a Python module consisting of various functions and converts them into a running instance of the Python interpreter that knows how to process incoming kernel events. It also augments the Python module with numerous functions that permit a filament to interact with alerts and other state exposed by Fibratus.

### Event dispatching {docsify-ignore}

The backbone of a filament is the `on_next_kevent` function. It's executed whenever a new kernel event arrives. The parameter of this function is the Python dictionary that contains event data. Here is the structure of such a dictionary object:

```python
{
  'seq': 122344,
  'pid': 2034,
  'tid': 2453,
  'ppid': 45,
  'cwd': 'C:\Windows\system32',
  'exe': 'cmd.exe',
  'comm': 'cmd.exe rm /r',
  'sid': 'archrabbit\SYSTEM',
  'cpu': 2,
  'name': 'CreateFile',
  'category': 'file',
  'timestamp': '2013-08-23 16:15:13.4323',
  'host': 'archrabbit',
  'description': 'Creates or opens a file or I/O device',
  'kparams': {
    'file_name': 'C:\WINDOWS\system32\config\systemprofile\AppData\WindowsApps\',
    'file_object': 'ffffa88c7ea077d0',
    'irp': 'ffffa88c746b2a88',
    'operation': 'supersede',
    'share_mask': 'rw-',
    'type': 'directory'
  }
}
```

For a more convenient dictionary accesses, you can annotate the function with the `dotdictify` decorator.

```python
from utils.dotdict import dotdictify

@dotdictify
def on_next_kevent(kevent):
    print(f'{kevent.name} generated by {kevent.exe}')
```

### Initialization {docsify-ignore}

If the `on_init` function is declared in the filament, any logic wrapped inside this function is executed prior to event processing. This is a convenient place for configuring the table columns or establishing the `on_interval` function triggering intervals among other initialization tasks.

```python
def on_init():
    interval(1)
```

### Termination {docsify-ignore}

The `on_stop` function is called right before the Python interpreter is teared down. You can place any code you would like to get executed when the filament is stopped.

```python
def on_stop():
    f.close()
```

### Periodical actions {docsify-ignore}

Filament has built-in support for scheduling timers. The timer, associated with the `on_interval` function, is fired after the interval specified by the `interval` function elapses. The minimum interval granularity is one second.

```python
def on_interval():
    for ip, count in __connections__.copy().items():
      f.write(f'{ip.count}')
```

### Filtering {docsify-ignore}

The `kfilter` function defines a filter expression for the life span of a filament. Filaments give an appealing approach for constructing the filters dynamically. For example, this following code snippet defines a filter from the list:

```python
kfilter("ps.name in (%s)" % (', '.join([f'\'{ps}\'' for ps in __procs__])))
```

### Table rendering {docsify-ignore}

Filaments are able to render tabular data on the console in a flicker-free fashion by using the frame buffers. To render a table, you start by defining the columns with the `columns` function. It's possible to sort the data by specifying the column via `sort_by` function. Finally, the `add_row` function appends rows to the table. When you're ready to draw the table, invoke the `render_table` function.

```python
def on_init():
    columns(["Source", "Count"])
    sort_by('Count')
    interval(1)

def on_interval():
    for ip, count in __connections__.copy().items():
        add_row([ip, count])
    render_table()
```

### Python distribution and pip {docsify-ignore}

Fibratus bundles embedded Python 3.7 distribution. Installing additional packages can be achieved by running the `pip` command from the `%PROGRAM FILES%\Fibratus\Python\Scripts` directory.

```

`docs/filaments/introduction.md`:

```md
# Python Meets Kernel Events

**Python** is the lingua franca of pen testers and other **SecOps**-driven individuals. Many security tools are written in Python language.
Wouldn't it be awesome to exploit the arsenal of those tools in Fibratus or build your own tools atop them?

Fibratus incorporates a framework for painlessly extending the functionality and incorporating new features via Python scripts. These scripts are called **filaments**. You can also think of them as extension points with virtually endless possibilities. Whatever you are allowed to craft in Python, you can also implement in filaments.

Filaments are executed on top of kernel event flux and thus they have access to all event's parameters, process state and so on.
From technical perspective, a filament is a full-fledged instance of the Python interpreter. Fibratus interacts with the **CPython** API to bootstrap the interpreter, initialize the module from filament definition, declare functions and other related tasks.

```

`docs/filaments/writing.md`:

```md
# Writing Filaments

The best way to grasp filaments is by writing a new filament from scratch. The following is the walkthrough of building a filament that fetches the IP blacklist database and relies on it to detect outbound/inbound connections to botnets, C&C servers, and other fishy destinations.

Let's first define the function for fetching the database and converting it into a list. We also declare two regular expressions for accepting only valid IP addresses or IP addresses in CIDR notation. Note that we use the `requests` package for fetching the database.

```python
IP_RE      = re.compile(r"(?<!\d\.)(?<!\d)(?:\d{1,3}\.){3}\d{1,3}(?!\d|(?:\.\d))")
IP_CIDR_RE = re.compile(r"(?<!\d\.)(?<!\d)(?:\d{1,3}\.){3}\d{1,3}/\d{1,2}(?!\d|(?:\.\d))")

def fetch_db(url):
    with requests.get(url) as r:
      ips = [ipaddress.ip_network(l) if '/' in l else ipaddress.ip_address(l) \
          for l in r.text.splitlines() if IP_RE.match(l) or IP_CIDR_RE.match(l)]
    return ips
```

We call into the `fetch_db` function during filament initialization and store the result into the global `__fishy_ips__` list. Additionally, we'll schedule the syncing of the IP database every hour to get the latest definitions of spam nets and attacker IP addresses. Since we're only interested in network events, we'll set the filter accordingly.

```python
IP_DB_URL = 'http://rules.emergingthreats.net/fwrules/emerging-Block-IPs.txt'

def on_init():
    __fishy_ips__ = fetch_db(IP_DB_URL)
    interval(3600)
    kfilter("kevt.category = 'net'")
    columns(["Source", "Destination", "Process"])

def on_interval():
    __fishy_ips__ = fetch_db(IP_DB_URL)
```

Now, we'll implement the main logic for checking whether the network flow is involved in compromised communication such as C&C server requests. Here we simply add a new row and render a table with the source/destination IP address and the process that initiated the network request.

```python
@dotdictify
def on_next_kevent(kevent):
    sip = kevent.kparams.sip
    dip = kevent.kparams.dip
    if (sip in __fishy_ips__ or dip in __fishy_ips__) or \
        (sip or dip in net for net in __fishy_ips__ if isinstance(net, ipaddress.IPv4Network)):
        add_row([sip, dip, kevent.exe])
    render_table()
```

We could have generated an alert and send it via Slack or email. We'll touch on emitting the alerts in [filament alerting](/alerts/filaments).

The full source code of our filament would look similar to the snippet above.

```python
"""
Pinpoints network communications with botnets or C&C servers.
"""

import requests
import re
import ipaddress
from utils.dotdict import dotdictify

IP_RE      = re.compile(r"(?<!\d\.)(?<!\d)(?:\d{1,3}\.){3}\d{1,3}(?!\d|(?:\.\d))")
IP_CIDR_RE = re.compile(r"(?<!\d\.)(?<!\d)(?:\d{1,3}\.){3}\d{1,3}/\d{1,2}(?!\d|(?:\.\d))")
IP_DB_URL = 'http://rules.emergingthreats.net/fwrules/emerging-Block-IPs.txt'


def fetch_db(url):
    with requests.get(url) as r:
      ips = [ipaddress.ip_network(l) if '/' in l else ipaddress.ip_address(l) \
            for l in r.text.splitlines() if IP_RE.match(l) or IP_CIDR_RE.match(l)]
    return ips


def on_init():
    __fishy_ips__ = fetch_db(IP_DB_URL)
    interval(3600)
    kfilter("kevt.category = 'net'")
    columns(["Source", "Destination", "Process"])


@dotdictify
def on_next_kevent(kevent):
    sip = kevent.kparams.sip
    dip = kevent.kparams.dip
    if (sip in __fishy_ips__ or dip in __fishy_ips__) or \
        (sip or dip in net for net in __fishy_ips__ if isinstance(net, ipaddress.IPv4Network)):
        add_row([sip, dip, kevent.exe])
    render_table()


def on_interval():
    __fishy_ips__ = fetch_db(IP_DB_URL)
```

Save it to, let's say, `cc.py` file inside the `%PROGRAMFILES%\Fibratus\Filaments` directory and you're ready to go. Run the filament with the following command:

```
$ fibratus run -f cc
```

```

`docs/filters/fields.md`:

```md
# Fields

In Fibratus filter expression language the fields can evaluate to one of the following types:

- **string** values are enclosed in single quotes and escaped according to these [rules](filters/filtering?id=escaping-characters)
- **number** field types can be both integer and floating-point numbers. Floating point numbers use the dot notation (`6.54`).
- **IP address** field types represent IPv4 addresses (`172.14.4.4`)
- **bool** represents the `true` or `false` boolean values

## Filter fields {docsify-ignore}

The following tables summarize available field names that can be used in filter expressions.

### Event
| Field Name  | Description | Example     |
| :---        |    :----   |          :---: |
| kevt.seq      | Monotonic event sequence number       | `kevt.seq > 666`   |
| kevt.pid      | Process identifier generating the event       | `kevt.pid = 6`   |
| kevt.tid      | Thread identifier generating the event       | `kevt.tid = 1024`   |
| kevt.cpu      | Logical processor core where the event was generated       | `kevt.cpu = 2`   |
| kevt.name      | Symbolical event name       | `kevt.name = 'CreateThread'`   |
| kevt.category      | Category to which the event pertains      | `kevt.category = 'registry'`   |
| kevt.desc      | Cursory event description      | `kevt.desc contains 'Creates'`   |
| kevt.host      | Hostname on which the event was produced     | `kevt.host contains 'dev'`   |
| kevt.nparams    | Number of event parameters     | `kevt.nparams > 2`   |
| kevt.time      | Event timestamp as a time string      | `kevt.time = '17:05:32'`   |
| kevt.time.h      | Hour within the day on which the event occurred      | `kevt.time.h = 23`   |
| kevt.time.m      | Minute offset within the hour on which the event occurred      | `kevt.time.m = 54`   |
| kevt.time.s      | Second offset within the minute on which the event occurred      | `kevt.time.s = 0`   |
| kevt.time.ns     | Nanoseconds specified by the event timestamp      | `kevt.time.ns > 1591191629102337000`   |
| kevt.date       | Event timestamp as a date string      | `kevt.date = '2018-03-03'`   |
| kevt.date.d     | Day of the month on which the event occurred      | `kevt.date.d = 12`   |
| kevt.date.m     | Month of the year on which the event occurred      | `kevt.date.m = 11`   |
| kevt.date.y     | Year on which the event occurred      | `kevt.date.y = 2020`   |
| kevt.date.tz    | Time zone associated with the event timestamp     | `kevt.date.tz = 'UTC'`   |
| kevt.date.week    | Week number within the year on which the event occurred     | `kevt.date.week = 2`   |
| kevt.date.weekday    | Week day on which the event occurred     | `kevt.date.weekday = 'Monday'`   |
| kevt.arg[]    | Accesses a specific event parameter via internal name | `kevt.arg[exe] = 'C:\\Windows\\cmd.exe'`   |


### Process
| Field Name  | Description | Example     |
| :---        |    :----   |          :---: |
| ps.pid         | Process identifier generating the event. Alias for `kevt.pid` | `ps.pid = 1024`   |
| ps.ppid         | Parent process identifier of the process generating the event | `ps.ppid = 25`   |
| ps.name         | Process (image) path name that generates an event | `ps.name = 'cmd.exe'`   |
| ps.cmdline      | Process command line | `ps.cmdline contains '/E c:\\ads\\file.txt:regfile.reg'`   |
| ps.exe          | Full name of the process' executable | `ps.exe = 'C:\\Windows\\system32\\cmd.exe'`   |
| ps.args         | Process command line arguments | `ps.args in ('/cdir', '/-C')`   |
| ps.cwd          | Process current working directory | `ps.cwd = 'C:\\Users\\Default'`   |
| ps.sid          | Security identifier under which this process is run | `ps.sid = 'S-1-5-18'`   |
| ps.domain       | Process domain name  | `ps.domain = 'NT AUTHORITY'`   |
| ps.username     | Process user name  | `ps.username = 'SYSTEM'`   |
| ps.sessionid    | Unique identifier for the current session | `ps.sessionid = 1`   |
| ps.access.mask  | Process access rights | `ps.access.mask = '0x1000'`   |
| ps.access.mask.names  | Process access human-readable rights | `ps.access.mask.names in ('TERMINATE', 'QUERY_INFORMATION')`   |
| ps.access.status  | Process access status | `ps.access.status = 'success'`   |
| ps.envs         | Process environment variables | `ps.envs in ('MOZ_CRASHREPORTER_DATA_DIRECTORY')`  |
| ps.envs[]       | Accesses a specific environment variable. Prefix matches are supported | `ps.envs['MOZ_CRASHREPORTER'] = 'C:\\Program Files\\Firefox'`  |
| ps.dtb          | Process directory table base address | `ps.dtb = '7ffe0000'` |
| ps.handles      | Allocated process handles | `ps.handles in ('\\BaseNamedObjects\\__ComCatalogCache__')`   |
| ps.handle.types | Allocated process handle types | `ps.handle.types in ('Key', 'Mutant', 'Section')`   |
| ps.modules      | Modules loaded by the process | `ps.modules in ('crypt32.dll', 'xul.dll')`   |
| ps.modules[]    | Accesses a specific process module. Prefix matches are supported  | `ps.modules['crypt'].size > 1024`   |
| ps.parent.name    | Parent process name  | `ps.parent.name = 'powershell.exe'`   |
| ps.parent.pid    | Parent process identifier  | `ps.parent.pid = 2340`   |
| ps.parent.cmdline| Parent process command line  | `ps.parent.cmdline contains 'attrib'`   |
| ps.parent.exe    | Full name of the parent process executable  | `ps.parent.exe = 'C:\\Windows\\system32\\cmd.exe'`   |
| ps.parent.cwd    | Parent process current working directory  | `ps.parent.cwd = 'C:\\Users\\Default'`   |
| ps.parent.sid    | Security identifier under which the parent process is run  | `ps.parent.sid = 'S-1-5-18'`   |
| ps.parent.domain    | Parent process domain name  | `ps.parent.domain = 'NT AUTHORITY'`   |
| ps.parent.username  | Parent process user name  | `ps.parent.username = 'SYSTEM'`   |
| ps.parent.sessionid    | Unique identifier for the current session of the parent process  | `ps.parent.session = 1`   |
| ps.parent.dtb    | Parent process directory table base address  | `ps.parent.dtb = 'powershell.exe'`   |
| ps.parent.envs    | Parent process environment variables   | `ps.parent.envs in ('PROCESSOR_LEVEL')'`   |
| ps.parent.handles    | Allocated parent process handles  | `ps.parent.handles in ('\\...\\Cor_SxSPublic_IPCBlock')`   |
| ps.parent.handle.types    | Allocated parent process handles types  | `ps.parent.handle.types in ('Key', 'Mutant', 'Section')`   |
| ps.ancestor[]    | Process ancestry traversing  | `ps.ancestor[2].name in ('winword.exe', 'powershell.exe')`   |
| ps.child.name    | Child process name  | `ps.child.name = 'cmd.exe'`   |
| ps.child.pid     | Child process identifier  | `ps.child.id = 6050`   |
| ps.child.cmdline    | Child process command line  | `ps.child.cmdline contains '/k /v'`   |
| ps.child.exe     | Child process executable full path  | `ps.child.exe = 'C:\\Windows\\system32\\cmd.exe'`   |
| ps.child.args    | Child process command line arguments  | `ps.child.args in ('C:\\Windows\\system32\\cmd.exe')`   |
| ps.child.sid     | Child process security identifier  | `ps.child.sid = 'S-1-5-20'`   |
| ps.child.sessionid   | Child process session identifier  | `ps.child.sessionid = 1`   |
| ps.child.domain    | Child process domain name  | `ps.child.domain = 'NT AUTHORITY'`   |
| ps.child.username  | Child process user name  | `ps.child.username = 'SYSTEM'`   |
| ps.uuid  | Unique process identifier resistant to repetition | `ps.uuid > 10000400`   |
| ps.parent.uuid  | Unique parent process identifier resistant to repetition  | `ps.parent.uuid = 1843450000440`   |
| ps.child.uuid  | Unique child process identifier resistant to repetition  | `ps.child.uuid > 20030000000`   |
| ps.child.pe.file.name | Original file name of the child process executable supplied at compile-time | `ps.child.pe.file.name = 'NOTEPAD.EXE'` |
| ps.child.is_wow64 | Indicates if the 32-bit child process is created in 64-bit Windows system | `ps.child.is_wow64` |
| ps.child.is_packaged | Indicates if the child process is packaged with the MSIX technology | `ps.child.is_packaged` |
| ps.child.is_protected | Indicates if the child process is a protected process | `ps.child.is_protected` |
| ps.is_wow64 | Indicates if the process generating the event is a 32-bit child process is created in 64-bit Windows system | `ps.is_wow64` |
| ps.is_packaged | Indicates if the process process generating the event is packaged with the MSIX technology | `ps.is_packaged` |
| ps.is_protected | Indicates if the process generating the event is a protected process | `ps.is_protected` |
| ps.parent.is_wow64 | Indicates if the parent process generating the event is a 32-bit process created in 64-bit Windows system | `ps.parent.is_wow64` |
| ps.parent.is_packaged | Indicates if the parent process generating the event is packaged with the MSIX technology | `ps.parent.is_packaged` |
| ps.parent.is_protected | Indicates if the parent process generating the event is a protected process | `ps.parent.is_protected` |


### Thread
| Field Name  | Description | Example     |
| :---        |    :----   |          :---: |
| thread.prio     | Scheduler priority of the thread | `thread.prio = 5`   |
| thread.io.prio  | I/O priority hint for scheduling I/O operations | `thread.io.prio = 4`   |
| thread.page.prio | Memory page priority hint for memory pages accessed by the thread | `thread.page.prio = 12`   |
| thread.kstack.base | Base address of the thread's kernel space stack | `thread.kstack.base = 'a65d800000'`   |
| thread.kstack.limit | Limit of the thread's kernel space stack | `thread.kstack.limit = 'a85d800000'`   |
| thread.ustack.base | Base address of the thread's user space stack | `thread.ustack.base = '7ffe0000'`   |
| thread.ustack.limit | Limit of the thread's user space stack | `thread.ustack.limit = '8ffe0000'`   |
| thread.start_address | Start address of the function to be executed by the thread | `thread.start_address = '7efe0000'`   |
| thread.access.mask | Thread access rights | `thread.access.mask = '0x1800'`   |
| thread.access.mask.names | Thread access human-readable rights | `thread.access.mask.names in ('QUERY_LIMITED_INFORMATION')`   |
| thread.access.status | Thread access status | `thread.access.status = 'Success'`   |
| thread.teb_address | The base address of the thread environment block | `thread.teb_address = '8f30893000'`   |
| thread.start_address.symbol | Thread start address symbol | `thread.start_address.symbol = 'LoadImage'`   |
| thread.start_address.module | Thread start address module | `thread.start_address.module endswith 'kernel32.dll'`   |


### Threadpool

| Field Name  | Description | Example     |
| :---        |    :----   |          :---: |
| threadpool.id     | Thread pool identifier | `threadpool.id = '20f5fc02440'`   |
| threadpool.task.id     | Thread pool task identifier | `threadpool.task.id = '20f7ecd21f8'`   |
| threadpool.callback.address     | Thread pool callback address | `threadpool.callback.address = '7ff868739ed0'` |
| threadpool.callback.symbol     | Thread pool callback address symbol | `threadpool.callback.symbol = 'RtlDestroyQueryDebugBuffer'`   |
| threadpool.callback.module     | Thread pool callback address module | `threadpool.callback.module contains 'ntdll.dll'`   |
| threadpool.callback.context     | Thread pool callback context address | `threadpool.callback.context = '1df41e07bd0'`   |
| threadpool.callback.context.rip     | Thread pool callback thread context instruction pointer | `threadpool.callback.context.rip = '1df42ffc1f8'`   |
| threadpool.callback.context.rip.symbol     | Thread pool callback thread context instruction pointer symbol | `threadpool.callback.context.rip.symbol = 'VirtualProtect'`   |
| threadpool.callback.context.rip.module     | Thread pool callback thread context instruction pointer module | `threadpool.callback.context.rip.module contains 'ntdll.dll'`   |
| threadpool.subprocess_tag     | Thread pool service identifier | `threadpool.subprocess_tag = '10d'`   |
| threadpool.timer.duetime     | Thread pool timer due time | `threadpool.timer.duetime > 10`   |
| threadpool.timer.subqueue     | Thread pool timer subqueue address | `threadpool.timer.subqueue = '1db401703e8'`   |
| threadpool.timer.address     | Thread pool timer address | `threadpool.timer.address = '3e8'`   |
| threadpool.timer.period     | Thread pool timer period | `threadpool.timer.period = 0`   |
| threadpool.timer.window     | Thread pool timer tolerate period | `threadpool.timer.window = 0`   |
| threadpool.timer.is_absolute     | Indicates if the thread pool timer is absolute or relative | `threadpool.timer.is_absolute = true`   |


### Callstack
| Field Name  | Description | Example     |
| :---        |    :----   |          :---: |
| thread.callstack.summary     | Callstack summary showing involved modules | `thread.callstack.summary contains 'ntdll.dll\|KERNELBASE.dll'` |
| thread.callstack.detail      | Detailed information of each stack frame | `thread.callstack.detail contains 'KERNELBASE.dll!CreateProcessW'` |
| thread.callstack.modules     | List of modules comprising the callstack | `thread.callstack.modules in ('C:\WINDOWS\System32\KERNELBASE.dll')` |
| thread.callstack.symbols     | List of symbols comprising the callstack | `thread.callstack.symbols in ('ntdll.dll!NtCreateProcess')` |
| thread.callstack.allocation_sizes | Allocation sizes of private pages | `thread.callstack.allocation_sizes > 10000` |
| thread.callstack.protections    | Page protections masks of each frame | `thread.callstack.protections in ('RWX', 'WX')'` |
| thread.callstack.callsite_leading_assembly    | Callsite leading assembly instructions | `thread.callstack.callsite_leading_assembly in ('mov r10,rcx', 'syscall')` |
| thread.callstack.callsite_trailing_assembly    | Callsite trailing assembly instructions | `thread.callstack.callsite_trailing_assembly in ('add esp, 0xab')` |
| thread.callstack.is_unbacked    | Indicates if the callstack contains unbacked regions | `thread.callstack.is_unbacked` |
| thread.callstack.addresses    | List of all callstack return addresses | `thread.callstack.addresses in ('7ffb5c1d0396')` |
| thread.callstack.final_user_module.name  | The final user module name | `thread.callstack.final_user_module.name != 'ntdll.dll'` |
| thread.callstack.final_user_module.path  | The final user module path | `thread.callstack.final_user_module.path imatches '?:\\Windows\\System32\\ntdll.dll'` |
| thread.callstack.final_user_symbol.name  | The final user symbol name | `thread.callstack.final_user_symbol.name imatches 'CreateProcess*'` |
| thread.callstack.final_kernel_module.name  | The final kernel module name | `thread.callstack.final_kernel_module.name = 'FLTMGR.SYS'` |
| thread.callstack.final_kernel_module.path  | The final kernel module path | `thread.callstack.final_kernel_module.path imatches '?:\\WINDOWS\\System32\\drivers\\FLTMGR.SYS'` |
| thread.callstack.final_kernel_symbol.name  | The final kernel symbol name | `thread.callstack.final_kernel_symbol.name = 'FltGetStreamContext'` |
| thread.callstack.final_user_module.signature.is_signed  | Indicates if the final user module is signed | `thread.callstack.final_user_module.signature.is_signed = true` |
| thread.callstack.final_user_module.signature.is_trusted   | Indicates if the final user module signature is trusted | `thread.callstack.final_user_module.signature.is_trusted = true` |
| thread.callstack.final_user_module.signature.cert.issuer  | The final user module signature certificate issuer | `thread.callstack.final_user_module.signature.cert.issuer imatches '*Microsoft Corporation*'` |
| thread.callstack.final_user_module.signature.cert.subject  |  The final user module signature certificate subject | `thread.callstack.final_user_module.signature.cert.subject imatches '*Microsoft Windows*'` |

### Image
| Field Name  | Description | Example     |
| :---        |    :----   |          :---: |
| image.path     | Full image path | `image.name = 'C:\\Windows\\System32\\advapi32.dll'`   |
| image.name     | Image name | `image.name = 'advapi32.dll'`   |
| image.base.address  | Base address of the process in which the image is loaded | `image.base.address = 'a65d800000'`   |
| image.checksum  | Image checksum | `image.checksum = 746424`   |
| image.size  | Image size | `image.size > 1024`   |
| image.default.address  | Default image address | `image.default.address = '7efe0000'`   |
| image.signature.type  | Image signature type | `image.signature.type != 'NONE'`   |
| image.signature.level  | Image signature level | `image.signature.level = 'AUTHENTICODE'`   |
| image.cert.serial  | Image certificate serial number | `image.cert.serial = '330000023241fb59996dcc4dff000000000232'`   |
| image.cert.subject  | Image certificate subject | `image.cert.subject contains 'Washington, Redmond, Microsoft Corporation'`   |
| image.cert.issuer  | Image certificate CA | `image.cert.issuer contains 'US, Washington, Redmond, Microsoft Windows Production PCA 2011`   |
| image.cert.after  | Image certificate expiration date | `image.cert.after contains '2024-02-01 00:05:42 +0000 UTC'`   |
| image.cert.before  | Image certificate enrollment date | `image.cert.before contains '2024-02-01 00:05:42 +0000 UTC'`   |
| image.is_driver_malicious  | Indicates if the loaded driver is malicious | `image.is_driver_malicious`  |
| image.is_driver_vulnerable | Indicates if the loaded driver is vulnerable | `image.is_driver_vulnerable` |
| image.is_dll | Indicates if the loaded image is a DLL | `image.is_dll` |
| image.is_driver | Indicates if the loaded image is a driver | `image.is_driver` |
| image.is_exec | Indicates if the loaded image is an executable | `image.is_exec` |
| image.is_dotnet | Indicates if the loaded image is a .NET assembly | `image.is_dotnet` |

### File
| Field Name  | Description | Example     |
| :---        |    :----   |          :---: |
| file.object     | File object address in the kernel space | `file.object = 18446738026482168384`   |
| file.path       | Full file path | `file.name = 'C:\\Windows\\Sytem32\\regedit.exe'`   |
| file.name       | File name | `file.name = 'regedit.exe'`   |
| file.operation  | Operation performed on the file or I/O device | `file.operation = 'OPEN'`   |
| file.share.mask | File share mask | `file.share.mask = 'READ'`   |
| file.io.size    | I/O read/write size | `file.io.size > 512`   |
| file.offset     | Read/write position in the file | `file.offset = 1024`   |
| file.type       | File type. Possible values are `File`, `Directory`, `Pipe`, `Console`, `Mailslot`, `Other`, `Unknown` | `file.type = 'Directory'`   |
| file.extension  | File extension represents the file extension (e.g. .exe or .dll) | `file.extension = '.dll'`   |
| file.attributes | List of file attributes | `file.attributes in ('HIDDEN', 'TEMPORARY')`   |
| file.status | System status message of the `CreateFile` operation | `file.status = 'Success'`   |
| file.view.base | Base address of the mapped/unmapped section view | `file.view.base = '25d42170000'`   |
| file.view.size | Size of the mapped/unmapped section view | `file.view.size > 1024`   |
| file.view.type | Type of the mapped/unmapped section view | `file.view.type = 'IMAGE'`   |
| file.view.protection | Protection rights of the section view | `file.view.protection = 'READONLY'` |
| file.is_driver_malicious  | Indicates if the dropped driver is malicious | `file.is_driver_malicious`  |
| file.is_driver_vulnerable | Indicates if the dropped driver is vulnerable | `file.is_driver_vulnerable` |
| file.is_dll | Indicates if the created file is a DLL | `file.is_dll` |
| file.is_driver | Indicates if the created file is a driver | `file.is_driver` |
| file.is_exec | Indicates if the created file is an executable | `file.is_exec` |
| file.info_class | Identifies the file information class | `file.info_class = 'Allocation'` |
| file.info.allocation_size | Represents the file allocation size set via `NtSetInformationFile` syscall | `file.info.allocation_size > 645400` |
| file.info.eof_size | Represents the file EOF size set via `NtSetInformationFile` syscall | `file.info.eof_size > 1000` |
| file.info.is_disposition_file_delete | Indicates if the file is deleted when its handle is closed | `file.info.is_disposition_file_delete = true` |


### Registry
| Field Name  | Description | Example     |
| :---        |    :----   |          :---: |
| registry.path   | Fully qualified registry path | `registry.path = 'HKEY_LOCAL_MACHINE\SYSTEM\ControlSet001\Services'`   |
| registry.key.name   | Base registry key name | `registry.key.name = 'Services'`   |
| registry.key.handle | Registry key object address | `registry.key.handle = 'FFFFB905D60C2268'`   |
| registry.value      | Registry value content | `registry.value = '%SystemRoot%\\system32'`   |
| registry.value.type | Registry value type | `registry.value.type = 'REG_SZ'`   |
| registry.status     | Registry operation status | `registry.status != 'Success'`   |

### Network
| Field Name  | Description | Example     |
| :---        |    :----   |          :---: |
| net.dip   | Destination IP address | `net.dip = 172.17.0.3`   |
| net.sip   | Source IP address | `net.sip = 127.0.0.1`   |
| net.dport   | Destination port | `net.dport in (80, 443, 8080)`   |
| net.sport   |Source port | `net.sport != 3306`   |
| net.dport.name   | Destination port name as per [IANA](https://www.iana.org/assignments/service-names-port-numbers/service-names-port-numbers.txt) port to service assignation | `net.dport.name = 'dns'`   |
| net.sport.name   | Source port name as per [IANA](https://www.iana.org/assignments/service-names-port-numbers/service-names-port-numbers.txt) port to service assignation | `net.sport.name = 'http'`   |
| net.l4.proto   | Layer 4 protocol name | `net.l4.proto = 'TCP'`   |
| net.size   | Network packet size | `net.size > 512`   |
| net.dip.names | List of destination IP address domain names | `net.dip.names in ('github.com.')` |
| net.sip.names | List of source IP address domain names | `net.sip.names in ('github.com.')` |


### Handle
| Field Name  | Description | Example     |
| :---        |    :----   |          :---: |
| handle.id   	| Handle identifier | `handle.id = 24`   |
| handle.object | Handle kernel object address | `handle.object = 'FFFFB905DBF61988'`   |
| handle.name   | Handle name | `handle.name = '\\Device\\NamedPipe\\chrome.12644.28.105826381'`   |
| handle.type   | Handle type | `handle.type = 'Mutant'`   |


### Memory
| Field Name  | Description | Example     |
| :---        |    :----   |          :---: |
| mem.address   	| Base address of the allocated region | `mem.address = '211d13f2000'`   |
| mem.size   	| Size of the allocated region | `mem.size > 438272`   |
| mem.alloc   	| Region allocation or release type | `mem.alloc = 'COMMIT'`   |
| mem.type   	| Designates the page type of the allocated region | `mem.type = 'PRIVATE'`   |
| mem.protection   	| Designates the protection type of the allocated region | `mem.protection = 'READWRITE'`   |
| mem.protection.mask   	| Designates the allocated region protection in mask notation | `mem.protection.mask = 'RWX'`   |


### DNS
| Field Name  | Description | Example     |
| :---        |    :----   |          :---: |
| dns.name 	| DNS query name | `dns.name = 'example.org'`   |
| dns.rr 	| DNS resource record type | `dns.rr = 'AA'`   |
| dns.options 	| DNS query options | `dns.options in ('ADDRCONFIG', 'DUAL_ADDR')`   |
| dns.rcode 	| DNS response status | `dns.rcode = 'NXDOMAIN'`   |
| dns.answers 	| DNS response answers | `dns.answers in ('o.lencr.edgesuite.net', 'a1887.dscq.akamai.net')`   |


### PE
| Field Name  | Description | Example     |
| :---        |    :----   |          :---: |
| pe.nsections   | Number of sections | `pe.nsections < 5`   |
| pe.nsymbols   | Number of entries in the symbol table | `pe.nsymbols > 230`   |
| pe.address.base   | Image base address | `pe.address.base = '140000000'`   |
| pe.address.entrypoint   | Address of the entrypoint function | `pe.address.entrypoint = '20110'`   |
| pe.sections[].entropy   | Specified section entropy | `pe.sections[.text].entropy > 6.2`   |
| pe.sections[].size   | Size in bytes of the specified section | `pe.sections[.text].size > 56000`   |
| pe.sections[].md5   | MD5 hash of the specified section | `pe.sections[.text].md5 = '0464997eb36c70083164c666d53c6af3'`   |
| pe.symbols   | Imported symbols | `pe.symbols in ('GetTextFaceW', 'GetProcessHeap')`   |
| pe.imports   | Imported dynamic linked libraries | `pe.imports in ('msvcrt.dll', 'GDI32.dll')`   |
| pe.resources  | Version and other PE resources | `pe.resources[FileDescription] = 'Notepad'`   |
| pe.company   | Internal company name of the file provided at compile-time | `pe.company = 'Microsoft Corporation'`  |
| pe.copyright | Copyright notice for the file emitted at compile-time | `pe.company = '© Microsoft Corporation'`  |
| pe.description   | Internal description of the file provided at compile-time | `pe.description = 'Notepad'`   |
| pe.file.name   | Original file name supplied at compile-time | `pe.file.name = 'NOTEPAD.EXE'`   |
| pe.file.version   | File version supplied at compile-time | `pe.file.version = '10.0.18362.693 (WinBuild.160101.0800)'`   |
| pe.product   | Internal product name of the file provided at compile-time | `pe.product = 'Microsoft® Windows® Operating System'`   |
| pe.product.name   | Internal product version of the file provided at compile-time | `pe.product.version = '10.0.18362.693'`   |
| pe.is_dll   | Indicates if the loaded image or a created file is a DLL | `pe.is_dll`   |
| pe.is_driver   | Indicates if the loaded image or a created file is a driver | `pe.is_driver`   |
| pe.is_exec   | Indicates if the loaded image or a created file is an executable | `pe.is_exec`   |
| pe.is_dotnet   | Indicates if the PE contains CLR (Common Language Runtime) data | `pe.is_dotnet`   |
| pe.is_signed   | Indicates if the PE has embedded or catalog signature | `pe.is_signed`   |
| pe.is_trusted   | Indicates if the PE certificate chain is trusted | `pe.is_trusted`   |
| pe.imphash   | Import hash | `pe.impash = '5d3861c5c547f8a34e471ba273a732b2'`   |
| pe.anomalies   | Contains PE anomalies detected during parsing | `pe.anomalies in ('number of sections is 0')`   |
| pe.cert.serial  | PE certificate serial number | `pe.cert.serial = '330000023241fb59996dcc4dff000000000232'`   |
| pe.cert.subject  | PE certificate subject | `pe.cert.subject contains 'Washington, Redmond, Microsoft Corporation'`   |
| pe.cert.issuer  | PE certificate CA | `pe.cert.issuer contains 'US, Washington, Redmond, Microsoft Windows Production PCA 2011'`   |
| pe.cert.after  | PE certificate expiration date | `pe.cert.after contains '2024-02-01 00:05:42 +0000 UTC'`   |
| pe.cert.before  | PE certificate enrollment date | `pe.cert.before contains '2024-02-01 00:05:42 +0000 UTC'`   |
| pe.is_modified | Indicates if on-disk and in-memory PE headers differ | `pe.is_modified'`   |
| pe.is_modified | Indicates if on-disk and in-memory PE headers differ | `pe.is_modified'`   |

```

`docs/filters/filtering.md`:

```md
# Filtering

### Anatomy of a filter {docsify-ignore}

At its simplest form, a filter is composed of the LHS (Left Hand Side) and RHS (Right Hand Side) expressions connected with an [operator](/filters/operators) that can pertain to binary, logical, or string operators. The LHS expression is usually a [field](/filters/fields) [path](/filters/paths), even though the use of fields is possible in Right Hand Side expressions as well.

```
    LHS          operator         RHS
kevt.category       =            'net'
```

Boolean fields, that is the fields that always evaluate to either `true` or `false` can appear alone in the filter expression. For example, `pe.is_dll` is the short form of `pe.is_dll = true` expression.

The RHS expressions can be strings, numbers, IP addresses, boolean values, and fields. In the above snippet, the RHS is a simple string literal, but we could have written filters with the following RHS expressions:

- IP addresses: `net.sip = 127.0.0.1`
- Booleans: `kevt.nparams != false`
- Numbers: `ps.pid = 4`
- Fields: `kevt.pid != ps.pid`

### Running filters {docsify-ignore}

As previously mentioned, filters can be engaged in various stages of event collection and processing. The filter expression is given  to `run`, `capture`, and `replay` commands in form of the command line argument.

The `run` command applies the filter expression to each inbound event and prevents the routing the the output sink if the event doesn't match the filter. The above command filters events that occur on `Monday` and are produced by `cmd.exe` and `svchost.exe` processes.

```
$ fibratus run --forward kevt.date.weekday = 'Monday' and ps.name in ('cmd.exe', 'svchost.exe')
```

!> If you're using PowerShell, it is necessary to enclose the entire filter expression in quotes. For example, `fibratus run --forward "kevt.category = 'net'"`


In a similar fashion, the `capture` command only dumps events that match the provided filter. In this case, the capture would boil down to `registry` events.

```
$ fibratus capture kevt.category = 'registry' -o events
```

When replaying events from the kcap file, you can also specify a filter to narrow down the replay context, for example, to filter out events that mutate registry values.

```
$ fibratus replay kevt.name = 'RegSetValue' -k events
```

Lastly, filtering is possible during filament execution. If the filter is set in both, the `run` command and through the `kfilter` function, the latter takes precedence. Filtering in filaments is thoroughly explained in [filaments](/filaments/introduction).

### Escaping characters {docsify-ignore}

As you might have noticed, string values are enclosed in single quotes `''`. If the string contains characters that would result in an illegal identifier, you'll have to escape the offending characters accordingly. For example, path delimiters (backslashes) or quotes need to be escaped:

```
$ fibratus run --forward file.name = 'C:\\Windows\\System32'
$ fibratus run --forward file.name contains '\"hosts\"'
```

Filter expressions can accept escape sequences, such as newline characters (`\n`).

### Invalid filters {docsify-ignore}

If a syntax error is present in the filter, a hint is given indicating the erroneous position in the expression.  

```
kevt.name in ('RegCreateKey', 'RegDeleteKey', 'RegSetValue', 'RegDeleteValue')
      and
   registry.key.name icontains
      (
        'CurrentVersion\\Run',
        'Windows\\System\\Scripts',
        'CurrentVersion\\Windows\\Load',
        'CurrentVersion\\Windows\\Run',
        'CurrentVersion\\Winlogon\\Shell',
        'CurrentVersion\\Winlogon\\System',
        'UserInitMprLogonScript'
      )
      or
   registry.key.name istartswith
      (
        'HKEY_LOCAL_MACHINE\\Software\\Microsoft\\Windows NT\\CurrentVersion\\Winlogon\\Notify',
        'HKEY_LOCAL_MACHINE\\Software\\Microsoft\\Windows NT\\CurrentVersion\\Winlogon\\Shell',
        'HKEY_LOCAL_MACHINE\\Software\\Microsoft\\Windows NT\\CurrentVersion\\Winlogon\\Userinit',
        'HKEY_LOCAL_MACHINE\\Software\\WOW6432Node\\Microsoft\\Windows NT\\CurrentVersion\\Drivers32',
        HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Control\\Session Manager\\BootExecute',
╭──────────^
|        'HKEY_LOCAL_MACHINE\\Software\\Microsoft\\Windows NT\\CurrentVersion\\AeDebug'
|      )
|      or
|   registry.key.name iendswith
|      (
|        'user shell folders\\startup'
|      )
|
|
╰─────────────────── expected field, string, number, bool, ip, function, pattern binding
```

```

`docs/filters/functions.md`:

```md
# Functions

Functions expand the scope of the filtering language by bringing a plethora of capabilities. The function can return a primitive value, including integers, strings, and booleans. Function calls can be nested where the result of one function is used as an input in another function. For example, `lower(ltrim(file.name, 'C:'))`, removes the `C` drive letter from the file path and converts it to a lower case string.

Additionally, some functions may return a collection of values. Function names are case insensitive.

### Network functions

#### cidr_contains

`cidr_contains` determines if the specified IP is contained within the block referenced by the given CIDR mask. The first argument represents the IP address and the subsequent   arguments are IP masks in CIDR notation.

- **Specification**
    ```
    cidr_contains(ip: <string>, cidrs: <string>...) :: <boolean>
    ```
    - `ip`: The IP address in v4/v6 notation
    - `cidrs`: The list of CIDR masks
    - `return` a boolean value indicating whether the IP pertains to the CIDR block

- **Examples**

    Assuming `net.sip` contains the `192.168.1.20` IP address

    ```
    cidr_contains(net.sip, '192.168.1.1/24', '172.17.1.1/8') = true
    ```

### Hash functions

#### md5

`md5` computes the MD5 hash of the given value.

- **Specification**
    ```
    md5(data: <string|[]byte>) :: <string>
    ```
    - `data`: The string or the byte array for which to calculate the hash
    - `return` a string representing the md5 hash

- **Examples**

    Assuming `registry.key.name` contains the `HKEY_LOCAL_MACHINE\SYSTEM\Setup\Pid` key.

    ```
    md5(registry.key.name) = 'eab870b2a516206575d2ffa2b98d8af5'
    ```

### String functions

#### concat

`concat` concatenates string/integer input arguments.

- **Specification**
    ```
    concat(args: <string|int>...) :: <string>
    ```
    - `args`: Strings or integers to be concatenated. This function requires at least 2 input arguments
    - `return` a concatenated string of all input arguments

- **Examples**

    Assuming `ps.domain` field contains `NT_AUTHORITY` and `ps.username` field contains `admin`.

    ```
    concat(ps.domain, '-', ps.username) = 'NT_AUTHORITY-admin'
    ```

#### ltrim

`ltrim` trims the specified prefix from a string.

- **Specification**
    ```
    ltrim(string: <string>, prefix: <string>) :: <string>
    ```
    - `string`: Input string
    - `prefix`: Prefix that is removed from the original input string
    - `return` a string with the specified prefix removed

- **Examples**

    Assuming `registry.key.name` contains the `HKEY_LOCAL_MACHINE\SYSTEM\Setup\Pid` key.

    ```
    ltrim(registry.key.name, 'HKEY_LOCAL_MACHINE\\') = 'SYSTEM\\Setup\\Pid'
    ```

#### rtrim

`rtrim` trims the specified suffix from a string.

- **Specification**
    ```
    rtrim(string: <string>, suffix: <string>) :: <string>
    ```
    - `string`: Input string
    - `prefix`: Suffix that is removed from the original string
    - `return` a string with the specified suffix removed

- **Examples**

    Assuming `registry.key.name` contains the `HKEY_LOCAL_MACHINE\SYSTEM\Setup\Pid` key.

    ```
    rtrim(registry.key.name, '\\Pid') = 'HKEY_LOCAL_MACHINE\\SYSTEM\\Setup'
    ```

#### lower

`lower` converts the string with all Unicode letters mapped to their lower case.

- **Specification**
    ```
    lower(string: <string>) :: <string>
    ```
    - `string`: Input string
    - `return` a string converted to lower case

- **Examples**

    Assuming `registry.key.name` contains the `HKEY_LOCAL_MACHINE\SYSTEM\Setup\Pid` key.

    ```
    lower(registry.key.name) = 'hkey_local_machine\\system\\setup'
    ```

#### upper

`upper` converts the string with all Unicode letters mapped to their upper case.

- **Specification**
    ```
    upper(string: <string>) :: <string>
    ```
    - `string`: Input string
    - `return` a string converted to upper case

- **Examples**

    Assuming `registry.key.name` contains the `HKEY_LOCAL_MACHINE\SYSTEM\Setup` key. 

    ```
    upper(registry.key.name) = 'HKEY_LOCAL_MACHINE\\SYSTEM\\SETUP'
    ```

#### replace

`replace` replaces all occurrences in the string as given by arbitrary old/new replacement pairs.

- **Specification**
    ```
    replace(string: <string>, old: <string>, new: <string>, ..., old-n: <string>, new-n: <string>) :: <string>
    ```
    - `string`: Input string
    - `old`: substring in the original string that is replaced with the `new` string
    - `new`: the replacement string
    - `return` a string with all occurrences replaced by old/new pairs

- **Examples**

    Assuming `registry.key.name` contains the `HKEY_LOCAL_MACHINE\SYSTEM\Setup` key.

    ```
    replace(registry.key.name, 'HKEY_LOCAL_MACHINE', 'HKLM', 'SYSTEM', 'SYS') = 'HKLM\\SYS\\Setup'
    ```

#### split

`split` produces a slice of substrings separated by the given delimiter.

- **Specification**
    ```
    split(string: <string>, sep: <string>) :: <[]string>
    ```
    - `string`: Input string
    - `prefix`: The separator that is used to split the string
    - `return` a slice of substrings

- **Examples**

    Assuming `file.name` contains the `C:\Windows\System32\kernel32.dll` path.

    ```
    split(file.name, '\\') in ('kernel32.dll', 'System32', 'Windows')
    ```

#### length

`length` returns the number of characters for string arguments and the size of the slice for slice arguments.

- **Specification**
    ```
    length(string: <string|slice>) :: <int>
    ```
    - `string`: Input string or slice
    - `return` the number of characters or array length

- **Examples**

    Assuming `ps.domain` field contains `"こんにちは"`.

    ```
    length(ps.domain) = 5
    ```

#### indexof

`indexof` returns the index of the instance of substring in a given string depending on the provided search order.

- **Specification**
    ```
    indexof(string: <string>, substring: <string>, order: <string>) :: <int>
    ```
    - `string`: Input string
    - `prefix`: Substring for which the search is performed
    - `order`: Specifies the string index search order. It can be `first`, `any`, `last`, `lastany`. This is an optional argument.
    - `return` the index of the substring

- **Examples**

    Assuming `ps.domain` contains `NT_AUTHORITY`.

    ```
    indexof(ps.domain, 'NT') = 0
    ```

#### substr

`substr` creates a substring of a given string.

- **Specification**
    ```
    substr(string: <string>, start: <int>, end: <int>) :: <string>
    ```
    - `string`: Input string
    - `start`: Substring start index
    - `end`: Substring end index (optional)
    - `return` a substring contained within start and end indices

- **Examples**

    Assuming `file.name` contains the `\Device\HarddiskVolume2\Windows\system32\user32.dll` path.

    ```
    substr(file.name, indexof(file.name, '\\'), indexof(file.name, '\\Hard')) = '\\Device'
    substr(file.name, indexof(file.name, 'system32')) = 'system32\\user32.dll'
    ```

#### entropy

`entropy` measures the string entropy.

- **Specification**
    ```
    entropy(string: <string>, algo: <string>) :: <int>
    ```
    - `string`: Input string
    - `algo`: The algorithm used to calculate the string entropy. `shannon` is the default entropy type. This argument is optional
    - `return` the string entropy

- **Examples**

    Assuming `file.name` contains the `\Device\HarddiskVolume2\Windows\system32\user32.dll` path.

    ```
    entropy(file.name) > 255
    ```

#### regex

`regex` applies single/multiple regular expressions on the provided string argument.

- **Specification**
    ```
    regex(string: <string>, patterns: <string>...) :: <bool>
    ```
    - `string`: Input string
    - `patterns`: Regular expression patterns
    - `return` `true` if at least one regular expression matches or `false` otherwise

- **Examples**

    Assuming `ps.name` contains `powershell.exe`.

    ```
    regex(ps.name, 'power.*(shell|hell).dll', '.*hell.exe') = true
    ```

### File functions

#### base

`base` returns the last element of the path.

- **Specification**
    ```
    base(path: <string|[]string>, ext: bool) :: <string|[]string>
    ```
    - `path`: The string or an array of strings representing file system path(s)
    - `ext`: Determines whether the extension is retained in the file path. This parameter is optional and `true` by default
    - `return` a string or a slice of strings with file names

- **Examples**

    Assuming `file.name` contains the `C:\\Windows\\cmd.exe` path.

    ```
    base(file.name) = 'cmd.exe'
    base(file.name, false) = 'cmd'
    ```

#### dir

`dir` returns all but the last element of the path, typically the path's directory.

- **Specification**
    ```
    dir(path: <string|[]string>) :: <string|[]string>
    ```
    - `path`: The string or an array of strings representing file system path(s)
    - `return` a string or a slice of strings with directory names

- **Examples**

    Assuming `file.name` contains the `C:\\Windows\\cmd.exe` path.

    ```
    dir(file.name) = 'C:\\Windows'
    ```

#### ext

`ext` returns the file name extension used by the path.

- **Specification**
    ```
    ext(path: <string>, dot: bool) :: <string>
    ```
    - `path`: The string representing file system path
    - `dot`: Indicates if the dot symbol is retained as part of extension. This parameter is optional and `true` by default
    - `return` file name extension used by the path

- **Examples**

    Assuming `file.name` contains the `C:\\Windows\\cmd.exe` path.

    ```
    ext(file.name) = '.exe'
    ext(file.name, false) = 'exe'
    ```

#### glob

`glob` returns the names of all files matching the pattern.

- **Specification**
    ```
    glob(pattern: <string>) :: <[]string>
    ```
    - `pattern`: Shell file name pattern as described [here](https://pkg.go.dev/path/filepath#Match)
    - `return` returns the names of all files matching the pattern or an empty list if there is no matching file

- **Examples**

    ```
    glob('C:\\Windows\\*.exe') in ('C:\\Windows\\notepad.exe')
    ```

#### is_abs

`is_abs` reports whether the path is absolute.

- **Specification**
    ```
    is_abs(path: <string>) :: bool
    ```
    - `path`: The string representing file system path
    - `return` `true` if `path` references an absolute path or `false` otherwise

- **Examples**

    Assuming `file.name` contains the `Windows\\cmd.exe` path.

    ```
    is_abs(file.name) = false
    ```

#### symlink

`symlink` returns the path name after the evaluation of any symbolic links.

- **Specification**
    ```
    symlink(path: <string>) :: string
    ```
    - `path`: The string representing file system path
    - `return` the path name after the evaluation of any symbolic links, or the original path if any errors occur

- **Examples**

    Assuming `file.name` contains the `C:\\Windows\\symlink.txt` path which is a symlink to `C:\Windows\target.txt`.

    ```
    symlink('C:\\Windows\\symlink.txt') = 'C:\\Windows\\target.txt'
    ```

#### volume

`volume` returns leading volume name.

- **Specification**
    ```
    volume(path: <string>) :: string
    ```
    - `path`: The string representing file system path
    - `return` leading volume name

- **Examples**

    Assuming `file.name` contains the `C:\\Windows\\symlink.txt` path.

    ```
    volume(file.name) = 'C:'
    ```

#### is_minidump

`is_minidump` checks the signature of the provided file and returns `true` if the signature matches the `minidump` file.

- **Specification**
    ```
    is_mindump(path: <string>) :: <bool>
    ```
    - `string`: The file path for which the minidump signature is checked
    - `return` `true` if the file contains the `minidump` signature or `false` otherwise

- **Examples**

    Assuming `file.name` contains the `C:\\Temp\\lsass.dmp` path with a valid `minidump` file. 

    ```
    is_minidump(file.name) = true
    ```

### Registry functions

`get_reg_value` retrieves the content of the registry value.

- **Specification**
    ```
    get_reg_value(key: <string>) :: <string|[]string|int>
    ```
    - `key`: Is the fully-qualified registry key path including the value name. The root key can be expressed in abbreviated notation, e.g. instead of `HKEY_LOCAL_MACHINE` you can write `HKLM`.
    - `return` depending on the registry value type, it can return a string, array of strings or an integer value.

- **Examples**

    Assuming the `HKEY_CURRENT_USER\Volatile Environment\Envs` registry value contains a multi-size string with `dev\0staging` values.

    ```
    get_reg_value('HKCU\Volatile Environment\Envs') in ('dev', 'staging')
    ```


### YARA functions

`yara` provides signature-based detection in filters and rules. YARA is a tool aimed at (but not limited to) helping malware
researchers to identify and classify malware samples. With YARA you can create descriptions of malware families based on textual
or binary patterns. Depending on the parameter type supplied to this function, the scan can be performed on the process, filename or a memory block.

- **Specification**
    ```
    yara(target: <int|string|[]byte>, rules: <string>) :: bool
    ```
    - `target`: If this parameter is an integer value, it's assumed to be a pid for which the memory area is scanned. If it is a string, the scan is performed on the process image executable or arbitrary file system file. Otherwise, it is a stream of bytes that represents a memory block to be scanned.
    - `rules`: a string containing YARA rules
    - `return` if any rule defined in the `rules` parameter matches, the function returns `true`. Otherwise, it returns `false`.

- **Examples**

    Assuming `file.name` contains `C:\\Windows\\notepad.exe`. 

    ```
    yara(file.name, 'rule Notepad : notepad
{
	strings:
		$c0 = "Notepad" fullword ascii
	condition:
		$c0
}') = true
    ```

```

`docs/filters/introduction.md`:

```md
# Needle In The Haystack

An overwhelming volume of events makes it challenging to dig out valuable insights or to narrow down the scope of a particular investigation or postmortem scenario. To streamline day-to-day tasks and to propel your workflow, Fibratus delivers a powerful engine for building sophisticated filtering expressions. Let's assume you want to catch events originated from `cmd.exe`, `powershell.exe`, `winword.exe` processes, or processes that export the `WORKER=1` environment variable and whose current working directory contains the `Users\Public` path. We can write such a filter as:

```
ps.name in ('cmd.exe', 'powershell.exe', 'winword.exe')
        or ps.envs['WORKER'] = '1'
        and ps.cwd contains 'Users\\Public'
```

It may look intimidating at first glance, but once you get familiar with the syntax and the field names you'll be able to write even the most intricate filters.

Filters represent the foundation of the [rule engine](/filters/rules) that provides threat detection capabilities. For example, the following stanza detects the outbound communication followed by the execution of the command shell within one-minute time window. The action invokes the [alert sender](/alerts/senders) to emit the security alert via email, Slack, or a 
different supported channel. 

```yaml
name: Remote connection followed by command shell execution
id: eddace20-4962-4381-884e-40dcdde66626
version: 1.0.0

condition: >
  sequence
  maxspan 1m
  by ps.uuid
    |kevt.name = 'Connect'
      and
      not
     cidr_contains(
      net.dip,
      '10.0.0.0/8',
      '172.16.0.0/12'
     )
    |
    |kevt.name = 'CreateProcess'
      and
     ps.child.name in ('cmd.exe', 'powershell.exe') 
    |
    
output: > 
  Command shell spawned after remote connection %2.ps.exe 
  process spawned a command shell after connecting to %1.net.dip

severity: critical

min-engine-version: 2.0.0
```

```

`docs/filters/iterators.md`:

```md
# Iterators

`foreach` idiom adds iteration capabilities to the rule language. Under the hood, `foreach` is implemented as a function that accepts three required and multiple optional arguments. The first argument is the `iterable` value typically yielded by the pseudo field. 

The function recognizes process internal state collections such as modules, threads, memory mappings, or thread stack frames. Obviously, it is also possible to iterate over simple string slices. The second argument represents the `bound variable` which is an item associated with every element in the slice. The bound variable is accessed in the third argument, the `predicate`. It is usually followed by the `segment` that denotes the accessed value. Unsurprisingly, the predicate is commonly a binary expression that can be formed of `not/paren` expressions, other functions, and so on. The predicate is executed on every item in the slice. If the predicate evaluates to true, the function also returns the true value.

Lastly, foreach function can receive an optional `list of fields` from the outer context, i.e. outside predicate loop. Therefore, for the predicate to access the field not defined within the scope of the iterable, it must capture the field first.

Some examples of the `foreach` usage:

- Traverses process modules and return true if the module path matches the pattern

```
foreach(ps._modules, $mod, $mod.path imatches '?:\\Windows\\System32\\us?r32.dll')
```

- For each process ancestor, check if the ancestor is `services.exe` and the current process is protected. In this example, the `ps.is_protected` field is captured before its usage in the predicate

```
foreach(ps._ancestors, $proc, $proc.name = 'services.exe' and ps.is_protected, ps.is_protected)
```

## Process iterators {docsify-ignore}

The `ps.ancestor` returns all ancestor names of the process generating the event. Alternatively, the filter field can accept an argument. In case of the `ps.ancestor` field, the argument indicates the ancestor level. Given the process tree below and assuming the current process generating the event is `cmd.exe`, the field with an optional level argument yields the values as follows:

```
├───wininit.exe
│   └───services.exe
│       └───svchost.exe
│           └───dllhost.exe
│               ├───cmd.exe
│               └───winword.exe
```

- `ps.ancestor[1]` returns `dllhost.exe`
- `ps.ancestor[3]` returns `services.exe`
- `ps.ancestor[4]` returns `wininit.exe`

If the argument is omitted, the slice with all ancestor names is returned. The `ps.ancestor` field can only yield a single process attribute - process name. To build complex conditions involving different process attribute, we can use the `foreach` construct. The bound variable associated with the `ps._ancestors` pseudo field can have the any of the segments:

| Segment Name  | Description |
| :---        |    :----    |
|`pid` | Process identifier |
|`name` | Process name |
|`args` | Process command line arguments as a list of strings |
|`cmdline` | Process command line argument as a raw string |
|`cwd`  | Process current working directory |
|`exe` | Process image path |
|`sid` | Process SID (security identifier) |
|`sessionid` | Process session identifier |
|`username` | User name associated with the process security context |
|`domain`  | Domain associated with the process security context |

Examples

- Check if the ancestor has one of the particular process identifiers and the pid belongs to the `services.exe` process

```
foreach(ps._ancestors, $proc, $proc.pid in (2034, 343) and $proc.name = 'services.exe')
```

- Check if the ancestor starts with the specific security identifier and the pid belongs to the `svchost.exe` process

```
foreach(ps._ancestors, $proc, $proc.sid imatches `S-1-5*` and $proc.name = 'svchost.exe')
```


### Modules {docsify-ignore}

The `ps._modules` pseudo field returns the process modules iterable. Available module segments are:


| Segment Name  | Description |
| :---        |    :----    |
|`address` | Base address of the process in which the module is loaded|
|`checksum` | Module checksum |
|`size` | Module size in terms of allocated virtual address space |
|`name` | Module name |
|`path`  | Full module path |

Examples

- Check the virtual memory space size of the specific module

```
foreach(ps._modules, $mod, $mod.size >= 212354 and $mod.name imatches '*winhttp.dll')
```

### Threads {docsify-ignore}

The `ps._threads` pseudo field yields all of the process running threads. Available thread segments are:


| Segment Name  | Description |
| :---        |    :----    |
|`tid` | Thread identifier |
|`start_address` | The address of the function executed by the thread |
|`user_stack_base` | The base address of the thread userspace stack |
|`user_stack_limit` | The address denoting the thread userspace stack limit  |
|`kernel_stack_base`  | The base address of the thread kernel stack |
|`kernel_stack_limit`  | he address denoting the thread kernel stack limit |

### Memory mappings {docsify-ignore}

Process memory mappings (also known as sections) can be accessed via the `ps._mmaps` pseudo field. Available memory mappings segments are:

| Segment Name  | Description |
| :---        |    :----    |
|`address` | Address where the section is mapped within the process address space |
|`type` | The type of the memory mapping. For example, `DATA`. |
|`size` | Size in bytes of the memory mapping |
|`protection` | Protection attributes of the mapped memory section |
|`path`  | If the memory mapping is backed by a physical file, indicates the path of the file |

### Environment variables {docsify-ignore}

You can access process environment variables by providing the name of the environment variable. Alternatively, you can provide the prefix.

```
ps.envs['MOZ_CRASHREPORTER'] = 'C:\\Program Files\\Firefox'
```

Or, supplying the prefix

```
ps.envs['MOZ_CRASH'] = 'C:\\Program Files\\Firefox'
```

It is also possible to retrieve all environment variables as a list of colon separated key/value pairs. Example using the `foreach` idiom:

```
foreach(ps.envs, $env, substr($env, 0, indexof($env, ':')) = 'OS')
```

## Portable Executable iterators {docsify-ignore}

[Portable Executable](/pe/introduction) introspection allows for utilizing the PE metadata in filters. See other [fields](filters/fields?id=pe) that can be used to narrow down events by PE data.

### Sections {docsify-ignore}

The `pe._sections` pseudo field yields all of the executable image PE sections. Available section segments are:

| Segment Name  | Description |
| :---        |    :----    |
|`name` | Section name. For example, `.debug$` |
|`size` | Section size in bytes |
|`entropy` | Section entropy |
|`md5` | Section MD5 hash |

### Resources {docsify-ignore}

PE [resources](/pe/resources) can be accessed by the resource name. Alternatively, it is possible to obtain all the resources as a list separated by the colon delimiter:

```
pe.resources iin ('FileDescription:Notepad')
```


## Callstack {docsify-ignore}

[Stack enrichment](/kevents/anatomy?id=callstack) attaches call frames that can be accessed by the `thread._callstack` pseudo field. Available callstsack segments are:

| Segment Name  | Description |
| :---        |    :----    |
|`address` | Symbol address |
|`offset` | Symbol offset |
|`symbol` | Symbol name |
|`module` | Module name containing the frame |
|`allocation_size` | Private allocation size |
|`protection` | Frame protection mask |
|`is_unbacked` | Indicates if the frame is unbacked |
|`callsite_leading_assembly` | Callsite leading assembly instructions |
|`callsite_trailing_assembly` | Callsite trailing assembly instructions|
|`module.signature.is_signed` | Indicates if the frame module is signed |
|`module.signature.is_trusted` | Indicates if the frame module signature is trusted |
|`module.signature.cert.subject` | Frame module signature certificate subject |
|`module.signature.cert.issuer` | Frame module signature certificate issuer |

Examples:

- Determine if the frame protection is RWX (Read-Write-Execute)

```
foreach(thread._callstack, $frame, $frame.protection = 'RWX')
```

- Determine if the frame trailing assembly contain the `syscall` instruction and the frame resides in the floating memory region

```
foreach(thread._callstack, $frame, $frame.callsite_trailing_assembly matches '*mov r10, rcx|mov eax, 0x*|syscall*' and $frame.module = 'unbacked')
```
```

`docs/filters/operators.md`:

```md
# Operators

The filter engine supports logical, arithmetic, and string operators. Operator names are case-insensitive.

## Binary operators

The filtering query language supports the following comparison binary operators:

- `=` (equal)
- `!=` (not equal)
- `<` (less than)
- `>` (greater than)
- `>=` (greater or equal)
- `<=` (less or equal)
- `~=` (case-insensitive string comparison)

## Logical operators

Logical operators are applied on two or more binary expressions, except for `not` that acts as a unary operator.

### or

`or` (union) evalutes to true if either one of the LHS (Left Hand Side) or RHS (Right Hand Side) expressions are true. 

- **Example**

   Filter events where the originating process name is equal to `svchost.exe` or the process name contains the `svc` string

   ```
   fibratus run ps.name = 'svchost.exe' or ps.name contains ('svc')
   ```

### and

`and` (intersection) evalutes to true if both of the LHS (Left Hand Side) and RHS (Right Hand Side) expressions are true.

- **Example**

   Filter events only when the originating process name is equal to `System` and the process identifier is equal to `4`

   ```
   fibratus run ps.name = 'System' and ps.pid = 4
   ```

### not

`not` (negation) negates the result of the adjacent expression.

- **Example**

   Filter events only when the originating process name is equal to `svchost.exe` and none of the process' command line arguments is equal to `/-C` or `/cdir`

   ```
   fibratus run ps.name = 'svchost.exe' and ps.args not in ('/-C', '/cdir') 
   ```

## String operators

String operators are applied to string field types or string literals.

### in, iin

`in` operator validates the presence of a value in the string sequence. It can be applied to string literal sequences or dynamic string slices given by filter fields. `iin` is the case-insensitive variant of the `in` operator.

- **Examples**

   Tests if the process name producing the event is either `cmd.exe` or `powershell.exe`

   ```
   $ fibratus run ps.name in ('cmd.exe', 'powershell.exe')
   ```

   Checks if any of the process modules contains the `kernel32` dynamic linked object

   ```
   $ fibratus run ps.modules in ('kernel32.dll')
   ```

### contains, icontains

`contains` operator checks whether a string field contains a sequence of characters. This operator works on both simple string values and lists of strings. `icontains` is the case-insensitive variant of the `contains` operator.

- **Examples**

   Checks if the process' name contains the `cmd` or `power` substrings

   ```
   $ fibratus run ps.name contains ('cmd', 'power')
   ```

   Checks if the process' command line contains the `Windows Tasks` substring

   ```
   $ fibratus run ps.comm contains 'Windows Tasks'
   ```


### startswith, istartswith

`startswith` checks whether a string field starts with a specified prefix. This operator works on both simple string values and lists of strings. `istartswith` is the case-insensitive variant of the `startswith` operator.

- **Example**

   Filter events where the originating process name is equal to `svchost.exe`

   ```
   fibratus run ps.name startswith 'svchost'
   ```


### endswith, iendswith

`endswith` checks whether a string field ends with a specified suffix. This operator works on both simple string values and lists of strings. `iendswith` is the case-insensitive variant of the `endswith` operator.

- **Example**

   Filter events where the originating process name is equal to `svchost.exe`

   ```
   fibratus run ps.name endswith '.exe'
    ```

### intersects, iintersects

`intersects` operator and its case-insensitive `iintersects` variant operate on string slices. If all elements in the RHS slice are present in the slice given by LHS, the operator evaluates to `true`. Otherwise, it evaluates to `false`.

- **Example**

   Filter events where the originating process command line arguments contain both `DcomLaunch` and `LSM` arguments

   ```
   fibratus run ps.args intersects ('DcomLaunch', 'LSM')
   ```

### matches, imatches

`matches` is the swiss army knife string matching operator. It allows string matching by using the wildcard characters similar to [globbing](https://en.wikipedia.org/wiki/Glob_(programming)). The `*` wildcard matches a sequence of characters, while the `?` wildcard matches a single character. `imatches` is the case-insensitive variant of the `matches` operator.

- **Examples**

   To match events with file paths equal to `C:\\Windows\\System32\\lsass2.dmp` or `C:\\ProgramData\\Directory\\tmp\\anubis.dll`

   ```
   fibratus run file.name matches ('C:\\*\\lsass?.dmp', 'C:\\ProgramData\\*.dll')
   ```

   For filtering registry events with key names such as `HKEY_USERS\\S-1-5-21-2271034452-2606270099-984871569-1001\\Environment\\windir`

   ```
   fibratus run registry.key.name matches 'HKEY_USERS\\*\\Environment\\windir'
   ```

### fuzzy, ifuzzy, fuzzynorm, ifuzzynorm

`fuzzy` operators allow for flexibly matching a string with partial input based on [fuzzy matching](https://en.wikipedia.org/wiki/Fuzzy_matching_(computer-assisted_translation)) techniques. `fuzzynorm` applies Unicode normalization before running the matching phase. `ifuzzy` and `ifuzzynorm` are the case-insensitive variants of the respective fuzzy operators.

- **Examples**

   To match events with file paths that contain `C:\\Windows\\System32\\user32.dll`, you could create an expression with the  partial path input

   ```
   fibratus run file.name fuzzy 'C:\\Windows\\Sys\\ser3ll'
   ```

   `fuzzynorm` operates on normalized Unicode codepoints

   ```
   fibratus run file.name fuzzynorm 'C:\\Windows\\Sys\\sér3ll'
   ```
```

`docs/filters/prefiltering.md`:

```md
# Prefiltering

Sometimes it is useful to drop certain events either by image (process) name or event type once the event is peeked from the tracing buffer. Besides this, the kernel stream consumer can be configured to ignore events at the `ETW` session level. This can drastically reduce the impact on the system load if you're not interested in events that may produce an immense volume of data. 

The above is the summary of configuration options that influence the collection of events. These options are placed in the `kstream` section of the configuration file.

- `enable-thread` enables/disables the collection of the thread-related kernel events
- `enable-registry` enables/disables the collection of registry kernel events
- `enable-net` enables/disables the collection of network kernel events
- `enable-fileio` enables/disables the collection of the file system events
- `enable-image` enables/disables the collection of image loading/unloading events
- `enable-handle` enables/disables the collection of handle events
- `enable-audit-api` enables/disables kernel audit API calls events
- `enable-mem` enables/disables the collection of memory events
- `enable-dns` enables/disables DNS telemetry
- `enable-threadpool` enables/disables thread pool telemetry

### Excluding processes or events {docsify-ignore}

If you want to permanently exclude specific events or processes that produce them from the event flow, you can achieve this by defining the blacklist in the `kstream.blacklist` configuration section:

- `events` contains a list of event names that are dropped from the event stream.
- `images` contains a list of case-sensitive process image names including the extension. Any event originated by the image specified in this list is dropped from the event stream.

```

`docs/filters/rules.md`:

```md
# Rules

Rules bring a set of capabilities for detecting and disrupting the adversary kill chain exploiting stealthy attacks and advanced threat models. Fibratus comes equipped with a decent catalog of [detection rules](https://github.com/rabbitstack/fibratus/tree/master/rules) built on top of the [MITRE ATT&CK](https://attack.mitre.org/) framework with each rule mapped to the most relevant tactics, techniques, and sub-techniques.

Detection rules are organized in `yaml` files. Rules can live in different directories and there is no strict naming convention. However, the recommended practice is to follow the `tactic_name_rule_name.yml` naming nomenclature. Analysts are encouraged to follow design guidelines to produce optimal rules.

#### Stick to naming nomenclature {docsify-ignore}

It is highly recommended to name the rule files after the pattern explained in the above section. This facilitates the organization and searching through the detection rules catalog and fosters standardization.

#### Include descriptions and labels {docsify-ignore}

Rules should have a meaningful description.
For example, `Potential process injection via tainted memory section`.

Additionally, there should exist labels attached to every rule describing the MITRE tactic, technique, and sub-technique. This information is used when rendering email rule alert templates as depicted in the image above.

#### Rules should have a narrowed event scope {docsify-ignore}

If a rule is declared without the scoped event conditions, such as `kevt.name` or `kevt.category`, you'll get a warning message in `Fibratus` logs informing you about unwanted side effects. **This always lead to the rule being utterly discarded by the engine!**

#### Pay attention to the condition arrangement {docsify-ignore}

As highlighted in the previous paragraph, all rules should have the event type condition. Additionally, condition arrangement may have important runtime performance impact because the rule engine can lazily evaluate binary expressions that comprise a rule. In general, costly evaluations or functions such as `get_reg_value` should go last to make sure they are evaluated after all other expressions have been visited.

#### Prefer macros over raw conditions {docsify-ignore}

Fibratus comes with a [macros](https://www.fibratus.io/#/filters/rules?id=macros) library to promote the reusability and modularization of rule conditions and lists. Before trying to spell out a raw rule condition, explore the library to check if there's already a macro you can pull into the rule. For example, detecting file accesses could be accomplished by declaring the `kevt.name = 'CreateFile' and file.operation = 'open'` expression. However, the macro library comes with the `open_file` macro that you can directly call in any rule. If you can't encounter a particular macro in the library, please consider creating it. Future detection engineers and rule writers could profit from those macros.

#### Formatting styles {docsify-ignore}

Pay attention to rule condition/action formatting style. If the rule consists of multiple or large expressions, it is desirable to split each spanning expression on a new line and properly indent the `and`, `or`, or `not` operators. By default, we use 1 space tab for indenting operators and rule actions. This notably improves readability and prevents formatting inconsistencies.

### Loading rules

By default, rules reside inside `%PROGRAM FILES%\Fibratus\Rules` directory. You can load any number of rule files from file system paths or URL locations. It is possible to utilize the wildcard expressions in file paths to enumerate multiple rule files from a single path specifier.

Edit the main [configuration](/setup/configuration?id=files) file. Go to the `filters` section where the following `yaml` fragment is located:

```yaml
filters:
  rules:
    from-paths:
      - C:\Program Files\Fibratus\Rules\*.yml
    from-urls:
      - https://raw.githubusercontent.com/rabbitstack/fibratus/master/rules/credential_access_unusual_access_to_windows_credential_history.yml
```

- `from-paths` represents an array of file system paths pointing to the rule definition files
- `from-urls` is an array of URL resources that serve the rule definitions

### Creating rules

Let's have a glimpse at an example of a simple rule definition described in `yaml` format. When creating a new rule, use the `fibratus rules create` CLI command. It will create a `yaml` template with some required fields populated automatically. Run `fibratus rules create -h` to get extended help on this command.

```yaml
name: Unusual access to Windows Credential history files
id: 9d94062f-2cf3-407c-bd65-4072fe4b167f
version: 1.0.0
description: |
  Detects unusual accesses to the Windows Credential history file.
  The CREDHIST file contains all previous password-linked master key hashes used by
  DPAPI to protect secrets on the device. Adversaries may obtain credentials
  from the Windows Credentials Manager.
enabled: true
labels:
  tactic.id: TA0006
  tactic.name: Credential Access
  tactic.ref: https://attack.mitre.org/tactics/TA0006/
  technique.id: T1555
  technique.name: Credentials from Password Stores
  technique.ref: https://attack.mitre.org/techniques/T1555/
  subtechnique.id: T1555.004
  subtechnique.name: Windows Credential Manager
  subtechnique.ref: https://attack.mitre.org/techniques/T1555/004/
tags:
  - credential stealing
references:
  - https://www.passcape.com/windows_password_recovery_dpapi_credhist

condition: >
  open_file
    and
  file.name imatches '?:\\Users\\*\\AppData\\*\\Microsoft\\Protect\\CREDHIST'
    and
    not
  ps.exe imatches
    (
      '?:\\Program Files\\*',
      '?:\\Windows\\System32\\lsass.exe',
      '?:\\Windows\\System32\\svchost.exe',
      '?:\\Windows\\ccmcache\\*.exe'
    )

output: |
  Detected an attempt by `%ps.name` process to access and read
  Windows Credential history file at `%file.name`
severity: critical

action:
  - name: kill

min-engine-version: 2.0.0

notes: |
  Anything else relevant for the analyst.
```

1. `name` (required). Short title to emphasize rule's intent. The rule name is primary message used in security alerts.
2. `id` (required). Anchors a unique identifier to the rule that never changes, while the name could change over time.
3. `version` (required). Describes the rule version. The version is useful to track regressions or breaking changes.
4. `description` (optional). A larger explanation of what the rule should detect. Provide as much context as possible to the analyst.
5. `enabled` (optional). Sometimes it comes in handy to temporarily disable a specific rule. If omitted, the default value is `true`.
6. `labels` (optional). Arbitrary key/value pairs. As per [best practices](https://github.com/rabbitstack/fibratus/tree/master/rules#guidelines) rule design guidelines, it is highly recommended to include labels for the MITRE tactic, technique/sub-technique. Of course, you are free to populate the labels attribute with any other useful data.
7. `tags` (optional). Unlike labels, tags represent a sequence of meaningful keywords that you may find useful for categorization purposes.
8. `references` (optional). List of web resources, documents, etc. with relevant information about adversary tactics, defensive strategy, and so on.
9. `condition` (required). Well-known filter expression we used to employ in the CLI filters. You might have spotted some additional constructs like `open_file`. They are called macros, and we'll dive into macros goodies in the next section.
11. `output` (optional) Provides additional context in the alert description. It is possible to use fields interpolation, as seen later.
12. `severity` (optional) Sets the alert severity. Possible values are `low`, `medium`, `high`, and `critical`. If omitted, `medium` severity is assumed.
13. `action` (optional) Rule action can perform a variety of operations, such killing a process involved in the matched rule condition.
14. `min-engine-version` (required) Identifies the minimum Fibratus version that is compatible with the rule.
15. `notes` (optional). Any notes or observations that you would like to communicate to the analyst.

#### Macros

Macros foment rule patterns reusability and a human-friendly domain-specific language (DSL). A vast majority of detection rules may require conditions to express process execution or file writes. Traditionally, one could spell out a raw filter expression such as `kevt.name = 'CreateProcess'`. This may lead to bloated and boilerplate rules. From the maintenance standpoint, introducing a small change in the rule condition would force us to update all the rules, while macros are a much more convenient mechanism for declaring reusable rule patterns. Fibratus ships with a [macros library](https://github.com/rabbitstack/fibratus/blob/master/rules/macros/macros.yml) containing a dozen of different macros ready to use. Macros library is loaded from the file system and can be split across multiple `yaml` files. The default location is designated by the `%PROGRAM FILES%\Fibratus\Rules\Macros` directory.

```yaml
filters:
  macros:
    from-paths:
      - C:\Program Files\Fibratus\Rules\Macros\*.yml
```

Macros come in two flavors:

- **expression** macros encapsulate filter expressions. A macro declaration requires a unique macro name, the filter expression, and an optional description.

```yaml
- macro: spawn_process
  expr: kevt.name = 'CreateProcess'
  description: Identifies the execution of a new process
```

Where macro expressions really shine is when combined with other macros to forge recursive macros. For example, the `spawn_msoffice_process` is composed of `spawn_process` expression macro and the `msoffice_binaries` list macro.

```yaml
- macro: spawn_msoffice_process
  expr: spawn_process and ps.sibling.exe iin msoffice_binaries
  description: Identifies the execution of the MS Office process
```

- **list** macros declare a sequence of items such as file system paths, process names, or registry keys. List macros help to make the rules succinct and clean. An example of a macro list containing Microsoft Office process image names. Various operators, such as `in`, `matches`, or `startswith` can accept list macros as RHS (Right Hand Side) expressions.

```yaml
- macro: msoffice_binaries
  list: [EXCEL.EXE, WINWORD.EXE, MSACCESS.EXE, POWERPNT.EXE]
```

#### Templates {docsify-ignore}

Both, rule and macro `yaml` files can include Go [template](https://pkg.go.dev/text/template) directives. This encompasses loops, conditional directives, pipelines, or functions. Fibratus ships with a collection of [predefined](http://masterminds.github.io/sprig/) functions for string and filepath manipulation, math, date, and cryptographic functions to name a few. 

To illustrate the use of templates, let's assume the rules we deploy should require a minimum engine version of `2.0.0` under the presence of a certain environment variable in the host. By combining different Go template directives, we can conditionally render a fragment of the `yaml` file if the `env` function which receives the `AZ` environment variable name returns the `za` value.

```yaml
name: Execution via Microsoft Office process
id: a10ebe66-1b55-4005-a374-840f1e2933a3
version: 1.0.0
description:
  Identifies the execution of the file dropped by Microsoft Office process.
labels:
  tactic.id: TA0001
  tactic.name: Initial Access
  tactic.ref: https://attack.mitre.org/tactics/TA0001/
  technique.id: T1566
  technique.name: Phishing
  technique.ref: https://attack.mitre.org/techniques/T1566/
  subtechnique.id: T1566.001
  subtechnique.name: Spearphishing Attachment
  subtechnique.ref: https://attack.mitre.org/techniques/T1566/001/

condition: >
  sequence
  maxspan 1h
    |create_file
      and
     (file.extension iin executable_extensions or file.is_exec)
      and
     ps.name iin msoffice_binaries
    | by file.name
    |spawn_process
      and
     ps.name iin msoffice_binaries
    | by ps.child.exe

{{- if eq (env "AZ") "za" }}
min-engine-version: 2.0.0
{{- else }}
min-engine-version: 2.2.0
{{- end }}
```

### Actions

Actions are responses executed as a consequence of rule matches. Actions provide alerting and prevention capabilities aim at stopping the adversary at the initial stages of the attack.

#### Generating alerts

Alerts are automatically generated when the rule matches. The alert is sent via all active [senders](/alerts/senders). [Systray](/alerts/senders/systray) alert sender is enabled by default. The rule name is used in the alert title. To provide extra context in the alert, the rule `output` attribute can be used in combination with **field interpolation**. In the following snippet, we use the `%ps.exe` format modifier to render the process executable path. Formats modifiers are well-known filter fields prefixed with the `%` symbol. 

```yaml
output: |
  "%ps.exe process spawned a command shell after connecting to the remote endpoint
```

In the case of sequence rules, we can access the desired event reference by including the ordinal which points to the slot in the sequence. This way, `%1.ps.name` would yield the name of the process in the first sequence slot, while `%2.file.name` gives us the filename located in the event reference of the second slot. Both, title and text permit including Markdown or HTML tags.

```yaml
output: |
  Detected an attempt by <code>%1.ps.name</code> process to access
  and read the memory of the **Local Security And Authority Subsystem Service**
  and subsequently write the <code>%2.file.name</code> dump file to the disk device
```

[email](alerts/senders/mail.md) alert senders render beautiful responsive HTML emails as depicted in the image below. Email rule alerts deliver high-fidelity and incident-centric notifications that aim to prevent alert fatigue by summarizing key investigation insights.

<p align="center">
  <img src="filters/images/rule-alert.png"/>
</p>

The email alerts have the following sections:

- Date, time, and the hostname where the alert was triggered
- Alert severity given by the `severity` attribute
- Alert title as specified the `name` attribute
- Alert description as specified by the `output` attribute
- Links with MITRE tactic, technique, and sub-technique
- The list of security events involved in the incident. For each event, the name, timestamp, and excerpt are shown. Next, all event attributes and process state information is represented.

#### Killing processes

`kill` action terminates the process involved in matched rule condition. Fibratus needs to acquire the process handle with the `PROCESS_TERMINATE` access rights to successfully kill the process.

```yaml
action:
  - name: kill
```

#### Isolating endpoints

`isolate` action isolates the host by installing **Windows Filtering Platform** (WFP) rules. To revert the effects of the `isolate` action, simply restart the Fibratus service. The action can be combined with other actions. For example, the following snippet will kill the process and isolate the endpoint.


```yaml
action:
  - name: kill
  - name: isolate
```

### Advanced patterns

Adversaries often employ sophisticated techniques which may be daunting to detect without combining events from different data sources. For example, detecting a remote connection attempt followed by the execution of a command shell by the same process that initiated the connection can't be expressed with a simple rule expecting to match on a single event. Enter `sequence` rules.

#### Sequences

In a nutshell, sequences permit state tracking of an ordered series of events over a short period of time. Let's peer into the structure of sequence-powered rules. Sequence rules start with the `sequence` keyword as you can observe in the `LSASS memory dumping via legitimate or offensive tools` rule's condition. Sequence consists of two or more expressions surrounded by vertical bars or pipes. For the sequence to match, all expressions need to match successively in time.

```yaml
name: LSASS memory dumping via legitimate or offensive tools
id: 335795af-246b-483e-8657-09a30c102e63
version: 1.0.0
description: |
  Detects an attempt to dump the LSAAS memory to the disk by employing legitimate
  tools such as procdump, Task Manager, Process Explorer or built-in Windows tools
  such as comsvcs.dll.
labels:
  tactic.id: TA0006
  tactic.name: Credential Access
  tactic.ref: https://attack.mitre.org/tactics/TA0006/
  technique.id: T1003
  technique.name: OS Credential Dumping
  technique.ref: https://attack.mitre.org/techniques/T1003/
  subtechnique.id: T1003.001
  subtechnique.name: LSASS Memory
  subtechnique.ref: https://attack.mitre.org/techniques/T1003/001/
references:
  - https://redcanary.com/threat-detection-report/techniques/lsass-memory/
  - https://www.deepinstinct.com/blog/lsass-memory-dumps-are-stealthier-than-ever-before

condition: >
  sequence
  maxspan 2m
  by ps.uuid
    |open_process
      and
     ps.access.mask.names in ('ALL_ACCESS', 'CREATE_PROCESS', 'VM_READ')
      and
     kevt.arg[exe] imatches '?:\\Windows\\System32\\lsass.exe'
      and
      not
     ps.exe imatches
      (
        '?:\\Windows\\System32\\svchost.exe',
        '?:\\ProgramData\\Microsoft\\Windows Defender\\*\\MsMpEng.exe'
      )
    |
    |write_minidump_file|

output: >
  Detected an attempt by `%1.ps.name` process to access and read
  the memory of the **Local Security And Authority Subsystem Service**
  and subsequently write the `%2.file.name` dump file to the disk device
severity: critical

min-engine-version: 2.0.0
```

The sequence behavior can be controlled by the following statements:

- `maxspan` defines the time window in duration units, such as `2s`, `2m`, or `2h` for two minutes, two hours, and two days respectively. The time window dictates how long each expression in the sequence is expecting to wait for events that could result in expression evaluating to true. For example, by examining the above snippet, the sequence starts by detecting process handle acquisition on the `lsass` process. Since this is the first expression in the sequence, the time window constraint doesn't kick in yet. After the first expression evaluates to true, the next one, expecting to detect creation of the minidump file, will evaluate only if the `CreateFile` event arrives within the 2 minutes time frame. Otherwise, the deadline is reached and the entire sequence is discarded.
- `by` enables event stitching by any of the [filter fields](filters/fields). It guarantees that only events sharing certain properties will be eligible for matching. Continuing the example from previous rule, the sequence can match only if `OpenProcess` and `CreateFile` events are generated by the same process. Specifically, events are joined by the `ps.uuid` field which is meant to offer a more robust version of the `ps.pid` field that is resistant to being repeated. A variation of the `by` statement allows establishing a joining criteria separately on each expression in the sequence. Let's take a look at the following rule:

```yaml
sequence
maxspan 1h
  |write_file
      and
   file.extension iin executable_extensions
      and
   ps.name iin msoffice_binaries
  | by file.name
  |spawn_process
      and
   ps.name iin msoffice_binaries
  | by ps.child.exe
```

As we can observe, the `by` statement is anchored to each expression but using a different join field. This rule would only match if the file being written is equal to the spawned process executable image.
Of course, it is possible to omit both `maxspan` and `by` statements. However, such rules are rarely used to express behaviors that require relationships between events, instead, a mere temporally connection.

#### Aliases

In certain situations, expressing event stitching relations may require more complex heuristics. Imagine a detection rule checking the presence of a created filename against the list of values obtained in subsequent sequence expression. An avid reader may immediately realize this sort of joining is not attainable by means of the `by` statement. Luckily, a more flexible solution exists in form of the `as` statement. This statement allows creating aliases which can be referenced in sequence expressions by using **bound fields**. Bound field is essentially a regular filter field prefixed with an alias. Let's see another example.

```yaml
sequence
maxspan 5m
  |create_file
      and
   file.name imatches '?:\\Windows\\System32\\*.dll'
  | as e1
  |modify_registry
      and
   registry.key.name ~= 'HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Control\\Lsa\\Notification Packages'
      and
   get_reg_value(registry.key.name) iin (base($e1.file.name, false))
  |
```

The first expression in the sequence detects the creation of a DLL file in the system directory. Once this expression evaluates to true, the event that triggered it is accessible via the `e1` alias. The second expression will detect registry modifications on the specified value, and if eligible, it will use the `get_reg_value` function to query the value, which, in this case,contains the `MULTI_SZ` content. The retrieved list of strings is compared against the filename from the event matching the first expression. The `$e1.file.name` bound field is responsible for consulting the filename field value from the referenced expression's matching event.

```

`docs/index.html`:

```html
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Fibratus</title>
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
  <meta name="description" content="Fibratus detects, protects, and eradicates advanced adversary tradecraft by scrutinizing and asserting a wide spectrum of system events against a behavior-driven rule engine and YARA memory scanner">
  <meta name="viewport" content="width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
  <link rel="stylesheet" href="https://indestructibletype.com/fonts/Jost.css" type="text/css" charset="utf-8" />
  <link rel="stylesheet" href="themes/fibratus.css">
  <link rel="stylesheet" href="https://unpkg.com/docsify-toc@1.0.0/dist/toc.css">
  <link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css">
  <link media="all" rel="stylesheet" href="https://cdn.jsdelivr.net/gh/dmhendricks/bootstrap-grid-css@4.1.3/dist/css/bootstrap-grid.min.css" />
</head>
<body>
  <div id="app"></div>
  <script>
    window.$docsify = {
      onlyCover: true,
      auto2top: true,
      themeColor: "#6da9e2",
      coverpage: true,
      loadNavbar: 'nav.md',
      loadSidebar: true,
      subMaxLevel: 3,
      maxLevel: 4,
      homepage: 'home.md',
      executeScript: true,
      search: {
        maxAge: 86400000, // Expiration time, the default one day
        paths: 'auto',
        placeholder: 'Search',
        noData: 'No Results!',
        // Headline depth, 1 - 6
        depth: 6,
        hideOtherSidebarContent: false // whether or not to hide other sidebar content
      },
      pagination: {
        crossChapter: true,
        crossChapterText: true,
        headings: 'h1, h2, h3, h4, h5, h6'
      },
      toc: {
        scope: '.markdown-section',
        headings: 'h1, h2, h3, h4, h5, h6',
        title: 'CONTENTS',
      }
    }
  </script>
  <script src="//unpkg.com/docsify/lib/docsify.min.js"></script>
  <script src="//unpkg.com/docsify-sidebar-collapse/dist/docsify-sidebar-collapse.min.js"></script>
  <script src="//unpkg.com/docsify-pagination/dist/docsify-pagination.min.js"></script>
  <script src="//unpkg.com/docsify-toc@1.0.0/dist/toc.js"></script>
  <script src="//unpkg.com/ionicons@5.0.0/dist/ionicons.js"></script>
  <script src="//unpkg.com/docsify/lib/plugins/search.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/prismjs/components/prism-yaml.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/prismjs/components/prism-python.min.js"></script>
</body>
</html>

```

`docs/kevents/anatomy.md`:

```md
# Anatomy Of An Event

The **Event** or `kevent` as referred to in Fibratus internal lingo is the fundamental building block that encapsulates the state of the event. The [ETW](https://docs.microsoft.com/en-us/windows/win32/etw/event-tracing-portal) **Kernel Logger** provider produces the flow of events in their raw format. This means that the vast majority of the event's parameters lack a meaningful context needed for an intuitive human interpretation. To clarify the previous statement, here are some concrete examples:

- registry keys containing partial paths are typically not very useful. Think of `Settings/Control Panel` key that actually represents the fully qualified `HKEY_CURRENT_USER/Settings/Control Panel` path. Fibratus makes sure to run a hook in the early stage of the kernel event stream to figure out the remaining key name. Aside from this, root keys are represented in the native object manager format, e.g. `REGISTRY\MACHINE` is the key name for the `HKEY_CURRENT_MACHINE` root level key. Fibratus normalizes native root keys to well-known names.
- missing file names in `ReadFile` or `WriteFile` events. These events only contain the address of the file object that obviously doesn't give any hints about the file involved in the I/O operation. Fibratus strives for a best-effort file name resolution. Similarly to native registry key names, the Kernel Logger emits files names in DOS device name format, e.g. `Device\HardDisk4\Windows\System32\kernel32.dll`. Fibratus maps DOS device names to drive letters.
- handle type names are given as integer values. Fibratus takes care of mapping type identifiers to human-readable handle type names such as `File`, `Mutant` or `Key`.

However, this is not the only heavy-lifting task Fibratus does to produce high-quality events. Additionally, events are enriched with various parameters that are not originally present in the ETW payloads.

### Canonical fields

Each event contains a series of canonical fields that describe the nature of the event such as its name, the process identifier that generated the event and such. The following is the list of all canonical fields.

- **Sequence** is a monotonically increasing integer value that uniquely identifies an event. The sequence value is guaranteed to increment monotonically as long as the machine is not rebooted. After the restart, the sequence is restored to the zero value.
- **PID** represents the process identifier that triggered the event.
- **TID** is the thread identifier connected to the event.
- **CPU** designates the logical CPU core on which the event was originated.
- **Name** is the human-readable event name such as `CreateProcess` or `RegOpenKey`.
- **Timestamp** denotes the timestamp expressed in nanosecond precision as the instant the event occurred.
- **Category** designates the category to which the event pertains, e.g. `file` or `thread`. Each particular category is explained thoroughly in the next
 sections. Possible category types are: `registry`, `file`, `net`, `process`, `thread`, `image` and `handle`.
- **Description** is a short explanation about the purpose of the event. For example, `CreateFile` event creates or opens a file, directory, I/O device, pipe, console buffer or other block/pseudo device.
- **Host** represents the host name where the event was produced.

### Parameters

Also called as `kparams` in Fibratus parlance, contain each of the event's parameters. Internally, they are modeled as a collection of key/value pairs where the key is mapped to the structure consisting of parameter name, parameter type and the value. An example of the parameter tuple could be the `dip` parameter
that denotes a destination IP address with value `172.17.0.2` and therefore `IPv4` type. Additionally, parameter types can be scalar values, strings, slices, enumerations, and timestamps among others.

### Process state

Each event stores the process state that represents an extended information about the process including its allocated resources such as handles, dynamically-linked libraries, exported environment variables and other attributes. The process state internals are thoroughly explained in the [Process](/kevents/process) events section.

### Callstack

Callstack reconstructs the sequence of function calls that led to the current thread state. When stack enrichment is enabled (controlled by the `--kstream.stack-enrichment` configuration flag), return addresses obtained directly from kernel space, are symbolized and enriched with a vital context that can be leveraged to boost behavioral detections and reduce false positive alerts. A typical callstack summary is depicted in the snippet above:

```
0x7ffb5c1d0396 C:\WINDOWS\System32\KERNELBASE.dll!CreateProcessW+0x66
0x7ffb5d8e61f4 C:\WINDOWS\System32\KERNEL32.DLL!CreateProcessW+0x54
0x7ffb5c1d0396 C:\WINDOWS\System32\KERNELBASE.dll!CreateProcessW+0x61
0x7ffb3138592e C:\Program Files\JetBrains\GoLand 2021.2.3\jbr\bin\java.dll!Java_java_lang_ProcessImpl_waitForTimeoutInterruptibly+0x3a2
0x7ffb313853b2 C:\Program Files\JetBrains\GoLand 2021.2.3\jbr\bin\java.dll!Java_java_lang_ProcessImpl_create+0x10a
0x2638e59e0a5 unbacked!?
```

Each line is comprised of:

- function call return address (e.g. `0x7ffb5c1d0396`)
- full path of the image/module containing the executed function. If the call is invoked from a floating memory region, then the module name is marked as `unbacked`
- name of the symbol mapping to the return address (e.g. `CreateProcessW`)
- offset within the function body

Stack enrichment is performed for the following event set:

- `CreateProcess`
- `CreateThread`
- `TerminateThread`
- `SetThreadContext`
- `LoadImage`
- `RegCreateKey`
- `RegDeleteKey`
- `RegSetValue`
- `RegDeleteValue`
- `CreateFile`
- `DeleteFile`
- `RenameFile`
- `VirtualAlloc`
- `OpenProcess`
- `OpenThread`
- `CreateSymbolicLinkObject`
- `SubmitThreadpoolWork`
- `SubmitThreadpoolCallback`
- `SetThreadpoolTimer`


To enable stack enrichment for kernel space return addresses, the `symbolize-kernel-addresses` config option needs to be set to `true`. Callstack data is used by [filter fields](/filters/fields?id=callstack) to permit crafting advanced detection rules.

### Metadata

Metadata are an arbitrary sequence of tags in form of key/value pairs that you can squash into the event on behalf of [transformers](/transformers/introduction). A tag can be virtually any string data that you find meaningful to either identify the event or apply filtering/grouping once event is persisted in the data store.

```

`docs/kevents/driver.md`:

```md
# Driver events

#### LoadDriver

Driver loading events are triggered when the driver object is loaded into the kernel. Regular `LoadImage` events are triggered when the kernel driver is loaded or when the driver is unloaded, the `UnloadImage` event is received.

An alternative route for detecting driver loading events is based on observing the [handle manager](kevents/handle.md) events. For example, a filter expression for pinpointing such events could be arranged as follows.

```
kevt.name = 'CreateHandle'
    and
handle.type = 'Driver'
```

Rule writers are encouraged to use the `load_driver` macro from the [macro library](https://github.com/rabbitstack/fibratus/blob/master/rules/macros/macros.yml). This macro seamlessly handles the detection of driver loading depending on whether direct events are available or handle manager tracking is required.

```

`docs/kevents/file.md`:

```md
# File events

File events encompass a variety of file system related activities such as creating or opening directories/files/devices, writing or reading data, altering file metadata and so on.

#### CreateFile

The `CreateFile` event is triggered when the kernel serves create/open requests for files or I/O devices. The most commonly used I/O devices are as follows: file, file stream, directory, physical disk, volume, console buffer, tape drive, communications resource, mailslot, and pipe. `CreateFile` events have the following parameters:

- `file_object` is the file object pointer as seen from the kernel perspective. You can use this parameter to correlate file events.
- `file_name` represents the file/directory or device name (e.g. `C:\ProgramData\AVG\Antivirus\psi.db-journal`)
- `irp` is the I/O request packet value that identifies the file system activity.
- `tid` is the thread identifier that initiated the I/O operation.
- `create_disposition` identifies the file system operation performed on the file or device:
  - `SUPERSEDE` replaces the file if it already exists, otherwise creates a new file
  - `OPEN` opens the file if it exists
  - `CREATE` creates a new file or fails if the file already exists
  - `OPENIF` opens the file if it already exists, otherwise creates a new file
  - `OVERWRITE` opens and overwrites the file if it already exists
  - `OVERWRITEIF` opens and overwrites the file if it already exists, otherwise creates a new file
- `create_options` the options to be applied when creating or opening the file, as a compatible combination of the following values: `DIRECTORY_FILE`,`WRITE_THROUGH`, `SEQUENTIAL_ONLY`, `NO_INTERMEDIATE_BUFFERING`, `SYNCHRONOUS_IO_ALERT`, `SYNCHRONOUS_IO_NONALERT`, `NON_DIRECTORY_FILE`, `CREATE_TREE_CONNECTION`, `COMPLETE_IF_OPLOCKED`, `NO_EA_KNOWLEDGE`, `OPEN_REMOTE_INSTANCE`, `RANDOM_ACCESS`, `DELETE_ON_CLOSE`,`OPEN_BY_FILE_ID`, `FOR_BACKUP_INTENT`, `NO_COMPRESSION`, `OPEN_REQUIRING_OPLOCK`,`DISALLOW_EXCLUSIVE`, `RESERVE_OPFILTER`, `OPEN_REPARSE_POINT`, `OPEN_NO_RECALL` and `OPEN_FOR_FREE_SPACE_QUERY`.
- `share_mask` specifies the sharing mode of the file or device, which can be the combination of `READ`, `WRITE`, and `DELETE` values. This flag determines the permission granularity which enables a process to share a file or device while another process has the file or device open.
- `type` defines the file type. Possible values are `File`, `Directory`, `Pipe`, `Console`, `Mailslot`, `Other`, `Unknown`.
- `attributes` denotes the file attributes. Possible values are `READONLY`, `HIDDEN`, `SYSTEM`, `DIRECTORY`, `COMPRESSED`, `ENCRYPTED`, `JUNCTION`, `SPARSE`,`TEMPORARY`, `DEVICE`, `NORMAL`, `OFFLINE`, `UNINDEXED`, `STREAM`, `VIRTUAL`, `NOSCRUB`, `RECALLOPEN`, `RECALLACCESS`, `PINNED`, `UNPINNED`, `UNKNOWN`.
- `status` represents the system status message (e.g. `Success`)
- `is_dll` determines if the created file is a DLL object. Only present when `create_disposition != OPEN`.
- `is_driver` determines if the created file is a driver. Only present when `create_disposition != OPEN`.
- `is_exec` determines if the created file is an executable image. Only present when `create_disposition != OPEN`.

#### WriteFile and ReadFile

These events occur when a process writes data to a file or reads data from the file or I/O device. They contain the following parameters:

- `file_object` is the file object pointer as seen from the kernel perspective. You can use this parameter to correlate file events.
- `file_name` represents the file/directory or device name the data is written to or read from.
- `irp` is the I/O request packet value that identifies the file system activity.
- `io_size` specifies the number of bytes read or written.
- `offset` determines the offset in the file where the data is read or written.
- `type` defines the file type. Possible values are  `File`, `Directory`, `Pipe`, `Console`, `Mailslot`, `Other`, `Unknown`.


#### DeleteFile

Removes the file from the file system. This event contains the following parameters:

- `file_object` is the file object pointer as seen from the kernel perspective. You can use this parameter to correlate file events.
- `file_name` represents the file/directory that was removed
- `irp` is the I/O request packet value that identifies the file system activity.
- `type` defines the file type. Possible values are  `File`, `Directory`, `Pipe`, `Console`, `Mailslot`, `Other`, `Unknown`.

#### RenameFile

Renames the file or directory in the file system.

- `file_object` is the file object pointer as seen from the kernel perspective.
- `file_name` represents the file/directory that was renamed.
- `irp` is the I/O request packet value that identifies the file system activity.
- `type` defines the file type. Possible values are  `File`, `Directory`, `Pipe`, `Console`, `Mailslot`, `Other`, `Unknown`.

#### CloseFile

Closes the handle to opened file. This event is excluded by default.

- `file_object` is the file object pointer as seen from the kernel perspective.
- `file_name` represents the file/directory that was closed.
- `irp` is the I/O request packet value that identifies the file system activity.
- `type` defines the file type. Possible values are  `File`, `Directory`, `Pipe`, `Console`, `Mailslot`, `Other`, `Unknown`.


#### SetFileInformation

Sets the file information for the file according to the file information class.

- `class` identifies the file information class. For example, the `Basic` information class means the process altered file timestamps or basic attributes. Refer to [this](https://docs.microsoft.com/en-us/windows-hardware/drivers/ddi/wdm/ne-wdm-_file_information_class) link for a full list of the file information class enumerations.
- `file_object` is the file object pointer as seen from the kernel perspective.
- `file_name` represents the file whose information class was set.
- `irp` is the I/O request packet value that identifies the file system activity.
- `type` defines the file type. Possible values are `File`, `Pipe`, `Mailslot`, `Other`, `Unknown`.


#### EnumDirectory

The `EnumDirectory` event is triggered in response to directory enumeration requests.

- `dir` specifies the directory that was requested for enumeration.
- `file_name` is the pattern for directory enumeration.
- `class` identifies the requested directory enumeration class.
- `file_object` is the file object pointer as seen from the kernel perspective.
- `irp` is the I/O request packet value that identifies the file system activity.

#### MapViewFile

Maps a view of a file mapping into the process address space. These events contain the following parameters:

- `file_key` is the address of the file object for which the mapping is performed.
- `offset` represents the file offset where the view is to begin.
- `pid` is the process identifier where the file mapping is performed.
- `protection` specifies the page protection of the file mapping object. Can be the compatible combination of the following values: `READONLY`, `EXECUTE`, `EXECUTE_READ`, `READWRITE`, `WRITECOPY`, `NOCACHE`, `EXECUTE_WRITECOPY` and `EXECUTE_READWRITE`. 
- `section_type` describes the type of the mapped section. It can be `DATA`, `IMAGE`, `IMAGE_NO_EXECUTE`, `PAGEFILE` or `PHYSICAL`. 
- `view_base` is the base memory address in the process address space where mapping begins.
- `view_size` represents the number of bytes of a file mapping to map to a view.

#### UnmapViewFile

Unmaps a mapped view of a file from the process's virtual address space.

- `file_key` is the address of the file object for which the unmapping is performed.
- `offset` represents the file offset where the view to unmap begins.
- `pid` is the process identifier where the file unmapping is performed.
- `protection` specifies the page protection of the file mapping object that is being unmapped. Can be the compatible combination of the following values: `READONLY`, `EXECUTE`, `EXECUTE_READ`, `READWRITE`, `WRITECOPY`, `NOCACHE`, `EXECUTE_WRITECOPY` and `EXECUTE_READWRITE`. 
- `section_type` describes the type of the unmapped section. It can be `DATA`, `IMAGE`, `IMAGE_NO_EXECUTE`, `PAGEFILE` or `PHYSICAL`. 
- `view_base` is the base memory address in the process address space where unmapping begins.
- `view_size` represents the number of bytes of a file mapping to unmap.

```

`docs/kevents/handle.md`:

```md
# Handle events

The object manager produces handle events to provision or dispose Windows resources allocated to processes. Resources can be threads, registry keys, files, synchronization primitives and so on.

!> Handle events can be quite voluminous and they are disabled by default. To enable the collection of handle events either run Fibratus with the `--kstream.enable-handle=true` flag or activate them permanently by editing the config file.

#### CreateHandle

Provisions a new handle in the address space of the calling process. The following parameters are associated with the `CreateHandle` event:

- `handle_id` represents the unique identifier of the handle.
- `handle_object` represents the address of the kernel object to which the handle is associated
- `handle_name` denotes the handle name. (e.g. `\RPC Control\OLEA61B27E13E028C4EA6C286932E80`)
- `type_id` designates the handle type. (e.g. `ALPC Port`, `File`, `Key`)

#### CloseHandle

The `CloseHandle` event is triggered when the handle is released by the process. It contains the same set of parameters found in the `CreateHandle` event.

#### DuplicateHandle

This event is fired when the process duplicates an object handle. The following parameters are present in `DuplicateHandle` events:

- `handle_id` represents the duplicated handle identifier.
- `handle_object` represents the address of the duplicated kernel object
- `handle_source_id` represents the identifier of the handle to be duplicated.
- `type_id` designates the duplicated handle type. (e.g. `DxgkCompositionObject`)
- `pid`, `exe`, `name` represent the source process identifier, process executable path, and the process image name respectively.

### Handle state {docsify-ignore}

During bootstrap, Fibratus builds a snapshot of currently allocated handles. Similarly, when a new process is created Fibratus fetches its handles and attaches them to the process state. However, to optimize memory utilization, the initial handle snapshot and process handle table initialization are disabled by default. You can enable both features by modifying the `--handle.init-snapshot=true` and `--handle.enumerate-handles` config flags respectively or changing the corresponding key in the configuration file.

The handle state contains:

- handle name
- handle type
- the address of the kernel object
- handle identifier
- additional metadata such as `ALPC` port information or mutant count

```

`docs/kevents/image.md`:

```md
# Image events

Image events occur when a process loads/unloads a dynamic linked library, executable or the kernel driver. The loading can happen in the local or remote process. These events are represented by `LoadImage` and `UnloadImage` types respectively. The following list describes all available parameters present in DLL events.

- `file_name` denotes the full path name of the image file. (e.g. `C:\Windows\system32\kernel32.dll`)
- `image_size` represents the image size in bytes.
- `checksum` represents the image checksum digest.
- `base_address` is the base address of the process in which the image is loaded/unloaded.
- `default_address` represents the image's base address.
- `pid` that specifies the process identifier where the image was loaded/unloaded.


Additionally, `LoadImage` events contain the following parameters.

- `is_dll` determines if the image is a DLL object. 
- `is_driver` determines if the image is a kernel driver. 
- `is_exec` determines if the image being loaded is an executable.

```

`docs/kevents/mem.md`:

```md
# Memory events

Memory events include reserving, committing, or freeing the state of a region of pages in the virtual process address space.

#### VirtualAlloc

Allocates, commits, or changes the state of a region of pages in the virtual address space. If the `pid` parameter is different than the calling process id, memory allocation is performed in the address space of another process. `VirtualAlloc` events carry the following parameters:

- `alloc_type` designates the type of memory allocation. It can be the combination of `COMMIT`, `RESERVE`, `RESET`, `RESET_UNDO`, `PHYSICAL`, `LARGE_PAGES`, `TOP_DOWN`, and `WRITE_WATCH`.
- `base_address` is the starting address of the allocated region.
- `page_type` represents the type of pages in the allocated region. It can be one of `IMAGE`, `MAPPED`, or `PRIVATE`.
- `protection` designates the memory protection for the region of allocated pages. It can be the combination of `EXECUTE`, `EXECUTE_READ`, `EXECUTE_READWRITE`, `EXECUTE_WRITECOPY`, `NOACCESS`, `READONLY`, `READWRITE`, `WRITECOPY`, `TARGETS_INVALID`, `TARGETS_NO_UPDATE`, `GUARD`, `NOCACHE`, and `WRITECOMBINE`. 
- `protection_mask` is an abbreviated form of the pages protection flag. e.g. `RWX`
- `region_size` is the size of the allocated region in bytes.
- `pid`, `exe`, `name` represent process identifier, process executable path, and the image name of the process into which the region is allocated.

#### VirtualFree

Releases, decommits, or releases and decommits a region of pages within the virtual process address space. If the `pid` parameter is different than the calling process id, memory release is performed in the address space of another process. `VirtualFree` events contain the following parameters:

- `alloc_type` designates the type of free operation that can be `DECOMMIT` or `RELEASE`.
- `base_address` is the base address of the region of pages to be freed.
- `region_size` represents the size of the region of memory to be freed, in bytes.
- `pid`, `exe`, `name` represent process identifier, process executable path, and the image name of the process for which the pages are freed.

```

`docs/kevents/network.md`:

```md
# Network events

Interprocess communication via TCP/UDP sockets produces all sorts of network events including, sending and receiving data, retransmitting TCP segments or connecting to sockets.

#### Connect

Establishes a connection to the stream-oriented socket. `Connect` events have the following parameters:

- `dip` represents the destination IPv4/IPv6 address of the communication endpoint.
- `sip` represents the source IPv4/IPv6 address of the local process.
- `dport` identifies the destination port.
- `sport` identifies the source port.
- `l4_proto` denotes the type of the Layer 4 protocol. Possible values are `tcp`, `udp`.
- `dport_name` represents the destination port name per [IANA](https://www.iana.org/assignments/service-names-port-numbers/service-names-port-numbers.txt) port to service mappings.
- `sport_name` represents the source port name per [IANA](https://www.iana.org/assignments/service-names-port-numbers/service-names-port-numbers.txt) port to service mappings.

The remaining network events share the same parameters as the `Connect` event.

#### Accept

Accepts the connection request from the socket queue.

#### Send

Sends data over the wire. The kernel generates `Send` events when a process transports data to local or remote endpoint.

#### Recv

Receives data from the socket. The kernel produces `Recv` events when a process is ready to consume data sent by local or remote socket.

#### Disconnect

Terminates data reception on the socket.


#### Reconnect

Reconnects to the socket.

#### Retransmit

Retransmits unacknowledged TCP segments. The kernel networking stack generates retransmissions when packets are dropped due to network congestion, packets arriving out of order and other reasons. 

### DNS queries/responses

DNS telemetry uncovers all DNS query/reply interactions. More specifically, `QueryDns` and `ReplyDns` events are fired when the process sends a query to the name server and when it receives the response from the DNS server, respectively. DNS events are collected by default, but it is possible to disable them by setting the `kstream.enable-dns` config flag to `false`.

#### QueryDns

Sends a query to the name server. This event has the following parameters:

- `name` represents the DNS query (e.g. `www.iana.org`)
- `options` represents the DNS options. It can be the combination of the following values: `STANDARD`, `ACCEPT_TRUNCATED_RESPONSE`, `USE_TCP_ONLY`, `NO_RECURSION`, `BYPASS_CACHE`, `NO_WIRE_QUERY`, `NO_LOCAL_NAME`, `NO_NETBT`, 
`WIRE_ONLY`, `RETURN_MESSAGE`, `MULTICAST_ONLY`, `NO_MULTICAST`, `TREAT_AS_FQDN`, `ADDRCONFIG`, `DUAL_ADDR`, `MULTICAST_WAIT`, 
`MULTICAST_VERIFY`, `DONT_RESET_TTL_VALUES`, `DISABLE_IDN_ENCODING`, `APPEND_MULTILABEL`.
- `rr` specifies the type of the resource record. It can be one of `A`,`NS`, `MD`, `MF`, `CNAME`, `SOA`, `MB`, `MG`, `MR`, `NULL`, `WKS`, `PTR`,`HINFO`, `MINFO`, `MX`, `TEXT`, `RP`, `AFSDB`, `X25`, `ISDN`, `NSAPPTR`, `SIG`, `KEY`, `PX`, `GPOS`,
`AAAA`, `LOC`, `NXT`, `EID`, `NIMLOC`, `SRV`, `ATMA`, `NAPTR`, `KX`, `CERT`, `A6`, `DNAME`, `SINK`, `OPT`, `DS`, `RRSIG`,
`NSEC`, `DNSKEY` `DHCID`, `UINFO`, `UID`, `GID`, `UNSPEC`, `ADDRS`, `TKEY`, `TSIG`, `IXFR`, `AXFR`, `MAILB`, `MAILA`, `ANY`,
`WINS`, `WINSR`.

#### ReplyDns

Receives the response from the DNS server. DNS reply events contain the following parameters:

- `name` represents the DNS query (e.g. `www.iana.org`)
- `answers` contains the response answers (e.g. `151.101.194.132`, `151.101.130.132`)
- `options` represents the DNS options. It can be the combination of the following values: `STANDARD`, `ACCEPT_TRUNCATED_RESPONSE`, `USE_TCP_ONLY`, `NO_RECURSION`, `BYPASS_CACHE`, `NO_WIRE_QUERY`, `NO_LOCAL_NAME`, `NO_NETBT`, 
`WIRE_ONLY`, `RETURN_MESSAGE`, `MULTICAST_ONLY`, `NO_MULTICAST`, `TREAT_AS_FQDN`, `ADDRCONFIG`, `DUAL_ADDR`, `MULTICAST_WAIT`, 
`MULTICAST_VERIFY`, `DONT_RESET_TTL_VALUES`, `DISABLE_IDN_ENCODING`, `APPEND_MULTILABEL`.
- `rr` specifies the type of the resource record. It can be one of `A`,`NS`, `MD`, `MF`, `CNAME`, `SOA`, `MB`, `MG`, `MR`, `NULL`, `WKS`, `PTR`,`HINFO`, `MINFO`, `MX`, `TEXT`, `RP`, `AFSDB`, `X25`, `ISDN`, `NSAPPTR`, `SIG`, `KEY`, `PX`, `GPOS`,
`AAAA`, `LOC`, `NXT`, `EID`, `NIMLOC`, `SRV`, `ATMA`, `NAPTR`, `KX`, `CERT`, `A6`, `DNAME`, `SINK`, `OPT`, `DS`, `RRSIG`,
`NSEC`, `DNSKEY` `DHCID`, `UINFO`, `UID`, `GID`, `UNSPEC`, `ADDRS`, `TKEY`, `TSIG`, `IXFR`, `AXFR`, `MAILB`, `MAILA`, `ANY`,
`WINS`, `WINSR`.
- `rcode` designates the DNS response code. It can be one of `NOERROR`, `FORMERR`, `SERVFAIL`, `NXDOMAIN`, `NOTIMP`, `REFUSED`,
`YXDOMAIN`, `YXRRSET`, `NXRRSET`, `NOTAUTH`, `NOTZONE`, `BADSIG`, `BADKEY`, `BADTIME`, `BADNAME`, `INVALID`, `NXDOMAIN`.

### DNS reverse lookups

Fibratus can perform reverse DNS lookups on IP addresses and return a list of domain names that correspond to a particular IP address.

For example, `47.224.186.35.bc.googleusercontent.com` is the reverse lookup representation of the Google IP address.

You can use domain names in [filters](filters/introduction) in conjunction with the `matches`, `contains` or `in` operators. For example, the following filter would match all events that have at least one domain ending with `.domain.`

```
net.sip.names matches ('*.domain.')
```

```

`docs/kevents/object.md`:

```md
# Object manager events

#### CreateSymbolicLinkObject

`CreateSymbolicLinkObject` event is fired when the symbolic link within the object manager directory. This event has the following parameters:

- `source` identifies the parameter that represents the source symbolic link object or other kernel object.
- `target` identifies the parameter that represents the target symbolic link object or other kernel object.
- `desired_access` denotes the access rights for the target symbolic link object. Can be the combination of `DELETE`, `READ_CONTROL`, `WRITE_DAC`, `WRITE_OWNER`, `SYNCHRONIZE`, `STANDARD_RIGHTS_REQUIRED`, `STANDARD_RIGHTS_ALL`, `ACCESS_SYSTEM_SECURITY`, `MAXIMUM_ALLOWED`, `GENERIC_READ`, `GENERIC_WRITE`, `GENERIC_EXECUTE`, `GENERIC_ALL`.
- `status` represents the outcome of the operation.
```

`docs/kevents/process.md`:

```md
# Process events

#### CreateProcess and TerminateProcess

Process events are fired up as a stimulus to the process' life-cycle changes. When the kernel puts into motion a process or terminates it, the `CreateProcess` and `TerminateProcess` events are emitted respectively. The following list summarizes all the distinct event parameters that are associated with process events.

- `pid` is the process' identifier. This value is valid from the time a process is created until it is terminated.
- `tid` is the thread identifier inside process address space that generated the event.
- `ppid` represents the parent identifier of the child process. Process identifier numbers are reused, so they only identify a process for the lifetime of that process. It is possible that the process identified by `ppid` is terminated, so `ppid` may not refer to a running process. It is also possible that `ppid` incorrectly refers to a process that reuses a process identifier.
- `real_ppid` is the process identifier useful for detecting process spoofing.
- `name` is the process' image name including file extension (e.g. `cmd.exe`).
- `cmdline` is the full process' command line (e.g. `C:\Windows\system32\cmd.exe /cdir /-C /W`).
- `exe` is the full name of the process' executable (e.g. `C:\Windows\system32\cmd.exe`)
- `sid` is the security identifier under which this process is run. (e.g. `S-1-5-18`)
- `kproc` represents the address of the process object in the kernel.
- `directory_table_base` represents the address of the directory table that holds process' memory page mappings.
- `session_id` is the unique identifier for the current session under which process was started or terminated.
- `status` is the exit status of the started/stopped process.
- `start_time` designates the instant when the process was started.
- `domain` represents the domain name under which the process is started.
- `username` represents the username that started the process.
- `flags` represents process creation flags. Can be `WOW64`, `PROTECTED`, or `PACKAGED` to designate 32-bit process is created in 64-bit Windows system,  process is to be run as a protected process, or a process packaged with the **MSIX** technology respectively.

#### OpenProcess

`OpenProcess` event is triggered when a process tries to acquire an existing local process object. This event contains the following parameters:

- `desired_access` is the hexadecimal value that represents the desired access to the process object.
- `desired_access_names` is the list of human-readable desired access strings (e.g. `TERMINATE,QUERY_INFORMATION`). For a full list and detailed explanation of available access rights, head to the official [docs](https://docs.microsoft.com/en-us/windows/win32/procthread/process-security-and-access-rights).
- `name` is the name of the local process that was opened.
- `exe` is the full path of the local process object that was open.
- `pid` is the identifier of the local process that was opened.
- `status` contains the result of the process object open operation. (e.g. `Success`)

### Process state  {docsify-ignore}

Fibratus keeps a snapshot of all running processes including their state such as basic process attributes, allocated file handles, dynamically-linked libraries, PE (Portable Executable) metadata and other resources. The snapshot is updated dynamically as processes get spawn or die. Each time a kernel event is triggered, its process' state is fetched from the snapshot and attached to the event. This state machine semantically enriches each individual event with the aim on providing a powerful context for [filtering](/filters/introduction.md) and [scripting](/filaments/introduction.md).

Process state comprises the following attributes and resources:

- process name
- process identifier as well as its parent process identifier
- process command line
- current working directory
- process SID
- session identifier
- environment variables
- threads
- modules
- handles
- memory mappings
- PE metadata

```

`docs/kevents/registry.md`:

```md
# Registry events

Registry events are triggered when processes access or modify the registry structure.

#### RegCreateKey

Creates a new registry key or opens the key if it already exists. This event has the following parameters:

- `key_handle` represents the handle to the registry key. In reality, this value represents the address of the KCB (Key Control Block) structure in kernel space.
- `key_name` is the name of the registry key including the root key. (e.g. `HKEY_LOCAL_MACHINE\System\CurrentControlSet\Control`)
- `status` contains the result of the registry operation (e.g. `key not found`)

#### RegDeleteKey

Deletes a subkey and all its values. This event has the same group of parameters as the `RegCreateKey` event.

#### RegOpenKey

Opens a registry key. This event has the same group of parameters as the `RegCreateKey` event.

#### RegCloseKey

Closes the registry key. This event has the same group of parameters as the `RegCreateKey` event.

#### RegQueryKey

Enumerates the subkeys of the specified key. The first subkey is referenced by index number 0, the second key by 1, and so on.

- `key_handle` represents the handle to the registry key.
- `key_name` is the name of the registry key whose subkeys are enumerated.
- `status` contains the result of the registry operation (e.g. `key not found`)

#### RegQueryValue

Fetches the data associated with the value of a registry key. This event has the same group of parameters as the `RegCreateKey` event, except that the base name of the registry key path is the value name.

#### RegSetValue

Sets the data associated with the value of a registry key. This event contains the following parameters:

- `key_handle` represents the handle to the registry key.
- `key_name` represents the fully qualified name of the registry value whose data is modified
- `status` contains the result of the registry operation (e.g. `success`)
- `value` contains the payload of the value being set
- `type` represents the registry value type. Possible value are: `REG_DWORD`, `REG_QWORD`, `REG_SZ`, `REG_EXPAND_SZ`, `REG_MULTI_SZ`, `REG_BINARY`, `UNKNOWN`.

#### RegDeleteValue

Deletes the registry value. This event has the same parameters as the `RegCreateKey` event.

```

`docs/kevents/thread.md`:

```md
# Thread events

#### CreateThread and TerminateThread

Thread events notify the creation (`CreateThread`) or termination (`TerminateThread`) of threads within the process' address space. In situations where a process spawns a remote thread that runs in other process' address space, the `CreateThread` event is also triggered.
Thread events are comprised of the following parameters:

- `pid` identifies the process where the thread was created. If this value is not equal to the `pid` of the process generating the event, then the thread is created in remote process.
- `tid` represents the identifier of the freshly spawn thread.
- `base_prio` is the scheduler priority of the thread.
- `page_prio` is a memory page priority hint for memory pages accessed by the thread.
- `io_prio` represents an I/O priority hint for scheduling I/O operations generated by the thread.
- `ustack_base` is the base address of the thread's user space stack.
- `ustack_limit` is the limit of the thread's user space stack.
- `kstack_base` is the base address of the thread's kernel space stack.
- `kstack_limit` is the limit of the thread's kernel space stack.
- `start_address` is the start address of the function to be executed by the thread.
- `start_address_symbol` the symbol the represents the thread start address (e.g. `LoadLibraryEx`). Only present in `CreateThread` events.
- `start_address_module` the module that maps to the thread start address (e.g. `ntdll.dll`). Only present in `CreateThread` events.
- `teb` is the address of the Thread Environment Block (TEB).


#### OpenThread

`OpenProcess` event is triggered when a process opens an existing local thread object. This event contains the following parameters:

- `desired_access` is the hexadecimal value that represents the desired access to the thread object.
- `desired_access_names` is the list of human-readable desired access strings (e.g. `QUERY_LIMITED_INFORMATION`). For a full list and detailed explanation of available access rights, head to the official [docs](https://docs.microsoft.com/en-us/windows/win32/procthread/thread-security-and-access-rights).
- `name` is the name of the local process whose thread object was open.
- `exe` is the full path of the local process image whose thread object was open.
- `pid` is the identifier of the local process whose thread object was opened.
- `tid` is the identifier of the local thread that was opened.
- `status` contains the result of the thread object open operation. (e.g. `Success`)

#### SetThreadContext

`SetThreadContext` sets the thread context. Thread context represents the set of CPU registers.

- `status` contains the result of operation. (e.g. `Success`)

## Thread pool events {docsify-ignore}

A thread pool is a collection of worker threads that efficiently execute asynchronous callbacks on behalf of the application. The thread pool is primarily used to reduce the number of application threads and provide management of the worker threads.


#### SubmitThreadpoolWork

Enqueues the work item to the thread pool. This event has the following parameters:

- `pool_id` represents the thread pool identifier.
- `task_id` represents the thread pool task identifier.
- `callback` represents the address of the callback function.
- `context` represents the address of the callback context.
- `subprocess_tag` represents the thread pool identifier.
- `pool_id` represents the service identifier associated with the thread pool.
- `callback_symbol` represents the callback symbol (e.g. `RtlCaputreContext`)
- `callback_module` represents the module containing the callback symbol (e.g. `C:\Windows\System32\ntdll.dll`)
- `context_rip` represents the value of instruction pointer contained in the callback context.
- `context_rip_symbol` represents the symbol name associated with the instruction pointer in callback context.
- `context_rip_module` represents the module name associated with the instruction pointer in callback context.


#### SubmitThreadpoolCallback

Submits the thread pool callback for execution within the work item. This event has the same parameter set as the `SubmitThreadpoolWork` events.


#### SetThreadpoolTimer

Sets the thread pool timer object. This event consists of the following parameters:

- `duetime` represents the timer due time.
- `subqueue` represents the memory address of the timer subqueue.
- `timer` represents the memory address of the timer object.
- `period` represents the period of the timer.
- `window` represents the timer tolerate period.
- `absolute` indicates if the timer is absolute or relative.


```

`docs/nav.md`:

```md
<div onclick="window.location='https://www.fibratus.io';" class="logo"><strong>f</strong>ibratus</div>

```

`docs/outputs/console.md`:

```md
# Console

Console is the default output. It renders the inbound event flow onto the console. The console output tends to reduce the number of I/O syscalls by buffering the incoming event lines.

### Configuration {docsify-ignore}

The console output configuration is located in the `outputs.console` section.

#### enabled

Indicates whether the console output is active.

**default**: `true`

#### format

Specifies the console output format. The `pretty` format dictates that formatting is accomplished by replacing the specifiers in the template. The `json` format outputs the event as a raw JSON string.

**default**: `pretty`

#### kv-delimiter

Specifies the separator that's rendered between the event parameter's key and its value.

**default**: `➜`

#### template

Defines the template that's used in the event formatter. For more details, see the next section.

**default**: `{{ .Seq }} {{ .Timestamp }} - {{ .CPU }} {{ .Process }} ({{ .Pid }}) - {{ .Type }} ({{ .Kparams }})`

### Templates {docsify-ignore}

The template consists of a collection of named placeholders that event formatter replaces with desired values. The syntax of the template resembles the Go [template](https://golang.org/pkg/text/template/) engine constructs, excepts the event formatter lacks advanced templating features such as loops , functions or `if` statements.

The following field modifiers are supported:

- `.Seq`
- `.Timestamp`
- `.Pid`
- `.Ppid`
- `.Pexe`
- `.Pcomm`
- `.Pname`
- `.Cwd`
- `.Exe`
- `.Comm`
- `.Tid`
- `.Sid`
- `.Process`
- `.Category`
- `.Description`
- `.CPU`
- `.Type`
- `.Kparams`
- `.Meta`
- `.Host`
- `.PE`
- `.Kparams.`
- `.Callstack`

**Examples**

- `{{ .Type }} on file ({{ .Kparams.File_name }})`

  renders

  `CreateFile on file C:\ProgramData\AVG\Antivirus\psi.db-journal`

- `{{ .Seq }} {{ .Process }} ({{ .Cwd }}) {{ .Ppid }} ({{ .Sid }})`

  renders

  `1999 cmd.exe (C:/Windows/System32) 2324 (nedo/archrabbit)`

- `{{ .Seq }} {{.CPU}} -  ({{.Type}}) Pid: {{ .Kparams.Pid }} {{ .Meta }}`

  renders

  `1999 4 -  (CreateProcess) Pid: 1232 env: prod, az: east`

```

`docs/outputs/elasticsearch.md`:

```md
# Elasticsearch

The Elasticsearch output ships kernel events to the `_bulk` [API endpoint](https://www.elastic.co/guide/en/elasticsearch/reference/current/docs-bulk.html). Events are batched and flushed when the interval specified by `flush-period` elapses.

### Configuration {docsify-ignore}

The Elasticsearch output configuration is located in the `outputs.elasticsearch` section.

#### enabled

Indicates whether the Elasticsearch output is enabled.

**default**: `false`

#### servers

Defines the URL endpoints of the Elasticsearch nodes.

**default**: `http://localhost:9200`

#### timeout

Represents the initial HTTP connection timeout when connecting to the Elasticsearch cluster.

**default**: `5s`

#### flush-period

Specifies when to flush the bulk at the end of the given interval.

**default**: `1s`

#### bulk-workers

Determines the number of workers that commit docs to Elasticsearch. Higher values maximize the throughout at the cost of increased CPU utilization.

**default**: `1`

#### healthcheck

Enables or disables nodes health checking.

**default**: `true`

#### healthcheck-interval

Specifies the interval for checking if the Elasticsearch nodes are available.

**default**: `10s`

#### healthcheck-timeout

Specifies the timeout for periodic node health checks.

**default**: `5s`

#### username

Identifies the user name for the basic HTTP authentication.

#### password

Identifies the password for the basic HTTP authentication.

#### sniff

Enables the discovery of all Elasticsearch nodes in the cluster. This avoids populating the list of available Elasticsearch nodes.

**default**: `false`

#### trace-log

Determines if the Elasticsearch client trace log is enabled. Useful for troubleshooting.

**default**: `false`

#### gzip-compression

Determines if the `gzip` compression is enabled for Elasticsearch documents.

**default**: `false`

#### template-name

Specifies the name of the index template.

**default**: `fibratus`

#### template-config

Contains the full JSON body of the index template. For more information refer to [index templates](https://www.elastic.co/guide/en/elasticsearch/reference/current/index-templates.html).

**default**:

```
{
	"index_patterns": [ "{{ fibratus* }}" ],
	"settings": {
		"index": {
			"refresh_interval": "5s",
			"number_of_shards": 1,
			"number_of_replicas": 1
		}
	},
	"mappings": {
		"properties": {
			"seq": { "type": "long" },
			"pid": { "type": "long" },
			"tid": { "type": "long" },
			"cpu": { "type": "short" },

			"name": { "type": "keyword" },
			"category": { "type": "keyword" },
			"description": { "type": "text" },
			"host": { "type": "keyword" },

			"timestamp": { "type": "date" },

			"kparams": {
				"type": "nested",
			    "properties": {
					"dip": { "type": "ip" },
					"sip": { "type": "ip" }
				}
			},

			"ps": {
				"type": "nested",
			    "properties": {
					"pid": { "type": "long" },
					"ppid": { "type": "long" },
					"name": { "type": "keyword" },
					"comm": { "type": "text" },
					"exe": { "type": "text" },
					"cwd": { "type": "text" },
					"sid": { "type": "keyword" },
					"sessionid": { "type": "short" }
				}
			}
		}
	}
}
```

#### index-name

Represents the target index for kernel events. It allows time specifiers to create indices per time frame. For example, `fibratus-%Y-%m` generates the index name with current year and month. Supported time specifiers are:

- `%Y` current year in `YYYY` format (`2020`)
- `%y` current year in `YY` format (`20`)
- `%m` current month (`01`)
- `%d` current day (`02`)
- `%H` current hour (`15`)

**default**: `fibratus`

#### tls-key

Path to the public/private key file.

#### tls-cert

Path to the certificate file.

#### tls-ca

Represents the path of the certificate file that is associated with the Certification Authority (CA).

#### tls-insecure-skip-verify

Indicates if the chain and host verification stage is skipped.

**default**: `false`

```

`docs/outputs/eventlog.md`:

```md
# Eventlog

Exports events via [Windows Event Log](https://docs.microsoft.com/en-us/windows/win32/wes/windows-event-log) API that can be explored with the [Event Viewer](https://docs.microsoft.com/en-us/previous-versions/windows/it-pro/windows-server-2008-R2-and-2008/cc766042(v=ws.11)) management tool. The screenshots below illustrate event logs produced by Fibratus. The `General` tab reveals the event type that was generated. Each log event pertains to the specific `Task Category` that directly maps to the internal event category. Similar to [sysmon](https://docs.microsoft.com/en-us/sysinternals/downloads/sysmon), Fibratus classifies each event with a custom `Event ID`. 

<p align="center">
  <img src="outputs/images/eventlog-general.png"/>
</p>

The `Details` tab shows extended event data including event parameters, process, and thread information. It is possible to customize the rendering template to influence the constructed event data. This is achieved by changing the [`eventlog.template`](outputs/eventlog?id=template) configuration property.

<p align="center">
  <img src="outputs/images/eventlog-details.png"/>
</p>

### Configuration {docsify-ignore}

The Eventlog output configuration is located in the `outputs.eventlog` section.

#### enabled

Indicates whether the Eventlog output is enabled.

**default**: `false`


#### level

Specifies the eventlog level associated with the event logs produced by Fibratus. You can specify one of the following values:

- `info`, `INFO`
- `warn`, `warning`, `WARN`, `WARNING`
- `erro`, `ERRO`, `error`, `ERROR`

**default**: `info`

#### remote-host

Address of the remote eventlog intake.

#### template

Go [template](https://pkg.go.dev/text/template) for rendering the eventlog message.

**default**:

```
Name:  		    {{ .Kevt.Name }}
Sequence: 		{{ .Kevt.Seq }}
Process ID:		{{ .Kevt.PID }}
Thread ID: 		{{ .Kevt.Tid }}
Cpu: 			{{ .Kevt.CPU }}
Params:			{{ .Kevt.Kparams }}
Category: 		{{ .Kevt.Category }}

{{- if .Kevt.PS }}

Process:		{{ .Kevt.PS.Name }}
Exe:			{{ .Kevt.PS.Exe }}
Pid:  			{{ .Kevt.PS.PID }}
Ppid: 			{{ .Kevt.PS.Ppid }}
Cmdline:		{{ .Kevt.PS.Comm }}
Cwd:			{{ .Kevt.PS.Cwd }}
SID:			{{ .Kevt.PS.SID }}
Session ID:		{{ .Kevt.PS.SessionID }}
{{ if and (.SerializeEnvs) (.Kevt.PS.Envs) }}
Env:
			{{- with .Kevt.PS.Envs }}
			{{- range $k, $v := . }}
			{{ $k }}: {{ $v }}
			{{- end }}
			{{- end }}
{{ end }}
{{ if .SerializeThreads }}
Threads:
			{{- with .Kevt.PS.Threads }}
			{{- range . }}
			{{ . }}
			{{- end }}
			{{- end }}
{{ end }}
{{ if .SerializeImages }}
Modules:
			{{- with .Kevt.PS.Modules }}
			{{- range . }}
			{{ . }}
			{{- end }}
			{{- end }}
{{ end }}
{{ if and (.SerializeHandles) (.Kevt.PS.Handles) }}
Handles:
			{{- with .Kevt.PS.Handles }}
			{{- range . }}
			{{ . }}
			{{- end }}
			{{- end }}
{{ end }}

{{ if and (.SerializePE) (.Kevt.PS.PE) }}
Entrypoint:  		{{ .Kevt.PS.PE.EntryPoint }}
Image base: 		{{ .Kevt.PS.PE.ImageBase }}
Build date:  		{{ .Kevt.PS.PE.LinkTime }}

Number of symbols: 	{{ .Kevt.PS.PE.NumberOfSymbols }}
Number of sections: {{ .Kevt.PS.PE.NumberOfSections }}

Sections:
			{{- with .Kevt.PS.PE.Sections }}
			{{- range . }}
			{{ . }}
			{{- end }}
			{{- end }}
{{ if .Kevt.PS.PE.Symbols }}
Symbols:
			{{- with .Kevt.PS.PE.Symbols }}
			{{- range . }}
			{{ . }}
			{{- end }}
			{{- end }}
{{ end }}
{{ if .Kevt.PS.PE.Imports }}
Imports:
			{{- with .Kevt.PS.PE.Imports }}
			{{- range . }}
			{{ . }}
			{{- end }}
			{{- end }}
{{ end }}
{{ if .Kevt.PS.PE.VersionResources }}
Resources:
			{{- with .Kevt.PS.PE.VersionResources }}
			{{- range $k, $v := . }}
			{{ $k }}: {{ $v }}
			{{- end }}
			{{- end }}
			{{ end }}
{{ end }}
{{- end }}

```

```

`docs/outputs/http.md`:

```md
# HTTP

Sends events to local/remote endpoints via HTTP protocol. Requests are serialized to the data format specified by the `serializer` property, which by default encodes events as `JSON` payloads. HTTP requests are randomly load-balanced across endpoints defined in the `endpoints` config property.

### Configuration {docsify-ignore}

The HTTP output configuration is located in the `outputs.http` section.

#### enabled

Indicates whether the HTTP output is enabled.

**default**: `false`

#### endpoints

Specifies a list of endpoints to which the events are forwarded. Each of the endpoints must contain the HTTP protocol scheme, that can be `http` or `https`.

#### timeout

Represents the timeout for the HTTP requests.

**default**: `5s`

#### proxy-url

Specifies the HTTP proxy URL. It overrides the HTTP proxy URL as indicated by the environment variables.

#### proxy-username

The username for HTTP proxy authentication.

#### proxy-password

The password for HTTP proxy authentication.

#### method

Determines the HTTP verb to use in requests.

**default**: `POST`

#### serializer

Specifies the event serializer type.

**default**: `json`

#### username

Username for the basic HTTP authentication.
   
#### password

Password for the basic HTTP authentication.

#### enable-gzip

If enabled, the HTTP body is compressed with the `gzip` compression.

**default**: `false`

#### headers

Represents a list of arbitrary headers to include in HTTP requests.

#### tls-key

Path to the public/private key file.

#### tls-cert

Path to the certificate file.

#### tls-ca

Represents the path of the certificate file that is associated with the Certification Authority (CA).

#### tls-insecure-skip-verify

Indicates if the chain and host verification stage is skipped.

**default**: `false`

```

`docs/outputs/introduction.md`:

```md
# Transporting Events

Fibratus delivers a diverse array of output sinks to route the events. When captures are not enough, you may opt for forwarding the event stream to remote destinations such as RabbitMQ brokers or Elasticsearch clusters. Outputs expose a rich set of configuration knobs that enable to fine-tune the behaviour of the event flow transmission.

### Event serialization tweaking {docsify-ignore}

JSON is the default serialization format for events. Since the event state contains a vast of attributes, you can specify which fields are serialized through configuration properties located in the `kevent` section.

- `serialize-threads` indicates whether the threads metadata are serialized as part of the process, and consequently, the event state
- `serialize-images` decides whether modules such as Dynamic Linked Libraries are serialized as part of the process state
- `serialize-handles` determines whether allocated process handles are serialized as part of the process state
- `serialize-pe` indicates if PE (Portable Executable) metadata are serialized as part of the process state
- `serialize-envs` indicates if environment variables are serialized as part of the process state

```

`docs/outputs/null.md`:

```md
# Null

The null output devours kernel events the same way a black hole swallows the light. This output is useful in case you want to snooze the event stream.

```

`docs/outputs/rabbitmq.md`:

```md
# RabbitMQ

The RabbitMQ output sends events to the [RabbitMQ](https://www.rabbitmq.com/) message broker. Various events are buffered and sent as part of a single AMQP message.

### Configuration {docsify-ignore}

The RabbitMQ output configuration is located in the `outputs.amqp` section.

#### enabled

Specifies whether the RabbitMQ output sink is enabled.

**default**: `false`

#### url

Represents the AMQP connection string.

**default**: `amqp://localhost:5672`

#### timeout

Specifies the AMQP connection timeout.

**default**: `5s`

#### exchange

Specifies the target AMQP exchange name that receives inbound event message flow.

**default**: `fibratus`

#### exchange-type

Represents  the AMQP exchange type. Available exchange type include common types are `direct`, `fanout`,
`topic`, `header`, and `x-consistent-hash`. To learn more about exchange types, refer to the RabbitMQ [docs](https://www.rabbitmq.com/tutorials/amqp-concepts.html#exchanges).

#### routing-key

Represents the static routing key to link exchanges with queues.

**default**: `fibratus`

#### vhost

Represents the AMQP virtual host name.

**default**: `/`

#### durable

Indicates if the exchange is marked as durable. Durable exchanges can survive broker restarts.

**default**: `false`

#### passive

Indicates if the server checks whether the exchange already exists and raises an error if it doesn't exist.

**default**: `false`

#### delivery-mode

Determines if a published message is persistent or transient.

**default**: `transient`

#### username

The username for the plain authentication method.

#### password

The password for the plain authentication method.

#### headers

Designates a collection of static headers that are added to each published message.

#### tls-key

Path to the public/private key file.

#### tls-cert

Path to the certificate file.

#### tls-ca

Represents the path of the certificate file that is associated with the Certification Authority (CA).

#### tls-insecure-skip-verify

Indicates if the chain and host verification stage is skipped.

**default**: `false`

```

`docs/overview/what-is-fibratus.md`:

```md
# What is Fibratus?

[Fibratus](https://github.com/rabbitstack/fibratus) detects, protects, and eradicates advanced adversary tradecraft by scrutinizing
and asserting a wide spectrum of system events against a behavior-driven [rule engine](/filters/rules) and [YARA](/yara/introduction) memory scanner.

Events can also be shipped to a wide array of [output sinks](/outputs/introduction) or dumped to [capture](/captures/introduction) files for local inspection and forensics analysis. You can use [filaments](/filaments/introduction) to extend Fibratus with your own arsenal of tools and so leverage the power of the Python ecosystem.

In a nutshell, the Fibratus mantra is defined by the pillars of **realtime behavior detection**, **memory scanning**, and **forensics capabilities**.

```

`docs/pe/introduction.md`:

```md
# Portable Executable Introspection

[Portable Executable](https://en.wikipedia.org/wiki/Portable_Executable) (PE) is the Windows file format that describes the layout of the executable code. PE is frequently subject to weaponization ranging from reverse shell payload injections to several obfuscation techniques used by malware creators.

Fibratus natively supports the scanning of the PE format data that, for example, underpins the [PE filters](/filters/fields?id=pe). To enable the PE introspection, it is necessary to edit the `pe.enabled` key in the configuration file or provide the `--pe.enabled=true` command line flag.

### Excluding executables {docsify-ignore}

When the PE introspection is enabled, Fibratus will try to obtain the PE data for every running process in the system. This happens during Fibratus bootstrap stage, but also when a new process is spawn. To skip gathering the PE data for some process images, you can add the image name under the `excluded-images` key in the configuration file. Avoiding the parsing of the PE format data for some process images, alleviates the pressure on Fibratus and reduces resource usage.

```

`docs/pe/resources.md`:

```md
# Resources

Fibratus reads version resources from the PE resource directory. The resource contains information about the exeucutable as its version number, its intended operating system, and its original filename. An example of version resources read by Fibratus:

```
CompanyName: Microsoft Corporation
FileDescription: Notepad
FileVersion: 10.0.18362.693 (WinBuild.160101.0800)
InternalName: Notepad
LegalCopyright: © Microsoft Corporation. All rights reserved.
OriginalFilename: NOTEPAD.EXE
ProductName: Microsoft® Windows® Operating System
ProductVersion: 10.0.18362.693
```

You can use any of these resource entries in filter expressions. For example, the `pe.resources[FileDescription] = 'Notepad'` filter matches any event where the `FileDescription` resource is equal to `Notepad`.

To enable resource parsing, it is necessary to set the `read-resources` option to `true`.

```

`docs/pe/sections.md`:

```md
# Sections

Sections are the fundamental building block of the PE data. They contain the content of the file, including the executable code, data, resources and other executable artifacts.

Fibratus obtains the number of sections, and for each section encountered in the PE data, its name and size is fetched. For example, the code section is called `.text` and the data section is called `.data`. Sometimes the malware specimens tamper the PE structure and alter sections. You can hunt for a non-standard number of sections in the executable or detect extraneous sections by checking the data surfaced by Fibratus.

### Reading extended section data {docsify-ignore}

For a full-blown section parsing, you can enable the `read-sections` option. This instructs the PE parser to read the underlying section bytes for the purpose of computing the `md5` hash of each section. It is possible to write filter expressions that involve evaluating the section attributes.

For example, to match against specific `.text` section `md5` hash, you would write the `pe.sections[.text].md5 = '0464997eb36c70083164c666d53c6af3'` filter.

```

`docs/pe/symbols.md`:

```md
# Symbols

 Symbols or functions referred to by the binary that are expected to be satisfied by other libraries at dynamic load time are located in the Import Address Table (IAT). Fibratus parses this table and extracts all symbols names as well as the dynamic libraries referenced by the binary. Symbol names can be `URLDownloadToFileA` or `WriteFile`.

 To activate symbol parsing it is necessary to enable the `read-symbols` option.

 From the filtering perspective,  you can write `pe.symbols in ('GetTextFaceW', 'GetProcessHeap')` or `pe.imports in ('msvcrt.dll', 'GDI32.dll')` to filter events where the originating process contains the provided symbols or imports in its binary PE data.

```

`docs/setup/cli.md`:

```md
## CLI {docsify-ignore}

Invoking the `fibratus` binary without any parameters reveals available CLI commands. You can obtain help information for each available command by appending the `--help` or `-h` option after the command name. Let's briefly describe available commands.

### run

The main command for bootstrapping Fibratus (either in rule engine or event forwarder mode) or running a filament. It accepts an optional filter expression. Examples:

- collect all events
  ```
  $ fibratus run --forward
  ```

- run the `watch_files` filament
  ```
  $ fibratus run -f watch_files
  ```

- collect fs events originated from the `cmd.exe` process
  ```
  $ fibratus run --forward kevt.category = 'file' and ps.name = 'cmd.exe'
  ```

- collect fs events and enable PE introspection
  ```
  $ fibratus run --forward kevt.category = 'file' --pe.enabled=true
  ```

### capture

Dumps the event flow to specialized kcap (capture) file. It accepts an optional filter expression. Examples:

- capture all events to `events.kcap` capture file
  ```
  $ fibratus capture -o events
  ```

- capture network events from the specific destination IP address
  ```
  $ fibratus capture kevt.category = 'net' and net.dip = 172.17.2.3 -o events
  ```

### replay

Replays the event flow from the kcap file. It accepts an optional filter expression. Examples:

- replay all events from the `events.kcap` capture file
  ```
  $ fibratus replay -k events
  ```

- replay events that contain a specific resource name in the PE resource directory
  ```
  $ fibratus replay pe.resources[Company] contains 'blackwater' -k events
  ```

### rules

The root command that exposes various subcommands for listing/validating rules and creating detection rule templates.

- #### list

List all rules present in the `Rules` directory.

- #### validate

Validates rules for structural and syntactic correctness.

- #### create

Create a new rule template. The command requires a rule name and an optional MITRE tactic identifier (e.g. `TA0001`) that can be passed via `--tactic-id` flag.

### config

Prints the options loaded from configuration sources including files, command line flags or environment variables. Sensitive data, such as passwords are  masked out.

### service

This is the root command that exposes multiple subcommands for interacting with the **Windows Service Control Manager**.

- #### start

Starts the Fibratus service that was previously registered within the Windows Service Control Manager.

- #### stop

Stops the Fibratus Windows service.

- #### restart

Restarts the Fibratus Windows service.

- #### remove

Removes the Fibratus service from the Windows Service Control Manager.

- #### status

Checks the status of the Fibratus Windows service.

### docs

Launches the default web browser and opens the Fibratus documentation site.

### list

The command consists of various subcommands:

- #### filaments 

Displays available filaments. Filaments live in the `%PROGRAMFILES\Fibratus\Filaments` directory, but you can override this location with the `--filament.path` flag or the corresponding key in the `yaml` configuration file.

- #### fields 

Shows all [field names](/filters/fields) that can be used in filter expressions.

- #### kevents 

Shows available event types.

### stats

Returns the runtime metrics that are exposed through the [expvar](https://golang.org/pkg/expvar/) HTTP endpoint. Useful for debugging.

### version

Displays the Fibratus version along with the commit hash and the Go compiler version.

```

`docs/setup/configuration.md`:

```md
# Configuration

You can parametrize Fibratus from various configuration sources including `yaml`/`json` files, environment variables and command line flags.
Properties that you specify via command line flags or environment variables take precedence over the configuration file.

### Files {docsify-ignore}

By default, configuration files are stored in `%PROGRAM FILES%\Fibratus\Config` directory. If you prefer to keep them in a different location, you can override the configuration file path via the `--config-file` command line flag when starting Fibratus. The template, `fibratus.yml` configuration file with all options documented is available in the `%PROGRAM FILES%\Fibratus\Config` directory.

### Flags {docsify-ignore}

Each CLI command accepts a set of config flags. For example, running the `fibratus run -h` command displays flag names, their default value (if any), and a short description. Command line flags take precedence over environment variables and configuration files.

!> Some configuration options are not exposed via command line flags and can only be tuned in the configuration file.


### Environment variables {docsify-ignore}

To set a certain configuration property via an environment variable, a simple rule of thumb needs to be followed: remove the leading `--` characters in the flag name, convert all `.` and `-` characters to `_` symbol, capitalize the environment variable name and you're ready to go.

Let's suppose we want to set the value of the `--kstream.buffer-size` flag via an environment variable. The resulting environment variable would get converted to `KSTREAM_BUFFER_SIZE`.

```

`docs/setup/installation.md`:

```md
# Installation

### System requirements {docsify-ignore}

- **Windows 10** and higher or **Windows Server 2016** or higher
- 40 MB of free disk space
- 1 (V)CPU
- 90 MB of available physical memory

### Permission requirements {docsify-ignore}

Fibratus requires **administrator** or **SYSTEM** privileges to capture system events from the ETW subsystem. During execution, Fibratus performs the following operations on your system:

- takes a snapshot of allocated system handles. You can control this option through [configuration](/kevents/handle?id=handle-state) flags. Disabled by default.
- periodically writes the current event sequence into volatile registry value
- writes logs to disk. The default logs directory location is `%PROGRAMFILES%\Fibratus\Logs`
- grants the `SeDebugPrivilege` to its process token. However, you can disable granting this privilege by setting the `debug-privilege` option to `false`
- transports event messages over the wire if the eligible output sink is active
- inspects process image [PE](/pe/introduction.md) metadata. Again, you can disable this feature through [config](/pe/introduction) file
- executes [YARA](/yara/introduction.md) rules on freshly created process images or other image files when the [YARA scanner](/yara/introduction) is enabled
- spins up an embedded Python interpreter to run [filaments](/filaments/introduction)
- accesses raw disk devices to read file data


### Installation  {docsify-ignore}

The easiest way to get started with Fibratus is by downloading the Windows installer. Head over to the [releases](https://github.com/rabbitstack/fibratus/releases) and pick your download. Latest releases are recommended as they ship with new features, bug fixes and tend to improve the performance.
Windows installers are automatically built by the CI platform each time new Fibratus release is published.

<p align="center">
  <a href="https://github.com/rabbitstack/fibratus/releases"><img src="setup/images/fibratus-msi.png"/ width="700px" height="600px"></a>
</p>

There are two flavors of Windows MSI installers:

- __full installers__ ship with all features ([captures](captures/introduction), [filaments](filaments/introduction), [yara](yara/introduction)) and bundle the embedded Python distribution
- __slim installers__ support less features but are more portable and have lower disk space requirements

The installer will automatically register and start Fibratus as **Windows Service**. To verify if the service is running correctly, spin up a command line prompt and execute the following command:

```
$ fibratus service status
Fibratus service is running
```

If you're able to see the output like in the snippet above, congratulations! You have successfully installed Fibratus. Jump to [quick start](/setup/quick-start).

### Uninstall {docsify-ignore}

To remove Fibratus from your system, head to the **Control Panel > Programs and Features** and start the uninstall process. The uninstaller will make sure to stop/remove the Windows Service and get rid of all installation data.

## Building from source {docsify-ignore}

To build Fibratus directly from source code you have to satisfy the following requirements:

- Go compiler 1.21+
- C compiler (optional)
- Python headers (optional)
- [libyara](https://github.com/VirusTotal/yara/tree/master/libyara) (optional)

### Installing dependencies {docsify-ignore}

!> You can skip this step if you're not interested in building features that interop with the C code.

1. Download the `msys2` installer and follow the instructions [here](https://www.msys2.org/).
  - open the `msys2` shell (by default located in `C:\msys2\msys2.exe`). You can also access it from the `MSYS2 64-bit` Start Menu item.
  - install the `MinGW` compiler toolchain along with other dependencies:
    - `pacman -S base-devel mingw-w64-x86_64-openssl mingw-w64-x86_64-gcc mingw-w64-x86_64-pkg-config automake libtool autoconf`
2. [Download](https://www.python.org/ftp/python/3.7.9/python-3.7.9-amd64.exe) and install the `Python 3.7`. Assuming the Python distribution was installed in `C:\Python37`, set the `PKG_CONFIG_PATH` environment variable to the location of the `pkg-config` directory within the `fibratus` directory.
  - `set PKG_CONFIG_PATH=<pkg-config absolute path>`
3. Build `libyara`
  - clone the `yara` repository into the path visible to the `msys2` environment. This is ideally done from the `MSYS2 64-bit` shell.
    - `pacman -S git`
    - `git clone https://github.com/VirusTotal/yara.git`
    - go to the `yara` repository you previously cloned. Run the following commands:
      - `autoreconf -fiv`
      - `./configure --host=x86_64-w64-mingw32`
      - `make install`

### Building the executable {docsify-ignore}

The **optional dependencies are only needed** if you'll be building features that interop with the C code. The Go compiler is instructed to ignore all features that trigger the [cgo](https://golang.org/cmd/cgo/), but you can control which features are built into Fibratus through the following build flags:

- `filament`: compiles Fibratus with filaments support
- `kcap`: compiles Fibratus with support for capturing/replaying kcap files
- `yara`: builds Fibratus with support for [Yara](https://virustotal.github.io/yara/) pattern matching

To build the Fibratus binary without filament, kcap nor yara features, run the following command from the `cmd` shell and within the`fibratus` directory:

```
$ make
```

To produce the Fibratus binary with the filaments support, you would run the following commands:

```
$ set TAGS=filament
$ make
```

In either case, the resulting binary is placed in the `cmd\fibratus` directory.

```

`docs/setup/quick-start.md`:

```md
# Quick start

By default, Fibratus operates in rule engine mode. It loads the rule set from the `%PROGRAM FILES%\Fibratus\Rules` directory and sends security alerts to [Eventlog](/alerts/senders/eventlog) or other configurable [sinks](/alerts/senders). Optionally, it takes response actions when the rule is fired, such as killing the process. To see Fibratus in action, we can trigger a rule by performing the following actions:

- spin up a command line prompt
- list credentials from the vault by using the `VaultCmd` tool
```
$ VaultCmd.exe /listcreds:"Windows Credentials" /all
```

- `Credential discovery via VaultCmd tool` rule should trigger displaying the alert in the Eventlog `Application` channel.

To learn more about detection rules, head to [rules](/filters/rules).

### Event forwarding {docsify-ignore}

To start forwarding events to [output](/outputs/introduction) sinks, run Fibratus from the command line in event forwarding mode:

```
$ fibratus service stop
$ fibratus run --forward
```

The continuous stream of events will start rendering on the console.

```
  ...
681951 2020-11-07 14:24:57.1839809 +0100 CET - 2 cmd.exe (6328) - CreateFile (file_name➜ C:\WINDOWS\system32\config\systemprofile\AppData\Local\Microsoft\WindowsApps\, file_object➜ ffffa88c7ea077d0, irp➜ ffffa88c746b2a88, operation➜ supersede, share_mask➜ rw-, type➜ directory)
681952 2020-11-07 14:24:57.1840451 +0100 CET - 2 cmd.exe (6328) - RegOpenKey (key_handle➜ 0, key_name➜ HKEY_LOCAL_MACHINE\SOFTWARE\Policies\Microsoft\WindowsStore, status➜ key not found)
681953 2020-11-07 14:24:57.1840626 +0100 CET - 2 cmd.exe (6328) - RegOpenKey (key_handle➜ 0, key_name➜ HKEY_LOCAL_MACHINE\System\CurrentControlSet\Control\StateSeparation\RedirectionMap\Keys, status➜ key not found)
681954 2020-11-07 14:24:57.1840751 +0100 CET - 2 cmd.exe (6328) - RegOpenKey (key_handle➜ 0, key_name➜ HKEY_LOCAL_MACHINE\Software\Microsoft\LanguageOverlay\OverlayPackages\en-US, status➜ key not found)
681955 2020-11-07 14:24:57.1841104 +0100 CET - 2 cmd.exe (6328) - CreateFile (file_name➜ C:\WINDOWS\system32\en-US\cmd.exe.mui, file_object➜ ffffa88c7ea077d0, irp➜ ffffa88c746b2a88, operation➜ open, share_mask➜ r-d, type➜ directory)
681956 2020-11-07 14:24:57.1848044 +0100 CET - 2 cmd.exe (6328) - TerminateThread (base_prio➜ 8, entrypoint➜ 7ff7762382b0, io_prio➜ 2, kstack➜ fffff10cf0785000, kstack_limit➜ fffff10cf077e000, page_prio➜ 5, pid➜ 6328, tid➜ 11716, ustack➜ d020700000, ustack_limit➜ d020604000)
681957 2020-11-07 14:24:57.1848713 +0100 CET - 2 cmd.exe (6328) - UnloadImage (base_address➜ 7ff776220000, default_address➜ 7ff776220000, file_name➜ C:\Windows\System32\cmd.exe, image_size➜ 413696, pid➜ 6328)
681958 2020-11-07 14:24:57.1848779 +0100 CET - 2 cmd.exe (6328) - UnloadImage (base_address➜ 7fffaaba0000, default_address➜ 7fffaaba0000, file_name➜ C:\Program Files\AVG\Antivirus\aswhook.dll, image_size➜ 73728, pid➜ 6328)
681959 2020-11-07 14:24:57.1848954 +0100 CET - 2 cmd.exe (6328) - UnloadImage (base_address➜ 7fffc97a0000, default_address➜ 7fffc97a0000, file_name➜ C:\Windows\System32\KernelBase.dll, image_size➜ 2764800, pid➜ 6328)
681967 2020-11-07 14:24:57.184997 +0100 CET - 2 erl.exe (5236) - TerminateProcess (comm➜ C:\WINDOWS\system32\cmd.exe /c handle.exe /accepteula -s -p 5236 2> nul, directory_table_base➜ 2300cb000, exe➜ C:\WINDOWS\system32\cmd.exe, exit_status➜ 1, kproc➜ ffffa88c70ee7080, name➜ cmd.exe, pid➜ 6328, ppid➜ 5236, session_id➜ 0, sid➜ NT AUTHORITY\SYSTEM)
681968 2020-11-07 14:24:57.1853111 +0100 CET - 2  (6328) - RegOpenKey (key_handle➜ ffffc980980b55f0, key_name➜ HKEY_LOCAL_MACHINE\SYSTEM\ControlSet001\Services\bam\State\UserSettings\S-1-5-18, status➜ success)
681969 2020-11-07 14:24:57.1853224 +0100 CET - 2  (6328) - RegQueryValue (key_handle➜ ffffc980abd657d0, key_name➜ HKEY_LOCAL_MACHINE\SYSTEM\ControlSet001\Services\bam\State\UserSettings\S-1-5-18\\Device\HarddiskVolume4\Windows\System32\cmd.exe, status➜ key not found)
681970 2020-11-07 14:24:57.1853581 +0100 CET - 5 aswidsagent.exe (7812) - CreateFile (file_name➜ C:\WINDOWS\SYSTEM32\CMD.EXE, file_object➜ ffffa88c7a8053e0, irp➜ ffffa88c7b711608, operation➜ open, share_mask➜ rw-, type➜ file)
681971 2020-11-07 14:24:57.185952 +0100 CET - 4 AVGSvc.exe (4000) - CreateFile (file_name➜ C:\ProgramData\AVG\Antivirus\psi.db-journal, file_object➜ ffffa88c7ea02500, irp➜ ffffa88c73ff8a88, operation➜ supersede, share_mask➜ rw-, type➜ directory)
681972 2020-11-07 14:24:57.1860706 +0100 CET - 4 AVGSvc.exe (4000) - ReadFile (file_name➜ C:\ProgramData\AVG\Antivirus\psi.db, file_object➜ ffffa88c72c7c260, io_size➜ 16, irp➜ ffffa88c73ff8a88, offset➜ 24, type➜ file)
  ...
```

Each line is comprised of the following fields:

- monotonic sequence value
- timestamp of event occurrence
- CPU where the event was captured
- the process name and the pid that produced the event
- event type
- event parameters

A different [rendering template](/outputs/console?id=templates) can be used to customize the line format or you can opt to change the output format to, for example, JSON.

The console output is the default events output, even though you can route the event flow to [Elasticsearch](https://www.elastic.co/elasticsearch/) or [RabbitMQ](https://www.rabbitmq.com/) sinks, just to name a few. [Learn](/outputs/introduction) more about output sinks.

To stop Fibratus, hit the `Ctr-C` key combination.

```

`docs/themes/fibratus.css`:

```css
@import url("https://fonts.googleapis.com/css?family=Roboto+Mono|Source+Code+Pro|Oxygen+Mono|Nova+Mono|Source+Sans+Pro:300,400,600");
* {
	-webkit-font-smoothing: antialiased;
	-webkit-overflow-scrolling: touch;
	-webkit-tap-highlight-color: rgba(0, 0, 0, 0);
	-webkit-text-size-adjust: none;
	-webkit-touch-callout: none;
	box-sizing: border-box
}

body:not(.ready) {
	overflow: hidden
}

body:not(.ready) .app-nav,
body:not(.ready)>nav,
body:not(.ready) [data-cloak] {
	display: none
}

div#app {
	font-size: 30px;
	font-weight: lighter;
	margin: 40vh auto;
	text-align: center
}

div#app:empty:before {
	content: "Loading Fibratus Docs..."
}

footer span {
		font-size: 10px;
}

footer {
	text-align: center;
}

.search input {
	background-color: #F7F7F7;
	border-radius:5px;
	text-indent: 23px;
	-moz-border-radius:5px;
	-webkit-border-radius:5px;
}

.search .input-wrap::before {
		font-family: "FontAwesome";
		content: "\f002";
    position: relative;
    left: 8px;
    top: -2px;
		color: #d6e0f0;
    height: 24px;
    width: 0;
    overflow: visible;
    display: inline-block;
    line-height: 24px;
    z-index: 1;
}

.fast-icon {
  color: #ffba00;
}

.extensible-icon {
	color: #5D99E5;
}

.comprehensive-icon {
	color: #738FD6;
}

.operator > p {
	background-color: rgba(0, 27, 61, 0.03);
	border-left: 4px solid #6da9e2 !important;
	border-radius: 5px;
	color: #001b3d;
	font-weight: 600;
	font-size: .95em;
	padding: 0.7em 0.6em;
}


p.center {
	text-align: center;
	font-size: 30px;
}

.inner-icon {
    border-top: 1px solid #ffba00;
    color: #ffba00;
    font-size: 1.5em;
    margin-bottom: -.5em;
    margin-top: 1em;
    text-align: center;
}

.emoji {
	height: 1.2rem;
	vertical-align: middle
}

.progress {
	background-color: var(--theme-color, #42b983);
	height: 2px;
	left: 0;
	position: fixed;
	right: 0;
	top: 0;
	transition: width .2s, opacity .4s;
	width: 0;
	z-index: 999999
}

.hero-icon-left {
	font-size: 100px;
	color: #b6d4f0;
	float: left;
	margin-left: -10px;
	margin-bottom: 2px;
	margin-top: -10px;
	margin-right: 15px;
	 --ionicon-stroke-width: 16px;
}

.search .search-keyword,
.search a:hover {
	color: var(--theme-color, #42b983)
}

.search .search-keyword {
	font-style: normal;
	font-weight: 700
}

.hydrated {
	top: 3px;
	position: relative;
}

body,
html {
	height: 100%
}

body {
	-moz-osx-font-smoothing: grayscale;
	-webkit-font-smoothing: antialiased;
	color: #34495e;
	font-family: Jost, Source Sans Pro, Helvetica Neue, Arial, sans-serif;
	font-size: 18px;
	letter-spacing: 0;
	margin: 0;
	overflow-x: hidden
}

img {
	max-width: 100%
}

a[disabled] {
	cursor: not-allowed;
	opacity: .6
}

kbd {
	border: 1px solid #ccc;
	border-radius: 3px;
	display: inline-block;
	font-size: 12px!important;
	line-height: 12px;
	margin-bottom: 3px;
	padding: 3px 5px;
	vertical-align: middle
}

li input[type=checkbox] {
	margin: 0 .2em .25em 0;
	vertical-align: middle
}

.app-nav {
	margin: 0;
	top: 0;
	position: fixed;
	right: 0;
	text-align: right;
	z-index: 10;
	background-color: #6da9e2;
	width: 100%;
	height: 0px;
	display: none;
}

.app-nav.no-badge {
	margin-right: 0px
}

.app-nav p {
	margin: 0
}

.app-nav>a {
	margin: 0 0rem;
	padding: 5px 0
}

.app-nav li,
.app-nav ul {
	display: inline-block;
	list-style: none;
	top: -12px;
	margin-right: 10px;
}

.app-nav a {
	border-radius: 1rem;
	border: 1px solid var(--theme-color, #42b983);
	box-sizing: border-box;
	color: var(--theme-color, #42b983);
	display: inline-block;
	font-size: 0.6rem;
	font-weight: 600;
	letter-spacing: .1rem;
	margin: .1rem .1rem;
	padding: .4em .4rem;
	text-decoration: none;
	transition: all .15s ease;
	background-color: #4787BE;
	color: #F7F7F7
}

.sidebar-margin-nocover {
	margin-top: 0px;
}

.app-nav a.active {
	color: #fff;
}
.app-nav a:hover {
	background-color: #5894ce;
	opacity: .8
}

.app-nav li {
	display: inline-block;
	margin: 0 0.2rem;
	padding: 0px 0;
	position: relative
}

.app-nav li ul {
	background-color: #fff;
	border: 1px solid;
	border-color: #ddd #ddd #ccc;
	border-radius: 4px;
	box-sizing: border-box;
	display: none;
	max-height: calc(100vh - 81px);
	overflow-y: auto;
	padding: 10px 0;
	position: absolute;
	right: -15px;
	text-align: left;
	top: 100%;
	white-space: nowrap
}

.app-nav li ul li {
	display: block;
	font-size: 14px;
	line-height: 1rem;
	margin: 8px 14px;
	white-space: nowrap
}

.app-nav li ul a {
	display: block;
	font-size: inherit;
	margin: 0;
	padding: 0;
}

.app-nav li ul a.active {
	border-bottom: 0;
}

.app-nav li:hover ul {
	display: block
}

.app-nav .logo {
	color: #F7F7F7;
	font-size: 1.7rem;
	font-weight: 400;
	margin-left: 25px;
	margin-top: 2px;
	position: absolute;
	text-align: right;
	display: none;
	cursor: pointer;
	letter-spacing: 2px;
}

.github-corner {
	border-bottom: 0;
	position: fixed;
	right: 0;
	text-decoration: none;
	top: 0;
	z-index: 1
}

.github-corner:hover .octo-arm {
	-webkit-animation: octocat-wave .56s ease-in-out;
	animation: octocat-wave .56s ease-in-out
}

.github-corner svg {
	color: #fff;
	fill: var(--theme-color, #42b983);
	height: 80px;
	width: 80px
}

main {
	display: block;
	position: relative;
	width: 100vw;
	height: 100%;
	z-index: 0
}

main.hidden {
	display: none
}

.anchor {
	display: inline-block;
	text-decoration: none;
	transition: all .3s
}

.anchor span {
	color: #34495e
}

.anchor span:h {
	color: #6da9e2
}

.anchor:hover {
	text-decoration: none;
}

.ml-auto {
	margin-left: auto;
}

.mr-auto {
	margin-right: auto;
}

.divider-custom {
    margin: 1.25rem 0 1.5rem;
    width: 100%;
    display: flex;
    justify-content: center;
    align-items: center;
}

.divider-custom.divider-light .divider-custom-line {
    background-color: #2c3e50;
}

.divider-custom .divider-custom-line {
    width: 100%;
    max-width: 7rem;
    height: 0.25rem;
    background-color: #2c3e50;
    border-radius: 1rem;
    border-color: #2c3e50 !important;
}

.divider-custom .divider-custom-icon {
    color: #2c3e50 !important;
    font-size: 2rem;
}

.sidebar {
	border-right: 1px solid rgba(0, 0, 0, .07);
	overflow-y: auto;
	padding: 10px 10px 0;
	position: absolute;
	top: 0;
	bottom: 0;
	left: 0;
	transition: transform .25s ease-out;
	width: 300px;
	z-index: 20;
	background-color: #F7F7F7;
}

.sidebar>h1 {
	margin: 0 auto 1rem;
	font-size: 1.5rem;
	font-weight: 300;
	text-align: center
}

.sidebar>h1 a {
	color: inherit;
	text-decoration: none
}

.sidebar>h1 .app-nav {
	display: block;
	position: static
}

.sidebar .sidebar-nav {
	line-height: 1.7em;
	padding-bottom: 40px
}

.sidebar li.collapse .app-sub-sidebar {
	display: none
}

.sidebar ul {
	margin: 0 0 0 8px;
	padding: 0;
}

.sidebar li>p {
	font-weight: 700;
	margin: 0
}

.sidebar ul,
.sidebar ul li {
	list-style: none;
	line-height: 20px;
	margin-bottom: -4px;
}

.sidebar ul li:hover {
	cursor: pointer;
	color: #6da9e2;
}

.sidebar ul +ul {
  max-height:0;
  overflow:hidden;
  transition:0.5s linear;
}

.sidebar ul li {
	border-bottom: none;
	display: block;
  padding: 4px 8px;
	font-size: 19px;
	font-weight: 500;
}

.sidebar ul li ul {
	border-left: 1px solid rgba(0, 0, 0, .07);
}

.sidebar ul li ul {
	padding-left: 1px
}

.sidebar::-webkit-scrollbar {
	width: 4px
}

.sidebar::-webkit-scrollbar-thumb {
	background: transparent;
	border-radius: 4px
}

.sidebar:hover::-webkit-scrollbar-thumb {
	background: hsla(0, 0%, 53.3%, .4)
}

.sidebar:hover::-webkit-scrollbar-track {
	background: hsla(0, 0%, 53.3%, .1)
}

.sidebar-toggle {
	background-color: transparent;
	border: 0;
	outline: none;
	padding: 10px;
	position: absolute;
	bottom: 0;
	left: 0;
	text-align: center;
	transition: opacity .3s;
	width: 284px;
	z-index: 30
}

.sidebar-toggle .sidebar-toggle-button:hover {
	opacity: .4
}

.sidebar-toggle span {
	background-color: var(--theme-color, #42b983);
	display: block;
	margin-bottom: 4px;
	width: 16px;
	height: 2px
}

body.sticky .sidebar,
body.sticky .sidebar-toggle {
	margin-top: 0px;
	position: fixed;
}

body.sticky .page_toc {
	margin-top: 15px;
}

body.sticky .app-nav .logo {
	display: none;
}

.page_toc ul a:hover span {
	color: #6da9e2 !important;
}

.page_toc ul a {
	font-size: 17px !important;
}

.page_toc .active {
	border-left: 3px solid !important;
}

.page_toc {
		padding-left: 12px !important;
}

.content {
	padding-top: 30px;
	position: absolute;
	top: 0;
	right: 0;
	bottom: 0;
	left: 300px;
	transition: left .25s ease;
	background-color: #F7F7F7;
}

.markdown-section {
	margin: 0 auto;
	max-width: 80%;
	padding: 30px 15px 40px;
	position: relative;
}

.markdown-section>* {
	box-sizing: border-box;
	font-size: inherit
}

.markdown-section>:first-child {
	margin-top: 0!important
}

.markdown-section hr {
	border: none;
	border-bottom: 1px solid #eee;
	margin: 2em 0
}

.markdown-section iframe {
	border: 1px solid #eee;
	width: 1px;
	min-width: 100%
}

.markdown-section table {
	border-collapse: collapse;
	border-spacing: 0;
	display: block;
	margin-bottom: 1rem;
	overflow: auto;
	width: 100%
}

.markdown-section th {
	font-weight: 700
}

.markdown-section td,
.markdown-section th {
	border: 1px solid #ddd;
	padding: 6px 13px
}

.markdown-section tr {
	border-top: 1px solid #ccc
}

.markdown-section p.tip,
.markdown-section tr:nth-child(2n) {
	background-color: rgba(0, 27, 61, 0.03);
}

.markdown-section p.tip {
	border-bottom-right-radius: 2px;
	border-left: 4px solid #f66;
	border-top-right-radius: 2px;
	margin: 2em 0;
	padding: 12px 24px 12px 30px;
	position: relative
}

.markdown-section p.tip:before {
	background-color: #f66;
	border-radius: 100%;
	color: #fff;
	content: "!";
	font-family: Dosis, Source Sans Pro, Helvetica Neue, Arial, sans-serif;
	font-size: 14px;
	font-weight: 700;
	left: -12px;
	line-height: 20px;
	position: absolute;
	height: 20px;
	width: 20px;
	text-align: center;
	top: 14px
}

.markdown-section p.tip code {
	background-color: #efefef
}

.markdown-section p.tip em {
	color: #34495e
}

.markdown-section p.warn {
	background: rgba(66, 185, 131, .1);
	border-radius: 2px;
	padding: 1rem
}

.markdown-section ul.task-list>li {
	list-style-type: none
}

body.close .sidebar {
	transform: translateX(-300px)
}

body.close .sidebar-toggle {
	width: auto
}

body.close .content {
	left: 0
}

@media print {
	.app-nav,
	.github-corner,
	.sidebar,
	.sidebar-toggle {
		display: none
	}
}


@media screen and (max-width: 1300px) {
	.page_toc {
		display: none;
	}
}

@media screen and (max-width: 768px) {
    .github-corner,
    .sidebar,
    .sidebar-toggle {
        position: fixed;
    }
    .app-nav {
        margin-top: 16px;
    }
    .app-nav li ul {
        top: 30px;
    }
    main {
        height: auto;
        overflow-x: hidden;
    }
    .sidebar {
        left: -300px;
        transition: transform 0.25s ease-out;
    }
    .content {
        left: 0;
        max-width: 100vw;
        position: static;
        padding-top: 20px;
        transition: transform 0.25s ease;
    }
    .app-nav,
    .github-corner {
        transition: transform 0.25s ease-out;
    }
    .sidebar-toggle {
        background-color: transparent;
        width: auto;
        padding: 30px 30px 10px 10px;
    }
    body.close .sidebar {
        transform: translateX(300px);
    }
    body.close .sidebar-toggle {
        background-color: hsla(0, 0%, 100%, 0.8);
        transition: background-color 1s;
        width: 284px;
        padding: 10px;
    }
    body.close .content {
        transform: translateX(300px);
    }
    body.close .app-nav,
    body.close .github-corner {
        display: none;
    }
    .github-corner:hover .octo-arm {
        -webkit-animation: none;
        animation: none;
    }
    .github-corner .octo-arm {
        -webkit-animation: octocat-wave 0.56s ease-in-out;
        animation: octocat-wave 0.56s ease-in-out;
    }
	.page_toc {
		display: none;
	}
}

@keyframes octocat-wave {
	0%,
	to {
		transform: rotate(0)
	}
	20%,
	60% {
		transform: rotate(-25deg)
	}
	40%,
	80% {
		transform: rotate(10deg)
	}
}

section.cover {
	align-items: center;
	background-position: 50%;
	background-repeat: no-repeat;
	background-size: cover;
	height: 205vh;
	display: none;
}

section.cover.show {
	display: flex;
	background: linear-gradient(#1180e0,#c7def4) !important;
}

section.cover.has-mask .mask {
	background-color: #fff;
	opacity: .8;
	position: absolute;
	top: 0;
	height: 100%;
	width: 100%
}

section.cover .cover-main {
	flex: 1;
	margin: -20px 16px 0px; 
	text-align: center;
	position: relative;
}

section.cover .cover-main img {
	margin-top: 45px;
}

section.cover a {
	color: inherit
}

section.cover a,
section.cover a:hover {
	text-decoration: none
}

section.cover p {
	line-height: 1.5rem;
	margin: 1em 0
}

section.cover h1 {
	color: #fff;
	font-size: 2.5rem;
	font-weight: 300;
	margin: .625rem 0 2.5rem;
	position: relative;
	text-align: center
}

section.cover h1 a {
	display: block
}

section.cover h1 small {
	bottom: -.4375rem;
	font-size: 1rem;
	position: absolute
}

section.cover blockquote {
	font-size: 1.5rem;
	text-align: center
}

section.cover ul {
	line-height: 1.8;
	list-style-type: none;
	margin: 1em auto;
	max-width: 500px;
	padding: 0
}

section.cover .cover-main>p:nth-last-child(2) a {
	background: linear-gradient(340.87deg,#777ce0 -5.97%,#60cefd 100.83%);
	box-shadow: 0px 20px 30px -3px rgba(112,153,234,.45);
	border-radius: 2rem;
	border: 1px solid var(--theme-color, #42b983);
	box-sizing: border-box;
	color: #34495e;
	display: inline-block;
	font-size: 1.05rem;
	letter-spacing: .1rem;
	margin: .5rem 1rem;
	padding: .75em 2rem;
	text-decoration: none;
	transition: .3s all ease-in-out;
}

section.cover .cover-main {
	position: relative;
	top: 0px;
}

section.cover .cover-main>p:nth-last-child(2) a:hover {
	color: inherit;
  opacity: .8;
}

section.cover .cover-main h1 {
	font-size: 3.5rem;
}

section.cover blockquote>p>a {
	border-bottom: 2px solid var(--theme-color, #42b983);
	transition: color .3s
}

section.cover blockquote>p>a:hover {
	color: var(--theme-color, #42b983)
}

section.cover .cover-main div {
	position: relative;
} 

.sidebar,
body {
	background-color: #F7F7F7;
}

.sidebar {
	color: #364149
}

.sidebar li {
	margin: 10px 0
}

.sidebar ul li a {
	color: #505d6b;
	font-size: 16px;
	font-weight: 500;
	overflow: hidden;
	text-decoration: none;
	text-overflow: ellipsis;
	white-space: nowrap;
}

.sidebar ul li a:hover {
	text-decoration: underline
}

.sidebar ul li ul {
	padding: -1;
	margin: 0
}

.sidebar ul li.active>a {
	color: var(--theme-color, #42b983);
	font-weight: 600
}

.app-sub-sidebar li:before {
	padding-right: 4px;
	float: left
}

.markdown-section h1,
.markdown-section h2,
.markdown-section h3,
.markdown-section h4,
.markdown-section strong {
	color: #2c3e50;
	font-weight: 600
}

.markdown-section h4 {
	 border-bottom: 1px solid rgba(0, 0, 0,.045);
}

.markdown-section h2.center {
	color: #2c3e50;
	font-weight: 600;
	text-align: center;
}

.markdown-section a {
	color: var(--theme-color, #42b983);
	font-weight: 600
}

.markdown-section h1 {
	font-size: 2rem;
	margin: 0 0 1rem;
	border-bottom: 1px solid rgba(0, 0, 0,.075);
}

.markdown-section h2 {
	font-size: 1.75rem;
	margin: 45px 0 .8rem
}

.markdown-section h3 {
	font-size: 1.5rem;
	margin: 40px 0 .6rem
}

.markdown-section h4 {
	font-size: 1.25rem
}

.markdown-section h5 {
	font-size: 1rem
}

.markdown-section h6 {
	color: #777;
	font-size: 1rem
}

.markdown-section figure,
.markdown-section p {
	margin: 1.2em 0
}

.markdown-section ol,
.markdown-section p,
.markdown-section ul {
	line-height: 1.6rem;
	word-spacing: .05rem
}

.markdown-section ol,
.markdown-section ul {
	padding-left: 1.5rem
}

.markdown-section blockquote {
	border-left: 4px solid var(--theme-color, #42b983);
	color: #858585;
	margin: 2em 0;
	padding-left: 20px
}

.markdown-section blockquote p {
	font-weight: 600;
	margin-left: 0
}

.markdown-section iframe {
	margin: 1em 0
}

.markdown-section em {
	color: #6da9e2
}

.pagination-item-title:hover {
	 color: #6da9e2
}

.markdown-section code {
	border-radius: 5px;
	color: #5894ce;
	font-size: .8rem;
	margin: 0 2px;
	padding: 3px 5px;
	white-space: pre-wrap;
	font-weight: 600;
}

.markdown-section code,
.markdown-section pre {
	background-color: rgba(0, 27, 61, 0.03);
	font-family: Nova Mono, Oxygen Mono, Source Code Pro, Roboto Mono, Monaco, courier, monospace
}

.markdown-section pre {
	font-family: Nova Mono, Source Code Pro, Roboto Mono, Monaco, courier, monospace;
	-moz-osx-font-smoothing: initial;
	-webkit-font-smoothing: initial;
	line-height: 1.5rem;
	margin: 1.2em 0;
	overflow: auto;
	padding: 0 1.4rem;
	position: relative;
	word-wrap: normal;
	border-radius: 5px;
}

.token.cdata,
.token.comment,
.token.doctype,
.token.prolog {
	color: #8e908c
}

.token.namespace {
	opacity: .7
}

.token.boolean,
.token.number {
	color: #c76b29
}

.token.punctuation {
	color: #525252
}

.token.property {
	color: #c08b30
}

.token.tag {
	color: #2973b7
}

.token.string {
	color: var(--theme-color, #42b983)
}

.token.selector {
	color: #6679cc
}

.token.attr-name {
	color: #2973b7
}

.language-css .token.string,
.style .token.string,
.token.entity,
.token.url {
	color: #22a2c9
}

.token.attr-value,
.token.control,
.token.directive,
.token.unit {
	color: var(--theme-color, #42b983)
}

.token.function,
.token.keyword {
	color: #e96900
}

.token.atrule,
.token.regex,
.token.statement {
	color: #22a2c9
}

.token.placeholder,
.token.variable {
	color: #3d8fd1
}

.token.deleted {
	text-decoration: line-through
}

.token.inserted {
	border-bottom: 1px dotted #202746;
	text-decoration: none
}

.token.italic {
	font-style: italic
}

.token.bold,
.token.important {
	font-weight: 700
}

.token.important {
	color: #c94922
}

.token.entity {
	cursor: help
}

.markdown-section pre>code {
	-moz-osx-font-smoothing: initial;
	-webkit-font-smoothing: initial;
	background-color: #f8f8f8a3;
	border-radius: 0px;
	color: #5994CE;
	display: block;
	font-family: Nova Mono, Oxygen Mono, Source Code Pro, Roboto Mono, Monaco, courier, monospace;
	font-size: .85rem;
	line-height: inherit;
	margin: 0 2px;
	max-width: inherit;
	overflow: inherit;
	padding: 1.2em 5px;
	white-space: inherit
}

.markdown-section code:after,
.markdown-section code:before {
	letter-spacing: .05rem
}

code .token {
	-moz-osx-font-smoothing: initial;
	-webkit-font-smoothing: initial;
	min-height: 1.5rem;
	position: relative;
	left: auto
}

pre:after {
	color: #ccc;
	content: attr(data-lang);
	font-size: .6rem;
	font-weight: 600;
	height: 15px;
	line-height: 15px;
	padding: 5px 10px 0;
	position: absolute;
	right: 0;
	text-align: right;
	top: 0
}

```

`docs/transformers/introduction.md`:

```md
# Parsing, Enriching, Transforming

Transformers are responsible for mutating, parsing, or enriching kernel events before they hit the output sink. They offer a fair amount of flexibility to shape the structure of the event parameters. Transformers are applied sequentially to every event routed to the output sink.

You can parameterize transformers via the `yml` configuration in the `transformers` section.

```

`docs/transformers/remove.md`:

```md
# Remove

The `remove` transform drops parameters from the event. Given the following event parameters:

```
{
  'file_name': 'C:\WINDOWS\system32\config\systemprofile\AppData\WindowsApps\',
  'file_object': 'ffffa88c7ea077d0',
  'irp': 'ffffa88c746b2a88',
  'operation': 'supersede',
  'share_mask': 'rw-',
  'type': 'directory'
}
```

And the `remove` transformer configuration:

```
transformers:
  remove:
    enabled: true
    kparams:
      - irp
      - share_mask
      - file_object
```

The event will contain the following parameters:

```
{
  'file_name': 'C:\WINDOWS\system32\config\systemprofile\AppData\WindowsApps\',
  'operation': 'supersede',
  'type': 'directory'
}
```

### Configuration {docsify-ignore}

The `remove` transformer configuration is located in the `transformers.remove` section.

#### enabled

Indicates if the `remove` transformer is enabled.

**default**: `false`

#### kparams

Represents the list of parameters that are removed from the event.

```

`docs/transformers/rename.md`:

```md
# Rename

The `rename` transform rename one or more parameters. Given the following event parameters:

```
{
  'file_name': 'C:\WINDOWS\system32\config\systemprofile\AppData\WindowsApps\',
  'file_object': 'ffffa88c7ea077d0',
  'irp': 'ffffa88c746b2a88',
  'operation': 'supersede',
  'share_mask': 'rw-',
  'type': 'directory'
}
```

And the `rename` transformer configuration:

```
transformers:
  rename:
    enabled: true
    kparams:
      - old: file_name
        new: file
      - old: file_object
        new: fobj
```

The event will contain the following parameters:

```
{
  'name': 'C:\WINDOWS\system32\config\systemprofile\AppData\WindowsApps\',
  'fobj': 'ffffa88c7ea077d0',
  'irp': 'ffffa88c746b2a88',
  'operation': 'supersede',
  'share_mask': 'rw-',
  'type': 'directory'
}
```

### Configuration {docsify-ignore}

The `rename` transformer configuration is located in the `transformers.rename` section.

#### enabled

Indicates if the `rename` transformer is enabled.

**default**: `false`

#### kparams

Contains the list of old/new parameter name mappings. `old` key represents the original parameter name, while `new` is the new parameter name.

```

`docs/transformers/replace.md`:

```md
# Replace

The `replace` transformer replaces all non-overlapping instances of string parameters with the specified substring. Given the following event parameters:

```
{
  'key_handle': 0,
  'key_name': 'HKEY_LOCAL_MACHINE\System\CurrentControlSet\Control\StateSeparation\Keys',
  'status': 'key not found'
}
```

And the `replace` transformer configuration:

```
replace:
  enabled: true
  replacements:
    - kparam: key_name
      old: HKEY_LOCAL_MACHINE
      new: HKLM
```

The transformer produces the following parameters:

```
{
  'key_handle': 0,
  'key_name': 'HKLM\System\CurrentControlSet\Control\StateSeparation\Keys',
  'status': 'key not found'
}
```

### Configuration {docsify-ignore}

The `replace` transformer configuration is located in the `transformers.replace` section.

#### enabled

Indicates if the `replace` transformer is enabled.

**default**: `false`

#### replacements

Contains the list of parameter replacements. For each target event parameter identified by the `kparam` key, `old` represent the substring  that will be replaced by the `new` substring.

```

`docs/transformers/tags.md`:

```md
# Tags

The `tags` transformer appends custom tags to event's metadata field.

### Configuration {docsify-ignore}

The `tags` transformer configuration is located in the `transformers.tags` section.

#### enabled

Indicates if the `tags` transformer is enabled.

**default**: `false`

#### tags

Contains the list of tags that are appended to event metadata. Values can be fetched from environment variables by enclosing them in `%`. Example:

```
tags:
  enabled: true
  tags:
    - key: env
      value: prod
    - key: drive
      value: %HOMEDRIVE%
```

```

`docs/transformers/trim.md`:

```md
# Trim

The `trim` transformer cuts off specified prefixes/suffixes from the string event parameters. Given the following event parameters:

```
{
  'key_handle': 0,
  'key_name': 'HKEY_LOCAL_MACHINE\System\CurrentControlSet\Control\StateSeparation\Keys',
  'status': 'key not found'
}
```

And the `trim` transformer configuration:

```
replace:
  enabled: true
  prefixes:
    - kparam: key_name
      trim: HKEY_LOCAL_MACHINE
  suffixes:
    - kparam: key_name
      trim: Keys
```

The transformer produces the following parameters:

```
{
  'key_handle': 0,
  'key_name': '\System\CurrentControlSet\Control\StateSeparation\',
  'status': 'key not found'
}
```

### Configuration {docsify-ignore}

The `trim` transformer configuration is located in the `transformers.trim` section.

#### enabled

Indicates if the `trim` transformer is enabled.

**default**: `false`

#### prefixes

Contains the list of parameter names and prefixes that are trimmed from the parameter's value.

#### suffixes

Contains the list of parameter names and suffixes that are trimmed from the parameter's value.

```

`docs/troubleshooting/logs.md`:

```md
# Logs

Fibratus logs various diagnostics and error messages to log files residing in the `%PROGRAM FILES%\Fibratus\Logs` directory. Logs serve as an invaluable resource for debugging or chasing down issues in Fibratus.

### Configuration {docsify-ignore}

It's possible to influence the behavior of how log file are written. The configuration options are stored in the `logging` section of the `yml` file.

#### level

Specifies the minimum allowed log level. Anything logged below this log level will not get dumped to a file or stdout stream. Possible values are `debug`, `info`, `warn`, `error`, `panic`.

**default**: `info`

#### max-age

Represents the maximum number of days to retain old log files based on the timestamp encoded in their filename. By default, all log files are retained.

**default**: `0`

#### max-backup

Specifies the maximum number of old log files to retain.

**default**: `15`

#### max-size

Specifies the maximum size in megabytes of the log file before it gets rotated.

**default**: `100`

#### formatter

Represents the log file format. Possible values are `text` or `json`. By default, Fibratus will dump the logs in JSON format.

**default**: `json`

#### path

Represents the alternative paths for storing the logs.

#### log-stdout

Indicates whether log lines are written to standard output in addition to writing them to log files.

**default**: `false`

```

`docs/troubleshooting/pprof.md`:

```md
# Profiling

[pprof](https://golang.org/pkg/net/http/pprof/) is an extremely useful profiling facility that lets you collect CPU profiles, traces and heap allocation profiles among others. With `pprof` it is easy to spot top CPU consumers or find opportunities for code optimizations.

To get the profile, you can use the `go tool pprof` tool. The pprof HTTP handlers are exposed on `localhost:8482` by default. To override the TCP port or the transport protocol, modify the `api.transport` configuration option. For example, getting the CPU profile could be accomplished with the following command:

```
$ go tool pprof http://localhost:8482/debug/pprof/profile
```

```

`docs/troubleshooting/stats.md`:

```md
# Stats

Sometimes it is useful to dive into the internal Fibratus telemetry to get various metrics about its inner workings. Fibratus exposes its internal metrics through the [expvar](https://golang.org/pkg/expvar/) interface. To explore the metrics you can execute the `fibratus stats` command.

```

`docs/yara/alerts.md`:

```md
# Alerts

Alerts on rule matches are automatically sent via all active alert senders.

##  Event metadata {docsify-ignore}

When the event triggers a specific YARA rule, its metadata is automatically decorated with the rule matches. 
The `yara.matches` tag contains the JSON array payload where each object represents the YARA rule match. For example:

```json
[
  {
    "rule": "AnglerEKredirector ",
    "namespace": "EK",
    "tags": null,
    "metas": [
      {
        "identifier": "description",
        "value": "Angler Exploit Kit Redirector"
      }
    ],
    "strings": "..."
  },
  {
    "rule": "angler_flash_uncompressed ",
    "namespace": "EK",
    "tags": [
      "exploitkit"
    ],
    "metas": [
      {
        "identifier": "description",
        "value": "Angler Exploit Kit Detection"
      }
    ],
    "strings": "..."
  }
]
```

```

`docs/yara/introduction.md`:

```md
# Pattern Matching Swiss Knife

[YARA](https://virustotal.github.io/yara/) is a prominent tool for binary pattern matching that aims to streamline and accelerate the classification of malware specimens. Fibratus interacts with the `libyara` through C bindings. The `libyara` dependency is statically linked, so no further software needs to be installed.

**Fibratus/YARA** tandem aims to detect in-memory threats and malicious **PE** files by reacting on various signals including:

- new process creation
- loading of an unsigned/untrusted executable/DLL or when the executable/DLL is loaded from the unbacked memory region
- creation of executable, DLL, or driver PE files
- creation of [ADS](https://learn.microsoft.com/en-us/openspecs/windows_protocols/ms-fscc/e2b19412-a925-4360-b009-86e3b8a020c8) (Alternate Data Streams)
- RWX memory allocations
- mapping of a suspicious view of section
- writing a binary registry value

The YARA scanner is not enabled by default, but you can do that by modifying the `yara.enabled` key in the configuration file.

```

`docs/yara/scanning.md`:

```md
# Scanning Processes

For the YARA scanner to operate correctly, the rules have to be compiled and loaded into the engine. This is accomplished by providing file system paths with YARA rule definitions in the `rule.paths` configuration keys. The directories are scanned recursively for any `.yar` file. Alternatively, it is possible to provide the rules as inline strings directly in the Fibratus configuration file.

### Configuration {docsify-ignore}

YARA scanner related options are located in the `yara` section of the configuration file.

#### enabled

Indicates if the YARA scanner is enabled. When enabled, each newly created process is scanned for pattern matches.

**default**: `false`

#### rule

The `rule` key contains various nested keys. The `paths` key identifies directories that hold the YARA rule definitions. It is also possible to link each directory to YARA namespace. The `strings` key allows for defining inline YARA rules. Example:

```
rule:
  paths:
    - path: C:\\yara-rules
      namespace: default
    - path: C:\\pdf-rules
      namespace: pdf

  strings:
    - string: rule test : tag1 { meta: author = \"Hilko Bengen\" strings: $a = \"abc\" fullword condition: $a }
      namespace: notepad
```

#### alert-template:

Specifies templates for the alert text in Go [templating](https://golang.org/pkg/text/template) language. 


#### fastscan

Determines when multiple matches of the same string can be avoided when not necessary.

**default**: `true`

#### scan-timeout

Specifies the timeout for the scanner. If the timeout is reached, the scan operation is cancelled.

**default**: `20s`

#### skip-files

Indicates whether file scanning is enabled. This affects the scan triggered by the image loading, create file, and file mapping operations.

**default**: `false`

#### skip-allocs

Indicates whether scanning on suspicious memory allocations is disabled.

**default**: `false`

#### skip-mmaps

Indicates whether scanning on suspicious mappings of sections is disabled.

**default**: `false`


#### skip-registry

Indicates whether registry value scanning is disabled.

**default**: `false`


#### excluded-files

Contains the list of the comma-separated file paths that shouldn't be scanned. Wildcard matching is possible. For example:

```
excluded-files:
	- ?:\\Windows\\System32\\kernel32.dll
```

#### excluded-procs

Contains the list of the comma-separated process image paths that shouldn't be scanned. Wildcard matching is possible.

```

`filaments/README.md`:

```md
Fibratus incorporates a framework for painlessly extending the functionality and incorporating new features via Python scripts. 
These scripts are called **filaments**. You can also think of them as extension points with virtually endless possibilities. 
Whatever you are allowed to craft in Python, you can also implement in filaments.

Visit the [documentation](https://www.fibratus.io/#/filaments/writing) for a walkthrough on writing a filament from scratch.

### Available filaments

- `top_in_packets` shows the top TCP / UDP inbound packets by IP/port tuple
- `top_keys` shows the top registry keys by number of registry operations
- `top_out_packets` shows the top TCP / UDP outbound packets by IP/port tuple
- `watch_files` watches files and directories created in the file system

```

`filaments/top_in_packets.py`:

```py
# Copyright 2019-2020 by Nedim Sabic (RabbitStack)
# All Rights Reserved.
# http://rabbitstack.github.io

# Licensed under the Apache License, Version 2.0 (the "License"); you may
# not use this file except in compliance with the License. You may obtain
# a copy of the License at
#
# http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
# WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
# License for the specific language governing permissions and limitations
# under the License.

"""
Shows the top TCP / UDP inbound packets by IP/port tuple
"""

import collections
from utils.dotdict import dotdictify

__connections__ = collections.Counter()


def on_init():
    set_filter("evt.name = 'Recv'")
    columns(["Source", "Count"])
    sort_by('Count')
    interval(1)


@dotdictify
def on_next_event(event):
    src = ['%s:%d' % (event.params.sip, event.params.sport)]
    __connections__.update(src)


def on_interval():
    for ip, count in __connections__.copy().items():
        add_row([ip, count])
    render_table()
```

`filaments/top_keys.py`:

```py
# Copyright 2016 by Nedim Sabic (RabbitStack)
# All Rights Reserved.
# http://rabbitstack.github.io

# Licensed under the Apache License, Version 2.0 (the "License"); you may
# not use this file except in compliance with the License. You may obtain
# a copy of the License at
#
# http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
# WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
# License for the specific language governing permissions and limitations
# under the License.


"""
Shows top keys by number of registry operations
"""

import collections
from utils.dotdict import dotdictify

__keys__ = collections.Counter()


def on_init():
    set_filter("evt.category = 'registry'")
    columns(["Key", "#Ops"])
    sort_by('#Ops')
    interval(1)


@dotdictify
def on_next_event(event):
    key = event.params.key_path
    if key:
        __keys__.update((key, ))


def on_interval():
    for key, count in __keys__.copy().items():
        add_row([key, count])
    render_table()
```

`filaments/top_out_packets.py`:

```py
# Copyright 2019-2020 by Nedim Sabic (RabbitStack)
# All Rights Reserved.
# http://rabbitstack.github.io

# Licensed under the Apache License, Version 2.0 (the "License"); you may
# not use this file except in compliance with the License. You may obtain
# a copy of the License at
#
# http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
# WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
# License for the specific language governing permissions and limitations
# under the License.

"""
Shows the top TCP / UDP outbound packets by IP/port tuple
"""

import collections
from utils.dotdict import dotdictify

__connections__ = collections.Counter()


def on_init():
    set_filter("evt.name = 'Send'")
    columns(["Destination", "Count"])
    sort_by('Count')
    interval(1)


@dotdictify
def on_next_event(event):
    dst = ['%s:%d' % (event.params.dip, event.params.dport)]
    __connections__.update(dst)


def on_interval():
    for ip, count in __connections__.copy().items():
        add_row([ip, count])
    render_table()
```

`filaments/utils/dotdict.py`:

```py
# https://stackoverflow.com/questions/2352181/how-to-use-a-dot-to-access-members-of-dictionary
class dotdict(dict):
    """dot.notation access to dictionary attributes"""
    __getattr__ = dict.get
    __setattr__ = dict.__setitem__
    __delattr__ = dict.__delitem__


def dotdictify(fn):
    """
    The decorator for converting the dict parameter to dot notation access dictionary.
    """
    def __wrap(event):
        event = dotdict(event)
        event.params = dotdict(event.params)
        return fn(event)
    return __wrap

```

`filaments/watch_files.py`:

```py
# Copyright 2019-2020 by Nedim Sabic (RabbitStack)
# All Rights Reserved.
# http://rabbitstack.github.io

# Licensed under the Apache License, Version 2.0 (the "License"); you may
# not use this file except in compliance with the License. You may obtain
# a copy of the License at
#
# http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
# WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
# License for the specific language governing permissions and limitations
# under the License.

"""
Watches files and directories created in the file system
"""

from utils.dotdict import dotdictify

__files__ = []


def on_init():
    set_filter("evt.name = 'CreateFile' and file.operation != 'OPEN'")
    columns(["Process", "File"])


@dotdictify
def on_next_event(event):
    file_path = event.params.file_path
    if file_path:
        __files__.append((event.exe, file_path, ))
        for f in __files__:
            add_row([f[0], f[1]])
        render_table()

```

`go.mod`:

```mod
module github.com/rabbitstack/fibratus

require (
	github.com/Masterminds/sprig/v3 v3.2.2
	github.com/Microsoft/go-winio v0.4.14
	github.com/antchfx/htmlquery v1.2.5
	github.com/bits-and-blooms/bitset v1.13.0
	github.com/briandowns/spinner v1.12.0
	github.com/cenkalti/backoff/v4 v4.3.0
	github.com/dustin/go-humanize v1.0.0
	github.com/enescakir/emoji v1.0.0
	github.com/golang/groupcache v0.0.0-20200121045136-8c9f03a8e57e
	github.com/hashicorp/go-version v1.2.1
	github.com/hillu/go-yara/v4 v4.2.4
	github.com/jedib0t/go-pretty/v6 v6.2.1
	github.com/lithammer/fuzzysearch v1.1.2
	github.com/magiconair/properties v1.8.1
	github.com/mitchellh/mapstructure v1.4.1
	github.com/olivere/elastic/v7 v7.0.20
	github.com/phayes/freeport v0.0.0-20180830031419-95f893ade6f2
	github.com/pkg/errors v0.9.1
	github.com/qmuntal/stateless v1.6.0
	github.com/rifflock/lfshook v0.0.0-20180920164130-b9218ef580f5
	github.com/saferwall/pe v1.5.6
	github.com/sirupsen/logrus v1.9.3
	github.com/spf13/cobra v0.0.3
	github.com/spf13/pflag v1.0.5
	github.com/spf13/viper v1.6.2
	github.com/streadway/amqp v1.0.0
	github.com/stretchr/testify v1.8.1
	github.com/tailscale/wf v0.0.0-20240214030419-6fbb0a674ee6
	github.com/valyala/bytebufferpool v1.0.0
	github.com/valyala/gozstd v1.11.0
	github.com/xeipuuv/gojsonschema v1.2.0
	github.com/yuin/goldmark v1.5.2
	go.mozilla.org/pkcs7 v0.0.0-20210826202110-33d05740a352
	golang.org/x/arch v0.6.0
	golang.org/x/sys v0.31.0
	golang.org/x/text v0.23.0
	golang.org/x/time v0.3.0
	gopkg.in/gomail.v2 v2.0.0-20160411212932-81ebce5c23df
	gopkg.in/natefinch/lumberjack.v2 v2.0.0
	gopkg.in/yaml.v3 v3.0.1
	www.velocidex.com/golang/go-ntfs v0.2.1-0.20240818145200-04736de821dc
)

require (
	github.com/BurntSushi/toml v0.4.1 // indirect
	github.com/rivo/uniseg v0.4.2 // indirect
	github.com/rogpeppe/go-internal v1.11.0 // indirect
	github.com/secDre4mer/pkcs7 v0.0.0-20240322103146-665324a4461d // indirect
	go4.org/netipx v0.0.0-20220725152314-7e7bdc8411bf // indirect
	golang.org/x/exp/typeparams v0.0.0-20220218215828-6cf2b201936e // indirect
	golang.org/x/mod v0.17.0 // indirect
	golang.org/x/sync v0.12.0 // indirect
	golang.org/x/tools v0.21.1-0.20240508182429-e35e4ccd0d2d // indirect
	honnef.co/go/tools v0.3.2 // indirect
)

require (
	github.com/Masterminds/goutils v1.1.1 // indirect
	github.com/Masterminds/semver/v3 v3.1.1 // indirect
	github.com/antchfx/xpath v1.2.1 // indirect
	github.com/davecgh/go-spew v1.1.2-0.20180830191138-d8f796af33cc // indirect
	github.com/edsrzf/mmap-go v1.1.0 // indirect
	github.com/fatih/color v1.7.0 // indirect
	github.com/fsnotify/fsnotify v1.4.7 // indirect
	github.com/google/uuid v1.1.1
	github.com/hashicorp/hcl v1.0.0 // indirect
	github.com/huandu/xstrings v1.3.1 // indirect
	github.com/imdario/mergo v0.3.11 // indirect
	github.com/inconshreveable/mousetrap v1.0.0 // indirect
	github.com/josharian/intern v1.0.0 // indirect
	github.com/mailru/easyjson v0.7.6 // indirect
	github.com/mattn/go-colorable v0.1.2 // indirect
	github.com/mattn/go-isatty v0.0.16 // indirect
	github.com/mattn/go-runewidth v0.0.14 // indirect
	github.com/mitchellh/copystructure v1.0.0 // indirect
	github.com/mitchellh/reflectwalk v1.0.0 // indirect
	github.com/pelletier/go-toml v1.2.0 // indirect
	github.com/pmezard/go-difflib v1.0.0 // indirect
	github.com/shopspring/decimal v1.2.0 // indirect
	github.com/spf13/afero v1.1.2 // indirect
	github.com/spf13/cast v1.3.1 // indirect
	github.com/spf13/jwalterweatherman v1.0.0 // indirect
	github.com/stretchr/objx v0.5.0 // indirect
	github.com/subosito/gotenv v1.2.0 // indirect
	github.com/xeipuuv/gojsonpointer v0.0.0-20180127040702-4e3ac2762d5f // indirect
	github.com/xeipuuv/gojsonreference v0.0.0-20180127040603-bd5ef7bd5415 // indirect
	golang.org/x/crypto v0.36.0 // indirect
	golang.org/x/net v0.38.0 // indirect
	gopkg.in/alexcesaro/quotedprintable.v3 v3.0.0-20150716171945-2caba252f4dc // indirect
	gopkg.in/ini.v1 v1.51.0 // indirect
	gopkg.in/yaml.v2 v2.3.0 // indirect
)

go 1.26.0

```

`go.sum`:

```sum
cloud.google.com/go v0.26.0/go.mod h1:aQUYkXzVsufM+DwF1aE+0xfcU+56JwCaLick0ClmMTw=
github.com/BurntSushi/toml v0.3.1/go.mod h1:xHWCNGjB5oqiDr8zfno3MHue2Ht5sIBksp03qcyfWMU=
github.com/BurntSushi/toml v0.4.1 h1:GaI7EiDXDRfa8VshkTj7Fym7ha+y8/XxIgD2okUIjLw=
github.com/BurntSushi/toml v0.4.1/go.mod h1:CxXYINrC8qIiEnFrOxCa7Jy5BFHlXnUU2pbicEuybxQ=
github.com/Masterminds/goutils v1.1.1 h1:5nUrii3FMTL5diU80unEVvNevw1nH4+ZV4DSLVJLSYI=
github.com/Masterminds/goutils v1.1.1/go.mod h1:8cTjp+g8YejhMuvIA5y2vz3BpJxksy863GQaJW2MFNU=
github.com/Masterminds/semver/v3 v3.1.1 h1:hLg3sBzpNErnxhQtUy/mmLR2I9foDujNK030IGemrRc=
github.com/Masterminds/semver/v3 v3.1.1/go.mod h1:VPu/7SZ7ePZ3QOrcuXROw5FAcLl4a0cBrbBpGY/8hQs=
github.com/Masterminds/sprig/v3 v3.2.2 h1:17jRggJu518dr3QaafizSXOjKYp94wKfABxUmyxvxX8=
github.com/Masterminds/sprig/v3 v3.2.2/go.mod h1:UoaO7Yp8KlPnJIYWTFkMaqPUYKTfGFPhxNuwnnxkKlk=
github.com/Microsoft/go-winio v0.4.14 h1:+hMXMk01us9KgxGb7ftKQt2Xpf5hH/yky+TDA+qxleU=
github.com/Microsoft/go-winio v0.4.14/go.mod h1:qXqCSQ3Xa7+6tgxaGTIe4Kpcdsi+P8jBhyzoq1bpyYA=
github.com/OneOfOne/xxhash v1.2.2/go.mod h1:HSdplMjZKSmBqAxg5vPj2TmRDmfkzw+cTzAElWljhcU=
github.com/alecthomas/assert v1.0.0 h1:3XmGh/PSuLzDbK3W2gUbRXwgW5lqPkuqvRgeQ30FI5o=
github.com/alecthomas/assert v1.0.0/go.mod h1:va/d2JC+M7F6s+80kl/R3G7FUiW6JzUO+hPhLyJ36ZY=
github.com/alecthomas/colour v0.1.0 h1:nOE9rJm6dsZ66RGWYSFrXw461ZIt9A6+nHgL7FRrDUk=
github.com/alecthomas/colour v0.1.0/go.mod h1:QO9JBoKquHd+jz9nshCh40fOfO+JzsoXy8qTHF68zU0=
github.com/alecthomas/repr v0.1.1 h1:87P60cSmareLAxMc4Hro0r2RBY4ROm0dYwkJNpS4pPs=
github.com/alecthomas/repr v0.1.1/go.mod h1:Fr0507jx4eOXV7AlPV6AVZLYrLIuIeSOWtW57eE/O/4=
github.com/alecthomas/template v0.0.0-20160405071501-a0175ee3bccc/go.mod h1:LOuyumcjzFXgccqObfd/Ljyb9UuFJ6TxHnclSeseNhc=
github.com/alecthomas/units v0.0.0-20151022065526-2efee857e7cf/go.mod h1:ybxpYRFXyAe+OPACYpWeL0wqObRcbAqCMya13uyzqw0=
github.com/antchfx/htmlquery v1.2.5 h1:1lXnx46/1wtv1E/kzmH8vrfMuUKYgkdDBA9pIdMJnk4=
github.com/antchfx/htmlquery v1.2.5/go.mod h1:2MCVBzYVafPBmKbrmwB9F5xdd+IEgRY61ci2oOsOQVw=
github.com/antchfx/xpath v1.2.1 h1:qhp4EW6aCOVr5XIkT+l6LJ9ck/JsUH/yyauNgTQkBF8=
github.com/antchfx/xpath v1.2.1/go.mod h1:i54GszH55fYfBmoZXapTHN8T8tkcHfRgLyVwwqzXNcs=
github.com/armon/consul-api v0.0.0-20180202201655-eb2c6b5be1b6/go.mod h1:grANhF5doyWs3UAsr3K4I6qtAmlQcZDesFNEHPZAzj8=
github.com/aws/aws-sdk-go v1.34.13/go.mod h1:5zCpMtNQVjRREroY7sYe8lOMRSxkhG6MZveU8YkpAk0=
github.com/beorn7/perks v0.0.0-20180321164747-3a771d992973/go.mod h1:Dwedo/Wpr24TaqPxmxbtue+5NUziq4I4S80YR8gNf3Q=
github.com/beorn7/perks v1.0.0/go.mod h1:KWe93zE9D1o94FZ5RNwFwVgaQK1VOXiVxmqh+CedLV8=
github.com/bits-and-blooms/bitset v1.13.0 h1:bAQ9OPNFYbGHV6Nez0tmNI0RiEu7/hxlYJRUA0wFAVE=
github.com/bits-and-blooms/bitset v1.13.0/go.mod h1:7hO7Gc7Pp1vODcmWvKMRA9BNmbv6a/7QIWpPxHddWR8=
github.com/briandowns/spinner v1.12.0 h1:72O0PzqGJb6G3KgrcIOtL/JAGGZ5ptOMCn9cUHmqsmw=
github.com/briandowns/spinner v1.12.0/go.mod h1:QOuQk7x+EaDASo80FEXwlwiA+j/PPIcX3FScO+3/ZPQ=
github.com/cenkalti/backoff/v4 v4.3.0 h1:MyRJ/UdXutAwSAT+s3wNd7MfTIcy71VQueUuFK343L8=
github.com/cenkalti/backoff/v4 v4.3.0/go.mod h1:Y3VNntkOUPxTVeUxJ/G5vcM//AlwfmyYozVcomhLiZE=
github.com/cespare/xxhash v1.1.0/go.mod h1:XrSqR1VqqWfGrhpAt58auRo0WTKS1nRRg3ghfAqPWnc=
github.com/client9/misspell v0.3.4/go.mod h1:qj6jICC3Q7zFZvVWo7KLAzC3yx5G7kyvSDkc90ppPyw=
github.com/coreos/bbolt v1.3.2/go.mod h1:iRUV2dpdMOn7Bo10OQBFzIJO9kkE559Wcmn+qkEiiKk=
github.com/coreos/etcd v3.3.10+incompatible/go.mod h1:uF7uidLiAD3TWHmW31ZFd/JWoc32PjwdhPthX9715RE=
github.com/coreos/go-semver v0.2.0/go.mod h1:nnelYz7RCh+5ahJtPPxZlU+153eP4D4r3EedlOD2RNk=
github.com/coreos/go-systemd v0.0.0-20190321100706-95778dfbb74e/go.mod h1:F5haX7vjVVG0kc13fIWeqUViNPyEJxv/OmvnBo0Yme4=
github.com/coreos/pkg v0.0.0-20180928190104-399ea9e2e55f/go.mod h1:E3G3o1h8I7cfcXa63jLwjI0eiQQMgzzUDFVpN/nH/eA=
github.com/davecgh/go-spew v1.1.0/go.mod h1:J7Y8YcW2NihsgmVo/mv3lAwl/skON4iLHjSsI+c5H38=
github.com/davecgh/go-spew v1.1.1/go.mod h1:J7Y8YcW2NihsgmVo/mv3lAwl/skON4iLHjSsI+c5H38=
github.com/davecgh/go-spew v1.1.2-0.20180830191138-d8f796af33cc h1:U9qPSI2PIWSS1VwoXQT9A3Wy9MM3WgvqSxFWenqJduM=
github.com/davecgh/go-spew v1.1.2-0.20180830191138-d8f796af33cc/go.mod h1:J7Y8YcW2NihsgmVo/mv3lAwl/skON4iLHjSsI+c5H38=
github.com/dgrijalva/jwt-go v3.2.0+incompatible/go.mod h1:E3ru+11k8xSBh+hMPgOLZmtrrCbhqsmaPHjLKYnJCaQ=
github.com/dgryski/go-sip13 v0.0.0-20181026042036-e10d5fee7954/go.mod h1:vAd38F8PWV+bWy6jNmig1y/TA+kYO4g3RSRF0IAv0no=
github.com/dustin/go-humanize v1.0.0 h1:VSnTsYCnlFHaM2/igO1h6X3HA71jcobQuxemgkq4zYo=
github.com/dustin/go-humanize v1.0.0/go.mod h1:HtrtbFcZ19U5GC7JDqmcUSB87Iq5E25KnS6fMYU6eOk=
github.com/edsrzf/mmap-go v1.1.0 h1:6EUwBLQ/Mcr1EYLE4Tn1VdW1A4ckqCQWZBw8Hr0kjpQ=
github.com/edsrzf/mmap-go v1.1.0/go.mod h1:19H/e8pUPLicwkyNgOykDXkJ9F0MHE+Z52B8EIth78Q=
github.com/enescakir/emoji v1.0.0 h1:W+HsNql8swfCQFtioDGDHCHri8nudlK1n5p2rHCJoog=
github.com/enescakir/emoji v1.0.0/go.mod h1:Bt1EKuLnKDTYpLALApstIkAjdDrS/8IAgTkKp+WKFD0=
github.com/fatih/color v1.7.0 h1:DkWD4oS2D8LGGgTQ6IvwJJXSL5Vp2ffcQg58nFV38Ys=
github.com/fatih/color v1.7.0/go.mod h1:Zm6kSWBoL9eyXnKyktHP6abPY2pDugNf5KwzbycvMj4=
github.com/fortytw2/leaktest v1.3.0 h1:u8491cBMTQ8ft8aeV+adlcytMZylmA5nnwwkRZjI8vw=
github.com/fortytw2/leaktest v1.3.0/go.mod h1:jDsjWgpAGjm2CA7WthBh/CdZYEPF31XHquHwclZch5g=
github.com/fsnotify/fsnotify v1.4.7 h1:IXs+QLmnXW2CcXuY+8Mzv/fWEsPGWxqefPtCP5CnV9I=
github.com/fsnotify/fsnotify v1.4.7/go.mod h1:jwhsz4b93w/PPRr/qN1Yymfu8t87LnFCMoQvtojpjFo=
github.com/fzipp/gocyclo v0.3.1/go.mod h1:DJHO6AUmbdqj2ET4Z9iArSuwWgYDRryYt2wASxc7x3E=
github.com/ghodss/yaml v1.0.0/go.mod h1:4dBDuWmgqj2HViK6kFavaiC9ZROes6MMH2rRYeMEF04=
github.com/go-kit/kit v0.8.0/go.mod h1:xBxKIO96dXMWWy0MnWVtmwkA9/13aqxPnvrjFYMA2as=
github.com/go-logfmt/logfmt v0.3.0/go.mod h1:Qt1PoO58o5twSAckw1HlFXLmHsOX5/0LbT9GBnD5lWE=
github.com/go-logfmt/logfmt v0.4.0/go.mod h1:3RMwSq7FuexP4Kalkev3ejPJsZTpXXBr9+V4qmtdjCk=
github.com/go-sql-driver/mysql v1.5.0/go.mod h1:DCzpHaOWr8IXmIStZouvnhqoel9Qv2LBy8hT2VhHyBg=
github.com/go-stack/stack v1.8.0/go.mod h1:v0f6uXyyMGvRgIKkXu+yp6POWl0qKG85gN/melR3HDY=
github.com/gogo/protobuf v1.1.1/go.mod h1:r8qH/GZQm5c6nD/R0oafs1akxWv10x8SbQlK7atdtwQ=
github.com/gogo/protobuf v1.2.1/go.mod h1:hp+jE20tsWTFYpLwKvXlhS1hjn+gTNwPg2I6zVXpSg4=
github.com/golang/glog v0.0.0-20160126235308-23def4e6c14b/go.mod h1:SBH7ygxi8pfUlaOkMMuAQtPIUF8ecWP5IEl/CR7VP2Q=
github.com/golang/groupcache v0.0.0-20190129154638-5b532d6fd5ef/go.mod h1:cIg4eruTrX1D+g88fzRXU5OdNfaM+9IcxsU14FzY7Hc=
github.com/golang/groupcache v0.0.0-20190702054246-869f871628b6/go.mod h1:cIg4eruTrX1D+g88fzRXU5OdNfaM+9IcxsU14FzY7Hc=
github.com/golang/groupcache v0.0.0-20200121045136-8c9f03a8e57e h1:1r7pUrabqp18hOBcwBwiTsbnFeTZHV9eER/QT5JVZxY=
github.com/golang/groupcache v0.0.0-20200121045136-8c9f03a8e57e/go.mod h1:cIg4eruTrX1D+g88fzRXU5OdNfaM+9IcxsU14FzY7Hc=
github.com/golang/mock v1.1.1/go.mod h1:oTYuIxOrZwtPieC+H1uAHpcLFnEyAGVDL/k47Jfbm0A=
github.com/golang/protobuf v1.2.0/go.mod h1:6lQm79b+lXiMfvg/cZm0SGofjICqVBUtrP5yJMmIC1U=
github.com/golang/protobuf v1.3.1/go.mod h1:6lQm79b+lXiMfvg/cZm0SGofjICqVBUtrP5yJMmIC1U=
github.com/google/btree v1.0.0/go.mod h1:lNA+9X1NB3Zf8V7Ke586lFgjr2dZNuvo3lPJSGZ5JPQ=
github.com/google/go-cmp v0.2.0/go.mod h1:oXzfMopK8JAjlY9xF4vHSVASa0yLyX7SntLO5aqRK0M=
github.com/google/go-cmp v0.3.0/go.mod h1:8QqcDgzrUqlUb/G2PQTWiueGozuR1884gddMywk6iLU=
github.com/google/go-cmp v0.5.2/go.mod h1:v8dTdLbMG2kIc/vJvl+f65V22dbkXbowE6jgT/gNBxE=
github.com/google/go-cmp v0.6.0 h1:ofyhxvXcZhMsU5ulbFiLKl/XBFqE1GSq7atu8tAmTRI=
github.com/google/go-cmp v0.6.0/go.mod h1:17dUlkBOakJ0+DkrSSNjCkIjxS6bF9zb3elmeNGIjoY=
github.com/google/uuid v1.1.1 h1:Gkbcsh/GbpXz7lPftLA3P6TYMwjCLYm83jiFQZF/3gY=
github.com/google/uuid v1.1.1/go.mod h1:TIyPZe4MgqvfeYDBFedMoGGpEw/LqOeaOT+nhxU+yHo=
github.com/gopherjs/gopherjs v0.0.0-20181017120253-0766667cb4d1 h1:EGx4pi6eqNxGaHF6qqu48+N2wcFQ5qg5FXgOdqsJ5d8=
github.com/gopherjs/gopherjs v0.0.0-20181017120253-0766667cb4d1/go.mod h1:wJfORRmW1u3UXTncJ5qlYoELFm8eSnnEO6hX4iZ3EWY=
github.com/gorilla/websocket v1.4.0/go.mod h1:E7qHFY5m1UJ88s3WnNqhKjPHQ0heANvMoAMk2YaljkQ=
github.com/grpc-ecosystem/go-grpc-middleware v1.0.0/go.mod h1:FiyG127CGDf3tlThmgyCl78X/SZQqEOJBCDaAfeWzPs=
github.com/grpc-ecosystem/go-grpc-prometheus v1.2.0/go.mod h1:8NvIoxWQoOIhqOTXgfV/d3M/q6VIi02HzZEHgUlZvzk=
github.com/grpc-ecosystem/grpc-gateway v1.9.0/go.mod h1:vNeuVxBJEsws4ogUvrchl83t/GYV9WGTSLVdBhOQFDY=
github.com/hashicorp/go-version v1.2.1 h1:zEfKbn2+PDgroKdiOzqiE8rsmLqU2uwi5PB5pBJ3TkI=
github.com/hashicorp/go-version v1.2.1/go.mod h1:fltr4n8CU8Ke44wwGCBoEymUuxUHl09ZGVZPK5anwXA=
github.com/hashicorp/hcl v1.0.0 h1:0Anlzjpi4vEasTeNFn2mLJgTSwt0+6sfsiTG8qcWGx4=
github.com/hashicorp/hcl v1.0.0/go.mod h1:E5yfLk+7swimpb2L/Alb/PJmXilQ/rhwaUYs4T20WEQ=
github.com/hillu/go-yara/v4 v4.2.4 h1:r3KB1XV+h6q+N8bvK6/gLpxAVcd6baYzmOSYHzNo9QQ=
github.com/hillu/go-yara/v4 v4.2.4/go.mod h1:AHEs/FXVMQKVVlT6iG9d+q1BRr0gq0WoAWZQaZ0gS7s=
github.com/huandu/xstrings v1.3.1 h1:4jgBlKK6tLKFvO8u5pmYjG91cqytmDCDvGh7ECVFfFs=
github.com/huandu/xstrings v1.3.1/go.mod h1:y5/lhBue+AyNmUVz9RLU9xbLR0o4KIIExikq4ovT0aE=
github.com/imdario/mergo v0.3.11 h1:3tnifQM4i+fbajXKBHXWEH+KvNHqojZ778UH75j3bGA=
github.com/imdario/mergo v0.3.11/go.mod h1:jmQim1M+e3UYxmgPu/WyfjB3N3VflVyUjjjwH0dnCYA=
github.com/inconshreveable/mousetrap v1.0.0 h1:Z8tu5sraLXCXIcARxBp/8cbvlwVa7Z1NHg9XEKhtSvM=
github.com/inconshreveable/mousetrap v1.0.0/go.mod h1:PxqpIevigyE2G7u3NXJIT2ANytuPF1OarO4DADm73n8=
github.com/jedib0t/go-pretty/v6 v6.2.1 h1:O/3XdNfyWSyVLLIt1EeDhfP8AhNMjtBSh0MuZ4frg6U=
github.com/jedib0t/go-pretty/v6 v6.2.1/go.mod h1:+nE9fyyHGil+PuISTCrp7avEdo6bqoMwqZnuiK2r2a0=
github.com/jmespath/go-jmespath v0.3.0/go.mod h1:9QtRXoHjLGCJ5IBSaohpXITPlowMeeYCZ7fLUTSywik=
github.com/jonboulle/clockwork v0.1.0/go.mod h1:Ii8DK3G1RaLaWxj9trq07+26W01tbo22gdxWY5EU2bo=
github.com/josharian/intern v1.0.0 h1:vlS4z54oSdjm0bgjRigI+G1HpF+tI+9rE5LLzOg8HmY=
github.com/josharian/intern v1.0.0/go.mod h1:5DoeVV0s6jJacbCEi61lwdGj/aVlrQvzHFFd8Hwg//Y=
github.com/jtolds/gls v4.20.0+incompatible h1:xdiiI2gbIgH/gLH7ADydsJ1uDOEzR8yvV7C0MuV77Wo=
github.com/jtolds/gls v4.20.0+incompatible/go.mod h1:QJZ7F/aHp+rZTRtaJ1ow/lLfFfVYBRgL+9YlvaHOwJU=
github.com/julienschmidt/httprouter v1.2.0/go.mod h1:SYymIcj16QtmaHHD7aYtjjsJG7VTCxuUUipMqKk8s4w=
github.com/kisielk/errcheck v1.1.0/go.mod h1:EZBBE59ingxPouuu3KfxchcWSUPOHkagtvWXihfKN4Q=
github.com/kisielk/gotool v1.0.0/go.mod h1:XhKaO+MFFWcvkIS/tQcRk01m1F5IRFswLeQ+oQHNcck=
github.com/konsorten/go-windows-terminal-sequences v1.0.1/go.mod h1:T0+1ngSBFLxvqU3pZ+m/2kptfBszLMUkC4ZK/EgS/cQ=
github.com/kr/logfmt v0.0.0-20140226030751-b84e30acd515/go.mod h1:+0opPa2QZZtGFBFZlji/RkVcI2GknAs/DXo4wKdlNEc=
github.com/kr/pretty v0.1.0/go.mod h1:dAy3ld7l9f0ibDNOQOHHMYYIIbhfbHSm3C4ZsoJORNo=
github.com/kr/pretty v0.3.1 h1:flRD4NNwYAUpkphVc1HcthR4KEIFJ65n8Mw5qdRn3LE=
github.com/kr/pretty v0.3.1/go.mod h1:hoEshYVHaxMs3cyo3Yncou5ZscifuDolrwPKZanG3xk=
github.com/kr/pty v1.1.1/go.mod h1:pFQYn66WHrOpPYNljwOMqo10TkYh1fy3cYio2l3bCsQ=
github.com/kr/text v0.1.0 h1:45sCR5RtlFHMR4UwH9sdQ5TC8v0qDQCHnXt+kaKSTVE=
github.com/kr/text v0.1.0/go.mod h1:4Jbv+DJW3UT/LiOwJeYQe1efqtUx/iVham/4vfdArNI=
github.com/lithammer/fuzzysearch v1.1.2 h1:ePUtm14xKxbpCxozcFbIDRtvANxnVnE+RKpJUqkr2gA=
github.com/lithammer/fuzzysearch v1.1.2/go.mod h1:v6tYW/9kpfV6LNcweXdSjQsfCku/1M/oObmSox1fzP8=
github.com/magiconair/properties v1.8.1 h1:ZC2Vc7/ZFkGmsVC9KvOjumD+G5lXy2RtTKyzRKO2BQ4=
github.com/magiconair/properties v1.8.1/go.mod h1:PppfXfuXeibc/6YijjN8zIbojt8czPbwD3XqdrwzmxQ=
github.com/mailru/easyjson v0.7.6 h1:8yTIVnZgCoiM1TgqoeTl+LfU5Jg6/xL3QhGQnimLYnA=
github.com/mailru/easyjson v0.7.6/go.mod h1:xzfreul335JAWq5oZzymOObrkdz5UnU4kGfJJLY9Nlc=
github.com/mattn/go-colorable v0.1.2 h1:/bC9yWikZXAL9uJdulbSfyVNIR3n3trXl+v8+1sx8mU=
github.com/mattn/go-colorable v0.1.2/go.mod h1:U0ppj6V5qS13XJ6of8GYAs25YV2eR4EVcfRqFIhoBtE=
github.com/mattn/go-isatty v0.0.8/go.mod h1:Iq45c/XA43vh69/j3iqttzPXn0bhXyGjM0Hdxcsrc5s=
github.com/mattn/go-isatty v0.0.16 h1:bq3VjFmv/sOjHtdEhmkEV4x1AJtvUvOJ2PFAZ5+peKQ=
github.com/mattn/go-isatty v0.0.16/go.mod h1:kYGgaQfpe5nmfYZH+SKPsOc2e4SrIfOl2e/yFXSvRLM=
github.com/mattn/go-runewidth v0.0.9/go.mod h1:H031xJmbD/WCDINGzjvQ9THkh0rPKHF+m2gUSrubnMI=
github.com/mattn/go-runewidth v0.0.14 h1:+xnbZSEeDbOIg5/mE6JF0w6n9duR1l3/WmbinWVwUuU=
github.com/mattn/go-runewidth v0.0.14/go.mod h1:Jdepj2loyihRzMpdS35Xk/zdY8IAYHsh153qUoGf23w=
github.com/matttproud/golang_protobuf_extensions v1.0.1/go.mod h1:D8He9yQNgCq6Z5Ld7szi9bcBfOoFv/3dc6xSMkL2PC0=
github.com/mitchellh/copystructure v1.0.0 h1:Laisrj+bAB6b/yJwB5Bt3ITZhGJdqmxquMKeZ+mmkFQ=
github.com/mitchellh/copystructure v1.0.0/go.mod h1:SNtv71yrdKgLRyLFxmLdkAbkKEFWgYaq1OVrnRcwhnw=
github.com/mitchellh/mapstructure v1.1.2/go.mod h1:FVVH3fgwuzCH5S8UJGiWEs2h04kUh9fWfEaFds41c1Y=
github.com/mitchellh/mapstructure v1.4.1 h1:CpVNEelQCZBooIPDn+AR3NpivK/TIKU8bDxdASFVQag=
github.com/mitchellh/mapstructure v1.4.1/go.mod h1:bFUtVrKA4DC2yAKiSyO/QUcy7e+RRV2QTWOzhPopBRo=
github.com/mitchellh/reflectwalk v1.0.0 h1:9D+8oIskB4VJBN5SFlmc27fSlIBZaov1Wpk/IfikLNY=
github.com/mitchellh/reflectwalk v1.0.0/go.mod h1:mSTlrgnPZtwu0c4WaC2kGObEpuNDbx0jmZXqmk4esnw=
github.com/mwitkow/go-conntrack v0.0.0-20161129095857-cc309e4a2223/go.mod h1:qRWi+5nqEBWmkhHvq77mSJWrCKwh8bxhgT7d/eI7P4U=
github.com/oklog/ulid v1.3.1/go.mod h1:CirwcVhetQ6Lv90oh/F+FBtV6XMibvdAFo93nm5qn4U=
github.com/olivere/elastic/v7 v7.0.20 h1:5FFpGPVJlBSlWBOdict406Y3yNTIpVpAiUvdFZeSbAo=
github.com/olivere/elastic/v7 v7.0.20/go.mod h1:Kh7iIsXIBl5qRQOBFoylCsXVTtye3keQU2Y/YbR7HD8=
github.com/opentracing/opentracing-go v1.2.0/go.mod h1:GxEUsuufX4nBwe+T+Wl9TAgYrxe9dPLANfrWvHYVTgc=
github.com/pelletier/go-toml v1.2.0 h1:T5zMGML61Wp+FlcbWjRDT7yAxhJNAiPPLOFECq181zc=
github.com/pelletier/go-toml v1.2.0/go.mod h1:5z9KED0ma1S8pY6P1sdut58dfprrGBbd/94hg7ilaic=
github.com/phayes/freeport v0.0.0-20180830031419-95f893ade6f2 h1:JhzVVoYvbOACxoUmOs6V/G4D5nPVUW73rKvXxP4XUJc=
github.com/phayes/freeport v0.0.0-20180830031419-95f893ade6f2/go.mod h1:iIss55rKnNBTvrwdmkUpLnDpZoAHvWaiq5+iMmen4AE=
github.com/pkg/errors v0.8.0/go.mod h1:bwawxfHBFNV+L2hUp1rHADufV3IMtnDRdf1r5NINEl0=
github.com/pkg/errors v0.8.1/go.mod h1:bwawxfHBFNV+L2hUp1rHADufV3IMtnDRdf1r5NINEl0=
github.com/pkg/errors v0.9.1 h1:FEBLx1zS214owpjy7qsBeixbURkuhQAwrK5UwLGTwt4=
github.com/pkg/errors v0.9.1/go.mod h1:bwawxfHBFNV+L2hUp1rHADufV3IMtnDRdf1r5NINEl0=
github.com/pkg/profile v1.2.1/go.mod h1:hJw3o1OdXxsrSjjVksARp5W95eeEaEfptyVZyv6JUPA=
github.com/pmezard/go-difflib v1.0.0 h1:4DBwDE0NGyQoBHbLQYPwSUPoCMWR5BEzIk/f1lZbAQM=
github.com/pmezard/go-difflib v1.0.0/go.mod h1:iKH77koFhYxTK1pcRnkKkqfTogsbg7gZNVY4sRDYZ/4=
github.com/prometheus/client_golang v0.9.1/go.mod h1:7SWBe2y4D6OKWSNQJUaRYU/AaXPKyh/dDVn+NZz0KFw=
github.com/prometheus/client_golang v0.9.3/go.mod h1:/TN21ttK/J9q6uSwhBd54HahCDft0ttaMvbicHlPoso=
github.com/prometheus/client_model v0.0.0-20180712105110-5c3871d89910/go.mod h1:MbSGuTsp3dbXC40dX6PRTWyKYBIrTGTE9sqQNg2J8bo=
github.com/prometheus/client_model v0.0.0-20190129233127-fd36f4220a90/go.mod h1:xMI15A0UPsDsEKsMN9yxemIoYk6Tm2C1GtYGdfGttqA=
github.com/prometheus/common v0.0.0-20181113130724-41aa239b4cce/go.mod h1:daVV7qP5qjZbuso7PdcryaAu0sAZbrN9i7WWcTMWvro=
github.com/prometheus/common v0.4.0/go.mod h1:TNfzLD0ON7rHzMJeJkieUDPYmFC7Snx/y86RQel1bk4=
github.com/prometheus/procfs v0.0.0-20181005140218-185b4288413d/go.mod h1:c3At6R/oaqEKCNdg8wHV1ftS6bRYblBhIjjI8uT2IGk=
github.com/prometheus/procfs v0.0.0-20190507164030-5867b95ac084/go.mod h1:TjEm7ze935MbeOT/UhFTIMYKhuLP4wbCsTZCD3I8kEA=
github.com/prometheus/tsdb v0.7.1/go.mod h1:qhTCs0VvXwvX/y3TZrWD7rabWM+ijKTux40TwIPHuXU=
github.com/qmuntal/stateless v1.6.0 h1:gL34XLU4ZIGGEtlhbG1IBOty5Aoa8i+XY1YiRFtdLWk=
github.com/qmuntal/stateless v1.6.0/go.mod h1:cWTwXu9ey+FxI0fHvDi1nGCtpYa8N1X2aOmoRg2RUCI=
github.com/rifflock/lfshook v0.0.0-20180920164130-b9218ef580f5 h1:mZHayPoR0lNmnHyvtYjDeq0zlVHn9K/ZXoy17ylucdo=
github.com/rifflock/lfshook v0.0.0-20180920164130-b9218ef580f5/go.mod h1:GEXHk5HgEKCvEIIrSpFI3ozzG5xOKA2DVlEX/gGnewM=
github.com/rivo/uniseg v0.2.0/go.mod h1:J6wj4VEh+S6ZtnVlnTBMWIodfgj8LQOQFoIToxlJtxc=
github.com/rivo/uniseg v0.4.2 h1:YwD0ulJSJytLpiaWua0sBDusfsCZohxjxzVTYjwxfV8=
github.com/rivo/uniseg v0.4.2/go.mod h1:FN3SvrM+Zdj16jyLfmOkMNblXMcoc8DfTHruCPUcx88=
github.com/rogpeppe/fastuuid v0.0.0-20150106093220-6724a57986af/go.mod h1:XWv6SoW27p1b0cqNHllgS5HIMJraePCO15w5zCzIWYg=
github.com/rogpeppe/go-internal v1.11.0 h1:cWPaGQEPrBb5/AsnsZesgZZ9yb1OQ+GOISoDNXVBh4M=
github.com/rogpeppe/go-internal v1.11.0/go.mod h1:ddIwULY96R17DhadqLgMfk9H9tvdUzkipdSkR5nkCZA=
github.com/saferwall/pe v1.5.6 h1:DrRLnoQFxHWJ5lJUmrH7X2L0xeUu6SUS95Dc61eW2Yc=
github.com/saferwall/pe v1.5.6/go.mod h1:mJx+PuptmNpoPFBNhWs/uDMFL/kTHVZIkg0d4OUJFbQ=
github.com/sebdah/goldie v1.0.0 h1:9GNhIat69MSlz/ndaBg48vl9dF5fI+NBB6kfOxgfkMc=
github.com/sebdah/goldie v1.0.0/go.mod h1:jXP4hmWywNEwZzhMuv2ccnqTSFpuq8iyQhtQdkkZBH4=
github.com/secDre4mer/pkcs7 v0.0.0-20240322103146-665324a4461d h1:RQqyEogx5J6wPdoxqL132b100j8KjcVHO1c0KLRoIhc=
github.com/secDre4mer/pkcs7 v0.0.0-20240322103146-665324a4461d/go.mod h1:PegD7EVqlN88z7TpCqH92hHP+GBpfomGCCnw1PFtNOA=
github.com/sergi/go-diff v1.2.0 h1:XU+rvMAioB0UC3q1MFrIQy4Vo5/4VsRDQQXHsEya6xQ=
github.com/sergi/go-diff v1.2.0/go.mod h1:STckp+ISIX8hZLjrqAeVduY0gWCT9IjLuqbuNXdaHfM=
github.com/shopspring/decimal v1.2.0 h1:abSATXmQEYyShuxI4/vyW3tV1MrKAJzCZ/0zLUXYbsQ=
github.com/shopspring/decimal v1.2.0/go.mod h1:DKyhrW/HYNuLGql+MJL6WCR6knT2jwCFRcu2hWCYk4o=
github.com/sirupsen/logrus v1.2.0/go.mod h1:LxeOpSwHxABJmUn/MG1IvRgCAasNZTLOkJPxbbu5VWo=
github.com/sirupsen/logrus v1.4.1/go.mod h1:ni0Sbl8bgC9z8RoU9G6nDWqqs/fq4eDPysMBDgk/93Q=
github.com/sirupsen/logrus v1.9.3 h1:dueUQJ1C2q9oE3F7wvmSGAaVtTmUizReu6fjN8uqzbQ=
github.com/sirupsen/logrus v1.9.3/go.mod h1:naHLuLoDiP4jHNo9R0sCBMtWGeIprob74mVsIT4qYEQ=
github.com/smartystreets/assertions v0.0.0-20180927180507-b2de0cb4f26d/go.mod h1:OnSkiWE9lh6wB0YB77sQom3nweQdgAjqCqsofrRNTgc=
github.com/smartystreets/assertions v1.1.1 h1:T/YLemO5Yp7KPzS+lVtu+WsHn8yoSwTfItdAd1r3cck=
github.com/smartystreets/assertions v1.1.1/go.mod h1:tcbTF8ujkAEcZ8TElKY+i30BzYlVhC/LOxJk7iOWnoo=
github.com/smartystreets/go-aws-auth v0.0.0-20180515143844-0c1422d1fdb9/go.mod h1:SnhjPscd9TpLiy1LpzGSKh3bXCfxxXuqd9xmQJy3slM=
github.com/smartystreets/goconvey v1.6.4 h1:fv0U8FUIMPNf1L9lnHLvLhgicrIVChEkdzIKYqbNC9s=
github.com/smartystreets/goconvey v1.6.4/go.mod h1:syvi0/a8iFYH4r/RixwvyeAJjdLS9QV7WQ/tjFTllLA=
github.com/smartystreets/gunit v1.4.2/go.mod h1:ZjM1ozSIMJlAz/ay4SG8PeKF00ckUp+zMHZXV9/bvak=
github.com/soheilhy/cmux v0.1.4/go.mod h1:IM3LyeVVIOuxMH7sFAkER9+bJ4dT7Ms6E4xg4kGIyLM=
github.com/spaolacci/murmur3 v0.0.0-20180118202830-f09979ecbc72/go.mod h1:JwIasOWyU6f++ZhiEuf87xNszmSA2myDM2Kzu9HwQUA=
github.com/spf13/afero v1.1.2 h1:m8/z1t7/fwjysjQRYbP0RD+bUIF/8tJwPdEZsI83ACI=
github.com/spf13/afero v1.1.2/go.mod h1:j4pytiNVoe2o6bmDsKpLACNPDBIoEAkihy7loJ1B0CQ=
github.com/spf13/cast v1.3.0/go.mod h1:Qx5cxh0v+4UWYiBimWS+eyWzqEqokIECu5etghLkUJE=
github.com/spf13/cast v1.3.1 h1:nFm6S0SMdyzrzcmThSipiEubIDy8WEXKNZ0UOgiRpng=
github.com/spf13/cast v1.3.1/go.mod h1:Qx5cxh0v+4UWYiBimWS+eyWzqEqokIECu5etghLkUJE=
github.com/spf13/cobra v0.0.3 h1:ZlrZ4XsMRm04Fr5pSFxBgfND2EBVa1nLpiy1stUsX/8=
github.com/spf13/cobra v0.0.3/go.mod h1:1l0Ry5zgKvJasoi3XT1TypsSe7PqH0Sj9dhYf7v3XqQ=
github.com/spf13/jwalterweatherman v1.0.0 h1:XHEdyB+EcvlqZamSM4ZOMGlc93t6AcsBEu9Gc1vn7yk=
github.com/spf13/jwalterweatherman v1.0.0/go.mod h1:cQK4TGJAtQXfYWX+Ddv3mKDzgVb68N+wFjFa4jdeBTo=
github.com/spf13/pflag v1.0.3/go.mod h1:DYY7MBk1bdzusC3SYhjObp+wFpr4gzcvqqNjLnInEg4=
github.com/spf13/pflag v1.0.5 h1:iy+VFUOCP1a+8yFto/drg2CJ5u0yRoB7fZw3DKv/JXA=
github.com/spf13/pflag v1.0.5/go.mod h1:McXfInJRrz4CZXVZOBLb0bTZqETkiAhM9Iw0y3An2Bg=
github.com/spf13/viper v1.6.2 h1:7aKfF+e8/k68gda3LOjo5RxiUqddoFxVq4BKBPrxk5E=
github.com/spf13/viper v1.6.2/go.mod h1:t3iDnF5Jlj76alVNuyFBk5oUMCvsrkbvZK0WQdfDi5k=
github.com/streadway/amqp v1.0.0 h1:kuuDrUJFZL1QYL9hUNuCxNObNzB0bV/ZG5jV3RWAQgo=
github.com/streadway/amqp v1.0.0/go.mod h1:AZpEONHx3DKn8O/DFsRAY58/XVQiIPMTMB1SddzLXVw=
github.com/stretchr/objx v0.1.0/go.mod h1:HFkY916IF+rwdDfMAkV7OtwuqBVzrE8GR6GFx+wExME=
github.com/stretchr/objx v0.1.1/go.mod h1:HFkY916IF+rwdDfMAkV7OtwuqBVzrE8GR6GFx+wExME=
github.com/stretchr/objx v0.4.0/go.mod h1:YvHI0jy2hoMjB+UWwv71VJQ9isScKT/TqJzVSSt89Yw=
github.com/stretchr/objx v0.5.0 h1:1zr/of2m5FGMsad5YfcqgdqdWrIhu+EBEJRhR1U7z/c=
github.com/stretchr/objx v0.5.0/go.mod h1:Yh+to48EsGEfYuaHDzXPcE3xhTkx73EhmCGUpEOglKo=
github.com/stretchr/testify v1.2.2/go.mod h1:a8OnRcib4nhh0OaRAV+Yts87kKdq0PP7pXfy6kDkUVs=
github.com/stretchr/testify v1.3.0/go.mod h1:M5WIy9Dh21IEIfnGCwXGc5bZfKNJtfHm1UVUgZn+9EI=
github.com/stretchr/testify v1.4.0/go.mod h1:j7eGeouHqKxXV5pUuKE4zz7dFj8WfuZ+81PSLYec5m4=
github.com/stretchr/testify v1.5.1/go.mod h1:5W2xD1RspED5o8YsWQXVCued0rvSQ+mT+I5cxcmMvtA=
github.com/stretchr/testify v1.7.0/go.mod h1:6Fq8oRcR53rry900zMqJjRRixrwX3KX962/h/Wwjteg=
github.com/stretchr/testify v1.7.1/go.mod h1:6Fq8oRcR53rry900zMqJjRRixrwX3KX962/h/Wwjteg=
github.com/stretchr/testify v1.8.0/go.mod h1:yNjHg4UonilssWZ8iaSj1OCr/vHnekPRkoO+kdMU+MU=
github.com/stretchr/testify v1.8.1 h1:w7B6lhMri9wdJUVmEZPGGhZzrYTPvgJArz7wNPgYKsk=
github.com/stretchr/testify v1.8.1/go.mod h1:w2LPCIKwWwSfY2zedu0+kehJoqGctiVI29o6fzry7u4=
github.com/subosito/gotenv v1.2.0 h1:Slr1R9HxAlEKefgq5jn9U+DnETlIUa6HfgEzj0g5d7s=
github.com/subosito/gotenv v1.2.0/go.mod h1:N0PQaV/YGNqwC0u51sEeR/aUtSLEXKX9iv69rRypqCw=
github.com/tailscale/wf v0.0.0-20240214030419-6fbb0a674ee6 h1:l10Gi6w9jxvinoiq15g8OToDdASBni4CyJOdHY1Hr8M=
github.com/tailscale/wf v0.0.0-20240214030419-6fbb0a674ee6/go.mod h1:ZXRML051h7o4OcI0d3AaILDIad/Xw0IkXaHM17dic1Y=
github.com/tmc/grpc-websocket-proxy v0.0.0-20190109142713-0ad062ec5ee5/go.mod h1:ncp9v5uamzpCO7NfCPTXjqaC+bZgJeR0sMTm6dMHP7U=
github.com/ugorji/go v1.1.4/go.mod h1:uQMGLiO92mf5W77hV/PUCpI3pbzQx3CRekS0kk+RGrc=
github.com/valyala/bytebufferpool v1.0.0 h1:GqA5TC/0021Y/b9FG4Oi9Mr3q7XYx6KllzawFIhcdPw=
github.com/valyala/bytebufferpool v1.0.0/go.mod h1:6bBcMArwyJ5K/AmCkWv1jt77kVWyCJ6HpOuEn7z0Csc=
github.com/valyala/gozstd v1.11.0 h1:VV6qQFt+4sBBj9OJ7eKVvsFAMy59Urcs9Lgd+o5FOw0=
github.com/valyala/gozstd v1.11.0/go.mod h1:y5Ew47GLlP37EkTB+B4s7r6A5rdaeB7ftbl9zoYiIPQ=
github.com/xeipuuv/gojsonpointer v0.0.0-20180127040702-4e3ac2762d5f h1:J9EGpcZtP0E/raorCMxlFGSTBrsSlaDGf3jU/qvAE2c=
github.com/xeipuuv/gojsonpointer v0.0.0-20180127040702-4e3ac2762d5f/go.mod h1:N2zxlSyiKSe5eX1tZViRH5QA0qijqEDrYZiPEAiq3wU=
github.com/xeipuuv/gojsonreference v0.0.0-20180127040603-bd5ef7bd5415 h1:EzJWgHovont7NscjpAxXsDA8S8BMYve8Y5+7cuRE7R0=
github.com/xeipuuv/gojsonreference v0.0.0-20180127040603-bd5ef7bd5415/go.mod h1:GwrjFmJcFw6At/Gs6z4yjiIwzuJ1/+UwLxMQDVQXShQ=
github.com/xeipuuv/gojsonschema v1.2.0 h1:LhYJRs+L4fBtjZUfuSZIKGeVu0QRy8e5Xi7D17UxZ74=
github.com/xeipuuv/gojsonschema v1.2.0/go.mod h1:anYRn/JVcOK2ZgGU+IjEV4nwlhoK5sQluxsYJ78Id3Y=
github.com/xiang90/probing v0.0.0-20190116061207-43a291ad63a2/go.mod h1:UETIi67q53MR2AWcXfiuqkDkRtnGDLqkBTpCHuJHxtU=
github.com/xordataexchange/crypt v0.0.3-0.20170626215501-b2862e3d0a77/go.mod h1:aYKd//L2LvnjZzWKhF00oedf4jCCReLcmhLdhm1A27Q=
github.com/yuin/goldmark v1.4.13/go.mod h1:6yULJ656Px+3vBD8DxQVa3kxgyrAnzto9xy5taEt/CY=
github.com/yuin/goldmark v1.5.2 h1:ALmeCk/px5FSm1MAcFBAsVKZjDuMVj8Tm7FFIlMJnqU=
github.com/yuin/goldmark v1.5.2/go.mod h1:6yULJ656Px+3vBD8DxQVa3kxgyrAnzto9xy5taEt/CY=
go.etcd.io/bbolt v1.3.2/go.mod h1:IbVyRI1SCnLcuJnV2u8VeU0CEYM7e686BmAb1XKL+uU=
go.mozilla.org/pkcs7 v0.0.0-20210826202110-33d05740a352 h1:CCriYyAfq1Br1aIYettdHZTy8mBTIPo7We18TuO/bak=
go.mozilla.org/pkcs7 v0.0.0-20210826202110-33d05740a352/go.mod h1:SNgMg+EgDFwmvSmLRTNKC5fegJjB7v23qTQ0XLGUNHk=
go.opencensus.io v0.22.4/go.mod h1:yxeiOL68Rb0Xd1ddK5vPZ/oVn4vY4Ynel7k9FzqtOIw=
go.uber.org/atomic v1.4.0/go.mod h1:gD2HeocX3+yG+ygLZcrzQJaqmWj9AIm7n08wl/qW/PE=
go.uber.org/multierr v1.1.0/go.mod h1:wR5kodmAFQ0UK8QlbwjlSNy0Z68gJhDJUG5sjR94q/0=
go.uber.org/zap v1.10.0/go.mod h1:vwi/ZaCAaUcBkycHslxD9B2zi4UTXhF60s6SWpuDF0Q=
go4.org/intern v0.0.0-20211027215823-ae77deb06f29 h1:UXLjNohABv4S58tHmeuIZDO6e3mHpW2Dx33gaNt03LE=
go4.org/intern v0.0.0-20211027215823-ae77deb06f29/go.mod h1:cS2ma+47FKrLPdXFpr7CuxiTW3eyJbWew4qx0qtQWDA=
go4.org/netipx v0.0.0-20220725152314-7e7bdc8411bf h1:IdwJUzqoIo5lkr2EOyKoe5qipUaEjbOKKY5+fzPBZ3A=
go4.org/netipx v0.0.0-20220725152314-7e7bdc8411bf/go.mod h1:+QXzaoURFd0rGDIjDNpyIkv+F9R7EmeKorvlKRnhqgA=
go4.org/unsafe/assume-no-moving-gc v0.0.0-20220617031537-928513b29760 h1:FyBZqvoA/jbNzuAWLQE2kG820zMAkcilx6BMjGbL/E4=
go4.org/unsafe/assume-no-moving-gc v0.0.0-20220617031537-928513b29760/go.mod h1:FftLjUGFEDu5k8lt0ddY+HcrH/qU/0qk+H8j9/nTl3E=
golang.org/x/arch v0.6.0 h1:S0JTfE48HbRj80+4tbvZDYsJ3tGv6BUU3XxyZ7CirAc=
golang.org/x/arch v0.6.0/go.mod h1:FEVrYAQjsQXMVJ1nsMoVVXPZg6p2JE2mx8psSWTDQys=
golang.org/x/crypto v0.0.0-20180904163835-0709b304e793/go.mod h1:6SG95UA2DQfeDnfUPMdvaQW0Q7yPrPDi9nlGo2tz2b4=
golang.org/x/crypto v0.0.0-20190308221718-c2843e01d9a2/go.mod h1:djNgcEr1/C05ACkg1iLfiJU5Ep61QUkGW8qpdssI0+w=
golang.org/x/crypto v0.0.0-20200414173820-0848c9571904/go.mod h1:LzIPMQfyMNhhGPhUkYOs5KpL4U8rLKemX1yGLhDgUto=
golang.org/x/crypto v0.0.0-20210921155107-089bfa567519/go.mod h1:GvvjBRRGRdwPK5ydBHafDWAxML/pGHZbMvKqRZ5+Abc=
golang.org/x/crypto v0.36.0 h1:AnAEvhDddvBdpY+uR+MyHmuZzzNqXSe/GvuDeob5L34=
golang.org/x/crypto v0.36.0/go.mod h1:Y4J0ReaxCR1IMaabaSMugxJES1EpwhBHhv2bDHklZvc=
golang.org/x/exp v0.0.0-20190121172915-509febef88a4/go.mod h1:CJ0aWSM057203Lf6IL+f9T1iT9GByDxfZKAQTCR3kQA=
golang.org/x/exp/typeparams v0.0.0-20220218215828-6cf2b201936e h1:qyrTQ++p1afMkO4DPEeLGq/3oTsdlvdH4vqZUBWzUKM=
golang.org/x/exp/typeparams v0.0.0-20220218215828-6cf2b201936e/go.mod h1:AbB0pIl9nAr9wVwH+Z2ZpaocVmF5I4GyWCDIsVjR0bk=
golang.org/x/lint v0.0.0-20181026193005-c67002cb31c3/go.mod h1:UVdnD1Gm6xHRNCYTkRU2/jEulfH38KcIWyp/GAMgvoE=
golang.org/x/lint v0.0.0-20190227174305-5b3e6a55c961/go.mod h1:wehouNa3lNwaWXcvxsM5YxQ5yQlVC4a0KAMCusXpPoU=
golang.org/x/lint v0.0.0-20190313153728-d0100b6bd8b3/go.mod h1:6SW0HCj/g11FgYtHlgUYUwCkIfeOF89ocIRzGO/8vkc=
golang.org/x/mod v0.6.0-dev.0.20220419223038-86c51ed26bb4/go.mod h1:jJ57K6gSWd91VN4djpZkiMVwK6gcyfeH4XE8wZrZaV4=
golang.org/x/mod v0.17.0 h1:zY54UmvipHiNd+pm+m0x9KhZ9hl1/7QNMyxXbc6ICqA=
golang.org/x/mod v0.17.0/go.mod h1:hTbmBsO62+eylJbnUtE2MGJUyE7QWk4xUqPFrRgJ+7c=
golang.org/x/net v0.0.0-20180724234803-3673e40ba225/go.mod h1:mL1N/T3taQHkDXs73rZJwtUhF3w3ftmwwsq0BUmARs4=
golang.org/x/net v0.0.0-20180826012351-8a410e7b638d/go.mod h1:mL1N/T3taQHkDXs73rZJwtUhF3w3ftmwwsq0BUmARs4=
golang.org/x/net v0.0.0-20181114220301-adae6a3d119a/go.mod h1:mL1N/T3taQHkDXs73rZJwtUhF3w3ftmwwsq0BUmARs4=
golang.org/x/net v0.0.0-20181220203305-927f97764cc3/go.mod h1:mL1N/T3taQHkDXs73rZJwtUhF3w3ftmwwsq0BUmARs4=
golang.org/x/net v0.0.0-20190213061140-3a22650c66bd/go.mod h1:mL1N/T3taQHkDXs73rZJwtUhF3w3ftmwwsq0BUmARs4=
golang.org/x/net v0.0.0-20190311183353-d8887717615a/go.mod h1:t9HGtf8HONx5eT2rtn7q6eTqICYqUVnKs3thJo3Qplg=
golang.org/x/net v0.0.0-20190404232315-eb5bcb51f2a3/go.mod h1:t9HGtf8HONx5eT2rtn7q6eTqICYqUVnKs3thJo3Qplg=
golang.org/x/net v0.0.0-20190522155817-f3200d17e092/go.mod h1:HSz+uSET+XFnRR8LxR5pz3Of3rY3CfYBVs4xY44aLks=
golang.org/x/net v0.0.0-20190620200207-3b0461eec859/go.mod h1:z5CRVTTTmAJ677TzLLGU+0bjPO0LkuOLi4/5GtJWs/s=
golang.org/x/net v0.0.0-20200202094626-16171245cfb2/go.mod h1:z5CRVTTTmAJ677TzLLGU+0bjPO0LkuOLi4/5GtJWs/s=
golang.org/x/net v0.0.0-20200421231249-e086a090c8fd/go.mod h1:qpuaurCH72eLCgpAm/N6yyVIVM9cpaDIP3A8BGJEC5A=
golang.org/x/net v0.0.0-20210226172049-e18ecbb05110/go.mod h1:m0MpNAwzfU5UDzcl9v0D8zg8gWTRqZa9RBIspLL5mdg=
golang.org/x/net v0.0.0-20220722155237-a158d28d115b/go.mod h1:XRhObCWvk6IyKnWLug+ECip1KBveYUHfp+8e9klMJ9c=
golang.org/x/net v0.38.0 h1:vRMAPTMaeGqVhG5QyLJHqNDwecKTomGeqbnfZyKlBI8=
golang.org/x/net v0.38.0/go.mod h1:ivrbrMbzFq5J41QOQh0siUuly180yBYtLp+CKbEaFx8=
golang.org/x/oauth2 v0.0.0-20180821212333-d2e6202438be/go.mod h1:N/0e6XlmueqKjAGxoOufVs8QHGRruUQn6yWY3a++T0U=
golang.org/x/sync v0.0.0-20180314180146-1d60e4601c6f/go.mod h1:RxMgew5VJxzue5/jJTE5uejpjVlOe/izrB70Jof72aM=
golang.org/x/sync v0.0.0-20181108010431-42b317875d0f/go.mod h1:RxMgew5VJxzue5/jJTE5uejpjVlOe/izrB70Jof72aM=
golang.org/x/sync v0.0.0-20181221193216-37e7f081c4d4/go.mod h1:RxMgew5VJxzue5/jJTE5uejpjVlOe/izrB70Jof72aM=
golang.org/x/sync v0.0.0-20190227155943-e225da77a7e6/go.mod h1:RxMgew5VJxzue5/jJTE5uejpjVlOe/izrB70Jof72aM=
golang.org/x/sync v0.0.0-20190423024810-112230192c58/go.mod h1:RxMgew5VJxzue5/jJTE5uejpjVlOe/izrB70Jof72aM=
golang.org/x/sync v0.0.0-20220722155255-886fb9371eb4/go.mod h1:RxMgew5VJxzue5/jJTE5uejpjVlOe/izrB70Jof72aM=
golang.org/x/sync v0.12.0 h1:MHc5BpPuC30uJk597Ri8TV3CNZcTLu6B6z4lJy+g6Jw=
golang.org/x/sync v0.12.0/go.mod h1:1dzgHSNfp02xaA81J2MS99Qcpr2w7fw1gpm99rleRqA=
golang.org/x/sys v0.0.0-20180816055513-1c9583448a9c/go.mod h1:STP8DvDyc/dI5b8T5hshtkjS+E42TnysNCUPdjciGhY=
golang.org/x/sys v0.0.0-20180830151530-49385e6e1522/go.mod h1:STP8DvDyc/dI5b8T5hshtkjS+E42TnysNCUPdjciGhY=
golang.org/x/sys v0.0.0-20180905080454-ebe1bf3edb33/go.mod h1:STP8DvDyc/dI5b8T5hshtkjS+E42TnysNCUPdjciGhY=
golang.org/x/sys v0.0.0-20181107165924-66b7b1311ac8/go.mod h1:STP8DvDyc/dI5b8T5hshtkjS+E42TnysNCUPdjciGhY=
golang.org/x/sys v0.0.0-20181116152217-5ac8a444bdc5/go.mod h1:STP8DvDyc/dI5b8T5hshtkjS+E42TnysNCUPdjciGhY=
golang.org/x/sys v0.0.0-20190215142949-d0b11bdaac8a/go.mod h1:STP8DvDyc/dI5b8T5hshtkjS+E42TnysNCUPdjciGhY=
golang.org/x/sys v0.0.0-20190222072716-a9d3bda3a223/go.mod h1:STP8DvDyc/dI5b8T5hshtkjS+E42TnysNCUPdjciGhY=
golang.org/x/sys v0.0.0-20190412213103-97732733099d/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=
golang.org/x/sys v0.0.0-20190502145724-3ef323f4f1fd/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=
golang.org/x/sys v0.0.0-20190507160741-ecd444e8653b/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=
golang.org/x/sys v0.0.0-20200323222414-85ca7c5b95cd/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=
golang.org/x/sys v0.0.0-20201119102817-f84b799fce68/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=
golang.org/x/sys v0.0.0-20210615035016-665e8c7367d1/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=
golang.org/x/sys v0.0.0-20211216021012-1d35b9e2eb4e/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=
golang.org/x/sys v0.0.0-20220520151302-bc2c85ada10a/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=
golang.org/x/sys v0.0.0-20220715151400-c0bba94af5f8/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=
golang.org/x/sys v0.0.0-20220722155257-8c9f86f7a55f/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=
golang.org/x/sys v0.0.0-20220811171246-fbc7d0a398ab/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=
golang.org/x/sys v0.31.0 h1:ioabZlmFYtWhL+TRYpcnNlLwhyxaM9kWTDEmfnprqik=
golang.org/x/sys v0.31.0/go.mod h1:BJP2sWEmIv4KK5OTEluFJCKSidICx8ciO85XgH3Ak8k=
golang.org/x/term v0.0.0-20201126162022-7de9c90e9dd1/go.mod h1:bj7SfCRtBDWHUb9snDiAeCFNEtKQo2Wmx5Cou7ajbmo=
golang.org/x/term v0.0.0-20210927222741-03fcf44c2211/go.mod h1:jbD1KX2456YbFQfuXm/mYQcufACuNUgVhRMnK/tPxf8=
golang.org/x/text v0.3.0/go.mod h1:NqM8EUOU14njkJ3fqMW+pc6Ldnwhi/IjpwHt7yyuwOQ=
golang.org/x/text v0.3.2/go.mod h1:bEr9sfX3Q8Zfm5fL9x+3itogRgK3+ptLWKqgva+5dAk=
golang.org/x/text v0.3.3/go.mod h1:5Zoc/QRtKVWzQhOtBMvqHzDpF6irO9z98xDceosuGiQ=
golang.org/x/text v0.3.5/go.mod h1:5Zoc/QRtKVWzQhOtBMvqHzDpF6irO9z98xDceosuGiQ=
golang.org/x/text v0.3.7/go.mod h1:u+2+/6zg+i71rQMx5EYifcz6MCKuco9NR6JIITiCfzQ=
golang.org/x/text v0.7.0/go.mod h1:mrYo+phRRbMaCq/xk9113O4dZlRixOauAjOtrjsXDZ8=
golang.org/x/text v0.23.0 h1:D71I7dUrlY+VX0gQShAThNGHFxZ13dGLBHQLVl1mJlY=
golang.org/x/text v0.23.0/go.mod h1:/BLNzu4aZCJ1+kcD0DNRotWKage4q2rGVAg4o22unh4=
golang.org/x/time v0.0.0-20190308202827-9d24e82272b4/go.mod h1:tRJNPiyCQ0inRvYxbN9jk5I+vvW/OXSQhTDSoE431IQ=
golang.org/x/time v0.3.0 h1:rg5rLMjNzMS1RkNLzCG38eapWhnYLFYXDXj2gOlr8j4=
golang.org/x/time v0.3.0/go.mod h1:tRJNPiyCQ0inRvYxbN9jk5I+vvW/OXSQhTDSoE431IQ=
golang.org/x/tools v0.0.0-20180221164845-07fd8470d635/go.mod h1:n7NCudcB/nEzxVGmLbDWY5pfWTLqBcC2KZ6jyYvM4mQ=
golang.org/x/tools v0.0.0-20180917221912-90fa682c2a6e/go.mod h1:n7NCudcB/nEzxVGmLbDWY5pfWTLqBcC2KZ6jyYvM4mQ=
golang.org/x/tools v0.0.0-20190114222345-bf090417da8b/go.mod h1:n7NCudcB/nEzxVGmLbDWY5pfWTLqBcC2KZ6jyYvM4mQ=
golang.org/x/tools v0.0.0-20190226205152-f727befe758c/go.mod h1:9Yl7xja0Znq3iFh3HoIrodX9oNMXvdceNzlUR8zjMvY=
golang.org/x/tools v0.0.0-20190311212946-11955173bddd/go.mod h1:LCzVGOaR6xXOjkQ3onu1FJEFr0SW1gC7cKk1uF8kGRs=
golang.org/x/tools v0.0.0-20190328211700-ab21143f2384/go.mod h1:LCzVGOaR6xXOjkQ3onu1FJEFr0SW1gC7cKk1uF8kGRs=
golang.org/x/tools v0.0.0-20191119224855-298f0cb1881e/go.mod h1:b+2E5dAYhXwXZwtnZ6UAqBI28+e2cm9otk0dWdXHAEo=
golang.org/x/tools v0.1.12/go.mod h1:hNGJHUnrk76NpqgfD5Aqm5Crs+Hm0VOH/i9J2+nxYbc=
golang.org/x/tools v0.21.1-0.20240508182429-e35e4ccd0d2d h1:vU5i/LfpvrRCpgM/VPfJLg5KjxD3E+hfT1SH+d9zLwg=
golang.org/x/tools v0.21.1-0.20240508182429-e35e4ccd0d2d/go.mod h1:aiJjzUbINMkxbQROHiO6hDPo2LHcIPhhQsa9DLh0yGk=
golang.org/x/xerrors v0.0.0-20190717185122-a985d3407aa7/go.mod h1:I/5z698sn9Ka8TeJc9MKroUUfqBBauWjQqLJ2OPfmY0=
golang.org/x/xerrors v0.0.0-20191204190536-9bdfabe68543/go.mod h1:I/5z698sn9Ka8TeJc9MKroUUfqBBauWjQqLJ2OPfmY0=
google.golang.org/appengine v1.1.0/go.mod h1:EbEs0AVv82hx2wNQdGPgUI5lhzA/G0D9YwlJXL52JkM=
google.golang.org/appengine v1.4.0/go.mod h1:xpcJRLb0r/rnEns0DIKYYv+WjYCduHsrkT7/EB5XEv4=
google.golang.org/genproto v0.0.0-20180817151627-c66870c02cf8/go.mod h1:JiN7NxoALGmiZfu7CAH4rXhgtRTLTxftemlI0sWmxmc=
google.golang.org/genproto v0.0.0-20190425155659-357c62f0e4bb/go.mod h1:VzzqZJRnGkLBvHegQrXjBqPurQTc5/KpmUdxsrq26oE=
google.golang.org/grpc v1.19.0/go.mod h1:mqu4LbDTu4XGKhr4mRzUsmM4RtVoemTSY81AxZiDr8c=
google.golang.org/grpc v1.20.1/go.mod h1:10oTOabMzJvdu6/UiuZezV6QK5dSlG84ov/aaiqXj38=
google.golang.org/grpc v1.21.0/go.mod h1:oYelfM1adQP15Ek0mdvEgi9Df8B9CZIaU1084ijfRaM=
gopkg.in/alecthomas/kingpin.v2 v2.2.6/go.mod h1:FMv+mEhP44yOT+4EoQTLFTRgOQ1FBLkstjWtayDeSgw=
gopkg.in/alexcesaro/quotedprintable.v3 v3.0.0-20150716171945-2caba252f4dc h1:2gGKlE2+asNV9m7xrywl36YYNnBG5ZQ0r/BOOxqPpmk=
gopkg.in/alexcesaro/quotedprintable.v3 v3.0.0-20150716171945-2caba252f4dc/go.mod h1:m7x9LTH6d71AHyAX77c9yqWCCa3UKHcVEj9y7hAtKDk=
gopkg.in/check.v1 v0.0.0-20161208181325-20d25e280405/go.mod h1:Co6ibVJAznAaIkqp8huTwlJQCZ016jof/cbN4VW5Yz0=
gopkg.in/check.v1 v1.0.0-20180628173108-788fd7840127/go.mod h1:Co6ibVJAznAaIkqp8huTwlJQCZ016jof/cbN4VW5Yz0=
gopkg.in/check.v1 v1.0.0-20201130134442-10cb98267c6c h1:Hei/4ADfdWqJk1ZMxUNpqntNwaWcugrBjAiHlqqRiVk=
gopkg.in/check.v1 v1.0.0-20201130134442-10cb98267c6c/go.mod h1:JHkPIbrfpd72SG/EVd6muEfDQjcINNoR0C8j2r3qZ4Q=
gopkg.in/gomail.v2 v2.0.0-20160411212932-81ebce5c23df h1:n7WqCuqOuCbNr617RXOY0AWRXxgwEyPp2z+p0+hgMuE=
gopkg.in/gomail.v2 v2.0.0-20160411212932-81ebce5c23df/go.mod h1:LRQQ+SO6ZHR7tOkpBDuZnXENFzX8qRjMDMyPD6BRkCw=
gopkg.in/ini.v1 v1.51.0 h1:AQvPpx3LzTDM0AjnIRlVFwFFGC+npRopjZxLJj6gdno=
gopkg.in/ini.v1 v1.51.0/go.mod h1:pNLf8WUiyNEtQjuu5G5vTm06TEv9tsIgeAvK8hOrP4k=
gopkg.in/natefinch/lumberjack.v2 v2.0.0 h1:1Lc07Kr7qY4U2YPouBjpCLxpiyxIVoxqXgkXLknAOE8=
gopkg.in/natefinch/lumberjack.v2 v2.0.0/go.mod h1:l0ndWWf7gzL7RNwBG7wST/UCcT4T24xpD6X8LsfU/+k=
gopkg.in/resty.v1 v1.12.0/go.mod h1:mDo4pnntr5jdWRML875a/NmxYqAlA73dVijT2AXvQQo=
gopkg.in/yaml.v2 v2.0.0-20170812160011-eb3733d160e7/go.mod h1:JAlM8MvJe8wmxCU4Bli9HhUf9+ttbYbLASfIpnQbh74=
gopkg.in/yaml.v2 v2.2.1/go.mod h1:hI93XBmqTisBFMUTm0b8Fm+jr3Dg1NNxqwp+5A1VGuI=
gopkg.in/yaml.v2 v2.2.2/go.mod h1:hI93XBmqTisBFMUTm0b8Fm+jr3Dg1NNxqwp+5A1VGuI=
gopkg.in/yaml.v2 v2.2.4/go.mod h1:hI93XBmqTisBFMUTm0b8Fm+jr3Dg1NNxqwp+5A1VGuI=
gopkg.in/yaml.v2 v2.3.0 h1:clyUAQHOM3G0M3f5vQj7LuJrETvjVot3Z5el9nffUtU=
gopkg.in/yaml.v2 v2.3.0/go.mod h1:hI93XBmqTisBFMUTm0b8Fm+jr3Dg1NNxqwp+5A1VGuI=
gopkg.in/yaml.v3 v3.0.0-20200313102051-9f266ea9e77c/go.mod h1:K4uyk7z7BCEPqu6E+C64Yfv1cQ7kz7rIZviUmN+EgEM=
gopkg.in/yaml.v3 v3.0.1 h1:fxVm/GzAzEWqLHuvctI91KS9hhNmmWOoWu0XTYJS7CA=
gopkg.in/yaml.v3 v3.0.1/go.mod h1:K4uyk7z7BCEPqu6E+C64Yfv1cQ7kz7rIZviUmN+EgEM=
honnef.co/go/tools v0.0.0-20190102054323-c2f93a96b099/go.mod h1:rf3lG4BRIbNafJWhAfAdb/ePZxsR/4RtNHQocxwk9r4=
honnef.co/go/tools v0.3.2 h1:ytYb4rOqyp1TSa2EPvNVwtPQJctSELKaMyLfqNP4+34=
honnef.co/go/tools v0.3.2/go.mod h1:jzwdWgg7Jdq75wlfblQxO4neNaFFSvgc1tD5Wv8U0Yw=
www.velocidex.com/golang/go-ntfs v0.2.1-0.20240818145200-04736de821dc h1:eeL+RUEGr6/lYL8hJEbvugrF88I6W4pBaVtFa1falj4=
www.velocidex.com/golang/go-ntfs v0.2.1-0.20240818145200-04736de821dc/go.mod h1:itvbHQcnLdTVIDY6fI3lR0zeBwXwBYBdUFtswE0x1vc=

```

`internal/bootstrap/bootstrap.go`:

```go
/*
 * Copyright 2021-2022 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package bootstrap

import (
	"context"
	"errors"
	"github.com/rabbitstack/fibratus/internal/evasion"
	"github.com/rabbitstack/fibratus/pkg/aggregator"
	"github.com/rabbitstack/fibratus/pkg/alertsender"
	"github.com/rabbitstack/fibratus/pkg/api"
	"github.com/rabbitstack/fibratus/pkg/cap"
	"github.com/rabbitstack/fibratus/pkg/config"
	"github.com/rabbitstack/fibratus/pkg/filament"
	"github.com/rabbitstack/fibratus/pkg/filter"
	"github.com/rabbitstack/fibratus/pkg/handle"
	"github.com/rabbitstack/fibratus/pkg/ps"
	"github.com/rabbitstack/fibratus/pkg/rules"
	"github.com/rabbitstack/fibratus/pkg/symbolize"
	"github.com/rabbitstack/fibratus/pkg/sys"
	"github.com/rabbitstack/fibratus/pkg/util/multierror"
	"github.com/rabbitstack/fibratus/pkg/util/signals"
	"github.com/rabbitstack/fibratus/pkg/util/version"
	"github.com/rabbitstack/fibratus/pkg/yara"
	log "github.com/sirupsen/logrus"
	"golang.org/x/sys/windows"
	"os"
)

// ErrAlreadyRunning signals a Fibratus process is already running in the system
var ErrAlreadyRunning = errors.New("an instance of Fibratus process is already running in the system")

// App centralizes the core building blocks responsible
// for event acquisition, rule engine initialization,
// captures handling, filament execution and event routing
// to the output sinks.
type App struct {
	config     *config.Config
	evs        *EventSourceControl
	symbolizer *symbolize.Symbolizer
	engine     *rules.Engine
	hsnap      handle.Snapshotter
	psnap      ps.Snapshotter
	filament   filament.Filament
	agg        *aggregator.BufferedAggregator
	writer     cap.Writer
	reader     cap.Reader
	signals    chan struct{}
}

// Option enables changing the behaviour of the bootstrap application.
type Option func(*opts)

type opts struct {
	setDebugPrivilege bool
	installSignals    bool
	isCaptureReplay   bool
	handleSnapshotFn  handle.SnapshotBuildCompleted
}

// WithSignals installs signal handlers.
func WithSignals() Option {
	return func(o *opts) {
		o.installSignals = true
	}
}

// WithDebugPrivilege injects the SeDebugPrivilege in the process access token.
func WithDebugPrivilege() Option {
	return func(o *opts) {
		o.setDebugPrivilege = true
	}
}

// WithCaptureReplay denotes the capture file is being replayed.
func WithCaptureReplay() Option {
	return func(o *opts) {
		o.isCaptureReplay = true
	}
}

// WithHandleSnapshotFn sets the handle snapshotter completion function.
func WithHandleSnapshotFn(fn handle.SnapshotBuildCompleted) Option {
	return func(o *opts) {
		o.handleSnapshotFn = fn
	}
}

// NewApp constructs a new bootstrap application with the specified configuration
// and a list of options. The configuration is passed from individual command work
// functions.
func NewApp(cfg *config.Config, options ...Option) (*App, error) {
	if err := InitConfigAndLogger(cfg); err != nil {
		return nil, err
	}
	var opts opts
	var sigs chan struct{}
	for _, opt := range options {
		opt(&opts)
	}
	if cfg.DebugPrivilege && opts.setDebugPrivilege {
		sys.SetDebugPrivilege()
	}
	if opts.installSignals {
		sigs = signals.Install()
	}
	if opts.isCaptureReplay {
		reader, err := cap.NewReader(cfg.CapFile, cfg)
		if err != nil {
			return nil, err
		}
		app := &App{
			config:  cfg,
			reader:  reader,
			signals: sigs,
		}
		return app, nil
	}

	hsnap := handle.NewSnapshotter(cfg, opts.handleSnapshotFn)
	psnap := ps.NewSnapshotter(hsnap, cfg)

	var engine *rules.Engine
	var rs *config.RulesCompileResult

	if cfg.Filters.Rules.Enabled && !cfg.ForwardMode && !cfg.IsCaptureSet() && !cfg.IsFilamentSet() {
		engine = rules.NewEngine(psnap, cfg)
		var err error
		rs, err = engine.Compile()
		if err != nil {
			return nil, err
		}
		if rs != nil {
			log.Infof("rules compile summary: %s", rs)
		}
	} else {
		log.Info("rule engine is disabled")
	}

	evs := NewEventSourceControl(psnap, hsnap, cfg, rs)

	app := &App{
		config:  cfg,
		evs:     evs,
		engine:  engine,
		hsnap:   hsnap,
		psnap:   psnap,
		signals: sigs,
	}

	return app, nil
}

// Run configure and opens the event source to start consuming events.
// Depending on whether the filament is provided, this method will either
// spin up a filament or set up the aggregator to start forwarding events
// to the rule engine and output sinks.
func (f *App) Run(args []string) error {
	if f.evs == nil {
		panic("event source is nil")
	}
	cfg := f.config

	if !f.isSingleInstance() {
		return ErrAlreadyRunning
	}

	log.Infof("bootstrapping with pid %d. Version: %s", os.Getpid(), version.Get())
	log.Infof("configuration options: %s", cfg.Print())

	// build the filter from the CLI argument. If we got
	// a valid expression the filter is attached to the
	// event consumer
	fltr, err := filter.NewFromCLI(args, cfg)
	if err != nil {
		return err
	}
	if fltr != nil {
		f.evs.SetFilter(fltr)
	}
	// user can either instruct to bootstrap a filament or
	// start a regular run. We'll set up the corresponding
	// components accordingly to what we got from the CLI options.
	// If a filament was given, we'll assign it the previous filter
	// if it wasn't provided in the filament init function.
	// Finally, we open the event source and run the filament i.e.
	// Python main thread in a new goroutine.
	// In case of a regular run, we additionally set up the aggregator.
	// The aggregator will grab the events from the queue, assemble them
	// into batches and hand over to output sinks.
	if cfg.IsFilamentSet() {
		f.filament, err = filament.New(cfg.Filament.Name, f.psnap, f.hsnap, cfg)
		if err != nil {
			return err
		}
		if f.filament.Filter() != nil {
			f.evs.SetFilter(f.filament.Filter())
		}
		err = f.evs.Open(cfg)
		if err != nil {
			return multierror.Wrap(err, f.evs.Close())
		}
		// load alert senders so emitting alerts is possible from filaments
		err = alertsender.LoadAll(cfg.Alertsenders)
		if err != nil {
			log.Warnf("couldn't load alertsenders: %v", err)
		}
		go func() {
			err = f.filament.Run(f.evs.Events(), f.evs.Errors())
			if err != nil {
				log.Errorf("filament failed: %v", err)
				f.stop()
			}
		}()
	} else {
		// register stack symbolizer
		if cfg.EventSource.StackEnrichment {
			f.symbolizer = symbolize.NewSymbolizer(symbolize.NewDebugHelpResolver(cfg), f.psnap, cfg, false)
			f.evs.RegisterEventListener(f.symbolizer)
		}
		// register evasion scanner
		if cfg.Evasion.Enabled {
			f.evs.RegisterEventListener(evasion.NewScanner(cfg.Evasion))
		}
		// register rule engine
		if f.engine != nil {
			f.evs.RegisterEventListener(f.engine)
		}
		// register YARA scanner
		if cfg.Yara.Enabled {
			scanner, err := yara.NewScanner(f.psnap, cfg.Yara)
			if err != nil {
				return err
			}
			f.evs.RegisterEventListener(scanner)
		}
		err = f.evs.Open(cfg)
		if err != nil {
			return multierror.Wrap(err, f.evs.Close())
		}
		// set up the aggregator that forwards events to outputs
		f.agg, err = aggregator.NewBuffered(
			f.evs.Events(),
			f.evs.Errors(),
			cfg.Aggregator,
			cfg.Output,
			cfg.Transformers,
			cfg.Alertsenders,
		)
		if err != nil {
			return err
		}
	}
	// start the HTTP server
	return api.StartServer(cfg)
}

// WriteCapture writes the event stream to the capture file.
func (f *App) WriteCapture(args []string) error {
	if f.evs == nil {
		panic("event source is nil")
	}

	if !f.isSingleInstance() {
		return ErrAlreadyRunning
	}

	fltr, err := filter.NewFromCLI(args, f.config)
	if err != nil {
		return err
	}
	if fltr != nil {
		f.evs.SetFilter(fltr)
	}
	err = f.evs.Open(f.config)
	if err != nil {
		return err
	}
	f.writer, err = cap.NewWriter(f.config.CapFile, f.psnap, f.hsnap)
	if err != nil {
		return err
	}
	errsChan := f.writer.Write(f.evs.Events(), f.evs.Errors())
	go func() {
		for err := range errsChan {
			log.Warnf("fail to write event to capture: %v", err)
		}
	}()
	return api.StartServer(f.config)
}

// ReadCapture reconstructs the event stream from the capture file.
func (f *App) ReadCapture(ctx context.Context, args []string) error {
	if f.reader == nil {
		panic("reader is nil")
	}
	fltr, err := filter.NewFromCLIWithAllAccessors(args)
	if err != nil {
		return err
	}
	f.hsnap, f.psnap, err = f.reader.RecoverSnapshotters()
	if err != nil {
		return err
	}

	if f.config.IsFilamentSet() {
		f.filament, err = filament.New(f.config.Filament.Name, f.psnap, f.hsnap, f.config)
		if err != nil {
			return err
		}
		if f.filament.Filter() != nil {
			// filament filter overrides CLI filter
			f.reader.SetFilter(f.filament.Filter())
		} else if fltr != nil {
			f.reader.SetFilter(fltr)
		}
		// returns the channel where events are read from the cap
		evts, errs := f.reader.Read(ctx)
		go func() {
			defer f.filament.Close()
			err = f.filament.Run(evts, errs)
			if err != nil {
				log.Errorf("filament failed: %v", err)
				f.stop()
			}
		}()
	} else {
		if fltr != nil {
			f.reader.SetFilter(fltr)
		}
		// use the channels where events are read
		// from the capture as aggregator source
		evts, errs := f.reader.Read(ctx)
		f.agg, err = aggregator.NewBuffered(
			evts,
			errs,
			f.config.Aggregator,
			f.config.Output,
			f.config.Transformers,
			f.config.Alertsenders,
		)
		if err != nil {
			return err
		}
	}

	return api.StartServer(f.config)
}

// Wait waits for the app to receive the termination signal.
func (f *App) Wait() {
	if f.signals != nil {
		<-f.signals
	}
}

// Shutdown is responsible for tearing down everything gracefully.
func (f *App) Shutdown() error {
	errs := make([]error, 0)
	if f.symbolizer != nil {
		f.symbolizer.Close()
	}
	if f.evs != nil {
		if err := f.evs.Close(); err != nil {
			errs = append(errs, err)
		}
	}
	if f.hsnap != nil {
		if err := f.hsnap.Close(); err != nil {
			errs = append(errs, err)
		}
	}
	if f.psnap != nil {
		if err := f.psnap.Close(); err != nil {
			errs = append(errs, err)
		}
	}
	if f.filament != nil {
		if err := f.filament.Close(); err != nil {
			errs = append(errs, err)
		}
	}
	if f.writer != nil {
		if err := f.writer.Close(); err != nil {
			errs = append(errs, err)
		}
	}
	if f.reader != nil {
		if err := f.reader.Close(); err != nil {
			errs = append(errs, err)
		}
	}
	if f.agg != nil {
		if err := f.agg.Stop(); err != nil {
			errs = append(errs, err)
		}
	}
	if err := handle.CloseTimeout(); err != nil {
		errs = append(errs, err)
	}
	if err := api.CloseServer(); err != nil {
		errs = append(errs, err)
	}
	if err := alertsender.ShutdownAll(); err != nil {
		errs = append(errs, err)
	}
	return multierror.Wrap(errs...)
}

func (f *App) stop() {
	if f.signals != nil {
		f.signals <- struct{}{}
	}
}

// isSingleInstance checks if there is a single instance
// of the Fibratus process running in the system. This is
// accomplished by creating a global event object. If such
// an object already exists, we can conclude Fibratus process
// is already running.
func (f *App) isSingleInstance() bool {
	name, err := windows.UTF16PtrFromString("Global\\Fibratus")
	if err != nil {
		return false
	}
	event, err := windows.CreateEvent(nil, 0, 0, name)
	return event != 0 && !errors.Is(err, windows.ERROR_ALREADY_EXISTS)
}

```

`internal/bootstrap/config.go`:

```go
/*
 * Copyright 2021-2022 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package bootstrap

import (
	"github.com/rabbitstack/fibratus/pkg/config"
	"github.com/rabbitstack/fibratus/pkg/util/log"
	"github.com/sirupsen/logrus"
	"os"
)

// InitConfigAndLogger initializes the configuration and sets up the logger.
// We allow continuing with the initialization process even if the config file
// loading fails. In this situation, the default config flag values are used
// to tweak any of the internal behaviours.
func InitConfigAndLogger(cfg *config.Config) error {
	err := cfg.TryLoadFile(cfg.File())
	notExists := os.IsNotExist(err)
	if err != nil && !notExists {
		return err
	}
	if err := cfg.Init(); err != nil {
		return err
	}
	if err == nil {
		if err := cfg.Validate(); err != nil {
			return err
		}
	}
	if err := log.InitFromConfig(cfg.Log, "fibratus.log"); err != nil {
		return err
	}
	if notExists {
		logrus.Infof("configuration file "+
			"%s not found. Continuing with default "+
			"settings...", cfg.File())
	}
	return nil
}

```

`internal/bootstrap/source.go`:

```go
/*
 * Copyright 2021-2022 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package bootstrap

import (
	"github.com/rabbitstack/fibratus/internal/etw"
	"github.com/rabbitstack/fibratus/pkg/config"
	"github.com/rabbitstack/fibratus/pkg/event"
	"github.com/rabbitstack/fibratus/pkg/filter"
	"github.com/rabbitstack/fibratus/pkg/handle"
	"github.com/rabbitstack/fibratus/pkg/ps"
	"github.com/rabbitstack/fibratus/pkg/source"
)

// EventSourceControl abstracts away the management of event sources.
// Presently, system events are captured by ETW infra, in the future
// additional instrumentation engines can be introduced and the event
// source will automatically decide which is the best engine to operate
// with. As an example, eBPF instrumentation may gain traction in the
// future, and the systems that support eBPF can provide a richer spectrum
// of telemetry than the ETW subsystem. In this scenario, the event source
// control will bootstrap the instrumentation engine based on eBPF.
type EventSourceControl struct {
	evs source.EventSource
}

func NewEventSourceControl(
	psnap ps.Snapshotter,
	hsnap handle.Snapshotter,
	config *config.Config,
	compiler *config.RulesCompileResult,
) *EventSourceControl {
	return &EventSourceControl{evs: etw.NewEventSource(psnap, hsnap, config, compiler)}
}

func (s *EventSourceControl) Open(config *config.Config) error {
	return s.evs.Open(config)
}

func (s *EventSourceControl) Close() error {
	return s.evs.Close()
}

func (s *EventSourceControl) Errors() <-chan error {
	return s.evs.Errors()
}

func (s *EventSourceControl) Events() <-chan *event.Event {
	return s.evs.Events()
}

func (s *EventSourceControl) SetFilter(f filter.Filter) {
	s.evs.SetFilter(f)
}

func (s *EventSourceControl) RegisterEventListener(lis event.Listener) {
	s.evs.RegisterEventListener(lis)
}

```

`internal/etw/_fixtures/Taskfile.yml`:

```yml
version: '3'

vars:
  SYSWHISPERS3_REPO: https://github.com/klezVirus/SysWhispers3.git
  VISUAL_STUDIO_EDITION: Enterprise
  VISUAL_STUDIO_VERSION: 2022

tasks:
  direct-syscall:
    desc: Builds the binary to perform direct syscalls via Syswhispers generated stubs
    dir: direct-syscall
    cmds:
      - git clone {{ .SYSWHISPERS3_REPO }}
      - python SysWhispers3/syswhispers.py -a x64 -c msvc -p common -o syscalls
      - cmd.exe /c 'C:\"Program Files"\"Microsoft Visual Studio"\{{ .VISUAL_STUDIO_VERSION }}\{{ .VISUAL_STUDIO_EDITION }}\VC\Auxiliary\Build\vcvars64.bat && nmake -f Makefile.msvc'
    silent: true

  indirect-syscall:
    desc: Builds the binary to perform indirect syscalls via Syswhispers generated stubs
    dir: indirect-syscall
    cmds:
      - git clone {{ .SYSWHISPERS3_REPO }}
      - python SysWhispers3/syswhispers.py -a x64 -c msvc -p common -m jumper_randomized -o syscalls
      - cmd.exe /c 'C:\"Program Files"\"Microsoft Visual Studio"\{{ .VISUAL_STUDIO_VERSION }}\{{ .VISUAL_STUDIO_EDITION }}\VC\Auxiliary\Build\vcvars64.bat && nmake -f Makefile.msvc'
    silent: true

  all:
    deps:
      - direct-syscall
      - indirect-syscall

```

`internal/etw/_fixtures/direct-syscall/Makefile.msvc`:

```msvc
OPTIONS = -Zp8 -c -nologo -Gy -Os -O1 -GR- -EHa -Oi -GS-
LIBS = libvcruntime.lib libcmt.lib ucrt.lib kernel32.lib

main:
  ML64 /c syscalls-asm.x64.asm /link /NODEFAULTLIB /RELEASE /MACHINE:X64
  cl.exe $(OPTIONS) syscalls.c main.c
  link.exe /OUT:direct-syscall.exe -nologo $(LIBS) /MACHINE:X64 -subsystem:console -nodefaultlib syscalls-asm.x64.obj syscalls.obj main.obj

```

`internal/etw/_fixtures/direct-syscall/main.c`:

```c
#include "syscalls.h"

#include <Windows.h>

int main(int argc, char* argv[])
{
    Sw3NtSetContextThread(-1, NULL);
    return 0;
}

```

`internal/etw/_fixtures/indirect-syscall/Makefile.msvc`:

```msvc
OPTIONS = -Zp8 -c -nologo -Gy -Os -O1 -GR- -EHa -Oi -GS-
LIBS = libvcruntime.lib libcmt.lib ucrt.lib kernel32.lib

main:
  ML64 /c syscalls-asm.x64.asm /link /NODEFAULTLIB /RELEASE /MACHINE:X64
  cl.exe $(OPTIONS) syscalls.c main.c
  link.exe /OUT:indirect-syscall.exe -nologo $(LIBS) /MACHINE:X64 -subsystem:console -nodefaultlib syscalls-asm.x64.obj syscalls.obj main.obj

```

`internal/etw/_fixtures/indirect-syscall/main.c`:

```c
#include "syscalls.h"

#include <Windows.h>

int main(int argc, char* argv[])
{
    Sw3NtSetContextThread(-1, NULL);
    return 0;
}

```

`internal/etw/consumer.go`:

```go
/*
 * Copyright 2021-2022 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package etw

import (
	"github.com/rabbitstack/fibratus/internal/etw/processors"
	"github.com/rabbitstack/fibratus/pkg/config"
	"github.com/rabbitstack/fibratus/pkg/event"
	"github.com/rabbitstack/fibratus/pkg/filter"
	"github.com/rabbitstack/fibratus/pkg/ps"
	"github.com/rabbitstack/fibratus/pkg/sys/etw"
)

// Consumer is the core component in the event processing pipeline.
// The raw event is offloaded from the session buffer, then parsed
// and converted to typed representation with process state attached
// to it. The event consumer is responsible for enriching the event
// with additional attributes. The event is sent to the queue where
// all registered listeners are executed.
type Consumer struct {
	q          *event.Queue
	sequencer  *event.Sequencer
	processors processors.Chain
	psnap      ps.Snapshotter
	config     *config.Config
	filter     filter.Filter
	isClosing  bool
}

// NewConsumer builds a new event consumer.
func NewConsumer(
	psnap ps.Snapshotter,
	config *config.Config,
	sequencer *event.Sequencer,
	evts chan *event.Event,
	processors processors.Chain,
) *Consumer {
	return &Consumer{
		q:          event.NewQueueWithChannel(evts, config.EventSource.StackEnrichment, config.ForwardMode || config.IsCaptureSet()),
		sequencer:  sequencer,
		processors: processors,
		psnap:      psnap,
		config:     config,
	}
}

func (c *Consumer) SetFilter(f filter.Filter) {
	c.filter = f
}

func (c *Consumer) Close() error {
	c.isClosing = true
	return c.processors.Close()
}

func (c *Consumer) ProcessEvent(ev *etw.EventRecord) error {
	if c.isClosing {
		return nil
	}

	if !c.config.EventSource.EventExists(ev.ID()) {
		eventsUnknown.Add(1)
		return nil
	}
	if event.IsCurrentProcDropped(ev.Header.ProcessID) && ev.Header.ProviderID != etw.WindowsKernelProcessGUID {
		return nil
	}
	if c.config.EventSource.ExcludeEvent(ev.ID()) {
		eventsExcluded.Add(1)
		return nil
	}

	eventsProcessed.Add(1)
	evt := event.New(c.sequencer.Get(), ev)

	// Dispatch each event to the processor chain.
	// Processors may further augment the event with
	// useful fields or play the role of state managers.
	// Scanning open files and registry control blocks
	// at the beginning of the kernel trace session is an
	// example of state management
	var err error
	evt, err = c.processors.ProcessEvent(evt)
	if err != nil {
		return err
	}
	if evt.WaitEnqueue {
		return nil
	}
	ok, proc := c.psnap.Find(evt.PID)
	if !ok {
		c.psnap.Put(proc)
	}

	// Associate process' state with the event.
	// We only override the process' state if it hasn't
	// been set previously such as in the situation where
	// captures are being taken. Events that construct
	// the process' snapshot also have attached process
	// state, so simply by replaying the flow of these
	// events we are able to reconstruct system-wide
	// process state.
	if evt.PS == nil {
		evt.PS = proc
	}
	// Drop any events if it is originated by the
	// current process, state event, or if the
	// process image is in the exclusion list.
	// Stack walk events are forwarded to the
	// event queue for stack enrichment. Lastly,
	// the filter is evaluated on the event to
	// decide whether it should get dropped
	if (evt.IsDropped(c.config.IsCaptureSet()) ||
		c.config.EventSource.ExcludeImage(evt.PS)) && !evt.IsStackWalk() {
		eventsExcluded.Add(1)
		return nil
	}
	if c.filter != nil && !evt.IsStackWalk() && !c.filter.Run(evt) {
		return nil
	}
	// Increment sequence
	if !evt.IsState() {
		c.sequencer.Increment()
	}

	return c.q.Push(evt)
}

```

`internal/etw/processors/chain.go`:

```go
/*
 * Copyright 2019-2020 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package processors

import (
	"expvar"
	"fmt"
	"github.com/rabbitstack/fibratus/pkg/event"
	"github.com/rabbitstack/fibratus/pkg/util/multierror"
)

// processorFailures counts the number of failures caused by event processors
var processorFailures = expvar.NewInt("event.processor.failures")

// Chain defines the event process chain has to satisfy.
type Chain interface {
	// ProcessEvent pushes the event into processor chain. Processors are applied sequentially, so we have to make
	// sure that any processor providing additional context to the next processor is defined first in the chain. If
	// one processor fails, the next processor in chain is invoked.
	ProcessEvent(evt *event.Event) (*event.Event, error)
	// Close closes the processor chain and frees all allocated resources.
	Close() error
}

func (c *chain) addProcessor(processor Processor) {
	if processor == nil {
		return
	}
	c.processors = append(c.processors, processor)
}

func (c chain) ProcessEvent(e *event.Event) (*event.Event, error) {
	var errs = make([]error, 0)
	var evt *event.Event

	for _, processor := range c.processors {
		var err error
		var next bool
		evt, next, err = processor.ProcessEvent(e)
		if err != nil {
			processorFailures.Add(1)
			errs = append(errs, fmt.Errorf("%q processor failed with error: %v", processor.Name(), err))
			continue
		}
		if !next {
			break
		}
	}
	if len(errs) > 0 {
		return evt, multierror.Wrap(errs...)
	}

	return evt, nil
}

// Close closes the processor chain and frees all allocated resources.
func (c chain) Close() error {
	for _, processor := range c.processors {
		processor.Close()
	}
	return nil
}

```

`internal/etw/processors/chain_windows.go`:

```go
/*
 * Copyright 2020-2021 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package processors

import (
	"github.com/rabbitstack/fibratus/pkg/config"
	"github.com/rabbitstack/fibratus/pkg/fs"
	"github.com/rabbitstack/fibratus/pkg/handle"
	"github.com/rabbitstack/fibratus/pkg/ps"
	"github.com/rabbitstack/fibratus/pkg/util/va"
)

type chain struct {
	processors   []Processor
	psnapshotter ps.Snapshotter
}

// NewChain constructs the processor chain. It arranges all the processors
// according to enabled kernel event categories.
func NewChain(
	psnap ps.Snapshotter,
	hsnap handle.Snapshotter,
	config *config.Config,
) Chain {
	var (
		chain = &chain{
			psnapshotter: psnap,
			processors:   make([]Processor, 0),
		}
		devMapper       = fs.NewDevMapper()
		devPathResolver = fs.NewDevPathResolver()
		vaRegionProber  = va.NewRegionProber()
	)

	chain.addProcessor(newPsProcessor(psnap, vaRegionProber))

	if config.EventSource.EnableFileIOEvents {
		chain.addProcessor(newFsProcessor(hsnap, psnap, devMapper, devPathResolver, config))
	}
	if config.EventSource.EnableRegistryEvents {
		chain.addProcessor(newRegistryProcessor(hsnap))
	}
	if config.EventSource.EnableImageEvents {
		chain.addProcessor(newImageProcessor(psnap))
	}
	if config.EventSource.EnableNetEvents {
		chain.addProcessor(newNetProcessor())
	}
	if config.EventSource.EnableHandleEvents {
		chain.addProcessor(newHandleProcessor(hsnap, psnap, devMapper, devPathResolver))
	}
	if config.EventSource.EnableMemEvents {
		chain.addProcessor(newMemProcessor(psnap, vaRegionProber))
	}

	return chain
}

```

`internal/etw/processors/fs_windows.go`:

```go
/*
 * Copyright 2019-2020 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package processors

import (
	"expvar"
	"sync"
	"time"

	"github.com/rabbitstack/fibratus/pkg/config"
	"github.com/rabbitstack/fibratus/pkg/event"
	"github.com/rabbitstack/fibratus/pkg/event/params"
	"github.com/rabbitstack/fibratus/pkg/fs"
	"github.com/rabbitstack/fibratus/pkg/handle"
	htypes "github.com/rabbitstack/fibratus/pkg/handle/types"
	"github.com/rabbitstack/fibratus/pkg/ps"
	"github.com/rabbitstack/fibratus/pkg/sys"
	"github.com/rabbitstack/fibratus/pkg/util/va"
	"golang.org/x/sys/windows"
	"golang.org/x/time/rate"
)

var (
	// totalRundownFiles counts the number of opened files
	totalRundownFiles    = expvar.NewInt("fs.total.rundown.files")
	totalMapRundownFiles = expvar.NewInt("fs.total.map.rundown.files")
	// fileObjectMisses computes file object cache misses
	fileObjectMisses     = expvar.NewInt("fs.file.objects.misses")
	fileObjectHandleHits = expvar.NewInt("fs.file.object.handle.hits")
	fileReleaseCount     = expvar.NewInt("fs.file.releases")

	fsFileCharacteristicsRateLimits = expvar.NewInt("fs.file.characteristics.rate.limits")
)

type fsProcessor struct {
	// files stores the file metadata indexed by file object
	files map[uint64]*FileInfo

	hsnap handle.Snapshotter
	psnap ps.Snapshotter

	// irps contains a mapping between the IRP (I/O request packet) and CreateFile events
	irps map[uint64]*event.Event

	devMapper       fs.DevMapper
	devPathResolver fs.DevPathResolver
	config          *config.Config

	// buckets stores stack walk events per stack id
	buckets map[uint64][]*event.Event
	mu      sync.Mutex
	purger  *time.Ticker

	quit chan struct{}
	// lim throttles the parsing of image characteristics
	lim *rate.Limiter
}

// FileInfo stores file information obtained from event state.
type FileInfo struct {
	Name string
	Type fs.FileType
}

func newFsProcessor(
	hsnap handle.Snapshotter,
	psnap ps.Snapshotter,
	devMapper fs.DevMapper,
	devPathResolver fs.DevPathResolver,
	config *config.Config,
) Processor {
	f := &fsProcessor{
		files:           make(map[uint64]*FileInfo),
		irps:            make(map[uint64]*event.Event),
		hsnap:           hsnap,
		psnap:           psnap,
		devMapper:       devMapper,
		devPathResolver: devPathResolver,
		config:          config,
		buckets:         make(map[uint64][]*event.Event),
		purger:          time.NewTicker(time.Second * 5),
		quit:            make(chan struct{}, 1),
		lim:             rate.NewLimiter(30, 40), // allow 30 parse ops per second or bursts of 40 ops
	}

	go f.purge()

	return f
}

func (f *fsProcessor) ProcessEvent(e *event.Event) (*event.Event, bool, error) {
	if e.Category == event.File || e.IsStackWalk() {
		evt, err := f.processEvent(e)
		return evt, false, err
	}
	return e, true, nil
}

func (*fsProcessor) Name() ProcessorType { return Fs }
func (f *fsProcessor) Close()            { f.quit <- struct{}{} }

func (f *fsProcessor) getFileInfo(name string, opts uint32) *FileInfo {
	return &FileInfo{Name: name, Type: fs.GetFileType(name, opts)}
}

func (f *fsProcessor) processEvent(e *event.Event) (*event.Event, error) {
	switch e.Type {
	case event.FileRundown:
		// when the file rundown event comes in we store the file info
		// in internal state in order to augment the rest of file events
		// that lack the file path field
		filepath := e.GetParamAsString(params.FilePath)
		fileObject, err := e.Params.GetUint64(params.FileObject)
		if err != nil {
			return nil, err
		}
		if _, ok := f.files[fileObject]; !ok {
			totalRundownFiles.Add(1)
			f.files[fileObject] = &FileInfo{Name: filepath, Type: fs.GetFileType(filepath, 0)}
		}
	case event.MapFileRundown:
		fileKey := e.Params.MustGetUint64(params.FileKey)
		fileinfo := f.files[fileKey]

		if fileinfo != nil {
			totalMapRundownFiles.Add(1)
			e.AppendParam(params.FilePath, params.Path, fileinfo.Name)
		} else {
			// if the view of section is backed by the data/image file
			// try to get the mapped file name and append it to params
			sec := e.Params.MustGetUint32(params.FileViewSectionType)
			isMapped := sec != va.SectionPagefile && sec != va.SectionPhysical
			if isMapped {
				totalMapRundownFiles.Add(1)
				addr := e.Params.MustGetUint64(params.FileViewBase) + (e.Params.MustGetUint64(params.FileOffset))
				e.AppendParam(params.FilePath, params.Path, f.getMappedFile(e.PID, addr))
			}
		}

		return e, f.psnap.AddMmap(e)
	case event.CreateFile:
		// we defer the processing of the CreateFile event until we get
		// the matching FileOpEnd event. This event contains the operation
		// that was done on behalf of the file, e.g. create or open.
		irp := e.Params.MustGetUint64(params.FileIrpPtr)
		e.WaitEnqueue = true
		f.irps[irp] = e
	case event.StackWalk:
		if !event.IsCurrentProcDropped(e.PID) {
			f.mu.Lock()
			defer f.mu.Unlock()

			// append the event to the bucket indexed by stack id
			id := e.StackID()
			q, ok := f.buckets[id]
			if !ok {
				f.buckets[id] = []*event.Event{e}
			} else {
				f.buckets[id] = append(q, e)
			}
		}
	case event.FileOpEnd:
		// get the CreateFile pending event by IRP identifier
		// and fetch the file create disposition value
		var (
			irp    = e.Params.MustGetUint64(params.FileIrpPtr)
			dispo  = e.Params.MustGetUint64(params.FileExtraInfo)
			status = e.Params.MustGetUint32(params.NTStatus)
		)

		if dispo > windows.FILE_MAXIMUM_DISPOSITION {
			return e, nil
		}
		ev, ok := f.irps[irp]
		if !ok {
			return e, nil
		}
		delete(f.irps, irp)

		// reset the wait status to allow passage of this event to
		// the aggregator queue. Additionally, append params to it
		ev.WaitEnqueue = false
		fileObject := ev.Params.MustGetUint64(params.FileObject)

		// try to get extended file info. If the file object is already
		// present in the map, we'll reuse the existing file information
		fileinfo, ok := f.files[fileObject]
		if !ok {
			opts := ev.Params.MustGetUint32(params.FileCreateOptions)
			opts &= 0xFFFFFF
			filepath := ev.GetParamAsString(params.FilePath)
			fileinfo = f.getFileInfo(filepath, opts)
			f.files[fileObject] = fileinfo
		}

		if f.config.EventSource.EnableHandleEvents {
			f.devPathResolver.AddPath(ev.GetParamAsString(params.FilePath))
		}

		ev.AppendParam(params.NTStatus, params.Status, status)
		if fileinfo.Type != fs.Unknown {
			ev.AppendEnum(params.FileType, uint32(fileinfo.Type), fs.FileTypes)
		}
		ev.AppendEnum(params.FileOperation, uint32(dispo), fs.FileCreateDispositions)

		// attach stack walk return addresses. CreateFile events
		// represent an edge case in callstack enrichment. Since
		// the events are delayed until the respective FileOpEnd
		// event arrives, we enable stack tracing for CreateFile
		// events. When the CreateFile event is generated, we store
		// it in pending IRP map. Subsequently, the stack walk event
		// is put inside the queue. After FileOpEnd event arrives,
		// the previous stack walk for CreateFile is popped from
		// the queue and the callstack parameter attached to the
		// event.
		if f.config.EventSource.StackEnrichment {
			f.mu.Lock()
			defer f.mu.Unlock()

			id := ev.StackID()
			q, ok := f.buckets[id]
			if ok && len(q) > 0 {
				var s *event.Event
				s, f.buckets[id] = q[len(q)-1], q[:len(q)-1]
				callstack := s.Params.MustGetSlice(params.Callstack)
				ev.AppendParam(params.Callstack, params.Slice, callstack)
			}
		}

		// parse PE data for created files and append parameters
		if ev.IsCreateDisposition() && ev.IsSuccess() {
			if !f.lim.Allow() {
				fsFileCharacteristicsRateLimits.Add(1)
				return ev, nil
			}
			path := ev.GetParamAsString(params.FilePath)
			c, err := parseImageFileCharacteristics(path)
			if err != nil {
				return ev, nil
			}
			ev.AppendParam(params.FileIsDLL, params.Bool, c.isDLL)
			ev.AppendParam(params.FileIsDriver, params.Bool, c.isDriver)
			ev.AppendParam(params.FileIsExecutable, params.Bool, c.isExe)
			ev.AppendParam(params.FileIsDotnet, params.Bool, c.isDotnet)
		}

		return ev, nil
	case event.ReleaseFile:
		fileReleaseCount.Add(1)
		// delete file metadata by file object address
		fileObject := e.Params.MustGetUint64(params.FileObject)
		delete(f.files, fileObject)
	case event.UnmapViewFile:
		ok, proc := f.psnap.Find(e.PID)
		addr := e.Params.TryGetAddress(params.FileViewBase)
		if ok {
			mmap := proc.FindMmap(addr)
			if mmap != nil {
				e.AppendParam(params.FilePath, params.Path, mmap.File)
			}
		}

		totalMapRundownFiles.Add(-1)

		return e, f.psnap.RemoveMmap(e.PID, addr)
	default:
		var fileObject uint64
		fileKey := e.Params.MustGetUint64(params.FileKey)

		if !e.IsMapViewFile() {
			fileObject = e.Params.MustGetUint64(params.FileObject)
		}

		// attempt to get the file by file key. If there is no such file referenced
		// by the file key, then try to fetch it by file object. Even if file object
		// references fails, we search in the file handles for such file
		fileinfo := f.findFile(fileKey, fileObject)

		// try to resolve mapped file name if not found in internal state
		if fileinfo == nil && e.IsMapViewFile() {
			sec := e.Params.MustGetUint32(params.FileViewSectionType)
			isMapped := sec != va.SectionPagefile && sec != va.SectionPhysical
			if isMapped {
				totalMapRundownFiles.Add(1)
				addr := e.Params.MustGetUint64(params.FileViewBase) + (e.Params.MustGetUint64(params.FileOffset))
				e.AppendParam(params.FilePath, params.Path, f.getMappedFile(e.PID, addr))
			}
		}

		// ignore object misses that are produced by CloseFile
		if fileinfo == nil && !e.IsCloseFile() {
			fileObjectMisses.Add(1)
		}

		if e.IsDeleteFile() {
			delete(f.files, fileObject)
		}
		if e.IsEnumDirectory() {
			if fileinfo != nil {
				e.AppendParam(params.FileDirectory, params.Path, fileinfo.Name)
			}
			return e, nil
		}

		if fileinfo != nil {
			if fileinfo.Type != fs.Unknown {
				e.AppendEnum(params.FileType, uint32(fileinfo.Type), fs.FileTypes)
			}
			e.AppendParam(params.FilePath, params.Path, fileinfo.Name)
		}

		if e.IsMapViewFile() {
			return e, f.psnap.AddMmap(e)
		}
	}

	return e, nil
}

func (f *fsProcessor) findFile(fileKey, fileObject uint64) *FileInfo {
	fileinfo, ok := f.files[fileKey]
	if ok {
		return fileinfo
	}
	fileinfo, ok = f.files[fileObject]
	if ok {
		return fileinfo
	}
	// look in the system handles for file objects
	var file htypes.Handle
	file, ok = f.hsnap.FindByObject(fileObject)
	if !ok {
		return nil
	}
	if file.Type == handle.File {
		fileObjectHandleHits.Add(1)
		return &FileInfo{Name: file.Name, Type: fs.GetFileType(file.Name, 0)}
	}
	return nil
}

func (f *fsProcessor) getMappedFile(pid uint32, addr uint64) string {
	process, err := windows.OpenProcess(windows.PROCESS_QUERY_INFORMATION, false, pid)
	if err != nil {
		return ""
	}
	defer windows.Close(process)
	return f.devMapper.Convert(sys.GetMappedFile(process, uintptr(addr)))
}

func (f *fsProcessor) purge() {
	for {
		select {
		case <-f.purger.C:
			f.mu.Lock()

			// evict unmatched stack traces
			for id, q := range f.buckets {
				s := make([]*event.Event, 0, len(q))
				for _, evt := range q {
					if time.Since(evt.Timestamp) <= time.Second*30 {
						s = append(s, evt)
					}
				}
				if len(s) == 0 {
					delete(f.buckets, id)
				} else {
					f.buckets[id] = s
				}
			}

			f.mu.Unlock()
		case <-f.quit:
			return
		}
	}
}

```

`internal/etw/processors/fs_windows_test.go`:

```go
/*
 * Copyright 2019-2020 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package processors

import (
	"github.com/rabbitstack/fibratus/pkg/config"
	"github.com/rabbitstack/fibratus/pkg/event"
	"github.com/rabbitstack/fibratus/pkg/event/params"
	"github.com/rabbitstack/fibratus/pkg/fs"
	"github.com/rabbitstack/fibratus/pkg/handle"
	htypes "github.com/rabbitstack/fibratus/pkg/handle/types"
	"github.com/rabbitstack/fibratus/pkg/ps"
	pstypes "github.com/rabbitstack/fibratus/pkg/ps/types"
	"github.com/rabbitstack/fibratus/pkg/util/va"
	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/mock"
	"github.com/stretchr/testify/require"
	"os"
	"reflect"
	"testing"
)

func TestFsProcessor(t *testing.T) {
	exe, err := os.Executable()
	require.NoError(t, err)

	var tests = []struct {
		name           string
		e              *event.Event
		setupProcessor func(Processor)
		hsnap          func() *handle.SnapshotterMock
		assertions     func(*event.Event, *testing.T, *handle.SnapshotterMock, Processor)
	}{
		{
			"process file rundown",
			&event.Event{
				Type:     event.FileRundown,
				Category: event.File,
				Params: event.Params{
					params.FileObject: {Name: params.FileObject, Type: params.Uint64, Value: uint64(124567380264)},
					params.FilePath:   {Name: params.FilePath, Type: params.UnicodeString, Value: "C:\\Windows\\system32\\user32.dll"},
				},
			},
			nil,
			func() *handle.SnapshotterMock {
				hsnap := new(handle.SnapshotterMock)
				return hsnap
			},
			func(e *event.Event, t *testing.T, hsnap *handle.SnapshotterMock, p Processor) {
				fsProcessor := p.(*fsProcessor)
				assert.Contains(t, fsProcessor.files, uint64(124567380264))
				file := fsProcessor.files[124567380264]
				assert.Equal(t, "C:\\Windows\\system32\\user32.dll", file.Name)
				assert.Equal(t, fs.Regular, file.Type)
			},
		},
		{
			"process mapped file rundown",
			&event.Event{
				PID:      10233,
				Type:     event.MapFileRundown,
				Category: event.File,
				Params: event.Params{
					params.FileKey:             {Name: params.FileKey, Type: params.Uint64, Value: uint64(124567380264)},
					params.FileViewSize:        {Name: params.FileViewSize, Type: params.Uint64, Value: uint64(3098)},
					params.FileViewBase:        {Name: params.FileViewBase, Type: params.Uint64, Value: uint64(0xffff23433)},
					params.FileViewSectionType: {Name: params.FileViewSectionType, Type: params.Enum, Value: uint32(va.SectionImage), Enum: event.ViewSectionTypes},
				},
			},
			func(p Processor) {
				fsProcessor := p.(*fsProcessor)
				fsProcessor.files[124567380264] = &FileInfo{Name: "C:\\Windows\\System32\\kernel32.dll"}
			},
			func() *handle.SnapshotterMock {
				hsnap := new(handle.SnapshotterMock)
				return hsnap
			},
			func(e *event.Event, t *testing.T, hsnap *handle.SnapshotterMock, p Processor) {
				fsProcessor := p.(*fsProcessor)

				assert.Equal(t, "C:\\Windows\\System32\\kernel32.dll", e.GetParamAsString(params.FilePath))

				psnap := fsProcessor.psnap.(*ps.SnapshotterMock)
				psnap.AssertNumberOfCalls(t, "AddMmap", 1)
			},
		},
		{
			"wait enqueue for create file events",
			&event.Event{
				Type:     event.CreateFile,
				Category: event.File,
				Params: event.Params{
					params.FileObject:        {Name: params.FileObject, Type: params.Uint64, Value: uint64(18446738026482168384)},
					params.ThreadID:          {Name: params.ThreadID, Type: params.Uint32, Value: uint32(1484)},
					params.FileCreateOptions: {Name: params.FileCreateOptions, Type: params.Uint32, Value: uint32(1223456)},
					params.FilePath:          {Name: params.FilePath, Type: params.UnicodeString, Value: "C:\\Windows\\system32\\kernel32.dll"},
					params.FileShareMask:     {Name: params.FileShareMask, Type: params.Uint32, Value: uint32(5)},
					params.FileIrpPtr:        {Name: params.FileIrpPtr, Type: params.Uint64, Value: uint64(1234543123112321)},
				},
			},
			nil,
			func() *handle.SnapshotterMock {
				hsnap := new(handle.SnapshotterMock)
				return hsnap
			},
			func(e *event.Event, t *testing.T, hsnap *handle.SnapshotterMock, p Processor) {
				fsProcessor := p.(*fsProcessor)
				assert.True(t, e.WaitEnqueue)
				assert.Contains(t, fsProcessor.irps, uint64(1234543123112321))
				assert.True(t, reflect.DeepEqual(e, fsProcessor.irps[1234543123112321]))
			},
		},
		{
			"get IRP completion for create file event",
			&event.Event{
				Type:     event.FileOpEnd,
				Category: event.File,
				Params: event.Params{
					params.FileObject:    {Name: params.FileObject, Type: params.Uint64, Value: uint64(18446738026482168384)},
					params.FileExtraInfo: {Name: params.FileExtraInfo, Type: params.Uint64, Value: uint64(2)},
					params.FileIrpPtr:    {Name: params.FileIrpPtr, Type: params.Uint64, Value: uint64(1334543123112321)},
					params.NTStatus:      {Name: params.NTStatus, Type: params.Status, Value: uint32(0)},
				},
			},
			func(p Processor) {
				fsProcessor := p.(*fsProcessor)
				fsProcessor.irps[1334543123112321] = &event.Event{
					Type:     event.CreateFile,
					Category: event.File,
					Params: event.Params{
						params.FileObject:        {Name: params.FileObject, Type: params.Uint64, Value: uint64(12446738026482168384)},
						params.FileCreateOptions: {Name: params.FileCreateOptions, Type: params.Uint32, Value: uint32(18874368)},
						params.FilePath:          {Name: params.FilePath, Type: params.UnicodeString, Value: exe},
						params.FileShareMask:     {Name: params.FileShareMask, Type: params.Uint32, Value: uint32(5)},
						params.FileIrpPtr:        {Name: params.FileIrpPtr, Type: params.Uint64, Value: uint64(1334543123112321)},
					},
				}
			},
			func() *handle.SnapshotterMock {
				hsnap := new(handle.SnapshotterMock)
				return hsnap
			},
			func(e *event.Event, t *testing.T, hsnap *handle.SnapshotterMock, p Processor) {
				fsProcessor := p.(*fsProcessor)
				assert.Equal(t, event.CreateFile, e.Type)
				assert.NotContains(t, fsProcessor.irps, uint64(1334543123112321))
				assert.False(t, e.WaitEnqueue)
				assert.Contains(t, fsProcessor.files, uint64(12446738026482168384))
				assert.Equal(t, exe, fsProcessor.files[12446738026482168384].Name)
				assert.Equal(t, "Success", e.GetParamAsString(params.NTStatus))
				assert.Equal(t, "File", e.GetParamAsString(params.FileType))
				assert.Equal(t, "CREATE", e.GetParamAsString(params.FileOperation))
				assert.True(t, e.Params.MustGetBool(params.FileIsExecutable))
				assert.False(t, e.Params.MustGetBool(params.FileIsDotnet))
				assert.False(t, e.Params.MustGetBool(params.FileIsDLL))
				assert.False(t, e.Params.MustGetBool(params.FileIsDriver))
			},
		},
		{
			"release file and remove file info",
			&event.Event{
				Type:     event.ReleaseFile,
				Category: event.File,
				Params: event.Params{
					params.FileObject: {Name: params.FileObject, Type: params.Uint64, Value: uint64(18446738026482168384)},
					params.FileKey:    {Name: params.FileKey, Type: params.Uint64, Value: uint64(14446538026482168384)},
				},
			},
			func(p Processor) {
				fsProcessor := p.(*fsProcessor)
				fsProcessor.files[18446738026482168384] = &FileInfo{Name: "C:\\Windows\\temp\\idxx.exe", Type: fs.Regular}
			},
			func() *handle.SnapshotterMock {
				hsnap := new(handle.SnapshotterMock)
				return hsnap
			},
			func(e *event.Event, t *testing.T, hsnap *handle.SnapshotterMock, p Processor) {
				fsProcessor := p.(*fsProcessor)
				assert.Empty(t, fsProcessor.files)
			},
		},
		{
			"parse created file characteristics",
			&event.Event{
				Type:     event.CreateFile,
				Category: event.File,
				Params: event.Params{
					params.FileObject:        {Name: params.FileObject, Type: params.Uint64, Value: uint64(18446738026482168384)},
					params.ThreadID:          {Name: params.ThreadID, Type: params.Uint32, Value: uint32(1484)},
					params.FileCreateOptions: {Name: params.FileCreateOptions, Type: params.Uint32, Value: uint32(1223456)},
					params.FilePath:          {Name: params.FilePath, Type: params.UnicodeString, Value: exe},
					params.FileShareMask:     {Name: params.FileShareMask, Type: params.Uint32, Value: uint32(5)},
					params.FileIrpPtr:        {Name: params.FileIrpPtr, Type: params.Uint64, Value: uint64(1234543123112321)},
					params.FileOperation:     {Name: params.FileOperation, Type: params.Uint64, Value: uint64(2)},
				},
			},
			nil,
			func() *handle.SnapshotterMock {
				hsnap := new(handle.SnapshotterMock)
				return hsnap
			},
			func(e *event.Event, t *testing.T, hsnap *handle.SnapshotterMock, p Processor) {
				fsProcessor := p.(*fsProcessor)
				assert.True(t, e.WaitEnqueue)
				assert.Contains(t, fsProcessor.irps, uint64(1234543123112321))
				assert.True(t, reflect.DeepEqual(e, fsProcessor.irps[1234543123112321]))
			},
		},
		{
			"unmap view file",
			&event.Event{
				PID:      10233,
				Type:     event.UnmapViewFile,
				Category: event.File,
				Params: event.Params{
					params.FileKey:             {Name: params.FileKey, Type: params.Uint64, Value: uint64(124567380264)},
					params.FileViewSize:        {Name: params.FileViewSize, Type: params.Uint64, Value: uint64(3098)},
					params.FileViewBase:        {Name: params.FileViewBase, Type: params.Uint64, Value: uint64(0xffff23433)},
					params.FileViewSectionType: {Name: params.FileViewSectionType, Type: params.Enum, Value: uint32(va.SectionImage), Enum: event.ViewSectionTypes},
				},
			},
			nil,
			func() *handle.SnapshotterMock {
				hsnap := new(handle.SnapshotterMock)
				return hsnap
			},
			func(e *event.Event, t *testing.T, hsnap *handle.SnapshotterMock, p Processor) {
				fsProcessor := p.(*fsProcessor)

				psnap := fsProcessor.psnap.(*ps.SnapshotterMock)
				psnap.AssertNumberOfCalls(t, "RemoveMmap", 1)
			},
		},
		{
			"process write file",
			&event.Event{
				Type:     event.WriteFile,
				Category: event.File,
				Params: event.Params{
					params.FileObject: {Name: params.FileObject, Type: params.Uint64, Value: uint64(18446738026482168384)},
					params.FileKey:    {Name: params.FileKey, Type: params.Uint64, Value: uint64(14446538026482168384)},
					params.FileIoSize: {Name: params.FileIoSize, Type: params.Uint32, Value: uint32(1024)},
				},
			},
			func(p Processor) {
				fsProcessor := p.(*fsProcessor)
				fsProcessor.files[18446738026482168384] = &FileInfo{Name: "C:\\Windows\\temp\\idxx.exe", Type: fs.Regular}
			},
			func() *handle.SnapshotterMock {
				hsnap := new(handle.SnapshotterMock)
				return hsnap
			},
			func(e *event.Event, t *testing.T, hsnap *handle.SnapshotterMock, p Processor) {
				assert.Equal(t, event.WriteFile, e.Type)
				assert.Contains(t, e.Params, params.FilePath, params.FileType)
				assert.Equal(t, "C:\\Windows\\temp\\idxx.exe", e.GetParamAsString(params.FilePath))
				assert.Equal(t, "File", e.GetParamAsString(params.FileType))
			},
		},
		{
			"process write file consult handle snapshotter",
			&event.Event{
				Type:     event.WriteFile,
				Category: event.File,
				Params: event.Params{
					params.FileObject: {Name: params.FileObject, Type: params.Uint64, Value: uint64(18446738026482168384)},
					params.FileKey:    {Name: params.FileKey, Type: params.Uint64, Value: uint64(14446538026482168384)},
					params.FileIoSize: {Name: params.FileIoSize, Type: params.Uint32, Value: uint32(1024)},
				},
			},
			nil,
			func() *handle.SnapshotterMock {
				hsnap := new(handle.SnapshotterMock)
				hsnap.On("FindByObject", uint64(18446738026482168384)).Return(htypes.Handle{Type: handle.File, Name: "C:\\Windows\\temp\\doc.docx"}, true)
				return hsnap
			},
			func(e *event.Event, t *testing.T, hsnap *handle.SnapshotterMock, p Processor) {
				assert.Equal(t, event.WriteFile, e.Type)
				hsnap.AssertNumberOfCalls(t, "FindByObject", 1)
				assert.Contains(t, e.Params, params.FilePath, params.FileType)
				assert.Equal(t, "C:\\Windows\\temp\\doc.docx", e.GetParamAsString(params.FilePath))
				assert.Equal(t, "File", e.GetParamAsString(params.FileType))
			},
		},
		{
			"process enum directory",
			&event.Event{
				Type:     event.EnumDirectory,
				Category: event.File,
				Params: event.Params{
					params.FileObject: {Name: params.FileObject, Type: params.Uint64, Value: uint64(18446738026482168384)},
					params.FileKey:    {Name: params.FileKey, Type: params.Uint64, Value: uint64(14446538026482168384)},
					params.FilePath:   {Name: params.FilePath, Type: params.UnicodeString, Value: "*"},
				},
			},
			func(p Processor) {
				fsProcessor := p.(*fsProcessor)
				fsProcessor.files[14446538026482168384] = &FileInfo{Name: "C:\\Windows\\temp", Type: fs.Regular}
			},
			func() *handle.SnapshotterMock {
				hsnap := new(handle.SnapshotterMock)
				return hsnap
			},
			func(e *event.Event, t *testing.T, hsnap *handle.SnapshotterMock, p Processor) {
				assert.Equal(t, event.EnumDirectory, e.Type)
				assert.Contains(t, e.Params, params.FilePath, params.FileDirectory)
				assert.Equal(t, "C:\\Windows\\temp", e.GetParamAsString(params.FileDirectory))
			},
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			hsnap := tt.hsnap()
			psnap := new(ps.SnapshotterMock)
			psnap.On("AddMmap", mock.Anything).Return(nil)
			psnap.On("RemoveMmap", mock.Anything, mock.Anything).Return(nil)
			psnap.On("Find", mock.Anything).Return(true, &pstypes.PS{
				Mmaps: []pstypes.Mmap{
					{File: "C:\\Windows\\System32\\kernel32.dll", BaseAddress: va.Address(0xffff23433), Size: 3098},
				},
			})
			p := newFsProcessor(hsnap, psnap, fs.NewDevMapper(), fs.NewDevPathResolver(), &config.Config{})
			if tt.setupProcessor != nil {
				tt.setupProcessor(p)
			}
			var err error
			tt.e, _, err = p.ProcessEvent(tt.e)
			require.NoError(t, err)
			tt.assertions(tt.e, t, hsnap, p)
		})
	}
}

```

`internal/etw/processors/handle_windows.go`:

```go
/*
 * Copyright 2019-2020 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package processors

import (
	"github.com/rabbitstack/fibratus/pkg/event"
	"github.com/rabbitstack/fibratus/pkg/event/params"
	"github.com/rabbitstack/fibratus/pkg/fs"
	"github.com/rabbitstack/fibratus/pkg/handle"
	"github.com/rabbitstack/fibratus/pkg/ps"
	"github.com/rabbitstack/fibratus/pkg/util/key"
	"strings"
)

type handleProcessor struct {
	hsnap           handle.Snapshotter
	psnap           ps.Snapshotter
	devMapper       fs.DevMapper
	devPathResolver fs.DevPathResolver
}

func newHandleProcessor(
	hsnap handle.Snapshotter,
	psnap ps.Snapshotter,
	devMapper fs.DevMapper,
	devPathResolver fs.DevPathResolver,
) Processor {
	return &handleProcessor{
		hsnap:           hsnap,
		psnap:           psnap,
		devMapper:       devMapper,
		devPathResolver: devPathResolver,
	}
}

func (h *handleProcessor) ProcessEvent(e *event.Event) (*event.Event, bool, error) {
	if e.Category == event.Handle {
		evt, err := h.processEvent(e)
		return evt, false, err
	}
	return e, true, nil
}

func (h *handleProcessor) processEvent(e *event.Event) (*event.Event, error) {
	if e.Type == event.DuplicateHandle {
		// enrich event with process parameters
		pid := e.Params.MustGetPid()
		proc := h.psnap.FindAndPut(pid)
		if proc != nil {
			e.AppendParam(params.Exe, params.Path, proc.Exe)
			e.AppendParam(params.ProcessName, params.AnsiString, proc.Name)
		}
		return e, nil
	}

	name := e.GetParamAsString(params.HandleObjectName)
	typ := e.GetParamAsString(params.HandleObjectTypeID)

	if name != "" {
		switch typ {
		case handle.Key:
			rootKey, keyName := key.Format(name)
			if rootKey == key.Invalid {
				break
			}
			name = rootKey.String()
			if keyName != "" {
				name += "\\" + keyName
			}
		case handle.File:
			name = h.devMapper.Convert(name)
		case handle.Driver:
			driverName := strings.TrimPrefix(name, "\\Driver\\") + ".sys"
			driverPath := h.devPathResolver.GetPath(driverName)
			if driverPath == "" {
				driverPath = driverName
			}
			h.devPathResolver.RemovePath(driverName)
			e.Params.Append(params.ImagePath, params.Path, driverPath)
		}
		// assign the formatted handle name
		if err := e.Params.SetValue(params.HandleObjectName, name); err != nil {
			return e, err
		}
	}

	if e.Type == event.CreateHandle {
		return e, h.hsnap.Write(e)
	}

	return e, h.hsnap.Remove(e)
}

func (*handleProcessor) Name() ProcessorType { return Handle }
func (h *handleProcessor) Close()            {}

```

`internal/etw/processors/handle_windows_test.go`:

```go
/*
 * Copyright 2019-2020 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package processors

import (
	"github.com/rabbitstack/fibratus/pkg/event"
	"github.com/rabbitstack/fibratus/pkg/event/params"
	"github.com/rabbitstack/fibratus/pkg/fs"
	"github.com/rabbitstack/fibratus/pkg/handle"
	"github.com/rabbitstack/fibratus/pkg/ps"
	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/mock"
	"github.com/stretchr/testify/require"
	"testing"
)

func TestHandleProcessor(t *testing.T) {
	var tests = []struct {
		name       string
		e          *event.Event
		hsnap      func() *handle.SnapshotterMock
		assertions func(*event.Event, *testing.T, *handle.SnapshotterMock)
	}{
		{
			"process create handle",
			&event.Event{
				Type:     event.CreateHandle,
				Tid:      2484,
				PID:      859,
				Category: event.Handle,
				Params: event.Params{
					params.HandleID:           {Name: params.HandleID, Type: params.Uint32, Value: uint32(21)},
					params.HandleObjectTypeID: {Name: params.HandleObjectTypeID, Type: params.AnsiString, Value: "Key"},
					params.HandleObject:       {Name: params.HandleObject, Type: params.Uint64, Value: uint64(18446692422059208560)},
					params.HandleObjectName:   {Name: params.HandleObjectName, Type: params.UnicodeString, Value: ""},
				},
				Metadata: make(event.Metadata),
			},
			func() *handle.SnapshotterMock {
				hsnap := new(handle.SnapshotterMock)
				hsnap.On("Write", mock.Anything).Return(nil)
				return hsnap
			},
			func(e *event.Event, t *testing.T, hsnap *handle.SnapshotterMock) {
				hsnap.AssertNumberOfCalls(t, "Write", 1)
			},
		},
		{
			"process close handle",
			&event.Event{
				Type:     event.CloseHandle,
				Tid:      2484,
				PID:      859,
				Category: event.Handle,
				Params: event.Params{
					params.HandleID:           {Name: params.HandleID, Type: params.Uint32, Value: uint32(21)},
					params.HandleObjectTypeID: {Name: params.HandleObjectTypeID, Type: params.AnsiString, Value: "Key"},
					params.HandleObject:       {Name: params.HandleObject, Type: params.Uint64, Value: uint64(18446692422059208560)},
					params.HandleObjectName:   {Name: params.HandleObjectName, Type: params.UnicodeString, Value: `\REGISTRY\MACHINE\SYSTEM\ControlSet001\Services\Tcpip\Parameters\Interfaces\{b677c565-6ca5-45d3-b618-736b4e09b036}`},
				},
				Metadata: make(event.Metadata),
			},
			func() *handle.SnapshotterMock {
				hsnap := new(handle.SnapshotterMock)
				hsnap.On("Remove", mock.Anything).Return(nil)
				return hsnap
			},
			func(e *event.Event, t *testing.T, hsnap *handle.SnapshotterMock) {
				assert.Equal(t, `HKEY_LOCAL_MACHINE\SYSTEM\ControlSet001\Services\Tcpip\Parameters\Interfaces\{b677c565-6ca5-45d3-b618-736b4e09b036}`, e.GetParamAsString(params.HandleObjectName))
				hsnap.AssertNumberOfCalls(t, "Remove", 1)
			},
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			hsnap := tt.hsnap()
			psnap := new(ps.SnapshotterMock)
			p := newHandleProcessor(hsnap, psnap, fs.NewDevMapper(), fs.NewDevPathResolver())
			var err error
			tt.e, _, err = p.ProcessEvent(tt.e)
			require.NoError(t, err)
			tt.assertions(tt.e, t, hsnap)
		})
	}
}

```

`internal/etw/processors/image_windows.go`:

```go
/*
 * Copyright 2019-2020 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package processors

import (
	"expvar"
	"github.com/rabbitstack/fibratus/pkg/event"
	"github.com/rabbitstack/fibratus/pkg/event/params"
	"github.com/rabbitstack/fibratus/pkg/ps"
	"sync"
	"time"
)

var imageFileCharacteristicsCacheHits = expvar.NewInt("image.file.characteristics.cache.hits")

var modTTL = time.Minute * 10

type imageProcessor struct {
	psnap  ps.Snapshotter
	mods   map[string]*imageFileCharacteristics
	mu     sync.Mutex
	purger *time.Ticker
	quit   chan struct{}
}

func newImageProcessor(psnap ps.Snapshotter) Processor {
	m := &imageProcessor{
		psnap:  psnap,
		mods:   make(map[string]*imageFileCharacteristics),
		purger: time.NewTicker(time.Minute),
		quit:   make(chan struct{}, 1),
	}

	go m.purge()

	return m
}

func (*imageProcessor) Name() ProcessorType { return Image }

func (m *imageProcessor) ProcessEvent(e *event.Event) (*event.Event, bool, error) {
	if e.IsLoadImageInternal() {
		// state management
		return e, false, m.psnap.AddModule(e)
	}

	if e.IsLoadImage() {
		// is image characteristics data cached?
		path := e.GetParamAsString(params.ImagePath)
		key := path + e.GetParamAsString(params.ImageCheckSum)

		m.mu.Lock()
		defer m.mu.Unlock()
		c, ok := m.mods[key]
		if !ok {
			// parse PE image data
			var err error
			c, err = parseImageFileCharacteristics(path)
			if err != nil {
				return e, false, m.psnap.AddModule(e)
			}
			c.keepalive()
			m.mods[key] = c
		} else {
			imageFileCharacteristicsCacheHits.Add(1)
			c.keepalive()
		}

		// append event parameters
		e.AppendParam(params.FileIsDLL, params.Bool, c.isDLL)
		e.AppendParam(params.FileIsDriver, params.Bool, c.isDriver)
		e.AppendParam(params.FileIsExecutable, params.Bool, c.isExe)
		e.AppendParam(params.FileIsDotnet, params.Bool, c.isDotnet)
	}

	if e.IsUnloadImage() {
		pid := e.Params.MustGetPid()
		addr := e.Params.TryGetAddress(params.ImageBase)
		if pid == 0 {
			pid = e.PID
		}
		return e, false, m.psnap.RemoveModule(pid, addr)
	}

	if e.IsLoadImage() || e.IsImageRundown() {
		return e, false, m.psnap.AddModule(e)
	}
	return e, true, nil
}

func (m *imageProcessor) Close() {
	m.quit <- struct{}{}
}

func (m *imageProcessor) purge() {
	for {
		select {
		case <-m.purger.C:
			m.mu.Lock()
			for key, mod := range m.mods {
				if time.Since(mod.accessed) > modTTL {
					delete(m.mods, key)
				}
			}
			m.mu.Unlock()
		case <-m.quit:
			return
		}
	}
}

```

`internal/etw/processors/image_windows_test.go`:

```go
/*
 * Copyright 2019-2020 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package processors

import (
	"github.com/rabbitstack/fibratus/pkg/event"
	"github.com/rabbitstack/fibratus/pkg/event/params"
	"github.com/rabbitstack/fibratus/pkg/ps"
	"github.com/rabbitstack/fibratus/pkg/util/signature"
	"github.com/rabbitstack/fibratus/pkg/util/va"
	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/mock"
	"github.com/stretchr/testify/require"
	"os"
	"path/filepath"
	"testing"
)

func TestImageProcessor(t *testing.T) {
	var tests = []struct {
		name       string
		e          *event.Event
		psnap      func() *ps.SnapshotterMock
		assertions func(*event.Event, *testing.T, *ps.SnapshotterMock)
	}{
		{
			"load new image",
			&event.Event{
				Type: event.LoadImage,
				Params: event.Params{
					params.ImagePath:           {Name: params.ImagePath, Type: params.UnicodeString, Value: filepath.Join(os.Getenv("windir"), "System32", "kernel32.dll")},
					params.ProcessID:           {Name: params.ProcessID, Type: params.PID, Value: uint32(1023)},
					params.ImageCheckSum:       {Name: params.ImageCheckSum, Type: params.Uint32, Value: uint32(2323432)},
					params.ImageBase:           {Name: params.ImageBase, Type: params.Address, Value: uint64(0x7ffb313833a3)},
					params.ImageSignatureType:  {Name: params.ImageSignatureType, Type: params.Enum, Value: uint32(1), Enum: signature.Types},
					params.ImageSignatureLevel: {Name: params.ImageSignatureLevel, Type: params.Enum, Value: uint32(4), Enum: signature.Levels},
				},
			},
			func() *ps.SnapshotterMock {
				psnap := new(ps.SnapshotterMock)
				psnap.On("AddModule", mock.Anything).Return(nil)
				return psnap
			},
			func(e *event.Event, t *testing.T, psnap *ps.SnapshotterMock) {
				psnap.AssertNumberOfCalls(t, "AddModule", 1)
				// should get the signature verified
				assert.Equal(t, "EMBEDDED", e.GetParamAsString(params.ImageSignatureType))
				assert.Equal(t, "AUTHENTICODE", e.GetParamAsString(params.ImageSignatureLevel))
			},
		},
		{
			"parse image characteristics",
			&event.Event{
				Type: event.LoadImage,
				Params: event.Params{
					params.ImagePath:           {Name: params.ImagePath, Type: params.UnicodeString, Value: "../_fixtures/mscorlib.dll"},
					params.ProcessID:           {Name: params.ProcessID, Type: params.PID, Value: uint32(1023)},
					params.ImageCheckSum:       {Name: params.ImageCheckSum, Type: params.Uint32, Value: uint32(2323432)},
					params.ImageBase:           {Name: params.ImageBase, Type: params.Address, Value: uint64(0x7ffb313833a3)},
					params.ImageSignatureType:  {Name: params.ImageSignatureType, Type: params.Enum, Value: uint32(1), Enum: signature.Types},
					params.ImageSignatureLevel: {Name: params.ImageSignatureLevel, Type: params.Enum, Value: uint32(4), Enum: signature.Levels},
				},
			},
			func() *ps.SnapshotterMock {
				psnap := new(ps.SnapshotterMock)
				psnap.On("AddModule", mock.Anything).Return(nil)
				return psnap
			},
			func(e *event.Event, t *testing.T, psnap *ps.SnapshotterMock) {
				psnap.AssertNumberOfCalls(t, "AddModule", 1)
				// should be enriched with image characteristics params
				assert.True(t, e.Params.MustGetBool(params.FileIsDLL))
				assert.True(t, e.Params.MustGetBool(params.FileIsDotnet))
				assert.False(t, e.Params.MustGetBool(params.FileIsExecutable))
				assert.False(t, e.Params.MustGetBool(params.FileIsDriver))
			},
		},
		{
			"unload image",
			&event.Event{
				Type: event.UnloadImage,
				Params: event.Params{
					params.ImagePath:           {Name: params.ImagePath, Type: params.UnicodeString, Value: "C:\\Windows\\system32\\kernel32.dll"},
					params.ProcessName:         {Name: params.ProcessName, Type: params.AnsiString, Value: "csrss.exe"},
					params.ProcessID:           {Name: params.ProcessID, Type: params.PID, Value: uint32(676)},
					params.ImageBase:           {Name: params.ImageBase, Type: params.Address, Value: uint64(0xfffb313833a3)},
					params.ImageSignatureType:  {Name: params.ImageSignatureType, Type: params.Enum, Value: uint32(0), Enum: signature.Types},
					params.ImageSignatureLevel: {Name: params.ImageSignatureLevel, Type: params.Enum, Value: uint32(0), Enum: signature.Levels},
				},
			},
			func() *ps.SnapshotterMock {
				psnap := new(ps.SnapshotterMock)
				psnap.On("RemoveModule", uint32(676), va.Address(0xfffb313833a3)).Return(nil)
				psnap.On("FindModule", mock.Anything).Return(false, nil)
				return psnap
			},
			func(e *event.Event, t *testing.T, psnap *ps.SnapshotterMock) {
				psnap.AssertNumberOfCalls(t, "RemoveModule", 1)
			},
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			psnap := tt.psnap()
			p := newImageProcessor(psnap)
			var err error
			tt.e, _, err = p.ProcessEvent(tt.e)
			require.NoError(t, err)
			tt.assertions(tt.e, t, psnap)
		})
	}
}

```

`internal/etw/processors/mem_windows.go`:

```go
/*
 * Copyright 2021-2022 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package processors

import (
	"github.com/rabbitstack/fibratus/pkg/event"
	"github.com/rabbitstack/fibratus/pkg/event/params"
	psnap "github.com/rabbitstack/fibratus/pkg/ps"
	"github.com/rabbitstack/fibratus/pkg/util/va"
)

// MemPageTypes represents the type of the pages in the allocated region.
var MemPageTypes = event.ParamEnum{
	va.MemImage:   "IMAGE",
	va.MemMapped:  "MAPPED",
	va.MemPrivate: "PRIVATE",
}

type memProcessor struct {
	psnap        psnap.Snapshotter
	regionProber *va.RegionProber
}

func newMemProcessor(psnap psnap.Snapshotter, regionProber *va.RegionProber) Processor {
	return &memProcessor{psnap: psnap, regionProber: regionProber}
}

func (memProcessor) Name() ProcessorType { return Mem }

func (m memProcessor) Close() {
	m.regionProber.Close()
}

func (m memProcessor) ProcessEvent(e *event.Event) (*event.Event, bool, error) {
	if e.Category == event.Mem {
		pid := e.Params.MustGetPid()
		if e.IsVirtualAlloc() {
			// retrieve info about the range of pages and enrich the event
			// with allocation protection options and the type of pages in
			// the allocated region. If the region is mapped, we try to find
			// the backing file name
			addr := e.Params.MustGetUint64(params.MemBaseAddress)
			region := m.regionProber.Query(pid, addr)
			if region != nil {
				if region.IsMapped() {
					e.AppendParam(params.FilePath, params.DOSPath, region.GetMappedFile())
				}
				e.AppendEnum(params.MemPageType, region.Type, MemPageTypes)
				e.AppendFlags(params.MemProtect, region.Protect, event.MemProtectionFlags)
				e.AppendParam(params.MemProtectMask, params.AnsiString, region.ProtectMask())
			}
		}
		proc := m.psnap.FindAndPut(pid)
		if proc != nil {
			e.AppendParam(params.Exe, params.Path, proc.Exe)
			e.AppendParam(params.ProcessName, params.AnsiString, proc.Name)
		}
		return e, false, nil
	}
	return e, true, nil
}

```

`internal/etw/processors/mem_windows_test.go`:

```go
/*
 * Copyright 2021-2022 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package processors

import (
	"github.com/rabbitstack/fibratus/pkg/event"
	"github.com/rabbitstack/fibratus/pkg/event/params"
	"github.com/rabbitstack/fibratus/pkg/ps"
	pstypes "github.com/rabbitstack/fibratus/pkg/ps/types"
	"github.com/rabbitstack/fibratus/pkg/util/va"
	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/mock"
	"github.com/stretchr/testify/require"
	"golang.org/x/sys/windows"
	"os"
	"testing"
)

func TestMemProcessor(t *testing.T) {
	base, err := windows.VirtualAlloc(0, 1024, windows.MEM_COMMIT|windows.MEM_RESERVE, windows.PAGE_EXECUTE_READWRITE)
	require.NoError(t, err)
	defer func() {
		_ = windows.VirtualFree(base, 1024, windows.MEM_RELEASE)
	}()
	var tests = []struct {
		name       string
		e          *event.Event
		psnap      func() *ps.SnapshotterMock
		assertions func(*event.Event, *testing.T, *ps.SnapshotterMock)
	}{
		{
			"virtual alloc",
			&event.Event{
				Type:     event.VirtualAlloc,
				Category: event.Mem,
				Params: event.Params{
					params.MemRegionSize:  {Name: params.MemRegionSize, Type: params.Uint64, Value: uint64(1024)},
					params.MemBaseAddress: {Name: params.MemBaseAddress, Type: params.Address, Value: uint64(base)},
					params.MemAllocType:   {Name: params.MemAllocType, Type: params.Flags, Value: uint32(0x00001000 | 0x00002000), Flags: event.MemAllocationFlags},
					params.ProcessID:      {Name: params.ProcessID, Type: params.PID, Value: uint32(os.Getpid())},
				},
			},
			func() *ps.SnapshotterMock {
				psnap := new(ps.SnapshotterMock)
				psnap.On("FindAndPut", mock.Anything).Return(&pstypes.PS{Name: "svchost.exe", Exe: "C:\\Windows\\System32\\svchost.exe"})
				return psnap
			},
			func(e *event.Event, t *testing.T, psnap *ps.SnapshotterMock) {
				psnap.AssertNumberOfCalls(t, "FindAndPut", 1)
				assert.Equal(t, "PRIVATE", e.GetParamAsString(params.MemPageType))
				assert.Equal(t, "EXECUTE_READWRITE", e.GetParamAsString(params.MemProtect))
				assert.Equal(t, "RWX", e.GetParamAsString(params.MemProtectMask))
				assert.Equal(t, "svchost.exe", e.GetParamAsString(params.ProcessName))
				assert.Equal(t, "C:\\Windows\\System32\\svchost.exe", e.GetParamAsString(params.Exe))
			},
		},
		{
			"virtual free",
			&event.Event{
				Type:     event.VirtualFree,
				Category: event.Mem,
				Params: event.Params{
					params.MemRegionSize:  {Name: params.MemRegionSize, Type: params.Uint64, Value: uint64(1024)},
					params.MemBaseAddress: {Name: params.MemBaseAddress, Type: params.Address, Value: uint64(base)},
					params.MemAllocType:   {Name: params.MemAllocType, Type: params.Flags, Value: uint32(0x00008000), Flags: event.MemAllocationFlags},
					params.ProcessID:      {Name: params.ProcessID, Type: params.PID, Value: uint32(os.Getpid())},
				},
			},
			func() *ps.SnapshotterMock {
				psnap := new(ps.SnapshotterMock)
				psnap.On("FindAndPut", mock.Anything).Return(&pstypes.PS{Name: "svchost.exe", Exe: "C:\\Windows\\System32\\svchost.exe"})
				return psnap
			},
			func(e *event.Event, t *testing.T, psnap *ps.SnapshotterMock) {
				psnap.AssertNumberOfCalls(t, "FindAndPut", 1)
				assert.Equal(t, "svchost.exe", e.GetParamAsString(params.ProcessName))
				assert.Equal(t, "C:\\Windows\\System32\\svchost.exe", e.GetParamAsString(params.Exe))
			},
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			psnap := tt.psnap()
			p := newMemProcessor(psnap, va.NewRegionProber())
			var err error
			tt.e, _, err = p.ProcessEvent(tt.e)
			require.NoError(t, err)
			tt.assertions(tt.e, t, psnap)
		})
	}
}

```

`internal/etw/processors/net_windows.go`:

```go
/*
 * Copyright 2019-2020 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package processors

import (
	"github.com/rabbitstack/fibratus/pkg/event"
	"github.com/rabbitstack/fibratus/pkg/event/params"
	"github.com/rabbitstack/fibratus/pkg/network"
	"github.com/rabbitstack/fibratus/pkg/util/ports"
)

type netProcessor struct {
}

// newNetProcessor creates a new instance of the network event interceptor.
func newNetProcessor() Processor {
	return &netProcessor{}
}

func (netProcessor) Name() ProcessorType { return Net }

func (n netProcessor) Close() {}

func (n *netProcessor) ProcessEvent(e *event.Event) (*event.Event, bool, error) {
	if e.Category == event.Net {
		if e.IsNetworkTCP() && !e.IsDNS() {
			e.AppendEnum(params.NetL4Proto, uint32(network.TCP), network.ProtoNames)
		}
		if e.IsNetworkUDP() && !e.IsDNS() {
			e.AppendEnum(params.NetL4Proto, uint32(network.UDP), network.ProtoNames)
		}

		if e.IsDNS() {
			return e, false, nil
		}

		n.resolvePortName(e)

		return e, false, nil
	}
	return e, true, nil
}

// resolvePortName resolves the IANA service name for the particular port and transport protocol as
// per https://www.iana.org/assignments/service-names-port-numbers/service-names-port-numbers.xhtml.
func (n netProcessor) resolvePortName(e *event.Event) *event.Event {
	dport := e.Params.TryGetUint16(params.NetDport)
	sport := e.Params.TryGetUint16(params.NetSport)

	if e.IsNetworkTCP() {
		if name, ok := ports.TCPPortNames[dport]; ok {
			e.Params.Append(params.NetDportName, params.AnsiString, name)
		}
		if name, ok := ports.TCPPortNames[sport]; ok {
			e.Params.Append(params.NetSportName, params.AnsiString, name)
		}
		return e
	}

	if name, ok := ports.UDPPortNames[dport]; ok {
		e.Params.Append(params.NetDportName, params.AnsiString, name)
	}
	if name, ok := ports.UDPPortNames[sport]; ok {
		e.Params.Append(params.NetSportName, params.AnsiString, name)
	}
	return e
}

```

`internal/etw/processors/net_windows_test.go`:

```go
/*
 * Copyright 2019-2020 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package processors

import (
	"github.com/rabbitstack/fibratus/pkg/event"
	"github.com/rabbitstack/fibratus/pkg/event/params"
	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/require"
	"net"
	"testing"
)

func TestNetworkProcessor(t *testing.T) {
	var tests = []struct {
		name       string
		e          *event.Event
		assertions func(*event.Event, *testing.T)
	}{
		{
			"send tcpv4",
			&event.Event{
				Type:     event.SendTCPv4,
				Category: event.Net,
				Params: event.Params{
					params.NetDport: {Name: params.NetDport, Type: params.Uint16, Value: uint16(443)},
					params.NetSport: {Name: params.NetSport, Type: params.Uint16, Value: uint16(43123)},
					params.NetSIP:   {Name: params.NetSIP, Type: params.IPv4, Value: net.ParseIP("127.0.0.1")},
					params.NetDIP:   {Name: params.NetDIP, Type: params.IPv4, Value: net.ParseIP("8.8.8.8")},
				},
			},
			func(e *event.Event, t *testing.T) {
				assert.Equal(t, "Send", e.Type.String())
				assert.Equal(t, "https", e.GetParamAsString(params.NetDportName))
				assert.Equal(t, "TCP", e.GetParamAsString(params.NetL4Proto))
				assert.Equal(t, "127.0.0.1", e.GetParamAsString(params.NetSIP))
				assert.Equal(t, "8.8.8.8", e.GetParamAsString(params.NetDIP))
				assert.Equal(t, "443", e.GetParamAsString(params.NetDport))
				assert.Equal(t, "43123", e.GetParamAsString(params.NetSport))
			},
		},
		{
			"recv udp6",
			&event.Event{
				Type:     event.RecvUDPv6,
				Category: event.Net,
				Params: event.Params{
					params.NetDport: {Name: params.NetDport, Type: params.Uint16, Value: uint16(53)},
					params.NetSport: {Name: params.NetSport, Type: params.Uint16, Value: uint16(43123)},
					params.NetSIP:   {Name: params.NetSIP, Type: params.IPv4, Value: net.ParseIP("127.0.0.1")},
					params.NetDIP:   {Name: params.NetDIP, Type: params.IPv4, Value: net.ParseIP("8.8.8.8")},
				},
			},
			func(e *event.Event, t *testing.T) {
				assert.Equal(t, "Recv", e.Type.String())
				assert.Equal(t, "domain", e.GetParamAsString(params.NetDportName))
				assert.Equal(t, "UDP", e.GetParamAsString(params.NetL4Proto))
			},
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			p := newNetProcessor()
			var err error
			tt.e, _, err = p.ProcessEvent(tt.e)
			require.NoError(t, err)
			tt.assertions(tt.e, t)
		})
	}
}

```

`internal/etw/processors/processor.go`:

```go
/*
 * Copyright 2019-2020 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package processors

import (
	"github.com/rabbitstack/fibratus/pkg/event"
	libntfs "github.com/rabbitstack/fibratus/pkg/fs/ntfs"
	"github.com/rabbitstack/fibratus/pkg/pe"
	"os"
	"time"
)

// ProcessorType is an alias for the event processor type
type ProcessorType uint8

const (
	// Ps represents the process event processor.
	Ps ProcessorType = iota
	// Fs represents the file system event processor.
	Fs
	// Registry represents the registry event processor.
	Registry
	// Image represents the image event processor.
	Image
	// Net represents the network event processor.
	Net
	// Handle represents the handle event processor.
	Handle
	// Mem represents the memory event processor.
	Mem
)

// Processor is the minimal interface that each event stream processor has to satisfy. The event processor
// has the ability to augment events with additional parameters. It is also capable of building a state machine
// from the flow of events going through it.
type Processor interface {
	// ProcessEvent receives an existing event possibly mutating its state.
	// If it returns true, the next processor in the chain is evaluated.
	ProcessEvent(*event.Event) (*event.Event, bool, error)

	// Name returns a human-readable name of this processor.
	Name() ProcessorType

	// Close closes the processor and disposes allocated resources.
	Close()
}

// String returns a human-friendly processor name.
func (typ ProcessorType) String() string {
	switch typ {
	case Ps:
		return "process"
	case Fs:
		return "file"
	case Registry:
		return "registry"
	case Image:
		return "image"
	case Net:
		return "net"
	case Handle:
		return "handle"
	case Mem:
		return "mem"
	default:
		return "unknown"
	}
}

type imageFileCharacteristics struct {
	isExe    bool
	isDLL    bool
	isDriver bool
	isDotnet bool
	accessed time.Time
}

func (c *imageFileCharacteristics) keepalive() {
	c.accessed = time.Now()
}

// parseImageFileCharacteristics parses the PE structure for the file path
// residing in the given event parameters. The preferred method for reading
// the PE metadata is by directly accessing the file.
// If this operation fails, the file data is read form the raw device and
// the blob is passed to the PE parser.
// The given event is decorated with various parameters extracted from PE
// data. Most notably, parameters that indicate whether the file is a DLL,
// executable image, or a Windows driver.
func parseImageFileCharacteristics(path string) (*imageFileCharacteristics, error) {
	var pefile *pe.PE

	f, err := os.Open(path)
	if err != nil {
		// read file data blob from raw device
		// if the regular file access fails
		ntfs := libntfs.NewFS()
		data, n, err := ntfs.Read(path, 0, int64(os.Getpagesize()))
		defer ntfs.Close()
		if err != nil {
			return nil, err
		}
		if n > 0 {
			data = data[:n]
		}
		// parse PE file from byte slice
		pefile, err = pe.ParseBytes(data, pe.WithSections(), pe.WithSymbols(), pe.WithCLR())
		if err != nil {
			return nil, err
		}
	} else {
		defer f.Close()
		// parse PE file from on-disk file
		pefile, err = pe.ParseFile(path, pe.WithSections(), pe.WithSymbols(), pe.WithCLR())
		if err != nil {
			return nil, err
		}
	}

	c := &imageFileCharacteristics{
		isExe:    pefile.IsExecutable,
		isDLL:    pefile.IsDLL,
		isDriver: pefile.IsDriver,
		isDotnet: pefile.IsDotnet,
	}

	return c, nil
}

```

`internal/etw/processors/ps_windows.go`:

```go
/*
 * Copyright 2019-2020 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package processors

import (
	"github.com/rabbitstack/fibratus/pkg/event"
	"github.com/rabbitstack/fibratus/pkg/event/params"
	"github.com/rabbitstack/fibratus/pkg/ps"
	"github.com/rabbitstack/fibratus/pkg/util/cmdline"
	"github.com/rabbitstack/fibratus/pkg/util/multierror"
	"github.com/rabbitstack/fibratus/pkg/util/va"
	"golang.org/x/sys/windows"
	"time"
)

type psProcessor struct {
	psnap        ps.Snapshotter
	regionProber *va.RegionProber
}

// newPsProcessor creates a new event processor for process/thread events.
func newPsProcessor(psnap ps.Snapshotter, regionProber *va.RegionProber) Processor {
	return &psProcessor{psnap: psnap, regionProber: regionProber}
}

func (p psProcessor) ProcessEvent(e *event.Event) (*event.Event, bool, error) {
	switch e.Type {
	case event.CreateProcess, event.CreateProcessInternal, event.TerminateProcess, event.ProcessRundown, event.ProcessRundownInternal:
		evt, err := p.processEvent(e)
		if evt.IsTerminateProcess() {
			p.regionProber.Remove(evt.Params.MustGetPid())
			return evt, false, multierror.Wrap(err, p.psnap.Remove(evt))
		}

		return evt, false, multierror.Wrap(err, p.psnap.Write(evt))
	case event.CreateThread, event.TerminateThread, event.ThreadRundown:
		pid, err := e.Params.GetPid()
		if err != nil {
			return e, false, err
		}
		proc := p.psnap.FindAndPut(pid)
		if proc != nil {
			e.AppendParam(params.Exe, params.UnicodeString, proc.Exe)
		}
		if !e.IsTerminateThread() {
			return e, false, p.psnap.AddThread(e)
		}
		tid, err := e.Params.GetTid()
		if err != nil {
			return e, false, err
		}

		return e, false, p.psnap.RemoveThread(pid, tid)
	case event.OpenProcess, event.OpenThread:
		pid, err := e.Params.GetPid()
		if err != nil {
			return e, false, err
		}
		proc := p.psnap.FindAndPut(pid)
		if proc != nil {
			e.AppendParam(params.Exe, params.Path, proc.Exe)
			e.AppendParam(params.ProcessName, params.AnsiString, proc.Name)
		}

		return e, false, nil
	}

	return e, true, nil
}

//nolint:unparam
func (p psProcessor) processEvent(e *event.Event) (*event.Event, error) {
	if e.IsCreateProcessInternal() || e.IsProcessRundownInternal() {
		return e, nil
	}

	cmndline := cmdline.New(e.GetParamAsString(params.Cmdline)).
		// get rid of leading/trailing quotes in the executable path
		CleanExe().
		// expand all variations of the SystemRoot environment variable
		ExpandSystemRoot().
		// some system processes are reported without the path in the command line,
		// but we can expand the path from the SystemRoot environment variable
		CompleteSysProc(e.GetParamAsString(params.ProcessName))

	// append executable path parameter
	exe := cmndline.Exeline()
	if exe == "" {
		exe = e.GetParamAsString(params.ProcessName)
	}
	e.AppendParam(params.Exe, params.Path, exe)

	if e.IsTerminateProcess() {
		return e, nil
	}

	// query process start time
	pid := e.Params.MustGetPid()
	started, err := getStartTime(pid, e)
	if err != nil {
		started = e.Timestamp
	}
	e.AppendParam(params.StartTime, params.Time, started)

	return e, nil
}

func (psProcessor) Name() ProcessorType { return Ps }
func (p psProcessor) Close()            {}

func getStartTime(pid uint32, e *event.Event) (time.Time, error) {
	proc, err := windows.OpenProcess(windows.PROCESS_QUERY_LIMITED_INFORMATION, false, pid)
	if err != nil {
		return e.Timestamp, err
	}
	//nolint:errcheck
	defer windows.CloseHandle(proc)
	var (
		ct windows.Filetime
		xt windows.Filetime
		kt windows.Filetime
		ut windows.Filetime
	)
	err = windows.GetProcessTimes(proc, &ct, &xt, &kt, &ut)
	if err != nil {
		return e.Timestamp, err
	}
	return time.Unix(0, ct.Nanoseconds()), nil
}

```

`internal/etw/processors/ps_windows_test.go`:

```go
/*
 * Copyright 2019-2020 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package processors

import (
	"github.com/rabbitstack/fibratus/pkg/event"
	"github.com/rabbitstack/fibratus/pkg/event/params"
	"github.com/rabbitstack/fibratus/pkg/ps"
	pstypes "github.com/rabbitstack/fibratus/pkg/ps/types"
	"github.com/rabbitstack/fibratus/pkg/util/va"
	"github.com/stretchr/testify/mock"
	"github.com/stretchr/testify/require"
	"os"
	"testing"
	"time"
)

func TestPsProcessor(t *testing.T) {
	require.NoError(t, os.Setenv("SystemRoot", "C:\\Windows"))

	var tests = []struct {
		name       string
		e          *event.Event
		psnap      func() *ps.SnapshotterMock
		assertions func(*event.Event, *testing.T, *ps.SnapshotterMock)
	}{
		{
			"create exe parameter from cmdline",
			&event.Event{
				Type: event.CreateProcess,
				Params: event.Params{
					params.Cmdline:   {Name: params.Cmdline, Type: params.UnicodeString, Value: "C:\\Windows\\system32\\svchost.exe -k RPCSS"},
					params.ProcessID: {Name: params.ProcessID, Type: params.PID, Value: uint32(1023)},
				},
			},
			func() *ps.SnapshotterMock {
				psnap := new(ps.SnapshotterMock)
				psnap.On("Write", mock.Anything).Return(nil)
				return psnap
			},
			func(e *event.Event, t *testing.T, psnap *ps.SnapshotterMock) {
				require.True(t, e.Params.Contains(params.Exe))
				require.Equal(t, "C:\\Windows\\system32\\svchost.exe", e.GetParamAsString(params.Exe))
				psnap.AssertNumberOfCalls(t, "Write", 1)
			},
		},
		{
			"complete exe for system procs",
			&event.Event{
				Type: event.CreateProcess,
				Params: event.Params{
					params.Cmdline:     {Name: params.Cmdline, Type: params.UnicodeString, Value: "csrss.exe"},
					params.ProcessName: {Name: params.ProcessName, Type: params.AnsiString, Value: "csrss.exe"},
					params.ProcessID:   {Name: params.ProcessID, Type: params.PID, Value: uint32(676)},
				},
			},
			func() *ps.SnapshotterMock {
				psnap := new(ps.SnapshotterMock)
				psnap.On("Write", mock.Anything).Return(nil)
				return psnap
			},
			func(e *event.Event, t *testing.T, psnap *ps.SnapshotterMock) {
				require.True(t, e.Params.Contains(params.Exe))
				require.Equal(t, "csrss.exe", e.GetParamAsString(params.Cmdline))
				require.Equal(t, "C:\\Windows\\System32\\csrss.exe", e.GetParamAsString(params.Exe))
				psnap.AssertNumberOfCalls(t, "Write", 1)
			},
		},
		{
			"clean quoted executable path",
			&event.Event{
				Type: event.CreateProcess,
				Params: event.Params{
					params.Cmdline:   {Name: params.Cmdline, Type: params.UnicodeString, Value: "\"C:\\Windows\\System32\\smss.exe\""},
					params.ProcessID: {Name: params.ProcessID, Type: params.PID, Value: uint32(760)},
				},
			},
			func() *ps.SnapshotterMock {
				psnap := new(ps.SnapshotterMock)
				psnap.On("Write", mock.Anything).Return(nil)
				return psnap
			},
			func(e *event.Event, t *testing.T, psnap *ps.SnapshotterMock) {
				require.True(t, e.Params.Contains(params.Exe))
				require.Equal(t, "\"C:\\Windows\\System32\\smss.exe\"", e.GetParamAsString(params.Cmdline))
				require.Equal(t, "C:\\Windows\\System32\\smss.exe", e.GetParamAsString(params.Exe))
				psnap.AssertNumberOfCalls(t, "Write", 1)
			},
		},
		{
			"expand SystemRoot in executable path",
			&event.Event{
				Type: event.CreateProcess,
				Params: event.Params{
					params.Cmdline:   {Name: params.Cmdline, Type: params.UnicodeString, Value: `\SystemRoot\System32\smss.exe`},
					params.ProcessID: {Name: params.ProcessID, Type: params.PID, Value: uint32(760)},
				},
			},
			func() *ps.SnapshotterMock {
				psnap := new(ps.SnapshotterMock)
				psnap.On("Write", mock.Anything).Return(nil)
				return psnap
			},
			func(e *event.Event, t *testing.T, psnap *ps.SnapshotterMock) {
				require.True(t, e.Params.Contains(params.Exe))
				require.Equal(t, `\SystemRoot\System32\smss.exe`, e.GetParamAsString(params.Cmdline))
				require.Equal(t, "C:\\Windows\\System32\\smss.exe", e.GetParamAsString(params.Exe))
				psnap.AssertNumberOfCalls(t, "Write", 1)
			},
		},
		{
			"add process start time parameter",
			&event.Event{
				Type:      event.CreateProcess,
				Timestamp: time.Now(),
				Params: event.Params{
					params.Cmdline:   {Name: params.Cmdline, Type: params.UnicodeString, Value: `C:\Program Files\Fibratus\fibratus.exe`},
					params.ProcessID: {Name: params.ProcessID, Type: params.PID, Value: uint32(os.Getpid())},
				},
			},
			func() *ps.SnapshotterMock {
				psnap := new(ps.SnapshotterMock)
				psnap.On("Write", mock.Anything).Return(nil)
				return psnap
			},
			func(e *event.Event, t *testing.T, psnap *ps.SnapshotterMock) {
				require.True(t, e.Params.Contains(params.StartTime))
				require.NotEqual(t, e.Timestamp, e.Params.MustGetTime(params.StartTime))
			},
		},
		{
			"terminate process",
			&event.Event{
				Type: event.TerminateProcess,
				Params: event.Params{
					params.Cmdline:   {Name: params.Cmdline, Type: params.UnicodeString, Value: `\SystemRoot\System32\smss.exe`},
					params.ProcessID: {Name: params.ProcessID, Type: params.PID, Value: uint32(760)},
				},
			},
			func() *ps.SnapshotterMock {
				psnap := new(ps.SnapshotterMock)
				psnap.On("Remove", mock.Anything).Return(nil)
				return psnap
			},
			func(e *event.Event, t *testing.T, psnap *ps.SnapshotterMock) {
				require.True(t, e.Params.Contains(params.Exe))
				require.Equal(t, `\SystemRoot\System32\smss.exe`, e.GetParamAsString(params.Cmdline))
				require.Equal(t, "C:\\Windows\\System32\\smss.exe", e.GetParamAsString(params.Exe))
				psnap.AssertNumberOfCalls(t, "Remove", 1)
				psnap.AssertNotCalled(t, "Write")
			},
		},
		{
			"create thread",
			&event.Event{
				Type: event.CreateThread,
				Params: event.Params{
					params.ProcessID: {Name: params.ProcessID, Type: params.PID, Value: uint32(760)},
					params.ThreadID:  {Name: params.ThreadID, Type: params.TID, Value: uint32(10234)},
				},
			},
			func() *ps.SnapshotterMock {
				psnap := new(ps.SnapshotterMock)
				psnap.On("FindAndPut", uint32(760)).Return(&pstypes.PS{Exe: "C:\\Windows\\System32\\smss.exe"})
				psnap.On("AddThread", mock.Anything).Return(nil)
				return psnap
			},
			func(e *event.Event, t *testing.T, psnap *ps.SnapshotterMock) {
				require.True(t, e.Params.Contains(params.Exe))
				require.Equal(t, "C:\\Windows\\System32\\smss.exe", e.GetParamAsString(params.Exe))
				psnap.AssertNumberOfCalls(t, "AddThread", 1)
			},
		},
		{
			"terminate thread",
			&event.Event{
				Type: event.TerminateThread,
				Params: event.Params{
					params.ProcessID: {Name: params.ProcessID, Type: params.PID, Value: uint32(760)},
					params.ThreadID:  {Name: params.ThreadID, Type: params.TID, Value: uint32(10234)},
				},
			},
			func() *ps.SnapshotterMock {
				psnap := new(ps.SnapshotterMock)
				psnap.On("FindAndPut", uint32(760)).Return(&pstypes.PS{Exe: "C:\\Windows\\System32\\smss.exe"})
				psnap.On("RemoveThread", uint32(760), uint32(10234)).Return(nil)
				return psnap
			},
			func(e *event.Event, t *testing.T, psnap *ps.SnapshotterMock) {
				require.True(t, e.Params.Contains(params.Exe))
				require.Equal(t, "C:\\Windows\\System32\\smss.exe", e.GetParamAsString(params.Exe))
				psnap.AssertNumberOfCalls(t, "RemoveThread", 1)
				psnap.AssertNotCalled(t, "AddThread")
			},
		},
		{
			"open process",
			&event.Event{
				Type: event.OpenProcess,
				Params: event.Params{
					params.ProcessID: {Name: params.ProcessID, Type: params.PID, Value: uint32(760)},
				},
			},
			func() *ps.SnapshotterMock {
				psnap := new(ps.SnapshotterMock)
				psnap.On("FindAndPut", uint32(760)).Return(&pstypes.PS{Name: "smss.exe", Exe: "C:\\Windows\\System32\\smss.exe"})
				return psnap
			},
			func(e *event.Event, t *testing.T, psnap *ps.SnapshotterMock) {
				require.True(t, e.Params.Contains(params.Exe))
				require.True(t, e.Params.Contains(params.ProcessName))
				require.Equal(t, "C:\\Windows\\System32\\smss.exe", e.GetParamAsString(params.Exe))
				require.Equal(t, "smss.exe", e.GetParamAsString(params.ProcessName))
			},
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			psnap := tt.psnap()
			p := newPsProcessor(psnap, va.NewRegionProber())
			var err error
			tt.e, _, err = p.ProcessEvent(tt.e)
			require.NoError(t, err)
			tt.assertions(tt.e, t, psnap)
		})
	}
}

```

`internal/etw/processors/registry_windows.go`:

```go
/*
 * Copyright 2019-2020 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package processors

import (
	"expvar"
	"fmt"
	"github.com/rabbitstack/fibratus/pkg/util/key"
	"golang.org/x/sys/windows"
	"golang.org/x/sys/windows/registry"
	"os"
	"path/filepath"
	"strings"
	"sync"
	"sync/atomic"
	"time"

	"github.com/rabbitstack/fibratus/pkg/event"
	"github.com/rabbitstack/fibratus/pkg/event/params"
	"github.com/rabbitstack/fibratus/pkg/handle"
)

var (
	// ErrReadValue describes an error occurred while reading the registry value
	ErrReadValue = func(key, subkey string, err error) error {
		return fmt.Errorf("unable to read value %s : %v", filepath.Join(key, subkey), err)
	}

	// valueTTL specifies the maximum allowed period for RegSetValueInternal events
	// to remain in the queue
	valueTTL = time.Minute * 2
	// valuePurgerInterval specifies the purge interval for stale values
	valuePurgerInterval = time.Minute

	// kcbCount counts the total KCBs found during the duration of the kernel session
	kcbCount      = expvar.NewInt("registry.kcb.count")
	kcbMissCount  = expvar.NewInt("registry.kcb.misses")
	keyHandleHits = expvar.NewInt("registry.key.handle.hits")

	readValueOps     = expvar.NewInt("registry.read.value.ops")
	capturedDataHits = expvar.NewInt("registry.data.hits")

	handleThrottleCount uint32
)

const (
	maxHandleQueries = 200
)

type registryProcessor struct {
	// keys stores the mapping between the KCB (Key Control Block) and the key name.
	keys  map[uint64]string
	hsnap handle.Snapshotter

	values map[uint32][]*event.Event
	mu     sync.Mutex

	purger *time.Ticker

	quit chan struct{}
}

func newRegistryProcessor(hsnap handle.Snapshotter) Processor {
	// schedule a ticker that resets the throttle count every minute
	tick := time.NewTicker(time.Minute)
	go func() {
		for {
			<-tick.C
			atomic.StoreUint32(&handleThrottleCount, 0)
		}
	}()

	r := &registryProcessor{
		keys:   make(map[uint64]string),
		hsnap:  hsnap,
		values: make(map[uint32][]*event.Event),
		purger: time.NewTicker(valuePurgerInterval),
		quit:   make(chan struct{}, 1),
	}

	go r.housekeep()

	return r
}

func (r *registryProcessor) ProcessEvent(e *event.Event) (*event.Event, bool, error) {
	if e.Category == event.Registry {
		evt, err := r.processEvent(e)
		return evt, false, err
	}
	return e, true, nil
}

func (r *registryProcessor) processEvent(e *event.Event) (*event.Event, error) {
	switch e.Type {
	case event.RegKCBRundown, event.RegCreateKCB:
		khandle := e.Params.MustGetUint64(params.RegKeyHandle)
		r.keys[khandle] = e.Params.MustGetString(params.RegPath)
		kcbCount.Add(1)
	case event.RegDeleteKCB:
		khandle := e.Params.MustGetUint64(params.RegKeyHandle)
		delete(r.keys, khandle)
		kcbCount.Add(-1)
	default:
		if e.IsRegSetValueInternal() {
			// store the event in temporary queue
			r.pushSetValue(e)
			return e, nil
		}

		khandle := e.Params.MustGetUint64(params.RegKeyHandle)
		// we have to obey a straightforward algorithm to connect relative
		// key names to their root keys. If key handle is equal to zero we
		// have a full key name and don't have to go further resolving the
		// missing part. Otherwise, we have to lookup existing KCBs to try
		// finding the matching base key name and concatenate to its relative
		// path. If none of the aforementioned checks are successful, our
		// last resort is to scan process' handles and check if any of the
		// key handles contain the partial key name. In this case we assume
		// the correct key is encountered.
		keyName := e.Params.MustGetString(params.RegPath)
		if khandle != 0 {
			if baseKey, ok := r.keys[khandle]; ok {
				keyName = baseKey + "\\" + keyName
			} else {
				kcbMissCount.Add(1)
				keyName = r.findMatchingKey(e.PID, keyName)
			}
			if err := e.Params.SetValue(params.RegPath, keyName); err != nil {
				return e, err
			}
		}

		if e.IsRegSetValue() {
			// previously stored RegSetValueInternal event
			// is popped from the queue. RegSetValue can
			// be enriched with registry value type/data
			v := r.popSetValue(e)
			if v == nil {
				// try to read captured data from userspace
				goto readValue
			}

			capturedDataHits.Add(1)

			// enrich the event with value data/type parameters
			typ, err := v.Params.GetUint32(params.RegValueType)
			if err == nil {
				e.AppendEnum(params.RegValueType, typ, key.RegistryValueTypes)
			}
			data, err := v.Params.Get(params.RegData)
			if err == nil {
				e.AppendParam(params.RegData, data.Type, data.Value)
			}

			return e, nil
		}

	readValue:
		if !e.IsRegSetValue() || !e.IsSuccess() {
			return e, nil
		}

		// values within hidden keys cannot be read
		if strings.HasSuffix(keyName, "\\") {
			return e, nil
		}

		// get the type/value of the registry key and append to parameters
		rootkey, subkey := key.Format(keyName)
		if rootkey == key.Invalid {
			return e, nil
		}

		readValueOps.Add(1)
		typ, val, err := rootkey.ReadValue(subkey)
		if err != nil {
			errno, ok := err.(windows.Errno)
			if ok && (errno.Is(os.ErrNotExist) || err == windows.ERROR_ACCESS_DENIED) {
				return e, nil
			}
			return e, ErrReadValue(rootkey.String(), keyName, err)
		}
		e.AppendEnum(params.RegValueType, typ, key.RegistryValueTypes)

		switch typ {
		case registry.SZ, registry.EXPAND_SZ:
			e.AppendParam(params.RegData, params.UnicodeString, val)
		case registry.MULTI_SZ:
			e.AppendParam(params.RegData, params.Slice, val)
		case registry.BINARY:
			e.AppendParam(params.RegData, params.Binary, val)
		case registry.QWORD:
			e.AppendParam(params.RegData, params.Uint64, val)
		case registry.DWORD:
			e.AppendParam(params.RegData, params.Uint32, uint32(val.(uint64)))
		}
	}

	return e, nil
}

func (*registryProcessor) Name() ProcessorType { return Registry }
func (r *registryProcessor) Close()            { r.quit <- struct{}{} }

func (r *registryProcessor) findMatchingKey(pid uint32, relativeKeyName string) string {
	// we want to prevent too frequent queries on the process' handles
	// since that can cause significant performance overhead. When throttle
	// count is greater than the max permitted value we'll just return the
	// partial key and hold on querying the handles of target process
	atomic.AddUint32(&handleThrottleCount, 1)
	if atomic.LoadUint32(&handleThrottleCount) > maxHandleQueries {
		return relativeKeyName
	}

	handles, err := r.hsnap.FindHandles(pid)
	if err != nil {
		return relativeKeyName
	}

	for _, h := range handles {
		if h.Type != handle.Key {
			continue
		}
		if strings.HasSuffix(h.Name, relativeKeyName) {
			keyHandleHits.Add(1)
			return h.Name
		}
	}

	return relativeKeyName
}

// pushSetValue stores the internal RegSetValue event
// into per process identifier queue.
func (r *registryProcessor) pushSetValue(e *event.Event) {
	r.mu.Lock()
	defer r.mu.Unlock()
	vals, ok := r.values[e.PID]
	if !ok {
		r.values[e.PID] = []*event.Event{e}
	} else {
		r.values[e.PID] = append(vals, e)
	}
}

// popSetValue traverses the internal RegSetValue queue
// and pops the event if the suffixes match.
func (r *registryProcessor) popSetValue(e *event.Event) *event.Event {
	r.mu.Lock()
	defer r.mu.Unlock()
	vals, ok := r.values[e.PID]
	if !ok {
		return nil
	}

	var v *event.Event
	for i := len(vals) - 1; i >= 0; i-- {
		val := vals[i]
		if strings.HasSuffix(e.GetParamAsString(params.RegPath), val.GetParamAsString(params.RegPath)) {
			v = val
			r.values[e.PID] = append(vals[:i], vals[i+1:]...)
			break
		}
	}

	return v
}

func (r *registryProcessor) valuesSize(pid uint32) int {
	r.mu.Lock()
	defer r.mu.Unlock()
	return len(r.values[pid])
}

func (r *registryProcessor) housekeep() {
	for {
		select {
		case <-r.purger.C:
			r.mu.Lock()
			for pid, vals := range r.values {
				for i, val := range vals {
					if time.Since(val.Timestamp) < valueTTL {
						continue
					}
					r.values[pid] = append(vals[:i], vals[i+1:]...)
				}
				if len(vals) == 0 {
					delete(r.values, pid)
				}
			}
			r.mu.Unlock()
		case <-r.quit:
			return
		}
	}
}

```

`internal/etw/processors/registry_windows_test.go`:

```go
/*
 * Copyright 2019-2020 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package processors

import (
	"github.com/rabbitstack/fibratus/pkg/event"
	"github.com/rabbitstack/fibratus/pkg/event/params"
	"github.com/rabbitstack/fibratus/pkg/handle"
	htypes "github.com/rabbitstack/fibratus/pkg/handle/types"
	"github.com/rabbitstack/fibratus/pkg/util/key"
	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/require"
	"testing"
	"time"
)

func init() {
	valueTTL = time.Millisecond * 150
	valuePurgerInterval = time.Millisecond * 300
}

func TestRegistryProcessor(t *testing.T) {
	var tests = []struct {
		name           string
		e              *event.Event
		setupProcessor func(Processor)
		hsnap          func() *handle.SnapshotterMock
		assertions     func(*event.Event, *testing.T, *handle.SnapshotterMock, Processor)
	}{
		{
			"process KCB rundown",
			&event.Event{
				Type:     event.RegKCBRundown,
				Category: event.Registry,
				Params: event.Params{
					params.RegPath:      {Name: params.RegPath, Type: params.UnicodeString, Value: `\REGISTRY\MACHINE\SYSTEM\ControlSet001\Services\bthserv\Parameters`},
					params.RegKeyHandle: {Name: params.RegKeyHandle, Type: params.Uint64, Value: uint64(18446666033549154696)},
				},
			},
			nil,
			func() *handle.SnapshotterMock {
				hsnap := new(handle.SnapshotterMock)
				return hsnap
			},
			func(e *event.Event, t *testing.T, hsnap *handle.SnapshotterMock, p Processor) {
				registryProcessor := p.(*registryProcessor)
				assert.Contains(t, registryProcessor.keys, uint64(18446666033549154696))
				assert.Equal(t, `\REGISTRY\MACHINE\SYSTEM\ControlSet001\Services\bthserv\Parameters`, registryProcessor.keys[18446666033549154696])
			},
		},
		{
			"process delete KCB",
			&event.Event{
				Type:     event.RegDeleteKCB,
				Category: event.Registry,
				Params: event.Params{
					params.RegPath:      {Name: params.RegPath, Type: params.UnicodeString, Value: `\REGISTRY\MACHINE\SYSTEM\ControlSet001\Services\bthserv\Parameters`},
					params.RegKeyHandle: {Name: params.RegKeyHandle, Type: params.Uint64, Value: uint64(18446666033549154696)},
				},
			},
			func(p Processor) {
				p.(*registryProcessor).keys[18446666033549154696] = `\REGISTRY\MACHINE\SYSTEM\ControlSet001\Services\bthserv\Parameters`
			},
			func() *handle.SnapshotterMock {
				hsnap := new(handle.SnapshotterMock)
				return hsnap
			},
			func(e *event.Event, t *testing.T, hsnap *handle.SnapshotterMock, p Processor) {
				registryProcessor := p.(*registryProcessor)
				assert.Empty(t, registryProcessor.keys)
			},
		},
		{
			"full key name",
			&event.Event{
				Type:     event.RegOpenKey,
				Category: event.Registry,
				Params: event.Params{
					params.RegPath:      {Name: params.RegPath, Type: params.Key, Value: `\REGISTRY\MACHINE\SYSTEM\ControlSet001\Services\bthserv\Parameters`},
					params.RegKeyHandle: {Name: params.RegKeyHandle, Type: params.Uint64, Value: uint64(0)},
				},
			},
			nil,
			func() *handle.SnapshotterMock {
				hsnap := new(handle.SnapshotterMock)
				return hsnap
			},
			func(e *event.Event, t *testing.T, hsnap *handle.SnapshotterMock, p Processor) {
				assert.Equal(t, `HKEY_LOCAL_MACHINE\SYSTEM\ControlSet001\Services\bthserv\Parameters`, e.GetParamAsString(params.RegPath))
			},
		},
		{
			"incomplete key name",
			&event.Event{
				Type:     event.RegOpenKey,
				Category: event.Registry,
				Params: event.Params{
					params.RegPath:      {Name: params.RegPath, Type: params.Key, Value: `Pid`},
					params.RegKeyHandle: {Name: params.RegKeyHandle, Type: params.Uint64, Value: uint64(18446666033549154696)},
				},
			},
			func(p Processor) {
				p.(*registryProcessor).keys[18446666033549154696] = `\REGISTRY\MACHINE\SYSTEM\Setup`
			},
			func() *handle.SnapshotterMock {
				hsnap := new(handle.SnapshotterMock)
				return hsnap
			},
			func(e *event.Event, t *testing.T, hsnap *handle.SnapshotterMock, p Processor) {
				assert.Equal(t, `HKEY_LOCAL_MACHINE\SYSTEM\Setup\Pid`, e.GetParamAsString(params.RegPath))
			},
		},
		{
			"incomplete key name consult handle snapshotter",
			&event.Event{
				Type:     event.RegOpenKey,
				Category: event.Registry,
				PID:      23234,
				Params: event.Params{
					params.RegPath:      {Name: params.RegPath, Type: params.Key, Value: `Pid`},
					params.RegKeyHandle: {Name: params.RegKeyHandle, Type: params.Uint64, Value: uint64(18446666033549154696)},
				},
			},
			nil,
			func() *handle.SnapshotterMock {
				hsnap := new(handle.SnapshotterMock)
				handles := []htypes.Handle{{Type: handle.Key, Name: `HKEY_LOCAL_MACHINE\SYSTEM\Setup\Pid`}}
				hsnap.On("FindHandles", uint32(23234)).Return(handles, nil)
				return hsnap
			},
			func(e *event.Event, t *testing.T, hsnap *handle.SnapshotterMock, p Processor) {
				hsnap.AssertNumberOfCalls(t, "FindHandles", 1)
				assert.Equal(t, `HKEY_LOCAL_MACHINE\SYSTEM\Setup\Pid`, e.GetParamAsString(params.RegPath))
			},
		},
		{
			"process registry set value",
			&event.Event{
				Type:     event.RegSetValue,
				Category: event.Registry,
				PID:      23234,
				Params: event.Params{
					params.RegPath:      {Name: params.RegPath, Type: params.Key, Value: `\REGISTRY\MACHINE\SYSTEM\CurrentControlSet\Control\Windows\Directory`},
					params.RegKeyHandle: {Name: params.RegKeyHandle, Type: params.Uint64, Value: uint64(0)},
				},
			},
			nil,
			func() *handle.SnapshotterMock {
				hsnap := new(handle.SnapshotterMock)
				return hsnap
			},
			func(e *event.Event, t *testing.T, hsnap *handle.SnapshotterMock, p Processor) {
				assert.Equal(t, `HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Windows\Directory`, e.GetParamAsString(params.RegPath))
				assert.Equal(t, `REG_EXPAND_SZ`, e.GetParamAsString(params.RegValueType))
				assert.Equal(t, `%SystemRoot%`, e.GetParamAsString(params.RegData))
			},
		},
		{
			"process registry set value from internal event",
			&event.Event{
				Type:     event.RegSetValue,
				Category: event.Registry,
				PID:      23234,
				Params: event.Params{
					params.RegPath:      {Name: params.RegPath, Type: params.Key, Value: `\REGISTRY\MACHINE\SYSTEM\CurrentControlSet\Control\Windows\Directory`},
					params.RegKeyHandle: {Name: params.RegKeyHandle, Type: params.Uint64, Value: uint64(0)},
				},
			},
			func(p Processor) {
				p.(*registryProcessor).values[23234] = []*event.Event{
					{
						Type:      event.RegSetValueInternal,
						Timestamp: time.Now(),
						Params: event.Params{
							params.RegPath:      {Name: params.RegPath, Type: params.Key, Value: `\SessionId`},
							params.RegData:      {Name: params.RegData, Type: params.UnicodeString, Value: "{ABD9EA10-87F6-11EB-9ED5-645D86501328}"},
							params.RegValueType: {Name: params.RegValueType, Type: params.Enum, Value: uint32(1), Enum: key.RegistryValueTypes},
							params.RegKeyHandle: {Name: params.RegKeyHandle, Type: params.Uint64, Value: uint64(0)}},
					},
					{
						Type:      event.RegSetValueInternal,
						Timestamp: time.Now(),
						Params: event.Params{
							params.RegPath:      {Name: params.RegPath, Type: params.Key, Value: `\Directory`},
							params.RegData:      {Name: params.RegData, Type: params.UnicodeString, Value: "%SYSTEMROOT%"},
							params.RegValueType: {Name: params.RegValueType, Type: params.Enum, Value: uint32(2), Enum: key.RegistryValueTypes},
							params.RegKeyHandle: {Name: params.RegKeyHandle, Type: params.Uint64, Value: uint64(0)}},
					},
				}
			},
			func() *handle.SnapshotterMock {
				hsnap := new(handle.SnapshotterMock)
				return hsnap
			},
			func(e *event.Event, t *testing.T, hsnap *handle.SnapshotterMock, p Processor) {
				assert.Equal(t, `HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Windows\Directory`, e.GetParamAsString(params.RegPath))
				assert.Equal(t, `REG_EXPAND_SZ`, e.GetParamAsString(params.RegValueType))
				assert.Equal(t, `%SYSTEMROOT%`, e.GetParamAsString(params.RegData))
				assert.Equal(t, p.(*registryProcessor).valuesSize(23234), 1)
				time.Sleep(time.Millisecond * 500)
				assert.Equal(t, p.(*registryProcessor).valuesSize(23234), 0)
			},
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			hsnap := tt.hsnap()
			p := newRegistryProcessor(hsnap)
			if tt.setupProcessor != nil {
				tt.setupProcessor(p)
			}
			var err error
			tt.e, _, err = p.ProcessEvent(tt.e)
			require.NoError(t, err)
			tt.assertions(tt.e, t, hsnap, p)
		})
	}
}

```

`internal/etw/source.go`:

```go
/*
 * Copyright 2021-2022 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package etw

import (
	"errors"
	"expvar"
	"fmt"
	"github.com/rabbitstack/fibratus/internal/etw/processors"
	"github.com/rabbitstack/fibratus/pkg/config"
	errs "github.com/rabbitstack/fibratus/pkg/errors"
	"github.com/rabbitstack/fibratus/pkg/event"
	"github.com/rabbitstack/fibratus/pkg/filter"
	"github.com/rabbitstack/fibratus/pkg/handle"
	"github.com/rabbitstack/fibratus/pkg/ps"
	"github.com/rabbitstack/fibratus/pkg/source"
	"github.com/rabbitstack/fibratus/pkg/sys/etw"
	"github.com/rabbitstack/fibratus/pkg/util/multierror"
	log "github.com/sirupsen/logrus"
	"golang.org/x/sys/windows/registry"
	"time"
	"unsafe"
)

const (
	// callbackNext is the return callback value which indicates that callback execution should progress
	callbackNext = uintptr(1)

	// maxBufferSize specifies the maximum buffer size for event tracing session buffer
	maxBufferSize = 1024
	// etwMaxLoggersPath is the registry subkey that contains ETW logger preferences
	etwMaxLoggersPath = `SYSTEM\CurrentControlSet\Control\WMI`
	// etwMaxLoggersValue is the registry value that dictates the maximum number of loggers. Default value is 64 on most systems
	etwMaxLoggersValue = "EtwMaxLoggers"
	maxLoggerNameSize  = 128
	maxLogfileNameSize = 1024
	// maxTracePropsSize must make room for logger name and log file name
	maxTracePropsSize = 2 * (maxLoggerNameSize + maxLogfileNameSize)
)

var (
	// eventsFailed counts the number of events that failed to process
	eventsFailed = expvar.NewMap("eventsource.events.failed")
	// eventsProcessed counts the number of total processed events
	eventsProcessed = expvar.NewInt("eventsource.events.processed")
	// eventsUnknown counts the number of published events which types are not present in the internal catalog
	eventsUnknown = expvar.NewInt("eventsource.events.unknown")
	// eventsExcluded counts the number of excluded events
	eventsExcluded = expvar.NewInt("eventsource.events.excluded")
	// buffersRead amount of buffers fetched from the ETW session
	buffersRead = expvar.NewInt("eventsource.buffers.read")
)

// EventSource is the core component responsible for
// starting ETW tracing sessions and setting up event
// consumers.
type EventSource struct {
	r          *config.RulesCompileResult
	traces     []*Trace
	consumers  []*Consumer
	processors processors.Chain

	errs      chan error
	evts      chan *event.Event
	sequencer *event.Sequencer
	config    *config.Config
	stop      chan struct{}

	psnap ps.Snapshotter
	hsnap handle.Snapshotter

	filter    filter.Filter
	listeners []event.Listener

	isClosed bool
}

// NewEventSource creates the new ETW event source.
func NewEventSource(
	psnap ps.Snapshotter,
	hsnap handle.Snapshotter,
	config *config.Config,
	compiler *config.RulesCompileResult,
) source.EventSource {
	evs := &EventSource{
		r:          compiler,
		traces:     make([]*Trace, 0),
		consumers:  make([]*Consumer, 0),
		processors: processors.NewChain(psnap, hsnap, config),
		errs:       make(chan error, 1000),
		evts:       make(chan *event.Event, 500),
		sequencer:  event.NewSequencer(),
		config:     config,
		stop:       make(chan struct{}),
		psnap:      psnap,
		hsnap:      hsnap,
		listeners:  make([]event.Listener, 0),
	}
	return evs
}

// Open configures and starts traces and event consumers.
func (e *EventSource) Open(config *config.Config) error {
	// set up drop masks if the rule engine
	// is enabled. For any event not present
	// in the rule set, the drop mask instructs
	// to reject the event as soon as it is consumed
	// from the session buffer. Config value takes
	// precedence over rules compile result flag.
	// For example, if the CreateThread event is
	// used by the rules, but thread events are
	// disabled in the config, then thread events
	// are not captured
	if e.r != nil {
		config.EventSource.EnableThreadEvents = config.EventSource.EnableThreadEvents && e.r.HasThreadEvents
		config.EventSource.EnableImageEvents = config.EventSource.EnableImageEvents && e.r.HasImageEvents
		config.EventSource.EnableNetEvents = config.EventSource.EnableNetEvents && e.r.HasNetworkEvents
		config.EventSource.EnableRegistryEvents = config.EventSource.EnableRegistryEvents && (e.r.HasRegistryEvents || (config.Yara.Enabled && !config.Yara.SkipRegistry))
		config.EventSource.EnableFileIOEvents = config.EventSource.EnableFileIOEvents && (e.r.HasFileEvents || (config.Yara.Enabled && !config.Yara.SkipFiles))
		config.EventSource.EnableVAMapEvents = config.EventSource.EnableVAMapEvents && (e.r.HasVAMapEvents || (config.Yara.Enabled && !config.Yara.SkipMmaps))
		config.EventSource.EnableMemEvents = config.EventSource.EnableMemEvents && (e.r.HasMemEvents || (config.Yara.Enabled && !config.Yara.SkipAllocs))
		config.EventSource.EnableDNSEvents = config.EventSource.EnableDNSEvents && e.r.HasDNSEvents
		config.EventSource.EnableAuditAPIEvents = config.EventSource.EnableAuditAPIEvents && e.r.HasAuditAPIEvents
		config.EventSource.EnableThreadpoolEvents = config.EventSource.EnableThreadpoolEvents && e.r.HasThreadpoolEvents
		for _, typ := range event.All() {
			if typ == event.CreateProcess || typ == event.TerminateProcess ||
				typ == event.LoadImage || typ == event.UnloadImage {
				// always allow fundamental events
				continue
			}

			// allow events required for memory/file scanning
			if typ == event.MapViewFile && config.Yara.Enabled && !config.Yara.SkipMmaps {
				continue
			}
			if typ == event.VirtualAlloc && config.Yara.Enabled && !config.Yara.SkipAllocs {
				continue
			}
			if typ == event.CreateFile && config.Yara.Enabled && !config.Yara.SkipFiles {
				continue
			}
			if typ == event.RegSetValue && config.Yara.Enabled && !config.Yara.SkipRegistry {
				continue
			}

			if !e.r.ContainsEvent(typ) {
				config.EventSource.SetDropMask(typ)
			}
		}
	}

	// security telemetry trace hosts all ETW providers but NT Kernel Logger
	trace := NewTrace(etw.SecurityTelemetrySession, config)

	// Windows Kernel Process session permits enriching event state with
	// additional attributes and guaranteeing that any event published by
	// the security telemetry session doesn't miss its respective process
	// from the snapshotter
	trace.AddProvider(etw.WindowsKernelProcessGUID, false, WithKeywords(etw.ProcessKeyword|etw.ImageKeyword), WithCaptureState())

	// in a similar vein, Windows Kernel Registry provider publishes
	// the RegSetValue event with the full captured data for the
	// modified value. This data is used to attach various parameters
	// to the RegSetValue event published by the NT Kernel Logger
	if config.EventSource.EnableRegistryEvents {
		// undocumented ETW feature to enable captured data in RegSetValue events
		val := 0x2
		eventFilterDescriptor := etw.EventFilterDescriptor{
			Ptr:  uintptr(unsafe.Pointer(&val)),
			Size: 4,
		}
		trace.AddProvider(etw.WindowsKernelRegistryGUID, false, WithKeywords(etw.SetValueKeyword), WithEventFilterDescriptors(eventFilterDescriptor))
	}

	if config.EventSource.EnableDNSEvents {
		trace.AddProvider(etw.DNSClientGUID, false)
	}

	if config.EventSource.EnableAuditAPIEvents {
		trace.AddProvider(etw.KernelAuditAPICallsGUID, config.EventSource.StackEnrichment)
	}

	if config.EventSource.EnableThreadpoolEvents {
		// thread pool provider must be configured with
		// stack extensions to activate stack walks events
		var stackexts *StackExtensions
		if e.config.EventSource.StackEnrichment {
			stackexts = NewStackExtensions(config.EventSource)
			stackexts.EnableThreadpoolCallstack()
		}
		trace.AddProvider(etw.ThreadpoolGUID, config.EventSource.StackEnrichment, WithStackExts(stackexts))
	}

	// add security telemetry trace
	e.addTrace(trace)
	// add the core NT Kernel Logger trace
	e.addTrace(NewKernelTrace(config))

	for _, t := range e.traces {
		err := t.Start()
		switch err {
		case errs.ErrTraceAlreadyRunning:
			log.Debugf("%s trace is already running. Trying to restart...", t.Name)
			if err := t.Stop(); err != nil {
				return err
			}
			time.Sleep(time.Millisecond * 100)
			if err := t.Start(); err != nil {
				return multierror.Wrap(errs.ErrRestartTrace, err)
			}
		case errs.ErrTraceNoSysResources:
			// get the number of maximum allowed loggers from registry
			key, err := registry.OpenKey(registry.LOCAL_MACHINE, etwMaxLoggersPath, registry.QUERY_VALUE)
			if err != nil {
				return err
			}
			v, _, err := key.GetIntegerValue(etwMaxLoggersValue)
			if err != nil {
				_ = key.Close()
				return err
			}
			_ = key.Close()
			return fmt.Errorf(`the limit for logging sessions on your system is %d. Please consider increasing this number `+
				`by editing HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\WMI\EtwMaxLoggers key in registry. `+
				`Permissible values are 32 through 256 inclusive, and a reboot is required for any change to take effect`, v)
		default:
			if err != nil {
				return err
			}
		}

		// Init consumer and open the trace for processing
		consumer := NewConsumer(
			e.psnap,
			config,
			e.sequencer,
			e.evts,
			e.processors,
		)
		consumer.SetFilter(e.filter)

		// Attach event listeners
		for _, lis := range e.listeners {
			consumer.q.RegisterListener(lis)
		}
		e.consumers = append(e.consumers, consumer)

		// Open the trace and assign a consumer
		err = t.Open(consumer, e.errs)
		if err != nil {
			return fmt.Errorf("unable to open %s trace: %v", t.Name, err)
		}
		log.Infof("starting [%s] trace processing", t.Name)

		// Instruct the provider to emit state information
		if err := t.CaptureState(); err != nil {
			log.Warnf("unable to capture trace %s state: %v", t.Name, err)
		}

		// Start event processing loop
		errch := make(chan error)
		go t.Process(errch)

		go func(trace *Trace) {
			select {
			case <-e.stop:
				return
			case err := <-errch:
				log.Infof("stopping [%s] trace processing", trace.Name)
				if err != nil && !errors.Is(err, errs.ErrTraceCancelled) {
					e.errs <- fmt.Errorf("unable to process %s trace: %v", trace.Name, err)
				}
			}
		}(t)
	}

	return nil
}

// Close shutdowns all tracing sessions orderly. Firstly,
// the buffers are flushed. Then, the trace is closed to
// signal the event callback to stop consuming more events.
// Finally, the trace is stopped along with all event consumers.
func (e *EventSource) Close() error {
	if e.isClosed {
		return nil
	}

	for _, consumer := range e.consumers {
		if err := consumer.Close(); err != nil {
			log.Warnf("couldn't close consumer: %v", err)
		}
	}

	for _, trace := range e.traces {
		if !trace.IsStarted() {
			continue
		}
		if err := trace.Flush(); err != nil {
			log.Warnf("couldn't flush trace session for [%s]: %v", trace.Name, err)
		}
		time.Sleep(time.Millisecond * 150)
		if err := trace.Close(); err != nil {
			log.Warnf("couldn't close trace session for [%s]: %v", trace.Name, err)
		}
		time.Sleep(time.Millisecond * 250)
		if err := trace.Stop(); err != nil {
			log.Warnf("couldn't stop trace session for [%s]: %v", trace.Name, err)
		}
	}

	close(e.stop)

	e.isClosed = true

	return e.sequencer.Shutdown()
}

// Errors returns the channel where errors are published.
func (e *EventSource) Errors() <-chan error {
	return e.errs
}

// Events returns the buffered event channel.
func (e *EventSource) Events() <-chan *event.Event {
	return e.evts
}

// SetFilter assigns the filter to each consumer. The filter is applied
// to every event captured by the consumer. If the filter expression
// matches, then the consumer enqueues the event to the output queue.
func (e *EventSource) SetFilter(f filter.Filter) {
	e.filter = f
}

// RegisterEventListener registers a new event listener for each consumer queue.
// The event is pushed to the output queue if at least one of the listeners allows.
func (e *EventSource) RegisterEventListener(lis event.Listener) {
	e.listeners = append(e.listeners, lis)
}

func (e *EventSource) addTrace(trace *Trace) {
	e.traces = append(e.traces, trace)
}

```

`internal/etw/source_test.go`:

```go
/*
* Copyright 2019-2020 by Nedim Sabic Sabic
* https://www.fibratus.io
* All Rights Reserved.
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
*  http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
 */
package etw

import (
	"context"
	"fmt"
	"net"
	"net/http"
	"os"
	"os/exec"
	"path/filepath"
	"runtime"
	"slices"
	"strings"
	"syscall"
	"testing"
	"time"
	"unsafe"

	"github.com/rabbitstack/fibratus/internal/evasion"
	"github.com/rabbitstack/fibratus/pkg/config"
	"github.com/rabbitstack/fibratus/pkg/event"
	"github.com/rabbitstack/fibratus/pkg/event/params"
	"github.com/rabbitstack/fibratus/pkg/handle"
	htypes "github.com/rabbitstack/fibratus/pkg/handle/types"
	"github.com/rabbitstack/fibratus/pkg/ps"
	pstypes "github.com/rabbitstack/fibratus/pkg/ps/types"
	"github.com/rabbitstack/fibratus/pkg/symbolize"
	"github.com/rabbitstack/fibratus/pkg/sys"
	"github.com/rabbitstack/fibratus/pkg/sys/etw"
	"github.com/rabbitstack/fibratus/pkg/util/va"
	yara "github.com/rabbitstack/fibratus/pkg/yara/config"
	log "github.com/sirupsen/logrus"
	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/mock"
	"github.com/stretchr/testify/require"
	"golang.org/x/sys/windows"
	"golang.org/x/sys/windows/registry"
)

// MockListener receives the event and does nothing but indicating the event was processed.
type MockListener struct {
	gotEvent bool
}

func (l *MockListener) CanEnqueue() bool { return true }

func (l *MockListener) ProcessEvent(e *event.Event) (bool, error) {
	l.gotEvent = true
	return true, nil
}

func TestEventSourceStartTraces(t *testing.T) {
	psnap := new(ps.SnapshotterMock)
	psnap.On("Write", mock.Anything).Return(nil)
	psnap.On("AddThread", mock.Anything).Return(nil)
	psnap.On("AddModule", mock.Anything).Return(nil)
	psnap.On("AddMmap", mock.Anything).Return(nil)
	psnap.On("RemoveMmap", mock.Anything, mock.Anything).Return(nil)
	psnap.On("RemoveThread", mock.Anything, mock.Anything).Return(nil)
	psnap.On("RemoveModule", mock.Anything, mock.Anything).Return(nil)
	psnap.On("FindModule", mock.Anything).Return(false, nil)
	psnap.On("FindAndPut", mock.Anything).Return(&pstypes.PS{})
	psnap.On("Find", mock.Anything).Return(true, &pstypes.PS{})
	psnap.On("Remove", mock.Anything).Return(nil)

	hsnap := new(handle.SnapshotterMock)
	hsnap.On("FindByObject", mock.Anything).Return(htypes.Handle{}, false)
	hsnap.On("FindHandles", mock.Anything).Return([]htypes.Handle{}, nil)

	var tests = []struct {
		name         string
		cfg          *config.Config
		wantSessions int
		wantFlags    []etw.EventTraceFlags
	}{
		{"start kernel logger session",
			&config.Config{
				EventSource: config.EventSourceConfig{
					EnableThreadEvents: true,
					EnableNetEvents:    true,
					EnableFileIOEvents: true,
					EnableVAMapEvents:  true,
					BufferSize:         1024,
					FlushTimer:         time.Millisecond * 2300,
				},
				Filters: &config.Filters{},
			},
			2,
			[]etw.EventTraceFlags{0x6018203, 0},
		},
		{"start kernel and security telemetry logger sessions",
			&config.Config{
				EventSource: config.EventSourceConfig{
					EnableThreadEvents:   true,
					EnableNetEvents:      true,
					EnableFileIOEvents:   true,
					EnableVAMapEvents:    true,
					EnableHandleEvents:   true,
					EnableRegistryEvents: true,
					BufferSize:           1024,
					FlushTimer:           time.Millisecond * 2300,
					EnableAuditAPIEvents: true,
				},
				Filters: &config.Filters{},
			},
			2,
			[]etw.EventTraceFlags{0x6038203, 0x80000040},
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			tt.cfg.EventSource.Init()
			evs := NewEventSource(psnap, hsnap, tt.cfg, nil)
			require.NoError(t, evs.Open(tt.cfg))
			defer evs.Close()
			assert.Equal(t, tt.wantSessions, len(evs.(*EventSource).traces))

			for _, trace := range evs.(*EventSource).traces {
				require.True(t, trace.Handle().IsValid())
				require.NoError(t, etw.ControlTrace(0, trace.Name, trace.GUID, etw.Query))
				if tt.wantFlags != nil && trace.IsKernelTrace() {
					flags, err := etw.GetTraceSystemFlags(trace.Handle())
					require.NoError(t, err)
					// check enabled system event flags
					require.Equal(t, tt.wantFlags[0], flags[0])
					require.Equal(t, tt.wantFlags[1], flags[4])
				}
			}
		})
	}
}

func TestEventSourceEnableFlagsDynamically(t *testing.T) {
	psnap := new(ps.SnapshotterMock)
	psnap.On("Write", mock.Anything).Return(nil)
	psnap.On("AddThread", mock.Anything).Return(nil)
	psnap.On("AddModule", mock.Anything).Return(nil)
	psnap.On("AddMmap", mock.Anything).Return(nil)
	psnap.On("RemoveMmap", mock.Anything, mock.Anything).Return(nil)
	psnap.On("RemoveThread", mock.Anything, mock.Anything).Return(nil)
	psnap.On("RemoveModule", mock.Anything, mock.Anything).Return(nil)
	psnap.On("FindModule", mock.Anything).Return(false, nil)
	psnap.On("FindAndPut", mock.Anything).Return(&pstypes.PS{})
	psnap.On("Find", mock.Anything).Return(true, &pstypes.PS{})
	psnap.On("Remove", mock.Anything).Return(nil)

	hsnap := new(handle.SnapshotterMock)
	hsnap.On("FindByObject", mock.Anything).Return(htypes.Handle{}, false)
	hsnap.On("FindHandles", mock.Anything).Return([]htypes.Handle{}, nil)

	r := &config.RulesCompileResult{
		HasProcEvents:     true,
		HasImageEvents:    true,
		HasRegistryEvents: true,
		HasNetworkEvents:  true,
		HasFileEvents:     true,
		HasThreadEvents:   false,
		HasVAMapEvents:    true,
		HasAuditAPIEvents: true,
		UsedEvents: []event.Type{
			event.CreateProcess,
			event.LoadImage,
			event.RegCreateKey,
			event.RegSetValue,
			event.CreateFile,
			event.RenameFile,
			event.MapViewFile,
			event.OpenProcess,
			event.ConnectTCPv4,
		},
	}
	cfg := &config.Config{
		EventSource: config.EventSourceConfig{
			EnableThreadEvents:   true,
			EnableRegistryEvents: true,
			EnableImageEvents:    true,
			EnableFileIOEvents:   true,
			EnableAuditAPIEvents: true,
		},
		Filters: &config.Filters{},
	}

	cfg.EventSource.Init()
	evs := NewEventSource(psnap, hsnap, cfg, r)
	require.NoError(t, evs.Open(cfg))
	defer evs.Close()

	require.Len(t, evs.(*EventSource).traces, 2)

	flags := evs.(*EventSource).traces[1].enableFlagsDynamically(cfg.EventSource)

	require.True(t, flags&etw.FileIO != 0)
	require.True(t, flags&etw.Process != 0)
	// rules compile result doesn't have the thread event
	// and thread events are enabled in the config
	require.True(t, flags&etw.Thread == 0)
	require.True(t, flags&etw.ImageLoad != 0)
	require.True(t, flags&etw.Registry != 0)
	// rules compile result has the network event
	// but network I/O is disabled in the config
	require.True(t, flags&etw.NetTCPIP == 0)
	require.True(t, flags&etw.FileIO != 0)
	// rules compile result has MapViewFile event
	// but VAMap is disabled in the config
	require.True(t, flags&etw.VaMap == 0)

	require.False(t, cfg.EventSource.TestDropMask(event.UnloadImage))
	require.True(t, cfg.EventSource.TestDropMask(event.WriteFile))
	require.True(t, cfg.EventSource.TestDropMask(event.UnmapViewFile))
	require.False(t, cfg.EventSource.TestDropMask(event.OpenProcess))
}

func TestEventSourceEnableFlagsDynamicallyWithYaraEnabled(t *testing.T) {
	psnap := new(ps.SnapshotterMock)
	psnap.On("Write", mock.Anything).Return(nil)
	psnap.On("AddThread", mock.Anything).Return(nil)
	psnap.On("AddModule", mock.Anything).Return(nil)
	psnap.On("AddMmap", mock.Anything).Return(nil)
	psnap.On("RemoveMmap", mock.Anything, mock.Anything).Return(nil)
	psnap.On("RemoveThread", mock.Anything, mock.Anything).Return(nil)
	psnap.On("RemoveModule", mock.Anything, mock.Anything).Return(nil)
	psnap.On("FindModule", mock.Anything).Return(false, nil)
	psnap.On("FindAndPut", mock.Anything).Return(&pstypes.PS{})
	psnap.On("Find", mock.Anything).Return(true, &pstypes.PS{})
	psnap.On("Remove", mock.Anything).Return(nil)

	hsnap := new(handle.SnapshotterMock)
	hsnap.On("FindByObject", mock.Anything).Return(htypes.Handle{}, false)
	hsnap.On("FindHandles", mock.Anything).Return([]htypes.Handle{}, nil)

	r := &config.RulesCompileResult{
		HasProcEvents:     true,
		HasImageEvents:    true,
		HasRegistryEvents: true,
		HasNetworkEvents:  true,
		HasFileEvents:     false,
		HasThreadEvents:   false,
		HasAuditAPIEvents: true,
		UsedEvents: []event.Type{
			event.CreateProcess,
			event.LoadImage,
			event.RegCreateKey,
			event.RegSetValue,
			event.RenameFile,
			event.OpenProcess,
			event.ConnectTCPv4,
		},
	}
	cfg := &config.Config{
		EventSource: config.EventSourceConfig{
			EnableThreadEvents:   true,
			EnableRegistryEvents: true,
			EnableImageEvents:    true,
			EnableFileIOEvents:   true,
			EnableAuditAPIEvents: true,
			EnableVAMapEvents:    false,
			EnableMemEvents:      true,
		},
		Filters: &config.Filters{},
		Yara: yara.Config{
			Enabled:    true,
			SkipFiles:  false,
			SkipMmaps:  true,
			SkipAllocs: false,
		},
	}

	cfg.EventSource.Init()
	evs := NewEventSource(psnap, hsnap, cfg, r)
	require.NoError(t, evs.Open(cfg))
	defer evs.Close()

	require.Len(t, evs.(*EventSource).traces, 2)

	flags := evs.(*EventSource).traces[1].enableFlagsDynamically(cfg.EventSource)

	// rules compile result doesn't have file events
	// but Yara file scanning is enabled
	require.True(t, flags&etw.FileIO != 0)
	// VAMap events are not in the ruleset and VaMap is disabled
	require.False(t, flags&etw.VaMap != 0)
	// VirtualAlloc is not present in the ruleset, but Yara
	// alloc scanning is enabled
	require.True(t, flags&etw.VirtualAlloc != 0)

	require.False(t, cfg.EventSource.TestDropMask(event.CreateFile))
	require.True(t, cfg.EventSource.TestDropMask(event.MapViewFile))
	require.False(t, cfg.EventSource.TestDropMask(event.VirtualAlloc))
}

func TestEventSourceRundownEvents(t *testing.T) {
	psnap := new(ps.SnapshotterMock)
	psnap.On("Write", mock.Anything).Return(nil)
	psnap.On("AddThread", mock.Anything).Return(nil)
	psnap.On("AddModule", mock.Anything).Return(nil)
	psnap.On("AddMmap", mock.Anything).Return(nil)
	psnap.On("RemoveMmap", mock.Anything, mock.Anything).Return(nil)
	psnap.On("RemoveThread", mock.Anything, mock.Anything).Return(nil)
	psnap.On("RemoveModule", mock.Anything, mock.Anything).Return(nil)
	psnap.On("FindModule", mock.Anything).Return(false, nil)
	psnap.On("FindAndPut", mock.Anything).Return(&pstypes.PS{})
	psnap.On("Find", mock.Anything).Return(true, &pstypes.PS{})
	psnap.On("Remove", mock.Anything).Return(nil)

	hsnap := new(handle.SnapshotterMock)
	hsnap.On("FindByObject", mock.Anything).Return(htypes.Handle{}, false)
	hsnap.On("FindHandles", mock.Anything).Return([]htypes.Handle{}, nil)

	evsConfig := config.EventSourceConfig{
		EnableThreadEvents:   true,
		EnableImageEvents:    true,
		EnableFileIOEvents:   true,
		EnableNetEvents:      true,
		EnableRegistryEvents: true,
	}
	cfg := &config.Config{
		EventSource: evsConfig,
		CapFile:     "fake.cap", // simulate capture to receive state/rundown events
		Filters:     &config.Filters{},
	}

	cfg.EventSource.Init()
	evs := NewEventSource(psnap, hsnap, cfg, nil)

	l := &MockListener{}
	evs.RegisterEventListener(l)
	require.NoError(t, evs.Open(cfg))
	defer evs.Close()

	rundownsByType := map[event.Type]bool{
		event.ProcessRundown: false,
		event.ThreadRundown:  false,
		event.ImageRundown:   false,
		event.FileRundown:    false,
		event.RegKCBRundown:  false,
	}
	rundownsByHash := make(map[uint64]uint8)
	timeout := time.After(time.Minute)

	for {
		select {
		case e := <-evs.Events():
			if !e.IsRundown() {
				continue
			}
			rundownsByType[e.Type] = true
			rundownsByHash[e.RundownKey()]++
		case err := <-evs.Errors():
			t.Fatalf("FAIL: %v", err)
		case <-timeout:
			t.Logf("got %d rundown events", len(rundownsByHash))
			for key, count := range rundownsByHash {
				if count > 1 {
					t.Fatalf("got more than 1 rundown event for key %d", key)
				}
			}
			for typ, got := range rundownsByType {
				if !got {
					t.Fatalf("no rundown events for %s", typ.String())
				}
			}
			return
		}
	}
}

func TestEventSourceAllEvents(t *testing.T) {
	event.DropCurrentProc = false
	var viewBase uintptr
	var freeAddress uintptr
	var dupHandleID windows.Handle

	var tests = []*struct {
		name      string
		gen       func() error
		want      func(e *event.Event) bool
		completed bool
	}{
		{
			"spawn new process",
			func() error {
				var si windows.StartupInfo
				var pi windows.ProcessInformation
				argv, err := windows.UTF16PtrFromString(filepath.Join(os.Getenv("windir"), "notepad.exe"))
				if err != nil {
					return err
				}
				err = windows.CreateProcess(
					nil,
					argv,
					nil,
					nil,
					true,
					0,
					nil,
					nil,
					&si,
					&pi)
				if err != nil {
					return err
				}
				defer windows.TerminateProcess(pi.Process, 0)
				return nil
			},
			func(e *event.Event) bool {
				return e.IsCreateProcess() && e.Params.MustGetUint32(params.ProcessParentID) == uint32(os.Getpid()) &&
					strings.EqualFold(e.GetParamAsString(params.ProcessName), "notepad.exe")
			},
			false,
		},
		{
			"terminate process",
			nil,
			func(e *event.Event) bool {
				return e.IsTerminateProcess() && strings.EqualFold(e.GetParamAsString(params.ProcessName), "notepad.exe")
			},
			false,
		},
		{
			"load image",
			nil,
			func(e *event.Event) bool {
				img := filepath.Join(os.Getenv("windir"), "System32", "notepad.exe")
				return e.IsLoadImage() && strings.EqualFold(img, e.GetParamAsString(params.ImagePath))
			},
			false,
		},
		{
			"create new file",
			func() error {
				f, err := os.CreateTemp(os.TempDir(), "fibratus-test")
				if err != nil {
					return err
				}
				defer f.Close()
				return nil
			},
			func(e *event.Event) bool {
				return e.CurrentPid() && e.Type == event.CreateFile &&
					strings.HasPrefix(filepath.Base(e.GetParamAsString(params.FilePath)), "fibratus-test") &&
					!e.IsOpenDisposition()
			},
			false,
		},
		{
			"connect socket",
			func() error {
				go func() {
					srv := http.Server{
						Addr: ":18090",
					}
					mux := http.NewServeMux()
					mux.HandleFunc("/", func(writer http.ResponseWriter, request *http.Request) {})
					time.AfterFunc(time.Second*2, func() {
						//nolint:noctx
						resp, _ := http.Get("http://localhost:18090")
						if resp != nil {
							defer func() {
								_ = resp.Body.Close()
							}()
						}
						_ = srv.Shutdown(context.TODO())
					})
					_ = srv.ListenAndServe()
				}()
				return nil
			},
			func(e *event.Event) bool {
				return e.CurrentPid() && (e.Type == event.ConnectTCPv4 || e.Type == event.ConnectTCPv6)
			},
			false,
		},
		{
			"map view section",
			func() error {
				const SecImage = 0x01000000
				const SectionRead = 0x4

				var sec windows.Handle
				var offset uintptr
				var baseViewAddr uintptr
				dll := "_fixtures/yara-test.dll"
				f, err := os.Open(dll)
				if err != nil {
					return err
				}
				defer f.Close()
				stat, err := f.Stat()
				if err != nil {
					return err
				}
				size := stat.Size()
				if err := sys.NtCreateSection(
					&sec,
					SectionRead,
					0,
					uintptr(unsafe.Pointer(&size)),
					windows.PAGE_READONLY,
					SecImage,
					windows.Handle(f.Fd()),
				); err != nil {
					return fmt.Errorf("NtCreateSection: %v", err)
				}
				defer windows.Close(sec)
				err = sys.NtMapViewOfSection(
					sec,
					windows.CurrentProcess(),
					uintptr(unsafe.Pointer(&baseViewAddr)),
					0,
					0,
					uintptr(unsafe.Pointer(&offset)),
					uintptr(unsafe.Pointer(&size)),
					windows.SUB_CONTAINERS_ONLY_INHERIT,
					0,
					windows.PAGE_READONLY)
				if err != nil {
					return fmt.Errorf("NtMapViewOfSection: %v", err)
				}
				return nil
			},
			func(e *event.Event) bool {
				return e.CurrentPid() && e.Type == event.MapViewFile &&
					e.GetParamAsString(params.MemProtect) == "EXECUTE_READWRITE|READONLY" &&
					e.GetParamAsString(params.FileViewSectionType) == "IMAGE" &&
					strings.Contains(e.GetParamAsString(params.FilePath), "_fixtures\\yara-test.dll")
			},
			false,
		},
		{
			"unmap view section",
			func() error {
				const SecCommit = 0x8000000
				const SectionWrite = 0x2
				const SectionRead = 0x4
				const SectionExecute = 0x8
				const SectionRWX = SectionRead | SectionWrite | SectionExecute

				var sec windows.Handle
				var size uint64 = 1024
				var offset uintptr
				if err := sys.NtCreateSection(
					&sec,
					SectionRWX,
					0,
					uintptr(unsafe.Pointer(&size)),
					windows.PAGE_READONLY,
					SecCommit,
					0,
				); err != nil {
					return fmt.Errorf("NtCreateSection: %v", err)
				}
				defer windows.Close(sec)
				err := sys.NtMapViewOfSection(
					sec,
					windows.CurrentProcess(),
					uintptr(unsafe.Pointer(&viewBase)),
					0,
					0,
					uintptr(unsafe.Pointer(&offset)),
					uintptr(unsafe.Pointer(&size)),
					windows.SUB_CONTAINERS_ONLY_INHERIT,
					0,
					windows.PAGE_READONLY)
				if err != nil {
					return fmt.Errorf("NtMapViewOfSection: %v", err)
				}
				return sys.NtUnmapViewOfSection(windows.CurrentProcess(), viewBase)
			},
			func(e *event.Event) bool {
				return e.CurrentPid() && e.Type == event.UnmapViewFile &&
					e.GetParamAsString(params.MemProtect) == "READONLY" &&
					e.Params.MustGetUint64(params.FileViewBase) == uint64(viewBase)
			},
			false,
		},
		{
			"virtual alloc",
			func() error {
				base, err := windows.VirtualAlloc(0, 1024, windows.MEM_COMMIT|windows.MEM_RESERVE, windows.PAGE_EXECUTE_READWRITE)
				if err != nil {
					return err
				}
				defer func() {
					_ = windows.VirtualFree(base, 1024, windows.MEM_RELEASE)
				}()
				return nil
			},
			func(e *event.Event) bool {
				return e.CurrentPid() && e.Type == event.VirtualAlloc &&
					e.GetParamAsString(params.MemAllocType) == "COMMIT|RESERVE" && e.GetParamAsString(params.MemProtectMask) == "RWX"
			},
			false,
		},
		{
			"virtual free",
			func() error {
				var err error
				freeAddress, err = windows.VirtualAlloc(0, 1024, windows.MEM_COMMIT|windows.MEM_RESERVE, windows.PAGE_EXECUTE_READWRITE)
				if err != nil {
					return err
				}
				return windows.VirtualFree(freeAddress, 1024, windows.MEM_DECOMMIT)
			},
			func(e *event.Event) bool {
				return e.CurrentPid() && e.Type == event.VirtualFree &&
					e.GetParamAsString(params.MemAllocType) == "DECOMMIT" && e.Params.MustGetUint64(params.MemBaseAddress) == uint64(freeAddress)
			},
			false,
		},
		{
			"duplicate handle",
			func() error {
				hs := handle.NewSnapshotter(&config.Config{EnumerateHandles: true}, nil)
				handles, err := hs.FindHandles(uint32(os.Getppid()))
				if err != nil {
					return err
				}
				for _, h := range handles {
					if h.Type == handle.Key {
						dupHandleID = h.Num
						break
					}
				}
				assert.False(t, dupHandleID == 0)
				dup, err := handle.Duplicate(dupHandleID, uint32(os.Getppid()), 0)
				if err != nil {
					return err
				}
				defer windows.Close(dup)
				return nil
			},
			func(e *event.Event) bool {
				return e.CurrentPid() && e.Type == event.DuplicateHandle &&
					e.GetParamAsString(params.HandleObjectTypeID) == handle.Key &&
					windows.Handle(e.Params.MustGetUint32(params.HandleSourceID)) == dupHandleID
			},
			false,
		},
		{
			"query dns",
			func() error {
				_, err := net.LookupHost("dns.google")
				return err
			},
			func(e *event.Event) bool {
				return e.CurrentPid() && e.Type == event.QueryDNS && e.IsDNS() &&
					e.Type.Subcategory() == event.DNS &&
					e.GetParamAsString(params.DNSName) == "dns.google" &&
					e.GetParamAsString(params.DNSRR) == "A"
			},
			false,
		},
		{
			"reply dns",
			func() error {
				_, err := net.LookupHost("dns.google")
				return err
			},
			func(e *event.Event) bool {
				return e.CurrentPid() && e.Type == event.ReplyDNS && e.IsDNS() &&
					e.Type.Subcategory() == event.DNS &&
					e.GetParamAsString(params.DNSName) == "dns.google" &&
					e.GetParamAsString(params.DNSRR) == "AAAA" &&
					e.GetParamAsString(params.DNSRcode) == "NOERROR" &&
					e.GetParamAsString(params.DNSAnswers) != ""
			},
			false,
		},
		{
			"set thread context",
			func() error {
				return nil
			},
			func(e *event.Event) bool {
				return e.CurrentPid() && e.Type == event.SetThreadContext && e.GetParamAsString(params.NTStatus) == "Success"
			},
			false,
		},
	}

	psnap := new(ps.SnapshotterMock)
	psnap.On("Write", mock.Anything).Return(nil)
	psnap.On("AddThread", mock.Anything).Return(nil)
	psnap.On("AddModule", mock.Anything).Return(nil)
	psnap.On("AddMmap", mock.Anything).Return(nil)
	psnap.On("RemoveThread", mock.Anything, mock.Anything).Return(nil)
	psnap.On("RemoveModule", mock.Anything, mock.Anything).Return(nil)
	psnap.On("FindModule", mock.Anything).Return(false, nil)
	psnap.On("RemoveMmap", mock.Anything, mock.Anything).Return(nil)
	psnap.On("FindAndPut", mock.Anything).Return(&pstypes.PS{})
	psnap.On("Find", mock.Anything).Return(true, &pstypes.PS{})
	psnap.On("Remove", mock.Anything).Return(nil)

	hsnap := new(handle.SnapshotterMock)
	hsnap.On("FindByObject", mock.Anything).Return(htypes.Handle{}, false)
	hsnap.On("FindHandles", mock.Anything).Return([]htypes.Handle{}, nil)
	hsnap.On("Write", mock.Anything).Return(nil)
	hsnap.On("Remove", mock.Anything).Return(nil)

	evsConfig := config.EventSourceConfig{
		EnableThreadEvents:   true,
		EnableImageEvents:    true,
		EnableFileIOEvents:   true,
		EnableVAMapEvents:    true,
		EnableNetEvents:      true,
		EnableRegistryEvents: true,
		EnableMemEvents:      true,
		EnableHandleEvents:   true,
		EnableDNSEvents:      true,
		EnableAuditAPIEvents: true,
		StackEnrichment:      false,
	}

	evsConfig.Init()
	cfg := &config.Config{EventSource: evsConfig, Filters: &config.Filters{}}
	evs := NewEventSource(psnap, hsnap, cfg, nil)

	l := &MockListener{}
	evs.RegisterEventListener(l)
	require.NoError(t, evs.Open(cfg))
	defer evs.Close()

	time.Sleep(time.Second * 2)

	for _, tt := range tests {
		gen := tt.gen
		if gen != nil {
			require.NoError(t, gen(), tt.name)
		}
	}

	ntests := len(tests)
	timeout := time.After(time.Duration(ntests) * time.Minute)

	for {
		select {
		case e := <-evs.Events():
			for _, tt := range tests {
				if tt.completed {
					continue
				}
				pred := tt.want
				if pred(e) {
					t.Logf("PASS: %s", tt.name)
					tt.completed = true
					ntests--
				}
				if ntests == 0 {
					assert.True(t, l.gotEvent)
					return
				}
			}
		case err := <-evs.Errors():
			t.Fatalf("FAIL: %v", err)
		case <-timeout:
			for _, tt := range tests {
				if !tt.completed {
					t.Logf("FAIL: %s", tt.name)
				}
			}
			t.Fatal("FAIL: TestConsumerEvents")
		}
	}
}

func callstackContainsTestExe(callstack string) bool {
	return strings.Contains(callstack, "etw.test.exe")
}

// NoopPsSnapshotter is the process noop snapshotter  used in tests.
// The main motivation for a noop snapshotter is to reduce the pressure
// on internal mock calls which lead to excessive memory usage when
// the snapshotter Find method is invoked for each incoming event. This
// may create flaky tests.
type NoopPsSnapshotter struct{}

var fakeProc = &pstypes.PS{PID: 111111, Name: "fake.exe"}

func (s *NoopPsSnapshotter) Write(evt *event.Event) error                       { return nil }
func (s *NoopPsSnapshotter) Remove(evt *event.Event) error                      { return nil }
func (s *NoopPsSnapshotter) Find(pid uint32) (bool, *pstypes.PS)                { return true, fakeProc }
func (s *NoopPsSnapshotter) FindAndPut(pid uint32) *pstypes.PS                  { return fakeProc }
func (s *NoopPsSnapshotter) Put(ps *pstypes.PS)                                 {}
func (s *NoopPsSnapshotter) Size() uint32                                       { return 1 }
func (s *NoopPsSnapshotter) Close() error                                       { return nil }
func (s *NoopPsSnapshotter) GetSnapshot() []*pstypes.PS                         { return nil }
func (s *NoopPsSnapshotter) AddThread(evt *event.Event) error                   { return nil }
func (s *NoopPsSnapshotter) AddModule(evt *event.Event) error                   { return nil }
func (s *NoopPsSnapshotter) FindModule(addr va.Address) (bool, *pstypes.Module) { return false, nil }
func (s *NoopPsSnapshotter) FindAllModules() map[string]pstypes.Module          { return nil }
func (s *NoopPsSnapshotter) RemoveThread(pid uint32, tid uint32) error          { return nil }
func (s *NoopPsSnapshotter) RemoveModule(pid uint32, addr va.Address) error     { return nil }
func (s *NoopPsSnapshotter) WriteFromCapture(evt *event.Event) error            { return nil }
func (s *NoopPsSnapshotter) AddMmap(evt *event.Event) error                     { return nil }
func (s *NoopPsSnapshotter) RemoveMmap(pid uint32, addr va.Address) error       { return nil }

func TestCallstackEnrichment(t *testing.T) {
	hsnap := new(handle.SnapshotterMock)
	hsnap.On("FindByObject", mock.Anything).Return(htypes.Handle{}, false)
	hsnap.On("FindHandles", mock.Anything).Return([]htypes.Handle{}, nil)
	hsnap.On("Write", mock.Anything).Return(nil)
	hsnap.On("Remove", mock.Anything).Return(nil)

	// exercise callstack enrichment with a noop
	// process snapshotter. This will make the
	// symbolizer to always fall back to Debug Help
	// API when resolving symbolic information
	nopsnap := new(NoopPsSnapshotter)
	log.Info("test callstack enrichment with noop ps snapshotter")
	testCallstackEnrichment(t, hsnap, nopsnap)

	// now use a real process snapshotter to
	// enrich the callstacks. This way, we
	// should only resort to Debug Help API
	// when the symbol is not found in PE
	// export directory or the module doesn't
	// exist in process state
	cfg := &config.Config{}
	psnap := ps.NewSnapshotter(hsnap, cfg)
	log.Info("test callstack enrichment with real ps snapshotter")
	testCallstackEnrichment(t, hsnap, psnap)
}

func testCallstackEnrichment(t *testing.T, hsnap handle.Snapshotter, psnap ps.Snapshotter) {
	event.DropCurrentProc = false

	var procHandle windows.Handle

	var tests = []*struct {
		name      string
		gen       func() error
		want      func(e *event.Event) bool
		completed bool
	}{
		{
			"create process callstack",
			func() error {
				var si windows.StartupInfo
				var pi windows.ProcessInformation
				argv, err := windows.UTF16PtrFromString(filepath.Join(os.Getenv("windir"), "notepad.exe"))
				if err != nil {
					return err
				}
				err = windows.CreateProcess(
					nil,
					argv,
					nil,
					nil,
					true,
					0,
					nil,
					nil,
					&si,
					&pi)
				if err != nil {
					return err
				}
				procHandle = pi.Process
				return nil
			},
			func(e *event.Event) bool {
				if e.IsCreateProcess() && e.Params.MustGetUint32(params.ProcessParentID) == uint32(os.Getpid()) &&
					strings.EqualFold(e.GetParamAsString(params.ProcessName), "notepad.exe") {
					callstack := e.Callstack.String()
					log.Infof("create process event %s: %s", e.String(), callstack)
					return callstackContainsTestExe(callstack) &&
						strings.Contains(strings.ToLower(callstack), strings.ToLower("\\WINDOWS\\System32\\KERNELBASE.dll!CreateProcessW"))
				}
				return false
			},
			false,
		},
		{
			"load image callstack",
			nil,
			func(e *event.Event) bool {
				if e.IsLoadImage() && filepath.Ext(e.GetParamAsString(params.FilePath)) == ".dll" {
					callstack := e.Callstack.String()
					return strings.Contains(strings.ToLower(callstack), strings.ToLower("\\WINDOWS\\System32\\KERNELBASE.dll!LoadLibraryExW")) &&
						strings.Contains(strings.ToLower(callstack), strings.ToLower("\\WINDOWS\\system32\\ntoskrnl.exe!NtMapViewOfSection"))
				}
				return false
			},
			false,
		},
		{
			"create thread callstack",
			nil,
			func(e *event.Event) bool {
				if e.IsCreateThread() {
					callstack := e.Callstack.String()
					log.Infof("create thread event %s: %s", e.String(), callstack)
					return strings.Contains(strings.ToLower(callstack), strings.ToLower("\\WINDOWS\\SYSTEM32\\ntdll.dll!ZwCreateThreadEx")) ||
						strings.Contains(strings.ToLower(callstack), strings.ToLower("\\WINDOWS\\System32\\KERNEL32.DLL!CreateThread"))
				}
				return false
			},
			false,
		},
		{
			"terminate thread callstack",
			nil,
			func(e *event.Event) bool {
				if e.IsTerminateThread() {
					callstack := e.Callstack.String()
					log.Infof("terminate thread event %s: %s", e.String(), callstack)
					return strings.Contains(strings.ToLower(callstack), strings.ToLower("\\WINDOWS\\SYSTEM32\\ntdll.dll!ZwTerminateThread")) ||
						strings.Contains(strings.ToLower(callstack), strings.ToLower("\\WINDOWS\\SYSTEM32\\ntdll.dll!NtTerminateThread"))
				}
				return false
			},
			false,
		},
		{
			"create registry key callstack",
			func() error {
				var h syscall.Handle
				var d uint32
				path := "Volatile Environment\\CallstackTest"
				err := regCreateKeyEx(syscall.Handle(registry.CURRENT_USER), windows.StringToUTF16Ptr(path),
					0, nil, 1, registry.ALL_ACCESS, nil, &h, &d)
				if err != nil {
					return err
				}
				defer registry.DeleteKey(registry.CURRENT_USER, path)
				return nil
			},
			func(e *event.Event) bool {
				if e.CurrentPid() && e.Type == event.RegCreateKey && e.GetParamAsString(params.RegPath) == "HKEY_CURRENT_USER\\Volatile Environment\\CallstackTest" {
					callstack := e.Callstack.String()
					log.Infof("create key event %s: %s", e.String(), callstack)
					return callstackContainsTestExe(callstack) &&
						(strings.Contains(strings.ToLower(callstack), strings.ToLower("\\WINDOWS\\SYSTEM32\\ntdll.dll!NtCreateKey")) ||
							strings.Contains(strings.ToLower(callstack), strings.ToLower("\\WINDOWS\\SYSTEM32\\ntdll.dll!ZwCreateKey"))) &&
						strings.Contains(strings.ToLower(callstack), strings.ToLower("\\WINDOWS\\System32\\KERNELBASE.dll!RegCreateKeyExW"))
				}
				return false
			},
			false,
		},
		{
			"delete registry key callstack",
			nil,
			func(e *event.Event) bool {
				if e.CurrentPid() && e.Type == event.RegDeleteKey {
					callstack := e.Callstack.String()
					log.Infof("delete key event %s: %s", e.String(), callstack)
					return callstackContainsTestExe(callstack) &&
						strings.Contains(strings.ToLower(callstack), strings.ToLower("\\WINDOWS\\System32\\advapi32.dll!RegDeleteKeyW"))
				}
				return false
			},
			false,
		},
		{
			"set registry value callstack",
			func() error {
				key, err := registry.OpenKey(registry.CURRENT_USER, "Volatile Environment", registry.SET_VALUE)
				if err != nil {
					return err
				}
				defer key.Close()
				defer key.DeleteValue("FibratusCallstack")
				return key.SetStringValue("FibratusCallstack", "Callstack")
			},
			func(e *event.Event) bool {
				if e.CurrentPid() && e.Type == event.RegSetValue && strings.HasSuffix(e.GetParamAsString(params.RegPath), "FibratusCallstack") {
					callstack := e.Callstack.String()
					log.Infof("set value event %s: %s", e.String(), callstack)
					return callstackContainsTestExe(callstack) &&
						strings.Contains(strings.ToLower(callstack), strings.ToLower("\\WINDOWS\\System32\\KERNELBASE.dll!RegSetValueExW")) &&
						(strings.Contains(strings.ToLower(callstack), strings.ToLower("\\WINDOWS\\SYSTEM32\\ntdll.dll!ZwSetValueKey")) ||
							strings.Contains(strings.ToLower(callstack), strings.ToLower("\\WINDOWS\\SYSTEM32\\ntdll.dll!NtSetValueKey")))
				}
				return false
			},
			false,
		},
		{
			"delete registry value callstack",
			nil,
			func(e *event.Event) bool {
				if e.CurrentPid() && e.Type == event.RegDeleteValue {
					callstack := e.Callstack.String()
					log.Infof("delete value event %s: %s", e.String(), callstack)
					return callstackContainsTestExe(callstack) &&
						strings.Contains(strings.ToLower(callstack), strings.ToLower("\\WINDOWS\\System32\\KERNELBASE.dll!RegDeleteValueW"))
				}
				return false
			},
			false,
		},
		{
			"set thread context callstack",
			nil,
			func(e *event.Event) bool {
				return e.Type == event.SetThreadContext &&
					callstackContainsTestExe(e.Callstack.String()) &&
					strings.Contains(strings.ToLower(e.Callstack.String()), strings.ToLower("\\WINDOWS\\System32\\KERNELBASE.dll!SetThreadContext"))
			},
			false,
		},
		{
			"create file callstack",
			func() error {
				f, err := os.CreateTemp(os.TempDir(), "fibratus-callstack")
				if err != nil {
					return err
				}
				defer f.Close()
				return nil
			},
			func(e *event.Event) bool {
				if e.CurrentPid() && e.Type == event.CreateFile &&
					strings.HasPrefix(filepath.Base(e.GetParamAsString(params.FilePath)), "fibratus-callstack") &&
					!e.IsOpenDisposition() {
					callstack := e.Callstack.String()
					log.Infof("create file event %s: %s", e.String(), callstack)
					return callstackContainsTestExe(callstack) &&
						strings.Contains(strings.ToLower(callstack), strings.ToLower("\\WINDOWS\\System32\\KERNELBASE.dll!CreateFileW"))
				}
				return false
			},
			false,
		},
		{
			"create file transacted callstack",
			func() error {
				n, _ := windows.UTF16PtrFromString(filepath.Join(os.TempDir(), "fibratus-file-transacted"))
				t, err := createTransaction()
				if err != nil {
					return err
				}
				defer windows.Close(t)
				h, err := createFileTransacted(n, windows.GENERIC_READ|windows.GENERIC_WRITE, windows.FILE_SHARE_WRITE, nil, 1, 0, 0, t, 0)
				if err != nil {
					return err
				}
				defer windows.Close(h)
				return nil
			},
			func(e *event.Event) bool {
				if e.CurrentPid() && e.Type == event.CreateFile &&
					strings.HasPrefix(filepath.Base(e.GetParamAsString(params.FilePath)), "fibratus-file-transacted") &&
					!e.IsOpenDisposition() {
					callstack := e.Callstack.String()
					log.Infof("create transacted file event %s: %s", e.String(), callstack)
					return callstackContainsTestExe(callstack) &&
						strings.Contains(strings.ToLower(callstack), strings.ToLower("\\WINDOWS\\System32\\KERNEL32.dll!CreateFileTransactedW"))
				}
				return false
			},
			false,
		},
		{
			"virtual alloc callstack",
			func() error {
				_, err := windows.VirtualAlloc(0, 1024, windows.MEM_COMMIT|windows.MEM_RESERVE, windows.PAGE_EXECUTE_READ)
				if err != nil {
					return err
				}
				return nil
			},
			func(e *event.Event) bool {
				if e.CurrentPid() && e.Type == event.VirtualAlloc &&
					e.GetParamAsString(params.MemAllocType) == "COMMIT|RESERVE" {
					callstack := e.Callstack.String()
					log.Infof("virtual alloc event %s: %s", e.String(), callstack)
					return callstackContainsTestExe(callstack) &&
						strings.Contains(strings.ToLower(callstack), strings.ToLower("\\Windows\\System32\\KernelBase.dll!VirtualAlloc"))
				}
				return false
			},
			false,
		},
		//{
		//	"copy file callstack",
		//	func() error {
		//		// TODO: Investigate CopyFile API call not working in Github CI
		//		f, err := os.CreateTemp(os.TempDir(), "fibratus-copy-file")
		//		if err != nil {
		//			return err
		//		}
		//		f.Close()
		//		from, _ := windows.UTF16PtrFromString(f.Name())
		//		to, _ := windows.UTF16PtrFromString(filepath.Join(os.TempDir(), "copied-file"))
		//		return copyFile(from, to)
		//	},
		//	func(e *event.Event) bool {
		//		if e.CurrentPid() && e.Type == event.CreateFile &&
		//			strings.HasPrefix(filepath.Base(e.GetParamAsString(params.FileName)), "copied-file") &&
		//			!e.IsOpenDisposition() {
		//			callstack := e.Callstack.String()
		//			log.Infof("copy file event %s: %s", e.String(), callstack)
		//			return callstackContainsTestExe(callstack) &&
		//				strings.Contains(strings.ToLower(callstack), strings.ToLower("\\WINDOWS\\System32\\KERNELBASE.dll!CopyFileExW"))
		//		}
		//		return false
		//	},
		//	false,
		//},
		{
			"delete file callstack",
			func() error {
				f, err := os.CreateTemp(os.TempDir(), "fibratus-delete")
				if err != nil {
					return err
				}
				f.Close()
				return os.Remove(f.Name())
			},
			func(e *event.Event) bool {
				if e.CurrentPid() && e.Type == event.DeleteFile &&
					strings.HasPrefix(filepath.Base(e.GetParamAsString(params.FilePath)), "fibratus-delete") {
					callstack := e.Callstack.String()
					log.Infof("delete file event %s: %s", e.String(), callstack)
					return callstackContainsTestExe(callstack) &&
						strings.Contains(strings.ToLower(callstack), strings.ToLower("\\WINDOWS\\System32\\KERNELBASE.dll!DeleteFileW"))
				}
				return false
			},
			false,
		},
		{
			"rename file callstack",
			func() error {
				f, err := os.CreateTemp(os.TempDir(), "fibratus-rename")
				if err != nil {
					return err
				}
				f.Close()
				if err := os.Rename(f.Name(), filepath.Join(os.TempDir(), "fibratus-ren")); err != nil {
					return err
				}
				return os.Remove(filepath.Join(os.TempDir(), "fibratus-ren"))
			},
			func(e *event.Event) bool {
				if e.CurrentPid() && e.Type == event.RenameFile &&
					strings.HasPrefix(filepath.Base(e.GetParamAsString(params.FilePath)), "fibratus-rename") {
					callstack := e.Callstack.String()
					log.Infof("rename file event %s: %s", e.String(), callstack)
					return callstackContainsTestExe(callstack) &&
						strings.Contains(strings.ToLower(callstack), strings.ToLower("\\WINDOWS\\System32\\KERNELBASE.dll!MoveFileExW"))
				}
				return false
			},
			false,
		},
		{
			"open process callstack",
			func() error {
				_, err := windows.OpenProcess(windows.PROCESS_VM_READ, false, uint32(os.Getpid()))
				return err
			},
			func(e *event.Event) bool {
				if e.CurrentPid() && e.Type == event.OpenProcess {
					callstack := e.Callstack.String()
					log.Infof("open process event %s: %s", e.String(), callstack)
					return callstackContainsTestExe(callstack) &&
						strings.Contains(strings.ToLower(callstack), strings.ToLower("\\WINDOWS\\System32\\KERNELBASE.dll!OpenProcess"))
				}
				return false
			},
			false,
		},
		{
			"open thread callstack",
			func() error {
				_, err := windows.OpenThread(windows.THREAD_IMPERSONATE, false, windows.GetCurrentThreadId())
				return err
			},
			func(e *event.Event) bool {
				if e.CurrentPid() && e.Type == event.OpenThread {
					callstack := e.Callstack.String()
					log.Infof("open thread event %s: %s", e.String(), callstack)
					return callstackContainsTestExe(callstack) &&
						strings.Contains(strings.ToLower(callstack), strings.ToLower("\\WINDOWS\\System32\\KERNELBASE.dll!OpenThread"))
				}
				return false
			},
			false,
		},
	}

	evsConfig := config.EventSourceConfig{
		EnableThreadEvents:   true,
		EnableImageEvents:    true,
		EnableFileIOEvents:   true,
		EnableRegistryEvents: true,
		EnableMemEvents:      true,
		EnableAuditAPIEvents: true,
		StackEnrichment:      true,
		BufferSize:           1024,
		MinBuffers:           uint32(runtime.NumCPU() * 2),
		MaxBuffers:           uint32((runtime.NumCPU() * 2) + 20),
		ExcludedImages:       []string{"System"},
		ExcludedEvents:       []string{"WriteFile", "ReadFile", "RegOpenKey", "RegCloseKey", "CloseFile"},
		FlushTimer:           1,
	}

	evsConfig.Init()

	cfg := &config.Config{
		EventSource:              evsConfig,
		Filters:                  &config.Filters{},
		SymbolizeKernelAddresses: true,
	}

	evs := NewEventSource(psnap, hsnap, cfg, nil)
	symbolizer := symbolize.NewSymbolizer(symbolize.NewDebugHelpResolver(cfg), psnap, cfg, true)
	defer symbolizer.Close()
	evs.RegisterEventListener(symbolizer)
	require.NoError(t, evs.Open(cfg))
	defer evs.Close()

	time.Sleep(time.Second * 5)

	log.Infof("current process id is [%d]", os.Getpid())

	for _, tt := range tests {
		gen := tt.gen
		log.Infof("executing [%s] test generator", tt.name)
		if gen != nil {
			require.NoError(t, gen(), tt.name)
		}
	}

	ntests := len(tests)
	timeout := time.After(time.Duration(ntests) * time.Minute)
	defer windows.TerminateProcess(procHandle, 0)

	for {
		select {
		case e := <-evs.Events():
			for _, tt := range tests {
				if tt.completed {
					continue
				}
				pred := tt.want
				if pred(e) {
					t.Logf("PASS: %s", tt.name)
					tt.completed = true
					ntests--
				}
				if ntests == 0 {
					return
				}
			}
		case err := <-evs.Errors():
			t.Fatalf("FAIL: %v", err)
		case <-timeout:
			for _, tt := range tests {
				if !tt.completed {
					t.Logf("FAIL: %s", tt.name)
				}
			}
			t.Fatal("FAIL: TestCallstackEnrichment")
		}
	}
}

func containsEvasion(e *event.Event, evasion string) bool {
	m := e.GetMeta(event.EvasionsKey)
	evas, ok := m.([]string)
	if !ok {
		return false
	}
	return slices.Contains(evas, evasion)
}

func TestEvasionScanner(t *testing.T) {
	var tests = []*struct {
		name      string
		gen       func() error
		want      func(e *event.Event) bool
		completed bool
	}{
		{
			"direct syscall",
			func() error {
				cmd := exec.Command("_fixtures/direct-syscall/direct-syscall.exe")
				return cmd.Run()
			},
			func(e *event.Event) bool {
				if strings.Contains(strings.ToLower(e.Callstack.String()), strings.ToLower("direct-syscall.exe")) && e.Type == event.SetThreadContext {
					log.Info(e, e.Callstack)
					return containsEvasion(e, "direct_syscall")
				}
				return false
			},
			false,
		},
		{
			"indirect syscall",
			func() error {
				cmd := exec.Command("_fixtures/indirect-syscall/indirect-syscall.exe")
				return cmd.Run()
			},
			func(e *event.Event) bool {
				if strings.Contains(strings.ToLower(e.Callstack.String()), strings.ToLower("indirect-syscall.exe")) && e.Type == event.SetThreadContext {
					log.Info(e, e.Callstack)
					return containsEvasion(e, "indirect_syscall")
				}
				return false
			},
			false,
		},
	}

	evsConfig := config.EventSourceConfig{
		EnableThreadEvents:   true,
		EnableImageEvents:    true,
		EnableFileIOEvents:   false,
		EnableVAMapEvents:    true,
		EnableNetEvents:      true,
		EnableRegistryEvents: false,
		EnableMemEvents:      false,
		EnableHandleEvents:   false,
		EnableDNSEvents:      false,
		EnableAuditAPIEvents: true,
		StackEnrichment:      true,
	}
	evsConfig.Init()

	hsnap := new(handle.SnapshotterMock)
	hsnap.On("FindByObject", mock.Anything).Return(htypes.Handle{}, false)
	hsnap.On("FindHandles", mock.Anything).Return([]htypes.Handle{}, nil)
	hsnap.On("Write", mock.Anything).Return(nil)
	hsnap.On("Remove", mock.Anything).Return(nil)

	cfg := &config.Config{EventSource: evsConfig, Filters: &config.Filters{}}

	psnap := ps.NewSnapshotter(hsnap, cfg)

	evs := NewEventSource(psnap, hsnap, cfg, nil)

	l := &MockListener{}
	evs.RegisterEventListener(l)

	symbolizer := symbolize.NewSymbolizer(symbolize.NewDebugHelpResolver(cfg), psnap, cfg, true)
	defer symbolizer.Close()
	evs.RegisterEventListener(symbolizer)

	scanner := evasion.NewScanner(
		evasion.Config{
			Enabled:               true,
			EnableDirectSyscall:   true,
			EnableIndirectSyscall: true,
		})
	evs.RegisterEventListener(scanner)

	require.NoError(t, evs.Open(cfg))
	defer evs.Close()

	time.Sleep(time.Second * 2)

	for _, tt := range tests {
		gen := tt.gen
		if gen != nil {
			log.Infof("executing [%s] evasion test generator", tt.name)
			require.NoError(t, gen(), tt.name)
		}
	}

	ntests := len(tests)
	timeout := time.After(time.Duration(ntests) * time.Minute)

	for {
		select {
		case e := <-evs.Events():
			for _, tt := range tests {
				if tt.completed {
					continue
				}
				pred := tt.want
				if pred(e) {
					t.Logf("PASS: %s", tt.name)
					tt.completed = true
					ntests--
				}
				if ntests == 0 {
					return
				}
			}
		case err := <-evs.Errors():
			t.Fatalf("FAIL: %v", err)
		case <-timeout:
			for _, tt := range tests {
				if !tt.completed {
					t.Logf("FAIL: %s", tt.name)
				}
			}
			t.Fatal("FAIL: TestEvasionScanner")
		}
	}
}

var (
	modadvapi32 = windows.NewLazySystemDLL("advapi32.dll")
	kernel32    = windows.NewLazySystemDLL("kernel32.dll")
	ktmW32      = windows.NewLazySystemDLL("KtmW32.dll")

	procRegCreateKeyExW = modadvapi32.NewProc("RegCreateKeyExW")
	//procCopyFile             = kernel32.NewProc("CopyFileW")
	procCreateTransaction    = ktmW32.NewProc("CreateTransaction")
	procCreateFileTransacted = kernel32.NewProc("CreateFileTransactedW")
)

func regCreateKeyEx(key syscall.Handle, subkey *uint16, reserved uint32, class *uint16, options uint32, desired uint32, sa *syscall.SecurityAttributes, result *syscall.Handle, disposition *uint32) (regerrno error) {
	r0, _, _ := syscall.SyscallN(procRegCreateKeyExW.Addr(), uintptr(key), uintptr(unsafe.Pointer(subkey)), uintptr(reserved), uintptr(unsafe.Pointer(class)), uintptr(options), uintptr(desired), uintptr(unsafe.Pointer(sa)), uintptr(unsafe.Pointer(result)), uintptr(unsafe.Pointer(disposition)))
	if r0 != 0 {
		regerrno = syscall.Errno(r0)
	}
	return
}

func createFileTransacted(name *uint16, access uint32, mode uint32, sa *windows.SecurityAttributes, createmode uint32, attrs uint32, templatefile windows.Handle, trans windows.Handle, ver uint8) (handle windows.Handle, err error) {
	r0, _, e1 := syscall.SyscallN(procCreateFileTransacted.Addr(), uintptr(unsafe.Pointer(name)), uintptr(access), uintptr(mode), uintptr(unsafe.Pointer(sa)), uintptr(createmode), uintptr(attrs), uintptr(templatefile), uintptr(trans), uintptr(ver), 0, 0, 0)
	handle = windows.Handle(r0)
	if handle == windows.InvalidHandle {
		err = e1
	}
	return
}

//func copyFile(from *uint16, to *uint16) (regerrno error) {
//	r0, _, _ := procCopyFile.Call(uintptr(unsafe.Pointer(from)), uintptr(unsafe.Pointer(to)), uintptr(1))
//	if r0 != 0 {
//		regerrno = syscall.Errno(r0)
//	}
//	return
//}

func createTransaction() (handle windows.Handle, err error) {
	r0, _, e1 := syscall.SyscallN(procCreateTransaction.Addr(), 0, 0, 0, 0, 0, 0, 0, 0, 0)
	handle = windows.Handle(r0)
	if handle == windows.InvalidHandle {
		err = e1
	}
	return
}

```

`internal/etw/stackext.go`:

```go
/*
 * Copyright 2021-2022 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package etw

import (
	"github.com/rabbitstack/fibratus/pkg/config"
	"github.com/rabbitstack/fibratus/pkg/event"
	"github.com/rabbitstack/fibratus/pkg/sys/etw"
	"golang.org/x/sys/windows"
)

// StackExtensions manages stack tracing enablement
// for particular event or event categories.
type StackExtensions struct {
	ids    []etw.ClassicEventID
	config config.EventSourceConfig
}

// NewStackExtensions creates an empty stack extensions.
func NewStackExtensions(config config.EventSourceConfig) *StackExtensions {
	return &StackExtensions{ids: make([]etw.ClassicEventID, 0), config: config}
}

// AddStackTracing enables stack tracing for the specified event type.
func (s *StackExtensions) AddStackTracing(typ event.Type) {
	if !s.config.TestDropMask(typ) {
		s.ids = append(s.ids, etw.NewClassicEventID(typ.GUID(), typ.HookID()))
	}
}

// AddStackTracingWith enables stack tracing for the specified provider GUID and event hook id.
func (s *StackExtensions) AddStackTracingWith(guid windows.GUID, hookID uint16) {
	if !s.config.TestDropMask(event.TypeFromParts(guid, hookID)) {
		s.ids = append(s.ids, etw.NewClassicEventID(guid, hookID))
	}
}

// EventIds returns all event types eligible for stack tracing.
func (s *StackExtensions) EventIds() []etw.ClassicEventID { return s.ids }

// Empty determines if this stack extensions has registered event identifiers.
func (s *StackExtensions) Empty() bool { return len(s.ids) == 0 }

// EnableProcessCallstack populates the stack identifiers
// with event types eligible for emitting stack walk events
// related to process telemetry, such as creating a process,
// creating/terminating a thread or loading an image into
// process address space.
func (s *StackExtensions) EnableProcessCallstack() {
	s.AddStackTracing(event.CreateProcess)
	if s.config.EnableThreadEvents {
		s.AddStackTracing(event.CreateThread)
		s.AddStackTracing(event.TerminateThread)
	}
	if s.config.EnableImageEvents {
		s.AddStackTracingWith(event.ProcessEventGUID, event.LoadImage.HookID())
	}
}

// EnableFileCallstack populates the stack identifiers
// with event types eligible for publishing call stack
// return addresses for file system activity.
func (s *StackExtensions) EnableFileCallstack() {
	if s.config.EnableFileIOEvents {
		s.AddStackTracing(event.CreateFile)
		s.AddStackTracing(event.DeleteFile)
		s.AddStackTracing(event.RenameFile)
	}
}

// EnableRegistryCallstack populates the stack identifiers
// with event types eligible for publishing call stack
// return addresses for registry operations.
func (s *StackExtensions) EnableRegistryCallstack() {
	if s.config.EnableRegistryEvents {
		s.AddStackTracing(event.RegCreateKey)
		s.AddStackTracing(event.RegDeleteKey)
		s.AddStackTracing(event.RegSetValue)
		s.AddStackTracing(event.RegDeleteValue)
	}
}

// EnableMemoryCallstack enables stack tracing for the memory
// events such as memory allocations.
func (s *StackExtensions) EnableMemoryCallstack() {
	if s.config.EnableMemEvents {
		s.AddStackTracing(event.VirtualAlloc)
	}
}

// EnableThreadpoolCallstack enables stack tracing for thread pool events.
func (s *StackExtensions) EnableThreadpoolCallstack() {
	if s.config.EnableThreadpoolEvents {
		s.AddStackTracing(event.SubmitThreadpoolWork)
		s.AddStackTracing(event.SubmitThreadpoolCallback)
		s.AddStackTracing(event.SetThreadpoolTimer)
	}
}

```

`internal/etw/stackext_test.go`:

```go
/*
 * Copyright 2021-2022 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package etw

import (
	"github.com/rabbitstack/fibratus/pkg/config"
	"github.com/rabbitstack/fibratus/pkg/event"
	"github.com/rabbitstack/fibratus/pkg/sys/etw"
	"github.com/stretchr/testify/assert"
	"testing"
	"time"
)

func TestStackExtensions(t *testing.T) {
	cfg := &config.Config{
		EventSource: config.EventSourceConfig{
			EnableThreadEvents: true,
			EnableNetEvents:    true,
			EnableFileIOEvents: true,
			EnableMemEvents:    true,
			BufferSize:         1024,
			FlushTimer:         time.Millisecond * 2300,
		},
	}

	cfg.EventSource.Init()

	exts := NewStackExtensions(cfg.EventSource)
	assert.Len(t, exts.EventIds(), 0)

	exts.EnableProcessCallstack()
	exts.EnableRegistryCallstack()
	exts.EnableFileCallstack()
	exts.EnableMemoryCallstack()

	assert.Len(t, exts.EventIds(), 7)
	assert.Contains(t, exts.EventIds(), etw.ClassicEventID{GUID: event.ProcessEventGUID, Type: uint8(event.CreateProcess.HookID())})
	assert.Contains(t, exts.EventIds(), etw.ClassicEventID{GUID: event.ThreadEventGUID, Type: uint8(event.CreateThread.HookID())})
	assert.Contains(t, exts.EventIds(), etw.ClassicEventID{GUID: event.ThreadEventGUID, Type: uint8(event.TerminateThread.HookID())})
	assert.Contains(t, exts.EventIds(), etw.ClassicEventID{GUID: event.FileEventGUID, Type: uint8(event.CreateFile.HookID())})
	assert.Contains(t, exts.EventIds(), etw.ClassicEventID{GUID: event.FileEventGUID, Type: uint8(event.RenameFile.HookID())})
	assert.Contains(t, exts.EventIds(), etw.ClassicEventID{GUID: event.FileEventGUID, Type: uint8(event.DeleteFile.HookID())})
	assert.Contains(t, exts.EventIds(), etw.ClassicEventID{GUID: event.MemEventGUID, Type: uint8(event.VirtualAlloc.HookID())})
}

```

`internal/etw/trace.go`:

```go
/*
 * Copyright 2021-2022 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package etw

import (
	"fmt"
	"github.com/rabbitstack/fibratus/pkg/config"
	errs "github.com/rabbitstack/fibratus/pkg/errors"
	"github.com/rabbitstack/fibratus/pkg/sys/etw"
	log "github.com/sirupsen/logrus"
	"golang.org/x/sys/windows"
	"runtime"
	"time"
	"unsafe"
)

// initEventTraceProps builds the trace properties descriptor which
// influences the behaviour of event publishing to the trace session
// buffers.
func initEventTraceProps(c config.EventSourceConfig) etw.EventTraceProperties {
	bufferSize := c.BufferSize
	if bufferSize > maxBufferSize {
		bufferSize = maxBufferSize
	}
	// validate min/max buffers. The minimal
	// number of buffers is 2 per CPU logical core
	minBuffers := c.MinBuffers
	if minBuffers < uint32(runtime.NumCPU()*2) {
		minBuffers = uint32(runtime.NumCPU() * 2)
	}
	maxBuffers := c.MaxBuffers
	maxBuffersAllowed := minBuffers + 20
	if maxBuffers > maxBuffersAllowed {
		maxBuffers = maxBuffersAllowed
	}
	if minBuffers > maxBuffers {
		minBuffers = maxBuffers - 20
	}
	flushTimer := c.FlushTimer
	if flushTimer < time.Second {
		flushTimer = time.Second
	}

	mode := uint32(etw.ProcessTraceModeRealtime)

	return etw.EventTraceProperties{
		Wnode: etw.WnodeHeader{
			BufferSize:    uint32(unsafe.Sizeof(etw.EventTraceProperties{})) + maxTracePropsSize,
			Flags:         etw.WnodeTraceFlagGUID,
			ClientContext: 1, // QPC clock resolution
		},
		BufferSize:     bufferSize,
		LogFileMode:    mode,
		MinimumBuffers: minBuffers,
		MaximumBuffers: maxBuffers,
		FlushTimer:     uint32(flushTimer.Seconds()),
	}
}

// ProviderInfo describes ETW provider metadata.
type ProviderInfo struct {
	// GUID is the globally unique identifier for the
	// ETW provider for which the session is started.
	GUID windows.GUID
	// Keywords is the bitmask of keywords that determine
	// the categories of events for the provider to emit.
	// The provider typically writes an event if the event's
	// keyword bits match any of the bits set in this value
	// or if the event has no keyword bits set. Only relevant
	// for providers that are enabled via etw.EnableProvider
	// API.
	Keywords uint64
	// EnableStacks indicates if callstacks are enabled for
	// this provider.
	EnableStacks bool
	// CaptureState requests that the provider log its state
	// information, such as rundown events.
	CaptureState bool
	// stackExtensions manager stack tracing enablement.
	// For each event present in the stack identifiers,
	// the StackWalk event is published by the provider.
	stackExtensions        *StackExtensions
	eventFilterDescriptors []etw.EventFilterDescriptor
}

func (p *ProviderInfo) HasStackExtensions() bool {
	return p.stackExtensions != nil && !p.stackExtensions.Empty()
}

func (p *ProviderInfo) HasEventFilterDescriptors() bool {
	return len(p.eventFilterDescriptors) > 0
}

// Trace is the essential building block for controlling
// trace sessions and configuring event consumers. Such
// operations include starting, stopping, and flushing
// trace sessions, and opening the trace for processing
// and event consumption. Trace can be configured to
// operate a single ETW provider, or it can act as a
// container for multiple provider sessions.
type Trace struct {
	// Name represents the unique tracing session name.
	Name string
	// GUID is the globally unique identifier for the
	// ETW provider for which the session is started.
	GUID windows.GUID

	// Providers is the list of providers to be run inside
	// the tracing session. For each provider, the GUID,
	// keywords and other parameters can be specified.
	Providers []ProviderInfo

	// stackExtensions manages stack tracing enablement.
	// For each event present in the stack identifiers,
	// the StackWalk event is published by the provider.
	stackExtensions *StackExtensions

	// startHandle is the session handle returned by the
	// etw.StartTrace function. This handle is
	// used for subsequent calls to other API
	// functions, but also to indicate if the
	// trace was started successfully. In this
	// case the trace handle is different from
	// zero.
	startHandle etw.TraceHandle
	// openHandle is the trace processing handle obtained
	// after the call to etw.OpenTrace function.
	// This handle is later handed over to the
	// trace processing function to consume events
	// from the real-time tracing session.
	openHandle etw.TraceHandle
	// config represents global configuration store
	config *config.Config
	// consumer is the instance of the event consumer
	// responsible for processing events for the trace
	consumer *Consumer
	// errs receives event consumer errors
	errs chan error
}

type opts struct {
	stackexts              *StackExtensions
	keywords               uint64
	captureState           bool
	eventFilterDescriptors []etw.EventFilterDescriptor
}

// Option represents the option for the trace.
type Option func(o *opts)

// WithStackExts sets the stack extensions.
func WithStackExts(stackexts *StackExtensions) Option {
	return func(o *opts) {
		o.stackexts = stackexts
	}
}

// WithKeywords sets the bitmask of keywords that determine
// the categories of events for the provider to emit.
func WithKeywords(keywords uint64) Option {
	return func(o *opts) {
		o.keywords = keywords
	}
}

// WithCaptureState indicates that the provider should
// emit its state information.
func WithCaptureState() Option {
	return func(o *opts) {
		o.captureState = true
	}
}

// WithEventFilterDescriptors assigns filters to be passed
// to the provider's enable callback function.
func WithEventFilterDescriptors(descriptors ...etw.EventFilterDescriptor) Option {
	return func(o *opts) {
		o.eventFilterDescriptors = descriptors
	}
}

// NewKernelTrace creates a new NT Kernel Logger trace.
func NewKernelTrace(config *config.Config) *Trace {
	t := &Trace{Name: etw.KernelLoggerSession, GUID: etw.KernelTraceControlGUID, stackExtensions: NewStackExtensions(config.EventSource), config: config}
	t.enableCallstacks()
	return t
}

// NewTrace creates a new trace that can host various ETW provider sessions.
// The providers to be run inside the session can be given in the last argument
// or added by the AddProvider method.
func NewTrace(name string, config *config.Config, providers ...ProviderInfo) *Trace {
	t := &Trace{Name: name, config: config, Providers: make([]ProviderInfo, 0)}
	t.Providers = providers
	return t
}

// AddProvider adds a new provider to the multi trace session
// with optional parameters that influence the provider.
func (t *Trace) AddProvider(guid windows.GUID, enableStacks bool, options ...Option) {
	var opts opts

	for _, opt := range options {
		opt(&opts)
	}

	t.Providers = append(
		t.Providers,
		ProviderInfo{GUID: guid, Keywords: opts.keywords, EnableStacks: enableStacks, CaptureState: opts.captureState, stackExtensions: opts.stackexts, eventFilterDescriptors: opts.eventFilterDescriptors},
	)
}

// HasProviders determines if this trace contains providers.
func (t *Trace) HasProviders() bool { return len(t.Providers) > 0 }

// IsGUIDEmpty determines if the provider GUID is empty.
func (t *Trace) IsGUIDEmpty() bool {
	return t.GUID.Data1 == 0 &&
		t.GUID.Data2 == 0 &&
		t.GUID.Data3 == 0 &&
		t.GUID.Data4 == [8]byte{}
}

func (t *Trace) enableCallstacks() {
	if t.IsKernelTrace() {
		t.stackExtensions.EnableProcessCallstack()

		t.stackExtensions.EnableRegistryCallstack()

		t.stackExtensions.EnableFileCallstack()

		t.stackExtensions.EnableMemoryCallstack()
	}
}

// Start registers and starts an event tracing session.
// The session remains active until the session is stopped,
// the machine is restarted, or an error occurs that would
// interrupt the session.
func (t *Trace) Start() error {
	if len(t.Name) > maxLoggerNameSize {
		return fmt.Errorf("trace name [%s] is too long", t.Name)
	}

	if !t.IsGUIDEmpty() && t.HasProviders() {
		return fmt.Errorf("%s trace has the root GUID set but providers are not empty", t.Name)
	}

	cfg := t.config.EventSource
	props := initEventTraceProps(cfg)
	flags := t.enableFlagsDynamically(cfg)

	if t.IsKernelTrace() {
		props.EnableFlags = flags
		props.Wnode.GUID = t.GUID
		log.Debugf("starting kernel trace with %q event flags", props.EnableFlags)
	}

	log.Debugf("starting trace [%s]", t.Name)

	var err error
	t.startHandle, err = etw.StartTrace(
		t.Name,
		props,
	)
	if err != nil {
		return err
	}
	if !t.startHandle.IsValid() {
		return errs.ErrInvalidTrace
	}

	if t.IsKernelTrace() {
		handle := t.startHandle
		// poorly documented ETW feature that allows for enabling an extended set of
		// kernel event tracing flags. According to the MSDN documentation, aside from
		// invoking `EventTraceProperties` function to enable object manager tracking
		// the `EventTraceProperties` structure's `EnableFlags` member needs to be set
		// to PERF_OB_HANDLE (0x80000040). This actually results in an erroneous trace start.
		// The documentation neither specifies how the function should be called, group mask
		// array with its 4th element set to 0x80000040.
		sysTraceFlags := make([]etw.EventTraceFlags, 8)
		// when we call `TraceSetInformation` with event empty group mask reserved for the
		// flags that are bitvectored into `EventTraceProperties` structure's `EnableFlags` field,
		// it will trigger the arrival of rundown events including open file objects and
		// registry keys that are very valuable for us to construct the initial snapshot of
		// these system resources and let us build the state machine
		if err := etw.SetTraceSystemFlags(handle, sysTraceFlags); err != nil {
			log.Warnf("unable to set empty system flags: %v", err)
			return nil
		}

		sysTraceFlags[0] = flags

		// enable object manager tracking
		if cfg.EnableHandleEvents {
			sysTraceFlags[4] = etw.Handle
		}
		// enable stack enrichment
		if cfg.StackEnrichment {
			if err := etw.EnableStackTracing(handle, t.stackExtensions.EventIds()); err != nil {
				return fmt.Errorf("fail to enable kernel callstack tracing: %v", err)
			}
		}
		// call again to enable all kernel events. Just to recap. The first call to
		// `TraceSetInformation` with empty group masks activates rundown events,
		// while this second call enables the rest of the kernel events specified in flags.
		return etw.SetTraceSystemFlags(handle, sysTraceFlags)
	}

	// For each provider in multi trace, the call to etw.EnableTrace is
	// needed to configure how an ETW provider publishes events to the
	// trace session.
	// For instance, if stack enrichment is enabled, it is necessary to
	// instruct the provider to emit stack addresses in the extended
	// data item section when writing events to the session buffers
	for _, provider := range t.Providers {
		switch {
		case provider.EnableStacks && provider.HasStackExtensions():
			if err := etw.EnableStackTracing(t.startHandle, provider.stackExtensions.EventIds()); err != nil {
				return fmt.Errorf("fail to enable provider callstack tracing: %v", err)
			}
			if err := etw.EnableTrace(provider.GUID, t.startHandle, provider.Keywords); err != nil {
				return err
			}
		case provider.EnableStacks || provider.HasEventFilterDescriptors():
			opts := etw.EnableTraceOpts{
				WithStacktrace:         provider.EnableStacks,
				EventFilterDescriptors: provider.eventFilterDescriptors,
			}
			if err := etw.EnableTraceWithOpts(provider.GUID, t.startHandle, provider.Keywords, opts); err != nil {
				return err
			}
		default:
			if err := etw.EnableTrace(provider.GUID, t.startHandle, provider.Keywords); err != nil {
				return err
			}
		}
	}

	return nil
}

// IsStarted indicates if the trace is started successfully.
func (t *Trace) IsStarted() bool { return t.startHandle.IsValid() }

// IsRunning determines if the current trace is running.
func (t *Trace) IsRunning() bool { return etw.ControlTrace(0, t.Name, t.GUID, etw.Query) == nil }

// Handle returns the trace handle returned by etw.StartTrace function.
func (t *Trace) Handle() etw.TraceHandle {
	return t.startHandle
}

// Stop stops the event tracing session.
func (t *Trace) Stop() error {
	return etw.StopTrace(t.Name, t.GUID)
}

// Flush causes an event tracing session to immediately deliver
// buffered events for the specified session. By default, an event
// tracing session will deliver events when the buffer is full,
// the session's flusher timer expires, or the session is closed.
func (t *Trace) Flush() error {
	return etw.FlushTrace(t.Name, t.GUID)
}

// Open opens an ETW trace processing handle for consuming events
// from an ETW real-time trace. It specifies the callbacks the consumer
// wants to use to receive the events or trace buffer statistics. The
// first callback function that receives buffer-related
// statistics for each buffer ETW flushes. ETW calls this callback after
// it delivers all the events in the buffer. The second callback function
// that ETW calls for each event in the buffer.
func (t *Trace) Open(consumer *Consumer, errs chan error) error {
	t.consumer = consumer
	t.errs = errs
	logfile := etw.NewEventTraceLogfile(t.Name)
	logfile.SetEventCallback(windows.NewCallback(t.processEventCallback))
	logfile.SetBufferCallback(windows.NewCallback(t.bufferStatsCallback))
	logfile.SetModes(etw.ProcessTraceModeRealtime | etw.ProcessTraceModeEventRecord)

	t.openHandle = etw.OpenTrace(logfile)
	if !t.openHandle.IsValid() {
		return fmt.Errorf("unable to open %s trace: %v", t.Name, windows.GetLastError().Error())
	}
	return nil
}

// processEventCallback is the event callback function signature that is called each time
// a new event is available on the session buffer. It does the heavy lifting of parsing incoming
// ETW events from raw data buffers, building the state machine, and pushing events to the channel.
func (t *Trace) processEventCallback(ev *etw.EventRecord) uintptr {
	if t.consumer == nil {
		panic("consumer is nil")
	}
	if err := t.consumer.ProcessEvent(ev); err != nil {
		t.errs <- err
		eventsFailed.Add(err.Error(), 1)
	}
	return callbackNext
}

// bufferStatsCallback is periodically triggered by ETW subsystem for the purpose of reporting
// buffer statistics, such as the number of buffers processed.
func (t *Trace) bufferStatsCallback(logfile *etw.EventTraceLogfile) uintptr {
	buffersRead.Add(int64(logfile.BuffersRead))
	return callbackNext
}

// Process delivers events from the ETW trace processing sessions
// to the consumer. This method attempts to deliver events in order
// based on the event's timestamp - it tries to deliver events oldest
// to newest. In certain cases, events might deliver events out of order.
// The current thread is blocked upon calling this method, so be sure
// to spawn a dedicated goroutine and use the provided error channel to
// stream any errors.
func (t *Trace) Process(ch chan error) {
	ch <- etw.ProcessTrace(t.openHandle)
}

// Close closes a trace processing session that was initiated
// with the etw.OpenTrace function. This method should be called
// after the respective session processing worker is started.
func (t *Trace) Close() error {
	return etw.CloseTrace(t.openHandle)
}

// CaptureState forces the provider to publish state
// information such as rundown events.
func (t *Trace) CaptureState() error {
	for _, provider := range t.Providers {
		if !provider.CaptureState {
			continue
		}
		if err := etw.CaptureProviderState(provider.GUID, t.startHandle); err != nil {
			return fmt.Errorf("unable to capture %s provider state: %v", provider.GUID, err)
		}
	}
	return nil
}

// IsKernelTrace determines if this is the system logger trace.
func (t *Trace) IsKernelTrace() bool { return t.GUID == etw.KernelTraceControlGUID }

// enableFlagsDynamically crafts the system logger event mask
// depending on the compiled rules result or the config state.
// System logger flags is a bitmask that indicates which kernel events
// are delivered to the consumer when system logger session is
// started. At minimum, process events are published to the trace
// session as they represent the foundation for building the state
// machine. Note these flags are relevant to system logger traces
// and initializing the EnableFlags field of the etw.EventTraceProperties
// structure for non-system logger providers will result in an error.
func (t *Trace) enableFlagsDynamically(config config.EventSourceConfig) etw.EventTraceFlags {
	var flags etw.EventTraceFlags

	if !t.IsKernelTrace() {
		return flags
	}

	flags |= etw.Process

	if config.EnableThreadEvents {
		flags |= etw.Thread
	}
	if config.EnableImageEvents {
		flags |= etw.ImageLoad
	}
	if config.EnableNetEvents {
		flags |= etw.NetTCPIP
	}
	if config.EnableRegistryEvents {
		flags |= etw.Registry
	}
	if config.EnableFileIOEvents {
		flags |= etw.DiskFileIO | etw.FileIO | etw.FileIOInit
	}
	if config.EnableVAMapEvents {
		flags |= etw.VaMap
	}
	if config.EnableMemEvents {
		flags |= etw.VirtualAlloc
	}
	if config.EnableRegistryEvents {
		flags |= etw.Registry
	}

	return flags
}

```

`internal/etw/trace_test.go`:

```go
/*
 * Copyright 2021-2022 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package etw

import (
	"github.com/rabbitstack/fibratus/pkg/config"
	"github.com/stretchr/testify/require"
	"testing"
	"time"
)

func TestStartTrace(t *testing.T) {
	cfg := &config.Config{
		EventSource: config.EventSourceConfig{
			EnableThreadEvents: true,
			EnableNetEvents:    true,
			EnableFileIOEvents: true,
			BufferSize:         1024,
			FlushTimer:         time.Millisecond * 2300,
		},
	}

	cfg.EventSource.Init()

	trace := NewKernelTrace(cfg)
	require.NoError(t, trace.Start())
	require.True(t, trace.IsStarted())
	defer trace.Stop()
	require.Error(t, trace.Start())
	require.True(t, trace.IsRunning())
}

```

`internal/evasion/config.go`:

```go
/*
 * Copyright 2021-present by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package evasion

import (
	"github.com/spf13/pflag"
	"github.com/spf13/viper"
)

const (
	enabled               = "evasion.enabled"
	enableDirectSyscall   = "evasion.enable-direct-syscall"
	enableIndirectSyscall = "evasion.enable-indirect-syscall"
)

// Config contains the settings that influence the behaviour of the evasion scanner.
type Config struct {
	// Enabled indicates if evasion detections are enabled global-wise.
	Enabled bool `json:"enabled" yaml:"enabled"`
	// EnableDirectSyscall indicates if direct syscall evasion detection is enabled.
	EnableDirectSyscall bool `json:"enable-direct-syscall" yaml:"enable-direct-syscall"`
	// EnableIndirectSyscall indicates if indirect syscall evasion detection is enabled.
	EnableIndirectSyscall bool `json:"enable-indirect-syscall" yaml:"enable-indirect-syscall"`
}

// InitFromViper initializes evasion config from Viper.
func (c *Config) InitFromViper(v *viper.Viper) {
	c.Enabled = v.GetBool(enabled)
	c.EnableDirectSyscall = v.GetBool(enableDirectSyscall)
	c.EnableIndirectSyscall = v.GetBool(enableIndirectSyscall)
}

// AddFlags adds evasion config flags to the set.
func AddFlags(flags *pflag.FlagSet) {
	flags.Bool(enabled, true, "Indicates if evasion detections are enabled global-wise")
	flags.Bool(enableDirectSyscall, true, "Indicates if direct syscall evasion detection is enabled")
	flags.Bool(enableIndirectSyscall, true, "Indicates if indirect syscall evasion detection is enabled")
}

```

`internal/evasion/direct_syscall.go`:

```go
/*
 * Copyright 2021-present by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package evasion

import (
	"path/filepath"
	"strings"

	"github.com/rabbitstack/fibratus/pkg/event"
)

// directSyscall direct syscall evasion refers to a technique where
// adversaries bypass traditional user-mode API monitoring and security
// hooks by invoking system calls directly, but does so in a way that
// evades detection or analysis.
//
// A direct syscall bypasses Windows API functions and calls the underlying
// system call directly using the syscall instruction, skipping the NTDLL
// stub that normally performs the transition to kernel mode.
type directSyscall struct{}

func NewDirectSyscall() Evasion {
	return &directSyscall{}
}

func (d *directSyscall) Eval(e *event.Event) (bool, error) {
	if e.Callstack.IsEmpty() {
		return false, nil
	}

	frame := e.Callstack.FinalUserspaceFrame()
	if frame == nil {
		return false, nil
	}

	if frame.IsUnbacked() {
		return false, nil
	}

	mod := filepath.Base(strings.ToLower(frame.Module))

	// check if the last user space frame is originated
	// from the allowed modules such as the native NTDLL
	// module. If that's not the case, the process is
	// likely invoking a direct syscall
	switch mod {
	case "ntdll.dll", "win32.dll", "win32u.dll", "wow64win.dll", "wow64cpu.dll":
		return false, nil
	default:
		return true, nil
	}
}

func (*directSyscall) Type() Type { return DirectSyscall }

func (*directSyscall) SetMask(e *event.Event) {
	e.Evasions |= uint32(DirectSyscall)
}

```

`internal/evasion/direct_syscall_test.go`:

```go
/*
 * Copyright 2021-present by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package evasion

import (
	"github.com/rabbitstack/fibratus/pkg/callstack"
	"github.com/rabbitstack/fibratus/pkg/event"
	"github.com/rabbitstack/fibratus/pkg/event/params"
	"github.com/rabbitstack/fibratus/pkg/fs"
	"github.com/stretchr/testify/require"
	"testing"
	"time"
)

func TestDirectSyscall(t *testing.T) {
	var tests = []struct {
		evt     *event.Event
		matches bool
	}{
		{&event.Event{
			Type:      event.CreateFile,
			Tid:       2484,
			PID:       859,
			CPU:       1,
			Seq:       2,
			Name:      "CreateFile",
			Timestamp: time.Now(),
			Category:  event.File,
			Params: event.Params{
				params.FileObject:    {Name: params.FileObject, Type: params.Uint64, Value: uint64(12456738026482168384)},
				params.FilePath:      {Name: params.FilePath, Type: params.UnicodeString, Value: "C:\\Windows\\system32\\user32.dll"},
				params.FileType:      {Name: params.FileType, Type: params.AnsiString, Value: "file"},
				params.FileOperation: {Name: params.FileOperation, Type: params.Enum, Value: uint32(2), Enum: fs.FileCreateDispositions},
			},
			Callstack: callstackFromFrames(
				callstack.Frame{Addr: 0xf259de, Module: "unbacked", Symbol: "?"},
				callstack.Frame{Addr: 0x7ffe4fda6e3b, Module: "C:\\Windows\\System32\\KernelBase.dll", Symbol: "SetThreadContext"},
				callstack.Frame{Addr: 0xfffff807e228c555, Module: "C:\\WINDOWS\\system32\\ntoskrnl.exe", Symbol: "setjmpex"},
				callstack.Frame{Addr: 0xfffff807e264805c, Module: "C:\\WINDOWS\\system32\\ntoskrnl.exe", Symbol: "ObOpenObjectByPointerWithTag"}),
		}, true},
		{&event.Event{
			Type:      event.CreateFile,
			Tid:       2484,
			PID:       859,
			CPU:       1,
			Seq:       2,
			Name:      "CreateFile",
			Timestamp: time.Now(),
			Category:  event.File,
			Params: event.Params{
				params.FileObject:    {Name: params.FileObject, Type: params.Uint64, Value: uint64(12456738026482168384)},
				params.FilePath:      {Name: params.FilePath, Type: params.UnicodeString, Value: "C:\\Windows\\system32\\user32.dll"},
				params.FileType:      {Name: params.FileType, Type: params.AnsiString, Value: "file"},
				params.FileOperation: {Name: params.FileOperation, Type: params.Enum, Value: uint32(2), Enum: fs.FileCreateDispositions},
			},
			Callstack: callstackFromFrames(
				callstack.Frame{Addr: 0xf259de, Module: "unbacked", Symbol: "?"},
				callstack.Frame{Addr: 0x7ffe4fda6e3b, Module: "C:\\Windows\\System32\\KernelBase.dll", Symbol: "SetThreadContext"},
				callstack.Frame{Addr: 0x7ffe52942b24, Module: "C:\\Windows\\System32\\ntdll.dll", Symbol: "ZwSetContextThread"},
				callstack.Frame{Addr: 0xfffff807e228c555, Module: "C:\\WINDOWS\\system32\\ntoskrnl.exe", Symbol: "setjmpex"},
				callstack.Frame{Addr: 0xfffff807e264805c, Module: "C:\\WINDOWS\\system32\\ntoskrnl.exe", Symbol: "ObOpenObjectByPointerWithTag"}),
		}, false},
		{&event.Event{
			Type:      event.CreateFile,
			Tid:       2484,
			PID:       859,
			CPU:       1,
			Seq:       2,
			Name:      "CreateFile",
			Timestamp: time.Now(),
			Category:  event.File,
			Params: event.Params{
				params.FileObject:    {Name: params.FileObject, Type: params.Uint64, Value: uint64(12456738026482168384)},
				params.FilePath:      {Name: params.FilePath, Type: params.UnicodeString, Value: "C:\\Windows\\system32\\user32.dll"},
				params.FileType:      {Name: params.FileType, Type: params.AnsiString, Value: "file"},
				params.FileOperation: {Name: params.FileOperation, Type: params.Enum, Value: uint32(2), Enum: fs.FileCreateDispositions},
			},
			Callstack: callstackFromFrames(
				callstack.Frame{Addr: 0xf259de, Module: "unbacked", Symbol: "?"},
				callstack.Frame{Addr: 0x7ffe4fda6e3b, Module: "C:\\Windows\\System32\\KernelBase.dll", Symbol: "SetThreadContext"},
				callstack.Frame{Addr: 0x7ffe52942b24, Module: "C:\\Windows\\System32\\wow64win.dll", Symbol: "SetContextThread"},
				callstack.Frame{Addr: 0xfffff807e228c555, Module: "C:\\WINDOWS\\system32\\ntoskrnl.exe", Symbol: "setjmpex"},
				callstack.Frame{Addr: 0xfffff807e264805c, Module: "C:\\WINDOWS\\system32\\ntoskrnl.exe", Symbol: "ObOpenObjectByPointerWithTag"}),
		}, false},
		{&event.Event{
			Type:      event.CreateFile,
			Tid:       2484,
			PID:       859,
			CPU:       1,
			Seq:       2,
			Name:      "CreateFile",
			Timestamp: time.Now(),
			Category:  event.File,
			Params: event.Params{
				params.FileObject:    {Name: params.FileObject, Type: params.Uint64, Value: uint64(12456738026482168384)},
				params.FilePath:      {Name: params.FilePath, Type: params.UnicodeString, Value: "C:\\Windows\\system32\\user32.dll"},
				params.FileType:      {Name: params.FileType, Type: params.AnsiString, Value: "file"},
				params.FileOperation: {Name: params.FileOperation, Type: params.Enum, Value: uint32(2), Enum: fs.FileCreateDispositions},
			},
			Callstack: callstackFromFrames(
				callstack.Frame{Addr: 0xf259de, Module: "unbacked", Symbol: "?"},
				callstack.Frame{Addr: 0x7ffe4fda6e3b, Module: "C:\\Windows\\System32\\KernelBase.dll", Symbol: "SetThreadContext"},
				callstack.Frame{Addr: 0x7ffe52942b24, Module: "unbacked", Symbol: "?"},
				callstack.Frame{Addr: 0xfffff807e228c555, Module: "C:\\WINDOWS\\system32\\ntoskrnl.exe", Symbol: "setjmpex"},
				callstack.Frame{Addr: 0xfffff807e264805c, Module: "C:\\WINDOWS\\system32\\ntoskrnl.exe", Symbol: "ObOpenObjectByPointerWithTag"}),
		}, false},
	}

	for _, tt := range tests {
		t.Run(tt.evt.Name, func(t *testing.T) {
			eva := NewDirectSyscall()
			matches, err := eva.Eval(tt.evt)
			require.NoError(t, err)
			require.Equal(t, tt.matches, matches)
		})
	}
}

func callstackFromFrames(frames ...callstack.Frame) callstack.Callstack {
	var c callstack.Callstack
	for _, frame := range frames {
		c.PushFrame(frame)
	}
	return c
}

```

`internal/evasion/indirect_syscall.go`:

```go
/*
 * Copyright 2021-present by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package evasion

import (
	"path/filepath"
	"strings"
	"unsafe"

	"github.com/rabbitstack/fibratus/pkg/event"
	"github.com/rabbitstack/fibratus/pkg/sys"
	"github.com/rabbitstack/fibratus/pkg/util/va"
	log "github.com/sirupsen/logrus"
	"golang.org/x/sys/windows"
)

var syscallStubs = map[event.Type]string{
	event.CreateProcess:            "NtCreateUserProcess",
	event.CreateThread:             "NtCreateThreadEx",
	event.TerminateThread:          "NtTerminateThread",
	event.RegCreateKey:             "NtCreateKey",
	event.RegDeleteKey:             "NtDeleteKey",
	event.RegSetValue:              "NtSetValueKey",
	event.RegDeleteValue:           "NtDeleteValueKey",
	event.SetThreadContext:         "NtSetContextThread",
	event.OpenProcess:              "NtOpenProcess",
	event.OpenThread:               "NtOpenThread",
	event.VirtualAlloc:             "NtAllocateVirtualMemory",
	event.CreateFile:               "NtCreateFile",
	event.DeleteFile:               "NtDeleteFile",
	event.RenameFile:               "NtSetInformationFile",
	event.CreateSymbolicLinkObject: "NtCreateSymbolicLinkObject",
}

const syscallStubLength = 23

// indirectSyscall evasion refers to executing the syscall instruction by
// diverting the execution flow into a legitimate, clean ntdll stub that
// performs the syscall on process behalf.
//
// This achieves code origin legitimacy, since the execution lands in .text
// of a signed Microsoft module (ntdll.dll). Stack frames look identical to
// a normal API call, which achieves call stack normalization.
type indirectSyscall struct {
	offsets map[event.Type]uintptr // stores expected syscall stub offsets
}

func NewIndirectSyscall() Evasion {
	return &indirectSyscall{}
}

func (i *indirectSyscall) tryResolveSyscallStubOffsets(e *event.Event) error {
	if i.offsets != nil {
		return nil
	}

	var ntdllBase va.Address
	if e.PS != nil {
		for _, mod := range e.PS.Modules {
			if mod.IsNTDLL() {
				ntdllBase = mod.BaseAddress
			}
		}
	}

	if ntdllBase.IsZero() {
		return nil
	}

	var handle windows.Handle
	if err := windows.GetModuleHandleEx(sys.ModuleHandleFromAddress, (*uint16)(unsafe.Pointer(ntdllBase.Uintptr())), &handle); err != nil {
		return err
	}
	defer windows.Close(handle)

	i.offsets = make(map[event.Type]uintptr)

	for evt, stub := range syscallStubs {
		addr, err := windows.GetProcAddress(handle, stub)
		if err != nil {
			log.Warnf("unable to get procedure address for %s: %v", evt, err)
			continue
		}
		i.offsets[evt] = addr - ntdllBase.Uintptr()
		log.Debugf("syscall stub %s resolved to address %x and offset %d", evt, addr, i.offsets[evt])
	}

	return nil
}

func (i *indirectSyscall) Eval(e *event.Event) (bool, error) {
	if err := i.tryResolveSyscallStubOffsets(e); err != nil {
		return false, err
	}
	if e.Callstack.IsEmpty() {
		return false, nil
	}

	frame := e.Callstack.FinalUserspaceFrame()
	if frame == nil {
		return false, nil
	}

	if frame.IsUnbacked() {
		return false, nil
	}

	sym := frame.Symbol
	mod := filepath.Base(strings.ToLower(frame.Module))

	if mod != "ntdll.dll" {
		// only check ntdll syscall stubs
		return false, nil
	}

	// eliminate common false positives (there are
	// many other false positives that can be directly
	// tuned in the rules)
	switch {
	case e.IsCreateProcess() && sym == "ZwDeviceIoControlFile" && e.Callstack.ContainsSymbol("AttachConsole"):
		return false, nil
	case e.IsCreateThread() && (sym == "ZwSetInformationWorkerFactory" || sym == "ZwReleaseWorkerFactoryWorker"):
		return false, nil
	case e.IsOpenThread() && sym == "ZwAlpcOpenSenderThread":
		return false, nil
	case e.IsOpenProcess() && sym == "ZwAlpcOpenSenderProcess":
		return false, nil
	case e.IsCreateFile() && (sym == "ZwOpenFile" || sym == "NtOpenFile" || sym == "ZwQueryAttributesFile" || sym == "ZwQueryFullAttributesFile" || sym == "ZwQueryInformationByName" || sym == "ZwQuerySystemInformation"):
		return false, nil
	case e.IsDeleteFile() && (sym == "ZwSetInformationFile" && (e.Callstack.ContainsSymbol("DeleteFileA") || e.Callstack.ContainsSymbol("DeleteFileW"))):
		return false, nil
	case e.IsRegCreateKey() && sym == "ZwDeviceIoControlFile" && e.Callstack.ContainsSymbol("DllUnregisterServer"):
		return false, nil
	}

	exp, ok := i.offsets[e.Type]
	if !ok {
		return false, nil
	}
	curr := frame.Addr.Dec(uint64(frame.ModuleAddress)).Uintptr()

	//nolint:staticcheck
	return !(curr > exp && curr <= exp+syscallStubLength), nil
}

func (*indirectSyscall) Type() Type { return IndirectSyscall }

func (*indirectSyscall) SetMask(e *event.Event) {
	e.Evasions |= uint32(IndirectSyscall)
}

```

`internal/evasion/indirect_syscall_test.go`:

```go
/*
 * Copyright 2021-present by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package evasion

import (
	"testing"
	"time"
	"unsafe"

	"github.com/rabbitstack/fibratus/pkg/callstack"
	"github.com/rabbitstack/fibratus/pkg/event"
	"github.com/rabbitstack/fibratus/pkg/event/params"
	"github.com/rabbitstack/fibratus/pkg/fs"
	pstypes "github.com/rabbitstack/fibratus/pkg/ps/types"
	"github.com/rabbitstack/fibratus/pkg/sys"
	"github.com/rabbitstack/fibratus/pkg/util/va"
	"github.com/stretchr/testify/require"
	"golang.org/x/sys/windows"
)

func TestIndirectSyscall(t *testing.T) {
	var tests = []struct {
		evt     *event.Event
		matches bool
	}{
		{&event.Event{
			Type:      event.CreateFile,
			Tid:       2484,
			PID:       859,
			CPU:       1,
			Seq:       2,
			Name:      "CreateFile",
			Timestamp: time.Now(),
			Category:  event.File,
			Params: event.Params{
				params.FileObject:    {Name: params.FileObject, Type: params.Uint64, Value: uint64(12456738026482168384)},
				params.FilePath:      {Name: params.FilePath, Type: params.UnicodeString, Value: "C:\\Windows\\system32\\user32.dll"},
				params.FileType:      {Name: params.FileType, Type: params.AnsiString, Value: "file"},
				params.FileOperation: {Name: params.FileOperation, Type: params.Enum, Value: uint32(2), Enum: fs.FileCreateDispositions},
			},
			PS: &pstypes.PS{
				Modules: []pstypes.Module{
					{Name: "C:\\Windows\\System32\\ntdll.dll", Size: 32358, Checksum: 23123343, BaseAddress: getNtdllAddress(), DefaultBaseAddress: getNtdllAddress()},
					{Name: "C:\\Windows\\System32\\kernel32.dll", Size: 12354, Checksum: 23123343, BaseAddress: va.Address(0x7ffb5c1d0126), DefaultBaseAddress: va.Address(0x7ffb5c1d0126)},
					{Name: "C:\\Windows\\System32\\user32.dll", Size: 212354, Checksum: 33123343, BaseAddress: va.Address(0x7ffb5d8e11c4), DefaultBaseAddress: va.Address(0x7ffb5d8e11c4)},
				},
			},
			Callstack: callstackFromFrames(
				callstack.Frame{Addr: 0xf259de, Module: "unbacked", Symbol: "?"},
				callstack.Frame{Addr: getNtdllProcAddress("NtCreateUserProcess"), ModuleAddress: getNtdllAddress(), Module: "C:\\Windows\\System32\\ntdll.dll", Symbol: "ZwCreateFile"},
				callstack.Frame{Addr: 0xfffff807e228c555, Module: "C:\\WINDOWS\\system32\\ntoskrnl.exe", Symbol: "setjmpex"},
				callstack.Frame{Addr: 0xfffff807e264805c, Module: "C:\\WINDOWS\\system32\\ntoskrnl.exe", Symbol: "ObOpenObjectByPointerWithTag"}),
		}, true},
		{&event.Event{
			Type:      event.SetThreadContext,
			Tid:       2484,
			PID:       859,
			CPU:       1,
			Seq:       2,
			Name:      "SetThreadContext",
			Timestamp: time.Now(),
			Category:  event.Thread,
			PS: &pstypes.PS{
				Modules: []pstypes.Module{
					{Name: "C:\\Windows\\System32\\ntdll.dll", Size: 32358, Checksum: 23123343, BaseAddress: getNtdllAddress(), DefaultBaseAddress: getNtdllAddress()},
					{Name: "C:\\Windows\\System32\\kernel32.dll", Size: 12354, Checksum: 23123343, BaseAddress: va.Address(0x7ffb5c1d0126), DefaultBaseAddress: va.Address(0x7ffb5c1d0126)},
					{Name: "C:\\Windows\\System32\\user32.dll", Size: 212354, Checksum: 33123343, BaseAddress: va.Address(0x7ffb5d8e11c4), DefaultBaseAddress: va.Address(0x7ffb5d8e11c4)},
				},
			},
			Callstack: callstackFromFrames(
				callstack.Frame{Addr: 0xf259de, Module: "unbacked", Symbol: "?"},
				callstack.Frame{Addr: 0x7ffe4fda6e3b, Module: "C:\\Windows\\System32\\KernelBase.dll", Symbol: "SetThreadContext"},
				callstack.Frame{Addr: getNtdllProcAddress("ZwSetContextThread") + 20, ModuleAddress: getNtdllAddress(), Module: "C:\\Windows\\System32\\ntdll.dll", Symbol: "ZwSetContextThread"},
				callstack.Frame{Addr: 0xfffff807e228c555, Module: "C:\\WINDOWS\\system32\\ntoskrnl.exe", Symbol: "setjmpex"},
				callstack.Frame{Addr: 0xfffff807e264805c, Module: "C:\\WINDOWS\\system32\\ntoskrnl.exe", Symbol: "ObOpenObjectByPointerWithTag"}),
		}, false},
		{&event.Event{
			Type:      event.CreateFile,
			Tid:       2484,
			PID:       859,
			CPU:       1,
			Seq:       2,
			Name:      "CreateFile",
			Timestamp: time.Now(),
			Category:  event.File,
			Params: event.Params{
				params.FileObject:    {Name: params.FileObject, Type: params.Uint64, Value: uint64(12456738026482168384)},
				params.FilePath:      {Name: params.FilePath, Type: params.UnicodeString, Value: "C:\\Windows\\system32\\user32.dll"},
				params.FileType:      {Name: params.FileType, Type: params.AnsiString, Value: "file"},
				params.FileOperation: {Name: params.FileOperation, Type: params.Enum, Value: uint32(2), Enum: fs.FileCreateDispositions},
			},
			Callstack: callstackFromFrames(
				callstack.Frame{Addr: 0xf259de, Module: "unbacked", Symbol: "?"},
				callstack.Frame{Addr: 0x7ffe4fda6e3b, Module: "C:\\Windows\\System32\\KernelBase.dll", Symbol: "SetThreadContext"},
				callstack.Frame{Addr: getNtdllProcAddress("ZwQueryAttributesFile"), ModuleAddress: getNtdllAddress(), Module: "C:\\Windows\\System32\\ntdll.dll", Symbol: "ZwQueryAttributesFile"},
				callstack.Frame{Addr: 0xfffff807e228c555, Module: "C:\\WINDOWS\\system32\\ntoskrnl.exe", Symbol: "setjmpex"},
				callstack.Frame{Addr: 0xfffff807e264805c, Module: "C:\\WINDOWS\\system32\\ntoskrnl.exe", Symbol: "ObOpenObjectByPointerWithTag"}),
		}, false},
	}

	for _, tt := range tests {
		t.Run(tt.evt.Name, func(t *testing.T) {
			eva := NewIndirectSyscall()
			matches, err := eva.Eval(tt.evt)
			require.NoError(t, err)
			require.Equal(t, tt.matches, matches)
		})
	}
}

func getNtdllAddress() va.Address {
	var moduleHandles [1024]windows.Handle
	var cbNeeded uint32
	proc, err := windows.OpenProcess(windows.PROCESS_ALL_ACCESS, false, windows.GetCurrentProcessId())
	if err != nil {
		return 0
	}
	if err := windows.EnumProcessModules(proc, &moduleHandles[0], 1024, &cbNeeded); err != nil {
		return 0
	}
	moduleHandle := moduleHandles[1]
	var moduleInfo windows.ModuleInfo
	if err := windows.GetModuleInformation(proc, moduleHandle, &moduleInfo, uint32(unsafe.Sizeof(moduleInfo))); err != nil {
		return 0
	}
	return va.Address(moduleInfo.BaseOfDll)
}

func getNtdllProcAddress(procname string) va.Address {
	var handle windows.Handle
	if err := windows.GetModuleHandleEx(sys.ModuleHandleFromAddress, (*uint16)(unsafe.Pointer(getNtdllAddress().Uintptr())), &handle); err != nil {
		panic(err)
	}
	addr, err := windows.GetProcAddress(handle, procname)
	if err != nil {
		panic(err)
	}
	defer windows.CloseHandle(handle)
	return va.Address(addr)
}

```

`internal/evasion/scanner.go`:

```go
/*
 * Copyright 2021-present by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package evasion

import (
	"expvar"

	"github.com/rabbitstack/fibratus/pkg/event"
	log "github.com/sirupsen/logrus"
)

var evasionsCount expvar.Map

// Scanner is responsible for evaluating evasion detectors
// and decorating the event with the reported behaviours.
// Some behaviours represent strong IoCs, while other need
// careful tuning to avoid alert fatigue. Evasion behaviours
// are consumed by the rule engine through the filter fields
// that yields the evasion techniques, such as direct syscall.
type Scanner struct {
	evasions []Evasion
	config   Config
}

// NewScanner instantiates the new evasion scanner.
func NewScanner(config Config) *Scanner {
	s := &Scanner{
		evasions: make([]Evasion, 0),
		config:   config,
	}

	if config.EnableDirectSyscall {
		s.addEvasion(NewDirectSyscall())
	}
	if config.EnableIndirectSyscall {
		s.addEvasion(NewIndirectSyscall())
	}

	return s
}

func (s *Scanner) ProcessEvent(e *event.Event) (bool, error) {
	// filter out CreateFile events with the open disposition
	// as they tend to be noisy and could impact performance
	// when hitting evasion detectors
	if e.IsOpenDisposition() {
		return true, nil
	}

	var enq bool

	// run registered evasion detectors
	for _, evasion := range s.evasions {
		matches, err := evasion.Eval(e)
		if err != nil {
			return false, err
		}
		if matches {
			enq = true
			evasion.SetMask(e)
			evasionsCount.Add(evasion.Type().String(), 1)
			e.AddOrAppendMetaSlice(event.EvasionsKey, evasion.Type().String())
			log.Debugf("detected evasion %q on event [%s] and callstack [%s]", evasion.Type(), e, e.Callstack)
		}
	}

	return enq, nil
}

func (s *Scanner) CanEnqueue() bool { return false }

func (s *Scanner) addEvasion(evasion Evasion) {
	if s.config.Enabled {
		s.evasions = append(s.evasions, evasion)
	}
}

```

`internal/evasion/scanner_test.go`:

```go
/*
 * Copyright 2021-present by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package evasion

import (
	"strings"
	"testing"
	"time"

	"github.com/rabbitstack/fibratus/pkg/callstack"
	"github.com/rabbitstack/fibratus/pkg/event"
	"github.com/rabbitstack/fibratus/pkg/event/params"
	"github.com/rabbitstack/fibratus/pkg/fs"
	"github.com/stretchr/testify/require"
)

func TestScannerProcessEvent(t *testing.T) {
	var tests = []struct {
		evt              *event.Event
		expectedEvasions []string
	}{
		{&event.Event{
			Type:      event.CreateFile,
			Tid:       2484,
			PID:       859,
			CPU:       1,
			Seq:       2,
			Name:      "CreateFile",
			Timestamp: time.Now(),
			Category:  event.File,
			Metadata:  event.Metadata{},
			Params: event.Params{
				params.FileObject:    {Name: params.FileObject, Type: params.Uint64, Value: uint64(12456738026482168384)},
				params.FilePath:      {Name: params.FilePath, Type: params.UnicodeString, Value: "C:\\Windows\\system32\\user32.dll"},
				params.FileType:      {Name: params.FileType, Type: params.AnsiString, Value: "file"},
				params.FileOperation: {Name: params.FileOperation, Type: params.Enum, Value: uint32(2), Enum: fs.FileCreateDispositions},
			},
			Callstack: callstackFromFrames(
				callstack.Frame{Addr: 0xf259de, Module: "unbacked", Symbol: "?"},
				callstack.Frame{Addr: 0x7ffe4fda6e3b, Module: "C:\\Windows\\System32\\KernelBase.dll", Symbol: "SetThreadContext"},
				callstack.Frame{Addr: 0xfffff807e228c555, Module: "C:\\WINDOWS\\system32\\ntoskrnl.exe", Symbol: "setjmpex"},
				callstack.Frame{Addr: 0xfffff807e264805c, Module: "C:\\WINDOWS\\system32\\ntoskrnl.exe", Symbol: "ObOpenObjectByPointerWithTag"}),
		}, []string{"direct_syscall"}},
	}

	s := NewScanner(Config{Enabled: true, EnableDirectSyscall: true})

	for _, tt := range tests {
		t.Run(strings.Join(tt.expectedEvasions, ","), func(t *testing.T) {
			matches, err := s.ProcessEvent(tt.evt)
			require.NoError(t, err)
			require.True(t, matches && len(tt.expectedEvasions) > 0)
			if len(tt.expectedEvasions) > 0 {
				require.True(t, tt.evt.Evasions&uint32(DirectSyscall) != 0)
				require.True(t, tt.evt.ContainsMeta(event.EvasionsKey))
				require.Equal(t, tt.expectedEvasions, tt.evt.GetMeta(event.EvasionsKey).([]string))
			}
		})
	}
}

```

`internal/evasion/types.go`:

```go
/*
 * Copyright 2021-present by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package evasion

import "github.com/rabbitstack/fibratus/pkg/event"

// Type is the alias for the evasion technique type.
type Type uint32

const (
	// DirectSyscall represents the direct syscall evasion.
	DirectSyscall Type = 1 << iota
	// IndirectSyscall represents the indirect syscall evasion.
	IndirectSyscall
)

// String returns the evasion human-friendly name.
func (t Type) String() string {
	switch t {
	case DirectSyscall:
		return "direct_syscall"
	case IndirectSyscall:
		return "indirect_syscall"
	default:
		return "unknown"
	}
}

// Evasion defines the contract that all evasion detectors need to satisfy.
type Evasion interface {
	// Eval executes the evasion logic. The evasion detector usually accesses
	// the callstack from the given event to determine if any evasions are
	// performed on behalf of the process. If the evasion is recognized, this
	// method returns true, or false otherwise.
	Eval(*event.Event) (bool, error)
	// Type returns the type of the evasion technique.
	Type() Type
	// SetMask sets the type in the event evasions bitmask.
	SetMask(*event.Event)
}

```

`make.bat`:

```bat
:: Copyright 2019-2020 by Nedim Sabic Sabic
:: https://www.fibratus.io
:: All Rights Reserved.
::
:: Licensed under the Apache License, Version 2.0 (the "License"); you may
:: not use this file except in compliance with the License. You may obtain
:: a copy of the License at
::
:: http://www.apache.org/licenses/LICENSE-2.0

@echo off
SetLocal EnableDelayedExpansion

set PYTHON_VER=3.7.9
set PYTHON_URL=https://www.python.org/ftp/python/%PYTHON_VER%/python-%PYTHON_VER%-embed-amd64.zip

set WIX_VERSION=5.0.0

set GOBIN=%USERPROFILE%\go\bin

set GOTEST=go test -timeout=10m -v -gcflags=all=-d=checkptr=0
set GOFMT=gofmt -e -s -l -w
set GOLINT=%GOBIN%\golangci-lint

if NOT DEFINED VERSION (
    set VERSION="0.0.0"
)

FOR /F "tokens=* USEBACKQ" %%F IN (`powershell -Command get-date -format "{dd-MM-yyyy.HH:mm:ss}"`) DO (
    SET BUILD_DATE=%%F
)
set LDFLAGS="-s -w -X github.com/rabbitstack/fibratus/cmd/fibratus/app.version=%VERSION% -X github.com/rabbitstack/fibratus/cmd/fibratus/app.commit=%COMMIT% -X github.com/rabbitstack/fibratus/cmd/fibratus/app.date=%BUILD_DATE%"

:: In case you want to avoid CGO overhead or don't need a specific feature, try tweaking the following compilation tags:
::
:: cap: enables capture support
:: filament: enables running filaments and thus interacting with the CPython interpreter
:: yara: enables YARA scanner via cgo bindings
if NOT DEFINED TAGS (
    set TAGS=""
)

set PKGS=
:: Get the list of packages that we'll use to run tests/linter
for /f %%p in ('go list .\...') do call set "PKGS=%%PKGS%% %%p"


if "%~1"=="build" goto build
if "%~1"=="test" goto test
if "%~1"=="lint" goto lint
if "%~1"=="fmt" goto fmt
if "%~1"=="clean" goto clean
if "%~1"=="pkg" goto pkg
if "%~1"=="pkg-slim" goto pkg-slim
if "%~1"=="install" goto install
if "%~1"=="deps" goto deps
if "%~1"=="rsrc" goto rsrc
if "%~1"=="mc" goto mc

:build
:: set PKG_CONFIG_PATH=pkg-config
go build -ldflags %LDFLAGS% -tags %TAGS% -o .\cmd\fibratus\fibratus.exe .\cmd\fibratus
if errorlevel 1 goto fail
go build -ldflags %LDFLAGS% -o .\cmd\systray\fibratus-systray.exe .\cmd\systray
if errorlevel 1 goto fail
goto :EOF

:test
%GOTEST% -tags %TAGS% %PKGS%
if errorlevel 1 goto fail
goto :EOF

:lint
%GOLINT% run --timeout 10m
if errorlevel 1 goto fail
goto :EOF

:fmt
%GOFMT% pkg cmd internal
goto :EOF

:deps
go get -v -u github.com/golangci/golangci-lint/cmd/golangci-lint@v1.52.2
goto :EOF

:rsrc
set RC_VER=%VERSION:.=,%
windres --define RC_VER=%RC_VER% --define VER=%VERSION% -i cmd\fibratus\fibratus.rc -O coff -o cmd\fibratus\fibratus.syso
if errorlevel 1 goto fail
windres --define RC_VER=%RC_VER% --define VER=%VERSION% -i cmd\systray\fibratus-systray.rc -O coff -o cmd\systray\fibratus-systray.syso
if errorlevel 1 goto fail
goto :EOF

:mc
:: Generate eventlog message compiler input file
go generate github.com/rabbitstack/fibratus/pkg/outputs/eventlog
windmc -c -r pkg/outputs/eventlog/mc pkg/outputs/eventlog/mc/fibratus.mc
windres -O coff -r -fo pkg/outputs/eventlog/mc/fibratus.res pkg/outputs/eventlog/mc/fibratus.rc
:: Link the resulting resource object
gcc pkg/outputs/eventlog/mc/fibratus.res -o pkg/outputs/eventlog/mc/fibratus.dll -s -shared "-Wl,--subsystem,windows"
if errorlevel 1 goto fail
goto :EOF

:pkg
set RELEASE_DIR=.\build\msi\fibratus-%VERSION%

:: Create the directory structure
mkdir "%~dp0\%RELEASE_DIR%"
mkdir "%~dp0\%RELEASE_DIR%\Bin"
mkdir "%~dp0\%RELEASE_DIR%\Config"
mkdir "%~dp0\%RELEASE_DIR%\Rules"
mkdir "%~dp0\%RELEASE_DIR%\Python"
mkdir "%~dp0\%RELEASE_DIR%\Filaments"

echo Copying artifacts...
:: Copy artifacts
copy /y ".\cmd\fibratus\fibratus.exe" "%RELEASE_DIR%\Bin"
copy /y ".\cmd\systray\fibratus-systray.exe" "%RELEASE_DIR%\Bin"
copy /y ".\cmd\fibratus\fibratus.ico" "%RELEASE_DIR%\Bin"
copy /y ".\configs\fibratus.yml" "%RELEASE_DIR%\Config\fibratus.yml"
copy /y ".\pkg\outputs\eventlog\mc\fibratus.dll" "%RELEASE_DIR%\fibratus.dll"

robocopy ".\filaments" "%RELEASE_DIR%\Filaments" /E /S /XF *.md /XD __pycache__ .idea
robocopy ".\rules" "%RELEASE_DIR%\Rules" /E /S /XF *.md *.png

:: Download the embedded Python distribution
echo Downloading Python %PYTHON_VER%...
powershell -Command "Invoke-WebRequest %PYTHON_URL% -OutFile %RELEASE_DIR%\python.zip" || goto :fail

echo Extracting Python distribution...
powershell -Command "Expand-Archive %RELEASE_DIR%\python.zip -DestinationPath %RELEASE_DIR%\python"

:: Bring in the pip
:: https://stackoverflow.com/questions/42666121/pip-with-embedded-python
powershell -Command "(Get-Content -path %RELEASE_DIR%\python\python*._pth -Raw) -replace '#import','import' | Set-Content -Path %RELEASE_DIR%\python\python*._pth"
echo Downloading get-pip.py...
powershell -Command "Invoke-WebRequest https://bootstrap.pypa.io/get-pip.py -OutFile %RELEASE_DIR%\get-pip.py"
%RELEASE_DIR%\python\python.exe %RELEASE_DIR%\get-pip.py

del %RELEASE_DIR%\get-pip.py
del %RELEASE_DIR%\python.zip

:: Move Python DLLs and other dependencies to the same directory
:: where the fibratus binary is located to advise Windows on the
:: DLL search path strategy.
move %RELEASE_DIR%\python\*.dll %RELEASE_DIR%\bin

:: Rename libcrypto-1_1.dll to libcrypto-3-x64.dll
ren "%RELEASE_DIR%\bin\libcrypto-1_1.dll" "libcrypto-3-x64.dll"
:: Copy Debug Help DLL
copy %SystemRoot%\System32\dbghelp.dll "%RELEASE_DIR%\Bin"

echo Building MSI package...
pushd .
cd build/msi
wix extension add WixToolset.UI.wixext/%WIX_VERSION% || goto :fail
wix extension add WixToolset.Util.wixext/%WIX_VERSION% || goto :fail
wix build -ext WixToolset.UI.wixext -ext WixToolset.Util.wixext -b dir=fibratus-%VERSION% fibratus.wxs -arch x64 -d VERSION=%VERSION% -o fibratus-%VERSION%-amd64.msi || goto :fail
popd
echo fibratus-%VERSION%-amd64.msi MSI package built successfully

if errorlevel 1 goto fail

goto :EOF

:pkg-slim
set RELEASE_DIR=.\build\msi\fibratus-%VERSION%-slim

:: Create the dir structure
mkdir "%~dp0\%RELEASE_DIR%"
mkdir "%~dp0\%RELEASE_DIR%\Bin"
mkdir "%~dp0\%RELEASE_DIR%\Config"
mkdir "%~dp0\%RELEASE_DIR%\Rules"

echo Copying artifacts...
:: Copy artifacts
copy /y ".\cmd\fibratus\fibratus.exe" "%RELEASE_DIR%\Bin"
copy /y ".\cmd\systray\fibratus-systray.exe" "%RELEASE_DIR%\Bin"
copy /y ".\cmd\fibratus\fibratus.ico" "%RELEASE_DIR%\Bin"
copy /y ".\configs\fibratus.yml" "%RELEASE_DIR%\Config\fibratus.yml"
copy /y ".\pkg\outputs\eventlog\mc\fibratus.dll" "%RELEASE_DIR%\fibratus.dll"

robocopy ".\rules" "%RELEASE_DIR%\Rules" /E /S /XF *.md *.png

:: Copy Debug Help DLL
copy %SystemRoot%\System32\dbghelp.dll "%RELEASE_DIR%\Bin"

echo Building MSI package...
pushd .
cd build/msi
wix extension add WixToolset.UI.wixext/%WIX_VERSION% || goto :fail
wix extension add WixToolset.Util.wixext/%WIX_VERSION% || goto :fail
wix build -ext WixToolset.UI.wixext -ext WixToolset.Util.wixext -b dir=fibratus-%VERSION%-slim fibratus.wxs -arch x64 -d VERSION=%VERSION% -o fibratus-%VERSION%-slim-amd64.msi ||  goto :fail
popd
echo fibratus-%VERSION%-slim-amd64.msi MSI package built successfully

goto :EOF

:clean
del cmd\fibratus\fibratus.exe
del cmd\systray\fibratus-systray.exe
goto :EOF

:: Install the dev MSI. This target executes
:: the msiexec in the background, and waits
:: for process completion. Once the command
:: finishes, the install log is dumped to
:: help diagnosing installer failures
:install
echo Installing Fibratus...
start /b /wait msiexec /i fibratus-0.0.0-amd64.msi /qn /l*! install.log
timeout 2 > NUL
type install.log
goto :EOF

:fail
echo Failed with error #%errorlevel%.
exit /b %errorlevel%

```

`pkg-config/python-37.pc`:

```pc
prefix=C:/Python37
exec_prefix=${prefix}
libdir=${exec_prefix}/libs
includedir=${prefix}/include

Name: Python
Description: Python library
Requires:
Version: 3.7
Libs: -L${libdir} -lpython37
Cflags: -I${includedir} -DMS_WIN64
```

`pkg/aggregator/aggregator.go`:

```go
/*
 * Copyright 2019-2020 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package aggregator

import (
	"errors"
	"expvar"
	"time"

	"github.com/rabbitstack/fibratus/pkg/aggregator/transformers"
	"github.com/rabbitstack/fibratus/pkg/alertsender"
	"github.com/rabbitstack/fibratus/pkg/event"
	"github.com/rabbitstack/fibratus/pkg/outputs"
	log "github.com/sirupsen/logrus"

	// initialize outputs
	_ "github.com/rabbitstack/fibratus/pkg/outputs/amqp"
	_ "github.com/rabbitstack/fibratus/pkg/outputs/console"
	_ "github.com/rabbitstack/fibratus/pkg/outputs/elasticsearch"
	_ "github.com/rabbitstack/fibratus/pkg/outputs/eventlog"
	_ "github.com/rabbitstack/fibratus/pkg/outputs/http"
	_ "github.com/rabbitstack/fibratus/pkg/outputs/null"

	// initialize alert senders
	_ "github.com/rabbitstack/fibratus/pkg/alertsender/mail"
	_ "github.com/rabbitstack/fibratus/pkg/alertsender/slack"
	_ "github.com/rabbitstack/fibratus/pkg/alertsender/systray"

	// initialize transformers
	_ "github.com/rabbitstack/fibratus/pkg/aggregator/transformers/remove"
	_ "github.com/rabbitstack/fibratus/pkg/aggregator/transformers/rename"
	_ "github.com/rabbitstack/fibratus/pkg/aggregator/transformers/replace"
	_ "github.com/rabbitstack/fibratus/pkg/aggregator/transformers/tags"
	_ "github.com/rabbitstack/fibratus/pkg/aggregator/transformers/trim"
)

var (
	// eventsDequeued counts the number of dequeued events
	eventsDequeued = expvar.NewInt("aggregator.events.dequeued")
	// flushesCount computes the total count of aggregator flushes
	flushesCount = expvar.NewInt("aggregator.flushes.count")
	// batchEvents represents the overall number of processed batches
	batchEvents = expvar.NewInt("aggregator.batch.events")
	// transformerErrors is the count of errors occurred when applying transformers
	transformerErrors = expvar.NewMap("aggregator.transformer.errors")
	// eventsErrors is the number of event errors
	eventsErrors = expvar.NewInt("aggregator.event.errors")
)

// BufferedAggregator collects events from the inbound channel and produces batches on regular intervals. The batches
// are pushed to the work queue from which load-balanced configured workers consume the batches and publish to the outputs.
type BufferedAggregator struct {
	evtsc   <-chan *event.Event
	errsc   <-chan error
	stop    chan struct{}
	flusher *time.Ticker
	// queue of inbound events
	evts []*event.Event
	// work queue that forwarder passes to outputs
	wq         queue
	submitter  *submitter
	transforms []transformers.Transformer
	c          Config
}

// NewBuffered creates a new instance of the event aggregator.
func NewBuffered(
	evts <-chan *event.Event,
	errs <-chan error,
	aggConfig Config,
	outputConfig outputs.Config,
	transformerConfigs []transformers.Config,
	alertsenderConfigs []alertsender.Config,
) (*BufferedAggregator, error) {
	flushInterval := aggConfig.FlushPeriod
	if flushInterval < time.Millisecond*250 {
		flushInterval = time.Millisecond * 250
	}
	agg := &BufferedAggregator{
		evtsc:   evts,
		evts:    make([]*event.Event, 0),
		errsc:   errs,
		stop:    make(chan struct{}, 1),
		flusher: time.NewTicker(flushInterval),
		wq:      make(chan *event.Batch),
		c:       aggConfig,
	}

	var err error
	agg.submitter, err = newSubmitter(agg.wq, outputConfig)
	if err != nil {
		return nil, err
	}
	agg.transforms, err = transformers.LoadAll(transformerConfigs)
	if err != nil {
		return nil, err
	}

	err = alertsender.LoadAll(alertsenderConfigs)
	if err != nil {
		return nil, err
	}

	go agg.run()

	return agg, nil
}

// Stop flushes pending event batches and instructs the aggregator to stop processing events.
func (agg *BufferedAggregator) Stop() error {
	agg.stop <- struct{}{}

	// flush enqueued events
	b := event.NewBatch(agg.evts...)
	if b.Len() > 0 {
		done := make(chan struct{}, 1)
		go func() {
			agg.wq <- b
			done <- struct{}{}
		}()

		select {
		case <-done:
			close(agg.wq)
		case <-time.After(agg.c.FlushTimeout):
			return errors.New("fail to flush events after stop timed out")
		}
	}

	// sleep a bit before closing the clients
	time.Sleep(time.Millisecond * 150)

	err := agg.submitter.shutdown()
	if err != nil {
		return err
	}

	return nil
}

// run starts the aggregator loop. The aggregator receives event stream from the upstream channel, buffers
// them to intermediate queue and dispatches batches to downstream worker queue.
func (agg *BufferedAggregator) run() {
	for {
		select {
		case <-agg.stop:
			agg.flusher.Stop()
			return
		case <-agg.flusher.C:
			if len(agg.evts) == 0 {
				continue
			}
			b := event.NewBatch(agg.evts...)
			l := b.Len()
			batchEvents.Add(l)
			// push the batch to the work queue
			if l > 0 {
				agg.wq <- b
			}
			flushesCount.Add(1)
			// clear the queue
			agg.evts = nil
		case evt := <-agg.evtsc:
			for _, transform := range agg.transforms {
				err := transform.Transform(evt)
				if err != nil {
					transformerErrors.Add(err.Error(), 1)
				}
			}
			// push the event to the queue
			agg.evts = append(agg.evts, evt)
			eventsDequeued.Add(1)
		case err := <-agg.errsc:
			eventsErrors.Add(1)
			log.Errorf("event processing failure: %v", err)
		}
	}
}

```

`pkg/aggregator/aggregator_test.go`:

```go
/*
 * Copyright 2019-2020 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package aggregator

import (
	"github.com/rabbitstack/fibratus/pkg/event"
	"github.com/rabbitstack/fibratus/pkg/event/params"
	"github.com/rabbitstack/fibratus/pkg/outputs"
	"github.com/rabbitstack/fibratus/pkg/outputs/console"
	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/require"
	"net"
	"testing"
	"time"
)

func TestNewBufferedAggregator(t *testing.T) {
	eventsc := make(chan *event.Event, 20)
	errsc := make(chan error, 1)
	agg, err := NewBuffered(
		eventsc,
		errsc,
		Config{FlushPeriod: time.Millisecond * 200},
		outputs.Config{Type: outputs.Console, Output: console.Config{Format: "pretty"}},
		nil,
		nil,
	)
	require.NoError(t, err)
	require.NotNil(t, agg)

	for i := 0; i < 4; i++ {
		evt := &event.Event{
			Type: event.SendTCPv4,
			Tid:  2484,
			PID:  859,
			Params: event.Params{
				params.NetDport: {Name: params.NetDport, Type: params.Uint16, Value: uint16(443)},
				params.NetSport: {Name: params.NetSport, Type: params.Uint16, Value: uint16(43123)},
				params.NetSIP:   {Name: params.NetSIP, Type: params.IPv4, Value: net.ParseIP("127.0.0.1")},
				params.NetDIP:   {Name: params.NetDIP, Type: params.IPv4, Value: net.ParseIP("216.58.201.174")},
			},
		}
		eventsc <- evt
	}
	<-time.After(time.Millisecond * 275)
	assert.Equal(t, int64(4), batchEvents.Value())

	for i := 0; i < 2; i++ {
		evt := &event.Event{
			Type: event.SendTCPv4,
			Tid:  2484,
			PID:  859,
			Seq:  uint64(i),
			Params: event.Params{
				params.NetDport: {Name: params.NetDport, Type: params.Uint16, Value: uint16(443)},
				params.NetSport: {Name: params.NetSport, Type: params.Uint16, Value: uint16(43123)},
				params.NetSIP:   {Name: params.NetSIP, Type: params.IPv4, Value: net.ParseIP("127.0.0.1")},
				params.NetDIP:   {Name: params.NetDIP, Type: params.IPv4, Value: net.ParseIP("216.58.201.174")},
			},
		}
		eventsc <- evt
	}
	<-time.After(time.Millisecond * 260)
	assert.Equal(t, int64(6), batchEvents.Value())
	assert.Equal(t, int64(2), flushesCount.Value())
}

```

`pkg/aggregator/config.go`:

```go
/*
 * Copyright 2019-2020 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package aggregator

import (
	"github.com/spf13/pflag"
	"github.com/spf13/viper"
	"time"
)

const (
	flushPeriod  = "aggregator.flush-period"
	flushTimeout = "aggregator.flush-timeout"
)

// Config contains aggregator-specific configuration tweaks.
type Config struct {
	// FlushPeriod determines the period for flushing batches to outputs.
	FlushPeriod time.Duration `json:"aggregator.flush-period" yaml:"aggregator.flush-period"`
	// FlushTimeout represents the max time to wait before announcing failed flushing of enqueued events
	FlushTimeout time.Duration `json:"aggregator.flush-timeout" yaml:"aggregator.flush-timeout"`
}

// AddFlags registers persistent aggregator flags.
func AddFlags(flags *pflag.FlagSet) {
	flags.Duration(flushPeriod, time.Millisecond*200, "Determines the period for flushing batches to outputs")
	flags.Duration(flushTimeout, time.Second*4, "Represents the max time to wait before announcing failed flushing of enqueued events on aggregator shutdown")
}

// InitFromViper initializes aggregator flags from viper.
func (c *Config) InitFromViper(v *viper.Viper) {
	c.FlushPeriod = v.GetDuration(flushPeriod)
	c.FlushTimeout = v.GetDuration(flushTimeout)
}

```

`pkg/aggregator/submitter.go`:

```go
/*
 * Copyright 2019-2020 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package aggregator

import (
	"github.com/rabbitstack/fibratus/pkg/event"
	"github.com/rabbitstack/fibratus/pkg/outputs"
)

// queue defines the type alias for the batch worker queue
type queue chan *event.Batch

// submitter initializes a group of load balanced output producers.
type submitter struct {
	wq      queue
	workers []*worker
}

func newSubmitter(wq queue, outputConfig outputs.Config) (*submitter, error) {
	output, err := outputs.Load(outputConfig.Type, outputConfig)
	if err != nil {
		return nil, err
	}
	clients := output.Clients
	workers := make([]*worker, len(clients))

	for i, client := range clients {
		workers[i] = initWorker(wq, client)
	}

	return &submitter{wq: wq, workers: workers}, nil
}

func (s *submitter) shutdown() error {
	for _, w := range s.workers {
		if err := w.close(); err != nil {
			return err
		}
	}
	return nil
}

```

`pkg/aggregator/transformers/config.go`:

```go
/*
 * Copyright 2019-2020 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package transformers

import "fmt"

// ErrInvalidConfig signals an invalid transformer configuration
var ErrInvalidConfig = func(name Type) error { return fmt.Errorf("invalid config for %q transformer", name) }

// Config acts as a container for the transformer configuration structures.
type Config struct {
	Type        Type
	Transformer interface{}
}

```

`pkg/aggregator/transformers/remove/config.go`:

```go
/*
 * Copyright 2019-2020 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package remove

import "github.com/spf13/pflag"

const (
	pars    = "transformers.remove.params"
	enabled = "transformers.remove.enabled"
)

// Config stores the configuration for the remove transformer.
type Config struct {
	// Params is the list of parameters that are dropped from the event.
	Params []string `mapstructure:"params"`
	// Enabled indicates whether this transformer is enabled
	Enabled bool `mapstructure:"enabled"`
}

// AddFlags registers persistent flags.
func AddFlags(flags *pflag.FlagSet) {
	flags.StringSlice(pars, []string{}, "A list of comma-separated parameters that will be removed from the event")
	flags.Bool(enabled, false, "Indicates if remove transformer is enabled")
}

```

`pkg/aggregator/transformers/remove/remove.go`:

```go
/*
 * Copyright 2019-2020 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package remove

import (
	"expvar"
	"github.com/rabbitstack/fibratus/pkg/aggregator/transformers"
	"github.com/rabbitstack/fibratus/pkg/event"
)

var removedCount = expvar.NewInt("transformers.removed.params")

// remove transformer deletes params that are given in the list.
type remove struct {
	c Config
}

func init() {
	transformers.Register(transformers.Remove, initRemoveTransformer)
}

func initRemoveTransformer(config transformers.Config) (transformers.Transformer, error) {
	cfg, ok := config.Transformer.(Config)
	if !ok {
		return nil, transformers.ErrInvalidConfig(transformers.Remove)
	}
	return &remove{c: cfg}, nil
}

func (r remove) Transform(evt *event.Event) error {
	for _, par := range r.c.Params {
		delete(evt.Params, par)
		removedCount.Add(1)
	}
	return nil
}

```

`pkg/aggregator/transformers/remove/remove_test.go`:

```go
/*
 * Copyright 2019-2020 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package remove

import (
	"github.com/rabbitstack/fibratus/pkg/aggregator/transformers"
	"github.com/rabbitstack/fibratus/pkg/event"
	"github.com/rabbitstack/fibratus/pkg/event/params"
	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/require"
	"net"
	"testing"
)

func TestTransform(t *testing.T) {
	evt := &event.Event{
		Type: event.SendTCPv4,
		Tid:  2484,
		PID:  859,
		Params: event.Params{
			params.NetDport: {Name: params.NetDport, Type: params.Uint16, Value: uint16(443)},
			params.NetSport: {Name: params.NetSport, Type: params.Uint16, Value: uint16(43123)},
			params.NetSIP:   {Name: params.NetSIP, Type: params.IPv4, Value: net.ParseIP("127.0.0.1")},
			params.NetDIP:   {Name: params.NetDIP, Type: params.IPv4, Value: net.ParseIP("216.58.201.174")},
		},
	}
	assert.Len(t, evt.Params, 4)

	transf, err := transformers.Load(transformers.Config{Type: transformers.Remove, Transformer: Config{Params: []string{"dip", "sport", "foo"}}})
	require.NoError(t, err)
	err = transf.Transform(evt)

	require.NoError(t, err)

	assert.Len(t, evt.Params, 2)
}

```

`pkg/aggregator/transformers/rename/config.go`:

```go
/*
 * Copyright 2019-2020 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package rename

import "github.com/spf13/pflag"

const (
	enabled = "transformers.rename.enabled"
)

// Rename describes the configuration for the old/new parameter name.
type Rename struct {
	Old string `mapstructure:"old"`
	New string `mapstructure:"new"`
}

// Config stores the configuration of the rename transformer.
type Config struct {
	// Params is the list of parameters that will be renamed.
	Params []Rename
	// Enabled indicates whether this transformer is enabled.
	Enabled bool
}

// AddFlags registers persistent flags.
func AddFlags(flags *pflag.FlagSet) {
	flags.Bool(enabled, false, "Indicates if the rename transformer is enabled")
}

```

`pkg/aggregator/transformers/rename/rename.go`:

```go
/*
 * Copyright 2019-2020 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package rename

import (
	"github.com/rabbitstack/fibratus/pkg/aggregator/transformers"
	"github.com/rabbitstack/fibratus/pkg/event"
)

// rename as it name implies, it renames a sequence of params to their new names.
type rename struct {
	c Config
}

func init() {
	transformers.Register(transformers.Rename, initRenameTransformer)
}

func initRenameTransformer(config transformers.Config) (transformers.Transformer, error) {
	cfg, ok := config.Transformer.(Config)
	if !ok {
		return nil, transformers.ErrInvalidConfig(transformers.Rename)
	}
	return &rename{c: cfg}, nil
}

func (r rename) Transform(evt *event.Event) error {
	for _, p := range r.c.Params {
		par, ok := evt.Params[p.Old]
		if !ok {
			continue
		}
		evt.Params.Remove(p.Old)
		par.Name = p.New
		evt.Params[p.New] = par
	}
	return nil
}

```

`pkg/aggregator/transformers/rename/rename_test.go`:

```go
/*
 * Copyright 2019-2020 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package rename

import (
	"github.com/rabbitstack/fibratus/pkg/aggregator/transformers"
	"github.com/rabbitstack/fibratus/pkg/event"
	"github.com/rabbitstack/fibratus/pkg/event/params"
	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/require"
	"net"
	"testing"
)

func TestTransform(t *testing.T) {
	evt := &event.Event{
		Type: event.SendTCPv4,
		Tid:  2484,
		PID:  859,
		Params: event.Params{
			params.NetDport: {Name: params.NetDport, Type: params.Uint16, Value: uint16(443)},
			params.NetSport: {Name: params.NetSport, Type: params.Uint16, Value: uint16(43123)},
			params.NetSIP:   {Name: params.NetSIP, Type: params.IPv4, Value: net.ParseIP("127.0.0.1")},
			params.NetDIP:   {Name: params.NetDIP, Type: params.IPv4, Value: net.ParseIP("216.58.201.174")},
		},
		Metadata: make(map[event.MetadataKey]any),
	}

	transf, err := transformers.Load(transformers.Config{Type: transformers.Rename, Transformer: Config{Params: []Rename{{Old: "dport", New: "dstport"}, {Old: "sip", New: "srcip"}}}})
	require.NoError(t, err)

	require.NoError(t, transf.Transform(evt))

	assert.True(t, evt.Params.Contains("dstport"))
	assert.False(t, evt.Params.Contains("dport"))
	assert.True(t, evt.Params.Contains("srcip"))
	assert.False(t, evt.Params.Contains("sip"))
}

```

`pkg/aggregator/transformers/replace/config.go`:

```go
/*
 * Copyright 2019-2020 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package replace

import "github.com/spf13/pflag"

const (
	enabled = "transformers.replace.enabled"
)

// Config stores the configuration for the replace transformer
type Config struct {
	// Replacements describes a list of replacements that are applied on the Param.
	Replacements []Replacement `mapstructure:"replacements"`
	// Enabled indicates whether this transformer is enabled
	Enabled bool `mapstructure:"enabled"`
}

// Replacement defines the string replacement config for a specific Param.
type Replacement struct {
	Param string `mapstructure:"param"`
	Old   string `mapstructure:"old"`
	New   string `mapstructure:"new"`
}

// AddFlags registers persistent flags.
func AddFlags(flags *pflag.FlagSet) {
	flags.Bool(enabled, false, "Indicates if the replace transformer is enabled")
}

```

`pkg/aggregator/transformers/replace/replace.go`:

```go
/*
 * Copyright 2019-2020 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package replace

import (
	"expvar"
	"github.com/rabbitstack/fibratus/pkg/aggregator/transformers"
	"github.com/rabbitstack/fibratus/pkg/event"
	"strings"
)

var replaceCount = expvar.NewInt("transformers.replaced.params")

// replace applies string substitutions in par values.
type replace struct {
	c Config
}

func init() {
	transformers.Register(transformers.Replace, initReplaceTransformer)
}

func initReplaceTransformer(config transformers.Config) (transformers.Transformer, error) {
	cfg, ok := config.Transformer.(Config)
	if !ok {
		return nil, transformers.ErrInvalidConfig(transformers.Replace)
	}
	return &replace{c: cfg}, nil
}

func (r replace) Transform(evt *event.Event) error {
	for _, repl := range r.c.Replacements {
		par := evt.Params.Find(repl.Param)
		if par == nil {
			continue
		}
		_, ok := par.Value.(string)
		if !ok {
			continue
		}
		par.Value = strings.ReplaceAll(evt.GetParamAsString(par.Name), repl.Old, repl.New)
		replaceCount.Add(1)
	}
	return nil
}

```

`pkg/aggregator/transformers/replace/replace_test.go`:

```go
/*
 * Copyright 2019-2020 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package replace

import (
	"github.com/rabbitstack/fibratus/pkg/aggregator/transformers"
	"github.com/rabbitstack/fibratus/pkg/event"
	"github.com/rabbitstack/fibratus/pkg/event/params"
	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/require"
	"testing"
)

func TestTransform(t *testing.T) {
	evt := &event.Event{
		Type: event.RegCreateKey,
		Tid:  2484,
		PID:  859,
		Params: event.Params{
			params.RegPath:      {Name: params.RegPath, Type: params.UnicodeString, Value: `HKEY_LOCAL_MACHINE\SYSTEM\Setup\Pid`},
			params.RegKeyHandle: {Name: params.RegKeyHandle, Type: params.Address, Value: uint64(18446666033449935464)},
		},
	}

	transf, err := transformers.Load(transformers.Config{Type: transformers.Replace, Transformer: Config{Replacements: []Replacement{{Param: "key_path", Old: "HKEY_LOCAL_MACHINE", New: "HKLM"}}}})
	require.NoError(t, err)

	require.NoError(t, transf.Transform(evt))

	keyName, _ := evt.Params.GetString(params.RegPath)

	assert.Equal(t, `HKLM\SYSTEM\Setup\Pid`, keyName)
}

```

`pkg/aggregator/transformers/tags/config.go`:

```go
/*
 * Copyright 2019-2020 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package tags

import (
	"github.com/spf13/pflag"
)

const (
	enabled = "transformers.tags.enabled"
)

// Tag represents a distinct tag with its key and value attached.
type Tag struct {
	Key   string `mapstructure:"key"`
	Value string `mapstructure:"value"`
}

// Config stores the configuration for the tags transformer
type Config struct {
	// Tags is the sequence of key/value pairs that are added to the event
	Tags []Tag `mapstructure:"tags"`
	// Enabled indicates whether this transformer is enabled
	Enabled bool `mapstructure:"enabled"`
}

// AddFlags registers persistent flags.
func AddFlags(flags *pflag.FlagSet) {
	flags.Bool(enabled, false, "Indicates if the tags transformer is enabled")
}

```

`pkg/aggregator/transformers/tags/tags.go`:

```go
/*
 * Copyright 2019-2020 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package tags

import (
	"os"
	"strings"

	"github.com/rabbitstack/fibratus/pkg/aggregator/transformers"
	"github.com/rabbitstack/fibratus/pkg/event"
)

// tags transformer appends tags to the event's metadata. It is capable of adding literal values as well as
// tags that are stored in environment variables.
type tags struct {
	tags map[string]string
}

func init() {
	transformers.Register(transformers.Tags, initTagsTransformer)
}

func initTagsTransformer(config transformers.Config) (transformers.Transformer, error) {
	cfg, ok := config.Transformer.(Config)
	if !ok {
		return nil, transformers.ErrInvalidConfig(transformers.Tags)
	}

	ktags := make(map[string]string)

	for _, tag := range cfg.Tags {
		// if the value is enclosed within % symbols this means
		// we have to expand it from the environ variable
		key, val := tag.Key, tag.Value
		if len(val) == 0 {
			continue
		}
		if val[0] == '%' && val[len(val)-1] == '%' {
			ktags[key] = os.Getenv(strings.ReplaceAll(val, "%", ""))
			continue
		}
		ktags[key] = val
	}

	return &tags{tags: ktags}, nil
}

func (t tags) Transform(evt *event.Event) error {
	for k, v := range t.tags {
		evt.AddMeta(event.MetadataKey(k), v)
	}
	return nil
}

```

`pkg/aggregator/transformers/tags/tags_test.go`:

```go
/*
 * Copyright 2019-2020 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package tags

import (
	"net"
	"os"
	"testing"

	"github.com/rabbitstack/fibratus/pkg/aggregator/transformers"
	"github.com/rabbitstack/fibratus/pkg/event"
	"github.com/rabbitstack/fibratus/pkg/event/params"
	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/require"
)

func TestTransform(t *testing.T) {
	evt := &event.Event{
		Type: event.SendTCPv4,
		Tid:  2484,
		PID:  859,
		Params: event.Params{
			params.NetDport: {Name: params.NetDport, Type: params.Uint16, Value: uint16(443)},
			params.NetSport: {Name: params.NetSport, Type: params.Uint16, Value: uint16(43123)},
			params.NetSIP:   {Name: params.NetSIP, Type: params.IPv4, Value: net.ParseIP("127.0.0.1")},
			params.NetDIP:   {Name: params.NetDIP, Type: params.IPv4, Value: net.ParseIP("216.58.201.174")},
		},
		Metadata: make(map[event.MetadataKey]any),
	}
	require.NoError(t, os.Setenv("NODENAME", "archbunny"))
	transf, err := transformers.Load(transformers.Config{Type: transformers.Tags, Transformer: Config{Tags: []Tag{{Key: "env", Value: "staging"}, {Key: "zone", Value: "dmz"}, {Key: "node", Value: "%NODENAME%"}}}})
	require.NoError(t, err)

	require.NoError(t, transf.Transform(evt))

	require.Len(t, evt.Metadata, 3)

	assert.Equal(t, "staging", evt.Metadata["env"])
	assert.Equal(t, "dmz", evt.Metadata["zone"])
	assert.Equal(t, "archbunny", evt.Metadata["node"])
}

```

`pkg/aggregator/transformers/transformer.go`:

```go
/*
 * Copyright 2019-2020 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package transformers

import (
	"fmt"
	"github.com/rabbitstack/fibratus/pkg/event"
)

var transformers = map[Type]Factory{}

// Factory defines the function for transformer factories
type Factory func(config Config) (Transformer, error)

// Type defines the alias for the transformer types
type Type uint8

const (
	// Remove represents the remove transformer type. This transformer deletes the given list of parameters from the event.
	Remove Type = iota
	// Rename represents the rename transformer type. It renames a sequence of Param from old to new names.
	Rename
	// Replace represents the replace transformer type. It applies string replacements on specific params.
	Replace
	// Trim represents the trim transformer type that that removes suffix/prefix from string params.
	Trim
	// Tags represents the tags transformer type. This transformer appends tags to the event's metadata.
	Tags
)

// String returns the type human-readable name.
func (typ Type) String() string {
	switch typ {
	case Remove:
		return "remove"
	case Rename:
		return "rename"
	case Replace:
		return "replace"
	case Trim:
		return "trim"
	case Tags:
		return "tags"
	default:
		return "unknown"
	}
}

// Register registers a singleton instance of the provided transformer.
func Register(typ Type, factory Factory) {
	if _, ok := transformers[typ]; ok {
		panic(fmt.Sprintf("output %q is already registered", typ))
	}
	transformers[typ] = factory
}

// LoadAll loads all transformers from the configuration inputs.
func LoadAll(configs []Config) ([]Transformer, error) {
	transformers := make([]Transformer, len(configs))
	for i, config := range configs {
		transformer, err := Load(config)
		if err != nil {
			return nil, err
		}
		transformers[i] = transformer
	}
	return transformers, nil
}

// Load loads a single transformer from the configuration.
func Load(config Config) (Transformer, error) {
	typ := config.Type
	factory := transformers[typ]
	if factory == nil {
		return nil, fmt.Errorf("%q transformer not available in the factory", typ)
	}
	return factory(config)
}

// Transformer is the minimal interface all transformers have to satisfy.
type Transformer interface {
	Transform(*event.Event) error
}

```

`pkg/aggregator/transformers/trim/config.go`:

```go
/*
 * Copyright 2019-2020 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package trim

import "github.com/spf13/pflag"

const (
	enabled = "transformers.trim.enabled"
)

// Trim defines the trim configuration for a single event parameter.
type Trim struct {
	Name string `mapstructure:"Param"`
	Trim string `mapstructure:"trim"`
}

// Config stores the configuration for the trim transformer.
type Config struct {
	// Prefixes contains the mapping between distinct Param names and the prefixes that will get trimmed from their values.
	Prefixes []Trim `mapstructure:"prefixes"`
	// Suffixes contains the mapping between distinct Param names and the suffixes that will get trimmed from their values.
	Suffixes []Trim `mapstructure:"suffixes"`
	// Enabled determines whether trim transformer is enabled or disabled.
	Enabled bool `mapstructure:"enabled"`
}

// AddFlags registers persistent flags.
func AddFlags(flags *pflag.FlagSet) {
	flags.Bool(enabled, false, "Indicates if the trim transformer is enabled")
}

```

`pkg/aggregator/transformers/trim/trim.go`:

```go
/*
 * Copyright 2019-2020 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package trim

import (
	"github.com/rabbitstack/fibratus/pkg/aggregator/transformers"
	"github.com/rabbitstack/fibratus/pkg/event"
	"strings"
)

// trim transformer trims suffixes/prefixes from par values.
type trim struct {
	c Config
}

func init() {
	transformers.Register(transformers.Trim, initTrimTransformer)
}

func initTrimTransformer(config transformers.Config) (transformers.Transformer, error) {
	cfg, ok := config.Transformer.(Config)
	if !ok {
		return nil, transformers.ErrInvalidConfig(transformers.Trim)
	}
	return &trim{c: cfg}, nil
}

func (r trim) Transform(evt *event.Event) error {
	for _, par := range evt.Params {
		// trim prefixes
		for _, pre := range r.c.Prefixes {
			if par.Name != pre.Name {
				continue
			}
			_, ok := par.Value.(string)
			if !ok {
				continue
			}
			par.Value = strings.TrimPrefix(evt.GetParamAsString(par.Name), pre.Trim)
		}
		// trim suffixes
		for _, suf := range r.c.Suffixes {
			if par.Name != suf.Name {
				continue
			}
			_, ok := par.Value.(string)
			if !ok {
				continue
			}
			par.Value = strings.TrimSuffix(evt.GetParamAsString(par.Name), suf.Trim)
		}
	}
	return nil
}

```

`pkg/aggregator/transformers/trim/trim_test.go`:

```go
/*
 * Copyright 2019-2020 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package trim

import (
	"github.com/rabbitstack/fibratus/pkg/aggregator/transformers"
	"github.com/rabbitstack/fibratus/pkg/event"
	"github.com/rabbitstack/fibratus/pkg/event/params"
	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/require"
	"testing"
	"time"
)

func TestTransform(t *testing.T) {
	evt := &event.Event{
		Type:        event.CreateFile,
		Tid:         2484,
		PID:         859,
		CPU:         1,
		Seq:         2,
		Name:        "CreateFile",
		Category:    event.File,
		Host:        "archrabbit",
		Description: "Creates or opens a new file, directory, I/O device, pipe, console",
		Params: event.Params{
			params.FileObject:    {Name: params.FileObject, Type: params.Uint64, Value: uint64(12456738026482168384)},
			params.FilePath:      {Name: params.FilePath, Type: params.UnicodeString, Value: "\\Device\\HarddiskVolume2\\Windows\\system32\\user32.dll"},
			params.FileType:      {Name: params.FileType, Type: params.AnsiString, Value: "file"},
			params.FileOperation: {Name: params.FileOperation, Type: params.AnsiString, Value: "overwriteif"},
			params.BasePrio:      {Name: params.BasePrio, Type: params.Int8, Value: int8(2)},
			params.PagePrio:      {Name: params.PagePrio, Type: params.Uint8, Value: uint8(2)},
			params.KstackLimit:   {Name: params.KstackLimit, Type: params.Address, Value: uint64(18884888488889)},
			params.StartTime:     {Name: params.StartTime, Type: params.Time, Value: time.Now()},
			params.ProcessID:     {Name: params.ProcessID, Type: params.PID, Value: uint32(1204)},
		},
		Metadata: map[event.MetadataKey]any{"foo": "bar", "fooz": "barz"},
	}

	transf, err := transformers.Load(transformers.Config{Type: transformers.Trim, Transformer: Config{Prefixes: []Trim{{Name: "file_path", Trim: "\\Device"}}, Suffixes: []Trim{{Name: "create_disposition", Trim: "if"}}}})
	require.NoError(t, err)

	require.NoError(t, transf.Transform(evt))
	filename, _ := evt.Params.GetString(params.FilePath)
	dispo, _ := evt.Params.GetString(params.FileOperation)

	assert.Equal(t, "\\HarddiskVolume2\\Windows\\system32\\user32.dll", filename)
	assert.Equal(t, "overwrite", dispo)
}

```

`pkg/aggregator/worker.go`:

```go
/*
 * Copyright 2019-2020 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package aggregator

import (
	"expvar"
	"github.com/rabbitstack/fibratus/pkg/outputs"
	log "github.com/sirupsen/logrus"
	"time"
)

// maxBackoff determines the maximum exponential backoff wait time before reconnecting the client
const maxBackoff = time.Minute

var clientPublishErrors = expvar.NewInt("aggregator.worker.client.publish.errors")

type worker struct {
	qu      queue
	client  outputs.Client
	backoff time.Duration
}

func initWorker(q queue, client outputs.Client) *worker {
	w := &worker{qu: q, client: client, backoff: time.Second * 2}
	go w.run()
	return w
}

func (w *worker) run() {
	for {
		err := w.client.Connect()
		if err != nil {
			// schedule an exponential backoff reconnect strategy for the client
			w.backoff *= 2
			log.Warnf("fail to connect the client: %v. Reconnecting in %v...", err, w.backoff)
			if w.backoff > maxBackoff {
				w.backoff = maxBackoff
			}
			<-time.After(w.backoff)
			continue
		}
		break
	}
	for batch := range w.qu {
		if err := w.client.Publish(batch); err != nil {
			clientPublishErrors.Add(1)
			log.Warnf("couldn't publish batch to client: %v", err)
		}
	}
}

func (w *worker) close() error {
	return w.client.Close()
}

```

`pkg/aggregator/worker_test.go`:

```go
/*
 * Copyright 2019-2020 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package aggregator

import (
	"github.com/rabbitstack/fibratus/pkg/event"
	"github.com/stretchr/testify/assert"
	"net/http"
	"net/http/httptest"
	"testing"
	"time"
)

type httpClient struct {
	url               string
	published         int
	expectedPublished int
	wait              chan struct{}
}

func (c *httpClient) Connect() error {
	//nolint:noctx
	res, err := http.Get(c.url + "/connect")
	if err != nil {
		return err
	}
	defer func() {
		_ = res.Body.Close()
	}()
	if res.StatusCode != http.StatusOK {
		return err
	}
	return nil
}

func (c *httpClient) Close() error { return nil }

func (c *httpClient) Publish(b *event.Batch) error {
	//nolint:noctx
	res, err := http.Post(c.url+"/publish", "application/json", nil)
	if err != nil {
		return err
	}
	defer func() {
		_ = res.Body.Close()
	}()
	c.published++
	if c.published == c.expectedPublished {
		c.wait <- struct{}{}
	}
	return nil
}

func TestRunWorker(t *testing.T) {
	q := make(chan *event.Batch, 2)
	q <- &event.Batch{}
	q <- &event.Batch{}

	mux := http.NewServeMux()
	mux.HandleFunc("/publish", func(w http.ResponseWriter, r *http.Request) {
		w.WriteHeader(http.StatusOK)
	})

	srv := httptest.NewServer(mux)
	defer srv.Close()

	client := &httpClient{url: srv.URL, wait: make(chan struct{}, 1), expectedPublished: 2}

	w := initWorker(q, client)
	defer w.close()

	<-client.wait

	assert.Equal(t, 2, client.published)
}

func TestConnectClientBackoff(t *testing.T) {
	q := make(chan *event.Batch, 2)
	q <- &event.Batch{}
	q <- &event.Batch{}

	fail := true

	mux := http.NewServeMux()
	mux.HandleFunc("/publish", func(w http.ResponseWriter, r *http.Request) {
		w.WriteHeader(http.StatusOK)
	})
	mux.HandleFunc("/connect", func(w http.ResponseWriter, r *http.Request) {
		if fail {
			w.WriteHeader(http.StatusInternalServerError)
			return
		}
		w.WriteHeader(http.StatusOK)
	})

	srv := httptest.NewServer(mux)
	defer srv.Close()

	client := &httpClient{url: srv.URL, wait: make(chan struct{}, 1), expectedPublished: 2}

	go time.AfterFunc(time.Second*3, func() {
		fail = false
	})

	w := initWorker(q, client)
	defer w.close()

	<-client.wait

	assert.Equal(t, 2, client.published)
}

```

`pkg/alertsender/alert.go`:

```go
/*
 * Copyright 2019-2020 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package alertsender

import (
	"bytes"
	"encoding/json"
	"fmt"
	"reflect"
	"strings"
	"time"

	"github.com/mitchellh/mapstructure"

	"github.com/rabbitstack/fibratus/pkg/event"
	"github.com/rabbitstack/fibratus/pkg/event/params"
	"github.com/yuin/goldmark"
	"github.com/yuin/goldmark/extension"
	"github.com/yuin/goldmark/renderer/html"
)

// Severity is the type alias for alert's severity level.
type Severity uint8

const (
	// Normal designates alert's normal level
	Normal Severity = iota
	// Medium designates alert's medium level
	Medium
	// High designates alert's high level
	High
	// Critical designates alert's critical level
	Critical
)

// String returns severity human-friendly name.
func (s Severity) String() string {
	switch s {
	case Normal:
		return "low"
	case Medium:
		return "medium"
	case High:
		return "high"
	case Critical:
		return "critical"
	default:
		return "unknown"
	}
}

// StringToSeverityDecodeHook converts severity string to integer.
func StringToSeverityDecodeHook() mapstructure.DecodeHookFuncType {
	return func(
		from reflect.Type,
		to reflect.Type,
		data any,
	) (any, error) {
		if from.Kind() != reflect.String {
			return data, nil
		}

		if to != reflect.TypeOf(Severity(0)) {
			return data, nil
		}

		return ParseSeverityFromString(data.(string)), nil
	}
}

// ParseSeverityFromString parses the severity from the string representation.
func ParseSeverityFromString(sever string) Severity {
	switch sever {
	case "normal", "Normal", "NORMAL", "low", "LOW":
		return Normal
	case "medium", "Medium", "MEDIUM":
		return Medium
	case "high", "High", "HIGH":
		return High
	case "critical", "Critical", "CRITICAL":
		return Critical
	default:
		return Normal
	}
}

// Alert encapsulates the state of an alert.
type Alert struct {
	// ID identifies the alert. Note that the ID may not be unique
	// for every distinct instance of the generated alert. For runtime
	// rules, the alert id equals to the rule identifier.
	ID string
	// Title is the short title that summarizes the purpose of the alert.
	Title string
	// Text is the longer textual content that further explains what this alert is about.
	Text string
	// Tags contains a sequence of tags for categorizing the alerts.
	Tags []string
	// Labels is an arbitrary collection of key-value pairs.
	Labels map[string]string
	// Description represents a longer explanation of the alert. It is
	// typically a description of adversary tactics, techniques or any
	// information valuable to the analyst.
	Description string
	// Severity determines the severity of this alert.
	Severity Severity
	// Events contains a list of events that trigger the alert.
	Events []*event.Event
}

// String returns the alert string representation. If verbose
// argument is set to true, the event summary is included in
// the alert.
func (a Alert) String(verbose bool) string {
	if verbose {
		var b strings.Builder
		if len(a.Events) > 1 {
			b.WriteString("System events involved in this alert:\n\n")
		} else {
			b.WriteString("System event involved in this alert:\n\n")
		}
		for n, evt := range a.Events {
			b.WriteString(fmt.Sprintf("\tEvent #%d:\n", n+1))
			b.WriteString(strings.TrimSuffix(evt.StringShort(), "\t"))
		}
		if a.Text == "" {
			return fmt.Sprintf("%s\n\nSeverity: %s\n\n%s", a.Title, a.Severity, b.String())
		}
		return fmt.Sprintf("%s\n\n%s\n\nSeverity: %s\n\n%s", a.Title, a.Text, a.Severity, b.String())
	}

	if a.Text == "" {
		return a.Title
	}
	return fmt.Sprintf("%s\n\n%s", a.Title, a.Text)
}

// MDToHTML converts alert's text Markdown elements to HTML blocks.
func (a *Alert) MDToHTML() error {
	md := goldmark.New(
		goldmark.WithExtensions(extension.GFM),
		goldmark.WithRendererOptions(html.WithUnsafe()),
	)
	var w bytes.Buffer
	err := md.Convert([]byte(a.Text), &w)
	if err != nil {
		return err
	}
	a.Text = w.String()
	return nil
}

// MarshalJSON encodes the alert to JSON format.
func (a Alert) MarshalJSON() ([]byte, error) {
	var msg = &struct {
		ID          string            `json:"id"`
		Title       string            `json:"title"`
		Severity    string            `json:"severity"`
		Text        string            `json:"text,omitempty"`
		Description string            `json:"description"`
		Labels      map[string]string `json:"labels,omitempty"`
		Events      []struct {
			Name      string         `json:"name"`
			Category  string         `json:"category"`
			Timestamp time.Time      `json:"timestamp"`
			Params    map[string]any `json:"params"`
			Callstack []string       `json:"callstack,omitempty"`
			Proc      *struct {
				PID            uint32   `json:"pid"`
				TID            uint32   `json:"tid"`
				PPID           uint32   `json:"ppid"`
				Name           string   `json:"name"`
				Exe            string   `json:"exe"`
				Cmdline        string   `json:"cmdline,omitempty"`
				Pname          string   `json:"parent_name,omitempty"`
				Pcmdline       string   `json:"parent_cmdline,omitempty"`
				Cwd            string   `json:"cwd,omitempty"`
				SID            string   `json:"sid"`
				Username       string   `json:"username"`
				Domain         string   `json:"domain"`
				SessionID      uint32   `json:"session_id"`
				IntegrityLevel string   `json:"integrity_level"`
				IsWOW64        bool     `json:"is_wow64"`
				IsPackaged     bool     `json:"is_packaged"`
				IsProtected    bool     `json:"is_protected"`
				Ancestors      []string `json:"ancestors"`
			} `json:"proc,omitempty"`
		} `json:"events"`
	}{
		ID:          a.ID,
		Title:       a.Title,
		Severity:    a.Severity.String(),
		Text:        a.Text,
		Description: a.Description,
		Labels:      a.Labels,
	}

	events := make([]struct {
		Name      string         `json:"name"`
		Category  string         `json:"category"`
		Timestamp time.Time      `json:"timestamp"`
		Params    map[string]any `json:"params"`
		Callstack []string       `json:"callstack,omitempty"`
		Proc      *struct {
			PID            uint32   `json:"pid"`
			TID            uint32   `json:"tid"`
			PPID           uint32   `json:"ppid"`
			Name           string   `json:"name"`
			Exe            string   `json:"exe"`
			Cmdline        string   `json:"cmdline,omitempty"`
			Pname          string   `json:"parent_name,omitempty"`
			Pcmdline       string   `json:"parent_cmdline,omitempty"`
			Cwd            string   `json:"cwd,omitempty"`
			SID            string   `json:"sid"`
			Username       string   `json:"username"`
			Domain         string   `json:"domain"`
			SessionID      uint32   `json:"session_id"`
			IntegrityLevel string   `json:"integrity_level"`
			IsWOW64        bool     `json:"is_wow64"`
			IsPackaged     bool     `json:"is_packaged"`
			IsProtected    bool     `json:"is_protected"`
			Ancestors      []string `json:"ancestors"`
		} `json:"proc,omitempty"`
	}, 0, len(a.Events))

	for _, e := range a.Events {
		var evt = struct {
			Name      string         `json:"name"`
			Category  string         `json:"category"`
			Timestamp time.Time      `json:"timestamp"`
			Params    map[string]any `json:"params"`
			Callstack []string       `json:"callstack,omitempty"`
			Proc      *struct {
				PID            uint32   `json:"pid"`
				TID            uint32   `json:"tid"`
				PPID           uint32   `json:"ppid"`
				Name           string   `json:"name"`
				Exe            string   `json:"exe"`
				Cmdline        string   `json:"cmdline,omitempty"`
				Pname          string   `json:"parent_name,omitempty"`
				Pcmdline       string   `json:"parent_cmdline,omitempty"`
				Cwd            string   `json:"cwd,omitempty"`
				SID            string   `json:"sid"`
				Username       string   `json:"username"`
				Domain         string   `json:"domain"`
				SessionID      uint32   `json:"session_id"`
				IntegrityLevel string   `json:"integrity_level"`
				IsWOW64        bool     `json:"is_wow64"`
				IsPackaged     bool     `json:"is_packaged"`
				IsProtected    bool     `json:"is_protected"`
				Ancestors      []string `json:"ancestors"`
			} `json:"proc,omitempty"`
		}{
			Name:      e.Name,
			Category:  string(e.Category),
			Timestamp: e.Timestamp,
			Params:    make(map[string]any),
			Callstack: make([]string, 0, len(e.Callstack)),
		}

		// populate event parameters
		for _, param := range e.Params {
			if param.Type == params.Bool || param.Type == params.PID ||
				param.Type == params.TID || param.Type == params.Port || param.IsNumber() {
				evt.Params[param.Name] = param.Value
			} else {
				evt.Params[param.Name] = param.String()
			}
		}

		// populate callstack
		for i := range e.Callstack {
			frame := e.Callstack[len(e.Callstack)-i-1]
			evt.Callstack = append(evt.Callstack, fmt.Sprintf("%s %s!%s", frame.Addr, frame.Module, frame.Symbol))
		}

		ps := e.PS
		if ps != nil {
			evt.Proc = &struct {
				PID            uint32   `json:"pid"`
				TID            uint32   `json:"tid"`
				PPID           uint32   `json:"ppid"`
				Name           string   `json:"name"`
				Exe            string   `json:"exe"`
				Cmdline        string   `json:"cmdline,omitempty"`
				Pname          string   `json:"parent_name,omitempty"`
				Pcmdline       string   `json:"parent_cmdline,omitempty"`
				Cwd            string   `json:"cwd,omitempty"`
				SID            string   `json:"sid"`
				Username       string   `json:"username"`
				Domain         string   `json:"domain"`
				SessionID      uint32   `json:"session_id"`
				IntegrityLevel string   `json:"integrity_level"`
				IsWOW64        bool     `json:"is_wow64"`
				IsPackaged     bool     `json:"is_packaged"`
				IsProtected    bool     `json:"is_protected"`
				Ancestors      []string `json:"ancestors"`
			}{
				PID:            ps.PID,
				TID:            e.Tid,
				PPID:           ps.Ppid,
				Name:           ps.Name,
				Exe:            ps.Exe,
				Cmdline:        ps.Cmdline,
				Cwd:            ps.Cwd,
				SID:            ps.SID,
				Username:       ps.Username,
				Domain:         ps.Domain,
				SessionID:      ps.SessionID,
				IntegrityLevel: ps.TokenIntegrityLevel,
				IsWOW64:        ps.IsWOW64,
				IsPackaged:     ps.IsPackaged,
				IsProtected:    ps.IsProtected,
				Ancestors:      ps.Ancestors(),
			}
			if ps.Parent != nil {
				evt.Proc.Pname = ps.Parent.Name
				evt.Proc.Pcmdline = ps.Parent.Cmdline
			}
		}

		events = append(events, evt)
	}
	msg.Events = events

	return json.Marshal(msg)
}

// NewAlert builds a new alert.
func NewAlert(title, text string, tags []string, severity Severity) Alert {
	return Alert{Title: title, Text: text, Tags: tags, Severity: severity}
}

// NewAlertWithEvents builds a new alert with associated events.
func NewAlertWithEvents(title, text string, tags []string, severity Severity, evts []*event.Event) Alert {
	return Alert{Title: title, Text: text, Tags: tags, Severity: severity, Events: evts}
}

```

`pkg/alertsender/alert_test.go`:

```go
/*
 * Copyright 2021-2022 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package alertsender

import (
	"encoding/json"
	"testing"

	"github.com/rabbitstack/fibratus/pkg/event"
	"github.com/rabbitstack/fibratus/pkg/event/params"
	pstypes "github.com/rabbitstack/fibratus/pkg/ps/types"
	"github.com/stretchr/testify/require"
)

func TestAlertString(t *testing.T) {
	var tests = []struct {
		alert      Alert
		verbose    bool
		wantString string
	}{
		{
			NewAlert("Credential discovery via VaultCmd.exe", "", nil, Normal),
			false,
			"Credential discovery via VaultCmd.exe",
		},
		{
			NewAlert("Credential discovery via VaultCmd.exe", "Suspicious vault enumeration via VaultCmd tool", nil, Normal),
			false,
			"Credential discovery via VaultCmd.exe\n\nSuspicious vault enumeration via VaultCmd tool",
		},
		{
			NewAlertWithEvents("Credential discovery via VaultCmd.exe", "Suspicious vault enumeration via VaultCmd tool", nil, Normal, []*event.Event{{
				Type:     event.CreateProcess,
				Category: event.Process,
				Params: event.Params{
					params.Cmdline:     {Name: params.Cmdline, Type: params.UnicodeString, Value: "C:\\Windows\\system32\\svchost-fake.exe -k RPCSS"},
					params.ProcessName: {Name: params.ProcessName, Type: params.AnsiString, Value: "svchost-fake.exe"}},
				Name: "CreateProcess",
				PID:  1023,
				PS: &pstypes.PS{
					Name:                "svchost.exe",
					Cmdline:             "C:\\Windows\\System32\\svchost.exe",
					Ppid:                345,
					Username:            "SYSTEM",
					Domain:              "NT AUTHORITY",
					SID:                 "S-1-5-18",
					TokenIntegrityLevel: "HIGH",
				},
			}}),
			true,
			"Credential discovery via VaultCmd.exe\n\nSuspicious vault enumeration via VaultCmd tool\n\nSeverity: low\n\nSystem event involved in this alert:\n\n\tEvent #1:\n\n\t\tSeq: 0\n\t\tPid: 1023\n\t\tTid: 0\n\t\tName: CreateProcess\n\t\tCategory: process\n\t\tHost: \n\t\tTimestamp: 0001-01-01 00:00:00 +0000 UTC\n\t\tParameters: cmdline➜ C:\\Windows\\system32\\svchost-fake.exe -k RPCSS, name➜ svchost-fake.exe\n    \n\t\tPid:  0\n\t\tPpid: 345\n\t\tName: svchost.exe\n\t\tCmdline: C:\\Windows\\System32\\svchost.exe\n\t\tExe: \n\t\tCwd: \n\t\tSID: S-1-5-18\n\t\tIntegrity level: HIGH\n\t\tUsername: SYSTEM\n\t\tDomain: NT AUTHORITY\n\t\tArgs: []\n\t\tSession ID: 0\n\t\tAncestors: \n\t\n",
		},
		{
			NewAlertWithEvents("Credential discovery via VaultCmd.exe", "", nil, Normal, []*event.Event{{
				Type:     event.CreateProcess,
				Category: event.Process,
				Params: event.Params{
					params.Cmdline:     {Name: params.Cmdline, Type: params.UnicodeString, Value: "C:\\Windows\\system32\\svchost-fake.exe -k RPCSS"},
					params.ProcessName: {Name: params.ProcessName, Type: params.AnsiString, Value: "svchost-fake.exe"}},
				Name: "CreateProcess",
				PID:  1023,
				PS: &pstypes.PS{
					Name:                "svchost.exe",
					Cmdline:             "C:\\Windows\\System32\\svchost.exe",
					Ppid:                345,
					Username:            "SYSTEM",
					Domain:              "NT AUTHORITY",
					SID:                 "S-1-5-18",
					TokenIntegrityLevel: "HIGH",
				},
			}}),
			true,
			"Credential discovery via VaultCmd.exe\n\nSeverity: low\n\nSystem event involved in this alert:\n\n\tEvent #1:\n\n\t\tSeq: 0\n\t\tPid: 1023\n\t\tTid: 0\n\t\tName: CreateProcess\n\t\tCategory: process\n\t\tHost: \n\t\tTimestamp: 0001-01-01 00:00:00 +0000 UTC\n\t\tParameters: cmdline➜ C:\\Windows\\system32\\svchost-fake.exe -k RPCSS, name➜ svchost-fake.exe\n    \n\t\tPid:  0\n\t\tPpid: 345\n\t\tName: svchost.exe\n\t\tCmdline: C:\\Windows\\System32\\svchost.exe\n\t\tExe: \n\t\tCwd: \n\t\tSID: S-1-5-18\n\t\tIntegrity level: HIGH\n\t\tUsername: SYSTEM\n\t\tDomain: NT AUTHORITY\n\t\tArgs: []\n\t\tSession ID: 0\n\t\tAncestors: \n\t\n",
		},
	}

	for _, tt := range tests {
		t.Run(tt.wantString, func(t *testing.T) {
			require.Equal(t, tt.wantString, tt.alert.String(tt.verbose))
		})
	}
}

func TestAlertJSON(t *testing.T) {
	alert := NewAlertWithEvents("Credential discovery via VaultCmd.exe", "Suspicious vault enumeration via VaultCmd tool", nil, Normal, []*event.Event{{
		Type:     event.CreateProcess,
		Category: event.Process,
		Params: event.Params{
			params.Cmdline:     {Name: params.Cmdline, Type: params.UnicodeString, Value: "C:\\Windows\\system32\\svchost-fake.exe -k RPCSS"},
			params.ProcessName: {Name: params.ProcessName, Type: params.AnsiString, Value: "svchost-fake.exe"}},
		Name: "CreateProcess",
		PID:  1023,
		PS: &pstypes.PS{
			Name:                "svchost.exe",
			Cmdline:             "C:\\Windows\\System32\\svchost.exe",
			Ppid:                345,
			Username:            "SYSTEM",
			Domain:              "NT AUTHORITY",
			SID:                 "S-1-5-18",
			TokenIntegrityLevel: "HIGH",
		},
	}})

	alert.ID = "64af2e2e-2309-4079-9c0f-985f1dd930f5"

	b, err := json.MarshalIndent(alert, "", "  ")
	require.NoError(t, err)

	expectedJSON := "{\n  \"id\": \"64af2e2e-2309-4079-9c0f-985f1dd930f5\",\n  \"title\": \"Credential discovery via VaultCmd.exe\",\n  \"severity\": \"low\",\n  \"text\": \"Suspicious vault enumeration via VaultCmd tool\",\n  \"description\": \"\",\n  \"events\": [\n    {\n      \"name\": \"CreateProcess\",\n      \"category\": \"process\",\n      \"timestamp\": \"0001-01-01T00:00:00Z\",\n      \"params\": {\n        \"cmdline\": \"C:\\\\Windows\\\\system32\\\\svchost-fake.exe -k RPCSS\",\n        \"name\": \"svchost-fake.exe\"\n      },\n      \"proc\": {\n        \"pid\": 0,\n        \"tid\": 0,\n        \"ppid\": 345,\n        \"name\": \"svchost.exe\",\n        \"exe\": \"\",\n        \"cmdline\": \"C:\\\\Windows\\\\System32\\\\svchost.exe\",\n        \"sid\": \"S-1-5-18\",\n        \"username\": \"SYSTEM\",\n        \"domain\": \"NT AUTHORITY\",\n        \"session_id\": 0,\n        \"integrity_level\": \"HIGH\",\n        \"is_wow64\": false,\n        \"is_packaged\": false,\n        \"is_protected\": false,\n        \"ancestors\": []\n      }\n    }\n  ]\n}"

	require.Equal(t, expectedJSON, string(b))
}

```

`pkg/alertsender/config.go`:

```go
/*
 * Copyright 2019-2020 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package alertsender

// Config is the container for the alert sender configuration structure.
type Config struct {
	Type   Type
	Sender interface{}
}

```

`pkg/alertsender/eventlog/config.go`:

```go
/*
 * Copyright 2019-2024 by Nedim Sabic Sabic and Contributors
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package eventlog

import (
	"github.com/spf13/pflag"
)

const (
	enabled = "alertsenders.eventlog.enabled"
	verbose = "alertsenders.eventlog.verbose"
	format  = "alertsenders.eventlog.format"

	prettyFormat = "pretty"
	jsonFormat   = "json"
)

// Config defines the configuration for the eventlog sender.
type Config struct {
	// Enabled indicates if the eventlog sender is enabled.
	Enabled bool `mapstructure:"enabled"`
	// Verbose activates verbose mode. In verbose mode, the full
	// event context, including parameters and the process
	// state are included in the log message.
	Verbose bool `mapstructure:"verbose"`
	// Format specifies the eventlog record format for the alert.
	// Can be pretty or json.
	Format string `mapstructure:"format"`
}

// AddFlags registers persistent flags.
func AddFlags(flags *pflag.FlagSet) {
	flags.Bool(enabled, true, "Indicates if eventlog alert sender is enabled")
	flags.Bool(verbose, true, "Enables/disables the verbose mode. In verbose mode, the full event context, including all parameters and the process information are included in the log message")
	flags.String(format, "pretty", "Specifies the eventlog record format for the alert. Can be pretty|json")
}

```

`pkg/alertsender/eventlog/eventlog.go`:

```go
/*
 * Copyright 2019-2024 by Nedim Sabic Sabic and Contributors
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package eventlog

import (
	"encoding/json"
	"errors"
	"fmt"
	"hash/crc32"
	"strings"

	"github.com/rabbitstack/fibratus/pkg/alertsender"
	evlog "github.com/rabbitstack/fibratus/pkg/util/eventlog"
	"golang.org/x/sys/windows"
)

const minIDChars = 12

type eventlog struct {
	log    windows.Handle
	config Config
}

func init() {
	alertsender.Register(alertsender.Eventlog, makeSender)
}

func makeSender(config alertsender.Config) (alertsender.Sender, error) {
	c, ok := config.Sender.(Config)
	if !ok {
		return nil, alertsender.ErrInvalidConfig(alertsender.Eventlog)
	}
	sourceName, err := windows.UTF16PtrFromString(evlog.Source)
	if err != nil {
		return nil, fmt.Errorf("could not convert source name: %v", err)
	}

	err = evlog.Install(evlog.Levels)
	if err != nil {
		if !errors.Is(err, evlog.ErrKeyExists) {
			return nil, err
		}
	}

	h, err := windows.RegisterEventSource(nil, sourceName)
	if err != nil {
		return nil, fmt.Errorf("could not register event source: %v", err)
	}
	return &eventlog{log: h, config: c}, nil
}

// Send logs the alert to the eventlog.
func (s *eventlog) Send(alert alertsender.Alert) error {
	var code uint16
	// despite the event id is 4-byte long
	// we can only use 2 bytes to store the
	// event code. Calculate the hash
	// of the event code from alert identifier
	// but keeping in mind collisions are
	// possible since we're mapping a larger
	// space to a smaller one
	if len(alert.ID) > minIDChars {
		// assume alert ID has the UUID format
		// where we build the short version by
		// taking the first 12 characters
		id := strings.ReplaceAll(alert.ID, "-", "")
		h := crc32.ChecksumIEEE([]byte(id[:minIDChars]))
		// take the lower 16 bits of the CRC32 hash
		code = uint16(h & 0xFFFF)
	}

	// build the eventlog event
	var msg string
	switch s.config.Format {
	case prettyFormat:
		msg = alert.String(s.config.Verbose)
	case jsonFormat:
		b, err := json.MarshalIndent(alert, "", "  ")
		if err != nil {
			return err
		}
		msg = string(b)
	}

	// trim null characters to avoid
	// UTF16PtrFromString complaints
	msg = strings.ReplaceAll(msg, "\x00", "")

	m, err := windows.UTF16PtrFromString(msg)
	if err != nil {
		return fmt.Errorf("could not convert eventlog message to UTF16: %v: %s", err, msg)
	}

	return windows.ReportEvent(s.log, windows.EVENTLOG_INFORMATION_TYPE, 0,
		evlog.EventID(windows.EVENTLOG_INFORMATION_TYPE, code),
		uintptr(0),
		1, 0, &m, nil)
}

// Shutdown deregisters the event source.
func (s *eventlog) Shutdown() error {
	if s.log != windows.InvalidHandle {
		return windows.DeregisterEventSource(s.log)
	}
	return nil
}

func (s *eventlog) Type() alertsender.Type { return alertsender.Eventlog }
func (s *eventlog) SupportsMarkdown() bool { return false }

```

`pkg/alertsender/eventlog/eventlog_test.go`:

```go
/*
 * Copyright 2019-2024 by Nedim Sabic Sabic and Contributors
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package eventlog

import (
	"testing"
	"time"

	"github.com/rabbitstack/fibratus/pkg/alertsender"
	"github.com/rabbitstack/fibratus/pkg/event"
	"github.com/rabbitstack/fibratus/pkg/event/params"
	htypes "github.com/rabbitstack/fibratus/pkg/handle/types"
	pex "github.com/rabbitstack/fibratus/pkg/pe"
	pstypes "github.com/rabbitstack/fibratus/pkg/ps/types"
	"github.com/rabbitstack/fibratus/pkg/util/va"
	"github.com/stretchr/testify/require"
	"golang.org/x/sys/windows"
)

func TestEventlogSender(t *testing.T) {
	s, err := alertsender.Load(alertsender.Config{Type: alertsender.Eventlog, Sender: Config{Verbose: true, Enabled: true, Format: prettyFormat}})
	require.NoError(t, err)
	require.NotNil(t, s)

	require.NoError(t, s.Send(alertsender.Alert{
		Events: []*event.Event{
			{
				Type:        event.CreateFile,
				Tid:         2484,
				PID:         859,
				CPU:         1,
				Seq:         2,
				Name:        "CreateFile",
				Timestamp:   time.Now(),
				Category:    event.File,
				Host:        "archrabbit",
				Description: "Creates or opens a new file, directory, I/O device, pipe, console",
				Params: event.Params{
					params.FileObject:    {Name: params.FileObject, Type: params.Uint64, Value: uint64(12456738026482168384)},
					params.FilePath:      {Name: params.FilePath, Type: params.UnicodeString, Value: "C:\\Windows\\system32\\user32.dll"},
					params.FileType:      {Name: params.FileType, Type: params.AnsiString, Value: "file"},
					params.FileOperation: {Name: params.FileOperation, Type: params.Enum, Value: uint32(1)},
				},
				Metadata: map[event.MetadataKey]any{"foo": "bar", "fooz": "barzz"},
				PS: &pstypes.PS{
					PID:  2436,
					Ppid: 6304,
					Parent: &pstypes.PS{
						PID:  2034,
						Name: "explorer.exe",
						Exe:  `C:\Windows\System32\explorer.exe`,
						Cwd:  `C:\Windows\System32`,
						SID:  "admin\\SYSTEM",
						Parent: &pstypes.PS{
							PID:  2345,
							Name: "winlogon.exe",
						},
					},
					Name:      "firefox.exe",
					Exe:       `C:\Program Files\Mozilla Firefox\firefox.exe`,
					Cmdline:   `C:\Program Files\Mozilla Firefox\firefox.exe -contentproc --channel="6304.3.1055809391\1014207667" -childID 1 -isForBrowser -prefsHandle 2584 -prefMapHandle 2580 -prefsLen 70 -prefMapSize 216993 -parentBuildID 20200107212822 -greomni "C:\Program Files\Mozilla Firefox\omni.ja" -appomni "C:\Program Files\Mozilla Firefox\browser\omni.ja" -appdir "C:\Program Files\Mozilla Firefox\browser" - 6304 "\\.\pipe\gecko-crash-server-pipe.6304" 2596 tab`,
					Cwd:       `C:\Program Files\Mozilla Firefox\`,
					SID:       "archrabbit\\SYSTEM",
					Args:      []string{"-contentproc", `--channel=6304.3.1055809391\1014207667`, "-childID", "1", "-isForBrowser", "-prefsHandle", "2584", "-prefMapHandle", "2580", "-prefsLen", "70", "-prefMapSize", "216993", "-parentBuildID"},
					SessionID: 4,
					Envs:      map[string]string{"ProgramData": "C:\\ProgramData", "COMPUTRENAME": "archrabbit", "Path": "C:\\Program Files (x86)\\Common Files\\Oracle\\Java\\javapath;C:\\WINDOWS\\system32;C:\\WINDOWS;C:\\WINDOWS\\System32\\Wbem;C:\\WINDOWS\\System32\\WindowsPowerShell\\v1.0\\;C:\\Program Files\\Git\\cmd;C:\\msys64\\mingw64\\bin;C:\\WINDOWS\\System32\\OpenSSH\\;C:\\Program Files (x86)\\Windows Kits\\10\\Windows Performance Toolkit\\;C:\\Program Files\\nodejs\\;C:\\rubyinstaller-2.5.7-1-x64\\bin;C:\\Program Files (x86)\\WiX Toolset v3.11\\bin;C:\\Program Files (x86)\\Windows Kits\\10\\App Certification Kit;C:\\Program Files (x86)\\Graphviz2.38\\bin;C:\\Program Files (x86)\\NSIS\\Bin;C:\\Program Files\\Jdk11\\bin;C:\\Python310;C:\\msys64\\usr\\bin;C:\\Program Files\\dotnet\\;C:\\Program Files\\Go\\bin;C:\\Program Files\\Fibratus\\Bin;C:\\Program Files\\AutoFirma\\AutoFirma;C:\\Users\\nedo\\AppData\\Local\\Programs\\Python\\Launcher\\;C:\\Scripts\\;C:\\;C:\\Users\\nedo\\AppData\\Local\\Programs\\Microsoft VS Code\\bin;C:\\Users\\nedo\\AppData\\Local\\Microsoft\\WindowsApps;C:\\Users\\nedo\\AppData\\Roaming\\npm;C:\\Users\\nedo\\AppData\\Local\\Programs\\oh-my-posh\\bin;C:\\Users\\nedo\\go\\bin"},
					Threads: map[uint32]pstypes.Thread{
						3453: {Tid: 3453, StartAddress: va.Address(140729524944768), IOPrio: 2, PagePrio: 5, KstackBase: va.Address(18446677035730165760), KstackLimit: va.Address(18446677035730137088), UstackLimit: va.Address(86376448), UstackBase: va.Address(86372352)},
						3455: {Tid: 3455, StartAddress: va.Address(140729524944768), IOPrio: 3, PagePrio: 5, KstackBase: va.Address(18446677035730165760), KstackLimit: va.Address(18446677035730137088), UstackLimit: va.Address(86376448), UstackBase: va.Address(86372352)},
					},
					Modules: []pstypes.Module{
						{Name: "C:\\Windows\\System32\\kernel32.dll", Size: 1233405456},
						{Name: "C:\\Windows\\System32\\ntdll.dll", Size: 133405456},
						{Name: "C:\\Windows\\System32\\shell32.dll", Size: 33405456},
					},
					Handles: []htypes.Handle{
						{Num: windows.Handle(0xffffd105e9baaf70),
							Name:   `\REGISTRY\MACHINE\SYSTEM\ControlSet001\Services\Tcpip\Parameters\Interfaces\{b677c565-6ca5-45d3-b618-736b4e09b036}`,
							Type:   "Key",
							Object: 777488883434455544,
							Pid:    uint32(1023),
						},
						{
							Num:  windows.Handle(0xffffd105e9adaf70),
							Name: `\RPC Control\OLEA61B27E13E028C4EA6C286932E80`,
							Type: "ALPC Port",
							Pid:  uint32(1023),
							MD: &htypes.AlpcPortInfo{
								Seqno:   1,
								Context: 0x0,
								Flags:   0x0,
							},
							Object: 457488883434455544,
						},
						{
							Num:  windows.Handle(0xeaffd105e9adaf30),
							Name: `C:\Users\bunny`,
							Type: "File",
							Pid:  uint32(1023),
							MD: &htypes.FileInfo{
								IsDirectory: true,
							},
							Object: 357488883434455544,
						},
					},
					PE: &pex.PE{
						NumberOfSections: 2,
						NumberOfSymbols:  10,
						EntryPoint:       "0x20110",
						ImageBase:        "0x140000000",
						LinkTime:         time.Now(),
						Sections: []pex.Sec{
							{Name: ".text", Size: 132608, Entropy: 6.368381, Md5: "db23dce3911a42e987041d98abd4f7cd"},
							{Name: ".rdata", Size: 35840, Entropy: 5.996976, Md5: "ffa5c960b421ca9887e54966588e97e8"},
						},
						Symbols:          []string{"SelectObject", "GetTextFaceW", "EnumFontsW", "TextOutW", "GetProcessHeap"},
						Imports:          []string{"GDI32.dll", "USER32.dll", "msvcrt.dll", "api-ms-win-core-libraryloader-l1-2-0.dl"},
						VersionResources: map[string]string{"CompanyName": "Microsoft Corporation", "FileDescription": "Notepad", "FileVersion": "10.0.18362.693"},
					},
				},
			},
			{
				Type:        event.CreateProcess,
				Tid:         2184,
				PID:         1022,
				CPU:         2,
				Seq:         3,
				Name:        "CreateProcess",
				Timestamp:   time.Now(),
				Category:    event.File,
				Host:        "archrabbit",
				Description: "Creates a new process",
				Params: event.Params{
					params.Cmdline: {Name: params.Cmdline, Type: params.UnicodeString, Value: "C:\\Windows\\system32\\svchost.exe -k RPCSS"},
					params.Exe:     {Name: params.Exe, Type: params.UnicodeString, Value: "C:\\Windows\\system32\\svchost.exe"},
					params.UserSID: {Name: params.UserSID, Type: params.UnicodeString, Value: "admin\\SYSTEM"},
				},
				Metadata: map[event.MetadataKey]any{"foo": "bar", "fooz": "barzz"},
				PS: &pstypes.PS{
					PID:  2436,
					Ppid: 6304,
					Parent: &pstypes.PS{
						PID:  2034,
						Name: "explorer.exe",
						Exe:  `C:\Windows\System32\explorer.exe`,
						Cwd:  `C:\Windows\System32`,
						SID:  "admin\\SYSTEM",
						Parent: &pstypes.PS{
							PID:  2345,
							Name: "winlogon.exe",
						},
					},
					Name:      "firefox.exe",
					Exe:       `C:\Program Files\Mozilla Firefox\firefox.exe`,
					Cmdline:   `C:\Program Files\Mozilla Firefox\firefox.exe -contentproc --channel="6304.3.1055809391\1014207667" -childID 1 -isForBrowser -prefsHandle 2584 -prefMapHandle 2580 -prefsLen 70 -prefMapSize 216993 -parentBuildID 20200107212822 -greomni "C:\Program Files\Mozilla Firefox\omni.ja" -appomni "C:\Program Files\Mozilla Firefox\browser\omni.ja" -appdir "C:\Program Files\Mozilla Firefox\browser" - 6304 "\\.\pipe\gecko-crash-server-pipe.6304" 2596 tab`,
					Cwd:       `C:\Program Files\Mozilla Firefox\`,
					SID:       "archrabbit\\SYSTEM",
					Args:      []string{"-contentproc", `--channel=6304.3.1055809391\1014207667`, "-childID", "1", "-isForBrowser", "-prefsHandle", "2584", "-prefMapHandle", "2580", "-prefsLen", "70", "-prefMapSize", "216993", "-parentBuildID"},
					SessionID: 4,
					Envs:      map[string]string{"ProgramData": "C:\\ProgramData", "COMPUTRENAME": "archrabbit"},
					Threads: map[uint32]pstypes.Thread{
						3453: {Tid: 3453, StartAddress: va.Address(140729524944768), IOPrio: 2, PagePrio: 5, KstackBase: va.Address(18446677035730165760), KstackLimit: va.Address(18446677035730137088), UstackLimit: va.Address(86376448), UstackBase: va.Address(86372352)},
						3455: {Tid: 3455, StartAddress: va.Address(140729524944768), IOPrio: 3, PagePrio: 5, KstackBase: va.Address(18446677035730165760), KstackLimit: va.Address(18446677035730137088), UstackLimit: va.Address(86376448), UstackBase: va.Address(86372352)},
					},
					Modules: []pstypes.Module{
						{Name: "C:\\Windows\\System32\\kernel32.dll", Size: 1233405456},
						{Name: "C:\\Windows\\System32\\ntdll.dll", Size: 133405456},
						{Name: "C:\\Windows\\System32\\shell32.dll", Size: 33405456},
					},
					Handles: []htypes.Handle{
						{Num: windows.Handle(0xffffd105e9baaf70),
							Name:   `\REGISTRY\MACHINE\SYSTEM\ControlSet001\Services\Tcpip\Parameters\Interfaces\{b677c565-6ca5-45d3-b618-736b4e09b036}`,
							Type:   "Key",
							Object: 777488883434455544,
							Pid:    uint32(1023),
						},
						{
							Num:  windows.Handle(0xffffd105e9adaf70),
							Name: `\RPC Control\OLEA61B27E13E028C4EA6C286932E80`,
							Type: "ALPC Port",
							Pid:  uint32(1023),
							MD: &htypes.AlpcPortInfo{
								Seqno:   1,
								Context: 0x0,
								Flags:   0x0,
							},
							Object: 457488883434455544,
						},
						{
							Num:  windows.Handle(0xeaffd105e9adaf30),
							Name: `C:\Users\bunny`,
							Type: "File",
							Pid:  uint32(1023),
							MD: &htypes.FileInfo{
								IsDirectory: true,
							},
							Object: 357488883434455544,
						},
					},
					PE: &pex.PE{
						NumberOfSections: 2,
						NumberOfSymbols:  10,
						EntryPoint:       "0x20110",
						ImageBase:        "0x140000000",
						LinkTime:         time.Now(),
						Sections: []pex.Sec{
							{Name: ".text", Size: 132608, Entropy: 6.368381, Md5: "db23dce3911a42e987041d98abd4f7cd"},
							{Name: ".rdata", Size: 35840, Entropy: 5.996976, Md5: "ffa5c960b421ca9887e54966588e97e8"},
						},
						Symbols:          []string{"SelectObject", "GetTextFaceW", "EnumFontsW", "TextOutW", "GetProcessHeap"},
						Imports:          []string{"GDI32.dll", "USER32.dll", "msvcrt.dll", "api-ms-win-core-libraryloader-l1-2-0.dl"},
						VersionResources: map[string]string{"CompanyName": "Microsoft Corporation", "FileDescription": "Notepad", "FileVersion": "10.0.18362.693"},
					},
				},
			},
		},
		ID:    "e3ce664-c620d-4d11-9d57-62a4d341f117",
		Title: "LSASS memory dumping via legitimate or offensive tools",
		Text: `Detected an attempt by mimikatz.exe process to access and read
	the memory of the Local Security And Authority Subsystem Service
	and subsequently write the C:\\temp\lsass.dmp dump file to the disk device`}))
}

```

`pkg/alertsender/mail/config.go`:

```go
/*
 * Copyright 2019-2020 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package mail

import "github.com/spf13/pflag"

const (
	host        = "alertsenders.mail.host"
	port        = "alertsenders.mail.port"
	user        = "alertsenders.mail.user"
	pass        = "alertsenders.mail.password"
	from        = "alertsenders.mail.from"
	to          = "alertsenders.mail.to"
	enabled     = "alertsenders.mail.enabled"
	contentType = "alertsenders.mail.content-type"
	useTemplate = "alertsenders.mail.use-template"
)

// Config contains the configuration for the mail alert sender.
type Config struct {
	// Host is the host of the SMTP server.
	Host string `mapstructure:"host"`
	// Port is the port of the SMTP server.
	Port int `mapstructure:"port"`
	// User specifies the username when authenticating to the SMTP server.
	User string `mapstructure:"user"`
	// Pass specifies the password when authenticating to the SMTP server.
	Pass string `mapstructure:"password"`
	// From specifies the sender address.
	From string `mapstructure:"from"`
	// To specifies recipients that receive the alert.
	To []string `mapstructure:"to"`
	// Enabled indicates whether mail alert sender is enabled.
	Enabled bool `mapstructure:"enabled"`
	// ContentType represents the email body content type.
	ContentType string `mapstructure:"content-type"`
	// UseTemplate indicates if the alert is rendered with HTML template.
	// If set to false, the plain text email is sent instead.
	UseTemplate bool `mapstructure:"use-template"`
}

// AddFlags registers persistent flags.
func AddFlags(flags *pflag.FlagSet) {
	flags.String(host, "", "Represents the host of the SMTP server")
	flags.Int(port, 25, "Represents the port of the SMTP server")
	flags.String(user, "", "Specifies the user name when authenticating to the SMTP server")
	flags.String(pass, "", "Specifies the password when authenticating to the SMTP server")
	flags.String(from, "", "Specifies the sender's address")
	flags.StringSlice(to, []string{}, "Specifies all the recipients that'll receive the alert")
	flags.Bool(enabled, false, "Indicates whether mail alert sender is enabled")
	flags.String(contentType, "text/html", "Represents the email body content type")
	flags.Bool(useTemplate, true, "Indicates if the alert is rendered with HTML template")
}

```

`pkg/alertsender/mail/mail.go`:

```go
/*
 * Copyright 2019-2020 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package mail

import (
	"github.com/rabbitstack/fibratus/pkg/alertsender"
	"gopkg.in/gomail.v2"
)

type mail struct {
	dialer *gomail.Dialer
	c      Config
}

func init() {
	alertsender.Register(alertsender.Mail, makeSender)
}

// makeSender constructs a new instance of the email alert sender.
func makeSender(config alertsender.Config) (alertsender.Sender, error) {
	c, ok := config.Sender.(Config)
	if !ok {
		return nil, alertsender.ErrInvalidConfig(alertsender.Mail)
	}
	dialer := gomail.NewDialer(c.Host, c.Port, c.User, c.Pass)
	return &mail{dialer: dialer, c: c}, nil
}

func (s mail) Send(alert alertsender.Alert) error {
	sender, err := s.dialer.Dial()
	if err != nil {
		return err
	}
	defer sender.Close()
	msg, err := s.composeMessage(s.c.From, s.c.To, alert)
	if err != nil {
		return err
	}
	return gomail.Send(sender, msg)
}

func (s mail) Type() alertsender.Type { return alertsender.Mail }
func (s mail) Shutdown() error        { return nil }
func (s mail) SupportsMarkdown() bool { return true }

func (s mail) composeMessage(from string, to []string, alert alertsender.Alert) (*gomail.Message, error) {
	msg := gomail.NewMessage()
	msg.SetHeader("From", from)
	msg.SetHeader("To", to...)
	msg.SetHeader("Subject", alert.Title)

	body := alert.Text

	var err error
	if s.c.UseTemplate {
		body, err = renderHTMLTemplate(alert)
	}
	if err != nil {
		return nil, err
	}

	msg.SetBody(s.c.ContentType, body)

	return msg, nil
}

```

`pkg/alertsender/mail/renderer.go`:

```go
/*
 * Copyright 2021-2022 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package mail

import (
	"bytes"
	"github.com/Masterminds/sprig/v3"
	"github.com/rabbitstack/fibratus/pkg/alertsender"
	"github.com/rabbitstack/fibratus/pkg/util/hostname"
	"github.com/rabbitstack/fibratus/pkg/util/version"
	"text/template"
	"time"
)

// renderHTMLTemplate produces HTML template for the alert.
// This function generates inlined CSS to maximize the compatibility
// across email clients.
func renderHTMLTemplate(alert alertsender.Alert) (string, error) {
	data := struct {
		Alert       alertsender.Alert
		TriggeredAt time.Time
		Hostname    string
		Version     string
	}{
		alert,
		time.Now(),
		hostname.Get(),
		version.Get(),
	}

	_ = data.Alert.MDToHTML()
	funcmap := sprig.TxtFuncMap()

	// redefine hasKey to work on string map values
	funcmap["hasKey"] = func(m map[string]string, key string) bool {
		if _, ok := m[key]; ok {
			return true
		}
		return false
	}
	tmpl, err := template.New("alert").Funcs(funcmap).Parse(htmlTemplate)
	if err != nil {
		return "", err
	}

	var bb bytes.Buffer
	if err := tmpl.Execute(&bb, data); err != nil {
		return "", err
	}
	return bb.String(), nil
}

```

`pkg/alertsender/mail/renderer_test.go`:

```go
/*
 * Copyright 2021-2022 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package mail

import (
	"github.com/antchfx/htmlquery"
	"github.com/rabbitstack/fibratus/pkg/alertsender"
	"github.com/rabbitstack/fibratus/pkg/event"
	"github.com/rabbitstack/fibratus/pkg/event/params"
	htypes "github.com/rabbitstack/fibratus/pkg/handle/types"
	pex "github.com/rabbitstack/fibratus/pkg/pe"
	pstypes "github.com/rabbitstack/fibratus/pkg/ps/types"
	"github.com/rabbitstack/fibratus/pkg/util/va"
	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/require"
	"golang.org/x/sys/windows"
	"strings"
	"testing"
	"time"
)

func TestRenderHTMLTemplate(t *testing.T) {
	out, err := renderHTMLTemplate(alertsender.Alert{
		Title:       "Suspicious access to Windows Vault files",
		Text:        "`cmd.exe` attempted to access Windows Vault files which was considered as a suspicious activity",
		Severity:    alertsender.Critical,
		Description: "Identifies attempts from adversaries to acquire credentials from Vault files",
		Labels: map[string]string{
			"tactic.name":       "Credential Access",
			"tactic.ref":        "https://attack.mitre.org/tactics/TA0006/",
			"technique.name":    "Credentials from Password Stores",
			"technique.ref":     "https://attack.mitre.org/techniques/T1555/",
			"subtechnique.name": "Windows Credential Manager",
			"subtechnique.ref":  "https://attack.mitre.org/techniques/T1555/004/",
		},
		Events: []*event.Event{
			{
				Type:        event.CreateFile,
				Tid:         2484,
				PID:         859,
				CPU:         1,
				Seq:         2,
				Name:        "CreateFile",
				Timestamp:   time.Now(),
				Category:    event.File,
				Host:        "archrabbit",
				Description: "Creates or opens a new file, directory, I/O device, pipe, console",
				Params: event.Params{
					params.FileObject:    {Name: params.FileObject, Type: params.Uint64, Value: uint64(12456738026482168384)},
					params.FilePath:      {Name: params.FilePath, Type: params.UnicodeString, Value: "C:\\Windows\\system32\\user32.dll"},
					params.FileType:      {Name: params.FileType, Type: params.AnsiString, Value: "file"},
					params.FileOperation: {Name: params.FileOperation, Type: params.Enum, Value: uint32(1)},
				},
				Metadata: map[event.MetadataKey]any{"foo": "bar", "fooz": "barzz"},
				PS: &pstypes.PS{
					PID:  2436,
					Ppid: 6304,
					Parent: &pstypes.PS{
						PID:  2034,
						Name: "explorer.exe",
						Exe:  `C:\Windows\System32\explorer.exe`,
						Cwd:  `C:\Windows\System32`,
						SID:  "admin\\SYSTEM",
						Parent: &pstypes.PS{
							PID:  2345,
							Name: "winlogon.exe",
						},
					},
					Name:      "firefox.exe",
					Exe:       `C:\Program Files\Mozilla Firefox\firefox.exe`,
					Cmdline:   `C:\Program Files\Mozilla Firefox\firefox.exe -contentproc --channel="6304.3.1055809391\1014207667" -childID 1 -isForBrowser -prefsHandle 2584 -prefMapHandle 2580 -prefsLen 70 -prefMapSize 216993 -parentBuildID 20200107212822 -greomni "C:\Program Files\Mozilla Firefox\omni.ja" -appomni "C:\Program Files\Mozilla Firefox\browser\omni.ja" -appdir "C:\Program Files\Mozilla Firefox\browser" - 6304 "\\.\pipe\gecko-crash-server-pipe.6304" 2596 tab`,
					Cwd:       `C:\Program Files\Mozilla Firefox\`,
					SID:       "archrabbit\\SYSTEM",
					Args:      []string{"-contentproc", `--channel=6304.3.1055809391\1014207667`, "-childID", "1", "-isForBrowser", "-prefsHandle", "2584", "-prefMapHandle", "2580", "-prefsLen", "70", "-prefMapSize", "216993", "-parentBuildID"},
					SessionID: 4,
					Envs:      map[string]string{"ProgramData": "C:\\ProgramData", "COMPUTRENAME": "archrabbit", "Path": "C:\\Program Files (x86)\\Common Files\\Oracle\\Java\\javapath;C:\\WINDOWS\\system32;C:\\WINDOWS;C:\\WINDOWS\\System32\\Wbem;C:\\WINDOWS\\System32\\WindowsPowerShell\\v1.0\\;C:\\Program Files\\Git\\cmd;C:\\msys64\\mingw64\\bin;C:\\WINDOWS\\System32\\OpenSSH\\;C:\\Program Files (x86)\\Windows Kits\\10\\Windows Performance Toolkit\\;C:\\Program Files\\nodejs\\;C:\\rubyinstaller-2.5.7-1-x64\\bin;C:\\Program Files (x86)\\WiX Toolset v3.11\\bin;C:\\Program Files (x86)\\Windows Kits\\10\\App Certification Kit;C:\\Program Files (x86)\\Graphviz2.38\\bin;C:\\Program Files (x86)\\NSIS\\Bin;C:\\Program Files\\Jdk11\\bin;C:\\Python310;C:\\msys64\\usr\\bin;C:\\Program Files\\dotnet\\;C:\\Program Files\\Go\\bin;C:\\Program Files\\Fibratus\\Bin;C:\\Program Files\\AutoFirma\\AutoFirma;C:\\Users\\nedo\\AppData\\Local\\Programs\\Python\\Launcher\\;C:\\Scripts\\;C:\\;C:\\Users\\nedo\\AppData\\Local\\Programs\\Microsoft VS Code\\bin;C:\\Users\\nedo\\AppData\\Local\\Microsoft\\WindowsApps;C:\\Users\\nedo\\AppData\\Roaming\\npm;C:\\Users\\nedo\\AppData\\Local\\Programs\\oh-my-posh\\bin;C:\\Users\\nedo\\go\\bin"},
					Threads: map[uint32]pstypes.Thread{
						3453: {Tid: 3453, StartAddress: va.Address(140729524944768), IOPrio: 2, PagePrio: 5, KstackBase: va.Address(18446677035730165760), KstackLimit: va.Address(18446677035730137088), UstackLimit: va.Address(86376448), UstackBase: va.Address(86372352)},
						3455: {Tid: 3455, StartAddress: va.Address(140729524944768), IOPrio: 3, PagePrio: 5, KstackBase: va.Address(18446677035730165760), KstackLimit: va.Address(18446677035730137088), UstackLimit: va.Address(86376448), UstackBase: va.Address(86372352)},
					},
					Modules: []pstypes.Module{
						{Name: "C:\\Windows\\System32\\kernel32.dll", Size: 1233405456},
						{Name: "C:\\Windows\\System32\\ntdll.dll", Size: 133405456},
						{Name: "C:\\Windows\\System32\\shell32.dll", Size: 33405456},
					},
					Handles: []htypes.Handle{
						{Num: windows.Handle(0xffffd105e9baaf70),
							Name:   `\REGISTRY\MACHINE\SYSTEM\ControlSet001\Services\Tcpip\Parameters\Interfaces\{b677c565-6ca5-45d3-b618-736b4e09b036}`,
							Type:   "Key",
							Object: 777488883434455544,
							Pid:    uint32(1023),
						},
						{
							Num:  windows.Handle(0xffffd105e9adaf70),
							Name: `\RPC Control\OLEA61B27E13E028C4EA6C286932E80`,
							Type: "ALPC Port",
							Pid:  uint32(1023),
							MD: &htypes.AlpcPortInfo{
								Seqno:   1,
								Context: 0x0,
								Flags:   0x0,
							},
							Object: 457488883434455544,
						},
						{
							Num:  windows.Handle(0xeaffd105e9adaf30),
							Name: `C:\Users\bunny`,
							Type: "File",
							Pid:  uint32(1023),
							MD: &htypes.FileInfo{
								IsDirectory: true,
							},
							Object: 357488883434455544,
						},
					},
					PE: &pex.PE{
						NumberOfSections: 2,
						NumberOfSymbols:  10,
						EntryPoint:       "0x20110",
						ImageBase:        "0x140000000",
						LinkTime:         time.Now(),
						Sections: []pex.Sec{
							{Name: ".text", Size: 132608, Entropy: 6.368381, Md5: "db23dce3911a42e987041d98abd4f7cd"},
							{Name: ".rdata", Size: 35840, Entropy: 5.996976, Md5: "ffa5c960b421ca9887e54966588e97e8"},
						},
						Symbols:          []string{"SelectObject", "GetTextFaceW", "EnumFontsW", "TextOutW", "GetProcessHeap"},
						Imports:          []string{"GDI32.dll", "USER32.dll", "msvcrt.dll", "api-ms-win-core-libraryloader-l1-2-0.dl"},
						VersionResources: map[string]string{"CompanyName": "Microsoft Corporation", "FileDescription": "Notepad", "FileVersion": "10.0.18362.693"},
					},
				},
			},
			{
				Type:        event.CreateProcess,
				Tid:         2184,
				PID:         1022,
				CPU:         2,
				Seq:         3,
				Name:        "CreateProcess",
				Timestamp:   time.Now(),
				Category:    event.File,
				Host:        "archrabbit",
				Description: "Creates a new process",
				Params: event.Params{
					params.Cmdline: {Name: params.Cmdline, Type: params.UnicodeString, Value: "C:\\Windows\\system32\\svchost.exe -k RPCSS"},
					params.Exe:     {Name: params.Exe, Type: params.UnicodeString, Value: "C:\\Windows\\system32\\svchost.exe"},
					params.UserSID: {Name: params.UserSID, Type: params.UnicodeString, Value: "admin\\SYSTEM"},
				},
				Metadata: map[event.MetadataKey]any{"foo": "bar", "fooz": "barzz"},
				PS: &pstypes.PS{
					PID:  2436,
					Ppid: 6304,
					Parent: &pstypes.PS{
						PID:  2034,
						Name: "explorer.exe",
						Exe:  `C:\Windows\System32\explorer.exe`,
						Cwd:  `C:\Windows\System32`,
						SID:  "admin\\SYSTEM",
						Parent: &pstypes.PS{
							PID:  2345,
							Name: "winlogon.exe",
						},
					},
					Name:      "firefox.exe",
					Exe:       `C:\Program Files\Mozilla Firefox\firefox.exe`,
					Cmdline:   `C:\Program Files\Mozilla Firefox\firefox.exe -contentproc --channel="6304.3.1055809391\1014207667" -childID 1 -isForBrowser -prefsHandle 2584 -prefMapHandle 2580 -prefsLen 70 -prefMapSize 216993 -parentBuildID 20200107212822 -greomni "C:\Program Files\Mozilla Firefox\omni.ja" -appomni "C:\Program Files\Mozilla Firefox\browser\omni.ja" -appdir "C:\Program Files\Mozilla Firefox\browser" - 6304 "\\.\pipe\gecko-crash-server-pipe.6304" 2596 tab`,
					Cwd:       `C:\Program Files\Mozilla Firefox\`,
					SID:       "archrabbit\\SYSTEM",
					Args:      []string{"-contentproc", `--channel=6304.3.1055809391\1014207667`, "-childID", "1", "-isForBrowser", "-prefsHandle", "2584", "-prefMapHandle", "2580", "-prefsLen", "70", "-prefMapSize", "216993", "-parentBuildID"},
					SessionID: 4,
					Envs:      map[string]string{"ProgramData": "C:\\ProgramData", "COMPUTRENAME": "archrabbit"},
					Threads: map[uint32]pstypes.Thread{
						3453: {Tid: 3453, StartAddress: va.Address(140729524944768), IOPrio: 2, PagePrio: 5, KstackBase: va.Address(18446677035730165760), KstackLimit: va.Address(18446677035730137088), UstackLimit: va.Address(86376448), UstackBase: va.Address(86372352)},
						3455: {Tid: 3455, StartAddress: va.Address(140729524944768), IOPrio: 3, PagePrio: 5, KstackBase: va.Address(18446677035730165760), KstackLimit: va.Address(18446677035730137088), UstackLimit: va.Address(86376448), UstackBase: va.Address(86372352)},
					},
					Modules: []pstypes.Module{
						{Name: "C:\\Windows\\System32\\kernel32.dll", Size: 1233405456},
						{Name: "C:\\Windows\\System32\\ntdll.dll", Size: 133405456},
						{Name: "C:\\Windows\\System32\\shell32.dll", Size: 33405456},
					},
					Handles: []htypes.Handle{
						{Num: windows.Handle(0xffffd105e9baaf70),
							Name:   `\REGISTRY\MACHINE\SYSTEM\ControlSet001\Services\Tcpip\Parameters\Interfaces\{b677c565-6ca5-45d3-b618-736b4e09b036}`,
							Type:   "Key",
							Object: 777488883434455544,
							Pid:    uint32(1023),
						},
						{
							Num:  windows.Handle(0xffffd105e9adaf70),
							Name: `\RPC Control\OLEA61B27E13E028C4EA6C286932E80`,
							Type: "ALPC Port",
							Pid:  uint32(1023),
							MD: &htypes.AlpcPortInfo{
								Seqno:   1,
								Context: 0x0,
								Flags:   0x0,
							},
							Object: 457488883434455544,
						},
						{
							Num:  windows.Handle(0xeaffd105e9adaf30),
							Name: `C:\Users\bunny`,
							Type: "File",
							Pid:  uint32(1023),
							MD: &htypes.FileInfo{
								IsDirectory: true,
							},
							Object: 357488883434455544,
						},
					},
					PE: &pex.PE{
						NumberOfSections: 2,
						NumberOfSymbols:  10,
						EntryPoint:       "0x20110",
						ImageBase:        "0x140000000",
						LinkTime:         time.Now(),
						Sections: []pex.Sec{
							{Name: ".text", Size: 132608, Entropy: 6.368381, Md5: "db23dce3911a42e987041d98abd4f7cd"},
							{Name: ".rdata", Size: 35840, Entropy: 5.996976, Md5: "ffa5c960b421ca9887e54966588e97e8"},
						},
						Symbols:          []string{"SelectObject", "GetTextFaceW", "EnumFontsW", "TextOutW", "GetProcessHeap"},
						Imports:          []string{"GDI32.dll", "USER32.dll", "msvcrt.dll", "api-ms-win-core-libraryloader-l1-2-0.dl"},
						VersionResources: map[string]string{"CompanyName": "Microsoft Corporation", "FileDescription": "Notepad", "FileVersion": "10.0.18362.693"},
					},
				},
			},
		},
	})

	require.NoError(t, err)
	doc, err := htmlquery.Parse(strings.NewReader(out))
	require.NoError(t, err)

	alertTitle := htmlquery.FindOne(doc, "//h1")

	require.NotNil(t, alertTitle)
	assert.Equal(t, "Suspicious access to Windows Vault files", htmlquery.InnerText(alertTitle))
}

```

`pkg/alertsender/mail/template.go`:

```go
/*
 * Copyright 2021-2022 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package mail

var htmlTemplate = `
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
  <style>
     @media only screen and (max-width: 600px) {
      .alert-body-inner,
      .alert-footer {
        width: 100% !important;
      }
    }
  </style>
  <!--[if (gte mso 9)|(IE)]>
    <style type="text/css">
        table {border-collapse: collapse;}
    </style>
  <![endif]-->
  <title></title>
</head>
<body style="font-family: 'Noto Sans', Tahoma, Roboto, 'Open Sans', Arial, 'Helvetica Neue', Helvetica, sans-serif; -webkit-box-sizing: border-box; box-sizing: border-box; width: 100% !important; height: 100%; margin: 0; line-height: 1.4; background-color: #f7f7f7; color: #74787E; -webkit-text-size-adjust: none; border-radius: 4px">
<table style="width: 100%; margin: 0; padding: 0; background-color: #F2F4F6; border-collapse: collapse;" width="100%" cellpadding="0" cellspacing="0">
  <tr>
    <td>
      <table style="width: 100%; margin: 0px; padding: 0; border-collapse: collapse;" width="100%" cellpadding="0" cellspacing="0">
        <tr>
          <td style="width: 100%; margin: 0; padding: 0; align: center" width="100%">
            <table class="alert-body-inner" style="width: 570px; margin: 0 auto; padding: 0; border-collapse: collapse;" align="center" width="570" cellpadding="0" cellspacing="0">
              <tr>
                <td style="padding: 35px; color: #74787E; font-size: 15px; line-height: 18px;">
                  <p style="font-size: 12px; color: #C5C5C5; line-height: 0.5em;">
                    Triggered on <span style="color: #6f7578;">{{ .TriggeredAt | date "Mon Jan 02 2006" }} at {{ .TriggeredAt | date "03:04:05 PM" }}</span> in <span
                    style="color: #6f7578;"> {{ .Hostname }} </span> host
                  </p>
                  <h1 style="font-size: 16px; font-weight: bold; color: #2F3133; text-decoration: none; text-shadow: 0 1px 0 white;">{{ .Alert.Title }}</h1>
                  {{- if .Alert.Text }}
                  <div style="margin-bottom: 5px;">
                  {{- else }}
                  <div style="margin-bottom: 10px;">
                  {{- end }}
                      {{ $severityColor := "#fcd834" }}
                      {{- if eq .Alert.Severity.String "low" }}
                      {{ $severityColor := "#29b33e" }}
                      {{- else if eq .Alert.Severity.String "medium" }}
                      {{ $severityColor := "#fcd834" }}
                      {{- else }}
                      {{ $severityColor = "#fa7975" }}
                      {{- end }}
                      <span style="height: 8px; width: 8px; border-radius: 50%; display: inline-block; background-color: {{ $severityColor }}"></span>
                      <p style="font-size: 12px; white-space: pre-wrap; color: #6f7578; line-height: 0.5em; display: inline; margin-left: 2px">{{ .Alert.Severity.String | title }} Severity</p>
                  </div>
                  {{- if .Alert.Text }}
                  {{ $text := (regexReplaceAll "<code>" .Alert.Text "<code style='border-radius: 5px; color: #404243; font-size: .8rem; margin: 0 2px; padding: 3px 5px; line-height: 1.7rem; white-space: pre-wrap; font-weight: 600; font-family: Consolas, Roboto, monaco, monospace; background-color: #e1e3e4;'>") }}
                  <p style="font-size: .8rem; margin: 0 0 4px 0px; padding: 3px 0px; white-space: pre-wrap; line-height: 1.5em;">{{ regexReplaceAll "\\s+" $text " " }}</p>
                  {{- end }}
                  {{ if hasKey .Alert.Labels "tactic.name" }}
                  <div class="tag" style="display: inline-block; border-radius: 5px; color: #404243; font-size: .8rem; margin: 2px 2px; padding: 3px 5px; white-space: pre-wrap; font-weight: 600; background-color: #bad1fb;"><a style="text-decoration: none; color: inherit;" href="{{ index .Alert.Labels "tactic.ref"}}">{{ index .Alert.Labels "tactic.name"}}</a></div>
                  {{ end }}
                  {{ if hasKey .Alert.Labels "technique.name" }}
                  <div class="tag" style="display: inline-block; border-radius: 5px; color: #404243; font-size: .8rem; margin: 2px 2px; padding: 3px 5px; white-space: pre-wrap; font-weight: 600; background-color: #84cad7;"><a style="text-decoration: none; color: inherit;" href="{{ index .Alert.Labels "technique.ref"}}">{{ index .Alert.Labels "technique.name"}}</a></div>
                  {{ end }}
                  {{ if hasKey .Alert.Labels "subtechnique.name" }}
                  <div class="tag" style="display: inline-block; border-radius: 5px; color: #404243; font-size: .8rem; margin: 2px 2px; padding: 3px 5px; white-space: pre-wrap; font-weight: 600; background-color: #fcbcba;"><a style="text-decoration: none; color: inherit;" href="{{ index .Alert.Labels "subtechnique.ref"}}">{{ index .Alert.Labels "subtechnique.name"}}</a></div>
                  {{ end }}
                </td>
              </tr>
             {{- if .Alert.Description }}
              <tr>
                <td style="padding: 5px 0px 0px 15px;">
                  <p style="background: #efefef; display: inline-block; border-radius: 5px; font-size: .8rem; margin: 4px 4px 25px 0px; padding: 3px 5px; white-space: pre-wrap; line-height: 1.5em;">
                     {{- .Alert.Description | trimSuffix "." }}
                  </p>
                </td>
              </tr>
			 {{ end }}
            </table>
          </td>
        </tr>

        <tr>
          <td style="width: 100%; margin: 0; padding: 0; background-color: #F2F4F6;" width="100%">
            <table class="alert-body-inner" style="width: 570px; margin: 0 auto; padding: 0; border-collapse: collapse;" align="center" width="570" cellpadding="0" cellspacing="0">
              <tr>
                <td style="padding: 35px;">
                  <h1 style="font-weight: bold; margin-bottom: 22px; margin-top: 0px; font-size: 16px;">
                    Security events involved in this incident
                  </h1>
                  {{- range $i, $evt := .Alert.Events }}
                  {{ with $evt }}
                  <table style="width: 100%; margin: 0; padding: 35px 0; border-collapse: collapse;" width="100%" cellpadding="0" cellspacing="0">
                    <tr>
                      <td>
                        <table style="width: 100%; margin: 0; padding: 35px 0;" width="100%" cellpadding="0" cellspacing="0">
                          <tr>
                            <td style="padding: 5px 0px 0px 35px;">
                              <div>
                                <h1 style="color: #A8A9A9; font-size: 22px; margin-top: 0; font-weight: bold;"><span style=font-style: italic;color: #C5C5C5; font-size: 28px;">#</span> {{ $i | add1 }}</h1>
                              </div>
                            </td>
                            <td>
                              <p style="color: #6f7c96; font-weight: bold; margin-top: 0px;">{{ .Name }}</p>
                              <p style="margin-top: -10px; font-size: 12px; color: #C5C5C5; line-height: 0.5em;"><span style="color: #A8A9A9;">{{ .Timestamp | date "03:04:05 PM" }}</span></p>
                            </td>
                          </tr>
                          <tr>
                            <td style="padding: 10px 5px; color: #74787E; font-size: 15px; line-height: 18px;" colspan="2">
                              {{ regexReplaceAll "<code>" .Summary "<code style='border-radius: 5px; color: #404243; font-size: .8rem; margin: 0 2px; padding: 3px 5px; line-height: 1.7rem; white-space: pre-wrap; font-weight: 600; font-family: Consolas, Roboto, monaco, monospace; background-color: #e1e3e4;'>" }}
                            </td>
                          </tr>
                          <tr>
                            <td colspan="2">
                              <table style="width: 100%; margin: 16px 0 16px 0;" width="100%" cellpadding="0" cellspacing="0">
                                {{- range $key, $par := .Params }}
                                <tr>
                                  <td style="padding: 5px 5px;">
                                    <span style="font-size: 13px; color: #626567;">{{ regexReplaceAll "_" $key " " | title }}</span>
                                  </td>
                                  <td style="padding: 5px 5px;">
                                    {{ $paramValue := $par.String }}
                                    <p style="margin: 4px 4px 4px 0px; font-size: 13px; color: #74787E; font-weight: bold; line-height: 1.1em; background: #fed5a0; display: inline-block; border-radius: 5px; padding: 3px 5px; white-space: pre-wrap;">{{ $paramValue }}</p>
                                  </td>
                                </tr>
                                {{- end }}
                              </table>
                            </td>
                          </tr>
                          {{- if .PS }}
                          <tr>
                            <td colspan="2">
                                <h2 style="margin-top: 0; color: #2F3133; font-size: 16px; font-weight: bold;">Process</h2>
                                <div style="align: center; padding: 0;">
                                  <table style="width: 100%; margin: 16px 0 16px 0;" width="100%" cellpadding="0" cellspacing="0">
                                    <tr>
                                      <td style="padding: 5px 5px;">
                                        <p style="margin-top: 0px; font-size: 13px; color: #626567; line-height: 1.1em;">Pid</p>
                                      </td>
                                      <td style="padding: 5px 5px;">
                                        <p style="margin-top: 0px; font-size: 13px; color: #74787E; line-height: 1.1em; font-weight: bold; display: inline-block; padding: 3px 5px; white-space: pre-wrap;">{{ .PS.PID }}</p>
                                      </td>
                                    </tr>
                                    <tr>
                                      <td style="padding: 5px 5px;">
                                        <p style="margin-top: 0px; font-size: 13px; color: #626567; line-height: 1.1em;">Name</p>
                                      </td>
                                      <td style="padding: 5px 5px;">
                                        <p style="margin-top: 0px; font-size: 13px; color: #74787E; line-height: 1.3em; font-weight: bold; display: inline-block; padding: 3px 5px; white-space: pre-wrap;">{{ .PS.Name }}</p>
                                      </td>
                                    </tr>
                                    <tr>
                                      <td style="padding: 5px 5px;">
                                        <p style="margin-top: 0px; font-size: 13px; color: #626567; line-height: 1.1em;">Parent</p>
                                      </td>
                                      <td style="padding: 5px 5px;">
                                      {{- if .PS.Parent -}}
                                        <p style="margin-top: 0px; font-size: 13px; color: #74787E; line-height: 1.3em; font-weight: bold; display: inline-block; padding: 3px 5px; white-space: pre-wrap;">{{ .PS.Parent.Name }} ({{.PS.Parent.PID}})</p>
                                      {{- else -}}
                                        <p style="margin-top: 0px; font-size: 13px; color: #74787E; line-height: 1.3em; font-weight: bold; display: inline-block; padding: 3px 5px; white-space: pre-wrap;">N/A {{ .PS.Ppid }}</p>
                                      {{- end -}}
                                      </td>
                                    </tr>
                                    {{- if gt (len .PS.Ancestors) 1 }}
                                    <tr>
                                      <td style="padding: 5px 5px;">
                                        <p style="margin-top: 0px; font-size: 13px; color: #626567; line-height: 1.1em;">Ancestors</p>
                                      </td>
                                      <td style="padding: 5px 5px;">
                                        <p style="margin-top: 0px; font-size: 13px; color: #74787E; line-height: 1.3em; font-weight: bold; display: inline-block; padding: 3px 5px; white-space: pre-wrap;">{{ .PS.Ancestors | join " &#65125; " }}</p>
                                      </td>
                                    </tr>
                                    {{- end }}
                                    <tr>
                                      <td style="padding: 5px 5px;">
                                        <p style="margin-top: 0px; font-size: 13px; color: #626567; line-height: 1.1em;">Exe</p>
                                      </td>
                                      <td style="padding: 5px 5px;">
                                        <p style="position: relative; margin-top: 0px; font-size: 13px; color: #74787E; line-height: 1.3em; font-weight: bold; display: inline-block; padding: 3px 5px; white-space: pre-wrap;">{{ .PS.Exe }}</p>
                                      </td>
                                    </tr>
                                    <tr>
                                      <td style="padding: 5px 5px;">
                                        <p style="margin-top: 0px; font-size: 13px; color: #626567; line-height: 1.1em;">Cmdline</p>
                                      </td>
                                      <td style="padding: 5px 5px;">
                                        <p style="margin-top: 0px; font-size: 13px; color: #74787E; line-height: 1.3em; font-weight: bold; display: inline-block; padding: 3px 5px; white-space: pre-wrap;">{{ .PS.Cmdline }}</p>
                                      </td>
                                    </tr>
                                    <tr>
                                      <td style="padding: 5px 5px;">
                                        <p style="margin-top: 0px; font-size: 13px; color: #626567; line-height: 1.1em;">Cwd</p>
                                      </td>
                                      <td style="padding: 5px 5px;">
                                        <p style="margin-top: 0px; font-size: 13px; color: #74787E; line-height: 1.3em; font-weight: bold; display: inline-block; padding: 3px 5px; white-space: pre-wrap;">{{ .PS.Cwd }}</p>
                                      </td>
                                    </tr>
                                    <tr>
                                      <td style="padding: 5px 5px;">
                                        <p style="margin-top: 0px; font-size: 13px; color: #626567; line-height: 1.1em;">User</p>
                                      </td>
                                      <td style="padding: 5px 5px;">
                                        <p style="margin-top: 0px; font-size: 13px; color: #74787E; line-height: 1.3em; font-weight: bold; display: inline-block; padding: 3px 5px; white-space: pre-wrap;">{{ .PS.SID }}</p>
                                      </td>
                                    </tr>
                                    <tr>
                                      <td style="padding: 5px 5px;">
                                        <p style="margin-top: 0px; font-size: 13px; color: #626567; line-height: 1.1em;">Session ID</p>
                                      </td>
                                      <td style="padding: 5px 5px;">
                                        <p style="margin-top: 0px; font-size: 13px; color: #74787E; line-height: 1.3em; font-weight: bold; display: inline-block; padding: 3px 5px; white-space: pre-wrap;">{{ .PS.SessionID }}</p>
                                      </td>
                                    </tr>
                                  </table>
                                </div>
                            </td>
                          </tr>
                          {{- end }}
                        </table>
                      </td>
                    </tr>
                  </table>
                  {{- end }}
                  {{- end }}
              </tr>
            </table>
          </td>
        </tr>
      </table>
    </td>
  </tr>
  <tr style="margin: 0 auto; padding: 0; text-align: center; background: #f7f7f7;">
    <td style="padding: 5px;">
      <p style="font-size: 9px; text-align: center;">
        This email was automatically generated by Fibratus {{ .Version }}
      </p>
    </td>
  </tr>
</table>
</body>
</html>
`

```

`pkg/alertsender/sender.go`:

```go
/*
 * Copyright 2019-2020 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package alertsender

import (
	"fmt"
	"github.com/rabbitstack/fibratus/pkg/util/multierror"
)

// ErrInvalidConfig signals an invalid sender config
var ErrInvalidConfig = func(name Type) error { return fmt.Errorf("invalid config for %q sender", name) }

var factories = map[Type]Factory{}
var alertsenders = map[Type]Sender{}

// Factory defines the alias for the alert sender factory
type Factory func(config Config) (Sender, error)

// Type defines the alias for the alert sender type
type Type uint8

const (
	// Mail designates mail alert sender
	Mail Type = iota
	// Slack designates Slack alert sender
	Slack
	// Noop is a noop alert sender. Useful for testing.
	Noop
	// Systray designates the systray notification alert sender
	Systray
	// Eventlog designate the eventlog alert sender
	Eventlog
	// None is the type for unknown alert sender
	None
)

// String returns the string representation of the alert sender type.
func (s Type) String() string {
	switch s {
	case Mail:
		return "mail"
	case Slack:
		return "slack"
	case Noop:
		return "noop"
	case Systray:
		return "systray"
	case Eventlog:
		return "eventlog"
	default:
		return "none"
	}
}

// Sender is the minimal interface all alert senders have to implement.
type Sender interface {
	// Send emits an alert.
	Send(Alert) error
	// Type returns the type that identifies a particular sender.
	Type() Type
	// Shutdown performs cleanup tasks possibly disposing any resources
	// allocated by the sender.
	Shutdown() error
	// SupportsMarkdown indicates if the sender supports Markdown
	// rendering in alert text string.
	SupportsMarkdown() bool
}

// ToType converts the string representation of the alert sender to its corresponding type.
func ToType(s string) Type {
	switch s {
	case "mail":
		return Mail
	case "slack":
		return Slack
	case "noop":
		return Noop
	case "systray":
		return Systray
	default:
		return None
	}
}

// Register registers a new alert sender.
func Register(typ Type, factory Factory) {
	if _, ok := factories[typ]; ok {
		panic(fmt.Sprintf("%q alert sender is already registered", typ))
	}
	factories[typ] = factory
}

// Find locates the sender.
func Find(typ Type) Sender {
	return alertsenders[typ]
}

// FindAll returns all registered senders.
func FindAll() []Sender {
	senders := make([]Sender, 0, len(alertsenders))
	for _, s := range alertsenders {
		senders = append(senders, s)
	}
	return senders
}

// ShutdownAll shutdowns all registered senders.
func ShutdownAll() error {
	errs := make([]error, 0)
	for _, s := range alertsenders {
		err := s.Shutdown()
		if err != nil {
			errs = append(errs, err)
		}
	}
	return multierror.Wrap(errs...)
}

// Load loads an alert sender from the registry.
func Load(config Config) (Sender, error) {
	typ := config.Type
	factory := factories[typ]
	if factory == nil {
		return nil, fmt.Errorf("%q alert sender not available in the factory", typ)
	}
	return factory(config)
}

// LoadAll loads all alert senders from the configuration inputs.
func LoadAll(configs []Config) error {
	for _, config := range configs {
		alertsender, err := Load(config)
		if err != nil {
			return fmt.Errorf("fail to load %q alertsender: %v", config.Type, err)
		}
		alertsenders[config.Type] = alertsender
	}
	return nil
}

```

`pkg/alertsender/slack/config.go`:

```go
/*
 * Copyright 2019-2020 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package slack

import "github.com/spf13/pflag"

const (
	enabled   = "alertsenders.slack.enabled"
	url       = "alertsenders.slack.url"
	workspace = "alertsenders.slack.workspace"
	channel   = "alertsenders.slack.channel"
	botemoji  = "alertsenders.slack.emoji"
)

// Config stores the settings that dictate the behaviour of the Slack alert sender.
type Config struct {
	// URL represents the Webhook URL of the workspace where alerts will be dispatched.
	URL string `mapstructure:"url"`
	// Workspace designates the Slack workspace where alerts will be routed.
	Workspace string `mapstructure:"workspace"`
	// Channel is the slack channel in which to post alerts.
	Channel string `mapstructure:"channel"`
	// BotEmoji is the emoji icon for the Slack bot.
	BotEmoji string `mapstructure:"emoji"`
	// Enabled determines if Slack alert sender is enabled.
	Enabled bool `mapstructure:"enabled"`
}

// AddFlags registers persistent flags.
func AddFlags(flags *pflag.FlagSet) {
	flags.Bool(enabled, false, "Determines whether Slack alert sender is enabled")
	flags.String(url, "", "Represents the Webhook URL of the workspace where alerts will be dispatched")
	flags.String(workspace, "", "Designates the Slack workspace where alerts will be routed")
	flags.String(channel, "", "Represents the slack channel in which to post alerts")
	flags.String(botemoji, "", "Represents the emoji icon for the Slack bot")
}

```

`pkg/alertsender/slack/slack.go`:

```go
/*
 * Copyright 2019-2020 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package slack

import (
	"bytes"
	"encoding/json"
	"errors"
	"fmt"
	"github.com/rabbitstack/fibratus/pkg/alertsender"
	"io"
	"net"
	"net/http"
	"time"
)

const botName = "fibratus"

type slack struct {
	client *http.Client
	config Config
}

// attachment represents Slack attachment info
type attachment struct {
	Fallback string   `json:"fallback"`
	Color    string   `json:"color"`
	Text     string   `json:"text"`
	Mdin     []string `json:"mrkdwn_in"`
}

func init() {
	alertsender.Register(alertsender.Slack, makeSender)
}

// makeSender constructs a new instance of the Slack alert sender.
func makeSender(config alertsender.Config) (alertsender.Sender, error) {
	c, ok := config.Sender.(Config)
	if !ok {
		return nil, alertsender.ErrInvalidConfig(alertsender.Slack)
	}
	client := &http.Client{
		Transport: &http.Transport{
			DialContext: (&net.Dialer{
				Timeout:   10 * time.Second,
				KeepAlive: 30 * time.Second,
			}).DialContext,
			IdleConnTimeout:     90 * time.Second,
			TLSHandshakeTimeout: 10 * time.Second,
		},
	}
	return &slack{config: c, client: client}, nil
}

func (s slack) Send(alert alertsender.Alert) error {
	var color string
	switch alert.Severity {
	case alertsender.Medium:
		color = "warning"
	case alertsender.Critical, alertsender.High:
		color = "danger"
	default:
		color = "good"
	}

	text := fmt.Sprintf("%s\n%s", alert.Title, alert.Text)

	attach := attachment{
		Fallback: text,
		Text:     text,
		Color:    color,
		Mdin:     []string{"text"},
	}

	params := make(map[string]interface{})
	params["as_user"] = false
	params["channel"] = s.config.Channel
	params["text"] = ""
	params["attachments"] = []attachment{attach}
	params["username"] = botName
	if s.config.BotEmoji != "" {
		params["icon_emoji"] = s.config.BotEmoji
	}

	var body bytes.Buffer
	enc := json.NewEncoder(&body)
	err := enc.Encode(params)
	if err != nil {
		return nil
	}
	//nolint:noctx
	resp, err := s.client.Post(s.config.URL, "application/json", &body)
	if err != nil {
		return err
	}
	defer resp.Body.Close()
	if resp.StatusCode != http.StatusOK {
		body, err := io.ReadAll(resp.Body)
		if err != nil {
			return err
		}
		type response struct {
			Error string `json:"error"`
		}
		r := &response{Error: fmt.Sprintf("failed to send alert to Slack. code: %d content: %s", resp.StatusCode, string(body))}
		b := bytes.NewReader(body)
		dec := json.NewDecoder(b)
		if err := dec.Decode(r); err != nil {
			return err
		}
		return errors.New(r.Error)
	}
	return nil
}

func (s slack) Type() alertsender.Type { return alertsender.Slack }
func (s slack) Shutdown() error        { return nil }
func (s slack) SupportsMarkdown() bool { return true }

```

`pkg/alertsender/systray/config.go`:

```go
/*
 * Copyright 2021-2022 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package systray

import "github.com/spf13/pflag"

const (
	enabled   = "alertsenders.systray.enabled"
	sound     = "alertsenders.systray.sound"
	quietMode = "alertsenders.systray.quiet-mode"
)

// Config contains the configuration for the systray alert sender.
type Config struct {
	// Enabled indicates whether systray alert sender is enabled.
	Enabled bool `mapstructure:"enabled"`
	// Sound indicates if the associated sound is played
	// when the balloon notification is shown.
	Sound bool `mapstructure:"sound"`
	// QuietMode instructs not to display the balloon notification
	// if the current user is in quiet time.
	QuietMode bool `mapstructure:"quiet"`
}

// AddFlags registers persistent flags.
func AddFlags(flags *pflag.FlagSet) {
	flags.Bool(enabled, false, "Determines whether systray alert sender is enabled")
	flags.Bool(sound, true, "Indicates if the associated sound is played when the balloon notification is shown")
	flags.Bool(quietMode, false, "Instructs not to display the balloon notification if the current user is in quiet time")
}

```

`pkg/alertsender/systray/systray.go`:

```go
/*
 * Copyright 2021-2022 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package systray

import (
	"context"
	"encoding/json"
	"fmt"
	"github.com/Microsoft/go-winio"
	"github.com/cenkalti/backoff/v4"
	"github.com/rabbitstack/fibratus/pkg/alertsender"
	"github.com/rabbitstack/fibratus/pkg/event"
	"github.com/rabbitstack/fibratus/pkg/sys"
	log "github.com/sirupsen/logrus"
	"golang.org/x/sys/windows"
	"math"
	"os"
	"path/filepath"
	"time"
)

const systrayPipe = `\\.\pipe\fibratus-systray`

// systray interops with the status area
// to show balloon notifications with the
// desired title and text. Both, regular
// and balloon icons are also rendered when
// displaying the notification message. The
// interactions with the status area are
// performed via IPC through named pipe.
// Systray process exposes the named pipe server
// and listen for incoming messages published
// by the systray sender.
type systray struct {
	config Config
	proc   windows.Handle // systray server process handle
}

// MsgType determines the type of the message sent
// to the systray named pipe server.
type MsgType uint8

const (
	Conf MsgType = iota
	Balloon
)

// Msg represents the data exchanged between systray client/server.
type Msg struct {
	Type MsgType `json:"type"`
	Data any     `json:"data"`
}

func (m Msg) encode() ([]byte, error) {
	b, err := json.Marshal(m)
	if err != nil {
		return nil, err
	}
	return b, err
}

func init() {
	alertsender.Register(alertsender.Systray, makeSender)
}

// makeSender constructs a new instance of the systray alert sender.
func makeSender(config alertsender.Config) (alertsender.Sender, error) {
	c, ok := config.Sender.(Config)
	if !ok {
		return nil, alertsender.ErrInvalidConfig(alertsender.Systray)
	}

	if !c.Enabled {
		return &systray{}, nil
	}

	// spin up systray server process
	var si windows.StartupInfo
	var pi windows.ProcessInformation

	exe, err := os.Executable()
	if err != nil {
		return nil, err
	}
	cmdline := filepath.Join(filepath.Dir(exe), "fibratus-systray.exe")
	argv, err := windows.UTF16PtrFromString(cmdline)
	if err != nil {
		return nil, err
	}

	log.Infof("starting systray server process %q", cmdline)

	if sys.IsWindowsService() {
		// if we're running inside Windows Service, the systray server
		// process must be created in the console session and with the
		// currently logged-in user access token
		var token windows.Token

		// enable TCB privilege to obtain the console session user token
		sys.SetTcbPrivilege()

		consoleSessionID := sys.WTSGetActiveConsoleSessionID()
		if consoleSessionID == math.MaxUint32 && sys.IsInSandbox() {
			// if we failed to obtain the console session ID and
			// are running inside Windows Sandbox, use session 1
			consoleSessionID = 1
		}

		if sys.WTSQueryUserToken(consoleSessionID, &token) {
			log.Infof("obtained user token for console session ID %d", consoleSessionID)
			err = windows.CreateProcessAsUser(
				token,
				nil,
				argv,
				nil,
				nil,
				false,
				windows.CREATE_NO_WINDOW,
				nil,
				nil,
				&si,
				&pi,
			)
		} else {
			err = fmt.Errorf("unable to obtain user token for console session ID %d", consoleSessionID)
		}

		// drop TCB privilege and close the token handle
		sys.RemoveTcbPrivilege()
		_ = windows.CloseHandle(windows.Handle(token))
	} else {
		err = windows.CreateProcess(
			nil,
			argv,
			nil,
			nil,
			false,
			windows.CREATE_NO_WINDOW,
			nil,
			nil,
			&si,
			&pi)
	}

	if err != nil {
		log.Warnf("unable to start systray server process: %v", err)
	}

	s := &systray{config: c}
	b := &backoff.ExponentialBackOff{
		// first backoff timeout will be somewhere in the 100 - 300 ms range given the default multiplier
		InitialInterval:     time.Millisecond * 200,
		RandomizationFactor: backoff.DefaultRandomizationFactor,
		Multiplier:          backoff.DefaultMultiplier,
		MaxInterval:         time.Second * 10,
		MaxElapsedTime:      time.Minute * 30,
		Stop:                backoff.Stop,
		Clock:               backoff.SystemClock,
	}

	b.Reset()

	for {
		if !pipeExists() {
			backoffTime := b.NextBackOff()
			if backoffTime == backoff.Stop {
				return nil, fmt.Errorf("%s named pipe didn't appear after 30m", systrayPipe)
			}
			log.Warnf("systray pipe not ready. Trying to dial in %v...", backoffTime)
			time.Sleep(backoffTime)
			continue
		}
		break
	}

	log.Info("established connection to systray server")

	s.proc = pi.Process

	return s, s.send(&Msg{Type: Conf, Data: c})
}

func (s *systray) Send(alert alertsender.Alert) error {
	// remove all events to avoid decoding errors on systray server end
	alert.Events = make([]*event.Event, 0)
	return s.send(&Msg{Type: Balloon, Data: alert})
}

func (*systray) Type() alertsender.Type { return alertsender.Systray }
func (*systray) SupportsMarkdown() bool { return false }

func (s *systray) Shutdown() error {
	if s.proc != 0 && sys.IsProcessRunning(s.proc) {
		return windows.TerminateProcess(s.proc, 1)
	}
	return nil
}

func (s *systray) send(m *Msg) error {
	ctx, cancel := context.WithTimeout(context.Background(), time.Second*5)
	defer cancel()

	conn, err := winio.DialPipeContext(ctx, systrayPipe)
	if err != nil {
		return fmt.Errorf("unable to dial %s pipe: %v", systrayPipe, err)
	}
	defer conn.Close()

	b, err := m.encode()
	if err != nil {
		return err
	}
	if err = conn.SetDeadline(time.Now().Add(time.Second * 5)); err != nil {
		return err
	}
	if _, err = conn.Write(b); err != nil {
		return fmt.Errorf("unable to write systray pipe: %v", err)
	}

	return nil
}

func pipeExists() bool {
	_, err := os.Stat(systrayPipe)
	return err == nil
}

```

`pkg/alertsender/systray/systray_test.go`:

```go
/*
 * Copyright 2021-2022 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package systray

import (
	"encoding/json"
	"io"
	"net"
	"sync"
	"testing"

	"github.com/Microsoft/go-winio"
	"github.com/mitchellh/mapstructure"
	"github.com/rabbitstack/fibratus/pkg/alertsender"
	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/require"
)

func handleMessage(t *testing.T, conn net.Conn, wg *sync.WaitGroup, msgs chan Msg) {
	buf := make([]byte, 1024)
	defer conn.Close()
	defer func() {
		wg.Done()
	}()
	n, err := conn.Read(buf)
	if err != nil {
		if err != io.EOF {
			t.Error(err)
			t.Fail()
		}
		return
	}
	var m Msg
	err = json.Unmarshal(buf[:n], &m)
	if err != nil {
		t.Error(err)
		t.Fail()
	}
	msgs <- m
}

func TestSystraySender(t *testing.T) {
	// set up named pipe server
	l, err := winio.ListenPipe(systrayPipe, nil)
	require.NoError(t, err)
	defer l.Close()

	var wg sync.WaitGroup
	wg.Add(3)

	msgs := make(chan Msg, 2)
	go func(wg *sync.WaitGroup) {
		for {
			conn, err := l.Accept()
			if err != nil {
				break
			}
			go handleMessage(t, conn, wg, msgs)
		}
	}(&wg)

	s, err := alertsender.Load(alertsender.Config{Type: alertsender.Systray, Sender: Config{Enabled: true, Sound: false, QuietMode: false}})
	require.NoError(t, err)
	require.NotNil(t, s)

	require.NoError(t, s.Send(alertsender.Alert{
		Title: "LSASS memory dumping via legitimate or offensive tools",
		Text: `Detected an attempt by mimikatz.exe process to access and read
	the memory of the Local Security And Authority Subsystem Service
	and subsequently write the C:\\temp\lsass.dmp dump file to the disk device`}))

	wg.Wait()

	// consume messages
	cfg := <-msgs
	require.NotNil(t, cfg)
	require.Equal(t, MsgType(0), cfg.Type)

	alert := <-msgs
	require.NotNil(t, alert)
	require.Equal(t, MsgType(1), alert.Type)
	var a alertsender.Alert
	require.NoError(t, decodeMsg(&a, alert.Data))
	assert.Equal(t, "LSASS memory dumping via legitimate or offensive tools", a.Title)
}

func decodeMsg(output any, data any) error {
	var decoderConfig = &mapstructure.DecoderConfig{
		Metadata:         nil,
		Result:           output,
		WeaklyTypedInput: true,
		DecodeHook: mapstructure.ComposeDecodeHookFunc(
			mapstructure.StringToTimeDurationHookFunc(),
			mapstructure.StringToSliceHookFunc(","),
			alertsender.StringToSeverityDecodeHook(),
		),
	}
	decoder, err := mapstructure.NewDecoder(decoderConfig)
	if err != nil {
		return err
	}
	return decoder.Decode(data)
}

```

`pkg/api/handler/config.go`:

```go
/*
 * Copyright 2019-2020 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package handler

import (
	"github.com/rabbitstack/fibratus/pkg/config"
	"net/http"
)

// Config is the handler the serves the current configuration state as pretty-formatted text.
func Config(c *config.Config) http.Handler {
	return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		if _, err := w.Write([]byte(c.Print())); err != nil {
			http.Error(w, err.Error(), http.StatusInternalServerError)
		}
	})
}

```

`pkg/api/listener.go`:

```go
//go:build windows
// +build windows

/*
 * Copyright 2019-2020 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package api

import (
	"context"
	"fmt"
	"net"
	"strings"

	"github.com/Microsoft/go-winio"
)

// MakePipeListener produces a new listener for receiving requests over a named pipe.
func MakePipeListener(pipePath, descriptor string) (net.Listener, error) {
	npipe := transformPipePath(pipePath)
	l, err := winio.ListenPipe(npipe, &winio.PipeConfig{SecurityDescriptor: descriptor})
	if err != nil {
		return nil, fmt.Errorf("fail to listen on the %q pipe: %v", pipePath, err)
	}
	return l, nil
}

// makeTCPListener produces a new listener for receiving requests over TCP.
func makeTCPListener(addr string) (net.Listener, error) {
	//nolint:noctx
	return net.Listen("tcp", addr)
}

// DialPipe creates a dialer to be used with the http.Client to connect to a named pipe.
func DialPipe(pipePath string) func(context.Context, string, string) (net.Conn, error) {
	npipe := transformPipePath(pipePath)
	return func(ctx context.Context, _, _ string) (net.Conn, error) {
		return winio.DialPipeContext(ctx, npipe)
	}
}

// transformPipePath takes an input type name defined as a URI like `npipe:///hello` and transform it into
// `\\.\pipe\hello`. Borrowed from https://github.com/elastic/beats/blob/master/libbeat/api/npipe/listener_windows.go
func transformPipePath(name string) string {
	if strings.HasPrefix(name, "npipe:///") {
		path := strings.TrimPrefix(name, "npipe:///")
		return `\\.\pipe\` + path
	}

	if strings.HasPrefix(name, `\\.\pipe\`) {
		return name
	}

	return name
}

```

`pkg/api/server.go`:

```go
/*
 * Copyright 2020-2021 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package api

import (
	"expvar"
	"github.com/rabbitstack/fibratus/pkg/api/handler"
	"github.com/rabbitstack/fibratus/pkg/config"
	log "github.com/sirupsen/logrus"
	"net"
	"net/http"
	"net/http/pprof"
	"runtime/debug"
	"strings"
)

func setupServer(lis net.Listener, c *config.Config) {
	mux := http.NewServeMux()
	mux.Handle("/config", handler.Config(c))
	mux.Handle("/debug/vars", expvar.Handler())

	mux.HandleFunc("/debug/pprof/", pprof.Index)
	mux.HandleFunc("/debug/pprof/profile", pprof.Profile)
	mux.HandleFunc("/debug/freemem", func(writer http.ResponseWriter, request *http.Request) {
		debug.FreeOSMemory()
	})

	srv := &http.Server{
		Handler: mux,
	}

	go func() {
		if err := srv.Serve(lis); err != nil && err != http.ErrServerClosed {
			if strings.Contains(err.Error(), "use of closed network connection") {
				return
			}
			log.Errorf("unable to bind the API server: %v", err)
		}
	}()
}

```

`pkg/api/server_windows.go`:

```go
/*
 * Copyright 2019-2020 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package api

import (
	"fmt"
	"github.com/rabbitstack/fibratus/pkg/config"
	"net"
	"os/user"
	"strings"
)

var listener net.Listener

// StartServer starts the HTTP server with the specified configuration.
func StartServer(c *config.Config) error {
	var err error
	apiConfig := c.API
	if strings.HasPrefix(apiConfig.Transport, `npipe:///`) {
		usr, err := user.Current()
		if err != nil {
			return fmt.Errorf("failed to retrieve the current user: %v", err)
		}
		// Named pipe security and access rights.
		// We create the pipe and the specific users should only be able to write to it.
		// See docs: https://docs.microsoft.com/en-us/windows/win32/ipc/named-pipe-security-and-access-rights
		// String definition: https://docs.microsoft.com/en-us/windows/win32/secauthz/ace-strings
		// Give generic read/write access to the specified user.
		descriptor := "D:P(A;;GA;;;" + usr.Uid + ")"
		listener, err = MakePipeListener(apiConfig.Transport, descriptor)
		if err != nil {
			return err
		}
	} else {
		listener, err = makeTCPListener(apiConfig.Transport)
	}
	if err != nil {
		return err
	}

	setupServer(listener, c)

	return nil
}

// CloseServer shutdowns the server by stopping the listener.
func CloseServer() error {
	if listener != nil {
		return listener.Close()
	}
	return nil
}

```

`pkg/callstack/callstack.go`:

```go
/*
 * Copyright 2021-2022 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package callstack

import (
	"os"
	"path/filepath"
	"strconv"
	"strings"

	"github.com/rabbitstack/fibratus/pkg/util/va"
	"golang.org/x/arch/x86/x86asm"
	"golang.org/x/sys/windows"
)

// unbacked represents the identifier for unbacked regions in stack frames
const unbacked = "unbacked"

var pageSize = uint64(os.Getpagesize())

// buildNumber stores the Windows OS build number
var _, _, buildNumber = windows.RtlGetNtVersionNumbers()

// Frame describes a single stack frame.
type Frame struct {
	PID           uint32     // pid owning thread's stack
	Addr          va.Address // return address
	Offset        uint64     // symbol offset
	Symbol        string     // symbol name
	Module        string     // module name
	ModuleAddress va.Address // module base address
}

// IsUnbacked returns true if this frame is originated
// from unbacked memory section
func (f Frame) IsUnbacked() bool { return f.Module == unbacked }

// AllocationSize calculates the private region size
// to which the frame return address pertains if the
// memory pages within the region are private and
// non-shareable pages.
func (f *Frame) AllocationSize(proc windows.Handle) uint64 {
	if f.Addr.InSystemRange() {
		return 0
	}

	r := va.VirtualQuery(proc, f.Addr.Uint64())

	if r == nil || (r.State != windows.MEM_COMMIT || r.Protect == windows.PAGE_NOACCESS || r.Type != va.MemImage) {
		return 0
	}

	var size uint64

	// traverse all pages in the region
	for n := uint64(0); n < r.Size; n += pageSize {
		addr := f.Addr.Inc(n)
		ws := va.QueryWorkingSet(proc, addr.Uint64())
		if ws == nil || !ws.Valid() {
			continue
		}

		// use SharedOriginal after RS3/1709
		if buildNumber >= 16299 {
			if !ws.SharedOriginal() {
				size += pageSize
			}
		} else {
			if !ws.Shared() {
				size += pageSize
			}
		}
	}

	return size
}

// Protection resolves the memory protection
// of the pages within the region that contains the
// frame return address.
func (f *Frame) Protection(proc windows.Handle) string {
	if f.Addr.InSystemRange() {
		return ""
	}
	r := va.VirtualQuery(proc, f.Addr.Uint64())
	if r == nil {
		return "?"
	}
	return r.ProtectMask()
}

// CallsiteAssembly decodes the callsite trailing/leading
// bytes depending on the value of the `leading` argument.
// The resulting string contains the decoded x86 machine
// opcodes in Intel assembler syntax.
func (f *Frame) CallsiteAssembly(proc windows.Handle, leading bool) string {
	if f.Addr.InSystemRange() {
		return ""
	}

	size := uint(512)
	base := f.Addr.Uintptr()
	if leading {
		base -= uintptr(size)
	}

	buf := va.ReadArea(proc, base, size, size, false)
	if len(buf) == 0 || va.Zeroed(buf) {
		return ""
	}

	var b strings.Builder

	for i := 0; i < len(buf); {
		ins, err := x86asm.Decode(buf[i:], 64)
		if err != nil {
			return b.String()
		}
		b.WriteString(x86asm.IntelSyntax(ins, f.Addr.Uint64(), nil))
		b.WriteRune('|')
		i += ins.Len
	}

	return b.String()
}

// Callstack is a sequence of stack frames
// representing function executions.
type Callstack []Frame

// Init allocates the initial callstack capacity.
func (s *Callstack) Init(n int) {
	*s = make(Callstack, 0, n)
}

// PushFrame pushes a new from to the call stack.
func (s *Callstack) PushFrame(f Frame) {
	if f.Module == "" {
		f.Module = unbacked
	}
	*s = append(*s, f)
}

// FrameAt returns the stack frame at the specified index.
func (s *Callstack) FrameAt(i int) Frame {
	if i > len(*s)-1 {
		return Frame{}
	}
	return (*s)[i]
}

// Depth returns the number of frames in the call stack.
func (s *Callstack) Depth() int { return len(*s) }

// IsEmpty returns true if the callstack has no frames.
func (s *Callstack) IsEmpty() bool { return s.Depth() == 0 }

// FinalUserFrame returns the final frame that corresponds
// to the user code execution. That usually translates to
// the last frame before ntdll or kernel32 modules.
func (s *Callstack) FinalUserFrame() *Frame {
	if s.IsEmpty() {
		return nil
	}

	var n int
	for n = s.Depth() - 1; n > 0; n-- {
		f := (*s)[n]
		if f.Addr.InSystemRange() {
			continue
		}
		mod := filepath.Base(strings.ToLower(f.Module))
		if mod != "ntdll.dll" && mod != "kernel32.dll" && mod != "kernelbase.dll" {
			break
		}
	}

	if n >= 0 && n < s.Depth()-1 {
		return &(*s)[n]
	}

	return nil
}

// FinalUserspaceFrame returns the final userspace frame. This
// frame is typically backed by the ntdll module.
func (s *Callstack) FinalUserspaceFrame() *Frame {
	if s.IsEmpty() {
		return nil
	}

	for n := s.Depth() - 1; n > 0; n-- {
		f := (*s)[n]
		if f.Addr.InSystemRange() {
			continue
		}
		return &f
	}

	return nil
}

// FinalKernelFrame returns the final kernel space frame.
func (s *Callstack) FinalKernelFrame() *Frame {
	if s.IsEmpty() {
		return nil
	}
	return &(*s)[s.Depth()-1]
}

// Summary returns a sequence of non-repeated module names.
func (s Callstack) Summary() string {
	var b strings.Builder
	var prev string
	var removeSep bool

	for i := range s {
		frame := s[len(s)-i-1]
		if frame.Addr.InSystemRange() {
			continue
		}

		var n string
		if frame.IsUnbacked() {
			n = unbacked
		} else {
			n = filepath.Base(frame.Module)
		}

		if n == prev {
			if i == len(s)-1 {
				// last module equals to the previous
				// which renders redundant separator
				removeSep = true
			}
			continue
		}

		b.WriteString(n)
		if i != len(s)-1 {
			b.WriteRune('|')
		}
		prev = n
	}

	if removeSep {
		return strings.TrimSuffix(b.String(), "|")
	}

	return b.String()
}

func (s Callstack) String() string {
	var b strings.Builder

	for i := range s {
		frame := s[len(s)-i-1]
		b.WriteString("0x")
		b.WriteString(frame.Addr.String())
		b.WriteString(" ")

		if frame.Addr.InSystemRange() && frame.Module == unbacked {
			b.WriteString("?")
		} else {
			b.WriteString(frame.Module)
		}

		b.WriteRune('!')
		if frame.Symbol != "" && frame.Symbol != "?" {
			b.WriteString(frame.Symbol)
		} else {
			b.WriteRune('?')
		}

		if frame.Offset != 0 {
			b.WriteString("+0x")
			b.WriteString(strconv.FormatUint(frame.Offset, 16))
		}

		if i != len(s)-1 {
			b.WriteRune('|')
		}
	}
	return b.String()
}

// ContainsUnbacked returns true if there is a frame
// pertaining to the function call initiated from the
// unbacked memory section. This method only checks
// user space frames for such a condition.
func (s Callstack) ContainsUnbacked() bool {
	for _, frame := range s {
		if !frame.Addr.InSystemRange() && frame.IsUnbacked() {
			return true
		}
	}
	return false
}

// ContainsSymbol checks if the supplied symbol name is present in the callstack.
func (s Callstack) ContainsSymbol(sym string) bool {
	for _, frame := range s {
		if frame.Symbol == sym {
			return true
		}
	}
	return false
}

// Addresses returns stack retrun addresses.
func (s Callstack) Addresses() []string {
	addrs := make([]string, len(s))
	for i, frame := range s {
		addrs[i] = frame.Addr.String()
	}
	return addrs
}

// Modules returns all modules comprising the thread stack.
func (s Callstack) Modules() []string {
	mods := make([]string, len(s))
	for i, f := range s {
		mods[i] = f.Module
	}
	return mods
}

// Symbols returns all symbols comprising the call stack.
// Each symbol name is prefixed with the source module.
func (s Callstack) Symbols() []string {
	syms := make([]string, len(s))
	for i, f := range s {
		syms[i] = filepath.Base(f.Module) + "!" + f.Symbol
	}
	return syms
}

// AllocationSizes returns allocation size of each stack frame
// in terms of allocation/module private non-shareable pages.
func (s Callstack) AllocationSizes(pid uint32) []uint64 {
	proc, err := windows.OpenProcess(windows.PROCESS_QUERY_INFORMATION, false, pid)
	if err != nil {
		return nil
	}
	defer windows.Close(proc)
	sizes := make([]uint64, len(s))
	for i, f := range s {
		sizes[i] = f.AllocationSize(proc)
	}
	return sizes
}

// Protections returns page protection mask for every
// frame comprising the stack.
func (s Callstack) Protections(pid uint32) []string {
	proc, err := windows.OpenProcess(windows.PROCESS_QUERY_INFORMATION, false, pid)
	if err != nil {
		return nil
	}
	defer windows.Close(proc)
	prots := make([]string, len(s))
	for i, f := range s {
		prots[i] = f.Protection(proc)
	}
	return prots
}

// CallsiteInsns returns callsite assembly opcodes
// for leading/trailing bytes contained in each frame.
func (s Callstack) CallsiteInsns(pid uint32, leading bool) []string {
	proc, err := windows.OpenProcess(windows.PROCESS_QUERY_INFORMATION|windows.PROCESS_VM_READ, false, pid)
	if err != nil {
		return nil
	}
	defer windows.Close(proc)
	opcodes := make([]string, len(s))
	for i, f := range s {
		opcodes[i] = f.CallsiteAssembly(proc, leading)
	}
	return opcodes
}

```

`pkg/callstack/callstack_test.go`:

```go
/*
 * Copyright 2021-present by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package callstack

import (
	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/require"
	"testing"
)

func TestCallstack(t *testing.T) {
	var callstack Callstack
	callstack.Init(9)

	assert.Equal(t, 9, cap(callstack))

	callstack.PushFrame(Frame{Addr: 0x2638e59e0a5, Offset: 0, Symbol: "?", Module: "unbacked"})
	callstack.PushFrame(Frame{Addr: 0x7ffb313853b2, Offset: 0x10a, Symbol: "Java_java_lang_ProcessImpl_create", Module: "C:\\Program Files\\JetBrains\\GoLand 2021.2.3\\jbr\\bin\\java.dll"})
	callstack.PushFrame(Frame{Addr: 0x7ffb3138592e, Offset: 0x3a2, Symbol: "Java_java_lang_ProcessImpl_waitForTimeoutInterruptibly", Module: "C:\\Program Files\\JetBrains\\GoLand 2021.2.3\\jbr\\bin\\java.dll"})
	callstack.PushFrame(Frame{Addr: 0x7ffb5c1d0396, Offset: 0x61, Symbol: "CreateProcessW", Module: "C:\\WINDOWS\\System32\\KERNELBASE.dll"})
	callstack.PushFrame(Frame{Addr: 0x7ffb5d8e61f4, Offset: 0x54, Symbol: "CreateProcessW", Module: "C:\\WINDOWS\\System32\\KERNEL32.DLL"})
	callstack.PushFrame(Frame{Addr: 0x7ffb5c1d0396, Offset: 0x66, Symbol: "CreateProcessW", Module: "C:\\WINDOWS\\System32\\KERNELBASE.dll"})
	callstack.PushFrame(Frame{Addr: 0xfffff8015662a605, Offset: 0x9125, Symbol: "setjmpex", Module: "C:\\WINDOWS\\system32\\ntoskrnl.exe"})
	callstack.PushFrame(Frame{Addr: 0xfffff801568e9c33, Offset: 0x2ef3, Symbol: "LpcRequestPort", Module: "C:\\WINDOWS\\system32\\ntoskrnl.exe"})
	callstack.PushFrame(Frame{Addr: 0xfffff8015690b644, Offset: 0x45b4, Symbol: "ObDeleteCapturedInsertInfo", Module: "C:\\WINDOWS\\system32\\ntoskrnl.exe"})

	assert.True(t, callstack.ContainsUnbacked())
	assert.Equal(t, 9, callstack.Depth())
	assert.Equal(t, "0xfffff8015690b644 C:\\WINDOWS\\system32\\ntoskrnl.exe!ObDeleteCapturedInsertInfo+0x45b4|0xfffff801568e9c33 C:\\WINDOWS\\system32\\ntoskrnl.exe!LpcRequestPort+0x2ef3|0xfffff8015662a605 C:\\WINDOWS\\system32\\ntoskrnl.exe!setjmpex+0x9125|0x7ffb5c1d0396 C:\\WINDOWS\\System32\\KERNELBASE.dll!CreateProcessW+0x66|0x7ffb5d8e61f4 C:\\WINDOWS\\System32\\KERNEL32.DLL!CreateProcessW+0x54|0x7ffb5c1d0396 C:\\WINDOWS\\System32\\KERNELBASE.dll!CreateProcessW+0x61|0x7ffb3138592e C:\\Program Files\\JetBrains\\GoLand 2021.2.3\\jbr\\bin\\java.dll!Java_java_lang_ProcessImpl_waitForTimeoutInterruptibly+0x3a2|0x7ffb313853b2 C:\\Program Files\\JetBrains\\GoLand 2021.2.3\\jbr\\bin\\java.dll!Java_java_lang_ProcessImpl_create+0x10a|0x2638e59e0a5 unbacked!?", callstack.String())
	assert.Equal(t, "KERNELBASE.dll|KERNEL32.DLL|KERNELBASE.dll|java.dll|unbacked", callstack.Summary())

	uframe := callstack.FinalUserFrame()
	require.NotNil(t, uframe)
	assert.Equal(t, "7ffb3138592e", uframe.Addr.String())
	assert.Equal(t, "Java_java_lang_ProcessImpl_waitForTimeoutInterruptibly", uframe.Symbol)
	assert.Equal(t, "C:\\Program Files\\JetBrains\\GoLand 2021.2.3\\jbr\\bin\\java.dll", uframe.Module)

	kframe := callstack.FinalKernelFrame()
	require.NotNil(t, kframe)
	assert.Equal(t, "fffff8015690b644", kframe.Addr.String())
	assert.Equal(t, "ObDeleteCapturedInsertInfo", kframe.Symbol)
	assert.Equal(t, "C:\\WINDOWS\\system32\\ntoskrnl.exe", kframe.Module)

	finalUserspaceFrame := callstack.FinalUserspaceFrame()
	require.NotNil(t, finalUserspaceFrame)
	assert.Equal(t, "7ffb5c1d0396", finalUserspaceFrame.Addr.String())
	assert.Equal(t, "CreateProcessW", finalUserspaceFrame.Symbol)
	assert.Equal(t, "C:\\WINDOWS\\System32\\KERNELBASE.dll", finalUserspaceFrame.Module)
}

func TestCallstackFinalUserFrame(t *testing.T) {
	var tests = []struct {
		callstack   Callstack
		expectedMod string
		expectedSym string
	}{
		{callstack: callstackFromFrames(
			Frame{Addr: 0xf259de, Module: unbacked, Symbol: "?"},
			Frame{Addr: 0x7ffe4fda6e3b, Module: "C:\\Windows\\System32\\KernelBase.dll", Symbol: "SetThreadContext"},
			Frame{Addr: 0x7ffe52942b24, Module: "C:\\Windows\\System32\\ntdll.dll", Symbol: "ZwSetContextThread"},
			Frame{Addr: 0xfffff807e228c555, Module: "C:\\WINDOWS\\system32\\ntoskrnl.exe", Symbol: "setjmpex"},
			Frame{Addr: 0xfffff807e264805c, Module: "C:\\WINDOWS\\system32\\ntoskrnl.exe", Symbol: "ObOpenObjectByPointerWithTag"}),
			expectedMod: "unbacked",
			expectedSym: "?",
		},
		{callstack: callstackFromFrames(
			Frame{Addr: 0x7ffff0f3bf6c, Module: "C:\\Windows\\System32\\ntdll.dll", Symbol: "RtlUserThreadStart"},
			Frame{Addr: 0x7ffff03ee8d7, Module: "C:\\Windows\\System32\\ntdll.dll", Symbol: "BaseThreadInitThunk"},
			Frame{Addr: 0x7ffff0ee5f13, Module: "C:\\Windows\\System32\\ntdll.dll", Symbol: "TpCallbackMayRunLong"},
			Frame{Addr: 0x7ffff0c78788, Module: "C:\\Windows\\System32\\rpcrt4.dll", Symbol: "RpcGetBufferWithObject"},
			Frame{Addr: 0x7ffff0c797e3, Module: "C:\\Windows\\System32\\rpcrt4.dll", Symbol: "RpcImpersonateClient"},
			Frame{Addr: 0x7fffee58d16a, Module: "C:\\Windows\\System32\\KernelBase.dll", Symbol: "CreateProcessInternalW"},
			Frame{Addr: 0x7ffff0fe1204, Module: "C:\\Windows\\System32\\ntdll.dll", Symbol: "ZwCreateUserProcess"}),
			expectedMod: "C:\\Windows\\System32\\rpcrt4.dll",
			expectedSym: "RpcImpersonateClient",
		},
		{callstack: callstackFromFrames(
			Frame{Addr: 0x7fffa7e3bf6c, Module: "C:\\Windows\\System32\\ntdll.dll", Symbol: "RtlUserThreadStart"},
			Frame{Addr: 0x7fffa60de8d7, Module: "C:\\Windows\\System32\\ntdll.dll", Symbol: "BaseThreadInitThunk"},
			Frame{Addr: 0x7ff6163cfc68, Module: "C:\\Program Files\\Mozilla Firefox\\firefox.exe", Symbol: "TargetCreateThread"},
			Frame{Addr: 0x7fffee58d16a, Module: "C:\\Windows\\System32\\ntdll.dll", Symbol: "ZwMapViewOfSection"},
			Frame{Addr: 0xfffff8028deeed1d, Module: "C:\\WINDOWS\\system32\\ntoskrnl.exe", Symbol: "NtMapViewOfSection"}),
			expectedMod: "C:\\Program Files\\Mozilla Firefox\\firefox.exe",
			expectedSym: "TargetCreateThread",
		},
		{callstack: callstackFromFrames(
			Frame{Addr: 0x7fffa7e3bf6c, Module: "C:\\Windows\\System32\\ntdll.dll", Symbol: "RtlUserThreadStart"},
			Frame{Addr: 0x7fffa60de8d7, Module: "C:\\Windows\\System32\\ntdll.dll", Symbol: "BaseThreadInitThunk"},
			Frame{Addr: 0x7ffff0c78788, Module: "C:\\Windows\\System32\\rpcrt4.dll", Symbol: "NdrServerCallNdr64"},
			Frame{Addr: 0x7ffff0c574ed, Module: "C:\\Windows\\System32\\rpcrt4.dll", Symbol: "NdrStubCall2"},
			Frame{Addr: 0x7ffff03fb090, Module: "C:\\Windows\\System32\\kernel32.dll", Symbol: "CreateProcessInternalW"},
			Frame{Addr: 0x7fffee58a923, Module: "C:\\Windows\\System32\\kernel32.dll", Symbol: "CreateProcessAsUserW"},
			Frame{Addr: 0x7ffff0fe1204, Module: "C:\\Windows\\System32\\ntdll.dll", Symbol: "ZwCreateUserProcess"}),
			expectedMod: "C:\\Windows\\System32\\rpcrt4.dll",
			expectedSym: "NdrStubCall2",
		},
	}

	for _, tt := range tests {
		t.Run(tt.expectedMod+"!"+tt.expectedSym, func(t *testing.T) {
			f := tt.callstack.FinalUserFrame()
			require.NotNil(t, f)
			assert.Equal(t, tt.expectedMod, f.Module)
			assert.Equal(t, tt.expectedSym, f.Symbol)
		})
	}
}

func callstackFromFrames(frames ...Frame) Callstack {
	var c Callstack
	for _, frame := range frames {
		c.PushFrame(frame)
	}
	return c
}

```

`pkg/cap/config.go`:

```go
/*
 * Copyright 2019-2020 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package cap

import "time"

// Config stores options that influences the behaviour of the kernel capture reader/writer.
type Config struct {
	FlushPeriod time.Duration
}

```

`pkg/cap/header.go`:

```go
//go:build cap
// +build cap

/*
 * Copyright 2019-2020 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package cap

import (
	"github.com/rabbitstack/fibratus/pkg/cap/section"
	kcapver "github.com/rabbitstack/fibratus/pkg/cap/version"
)

// magic has two purposes. It is used to identify cap files. The magic is stored within the first 8 bytes of the file.
// The reader ensures the magic number matches this constant. Besides identifying the capture file, it serves as an
// input for initializing the byte order on the machine where cap file is read. This implies capture can be taken on a
// machine with different endianness from the one capture is replayed.
const magic = 0x6669627261747573

// major represents the major digit of the cap file format. Incrementing the major digit makes older cap readers not
// capable to replay the capture file
const major = uint8(2)

// minor represents the minor digit of the cap file format
const minor = uint8(0)

// flags denotes extra flags for the purpose of the header description
const flags = uint64(0)

// ws writes the section block with the specified parameters.
func (w *writer) ws(typ section.Type, ver kcapver.Version, l, size uint32) error {
	sec := section.New(typ, ver, l, size)
	if _, err := w.zw.Write(sec[:]); err != nil {
		return ErrWriteSection(typ, err)
	}
	return nil
}

```

`pkg/cap/reader.go`:

```go
//go:build cap
// +build cap

/*
 * Copyright 2020-2021 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package cap

import (
	"errors"
	"expvar"
	"fmt"
	"github.com/rabbitstack/fibratus/pkg/cap/section"
)

var (
	// ErrCapMagicMismatch signals invalid capture binary format
	ErrCapMagicMismatch = errors.New("invalid capture file magic number")
	// ErrMajorVer signals incompatible cap version
	ErrMajorVer = func(maj, min byte) error {
		return fmt.Errorf("incompatible cap version format. Required version %d.%d but %d.%d found", major, minor, maj, min)
	}
	// ErrReadVersion is thrown when version digit errors occur
	ErrReadVersion = func(s string, err error) error { return fmt.Errorf("couldn't read %s version digit: %v", s, err) }
	// ErrReadSection is thrown when section read errors occur
	ErrReadSection = func(s section.Type, err error) error { return fmt.Errorf("couldn't read %s section: %v", s, err) }

	capReadEvents            = expvar.NewInt("cap.read.events")
	capReadBytes             = expvar.NewInt("cap.read.bytes")
	capEventUnmarshalErrors  = expvar.NewInt("cap.event.unmarshal.errors")
	capHandleUnmarshalErrors = expvar.NewInt("cap.reader.handle.unmarshal.errors")
	capDroppedByFilter       = expvar.NewInt("cap.reader.dropped.by.filter")
)

```

`pkg/cap/reader_unsupported.go`:

```go
//go:build !cap
// +build !cap

/*
 * Copyright 2019-2020 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package cap

import (
	"github.com/rabbitstack/fibratus/pkg/config"
	"github.com/rabbitstack/fibratus/pkg/errors"
)

// NewReader returns unsupported reader.
func NewReader(filename string, config *config.Config) (Reader, error) {
	return nil, errors.ErrFeatureUnsupported("cap")
}

```

`pkg/cap/reader_windows.go`:

```go
//go:build cap
// +build cap

/*
 * Copyright 2019-2020 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package cap

import (
	"context"
	"fmt"
	"github.com/rabbitstack/fibratus/pkg/cap/section"
	"github.com/rabbitstack/fibratus/pkg/config"
	"github.com/rabbitstack/fibratus/pkg/event"
	"github.com/rabbitstack/fibratus/pkg/event/params"
	"github.com/rabbitstack/fibratus/pkg/filter"
	"github.com/rabbitstack/fibratus/pkg/handle"
	htypes "github.com/rabbitstack/fibratus/pkg/handle/types"
	"github.com/rabbitstack/fibratus/pkg/ps"
	"github.com/rabbitstack/fibratus/pkg/util/bytes"
	log "github.com/sirupsen/logrus"
	zstd "github.com/valyala/gozstd"
	"io"
	"os"
	"path/filepath"
	"sync"
)

type reader struct {
	zr           *zstd.Reader
	f            *os.File
	psnapshotter ps.Snapshotter
	hsnapshotter handle.Snapshotter
	filter       filter.Filter
	config       *config.Config
	mu           sync.Mutex // guards the underlying zstd byte buffer
}

// NewReader builds a new instance of the cap reader.
func NewReader(filename string, config *config.Config) (Reader, error) {
	if filepath.Ext(filename) == "" {
		filename += ".cap"
	}
	f, err := os.Open(filename)
	if err != nil {
		if os.IsNotExist(err) {
			return nil, fmt.Errorf("%q capture file does not exist", filename)
		}
		return nil, err
	}
	zr := zstd.NewReader(f)

	mag := make([]byte, 8)
	if n, err := zr.Read(mag); err != nil || n != 8 {
		return nil, ErrCapMagicMismatch
	}
	bytes.InitNativeEndian(mag)
	// from now on all byte reads will use the endianness of the magic number.
	// This guarantees we'll be able to replay captures that were taken
	// on a machine with a different endianness from the machine where
	// actual capture is being read.
	if bytes.ReadUint64(mag) != magic {
		return nil, ErrCapMagicMismatch
	}

	maj := make([]byte, 1)
	min := make([]byte, 1)

	if n, err := zr.Read(maj); err != nil || n != 1 {
		return nil, ErrReadVersion("major", err)
	}
	if n, err := zr.Read(min); err != nil || n != 1 {
		return nil, ErrReadVersion("minor", err)
	}
	if maj[0] < major {
		return nil, ErrMajorVer(maj[0], min[0])
	}

	// read the flags bit vector but do nothing with it at the moment
	flags := make([]byte, 8)
	if n, err := zr.Read(flags); err != nil || n != 8 {
		return nil, fmt.Errorf("fail to read cap flags: %v", err)
	}

	return &reader{f: f, zr: zr, config: config}, nil
}

func (r *reader) SetFilter(f filter.Filter) { r.filter = f }

func (r *reader) Read(ctx context.Context) (chan *event.Event, chan error) {
	errsc := make(chan error, 100)
	eventsc := make(chan *event.Event, 2000)
	go func() {
		r.mu.Lock()
		defer r.mu.Unlock()
		for {
			select {
			case <-ctx.Done():
				return
			default:
			}

			var sec section.Section
			if _, err := io.ReadFull(r.zr, sec[:]); err != nil {
				if err != io.EOF {
					errsc <- err
					continue
				}
				break
			}

			l := sec.Size()
			buf := make([]byte, l)
			if _, err := io.ReadFull(r.zr, buf); err != nil {
				if err != io.EOF {
					errsc <- err
					continue
				}
				break
			}
			evt, err := event.NewFromCapture(buf, sec.Version())
			if err != nil {
				errsc <- fmt.Errorf("fail to unmarshal event: %v", err)
				capEventUnmarshalErrors.Add(1)
				continue
			}
			capReadBytes.Add(int64(len(buf)))
			// update the state of the ps/handle snapshotters
			if err := r.updateSnapshotters(evt); err != nil {
				log.Warn(err)
			}
			// push the event to the chanel
			r.read(evt, eventsc)
		}
	}()

	return eventsc, errsc
}

func (r *reader) Close() error {
	r.mu.Lock()
	defer r.mu.Unlock()
	if r.zr != nil {
		r.zr.Release()
	}
	if r.f != nil {
		return r.f.Close()
	}
	return nil
}

func (r *reader) read(evt *event.Event, eventsc chan *event.Event) {
	if evt.Type.OnlyState() {
		return
	}
	if r.filter != nil && !r.filter.Run(evt) {
		capDroppedByFilter.Add(1)
		return
	}
	eventsc <- evt
	capReadEvents.Add(1)
}

func (r *reader) updateSnapshotters(evt *event.Event) error {
	switch evt.Type {
	case event.TerminateProcess:
		if err := r.psnapshotter.Remove(evt); err != nil {
			return err
		}
	case event.TerminateThread:
		pid := evt.Params.MustGetPid()
		tid := evt.Params.MustGetTid()
		if err := r.psnapshotter.RemoveThread(pid, tid); err != nil {
			return err
		}
	case event.UnloadImage:
		pid := evt.Params.MustGetPid()
		addr := evt.Params.TryGetAddress(params.ImageBase)
		if err := r.psnapshotter.RemoveModule(pid, addr); err != nil {
			return err
		}
	case event.CreateProcess,
		event.ProcessRundown,
		event.LoadImage,
		event.ImageRundown,
		event.CreateThread,
		event.ThreadRundown:
		if err := r.psnapshotter.WriteFromCapture(evt); err != nil {
			return err
		}
	case event.CreateHandle:
		if err := r.hsnapshotter.Write(evt); err != nil {
			return err
		}
	case event.CloseHandle:
		if err := r.hsnapshotter.Remove(evt); err != nil {
			return err
		}
	}
	if evt.PS == nil {
		_, evt.PS = r.psnapshotter.Find(evt.PID)
	}
	return nil
}

func (r *reader) RecoverSnapshotters() (handle.Snapshotter, ps.Snapshotter, error) {
	hsnap, err := r.recoverHandleSnapshotter()
	if err != nil {
		return nil, nil, err
	}
	r.psnapshotter = ps.NewSnapshotterFromCapture(hsnap, r.config)
	return hsnap, r.psnapshotter, nil
}

func (r *reader) recoverHandleSnapshotter() (handle.Snapshotter, error) {
	var sec section.Section
	if _, err := io.ReadFull(r.zr, sec[:]); err != nil {
		return nil, ErrReadSection(section.Handle, err)
	}
	nhandles := sec.Len()
	handles := make([]htypes.Handle, nhandles)
	for i := 0; i < int(nhandles); i++ {
		b := make([]byte, 2)
		if _, err := io.ReadFull(r.zr, b); err != nil {
			continue
		}

		l := bytes.ReadUint16(b)
		b = make([]byte, l)
		if _, err := io.ReadFull(r.zr, b); err != nil {
			continue
		}

		var err error
		handles[i], err = htypes.NewFromCapture(b)
		if err != nil {
			capHandleUnmarshalErrors.Add(1)
		}
	}
	r.hsnapshotter = handle.NewFromCapture(handles)
	return r.hsnapshotter, nil
}

```

`pkg/cap/reader_windows_test.go`:

```go
//go:build kcap
// +build kcap

/*
 * Copyright 2019-2020 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package cap

import (
	"context"
	"fmt"
	"github.com/rabbitstack/fibratus/pkg/config"
	"github.com/stretchr/testify/require"
	"testing"
)

func TestReadIncompatibleFormat(t *testing.T) {
	r, err := NewReader("_fixtures/cap1.cap", &config.Config{})
	require.Nil(t, r)
	require.EqualErrorf(t, err, fmt.Sprintf("incompatible cap version format. Required version %d.%d but 1.0 found", major, minor), "incompatible cap version format. Required version %d.%d but 1.0 found", major, minor)
}

func TestRead(t *testing.T) {
	r, err := NewReader("_fixtures/cap2.cap", &config.Config{})
	if err != nil {
		t.Fatal(err)
	}
	defer r.Close()
	_, _, err = r.RecoverSnapshotters()
	require.NoError(t, err)

	ctx, cancel := context.WithCancel(context.Background())

	evtsc, errs := r.Read(ctx)
	i := 0
	for {
		select {
		case evt := <-evtsc:
			require.NotNil(t, evt)
			require.True(t, evt.Seq > 0)
			i++
			if i == 90 {
				cancel()
				return
			}
		case err := <-errs:
			t.Fatal(t, err)
		}
	}
}

```

`pkg/cap/section/section.go`:

```go
/*
 * Copyright 2020-2021 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package section

import (
	"fmt"
	capver "github.com/rabbitstack/fibratus/pkg/cap/version"
	"github.com/rabbitstack/fibratus/pkg/util/bytes"
)

// Section represents the header describing the type, length and the version of each section.
type Section [10]byte

// String returns the string representation of the cap section.
func (s Section) String() string {
	return fmt.Sprintf("type: %s, version: %d, len: %d, size: %d", s.Type(), s.Version(), s.Len(), s.Size())
}

// New builds a new section block with the specified type, version, optional length and size.
func New(typ Type, ver capver.Version, l, size uint32) Section {
	var s Section
	s[0] = uint8(typ)
	s[1] = uint8(ver)
	copy(s[2:6], bytes.WriteUint32(l))
	copy(s[6:], bytes.WriteUint32(size))
	return s
}

// Read reads the section from the byte slice.
func Read(b []byte) Section {
	var s Section
	copy(s[:], b)
	return s
}

// Type returns the type of this section.
func (s Section) Type() Type { return Type(s[0]) }

// Version returns the version of the capture section block.
func (s Section) Version() capver.Version { return capver.Version(s[1]) }

// Len returns the length of the section.
func (s Section) Len() uint32 { return bytes.ReadUint32(s[2:6]) }

// Size returns the size of the section.
func (s Section) Size() uint32 { return bytes.ReadUint32(s[6:]) }

```

`pkg/cap/section/section_windows.go`:

```go
/*
 * Copyright 2019-2020 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package section

// Type describes the type of the capture section
type Type uint8

const (
	// Process is the process header type
	Process Type = iota + 1
	// Handle is the handle header type
	Handle
	// Event is the event header type
	Event
	// PE is the Portable Executable header type
	PE
)

// String returns the type name.
func (s Type) String() string {
	switch s {
	case Process:
		return "process"
	case Handle:
		return "handle"
	case Event:
		return "event"
	case PE:
		return "pe"
	default:
		return ""
	}
}

```

`pkg/cap/section/section_windows_test.go`:

```go
/*
 * Copyright 2019-2020 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package section

import (
	capver "github.com/rabbitstack/fibratus/pkg/cap/version"
	"github.com/stretchr/testify/assert"
	"testing"
)

func TestSection(t *testing.T) {
	s := New(Process, capver.ProcessSecV1, uint32(2456), uint32(30000))
	assert.Equal(t, Process, s.Type())
	assert.Equal(t, capver.ProcessSecV1, s.Version())
	assert.Equal(t, uint32(2456), s.Len())
	assert.Equal(t, uint32(30000), s.Size())
}

```

`pkg/cap/types_linux.go`:

```go
/*
 * Copyright 2020-2021 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package cap

type Writer interface {
	// Write accepts two channels. The event channel receives events pushed by the event source. When the event
	// is peeked from the channel, it is serialized and written to the underlying byte buffer.
	Write(chan *Event.Event, chan error) chan error
	// Close disposes all resources allocated by the writer.
	Close() error
}

// Reader offers the mechanism for recovering the state of the capture and replaying all captured events.
type Reader interface {
	// Read returns two channels. The event channel is populated with event instances pulled from the cap. If
	// any error occurs during cap processing, it is pushed to the error channel.
	Read(ctx context.Context) (chan *Event.Event, chan error)
	// Close shutdowns the reader gracefully.
	Close() error
	// SetFilter sets the filter that is applied to each event coming out of the capture.
	SetFilter(f filter.Filter)
}

```

`pkg/cap/types_windows.go`:

```go
/*
 * Copyright 2019-2020 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package cap

import (
	"context"
	"github.com/rabbitstack/fibratus/pkg/event"
	"github.com/rabbitstack/fibratus/pkg/filter"
	"github.com/rabbitstack/fibratus/pkg/handle"
	"github.com/rabbitstack/fibratus/pkg/ps"
)

// Writer is the minimal interface that all cap writers need to satisfy. The Windows cap
// file format has the layout as depicted in the following diagram:
//
//	 +-+-+-+-+-+-+-+-++-+-+-+-+-+-+-+-++-+-+-+
//	 | Magic Number  | Major | Minor | Flags |
//		|----------------------------------------
//	 | Handle Section |       Handles        |
//	 -----------------------------------------
//	 | evt Section | evt ..................|
//		| ......................................|
//		| ......................................|
//		| ......................................|
//	 | ........ evt Section n  evt n  EOF  |
//	 +-+-+-+-+-+-+-+-++-+-+-+-+-+-+-+-++-+-+-+
type Writer interface {
	// Write accepts two channels. The event channel receives events pushed by the event consumer.
	// When the event is peeked from the channel, it is serialized and written to the underlying
	// byte buffer.
	Write(<-chan *event.Event, <-chan error) chan error
	// Close disposes all resources allocated by the writer.
	Close() error
}

// Reader offers the mechanism for recovering the state of the capture and replaying all captured events.
type Reader interface {
	// Read returns two channels. The event channel is populated with event instances pulled from the cap. If
	// any error occurs during capture processing, it is pushed to the error channel.
	Read(ctx context.Context) (chan *event.Event, chan error)
	// Close shutdowns the reader gracefully.
	Close() error
	// RecoverSnapshotters recovers the state of the snapshotters from the cap.
	RecoverSnapshotters() (handle.Snapshotter, ps.Snapshotter, error)
	// SetFilter sets the filter applied to each event coming out of the cap.
	SetFilter(f filter.Filter)
}

```

`pkg/cap/version/version_windows.go`:

```go
/*
 * Copyright 2019-2020 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package version

// Version designates the type for specifying the current section version.
type Version uint16

const (
	// EvtSecV1 is the v1 of the event section
	EvtSecV1 Version = iota + 1
	// EvtSecV2 is the v2 of the event section
	EvtSecV2
)

const (
	// ProcessSecV1 is the v1 of the process section
	ProcessSecV1 Version = iota + 1
	// ProcessSecV2 is the v2 of the process section
	ProcessSecV2
	// ProcessSecV3 is the v3 of the process section
	ProcessSecV3
	// ProcessSecV4 is the v4 of the process section
	ProcessSecV4
)

const (
	// HandleSecV1 is the v1 of the handle section
	HandleSecV1 Version = iota + 1
)

const (
	// PESecV1 is the v1 of the PE section
	PESecV1 Version = iota + 1
	// PESecV2 is the v2 of the PE section
	PESecV2
)

```

`pkg/cap/writer.go`:

```go
//go:build cap
// +build cap

/*
 * Copyright 2020-2021 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package cap

import (
	"expvar"
	"fmt"
	"github.com/rabbitstack/fibratus/pkg/cap/section"
	"math"
)

var (
	// ErrWriteMagic signals magic write errors
	ErrWriteMagic = func(err error) error { return fmt.Errorf("couldn't write magic number: %v", err) }
	// ErrWriteVersion signals version write errors
	ErrWriteVersion = func(v string, err error) error { return fmt.Errorf("couldn't write %s cap digit: %v", v, err) }
	// ErrWriteSection signals section write errors
	ErrWriteSection = func(s section.Type, err error) error { return fmt.Errorf("couldn't write %s cap section: %v", s, err) }

	handleWriteErrors = expvar.NewInt("cap.handle.write.errors")
	evtWriteErrors    = expvar.NewInt("cap.evt.write.errors")
	flusherErrors     = expvar.NewMap("cap.flusher.errors")
	overflowEvents    = expvar.NewInt("cap.overflow.events")
	eventSourceErrors = expvar.NewInt("cap.eventsource.errors")
)

const maxKevtSize = math.MaxUint32

```

`pkg/cap/writer_unsupported.go`:

```go
//go:build !cap
// +build !cap

/*
 * Copyright 2019-2020 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package cap

import (
	errs "github.com/rabbitstack/fibratus/pkg/errors"
	"github.com/rabbitstack/fibratus/pkg/handle"
	"github.com/rabbitstack/fibratus/pkg/ps"
)

// NewWriter returns unsupported writer.
func NewWriter(filename string, psnap ps.Snapshotter, hsnap handle.Snapshotter) (Writer, error) {
	return nil, errs.ErrFeatureUnsupported("cap")
}

```

`pkg/cap/writer_windows.go`:

```go
//go:build cap
// +build cap

/*
 * Copyright 2019-2020 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package cap

import (
	"fmt"
	"os"
	"path/filepath"
	"sync"
	"sync/atomic"
	"time"

	"github.com/dustin/go-humanize"
	"github.com/jedib0t/go-pretty/v6/table"
	"github.com/rabbitstack/fibratus/pkg/cap/section"
	capver "github.com/rabbitstack/fibratus/pkg/cap/version"
	"github.com/rabbitstack/fibratus/pkg/event"
	"github.com/rabbitstack/fibratus/pkg/handle"
	"github.com/rabbitstack/fibratus/pkg/ps"
	"github.com/rabbitstack/fibratus/pkg/util/bytes"
	zstd "github.com/valyala/gozstd"
)

type stats struct {
	capFile        string
	evtsWritten    uint64
	bytesWritten   uint64
	handlesWritten uint64
	procsWritten   uint64
}

func (s *stats) incKevts(evt *event.Event) {
	if !evt.Type.OnlyState() {
		atomic.AddUint64(&s.evtsWritten, 1)
	}
}
func (s *stats) incBytes(bytes uint64) { atomic.AddUint64(&s.bytesWritten, bytes) }
func (s *stats) incHandles()           { atomic.AddUint64(&s.handlesWritten, 1) }
func (s *stats) incProcs(evt *event.Event) {
	if evt.IsCreateProcess() || evt.IsProcessRundown() {
		atomic.AddUint64(&s.procsWritten, 1)
	}
}

func (s *stats) printStats() {
	t := table.NewWriter()
	t.SetOutputMirror(os.Stdout)
	t.SetTitle("Capture Statistics")
	t.SetStyle(table.StyleLight)

	t.AppendRow(table.Row{"File", filepath.Base(s.capFile)})
	t.AppendSeparator()

	t.AppendRow(table.Row{"Events written", atomic.LoadUint64(&s.evtsWritten)})
	t.AppendRow(table.Row{"Bytes written", atomic.LoadUint64(&s.bytesWritten)})
	t.AppendRow(table.Row{"Processes written", atomic.LoadUint64(&s.procsWritten)})
	t.AppendRow(table.Row{"Handles written", atomic.LoadUint64(&s.handlesWritten)})

	f, err := os.Stat(s.capFile)
	if err != nil {
		t.Render()
		return
	}
	t.AppendSeparator()
	t.AppendRow(table.Row{"Capture size", humanize.Bytes(uint64(f.Size()))})

	t.Render()
}

type writer struct {
	zw      *zstd.Writer
	f       *os.File
	flusher *time.Ticker
	psnap   ps.Snapshotter
	hsnap   handle.Snapshotter
	stop    chan struct{}
	// stats contains the capture statistics
	stats *stats
	// mu protects the underlying zstd buffer
	mu sync.Mutex
	// released indicates if the zstd buffer is disposed
	released atomic.Bool
}

// NewWriter constructs a new instance of the cap writer.
func NewWriter(filename string, psnap ps.Snapshotter, hsnap handle.Snapshotter) (Writer, error) {
	if filepath.Ext(filename) == "" {
		filename += ".cap"
	}
	f, err := os.Create(filename)
	if err != nil {
		return nil, err
	}
	zw := zstd.NewWriter(f)
	// start by writing the cap header that is composed
	// of magic number, major/minor digits and the optional
	// flags bit vector. The flags bit vector is reserved
	// for the future uses.
	// The header is followed by the handle snapshot.
	// It contains the current state of the system handles
	// at the time the capture was started.
	// Handle snapshots are prepended with a section
	// that describes the version and the number of handles
	// in the snapshot. This information is used by the reader to
	// restore the state of the snapshotters.
	if _, err := zw.Write(bytes.WriteUint64(magic)); err != nil {
		return nil, ErrWriteMagic(err)
	}
	if _, err := zw.Write([]byte{major}); err != nil {
		return nil, ErrWriteVersion("major", err)
	}
	if _, err := zw.Write([]byte{minor}); err != nil {
		return nil, ErrWriteVersion("minor", err)
	}
	if _, err := zw.Write(bytes.WriteUint64(flags)); err != nil {
		return nil, err
	}

	w := &writer{
		zw:      zw,
		f:       f,
		flusher: time.NewTicker(time.Second),
		psnap:   psnap,
		hsnap:   hsnap,
		stop:    make(chan struct{}),
		stats:   &stats{capFile: filename},
	}

	if err := w.writeSnapshots(); err != nil {
		return nil, err
	}

	go w.flush()

	return w, nil
}

func (w *writer) writeSnapshots() error {
	handles := w.hsnap.GetSnapshot()
	// write handle section and the data blocks
	err := w.ws(section.Handle, capver.HandleSecV1, uint32(len(handles)), 0)
	if err != nil {
		return err
	}

	writeHandle := func(buf []byte) error {
		l := bytes.WriteUint16(uint16(len(buf)))
		if _, err := w.zw.Write(l); err != nil {
			return err
		}
		if _, err := w.zw.Write(buf); err != nil {
			return err
		}
		return nil
	}

	for _, khandle := range handles {
		if err := writeHandle(khandle.Marshal()); err != nil {
			handleWriteErrors.Add(1)
			continue
		}
		w.stats.incHandles()
	}
	return w.zw.Flush()
}

func (w *writer) Write(evtsc <-chan *event.Event, errs <-chan error) chan error {
	errsc := make(chan error, 100)
	go func() {
		for {
			select {
			case evt := <-evtsc:
				b := evt.MarshalRaw()
				l := len(b)
				if l == 0 {
					continue
				}
				// write event buffer
				err := w.write(b)
				if err != nil {
					errsc <- err
					continue
				}
				// update stats
				w.stats.incKevts(evt)
				w.stats.incBytes(uint64(l))
				w.stats.incProcs(evt)
			case err := <-errs:
				errsc <- err
				eventSourceErrors.Add(1)
			case <-w.stop:
				return
			}
		}
	}()
	return errsc
}

func (w *writer) write(b []byte) error {
	w.mu.Lock()
	defer w.mu.Unlock()
	l := len(b)
	if l > maxKevtSize {
		overflowEvents.Add(1)
		return fmt.Errorf("event size overflow by %d bytes", l-maxKevtSize)
	}
	if err := w.ws(section.Event, capver.EvtSecV2, 0, uint32(l)); err != nil {
		evtWriteErrors.Add(1)
		return err
	}
	if _, err := w.zw.Write(b); err != nil {
		evtWriteErrors.Add(1)
		return err
	}
	return nil
}

func (w *writer) Close() error {
	w.stats.printStats()

	close(w.stop)

	w.flusher.Stop()
	w.mu.Lock()
	defer w.mu.Unlock()

	if w.zw != nil {
		if err := w.zw.Close(); err != nil {
			return err
		}
		w.zw.Release()
		w.released.Store(true)
	}
	if w.f != nil {
		return w.f.Close()
	}
	return nil
}

func (w *writer) flush() {
	for {
		select {
		case <-w.flusher.C:
			if w.released.Load() {
				return
			}
			w.mu.Lock()
			err := w.zw.Flush()
			w.mu.Unlock()
			if err != nil {
				flusherErrors.Add(err.Error(), 1)
			}
		case <-w.stop:
			return
		}
	}
}

```

`pkg/cap/writer_windows_test.go`:

```go
//go:build cap
// +build cap

/*
 * Copyright 2019-2020 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package cap

import (
	"github.com/rabbitstack/fibratus/internal/etw"
	"github.com/rabbitstack/fibratus/pkg/config"
	"github.com/rabbitstack/fibratus/pkg/event"
	"github.com/rabbitstack/fibratus/pkg/event/params"
	"github.com/rabbitstack/fibratus/pkg/handle"
	htypes "github.com/rabbitstack/fibratus/pkg/handle/types"
	"github.com/rabbitstack/fibratus/pkg/ps"
	pstypes "github.com/rabbitstack/fibratus/pkg/ps/types"
	log "github.com/sirupsen/logrus"
	"github.com/stretchr/testify/require"
	"golang.org/x/sys/windows"
	"testing"
	"time"
)

func TestWrite(t *testing.T) {
	psnap := new(ps.SnapshotterMock)
	hsnap := new(handle.SnapshotterMock)
	log.SetLevel(log.DebugLevel)

	procs := []*pstypes.PS{
		{PID: 8390, Ppid: 1096, Name: "spotify.exe", Exe: `C:\Users\admin\AppData\Roaming\Spotify\Spotify.exe`, Cmdline: `C:\Users\admin\AppData\Roaming\Spotify\Spotify.exe --type=crashpad-handler /prefetch:7 --max-uploads=5 --max-db-size=20 --max-db-age=5 --monitor-self-annotation=ptype=crashpad-handler "--metrics-dir=C:\Users\admin\AppData\Local\Spotify\User Data" --url=https://crashdump.spotify.com:443/ --annotation=platform=win32 --annotation=product=spotify --annotation=version=1.1.4.197 --initial-client-data=0x5a4,0x5a0,0x5a8,0x59c,0x5ac,0x6edcbf60,0x6edcbf70,0x6edcbf7c`, Cwd: `C:\Users\admin\AppData\Roaming\Spotify`, SID: "admin\\SYSTEM"},
		{PID: 2436, Ppid: 6304, Name: "firefox.exe", Exe: `C:\Program Files\Mozilla Firefox\firefox.exe`, Cmdline: `C:\Program Files\Mozilla Firefox\firefox.exe" -contentproc --channel="6304.3.1055809391\1014207667" -childID 1 -isForBrowser -prefsHandle 2584 -prefMapHandle 2580 -prefsLen 70 -prefMapSize 216993 -parentBuildID 20200107212822 -greomni "C:\Program Files\Mozilla Firefox\omni.ja" -appomni "C:\Program Files\Mozilla Firefox\browser\omni.ja" -appdir "C:\Program Files\Mozilla Firefox\browser" - 6304 "\\.\pipe\gecko-crash-server-pipe.6304" 2596 tab`, Cwd: `C:\Program Files\Mozilla Firefox\`, SID: "archrabbit\\SYSTEM"},
	}

	handles := []htypes.Handle{
		{Pid: 8390, Name: "C:\\Windows", Type: "File"},
		{Pid: 8390, Name: "C:\\Windows\\System32", Type: "File"},
	}

	psnap.On("GetSnapshot").Return(procs)
	psnap.On("Size").Return(len(procs))

	hsnap.On("GetSnapshot").Return(handles)

	w, err := NewWriter("_fixtures/cap.cap", psnap, hsnap)
	require.NoError(t, err)
	require.NotNil(t, w)

	evtsc := make(chan *event.Event, 100)
	errs := make(chan error, 10)

	for i := 0; i < 100; i++ {
		evt := &event.Event{
			Type:        event.CreateFile,
			Tid:         2484,
			PID:         859,
			CPU:         uint8(i / 2),
			Seq:         uint64(i + 1),
			Name:        "CreateFile",
			Timestamp:   time.Now(),
			Category:    event.File,
			Host:        "archrabbit",
			Description: "Creates or opens a new file, directory, I/O device, pipe, console",
			Params: event.Params{
				params.FileObject:    {Name: params.FileObject, Type: params.Uint64, Value: uint64(12456738026482168384)},
				params.FilePath:      {Name: params.FilePath, Type: params.UnicodeString, Value: "\\Device\\HarddiskVolume2\\Windows\\system32\\user32.dll"},
				params.FileType:      {Name: params.FileType, Type: params.AnsiString, Value: "file"},
				params.FileOperation: {Name: params.FileOperation, Type: params.AnsiString, Value: "open"},
			},
			Metadata: map[event.MetadataKey]any{"foo": "bar", "fooz": "barz"},
			PS: &pstypes.PS{
				PID:       2436,
				Ppid:      6304,
				Name:      "firefox.exe",
				Exe:       `C:\Program Files\Mozilla Firefox\firefox.exe`,
				Cmdline:   `C:\Program Files\Mozilla Firefox\firefox.exe -contentproc --channel="6304.3.1055809391\1014207667" -childID 1 -isForBrowser -prefsHandle 2584 -prefMapHandle 2580 -prefsLen 70 -prefMapSize 216993 -parentBuildID 20200107212822 -greomni "C:\Program Files\Mozilla Firefox\omni.ja" -appomni "C:\Program Files\Mozilla Firefox\browser\omni.ja" -appdir "C:\Program Files\Mozilla Firefox\browser" - 6304 "\\.\pipe\gecko-crash-server-pipe.6304" 2596 tab`,
				Cwd:       `C:\Program Files\Mozilla Firefox\`,
				SID:       "S-1-15-2",
				Args:      []string{"-contentproc", `--channel="6304.3.1055809391\1014207667`, "-childID", "1", "-isForBrowser", "-prefsHandle", "2584", "-prefMapHandle", "2580", "-prefsLen", "70", "-prefMapSize", "216993", "-parentBuildID"},
				SessionID: 4,
				Envs:      map[string]string{"ProgramData": "C:\\ProgramData", "COMPUTRENAME": "archrabbit"},
				Handles: []htypes.Handle{
					{
						Num:    windows.Handle(0xffffd105e9baaf70),
						Name:   `\REGISTRY\MACHINE\SYSTEM\ControlSet001\Services\Tcpip\Parameters\Interfaces\{b677c565-6ca5-45d3-b618-736b4e09b036}`,
						Type:   "Key",
						Object: 777488883434455544,
						Pid:    uint32(1023),
					},
					{
						Num:    windows.Handle(0xe1ffd105e9baaf70),
						Type:   "Event",
						Object: 777488883434455544,
						Pid:    uint32(1023),
					},
					{
						Type: "Event",
					},
					{
						Num:  windows.Handle(0xe1ecd105e9baaf70),
						Type: "Event",
						Pid:  uint32(1023),
					},
					{
						Num:  windows.Handle(0xffffd105e9adaf70),
						Name: `\RPC Control\OLEA61B27E13E028C4EA6C286932E80`,
						Type: "ALPC Port",
						Pid:  uint32(1023),
						MD: &htypes.AlpcPortInfo{
							Seqno:   1,
							Context: 0x0,
							Flags:   0x0,
						},
						Object: 457488883434455544,
					},
					{
						Num:  windows.Handle(0xeaffd105e9adaf30),
						Name: `C:\Users\bunny`,
						Type: "File",
						Pid:  uint32(1023),
						MD: &htypes.FileInfo{
							IsDirectory: true,
						},
						Object: 357488883434455544,
					},
				},
			},
		}
		if i%2 == 0 {
			evt.PS.Handles = append(evt.PS.Handles, htypes.Handle{})
		}
		evtsc <- evt
	}

	werrs := w.Write(evtsc, errs)
	quit := make(chan struct{}, 1)
	time.AfterFunc(time.Second*5, func() {
		quit <- struct{}{}
	})
	select {
	case err := <-werrs:
		t.Fatal(err)
	case <-quit:
		w.Close()
		require.True(t, w.(*writer).stats.evtsWritten > 0)
		return
	}
}

func TestLiveCapture(t *testing.T) {
	t.SkipNow()
	cfg := &config.Config{
		EventSource: config.EventSourceConfig{
			EnableFileIOEvents:   true,
			EnableImageEvents:    true,
			EnableRegistryEvents: true,
			EnableNetEvents:      true,
			EnableThreadEvents:   true,
			EnableHandleEvents:   true,
		},
		CapFile:            "../../test.cap",
		Filters:            &config.Filters{},
		InitHandleSnapshot: true,
	}
	wait := make(chan struct{}, 1)
	cb := func(total uint64, withName uint64) {
		wait <- struct{}{}
	}
	hsnap := handle.NewSnapshotter(cfg, cb)
	psnap := ps.NewSnapshotter(hsnap, cfg)

	<-wait

	evs := etw.NewEventSource(psnap, hsnap, cfg, nil)
	err := evs.Open(cfg)
	if err != nil {
		t.Fatal(err)
	}

	// bootstrap cap writer with inbound event channel
	writer, err := NewWriter(cfg.CapFile, psnap, hsnap)
	if err != nil {
		t.Fatal(err)
	}
	writer.Write(evs.Events(), evs.Errors())

	// capture for a minute
	<-time.After(time.Minute)

	writer.Close()

	_ = evs.Close()
}

```

`pkg/config/_fixtures/eventlog-output.yml`:

```yml
kstream:
  max-buffers: 10
  min-buffers: 8
  flush-interval: 1s
  blacklist:
    events:
      - CreateThread

filament: top_hives_io

output:
  console:
    enabled: false
    format: pretty
  elasticsearch:
  eventlog:
    enabled: true
    level: INFO

```

`pkg/config/_fixtures/fibratus.json`:

```json
{
  "aggregator": {
    "flush-period": "230ms",
    "flush-timeout": "8s"
  },

  "alertsenders": {
    "mail": {
      "enabled": false
    },

    "slack": {
      "enabled": false
    }
  },

  "api": {
    "transport": "localhost:8090",
    "timeout": "5s"
  },

  "debug-privilege": true,

  "filament": {
    "name": "",
    "flush-period": "200ms"
  },

  "handle": {
    "init-snapshot": true
  },

  "event": {

  },

  "cap": {

  },

  "eventsource": {},
  "logging": {},
  "output": {
    "console": {
      "enabled": true,
      "format": "pretty",
      "kv-delimiter": "->"
    }
  },
  "pe": {},
  "transformers": {},
  "yara": {}
}
```

`pkg/config/_fixtures/fibratus.yml`:

```yml
###################### Fibratus Configuration File #####################################

# =============================== Aggregator ==========================================

# Aggregator is responsible for creating event batches, applying transformers to each event
# present in the batch, and forwarding those batches to the output sinks.
aggregator:
  # Determines the flush period that triggers the flushing of the event batches to output sinks.
  flush-period: 230ms

  # Represents the max time to wait before announcing failed flushing of enqueued events when fibratus
  # is stopped.
  flush-timeout: 8s

# =============================== Alert senders ========================================

# Alert senders deal with emitting alerts via different channels.
alertsenders:
  # Systray sender sends alerts as notifications to the taskbar status area.
  systray:
    # Enables/disables systray alert sender
    enabled: true

    # Indicates if the associated sound is played when the balloon notification is shown
    sound: true

    # Instructs not to display the balloon notification if the current user is in quiet time.
    # During this time, most notifications should not be sent or shown. This lets a user become
    # accustomed to a new computer system without those distractions. Quiet time also occurs for
    # each user after an operating system upgrade or clean installation.
    quiet-mode: false

  # Mail sender transports the alerts via SMTP protocol.
  mail:
    # Enables/disables mail alert sender.
    enabled: true

    # Represents the host of the SMTP server.
    host: smtp.gmail.com

    # Represents the port of the SMTP server.
    port: 587

    # Specifies the username when authenticating to the SMTP server.
    user: bunny

    # Specifies the password when authenticating to the SMTP server.
    password: changeit

    # Specifies the sender's address.
    from: bunny@gmail.com

    # Specifies all the recipients that'll receive the alert.
    to:
      - bunny@gmail.com
      - rabbit@gmail.com
      - cuniculus@gmail.com

  # Slack sender transports the alerts to the Slack workspace.
  slack:
    # Enables/disables Slack alert sender.
    enabled: true

    # Represents the Webhook URL of the workspace where alerts will be dispatched.
    url: https://fibratus/232sfghagjhfasr

    # Designates the Slack workspace where alerts will be routed.
    workspace: fibratus

    # Is the slack channel in which to post alerts.
    channel: fibratus

    # Represents the emoji icon surrounded in ':' characters for the Slack bot.
    #emoji: ""

# =============================== API ==================================================

# Settings that influence the behaviour of the HTTP server that exposes a number of endpoints such as
# expvar metrics, internal state, and so on.
api:
  # Specifies the underlying transport protocol for the API HTTP server. The transport can either be the
  # named pipe or TCP socket. Default is named pipe but you can override it to expose theAPI server on
  # TCP address, e.g. 192.168.1.32:8084.
  transport: npipe:///fibratus

  # Represents the timeout interval for the HTTP server responses.
  timeout: 5s

# =============================== General ==============================================

# Indicates whether debug privilege is set in Fibratus process' token. Enabling this security policy allows
# Fibratus to obtain handles of protected processes for the purpose of querying the Process Environment Block
# regions.
debug-privilege: true

# =============================== Filament =============================================

# Filaments are lightweight Python scriplets that are executed on top of the kernel event stream. You can easily
# extend Fibratus with custom features that is encapsulated in filaments. This section controls the behaviour of
# the filament engine.
filament:
  # Specifies the name of the filament that is executed with the run command.
  name: top_netio

  # The directory where all filaments are located. By default, they are stored within the fibratus program
  # files directory.
  path: $(PROGRAMFILES)/fibratus/filaments

  flush-period: 300ms

# =============================== Handle ===============================================

# Indicates whether initial handle snapshot is taken.
handle:
  init-snapshot: true

# =============================== Kcap =================================================

cap:
  file: ""

# =============================== Event ===============================================

event:
  serialize-threads: false
  serialize-images: false
  serialize-handles: false
  serialize-pe: false

# =============================== Kstream ==============================================

eventsource:
  max-buffers: 2
  min-buffers: 1
  flush-interval: 1s
  blacklist:
    events:
      - CreateThread
      - CreateHandle
      - CloseHandle
    images:
      - System


# =============================== Logging ================================================

logging:
  level: info
  # max-age:
  # max-backups:
  # max-size:
  # formatter:
  # path:
  # log-stdout: false


# =============================== Output ================================================

output:
  console:
    enabled: false
    format: json
    template: ""


  elasticsearch:
    enabled: false
    servers:
      - http://localhost:9200
    timeout: 5s

  amqp:
    enabled: true
    url: amqp://localhost:5672
    timeout: 5s
    exchange-type: topic
    routing-key: fibratus
    vhost: /

  http:
    enabled: false
    endpoints:
      - http://localhost:8081
    timeout: 5s
    method: POST

# =============================== Portable Executable (PE) =============================

pe:
  enabled: false
  read-resources: true
  read-symbols: true
  read-sections: false

# =============================== Transformers =========================================

transformers:
  remove:
    enabled: true
    params:
      - disposition
  rename:
    enabled: true
    params:
      - old: "a"
        new: "b"
      - old: "c"
        new: "d"
  replace:
    enabled: false
    replacements:
      - param: key_name
        old: HKEY_CURRENT_USER
        new: HCU
  tags:
    enabled: false
    tags:
      - key: foo
        value: bar
  trim:
    enabled: false
    prefixes:
      - param: key_name
        trim: CurrentControlSet
    suffixes:
      - param: file_name
        trim: .exe

# =============================== YARA =================================================

yara:
  enabled: true
  rule:
    paths:
      - path: "C:\\yara-rules"
        namespace: default
    strings:
      - string: "rule test : tag1 { meta: author = \"Hilko Bengen\" strings: $a = \"abc\" fullword condition: $a }"
        namespace: default
  alert-template: ""
  fastscan: true
  scan-timeout: 20s
  skip-files: true
  skip-mmaps: false
  skip-allocs: false
  skip-registry: false
  excluded-files:
    - kernel32.dll
  excluded-procs:
    - system
    - spotify.exe

```

`pkg/config/_fixtures/filters/default-with-template.yml`:

```yml
name: only network category
id: d6385b50-532a-4464-929a-044f21443dd3
version: 1.0.0
enabled: true
description: this rule matches all network signals
condition: evt.category = 'net'
severity: low
output: >
  {{ upper "all network events" }}
action:
  - name: kill
min-engine-version: 2.0.0
tags:
  - TE

```

`pkg/config/_fixtures/filters/default.yml`:

```yml
name: only network category
id: 313933e7-8eb9-45d9-81af-0305fee70e29
version: 1.0.0
enabled: true
description: this rule matches all network signals
condition: evt.category = 'net'
severity: low
output: >
  `%ps.exe` attempted to reach out to `%net.sip` IP address
action:
- name: kill
- name: isolate
  whitelist:
    - 127.0.0.1
    - 8.8.8.8
min-engine-version: 2.0.0
tags:
  - TE
references:
  - ref1
  - ref2
notes: |
  Lorem ipsum dolor sit amet, consectetur adipiscing elit.
  Ut ut ante id ligula molestie varius. Duis efficitur eros
  quis turpis accumsan, nec scelerisque libero euismod.
authors:
  - rabbitstack
  - skynova

```

`pkg/config/_fixtures/filters/default1.yml`:

```yml
name: suspicious network {{ upper "activity" }}
id: 1a06b6e0-a3f4-44a0-a1f0-89028273761b
version: 1.1.0
condition: evt.category = 'net' and ps.name in ('at.exe', 'java.exe')
min-engine-version: 2.0.0

```

`pkg/config/_fixtures/http-output.yml`:

```yml
eventsource:
  max-buffers: 10
  min-buffers: 8
  flush-interval: 1s
  blacklist:
    events:
      - CreateThread

filament: top_hives_io

output:
  console:
    enabled: false
    format: pretty
  elasticsearch:
  http:
    enabled: true
    endpoints:
      - http://localhost:8081
      - http://localhost:8082
    timeout: 2s
    proxy-url: http://192.168.1.8:3123
    proxy-username: bunny
    proxy-password: bunny
    username: basic
    password: basic
    enable-gzip: true
    headers:
      api-Key: kkvvkk
      header2: value2

```

`pkg/config/_fixtures/output.yml`:

```yml
eventsource:
  max-buffers: 10
  min-buffers: 8
  flush-interval: 1s
  blacklist:
    events:
      - CreateThread

filament: top_hives_io

output:
  console:
    enabled: false
    format: pretty
  elasticsearch:
  amqp:
    enabled: true
    url: amqp://localhost:5672
    timeout: 5s
    exchange: fibratus
    exchange-type: topic
    routing-key: fibratus


```

`pkg/config/_fixtures/transformers.yml`:

```yml
eventsource:
  max-buffers: 10
  min-buffers: 8
  flush-interval: 1s
  blacklist:
    events:
      - CreateThread

filament: top_hives_io

output.console:
  format: pretty

transformers.tags:
  enabled: true
  tags:
    - key: 1
      value: k

transformers.remove:
  enabled: true
  params:
    - key_handle

transformers.rename:
  enabled: true
  params:
    - old: key_handle
      new: KeyHandle
```

`pkg/config/alertsender.go`:

```go
/*
 * Copyright 2019-2020 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package config

import (
	"errors"
	"fmt"
	"github.com/rabbitstack/fibratus/pkg/alertsender"
	"github.com/rabbitstack/fibratus/pkg/alertsender/eventlog"
	"github.com/rabbitstack/fibratus/pkg/alertsender/mail"
	"github.com/rabbitstack/fibratus/pkg/alertsender/slack"
	"github.com/rabbitstack/fibratus/pkg/alertsender/systray"
	"reflect"
)

var errNoAlertsendersSection = errors.New("no alertsenders section in config")

var errAlertsenderConfig = func(sender string, err error) error {
	return fmt.Errorf("%s alert sender invalid config: %v", sender, err)
}

func (c *Config) tryLoadAlertSenders() error {
	if c.ForwardMode || c.IsCaptureSet() {
		// In event forwarding mode or capture control, alert senders are useless
		return nil
	}

	configs := make([]alertsender.Config, 0)
	alertsenders := c.viper.AllSettings()["alertsenders"]
	if alertsenders == nil {
		return errNoAlertsendersSection
	}

	mapping, ok := alertsenders.(map[string]interface{})
	if !ok {
		return fmt.Errorf("expected map[string]interface{} type for alertsenders but found %s", reflect.TypeOf(alertsenders))
	}

	for typ, config := range mapping {
		switch typ {
		case "mail":
			var mailConfig mail.Config
			if err := decode(config, &mailConfig); err != nil {
				return errAlertsenderConfig(typ, err)
			}
			if !mailConfig.Enabled {
				continue
			}
			config := alertsender.Config{
				Type:   alertsender.Mail,
				Sender: mailConfig,
			}
			configs = append(configs, config)
		case "slack":
			var slackConfig slack.Config
			if err := decode(config, &slackConfig); err != nil {
				return errAlertsenderConfig(typ, err)
			}
			if !slackConfig.Enabled {
				continue
			}
			config := alertsender.Config{
				Type:   alertsender.Slack,
				Sender: slackConfig,
			}
			configs = append(configs, config)
		case "systray":
			var systrayConfig systray.Config
			if err := decode(config, &systrayConfig); err != nil {
				return errAlertsenderConfig(typ, err)
			}
			if !systrayConfig.Enabled {
				continue
			}
			config := alertsender.Config{
				Type:   alertsender.Systray,
				Sender: systrayConfig,
			}
			configs = append(configs, config)

		case "eventlog":
			var eventlogConfig eventlog.Config
			if err := decode(config, &eventlogConfig); err != nil {
				return errAlertsenderConfig(typ, err)
			}
			if !eventlogConfig.Enabled {
				continue
			}
			config := alertsender.Config{
				Type:   alertsender.Eventlog,
				Sender: eventlogConfig,
			}
			configs = append(configs, config)
		}
	}

	c.Alertsenders = configs

	return nil
}

```

`pkg/config/api.go`:

```go
/*
 * Copyright 2019-2020 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package config

import (
	"github.com/spf13/viper"
	"time"
)

const (
	transport = "api.transport"
	timeout   = "api.timeout"
)

// APIConfig contains API specific config options.
type APIConfig struct {
	// Transport specifies the underlying transport protocol for the API HTTP server.
	Transport string `json:"api.transport" yaml:"api.transport"`
	// Timeout determines the timeout for the API server responses
	Timeout time.Duration `json:"api.timeout" yaml:"api.timeout"`
}

// initFromViper initializes API configuration from Viper.
func (c *APIConfig) initFromViper(v *viper.Viper) {
	c.Transport = v.GetString(transport)
	c.Timeout = v.GetDuration(timeout)
}

```

`pkg/config/config.schema.json`:

```json
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "definitions": {
    "yara": {
      "$id": "#yara",
      "type": "object",
      "properties": {
        "enabled": {
          "type": "boolean"
        }
      }
    }
  },
  "type": "object",
  "properties": {
    "aggregator": {
      "type": "object",
      "properties": {
        "flush-period": {
          "type": "string",
          "minLength": 2,
          "pattern": "[0-9]+ms|s"
        },
        "flush-timeout": {
          "type": "string",
          "minLength": 2,
          "pattern": "[0-9]+s"
        }
      },
      "additionalProperties": false
    },
    "alertsenders": {
      "type": "object",
      "anyOf": [
        {
          "properties": {
            "mail": {
              "type": "object",
              "properties": {
                "enabled": {
                  "type": "boolean"
                },
                "host": {
                  "type": "string"
                },
                "port": {
                  "type": "number"
                },
                "user": {
                  "type": "string"
                },
                "password": {
                  "type": "string"
                },
                "from": {
                  "type": "string"
                },
                "to": {
                  "type": "array",
                  "items": {
                    "type": "string",
                    "format": "email"
                  }
                },
                "content-type": {
                  "type": "string"
                },
                "use-template": {
                  "type": "boolean"
                }
              },
              "if": {
                "properties": {
                  "enabled": {
                    "const": true
                  }
                }
              },
              "then": {
                "properties": {
                  "from": {
                    "type": "string",
                    "format": "email"
                  },
                  "to": {
                    "type": "array",
                    "minItems": 1,
                    "items": {
                      "type": "string",
                      "format": "email"
                    }
                  }
                }
              },
              "additionalProperties": false
            },
            "slack": {
              "type": "object",
              "properties": {
                "enabled": {
                  "type": "boolean"
                },
                "url": {
                  "type": "string"
                },
                "workspace": {
                  "type": "string"
                },
                "channel": {
                  "type": "string"
                },
                "emoji": {
                  "type": "string"
                }
              },
              "if": {
                "properties": {
                  "enabled": {
                    "const": true
                  }
                }
              },
              "then": {
                "properties": {
                  "url": {
                    "type": "string",
                    "format": "uri",
                    "minLength": 1,
                    "pattern": "^(https?|http?)://"
                  }
                }
              },
              "additionalProperties": false
            },
            "systray": {
              "type": "object",
              "properties": {
                "enabled": {
                  "type": "boolean"
                },
                "sound": {
                  "type": "boolean"
                },
                "quiet-mode": {
                  "type": "boolean"
                }
              },
              "additionalProperties": false
            },
            "eventlog": {
              "type": "object",
              "properties": {
                "enabled": {
                  "type": "boolean"
                },
                "verbose": {
                  "type": "boolean"
                },
                "format": {
                  "type": "string",
                  "enum": ["pretty", "json"]
                }
              },
              "additionalProperties": false
            }
          },
          "additionalProperties": false
        }
      ]
    },
    "api": {
      "type": "object",
      "properties": {
        "transport": {
          "type": "string",
          "minLength": 3
        },
        "timeout": {
          "type": "string",
          "minLength": 2,
          "pattern": "[0-9]+s"
        }
      },
      "additionalProperties": false
    },
    "config-file": {
      "type": "string"
    },
    "debug-privilege": {
      "type": "boolean"
    },
    "forward": {
      "type": "boolean"
    },
    "symbol-paths": {
      "type": "string"
    },
    "symbolize-kernel-addresses": {
      "type": "boolean"
    },
    "handle": {
      "type": "object",
      "properties": {
        "init-snapshot": {
          "type": "boolean"
        },
        "enumerate-handles": {
          "type": "boolean"
        }
      },
      "additionalProperties": false
    },
    "cap": {
      "type": "object",
      "properties": {
        "file": {
          "type": "string"
        }
      },
      "additionalProperties": false
    },
    "filament": {
      "type": "object",
      "properties": {
        "name": {
          "type": "string"
        },
        "path": {
          "type": "string"
        },
        "flush-period": {
          "type": "string",
          "minLength": 2,
          "pattern": "[0-9]+ms|s"
        }
      },
      "additionalProperties": false
    },
    "filters": {
      "type": "object",
      "properties": {
        "match-all": {
          "type": "boolean"
        },
        "rules": {
          "type": "object",
          "properties": {
            "enabled": {
              "type": "boolean"
            },
            "from-paths": {
              "type": [
                "array",
                "null"
              ],
              "items": [
                {
                  "type": "string",
                  "minLength": 4
                }
              ]
            },
            "from-urls": {
              "type": [
                "array",
                "null"
              ],
              "items": [
                {
                  "type": "string",
                  "minLength": 8
                }
              ]
            }
          },
          "additionalProperties": false
        },
        "macros": {
          "type": "object",
          "properties": {
            "from-paths": {
              "type": [
                "array",
                "null"
              ],
              "items": [
                {
                  "type": "string",
                  "minLength": 4
                }
              ]
            }
          },
          "additionalProperties": false
        }
      },
      "additionalProperties": false
    },
    "evasion": {
      "type": "object",
      "properties": {
        "enabled": {
          "type": "boolean"
        },
        "enable-direct-syscall": {
          "type": "boolean"
        },
        "enable-indirect-syscall": {
          "type": "boolean"
        }
      },
      "additionalProperties": false
    },
    "event": {
      "type": "object",
      "properties": {
        "serialize-threads": {
          "type": "boolean"
        },
        "serialize-images": {
          "type": "boolean"
        },
        "serialize-handles": {
          "type": "boolean"
        },
        "serialize-pe": {
          "type": "boolean"
        },
        "serialize-envs": {
          "type": "boolean"
        }
      },
      "additionalProperties": false
    },
    "eventsource": {
      "type": "object",
      "properties": {
        "enable-thread": {
          "type": "boolean"
        },
        "enable-image": {
          "type": "boolean"
        },
        "enable-registry": {
          "type": "boolean"
        },
        "enable-fileio": {
          "type": "boolean"
        },
        "enable-vamap": {
          "type": "boolean"
        },
        "enable-handle": {
          "type": "boolean"
        },
        "enable-net": {
          "type": "boolean"
        },
        "enable-mem": {
          "type": "boolean"
        },
        "enable-audit-api": {
          "type": "boolean"
        },
        "enable-dns": {
          "type": "boolean"
        },
        "enable-threadpool": {
          "type": "boolean"
        },
        "stack-enrichment": {
          "type": "boolean"
        },
        "min-buffers": {
          "type": "integer",
          "minimum": 1
        },
        "max-buffers": {
          "type": "integer",
          "minimum": 2
        },
        "buffer-size": {
          "type": "integer"
        },
        "flush-interval": {
          "type": "string",
          "minLength": 2,
          "pattern": "[0-9]+s"
        },
        "blacklist": {
          "type": "object",
          "properties": {
            "events": {
              "type": "array",
              "items": {
                "type": "string",
                "enum": [
                  "CreateThread",
                  "TerminateThread",
                  "OpenProcess",
                  "OpenThread",
                  "SetThreadContext",
                  "LoadImage",
                  "UnloadImage",
                  "CreateFile",
                  "CloseFile",
                  "ReadFile",
                  "WriteFile",
                  "DeleteFile",
                  "RenameFile",
                  "SetFileInformation",
                  "EnumDirectory",
                  "MapViewFile",
                  "UnmapViewFile",
                  "RegCreateKey",
                  "RegOpenKey",
                  "RegSetValue",
                  "RegQueryValue",
                  "RegQueryKey",
                  "RegDeleteKey",
                  "RegDeleteValue",
                  "RegCloseKey",
                  "Accept",
                  "Send",
                  "Recv",
                  "Connect",
                  "Disconnect",
                  "Reconnect",
                  "Retransmit",
                  "CreateHandle",
                  "CloseHandle",
                  "DuplicateHandle",
                  "QueryDns",
                  "ReplyDns",
                  "VirtualAlloc",
                  "VirtualFree",
                  "CreateSymbolicLinkObject",
                  "SubmitThreadpoolWork",
                  "SubmitThreadpoolCallback",
                  "SetThreadpoolTimer"
                ]
              }
            },
            "images": {
              "type": "array",
              "items": {
                "type": "string",
                "minLength": 1
              }
            }
          },
          "additionalProperties": false
        }
      },
      "additionalProperties": false
    },
    "logging": {
      "type": "object",
      "properties": {
        "level": {
          "type": "string"
        },
        "max-age": {
          "type": "integer"
        },
        "max-backups": {
          "type": "integer",
          "minimum": 1
        },
        "max-size": {
          "type": "integer",
          "minimum": 1
        },
        "formatter": {
          "type": "string",
          "enum": [
            "json",
            "text"
          ]
        },
        "path": {
          "type": "string"
        },
        "log-stdout": {
          "type": "boolean"
        }
      },
      "additionalProperties": false
    },
    "output": {
      "type": "object",
      "anyOf": [
        {
          "properties": {
            "console": {
              "type": "object",
              "properties": {
                "enabled": {
                  "type": "boolean"
                },
                "format": {
                  "type": "string",
                  "enum": [
                    "json",
                    "pretty"
                  ]
                },
                "template": {
                  "type": "string"
                },
                "kv-delimiter": {
                  "type": "string"
                }
              },
              "additionalProperties": false
            },
            "elasticsearch": {
              "type": "object",
              "properties": {
                "enabled": {
                  "type": "boolean"
                },
                "servers": {
                  "type": "array",
                  "items": [
                    {
                      "type": "string",
                      "minItems": 1,
                      "format": "uri",
                      "minLength": 1,
                      "maxLength": 255,
                      "pattern": "^(https?|http?)://"
                    }
                  ]
                },
                "timeout": {
                  "type": "string"
                },
                "index-name": {
                  "type": "string",
                  "minLength": 1
                },
                "template-config": {
                  "type": "string"
                },
                "template-name": {
                  "type": "string",
                  "minLength": 1
                },
                "healthcheck": {
                  "type": "boolean"
                },
                "bulk-workers": {
                  "type": "integer",
                  "minimum": 1
                },
                "sniff": {
                  "type": "boolean"
                },
                "trace-log": {
                  "type": "boolean"
                },
                "gzip-compression": {
                  "type": "boolean"
                },
                "healthcheck-interval": {
                  "type": "string",
                  "minLength": 2,
                  "pattern": "[0-9]+s|m}"
                },
                "healthcheck-timeout": {
                  "type": "string",
                  "minLength": 2,
                  "pattern": "[0-9]+s|m}"
                },
                "flush-period": {
                  "type": "string",
                  "minLength": 2,
                  "pattern": "[0-9]+s|m}"
                },
                "username": {
                  "type": "string"
                },
                "password": {
                  "type": "string"
                },
                "tls-key": {
                  "type": "string"
                },
                "tls-cert": {
                  "type": "string"
                },
                "tls-ca": {
                  "type": "string"
                },
                "tls-insecure-skip-verify": {
                  "type": "boolean"
                }
              },
              "additionalProperties": false
            },
            "amqp": {
              "type": "object",
              "properties": {
                "enabled": {
                  "type": "boolean"
                },
                "url": {
                  "type": "string",
                  "format": "uri",
                  "minLength": 1,
                  "maxLength": 255,
                  "pattern": "^(amqps?|amqp?)://"
                },
                "timeout": {
                  "type": "string",
                  "minLength": 2,
                  "pattern": "[0-9]+s|m}"
                },
                "exchange": {
                  "type": "string",
                  "minLength": 1
                },
                "exchange-type": {
                  "type": "string",
                  "enum": [
                    "direct",
                    "topic",
                    "fanout",
                    "header",
                    "x-consistent-hash"
                  ]
                },
                "routing-key": {
                  "type": "string",
                  "minLength": 1
                },
                "delivery-mode": {
                  "type": "string",
                  "enum": [
                    "transient",
                    "persistent"
                  ]
                },
                "vhost": {
                  "type": "string",
                  "minLength": 1
                },
                "passive": {
                  "type": "boolean"
                },
                "durable": {
                  "type": "boolean"
                },
                "username": {
                  "type": "string"
                },
                "password": {
                  "type": "string"
                },
                "tls-key": {
                  "type": "string"
                },
                "tls-cert": {
                  "type": "string"
                },
                "tls-ca": {
                  "type": "string"
                },
                "tls-insecure-skip-verify": {
                  "type": "boolean"
                },
                "headers": {
                  "type": "object",
                  "additionalProperties": true
                }
              },
              "additionalProperties": false
            },
            "http": {
              "type": "object",
              "properties": {
                "enabled": {
                  "type": "boolean"
                },
                "endpoints": {
                  "type": "array",
                  "items": [
                    {
                      "type": "string",
                      "minItems": 1,
                      "format": "uri",
                      "minLength": 1,
                      "maxLength": 255,
                      "pattern": "^(https?|http?)://"
                    }
                  ]
                },
                "timeout": {
                  "type": "string",
                  "minLength": 2,
                  "pattern": "[0-9]+s|m}"
                },
                "method": {
                  "type": "string",
                  "enum": [
                    "POST",
                    "PUT"
                  ]
                },
                "serializer": {
                  "type": "string",
                  "enum": [
                    "json"
                  ]
                },
                "enable-gzip": {
                  "type": "boolean"
                },
                "proxy-url": {
                  "type": "string"
                },
                "proxy-username": {
                  "type": "string"
                },
                "proxy-password": {
                  "type": "string"
                },
                "username": {
                  "type": "string"
                },
                "password": {
                  "type": "string"
                },
                "tls-key": {
                  "type": "string"
                },
                "tls-cert": {
                  "type": "string"
                },
                "tls-ca": {
                  "type": "string"
                },
                "tls-insecure-skip-verify": {
                  "type": "boolean"
                },
                "headers": {
                  "type": "object",
                  "additionalProperties": true
                }
              },
              "additionalProperties": false
            },
            "eventlog": {
              "type": "object",
              "properties": {
                "enabled": {
                  "type": "boolean"
                },
                "level": {
                  "type": "string",
                  "enum": [
                    "INFO",
                    "info",
                    "warn",
                    "warning",
                    "WARN",
                    "WARNING",
                    "error",
                    "erro",
                    "ERROR",
                    "ERRO"
                  ]
                },
                "remote-host": {
                  "type": "string"
                },
                "template": {
                  "type": "string"
                }
              },
              "additionalProperties": false
            }
          },
          "additionalProperties": false
        }
      ]
    },
    "pe": {
      "type": "object",
      "properties": {
        "enabled": {
          "type": "boolean"
        },
        "read-resources": {
          "type": "boolean"
        },
        "read-symbols": {
          "type": "boolean"
        },
        "read-sections": {
          "type": "boolean"
        },
        "excluded-images": {
          "type": "array",
          "items": [
            {
              "type": "string"
            }
          ]
        }
      },
      "additionalProperties": false
    },
    "transformers": {
      "type": "object",
      "anyOf": [
        {
          "properties": {
            "remove": {
              "type": "object",
              "properties": {
                "enabled": {
                  "type": "boolean"
                },
                "params": {
                  "type": "array",
                  "items": [
                    {
                      "type": "string"
                    }
                  ]
                }
              },
              "if": {
                "properties": {
                  "enabled": {
                    "const": true
                  }
                }
              },
              "then": {
                "properties": {
                  "params": {
                    "type": "array",
                    "minItems": 1,
                    "items": [
                      {
                        "type": "string"
                      }
                    ]
                  }
                }
              },
              "additionalProperties": false
            },
            "rename": {
              "type": "object",
              "properties": {
                "enabled": {
                  "type": "boolean"
                },
                "params": {
                  "type": "array",
                  "items": [
                    {
                      "type": "object",
                      "properties": {
                        "old": {
                          "type": "string",
                          "minLength": 1
                        },
                        "new": {
                          "type": "string",
                          "minLength": 1
                        }
                      },
                      "additionalProperties": false
                    }
                  ]
                }
              },
              "if": {
                "properties": {
                  "enabled": {
                    "const": true
                  }
                }
              },
              "then": {
                "properties": {
                  "params": {
                    "minItems": 1
                  }
                }
              },
              "additionalProperties": false
            },
            "replace": {
              "type": "object",
              "properties": {
                "enabled": {
                  "type": "boolean"
                },
                "replacements": {
                  "type": "array",
                  "items": [
                    {
                      "type": "object",
                      "properties": {
                        "param": {
                          "type": "string",
                          "minLength": 1
                        },
                        "old": {
                          "type": "string",
                          "minLength": 1
                        },
                        "new": {
                          "type": "string"
                        }
                      },
                      "additionalProperties": false
                    }
                  ]
                }
              },
              "if": {
                "properties": {
                  "enabled": {
                    "const": true
                  }
                }
              },
              "then": {
                "properties": {
                  "replacements": {
                    "minItems": 1
                  }
                }
              },
              "additionalProperties": false
            },
            "tags": {
              "type": "object",
              "properties": {
                "enabled": {
                  "type": "boolean"
                },
                "tags": {
                  "type": "array",
                  "items": [
                    {
                      "type": "object",
                      "properties": {
                        "key": {
                          "type": "string",
                          "minLength": 1
                        },
                        "value": {
                          "type": "string",
                          "minLength": 1
                        }
                      },
                      "additionalProperties": false
                    }
                  ]
                }
              },
              "if": {
                "properties": {
                  "enabled": {
                    "const": true
                  }
                }
              },
              "then": {
                "properties": {
                  "tags": {
                    "minItems": 1
                  }
                }
              },
              "additionalProperties": false
            },
            "trim": {
              "type": "object",
              "properties": {
                "enabled": {
                  "type": "boolean"
                },
                "prefixes": {
                  "type": "array",
                  "items": [
                    {
                      "type": "object",
                      "properties": {
                        "param": {
                          "type": "string",
                          "minLength": 1
                        },
                        "trim": {
                          "type": "string",
                          "minLength": 1
                        }
                      },
                      "additionalProperties": false
                    }
                  ]
                },
                "suffixes": {
                  "type": "array",
                  "items": [
                    {
                      "type": "object",
                      "properties": {
                        "param": {
                          "type": "string",
                          "minLength": 1
                        },
                        "trim": {
                          "type": "string",
                          "minLength": 1
                        }
                      },
                      "additionalProperties": false
                    }
                  ]
                }
              },
              "if": {
                "properties": {
                  "enabled": {
                    "const": true
                  }
                }
              },
              "then": {
                "properties": {
                  "suffixes": {
                    "minItems": 1
                  },
                  "prefixes": {
                    "minItems": 1
                  }
                }
              },
              "additionalProperties": false
            }
          },
          "additionalProperties": false
        }
      ]
    },
    "yara": {
      "type": "object",
      "properties": {
        "enabled": {
          "type": "boolean"
        },
        "rule": {
          "type": "object",
          "anyOf": [
            {
              "properties": {
                "paths": {
                  "type": "array",
                  "items": [
                    {
                      "type": "object",
                      "properties": {
                        "path": {
                          "type": "string"
                        },
                        "namespace": {
                          "type": "string"
                        }
                      },
                      "if": {
                        "properties": {
                          "enabled": {
                            "$ref": "#yara",
                            "const": true
                          }
                        }
                      },
                      "then": {
                        "properties": {
                          "path": {
                            "minLength": 0
                          }
                        }
                      },
                      "additionalProperties": false
                    }
                  ]
                },
                "strings": {
                  "type": "array"
                }
              },
              "additionalProperties": false
            }
          ]
        },
        "alert-template": {
          "type": "string"
        },
        "fastscan": {
          "type": "boolean"
        },
        "skip-files": {
          "type": "boolean"
        },
        "skip-allocs": {
          "type": "boolean"
        },
        "skip-mmaps": {
          "type": "boolean"
        },
        "skip-registry": {
          "type": "boolean"
        },
        "scan-timeout": {
          "type": "string",
          "minLength": 2,
          "pattern": "[0-9]+s"
        },
        "excluded-files": {
          "type": "array",
          "items": [
            {
              "type": "string",
              "minLength": 1
            }
          ]
        },
        "excluded-procs": {
          "type": "array",
          "items": [
            {
              "type": "string",
              "minLength": 1
            }
          ]
        }
      },
      "additionalProperties": false
    }
  },
  "additionalProperties": false
}
```

`pkg/config/config_windows.go`:

```go
/*
 * Copyright 2019-2020 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package config

import (
	"encoding/json"
	"fmt"
	"github.com/rabbitstack/fibratus/internal/evasion"
	"golang.org/x/sys/windows"
	"time"

	"github.com/rabbitstack/fibratus/pkg/outputs/eventlog"

	"github.com/rabbitstack/fibratus/pkg/outputs/http"

	"github.com/rabbitstack/fibratus/pkg/aggregator"
	"github.com/rabbitstack/fibratus/pkg/aggregator/transformers"
	removet "github.com/rabbitstack/fibratus/pkg/aggregator/transformers/remove"
	replacet "github.com/rabbitstack/fibratus/pkg/aggregator/transformers/replace"
	tagst "github.com/rabbitstack/fibratus/pkg/aggregator/transformers/tags"
	"github.com/rabbitstack/fibratus/pkg/event"
	"github.com/rabbitstack/fibratus/pkg/outputs/amqp"
	"github.com/rabbitstack/fibratus/pkg/outputs/elasticsearch"
	"github.com/rabbitstack/fibratus/pkg/util/log"
	"github.com/rabbitstack/fibratus/pkg/util/multierror"
	yara "github.com/rabbitstack/fibratus/pkg/yara/config"
	"gopkg.in/yaml.v3"

	renamet "github.com/rabbitstack/fibratus/pkg/aggregator/transformers/rename"
	trimt "github.com/rabbitstack/fibratus/pkg/aggregator/transformers/trim"

	"os"
	"path/filepath"
	"strings"

	"github.com/rabbitstack/fibratus/pkg/alertsender"
	eventlogsender "github.com/rabbitstack/fibratus/pkg/alertsender/eventlog"
	mailsender "github.com/rabbitstack/fibratus/pkg/alertsender/mail"
	slacksender "github.com/rabbitstack/fibratus/pkg/alertsender/slack"
	systraysender "github.com/rabbitstack/fibratus/pkg/alertsender/systray"
	"github.com/rabbitstack/fibratus/pkg/outputs"
	"github.com/rabbitstack/fibratus/pkg/outputs/console"
	"github.com/rabbitstack/fibratus/pkg/pe"
	"github.com/spf13/cobra"
	"github.com/spf13/pflag"
	"github.com/spf13/viper"
)

const (
	capFile                  = "cap.file"
	configFile               = "config-file"
	debugPrivilege           = "debug-privilege"
	initHandleSnapshot       = "handle.init-snapshot"
	enumerateHandles         = "handle.enumerate-handles"
	symbolPaths              = "symbol-paths"
	symbolizeKernelAddresses = "symbolize-kernel-addresses"
	forwardMode              = "forward"

	serializeThreads = "event.serialize-threads"
	serializeImages  = "event.serialize-images"
	serializeHandles = "event.serialize-handles"
	serializePE      = "event.serialize-pe"
	serializeEnvs    = "event.serialize-envs"
)

// Config stores configuration options for fine-tuning the behaviour of Fibratus.
type Config struct {
	// EventSource stores different configuration options for fine-tuning the event source.
	EventSource EventSourceConfig `json:"eventsource" yaml:"eventsource"`
	// Filament contains filament settings
	Filament FilamentConfig `json:"filament" yaml:"filament"`
	// PE contains the settings that influences the behaviour of the PE (Portable Executable) reader.
	PE pe.Config `json:"pe" yaml:"pe"`
	// Output stores the currently active output config
	Output outputs.Config
	// InitHandleSnapshot indicates whether initial handle snapshot is built
	InitHandleSnapshot bool `json:"init-handle-snapshot" yaml:"init-handle-snapshot"`
	// EnumerateHandles indicates if process handles are collected during startup or
	// when a new process is spawn
	EnumerateHandles bool `json:"enumerate-handles" yaml:"enumerate-handles"`
	// SymbolPaths designates the path or a series of paths separated by a semicolon
	// that is used to search for symbols files.
	SymbolPaths string `json:"symbol-paths" yaml:"symbols-paths"`
	// SymbolizeKernelAddresses determines if kernel stack addresses are symbolized.
	SymbolizeKernelAddresses bool `json:"symbolize-kernel-addresses" yaml:"symbolize-kernel-addresses"`

	// DebugPrivilege dictates if the SeDebugPrivilege is injected into
	// Fibratus process' access token.
	DebugPrivilege bool `json:"debug-privilege" yaml:"debug-privilege"`
	// ForwardMode designates if event forwarding mode is engaged
	ForwardMode bool `json:"forward" yaml:"forward"`

	// CapFile represents the name of the capture file.
	CapFile string

	// API stores global HTTP API preferences
	API APIConfig `json:"api" yaml:"api"`
	// Yara contains configuration that influences the behaviour of the Yara engine
	Yara yara.Config `json:"yara" yaml:"yara"`
	// Aggregator stores event aggregator configuration
	Aggregator aggregator.Config `json:"aggregator" yaml:"aggregator"`
	// Log contains log-specific configuration options
	Log log.Config `json:"logging" yaml:"logging"`

	// Transformers stores transformer configurations
	Transformers []transformers.Config
	// Alertsenders stores alert sender configurations
	Alertsenders []alertsender.Config

	// Filters contains filter/rule definitions
	Filters *Filters `json:"filters" yaml:"filters"`

	// Evasion controls the detection of evasion behaviours.
	Evasion evasion.Config `json:"evasion" yaml:"evasion"`

	flags *pflag.FlagSet
	viper *viper.Viper
	opts  *Options
}

// Options determines which config flags are toggled depending on the command type.
type Options struct {
	capture  bool
	replay   bool
	run      bool
	list     bool
	stats    bool
	validate bool
}

// Option is the type alias for the config option.
type Option func(*Options)

// WithCapture determines the capture command is executed.
func WithCapture() Option {
	return func(o *Options) {
		o.capture = true
	}
}

// WithReplay determines the replay command is executed.
func WithReplay() Option {
	return func(o *Options) {
		o.replay = true
	}
}

// WithRun determines the main command is executed.
func WithRun() Option {
	return func(o *Options) {
		o.run = true
	}
}

// WithList determines the list command is executed.
func WithList() Option {
	return func(o *Options) {
		o.list = true
	}
}

// WithStats determines the stats command is executed.
func WithStats() Option {
	return func(o *Options) {
		o.stats = true
	}
}

// WithValidate determines the validate command is executed.
func WithValidate() Option {
	return func(o *Options) {
		o.validate = true
	}
}

// NewWithOpts builds a new configuration store from a variety of sources such as configuration files,
// environment variables or command line flags.
func NewWithOpts(options ...Option) *Config {
	opts := &Options{}

	for _, opt := range options {
		opt(opts)
	}

	v := viper.New()
	v.AutomaticEnv()
	v.SetEnvKeyReplacer(strings.NewReplacer("-", "_", ".", "_"))

	flagSet := new(pflag.FlagSet)

	c := &Config{
		EventSource: EventSourceConfig{},
		Filament:    FilamentConfig{},
		API:         APIConfig{},
		PE:          pe.Config{},
		Log:         log.Config{},
		Aggregator:  aggregator.Config{},
		Filters:     &Filters{},
		viper:       v,
		flags:       flagSet,
		opts:        opts,
	}

	if opts.run || opts.replay {
		aggregator.AddFlags(flagSet)
		console.AddFlags(flagSet)
		amqp.AddFlags(flagSet)
		elasticsearch.AddFlags(flagSet)
		http.AddFlags(flagSet)
		eventlog.AddFlags(flagSet)
		removet.AddFlags(flagSet)
		replacet.AddFlags(flagSet)
		renamet.AddFlags(flagSet)
		trimt.AddFlags(flagSet)
		tagst.AddFlags(flagSet)
		mailsender.AddFlags(flagSet)
		slacksender.AddFlags(flagSet)
		systraysender.AddFlags(flagSet)
		eventlogsender.AddFlags(flagSet)
		yara.AddFlags(flagSet)
	}

	if opts.run || opts.capture {
		pe.AddFlags(flagSet)
	}

	if opts.run {
		evasion.AddFlags(flagSet)
	}

	c.addFlags()

	return c
}

// GetConfigFile gets the path of the configuration file from Viper value.
func (c Config) GetConfigFile() string {
	return c.viper.GetString(configFile)
}

// GetFilters returns all rule filters loaded into the engine.
func (c Config) GetFilters() []*FilterConfig {
	if c.Filters == nil {
		return nil
	}
	return c.Filters.filters
}

// MustViperize adds the flag set to the Cobra command and binds them within the Viper flags.
func (c *Config) MustViperize(cmd *cobra.Command) {
	cmd.PersistentFlags().AddFlagSet(c.flags)
	if err := c.viper.BindPFlags(cmd.PersistentFlags()); err != nil {
		panic(err)
	}
	if c.opts.capture || c.opts.replay {
		if err := cmd.MarkPersistentFlagRequired(capFile); err != nil {
			panic(err)
		}
	}
}

// Init setups the configuration state from Viper.
func (c *Config) Init() error {
	c.EventSource.initFromViper(c.viper)
	c.Filament.initFromViper(c.viper)
	c.API.initFromViper(c.viper)
	c.PE.InitFromViper(c.viper)
	c.Aggregator.InitFromViper(c.viper)
	c.Log.InitFromViper(c.viper)
	c.Yara.InitFromViper(c.viper)
	c.Filters.initFromViper(c.viper)

	c.InitHandleSnapshot = c.viper.GetBool(initHandleSnapshot)
	c.EnumerateHandles = c.viper.GetBool(enumerateHandles)
	c.SymbolPaths = c.viper.GetString(symbolPaths)
	c.SymbolizeKernelAddresses = c.viper.GetBool(symbolizeKernelAddresses)
	c.DebugPrivilege = c.viper.GetBool(debugPrivilege)
	c.ForwardMode = c.viper.GetBool(forwardMode)
	c.CapFile = c.viper.GetString(capFile)

	event.SerializeThreads = c.viper.GetBool(serializeThreads)
	event.SerializeImages = c.viper.GetBool(serializeImages)
	event.SerializeHandles = c.viper.GetBool(serializeHandles)
	event.SerializePE = c.viper.GetBool(serializePE)
	event.SerializeEnvs = c.viper.GetBool(serializeEnvs)

	if c.opts.run || c.opts.replay {
		if err := c.tryLoadOutput(); err != nil {
			return err
		}
		if err := c.tryLoadTransformers(); err != nil {
			return err
		}
		if err := c.tryLoadAlertSenders(); err != nil {
			return err
		}
	}

	if c.opts.run {
		c.Evasion.InitFromViper(c.viper)
	}

	return nil
}

// IsCaptureSet determines if the events are stored
// in the capture file.
func (c *Config) IsCaptureSet() bool { return c.CapFile != "" }

// IsFilamentSet indicates if the filament is supplied.
func (c *Config) IsFilamentSet() bool { return c.Filament.Name != "" }

// TryLoadFile attempts to load the configuration file from specified path on the file system.
func (c *Config) TryLoadFile(file string) error {
	c.viper.SetConfigFile(file)
	return c.viper.ReadInConfig()
}

// Validate ensures that all configuration options provided by user have the expected values. It returns
// a list of validation errors prefixed with the offending configuration property/flag.
func (c *Config) Validate() error {
	// we'll first validate the structure and values of the config file
	file := c.viper.GetString(configFile)
	var out interface{}
	b, err := os.ReadFile(file)
	if err != nil {
		return err
	}
	switch filepath.Ext(file) {
	case ".yaml", ".yml":
		err = yaml.Unmarshal(b, &out)
	case ".json":
		err = json.Unmarshal(b, &out)
	default:
		return fmt.Errorf("%s is not a supported config file extension", filepath.Ext(file))
	}
	if err != nil {
		return fmt.Errorf("couldn't read the config file: %v", err)
	}
	// validate config file content
	valid, errs := validate(configSchema, out)
	if !valid || len(errs) > 0 {
		return fmt.Errorf("invalid config: %v", multierror.Wrap(errs...))
	}
	// now validate the Viper config flags
	valid, errs = validate(configSchema, c.viper.AllSettings())
	if !valid || len(errs) > 0 {
		return fmt.Errorf("invalid config: %v", multierror.Wrap(errs...))
	}
	return nil
}

// File returns the config file path.
func (c *Config) File() string { return c.viper.GetString(configFile) }

// SymbolPathsUTF16 returns the symbol paths as UTF16 string
// suitable for use in the Debug Helper API functions.
func (c *Config) SymbolPathsUTF16() *uint16 {
	paths, _ := windows.UTF16PtrFromString(c.SymbolPaths)
	return paths
}

func (c *Config) addFlags() {
	c.flags.String(configFile, filepath.Join(os.Getenv("PROGRAMFILES"), "fibratus", "config", "fibratus.yml"), "Indicates the location of the configuration file")
	if c.opts.run {
		c.flags.Bool(forwardMode, false, "Designates if event forwarding mode is engaged")
	}
	if c.opts.run || c.opts.replay || c.opts.validate {
		c.flags.StringP(filamentName, "f", "", "Specifies the filament to execute")

		// initialize default rules paths
		exe, err := os.Executable()
		if err != nil {
			// fallback to default install directory
			exe = filepath.Join(os.Getenv("ProgramFiles"), "Fibratus", "Bin", "fibratus.exe")
		}
		dir := filepath.Join(filepath.Dir(exe), "..", "Rules")

		c.flags.Bool(rulesEnabled, true, "Indicates if the rule engine is enabled and rules loaded")
		c.flags.StringSlice(rulesFromPaths, []string{filepath.Join(dir, "*")}, "Comma-separated list of rules files")
		c.flags.StringSlice(macrosFromPaths, []string{filepath.Join(dir, "Macros", "*")}, "Comma-separated list of macro files")
		c.flags.StringSlice(rulesFromURLs, []string{}, "Comma-separated list of rules URL resources")
		c.flags.Bool(matchAll, true, "Indicates if the match all strategy is enabled for the rule engine. If the match all strategy is enabled, a single event can trigger multiple rules")
	}
	if c.opts.capture {
		c.flags.StringP(capFile, "o", "", "The path of the output cap file")
	}
	if c.opts.replay {
		c.flags.StringP(capFile, "k", "", "The path of the input cap file")
	}
	if c.opts.run || c.opts.replay || c.opts.list || c.opts.validate {
		c.flags.String(filamentPath, filepath.Join(os.Getenv("PROGRAMFILES"), "fibratus", "filaments"), "Denotes the directory where filaments are located")
	}
	if c.opts.run || c.opts.replay || c.opts.capture || c.opts.stats {
		c.flags.String(transport, `localhost:8080`, "Specifies the underlying transport protocol for the API HTTP server")
		c.flags.Duration(timeout, time.Second*15, "Determines the timeout for the API server responses")
	}
	if c.opts.run || c.opts.capture {
		c.flags.Bool(initHandleSnapshot, false, "Indicates whether initial handle snapshot is built. This implies scanning the system handles table and producing an entry for each handle object")
		c.flags.Bool(debugPrivilege, true, "Dictates if the SeDebugPrivilege is injected into Fibratus process' access token")
		c.flags.Bool(enumerateHandles, false, "Indicates if process handles are collected during startup or when a new process is spawn")
		c.flags.String(symbolPaths, "srv*c:\\\\SymCache*https://msdl.microsoft.com/download/symbols", "Designates the path or a series of paths separated by a semicolon that is used to search for symbols files")
		c.flags.Bool(symbolizeKernelAddresses, false, "Determines if kernel stack addresses are symbolized")

		c.flags.Bool(enableThreadEvents, true, "Determines whether thread events are collected by Kernel Logger provider")
		c.flags.Bool(enableRegistryEvents, true, "Determines whether registry events are collected by Kernel Logger provider")
		c.flags.Bool(enableNetEvents, true, "Determines whether network (TCP/UDP) events are collected by Kernel Logger provider")
		c.flags.Bool(enableFileIOEvents, true, "Determines whether disk I/O events are collected by Kernel Logger provider")
		c.flags.Bool(enableVAMapEvents, true, "Determines whether VA map/unmap events are collected by Kernel Logger provider")
		c.flags.Bool(enableImageEvents, true, "Determines whether file I/O events are collected by Kernel Logger provider")
		c.flags.Bool(enableHandleEvents, false, "Determines whether object manager events (handle creation/destruction) are collected by Kernel Logger provider")
		c.flags.Bool(enableMemEvents, true, "Determines whether memory manager events are collected by Kernel Logger provider")
		c.flags.Bool(enableAuditAPIEvents, true, "Determines whether kernel audit API calls events are published")
		c.flags.Bool(enableDNSEvents, true, "Determines whether DNS client events are enabled")
		c.flags.Bool(enableThreadpoolEvents, true, "Determines whether thread pool events are published")
		c.flags.Bool(stackEnrichment, true, "Indicates if stack enrichment is enabled for eligible events")
		c.flags.Int(bufferSize, int(maxBufferSize), "Represents the amount of memory allocated for each event tracing session buffer, in kilobytes. The buffer size affects the rate at which buffers fill and must be flushed (small buffer size requires less memory but it increases the rate at which buffers must be flushed)")
		c.flags.Int(minBuffers, int(defaultMinBuffers), "Determines the minimum number of buffers allocated for the event tracing session's buffer pool")
		c.flags.Int(maxBuffers, int(defaultMaxBuffers), "Determines the maximum number of buffers allocated for the event tracing session's buffer pool")
		c.flags.Duration(flushInterval, defaultFlushInterval, "Specifies how often the trace buffers are forcibly flushed")
		c.flags.StringSlice(excludedEvents, []string{}, "A list of symbolical kernel event names that will be dropped from the event stream. By default all events are accepted")
		c.flags.StringSlice(excludedImages, []string{}, "A list of image names that will be dropped from the event stream. Image names are case sensitive")

		c.flags.Bool(serializeThreads, false, "Indicates if threads are serialized as part of the process state")
		c.flags.Bool(serializeImages, false, "Indicates if images are serialized as part of the process state")
		c.flags.Bool(serializeHandles, false, "Indicates if handles are serialized as part of the process state")
		c.flags.Bool(serializePE, false, "Indicates if the PE metadata are serialized as part of the process state")
		c.flags.Bool(serializeEnvs, true, "Indicates if environment variables are serialized as part of the process state")
	}
	c.Log.AddFlags(c.flags)
}

```

`pkg/config/config_windows_test.go`:

```go
/*
 * Copyright 2019-2020 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package config

import (
	"github.com/rabbitstack/fibratus/pkg/aggregator/transformers"
	"github.com/rabbitstack/fibratus/pkg/aggregator/transformers/rename"
	"github.com/rabbitstack/fibratus/pkg/alertsender"
	"github.com/rabbitstack/fibratus/pkg/alertsender/eventlog"
	"github.com/rabbitstack/fibratus/pkg/alertsender/mail"
	"github.com/rabbitstack/fibratus/pkg/alertsender/slack"
	"github.com/rabbitstack/fibratus/pkg/alertsender/systray"
	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/require"
	"testing"
	"time"
)

func TestNewFromYamlFile(t *testing.T) {
	c := NewWithOpts(WithRun())

	err := c.flags.Parse([]string{"--config-file=_fixtures/fibratus.yml"})
	require.NoError(t, c.viper.BindPFlags(c.flags))
	require.NoError(t, err)
	require.NoError(t, c.TryLoadFile(c.GetConfigFile()))

	require.NoError(t, c.Init())

	errs := c.Validate()

	require.Empty(t, errs)

	assert.Equal(t, time.Millisecond*230, c.Aggregator.FlushPeriod)
	assert.Equal(t, time.Second*8, c.Aggregator.FlushTimeout)

	assert.Len(t, c.Alertsenders, 4)

	for _, c := range c.Alertsenders {
		switch c.Type {
		case alertsender.Slack:
			assert.IsType(t, slack.Config{}, c.Sender)
		case alertsender.Mail:
			assert.IsType(t, mail.Config{}, c.Sender)
			mailConfig := c.Sender.(mail.Config)
			assert.Equal(t, "smtp.gmail.com", mailConfig.Host)
			assert.Equal(t, 587, mailConfig.Port)
			assert.Equal(t, "bunny", mailConfig.User)
			assert.Equal(t, "changeit", mailConfig.Pass)
			assert.Equal(t, "bunny@gmail.com", mailConfig.From)
			assert.Equal(t, []string{"bunny@gmail.com", "rabbit@gmail.com", "cuniculus@gmail.com"}, mailConfig.To)
		case alertsender.Systray:
			assert.IsType(t, systray.Config{}, c.Sender)
			systrayConfig := c.Sender.(systray.Config)
			assert.True(t, systrayConfig.Enabled)
			assert.True(t, systrayConfig.Sound)
			assert.False(t, systrayConfig.QuietMode)
		case alertsender.Eventlog:
			assert.IsType(t, eventlog.Config{}, c.Sender)
			eventlogConfig := c.Sender.(eventlog.Config)
			assert.True(t, eventlogConfig.Enabled)
		}
	}

	assert.Equal(t, "npipe:///fibratus", c.API.Transport)
	assert.Equal(t, time.Second*5, c.API.Timeout)
	assert.True(t, c.DebugPrivilege)

	assert.Equal(t, "top_netio", c.Filament.Name)

	require.Len(t, c.Transformers, 2)

	for _, tr := range c.Transformers {
		switch tr.Type {
		case transformers.Rename:
			rconfig := tr.Transformer.(rename.Config)
			assert.Len(t, rconfig.Params, 2)
			r1 := rconfig.Params[0]
			assert.Equal(t, "b", r1.New)
		}
	}

	assert.True(t, c.Yara.Enabled)

	require.Len(t, c.Yara.Rule.Paths, 1)
	assert.Len(t, c.Yara.Rule.Strings, 1)

	assert.Equal(t, "C:\\yara-rules", c.Yara.Rule.Paths[0].Path)
	assert.Equal(t, "default", c.Yara.Rule.Paths[0].Namespace)
}

func TestNewFromJsonFile(t *testing.T) {
	c := NewWithOpts(WithRun())

	err := c.flags.Parse([]string{"--config-file=_fixtures/fibratus.json"})
	require.NoError(t, c.viper.BindPFlags(c.flags))
	require.NoError(t, err)
	require.NoError(t, c.TryLoadFile(c.GetConfigFile()))

	require.NoError(t, c.Init())

	errs := c.Validate()

	require.Empty(t, errs)

	assert.Equal(t, time.Millisecond*230, c.Aggregator.FlushPeriod)
	assert.Equal(t, time.Second*8, c.Aggregator.FlushTimeout)
}

```

`pkg/config/decoder.go`:

```go
/*
 * Copyright 2019-2020 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package config

import (
	"github.com/mitchellh/mapstructure"
	"net"
	"reflect"
)

func decode(input, output interface{}) error {
	var decoderConfig = &mapstructure.DecoderConfig{
		Metadata:         nil,
		Result:           output,
		WeaklyTypedInput: true,
		DecodeHook: mapstructure.ComposeDecodeHookFunc(
			mapstructure.StringToTimeDurationHookFunc(),
			mapstructure.StringToSliceHookFunc(","),
			ipSliceDecodeHook(),
		),
	}
	decoder, err := mapstructure.NewDecoder(decoderConfig)
	if err != nil {
		return err
	}
	return decoder.Decode(input)
}

func ipSliceDecodeHook() mapstructure.DecodeHookFunc {
	return func(from reflect.Type, to reflect.Type, data interface{}) (interface{}, error) {
		if to.Kind() == reflect.Slice && to.Elem() == reflect.TypeOf(net.IP(nil)) {
			switch v := data.(type) {
			case []interface{}:
				var ips []net.IP
				for _, s := range v {
					ip, ok := s.(string)
					if !ok {
						continue
					}
					ips = append(ips, net.ParseIP(ip))
				}
				return ips, nil
			}
		}

		return data, nil
	}
}

```

`pkg/config/eventsource.go`:

```go
//go:build windows
// +build windows

/*
 * Copyright 2019-2020 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package config

import (
	"github.com/rabbitstack/fibratus/pkg/event"
	"github.com/rabbitstack/fibratus/pkg/util/bitmask"
	"runtime"
	"time"

	pstypes "github.com/rabbitstack/fibratus/pkg/ps/types"
	"github.com/spf13/viper"
)

const (
	enableThreadEvents     = "eventsource.enable-thread"
	enableRegistryEvents   = "eventsource.enable-registry"
	enableNetEvents        = "eventsource.enable-net"
	enableFileIOEvents     = "eventsource.enable-fileio"
	enableVAMapEvents      = "eventsource.enable-vamap"
	enableImageEvents      = "eventsource.enable-image"
	enableHandleEvents     = "eventsource.enable-handle"
	enableMemEvents        = "eventsource.enable-mem"
	enableAuditAPIEvents   = "eventsource.enable-audit-api"
	enableDNSEvents        = "eventsource.enable-dns"
	enableThreadpoolEvents = "eventsource.enable-threadpool"
	stackEnrichment        = "eventsource.stack-enrichment"
	bufferSize             = "eventsource.buffer-size"
	minBuffers             = "eventsource.min-buffers"
	maxBuffers             = "eventsource.max-buffers"
	flushInterval          = "eventsource.flush-interval"

	excludedEvents = "eventsource.blacklist.events"
	excludedImages = "eventsource.blacklist.images"

	maxBufferSize = uint32(512)
)

var (
	defaultMinBuffers    = uint32(runtime.NumCPU() * 2)
	defaultMaxBuffers    = defaultMinBuffers + 20
	defaultFlushInterval = time.Second
)

// EventSourceConfig stores different configuration options for fine-tuning the event source.
type EventSourceConfig struct {
	// EnableThreadEvents indicates if thread events are collected by the ETW provider.
	EnableThreadEvents bool `json:"enable-thread" yaml:"enable-thread"`
	// EnableRegistryEvents indicates if registry events are collected by the ETW provider.
	EnableRegistryEvents bool `json:"enable-registry" yaml:"enable-registry"`
	// EnableNetEvents determines whether network (TCP/UDP) events are collected by the ETW provider.
	EnableNetEvents bool `json:"enable-net" yaml:"enable-net"`
	// EnableFileIOEvents indicates if file I/O events are collected by the ETW provider.
	EnableFileIOEvents bool `json:"enable-fileio" yaml:"enable-fileio"`
	// EnableVAMapEvents indicates if VA map/unmap events are collected by the ETW provider.
	EnableVAMapEvents bool `json:"enable-vamap" yaml:"enable-vamap"`
	// EnableImageEvents indicates if image events are collected by the ETW provider.
	EnableImageEvents bool `json:"enable-image" yaml:"enable-image"`
	// EnableHandleEvents indicates whether handle creation/disposal events are enabled.
	EnableHandleEvents bool `json:"enable-handle" yaml:"enable-handle"`
	// EnableMemEvents indicates whether memory manager events are enabled.
	EnableMemEvents bool `json:"enable-memory" yaml:"enable-memory"`
	// EnableAuditAPIEvents indicates if kernel audit API calls events are enabled
	EnableAuditAPIEvents bool `json:"enable-audit-api" yaml:"enable-audit-api"`
	// EnableDNSEvents indicates if DNS client events are enabled
	EnableDNSEvents bool `json:"enable-dns" yaml:"enable-dns"`
	// EnableThreadpoolEvents indicates if thread pool events are enabled
	EnableThreadpoolEvents bool `json:"enable-threadpool" yaml:"enable-threadpool"`
	// StackEnrichment indicates if stack enrichment is enabled for eligible events.
	StackEnrichment bool `json:"stack-enrichment" yaml:"stack-enrichment"`
	// BufferSize represents the amount of memory allocated for each event tracing session buffer, in kilobytes.
	// The buffer size affects the rate at which buffers fill and must be flushed (small buffer size requires
	// less memory, but it increases the rate at which buffers must be flushed).
	BufferSize uint32 `json:"buffer-size" yaml:"buffer-size"`
	// MinBuffers determines the minimum number of buffers allocated for the event tracing session's buffer pool.
	MinBuffers uint32 `json:"min-buffers" yaml:"min-buffers"`
	// MaxBuffers is the maximum number of buffers allocated for the event tracing session's buffer pool.
	MaxBuffers uint32 `json:"max-buffers" yaml:"max-buffers"`
	// FlushTimer specifies how often the trace buffers are forcibly flushed.
	FlushTimer time.Duration `json:"flush-interval" yaml:"flush-interval"`
	// ExcludedEvents are kernel event names that will be dropped from the kernel event stream.
	ExcludedEvents []string `json:"blacklist.events" yaml:"blacklist.events"`
	// ExcludedImages are process image names that will be rejected if they generate a kernel event.
	ExcludedImages []string `json:"blacklist.images" yaml:"blacklist.images"`

	dropMasks *bitmask.Bitmask
	allMasks  *bitmask.Bitmask

	excludedImages map[string]bool
}

func (c *EventSourceConfig) initFromViper(v *viper.Viper) {
	c.EnableThreadEvents = v.GetBool(enableThreadEvents)
	c.EnableRegistryEvents = v.GetBool(enableRegistryEvents)
	c.EnableNetEvents = v.GetBool(enableNetEvents)
	c.EnableFileIOEvents = v.GetBool(enableFileIOEvents)
	c.EnableVAMapEvents = v.GetBool(enableVAMapEvents)
	c.EnableImageEvents = v.GetBool(enableImageEvents)
	c.EnableHandleEvents = v.GetBool(enableHandleEvents)
	c.EnableMemEvents = v.GetBool(enableMemEvents)
	c.EnableAuditAPIEvents = v.GetBool(enableAuditAPIEvents)
	c.EnableDNSEvents = v.GetBool(enableDNSEvents)
	c.EnableThreadpoolEvents = v.GetBool(enableThreadpoolEvents)
	c.StackEnrichment = v.GetBool(stackEnrichment)
	c.BufferSize = uint32(v.GetInt(bufferSize))
	c.MinBuffers = uint32(v.GetInt(minBuffers))
	c.MaxBuffers = uint32(v.GetInt(maxBuffers))
	c.FlushTimer = v.GetDuration(flushInterval)
	c.ExcludedEvents = v.GetStringSlice(excludedEvents)
	c.ExcludedImages = v.GetStringSlice(excludedImages)

	c.dropMasks = bitmask.New()
	c.allMasks = bitmask.New()

	c.excludedImages = make(map[string]bool)

	for _, name := range c.ExcludedEvents {
		if typ := event.NameToType(name); typ != event.UnknownType {
			c.dropMasks.Set(typ.ID())
		}
	}

	for _, typ := range event.AllWithState() {
		c.allMasks.Set(typ.ID())
	}

	for _, name := range c.ExcludedImages {
		c.excludedImages[name] = true
	}
}

// Init is an exported method to allow initializing exclusion maps from external modules.
func (c *EventSourceConfig) Init() {
	c.excludedImages = make(map[string]bool)

	if c.dropMasks == nil {
		c.dropMasks = bitmask.New()
	}
	for _, name := range c.ExcludedEvents {
		for _, typ := range event.NameToTypes(name) {
			if typ != event.UnknownType {
				c.dropMasks.Set(typ.ID())
			}
		}
	}

	for _, name := range c.ExcludedImages {
		c.excludedImages[name] = true
	}

	if c.allMasks == nil {
		c.allMasks = bitmask.New()
	}
	for _, typ := range event.AllWithState() {
		c.allMasks.Set(typ.ID())
	}
}

// SetDropMask inserts the event mask in the bitset to
// instruct the given event type should be dropped from
// the event stream.
func (c *EventSourceConfig) SetDropMask(typ event.Type) {
	c.dropMasks.Set(typ.ID())
}

// TestDropMask checks if the specified event type has
// the drop mask in the bitset.
func (c *EventSourceConfig) TestDropMask(typ event.Type) bool {
	return c.dropMasks.IsSet(typ.ID())
}

// ExcludeEvent determines whether the supplied short
// event ID exists in the bitset of excluded events.
func (c *EventSourceConfig) ExcludeEvent(id uint) bool {
	return c.dropMasks.IsSet(id)
}

// EventExists determines if the provided event ID exists
// in the internal event catalog by checking the event ID
// bitmask.
func (c *EventSourceConfig) EventExists(id uint) bool {
	return c.allMasks.IsSet(id)
}

// ExcludeImage determines whether the process generating event is present in the
// list of excluded images. If the hit occurs, the event associated with the process
// is dropped.
func (c *EventSourceConfig) ExcludeImage(ps *pstypes.PS) bool {
	if len(c.excludedImages) == 0 {
		return false
	}
	if ps == nil {
		return false
	}
	return c.excludedImages[ps.Name]
}

```

`pkg/config/eventsource_test.go`:

```go
//go:build windows
// +build windows

/*
 * Copyright 2019-2020 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package config

import (
	"github.com/rabbitstack/fibratus/pkg/event"
	"testing"

	pstypes "github.com/rabbitstack/fibratus/pkg/ps/types"

	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/require"
)

func TestEventSourceConfig(t *testing.T) {
	c := NewWithOpts(WithRun())

	err := c.flags.Parse([]string{
		"--eventsource.enable-thread=false",
		"--eventsource.enable-registry=false",
		"--eventsource.enable-fileio=false",
		"--eventsource.enable-net=false",
		"--eventsource.enable-image=false",
		"--eventsource.blacklist.events=CloseFile,CloseHandle",
		"--eventsource.blacklist.images=System,svchost.exe",
	})
	require.NoError(t, err)
	require.NoError(t, c.viper.BindPFlags(c.flags))
	require.NoError(t, err)

	require.NoError(t, c.Init())

	assert.False(t, c.EventSource.EnableThreadEvents)
	assert.False(t, c.EventSource.EnableNetEvents)
	assert.False(t, c.EventSource.EnableRegistryEvents)
	assert.False(t, c.EventSource.EnableImageEvents)
	assert.False(t, c.EventSource.EnableFileIOEvents)

	assert.True(t, c.EventSource.ExcludeEvent(event.CloseHandle.ID()))
	assert.False(t, c.EventSource.ExcludeEvent(event.CreateProcess.ID()))

	assert.True(t, c.EventSource.ExcludeImage(&pstypes.PS{Name: "svchost.exe"}))
	assert.False(t, c.EventSource.ExcludeImage(&pstypes.PS{Name: "explorer.exe"}))
}

```

`pkg/config/filament.go`:

```go
/*
 * Copyright 2019-2020 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package config

import (
	"github.com/spf13/viper"
	"time"
)

const (
	filamentName = "filament.name"
	filamentPath = "filament.path"
)

// FilamentConfig stores config parameters for tweaking the behaviour of the filament engine.
type FilamentConfig struct {
	Name        string
	Path        string
	FlushPeriod time.Duration
}

func (f *FilamentConfig) initFromViper(v *viper.Viper) {
	f.Name = v.GetString(filamentName)
	f.Path = v.GetString(filamentPath)
}

```

`pkg/config/filters.go`:

```go
/*
 * Copyright 2020-2021 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package config

import (
	"bytes"
	"fmt"
	"github.com/Masterminds/sprig/v3"
	"github.com/rabbitstack/fibratus/pkg/event"
	"github.com/rabbitstack/fibratus/pkg/util/convert"
	"github.com/rabbitstack/fibratus/pkg/util/multierror"
	log "github.com/sirupsen/logrus"
	"github.com/spf13/viper"
	"gopkg.in/yaml.v3"
	"io"
	"net"
	"net/http"
	u "net/url"
	"os"
	"path/filepath"
	"slices"
	"strings"
	"text/template"
)

// FilterConfig is the descriptor of a single filter.
type FilterConfig struct {
	ID               string            `json:"id" yaml:"id"`
	Name             string            `json:"name" yaml:"name"`
	Description      string            `json:"description" yaml:"description"`
	Version          string            `json:"version" yaml:"version"`
	Condition        string            `json:"condition" yaml:"condition"`
	Action           []FilterAction    `json:"action" yaml:"action"`
	Output           string            `json:"output" yaml:"output"`
	Severity         string            `json:"severity" yaml:"severity"`
	Labels           map[string]string `json:"labels" yaml:"labels"`
	Tags             []string          `json:"tags" yaml:"tags"`
	References       []string          `json:"references" yaml:"references"`
	Notes            string            `json:"notes" yaml:"notes"`
	MinEngineVersion string            `json:"min-engine-version" yaml:"min-engine-version"`
	Enabled          *bool             `json:"enabled" yaml:"enabled"`
	Authors          []string          `json:"authors" yaml:"authors"`
}

// FilterAction wraps all possible filter actions.
type FilterAction any

// KillAction defines an action for killing the process
// indicates by the filter field expression.
type KillAction struct{}

// IsolateAction defines an action for isolating the host
// via firewall rules.
type IsolateAction struct {
	// Whitelist contains IP addresses that should remain accessible.
	Whitelist []net.IP `mapstructure:"whitelist"`
}

// DecodeActions converts raw YAML map to
// typed action structures.
func (f FilterConfig) DecodeActions() ([]any, error) {
	actions := make([]any, 0, len(f.Action))

	dec := func(m map[string]any, o any) error {
		err := decode(m, &o)
		if err != nil {
			return err
		}
		actions = append(actions, o)
		return nil
	}

	for _, act := range f.Action {
		m, ok := act.(map[string]any)
		if !ok {
			continue
		}
		switch m["name"] {
		case "kill":
			var kill KillAction
			if err := dec(m, kill); err != nil {
				return nil, err
			}
		case "isolate":
			var isolate IsolateAction
			if err := dec(m, isolate); err != nil {
				return nil, err
			}
		}
	}

	return actions, nil
}

// IsDisabled determines if this filter is disabled.
func (f FilterConfig) IsDisabled() bool { return f.Enabled != nil && !*f.Enabled }

// HasLabel determines if the filter has the given label.
func (f FilterConfig) HasLabel(l string) bool { return f.Labels[l] != "" }

// Filters contains references to rule and macro definitions.
type Filters struct {
	Rules  Rules  `json:"rules" yaml:"rules"`
	Macros Macros `json:"macros" yaml:"macros"`
	// MatchAll indicates if the match all strategy is enabled for the rule engine.
	// If the match all strategy is enabled, a single event can trigger multiple rules.
	MatchAll bool `json:"match-all" yaml:"match-all"`
	macros   map[string]*Macro
	filters  []*FilterConfig
}

// FiltersWithMacros builds the filter config with the map of
// predefined macros. Only used for testing purposes.
func FiltersWithMacros(macros map[string]*Macro) *Filters {
	return &Filters{macros: macros, filters: make([]*FilterConfig, 0)}
}

// Rules contains attributes that describe the location of
// rule resources.
type Rules struct {
	Enabled   bool     `json:"enabled" yaml:"enabled"`
	FromPaths []string `json:"from-paths" yaml:"from-paths"`
	FromURLs  []string `json:"from-urls" yaml:"from-urls"`
}

// Macros contains attributes that describe the location of
// macro resources.
type Macros struct {
	FromPaths []string `json:"from-paths" yaml:"from-paths"`
}

// Macro represents the state of the rule macro. Macros
// either expand to expressions or lists.
type Macro struct {
	ID          string   `json:"macro" yaml:"macro"`
	Description string   `json:"description" yaml:"description"`
	Expr        string   `json:"expr" yaml:"expr"`
	List        []string `json:"list" yaml:"list"`
}

// ActionContext is the convenient structure
// for grouping the event that resulted in
// matched filter along with filter information.
type ActionContext struct {
	// Events contains a single element simple rules
	// or a list of ordered matched events for sequence
	// policies
	Events []*event.Event
	// Filter represents the filter that matched the event
	Filter *FilterConfig
}

// UniquePids returns a set of process identifiers
// from each matched event to be used in actions
// such as the process kill action.
func (ctx *ActionContext) UniquePids() []uint32 {
	pids := make(map[uint32]struct{})
	for _, e := range ctx.Events {
		if e.IsCreateProcess() {
			pids[e.Params.MustGetPid()] = struct{}{}
		} else {
			pids[e.PID] = struct{}{}
		}
	}
	return convert.MapKeysToSlice(pids)
}

// RulesCompileResult contains the stats of the
// compiled ruleset, like which event types or
// categories are used. This information permits
// enabling/disabling event providers/types
// dynamically.
type RulesCompileResult struct {
	HasProcEvents       bool
	HasThreadEvents     bool
	HasImageEvents      bool
	HasFileEvents       bool
	HasNetworkEvents    bool
	HasRegistryEvents   bool
	HasHandleEvents     bool
	HasMemEvents        bool
	HasVAMapEvents      bool
	HasDNSEvents        bool
	HasAuditAPIEvents   bool
	HasThreadpoolEvents bool
	UsedEvents          []event.Type
	NumberRules         int
}

func (r RulesCompileResult) ContainsEvent(Type event.Type) bool {
	for _, ktyp := range r.UsedEvents {
		if ktyp == Type {
			return true
		}
	}
	return false
}

func (r RulesCompileResult) String() string {
	m := map[string]bool{}
	events := make([]string, 0)
	for _, ktyp := range r.UsedEvents {
		if m[ktyp.String()] {
			continue
		}
		events = append(events, ktyp.String())
		m[ktyp.String()] = true
	}
	slices.Sort(events)
	return fmt.Sprintf(`
		HasProcEvents: %t
		HasThreadEvents: %t
		HasImageEvents: %t
		HasFileEvents: %t
		HasRegistryEvents: %t
		HasNetworkEvents: %t
		HasHandleEvents: %t
		HasMemEvents: %t
		HasVAMapEvents: %t
		HasAuditAPIEvents: %t
		HasDNSEvents: %t
		HasThreadpoolEvents: %t
		Events: %s`,
		r.HasProcEvents,
		r.HasThreadEvents,
		r.HasImageEvents,
		r.HasFileEvents,
		r.HasRegistryEvents,
		r.HasNetworkEvents,
		r.HasHandleEvents,
		r.HasMemEvents,
		r.HasVAMapEvents,
		r.HasAuditAPIEvents,
		r.HasDNSEvents,
		r.HasThreadpoolEvents,
		strings.Join(events, ", "),
	)
}

const (
	rulesEnabled    = "filters.rules.enabled"
	rulesFromPaths  = "filters.rules.from-paths"
	rulesFromURLs   = "filters.rules.from-urls"
	macrosFromPaths = "filters.macros.from-paths"
	matchAll        = "filters.match-all"
)

func (f *Filters) initFromViper(v *viper.Viper) {
	f.Rules.Enabled = v.GetBool(rulesEnabled)
	f.Rules.FromPaths = v.GetStringSlice(rulesFromPaths)
	f.Rules.FromURLs = v.GetStringSlice(rulesFromURLs)
	f.Macros.FromPaths = v.GetStringSlice(macrosFromPaths)
	f.MatchAll = v.GetBool(matchAll)
}

func (f Filters) HasMacros() bool           { return len(f.macros) > 0 }
func (f Filters) GetMacro(id string) *Macro { return f.macros[id] }
func (f Filters) IsMacroList(id string) bool {
	macro, ok := f.macros[id]
	if !ok {
		return false
	}
	return macro.List != nil
}

// LoadMacros from the macro library. The Go templates are applied
// on each macro file before running the YAML decoder on them.
func (f *Filters) LoadMacros() error {
	f.macros = make(map[string]*Macro)
	for _, p := range f.Macros.FromPaths {
		paths, err := filepath.Glob(p)
		if err != nil {
			return err
		}
		for _, path := range paths {
			if !isValidExt(path) {
				continue
			}
			log.Infof("loading macros from file %s", path)
			buf, err := os.ReadFile(path)
			if err != nil {
				return fmt.Errorf("couldn't load macros from file: %v", err)
			}
			// validate macro yaml structure
			var out interface{}
			err = yaml.Unmarshal(buf, &out)
			if err != nil {
				return fmt.Errorf("%q is invalid macro yaml file: %v", path, err)
			}
			valid, errs := validate(macrosSchema, out)
			if !valid || len(errs) > 0 {
				b, err := yaml.Marshal(&out)
				if err == nil {
					out = string(b)
				}
				return fmt.Errorf("invalid macro definition: \n\n"+
					"%v in %s: %v", out, path, multierror.Wrap(errs...))
			}
			buf, err = renderTmpl(path, buf)
			if err != nil {
				return err
			}
			// unmarshal macros and transform to map
			var macros []Macro
			if err := yaml.Unmarshal(buf, &macros); err != nil {
				return err
			}
			for _, m := range macros {
				f.macros[m.ID] = &Macro{
					ID:          m.ID,
					Description: m.Description,
					Expr:        m.Expr,
					List:        m.List,
				}
			}
		}
	}
	return nil
}

func isValidExt(path string) bool {
	return filepath.Ext(path) == ".yml" || filepath.Ext(path) == ".yaml"
}

// LoadFilters loads rules from YAML files or URL addresses.
func (f *Filters) LoadFilters() error {
	f.filters = make([]*FilterConfig, 0)
	ids := make(map[string]bool)

	for _, p := range f.Rules.FromPaths {
		paths, err := filepath.Glob(p)
		if err != nil {
			return err
		}
		for _, path := range paths {
			if !isValidExt(path) {
				continue
			}
			log.Infof("loading rule from %s", path)
			// read the rule file and decode to filter config
			rawConfig, err := os.ReadFile(path)
			if err != nil {
				return fmt.Errorf("couldn't load rule file: %s: %v", path, err)
			}
			flt, err := decodeFilter(path, rawConfig)
			if err != nil {
				return err
			}
			if ids[flt.ID] {
				return fmt.Errorf("%q rule uses duplicate id %s", flt.Name, flt.ID)
			}
			ids[flt.ID] = true
			f.filters = append(f.filters, flt)
		}
	}
	for _, url := range f.Rules.FromURLs {
		log.Infof("loading rule from URL %s", url)
		if _, err := u.Parse(url); err != nil {
			return fmt.Errorf("%q is an invalid URL", url)
		}
		//nolint:noctx
		resp, err := http.Get(url)
		if err != nil {
			return fmt.Errorf("cannot fetch rule file from %q: %v", url, err)
		}
		if resp.StatusCode != http.StatusOK {
			_ = resp.Body.Close()
			return fmt.Errorf("got non-ok status code for %q: %s", url,
				http.StatusText(resp.StatusCode))
		}

		var rawConfig bytes.Buffer
		_, err = io.Copy(&rawConfig, resp.Body)
		_ = resp.Body.Close()
		if err != nil {
			return fmt.Errorf("cannot copy rule file from %q: %v", url, err)
		}
		flt, err := decodeFilter(url, rawConfig.Bytes())
		if err != nil {
			return err
		}
		if ids[flt.ID] {
			return fmt.Errorf("%q rule uses duplicate id %s", flt.Name, flt.ID)
		}
		ids[flt.ID] = true
		f.filters = append(f.filters, flt)
	}

	if len(f.filters) == 0 {
		log.Warnf("no rules were loaded from [%s] path(s)", strings.Join(f.Rules.FromPaths, ","))
	}

	return nil
}

func decodeFilter(resource string, b []byte) (*FilterConfig, error) {
	var out interface{}
	err := yaml.Unmarshal(b, &out)
	if err != nil {
		return nil, fmt.Errorf("%q is an invalid yaml file: %v", resource, err)
	}
	// apply validation to rule definition
	valid, errs := validate(rulesSchema, out)
	if !valid || len(errs) > 0 {
		rawRule := out
		b, err := yaml.Marshal(&rawRule)
		if err == nil {
			rawRule = string(b)
		}
		return nil, fmt.Errorf("invalid rule definition: \n\n"+
			"%v in %s: %v", rawRule, resource, multierror.Wrap(errs...))
	}
	// render template
	b, err = renderTmpl(resource, b)
	if err != nil {
		return nil, err
	}
	// now unmarshal into typed filter config
	var flt FilterConfig
	if err := yaml.Unmarshal(b, &flt); err != nil {
		return nil, err
	}
	return &flt, nil
}

// renderTmpl executes templating directives in the
// rule yaml file. It returns the byte slice
// with yaml content after template expansion.
func renderTmpl(filename string, b []byte) ([]byte, error) {
	tmpl, err := template.New(filename).Funcs(sprig.FuncMap()).Parse(string(b))
	if err != nil {
		return nil, cleanupParseError(filename, err)
	}
	var w bytes.Buffer
	// force strict keys presence
	tmpl.Option("missingkey=error")
	err = tmpl.Execute(&w, nil)
	if err != nil {
		return nil, cleanupParseError(filename, err)
	}
	return w.Bytes(), nil
}

func cleanupParseError(filename string, err error) error {
	if err == nil {
		return nil
	}
	tokens := strings.Split(err.Error(), ": ")
	if len(tokens) < 2 {
		// This might happen if a non-templating error occurs
		return fmt.Errorf("syntax error in (%s): %s", filename, err)
	}
	// The first token is "template"
	// The second token is either "filename:lineno" or "filename:lineNo:columnNo"
	location := tokens[1]
	key := tokens[2]
	i := strings.Index(key, "at")
	if i > 0 {
		key = key[i+3:]
	}
	var errMsg string
	if len(tokens) > 4 {
		errMsg = strings.Join(tokens[3:], ": ")
	} else {
		errMsg = tokens[len(tokens)-1]
	}
	return fmt.Errorf("syntax error in (%s) at %s: %s", location, key, errMsg)
}

```

`pkg/config/filters_test.go`:

```go
/*
 * Copyright 2020-2021 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package config

import (
	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/require"
	"net"
	"net/http"
	"net/http/httptest"
	"os"
	"testing"
)

func TestLoadRulesFromPaths(t *testing.T) {
	filters := Filters{
		Rules{
			FromPaths: []string{
				"_fixtures/filters/default.yml",
				"_fixtures/filters/default1.yml",
			},
		},
		Macros{FromPaths: nil},
		false,
		map[string]*Macro{},
		[]*FilterConfig{},
	}
	err := filters.LoadFilters()
	require.NoError(t, err)
	require.Len(t, filters.filters, 2)

	f1 := filters.filters[0]
	assert.Equal(t, "only network category", f1.Name)
	assert.Equal(t, "313933e7-8eb9-45d9-81af-0305fee70e29", f1.ID)
	assert.Equal(t, "1.0.0", f1.Version)
	assert.True(t, *f1.Enabled)
	assert.Contains(t, f1.Tags, "TE")
	assert.Equal(t, "evt.category = 'net'", f1.Condition)
	assert.Equal(t, "this rule matches all network signals", f1.Description)
	assert.Equal(t, "low", f1.Severity)
	assert.Equal(t, "`%ps.exe` attempted to reach out to `%net.sip` IP address\n", f1.Output)
	assert.NotNil(t, f1.Action)
	assert.Contains(t, f1.References, "ref2")
	assert.NotEmpty(t, f1.Notes)
	assert.Len(t, f1.Authors, 2)

	acts, err := f1.DecodeActions()
	require.NoError(t, err)
	require.IsType(t, KillAction{}, acts[0])
	require.IsType(t, IsolateAction{}, acts[1])

	isolate := acts[1].(IsolateAction)
	require.Len(t, isolate.Whitelist, 2)
	require.Contains(t, isolate.Whitelist, net.ParseIP("127.0.0.1"))

	assert.Equal(t, "2.0.0", f1.MinEngineVersion)

	f2 := filters.filters[1]
	assert.False(t, f2.IsDisabled())
	assert.Equal(t, "suspicious network ACTIVITY", f2.Name)
	assert.Equal(t, "evt.category = 'net' and ps.name in ('at.exe', 'java.exe')", f2.Condition)
}

func TestLoadRulesFromPathsWithTemplate(t *testing.T) {
	filters := Filters{
		Rules{
			FromPaths: []string{
				"_fixtures/filters/default-with-template.yml",
			},
		},
		Macros{FromPaths: nil},
		false,
		map[string]*Macro{},
		[]*FilterConfig{},
	}
	err := filters.LoadFilters()
	require.NoError(t, err)
	require.Len(t, filters.filters, 1)

	f1 := filters.filters[0]
	assert.Equal(t, "ALL NETWORK EVENTS\n", f1.Output)
}

func TestLoadGroupsFromURLs(t *testing.T) {
	mux := http.NewServeMux()
	mux.HandleFunc("/default.yml", func(w http.ResponseWriter, r *http.Request) {
		b, err := os.ReadFile("_fixtures/filters/default.yml")
		if err != nil {
			w.WriteHeader(http.StatusInternalServerError)
			return
		}
		_, _ = w.Write(b)
	})

	l, err := net.Listen("tcp", "127.0.0.1:3231")
	if err != nil {
		t.Fatal(err)
	}
	srv := httptest.NewUnstartedServer(mux)
	srv.Listener = l
	srv.Start()
	defer srv.Close()

	filters := Filters{
		Rules{
			FromURLs: []string{
				"http://localhost:3231/default.yml",
			},
		},
		Macros{FromPaths: nil},
		false,
		map[string]*Macro{},
		[]*FilterConfig{},
	}
	err = filters.LoadFilters()
	require.NoError(t, err)
	require.Len(t, filters.filters, 1)

	f1 := filters.filters[0]
	assert.Equal(t, "only network category", f1.Name)
	assert.True(t, *f1.Enabled)
	assert.Contains(t, f1.Tags, "TE")
	assert.Equal(t, "evt.category = 'net'", f1.Condition)
	assert.Equal(t, "this rule matches all network signals", f1.Description)
	assert.Equal(t, "low", f1.Severity)
	assert.Equal(t, "`%ps.exe` attempted to reach out to `%net.sip` IP address\n", f1.Output)
	assert.NotNil(t, f1.Action)

	acts, err := f1.DecodeActions()
	require.NoError(t, err)
	require.IsType(t, KillAction{}, acts[0])

	assert.Equal(t, "2.0.0", f1.MinEngineVersion)
}

```

`pkg/config/macros.schema.json`:

```json
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "type": "array",
  "items": {
    "type": "object",
    "properties": {
      "macro": {
        "type": "string",
        "minLength": 2,
        "pattern": "^[A-Za-z0-9_-]+$"
      },
      "description": {
        "type": "string"
      },
      "expr": {
        "type": "string",
        "minLength": 5
      },
      "list": {
        "type": "array",
        "items": [
          {
            "type": "string",
            "minLength": 1
          }
        ]
      }
    },
    "required": [
      "macro"
    ],
    "oneOf": [
      {
        "required": [
          "expr"
        ]
      },
      {
        "required": [
          "list"
        ]
      }
    ],
    "additionalProperties": false
  },
  "additionalProperties": false
}

```

`pkg/config/output.go`:

```go
/*
 * Copyright 2019-2020 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package config

import (
	"errors"
	"fmt"
	"reflect"
	"strconv"

	"github.com/rabbitstack/fibratus/pkg/outputs/eventlog"

	"github.com/rabbitstack/fibratus/pkg/outputs"
	"github.com/rabbitstack/fibratus/pkg/outputs/amqp"
	"github.com/rabbitstack/fibratus/pkg/outputs/console"
	"github.com/rabbitstack/fibratus/pkg/outputs/elasticsearch"
	"github.com/rabbitstack/fibratus/pkg/outputs/http"
	"github.com/rabbitstack/fibratus/pkg/outputs/null"
	log "github.com/sirupsen/logrus"
	"golang.org/x/sys/windows/svc"
)

var errNoOutputSection = errors.New("no output section in config")

var errOutputConfig = func(output string, err error) error { return fmt.Errorf("%s output invalid config: %v", output, err) }

func (c *Config) tryLoadOutput() error {
	output := c.viper.AllSettings()["output"]
	if output == nil {
		return errNoOutputSection
	}
	mapping, ok := output.(map[string]interface{})
	if !ok {
		return fmt.Errorf("expected map[string]interface{} type for output but found %s", reflect.TypeOf(output))
	}

	humNum := func(n int) string {
		switch n {
		case 2:
			return "two"
		case 3:
			return "three"
		case 4:
			return "four"
		case 5:
			return "five"
		case 6:
			return "six"
		case 7:
			return "seven"
		default:
			return strconv.Itoa(n)
		}
	}
	// don't permit if there are various outputs enabled at a time
	activeOutputs := findActiveOutputs(mapping)
	if len(activeOutputs) > 1 {
		return fmt.Errorf("expected one but found %s active outputs: %s", humNum(len(activeOutputs)), activeOutputs)
	}

	for typ, config := range mapping {
		switch outputs.TypeFromString(typ) {
		case outputs.Console:
			var consoleConfig console.Config
			if err := decode(config, &consoleConfig); err != nil {
				return errOutputConfig(typ, err)
			}
			if !consoleConfig.Enabled {
				continue
			}
			c.Output.Type, c.Output.Output = outputs.Console, consoleConfig

		case outputs.AMQP:
			var amqpConfig amqp.Config
			if err := decode(config, &amqpConfig); err != nil {
				return errOutputConfig(typ, err)
			}
			if !amqpConfig.Enabled {
				continue
			}
			c.Output.Type, c.Output.Output = outputs.AMQP, amqpConfig

		case outputs.Elasticsearch:
			var esConfig elasticsearch.Config
			if err := decode(config, &esConfig); err != nil {
				return errOutputConfig(typ, err)
			}
			if !esConfig.Enabled {
				continue
			}
			c.Output.Type, c.Output.Output = outputs.Elasticsearch, esConfig

		case outputs.HTTP:
			var httpConfig http.Config
			if err := decode(config, &httpConfig); err != nil {
				return errOutputConfig(typ, err)
			}
			if !httpConfig.Enabled {
				continue
			}
			c.Output.Type, c.Output.Output = outputs.HTTP, httpConfig

		case outputs.Eventlog:
			var eventlogConfig eventlog.Config
			if err := decode(config, &eventlogConfig); err != nil {
				return errOutputConfig(typ, err)
			}
			if !eventlogConfig.Enabled {
				continue
			}
			c.Output.Type, c.Output.Output = outputs.Eventlog, eventlogConfig
		}
	}

	// if it is not an interactive session but the console output is enabled
	// we default to null output and warn about that
	if isWindowsService() && c.Output.Output != nil {
		if c.Output.Type == outputs.Console {
			log.Warn("running in non-interactive session with console output. " +
				"Please configure a different output type. Defaulting to null output")
			c.Output.Type, c.Output.Output = outputs.Null, &null.Config{}
			return nil
		}
	}

	// default to null output
	if c.Output.Output == nil {
		log.Warn("all outputs disabled. Defaulting to null output")
		c.Output.Type, c.Output.Output = outputs.Null, &null.Config{}
	}

	return nil
}

func findActiveOutputs(outputs map[string]interface{}) []string {
	outputTypes := make([]string, 0)
	for typ, rawConfig := range outputs {
		enabled, ok := rawConfig.(map[string]interface{})["enabled"].(bool)
		if ok && enabled {
			outputTypes = append(outputTypes, typ)
		}
	}
	return outputTypes
}

// isWindowsService returns true if the process is running inside Windows Service.
func isWindowsService() bool {
	isWinService, err := svc.IsWindowsService()
	if err != nil {
		return false
	}
	return isWinService
}

```

`pkg/config/output_test.go`:

```go
/*
 * Copyright 2019-2020 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package config

import (
	"testing"
	"time"

	"github.com/rabbitstack/fibratus/pkg/outputs/eventlog"

	"github.com/rabbitstack/fibratus/pkg/outputs/amqp"
	"github.com/rabbitstack/fibratus/pkg/outputs/http"
	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/require"
)

func TestAMQPOutput(t *testing.T) {
	c := NewWithOpts(WithRun())

	err := c.flags.Parse([]string{"--config-file=_fixtures/output.yml"})
	require.NoError(t, c.viper.BindPFlags(c.flags))
	require.NoError(t, err)
	require.NoError(t, c.TryLoadFile(c.GetConfigFile()))

	require.NoError(t, c.Init())

	require.NotNil(t, c.Output)
	require.IsType(t, amqp.Config{}, c.Output.Output)

	amqpConfig := c.Output.Output.(amqp.Config)
	assert.Equal(t, "amqp://localhost:5672", amqpConfig.URL)
	assert.Equal(t, time.Second*5, amqpConfig.Timeout)
	assert.Equal(t, "fibratus", amqpConfig.Exchange)
	assert.Equal(t, "topic", amqpConfig.ExchangeType)
	assert.Equal(t, "fibratus", amqpConfig.RoutingKey)
	assert.Equal(t, "/", amqpConfig.Vhost)
}

func TestHTTPOutput(t *testing.T) {
	c := NewWithOpts(WithRun())

	err := c.flags.Parse([]string{"--config-file=_fixtures/http-output.yml"})
	require.NoError(t, c.viper.BindPFlags(c.flags))
	require.NoError(t, err)
	require.NoError(t, c.TryLoadFile(c.GetConfigFile()))

	require.NoError(t, c.Init())

	require.NotNil(t, c.Output)
	require.IsType(t, http.Config{}, c.Output.Output)

	httpConfig := c.Output.Output.(http.Config)
	assert.True(t, httpConfig.Enabled)
	assert.Len(t, httpConfig.Endpoints, 2)
	assert.Contains(t, httpConfig.Endpoints, "http://localhost:8081")
	assert.Equal(t, time.Second*2, httpConfig.Timeout)
	assert.Equal(t, "http://192.168.1.8:3123", httpConfig.ProxyURL)
	assert.Equal(t, "bunny", httpConfig.ProxyUsername)
	assert.Equal(t, "bunny", httpConfig.ProxyPassword)
	assert.True(t, httpConfig.EnableGzip)
	assert.Equal(t, "basic", httpConfig.Username)
	assert.Equal(t, "basic", httpConfig.Password)
	assert.Len(t, httpConfig.Headers, 2)
	assert.Equal(t, "kkvvkk", httpConfig.Headers["api-key"])
}

func TestEventlogOutput(t *testing.T) {
	c := NewWithOpts(WithRun())

	err := c.flags.Parse([]string{"--config-file=_fixtures/eventlog-output.yml"})
	require.NoError(t, c.viper.BindPFlags(c.flags))
	require.NoError(t, err)
	require.NoError(t, c.TryLoadFile(c.GetConfigFile()))

	require.NoError(t, c.Init())

	require.NotNil(t, c.Output)
	require.IsType(t, eventlog.Config{}, c.Output.Output)

	eventlogConfig := c.Output.Output.(eventlog.Config)
	assert.True(t, eventlogConfig.Enabled)
	assert.Equal(t, "INFO", eventlogConfig.Level)
}

```

`pkg/config/print.go`:

```go
/*
 * Copyright 2019-2020 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package config

import (
	"bytes"
	"fmt"
	"reflect"
	"sort"
	"strings"
)

func (c *Config) printArray(arr []interface{}) string {
	var buffer bytes.Buffer
	for v := range arr {
		buffer.WriteString(fmt.Sprintf("%v;", v))
	}
	return buffer.String()
}

func (c *Config) printMap(m map[string]interface{}) string {
	var buffer bytes.Buffer
	buffer.WriteString("[")
	for k, v := range m {
		val := c.print(v)
		if len(val) > 0 {
			buffer.WriteString(" ")
			buffer.WriteString(k)
			buffer.WriteString("=>")
			if strings.Contains(k, "password") {
				buffer.WriteString("********")
			} else {
				buffer.WriteString(val)
			}
		}
	}
	buffer.WriteString("]")
	return buffer.String()
}

func (c *Config) print(value interface{}) string {
	t := reflect.TypeOf(value)
	switch t.Kind() {
	case reflect.Array:
		return c.printArray(value.([]interface{}))
	case reflect.Map:
		return c.printMap(value.(map[string]interface{}))
	default:
		return fmt.Sprintf("%v", value)
	}
}

func (c *Config) printLine(buffer *bytes.Buffer, maxLength int, key string, value string) {
	if value != "" {
		buffer.WriteString("\n\t")
		buffer.WriteString(key)
		buffer.WriteString(" ")
		buffer.WriteString(strings.Repeat(".", maxLength-len(key)+5))
		buffer.WriteString(" ")
		buffer.WriteString(value)
	}
}

// Print returns the string with all the config options pretty-printed.
func (c *Config) Print() string {
	opts := c.viper.AllSettings()

	var buffer bytes.Buffer
	var maxKeyLen = 20

	type kv struct {
		k string
		v interface{}
	}

	sorted := make([]kv, 0, len(opts))
	// for printing we need to find the max key length
	for key, v := range opts {
		if len(key) > maxKeyLen {
			maxKeyLen = len(key)
		}
		sorted = append(sorted, kv{k: key, v: v})
	}
	sort.Slice(sorted, func(i, j int) bool { return sorted[i].k < sorted[j].k })

	// print the options
	for _, kv := range sorted {
		c.printLine(&buffer, maxKeyLen, kv.k, c.print(kv.v))
	}

	return buffer.String()
}

```

`pkg/config/print_test.go`:

```go
/*
 * Copyright 2019-2020 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package config

import (
	"github.com/stretchr/testify/require"
	"testing"
)

func TestConfigPrint(t *testing.T) {
	c := NewWithOpts(WithRun())
	err := c.flags.Parse([]string{"--eventsource.enable-thread=false", "--config-file=_fixtures/fibratus.yml"})
	require.NoError(t, c.viper.BindPFlags(c.flags))
	require.NoError(t, err)
	require.NoError(t, c.TryLoadFile(c.GetConfigFile()))
	opts := c.Print()
	require.NotEmpty(t, opts)
}

```

`pkg/config/rules.schema.json`:

```json
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "type": "object",
  "properties": {
    "id": {
      "type": "string",
      "minLength": 36,
      "pattern": "^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$"
    },
    "version": {
      "type": "string",
      "minLength": 5,
      "pattern": "^([0-9]+.)([0-9]+.)([0-9]+)$"
    },
    "name": {
      "type": "string",
      "minLength": 3
    },
    "description": {
      "type": "string"
    },
    "output": {
      "type": "string",
      "minLength": 5
    },
    "notes": {
      "type": "string"
    },
    "severity": {
      "type": "string",
      "enum": [
        "low",
        "medium",
        "high",
        "critical"
      ]
    },
    "min-engine-version": {
      "type": "string",
      "minLength": 5,
      "pattern": "^([0-9]+.)([0-9]+.)([0-9]+)$"
    },
    "enabled": {
      "type": "boolean"
    },
    "condition": {
      "type": "string",
      "minLength": 3
    },
    "labels": {
      "type": "object",
      "additionalProperties": {
        "type": "string"
      }
    },
    "tags": {
      "type": "array",
      "items": [
        {
          "type": "string",
          "minLength": 1
        }
      ]
    },
    "references": {
      "type": "array",
      "items": [
        {
          "type": "string",
          "minLength": 1
        }
      ]
    },
    "authors": {
      "type": "array",
      "items": [
        {
          "type": "string",
          "minLength": 1
        }
      ]
    },
    "action": {
      "type": "array",
      "items": {
        "type": "object",
        "additionalProperties": false,
        "properties": {
          "name": {
            "type": "string",
            "enum": [
              "kill",
              "isolate"
            ]
          },
          "whitelist": true
        },
        "required": [
          "name"
        ],
        "if": {
          "properties": {
            "name": {
              "const": "isolate"
            }
          }
        },
        "then": {
          "properties": {
            "whitelist": {
              "type": "array",
              "minItems": 1,
              "items": {
                "type": "string",
                "format": "ipv4"
              }
            }
          }
        },
        "else": {
          "properties": {
            "name": {
              "type": "string",
              "enum": [
                "kill",
                "isolate"
              ]
            }
          },
          "additionalProperties": false
        }
      }
    }
  },
  "required": [
    "id",
    "version",
    "name",
    "condition",
    "min-engine-version"
  ],
  "additionalProperties": false
}

```

`pkg/config/schema_windows.go`:

```go
/*
 * Copyright 2019-2020 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package config

import (
	_ "embed"
)

//go:embed config.schema.json
var configSchema string

//go:embed rules.schema.json
var rulesSchema string

//go:embed macros.schema.json
var macrosSchema string

```

`pkg/config/transformer.go`:

```go
/*
 * Copyright 2019-2020 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package config

import (
	"fmt"
	"github.com/rabbitstack/fibratus/pkg/aggregator/transformers"
	"github.com/rabbitstack/fibratus/pkg/aggregator/transformers/remove"
	"github.com/rabbitstack/fibratus/pkg/aggregator/transformers/rename"
	"github.com/rabbitstack/fibratus/pkg/aggregator/transformers/replace"
	"github.com/rabbitstack/fibratus/pkg/aggregator/transformers/tags"
	"github.com/rabbitstack/fibratus/pkg/aggregator/transformers/trim"
	"reflect"
)

var errTransformerConfig = func(t string, err error) error { return fmt.Errorf("%s transformer invalid config: %v", t, err) }

func (c *Config) tryLoadTransformers() error {
	transforms := c.viper.AllSettings()["transformers"]
	if transforms == nil {
		return nil
	}
	mapping, ok := transforms.(map[string]interface{})
	if !ok {
		return fmt.Errorf("expected map[string]interface{} type for transformers but found %s", reflect.TypeOf(transforms))
	}

	configs := make([]transformers.Config, 0)

	for typ, config := range mapping {
		switch typ {
		case "remove":
			var removeConfig remove.Config
			if err := decode(config, &removeConfig); err != nil {
				return errTransformerConfig(typ, err)
			}
			if !removeConfig.Enabled {
				continue
			}
			config := transformers.Config{
				Type:        transformers.Remove,
				Transformer: removeConfig,
			}
			configs = append(configs, config)

		case "rename":
			var renameConfig rename.Config
			if err := decode(config, &renameConfig); err != nil {
				return errTransformerConfig(typ, err)
			}
			if !renameConfig.Enabled {
				continue
			}
			config := transformers.Config{
				Type:        transformers.Rename,
				Transformer: renameConfig,
			}
			configs = append(configs, config)

		case "replace":
			var replaceConfig replace.Config
			if err := decode(config, &replaceConfig); err != nil {
				return errTransformerConfig(typ, err)
			}
			if !replaceConfig.Enabled {
				continue
			}
			config := transformers.Config{
				Type:        transformers.Replace,
				Transformer: replaceConfig,
			}
			configs = append(configs, config)

		case "trim":
			var trimConfig trim.Config
			if err := decode(config, &trimConfig); err != nil {
				return errTransformerConfig(typ, err)
			}
			if !trimConfig.Enabled {
				continue
			}
			config := transformers.Config{
				Type:        transformers.Trim,
				Transformer: trimConfig,
			}
			configs = append(configs, config)

		case "tags":
			var tagsConfig tags.Config
			if err := decode(config, &tagsConfig); err != nil {
				return errTransformerConfig(typ, err)
			}
			if !tagsConfig.Enabled {
				continue
			}
			config := transformers.Config{
				Type:        transformers.Tags,
				Transformer: tagsConfig,
			}
			configs = append(configs, config)
		}
	}

	c.Transformers = configs

	return nil
}

```

`pkg/config/transformer_test.go`:

```go
/*
 * Copyright 2019-2020 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package config

import (
	"github.com/stretchr/testify/require"
	"testing"
)

func TestTransformers(t *testing.T) {
	c := NewWithOpts(WithRun())

	err := c.flags.Parse([]string{"--config-file=_fixtures/transformers.yml"})
	require.NoError(t, c.viper.BindPFlags(c.flags))
	require.NoError(t, err)
	require.NoError(t, c.TryLoadFile(c.GetConfigFile()))

	require.NoError(t, c.Init())

	require.Len(t, c.Transformers, 3)
}

```

`pkg/config/validation.go`:

```go
/*
 * Copyright 2019-2020 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package config

import (
	"fmt"
	"github.com/pkg/errors"
	"github.com/xeipuuv/gojsonschema"
)

func validate(s string, m interface{}) (bool, []error) {
	converted, err := convertToStringKeysRecursive(m, "")
	if err != nil {
		return false, []error{fmt.Errorf("fail to convert keys to string: %v", err)}
	}
	loader := gojsonschema.NewGoLoader(converted)
	sc := gojsonschema.NewStringLoader(s)
	r, err := gojsonschema.Validate(sc, loader)
	if err != nil {
		return false, []error{fmt.Errorf("fail to validate file through schema: %v", err)}
	}
	errs := make([]error, len(r.Errors()))
	for i, err := range r.Errors() {
		errs[i] = errors.New(err.String())
	}
	return r.Valid(), errs
}

// convertToStringKeysRecursive ensures keys are converted to strings for jsonschema.
func convertToStringKeysRecursive(value interface{}, keyPrefix string) (interface{}, error) {
	if mapping, ok := value.(map[string]interface{}); ok {
		dict := make(map[string]interface{})
		for str, entry := range mapping {
			var newKeyPrefix string
			if keyPrefix == "" {
				newKeyPrefix = str
			} else {
				newKeyPrefix = fmt.Sprintf("%s.%s", keyPrefix, str)
			}
			convertedEntry, err := convertToStringKeysRecursive(entry, newKeyPrefix)
			if err != nil {
				return nil, err
			}
			dict[str] = convertedEntry
		}
		return dict, nil
	}
	if mapping, ok := value.(map[interface{}]interface{}); ok {
		dict := make(map[string]interface{})
		for key, entry := range mapping {
			str, ok := key.(string)
			if !ok {
				return nil, formatInvalidKeyError(keyPrefix, key)
			}
			var newKeyPrefix string
			if keyPrefix == "" {
				newKeyPrefix = str
			} else {
				newKeyPrefix = fmt.Sprintf("%s.%s", keyPrefix, str)
			}
			convertedEntry, err := convertToStringKeysRecursive(entry, newKeyPrefix)
			if err != nil {
				return nil, err
			}
			dict[str] = convertedEntry
		}
		return dict, nil
	}
	if list, ok := value.([]interface{}); ok {
		var convertedList []interface{}
		for index, entry := range list {
			newKeyPrefix := fmt.Sprintf("%s[%d]", keyPrefix, index)
			convertedEntry, err := convertToStringKeysRecursive(entry, newKeyPrefix)
			if err != nil {
				return nil, err
			}
			convertedList = append(convertedList, convertedEntry)
		}
		return convertedList, nil
	}
	return value, nil
}

func formatInvalidKeyError(keyPrefix string, key interface{}) error {
	var location string
	if keyPrefix == "" {
		location = "at top level"
	} else {
		location = fmt.Sprintf("in %s", keyPrefix)
	}
	return errors.Errorf("non-string key %s: %#v", location, key)
}

```

`pkg/config/validation_test.go`:

```go
/*
 * Copyright 2019-2020 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package config

import (
	"gopkg.in/yaml.v3"
	"testing"
)

func TestValidate(t *testing.T) {
	var tests = []struct {
		text  string
		valid bool
		errs  int
	}{
		{text: `aggregator:
                 flush-period: 20ms
                 flush-timeout: 1s`, valid: true},
		{text: `aggregator:
                 flush-period: 20
                 flush-timeout: 1s`, valid: false, errs: 1},
		{text: `aggregator:
                 flush-perio: 20ms
                 flush-timeout: 1`, valid: false, errs: 2},

		{text: `alertsenders:
                 mail: 
                  enabled: true
                  host: smtp.gmail.com
                  port: 465
                  user: user
                  password: pas$
                  from: from@mail.com
                  to:
                   - to@mail.com
                 slack:
                  enabled: true
                  url: https://slack.url
                  workspace: fibratus
                  channel: fibratus
                  emoji: ""`, valid: true},
		{text: `alertsenders:
                 mail: 
                  enabled: true
                  host: smtp.gmail.com
                  port: 
                  user: user
                  pass: pas$
                  from: from@mail.com
                  to:
                   - invalidmail@
                 slack:
                  enabled: true
                  url: https://slack.url
                  workspace: fibratus
                  channel: fibratus
                  emoji: ""`, valid: false, errs: 6},
		{text: `api:
                 transport: "" 
                 timeout: 1s`, valid: false, errs: 1},
	}

	for i, tt := range tests {
		var m interface{}
		err := yaml.Unmarshal([]byte(tt.text), &m)
		if err != nil {
			t.Fatal(err)
		}
		valid, errs := validate(configSchema, m)
		if valid != tt.valid {
			t.Errorf("%d. valid mismatch: text=%q exp=%#v got=%#v errs=%#v", i, tt.text, tt.valid, valid, errs)
		} else if len(errs) != tt.errs {
			t.Errorf("%d. error count mismatch: text=%q exp=%#v got=%#v errs=%#v", i, tt.text, tt.errs, len(errs), errs)
		}
	}
}

```

`pkg/errors/errors.go`:

```go
/*
 * Copyright 2020-2021 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package errors

import (
	"fmt"
)

var (
	// ErrFeatureUnsupported is thrown when a certain feature was not triggered via the build flag
	ErrFeatureUnsupported = func(s string) error {
		return fmt.Errorf("fibratus was compiled without %s support. Please compile with the '%s' build flag", s, s)
	}

	// ErrHTTPServerUnavailable signals that the HTTP server is not running on the specified transport
	ErrHTTPServerUnavailable = func(transport string, err error) error {
		return fmt.Errorf("fibratus API server up and running on %s? %v", transport, err)
	}
)

// ErrParamNotFound is the error is thrown when a parameter is not present in the list of parameters
type ErrParamNotFound struct {
	Name string
}

// Error returns the error message.
func (e ErrParamNotFound) Error() string {
	return "couldn't find '" + e.Name + "' in event parameters"
}

// IsParamNotFound returns true if the error is ErrParamNotFound.
func IsParamNotFound(err error) bool {
	switch err.(type) {
	case *ErrParamNotFound:
		return true
	default:
		return false
	}
}

```

`pkg/errors/errors_windows.go`:

```go
/*
 * Copyright 2019-2020 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package errors

import (
	"errors"
)

var (
	// ErrTraceAccessDenied is returned when user doesn't have enough privileges to start the trace
	ErrTraceAccessDenied = errors.New("not enough privileges to start the trace. Only users with administrative privileges or users in the Performance Log Users group can start kernel traces")
	// ErrTraceInvalidParameter signals invalid values for trace session
	ErrTraceInvalidParameter = errors.New("trace has invalid values")
	// ErrTraceBadLength signals an incorrect size for internal structure buffer
	ErrTraceBadLength = errors.New("incorrect size of internal structure buffer")
	// ErrTraceNoSysResources signals that the maximum number of logging sessions has been reached
	ErrTraceNoSysResources = errors.New("maximum number of logging sessions has been reached")
	// ErrTraceDiskFull signals that there is not enough space on disk for the log file. Should never happen for real-time loggers
	ErrTraceDiskFull = errors.New("not enough disk space for writing to log file")
	// ErrInvalidTrace signals invalid trace handle
	ErrInvalidTrace = errors.New("invalid trace handle")
	// ErrRestartTrace signals an error that is thrown when currently running trace cannot be restarted
	ErrRestartTrace = errors.New("couldn't restart an already running trace")
	// ErrTraceAlreadyRunning identifies trace already running errors
	ErrTraceAlreadyRunning = errors.New("trace is already running")
	// ErrEventCallbackException signals that an exception has occurred in the event processing function
	ErrEventCallbackException = errors.New("an exception occurred in the event callback function")
	// ErrSessionNotRunning is thrown when session from which consumer is trying to collect events is not running
	ErrSessionNotRunning = errors.New("session from which you are trying to consume events in real time is not running")
	// ErrTraceCancelled is thrown when in-progress event trace is cancelled
	ErrTraceCancelled = errors.New("event trace has been cancelled")
)

```

`pkg/event/_fixtures/handles.json`:

```json
[
	{
		"id": 4,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 8,
		"object": 0,
		"type": "Key",
		"name": "HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Image File Execution Options"
	},
	{
		"id": 16,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 20,
		"object": 0,
		"type": "WaitCompletionPacket",
		"name": ""
	},
	{
		"id": 24,
		"object": 0,
		"type": "IoCompletion",
		"name": ""
	},
	{
		"id": 28,
		"object": 0,
		"type": "TpWorkerFactory",
		"name": ""
	},
	{
		"id": 32,
		"object": 0,
		"type": "IRTimer",
		"name": ""
	},
	{
		"id": 36,
		"object": 0,
		"type": "WaitCompletionPacket",
		"name": ""
	},
	{
		"id": 40,
		"object": 0,
		"type": "IRTimer",
		"name": ""
	},
	{
		"id": 44,
		"object": 0,
		"type": "WaitCompletionPacket",
		"name": ""
	},
	{
		"id": 60,
		"object": 0,
		"type": "Directory",
		"name": "\\KnownDlls"
	},
	{
		"id": 64,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 68,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 88,
		"object": 0,
		"type": "Key",
		"name": "HKEY_LOCAL_MACHINE\\SYSTEM\\ControlSet001\\Control\\Session Manager"
	},
	{
		"id": 92,
		"object": 0,
		"type": "ALPC Port",
		"name": "",
		"meta": {
			"Flags": 196608,
			"Seqno": 77,
			"Context": 92
		}
	},
	{
		"id": 100,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 104,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 108,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 112,
		"object": 0,
		"type": "Key",
		"name": "HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\MSF\\Registration\\Listen"
	},
	{
		"id": 116,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 124,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 128,
		"object": 0,
		"type": "Key",
		"name": "HKEY_LOCAL_MACHINE\\SYSTEM\\ControlSet001\\Control\\Nls\\Sorting\\Versions"
	},
	{
		"id": 140,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 144,
		"object": 0,
		"type": "WaitCompletionPacket",
		"name": ""
	},
	{
		"id": 148,
		"object": 0,
		"type": "Key",
		"name": "HKEY_LOCAL_MACHINE"
	},
	{
		"id": 152,
		"object": 0,
		"type": "Key",
		"name": "HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Ole"
	},
	{
		"id": 156,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 160,
		"object": 0,
		"type": "Key",
		"name": "HKEY_CURRENT_USER\\Classes\\Local Settings\\Software\\Microsoft"
	},
	{
		"id": 164,
		"object": 0,
		"type": "Key",
		"name": "HKEY_CURRENT_USER\\Classes\\Local Settings"
	},
	{
		"id": 168,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 180,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 188,
		"object": 0,
		"type": "Directory",
		"name": "\\Sessions\\1\\BaseNamedObjects"
	},
	{
		"id": 232,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 236,
		"object": 0,
		"type": "IoCompletion",
		"name": ""
	},
	{
		"id": 240,
		"object": 0,
		"type": "WindowStation",
		"name": "\\Sessions\\1\\Windows\\WindowStations\\WinSta0"
	},
	{
		"id": 244,
		"object": 0,
		"type": "Desktop",
		"name": "\\Default"
	},
	{
		"id": 248,
		"object": 0,
		"type": "WindowStation",
		"name": "\\Sessions\\1\\Windows\\WindowStations\\WinSta0"
	},
	{
		"id": 396,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 408,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 420,
		"object": 0,
		"type": "Mutant",
		"name": "",
		"meta": {
			"Count": 1,
			"IsAbandoned": false
		}
	},
	{
		"id": 424,
		"object": 0,
		"type": "Semaphore",
		"name": ""
	},
	{
		"id": 428,
		"object": 0,
		"type": "Semaphore",
		"name": ""
	},
	{
		"id": 488,
		"object": 0,
		"type": "Semaphore",
		"name": ""
	},
	{
		"id": 492,
		"object": 0,
		"type": "Semaphore",
		"name": ""
	},
	{
		"id": 536,
		"object": 0,
		"type": "Semaphore",
		"name": "\\Sessions\\1\\BaseNamedObjects\\SM0:9308:304:WilStaging_02_p0"
	},
	{
		"id": 540,
		"object": 0,
		"type": "Semaphore",
		"name": "\\Sessions\\1\\BaseNamedObjects\\SM0:9308:304:WilStaging_02_p0h"
	},
	{
		"id": 576,
		"object": 0,
		"type": "Key",
		"name": "HKEY_CURRENT_USER"
	},
	{
		"id": 580,
		"object": 0,
		"type": "ALPC Port",
		"name": "",
		"meta": {
			"Flags": 196608,
			"Seqno": 1,
			"Context": 580
		}
	},
	{
		"id": 588,
		"object": 0,
		"type": "Key",
		"name": "HKEY_CURRENT_USER\\Software\\Microsoft\\Windows\\CurrentVersion\\Explorer"
	},
	{
		"id": 592,
		"object": 0,
		"type": "Key",
		"name": "HKEY_LOCAL_MACHINE\\SYSTEM\\ControlSet001\\Control\\Nls\\Sorting\\Ids"
	},
	{
		"id": 596,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 624,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 628,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 632,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 648,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 664,
		"object": 0,
		"type": "Section",
		"name": "\\Sessions\\1\\BaseNamedObjects\\245cHWNDInterface:4040c"
	},
	{
		"id": 668,
		"object": 0,
		"type": "Mutant",
		"name": "",
		"meta": {
			"Count": 1,
			"IsAbandoned": false
		}
	},
	{
		"id": 672,
		"object": 0,
		"type": "Section",
		"name": "\\Sessions\\1\\BaseNamedObjects\\SessionImmersiveColorPreference"
	},
	{
		"id": 684,
		"object": 0,
		"type": "Key",
		"name": "HKEY_CURRENT_USER\\Classes"
	},
	{
		"id": 688,
		"object": 0,
		"type": "Section",
		"name": "\\BaseNamedObjects\\__ComCatalogCache__"
	},
	{
		"id": 696,
		"object": 0,
		"type": "Event",
		"name": "\\KernelObjects\\MaximumCommitCondition"
	},
	{
		"id": 700,
		"object": 0,
		"type": "Section",
		"name": "\\BaseNamedObjects\\__ComCatalogCache__"
	},
	{
		"id": 708,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 712,
		"object": 0,
		"type": "Key",
		"name": "HKEY_CURRENT_USER\\Classes"
	},
	{
		"id": 716,
		"object": 0,
		"type": "Key",
		"name": "HKEY_CURRENT_USER\\Classes"
	},
	{
		"id": 724,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 728,
		"object": 0,
		"type": "Semaphore",
		"name": ""
	},
	{
		"id": 748,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 752,
		"object": 0,
		"type": "Section",
		"name": "\\Sessions\\1\\BaseNamedObjects\\windows_shell_global_counters"
	},
	{
		"id": 756,
		"object": 0,
		"type": "Mutant",
		"name": "",
		"meta": {
			"Count": 1,
			"IsAbandoned": false
		}
	},
	{
		"id": 760,
		"object": 0,
		"type": "Semaphore",
		"name": "\\Sessions\\1\\BaseNamedObjects\\SM0:9308:120:WilError_02_p0h"
	},
	{
		"id": 764,
		"object": 0,
		"type": "Key",
		"name": "HKEY_CURRENT_USER\\Software\\Microsoft\\Windows\\CurrentVersion\\Explorer"
	},
	{
		"id": 768,
		"object": 0,
		"type": "Semaphore",
		"name": "\\Sessions\\1\\BaseNamedObjects\\SM0:9308:120:WilError_02_p0"
	},
	{
		"id": 772,
		"object": 0,
		"type": "Key",
		"name": "HKEY_CURRENT_USER\\Classes"
	},
	{
		"id": 780,
		"object": 0,
		"type": "Section",
		"name": "\\BaseNamedObjects\\windows_shell_global_counters"
	},
	{
		"id": 784,
		"object": 0,
		"type": "Key",
		"name": "HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Explorer\\FolderDescriptions\\{B4BFCC3A-DB2C-424C-B029-7FE99A87C641}\\PropertyBag"
	},
	{
		"id": 788,
		"object": 0,
		"type": "Thread",
		"name": ""
	},
	{
		"id": 792,
		"object": 0,
		"type": "Key",
		"name": "HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Explorer\\FolderDescriptions\\{f42ee2d3-909f-4907-8871-4c22fc0bf756}\\PropertyBag"
	},
	{
		"id": 796,
		"object": 0,
		"type": "Key",
		"name": "HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Explorer\\FolderDescriptions\\{a0c69a99-21c8-4671-8703-7934162fcf1d}\\PropertyBag"
	},
	{
		"id": 800,
		"object": 0,
		"type": "Key",
		"name": "HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Explorer\\FolderDescriptions\\{0ddd015d-b06c-45d5-8c4c-f59713854639}\\PropertyBag"
	},
	{
		"id": 804,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 808,
		"object": 0,
		"type": "Key",
		"name": "HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Explorer\\FolderDescriptions\\{35286a68-3c57-41a1-bbb1-0eae73d76c95}\\PropertyBag"
	},
	{
		"id": 812,
		"object": 0,
		"type": "Key",
		"name": "HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Explorer\\FolderDescriptions\\{7d83ee9b-2244-4e70-b1f5-5393042af1e4}\\PropertyBag"
	},
	{
		"id": 816,
		"object": 0,
		"type": "ALPC Port",
		"name": "",
		"meta": {
			"Flags": 34078720,
			"Seqno": 662,
			"Context": 5849088
		}
	},
	{
		"id": 824,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 832,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 836,
		"object": 0,
		"type": "Event",
		"name": "\\BaseNamedObjects\\StateRepository.SecondaryTileUserNotificationChannel.{45F7AD0F-AB53-4EB1-B5A8-7091C8251662}"
	},
	{
		"id": 844,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 848,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 852,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 856,
		"object": 0,
		"type": "Key",
		"name": "HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\WindowsRuntime"
	},
	{
		"id": 860,
		"object": 0,
		"type": "ALPC Port",
		"name": "",
		"meta": {
			"Flags": 34144256,
			"Seqno": 20385,
			"Context": 860
		}
	},
	{
		"id": 864,
		"object": 0,
		"type": "Section",
		"name": "\\Sessions\\1\\BaseNamedObjects\\245cHWNDInterface:890794"
	},
	{
		"id": 868,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 872,
		"object": 0,
		"type": "ALPC Port",
		"name": "",
		"meta": {
			"Flags": 34209792,
			"Seqno": 46,
			"Context": 0
		}
	},
	{
		"id": 880,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 884,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 888,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 892,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 896,
		"object": 0,
		"type": "Timer",
		"name": ""
	},
	{
		"id": 900,
		"object": 0,
		"type": "Mutant",
		"name": "",
		"meta": {
			"Count": 1,
			"IsAbandoned": false
		}
	},
	{
		"id": 904,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 912,
		"object": 0,
		"type": "Thread",
		"name": ""
	},
	{
		"id": 916,
		"object": 0,
		"type": "Key",
		"name": "HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\WindowsRuntime\\ActivatableClassId"
	},
	{
		"id": 928,
		"object": 0,
		"type": "ALPC Port",
		"name": "",
		"meta": {
			"Flags": 458752,
			"Seqno": 2,
			"Context": 928
		}
	},
	{
		"id": 940,
		"object": 0,
		"type": "Key",
		"name": "HKEY_CURRENT_USER\\Software\\Microsoft\\MSF\\Registration\\Listen"
	},
	{
		"id": 944,
		"object": 0,
		"type": "Thread",
		"name": ""
	},
	{
		"id": 952,
		"object": 0,
		"type": "Token",
		"name": ""
	},
	{
		"id": 956,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 960,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 972,
		"object": 0,
		"type": "WaitCompletionPacket",
		"name": ""
	},
	{
		"id": 976,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 980,
		"object": 0,
		"type": "Thread",
		"name": ""
	},
	{
		"id": 984,
		"object": 0,
		"type": "ALPC Port",
		"name": "",
		"meta": {
			"Flags": 34144256,
			"Seqno": 45,
			"Context": 984
		}
	},
	{
		"id": 996,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 1004,
		"object": 0,
		"type": "Key",
		"name": "HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\WindowsRuntime\\Server"
	},
	{
		"id": 1008,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 1016,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 1020,
		"object": 0,
		"type": "ALPC Port",
		"name": "",
		"meta": {
			"Flags": 34078720,
			"Seqno": 3,
			"Context": 100344272
		}
	},
	{
		"id": 1032,
		"object": 0,
		"type": "Semaphore",
		"name": ""
	},
	{
		"id": 1036,
		"object": 0,
		"type": "Semaphore",
		"name": ""
	},
	{
		"id": 1040,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 1064,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 1068,
		"object": 0,
		"type": "Section",
		"name": "\\Sessions\\1\\BaseNamedObjects\\245cHWNDInterface:404e6"
	},
	{
		"id": 1084,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 1088,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 1092,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 1096,
		"object": 0,
		"type": "IoCompletion",
		"name": ""
	},
	{
		"id": 1104,
		"object": 0,
		"type": "IoCompletion",
		"name": ""
	},
	{
		"id": 1108,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 1112,
		"object": 0,
		"type": "IoCompletion",
		"name": ""
	},
	{
		"id": 1120,
		"object": 0,
		"type": "Section",
		"name": "\\Sessions\\1\\BaseNamedObjects\\C:*Users*bunny*AppData*Local*Microsoft*Windows*Caches*cversions.3.ro"
	},
	{
		"id": 1132,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 1172,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 1184,
		"object": 0,
		"type": "Key",
		"name": "HKEY_LOCAL_MACHINE\\SYSTEM\\ControlSet001\\Services\\Tcpip\\Parameters\\Interfaces"
	},
	{
		"id": 1188,
		"object": 0,
		"type": "Key",
		"name": "HKEY_LOCAL_MACHINE\\SYSTEM\\ControlSet001\\Services\\Tcpip6\\Parameters\\Interfaces"
	},
	{
		"id": 1212,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 1224,
		"object": 0,
		"type": "ALPC Port",
		"name": "",
		"meta": {
			"Flags": 34144256,
			"Seqno": 4,
			"Context": 1224
		}
	},
	{
		"id": 1228,
		"object": 0,
		"type": "ALPC Port",
		"name": "",
		"meta": {
			"Flags": 34078720,
			"Seqno": 36,
			"Context": 100339568
		}
	},
	{
		"id": 1232,
		"object": 0,
		"type": "Key",
		"name": "HKEY_LOCAL_MACHINE\\SOFTWARE\\Classes\\Local Settings\\Software\\Microsoft\\Windows\\CurrentVersion\\AppModel\\Deployment\\Package\\*\\S-1-5-21-2271034452-2606270099-984871569-1001\\{A2595E0B-CF05-4E86-A18B-7B8B98616B5F}"
	},
	{
		"id": 1236,
		"object": 0,
		"type": "WaitCompletionPacket",
		"name": ""
	},
	{
		"id": 1240,
		"object": 0,
		"type": "IoCompletion",
		"name": ""
	},
	{
		"id": 1244,
		"object": 0,
		"type": "TpWorkerFactory",
		"name": ""
	},
	{
		"id": 1248,
		"object": 0,
		"type": "IRTimer",
		"name": ""
	},
	{
		"id": 1252,
		"object": 0,
		"type": "WaitCompletionPacket",
		"name": ""
	},
	{
		"id": 1256,
		"object": 0,
		"type": "IRTimer",
		"name": ""
	},
	{
		"id": 1260,
		"object": 0,
		"type": "WaitCompletionPacket",
		"name": ""
	},
	{
		"id": 1268,
		"object": 0,
		"type": "ALPC Port",
		"name": "",
		"meta": {
			"Flags": 34144256,
			"Seqno": 5931,
			"Context": 1268
		}
	},
	{
		"id": 1272,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 1276,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 1280,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 1296,
		"object": 0,
		"type": "IoCompletion",
		"name": ""
	},
	{
		"id": 1304,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 1308,
		"object": 0,
		"type": "Thread",
		"name": ""
	},
	{
		"id": 1312,
		"object": 0,
		"type": "Event",
		"name": "\\BaseNamedObjects\\TermSrvReadyEvent"
	},
	{
		"id": 1320,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 1360,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 1364,
		"object": 0,
		"type": "ALPC Port",
		"name": "",
		"meta": {
			"Flags": 34144256,
			"Seqno": 22,
			"Context": 1364
		}
	},
	{
		"id": 1368,
		"object": 0,
		"type": "Mutant",
		"name": "",
		"meta": {
			"Count": 1,
			"IsAbandoned": false
		}
	},
	{
		"id": 1372,
		"object": 0,
		"type": "Mutant",
		"name": "",
		"meta": {
			"Count": 1,
			"IsAbandoned": false
		}
	},
	{
		"id": 1388,
		"object": 0,
		"type": "Section",
		"name": "\\Windows\\Theme4136432297"
	},
	{
		"id": 1392,
		"object": 0,
		"type": "Section",
		"name": "\\Sessions\\1\\Windows\\Theme4282677873"
	},
	{
		"id": 1396,
		"object": 0,
		"type": "Section",
		"name": "\\Sessions\\1\\BaseNamedObjects\\245cHWNDInterface:100e4"
	},
	{
		"id": 1400,
		"object": 0,
		"type": "Section",
		"name": ""
	},
	{
		"id": 1404,
		"object": 0,
		"type": "Event",
		"name": "\\BaseNamedObjects\\StateRepository.SecondaryTileUserNotificationChannel.{55CC93E3-1E5B-40A9-BD6A-6705CAFF7649}"
	},
	{
		"id": 1408,
		"object": 0,
		"type": "WaitCompletionPacket",
		"name": ""
	},
	{
		"id": 1416,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 1420,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 1432,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 1440,
		"object": 0,
		"type": "Section",
		"name": ""
	},
	{
		"id": 1452,
		"object": 0,
		"type": "Section",
		"name": ""
	},
	{
		"id": 1460,
		"object": 0,
		"type": "Section",
		"name": "\\Sessions\\1\\BaseNamedObjects\\245cHWNDInterface:100e4"
	},
	{
		"id": 1500,
		"object": 0,
		"type": "Section",
		"name": "\\Sessions\\1\\BaseNamedObjects\\SessionImmersiveColorPreference"
	},
	{
		"id": 1548,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 1552,
		"object": 0,
		"type": "Thread",
		"name": ""
	},
	{
		"id": 1556,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 1560,
		"object": 0,
		"type": "WaitCompletionPacket",
		"name": ""
	},
	{
		"id": 1568,
		"object": 0,
		"type": "Mutant",
		"name": "",
		"meta": {
			"Count": 1,
			"IsAbandoned": false
		}
	},
	{
		"id": 1572,
		"object": 0,
		"type": "Mutant",
		"name": "",
		"meta": {
			"Count": 1,
			"IsAbandoned": false
		}
	},
	{
		"id": 1580,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 1584,
		"object": 0,
		"type": "Semaphore",
		"name": ""
	},
	{
		"id": 1588,
		"object": 0,
		"type": "Semaphore",
		"name": ""
	},
	{
		"id": 1592,
		"object": 0,
		"type": "Semaphore",
		"name": ""
	},
	{
		"id": 1596,
		"object": 0,
		"type": "Semaphore",
		"name": ""
	},
	{
		"id": 1600,
		"object": 0,
		"type": "Semaphore",
		"name": ""
	},
	{
		"id": 1604,
		"object": 0,
		"type": "Semaphore",
		"name": ""
	},
	{
		"id": 1608,
		"object": 0,
		"type": "Semaphore",
		"name": ""
	},
	{
		"id": 1612,
		"object": 0,
		"type": "Semaphore",
		"name": ""
	},
	{
		"id": 1636,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 1640,
		"object": 0,
		"type": "IoCompletion",
		"name": ""
	},
	{
		"id": 1648,
		"object": 0,
		"type": "WaitCompletionPacket",
		"name": ""
	},
	{
		"id": 1656,
		"object": 0,
		"type": "Section",
		"name": "\\Sessions\\1\\BaseNamedObjects\\C:*ProgramData*Microsoft*Windows*Caches*cversions.2.ro"
	},
	{
		"id": 1660,
		"object": 0,
		"type": "Section",
		"name": "\\Sessions\\1\\BaseNamedObjects\\C:*ProgramData*Microsoft*Windows*Caches*cversions.2.ro"
	},
	{
		"id": 1664,
		"object": 0,
		"type": "Section",
		"name": "\\Sessions\\1\\BaseNamedObjects\\C:*ProgramData*Microsoft*Windows*Caches*{6AF0698E-D558-4F6E-9B3C-3716689AF493}.2.ver0x0000000000000001.db"
	},
	{
		"id": 1668,
		"object": 0,
		"type": "Section",
		"name": "\\Sessions\\1\\BaseNamedObjects\\C:*ProgramData*Microsoft*Windows*Caches*{DDF571F2-BE98-426D-8288-1A9A39C3FDA2}.2.ver0x0000000000000001.db"
	},
	{
		"id": 1688,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 1692,
		"object": 0,
		"type": "Section",
		"name": ""
	},
	{
		"id": 1696,
		"object": 0,
		"type": "Key",
		"name": "HKEY_CURRENT_USER\\Software\\Microsoft\\Windows\\CurrentVersion\\Internet Settings\\5.0\\Cache\\Extensible Cache"
	},
	{
		"id": 1700,
		"object": 0,
		"type": "Key",
		"name": "HKEY_CURRENT_USER\\Software\\Microsoft\\Windows\\CurrentVersion\\Internet Settings"
	},
	{
		"id": 1704,
		"object": 0,
		"type": "Key",
		"name": "HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Internet Settings"
	},
	{
		"id": 1708,
		"object": 0,
		"type": "Key",
		"name": "HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Internet Explorer\\Main\\FeatureControl"
	},
	{
		"id": 1712,
		"object": 0,
		"type": "Key",
		"name": "HKEY_CURRENT_USER\\Software\\Microsoft\\Internet Explorer\\Main\\FeatureControl"
	},
	{
		"id": 1716,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 1724,
		"object": 0,
		"type": "Section",
		"name": "\\Sessions\\1\\BaseNamedObjects\\245cHWNDInterface:1010a"
	},
	{
		"id": 1732,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 1740,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 1744,
		"object": 0,
		"type": "WaitCompletionPacket",
		"name": ""
	},
	{
		"id": 1748,
		"object": 0,
		"type": "Thread",
		"name": ""
	},
	{
		"id": 1760,
		"object": 0,
		"type": "Section",
		"name": "\\Sessions\\1\\BaseNamedObjects\\245cHWNDInterface:1010a"
	},
	{
		"id": 1764,
		"object": 0,
		"type": "Section",
		"name": "\\Sessions\\1\\BaseNamedObjects\\245cHWNDInterface:10104"
	},
	{
		"id": 1768,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 1776,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 1780,
		"object": 0,
		"type": "Thread",
		"name": ""
	},
	{
		"id": 1788,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 1792,
		"object": 0,
		"type": "Key",
		"name": "HKEY_CURRENT_USER\\Software\\Microsoft\\Windows\\Shell\\Bags\\1\\Desktop"
	},
	{
		"id": 1796,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 1800,
		"object": 0,
		"type": "Key",
		"name": "HKEY_CURRENT_USER\\Software\\Microsoft\\Windows\\Shell"
	},
	{
		"id": 1804,
		"object": 0,
		"type": "ALPC Port",
		"name": "",
		"meta": {
			"Flags": 393216,
			"Seqno": 2107,
			"Context": 1804
		}
	},
	{
		"id": 1808,
		"object": 0,
		"type": "Key",
		"name": "HKEY_LOCAL_MACHINE\\SOFTWARE\\Classes\\PackagedCom\\ClassIndex"
	},
	{
		"id": 1816,
		"object": 0,
		"type": "ALPC Port",
		"name": "",
		"meta": {
			"Flags": 34144256,
			"Seqno": 15,
			"Context": 1816
		}
	},
	{
		"id": 1824,
		"object": 0,
		"type": "Key",
		"name": "HKEY_LOCAL_MACHINE\\SOFTWARE\\Classes\\PackagedCom"
	},
	{
		"id": 1836,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 1844,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 1860,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 1864,
		"object": 0,
		"type": "Key",
		"name": "HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Explorer\\FolderDescriptions\\{FDD39AD0-238F-46AF-ADB4-6C85480369C7}\\PropertyBag"
	},
	{
		"id": 1868,
		"object": 0,
		"type": "IoCompletion",
		"name": ""
	},
	{
		"id": 1872,
		"object": 0,
		"type": "Key",
		"name": "HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Explorer\\FolderDescriptions\\{FD228CB7-AE11-4AE3-864C-16F3910AB8FE}\\PropertyBag"
	},
	{
		"id": 1876,
		"object": 0,
		"type": "Section",
		"name": "\\Sessions\\1\\BaseNamedObjects\\245cHWNDInterface:10104"
	},
	{
		"id": 1880,
		"object": 0,
		"type": "Key",
		"name": "HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Explorer\\FolderDescriptions\\{F38BF404-1D43-42F2-9305-67DE0B28FC23}\\PropertyBag"
	},
	{
		"id": 1884,
		"object": 0,
		"type": "Key",
		"name": "HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Explorer\\FolderDescriptions\\{1AC14E77-02E7-4E5D-B744-2EB1AE5198B7}\\PropertyBag"
	},
	{
		"id": 1892,
		"object": 0,
		"type": "Key",
		"name": "HKEY_CURRENT_USER\\Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\FileExts"
	},
	{
		"id": 1896,
		"object": 0,
		"type": "Semaphore",
		"name": ""
	},
	{
		"id": 1900,
		"object": 0,
		"type": "Thread",
		"name": ""
	},
	{
		"id": 1904,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 1924,
		"object": 0,
		"type": "Section",
		"name": ""
	},
	{
		"id": 1928,
		"object": 0,
		"type": "Thread",
		"name": ""
	},
	{
		"id": 1932,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 1936,
		"object": 0,
		"type": "Thread",
		"name": ""
	},
	{
		"id": 1944,
		"object": 0,
		"type": "Thread",
		"name": ""
	},
	{
		"id": 1964,
		"object": 0,
		"type": "Key",
		"name": "HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows\\Shell"
	},
	{
		"id": 1968,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 1972,
		"object": 0,
		"type": "Key",
		"name": "HKEY_CURRENT_USER\\Classes\\Local Settings\\Software\\Microsoft\\Windows\\Shell"
	},
	{
		"id": 1984,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 1988,
		"object": 0,
		"type": "Mutant",
		"name": "",
		"meta": {
			"Count": 1,
			"IsAbandoned": false
		}
	},
	{
		"id": 1992,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 2000,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 2004,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 2008,
		"object": 0,
		"type": "Mutant",
		"name": "",
		"meta": {
			"Count": 1,
			"IsAbandoned": false
		}
	},
	{
		"id": 2012,
		"object": 0,
		"type": "ALPC Port",
		"name": "",
		"meta": {
			"Flags": 34144256,
			"Seqno": 278,
			"Context": 2012
		}
	},
	{
		"id": 2016,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 2028,
		"object": 0,
		"type": "Key",
		"name": "HKEY_LOCAL_MACHINE\\SOFTWARE\\Classes\\CLSID\\{A8CDFF1C-4878-43be-B5FD-F8091C1C60D0}\\Instance"
	},
	{
		"id": 2036,
		"object": 0,
		"type": "Event",
		"name": "\\BaseNamedObjects\\CfProgressEvent"
	},
	{
		"id": 2040,
		"object": 0,
		"type": "Timer",
		"name": ""
	},
	{
		"id": 2044,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 2052,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 2056,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 2060,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 2064,
		"object": 0,
		"type": "Thread",
		"name": ""
	},
	{
		"id": 2068,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 2072,
		"object": 0,
		"type": "Section",
		"name": "\\Sessions\\1\\BaseNamedObjects\\245cHWNDInterface:100ec"
	},
	{
		"id": 2076,
		"object": 0,
		"type": "Section",
		"name": "\\Sessions\\1\\BaseNamedObjects\\245cHWNDInterface:100ec"
	},
	{
		"id": 2084,
		"object": 0,
		"type": "Semaphore",
		"name": ""
	},
	{
		"id": 2088,
		"object": 0,
		"type": "ALPC Port",
		"name": "",
		"meta": {
			"Flags": 34144256,
			"Seqno": 714,
			"Context": 2088
		}
	},
	{
		"id": 2092,
		"object": 0,
		"type": "IoCompletion",
		"name": ""
	},
	{
		"id": 2100,
		"object": 0,
		"type": "ALPC Port",
		"name": "",
		"meta": {
			"Flags": 34078720,
			"Seqno": 206,
			"Context": 67769888
		}
	},
	{
		"id": 2104,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 2108,
		"object": 0,
		"type": "Key",
		"name": "HKEY_CURRENT_USER\\Control Panel\\Desktop"
	},
	{
		"id": 2112,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 2116,
		"object": 0,
		"type": "WaitCompletionPacket",
		"name": ""
	},
	{
		"id": 2120,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 2124,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 2128,
		"object": 0,
		"type": "Semaphore",
		"name": ""
	},
	{
		"id": 2132,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 2136,
		"object": 0,
		"type": "Thread",
		"name": ""
	},
	{
		"id": 2144,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 2148,
		"object": 0,
		"type": "ALPC Port",
		"name": "",
		"meta": {
			"Flags": 393216,
			"Seqno": 1,
			"Context": 2148
		}
	},
	{
		"id": 2152,
		"object": 0,
		"type": "Thread",
		"name": ""
	},
	{
		"id": 2180,
		"object": 0,
		"type": "Mutant",
		"name": "",
		"meta": {
			"Count": 1,
			"IsAbandoned": false
		}
	},
	{
		"id": 2188,
		"object": 0,
		"type": "Mutant",
		"name": "",
		"meta": {
			"Count": 1,
			"IsAbandoned": false
		}
	},
	{
		"id": 2204,
		"object": 0,
		"type": "Key",
		"name": "HKEY_CURRENT_USER\\Software\\Microsoft\\Windows\\Shell\\Bags\\1\\Desktop"
	},
	{
		"id": 2272,
		"object": 0,
		"type": "Key",
		"name": "HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Explorer\\FolderDescriptions\\{767E6811-49CB-4273-87C2-20F355E1085B}\\PropertyBag"
	},
	{
		"id": 2276,
		"object": 0,
		"type": "Key",
		"name": "HKEY_CURRENT_USER\\Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\SessionInfo\\1\\ApplicationViewManagement"
	},
	{
		"id": 2280,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 2284,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 2288,
		"object": 0,
		"type": "Key",
		"name": "HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Explorer\\FolderDescriptions\\{24D89E24-2F19-4534-9DDE-6A6671FBB8FE}\\PropertyBag"
	},
	{
		"id": 2292,
		"object": 0,
		"type": "Key",
		"name": "HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Explorer\\FolderDescriptions\\{339719B5-8C47-4894-94C2-D8F77ADD44A6}\\PropertyBag"
	},
	{
		"id": 2296,
		"object": 0,
		"type": "Key",
		"name": "HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Explorer\\FolderDescriptions\\{52528A6B-B9E3-4add-B60D-588C2DBA842D}\\PropertyBag"
	},
	{
		"id": 2300,
		"object": 0,
		"type": "Key",
		"name": "HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Explorer\\FolderDescriptions\\{C3F2459E-80D6-45DC-BFEF-1F769F2BE730}\\PropertyBag"
	},
	{
		"id": 2304,
		"object": 0,
		"type": "Key",
		"name": "HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Explorer\\FolderDescriptions\\{7C5A40EF-A0FB-4BFC-874A-C0F2E0B9FA8E}\\PropertyBag"
	},
	{
		"id": 2308,
		"object": 0,
		"type": "Key",
		"name": "HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Explorer\\FolderDescriptions\\{4BD8D571-6D19-48D3-BE97-422220080E43}\\PropertyBag"
	},
	{
		"id": 2312,
		"object": 0,
		"type": "Key",
		"name": "HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Explorer\\FolderDescriptions\\{905e63b6-c1bf-494e-b29c-65b732d3d21a}\\PropertyBag"
	},
	{
		"id": 2316,
		"object": 0,
		"type": "Key",
		"name": "HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Explorer\\FolderDescriptions\\{374DE290-123F-4565-9164-39C4925E467B}\\PropertyBag"
	},
	{
		"id": 2320,
		"object": 0,
		"type": "Key",
		"name": "HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Explorer\\FolderDescriptions\\{33E28130-4E1E-4676-835A-98395C3BC3BB}\\PropertyBag"
	},
	{
		"id": 2324,
		"object": 0,
		"type": "Key",
		"name": "HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Explorer\\SyncRootManager"
	},
	{
		"id": 2328,
		"object": 0,
		"type": "Key",
		"name": "HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Explorer\\FolderDescriptions\\{18989B1D-99B5-455B-841C-AB7C74E4DDFC}\\PropertyBag"
	},
	{
		"id": 2340,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 2344,
		"object": 0,
		"type": "WaitCompletionPacket",
		"name": ""
	},
	{
		"id": 2348,
		"object": 0,
		"type": "Semaphore",
		"name": ""
	},
	{
		"id": 2360,
		"object": 0,
		"type": "Semaphore",
		"name": ""
	},
	{
		"id": 2364,
		"object": 0,
		"type": "Semaphore",
		"name": ""
	},
	{
		"id": 2368,
		"object": 0,
		"type": "Semaphore",
		"name": ""
	},
	{
		"id": 2372,
		"object": 0,
		"type": "Timer",
		"name": ""
	},
	{
		"id": 2376,
		"object": 0,
		"type": "IoCompletion",
		"name": ""
	},
	{
		"id": 2400,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 2404,
		"object": 0,
		"type": "Thread",
		"name": ""
	},
	{
		"id": 2408,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 2412,
		"object": 0,
		"type": "WaitCompletionPacket",
		"name": ""
	},
	{
		"id": 2416,
		"object": 0,
		"type": "Semaphore",
		"name": ""
	},
	{
		"id": 2420,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 2424,
		"object": 0,
		"type": "Key",
		"name": "HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Explorer"
	},
	{
		"id": 2432,
		"object": 0,
		"type": "IoCompletionReserve",
		"name": ""
	},
	{
		"id": 2436,
		"object": 0,
		"type": "IoCompletion",
		"name": ""
	},
	{
		"id": 2452,
		"object": 0,
		"type": "Key",
		"name": "HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Explorer\\FolderDescriptions\\{9B74B6A3-0DFD-4f11-9E78-5F7800F2E772}\\PropertyBag"
	},
	{
		"id": 2456,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 2460,
		"object": 0,
		"type": "Process",
		"name": "C:\\Windows\\System32\\sihost.exe"
	},
	{
		"id": 2464,
		"object": 0,
		"type": "WaitCompletionPacket",
		"name": ""
	},
	{
		"id": 2468,
		"object": 0,
		"type": "Key",
		"name": "HKEY_CURRENT_USER\\Software\\Microsoft\\Windows\\CurrentVersion\\Internet Settings\\Zones"
	},
	{
		"id": 2472,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 2476,
		"object": 0,
		"type": "Key",
		"name": "HKEY_CURRENT_USER\\Software\\Microsoft\\Windows\\CurrentVersion\\CloudStore\\Store\\DefaultAccount\\Current\\default$windows.data.bluelightreduction.settings\\windows.data.bluelightreduction.settings"
	},
	{
		"id": 2496,
		"object": 0,
		"type": "IoCompletion",
		"name": ""
	},
	{
		"id": 2500,
		"object": 0,
		"type": "Key",
		"name": "HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Explorer\\FolderDescriptions\\{D65231B0-B2F1-4857-A4CE-A8E7C6EA7D27}\\PropertyBag"
	},
	{
		"id": 2504,
		"object": 0,
		"type": "Key",
		"name": "HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Explorer\\FolderDescriptions\\{ED4824AF-DCE4-45A8-81E2-FC7965083634}\\PropertyBag"
	},
	{
		"id": 2508,
		"object": 0,
		"type": "Token",
		"name": ""
	},
	{
		"id": 2512,
		"object": 0,
		"type": "Thread",
		"name": ""
	},
	{
		"id": 2520,
		"object": 0,
		"type": "ALPC Port",
		"name": "",
		"meta": {
			"Flags": 458752,
			"Seqno": 0,
			"Context": 0
		}
	},
	{
		"id": 2528,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 2536,
		"object": 0,
		"type": "WaitCompletionPacket",
		"name": ""
	},
	{
		"id": 2544,
		"object": 0,
		"type": "WaitCompletionPacket",
		"name": ""
	},
	{
		"id": 2548,
		"object": 0,
		"type": "Section",
		"name": "\\Sessions\\1\\BaseNamedObjects\\245cHWNDInterface:20110"
	},
	{
		"id": 2556,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 2560,
		"object": 0,
		"type": "Mutant",
		"name": "",
		"meta": {
			"Count": 1,
			"IsAbandoned": false
		}
	},
	{
		"id": 2568,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 2572,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 2576,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 2584,
		"object": 0,
		"type": "Thread",
		"name": ""
	},
	{
		"id": 2596,
		"object": 0,
		"type": "ALPC Port",
		"name": "",
		"meta": {
			"Flags": 458752,
			"Seqno": 13,
			"Context": 2596
		}
	},
	{
		"id": 2600,
		"object": 0,
		"type": "ALPC Port",
		"name": "",
		"meta": {
			"Flags": 34144256,
			"Seqno": 373,
			"Context": 2600
		}
	},
	{
		"id": 2608,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 2620,
		"object": 0,
		"type": "Timer",
		"name": ""
	},
	{
		"id": 2632,
		"object": 0,
		"type": "Timer",
		"name": ""
	},
	{
		"id": 2640,
		"object": 0,
		"type": "Key",
		"name": "HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Explorer\\FolderDescriptions\\{3214FAB5-9757-4298-BB61-92A9DEAA44FF}\\PropertyBag"
	},
	{
		"id": 2644,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 2656,
		"object": 0,
		"type": "WaitCompletionPacket",
		"name": ""
	},
	{
		"id": 2660,
		"object": 0,
		"type": "Key",
		"name": "HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Explorer\\FolderDescriptions\\{DE92C1C7-837F-4F69-A3BB-86E631204A23}\\PropertyBag"
	},
	{
		"id": 2668,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 2672,
		"object": 0,
		"type": "Key",
		"name": "HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Explorer\\FolderDescriptions\\{A990AE9F-A03B-4e80-94BC-9912D7504104}\\PropertyBag"
	},
	{
		"id": 2676,
		"object": 0,
		"type": "WaitCompletionPacket",
		"name": ""
	},
	{
		"id": 2680,
		"object": 0,
		"type": "IoCompletion",
		"name": ""
	},
	{
		"id": 2684,
		"object": 0,
		"type": "Key",
		"name": "HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Explorer\\FolderDescriptions\\{B6EBFB86-6907-413C-9AF7-4FC2ABF07CC5}\\PropertyBag"
	},
	{
		"id": 2688,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 2692,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 2696,
		"object": 0,
		"type": "WaitCompletionPacket",
		"name": ""
	},
	{
		"id": 2700,
		"object": 0,
		"type": "Key",
		"name": "HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Explorer\\FolderDescriptions\\{2B20DF75-1EDA-4039-8097-38798227D5B7}\\PropertyBag"
	},
	{
		"id": 2704,
		"object": 0,
		"type": "Key",
		"name": "HKEY_CURRENT_USER\\Classes\\Local Settings\\Software\\Microsoft\\Windows\\Shell\\Bags\\2\\Shell\\{24CCB8A6-C45A-477D-B940-3382B9225668}"
	},
	{
		"id": 2712,
		"object": 0,
		"type": "Key",
		"name": "HKEY_CURRENT_USER\\Software\\Microsoft\\Windows\\CurrentVersion\\CloudStore\\Store\\DefaultAccount\\Cloud\\default$windows.data.bluelightreduction.settings\\windows.data.bluelightreduction.settings"
	},
	{
		"id": 2716,
		"object": 0,
		"type": "WaitCompletionPacket",
		"name": ""
	},
	{
		"id": 2728,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 2740,
		"object": 0,
		"type": "Section",
		"name": "\\Sessions\\1\\BaseNamedObjects\\245cHWNDInterface:20110"
	},
	{
		"id": 2744,
		"object": 0,
		"type": "Key",
		"name": "HKEY_CURRENT_USER\\Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\SessionInfo\\1\\ModeTriggerCachedKey"
	},
	{
		"id": 2756,
		"object": 0,
		"type": "IoCompletion",
		"name": ""
	},
	{
		"id": 2772,
		"object": 0,
		"type": "WaitCompletionPacket",
		"name": ""
	},
	{
		"id": 2776,
		"object": 0,
		"type": "Key",
		"name": "HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Explorer\\Desktop\\NameSpace"
	},
	{
		"id": 2784,
		"object": 0,
		"type": "Thread",
		"name": ""
	},
	{
		"id": 2788,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 2796,
		"object": 0,
		"type": "Thread",
		"name": ""
	},
	{
		"id": 2800,
		"object": 0,
		"type": "WaitCompletionPacket",
		"name": ""
	},
	{
		"id": 2804,
		"object": 0,
		"type": "Key",
		"name": "HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Explorer\\Desktop\\NameSpace\\DelegateFolders"
	},
	{
		"id": 2808,
		"object": 0,
		"type": "Key",
		"name": "HKEY_LOCAL_MACHINE\\SOFTWARE\\Classes\\CLSID\\{B4BFCC3A-DB2C-424C-B029-7FE99A87C641}\\Instance"
	},
	{
		"id": 2828,
		"object": 0,
		"type": "WaitCompletionPacket",
		"name": ""
	},
	{
		"id": 2844,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 2848,
		"object": 0,
		"type": "WaitCompletionPacket",
		"name": ""
	},
	{
		"id": 2860,
		"object": 0,
		"type": "ALPC Port",
		"name": "",
		"meta": {
			"Flags": 34144256,
			"Seqno": 99,
			"Context": 2860
		}
	},
	{
		"id": 2864,
		"object": 0,
		"type": "Semaphore",
		"name": "\\Sessions\\1\\BaseNamedObjects\\CDP_CALLBACK_DDEC674B-99D8-42D4-5B17-2C40D71B2989"
	},
	{
		"id": 2868,
		"object": 0,
		"type": "Thread",
		"name": ""
	},
	{
		"id": 2872,
		"object": 0,
		"type": "Thread",
		"name": ""
	},
	{
		"id": 2876,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 2880,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 2884,
		"object": 0,
		"type": "ALPC Port",
		"name": "",
		"meta": {
			"Flags": 458752,
			"Seqno": 7,
			"Context": 2884
		}
	},
	{
		"id": 2888,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 2892,
		"object": 0,
		"type": "Timer",
		"name": ""
	},
	{
		"id": 2904,
		"object": 0,
		"type": "Key",
		"name": "HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Explorer\\FolderDescriptions\\{7b0db17d-9cd2-4a93-9733-46cc89022e7c}\\PropertyBag"
	},
	{
		"id": 2912,
		"object": 0,
		"type": "Key",
		"name": "HKEY_CURRENT_USER\\Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\SessionInfo\\1\\ImmersiveShell\\PersistedApplicationData\\Volatile"
	},
	{
		"id": 2916,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 2920,
		"object": 0,
		"type": "WaitCompletionPacket",
		"name": ""
	},
	{
		"id": 2928,
		"object": 0,
		"type": "ALPC Port",
		"name": "",
		"meta": {
			"Flags": 458752,
			"Seqno": 42,
			"Context": 2928
		}
	},
	{
		"id": 2932,
		"object": 0,
		"type": "Thread",
		"name": ""
	},
	{
		"id": 2936,
		"object": 0,
		"type": "Key",
		"name": "HKEY_CURRENT_USER\\Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\SessionInfo\\1\\VirtualDesktops"
	},
	{
		"id": 2940,
		"object": 0,
		"type": "Key",
		"name": "HKEY_CURRENT_USER\\Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\VirtualDesktops"
	},
	{
		"id": 2948,
		"object": 0,
		"type": "Timer",
		"name": ""
	},
	{
		"id": 2952,
		"object": 0,
		"type": "WaitCompletionPacket",
		"name": ""
	},
	{
		"id": 2956,
		"object": 0,
		"type": "Key",
		"name": "HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Explorer\\FolderDescriptions\\{f3ce0f7c-4901-4acc-8648-d5d44b04ef8f}\\PropertyBag"
	},
	{
		"id": 2960,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 2964,
		"object": 0,
		"type": "WaitCompletionPacket",
		"name": ""
	},
	{
		"id": 2968,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 2972,
		"object": 0,
		"type": "WaitCompletionPacket",
		"name": ""
	},
	{
		"id": 2976,
		"object": 0,
		"type": "WaitCompletionPacket",
		"name": ""
	},
	{
		"id": 2980,
		"object": 0,
		"type": "WaitCompletionPacket",
		"name": ""
	},
	{
		"id": 2984,
		"object": 0,
		"type": "Thread",
		"name": ""
	},
	{
		"id": 2988,
		"object": 0,
		"type": "WaitCompletionPacket",
		"name": ""
	},
	{
		"id": 2992,
		"object": 0,
		"type": "IoCompletionReserve",
		"name": ""
	},
	{
		"id": 2996,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 3000,
		"object": 0,
		"type": "ALPC Port",
		"name": "",
		"meta": {
			"Flags": 458752,
			"Seqno": 1884,
			"Context": 3000
		}
	},
	{
		"id": 3004,
		"object": 0,
		"type": "WaitCompletionPacket",
		"name": ""
	},
	{
		"id": 3008,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 3012,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 3016,
		"object": 0,
		"type": "Key",
		"name": "HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Explorer\\FolderDescriptions\\{2112AB0A-C86A-4ffe-A368-0DE96E47012E}\\PropertyBag"
	},
	{
		"id": 3020,
		"object": 0,
		"type": "Key",
		"name": "HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Explorer\\FolderDescriptions\\{E25B5812-BE88-4bd9-94B0-29233477B6C3}\\PropertyBag"
	},
	{
		"id": 3028,
		"object": 0,
		"type": "Key",
		"name": "HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Explorer\\FolderDescriptions\\{491E922F-5643-4af4-A7EB-4E7A138D8174}\\PropertyBag"
	},
	{
		"id": 3032,
		"object": 0,
		"type": "Key",
		"name": "HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Explorer\\FolderDescriptions\\{2400183A-6185-49FB-A2D8-4A392A602BA3}\\PropertyBag"
	},
	{
		"id": 3036,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 3040,
		"object": 0,
		"type": "Thread",
		"name": ""
	},
	{
		"id": 3044,
		"object": 0,
		"type": "WaitCompletionPacket",
		"name": ""
	},
	{
		"id": 3048,
		"object": 0,
		"type": "Key",
		"name": "HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Explorer\\FolderDescriptions\\{56784854-C6CB-462B-8169-88E350ACB882}\\PropertyBag"
	},
	{
		"id": 3052,
		"object": 0,
		"type": "ALPC Port",
		"name": "",
		"meta": {
			"Flags": 458752,
			"Seqno": 1882,
			"Context": 3052
		}
	},
	{
		"id": 3060,
		"object": 0,
		"type": "WaitCompletionPacket",
		"name": ""
	},
	{
		"id": 3064,
		"object": 0,
		"type": "Key",
		"name": "HKEY_CURRENT_USER\\Software\\Microsoft\\Windows\\CurrentVersion\\ContentDeliveryManager"
	},
	{
		"id": 3068,
		"object": 0,
		"type": "Key",
		"name": "HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Explorer\\FolderDescriptions\\{A302545D-DEFF-464b-ABE8-61C8648D939B}\\PropertyBag"
	},
	{
		"id": 3084,
		"object": 0,
		"type": "Key",
		"name": "HKEY_CURRENT_USER\\Software\\Microsoft\\Windows\\CurrentVersion\\CloudStore\\Store\\DefaultAccount\\Current\\default$windows.data.bluelightreduction.bluelightreductionstate\\windows.data.bluelightreduction.bluelightreductionstate"
	},
	{
		"id": 3088,
		"object": 0,
		"type": "Key",
		"name": "HKEY_CURRENT_USER\\Software\\Microsoft\\Windows\\CurrentVersion\\CloudStore\\Store\\DefaultAccount\\Cloud\\default$windows.data.bluelightreduction.bluelightreductionstate\\windows.data.bluelightreduction.bluelightreductionstate"
	},
	{
		"id": 3092,
		"object": 0,
		"type": "WaitCompletionPacket",
		"name": ""
	},
	{
		"id": 3096,
		"object": 0,
		"type": "WaitCompletionPacket",
		"name": ""
	},
	{
		"id": 3100,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 3104,
		"object": 0,
		"type": "WaitCompletionPacket",
		"name": ""
	},
	{
		"id": 3116,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 3120,
		"object": 0,
		"type": "WaitCompletionPacket",
		"name": ""
	},
	{
		"id": 3124,
		"object": 0,
		"type": "DxgkCompositionObject",
		"name": ""
	},
	{
		"id": 3128,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 3136,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 3140,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 3156,
		"object": 0,
		"type": "Semaphore",
		"name": ""
	},
	{
		"id": 3160,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 3164,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 3168,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 3176,
		"object": 0,
		"type": "ALPC Port",
		"name": "",
		"meta": {
			"Flags": 196608,
			"Seqno": 1,
			"Context": 3176
		}
	},
	{
		"id": 3180,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 3188,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 3192,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 3196,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 3200,
		"object": 0,
		"type": "Key",
		"name": "HKEY_LOCAL_MACHINE\\SOFTWARE\\Classes\\CLSID\\{1f3427c8-5c10-4210-aa03-2ee45287d668}\\Instance"
	},
	{
		"id": 3204,
		"object": 0,
		"type": "Key",
		"name": "HKEY_CURRENT_USER\\Software\\Microsoft\\Windows\\CurrentVersion\\ActivityDataModel\\ReaderRevisionInfo"
	},
	{
		"id": 3208,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 3216,
		"object": 0,
		"type": "WaitCompletionPacket",
		"name": ""
	},
	{
		"id": 3220,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 3224,
		"object": 0,
		"type": "Key",
		"name": "HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\TabletTip\\1.7"
	},
	{
		"id": 3228,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 3232,
		"object": 0,
		"type": "WaitCompletionPacket",
		"name": ""
	},
	{
		"id": 3236,
		"object": 0,
		"type": "Key",
		"name": "HKEY_CURRENT_USER\\Software\\Microsoft\\TabletTip\\1.7"
	},
	{
		"id": 3240,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 3244,
		"object": 0,
		"type": "WaitCompletionPacket",
		"name": ""
	},
	{
		"id": 3268,
		"object": 0,
		"type": "WaitCompletionPacket",
		"name": ""
	},
	{
		"id": 3276,
		"object": 0,
		"type": "Thread",
		"name": ""
	},
	{
		"id": 3284,
		"object": 0,
		"type": "Section",
		"name": ""
	},
	{
		"id": 3288,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 3292,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 3296,
		"object": 0,
		"type": "WaitCompletionPacket",
		"name": ""
	},
	{
		"id": 3300,
		"object": 0,
		"type": "IoCompletion",
		"name": ""
	},
	{
		"id": 3304,
		"object": 0,
		"type": "Semaphore",
		"name": ""
	},
	{
		"id": 3316,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 3324,
		"object": 0,
		"type": "Section",
		"name": ""
	},
	{
		"id": 3328,
		"object": 0,
		"type": "Process",
		"name": "C:\\Windows\\System32\\ApplicationFrameHost.exe"
	},
	{
		"id": 3332,
		"object": 0,
		"type": "WaitCompletionPacket",
		"name": ""
	},
	{
		"id": 3336,
		"object": 0,
		"type": "WaitCompletionPacket",
		"name": ""
	},
	{
		"id": 3340,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 3352,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 3356,
		"object": 0,
		"type": "Thread",
		"name": ""
	},
	{
		"id": 3360,
		"object": 0,
		"type": "Semaphore",
		"name": "\\Sessions\\1\\BaseNamedObjects\\CDP_CALLBACK_B59BF58B-B658-3070-A3B6-D69128DC0AF1"
	},
	{
		"id": 3368,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 3372,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 3376,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 3384,
		"object": 0,
		"type": "Thread",
		"name": ""
	},
	{
		"id": 3408,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 3412,
		"object": 0,
		"type": "WaitCompletionPacket",
		"name": ""
	},
	{
		"id": 3416,
		"object": 0,
		"type": "ALPC Port",
		"name": "",
		"meta": {
			"Flags": 34144256,
			"Seqno": 3386,
			"Context": 3416
		}
	},
	{
		"id": 3420,
		"object": 0,
		"type": "Section",
		"name": "\\Sessions\\1\\BaseNamedObjects\\245cHWNDInterface:10158"
	},
	{
		"id": 3424,
		"object": 0,
		"type": "Section",
		"name": "\\Sessions\\1\\BaseNamedObjects\\245cHWNDInterface:10168"
	},
	{
		"id": 3428,
		"object": 0,
		"type": "Semaphore",
		"name": "\\Sessions\\1\\BaseNamedObjects\\CDP_CALLBACK_12541A3D-DFB6-BD6F-FACE-BB3E6841EB46"
	},
	{
		"id": 3432,
		"object": 0,
		"type": "IoCompletion",
		"name": ""
	},
	{
		"id": 3436,
		"object": 0,
		"type": "TpWorkerFactory",
		"name": ""
	},
	{
		"id": 3440,
		"object": 0,
		"type": "IRTimer",
		"name": ""
	},
	{
		"id": 3444,
		"object": 0,
		"type": "WaitCompletionPacket",
		"name": ""
	},
	{
		"id": 3448,
		"object": 0,
		"type": "IRTimer",
		"name": ""
	},
	{
		"id": 3452,
		"object": 0,
		"type": "WaitCompletionPacket",
		"name": ""
	},
	{
		"id": 3456,
		"object": 0,
		"type": "Event",
		"name": "\\Sessions\\1\\BaseNamedObjects\\{F6151BD3-458B-4C93-9088-9F6A37F9EE97}"
	},
	{
		"id": 3460,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 3464,
		"object": 0,
		"type": "Thread",
		"name": ""
	},
	{
		"id": 3480,
		"object": 0,
		"type": "WaitCompletionPacket",
		"name": ""
	},
	{
		"id": 3484,
		"object": 0,
		"type": "Semaphore",
		"name": "\\Sessions\\1\\BaseNamedObjects\\CDP_CALLBACK_FC12EE91-49F1-DC96-0D54-0B587D5A88FC"
	},
	{
		"id": 3492,
		"object": 0,
		"type": "Section",
		"name": "\\Sessions\\1\\BaseNamedObjects\\245cHWNDInterface:ca0706"
	},
	{
		"id": 3508,
		"object": 0,
		"type": "ALPC Port",
		"name": "",
		"meta": {
			"Flags": 34144256,
			"Seqno": 163,
			"Context": 3508
		}
	},
	{
		"id": 3512,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 3520,
		"object": 0,
		"type": "ALPC Port",
		"name": "",
		"meta": {
			"Flags": 34144256,
			"Seqno": 406,
			"Context": 3520
		}
	},
	{
		"id": 3532,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 3540,
		"object": 0,
		"type": "Semaphore",
		"name": "\\Sessions\\1\\BaseNamedObjects\\CDP_CALLBACK_072CE8F2-A62E-55F4-CE88-CB84F0268487"
	},
	{
		"id": 3544,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 3552,
		"object": 0,
		"type": "Key",
		"name": "HKEY_CURRENT_USER\\Software\\Microsoft\\Windows\\CurrentVersion\\Themes\\Personalize"
	},
	{
		"id": 3556,
		"object": 0,
		"type": "WaitCompletionPacket",
		"name": ""
	},
	{
		"id": 3560,
		"object": 0,
		"type": "Section",
		"name": "\\Sessions\\1\\BaseNamedObjects\\245cHWNDInterface:10160"
	},
	{
		"id": 3564,
		"object": 0,
		"type": "Section",
		"name": "\\Sessions\\1\\BaseNamedObjects\\245cHWNDInterface:10160"
	},
	{
		"id": 3568,
		"object": 0,
		"type": "Section",
		"name": "\\Sessions\\1\\BaseNamedObjects\\245cHWNDInterface:10158"
	},
	{
		"id": 3572,
		"object": 0,
		"type": "Section",
		"name": "\\Sessions\\1\\BaseNamedObjects\\245cHWNDInterface:1015a"
	},
	{
		"id": 3576,
		"object": 0,
		"type": "Section",
		"name": "\\Sessions\\1\\BaseNamedObjects\\245cHWNDInterface:1015a"
	},
	{
		"id": 3580,
		"object": 0,
		"type": "Section",
		"name": "\\Sessions\\1\\BaseNamedObjects\\245cHWNDInterface:1015c"
	},
	{
		"id": 3584,
		"object": 0,
		"type": "Section",
		"name": "\\Sessions\\1\\BaseNamedObjects\\245cHWNDInterface:1015c"
	},
	{
		"id": 3588,
		"object": 0,
		"type": "Section",
		"name": "\\Sessions\\1\\BaseNamedObjects\\245cHWNDInterface:1015e"
	},
	{
		"id": 3592,
		"object": 0,
		"type": "Section",
		"name": "\\Sessions\\1\\BaseNamedObjects\\245cHWNDInterface:1015e"
	},
	{
		"id": 3596,
		"object": 0,
		"type": "Section",
		"name": "\\Sessions\\1\\BaseNamedObjects\\245cHWNDInterface:10162"
	},
	{
		"id": 3600,
		"object": 0,
		"type": "Section",
		"name": "\\Sessions\\1\\BaseNamedObjects\\245cHWNDInterface:10162"
	},
	{
		"id": 3604,
		"object": 0,
		"type": "Section",
		"name": "\\Sessions\\1\\BaseNamedObjects\\245cHWNDInterface:10164"
	},
	{
		"id": 3608,
		"object": 0,
		"type": "Section",
		"name": "\\Sessions\\1\\BaseNamedObjects\\245cHWNDInterface:10164"
	},
	{
		"id": 3612,
		"object": 0,
		"type": "Section",
		"name": "\\Sessions\\1\\BaseNamedObjects\\245cHWNDInterface:10166"
	},
	{
		"id": 3616,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 3620,
		"object": 0,
		"type": "Section",
		"name": "\\Sessions\\1\\BaseNamedObjects\\245cHWNDInterface:10166"
	},
	{
		"id": 3624,
		"object": 0,
		"type": "Section",
		"name": "\\Sessions\\1\\BaseNamedObjects\\245cHWNDInterface:10168"
	},
	{
		"id": 3632,
		"object": 0,
		"type": "WaitCompletionPacket",
		"name": ""
	},
	{
		"id": 3636,
		"object": 0,
		"type": "Key",
		"name": "HKEY_CURRENT_USER\\Software\\Microsoft\\Windows\\CurrentVersion\\Holographic"
	},
	{
		"id": 3640,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 3648,
		"object": 0,
		"type": "WaitCompletionPacket",
		"name": ""
	},
	{
		"id": 3652,
		"object": 0,
		"type": "Key",
		"name": "HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\PerceptionSimulationExtensions"
	},
	{
		"id": 3656,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 3660,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 3664,
		"object": 0,
		"type": "WaitCompletionPacket",
		"name": ""
	},
	{
		"id": 3668,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 3672,
		"object": 0,
		"type": "WaitCompletionPacket",
		"name": ""
	},
	{
		"id": 3676,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 3680,
		"object": 0,
		"type": "WaitCompletionPacket",
		"name": ""
	},
	{
		"id": 3688,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 3700,
		"object": 0,
		"type": "Key",
		"name": "HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Explorer\\CommandStore"
	},
	{
		"id": 3704,
		"object": 0,
		"type": "Semaphore",
		"name": ""
	},
	{
		"id": 3712,
		"object": 0,
		"type": "ALPC Port",
		"name": "",
		"meta": {
			"Flags": 34078720,
			"Seqno": 138,
			"Context": 99580000
		}
	},
	{
		"id": 3716,
		"object": 0,
		"type": "Mutant",
		"name": "",
		"meta": {
			"Count": 1,
			"IsAbandoned": false
		}
	},
	{
		"id": 3728,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 3732,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 3736,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 3740,
		"object": 0,
		"type": "Mutant",
		"name": "",
		"meta": {
			"Count": 1,
			"IsAbandoned": false
		}
	},
	{
		"id": 3744,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 3748,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 3752,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 3760,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 3764,
		"object": 0,
		"type": "Section",
		"name": "\\Sessions\\1\\BaseNamedObjects\\245cHWNDInterface:ca0706"
	},
	{
		"id": 3768,
		"object": 0,
		"type": "IoCompletion",
		"name": ""
	},
	{
		"id": 3772,
		"object": 0,
		"type": "DxgkCompositionObject",
		"name": ""
	},
	{
		"id": 3776,
		"object": 0,
		"type": "Mutant",
		"name": "",
		"meta": {
			"Count": 1,
			"IsAbandoned": false
		}
	},
	{
		"id": 3784,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 3796,
		"object": 0,
		"type": "WaitCompletionPacket",
		"name": ""
	},
	{
		"id": 3800,
		"object": 0,
		"type": "DxgkCompositionObject",
		"name": ""
	},
	{
		"id": 3804,
		"object": 0,
		"type": "WaitCompletionPacket",
		"name": ""
	},
	{
		"id": 3812,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 3816,
		"object": 0,
		"type": "Semaphore",
		"name": ""
	},
	{
		"id": 3820,
		"object": 0,
		"type": "Mutant",
		"name": "",
		"meta": {
			"Count": 1,
			"IsAbandoned": false
		}
	},
	{
		"id": 3828,
		"object": 0,
		"type": "ALPC Port",
		"name": "",
		"meta": {
			"Flags": 393216,
			"Seqno": 1,
			"Context": 3828
		}
	},
	{
		"id": 3848,
		"object": 0,
		"type": "Thread",
		"name": ""
	},
	{
		"id": 3852,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 3856,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 3860,
		"object": 0,
		"type": "WaitCompletionPacket",
		"name": ""
	},
	{
		"id": 3864,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 3868,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 3880,
		"object": 0,
		"type": "WaitCompletionPacket",
		"name": ""
	},
	{
		"id": 3884,
		"object": 0,
		"type": "WaitCompletionPacket",
		"name": ""
	},
	{
		"id": 3888,
		"object": 0,
		"type": "Key",
		"name": "HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Policies\\System"
	},
	{
		"id": 3912,
		"object": 0,
		"type": "Event",
		"name": "\\Sessions\\1\\BaseNamedObjects\\PRS_EXTERNAL_CHECK_CHANGED_NOTIFY"
	},
	{
		"id": 3916,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 3920,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 3924,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 3928,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 3932,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 3940,
		"object": 0,
		"type": "Key",
		"name": "HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Explorer\\CommandStore\\shell\\Windows.undo"
	},
	{
		"id": 3948,
		"object": 0,
		"type": "Thread",
		"name": ""
	},
	{
		"id": 3952,
		"object": 0,
		"type": "IoCompletion",
		"name": ""
	},
	{
		"id": 3956,
		"object": 0,
		"type": "Thread",
		"name": ""
	},
	{
		"id": 3964,
		"object": 0,
		"type": "IoCompletion",
		"name": ""
	},
	{
		"id": 3968,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 3984,
		"object": 0,
		"type": "WaitCompletionPacket",
		"name": ""
	},
	{
		"id": 3988,
		"object": 0,
		"type": "ALPC Port",
		"name": "",
		"meta": {
			"Flags": 34078720,
			"Seqno": 19,
			"Context": 99592368
		}
	},
	{
		"id": 3992,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 4000,
		"object": 0,
		"type": "WaitCompletionPacket",
		"name": ""
	},
	{
		"id": 4012,
		"object": 0,
		"type": "ALPC Port",
		"name": "",
		"meta": {
			"Flags": 34144256,
			"Seqno": 9,
			"Context": 4012
		}
	},
	{
		"id": 4024,
		"object": 0,
		"type": "Key",
		"name": "HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Explorer\\CommandStore\\shell\\Windows.undo"
	},
	{
		"id": 4028,
		"object": 0,
		"type": "WaitCompletionPacket",
		"name": ""
	},
	{
		"id": 4032,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 4052,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 4068,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 4072,
		"object": 0,
		"type": "Mutant",
		"name": "",
		"meta": {
			"Count": 1,
			"IsAbandoned": false
		}
	},
	{
		"id": 4076,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 4080,
		"object": 0,
		"type": "Mutant",
		"name": "",
		"meta": {
			"Count": 1,
			"IsAbandoned": false
		}
	},
	{
		"id": 4092,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 4100,
		"object": 0,
		"type": "Key",
		"name": "HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Explorer\\CommandStore\\shell\\Windows.help"
	},
	{
		"id": 4104,
		"object": 0,
		"type": "Section",
		"name": ""
	},
	{
		"id": 4112,
		"object": 0,
		"type": "Key",
		"name": "HKEY_LOCAL_MACHINE\\SOFTWARE\\Classes\\CLSID\\{DFFACDC5-679F-4156-8947-C5C76BC0B67F}\\Instance"
	},
	{
		"id": 4120,
		"object": 0,
		"type": "Key",
		"name": "HKEY_CURRENT_USER\\Control Panel\\Keyboard"
	},
	{
		"id": 4124,
		"object": 0,
		"type": "Key",
		"name": "HKEY_CURRENT_USER\\Software\\Microsoft\\Windows\\CurrentVersion\\SignalManager\\Peek\\CacheStore"
	},
	{
		"id": 4128,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 4136,
		"object": 0,
		"type": "Section",
		"name": "\\Sessions\\1\\BaseNamedObjects\\245cHWNDInterface:10804"
	},
	{
		"id": 4144,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 4148,
		"object": 0,
		"type": "ALPC Port",
		"name": "",
		"meta": {
			"Flags": 34144256,
			"Seqno": 51,
			"Context": 4148
		}
	},
	{
		"id": 4152,
		"object": 0,
		"type": "Section",
		"name": "\\Sessions\\1\\BaseNamedObjects\\245cHWNDInterface:100a6"
	},
	{
		"id": 4156,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 4160,
		"object": 0,
		"type": "Thread",
		"name": ""
	},
	{
		"id": 4168,
		"object": 0,
		"type": "Key",
		"name": "HKEY_CURRENT_USER\\Software\\Microsoft\\Windows NT\\CurrentVersion"
	},
	{
		"id": 4172,
		"object": 0,
		"type": "Event",
		"name": "\\BaseNamedObjects\\{9D4A3865-6969-4B24-928C-C60ACC181E40}"
	},
	{
		"id": 4176,
		"object": 0,
		"type": "Thread",
		"name": ""
	},
	{
		"id": 4188,
		"object": 0,
		"type": "Semaphore",
		"name": ""
	},
	{
		"id": 4192,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 4196,
		"object": 0,
		"type": "Timer",
		"name": ""
	},
	{
		"id": 4204,
		"object": 0,
		"type": "Thread",
		"name": ""
	},
	{
		"id": 4208,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 4212,
		"object": 0,
		"type": "Section",
		"name": ""
	},
	{
		"id": 4216,
		"object": 0,
		"type": "Key",
		"name": "HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Explorer\\CommandStore\\shell\\Windows.properties"
	},
	{
		"id": 4220,
		"object": 0,
		"type": "Event",
		"name": "\\Sessions\\1\\BaseNamedObjects\\{43a2b8d7-6fed-4c18-bd36-b4630d61afb5}"
	},
	{
		"id": 4224,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 4228,
		"object": 0,
		"type": "DxgkCompositionObject",
		"name": ""
	},
	{
		"id": 4236,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 4240,
		"object": 0,
		"type": "ALPC Port",
		"name": "",
		"meta": {
			"Flags": 34144256,
			"Seqno": 2949,
			"Context": 4240
		}
	},
	{
		"id": 4244,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 4248,
		"object": 0,
		"type": "ALPC Port",
		"name": "",
		"meta": {
			"Flags": 34144256,
			"Seqno": 108,
			"Context": 4248
		}
	},
	{
		"id": 4252,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 4256,
		"object": 0,
		"type": "Key",
		"name": "HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\SignalManager\\Peek\\CacheStore"
	},
	{
		"id": 4260,
		"object": 0,
		"type": "WaitCompletionPacket",
		"name": ""
	},
	{
		"id": 4264,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 4272,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 4276,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 4280,
		"object": 0,
		"type": "IoCompletion",
		"name": ""
	},
	{
		"id": 4284,
		"object": 0,
		"type": "Thread",
		"name": ""
	},
	{
		"id": 4288,
		"object": 0,
		"type": "IoCompletion",
		"name": ""
	},
	{
		"id": 4292,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 4296,
		"object": 0,
		"type": "WaitCompletionPacket",
		"name": ""
	},
	{
		"id": 4300,
		"object": 0,
		"type": "WaitCompletionPacket",
		"name": ""
	},
	{
		"id": 4304,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 4308,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 4312,
		"object": 0,
		"type": "WaitCompletionPacket",
		"name": ""
	},
	{
		"id": 4316,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 4320,
		"object": 0,
		"type": "WaitCompletionPacket",
		"name": ""
	},
	{
		"id": 4324,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 4328,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 4332,
		"object": 0,
		"type": "WaitCompletionPacket",
		"name": ""
	},
	{
		"id": 4336,
		"object": 0,
		"type": "Semaphore",
		"name": ""
	},
	{
		"id": 4340,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 4352,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 4356,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 4364,
		"object": 0,
		"type": "WaitCompletionPacket",
		"name": ""
	},
	{
		"id": 4372,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 4376,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 4380,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 4384,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 4388,
		"object": 0,
		"type": "ALPC Port",
		"name": "",
		"meta": {
			"Flags": 34078720,
			"Seqno": 56,
			"Context": 99600432
		}
	},
	{
		"id": 4396,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 4400,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 4416,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 4420,
		"object": 0,
		"type": "WaitCompletionPacket",
		"name": ""
	},
	{
		"id": 4424,
		"object": 0,
		"type": "ALPC Port",
		"name": "",
		"meta": {
			"Flags": 458752,
			"Seqno": 1,
			"Context": 4424
		}
	},
	{
		"id": 4428,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 4432,
		"object": 0,
		"type": "ALPC Port",
		"name": "",
		"meta": {
			"Flags": 458752,
			"Seqno": 0,
			"Context": 0
		}
	},
	{
		"id": 4436,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 4440,
		"object": 0,
		"type": "WaitCompletionPacket",
		"name": ""
	},
	{
		"id": 4444,
		"object": 0,
		"type": "Semaphore",
		"name": ""
	},
	{
		"id": 4448,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 4456,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 4460,
		"object": 0,
		"type": "IoCompletion",
		"name": ""
	},
	{
		"id": 4468,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 4472,
		"object": 0,
		"type": "Thread",
		"name": ""
	},
	{
		"id": 4476,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 4480,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 4484,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 4488,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 4492,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 4500,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 4508,
		"object": 0,
		"type": "Key",
		"name": "HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\IdentityStore\\Providers"
	},
	{
		"id": 4512,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 4520,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 4528,
		"object": 0,
		"type": "Key",
		"name": "HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Explorer\\CommandStore"
	},
	{
		"id": 4532,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 4540,
		"object": 0,
		"type": "ALPC Port",
		"name": "",
		"meta": {
			"Flags": 34078720,
			"Seqno": 14,
			"Context": 100338224
		}
	},
	{
		"id": 4544,
		"object": 0,
		"type": "Thread",
		"name": ""
	},
	{
		"id": 4548,
		"object": 0,
		"type": "Thread",
		"name": ""
	},
	{
		"id": 4564,
		"object": 0,
		"type": "Thread",
		"name": ""
	},
	{
		"id": 4568,
		"object": 0,
		"type": "Section",
		"name": "\\Sessions\\1\\BaseNamedObjects\\245cHWNDInterface:10804"
	},
	{
		"id": 4572,
		"object": 0,
		"type": "Section",
		"name": ""
	},
	{
		"id": 4576,
		"object": 0,
		"type": "Thread",
		"name": ""
	},
	{
		"id": 4580,
		"object": 0,
		"type": "IoCompletion",
		"name": ""
	},
	{
		"id": 4584,
		"object": 0,
		"type": "Key",
		"name": "HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Explorer\\CommandStore\\shell\\Windows.RibbonDelete"
	},
	{
		"id": 4588,
		"object": 0,
		"type": "Event",
		"name": "\\BaseNamedObjects\\{c245290c-487c-4f81-9aba-7eb0dac882a2}"
	},
	{
		"id": 4592,
		"object": 0,
		"type": "Thread",
		"name": ""
	},
	{
		"id": 4596,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 4604,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 4608,
		"object": 0,
		"type": "WaitCompletionPacket",
		"name": ""
	},
	{
		"id": 4612,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 4620,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 4624,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 4632,
		"object": 0,
		"type": "IoCompletion",
		"name": ""
	},
	{
		"id": 4660,
		"object": 0,
		"type": "Mutant",
		"name": "",
		"meta": {
			"Count": 1,
			"IsAbandoned": false
		}
	},
	{
		"id": 4664,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 4684,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 4688,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 4692,
		"object": 0,
		"type": "Thread",
		"name": ""
	},
	{
		"id": 4696,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 4700,
		"object": 0,
		"type": "Thread",
		"name": ""
	},
	{
		"id": 4704,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 4708,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 4712,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 4720,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 4728,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 4736,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 4740,
		"object": 0,
		"type": "WaitCompletionPacket",
		"name": ""
	},
	{
		"id": 4744,
		"object": 0,
		"type": "Semaphore",
		"name": ""
	},
	{
		"id": 4752,
		"object": 0,
		"type": "Event",
		"name": "\\BaseNamedObjects\\{44ea083b-899c-4440-8338-2469fd4681cf}"
	},
	{
		"id": 4764,
		"object": 0,
		"type": "ALPC Port",
		"name": "",
		"meta": {
			"Flags": 34144256,
			"Seqno": 75,
			"Context": 4764
		}
	},
	{
		"id": 4768,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 4772,
		"object": 0,
		"type": "Timer",
		"name": ""
	},
	{
		"id": 4776,
		"object": 0,
		"type": "Semaphore",
		"name": ""
	},
	{
		"id": 4784,
		"object": 0,
		"type": "ALPC Port",
		"name": "",
		"meta": {
			"Flags": 34078720,
			"Seqno": 2,
			"Context": 327862048
		}
	},
	{
		"id": 4796,
		"object": 0,
		"type": "Thread",
		"name": ""
	},
	{
		"id": 4808,
		"object": 0,
		"type": "WaitCompletionPacket",
		"name": ""
	},
	{
		"id": 4812,
		"object": 0,
		"type": "Thread",
		"name": ""
	},
	{
		"id": 4820,
		"object": 0,
		"type": "Section",
		"name": "\\Sessions\\1\\BaseNamedObjects\\245cHWNDInterface:10380"
	},
	{
		"id": 4824,
		"object": 0,
		"type": "Thread",
		"name": ""
	},
	{
		"id": 4828,
		"object": 0,
		"type": "WaitCompletionPacket",
		"name": ""
	},
	{
		"id": 4832,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 4836,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 4840,
		"object": 0,
		"type": "WaitCompletionPacket",
		"name": ""
	},
	{
		"id": 4848,
		"object": 0,
		"type": "ALPC Port",
		"name": "",
		"meta": {
			"Flags": 458752,
			"Seqno": 1800,
			"Context": 4848
		}
	},
	{
		"id": 4852,
		"object": 0,
		"type": "Key",
		"name": "HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Explorer\\CommandStore\\shell\\Windows.properties"
	},
	{
		"id": 4856,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 4860,
		"object": 0,
		"type": "Thread",
		"name": ""
	},
	{
		"id": 4864,
		"object": 0,
		"type": "WaitCompletionPacket",
		"name": ""
	},
	{
		"id": 4868,
		"object": 0,
		"type": "WaitCompletionPacket",
		"name": ""
	},
	{
		"id": 4872,
		"object": 0,
		"type": "Key",
		"name": "HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Security Center"
	},
	{
		"id": 4880,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 4884,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 4896,
		"object": 0,
		"type": "Timer",
		"name": ""
	},
	{
		"id": 4904,
		"object": 0,
		"type": "Thread",
		"name": ""
	},
	{
		"id": 4908,
		"object": 0,
		"type": "WaitCompletionPacket",
		"name": ""
	},
	{
		"id": 4912,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 4920,
		"object": 0,
		"type": "IoCompletion",
		"name": ""
	},
	{
		"id": 4928,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 4936,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 4940,
		"object": 0,
		"type": "WaitCompletionPacket",
		"name": ""
	},
	{
		"id": 4944,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 4948,
		"object": 0,
		"type": "Key",
		"name": "HKEY_CURRENT_USER"
	},
	{
		"id": 4952,
		"object": 0,
		"type": "ALPC Port",
		"name": "",
		"meta": {
			"Flags": 458752,
			"Seqno": 282,
			"Context": 0
		}
	},
	{
		"id": 4956,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 4960,
		"object": 0,
		"type": "Section",
		"name": ""
	},
	{
		"id": 4964,
		"object": 0,
		"type": "Thread",
		"name": ""
	},
	{
		"id": 4968,
		"object": 0,
		"type": "Thread",
		"name": ""
	},
	{
		"id": 4972,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 4976,
		"object": 0,
		"type": "Section",
		"name": "\\Sessions\\1\\BaseNamedObjects\\245cHWNDInterface:890794"
	},
	{
		"id": 4984,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 4992,
		"object": 0,
		"type": "Section",
		"name": ""
	},
	{
		"id": 5000,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 5008,
		"object": 0,
		"type": "Semaphore",
		"name": ""
	},
	{
		"id": 5012,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 5016,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 5024,
		"object": 0,
		"type": "Event",
		"name": "\\Sessions\\1\\BaseNamedObjects\\ShellReadyEvent"
	},
	{
		"id": 5048,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 5056,
		"object": 0,
		"type": "Key",
		"name": "HKEY_LOCAL_MACHINE\\SOFTWARE\\Classes\\CLSID\\{1f3427c8-5c10-4210-aa03-2ee45287d668}\\Instance"
	},
	{
		"id": 5064,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 5084,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 5092,
		"object": 0,
		"type": "Thread",
		"name": ""
	},
	{
		"id": 5104,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 5108,
		"object": 0,
		"type": "Thread",
		"name": ""
	},
	{
		"id": 5112,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 5116,
		"object": 0,
		"type": "WaitCompletionPacket",
		"name": ""
	},
	{
		"id": 5124,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 5128,
		"object": 0,
		"type": "Event",
		"name": "\\BaseNamedObjects\\{c245290c-487c-4f81-9aba-7eb0dac882a2}"
	},
	{
		"id": 5136,
		"object": 0,
		"type": "ALPC Port",
		"name": "",
		"meta": {
			"Flags": 34144256,
			"Seqno": 198,
			"Context": 5136
		}
	},
	{
		"id": 5140,
		"object": 0,
		"type": "Section",
		"name": "\\Sessions\\1\\BaseNamedObjects\\245cHWNDInterface:4040c"
	},
	{
		"id": 5144,
		"object": 0,
		"type": "Section",
		"name": "\\Sessions\\1\\BaseNamedObjects\\C:*ProgramData*Microsoft*Windows*Caches*cversions.2.ro"
	},
	{
		"id": 5148,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 5152,
		"object": 0,
		"type": "Section",
		"name": "\\Sessions\\1\\BaseNamedObjects\\245cHWNDInterface:107e2"
	},
	{
		"id": 5156,
		"object": 0,
		"type": "Semaphore",
		"name": "\\Sessions\\1\\BaseNamedObjects\\CDP_CALLBACK_C59FE15A-8D83-87A7-9461-4DA519BF2583"
	},
	{
		"id": 5160,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 5164,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 5172,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 5184,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 5192,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 5196,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 5224,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 5232,
		"object": 0,
		"type": "Semaphore",
		"name": ""
	},
	{
		"id": 5236,
		"object": 0,
		"type": "Event",
		"name": "\\BaseNamedObjects\\{44ea083b-899c-4440-8338-2469fd4681cf}"
	},
	{
		"id": 5240,
		"object": 0,
		"type": "Thread",
		"name": ""
	},
	{
		"id": 5244,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 5248,
		"object": 0,
		"type": "IoCompletion",
		"name": ""
	},
	{
		"id": 5252,
		"object": 0,
		"type": "WaitCompletionPacket",
		"name": ""
	},
	{
		"id": 5264,
		"object": 0,
		"type": "ALPC Port",
		"name": "",
		"meta": {
			"Flags": 34144256,
			"Seqno": 4,
			"Context": 5264
		}
	},
	{
		"id": 5268,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 5272,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 5276,
		"object": 0,
		"type": "ALPC Port",
		"name": "",
		"meta": {
			"Flags": 34144256,
			"Seqno": 21,
			"Context": 5276
		}
	},
	{
		"id": 5280,
		"object": 0,
		"type": "IoCompletion",
		"name": ""
	},
	{
		"id": 5284,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 5288,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 5292,
		"object": 0,
		"type": "Key",
		"name": "HKEY_CURRENT_USER\\Classes\\Local Settings\\Software\\Microsoft\\Windows\\Shell\\Bags\\AllFolders\\Shell"
	},
	{
		"id": 5300,
		"object": 0,
		"type": "Event",
		"name": "\\BaseNamedObjects\\{c245290c-487c-4f81-9aba-7eb0dac882a2}"
	},
	{
		"id": 5312,
		"object": 0,
		"type": "WaitCompletionPacket",
		"name": ""
	},
	{
		"id": 5316,
		"object": 0,
		"type": "Key",
		"name": "HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\KGL\\OneSettings"
	},
	{
		"id": 5320,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 5328,
		"object": 0,
		"type": "Thread",
		"name": ""
	},
	{
		"id": 5332,
		"object": 0,
		"type": "Thread",
		"name": ""
	},
	{
		"id": 5364,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 5368,
		"object": 0,
		"type": "Event",
		"name": "\\BaseNamedObjects\\{CF8F7C29-0D29-4AAA-8A98-2674979117A1}"
	},
	{
		"id": 5372,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 5376,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 5380,
		"object": 0,
		"type": "Thread",
		"name": ""
	},
	{
		"id": 5384,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 5392,
		"object": 0,
		"type": "Thread",
		"name": ""
	},
	{
		"id": 5412,
		"object": 0,
		"type": "Event",
		"name": "\\Sessions\\1\\BaseNamedObjects\\BcastdvrStartup73BD1D72-A850-47FF-82E1-8F30D2C38FFE"
	},
	{
		"id": 5420,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 5428,
		"object": 0,
		"type": "Process",
		"name": "C:\\Users\\bunny\\AppData\\Roaming\\Spotify\\Spotify.exe"
	},
	{
		"id": 5432,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 5436,
		"object": 0,
		"type": "ALPC Port",
		"name": "",
		"meta": {
			"Flags": 0,
			"Seqno": 3,
			"Context": 109119872
		}
	},
	{
		"id": 5520,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 5524,
		"object": 0,
		"type": "ALPC Port",
		"name": "",
		"meta": {
			"Flags": 34144256,
			"Seqno": 23,
			"Context": 5524
		}
	},
	{
		"id": 5528,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 5532,
		"object": 0,
		"type": "Key",
		"name": "HKEY_CURRENT_USER\\Software\\Microsoft\\GameBar"
	},
	{
		"id": 5536,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 5540,
		"object": 0,
		"type": "WaitCompletionPacket",
		"name": ""
	},
	{
		"id": 5544,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 5548,
		"object": 0,
		"type": "WaitCompletionPacket",
		"name": ""
	},
	{
		"id": 5552,
		"object": 0,
		"type": "WaitCompletionPacket",
		"name": ""
	},
	{
		"id": 5556,
		"object": 0,
		"type": "Key",
		"name": "HKEY_CURRENT_USER\\Software\\Microsoft\\Windows\\CurrentVersion\\GameDVR"
	},
	{
		"id": 5560,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 5568,
		"object": 0,
		"type": "Thread",
		"name": ""
	},
	{
		"id": 5584,
		"object": 0,
		"type": "Key",
		"name": "HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Explorer\\CommandStore\\shell\\Windows.rename"
	},
	{
		"id": 5596,
		"object": 0,
		"type": "Thread",
		"name": ""
	},
	{
		"id": 5608,
		"object": 0,
		"type": "ALPC Port",
		"name": "",
		"meta": {
			"Flags": 458752,
			"Seqno": 2,
			"Context": 5608
		}
	},
	{
		"id": 5612,
		"object": 0,
		"type": "WaitCompletionPacket",
		"name": ""
	},
	{
		"id": 5624,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 5628,
		"object": 0,
		"type": "Key",
		"name": "HKEY_LOCAL_MACHINE"
	},
	{
		"id": 5632,
		"object": 0,
		"type": "Section",
		"name": "\\Sessions\\1\\BaseNamedObjects\\245cHWNDInterface:ca0706"
	},
	{
		"id": 5636,
		"object": 0,
		"type": "IoCompletion",
		"name": ""
	},
	{
		"id": 5656,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 5660,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 5668,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 5672,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 5700,
		"object": 0,
		"type": "IoCompletion",
		"name": ""
	},
	{
		"id": 5708,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 5720,
		"object": 0,
		"type": "Key",
		"name": "HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Explorer\\CommandStore\\shell\\Windows.newfolder"
	},
	{
		"id": 5724,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 5732,
		"object": 0,
		"type": "IoCompletion",
		"name": ""
	},
	{
		"id": 5756,
		"object": 0,
		"type": "Key",
		"name": "HKEY_LOCAL_MACHINE\\SOFTWARE\\Classes\\CLSID\\{1f3427c8-5c10-4210-aa03-2ee45287d668}\\Instance"
	},
	{
		"id": 5760,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 5764,
		"object": 0,
		"type": "Thread",
		"name": ""
	},
	{
		"id": 5768,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 5784,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 5788,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 5804,
		"object": 0,
		"type": "WaitCompletionPacket",
		"name": ""
	},
	{
		"id": 5808,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 5824,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 5828,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 5836,
		"object": 0,
		"type": "Process",
		"name": "C:\\Users\\bunny\\AppData\\Roaming\\Spotify\\Spotify.exe"
	},
	{
		"id": 5844,
		"object": 0,
		"type": "Thread",
		"name": ""
	},
	{
		"id": 5848,
		"object": 0,
		"type": "Semaphore",
		"name": ""
	},
	{
		"id": 5852,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 5868,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 5880,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 5884,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 5888,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 5896,
		"object": 0,
		"type": "WaitCompletionPacket",
		"name": ""
	},
	{
		"id": 5900,
		"object": 0,
		"type": "WmiGuid",
		"name": ""
	},
	{
		"id": 5920,
		"object": 0,
		"type": "Thread",
		"name": ""
	},
	{
		"id": 5924,
		"object": 0,
		"type": "ALPC Port",
		"name": "",
		"meta": {
			"Flags": 34144256,
			"Seqno": 6,
			"Context": 5924
		}
	},
	{
		"id": 5932,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 5936,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 5940,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 5944,
		"object": 0,
		"type": "Thread",
		"name": ""
	},
	{
		"id": 5948,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 5956,
		"object": 0,
		"type": "ALPC Port",
		"name": "",
		"meta": {
			"Flags": 34144256,
			"Seqno": 10,
			"Context": 5956
		}
	},
	{
		"id": 5960,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 5968,
		"object": 0,
		"type": "Thread",
		"name": ""
	},
	{
		"id": 6000,
		"object": 0,
		"type": "IoCompletion",
		"name": ""
	},
	{
		"id": 6004,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 6008,
		"object": 0,
		"type": "IoCompletion",
		"name": ""
	},
	{
		"id": 6012,
		"object": 0,
		"type": "Event",
		"name": "\\BaseNamedObjects\\{44ea083b-899c-4440-8338-2469fd4681cf}"
	},
	{
		"id": 6020,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 6024,
		"object": 0,
		"type": "IoCompletion",
		"name": ""
	},
	{
		"id": 6048,
		"object": 0,
		"type": "WaitCompletionPacket",
		"name": ""
	},
	{
		"id": 6056,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 6068,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 6072,
		"object": 0,
		"type": "DxgkCompositionObject",
		"name": ""
	},
	{
		"id": 6084,
		"object": 0,
		"type": "ALPC Port",
		"name": "",
		"meta": {
			"Flags": 458752,
			"Seqno": 0,
			"Context": 0
		}
	},
	{
		"id": 6104,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 6116,
		"object": 0,
		"type": "Section",
		"name": ""
	},
	{
		"id": 6128,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 6132,
		"object": 0,
		"type": "ALPC Port",
		"name": "",
		"meta": {
			"Flags": 34078720,
			"Seqno": 34,
			"Context": 99590352
		}
	},
	{
		"id": 6140,
		"object": 0,
		"type": "Key",
		"name": "HKEY_LOCAL_MACHINE\\SOFTWARE\\Classes\\CLSID\\{DFFACDC5-679F-4156-8947-C5C76BC0B67F}\\Instance"
	},
	{
		"id": 6160,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 6164,
		"object": 0,
		"type": "WaitCompletionPacket",
		"name": ""
	},
	{
		"id": 6168,
		"object": 0,
		"type": "DxgkCompositionObject",
		"name": ""
	},
	{
		"id": 6172,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 6176,
		"object": 0,
		"type": "ALPC Port",
		"name": "",
		"meta": {
			"Flags": 34078720,
			"Seqno": 52,
			"Context": 327856672
		}
	},
	{
		"id": 6180,
		"object": 0,
		"type": "Section",
		"name": "\\Sessions\\1\\BaseNamedObjects\\245cHWNDInterface:10380"
	},
	{
		"id": 6184,
		"object": 0,
		"type": "WaitCompletionPacket",
		"name": ""
	},
	{
		"id": 6188,
		"object": 0,
		"type": "Section",
		"name": "\\Sessions\\1\\BaseNamedObjects\\245cHWNDInterface:10380"
	},
	{
		"id": 6192,
		"object": 0,
		"type": "Section",
		"name": ""
	},
	{
		"id": 6196,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 6200,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 6204,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 6208,
		"object": 0,
		"type": "Thread",
		"name": ""
	},
	{
		"id": 6212,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 6220,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 6224,
		"object": 0,
		"type": "Mutant",
		"name": "",
		"meta": {
			"Count": 1,
			"IsAbandoned": false
		}
	},
	{
		"id": 6228,
		"object": 0,
		"type": "Key",
		"name": "HKEY_CURRENT_USER\\Software\\Microsoft\\Windows\\CurrentVersion\\SettingSync\\Groups"
	},
	{
		"id": 6240,
		"object": 0,
		"type": "Mutant",
		"name": "",
		"meta": {
			"Count": 1,
			"IsAbandoned": false
		}
	},
	{
		"id": 6244,
		"object": 0,
		"type": "Key",
		"name": "HKEY_CURRENT_USER\\Console"
	},
	{
		"id": 6248,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 6252,
		"object": 0,
		"type": "Key",
		"name": "HKEY_CURRENT_USER\\Software\\Microsoft\\Windows\\CurrentVersion\\Notifications\\Settings"
	},
	{
		"id": 6256,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 6260,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 6264,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 6268,
		"object": 0,
		"type": "ALPC Port",
		"name": "",
		"meta": {
			"Flags": 34144256,
			"Seqno": 10277,
			"Context": 6268
		}
	},
	{
		"id": 6292,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 6316,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 6320,
		"object": 0,
		"type": "Thread",
		"name": ""
	},
	{
		"id": 6324,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 6332,
		"object": 0,
		"type": "Section",
		"name": "\\Sessions\\1\\BaseNamedObjects\\245cHWNDInterface:404e6"
	},
	{
		"id": 6336,
		"object": 0,
		"type": "IoCompletion",
		"name": ""
	},
	{
		"id": 6344,
		"object": 0,
		"type": "Key",
		"name": "HKEY_CURRENT_USER\\Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\FeatureUsage"
	},
	{
		"id": 6356,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 6360,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 6364,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 6368,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 6372,
		"object": 0,
		"type": "Mutant",
		"name": "",
		"meta": {
			"Count": 1,
			"IsAbandoned": false
		}
	},
	{
		"id": 6376,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 6396,
		"object": 0,
		"type": "Thread",
		"name": ""
	},
	{
		"id": 6404,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 6412,
		"object": 0,
		"type": "Key",
		"name": "HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\MMDevices\\Audio\\Render\\{0868fdbf-c90c-41c7-be4c-7c220094765a}\\Properties"
	},
	{
		"id": 6416,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 6420,
		"object": 0,
		"type": "Mutant",
		"name": "",
		"meta": {
			"Count": 1,
			"IsAbandoned": false
		}
	},
	{
		"id": 6424,
		"object": 0,
		"type": "IoCompletionReserve",
		"name": ""
	},
	{
		"id": 6428,
		"object": 0,
		"type": "Mutant",
		"name": "",
		"meta": {
			"Count": 1,
			"IsAbandoned": false
		}
	},
	{
		"id": 6432,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 6436,
		"object": 0,
		"type": "Mutant",
		"name": "",
		"meta": {
			"Count": 1,
			"IsAbandoned": false
		}
	},
	{
		"id": 6440,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 6444,
		"object": 0,
		"type": "ALPC Port",
		"name": "",
		"meta": {
			"Flags": 34078720,
			"Seqno": 2,
			"Context": 327858688
		}
	},
	{
		"id": 6448,
		"object": 0,
		"type": "WaitCompletionPacket",
		"name": ""
	},
	{
		"id": 6452,
		"object": 0,
		"type": "Thread",
		"name": ""
	},
	{
		"id": 6456,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 6460,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 6472,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 6484,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 6496,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 6500,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 6504,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 6512,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 6516,
		"object": 0,
		"type": "Semaphore",
		"name": "\\Sessions\\1\\BaseNamedObjects\\CDP_CALLBACK_1753CA72-8431-5BA1-568C-695D2B1C5FD1"
	},
	{
		"id": 6524,
		"object": 0,
		"type": "Section",
		"name": ""
	},
	{
		"id": 6528,
		"object": 0,
		"type": "Key",
		"name": "HKEY_CURRENT_USER\\Classes\\Local Settings\\Software\\Microsoft\\Windows\\Shell\\Bags\\AllFolders\\Shell"
	},
	{
		"id": 6532,
		"object": 0,
		"type": "WaitCompletionPacket",
		"name": ""
	},
	{
		"id": 6536,
		"object": 0,
		"type": "WaitCompletionPacket",
		"name": ""
	},
	{
		"id": 6540,
		"object": 0,
		"type": "ALPC Port",
		"name": "",
		"meta": {
			"Flags": 458752,
			"Seqno": 3,
			"Context": 6540
		}
	},
	{
		"id": 6544,
		"object": 0,
		"type": "WaitCompletionPacket",
		"name": ""
	},
	{
		"id": 6548,
		"object": 0,
		"type": "ALPC Port",
		"name": "",
		"meta": {
			"Flags": 458752,
			"Seqno": 10,
			"Context": 6548
		}
	},
	{
		"id": 6552,
		"object": 0,
		"type": "Thread",
		"name": ""
	},
	{
		"id": 6556,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 6560,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 6564,
		"object": 0,
		"type": "Semaphore",
		"name": ""
	},
	{
		"id": 6568,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 6576,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 6580,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 6584,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 6588,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 6592,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 6596,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 6600,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 6608,
		"object": 0,
		"type": "ALPC Port",
		"name": "",
		"meta": {
			"Flags": 0,
			"Seqno": 1,
			"Context": 65216448
		}
	},
	{
		"id": 6616,
		"object": 0,
		"type": "IoCompletion",
		"name": ""
	},
	{
		"id": 6628,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 6636,
		"object": 0,
		"type": "ALPC Port",
		"name": "",
		"meta": {
			"Flags": 34144256,
			"Seqno": 3527,
			"Context": 6636
		}
	},
	{
		"id": 6640,
		"object": 0,
		"type": "Section",
		"name": "\\Sessions\\1\\BaseNamedObjects\\245cHWNDInterface:100a6"
	},
	{
		"id": 6648,
		"object": 0,
		"type": "Thread",
		"name": ""
	},
	{
		"id": 6656,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 6660,
		"object": 0,
		"type": "Thread",
		"name": ""
	},
	{
		"id": 6664,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 6716,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 6720,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 6724,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 6736,
		"object": 0,
		"type": "Event",
		"name": "\\BaseNamedObjects\\{4D5078EE-878B-4E83-A77E-C558B283594A}"
	},
	{
		"id": 6772,
		"object": 0,
		"type": "ALPC Port",
		"name": "",
		"meta": {
			"Flags": 34078720,
			"Seqno": 11,
			"Context": 99594384
		}
	},
	{
		"id": 6776,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 6780,
		"object": 0,
		"type": "ALPC Port",
		"name": "",
		"meta": {
			"Flags": 34144256,
			"Seqno": 6,
			"Context": 6780
		}
	},
	{
		"id": 6784,
		"object": 0,
		"type": "Thread",
		"name": ""
	},
	{
		"id": 6788,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 6804,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 6812,
		"object": 0,
		"type": "Event",
		"name": "\\Sessions\\1\\BaseNamedObjects\\ShellDesktopSwitchEvent"
	},
	{
		"id": 6816,
		"object": 0,
		"type": "Section",
		"name": "\\Sessions\\1\\BaseNamedObjects\\C:*Users*bunny*AppData*Local*Microsoft*Windows*Caches*{3DA71D5A-20CC-432F-A115-DFE92379E91F}.3.ver0x00000000000001ab.db"
	},
	{
		"id": 6820,
		"object": 0,
		"type": "Key",
		"name": "HKEY_CURRENT_USER\\Classes\\CLSID\\{031E4825-7B94-4dc3-B131-E946B44C8DD5}"
	},
	{
		"id": 6828,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 6832,
		"object": 0,
		"type": "Key",
		"name": "HKEY_CURRENT_USER\\Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\BannerStore"
	},
	{
		"id": 6840,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 6844,
		"object": 0,
		"type": "Key",
		"name": "HKEY_CURRENT_USER\\Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\CabinetState"
	},
	{
		"id": 6848,
		"object": 0,
		"type": "WaitCompletionPacket",
		"name": ""
	},
	{
		"id": 6852,
		"object": 0,
		"type": "Key",
		"name": "HKEY_CURRENT_USER\\Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\Advanced"
	},
	{
		"id": 6856,
		"object": 0,
		"type": "Key",
		"name": "HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Explorer\\SyncRootManager"
	},
	{
		"id": 6860,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 6864,
		"object": 0,
		"type": "WaitCompletionPacket",
		"name": ""
	},
	{
		"id": 6868,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 6880,
		"object": 0,
		"type": "WaitCompletionPacket",
		"name": ""
	},
	{
		"id": 6884,
		"object": 0,
		"type": "Key",
		"name": "HKEY_CURRENT_USER\\Software\\Microsoft\\Windows\\CurrentVersion\\Explorer"
	},
	{
		"id": 6888,
		"object": 0,
		"type": "Section",
		"name": "\\Sessions\\1\\BaseNamedObjects\\245cHWNDInterface:107e2"
	},
	{
		"id": 6892,
		"object": 0,
		"type": "WaitCompletionPacket",
		"name": ""
	},
	{
		"id": 6896,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 6900,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 6908,
		"object": 0,
		"type": "WaitCompletionPacket",
		"name": ""
	},
	{
		"id": 6912,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 6916,
		"object": 0,
		"type": "Key",
		"name": "HKEY_CURRENT_USER\\Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\Search\\PrimaryProperties\\IndexedLocations"
	},
	{
		"id": 6920,
		"object": 0,
		"type": "Key",
		"name": "HKEY_CURRENT_USER\\Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\Ribbon"
	},
	{
		"id": 6924,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 6928,
		"object": 0,
		"type": "WaitCompletionPacket",
		"name": ""
	},
	{
		"id": 6932,
		"object": 0,
		"type": "WaitCompletionPacket",
		"name": ""
	},
	{
		"id": 6936,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 6940,
		"object": 0,
		"type": "Key",
		"name": "HKEY_CURRENT_USER\\Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\Search\\PrimaryProperties\\UnindexedLocations"
	},
	{
		"id": 6944,
		"object": 0,
		"type": "Key",
		"name": "HKEY_CURRENT_USER\\Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\Modules\\GlobalSettings\\DetailsContainer"
	},
	{
		"id": 6948,
		"object": 0,
		"type": "Key",
		"name": "HKEY_CURRENT_USER\\Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\Search\\Preferences"
	},
	{
		"id": 6952,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 6956,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 6960,
		"object": 0,
		"type": "WaitCompletionPacket",
		"name": ""
	},
	{
		"id": 6964,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 6968,
		"object": 0,
		"type": "WaitCompletionPacket",
		"name": ""
	},
	{
		"id": 6972,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 6976,
		"object": 0,
		"type": "WaitCompletionPacket",
		"name": ""
	},
	{
		"id": 6980,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 6984,
		"object": 0,
		"type": "WaitCompletionPacket",
		"name": ""
	},
	{
		"id": 6988,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 6992,
		"object": 0,
		"type": "WaitCompletionPacket",
		"name": ""
	},
	{
		"id": 6996,
		"object": 0,
		"type": "Key",
		"name": "HKEY_CURRENT_USER\\Software\\Microsoft\\Windows\\CurrentVersion\\Themes\\Personalize"
	},
	{
		"id": 7004,
		"object": 0,
		"type": "Key",
		"name": "HKEY_CURRENT_USER\\Control Panel\\International"
	},
	{
		"id": 7008,
		"object": 0,
		"type": "Key",
		"name": "HKEY_CURRENT_USER\\Software\\Microsoft\\Windows\\CurrentVersion\\HomeGroup\\Roaming"
	},
	{
		"id": 7012,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 7016,
		"object": 0,
		"type": "WaitCompletionPacket",
		"name": ""
	},
	{
		"id": 7020,
		"object": 0,
		"type": "Key",
		"name": "HKEY_CURRENT_USER\\Software\\Microsoft\\InputMethod\\JPN\\roaming\\mon"
	},
	{
		"id": 7024,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 7028,
		"object": 0,
		"type": "WaitCompletionPacket",
		"name": ""
	},
	{
		"id": 7032,
		"object": 0,
		"type": "Key",
		"name": "HKEY_CURRENT_USER\\Software\\Microsoft\\InputMethod\\KOR\\roaming\\mon"
	},
	{
		"id": 7036,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 7040,
		"object": 0,
		"type": "WaitCompletionPacket",
		"name": ""
	},
	{
		"id": 7044,
		"object": 0,
		"type": "Key",
		"name": "HKEY_CURRENT_USER\\Control Panel\\International\\User Profile"
	},
	{
		"id": 7048,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 7052,
		"object": 0,
		"type": "WaitCompletionPacket",
		"name": ""
	},
	{
		"id": 7056,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 7060,
		"object": 0,
		"type": "WaitCompletionPacket",
		"name": ""
	},
	{
		"id": 7072,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 7076,
		"object": 0,
		"type": "WaitCompletionPacket",
		"name": ""
	},
	{
		"id": 7080,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 7084,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 7092,
		"object": 0,
		"type": "WaitCompletionPacket",
		"name": ""
	},
	{
		"id": 7100,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 7108,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 7116,
		"object": 0,
		"type": "Key",
		"name": "HKEY_LOCAL_MACHINE\\SYSTEM\\ControlSet001\\Control\\NetworkUxManager"
	},
	{
		"id": 7124,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 7128,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 7136,
		"object": 0,
		"type": "WaitCompletionPacket",
		"name": ""
	},
	{
		"id": 7140,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 7144,
		"object": 0,
		"type": "Key",
		"name": "HKEY_CURRENT_USER\\Control Panel\\Quick Actions"
	},
	{
		"id": 7160,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 7164,
		"object": 0,
		"type": "Thread",
		"name": ""
	},
	{
		"id": 7172,
		"object": 0,
		"type": "Key",
		"name": "HKEY_CURRENT_USER\\Software\\Microsoft\\InputMethod\\Settings"
	},
	{
		"id": 7176,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 7180,
		"object": 0,
		"type": "WaitCompletionPacket",
		"name": ""
	},
	{
		"id": 7184,
		"object": 0,
		"type": "Thread",
		"name": ""
	},
	{
		"id": 7188,
		"object": 0,
		"type": "UserApcReserve",
		"name": ""
	},
	{
		"id": 7208,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 7212,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 7216,
		"object": 0,
		"type": "Key",
		"name": "HKEY_LOCAL_MACHINE\\SYSTEM\\ControlSet001\\Services\\WinSock2\\Parameters\\Protocol_Catalog9"
	},
	{
		"id": 7220,
		"object": 0,
		"type": "Key",
		"name": "HKEY_LOCAL_MACHINE\\SYSTEM\\ControlSet001\\Services\\WinSock2\\Parameters\\NameSpace_Catalog5"
	},
	{
		"id": 7228,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 7232,
		"object": 0,
		"type": "Thread",
		"name": ""
	},
	{
		"id": 7236,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 7240,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 7244,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 7248,
		"object": 0,
		"type": "UserApcReserve",
		"name": ""
	},
	{
		"id": 7252,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 7260,
		"object": 0,
		"type": "Key",
		"name": "HKEY_CURRENT_USER\\Software\\Microsoft\\Windows\\DWM"
	},
	{
		"id": 7264,
		"object": 0,
		"type": "Thread",
		"name": ""
	},
	{
		"id": 7268,
		"object": 0,
		"type": "WaitCompletionPacket",
		"name": ""
	},
	{
		"id": 7272,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 7280,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 7284,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 7288,
		"object": 0,
		"type": "UserApcReserve",
		"name": ""
	},
	{
		"id": 7296,
		"object": 0,
		"type": "WaitCompletionPacket",
		"name": ""
	},
	{
		"id": 7300,
		"object": 0,
		"type": "Key",
		"name": "HKEY_CURRENT_USER\\Software\\Microsoft\\Internet Explorer\\IntelliForms\\FormData"
	},
	{
		"id": 7304,
		"object": 0,
		"type": "Key",
		"name": "HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\SettingSync\\BrowserSettings"
	},
	{
		"id": 7308,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 7312,
		"object": 0,
		"type": "WaitCompletionPacket",
		"name": ""
	},
	{
		"id": 7320,
		"object": 0,
		"type": "ALPC Port",
		"name": "",
		"meta": {
			"Flags": 34078720,
			"Seqno": 5,
			"Context": 99601776
		}
	},
	{
		"id": 7324,
		"object": 0,
		"type": "ALPC Port",
		"name": "",
		"meta": {
			"Flags": 34078720,
			"Seqno": 2,
			"Context": 99588336
		}
	},
	{
		"id": 7332,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 7336,
		"object": 0,
		"type": "Key",
		"name": "HKEY_CURRENT_USER\\Software\\Microsoft\\Internet Explorer\\DomainSuggestion\\Exclude"
	},
	{
		"id": 7340,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 7344,
		"object": 0,
		"type": "WaitCompletionPacket",
		"name": ""
	},
	{
		"id": 7348,
		"object": 0,
		"type": "Key",
		"name": "HKEY_CURRENT_USER\\Software\\Microsoft\\Internet Explorer\\TabbedBrowsing"
	},
	{
		"id": 7352,
		"object": 0,
		"type": "WaitCompletionPacket",
		"name": ""
	},
	{
		"id": 7356,
		"object": 0,
		"type": "ALPC Port",
		"name": "",
		"meta": {
			"Flags": 34209792,
			"Seqno": 23,
			"Context": 0
		}
	},
	{
		"id": 7360,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 7364,
		"object": 0,
		"type": "WaitCompletionPacket",
		"name": ""
	},
	{
		"id": 7368,
		"object": 0,
		"type": "Thread",
		"name": ""
	},
	{
		"id": 7372,
		"object": 0,
		"type": "Key",
		"name": "HKEY_CURRENT_USER\\Software\\Microsoft\\Windows\\CurrentVersion\\Internet Settings\\Zones\\3"
	},
	{
		"id": 7376,
		"object": 0,
		"type": "Thread",
		"name": ""
	},
	{
		"id": 7384,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 7396,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 7400,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 7404,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 7408,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 7432,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 7440,
		"object": 0,
		"type": "Key",
		"name": "HKEY_CURRENT_USER\\Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\MenuOrder\\Favorites"
	},
	{
		"id": 7444,
		"object": 0,
		"type": "WaitCompletionPacket",
		"name": ""
	},
	{
		"id": 7448,
		"object": 0,
		"type": "Key",
		"name": "HKEY_CURRENT_USER\\Software\\Microsoft\\Internet Explorer\\FlipAhead"
	},
	{
		"id": 7452,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 7456,
		"object": 0,
		"type": "WaitCompletionPacket",
		"name": ""
	},
	{
		"id": 7464,
		"object": 0,
		"type": "WaitCompletionPacket",
		"name": ""
	},
	{
		"id": 7468,
		"object": 0,
		"type": "Key",
		"name": "HKEY_CURRENT_USER\\Software\\Microsoft\\Windows\\CurrentVersion\\CloudStore"
	},
	{
		"id": 7472,
		"object": 0,
		"type": "Key",
		"name": "HKEY_CURRENT_USER\\Software\\Microsoft\\Internet Explorer\\Main"
	},
	{
		"id": 7476,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 7480,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 7484,
		"object": 0,
		"type": "WaitCompletionPacket",
		"name": ""
	},
	{
		"id": 7488,
		"object": 0,
		"type": "Key",
		"name": "HKEY_CURRENT_USER\\Software\\Microsoft\\Internet Explorer\\IntelliForms"
	},
	{
		"id": 7500,
		"object": 0,
		"type": "WaitCompletionPacket",
		"name": ""
	},
	{
		"id": 7504,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 7508,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 7512,
		"object": 0,
		"type": "Key",
		"name": "HKEY_CURRENT_USER\\Software\\Microsoft\\Internet Explorer\\FullScreen\\AllowDomains"
	},
	{
		"id": 7516,
		"object": 0,
		"type": "ALPC Port",
		"name": "",
		"meta": {
			"Flags": 458752,
			"Seqno": 3,
			"Context": 7516
		}
	},
	{
		"id": 7520,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 7524,
		"object": 0,
		"type": "WaitCompletionPacket",
		"name": ""
	},
	{
		"id": 7528,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 7532,
		"object": 0,
		"type": "Key",
		"name": "HKEY_CURRENT_USER\\Software\\Microsoft\\Internet Explorer\\New Windows\\Allow"
	},
	{
		"id": 7536,
		"object": 0,
		"type": "WaitCompletionPacket",
		"name": ""
	},
	{
		"id": 7540,
		"object": 0,
		"type": "Key",
		"name": "HKEY_CURRENT_USER\\Software\\Microsoft\\Windows\\CurrentVersion\\Internet Settings"
	},
	{
		"id": 7544,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 7548,
		"object": 0,
		"type": "WaitCompletionPacket",
		"name": ""
	},
	{
		"id": 7552,
		"object": 0,
		"type": "Key",
		"name": "HKEY_CURRENT_USER\\Software\\Microsoft\\Internet Explorer\\SearchScopes"
	},
	{
		"id": 7556,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 7560,
		"object": 0,
		"type": "WaitCompletionPacket",
		"name": ""
	},
	{
		"id": 7564,
		"object": 0,
		"type": "Key",
		"name": "HKEY_CURRENT_USER\\Software\\Microsoft\\Internet Explorer\\Main"
	},
	{
		"id": 7568,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 7572,
		"object": 0,
		"type": "WaitCompletionPacket",
		"name": ""
	},
	{
		"id": 7576,
		"object": 0,
		"type": "Key",
		"name": "HKEY_CURRENT_USER\\Software\\Microsoft\\Internet Explorer\\Main"
	},
	{
		"id": 7580,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 7584,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 7588,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 7592,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 7596,
		"object": 0,
		"type": "WaitCompletionPacket",
		"name": ""
	},
	{
		"id": 7600,
		"object": 0,
		"type": "Key",
		"name": "HKEY_CURRENT_USER\\Software\\Microsoft\\Internet Explorer\\Safety\\PrivacIE"
	},
	{
		"id": 7604,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 7608,
		"object": 0,
		"type": "WaitCompletionPacket",
		"name": ""
	},
	{
		"id": 7612,
		"object": 0,
		"type": "Key",
		"name": "HKEY_CURRENT_USER\\Software\\Microsoft\\Internet Explorer\\Safety\\Tracking Protection Exceptions"
	},
	{
		"id": 7616,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 7620,
		"object": 0,
		"type": "WaitCompletionPacket",
		"name": ""
	},
	{
		"id": 7624,
		"object": 0,
		"type": "Key",
		"name": "HKEY_CURRENT_USER\\Software\\Microsoft\\Internet Explorer\\Safety\\PrivacIE\\Lists"
	},
	{
		"id": 7628,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 7632,
		"object": 0,
		"type": "WaitCompletionPacket",
		"name": ""
	},
	{
		"id": 7636,
		"object": 0,
		"type": "Key",
		"name": "HKEY_CURRENT_USER\\Software\\Microsoft\\Internet Explorer\\TypedURLs"
	},
	{
		"id": 7640,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 7644,
		"object": 0,
		"type": "WaitCompletionPacket",
		"name": ""
	},
	{
		"id": 7648,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 7652,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 7656,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 7664,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 7676,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 7680,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 7684,
		"object": 0,
		"type": "Key",
		"name": "HKEY_CURRENT_USER\\Software\\Microsoft\\Windows\\CurrentVersion\\Internet Settings\\5.0\\Cache"
	},
	{
		"id": 7688,
		"object": 0,
		"type": "Thread",
		"name": ""
	},
	{
		"id": 7692,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 7700,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 7704,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 7716,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 7724,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 7744,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 7748,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 7756,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 7760,
		"object": 0,
		"type": "IoCompletionReserve",
		"name": ""
	},
	{
		"id": 7764,
		"object": 0,
		"type": "ALPC Port",
		"name": "",
		"meta": {
			"Flags": 0,
			"Seqno": 20,
			"Context": 109113136
		}
	},
	{
		"id": 7768,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 7772,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 7776,
		"object": 0,
		"type": "Event",
		"name": "\\Sessions\\1\\BaseNamedObjects\\ShellLauncherLoginEvent"
	},
	{
		"id": 7796,
		"object": 0,
		"type": "Thread",
		"name": ""
	},
	{
		"id": 7804,
		"object": 0,
		"type": "ALPC Port",
		"name": "",
		"meta": {
			"Flags": 0,
			"Seqno": 1401,
			"Context": 108332496
		}
	},
	{
		"id": 7812,
		"object": 0,
		"type": "ALPC Port",
		"name": "",
		"meta": {
			"Flags": 458752,
			"Seqno": 8,
			"Context": 0
		}
	},
	{
		"id": 7816,
		"object": 0,
		"type": "Thread",
		"name": ""
	},
	{
		"id": 7820,
		"object": 0,
		"type": "ALPC Port",
		"name": "",
		"meta": {
			"Flags": 458752,
			"Seqno": 10,
			"Context": 7820
		}
	},
	{
		"id": 7824,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 7828,
		"object": 0,
		"type": "Timer",
		"name": ""
	},
	{
		"id": 7832,
		"object": 0,
		"type": "Timer",
		"name": ""
	},
	{
		"id": 7836,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 7840,
		"object": 0,
		"type": "WaitCompletionPacket",
		"name": ""
	},
	{
		"id": 7844,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 7848,
		"object": 0,
		"type": "WaitCompletionPacket",
		"name": ""
	},
	{
		"id": 7852,
		"object": 0,
		"type": "WaitCompletionPacket",
		"name": ""
	},
	{
		"id": 7856,
		"object": 0,
		"type": "WaitCompletionPacket",
		"name": ""
	},
	{
		"id": 7860,
		"object": 0,
		"type": "Thread",
		"name": ""
	},
	{
		"id": 7864,
		"object": 0,
		"type": "WaitCompletionPacket",
		"name": ""
	},
	{
		"id": 7868,
		"object": 0,
		"type": "WaitCompletionPacket",
		"name": ""
	},
	{
		"id": 7872,
		"object": 0,
		"type": "ALPC Port",
		"name": "",
		"meta": {
			"Flags": 458752,
			"Seqno": 2,
			"Context": 7872
		}
	},
	{
		"id": 7876,
		"object": 0,
		"type": "WaitCompletionPacket",
		"name": ""
	},
	{
		"id": 7880,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 7892,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 7896,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 7904,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 7908,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 7912,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 7916,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 7924,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 7932,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 7940,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 7952,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 7960,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 7976,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 7980,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 7988,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 7992,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 7996,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 8004,
		"object": 0,
		"type": "ALPC Port",
		"name": "",
		"meta": {
			"Flags": 34144256,
			"Seqno": 4,
			"Context": 8004
		}
	},
	{
		"id": 8024,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 8028,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 8036,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 8040,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 8048,
		"object": 0,
		"type": "WaitCompletionPacket",
		"name": ""
	},
	{
		"id": 8060,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 8072,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 8080,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 8088,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 8092,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 8100,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 8112,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 8116,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 8120,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 8124,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 8132,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 8144,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 8148,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 8152,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 8156,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 8168,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 8176,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 8188,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 8200,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 8208,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 8216,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 8224,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 8232,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 8240,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 8248,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 8256,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 8264,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 8272,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 8280,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 8288,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 8296,
		"object": 0,
		"type": "Process",
		"name": "C:\\Users\\bunny\\AppData\\Roaming\\Spotify\\Spotify.exe"
	},
	{
		"id": 8300,
		"object": 0,
		"type": "Event",
		"name": "\\BaseNamedObjects\\{c245290c-487c-4f81-9aba-7eb0dac882a2}"
	},
	{
		"id": 8304,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 8308,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 8320,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 8332,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 8340,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 8344,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 8356,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 8364,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 8376,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 8384,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 8392,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 8396,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 8400,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 8420,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 8424,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 8436,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 8440,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 8444,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 8448,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 8464,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 8468,
		"object": 0,
		"type": "Thread",
		"name": ""
	},
	{
		"id": 8472,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 8476,
		"object": 0,
		"type": "Thread",
		"name": ""
	},
	{
		"id": 8488,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 8492,
		"object": 0,
		"type": "Semaphore",
		"name": ""
	},
	{
		"id": 8496,
		"object": 0,
		"type": "Semaphore",
		"name": ""
	},
	{
		"id": 8500,
		"object": 0,
		"type": "Timer",
		"name": ""
	},
	{
		"id": 8504,
		"object": 0,
		"type": "Thread",
		"name": ""
	},
	{
		"id": 8520,
		"object": 0,
		"type": "Key",
		"name": "HKEY_LOCAL_MACHINE\\SOFTWARE\\Policies"
	},
	{
		"id": 8532,
		"object": 0,
		"type": "Thread",
		"name": ""
	},
	{
		"id": 8540,
		"object": 0,
		"type": "Event",
		"name": "\\BaseNamedObjects\\{44ea083b-899c-4440-8338-2469fd4681cf}"
	},
	{
		"id": 8544,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 8552,
		"object": 0,
		"type": "Thread",
		"name": ""
	},
	{
		"id": 8556,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 8568,
		"object": 0,
		"type": "WaitCompletionPacket",
		"name": ""
	},
	{
		"id": 8576,
		"object": 0,
		"type": "ALPC Port",
		"name": "",
		"meta": {
			"Flags": 34144256,
			"Seqno": 255,
			"Context": 8576
		}
	},
	{
		"id": 8580,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 8592,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 8596,
		"object": 0,
		"type": "Key",
		"name": "HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows Search\\CrawlScopeManager\\Windows\\SystemIndex\\SearchRoots"
	},
	{
		"id": 8628,
		"object": 0,
		"type": "Thread",
		"name": ""
	},
	{
		"id": 8632,
		"object": 0,
		"type": "ALPC Port",
		"name": "",
		"meta": {
			"Flags": 458752,
			"Seqno": 11,
			"Context": 8632
		}
	},
	{
		"id": 8636,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 8640,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 8728,
		"object": 0,
		"type": "WaitCompletionPacket",
		"name": ""
	},
	{
		"id": 8732,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 8740,
		"object": 0,
		"type": "Thread",
		"name": ""
	},
	{
		"id": 8744,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 8748,
		"object": 0,
		"type": "Timer",
		"name": ""
	},
	{
		"id": 8752,
		"object": 0,
		"type": "Timer",
		"name": ""
	},
	{
		"id": 8756,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 8760,
		"object": 0,
		"type": "WaitCompletionPacket",
		"name": ""
	},
	{
		"id": 8764,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 8768,
		"object": 0,
		"type": "WaitCompletionPacket",
		"name": ""
	},
	{
		"id": 8772,
		"object": 0,
		"type": "WaitCompletionPacket",
		"name": ""
	},
	{
		"id": 8776,
		"object": 0,
		"type": "WaitCompletionPacket",
		"name": ""
	},
	{
		"id": 8780,
		"object": 0,
		"type": "Thread",
		"name": ""
	},
	{
		"id": 8784,
		"object": 0,
		"type": "WaitCompletionPacket",
		"name": ""
	},
	{
		"id": 8788,
		"object": 0,
		"type": "IoCompletionReserve",
		"name": ""
	},
	{
		"id": 8792,
		"object": 0,
		"type": "Thread",
		"name": ""
	},
	{
		"id": 8796,
		"object": 0,
		"type": "ALPC Port",
		"name": "",
		"meta": {
			"Flags": 458752,
			"Seqno": 7,
			"Context": 0
		}
	},
	{
		"id": 8800,
		"object": 0,
		"type": "WaitCompletionPacket",
		"name": ""
	},
	{
		"id": 8804,
		"object": 0,
		"type": "ALPC Port",
		"name": "",
		"meta": {
			"Flags": 458752,
			"Seqno": 3,
			"Context": 8804
		}
	},
	{
		"id": 8808,
		"object": 0,
		"type": "WaitCompletionPacket",
		"name": ""
	},
	{
		"id": 8812,
		"object": 0,
		"type": "Key",
		"name": "HKEY_CURRENT_USER\\Software\\Policies"
	},
	{
		"id": 8816,
		"object": 0,
		"type": "Thread",
		"name": ""
	},
	{
		"id": 8820,
		"object": 0,
		"type": "ALPC Port",
		"name": "",
		"meta": {
			"Flags": 0,
			"Seqno": 21,
			"Context": 64834608
		}
	},
	{
		"id": 8824,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 8828,
		"object": 0,
		"type": "Key",
		"name": "HKEY_CURRENT_USER\\Software"
	},
	{
		"id": 8836,
		"object": 0,
		"type": "WaitCompletionPacket",
		"name": ""
	},
	{
		"id": 8840,
		"object": 0,
		"type": "Timer",
		"name": ""
	},
	{
		"id": 8844,
		"object": 0,
		"type": "WaitCompletionPacket",
		"name": ""
	},
	{
		"id": 8848,
		"object": 0,
		"type": "WaitCompletionPacket",
		"name": ""
	},
	{
		"id": 8852,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 8856,
		"object": 0,
		"type": "ALPC Port",
		"name": "",
		"meta": {
			"Flags": 34144256,
			"Seqno": 18,
			"Context": 8856
		}
	},
	{
		"id": 8864,
		"object": 0,
		"type": "ALPC Port",
		"name": "",
		"meta": {
			"Flags": 34078720,
			"Seqno": 5,
			"Context": 99598416
		}
	},
	{
		"id": 8868,
		"object": 0,
		"type": "ALPC Port",
		"name": "",
		"meta": {
			"Flags": 34144256,
			"Seqno": 7,
			"Context": 8868
		}
	},
	{
		"id": 8880,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 8884,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 8892,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 8908,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 8912,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 8916,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 8924,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 8928,
		"object": 0,
		"type": "Key",
		"name": "HKEY_LOCAL_MACHINE\\SOFTWARE\\Classes\\CLSID\\{1f3427c8-5c10-4210-aa03-2ee45287d668}\\Instance"
	},
	{
		"id": 8948,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 8952,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 8956,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 8960,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 8964,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 8968,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 8972,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 8976,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 8980,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 8984,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 8996,
		"object": 0,
		"type": "Key",
		"name": "HKEY_LOCAL_MACHINE\\SOFTWARE"
	},
	{
		"id": 9000,
		"object": 0,
		"type": "Key",
		"name": "HKEY_LOCAL_MACHINE\\SOFTWARE\\WOW6432Node"
	},
	{
		"id": 9004,
		"object": 0,
		"type": "Key",
		"name": "HKEY_CURRENT_USER\\Software\\Microsoft\\Windows\\CurrentVersion\\Internet Settings\\ZoneMap"
	},
	{
		"id": 9008,
		"object": 0,
		"type": "Key",
		"name": "HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Internet Settings\\ZoneMap"
	},
	{
		"id": 9012,
		"object": 0,
		"type": "Section",
		"name": "\\Sessions\\1\\BaseNamedObjects\\UrlZonesSM_bunny"
	},
	{
		"id": 9020,
		"object": 0,
		"type": "Mutant",
		"name": "",
		"meta": {
			"Count": 1,
			"IsAbandoned": false
		}
	},
	{
		"id": 9024,
		"object": 0,
		"type": "Mutant",
		"name": "",
		"meta": {
			"Count": 1,
			"IsAbandoned": false
		}
	},
	{
		"id": 9032,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 9040,
		"object": 0,
		"type": "Mutant",
		"name": "",
		"meta": {
			"Count": 1,
			"IsAbandoned": false
		}
	},
	{
		"id": 9044,
		"object": 0,
		"type": "Key",
		"name": "HKEY_CURRENT_USER\\Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\UserAssist\\{CEBFF5CD-ACE2-4F4F-9178-9926F41749EA}\\Count"
	},
	{
		"id": 9048,
		"object": 0,
		"type": "Key",
		"name": "HKEY_CURRENT_USER\\Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\UserAssist\\{F4E57C4B-2036-45F0-A9AB-443BCFE33D9F}\\Count"
	},
	{
		"id": 9052,
		"object": 0,
		"type": "Key",
		"name": "HKEY_CURRENT_USER\\Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\UserAssist\\{B267E3AD-A825-4A09-82B9-EEC22AA3B847}\\Count"
	},
	{
		"id": 9056,
		"object": 0,
		"type": "Key",
		"name": "HKEY_CURRENT_USER\\Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\UserAssist\\{9E04CAB2-CC14-11DF-BB8C-A2F1DED72085}\\Count"
	},
	{
		"id": 9060,
		"object": 0,
		"type": "Key",
		"name": "HKEY_CURRENT_USER\\Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\UserAssist\\{FA99DFC7-6AC2-453A-A5E2-5E2AFF4507BD}\\Count"
	},
	{
		"id": 9064,
		"object": 0,
		"type": "Key",
		"name": "HKEY_CURRENT_USER\\Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\UserAssist\\{CAA59E3C-4792-41A5-9909-6A6A8D32490E}\\Count"
	},
	{
		"id": 9068,
		"object": 0,
		"type": "Key",
		"name": "HKEY_CURRENT_USER\\Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\UserAssist\\{A3D53349-6E61-4557-8FC7-0028EDCEEBF6}\\Count"
	},
	{
		"id": 9072,
		"object": 0,
		"type": "Key",
		"name": "HKEY_CURRENT_USER\\Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\UserAssist\\{F2A1CB5A-E3CC-4A2E-AF9D-505A7009D442}\\Count"
	},
	{
		"id": 9076,
		"object": 0,
		"type": "Key",
		"name": "HKEY_CURRENT_USER\\Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\UserAssist\\{BCB48336-4DDD-48FF-BB0B-D3190DACB3E2}\\Count"
	},
	{
		"id": 9088,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 9092,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 9096,
		"object": 0,
		"type": "Key",
		"name": "HKEY_LOCAL_MACHINE\\SYSTEM\\ControlSet001\\Control\\NetworkProvider\\HwOrder"
	},
	{
		"id": 9100,
		"object": 0,
		"type": "Key",
		"name": "HKEY_LOCAL_MACHINE\\SYSTEM\\ControlSet001\\Control\\NetworkProvider\\ProviderOrder"
	},
	{
		"id": 9104,
		"object": 0,
		"type": "Semaphore",
		"name": ""
	},
	{
		"id": 9108,
		"object": 0,
		"type": "Semaphore",
		"name": ""
	},
	{
		"id": 9124,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 9128,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 9132,
		"object": 0,
		"type": "ALPC Port",
		"name": "",
		"meta": {
			"Flags": 34144256,
			"Seqno": 6,
			"Context": 9132
		}
	},
	{
		"id": 9144,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 9148,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 9152,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 9160,
		"object": 0,
		"type": "Thread",
		"name": ""
	},
	{
		"id": 9164,
		"object": 0,
		"type": "IoCompletion",
		"name": ""
	},
	{
		"id": 9168,
		"object": 0,
		"type": "WaitCompletionPacket",
		"name": ""
	},
	{
		"id": 9172,
		"object": 0,
		"type": "Thread",
		"name": ""
	},
	{
		"id": 9180,
		"object": 0,
		"type": "Thread",
		"name": ""
	},
	{
		"id": 9184,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 9196,
		"object": 0,
		"type": "IoCompletion",
		"name": ""
	},
	{
		"id": 9200,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 9220,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 9224,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 9228,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 9232,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 9236,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 9240,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 9244,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 9248,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 9252,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 9256,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 9260,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 9264,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 9268,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 9272,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 9276,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 9280,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 9284,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 9288,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 9292,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 9296,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 9300,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 9304,
		"object": 0,
		"type": "Thread",
		"name": ""
	},
	{
		"id": 9308,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 9312,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 9316,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 9320,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 9324,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 9328,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 9332,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 9336,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 9340,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 9344,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 9348,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 9352,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 9356,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 9360,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 9364,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 9368,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 9372,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 9376,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 9380,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 9384,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 9388,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 9392,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 9396,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 9400,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 9404,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 9408,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 9412,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 9416,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 9420,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 9424,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 9428,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 9432,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 9436,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 9440,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 9444,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 9448,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 9452,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 9456,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 9460,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 9464,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 9468,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 9472,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 9476,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 9480,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 9484,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 9488,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 9492,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 9496,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 9500,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 9504,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 9508,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 9512,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 9516,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 9520,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 9524,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 9528,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 9532,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 9536,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 9540,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 9544,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 9548,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 9552,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 9556,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 9560,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 9564,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 9568,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 9572,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 9576,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 9580,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 9584,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 9588,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 9592,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 9596,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 9600,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 9604,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 9608,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 9612,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 9616,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 9620,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 9624,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 9628,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 9632,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 9636,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 9640,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 9644,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 9648,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 9652,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 9656,
		"object": 0,
		"type": "Thread",
		"name": ""
	},
	{
		"id": 9660,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 9668,
		"object": 0,
		"type": "Thread",
		"name": ""
	},
	{
		"id": 9672,
		"object": 0,
		"type": "Thread",
		"name": ""
	},
	{
		"id": 9676,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 9680,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 9684,
		"object": 0,
		"type": "Thread",
		"name": ""
	},
	{
		"id": 9692,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 9704,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 9708,
		"object": 0,
		"type": "Thread",
		"name": ""
	},
	{
		"id": 9712,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 9716,
		"object": 0,
		"type": "WaitCompletionPacket",
		"name": ""
	},
	{
		"id": 9720,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 9724,
		"object": 0,
		"type": "Thread",
		"name": ""
	},
	{
		"id": 9728,
		"object": 0,
		"type": "ALPC Port",
		"name": "",
		"meta": {
			"Flags": 34144256,
			"Seqno": 243,
			"Context": 9728
		}
	},
	{
		"id": 9732,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 9740,
		"object": 0,
		"type": "IoCompletion",
		"name": ""
	},
	{
		"id": 9744,
		"object": 0,
		"type": "Key",
		"name": "HKEY_CURRENT_USER\\Classes\\Local Settings\\Software\\Microsoft\\Windows\\Shell\\MuiCache"
	},
	{
		"id": 9748,
		"object": 0,
		"type": "ALPC Port",
		"name": "",
		"meta": {
			"Flags": 458752,
			"Seqno": 7,
			"Context": 9748
		}
	},
	{
		"id": 9760,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 9764,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 9768,
		"object": 0,
		"type": "IoCompletion",
		"name": ""
	},
	{
		"id": 9772,
		"object": 0,
		"type": "Thread",
		"name": ""
	},
	{
		"id": 9776,
		"object": 0,
		"type": "Key",
		"name": "HKEY_CURRENT_USER\\Software\\Microsoft\\Windows\\CurrentVersion\\CloudStore"
	},
	{
		"id": 9792,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 9804,
		"object": 0,
		"type": "IoCompletion",
		"name": ""
	},
	{
		"id": 9808,
		"object": 0,
		"type": "Key",
		"name": "HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Explorer\\CommandStore"
	},
	{
		"id": 9816,
		"object": 0,
		"type": "Key",
		"name": "HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\PlayToReceiver"
	},
	{
		"id": 9820,
		"object": 0,
		"type": "WaitCompletionPacket",
		"name": ""
	},
	{
		"id": 9828,
		"object": 0,
		"type": "Key",
		"name": "HKEY_LOCAL_MACHINE\\SOFTWARE\\Classes\\CLSID\\{b155bdf8-02f0-451e-9a26-ae317cfd7779}\\Instance"
	},
	{
		"id": 9832,
		"object": 0,
		"type": "IoCompletion",
		"name": ""
	},
	{
		"id": 9864,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 9872,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 9884,
		"object": 0,
		"type": "Thread",
		"name": ""
	},
	{
		"id": 9888,
		"object": 0,
		"type": "Key",
		"name": "HKEY_LOCAL_MACHINE\\SOFTWARE\\Classes\\CLSID\\{B4BFCC3A-DB2C-424C-B029-7FE99A87C641}\\Instance"
	},
	{
		"id": 9896,
		"object": 0,
		"type": "Token",
		"name": ""
	},
	{
		"id": 9904,
		"object": 0,
		"type": "ALPC Port",
		"name": "",
		"meta": {
			"Flags": 34144256,
			"Seqno": 23,
			"Context": 9904
		}
	},
	{
		"id": 9908,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 9916,
		"object": 0,
		"type": "Mutant",
		"name": "",
		"meta": {
			"Count": 1,
			"IsAbandoned": false
		}
	},
	{
		"id": 9920,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 9924,
		"object": 0,
		"type": "Thread",
		"name": ""
	},
	{
		"id": 9932,
		"object": 0,
		"type": "Key",
		"name": "HKEY_CURRENT_USER\\Classes\\PackagedCom"
	},
	{
		"id": 9936,
		"object": 0,
		"type": "Key",
		"name": "HKEY_CURRENT_USER\\Classes\\PackagedCom\\Package"
	},
	{
		"id": 9944,
		"object": 0,
		"type": "Key",
		"name": "HKEY_LOCAL_MACHINE\\SOFTWARE\\Classes\\PackagedCom\\Package"
	},
	{
		"id": 9952,
		"object": 0,
		"type": "IoCompletionReserve",
		"name": ""
	},
	{
		"id": 9964,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 9972,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 9976,
		"object": 0,
		"type": "IoCompletion",
		"name": ""
	},
	{
		"id": 9980,
		"object": 0,
		"type": "Thread",
		"name": ""
	},
	{
		"id": 9984,
		"object": 0,
		"type": "ALPC Port",
		"name": "",
		"meta": {
			"Flags": 34078720,
			"Seqno": 183,
			"Context": 327866752
		}
	},
	{
		"id": 9988,
		"object": 0,
		"type": "WaitCompletionPacket",
		"name": ""
	},
	{
		"id": 9992,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 9996,
		"object": 0,
		"type": "WaitCompletionPacket",
		"name": ""
	},
	{
		"id": 10000,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 10004,
		"object": 0,
		"type": "Event",
		"name": "\\BaseNamedObjects\\StateRepository.PrimaryTileUserNotificationChannel.{F0DE26AA-90D1-4928-BBDF-41F137A7B6B3}"
	},
	{
		"id": 10008,
		"object": 0,
		"type": "Token",
		"name": ""
	},
	{
		"id": 10044,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 10048,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 10056,
		"object": 0,
		"type": "Key",
		"name": "HKEY_LOCAL_MACHINE\\SOFTWARE\\Classes\\CLSID\\{B4BFCC3A-DB2C-424C-B029-7FE99A87C641}\\Instance"
	},
	{
		"id": 10060,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 10068,
		"object": 0,
		"type": "Key",
		"name": "HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Explorer\\CommandStore\\shell\\Windows.newfolder"
	},
	{
		"id": 10072,
		"object": 0,
		"type": "WaitCompletionPacket",
		"name": ""
	},
	{
		"id": 10080,
		"object": 0,
		"type": "Thread",
		"name": ""
	},
	{
		"id": 10092,
		"object": 0,
		"type": "Mutant",
		"name": "",
		"meta": {
			"Count": 1,
			"IsAbandoned": false
		}
	},
	{
		"id": 10108,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 10112,
		"object": 0,
		"type": "Thread",
		"name": ""
	},
	{
		"id": 10116,
		"object": 0,
		"type": "Process",
		"name": "C:\\Users\\bunny\\AppData\\Roaming\\Spotify\\Spotify.exe"
	},
	{
		"id": 10124,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 10128,
		"object": 0,
		"type": "Section",
		"name": "\\Sessions\\1\\BaseNamedObjects\\245cHWNDInterface:4040c"
	},
	{
		"id": 10132,
		"object": 0,
		"type": "Thread",
		"name": ""
	},
	{
		"id": 10136,
		"object": 0,
		"type": "Thread",
		"name": ""
	},
	{
		"id": 10164,
		"object": 0,
		"type": "Timer",
		"name": ""
	},
	{
		"id": 10168,
		"object": 0,
		"type": "Process",
		"name": "C:\\Users\\bunny\\AppData\\Roaming\\Spotify\\Spotify.exe"
	},
	{
		"id": 10172,
		"object": 0,
		"type": "ALPC Port",
		"name": "",
		"meta": {
			"Flags": 34078720,
			"Seqno": 195,
			"Context": 327867424
		}
	},
	{
		"id": 10180,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 10188,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 10192,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 10208,
		"object": 0,
		"type": "Key",
		"name": "HKEY_CURRENT_USER\\Software\\Microsoft\\Windows\\CurrentVersion\\CloudStore\\Store\\Cache\\DefaultAccount\\$de${6ca1ca25-d1e2-4563-945a-eb5b802393e7}$$windows.data.unifiedtile.localstarttilepropertiesmap\\Current"
	},
	{
		"id": 10212,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 10220,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 10224,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 10228,
		"object": 0,
		"type": "Key",
		"name": "HKEY_CURRENT_USER\\Software\\Microsoft\\Windows\\CurrentVersion\\CloudStore\\Store\\Cache\\DefaultAccount\\$de${6ca1ca25-d1e2-4563-945a-eb5b802393e7}$$windows.data.unifiedtile.localstartvolatiletilepropertiesmap\\Current"
	},
	{
		"id": 10232,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 10244,
		"object": 0,
		"type": "Thread",
		"name": ""
	},
	{
		"id": 10248,
		"object": 0,
		"type": "ALPC Port",
		"name": "",
		"meta": {
			"Flags": 458752,
			"Seqno": 12,
			"Context": 10248
		}
	},
	{
		"id": 10252,
		"object": 0,
		"type": "ALPC Port",
		"name": "",
		"meta": {
			"Flags": 458752,
			"Seqno": 12,
			"Context": 10252
		}
	},
	{
		"id": 10256,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 10260,
		"object": 0,
		"type": "Timer",
		"name": ""
	},
	{
		"id": 10264,
		"object": 0,
		"type": "Timer",
		"name": ""
	},
	{
		"id": 10268,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 10272,
		"object": 0,
		"type": "WaitCompletionPacket",
		"name": ""
	},
	{
		"id": 10276,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 10280,
		"object": 0,
		"type": "WaitCompletionPacket",
		"name": ""
	},
	{
		"id": 10284,
		"object": 0,
		"type": "WaitCompletionPacket",
		"name": ""
	},
	{
		"id": 10288,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 10292,
		"object": 0,
		"type": "WaitCompletionPacket",
		"name": ""
	},
	{
		"id": 10296,
		"object": 0,
		"type": "Thread",
		"name": ""
	},
	{
		"id": 10300,
		"object": 0,
		"type": "WaitCompletionPacket",
		"name": ""
	},
	{
		"id": 10304,
		"object": 0,
		"type": "Timer",
		"name": ""
	},
	{
		"id": 10308,
		"object": 0,
		"type": "Timer",
		"name": ""
	},
	{
		"id": 10312,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 10316,
		"object": 0,
		"type": "WaitCompletionPacket",
		"name": ""
	},
	{
		"id": 10320,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 10324,
		"object": 0,
		"type": "WaitCompletionPacket",
		"name": ""
	},
	{
		"id": 10328,
		"object": 0,
		"type": "WaitCompletionPacket",
		"name": ""
	},
	{
		"id": 10332,
		"object": 0,
		"type": "WaitCompletionPacket",
		"name": ""
	},
	{
		"id": 10336,
		"object": 0,
		"type": "Thread",
		"name": ""
	},
	{
		"id": 10340,
		"object": 0,
		"type": "WaitCompletionPacket",
		"name": ""
	},
	{
		"id": 10344,
		"object": 0,
		"type": "IoCompletionReserve",
		"name": ""
	},
	{
		"id": 10348,
		"object": 0,
		"type": "IoCompletionReserve",
		"name": ""
	},
	{
		"id": 10352,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 10356,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 10360,
		"object": 0,
		"type": "Mutant",
		"name": "",
		"meta": {
			"Count": 1,
			"IsAbandoned": false
		}
	},
	{
		"id": 10364,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 10368,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 10372,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 10376,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 10380,
		"object": 0,
		"type": "Event",
		"name": "\\Sessions\\1\\BaseNamedObjects\\HasAnimations.9308.12724"
	},
	{
		"id": 10384,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 10388,
		"object": 0,
		"type": "Thread",
		"name": ""
	},
	{
		"id": 10392,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 10396,
		"object": 0,
		"type": "Mutant",
		"name": "",
		"meta": {
			"Count": 1,
			"IsAbandoned": false
		}
	},
	{
		"id": 10400,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 10404,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 10408,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 10412,
		"object": 0,
		"type": "Thread",
		"name": ""
	},
	{
		"id": 10416,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 10420,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 10424,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 10428,
		"object": 0,
		"type": "ALPC Port",
		"name": "",
		"meta": {
			"Flags": 458752,
			"Seqno": 0,
			"Context": 0
		}
	},
	{
		"id": 10432,
		"object": 0,
		"type": "ALPC Port",
		"name": "",
		"meta": {
			"Flags": 458752,
			"Seqno": 0,
			"Context": 0
		}
	},
	{
		"id": 10436,
		"object": 0,
		"type": "WaitCompletionPacket",
		"name": ""
	},
	{
		"id": 10440,
		"object": 0,
		"type": "WaitCompletionPacket",
		"name": ""
	},
	{
		"id": 10448,
		"object": 0,
		"type": "Mutant",
		"name": "",
		"meta": {
			"Count": 1,
			"IsAbandoned": false
		}
	},
	{
		"id": 10460,
		"object": 0,
		"type": "Thread",
		"name": ""
	},
	{
		"id": 10464,
		"object": 0,
		"type": "Event",
		"name": "\\Sessions\\1\\BaseNamedObjects\\AnimationsComplete.9308.12724"
	},
	{
		"id": 10468,
		"object": 0,
		"type": "IoCompletion",
		"name": ""
	},
	{
		"id": 10472,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 10476,
		"object": 0,
		"type": "Mutant",
		"name": "",
		"meta": {
			"Count": 1,
			"IsAbandoned": false
		}
	},
	{
		"id": 10480,
		"object": 0,
		"type": "Mutant",
		"name": "",
		"meta": {
			"Count": 1,
			"IsAbandoned": false
		}
	},
	{
		"id": 10484,
		"object": 0,
		"type": "Mutant",
		"name": "",
		"meta": {
			"Count": 1,
			"IsAbandoned": false
		}
	},
	{
		"id": 10488,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 10492,
		"object": 0,
		"type": "Thread",
		"name": ""
	},
	{
		"id": 10496,
		"object": 0,
		"type": "WaitCompletionPacket",
		"name": ""
	},
	{
		"id": 10500,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 10504,
		"object": 0,
		"type": "Thread",
		"name": ""
	},
	{
		"id": 10508,
		"object": 0,
		"type": "WaitCompletionPacket",
		"name": ""
	},
	{
		"id": 10512,
		"object": 0,
		"type": "WaitCompletionPacket",
		"name": ""
	},
	{
		"id": 10516,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 10520,
		"object": 0,
		"type": "ALPC Port",
		"name": "",
		"meta": {
			"Flags": 720896,
			"Seqno": 5,
			"Context": 10520
		}
	},
	{
		"id": 10524,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 10528,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 10532,
		"object": 0,
		"type": "IoCompletion",
		"name": ""
	},
	{
		"id": 10536,
		"object": 0,
		"type": "Event",
		"name": "\\Sessions\\1\\BaseNamedObjects\\HasDeferredAnimationOperations.9308.12724"
	},
	{
		"id": 10540,
		"object": 0,
		"type": "ALPC Port",
		"name": "",
		"meta": {
			"Flags": 0,
			"Seqno": 1568,
			"Context": 108263392
		}
	},
	{
		"id": 10544,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 10548,
		"object": 0,
		"type": "Mutant",
		"name": "",
		"meta": {
			"Count": 1,
			"IsAbandoned": false
		}
	},
	{
		"id": 10552,
		"object": 0,
		"type": "Thread",
		"name": ""
	},
	{
		"id": 10556,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 10560,
		"object": 0,
		"type": "Thread",
		"name": ""
	},
	{
		"id": 10564,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 10568,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 10572,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 10576,
		"object": 0,
		"type": "Thread",
		"name": ""
	},
	{
		"id": 10580,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 10584,
		"object": 0,
		"type": "ALPC Port",
		"name": "",
		"meta": {
			"Flags": 458752,
			"Seqno": 1,
			"Context": 0
		}
	},
	{
		"id": 10588,
		"object": 0,
		"type": "WaitCompletionPacket",
		"name": ""
	},
	{
		"id": 10592,
		"object": 0,
		"type": "Thread",
		"name": ""
	},
	{
		"id": 10600,
		"object": 0,
		"type": "ALPC Port",
		"name": "",
		"meta": {
			"Flags": 458752,
			"Seqno": 2,
			"Context": 10600
		}
	},
	{
		"id": 10604,
		"object": 0,
		"type": "WaitCompletionPacket",
		"name": ""
	},
	{
		"id": 10608,
		"object": 0,
		"type": "Section",
		"name": ""
	},
	{
		"id": 10612,
		"object": 0,
		"type": "ALPC Port",
		"name": "",
		"meta": {
			"Flags": 458752,
			"Seqno": 1,
			"Context": 0
		}
	},
	{
		"id": 10616,
		"object": 0,
		"type": "WaitCompletionPacket",
		"name": ""
	},
	{
		"id": 10620,
		"object": 0,
		"type": "ALPC Port",
		"name": "",
		"meta": {
			"Flags": 458752,
			"Seqno": 2,
			"Context": 10620
		}
	},
	{
		"id": 10624,
		"object": 0,
		"type": "WaitCompletionPacket",
		"name": ""
	},
	{
		"id": 10628,
		"object": 0,
		"type": "Section",
		"name": "\\Sessions\\1\\BaseNamedObjects\\245cHWNDInterface:201e4"
	},
	{
		"id": 10632,
		"object": 0,
		"type": "Section",
		"name": "\\Sessions\\1\\BaseNamedObjects\\245cHWNDInterface:201e4"
	},
	{
		"id": 10640,
		"object": 0,
		"type": "Section",
		"name": "\\Sessions\\1\\BaseNamedObjects\\245cHWNDInterface:201e6"
	},
	{
		"id": 10644,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 10648,
		"object": 0,
		"type": "IoCompletion",
		"name": ""
	},
	{
		"id": 10652,
		"object": 0,
		"type": "Section",
		"name": "\\Sessions\\1\\BaseNamedObjects\\245cHWNDInterface:201e6"
	},
	{
		"id": 10656,
		"object": 0,
		"type": "Key",
		"name": "HKEY_CURRENT_USER\\Software\\Microsoft\\Windows\\CurrentVersion\\Themes\\Personalize"
	},
	{
		"id": 10660,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 10664,
		"object": 0,
		"type": "WaitCompletionPacket",
		"name": ""
	},
	{
		"id": 10668,
		"object": 0,
		"type": "Key",
		"name": "HKEY_CURRENT_USER\\Control Panel\\Colors"
	},
	{
		"id": 10672,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 10676,
		"object": 0,
		"type": "WaitCompletionPacket",
		"name": ""
	},
	{
		"id": 10680,
		"object": 0,
		"type": "Key",
		"name": "HKEY_CURRENT_USER\\Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\Accent"
	},
	{
		"id": 10684,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 10688,
		"object": 0,
		"type": "WaitCompletionPacket",
		"name": ""
	},
	{
		"id": 10692,
		"object": 0,
		"type": "ALPC Port",
		"name": "",
		"meta": {
			"Flags": 0,
			"Seqno": 1,
			"Context": 64625152
		}
	},
	{
		"id": 10696,
		"object": 0,
		"type": "Thread",
		"name": ""
	},
	{
		"id": 10700,
		"object": 0,
		"type": "Thread",
		"name": ""
	},
	{
		"id": 10704,
		"object": 0,
		"type": "IoCompletion",
		"name": ""
	},
	{
		"id": 10708,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 10712,
		"object": 0,
		"type": "Thread",
		"name": ""
	},
	{
		"id": 10716,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 10720,
		"object": 0,
		"type": "Event",
		"name": "\\Sessions\\1\\BaseNamedObjects\\HasAnimations.9308.12732"
	},
	{
		"id": 10724,
		"object": 0,
		"type": "Event",
		"name": "\\Sessions\\1\\BaseNamedObjects\\AnimationsComplete.9308.12732"
	},
	{
		"id": 10728,
		"object": 0,
		"type": "Event",
		"name": "\\Sessions\\1\\BaseNamedObjects\\HasDeferredAnimationOperations.9308.12732"
	},
	{
		"id": 10732,
		"object": 0,
		"type": "Event",
		"name": "\\Sessions\\1\\BaseNamedObjects\\DeferredAnimationOperationsComplete.9308.12732"
	},
	{
		"id": 10736,
		"object": 0,
		"type": "Event",
		"name": "\\Sessions\\1\\BaseNamedObjects\\RootVisualReset.9308.12732"
	},
	{
		"id": 10740,
		"object": 0,
		"type": "Event",
		"name": "\\Sessions\\1\\BaseNamedObjects\\ImageDecodingIdle.9308.12732"
	},
	{
		"id": 10744,
		"object": 0,
		"type": "Event",
		"name": "\\Sessions\\1\\BaseNamedObjects\\FontDownloadsIdle.9308.12732"
	},
	{
		"id": 10748,
		"object": 0,
		"type": "Event",
		"name": "\\Sessions\\1\\BaseNamedObjects\\PopupMenuCommandInvoked.9308.12732"
	},
	{
		"id": 10752,
		"object": 0,
		"type": "Event",
		"name": "\\Sessions\\1\\BaseNamedObjects\\HasBuildTreeWorks.9308.12732"
	},
	{
		"id": 10756,
		"object": 0,
		"type": "Event",
		"name": "\\Sessions\\1\\BaseNamedObjects\\BuildTreeServiceDrained.9308.12732"
	},
	{
		"id": 10760,
		"object": 0,
		"type": "Event",
		"name": "\\Sessions\\1\\BaseNamedObjects\\KeyboardInputReceived.9308.12732"
	},
	{
		"id": 10764,
		"object": 0,
		"type": "Event",
		"name": "\\Sessions\\1\\BaseNamedObjects\\ImplicitShowHideComplete.9308.12732"
	},
	{
		"id": 10768,
		"object": 0,
		"type": "Event",
		"name": "\\Sessions\\1\\BaseNamedObjects\\HasFacadeAnimations.9308.12732"
	},
	{
		"id": 10772,
		"object": 0,
		"type": "Event",
		"name": "\\Sessions\\1\\BaseNamedObjects\\FacadeAnimationsComplete.9308.12732"
	},
	{
		"id": 10776,
		"object": 0,
		"type": "Event",
		"name": "\\Sessions\\1\\BaseNamedObjects\\AnimatedFacadePropertyChangesComplete.9308.12732"
	},
	{
		"id": 10780,
		"object": 0,
		"type": "Event",
		"name": "\\Sessions\\1\\BaseNamedObjects\\HasBrushTransitions.9308.12732"
	},
	{
		"id": 10784,
		"object": 0,
		"type": "Event",
		"name": "\\Sessions\\1\\BaseNamedObjects\\BrushTransitionsComplete.9308.12732"
	},
	{
		"id": 10788,
		"object": 0,
		"type": "Event",
		"name": "\\Sessions\\1\\BaseNamedObjects\\PageNavigationComplete.9308.12732"
	},
	{
		"id": 10792,
		"object": 0,
		"type": "Event",
		"name": "\\Sessions\\1\\BaseNamedObjects\\DeferredAnimationOperationsComplete.9308.12724"
	},
	{
		"id": 10796,
		"object": 0,
		"type": "Event",
		"name": "\\Sessions\\1\\BaseNamedObjects\\RootVisualReset.9308.12724"
	},
	{
		"id": 10800,
		"object": 0,
		"type": "Event",
		"name": "\\Sessions\\1\\BaseNamedObjects\\ImageDecodingIdle.9308.12724"
	},
	{
		"id": 10804,
		"object": 0,
		"type": "Event",
		"name": "\\Sessions\\1\\BaseNamedObjects\\FontDownloadsIdle.9308.12724"
	},
	{
		"id": 10808,
		"object": 0,
		"type": "Event",
		"name": "\\Sessions\\1\\BaseNamedObjects\\HasBuildTreeWorks.9308.12724"
	},
	{
		"id": 10812,
		"object": 0,
		"type": "Event",
		"name": "\\Sessions\\1\\BaseNamedObjects\\PopupMenuCommandInvoked.9308.12724"
	},
	{
		"id": 10816,
		"object": 0,
		"type": "Event",
		"name": "\\Sessions\\1\\BaseNamedObjects\\BuildTreeServiceDrained.9308.12724"
	},
	{
		"id": 10820,
		"object": 0,
		"type": "Event",
		"name": "\\Sessions\\1\\BaseNamedObjects\\KeyboardInputReceived.9308.12724"
	},
	{
		"id": 10824,
		"object": 0,
		"type": "Event",
		"name": "\\Sessions\\1\\BaseNamedObjects\\ImplicitShowHideComplete.9308.12724"
	},
	{
		"id": 10828,
		"object": 0,
		"type": "Event",
		"name": "\\Sessions\\1\\BaseNamedObjects\\HasFacadeAnimations.9308.12724"
	},
	{
		"id": 10832,
		"object": 0,
		"type": "Event",
		"name": "\\Sessions\\1\\BaseNamedObjects\\FacadeAnimationsComplete.9308.12724"
	},
	{
		"id": 10836,
		"object": 0,
		"type": "Event",
		"name": "\\Sessions\\1\\BaseNamedObjects\\AnimatedFacadePropertyChangesComplete.9308.12724"
	},
	{
		"id": 10840,
		"object": 0,
		"type": "Event",
		"name": "\\Sessions\\1\\BaseNamedObjects\\HasBrushTransitions.9308.12724"
	},
	{
		"id": 10844,
		"object": 0,
		"type": "Event",
		"name": "\\Sessions\\1\\BaseNamedObjects\\BrushTransitionsComplete.9308.12724"
	},
	{
		"id": 10848,
		"object": 0,
		"type": "Event",
		"name": "\\Sessions\\1\\BaseNamedObjects\\PageNavigationComplete.9308.12724"
	},
	{
		"id": 10852,
		"object": 0,
		"type": "Thread",
		"name": ""
	},
	{
		"id": 10856,
		"object": 0,
		"type": "Mutant",
		"name": "",
		"meta": {
			"Count": 1,
			"IsAbandoned": false
		}
	},
	{
		"id": 10860,
		"object": 0,
		"type": "ALPC Port",
		"name": "",
		"meta": {
			"Flags": 0,
			"Seqno": 1,
			"Context": 65347152
		}
	},
	{
		"id": 10864,
		"object": 0,
		"type": "ALPC Port",
		"name": "",
		"meta": {
			"Flags": 458752,
			"Seqno": 452,
			"Context": 0
		}
	},
	{
		"id": 10868,
		"object": 0,
		"type": "ALPC Port",
		"name": "",
		"meta": {
			"Flags": 393216,
			"Seqno": 1,
			"Context": 10868
		}
	},
	{
		"id": 10872,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 10876,
		"object": 0,
		"type": "Mutant",
		"name": "",
		"meta": {
			"Count": 1,
			"IsAbandoned": false
		}
	},
	{
		"id": 10880,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 10896,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 10900,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 10904,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 10912,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 10916,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 10924,
		"object": 0,
		"type": "Thread",
		"name": ""
	},
	{
		"id": 10928,
		"object": 0,
		"type": "ALPC Port",
		"name": "",
		"meta": {
			"Flags": 458752,
			"Seqno": 11,
			"Context": 10928
		}
	},
	{
		"id": 10932,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 10936,
		"object": 0,
		"type": "IoCompletion",
		"name": ""
	},
	{
		"id": 10940,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 10944,
		"object": 0,
		"type": "IoCompletion",
		"name": ""
	},
	{
		"id": 10952,
		"object": 0,
		"type": "ALPC Port",
		"name": "",
		"meta": {
			"Flags": 393216,
			"Seqno": 1,
			"Context": 10952
		}
	},
	{
		"id": 10956,
		"object": 0,
		"type": "Timer",
		"name": ""
	},
	{
		"id": 10960,
		"object": 0,
		"type": "Timer",
		"name": ""
	},
	{
		"id": 10964,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 10968,
		"object": 0,
		"type": "WaitCompletionPacket",
		"name": ""
	},
	{
		"id": 10972,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 10976,
		"object": 0,
		"type": "WaitCompletionPacket",
		"name": ""
	},
	{
		"id": 10980,
		"object": 0,
		"type": "WaitCompletionPacket",
		"name": ""
	},
	{
		"id": 10984,
		"object": 0,
		"type": "WaitCompletionPacket",
		"name": ""
	},
	{
		"id": 10988,
		"object": 0,
		"type": "Thread",
		"name": ""
	},
	{
		"id": 10992,
		"object": 0,
		"type": "WaitCompletionPacket",
		"name": ""
	},
	{
		"id": 10996,
		"object": 0,
		"type": "IoCompletionReserve",
		"name": ""
	},
	{
		"id": 11000,
		"object": 0,
		"type": "Thread",
		"name": ""
	},
	{
		"id": 11004,
		"object": 0,
		"type": "ALPC Port",
		"name": "",
		"meta": {
			"Flags": 458752,
			"Seqno": 627,
			"Context": 0
		}
	},
	{
		"id": 11008,
		"object": 0,
		"type": "WaitCompletionPacket",
		"name": ""
	},
	{
		"id": 11012,
		"object": 0,
		"type": "ALPC Port",
		"name": "",
		"meta": {
			"Flags": 458752,
			"Seqno": 3,
			"Context": 11012
		}
	},
	{
		"id": 11016,
		"object": 0,
		"type": "WaitCompletionPacket",
		"name": ""
	},
	{
		"id": 11024,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 11032,
		"object": 0,
		"type": "Section",
		"name": ""
	},
	{
		"id": 11040,
		"object": 0,
		"type": "ALPC Port",
		"name": "",
		"meta": {
			"Flags": 458752,
			"Seqno": 10,
			"Context": 11040
		}
	},
	{
		"id": 11044,
		"object": 0,
		"type": "Thread",
		"name": ""
	},
	{
		"id": 11048,
		"object": 0,
		"type": "ALPC Port",
		"name": "",
		"meta": {
			"Flags": 0,
			"Seqno": 1930,
			"Context": 133471376
		}
	},
	{
		"id": 11052,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 11056,
		"object": 0,
		"type": "WaitCompletionPacket",
		"name": ""
	},
	{
		"id": 11064,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 11068,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 11072,
		"object": 0,
		"type": "Key",
		"name": "HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Internet Settings\\Zones"
	},
	{
		"id": 11076,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 11080,
		"object": 0,
		"type": "Key",
		"name": "HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Explorer\\CommandStore"
	},
	{
		"id": 11088,
		"object": 0,
		"type": "WaitCompletionPacket",
		"name": ""
	},
	{
		"id": 11092,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 11096,
		"object": 0,
		"type": "DxgkCompositionObject",
		"name": ""
	},
	{
		"id": 11100,
		"object": 0,
		"type": "Thread",
		"name": ""
	},
	{
		"id": 11104,
		"object": 0,
		"type": "DxgkCompositionObject",
		"name": ""
	},
	{
		"id": 11108,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 11112,
		"object": 0,
		"type": "Timer",
		"name": ""
	},
	{
		"id": 11116,
		"object": 0,
		"type": "Event",
		"name": "\\Sessions\\1\\BaseNamedObjects\\{43a2b8d7-6fed-4c18-bd36-b4630d61afb5}"
	},
	{
		"id": 11124,
		"object": 0,
		"type": "Thread",
		"name": ""
	},
	{
		"id": 11128,
		"object": 0,
		"type": "Timer",
		"name": ""
	},
	{
		"id": 11132,
		"object": 0,
		"type": "WaitCompletionPacket",
		"name": ""
	},
	{
		"id": 11136,
		"object": 0,
		"type": "Thread",
		"name": ""
	},
	{
		"id": 11144,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 11148,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 11152,
		"object": 0,
		"type": "WaitCompletionPacket",
		"name": ""
	},
	{
		"id": 11160,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 11168,
		"object": 0,
		"type": "Thread",
		"name": ""
	},
	{
		"id": 11172,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 11180,
		"object": 0,
		"type": "Thread",
		"name": ""
	},
	{
		"id": 11188,
		"object": 0,
		"type": "IoCompletionReserve",
		"name": ""
	},
	{
		"id": 11192,
		"object": 0,
		"type": "DxgkCompositionObject",
		"name": ""
	},
	{
		"id": 11196,
		"object": 0,
		"type": "WaitCompletionPacket",
		"name": ""
	},
	{
		"id": 11200,
		"object": 0,
		"type": "Thread",
		"name": ""
	},
	{
		"id": 11216,
		"object": 0,
		"type": "ALPC Port",
		"name": "",
		"meta": {
			"Flags": 34078720,
			"Seqno": 19,
			"Context": 327872128
		}
	},
	{
		"id": 11220,
		"object": 0,
		"type": "WaitCompletionPacket",
		"name": ""
	},
	{
		"id": 11224,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 11232,
		"object": 0,
		"type": "Mutant",
		"name": "",
		"meta": {
			"Count": 1,
			"IsAbandoned": false
		}
	},
	{
		"id": 11236,
		"object": 0,
		"type": "WaitCompletionPacket",
		"name": ""
	},
	{
		"id": 11240,
		"object": 0,
		"type": "Key",
		"name": "HKEY_CURRENT_USER\\Classes\\Local Settings\\Software\\Microsoft\\Windows\\Shell\\Bags\\AllFolders\\Shell"
	},
	{
		"id": 11244,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 11248,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 11252,
		"object": 0,
		"type": "ALPC Port",
		"name": "",
		"meta": {
			"Flags": 34144256,
			"Seqno": 96,
			"Context": 11252
		}
	},
	{
		"id": 11260,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 11268,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 11272,
		"object": 0,
		"type": "Mutant",
		"name": "",
		"meta": {
			"Count": 1,
			"IsAbandoned": false
		}
	},
	{
		"id": 11280,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 11300,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 11320,
		"object": 0,
		"type": "WaitCompletionPacket",
		"name": ""
	},
	{
		"id": 11324,
		"object": 0,
		"type": "Key",
		"name": "HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Internet Settings\\5.0\\Cache"
	},
	{
		"id": 11332,
		"object": 0,
		"type": "Key",
		"name": "HKEY_USERS"
	},
	{
		"id": 11336,
		"object": 0,
		"type": "ALPC Port",
		"name": "",
		"meta": {
			"Flags": 34144256,
			"Seqno": 7,
			"Context": 11336
		}
	},
	{
		"id": 11340,
		"object": 0,
		"type": "Section",
		"name": "\\Sessions\\1\\BaseNamedObjects\\windows_webcache_counters_{9B6AB5B3-91BC-4097-835C-EA2DEC95E9CC}_S-1-5-21-2271034452-2606270099-984871569-1001"
	},
	{
		"id": 11348,
		"object": 0,
		"type": "ALPC Port",
		"name": "",
		"meta": {
			"Flags": 0,
			"Seqno": 3,
			"Context": 65322496
		}
	},
	{
		"id": 11356,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 11360,
		"object": 0,
		"type": "ALPC Port",
		"name": "",
		"meta": {
			"Flags": 458752,
			"Seqno": 2,
			"Context": 11360
		}
	},
	{
		"id": 11364,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 11368,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 11372,
		"object": 0,
		"type": "Thread",
		"name": ""
	},
	{
		"id": 11376,
		"object": 0,
		"type": "Key",
		"name": "HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Explorer\\CommandStore"
	},
	{
		"id": 11380,
		"object": 0,
		"type": "Mutant",
		"name": "",
		"meta": {
			"Count": 1,
			"IsAbandoned": false
		}
	},
	{
		"id": 11388,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 11392,
		"object": 0,
		"type": "Mutant",
		"name": "",
		"meta": {
			"Count": 1,
			"IsAbandoned": false
		}
	},
	{
		"id": 11396,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 11408,
		"object": 0,
		"type": "Mutant",
		"name": "",
		"meta": {
			"Count": 1,
			"IsAbandoned": false
		}
	},
	{
		"id": 11412,
		"object": 0,
		"type": "Key",
		"name": "HKEY_CURRENT_USER\\Classes\\Local Settings\\Software\\Microsoft\\Windows\\Shell\\Bags\\2\\Shell"
	},
	{
		"id": 11428,
		"object": 0,
		"type": "Key",
		"name": "HKEY_LOCAL_MACHINE\\SOFTWARE\\Classes\\Applications\\taskmgr.exe"
	},
	{
		"id": 11496,
		"object": 0,
		"type": "Key",
		"name": "HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Explorer\\CommandStore"
	},
	{
		"id": 11508,
		"object": 0,
		"type": "Key",
		"name": "HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Explorer\\CommandStore"
	},
	{
		"id": 11512,
		"object": 0,
		"type": "WaitCompletionPacket",
		"name": ""
	},
	{
		"id": 11524,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 11532,
		"object": 0,
		"type": "Key",
		"name": "HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Explorer\\CommandStore\\shell\\Windows.redo"
	},
	{
		"id": 11536,
		"object": 0,
		"type": "ALPC Port",
		"name": "",
		"meta": {
			"Flags": 34144256,
			"Seqno": 7,
			"Context": 11536
		}
	},
	{
		"id": 11540,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 11556,
		"object": 0,
		"type": "IoCompletion",
		"name": ""
	},
	{
		"id": 11576,
		"object": 0,
		"type": "Event",
		"name": "\\BaseNamedObjects\\{8092FD1B-FFD3-4F2A-91D2-232E90AAFAC3}"
	},
	{
		"id": 11588,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 11604,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 11620,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 11624,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 11644,
		"object": 0,
		"type": "Key",
		"name": "HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Explorer\\CommandStore\\shell\\Windows.RibbonDelete"
	},
	{
		"id": 11688,
		"object": 0,
		"type": "Event",
		"name": "\\BaseNamedObjects\\C::Users:bunny:AppData:Local:Microsoft:Windows:Explorer:iconcache_idx.db!rwWriterEvent"
	},
	{
		"id": 11692,
		"object": 0,
		"type": "Mutant",
		"name": "",
		"meta": {
			"Count": 1,
			"IsAbandoned": false
		}
	},
	{
		"id": 11700,
		"object": 0,
		"type": "Thread",
		"name": ""
	},
	{
		"id": 11712,
		"object": 0,
		"type": "Thread",
		"name": ""
	},
	{
		"id": 11720,
		"object": 0,
		"type": "Mutant",
		"name": "",
		"meta": {
			"Count": 1,
			"IsAbandoned": false
		}
	},
	{
		"id": 11728,
		"object": 0,
		"type": "Mutant",
		"name": "",
		"meta": {
			"Count": 1,
			"IsAbandoned": false
		}
	},
	{
		"id": 11732,
		"object": 0,
		"type": "Key",
		"name": "HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Explorer\\CommandStore\\shell\\Windows.help"
	},
	{
		"id": 11736,
		"object": 0,
		"type": "DxgkCompositionObject",
		"name": ""
	},
	{
		"id": 11740,
		"object": 0,
		"type": "DxgkCompositionObject",
		"name": ""
	},
	{
		"id": 11752,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 11764,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 11768,
		"object": 0,
		"type": "Mutant",
		"name": "",
		"meta": {
			"Count": 1,
			"IsAbandoned": false
		}
	},
	{
		"id": 11772,
		"object": 0,
		"type": "Section",
		"name": ""
	},
	{
		"id": 11776,
		"object": 0,
		"type": "IoCompletion",
		"name": ""
	},
	{
		"id": 11780,
		"object": 0,
		"type": "Key",
		"name": "HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Explorer\\CommandStore\\shell\\Windows.rename"
	},
	{
		"id": 11788,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 11792,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 11800,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 11816,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 11824,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 11832,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 11836,
		"object": 0,
		"type": "Section",
		"name": ""
	},
	{
		"id": 11852,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 11868,
		"object": 0,
		"type": "Thread",
		"name": ""
	},
	{
		"id": 11872,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 11876,
		"object": 0,
		"type": "Key",
		"name": "HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Explorer\\CommandStore\\shell\\Windows.redo"
	},
	{
		"id": 11880,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 11884,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 11896,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 11900,
		"object": 0,
		"type": "Thread",
		"name": ""
	},
	{
		"id": 11904,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 11912,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 11916,
		"object": 0,
		"type": "WaitCompletionPacket",
		"name": ""
	},
	{
		"id": 11928,
		"object": 0,
		"type": "Event",
		"name": ""
	},
	{
		"id": 5748,
		"object": 18446616034694817200,
		"type": "File",
		"name": "C:\\Windows\\SystemResources\\stobject.dll.mun",
		"meta": {
			"IsDirectory": false
		}
	},
	{
		"id": 7752,
		"object": 18446616034694946400,
		"type": "File",
		"name": "C:\\Users\\bunny\\AppData\\Local\\Packages\\Microsoft.BingFinance_8wekyb3d8bbwe\\RoamingState",
		"meta": {
			"IsDirectory": true
		}
	},
	{
		"id": 8412,
		"object": 18446616034694995600,
		"type": "File",
		"name": "C:\\Users\\bunny\\AppData\\Local\\Packages\\Microsoft.ZuneVideo_8wekyb3d8bbwe\\RoamingState",
		"meta": {
			"IsDirectory": true
		}
	},
	{
		"id": 7740,
		"object": 18446616034690721664,
		"type": "File",
		"name": "C:\\Users\\bunny\\AppData\\Local\\Packages\\Microsoft.BioEnrollment_cw5n1h2txyewy\\RoamingState",
		"meta": {
			"IsDirectory": true
		}
	},
	{
		"id": 8076,
		"object": 18446616034694973200,
		"type": "File",
		"name": "C:\\Users\\bunny\\AppData\\Local\\Packages\\Microsoft.People_8wekyb3d8bbwe\\RoamingState",
		"meta": {
			"IsDirectory": true
		}
	},
	{
		"id": 3972,
		"object": 18446616034747445808,
		"type": "File",
		"name": "C:\\Windows\\WinSxS\\amd64_microsoft.windows.common-controls_6595b64144ccf1df_6.0.18362.720_none_e6beb5c51314836b",
		"meta": {
			"IsDirectory": true
		}
	},
	{
		"id": 5928,
		"object": 18446616034686617392,
		"type": "File",
		"name": "C:\\Windows\\System32\\en-US\\batmeter.dll.mui",
		"meta": {
			"IsDirectory": false
		}
	},
	{
		"id": 5640,
		"object": 18446616034858273424,
		"type": "File",
		"name": "C:\\Users\\bunny\\AppData\\Roaming\\Microsoft\\Windows\\Network Shortcuts",
		"meta": {
			"IsDirectory": true
		}
	},
	{
		"id": 1828,
		"object": 18446616034686815792,
		"type": "File",
		"name": "C:\\Windows\\WinSxS\\amd64_microsoft.windows.common-controls_6595b64144ccf1df_6.0.18362.720_none_e6beb5c51314836b",
		"meta": {
			"IsDirectory": true
		}
	},
	{
		"id": 10196,
		"object": 18446616034704160752,
		"type": "File",
		"name": "C:\\Windows\\WinSxS\\amd64_microsoft.windows.common-controls_6595b64144ccf1df_6.0.18362.720_none_e6beb5c51314836b",
		"meta": {
			"IsDirectory": true
		}
	},
	{
		"id": 8276,
		"object": 18446616034694983200,
		"type": "File",
		"name": "C:\\Users\\bunny\\AppData\\Local\\Packages\\Microsoft.Windows.SecureAssessmentBrowser_cw5n1h2txyewy\\RoamingState",
		"meta": {
			"IsDirectory": true
		}
	},
	{
		"id": 7800,
		"object": 18446616034694944000,
		"type": "File",
		"name": "C:\\Users\\bunny\\AppData\\Local\\Packages\\Microsoft.AsyncTextService_8wekyb3d8bbwe\\RoamingState",
		"meta": {
			"IsDirectory": true
		}
	},
	{
		"id": 8056,
		"object": 18446616034686563792,
		"type": "File",
		"name": "C:\\Users\\bunny\\AppData\\Local\\Packages\\Microsoft.PPIProjection_cw5n1h2txyewy\\RoamingState",
		"meta": {
			"IsDirectory": true
		}
	},
	{
		"id": 7936,
		"object": 18446616034694961600,
		"type": "File",
		"name": "C:\\Users\\bunny\\AppData\\Local\\Packages\\Microsoft.DesktopAppInstaller_8wekyb3d8bbwe\\RoamingState",
		"meta": {
			"IsDirectory": true
		}
	},
	{
		"id": 11724,
		"object": 18446616034858271824,
		"type": "File",
		"name": "C:\\Users\\bunny\\AppData\\Roaming\\Microsoft\\Internet Explorer\\Quick Launch\\User Pinned",
		"meta": {
			"IsDirectory": true
		}
	},
	{
		"id": 8044,
		"object": 18446616034694951200,
		"type": "File",
		"name": "C:\\Users\\bunny\\AppData\\Local\\Packages\\Microsoft.Wallet_8wekyb3d8bbwe\\RoamingState",
		"meta": {
			"IsDirectory": true
		}
	},
	{
		"id": 5592,
		"object": 18446616034682718736,
		"type": "File",
		"name": "C:\\Windows\\bcastdvr",
		"meta": {
			"IsDirectory": true
		}
	},
	{
		"id": 10948,
		"object": 18446616034858272624,
		"type": "File",
		"name": "C:\\Users\\bunny\\Favorites",
		"meta": {
			"IsDirectory": true
		}
	},
	{
		"id": 5396,
		"object": 18446616034666524016,
		"type": "File",
		"name": "C:\\Users\\bunny\\AppData\\Local\\Microsoft\\GameDVR",
		"meta": {
			"IsDirectory": true
		}
	},
	{
		"id": 11344,
		"object": 18446616034858263824,
		"type": "File",
		"name": "C:\\Users\\bunny\\AppData\\Roaming\\Microsoft\\Windows\\Start Menu",
		"meta": {
			"IsDirectory": true
		}
	},
	{
		"id": 4816,
		"object": 18446616034858284624,
		"type": "File",
		"name": "C:\\Users\\bunny\\AppData\\Local\\Microsoft\\Internet Explorer\\TabRoaming",
		"meta": {
			"IsDirectory": true
		}
	},
	{
		"id": 8260,
		"object": 18446616034694974800,
		"type": "File",
		"name": "C:\\Users\\bunny\\AppData\\Local\\Packages\\Microsoft.Windows.PinningConfirmationDialog_cw5n1h2txyewy\\RoamingState",
		"meta": {
			"IsDirectory": true
		}
	},
	{
		"id": 3144,
		"object": 18446616034858263024,
		"type": "File",
		"name": "C:\\ProgramData\\Microsoft\\Windows\\Start Menu",
		"meta": {
			"IsDirectory": true
		}
	},
	{
		"id": 5800,
		"object": 18446616034690712464,
		"type": "File",
		"name": "C:\\Windows\\SystemResources\\batmeter.dll.mun",
		"meta": {
			"IsDirectory": false
		}
	},
	{
		"id": 8428,
		"object": 18446616034690731264,
		"type": "File",
		"name": "C:\\Users\\bunny\\AppData\\Local\\Packages\\Microsoft.YourPhone_8wekyb3d8bbwe\\RoamingState",
		"meta": {
			"IsDirectory": true
		}
	},
	{
		"id": 10052,
		"object": 18446616034704120752,
		"type": "File",
		"name": "C:\\Windows\\System32\\en-US\\mpr.dll.mui",
		"meta": {
			"IsDirectory": false
		}
	},
	{
		"id": 7708,
		"object": 18446616034694945600,
		"type": "File",
		"name": "C:\\Users\\bunny\\AppData\\Local\\Packages\\E2A4F912-2574-4A75-9BB0-0D023378592B_cw5n1h2txyewy\\RoamingState",
		"meta": {
			"IsDirectory": true
		}
	},
	{
		"id": 7720,
		"object": 18446616034694955200,
		"type": "File",
		"name": "C:\\Users\\bunny\\AppData\\Local\\Packages\\InputApp_cw5n1h2txyewy\\RoamingState",
		"meta": {
			"IsDirectory": true
		}
	},
	{
		"id": 8624,
		"object": 18446616034700692208,
		"type": "File",
		"name": "C:\\Windows\\WinSxS\\amd64_microsoft.windows.common-controls_6595b64144ccf1df_6.0.18362.720_none_e6beb5c51314836b",
		"meta": {
			"IsDirectory": true
		}
	},
	{
		"id": 11528,
		"object": 18446616034858261024,
		"type": "File",
		"name": "C:\\Users\\bunny\\AppData\\Roaming\\Microsoft\\Windows\\Start Menu",
		"meta": {
			"IsDirectory": true
		}
	},
	{
		"id": 8220,
		"object": 18446616034679797136,
		"type": "File",
		"name": "C:\\Users\\bunny\\AppData\\Local\\Packages\\Microsoft.Windows.OOBENetworkCaptivePortal_cw5n1h2txyewy\\RoamingState",
		"meta": {
			"IsDirectory": true
		}
	},
	{
		"id": 8236,
		"object": 18446616034694980400,
		"type": "File",
		"name": "C:\\Users\\bunny\\AppData\\Local\\Packages\\Microsoft.Windows.ParentalControls_cw5n1h2txyewy\\RoamingState",
		"meta": {
			"IsDirectory": true
		}
	},
	{
		"id": 1384,
		"object": 18446616034686750192,
		"type": "File",
		"name": "C:\\Windows\\System32\\en-US\\oleaccrc.dll.mui",
		"meta": {
			"IsDirectory": false
		}
	},
	{
		"id": 8008,
		"object": 18446616034686748192,
		"type": "File",
		"name": "C:\\Users\\bunny\\AppData\\Local\\Packages\\Microsoft.MicrosoftOfficeHub_8wekyb3d8bbwe\\RoamingState",
		"meta": {
			"IsDirectory": true
		}
	},
	{
		"id": 9844,
		"object": 18446616034700855408,
		"type": "File",
		"name": "C:\\Windows\\WinSxS\\amd64_microsoft.windows.common-controls_6595b64144ccf1df_6.0.18362.720_none_e6beb5c51314836b",
		"meta": {
			"IsDirectory": true
		}
	},
	{
		"id": 8284,
		"object": 18446616034686778192,
		"type": "File",
		"name": "C:\\Users\\bunny\\AppData\\Local\\Packages\\Microsoft.Windows.StartMenuExperienceHost_cw5n1h2txyewy\\RoamingState",
		"meta": {
			"IsDirectory": true
		}
	},
	{
		"id": 8584,
		"object": 18446616034700826608,
		"type": "File",
		"name": "C:\\Windows\\WinSxS\\amd64_microsoft.windows.common-controls_6595b64144ccf1df_6.0.18362.720_none_e6beb5c51314836b",
		"meta": {
			"IsDirectory": true
		}
	},
	{
		"id": 7956,
		"object": 18446616034686731392,
		"type": "File",
		"name": "C:\\Users\\bunny\\AppData\\Local\\Packages\\Microsoft.Getstarted_8wekyb3d8bbwe\\RoamingState",
		"meta": {
			"IsDirectory": true
		}
	},
	{
		"id": 8184,
		"object": 18446616034686739792,
		"type": "File",
		"name": "C:\\Users\\bunny\\AppData\\Local\\Packages\\Microsoft.Windows.CloudExperienceHost_cw5n1h2txyewy\\RoamingState",
		"meta": {
			"IsDirectory": true
		}
	},
	{
		"id": 908,
		"object": 18446616034858292624,
		"type": "File",
		"name": "C:\\Users\\bunny\\Desktop",
		"meta": {
			"IsDirectory": true
		}
	},
	{
		"id": 7276,
		"object": 18446616034684668048,
		"type": "File",
		"name": "C:\\Windows\\WinSxS\\amd64_microsoft.windows.common-controls_6595b64144ccf1df_6.0.18362.720_none_e6beb5c51314836b",
		"meta": {
			"IsDirectory": true
		}
	},
	{
		"id": 5816,
		"object": 18446616034679688736,
		"type": "File",
		"name": "C:\\Windows\\WinSxS\\amd64_microsoft.windows.common-controls_6595b64144ccf1df_6.0.18362.720_none_e6beb5c51314836b",
		"meta": {
			"IsDirectory": true
		}
	},
	{
		"id": 8292,
		"object": 18446616034694989200,
		"type": "File",
		"name": "C:\\Users\\bunny\\AppData\\Local\\Packages\\Microsoft.Windows.ShellExperienceHost_cw5n1h2txyewy\\RoamingState",
		"meta": {
			"IsDirectory": true
		}
	},
	{
		"id": 7328,
		"object": 18446616034663462288,
		"type": "File",
		"name": "C:\\Windows\\System32\\en-US\\bthprops.cpl.mui",
		"meta": {
			"IsDirectory": false
		}
	},
	{
		"id": 5052,
		"object": 18446616034690669264,
		"type": "File",
		"name": "C:\\Windows\\SystemResources\\imageres.dll.mun",
		"meta": {
			"IsDirectory": false
		}
	},
	{
		"id": 8104,
		"object": 18446616034686608192,
		"type": "File",
		"name": "C:\\Users\\bunny\\AppData\\Local\\Packages\\Microsoft.ScreenSketch_8wekyb3d8bbwe\\RoamingState",
		"meta": {
			"IsDirectory": true
		}
	},
	{
		"id": 5856,
		"object": 18446616034690708064,
		"type": "File",
		"name": "C:\\Windows\\System32\\en-US\\InputSwitch.dll.mui",
		"meta": {
			"IsDirectory": false
		}
	},
	{
		"id": 72,
		"object": 18446616034686702992,
		"type": "File",
		"name": "C:\\Windows\\System32",
		"meta": {
			"IsDirectory": true
		}
	},
	{
		"id": 4108,
		"object": 18446616034690650864,
		"type": "File",
		"name": "C:\\Windows\\WinSxS\\amd64_microsoft.windows.common-controls_6595b64144ccf1df_6.0.18362.720_none_e6beb5c51314836b",
		"meta": {
			"IsDirectory": true
		}
	},
	{
		"id": 1772,
		"object": 18446616034670756720,
		"type": "File",
		"name": "C:\\Windows\\System32\\en-US\\propsys.dll.mui",
		"meta": {
			"IsDirectory": false
		}
	},
	{
		"id": 3836,
		"object": 18446616034858267024,
		"type": "File",
		"name": "C:\\Users\\bunny\\AppData\\Roaming\\Microsoft\\Windows\\Start Menu\\Programs",
		"meta": {
			"IsDirectory": true
		}
	},
	{
		"id": 8108,
		"object": 18446616034690499264,
		"type": "File",
		"name": "C:\\Users\\bunny\\AppData\\Local\\Packages\\Microsoft.StorePurchaseApp_8wekyb3d8bbwe\\RoamingState",
		"meta": {
			"IsDirectory": true
		}
	},
	{
		"id": 4656,
		"object": 18446616034684636448,
		"type": "File",
		"name": "C:\\Users\\bunny\\AppData\\Local\\Microsoft\\GameDVR\\KnownGameList.bin",
		"meta": {
			"IsDirectory": false
		}
	},
	{
		"id": 7204,
		"object": 18446616034684654848,
		"type": "File",
		"name": "C:\\Windows\\System32\\en-US\\pnidui.dll.mui",
		"meta": {
			"IsDirectory": false
		}
	},
	{
		"id": 8064,
		"object": 18446616034694956800,
		"type": "File",
		"name": "C:\\Users\\bunny\\AppData\\Local\\Packages\\Microsoft.Office.Sway_8wekyb3d8bbwe\\RoamingState",
		"meta": {
			"IsDirectory": true
		}
	},
	{
		"id": 6156,
		"object": 18446616034694941600,
		"type": "File",
		"name": "C:\\Windows\\System32\\en-US\\KernelBase.dll.mui",
		"meta": {
			"IsDirectory": false
		}
	},
	{
		"id": 2816,
		"object": 18446616034690592464,
		"type": "File",
		"name": "C:\\Windows\\System32\\en-US\\windows.storage.dll.mui",
		"meta": {
			"IsDirectory": false
		}
	},
	{
		"id": 10892,
		"object": 18446616034717027104,
		"type": "File",
		"name": "C:\\Windows\\WinSxS\\amd64_microsoft.windows.common-controls_6595b64144ccf1df_6.0.18362.720_none_e6beb5c51314836b",
		"meta": {
			"IsDirectory": true
		}
	},
	{
		"id": 11664,
		"object": 18446616034858280224,
		"type": "File",
		"name": "C:\\Users\\bunny\\AppData\\Local\\Microsoft\\Windows\\Burn",
		"meta": {
			"IsDirectory": true
		}
	},
	{
		"id": 7948,
		"object": 18446616034694950400,
		"type": "File",
		"name": "C:\\Users\\bunny\\AppData\\Local\\Packages\\Microsoft.GetHelp_8wekyb3d8bbwe\\RoamingState",
		"meta": {
			"IsDirectory": true
		}
	},
	{
		"id": 2824,
		"object": 18446616034690597264,
		"type": "File",
		"name": "C:\\Windows\\System32\\en-US\\twinui.pcshell.dll.mui",
		"meta": {
			"IsDirectory": false
		}
	},
	{
		"id": 8000,
		"object": 18446616034694964400,
		"type": "File",
		"name": "C:\\Users\\bunny\\AppData\\Local\\Packages\\Microsoft.Microsoft3DViewer_8wekyb3d8bbwe\\RoamingState",
		"meta": {
			"IsDirectory": true
		}
	},
	{
		"id": 8832,
		"object": 18446616034684504448,
		"type": "File",
		"name": "C:\\Windows\\System32\\en-US\\netmsg.dll.mui",
		"meta": {
			"IsDirectory": false
		}
	},
	{
		"id": 7944,
		"object": 18446616034694949600,
		"type": "File",
		"name": "C:\\Users\\bunny\\AppData\\Local\\Packages\\Microsoft.ECApp_8wekyb3d8bbwe\\RoamingState",
		"meta": {
			"IsDirectory": true
		}
	},
	{
		"id": 7132,
		"object": 18446616034694935200,
		"type": "File",
		"name": "C:\\Users\\bunny\\AppData\\Local\\Microsoft\\Windows\\PicturePassword",
		"meta": {
			"IsDirectory": true
		}
	},
	{
		"id": 6148,
		"object": 18446616034690719264,
		"type": "File",
		"name": "C:\\Windows\\WinSxS\\amd64_microsoft.windows.common-controls_6595b64144ccf1df_6.0.18362.720_none_e6beb5c51314836b",
		"meta": {
			"IsDirectory": true
		}
	},
	{
		"id": 8016,
		"object": 18446616034679711936,
		"type": "File",
		"name": "C:\\Users\\bunny\\AppData\\Local\\Packages\\Microsoft.MicrosoftSolitaireCollection_8wekyb3d8bbwe\\RoamingState",
		"meta": {
			"IsDirectory": true
		}
	},
	{
		"id": 7808,
		"object": 18446616034690726864,
		"type": "File",
		"name": "C:\\Users\\bunny\\AppData\\Local\\Packages\\Microsoft.BingSports_8wekyb3d8bbwe\\RoamingState",
		"meta": {
			"IsDirectory": true
		}
	},
	{
		"id": 252,
		"object": 18446616034686714992,
		"type": "File",
		"name": "C:\\Windows\\en-US\\explorer.exe.mui",
		"meta": {
			"IsDirectory": false
		}
	},
	{
		"id": 8084,
		"object": 18446616034686617792,
		"type": "File",
		"name": "C:\\Users\\bunny\\AppData\\Local\\Packages\\Microsoft.Print3D_8wekyb3d8bbwe\\RoamingState",
		"meta": {
			"IsDirectory": true
		}
	},
	{
		"id": 9892,
		"object": 18446616034686714592,
		"type": "File",
		"name": "C:\\Windows\\SystemResources\\imageres.dll.mun",
		"meta": {
			"IsDirectory": false
		}
	},
	{
		"id": 5752,
		"object": 18446616034690689664,
		"type": "File",
		"name": "C:\\Windows\\WinSxS\\amd64_microsoft.windows.common-controls_6595b64144ccf1df_6.0.18362.720_none_e6beb5c51314836b",
		"meta": {
			"IsDirectory": true
		}
	},
	{
		"id": 7788,
		"object": 18446616034694960000,
		"type": "File",
		"name": "C:\\Users\\bunny\\AppData\\Local\\Packages\\Microsoft.MSPaint_8wekyb3d8bbwe\\RoamingState",
		"meta": {
			"IsDirectory": true
		}
	},
	{
		"id": 4748,
		"object": 18446616034747446208,
		"type": "File",
		"name": "C:\\Windows\\System32\\en-US\\hcproviders.dll.mui",
		"meta": {
			"IsDirectory": false
		}
	},
	{
		"id": 3808,
		"object": 18446616034747451808,
		"type": "File",
		"name": "C:\\Windows\\System32\\en-US\\wscui.cpl.mui",
		"meta": {
			"IsDirectory": false
		}
	},
	{
		"id": 5604,
		"object": 18446616034798478992,
		"type": "File",
		"name": "C:\\Windows\\System32\\en-US\\explorerframe.dll.mui",
		"meta": {
			"IsDirectory": false
		}
	},
	{
		"id": 6124,
		"object": 18446616034684658048,
		"type": "File",
		"name": "C:\\Windows\\System32\\en-US\\sndvolsso.dll.mui",
		"meta": {
			"IsDirectory": false
		}
	},
	{
		"id": 8244,
		"object": 18446616034686753792,
		"type": "File",
		"name": "C:\\Users\\bunny\\AppData\\Local\\Packages\\Microsoft.Windows.PeopleExperienceHost_cw5n1h2txyewy\\RoamingState",
		"meta": {
			"IsDirectory": true
		}
	},
	{
		"id": 1512,
		"object": 18446616034686777392,
		"type": "File",
		"name": "C:\\Windows\\WinSxS\\amd64_microsoft.windows.common-controls_6595b64144ccf1df_6.0.18362.720_none_e6beb5c51314836b",
		"meta": {
			"IsDirectory": true
		}
	},
	{
		"id": 9080,
		"object": 18446616034700847808,
		"type": "File",
		"name": "C:\\Windows\\WinSxS\\amd64_microsoft.windows.gdiplus_6595b64144ccf1df_1.1.18362.720_none_17a9a8aa6da6fd39",
		"meta": {
			"IsDirectory": true
		}
	},
	{
		"id": 8452,
		"object": 18446616034694997600,
		"type": "File",
		"name": "C:\\Users\\bunny\\AppData\\Local\\Packages\\Windows.CBSPreview_cw5n1h2txyewy\\RoamingState",
		"meta": {
			"IsDirectory": true
		}
	},
	{
		"id": 11648,
		"object": 18446616034858266224,
		"type": "File",
		"name": "C:\\Users\\bunny\\AppData\\Roaming\\Microsoft\\Windows\\Start Menu\\Programs",
		"meta": {
			"IsDirectory": true
		}
	},
	{
		"id": 4780,
		"object": 18446616034858269024,
		"type": "File",
		"name": "C:\\Users\\bunny\\AppData\\Roaming\\Microsoft\\Internet Explorer\\Quick Launch\\User Pinned",
		"meta": {
			"IsDirectory": true
		}
	},
	{
		"id": 8096,
		"object": 18446616034686602192,
		"type": "File",
		"name": "C:\\Users\\bunny\\AppData\\Local\\Packages\\Microsoft.SkypeApp_kzf8qxf38zg5c\\RoamingState",
		"meta": {
			"IsDirectory": true
		}
	},
	{
		"id": 8196,
		"object": 18446616034694976400,
		"type": "File",
		"name": "C:\\Users\\bunny\\AppData\\Local\\Packages\\Microsoft.Windows.ContentDeliveryManager_cw5n1h2txyewy\\RoamingState",
		"meta": {
			"IsDirectory": true
		}
	},
	{
		"id": 8164,
		"object": 18446616034690680864,
		"type": "File",
		"name": "C:\\Users\\bunny\\AppData\\Local\\Packages\\Microsoft.Windows.AssignedAccessLockApp_cw5n1h2txyewy\\RoamingState",
		"meta": {
			"IsDirectory": true
		}
	},
	{
		"id": 8328,
		"object": 18446616034642137968,
		"type": "File",
		"name": "C:\\Users\\bunny\\AppData\\Local\\Packages\\Microsoft.WindowsCalculator_8wekyb3d8bbwe\\RoamingState",
		"meta": {
			"IsDirectory": true
		}
	},
	{
		"id": 4452,
		"object": 18446616034747446608,
		"type": "File",
		"name": "C:\\Windows\\System32\\en-US\\ActionCenter.dll.mui",
		"meta": {
			"IsDirectory": false
		}
	},
	{
		"id": 7984,
		"object": 18446616034694965200,
		"type": "File",
		"name": "C:\\Users\\bunny\\AppData\\Local\\Packages\\Microsoft.Messaging_8wekyb3d8bbwe\\RoamingState",
		"meta": {
			"IsDirectory": true
		}
	},
	{
		"id": 8212,
		"object": 18446616034686604592,
		"type": "File",
		"name": "C:\\Users\\bunny\\AppData\\Local\\Packages\\Microsoft.Windows.NarratorQuickStart_8wekyb3d8bbwe\\RoamingState",
		"meta": {
			"IsDirectory": true
		}
	},
	{
		"id": 8180,
		"object": 18446616034679697536,
		"type": "File",
		"name": "C:\\Users\\bunny\\AppData\\Local\\Packages\\Microsoft.Windows.CallingShellApp_cw5n1h2txyewy\\RoamingState",
		"meta": {
			"IsDirectory": true
		}
	},
	{
		"id": 5572,
		"object": 18446616034858291424,
		"type": "File",
		"name": "C:\\Users\\Public\\Desktop",
		"meta": {
			"IsDirectory": true
		}
	},
	{
		"id": 8140,
		"object": 18446616034694972000,
		"type": "File",
		"name": "C:\\Users\\bunny\\AppData\\Local\\Packages\\Microsoft.WebpImageExtension_8wekyb3d8bbwe\\RoamingState",
		"meta": {
			"IsDirectory": true
		}
	},
	{
		"id": 8052,
		"object": 18446616034694958000,
		"type": "File",
		"name": "C:\\Users\\bunny\\AppData\\Local\\Packages\\Microsoft.MixedReality.Portal_8wekyb3d8bbwe\\RoamingState",
		"meta": {
			"IsDirectory": true
		}
	},
	{
		"id": 8316,
		"object": 18446616034694982000,
		"type": "File",
		"name": "C:\\Users\\bunny\\AppData\\Local\\Packages\\Microsoft.WindowsCamera_8wekyb3d8bbwe\\RoamingState",
		"meta": {
			"IsDirectory": true
		}
	},
	{
		"id": 1436,
		"object": 18446616034686761792,
		"type": "File",
		"name": "C:\\Windows\\Fonts\\StaticCache.dat",
		"meta": {
			"IsDirectory": false
		}
	},
	{
		"id": 9852,
		"object": 18446616034700855808,
		"type": "File",
		"name": "C:\\Windows\\System32\\en-US\\acppage.dll.mui",
		"meta": {
			"IsDirectory": false
		}
	},
	{
		"id": 7728,
		"object": 18446616034694954400,
		"type": "File",
		"name": "C:\\Users\\bunny\\AppData\\Local\\Packages\\Microsoft.BingNews_8wekyb3d8bbwe\\RoamingState",
		"meta": {
			"IsDirectory": true
		}
	},
	{
		"id": 7920,
		"object": 18446616034694944800,
		"type": "File",
		"name": "C:\\Users\\bunny\\AppData\\Local\\Packages\\Microsoft.CredDialogHost_cw5n1h2txyewy\\RoamingState",
		"meta": {
			"IsDirectory": true
		}
	},
	{
		"id": 8720,
		"object": 18446616034700827408,
		"type": "File",
		"name": "C:\\Windows\\System32\\en-US\\twext.dll.mui",
		"meta": {
			"IsDirectory": false
		}
	},
	{
		"id": 7780,
		"object": 18446616034694953200,
		"type": "File",
		"name": "C:\\Users\\bunny\\AppData\\Local\\Packages\\Microsoft.AAD.BrokerPlugin_cw5n1h2txyewy\\RoamingState",
		"meta": {
			"IsDirectory": true
		}
	},
	{
		"id": 8408,
		"object": 18446616034694992800,
		"type": "File",
		"name": "C:\\Users\\bunny\\AppData\\Local\\Packages\\Microsoft.ZuneMusic_8wekyb3d8bbwe\\RoamingState",
		"meta": {
			"IsDirectory": true
		}
	},
	{
		"id": 1956,
		"object": 18446616034670771920,
		"type": "File",
		"name": "C:\\Windows\\WinSxS\\amd64_microsoft.windows.common-controls_6595b64144ccf1df_6.0.18362.720_none_e6beb5c51314836b",
		"meta": {
			"IsDirectory": true
		}
	},
	{
		"id": 7392,
		"object": 18446616034747449808,
		"type": "File",
		"name": "C:\\ProgramData\\Microsoft\\Windows\\WER\\ReportArchive",
		"meta": {
			"IsDirectory": true
		}
	},
	{
		"id": 7888,
		"object": 18446616034694968000,
		"type": "File",
		"name": "C:\\Users\\bunny\\AppData\\Local\\Packages\\Microsoft.MicrosoftEdge_8wekyb3d8bbwe\\RoamingState",
		"meta": {
			"IsDirectory": true
		}
	},
	{
		"id": 8416,
		"object": 18446616034694994000,
		"type": "File",
		"name": "C:\\Users\\bunny\\AppData\\Local\\Packages\\Microsoft.XboxGamingOverlay_8wekyb3d8bbwe\\RoamingState",
		"meta": {
			"IsDirectory": true
		}
	},
	{
		"id": 7968,
		"object": 18446616034694964000,
		"type": "File",
		"name": "C:\\Users\\bunny\\AppData\\Local\\Packages\\Microsoft.MicrosoftStickyNotes_8wekyb3d8bbwe\\RoamingState",
		"meta": {
			"IsDirectory": true
		}
	},
	{
		"id": 8432,
		"object": 18446616034694994400,
		"type": "File",
		"name": "C:\\Users\\bunny\\AppData\\Local\\Packages\\Microsoft.XboxIdentityProvider_8wekyb3d8bbwe\\RoamingState",
		"meta": {
			"IsDirectory": true
		}
	},
	{
		"id": 7972,
		"object": 18446616034694965600,
		"type": "File",
		"name": "C:\\Users\\bunny\\AppData\\Local\\Packages\\Microsoft.LockApp_cw5n1h2txyewy\\RoamingState",
		"meta": {
			"IsDirectory": true
		}
	},
	{
		"id": 8128,
		"object": 18446616034683651472,
		"type": "File",
		"name": "C:\\Users\\bunny\\AppData\\Local\\Packages\\Microsoft.TheNorthernLights_8wekyb3d8bbwe\\RoamingState",
		"meta": {
			"IsDirectory": true
		}
	},
	{
		"id": 7928,
		"object": 18446616034679699136,
		"type": "File",
		"name": "C:\\Users\\bunny\\AppData\\Local\\Packages\\Microsoft.LanguageExperiencePackes-ES_8wekyb3d8bbwe\\RoamingState",
		"meta": {
			"IsDirectory": true
		}
	},
	{
		"id": 11276,
		"object": 18446616034858278624,
		"type": "File",
		"name": "C:\\Users\\bunny\\AppData\\Roaming\\Microsoft\\Windows\\Libraries",
		"meta": {
			"IsDirectory": true
		}
	},
	{
		"id": 6388,
		"object": 18446616034858280624,
		"type": "File",
		"name": "C:\\Users\\bunny\\AppData\\Local\\Microsoft\\Windows\\Burn",
		"meta": {
			"IsDirectory": true
		}
	},
	{
		"id": 8268,
		"object": 18446616034694981600,
		"type": "File",
		"name": "C:\\Users\\bunny\\AppData\\Local\\Packages\\Microsoft.Windows.SecHealthUI_cw5n1h2txyewy\\RoamingState",
		"meta": {
			"IsDirectory": true
		}
	},
	{
		"id": 8136,
		"object": 18446616034694972400,
		"type": "File",
		"name": "C:\\Users\\bunny\\AppData\\Local\\Packages\\Microsoft.WebMediaExtensions_8wekyb3d8bbwe\\RoamingState",
		"meta": {
			"IsDirectory": true
		}
	},
	{
		"id": 11256,
		"object": 18446616034747447808,
		"type": "File",
		"name": "C:\\Users\\bunny\\AppData\\Local\\Microsoft\\Windows\\WER\\ERC",
		"meta": {
			"IsDirectory": true
		}
	},
	{
		"id": 9664,
		"object": 18446616034700850208,
		"type": "File",
		"name": "C:\\ProgramData\\AVG\\Antivirus",
		"meta": {
			"IsDirectory": true
		}
	},
	{
		"id": 1676,
		"object": 18446616034858282624,
		"type": "File",
		"name": "C:\\Users\\bunny\\AppData\\Roaming\\Microsoft\\Windows\\Network Shortcuts",
		"meta": {
			"IsDirectory": true
		}
	},
	{
		"id": 8372,
		"object": 18446616034686792992,
		"type": "File",
		"name": "C:\\Users\\bunny\\AppData\\Local\\Packages\\Microsoft.WindowsSoundRecorder_8wekyb3d8bbwe\\RoamingState",
		"meta": {
			"IsDirectory": true
		}
	},
	{
		"id": 9688,
		"object": 18446616034700854608,
		"type": "File",
		"name": "C:\\Program Files\\AVG\\Antivirus\\setup",
		"meta": {
			"IsDirectory": true
		}
	},
	{
		"id": 1784,
		"object": 18446616034670779120,
		"type": "File",
		"name": "\\FileSystem\\Filters\\FltMgrMsg",
		"meta": {
			"IsDirectory": false
		}
	},
	{
		"id": 7964,
		"object": 18446616034690725264,
		"type": "File",
		"name": "C:\\Users\\bunny\\AppData\\Local\\Packages\\Microsoft.HEIFImageExtension_8wekyb3d8bbwe\\RoamingState",
		"meta": {
			"IsDirectory": true
		}
	},
	{
		"id": 5580,
		"object": 18446616034684635248,
		"type": "File",
		"name": "C:\\Program Files\\WindowsApps\\Microsoft.XboxGameOverlay_1.54.4001.0_x64__8wekyb3d8bbwe",
		"meta": {
			"IsDirectory": true
		}
	},
	{
		"id": 5576,
		"object": 18446616034684639248,
		"type": "File",
		"name": "C:\\Program Files\\WindowsApps\\Microsoft.XboxGameOverlay_1.54.4001.0_x64__8wekyb3d8bbwe",
		"meta": {
			"IsDirectory": true
		}
	},
	{
		"id": 3344,
		"object": 18446616034858261824,
		"type": "File",
		"name": "C:\\ProgramData\\Microsoft\\Windows\\Start Menu\\Programs",
		"meta": {
			"IsDirectory": true
		}
	},
	{
		"id": 8068,
		"object": 18446616034694967600,
		"type": "File",
		"name": "C:\\Users\\bunny\\AppData\\Local\\Packages\\Microsoft.OneConnect_8wekyb3d8bbwe\\RoamingState",
		"meta": {
			"IsDirectory": true
		}
	},
	{
		"id": 6036,
		"object": 18446616034690710864,
		"type": "File",
		"name": "C:\\Windows\\SystemResources\\SndVolSSO.dll.mun",
		"meta": {
			"IsDirectory": false
		}
	},
	{
		"id": 8324,
		"object": 18446616034694961200,
		"type": "File",
		"name": "C:\\Users\\bunny\\AppData\\Local\\Packages\\Microsoft.WindowsAlarms_8wekyb3d8bbwe\\RoamingState",
		"meta": {
			"IsDirectory": true
		}
	},
	{
		"id": 11640,
		"object": 18446616034858284224,
		"type": "File",
		"name": "C:\\Users\\bunny\\AppData\\Roaming\\Microsoft\\Windows\\Libraries",
		"meta": {
			"IsDirectory": true
		}
	},
	{
		"id": 7900,
		"object": 18446616034694966000,
		"type": "File",
		"name": "C:\\Users\\bunny\\AppData\\Local\\Packages\\Microsoft.MicrosoftEdgeDevToolsClient_8wekyb3d8bbwe\\RoamingState",
		"meta": {
			"IsDirectory": true
		}
	},
	{
		"id": 8404,
		"object": 18446616034686804592,
		"type": "File",
		"name": "C:\\Users\\bunny\\AppData\\Local\\Packages\\Microsoft.XboxGameOverlay_8wekyb3d8bbwe\\RoamingState",
		"meta": {
			"IsDirectory": true
		}
	},
	{
		"id": 8312,
		"object": 18446616034690718064,
		"type": "File",
		"name": "C:\\Users\\bunny\\AppData\\Local\\Packages\\Microsoft.Windows.XGpuEjectDialog_cw5n1h2txyewy\\RoamingState",
		"meta": {
			"IsDirectory": true
		}
	},
	{
		"id": 8380,
		"object": 18446616034694829600,
		"type": "File",
		"name": "C:\\Users\\bunny\\AppData\\Local\\Packages\\Microsoft.XboxApp_8wekyb3d8bbwe\\RoamingState",
		"meta": {
			"IsDirectory": true
		}
	},
	{
		"id": 8572,
		"object": 18446616034700683008,
		"type": "File",
		"name": "C:\\Windows\\WinSxS\\amd64_microsoft.windows.common-controls_6595b64144ccf1df_6.0.18362.720_none_e6beb5c51314836b",
		"meta": {
			"IsDirectory": true
		}
	},
	{
		"id": 676,
		"object": 18446616034686720192,
		"type": "File",
		"name": "C:\\Windows\\WinSxS\\amd64_microsoft.windows.common-controls_6595b64144ccf1df_6.0.18362.720_none_e6beb5c51314836b",
		"meta": {
			"IsDirectory": true
		}
	},
	{
		"id": 8160,
		"object": 18446616034694976000,
		"type": "File",
		"name": "C:\\Users\\bunny\\AppData\\Local\\Packages\\Microsoft.Windows.Apprep.ChxApp_cw5n1h2txyewy\\RoamingState",
		"meta": {
			"IsDirectory": true
		}
	},
	{
		"id": 5324,
		"object": 18446616034858276624,
		"type": "File",
		"name": "C:\\Users\\bunny\\AppData\\Local\\Microsoft\\Internet Explorer\\TabRoaming",
		"meta": {
			"IsDirectory": true
		}
	},
	{
		"id": 8172,
		"object": 18446616034694971600,
		"type": "File",
		"name": "C:\\Users\\bunny\\AppData\\Local\\Packages\\Microsoft.Windows.CapturePicker_cw5n1h2txyewy\\RoamingState",
		"meta": {
			"IsDirectory": true
		}
	},
	{
		"id": 8456,
		"object": 18446616034694998400,
		"type": "File",
		"name": "C:\\Users\\bunny\\AppData\\Local\\Packages\\Windows.PrintDialog_cw5n1h2txyewy\\RoamingState",
		"meta": {
			"IsDirectory": true
		}
	},
	{
		"id": 9912,
		"object": 18446616034858283424,
		"type": "File",
		"name": "C:\\Users\\Public\\Desktop",
		"meta": {
			"IsDirectory": true
		}
	},
	{
		"id": 10024,
		"object": 18446616034858259824,
		"type": "File",
		"name": "C:\\ProgramData\\Microsoft\\Windows\\Start Menu",
		"meta": {
			"IsDirectory": true
		}
	},
	{
		"id": 7712,
		"object": 18446616034694953600,
		"type": "File",
		"name": "C:\\Users\\bunny\\AppData\\Local\\Packages\\F46D4000-FD22-4DB4-AC8E-4E1DDDE828FE_cw5n1h2txyewy\\RoamingState",
		"meta": {
			"IsDirectory": true
		}
	},
	{
		"id": 8348,
		"object": 18446616034690734464,
		"type": "File",
		"name": "C:\\Users\\bunny\\AppData\\Local\\Packages\\microsoft.windowscommunicationsapps_8wekyb3d8bbwe\\RoamingState",
		"meta": {
			"IsDirectory": true
		}
	},
	{
		"id": 11708,
		"object": 18446616034858285824,
		"type": "File",
		"name": "C:\\Users\\bunny\\Desktop",
		"meta": {
			"IsDirectory": true
		}
	},
	{
		"id": 11584,
		"object": 18446616034858281824,
		"type": "File",
		"name": "C:\\Users\\bunny\\AppData\\Roaming\\Microsoft\\Windows\\Printer Shortcuts",
		"meta": {
			"IsDirectory": true
		}
	},
	{
		"id": 6272,
		"object": 18446616034858267424,
		"type": "File",
		"name": "C:\\ProgramData\\Microsoft\\Windows\\Start Menu\\Programs",
		"meta": {
			"IsDirectory": true
		}
	},
	{
		"id": 1680,
		"object": 18446616034736151712,
		"type": "File",
		"name": "C:\\Windows\\System32\\en-US\\user32.dll.mui",
		"meta": {
			"IsDirectory": false
		}
	},
	{
		"id": 1832,
		"object": 18446616034670748720,
		"type": "File",
		"name": "C:\\Windows\\WinSxS\\amd64_microsoft.windows.common-controls_6595b64144ccf1df_6.0.18362.720_none_e6beb5c51314836b",
		"meta": {
			"IsDirectory": true
		}
	},
	{
		"id": 7732,
		"object": 18446616034694948400,
		"type": "File",
		"name": "C:\\Users\\bunny\\AppData\\Local\\Packages\\Microsoft.3DBuilder_8wekyb3d8bbwe\\RoamingState",
		"meta": {
			"IsDirectory": true
		}
	},
	{
		"id": 6904,
		"object": 18446616034694938800,
		"type": "File",
		"name": "C:\\Users\\bunny\\AppData\\Local\\Microsoft\\Vault\\UserProfileRoaming",
		"meta": {
			"IsDirectory": true
		}
	},
	{
		"id": 2428,
		"object": 18446616034690557264,
		"type": "File",
		"name": "C:\\Windows\\WinSxS\\amd64_microsoft.windows.common-controls_6595b64144ccf1df_6.0.18362.720_none_e6beb5c51314836b",
		"meta": {
			"IsDirectory": true
		}
	},
	{
		"id": 7696,
		"object": 18446616034679698336,
		"type": "File",
		"name": "C:\\Users\\bunny\\AppData\\Local\\Packages\\c5e2524a-ea46-4f67-841f-6a9465d9d515_cw5n1h2txyewy\\RoamingState",
		"meta": {
			"IsDirectory": true
		}
	},
	{
		"id": 7428,
		"object": 18446616034686635392,
		"type": "File",
		"name": "C:\\Users\\bunny\\AppData\\Local\\Packages\\1527c705-839a-4832-9118-54d4Bd6a0c89_cw5n1h2txyewy\\RoamingState",
		"meta": {
			"IsDirectory": true
		}
	},
	{
		"id": 8548,
		"object": 18446616034700674208,
		"type": "File",
		"name": "C:\\Windows\\WinSxS\\amd64_microsoft.windows.common-controls_6595b64144ccf1df_6.0.18362.720_none_e6beb5c51314836b",
		"meta": {
			"IsDirectory": true
		}
	},
	{
		"id": 8204,
		"object": 18446616034694978800,
		"type": "File",
		"name": "C:\\Users\\bunny\\AppData\\Local\\Packages\\Microsoft.Windows.Cortana_cw5n1h2txyewy\\RoamingState",
		"meta": {
			"IsDirectory": true
		}
	},
	{
		"id": 7792,
		"object": 18446616034694947600,
		"type": "File",
		"name": "C:\\Users\\bunny\\AppData\\Local\\Packages\\Microsoft.AccountsControl_cw5n1h2txyewy\\RoamingState",
		"meta": {
			"IsDirectory": true
		}
	},
	{
		"id": 8352,
		"object": 18446616034694986000,
		"type": "File",
		"name": "C:\\Users\\bunny\\AppData\\Local\\Packages\\Microsoft.WindowsFeedbackHub_8wekyb3d8bbwe\\RoamingState",
		"meta": {
			"IsDirectory": true
		}
	},
	{
		"id": 3844,
		"object": 18446616034690701264,
		"type": "File",
		"name": "C:\\Windows\\System32\\en-US\\dsreg.dll.mui",
		"meta": {
			"IsDirectory": false
		}
	},
	{
		"id": 6676,
		"object": 18446616034684660848,
		"type": "File",
		"name": "C:\\Windows\\WinSxS\\amd64_microsoft.windows.common-controls_6595b64144ccf1df_6.0.18362.720_none_e6beb5c51314836b",
		"meta": {
			"IsDirectory": true
		}
	},
	{
		"id": 8012,
		"object": 18446616034694962000,
		"type": "File",
		"name": "C:\\Users\\bunny\\AppData\\Local\\Packages\\Microsoft.VP9VideoExtensions_8wekyb3d8bbwe\\RoamingState",
		"meta": {
			"IsDirectory": true
		}
	},
	{
		"id": 8368,
		"object": 18446616034694993600,
		"type": "File",
		"name": "C:\\Users\\bunny\\AppData\\Local\\Packages\\Microsoft.WindowsMaps_8wekyb3d8bbwe\\RoamingState",
		"meta": {
			"IsDirectory": true
		}
	},
	{
		"id": 5564,
		"object": 18446616034684644848,
		"type": "File",
		"name": "C:\\Program Files\\WindowsApps\\Microsoft.XboxGameOverlay_1.54.4001.0_x64__8wekyb3d8bbwe",
		"meta": {
			"IsDirectory": true
		}
	},
	{
		"id": 6468,
		"object": 18446616034858273024,
		"type": "File",
		"name": "C:\\Users\\bunny\\AppData\\Roaming\\Microsoft\\Windows\\Printer Shortcuts",
		"meta": {
			"IsDirectory": true
		}
	},
	{
		"id": 3468,
		"object": 18446616034694941200,
		"type": "File",
		"name": "C:\\Windows\\WinSxS\\amd64_microsoft.windows.common-controls_6595b64144ccf1df_6.0.18362.720_none_e6beb5c51314836b",
		"meta": {
			"IsDirectory": true
		}
	},
	{
		"id": 8336,
		"object": 18446616034694991600,
		"type": "File",
		"name": "C:\\Users\\bunny\\AppData\\Local\\Packages\\Microsoft.WindowsTerminal_8wekyb3d8bbwe\\RoamingState",
		"meta": {
			"IsDirectory": true
		}
	},
	{
		"id": 7884,
		"object": 18446616034690727264,
		"type": "File",
		"name": "C:\\Users\\bunny\\AppData\\Local\\Packages\\Microsoft.BingWeather_8wekyb3d8bbwe\\RoamingState",
		"meta": {
			"IsDirectory": true
		}
	},
	{
		"id": 5588,
		"object": 18446616034684652448,
		"type": "File",
		"name": "C:\\Users\\bunny\\AppData\\Local\\Packages\\Microsoft.XboxGamingOverlay_8wekyb3d8bbwe\\LocalCache",
		"meta": {
			"IsDirectory": true
		}
	},
	{
		"id": 1140,
		"object": 18446616034686748992,
		"type": "File",
		"name": "C:\\Windows\\System32\\en-US\\shell32.dll.mui",
		"meta": {
			"IsDirectory": false
		}
	},
	{
		"id": 8360,
		"object": 18446616034694756400,
		"type": "File",
		"name": "C:\\Users\\bunny\\AppData\\Local\\Packages\\Microsoft.WindowsStore_8wekyb3d8bbwe\\RoamingState",
		"meta": {
			"IsDirectory": true
		}
	},
	{
		"id": 8032,
		"object": 18446616034694974400,
		"type": "File",
		"name": "C:\\Users\\bunny\\AppData\\Local\\Packages\\Microsoft.Win32WebViewHost_cw5n1h2txyewy\\RoamingState",
		"meta": {
			"IsDirectory": true
		}
	},
	{
		"id": 8388,
		"object": 18446616034694991200,
		"type": "File",
		"name": "C:\\Users\\bunny\\AppData\\Local\\Packages\\Microsoft.XboxGameCallableUI_cw5n1h2txyewy\\RoamingState",
		"meta": {
			"IsDirectory": true
		}
	},
	{
		"id": 8252,
		"object": 18446616034694980800,
		"type": "File",
		"name": "C:\\Users\\bunny\\AppData\\Local\\Packages\\Microsoft.Windows.Photos_8wekyb3d8bbwe\\RoamingState",
		"meta": {
			"IsDirectory": true
		}
	},
	{
		"id": 5772,
		"object": 18446616034694830000,
		"type": "File",
		"name": "C:\\Windows\\System32\\en-US\\stobject.dll.mui",
		"meta": {
			"IsDirectory": false
		}
	},
	{
		"id": 10596,
		"object": 18446616034717010304,
		"type": "File",
		"name": "C:\\Windows\\Fonts\\segoeui.ttf",
		"meta": {
			"IsDirectory": false
		}
	},
	{
		"id": 8228,
		"object": 18446616034694978400,
		"type": "File",
		"name": "C:\\Users\\bunny\\AppData\\Local\\Packages\\Microsoft.Windows.OOBENetworkConnectionFlow_cw5n1h2txyewy\\RoamingState",
		"meta": {
			"IsDirectory": true
		}
	},
	{
		"id": 11228,
		"object": 18446616034755486576,
		"type": "File",
		"name": "C:\\Windows\\System32\\en-US\\ApplicationFrame.dll.mui",
		"meta": {
			"IsDirectory": false
		}
	},
	{
		"id": 3252,
		"object": 18446616034858273824,
		"type": "File",
		"name": "C:\\Users\\bunny\\Favorites",
		"meta": {
			"IsDirectory": true
		}
	}
]
```

`pkg/event/batch.go`:

```go
/*
 * Copyright 2019-2020 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package event

// Batch contains a group of events.
type Batch struct {
	Events []*Event
}

// NewBatch produces a new batch from the group of events.
func NewBatch(evts ...*Event) *Batch {
	return &Batch{Events: evts}
}

// Len returns the length of the batch.
func (b *Batch) Len() int64 { return int64(len(b.Events)) }

// MarshalJSON serializes the batch of events to JSON format.
func (b *Batch) MarshalJSON() []byte {
	buf := make([]byte, 0)
	buf = append(buf, '[')
	for i, evt := range b.Events {
		writeMore := true
		if i == len(b.Events)-1 {
			writeMore = false
		}
		buf = append(buf, evt.MarshalJSON()...)
		buf = append(buf, '\n')
		if writeMore {
			buf = append(buf, ',')
		}
	}
	buf = append(buf, ']')
	return buf
}

```

`pkg/event/batch_test.go`:

```go
/*
 * Copyright 2019-2020 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package event

import (
	"encoding/json"
	"github.com/magiconair/properties/assert"
	"github.com/rabbitstack/fibratus/pkg/event/params"
	htypes "github.com/rabbitstack/fibratus/pkg/handle/types"
	pstypes "github.com/rabbitstack/fibratus/pkg/ps/types"
	"github.com/rabbitstack/fibratus/pkg/util/va"
	"github.com/stretchr/testify/require"
	"golang.org/x/sys/windows"
	"testing"
	"time"
)

func TestBatchMarshalJSON(t *testing.T) {
	evt := &Event{
		Type:        CreateFile,
		Tid:         2484,
		PID:         859,
		CPU:         1,
		Seq:         2,
		Name:        "CreateFile",
		Timestamp:   time.Now(),
		Category:    File,
		Host:        "archrabbit",
		Description: "Creates or opens a new file, directory, I/O device, pipe, console",
		Params: Params{
			params.FileObject:    {Name: params.FileObject, Type: params.Uint64, Value: uint64(12456738026482168384)},
			params.FilePath:      {Name: params.FilePath, Type: params.UnicodeString, Value: "\\Device\\HarddiskVolume2\\Windows\\system32\\user32.dll"},
			params.FileType:      {Name: params.FileType, Type: params.AnsiString, Value: "file"},
			params.FileOperation: {Name: params.FileOperation, Type: params.AnsiString, Value: "open"},
			params.BasePrio:      {Name: params.BasePrio, Type: params.Int8, Value: int8(2)},
			params.PagePrio:      {Name: params.PagePrio, Type: params.Uint8, Value: uint8(2)},
		},
		Metadata: map[MetadataKey]any{"foo": "bar", "fooz": "baarz"},
		PS: &pstypes.PS{
			PID:       2436,
			Ppid:      6304,
			Name:      "firefox.exe",
			Exe:       `C:\Program Files\Mozilla Firefox\firefox.exe`,
			Cmdline:   `C:\Program Files\Mozilla Firefox\firefox.exe -contentproc --channel="6304.3.1055809391\1014207667" -childID 1 -isForBrowser -prefsHandle 2584 -prefMapHandle 2580 -prefsLen 70 -prefMapSize 216993 -parentBuildID 20200107212822 -greomni "C:\Program Files\Mozilla Firefox\omni.ja" -appomni "C:\Program Files\Mozilla Firefox\browser\omni.ja" -appdir "C:\Program Files\Mozilla Firefox\browser" - 6304 "\\.\pipe\gecko-crash-server-pipe.6304" 2596 tab`,
			Cwd:       `C:\Program Files\Mozilla Firefox\`,
			SID:       "archrabbit\\SYSTEM",
			Args:      []string{"-contentproc", `--channel=6304.3.1055809391\1014207667`, "-childID", "1", "-isForBrowser", "-prefsHandle", "2584", "-prefMapHandle", "2580", "-prefsLen", "70", "-prefMapSize", "216993", "-parentBuildID"},
			SessionID: 4,
			Envs:      map[string]string{"ProgramData": "C:\\ProgramData", "COMPUTRENAME": "archrabbit"},
			Threads: map[uint32]pstypes.Thread{
				3453: {Tid: 3453, StartAddress: va.Address(140729524944768), IOPrio: 2, PagePrio: 5, KstackBase: va.Address(18446677035730165760), KstackLimit: va.Address(18446677035730137088), UstackLimit: va.Address(86376448), UstackBase: va.Address(86372352)},
				3455: {Tid: 3455, StartAddress: va.Address(140729524944768), IOPrio: 3, PagePrio: 5, KstackBase: va.Address(18446677035730165760), KstackLimit: va.Address(18446677035730137088), UstackLimit: va.Address(86376448), UstackBase: va.Address(86372352)},
			},
			Handles: []htypes.Handle{
				{Num: windows.Handle(0xffffd105e9baaf70),
					Name:   `\REGISTRY\MACHINE\SYSTEM\ControlSet001\Services\Tcpip\Parameters\Interfaces\{b677c565-6ca5-45d3-b618-736b4e09b036}`,
					Type:   "Key",
					Object: 777488883434455544,
					Pid:    uint32(1023),
				},
				{
					Num:  windows.Handle(0xffffd105e9adaf70),
					Name: `\RPC Control\OLEA61B27E13E028C4EA6C286932E80`,
					Type: "ALPC Port",
					Pid:  uint32(1023),
					MD: &htypes.AlpcPortInfo{
						Seqno:   1,
						Context: 0x0,
						Flags:   0x0,
					},
					Object: 457488883434455544,
				},
				{
					Num:  windows.Handle(0xeaffd105e9adaf30),
					Name: `C:\Users\bunny`,
					Type: "File",
					Pid:  uint32(1023),
					MD: &htypes.FileInfo{
						IsDirectory: true,
					},
					Object: 357488883434455544,
				},
			},
		},
	}

	evt1 := &Event{
		Type:        CreateFile,
		Tid:         2484,
		PID:         459,
		CPU:         1,
		Seq:         2,
		Name:        "CreateFile",
		Timestamp:   time.Now(),
		Category:    File,
		Host:        "archrabbit",
		Description: "Creates or opens a new file, directory, I/O device, pipe, console",
		Params: Params{
			params.FileObject:    {Name: params.FileObject, Type: params.Uint64, Value: uint64(12456738026482168384)},
			params.FilePath:      {Name: params.FilePath, Type: params.UnicodeString, Value: "\\Device\\HarddiskVolume2\\Windows\\system32\\user32.dll"},
			params.FileType:      {Name: params.FileType, Type: params.AnsiString, Value: "file"},
			params.FileOperation: {Name: params.FileOperation, Type: params.AnsiString, Value: "open"},
			params.BasePrio:      {Name: params.BasePrio, Type: params.Int8, Value: int8(2)},
			params.PagePrio:      {Name: params.PagePrio, Type: params.Uint8, Value: uint8(2)},
		},
		Metadata: map[MetadataKey]any{"foo": "bar", "fooz": "baarz"},
		PS: &pstypes.PS{
			PID:       2436,
			Ppid:      6304,
			Name:      "firefox.exe",
			Exe:       `C:\Program Files\Mozilla Firefox\firefox.exe`,
			Cmdline:   `C:\Program Files\Mozilla Firefox\firefox.exe -contentproc --channel="6304.3.1055809391\1014207667" -childID 1 -isForBrowser -prefsHandle 2584 -prefMapHandle 2580 -prefsLen 70 -prefMapSize 216993 -parentBuildID 20200107212822 -greomni "C:\Program Files\Mozilla Firefox\omni.ja" -appomni "C:\Program Files\Mozilla Firefox\browser\omni.ja" -appdir "C:\Program Files\Mozilla Firefox\browser" - 6304 "\\.\pipe\gecko-crash-server-pipe.6304" 2596 tab`,
			Cwd:       `C:\Program Files\Mozilla Firefox\`,
			SID:       "archrabbit\\SYSTEM",
			Args:      []string{"-contentproc", `--channel=6304.3.1055809391\1014207667`, "-childID", "1", "-isForBrowser", "-prefsHandle", "2584", "-prefMapHandle", "2580", "-prefsLen", "70", "-prefMapSize", "216993", "-parentBuildID"},
			SessionID: 4,
			Envs:      map[string]string{"ProgramData": "C:\\ProgramData", "COMPUTRENAME": "archrabbit"},
			Threads: map[uint32]pstypes.Thread{
				3453: {Tid: 3453, StartAddress: va.Address(140729524944768), IOPrio: 2, PagePrio: 5, KstackBase: va.Address(18446677035730165760), KstackLimit: va.Address(18446677035730137088), UstackLimit: va.Address(86376448), UstackBase: va.Address(86372352)},
				3455: {Tid: 3455, StartAddress: va.Address(140729524944768), IOPrio: 3, PagePrio: 5, KstackBase: va.Address(18446677035730165760), KstackLimit: va.Address(18446677035730137088), UstackLimit: va.Address(86376448), UstackBase: va.Address(86372352)},
			},
			Handles: []htypes.Handle{
				{Num: windows.Handle(0xffffd105e9baaf70),
					Name:   `\REGISTRY\MACHINE\SYSTEM\ControlSet001\Services\Tcpip\Parameters\Interfaces\{b677c565-6ca5-45d3-b618-736b4e09b036}`,
					Type:   "Key",
					Object: 777488883434455544,
					Pid:    uint32(1023),
				},
				{
					Num:  windows.Handle(0xffffd105e9adaf70),
					Name: `\RPC Control\OLEA61B27E13E028C4EA6C286932E80`,
					Type: "ALPC Port",
					Pid:  uint32(1023),
					MD: &htypes.AlpcPortInfo{
						Seqno:   1,
						Context: 0x0,
						Flags:   0x0,
					},
					Object: 457488883434455544,
				},
				{
					Num:  windows.Handle(0xeaffd105e9adaf30),
					Name: `C:\Users\bunny`,
					Type: "File",
					Pid:  uint32(1023),
					MD: &htypes.FileInfo{
						IsDirectory: true,
					},
					Object: 357488883434455544,
				},
			},
		},
	}

	evt2 := &Event{
		Type:        CreateFile,
		Tid:         2484,
		PID:         829,
		CPU:         1,
		Seq:         2,
		Name:        "CreateFile",
		Timestamp:   time.Now(),
		Category:    File,
		Host:        "archrabbit",
		Description: "Creates or opens a new file, directory, I/O device, pipe, console",
		Params: Params{
			params.FileObject:    {Name: params.FileObject, Type: params.Uint64, Value: uint64(12456738026482168384)},
			params.FilePath:      {Name: params.FilePath, Type: params.UnicodeString, Value: "\\Device\\HarddiskVolume2\\Windows\\system32\\user32.dll"},
			params.FileType:      {Name: params.FileType, Type: params.AnsiString, Value: "file"},
			params.FileOperation: {Name: params.FileOperation, Type: params.AnsiString, Value: "open"},
			params.BasePrio:      {Name: params.BasePrio, Type: params.Int8, Value: int8(2)},
			params.PagePrio:      {Name: params.PagePrio, Type: params.Uint8, Value: uint8(2)},
		},
		Metadata: map[MetadataKey]any{"foo": "bar", "fooz": "baarz"},
		PS: &pstypes.PS{
			PID:       829,
			Ppid:      6304,
			Name:      "firefox.exe",
			Exe:       `C:\Program Files\Mozilla Firefox\firefox.exe`,
			Cmdline:   `C:\Program Files\Mozilla Firefox\firefox.exe -contentproc --channel="6304.3.1055809391\1014207667" -childID 1 -isForBrowser -prefsHandle 2584 -prefMapHandle 2580 -prefsLen 70 -prefMapSize 216993 -parentBuildID 20200107212822 -greomni "C:\Program Files\Mozilla Firefox\omni.ja" -appomni "C:\Program Files\Mozilla Firefox\browser\omni.ja" -appdir "C:\Program Files\Mozilla Firefox\browser" - 6304 "\\.\pipe\gecko-crash-server-pipe.6304" 2596 tab`,
			Cwd:       `C:\Program Files\Mozilla Firefox\`,
			SID:       "archrabbit\\SYSTEM",
			Args:      []string{"-contentproc", `--channel=6304.3.1055809391\1014207667`, "-childID", "1", "-isForBrowser", "-prefsHandle", "2584", "-prefMapHandle", "2580", "-prefsLen", "70", "-prefMapSize", "216993", "-parentBuildID"},
			SessionID: 4,
			Envs:      map[string]string{"ProgramData": "C:\\ProgramData", "COMPUTRENAME": "archrabbit"},
			Threads: map[uint32]pstypes.Thread{
				3453: {Tid: 3453, StartAddress: va.Address(140729524944768), IOPrio: 2, PagePrio: 5, KstackBase: va.Address(18446677035730165760), KstackLimit: va.Address(18446677035730137088), UstackLimit: va.Address(86376448), UstackBase: va.Address(86372352)},
				3455: {Tid: 3455, StartAddress: va.Address(140729524944768), IOPrio: 3, PagePrio: 5, KstackBase: va.Address(18446677035730165760), KstackLimit: va.Address(18446677035730137088), UstackLimit: va.Address(86376448), UstackBase: va.Address(86372352)},
			},
			Handles: []htypes.Handle{
				{Num: windows.Handle(0xffffd105e9baaf70),
					Name:   `\REGISTRY\MACHINE\SYSTEM\ControlSet001\Services\Tcpip\Parameters\Interfaces\{b677c565-6ca5-45d3-b618-736b4e09b036}`,
					Type:   "Key",
					Object: 777488883434455544,
					Pid:    uint32(1023),
				},
				{
					Num:  windows.Handle(0xffffd105e9adaf70),
					Name: `\RPC Control\OLEA61B27E13E028C4EA6C286932E80`,
					Type: "ALPC Port",
					Pid:  uint32(1023),
					MD: &htypes.AlpcPortInfo{
						Seqno:   1,
						Context: 0x0,
						Flags:   0x0,
					},
					Object: 457488883434455544,
				},
				{
					Num:  windows.Handle(0xeaffd105e9adaf30),
					Name: `C:\Users\bunny`,
					Type: "File",
					Pid:  uint32(1023),
					MD: &htypes.FileInfo{
						IsDirectory: true,
					},
					Object: 357488883434455544,
				},
			},
		},
	}

	b := NewBatch(evt, evt1, evt2)
	require.Equal(t, int64(3), b.Len())

	buf := b.MarshalJSON()
	var evts []*Event

	err := json.Unmarshal(buf, &evts)
	require.NoError(t, err)
	require.Len(t, evts, 3)

	assert.Equal(t, uint32(859), evts[0].PID)
	assert.Equal(t, uint32(459), evts[1].PID)
	assert.Equal(t, uint32(829), evts[2].PID)
}

```

`pkg/event/bitset.go`:

```go
/*
 * Copyright 2021-2022 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package event

import (
	"github.com/bits-and-blooms/bitset"
	"github.com/rabbitstack/fibratus/pkg/util/bitmask"
)

// BitSetType defines the bitset type
type BitSetType uint8

const (
	// BitmaskBitSet designates the mask-based event id bitset
	BitmaskBitSet BitSetType = iota + 1
	// TypeBitSet designates the uint16 number space event type bitset
	TypeBitSet
	// CategoryBitSet designates the event category bitset
	CategoryBitSet
)

// BitSets handles the group of category/event type bitsets
// and the bitmask for evaluating event ids bits.
type BitSets struct {
	bitmask *bitmask.Bitmask
	cats    *bitset.BitSet
	types   *bitset.BitSet
}

// SetBit sets the bit dictated by the bitset type.
func (b *BitSets) SetBit(bs BitSetType, typ Type) {
	switch bs {
	case BitmaskBitSet:
		if b.bitmask == nil {
			b.bitmask = bitmask.New()
		}
		b.bitmask.Set(typ.ID())

	case TypeBitSet:
		if b.types == nil {
			b.types = bitset.New(uint(MaxTypeID() + 1))
		}
		b.types.Set(uint(typ.HookID()))

	case CategoryBitSet:
		if b.cats == nil {
			b.cats = bitset.New(MaxCategoryIndex + 1)
		}
		b.cats.Set(uint(typ.Category().Index()))
	}
}

// SetCategoryBit toggles the category bit in the bitset.
func (b *BitSets) SetCategoryBit(c Category) {
	if b.cats == nil {
		b.cats = bitset.New(MaxCategoryIndex + 1)
	}
	b.cats.Set(uint(c.Index()))
}

// IsBitSet checks if any of the populated bitsets
// contain the type, event ID, or category bit.
// This method evaluates first the event type bitset.
// The event type bitset should only be initialized
// if all event types pertain to the same category.
// Otherwise, event id bitset and last category bitset
// are tested for respective bits.
func (b *BitSets) IsBitSet(evt *Event) bool {
	if b.types != nil && b.types.Test(uint(evt.Type.HookID())) {
		return true
	}
	return (b.bitmask != nil && b.bitmask.IsSet(evt.Type.ID())) ||
		(b.cats != nil && b.cats.Test(uint(evt.Category.Index())))
}

// IsInitialized checks if the given bitset type is initialized.
func (b *BitSets) IsInitialized(bs BitSetType) bool {
	switch bs {
	case BitmaskBitSet:
		return b.bitmask != nil
	case TypeBitSet:
		return b.types != nil
	case CategoryBitSet:
		return b.cats != nil
	}
	return false
}

```

`pkg/event/bitset_test.go`:

```go
/*
 * Copyright 2021-2022 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package event

import (
	"github.com/rabbitstack/fibratus/pkg/util/bitmask"
	"testing"

	"github.com/rabbitstack/fibratus/pkg/sys/etw"
	"github.com/stretchr/testify/assert"
)

func TestBitmask(t *testing.T) {
	var tests = []struct {
		typ      Type
		expected bool
	}{
		{TerminateThread, true},
		{TerminateProcess, true},
		{CreateThread, true},
		{CreateFile, false},
		{WriteFile, false},
		{LoadImage, false},
		{MapFileRundown, true},
		{ProcessRundown, true},
	}

	b := bitmask.New()
	for _, typ := range AllWithState() {
		if typ == WriteFile || typ == LoadImage || typ == CreateFile {
			continue
		}
		b.Set(typ.ID())
	}

	for _, tt := range tests {
		t.Run(tt.typ.String(), func(t *testing.T) {
			assert.Equal(t, tt.expected, b.IsSet(tt.typ.ID()))
		})
	}
}

func TestBitSets(t *testing.T) {
	var tests = []struct {
		evt      *Event
		expected bool
	}{
		{&Event{Type: TerminateThread}, true},
		{&Event{Type: TerminateProcess}, true},
		{&Event{Type: CreateThread, Category: Thread}, true},
		{&Event{Type: CreateFile}, false},
		{&Event{Type: WriteFile}, false},
		{&Event{Type: LoadImage}, false},
		{&Event{Type: MapFileRundown}, true},
		{&Event{Type: ProcessRundown}, true},
	}

	var bitsets BitSets

	bitsets.SetBit(BitmaskBitSet, TerminateThread)
	bitsets.SetBit(TypeBitSet, TerminateProcess)
	bitsets.SetBit(CategoryBitSet, CreateThread)
	bitsets.SetBit(TypeBitSet, MapFileRundown)
	bitsets.SetBit(BitmaskBitSet, ProcessRundown)

	for _, tt := range tests {
		t.Run(tt.evt.Type.String(), func(t *testing.T) {
			assert.Equal(t, tt.expected, bitsets.IsBitSet(tt.evt))
		})
	}
}

func BenchmarkBitmask(b *testing.B) {
	b.ReportAllocs()

	bm := bitmask.New()
	bm.Set(TerminateThread.ID())
	bm.Set(CreateThread.ID())
	bm.Set(TerminateProcess.ID())
	bm.Set(CreateFile.ID())

	evt := &etw.EventRecord{Header: etw.EventHeader{ProviderID: ThreadEventGUID, EventDescriptor: etw.EventDescriptor{Opcode: 2}}}

	b.ResetTimer()

	for i := 0; i < b.N; i++ {
		if !bm.IsSet(evt.ID()) {
			panic("mask should be present")
		}
	}
}

func BenchmarkStdlibMap(b *testing.B) {
	b.ReportAllocs()

	evts := make(map[Type]bool)
	evts[TerminateThread] = true
	evts[CreateThread] = true
	evts[TerminateProcess] = true
	evts[CreateFile] = true

	evt := etw.EventRecord{Header: etw.EventHeader{ProviderID: ThreadEventGUID, EventDescriptor: etw.EventDescriptor{Opcode: 2}}}
	etype := NewTypeFromEventRecord(&evt)

	b.ResetTimer()

	for i := 0; i < b.N; i++ {
		if !evts[etype] {
			panic("event should be present")
		}
	}
}

```

`pkg/event/category.go`:

```go
/*
 * Copyright 2019-2020 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package event

import (
	"github.com/rabbitstack/fibratus/pkg/util/hashers"
)

// Category is the type alias for event categories
type Category string

// Subcategory is the type alias for event subcategories
type Subcategory string

const (
	// Registry is the category for registry related events
	Registry Category = "registry"
	// File is the category for file system events
	File Category = "file"
	// Net is the category for network events
	Net Category = "net"
	// Process is the category for process events
	Process Category = "process"
	// Thread is the category for thread events
	Thread Category = "thread"
	// Image is the category for image events
	Image Category = "image"
	// Handle is the category for handle events
	Handle Category = "handle"
	// Driver is the category for driver events
	Driver Category = "driver"
	// Mem is the category for memory events
	Mem Category = "mem"
	// Object the category for object manager events
	Object Category = "object"
	// Threadpool is the category for thread pool events
	Threadpool Category = "threadpool"
	// Other is the category for uncategorized events
	Other Category = "other"
	// Unknown is the category for events that couldn't match any of the previous categories
	Unknown Category = "unknown"
)

const (
	// DNS designates the DNS (Domain Name Service) event subcategory
	DNS Subcategory = "dns"
	// None identifies no subcategory
	None Subcategory = "none"
)

// Hash obtains the hash of the category string.
func (c Category) Hash() uint32 {
	return hashers.FnvUint32([]byte(c))
}

// MaxCategoryIndex designates the maximum category index.
const MaxCategoryIndex = 13

// Index returns a numerical category index.
func (c Category) Index() uint8 {
	switch c {
	case Registry:
		return 1
	case File:
		return 2
	case Net:
		return 3
	case Process:
		return 4
	case Thread:
		return 5
	case Image:
		return 6
	case Handle:
		return 7
	case Driver:
		return 8
	case Mem:
		return 9
	case Object:
		return 10
	case Threadpool:
		return 11
	case Other:
		return 12
	default:
		return MaxCategoryIndex
	}
}

// Categories returns all available categories.
func Categories() []string {
	return []string{
		string(Registry),
		string(File),
		string(Net),
		string(Process),
		string(Thread),
		string(Image),
		string(Handle),
		string(Mem),
		string(Driver),
		string(Other),
		string(Unknown),
		string(Object),
		string(Threadpool),
	}
}

// IsCategoryKnown indicates if the category is known given its name.
func IsCategoryKnown(name string) bool {
	for _, category := range Categories() {
		if category == name {
			return true
		}
	}
	return false
}

```

`pkg/event/doc.go`:

```go
/*
 * Copyright 2019-2020 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

// Package event defines the fundamental data structures that underpin the state of the event pushed from the
// event source.
package event

```

`pkg/event/enum.go`:

```go
/*
 * Copyright 2021-2022 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package event

import (
	"github.com/rabbitstack/fibratus/pkg/util/va"
	"golang.org/x/sys/windows"
)

// ViewSectionTypes describes possible values for process mapped sections.
var ViewSectionTypes = ParamEnum{
	va.SectionData:           "DATA",
	va.SectionImage:          "IMAGE",
	va.SectionImageNoExecute: "IMAGE_NO_EXECUTE",
	va.SectionPagefile:       "PAGEFILE",
	va.SectionPhysical:       "PHYSICAL",
}

// DNSRecordTypes describes DNS record type values.
var DNSRecordTypes = ParamEnum{
	windows.DNS_TYPE_A:       "A",
	windows.DNS_TYPE_NS:      "NS",
	windows.DNS_TYPE_MD:      "MD",
	windows.DNS_TYPE_MF:      "MF",
	windows.DNS_TYPE_CNAME:   "CNAME",
	windows.DNS_TYPE_SOA:     "SOA",
	windows.DNS_TYPE_MB:      "MB",
	windows.DNS_TYPE_MG:      "MG",
	windows.DNS_TYPE_MR:      "MR",
	windows.DNS_TYPE_NULL:    "NULL",
	windows.DNS_TYPE_WKS:     "WKS",
	windows.DNS_TYPE_PTR:     "PTR",
	windows.DNS_TYPE_HINFO:   "HINFO",
	windows.DNS_TYPE_MINFO:   "MINFO",
	windows.DNS_TYPE_MX:      "MX",
	windows.DNS_TYPE_TEXT:    "TEXT",
	windows.DNS_TYPE_RP:      "RP",
	windows.DNS_TYPE_AFSDB:   "AFSDB",
	windows.DNS_TYPE_X25:     "X25",
	windows.DNS_TYPE_ISDN:    "ISDN",
	windows.DNS_TYPE_NSAPPTR: "NSAPPTR",
	windows.DNS_TYPE_SIG:     "SIG",
	windows.DNS_TYPE_KEY:     "KEY",
	windows.DNS_TYPE_PX:      "PX",
	windows.DNS_TYPE_GPOS:    "GPOS",
	windows.DNS_TYPE_AAAA:    "AAAA",
	windows.DNS_TYPE_LOC:     "LOC",
	windows.DNS_TYPE_NXT:     "NXT",
	windows.DNS_TYPE_EID:     "EID",
	windows.DNS_TYPE_NIMLOC:  "NIMLOC",
	windows.DNS_TYPE_SRV:     "SRV",
	windows.DNS_TYPE_ATMA:    "ATMA",
	windows.DNS_TYPE_NAPTR:   "NAPTR",
	windows.DNS_TYPE_KX:      "KX",
	windows.DNS_TYPE_CERT:    "CERT",
	windows.DNS_TYPE_A6:      "A6",
	windows.DNS_TYPE_DNAME:   "DNAME",
	windows.DNS_TYPE_SINK:    "SINK",
	windows.DNS_TYPE_OPT:     "OPT",
	windows.DNS_TYPE_DS:      "DS",
	windows.DNS_TYPE_RRSIG:   "RRSIG",
	windows.DNS_TYPE_NSEC:    "NSEC",
	windows.DNS_TYPE_DNSKEY:  "DNSKEY",
	windows.DNS_TYPE_DHCID:   "DHCID",
	windows.DNS_TYPE_UINFO:   "UINFO",
	windows.DNS_TYPE_UID:     "UID",
	windows.DNS_TYPE_GID:     "GID",
	windows.DNS_TYPE_UNSPEC:  "UNSPEC",
	windows.DNS_TYPE_ADDRS:   "ADDRS",
	windows.DNS_TYPE_TKEY:    "TKEY",
	windows.DNS_TYPE_TSIG:    "TSIG",
	windows.DNS_TYPE_IXFR:    "IXFR",
	windows.DNS_TYPE_AXFR:    "AXFR",
	windows.DNS_TYPE_MAILB:   "MAILB",
	windows.DNS_TYPE_MAILA:   "MAILA",
	windows.DNS_TYPE_ANY:     "ANY",
	windows.DNS_TYPE_WINS:    "WINS",
	windows.DNS_TYPE_WINSR:   "WINSR",
}

// DNSResponseCodes describes DNS response codes.
var DNSResponseCodes = ParamEnum{
	uint32(windows.DNS_ERROR_RCODE_NO_ERROR):        "NOERROR",
	uint32(windows.DNS_ERROR_RCODE_FORMAT_ERROR):    "FORMERR",
	uint32(windows.DNS_ERROR_RCODE_SERVER_FAILURE):  "SERVFAIL",
	uint32(windows.DNS_ERROR_RCODE_NAME_ERROR):      "NXDOMAIN",
	uint32(windows.DNS_ERROR_RCODE_NOT_IMPLEMENTED): "NOTIMP",
	uint32(windows.DNS_ERROR_RCODE_REFUSED):         "REFUSED",
	uint32(windows.DNS_ERROR_RCODE_YXDOMAIN):        "YXDOMAIN",
	uint32(windows.DNS_ERROR_RCODE_YXRRSET):         "YXRRSET",
	uint32(windows.DNS_ERROR_RCODE_NXRRSET):         "NXRRSET",
	uint32(windows.DNS_ERROR_RCODE_NOTAUTH):         "NOTAUTH",
	uint32(windows.DNS_ERROR_RCODE_NOTZONE):         "NOTZONE",
	uint32(windows.DNS_ERROR_RCODE_BADSIG):          "BADSIG",
	uint32(windows.DNS_ERROR_RCODE_BADKEY):          "BADKEY",
	uint32(windows.DNS_ERROR_RCODE_BADTIME):         "BADTIME",
	uint32(windows.DNS_ERROR_INVALID_NAME):          "BADNAME",
	uint32(windows.ERROR_INVALID_PARAMETER):         "INVALID",
	uint32(windows.DNS_INFO_NO_RECORDS):             "NXDOMAIN",
}

const (
	TokenElevationTypeDefault uint32 = iota + 1
	TokenElevationTypeFull
	TokenElevationTypeLimited
)

// PsTokenElevationTypes describes process token elevation types
var PsTokenElevationTypes = ParamEnum{
	TokenElevationTypeDefault: "DEFAULT",
	TokenElevationTypeFull:    "FULL",
	TokenElevationTypeLimited: "LIMITED",
}

```

`pkg/event/event.go`:

```go
/*
 * Copyright 2019-2020 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package event

import (
	"fmt"
	"strings"
	"sync"
	"time"

	"github.com/rabbitstack/fibratus/pkg/callstack"
	capver "github.com/rabbitstack/fibratus/pkg/cap/version"
	"github.com/rabbitstack/fibratus/pkg/event/params"
	pstypes "github.com/rabbitstack/fibratus/pkg/ps/types"
)

// TimestampFormat is the Go valid format for the event timestamp
var TimestampFormat string

// MetadataKey represents the type definition for the metadata keys
type MetadataKey string

// Metadata is a type alias for event metadata. Any tag, i.e. key/value pair could be attached to metadata.
type Metadata map[MetadataKey]any

const (
	// YaraMatchesKey is the tag name for the yara matches JSON representation
	YaraMatchesKey MetadataKey = "yara.matches"
	// RuleNameKey identifies the rule that was triggered by the event
	RuleNameKey MetadataKey = "rule.name"
	// RuleSequenceLink represents the join link values in sequence rules
	RuleSequenceLinks MetadataKey = "rule.seq.links"
	// RuleSequenceOOOKey the presence of this metadata key indicates the
	// event in the partials list arrived out of order and requires reevaluation
	RuleSequenceOOOKey MetadataKey = "rule.seq.ooo"
	// EvasionsKey represents the evasion behaviours detected on the event
	EvasionsKey MetadataKey = "evasions"
)

func (key MetadataKey) String() string { return string(key) }

// String turns event's metadata into string.
func (md Metadata) String() string {
	var sb strings.Builder
	for k, v := range md {
		sb.WriteString(k.String() + ": " + fmt.Sprintf("%v", v) + ", ")
	}
	return strings.TrimSuffix(sb.String(), ", ")
}

// Event encapsulates event's state and provides a set of methods for
// accessing and manipulating event parameters, process state, and other
// metadata. The fields in this structure are organized for cache-optimal
// layout.
type Event struct {
	// Seq is monotonically incremented event sequence.
	Seq uint64 `json:"seq"`
	// Timestamp represents the temporal occurrence of the event.
	Timestamp time.Time `json:"timestamp"`
	// PID is the identifier of the process that generated the event.
	PID uint32 `json:"pid"`
	// Tid is the thread identifier of the thread that generated the event.
	Tid uint32 `json:"tid"`
	// Evasions is the bitmask that stores detected evasion types on this event.
	Evasions uint32 `json:"-"`
	// Type is the internal representation of the event. This field should be
	// ignored by serializers.
	Type Type `json:"-"`
	// CPU designates the processor logical core where the event was originated.
	CPU uint8 `json:"cpu"`
	// WaitEnqueue indicates if this event should temporarily defer pushing to
	// the consumer output queue. This is usually required in event processors
	// to propagate certain events stored in processor's state when the related
	// event arrives.
	WaitEnqueue bool `json:"waitenqueue"`

	// Name is the human friendly name of the event.
	Name string `json:"name"`
	// Category designates the category to which this event pertains.
	Category Category `json:"category"`
	// Description is the short explanation that describes the purpose of the event.
	Description string `json:"description"`
	// Host is the machine name that reported the generated event.
	Host string `json:"host"`
	// Params stores the collection of event parameters.
	Params Params `json:"-"`
	// Metadata represents any tags that are meaningful to this event.
	Metadata Metadata `json:"metadata"`
	// PS represents process' metadata and its allocated resources such as handles, DLLs, etc.
	PS *pstypes.PS `json:"ps,omitempty"`
	// Callstack represents the call stack for the thread that generated the event.
	Callstack callstack.Callstack `json:"callstack"`

	// mmux guards the metadata map
	mmux sync.RWMutex
}

// String returns event's string representation.
func (e *Event) String() string {
	e.mmux.RLock()
	defer e.mmux.RUnlock()
	if e.PS != nil {
		return fmt.Sprintf(`
		Seq: %d
		Pid: %d
		Tid: %d
		Type: %s
		CPU: %d
		Name: %s
		Category: %s
		Description: %s
		Host: %s
		Timestamp: %s
		Params: %s
		Metadata: %s
	    %s
	`,
			e.Seq,
			e.PID,
			e.Tid,
			e.Type,
			e.CPU,
			e.Name,
			e.Category,
			e.Description,
			e.Host,
			e.Timestamp,
			e.Params,
			e.Metadata,
			e.PS,
		)
	}
	return fmt.Sprintf(`
		Seq: %d
		Pid: %d
		Tid: %d
		Type: %s
		CPU: %d
		Name: %s
		Category: %s
		Description: %s
		Host: %s
		Timestamp: %s
		Params: %s
		Metadata: %s
	`,
		e.Seq,
		e.PID,
		e.Tid,
		e.Type,
		e.CPU,
		e.Name,
		e.Category,
		e.Description,
		e.Host,
		e.Timestamp,
		e.Params,
		e.Metadata,
	)
}

// StringShort returns event's string representation
// by removing some irrelevant event/process fields.
func (e *Event) StringShort() string {
	e.mmux.RLock()
	defer e.mmux.RUnlock()
	if e.PS != nil {
		return fmt.Sprintf(`
		Seq: %d
		Pid: %d
		Tid: %d
		Name: %s
		Category: %s
		Host: %s
		Timestamp: %s
		Parameters: %s
    %s
	`,
			e.Seq,
			e.PID,
			e.Tid,
			e.Name,
			e.Category,
			e.Host,
			e.Timestamp,
			e.Params,
			e.PS.StringShort(),
		)
	}
	return fmt.Sprintf(`
		Seq: %d
		Pid: %d
		Tid: %d
		Name: %s
		Category: %s
		Host: %s
		Timestamp: %s
		Parameters: %s
	`,
		e.Seq,
		e.PID,
		e.Tid,
		e.Name,
		e.Category,
		e.Host,
		e.Timestamp,
		e.Params,
	)
}

// Empty return a pristine event instance.
func Empty() *Event {
	return &Event{
		Params:   map[string]*Param{},
		Metadata: make(map[MetadataKey]any),
		PS:       &pstypes.PS{},
	}
}

// NewFromCapture recovers the event instance from the capture byte buffer.
func NewFromCapture(buf []byte, ver capver.Version) (*Event, error) {
	e := &Event{
		Params:   make(Params),
		Metadata: make(map[MetadataKey]any),
	}
	if err := e.UnmarshalRaw(buf, ver); err != nil {
		return nil, err
	}
	return e, nil
}

// AddMeta appends a key/value pair to event's metadata.
func (e *Event) AddMeta(k MetadataKey, v any) {
	e.mmux.Lock()
	defer e.mmux.Unlock()
	if e.Metadata == nil {
		e.Metadata = make(map[MetadataKey]any)
	}
	e.Metadata[k] = v
}

// AddOrAppendMetaSlice puts the provided string into the slice if the key
// doesn't exist or appends the string to the slice.
func (e *Event) AddOrAppendMetaSlice(k MetadataKey, s string) {
	if e.ContainsMeta(k) {
		v := append(e.GetMeta(k).([]string), s)
		e.AddMeta(k, v)
	} else {
		e.AddMeta(k, []string{s})
	}
}

// RemoveMeta removes the event metadata index by given key.
func (e *Event) RemoveMeta(k MetadataKey) {
	e.mmux.Lock()
	defer e.mmux.Unlock()
	if e.Metadata != nil {
		delete(e.Metadata, k)
	}
}

// GetMetaAsString returns the metadata as a string value.
func (e *Event) GetMetaAsString(k MetadataKey) string {
	e.mmux.RLock()
	defer e.mmux.RUnlock()
	if e.Metadata == nil {
		return ""
	}
	if v, ok := e.Metadata[k]; ok {
		if s, ok := v.(string); ok {
			return s
		}
	}
	return ""
}

// GetMeta returns the metadata for the given key.
func (e *Event) GetMeta(k MetadataKey) any {
	e.mmux.RLock()
	defer e.mmux.RUnlock()
	if e.Metadata == nil {
		return ""
	}
	return e.Metadata[k]
}

// ContainsMeta returns true if the metadata contains the specified key.
func (e *Event) ContainsMeta(k MetadataKey) bool {
	e.mmux.RLock()
	defer e.mmux.RUnlock()
	if e.Metadata == nil {
		return false
	}
	return e.Metadata[k] != nil
}

// AddSequenceLink adds a new sequence link to the set.
func (e *Event) AddSequenceLink(link any) {
	if e.ContainsMeta(RuleSequenceLinks) {
		links, ok := e.GetMeta(RuleSequenceLinks).(map[any]struct{})
		if !ok {
			return
		}
		links[link] = struct{}{}
		e.AddMeta(RuleSequenceLinks, links)
	} else {
		e.AddMeta(RuleSequenceLinks, map[any]struct{}{link: {}})
	}
}

// AppendParam adds a new parameter to this event.
func (e *Event) AppendParam(name string, typ params.Type, value params.Value, opts ...ParamOption) {
	e.Params.Append(name, typ, value, opts...)
}

// AppendEnum adds the enum parameter to this event.
func (e *Event) AppendEnum(name string, value uint32, enum ParamEnum) {
	e.AppendParam(name, params.Enum, value, WithEnum(enum))
}

// AppendFlags adds the flags parameter to this event.
func (e *Event) AppendFlags(name string, value uint32, flags ParamFlags) {
	e.AppendParam(name, params.Flags, value, WithFlags(flags))
}

// GetParamAsString returns the specified parameter value as string.
// Parameter values are resolved according to their types. For instance,
// if the parameter type is `Status`, the system error code is converted
// to the error message.
// Returns an empty string if the given parameter name is not found
// in event parameters.
func (e *Event) GetParamAsString(name string) string {
	par, err := e.Params.Get(name)
	if err != nil {
		return ""
	}
	return par.String()
}

// GetFlagsAsSlice returns parameter flags as a slice of bitmask string values.
func (e *Event) GetFlagsAsSlice(name string) []string {
	return strings.Split(e.GetParamAsString(name), "|")
}

// SequenceLink returns the sequence link values from event metadata.
func (e *Event) SequenceLinks() []any {
	e.mmux.RLock()
	defer e.mmux.RUnlock()
	links, ok := e.Metadata[RuleSequenceLinks].(map[any]struct{})
	if !ok {
		return nil
	}
	s := make([]any, 0, len(links))
	for v := range links {
		s = append(s, v)
	}
	return s
}

```

`pkg/event/event_windows.go`:

```go
/*
 * Copyright 2020-2021 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package event

import (
	"encoding/binary"
	"fmt"
	"os"
	"strings"
	"sync"
	"unsafe"

	"github.com/rabbitstack/fibratus/pkg/event/params"
	"github.com/rabbitstack/fibratus/pkg/sys"
	"github.com/rabbitstack/fibratus/pkg/sys/etw"
	"github.com/rabbitstack/fibratus/pkg/util/filetime"
	"github.com/rabbitstack/fibratus/pkg/util/hashers"
	"github.com/rabbitstack/fibratus/pkg/util/hostname"
	"github.com/rabbitstack/fibratus/pkg/util/ntstatus"
	"golang.org/x/sys/windows"
)

var (
	// DropCurrentProc determines if the events generated by the current, i.e. Fibratus process, are dropped
	DropCurrentProc = true
	// currentPid is the current process identifier
	currentPid = uint32(os.Getpid())
	// rundowns stores the hashes of processed rundown events
	rundowns = map[uint64]bool{}
	mu       sync.Mutex
)

// New constructs a fresh event instance with basic fields and parameters
// from the raw ETW event record.
func New(seq uint64, evt *etw.EventRecord) *Event {
	var (
		pid = evt.Header.ProcessID
		tid = evt.Header.ThreadID
		cpu = *(*uint8)(unsafe.Pointer(&evt.BufferContext.ProcessorIndex[0]))
		ts  = filetime.ToEpoch(evt.Header.Timestamp)
		typ = NewTypeFromEventRecord(evt)
	)

	e := &Event{
		Seq:       seq,
		PID:       pid,
		Tid:       tid,
		CPU:       cpu,
		Type:      typ,
		Category:  typ.Category(),
		Name:      typ.String(),
		Params:    make(map[string]*Param),
		Timestamp: ts,
		Host:      hostname.Get(),
	}

	e.produceParams(evt)
	e.adjustPID()

	return e
}

func (e *Event) adjustPID() {
	switch e.Category {
	case Image:
		// sometimes the pid present in event header is invalid
		// but, we can get the valid one from the event parameters
		if e.InvalidPid() {
			e.PID, _ = e.Params.GetPid()
		}
	case File:
		if !e.IsMapViewFile() && !e.IsUnmapViewFile() {
			// take thread id from the event parameters
			e.Tid, _ = e.Params.GetTid()
		}
		switch {
		case e.InvalidPid() && e.Type == MapFileRundown:
			// a valid pid for map rundown events
			// is located in the event parameters
			e.PID = e.Params.MustGetPid()
		case e.InvalidPid():
			// on some Windows versions the value of
			// the PID is invalid in the event header
			access := uint32(windows.THREAD_QUERY_LIMITED_INFORMATION)
			thread, err := windows.OpenThread(access, false, e.Tid)
			if err != nil {
				return
			}
			defer func() {
				_ = windows.CloseHandle(thread)
			}()
			e.PID = sys.GetProcessIdOfThread(thread)
		}
	case Process:
		// process start events may be logged in the context of the parent or child process.
		// As a result, the ProcessId member of EVENT_TRACE_HEADER may not correspond to the
		// process being created, so we extract the process id from the event parameters
		if e.IsCreateProcess() {
			e.PID, _ = e.Params.GetPid()
		}
	case Net:
		if !e.IsDNS() {
			e.PID, _ = e.Params.GetPid()
		}
	case Handle:
		if e.Type == DuplicateHandle {
			e.PID, _ = e.Params.GetUint32(params.TargetProcessID)
			e.Params.Remove(params.TargetProcessID)
		}
	case Thread:
		if e.Type == StackWalk {
			e.PID, _ = e.Params.GetPid()
			e.Tid, _ = e.Params.GetTid()
		}
	}
}

// IsDropped determines if the event should be dropped. The event
// is dropped in under the following circumstances:
//
// 1. The event is dealing with state management, and as long as
// we're not storing them into the capture file, it can be dropped
// 2. Rundowns events are dropped if they haven't been processed already
// 3. If the event is generated by Fibratus process, we can safely ignore it
func (e *Event) IsDropped(capture bool) bool {
	if e.IsState() && !capture {
		return true
	}
	if e.IsRundown() && e.IsRundownProcessed() {
		return true
	}
	return IsCurrentProcDropped(e.PID)
}

// IsCurrentProcDropped determines if the event originated from the
// current process is dropped.
func IsCurrentProcDropped(pid uint32) bool { return DropCurrentProc && pid == currentPid }

// IsNetworkTCP determines whether the event pertains to network TCP events.
func (e *Event) IsNetworkTCP() bool {
	return e.Category == Net && !e.IsNetworkUDP()
}

// IsNetworkUDP determines whether the event pertains to network UDP events.
func (e *Event) IsNetworkUDP() bool {
	return e.Type == RecvUDPv4 || e.Type == RecvUDPv6 || e.Type == SendUDPv4 || e.Type == SendUDPv6
}

// IsDNS determines whether the event is a DNS question/answer.
func (e *Event) IsDNS() bool {
	return e.Type.Subcategory() == DNS
}

// IsRundown determines if this is a rundown events.
func (e *Event) IsRundown() bool {
	return e.Type == ProcessRundown || e.Type == ThreadRundown || e.Type == ImageRundown ||
		e.Type == FileRundown || e.Type == RegKCBRundown
}

// IsSuccess checks if the event contains the status parameter
// and in such case, returns true if the operation completed
// successfully, i.e. the system code is equal to ERROR_SUCCESS.
func (e *Event) IsSuccess() bool {
	if !e.Params.Contains(params.NTStatus) {
		return true
	}
	return e.GetParamAsString(params.NTStatus) == ntstatus.Success
}

// IsRundownProcessed checks if the rundown events was processed
// to discard writing the snapshot state if the process/module is
// already present. This usually happens when we purposely alter
// the tracing session to induce the arrival of rundown events
// by calling into the `etw.SetTraceInformation` Windows API
// function which causes duplicate rundown events.
// For more pointers check `internal/etw/trace.go` and the
// `etw.SetTraceInformation` API function.
func (e *Event) IsRundownProcessed() bool {
	mu.Lock()
	defer mu.Unlock()
	key := e.RundownKey()
	_, isProcessed := rundowns[key]
	if isProcessed {
		return true
	}
	rundowns[key] = true
	return false
}

func (e *Event) IsCreateFile() bool             { return e.Type == CreateFile }
func (e *Event) IsCreateProcess() bool          { return e.Type == CreateProcess }
func (e *Event) IsCreateProcessInternal() bool  { return e.Type == CreateProcessInternal }
func (e *Event) IsCreateThread() bool           { return e.Type == CreateThread }
func (e *Event) IsCloseFile() bool              { return e.Type == CloseFile }
func (e *Event) IsCreateHandle() bool           { return e.Type == CreateHandle }
func (e *Event) IsCloseHandle() bool            { return e.Type == CloseHandle }
func (e *Event) IsDeleteFile() bool             { return e.Type == DeleteFile }
func (e *Event) IsEnumDirectory() bool          { return e.Type == EnumDirectory }
func (e *Event) IsTerminateProcess() bool       { return e.Type == TerminateProcess }
func (e *Event) IsTerminateThread() bool        { return e.Type == TerminateThread }
func (e *Event) IsUnloadImage() bool            { return e.Type == UnloadImage }
func (e *Event) IsLoadImage() bool              { return e.Type == LoadImage }
func (e *Event) IsLoadImageInternal() bool      { return e.Type == LoadImageInternal }
func (e *Event) IsImageRundown() bool           { return e.Type == ImageRundown }
func (e *Event) IsFileOpEnd() bool              { return e.Type == FileOpEnd }
func (e *Event) IsRegSetValue() bool            { return e.Type == RegSetValue }
func (e *Event) IsRegSetValueInternal() bool    { return e.Type == RegSetValueInternal }
func (e *Event) IsRegCreateKey() bool           { return e.Type == RegCreateKey }
func (e *Event) IsProcessRundown() bool         { return e.Type == ProcessRundown }
func (e *Event) IsProcessRundownInternal() bool { return e.Type == ProcessRundownInternal }
func (e *Event) IsVirtualAlloc() bool           { return e.Type == VirtualAlloc }
func (e *Event) IsMapViewFile() bool            { return e.Type == MapViewFile }
func (e *Event) IsUnmapViewFile() bool          { return e.Type == UnmapViewFile }
func (e *Event) IsStackWalk() bool              { return e.Type == StackWalk }
func (e *Event) IsOpenThread() bool             { return e.Type == OpenThread }
func (e *Event) IsOpenProcess() bool            { return e.Type == OpenProcess }

// InvalidPid indicates if the process generating the event is invalid.
func (e *Event) InvalidPid() bool { return e.PID == sys.InvalidProcessID }

// CurrentPid indicates if Fibratus is the process generating the event.
func (e *Event) CurrentPid() bool { return e.PID == currentPid }

// IsSystemPid indicates if the process generating the event is the System process.
func (e *Event) IsSystemPid() bool { return e.PID == 4 }

// IsState indicates if this event is only used for state management.
func (e *Event) IsState() bool { return e.Type.OnlyState() }

// IsCreateDisposition determines if the file disposition leads to creating a new file.
func (e *Event) IsCreateDisposition() bool {
	return e.IsCreateFile() && e.Params.MustGetUint32(params.FileOperation) == windows.FILE_CREATE
}

// IsOpenDisposition determines if the file disposition leads to opening a file object.
func (e *Event) IsOpenDisposition() bool {
	return e.IsCreateFile() && e.Params.MustGetUint32(params.FileOperation) == windows.FILE_OPEN
}

// StackID returns the integer that is used to stich the callstack present in the StackWalk event.
func (e *Event) StackID() uint64 {
	if e.IsCreateProcess() {
		return uint64(e.Params.MustGetPpid() + e.Tid)
	}
	return uint64(e.PID + e.Tid)
}

// StackPID returns the process id as seen the creator
// from the callstack execution perspective. For example,
// the pid associated with CreateProcess events is the
// parent, not the process being created.
func (e *Event) StackPID() uint32 {
	if e.IsCreateProcess() {
		if e.IsSurrogateProcess() {
			return e.Params.MustGetUint32(params.ProcessRealParentID)
		}
		return e.Params.MustGetPpid()
	}
	return e.PID
}

// IsCreateRemoteThread indicates if the remote thread creation occurred.
func (e *Event) IsCreateRemoteThread() bool {
	return e.Type == CreateThread && e.PID != e.Params.MustGetPid()
}

// IsSurrogateProcess indicates if the process creation event parent id
// differs from the real process parent identifier.
func (e *Event) IsSurrogateProcess() bool {
	return e.IsCreateProcess() && e.Params.MustGetUint32(params.ProcessParentID) != e.Params.MustGetUint32(params.ProcessRealParentID)
}

// RundownKey calculates the rundown event hash. The hash is
// used to determine if the rundown event was already processed.
func (e *Event) RundownKey() uint64 {
	switch e.Type {
	case ProcessRundown:
		b := make([]byte, 4)
		pid, _ := e.Params.GetPid()

		binary.LittleEndian.PutUint32(b, pid)

		return hashers.FnvUint64(b)
	case ThreadRundown:
		b := make([]byte, 8)
		pid, _ := e.Params.GetPid()
		tid, _ := e.Params.GetTid()

		binary.LittleEndian.PutUint32(b, pid)
		binary.LittleEndian.PutUint32(b, tid)

		return hashers.FnvUint64(b)
	case ImageRundown:
		pid, _ := e.Params.GetPid()
		mod, _ := e.Params.GetString(params.ImagePath)
		b := make([]byte, 4+len(mod))

		binary.LittleEndian.PutUint32(b, pid)
		b = append(b, mod...)

		return hashers.FnvUint64(b)
	case FileRundown:
		b := make([]byte, 8)
		fileObject, _ := e.Params.GetUint64(params.FileObject)
		binary.LittleEndian.PutUint64(b, fileObject)

		return hashers.FnvUint64(b)
	case MapFileRundown:
		b := make([]byte, 12)
		fileKey, _ := e.Params.GetUint64(params.FileKey)
		binary.LittleEndian.PutUint32(b, e.PID)
		binary.LittleEndian.PutUint64(b, fileKey)

		return hashers.FnvUint64(b)
	case RegKCBRundown:
		key, _ := e.Params.GetString(params.RegPath)
		b := make([]byte, 4+len(key))

		binary.LittleEndian.PutUint32(b, e.PID)
		b = append(b, key...)
		return hashers.FnvUint64(b)
	}
	return 0
}

// PartialKey computes the unique hash of the event
// that can be employed to determine if the event
// from the given process and source has been processed
// in the rule sequences.
func (e *Event) PartialKey() uint64 {
	switch e.Type {
	case WriteFile, ReadFile:
		return e.Params.MustGetUint64(params.FileObject) + uint64(e.PID)
	case MapViewFile, UnmapViewFile:
		return e.Params.MustGetUint64(params.FileViewBase) + uint64(e.PID)
	case CreateFile:
		file, _ := e.Params.GetString(params.FilePath)
		b := make([]byte, 4+len(file))
		binary.LittleEndian.PutUint32(b, e.PID)
		b = append(b, []byte(file)...)
		return hashers.FnvUint64(b)
	case OpenProcess:
		pid := e.Params.MustGetUint32(params.ProcessID)
		access := e.Params.MustGetUint32(params.DesiredAccess)
		return uint64(pid + access + e.PID)
	case OpenThread:
		tid := e.Params.MustGetUint32(params.ThreadID)
		access := e.Params.MustGetUint32(params.DesiredAccess)
		return uint64(tid + access + e.PID)
	case AcceptTCPv4, RecvTCPv4, RecvUDPv4:
		b := make([]byte, 10)
		ip, _ := e.Params.GetIP(params.NetSIP)
		port, _ := e.Params.GetUint16(params.NetSport)
		binary.LittleEndian.PutUint32(b, e.PID)
		binary.LittleEndian.PutUint32(b, binary.BigEndian.Uint32(ip.To4()))
		binary.LittleEndian.PutUint16(b, port)
		return hashers.FnvUint64(b)
	case AcceptTCPv6, RecvTCPv6, RecvUDPv6:
		b := make([]byte, 22)
		ip, _ := e.Params.GetIP(params.NetSIP)
		port, _ := e.Params.GetUint16(params.NetSport)
		binary.LittleEndian.PutUint32(b, e.PID)
		binary.LittleEndian.PutUint64(b, binary.BigEndian.Uint64(ip.To16()[0:8]))
		binary.LittleEndian.PutUint64(b, binary.BigEndian.Uint64(ip.To16()[8:16]))
		binary.LittleEndian.PutUint16(b, port)
		return hashers.FnvUint64(b)
	case ConnectTCPv4, SendTCPv4, SendUDPv4:
		b := make([]byte, 10)
		ip, _ := e.Params.GetIP(params.NetDIP)
		port, _ := e.Params.GetUint16(params.NetDport)
		binary.LittleEndian.PutUint32(b, e.PID)
		binary.LittleEndian.PutUint32(b, binary.BigEndian.Uint32(ip.To4()))
		binary.LittleEndian.PutUint16(b, port)
		return hashers.FnvUint64(b)
	case ConnectTCPv6, SendTCPv6, SendUDPv6:
		b := make([]byte, 22)
		ip, _ := e.Params.GetIP(params.NetDIP)
		port, _ := e.Params.GetUint16(params.NetDport)
		binary.LittleEndian.PutUint32(b, e.PID)
		binary.LittleEndian.PutUint64(b, binary.BigEndian.Uint64(ip.To16()[0:8]))
		binary.LittleEndian.PutUint64(b, binary.BigEndian.Uint64(ip.To16()[8:16]))
		binary.LittleEndian.PutUint16(b, port)
		return hashers.FnvUint64(b)
	case RegOpenKey, RegQueryKey, RegQueryValue,
		RegDeleteKey, RegDeleteValue, RegSetValue,
		RegCloseKey:
		key, _ := e.Params.GetString(params.RegPath)
		b := make([]byte, 4+len(key))
		binary.LittleEndian.PutUint32(b, e.PID)
		b = append(b, key...)
		return hashers.FnvUint64(b)
	case VirtualAlloc, VirtualFree:
		return e.Params.MustGetUint64(params.MemBaseAddress) + uint64(e.PID)
	case DuplicateHandle:
		pid := e.Params.MustGetUint32(params.ProcessID)
		object := e.Params.MustGetUint64(params.HandleObject)
		return object + uint64(pid+e.PID)
	case QueryDNS, ReplyDNS:
		n, _ := e.Params.GetString(params.DNSName)
		b := make([]byte, 4+len(n))
		binary.LittleEndian.PutUint32(b, e.PID)
		b = append(b, n...)
		return hashers.FnvUint64(b)
	}
	return 0
}

// Summary returns a brief summary of this event. Various important substrings
// in the summary text are highlighted by surrounding them inside <code> HTML tags.
func (e *Event) Summary() string {
	switch e.Type {
	case CreateProcess:
		exe := e.Params.MustGetString(params.Exe)
		sid := e.GetParamAsString(params.Username)
		return printSummary(e, fmt.Sprintf("spawned <code>%s</code> process as <code>%s</code> user", exe, sid))
	case TerminateProcess:
		exe := e.Params.MustGetString(params.Exe)
		sid := e.GetParamAsString(params.Username)
		return printSummary(e, fmt.Sprintf("terminated <code>%s</code> process as <code>%s</code> user", exe, sid))
	case OpenProcess:
		access := e.GetParamAsString(params.DesiredAccess)
		exe, _ := e.Params.GetString(params.Exe)
		return printSummary(e, fmt.Sprintf("opened <code>%s</code> process object with <code>%s</code> access right(s)",
			exe, access))
	case CreateThread:
		tid, _ := e.Params.GetTid()
		addr := e.GetParamAsString(params.StartAddress)
		return printSummary(e, fmt.Sprintf("spawned a new thread with <code>%d</code> id at <code>%s</code> address",
			tid, addr))
	case TerminateThread:
		tid, _ := e.Params.GetTid()
		addr := e.GetParamAsString(params.StartAddress)
		return printSummary(e, fmt.Sprintf("terminated a thread with <code>%d</code> id at <code>%s</code> address",
			tid, addr))
	case OpenThread:
		access := e.GetParamAsString(params.DesiredAccess)
		exe, _ := e.Params.GetString(params.Exe)
		return printSummary(e, fmt.Sprintf("opened <code>%s</code> process' thread object with <code>%s</code> access right(s)",
			exe, access))
	case LoadImage:
		filename := e.GetParamAsString(params.FilePath)
		return printSummary(e, fmt.Sprintf("loaded </code>%s</code> module", filename))
	case UnloadImage:
		filename := e.GetParamAsString(params.FilePath)
		return printSummary(e, fmt.Sprintf("unloaded </code>%s</code> module", filename))
	case CreateFile:
		op := e.GetParamAsString(params.FileOperation)
		filename := e.GetParamAsString(params.FilePath)
		return printSummary(e, fmt.Sprintf("%sed a file <code>%s</code>", strings.ToLower(op), filename))
	case ReadFile:
		filename := e.GetParamAsString(params.FilePath)
		size, _ := e.Params.GetUint32(params.FileIoSize)
		return printSummary(e, fmt.Sprintf("read <code>%d</code> bytes from <code>%s</code> file", size, filename))
	case WriteFile:
		filename := e.GetParamAsString(params.FilePath)
		size, _ := e.Params.GetUint32(params.FileIoSize)
		return printSummary(e, fmt.Sprintf("wrote <code>%d</code> bytes to <code>%s</code> file", size, filename))
	case SetFileInformation:
		filename := e.GetParamAsString(params.FilePath)
		class := e.GetParamAsString(params.FileInfoClass)
		return printSummary(e, fmt.Sprintf("set <code>%s</code> information class on <code>%s</code> file", class, filename))
	case DeleteFile:
		filename := e.GetParamAsString(params.FilePath)
		return printSummary(e, fmt.Sprintf("deleted <code>%s</code> file", filename))
	case RenameFile:
		filename := e.GetParamAsString(params.FilePath)
		return printSummary(e, fmt.Sprintf("renamed <code>%s</code> file", filename))
	case CloseFile:
		filename := e.GetParamAsString(params.FilePath)
		return printSummary(e, fmt.Sprintf("closed <code>%s</code> file", filename))
	case EnumDirectory:
		filename := e.GetParamAsString(params.FilePath)
		return printSummary(e, fmt.Sprintf("enumerated <code>%s</code> directory", filename))
	case RegCreateKey:
		key := e.GetParamAsString(params.RegPath)
		return printSummary(e, fmt.Sprintf("created <code>%s</code> key", key))
	case RegOpenKey:
		key := e.GetParamAsString(params.RegPath)
		return printSummary(e, fmt.Sprintf("opened <code>%s</code> key", key))
	case RegDeleteKey:
		key := e.GetParamAsString(params.RegPath)
		return printSummary(e, fmt.Sprintf("deleted <code>%s</code> key", key))
	case RegQueryKey:
		key := e.GetParamAsString(params.RegPath)
		return printSummary(e, fmt.Sprintf("queried <code>%s</code> key", key))
	case RegSetValue:
		key := e.GetParamAsString(params.RegPath)
		val, err := e.Params.GetString(params.RegValue)
		if err != nil {
			return printSummary(e, fmt.Sprintf("set <code>%s</code> value", key))
		}
		return printSummary(e, fmt.Sprintf("set <code>%s</code> payload in <code>%s</code> value", val, key))
	case RegDeleteValue:
		key := e.GetParamAsString(params.RegPath)
		return printSummary(e, fmt.Sprintf("deleted <code>%s</code> value", key))
	case RegQueryValue:
		key := e.GetParamAsString(params.RegPath)
		return printSummary(e, fmt.Sprintf("queried <code>%s</code> value", key))
	case AcceptTCPv4, AcceptTCPv6:
		ip, _ := e.Params.GetIP(params.NetSIP)
		port, _ := e.Params.GetUint16(params.NetSport)
		return printSummary(e, fmt.Sprintf("accepted connection from <code>%v</code> and <code>%d</code> port", ip, port))
	case ConnectTCPv4, ConnectTCPv6:
		ip, _ := e.Params.GetIP(params.NetDIP)
		port, _ := e.Params.GetUint16(params.NetDport)
		return printSummary(e, fmt.Sprintf("connected to <code>%v</code> and <code>%d</code> port", ip, port))
	case SendTCPv4, SendTCPv6, SendUDPv4, SendUDPv6:
		ip, _ := e.Params.GetIP(params.NetDIP)
		port, _ := e.Params.GetUint16(params.NetDport)
		size, _ := e.Params.GetUint32(params.NetSize)
		return printSummary(e, fmt.Sprintf("sent <code>%d</code> bytes to <code>%v</code> and <code>%d</code> port",
			size, ip, port))
	case RecvTCPv4, RecvTCPv6, RecvUDPv4, RecvUDPv6:
		ip, _ := e.Params.GetIP(params.NetSIP)
		port, _ := e.Params.GetUint16(params.NetSport)
		size, _ := e.Params.GetUint32(params.NetSize)
		return printSummary(e, fmt.Sprintf("received <code>%d</code> bytes from <code>%v</code> and <code>%d</code> port",
			size, ip, port))
	case CreateHandle:
		handleType := e.GetParamAsString(params.HandleObjectTypeID)
		handleName := e.GetParamAsString(params.HandleObjectName)
		return printSummary(e, fmt.Sprintf("created <code>%s</code> handle of <code>%s</code> type",
			handleName, handleType))
	case CloseHandle:
		handleType := e.GetParamAsString(params.HandleObjectTypeID)
		handleName := e.GetParamAsString(params.HandleObjectName)
		return printSummary(e, fmt.Sprintf("closed <code>%s</code> handle of <code>%s</code> type",
			handleName, handleType))
	case VirtualAlloc:
		addr := e.GetParamAsString(params.MemBaseAddress)
		return printSummary(e, fmt.Sprintf("allocated memory at <code>%s</code> address", addr))
	case VirtualFree:
		addr := e.GetParamAsString(params.MemBaseAddress)
		return printSummary(e, fmt.Sprintf("released memory at <code>%s</code> address", addr))
	case MapViewFile:
		sec := e.GetParamAsString(params.FileViewSectionType)
		return printSummary(e, fmt.Sprintf("mapped view of <code>%s</code> section", sec))
	case UnmapViewFile:
		sec := e.GetParamAsString(params.FileViewSectionType)
		return printSummary(e, fmt.Sprintf("unmapped view of <code>%s</code> section", sec))
	case DuplicateHandle:
		handleType := e.GetParamAsString(params.HandleObjectTypeID)
		return printSummary(e, fmt.Sprintf("duplicated <code>%s</code> handle", handleType))
	case QueryDNS:
		dnsName := e.GetParamAsString(params.DNSName)
		return printSummary(e, fmt.Sprintf("sent <code>%s</code> DNS query", dnsName))
	case ReplyDNS:
		dnsName := e.GetParamAsString(params.DNSName)
		return printSummary(e, fmt.Sprintf("received DNS response for <code>%s</code> query", dnsName))
	case CreateSymbolicLinkObject:
		src := e.GetParamAsString(params.LinkSource)
		target := e.GetParamAsString(params.LinkTarget)
		return printSummary(e, fmt.Sprintf("created symbolic link from %s to %s", src, target))
	case SubmitThreadpoolWork:
		return printSummary(e, "enqueued the work item to the thread pool")
	case SubmitThreadpoolCallback:
		return printSummary(e, "Submitted the thread pool callback for execution within the work item")
	case SetThreadpoolTimer:
		return printSummary(e, "set thread pool timer object")
	}
	return ""
}

func printSummary(e *Event, text string) string {
	ps := e.PS
	if ps != nil {
		return fmt.Sprintf("<code>%s</code> %s", ps.Name, text)
	}
	return fmt.Sprintf("process with <code>%d</code> id %s", e.PID, text)
}

```

`pkg/event/event_windows_test.go`:

```go
/*
 * Copyright 2019-2020 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package event

import (
	"github.com/rabbitstack/fibratus/pkg/event/params"
	"github.com/rabbitstack/fibratus/pkg/fs"
	pstypes "github.com/rabbitstack/fibratus/pkg/ps/types"
	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/require"
	"testing"
	"time"
)

func TestEventIsNetworkTCP(t *testing.T) {
	e1 := Event{Type: AcceptTCPv4, Category: Net}
	e2 := Event{Type: SendUDPv6, Category: Net}
	assert.True(t, e1.IsNetworkTCP())
	assert.False(t, e2.IsNetworkTCP())
}

func TestEventIsNetworkUDP(t *testing.T) {
	e1 := Event{Type: RecvUDPv4}
	e2 := Event{Type: SendTCPv6}
	assert.True(t, e1.IsNetworkUDP())
	assert.False(t, e2.IsNetworkUDP())
}

func TestEventSummary(t *testing.T) {
	evt := &Event{
		Type:        CreateFile,
		Tid:         2484,
		PID:         859,
		CPU:         1,
		Seq:         2,
		Name:        "CreateFile",
		Timestamp:   time.Now(),
		Category:    File,
		Host:        "archrabbit",
		Description: "Creates or opens a new file, directory, I/O device, pipe, console",
		Params: Params{
			params.FileObject:    {Name: params.FileObject, Type: params.Uint64, Value: uint64(12456738026482168384)},
			params.FilePath:      {Name: params.FilePath, Type: params.UnicodeString, Value: "C:\\Windows\\system32\\user32.dll"},
			params.FileType:      {Name: params.FileType, Type: params.AnsiString, Value: "file"},
			params.FileOperation: {Name: params.FileOperation, Type: params.Enum, Value: uint32(1), Enum: fs.FileCreateDispositions},
		},
		PS: &pstypes.PS{
			PID:  2436,
			Ppid: 6304,
			Parent: &pstypes.PS{
				PID:  2034,
				Name: "explorer.exe",
				Exe:  `C:\Windows\System32\explorer.exe`,
				Cwd:  `C:\Windows\System32`,
				SID:  "admin\\SYSTEM",
				Parent: &pstypes.PS{
					PID:  2345,
					Name: "winlogon.exe",
				},
			},
			Name:      "firefox.exe",
			Exe:       `C:\Program Files\Mozilla Firefox\firefox.exe`,
			Cmdline:   `C:\Program Files\Mozilla Firefox\firefox.exe -contentproc --channel="6304.3.1055809391\1014207667" -childID 1 -isForBrowser -prefsHandle 2584 -prefMapHandle 2580 -prefsLen 70 -prefMapSize 216993 -parentBuildID 20200107212822 -greomni "C:\Program Files\Mozilla Firefox\omni.ja" -appomni "C:\Program Files\Mozilla Firefox\browser\omni.ja" -appdir "C:\Program Files\Mozilla Firefox\browser" - 6304 "\\.\pipe\gecko-crash-server-pipe.6304" 2596 tab`,
			Cwd:       `C:\Program Files\Mozilla Firefox\`,
			SID:       "archrabbit\\SYSTEM",
			Args:      []string{"-contentproc", `--channel=6304.3.1055809391\1014207667`, "-childID", "1", "-isForBrowser", "-prefsHandle", "2584", "-prefMapHandle", "2580", "-prefsLen", "70", "-prefMapSize", "216993", "-parentBuildID"},
			SessionID: 4,
		},
	}

	require.Equal(t, "<code>firefox.exe</code> opened a file <code>C:\\Windows\\system32\\user32.dll</code>", evt.Summary())
	evt.PS = nil
	require.Equal(t, "process with <code>859</code> id opened a file <code>C:\\Windows\\system32\\user32.dll</code>", evt.Summary())
}

func TestPartialKey(t *testing.T) {
	var tests = []struct {
		evt *Event
		key uint64
	}{
		{
			&Event{Type: OpenProcess, PID: 1234, Params: Params{params.ProcessID: {Name: params.ProcessID, Type: params.PID, Value: uint32(1221)}, params.DesiredAccess: {Name: params.DesiredAccess, Type: params.Uint32, Value: uint32(5)}}},
			0x99c,
		},
		{
			&Event{Type: OpenThread, PID: 11234, Params: Params{params.ThreadID: {Name: params.ThreadID, Type: params.TID, Value: uint32(8452)}, params.DesiredAccess: {Name: params.DesiredAccess, Type: params.Uint32, Value: uint32(15)}}},
			0x4cf5,
		},
		{
			&Event{Type: CreateFile, PID: 4321, Params: Params{params.FilePath: {Name: params.FilePath, Type: params.DOSPath, Value: "C:\\Windows\\System32\\kernelbase.dll"}}},
			0x7ec254f31df879ec,
		},
		{
			&Event{Type: CreateFile, PID: 4321, Params: Params{params.FilePath: {Name: params.FilePath, Type: params.DOSPath, Value: "C:\\Windows\\System32\\kernel32.dll"}}},
			0xb6380d9159ccd174,
		},
	}

	for _, tt := range tests {
		t.Run(tt.evt.Type.String(), func(t *testing.T) {
			assert.Equal(t, tt.key, tt.evt.PartialKey())
		})
	}
}

```

`pkg/event/flags.go`:

```go
/*
 * Copyright 2021-2022 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package event

import (
	"github.com/rabbitstack/fibratus/pkg/sys"
	"golang.org/x/sys/windows"
	"strings"
)

// ParamFlag defines the mapping between the flag value and its symbolical name.
type ParamFlag struct {
	Name  string
	Value uint64
}

func (f ParamFlag) eval(v uint64) bool {
	return (v == 0 && f.Value == 0) || (f.Value != 0 && (v&f.Value) == f.Value && v != 0)
}

// ParamFlags represents the type alias for the event parameter flags
type ParamFlags []ParamFlag

// String produces a string with all flags present in the bitmask and delimited
// with the `|` separator.
func (flags ParamFlags) String(f uint64) string {
	var (
		n strings.Builder
		s string
	)
	for _, flag := range flags {
		if flag.eval(f) {
			n.WriteString(s)
			n.WriteString(flag.Name)
			s = "|"
			// remove current flags value to avoid duplicates
			f &= ^flag.Value
		}
	}
	return n.String()
}

const (
	// PsApplicationID identifies the packaged process
	PsApplicationID = 0x00000001
	// PsWOW64 indicates if the 32-bit process is created in 64-bit Windows system
	PsWOW64 = 0x00000002
	// PsProtected process is to be run as a protected process. The system restricts
	// access to protected processes and the threads of protected processes.
	PsProtected = 0x00000004
	// PsPackaged represents a process packaged with the MSIX technology and thus has
	// package identity.
	PsPackaged = 0x00000008
)

// PsCreationFlags describes the process creation flags.
var PsCreationFlags = []ParamFlag{
	{"APPLICATION_ID", PsApplicationID},
	{"WOW64", PsWOW64},
	{"PROTECTED", PsProtected},
	{"PACKAGED", PsPackaged},
}

// AllAccess represents the maximum process/thread access right
const AllAccess = windows.STANDARD_RIGHTS_REQUIRED | windows.SYNCHRONIZE | 0xFFFF

// PsAccessRightFlags describes flags for the process access rights.
var PsAccessRightFlags = []ParamFlag{
	{"ALL_ACCESS", AllAccess},
	{"DELETE", windows.DELETE},
	{"READ_CONTROL", windows.READ_CONTROL},
	{"SYNCHRONIZE", windows.SYNCHRONIZE},
	{"WRITE_DAC", windows.WRITE_DAC},
	{"WRITE_OWNER", windows.WRITE_OWNER},
	{"GENERIC_READ", windows.GENERIC_READ},
	{"ACCESS_SYSTEM_SECURITY", windows.ACCESS_SYSTEM_SECURITY},
	{"TERMINATE", windows.PROCESS_TERMINATE},
	{"CREATE_THREAD", windows.PROCESS_CREATE_THREAD},
	{"VM_OPERATION", windows.PROCESS_VM_OPERATION},
	{"VM_READ", windows.PROCESS_VM_READ},
	{"VM_WRITE", windows.PROCESS_VM_WRITE},
	{"DUP_HANDLE", windows.PROCESS_DUP_HANDLE},
	{"CREATE_PROCESS", windows.PROCESS_CREATE_PROCESS},
	{"SET_QUOTA", windows.PROCESS_SET_QUOTA},
	{"SET_INFORMATION", windows.PROCESS_SET_INFORMATION},
	{"QUERY_INFORMATION", windows.PROCESS_QUERY_INFORMATION},
	{"SUSPEND_RESUME", windows.PROCESS_SUSPEND_RESUME},
	{"QUERY_LIMITED_INFORMATION", windows.PROCESS_QUERY_LIMITED_INFORMATION},
}

// ThreadAccessRightFlags describes flags for the thread access rights.
var ThreadAccessRightFlags = []ParamFlag{
	{"ALL_ACCESS", AllAccess},
	{"DELETE", windows.DELETE},
	{"READ_CONTROL", windows.READ_CONTROL},
	{"SYNCHRONIZE", windows.SYNCHRONIZE},
	{"WRITE_DAC", windows.WRITE_DAC},
	{"WRITE_OWNER", windows.WRITE_OWNER},
	{"TERMINATE", windows.THREAD_TERMINATE},
	{"SUSPEND_THREAD", windows.THREAD_SUSPEND_RESUME},
	{"GET_CONTEXT", windows.THREAD_GET_CONTEXT},
	{"SET_CONTEXT", windows.THREAD_SET_CONTEXT},
	{"SET_INFORMATION", windows.THREAD_SET_INFORMATION},
	{"QUERY_INFORMATION", windows.THREAD_QUERY_INFORMATION},
	{"SET_THREAD_TOKEN", windows.THREAD_SET_THREAD_TOKEN},
	{"IMPERSONATE", windows.THREAD_IMPERSONATE},
	{"DIRECT_IMPERSONATION", windows.THREAD_DIRECT_IMPERSONATION},
	{"SET_LIMITED_INFORMATION", windows.THREAD_SET_LIMITED_INFORMATION},
	{"QUERY_LIMITED_INFORMATION", windows.THREAD_QUERY_LIMITED_INFORMATION},
}

// FileAttributeFlags describes file attribute flags.
var FileAttributeFlags = []ParamFlag{
	{"READ_ONLY", windows.FILE_ATTRIBUTE_READONLY},
	{"HIDDEN", windows.FILE_ATTRIBUTE_HIDDEN},
	{"SYSTEM", windows.FILE_ATTRIBUTE_SYSTEM},
	{"DIRECTORY", windows.FILE_ATTRIBUTE_DIRECTORY},
	{"ARCHIVE", windows.FILE_ATTRIBUTE_ARCHIVE},
	{"DEVICE", windows.FILE_ATTRIBUTE_DEVICE},
	{"NORMAL", windows.FILE_ATTRIBUTE_NORMAL},
	{"TEMPORARY", windows.FILE_ATTRIBUTE_TEMPORARY},
	{"SPARSE", windows.FILE_ATTRIBUTE_SPARSE_FILE},
	{"JUNCTION", windows.FILE_ATTRIBUTE_REPARSE_POINT},
	{"COMPRESSED", windows.FILE_ATTRIBUTE_COMPRESSED},
	{"OFFLINE", windows.FILE_ATTRIBUTE_OFFLINE},
	{"UNINDEXED", windows.FILE_ATTRIBUTE_NOT_CONTENT_INDEXED},
	{"ENCRYPTED", windows.FILE_ATTRIBUTE_ENCRYPTED},
	{"STREAM", windows.FILE_ATTRIBUTE_INTEGRITY_STREAM},
	{"VIRTUAL", windows.FILE_ATTRIBUTE_VIRTUAL},
	{"NO_SCRUB", windows.FILE_ATTRIBUTE_NO_SCRUB_DATA},
	{"RECALL_OPEN", windows.FILE_ATTRIBUTE_RECALL_ON_OPEN},
	{"RECALL_ACCESS", windows.FILE_ATTRIBUTE_RECALL_ON_DATA_ACCESS},
	{"PINNED", 0x80000},
	{"UNPINNED", 0x100000},
}

// FileCreateOptionsFlags describes file create options flags
var FileCreateOptionsFlags = []ParamFlag{
	{"DIRECTORY_FILE", windows.FILE_DIRECTORY_FILE},
	{"WRITE_THROUGH", windows.FILE_WRITE_THROUGH},
	{"SEQUENTIAL_ONLY", windows.FILE_SEQUENTIAL_ONLY},
	{"NO_INTERMEDIATE_BUFFERING", windows.FILE_NO_INTERMEDIATE_BUFFERING},
	{"SYNCHRONOUS_IO_ALERT", windows.FILE_SYNCHRONOUS_IO_ALERT},
	{"SYNCHRONOUS_IO_NONALERT", windows.FILE_SYNCHRONOUS_IO_NONALERT},
	{"NON_DIRECTORY_FILE", windows.FILE_NON_DIRECTORY_FILE},
	{"CREATE_TREE_CONNECTION", windows.FILE_CREATE_TREE_CONNECTION},
	{"COMPLETE_IF_OPLOCKED", windows.FILE_COMPLETE_IF_OPLOCKED},
	{"NO_EA_KNOWLEDGE", windows.FILE_NO_EA_KNOWLEDGE},
	{"OPEN_REMOTE_INSTANCE", windows.FILE_OPEN_REMOTE_INSTANCE},
	{"RANDOM_ACCESS", windows.FILE_RANDOM_ACCESS},
	{"DELETE_ON_CLOSE", windows.FILE_DELETE_ON_CLOSE},
	{"OPEN_BY_FILE_ID", windows.FILE_OPEN_BY_FILE_ID},
	{"FOR_BACKUP_INTENT", windows.FILE_OPEN_FOR_BACKUP_INTENT},
	{"NO_COMPRESSION", windows.FILE_NO_COMPRESSION},
	{"OPEN_REQUIRING_OPLOCK", windows.FILE_OPEN_REQUIRING_OPLOCK},
	{"DISALLOW_EXCLUSIVE", windows.FILE_DISALLOW_EXCLUSIVE},
	{"RESERVE_OPFILTER", windows.FILE_RESERVE_OPFILTER},
	{"OPEN_REPARSE_POINT", windows.FILE_OPEN_REPARSE_POINT},
	{"OPEN_NO_RECALL", windows.FILE_OPEN_NO_RECALL},
	{"OPEN_FOR_FREE_SPACE_QUERY", windows.FILE_OPEN_FOR_FREE_SPACE_QUERY},
}

// FileShareModeFlags describes file share mask flags
var FileShareModeFlags = []ParamFlag{
	{"READ", windows.FILE_SHARE_READ},
	{"WRITE", windows.FILE_SHARE_WRITE},
	{"DELETE", windows.FILE_SHARE_DELETE},
}

// MemAllocationFlags describes virtual allocation/free type flags
var MemAllocationFlags = []ParamFlag{
	{"COMMIT", windows.MEM_COMMIT},
	{"RESERVE", windows.MEM_RESERVE},
	{"RESET", windows.MEM_RESET},
	{"RESET_UNDO", windows.MEM_RESET_UNDO},
	{"PHYSICAL", windows.MEM_PHYSICAL},
	{"LARGE_PAGES", windows.MEM_LARGE_PAGES},
	{"TOP_DOWN", windows.MEM_TOP_DOWN},
	{"RELEASE", windows.MEM_RELEASE},
	{"DECOMMIT", windows.MEM_DECOMMIT},
	{"WRITE_WATCH", windows.MEM_WRITE_WATCH},
}

// MemProtectionFlags represents memory protection option flags.
var MemProtectionFlags = []ParamFlag{
	{"NONE", 0},
	{"EXECUTE", windows.PAGE_EXECUTE},
	{"EXECUTE_READ", windows.PAGE_EXECUTE_READ},
	{"EXECUTE_READWRITE", windows.PAGE_EXECUTE_READWRITE},
	{"EXECUTE_WRITECOPY", windows.PAGE_EXECUTE_WRITECOPY},
	{"NOACCESS", windows.PAGE_NOACCESS},
	{"READONLY", windows.PAGE_READONLY},
	{"READWRITE", windows.PAGE_READWRITE},
	{"WRITECOPY", windows.PAGE_WRITECOPY},
	{"TARGETS_INVALID", windows.PAGE_TARGETS_INVALID},
	{"TARGETS_NO_UPDATE", windows.PAGE_TARGETS_NO_UPDATE},
	{"GUARD", windows.PAGE_GUARD},
	{"NOCACHE", windows.PAGE_NOCACHE},
	{"WRITECOMBINE", windows.PAGE_WRITECOMBINE},
}

// ViewProtectionFlags describes section protection flags. These
// have different values than the memory protection flags as they
// are reported by the kernel.
var ViewProtectionFlags = []ParamFlag{
	{"EXECUTE_READWRITE", sys.SectionRWX},
	{"EXECUTE_WRITECOPY", sys.SectionWXC},
	{"NOCACHE", sys.SectionNC},
	{"WRITECOMBINE", sys.SectionWCB},
	{"READONLY", sys.SectionR},
	{"EXECUTE", sys.SectionX},
	{"EXECUTE_READ", sys.SectionRX},
	{"READWRITE", sys.SectionRW},
	{"WRITECOPY", sys.SectionWC},
}

// DNSOptsFlags describes DNS query/response options.
var DNSOptsFlags = []ParamFlag{
	{"STANDARD", 0x00000000},
	{"ACCEPT_TRUNCATED_RESPONSE", 0x00000001},
	{"USE_TCP_ONLY", 0x00000002},
	{"NO_RECURSION", 0x00000004},
	{"BYPASS_CACHE", 0x00000008},
	{"NO_WIRE_QUERY", 0x00000010},
	{"NO_LOCAL_NAME", 0x00000020},
	{"NO_NETBT", 0x00000080},
	{"WIRE_ONLY", 0x00000100},
	{"RETURN_MESSAGE", 0x00000200},
	{"MULTICAST_ONLY", 0x00000400},
	{"NO_MULTICAST", 0x00000800},
	{"TREAT_AS_FQDN", 0x00001000},
	{"ADDRCONFIG", 0x00002000},
	{"DUAL_ADDR", 0x00004000},
	{"MULTICAST_WAIT", 0x00020000},
	{"MULTICAST_VERIFY", 0x00040000},
	{"DONT_RESET_TTL_VALUES", 0x00100000},
	{"DISABLE_IDN_ENCODING", 0x00200000},
	{"APPEND_MULTILABEL", 0x00800000},
}

// AccessMaskFlags describes the generic and specific access rights
var AccessMaskFlags = []ParamFlag{
	{"DELETE", windows.DELETE},
	{"READ_CONTROL", windows.READ_CONTROL},
	{"WRITE_DAC", windows.WRITE_DAC},
	{"WRITE_OWNER", windows.WRITE_OWNER},
	{"SYNCHRONIZE", windows.SYNCHRONIZE},
	{"STANDARD_RIGHTS_REQUIRED", windows.STANDARD_RIGHTS_REQUIRED},
	{"STANDARD_RIGHTS_ALL", windows.STANDARD_RIGHTS_ALL},
	{"ACCESS_SYSTEM_SECURITY", windows.ACCESS_SYSTEM_SECURITY},
	{"MAXIMUM_ALLOWED", windows.MAXIMUM_ALLOWED},
	{"GENERIC_READ", windows.GENERIC_READ},
	{"GENERIC_WRITE", windows.GENERIC_WRITE},
	{"GENERIC_EXECUTE", windows.GENERIC_EXECUTE},
	{"GENERIC_ALL", windows.GENERIC_ALL},
}

```

`pkg/event/flags_test.go`:

```go
/*
 * Copyright 2021-2022 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package event

import "testing"

func TestParamFlags(t *testing.T) {
	var tests = []struct {
		flag     uint64
		flags    ParamFlags
		expected string
	}{
		{0x1fffff, PsAccessRightFlags, "ALL_ACCESS"},
		{0x1400, PsAccessRightFlags, "QUERY_INFORMATION|QUERY_LIMITED_INFORMATION"},
		{0x1800, ThreadAccessRightFlags, "QUERY_LIMITED_INFORMATION"},
		{0x00000002, PsCreationFlags, "WOW64"},
	}

	for i, tt := range tests {
		s := tt.flags.String(tt.flag)
		if s != tt.expected {
			t.Errorf("%d. %q flag mismatch: exp=%s got=%s", i, tt.expected, tt.expected, s)
		}
	}
}

```

`pkg/event/formatter.go`:

```go
/*
 * Copyright 2019-2020 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package event

import (
	"fmt"
	"github.com/rabbitstack/fibratus/pkg/util/fasttemplate"
	"regexp"
	"sort"
	"strings"
	"unicode"
)

const (
	// startTag represents the leading tag surrounding field name
	startTag = "{{"
	// endTag represents the trailing tag surrounding field name
	endTag = "}}"

	seq          = ".Seq"
	ts           = ".Timestamp"
	pid          = ".Pid"
	ppid         = ".Ppid"
	pexe         = ".Pexe"
	pcmd         = ".Pcmd"
	pproc        = ".Pname"
	cwd          = ".Cwd"
	exe          = ".Exe"
	cmd          = ".Cmd"
	tid          = ".Tid"
	sid          = ".Sid"
	proc         = ".Process"
	cat          = ".Category"
	desc         = ".Description"
	cpu          = ".CPU"
	typ          = ".Type"
	parameters   = ".Params"
	meta         = ".Meta"
	host         = ".Host"
	pe           = ".PE"
	parsAccessor = ".Params."
	cstack       = ".Callstack"
)

var (
	// tmplRegexp defines the regular expression for parsing template fields.
	tmplRegexp = regexp.MustCompile(`({{2}.*?}{2})`)
	// tmplNormRegepx defines the regular expression for normalizing the template. This basically consists in removing
	// the brackets and trailing/leading spaces from the field name.
	tmplNormRegexp = regexp.MustCompile(`({{2}\s*([A-Za-z.]+)\s*}{2})`)
	// tmplExpandParamsRegexp determines whether Params. fields are expanded
	tmplExpandParamsRegexp = regexp.MustCompile(`{{\s*.Params.\S+}}`)
)

var fields = map[string]bool{
	seq:        true,
	ts:         true,
	pid:        true,
	ppid:       true,
	pexe:       true,
	pcmd:       true,
	pproc:      true,
	cwd:        true,
	exe:        true,
	cmd:        true,
	tid:        true,
	sid:        true,
	proc:       true,
	cat:        true,
	desc:       true,
	cpu:        true,
	typ:        true,
	parameters: true,
	meta:       true,
	host:       true,
	pe:         true,
	cstack:     true,
}

func hintFields() string {
	s := make([]string, 0, len(fields))
	for field := range fields {
		s = append(s, field)
	}
	sort.Slice(s, func(i, j int) bool { return s[i] < s[j] })
	return strings.Join(s, " ")
}

// Formatter deals with producing event's output that is dictated by the template.
type Formatter struct {
	t               *fasttemplate.Template
	expandParamsDot bool
}

// NewFormatter builds a new instance of event's formatter.
func NewFormatter(template string) (*Formatter, error) {
	// check basic template format and ensure all fields
	// defined in the template are known to us
	flds := tmplRegexp.FindAllStringSubmatch(template, -1)
	if len(flds) == 0 {
		return nil, fmt.Errorf("invalid template format: %q", template)
	}
	if ok, pos := isTemplateBalanced(template); !ok {
		return nil, fmt.Errorf("template syntax error near field #%d: %q", pos, template)
	}
	for i, field := range flds {
		if len(field) > 0 {
			name := sanitize(field[0])
			if strings.HasPrefix(name, parsAccessor) {
				continue
			}
			if name == "" {
				return nil, fmt.Errorf("empty field found at position %d", i+1)
			}
			if _, ok := fields[name]; !ok {
				return nil, fmt.Errorf("%s is not a known field name. Maybe you meant one "+
					"of the following fields: %s", name, hintFields())
			}
		}
	}
	// user might define the tag such as `{{ .Seq }}` or {{ .Seq}}`. We have to make sure
	// inner spaces are removed before building the fast template instance
	norm := normalizeTemplate(template)
	t, err := fasttemplate.NewTemplate(norm, startTag, endTag)
	if err != nil {
		return nil, fmt.Errorf("invalid template format %q: %v", norm, err)
	}
	return &Formatter{
		t:               t,
		expandParamsDot: tmplExpandParamsRegexp.MatchString(norm),
	}, nil
}

func sanitize(s string) string {
	return strings.Map(func(r rune) rune {
		if r == '{' || r == '}' || unicode.IsSpace(r) {
			return -1
		}
		return r
	},
		s,
	)
}

func normalizeTemplate(tmpl string) string { return tmplNormRegexp.ReplaceAllString(tmpl, "{{$2}}") }

const expectedBracketsSeq = "{{}}"

// isTemplateBalanced ensures the template string is balanced. This means that each tag in the template
// has its pair of leading/trailing brackets.
func isTemplateBalanced(tmpl string) (bool, int) {
	// drop all but brackets
	s := strings.Map(func(r rune) rune {
		if r == '{' || r == '}' {
			return r
		}
		return -1
	},
		tmpl,
	)
	// partition slice into 4 groups. Each group must follow
	// the correct sequence, otherwise it is an invalid field
	partSize := 4
	partitions := len(s) / partSize
	var i int
	for ; i < partitions; i++ {
		if s[i*partSize:(i+1)*partSize] != expectedBracketsSeq {
			return false, i + 1
		}
	}
	if len(s)%partSize != 0 {
		if s[i*partSize:] != expectedBracketsSeq {
			return false, i + 1
		}
	}
	return true, -1
}

```

`pkg/event/formatter_test.go`:

```go
/*
 * Copyright 2019-2020 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package event

import (
	htypes "github.com/rabbitstack/fibratus/pkg/handle/types"
	pstypes "github.com/rabbitstack/fibratus/pkg/ps/types"
	"github.com/stretchr/testify/assert"

	kpars "github.com/rabbitstack/fibratus/pkg/event/params"
	"github.com/stretchr/testify/require"
	"testing"
)

func TestTemplateUnknownField(t *testing.T) {
	template := "{{ .Seq }} {{NUllField1}} {{.Type}}"
	_, err := NewFormatter(template)
	require.Error(t, err, "NUllField1 is not a known field name. Maybe you meant one of the following fields: .CPU .Category .Cmd .Cwd .Description .Exe .Handles .Host .Params .Meta .Pid .Ppid .Process .Seq .Sid .Tid .Timestamp .Type")
}

func TestTemplateEmptyField(t *testing.T) {
	template := "{{ .Seq }} {{}} {{.Type}}"
	_, err := NewFormatter(template)
	require.Error(t, err, "empty field found at position 2")

	template1 := "{{ .Seq }} {{.CPU}} -  ({{.Type}}) -- pid: {{}} {{ .Params.Pid }} ({{.Params}}) {{ .Meta }}"
	_, err = NewFormatter(template1)
	require.Error(t, err, "empty field found at position 4")
}

func TestTemplateSyntaxError(t *testing.T) {
	template := "{{ .Seq }} {{.CPU}} {.Type}}"
	_, err := NewFormatter(template)
	require.Error(t, err, "template syntax error near field #3: {{ .Seq }} {{.CPU}} {.Type}}")
}

func TestFormat(t *testing.T) {
	template := "{{ .Seq }} {{.CPU}} -  ({{.Type}}) -- pid: {{ .Params.Pid }} ({{.Params}}) {{ .Meta }}"
	f, err := NewFormatter(template)
	require.NoError(t, err)
	params := Params{
		kpars.ProcessID: {Name: kpars.ProcessID, Type: kpars.PID, Value: uint32(876)},
	}
	s := f.Format(&Event{CPU: uint8(4), Name: "CreateProcess", Seq: uint64(1999), Params: params, Metadata: map[MetadataKey]any{"key1": "value1"}})
	assert.Equal(t, "1999 4 -  (CreateProcess) -- pid: 876 (pid➜ 876) key1: value1", string(s))
}

func TestFormatPS(t *testing.T) {
	template := "{{ .Seq }} {{ .Process }} ({{ .Cwd }}) {{ .Ppid }} ({{ .Sid }})"
	f, err := NewFormatter(template)
	require.NoError(t, err)
	params := Params{
		kpars.ProcessID: {Name: kpars.ProcessID, Type: kpars.PID, Value: uint32(876)},
	}
	s := f.Format(&Event{
		CPU:    uint8(4),
		Name:   "CreateProcess",
		Seq:    uint64(1999),
		Params: params,
		PS: &pstypes.PS{
			Name: "cmd.exe",
			Cwd:  "C:/Windows/System32",
			SID:  "nedo/archrabbit",
			Ppid: 2324,
			Handles: htypes.Handles{
				{Name: "C:/Windows/notepad.exe", Type: "File"},
				{Name: "HKEY_LOCAL_MACHINE/Software", Type: "Key"},
			},
		},
	})
	assert.Equal(t, "1999 cmd.exe (C:/Windows/System32) 2324 (nedo/archrabbit)", string(s))
}

func TestNormalizeTemplate(t *testing.T) {
	assert.Equal(t, "{{.Seq}}   {{.CPU}}", normalizeTemplate("{{ .Seq }}   {{   .CPU   }}"))
}

func TestIsTemplateBalanced(t *testing.T) {
	ok, pos := isTemplateBalanced("{{ .Seq }} {{.CPU}}")
	require.True(t, ok)
	assert.Equal(t, -1, pos)

	ok, pos = isTemplateBalanced("{{ .Seq }} ({{.CPU}}) [] {{.Type}}")
	require.True(t, ok)
	assert.Equal(t, -1, pos)

	ok, pos = isTemplateBalanced("{{ .Seq }} {.CPU}} {{.Type}}")
	require.False(t, ok)
	assert.Equal(t, 2, pos)

	ok, pos = isTemplateBalanced("{.Seq}")
	require.False(t, ok)
	assert.Equal(t, 1, pos)

	ok, pos = isTemplateBalanced("{{ .Seq }} .CPU }}")
	require.False(t, ok)
	assert.Equal(t, 2, pos)

	ok, pos = isTemplateBalanced("{{{ .Seq }} {{.CPU}} {{} {{ .Params }} { .Params.pid}}")
	require.False(t, ok)
	assert.Equal(t, 1, pos)

	ok, pos = isTemplateBalanced("{{ .Seq }} {{.CPU}} {{} {{ .Params }} { .Params.pid}}")
	require.False(t, ok)
	assert.Equal(t, 3, pos)

	ok, pos = isTemplateBalanced("({{ .Seq }}) {{.CPU}} {{}} {{ .Params }} { .Params.pid}}")
	require.False(t, ok)
	assert.Equal(t, 5, pos)

	ok, pos = isTemplateBalanced("{{ .Seq } {{.CPU}} {.Type}}")
	require.False(t, ok)
	assert.Equal(t, 1, pos)

	ok, pos = isTemplateBalanced("{{ .Seq }} {{.CPU}} {.Type}}")
	require.False(t, ok)
	assert.Equal(t, 3, pos)

	ok, pos = isTemplateBalanced("{{ .Seq }} {{.CPU}} -  ({{.Type}}) -- pid: {{]} {{ .Params.Pid }} ({{.Params}}) {{ .Meta }}")
	require.False(t, ok)
	assert.Equal(t, 4, pos)
}

```

`pkg/event/formatter_windows.go`:

```go
/*
 * Copyright 2020-2021 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package event

import (
	"strconv"
)

// Format applies the template on the provided event.
func (f *Formatter) Format(evt *Event) []byte {
	if evt == nil {
		return []byte{}
	}
	values := map[string]interface{}{
		ts:         evt.Timestamp.String(),
		pid:        strconv.FormatUint(uint64(evt.PID), 10),
		tid:        strconv.FormatUint(uint64(evt.Tid), 10),
		seq:        strconv.FormatUint(evt.Seq, 10),
		cpu:        strconv.FormatUint(uint64(evt.CPU), 10),
		typ:        evt.Name,
		cat:        evt.Category,
		desc:       evt.Description,
		host:       evt.Host,
		meta:       evt.Metadata.String(),
		parameters: evt.Params.String(),
	}

	// add process metadata
	ps := evt.PS
	if ps != nil {
		values[proc] = ps.Name
		values[ppid] = strconv.FormatUint(uint64(ps.Ppid), 10)
		values[cwd] = ps.Cwd
		values[exe] = ps.Exe
		values[cmd] = ps.Cmdline
		values[sid] = ps.SID
		parent := ps.Parent
		if parent != nil {
			values[pproc] = parent.Name
			values[pexe] = parent.Exe
			values[pcmd] = parent.Cmdline
		}
		if ps.PE != nil {
			values[pe] = ps.PE.String()
		}
	}
	// add callstack summary
	if !evt.Callstack.IsEmpty() {
		values[cstack] = evt.Callstack.String()
	}

	if f.expandParamsDot {
		// expand all parameters into the map, so we can ask
		// for specific parameter names in the template
		for _, par := range evt.Params {
			values[".Params."+caser.String(par.Name)] = par.String()
		}
	}

	return f.t.ExecuteString(values)
}

```

`pkg/event/marshaller.go`:

```go
/*
 * Copyright 2019-2020 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package event

import (
	"math"
	"strconv"
	"unicode/utf8"
)

type jsonStream struct {
	buf []byte
}

func newJSONStream() *jsonStream {
	return &jsonStream{buf: make([]byte, 0)}
}

func (js *jsonStream) flush() []byte {
	buf := js.buf
	js.buf = nil
	return buf
}

func (js *jsonStream) writeByte(c byte) {
	js.buf = append(js.buf, c)
}

func (js *jsonStream) writeTwoBytes(c1, c2 byte) {
	js.buf = append(js.buf, c1, c2)
}

func (js *jsonStream) writeString(s string) *jsonStream {
	js.writeByte('"')
	js.buf = append(js.buf, s...)
	js.writeByte('"')
	return js
}

func (js *jsonStream) writeRaw(s string) {
	js.buf = append(js.buf, s...)
}

func (js *jsonStream) writeEscapeString(s string) *jsonStream {
	valLen := len(s)
	js.buf = append(js.buf, '"')
	// write string, the fast path, without utf8 and escape support
	i := 0
	for ; i < valLen; i++ {
		c := s[i]
		if c > 31 && c != '"' && c != '\\' {
			js.buf = append(js.buf, c)
		} else {
			break
		}
	}
	if i == valLen {
		js.buf = append(js.buf, '"')
		return js
	}

	// write remaining part of the string with escape support
	writeStringSlowPath(js, i, s, valLen)
	return js
}

//nolint:unparam
func (js *jsonStream) writeObjectStart() *jsonStream {
	js.writeByte('{')
	return js
}

//nolint:unparam
func (js *jsonStream) writeArrayStart() *jsonStream {
	js.writeByte('[')
	return js
}

func (js *jsonStream) writeArrayEnd() *jsonStream {
	js.writeByte(']')
	return js
}

func (js *jsonStream) writeObjectField(f string) *jsonStream {
	js.writeString(f)
	js.writeTwoBytes(':', ' ')
	return js
}

func (js *jsonStream) writeBool(b bool) *jsonStream {
	if b {
		js.writeString("true")
		return js
	}
	js.writeString("false")
	return js
}

func (js *jsonStream) writeObjectEnd() *jsonStream {
	js.writeByte('}')
	return js
}

//nolint:unparam
func (js *jsonStream) writeMore() *jsonStream {
	js.writeByte(',')
	return js
}

func (js *jsonStream) shouldWriteMore(i, l int) bool {
	//nolint:staticcheck
	return !(i == l-1)
}

// borrowed from jsointer: https://github.com/json-iterator/go/blob/2fbdfbb5951116fb8bede4fd8b919a19e4a6b647/stream_int.go and https://github.com/json-iterator/go/blob/2fbdfbb5951116fb8bede4fd8b919a19e4a6b647/stream_float.go

var digits []uint32

// safeSet holds the value true if the ASCII character with the given array
// position can be represented inside a JSON string without any further
// escaping.
//
// All values are true except for the ASCII control characters (0-31), the
// double quote ("), and the backslash character ("\").
var safeSet = [utf8.RuneSelf]bool{
	' ':      true,
	'!':      true,
	'"':      false,
	'#':      true,
	'$':      true,
	'%':      true,
	'&':      true,
	'\'':     true,
	'(':      true,
	')':      true,
	'*':      true,
	'+':      true,
	',':      true,
	'-':      true,
	'.':      true,
	'/':      true,
	'0':      true,
	'1':      true,
	'2':      true,
	'3':      true,
	'4':      true,
	'5':      true,
	'6':      true,
	'7':      true,
	'8':      true,
	'9':      true,
	':':      true,
	';':      true,
	'<':      true,
	'=':      true,
	'>':      true,
	'?':      true,
	'@':      true,
	'A':      true,
	'B':      true,
	'C':      true,
	'D':      true,
	'E':      true,
	'F':      true,
	'G':      true,
	'H':      true,
	'I':      true,
	'J':      true,
	'K':      true,
	'L':      true,
	'M':      true,
	'N':      true,
	'O':      true,
	'P':      true,
	'Q':      true,
	'R':      true,
	'S':      true,
	'T':      true,
	'U':      true,
	'V':      true,
	'W':      true,
	'X':      true,
	'Y':      true,
	'Z':      true,
	'[':      true,
	'\\':     false,
	']':      true,
	'^':      true,
	'_':      true,
	'`':      true,
	'a':      true,
	'b':      true,
	'c':      true,
	'd':      true,
	'e':      true,
	'f':      true,
	'g':      true,
	'h':      true,
	'i':      true,
	'j':      true,
	'k':      true,
	'l':      true,
	'm':      true,
	'n':      true,
	'o':      true,
	'p':      true,
	'q':      true,
	'r':      true,
	's':      true,
	't':      true,
	'u':      true,
	'v':      true,
	'w':      true,
	'x':      true,
	'y':      true,
	'z':      true,
	'{':      true,
	'|':      true,
	'}':      true,
	'~':      true,
	'\u007f': true,
}

var hex = "0123456789abcdef"

func init() {
	digits = make([]uint32, 1000)
	for i := uint32(0); i < 1000; i++ {
		digits[i] = (((i / 100) + '0') << 16) + ((((i / 10) % 10) + '0') << 8) + i%10 + '0'
		if i < 10 {
			digits[i] += 2 << 24
		} else if i < 100 {
			digits[i] += 1 << 24
		}
	}
}

func writeStringSlowPath(stream *jsonStream, i int, s string, valLen int) {
	start := i
	// for the remaining parts, we process them char by char
	for i < valLen {
		if b := s[i]; b < utf8.RuneSelf {
			if safeSet[b] {
				i++
				continue
			}
			if start < i {
				stream.writeRaw(s[start:i])
			}
			switch b {
			case '\\', '"':
				stream.writeTwoBytes('\\', b)
			case '\n':
				stream.writeTwoBytes('\\', 'n')
			case '\r':
				stream.writeTwoBytes('\\', 'r')
			case '\t':
				stream.writeTwoBytes('\\', 't')
			default:
				// This encodes bytes < 0x20 except for \t, \n and \r.
				// If escapeHTML is set, it also escapes <, >, and &
				// because they can lead to security holes when
				// user-controlled strings are rendered into JSON
				// and served to some browsers.
				stream.writeRaw(`\u00`)
				stream.writeTwoBytes(hex[b>>4], hex[b&0xF])
			}
			i++
			start = i
			continue
		}
		i++
		continue
	}
	if start < len(s) {
		stream.writeRaw(s[start:])
	}
	stream.writeByte('"')
}

func writeFirstBuf(space []byte, v uint32) []byte {
	start := v >> 24
	switch start {
	case 0:
		space = append(space, byte(v>>16), byte(v>>8))
	case 1:
		space = append(space, byte(v>>8))
	}
	space = append(space, byte(v))
	return space
}

func writeBuf(buf []byte, v uint32) []byte {
	return append(buf, byte(v>>16), byte(v>>8), byte(v))
}

func (js *jsonStream) writeUint8(val uint8) *jsonStream {
	js.buf = writeFirstBuf(js.buf, digits[val])
	return js
}

func (js *jsonStream) writeInt8(nval int8) *jsonStream {
	var val uint8
	if nval < 0 {
		val = uint8(-nval)
		js.buf = append(js.buf, '-')
	} else {
		val = uint8(nval)
	}
	js.buf = writeFirstBuf(js.buf, digits[val])
	return js
}

func (js *jsonStream) writeUint16(val uint16) *jsonStream {
	q1 := val / 1000
	if q1 == 0 {
		js.buf = writeFirstBuf(js.buf, digits[val])
		return js
	}
	r1 := val - q1*1000
	js.buf = writeFirstBuf(js.buf, digits[q1])
	js.buf = writeBuf(js.buf, digits[r1])
	return js
}

func (js *jsonStream) writeInt16(nval int16) *jsonStream {
	var val uint16
	if nval < 0 {
		val = uint16(-nval)
		js.buf = append(js.buf, '-')
	} else {
		val = uint16(nval)
	}
	js.writeUint16(val)
	return js
}

func (js *jsonStream) writeUint32(val uint32) *jsonStream {
	q1 := val / 1000
	if q1 == 0 {
		js.buf = writeFirstBuf(js.buf, digits[val])
		return js
	}
	r1 := val - q1*1000
	q2 := q1 / 1000
	if q2 == 0 {
		js.buf = writeFirstBuf(js.buf, digits[q1])
		js.buf = writeBuf(js.buf, digits[r1])
		return js
	}
	r2 := q1 - q2*1000
	q3 := q2 / 1000
	if q3 == 0 {
		js.buf = writeFirstBuf(js.buf, digits[q2])
	} else {
		r3 := q2 - q3*1000
		js.buf = append(js.buf, byte(q3+'0'))
		js.buf = writeBuf(js.buf, digits[r3])
	}
	js.buf = writeBuf(js.buf, digits[r2])
	js.buf = writeBuf(js.buf, digits[r1])
	return js
}

func (js *jsonStream) writeInt32(nval int32) *jsonStream {
	var val uint32
	if nval < 0 {
		val = uint32(-nval)
		js.buf = append(js.buf, '-')
	} else {
		val = uint32(nval)
	}
	js.writeUint32(val)
	return js
}

func (js *jsonStream) writeUint64(val uint64) *jsonStream {
	q1 := val / 1000
	if q1 == 0 {
		js.buf = writeFirstBuf(js.buf, digits[val])
		return js
	}
	r1 := val - q1*1000
	q2 := q1 / 1000
	if q2 == 0 {
		js.buf = writeFirstBuf(js.buf, digits[q1])
		js.buf = writeBuf(js.buf, digits[r1])
		return js
	}
	r2 := q1 - q2*1000
	q3 := q2 / 1000
	if q3 == 0 {
		js.buf = writeFirstBuf(js.buf, digits[q2])
		js.buf = writeBuf(js.buf, digits[r2])
		js.buf = writeBuf(js.buf, digits[r1])
		return js
	}
	r3 := q2 - q3*1000
	q4 := q3 / 1000
	if q4 == 0 {
		js.buf = writeFirstBuf(js.buf, digits[q3])
		js.buf = writeBuf(js.buf, digits[r3])
		js.buf = writeBuf(js.buf, digits[r2])
		js.buf = writeBuf(js.buf, digits[r1])
		return js
	}
	r4 := q3 - q4*1000
	q5 := q4 / 1000
	if q5 == 0 {
		js.buf = writeFirstBuf(js.buf, digits[q4])
		js.buf = writeBuf(js.buf, digits[r4])
		js.buf = writeBuf(js.buf, digits[r3])
		js.buf = writeBuf(js.buf, digits[r2])
		js.buf = writeBuf(js.buf, digits[r1])
		return js
	}
	r5 := q4 - q5*1000
	q6 := q5 / 1000
	if q6 == 0 {
		js.buf = writeFirstBuf(js.buf, digits[q5])
	} else {
		js.buf = writeFirstBuf(js.buf, digits[q6])
		r6 := q5 - q6*1000
		js.buf = writeBuf(js.buf, digits[r6])
	}
	js.buf = writeBuf(js.buf, digits[r5])
	js.buf = writeBuf(js.buf, digits[r4])
	js.buf = writeBuf(js.buf, digits[r3])
	js.buf = writeBuf(js.buf, digits[r2])
	js.buf = writeBuf(js.buf, digits[r1])
	return js
}

func (js *jsonStream) writeInt64(nval int64) *jsonStream {
	var val uint64
	if nval < 0 {
		val = uint64(-nval)
		js.buf = append(js.buf, '-')
	} else {
		val = uint64(nval)
	}
	js.writeUint64(val)
	return js
}

// writeFloat32 write float32 to stream
func (js *jsonStream) writeFloat32(val float32) *jsonStream {
	abs := math.Abs(float64(val))
	format := byte('f')
	// Note: Must use float32 comparisons for underlying float32 value to get precise cutoffs right.
	if abs != 0 {
		if float32(abs) < 1e-6 || float32(abs) >= 1e21 {
			format = 'e'
		}
	}
	js.buf = strconv.AppendFloat(js.buf, float64(val), format, -1, 32)
	return js
}

// writeFloat64 write float64 to stream
func (js *jsonStream) writeFloat64(val float64) *jsonStream {
	abs := math.Abs(val)
	format := byte('f')
	// Note: Must use float32 comparisons for underlying float32 value to get precise cutoffs right.
	if abs != 0 {
		if abs < 1e-6 || abs >= 1e21 {
			format = 'e'
		}
	}
	js.buf = strconv.AppendFloat(js.buf, val, format, -1, 64)
	return js
}

```

`pkg/event/marshaller_test.go`:

```go
/*
 * Copyright 2019-2020 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package event

import (
	"encoding/json"
	capver "github.com/rabbitstack/fibratus/pkg/cap/version"
	"github.com/rabbitstack/fibratus/pkg/util/va"
	"golang.org/x/sys/windows"
	"os"
	"testing"
	"time"

	"github.com/rabbitstack/fibratus/pkg/event/params"
	htypes "github.com/rabbitstack/fibratus/pkg/handle/types"
	pex "github.com/rabbitstack/fibratus/pkg/pe"
	pstypes "github.com/rabbitstack/fibratus/pkg/ps/types"
	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/require"
)

func init() {
	SerializeThreads = true
	SerializeImages = true
	SerializeHandles = true
	SerializePE = true
	SerializeEnvs = true
}

func TestMarshaller(t *testing.T) {
	now, err := time.Parse(time.RFC3339Nano, time.Now().Format(time.RFC3339Nano))
	require.NoError(t, err)

	evt := &Event{
		Type:        CreateFile,
		Tid:         2484,
		PID:         859,
		CPU:         1,
		Seq:         2,
		Name:        "CreateFile",
		Timestamp:   now,
		Category:    File,
		Host:        "archrabbit",
		Description: "Creates or opens a new file, directory, I/O device, pipe, console",
		Params: Params{
			params.FileObject:    {Name: params.FileObject, Type: params.Uint64, Value: uint64(12456738026482168384)},
			params.FilePath:      {Name: params.FilePath, Type: params.UnicodeString, Value: "\\Device\\HarddiskVolume2\\Windows\\system32\\user32.dll"},
			params.FileType:      {Name: params.FileType, Type: params.AnsiString, Value: "file"},
			params.FileOperation: {Name: params.FileOperation, Type: params.AnsiString, Value: "open"},
			params.BasePrio:      {Name: params.BasePrio, Type: params.Int8, Value: int8(2)},
			params.PagePrio:      {Name: params.PagePrio, Type: params.Uint8, Value: uint8(2)},
			params.KstackLimit:   {Name: params.KstackLimit, Type: params.Address, Value: uint64(1888833888)},
			params.StartTime:     {Name: params.StartTime, Type: params.Time, Value: time.Now()},
			params.ProcessID:     {Name: params.ProcessID, Type: params.PID, Value: uint32(1204)},
			params.NetDIPNames:   {Name: params.NetDIPNames, Type: params.Slice, Value: []string{"dns.google.", "github.com."}},
		},
		Metadata: map[MetadataKey]any{"foo": "bar", "fooz": "barzz"},
	}

	b := evt.MarshalRaw()
	require.NotEmpty(t, b)

	clone, err := NewFromCapture(b, capver.EvtSecV2)
	require.NoError(t, err)

	assert.Equal(t, uint64(2), clone.Seq)
	assert.Equal(t, uint32(859), clone.PID)
	assert.Equal(t, uint32(2484), clone.Tid)
	assert.Equal(t, CreateFile, clone.Type)
	assert.Equal(t, uint8(1), clone.CPU)
	assert.Equal(t, "CreateFile", clone.Name)
	assert.Equal(t, File, clone.Category)
	assert.Equal(t, "Creates or opens a new file, directory, I/O device, pipe, console", clone.Description)
	assert.Equal(t, "archrabbit", clone.Host)
	assert.Equal(t, now, clone.Timestamp)

	assert.Len(t, clone.Params, 10)

	filename, err := clone.Params.GetString(params.FilePath)
	require.NoError(t, err)
	assert.Equal(t, "\\Device\\HarddiskVolume2\\Windows\\system32\\user32.dll", filename)
	fileobject, err := clone.Params.GetUint64(params.FileObject)
	require.NoError(t, err)
	assert.Equal(t, uint64(12456738026482168384), fileobject)

	assert.Len(t, clone.Metadata, 2)

	assert.Equal(t, "bar", clone.Metadata["foo"])
	assert.Equal(t, "barzz", clone.Metadata["fooz"])
}

func TestEventMarshalJSON(t *testing.T) {
	evt := &Event{
		Type:        CreateFile,
		Tid:         2484,
		PID:         859,
		CPU:         1,
		Seq:         2,
		Name:        "CreateFile",
		Timestamp:   time.Now(),
		Category:    File,
		Host:        "archrabbit",
		Description: "Creates or opens a new file, directory, I/O device, pipe, console",
		Params: Params{
			params.FileObject:    {Name: params.FileObject, Type: params.Uint64, Value: uint64(12456738026482168384)},
			params.FilePath:      {Name: params.FilePath, Type: params.UnicodeString, Value: "\\Device\\HarddiskVolume2\\Windows\\system32\\user32.dll"},
			params.FileType:      {Name: params.FileType, Type: params.AnsiString, Value: "file"},
			params.FileOperation: {Name: params.FileOperation, Type: params.AnsiString, Value: "open"},
			params.BasePrio:      {Name: params.BasePrio, Type: params.Int8, Value: int8(2)},
			params.PagePrio:      {Name: params.PagePrio, Type: params.Uint8, Value: uint8(2)},
			params.NetDIPNames:   {Name: params.NetDIPNames, Type: params.Slice, Value: []string{"dns.google.", "github.com."}},
		},
		Metadata: map[MetadataKey]any{"foo": "bar", "fooz": "baarz"},
		PS: &pstypes.PS{
			PID:  2436,
			Ppid: 6304,
			Parent: &pstypes.PS{
				Name: "explorer.exe",
				Exe:  `C:\Windows\System32\explorer.exe`,
				Cwd:  `C:\Windows\System32`,
				SID:  "admin\\SYSTEM",
			},
			Name:      "firefox.exe",
			Exe:       `C:\Program Files\Mozilla Firefox\firefox.exe`,
			Cmdline:   `C:\Program Files\Mozilla Firefox\firefox.exe -contentproc --channel="6304.3.1055809391\1014207667" -childID 1 -isForBrowser -prefsHandle 2584 -prefMapHandle 2580 -prefsLen 70 -prefMapSize 216993 -parentBuildID 20200107212822 -greomni "C:\Program Files\Mozilla Firefox\omni.ja" -appomni "C:\Program Files\Mozilla Firefox\browser\omni.ja" -appdir "C:\Program Files\Mozilla Firefox\browser" - 6304 "\\.\pipe\gecko-crash-server-pipe.6304" 2596 tab`,
			Cwd:       `C:\Program Files\Mozilla Firefox\`,
			SID:       "archrabbit\\SYSTEM",
			Args:      []string{"-contentproc", `--channel=6304.3.1055809391\1014207667`, "-childID", "1", "-isForBrowser", "-prefsHandle", "2584", "-prefMapHandle", "2580", "-prefsLen", "70", "-prefMapSize", "216993", "-parentBuildID"},
			SessionID: 4,
			Envs:      map[string]string{"ProgramData": "C:\\ProgramData", "COMPUTRENAME": "archrabbit"},
			Threads: map[uint32]pstypes.Thread{
				3453: {Tid: 3453, StartAddress: va.Address(140729524944768), IOPrio: 2, PagePrio: 5, KstackBase: va.Address(18446677035730165760), KstackLimit: va.Address(18446677035730137088), UstackLimit: va.Address(86376448), UstackBase: va.Address(86372352)},
				3455: {Tid: 3455, StartAddress: va.Address(140729524944768), IOPrio: 3, PagePrio: 5, KstackBase: va.Address(18446677035730165760), KstackLimit: va.Address(18446677035730137088), UstackLimit: va.Address(86376448), UstackBase: va.Address(86372352)},
			},
			Handles: []htypes.Handle{
				{Num: windows.Handle(0xffffd105e9baaf70),
					Name:   `\REGISTRY\MACHINE\SYSTEM\ControlSet001\Services\Tcpip\Parameters\Interfaces\{b677c565-6ca5-45d3-b618-736b4e09b036}`,
					Type:   "Key",
					Object: 777488883434455544,
					Pid:    uint32(1023),
				},
				{
					Num:  windows.Handle(0xffffd105e9adaf70),
					Name: `\RPC Control\OLEA61B27E13E028C4EA6C286932E80`,
					Type: "ALPC Port",
					Pid:  uint32(1023),
					MD: &htypes.AlpcPortInfo{
						Seqno:   1,
						Context: 0x0,
						Flags:   0x0,
					},
					Object: 457488883434455544,
				},
				{
					Num:  windows.Handle(0xeaffd105e9adaf30),
					Name: `C:\Users\bunny`,
					Type: "File",
					Pid:  uint32(1023),
					MD: &htypes.FileInfo{
						IsDirectory: true,
					},
					Object: 357488883434455544,
				},
			},
			PE: &pex.PE{
				NumberOfSections: 2,
				NumberOfSymbols:  10,
				EntryPoint:       "0x20110",
				ImageBase:        "0x140000000",
				LinkTime:         time.Now(),
				Sections: []pex.Sec{
					{Name: ".text", Size: 132608, Entropy: 6.368381, Md5: "db23dce3911a42e987041d98abd4f7cd"},
					{Name: ".rdata", Size: 35840, Entropy: 5.996976, Md5: "ffa5c960b421ca9887e54966588e97e8"},
				},
				Symbols:          []string{"SelectObject", "GetTextFaceW", "EnumFontsW", "TextOutW", "GetProcessHeap"},
				Imports:          []string{"GDI32.dll", "USER32.dll", "msvcrt.dll", "api-ms-win-core-libraryloader-l1-2-0.dl"},
				VersionResources: map[string]string{"CompanyName": "Microsoft Corporation", "FileDescription": "Notepad", "FileVersion": "10.0.18362.693"},
			},
		},
	}

	s := evt.MarshalJSON()
	var newEvt Event
	err := json.Unmarshal(s, &newEvt)
	require.NoError(t, err)

	assert.Equal(t, uint32(2484), newEvt.Tid)
	assert.Equal(t, uint32(859), newEvt.PID)
	assert.Equal(t, "archrabbit\\SYSTEM", newEvt.PS.SID)
	assert.Len(t, newEvt.PS.Envs, 2)
	assert.Len(t, newEvt.PS.Handles, 3)

	assert.NotNil(t, newEvt.PS.PE)
	assert.Equal(t, "explorer.exe", newEvt.PS.Parent.Name)
	assert.Equal(t, uint32(10), newEvt.PS.PE.NumberOfSymbols)
	assert.Equal(t, uint16(2), newEvt.PS.PE.NumberOfSections)
	assert.Len(t, newEvt.PS.PE.Sections, 2)
	assert.Len(t, newEvt.PS.PE.Symbols, 5)
	assert.Len(t, newEvt.PS.PE.Imports, 4)
	assert.Len(t, newEvt.PS.PE.VersionResources, 3)
}

func TestUnmarshalHugeHandles(t *testing.T) {
	b, err := os.ReadFile("_fixtures\\handles.json")
	require.NoError(t, err)
	handles := make([]htypes.Handle, 0)
	err = json.Unmarshal(b, &handles)
	require.NoError(t, err)

	evt := &Event{
		Type:        CreateProcess,
		Tid:         2484,
		PID:         859,
		CPU:         1,
		Seq:         2,
		Name:        "CreateProcess",
		Timestamp:   time.Now(),
		Category:    File,
		Host:        "archrabbit",
		Description: "Creates a new process",
		Params: Params{
			params.FileObject:    {Name: params.FileObject, Type: params.Uint64, Value: uint64(12456738026482168384)},
			params.FilePath:      {Name: params.FilePath, Type: params.UnicodeString, Value: "\\Device\\HarddiskVolume2\\Windows\\system32\\user32.dll"},
			params.FileType:      {Name: params.FileType, Type: params.AnsiString, Value: "file"},
			params.FileOperation: {Name: params.FileOperation, Type: params.AnsiString, Value: "open"},
			params.BasePrio:      {Name: params.BasePrio, Type: params.Int8, Value: int8(2)},
			params.PagePrio:      {Name: params.PagePrio, Type: params.Uint8, Value: uint8(2)},
		},
		Metadata: map[MetadataKey]any{"foo": "bar", "fooz": "baarz"},
		PS: &pstypes.PS{
			PID:       2436,
			Ppid:      6304,
			Name:      "firefox.exe",
			Exe:       `C:\Program Files\Mozilla Firefox\firefox.exe`,
			Cmdline:   `C:\Program Files\Mozilla Firefox\firefox.exe -contentproc --channel="6304.3.1055809391\1014207667" -childID 1 -isForBrowser -prefsHandle 2584 -prefMapHandle 2580 -prefsLen 70 -prefMapSize 216993 -parentBuildID 20200107212822 -greomni "C:\Program Files\Mozilla Firefox\omni.ja" -appomni "C:\Program Files\Mozilla Firefox\browser\omni.ja" -appdir "C:\Program Files\Mozilla Firefox\browser" - 6304 "\\.\pipe\gecko-crash-server-pipe.6304" 2596 tab`,
			Cwd:       `C:\Program Files\Mozilla Firefox\`,
			SID:       "archrabbit\\SYSTEM",
			Args:      []string{"-contentproc", `--channel=6304.3.1055809391\1014207667`, "-childID", "1", "-isForBrowser", "-prefsHandle", "2584", "-prefMapHandle", "2580", "-prefsLen", "70", "-prefMapSize", "216993", "-parentBuildID"},
			SessionID: 4,
			Envs:      map[string]string{"ProgramData": "C:\\ProgramData", "COMPUTRENAME": "archrabbit"},
			Threads: map[uint32]pstypes.Thread{
				3453: {Tid: 3453, StartAddress: va.Address(140729524944768), IOPrio: 2, PagePrio: 5, KstackBase: va.Address(18446677035730165760), KstackLimit: va.Address(18446677035730137088), UstackLimit: va.Address(86376448), UstackBase: va.Address(86372352)},
				3455: {Tid: 3455, StartAddress: va.Address(140729524944768), IOPrio: 3, PagePrio: 5, KstackBase: va.Address(18446677035730165760), KstackLimit: va.Address(18446677035730137088), UstackLimit: va.Address(86376448), UstackBase: va.Address(86372352)},
			},
			Handles: handles,
			PE: &pex.PE{
				NumberOfSections: 7,
				NumberOfSymbols:  10,
				EntryPoint:       "0x20110",
				ImageBase:        "0x140000000",
				LinkTime:         time.Now(),
				Sections: []pex.Sec{
					{Name: ".text", Size: 132608, Entropy: 6.368381, Md5: "db23dce3911a42e987041d98abd4f7cd"},
					{Name: ".rdata", Size: 35840, Entropy: 5.996976, Md5: "ffa5c960b421ca9887e54966588e97e8"},
				},
				Symbols:          []string{"SelectObject", "GetTextFaceW", "EnumFontsW", "TextOutW", "GetProcessHeap"},
				Imports:          []string{"GDI32.dll", "USER32.dll", "msvcrt.dll", "api-ms-win-core-libraryloader-l1-2-0.dl"},
				VersionResources: map[string]string{"CompanyName": "Microsoft Corporation", "FileDescription": "Notepad", "FileVersion": "10.0.18362.693"},
			},
		},
	}

	s := evt.MarshalRaw()
	clone, err := NewFromCapture(s, capver.EvtSecV2)
	require.NoError(t, err)
	require.NotNil(t, clone)
}

func TestEventMarshalJSONMultiple(t *testing.T) {
	for i := 0; i < 10; i++ {
		seq := uint64(i + 1)
		evt := &Event{
			Type:        CreateFile,
			Tid:         2484,
			PID:         859,
			CPU:         1,
			Seq:         seq,
			Name:        "CreateFile",
			Timestamp:   time.Now(),
			Category:    File,
			Host:        "archrabbit",
			Description: "Creates or opens a new file, directory, I/O device, pipe, console",
			Params: Params{
				params.FileObject:    {Name: params.FileObject, Type: params.Uint64, Value: uint64(12456738026482168384)},
				params.FilePath:      {Name: params.FilePath, Type: params.UnicodeString, Value: "\\Device\\HarddiskVolume2\\Windows\\system32\\user32.dll"},
				params.FileType:      {Name: params.FileType, Type: params.AnsiString, Value: "file"},
				params.FileOperation: {Name: params.FileOperation, Type: params.AnsiString, Value: "open"},
				params.BasePrio:      {Name: params.BasePrio, Type: params.Int8, Value: int8(2)},
				params.PagePrio:      {Name: params.PagePrio, Type: params.Uint8, Value: uint8(2)},
			},
			Metadata: map[MetadataKey]any{"foo": "bar", "fooz": "baarz"},
			PS: &pstypes.PS{
				PID:       2436,
				Ppid:      6304,
				Name:      "firefox.exe",
				Exe:       `C:\Program Files\Mozilla Firefox\firefox.exe`,
				Cmdline:   `C:\Program Files\Mozilla Firefox\firefox.exe -contentproc --channel="6304.3.1055809391\1014207667" -childID 1 -isForBrowser -prefsHandle 2584 -prefMapHandle 2580 -prefsLen 70 -prefMapSize 216993 -parentBuildID 20200107212822 -greomni "C:\Program Files\Mozilla Firefox\omni.ja" -appomni "C:\Program Files\Mozilla Firefox\browser\omni.ja" -appdir "C:\Program Files\Mozilla Firefox\browser" - 6304 "\\.\pipe\gecko-crash-server-pipe.6304" 2596 tab`,
				Cwd:       `C:\Program Files\Mozilla Firefox\`,
				SID:       "archrabbit\\SYSTEM",
				Args:      []string{"-contentproc", `--channel=6304.3.1055809391\1014207667`, "-childID", "1", "-isForBrowser", "-prefsHandle", "2584", "-prefMapHandle", "2580", "-prefsLen", "70", "-prefMapSize", "216993", "-parentBuildID"},
				SessionID: 4,
				Envs:      map[string]string{"ProgramData": "C:\\ProgramData", "COMPUTRENAME": "archrabbit"},
				Threads: map[uint32]pstypes.Thread{
					3453: {Tid: 3453, StartAddress: va.Address(140729524944768), IOPrio: 2, PagePrio: 5, KstackBase: va.Address(18446677035730165760), KstackLimit: va.Address(18446677035730137088), UstackLimit: va.Address(86376448), UstackBase: va.Address(86372352)},
					3455: {Tid: 3455, StartAddress: va.Address(140729524944768), IOPrio: 3, PagePrio: 5, KstackBase: va.Address(18446677035730165760), KstackLimit: va.Address(18446677035730137088), UstackLimit: va.Address(86376448), UstackBase: va.Address(86372352)},
				},
				Handles: []htypes.Handle{
					{Num: windows.Handle(0xffffd105e9baaf70),
						Name:   `\REGISTRY\MACHINE\SYSTEM\ControlSet001\Services\Tcpip\Parameters\Interfaces\{b677c565-6ca5-45d3-b618-736b4e09b036}`,
						Type:   "Key",
						Object: 777488883434455544,
						Pid:    uint32(1023),
					},
					{
						Num:  windows.Handle(0xffffd105e9adaf70),
						Name: `\RPC Control\OLEA61B27E13E028C4EA6C286932E80`,
						Type: "ALPC Port",
						Pid:  uint32(1023),
						MD: &htypes.AlpcPortInfo{
							Seqno:   1,
							Context: 0x0,
							Flags:   0x0,
						},
						Object: 457488883434455544,
					},
					{
						Num:  windows.Handle(0xeaffd105e9adaf30),
						Name: `C:\Users\bunny`,
						Type: "File",
						Pid:  uint32(1023),
						MD: &htypes.FileInfo{
							IsDirectory: true,
						},
						Object: 357488883434455544,
					},
				},
			},
		}
		s := evt.MarshalJSON()
		var newKevt Event
		err := json.Unmarshal(s, &newKevt)
		require.NoError(t, err)

		assert.Equal(t, uint32(2484), newKevt.Tid)
		assert.Equal(t, uint32(859), newKevt.PID)
		assert.Equal(t, seq, newKevt.Seq)
		assert.Len(t, newKevt.PS.Handles, 3)
	}
}

func BenchmarkEventMarshalJSON(b *testing.B) {
	evt := &Event{
		Type:        CreateFile,
		Tid:         2484,
		PID:         859,
		CPU:         1,
		Seq:         2,
		Name:        "CreateFile",
		Timestamp:   time.Now(),
		Category:    File,
		Host:        "archrabbit",
		Description: "Creates or opens a new file, directory, I/O device, pipe, console",
		Params: Params{
			params.FileObject:    {Name: params.FileObject, Type: params.Uint64, Value: uint64(12456738026482168384)},
			params.FilePath:      {Name: params.FilePath, Type: params.UnicodeString, Value: "\\Device\\HarddiskVolume2\\Windows\\system32\\user32.dll"},
			params.FileType:      {Name: params.FileType, Type: params.AnsiString, Value: "file"},
			params.FileOperation: {Name: params.FileOperation, Type: params.AnsiString, Value: "open"},
			params.BasePrio:      {Name: params.BasePrio, Type: params.Int8, Value: int8(2)},
			params.PagePrio:      {Name: params.PagePrio, Type: params.Uint8, Value: uint8(2)},
		},
		Metadata: map[MetadataKey]any{"foo": "bar", "fooz": "baarz"},
		PS: &pstypes.PS{
			PID:       2436,
			Ppid:      6304,
			Name:      "firefox.exe",
			Exe:       `C:\Program Files\Mozilla Firefox\firefox.exe`,
			Cmdline:   `C:\Program Files\Mozilla Firefox\firefox.exe -contentproc --channel="6304.3.1055809391\1014207667" -childID 1 -isForBrowser -prefsHandle 2584 -prefMapHandle 2580 -prefsLen 70 -prefMapSize 216993 -parentBuildID 20200107212822 -greomni "C:\Program Files\Mozilla Firefox\omni.ja" -appomni "C:\Program Files\Mozilla Firefox\browser\omni.ja" -appdir "C:\Program Files\Mozilla Firefox\browser" - 6304 "\\.\pipe\gecko-crash-server-pipe.6304" 2596 tab`,
			Cwd:       `C:\Program Files\Mozilla Firefox\`,
			SID:       "archrabbit\\SYSTEM",
			Args:      []string{"-contentproc", `--channel=6304.3.1055809391\1014207667`, "-childID", "1", "-isForBrowser", "-prefsHandle", "2584", "-prefMapHandle", "2580", "-prefsLen", "70", "-prefMapSize", "216993", "-parentBuildID"},
			SessionID: 4,
			Envs:      map[string]string{"ProgramData": "C:\\ProgramData", "COMPUTRENAME": "archrabbit"},
			Handles: []htypes.Handle{
				{Num: windows.Handle(0xffffd105e9baaf70),
					Name:   `\REGISTRY\MACHINE\SYSTEM\ControlSet001\Services\Tcpip\Parameters\Interfaces\{b677c565-6ca5-45d3-b618-736b4e09b036}`,
					Type:   "Key",
					Object: 777488883434455544,
					Pid:    uint32(1023),
				},
				{
					Num:  windows.Handle(0xffffd105e9adaf70),
					Name: `\RPC Control\OLEA61B27E13E028C4EA6C286932E80`,
					Type: "ALPC Port",
					Pid:  uint32(1023),
					MD: &htypes.AlpcPortInfo{
						Seqno:   1,
						Context: 0x0,
						Flags:   0x0,
					},
					Object: 457488883434455544,
				},
				{
					Num:  windows.Handle(0xeaffd105e9adaf30),
					Name: `C:\Users\bunny`,
					Type: "File",
					Pid:  uint32(1023),
					MD: &htypes.FileInfo{
						IsDirectory: true,
					},
					Object: 357488883434455544,
				},
			},
			PE: &pex.PE{
				NumberOfSections: 2,
				NumberOfSymbols:  10,
				EntryPoint:       "0x20110",
				ImageBase:        "0x140000000",
				LinkTime:         time.Now(),
				Sections: []pex.Sec{
					{Name: ".text", Size: 132608, Entropy: 6.368381, Md5: "db23dce3911a42e987041d98abd4f7cd"},
					{Name: ".rdata", Size: 35840, Entropy: 5.996976, Md5: "ffa5c960b421ca9887e54966588e97e8"},
				},
				Symbols:          []string{"SelectObject", "GetTextFaceW", "EnumFontsW", "TextOutW", "GetProcessHeap"},
				Imports:          []string{"GDI32.dll", "USER32.dll", "msvcrt.dll", "api-ms-win-core-libraryloader-l1-2-0.dl"},
				VersionResources: map[string]string{"CompanyName": "Microsoft Corporation", "FileDescription": "Notepad", "FileVersion": "10.0.18362.693"},
			},
		},
	}
	b.ReportAllocs()
	for i := 0; i < b.N; i++ {
		evt.MarshalJSON()
	}
}

func BenchmarkEventMarshalJSONStdlib(b *testing.B) {
	evt := &Event{
		Type:        CreateFile,
		Tid:         2484,
		PID:         859,
		CPU:         1,
		Seq:         2,
		Name:        "CreateFile",
		Timestamp:   time.Now(),
		Category:    File,
		Host:        "archrabbit",
		Description: "Creates or opens a new file, directory, I/O device, pipe, console",
		Params: Params{
			params.FileObject:    {Name: params.FileObject, Type: params.Uint64, Value: uint64(12456738026482168384)},
			params.FilePath:      {Name: params.FilePath, Type: params.UnicodeString, Value: "\\Device\\HarddiskVolume2\\Windows\\system32\\user32.dll"},
			params.FileType:      {Name: params.FileType, Type: params.AnsiString, Value: "file"},
			params.FileOperation: {Name: params.FileOperation, Type: params.AnsiString, Value: "open"},
			params.BasePrio:      {Name: params.BasePrio, Type: params.Int8, Value: int8(2)},
			params.PagePrio:      {Name: params.PagePrio, Type: params.Uint8, Value: uint8(2)},
		},
		Metadata: map[MetadataKey]any{"foo": "bar", "fooz": "baarz"},
		PS: &pstypes.PS{
			PID:       2436,
			Ppid:      6304,
			Name:      "firefox.exe",
			Exe:       `C:\Program Files\Mozilla Firefox\firefox.exe`,
			Cmdline:   `C:\Program Files\Mozilla Firefox\firefox.exe -contentproc --channel="6304.3.1055809391\1014207667" -childID 1 -isForBrowser -prefsHandle 2584 -prefMapHandle 2580 -prefsLen 70 -prefMapSize 216993 -parentBuildID 20200107212822 -greomni "C:\Program Files\Mozilla Firefox\omni.ja" -appomni "C:\Program Files\Mozilla Firefox\browser\omni.ja" -appdir "C:\Program Files\Mozilla Firefox\browser" - 6304 "\\.\pipe\gecko-crash-server-pipe.6304" 2596 tab`,
			Cwd:       `C:\Program Files\Mozilla Firefox\`,
			SID:       "archrabbit\\SYSTEM",
			Args:      []string{"-contentproc", `--channel=6304.3.1055809391\1014207667`, "-childID", "1", "-isForBrowser", "-prefsHandle", "2584", "-prefMapHandle", "2580", "-prefsLen", "70", "-prefMapSize", "216993", "-parentBuildID"},
			SessionID: 4,
			Envs:      map[string]string{"ProgramData": "C:\\ProgramData", "COMPUTRENAME": "archrabbit"},
			Handles: []htypes.Handle{
				{Num: windows.Handle(0xffffd105e9baaf70),
					Name:   `\REGISTRY\MACHINE\SYSTEM\ControlSet001\Services\Tcpip\Parameters\Interfaces\{b677c565-6ca5-45d3-b618-736b4e09b036}`,
					Type:   "Key",
					Object: 777488883434455544,
					Pid:    uint32(1023),
				},
				{
					Num:  windows.Handle(0xffffd105e9adaf70),
					Name: `\RPC Control\OLEA61B27E13E028C4EA6C286932E80`,
					Type: "ALPC Port",
					Pid:  uint32(1023),
					MD: &htypes.AlpcPortInfo{
						Seqno:   1,
						Context: 0x0,
						Flags:   0x0,
					},
					Object: 457488883434455544,
				},
				{
					Num:  windows.Handle(0xeaffd105e9adaf30),
					Name: `C:\Users\bunny`,
					Type: "File",
					Pid:  uint32(1023),
					MD: &htypes.FileInfo{
						IsDirectory: true,
					},
					Object: 357488883434455544,
				},
			},
			PE: &pex.PE{
				NumberOfSections: 2,
				NumberOfSymbols:  10,
				EntryPoint:       "0x20110",
				ImageBase:        "0x140000000",
				LinkTime:         time.Now(),
				Sections: []pex.Sec{
					{Name: ".text", Size: 132608, Entropy: 6.368381, Md5: "db23dce3911a42e987041d98abd4f7cd"},
					{Name: ".rdata", Size: 35840, Entropy: 5.996976, Md5: "ffa5c960b421ca9887e54966588e97e8"},
				},
				Symbols:          []string{"SelectObject", "GetTextFaceW", "EnumFontsW", "TextOutW", "GetProcessHeap"},
				Imports:          []string{"GDI32.dll", "USER32.dll", "msvcrt.dll", "api-ms-win-core-libraryloader-l1-2-0.dl"},
				VersionResources: map[string]string{"CompanyName": "Microsoft Corporation", "FileDescription": "Notepad", "FileVersion": "10.0.18362.693"},
			},
		},
	}
	b.ReportAllocs()
	for i := 0; i < b.N; i++ {
		if _, err := json.Marshal(evt); err != nil {
			b.Fatal(err)
		}
	}
}

func BenchmarkMarshal(b *testing.B) {
	evt := &Event{
		Type:        CreateFile,
		Tid:         2484,
		PID:         859,
		CPU:         1,
		Seq:         2,
		Name:        "CreateFile",
		Timestamp:   time.Now(),
		Category:    File,
		Host:        "archrabbit",
		Description: "Creates or opens a new file, directory, I/O device, pipe, console",
		Params: Params{
			params.FileObject:    {Name: params.FileObject, Type: params.Uint64, Value: uint64(12456738026482168384)},
			params.FilePath:      {Name: params.FilePath, Type: params.UnicodeString, Value: "\\Device\\HarddiskVolume2\\Windows\\system32\\user32.dll"},
			params.FileType:      {Name: params.FileType, Type: params.AnsiString, Value: "file"},
			params.FileOperation: {Name: params.FileOperation, Type: params.AnsiString, Value: "open"},
		},
		Metadata: map[MetadataKey]any{"foo": "bar", "fooz": "barz"},
	}
	b.ReportAllocs()
	for i := 0; i < b.N; i++ {
		if buf := evt.MarshalRaw(); len(buf) == 0 {
			b.Fatal("empty buffer")
		}
	}
}

func BenchmarkUnmarshal(b *testing.B) {
	evt := &Event{
		Type:        CreateFile,
		Tid:         2484,
		PID:         859,
		CPU:         1,
		Seq:         2,
		Name:        "CreateFile",
		Timestamp:   time.Now(),
		Category:    File,
		Host:        "archrabbit",
		Description: "Creates or opens a new file, directory, I/O device, pipe, console",
		Params: Params{
			params.FileObject:    {Name: params.FileObject, Type: params.Uint64, Value: uint64(12456738026482168384)},
			params.FilePath:      {Name: params.FilePath, Type: params.UnicodeString, Value: "\\Device\\HarddiskVolume2\\Windows\\system32\\user32.dll"},
			params.FileType:      {Name: params.FileType, Type: params.AnsiString, Value: "file"},
			params.FileOperation: {Name: params.FileOperation, Type: params.AnsiString, Value: "open"},
		},
		Metadata: map[MetadataKey]any{"foo": "bar", "fooz": "barz"},
	}
	buf := evt.MarshalRaw()
	b.ReportAllocs()
	for i := 0; i < b.N; i++ {
		ke, err := NewFromCapture(buf, capver.EvtSecV2)
		if err != nil {
			b.Fatal(err)
		}
		if ke.Name == "" {
			b.Fatal("invalid unmarshal byte slice")
		}
	}
}

```

`pkg/event/marshaller_windows.go`:

```go
/*
 * Copyright 2020-2021 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package event

import (
	"expvar"
	"fmt"
	"github.com/rabbitstack/fibratus/pkg/util/convert"
	"github.com/rabbitstack/fibratus/pkg/util/va"
	"math"
	"net"
	"sort"
	"time"
	"unsafe"

	"github.com/rabbitstack/fibratus/pkg/cap/section"
	capver "github.com/rabbitstack/fibratus/pkg/cap/version"
	"github.com/rabbitstack/fibratus/pkg/event/params"
	ptypes "github.com/rabbitstack/fibratus/pkg/ps/types"
	"github.com/rabbitstack/fibratus/pkg/util/bytes"
	"github.com/rabbitstack/fibratus/pkg/util/ip"
)

var (
	// SerializeHandles indicates if handles are serialized as part of the process state
	SerializeHandles bool
	// SerializeThreads indicates if threads are serialized as part of the process state
	SerializeThreads bool
	// SerializeImages indicates if images are serialized as part of the process state
	SerializeImages bool
	// SerializePE indicates if PE metadata are serialized as part of the process state
	SerializePE bool
	// SerializeEnvs indicates if the environment variables are serialized as part of the process state
	SerializeEnvs bool
)

// unmarshalTimestampErrors counts timestamp unmarshal errors
var unmarshalTimestampErrors = expvar.NewInt("event.timestamp.unmarshal.errors")

// MarshalRaw produces a byte stream of the kernel event suitable for writing to disk.
func (e *Event) MarshalRaw() []byte {
	b := make([]byte, 0)

	// write seq, pid, tid fields
	b = append(b, bytes.WriteUint64(e.Seq)...)
	b = append(b, bytes.WriteUint32(e.PID)...)
	b = append(b, bytes.WriteUint32(e.Tid)...)

	// write type and CPU
	b = append(b, e.Type[:]...)
	b = append(b, e.CPU)

	// for the string fields we have to write the length prior to
	// the string buffer itself, so we can decode the string correctly
	//
	// write event name
	b = append(b, bytes.WriteUint16(uint16(len(e.Name)))...)
	b = append(b, e.Name...)
	// write category
	b = append(b, bytes.WriteUint16(uint16(len(e.Category)))...)
	b = append(b, e.Category...)
	// write description
	b = append(b, bytes.WriteUint16(uint16(len(e.Description)))...)
	b = append(b, e.Description...)
	// write host name
	b = append(b, bytes.WriteUint16(uint16(len(e.Host)))...)
	b = append(b, e.Host...)

	// write event's timestamp
	timestamp := make([]byte, 0)
	timestamp = e.Timestamp.AppendFormat(timestamp, time.RFC3339Nano)
	b = append(b, bytes.WriteUint16(uint16(len(timestamp)))...)
	b = append(b, timestamp...)

	// write the number of event parameters followed by each parameter
	b = append(b, bytes.WriteUint16(uint16(len(e.Params)))...)
	for _, par := range e.Params {
		// append the type, parameter size and name
		b = append(b, bytes.WriteUint16(uint16(par.CaptureType()))...)
		b = append(b, bytes.WriteUint16(uint16(len(par.Name)))...)
		b = append(b, par.Name...)
		switch par.Type {
		case params.AnsiString, params.UnicodeString:
			b = append(b, bytes.WriteUint16(uint16(len(par.Value.(string))))...)
			b = append(b, par.Value.(string)...)
		case params.Key, params.Path, params.DOSPath, params.HandleType:
			v := e.GetParamAsString(par.Name)
			b = append(b, bytes.WriteUint16(uint16(len(v)))...)
			b = append(b, v...)
		case params.Uint8:
			b = append(b, par.Value.(uint8))
		case params.Int8:
			b = append(b, byte(par.Value.(int8)))
		case params.Uint16, params.Port:
			b = append(b, bytes.WriteUint16(par.Value.(uint16))...)
		case params.Int16:
			b = append(b, bytes.WriteUint16(uint16(par.Value.(int16)))...)
		case params.Uint32, params.Status, params.Enum, params.Flags:
			b = append(b, bytes.WriteUint32(par.Value.(uint32))...)
		case params.Int32:
			b = append(b, bytes.WriteUint32(uint32(par.Value.(int32)))...)
		case params.Uint64, params.Address, params.Flags64:
			b = append(b, bytes.WriteUint64(par.Value.(uint64))...)
		case params.Int64:
			b = append(b, bytes.WriteUint64(uint64(par.Value.(int64)))...)
		case params.Double:
			b = append(b, bytes.WriteUint32(math.Float32bits(par.Value.(float32)))...)
		case params.Float:
			b = append(b, bytes.WriteUint64(math.Float64bits(par.Value.(float64)))...)
		case params.IPv4:
			b = append(b, par.Value.(net.IP).To4()...)
		case params.IPv6:
			b = append(b, par.Value.(net.IP).To16()...)
		case params.PID, params.TID:
			b = append(b, bytes.WriteUint32(par.Value.(uint32))...)
		case params.Bool:
			b = append(b, convert.Btoi(par.Value.(bool)))
		case params.Time:
			v := par.Value.(time.Time)
			ts := make([]byte, 0)
			ts = v.AppendFormat(ts, time.RFC3339Nano)
			b = append(b, bytes.WriteUint16(uint16(len(ts)))...)
			b = append(b, ts...)
		case params.Slice:
			switch slice := par.Value.(type) {
			case []string:
				// append the type for slice elements
				b = append(b, uint8('s'))
				b = append(b, bytes.WriteUint16(uint16(len(slice)))...)
				for _, s := range slice {
					b = append(b, bytes.WriteUint16(uint16(len(s)))...)
					b = append(b, s...)
				}
			case []va.Address:
				// 8 byte integers
				b = append(b, uint8('8'))
				b = append(b, bytes.WriteUint16(uint16(len(slice)))...)
				for _, v := range slice {
					b = append(b, bytes.WriteUint64(v.Uint64())...)
				}
			}
		case params.Binary, params.SID, params.WbemSID:
			b = append(b, bytes.WriteUint32(uint32(len(par.Value.([]byte))))...)
			b = append(b, par.Value.([]byte)...)
		}
	}

	// write metadata key/value pairs
	b = append(b, bytes.WriteUint16(uint16(len(e.Metadata)))...)
	for key, value := range e.Metadata {
		b = append(b, bytes.WriteUint16(uint16(len(key)))...)
		b = append(b, key...)
		v := fmt.Sprintf("%s", value)
		b = append(b, bytes.WriteUint16(uint16(len(v)))...)
		b = append(b, v...)
	}

	// write process state
	if e.PS != nil && (e.IsCreateProcess() || e.IsProcessRundown()) {
		buf := e.PS.Marshal()
		sec := section.New(section.Process, capver.ProcessSecV4, 0, uint32(len(buf)))
		b = append(b, sec[:]...)
		b = append(b, buf...)
	} else {
		sec := section.New(section.Process, capver.ProcessSecV4, 0, 0)
		b = append(b, sec[:]...)
	}

	return b
}

func inc(idx, inc uint32) uint32 {
	return idx + inc
}

// UnmarshalRaw recovers the state of the kernel event from the byte stream.
func (e *Event) UnmarshalRaw(b []byte, ver capver.Version) error {
	if len(b) < 34 {
		return fmt.Errorf("expected at least 34 bytes but got %d bytes", len(b))
	}

	// read seq, pid, tid
	e.Seq = bytes.ReadUint64(b[0:])
	e.PID = bytes.ReadUint32(b[8:])
	e.Tid = bytes.ReadUint32(b[12:])

	// read type and CPU
	var typ Type
	// set start index depending
	// on event section version
	var idx uint32
	switch ver {
	case capver.EvtSecV1:
		idx = 33
	case capver.EvtSecV2:
		idx = 34
	}
	copy(typ[:], b[16:idx])
	e.Type = typ
	e.CPU = b[idx : idx+1][0]

	idx++ // increment index
	var offset uint32

	// read event name
	l := bytes.ReadUint16(b[inc(idx, 0):])
	buf := b[inc(idx, 2):]
	offset = uint32(l)
	e.Name = string((*[1<<30 - 1]byte)(unsafe.Pointer(&buf[0]))[:l:l])

	// read category
	l = bytes.ReadUint16(b[inc(idx, 2)+offset:])
	buf = b[inc(idx, 4)+offset:]
	offset += uint32(l)
	e.Category = Category(string((*[1<<30 - 1]byte)(unsafe.Pointer(&buf[0]))[:l:l]))

	// read description
	l = bytes.ReadUint16(b[inc(idx, 4)+offset:])
	buf = b[inc(idx, 6)+offset:]
	offset += uint32(l)
	e.Description = string((*[1<<30 - 1]byte)(unsafe.Pointer(&buf[0]))[:l:l])

	// read host name
	l = bytes.ReadUint16(b[inc(idx, 6)+offset:])
	buf = b[inc(idx, 8)+offset:]
	offset += uint32(l)
	e.Host = string((*[1<<30 - 1]byte)(unsafe.Pointer(&buf[0]))[:l:l])

	// read timestamp
	l = bytes.ReadUint16(b[inc(idx, 8)+offset:])
	buf = b[inc(idx, 10)+offset:]
	offset += uint32(l)
	if len(buf) > 0 {
		var err error
		e.Timestamp, err = time.Parse(time.RFC3339Nano, string((*[1<<30 - 1]byte)(unsafe.Pointer(&buf[0]))[:l:l]))
		if err != nil {
			unmarshalTimestampErrors.Add(1)
		}
	}

	// read parameters
	nparams := bytes.ReadUint16(b[inc(idx, 10)+offset:])
	// accumulates the offset of all parameter name and value lengths
	var poffset uint32

	for i := 0; i < int(nparams); i++ {
		// read Param type
		typ := bytes.ReadUint16(b[inc(idx, 12)+offset+poffset:])
		// read Param name
		kparamNameLength := uint32(bytes.ReadUint16(b[inc(idx, 14)+offset+poffset:]))
		buf = b[inc(idx, 16)+offset+poffset:]
		kparamName := string((*[1<<30 - 1]byte)(unsafe.Pointer(&buf[0]))[:kparamNameLength:kparamNameLength])

		pi := inc(idx, 16) // parameter index

		var val params.Value
		switch params.Type(typ) {
		case params.AnsiString, params.UnicodeString, params.Path:
			// read string parameter
			l := bytes.ReadUint16(b[pi+offset+kparamNameLength+poffset:])
			buf = b[inc(idx, 18)+offset+kparamNameLength+poffset:]
			if len(buf) > 0 {
				val = string((*[1<<30 - 1]byte)(unsafe.Pointer(&buf[0]))[:l:l])
			}
			// increment parameter offset by string by type length + name length bytes + length of
			// the string parameter + string parameter size
			poffset += kparamNameLength + 6 + uint32(l)
		case params.Uint64, params.Address, params.Flags64:
			val = bytes.ReadUint64(b[pi+offset+kparamNameLength+poffset:])
			// increment parameter offset by type length + name length sizes + size of uint64
			poffset += kparamNameLength + 4 + 8
		case params.Int64:
			val = int64(bytes.ReadUint64(b[pi+offset+kparamNameLength+poffset:]))
			// increment parameter offset by type length + name length sizes + size of int64
			poffset += kparamNameLength + 4 + 8
		case params.Double:
			val = float64(bytes.ReadUint64(b[pi+offset+kparamNameLength+poffset:]))
			poffset += kparamNameLength + 4 + 8
		case params.Float:
			val = float32(bytes.ReadUint32(b[pi+offset+kparamNameLength+poffset:]))
			poffset += kparamNameLength + 4 + 4
		case params.IPv4:
			val = ip.ToIPv4(bytes.ReadUint32(b[pi+offset+kparamNameLength+poffset:]))
			// // increment by IPv4 length
			poffset += kparamNameLength + 4 + 4
		case params.IPv6:
			val = ip.ToIPv6(b[pi+offset+kparamNameLength+poffset : pi+offset+kparamNameLength+poffset+16])
			// increment by IPv6 length
			poffset += kparamNameLength + 4 + 16
		case params.PID, params.TID:
			val = bytes.ReadUint32(b[pi+offset+kparamNameLength+poffset:])
			poffset += kparamNameLength + 4 + 4
		case params.Int32:
			val = int32(bytes.ReadUint32(b[pi+offset+kparamNameLength+poffset:]))
			poffset += kparamNameLength + 4 + 4
		case params.Uint32, params.Enum, params.Flags, params.Status:
			val = bytes.ReadUint32(b[pi+offset+kparamNameLength+poffset:])
			poffset += kparamNameLength + 4 + 4
		case params.Uint16, params.Port:
			val = bytes.ReadUint16(b[pi+offset+kparamNameLength+poffset:])
			poffset += kparamNameLength + 4 + 2
		case params.Int16:
			val = int16(bytes.ReadUint16(b[pi+offset+kparamNameLength+poffset:]))
			poffset += kparamNameLength + 4 + 2
		case params.Uint8:
			val = b[pi+offset+kparamNameLength+poffset : pi+offset+kparamNameLength+poffset+1][0]
			poffset += kparamNameLength + 4 + 1
		case params.Int8:
			val = int8(b[pi+offset+kparamNameLength+poffset : pi+offset+kparamNameLength+poffset+1][0])
			poffset += kparamNameLength + 4 + 1
		case params.Bool:
			v := b[pi+offset+kparamNameLength+poffset : pi+offset+kparamNameLength+poffset+1][0]
			if v == 1 {
				val = true
			} else {
				val = false
			}
			poffset += kparamNameLength + 4 + 1
		case params.Time:
			// read ts length
			l := bytes.ReadUint16(b[pi+offset+kparamNameLength+poffset:])
			buf = b[inc(idx, 18)+offset+kparamNameLength+poffset:]
			if len(buf) > 0 {
				var err error
				val, err = time.Parse(time.RFC3339Nano, string((*[1<<30 - 1]byte)(unsafe.Pointer(&buf[0]))[:l:l]))
				if err != nil {
					unmarshalTimestampErrors.Add(1)
				}
			}
			poffset += kparamNameLength + 6 + uint32(l)
		case params.Slice:
			// read slice element type
			typ := b[pi+offset+kparamNameLength+poffset]
			// read slice size
			l := bytes.ReadUint16(b[inc(idx, 17)+offset+kparamNameLength+poffset:])
			var off uint32
			switch typ {
			case 's':
				s := make([]string, l)
				for i := 0; i < int(l); i++ {
					size := bytes.ReadUint16(b[inc(idx, 19)+offset+kparamNameLength+poffset+off:])
					buf := b[inc(idx, 22)+offset+kparamNameLength+poffset+off:]
					s[i] = string((*[1<<30 - 1]byte)(unsafe.Pointer(&buf[0]))[:size:size])
					off += 2 + uint32(size)
				}
				val = s
			case '8':
				v := make([]uint64, l)
				for i := 0; i < int(l); i++ {
					bytes.ReadUint64(b[inc(idx, 22)+offset+kparamNameLength+poffset+off:])
					off += 8
				}
				val = v
			}
			poffset += kparamNameLength + 4 + 1 + 2 + off
		case params.Binary, params.SID, params.WbemSID:
			l := bytes.ReadUint32(b[pi+offset+kparamNameLength+poffset:])
			buf = b[inc(idx, 18)+offset+kparamNameLength+poffset:]
			if len(buf) > 0 {
				val = buf[:l]
			}
			poffset += kparamNameLength + 8 + l
		}

		if val != nil {
			e.Params.AppendFromCapture(kparamName, params.Type(typ), val, e.Type)
		}
	}

	offset += poffset

	// read metadata tags
	ntags := bytes.ReadUint16(b[inc(idx, 12)+offset:])
	var moffset uint32
	for i := 0; i < int(ntags); i++ {
		// read key
		klen := uint32(bytes.ReadUint16(b[inc(idx, 14)+offset+moffset:]))
		buf = b[inc(idx, 16)+offset+moffset:]
		key := string((*[1<<30 - 1]byte)(unsafe.Pointer(&buf[0]))[:klen:klen])
		// read value
		vlen := uint32(bytes.ReadUint16(b[inc(idx, 16)+offset+klen+moffset:]))
		buf = b[inc(idx, 18)+offset+klen+moffset:]
		value := string((*[1<<30 - 1]byte)(unsafe.Pointer(&buf[0]))[:vlen:vlen])
		// increment the offset by the length of the key + length value + size of uint16 * 2
		// that corresponds to bytes storing the lengths of keys/values
		moffset += klen + vlen + 4
		if key != "" {
			e.AddMeta(MetadataKey(key), value)
		}
	}

	offset += moffset

	// read process state
	sec := section.Read(b[inc(idx, 14)+offset:])
	if sec.Size() != 0 {
		ps, err := ptypes.NewFromCapture(b[inc(idx, 24)+offset:], sec)
		if err != nil {
			return err
		}
		e.PS = ps
	}

	return nil
}

var js = newJSONStream()

func writePsResources() bool {
	return SerializeHandles || SerializeThreads || SerializeImages || SerializePE
}

// MarshalJSON produces a JSON payload for this event.
func (e *Event) MarshalJSON() []byte {
	if e == nil {
		return []byte{}
	}

	// start of JSON
	js.writeObjectStart()

	js.writeObjectField("seq").writeUint64(e.Seq).writeMore()
	js.writeObjectField("pid").writeUint32(e.PID).writeMore()
	js.writeObjectField("tid").writeUint32(e.Tid).writeMore()
	js.writeObjectField("cpu").writeUint8(e.CPU).writeMore()

	js.writeObjectField("name").writeString(e.Name).writeMore()
	js.writeObjectField("category").writeString(string(e.Category)).writeMore()
	js.writeObjectField("description").writeString(e.Description).writeMore()
	js.writeObjectField("host").writeString(e.Host).writeMore()

	timestamp := make([]byte, 0)
	timestamp = e.Timestamp.AppendFormat(timestamp, time.RFC3339Nano)
	js.writeObjectField("timestamp").writeString(string(timestamp)).writeMore()

	// start params
	js.writeObjectField("params")
	js.writeObjectStart()

	pars := make([]*Param, 0, len(e.Params))
	for _, par := range e.Params {
		pars = append(pars, par)
	}
	sort.Slice(pars, func(i, j int) bool { return pars[i].Name < pars[j].Name })

	for i, par := range pars {
		writeMore := js.shouldWriteMore(i, len(pars))
		js.writeObjectField(par.Name)
		switch par.Type {
		case params.Int64:
			js.writeInt64(par.Value.(int64))
		case params.Uint64:
			js.writeUint64(par.Value.(uint64))
		case params.Int32:
			js.writeInt32(par.Value.(int32))
		case params.Uint32:
			js.writeUint32(par.Value.(uint32))
		case params.Int16:
			js.writeInt16(par.Value.(int16))
		case params.Uint16, params.Port:
			js.writeUint16(par.Value.(uint16))
		case params.Int8:
			js.writeInt8(par.Value.(int8))
		case params.Uint8:
			js.writeUint8(par.Value.(uint8))
		case params.Float:
			js.writeFloat32(par.Value.(float32))
		case params.Double:
			js.writeFloat64(par.Value.(float64))
		case params.PID, params.TID:
			js.writeUint32(par.Value.(uint32))
		case params.IPv4, params.IPv6:
			js.writeString(par.Value.(net.IP).String())
		case params.Bool:
			js.writeBool(par.Value.(bool))
		case params.Time:
			js.writeString(par.Value.(time.Time).String())
		case params.Slice:
			switch slice := par.Value.(type) {
			case []string:
				js.writeArrayStart()
				for i, s := range slice {
					writeMore := js.shouldWriteMore(i, len(slice))
					js.writeEscapeString(s)
					if writeMore {
						js.writeMore()
					}
				}
				js.writeArrayEnd()
			}
		default:
			js.writeEscapeString(e.GetParamAsString(par.Name))
		}
		if writeMore {
			js.writeMore()
		}
	}
	// end params
	js.writeObjectEnd().writeMore()

	// start metadata
	js.writeObjectField("meta")
	js.writeObjectStart()
	var i int
	for k, v := range e.Metadata {
		writeMore := js.shouldWriteMore(i, len(e.Metadata))
		js.writeObjectField(k.String()).writeEscapeString(fmt.Sprintf("%s", v))
		if writeMore {
			js.writeMore()
		}
		i++
	}

	// end metadata
	js.writeObjectEnd()
	ps := e.PS
	if ps != nil {
		js.writeMore()
	}

	// start process state
	if ps != nil {
		js.writeObjectField("ps")
		js.writeObjectStart()

		js.writeObjectField("pid").writeUint32(ps.PID).writeMore()
		js.writeObjectField("ppid").writeUint32(ps.Ppid).writeMore()
		js.writeObjectField("name").writeString(ps.Name).writeMore()
		js.writeObjectField("cmdline").writeEscapeString(ps.Cmdline).writeMore()
		js.writeObjectField("exe").writeEscapeString(ps.Exe).writeMore()
		js.writeObjectField("cwd").writeEscapeString(ps.Cwd).writeMore()
		js.writeObjectField("sid").writeEscapeString(ps.SID).writeMore()

		js.writeObjectField("args")
		js.writeArrayStart()
		for i, arg := range ps.Args {
			writeMore := js.shouldWriteMore(i, len(ps.Args))
			js.writeEscapeString(arg)
			if writeMore {
				js.writeMore()
			}
		}
		js.writeArrayEnd().writeMore()

		js.writeObjectField("sessionid").writeUint32(ps.SessionID)

		parent := ps.Parent
		if parent != nil {
			js.writeMore()
			js.writeObjectField("parent")
			js.writeObjectStart()

			js.writeObjectField("name").writeString(parent.Name).writeMore()
			js.writeObjectField("cmdline").writeEscapeString(parent.Cmdline).writeMore()
			js.writeObjectField("exe").writeEscapeString(parent.Exe).writeMore()
			js.writeObjectField("cwd").writeEscapeString(parent.Cwd).writeMore()
			js.writeObjectField("sid").writeEscapeString(parent.SID)

			js.writeObjectEnd()
		}

		if SerializeEnvs {
			js.writeMore()
			js.writeObjectField("envs")
			js.writeObjectStart()
			var i int
			for k, v := range ps.Envs {
				writeMore := js.shouldWriteMore(i, len(ps.Envs))
				js.writeObjectField(k).writeEscapeString(v)
				if writeMore {
					js.writeMore()
				}
				i++
			}
			js.writeObjectEnd()
		}

		if writePsResources() {
			js.writeMore()
		}

		if SerializeThreads {
			// start threads
			js.writeObjectField("threads")
			js.writeArrayStart()
			var i int
			ps.RLock()
			for _, thread := range ps.Threads {
				writeMore := js.shouldWriteMore(i, len(ps.Threads))
				js.writeObjectStart()
				js.writeObjectField("tid").writeUint32(thread.Tid).writeMore()
				js.writeObjectField("ioprio").writeUint8(thread.IOPrio).writeMore()
				js.writeObjectField("baseprio").writeUint8(thread.BasePrio).writeMore()
				js.writeObjectField("pageprio").writeUint8(thread.PagePrio).writeMore()
				js.writeObjectField("start_address").writeString(thread.StartAddress.String()).writeMore()
				js.writeObjectField("ustack_base").writeString(thread.UstackBase.String()).writeMore()
				js.writeObjectField("ustack_limit").writeString(thread.UstackLimit.String()).writeMore()
				js.writeObjectField("kstack_base").writeString(thread.KstackBase.String()).writeMore()
				js.writeObjectField("kstack_limit").writeString(thread.KstackLimit.String())
				js.writeObjectEnd()
				if writeMore {
					js.writeMore()
				}
				i++
			}
			ps.RUnlock()
			// end threads
			js.writeArrayEnd()
			if SerializeImages || SerializeHandles {
				js.writeMore()
			}
		}

		if SerializeImages {
			// start modules
			js.writeObjectField("modules")
			js.writeArrayStart()

			for i, m := range ps.Modules {
				writeMore := js.shouldWriteMore(i, len(ps.Modules))
				js.writeObjectStart()
				js.writeObjectField("name").writeEscapeString(m.Name).writeMore()
				js.writeObjectField("size").writeUint64(m.Size)
				js.writeObjectEnd()
				if writeMore {
					js.writeMore()
				}
			}

			// end modules
			js.writeArrayEnd()
			if SerializeHandles {
				js.writeMore()
			}
		}

		if SerializeHandles {
			// start handles
			js.writeObjectField("handles")
			js.writeArrayStart()

			for i, handle := range ps.Handles {
				writeMore := js.shouldWriteMore(i, len(ps.Handles))
				js.writeObjectStart()
				js.writeObjectField("name").writeEscapeString(handle.Name).writeMore()
				js.writeObjectField("type").writeString(handle.Type).writeMore()
				js.writeObjectField("id").writeUint64(uint64(handle.Num)).writeMore()
				js.writeObjectField("object").writeEscapeString(va.Address(handle.Object).String())
				js.writeObjectEnd()

				if writeMore {
					js.writeMore()
				}
			}
			// end handles
			js.writeArrayEnd()
			if SerializePE && ps.PE != nil {
				js.writeMore()
			}
		}

		pe := ps.PE
		if SerializePE && pe != nil {
			// start PE
			js.writeObjectField("pe")
			js.writeObjectStart()

			js.writeObjectField("nsections").writeUint16(pe.NumberOfSections).writeMore()
			js.writeObjectField("nsymbols").writeUint32(pe.NumberOfSymbols).writeMore()
			js.writeObjectField("image_base").writeString(pe.ImageBase).writeMore()
			js.writeObjectField("entrypoint").writeString(pe.EntryPoint).writeMore()

			timestamp := make([]byte, 0)
			timestamp = e.Timestamp.AppendFormat(timestamp, time.RFC3339Nano)
			js.writeObjectField("link_time").writeString(string(timestamp)).writeMore()

			// sections
			if len(pe.Sections) > 0 {
				js.writeObjectField("sections")
				js.writeArrayStart()

				for i, sec := range pe.Sections {
					writeMore := js.shouldWriteMore(i, len(pe.Sections))
					js.writeObjectStart()
					js.writeObjectField("name").writeEscapeString(sec.Name).writeMore()
					js.writeObjectField("size").writeUint32(sec.Size).writeMore()
					js.writeObjectField("entropy").writeFloat64(sec.Entropy).writeMore()
					js.writeObjectField("md5").writeString(sec.Md5)

					js.writeObjectEnd()
					if writeMore {
						js.writeMore()
					}
				}

				js.writeArrayEnd()
				if len(pe.Symbols) > 0 {
					js.writeMore()
				}
			}

			// imported symbols
			if len(pe.Symbols) > 0 {
				js.writeObjectField("symbols")
				js.writeArrayStart()

				for i, sym := range pe.Symbols {
					writeMore := js.shouldWriteMore(i, len(pe.Symbols))
					js.writeEscapeString(sym)

					if writeMore {
						js.writeMore()
					}
				}

				js.writeArrayEnd()
				if len(pe.Imports) > 0 {
					js.writeMore()
				}
			}

			// imports
			if len(pe.Imports) > 0 {
				js.writeObjectField("imports")
				js.writeArrayStart()

				for i, imp := range pe.Imports {
					writeMore := js.shouldWriteMore(i, len(pe.Imports))
					js.writeEscapeString(imp)

					if writeMore {
						js.writeMore()
					}
				}

				js.writeArrayEnd()
				if len(pe.VersionResources) > 0 {
					js.writeMore()
				}
			}

			// version resources
			if len(pe.VersionResources) > 0 {
				js.writeObjectField("resources")
				js.writeObjectStart()

				var i int
				for k, v := range pe.VersionResources {
					writeMore := js.shouldWriteMore(i, len(pe.VersionResources))
					js.writeObjectField(k).writeEscapeString(v)

					if writeMore {
						js.writeMore()
					}
					i++
				}
				js.writeObjectEnd()
			}

			// end PE
			js.writeObjectEnd()
		}

		// end process state
		js.writeObjectEnd()
	}

	// end of JSON
	js.writeObjectEnd()

	return js.flush()
}

```

`pkg/event/metainfo_windows.go`:

```go
/*
 * Copyright 2019-2020 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package event

import (
	"cmp"
	"slices"
)

// Info describes the event meta info such as human-readable name, category and description.
type Info struct {
	// Name is the human-readable representation of the event (e.g. CreateProcess, DeleteFile).
	Name string
	// Category designates the category to which event pertains. (e.g. process, net)
	Category Category
	// Description is the short explanation that describes the purpose of the event.
	Description string
}

var events = map[Type]Info{
	CreateProcess:            {"CreateProcess", Process, "Creates a new process and its primary thread"},
	TerminateProcess:         {"TerminateProcess", Process, "Terminates the process and all of its threads"},
	OpenProcess:              {"OpenProcess", Process, "Opens the process handle"},
	CreateThread:             {"CreateThread", Thread, "Creates a thread to execute within the virtual address space of the calling process"},
	TerminateThread:          {"TerminateThread", Thread, "Terminates a thread within the process"},
	OpenThread:               {"OpenThread", Thread, "Opens the thread handle"},
	SetThreadContext:         {"SetThreadContext", Thread, "Sets the thread context"},
	ReadFile:                 {"ReadFile", File, "Reads data from the file or I/O device"},
	WriteFile:                {"WriteFile", File, "Writes data to the file or I/O device"},
	CreateFile:               {"CreateFile", File, "Creates or opens a file or I/O device"},
	CloseFile:                {"CloseFile", File, "Closes the file handle"},
	DeleteFile:               {"DeleteFile", File, "Removes the file from the file system"},
	RenameFile:               {"RenameFile", File, "Changes the file name"},
	SetFileInformation:       {"SetFileInformation", File, "Sets the file meta information"},
	EnumDirectory:            {"EnumDirectory", File, "Enumerates a directory or dispatches a directory change notification to registered listeners"},
	RegCreateKey:             {"RegCreateKey", Registry, "Creates a registry key or opens it if the key already exists"},
	RegOpenKey:               {"RegOpenKey", Registry, "Opens the registry key"},
	RegCloseKey:              {"RegCloseKey", Registry, "Closes the registry key"},
	RegSetValue:              {"RegSetValue", Registry, "Sets the data for the value of a registry key"},
	RegQueryValue:            {"RegQueryValue", Registry, "Reads the data for the value of a registry key"},
	RegQueryKey:              {"RegQueryKey", Registry, "Enumerates subkeys of the parent key"},
	RegDeleteKey:             {"RegDeleteKey", Registry, "Removes the registry key"},
	RegDeleteValue:           {"RegDeleteValue", Registry, "Removes the registry value"},
	AcceptTCPv4:              {"Accept", Net, "Accepts the connection request from the socket queue"},
	AcceptTCPv6:              {"Accept", Net, "Accepts the connection request from the socket queue"},
	SendTCPv4:                {"Send", Net, "Sends data over the wire"},
	SendTCPv6:                {"Send", Net, "Sends data over the wire"},
	SendUDPv4:                {"Send", Net, "Sends data over the wire"},
	SendUDPv6:                {"Send", Net, "Sends data over the wire"},
	RecvTCPv4:                {"Recv", Net, "Receives data from the socket"},
	RecvTCPv6:                {"Recv", Net, "Receives data from the socket"},
	RecvUDPv4:                {"Recv", Net, "Receives data from the socket"},
	RecvUDPv6:                {"Recv", Net, "Receives data from the socket"},
	ConnectTCPv4:             {"Connect", Net, "Connects establishes a connection to the socket"},
	ConnectTCPv6:             {"Connect", Net, "Connects establishes a connection to the socket"},
	DisconnectTCPv4:          {"Disconnect", Net, "Terminates data reception on the socket"},
	DisconnectTCPv6:          {"Disconnect", Net, "Terminates data reception on the socket"},
	ReconnectTCPv4:           {"Reconnect", Net, "Reconnects to the socket"},
	ReconnectTCPv6:           {"Reconnect", Net, "Reconnects to the socket"},
	RetransmitTCPv4:          {"Retransmit", Net, "Retransmits unacknowledged TCP segments"},
	RetransmitTCPv6:          {"Retransmit", Net, "Retransmits unacknowledged TCP segments"},
	LoadImage:                {"LoadImage", Image, "Loads the module into the address space of the calling process"},
	UnloadImage:              {"UnloadImage", Image, "Unloads the module from the address space of the calling process"},
	CreateHandle:             {"CreateHandle", Handle, "Creates a new handle"},
	CloseHandle:              {"CloseHandle", Handle, "Closes the handle"},
	DuplicateHandle:          {"DuplicateHandle", Handle, "Duplicates the handle"},
	VirtualAlloc:             {"VirtualAlloc", Mem, "Reserves, commits, or changes the state of a region of memory within the process virtual address space"},
	VirtualFree:              {"VirtualFree", Mem, "Releases or decommits a region of memory within the process virtual address space"},
	MapViewFile:              {"MapViewFile", File, "Maps a view of a file mapping into the address space of a calling process"},
	UnmapViewFile:            {"UnmapViewFile", File, "Unmaps a mapped view of a file from the calling process's address space"},
	QueryDNS:                 {"QueryDns", Net, "Sends a DNS query to the name server"},
	ReplyDNS:                 {"ReplyDNS", Net, "Receives the response from the DNS server"},
	CreateSymbolicLinkObject: {"CreateSymbolicLinkObject", Object, "Creates the symbolic link within the object manager directory"},
	SubmitThreadpoolWork:     {"SubmitThreadpoolWork", Threadpool, "Enqueues the work item to the thread pool"},
	SubmitThreadpoolCallback: {"SubmitThreadpoolCallback", Threadpool, "Submits the thread pool callback for execution within the work item"},
	SetThreadpoolTimer:       {"SetThreadpoolTimer", Threadpool, "Sets the thread pool timer object"},
}

var types = map[string]Type{
	"CreateProcess":            CreateProcess,
	"TerminateProcess":         TerminateProcess,
	"OpenProcess":              OpenProcess,
	"CreateThread":             CreateThread,
	"TerminateThread":          TerminateThread,
	"OpenThread":               OpenThread,
	"SetThreadContext":         SetThreadContext,
	"LoadImage":                LoadImage,
	"UnloadImage":              UnloadImage,
	"CreateFile":               CreateFile,
	"CloseFile":                CloseFile,
	"ReadFile":                 ReadFile,
	"WriteFile":                WriteFile,
	"SetFileInformation":       SetFileInformation,
	"DeleteFile":               DeleteFile,
	"RenameFile":               RenameFile,
	"EnumDirectory":            EnumDirectory,
	"RegCreateKey":             RegCreateKey,
	"RegOpenKey":               RegOpenKey,
	"RegSetValue":              RegSetValue,
	"RegQueryValue":            RegQueryValue,
	"RegQueryKey":              RegQueryKey,
	"RegDeleteKey":             RegDeleteKey,
	"RegDeleteValue":           RegDeleteValue,
	"RegCloseKey":              RegCloseKey,
	"AcceptTCP4":               AcceptTCPv4,
	"AcceptTCP6":               AcceptTCPv6,
	"SendTCP4":                 SendTCPv4,
	"SendTCP6":                 SendTCPv6,
	"SendUDP4":                 SendUDPv4,
	"SendUDP6":                 SendUDPv6,
	"RecvTCP4":                 RecvTCPv4,
	"RecvTCP6":                 RecvTCPv6,
	"RecvUDP4":                 RecvUDPv4,
	"RecvUDP6":                 RecvUDPv6,
	"ConnectTCP4":              ConnectTCPv4,
	"ConnectTCP6":              ConnectTCPv6,
	"ReconnectTCP4":            ReconnectTCPv4,
	"ReconnectTCP6":            ReconnectTCPv6,
	"DisconnectTCP4":           DisconnectTCPv4,
	"DisconnectTCP6":           DisconnectTCPv6,
	"RetransmitTCP4":           RetransmitTCPv4,
	"RetransmitTCP6":           RetransmitTCPv6,
	"CreateHandle":             CreateHandle,
	"CloseHandle":              CloseHandle,
	"DuplicateHandle":          DuplicateHandle,
	"VirtualAlloc":             VirtualAlloc,
	"VirtualFree":              VirtualFree,
	"MapViewFile":              MapViewFile,
	"UnmapViewFile":            UnmapViewFile,
	"QueryDns":                 QueryDNS,
	"ReplyDns":                 ReplyDNS,
	"CreateSymbolicLinkObject": CreateSymbolicLinkObject,
	"SubmitThreadpoolWork":     SubmitThreadpoolWork,
	"SubmitThreadpoolCallback": SubmitThreadpoolCallback,
	"SetThreadpoolTimer":       SetThreadpoolTimer,
}

// indexedEvents keeps the slice of event infos. When the
// new event type is added, MAKE SURE TO ADD the event info
// at the END of the slice. This way the event index is guaranteed
// to remain static which is important for eventlog message identifiers.
var indexedEvents = []Info{
	events[CreateProcess],
	events[TerminateProcess],
	events[OpenProcess],
	events[CreateThread],
	events[TerminateThread],
	events[OpenThread],
	events[SetThreadContext],
	events[LoadImage],
	events[UnloadImage],
	events[CreateFile],
	events[CloseFile],
	events[ReadFile],
	events[WriteFile],
	events[SetFileInformation],
	events[DeleteFile],
	events[RenameFile],
	events[EnumDirectory],
	events[RegCreateKey],
	events[RegOpenKey],
	events[RegSetValue],
	events[RegQueryValue],
	events[RegQueryKey],
	events[RegDeleteKey],
	events[RegDeleteValue],
	events[AcceptTCPv4],
	events[AcceptTCPv6],
	events[SendTCPv4],
	events[SendTCPv6],
	events[SendUDPv4],
	events[SendUDPv6],
	events[RecvTCPv4],
	events[RecvTCPv6],
	events[RecvUDPv4],
	events[RecvUDPv6],
	events[ConnectTCPv4],
	events[ConnectTCPv6],
	events[ReconnectTCPv4],
	events[ReconnectTCPv6],
	events[DisconnectTCPv4],
	events[DisconnectTCPv6],
	events[RetransmitTCPv4],
	events[RetransmitTCPv6],
	events[CreateHandle],
	events[CloseHandle],
	events[DuplicateHandle],
	events[VirtualAlloc],
	events[VirtualFree],
	events[MapViewFile],
	events[UnmapViewFile],
	events[QueryDNS],
	events[ReplyDNS],
	events[CreateSymbolicLinkObject],
	events[SubmitThreadpoolWork],
	events[SubmitThreadpoolCallback],
	events[SetThreadpoolTimer],
}

// All returns all event types.
func All() []Type {
	s := make([]Type, 0, len(types))
	for _, typ := range types {
		s = append(s, typ)
	}
	return s
}

// AllWithState returns all event types +
// event types used for state management.
func AllWithState() []Type {
	s := All()

	s = append(s, ProcessRundown)
	s = append(s, ThreadRundown)
	s = append(s, ImageRundown)
	s = append(s, FileRundown)
	s = append(s, RegKCBRundown)
	s = append(s, RegCreateKCB)
	s = append(s, RegDeleteKCB)
	s = append(s, FileOpEnd)
	s = append(s, ReleaseFile)
	s = append(s, MapFileRundown)
	s = append(s, StackWalk)
	s = append(s, CreateProcessInternal)
	s = append(s, ProcessRundownInternal)
	s = append(s, LoadImageInternal)
	s = append(s, RegSetValueInternal)

	return s
}

// MaxTypeID returns the maximum event type (hook id) value.
func MaxTypeID() uint16 {
	types := AllWithState()
	ids := make([]uint16, len(types))
	for i, t := range types {
		ids[i] = t.HookID()
	}
	return slices.Max(ids)
}

// TypeToEventInfo maps the event type to the structure storing detailed information about the event.
func TypeToEventInfo(typ Type) Info {
	if info, ok := events[typ]; ok {
		return info
	}
	return Info{Name: "N/A", Category: Unknown}
}

// NameToType converts a human-readable event name to its internal type representation.
func NameToType(name string) Type {
	if typ, ok := types[name]; ok {
		return typ
	}
	return UnknownType
}

// NameToTypes maps the event name to internal type representations, specifically, network
// events that have multiple internal types for a single event name. For example, the Accept
// event name has AcceptTCP4 and AcceptTCP6 types.
func NameToTypes(name string) []Type {
	switch name {
	case "Accept":
		return []Type{AcceptTCPv4, AcceptTCPv6}
	case "Send":
		return []Type{SendTCPv4, SendTCPv6, SendUDPv4, SendUDPv6}
	case "Recv":
		return []Type{RecvTCPv4, RecvTCPv6, RecvUDPv4, RecvUDPv6}
	case "Connect":
		return []Type{ConnectTCPv4, ConnectTCPv6}
	case "Reconnect":
		return []Type{ReconnectTCPv4, ReconnectTCPv6}
	case "Disconnect":
		return []Type{DisconnectTCPv4, DisconnectTCPv6}
	case "Retransmit":
		return []Type{RetransmitTCPv4, RetransmitTCPv6}
	default:
		return []Type{NameToType(name)}
	}
}

// GetTypesMeta returns event types metadata.
func GetTypesMeta() []Info {
	typs := make([]Info, 0)
outer:
	for _, ev := range events {
		for _, typ := range typs {
			if typ.Name == ev.Name {
				continue outer
			}
		}
		typs = append(typs, ev)
	}
	slices.SortFunc(typs, func(a, b Info) int {
		return cmp.Or(cmp.Compare(a.Category, b.Category), cmp.Compare(a.Name, b.Name))
	})
	return typs
}

// IsKnown indicates if the event type is known given the event name.
func IsKnown(name string) bool {
	for _, evt := range GetTypesMeta() {
		if evt.Name == name {
			return true
		}
	}
	return false
}

// GetTypesMetaIndexed returns indexed event types metadata
// that is guaranteed to always return the same event indices.
func GetTypesMetaIndexed() []Info { return indexedEvents }

```

`pkg/event/metainfo_windows_test.go`:

```go
/*
 * Copyright 2019-2020 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package event

import (
	"github.com/stretchr/testify/assert"
	"testing"
)

func TestEventNameToType(t *testing.T) {
	typ := NameToType("CreateProcess")

	assert.Equal(t, CreateProcess, typ)

	typ = NameToType("CreateRemoteThread")
	assert.Equal(t, UnknownType, typ)
}

func TestEventToEventInfo(t *testing.T) {
	info := TypeToEventInfo(CreateProcess)

	assert.Equal(t, "CreateProcess", info.Name)
	assert.Equal(t, Process, info.Category)
	assert.Equal(t, "Creates a new process and its primary thread", info.Description)

	info = TypeToEventInfo(UnknownType)
	assert.Equal(t, "N/A", info.Name)
	assert.Equal(t, Unknown, info.Category)
	assert.Empty(t, info.Description)
}

```

`pkg/event/param.go`:

```go
/*
 * Copyright 2019-2020 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package event

import (
	"fmt"
	"net"
	"reflect"
	"sort"
	"strings"
	"time"

	"github.com/rabbitstack/fibratus/pkg/fs"
	"github.com/rabbitstack/fibratus/pkg/network"
	"github.com/rabbitstack/fibratus/pkg/util/key"
	"github.com/rabbitstack/fibratus/pkg/util/va"
	"golang.org/x/text/cases"
	"golang.org/x/text/language"

	"github.com/rabbitstack/fibratus/pkg/errors"
	"github.com/rabbitstack/fibratus/pkg/event/params"
)

var caser = cases.Title(language.English)

// ParamCaseStyle is the type definition for parameter name case style
type ParamCaseStyle uint8

const (
	// SnakeCase is the default parameter's name case style. Multi-word parameters are delimited by underscore symbol (e.g. process_object)
	SnakeCase ParamCaseStyle = 1
	// DotCase style uses a dot to separate multi-word parameter names (e.g. process.object)
	DotCase ParamCaseStyle = 2
	// PascalCase renders parameter name with pascal case naming style (e.g. ProcessObject)
	PascalCase ParamCaseStyle = 3
	// CamelCase represents parameter names with camel case naming style (e.g. processObject)
	CamelCase ParamCaseStyle = 4
)

// ParamNameCaseStyle designates the case style for the parameter names
var ParamNameCaseStyle = SnakeCase

// ParamKVDelimiter specifies the character that delimits parameter's key from its value
var ParamKVDelimiter = "➜ "

// ParamEnum defines the type for the event parameter enumeration values. Enums
// are a direct mapping from the parameter integer value to some symbolical name
type ParamEnum map[uint32]string

type paramOpts struct {
	flags ParamFlags
	enum  ParamEnum
}

// ParamOption represents the option for the parameter literal constructor.
type ParamOption func(o *paramOpts)

// WithFlags appends the parameter with a list of bitmask flags.
func WithFlags(flags ParamFlags) ParamOption {
	return func(o *paramOpts) {
		o.flags = flags
	}
}

// WithEnum appends the parameter with the enum mapping.
func WithEnum(enum ParamEnum) ParamOption {
	return func(o *paramOpts) {
		o.enum = enum
	}
}

// Param defines the layout of the event parameter.
type Param struct {
	// Type is the type of the parameter. For example, `sport` parameter has the `Port` type although its value
	// is the uint16 numeric type.
	Type params.Type `json:"-"`
	// Value is the container for parameter values. To access the underlying value use the appropriate `Get` methods.
	Value params.Value `json:"value"`
	// Name represents the name of the parameter (e.g. pid, sport).
	Name string `json:"name"`
	// Flags represents parameter flags
	Flags ParamFlags `json:"flags"`
	// Enum represents parameter enumeration
	Enum ParamEnum `json:"enum"`
}

// IsNumber determines if the parameter stores the integer value type.
func (p Param) IsNumber() bool {
	return p.Type == params.Int8 || p.Type == params.Int16 || p.Type == params.Int32 || p.Type == params.Int64 ||
		p.Type == params.Uint8 || p.Type == params.Uint16 || p.Type == params.Uint32 || p.Type == params.Uint64
}

// CaptureType returns the event type saved inside the capture file.
// Captures usually override the type of the parameter to provide
// consistent replay experience. For example, the file path param
// type is converted to string param type, as drive mapping is performed
// on the target where the capture is being taken.
func (p Param) CaptureType() params.Type {
	switch p.Type {
	case params.HandleType, params.DOSPath, params.Key:
		return params.UnicodeString
	default:
		return p.Type
	}
}

// Params is the type that represents the sequence of event parameters
type Params map[string]*Param

// NewParamFromCapture builds a parameter instance from the restored capture state.
func NewParamFromCapture(name string, typ params.Type, value params.Value, etype Type) *Param {
	var enum ParamEnum
	var flags ParamFlags
	switch name {
	case params.FileOperation:
		enum = fs.FileCreateDispositions
	case params.FileCreateOptions:
		flags = FileCreateOptionsFlags
	case params.FileAttributes:
		flags = FileAttributeFlags
	case params.FileShareMask:
		flags = FileShareModeFlags
	case params.FileInfoClass:
		enum = fs.FileInfoClasses
	case params.FileType:
		enum = fs.FileTypes
	case params.NetL4Proto:
		enum = network.ProtoNames
	case params.RegValueType:
		enum = key.RegistryValueTypes
	case params.MemAllocType:
		flags = MemAllocationFlags
	case params.FileViewSectionType:
		enum = ViewSectionTypes
	case params.DNSOpts:
		flags = DNSOptsFlags
	case params.DNSRR:
		enum = DNSRecordTypes
	case params.DNSRcode:
		enum = DNSResponseCodes
	case params.DesiredAccess:
		if etype == OpenProcess {
			flags = PsAccessRightFlags
		} else {
			flags = ThreadAccessRightFlags
		}
	case params.MemProtect:
		if etype == VirtualAlloc || etype == VirtualFree {
			flags = MemProtectionFlags
		} else {
			flags = ViewProtectionFlags
		}
	}
	return &Param{Name: name, Type: typ, Value: value, Enum: enum, Flags: flags}
}

// Append adds a new parameter with the specified name, type and value.
func (pars Params) Append(name string, typ params.Type, value params.Value, opts ...ParamOption) Params {
	pars[name] = NewParam(name, typ, value, opts...)
	return pars
}

// AppendFromCapture adds a new parameter with the specified name, type and value from the cap state.
func (pars Params) AppendFromCapture(name string, typ params.Type, value params.Value, etype Type) Params {
	pars[name] = NewParamFromCapture(name, typ, value, etype)
	return pars
}

// Contains determines whether the specified parameter name exists.
func (pars Params) Contains(name string) bool {
	_, err := pars.findParam(name)
	return err == nil
}

// Remove deletes the specified parameter from the map.
func (pars Params) Remove(name string) {
	delete(pars, name)
}

// Get returns the event parameter with specified name.
func (pars Params) Get(name string) (*Param, error) {
	return pars.findParam(name)
}

// Len returns the number of parameters.
func (pars Params) Len() int { return len(pars) }

// Set replaces the value that is indexed at existing parameter name. It will return an error
// if the supplied parameter is not present.
func (pars Params) Set(name string, value params.Value, typ params.Type) error {
	_, err := pars.findParam(name)
	if err != nil {
		return fmt.Errorf("setting the value on a missing %q parameter is not allowed", name)
	}
	pars[name] = &Param{Name: name, Value: value, Type: typ}
	return nil
}

// SetValue replaces the value for the given parameter name. It will return an error
// if the supplied parameter is not present in the parameter map.
func (pars Params) SetValue(name string, value params.Value) error {
	_, err := pars.findParam(name)
	if err != nil {
		return fmt.Errorf("setting the value on a missing %q parameter is not allowed", name)
	}
	pars[name].Value = value
	return nil
}

// GetRaw returns the raw value for given parameter name. It is the responsibility of the caller to probe type assertion
// on the value before yielding its underlying type.
func (pars Params) GetRaw(name string) (params.Value, error) {
	par, err := pars.findParam(name)
	if err != nil {
		return "", err
	}
	return par.Value, nil
}

// GetString returns the underlying string value from the parameter.
func (pars Params) GetString(name string) (string, error) {
	par, err := pars.findParam(name)
	if err != nil {
		return "", err
	}
	if _, ok := par.Value.(string); !ok {
		return "", fmt.Errorf("unable to type cast %q parameter to string value", name)
	}
	return par.Value.(string), nil
}

// MustGetString returns the string parameter or panics
// if an error occurs while trying to get the parameter.
func (pars Params) MustGetString(name string) string {
	s, err := pars.GetString(name)
	if err != nil {
		panic(err)
	}
	return s
}

// GetPid returns the pid from the parameter.
func (pars Params) GetPid() (uint32, error) {
	return pars.getPid(params.ProcessID)
}

// MustGetPid returns the pid parameter. It panics if
// an error occurs while trying to get the pid parameter.
func (pars Params) MustGetPid() uint32 {
	pid, err := pars.GetPid()
	if err != nil {
		panic(err)
	}
	return pid
}

// GetPpid returns the parent pid from the parameter.
func (pars Params) GetPpid() (uint32, error) {
	return pars.getPid(params.ProcessParentID)
}

// MustGetPpid returns the parent pid parameter. It panics if
// an error occurs while trying to get the pid parameter.
func (pars Params) MustGetPpid() uint32 {
	ppid, err := pars.GetPpid()
	if err != nil {
		panic(err)
	}
	return ppid
}

func (pars Params) getPid(name string) (uint32, error) {
	par, err := pars.findParam(name)
	if err != nil {
		return uint32(0), err
	}
	if par.Type != params.PID {
		return uint32(0), fmt.Errorf("%q parameter is not a PID", name)
	}
	v, ok := par.Value.(uint32)
	if !ok {
		return uint32(0), fmt.Errorf("unable to type cast %q parameter to uint32 value from pid", name)
	}
	return v, nil
}

// GetTid returns the thread id from the parameter.
func (pars Params) GetTid() (uint32, error) {
	par, err := pars.findParam(params.ThreadID)
	if err != nil {
		return uint32(0), err
	}
	if par.Type != params.TID {
		return uint32(0), fmt.Errorf("%q parameter is not a TID", params.ThreadID)
	}
	v, ok := par.Value.(uint32)
	if !ok {
		return uint32(0), fmt.Errorf("unable to type cast %q parameter to uint32 value from tid", params.ThreadID)
	}
	return v, nil
}

// MustGetTid returns the thread id from the parameter or panics if an error occurs.
func (pars Params) MustGetTid() uint32 {
	par, err := pars.findParam(params.ThreadID)
	if err != nil {
		panic(err)
	}
	if par.Type != params.TID {
		panic(fmt.Errorf("%q parameter is not a TID", params.ThreadID))
	}
	v, ok := par.Value.(uint32)
	if !ok {
		panic(fmt.Errorf("unable to type cast %q parameter to uint32 value from tid", params.ThreadID))
	}
	return v
}

// GetUint8 returns the underlying uint8 value from the parameter.
func (pars Params) GetUint8(name string) (uint8, error) {
	par, err := pars.findParam(name)
	if err != nil {
		return uint8(0), err
	}
	v, ok := par.Value.(uint8)
	if !ok {
		return uint8(0), fmt.Errorf("unable to type cast %q parameter to uint8 value", name)
	}
	return v, nil
}

// GetBool returns the underlying boolean value from the parameter.
func (pars Params) GetBool(name string) (bool, error) {
	par, err := pars.findParam(name)
	if err != nil {
		return false, err
	}
	v, ok := par.Value.(bool)
	if !ok {
		return false, fmt.Errorf("unable to type cast %q parameter to bool value", name)
	}
	return v, nil
}

// MustGetBool returns the underlying boolean value from the parameter or
// panics if the parameter can't be retrieved.
func (pars Params) MustGetBool(name string) bool {
	val, err := pars.GetBool(name)
	if err != nil {
		panic(err)
	}
	return val
}

// TryGetBool tries to retrieve the boolean value from the parameter.
// Returns the underlying value on success, or false otherwise.
func (pars Params) TryGetBool(name string) bool {
	val, err := pars.GetBool(name)
	if err != nil {
		return false
	}
	return val
}

// GetInt8 returns the underlying int8 value from the parameter.
func (pars Params) GetInt8(name string) (int8, error) {
	par, err := pars.findParam(name)
	if err != nil {
		return int8(0), err
	}
	v, ok := par.Value.(int8)
	if !ok {
		return int8(0), fmt.Errorf("unable to type cast %q parameter to int8 value", name)
	}
	return v, nil
}

// GetUint16 returns the underlying int16 value from the parameter.
func (pars Params) GetUint16(name string) (uint16, error) {
	par, err := pars.findParam(name)
	if err != nil {
		return uint16(0), err
	}
	v, ok := par.Value.(uint16)
	if !ok {
		return uint16(0), fmt.Errorf("unable to type cast %q parameter to uint16 value", name)
	}
	return v, nil
}

// MustGetUint16 returns  the underlying uint16 value parameter. It panics if
// an error occurs while trying to get the parameter.
func (pars Params) MustGetUint16(name string) uint16 {
	v, err := pars.GetUint16(name)
	if err != nil {
		panic(err)
	}
	return v
}

// TryGetUint16 tries to retrieve the uint16 value from the parameter.
// Returns the underlying value on success, or zero otherwise.
func (pars Params) TryGetUint16(name string) uint16 {
	val, err := pars.GetUint16(name)
	if err != nil {
		return 0
	}
	return val
}

// GetInt16 returns the underlying int16 value from the parameter.
func (pars Params) GetInt16(name string) (int16, error) {
	par, err := pars.findParam(name)
	if err != nil {
		return int16(0), err
	}
	v, ok := par.Value.(int16)
	if !ok {
		return int16(0), fmt.Errorf("unable to type cast %q parameter to int16 value", name)
	}
	return v, nil
}

// GetUint32 returns the underlying uint32 value from the parameter.
func (pars Params) GetUint32(name string) (uint32, error) {
	par, err := pars.findParam(name)
	if err != nil {
		return uint32(0), err
	}
	v, ok := par.Value.(uint32)
	if !ok {
		return uint32(0), fmt.Errorf("unable to type cast %q parameter to uint32 value", name)
	}
	return v, nil
}

// MustGetUint32 returns  the underlying uint32 value parameter. It panics if
// an error occurs while trying to get the parameter.
func (pars Params) MustGetUint32(name string) uint32 {
	v, err := pars.GetUint32(name)
	if err != nil {
		panic(err)
	}
	return v
}

// TryGetUint32 tries to retrieve the uint32 value from the parameter.
// Returns the underlying value on success, or zero otherwise.
func (pars Params) TryGetUint32(name string) uint32 {
	val, err := pars.GetUint32(name)
	if err != nil {
		return 0
	}
	return val
}

// GetInt32 returns the underlying int32 value from the parameter.
func (pars Params) GetInt32(name string) (int32, error) {
	par, err := pars.findParam(name)
	if err != nil {
		return int32(0), err
	}
	v, ok := par.Value.(int32)
	if !ok {
		return int32(0), fmt.Errorf("unable to type cast %q parameter to int32 value", name)
	}
	return v, nil
}

// GetUint64 returns the underlying uint64 value from the parameter.
func (pars Params) GetUint64(name string) (uint64, error) {
	par, err := pars.findParam(name)
	if err != nil {
		return uint64(0), err
	}
	v, ok := par.Value.(uint64)
	if !ok {
		return uint64(0), fmt.Errorf("unable to type cast %q parameter to uint64 value", name)
	}
	return v, nil
}

// MustGetUint64 returns  the underlying uint64 value parameter. It panics if
// an error occurs while trying to get the parameter.
func (pars Params) MustGetUint64(name string) uint64 {
	v, err := pars.GetUint64(name)
	if err != nil {
		panic(err)
	}
	return v
}

// TryGetUint64 tries to retrieve the uint64 value from the parameter.
// Returns the underlying value on success, or zero otherwise.
func (pars Params) TryGetUint64(name string) uint64 {
	val, err := pars.GetUint64(name)
	if err != nil {
		return 0
	}
	return val
}

// GetInt64 returns the underlying int64 value from the parameter.
func (pars Params) GetInt64(name string) (int64, error) {
	par, err := pars.findParam(name)
	if err != nil {
		return int64(0), err
	}
	v, ok := par.Value.(int64)
	if !ok {
		return int64(0), fmt.Errorf("unable to type cast %q parameter to int64 value", name)
	}
	return v, nil
}

// GetFloat returns the underlying float value from the parameter.
func (pars Params) GetFloat(name string) (float32, error) {
	par, err := pars.findParam(name)
	if err != nil {
		return float32(0), err
	}
	v, ok := par.Value.(float32)
	if !ok {
		return float32(0), fmt.Errorf("unable to type cast %q parameter to float32 value", name)
	}
	return v, nil
}

// GetDouble returns the underlying double (float64) value from the parameter.
func (pars Params) GetDouble(name string) (float64, error) {
	par, err := pars.findParam(name)
	if err != nil {
		return float64(0), err
	}
	v, ok := par.Value.(float64)
	if !ok {
		return float64(0), fmt.Errorf("unable to type cast %q parameter to float64 value", name)
	}
	return v, nil
}

// TryGetAddress attempts to convert the underlying type to address.
func (pars Params) TryGetAddress(name string) va.Address {
	par, err := pars.findParam(name)
	if err != nil {
		return 0
	}
	v, ok := par.Value.(uint64)
	if !ok {
		return 0
	}
	return va.Address(v)
}

// GetIPv4 returns the underlying IPv4 address from the parameter.
func (pars Params) GetIPv4(name string) (net.IP, error) {
	par, err := pars.findParam(name)
	if err != nil {
		return net.IP{}, err
	}
	if par.Type != params.IPv4 {
		return net.IP{}, fmt.Errorf("%q parameter is not an IPv4 address", name)
	}
	v, ok := par.Value.(net.IP)
	if !ok {
		return net.IP{}, fmt.Errorf("unable to type cast %q parameter to net.IP value", name)
	}
	return v, nil
}

// GetIPv6 returns the underlying IPv6 address from the parameter.
func (pars Params) GetIPv6(name string) (net.IP, error) {
	par, err := pars.findParam(name)
	if err != nil {
		return net.IP{}, err
	}
	if par.Type != params.IPv6 {
		return net.IP{}, fmt.Errorf("%q parameter is not an IPv6 address", name)
	}
	v, ok := par.Value.(net.IP)
	if !ok {
		return net.IP{}, fmt.Errorf("unable to type cast %q parameter to net.IP value", name)
	}
	return v, nil
}

// GetIP returns either the IPv4 or IPv6 address from the parameter.
func (pars Params) GetIP(name string) (net.IP, error) {
	par, err := pars.findParam(name)
	if err != nil {
		return net.IP{}, err
	}
	if par.Type != params.IPv4 && par.Type != params.IPv6 {
		return net.IP{}, fmt.Errorf("%q parameter is not an IP address", name)
	}
	v, ok := par.Value.(net.IP)
	if !ok {
		return net.IP{}, fmt.Errorf("unable to type cast %q parameter to net.IP value", name)
	}
	return v, nil
}

// MustGetIP returns the IP address parameter or panics if an error occurs.
func (pars Params) MustGetIP(name string) net.IP {
	ip, err := pars.GetIP(name)
	if err != nil {
		panic(err)
	}
	return ip
}

// GetTime returns the underlying time structure from the parameter.
func (pars Params) GetTime(name string) (time.Time, error) {
	par, err := pars.findParam(name)
	if err != nil {
		return time.Unix(0, 0), err
	}
	v, ok := par.Value.(time.Time)
	if !ok {
		return time.Unix(0, 0), fmt.Errorf("unable to type cast %q parameter to Time value", name)
	}
	return v, nil
}

// MustGetTime returns the underlying time structure from the parameter or panics
// if any errors occur.
func (pars Params) MustGetTime(name string) time.Time {
	par, err := pars.findParam(name)
	if err != nil {
		panic(err)
	}
	v, ok := par.Value.(time.Time)
	if !ok {
		panic(fmt.Errorf("unable to type cast %q parameter to Time value", name))
	}
	return v
}

// GetStringSlice returns the string slice from the event parameter.
func (pars Params) GetStringSlice(name string) ([]string, error) {
	par, err := pars.GetSlice(name)
	if err != nil {
		return nil, err
	}
	v, ok := par.([]string)
	if !ok {
		return nil, fmt.Errorf("unable to type cast %q parameter to string slice", name)
	}
	return v, nil
}

// GetSlice returns the slice of generic values from the parameter.
func (pars Params) GetSlice(name string) (params.Value, error) {
	par, err := pars.findParam(name)
	if err != nil {
		return nil, err
	}
	if reflect.TypeOf(par.Value).Kind() != reflect.Slice {
		return nil, fmt.Errorf("%q parameter is not a slice", name)
	}
	return par.Value, nil
}

// MustGetSlice returns the slice of generic values from the parameter or
// panics if the parameter cannot be found.
func (pars Params) MustGetSlice(name string) params.Value {
	par, err := pars.findParam(name)
	if err != nil {
		panic(err)
	}
	return par.Value
}

// MustGetSliceAddrs returns the slice of addresses or panics if the parameter
// is not found, or either a parameter is not a slice of addresses.
func (pars Params) MustGetSliceAddrs(name string) []va.Address {
	val := pars.MustGetSlice(name)
	addrs, ok := val.([]va.Address)
	if !ok {
		panic("must be a slice of addresses")
	}
	return addrs
}

// String returns the string representation of the event parameters. Parameter names are rendered according
// to the currently active parameter style case.
func (pars Params) String() string {
	var sb strings.Builder
	// sort parameters by name
	s := make([]*Param, 0, len(pars))
	for _, par := range pars {
		s = append(s, par)
	}
	sort.Slice(s, func(i, j int) bool { return s[i].Name < s[j].Name })
	for i, par := range s {
		switch ParamNameCaseStyle {
		case SnakeCase:
			sb.WriteString(par.Name + ParamKVDelimiter + par.String())
		case DotCase:
			sb.WriteString(strings.ReplaceAll(par.Name, "_", ".") + ParamKVDelimiter + par.String())
		case PascalCase:
			sb.WriteString(strings.ReplaceAll(caser.String(strings.ReplaceAll(par.Name, "_", " ")), " ", "") + ParamKVDelimiter + par.String())
		case CamelCase:
		}
		if i != len(pars)-1 {
			sb.WriteString(", ")
		}
	}
	return sb.String()
}

// Find returns the parameter with the specified name. If it is not found, nil value is returned.
func (pars Params) Find(name string) *Param {
	par, err := pars.findParam(name)
	if err != nil {
		return nil
	}
	return par
}

// findParam lookups a parameter in the map and returns an error if it doesn't exist.
func (pars Params) findParam(name string) (*Param, error) {
	if _, ok := pars[name]; !ok {
		return nil, &errors.ErrParamNotFound{Name: name}
	}
	return pars[name], nil
}

```

`pkg/event/param_test.go`:

```go
/*
 * Copyright 2019-2020 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package event

import (
	"github.com/rabbitstack/fibratus/pkg/event/params"
	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/require"
	"testing"
)

func TestParams(t *testing.T) {
	pars := Params{
		params.FileObject:        {Name: params.FileObject, Type: params.Uint64, Value: uint64(18446738026482168384)},
		params.ThreadID:          {Name: params.ThreadID, Type: params.Uint32, Value: uint32(1484)},
		params.FileCreateOptions: {Name: params.FileCreateOptions, Type: params.Uint32, Value: uint32(1223456)},
		params.FilePath:          {Name: params.FilePath, Type: params.UnicodeString, Value: "\\Device\\HarddiskVolume2\\Windows\\system32\\kernel32.dll"},
		params.FileShareMask:     {Name: params.FileShareMask, Type: params.Uint32, Value: uint32(5)},
	}

	assert.True(t, pars.Contains(params.FileObject))
	assert.False(t, pars.Contains(params.FileOffset))

	filename, err := pars.GetString(params.FilePath)
	require.NoError(t, err)
	assert.Equal(t, "\\Device\\HarddiskVolume2\\Windows\\system32\\kernel32.dll", filename)

	_, err = pars.GetString(params.FileObject)
	require.Error(t, err)

	assert.Equal(t, 5, pars.Len())

	pars.Remove(params.ThreadID)

	assert.False(t, pars.Contains(params.ThreadID))
	assert.Equal(t, 4, pars.Len())

	require.NoError(t, pars.Set(params.FileShareMask, uint32(5), params.Enum))

	require.NoError(t, pars.SetValue(params.FilePath, "\\Device\\HarddiskVolume2\\Windows\\system32\\KERNEL32.dll"))
	filename1, err := pars.GetString(params.FilePath)
	require.NoError(t, err)
	assert.Equal(t, "\\Device\\HarddiskVolume2\\Windows\\system32\\KERNEL32.dll", filename1)
}

```

`pkg/event/param_windows.go`:

```go
/*
 * Copyright 2020-2021 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package event

import (
	"encoding/binary"
	"expvar"
	"fmt"
	"net"
	"path/filepath"
	"strconv"
	"strings"
	"time"
	"unsafe"

	"github.com/rabbitstack/fibratus/pkg/util/utf16"

	"github.com/rabbitstack/fibratus/pkg/event/params"
	"github.com/rabbitstack/fibratus/pkg/fs"
	htypes "github.com/rabbitstack/fibratus/pkg/handle/types"
	"github.com/rabbitstack/fibratus/pkg/sys"
	"github.com/rabbitstack/fibratus/pkg/sys/etw"
	"github.com/rabbitstack/fibratus/pkg/util/filetime"
	"github.com/rabbitstack/fibratus/pkg/util/ip"
	"github.com/rabbitstack/fibratus/pkg/util/key"
	"github.com/rabbitstack/fibratus/pkg/util/ntstatus"
	"github.com/rabbitstack/fibratus/pkg/util/signature"
	"github.com/rabbitstack/fibratus/pkg/util/va"
	"golang.org/x/sys/windows"
	"golang.org/x/sys/windows/registry"
)

// unknownKeysCount counts the number of times the registry key failed to convert from native format
var unknownKeysCount = expvar.NewInt("registry.unknown.keys.count")

// NewParam creates a new event parameter. Since the parameter type is already categorized,
// we can coerce the value to the appropriate representation (e.g. hex, IP address)
func NewParam(name string, typ params.Type, value params.Value, options ...ParamOption) *Param {
	var opts paramOpts
	for _, opt := range options {
		opt(&opts)
	}
	var v params.Value
	switch typ {
	case params.IPv4:
		v = ip.ToIPv4(value.(uint32))
	case params.IPv6:
		v = ip.ToIPv6(value.([]byte))
	case params.Port:
		v = windows.Ntohs(value.(uint16))
	default:
		v = value
	}
	return &Param{Name: name, Type: typ, Value: v, Flags: opts.flags, Enum: opts.enum}
}

var devMapper = fs.NewDevMapper()

// String returns the string representation of the parameter value.
func (p Param) String() string {
	if p.Value == nil {
		return ""
	}
	switch p.Type {
	case params.UnicodeString, params.AnsiString, params.Path:
		return p.Value.(string)
	case params.SID, params.WbemSID:
		sid, err := getSID(&p)
		if err != nil {
			return ""
		}
		if p.Name == params.ProcessTokenIntegrityLevel {
			return sys.RidToString(sid)
		}
		return sid.String()
	case params.DOSPath:
		return devMapper.Convert(p.Value.(string))
	case params.Key:
		rootKey, keyName := key.Format(p.Value.(string))
		if keyName != "" && rootKey != key.Invalid {
			return rootKey.String() + "\\" + keyName
		}
		if rootKey != key.Invalid {
			return rootKey.String()
		}
		unknownKeysCount.Add(1)
		return keyName
	case params.HandleType:
		return htypes.ConvertTypeIDToName(p.Value.(uint16))
	case params.Status:
		v, ok := p.Value.(uint32)
		if !ok {
			return ""
		}
		return ntstatus.FormatMessage(v)
	case params.Address:
		v, ok := p.Value.(uint64)
		if !ok {
			return ""
		}
		return va.Address(v).String()
	case params.Int8:
		return strconv.Itoa(int(p.Value.(int8)))
	case params.Uint8:
		return strconv.Itoa(int(p.Value.(uint8)))
	case params.Int16:
		return strconv.Itoa(int(p.Value.(int16)))
	case params.Uint16, params.Port:
		return strconv.Itoa(int(p.Value.(uint16)))
	case params.Uint32, params.PID, params.TID:
		return strconv.Itoa(int(p.Value.(uint32)))
	case params.Int32:
		return strconv.Itoa(int(p.Value.(int32)))
	case params.Uint64:
		return strconv.FormatUint(p.Value.(uint64), 10)
	case params.Int64:
		return strconv.Itoa(int(p.Value.(int64)))
	case params.IPv4, params.IPv6:
		return p.Value.(net.IP).String()
	case params.Bool:
		return strconv.FormatBool(p.Value.(bool))
	case params.Float:
		return strconv.FormatFloat(float64(p.Value.(float32)), 'f', 6, 32)
	case params.Double:
		return strconv.FormatFloat(p.Value.(float64), 'f', 6, 64)
	case params.Time:
		return p.Value.(time.Time).String()
	case params.Enum:
		if p.Enum == nil {
			return ""
		}
		e := p.Value
		v, ok := e.(uint32)
		if !ok {
			return ""
		}
		return p.Enum[v]
	case params.Flags, params.Flags64:
		if p.Flags == nil {
			return ""
		}
		f := p.Value
		switch v := f.(type) {
		case uint32:
			return p.Flags.String(uint64(v))
		case uint64:
			return p.Flags.String(v)
		default:
			return ""
		}
	case params.Slice:
		switch slice := p.Value.(type) {
		case []string:
			return strings.Join(slice, ",")
		default:
			return fmt.Sprintf("%v", slice)
		}
	case params.Binary:
		return string(p.Value.([]byte))
	}
	return fmt.Sprintf("%v", p.Value)
}

// GetSID returns the raw SID (Security Identifier) parameter as
// typed representation on which various operations can be performed,
// such as converting the SID to string or resolving username/domain.
func (pars Params) GetSID() (*windows.SID, error) {
	par, err := pars.findParam(params.UserSID)
	if err != nil {
		return nil, err
	}
	return getSID(par)
}

func getSID(param *Param) (*windows.SID, error) {
	sid, ok := param.Value.([]byte)
	if !ok {
		return nil, fmt.Errorf("unable to type cast %q parameter to []byte value", param.Name)
	}
	if sid == nil {
		return nil, fmt.Errorf("sid linked to parameter %s is empty", param.Name)
	}
	b := uintptr(unsafe.Pointer(&sid[0]))
	if param.Type == params.WbemSID {
		// a WBEM SID is actually a TOKEN_USER structure followed
		// by the SID, so we have to double the pointer size
		b += uintptr(8 * 2)
	}
	return (*windows.SID)(unsafe.Pointer(b)), nil
}

// MustGetSID returns the SID (Security Identifier) event parameter
// or panics if an error occurs.
func (pars Params) MustGetSID() *windows.SID {
	sid, err := pars.GetSID()
	if err != nil {
		panic(err)
	}
	return sid
}

// produceParams parses the event binary layout to extract
// the parameters. Each event is annotated with the schema
// version number which helps us determine when the event
// schema changes in order to parse new fields.
func (e *Event) produceParams(evt *etw.EventRecord) {
	switch e.Type {
	case ProcessRundown, CreateProcess, TerminateProcess:
		var (
			kproc      uint64
			pid, ppid  uint32
			sessionID  uint32
			exitStatus uint32
			dtb        uint64
			flags      uint32
			sid        []byte
			name       string
			cmdline    string
		)
		var offset uint16
		var soffset uint16
		var noffset uint16
		if evt.Version() >= 1 {
			pid = evt.ReadUint32(8)
			ppid = evt.ReadUint32(12)
			sessionID = evt.ReadUint32(16)
			exitStatus = evt.ReadUint32(20)
		}
		if evt.Version() >= 2 {
			kproc = evt.ReadUint64(0)
		}
		if evt.Version() >= 3 {
			dtb = evt.ReadUint64(24)
		}
		if evt.Version() >= 4 {
			flags = evt.ReadUint32(32)
		}
		switch {
		case evt.Version() >= 4:
			offset = 36
		case evt.Version() >= 3:
			offset = 32
		default:
			offset = 24
		}
		sid, soffset = evt.ReadSID(offset, true)
		name, noffset = evt.ReadAnsiString(soffset)
		cmdline, _ = evt.ReadUTF16String(noffset)
		e.AppendParam(params.ProcessObject, params.Address, kproc)
		e.AppendParam(params.ProcessID, params.PID, pid)
		e.AppendParam(params.ProcessParentID, params.PID, ppid)
		e.AppendParam(params.ProcessRealParentID, params.PID, evt.Header.ProcessID)
		e.AppendParam(params.SessionID, params.Uint32, sessionID)
		e.AppendParam(params.ExitStatus, params.Status, exitStatus)
		e.AppendParam(params.DTB, params.Address, dtb)
		e.AppendParam(params.ProcessFlags, params.Flags, flags, WithFlags(PsCreationFlags))
		e.AppendParam(params.UserSID, params.WbemSID, sid)
		e.AppendParam(params.ProcessName, params.AnsiString, name)
		e.AppendParam(params.Cmdline, params.UnicodeString, cmdline)
	case CreateProcessInternal, ProcessRundownInternal:
		var (
			pid                 uint32
			createTime          windows.Filetime
			ppid                uint32
			sessionID           uint32
			flags               uint32
			tokenElevationType  uint32
			tokenIsElevated     uint32
			tokenMandatoryLabel []byte
			exe                 string
		)

		pid = evt.ReadUint32(0)

		if (e.IsCreateProcessInternal() && evt.Version() >= 3) || (e.IsProcessRundownInternal() && evt.Version() >= 1) {
			createTime = windows.NsecToFiletime(int64(evt.ReadUint64(12))) // skip sequence number (8 bytes)

			ppid = evt.ReadUint32(20)
			sessionID = evt.ReadUint32(32) // skip parent sequence number (8 bytes)
			flags = evt.ReadUint32(36)
			tokenElevationType = evt.ReadUint32(40)
			tokenIsElevated = evt.ReadUint32(44)

			tokenMandatoryLabel, _ = evt.ReadSID(48, false) // integrity level SID size is 12 bytes

			exe, _ = evt.ReadNTUnicodeString(60)
		} else {
			createTime = windows.NsecToFiletime(int64(evt.ReadUint64(8)))
			ppid = evt.ReadUint32(16)
			sessionID = evt.ReadUint32(20)
			flags = evt.ReadUint32(24)
			exe, _ = evt.ReadNTUnicodeString(28)
		}

		e.AppendParam(params.ProcessID, params.PID, pid)
		e.AppendParam(params.StartTime, params.Time, filetime.ToEpoch(uint64(createTime.Nanoseconds())))
		e.AppendParam(params.ProcessParentID, params.PID, ppid)
		e.AppendParam(params.SessionID, params.Uint32, sessionID)
		e.AppendParam(params.ProcessFlags, params.Flags, flags, WithFlags(PsCreationFlags))
		e.AppendParam(params.ProcessTokenElevationType, params.Enum, tokenElevationType, WithEnum(PsTokenElevationTypes))
		e.AppendParam(params.ProcessTokenIsElevated, params.Bool, tokenIsElevated > 0)
		e.AppendParam(params.ProcessTokenIntegrityLevel, params.SID, tokenMandatoryLabel)
		e.AppendParam(params.Exe, params.DOSPath, exe)
	case OpenProcess:
		processID := evt.ReadUint32(0)
		desiredAccess := evt.ReadUint32(4)
		status := evt.ReadUint32(8)
		e.AppendParam(params.ProcessID, params.PID, processID)
		e.AppendParam(params.DesiredAccess, params.Flags, desiredAccess, WithFlags(PsAccessRightFlags))
		e.AppendParam(params.NTStatus, params.Status, status)

		// append callstack for interested flags
		if desiredAccess == AllAccess || ((desiredAccess & windows.PROCESS_VM_READ) != 0) || ((desiredAccess & windows.PROCESS_VM_WRITE) != 0) ||
			((desiredAccess & windows.PROCESS_VM_OPERATION) != 0) || ((desiredAccess & windows.PROCESS_DUP_HANDLE) != 0) ||
			((desiredAccess & windows.PROCESS_TERMINATE) != 0) || ((desiredAccess & windows.PROCESS_CREATE_PROCESS) != 0) ||
			((desiredAccess & windows.PROCESS_CREATE_THREAD) != 0) || ((desiredAccess & windows.PROCESS_SET_INFORMATION) != 0) {
			e.AppendParam(params.Callstack, params.Slice, evt.Callstack())
		}
	case CreateThread, TerminateThread, ThreadRundown:
		var (
			pid            uint32
			tid            uint32
			kstack, klimit uint64
			ustack, ulimit uint64
			startAddress   uint64
			teb            uint64
			basePrio       uint8
			pagePrio       uint8
			ioPrio         uint8
		)
		if evt.Version() >= 1 {
			pid = evt.ReadUint32(0)
			tid = evt.ReadUint32(4)
		} else {
			pid = evt.ReadUint32(4)
			tid = evt.ReadUint32(0)
		}
		if evt.Version() >= 2 {
			kstack = evt.ReadUint64(8)
			klimit = evt.ReadUint64(16)
			ustack = evt.ReadUint64(24)
			ulimit = evt.ReadUint64(32)
			startAddress = evt.ReadUint64(48)
			teb = evt.ReadUint64(56)
		}
		if evt.Version() >= 3 {
			basePrio = evt.ReadByte(69)
			pagePrio = evt.ReadByte(70)
			ioPrio = evt.ReadByte(71)
		}
		e.AppendParam(params.ProcessID, params.PID, pid)
		e.AppendParam(params.ThreadID, params.TID, tid)
		e.AppendParam(params.KstackBase, params.Address, kstack)
		e.AppendParam(params.KstackLimit, params.Address, klimit)
		e.AppendParam(params.UstackBase, params.Address, ustack)
		e.AppendParam(params.UstackLimit, params.Address, ulimit)
		e.AppendParam(params.StartAddress, params.Address, startAddress)
		e.AppendParam(params.TEB, params.Address, teb)
		e.AppendParam(params.BasePrio, params.Uint8, basePrio)
		e.AppendParam(params.PagePrio, params.Uint8, pagePrio)
		e.AppendParam(params.IOPrio, params.Uint8, ioPrio)
	case OpenThread:
		processID := evt.ReadUint32(0)
		threadID := evt.ReadUint32(4)
		desiredAccess := evt.ReadUint32(8)
		status := evt.ReadUint32(12)
		e.AppendParam(params.ProcessID, params.PID, processID)
		e.AppendParam(params.ThreadID, params.TID, threadID)
		e.AppendParam(params.DesiredAccess, params.Flags, desiredAccess, WithFlags(ThreadAccessRightFlags))
		e.AppendParam(params.NTStatus, params.Status, status)

		// append callstack for interested flags
		if desiredAccess == AllAccess || ((desiredAccess & windows.THREAD_SET_CONTEXT) != 0) || ((desiredAccess & windows.THREAD_SET_THREAD_TOKEN) != 0) ||
			((desiredAccess & windows.THREAD_IMPERSONATE) != 0) || ((desiredAccess & windows.THREAD_DIRECT_IMPERSONATION) != 0) ||
			((desiredAccess & windows.THREAD_SUSPEND_RESUME) != 0) || ((desiredAccess & windows.THREAD_TERMINATE) != 0) ||
			((desiredAccess & windows.THREAD_SET_INFORMATION) != 0) {
			e.AppendParam(params.Callstack, params.Slice, evt.Callstack())
		}
	case SetThreadContext:
		status := evt.ReadUint32(0)
		e.AppendParam(params.NTStatus, params.Status, status)
		if evt.HasStackTrace() {
			e.AppendParam(params.Callstack, params.Slice, evt.Callstack())
		}
	case CreateHandle, CloseHandle:
		object := evt.ReadUint64(0)
		handleID := evt.ReadUint32(8)
		typeID := evt.ReadUint16(12)
		var handleName string
		if evt.BufferLen >= 16 {
			handleName = evt.ConsumeUTF16String(14)
		}
		e.AppendParam(params.HandleObject, params.Address, object)
		e.AppendParam(params.HandleID, params.Uint32, handleID)
		e.AppendParam(params.HandleObjectTypeID, params.HandleType, typeID)
		e.AppendParam(params.HandleObjectName, params.UnicodeString, handleName)
	case DuplicateHandle:
		object := evt.ReadUint64(0)
		srcHandleID := evt.ReadUint32(8)
		dstHandleID := evt.ReadUint32(12)
		targetPID := evt.ReadUint32(16)
		typeID := evt.ReadUint16(20)
		sourcePID := evt.ReadUint32(22)
		e.AppendParam(params.HandleObject, params.Address, object)
		e.AppendParam(params.HandleID, params.Uint32, dstHandleID)
		e.AppendParam(params.HandleSourceID, params.Uint32, srcHandleID)
		e.AppendParam(params.HandleObjectTypeID, params.HandleType, typeID)
		e.AppendParam(params.ProcessID, params.PID, sourcePID)
		e.AppendParam(params.TargetProcessID, params.PID, targetPID)
	case LoadImage, UnloadImage, ImageRundown:
		var (
			pid               uint32
			checksum          uint32
			defaultBase       uint64
			filename          string
			sigLevel, sigType uint8
		)
		var offset uint16
		imageBase := evt.ReadUint64(0)
		imageSize := evt.ReadUint64(8)
		if evt.Version() >= 1 {
			pid = evt.ReadUint32(16)
		}
		if evt.Version() >= 2 {
			checksum = evt.ReadUint32(20)
			defaultBase = evt.ReadUint64(30)
		}
		if evt.Version() >= 3 {
			sigLevel = evt.ReadByte(28)
			sigType = evt.ReadByte(29)
			defaultBase = evt.ReadUint64(32)
		}
		switch {
		case evt.Version() >= 3:
			offset = 56
		case evt.Version() >= 2:
			offset = 54
		case evt.Version() >= 1:
			offset = 20
		default:
			offset = 16
		}
		filename = evt.ConsumeUTF16String(offset)
		e.AppendParam(params.ProcessID, params.PID, pid)
		e.AppendParam(params.ImageCheckSum, params.Uint32, checksum)
		e.AppendParam(params.ImageDefaultBase, params.Address, defaultBase)
		e.AppendParam(params.ImageBase, params.Address, imageBase)
		e.AppendParam(params.ImageSize, params.Uint64, imageSize)
		e.AppendParam(params.ImagePath, params.DOSPath, filename)
		e.AppendParam(params.ImageSignatureLevel, params.Enum, uint32(sigLevel), WithEnum(signature.Levels))
		e.AppendParam(params.ImageSignatureType, params.Enum, uint32(sigType), WithEnum(signature.Types))
	case LoadImageInternal:
		var (
			pid         uint32
			checksum    uint32
			defaultBase uint64
			imageBase   uint64
			imageSize   uint64
			filename    string
		)

		imageBase = evt.ReadUint64(0)
		imageSize = evt.ReadUint64(8)
		pid = evt.ReadUint32(16)
		checksum = evt.ReadUint32(20)
		defaultBase = evt.ReadUint64(28) // skip timestamp (4 bytes)
		filename = evt.ConsumeUTF16String(36)

		e.AppendParam(params.ProcessID, params.PID, pid)
		e.AppendParam(params.ImageCheckSum, params.Uint32, checksum)
		e.AppendParam(params.ImageDefaultBase, params.Address, defaultBase)
		e.AppendParam(params.ImageBase, params.Address, imageBase)
		e.AppendParam(params.ImageSize, params.Uint64, imageSize)
		e.AppendParam(params.ImagePath, params.DOSPath, filename)
	case RegOpenKey, RegCloseKey,
		RegCreateKCB, RegDeleteKCB,
		RegKCBRundown, RegCreateKey,
		RegDeleteKey, RegDeleteValue,
		RegQueryKey, RegQueryValue,
		RegSetValue:
		var (
			status    uint32
			keyHandle uint64
			keyName   string
		)
		if evt.Version() >= 2 {
			status = evt.ReadUint32(8)
			keyHandle = evt.ReadUint64(16)
		} else {
			status = evt.ReadUint32(0)
			keyHandle = evt.ReadUint64(4)
		}
		if evt.Version() >= 1 {
			keyName = evt.ConsumeUTF16String(24)
		} else {
			keyName = evt.ConsumeUTF16String(20)
		}
		e.AppendParam(params.RegKeyHandle, params.Address, keyHandle)
		e.AppendParam(params.RegPath, params.Key, keyName)
		e.AppendParam(params.NTStatus, params.Status, status)
	case RegSetValueInternal:
		keyObject := evt.ReadUint64(0)
		status := evt.ReadUint32(8)
		valueType := evt.ReadUint32(12)
		keyName, koffset := evt.ReadUTF16String(20) // skip data size param (4 bytes)
		valueName, voffset := evt.ReadUTF16String(koffset)
		capturedSize := evt.ReadUint16(voffset)
		capturedData := evt.ReadBytes(2+voffset, capturedSize)

		// copy the buffer as it points to invalid
		// memory when the callback function returns
		b := make([]byte, capturedSize)
		copy(b, capturedData)

		e.AppendParam(params.RegKeyHandle, params.Address, keyObject)
		e.AppendParam(params.NTStatus, params.Status, status)
		e.AppendParam(params.RegPath, params.Key, filepath.Join(keyName, valueName))
		e.AppendEnum(params.RegValueType, valueType, key.RegistryValueTypes)

		if len(b) > 0 {
			switch valueType {
			case registry.SZ, registry.MULTI_SZ, registry.EXPAND_SZ:
				e.AppendParam(params.RegData, params.UnicodeString, utf16.BytesToString(b, binary.LittleEndian))
			case registry.BINARY:
				e.AppendParam(params.RegData, params.Binary, b)
			case registry.DWORD:
				var v uint32
				switch len(b) {
				case 4:
					v = binary.LittleEndian.Uint32(b)
				case 2:
					v = uint32(binary.LittleEndian.Uint16(b))
				case 1:
					v = uint32(b[0])
				}
				e.AppendParam(params.RegData, params.Uint32, v)
			case registry.DWORD_BIG_ENDIAN:
				var v uint32
				switch len(b) {
				case 4:
					v = binary.BigEndian.Uint32(b)
				case 2:
					v = uint32(binary.BigEndian.Uint16(b))
				case 1:
					v = uint32(b[0])
				}
				e.AppendParam(params.RegData, params.Uint32, v)
			case registry.QWORD:
				var v uint64
				switch len(b) {
				case 8:
					v = binary.LittleEndian.Uint64(b)
				case 4:
					v = uint64(binary.LittleEndian.Uint32(b))
				case 2:
					v = uint64(binary.LittleEndian.Uint16(b))
				case 1:
					v = uint64(b[0])
				}
				e.AppendParam(params.RegData, params.Uint64, v)
			}
		}
	case CreateFile:
		var (
			irp            uint64
			fileObject     uint64
			tid            uint32
			createOptions  uint32
			fileAttributes uint32
			shareAccess    uint32
			filename       string
		)
		if evt.Version() >= 2 {
			irp = evt.ReadUint64(0)
			fileObject = evt.ReadUint64(8)
			tid = evt.ReadUint32(16)
			createOptions = evt.ReadUint32(20)
			fileAttributes = evt.ReadUint32(24)
			shareAccess = evt.ReadUint32(28)
			filename = evt.ConsumeUTF16String(32)
		} else {
			fileObject = evt.ReadUint64(0)
			filename = evt.ConsumeUTF16String(8)
		}
		e.AppendParam(params.FileIrpPtr, params.Address, irp)
		e.AppendParam(params.FileObject, params.Address, fileObject)
		e.AppendParam(params.ThreadID, params.TID, tid)
		e.AppendParam(params.FileShareMask, params.Flags, shareAccess, WithFlags(FileShareModeFlags))
		e.AppendParam(params.FileAttributes, params.Flags, fileAttributes, WithFlags(FileAttributeFlags))
		e.AppendParam(params.FileCreateOptions, params.Flags, createOptions, WithFlags(FileCreateOptionsFlags))
		e.AppendParam(params.FilePath, params.DOSPath, filename)
	case FileOpEnd:
		var (
			irp       uint64
			extraInfo uint64
			status    uint32
		)
		if evt.Version() >= 2 {
			irp = evt.ReadUint64(0)
			extraInfo = evt.ReadUint64(8)
			status = evt.ReadUint32(16)
		}
		e.AppendParam(params.FileIrpPtr, params.Address, irp)
		e.AppendParam(params.FileExtraInfo, params.Address, extraInfo)
		e.AppendParam(params.NTStatus, params.Status, status)
	case FileRundown:
		var (
			fileObject uint64
			filename   string
		)
		if evt.Version() >= 2 {
			fileObject = evt.ReadUint64(0)
			filename = evt.ConsumeUTF16String(8)
		}
		e.AppendParam(params.FileObject, params.Address, fileObject)
		e.AppendParam(params.FilePath, params.DOSPath, filename)
	case ReleaseFile, CloseFile:
		var (
			irp        uint64
			fileObject uint64
			fileKey    uint64
			tid        uint32
		)
		if evt.Version() >= 2 {
			irp = evt.ReadUint64(0)
		}
		if evt.Version() >= 3 {
			fileObject = evt.ReadUint64(8)
			fileKey = evt.ReadUint64(16)
			tid = evt.ReadUint32(24)
		}
		e.AppendParam(params.FileIrpPtr, params.Address, irp)
		e.AppendParam(params.FileObject, params.Address, fileObject)
		e.AppendParam(params.FileKey, params.Address, fileKey)
		e.AppendParam(params.ThreadID, params.TID, tid)
	case DeleteFile, RenameFile, SetFileInformation:
		var (
			irp        uint64
			fileObject uint64
			fileKey    uint64
			tid        uint32
			extraInfo  uint64
			infoClass  uint32
		)
		if evt.Version() >= 2 {
			irp = evt.ReadUint64(0)
		}
		if evt.Version() >= 3 {
			fileObject = evt.ReadUint64(8)
			fileKey = evt.ReadUint64(16)
			extraInfo = evt.ReadUint64(24)
			tid = evt.ReadUint32(32)
			infoClass = evt.ReadUint32(36)
		} else {
			tid = evt.ReadUint32(8)
			fileObject = evt.ReadUint64(12)
			fileKey = evt.ReadUint64(18)
			extraInfo = evt.ReadUint64(28)
		}
		e.AppendParam(params.FileIrpPtr, params.Address, irp)
		e.AppendParam(params.FileObject, params.Address, fileObject)
		e.AppendParam(params.FileKey, params.Address, fileKey)
		e.AppendParam(params.ThreadID, params.TID, tid)
		e.AppendParam(params.FileExtraInfo, params.Uint64, extraInfo)
		e.AppendParam(params.FileInfoClass, params.Enum, infoClass, WithEnum(fs.FileInfoClasses))
	case ReadFile, WriteFile:
		var (
			irp        uint64
			offset     uint64
			fileObject uint64
			fileKey    uint64
			tid        uint32
			size       uint32
		)
		if evt.Version() >= 2 {
			offset = evt.ReadUint64(0)
			irp = evt.ReadUint64(8)
		}
		if evt.Version() >= 3 {
			fileObject = evt.ReadUint64(16)
			fileKey = evt.ReadUint64(24)
			tid = evt.ReadUint32(32)
			size = evt.ReadUint32(34)
		} else {
			fileObject = evt.ReadUint64(20)
			fileKey = evt.ReadUint64(28)
			tid = evt.ReadUint32(16)
		}
		e.AppendParam(params.FileIrpPtr, params.Address, irp)
		e.AppendParam(params.FileObject, params.Address, fileObject)
		e.AppendParam(params.FileKey, params.Address, fileKey)
		e.AppendParam(params.ThreadID, params.TID, tid)
		e.AppendParam(params.FileOffset, params.Uint64, offset)
		e.AppendParam(params.FileIoSize, params.Uint32, size)
	case EnumDirectory:
		var (
			irp        uint64
			fileObject uint64
			fileKey    uint64
			tid        uint32
			infoClass  uint32
			filename   string
		)
		if evt.Version() >= 2 {
			irp = evt.ReadUint64(0)
		}
		if evt.Version() >= 3 {
			fileObject = evt.ReadUint64(8)
			fileKey = evt.ReadUint64(16)
			tid = evt.ReadUint32(24)
			infoClass = evt.ReadUint32(32)
			filename = evt.ConsumeUTF16String(38)
		} else {
			tid = evt.ReadUint32(8)
			fileObject = evt.ReadUint64(12)
			fileKey = evt.ReadUint64(20)
		}
		e.AppendParam(params.FileIrpPtr, params.Address, irp)
		e.AppendParam(params.FileObject, params.Address, fileObject)
		e.AppendParam(params.ThreadID, params.TID, tid)
		e.AppendParam(params.FileKey, params.Address, fileKey)
		e.AppendParam(params.FilePath, params.UnicodeString, filename)
		e.AppendParam(params.FileInfoClass, params.Enum, infoClass, WithEnum(fs.FileInfoClasses))
	case MapViewFile, UnmapViewFile, MapFileRundown:
		var (
			viewBase  uint64
			fileKey   uint64
			extraInfo uint64
			viewSize  uint64
			pid       uint32
			offset    uint64
		)
		viewBase = evt.ReadUint64(0)
		fileKey = evt.ReadUint64(8)
		extraInfo = evt.ReadUint64(16)
		viewSize = evt.ReadUint64(24)
		if evt.Version() >= 3 {
			offset = evt.ReadUint64(32)
		}
		if evt.Version() >= 3 {
			pid = evt.ReadUint32(40)
		} else {
			pid = evt.ReadUint32(32)
		}
		protect := uint32(extraInfo >> 32)
		section := uint32(extraInfo >> 52)
		e.AppendParam(params.FileViewBase, params.Address, viewBase)
		e.AppendParam(params.FileKey, params.Address, fileKey)
		e.AppendParam(params.FileViewSize, params.Uint64, viewSize)
		e.AppendParam(params.FileOffset, params.Uint64, offset)
		e.AppendParam(params.ProcessID, params.PID, pid)
		e.AppendParam(params.MemProtect, params.Flags, protect, WithFlags(ViewProtectionFlags))
		e.AppendParam(params.FileViewSectionType, params.Enum, section, WithEnum(ViewSectionTypes))
	case SendTCPv4,
		SendUDPv4,
		RecvTCPv4,
		RecvUDPv4,
		DisconnectTCPv4,
		RetransmitTCPv4,
		ReconnectTCPv4,
		ConnectTCPv4,
		AcceptTCPv4:
		var (
			pid   uint32
			size  uint32
			dip   uint32
			sip   uint32
			dport uint16
			sport uint16
		)
		if evt.Version() >= 1 {
			pid = evt.ReadUint32(0)
			size = evt.ReadUint32(4)
			dip = evt.ReadUint32(8)
			sip = evt.ReadUint32(12)
			dport = evt.ReadUint16(16)
			sport = evt.ReadUint16(18)
		} else {
			dip = evt.ReadUint32(0)
			sip = evt.ReadUint32(4)
			dport = evt.ReadUint16(8)
			sport = evt.ReadUint16(10)
			size = evt.ReadUint32(12)
			pid = evt.ReadUint32(16)
		}
		e.AppendParam(params.ProcessID, params.PID, pid)
		e.AppendParam(params.NetSize, params.Uint32, size)
		e.AppendParam(params.NetDIP, params.IPv4, dip)
		e.AppendParam(params.NetSIP, params.IPv4, sip)
		e.AppendParam(params.NetDport, params.Port, dport)
		e.AppendParam(params.NetSport, params.Port, sport)
	case SendTCPv6,
		SendUDPv6,
		RecvTCPv6,
		RecvUDPv6,
		DisconnectTCPv6,
		RetransmitTCPv6,
		ReconnectTCPv6,
		ConnectTCPv6,
		AcceptTCPv6:
		var (
			pid   uint32
			size  uint32
			dip   []byte
			sip   []byte
			dport uint16
			sport uint16
		)
		if evt.Version() >= 2 {
			pid = evt.ReadUint32(0)
			size = evt.ReadUint32(4)
			dip = evt.ReadBytes(8, 16)
			sip = evt.ReadBytes(24, 16)
			dport = evt.ReadUint16(40)
			sport = evt.ReadUint16(42)
		}
		e.AppendParam(params.ProcessID, params.PID, pid)
		e.AppendParam(params.NetSize, params.Uint32, size)
		e.AppendParam(params.NetDIP, params.IPv6, dip)
		e.AppendParam(params.NetSIP, params.IPv6, sip)
		e.AppendParam(params.NetDport, params.Port, dport)
		e.AppendParam(params.NetSport, params.Port, sport)
	case VirtualAlloc, VirtualFree:
		var (
			baseAddress uint64
			regionSize  uint64
			pid         uint32
			flags       uint32
		)
		if evt.Version() >= 1 {
			baseAddress = evt.ReadUint64(0)
			regionSize = evt.ReadUint64(8)
			pid = evt.ReadUint32(16)
			flags = evt.ReadUint32(20)
		}
		e.AppendParam(params.MemBaseAddress, params.Address, baseAddress)
		e.AppendParam(params.MemRegionSize, params.Uint64, regionSize)
		e.AppendParam(params.ProcessID, params.PID, pid)
		e.AppendParam(params.MemAllocType, params.Flags, flags, WithFlags(MemAllocationFlags))
	case QueryDNS, ReplyDNS:
		var (
			name string
			rr   uint32
			opts uint64
		)
		var offset uint16
		name, offset = evt.ReadUTF16String(0)
		rr = evt.ReadUint32(offset)
		opts = evt.ReadUint64(offset + 4)
		e.AppendParam(params.DNSName, params.UnicodeString, name)
		e.AppendParam(params.DNSRR, params.Enum, rr, WithEnum(DNSRecordTypes))
		e.AppendParam(params.DNSOpts, params.Flags64, opts, WithFlags(DNSOptsFlags))
		if e.Type == ReplyDNS {
			rcode := evt.ReadUint32(offset + 12)
			answers := evt.ConsumeUTF16String(offset + 16)
			e.AppendParam(params.DNSRcode, params.Enum, rcode, WithEnum(DNSResponseCodes))
			e.AppendParam(params.DNSAnswers, params.Slice, strings.Split(sanitizeDNSAnswers(answers), ";"))
		}
	case StackWalk:
		e.AppendParam(params.ProcessID, params.PID, evt.ReadUint32(8))
		e.AppendParam(params.ThreadID, params.TID, evt.ReadUint32(12))
		var n uint16
		var offset uint16 = 16
		frames := (evt.BufferLen - offset) / 8
		callstack := make([]va.Address, frames)
		for n < frames {
			callstack[n] = va.Address(evt.ReadUint64(offset))
			offset += 8
			n++
		}
		e.AppendParam(params.Callstack, params.Slice, callstack)
	case CreateSymbolicLinkObject:
		source, offset := evt.ReadUTF16String(0)
		target, offset := evt.ReadUTF16String(offset)
		desiredAccess := evt.ReadUint32(offset)
		status := evt.ReadUint32(offset + 4)
		e.AppendParam(params.LinkSource, params.UnicodeString, source)
		e.AppendParam(params.LinkTarget, params.UnicodeString, target)
		e.AppendParam(params.DesiredAccess, params.Flags, desiredAccess, WithFlags(AccessMaskFlags))
		e.AppendParam(params.NTStatus, params.Status, status)
		if evt.HasStackTrace() {
			e.AppendParam(params.Callstack, params.Slice, evt.Callstack())
		}
	case SubmitThreadpoolWork, SubmitThreadpoolCallback:
		poolID := evt.ReadUint64(0)
		taskID := evt.ReadUint64(8)
		callback := evt.ReadUint64(16)
		ctx := evt.ReadUint64(24)
		tag := evt.ReadUint64(32)
		e.AppendParam(params.ThreadpoolPoolID, params.Address, poolID)
		e.AppendParam(params.ThreadpoolTaskID, params.Address, taskID)
		e.AppendParam(params.ThreadpoolCallback, params.Address, callback)
		e.AppendParam(params.ThreadpoolContext, params.Address, ctx)
		e.AppendParam(params.ThreadpoolSubprocessTag, params.Address, tag)
	case SetThreadpoolTimer:
		duetime := evt.ReadUint64(0)
		subqueue := evt.ReadUint64(8)
		timer := evt.ReadUint64(16)
		period := evt.ReadUint32(24)
		window := evt.ReadUint32(28)
		absolute := evt.ReadUint32(32)
		e.AppendParam(params.ThreadpoolTimerDuetime, params.Uint64, duetime)
		e.AppendParam(params.ThreadpoolTimerSubqueue, params.Address, subqueue)
		e.AppendParam(params.ThreadpoolTimer, params.Address, timer)
		e.AppendParam(params.ThreadpoolTimerPeriod, params.Uint32, period)
		e.AppendParam(params.ThreadpoolTimerWindow, params.Uint32, window)
		e.AppendParam(params.ThreadpoolTimerAbsolute, params.Bool, absolute > 0)
	}
}

// sanitizeDNSAnswers removes the "type" string from DNS answers.
func sanitizeDNSAnswers(answers string) string {
	return strings.ReplaceAll(answers, "type: 5 ", "")
}

```

`pkg/event/params/params_windows.go`:

```go
/*
 * Copyright 2019-2020 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package params

const (
	// NTStatus is the parameter that identifies the NTSTATUS value.
	NTStatus = "status"

	// ProcessID represents the process identifier.
	ProcessID = "pid"
	// TargetProcessID represents the target process identifier.
	TargetProcessID = "target_pid"
	// ProcessObject field represents the address of the process object in the kernel.
	ProcessObject = "kproc"
	// ThreadID field represents the thread identifier.
	ThreadID = "tid"
	// Callstack field represents the thread callstack.
	Callstack = "callstack"
	// ProcessParentID field represents the parent process identifier.
	ProcessParentID = "ppid"
	// ProcessRealParentID field presents the real parent process identifier.
	ProcessRealParentID = "real_ppid"
	// SessionID fields represents the session identifier.
	SessionID = "session_id"
	// UserSID field is the security identifier associated to the process token under which it is run.
	UserSID = "sid"
	// Username field represents the username under which the event was generated.
	Username = "username"
	// Domain field represents the domain under which the event was generated.
	Domain = "domain"
	// ProcessName field denotes the process image name.
	ProcessName = "name"
	// Exe field denotes the full path of the executable.
	Exe = "exe"
	// Cmdline field represents the process command line.
	Cmdline = "cmdline"
	// DTB field denotes the address of the process directory table.
	DTB = "directory_table_base"
	// ProcessFlags field denotes the process creation flags
	ProcessFlags = "flags"
	// ExitStatus is the field that represents the process exit status.
	ExitStatus = "exit_status"
	// StartTime field denotes the process start time.
	StartTime = "start_time"
	// ProcessTokenIntegrityLevel field denotes the process integrity level.
	ProcessTokenIntegrityLevel = "token_integrity_level"
	// ProcessTokenElevationType field designates the process token elevation type.
	ProcessTokenElevationType = "token_elevation_type"
	// ProcessTokenIsElevated field designates if the process token is elevated.
	ProcessTokenIsElevated = "token_is_elevated"

	// DesiredAccess field denotes the access rights for different kernel objects such as processes or threads.
	DesiredAccess = "desired_access"

	// BasePrio field is the thread base priority assigned by the scheduler.
	BasePrio = "base_prio"
	// IOPrio represents the filed that indicates the thread I/O priority.
	IOPrio = "io_prio"
	// PagePrio field denotes page priority.
	PagePrio = "page_prio"
	// KstackBase field is the start address of the kernel space stack.
	KstackBase = "kstack"
	// KstackLimit field is the end address of the kernel space stack.
	KstackLimit = "kstack_limit"
	// UstackBase field is the start address of the user space stack.
	UstackBase = "ustack"
	// UstackLimit field is the end address of the user space stack.
	UstackLimit = "ustack_limit"
	// StartAddress field is the thread start address.
	StartAddress = "start_address"
	// StartAddressSymbol field is the symbol associated with the thread start address.
	StartAddressSymbol = "start_address_symbol"
	// StartAddressModule field is the module where the thread start address is mapped.
	StartAddressModule = "start_address_module"
	// TEB field is the address of the Thread Environment Block (TEB)
	TEB = "teb"

	// FileObject determines the field name for the file object pointer.
	FileObject = "file_object"
	// FilePath represents the field that designates the absolute path of the file.
	FilePath = "file_path"
	// FileCreateOptions is the field that represents the values passed in the CreateDispositions parameter to the NtCreateFile function.
	FileCreateOptions = "create_options"
	// FileOperation is the field that represents the values passed in the CreateOptions parameter to the NtCreateFile function.
	FileOperation = "create_disposition"
	// FileCreated represents the name for the file creation field.
	FileCreated = "created"
	// FileAccessed represents the name for the file access field.
	FileAccessed = "accessed"
	// FileModified represents the name for the file modification field.
	FileModified = "modified"
	// FileShareMask represents the field name for the share access mask.
	FileShareMask = "share_mask"
	// FileType represents the field name that indicates the file type.
	FileType = "type"
	// FileAttributes is the field that represents file attribute values.
	FileAttributes = "attributes"
	// FileIoSize is the filed that represents the number of bytes in file read/write operations.
	FileIoSize = "io_size"
	// FileOffset represents the file for the file offset in read/write operations.
	FileOffset = "offset"
	// FileInfoClass represents the file information class.
	FileInfoClass = "class"
	// FileKey represents the directory key identifier in EnumDirectory events.
	FileKey = "file_key"
	// FileDirectory represents the field for the directory name in EnumDirectory events.
	FileDirectory = "directory"
	// FileIrpPtr represents the I/O request packet id.
	FileIrpPtr = "irp"
	// FileExtraInfo is the parameter that represents extra information returned by the file system for the operation. For example for a read request, the actual number of bytes that were read.
	FileExtraInfo = "extra_info"
	// FileIsDLL is the parameter that indicates if the file is a DLL
	FileIsDLL = "is_dll"
	// FileIsDriver is the parameter that indicates if the file is a driver
	FileIsDriver = "is_driver"
	// FileIsExecutable is the parameter that indicates if the file is an executable
	FileIsExecutable = "is_exec"
	// FileIsDotnet is the parameter that indicates if the file is a .NET assembly
	FileIsDotnet = "is_dotnet"

	// FileViewBase is the parameter that represents the base address of the mapped section.
	FileViewBase = "view_base"
	// FileViewSize is the parameter that represents the size of the mapped section.
	FileViewSize = "view_size"
	// FileViewSectionType is the parameter that represents the mapped section type.
	FileViewSectionType = "section_type"

	// RegKeyHandle identifies the parameter name for the registry key handle.
	RegKeyHandle = "key_handle"
	// RegPath represents the parameter name for the fully qualified key path.
	RegPath = "key_path"
	// RegValue identifies the parameter name that contains the value
	RegValue = "value"
	// RegValueType identifies the parameter that represents registry value type e.g (DWORD, BINARY)
	RegValueType = "value_type"
	// RegData identifies the parameter that stores the captured registry data
	RegData = "data"

	// ImageBase identifies the parameter name for the base address of the process in which the image is loaded.
	ImageBase = "base_address"
	// ImageSize represents the parameter name for the size of the image in bytes.
	ImageSize = "image_size"
	// ImageCheckSum is the parameter name for image checksum.
	ImageCheckSum = "checksum"
	// ImageDefaultBase is the parameter name that represents image's base address.
	ImageDefaultBase = "default_address"
	// ImagePath is the parameter name that denotes the file path and extension of the DLL/executable image.
	ImagePath = "file_path"
	// ImageSignatureLevel is the parameter denoting the loaded module signature level.
	ImageSignatureLevel = "signature_level"
	// ImageSignatureType is the parameter denoting the loaded module signature type.
	ImageSignatureType = "signature_type"
	// ImageCertSubject is the parameter that indicates the subject of the certificate is the entity its public key is associated with.
	ImageCertSubject = "cert_subject"
	// ImageCertIssuer is the parameter that represents the certificate authority (CA).
	ImageCertIssuer = "cert_issuer"
	// ImageCertSerial is the parameter that represents the serial number MUST be a positive integer assigned
	// by the CA to each certificate.
	ImageCertSerial = "cert_serial"
	// ImageCertNotBefore  is the parameter that specifies the certificate won't be valid before this timestamp.
	ImageCertNotBefore = "cert_not_before"
	// ImageCertNotAfter is the parameter that specifies the certificate won't be valid after this timestamp.
	ImageCertNotAfter = "cert_not_after"

	// NetSize identifies the parameter name that represents the packet size.
	NetSize = "size"
	// NetDIP is the parameter name that denotes the destination IP address.
	NetDIP = "dip"
	// NetSIP is the parameter name that denotes the source IP address.
	NetSIP = "sip"
	// NetDport identifies the parameter name that represents destination port number.
	NetDport = "dport"
	// NetSport identifies the parameter name that represents source port number.
	NetSport = "sport"
	// NetMSS is the parameter name that represents the maximum TCP segment size.
	NetMSS = "mss"
	// NetRcvWin is the parameter name that represents TCP segment's receive window size.
	NetRcvWin = "rcvwin"
	// NetSAckopt is the parameter name that represents Selective Acknowledgment option in TCP header.
	NetSAckopt = "sack_opt"
	// NetTsopt is the parameter name that represents the time stamp option in TCP header.
	NetTsopt = "timestamp_opt"
	// NetWsopt is the parameter name that represents the window scale option in TCP header.
	NetWsopt = "window_scale_opt"
	// NetRcvWinScale is the parameter name that represents the TCP receive window scaling factor.
	NetRcvWinScale = "recv_winscale"
	// NetSendWinScale is the parameter name that represents the TCP send window scaling factor.
	NetSendWinScale = "send_winscale"
	// NetSeqNum is the parameter name that represents the TCP sequence number.
	NetSeqNum = "seqnum"
	// NetStartTime is the parameter name that represents the TCP start time.
	NetStartTime = "start_time"
	// NetEndTime is the parameter name that represents the TCP end time.
	NetEndTime = "end_time"
	// NetConnID is the parameter name that represents a unique connection identifier.
	NetConnID = "connid"
	// NetL4Proto is the parameter name that identifies the Layer 4 protocol name.
	NetL4Proto = "l4_proto"
	// NetDportName is the field that denotes the destination port name.
	NetDportName = "dport_name"
	// NetSportName is the field that denotes the source port name.
	NetSportName = "sport_name"
	// NetSIPNames is the field that denotes the source IP address names.
	NetSIPNames = "sip_names"
	// NetDIPNames is the field that denotes the destination IP address names.
	NetDIPNames = "dip_names"

	// DNSName is the field that represents the DNS query name
	DNSName = "name"
	// DNSRR is the field that represents the DNS record type
	DNSRR = "rr"
	// DNSOpts is the field that represents the DNS options
	DNSOpts = "options"
	// DNSRcode is the field that represents the DNS response code
	DNSRcode = "rcode"
	// DNSAnswers is the field that represents DNS response answers
	DNSAnswers = "answers"

	// HandleID identifies the parameter that specifies the handle identifier.
	HandleID = "handle_id"
	// HandleSourceID identifies the parameter that specifies the source handle identifier.
	HandleSourceID = "handle_source_id"
	// HandleObject identifies the parameter that represents the kernel object to which handle is associated.
	HandleObject = "handle_object"
	// HandleObjectName identifies the parameter that represents the kernel object name.
	HandleObjectName = "handle_name"
	// HandleObjectTypeID identifies the parameter that represents the kernel object type identifier.
	HandleObjectTypeID = "type_id"

	// MemBaseAddress identifies the parameter that denotes the allocation base address.
	MemBaseAddress = "base_address"
	// MemRegionSize identifies the parameter that represents the allocated region size.
	MemRegionSize = "region_size"
	// MemAllocType identifies the parameter that represents allocation flags.
	MemAllocType = "alloc_type"
	// MemProtect identifies the parameter that represents the memory protection for the range of pages.
	MemProtect = "protection"
	// MemProtectMask identifies the parameter that represents the memory protection in mask notation
	MemProtectMask = "protection_mask"
	// MemPageType identifies the parameter that represents the allocated region type.
	MemPageType = "page_type"

	// LinkSource identifies the parameter that represents the source symbolic link object or other kernel object
	LinkSource = "source"
	// LinkTarget identifies the parameter that represents the target symbolic link object or other kernel object
	LinkTarget = "target"

	// ThreadpoolPoolID represents the thread pool identifier.
	ThreadpoolPoolID = "pool_id"
	// ThreadpoolTaskID represents the thread pool task identifier.
	ThreadpoolTaskID = "task_id"
	// ThreadpoolCallback represents the address of the callback function.
	ThreadpoolCallback = "callback"
	// ThreadpoolCallbackSymbol represents the callback symbol.
	ThreadpoolCallbackSymbol = "callback_symbol"
	// ThreadpoolCallbackModule represents the module containing the callback symbol.
	ThreadpoolCallbackModule = "callback_module"
	// ThreadpoolContext represents the address of the callback context.
	ThreadpoolContext = "context"
	// ThreadpoolContextRip represents the value of instruction pointer contained in the callback context.
	ThreadpoolContextRip = "context_rip"
	// ThreadpoolContextRipSymbol represents the symbol name associated with the instruction pointer in callback context.
	ThreadpoolContextRipSymbol = "context_rip_symbol"
	// ThreadpoolContextRipModule represents the module name associated with the instruction pointer in callback context.
	ThreadpoolContextRipModule = "context_rip_module"
	// ThreadpoolSubprocessTag represents the service identifier associated with the thread pool.
	ThreadpoolSubprocessTag = "subprocess_tag"
	// ThreadpoolTimerDuetime represents the timer due time.
	ThreadpoolTimerDuetime = "duetime"
	// ThreadpoolTimerSubqueue represents the memory address of the timer subqueue.
	ThreadpoolTimerSubqueue = "subqueue"
	// ThreadpoolTimer represents the memory address of the timer object.
	ThreadpoolTimer = "timer"
	// ThreadpoolTimerPeriod represents the period of the timer
	ThreadpoolTimerPeriod = "period"
	// ThreadpoolTimerWindow represents the timer tolerate period.
	ThreadpoolTimerWindow = "window"
	// ThreadpoolTimerAbsolute indicates if the timer is absolute or relative.
	ThreadpoolTimerAbsolute = "absolute"
)

```

`pkg/event/params/types.go`:

```go
/*
 * Copyright 2021-present by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package params

const (
	// NA defines absent parameter's value
	NA = "na"
)

// Value defines the container for parameter values
type Value interface{}

```

`pkg/event/params/types_windows.go`:

```go
/*
 * Copyright 2021-present by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package params

// Type defines event parameter type
type Type uint16

const (
	// Null is a null parameter type
	Null Type = iota
	// UnicodeString a string of 16-bit characters. By default, assumed to have been encoded using UTF-16LE
	UnicodeString
	// AnsiString a string of 8-bit characters
	AnsiString
	// Int8 a signed 8-bit integer
	Int8
	// Uint8 an unsigned 8-bit integer
	Uint8
	// Int16 a signed 16-bit integer
	Int16
	// Uint16 an unsigned 16-bit integer
	Uint16
	// Int32 a signed 32-bit integer
	Int32
	// Uint32 an unsigned 32-bit integer
	Uint32
	// Int64 a signed 64-bit integer
	Int64
	// Uint64 an unsigned 64-bit integer
	Uint64
	// Float an IEEE 4-byte floating-point number
	Float
	// Double an IEEE 8-byte floating-point number
	Double
	// Bool a 32-bit value where 0 is false and 1 is true
	Bool
	// Binary is a binary data of variable size. The size must be specified in the data definition as a constant or a reference to another (integer) data item.For an IP V6 address, the data should be an IN6_ADDR structure.
	// For a socket address, the data should be a SOCKADDR_STORAGE structure. The AF_INET, AF_INET6, and AF_LINK address families are supported
	Binary
	// GUID is a GUID structure. On output, the GUID is rendered in the registry string form, {xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx}
	GUID
	// Pointer an unsigned 32-bit or 64-bit pointer value. The size depends on the architecture of the computer logging the event
	Pointer
	// SID a security identifier (SID) structure that uniquely identifies a user or group
	SID
	// PID is the process identifier
	PID
	// TID is the thread identifier
	TID
	// WbemSID is the Web-Based Enterprise Management security identifier.
	WbemSID
	// Port represents the endpoint port number
	Port
	// IP is the IP address
	IP
	// IPv4 is the IPv4 address
	IPv4
	// IPv6 is the IPv6 address
	IPv6
	// Time represents the timestamp
	Time
	// Slice represents a collection of items
	Slice
	// Enum represents an enumeration
	Enum
	// Map represents a map
	Map
	// Object is the generic object type
	Object
	// DOSPath represents the file system path in DOS device notation
	DOSPath
	// Path represents the file system path with normalized drive letter notation
	Path
	// Status represents the system error code message
	Status
	// Key represents the registry key
	Key
	// Flags represents a bitmask of flags
	Flags
	// Flags64 represents an extended (64 bits) bitmask of flags
	Flags64
	// Address is the memory address reference
	Address
	// HandleType represents the handle type such as Mutex or File
	HandleType
)

// String return the type string representation.
func (t Type) String() string {
	switch t {
	case UnicodeString:
		return "unicode"
	case AnsiString:
		return "ansi"
	case Int8:
		return "int8"
	case Uint8:
		return "uint8"
	case Int16:
		return "int16"
	case Uint16:
		return "uint16"
	case Int32:
		return "int32"
	case Uint32:
		return "uint32"
	case Int64:
		return "int64"
	case Uint64:
		return "uint64"
	case SID, WbemSID:
		return "sid"
	case TID:
		return "tid"
	case PID:
		return "pid"
	case Port:
		return "port"
	case IPv6:
		return "ipv6"
	case IPv4:
		return "ipv4"
	default:
		return "unknown"
	}
}

```

`pkg/event/queue.go`:

```go
/*
 * Copyright 2021-2022 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package event

import (
	"expvar"
)

// eventsEnqueued counts the number of events that are pushed to the queue
var eventsEnqueued = expvar.NewInt("eventsource.events.enqueued")

// Listener is the minimal interface that all event listeners need to implement.
type Listener interface {
	// ProcessEvent receives the event and returns a boolean value
	// indicating if the event should continue the processing journey.
	// In case any errors occur during processing, this method returns
	// the error and stops further event processing.
	ProcessEvent(*Event) (bool, error)
	// CanEnqueue indicates if the event listener is capable of
	// submitting the event to the output queue if the ProcessEvent
	// method returns true. In general, processors that merely
	// mutate or enrich event state, shouldn't influence event
	// queueing decisions.
	CanEnqueue() bool
}

// Queue is the channel-backed data structure for
// pushing captured events and invoking listeners.
type Queue struct {
	q               chan *Event
	listeners       []Listener
	decorator       *StackwalkDecorator
	stackEnrichment bool
	enqueueAlways   bool
}

// NewQueue constructs a new queue with the given channel size.
func NewQueue(size int, stackEnrichment bool, enqueueAlways bool) *Queue {
	q := &Queue{
		q:               make(chan *Event, size),
		listeners:       make([]Listener, 0),
		stackEnrichment: stackEnrichment,
		enqueueAlways:   enqueueAlways,
	}
	q.decorator = NewStackwalkDecorator(q)
	return q
}

// NewQueueWithChannel constructs a new queue with a custom channel.
func NewQueueWithChannel(ch chan *Event, stackEnrichment bool, enqueueAlways bool) *Queue {
	q := &Queue{
		q:               ch,
		listeners:       make([]Listener, 0),
		stackEnrichment: stackEnrichment,
		enqueueAlways:   enqueueAlways,
	}
	q.decorator = NewStackwalkDecorator(q)
	return q
}

// RegisterListener registers a new queue event listener. The listener
// is invoked before the event is pushed to the queue.
func (q *Queue) RegisterListener(listener Listener) {
	q.listeners = append(q.listeners, listener)
}

// Events returns the channel with all queued events.
func (q *Queue) Events() <-chan *Event { return q.q }

// Close closes the queue disposing allocated resources.
func (q *Queue) Close() { q.decorator.Stop() }

// Push pushes a new event to the channel. Prior to
// sending the event to the channel, all registered
// listeners are invoked. The event is sent to the
// channel if one of the listeners agrees so and no
// errors are thrown. If the event depends on the state
// of subsequent events, then we store it in the backlog
// cache. The event is fetched from the backlog cache if
// the matching event arrives, i.e. that backlog key holds
// the value that was used to index the delayed event in the
// backlog.
// It is also the responsibility of the event queue to perform
// callstack enrichment if enabled. We first
// check if the current event is eligible for stack
// enrichment. If such condition is given, the event
// is pushed into callstack decorator FIFO queue.
// The stack return addresses are stored inside StackWalk
// event which is published after the acting event.
// Then, the originating event is popped from the queue,
// enriched with callstack parameter and forwarded to the
// event queue.
func (q *Queue) Push(e *Event) error {
	if q.stackEnrichment {
		// store pending event for callstack enrichment
		if e.Type.CanEnrichStack() {
			q.decorator.Push(e)
			return nil
		}
		// decorate events with callstack return addresses
		if e.IsStackWalk() {
			e = q.decorator.Pop(e)
		}
	}
	// drop stack walk events
	if e.IsStackWalk() {
		return nil
	}
	return q.push(e)
}

func (q *Queue) push(e *Event) error {
	var enqueue bool
	if q.enqueueAlways {
		enqueue = true
	}
	for _, listener := range q.listeners {
		enq, err := listener.ProcessEvent(e)
		if err != nil {
			return err
		}
		if listener.CanEnqueue() && enq {
			enqueue = true
		}
	}
	if q.stackEnrichment && e.IsTerminateThread() {
		id := uint64(e.Params.MustGetPid() + e.Params.MustGetTid())
		q.decorator.RemoveBucket(id)
	}
	if enqueue || len(q.listeners) == 0 {
		q.q <- e
		eventsEnqueued.Add(1)
	}
	return nil
}

```

`pkg/event/queue_test.go`:

```go
/*
 * Copyright 2021-2022 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package event

import (
	"errors"
	"testing"
	"time"

	"github.com/rabbitstack/fibratus/pkg/event/params"
	"github.com/rabbitstack/fibratus/pkg/fs"
	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/mock"
)

// AddParamListener receives the event and appends a parameter to it
type AddParamListener struct {
	mock.Mock
}

func (l *AddParamListener) CanEnqueue() bool { return true }

func (l *AddParamListener) ProcessEvent(e *Event) (bool, error) {
	args := l.Called(e)
	e.AppendParam(params.FileAttributes, params.AnsiString, "HIDDEN")
	return args.Bool(0), args.Error(1)
}

// DummyListener listeners just lets the event pass through
type DummyListener struct{}

func (l *DummyListener) CanEnqueue() bool { return true }

func (l *DummyListener) ProcessEvent(e *Event) (bool, error) {
	return true, nil
}

var ErrCantEnqueue = errors.New("cannot push event into the queue")

func TestQueuePush(t *testing.T) {
	var tests = []struct {
		name          string
		e             *Event
		err           error
		listeners     func() []Listener
		enqueueAlways bool
		isEnqueued    bool
	}{
		{
			"push event ok",
			&Event{
				Type:      CreateFile,
				Tid:       2484,
				PID:       859,
				CPU:       1,
				Seq:       2,
				Name:      "CreateFile",
				Timestamp: time.Now(),
				Category:  File,
				Params: Params{
					params.FileObject:    {Name: params.FileObject, Type: params.Uint64, Value: uint64(12456738026482168384)},
					params.FilePath:      {Name: params.FilePath, Type: params.UnicodeString, Value: "C:\\Windows\\system32\\user32.dll"},
					params.FileType:      {Name: params.FileType, Type: params.AnsiString, Value: "file"},
					params.FileOperation: {Name: params.FileOperation, Type: params.Enum, Value: uint32(1), Enum: fs.FileCreateDispositions},
				},
			},
			nil,
			func() []Listener {
				l := &AddParamListener{}
				l.On("ProcessEvent", mock.Anything).Return(true, nil)
				return []Listener{l}
			},
			true,
			true,
		},
		{
			"push event listener error",
			&Event{
				Type:      CreateFile,
				Tid:       2484,
				PID:       859,
				CPU:       1,
				Seq:       2,
				Name:      "CreateFile",
				Timestamp: time.Now(),
				Category:  File,
				Params: Params{
					params.FileObject:    {Name: params.FileObject, Type: params.Uint64, Value: uint64(12456738026482168384)},
					params.FilePath:      {Name: params.FilePath, Type: params.UnicodeString, Value: "C:\\Windows\\system32\\user32.dll"},
					params.FileType:      {Name: params.FileType, Type: params.AnsiString, Value: "file"},
					params.FileOperation: {Name: params.FileOperation, Type: params.Enum, Value: uint32(1), Enum: fs.FileCreateDispositions},
				},
			},
			ErrCantEnqueue,
			func() []Listener {
				l := &AddParamListener{}
				l.On("ProcessEvent", mock.Anything).Return(true, ErrCantEnqueue)
				return []Listener{l}
			},
			true,
			false,
		},
		{
			"push event one listener allows",
			&Event{
				Type:      CreateFile,
				Tid:       2484,
				PID:       859,
				CPU:       1,
				Seq:       2,
				Name:      "CreateFile",
				Timestamp: time.Now(),
				Category:  File,
				Params: Params{
					params.FileObject:    {Name: params.FileObject, Type: params.Uint64, Value: uint64(12456738026482168384)},
					params.FilePath:      {Name: params.FilePath, Type: params.UnicodeString, Value: "C:\\Windows\\system32\\user32.dll"},
					params.FileType:      {Name: params.FileType, Type: params.AnsiString, Value: "file"},
					params.FileOperation: {Name: params.FileOperation, Type: params.Enum, Value: uint32(1), Enum: fs.FileCreateDispositions},
				},
			},
			nil,
			func() []Listener {
				l1, l2 := &AddParamListener{}, &AddParamListener{}
				l1.On("ProcessEvent", mock.Anything).Return(true, nil)
				l2.On("ProcessEvent", mock.Anything).Return(false, nil)
				return []Listener{l1, l2}
			},
			false,
			true,
		},
		{
			"push event listeners deny",
			&Event{
				Type:      CreateFile,
				Tid:       2484,
				PID:       859,
				CPU:       1,
				Seq:       2,
				Name:      "CreateFile",
				Timestamp: time.Now(),
				Category:  File,
				Params: Params{
					params.FileObject:    {Name: params.FileObject, Type: params.Uint64, Value: uint64(12456738026482168384)},
					params.FilePath:      {Name: params.FilePath, Type: params.UnicodeString, Value: "C:\\Windows\\system32\\user32.dll"},
					params.FileType:      {Name: params.FileType, Type: params.AnsiString, Value: "file"},
					params.FileOperation: {Name: params.FileOperation, Type: params.Enum, Value: uint32(1), Enum: fs.FileCreateDispositions},
				},
			},
			nil,
			func() []Listener {
				l1, l2 := &AddParamListener{}, &AddParamListener{}
				l1.On("ProcessEvent", mock.Anything).Return(false, nil)
				l2.On("ProcessEvent", mock.Anything).Return(false, nil)
				return []Listener{l1, l2}
			},
			false,
			false,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			q := NewQueue(100, false, tt.enqueueAlways)
			for _, lis := range tt.listeners() {
				q.RegisterListener(lis)
			}
			err := q.Push(tt.e)
			assert.Equal(t, err, tt.err)
			if tt.isEnqueued {
				assert.True(t, tt.e.Params.Contains(params.FileAttributes))
			}
			assert.True(t, len(q.Events()) > 0 == tt.isEnqueued)
		})
	}
}

```

`pkg/event/sequencer_windows.go`:

```go
/*
 * Copyright 2019-2020 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package event

import (
	"errors"
	"expvar"
	"fmt"
	"github.com/rabbitstack/fibratus/pkg/util/multierror"
	"golang.org/x/sys/windows/registry"
	"os"
	"sync/atomic"
	"syscall"
	"time"
)

const (
	// seqVName is the name of the registry value that stores the QWORD sequence.
	seqVName   = "EventSequence"
	invalidKey = registry.Key(syscall.InvalidHandle)
)

var seqStoreErrors = expvar.NewInt("event.seq.store.errors")
var seqInitErrors = expvar.NewMap("event.seq.init.errors")
var errInvalidVolatileKey = errors.New("couldn't open HKCU/Volatile Environment key")

// Sequencer is responsible for incrementing, getting and persisting the event sequence number in the Windows registry.
type Sequencer struct {
	key  registry.Key
	quit chan struct{}
	seq  uint64
}

// NewSequencer creates a fresh event sequencer. If the `EventSequence` value is present under the volatile key, the current
// sequence number is initialized to the last stored sequence. The sequencer schedules a ticker that periodically dumps
// the current sequence number into the registry value.
func NewSequencer() *Sequencer {
	access := uint32(registry.QUERY_VALUE | registry.SET_VALUE)
	key, err := registry.OpenKey(registry.CURRENT_USER, "Volatile Environment", access)
	if err != nil {
		seqInitErrors.Add(err.Error(), 1)
		return &Sequencer{key: invalidKey, quit: make(chan struct{}, 1)}
	}
	s := &Sequencer{
		key:  key,
		quit: make(chan struct{}, 1),
		seq:  uint64(0),
	}
	s.seq, _, _ = key.GetIntegerValue(seqVName)

	go s.store()

	return s
}

// Store saves the current sequence value in the registry.
func (s *Sequencer) Store() error {
	if s.key == invalidKey {
		// try to open the key again
		var err error
		access := uint32(registry.QUERY_VALUE | registry.SET_VALUE)
		s.key, err = registry.OpenKey(registry.CURRENT_USER, "Volatile Environment", access)
		if err != nil {
			return errInvalidVolatileKey
		}
	}
	nextSeq := s.Get()
	prevSeq, _, err := s.key.GetIntegerValue(seqVName)
	if err == nil && nextSeq < prevSeq {
		return fmt.Errorf("current sequence number %d is lower than registry value %d", nextSeq, prevSeq)
	}
	return s.key.SetQWordValue(seqVName, nextSeq)
}

// Increment increments the sequence number atomically.
func (s *Sequencer) Increment() {
	atomic.AddUint64(&s.seq, 1)
}

// Get returns the current sequence number.
func (s *Sequencer) Get() uint64 {
	return atomic.LoadUint64(&s.seq)
}

// Reset removes the sequence value from the registry and sets the sequence number to zero.
func (s *Sequencer) Reset() error {
	atomic.StoreUint64(&s.seq, 0)
	if s.key == invalidKey {
		return errInvalidVolatileKey
	}
	err := s.key.DeleteValue(seqVName)
	if err != nil {
		if !os.IsNotExist(err) {
			return err
		}
	}
	return nil
}

// Close shutdowns the event sequencer.
func (s *Sequencer) Close() error {
	s.quit <- struct{}{}
	return s.key.Close()
}

// Shutdown stores the sequence and closes the event sequencer.
func (s *Sequencer) Shutdown() error {
	return multierror.Wrap(s.Store(), s.Close())
}

// store periodically dumps the sequence number into registry value.
func (s *Sequencer) store() {
	ticker := time.NewTicker(time.Second * 5)
	for {
		select {
		case <-ticker.C:
			if err := s.Store(); err != nil {
				seqStoreErrors.Add(1)
			}
		case <-s.quit:
			ticker.Stop()
			return
		}
	}
}

```

`pkg/event/sequencer_windows_test.go`:

```go
/*
 * Copyright 2019-2020 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package event

import (
	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/require"
	"testing"
)

func TestSequencer(t *testing.T) {
	sequencer := NewSequencer()
	require.NoError(t, sequencer.Reset())
	sequencer.seq = 0
	defer sequencer.Close()

	for i := 0; i < 10; i++ {
		sequencer.Increment()
	}
	assert.Equal(t, uint64(10), sequencer.Get())
	require.NoError(t, sequencer.Store())

	sequencer = NewSequencer()
	defer sequencer.Close()
	assert.Equal(t, uint64(10), sequencer.Get())

	require.NoError(t, sequencer.Reset())
	assert.Equal(t, uint64(0), sequencer.Get())
}

func TestSequencerMonotonic(t *testing.T) {
	sequencer := NewSequencer()
	require.NoError(t, sequencer.Reset())
	sequencer.seq = 0
	defer sequencer.Close()

	for i := 0; i < 10; i++ {
		sequencer.Increment()
	}
	require.NoError(t, sequencer.Store())

	sequencer = NewSequencer()
	defer sequencer.Close()
	sequencer.seq = uint64(0)

	require.Error(t, sequencer.Store())
	require.NoError(t, sequencer.Reset())
}

```

`pkg/event/stackwalk.go`:

```go
/*
 * Copyright 2021-present by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package event

import (
	"expvar"
	"sync"
	"time"

	"github.com/rabbitstack/fibratus/pkg/event/params"
	"github.com/rabbitstack/fibratus/pkg/util/multierror"
	log "github.com/sirupsen/logrus"
)

// maxQueueTTLPeriod specifies the maximum period
// for the events to reside in the queue.
var maxQueueTTLPeriod = time.Second * 10

// flusherInterval specifies the interval for the queue flushing.
var flusherInterval = time.Second * 5

// stackwalkFlushes computes overall flushes for unmatched stackwalk events
var stackwalkFlushes = expvar.NewInt("stackwalk.flushes")

// stackwalkFlushesProcs computes overall flushes for unmatched stackwalk events per process
var stackwalkFlushesProcs = expvar.NewMap("stackwalk.flushes.procs")

// stackwalkFlushesEvents computes overall flushes for unmatched stackwalks per event type
var stackwalkFlushesEvents = expvar.NewMap("stackwalk.flushes.events")

// stackwalkEnqueued counts the number of enqueued events in individual buckets
var stackwalkEnqueued = expvar.NewInt("stackwalk.enqueued")

// stackwalkBuckets counts the number of overall stackwalk buckets per stack id
var stackwalkBuckets = expvar.NewInt("stackwalk.buckets")

// StackwalkDecorator maintains a FIFO queue where events
// eligible for stack enrichment are queued. Upon arrival
// of the respective stack walk event, the acting event is
// popped from the queue and enriched with return addresses
// which are later subject to symbolization.
type StackwalkDecorator struct {
	buckets map[uint64][]*Event
	q       *Queue
	mux     sync.Mutex

	flusher *time.Ticker
	quit    chan struct{}

	procs map[uint32]*Event // stores CreateProcess events with surrogate parent
}

// NewStackwalkDecorator creates a new callstack return
// addresses decorator which receives the event queue
// for long-standing event flushing.
func NewStackwalkDecorator(q *Queue) *StackwalkDecorator {
	s := &StackwalkDecorator{
		q:       q,
		buckets: make(map[uint64][]*Event),
		procs:   make(map[uint32]*Event),
		flusher: time.NewTicker(flusherInterval),
		quit:    make(chan struct{}, 1),
	}

	go s.doFlush()

	return s
}

// Push pushes a new event to the queue.
func (s *StackwalkDecorator) Push(e *Event) {
	s.mux.Lock()
	defer s.mux.Unlock()

	// the process is created on behalf of brokered
	// process and the callstack return addresses
	// need to be obtained from the surrogate process
	if e.IsSurrogateProcess() {
		s.procs[e.Params.MustGetPid()] = e
	}

	// append the event to the bucket indexed by stack id
	id := e.StackID()
	q, ok := s.buckets[id]
	if !ok {
		s.buckets[id] = []*Event{e}
	} else {
		s.buckets[id] = append(q, e)
	}

	stackwalkBuckets.Set(int64(len(s.buckets)))
	stackwalkEnqueued.Add(int64(len(s.buckets[id])))
}

// Pop receives the stack walk event and pops the oldest
// originating event with the same pid,tid tuple formerly
// coined as stack identifier. The originating event is then
// decorated with callstack return addresses.
func (s *StackwalkDecorator) Pop(e *Event) *Event {
	s.mux.Lock()
	defer s.mux.Unlock()

	id := e.StackID()
	q, ok := s.buckets[id]
	if !ok {
		return e
	}

	var evt *Event
	if len(q) > 0 {
		evt, s.buckets[id] = q[0], q[1:]
		stackwalkEnqueued.Add(-int64(len(s.buckets[id])))
	}

	if evt == nil {
		return e
	}

	if evt.IsSurrogateProcess() && s.procs[evt.Params.MustGetPid()] != nil {
		delete(s.procs, evt.Params.MustGetPid())
	}

	callstack := e.Params.MustGetSlice(params.Callstack)
	evt.AppendParam(params.Callstack, params.Slice, callstack)

	// obtain the callstack from the CreateThread event
	// generated by the surrogate/brokered process, such as
	// Secondary Logon.
	// If the remote process id is present in the procs map
	// the stack is attached to the cached event and then
	// pushed to the queue immediately
	if evt.IsCreateRemoteThread() {
		pid := evt.Params.MustGetPid()
		ev, ok := s.procs[pid]
		if ok {
			ev.AppendParam(params.Callstack, params.Slice, callstack)
			_ = s.q.push(ev)
			delete(s.procs, pid)
			// find the most recent CreateProcess event and
			// remove it from buckets as we have the callstack
			qu := s.buckets[ev.StackID()]
			for i := len(qu) - 1; i >= 0; i-- {
				proc := qu[i]
				if !proc.IsCreateProcess() && proc.Params.MustGetPid() != pid {
					continue
				}
				qu = append(qu[:i], qu[i+1:]...)
			}
			s.buckets[ev.StackID()] = qu
		}
	}

	return evt
}

// Stop shutdowns the stack walk decorator flusher.
func (s *StackwalkDecorator) Stop() {
	s.quit <- struct{}{}
}

// RemoveBucket removes the bucket and all enqueued events.
func (s *StackwalkDecorator) RemoveBucket(id uint64) {
	s.mux.Lock()
	defer s.mux.Unlock()
	delete(s.buckets, id)
	stackwalkBuckets.Set(int64(len(s.buckets)))
}

func (s *StackwalkDecorator) doFlush() {
	for {
		select {
		case <-s.flusher.C:
			errs := s.flush()
			if len(errs) > 0 {
				log.Warnf("callstack: unable to flush queued events: %v", multierror.Wrap(errs...))
			}
		case <-s.quit:
			return
		}
	}
}

// flush pushes events to the event queue if they have
// been living in the queue more than the maximum allowed
// TTL period.
func (s *StackwalkDecorator) flush() []error {
	s.mux.Lock()
	defer s.mux.Unlock()

	if len(s.buckets) == 0 {
		return nil
	}

	errs := make([]error, 0)

	for id, q := range s.buckets {
		n := make([]*Event, 0, len(q))
		for _, evt := range q {
			if time.Since(evt.Timestamp) < maxQueueTTLPeriod {
				n = append(n, evt)
				continue
			}

			stackwalkFlushes.Add(1)
			err := s.q.push(evt)
			if err != nil {
				errs = append(errs, err)
			}
			if stackwalkEnqueued.Value() > 0 {
				stackwalkEnqueued.Add(-1)
			}
			if evt.PS != nil {
				stackwalkFlushesProcs.Add(evt.PS.Name, 1)
			}
			stackwalkFlushesEvents.Add(evt.Name, 1)
		}
		if len(n) == 0 {
			delete(s.buckets, id)
		} else {
			s.buckets[id] = n
		}
	}

	return errs
}

```

`pkg/event/stackwalk_test.go`:

```go
/*
 * Copyright 2021-present by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package event

import (
	"testing"
	"time"

	"github.com/rabbitstack/fibratus/pkg/event/params"
	"github.com/rabbitstack/fibratus/pkg/fs"
	pstypes "github.com/rabbitstack/fibratus/pkg/ps/types"
	"github.com/rabbitstack/fibratus/pkg/util/va"
	"github.com/stretchr/testify/assert"
)

func TestStackwalkDecorator(t *testing.T) {
	q := NewQueue(50, false, true)
	cd := NewStackwalkDecorator(q)

	e := &Event{
		Type:      CreateFile,
		Tid:       2484,
		PID:       859,
		CPU:       1,
		Seq:       2,
		Name:      "CreateFile",
		Timestamp: time.Now(),
		Category:  File,
		Params: Params{
			params.FileObject:    {Name: params.FileObject, Type: params.Uint64, Value: uint64(12456738026482168384)},
			params.FilePath:      {Name: params.FilePath, Type: params.UnicodeString, Value: "C:\\Windows\\system32\\user32.dll"},
			params.FileType:      {Name: params.FileType, Type: params.AnsiString, Value: "file"},
			params.FileOperation: {Name: params.FileOperation, Type: params.Enum, Value: uint32(1), Enum: fs.FileCreateDispositions},
		},
	}

	e1 := &Event{
		Type:      CreateFile,
		Tid:       2484,
		PID:       859,
		CPU:       1,
		Seq:       3,
		Name:      "CreateFile",
		Timestamp: time.Now(),
		Category:  File,
		Params: Params{
			params.FileObject:    {Name: params.FileObject, Type: params.Uint64, Value: uint64(12456738026482168384)},
			params.FilePath:      {Name: params.FilePath, Type: params.UnicodeString, Value: "C:\\Windows\\system32\\kernel32.dll"},
			params.FileType:      {Name: params.FileType, Type: params.AnsiString, Value: "file"},
			params.FileOperation: {Name: params.FileOperation, Type: params.Enum, Value: uint32(1), Enum: fs.FileCreateDispositions},
		},
	}

	cd.Push(e)
	cd.Push(e1)

	assert.Len(t, cd.buckets[e.StackID()], 2)

	sw := &Event{
		Type:      StackWalk,
		Tid:       2484,
		PID:       859,
		CPU:       1,
		Seq:       4,
		Name:      "StackWalk",
		Timestamp: time.Now(),
		Params: Params{
			params.Callstack: {Name: params.Callstack, Type: params.Slice, Value: []va.Address{0x7ffb5eb70dc4, 0x7ffb5c191deb, 0x7ffb3138592e}},
		},
	}

	evt := cd.Pop(sw)
	assert.Len(t, cd.buckets[e.StackID()], 1)
	assert.Equal(t, CreateFile, evt.Type)
	assert.True(t, evt.Params.Contains(params.Callstack))
	assert.Equal(t, "C:\\Windows\\system32\\user32.dll", evt.GetParamAsString(params.FilePath))
}

func TestStackwalkDecoratorSurrogateProcess(t *testing.T) {
	q := NewQueue(50, false, true)
	cd := NewStackwalkDecorator(q)

	e := &Event{
		Type:      CreateProcess,
		Tid:       2484,
		PID:       859,
		CPU:       1,
		Seq:       2,
		Name:      "CreateProcess",
		Timestamp: time.Now(),
		Category:  Process,
		Params: Params{
			params.ProcessID:           {Name: params.ProcessID, Type: params.PID, Value: uint32(859)},
			params.ProcessParentID:     {Name: params.ProcessParentID, Type: params.PID, Value: uint32(4523)},
			params.ProcessRealParentID: {Name: params.ProcessRealParentID, Type: params.PID, Value: uint32(8846)},
		},
	}

	e1 := &Event{
		Type:      CreateThread,
		Tid:       2484,
		PID:       1411,
		CPU:       1,
		Seq:       3,
		Name:      "CreateThread",
		Timestamp: time.Now(),
		Category:  Thread,
		PS: &pstypes.PS{
			Name:    "svchost.exe",
			Exe:     `C:\WINDOWS\system32\svchost.exe`,
			Cmdline: `C:\WINDOWS\system32\svchost.exe -k netsvcs -p -s seclogon`,
		},
		Params: Params{
			params.ProcessID: {Name: params.ProcessID, Type: params.PID, Value: uint32(859)},
		},
	}

	cd.Push(e)

	assert.Len(t, cd.buckets[e.StackID()], 1)
	assert.Len(t, cd.buckets[e1.StackID()], 0)
	assert.Len(t, cd.procs, 1)

	cd.Push(e1)
	assert.Len(t, cd.buckets[e1.StackID()], 1)

	sw := &Event{
		Type:      StackWalk,
		Tid:       2484,
		PID:       1411,
		CPU:       1,
		Seq:       4,
		Name:      "StackWalk",
		Timestamp: time.Now(),
		Params: Params{
			params.Callstack: {Name: params.Callstack, Type: params.Slice, Value: []va.Address{0x7ffb5eb70dc4, 0x7ffb5c191deb, 0x7ffb3138592e}},
		},
	}

	thread := cd.Pop(sw)
	proc := <-q.Events()
	assert.Equal(t, CreateProcess, proc.Type)
	assert.Equal(t, CreateThread, thread.Type)
	assert.Len(t, cd.buckets[e.StackID()], 0)
	assert.Len(t, cd.buckets[e1.StackID()], 0)
	assert.True(t, proc.Params.Contains(params.Callstack))
	assert.True(t, thread.Params.Contains(params.Callstack))
}

func init() {
	maxQueueTTLPeriod = time.Second * 2
	flusherInterval = time.Second
}

func TestStackwalkDecoratorFlush(t *testing.T) {
	q := NewQueue(50, false, true)
	q.RegisterListener(&DummyListener{})
	cd := NewStackwalkDecorator(q)
	defer cd.Stop()

	e := &Event{
		Type:      CreateFile,
		Tid:       2484,
		PID:       859,
		CPU:       1,
		Seq:       2,
		Name:      "CreateFile",
		Timestamp: time.Now(),
		Category:  File,
		Params: Params{
			params.FileObject:    {Name: params.FileObject, Type: params.Uint64, Value: uint64(12456738026482168384)},
			params.FilePath:      {Name: params.FilePath, Type: params.UnicodeString, Value: "C:\\Windows\\system32\\user32.dll"},
			params.FileType:      {Name: params.FileType, Type: params.AnsiString, Value: "file"},
			params.FileOperation: {Name: params.FileOperation, Type: params.Enum, Value: uint32(1), Enum: fs.FileCreateDispositions},
		},
	}

	cd.Push(e)
	assert.Len(t, cd.buckets[e.StackID()], 1)
	time.Sleep(time.Millisecond * 3100)

	evt := <-q.Events()
	assert.Len(t, cd.buckets[e.StackID()], 0)
	assert.Equal(t, CreateFile, evt.Type)
	assert.False(t, evt.Params.Contains(params.Callstack))
}

```

`pkg/event/template.go`:

```go
/*
 * Copyright 2021-2022 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package event

import (
	"bytes"
	"fmt"
	"text/template"
)

// Template is the default Go template used for formatting events in textual format.
var Template = `Name:  		{{ .Evt.Name }}
Sequence: 		{{ .Evt.Seq }}
Description:    {{ .Evt.Description }}
Process ID:		{{ .Evt.PID }}
Thread ID: 		{{ .Evt.Tid }}
Params:			{{ .Evt.Params }}

{{- if .Evt.PS }}

Process:		{{ .Evt.PS.Name }}
Exe:			{{ .Evt.PS.Exe }}
Pid:  			{{ .Evt.PS.PID }}
Ppid: 			{{ .Evt.PS.Ppid }}
Cmdline:		{{ .Evt.PS.Cmdline }}
Cwd:			{{ .Evt.PS.Cwd }}
SID:			{{ .Evt.PS.SID }}
User:           {{ .Evt.PS.Username }}
Domain:         {{ .Evt.PS.Domain }}
Session ID:		{{ .Evt.PS.SessionID }}
{{ if and (.SerializeEnvs) (.Evt.PS.Envs) }}
Env:
			{{- with .Evt.PS.Envs }}
			{{- range $k, $v := . }}
			{{ $k }}: {{ $v }}
			{{- end }}
			{{- end }}
{{ end }}
{{ if .SerializeThreads }}
Threads:
			{{- with .Evt.PS.Threads }}
			{{- range . }}
			{{ . }}
			{{- end }}
			{{- end }}
{{ end }}
{{ if .SerializeImages }}
Modules:
			{{- with .Evt.PS.Modules }}
			{{- range . }}
			{{ . }}
			{{- end }}
			{{- end }}
{{ end }}
{{ if and (.SerializeHandles) (.Evt.PS.Handles) }}
Handles:
			{{- with .Evt.PS.Handles }}
			{{- range . }}
			{{ . }}
			{{- end }}
			{{- end }}
{{ end }}

{{ if and (.SerializePE) (.Evt.PS.PE) }}
Entrypoint:  		{{ .Evt.PS.PE.EntryPoint }}
Image base: 		{{ .Evt.PS.PE.ImageBase }}
Build date:  		{{ .Evt.PS.PE.LinkTime }}

Number of symbols: 	{{ .Evt.PS.PE.NumberOfSymbols }}
Number of sections: {{ .Evt.PS.PE.NumberOfSections }}

Sections:
			{{- with .Evt.PS.PE.Sections }}
			{{- range . }}
			{{ . }}
			{{- end }}
			{{- end }}
{{ if .Evt.PS.PE.Symbols }}
Symbols:
			{{- with .Evt.PS.PE.Symbols }}
			{{- range . }}
			{{ . }}
			{{- end }}
			{{- end }}
{{ end }}
{{ if .Evt.PS.PE.Imports }}
Imports:
			{{- with .Evt.PS.PE.Imports }}
			{{- range . }}
			{{ . }}
			{{- end }}
			{{- end }}
{{ end }}
{{ if .Evt.PS.PE.VersionResources }}
Resources:
			{{- with .Evt.PS.PE.VersionResources }}
			{{- range $k, $v := . }}
			{{ $k }}: {{ $v }}
			{{- end }}
			{{- end }}
			{{ end }}
{{ end }}
{{- end }}
`

// RenderDefaultTemplate returns the event string representation
// after applying the default Go template.
func (e *Event) RenderDefaultTemplate() ([]byte, error) {
	tmpl, err := template.New("event").Parse(Template)
	if err != nil {
		return nil, err
	}
	return renderTemplate(e, tmpl)
}

// RenderCustomTemplate returns the event string representation
// after applying the given Go template.
func (e *Event) RenderCustomTemplate(tmpl *template.Template) ([]byte, error) {
	return renderTemplate(e, tmpl)
}

func renderTemplate(evt *Event, tmpl *template.Template) ([]byte, error) {
	var writer bytes.Buffer
	data := struct {
		Evt              *Event
		SerializeHandles bool
		SerializeThreads bool
		SerializeImages  bool
		SerializeEnvs    bool
		SerializePE      bool
	}{
		evt,
		SerializeHandles,
		SerializeThreads,
		SerializeImages,
		SerializeEnvs,
		SerializePE,
	}
	err := tmpl.Execute(&writer, data)
	if err != nil {
		return nil, fmt.Errorf("unable to render event template: %v", err)
	}
	return writer.Bytes(), nil
}

```

`pkg/event/types_windows.go`:

```go
/*
 * Copyright 2019-2020 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package event

import (
	"encoding/binary"
	"github.com/rabbitstack/fibratus/pkg/sys/etw"
	"github.com/rabbitstack/fibratus/pkg/util/hashers"
	"golang.org/x/sys/windows"
)

// Source is the type that designates the provenance of the event
type Source uint8

const (
	// SystemLogger event is emitted by the system provider
	SystemLogger Source = iota
	// SecurityTelemetryLogger event is emitted by the combination of multiple providers.
	// Most notably, DNS, thread pool, and kernel audit API providers are in charge of
	// publishing the events.
	SecurityTelemetryLogger
)

// Type identifies an event type. It comprises the event GUID + hook ID to uniquely identify the event
type Type [18]byte

var (
	// ProcessEventGUID represents process provider event GUID
	ProcessEventGUID = windows.GUID{Data1: 0x3d6fa8d0, Data2: 0xfe05, Data3: 0x11d0, Data4: [8]byte{0x9d, 0xda, 0x0, 0xc0, 0x4f, 0xd7, 0xba, 0x7c}}
	// ThreadEventGUID represents thread provider event GUID
	ThreadEventGUID = windows.GUID{Data1: 0x3d6fa8d1, Data2: 0xfe05, Data3: 0x11d0, Data4: [8]byte{0x9d, 0xda, 0x0, 0xc0, 0x4f, 0xd7, 0xba, 0x7c}}
	// ImageEventGUID represents image provider event GUID
	ImageEventGUID = windows.GUID{Data1: 0x2cb15d1d, Data2: 0x5fc1, Data3: 0x11d2, Data4: [8]byte{0xab, 0xe1, 0x0, 0xa0, 0xc9, 0x11, 0xf5, 0x18}}
	// FileEventGUID represents file provider event GUID
	FileEventGUID = windows.GUID{Data1: 0x90cbdc39, Data2: 0x4a3e, Data3: 0x11d1, Data4: [8]byte{0x84, 0xf4, 0x0, 0x0, 0xf8, 0x04, 0x64, 0xe3}}
	// RegistryEventGUID represents registry provider event GUID
	RegistryEventGUID = windows.GUID{Data1: 0xae53722e, Data2: 0xc863, Data3: 0x11d2, Data4: [8]byte{0x86, 0x59, 0x0, 0xc0, 0x4f, 0xa3, 0x21, 0xa1}}
	// NetworkTCPEventGUID represents network TCP provider event GUID
	NetworkTCPEventGUID = windows.GUID{Data1: 0x9a280ac0, Data2: 0xc8e0, Data3: 0x11d1, Data4: [8]byte{0x84, 0xe2, 0x0, 0xc0, 0x4f, 0xb9, 0x98, 0xa2}}
	// NetworkUDPEventGUID represents network UDP provider event GUID
	NetworkUDPEventGUID = windows.GUID{Data1: 0xbf3a50c5, Data2: 0xa9c9, Data3: 0x4988, Data4: [8]byte{0xa0, 0x05, 0x2d, 0xf0, 0xb7, 0xc8, 0x0f, 0x80}}
	// HandleEventGUID represents handle provider event GUID
	HandleEventGUID = windows.GUID{Data1: 0x89497f50, Data2: 0xeffe, Data3: 0x4440, Data4: [8]byte{0x8c, 0xf2, 0xce, 0x6b, 0x1c, 0xdc, 0xac, 0xa7}}
	// MemEventGUID represents memory provider event GUID
	MemEventGUID = windows.GUID{Data1: 0x3d6fa8d3, Data2: 0xfe05, Data3: 0x11d0, Data4: [8]byte{0x9d, 0xda, 0x00, 0xc0, 0x4f, 0xd7, 0xba, 0x7c}}
	// AuditAPIEventGUID represents audit API calls event GUID
	AuditAPIEventGUID = windows.GUID{Data1: 0xe02a841c, Data2: 0x75a3, Data3: 0x4fa7, Data4: [8]byte{0xaf, 0xc8, 0xae, 0x09, 0xcf, 0x9b, 0x7f, 0x23}}
	// DNSEventGUID represents DNS provider event GUID
	DNSEventGUID = windows.GUID{Data1: 0x1c95126e, Data2: 0x7eea, Data3: 0x49a9, Data4: [8]byte{0xa3, 0xfe, 0xa3, 0x78, 0xb0, 0x3d, 0xdb, 0x4d}}
	// ThreadpoolGUID represents the thread pool event GUID
	ThreadpoolGUID = windows.GUID{Data1: 0xc861d0e2, Data2: 0xa2c1, Data3: 0x4d36, Data4: [8]byte{0x9f, 0x9c, 0x97, 0x0b, 0xab, 0x94, 0x3a, 0x12}}
	// ProcessKernelEventGUID represents the Process Kernel event GUID
	ProcessKernelEventGUID = windows.GUID{Data1: 0x22fb2cd6, Data2: 0x0e7b, Data3: 0x422b, Data4: [8]byte{0xa0, 0xc7, 0x2f, 0xad, 0x1f, 0xd0, 0xe7, 0x16}}
	// RegistryKernelEventGUID represents the Registry Kernel event GUID
	RegistryKernelEventGUID = windows.GUID{Data1: 0x70eb4f03, Data2: 0xc1de, Data3: 0x4f73, Data4: [8]byte{0xa0, 0x51, 0x33, 0xd1, 0x3d, 0x54, 0x13, 0xbd}}
)

var (
	// CreateProcess identifies process creation kernel events
	CreateProcess = pack(ProcessEventGUID, 1)
	// TerminateProcess identifies process termination kernel events
	TerminateProcess = pack(ProcessEventGUID, 2)
	// ProcessRundown represents the start data collection process event that enumerates processes that are currently running at the time the kernel session starts
	ProcessRundown = pack(ProcessEventGUID, 3)
	// OpenProcess identifies the kernel events that are triggered when the process handle is acquired
	OpenProcess = pack(AuditAPIEventGUID, 5)
	// CreateProcessInternal identifies the process creation event emitted by the Microsoft Windows Kernel Process provider.
	// The only purpose of this event is to enrich the process state with some extra attributes, and populates the snapshotter
	// for events running in the Security Telemetry session that might miss process lookups because the core NT Kernel Provider
	// hasn't still published the CreateProcess or ProcessRundown event
	CreateProcessInternal = pack(ProcessKernelEventGUID, 1)
	// ProcessRundownInternal same as above but for process rundown events originating from the Microsoft Windows Kernel Process provider.
	ProcessRundownInternal = pack(ProcessKernelEventGUID, 15)

	// CreateThread identifies thread creation kernel events
	CreateThread = pack(ThreadEventGUID, 1)
	// TerminateThread identifies thread termination kernel events
	TerminateThread = pack(ThreadEventGUID, 2)
	// ThreadRundown represents the start data collection thread event that enumerates threads that are currently running at the time the kernel session starts
	ThreadRundown = pack(ThreadEventGUID, 3)
	// OpenThread identifies the kernel events that are triggered when the process acquires a thread handle
	OpenThread = pack(AuditAPIEventGUID, 6)
	// SetThreadContext identifies the kernel event that is fired when the thread context is changed
	SetThreadContext = pack(AuditAPIEventGUID, 4)

	// MapViewFile represents events that map a view of a file mapping into the address space of a calling process
	MapViewFile = pack(FileEventGUID, 37)
	// UnmapViewFile represents events that unmap a view of a file mapping from the address space of a calling process
	UnmapViewFile = pack(FileEventGUID, 38)
	// MapFileRundown represents the event that is emitted at the start of the tracing session to enumerate I/O mapped files
	MapFileRundown = pack(FileEventGUID, 39)

	// FileRundown events are generated by kernel rundown logger to enumerate all open files on the start of the kernel session
	FileRundown = pack(FileEventGUID, 36)
	// CreateFile represents events that create/open a file or I/O device
	CreateFile = pack(FileEventGUID, 64)
	// ReleaseFile represents events that occur when the last file handle is disposed
	ReleaseFile = pack(FileEventGUID, 65)
	// CloseFile represents events that dispose existing kernel file objects
	CloseFile = pack(FileEventGUID, 66)
	// ReadFile represents events that read data from the file or I/O device
	ReadFile = pack(FileEventGUID, 67)
	// WriteFile represents events that write data to the file or I/O device
	WriteFile = pack(FileEventGUID, 68)
	// SetFileInformation represents events that set file information
	SetFileInformation = pack(FileEventGUID, 69)
	// DeleteFile identifies file deletion events
	DeleteFile = pack(FileEventGUID, 70)
	// RenameFile identifies events that are responsible for renaming files
	RenameFile = pack(FileEventGUID, 71)
	// EnumDirectory identifies enumerate directory and directory notification events
	EnumDirectory = pack(FileEventGUID, 72)
	// FileOpEnd signals the finalization of the file operation
	FileOpEnd = pack(FileEventGUID, 76)

	// RegCreateKey represents registry key creation kernel events
	RegCreateKey = pack(RegistryEventGUID, 10)
	// RegOpenKey represents registry open key kernel events
	RegOpenKey = pack(RegistryEventGUID, 11)
	// RegCloseKey represents registry close key kernel event.
	RegCloseKey = pack(RegistryEventGUID, 27)
	// RegDeleteKey represents registry key deletion kernel events
	RegDeleteKey = pack(RegistryEventGUID, 12)
	// RegQueryKey represents registry query key kernel events
	RegQueryKey = pack(RegistryEventGUID, 13)
	// RegSetValue represents registry set value kernel events
	RegSetValue = pack(RegistryEventGUID, 14)
	// RegDeleteValue are kernel events for registry value removals
	RegDeleteValue = pack(RegistryEventGUID, 15)
	// RegQueryValue are kernel events for registry value queries
	RegQueryValue = pack(RegistryEventGUID, 16)
	// RegCreateKCB represents kernel events for KCB (Key Control Block) creation requests
	RegCreateKCB = pack(RegistryEventGUID, 22)
	// RegDeleteKCB represents kernel events for KCB(Key Control Block) closures
	RegDeleteKCB = pack(RegistryEventGUID, 23)
	// RegKCBRundown enumerates the registry keys open at the start of the kernel session.
	RegKCBRundown = pack(RegistryEventGUID, 25)
	// RegSetValueInternal is the internal event that is used to
	// enrich the corresponding public RegSetValue event with
	// extra attributes
	RegSetValueInternal = pack(RegistryKernelEventGUID, 36)

	// UnloadImage represents unload image kernel events
	UnloadImage = pack(ImageEventGUID, 2)
	// ImageRundown represents kernel events that is triggered to enumerate all loaded images
	ImageRundown = pack(ImageEventGUID, 3)
	// LoadImage represents load image kernel events that are triggered when a DLL or executable file  is loaded
	LoadImage = pack(ImageEventGUID, 10)
	// LoadImageInternal same as for process internal event originating from the Microsoft Windows Kernel Process provider.
	LoadImageInternal = pack(ProcessKernelEventGUID, 5)

	// AcceptTCPv4 represents the TCPv4 kernel events for accepting connection requests from the socket queue.
	AcceptTCPv4 = pack(NetworkTCPEventGUID, 15)
	// AcceptTCPv6 represents the TCPv6 kernel events for accepting connection requests from the socket queue.
	AcceptTCPv6 = pack(NetworkTCPEventGUID, 31)
	// SendTCPv4 represents the TCPv4 kernel events for sending data to the connected socket.
	SendTCPv4 = pack(NetworkTCPEventGUID, 10)
	// SendTCPv6 represents the TCPv6 kernel events for sending data to the connected socket.
	SendTCPv6 = pack(NetworkTCPEventGUID, 26)
	// SendUDPv4 represents the UDPv4 kernel events for sending datagrams to connectionless sockets.
	SendUDPv4 = pack(NetworkUDPEventGUID, 10)
	// SendUDPv6 represents the UDPv6 kernel events for sending datagrams to connectionless sockets.
	SendUDPv6 = pack(NetworkUDPEventGUID, 26)
	// RecvTCPv4 represents the TCP IPv4 network receive event.
	RecvTCPv4 = pack(NetworkTCPEventGUID, 11)
	// RecvTCPv6 represents the TCP IPv6 network receive event.
	RecvTCPv6 = pack(NetworkTCPEventGUID, 27)
	// RecvUDPv4 represents the UDP IPv4 network receive event.
	RecvUDPv4 = pack(NetworkUDPEventGUID, 11)
	// RecvUDPv6 represents the UDP IPv6 network receive event.
	RecvUDPv6 = pack(NetworkUDPEventGUID, 27)
	// ConnectTCPv4 represents the TCP IPv4 network connect event.
	ConnectTCPv4 = pack(NetworkTCPEventGUID, 12)
	// ConnectTCPv6 represents the TCP IPv6 network connect event.
	ConnectTCPv6 = pack(NetworkTCPEventGUID, 28)
	// DisconnectTCPv4 is the TCP IPv4 network disconnect event.
	DisconnectTCPv4 = pack(NetworkTCPEventGUID, 13)
	// DisconnectTCPv6 is the TCP IPv6 network disconnect event.
	DisconnectTCPv6 = pack(NetworkTCPEventGUID, 29)
	// ReconnectTCPv4 is the TCP IPv4 network reconnect event.
	ReconnectTCPv4 = pack(NetworkTCPEventGUID, 16)
	// ReconnectTCPv6 is the TCP IPv6 network reconnect event.
	ReconnectTCPv6 = pack(NetworkTCPEventGUID, 32)
	// RetransmitTCPv4 is the TCP IPv4 network retransmit event.
	RetransmitTCPv4 = pack(NetworkTCPEventGUID, 14)
	// RetransmitTCPv6 is the TCP IPv6 network retransmit event.
	RetransmitTCPv6 = pack(NetworkTCPEventGUID, 30)

	// CreateHandle represents handle creation event
	CreateHandle = pack(HandleEventGUID, 32)
	// CloseHandle represents handle closure event
	CloseHandle = pack(HandleEventGUID, 33)
	// DuplicateHandle represents handle duplication event
	DuplicateHandle = pack(HandleEventGUID, 34)

	// VirtualAlloc represents virtual memory allocation event
	VirtualAlloc = pack(MemEventGUID, 98)
	// VirtualFree represents virtual memory release event
	VirtualFree = pack(MemEventGUID, 99)

	// QueryDNS represents DNS query events
	QueryDNS = pack(DNSEventGUID, 3006)
	// ReplyDNS represents the DNS response events
	ReplyDNS = pack(DNSEventGUID, 3008)

	// StackWalk represents stack walk event with the collection of return addresses
	StackWalk = pack(windows.GUID{Data1: 0xdef2fe46, Data2: 0x7bd6, Data3: 0x4b80, Data4: [8]byte{0xbd, 0x94, 0xf5, 0x7f, 0xe2, 0x0d, 0x0c, 0xe3}}, 32)

	// CreateSymbolicLinkObject represents the event emitted by the object manager when the new symbolic link is created within the object manager directory
	CreateSymbolicLinkObject = pack(AuditAPIEventGUID, 3)

	// SubmitThreadpoolWork represents the event that enqueues the work item to the thread pool
	SubmitThreadpoolWork = pack(ThreadpoolGUID, 32)
	//SubmitThreadpoolCallback represents the event that submits the thread pool callback for execution within the work item
	SubmitThreadpoolCallback = pack(ThreadpoolGUID, 34)
	// SetThreadpoolTimer represents the event that sets the thread pool timer object
	SetThreadpoolTimer = pack(ThreadpoolGUID, 44)

	// UnknownType designates unknown event type
	UnknownType = pack(windows.GUID{}, 0)
)

// NewTypeFromEventRecord creates a new event type from ETW event record.
func NewTypeFromEventRecord(ev *etw.EventRecord) Type {
	return pack(ev.Header.ProviderID, ev.HookID())
}

// String returns the string representation of the event type. Returns an empty string
// if the event type is not recognized.
func (t Type) String() string {
	switch t {
	case CreateProcess, CreateProcessInternal:
		return "CreateProcess"
	case TerminateProcess:
		return "TerminateProcess"
	case ProcessRundown, ProcessRundownInternal:
		return "ProcessRundown"
	case OpenProcess:
		return "OpenProcess"
	case CreateThread:
		return "CreateThread"
	case TerminateThread:
		return "TerminateThread"
	case ThreadRundown:
		return "ThreadRundown"
	case OpenThread:
		return "OpenThread"
	case SetThreadContext:
		return "SetThreadContext"
	case CreateFile:
		return "CreateFile"
	case CloseFile:
		return "CloseFile"
	case ReleaseFile:
		return "ReleaseFile"
	case ReadFile:
		return "ReadFile"
	case WriteFile:
		return "WriteFile"
	case SetFileInformation:
		return "SetFileInformation"
	case DeleteFile:
		return "DeleteFile"
	case RenameFile:
		return "RenameFile"
	case EnumDirectory:
		return "EnumDirectory"
	case FileOpEnd:
		return "FileOpEnd"
	case FileRundown:
		return "FileRundown"
	case MapViewFile:
		return "MapViewFile"
	case UnmapViewFile:
		return "UnmapViewFile"
	case MapFileRundown:
		return "MapFileRundown"
	case CreateHandle:
		return "CreateHandle"
	case CloseHandle:
		return "CloseHandle"
	case DuplicateHandle:
		return "DuplicateHandle"
	case RegKCBRundown:
		return "RegKCBRundown"
	case RegOpenKey:
		return "RegOpenKey"
	case RegCloseKey:
		return "RegCloseKey"
	case RegCreateKey:
		return "RegCreateKey"
	case RegDeleteKey:
		return "RegDeleteKey"
	case RegDeleteValue:
		return "RegDeleteValue"
	case RegQueryKey:
		return "RegQueryKey"
	case RegQueryValue:
		return "RegQueryValue"
	case RegCreateKCB:
		return "RegCreateKCB"
	case RegSetValue, RegSetValueInternal:
		return "RegSetValue"
	case LoadImage, LoadImageInternal:
		return "LoadImage"
	case UnloadImage:
		return "UnloadImage"
	case ImageRundown:
		return "ImageRundown"
	case AcceptTCPv4, AcceptTCPv6:
		return "Accept"
	case SendTCPv4, SendTCPv6, SendUDPv4, SendUDPv6:
		return "Send"
	case RecvTCPv4, RecvTCPv6, RecvUDPv4, RecvUDPv6:
		return "Recv"
	case ConnectTCPv4, ConnectTCPv6:
		return "Connect"
	case ReconnectTCPv4, ReconnectTCPv6:
		return "Reconnect"
	case DisconnectTCPv4, DisconnectTCPv6:
		return "Disconnect"
	case RetransmitTCPv4, RetransmitTCPv6:
		return "Retransmit"
	case VirtualAlloc:
		return "VirtualAlloc"
	case VirtualFree:
		return "VirtualFree"
	case QueryDNS:
		return "QueryDns"
	case ReplyDNS:
		return "ReplyDns"
	case StackWalk:
		return "StackWalk"
	case CreateSymbolicLinkObject:
		return "CreateSymbolicLinkObject"
	case SubmitThreadpoolWork:
		return "SubmitThreadpoolWork"
	case SubmitThreadpoolCallback:
		return "SubmitThreadpoolCallback"
	case SetThreadpoolTimer:
		return "SetThreadpoolTimer"
	default:
		return ""
	}
}

// Category determines the category to which the event type pertains.
func (t Type) Category() Category {
	switch t {
	case CreateProcess, CreateProcessInternal, TerminateProcess, OpenProcess, ProcessRundown, ProcessRundownInternal:
		return Process
	case CreateThread, TerminateThread, OpenThread, SetThreadContext, ThreadRundown, StackWalk:
		return Thread
	case LoadImage, UnloadImage, ImageRundown, LoadImageInternal:
		return Image
	case CreateFile, ReadFile, WriteFile, EnumDirectory, DeleteFile, RenameFile, CloseFile, SetFileInformation,
		FileRundown, FileOpEnd, ReleaseFile, MapViewFile, UnmapViewFile, MapFileRundown:
		return File
	case RegCreateKey, RegDeleteKey, RegOpenKey, RegCloseKey, RegQueryKey, RegQueryValue, RegSetValue, RegDeleteValue,
		RegKCBRundown, RegDeleteKCB, RegCreateKCB, RegSetValueInternal:
		return Registry
	case AcceptTCPv4, AcceptTCPv6,
		ConnectTCPv4, ConnectTCPv6,
		ReconnectTCPv4, ReconnectTCPv6,
		RetransmitTCPv4, RetransmitTCPv6,
		DisconnectTCPv4, DisconnectTCPv6,
		SendTCPv4, SendTCPv6, SendUDPv4, SendUDPv6,
		RecvTCPv4, RecvTCPv6, RecvUDPv4, RecvUDPv6,
		QueryDNS, ReplyDNS:
		return Net
	case CreateHandle, CloseHandle, DuplicateHandle:
		return Handle
	case VirtualAlloc, VirtualFree:
		return Mem
	case CreateSymbolicLinkObject:
		return Object
	case SubmitThreadpoolWork, SubmitThreadpoolCallback, SetThreadpoolTimer:
		return Threadpool
	default:
		return Unknown
	}
}

// Subcategory determines the event subcategory, if any.
func (t Type) Subcategory() Subcategory {
	switch t {
	case QueryDNS, ReplyDNS:
		return DNS
	default:
		return None
	}
}

// Description returns a brief description of the event type.
func (t Type) Description() string {
	switch t {
	case CreateProcess:
		return "Creates a new process and its primary thread"
	case TerminateProcess:
		return "Terminates the process and all of its threads"
	case OpenProcess:
		return "Opens the process handle"
	case CreateThread:
		return "Creates a thread to execute within the virtual address space of the calling process"
	case TerminateThread:
		return "Terminates a thread within the process"
	case OpenThread:
		return "Opens the thread handle"
	case SetThreadContext:
		return "Sets the thread context"
	case ReadFile:
		return "Reads data from the file or I/O device"
	case WriteFile:
		return "Writes data to the file or I/O device"
	case CreateFile:
		return "Creates or opens a file or I/O device"
	case CloseFile:
		return "Closes the file handle"
	case DeleteFile:
		return "Removes the file from the file system"
	case RenameFile:
		return "Changes the file name"
	case SetFileInformation:
		return "Sets the file meta information"
	case EnumDirectory:
		return "Enumerates a directory or dispatches a directory change notification to registered listeners"
	case MapViewFile:
		return "Maps a view of a file mapping into the address space of a calling process"
	case UnmapViewFile:
		return "Unmaps a mapped view of a file from the calling process's address space"
	case RegCreateKey:
		return "Creates a registry key or opens it if the key already exists"
	case RegOpenKey:
		return "Opens the registry key"
	case RegCloseKey:
		return "Closes the registry key"
	case RegSetValue:
		return "Sets the data for the value of a registry key"
	case RegQueryValue:
		return "Reads the data for the value of a registry key"
	case RegQueryKey:
		return "Enumerates subkeys of the parent key"
	case RegDeleteKey:
		return "Removes the registry key"
	case RegDeleteValue:
		return "Removes the registry value"
	case AcceptTCPv4, AcceptTCPv6:
		return "Accepts the connection request from the socket queue"
	case ConnectTCPv4, ConnectTCPv6:
		return "Connects establishes a connection to the socket"
	case DisconnectTCPv4, DisconnectTCPv6:
		return "Terminates data reception on the socket"
	case ReconnectTCPv4, ReconnectTCPv6:
		return "Reconnects to the socket"
	case RetransmitTCPv4, RetransmitTCPv6:
		return "Retransmits unacknowledged TCP segments"
	case SendTCPv4, SendUDPv4, SendTCPv6, SendUDPv6:
		return "Sends data over the wire"
	case RecvTCPv4, RecvUDPv4, RecvTCPv6, RecvUDPv6:
		return "Receives data from the socket"
	case LoadImage:
		return "Loads the module into the address space of the calling process"
	case UnloadImage:
		return "Unloads the module from the address space of the calling process"
	case CreateHandle:
		return "Creates a new handle"
	case CloseHandle:
		return "Closes the handle"
	case DuplicateHandle:
		return "Duplicates the handle"
	case VirtualAlloc:
		return "Reserves, commits, or changes the state of a region of memory within the process virtual address space"
	case VirtualFree:
		return "Releases or decommits a region of memory within the process virtual address space"
	case QueryDNS:
		return "Sends a DNS query to the name server"
	case ReplyDNS:
		return "Receives the response from the DNS server"
	case CreateSymbolicLinkObject:
		return "Creates the symbolic link within the object manager directory"
	case SubmitThreadpoolWork:
		return "Enqueues the work item to the thread pool"
	case SubmitThreadpoolCallback:
		return "Submits the thread pool callback for execution within the work item"
	case SetThreadpoolTimer:
		return "Sets the thread pool timer object"
	default:
		return ""
	}
}

// Hash calculates the hash number of the event type.
func (t Type) Hash() uint32 {
	if t == UnknownType {
		return 0
	}
	return hashers.FnvUint32([]byte(t.String()))
}

// Exists determines whether particular event type exists.
func (t Type) Exists() bool {
	return t.String() != ""
}

// OnlyState determines whether the event type is solely used for state management.
func (t Type) OnlyState() bool {
	switch t {
	case ProcessRundown,
		ProcessRundownInternal,
		CreateProcessInternal,
		ThreadRundown,
		ImageRundown,
		LoadImageInternal,
		FileRundown,
		RegKCBRundown,
		FileOpEnd,
		ReleaseFile,
		MapFileRundown,
		RegCreateKCB,
		RegDeleteKCB,
		RegSetValueInternal:
		return true
	default:
		return false
	}
}

// CanEnrichStack determines if the event can be enriched with a callstack.
func (t Type) CanEnrichStack() bool {
	switch t {
	case CreateProcess,
		CreateThread,
		TerminateThread,
		LoadImage,
		RegCreateKey,
		RegDeleteKey,
		RegSetValue,
		RegDeleteValue,
		DeleteFile,
		RenameFile,
		VirtualAlloc,
		SubmitThreadpoolWork,
		SubmitThreadpoolCallback,
		SetThreadpoolTimer:
		return true
	default:
		return false
	}
}

// UnmarshalYAML converts the Type name to Type array type.
func (t *Type) UnmarshalYAML(unmarshal func(interface{}) error) error {
	var typ string
	err := unmarshal(&typ)
	if err != nil {
		return err
	}
	*t = NameToType(typ)
	return nil
}

// GUID returns the event GUID from the raw event type.
func (t *Type) GUID() windows.GUID {
	return windows.GUID{
		Data1: binary.BigEndian.Uint32(t[0:4]),
		Data2: binary.BigEndian.Uint16(t[4:6]),
		Data3: binary.BigEndian.Uint16(t[6:8]),
		Data4: [8]byte{t[8], t[9], t[10], t[11], t[12], t[13], t[14], t[15]},
	}
}

// HookID returns the event operation code (hook ID) from the raw event type.
func (t *Type) HookID() uint16 {
	return binary.BigEndian.Uint16(t[16:])
}

// ID is an unsigned integer that uniquely
// identifies the event. Handy for bitmask
// operations.
func (t Type) ID() uint {
	id := uint(t[0])<<56 |
		uint(t[1])<<48 |
		uint(t[2])<<40 |
		uint(t[3])<<32 |
		uint(t[4])<<24 |
		uint(t[5])<<16 |
		uint(t.HookID())
	return id
}

// Source designates the provenance of this event type.
func (t Type) Source() Source {
	switch t.GUID() {
	case AuditAPIEventGUID, DNSEventGUID, ThreadpoolGUID, ProcessKernelEventGUID, RegistryKernelEventGUID:
		return SecurityTelemetryLogger
	default:
		return SystemLogger
	}
}

// TypeFromParts builds the event type from provider GUID and hook ID.
func TypeFromParts(g windows.GUID, id uint16) Type { return pack(g, id) }

// pack merges event provider GUID and the hook ID into `Type` array.
// The type provides a convenient way for comparing event types.
func pack(g windows.GUID, id uint16) Type {
	return [18]byte{
		byte(g.Data1 >> 24), byte(g.Data1 >> 16), byte(g.Data1 >> 8), byte(g.Data1),
		byte(g.Data2 >> 8), byte(g.Data2),
		byte(g.Data3 >> 8), byte(g.Data3),
		g.Data4[0],
		g.Data4[1],
		g.Data4[2],
		g.Data4[3],
		g.Data4[4],
		g.Data4[5],
		g.Data4[6],
		g.Data4[7],
		byte(id >> 8), byte(id),
	}
}

```

`pkg/event/types_windows_test.go`:

```go
/*
 * Copyright 2019-2020 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package event

import (
	"github.com/rabbitstack/fibratus/pkg/sys/etw"
	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/require"
	"golang.org/x/sys/windows"
	"testing"
)

func TestEventTypePackAllBytes(t *testing.T) {
	assert.Equal(t, byte(0x3d), CreateProcess[0])
	assert.Equal(t, byte(0x6f), CreateProcess[1])
	assert.Equal(t, byte(0xa8), CreateProcess[2])
	assert.Equal(t, byte(0xd0), CreateProcess[3])

	assert.Equal(t, byte(0xfe), CreateProcess[4])
	assert.Equal(t, byte(0x05), CreateProcess[5])

	assert.Equal(t, byte(0x11), CreateProcess[6])
	assert.Equal(t, byte(0xd0), CreateProcess[7])

	assert.Equal(t, byte(0x9d), CreateProcess[8])
	assert.Equal(t, byte(0xda), CreateProcess[9])
	assert.Equal(t, byte(0x0), CreateProcess[10])
	assert.Equal(t, byte(0xc0), CreateProcess[11])
	assert.Equal(t, byte(0x4f), CreateProcess[12])
	assert.Equal(t, byte(0xd7), CreateProcess[13])
	assert.Equal(t, byte(0xba), CreateProcess[14])
	assert.Equal(t, byte(0x7c), CreateProcess[15])
	assert.Equal(t, byte(0x0), CreateProcess[16])
	assert.Equal(t, byte(0x1), CreateProcess[17])

	assert.Equal(t, byte(0x0b), QueryDNS[16])
	assert.Equal(t, byte(0xbe), QueryDNS[17])
}

func TestEventTypeComparison(t *testing.T) {
	var tests = []struct {
		name  string
		ktyp  Type
		wants Type
	}{
		{
			"equals CreateProcess",
			pack(windows.GUID{Data1: 0x3d6fa8d0, Data2: 0xfe05, Data3: 0x11d0, Data4: [8]byte{0x9d, 0xda, 0x0, 0xc0, 0x4f, 0xd7, 0xba, 0x7c}}, 1),
			CreateProcess,
		},
		{
			"equals TerminateProcess",
			pack(windows.GUID{Data1: 0x3d6fa8d0, Data2: 0xfe05, Data3: 0x11d0, Data4: [8]byte{0x9d, 0xda, 0x0, 0xc0, 0x4f, 0xd7, 0xba, 0x7c}}, 2),
			TerminateProcess,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			lhs, rhs := tt.ktyp, tt.wants
			assert.Equal(t, lhs, rhs)
		})
	}
}

func TestNewEventTypeFromEventRecord(t *testing.T) {
	assert.Equal(t, CreateProcess, NewTypeFromEventRecord(&etw.EventRecord{
		Header: etw.EventHeader{
			ProviderID: windows.GUID{Data1: 0x3d6fa8d0, Data2: 0xfe05, Data3: 0x11d0, Data4: [8]byte{0x9d, 0xda, 0x0, 0xc0, 0x4f, 0xd7, 0xba, 0x7c}},
			EventDescriptor: etw.EventDescriptor{
				Opcode: 1,
			},
		},
	}))
	assert.Equal(t, OpenProcess, NewTypeFromEventRecord(&etw.EventRecord{
		Header: etw.EventHeader{
			ProviderID: windows.GUID{Data1: 0xe02a841c, Data2: 0x75a3, Data3: 0x4fa7, Data4: [8]byte{0xaf, 0xc8, 0xae, 0x09, 0xcf, 0x9b, 0x7f, 0x23}},
			EventDescriptor: etw.EventDescriptor{
				ID: 5,
			},
		},
	}))
}

func TestEventTypeExists(t *testing.T) {
	require.True(t, AcceptTCPv4.Exists())
	require.True(t, AcceptTCPv6.Exists())
}

func TestTypeID(t *testing.T) {
	assert.Equal(t, uint(14439051552138264620), SetThreadpoolTimer.ID())
}

func TestGUIDAndHookIDFromEventType(t *testing.T) {
	var tests = []struct {
		Type   Type
		opcode uint16
		guid   windows.GUID
	}{
		{
			LoadImage,
			10,
			windows.GUID{Data1: 0x2cb15d1d, Data2: 0x5fc1, Data3: 0x11d2, Data4: [8]byte{0xab, 0xe1, 0x0, 0xa0, 0xc9, 0x11, 0xf5, 0x18}},
		},
		{
			WriteFile,
			68,
			windows.GUID{Data1: 0x90cbdc39, Data2: 0x4a3e, Data3: 0x11d1, Data4: [8]byte{0x84, 0xf4, 0x0, 0x0, 0xf8, 0x04, 0x64, 0xe3}},
		},
	}

	for _, tt := range tests {
		t.Run(tt.Type.String(), func(t *testing.T) {
			assert.Equal(t, tt.guid.String(), tt.Type.GUID().String())
			assert.Equal(t, tt.opcode, tt.Type.HookID())
		})
	}
}

func TestIDEquality(t *testing.T) {
	evt := etw.EventRecord{Header: etw.EventHeader{ProviderID: ThreadEventGUID, EventDescriptor: etw.EventDescriptor{Opcode: 1}}}
	typ := CreateThread
	require.Equal(t, typ.ID(), evt.ID())
}

func TestEventTypeIDCollision(t *testing.T) {
	ids := make(map[uint]Type)
	for _, typ := range AllWithState() {
		if etype, ok := ids[typ.ID()]; ok {
			t.Fatalf("id collision for %s event type. Mapped event type: %s", typ.String(), etype.String())
		}
		ids[typ.ID()] = typ
	}
}

```

`pkg/filament/_fixtures/test_filter.py`:

```py
# Copyright 2016 by Nedim Sabic (RabbitStack)
# All Rights Reserved.
# http://rabbitstack.github.io

# Licensed under the Apache License, Version 2.0 (the "License"); you may
# not use this file except in compliance with the License. You may obtain
# a copy of the License at
#
# http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
# WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
# License for the specific language governing permissions and limitations
# under the License.

"""
Tests the filter expression.
"""

events = []

def on_init():
    set_filter('ps.name in (%s)' % ','.join(["'svchost.exe'", "'cmd.exe'", "'mimikatz.exe'"]))

def on_next_event(event):
    pass

```

`pkg/filament/_fixtures/test_on_next_event.py`:

```py
# Copyright 2016 by Nedim Sabic (RabbitStack)
# All Rights Reserved.
# http://rabbitstack.github.io

# Licensed under the Apache License, Version 2.0 (the "License"); you may
# not use this file except in compliance with the License. You may obtain
# a copy of the License at
#
# http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
# WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
# License for the specific language governing permissions and limitations
# under the License.

"""
Tests the on_next_event function.
"""

events = []

def on_init():
    interval(1)
    columns(['Key', '#Seq'])
    sort_by('#Seq')

def on_next_event(event):
    events.append({'key_name': event['params']['key_name'], 'seq': event['seq'], 'dip': event['params']['dip']})

def on_interval():
    for key in events:
        add_row([key['key_name'], key['seq']])
    render_table()

```

`pkg/filament/_fixtures/top_hives_io.py`:

```py
# Copyright 2016 by Nedim Sabic (RabbitStack)
# All Rights Reserved.
# http://rabbitstack.github.io

# Licensed under the Apache License, Version 2.0 (the "License"); you may
# not use this file except in compliance with the License. You may obtain
# a copy of the License at
#
# http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
# WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
# License for the specific language governing permissions and limitations
# under the License.

"""
Shows top registry hives by I/O activity.
"""

import collections

hives = collections.Counter()


def on_init():
    interval(4)
    columns(['Hive', "1", ["d"]])
    sort_by("1")


def on_next_event(event):
    pass


```

`pkg/filament/_fixtures/top_keys_io_table.py`:

```py
# Copyright 2016 by Nedim Sabic (RabbitStack)
# All Rights Reserved.
# http://rabbitstack.github.io

# Licensed under the Apache License, Version 2.0 (the "License"); you may
# not use this file except in compliance with the License. You may obtain
# a copy of the License at
#
# http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
# WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
# License for the specific language governing permissions and limitations
# under the License.

"""
Shows top registry keys by I/O activity.
"""

import collections

keys = collections.Counter()


def on_init():
    interval(1)
    columns(['Key', '#Ops'])
    sort_by('#Ops')


def on_next_event(event):
    pass


def on_interval():
    keys.update(("HKLM\\SYSTEM\\ControlSet001\\Services\\WinSock2\\Parameters\\Protocol_Catalog9",))
    keys.update(("HKLM\\SYSTEM\\ControlSet001\\Services\\WinSock2\\Parameters\\Protocol_Catalog9",))
    keys.update(("HKLM\\SYSTEM\\ControlSet001\\Services\\WinSock2\\Parameters\\Protocol_Catalog9",))
    keys.update(("HKLM\\SYSTEM\\ControlSet001\\Control\\Nls\\Sorting\\Ids",))
    for key, count in keys.items():
        add_row([key, count])
    render_table()
```

`pkg/filament/cpython/_fixtures/top_hives_io.py`:

```py
# Copyright 2016 by Nedim Sabic (RabbitStack)
# All Rights Reserved.
# http://rabbitstack.github.io

# Licensed under the Apache License, Version 2.0 (the "License"); you may
# not use this file except in compliance with the License. You may obtain
# a copy of the License at
#
# http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
# WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
# License for the specific language governing permissions and limitations
# under the License.

"""
Shows top registry hives by I/O activity.
"""

import collections

hives = collections.Counter()


def on_init():
    set_interval(2)
    print("on_init")
    #set_filter('RegOpenKey or proc.name=java')
    #columns(["Hive", "#Ops"])
    #sort_by('#Ops')
    #set_interval(1)


def on_next_event(event):
    print("Event\n", event["params"])
    #raise Exception('eggs', 'eggs')

def on_interval():
    for hive, count in hives.items():
        add_row([hive, count])
    render_tabular()

def sum(v):
    return 1 + 1
```

`pkg/filament/cpython/api.c`:

```c
/*
 *	Copyright 2019-2020 by Nedim Sabic
 *	http://rabbitstack.github.io
 *	All Rights Reserved.
 *
 *	Licensed under the Apache License, Version 2.0 (the "License"); you may
 *	not use this file except in compliance with the License. You may obtain
 *	a copy of the License at
 *
 *	http://www.apache.org/licenses/LICENSE-2.0
 */

#include "api.h"

int PyArg_ParseInt(PyObject *args, int n) {
    int i;
    int res;
    switch (n) {
    case 1:
        res = PyArg_ParseTuple(args, "i", &i);
        break;
    case 2:
        res = PyArg_ParseTuple(args, "Oi", &i, &i);
        break;
    case 3:
        res = PyArg_ParseTuple(args, "OOi", &i, &i, &i);
        break;
    default:
        return i;
    }
    if (!res) {
        PyErr_SetString(PyExc_ValueError, "argument must be an integer");
        return 0;
    }
    return i;
}

PyObject* PyArg_ParseList(PyObject *args, int n) {
    PyObject *ob;
    int res;
    switch (n) {
    case 1:
        res = PyArg_ParseTuple(args, "O!", &PyList_Type, &ob);
        break;
    case 2:
        res = PyArg_ParseTuple(args, "OO!", &ob, &PyList_Type, &ob);
        break;
    case 3:
        res = PyArg_ParseTuple(args, "OOO!", &ob, &ob, &PyList_Type, &ob);
        break;
    default:
        return NULL;
    }
    if (!res) {
        PyErr_SetString(PyExc_ValueError, "argument must be a list");
        return NULL;
    }
    return ob;
}

PyObject* PyArg_ParseString(PyObject *args, int n) {
    PyObject *ob;
    int res;
    switch (n) {
    case 1:
        res = PyArg_ParseTuple(args, "U", &ob);
        break;
    case 2:
        res = PyArg_ParseTuple(args, "OU", &ob, &ob);
        break;
    case 3:
        res = PyArg_ParseTuple(args, "OOU", &ob, &ob, &ob);
        break;
    default:
        return NULL;
    }
    if (!res) {
        PyErr_SetString(PyExc_ValueError, "argument must be a string");
        return NULL;
    }
    return ob;
}

void PyArg_ParseKeywords(PyObject *args, PyObject *kwargs, char *kwlist[], PyObject **ob1,  PyObject **ob2,  PyObject **ob3,  PyObject **ob4) {
    int res;

    res = PyArg_ParseTupleAndKeywords(args,
                                      kwargs,
                                      "OO|$OO", kwlist,
                                      ob1, ob2, ob3, ob4);
    if (!res) {
        PyErr_SetString(PyExc_ValueError, "parse keywords failed");
    }
}

PyObject* PyTime_FromDateTime(int year, int month, int day, int hour, int minute, int second, int usecond) {
    return PyDateTime_FromDateAndTime(year, month, day, hour, minute, second, usecond);
}

PyObject* PyChar_FromChar(char v) {
    return Py_BuildValue("b", v);
}

PyObject* PyChar_FromUnsignedChar(unsigned char v) {
    return Py_BuildValue("B", v);
}

PyObject* PyShort_FromShort(short v) {
    return Py_BuildValue("h", v);
}

PyObject* PyShort_FromUnsignedShort(unsigned short v) {
    return Py_BuildValue("H", v);
}

bool Py_IsUnicode(PyObject *ob) {
    if (ob == NULL)
      return false;
    return PyUnicode_CheckExact(ob);
}

bool Py_IsInteger(PyObject *ob) {
    if (ob == NULL)
       return false;
    return PyLong_CheckExact(ob);
}

void Py_DateTimeImport() {
    PyDateTime_IMPORT;
}


bool Py_IsDateTime(PyObject *ob) {
    if (ob == NULL)
       return false;
    return PyDateTime_CheckExact(ob);
}

const char* Py_Type(PyObject *ob) {
    return Py_TYPE(ob)->tp_name;
}

int PyDate_GetYear(PyObject *ob) {
    return PyDateTime_GET_YEAR(ob);
}
int PyDate_GetMonth(PyObject *ob) {
    return PyDateTime_GET_MONTH(ob);
}
int PyDate_GetDay(PyObject *ob) {
    return PyDateTime_GET_DAY(ob);
}
int PyDate_GetHour(PyObject *ob) {
    return PyDateTime_DATE_GET_HOUR(ob);
}
int PyDate_GetMinute(PyObject *ob) {
    return PyDateTime_DATE_GET_MINUTE(ob);
}
int PyDate_GetSecond(PyObject *ob) {
    return PyDateTime_DATE_GET_SECOND(ob);
}
int PyDate_GetMicroSecond(PyObject *ob) {
    return PyDateTime_DATE_GET_MICROSECOND(ob);
}
```

`pkg/filament/cpython/api.h`:

```h
/*
 *	Copyright 2019-2020 by Nedim Sabic
 *	http://rabbitstack.github.io
 *	All Rights Reserved.
 *
 *	Licensed under the Apache License, Version 2.0 (the "License"); you may
 *	not use this file except in compliance with the License. You may obtain
 *	a copy of the License at
 *
 *	http://www.apache.org/licenses/LICENSE-2.0
 */

#include <Python.h>
#include <string.h>
#include <stdbool.h>
#include "datetime.h"

typedef char i8;
typedef unsigned char u8;
typedef short i16;
typedef unsigned short u16;
typedef long i32;
typedef long long i64;
typedef unsigned long long u64;
typedef unsigned long u32;

/*
Cgo doesn't know how to deal with C macros/variadic functions. This is the main reason we need the wrapper for
some CPython API functions in pure C.
*/

int PyArg_ParseInt(PyObject *args, int n);
PyObject* PyArg_ParseString(PyObject *args, int n);
PyObject* PyArg_ParseList(PyObject *args, int n);

void PyArg_ParseKeywords(PyObject *args, PyObject *kwargs, char *kwlist[], PyObject **ob1,  PyObject **ob2,  PyObject **ob3,  PyObject **ob4);

PyObject* PyTime_FromDateTime(int year, int month, int day, int hour, int minute, int second, int usecond);
PyObject* PyChar_FromChar(char v);
PyObject* PyChar_FromUnsignedChar(unsigned char v);
PyObject* PyShort_FromShort(short v);
PyObject* PyShort_FromUnsignedShort(unsigned short v);

bool Py_IsUnicode(PyObject *ob);
bool Py_IsInteger(PyObject *ob);
bool Py_IsDateTime(PyObject *ob);

void Py_DateTimeImport();

int PyDate_GetYear(PyObject *ob);
int PyDate_GetMonth(PyObject *ob);
int PyDate_GetDay(PyObject *ob);
int PyDate_GetHour(PyObject *ob);
int PyDate_GetMinute(PyObject *ob);
int PyDate_GetSecond(PyObject *ob);
int PyDate_GetMicroSecond(PyObject *ob);

const char* Py_Type(PyObject *ob);
```

`pkg/filament/cpython/dict.go`:

```go
//go:build filament && windows
// +build filament,windows

/*
 * Copyright 2019-2020 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package cpython

/*
#include "api.h"
*/
import "C"

// Dict represents the abstraction over the Python dictionary object.
type Dict struct {
	*PyObject
}

// NewDict constructs a new empty dictionary object.
func NewDict() *Dict {
	return &Dict{PyObject: &PyObject{rawptr: C.PyDict_New()}}
}

// NewDictFromObject constructs a new dictionary object from the existing dictionary.
func NewDictFromObject(o *PyObject) *Dict {
	return &Dict{PyObject: o}
}

// Insert inserts a value into the dictionary indexed with a key. Key must be hashable, otherwise TypeError is raised.
func (d *Dict) Insert(k, v *PyObject) {
	C.PyDict_SetItem(d.rawptr, k.rawptr, v.rawptr)
}

// Get returns the object from dictionary with the provided key. Returns a null object if the key key is not present,
// but without setting an exception.
func (d *Dict) Get(k *PyObject) *PyObject {
	return &PyObject{rawptr: C.PyDict_GetItem(d.rawptr, k.rawptr)}
}

// Object returns the underlying Python object reference.
func (d *Dict) Object() *PyObject {
	return d.PyObject
}

```

`pkg/filament/cpython/dict_test.go`:

```go
//go:build filament && windows
// +build filament,windows

/*
 * Copyright 2019-2020 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package cpython

import (
	"github.com/magiconair/properties/assert"
	"github.com/stretchr/testify/require"
	"testing"
)

func TestDict(t *testing.T) {
	t.SkipNow()
	dict := NewDict()
	require.False(t, dict.IsNull())

	dict.Insert(PyUnicodeFromString("filename"), PyUnicodeFromString("C:\\Windows\\System32\\kernel32.dll"))
	v := dict.Get(PyUnicodeFromString("filename"))
	require.NotNil(t, v)

	assert.Equal(t, `C:\Windows\System32\kernel32.dll`, v.String())
}

```

`pkg/filament/cpython/errors.go`:

```go
//go:build filament && windows
// +build filament,windows

/*
 * Copyright 2019-2020 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package cpython

/*
#include "api.h"
*/
import "C"
import (
	"errors"
	"sync"
)

var once sync.Once
var formatException *PyObject

// FetchErr retrieves the error indicator into three variables whose addresses are passed. If the error indicator is not
// set, set all three variables to NULL. If it is set, it will be cleared and you own a reference to each object retrieved.
// The value and traceback object may be NULL even when the type object is not.
func FetchErr() error {
	if C.PyErr_Occurred() == nil {
		// error indicator not set, nothing to do
		return nil
	}

	exc := &PyObject{}
	val := &PyObject{}
	traceback := &PyObject{}
	defer exc.DecRef()
	defer val.DecRef()
	defer traceback.DecRef()

	C.PyErr_Fetch(&exc.rawptr, &val.rawptr, &traceback.rawptr)
	//  normalize exception values as per python C API
	C.PyErr_NormalizeException(&exc.rawptr, &val.rawptr, &traceback.rawptr)

	if !traceback.IsNull() {
		once.Do(func() {
			tb, _ := NewModule("traceback")
			if tb != nil {
				formatException, _ = tb.GetAttrString("format_exception")
			}
		})
		if !formatException.IsNull() {
			ob := formatException.Call(exc, val, traceback)
			if !ob.IsNull() {
				defer ob.DecRef()
				return errors.New(ob.String())
			}
		}
		return errors.New("can't format traceback exception")
	}
	if !val.IsNull() {
		return errors.New(val.String())
	}
	if !exc.IsNull() {
		return errors.New(exc.String())
	}
	return nil
}

// ClearError clears the error indicator.
func ClearError() {
	C.PyErr_Clear()
}

// CheckSignals checks the signal queue.
func CheckSignals() bool {
	return C.PyErr_CheckSignals() == -1
}

```

`pkg/filament/cpython/gil.go`:

```go
//go:build filament && windows
// +build filament,windows

/*
 * Copyright 2019-2020 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package cpython

/*
#include "api.h"
*/
import "C"
import (
	"runtime"
	"sync/atomic"
)

// PyGILState is the type alias for the native Python GIL state
type PyGILState C.PyGILState_STATE

// GIL is responsible for interacting with the Python GIL. Goroutines are executed on
// multiple threads and the scheduler might decide to pause the goroutine on one thread
// and resume it later in a different thread. This would cause catastrophic effects if
// the Python interpreter finds out the GIL was acquired in one thread but released in a
// different one. We have to provide extra safety to avoid runtime crashes at the cost of
// sacrificing some performance since we'll always stick the goroutine to be scheduled on
// the same thread.
type GIL struct {
	locked uint32
	state  PyGILState
	tstate *C.PyThreadState
}

// NewGIL creates a new instance of the GIL manager.
func NewGIL() *GIL {
	return &GIL{}
}

// SaveThread releases the global interpreter lock (if it has been created and thread
// support is enabled) and reset the thread state to NULL, returning the
// previous thread state (which is not NULL).
func (g *GIL) SaveThread() {
	g.tstate = C.PyEval_SaveThread()
}

// RestoreThread acquire the global interpreter lock (if it has been created and thread
// support is enabled) and set the thread state to tstate, which must not be
// NULL. If the lock has been created, the current thread must not have
// acquired it, otherwise deadlock ensues.
func (g *GIL) RestoreThread() {
	C.PyEval_RestoreThread(g.tstate)
}

// Lock acquires the GIL lock by ensuring the current thread is ready to call Python C API.
func (g *GIL) Lock() {
	runtime.LockOSThread()
	atomic.StoreUint32(&g.locked, 1)
	g.state = PyGILState(C.PyGILState_Ensure())
}

// Unlock releases the lock on the GIL.
func (g *GIL) Unlock() {
	atomic.StoreUint32(&g.locked, 0)
	C.PyGILState_Release(C.PyGILState_STATE(g.state))
	runtime.UnlockOSThread()
}

// Locked indicates if the lock on the GIL was acquired.
func (g *GIL) Locked() bool {
	return atomic.LoadUint32(&g.locked) > 0
}

```

`pkg/filament/cpython/gil_test.go`:

```go
//go:build filament && windows
// +build filament,windows

/*
 * Copyright 2019-2020 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package cpython

import (
	"testing"

	"github.com/stretchr/testify/require"
)

func TestGILLock(t *testing.T) {
	t.SkipNow()
	require.NoError(t, Initialize())
	defer Finalize()
	gil := NewGIL()
	gil.Lock()
	require.True(t, gil.Locked())
}

func TestGILUnlock(t *testing.T) {
	// failing non-deterministically in CI
	t.SkipNow()
	require.NoError(t, Initialize())
	defer Finalize()
	gil := NewGIL()
	gil.Lock()
	require.True(t, gil.Locked())
	gil.Unlock()
	require.False(t, gil.Locked())
}

```

`pkg/filament/cpython/interpreter.go`:

```go
//go:build filament && windows
// +build filament,windows

/*
 * Copyright 2019-2020 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package cpython

/*
#cgo pkg-config: python-37

#include "api.h"

*/
import "C"
import (
	"github.com/pkg/errors"
	log "github.com/sirupsen/logrus"
	"syscall"
	"unsafe"
)

// ErrPyInit signals that an error ocurred while initializing the Python interpreter
var ErrPyInit = errors.New("couldn't initialize the Python interpreter")

// ErrGILInit indicates that the global interpreter lock failed to initialize
var ErrGILInit = errors.New("unable to initialize the GIL")

// Initialize initializes the Python interpreter and its global interpreter lock (GIL).
func Initialize() error {
	if C.Py_IsInitialized() == 0 {
		// initialize the interpreter without signal handlers
		C.Py_InitializeEx(0)
	}
	if C.Py_IsInitialized() == 0 {
		return ErrPyInit
	}
	if C.PyEval_ThreadsInitialized() == 0 {
		C.PyEval_InitThreads()
	}
	if C.PyEval_ThreadsInitialized() == 0 {
		return ErrGILInit
	}
	// this calls into PyDateTime_IMPORT macro to initialize the PyDateTimeAPI
	C.Py_DateTimeImport()

	if err := initializeIPFnAndClasses(); err != nil {
		log.Warn(err)
	}

	return nil
}

// Finalize undos all initializations made by Initialize() and subsequent use of Python/C API functions,
// and destroys all sub-interpreters that were created and not yet destroyed since the last call to Initialize().
// Ideally, this frees all memory allocated by the Python interpreter.
func Finalize() {
	C.Py_Finalize()
}

// AddPythonPath adds a new path to the PYTHONPATH environment variable.
func AddPythonPath(path string) {
	syspath := C.CString("path")
	defer C.free(unsafe.Pointer(syspath))
	newPath := PyUnicodeFromString(path)
	defer newPath.DecRef()
	C.PyList_Append(C.PySys_GetObject(syspath), newPath.rawptr)
}

// SetPath sets the default module search path. If this function is called before Py_Initialize(), then Py_GetPath()
// won’t attempt to compute a default search path but uses the one provided instead. This is useful if Python is
// embedded by an application that has full knowledge of the location of all modules.
func SetPath(path string) {
	w, err := syscall.UTF16FromString(path)
	if err != nil {
		return
	}
	C.Py_SetPath((*C.wchar_t)(&w[0]))
}

// SetSysArgv sets sys.argv based on argc and argv. These parameters are similar to those passed to
// the program’s main() function with the difference that the first entry should refer to the script
// file to be executed rather than the executable hosting the Python interpreter. If there isn’t a
// script that will be run, the first entry in argv can be an empty string. If this function fails
// to initialize sys.argv, a fatal condition is signalled using Py_FatalError().
func SetSysArgv(args []string) {
	argc := C.int(len(args))
	argv := make([]*C.wchar_t, argc)
	for i, arg := range args {
		argv[i] = newWarg(arg)
	}
	C.PySys_SetArgvEx(argc, (**C.wchar_t)(unsafe.Pointer(&argv[0])), 0)
}

func newWarg(arg string) *C.wchar_t {
	carg := C.CString(arg)
	defer C.free(unsafe.Pointer(carg))

	warg := C.Py_DecodeLocale(carg, nil)
	if warg == nil {
		return nil
	}
	// Py_DecodeLocale requires a call to PyMem_RawFree to free the memory
	defer C.PyMem_RawFree(unsafe.Pointer(warg))
	return warg
}

```

`pkg/filament/cpython/interpreter_test.go`:

```go
//go:build filament && windows
// +build filament,windows

/*
 * Copyright 2019-2020 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package cpython

import (
	"github.com/stretchr/testify/require"
	"testing"
)

func TestInitialize(t *testing.T) {
	t.SkipNow()
	require.NoError(t, Initialize())
	Finalize()
}

```

`pkg/filament/cpython/ip.go`:

```go
//go:build filament && windows
// +build filament,windows

/*
 * Copyright 2019-2020 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package cpython

import "errors"

var ipv4Class *PyObject
var ipv6Class *PyObject
var ipaddressFn *PyObject

func initializeIPFnAndClasses() error {
	mod, err := NewModule("ipaddress")
	if err != nil {
		return err
	}
	if mod.IsNull() {
		return errors.New("ipaddress module was not initialized")
	}

	ipaddressFn, err = mod.GetAttrString("ip_address")
	if err != nil {
		return err
	}
	ipv4Class, err = mod.GetAttrString("IPv4Address")
	if err != nil {
		return err
	}
	ipv6Class, err = mod.GetAttrString("IPv6Address")
	if err != nil {
		return err
	}

	return nil
}

```

`pkg/filament/cpython/module.go`:

```go
//go:build filament && windows
// +build filament,windows

/*
 * Copyright 2019-2020 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package cpython

/*
#include <string.h>
#include "api.h"
*/
import "C"
import (
	"fmt"
	"syscall"
	"unsafe"
)

// Module encapsulates the Python module.
type Module struct {
	*PyObject
	name string
}

// NewModule imports a module leaving the globals and locals arguments set to NULL and level set to 0. When the name argument contains
// a dot (when it specifies a submodule of a package), the fromlist argument is set to the list ['*'] so that the return
// value is the named module rather than the top-level package containing it as would otherwise be the case.
// (Unfortunately, this has an additional side effect when name in fact specifies a subpackage instead of a submodule:
// the submodules specified in the package’s __all__ variable are loaded.) Return a new reference to the imported module,
// or NULL with an exception set on failure. A failing import of a module doesn't leave the module in sys.modules.
func NewModule(name string) (*Module, error) {
	n := C.CString(name)
	defer C.free(unsafe.Pointer(n))
	mod := C.PyImport_ImportModule(n)
	if mod == nil {
		return nil, fmt.Errorf("couldn't import %q module", name)
	}
	return &Module{
		PyObject: &PyObject{rawptr: mod},
		name:     name,
	}, nil
}

// MethFlags is the type alias for the method flags
type MethFlags int

const (
	// MethVarArgs indicates that the method or function accepts positional arguments
	MethVarArgs MethFlags = C.METH_VARARGS
	// MethKeyWords indicates that the method or function accepts keyword arguments
	MethKeyWords MethFlags = C.METH_KEYWORDS
	// MethNoArgs indicates that the method or function accepts no arguments
	MethNoArgs MethFlags = C.METH_NOARGS
)

// DefaultMethFlags represents the default method flags
var DefaultMethFlags = MethVarArgs | MethKeyWords

// declared globally to guard PyMethodDef structures from the garbage collector
var defs = map[string]*C.PyMethodDef{}

// RegisterFn anchors the function to this module. The callable Python object is built from the method definition
// that specifies the function name, the args expected by the function and the pointer to the Go callback.
func (m *Module) RegisterFn(name string, fn interface{}, flags MethFlags) error {
	n := C.CString(name)
	defer C.free(unsafe.Pointer(n))
	defs[name] = &C.PyMethodDef{
		ml_name:  n,
		ml_meth:  (C.PyCFunction)(unsafe.Pointer(syscall.NewCallback(fn))),
		ml_flags: C.int(flags),
	}
	mod := C.CString(m.name)
	defer C.free(unsafe.Pointer(mod))
	f := C.PyCFunction_NewEx((*C.PyMethodDef)(unsafe.Pointer(defs[name])), m.rawptr, C.PyUnicode_FromString(mod))
	if f == nil {
		return fmt.Errorf("unable to attach the %s function to the %s module", name, m.name)
	}
	return m.SetAttrString(name, f)
}

```

`pkg/filament/cpython/module_test.go`:

```go
//go:build filament && windows
// +build filament,windows

/*
 * Copyright 2019-2020 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package cpython

import (
	"github.com/stretchr/testify/require"
	"testing"
)

func TestNewModule(t *testing.T) {
	t.SkipNow()
	require.NoError(t, Initialize())
	defer Finalize()
	AddPythonPath("_fixtures/")
	mod, err := NewModule("top_hives_io")
	require.NoError(t, err)
	require.NotNil(t, mod)
}

func TestModuleRegisterFn(t *testing.T) {
	t.SkipNow()
	require.NoError(t, Initialize())
	defer Finalize()
	AddPythonPath("_fixtures/")
	mod, err := NewModule("top_hives_io")
	require.NoError(t, err)
	require.NotNil(t, mod)

	f := func() uintptr { return 0 }

	err = mod.RegisterFn("set_interval", f, MethVarArgs)
	require.NoError(t, err)

	fn, err := mod.GetAttrString("set_interval")
	require.NoError(t, err)
	require.False(t, fn.IsNull())
	require.True(t, fn.IsCallable())
	fn.Call()

	fn, err = mod.GetAttrString("sum")
	require.NoError(t, err)
	require.False(t, fn.IsNull())
	require.True(t, fn.IsCallable())
	r := fn.Call(PyUnicodeFromString("test"))
	require.False(t, r.IsNull())
}

```

`pkg/filament/cpython/object.go`:

```go
//go:build filament && windows
// +build filament,windows

/*
 * Copyright 2019-2020 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package cpython

/*
#include "api.h"
*/
import "C"
import (
	"errors"
	"fmt"
	"net"
	"syscall"
	"time"
	"unsafe"
)

var errTypeNotList = errors.New("couldn't parse the argument. It is probably not a list")

// PyRawObject is the type alias for the raw Python object pointer.
type PyRawObject *C.PyObject

// PyArgs represents the alias for the Python positional arguments.
type PyArgs uintptr

// PyKwargs represents the alias for the Python keyword arguments.
type PyKwargs uintptr

// GetInt returns the nth positional argument as an integer.
func (args PyArgs) GetInt(n uint8) int {
	return int(C.PyArg_ParseInt((*C.PyObject)(unsafe.Pointer(args)), C.int(n)))
}

// GetString returns the nth positional argument as a string.
func (args PyArgs) GetString(n uint8) string {
	return fromRawOb(C.PyArg_ParseString((*C.PyObject)(unsafe.Pointer(args)), C.int(n))).String()
}

// GetStringSlice returns the nth argument as a slice of string values.
func (args PyArgs) GetStringSlice(n uint8) ([]string, error) {
	ob := C.PyArg_ParseList((*C.PyObject)(unsafe.Pointer(args)), C.int(n))
	if ob == nil {
		return nil, errTypeNotList
	}
	l := int(C.PyList_Size(ob))
	s := make([]string, l)
	for i := 0; i < l; i++ {
		item := C.PyList_GetItem(ob, C.longlong(i))
		if item == nil {
			continue
		}
		isUnicode := bool(C.Py_IsUnicode(item))
		if !isUnicode {
			continue
		}
		s[i] = fromRawOb(item).String()
	}
	return s, nil
}

// GetSlice returns the nth argument as a slice of generic values.
func (args PyArgs) GetSlice(n uint8) ([]interface{}, error) {
	ob := C.PyArg_ParseList((*C.PyObject)(unsafe.Pointer(args)), C.int(n))
	if ob == nil {
		return nil, errTypeNotList
	}
	l := int(C.PyList_Size(ob))
	if l < 0 {
		return nil, nil
	}
	s := make([]interface{}, l)
	for i := 0; i < l; i++ {
		item := C.PyList_GetItem(ob, C.longlong(i))
		if item == nil {
			continue
		}
		switch {
		case bool(C.Py_IsUnicode(item)):
			s[i] = fromRawOb(item).String()
		case bool(C.Py_IsInteger(item)):
			s[i] = fromRawOb(item).Int()
		case bool(C.Py_IsDateTime(item)):
			s[i] = fromRawOb(item).Time()
		default:
			if ipv4Class != nil {
				if !ipv4Class.IsNull() && C.PyObject_IsInstance(item, ipv4Class.rawptr) > 0 {
					s[i] = net.ParseIP(fromRawOb(item).String())
				}
			}
			if ipv6Class != nil {
				if !ipv6Class.IsNull() && C.PyObject_IsInstance(item, ipv6Class.rawptr) > 0 {
					s[i] = net.ParseIP(fromRawOb(item).String())
				}
			}
		}
	}
	return s, nil
}

// PyArgsParseKeywords parses tuple and keywords arguments.
func PyArgsParseKeywords(args PyArgs, kwargs PyKwargs, kwlist []string) (string, string, string, []string) {
	var (
		ob1 *C.PyObject
		ob2 *C.PyObject
		ob3 *C.PyObject
		ob4 *C.PyObject
	)

	klist := make([]*C.char, len(kwlist)+1)

	for i, k := range kwlist {
		klist[i] = C.CString(k)
		defer C.free(unsafe.Pointer(klist[i]))
	}

	C.PyArg_ParseKeywords(
		(*C.PyObject)(unsafe.Pointer(args)),
		(*C.PyObject)(unsafe.Pointer(kwargs)),
		&klist[0],
		(**C.PyObject)(unsafe.Pointer(&ob1)),
		(**C.PyObject)(unsafe.Pointer(&ob2)),
		(**C.PyObject)(unsafe.Pointer(&ob3)),
		(**C.PyObject)(unsafe.Pointer(&ob4)),
	)

	return fromRawOb(ob1).String(), fromRawOb(ob2).String(), fromRawOb(ob3).String(), fromRawOb(ob4).StringSlice()
}

// PyObject is the main abstraction for manipulating the native CPython objects.
type PyObject struct {
	rawptr *C.PyObject
}

// NewPyNone creates a new none Python object.
func NewPyNone() *C.PyObject {
	return C.Py_None
}

// NewPyLong creates a new 64-bit signed integer Python object.
func NewPyLong(v int64) *C.PyObject {
	return C.PyLong_FromLongLong(C.i64(v))
}

// NewPyObjectFromValue builds a new Python object based on the underlying interface type.
func NewPyObjectFromValue(value interface{}) *PyObject {
	var ob *C.PyObject
	switch v := value.(type) {
	case int8:
		ob = C.PyChar_FromChar(C.i8(v))
	case uint8:
		ob = C.PyChar_FromUnsignedChar(C.u8(v))
	case int16:
		ob = C.PyShort_FromShort(C.i16(v))
	case uint16:
		ob = C.PyShort_FromUnsignedShort(C.u16(v))
	case int32:
		ob = C.PyLong_FromLong(C.i32(v))
	case uint32:
		ob = C.PyLong_FromUnsignedLong(C.u32(v))
	case int64:
		ob = C.PyLong_FromLongLong(C.i64(v))
	case uint64:
		ob = C.PyLong_FromUnsignedLongLong(C.u64(v))
	case string:
		ob = PyUnicodeFromString(v).asRaw()
	case time.Time:
		ob = C.PyTime_FromDateTime(C.int(v.Year()), C.int(v.Month()), C.int(v.Day()), C.int(v.Hour()), C.int(v.Minute()), C.int(v.Second()), C.int(v.Nanosecond()/1000))
	case net.IP:
		if !ipaddressFn.IsNull() {
			ob = ipaddressFn.Call(PyUnicodeFromString(v.String())).asRaw()
		} else {
			ob = PyUnicodeFromString(v.String()).asRaw()
		}
	case func(arg1, arg2 PyArgs) PyRawObject:
		n := C.CString("func")
		defer C.free(unsafe.Pointer(n))
		mdef := &C.PyMethodDef{
			ml_name:  n,
			ml_meth:  (C.PyCFunction)(unsafe.Pointer(syscall.NewCallback(v))),
			ml_flags: C.int(DefaultMethFlags),
		}
		ob = C.PyCFunction_NewEx((*C.PyMethodDef)(unsafe.Pointer(mdef)), nil, C.PyUnicode_FromString(n))
	}
	return &PyObject{rawptr: ob}
}

// fromRawOb builds a new Python object from the raw pointer.
func fromRawOb(ob *C.PyObject) *PyObject { return &PyObject{rawptr: ob} }

// DecRef decrements the reference count for object o. If the object is NULL, nothing happens. If the reference count
// reaches zero, the object’s type’s deallocation function (which must not be NULL) is invoked.
func (ob *PyObject) DecRef() {
	if ob != nil || ob.rawptr == nil {
		return
	}
	C.Py_DecRef(ob.rawptr)
}

// IncRef increment the reference count for object o. The object may be NULL, in which case this method has no effect.
func (ob *PyObject) IncRef() {
	if ob != nil && ob.rawptr == nil {
		return
	}
	C.Py_IncRef(ob.rawptr)
}

// IsNull determines whether this object's instance is null.
func (ob *PyObject) IsNull() bool {
	if ob == nil {
		return true
	}
	return ob.rawptr == nil
}

func (ob *PyObject) asRaw() *C.PyObject {
	return ob.rawptr
}

// SetAttrString set the value of the attribute provided for this object to the specified value.
func (ob *PyObject) SetAttrString(name string, value *C.PyObject) error {
	attr := C.CString(name)
	defer C.free(unsafe.Pointer(attr))
	err := int(C.PyObject_SetAttrString(ob.rawptr, attr, value))
	if err == -1 {
		return fmt.Errorf("couldn't set the value of the %q attribute", name)
	}
	return nil
}

// GetAttrString retrieves an attribute named from object the object. Returns an error if the attribute can't be fetched.
func (ob *PyObject) GetAttrString(name string) (*PyObject, error) {
	attr := C.CString(name)
	defer C.free(unsafe.Pointer(attr))
	v := C.PyObject_GetAttrString(ob.rawptr, attr)
	if v == nil {
		return nil, fmt.Errorf("couldn't get the %q attribute", name)
	}
	return &PyObject{rawptr: v}, nil
}

// HasAttr determines if the Python object has the specified attribute.
func (ob *PyObject) HasAttr(name string) bool {
	attr := C.CString(name)
	defer C.free(unsafe.Pointer(attr))
	return C.PyObject_HasAttrString(ob.rawptr, attr) > 0
}

var encoding = C.CString("utf-8")
var codecErrors = C.CString("strict")

// String encodes an Unicode object and returns the result as a Python bytes object converted to the Go string.
func (ob *PyObject) String() string {
	if ob.rawptr == nil {
		return ""
	}
	repr := C.PyObject_Str(ob.rawptr)
	if repr == nil {
		return ""
	}
	defer C.Py_DecRef(repr)
	s := C.PyUnicode_AsEncodedString(repr, encoding, codecErrors)
	if s == nil {
		return "invalid Unicode string"
	}
	defer C.Py_DecRef(s)
	return C.GoString(C.PyBytes_AsString(s))
}

// StringSlice returns this object as a string slice.
func (ob *PyObject) StringSlice() []string {
	if ob.rawptr == nil {
		return []string{}
	}
	l := int(C.PyList_Size(ob.asRaw()))
	if l < 0 {
		return nil
	}
	s := make([]string, l)
	for i := 0; i < l; i++ {
		item := C.PyList_GetItem(ob.asRaw(), C.longlong(i))
		if item == nil {
			continue
		}
		isUnicode := bool(C.Py_IsUnicode(item))
		if !isUnicode {
			continue
		}
		s[i] = fromRawOb(item).String()
	}
	return s
}

// Uint32 returns an uint32 integer from the raw Python object.
func (ob *PyObject) Uint32() uint32 {
	return uint32(C.PyLong_AsUnsignedLong(ob.rawptr))
}

// Uint64 returns an uint64 integer from the raw Python object.
func (ob *PyObject) Uint64() uint64 {
	return uint64(C.PyLong_AsUnsignedLongLong(ob.rawptr))
}

// Int returns an integer from the raw Python object.
func (ob *PyObject) Int() int {
	return int(C.PyLong_AsUnsignedLongLong(ob.rawptr))
}

// Time returns the time from the raw Python object.
func (ob *PyObject) Time() time.Time {
	year := int(C.PyDate_GetYear((*C.PyObject)(unsafe.Pointer(ob))))
	month := int(C.PyDate_GetMonth((*C.PyObject)(unsafe.Pointer(ob))))
	day := int(C.PyDate_GetDay((*C.PyObject)(unsafe.Pointer(ob))))
	hour := int(C.PyDate_GetHour((*C.PyObject)(unsafe.Pointer(ob))))
	minute := int(C.PyDate_GetMinute((*C.PyObject)(unsafe.Pointer(ob))))
	second := int(C.PyDate_GetSecond((*C.PyObject)(unsafe.Pointer(ob))))
	microsecond := int(C.PyDate_GetMicroSecond((*C.PyObject)(unsafe.Pointer(ob))))
	return time.Date(year, time.Month(month), day, hour, minute, second, microsecond*1000, time.Local)
}

// Type returns the Python type representation.
func (ob *PyObject) Type() string {
	return C.GoString(C.Py_Type(ob.rawptr))
}

// IsCallable determines if the object is callable.
func (ob *PyObject) IsCallable() bool {
	return C.PyCallable_Check(ob.rawptr) > 0
}

// CallableArgCount returns the number of arguments declared in the callable Python object.
func (ob *PyObject) CallableArgCount() uint32 {
	fnCode, err := ob.GetAttrString("__code__")
	if err != nil || fnCode.IsNull() {
		return 0
	}
	defer fnCode.DecRef()
	count, err := fnCode.GetAttrString("co_argcount")
	if err != nil {
		return 0
	}
	defer count.DecRef()
	return count.Uint32()
}

// Call calls a callable Python object with arguments given by the tuple args. If no arguments are needed, then args
// may be NULL. Returns the result of the call on success, or a null reference on failure.
func (ob *PyObject) Call(args ...*PyObject) *PyObject {
	if ob.rawptr == nil {
		return nil
	}
	if len(args) == 0 {
		return &PyObject{rawptr: C.PyObject_CallObject(ob.rawptr, nil)}
	}
	tuple := NewTuple(len(args))
	for pos, arg := range args {
		tuple.Set(pos, arg)
	}
	defer tuple.DecRef()
	r := C.PyObject_CallObject(ob.rawptr, tuple.rawptr)
	return &PyObject{rawptr: r}
}

```

`pkg/filament/cpython/sequence.go`:

```go
//go:build filament && windows
// +build filament,windows

/*
 * Copyright 2019-2020 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package cpython

/*
#include "api.h"
*/
import "C"

// Tuple represents the Python tuple sequence object.
type Tuple struct {
	*PyObject
}

// NewTuple constructs a new tuple object of the provided size.
func NewTuple(size int) *Tuple {
	return &Tuple{PyObject: &PyObject{rawptr: C.PyTuple_New(C.Py_ssize_t(size))}}
}

// Set inserts a reference to object at specified position of the tuple.
func (t *Tuple) Set(pos int, ob *PyObject) {
	C.PyTuple_SetItem(t.rawptr, C.Py_ssize_t(pos), ob.rawptr)
}

```

`pkg/filament/cpython/string.go`:

```go
//go:build filament && windows
// +build filament,windows

/*
 * Copyright 2019-2020 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package cpython

/*
 #include "api.h"
*/
import "C"
import "unsafe"

// PyUnicodeFromString creates the Python Unicode object from the Go string.
func PyUnicodeFromString(s string) *PyObject {
	u := C.CString(s)
	defer C.free(unsafe.Pointer(u))
	return &PyObject{rawptr: C.PyUnicode_FromString(u)}
}

```

`pkg/filament/dict.go`:

```go
//go:build filament && windows
// +build filament,windows

/*
 * Copyright 2019-2020 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package filament

import (
	"errors"
	"github.com/rabbitstack/fibratus/pkg/event"
	"github.com/rabbitstack/fibratus/pkg/event/params"
	"github.com/rabbitstack/fibratus/pkg/filament/cpython"
)

var (
	seq        = cpython.PyUnicodeFromString("seq")
	pid        = cpython.PyUnicodeFromString("pid")
	ppid       = cpython.PyUnicodeFromString("ppid")
	cwd        = cpython.PyUnicodeFromString("cwd")
	exec       = cpython.PyUnicodeFromString("exe")
	comm       = cpython.PyUnicodeFromString("comm")
	sid        = cpython.PyUnicodeFromString("sid")
	tid        = cpython.PyUnicodeFromString("tid")
	cpu        = cpython.PyUnicodeFromString("cpu")
	name       = cpython.PyUnicodeFromString("name")
	cat        = cpython.PyUnicodeFromString("category")
	desc       = cpython.PyUnicodeFromString("description")
	host       = cpython.PyUnicodeFromString("host")
	ts         = cpython.PyUnicodeFromString("timestamp")
	parameters = cpython.PyUnicodeFromString("params")

	errDictAllocate = errors.New("couldn't allocate a new dict")
)

// newEventDict constructs a Python dictionary object from event structure. This dictionary object is
// passed to the event dispatching function in the filament.
func newEventDict(evt *event.Event) (*cpython.Dict, error) {
	dict := cpython.NewDict()
	if dict.IsNull() {
		return nil, errDictAllocate
	}

	// insert canonical event fields
	dict.Insert(seq, cpython.NewPyObjectFromValue(evt.Seq))
	dict.Insert(pid, cpython.NewPyObjectFromValue(evt.PID))
	dict.Insert(tid, cpython.NewPyObjectFromValue(evt.Tid))
	dict.Insert(cpu, cpython.NewPyObjectFromValue(evt.CPU))
	dict.Insert(name, cpython.NewPyObjectFromValue(evt.Name))
	dict.Insert(cat, cpython.NewPyObjectFromValue(string(evt.Category)))
	dict.Insert(desc, cpython.NewPyObjectFromValue(evt.Description))
	dict.Insert(host, cpython.NewPyObjectFromValue(evt.Host))
	dict.Insert(ts, cpython.NewPyObjectFromValue(evt.Timestamp))

	// insert process state fields
	ps := evt.PS
	if ps != nil {
		dict.Insert(ppid, cpython.NewPyObjectFromValue(ps.Ppid))
		dict.Insert(cwd, cpython.NewPyObjectFromValue(ps.Cwd))
		dict.Insert(exec, cpython.NewPyObjectFromValue(ps.Name))
		dict.Insert(comm, cpython.NewPyObjectFromValue(ps.Cmdline))
		dict.Insert(sid, cpython.NewPyObjectFromValue(ps.SID))
	}

	// insert event parameters
	pars := cpython.NewDict()
	for _, par := range evt.Params {
		var val interface{}
		var err error
		switch par.Type {
		case params.Uint8:
			val, err = evt.Params.GetUint8(par.Name)
		case params.Uint16, params.Port:
			val, err = evt.Params.GetUint16(par.Name)
		case params.Uint32, params.PID, params.TID:
			val, err = evt.Params.GetUint32(par.Name)
		case params.Uint64:
			val, err = evt.Params.GetUint64(par.Name)
		case params.Time:
			val, err = evt.Params.GetTime(par.Name)
		case params.IP:
			val, err = evt.Params.GetIP(par.Name)
		default:
			val = evt.GetParamAsString(par.Name)
		}
		if err != nil {
			continue
		}
		param := cpython.NewPyObjectFromValue(val)
		if param.IsNull() {
			continue
		}
		pars.Insert(cpython.PyUnicodeFromString(par.Name), param)
	}

	dict.Insert(parameters, pars.Object())

	return dict, nil
}

```

`pkg/filament/dict_test.go`:

```go
//go:build filament && windows
// +build filament,windows

/*
 * Copyright 2019-2020 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package filament

import (
	"github.com/rabbitstack/fibratus/pkg/event"
	"github.com/rabbitstack/fibratus/pkg/event/params"
	"github.com/rabbitstack/fibratus/pkg/filament/cpython"
	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/require"
	"net"
	"testing"
	"time"
)

func TestProduceEventDict(t *testing.T) {
	// this test crashes in the CI. Reenable once
	// we investigate why this happens
	t.SkipNow()
	err := cpython.Initialize()
	require.NoError(t, err)
	defer cpython.Finalize()
	now := time.Now()
	evt := &event.Event{
		Seq:         uint64(12456738026482168384),
		Tid:         2484,
		PID:         859,
		CPU:         1,
		Name:        "CreateFile",
		Timestamp:   now,
		Category:    event.File,
		Host:        "archrabbit",
		Description: "Creates or opens a new file, directory, I/O device, pipe, console",
	}
	dict, err := newEventDict(evt)
	require.NoError(t, err)
	require.NotNil(t, dict)

	assert.Equal(t, uint64(12456738026482168384), dict.Get(seq).Uint64())
	assert.Equal(t, uint32(859), dict.Get(pid).Uint32())
	assert.Equal(t, uint32(2484), dict.Get(tid).Uint32())
	assert.Equal(t, uint8(1), uint8(dict.Get(cpu).Uint32()))
	assert.Equal(t, "CreateFile", dict.Get(name).String())
	assert.Equal(t, "file", dict.Get(cat).String())
	assert.Equal(t, "archrabbit", dict.Get(host).String())
	assert.Equal(t, "Creates or opens a new file, directory, I/O device, pipe, console", dict.Get(desc).String())

	timestamp, err := time.Parse("2006-01-02 15:04:05.000000", dict.Get(ts).String())
	require.NoError(t, err)
	assert.Equal(t, timestamp.Year(), now.Year())
	assert.Equal(t, timestamp.Hour(), now.Hour())
	assert.Equal(t, timestamp.Second(), now.Second())
}

func TestProduceEventDictWithIPAddresses(t *testing.T) {
	// this test crashes in the CI. Reenable once
	// we investigate why this happens
	t.SkipNow()
	err := cpython.Initialize()
	require.NoError(t, err)
	defer cpython.Finalize()

	evt := &event.Event{
		Name: "Send",
		Tid:  2484,
		PID:  859,
		Params: event.Params{
			params.NetDport: {Name: params.NetDport, Type: params.Uint16, Value: uint16(443)},
			params.NetSport: {Name: params.NetSport, Type: params.Uint16, Value: uint16(43123)},
			params.NetSIP:   {Name: params.NetSIP, Type: params.IPv6, Value: net.ParseIP("2001:0db8:85a3:0000:0000:8a2e:0370:7334")},
			params.NetDIP:   {Name: params.NetDIP, Type: params.IPv4, Value: net.ParseIP("216.58.201.174")},
		},
	}

	dict, err := newEventDict(evt)
	require.NoError(t, err)
	require.NotNil(t, dict)

	pars := dict.Get(cpython.PyUnicodeFromString("params"))
	paramsDict := cpython.NewDictFromObject(pars)

	assert.Equal(t, "216.58.201.174", paramsDict.Get(cpython.PyUnicodeFromString("dip")).String())
	assert.Equal(t, "2001:db8:85a3::8a2e:370:7334", paramsDict.Get(cpython.PyUnicodeFromString("sip")).String())
}

func BenchmarkTestProduceEventDict(b *testing.B) {
	// this crashes in the CI. Reenable once
	// we investigate why this happens
	b.SkipNow()
	b.ReportAllocs()
	err := cpython.Initialize()
	require.NoError(b, err)
	defer cpython.Finalize()

	evt := &event.Event{
		Seq:         uint64(12456738026482168384),
		Tid:         2484,
		PID:         859,
		CPU:         1,
		Name:        "CreateFile",
		Timestamp:   time.Now(),
		Category:    event.File,
		Host:        "archrabbit",
		Description: "Creates or opens a new file, directory, I/O device, pipe, console",
	}

	for i := 0; i < b.N; i++ {
		dict, err := newEventDict(evt)
		if err != nil || dict.IsNull() {
			b.Fatal("invalid dict produced")
		}
	}
}

```

`pkg/filament/filament.go`:

```go
//go:build filament && windows
// +build filament,windows

/*
 * Copyright 2019-2020 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package filament

import (
	"errors"
	"expvar"
	"fmt"
	"github.com/rabbitstack/fibratus/pkg/alertsender"
	"github.com/rabbitstack/fibratus/pkg/config"
	"github.com/rabbitstack/fibratus/pkg/event"
	"github.com/rabbitstack/fibratus/pkg/filament/cpython"
	"github.com/rabbitstack/fibratus/pkg/filter"
	"github.com/rabbitstack/fibratus/pkg/handle"
	"github.com/rabbitstack/fibratus/pkg/ps"
	"github.com/rabbitstack/fibratus/pkg/util/multierror"
	"github.com/rabbitstack/fibratus/pkg/util/term"
	log "github.com/sirupsen/logrus"
	"io"
	"os"
	"path/filepath"
	"strings"
	"time"
	// initialize alert senders
	_ "github.com/rabbitstack/fibratus/pkg/alertsender/mail"
	_ "github.com/rabbitstack/fibratus/pkg/alertsender/slack"
)

// pyver designates the current Python version
const pyver = "37"

// useEmbeddedPython instructs the filament engine to use the embedded Python distribution.
var useEmbeddedPython = true

const (
	intervalFn      = "interval"
	columnsFn       = "columns"
	sortbyFn        = "sort_by"
	setFilterFn     = "set_filter"
	addRowFn        = "add_row"
	maxRowsFn       = "max_rows"
	titleFn         = "title"
	renderTableFn   = "render_table"
	findHandleFn    = "find_handle"
	findHandlesFn   = "find_handles"
	findProcessFn   = "find_process"
	findProcessesFn = "find_processes"
	emitAlertFn     = "emit_alert"

	onInitFn      = "on_init"
	onStopFn      = "on_stop"
	onNextEventFn = "on_next_event"
	onIntervalFn  = "on_interval"
	doc           = "__doc__"
)

var (
	eventErrors        = expvar.NewMap("filament.event.errors")
	eventProcessErrors = expvar.NewInt("filament.event.process.errors")
	dictErrors         = expvar.NewInt("filament.dict.errors")
	batchFlushes       = expvar.NewInt("filament.event.batch.flushes")

	errFilamentsDir = func(path string) error { return fmt.Errorf("%s does not exist or is not a directory", path) }

	errNoDoc                   = errors.New("filament description is required")
	errNoOnNextEvent           = errors.New("required on_next_event function is not defined")
	errOnNextEventNotCallable  = errors.New("on_next_event is not callable")
	errOnNextEventMismatchArgs = func(c uint32) error { return fmt.Errorf("expected 1 argument for on_next_event but found %d args", c) }
	errEmptyName               = errors.New("filament name is empty")

	tableOutput io.Writer
)

type batch []*event.Event

func (b *batch) append(evt *event.Event) {
	if *b == nil {
		*b = make([]*event.Event, 0)
	}
	*b = append(*b, evt)
}

func (b *batch) reset()  { *b = nil }
func (b batch) len() int { return len(b) }

type filament struct {
	name     string
	sortBy   string
	interval time.Duration
	columns  []string
	fexpr    string
	fnerrs   chan error
	close    chan struct{}
	gil      *cpython.GIL

	tick *time.Ticker
	mod  *cpython.Module

	config *config.Config

	psnap  ps.Snapshotter
	hsnap  handle.Snapshotter
	filter filter.Filter

	initErrors []error

	onNextEvent *cpython.PyObject
	onStop      *cpython.PyObject

	table tab
}

// New creates a new instance of the filament by starting an embedded Python interpreter. It imports the filament
// module and anchors required functions for controlling the filament options as well as providing the access to
// the kernel event flow.
func New(
	name string,
	psnap ps.Snapshotter,
	hsnap handle.Snapshotter,
	config *config.Config,
) (Filament, error) {
	if useEmbeddedPython {
		exe, err := os.Executable()
		if err != nil {
			return nil, err
		}
		pylib := filepath.Join(filepath.Dir(exe), "..", "Python", fmt.Sprintf("python%s.zip", pyver))
		if _, err := os.Stat(pylib); err != nil {
			return nil, fmt.Errorf("python lib not found: %v", err)
		}
		// set the default module search path so it points to our embedded Python distribution
		cpython.SetPath(pylib)
	}

	if name == "" {
		return nil, errEmptyName
	}

	// split filament args. The first argument
	// is the filament name followed by comma
	// separated list of arguments
	args := strings.Split(name, ",")
	if len(args) == 0 {
		return nil, errEmptyName
	}
	filamentName := args[0]

	// initialize the Python interpreter
	if err := cpython.Initialize(); err != nil {
		return nil, err
	}
	// set sys.argv
	cpython.SetSysArgv(args)

	// set the PYTHON_PATH to the filaments directory so the interpreter
	// is aware of our filament module prior to its loading
	path := config.Filament.Path
	fstat, err := os.Stat(path)
	if err != nil || !fstat.IsDir() {
		return nil, errFilamentsDir(path)
	}
	filaments, err := os.ReadDir(path)
	if err != nil {
		return nil, err
	}
	// check if the filament is present in the directory
	var exists bool
	for _, f := range filaments {
		if strings.TrimSuffix(f.Name(), filepath.Ext(f.Name())) == filamentName {
			exists = true
		}
	}

	if !exists {
		return nil, fmt.Errorf("%q filament does not exist. Run 'fibratus list filaments' to view available filaments", name)
	}

	cpython.AddPythonPath(path)
	mod, err := cpython.NewModule(filamentName)
	if err != nil {
		if err = cpython.FetchErr(); err != nil {
			return nil, err
		}
		return nil, err
	}

	// ensure required attributes are present before proceeding with
	// further initialization. For instance, if the documentation
	// string is not provided, on_next_event function is missing
	// or has a wrong signature we won't run the filament
	doc, err := mod.GetAttrString(doc)
	if err != nil || doc.IsNull() {
		return nil, errNoDoc
	}
	defer doc.DecRef()
	if !mod.HasAttr(onNextEventFn) {
		return nil, errNoOnNextEvent
	}
	onNextEvent, err := mod.GetAttrString(onNextEventFn)
	if err != nil || onNextEvent.IsNull() {
		return nil, errNoOnNextEvent
	}
	if !onNextEvent.IsCallable() {
		return nil, errOnNextEventNotCallable
	}
	argCount := onNextEvent.CallableArgCount()
	if argCount != 1 {
		return nil, errOnNextEventMismatchArgs(argCount)
	}

	f := &filament{
		name:        name,
		mod:         mod,
		config:      config,
		psnap:       psnap,
		hsnap:       hsnap,
		close:       make(chan struct{}, 1),
		fnerrs:      make(chan error, 100),
		gil:         cpython.NewGIL(),
		columns:     make([]string, 0),
		onNextEvent: onNextEvent,
		interval:    time.Second,
		initErrors:  make([]error, 0),
		table:       newTable(),
	}

	if mod.HasAttr(onStopFn) {
		f.onStop, _ = mod.GetAttrString(onStopFn)
	}
	// register all the functions for interacting with filament
	// within the Python module
	err = f.mod.RegisterFn(addRowFn, f.addRowFn, cpython.DefaultMethFlags)
	if err != nil {
		return nil, err
	}
	err = f.mod.RegisterFn(renderTableFn, f.renderTableFn, cpython.MethNoArgs)
	if err != nil {
		return nil, err
	}
	err = f.mod.RegisterFn(titleFn, f.titleFn, cpython.DefaultMethFlags)
	if err != nil {
		return nil, err
	}
	err = f.mod.RegisterFn(sortbyFn, f.sortByFn, cpython.DefaultMethFlags)
	if err != nil {
		return nil, err
	}
	err = f.mod.RegisterFn(maxRowsFn, f.maxRowsFn, cpython.DefaultMethFlags)
	if err != nil {
		return nil, err
	}
	err = f.mod.RegisterFn(columnsFn, f.columnsFn, cpython.DefaultMethFlags)
	if err != nil {
		return nil, err
	}
	err = f.mod.RegisterFn(setFilterFn, f.setFilterFn, cpython.DefaultMethFlags)
	if err != nil {
		return nil, err
	}
	err = f.mod.RegisterFn(intervalFn, f.intervalFn, cpython.DefaultMethFlags)
	if err != nil {
		return nil, err
	}
	err = f.mod.RegisterFn(emitAlertFn, f.emitAlertFn, cpython.DefaultMethFlags)
	if err != nil {
		return nil, err
	}
	err = f.mod.RegisterFn(findHandleFn, f.findHandleFn, cpython.DefaultMethFlags)
	if err != nil {
		return nil, err
	}
	err = f.mod.RegisterFn(findHandlesFn, f.findHandlesFn, cpython.DefaultMethFlags)
	if err != nil {
		return nil, err
	}
	err = f.mod.RegisterFn(findProcessFn, f.findProcessFn, cpython.DefaultMethFlags)
	if err != nil {
		return nil, err
	}
	err = f.mod.RegisterFn(findProcessesFn, f.findProcessesFn, cpython.DefaultMethFlags)
	if err != nil {
		return nil, err
	}
	// invoke the on_init function if it has been declared in the filament
	if mod.HasAttr(onInitFn) {
		onInit, _ := mod.GetAttrString(onInitFn)
		if !onInit.IsNull() {
			onInit.Call()
			if err := cpython.FetchErr(); err != nil {
				return nil, fmt.Errorf("filament init error: %v", err)
			}
			if len(f.initErrors) > 0 {
				return nil, multierror.Wrap(f.initErrors...)
			}
		}
	}

	// initialize the console frame buffer
	var fb io.Writer
	if len(f.columns) > 0 {
		fb, err = term.NewFrameBuffer()
		if err != nil {
			return nil, fmt.Errorf("couldn't create console frame buffer: %v", err)
		}
	}
	if fb != nil {
		f.table.setWriter(fb)
		f.table.setColumnConfigs(f.columns, term.GetColumns()/2+15)
	} else if tableOutput != nil {
		f.table.setWriter(tableOutput)
	} else {
		f.table.setWriter(os.Stdout)
	}
	if len(f.columns) > 0 && f.sortBy != "" {
		var sortBy bool
		for _, col := range f.columns {
			if col == f.sortBy {
				sortBy = true
				break
			}
		}
		if !sortBy {
			return nil, fmt.Errorf("%s column can't be sorted since it is not defined", f.sortBy)
		}
	}

	// compile filter from the expression
	if f.fexpr != "" {
		f.filter = filter.New(f.fexpr, config)
		if err := f.filter.Compile(); err != nil {
			return nil, err
		}
	}
	// if on_interval function has been declared in the module, we'll
	// schedule the ticker to the interval value set during filament
	// bootstrap in on_init function or otherwise we'll use the default interval
	if mod.HasAttr(onIntervalFn) {
		onInterval, err := mod.GetAttrString(onIntervalFn)
		if err == nil && !onInterval.IsNull() {
			f.tick = time.NewTicker(f.interval)
			go f.onInterval(onInterval)
		}
	}
	// we acquired the GIL as a side effect of threading initialization (the call to cpython.Initialize())
	// but now we have to reset the current thread state and release the GIL. It is the responsibility of
	// the caller to acquire the GIL before executing any Python code from now on
	f.gil.SaveThread()

	return f, nil
}

func (f *filament) Run(eventsc <-chan *event.Event, errs <-chan error) error {
	var b batch
	var flusher = time.NewTicker(time.Second)
	for {
		select {
		case <-f.close:
			flusher.Stop()
			return nil
		default:
		}

		select {
		case evt := <-eventsc:
			b.append(evt)
		case err := <-errs:
			eventErrors.Add(err.Error(), 1)
		case <-flusher.C:
			batchFlushes.Add(1)
			if b.len() > 0 {
				err := f.pushEvents(b)
				if err != nil {
					log.Warnf("on_next_event failed: %v", err)
					eventProcessErrors.Add(1)
				}
				b.reset()
			}
		case err := <-f.fnerrs:
			return err
		case <-f.close:
			flusher.Stop()
			return nil
		}
	}
}

func (f *filament) pushEvents(b batch) error {
	f.gil.Lock()
	defer f.gil.Unlock()
	for _, evt := range b {
		dict, err := newEventDict(evt)
		if err != nil {
			dict.DecRef()
			dictErrors.Add(1)
			continue
		}
		r := f.onNextEvent.Call(dict.Object())
		if r != nil {
			r.DecRef()
		}
		dict.DecRef()
		if err := cpython.FetchErr(); err != nil {
			return err
		}
	}
	return nil
}

func (f *filament) Close() error {
	if f.onStop != nil && !f.onStop.IsNull() {
		f.gil.Lock()
		f.onStop.Call()
		f.gil.Unlock()
	}
	f.close <- struct{}{}
	if f.tick != nil {
		f.close <- struct{}{}
	}
	if f.tick != nil {
		f.tick.Stop()
	}
	return nil
}

func (f *filament) Filter() filter.Filter { return f.filter }

func (f *filament) intervalFn(_, args cpython.PyArgs) cpython.PyRawObject {
	f.interval = time.Second * time.Duration(args.GetInt(1))
	if f.interval == 0 {
		f.initErrors = append(f.initErrors, errors.New("invalid interval value specified"))
	}
	return cpython.NewPyNone()
}

func (f *filament) sortByFn(_, args cpython.PyArgs) cpython.PyRawObject {
	f.sortBy = args.GetString(1)
	f.table.sortBy(f.sortBy)
	return cpython.NewPyNone()
}

func (f *filament) maxRowsFn(_, args cpython.PyArgs) cpython.PyRawObject {
	f.table.maxRows(args.GetInt(1))
	return cpython.NewPyNone()
}

func (f *filament) columnsFn(_, args cpython.PyArgs) cpython.PyRawObject {
	var err error
	f.columns, err = args.GetStringSlice(1)
	if err != nil {
		f.initErrors = append(f.initErrors, err)
	}
	f.table.appendHeader(f.columns)
	return cpython.NewPyNone()
}

func (f *filament) setFilterFn(_, args cpython.PyArgs) cpython.PyRawObject {
	f.fexpr = args.GetString(1)
	return cpython.NewPyNone()
}

func (f *filament) addRowFn(_, args cpython.PyArgs) cpython.PyRawObject {
	s, err := args.GetSlice(1)
	if err != nil {
		f.fnerrs <- err
		return cpython.NewPyNone()
	}
	if len(s) != len(f.columns) {
		f.fnerrs <- fmt.Errorf("add_row has %d row(s) but expected %d rows(s)", len(s), len(f.columns))
		return cpython.NewPyNone()
	}
	f.table.appendRow(s)
	return cpython.NewPyLong(int64(len(s)))
}

func (f *filament) renderTableFn(_ cpython.PyArgs, args cpython.PyArgs) cpython.PyRawObject {
	f.table.render()
	f.table.reset()
	return cpython.NewPyNone()
}

func (f *filament) titleFn(_ cpython.PyArgs, args cpython.PyArgs) cpython.PyRawObject {
	f.table.title(args.GetString(1))
	return cpython.NewPyNone()
}

var keywords = []string{"", "", "severity", "tags"}

func (f *filament) emitAlertFn(_, args cpython.PyArgs, kwargs cpython.PyKwargs) cpython.PyRawObject {
	f.gil.Lock()
	defer f.gil.Unlock()
	senders := alertsender.FindAll()
	if len(senders) == 0 {
		log.Warn("no alertsenders registered. Alert won't be sent")
		return cpython.NewPyNone()
	}

	title, text, sever, tags := cpython.PyArgsParseKeywords(args, kwargs, keywords)

	for _, s := range senders {
		alert := alertsender.NewAlert(
			title,
			text,
			tags,
			alertsender.ParseSeverityFromString(sever),
		)
		if err := s.Send(alert); err != nil {
			log.Warnf("unable to emit alert from filament: %v", err)
		}
	}

	return cpython.NewPyNone()
}

func (f *filament) findProcessFn(_, args cpython.PyArgs) cpython.PyRawObject {
	f.gil.Lock()
	defer f.gil.Unlock()
	return cpython.NewPyNone()
}

func (f *filament) findHandleFn(_, args cpython.PyArgs) cpython.PyRawObject {
	f.gil.Lock()
	defer f.gil.Unlock()
	return cpython.NewPyNone()
}

func (f *filament) findProcessesFn(_, args cpython.PyArgs) cpython.PyRawObject {
	f.gil.Lock()
	defer f.gil.Unlock()
	return cpython.NewPyNone()
}

func (f *filament) findHandlesFn(_, args cpython.PyArgs) cpython.PyRawObject {
	f.gil.Lock()
	defer f.gil.Unlock()
	return cpython.NewPyNone()
}

func (f *filament) onInterval(fn *cpython.PyObject) {
	for {
		select {
		case <-f.tick.C:
			f.gil.Lock()
			r := fn.Call()
			if r != nil {
				r.DecRef()
			}
			if err := cpython.FetchErr(); err != nil {
				f.fnerrs <- err
			}
			f.gil.Unlock()
		case <-f.close:
			return
		}
	}
}

```

`pkg/filament/filament_test.go`:

```go
//go:build filament && windows
// +build filament,windows

/*
 * Copyright 2019-2020 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package filament

import (
	"bufio"
	"bytes"
	"github.com/rabbitstack/fibratus/pkg/config"
	"github.com/rabbitstack/fibratus/pkg/event"
	"github.com/rabbitstack/fibratus/pkg/event/params"
	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/require"
	"net"
	"strings"
	"testing"
	"time"
)

func init() {
	useEmbeddedPython = false
}

func TestNewFilament(t *testing.T) {
	t.SkipNow()
	filament, err := New("top_hives_io", nil, nil, &config.Config{Filament: config.FilamentConfig{Path: "_fixtures"}})
	require.NoError(t, err)
	require.NotNil(t, filament)
	defer filament.Close()
}

var buf bytes.Buffer

func init() {
	tableOutput = &buf
}

func TestOnNextEvent(t *testing.T) {
	// this test crashes in the CI. Reenable once
	// we investigate why this happens
	t.SkipNow()
	filament, err := New("test_on_next_event", nil, nil, &config.Config{Filament: config.FilamentConfig{FlushPeriod: time.Millisecond * 250, Path: "_fixtures"}})
	require.NoError(t, err)
	require.NotNil(t, filament)
	time.AfterFunc(time.Millisecond*1050, func() {
		filament.Close()
	})

	events := make(chan *event.Event, 100)
	errs := make(chan error, 10)
	for i := 1; i <= 100; i++ {
		evt := &event.Event{
			Type:      event.RegCreateKey,
			Tid:       2484,
			PID:       859,
			Name:      "RegCreateKey",
			Host:      "archrabbit",
			CPU:       uint8(i / 2),
			Category:  event.Registry,
			Seq:       uint64(i),
			Timestamp: time.Now(),
			Params: event.Params{
				params.RegPath:      {Name: params.RegPath, Type: params.UnicodeString, Value: `HKEY_LOCAL_MACHINE\SYSTEM\Setup`},
				params.RegKeyHandle: {Name: params.RegKeyHandle, Type: params.Address, Value: uint64(18446666033449935464)},
				params.NetDIP:       {Name: params.NetDIP, Type: params.IPv4, Value: net.ParseIP("216.58.201.174")},
			},
		}
		events <- evt
	}
	err = filament.Run(events, errs)
	require.Nil(t, err)
	sn := bufio.NewScanner(strings.NewReader(buf.String()))
	const headerOffset = 4
	rows := 0
	for sn.Scan() {
		rows++
	}
	assert.Equal(t, 100, rows-headerOffset)
}

func TestFilamentFilter(t *testing.T) {
	// skipped for the same reason as previous test
	t.SkipNow()
	filament, err := New("test_filter", nil, nil, &config.Config{Filament: config.FilamentConfig{Path: "_fixtures"}})
	require.NoError(t, err)
	require.NotNil(t, filament)
	defer filament.Close()
	require.NotNil(t, filament.Filter())
	kpars := event.Params{
		params.Cmdline:         {Name: params.Cmdline, Type: params.UnicodeString, Value: "C:\\Windows\\system32\\svchost.exe -k RPCSS"},
		params.ProcessName:     {Name: params.ProcessName, Type: params.AnsiString, Value: "svchost.exe"},
		params.ProcessID:       {Name: params.ProcessID, Type: params.Uint32, Value: uint32(1234)},
		params.ProcessParentID: {Name: params.ProcessParentID, Type: params.Uint32, Value: uint32(345)},
	}

	evt := &event.Event{
		Type:   event.CreateProcess,
		Params: kpars,
		Name:   "CreateProcess",
	}

	require.True(t, filament.Filter().Run(evt))
}

```

`pkg/filament/filament_unsupported.go`:

```go
//go:build !filament
// +build !filament

/*
 * Copyright 2019-2020 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package filament

import (
	"github.com/rabbitstack/fibratus/pkg/config"
	errs "github.com/rabbitstack/fibratus/pkg/errors"
	"github.com/rabbitstack/fibratus/pkg/handle"
	"github.com/rabbitstack/fibratus/pkg/ps"
)

// New returns unsupported filament error.
func New(
	name string,
	psnap ps.Snapshotter,
	hsnap handle.Snapshotter,
	config *config.Config,
) (Filament, error) {
	return nil, errs.ErrFeatureUnsupported("filament")
}

```

`pkg/filament/table.go`:

```go
//go:build filament && windows
// +build filament,windows

/*
 * Copyright 2019-2020 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package filament

import (
	"github.com/jedib0t/go-pretty/v6/table"
	"io"
)

type tab struct {
	writer table.Writer
}

func newTable() tab {
	writer := table.NewWriter()
	writer.SetStyle(table.StyleLight)
	return tab{writer: writer}
}

func (t tab) setWriter(output io.Writer) {
	t.writer.SetOutputMirror(output)
}

func (t tab) setColumnConfigs(cols []string, maxWidth int) {
	configs := make([]table.ColumnConfig, len(cols))
	for i, col := range cols {
		configs[i] = table.ColumnConfig{Name: col, WidthMax: maxWidth}
	}
	t.writer.SetColumnConfigs(configs)
}

func (t tab) appendHeader(cols []string) {
	r := make(table.Row, len(cols))
	for i, col := range cols {
		r[i] = col
	}
	t.writer.AppendHeader(r)
}

func (t tab) appendRow(row []interface{}) {
	t.writer.AppendRow(row)
}

func (t tab) sortBy(column string) {
	t.writer.SortBy([]table.SortBy{{Name: column, Mode: table.DscNumeric}})
}

func (t tab) maxRows(size int) {
	t.writer.SetPageSize(size)
}

func (t tab) render() {
	t.writer.Render()
}

func (t tab) reset() {
	t.writer.ResetRows()
}

func (t tab) title(title string) {
	t.writer.SetTitle(title)
}

```

`pkg/filament/table_test.go`:

```go
//go:build filament && windows
// +build filament,windows

/*
 * Copyright 2019-2020 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package filament

import (
	"os"
	"testing"
)

func TestTable(t *testing.T) {
	table := newTable()
	table.setWriter(os.Stdout)
	table.appendHeader([]string{"Hive", "#Ops"})
	table.appendRow([]interface{}{"HKLM/CurrentUser", 2000})
	table.render()

	table.reset()
	table.appendRow([]interface{}{"HKLM/CurrentUser", 2000})
	table.render()
}

```

`pkg/filament/types.go`:

```go
/*
 * Copyright 2019-2020 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package filament

import (
	"github.com/rabbitstack/fibratus/pkg/event"
	"github.com/rabbitstack/fibratus/pkg/filter"
)

// Filament defines the set of operations all filaments have to satisfy. Filament represents a full-fledged
// Python interpreter that runs the modules given by users.
type Filament interface {
	// Run consumes all events from the kernel event stream and dispatches them to the filament.
	Run(<-chan *event.Event, <-chan error) error
	// Close shutdowns the filament by releasing all allocated resources.
	Close() error
	// Filter returns the filter compiled from filament.
	Filter() filter.Filter
}

// Info stores metadata about the filament.
type Info struct {
	Name        string
	Description string
}

```

`pkg/filter/accessor.go`:

```go
/*
 * Copyright 2020-2021 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package filter

import (
	"errors"
	"net"
	"reflect"
	"time"

	"github.com/rabbitstack/fibratus/internal/evasion"
	"github.com/rabbitstack/fibratus/pkg/event"
	"github.com/rabbitstack/fibratus/pkg/event/params"
	"github.com/rabbitstack/fibratus/pkg/filter/fields"
)

var (
	// ErrPsNil indicates the process state associated with the event is not initialized
	ErrPsNil = errors.New("process state is nil")
)

// Accessor dictates the behaviour of the field accessors. One of the main responsibilities of the accessor is
// to extract the underlying parameter for the field given in the filter expression. It can also produce a value
// from the non-params constructs such as process' state or PE metadata.
type Accessor interface {
	// Get fetches the parameter value for the specified filter field.
	Get(f Field, evt *event.Event) (params.Value, error)
	// SetFields sets all fields declared in the expression.
	SetFields(fields []Field)
	// SetSegments sets all segments utilized in the function predicate expression.
	SetSegments(segments []fields.Segment)
	// IsFieldAccessible determines if the field can be extracted from the
	// given event. The condition is usually based on the event category,
	// but it can also include different circumstances, like the presence
	// of the process state or callstacks.
	IsFieldAccessible(evt *event.Event) bool
}

// evtAccessor extracts generic event values.
type evtAccessor struct{}

func (evtAccessor) SetFields([]Field)                   {}
func (evtAccessor) SetSegments([]fields.Segment)        {}
func (evtAccessor) IsFieldAccessible(*event.Event) bool { return true }

func newEventAccessor() Accessor {
	return &evtAccessor{}
}

const timeFmt = "15:04:05"
const dateFmt = "2006-01-02"

func (*evtAccessor) Get(f Field, evt *event.Event) (params.Value, error) {
	switch f.Name {
	case fields.EvtSeq, fields.KevtSeq:
		return evt.Seq, nil
	case fields.EvtPID, fields.KevtPID:
		return evt.PID, nil
	case fields.EvtTID, fields.KevtTID:
		return evt.Tid, nil
	case fields.EvtCPU, fields.KevtCPU:
		return evt.CPU, nil
	case fields.EvtName, fields.KevtName:
		return evt.Name, nil
	case fields.EvtCategory, fields.KevtCategory:
		return string(evt.Category), nil
	case fields.EvtDesc, fields.KevtDesc:
		return evt.Description, nil
	case fields.EvtHost, fields.KevtHost:
		return evt.Host, nil
	case fields.EvtTime, fields.KevtTime:
		return evt.Timestamp.Format(timeFmt), nil
	case fields.EvtTimeHour, fields.KevtTimeHour:
		return uint8(evt.Timestamp.Hour()), nil
	case fields.EvtTimeMin, fields.KevtTimeMin:
		return uint8(evt.Timestamp.Minute()), nil
	case fields.EvtTimeSec, fields.KevtTimeSec:
		return uint8(evt.Timestamp.Second()), nil
	case fields.EvtTimeNs, fields.KevtTimeNs:
		return evt.Timestamp.UnixNano(), nil
	case fields.EvtDate, fields.KevtDate:
		return evt.Timestamp.Format(dateFmt), nil
	case fields.EvtDateDay, fields.KevtDateDay:
		return uint8(evt.Timestamp.Day()), nil
	case fields.EvtDateMonth, fields.KevtDateMonth:
		return uint8(evt.Timestamp.Month()), nil
	case fields.EvtDateTz, fields.KevtDateTz:
		tz, _ := evt.Timestamp.Zone()
		return tz, nil
	case fields.EvtDateYear, fields.KevtDateYear:
		return uint32(evt.Timestamp.Year()), nil
	case fields.EvtDateWeek, fields.KevtDateWeek:
		_, week := evt.Timestamp.ISOWeek()
		return uint8(week), nil
	case fields.EvtDateWeekday, fields.KevtDateWeekday:
		return evt.Timestamp.Weekday().String(), nil
	case fields.EvtNparams, fields.KevtNparams:
		return uint64(evt.Params.Len()), nil
	case fields.EvtArg, fields.KevtArg:
		// lookup the parameter from the field argument
		// and depending on the parameter type, return
		// the respective value. The field format is
		// expressed as evt.arg[cmdline] where the string
		// inside brackets represents the parameter name
		name := f.Arg
		par, err := evt.Params.Get(name)
		if err != nil {
			return nil, err
		}

		switch par.Type {
		case params.Uint8:
			return evt.Params.GetUint8(name)
		case params.Uint16, params.Port:
			return evt.Params.GetUint16(name)
		case params.Uint32, params.PID, params.TID:
			return evt.Params.GetUint32(name)
		case params.Uint64:
			return evt.Params.GetUint64(name)
		case params.Time:
			return evt.Params.GetTime(name)
		default:
			return evt.GetParamAsString(name), nil
		}
	case fields.EvtIsDirectSyscall:
		return evt.Evasions&uint32(evasion.DirectSyscall) != 0, nil
	case fields.EvtIsIndirectSyscall:
		return evt.Evasions&uint32(evasion.IndirectSyscall) != 0, nil
	}

	return nil, nil
}

// narrowAccessors dynamically disables filter accessors by walking
// the fields declared in the expression. The field can be expressed
// as a regular LHS/RHS component, used as a function parameter or
// referenced in the bound field.
func (f *filter) narrowAccessors() {
	var (
		removeEvtAccessor        = true
		removePsAccessor         = true
		removeThreadAccessor     = true
		removeModuleAccessor     = true
		removeFileAccessor       = true
		removeRegistryAccessor   = true
		removeNetworkAccessor    = true
		removeHandleAccessor     = true
		removePEAccessor         = true
		removeMemAccessor        = true
		removeDNSAccessor        = true
		removeThreadpoolAccessor = true
	)

	for _, field := range f.fields {
		switch {
		case field.Name.IsEvtField() || field.Name.IsKevtField():
			removeEvtAccessor = false
		case field.Name.IsPeField():
			removePEAccessor = false
		case field.Name.IsPsField():
			removePsAccessor = false
		case field.Name.IsThreadField():
			removeThreadAccessor = false
		case field.Name.IsImageField() || field.Name.IsModuleField():
			removeModuleAccessor = false
		case field.Name.IsFileField():
			removeFileAccessor = false
		case field.Name.IsRegistryField():
			removeRegistryAccessor = false
		case field.Name.IsNetworkField():
			removeNetworkAccessor = false
		case field.Name.IsHandleField():
			removeHandleAccessor = false
		case field.Name.IsMemField():
			removeMemAccessor = false
		case field.Name.IsDNSField():
			removeDNSAccessor = false
		case field.Name.IsThreadpoolField():
			removeThreadpoolAccessor = false
		}
	}

	if removeEvtAccessor {
		f.removeAccessor(&evtAccessor{})
	}
	if removePsAccessor {
		f.removeAccessor(&psAccessor{})
	}
	if removeThreadAccessor {
		f.removeAccessor(&threadAccessor{})
	}
	if removeModuleAccessor {
		f.removeAccessor(&moduleAccessor{})
	}
	if removeFileAccessor {
		f.removeAccessor(&fileAccessor{})
	}
	if removeRegistryAccessor {
		f.removeAccessor(&registryAccessor{})
	}
	if removeNetworkAccessor {
		f.removeAccessor(&networkAccessor{})
	}
	if removeHandleAccessor {
		f.removeAccessor(&handleAccessor{})
	}
	if removePEAccessor {
		f.removeAccessor(&peAccessor{})
	}
	if removeMemAccessor {
		f.removeAccessor(&memAccessor{})
	}
	if removeDNSAccessor {
		f.removeAccessor(&dnsAccessor{})
	}
	if removeThreadpoolAccessor {
		f.removeAccessor(&threadpoolAccessor{})
	}

	for _, accessor := range f.accessors {
		accessor.SetFields(f.fields)
		accessor.SetSegments(f.segments)
	}
}

func (f *filter) removeAccessor(removed Accessor) {
	for i, accessor := range f.accessors {
		if reflect.TypeOf(accessor) == reflect.TypeOf(removed) {
			f.accessors = append(f.accessors[:i], f.accessors[i+1:]...)
		}
	}
}

var (
	zeroTime  time.Time
	zeroSlice []string
	zeroIP    net.IP
	zeroByte  []byte
)

// defaultAccessorValue provides the default value for the field.
// This value is typically assigned when the accessor returns an
// error or nil value, but the map valuer must contain the resolved
// field name in case of filters using the not operator.
func defaultAccessorValue(field Field) any {
	switch field.Name.Type() {
	case params.Uint8, params.Int64, params.Int8, params.Int32, params.Int16,
		params.Uint16, params.Port, params.Uint32, params.Uint64, params.PID,
		params.TID, params.Flags, params.Flags64:
		return 0
	case params.Float, params.Double:
		return 0.0
	case params.Time:
		return zeroTime
	case params.Bool:
		return false
	case params.IP, params.IPv4, params.IPv6:
		return zeroIP
	case params.Binary:
		return zeroByte
	case params.Slice:
		return zeroSlice
	default:
		return ""
	}
}

```

`pkg/filter/accessor_windows.go`:

```go
/*
 * Copyright 2019-2020 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package filter

import (
	"errors"
	"expvar"
	"net"
	"path/filepath"
	"strconv"
	"strings"
	"time"

	"github.com/rabbitstack/fibratus/pkg/fs"
	"github.com/rabbitstack/fibratus/pkg/network"
	psnap "github.com/rabbitstack/fibratus/pkg/ps"
	"github.com/rabbitstack/fibratus/pkg/util/signature"

	"github.com/rabbitstack/fibratus/pkg/event"
	"github.com/rabbitstack/fibratus/pkg/event/params"
	"github.com/rabbitstack/fibratus/pkg/filter/fields"
	"github.com/rabbitstack/fibratus/pkg/pe"
	pstypes "github.com/rabbitstack/fibratus/pkg/ps/types"
)

var (
	// ErrPENil indicates the PE (Portable Executable) data is nil
	ErrPENil = errors.New("pe state is nil")
)

// signatureErrors counts signature check/verification errors
var signatureErrors = expvar.NewInt("image.signature.errors")

// certErrors counts certificate parse errors
var certErrors = expvar.NewInt("image.certificate.errors")

// GetAccessors initializes and returns all available accessors.
func GetAccessors() []Accessor {
	return []Accessor{
		newPSAccessor(nil),
		newPEAccessor(),
		newMemAccessor(),
		newDNSAccessor(),
		newFileAccessor(),
		newEventAccessor(),
		newModuleAccessor(),
		newThreadAccessor(),
		newHandleAccessor(),
		newNetworkAccessor(),
		newRegistryAccessor(),
		newThreadpoolAccessor(),
	}
}

func getParentPs(e *event.Event) *pstypes.PS {
	if e.PS == nil {
		return nil
	}
	return e.PS.Parent
}

// psAccessor extracts process's state or event specific values.
type psAccessor struct {
	psnap psnap.Snapshotter
}

func (psAccessor) SetFields([]Field)            {}
func (psAccessor) SetSegments([]fields.Segment) {}
func (psAccessor) IsFieldAccessible(e *event.Event) bool {
	return e.PS != nil || e.Category == event.Process
}

func newPSAccessor(psnap psnap.Snapshotter) Accessor { return &psAccessor{psnap: psnap} }

func (ps *psAccessor) Get(f Field, e *event.Event) (params.Value, error) {
	switch f.Name {
	case fields.PsPid:
		return e.PID, nil
	case fields.PsPpid:
		ps := e.PS
		if ps == nil {
			return nil, ErrPsNil
		}
		return ps.Ppid, nil
	case fields.PsName:
		ps := e.PS
		if ps == nil {
			return nil, ErrPsNil
		}
		return ps.Name, nil
	case fields.PsComm, fields.PsCmdline:
		ps := e.PS
		if ps == nil {
			return nil, ErrPsNil
		}
		return ps.Cmdline, nil
	case fields.PsExe:
		ps := e.PS
		if ps == nil {
			return nil, ErrPsNil
		}
		return ps.Exe, nil
	case fields.PsArgs:
		ps := e.PS
		if ps == nil {
			return nil, ErrPsNil
		}
		return ps.Args, nil
	case fields.PsCwd:
		ps := e.PS
		if ps == nil {
			return nil, ErrPsNil
		}
		return ps.Cwd, nil
	case fields.PsSID:
		ps := e.PS
		if ps == nil {
			return nil, ErrPsNil
		}
		return ps.SID, nil
	case fields.PsIsWOW64Field:
		ps := e.PS
		if ps == nil {
			return nil, ErrPsNil
		}
		return ps.IsWOW64, nil
	case fields.PsIsPackagedField:
		ps := e.PS
		if ps == nil {
			return nil, ErrPsNil
		}
		return ps.IsPackaged, nil
	case fields.PsIsProtectedField:
		ps := e.PS
		if ps == nil {
			return nil, ErrPsNil
		}
		return ps.IsProtected, nil
	case fields.PsDomain:
		ps := e.PS
		if ps == nil {
			return nil, ErrPsNil
		}
		return ps.Domain, nil
	case fields.PsUsername:
		ps := e.PS
		if ps == nil {
			return nil, ErrPsNil
		}
		return ps.Username, nil
	case fields.PsSessionID:
		ps := e.PS
		if ps == nil {
			return nil, nil
		}
		return ps.SessionID, nil
	case fields.PsAccessMask:
		if e.Type != event.OpenProcess {
			return nil, nil
		}
		return e.Params.GetString(params.DesiredAccess)
	case fields.PsAccessMaskNames:
		if e.Type != event.OpenProcess {
			return nil, nil
		}
		return e.GetFlagsAsSlice(params.DesiredAccess), nil
	case fields.PsAccessStatus:
		if e.Type != event.OpenProcess {
			return nil, nil
		}
		return e.GetParamAsString(params.NTStatus), nil
	case fields.PsModuleNames:
		ps := e.PS
		if ps == nil {
			return nil, ErrPsNil
		}
		mods := make([]string, 0, len(ps.Modules))
		for _, m := range ps.Modules {
			mods = append(mods, m.Name)
		}
		return mods, nil
	case fields.PsUUID:
		ps := e.PS
		if ps == nil {
			return nil, ErrPsNil
		}
		return ps.UUID(), nil
	case fields.PsParentUUID:
		ps := getParentPs(e)
		if ps == nil {
			return nil, ErrPsNil
		}
		return ps.UUID(), nil
	case fields.PsHandleNames:
		ps := e.PS
		if ps == nil {
			return nil, ErrPsNil
		}
		handles := make([]string, len(ps.Handles))
		for i, handle := range ps.Handles {
			handles[i] = handle.Name
		}
		return handles, nil
	case fields.PsHandleTypes:
		ps := e.PS
		if ps == nil {
			return nil, ErrPsNil
		}
		types := make([]string, len(ps.Handles))
		for i, handle := range ps.Handles {
			if types[i] == handle.Type {
				continue
			}
			types[i] = handle.Type
		}
		return types, nil
	case fields.PsParentPid:
		parent := getParentPs(e)
		if parent == nil {
			return nil, ErrPsNil
		}
		return parent.PID, nil
	case fields.PsParentName:
		parent := getParentPs(e)
		if parent == nil {
			return nil, ErrPsNil
		}
		return parent.Name, nil
	case fields.PsParentComm, fields.PsParentCmdline:
		parent := getParentPs(e)
		if parent == nil {
			return nil, ErrPsNil
		}
		return parent.Cmdline, nil
	case fields.PsParentExe:
		parent := getParentPs(e)
		if parent == nil {
			return nil, ErrPsNil
		}
		return parent.Exe, nil
	case fields.PsParentArgs:
		parent := getParentPs(e)
		if parent == nil {
			return nil, ErrPsNil
		}
		return parent.Args, nil
	case fields.PsParentCwd:
		parent := getParentPs(e)
		if parent == nil {
			return nil, ErrPsNil
		}
		return parent.Cwd, nil
	case fields.PsParentSID:
		parent := getParentPs(e)
		if parent == nil {
			return nil, ErrPsNil
		}
		return parent.SID, nil
	case fields.PsParentDomain:
		ps := getParentPs(e)
		if ps == nil {
			return nil, ErrPsNil
		}
		return ps.Domain, nil
	case fields.PsParentUsername:
		ps := getParentPs(e)
		if ps == nil {
			return nil, ErrPsNil
		}
		return ps.Username, nil
	case fields.PsParentSessionID:
		ps := getParentPs(e)
		if ps == nil {
			return nil, ErrPsNil
		}
		return ps.SessionID, nil
	case fields.PsParentEnvs:
		ps := getParentPs(e)
		if ps == nil {
			return nil, ErrPsNil
		}
		envs := make([]string, 0, len(ps.Envs))
		for k, v := range ps.Envs {
			envs = append(envs, k+":"+v)
		}
		return envs, nil
	case fields.PsParentHandles:
		ps := getParentPs(e)
		if ps == nil {
			return nil, ErrPsNil
		}
		handles := make([]string, len(ps.Handles))
		for i, handle := range ps.Handles {
			handles[i] = handle.Name
		}
		return handles, nil
	case fields.PsParentHandleTypes:
		ps := getParentPs(e)
		if ps == nil {
			return nil, ErrPsNil
		}
		types := make([]string, len(ps.Handles))
		for i, handle := range ps.Handles {
			if types[i] == handle.Type {
				continue
			}
			types[i] = handle.Type
		}
		return types, nil
	case fields.PsParentIsWOW64Field:
		ps := getParentPs(e)
		if ps == nil {
			return nil, ErrPsNil
		}
		return ps.IsWOW64, nil
	case fields.PsParentIsPackagedField:
		ps := getParentPs(e)
		if ps == nil {
			return nil, ErrPsNil
		}
		return ps.IsPackaged, nil
	case fields.PsParentIsProtectedField:
		ps := getParentPs(e)
		if ps == nil {
			return nil, ErrPsNil
		}
		return ps.IsProtected, nil
	case fields.PsTokenIntegrityLevel:
		ps := e.PS
		if ps == nil {
			return nil, ErrPsNil
		}
		return ps.TokenIntegrityLevel, nil
	case fields.PsTokenElevationType:
		ps := e.PS
		if ps == nil {
			return nil, ErrPsNil
		}
		return ps.TokenElevationType, nil
	case fields.PsTokenIsElevated:
		ps := e.PS
		if ps == nil {
			return nil, ErrPsNil
		}
		return ps.IsTokenElevated, nil
	case fields.PsParentTokenIntegrityLevel:
		ps := getParentPs(e)
		if ps == nil {
			return nil, ErrPsNil
		}
		return ps.TokenIntegrityLevel, nil
	case fields.PsParentTokenElevationType:
		ps := getParentPs(e)
		if ps == nil {
			return nil, ErrPsNil
		}
		return ps.TokenElevationType, nil
	case fields.PsParentTokenIsElevated:
		ps := getParentPs(e)
		if ps == nil {
			return nil, ErrPsNil
		}
		return ps.IsTokenElevated, nil
	case fields.PsAncestors:
		if e.PS != nil {
			ancestors := make([]*pstypes.PS, 0)
			walk := func(proc *pstypes.PS) {
				if proc != nil {
					ancestors = append(ancestors, proc)
				}
			}
			pstypes.Walk(walk, e.PS)

			return ancestors, nil
		}
		return nil, ErrPsNil
	case fields.PsModules:
		if e.PS != nil {
			return e.PS.Modules, nil
		}
		return nil, ErrPsNil
	case fields.PsThreads:
		if e.PS != nil {
			return e.PS.Threads, nil
		}
		return nil, ErrPsNil
	case fields.PsMmaps:
		if e.PS != nil {
			return e.PS.Mmaps, nil
		}
		return nil, ErrPsNil
	case fields.PsAncestor:
		if e.PS != nil {
			n := -1
			// if the index is given try to parse it
			// to access the ancestor at the given level.
			// For example, ps.ancestor[0] would retrieve
			// the process parent, ps.ancestor[1] would
			// return the process grandparent and so on.
			if f.Arg != "" {
				var err error
				n, err = strconv.Atoi(f.Arg)
				if err != nil {
					return nil, err
				}
			}

			ancestors := make([]string, 0)
			walk := func(proc *pstypes.PS) {
				if proc != nil {
					ancestors = append(ancestors, proc.Name)
				}
			}
			pstypes.Walk(walk, e.PS)

			if n >= 0 {
				// return a single ancestor indicated by the index
				if n < len(ancestors) {
					return ancestors[n], nil
				} else {
					return "", nil
				}
			} else {
				// return all ancestors
				return ancestors, nil
			}
		}
		return nil, ErrPsNil
	case fields.PsEnvs:
		ps := e.PS
		if ps == nil {
			return nil, ErrPsNil
		}
		// resolve a single env variable indicated by the arg
		// For example, ps.envs[winroot] would return the value
		// of the winroot environment variable
		if f.Arg != "" {
			env := f.Arg
			v, ok := ps.Envs[env]
			if ok {
				return v, nil
			}

			// match on env variable name prefix
			for k, v := range ps.Envs {
				if strings.HasPrefix(k, env) {
					return v, nil
				}
			}
		} else {
			// return all environment variables as a string slice
			envs := make([]string, 0, len(ps.Envs))
			for k, v := range ps.Envs {
				envs = append(envs, k+":"+v)
			}
			return envs, nil
		}
	}

	return nil, nil
}

// threadAccessor fetches thread parameters from thread events.
type threadAccessor struct{}

func (threadAccessor) SetFields([]Field)            {}
func (threadAccessor) SetSegments([]fields.Segment) {}
func (threadAccessor) IsFieldAccessible(e *event.Event) bool {
	return !e.Callstack.IsEmpty() || e.Category == event.Thread
}

func newThreadAccessor() Accessor {
	return &threadAccessor{}
}

func (t *threadAccessor) Get(f Field, e *event.Event) (params.Value, error) {
	switch f.Name {
	case fields.ThreadBasePrio:
		return e.Params.GetUint8(params.BasePrio)
	case fields.ThreadIOPrio:
		return e.Params.GetUint8(params.IOPrio)
	case fields.ThreadPagePrio:
		return e.Params.GetUint8(params.PagePrio)
	case fields.ThreadKstackBase:
		return e.GetParamAsString(params.KstackBase), nil
	case fields.ThreadKstackLimit:
		return e.GetParamAsString(params.KstackLimit), nil
	case fields.ThreadUstackBase:
		return e.GetParamAsString(params.UstackBase), nil
	case fields.ThreadUstackLimit:
		return e.GetParamAsString(params.UstackLimit), nil
	case fields.ThreadEntrypoint, fields.ThreadStartAddress:
		return e.GetParamAsString(params.StartAddress), nil
	case fields.ThreadPID:
		return e.Params.GetUint32(params.ProcessID)
	case fields.ThreadTEB:
		return e.GetParamAsString(params.TEB), nil
	case fields.ThreadAccessMask:
		if e.Type != event.OpenThread {
			return nil, nil
		}
		return e.Params.GetString(params.DesiredAccess)
	case fields.ThreadAccessMaskNames:
		if e.Type != event.OpenThread {
			return nil, nil
		}
		return e.GetFlagsAsSlice(params.DesiredAccess), nil
	case fields.ThreadAccessStatus:
		if e.Type != event.OpenThread {
			return nil, nil
		}
		return e.GetParamAsString(params.NTStatus), nil
	case fields.ThreadCallstackSummary:
		return e.Callstack.Summary(), nil
	case fields.ThreadCallstackDetail:
		return e.Callstack.String(), nil
	case fields.ThreadCallstackModules:
		// return the module at the given frame level
		if f.Arg != "" {
			n, err := strconv.Atoi(f.Arg)
			if err != nil {
				return nil, err
			}

			if n > e.Callstack.Depth() {
				return "", nil
			}

			return e.Callstack.FrameAt(n).Module, nil
		}

		return e.Callstack.Modules(), nil
	case fields.ThreadCallstackSymbols:
		// return the symbol at the given frame level
		if f.Arg != "" {
			n, err := strconv.Atoi(f.Arg)
			if err != nil {
				return nil, err
			}

			if n > e.Callstack.Depth() {
				return "", nil
			}

			return e.Callstack.FrameAt(n).Symbol, nil
		}

		return e.Callstack.Symbols(), nil
	case fields.ThreadCallstackAllocationSizes:
		return e.Callstack.AllocationSizes(framePID(e)), nil
	case fields.ThreadCallstackProtections:
		return e.Callstack.Protections(framePID(e)), nil
	case fields.ThreadCallstackCallsiteLeadingAssembly:
		return e.Callstack.CallsiteInsns(framePID(e), true), nil
	case fields.ThreadCallstackCallsiteTrailingAssembly:
		return e.Callstack.CallsiteInsns(framePID(e), false), nil
	case fields.ThreadCallstackIsUnbacked:
		return e.Callstack.ContainsUnbacked(), nil
	case fields.ThreadCallstack:
		return e.Callstack, nil
	case fields.ThreadStartAddressSymbol:
		if e.Type != event.CreateThread {
			return nil, nil
		}
		return e.GetParamAsString(params.StartAddressSymbol), nil
	case fields.ThreadStartAddressModule:
		if e.Type != event.CreateThread {
			return nil, nil
		}
		return e.GetParamAsString(params.StartAddressModule), nil
	case fields.ThreadCallstackAddresses:
		return e.Callstack.Addresses(), nil
	case fields.ThreadCallstackFinalUserModuleName, fields.ThreadCallstackFinalUserModulePath:
		frame := e.Callstack.FinalUserFrame()
		if frame != nil {
			if f.Name == fields.ThreadCallstackFinalUserModuleName {
				return filepath.Base(frame.Module), nil
			}
			return frame.Module, nil
		}
		return nil, nil
	case fields.ThreadCallstackFinalUserSymbolName:
		frame := e.Callstack.FinalUserFrame()
		if frame != nil {
			return frame.Symbol, nil
		}
		return nil, nil
	case fields.ThreadCallstackFinalKernelModuleName, fields.ThreadCallstackFinalKernelModulePath:
		frame := e.Callstack.FinalKernelFrame()
		if frame != nil {
			if f.Name == fields.ThreadCallstackFinalKernelModuleName {
				return filepath.Base(frame.Module), nil
			}
			return frame.Module, nil
		}
		return nil, nil
	case fields.ThreadCallstackFinalKernelSymbolName:
		frame := e.Callstack.FinalKernelFrame()
		if frame != nil {
			return frame.Symbol, nil
		}
		return nil, nil
	case fields.ThreadCallstackFinalUserModuleSignatureExists, fields.ThreadCallstackFinalUserModuleSignatureTrusted:
		frame := e.Callstack.FinalUserFrame()
		if frame == nil || (frame != nil && frame.ModuleAddress.IsZero()) {
			return nil, nil
		}

		sign := getSignature(frame.ModuleAddress, frame.Module, false)
		if sign == nil {
			return nil, nil
		}

		if f.Name == fields.ThreadCallstackFinalUserModuleSignatureExists {
			return sign.IsSigned(), nil
		}

		return sign.IsTrusted(), nil
	case fields.ThreadCallstackFinalUserModuleSignatureIssuer, fields.ThreadCallstackFinalUserModuleSignatureSubject:
		frame := e.Callstack.FinalUserFrame()
		if frame == nil || (frame != nil && frame.ModuleAddress.IsZero()) {
			return nil, nil
		}

		sign := getSignature(frame.ModuleAddress, frame.Module, true)
		if sign == nil {
			return nil, nil
		}

		if sign.HasCertificate() && f.Name == fields.ThreadCallstackFinalUserModuleSignatureIssuer {
			return sign.Cert.Issuer, nil
		}

		if sign.HasCertificate() {
			return sign.Cert.Subject, nil
		}
	}

	return nil, nil
}

// fileAccessor extracts file specific values.
type fileAccessor struct{}

func (fileAccessor) SetFields(fields []Field) {
	initLOLDriversClient(fields)
}
func (fileAccessor) SetSegments([]fields.Segment) {}

func (fileAccessor) IsFieldAccessible(e *event.Event) bool { return e.Category == event.File }

func newFileAccessor() Accessor {
	return &fileAccessor{}
}

func (l *fileAccessor) Get(f Field, e *event.Event) (params.Value, error) {
	switch f.Name {
	case fields.FilePath:
		return e.GetParamAsString(params.FilePath), nil
	case fields.FilePathStem:
		path := e.GetParamAsString(params.FilePath)
		n := strings.LastIndexByte(path, '.')
		if n == -1 {
			return path, nil
		}
		return path[:n], nil
	case fields.FileName:
		return filepath.Base(e.GetParamAsString(params.FilePath)), nil
	case fields.FileExtension:
		return filepath.Ext(e.GetParamAsString(params.FilePath)), nil
	case fields.FileOffset:
		return e.Params.GetUint64(params.FileOffset)
	case fields.FileIOSize:
		return e.Params.GetUint32(params.FileIoSize)
	case fields.FileShareMask:
		return e.GetParamAsString(params.FileShareMask), nil
	case fields.FileOperation:
		return e.GetParamAsString(params.FileOperation), nil
	case fields.FileObject:
		return e.Params.GetUint64(params.FileObject)
	case fields.FileType:
		return e.GetParamAsString(params.FileType), nil
	case fields.FileAttributes:
		return e.GetFlagsAsSlice(params.FileAttributes), nil
	case fields.FileStatus:
		if e.Type != event.CreateFile {
			return nil, nil
		}
		return e.GetParamAsString(params.NTStatus), nil
	case fields.FileViewBase:
		return e.GetParamAsString(params.FileViewBase), nil
	case fields.FileViewSize:
		return e.Params.GetUint64(params.FileViewSize)
	case fields.FileViewType:
		return e.GetParamAsString(params.FileViewSectionType), nil
	case fields.FileViewProtection:
		return e.GetParamAsString(params.MemProtect), nil
	case fields.FileIsDriverVulnerable, fields.FileIsDriverMalicious:
		if e.IsCreateDisposition() && e.IsSuccess() {
			return isLOLDriver(f.Name, e)
		}
		return false, nil
	case fields.FileIsDLL:
		return e.Params.GetBool(params.FileIsDLL)
	case fields.FileIsDriver:
		return e.Params.GetBool(params.FileIsDriver)
	case fields.FileIsExecutable:
		return e.Params.GetBool(params.FileIsExecutable)
	case fields.FilePID:
		return e.Params.GetPid()
	case fields.FileKey:
		return e.Params.GetUint64(params.FileKey)
	case fields.FileInfoClass:
		return e.GetParamAsString(params.FileInfoClass), nil
	case fields.FileInfoAllocationSize:
		if e.Params.TryGetUint32(params.FileInfoClass) == fs.AllocationClass {
			return e.Params.GetUint64(params.FileExtraInfo)
		}
	case fields.FileInfoEOFSize:
		if e.Params.TryGetUint32(params.FileInfoClass) == fs.EOFClass {
			return e.Params.GetUint64(params.FileExtraInfo)
		}
	case fields.FileInfoIsDispositionDeleteFile:
		return e.Params.TryGetUint32(params.FileInfoClass) == fs.DispositionClass &&
			e.Params.TryGetUint64(params.FileExtraInfo) > 0, nil
	}

	return nil, nil
}

// moduleAccessor extracts module (DLL, executable, driver) event values.
type moduleAccessor struct{}

func (moduleAccessor) SetFields(fields []Field) {
	initLOLDriversClient(fields)
}
func (moduleAccessor) SetSegments([]fields.Segment) {}

func (moduleAccessor) IsFieldAccessible(e *event.Event) bool {
	return e.Category == event.Image
}

func newModuleAccessor() Accessor {
	return &moduleAccessor{}
}

func (*moduleAccessor) Get(f Field, e *event.Event) (params.Value, error) {
	if e.IsLoadImage() && (f.Name.IsModuleSignature() || f.Name == fields.ImageSignatureType || f.Name == fields.ImageSignatureLevel || f.Name.IsImageCert()) {
		filename := e.GetParamAsString(params.ImagePath)
		addr := e.Params.MustGetUint64(params.ImageBase)
		typ := e.Params.MustGetUint32(params.ImageSignatureType)
		level := e.Params.MustGetUint32(params.ImageSignatureLevel)

		sign := signature.GetSignatures().GetSignature(addr)

		// signature already checked
		if typ != signature.None {
			if sign == nil {
				sign = &signature.Signature{
					Type:     typ,
					Level:    level,
					Filename: filename,
				}
			}
			if f.Name.IsImageCert() || f.Name.IsModuleCert() {
				err := sign.ParseCertificate()
				if err != nil {
					certErrors.Add(1)
				}
			}
			signature.GetSignatures().PutSignature(addr, sign)
		} else {
			// image signature parameters exhibit unreliable behaviour. Allegedly,
			// signature verification is not performed in certain circumstances
			// which leads to the core system DLL or binaries to be reported with
			// signature unchecked level.
			// To mitigate this situation, we have to manually check/verify the
			// signature for all unchecked signature levels.
			if sign == nil {
				var err error
				sign = &signature.Signature{Filename: filename}
				sign.Type, sign.Level, err = sign.Check()
				if err != nil {
					signatureErrors.Add(1)
				}
				if sign.IsSigned() {
					sign.Verify()
				}
				if f.Name.IsImageCert() || f.Name.IsModuleCert() {
					err := sign.ParseCertificate()
					if err != nil {
						certErrors.Add(1)
					}
				}
				signature.GetSignatures().PutSignature(addr, sign)
			}
			// reset signature type/level parameters
			_ = e.Params.SetValue(params.ImageSignatureType, sign.Type)
			_ = e.Params.SetValue(params.ImageSignatureLevel, sign.Level)
		}

		// append certificate parameters
		if sign.HasCertificate() {
			e.AppendParam(params.ImageCertIssuer, params.UnicodeString, sign.Cert.Issuer)
			e.AppendParam(params.ImageCertSubject, params.UnicodeString, sign.Cert.Subject)
			e.AppendParam(params.ImageCertSerial, params.UnicodeString, sign.Cert.SerialNumber)
			e.AppendParam(params.ImageCertNotAfter, params.Time, sign.Cert.NotAfter)
			e.AppendParam(params.ImageCertNotBefore, params.Time, sign.Cert.NotBefore)
		}

		switch f.Name {
		case fields.ModuleSignatureExists, fields.DllSignatureExists:
			return sign != nil && sign.IsSigned(), nil
		case fields.ModuleSignatureTrusted, fields.DllSignatureTrusted:
			return sign != nil && sign.IsTrusted(), nil
		}
	}

	switch f.Name {
	case fields.ImagePath, fields.ModulePath, fields.DllPath:
		return e.GetParamAsString(params.ImagePath), nil
	case fields.ModulePathStem, fields.DllPathStem:
		path := e.GetParamAsString(params.ImagePath)
		n := strings.LastIndexByte(path, '.')
		if n == -1 {
			return path, nil
		}
		return path[:n], nil
	case fields.ImageName, fields.ModuleName, fields.DllName:
		return filepath.Base(e.GetParamAsString(params.ImagePath)), nil
	case fields.ImageDefaultAddress, fields.ModuleDefaultAddress:
		return e.GetParamAsString(params.ImageDefaultBase), nil
	case fields.ImageBase, fields.ModuleBase, fields.DllBase:
		return e.GetParamAsString(params.ImageBase), nil
	case fields.ImageSize, fields.ModuleSize, fields.DllSize:
		return e.Params.GetUint64(params.ImageSize)
	case fields.ImageChecksum, fields.ModuleChecksum:
		return e.Params.GetUint32(params.ImageCheckSum)
	case fields.ImagePID, fields.ModulePID, fields.DllPID:
		return e.Params.GetPid()
	case fields.ImageSignatureType, fields.ModuleSignatureType, fields.DllSignatureType:
		return e.GetParamAsString(params.ImageSignatureType), nil
	case fields.ImageSignatureLevel, fields.ModuleSignatureLevel, fields.DllSignatureLevel:
		return e.GetParamAsString(params.ImageSignatureLevel), nil
	case fields.ImageCertSubject, fields.ModuleSignatureSubject, fields.DllSignatureSubject:
		return e.GetParamAsString(params.ImageCertSubject), nil
	case fields.ImageCertIssuer, fields.ModuleSignatureIssuer, fields.DllSignatureIssuer:
		return e.GetParamAsString(params.ImageCertIssuer), nil
	case fields.ImageCertSerial, fields.ModuleSignatureSerial, fields.DllSignatureSerial:
		return e.GetParamAsString(params.ImageCertSerial), nil
	case fields.ImageCertBefore, fields.ModuleSignatureBefore, fields.DllSignatureBefore:
		return e.Params.GetTime(params.ImageCertNotBefore)
	case fields.ImageCertAfter, fields.ModuleSignatureAfter, fields.DllSignatureAfter:
		return e.Params.GetTime(params.ImageCertNotAfter)
	case fields.ImageIsDriverVulnerable, fields.ImageIsDriverMalicious, fields.ModuleIsDriverVulnerable, fields.ModuleIsDriverMalicious:
		if e.IsLoadImage() {
			return isLOLDriver(f.Name, e)
		}
		return false, nil
	case fields.ImageIsDLL, fields.ModuleIsDLL:
		return e.Params.GetBool(params.FileIsDLL)
	case fields.ImageIsDriver, fields.ModuleIsDriver:
		return e.Params.GetBool(params.FileIsDriver)
	case fields.ImageIsExecutable, fields.ModuleIsExecutable:
		return e.Params.GetBool(params.FileIsExecutable)
	case fields.ImageIsDotnet, fields.ModuleIsDotnet, fields.DllIsDotnet:
		return e.Params.GetBool(params.FileIsDotnet)
	}

	return nil, nil
}

// registryAccessor extracts registry specific parameters.
type registryAccessor struct{}

func (registryAccessor) SetFields([]Field)            {}
func (registryAccessor) SetSegments([]fields.Segment) {}
func (registryAccessor) IsFieldAccessible(e *event.Event) bool {
	return e.Category == event.Registry
}

func newRegistryAccessor() Accessor {
	return &registryAccessor{}
}

func (r *registryAccessor) Get(f Field, e *event.Event) (params.Value, error) {
	switch f.Name {
	case fields.RegistryPath:
		return e.GetParamAsString(params.RegPath), nil
	case fields.RegistryKeyName:
		if e.IsRegSetValue() {
			return filepath.Base(filepath.Dir(e.GetParamAsString(params.RegPath))), nil
		} else {
			return filepath.Base(e.GetParamAsString(params.RegPath)), nil
		}
	case fields.RegistryKeyHandle:
		return e.GetParamAsString(params.RegKeyHandle), nil
	case fields.RegistryValue:
		if e.IsRegSetValue() {
			return filepath.Base(filepath.Base(e.GetParamAsString(params.RegPath))), nil
		}
		return nil, nil
	case fields.RegistryValueType:
		return e.Params.GetString(params.RegValueType)
	case fields.RegistryData:
		return e.GetParamAsString(params.RegData), nil
	case fields.RegistryStatus:
		return e.GetParamAsString(params.NTStatus), nil
	}

	return nil, nil
}

// networkAccessor deals with extracting the network specific event parameters.
type networkAccessor struct {
	reverseDNS *network.ReverseDNS
}

func (n *networkAccessor) SetFields(flds []Field) {
	for _, f := range flds {
		if f.Name == fields.NetSIPNames || f.Name == fields.NetDIPNames {
			n.reverseDNS = network.GetReverseDNS(2000, time.Minute*30, time.Minute*2)
			break
		}
	}
}

func (networkAccessor) SetSegments([]fields.Segment) {}

func (networkAccessor) IsFieldAccessible(e *event.Event) bool {
	return e.Category == event.Net
}

func newNetworkAccessor() Accessor { return &networkAccessor{} }

func (n *networkAccessor) Get(f Field, e *event.Event) (params.Value, error) {
	switch f.Name {
	case fields.NetDIP:
		return e.Params.GetIP(params.NetDIP)
	case fields.NetSIP:
		return e.Params.GetIP(params.NetSIP)
	case fields.NetDport:
		return e.Params.GetUint16(params.NetDport)
	case fields.NetSport:
		return e.Params.GetUint16(params.NetSport)
	case fields.NetDportName:
		return e.Params.GetString(params.NetDportName)
	case fields.NetSportName:
		return e.Params.GetString(params.NetSportName)
	case fields.NetL4Proto:
		return e.GetParamAsString(params.NetL4Proto), nil
	case fields.NetPacketSize:
		return e.Params.GetUint32(params.NetSize)
	case fields.NetDIPNames:
		return n.resolveNamesForIP(e.Params.MustGetIP(params.NetDIP))
	case fields.NetSIPNames:
		return n.resolveNamesForIP(e.Params.MustGetIP(params.NetSIP))
	}

	return nil, nil
}

func (n *networkAccessor) resolveNamesForIP(ip net.IP) ([]string, error) {
	if n.reverseDNS == nil {
		return nil, nil
	}
	names, err := n.reverseDNS.Add(network.AddressFromIP(ip))
	if err != nil {
		return nil, err
	}
	return names, nil
}

// handleAccessor extracts handle event values.
type handleAccessor struct{}

func (handleAccessor) SetFields([]Field)            {}
func (handleAccessor) SetSegments([]fields.Segment) {}
func (handleAccessor) IsFieldAccessible(e *event.Event) bool {
	return e.Category == event.Handle
}

func newHandleAccessor() Accessor { return &handleAccessor{} }

func (h *handleAccessor) Get(f Field, e *event.Event) (params.Value, error) {
	switch f.Name {
	case fields.HandleID:
		return e.Params.GetUint32(params.HandleID)
	case fields.HandleType:
		return e.GetParamAsString(params.HandleObjectTypeID), nil
	case fields.HandleName:
		return e.Params.GetString(params.HandleObjectName)
	case fields.HandleObject:
		return e.Params.GetUint64(params.HandleObject)
	}

	return nil, nil
}

// peAccessor extracts PE specific values.
type peAccessor struct {
	fields   []Field
	segments []fields.Segment
}

func (pa *peAccessor) SetFields(fields []Field) {
	pa.fields = fields
}
func (pa *peAccessor) SetSegments(segments []fields.Segment) {
	pa.segments = segments
}

func (peAccessor) IsFieldAccessible(e *event.Event) bool {
	return e.PS != nil || e.IsLoadImage()
}

// parserOpts traverses all fields/segments declared in the expression and
// dynamically determines what aspects of the PE need to be parsed.
func (pa *peAccessor) parserOpts() []pe.Option {
	var opts []pe.Option
	var peSections bool

	for _, f := range pa.fields {
		if f.Name.IsPeSectionsPseudo() {
			peSections = true
		}
		if f.Name.IsPeSection() || f.Name.IsPeModified() {
			opts = append(opts, pe.WithSections())
		}
		if f.Name.IsPeSymbol() {
			opts = append(opts, pe.WithSymbols())
		}
		if f.Name.IsPeVersionResource() || f.Name.IsPeVersionResources() {
			opts = append(opts, pe.WithVersionResources())
		}
		if f.Name.IsPeImphash() {
			opts = append(opts, pe.WithImphash())
		}
		if f.Name.IsPeDotnet() || f.Name.IsPeModified() {
			opts = append(opts, pe.WithCLR())
		}
		if f.Name.IsPeAnomalies() {
			opts = append(opts, pe.WithSections(), pe.WithSymbols())
		}
		if f.Name.IsPeSignature() {
			opts = append(opts, pe.WithSecurity())
		}
	}

	for _, s := range pa.segments {
		if peSections && s.IsEntropy() {
			opts = append(opts, pe.WithSections(), pe.WithSectionEntropy())
		}
	}

	return opts
}

// ErrPeNilCertificate indicates the PE certificate is not available
var ErrPeNilCertificate = errors.New("pe certificate is nil")

func newPEAccessor() Accessor {
	return &peAccessor{}
}

func (pa *peAccessor) Get(f Field, e *event.Event) (params.Value, error) {
	var p *pe.PE
	if e.PS != nil && e.PS.PE != nil {
		p = e.PS.PE
	}

	// PE enrichment is likely disabled. Load PE data lazily
	// by only requesting parsing of the PE directories that
	// are relevant to the fields present in the expression.
	if e.PS != nil && e.PS.Exe != "" && p == nil {
		var err error
		exe := e.PS.Exe
		p, err = pe.ParseFile(exe, pa.parserOpts()...)
		if err != nil {
			return nil, err
		}
		e.PS.PE = p
	}

	// here we determine if the PE was tampered. This check
	// consists of two steps starting with parsing the disk
	// PE for loaded executables followed by fetching the PE
	// from process' memory at the base address of the loaded
	// executable image
	if e.IsLoadImage() && f.Name.IsPeModified() {
		filename := e.GetParamAsString(params.ImagePath)
		isExecutable := filepath.Ext(filename) == ".exe" || e.Params.TryGetBool(params.FileIsExecutable)
		if !isExecutable {
			return nil, nil
		}

		pid := e.Params.MustGetPid()
		addr := e.Params.MustGetUint64(params.ImageBase)

		file, err := pe.ParseFile(filename, pa.parserOpts()...)
		if err != nil {
			return nil, err
		}
		mem, err := pe.ParseMem(pid, uintptr(addr), false, pa.parserOpts()...)
		if err != nil {
			return nil, err
		}
		isModified := file.IsHeaderModified(mem)
		if p != nil {
			p.IsModified = isModified
		}
		return isModified, nil
	}

	if p == nil {
		return nil, ErrPENil
	}

	// verify signature
	if f.Name.IsPeSignature() {
		p.VerifySignature()
	}

	switch f.Name {
	case fields.PeEntrypoint, fields.PsPeEntrypoint:
		return p.EntryPoint, nil
	case fields.PeBaseAddress, fields.PsPeBaseAddress:
		return p.ImageBase, nil
	case fields.PeNumSections, fields.PsPeNumSections:
		return p.NumberOfSections, nil
	case fields.PeNumSymbols, fields.PsPeNumSymbols:
		return p.NumberOfSymbols, nil
	case fields.PeSymbols, fields.PsPeSymbols:
		return p.Symbols, nil
	case fields.PeImports, fields.PsPeImports:
		return p.Imports, nil
	case fields.PeImphash, fields.PsPeImphash:
		return p.Imphash, nil
	case fields.PeIsDotnet, fields.PsPeIsDotnet:
		return p.IsDotnet, nil
	case fields.PeAnomalies, fields.PsPeAnomalies:
		return p.Anomalies, nil
	case fields.PeIsSigned, fields.PsSignatureExists:
		return p.IsSigned, nil
	case fields.PeIsTrusted, fields.PsSignatureTrusted:
		return p.IsTrusted, nil
	case fields.PeIsModified:
		return p.IsModified, nil
	case fields.PeCertIssuer, fields.PsSignatureIssuer:
		if p.Cert == nil {
			return nil, ErrPeNilCertificate
		}
		return p.Cert.Issuer, nil
	case fields.PeCertSubject, fields.PsSignatureSubject:
		if p.Cert == nil {
			return nil, ErrPeNilCertificate
		}
		return p.Cert.Subject, nil
	case fields.PeCertSerial, fields.PsSignatureSerial:
		if p.Cert == nil {
			return nil, ErrPeNilCertificate
		}
		return p.Cert.SerialNumber, nil
	case fields.PeCertAfter, fields.PsSignatureAfter:
		if p.Cert == nil {
			return nil, ErrPeNilCertificate
		}
		return p.Cert.NotAfter, nil
	case fields.PeCertBefore, fields.PsSignatureBefore:
		if p.Cert == nil {
			return nil, ErrPeNilCertificate
		}
		return p.Cert.NotBefore, nil
	case fields.PeIsDLL:
		return e.Params.GetBool(params.FileIsDLL)
	case fields.PeIsDriver:
		return e.Params.GetBool(params.FileIsDriver)
	case fields.PeIsExecutable:
		return e.Params.GetBool(params.FileIsExecutable)
	case fields.PeCompany, fields.PsPeCompany:
		return p.VersionResources[pe.Company], nil
	case fields.PeCopyright, fields.PsPeCopyright:
		return p.VersionResources[pe.LegalCopyright], nil
	case fields.PeDescription, fields.PsPeDescription:
		return p.VersionResources[pe.FileDescription], nil
	case fields.PeFileName, fields.PsPeFileName:
		return p.VersionResources[pe.OriginalFilename], nil
	case fields.PeFileVersion, fields.PsPeFileVersion:
		return p.VersionResources[pe.FileVersion], nil
	case fields.PeProduct, fields.PsPeProduct:
		return p.VersionResources[pe.ProductName], nil
	case fields.PeProductVersion, fields.PsPeProductVersion:
		return p.VersionResources[pe.ProductVersion], nil
	case fields.PeSections, fields.PsPeSections:
		return p.Sections, nil
	case fields.PeResources, fields.PsPeResources:
		// return a single version resource indicated by the arg.
		// For example, pe.resources[FileDescription] returns the
		// original file description present in the resource directory
		key := f.Arg
		if key != "" {
			v, ok := p.VersionResources[key]
			if ok {
				return v, nil
			}

			// match on version name prefix
			for k, v := range p.VersionResources {
				if strings.HasPrefix(k, key) {
					return v, nil
				}
			}
		} else {
			// return all version resources as a string slice
			resources := make([]string, 0, len(p.VersionResources))
			for k, v := range p.VersionResources {
				resources = append(resources, k+":"+v)
			}
			return resources, nil
		}
	}

	return nil, nil
}

// memAccessor extracts parameters from memory alloc/free events.
type memAccessor struct{}

func (memAccessor) SetFields([]Field)                     {}
func (memAccessor) SetSegments([]fields.Segment)          {}
func (memAccessor) IsFieldAccessible(e *event.Event) bool { return e.Category == event.Mem }

func newMemAccessor() Accessor {
	return &memAccessor{}
}

func (*memAccessor) Get(f Field, e *event.Event) (params.Value, error) {
	switch f.Name {
	case fields.MemPageType:
		return e.GetParamAsString(params.MemPageType), nil
	case fields.MemAllocType:
		return e.GetParamAsString(params.MemAllocType), nil
	case fields.MemProtection:
		return e.GetParamAsString(params.MemProtect), nil
	case fields.MemBaseAddress:
		return e.Params.GetUint64(params.MemBaseAddress)
	case fields.MemRegionSize:
		return e.Params.GetUint64(params.MemRegionSize)
	case fields.MemProtectionMask:
		return e.Params.GetString(params.MemProtectMask)
	}

	return nil, nil
}

// dnsAccessor extracts values from DNS query/response event parameters.
type dnsAccessor struct{}

func (dnsAccessor) SetFields([]Field)            {}
func (dnsAccessor) SetSegments([]fields.Segment) {}
func (dnsAccessor) IsFieldAccessible(e *event.Event) bool {
	return e.Type.Subcategory() == event.DNS
}

func newDNSAccessor() Accessor {
	return &dnsAccessor{}
}

func (*dnsAccessor) Get(f Field, e *event.Event) (params.Value, error) {
	switch f.Name {
	case fields.DNSName:
		return e.GetParamAsString(params.DNSName), nil
	case fields.DNSRR:
		return e.GetParamAsString(params.DNSRR), nil
	case fields.DNSRcode:
		return e.GetParamAsString(params.DNSRcode), nil
	case fields.DNSOptions:
		return e.GetFlagsAsSlice(params.DNSOpts), nil
	case fields.DNSAnswers:
		return e.Params.GetSlice(params.DNSAnswers)
	}

	return nil, nil
}

// threadpoolAccessor extracts values from thread pool events
type threadpoolAccessor struct{}

func (threadpoolAccessor) SetFields([]Field)            {}
func (threadpoolAccessor) SetSegments([]fields.Segment) {}
func (threadpoolAccessor) IsFieldAccessible(e *event.Event) bool {
	return e.Category == event.Threadpool
}

func newThreadpoolAccessor() Accessor {
	return &threadpoolAccessor{}
}

func (*threadpoolAccessor) Get(f Field, e *event.Event) (params.Value, error) {
	switch f.Name {
	case fields.ThreadpoolPoolID:
		return e.GetParamAsString(params.ThreadpoolPoolID), nil
	case fields.ThreadpoolTaskID:
		return e.GetParamAsString(params.ThreadpoolTaskID), nil
	case fields.ThreadpoolCallbackAddress:
		return e.GetParamAsString(params.ThreadpoolCallback), nil
	case fields.ThreadpoolCallbackSymbol:
		return e.GetParamAsString(params.ThreadpoolCallbackSymbol), nil
	case fields.ThreadpoolCallbackModule:
		return e.GetParamAsString(params.ThreadpoolCallbackModule), nil
	case fields.ThreadpoolCallbackContext:
		return e.GetParamAsString(params.ThreadpoolContext), nil
	case fields.ThreadpoolCallbackContextRip:
		return e.GetParamAsString(params.ThreadpoolContextRip), nil
	case fields.ThreadpoolCallbackContextRipSymbol:
		return e.GetParamAsString(params.ThreadpoolContextRipSymbol), nil
	case fields.ThreadpoolCallbackContextRipModule:
		return e.GetParamAsString(params.ThreadpoolContextRipModule), nil
	case fields.ThreadpoolSubprocessTag:
		return e.GetParamAsString(params.ThreadpoolSubprocessTag), nil
	case fields.ThreadpoolTimer:
		return e.GetParamAsString(params.ThreadpoolTimer), nil
	case fields.ThreadpoolTimerSubqueue:
		return e.GetParamAsString(params.ThreadpoolTimerSubqueue), nil
	case fields.ThreadpoolTimerDuetime:
		return e.Params.GetUint64(params.ThreadpoolTimerDuetime)
	case fields.ThreadpoolTimerPeriod:
		return e.Params.GetUint32(params.ThreadpoolTimerPeriod)
	case fields.ThreadpoolTimerWindow:
		return e.Params.GetUint32(params.ThreadpoolTimerWindow)
	case fields.ThreadpoolTimerAbsolute:
		return e.Params.GetBool(params.ThreadpoolTimerAbsolute)
	}

	return nil, nil
}

```

`pkg/filter/accessor_windows_test.go`:

```go
/*
 * Copyright 2019-2020 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package filter

import (
	"reflect"
	"testing"

	"github.com/rabbitstack/fibratus/pkg/callstack"
	"github.com/rabbitstack/fibratus/pkg/event"
	ptypes "github.com/rabbitstack/fibratus/pkg/ps/types"
	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/require"
)

func TestNarrowAccessors(t *testing.T) {
	var tests = []struct {
		f                 Filter
		expectedAccessors int
	}{
		{
			New(`ps.name = 'cmd.exe' and evt.name = 'CreateProcess' or evt.name in ('TerminateProcess', 'CreateFile')`, cfg),
			2,
		},
		{
			New(`foreach(ps._modules, $mod, $mod.path = 'C:\\Windows\\System32')`, cfg),
			1,
		},
		{
			New(`handle.type = 'Section' and ps.pe.nsections > 1 and evt.name = 'CreateHandle'`, cfg),
			3,
		},
		{
			New(`sequence |evt.name = 'CreateProcess'| as e1 |evt.name = 'CreateFile' and file.name = $e1.ps.exe |`, cfg),
			3,
		},
		{
			New(`base(file.name) = 'kernel32.dll'`, cfg),
			1,
		},
	}

	var pea *peAccessor

	for i, tt := range tests {
		require.NoError(t, tt.f.Compile())
		naccessors := len(tt.f.(*filter).accessors)
		if tt.expectedAccessors != naccessors {
			t.Errorf("%d. accessors mismatch: exp=%d got=%d", i, tt.expectedAccessors, naccessors)
		}
		for _, a := range tt.f.(*filter).accessors {
			if reflect.TypeOf(a) == reflect.TypeOf(&peAccessor{}) {
				pea = a.(*peAccessor)
			}
		}
	}
	// check if fields are set in the accessor
	require.NotNil(t, pea)
	assert.Len(t, pea.fields, 3)
}

func TestIsFieldAccessible(t *testing.T) {
	var tests = []struct {
		a            Accessor
		e            *event.Event
		isAccessible bool
	}{
		{
			newEventAccessor(),
			&event.Event{Type: event.QueryDNS, Category: event.Net},
			true,
		},
		{
			newPSAccessor(nil),
			&event.Event{Type: event.CreateProcess, Category: event.Process},
			true,
		},
		{
			newPSAccessor(nil),
			&event.Event{PS: &ptypes.PS{}, Type: event.CreateFile, Category: event.File},
			true,
		},
		{
			newPSAccessor(nil),
			&event.Event{Type: event.SetThreadContext, Category: event.Thread},
			false,
		},
		{
			newThreadAccessor(),
			&event.Event{Type: event.SetThreadContext, Category: event.Thread},
			true,
		},
		{
			newThreadAccessor(),
			&event.Event{Type: event.CreateProcess, Category: event.Process, Callstack: []callstack.Frame{{Addr: 0x7ffb5c1d0396, Offset: 0x61, Symbol: "CreateProcessW", Module: "C:\\WINDOWS\\System32\\KERNELBASE.dll"}}},
			true,
		},
		{
			newThreadAccessor(),
			&event.Event{Type: event.RegSetValue, Category: event.Registry, Callstack: []callstack.Frame{{Addr: 0x7ffb5c1d0396, Offset: 0x61, Symbol: "CreateProcessW", Module: "C:\\WINDOWS\\System32\\KERNELBASE.dll"}}},
			true,
		},
		{
			newRegistryAccessor(),
			&event.Event{Type: event.RegSetValue, Category: event.Registry, Callstack: []callstack.Frame{{Addr: 0x7ffb5c1d0396, Offset: 0x61, Symbol: "CreateProcessW", Module: "C:\\WINDOWS\\System32\\KERNELBASE.dll"}}},
			true,
		},
		{
			newNetworkAccessor(),
			&event.Event{Type: event.RegSetValue, Category: event.Registry, Callstack: []callstack.Frame{{Addr: 0x7ffb5c1d0396, Offset: 0x61, Symbol: "CreateProcessW", Module: "C:\\WINDOWS\\System32\\KERNELBASE.dll"}}},
			false,
		},
		{
			newNetworkAccessor(),
			&event.Event{Type: event.ConnectTCPv6, Category: event.Net},
			true,
		},
		{
			newDNSAccessor(),
			&event.Event{Type: event.ReplyDNS, Category: event.Net},
			true,
		},
		{
			newModuleAccessor(),
			&event.Event{Type: event.LoadImage, Category: event.Image},
			true,
		},
		{
			newMemAccessor(),
			&event.Event{Type: event.VirtualAlloc, Category: event.Mem},
			true,
		},
	}

	for i, tt := range tests {
		isAccessible := tt.a.IsFieldAccessible(tt.e)
		if tt.isAccessible != isAccessible {
			t.Errorf("%d. accessors is field accessible condition mismatch: exp=%t got=%t", i, tt.isAccessible, isAccessible)
		}
	}
}

```

`pkg/filter/fields/fields.go`:

```go
/*
 * Copyright 2020-2021 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package fields

import (
	"github.com/rabbitstack/fibratus/pkg/event/params"
	"sort"
	"unicode"
)

// FieldInfo is the field metadata descriptor.
type FieldInfo struct {
	Field       Field
	Desc        string
	Type        params.Type
	Examples    []string
	Deprecation *Deprecation
	Argument    *Argument
}

// isNumber is the field argument validation function that
// returns true if all characters are digits.
var isNumber = func(s string) bool {
	for _, c := range s {
		if !unicode.IsNumber(c) {
			return false
		}
	}
	return true
}

// Argument defines field argument information.
type Argument struct {
	// Optional indicates if the argument is optional.
	Optional bool
	// ValidationFunc is the field argument validation function.
	// It returns true if the provided argument is valid, or false
	// otherwise.
	ValidationFunc func(string) bool
	// Pattern contains the regular expression like string that
	// represents the character set allowed for the argument value.
	Pattern string
}

// Validate validates the provided field argument.
func (a *Argument) Validate(v string) bool {
	if a.ValidationFunc == nil {
		return true
	}
	return a.ValidationFunc(v)
}

// IsDeprecated determines if the field is deprecated.
func (f FieldInfo) IsDeprecated() bool { return f.Deprecation != nil }

// Deprecation specifies field deprecation info.
type Deprecation struct {
	// Since denotes from which version the field is flagged as deprecated
	Since string
	// Fields represents the fields by which the deprecated field is superseded
	Fields []Field
}

// Get returns a slice of field information.
func Get() []FieldInfo {
	fi := make([]FieldInfo, 0, len(fields))
	for _, field := range fields {
		fi = append(fi, field)
	}
	sort.Slice(fi, func(i, j int) bool { return fi[i].Field < fi[j].Field })
	return fi
}

// IsDeprecated determines if the given field is deprecated.
func IsDeprecated(f Field) (bool, *Deprecation) {
	for _, field := range fields {
		if field.Field == f && field.IsDeprecated() {
			return true, field.Deprecation
		}
	}
	return false, nil
}

// IsBoolean determines if the given field has the bool type.
func IsBoolean(f Field) bool {
	return fields[f].Type == params.Bool
}

```

`pkg/filter/fields/fields_windows.go`:

```go
/*
 * Copyright 2019-2020 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package fields

import (
	"strings"
	"unicode"

	"github.com/rabbitstack/fibratus/pkg/event/params"
)

// Field represents the type alias for the field
type Field string

const (
	// PsPid represents the process id field
	PsPid Field = "ps.pid"
	// PsPpid represents the parent process id field
	PsPpid Field = "ps.ppid"
	// PsName represents the process name field
	PsName Field = "ps.name"
	// PsComm represents the process command line field. Deprecated.
	PsComm Field = "ps.comm"
	// PsCmdline represents the process command line field
	PsCmdline Field = "ps.cmdline"
	// PsExe represents the process image path field
	PsExe Field = "ps.exe"
	// PsArgs represents the process command line arguments
	PsArgs Field = "ps.args"
	// PsCwd represents the process current working directory
	PsCwd Field = "ps.cwd"
	// PsSID represents the process security identifier
	PsSID Field = "ps.sid"
	// PsDomain represents the process domain field
	PsDomain Field = "ps.domain"
	// PsUsername represents the process username field
	PsUsername Field = "ps.username"
	// PsSessionID represents the session id bound to the process
	PsSessionID Field = "ps.sessionid"
	// PsEnvs represents the process environment variables
	PsEnvs Field = "ps.envs"
	// PsHandleNames represents the process handles
	PsHandleNames Field = "ps.handles"
	// PsHandleTypes represents the process handle types
	PsHandleTypes Field = "ps.handle.types"
	// PsDTB represents the process directory table base address
	PsDTB Field = "ps.dtb"
	// PsModuleNames represents the process module file names
	PsModuleNames Field = "ps.modules"
	// PsParentPid represents the parent process identifier field
	PsParentPid Field = "ps.parent.pid"
	// PsParentName represents the parent process name field
	PsParentName Field = "ps.parent.name"
	// PsParentComm represents the parent process command line field. Deprecated
	PsParentComm Field = "ps.parent.comm"
	// PsParentCmdline represents the parent process command line field
	PsParentCmdline Field = "ps.parent.cmdline"
	// PsParentExe represents the parent process image path field
	PsParentExe Field = "ps.parent.exe"
	// PsParentArgs represents the parent process command line arguments field
	PsParentArgs Field = "ps.parent.args"
	// PsParentCwd represents the parent process current working directory field
	PsParentCwd Field = "ps.parent.cwd"
	// PsParentSID represents the parent process security identifier field
	PsParentSID Field = "ps.parent.sid"
	// PsParentUsername represents the parent process username field
	PsParentUsername Field = "ps.parent.username"
	// PsParentDomain represents the parent process domain field
	PsParentDomain Field = "ps.parent.domain"
	// PsParentSessionID represents the session id field bound to the parent process
	PsParentSessionID Field = "ps.parent.sessionid"
	// PsParentEnvs represents the parent process environment variables field
	PsParentEnvs Field = "ps.parent.envs"
	// PsParentHandles represents the parent process handles field
	PsParentHandles Field = "ps.parent.handles"
	// PsParentHandleTypes represents the parent process handle types field
	PsParentHandleTypes Field = "ps.parent.handle.types"
	// PsParentDTB represents the parent process directory table base address field
	PsParentDTB Field = "ps.parent.dtb"
	// PsAncestor represents the process ancestor field
	PsAncestor Field = "ps.ancestor"
	// PsAccessMask represents the process access rights field
	PsAccessMask Field = "ps.access.mask"
	// PsAccessMaskNames represents the process access rights list field
	PsAccessMaskNames Field = "ps.access.mask.names"
	// PsAccessStatus represents the process access status field
	PsAccessStatus Field = "ps.access.status"
	// PsIsWOW64Field represents the field that indicates if the 32-bit process is created in 64-bit Windows system
	PsIsWOW64Field Field = "ps.is_wow64"
	// PsIsPackagedField represents the field that indicates if a process is packaged with the MSIX technology
	PsIsPackagedField Field = "ps.is_packaged"
	// PsIsProtectedField represents the field that indicates if the process is to be run as a protected process
	PsIsProtectedField Field = "ps.is_protected"
	// PsParentIsWOW64Field represents the field that indicates if the 32-bit process is created in 64-bit Windows system
	PsParentIsWOW64Field Field = "ps.parent.is_wow64"
	// PsParentIsPackagedField represents the field that indicates if a process is packaged with the MSIX technology
	PsParentIsPackagedField Field = "ps.parent.is_packaged"
	// PsParentIsProtectedField represents the field that indicates if the process is to be run as a protected process
	PsParentIsProtectedField Field = "ps.parent.is_protected"
	// PsUUID represents the unique process identifier
	PsUUID Field = "ps.uuid"
	// PsParentUUID represents the unique parent process identifier
	PsParentUUID Field = "ps.parent.uuid"
	// PsTokenIntegrityLevel represents the field that indicates the current process integrity level
	PsTokenIntegrityLevel = "ps.token.integrity_level"
	// PsTokenIsElevated  represents the field that indicates if the current process token is elevated
	PsTokenIsElevated = "ps.token.is_elevated"
	// PsTokenElevationType represents the field that indicates if the current process token elevation type
	PsTokenElevationType = "ps.token.elevation_type"
	// PsParentTokenIntegrityLevel represents the field that indicates the parent process integrity level
	PsParentTokenIntegrityLevel = "ps.parent.token.integrity_level"
	// PsParentTokenIsElevated  represents the field that indicates if the parent process token is elevated
	PsParentTokenIsElevated = "ps.parent.token.is_elevated"
	// PsTokenElevationType represents the field that indicates if the parent process token elevation type
	PsParentTokenElevationType = "ps.parent.token.elevation_type"
	// PsSignatureExists is the field which indicates if the binary is signed, either by embedded or catalog signature
	PsSignatureExists Field = "ps.signature.exists"
	// PsSignatureTrusted is the field which indicates if the binary signature is trusted
	PsSignatureTrusted Field = "ps.signature.trusted"
	// PsSignatureIssuer is the field which indicates the certificate issuer
	PsSignatureIssuer Field = "ps.signature.issuer"
	// PsSignatureSubject is the field which indicates the certificate subject
	PsSignatureSubject Field = "ps.signature.subject"
	// PsSignatureSerial is the field which indicates the certificate serial
	PsSignatureSerial Field = "ps.signature.serial"
	// PsSignatureAfter is the field which indicates the timestamp after certificate is no longer valid
	PsSignatureAfter Field = "ps.signature.after"
	// PsSignatureBefore is the field which indicates the timestamp of the certificate enrollment date
	PsSignatureBefore Field = "ps.signature.before"

	// PsPeNumSections represents the number of sections
	PsPeNumSections Field = "ps.pe.nsections"
	// PsPeNumSymbols represents the number of exported symbols
	PsPeNumSymbols Field = "ps.pe.nsymbols"
	// PsPeSymbols represents imported symbols
	PsPeSymbols Field = "ps.pe.symbols"
	// PeImports represents imported libraries (e.g. kernel32.dll)
	PsPeImports Field = "ps.pe.imports"
	// PeTimestamp is the PE build timestamp
	PsPeTimestamp Field = "ps.pe.timestamp"
	// PeBaseAddress represents the base address when the binary is loaded
	PsPeBaseAddress Field = "ps.pe.address.base"
	// PeEntrypoint is the address of the entrypoint function
	PsPeEntrypoint Field = "ps.pe.address.entrypoint"
	// PeResources represents PE resources
	PsPeResources Field = "ps.pe.resources"
	// PeCompany represents the company name resource
	PsPeCompany Field = "ps.pe.company"
	// PeDescription represents the internal description of the file
	PsPeDescription Field = "ps.pe.description"
	// PeFileVersion represents the internal file version
	PsPeFileVersion Field = "ps.pe.file.version"
	// PeFileName represents the original file name provided at compile-time.
	PsPeFileName Field = "ps.pe.file.name"
	// PeCopyright represents the copyright notice emitted at compile-time
	PsPeCopyright Field = "ps.pe.copyright"
	// PeProduct represents the product name provided at compile-time
	PsPeProduct Field = "ps.pe.product"
	// PeProductVersion represents the internal product version provided at compile-time
	PsPeProductVersion Field = "ps.pe.product.version"
	// PeAnomalies represents the field that contains PE anomalies detected during parsing
	PsPeAnomalies Field = "ps.pe.anomalies"
	// PsPeImphash is the field that yields the PE import hash
	PsPeImphash Field = "ps.pe.imphash"
	// PsPeIsDotnet is the field which indicates if the binary contains the .NET assembly
	PsPeIsDotnet Field = "ps.pe.is_dotnet"
	// PsPeIsModified is the field that indicates whether disk and in-memory PE headers differ
	PsPeIsModified Field = "ps.pe.is_modified"

	// ThreadBasePrio is the base thread priority
	ThreadBasePrio Field = "thread.prio"
	// ThreadIOPrio is the thread I/O priority
	ThreadIOPrio Field = "thread.io.prio"
	// ThreadPagePrio is the thread page priority
	ThreadPagePrio Field = "thread.page.prio"
	// ThreadKstackBase is the thread kernel stack start address
	ThreadKstackBase Field = "thread.kstack.base"
	// ThreadKstackLimit is the thread kernel stack end address
	ThreadKstackLimit Field = "thread.kstack.limit"
	// ThreadUstackBase is the thread user stack start address
	ThreadUstackBase Field = "thread.ustack.base"
	// ThreadUstackLimit is the thead user stack end address
	ThreadUstackLimit Field = "thread.ustack.limit"
	// ThreadEntrypoint is the thread entrypoint address
	ThreadEntrypoint Field = "thread.entrypoint"
	// ThreadStartAddress is the thread start address
	ThreadStartAddress Field = "thread.start_address"
	// ThreadPID is the process identifier where the thread is created
	ThreadPID Field = "thread.pid"
	// ThreadTEB is the thread environment block base address
	ThreadTEB Field = "thread.teb_address"
	// ThreadAccessMask represents the thread access rights field
	ThreadAccessMask Field = "thread.access.mask"
	// ThreadAccessMaskNames represents the thread access rights list field
	ThreadAccessMaskNames Field = "thread.access.mask.names"
	// ThreadAccessStatus represents the thread access status field
	ThreadAccessStatus Field = "thread.access.status"
	// ThreadCallstackSummary represents the thread callstack summary field
	ThreadCallstackSummary Field = "thread.callstack.summary"
	// ThreadCallstackDetail represents the thread callstack detail field
	ThreadCallstackDetail Field = "thread.callstack.detail"
	// ThreadCallstackModules represents the callstack modules field
	ThreadCallstackModules Field = "thread.callstack.modules"
	// ThreadCallstackSymbols represents the callstack symbols field
	ThreadCallstackSymbols Field = "thread.callstack.symbols"
	// ThreadCallstackProtections represents the callstack region protections field
	ThreadCallstackProtections Field = "thread.callstack.protections"
	// ThreadCallstackAllocationSizes represents the private region page sizes field
	ThreadCallstackAllocationSizes Field = "thread.callstack.allocation_sizes"
	// ThreadCallstackCallsiteLeadingAssembly represents the callsite prelude opcodes field
	ThreadCallstackCallsiteLeadingAssembly Field = "thread.callstack.callsite_leading_assembly"
	// ThreadCallstackCallsiteTrailingAssembly represents the callsite postlude opcodes field
	ThreadCallstackCallsiteTrailingAssembly Field = "thread.callstack.callsite_trailing_assembly"
	// ThreadCallstackIsUnbacked represents the field that indicates if there is an unbacked stack frame
	ThreadCallstackIsUnbacked Field = "thread.callstack.is_unbacked"
	// ThreadStartAddressSymbol represents the symbol corresponding to the thread start address
	ThreadStartAddressSymbol Field = "thread.start_address.symbol"
	// ThreadStartAddressModule represents the module corresponding to the thread start address
	ThreadStartAddressModule Field = "thread.start_address.module"
	// ThreadCallstackAddresses represents the all callstack return addresses
	ThreadCallstackAddresses Field = "thread.callstack.addresses"
	// ThreadCallstackFinalUserModuleName represents the final user space stack frame module name
	ThreadCallstackFinalUserModuleName Field = "thread.callstack.final_user_module.name"
	// ThreadCallstackFinalUserModulePath represents the final user space stack frame module path
	ThreadCallstackFinalUserModulePath Field = "thread.callstack.final_user_module.path"
	// ThreadCallstackFinalUserSymbolName represents the final user space stack frame symbol name
	ThreadCallstackFinalUserSymbolName Field = "thread.callstack.final_user_symbol.name"
	// ThreadCallstackFinalKernelModuleName represents the final kernel space stack frame module name
	ThreadCallstackFinalKernelModuleName Field = "thread.callstack.final_kernel_module.name"
	// ThreadCallstackFinalKernelModulePath represents the final kernel space stack frame module name
	ThreadCallstackFinalKernelModulePath Field = "thread.callstack.final_kernel_module.path"
	// ThreadCallstackFinalKernelSymbolName represents the final kernel space stack frame symbol name
	ThreadCallstackFinalKernelSymbolName Field = "thread.callstack.final_kernel_symbol.name"
	// ThreadCallstackFinalUserModuleSignatureExists represents the signature status of the final user space stack frame module
	ThreadCallstackFinalUserModuleSignatureExists Field = "thread.callstack.final_user_module.signature.exists"
	// ThreadCallstackFinalUserModuleSignatureTrusted represents the trust status of the final user space stack frame module signature
	ThreadCallstackFinalUserModuleSignatureTrusted Field = "thread.callstack.final_user_module.signature.trusted"
	// ThreadCallstackFinalUserModuleSignatureIssuer represents the final user space stack frame module certificate issuer
	ThreadCallstackFinalUserModuleSignatureIssuer Field = "thread.callstack.final_user_module.signature.issuer"
	// ThreadCallstackFinalUserModuleSignatureSubject represents the final user space stack frame module certificate subject
	ThreadCallstackFinalUserModuleSignatureSubject Field = "thread.callstack.final_user_module.signature.subject"

	// PeNumSections represents the number of sections
	PeNumSections Field = "pe.nsections"
	// PeNumSymbols represents the number of exported symbols
	PeNumSymbols Field = "pe.nsymbols"
	// PeSymbols represents imported symbols
	PeSymbols Field = "pe.symbols"
	// PeImports represents imported libraries (e.g. kernel32.dll)
	PeImports Field = "pe.imports"
	// PeTimestamp is the PE build timestamp
	PeTimestamp Field = "pe.timestamp"
	// PeBaseAddress represents the base address when the binary is loaded
	PeBaseAddress Field = "pe.address.base"
	// PeEntrypoint is the address of the entrypoint function
	PeEntrypoint Field = "pe.address.entrypoint"
	// PeResources represents PE resources
	PeResources Field = "pe.resources"
	// PeCompany represents the company name resource
	PeCompany Field = "pe.company"
	// PeDescription represents the internal description of the file
	PeDescription Field = "pe.description"
	// PeFileVersion represents the internal file version
	PeFileVersion Field = "pe.file.version"
	// PeFileName represents the original file name provided at compile-time.
	PeFileName Field = "pe.file.name"
	// PeCopyright represents the copyright notice emitted at compile-time
	PeCopyright Field = "pe.copyright"
	// PeProduct represents the product name provided at compile-time
	PeProduct Field = "pe.product"
	// PeProductVersion represents the internal product version provided at compile-time
	PeProductVersion Field = "pe.product.version"
	// PeIsDLL indicates if the file is a DLL
	PeIsDLL Field = "pe.is_dll"
	// PeIsDriver indicates if the file is a driver
	PeIsDriver Field = "pe.is_driver"
	// PeIsExecutable indicates if the file is an executable
	PeIsExecutable Field = "pe.is_exec"
	// PeAnomalies represents the field that contains PE anomalies detected during parsing
	PeAnomalies Field = "pe.anomalies"
	// PeImphash is the field that yields the PE import hash
	PeImphash Field = "pe.imphash"
	// PeIsDotnet is the field which indicates if the binary contains the .NET assembly
	PeIsDotnet Field = "pe.is_dotnet"
	// PeIsSigned is the field which indicates if the binary is signed, either by embedded or catalog signature
	PeIsSigned Field = "pe.is_signed"
	// PeIsTrusted is the field which indicates if the binary signature is trusted
	PeIsTrusted Field = "pe.is_trusted"
	// PeCertIssuer is the field which indicates the certificate issuer
	PeCertIssuer Field = "pe.cert.issuer"
	// PeCertSubject is the field which indicates the certificate subject
	PeCertSubject Field = "pe.cert.subject"
	// PeCertSerial is the field which indicates the certificate serial
	PeCertSerial Field = "pe.cert.serial"
	// PeCertAfter is the field which indicates the timestamp after certificate is no longer valid
	PeCertAfter Field = "pe.cert.after"
	// PeCertBefore is the field which indicates the timestamp of the certificate enrollment date
	PeCertBefore Field = "pe.cert.before"
	// PeIsModified is the field that indicates whether disk and in-memory PE headers differ
	PeIsModified Field = "pe.is_modified"

	// EvtSeq is the event sequence number
	EvtSeq Field = "evt.seq"
	// EvtPID is the process identifier that generated the event
	EvtPID Field = "evt.pid"
	// EvtTID is the thread identifier that generated the event
	EvtTID Field = "evt.tid"
	// EvtCPU is the CPU core where the event was generated
	EvtCPU Field = "evt.cpu"
	// EvtDesc represents the event description
	EvtDesc Field = "evt.desc"
	// EvtHost represents the host where the event was produced
	EvtHost Field = "evt.host"
	// EvtTime is the event time
	EvtTime Field = "evt.time"
	// EvtTimeHour is the hour part of the event time
	EvtTimeHour Field = "evt.time.h"
	// EvtTimeMin is the minute part of the event time
	EvtTimeMin Field = "evt.time.m"
	// EvtTimeSec is the second part of the event time
	EvtTimeSec Field = "evt.time.s"
	// EvtTimeNs is the nanosecond part of the event time
	EvtTimeNs Field = "evt.time.ns"
	// EvtDate is the event date
	EvtDate Field = "evt.date"
	// EvtDateDay is the day of event date
	EvtDateDay Field = "evt.date.d"
	// EvtDateMonth is the month of event date
	EvtDateMonth Field = "evt.date.m"
	// EvtDateYear is the year of event date
	EvtDateYear Field = "evt.date.y"
	// EvtDateTz is the time zone of event timestamp
	EvtDateTz Field = "evt.date.tz"
	// EvtDateWeek is the event week number
	EvtDateWeek Field = "evt.date.week"
	// EvtDateWeekday is the event week day
	EvtDateWeekday Field = "evt.date.weekday"
	// EvtName is the event name
	EvtName Field = "evt.name"
	// EvtCategory is the event category
	EvtCategory Field = "evt.category"
	// EvtNparams is the number of event parameters
	EvtNparams Field = "evt.nparams"
	// EvtArg represents the field sequence for generic argument access
	EvtArg Field = "evt.arg"
	// EvtIsDirectSyscall represents the field that designates if this event is
	// performing a direct syscall.
	EvtIsDirectSyscall Field = "evt.is_direct_syscall"
	// EvtIsIndirectSyscall represents the field that designates if this event is
	// performing an indirect syscall.
	EvtIsIndirectSyscall Field = "evt.is_indirect_syscall"

	// KevtSeq is the event sequence number
	KevtSeq Field = "kevt.seq"
	// KevtPID is the process identifier that generated the event
	KevtPID Field = "kevt.pid"
	// KevtTID is the thread identifier that generated the event
	KevtTID Field = "kevt.tid"
	// KevtCPU is the CPU core where the event was generated
	KevtCPU Field = "kevt.cpu"
	// KevtDesc represents the event description
	KevtDesc Field = "kevt.desc"
	// KevtHost represents the host where the event was produced
	KevtHost Field = "kevt.host"
	// KevtTime is the event time
	KevtTime Field = "kevt.time"
	// KevtTimeHour is the hour part of the event time
	KevtTimeHour Field = "kevt.time.h"
	// KevtTimeMin is the minute part of the event time
	KevtTimeMin Field = "kevt.time.m"
	// KevtTimeSec is the second part of the event time
	KevtTimeSec Field = "kevt.time.s"
	// KevtTimeNs is the nanosecond part of the event time
	KevtTimeNs Field = "kevt.time.ns"
	// KevtDate is the event date
	KevtDate Field = "kevt.date"
	// KevtDateDay is the day of event date
	KevtDateDay Field = "kevt.date.d"
	// KevtDateMonth is the month of event date
	KevtDateMonth Field = "kevt.date.m"
	// KevtDateYear is the year of event date
	KevtDateYear Field = "kevt.date.y"
	// KevtDateTz is the time zone of event timestamp
	KevtDateTz Field = "kevt.date.tz"
	// KevtDateWeek is the event week number
	KevtDateWeek Field = "kevt.date.week"
	// KevtDateWeekday is the event week day
	KevtDateWeekday Field = "kevt.date.weekday"
	// KevtName is the event name
	KevtName Field = "kevt.name"
	// KevtCategory is the event category
	KevtCategory Field = "kevt.category"
	// KevtNparams is the number of event parameters
	KevtNparams Field = "kevt.nparams"
	// KevtArg represents the field sequence for generic argument access
	KevtArg Field = "kevt.arg"

	// HandleID represents the handle identifier within the process address space
	HandleID Field = "handle.id"
	// HandleObject represents the handle object address
	HandleObject Field = "handle.object"
	// HandleName represents the handle name
	HandleName Field = "handle.name"
	// HandleType represents the handle type (e.g. file)
	HandleType Field = "handle.type"

	// NetDIP represents network destination IP address
	NetDIP Field = "net.dip"
	// NetSIP represents the source IP address
	NetSIP Field = "net.sip"
	// NetDport represents the destination port
	NetDport Field = "net.dport"
	// NetSport represents the source port
	NetSport Field = "net.sport"
	// NetDportName represents the destination port IANA name
	NetDportName Field = "net.dport.name"
	// NetSportName represents the source port IANA name
	NetSportName Field = "net.sport.name"
	// NetL4Proto represents the Layer4 protocol name (e.g. TCP)
	NetL4Proto Field = "net.l4.proto"
	// NetPacketSize represents the packet size
	NetPacketSize Field = "net.size"
	// NetSIPNames represents the source IP names
	NetSIPNames Field = "net.sip.names"
	// NetDIPNames represents the destination IP names
	NetDIPNames Field = "net.dip.names"

	// FileObject represents the address of the file object
	FileObject Field = "file.object"
	// FileName represents the file base name (e.g. cmd.exe)
	FileName Field = "file.name"
	// FilePath represents the file full path (e.g. C:\Windows\System32\cmd.exe)
	FilePath Field = "file.path"
	// FilePathStem represents the full file path without extension (e.g. C:\Windows\System32\cmd)
	FilePathStem Field = "file.path.stem"
	// FileExtension represents the file extension (e.g. .exe or .dll)
	FileExtension Field = "file.extension"
	// FileOperation represents the file operation (e.g. create)
	FileOperation Field = "file.operation"
	// FileShareMask represents the file share mask
	FileShareMask Field = "file.share.mask"
	// FileIOSize represents the number of read/written bytes
	FileIOSize Field = "file.io.size"
	// FileOffset represents the read/write offset
	FileOffset Field = "file.offset"
	// FileType represents the file type
	FileType Field = "file.type"
	// FileAttributes represents a slice of file attributes
	FileAttributes Field = "file.attributes"
	// FileStatus represents the status message of the file operation
	FileStatus Field = "file.status"
	// FileViewBase represents the base address of the mapped view
	FileViewBase Field = "file.view.base"
	// FileViewSize represents the size of the mapped view
	FileViewSize Field = "file.view.size"
	// FileViewType represents the type of the mapped view section
	FileViewType Field = "file.view.type"
	// FileViewProtection represents the protection attributes of the section view
	FileViewProtection Field = "file.view.protection"
	// FileIsDriverVulnerable represents the field that denotes whether the created file is a vulnerable driver
	FileIsDriverVulnerable Field = "file.is_driver_vulnerable"
	// FileIsDriverMalicious represents the field that denotes whether the created file is a malicious driver
	FileIsDriverMalicious Field = "file.is_driver_malicious"
	// FileIsDLL indicates if the created file is a DLL
	FileIsDLL Field = "file.is_dll"
	// FileIsDriver indicates if the created file is a driver
	FileIsDriver Field = "file.is_driver"
	// FileIsExecutable indicates if the created file is an executable
	FileIsExecutable Field = "file.is_exec"
	// FilePID represents the field that denotes the process id performing file operations
	FilePID Field = "file.pid"
	// FileKey represents the field that uniquely identifies the file object.
	FileKey Field = "file.key"
	// FileInfoClass represents the field that identifies the file information class
	FileInfoClass Field = "file.info_class"
	// FileInfoAllocationSize represents the field that contains the file allocation size
	FileInfoAllocationSize Field = "file.info.allocation_size"
	// FileInfoEOFSize represents the field that contains the EOF size
	FileInfoEOFSize Field = "file.info.eof_size"
	// FileInfoIsDispositionDeleteFile represents the field that indicates if the file is deleted when its handle is closed
	FileInfoIsDispositionDeleteFile Field = "file.info.is_disposition_delete_file"

	// RegistryPath represents the full registry path
	RegistryPath Field = "registry.path"
	// RegistryKeyName represents the registry key name
	RegistryKeyName Field = "registry.key.name"
	// RegistryKeyHandle represents the registry KCB address
	RegistryKeyHandle Field = "registry.key.handle"
	// RegistryValue represents the registry value name field
	RegistryValue Field = "registry.value"
	// RegistryValueType represents the registry value type field
	RegistryValueType Field = "registry.value.type"
	// RegistryData represents the captured registry data field
	RegistryData Field = "registry.data"
	// RegistryStatus represent the registry operation status
	RegistryStatus Field = "registry.status"

	// ImageBase is the module base address
	ImageBase Field = "image.base.address"
	// ImageSize is the module size
	ImageSize Field = "image.size"
	// ImageChecksum represents the module checksum hash
	ImageChecksum Field = "image.checksum"
	// ImageDefaultAddress represents the module address
	ImageDefaultAddress Field = "image.default.address"
	// ImagePath is the module full path
	ImagePath Field = "image.path"
	// ImageName is the module name
	ImageName Field = "image.name"
	// ImagePID is the pid of the process where the image was loaded
	ImagePID Field = "image.pid"
	// ImageSignatureType represents the image signature type
	ImageSignatureType Field = "image.signature.type"
	// ImageSignatureLevel represents the image signature level
	ImageSignatureLevel Field = "image.signature.level"
	// ImageCertSubject is the field that indicates the subject of the certificate is the entity its public key is associated with.
	ImageCertSubject = "image.cert.subject"
	// ImageCertIssuer is the field that represents the certificate authority (CA).
	ImageCertIssuer = "image.cert.issuer"
	// ImageCertSerial is the field that represents the serial number MUST be a positive integer assigned
	// by the CA to each certificate.
	ImageCertSerial = "image.cert.serial"
	// ImageCertBefore is the field that specifies the certificate won't be valid before this timestamp.
	ImageCertBefore = "image.cert.before"
	// ImageCertAfter is the field that specifies the certificate won't be valid after this timestamp.
	ImageCertAfter = "image.cert.after"
	// ImageIsDriverVulnerable represents the field that denotes whether loaded driver is vulnerable
	ImageIsDriverVulnerable Field = "image.is_driver_vulnerable"
	// ImageIsDriverMalicious represents the field that denotes whether the loaded driver is malicious
	ImageIsDriverMalicious Field = "image.is_driver_malicious"
	// ImageIsDLL indicates if the loaded image is a DLL
	ImageIsDLL Field = "image.is_dll"
	// ImageIsDriver indicates if the loaded image is a driver
	ImageIsDriver Field = "image.is_driver"
	// ImageIsExecutable indicates if the loaded image is an executable
	ImageIsExecutable Field = "image.is_exec"
	// ImageIsDotnet indicates if the loaded image is a .NET assembly
	ImageIsDotnet Field = "image.is_dotnet"

	// DllBase is the DLL base address
	DllBase Field = "dll.base"
	// DllSize is the DLL virtual mapped space size
	DllSize Field = "dll.size"
	// DllPath is the DLL full path
	DllPath Field = "dll.path"
	// DllPath is the DLL path stem field
	DllPathStem Field = "dll.path.stem"
	// DllName is the DLL name
	DllName Field = "dll.name"
	// DllPID is the pid of the process where the DLL was loaded
	DllPID Field = "dll.pid"
	// DllSignatureType represents the DLL signature type
	DllSignatureType Field = "dll.signature.type"
	// DllSignatureLevel represents the DLL signature level
	DllSignatureLevel Field = "dll.signature.level"
	// DllSignatureExists is the field that determines if the DLL signature exists
	DllSignatureExists Field = "dll.signature.exists"
	// DllSignatureTrusted is the filed that determines if the DLL signature is trusted
	DllSignatureTrusted Field = "dll.signature.trusted"
	// DllSignatureSubject is the field that indicates the subject of the certificate is the entity its public key is associated with.
	DllSignatureSubject = "dll.signature.subject"
	// DllSignatureIssuer is the field that represents the certificate authority (CA).
	DllSignatureIssuer = "dll.signature.issuer"
	// DllSignatureSerial is the field that represents the serial number MUST be a positive integer assigned
	// by the CA to each certificate.
	DllSignatureSerial = "dll.signature.serial"
	// DllSignatureBefore is the field that specifies the certificate won't be valid before this timestamp.
	DllSignatureBefore = "dll.signature.before"
	// DllSignatureAfter is the field that specifies the certificate won't be valid after this timestamp.
	DllSignatureAfter = "dll.signature.after"
	// DllIsDotnet indicates if the DLL is a .NET assembly.
	DllIsDotnet Field = "dll.pe.is_dotnet"

	// ModuleBase is the module base address
	ModuleBase Field = "module.base"
	// ModuleSize is the module size
	ModuleSize Field = "module.size"
	// ModuleChecksum represents the module checksum hash
	ModuleChecksum Field = "module.checksum"
	// ModuleDefaultAddress represents the module address
	ModuleDefaultAddress Field = "module.default_address"
	// ModulePath is the module full path
	ModulePath Field = "module.path"
	// ModulePathStem is the module path stem field
	ModulePathStem Field = "module.path.stem"
	// ModuleName is the module name
	ModuleName Field = "module.name"
	// ModulePID is the pid of the process where the module was loaded
	ModulePID Field = "module.pid"
	// ModuleSignatureType represents the module signature type
	ModuleSignatureType Field = "module.signature.type"
	// ModuleSignatureLevel represents the module signature level
	ModuleSignatureLevel Field = "module.signature.level"
	// ModuleSignatureExists is the field that determines if the module signature exists
	ModuleSignatureExists Field = "module.signature.exists"
	// ModuleSignatureTrusted is the filed that determines if the module signature is trusted
	ModuleSignatureTrusted Field = "module.signature.trusted"
	// ModuleSignatureSubject is the field that indicates the subject of the certificate is the entity its public key is associated with.
	ModuleSignatureSubject = "module.signature.subject"
	// ModuleSignatureIssuer is the field that represents the certificate authority (CA).
	ModuleSignatureIssuer = "module.signature.issuer"
	// ModuleSignatureSerial is the field that represents the serial number MUST be a positive integer assigned
	// by the CA to each certificate.
	ModuleSignatureSerial = "module.signature.serial"
	// ModuleSignatureBefore is the field that specifies the certificate won't be valid before this timestamp.
	ModuleSignatureBefore = "module.signature.before"
	// ModuleSignatureAfter is the field that specifies the certificate won't be valid after this timestamp.
	ModuleSignatureAfter = "module.signature.after"
	// ModuleIsDriverVulnerable represents the field that denotes whether loaded driver is vulnerable
	ModuleIsDriverVulnerable Field = "module.is_driver_vulnerable"
	// ModuleIsDriverMalicious represents the field that denotes whether the loaded driver is malicious
	ModuleIsDriverMalicious Field = "module.is_driver_malicious"
	// ModuleIsDLL indicates if the loaded module is a DLL
	ModuleIsDLL Field = "module.is_dll"
	// ModuleIsDriver indicates if the loaded module is a driver
	ModuleIsDriver Field = "module.is_driver"
	// ModuleIsExecutable indicates if the loaded module is an executable
	ModuleIsExecutable Field = "module.is_exec"
	// ModuleIsDotnet indicates if the loaded module is a .NET assembly
	ModuleIsDotnet Field = "module.pe.is_dotnet"

	// MemBaseAddress identifies the field that denotes the allocation base address
	MemBaseAddress Field = "mem.address"
	// MemRegionSize Field identifies the field that represents the allocated region size
	MemRegionSize Field = "mem.size"
	// MemAllocType identifies the field that represents region allocation type
	MemAllocType Field = "mem.alloc"
	// MemPageType identifies the parameter that represents the allocated region type
	MemPageType Field = "mem.type"
	// MemProtection identifies the field that represents the memory protection for the range of pages
	MemProtection Field = "mem.protection"
	// MemProtectionMask identifies the field that represents the memory protection in mask notation
	MemProtectionMask Field = "mem.protection.mask"

	// DNSName identifies the field that represents the DNS name
	DNSName Field = "dns.name"
	// DNSRR identifies the field that represents the DNS record type
	DNSRR Field = "dns.rr"
	// DNSOptions identifies the field that represents the DNS options
	DNSOptions Field = "dns.options"
	// DNSAnswers identifies the field that represents the DNS answers
	DNSAnswers Field = "dns.answers"
	// DNSRcode identifies the field that represents the DNS response code
	DNSRcode Field = "dns.rcode"

	// ThreadpoolPoolID identifies the field that represents the thread pool identifier
	ThreadpoolPoolID = "threadpool.id"
	// ThreadpoolTaskID identifies the field that represents the thread pool task identifier
	ThreadpoolTaskID = "threadpool.task.id"
	// ThreadpoolCallbackAddress identifies the field that represents the address of the callback function
	ThreadpoolCallbackAddress = "threadpool.callback.address"
	// ThreadpoolCallbackSymbol identifies the field that represents the callback symbol
	ThreadpoolCallbackSymbol = "threadpool.callback.symbol"
	// ThreadpoolCallbackModule identifies the field that represents the module containing the callback symbol
	ThreadpoolCallbackModule = "threadpool.callback.module"
	// ThreadpoolCallbackContext identifies the field that represents the address of the callback context
	ThreadpoolCallbackContext = "threadpool.callback.context"
	// ThreadpoolCallbackContextRip identifies the field that represents the value of instruction pointer contained in the callback context
	ThreadpoolCallbackContextRip = "threadpool.callback.context.rip"
	// ThreadpoolCallbackContextRipSymbol identifies the field that represents the symbol name associated with the instruction pointer in callback context
	ThreadpoolCallbackContextRipSymbol = "threadpool.callback.context.rip.symbol"
	// ThreadpoolCallbackContextRipModule identifies the field that represents the module name associated with the instruction pointer in callback context
	ThreadpoolCallbackContextRipModule = "threadpool.callback.context.rip.module"
	// ThreadpoolSubprocessTag identifies the field that represents the service identifier associated with the thread pool
	ThreadpoolSubprocessTag = "threadpool.subprocess_tag"
	// ThreadpoolTimerDuetime identifies the field that represents the timer due time
	ThreadpoolTimerDuetime = "threadpool.timer.duetime"
	// ThreadpoolTimerSubqueue identifies the field that represents the memory address of the timer subqueue
	ThreadpoolTimerSubqueue = "threadpool.timer.subqueue"
	// ThreadpoolTimer identifies the field that represents the memory address of the timer object
	ThreadpoolTimer = "threadpool.timer.address"
	// ThreadpoolTimerPeriod identifies the field that represents the period of the timer
	ThreadpoolTimerPeriod = "threadpool.timer.period"
	// ThreadpoolTimerWindow identifies the field that represents the timer tolerate period
	ThreadpoolTimerWindow = "threadpool.timer.window"
	// ThreadpoolTimerAbsolute identifies the field that indicates if the timer is absolute or relative
	ThreadpoolTimerAbsolute = "threadpool.timer.is_absolute"
)

// String casts the field type to string.
func (f Field) String() string { return string(f) }

// Type returns the data type that this field contains.
func (f Field) Type() params.Type { return fields[f].Type }

func (f Field) IsPsField() bool       { return strings.HasPrefix(string(f), "ps.") }
func (f Field) IsKevtField() bool     { return strings.HasPrefix(string(f), "kevt.") }
func (f Field) IsEvtField() bool      { return strings.HasPrefix(string(f), "evt.") }
func (f Field) IsThreadField() bool   { return strings.HasPrefix(string(f), "thread.") }
func (f Field) IsImageField() bool    { return strings.HasPrefix(string(f), "image.") }
func (f Field) IsFileField() bool     { return strings.HasPrefix(string(f), "file.") }
func (f Field) IsRegistryField() bool { return strings.HasPrefix(string(f), "registry.") }
func (f Field) IsNetworkField() bool  { return strings.HasPrefix(string(f), "net.") }
func (f Field) IsHandleField() bool   { return strings.HasPrefix(string(f), "handle.") }
func (f Field) IsPeField() bool {
	return strings.HasPrefix(string(f), "pe.") || strings.HasPrefix(string(f), "ps.pe.") || strings.HasPrefix(string(f), "ps.signature.")
}
func (f Field) IsModuleField() bool {
	return strings.HasPrefix(string(f), "module.") || strings.HasPrefix(string(f), "dll.")
}
func (f Field) IsMemField() bool        { return strings.HasPrefix(string(f), "mem.") }
func (f Field) IsDNSField() bool        { return strings.HasPrefix(string(f), "dns.") }
func (f Field) IsThreadpoolField() bool { return strings.HasPrefix(string(f), "threadpool.") }

func (f Field) IsPeSection() bool { return f == PeNumSections || f == PsPeNumSections }
func (f Field) IsPeSymbol() bool {
	return f == PeSymbols || f == PeNumSymbols || f == PeImports || f == PsPeSymbols || f == PsPeNumSymbols || f == PsPeImports
}
func (f Field) IsPeVersionResource() bool {
	return f == PeCompany || f == PeCopyright || f == PeDescription || f == PeFileName || f == PeFileVersion || f == PeProduct || f == PeProductVersion ||
		f == PsPeCompany || f == PsPeCopyright || f == PsPeDescription || f == PsPeFileName || f == PsPeFileVersion || f == PsPeProduct || f == PsPeProductVersion
}
func (f Field) IsPeVersionResources() bool { return f == PeResources || f == PsPeResources }
func (f Field) IsPeImphash() bool          { return f == PeImphash || f == PsPeImphash }
func (f Field) IsPeDotnet() bool           { return f == PeIsDotnet || f == PsPeIsDotnet }
func (f Field) IsPeAnomalies() bool        { return f == PeAnomalies || f == PsPeAnomalies }
func (f Field) IsPeSignature() bool {
	return f == PeIsTrusted || f == PeIsSigned || f == PeCertIssuer || f == PeCertSerial || f == PeCertSubject || f == PeCertBefore || f == PeCertAfter || strings.HasPrefix(string(f), "ps.signature.")
}
func (f Field) IsPeIsTrusted() bool { return f == PeIsTrusted || f == PsSignatureTrusted }
func (f Field) IsPeIsSigned() bool  { return f == PeIsSigned || f == PsSignatureExists }

func (f Field) IsPeCert() bool {
	return strings.HasPrefix(string(f), "pe.cert.") || f == PsSignatureIssuer || f == PsSignatureSubject || f == PsSignatureSerial || f == PsSignatureAfter || f == PsSignatureBefore
}
func (f Field) IsImageCert() bool { return strings.HasPrefix(string(f), "image.cert.") }
func (f Field) IsModuleCert() bool {
	return f == ModuleSignatureSubject || f == ModuleSignatureIssuer || f == ModuleSignatureSerial || f == ModuleSignatureAfter || f == ModuleSignatureBefore ||
		f == DllSignatureSubject || f == DllSignatureIssuer || f == DllSignatureSerial || f == DllSignatureAfter || f == DllSignatureBefore
}
func (f Field) IsModuleSignature() bool {
	return strings.HasPrefix(string(f), "module.signature.") || strings.HasPrefix(string(f), "dll.signature.")
}

func (f Field) IsPeModified() bool { return f == PeIsModified || f == PsPeIsModified }

// Segment represents the type alias for the segment. Segment
// denotes the property anchored to the bound field reference.
// Let's look through an example. $module.name is the literal
// composed of bound field ($module) and the segment (name).
// Segments are most commonly used in the context of bound
// variables in foreach function.
type Segment string

const (
	PathSegment     Segment = "path"
	NameSegment     Segment = "name"
	TypeSegment     Segment = "type"
	SizeSegment     Segment = "size"
	ChecksumSegment Segment = "checksum"
	AddressSegment  Segment = "address"
	OffsetSegment   Segment = "offset"
	EntropySegment  Segment = "entropy"
	MD5Segment      Segment = "md5"

	PIDSegment                 Segment = "pid"
	CmdlineSegment             Segment = "cmdline"
	ExeSegment                 Segment = "exe"
	ArgsSegment                Segment = "args"
	CwdSegment                 Segment = "cwd"
	SIDSegment                 Segment = "sid"
	SessionIDSegment           Segment = "sessionid"
	UsernameSegment            Segment = "username"
	DomainSegment              Segment = "domain"
	TokenIntegrityLevelSegment Segment = "token.integrity_level"
	TokenIsElevatedSegment     Segment = "token.is_elevated"
	TokenElevationTypeSegment  Segment = "token.elevation_type"

	TidSegment              Segment = "tid"
	StartAddressSegment     Segment = "start_address"
	UserStackBaseSegment    Segment = "user_stack_base"
	UserStackLimitSegment   Segment = "user_stack_limit"
	KernelStackBaseSegment  Segment = "kernel_stack_base"
	KernelStackLimitSegment Segment = "kernel_stack_limit"

	SymbolSegment                   Segment = "symbol"
	ModuleSegment                   Segment = "module"
	AllocationSizeSegment           Segment = "allocation_size"
	ProtectionSegment               Segment = "protection"
	IsUnbackedSegment               Segment = "is_unbacked"
	CallsiteLeadingAssemblySegment  Segment = "callsite_leading_assembly"
	CallsiteTrailingAssemblySegment Segment = "callsite_trailing_assembly"

	ModuleSignatureExistsSegment  Segment = "module.signature.exists"
	ModuleSignatureTrustedSegment Segment = "module.signature.trusted"
	ModuleSignatureIssuerSegment  Segment = "module.signature.issuer"
	ModuleSignatureSubjectSegment Segment = "module.signature.subject"
)

var segments = map[Segment]bool{
	NameSegment:                     true,
	PathSegment:                     true,
	TypeSegment:                     true,
	EntropySegment:                  true,
	SizeSegment:                     true,
	MD5Segment:                      true,
	AddressSegment:                  true,
	ChecksumSegment:                 true,
	PIDSegment:                      true,
	CmdlineSegment:                  true,
	ExeSegment:                      true,
	ArgsSegment:                     true,
	CwdSegment:                      true,
	SIDSegment:                      true,
	SessionIDSegment:                true,
	UsernameSegment:                 true,
	DomainSegment:                   true,
	TokenIntegrityLevelSegment:      true,
	TokenIsElevatedSegment:          true,
	TokenElevationTypeSegment:       true,
	TidSegment:                      true,
	StartAddressSegment:             true,
	UserStackBaseSegment:            true,
	UserStackLimitSegment:           true,
	KernelStackBaseSegment:          true,
	KernelStackLimitSegment:         true,
	OffsetSegment:                   true,
	SymbolSegment:                   true,
	ModuleSegment:                   true,
	AllocationSizeSegment:           true,
	ProtectionSegment:               true,
	IsUnbackedSegment:               true,
	CallsiteLeadingAssemblySegment:  true,
	CallsiteTrailingAssemblySegment: true,
	ModuleSignatureExistsSegment:    true,
	ModuleSignatureTrustedSegment:   true,
	ModuleSignatureIssuerSegment:    true,
	ModuleSignatureSubjectSegment:   true,
}

var allowedSegments = map[Field][]Segment{
	PsAncestors:     {NameSegment, PIDSegment, CmdlineSegment, ExeSegment, ArgsSegment, CwdSegment, SIDSegment, SessionIDSegment, UsernameSegment, DomainSegment, TokenIntegrityLevelSegment, TokenIsElevatedSegment, TokenElevationTypeSegment},
	PsThreads:       {TidSegment, StartAddressSegment, UserStackBaseSegment, UserStackLimitSegment, KernelStackBaseSegment, KernelStackLimitSegment},
	PsModules:       {PathSegment, NameSegment, AddressSegment, SizeSegment, ChecksumSegment},
	PsMmaps:         {AddressSegment, TypeSegment, SizeSegment, ProtectionSegment, PathSegment},
	PeSections:      {NameSegment, SizeSegment, EntropySegment, MD5Segment},
	PsPeSections:    {NameSegment, SizeSegment, EntropySegment, MD5Segment},
	ThreadCallstack: {AddressSegment, OffsetSegment, SymbolSegment, ModuleSegment, AllocationSizeSegment, ProtectionSegment, IsUnbackedSegment, CallsiteLeadingAssemblySegment, CallsiteTrailingAssemblySegment, ModuleSignatureExistsSegment, ModuleSignatureTrustedSegment, ModuleSignatureIssuerSegment, ModuleSignatureSubjectSegment},
}

func (s Segment) IsEntropy() bool { return s == EntropySegment }

// IsSegmentAllowed determines if the segment is valid for the pseudo field.
func IsSegmentAllowed(f Field, s Segment) bool {
	segs := allowedSegments[f]
	if len(segs) == 0 {
		return false
	}

	for _, seg := range segs {
		if seg == s {
			return true
		}
	}

	return false
}

// SegmentsHint returns the sequence of available segments for the pseudo field.
func SegmentsHint(f Field) string {
	segs := allowedSegments[f]
	if len(segs) == 0 {
		return ""
	}

	s := make([]string, len(segs))
	for i, seg := range segs {
		s[i] = string(seg)
	}

	return strings.Join(s, ", ")
}

// IsSegment indicates if the given string is recognized as a known segment.
func IsSegment(s string) bool {
	return segments[Segment(s)]
}

// Pseudo fields provide access to the process/event internal state. They
// are typically used in conjunction with the foreach function as its
// first argument.

var (
	PsModules       Field = "ps._modules"
	PsThreads       Field = "ps._threads"
	PsMmaps         Field = "ps._mmaps"
	PsAncestors     Field = "ps._ancestors"
	PsPeSections    Field = "ps.pe._sections"
	ThreadCallstack Field = "thread._callstack"
	PeSections      Field = "pe._sections"
)

func IsPseudoField(f Field) bool {
	return f == PsAncestors || f == PsModules || f == PsThreads || f == PsMmaps || f == ThreadCallstack || f == PeSections || f == PsPeSections
}

func (f Field) IsPeSectionsPseudo() bool { return f == PeSections || f == PsPeSections }

var fields = map[Field]FieldInfo{
	EvtSeq:         {EvtSeq, "event sequence number", params.Uint64, []string{"evt.seq > 666"}, nil, nil},
	EvtPID:         {EvtPID, "process identifier generating the event", params.Uint32, []string{"evt.pid = 6"}, nil, nil},
	EvtTID:         {EvtTID, "thread identifier generating the event", params.Uint32, []string{"evt.tid = 1024"}, nil, nil},
	EvtCPU:         {EvtCPU, "logical processor core where the event was generated", params.Uint8, []string{"evt.cpu = 2"}, nil, nil},
	EvtName:        {EvtName, "symbolical event name", params.AnsiString, []string{"evt.name = 'CreateThread'"}, nil, nil},
	EvtCategory:    {EvtCategory, "event category", params.AnsiString, []string{"evt.category = 'registry'"}, nil, nil},
	EvtDesc:        {EvtDesc, "event description", params.AnsiString, []string{"evt.desc contains 'Creates a new process'"}, nil, nil},
	EvtHost:        {EvtHost, "host name on which the event was produced", params.UnicodeString, []string{"evt.host contains 'kitty'"}, nil, nil},
	EvtTime:        {EvtTime, "event timestamp as a time string", params.Time, []string{"evt.time = '17:05:32'"}, nil, nil},
	EvtTimeHour:    {EvtTimeHour, "hour within the day on which the event occurred", params.Time, []string{"evt.time.h = 23"}, nil, nil},
	EvtTimeMin:     {EvtTimeMin, "minute offset within the hour on which the event occurred", params.Time, []string{"evt.time.m = 54"}, nil, nil},
	EvtTimeSec:     {EvtTimeSec, "second offset within the minute  on which the event occurred", params.Time, []string{"evt.time.s = 0"}, nil, nil},
	EvtTimeNs:      {EvtTimeNs, "nanoseconds specified by event timestamp", params.Int64, []string{"evt.time.ns > 1591191629102337000"}, nil, nil},
	EvtDate:        {EvtDate, "event timestamp as a date string", params.Time, []string{"evt.date = '2018-03-03'"}, nil, nil},
	EvtDateDay:     {EvtDateDay, "day of the month on which the event occurred", params.Time, []string{"evt.date.d = 12"}, nil, nil},
	EvtDateMonth:   {EvtDateMonth, "month of the year on which the event occurred", params.Time, []string{"evt.date.m = 11"}, nil, nil},
	EvtDateYear:    {EvtDateYear, "year on which the event occurred", params.Uint32, []string{"evt.date.y = 2020"}, nil, nil},
	EvtDateTz:      {EvtDateTz, "time zone associated with the event timestamp", params.AnsiString, []string{"evt.date.tz = 'UTC'"}, nil, nil},
	EvtDateWeek:    {EvtDateWeek, "week number within the year on which the event occurred", params.Uint8, []string{"evt.date.week = 2"}, nil, nil},
	EvtDateWeekday: {EvtDateWeekday, "week day on which the event occurred", params.AnsiString, []string{"evt.date.weekday = 'Monday'"}, nil, nil},
	EvtNparams:     {EvtNparams, "number of parameters", params.Int8, []string{"evt.nparams > 2"}, nil, nil},
	EvtArg: {EvtArg, "event parameter", params.Object, []string{"evt.arg[cmdline] istartswith 'C:\\Windows'"}, nil, &Argument{Optional: false, Pattern: "[a-z0-9_]+", ValidationFunc: func(s string) bool {
		for _, c := range s {
			switch {
			case unicode.IsLower(c):
			case unicode.IsNumber(c):
			case c == '_':
			default:
				return false
			}
		}
		return true
	}}},
	EvtIsDirectSyscall:   {EvtIsDirectSyscall, "indicates if the event is performing a direct syscall", params.Bool, []string{"evt.is_direct_syscall = true"}, nil, nil},
	EvtIsIndirectSyscall: {EvtIsIndirectSyscall, "indicates if the event is performing an indirect syscall", params.Bool, []string{"evt.is_indirect_syscall = true"}, nil, nil},

	KevtSeq:         {KevtSeq, "event sequence number", params.Uint64, []string{"kevt.seq > 666"}, &Deprecation{Since: "3.0.0", Fields: []Field{EvtSeq}}, nil},
	KevtPID:         {KevtPID, "process identifier generating the event", params.Uint32, []string{"kevt.pid = 6"}, &Deprecation{Since: "3.0.0", Fields: []Field{EvtPID}}, nil},
	KevtTID:         {KevtTID, "thread identifier generating the event", params.Uint32, []string{"kevt.tid = 1024"}, &Deprecation{Since: "3.0.0", Fields: []Field{EvtTID}}, nil},
	KevtCPU:         {KevtCPU, "logical processor core where the event was generated", params.Uint8, []string{"kevt.cpu = 2"}, &Deprecation{Since: "3.0.0", Fields: []Field{EvtCPU}}, nil},
	KevtName:        {KevtName, "symbolical event name", params.AnsiString, []string{"kevt.name = 'CreateThread'"}, &Deprecation{Since: "3.0.0", Fields: []Field{EvtName}}, nil},
	KevtCategory:    {KevtCategory, "event category", params.AnsiString, []string{"kevt.category = 'registry'"}, &Deprecation{Since: "3.0.0", Fields: []Field{EvtCategory}}, nil},
	KevtDesc:        {KevtDesc, "event description", params.AnsiString, []string{"kevt.desc contains 'Creates a new process'"}, &Deprecation{Since: "3.0.0", Fields: []Field{EvtDesc}}, nil},
	KevtHost:        {KevtHost, "host name on which the event was produced", params.UnicodeString, []string{"kevt.host contains 'kitty'"}, &Deprecation{Since: "3.0.0", Fields: []Field{EvtHost}}, nil},
	KevtTime:        {KevtTime, "event timestamp as a time string", params.Time, []string{"kevt.time = '17:05:32'"}, &Deprecation{Since: "3.0.0", Fields: []Field{EvtTime}}, nil},
	KevtTimeHour:    {KevtTimeHour, "hour within the day on which the event occurred", params.Time, []string{"kevt.time.h = 23"}, &Deprecation{Since: "3.0.0", Fields: []Field{EvtTimeHour}}, nil},
	KevtTimeMin:     {KevtTimeMin, "minute offset within the hour on which the event occurred", params.Time, []string{"kevt.time.m = 54"}, &Deprecation{Since: "3.0.0", Fields: []Field{EvtTimeMin}}, nil},
	KevtTimeSec:     {KevtTimeSec, "second offset within the minute  on which the event occurred", params.Time, []string{"kevt.time.s = 0"}, &Deprecation{Since: "3.0.0", Fields: []Field{EvtTimeSec}}, nil},
	KevtTimeNs:      {KevtTimeNs, "nanoseconds specified by event timestamp", params.Int64, []string{"kevt.time.ns > 1591191629102337000"}, &Deprecation{Since: "3.0.0", Fields: []Field{EvtTimeNs}}, nil},
	KevtDate:        {KevtDate, "event timestamp as a date string", params.Time, []string{"kevt.date = '2018-03-03'"}, &Deprecation{Since: "3.0.0", Fields: []Field{EvtDate}}, nil},
	KevtDateDay:     {KevtDateDay, "day of the month on which the event occurred", params.Time, []string{"kevt.date.d = 12"}, &Deprecation{Since: "3.0.0", Fields: []Field{EvtDateDay}}, nil},
	KevtDateMonth:   {KevtDateMonth, "month of the year on which the event occurred", params.Time, []string{"kevt.date.m = 11"}, &Deprecation{Since: "3.0.0", Fields: []Field{EvtDateMonth}}, nil},
	KevtDateYear:    {KevtDateYear, "year on which the event occurred", params.Uint32, []string{"kevt.date.y = 2020"}, &Deprecation{Since: "3.0.0", Fields: []Field{EvtDateYear}}, nil},
	KevtDateTz:      {KevtDateTz, "time zone associated with the event timestamp", params.AnsiString, []string{"kevt.date.tz = 'UTC'"}, &Deprecation{Since: "3.0.0", Fields: []Field{EvtDateTz}}, nil},
	KevtDateWeek:    {KevtDateWeek, "week number within the year on which the event occurred", params.Uint8, []string{"kevt.date.week = 2"}, &Deprecation{Since: "3.0.0", Fields: []Field{EvtDateWeek}}, nil},
	KevtDateWeekday: {KevtDateWeekday, "week day on which the event occurred", params.AnsiString, []string{"kevt.date.weekday = 'Monday'"}, &Deprecation{Since: "3.0.0", Fields: []Field{EvtDateWeekday}}, nil},
	KevtNparams:     {KevtNparams, "number of parameters", params.Int8, []string{"kevt.nparams > 2"}, &Deprecation{Since: "3.0.0", Fields: []Field{EvtNparams}}, nil},
	KevtArg: {KevtArg, "event parameter", params.Object, []string{"kevt.arg[cmdline] istartswith 'C:\\Windows'"}, &Deprecation{Since: "3.0.0", Fields: []Field{EvtArg}}, &Argument{Optional: false, Pattern: "[a-z0-9_]+", ValidationFunc: func(s string) bool {
		for _, c := range s {
			switch {
			case unicode.IsLower(c):
			case unicode.IsNumber(c):
			case c == '_':
			default:
				return false
			}
		}
		return true
	}}},

	PsPid:                       {PsPid, "process identifier", params.PID, []string{"ps.pid = 1024"}, nil, nil},
	PsPpid:                      {PsPpid, "parent process identifier", params.PID, []string{"ps.ppid = 45"}, nil, nil},
	PsName:                      {PsName, "process image name including the file extension", params.UnicodeString, []string{"ps.name contains 'firefox'"}, nil, nil},
	PsComm:                      {PsComm, "process command line", params.UnicodeString, []string{"ps.comm contains 'java'"}, &Deprecation{Since: "1.10.0", Fields: []Field{PsCmdline}}, nil},
	PsCmdline:                   {PsCmdline, "process command line", params.UnicodeString, []string{"ps.cmdline contains 'java'"}, nil, nil},
	PsExe:                       {PsExe, "full name of the process' executable", params.UnicodeString, []string{"ps.exe = 'C:\\Windows\\system32\\cmd.exe'"}, nil, nil},
	PsArgs:                      {PsArgs, "process command line arguments", params.Slice, []string{"ps.args in ('/cdir', '/-C')"}, nil, nil},
	PsCwd:                       {PsCwd, "process current working directory", params.UnicodeString, []string{"ps.cwd = 'C:\\Users\\Default'"}, nil, nil},
	PsSID:                       {PsSID, "security identifier under which this process is run", params.UnicodeString, []string{"ps.sid contains 'SYSTEM'"}, nil, nil},
	PsSessionID:                 {PsSessionID, "unique identifier for the current session", params.Int16, []string{"ps.sessionid = 1"}, nil, nil},
	PsDomain:                    {PsDomain, "process domain", params.UnicodeString, []string{"ps.domain contains 'SERVICE'"}, nil, nil},
	PsUsername:                  {PsUsername, "process username", params.UnicodeString, []string{"ps.username contains 'system'"}, nil, nil},
	PsEnvs:                      {PsEnvs, "process environment variables", params.Slice, []string{"ps.envs in ('SystemRoot:C:\\WINDOWS')", "ps.envs[windir] = 'C:\\WINDOWS'"}, nil, &Argument{Optional: true, ValidationFunc: func(arg string) bool { return true }}},
	PsHandleNames:               {PsHandleNames, "allocated process handle names", params.Slice, []string{"ps.handles in ('\\BaseNamedObjects\\__ComCatalogCache__')"}, nil, nil},
	PsHandleTypes:               {PsHandleTypes, "allocated process handle types", params.Slice, []string{"ps.handle.types in ('Key', 'Mutant', 'Section')"}, nil, nil},
	PsDTB:                       {PsDTB, "process directory table base address", params.Address, []string{"ps.dtb = '7ffe0000'"}, nil, nil},
	PsModuleNames:               {PsModuleNames, "modules loaded by the process", params.Slice, []string{"ps.modules in ('crypt32.dll', 'xul.dll')"}, nil, nil},
	PsParentName:                {PsParentName, "parent process image name including the file extension", params.UnicodeString, []string{"ps.parent.name contains 'cmd.exe'"}, nil, nil},
	PsParentPid:                 {PsParentPid, "parent process id", params.Uint32, []string{"ps.parent.pid = 4"}, nil, nil},
	PsParentComm:                {PsParentComm, "parent process command line", params.UnicodeString, []string{"ps.parent.comm contains 'java'"}, &Deprecation{Since: "1.10.0", Fields: []Field{PsParentCmdline}}, nil},
	PsParentCmdline:             {PsParentCmdline, "parent process command line", params.UnicodeString, []string{"ps.parent.cmdline contains 'java'"}, nil, nil},
	PsParentExe:                 {PsParentExe, "full name of the parent process' executable", params.UnicodeString, []string{"ps.parent.exe = 'C:\\Windows\\system32\\explorer.exe'"}, nil, nil},
	PsParentArgs:                {PsParentArgs, "parent process command line arguments", params.Slice, []string{"ps.parent.args in ('/cdir', '/-C')"}, nil, nil},
	PsParentCwd:                 {PsParentCwd, "parent process current working directory", params.UnicodeString, []string{"ps.parent.cwd = 'C:\\Temp'"}, nil, nil},
	PsParentSID:                 {PsParentSID, "security identifier under which the parent process is run", params.UnicodeString, []string{"ps.parent.sid contains 'SYSTEM'"}, nil, nil},
	PsParentDomain:              {PsParentDomain, "parent process domain", params.UnicodeString, []string{"ps.parent.domain contains 'SERVICE'"}, nil, nil},
	PsParentUsername:            {PsParentUsername, "parent process username", params.UnicodeString, []string{"ps.parent.username contains 'system'"}, nil, nil},
	PsParentSessionID:           {PsParentSessionID, "unique identifier for the current session of parent process", params.Int16, []string{"ps.parent.sessionid = 1"}, nil, nil},
	PsParentEnvs:                {PsParentEnvs, "parent process environment variables", params.Slice, []string{"ps.parent.envs in ('MOZ_CRASHREPORTER_DATA_DIRECTORY')"}, nil, nil},
	PsParentHandles:             {PsParentHandles, "allocated parent process handle names", params.Slice, []string{"ps.parent.handles in ('\\BaseNamedObjects\\__ComCatalogCache__')"}, nil, nil},
	PsParentHandleTypes:         {PsParentHandleTypes, "allocated parent process handle types", params.Slice, []string{"ps.parent.handle.types in ('File', 'SymbolicLink')"}, nil, nil},
	PsParentDTB:                 {PsParentDTB, "parent process directory table base address", params.Address, []string{"ps.parent.dtb = '7ffe0000'"}, nil, nil},
	PsAccessMask:                {PsAccessMask, "process desired access rights", params.AnsiString, []string{"ps.access.mask = '0x1400'"}, nil, nil},
	PsAccessMaskNames:           {PsAccessMaskNames, "process desired access rights as a string list", params.Slice, []string{"ps.access.mask.names in ('SUSPEND_RESUME')"}, nil, nil},
	PsAccessStatus:              {PsAccessStatus, "process access status", params.UnicodeString, []string{"ps.access.status = 'access is denied.'"}, nil, nil},
	PsUUID:                      {PsUUID, "unique process identifier", params.Uint64, []string{"ps.uuid > 6000054355"}, nil, nil},
	PsParentUUID:                {PsParentUUID, "unique parent process identifier", params.Uint64, []string{"ps.parent.uuid > 6000054355"}, nil, nil},
	PsIsWOW64Field:              {PsIsWOW64Field, "indicates if the process generating the event is a 32-bit process created in 64-bit Windows system", params.Bool, []string{"ps.is_wow64"}, nil, nil},
	PsIsPackagedField:           {PsIsPackagedField, "indicates if the process generating the event is packaged with the MSIX technology", params.Bool, []string{"ps.is_packaged"}, nil, nil},
	PsIsProtectedField:          {PsIsProtectedField, "indicates if the process generating the event is a protected process", params.Bool, []string{"ps.is_protected"}, nil, nil},
	PsParentIsWOW64Field:        {PsParentIsWOW64Field, "indicates if the parent process generating the event is a 32-bit process created in 64-bit Windows system", params.Bool, []string{"ps.parent.is_wow64"}, nil, nil},
	PsParentIsPackagedField:     {PsParentIsPackagedField, "indicates if the parent process generating the event is packaged with the MSIX technology", params.Bool, []string{"ps.parent.is_packaged"}, nil, nil},
	PsParentIsProtectedField:    {PsParentIsProtectedField, "indicates if the the parent process generating the event is a protected process", params.Bool, []string{"ps.parent.is_protected"}, nil, nil},
	PsAncestor:                  {PsAncestor, "the process ancestor name", params.UnicodeString, []string{"ps.ancestor[1] = 'svchost.exe'", "ps.ancestor in ('winword.exe')"}, nil, &Argument{Optional: true, Pattern: "[0-9]+", ValidationFunc: isNumber}},
	PsTokenIntegrityLevel:       {PsTokenIntegrityLevel, "process token integrity level", params.UnicodeString, []string{"ps.token.integrity_level = 'SYSTEM'"}, nil, nil},
	PsTokenIsElevated:           {PsTokenIsElevated, "indicates if the process token is elevated", params.Bool, []string{"ps.token.is_elevated = true"}, nil, nil},
	PsTokenElevationType:        {PsTokenElevationType, "process token elevation type", params.AnsiString, []string{"ps.token.elevation_type = 'LIMITED'"}, nil, nil},
	PsParentTokenIntegrityLevel: {PsParentTokenIntegrityLevel, "parent process token integrity level", params.UnicodeString, []string{"ps.parent.token.integrity_level = 'HIGH'"}, nil, nil},
	PsParentTokenIsElevated:     {PsParentTokenIsElevated, "indicates if the parent process token is elevated", params.Bool, []string{"ps.parent.token.is_elevated = true"}, nil, nil},
	PsParentTokenElevationType:  {PsParentTokenElevationType, "parent process token elevation type", params.AnsiString, []string{"ps.parent.token.elevation_type = 'LIMITED'"}, nil, nil},
	PsSignatureExists:           {PsSignatureExists, "indicates if the process executable has a valid signature", params.Bool, []string{"ps.signature.exists"}, nil, nil},
	PsSignatureTrusted:          {PsSignatureTrusted, "indicates if the process executable signature certificate chain is trusted", params.Bool, []string{"ps.signature.trusted"}, nil, nil},
	PsSignatureSerial:           {PsSignatureSerial, "represents signature serial number", params.UnicodeString, []string{"ps.signature.serial = '330000023241fb59996dcc4dff000000000232'"}, nil, nil},
	PsSignatureSubject:          {PsSignatureSubject, "represents signature subject", params.UnicodeString, []string{"ps.signature.subject contains 'Washington, Redmond, Microsoft Corporation'"}, nil, nil},
	PsSignatureIssuer:           {PsSignatureIssuer, "represents signature CA", params.UnicodeString, []string{"ps.signature.issuer contains 'Washington, Redmond, Microsoft Corporation'"}, nil, nil},
	PsSignatureAfter:            {PsSignatureAfter, "represents certificate expiration date", params.Time, []string{"ps.signature.after contains '2024-02-01 00:05:42 +0000 UTC'"}, nil, nil},
	PsSignatureBefore:           {PsSignatureBefore, "represents certificate enrollment date", params.Time, []string{"ps.signature.before contains '2024-02-01 00:05:42 +0000 UTC'"}, nil, nil},

	PsPeNumSections: {PsPeNumSections, "number of PE sections", params.Uint16, []string{"ps.pe.nsections < 5"}, nil, nil},
	PsPeNumSymbols:  {PsPeNumSymbols, "number of entries in the symbol table", params.Uint32, []string{"ps.pe.nsymbols > 230"}, nil, nil},
	PsPeBaseAddress: {PsPeBaseAddress, "executable base address", params.Address, []string{"ps.pe.address.base = '140000000'"}, nil, nil},
	PsPeEntrypoint:  {PsPeEntrypoint, "address of the entrypoint function", params.Address, []string{"ps.pe.address.entrypoint = '20110'"}, nil, nil},
	PsPeSymbols:     {PsPeSymbols, "imported symbols", params.Slice, []string{"ps.pe.symbols in ('GetTextFaceW', 'GetProcessHeap')"}, nil, nil},
	PsPeImports:     {PsPeImports, "imported dynamic linked libraries", params.Slice, []string{"ps.pe.imports in ('msvcrt.dll', 'GDI32.dll'"}, nil, nil},
	PsPeResources: {PsPeResources, "version resources", params.Map, []string{"ps.pe.resources[FileDescription] = 'Notepad'"}, nil, &Argument{Optional: true, Pattern: "[a-zA-Z0-9_]+", ValidationFunc: func(s string) bool {
		for _, c := range s {
			switch {
			case unicode.IsLower(c):
			case unicode.IsUpper(c):
			case unicode.IsNumber(c):
			case c == '_':
			default:
				return false
			}
		}
		return true
	}}},
	PsPeCompany:        {PsPeCompany, "internal company name of the file provided at compile-time", params.UnicodeString, []string{"ps.pe.company = 'Microsoft Corporation'"}, nil, nil},
	PsPeCopyright:      {PsPeCopyright, "copyright notice for the file emitted at compile-time", params.UnicodeString, []string{"ps.pe.copyright = '© Microsoft Corporation'"}, nil, nil},
	PsPeDescription:    {PsPeDescription, "internal description of the file provided at compile-time", params.UnicodeString, []string{"ps.pe.description = 'Notepad'"}, nil, nil},
	PsPeFileName:       {PsPeFileName, "original file name supplied at compile-time", params.UnicodeString, []string{"ps.pe.file.name = 'NOTEPAD.EXE'"}, nil, nil},
	PsPeFileVersion:    {PsPeFileVersion, "file version supplied at compile-time", params.UnicodeString, []string{"ps.pe.file.version = '10.0.18362.693 (WinBuild.160101.0800)'"}, nil, nil},
	PsPeProduct:        {PsPeProduct, "internal product name of the file provided at compile-time", params.UnicodeString, []string{"ps.pe.product = 'Microsoft® Windows® Operating System'"}, nil, nil},
	PsPeProductVersion: {PsPeProductVersion, "internal product version of the file provided at compile-time", params.UnicodeString, []string{"ps.pe.product.version = '10.0.18362.693'"}, nil, nil},
	PsPeImphash:        {PsPeImphash, "import hash", params.AnsiString, []string{"pe.impash = '5d3861c5c547f8a34e471ba273a732b2'"}, nil, nil},
	PsPeIsDotnet:       {PsPeIsDotnet, "indicates if PE contains CLR data", params.Bool, []string{"ps.pe.is_dotnet"}, nil, nil},
	PsPeAnomalies:      {PsPeAnomalies, "contains PE anomalies detected during parsing", params.Slice, []string{"ps.pe.anomalies in ('number of sections is 0')"}, nil, nil},
	PsPeIsModified:     {PsPeIsModified, "indicates if disk and in-memory PE headers differ", params.Bool, []string{"ps.pe.is_modified"}, nil, nil},

	ThreadBasePrio:                                 {ThreadBasePrio, "scheduler priority of the thread", params.Int8, []string{"thread.prio = 5"}, nil, nil},
	ThreadIOPrio:                                   {ThreadIOPrio, "I/O priority hint for scheduling I/O operations", params.Int8, []string{"thread.io.prio = 4"}, nil, nil},
	ThreadPagePrio:                                 {ThreadPagePrio, "memory page priority hint for memory pages accessed by the thread", params.Int8, []string{"thread.page.prio = 12"}, nil, nil},
	ThreadKstackBase:                               {ThreadKstackBase, "base address of the thread's kernel space stack", params.Address, []string{"thread.kstack.base = 'a65d800000'"}, nil, nil},
	ThreadKstackLimit:                              {ThreadKstackLimit, "limit of the thread's kernel space stack", params.Address, []string{"thread.kstack.limit = 'a85d800000'"}, nil, nil},
	ThreadUstackBase:                               {ThreadUstackBase, "base address of the thread's user space stack", params.Address, []string{"thread.ustack.base = '7ffe0000'"}, nil, nil},
	ThreadUstackLimit:                              {ThreadUstackLimit, "limit of the thread's user space stack", params.Address, []string{"thread.ustack.limit = '8ffe0000'"}, nil, nil},
	ThreadEntrypoint:                               {ThreadEntrypoint, "starting address of the function to be executed by the thread", params.Address, []string{"thread.entrypoint = '7efe0000'"}, &Deprecation{Since: "2.3.0", Fields: []Field{ThreadStartAddress}}, nil},
	ThreadStartAddress:                             {ThreadStartAddress, "thread start address", params.Address, []string{"thread.start_address = '7efe0000'"}, nil, nil},
	ThreadStartAddressSymbol:                       {ThreadStartAddressSymbol, "thread start address symbol", params.UnicodeString, []string{"thread.start_address.symbol = 'LoadImage'"}, nil, nil},
	ThreadStartAddressModule:                       {ThreadStartAddressModule, "thread start address module", params.UnicodeString, []string{"thread.start_address.module endswith 'kernel32.dll'"}, nil, nil},
	ThreadPID:                                      {ThreadPID, "the process identifier where the thread is created", params.Uint32, []string{"evt.pid != thread.pid"}, nil, nil},
	ThreadTEB:                                      {ThreadTEB, "the base address of the thread environment block", params.Address, []string{"thread.teb_address = '8f30893000'"}, nil, nil},
	ThreadAccessMask:                               {ThreadAccessMask, "thread desired access rights", params.AnsiString, []string{"thread.access.mask = '0x1fffff'"}, nil, nil},
	ThreadAccessMaskNames:                          {ThreadAccessMaskNames, "thread desired access rights as a string list", params.Slice, []string{"thread.access.mask.names in ('IMPERSONATE')"}, nil, nil},
	ThreadAccessStatus:                             {ThreadAccessStatus, "thread access status", params.UnicodeString, []string{"thread.access.status = 'success'"}, nil, nil},
	ThreadCallstackSummary:                         {ThreadCallstackSummary, "callstack summary", params.UnicodeString, []string{"thread.callstack.summary contains 'ntdll.dll|KERNELBASE.dll'"}, nil, nil},
	ThreadCallstackDetail:                          {ThreadCallstackDetail, "detailed information of each stack frame", params.UnicodeString, []string{"thread.callstack.detail contains 'KERNELBASE.dll!CreateProcessW'"}, nil, nil},
	ThreadCallstackModules:                         {ThreadCallstackModules, "list of modules comprising the callstack", params.Slice, []string{"thread.callstack.modules in ('C:\\WINDOWS\\System32\\KERNELBASE.dll')", "base(thread.callstack.modules[7]) = 'ntdll.dll'"}, nil, &Argument{Optional: true, Pattern: "[0-9]+", ValidationFunc: isNumber}},
	ThreadCallstackSymbols:                         {ThreadCallstackSymbols, "list of symbols comprising the callstack", params.Slice, []string{"thread.callstack.symbols in ('ntdll.dll!NtCreateProcess')", "thread.callstack.symbols[3] = 'ntdll!NtCreateProcess'"}, nil, &Argument{Optional: true, Pattern: "[0-9]+", ValidationFunc: isNumber}},
	ThreadCallstackAllocationSizes:                 {ThreadCallstackAllocationSizes, "allocation sizes of private pages", params.Slice, []string{"thread.callstack.allocation_sizes > 10000"}, nil, nil},
	ThreadCallstackProtections:                     {ThreadCallstackProtections, "page protections masks of each frame", params.Slice, []string{"thread.callstack.protections in ('RWX', 'WX')"}, nil, nil},
	ThreadCallstackCallsiteLeadingAssembly:         {ThreadCallstackCallsiteLeadingAssembly, "callsite leading assembly instructions", params.Slice, []string{"thread.callstack.callsite_leading_assembly in ('mov r10,rcx', 'syscall')"}, nil, nil},
	ThreadCallstackCallsiteTrailingAssembly:        {ThreadCallstackCallsiteTrailingAssembly, "callsite trailing assembly instructions", params.Slice, []string{"thread.callstack.callsite_trailing_assembly in ('add esp, 0xab')"}, nil, nil},
	ThreadCallstackIsUnbacked:                      {ThreadCallstackIsUnbacked, "indicates if the callstack contains unbacked regions", params.Bool, []string{"thread.callstack.is_unbacked"}, nil, nil},
	ThreadCallstackAddresses:                       {ThreadCallstackAddresses, "list of all stack return addresses", params.Slice, []string{"thread.callstack.addresses in ('7ffb5c1d0396')"}, nil, nil},
	ThreadCallstackFinalUserModuleName:             {ThreadCallstackFinalUserModuleName, "final user space stack frame module name", params.UnicodeString, []string{"thread.callstack.final_user_module.name != 'ntdll.dll'"}, nil, nil},
	ThreadCallstackFinalUserModulePath:             {ThreadCallstackFinalUserModulePath, "final user space stack frame module path", params.UnicodeString, []string{"thread.callstack.final_user_module.path imatches '?:\\Windows\\System32\\ntdll.dll'"}, nil, nil},
	ThreadCallstackFinalUserSymbolName:             {ThreadCallstackFinalUserSymbolName, "final user space stack symbol name", params.UnicodeString, []string{"thread.callstack.final_user_symbol.name imatches 'CreateProcess*'"}, nil, nil},
	ThreadCallstackFinalKernelModuleName:           {ThreadCallstackFinalKernelModuleName, "final kernel space stack frame module name", params.UnicodeString, []string{"thread.callstack.final_kernel_module.name = 'FLTMGR.SYS'"}, nil, nil},
	ThreadCallstackFinalKernelModulePath:           {ThreadCallstackFinalKernelModulePath, "final kernel space stack frame module path", params.UnicodeString, []string{"thread.callstack.final_kernel_module.path imatches '?:\\WINDOWS\\System32\\drivers\\FLTMGR.SYS'"}, nil, nil},
	ThreadCallstackFinalKernelSymbolName:           {ThreadCallstackFinalKernelSymbolName, "final kernel space stack symbol name", params.UnicodeString, []string{"thread.callstack.final_kernel_symbol.name = 'FltGetStreamContext'"}, nil, nil},
	ThreadCallstackFinalUserModuleSignatureExists:  {ThreadCallstackFinalUserModuleSignatureExists, "signature status of the final user space stack frame module", params.Bool, []string{"thread.callstack.final_user_module.signature.exists = true"}, nil, nil},
	ThreadCallstackFinalUserModuleSignatureTrusted: {ThreadCallstackFinalUserModuleSignatureTrusted, "signature trust status of the final user space stack frame module", params.Bool, []string{"thread.callstack.final_user_module.signature.trusted = true"}, nil, nil},
	ThreadCallstackFinalUserModuleSignatureIssuer:  {ThreadCallstackFinalUserModuleSignatureIssuer, "final user space stack frame module signature certificate issuer", params.UnicodeString, []string{"thread.callstack.final_user_module.signature.issuer imatches '*Microsoft Corporation*'"}, nil, nil},
	ThreadCallstackFinalUserModuleSignatureSubject: {ThreadCallstackFinalUserModuleSignatureSubject, "final user space stack frame module signature certificate subject", params.UnicodeString, []string{"thread.callstack.final_user_module.signature.subject imatches '*Microsoft Windows*'"}, nil, nil},

	ImagePath:                {ImagePath, "full image path", params.UnicodeString, []string{"image.path = 'C:\\Windows\\System32\\advapi32.dll'"}, &Deprecation{Since: "3.0.0", Fields: []Field{ModulePath}}, nil},
	ImageName:                {ImageName, "image name", params.UnicodeString, []string{"image.name = 'advapi32.dll'"}, &Deprecation{Since: "3.0.0", Fields: []Field{ModuleName}}, nil},
	ImageBase:                {ImageBase, "the base address of process in which the image is loaded", params.Address, []string{"image.base.address = 'a65d800000'"}, &Deprecation{Since: "3.0.0", Fields: []Field{ModuleBase}}, nil},
	ImageChecksum:            {ImageChecksum, "image checksum", params.Uint32, []string{"image.checksum = 746424"}, &Deprecation{Since: "3.0.0", Fields: []Field{ModuleChecksum}}, nil},
	ImageSize:                {ImageSize, "image size", params.Uint32, []string{"image.size > 1024"}, &Deprecation{Since: "3.0.0", Fields: []Field{ModuleSize}}, nil},
	ImageDefaultAddress:      {ImageDefaultAddress, "default image address", params.Address, []string{"image.default.address = '7efe0000'"}, &Deprecation{Since: "3.0.0", Fields: []Field{ModuleDefaultAddress}}, nil},
	ImagePID:                 {ImagePID, "target process identifier", params.Uint32, []string{"image.pid = 80"}, &Deprecation{Since: "3.0.0", Fields: []Field{ModulePID}}, nil},
	ImageSignatureType:       {ImageSignatureType, "image signature type", params.AnsiString, []string{"image.signature.type != 'NONE'"}, &Deprecation{Since: "3.0.0", Fields: []Field{ModuleSignatureType}}, nil},
	ImageSignatureLevel:      {ImageSignatureLevel, "image signature level", params.AnsiString, []string{"image.signature.level = 'AUTHENTICODE'"}, &Deprecation{Since: "3.0.0", Fields: []Field{ModuleSignatureLevel}}, nil},
	ImageCertSerial:          {ImageCertSerial, "image certificate serial number", params.UnicodeString, []string{"image.cert.serial = '330000023241fb59996dcc4dff000000000232'"}, &Deprecation{Since: "3.0.0", Fields: []Field{ModuleSignatureSerial}}, nil},
	ImageCertSubject:         {ImageCertSubject, "image certificate subject", params.UnicodeString, []string{"image.cert.subject contains 'Washington, Redmond, Microsoft Corporation'"}, &Deprecation{Since: "3.0.0", Fields: []Field{ModuleSignatureSubject}}, nil},
	ImageCertIssuer:          {ImageCertIssuer, "image certificate CA", params.UnicodeString, []string{"image.cert.issuer contains 'Washington, Redmond, Microsoft Corporation'"}, &Deprecation{Since: "3.0.0", Fields: []Field{ModuleSignatureIssuer}}, nil},
	ImageCertAfter:           {ImageCertAfter, "image certificate expiration date", params.Time, []string{"image.cert.after contains '2024-02-01 00:05:42 +0000 UTC'"}, &Deprecation{Since: "3.0.0", Fields: []Field{ModuleSignatureAfter}}, nil},
	ImageCertBefore:          {ImageCertBefore, "image certificate enrollment date", params.Time, []string{"image.cert.before contains '2024-02-01 00:05:42 +0000 UTC'"}, &Deprecation{Since: "3.0.0", Fields: []Field{ModuleSignatureBefore}}, nil},
	ImageIsDriverMalicious:   {ImageIsDriverMalicious, "indicates if the loaded driver is malicious", params.Bool, []string{"image.is_driver_malicious"}, &Deprecation{Since: "3.0.0", Fields: []Field{ModuleIsDriverMalicious}}, nil},
	ImageIsDriverVulnerable:  {ImageIsDriverVulnerable, "indicates if the loaded driver is vulnerable", params.Bool, []string{"image.is_driver_vulnerable"}, &Deprecation{Since: "3.0.0", Fields: []Field{ModuleIsDriverVulnerable}}, nil},
	ImageIsDLL:               {ImageIsDLL, "indicates if the loaded image is a DLL", params.Bool, []string{"image.is_dll'"}, &Deprecation{Since: "3.0.0", Fields: []Field{ModuleIsDLL}}, nil},
	ImageIsDriver:            {ImageIsDriver, "indicates if the loaded image is a driver", params.Bool, []string{"image.is_driver'"}, &Deprecation{Since: "3.0.0", Fields: []Field{ModuleIsDriver}}, nil},
	ImageIsExecutable:        {ImageIsExecutable, "indicates if the loaded image is an executable", params.Bool, []string{"image.is_exec'"}, &Deprecation{Since: "3.0.0", Fields: []Field{ModuleIsExecutable}}, nil},
	ImageIsDotnet:            {ImageIsDotnet, "indicates if the loaded image is a .NET assembly", params.Bool, []string{"image.is_dotnet'"}, &Deprecation{Since: "3.0.0", Fields: []Field{ModuleIsDotnet}}, nil},
	ModulePath:               {ModulePath, "full module path", params.UnicodeString, []string{"module.path = 'C:\\Windows\\System32\\advapi32.dll'"}, nil, nil},
	ModulePathStem:           {ModulePathStem, "module path stem", params.UnicodeString, []string{"module.path.stem = 'C:\\Windows\\System32\\advapi32'"}, nil, nil},
	ModuleName:               {ModuleName, "module name", params.UnicodeString, []string{"module.name = 'advapi32.dll'"}, nil, nil},
	ModuleBase:               {ModuleBase, "the base address of process in which the module is loaded", params.Address, []string{"module.base.address = 'a65d800000'"}, nil, nil},
	ModuleChecksum:           {ModuleChecksum, "module checksum", params.Uint32, []string{"module.checksum = 746424"}, nil, nil},
	ModuleSize:               {ModuleSize, "module size", params.Uint32, []string{"module.size > 1024"}, nil, nil},
	ModuleDefaultAddress:     {ModuleDefaultAddress, "default module address", params.Address, []string{"module.default_address = '7efe0000'"}, nil, nil},
	ModulePID:                {ModulePID, "target process identifier", params.Uint32, []string{"module.pid = 80"}, nil, nil},
	ModuleSignatureType:      {ModuleSignatureType, "module signature type", params.AnsiString, []string{"module.signature.type != 'NONE'"}, nil, nil},
	ModuleSignatureLevel:     {ModuleSignatureLevel, "module signature level", params.AnsiString, []string{"module.signature.level = 'AUTHENTICODE'"}, nil, nil},
	ModuleSignatureExists:    {ModuleSignatureExists, "indicates if the module is signed", params.Bool, []string{"module.signature.exists = true"}, nil, nil},
	ModuleSignatureTrusted:   {ModuleSignatureTrusted, "indicates if the module signature is trusted", params.Bool, []string{"module.signature.trusted = false"}, nil, nil},
	ModuleSignatureSerial:    {ModuleSignatureSerial, "module certificate serial number", params.UnicodeString, []string{"module.signature.serial = '330000023241fb59996dcc4dff000000000232'"}, nil, nil},
	ModuleSignatureSubject:   {ModuleSignatureSubject, "module certificate subject", params.UnicodeString, []string{"module.signature.subject contains 'Washington, Redmond, Microsoft Corporation'"}, nil, nil},
	ModuleSignatureIssuer:    {ModuleSignatureIssuer, "module certificate CA", params.UnicodeString, []string{"module.signature.issuer contains 'Washington, Redmond, Microsoft Corporation'"}, nil, nil},
	ModuleSignatureAfter:     {ModuleSignatureAfter, "module certificate expiration date", params.Time, []string{"module.signature.after contains '2024-02-01 00:05:42 +0000 UTC'"}, nil, nil},
	ModuleSignatureBefore:    {ModuleSignatureBefore, "module certificate enrollment date", params.Time, []string{"module.signature.before contains '2024-02-01 00:05:42 +0000 UTC'"}, nil, nil},
	ModuleIsDriverMalicious:  {ModuleIsDriverMalicious, "indicates if the loaded driver is malicious", params.Bool, []string{"module.is_driver_malicious"}, nil, nil},
	ModuleIsDriverVulnerable: {ModuleIsDriverVulnerable, "indicates if the loaded driver is vulnerable", params.Bool, []string{"module.is_driver_vulnerable"}, nil, nil},
	ModuleIsDLL:              {ModuleIsDLL, "indicates if the loaded module is a DLL", params.Bool, []string{"module.is_dll'"}, nil, nil},
	ModuleIsDriver:           {ModuleIsDriver, "indicates if the loaded module is a driver", params.Bool, []string{"module.is_driver'"}, nil, nil},
	ModuleIsExecutable:       {ModuleIsExecutable, "indicates if the loaded module is an executable", params.Bool, []string{"module.is_exec'"}, nil, nil},
	ModuleIsDotnet:           {ModuleIsDotnet, "indicates if the loaded module is a .NET assembly", params.Bool, []string{"module.pe.is_dotnet'"}, nil, nil},
	DllPath:                  {DllPath, "full dll path", params.UnicodeString, []string{"dll.path = 'C:\\Windows\\System32\\advapi32.dll'"}, nil, nil},
	DllPathStem:              {DllPathStem, "dll path stem", params.UnicodeString, []string{"dll.path.stem = 'C:\\Windows\\System32\\advapi32'"}, nil, nil},
	DllName:                  {DllName, "module name", params.UnicodeString, []string{"dll.name = 'advapi32.dll'"}, nil, nil},
	DllBase:                  {DllBase, "the base address of process in which the DLL is loaded", params.Address, []string{"dll.base = 'a65d800000'"}, nil, nil},
	DllSize:                  {DllSize, "dll virtual mapped size", params.Uint32, []string{"dll.size > 1024"}, nil, nil},
	DllPID:                   {DllPID, "target process identifier", params.Uint32, []string{"dll.pid = 80"}, nil, nil},
	DllSignatureType:         {DllSignatureType, "dll signature type", params.AnsiString, []string{"dll.signature.type != 'NONE'"}, nil, nil},
	DllSignatureLevel:        {DllSignatureLevel, "dll signature level", params.AnsiString, []string{"dll.signature.level = 'AUTHENTICODE'"}, nil, nil},
	DllSignatureExists:       {DllSignatureExists, "indicates if the dll is signed", params.Bool, []string{"dll.signature.exists = true"}, nil, nil},
	DllSignatureTrusted:      {DllSignatureTrusted, "indicates if the dll signature is trusted", params.Bool, []string{"dll.signature.trusted = false"}, nil, nil},
	DllSignatureSerial:       {DllSignatureSerial, "dll certificate serial number", params.UnicodeString, []string{"dll.signature.serial = '330000023241fb59996dcc4dff000000000232'"}, nil, nil},
	DllSignatureSubject:      {DllSignatureSubject, "dll certificate subject", params.UnicodeString, []string{"dll.signature.subject contains 'Washington, Redmond, Microsoft Corporation'"}, nil, nil},
	DllSignatureIssuer:       {DllSignatureIssuer, "dll certificate CA", params.UnicodeString, []string{"dll.signature.issuer contains 'Washington, Redmond, Microsoft Corporation'"}, nil, nil},
	DllSignatureAfter:        {DllSignatureAfter, "moddllule certificate expiration date", params.Time, []string{"dll.signature.after contains '2024-02-01 00:05:42 +0000 UTC'"}, nil, nil},
	DllSignatureBefore:       {DllSignatureBefore, "dll certificate enrollment date", params.Time, []string{"dll.signature.before contains '2024-02-01 00:05:42 +0000 UTC'"}, nil, nil},
	DllIsDotnet:              {DllIsDotnet, "indicates if the loaded dll is a .NET assembly", params.Bool, []string{"dll.pe.is_dotnet'"}, nil, nil},

	FileObject:                      {FileObject, "file object address", params.Uint64, []string{"file.object = 18446738026482168384"}, nil, nil},
	FilePath:                        {FilePath, "full file path", params.UnicodeString, []string{"file.path = 'C:\\Windows\\System32'"}, nil, nil},
	FilePathStem:                    {FilePathStem, "full file path without extension", params.UnicodeString, []string{"file.path.stem = 'C:\\Windows\\System32\\cmd'"}, nil, nil},
	FileName:                        {FileName, "full file name", params.UnicodeString, []string{"file.name contains 'mimikatz'"}, nil, nil},
	FileOperation:                   {FileOperation, "file operation", params.AnsiString, []string{"file.operation = 'open'"}, nil, nil},
	FileShareMask:                   {FileShareMask, "file share mask", params.AnsiString, []string{"file.share.mask = 'rw-'"}, nil, nil},
	FileIOSize:                      {FileIOSize, "file I/O size", params.Uint32, []string{"file.io.size > 512"}, nil, nil},
	FileOffset:                      {FileOffset, "file offset", params.Uint64, []string{"file.offset = 1024"}, nil, nil},
	FileType:                        {FileType, "file type", params.AnsiString, []string{"file.type = 'directory'"}, nil, nil},
	FileExtension:                   {FileExtension, "file extension", params.AnsiString, []string{"file.extension = '.dll'"}, nil, nil},
	FileAttributes:                  {FileAttributes, "file attributes", params.Slice, []string{"file.attributes in ('archive', 'hidden')"}, nil, nil},
	FileStatus:                      {FileStatus, "file operation status message", params.UnicodeString, []string{"file.status != 'success'"}, nil, nil},
	FileViewBase:                    {FileViewBase, "view base address", params.Address, []string{"file.view.base = '25d42170000'"}, nil, nil},
	FileViewSize:                    {FileViewSize, "size of the mapped view", params.Uint64, []string{"file.view.size > 1024"}, nil, nil},
	FileViewType:                    {FileViewType, "type of the mapped view section", params.Enum, []string{"file.view.type = 'IMAGE'"}, nil, nil},
	FileViewProtection:              {FileViewProtection, "protection rights of the section view", params.AnsiString, []string{"file.view.protection = 'READONLY'"}, nil, nil},
	FileIsDriverMalicious:           {FileIsDriverMalicious, "indicates if the dropped driver is malicious", params.Bool, []string{"file.is_driver_malicious"}, nil, nil},
	FileIsDriverVulnerable:          {FileIsDriverVulnerable, "indicates if the dropped driver is vulnerable", params.Bool, []string{"file.is_driver_vulnerable"}, nil, nil},
	FileIsDLL:                       {FileIsDLL, "indicates if the created file is a DLL", params.Bool, []string{"file.is_dll'"}, nil, nil},
	FileIsDriver:                    {FileIsDriver, "indicates if the created file is a driver", params.Bool, []string{"file.is_driver'"}, nil, nil},
	FileIsExecutable:                {FileIsExecutable, "indicates if the created file is an executable", params.Bool, []string{"file.is_exec'"}, nil, nil},
	FilePID:                         {FilePID, "denotes the process id performing file operation", params.PID, []string{"file.pid = 4"}, nil, nil},
	FileKey:                         {FileKey, "uniquely identifies the file object", params.Uint64, []string{"file.key = 12446738026482168384"}, nil, nil},
	FileInfoClass:                   {FileInfoClass, "identifies the file information class", params.Enum, []string{"file.info_class = 'Allocation'"}, nil, nil},
	FileInfoAllocationSize:          {FileInfoAllocationSize, "file allocation size", params.Uint64, []string{"file.info.allocation_size > 645400"}, nil, nil},
	FileInfoEOFSize:                 {FileInfoEOFSize, "file EOF size", params.Uint64, []string{"file.info.eof_size > 1000"}, nil, nil},
	FileInfoIsDispositionDeleteFile: {FileInfoIsDispositionDeleteFile, "indicates if the file is deleted when its handle is closed", params.Bool, []string{"file.info.is_disposition_file_delete = true"}, nil, nil},

	RegistryPath:      {RegistryPath, "fully qualified registry path", params.UnicodeString, []string{"registry.path = 'HKEY_LOCAL_MACHINE\\SYSTEM'"}, nil, nil},
	RegistryKeyName:   {RegistryKeyName, "registry key name", params.UnicodeString, []string{"registry.key.name = 'CurrentControlSet'"}, nil, nil},
	RegistryKeyHandle: {RegistryKeyHandle, "registry key object address", params.Address, []string{"registry.key.handle = 'FFFFB905D60C2268'"}, nil, nil},
	RegistryValue:     {RegistryValue, "registry value name", params.UnicodeString, []string{"registry.value = 'Epoch'"}, nil, nil},
	RegistryValueType: {RegistryValueType, "type of registry value", params.UnicodeString, []string{"registry.value.type = 'REG_SZ'"}, nil, nil},
	RegistryData:      {RegistryData, "registry value captured data", params.Object, []string{"registry.data = '%SystemRoot%'"}, nil, nil},
	RegistryStatus:    {RegistryStatus, "status of registry operation", params.UnicodeString, []string{"registry.status != 'success'"}, nil, nil},

	NetDIP:        {NetDIP, "destination IP address", params.IP, []string{"net.dip = 172.17.0.3"}, nil, nil},
	NetSIP:        {NetSIP, "source IP address", params.IP, []string{"net.sip = 127.0.0.1"}, nil, nil},
	NetDport:      {NetDport, "destination port", params.Uint16, []string{"net.dport in (80, 443, 8080)"}, nil, nil},
	NetSport:      {NetSport, "source port", params.Uint16, []string{"net.sport != 3306"}, nil, nil},
	NetDportName:  {NetDportName, "destination port name", params.AnsiString, []string{"net.dport.name = 'dns'"}, nil, nil},
	NetSportName:  {NetSportName, "source port name", params.AnsiString, []string{"net.sport.name = 'http'"}, nil, nil},
	NetL4Proto:    {NetL4Proto, "layer 4 protocol name", params.AnsiString, []string{"net.l4.proto = 'TCP"}, nil, nil},
	NetPacketSize: {NetPacketSize, "packet size", params.Uint32, []string{"net.size > 512"}, nil, nil},
	NetSIPNames:   {NetSIPNames, "source IP names", params.Slice, []string{"net.sip.names in ('github.com.')"}, nil, nil},
	NetDIPNames:   {NetDIPNames, "destination IP names", params.Slice, []string{"net.dip.names in ('github.com.')"}, nil, nil},

	HandleID:     {HandleID, "handle identifier", params.Uint16, []string{"handle.id = 24"}, nil, nil},
	HandleObject: {HandleObject, "handle object address", params.Address, []string{"handle.object = 'FFFFB905DBF61988'"}, nil, nil},
	HandleName:   {HandleName, "handle name", params.UnicodeString, []string{"handle.name = '\\Device\\NamedPipe\\chrome.12644.28.105826381'"}, nil, nil},
	HandleType:   {HandleType, "handle type", params.AnsiString, []string{"handle.type = 'Mutant'"}, nil, nil},

	PeNumSections: {PeNumSections, "number of sections", params.Uint16, []string{"pe.nsections < 5"}, &Deprecation{Since: "3.0.0", Fields: []Field{PsPeNumSections}}, nil},
	PeNumSymbols:  {PeNumSymbols, "number of entries in the symbol table", params.Uint32, []string{"pe.nsymbols > 230"}, &Deprecation{Since: "3.0.0", Fields: []Field{PsPeNumSymbols}}, nil},
	PeBaseAddress: {PeBaseAddress, "image base address", params.Address, []string{"pe.address.base = '140000000'"}, &Deprecation{Since: "3.0.0", Fields: []Field{PsPeBaseAddress}}, nil},
	PeEntrypoint:  {PeEntrypoint, "address of the entrypoint function", params.Address, []string{"pe.address.entrypoint = '20110'"}, &Deprecation{Since: "3.0.0", Fields: []Field{PsPeEntrypoint}}, nil},
	PeSymbols:     {PeSymbols, "imported symbols", params.Slice, []string{"pe.symbols in ('GetTextFaceW', 'GetProcessHeap')"}, &Deprecation{Since: "3.0.0", Fields: []Field{PsPeSymbols}}, nil},
	PeImports:     {PeImports, "imported dynamic linked libraries", params.Slice, []string{"pe.imports in ('msvcrt.dll', 'GDI32.dll'"}, &Deprecation{Since: "3.0.0", Fields: []Field{PsPeImports}}, nil},

	PeResources: {PeResources, "version resources", params.Map, []string{"pe.resources[FileDescription] = 'Notepad'"}, &Deprecation{Since: "3.0.0", Fields: []Field{PsPeResources}}, &Argument{Optional: true, Pattern: "[a-zA-Z0-9_]+", ValidationFunc: func(s string) bool {
		for _, c := range s {
			switch {
			case unicode.IsLower(c):
			case unicode.IsUpper(c):
			case unicode.IsNumber(c):
			case c == '_':
			default:
				return false
			}
		}
		return true
	}}},

	PeCompany:        {PeCompany, "internal company name of the file provided at compile-time", params.UnicodeString, []string{"pe.company = 'Microsoft Corporation'"}, &Deprecation{Since: "3.0.0", Fields: []Field{PsPeCompany}}, nil},
	PeCopyright:      {PeCopyright, "copyright notice for the file emitted at compile-time", params.UnicodeString, []string{"pe.copyright = '© Microsoft Corporation'"}, &Deprecation{Since: "3.0.0", Fields: []Field{PsPeCopyright}}, nil},
	PeDescription:    {PeDescription, "internal description of the file provided at compile-time", params.UnicodeString, []string{"pe.description = 'Notepad'"}, &Deprecation{Since: "3.0.0", Fields: []Field{PsPeDescription}}, nil},
	PeFileName:       {PeFileName, "original file name supplied at compile-time", params.UnicodeString, []string{"pe.file.name = 'NOTEPAD.EXE'"}, &Deprecation{Since: "3.0.0", Fields: []Field{PsPeFileName}}, nil},
	PeFileVersion:    {PeFileVersion, "file version supplied at compile-time", params.UnicodeString, []string{"pe.file.version = '10.0.18362.693 (WinBuild.160101.0800)'"}, &Deprecation{Since: "3.0.0", Fields: []Field{PsPeFileVersion}}, nil},
	PeProduct:        {PeProduct, "internal product name of the file provided at compile-time", params.UnicodeString, []string{"pe.product = 'Microsoft® Windows® Operating System'"}, &Deprecation{Since: "3.0.0", Fields: []Field{PsPeProduct}}, nil},
	PeProductVersion: {PeProductVersion, "internal product version of the file provided at compile-time", params.UnicodeString, []string{"pe.product.version = '10.0.18362.693'"}, &Deprecation{Since: "3.0.0", Fields: []Field{PsPeProductVersion}}, nil},
	PeIsDLL:          {PeIsDLL, "indicates if the loaded image or created file is a DLL", params.Bool, []string{"pe.is_dll'"}, &Deprecation{Since: "2.0.0", Fields: []Field{FileIsDLL, ImageIsDLL}}, nil},
	PeIsDriver:       {PeIsDriver, "indicates if the loaded image or created file is a driver", params.Bool, []string{"pe.is_driver'"}, &Deprecation{Since: "2.0.0", Fields: []Field{FileIsDriver, ImageIsDriver}}, nil},
	PeIsExecutable:   {PeIsExecutable, "indicates if the loaded image or created file is an executable", params.Bool, []string{"pe.is_exec'"}, &Deprecation{Since: "2.0.0", Fields: []Field{FileIsExecutable, ImageIsExecutable}}, nil},
	PeImphash:        {PeImphash, "import hash", params.AnsiString, []string{"pe.impash = '5d3861c5c547f8a34e471ba273a732b2'"}, &Deprecation{Since: "3.0.0", Fields: []Field{PsPeImphash}}, nil},
	PeIsDotnet:       {PeIsDotnet, "indicates if PE contains CLR data", params.Bool, []string{"pe.is_dotnet"}, &Deprecation{Since: "3.0.0", Fields: []Field{PsPeIsDotnet}}, nil},
	PeAnomalies:      {PeAnomalies, "contains PE anomalies detected during parsing", params.Slice, []string{"pe.anomalies in ('number of sections is 0')"}, &Deprecation{Since: "3.0.0", Fields: []Field{PsPeAnomalies}}, nil},
	PeIsSigned:       {PeIsSigned, "indicates if the PE has embedded or catalog signature", params.Bool, []string{"pe.is_signed"}, &Deprecation{Since: "3.0.0", Fields: []Field{PsSignatureExists}}, nil},
	PeIsTrusted:      {PeIsTrusted, "indicates if the PE certificate chain is trusted", params.Bool, []string{"pe.is_trusted"}, &Deprecation{Since: "3.0.0", Fields: []Field{PsSignatureTrusted}}, nil},
	PeCertSerial:     {PeCertSerial, "PE certificate serial number", params.UnicodeString, []string{"pe.cert.serial = '330000023241fb59996dcc4dff000000000232'"}, &Deprecation{Since: "3.0.0", Fields: []Field{PsSignatureSerial}}, nil},
	PeCertSubject:    {PeCertSubject, "PE certificate subject", params.UnicodeString, []string{"pe.cert.subject contains 'Washington, Redmond, Microsoft Corporation'"}, &Deprecation{Since: "3.0.0", Fields: []Field{PsSignatureSubject}}, nil},
	PeCertIssuer:     {PeCertIssuer, "PE certificate CA", params.UnicodeString, []string{"pe.cert.issuer contains 'Washington, Redmond, Microsoft Corporation'"}, &Deprecation{Since: "3.0.0", Fields: []Field{PsSignatureIssuer}}, nil},
	PeCertAfter:      {PeCertAfter, "PE certificate expiration date", params.Time, []string{"pe.cert.after contains '2024-02-01 00:05:42 +0000 UTC'"}, &Deprecation{Since: "3.0.0", Fields: []Field{PsSignatureAfter}}, nil},
	PeCertBefore:     {PeCertBefore, "PE certificate enrollment date", params.Time, []string{"pe.cert.before contains '2024-02-01 00:05:42 +0000 UTC'"}, &Deprecation{Since: "3.0.0", Fields: []Field{PsSignatureBefore}}, nil},
	PeIsModified:     {PeIsModified, "indicates if disk and in-memory PE headers differ", params.Bool, []string{"pe.is_modified"}, &Deprecation{Since: "3.0.0", Fields: []Field{PsPeIsModified}}, nil},

	MemBaseAddress:    {MemBaseAddress, "region base address", params.Address, []string{"mem.address = '211d13f2000'"}, nil, nil},
	MemRegionSize:     {MemRegionSize, "region size", params.Uint64, []string{"mem.size > 438272"}, nil, nil},
	MemAllocType:      {MemAllocType, "region allocation or release type", params.Flags, []string{"mem.alloc = 'COMMIT'"}, nil, nil},
	MemPageType:       {MemPageType, "page type of the allocated region", params.Enum, []string{"mem.type = 'PRIVATE'"}, nil, nil},
	MemProtection:     {MemProtection, "allocated region protection type", params.Enum, []string{"mem.protection = 'READWRITE'"}, nil, nil},
	MemProtectionMask: {MemProtectionMask, "allocated region protection in mask notation", params.Enum, []string{"mem.protection.mask = 'RWX'"}, nil, nil},

	DNSName:    {DNSName, "dns query name", params.UnicodeString, []string{"dns.name = 'example.org'"}, nil, nil},
	DNSRR:      {DNSRR, "dns resource record type", params.AnsiString, []string{"dns.rr = 'AA'"}, nil, nil},
	DNSOptions: {DNSOptions, "dns query options", params.Flags64, []string{"dns.options in ('ADDRCONFIG', 'DUAL_ADDR')"}, nil, nil},
	DNSRcode:   {DNSRR, "dns response status", params.AnsiString, []string{"dns.rcode = 'NXDOMAIN'"}, nil, nil},
	DNSAnswers: {DNSAnswers, "dns response answers", params.Slice, []string{"dns.answers in ('o.lencr.edgesuite.net', 'a1887.dscq.akamai.net')"}, nil, nil},

	ThreadpoolPoolID:                   {ThreadpoolPoolID, "thread pool identifier", params.Address, []string{"threadpool.id = '20f5fc02440'"}, nil, nil},
	ThreadpoolTaskID:                   {ThreadpoolTaskID, "thread pool task identifier", params.Address, []string{"threadpool.task.id = '20f7ecd21f8'"}, nil, nil},
	ThreadpoolCallbackAddress:          {ThreadpoolCallbackAddress, "thread pool callback address", params.Address, []string{"threadpool.callback.address = '7ff868739ed0'"}, nil, nil},
	ThreadpoolCallbackSymbol:           {ThreadpoolCallbackSymbol, "thread pool callback symbol", params.UnicodeString, []string{"threadpool.callback.symbol = 'RtlDestroyQueryDebugBuffer'"}, nil, nil},
	ThreadpoolCallbackModule:           {ThreadpoolCallbackModule, "thread pool module containing the callback symbol", params.UnicodeString, []string{"threadpool.callback.module contains 'ntdll.dll'"}, nil, nil},
	ThreadpoolCallbackContext:          {ThreadpoolCallbackContext, "thread pool callback context address", params.Address, []string{"threadpool.callback.context = '1df41e07bd0'"}, nil, nil},
	ThreadpoolCallbackContextRip:       {ThreadpoolCallbackContextRip, "thread pool callback thread context instruction pointer", params.Address, []string{"threadpool.callback.context.rip = '1df42ffc1f8'"}, nil, nil},
	ThreadpoolCallbackContextRipSymbol: {ThreadpoolCallbackContextRipSymbol, "thread pool callback thread context instruction pointer symbol", params.UnicodeString, []string{"threadpool.callback.context.rip.symbol = 'VirtualProtect'"}, nil, nil},
	ThreadpoolCallbackContextRipModule: {ThreadpoolCallbackContextRipModule, "thread pool callback thread context instruction pointer symbol module", params.UnicodeString, []string{"threadpool.callback.context.rip.module contains 'ntdll.dll'"}, nil, nil},
	ThreadpoolSubprocessTag:            {ThreadpoolSubprocessTag, "thread pool service identifier", params.Address, []string{"threadpool.subprocess_tag = '10d'"}, nil, nil},
	ThreadpoolTimerDuetime:             {ThreadpoolTimerDuetime, "thread pool timer due time", params.Uint64, []string{"threadpool.timer.duetime > 10"}, nil, nil},
	ThreadpoolTimerSubqueue:            {ThreadpoolTimerSubqueue, "thread pool timer subqueue address", params.Address, []string{"threadpool.timer.subqueue = '1db401703e8'"}, nil, nil},
	ThreadpoolTimer:                    {ThreadpoolTimer, "thread pool timer address", params.Address, []string{"threadpool.timer.address = '3e8'"}, nil, nil},
	ThreadpoolTimerPeriod:              {ThreadpoolTimerPeriod, "thread pool timer period", params.Uint32, []string{"threadpool.timer.period = 0'"}, nil, nil},
	ThreadpoolTimerWindow:              {ThreadpoolTimerWindow, "thread pool timer tolerate period", params.Uint32, []string{"threadpool.timer.window = 0'"}, nil, nil},
	ThreadpoolTimerAbsolute:            {ThreadpoolTimerAbsolute, "indicates if the thread pool timer is absolute or relative", params.Bool, []string{"threadpool.timer.is_absolute = true'"}, nil, nil},
}

// ArgumentOf returns argument data for the specified field.
func ArgumentOf(name string) *Argument {
	f, ok := fields[Field(name)]
	if !ok {
		// this can happen for pseudo fields
		return nil
	}
	return f.Argument
}

// IsField returns true if the provided string is a
// recognized field or pseudo field. Otherwise, it
// returns false.
func IsField(name string) bool {
	if _, ok := fields[Field(name)]; ok || IsPseudoField(Field(name)) {
		return true
	}
	return false
}

```

`pkg/filter/fields/fields_windows_test.go`:

```go
/*
 * Copyright 2019-2020 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package fields

import (
	"testing"

	"github.com/stretchr/testify/assert"
)

func TestIsField(t *testing.T) {
	var tests = []struct {
		name    string
		isField bool
	}{
		{"ps.pid", true},
		{"ps.none", false},
		{"ps.envs[ALLUSERSPROFILE]", false},
		{"evt.arg", true},
		{"thread._callstack", true},
		{"evt._callstack", false},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			assert.Equal(t, tt.isField, IsField(tt.name))
		})
	}
}

func TestIsDeprecated(t *testing.T) {
	deprecated, d := IsDeprecated(KevtArg)
	assert.True(t, deprecated)
	assert.NotNil(t, d)
}

```

`pkg/filter/filter.go`:

```go
/*
 * Copyright 2019-2020 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package filter

import (
	"errors"
	"expvar"
	"fmt"
	"reflect"
	"regexp"
	"strconv"
	"strings"
	"sync"

	errs "github.com/rabbitstack/fibratus/pkg/errors"
	"github.com/rabbitstack/fibratus/pkg/event"
	"github.com/rabbitstack/fibratus/pkg/filter/fields"
	"github.com/rabbitstack/fibratus/pkg/filter/ql"
)

var (
	// ErrNoFields signals an error that happens when the filter is declared without any fields
	ErrNoFields = errors.New("expected at least one field or operator but zero found")
	// accessorErrors counts the errors produced by the field accessors
	accessorErrors = expvar.NewMap("filter.accessor.errors")
)

// Filter is the main interface for the filter engine implementors. Filter can either
// be a single expression combined by various subexpressions connected by operators, or
// it can be a sequence of expressions.
type Filter interface {
	// Compile compiles the filter by parsing the sequence/expression.
	Compile() error
	// Run runs a filter with a single expression. The return value decides
	// if the incoming event has successfully matched the filter expression.
	Run(evt *event.Event) bool
	// RunSequence runs a filter with sequence expressions. Sequence rules depend
	// on the state machine transitions and partial matches to decide whether the
	// rule is fired.
	RunSequence(evt *event.Event, seqID int, partials map[int][]*event.Event, rawMatch bool) bool
	// GetStringFields returns field names mapped to their string values.
	GetStringFields() map[fields.Field][]string
	// GetFields returns all fields used in the filter expression.
	GetFields() []Field
	// GetSequence returns the sequence descriptor or nil if this filter is not a sequence.
	GetSequence() *ql.Sequence
	// IsSequence determines if this filter is a sequence.
	IsSequence() bool
}

// Field contains field meta attributes all accessors need to extract the value.
type Field struct {
	Name  fields.Field
	Value string
	Arg   string
}

// BoundField contains the field meta attributes in addition to bound field specific fields.
type BoundField struct {
	Field    Field
	Value    string
	BoundVar string
	accessor Accessor
}

// Accessor finds exactly one accessor that can serve the bound field.
func (b *BoundField) Accessor(f *filter) Accessor {
	if b.accessor != nil {
		return b.accessor
	}
	switch {
	case b.Field.Name.IsKevtField(), b.Field.Name.IsEvtField():
		b.accessor = newEventAccessor()
	case b.Field.Name.IsPsField():
		for _, accessor := range f.accessors {
			if reflect.TypeOf(accessor) == reflect.TypeOf(&psAccessor{}) {
				b.accessor = accessor
				break
			}
		}
		if b.accessor == nil {
			b.accessor = newPSAccessor(nil)
		}
	case b.Field.Name.IsThreadField():
		b.accessor = newThreadAccessor()
	case b.Field.Name.IsImageField():
		b.accessor = newModuleAccessor()
	case b.Field.Name.IsFileField():
		b.accessor = newFileAccessor()
	case b.Field.Name.IsRegistryField():
		b.accessor = newRegistryAccessor()
	case b.Field.Name.IsNetworkField():
		b.accessor = newNetworkAccessor()
	case b.Field.Name.IsHandleField():
		b.accessor = newHandleAccessor()
	case b.Field.Name.IsPeField():
		b.accessor = newPEAccessor()
	case b.Field.Name.IsMemField():
		b.accessor = newMemAccessor()
	case b.Field.Name.IsDNSField():
		b.accessor = newDNSAccessor()
	case b.Field.Name.IsThreadpoolField():
		b.accessor = newThreadAccessor()
	}
	return b.accessor
}

type filter struct {
	expr        ql.Expr
	seq         *ql.Sequence
	parser      *ql.Parser
	accessors   []Accessor
	fields      []Field
	segments    []fields.Segment
	boundFields []*ql.BoundFieldLiteral
	// seqBoundFields contains per-sequence bound fields resolved from bound field literals
	seqBoundFields map[int][]BoundField
	// stringFields contains filter field names mapped to their string values
	stringFields map[fields.Field][]string
	hasFunctions bool
}

// Compile parsers the filter expression and builds a binary expression tree
// where leaf nodes represent constants/variables while internal nodes are
// operators. Operators can be binary (=) or unary (not). Fields in filter
// expressions are replaced with respective event parameters via map valuer.
// For functions call we grab all the arguments that are evaluated as field
// literals.
// Matching the filter involves descending the binary expression tree recursively
// until all nodes are visited.
func (f *filter) Compile() error {
	var err error
	if f.parser.IsSequence() {
		f.seq, err = f.parser.ParseSequence()
	} else {
		f.expr, err = f.parser.ParseExpr()
	}
	if err != nil {
		return err
	}

	// traverse the expression tree
	walk := func(n ql.Node) {
		switch expr := n.(type) {
		case *ql.BinaryExpr:
			if lhs, ok := expr.LHS.(*ql.FieldLiteral); ok {
				f.addField(lhs)
				f.addStringFields(lhs.Field, expr.RHS)
			}
			if rhs, ok := expr.RHS.(*ql.FieldLiteral); ok {
				f.addField(rhs)
				f.addStringFields(rhs.Field, expr.LHS)
			}
			if lhs, ok := expr.LHS.(*ql.BoundFieldLiteral); ok {
				f.addField(lhs.Field)
				f.addBoundField(lhs)
			}
			if rhs, ok := expr.RHS.(*ql.BoundFieldLiteral); ok {
				f.addField(rhs.Field)
				f.addBoundField(rhs)
			}
		case *ql.Function:
			f.hasFunctions = true
			for _, arg := range expr.Args {
				if field, ok := arg.(*ql.FieldLiteral); ok {
					f.addField(field)
				}
				if field, ok := arg.(*ql.BoundFieldLiteral); ok {
					f.addField(field.Field)
					f.addBoundField(field)
				}
				switch exp := arg.(type) {
				case *ql.BinaryExpr:
					if segment, ok := exp.LHS.(*ql.BoundSegmentLiteral); ok {
						f.addSegment(segment)
					}
					if segment, ok := exp.RHS.(*ql.BoundSegmentLiteral); ok {
						f.addSegment(segment)
					}
				}
			}
		case *ql.FieldLiteral:
			if fields.IsBoolean(expr.Field) {
				f.addField(expr)
			}
		}
	}

	if f.expr != nil {
		ql.WalkFunc(f.expr, walk)
	} else {
		if f.seq.By != nil {
			for _, fld := range f.seq.By.Fields {
				f.addField(fld)
			}
		}
		for _, expr := range f.seq.Expressions {
			ql.WalkFunc(expr.Expr, walk)
			if expr.By == nil {
				continue
			}
			for _, fld := range expr.By.Fields {
				f.addField(fld)
			}
		}
	}
	if len(f.fields) == 0 && !f.hasFunctions {
		return ErrNoFields
	}

	// only retain accessors for declared filter fields
	f.narrowAccessors()

	return f.checkBoundRefs()
}

func (f *filter) Run(e *event.Event) bool {
	if f.expr == nil {
		return false
	}
	return ql.Eval(f.expr, f.mapValuer(e), f.hasFunctions)
}

// evalBoundSequence evaluates the sequence with bound fields
// and returns true if the sequence expression matches or false
// otherwise.
func (f *filter) evalBoundSequence(
	e *event.Event,
	seqID int,
	expr *ql.SequenceExpr,
	partials map[int][]*event.Event,
	valuer ql.MapValuer,
) bool {
	//  map all partials to their sequence aliases
	maxSlots := len(partials[seqID])
	aliasEvents := make(map[string][]*event.Event, seqID)
	for i := range seqID {
		alias := f.seq.Expressions[i].Alias
		if alias == "" {
			continue
		}
		aliasEvents[alias] = partials[i]
		if l := len(partials[i]); l > maxSlots {
			maxSlots = l
		}
	}

	// retrieve or compute bound fields for this sequence expression
	flds, ok := f.seqBoundFields[seqID]
	if !ok {
		flds = f.addSeqBoundFields(seqID, expr.BoundFields)
	}

	// iterate slot-by-slot across all bound aliases
	for slot := 0; slot < maxSlots; slot++ {
		// process each bound field in this sequence expression
		var evt *event.Event
		for _, fld := range flds {
			evts := aliasEvents[fld.BoundVar]
			switch {
			case len(evts) == 0:
				continue
			case slot >= len(evts):
				// pick the latest event if all
				// events for this slot are consumed
				evt = evts[len(evts)-1]
			default:
				evt = evts[slot]
			}

			// extract bound variable value
			accessor := fld.Accessor(f)
			if accessor == nil {
				continue
			}
			v, err := accessor.Get(fld.Field, evt)
			if v == nil || err != nil {
				if v == nil {
					valuer[fld.Value] = defaultAccessorValue(fld.Field)
				}
				if err != nil && !errs.IsParamNotFound(err) {
					valuer[fld.Value] = defaultAccessorValue(fld.Field)
					accessorErrors.Add(err.Error(), 1)
				}
				continue
			}
			valuer[fld.Value] = v
		}

		// evaluate the expression with the current valuer state
		if ql.Eval(expr.Expr, valuer, f.hasFunctions) {
			// compute sequence key hash to stich events
			values := make([]any, 0)
			for _, fld := range flds {
				if !strings.HasPrefix(fld.BoundVar, "$") {
					continue
				}
				values = append(values, valuer[fld.Value])
			}
			hash := hashFields(values)
			e.AddSequenceLink(hash)
			evt.AddSequenceLink(hash)
			return true
		}
	}

	return false
}

// evalSequence evaluates the sequence with one, multiple or
// no join links. The sequence link is first consulted for the
// global sequence definition, and if it is not defined then
// the expression sequence link is used.
func (f *filter) evalSequence(
	e *event.Event,
	seqID int,
	expr *ql.SequenceExpr,
	partials map[int][]*event.Event,
	valuer ql.MapValuer,
) bool {
	// top-level sequence link is defined
	by := f.seq.By
	if by == nil {
		// otherwise, use the expression link
		by = expr.By
	}

	var match bool
	if seqID >= 1 && by != nil {
		linkID := makeSequenceLinkID(valuer, by)
		// traverse upstream partials for join equality
		joins := make([]bool, seqID)
	outer:
		for i := range seqID {
			for _, p := range partials[i] {
				if CompareSeqLink(linkID, p.SequenceLinks()) {
					joins[i] = true
					continue outer
				}
			}
		}
		match = joinsEqual(joins) && ql.Eval(expr.Expr, valuer, f.hasFunctions)
	} else {
		match = ql.Eval(expr.Expr, valuer, f.hasFunctions)
	}

	if match && by != nil {
		e.AddSequenceLink(makeSequenceLinkID(valuer, by))
	}

	return match
}

func (f *filter) RunSequence(e *event.Event, seqID int, partials map[int][]*event.Event, rawMatch bool) bool {
	if f.seq == nil {
		return false
	}
	nseqs := len(f.seq.Expressions)
	if seqID > nseqs-1 {
		return false
	}
	valuer := f.mapValuer(e)
	defer valuerPool.Put(valuer)
	expr := f.seq.Expressions[seqID]

	if rawMatch {
		// only check if the condition matches
		// without evaluating joins/bound fields
		return ql.Eval(expr.Expr, valuer, f.hasFunctions)
	}

	var match bool
	if seqID >= 1 && expr.HasBoundFields() {
		// evaluate bound field driven sequences
		match = f.evalBoundSequence(e, seqID, &expr, partials, valuer)
	} else {
		// evaluate constrained/unconstrained sequences
		match = f.evalSequence(e, seqID, &expr, partials, valuer)
	}

	return match
}

func (f *filter) GetStringFields() map[fields.Field][]string { return f.stringFields }
func (f *filter) GetFields() []Field                         { return f.fields }

func (f *filter) IsSequence() bool          { return f.seq != nil }
func (f *filter) GetSequence() *ql.Sequence { return f.seq }

// InterpolateFields replaces all occurrences of field modifiers in the given string
// with values extracted from the event. Field modifiers may contain a leading ordinal
// which refers to the event in particular sequence stage. Otherwise, the modifier is
// a well-known field name prepended with the `%` symbol.
func InterpolateFields(s string, evts []*event.Event) string {
	var fieldsReplRegexp = regexp.MustCompile(`%([1-9]?)\.?([a-z0-9A-Z\[\]._]+)`)
	matches := fieldsReplRegexp.FindAllStringSubmatch(s, -1)
	r := s
	if len(matches) == 0 {
		return s
	}

	split := func(s string) (string, string) {
		n, m := strings.Index(s, "["), strings.Index(s, "]")
		if n < 0 || m < 0 {
			return s, ""
		}
		if n > m {
			return s, ""
		}
		return s[0:n], s[n+1 : m]
	}

	for _, m := range matches {
		switch {
		case len(m) == 3:
			// parse index if the field modifier
			// refers to the event in the sequence
			i := 1
			if m[1] != "" {
				var err error
				i, err = strconv.Atoi(m[1])
				if err != nil {
					continue
				}
			}
			if i-1 > len(evts)-1 {
				continue
			}
			evt := evts[i-1]
			// extract field value from the event and replace in string
			var val any
			for _, accessor := range GetAccessors() {
				name, arg := split(m[2])
				f := Field{Value: m[2], Name: fields.Field(name), Arg: arg}
				var err error
				val, err = accessor.Get(f, evt)
				if err != nil {
					continue
				}
				if val != nil {
					break
				}
			}
			if val != nil {
				r = strings.ReplaceAll(r, m[0], fmt.Sprintf("%v", val))
			} else {
				r = strings.ReplaceAll(r, m[0], "N/A")
			}
		default:
			return r
		}
	}
	return r
}

var valuerPool = sync.Pool{
	New: func() any {
		return make(map[string]any)
	},
}

// mapValuer for each field present in the AST, we run the
// accessors and extract the field values that are
// supplied to the valuer. The valuer feeds the
// expression with correct values.
func (f *filter) mapValuer(evt *event.Event) map[string]any {
	valuer := valuerPool.Get().(map[string]any)
	for _, field := range f.fields {
		for _, accessor := range f.accessors {
			if !accessor.IsFieldAccessible(evt) {
				continue
			}
			v, err := accessor.Get(field, evt)
			if v == nil || err != nil {
				if v == nil {
					valuer[field.Value] = defaultAccessorValue(field)
				}
				if err != nil && !errs.IsParamNotFound(err) {
					valuer[field.Value] = defaultAccessorValue(field)
					accessorErrors.Add(err.Error(), 1)
				}
				continue
			}
			valuer[field.Value] = v
			break
		}
	}
	return valuer
}

// addField appends a new field to the filter fields list.
func (f *filter) addField(field *ql.FieldLiteral) {
	for _, f := range f.fields {
		if f.Value == field.Value {
			return
		}
	}
	f.fields = append(f.fields, Field{Value: field.Value, Name: field.Field, Arg: field.Arg})
}

// addStringFields appends values for all string field expressions.
func (f *filter) addStringFields(field fields.Field, expr ql.Expr) {
	switch v := expr.(type) {
	case *ql.StringLiteral:
		f.stringFields[field] = append(f.stringFields[field], v.Value)
	case *ql.ListLiteral:
		f.stringFields[field] = append(f.stringFields[field], v.Values...)
	}
}

// addBoundField appends a new bound field.
func (f *filter) addBoundField(field *ql.BoundFieldLiteral) {
	f.boundFields = append(f.boundFields, field)
}

// addSegment adds a new bound segment.
func (f *filter) addSegment(segment *ql.BoundSegmentLiteral) {
	f.segments = append(f.segments, segment.Segment)
}

// addSeqBoundFields receives the sequence id and the list of bound field literals
// and populates the list of bound fields containing the field structure convenient
// for accessors.
func (f *filter) addSeqBoundFields(seqID int, fields []*ql.BoundFieldLiteral) []BoundField {
	flds := make([]BoundField, 0, len(fields))
	for _, field := range fields {
		flds = append(flds,
			BoundField{
				Field:    Field{Name: field.Field.Field, Value: field.Field.Value, Arg: field.Field.Arg},
				Value:    field.Value,
				BoundVar: field.BoundVar.Value,
			})
	}
	f.seqBoundFields[seqID] = flds
	return flds
}

// checkBoundRefs checks if the bound field is referencing a valid alias.
// If no valid alias is reference, this method returns an error specifying
// an incorrect alias reference.
func (f *filter) checkBoundRefs() error {
	if f.seq == nil {
		return nil
	}

	aliases := make(map[string]bool)
	for _, expr := range f.seq.Expressions {
		if expr.Alias == "" {
			continue
		}
		aliases[expr.Alias] = true
	}

	for _, field := range f.boundFields {
		if _, ok := aliases[field.BoundVar.Value]; !ok {
			return fmt.Errorf("%s bound field references "+
				"an invalid '$%s' event alias",
				field.String(), field.BoundVar.Value)
		}
	}

	return nil
}

func makeSequenceLinkID(valuer ql.MapValuer, link *ql.SequenceLink) any {
	if !link.IsCompound() {
		return valuer[link.First()]
	}
	values := make([]any, 0, len(link.Fields))
	for _, fld := range link.Fields {
		values = append(values, valuer[fld.Value])
	}
	return hashFields(values)
}

```

`pkg/filter/filter_test.go`:

```go
/*
 * Copyright 2019-2020 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package filter

import (
	"fmt"
	"net"
	"os"
	"path/filepath"
	"testing"
	"time"
	"unsafe"

	"github.com/rabbitstack/fibratus/internal/etw/processors"
	"github.com/rabbitstack/fibratus/internal/evasion"
	"github.com/rabbitstack/fibratus/pkg/callstack"
	"github.com/rabbitstack/fibratus/pkg/config"
	"github.com/rabbitstack/fibratus/pkg/event"
	"github.com/rabbitstack/fibratus/pkg/event/params"
	"github.com/rabbitstack/fibratus/pkg/filter/fields"
	"github.com/rabbitstack/fibratus/pkg/filter/ql"
	"github.com/rabbitstack/fibratus/pkg/fs"
	"github.com/rabbitstack/fibratus/pkg/pe"
	"github.com/rabbitstack/fibratus/pkg/ps"
	pstypes "github.com/rabbitstack/fibratus/pkg/ps/types"
	"github.com/rabbitstack/fibratus/pkg/sys"
	"github.com/rabbitstack/fibratus/pkg/util/signature"
	"github.com/rabbitstack/fibratus/pkg/util/va"
	log "github.com/sirupsen/logrus"
	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/require"
	"golang.org/x/sys/windows"
)

var cfg = &config.Config{
	EventSource: config.EventSourceConfig{
		EnableHandleEvents:     true,
		EnableNetEvents:        true,
		EnableRegistryEvents:   true,
		EnableFileIOEvents:     true,
		EnableImageEvents:      true,
		EnableThreadEvents:     true,
		EnableMemEvents:        true,
		EnableDNSEvents:        true,
		EnableThreadpoolEvents: true,
	},
	Filters: &config.Filters{},
	PE:      pe.Config{Enabled: true},
}

func TestFilterCompile(t *testing.T) {
	f := New(`ps.name = 'cmd.exe'`, cfg)
	require.NoError(t, f.Compile())
	f = New(`'cmd.exe'`, cfg)
	require.EqualError(t, f.Compile(), "expected at least one field or operator but zero found")
	f = New(`ps.name`, cfg)
	require.EqualError(t, f.Compile(), "expected at least one field or operator but zero found")
	f = New(`pe.is_exec`, cfg)
	require.NoError(t, f.Compile())
	f = New(`length(pe.imphash) > 0`, cfg)
	require.NoError(t, f.Compile())
	f = New(`ps.name =`, cfg)
	require.EqualError(t, f.Compile(), "ps.name =\n╭─────────^\n|\n|\n╰─────────────────── expected field, bound field, string, number, bool, ip, function")
}

func TestSeqFilterCompile(t *testing.T) {
	f := New(`sequence
|evt.name = 'CreateProcess'| by ps.exe
|evt.name = 'CreateFile' and file.operation = 'create'| by file.name
`, cfg)
	require.NoError(t, f.Compile())
	require.NotNil(t, f.GetSequence())
	assert.Len(t, f.GetSequence().Expressions, 2)
	assert.NotNil(t, f.GetSequence().Expressions[0].By)
	assert.True(t, len(f.GetStringFields()) > 0)
}

func TestSeqFilterInvalidBoundRefs(t *testing.T) {
	f := New(`sequence
|evt.name = 'CreateProcess'| as e1
|evt.name = 'CreateFile' and file.name = $e.ps.exe |
`, cfg)
	require.Error(t, f.Compile())
	f1 := New(`sequence
|evt.name = 'CreateProcess'| as e1
|evt.name = 'CreateFile' and file.name = $e1.ps.exe |
`, cfg)
	require.NoError(t, f1.Compile())
}

func TestStringFields(t *testing.T) {
	f := New(`ps.name = 'cmd.exe' and evt.name = 'CreateProcess' or evt.name in ('TerminateProcess', 'CreateFile')`, cfg)
	require.NoError(t, f.Compile())
	assert.Len(t, f.GetStringFields(), 2)
	assert.Len(t, f.GetStringFields()[fields.EvtName], 3)
	assert.Len(t, f.GetStringFields()[fields.PsName], 1)
}

func TestMakeSequenceLinkID(t *testing.T) {
	var tests = []struct {
		valuer  ql.MapValuer
		seqLink *ql.SequenceLink
		id      any
	}{
		{ql.MapValuer{
			"ps.uuid": uint64(123232454234232132),
			"ps.exe":  "C:\\Windows\\System32\\cmd.exe"},
			&ql.SequenceLink{Fields: []*ql.FieldLiteral{{Value: "ps.exe"}, {Value: "ps.uuid"}}},
			"433a5c57696e646f77735c53797374656d33325c636d642e65786544556ea343cfb501",
		},
		{ql.MapValuer{
			"ps.uuid":        uint64(123232454234232132),
			"module.address": uint64(0xfff32343)},
			&ql.SequenceLink{Fields: []*ql.FieldLiteral{{Value: "ps.uuid"}, {Value: "module.address"}}},
			"44556ea343cfb5014323f3ff00000000",
		},
		{ql.MapValuer{
			"ps.uuid": uint64(123232454234232132),
			"ps.exe":  "C:\\Windows\\System32\\cmd.exe"},
			&ql.SequenceLink{Fields: []*ql.FieldLiteral{{Value: "ps.exe"}}},
			"C:\\Windows\\System32\\cmd.exe",
		},
		{ql.MapValuer{
			"ps.uuid": uint64(123232454234232132),
			"ps.exe":  "C:\\Windows\\System32\\cmd.exe"},
			&ql.SequenceLink{Fields: []*ql.FieldLiteral{{Value: "ps.uuid"}}},
			uint64(123232454234232132),
		},
	}

	for _, tt := range tests {
		t.Run(fmt.Sprintf("%v", tt.valuer), func(t *testing.T) {
			assert.Equal(t, tt.id, makeSequenceLinkID(tt.valuer, tt.seqLink))
		})
	}
}

func TestProcFilter(t *testing.T) {
	parent := &pstypes.PS{
		Name:     "svchost.exe",
		Cmdline:  "C:\\Windows\\system32\\svchost.exe -k RPCSS",
		Username: "SYSTEM",
		Domain:   "NT AUTHORITY",
		SID:      "S-1-5-18",
		PID:      5042,
		Parent: &pstypes.PS{
			Name: "services.exe",
			SID:  "S-1-5-8",
			PID:  2034,
			Parent: &pstypes.PS{
				Name: "csrss.exe",
			},
		},
		IsWOW64:             false,
		IsProtected:         true,
		IsPackaged:          false,
		TokenIntegrityLevel: "SYSTEM",
		IsTokenElevated:     false,
		TokenElevationType:  "DEFAULT",
	}

	evt := &event.Event{
		Type:     event.CreateProcess,
		Category: event.Process,
		Params: event.Params{
			params.Cmdline:                    {Name: params.Cmdline, Type: params.UnicodeString, Value: "C:\\Windows\\system32\\svchost.exe -k DcomLaunch -p -s LSM"},
			params.ProcessName:                {Name: params.ProcessName, Type: params.AnsiString, Value: "svchost.exe"},
			params.ProcessID:                  {Name: params.ProcessID, Type: params.PID, Value: uint32(1234)},
			params.ProcessParentID:            {Name: params.ProcessParentID, Type: params.PID, Value: uint32(345)},
			params.UserSID:                    {Name: params.UserSID, Type: params.WbemSID, Value: []byte{224, 8, 226, 31, 15, 167, 255, 255, 0, 0, 0, 0, 15, 167, 255, 255, 1, 1, 0, 0, 0, 0, 0, 5, 18, 0, 0, 0}},
			params.Username:                   {Name: params.Username, Type: params.UnicodeString, Value: "SYSTEM"},
			params.Domain:                     {Name: params.Domain, Type: params.UnicodeString, Value: "NT AUTHORITY"},
			params.ProcessFlags:               {Name: params.ProcessFlags, Type: params.Flags, Value: uint32(0x000000E)},
			params.ProcessTokenIntegrityLevel: {Name: params.ProcessTokenIntegrityLevel, Type: params.AnsiString, Value: "SYSTEM"},
			params.ProcessTokenIsElevated:     {Name: params.ProcessTokenIsElevated, Type: params.Bool, Value: true},
			params.ProcessTokenElevationType:  {Name: params.ProcessTokenElevationType, Type: params.AnsiString, Value: "DEFAULT"},
		},
		Name: "CreateProcess",
		PID:  1234,
		PS: &pstypes.PS{
			Name:     "svchost.exe",
			Cmdline:  "C:\\Windows\\System32\\svchost.exe -k DcomLaunch -p -s LSM",
			Parent:   parent,
			PID:      1234,
			Ppid:     345,
			Username: "SYSTEM",
			Domain:   "NT AUTHORITY",
			SID:      "S-1-5-18",
			Args:     []string{"-k", "DcomLaunch", "-p", "-s", "LSM"},
			Envs:     map[string]string{"ALLUSERSPROFILE": "C:\\ProgramData", "OS": "Windows_NT", "ProgramFiles(x86)": "C:\\Program Files (x86)"},
			Modules: []pstypes.Module{
				{Name: "C:\\Windows\\System32\\kernel32.dll", Size: 12354, Checksum: 23123343, BaseAddress: va.Address(4294066175), DefaultBaseAddress: va.Address(4293993725)},
				{Name: "C:\\Windows\\System32\\user32.dll", Size: 212354, Checksum: 33123343, BaseAddress: va.Address(4277288959), DefaultBaseAddress: va.Address(4293993725)},
			},
			Threads: map[uint32]pstypes.Thread{
				3453: {Tid: 3453, StartAddress: va.Address(144229524944769), IOPrio: 2, PagePrio: 5, KstackBase: va.Address(18446677035730165760), KstackLimit: va.Address(18446677035730137088), UstackLimit: va.Address(86376448), UstackBase: va.Address(86372352)},
				3455: {Tid: 3455, StartAddress: va.Address(140729524944768), IOPrio: 3, PagePrio: 5, KstackBase: va.Address(18446687035730165760), KstackLimit: va.Address(18446698035730165760), UstackLimit: va.Address(86376448), UstackBase: va.Address(46375352)},
			},
			Mmaps: []pstypes.Mmap{
				{Size: 34545, BaseAddress: va.Address(144229524944769), Protection: 4653056, File: "C:\\Windows\\System32\\ucrtbase.dll", Type: "IMAGE"}, //EXECUTE_READWRITE|READONLY
				{Size: 4096, BaseAddress: va.Address(145229445447666), Protection: 12845056, Type: "PAGEFILE"},                                           // READWRITE 12845056
			},
			IsProtected:         false,
			IsPackaged:          true,
			IsWOW64:             false,
			TokenIntegrityLevel: "SYSTEM",
			IsTokenElevated:     true,
			TokenElevationType:  "DEFAULT",
		},
	}
	evt.Timestamp, _ = time.Parse(time.RFC3339, "2011-05-03T15:04:05.323Z")

	evt1 := &event.Event{
		Type:     event.OpenProcess,
		Category: event.Process,
		Params: event.Params{
			params.DesiredAccess: {Name: params.DesiredAccess, Type: params.Flags, Value: uint32(0x1400), Flags: event.PsAccessRightFlags},
		},
		Name: "OpenProcess",
		PID:  1023,
		PS: &pstypes.PS{
			Name:   "svchost.exe",
			Parent: parent,
			Ppid:   345,
			Envs:   map[string]string{"ALLUSERSPROFILE": "C:\\ProgramData", "OS": "Windows_NT", "ProgramFiles(x86)": "C:\\Program Files (x86)"},
			Modules: []pstypes.Module{
				{Name: "C:\\Windows\\System32\\kernel32.dll", Size: 12354, Checksum: 23123343, BaseAddress: va.Address(4294066175), DefaultBaseAddress: va.Address(4293993725)},
				{Name: "C:\\Windows\\System32\\user32.dll", Size: 212354, Checksum: 33123343, BaseAddress: va.Address(4277288959), DefaultBaseAddress: va.Address(4293993725)},
			},
		},
	}

	evt2 := &event.Event{
		Type:     event.OpenProcess,
		Category: event.Process,
		Params: event.Params{
			params.DesiredAccess: {Name: params.DesiredAccess, Type: params.Flags, Value: uint32(0x1400), Flags: event.PsAccessRightFlags},
		},
		Name: "OpenProcess",
		PID:  1023,
	}

	var tests = []struct {
		filter  string
		matches bool
	}{

		{`ps.name = 'svchost.exe'`, true},
		{`ps.name = 'svchot.exe'`, false},
		{`ps.name = 'csrss.exe' or ps.name contains 'svc'`, true},
		{`ps.name ~= 'SVCHOST.exe'`, true},
		{`ps.parent.cmdline = 'C:\\Windows\\system32\\svchost.exe -k RPCSS'`, true},
		{`ps.cmdline = 'C:\\Windows\\System32\\svchost.exe -k DcomLaunch -p -s LSM'`, true},
		{`ps.username = 'SYSTEM'`, true},
		{`ps.domain = 'NT AUTHORITY'`, true},
		{`ps.sid = 'S-1-5-18'`, true},
		{`ps.pid = 1234`, true},
		{`ps.parent.sid = 'S-1-5-18'`, true},
		{`ps.uuid > 0`, true},
		{`ps.parent.name = 'svchost.exe'`, true},
		{`ps.parent.pid = 5042`, true},
		{`ps.parent.username = 'SYSTEM'`, true},
		{`ps.parent.domain = 'NT AUTHORITY'`, true},
		{`ps.envs[ALLUSERSPROFILE] = 'C:\\ProgramData'`, true},
		{`ps.envs[ALLUSER] = 'C:\\ProgramData'`, true},
		{`ps.envs[ProgramFiles] = 'C:\\Program Files (x86)'`, true},
		{`ps.envs[windir] = 'C:\\WINDOWS'`, false},
		{`ps.envs in ('ALLUSERSPROFILE:C:\\ProgramData')`, true},
		{`foreach(ps.envs, $env, substr($env, 0, indexof($env, ':')) = 'OS')`, true},

		{`ps.is_wow64`, false},
		{`ps.is_packaged`, true},
		{`ps.is_protected`, false},
		{`ps.parent.is_wow64`, false},
		{`ps.parent.is_packaged`, false},
		{`ps.parent.is_protected`, true},
		{`ps.token.integrity_level = 'SYSTEM'`, true},
		{`ps.token.is_elevated = true`, true},
		{`ps.token.elevation_type = 'DEFAULT'`, true},
		{`ps.token.integrity_level = 'SYSTEM'`, true},
		{`ps.token.is_elevated = true`, true},
		{`ps.parent.token.integrity_level = 'SYSTEM'`, true},
		{`ps.parent.token.is_elevated = false`, true},
		{`ps.parent.token.elevation_type = 'DEFAULT'`, true},

		{`evt.name = 'CreateProcess' and ps.name contains 'svchost'`, true},

		{`ps.modules IN ('C:\\Windows\\System32\\kernel32.dll')`, true},
		{`evt.name = 'CreateProcess' and evt.pid != ps.ppid`, true},
		{`ps.parent.name = 'svchost.exe'`, true},
		{`count(ps.modules, '*.dll') >= 2`, true},

		{`ps.ancestor[0] = 'svchost.exe'`, true},
		{`ps.ancestor[0] = 'csrss.exe'`, false},
		{`ps.ancestor[1] = 'services.exe'`, true},
		{`ps.ancestor[2] = 'csrss.exe'`, true},
		{`ps.ancestor[3] = ''`, true},
		{`ps.ancestor intersects ('csrss.exe', 'services.exe', 'svchost.exe')`, true},
		{`count(ps.ancestor, '*.exe') = 3`, true},

		{`foreach(ps._ancestors, $proc, $proc.name in ('csrss.exe', 'services.exe', 'System'))`, true},
		{`foreach(ps._ancestors, $proc, $proc.name in ('csrss.exe', 'services.exe', 'System') and ps.is_packaged, ps.is_packaged)`, true},
		{`foreach(ps._ancestors, $proc, $proc.name not in ('svchost.exe', 'WmiPrvSE.exe'))`, true},
		{`foreach(ps._ancestors, $proc, $proc.sid = 'S-1-5-8'))`, true},
		{`foreach(ps._ancestors, $proc, $proc.name endswith 'ices.exe'))`, true},
		{`foreach(ps._ancestors, $proc, $proc.pid in (2034, 343) and $proc.name = 'services.exe')`, true},
		{`foreach(ps._ancestors, $proc, $proc.username = 'SYSTEM')`, true},
		{`foreach(ps._ancestors, $proc, $proc.domain = 'NT AUTHORITY')`, true},
		{`foreach(ps._ancestors, $proc, $proc.username = upper('system'))`, true},
		{`foreach(ps._ancestors, $proc, $proc.token.integrity_level = 'SYSTEM' and $proc.token.is_elevated = false and $proc.token.elevation_type = 'DEFAULT')`, true},

		{`ps.args intersects ('-k', 'DcomLaunch')`, true},
		{`ps.args intersects ('-w', 'DcomLaunch')`, false},
		{`ps.args iintersects ('-K', 'DComLaunch')`, true},
		{`ps.args iintersects ('-W', 'DcomLaunch')`, false},

		{`foreach(ps.modules, $mod, $mod imatches '?:\\*\\us?r32.dll')`, true},
		{`foreach(ps._modules, $mod, $mod.path imatches '?:\\Windows\\System32\\us?r32.dll')`, true},
		{`foreach(ps._modules, $mod, $mod.name imatches 'USER32.*')`, true},
		{`foreach(ps._modules, $mod, $mod.name imatches 'USER32.*' and $mod.size >= 212354)`, true},
		{`foreach(ps._modules, $mod, ($mod.name imatches 'USER32.*' and $mod.size >= 212354) or $mod.name imatches '*winhttp.dll')`, true},
		{`foreach(ps._modules, $mod, ($mod.name imatches 'winhttp.dll' and $mod.size >= 11212354) or $mod.name matches 'user32.dll')`, true},
		{`foreach(ps._modules, $mod, $mod.checksum = 23123343)`, true},
		{`foreach(ps._modules, $mod, $mod.address = 'fff23fff')`, true},

		{`foreach(ps._threads, $t, $t.start_address = '7ffe2557ff80')`, true},
		{`foreach(ps._threads, $t, $t.start_address = '7ffe2557ff80' or $t.user_stack_base = '2251760466')`, true},
		{`foreach(ps._threads, $t, $t.tid = 3453)`, true},
		{`foreach(ps._threads, $t, $t.start_address = '7ffe2557ff80' or $t.user_stack_base = '2251760466')`, true},
		{`foreach(ps._threads, $t, $t.kernel_stack_base = 'ffffcc1fcf800000' and $t.kernel_stack_limit = 'ffffd620f297b000')`, true},

		{`foreach(ps._mmaps, $mmap, $mmap.protection = 'RW')`, true},
		{`foreach(ps._mmaps, $mmap, $mmap.path = 'C:\\Windows\\System32\\ucrtbase.dll' and $mmap.type = 'IMAGE')`, true},
		{`foreach(ps._mmaps, $mmap, $mmap.address = '8415dd81bff2')`, true},
		{`foreach(ps._mmaps, $mmap, $mmap.size = 4096)`, true},
	}

	psnap := new(ps.SnapshotterMock)
	psnap.On("FindAndPut", uint32(1234)).Return(parent)

	for i, tt := range tests {
		f := New(tt.filter, cfg, WithPSnapshotter(psnap))
		err := f.Compile()
		if err != nil {
			t.Fatal(err)
		}
		matches := f.Run(evt)
		if matches != tt.matches {
			t.Errorf("%d. %q ps filter mismatch: exp=%t got=%t", i, tt.filter, tt.matches, matches)
		}
	}

	var tests1 = []struct {
		filter  string
		matches bool
	}{

		{`ps.access.mask.names in ('QUERY_INFORMATION', 'QUERY_LIMITED_INFORMATION')`, true},
		{`ps.access.mask.names in ('ALL_ACCESS')`, false},
	}

	for i, tt := range tests1 {
		f := New(tt.filter, cfg)
		err := f.Compile()
		if err != nil {
			t.Fatal(err)
		}
		matches := f.Run(evt1)
		if matches != tt.matches {
			t.Errorf("%d. %q ps filter mismatch: exp=%t got=%t", i, tt.filter, tt.matches, matches)
		}
	}

	var tests2 = []struct {
		filter  string
		matches bool
	}{

		{`ps.exe = ''`, true},
	}

	for i, tt := range tests2 {
		f := New(tt.filter, cfg)
		err := f.Compile()
		if err != nil {
			t.Fatal(err)
		}
		matches := f.Run(evt2)
		if matches != tt.matches {
			t.Errorf("%d. %q ps filter mismatch: exp=%t got=%t", i, tt.filter, tt.matches, matches)
		}
	}
}

func TestThreadFilter(t *testing.T) {
	pars := event.Params{
		params.ProcessID:          {Name: params.ProcessID, Type: params.PID, Value: uint32(os.Getpid())},
		params.ThreadID:           {Name: params.ThreadID, Type: params.TID, Value: uint32(3453)},
		params.BasePrio:           {Name: params.BasePrio, Type: params.Uint8, Value: uint8(13)},
		params.StartAddress:       {Name: params.StartAddress, Type: params.Address, Value: uint64(140729524944768)},
		params.TEB:                {Name: params.TEB, Type: params.Address, Value: uint64(614994620416)},
		params.IOPrio:             {Name: params.IOPrio, Type: params.Uint8, Value: uint8(2)},
		params.KstackBase:         {Name: params.KstackBase, Type: params.Address, Value: uint64(18446677035730165760)},
		params.KstackLimit:        {Name: params.KstackLimit, Type: params.Address, Value: uint64(18446677035730137088)},
		params.PagePrio:           {Name: params.PagePrio, Type: params.Uint8, Value: uint8(5)},
		params.UstackBase:         {Name: params.UstackBase, Type: params.Address, Value: uint64(86376448)},
		params.UstackLimit:        {Name: params.UstackLimit, Type: params.Address, Value: uint64(86372352)},
		params.StartAddressSymbol: {Name: params.StartAddressSymbol, Type: params.UnicodeString, Value: "LoadImage"},
		params.StartAddressModule: {Name: params.StartAddressModule, Type: params.UnicodeString, Value: "C:\\Windows\\System32\\kernel32.dll"},
	}
	evt := &event.Event{
		Type:     event.CreateThread,
		Params:   pars,
		Name:     "CreateThread",
		PID:      windows.GetCurrentProcessId(),
		Category: event.Thread,
		PS: &pstypes.PS{
			Name: "svchost.exe",
			Envs: map[string]string{"ALLUSERSPROFILE": "C:\\ProgramData", "OS": "Windows_NT", "ProgramFiles(x86)": "C:\\Program Files (x86)"},
			Modules: []pstypes.Module{
				{Name: "C:\\Windows\\System32\\kernel32.dll", Size: 2312354, Checksum: 23123343, BaseAddress: va.Address(0x7ffb5c1d0396), DefaultBaseAddress: va.Address(0x7ffb5c1d0396)},
				{Name: "C:\\Windows\\System32\\user32.dll", Size: 32212354, Checksum: 33123343, BaseAddress: va.Address(0x7ffb313953b2), DefaultBaseAddress: va.Address(0x7ffb313953b2)},
				{Name: "C:\\Program Files\\JetBrains\\GoLand 2021.2.3\\jbr\\bin\\java.dll", Size: 32212354, Checksum: 33123343, BaseAddress: va.Address(0x7ffb3138592e), DefaultBaseAddress: va.Address(0x7ffb3138592e)},
			},
		},
	}

	// append the module signature
	cert := &sys.Cert{Subject: "US, Washington, Redmond, Microsoft Corporation, Microsoft Windows", Issuer: "US, Washington, Redmond, Microsoft Corporation, Microsoft Windows Production PCA 2011"}
	signature.GetSignatures().PutSignature(0x7ffb3138592e, &signature.Signature{Filename: "C:\\Program Files\\JetBrains\\GoLand 2021.2.3\\jbr\\bin\\java.dll", Level: 4, Type: 1, Cert: cert})

	// simulate unbacked RWX frame
	base, err := windows.VirtualAlloc(0, 1024, windows.MEM_COMMIT|windows.MEM_RESERVE, windows.PAGE_EXECUTE_READWRITE)
	require.NoError(t, err)
	defer func() {
		_ = windows.VirtualFree(base, 1024, windows.MEM_DECOMMIT)
	}()
	insns := []byte{
		0x4C, 0x8B, 0xD1, // mov r10, rcx
		0xB8, 0x55, 0x0, 0x0, 0x0, // mov eax, 55h
		0xF6, 0x04, 0x25, 0x08, 0x03, 0xFE, 0x7F, 0x01, // test byte ptr[7FFE0308h]
		0x0F, 0x05, // syscall
		0xC3, // ret
	}
	require.NoError(t, windows.WriteProcessMemory(windows.CurrentProcess(), base, &insns[0], uintptr(len(insns)), nil))

	evt.Callstack.Init(8)
	evt.Callstack.PushFrame(callstack.Frame{PID: evt.PID, Addr: 0x2638e59e0a5, Offset: 0, Symbol: "?", Module: "unbacked"})
	evt.Callstack.PushFrame(callstack.Frame{PID: evt.PID, Addr: va.Address(base), Offset: 0, Symbol: "?", Module: "unbacked"})
	evt.Callstack.PushFrame(callstack.Frame{PID: evt.PID, Addr: 0x7ffb313853b2, Offset: 0x10a, Symbol: "Java_java_lang_ProcessImpl_create", Module: "C:\\Program Files\\JetBrains\\GoLand 2021.2.3\\jbr\\bin\\java.dll"})
	evt.Callstack.PushFrame(callstack.Frame{PID: evt.PID, Addr: 0x7ffb3138592e, ModuleAddress: 0x7ffb3138592e, Offset: 0x3a2, Symbol: "Java_java_lang_ProcessImpl_waitForTimeoutInterruptibly", Module: "C:\\Program Files\\JetBrains\\GoLand 2021.2.3\\jbr\\bin\\java.dll"})
	evt.Callstack.PushFrame(callstack.Frame{PID: evt.PID, Addr: 0x7ffb5d8e61f4, Offset: 0x54, Symbol: "CreateProcessW", Module: "C:\\WINDOWS\\System32\\KERNEL32.DLL"})
	evt.Callstack.PushFrame(callstack.Frame{PID: evt.PID, Addr: 0x7ffb5c1d0396, Offset: 0x66, Symbol: "CreateProcessW", Module: "C:\\WINDOWS\\System32\\KERNELBASE.dll"})
	evt.Callstack.PushFrame(callstack.Frame{PID: evt.PID, Addr: 0xfffff8072ebc1f6f, Offset: 0x4ef, Symbol: "FltRequestFileInfoOnCreateCompletion", Module: "C:\\WINDOWS\\System32\\drivers\\FLTMGR.SYS"})
	evt.Callstack.PushFrame(callstack.Frame{PID: evt.PID, Addr: 0xfffff8072eb8961b, Offset: 0x20cb, Symbol: "FltGetStreamContext", Module: "C:\\WINDOWS\\System32\\drivers\\FLTMGR.SYS"})

	var tests = []struct {
		filter  string
		matches bool
	}{

		{`thread.ustack.base = '5260000'`, true},
		{`thread.ustack.limit = '525f000'`, true},
		{`thread.kstack.base = 'ffffc307810d6000'`, true},
		{`thread.kstack.limit = 'ffffc307810cf000'`, true},
		{`thread.start_address = '7ffe2557ff80'`, true},
		{`thread.teb_address = '8f30893000'`, true},
		{`thread.start_address.symbol = 'LoadImage'`, true},
		{`thread.start_address.module = 'C:\\Windows\\System32\\kernel32.dll'`, true},
		{`thread.callstack.summary = 'KERNELBASE.dll|KERNEL32.DLL|java.dll|unbacked'`, true},
		{`thread.callstack.detail icontains 'C:\\WINDOWS\\System32\\KERNELBASE.dll!CreateProcessW+0x66'`, true},
		{`thread.callstack.modules in ('C:\\WINDOWS\\System32\\KERNELBASE.dll', 'C:\\Program Files\\JetBrains\\GoLand 2021.2.3\\jbr\\bin\\java.dll')`, true},
		{`thread.callstack.modules[5] = 'C:\\WINDOWS\\System32\\KERNELBASE.dll'`, true},
		{`thread.callstack.modules[7] = 'C:\\WINDOWS\\System32\\drivers\\FLTMGR.SYS'`, true},
		{`thread.callstack.modules[8] = ''`, true},
		{`thread.callstack.symbols imatches ('KERNELBASE.dll!CreateProcess*', 'Java_java_lang_ProcessImpl_create')`, true},
		{`thread.callstack.symbols[2] = 'Java_java_lang_ProcessImpl_create'`, true},
		{`thread.callstack.symbols[8] = ''`, true},
		{`thread.callstack.protections in ('RWX')`, true},
		{`thread.callstack.allocation_sizes > 0`, false},
		{`length(thread.callstack.callsite_leading_assembly) > 0`, true},
		{`thread.callstack.callsite_trailing_assembly matches ('*mov r10, rcx|mov eax, 0x*|syscall*')`, true},
		{`thread.callstack.is_unbacked`, true},
		{`thread.callstack.addresses intersects ('7ffb5d8e61f4', 'fffff8072eb8961b')`, true},
		{`thread.callstack.final_user_module.name = 'java.dll'`, true},
		{`thread.callstack.final_user_module.path = 'C:\\Program Files\\JetBrains\\GoLand 2021.2.3\\jbr\\bin\\java.dll'`, true},
		{`thread.callstack.final_user_symbol.name = 'Java_java_lang_ProcessImpl_waitForTimeoutInterruptibly'`, true},
		{`thread.callstack.final_kernel_module.name = 'FLTMGR.SYS'`, true},
		{`thread.callstack.final_kernel_module.path = 'C:\\WINDOWS\\System32\\drivers\\FLTMGR.SYS'`, true},
		{`thread.callstack.final_kernel_symbol.name = 'FltGetStreamContext'`, true},
		{`thread.callstack.final_user_module.signature.exists = true`, true},
		{`thread.callstack.final_user_module.signature.trusted = true`, true},
		{`thread.callstack.final_user_module.signature.issuer imatches '*Microsoft Corporation*'`, true},
		{`thread.callstack.final_user_module.signature.subject imatches '*Microsoft Windows*'`, true},

		{`foreach(thread._callstack, $frame, $frame.address = '2638e59e0a5' or $frame.address = '7ffb5c1d0396')`, true},
		{`foreach(thread._callstack, $frame, $frame.address = 'fffff8072ebc1f6f' or $frame.address = 'fffff8072eb8961b')`, true},
		{`foreach(thread._callstack, $frame, $frame.address = 'ffffffffff')`, false},
		{`foreach(thread._callstack, $frame, $frame.symbol imatches '?:\\Program Files\\*java.dll!Java_java_lang_ProcessImpl_create')`, true},
		{`foreach(thread._callstack, $frame, $frame.symbol imatches '*CreateProcessW')`, true},
		{`foreach(thread._callstack, $frame, $frame.module = 'C:\\Program Files\\JetBrains\\GoLand 2021.2.3\\jbr\\bin\\java.dll')`, true},
		{`foreach(thread._callstack, $frame, base($frame.module) = 'java.dll' and $frame.symbol imatches '*Java_java_lang_ProcessImpl_create')`, true},
		{`foreach(thread._callstack, $frame, $frame.offset = 266)`, true},
		{`foreach(thread._callstack, $frame, $frame.is_unbacked = true)`, true},
		{`ps.name = 'svchost.exe' and not foreach(thread._callstack, $frame, $frame.symbol imatches '*LoadLibrary')`, true},
		{`foreach(thread._callstack, $frame, $frame.allocation_size = 0)`, true},
		{`foreach(thread._callstack, $frame, $frame.protection = 'RWX')`, true},
		{`foreach(thread._callstack, $frame, $frame.callsite_trailing_assembly matches '*mov r10, rcx|mov eax, 0x*|syscall*' and $frame.module = 'unbacked')`, true},
		{`foreach(thread._callstack, $frame, $frame.module.signature.exists and $frame.module.signature.trusted)`, true},
		{`foreach(thread._callstack, $frame, $frame.module.signature.issuer imatches '*Microsoft Corporation*')`, true},
		{`foreach(thread._callstack, $frame, $frame.module.signature.subject imatches '*Microsoft Windows*')`, true},
	}

	for i, tt := range tests {
		f := New(tt.filter, cfg)
		err := f.Compile()
		if err != nil {
			t.Fatal(err)
		}
		matches := f.Run(evt)
		if matches != tt.matches {
			t.Errorf("%d. %q thread filter mismatch: exp=%t got=%t", i, tt.filter, tt.matches, matches)
		}
	}

	// spawn a new process
	var si windows.StartupInfo
	si.Flags = windows.STARTF_USESHOWWINDOW
	var pi windows.ProcessInformation

	argv := windows.StringToUTF16Ptr(filepath.Join(os.Getenv("windir"), "regedit.exe"))

	err = windows.CreateProcess(
		nil,
		argv,
		nil,
		nil,
		true,
		0,
		nil,
		nil,
		&si,
		&pi)
	require.NoError(t, err)

	for {
		if sys.IsProcessRunning(pi.Process) {
			break
		}
		time.Sleep(time.Millisecond * 100)
		log.Infof("%d pid not yet ready", pi.ProcessId)
	}
	defer windows.TerminateProcess(pi.Process, 0)

	evt.PID = pi.ProcessId

	// try until a valid address is returned
	// or fail if max attempts are exhausted
	j := 50
	ntdll := getNtdllAddress(pi.ProcessId)
	for ntdll == 0 && j > 0 {
		ntdll = getNtdllAddress(pi.ProcessId)
		time.Sleep(time.Millisecond * 250)
		j--
	}

	// overwrite ntdll address with dummy bytes
	// to reproduce module stomping technique
	var protect uint32
	require.NoError(t, windows.VirtualProtectEx(pi.Process, ntdll, uintptr(len(insns)), windows.PAGE_EXECUTE_READWRITE, &protect))

	var n uintptr
	require.NoError(t, windows.WriteProcessMemory(pi.Process, ntdll, &insns[0], uintptr(len(insns)), &n))

	evt.Callstack[0] = callstack.Frame{PID: evt.PID, Addr: va.Address(ntdll), Offset: 0, Symbol: "?", Module: "C:\\Windows\\System32\\ntdll.dll"}

	var tests1 = []struct {
		filter  string
		matches bool
	}{

		{`thread.callstack.allocation_sizes > 0`, true},
		{`foreach(thread._callstack, $frame, $frame.allocation_size > 2048 and $frame.protection = 'RWXC')`, true},
	}

	for i, tt := range tests1 {
		f := New(tt.filter, cfg)
		err := f.Compile()
		if err != nil {
			t.Fatal(err)
		}
		matches := f.Run(evt)
		if matches != tt.matches {
			t.Errorf("%d. %q thread filter mismatch: exp=%t got=%t", i, tt.filter, tt.matches, matches)
		}
	}
}

func TestFileFilter(t *testing.T) {
	evt := &event.Event{
		Type:        event.CreateFile,
		Tid:         2484,
		PID:         859,
		CPU:         1,
		Seq:         2,
		Name:        "CreateFile",
		Category:    event.File,
		Host:        "archrabbit",
		Description: "Creates or opens a new file, directory, I/O device, pipe, console",
		Params: event.Params{
			params.FileObject:    {Name: params.FileObject, Type: params.Uint64, Value: uint64(12456738026482168384)},
			params.FilePath:      {Name: params.FilePath, Type: params.UnicodeString, Value: "C:\\Windows\\system32\\user32.dll"},
			params.FileType:      {Name: params.FileType, Type: params.AnsiString, Value: "file"},
			params.FileOperation: {Name: params.FileOperation, Type: params.AnsiString, Value: "open"},
		},
		Metadata: map[event.MetadataKey]any{"foo": "bar", "fooz": "barzz"},
	}

	var tests = []struct {
		filter  string
		matches bool
	}{

		{`file.name = 'user32.dll'`, true},
		{`file.path = 'C:\\Windows\\system32\\user32.dll'`, true},
		{`file.extension  = '.dll'`, true},
		{`file.extension not contains '.exe'`, true},
		{`file.extension contains '.exe' or (file.extension contains '.dll' and file.name endswith 'user32.dll')`, true},
		{`file.extension = '.dll' or (file.extension contains '.exe' and file.name endswith 'kernel32.dll')`, true},
		{`file.extension not contains '.exe' and file.extension contains '.dll'`, true},
		{`file.extension not contains '.exe' and file.extension not contains '.com'`, true},
		{`file.extension not contains '.exe' and file.extension not contains '.com' and file.extension not in ('.vba', '.exe')`, true},
		{`file.extension not in ('.exe', '.com')`, true},
		{`file.extension not in ('.exe', '.dll')`, false},
		{`file.path matches 'C:\\*\\user32.dll'`, true},
		{`file.path not matches 'C:\\*.exe'`, true},
		{`file.path imatches 'C:\\*\\USER32.dll'`, true},
		{`file.path matches ('C:\\*\\user3?.dll', 'C:\\*\\user32.*')`, true},
		{`file.path contains ('C:\\Windows\\system32\\kernel32.dll', 'C:\\Windows\\system32\\user32.dll')`, true},
		{`file.path not matches ('C:\\*.exe', 'C:\\Windows\\*.com')`, true},
		{`file.path endswith ('.exe', 'kernel32.dll', 'user32.dll')`, true},
		{`file.path iendswith ('.EXE', 'KERNEL32.dll', 'user32.dll')`, true},
		{`file.path istartswith ('C:\\WINDOWS', 'KERNEL32.dll', 'user32.dll')`, true},
		{`file.path iin ('C:\\WINDOWS\\system32\\user32.dll')`, true},
		{`file.path fuzzy 'C:\\Windows\\system32\\ser3ll'`, true},
		{`file.path ifuzzy 'C:\\WINDOWS\\sYS\\ser3ll'`, true},
		{`file.path ifuzzy 'C:\\WINDOWS\\sYS\\32dll'`, true},
		{`file.path fuzzy ('C:\\Windows\\system32\\kernel', 'C:\\Windows\\system32\\ser3ll')`, true},
		{`file.path ifuzzynorm 'C:\\WINDOWS\\sÝS\\32dll'`, true},
		{`file.path.stem = 'C:\\Windows\\system32\\user32'`, true},
		{`base(file.path) = 'user32.dll'`, true},
		{`ext(base(file.path)) = '.dll'`, true},
		{`base(file.path, false) = 'user32'`, true},
		{`dir(file.path) = 'C:\\Windows\\system32'`, true},
		{`ext(file.path) = '.dll'`, true},
		{`ext(file.path, false) = 'dll'`, true},
		{`is_abs(file.path)`, true},
		{`is_abs(base(file.path))`, false},
		{`file.path iin glob('C:\\Windows\\System32\\*.dll')`, true},
		{`volume(file.path) = 'C:'`, true},
	}

	for i, tt := range tests {
		f := New(tt.filter, cfg)
		err := f.Compile()
		if err != nil {
			t.Fatal(err)
		}
		matches := f.Run(evt)
		if matches != tt.matches {
			t.Errorf("%d. %q file filter mismatch: exp=%t got=%t", i, tt.filter, tt.matches, matches)
		}
	}
}

func TestFileInfoFilter(t *testing.T) {
	var tests = []struct {
		f       string
		e       *event.Event
		matches bool
	}{
		{
			`file.info_class = 'Allocation'`,
			&event.Event{
				Category: event.File,
				Type:     event.SetFileInformation,
				Name:     "SetFileInformation",
				Params: event.Params{
					params.FileInfoClass: {Name: params.FileInfoClass, Type: params.Enum, Value: fs.AllocationClass, Enum: fs.FileInfoClasses},
				},
			},
			true,
		},
		{
			`file.info.allocation_size = 64500`,
			&event.Event{
				Category: event.File,
				Type:     event.SetFileInformation,
				Name:     "SetFileInformation",
				Params: event.Params{
					params.FileInfoClass: {Name: params.FileInfoClass, Type: params.Enum, Value: fs.AllocationClass, Enum: fs.FileInfoClasses},
					params.FileExtraInfo: {Name: params.FileExtraInfo, Type: params.Uint64, Value: uint64(64500)},
				},
			},
			true,
		},
		{
			`file.info.eof_size = 64500`,
			&event.Event{
				Category: event.File,
				Type:     event.SetFileInformation,
				Name:     "SetFileInformation",
				Params: event.Params{
					params.FileInfoClass: {Name: params.FileInfoClass, Type: params.Enum, Value: fs.EOFClass, Enum: fs.FileInfoClasses},
					params.FileExtraInfo: {Name: params.FileExtraInfo, Type: params.Uint64, Value: uint64(64500)},
				},
			},
			true,
		},
		{
			`file.info.eof_size = 64500`,
			&event.Event{
				Category: event.File,
				Type:     event.SetFileInformation,
				Name:     "SetFileInformation",
				Params: event.Params{
					params.FileInfoClass: {Name: params.FileInfoClass, Type: params.Enum, Value: fs.DispositionClass, Enum: fs.FileInfoClasses},
					params.FileExtraInfo: {Name: params.FileExtraInfo, Type: params.Uint64, Value: uint64(1)},
				},
			},
			false,
		},
		{
			`file.info.is_disposition_delete_file = true`,
			&event.Event{
				Category: event.File,
				Type:     event.DeleteFile,
				Name:     "DeleteFile",
				Params: event.Params{
					params.FileInfoClass: {Name: params.FileInfoClass, Type: params.Enum, Value: fs.DispositionClass, Enum: fs.FileInfoClasses},
					params.FileExtraInfo: {Name: params.FileExtraInfo, Type: params.Uint64, Value: uint64(1)},
				},
			},
			true,
		},
	}

	for _, tt := range tests {
		t.Run(tt.f, func(t *testing.T) {
			f := New(tt.f, cfg)
			err := f.Compile()
			if err != nil {
				t.Fatal(err)
			}
			assert.Equal(t, tt.matches, f.Run(tt.e))
		})
	}
}

func TestEventFilter(t *testing.T) {
	evt := &event.Event{
		Type:        event.CreateFile,
		Tid:         2484,
		PID:         859,
		CPU:         1,
		Seq:         2,
		Name:        "CreateFile",
		Category:    event.File,
		Host:        "archrabbit",
		Description: "Creates or opens a new file, directory, I/O device, pipe, console",
		Evasions:    uint32(evasion.IndirectSyscall),
		Params: event.Params{
			params.ProcessID:     {Name: params.ProcessID, Type: params.PID, Value: uint32(3434)},
			params.FileObject:    {Name: params.FileObject, Type: params.Uint64, Value: uint64(12456738026482168384)},
			params.FilePath:      {Name: params.FilePath, Type: params.UnicodeString, Value: "\\Device\\HarddiskVolume2\\Windows\\system32\\user32.dll"},
			params.FileType:      {Name: params.FileType, Type: params.AnsiString, Value: "file"},
			params.FileOperation: {Name: params.FileOperation, Type: params.AnsiString, Value: "open"},
		},
		Metadata: map[event.MetadataKey]any{"foo": "bar", "fooz": "barz"},
	}

	evt.Timestamp, _ = time.Parse(time.RFC3339, "2011-05-03T15:04:05.323Z")

	var tests = []struct {
		filter  string
		matches bool
	}{

		{`evt.seq = 2`, true},
		{`evt.pid = 859`, true},
		{`evt.tid = 2484`, true},
		{`evt.cpu = 1`, true},
		{`evt.name = 'CreateFile'`, true},
		{`evt.category = 'file'`, true},
		{`evt.host = 'archrabbit'`, true},
		{`evt.nparams = 5`, true},
		{`evt.arg[file_path] = '\\Device\\HarddiskVolume2\\Windows\\system32\\user32.dll'`, true},
		{`evt.arg[type] = 'file'`, true},
		{`evt.arg[pid] = 3434`, true},
		{`evt.is_direct_syscall = false`, true},
		{`evt.is_indirect_syscall`, true},

		{`evt.desc contains 'Creates or opens a new file'`, true},

		{`evt.date.d = 3 AND evt.date.m = 5 AND evt.time.s = 5 AND evt.time.m = 4 and evt.time.h = 15`, true},
		{`evt.time = '15:04:05'`, true},
		{`concat(evt.name, evt.host, evt.nparams) = 'CreateFilearchrabbit5'`, true},
		{`ltrim(evt.host, 'arch') = 'rabbit'`, true},
		{`concat(ltrim(evt.name, 'Create'), evt.host) = 'Filearchrabbit'`, true},
		{`lower(rtrim(evt.name, 'File')) = 'create'`, true},
		{`upper(rtrim(evt.name, 'File')) = 'CREATE'`, true},
		{`replace(evt.host, 'rabbit', '_bunny') = 'arch_bunny'`, true},
		{`replace(evt.host, 'rabbit', '_bunny', '_bunny', 'bunny') = 'archbunny'`, true},
		{`split(file.path, '\\') IN ('windows', 'system32')`, true},
		{`length(file.path) = 51`, true},
		{`indexof(file.path, '\\') = 0`, true},
		{`indexof(file.path, '\\', 'last') = 40`, true},
		{`indexof(file.path, 'h2', 'any') = 22`, true},
		{`substr(file.path, indexof(file.path, '\\'), indexof(file.path, '\\Hard')) = '\\Device'`, true},
		{`substr(evt.desc, indexof(evt.desc, '\\'), indexof(evt.desc, 'NOT')) = 'Creates or opens a new file, directory, I/O device, pipe, console'`, true},
		{`entropy(file.path) > 120`, true},
		{`regex(file.path, '\\\\Device\\\\HarddiskVolume[2-9]+\\\\.*')`, true},
	}

	for i, tt := range tests {
		f := New(tt.filter, cfg)
		err := f.Compile()
		if err != nil {
			t.Fatal(err)
		}
		matches := f.Run(evt)
		if matches != tt.matches {
			t.Errorf("%d. %q evt filter mismatch: exp=%t got=%t", i, tt.filter, tt.matches, matches)
		}
	}
}

func TestNetFilter(t *testing.T) {
	evt := &event.Event{
		Type: event.SendTCPv4,
		Tid:  2484,
		PID:  859,
		PS: &pstypes.PS{
			Name: "cmd.exe",
		},
		Category: event.Net,
		Params: event.Params{
			params.NetDport: {Name: params.NetDport, Type: params.Uint16, Value: uint16(443)},
			params.NetSport: {Name: params.NetSport, Type: params.Uint16, Value: uint16(43123)},
			params.NetSIP:   {Name: params.NetSIP, Type: params.IPv4, Value: net.ParseIP("127.0.0.1")},
			params.NetDIP:   {Name: params.NetDIP, Type: params.IPv4, Value: net.ParseIP("216.58.201.174")},
		},
	}

	var tests = []struct {
		filter  string
		matches bool
	}{

		{`net.dip = 216.58.201.174`, true},
		{`net.dip != 216.58.201.174`, false},
		{`net.dip != 116.58.201.174`, true},
		{`net.dip startswith '216.58'`, true},
		{`net.dip endswith '.174'`, true},
		{`net.dport = 443`, true},
		{`net.dport in (123, 443)`, true},
		{`net.dip != 116.58.201.174`, true},
		{`net.dip not in ('116.58.201.172', '16.58.201.176')`, true},
		{`net.dip not in (116.58.201.172, 16.58.201.176)`, true},
		{`ps.name = 'cmd.exe' and not cidr_contains(net.sip, '227.0.0.1/12', '8.2.3.0/4')`, true},
		{`ps.name = 'cmd.exe' and not ((net.sip in (222.1.1.1)) or (net.sip in (12.3.4.5)))`, true},
		{`cidr_contains(net.dip, '216.58.201.1/24') = true`, true},
		{`cidr_contains(net.dip, '226.58.201.1/24') = false`, true},
		{`cidr_contains(net.dip, '216.58.201.1/24', '216.58.201.10/24') = true and evt.pid = 859`, true},
		{`evt.name not in ('CreateProcess', 'Connect') and cidr_contains(net.dip, '216.58.201.1/24') = true`, true},
	}

	for i, tt := range tests {
		f := New(tt.filter, cfg)
		err := f.Compile()
		if err != nil {
			t.Fatal(err)
		}
		matches := f.Run(evt)
		if matches != tt.matches {
			t.Errorf("%d. %q net filter mismatch: exp=%t got=%t", i, tt.filter, tt.matches, matches)
		}
	}

	evt1 := &event.Event{
		Type: event.SendTCPv4,
		Tid:  2484,
		PID:  859,
		PS: &pstypes.PS{
			Name: "cmd.exe",
		},
		Category: event.Net,
		Params: event.Params{
			params.NetDport: {Name: params.NetDport, Type: params.Uint16, Value: uint16(53)},
			params.NetSport: {Name: params.NetSport, Type: params.Uint16, Value: uint16(43123)},
			params.NetSIP:   {Name: params.NetSIP, Type: params.IPv4, Value: net.ParseIP("127.0.0.1")},
			params.NetDIP:   {Name: params.NetDIP, Type: params.IPv4, Value: net.ParseIP("8.8.8.8")},
		},
	}

	var tests1 = []struct {
		filter  string
		matches bool
	}{

		{`net.dip.names in ('dns.google.')`, true},
		{`length(net.sip.names) > 0`, true},
	}

	for i, tt := range tests1 {
		f := New(tt.filter, cfg)
		err := f.Compile()
		if err != nil {
			t.Fatal(err)
		}
		matches := f.Run(evt1)
		if matches != tt.matches {
			t.Errorf("%d. %q net filter mismatch: exp=%t got=%t", i, tt.filter, tt.matches, matches)
		}
	}
}

func TestRegistryFilter(t *testing.T) {
	evt := &event.Event{
		Type:     event.RegSetValue,
		Tid:      2484,
		PID:      859,
		Category: event.Registry,
		Params: event.Params{
			params.RegPath:      {Name: params.RegPath, Type: params.UnicodeString, Value: `HKEY_LOCAL_MACHINE\SYSTEM\Setup\Pid`},
			params.RegData:      {Name: params.RegData, Type: params.Uint32, Value: uint32(10234)},
			params.RegValueType: {Name: params.RegValueType, Type: params.AnsiString, Value: "DWORD"},
			params.NTStatus:     {Name: params.NTStatus, Type: params.AnsiString, Value: "success"},
			params.RegKeyHandle: {Name: params.RegKeyHandle, Type: params.Address, Value: uint64(18446666033449935464)},
		},
	}

	var tests = []struct {
		filter  string
		matches bool
	}{

		{`registry.status startswith ('key not', 'succ')`, true},
		{`registry.path = 'HKEY_LOCAL_MACHINE\\SYSTEM\\Setup\\Pid'`, true},
		{`registry.key.name icontains ('Setup', 'setup')`, true},
		{`registry.value = 'Pid'`, true},
		{`registry.value.type in ('DWORD', 'QWORD')`, true},
		{`registry.data = '10234'`, true},
		{`MD5(registry.path) = 'eab870b2a516206575d2ffa2b98d8af5'`, true},
	}

	for i, tt := range tests {
		f := New(tt.filter, cfg)
		err := f.Compile()
		if err != nil {
			t.Fatal(err)
		}
		matches := f.Run(evt)
		if matches != tt.matches {
			t.Errorf("%d. %q registry filter mismatch: exp=%t got=%t", i, tt.filter, tt.matches, matches)
		}
	}
}

func TestModuleFilter(t *testing.T) {
	e1 := &event.Event{
		Type:     event.LoadImage,
		Category: event.Image,
		Params: event.Params{
			params.ImagePath:           {Name: params.ImagePath, Type: params.UnicodeString, Value: filepath.Join(os.Getenv("windir"), "System32", "kernel32.dll")},
			params.ProcessID:           {Name: params.ProcessID, Type: params.PID, Value: uint32(1023)},
			params.ImageCheckSum:       {Name: params.ImageCheckSum, Type: params.Uint32, Value: uint32(2323432)},
			params.ImageBase:           {Name: params.ImageBase, Type: params.Address, Value: uint64(0x7ffb313833a3)},
			params.ImageSignatureType:  {Name: params.ImageSignatureType, Type: params.Enum, Value: uint32(1), Enum: signature.Types},
			params.ImageSignatureLevel: {Name: params.ImageSignatureLevel, Type: params.Enum, Value: uint32(4), Enum: signature.Levels},
			params.FileIsDotnet:        {Name: params.FileIsDotnet, Type: params.Bool, Value: false},
		},
	}

	var tests = []struct {
		filter  string
		matches bool
	}{

		{`module.signature.type = 'EMBEDDED'`, true},
		{`module.signature.level = 'AUTHENTICODE'`, true},
		{`module.signature.exists`, true},
		{`module.signature.trusted`, true},
		{`module.pid = 1023`, true},
		{`module.path endswith 'System32\\kernel32.dll'`, true},
		{`module.name = 'kernel32.dll'`, true},
		{`module.checksum = 2323432`, true},
		{`module.base = '7ffb313833a3'`, true},
		{`module.signature.issuer icontains 'Microsoft Windows'`, true},
		{`module.signature.subject icontains 'Microsoft Corporation'`, true},
		{`module.pe.is_dotnet`, false},
		{`module.path.stem endswith 'System32\\kernel32'`, true},
		{`dll.path.stem endswith 'System32\\kernel32'`, true},
		{`dll.signature.type = 'EMBEDDED'`, true},
		{`dll.signature.level = 'AUTHENTICODE'`, true},
		{`dll.signature.exists`, true},
		{`dll.signature.trusted`, true},
		{`dll.pid = 1023`, true},
		{`dll.path endswith 'System32\\kernel32.dll'`, true},
		{`dll.name = 'kernel32.dll'`, true},
		{`dll.base = '7ffb313833a3'`, true},
		{`dll.signature.issuer icontains 'Microsoft Windows'`, true},
		{`dll.signature.subject icontains 'Microsoft Corporation'`, true},
		{`dll.pe.is_dotnet`, false},
	}

	for i, tt := range tests {
		f := New(tt.filter, cfg)
		err := f.Compile()
		if err != nil {
			t.Fatal(err)
		}
		matches := f.Run(e1)
		if matches != tt.matches {
			t.Errorf("%d. %q image filter mismatch: exp=%t got=%t", i, tt.filter, tt.matches, matches)
		}
	}

	// check signatures expectations
	sig := signature.GetSignatures().GetSignature(0x7ffb313833a3)
	assert.NotNil(t, sig)
	assert.Equal(t, filepath.Join(os.Getenv("windir"), "System32", "kernel32.dll"), sig.Filename)
	assert.Equal(t, signature.Embedded, sig.Type)
	assert.Equal(t, signature.AuthenticodeLevel, sig.Level)

	// now exercise unsigned/unchecked signature
	e2 := &event.Event{
		Type:     event.LoadImage,
		Category: event.Image,
		Params: event.Params{
			params.ImagePath:           {Name: params.ImagePath, Type: params.UnicodeString, Value: filepath.Join(os.Getenv("windir"), "System32", "kernel32.dll")},
			params.ProcessID:           {Name: params.ProcessID, Type: params.PID, Value: uint32(1023)},
			params.ImageCheckSum:       {Name: params.ImageCheckSum, Type: params.Uint32, Value: uint32(2323432)},
			params.ImageBase:           {Name: params.ImageBase, Type: params.Address, Value: uint64(0x7ccb313833a3)},
			params.ImageSignatureType:  {Name: params.ImageSignatureType, Type: params.Enum, Value: uint32(0), Enum: signature.Types},
			params.ImageSignatureLevel: {Name: params.ImageSignatureLevel, Type: params.Enum, Value: uint32(0), Enum: signature.Levels},
			params.FileIsDotnet:        {Name: params.FileIsDotnet, Type: params.Bool, Value: false},
		},
	}

	var tests1 = []struct {
		filter  string
		matches bool
	}{

		{`module.signature.type = 'EMBEDDED'`, true},
		{`module.signature.level = 'AUTHENTICODE'`, true},
		{`module.signature.exists`, true},
		{`module.signature.trusted`, true},
		{`module.pid = 1023`, true},
		{`module.name endswith 'kernel32.dll'`, true},
		{`module.checksum = 2323432`, true},
		{`module.base = '7ccb313833a3'`, true},
		{`module.signature.issuer icontains 'Microsoft Windows'`, true},
		{`module.signature.subject icontains 'Microsoft Corporation'`, true},
		{`dll.signature.type = 'EMBEDDED'`, true},
		{`dll.signature.level = 'AUTHENTICODE'`, true},
		{`dll.signature.exists`, true},
		{`dll.signature.trusted`, true},
		{`dll.pid = 1023`, true},
		{`dll.name endswith 'kernel32.dll'`, true},
		{`dll.base = '7ccb313833a3'`, true},
		{`dll.signature.issuer icontains 'Microsoft Windows'`, true},
		{`dll.signature.subject icontains 'Microsoft Corporation'`, true},
	}

	for i, tt := range tests1 {
		f := New(tt.filter, cfg)
		err := f.Compile()
		if err != nil {
			t.Fatal(err)
		}
		matches := f.Run(e2)
		if matches != tt.matches {
			t.Errorf("%d. %q image filter mismatch: exp=%t got=%t", i, tt.filter, tt.matches, matches)
		}
	}

	assert.NotNil(t, signature.GetSignatures().GetSignature(0x7ccb313833a3))

	e3 := &event.Event{
		Type:     event.LoadImage,
		Category: event.Image,
		Params: event.Params{
			params.ImagePath:           {Name: params.ImagePath, Type: params.UnicodeString, Value: "C:\\Windows\\System32\\mscorlib.dll"},
			params.ProcessID:           {Name: params.ProcessID, Type: params.PID, Value: uint32(1023)},
			params.ImageCheckSum:       {Name: params.ImageCheckSum, Type: params.Uint32, Value: uint32(2323432)},
			params.ImageBase:           {Name: params.ImageBase, Type: params.Address, Value: uint64(0xfff313833a3)},
			params.ImageSignatureType:  {Name: params.ImageSignatureType, Type: params.Enum, Value: uint32(0), Enum: signature.Types},
			params.ImageSignatureLevel: {Name: params.ImageSignatureLevel, Type: params.Enum, Value: uint32(0), Enum: signature.Levels},
			params.FileIsDotnet:        {Name: params.FileIsDotnet, Type: params.Bool, Value: true},
		},
	}

	var tests2 = []struct {
		filter  string
		matches bool
	}{

		{`module.pid = 1023`, true},
		{`module.name endswith 'mscorlib.dll'`, true},
		{`module.pe.is_dotnet`, true},
		{`dll.pid = 1023`, true},
		{`dll.name endswith 'mscorlib.dll'`, true},
		{`dll.pe.is_dotnet`, true},
	}

	for i, tt := range tests2 {
		f := New(tt.filter, cfg)
		err := f.Compile()
		if err != nil {
			t.Fatal(err)
		}
		matches := f.Run(e3)
		if matches != tt.matches {
			t.Errorf("%d. %q image filter mismatch: exp=%t got=%t", i, tt.filter, tt.matches, matches)
		}
	}
}

func TestPEFilter(t *testing.T) {
	evt := &event.Event{
		PS: &pstypes.PS{
			PE: &pe.PE{
				NumberOfSections: 2,
				NumberOfSymbols:  10,
				EntryPoint:       "20110",
				ImageBase:        "140000000",
				LinkTime:         time.Now(),
				Sections: []pe.Sec{
					{Name: ".text", Size: 132608, Entropy: 6.368381, Md5: "db23dce3911a42e987041d98abd4f7cd"},
					{Name: ".rdata", Size: 35840, Entropy: 5.996976, Md5: "ffa5c960b421ca9887e54966588e97e8"},
				},
				Symbols:          []string{"SelectObject", "GetTextFaceW", "EnumFontsW", "TextOutW", "GetProcessHeap"},
				Imports:          []string{"GDI32.dll", "USER32.dll", "msvcrt.dll", "api-ms-win-core-libraryloader-l1-2-0.dl"},
				VersionResources: map[string]string{"CompanyName": "Microsoft Corporation", "FileDescription": "Notepad", "FileVersion": "10.0.18362.693"},
			},
		},
	}

	var tests = []struct {
		filter  string
		matches bool
	}{

		{`foreach(ps.pe._sections, $section, $section.entropy = 6.368381)`, true},
		{`foreach(ps.pe._sections, $section, $section.entropy > 4.45)`, true},
		{`foreach(ps.pe._sections, $section, $section.name = '.rdata' and $section.entropy < 9.45)`, true},
		{`foreach(ps.pe._sections, $section, $section.size = 132608)`, true},
		{`foreach(ps.pe._sections, $section, $section.md5 = 'ffa5c960b421ca9887e54966588e97e8')`, true},
		{`ps.pe.symbols IN ('GetTextFaceW', 'GetProcessHeap')`, true},
		{`ps.pe.resources[FileDesc] = 'Notepad'`, true},
		{`ps.pe.resources[CompanyName] = 'Microsoft Corporation'`, true},
		{`ps.pe.resources in ('FileDescription:Notepad')`, true},
		{`ps.pe.nsymbols = 10 AND ps.pe.nsections = 2`, true},
		{`ps.pe.nsections > 1`, true},
		{`ps.pe.address.base = '140000000' AND ps.pe.address.entrypoint = '20110'`, true},
	}

	for i, tt := range tests {
		f := New(tt.filter, cfg)
		err := f.Compile()
		if err != nil {
			t.Fatal(err)
		}
		matches := f.Run(evt)
		if matches != tt.matches {
			t.Errorf("%d. %q pe filter mismatch: exp=%t got=%t", i, tt.filter, tt.matches, matches)
		}
	}
}

func TestLazyPEFilter(t *testing.T) {
	evt := &event.Event{
		Type: event.LoadImage,
		PS: &pstypes.PS{
			PID: 2312,
			Exe: filepath.Join(os.Getenv("windir"), "notepad.exe"),
		},
		Params: event.Params{
			params.FileIsDLL: {Name: params.FileIsDLL, Type: params.Bool, Value: true},
			params.FilePath:  {Name: params.FilePath, Type: params.UnicodeString, Value: "C:\\Windows\\system32\\user32.dll"},
		},
	}

	var tests = []struct {
		filter  string
		matches bool
	}{
		{`foreach(ps.pe._sections, $s, $s.entropy > 1.23)`, true},
		{`ps.pe.symbols IN ('GetTextFaceW', 'GetProcessHeap')`, true},
		{`pe.is_dll`, true},
		{`length(ps.pe.imphash) > 0`, true},
		{`ps.pe.is_dotnet`, false},
		{`ps.pe.resources[FileDesc] icontains 'Notepad'`, true},
		{`ps.pe.file.name ~= 'NOTEPAD.EXE'`, true},
		{`ps.pe.nsymbols > 10 AND pe.nsections > 2`, true},
		{`ps.pe.nsections > 1`, true},
		{`length(ps.pe.anomalies) = 0`, true},
		{`ps.signature.exists`, true},
		{`ps.signature.trusted`, true},
		{`ps.signature.subject icontains 'microsoft'`, true},
		{`ps.signature.issuer icontains 'microsoft'`, true},
		{`length(ps.signature.serial) > 0`, true},
	}

	for i, tt := range tests {
		f := New(tt.filter, cfg)
		err := f.Compile()
		if err != nil {
			t.Fatal(err)
		}
		require.Nil(t, evt.PS.PE)
		matches := f.Run(evt)
		if matches != tt.matches {
			t.Errorf("%d. %q pe lazy filter mismatch: exp=%t got=%t", i, tt.filter, tt.matches, matches)
		}
		require.NotNil(t, evt.PS.PE)
		evt.PS.PE = nil
	}
}

func TestMemFilter(t *testing.T) {
	pars := event.Params{
		params.MemRegionSize:  {Name: params.MemRegionSize, Type: params.Uint64, Value: uint64(8192)},
		params.MemBaseAddress: {Name: params.MemBaseAddress, Type: params.Address, Value: uint64(1311246336000)},
		params.MemAllocType:   {Name: params.MemAllocType, Type: params.Flags, Value: uint32(0x00001000 | 0x00002000), Flags: event.MemAllocationFlags},
		params.ProcessID:      {Name: params.ProcessID, Type: params.Uint32, Value: uint32(345)},
		params.MemProtect:     {Name: params.MemProtect, Type: params.Flags, Value: uint32(0x40), Flags: event.MemProtectionFlags},
		params.MemProtectMask: {Name: params.MemProtectMask, Type: params.AnsiString, Value: "RWX"},
		params.MemPageType:    {Name: params.MemPageType, Type: params.Enum, Value: uint32(0x1000000), Enum: processors.MemPageTypes},
	}

	evt := &event.Event{
		Type:     event.VirtualAlloc,
		Params:   pars,
		Name:     "VirtualAlloc",
		Category: event.Mem,
		PS: &pstypes.PS{
			Name: "svchost.exe",
			Envs: map[string]string{"ALLUSERSPROFILE": "C:\\ProgramData", "OS": "Windows_NT", "ProgramFiles(x86)": "C:\\Program Files (x86)"},
		},
	}

	var tests = []struct {
		filter  string
		matches bool
	}{

		{`mem.size = 8192`, true},
		{`mem.address = 1311246336000`, true},
		{`mem.type = 'IMAGE'`, true},
		{`mem.size = 8192`, true},
		{`mem.alloc = 'COMMIT|RESERVE'`, true},
		{`mem.protection = 'EXECUTE_READWRITE'`, true},
		{`mem.protection.mask = 'RWX'`, true},
	}

	for i, tt := range tests {
		f := New(tt.filter, cfg)
		err := f.Compile()
		if err != nil {
			t.Fatal(err)
		}
		matches := f.Run(evt)
		if matches != tt.matches {
			t.Errorf("%d. %q mem filter mismatch: exp=%t got=%t", i, tt.filter, tt.matches, matches)
		}
	}
}

func TestDNSFilter(t *testing.T) {
	evt := &event.Event{
		Type: event.ReplyDNS,
		Tid:  2484,
		PID:  859,
		PS: &pstypes.PS{
			Name: "cmd.exe",
		},
		Category: event.Net,
		Params: event.Params{
			params.DNSName:    {Name: params.DNSName, Type: params.UnicodeString, Value: "r3.o.lencr.org"},
			params.DNSRR:      {Name: params.DNSRR, Type: params.Enum, Value: uint32(0x0001), Enum: event.DNSRecordTypes},
			params.DNSOpts:    {Name: params.DNSOpts, Type: params.Flags64, Value: uint64(0x00006000), Flags: event.DNSOptsFlags},
			params.DNSRcode:   {Name: params.DNSRcode, Type: params.Enum, Value: uint32(0), Enum: event.DNSResponseCodes},
			params.DNSAnswers: {Name: params.DNSAnswers, Type: params.Slice, Value: []string{"incoming.telemetry.mozilla.org", "a1887.dscq.akamai.net"}},
		},
	}

	var tests = []struct {
		filter  string
		matches bool
	}{

		{`dns.name = 'r3.o.lencr.org'`, true},
		{`dns.rr = 'A'`, true},
		{`dns.options in ('ADDRCONFIG', 'DUAL_ADDR')`, true},
		{`dns.rcode = 'NOERROR'`, true},
		{`dns.answers in ('incoming.telemetry.mozilla.org')`, true},
	}

	for i, tt := range tests {
		f := New(tt.filter, cfg)
		err := f.Compile()
		if err != nil {
			t.Fatal(err)
		}
		matches := f.Run(evt)
		if matches != tt.matches {
			t.Errorf("%d. %q dns filter mismatch: exp=%t got=%t", i, tt.filter, tt.matches, matches)
		}
	}
}

func TestThreadpoolFilter(t *testing.T) {
	e := &event.Event{
		Type:      event.SubmitThreadpoolCallback,
		Tid:       2484,
		PID:       1023,
		CPU:       1,
		Seq:       2,
		Name:      "SubmitThreadpoolCallback",
		Timestamp: time.Now(),
		Category:  event.Threadpool,
		Params: event.Params{
			params.ThreadpoolPoolID:           {Name: params.ThreadpoolPoolID, Type: params.Address, Value: uint64(0x20f5fc02440)},
			params.ThreadpoolTaskID:           {Name: params.ThreadpoolTaskID, Type: params.Address, Value: uint64(0x20f7ecd21f8)},
			params.ThreadpoolCallback:         {Name: params.ThreadpoolCallback, Type: params.Address, Value: uint64(0x7ffb3138592e)},
			params.ThreadpoolContext:          {Name: params.ThreadpoolContext, Type: params.Address, Value: uint64(0x14d0d16fed8)},
			params.ThreadpoolContextRip:       {Name: params.ThreadpoolContextRip, Type: params.Address, Value: uint64(0x143c9b07bd0)},
			params.ThreadpoolSubprocessTag:    {Name: params.ThreadpoolSubprocessTag, Type: params.Address, Value: uint64(0x10d)},
			params.ThreadpoolContextRipSymbol: {Name: params.ThreadpoolContextRipSymbol, Type: params.UnicodeString, Value: "VirtualProtect"},
			params.ThreadpoolContextRipModule: {Name: params.ThreadpoolContextRipModule, Type: params.UnicodeString, Value: "C:\\Windows\\System32\\kernelbase.dll"},
			params.ThreadpoolCallbackSymbol:   {Name: params.ThreadpoolCallbackSymbol, Type: params.UnicodeString, Value: "RtlDestroyQueryDebugBuffer"},
			params.ThreadpoolCallbackModule:   {Name: params.ThreadpoolCallbackModule, Type: params.UnicodeString, Value: "C:\\Windows\\System32\\ntdll.dll"},
			params.ThreadpoolTimerSubqueue:    {Name: params.ThreadpoolTimerSubqueue, Type: params.Address, Value: uint64(0x1db401703e8)},
			params.ThreadpoolTimerDuetime:     {Name: params.ThreadpoolTimerDuetime, Type: params.Uint64, Value: uint64(18446744073699551616)},
			params.ThreadpoolTimer:            {Name: params.ThreadpoolTimer, Type: params.Address, Value: uint64(0x3e8)},
			params.ThreadpoolTimerPeriod:      {Name: params.ThreadpoolTimerPeriod, Type: params.Uint32, Value: uint32(100)},
			params.ThreadpoolTimerWindow:      {Name: params.ThreadpoolTimerWindow, Type: params.Uint32, Value: uint32(50)},
			params.ThreadpoolTimerAbsolute:    {Name: params.ThreadpoolTimerAbsolute, Type: params.Bool, Value: true},
		},
	}

	var tests = []struct {
		filter  string
		matches bool
	}{

		{`threadpool.id = '20f5fc02440'`, true},
		{`threadpool.task.id = '20f7ecd21f8'`, true},
		{`threadpool.callback.address = '7ffb3138592e'`, true},
		{`threadpool.callback.symbol = 'RtlDestroyQueryDebugBuffer'`, true},
		{`threadpool.callback.module = 'C:\\Windows\\System32\\ntdll.dll'`, true},
		{`threadpool.callback.context = '14d0d16fed8'`, true},
		{`threadpool.callback.context.rip = '143c9b07bd0'`, true},
		{`threadpool.callback.context.rip.symbol = 'VirtualProtect'`, true},
		{`threadpool.callback.context.rip.module = 'C:\\Windows\\System32\\kernelbase.dll'`, true},
		{`threadpool.timer.address = '3e8'`, true},
		{`threadpool.timer.subqueue = '1db401703e8'`, true},
		{`threadpool.timer.duetime = 18446744073699551616`, true},
		{`threadpool.timer.period = 100`, true},
		{`threadpool.timer.window = 50`, true},
		{`threadpool.timer.is_absolute = true`, true},
	}

	for i, tt := range tests {
		f := New(tt.filter, cfg)
		err := f.Compile()
		if err != nil {
			t.Fatal(err)
		}
		matches := f.Run(e)
		if matches != tt.matches {
			t.Errorf("%d. %q threadpool filter mismatch: exp=%t got=%t", i, tt.filter, tt.matches, matches)
		}
	}
}

func TestInterpolateFields(t *testing.T) {
	var tests = []struct {
		original     string
		interpolated string
		evts         []*event.Event
	}{
		{
			original:     "Credential discovery via %ps.name (%evt.arg[cmdline]) and user %ps.sid",
			interpolated: "Credential discovery via VaultCmd.exe (VaultCmd.exe /listcreds:Windows Credentials /all) and user LOCAL\\tor",
			evts: []*event.Event{
				{
					Type:     event.CreateProcess,
					Category: event.Process,
					Name:     "CreateProcess",
					PID:      1023,
					PS: &pstypes.PS{
						Name: "VaultCmd.exe",
						Ppid: 345,
						SID:  "LOCAL\\tor",
					},
					Params: event.Params{
						params.Cmdline: {Name: params.Cmdline, Type: params.UnicodeString, Value: `VaultCmd.exe /listcreds:Windows Credentials /all`},
					},
				},
			},
		},
		{
			original:     "Credential discovery via %ps.name and pid %evt.pid",
			interpolated: "Credential discovery via N/A and pid 1023",
			evts: []*event.Event{
				{
					Type:     event.CreateProcess,
					Category: event.Process,
					Name:     "CreateProcess",
					PID:      1023,
				},
			},
		},
		{
			original:     "Suspicious thread start module %thread.start_address.module",
			interpolated: "Suspicious thread start module C:\\Windows\\System32\\vault.dll",
			evts: []*event.Event{
				{
					Type:     event.CreateThread,
					Category: event.Thread,
					Name:     "CreateThread",
					PID:      1023,
					Params: event.Params{
						params.StartAddressModule: {Name: params.StartAddressModule, Type: params.UnicodeString, Value: "C:\\Windows\\System32\\vault.dll"},
					},
				},
			},
		},
		{
			original: `Detected an attempt by <code>%1.ps.name</code> process to access
and read the memory of the <b>Local Security And Authority Subsystem Service</b>
and subsequently write the <code>%2.file.path</code> dump file to the disk device`,
			interpolated: `Detected an attempt by <code>taskmgr.exe</code> process to access
and read the memory of the <b>Local Security And Authority Subsystem Service</b>
and subsequently write the <code>C:\Users
eo\Temp\lsass.dump</code> dump file to the disk device`,
			evts: []*event.Event{
				{
					Type:     event.OpenProcess,
					Category: event.Process,
					Name:     "OpenProcess",
					PID:      1023,
					PS: &pstypes.PS{
						Name: "taskmgr.exe",
						Ppid: 345,
						SID:  "LOCAL\\tor",
					},
				},
				{
					Type:     event.WriteFile,
					Category: event.File,
					Name:     "WriteFile",
					PID:      1023,
					Params: event.Params{
						params.FilePath: {Name: params.FilePath, Type: params.UnicodeString, Value: "C:\\Users\neo\\Temp\\lsass.dump"},
					},
					PS: &pstypes.PS{
						Name: "taskmgr.exe",
						Ppid: 345,
						SID:  "LOCAL\\tor",
					},
				},
			},
		},
		{
			original: `Detected an attempt by <code>%ps.name</code> process to access
and read the memory of the <b>Local Security And Authority Subsystem Service</b>
and subsequently write the <code>%2.file.path</code> dump file to the disk device`,
			interpolated: `Detected an attempt by <code>taskmgr.exe</code> process to access
and read the memory of the <b>Local Security And Authority Subsystem Service</b>
and subsequently write the <code>C:\Users
eo\Temp\lsass.dump</code> dump file to the disk device`,
			evts: []*event.Event{
				{
					Type:     event.OpenProcess,
					Category: event.Process,
					Name:     "OpenProcess",
					PID:      1023,
					PS: &pstypes.PS{
						Name: "taskmgr.exe",
						Ppid: 345,
						SID:  "LOCAL\\tor",
					},
				},
				{
					Type:     event.WriteFile,
					Category: event.File,
					Name:     "WriteFile",
					PID:      1023,
					Params: event.Params{
						params.FilePath: {Name: params.FilePath, Type: params.UnicodeString, Value: "C:\\Users\neo\\Temp\\lsass.dump"},
					},
					PS: &pstypes.PS{
						Name: "taskmgr.exe",
						Ppid: 345,
						SID:  "LOCAL\\tor",
					},
				},
			},
		},
	}

	for _, tt := range tests {
		s := InterpolateFields(tt.original, tt.evts)
		if tt.interpolated != s {
			t.Errorf("expected %s interpolated string but got %s", tt.interpolated, s)
		}
	}
}

func BenchmarkFilterRun(b *testing.B) {
	b.ReportAllocs()
	f := New(`ps.name = 'mimikatz.exe' or ps.name contains 'svc'`, cfg)
	require.NoError(b, f.Compile())

	pars := event.Params{
		params.Cmdline:         {Name: params.Cmdline, Type: params.UnicodeString, Value: "C:\\Windows\\system32\\svchost.exe -k RPCSS"},
		params.ProcessName:     {Name: params.ProcessName, Type: params.AnsiString, Value: "svchost.exe"},
		params.ProcessID:       {Name: params.ProcessID, Type: params.Uint32, Value: uint32(1234)},
		params.ProcessParentID: {Name: params.ProcessParentID, Type: params.Uint32, Value: uint32(345)},
	}

	evt := &event.Event{
		Type:   event.CreateProcess,
		Params: pars,
		Name:   "CreateProcess",
	}

	for i := 0; i < b.N; i++ {
		f.Run(evt)
	}
}

func getNtdllAddress(pid uint32) uintptr {
	var moduleHandles [1024]windows.Handle
	var cbNeeded uint32
	proc, err := windows.OpenProcess(windows.PROCESS_ALL_ACCESS, false, pid)
	if err != nil {
		return 0
	}
	if err := windows.EnumProcessModules(proc, &moduleHandles[0], 1024, &cbNeeded); err != nil {
		return 0
	}
	moduleHandle := moduleHandles[1]
	var moduleInfo windows.ModuleInfo
	if err := windows.GetModuleInformation(proc, moduleHandle, &moduleInfo, uint32(unsafe.Sizeof(moduleInfo))); err != nil {
		return 0
	}
	return moduleInfo.BaseOfDll
}

```

`pkg/filter/filter_windows.go`:

```go
/*
 * Copyright 2020-2021 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package filter

import (
	"fmt"
	"strings"

	"github.com/rabbitstack/fibratus/pkg/config"
	"github.com/rabbitstack/fibratus/pkg/filter/fields"
	"github.com/rabbitstack/fibratus/pkg/filter/ql"
	"github.com/rabbitstack/fibratus/pkg/ps"
)

type opts struct {
	psnap ps.Snapshotter
}

// Option defines the option supplied to the filter
type Option func(o *opts)

// WithPSnapshotter passes a process snapshotter reference to the filter.
func WithPSnapshotter(psnap ps.Snapshotter) Option {
	return func(o *opts) {
		o.psnap = psnap
	}
}

// New creates a new filter with the specified filter expression. The consumers must ensure
// the expression is correctly parsed before executing the filter. This is achieved by calling the
// `Compile` method after constructing the filter.
func New(expr string, config *config.Config, options ...Option) Filter {
	var opts opts
	for _, opt := range options {
		opt(&opts)
	}
	accessors := []Accessor{
		// general event parameters
		newEventAccessor(),
		// process state and parameters
		newPSAccessor(opts.psnap),
		// PE metadata
		newPEAccessor(),
	}

	fconfig := config.Filters

	if config.EventSource.EnableThreadEvents {
		accessors = append(accessors, newThreadAccessor())
	}
	if config.EventSource.EnableImageEvents {
		accessors = append(accessors, newModuleAccessor())
	}
	if config.EventSource.EnableFileIOEvents {
		accessors = append(accessors, newFileAccessor())
	}
	if config.EventSource.EnableRegistryEvents {
		accessors = append(accessors, newRegistryAccessor())
	}
	if config.EventSource.EnableNetEvents {
		accessors = append(accessors, newNetworkAccessor())
	}
	if config.EventSource.EnableHandleEvents {
		accessors = append(accessors, newHandleAccessor())
	}
	if config.EventSource.EnableMemEvents {
		accessors = append(accessors, newMemAccessor())
	}
	if config.EventSource.EnableDNSEvents {
		accessors = append(accessors, newDNSAccessor())
	}
	if config.EventSource.EnableThreadpoolEvents {
		accessors = append(accessors, newThreadpoolAccessor())
	}

	var parser *ql.Parser
	if fconfig.HasMacros() {
		parser = ql.NewParserWithConfig(expr, fconfig)
	} else {
		parser = ql.NewParser(expr)
	}

	return &filter{
		parser:         parser,
		accessors:      accessors,
		fields:         make([]Field, 0),
		segments:       make([]fields.Segment, 0),
		stringFields:   make(map[fields.Field][]string),
		boundFields:    make([]*ql.BoundFieldLiteral, 0),
		seqBoundFields: make(map[int][]BoundField),
	}
}

// NewFromCLI builds and compiles a filter by joining all the command line arguments into the filter expression.
func NewFromCLI(args []string, config *config.Config) (Filter, error) {
	expr := strings.Join(args, " ")
	if expr == "" {
		return nil, nil
	}
	filter := New(expr, config)
	if err := filter.Compile(); err != nil {
		return nil, fmt.Errorf("bad filter:\n%v", err)
	}
	return filter, nil
}

// NewFromCLIWithAllAccessors builds and compiles a filter with all field accessors enabled.
func NewFromCLIWithAllAccessors(args []string) (Filter, error) {
	expr := strings.Join(args, " ")
	if expr == "" {
		return nil, nil
	}
	filter := &filter{
		parser:         ql.NewParser(expr),
		accessors:      GetAccessors(),
		fields:         make([]Field, 0),
		segments:       make([]fields.Segment, 0),
		stringFields:   make(map[fields.Field][]string),
		boundFields:    make([]*ql.BoundFieldLiteral, 0),
		seqBoundFields: make(map[int][]BoundField),
	}
	if err := filter.Compile(); err != nil {
		return nil, fmt.Errorf("bad filter:\n %v", err)
	}
	return filter, nil
}

```

`pkg/filter/ql/ast.go`:

```go
/*
 * Copyright 2019-2020 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 *  Copyright (c) 2013-2016 Errplane Inc.
 */

package ql

import (
	fuzzysearch "github.com/lithammer/fuzzysearch/fuzzy"
	"github.com/rabbitstack/fibratus/pkg/util/sets"
	"github.com/rabbitstack/fibratus/pkg/util/wildcard"
	"net"
	"strconv"
	"strings"
)

// Eval evaluates expr against a map that contains the field values.
func Eval(expr Expr, m map[string]interface{}, useFuncValuer bool) bool {
	var eval ValuerEval
	if useFuncValuer {
		eval = ValuerEval{Valuer: MultiValuer(MapValuer(m), FunctionValuer{m})}
	} else {
		eval = ValuerEval{Valuer: MapValuer(m)}
	}
	v, ok := eval.Eval(expr).(bool)
	if !ok {
		return false
	}
	return v
}

// MapValuer is a valuer that substitutes values for the mapped interface.
type MapValuer map[string]interface{}

// Value returns the value for a key in the MapValuer.
func (m MapValuer) Value(key string) (interface{}, bool) {
	v, ok := m[key]
	return v, ok
}

// Valuer is the interface that wraps the Value() method.
type Valuer interface {
	// Value returns the value and existence flag for a given key.
	Value(key string) (interface{}, bool)
}

// CallValuer implements the Call method for evaluating function calls.
type CallValuer interface {
	Valuer

	// Call is invoked to evaluate a function call (if possible).
	Call(name string, args []interface{}) (interface{}, bool)
}

// MultiValuer returns a Valuer that iterates over multiple Valuer instances
// to find a match.
func MultiValuer(valuers ...Valuer) Valuer {
	return multiValuer(valuers)
}

type multiValuer []Valuer

func (valuers multiValuer) Value(key string) (interface{}, bool) {
	for _, valuer := range valuers {
		if v, ok := valuer.Value(key); ok {
			return v, true
		}
	}
	return nil, false
}

func (valuers multiValuer) Call(name string, args []interface{}) (interface{}, bool) {
	for _, valuer := range valuers {
		if valuer, ok := valuer.(CallValuer); ok {
			if v, ok := valuer.Call(name, args); ok {
				return v, true
			}
		}
	}
	return nil, false
}

// ValuerEval will evaluate an expression using the Valuer.
type ValuerEval struct {
	Valuer Valuer

	// IntegerFloatDivision will set the eval system to treat
	// a division between two integers as a floating point division.
	IntegerFloatDivision bool
}

// Eval evaluates an expression and returns a value.
func (v *ValuerEval) Eval(expr Expr) interface{} {
	if expr == nil {
		return nil
	}

	switch expr := expr.(type) {
	case *BinaryExpr:
		return v.evalBinaryExpr(expr)
	case *NotExpr:
		switch exp := expr.Expr.(type) {
		case *BinaryExpr:
			v := v.evalBinaryExpr(exp)
			if v == nil {
				return nil
			}
			if val, ok := v.(bool); ok {
				return !val
			}
			return nil
		case *Function:
			if valuer, ok := v.Valuer.(CallValuer); ok {
				var args []interface{}

				if len(exp.Args) > 0 {
					args = make([]interface{}, len(exp.Args))

					for i := range exp.Args {
						// foreach function exhibits some corner cases.
						// Instead of evaluating the expression and storing
						// the value in the args slice, it operates on raw
						// binary and unary expressions.
						if exp.IsForeach() {
							switch {
							case exp.IsBinaryExprArg(i) || exp.IsNotExprArg(i) || exp.IsBareBoundVariableArg(i):
								args[i] = exp.Args[i]
							case exp.IsFieldArg(i):
								if i != 0 {
									field := exp.Args[i].(*FieldLiteral)
									// the final argument passed to the function is
									// a map with the key equal to the field name and
									// the value is the result of the map valuer access
									// in the outer context.
									args[i] = MapValuer{field.String(): v.Eval(field)}
								} else {
									// otherwise, this is the slice (iterable) argument
									args[i] = v.Eval(exp.Args[i])
								}
							}
						} else {
							args[i] = v.Eval(exp.Args[i])
						}
					}
				}

				value, _ := valuer.Call(exp.Name, args)
				if value == nil {
					return true
				}
				if val, ok := value.(bool); ok {
					return !val
				}
				return nil
			}
			return nil
		case *ParenExpr:
			v := v.Eval(exp.Expr)
			if v == nil {
				return nil
			}
			if val, ok := v.(bool); ok {
				return !val
			}
			return nil
		case *BoolLiteral:
			return !exp.Value
		default:
			return nil
		}
	case *IntegerLiteral:
		return expr.Value
	case *UnsignedLiteral:
		return expr.Value
	case *DecimalLiteral:
		return expr.Value
	case *ParenExpr:
		return v.Eval(expr.Expr)
	case *StringLiteral:
		return expr.Value
	case *ListLiteral:
		return expr.Values
	case *BoolLiteral:
		return expr.Value
	case *FieldLiteral:
		val, ok := v.Valuer.Value(expr.Value)
		if !ok {
			return nil
		}
		return val
	case *BoundFieldLiteral:
		val, ok := v.Valuer.Value(expr.Value)
		if !ok {
			return nil
		}
		return val
	case *BoundSegmentLiteral:
		val, ok := v.Valuer.Value(expr.Value)
		if !ok {
			return nil
		}
		return val
	case *BareBoundVariableLiteral:
		val, ok := v.Valuer.Value(expr.Value)
		if !ok {
			return nil
		}
		return val
	case *IPLiteral:
		return expr.Value
	case *Function:
		if valuer, ok := v.Valuer.(CallValuer); ok {
			var args []interface{}

			if len(expr.Args) > 0 {
				args = make([]interface{}, len(expr.Args))
				for i := range expr.Args {
					// foreach function exhibits some corner cases.
					// Instead of evaluating the expression and storing
					// the value in the args slice, it operates on raw
					// binary and unary expressions.
					if expr.IsForeach() {
						switch {
						case expr.IsBinaryExprArg(i) || expr.IsNotExprArg(i) || expr.IsBareBoundVariableArg(i):
							args[i] = expr.Args[i]
						case expr.IsFieldArg(i):
							if i != 0 {
								field := expr.Args[i].(*FieldLiteral)
								// the final argument passed to the function is
								// a map with the key equal to the field name and
								// the value is the result of the map valuer access
								// in the outer context.
								args[i] = MapValuer{field.String(): v.Eval(field)}
							} else {
								// otherwise, this is the slice (iterable) argument
								args[i] = v.Eval(expr.Args[i])
							}
						}
					} else {
						args[i] = v.Eval(expr.Args[i])
					}
				}
			}

			val, _ := valuer.Call(expr.Name, args)
			return val
		}
		return nil
	default:
		return nil
	}
}

func (v *ValuerEval) evalBinaryExpr(expr *BinaryExpr) interface{} {
	lhs := v.Eval(expr.LHS)
	// lazy evaluation for the AND/OR operators
	if lhs != nil && expr.Op == And {
		if val, ok := lhs.(bool); ok && !val {
			return false
		}
	}
	if lhs != nil && expr.Op == Or {
		if val, ok := lhs.(bool); ok && val {
			return true
		}
	}
	rhs := v.Eval(expr.RHS)
	if lhs == nil && rhs != nil {
		// when the LHS is nil and the RHS is a boolean, implicitly cast the
		// nil to false.
		if _, ok := rhs.(bool); ok {
			lhs = false
		}
	} else if lhs != nil && rhs == nil {
		// implicit cast of the RHS nil to false when the LHS is a boolean.
		if _, ok := lhs.(bool); ok {
			rhs = false
		}
	}
	// evaluate if both sides are simple types.
	switch lhs := lhs.(type) {
	case bool:
		rhs, ok := rhs.(bool)
		switch expr.Op {
		case And:
			return ok && (lhs && rhs)
		case Or:
			return ok && (lhs || rhs)
		case Eq:
			return ok && (lhs == rhs)
		case Neq:
			return ok && (lhs != rhs)
		}
	case int:
		switch rhs := rhs.(type) {
		case float64:
			lhs := float64(lhs)
			switch expr.Op {
			case Eq:
				return lhs == rhs
			case Neq:
				return lhs != rhs
			case Lt:
				return lhs < rhs
			case Lte:
				return lhs <= rhs
			case Gt:
				return lhs > rhs
			case Gte:
				return lhs >= rhs
			}
		case int64:
			switch expr.Op {
			case Eq:
				return int64(lhs) == rhs
			case Neq:
				return int64(lhs) != rhs
			case Lt:
				return int64(lhs) < rhs
			case Lte:
				return int64(lhs) <= rhs
			case Gt:
				return int64(lhs) > rhs
			case Gte:
				return int64(lhs) >= rhs
			}
		case uint64:
			switch expr.Op {
			case Eq:
				return uint64(lhs) == rhs
			case Neq:
				return uint64(lhs) != rhs
			case Lt:
				if lhs < 0 {
					return true
				}
				return uint64(lhs) < rhs
			case Lte:
				if lhs < 0 {
					return true
				}
				return uint64(lhs) <= rhs
			case Gt:
				if lhs < 0 {
					return false
				}
				return uint64(lhs) > rhs
			case Gte:
				if lhs < 0 {
					return false
				}
				return uint64(lhs) >= rhs
			}
		case []uint16:
			switch expr.Op {
			case In:
				for _, i := range rhs {
					if int(i) == lhs {
						return true
					}
				}
				return false
			}
		}
	case uint8:
		switch rhs := rhs.(type) {
		case float64:
			lhs := float64(lhs)
			switch expr.Op {
			case Eq:
				return lhs == rhs
			case Neq:
				return lhs != rhs
			case Lt:
				return lhs < rhs
			case Lte:
				return lhs <= rhs
			case Gt:
				return lhs > rhs
			case Gte:
				return lhs >= rhs
			}
		case int64:
			switch expr.Op {
			case Eq:
				return int64(lhs) == rhs
			case Neq:
				return int64(lhs) != rhs
			case Lt:
				return int64(lhs) < rhs
			case Lte:
				return int64(lhs) <= rhs
			case Gt:
				return int64(lhs) > rhs
			case Gte:
				return int64(lhs) >= rhs
			}
		case uint64:
			switch expr.Op {
			case Eq:
				return uint64(lhs) == rhs
			case Neq:
				return uint64(lhs) != rhs
			case Lt:
				return uint64(lhs) < rhs
			case Lte:
				return uint64(lhs) <= rhs
			case Gt:
				return uint64(lhs) > rhs
			case Gte:
				return uint64(lhs) >= rhs
			}
		}
	case float64:
		// try the rhs as a float64, int64, or uint64
		rhsf, ok := rhs.(float64)
		if !ok {
			switch val := rhs.(type) {
			case int64:
				rhsf, ok = float64(val), true
			case uint64:
				rhsf, ok = float64(val), true
			}
		}

		rhs := rhsf
		switch expr.Op {
		case Eq:
			return ok && (lhs == rhs)
		case Neq:
			return ok && (lhs != rhs)
		case Lt:
			return ok && (lhs < rhs)
		case Lte:
			return ok && (lhs <= rhs)
		case Gt:
			return ok && (lhs > rhs)
		case Gte:
			return ok && (lhs >= rhs)
		}
	case int64:
		// try as a float64 to see if a float cast is required.
		switch rhs := rhs.(type) {
		case float64:
			lhs := float64(lhs)
			switch expr.Op {
			case Eq:
				return lhs == rhs
			case Neq:
				return lhs != rhs
			case Lt:
				return lhs < rhs
			case Lte:
				return lhs <= rhs
			case Gt:
				return lhs > rhs
			case Gte:
				return lhs >= rhs
			}
		case int64:
			switch expr.Op {
			case Eq:
				return lhs == rhs
			case Neq:
				return lhs != rhs
			case Lt:
				return lhs < rhs
			case Lte:
				return lhs <= rhs
			case Gt:
				return lhs > rhs
			case Gte:
				return lhs >= rhs
			}
		case uint64:
			switch expr.Op {
			case Eq:
				return uint64(lhs) == rhs
			case Neq:
				return uint64(lhs) != rhs
			case Lt:
				if lhs < 0 {
					return true
				}
				return uint64(lhs) < rhs
			case Lte:
				if lhs < 0 {
					return true
				}
				return uint64(lhs) <= rhs
			case Gt:
				if lhs < 0 {
					return false
				}
				return uint64(lhs) > rhs
			case Gte:
				if lhs < 0 {
					return false
				}
				return uint64(lhs) >= rhs
			}
		}
	case uint64:
		// try as a float64 to see if a float cast is required.
		switch rhs := rhs.(type) {
		case float64:
			lhs := float64(lhs)
			switch expr.Op {
			case Eq:
				return lhs == rhs
			case Neq:
				return lhs != rhs
			case Lt:
				return lhs < rhs
			case Lte:
				return lhs <= rhs
			case Gt:
				return lhs > rhs
			case Gte:
				return lhs >= rhs
			}
		case int64:
			switch expr.Op {
			case Eq:
				return lhs == uint64(rhs)
			case Neq:
				return lhs != uint64(rhs)
			case Lt:
				if rhs < 0 {
					return false
				}
				return lhs < uint64(rhs)
			case Lte:
				if rhs < 0 {
					return false
				}
				return lhs <= uint64(rhs)
			case Gt:
				if rhs < 0 {
					return true
				}
				return lhs > uint64(rhs)
			case Gte:
				if rhs < 0 {
					return true
				}
				return lhs >= uint64(rhs)
			}
		case uint64:
			switch expr.Op {
			case Eq:
				return lhs == rhs
			case Neq:
				return lhs != rhs
			case Lt:
				return lhs < rhs
			case Lte:
				return lhs <= rhs
			case Gt:
				return lhs > rhs
			case Gte:
				return lhs >= rhs
			}
		}
	case []uint64:
		switch rhs := rhs.(type) {
		case uint64:
			switch expr.Op {
			case Gt:
				for _, i := range lhs {
					if i > rhs {
						return true
					}
				}
				return false
			case Gte:
				for _, i := range lhs {
					if i >= rhs {
						return true
					}
				}
				return false
			}
		case int64:
			switch expr.Op {
			case Gt:
				for _, i := range lhs {
					if i > uint64(rhs) {
						return true
					}
				}
				return false
			case Gte:
				for _, i := range lhs {
					if i >= uint64(rhs) {
						return true
					}
				}
				return false
			}
		}
	case uint32:
		switch rhs := rhs.(type) {
		case float64:
			lhs := float64(lhs)
			switch expr.Op {
			case Eq:
				return lhs == rhs
			case Neq:
				return lhs != rhs
			case Lt:
				return lhs < rhs
			case Lte:
				return lhs <= rhs
			case Gt:
				return lhs > rhs
			case Gte:
				return lhs >= rhs
			}
		case int32:
			switch expr.Op {
			case Eq:
				return lhs == uint32(rhs)
			case Neq:
				return lhs != uint32(rhs)
			case Lt:
				if rhs < 0 {
					return false
				}
				return lhs < uint32(rhs)
			case Lte:
				if rhs < 0 {
					return false
				}
				return lhs <= uint32(rhs)
			case Gt:
				if rhs < 0 {
					return true
				}
				return lhs > uint32(rhs)
			case Gte:
				if rhs < 0 {
					return true
				}
				return lhs >= uint32(rhs)
			}
		case int64:
			switch expr.Op {
			case Eq:
				return lhs == uint32(rhs)
			case Neq:
				return lhs != uint32(rhs)
			case Lt:
				if rhs < 0 {
					return false
				}
				return lhs < uint32(rhs)
			case Lte:
				if rhs < 0 {
					return false
				}
				return lhs <= uint32(rhs)
			case Gt:
				if rhs < 0 {
					return true
				}
				return lhs > uint32(rhs)
			case Gte:
				if rhs < 0 {
					return true
				}
				return lhs >= uint32(rhs)
			}
		case uint32:
			switch expr.Op {
			case Eq:
				return lhs == rhs
			case Neq:
				return lhs != rhs
			case Lt:
				return lhs < rhs
			case Lte:
				return lhs <= rhs
			case Gt:
				return lhs > rhs
			case Gte:
				return lhs >= rhs
			}
		case []string:
			switch expr.Op {
			case In:
				for _, s := range rhs {
					n, err := strconv.ParseUint(s, 10, 32)
					if err != nil {
						continue
					}
					if uint32(n) == lhs {
						return true
					}
				}
				return false
			}
		}
	case uint16:
		switch rhs := rhs.(type) {
		case float64:
			lhs := float64(lhs)
			switch expr.Op {
			case Eq:
				return lhs == rhs
			case Neq:
				return lhs != rhs
			case Lt:
				return lhs < rhs
			case Lte:
				return lhs <= rhs
			case Gt:
				return lhs > rhs
			case Gte:
				return lhs >= rhs
			}
		case int32:
			switch expr.Op {
			case Eq:
				return lhs == uint16(rhs)
			case Neq:
				return lhs != uint16(rhs)
			case Lt:
				if rhs < 0 {
					return false
				}
				return lhs < uint16(rhs)
			case Lte:
				if rhs < 0 {
					return false
				}
				return lhs <= uint16(rhs)
			case Gt:
				if rhs < 0 {
					return true
				}
				return lhs > uint16(rhs)
			case Gte:
				if rhs < 0 {
					return true
				}
				return lhs >= uint16(rhs)
			}
		case int64:
			switch expr.Op {
			case Eq:
				return lhs == uint16(rhs)
			case Neq:
				return lhs != uint16(rhs)
			case Lt:
				if rhs < 0 {
					return false
				}
				return lhs < uint16(rhs)
			case Lte:
				if rhs < 0 {
					return false
				}
				return lhs <= uint16(rhs)
			case Gt:
				if rhs < 0 {
					return true
				}
				return lhs > uint16(rhs)
			case Gte:
				if rhs < 0 {
					return true
				}
				return lhs >= uint16(rhs)
			}
		case uint16:
			switch expr.Op {
			case Eq:
				return lhs == rhs
			case Neq:
				return lhs != rhs
			case Lt:
				return lhs < rhs
			case Lte:
				return lhs <= rhs
			case Gt:
				return lhs > rhs
			case Gte:
				return lhs >= rhs
			}
		case []string:
			switch expr.Op {
			case In:
				for _, s := range rhs {
					n, err := strconv.Atoi(s)
					if err != nil {
						continue
					}
					if uint16(n) == lhs {
						return true
					}
				}
				return false
			}
		}
	case string:
		switch expr.Op {
		case Eq:
			rhs, ok := rhs.(string)
			if !ok {
				return false
			}
			return lhs == rhs
		case IEq:
			rhs, ok := rhs.(string)
			if !ok {
				return false
			}
			return strings.EqualFold(lhs, rhs)
		case Neq:
			rhs, ok := rhs.(string)
			if !ok {
				return false
			}
			return lhs != rhs
		case Contains:
			switch rhs := rhs.(type) {
			case string:
				return strings.Contains(lhs, rhs)
			case []string:
				for _, s := range rhs {
					if strings.Contains(lhs, s) {
						return true
					}
				}
				return false
			default:
				return false
			}
		case IContains:
			switch rhs := rhs.(type) {
			case string:
				return strings.Contains(strings.ToLower(lhs), strings.ToLower(rhs))
			case []string:
				for _, s := range rhs {
					if strings.Contains(strings.ToLower(lhs), strings.ToLower(s)) {
						return true
					}
				}
				return false
			default:
				return false
			}
		case In:
			rhs, ok := rhs.([]string)
			if !ok {
				return false
			}
			for _, i := range rhs {
				if i == lhs {
					return true
				}
			}
			return false
		case IIn:
			rhs, ok := rhs.([]string)
			if !ok {
				return false
			}
			for _, i := range rhs {
				if strings.EqualFold(i, lhs) {
					return true
				}
			}
			return false
		case Startswith:
			switch rhs := rhs.(type) {
			case string:
				return strings.HasPrefix(lhs, rhs)
			case []string:
				for _, s := range rhs {
					if strings.HasPrefix(lhs, s) {
						return true
					}
				}
				return false
			default:
				return false
			}
		case IStartswith:
			switch rhs := rhs.(type) {
			case string:
				return strings.HasPrefix(strings.ToLower(lhs), strings.ToLower(rhs))
			case []string:
				for _, s := range rhs {
					if strings.HasPrefix(strings.ToLower(lhs), strings.ToLower(s)) {
						return true
					}
				}
				return false
			default:
				return false
			}
		case Endswith:
			switch rhs := rhs.(type) {
			case string:
				return strings.HasSuffix(lhs, rhs)
			case []string:
				for _, s := range rhs {
					if strings.HasSuffix(lhs, s) {
						return true
					}
				}
				return false
			default:
				return false
			}
		case IEndswith:
			switch rhs := rhs.(type) {
			case string:
				return strings.HasSuffix(strings.ToLower(lhs), strings.ToLower(rhs))
			case []string:
				for _, s := range rhs {
					if strings.HasSuffix(strings.ToLower(lhs), strings.ToLower(s)) {
						return true
					}
				}
				return false
			default:
				return false
			}
		case Matches:
			switch rhs := rhs.(type) {
			case string:
				return wildcard.Match(rhs, lhs)
			case []string:
				for _, pat := range rhs {
					if wildcard.Match(pat, lhs) {
						return true
					}
				}
				return false
			default:
				return false
			}
		case IMatches:
			switch rhs := rhs.(type) {
			case string:
				return wildcard.Match(strings.ToLower(rhs), strings.ToLower(lhs))
			case []string:
				for _, pat := range rhs {
					if wildcard.Match(strings.ToLower(pat), strings.ToLower(lhs)) {
						return true
					}
				}
				return false
			default:
				return false
			}
		case Fuzzy:
			switch rhs := rhs.(type) {
			case string:
				return fuzzysearch.Match(rhs, lhs)
			case []string:
				for _, s := range rhs {
					if fuzzysearch.Match(s, lhs) {
						return true
					}
				}
				return false
			default:
				return false
			}
		case IFuzzy:
			switch rhs := rhs.(type) {
			case string:
				return fuzzysearch.MatchFold(rhs, lhs)
			case []string:
				for _, s := range rhs {
					if fuzzysearch.MatchFold(s, lhs) {
						return true
					}
				}
				return false
			default:
				return false
			}
		case Fuzzynorm:
			switch rhs := rhs.(type) {
			case string:
				return fuzzysearch.MatchNormalized(rhs, lhs)
			case []string:
				for _, s := range rhs {
					if fuzzysearch.MatchNormalized(s, lhs) {
						return true
					}
				}
				return false
			default:
				return false
			}
		case IFuzzynorm:
			switch rhs := rhs.(type) {
			case string:
				return fuzzysearch.MatchNormalizedFold(rhs, lhs)
			case []string:
				for _, s := range rhs {
					if fuzzysearch.MatchNormalizedFold(s, lhs) {
						return true
					}
				}
				return false
			default:
				return false
			}
		}
	case net.IP:
		switch expr.Op {
		case Eq:
			rhs, ok := rhs.(net.IP)
			if !ok {
				return false
			}
			return lhs.Equal(rhs)
		case Neq:
			rhs, ok := rhs.(net.IP)
			if !ok {
				return false
			}
			return !lhs.Equal(rhs)
		case In:
			ips, ok := rhs.([]net.IP)
			if !ok {
				// keep backward compatibility with string lists
				addrs, ok := rhs.([]string)
				if !ok {
					return false
				}
				for _, s := range addrs {
					if net.ParseIP(s).Equal(lhs) {
						return true
					}
				}
				return false
			}
			for _, ip := range ips {
				if ip.Equal(lhs) {
					return true
				}
			}
			return false
		case Startswith:
			rhs, ok := rhs.(string)
			if !ok {
				return false
			}
			return strings.HasPrefix(lhs.String(), rhs)
		case Endswith:
			rhs, ok := rhs.(string)
			if !ok {
				return false
			}
			return strings.HasSuffix(lhs.String(), rhs)
		}
	case []string:
		switch expr.Op {
		case Contains:
			s, ok := rhs.(string)
			if !ok {
				rhs, ok := rhs.([]string)
				if !ok {
					return false
				}
				for _, s1 := range rhs {
					for _, s2 := range lhs {
						if strings.Contains(s2, s1) {
							return true
						}
					}
				}
				return false
			}
			for _, val := range lhs {
				if strings.Contains(val, s) {
					return true
				}
			}
			return false
		case IContains:
			rhs, ok := rhs.([]string)
			if !ok {
				return false
			}
			for _, s1 := range lhs {
				for _, s2 := range rhs {
					if strings.Contains(strings.ToLower(s1), strings.ToLower(s2)) {
						return true
					}
				}
			}
			return false
		case In:
			s, ok := rhs.(string)
			if !ok {
				rhs, ok := rhs.([]string)
				if !ok {
					return false
				}
				for _, i := range lhs {
					for _, j := range rhs {
						if i == j {
							return true
						}
					}
				}
				return false
			}
			for _, val := range lhs {
				if val == s {
					return true
				}
			}
			return false
		case IIn:
			s, ok := rhs.(string)
			if !ok {
				rhs, ok := rhs.([]string)
				if !ok {
					return false
				}
				for _, i := range lhs {
					for _, j := range rhs {
						if strings.EqualFold(i, j) {
							return true
						}
					}
				}
			}
			for _, val := range lhs {
				if strings.EqualFold(val, s) {
					return true
				}
			}
			return false
		case Startswith:
			rhs, ok := rhs.([]string)
			if !ok {
				return false
			}
			for _, s1 := range rhs {
				for _, s2 := range lhs {
					if strings.HasPrefix(s2, s1) {
						return true
					}
				}
			}
			return false
		case IStartswith:
			rhs, ok := rhs.([]string)
			if !ok {
				return false
			}
			for _, s1 := range rhs {
				for _, s2 := range lhs {
					if strings.HasPrefix(strings.ToLower(s2), strings.ToLower(s1)) {
						return true
					}
				}
			}
			return false
		case Endswith:
			rhs, ok := rhs.([]string)
			if !ok {
				return false
			}
			for _, s1 := range rhs {
				for _, s2 := range lhs {
					if strings.HasSuffix(s2, s1) {
						return true
					}
				}
			}
			return false
		case IEndswith:
			rhs, ok := rhs.([]string)
			if !ok {
				return false
			}
			for _, s1 := range rhs {
				for _, s2 := range lhs {
					if strings.HasSuffix(strings.ToLower(s2), strings.ToLower(s1)) {
						return true
					}
				}
			}
			return false
		case Matches:
			rhs, ok := rhs.([]string)
			if !ok {
				return false
			}
			for _, pat := range rhs {
				for _, val := range lhs {
					if wildcard.Match(pat, val) {
						return true
					}
				}
			}
			return false
		case IMatches:
			rhs, ok := rhs.([]string)
			if !ok {
				return false
			}
			for _, pat := range rhs {
				for _, val := range lhs {
					if wildcard.Match(strings.ToLower(pat), strings.ToLower(val)) {
						return true
					}
				}
			}
			return false
		case Intersects:
			rhs, ok := rhs.([]string)
			if !ok {
				return false
			}
			return len(sets.IntersectionStrings(lhs, rhs, false)) == len(rhs)
		case IIntersects:
			rhs, ok := rhs.([]string)
			if !ok {
				return false
			}
			return len(sets.IntersectionStrings(lhs, rhs, true)) == len(rhs)
		}
	}

	// the types were not comparable. If our operation was an equality operation,
	// return false instead of true.
	switch expr.Op {
	case Eq, IEq, Neq, Lt, Lte, Gt, Gte:
		return false
	}
	return nil
}

```

`pkg/filter/ql/error.go`:

```go
/*
 * Copyright 2019-2020 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package ql

import (
	"fmt"
	"strings"
)

// ParseError represents an error that occurred during parsing.
type ParseError struct {
	Expr     string
	Message  string
	Found    string
	Expected []string
	Pos      int
}

// newParseError returns a new instance of ParseError.
func newParseError(found string, expected []string, pos int, expr string) *ParseError {
	return &ParseError{Found: found, Expected: expected, Pos: pos, Expr: expr}
}

// findPosInLine returns the parser position and the line number
// where the syntax error occurred when the expression is split
// over multiple lines.
func findPosInLine(expr string, pos int) (int, int) {
	ln := 1
	for i, c := range []rune(expr) {
		if c == '\n' {
			ln++
		}
		if i == pos {
			switch {
			case ln > 1:
				// multiline expression. Calculate
				// the position relative to the line
				// number by looking back for the
				// previous newline terminator
				j := pos
				for expr[j] != '\n' {
					j--
					// no newline found
					if j == -1 {
						break
					}
				}
				return pos - j - 1, ln
			default:
				// single line expression
				return pos, 1
			}
		}
	}
	return pos + 1, 1
}

type renderer struct {
	strings.Builder
}

func (r *renderer) renderTopGutter()                 { r.WriteString("\n╭") }
func (r *renderer) renderCaret()                     { r.WriteString("^\n|") }
func (r *renderer) renderLeftBorder()                { r.WriteString("|\n") }
func (r *renderer) renderLineWithBorder(line string) { r.WriteString("|" + line) }
func (r *renderer) renderLine(line string)           { r.WriteString(line) }
func (r *renderer) renderNewLine()                   { r.WriteString("\n") }
func (r *renderer) renderLabel(width int, msg string) {
	r.WriteString("╰")
	for i := 0; i <= width; i++ {
		r.WriteString("─")
	}
	r.WriteString(" expected " + msg)
}

func (r *renderer) renderTopBorder(width int) {
	for i := 0; i < width; i++ {
		r.WriteString("─")
	}
}

func render(e *ParseError) string {
	pos, ln := findPosInLine(e.Expr, e.Pos)
	r := renderer{}

	lines := strings.Split(e.Expr, "\n")

	for n, line := range lines {
		if n >= ln {
			r.renderLineWithBorder(line)
		} else {
			r.renderLine(line)
		}
		// insert a new line and start drawing
		// the snippet lines, gutters and borders
		if n == ln-1 {
			r.renderTopGutter()
			r.renderTopBorder(pos - 1)
			r.renderCaret()
		}
		r.renderNewLine()
	}

	r.renderLeftBorder()
	r.renderLabel(18, strings.Join(e.Expected, ", "))

	return r.String()
}

// Error returns the string representation of the error.
func (e *ParseError) Error() string {
	if e.Message != "" {
		return fmt.Sprintf("%s at char %d", e.Message, e.Pos+1)
	}
	return render(e)
}

```

`pkg/filter/ql/error_test.go`:

```go
/*
 * Copyright 2019-2020 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package ql

import (
	"github.com/stretchr/testify/require"
	"strings"
	"testing"
)

func TestParseError(t *testing.T) {
	expr := `evt.name in ('RegCreateKey', 'RegDeleteKey', 'RegSetValue', 'RegDeleteValue')
	        and
	     registry.key.name icontains
			(
	          CurrentVersion\\Run',
	          'Policies\\Explorer\\Run',
	          'Group Policy\\Scripts',
	          'Windows\\System\\Scripts',
	          'CurrentVersion\\Windows\\Load',
	          'CurrentVersion\\Windows\\Run',
	          'CurrentVersion\\Winlogon\\Shell',
	          'CurrentVersion\\Winlogon\\System',
	          'UserInitMprLogonScript'
	        )
	        or
	     registry.key.name istartswith
	        (
	          'HKEY_LOCAL_MACHINE\\Software\\Microsoft\\Windows NT\\CurrentVersion\\Winlogon\\Notify',
	          'HKEY_LOCAL_MACHINE\\Software\\Microsoft\\Windows NT\\CurrentVersion\\Winlogon\\Shell',
	          'HKEY_LOCAL_MACHINE\\Software\\Microsoft\\Windows NT\\CurrentVersion\\Winlogon\\Userinit',
	          'HKEY_LOCAL_MACHINE\\Software\\WOW6432Node\\Microsoft\\Windows NT\\CurrentVersion\\Drivers32',
	          'HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Control\\Session Manager\\BootExecute',
	          'HKEY_LOCAL_MACHINE\\Software\\Microsoft\\Windows NT\\CurrentVersion\\AeDebug'
	        )
	        or
	     registry.key.name iendswith
	        (
	          'user shell folders\\startup'
	        )`
	expected := `evt.name in ('RegCreateKey', 'RegDeleteKey', 'RegSetValue', 'RegDeleteValue')
	        and
	     registry.key.name icontains
			(
	          CurrentVersion\\Run',
╭──────────────^
|
|	          'Policies\\Explorer\\Run',
|	          'Group Policy\\Scripts',
|	          'Windows\\System\\Scripts',
|	          'CurrentVersion\\Windows\\Load',
|	          'CurrentVersion\\Windows\\Run',
|	          'CurrentVersion\\Winlogon\\Shell',
|	          'CurrentVersion\\Winlogon\\System',
|	          'UserInitMprLogonScript'
|	        )
|	        or
|	     registry.key.name istartswith
|	        (
|	          'HKEY_LOCAL_MACHINE\\Software\\Microsoft\\Windows NT\\CurrentVersion\\Winlogon\\Notify',
|	          'HKEY_LOCAL_MACHINE\\Software\\Microsoft\\Windows NT\\CurrentVersion\\Winlogon\\Shell',
|	          'HKEY_LOCAL_MACHINE\\Software\\Microsoft\\Windows NT\\CurrentVersion\\Winlogon\\Userinit',
|	          'HKEY_LOCAL_MACHINE\\Software\\WOW6432Node\\Microsoft\\Windows NT\\CurrentVersion\\Drivers32',
|	          'HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Control\\Session Manager\\BootExecute',
|	          'HKEY_LOCAL_MACHINE\\Software\\Microsoft\\Windows NT\\CurrentVersion\\AeDebug'
|	        )
|	        or
|	     registry.key.name iendswith
|	        (
|	          'user shell folders\\startup'
|	        )
|
╰─────────────────── expected field, bound field, string, number, bool, ip, function`

	e := newParseError("[", []string{"field, bound field, string, number, bool, ip, function"}, 145, expr)
	require.Equal(t, expected, e.Error())

	expr = `ps.name = 'cmd.exe' aand ps.cmdline contains 'ss'`
	e = newParseError("[", []string{"operator"}, 20, expr)

	expected1 := `
ps.name = 'cmd.exe' aand ps.cmdline contains 'ss'
╭───────────────────^
|
|
╰─────────────────── expected operator`
	require.Equal(t, strings.TrimSpace(expected1), e.Error())
}

```

`pkg/filter/ql/expr.go`:

```go
/*
 * Copyright 2019-2020 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package ql

import (
	"strings"
)

// Node represents a node in the abstract syntax tree.
type Node interface {
	String() string
}

// Expr represents an expression that can be evaluated to a value.
type Expr interface {
	Node
}

// ParenExpr represents a parenthesized expression.
type ParenExpr struct {
	Expr Expr
}

// String returns a string representation of the parenthesized expression.
func (e *ParenExpr) String() string {
	var b strings.Builder
	b.Grow(len(e.Expr.String()) + 2)
	b.WriteRune('(')
	b.WriteString(e.Expr.String())
	b.WriteRune(')')
	return b.String()
}

// BinaryExpr represents an operation between two expressions.
type BinaryExpr struct {
	Op  token
	LHS Expr
	RHS Expr
}

// String returns a string representation of the binary expression.
func (e *BinaryExpr) String() string {
	var b strings.Builder

	lhs := e.LHS.String()
	op := e.Op.String()
	rhs := e.RHS.String()

	b.Grow(len(lhs) + len(op) + len(rhs) + 2)

	b.WriteString(lhs)
	b.WriteString(" ")
	b.WriteString(op)
	b.WriteString(" ")
	b.WriteString(rhs)

	return b.String()
}

// NotExpr represents an unary not expression.
type NotExpr struct {
	Expr Expr
}

// String returns a string representation of the not expression.
func (e *NotExpr) String() string {
	var b strings.Builder
	b.Grow(len(e.Expr.String()) + 4)
	b.WriteString("NOT ")
	b.WriteString(e.Expr.String())
	return b.String()
}

```

`pkg/filter/ql/function.go`:

```go
/*
 * Copyright 2020-2021 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package ql

import (
	"fmt"
	"maps"
	"path/filepath"
	"regexp"
	"sort"
	"strings"

	"github.com/rabbitstack/fibratus/pkg/callstack"
	"github.com/rabbitstack/fibratus/pkg/filter/fields"
	"github.com/rabbitstack/fibratus/pkg/pe"
	pstypes "github.com/rabbitstack/fibratus/pkg/ps/types"
	"github.com/rabbitstack/fibratus/pkg/util/signature"
	"golang.org/x/sys/windows"

	"github.com/rabbitstack/fibratus/pkg/filter/ql/functions"
)

var (
	// ErrArgumentTypeMismatch signals an invalid argument type
	ErrArgumentTypeMismatch = func(i int, keyword string, fn functions.Fn, types []functions.ArgType) error {
		argTypes := make([]string, len(types))
		for i, typ := range types {
			argTypes[i] = typ.String()
		}
		return fmt.Errorf("argument #%d (%s) in function %s should be one of: %v", i+1, keyword, fn, strings.Join(argTypes, "|"))
	}
	// ErrUndefinedFunction is thrown when an unknown function is supplied
	ErrUndefinedFunction = func(name string) error {
		return fmt.Errorf("%s function is undefined. Did you mean one of %s%s", name, strings.Join(functionNames(), "|"), "?")
	}
	// ErrFunctionSignature is thrown when the function signature is not satisfied
	ErrFunctionSignature = func(desc functions.FunctionDesc, givenArguments int) error {
		return fmt.Errorf("%s function requires %d argument(s) but %d argument(s) given", desc.Name, desc.RequiredArgs(), givenArguments)
	}
)

var funcs = map[string]FunctionDef{
	functions.CIDRContainsFn.String(): &functions.CIDRContains{},
	functions.MD5Fn.String():          &functions.MD5{},
	functions.ConcatFn.String():       &functions.Concat{},
	functions.LtrimFn.String():        &functions.Ltrim{},
	functions.RtrimFn.String():        &functions.Rtrim{},
	functions.LowerFn.String():        &functions.Lower{},
	functions.UpperFn.String():        &functions.Upper{},
	functions.ReplaceFn.String():      &functions.Replace{},
	functions.SplitFn.String():        &functions.Split{},
	functions.LengthFn.String():       &functions.Length{},
	functions.IndexOfFn.String():      &functions.IndexOf{},
	functions.SubstrFn.String():       &functions.Substr{},
	functions.EntropyFn.String():      &functions.Entropy{},
	functions.RegexFn.String():        functions.NewRegex(),
	functions.IsMinidumpFn.String():   &functions.IsMinidump{},
	functions.BaseFn.String():         &functions.Base{},
	functions.DirFn.String():          &functions.Dir{},
	functions.SymlinkFn.String():      &functions.Symlink{},
	functions.ExtFn.String():          &functions.Ext{},
	functions.GlobFn.String():         &functions.Glob{},
	functions.IsAbsFn.String():        &functions.IsAbs{},
	functions.VolumeFn.String():       &functions.Volume{},
	functions.GetRegValueFn.String():  &functions.GetRegValue{},
	functions.YaraFn.String():         &functions.Yara{},
	functions.ForeachFn.String():      &Foreach{},
	functions.CountFn.String():        &functions.Count{},
}

// FunctionDef is the interface that all function definitions have to satisfy.
type FunctionDef interface {
	// Call is the main function method that contains the implementation logic.
	Call(args []interface{}) (interface{}, bool)
	// Desc returns the function descriptor.
	Desc() functions.FunctionDesc
	// Name returns the function name.
	Name() functions.Fn
}

// FunctionValuer implements the CallValuer interface and delegates
// the evaluation of function calls to the corresponding functions.
type FunctionValuer struct {
	m map[string]interface{}
}

func (f FunctionValuer) Value(key string) (interface{}, bool) {
	v, ok := f.m[key]
	return v, ok
}

func (FunctionValuer) Call(name string, args []interface{}) (interface{}, bool) {
	fn, ok := funcs[strings.ToUpper(name)]
	if !ok {
		return nil, false
	}
	return fn.Call(args)
}

func functionNames() []string {
	names := make([]string, 0, len(funcs))
	for _, f := range funcs {
		names = append(names, f.Name().String())
	}
	sort.Slice(names, func(i, j int) bool { return names[i] < names[j] })
	return names
}

// Foreach adds iteration capabilities to the rule language. The decision
// to keep the function implementation outside the functions package is
// deliberate.
// The function mostly operates with raw expressions, and if the function
// lived in the functions package, that would create a cyclic import and
// likely unleash more painful side effects. For the sake of simplicity
// it is better to keep the function close to the parser and AST evaluation.
// Foreach accepts three required and multiple optional arguments. The
// first argument is the iterable value typically yielded by the pseudo
// field. The function recognizes process internal state collections such
// as modules, threads, memory mappings, or thread stack frames. Obviously,
// it is also possible to iterate over a simple string slice.
// The second argument represents the bound variable which is an item
// associated with every element in the slice. The bound variable is
// accessed in the third argument, the predicate. It is usually followed by
// the segment that denotes the accessed value. Unsurprisingly, the
// predicate is commonly a binary expression which can be formed of not/paren
// expressions, other functions, and so on. The predicate is executed on
// every item in the slice. If the predicate evaluates to true, the function
// also returns the true value.
// Lastly, foreach function can receive an optional list of fields from the
// outer context, i.e. outside predicate loop. Therefore, for the predicate
// to access the field not defined within the scope of the iterable, it must
// capture the field first.
//
// Some examples:
//
//   - Traverses process modules and return true if the module path matches the pattern
//     foreach(ps._modules, $mod, $mod.path imatches '?:\\Windows\\System32\\us?r32.dll')
//
//   - For each process ancestor, checks if the ancestor is services.exe and the current process is protected
//     foreach(ps._ancestors, $proc, $proc.name = 'services.exe' and ps.is_protected, ps.is_protected)
//     In this example, the ps.is_protected field is captured prior to its usage in the predicate
type Foreach struct{}

func (f *Foreach) Call(args []interface{}) (interface{}, bool) {
	if len(args) < 3 {
		return false, false
	}

	s := args[0] // iterable (slice or map)
	if s == nil {
		return false, false
	}

	v, ok := args[1].(*BareBoundVariableLiteral) // item (variable)
	if !ok {
		return false, false
	}

	e := args[2] // predicate (expression)
	if e == nil {
		return false, false
	}

	var valuer = MapValuer{}
	if len(args) > 3 { // optional predicate captures
		for i := 3; i < len(args); i++ {
			m, ok := args[i].(MapValuer)
			if !ok {
				continue
			}
			maps.Copy(valuer, m)
		}
	}

	segments := make([]*BoundSegmentLiteral, 0)

	// obtain bound segments used in expression
	var useCallValuer bool
	walk := func(n Node) {
		switch exp := n.(type) {
		case *BoundSegmentLiteral:
			segments = append(segments, exp)
		case *Function:
			useCallValuer = true
		}
	}

	switch expr := e.(type) {
	case *BinaryExpr:
		WalkFunc(expr, walk)
	case *NotExpr:
		WalkFunc(expr, walk)
	}

	switch elems := s.(type) {
	case []string:
		for _, elem := range elems {
			if f.evalExpr(e, useCallValuer, f.stringMapValuer(v, elem), valuer) {
				return true, true
			}
		}
	case []*pstypes.PS:
		for _, proc := range elems {
			if f.evalExpr(e, useCallValuer, f.procMapValuer(segments, proc), valuer) {
				return true, true
			}
		}
	case []pstypes.Module:
		for _, mod := range elems {
			if f.evalExpr(e, useCallValuer, f.moduleMapValuer(segments, mod), valuer) {
				return true, true
			}
		}
	case map[uint32]pstypes.Thread:
		for _, thread := range elems {
			if f.evalExpr(e, useCallValuer, f.threadMapValuer(segments, thread), valuer) {
				return true, true
			}
		}
	case []pstypes.Mmap:
		for _, mmap := range elems {
			if f.evalExpr(e, useCallValuer, f.mmapMapValuer(segments, mmap), valuer) {
				return true, true
			}
		}
	case []pe.Sec:
		for _, sec := range elems {
			if f.evalExpr(e, useCallValuer, f.sectionMapValuer(segments, sec), valuer) {
				return true, true
			}
		}
	case callstack.Callstack:
		var pid uint32
		var proc windows.Handle
		var err error

		if !elems.IsEmpty() {
			pid = elems.FrameAt(0).PID
		}

		// open process handle with required access mask
		var desiredAccess uint32
	loop:
		for _, seg := range segments {
			switch seg.Segment {
			case fields.CallsiteLeadingAssemblySegment, fields.CallsiteTrailingAssemblySegment:
				// break on broader access rights
				desiredAccess = windows.PROCESS_QUERY_INFORMATION | windows.PROCESS_VM_READ
				break loop
			case fields.AllocationSizeSegment, fields.ProtectionSegment:
				desiredAccess = windows.PROCESS_QUERY_INFORMATION
			}
		}
		if desiredAccess != 0 {
			proc, err = windows.OpenProcess(desiredAccess, false, pid)
			if err != nil {
				return false, false
			}
			defer windows.Close(proc)
		}

		for _, frame := range elems {
			if f.evalExpr(e, useCallValuer, f.callstackMapValuer(segments, frame, proc), valuer) {
				return true, true
			}
		}
	}

	return false, false
}

func (f *Foreach) Desc() functions.FunctionDesc {
	desc := functions.FunctionDesc{
		Name: functions.ForeachFn,
		Args: []functions.FunctionArgDesc{
			{Keyword: "iterable", Types: []functions.ArgType{functions.Field}, Required: true},
			{Keyword: "var", Types: []functions.ArgType{functions.BareBoundVariable}, Required: true},
			{Keyword: "predicate", Types: []functions.ArgType{functions.Expression}, Required: true},
		},
		ArgsValidationFunc: func(args []string) error {
			s := args[0] // slice/map field name
			v := args[1] // bound variable name
			e := args[2] // expression

			var reserved = map[string]bool{ // reserved bound variable names
				"$ps":         true,
				"$pe":         true,
				"$file":       true,
				"$image":      true,
				"$thread":     true,
				"$threadpool": true,
				"$registry":   true,
				"$net":        true,
				"$mem":        true,
				"$handle":     true,
				"$dns":        true,
				"$evt":        true,
			}

			if reserved[v] {
				return fmt.Errorf("%q is a reserved bound variable name", v)
			}

			var hasBoundVar bool
			var boundSegmentRegexp = regexp.MustCompile(`(\$[a-zA-Z_0-9]+)\.?([a-zA-Z0-9_.$]*)`)

			// scan all bound fields inside expression
			matches := boundSegmentRegexp.FindAllStringSubmatch(e, -1)

			for _, match := range matches {
				// check the bound variable references
				// a valid segment and also verify if
				// the declared bound item is used in
				// the predicate
				switch len(match) {
				case 3:
					if match[2] != "" && !fields.IsSegmentAllowed(fields.Field(s), fields.Segment(match[2])) {
						return fmt.Errorf("unrecognized property %q accessing bound variable %s. Allowed properties [%s]",
							match[2],
							v,
							fields.SegmentsHint(fields.Field(s)))
					}
					if match[1] == v {
						hasBoundVar = true
					}
					if match[1] != v {
						return fmt.Errorf("undeclared bound variable %s in predicate %q", match[1], e)
					}
				default:
					return fmt.Errorf("invalid bound variables in predicate %q", e)
				}
			}

			if !hasBoundVar {
				return fmt.Errorf("unused bound variable %s in predicate %q", v, e)
			}

			var fieldRegexp = regexp.MustCompile(`(ps|pe|file|image|thread|registry|net|mem|handle|dns|evt)\.[a-zA-Z0-9_.$]+`)
			matches = fieldRegexp.FindAllStringSubmatch(e, -1)

			if len(args) > 3 {
				// validate predicate captures. The basic
				// requirements must ensure the field is
				// captured from outer context before it
				// can be used in the predicate
				captures := make(map[string]bool)

				for n := 3; n < len(args); n++ {
					captures[args[n]] = true
				}

				for _, match := range matches {
					if len(match) != 2 {
						continue
					}
					if !captures[match[0]] {
						return fmt.Errorf("field %s used in predicate %q but not captured", match[0], e)
					}
				}

				if len(matches) == 0 && len(captures) > 0 {
					return fmt.Errorf("one of captured field(s) (%s) not used in predicate %q", strings.Join(args[3:], ","), e)
				}
			} else {
				for _, match := range matches {
					if len(match) != 2 {
						continue
					}
					return fmt.Errorf("field %s used in predicate %q but not captured", match[0], e)
				}
			}

			return nil
		},
	}

	offset := len(desc.Args)

	// add optional fields the predicate can capture. Ten fields should be enough for anybody ;)
	for i := offset; i < offset+10; i++ {
		desc.Args = append(desc.Args, functions.FunctionArgDesc{Keyword: "field", Types: []functions.ArgType{functions.Field}})
	}

	return desc
}

func (f *Foreach) Name() functions.Fn {
	return functions.ForeachFn
}

func (f *Foreach) evalExpr(e any, useCallValuer bool, valuers ...Valuer) bool {
	var valuer ValuerEval

	if useCallValuer {
		callValuerMap := make(map[string]interface{})
		for _, v := range valuers {
			if m, ok := v.(MapValuer); ok {
				maps.Copy(callValuerMap, m)
			}
		}
		valuer = ValuerEval{Valuer: MultiValuer(append([]Valuer{FunctionValuer{callValuerMap}}, valuers...)...)}
	} else {
		valuer = ValuerEval{Valuer: MultiValuer(valuers...)}
	}

	switch expr := e.(type) {
	case *BinaryExpr:
		v, ok := valuer.Eval(expr).(bool)
		if !ok {
			return false
		}
		return v
	case *NotExpr:
		v, ok := valuer.Eval(expr).(bool)
		if !ok {
			return false
		}
		return v
	}

	return false
}

// stringMapValuer returns the map valuer composed of primitive string values.
func (f *Foreach) stringMapValuer(v *BareBoundVariableLiteral, s string) MapValuer {
	return MapValuer{v.Value: s}
}

// moduleMapValuer returns the map valuer with process module attributes.
func (f *Foreach) moduleMapValuer(segments []*BoundSegmentLiteral, mod pstypes.Module) MapValuer {
	var valuer = MapValuer{}
	for _, seg := range segments {
		key := seg.Value
		switch seg.Segment {
		case fields.PathSegment:
			valuer[key] = mod.Name
		case fields.NameSegment:
			valuer[key] = filepath.Base(mod.Name)
		case fields.AddressSegment:
			valuer[key] = mod.BaseAddress.String()
		case fields.SizeSegment:
			valuer[key] = mod.Size
		case fields.ChecksumSegment:
			valuer[key] = mod.Checksum
		}
	}
	return valuer
}

// procMapValuer returns the map valuer with process attributes.
func (f *Foreach) procMapValuer(segments []*BoundSegmentLiteral, proc *pstypes.PS) MapValuer {
	var valuer = MapValuer{}
	for _, seg := range segments {
		key := seg.Value
		switch seg.Segment {
		case fields.PIDSegment:
			valuer[key] = proc.PID
		case fields.NameSegment:
			valuer[key] = proc.Name
		case fields.ExeSegment:
			valuer[key] = proc.Exe
		case fields.CmdlineSegment:
			valuer[key] = proc.Cmdline
		case fields.ArgsSegment:
			valuer[key] = proc.Args
		case fields.CwdSegment:
			valuer[key] = proc.Cwd
		case fields.SIDSegment:
			valuer[key] = proc.SID
		case fields.SessionIDSegment:
			valuer[key] = proc.SessionID
		case fields.UsernameSegment:
			valuer[key] = proc.Username
		case fields.DomainSegment:
			valuer[key] = proc.Domain
		case fields.TokenIntegrityLevelSegment:
			valuer[key] = proc.TokenIntegrityLevel
		case fields.TokenIsElevatedSegment:
			valuer[key] = proc.IsTokenElevated
		case fields.TokenElevationTypeSegment:
			valuer[key] = proc.TokenElevationType
		}
	}
	return valuer
}

// threadMapValuer returns the map valuer with thread information.
func (f *Foreach) threadMapValuer(segments []*BoundSegmentLiteral, thread pstypes.Thread) MapValuer {
	var valuer = MapValuer{}
	for _, seg := range segments {
		key := seg.Value
		switch seg.Segment {
		case fields.TidSegment:
			valuer[key] = thread.Tid
		case fields.StartAddressSegment:
			valuer[key] = thread.StartAddress.String()
		case fields.UserStackBaseSegment:
			valuer[key] = thread.UstackBase.String()
		case fields.UserStackLimitSegment:
			valuer[key] = thread.UstackLimit.String()
		case fields.KernelStackBaseSegment:
			valuer[key] = thread.KstackBase.String()
		case fields.KernelStackLimitSegment:
			valuer[key] = thread.KstackLimit.String()
		}
	}
	return valuer
}

// mmapMapValuer returns map valuer with memory mapping details.
func (f *Foreach) mmapMapValuer(segments []*BoundSegmentLiteral, mmap pstypes.Mmap) MapValuer {
	var valuer = MapValuer{}
	for _, seg := range segments {
		key := seg.Value
		switch seg.Segment {
		case fields.AddressSegment:
			valuer[key] = mmap.BaseAddress.String()
		case fields.SizeSegment:
			valuer[key] = mmap.Size
		case fields.ProtectionSegment:
			valuer[key] = mmap.ProtectMask()
		case fields.TypeSegment:
			valuer[key] = mmap.Type
		case fields.PathSegment:
			valuer[key] = mmap.File
		}
	}
	return valuer
}

// callstackMapValuer returns map valuer with thread stack frame data.
func (f *Foreach) callstackMapValuer(segments []*BoundSegmentLiteral, frame callstack.Frame, proc windows.Handle) MapValuer {
	var valuer = MapValuer{}
	for _, seg := range segments {
		key := seg.Value
		switch seg.Segment {
		case fields.AddressSegment:
			valuer[key] = frame.Addr.String()
		case fields.OffsetSegment:
			valuer[key] = frame.Offset
		case fields.IsUnbackedSegment:
			valuer[key] = frame.IsUnbacked()
		case fields.ModuleSegment:
			valuer[key] = frame.Module
		case fields.SymbolSegment:
			valuer[key] = frame.Module + "!" + frame.Symbol
		case fields.AllocationSizeSegment:
			valuer[key] = frame.AllocationSize(proc)
		case fields.ProtectionSegment:
			valuer[key] = frame.Protection(proc)
		case fields.CallsiteTrailingAssemblySegment:
			valuer[key] = frame.CallsiteAssembly(proc, false)
		case fields.CallsiteLeadingAssemblySegment:
			valuer[key] = frame.CallsiteAssembly(proc, true)
		case fields.ModuleSignatureExistsSegment, fields.ModuleSignatureTrustedSegment,
			fields.ModuleSignatureIssuerSegment, fields.ModuleSignatureSubjectSegment:

			if frame.ModuleAddress.IsZero() {
				continue
			}

			segment := seg.Segment
			sign := signature.GetSignatures().GetSignature(frame.ModuleAddress.Uint64())
			if sign == nil && frame.Module != "" {
				// register signature if not present in the cache
				var err error
				sign = &signature.Signature{Filename: frame.Module}
				sign.Type, sign.Level, err = sign.Check()
				if err != nil {
					continue
				}

				if sign.IsSigned() {
					sign.Verify()
				}

				if segment == fields.ModuleSignatureIssuerSegment || segment == fields.ModuleSignatureSubjectSegment {
					if err := sign.ParseCertificate(); err != nil {
						continue
					}
				}

				signature.GetSignatures().PutSignature(frame.ModuleAddress.Uint64(), sign)
			}

			switch segment {
			case fields.ModuleSignatureExistsSegment:
				valuer[key] = sign.IsSigned()
			case fields.ModuleSignatureTrustedSegment:
				valuer[key] = sign.IsTrusted()
			case fields.ModuleSignatureIssuerSegment:
				if err := sign.ParseCertificate(); err != nil {
					continue
				}
				if sign.HasCertificate() {
					valuer[key] = sign.Cert.Issuer
				}
			case fields.ModuleSignatureSubjectSegment:
				if err := sign.ParseCertificate(); err != nil {
					continue
				}
				if sign.HasCertificate() {
					valuer[key] = sign.Cert.Subject
				}
			}
		}
	}
	return valuer
}

// sectionMapValuer returns map valuer with PE section data.
func (f *Foreach) sectionMapValuer(segments []*BoundSegmentLiteral, section pe.Sec) MapValuer {
	var valuer = MapValuer{}
	for _, seg := range segments {
		key := seg.Value
		switch seg.Segment {
		case fields.NameSegment:
			valuer[key] = section.Name
		case fields.SizeSegment:
			valuer[key] = section.Size
		case fields.EntropySegment:
			valuer[key] = section.Entropy
		case fields.MD5Segment:
			valuer[key] = section.Md5
		}
	}
	return valuer
}

```

`pkg/filter/ql/function_test.go`:

```go
/*
 * Copyright 2020-2021 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package ql

import (
	"errors"
	"fmt"
	"strings"
	"testing"

	"github.com/stretchr/testify/assert"
)

func TestParseFunction(t *testing.T) {
	var tests = []struct {
		expr string
		err  error
	}{
		{expr: "cidr_contains(net.dip)", err: errors.New("CIDR_CONTAINS function requires 2 argument(s) but 1 argument(s) given")},
		{expr: "cidr_contains(net.dip, 12)", err: errors.New("argument #2 (cidr) in function CIDR_CONTAINS should be one of: string")},
		{expr: "cidr_contains(net.dip, '172.17.12.4/24')"},
		{expr: "cidr_contains($e1.net.dip, '172.17.12.4/24')"},
		{expr: "md('172.17.12.4')", err: errors.New("md function is undefined")},
		{expr: "concat('hello ', 'world')"},
		{expr: "concat('hello')", err: errors.New("CONCAT function requires 2 argument(s) but 1 argument(s) given")},
		{expr: "ltrim('hello world', 'hello ')"},
		{expr: "replace('hello world', 'hello', 'hell', 'world')", err: errors.New("old/new replacements mismatch")},
		{expr: "replace('hello world', 'hello', 'hell', 'world', 'war', 'hello')", err: errors.New("old/new replacements mismatch")},
		{expr: "replace('hello world', 'hello', 'hell', 'world', 'war', 'hello', 'warld', 'old', 'new', 'one')", err: errors.New("old/new replacements mismatch")},
		{expr: "indexof('hello', 'h', 'frst')", err: errors.New("frst is not a valid index search order")},
		{expr: "base('C:\\\\Windows\\\\cmd.exe', false)"},
		{expr: "foreach(ps.modules, $n, $n = 'user32.dll')"},
		{expr: "foreach(ps._ancestors, $proc, $proc.name = 'svchost.exe')"},
		{expr: "foreach(ps._ancestors, $proc, $process.name = 'svchost.exe')", err: errors.New(`undeclared bound variable $process in predicate "$process.name = svchost.exe"`)},
		{expr: "foreach(ps._ancestors, $proc, $proc.pid = 4 or $process.name = 'svchost.exe')", err: errors.New(`undeclared bound variable $process in predicate "$proc.pid = 4 OR $process.name = svchost.exe"`)},
		{expr: "foreach(ps._ancestors, $ps, $ps.name = 'svchost.exe')", err: errors.New(`"$ps" is a reserved bound variable name`)},
		{expr: "foreach(pe._sections, $sec, $sec.protection = 'RWX')", err: errors.New(`unrecognized property "protection" accessing bound variable $sec. Allowed properties [name, size, entropy, md5]`)},
		{expr: "foreach(ps.modules, $n, $n.name = 'user32.dll')", err: errors.New(`unrecognized property "name" accessing bound variable $n. Allowed properties []`)},
		{expr: "foreach(ps._ancestors, $proc, ($proc.name = 'svchost.exe' and $proc.sessionid > 0) or $proc.sid = 'S-1-5-8')"},
		{expr: "foreach(ps._ancestors, $proc, $proc.name = 'svchost.exe' and ps.cwd imatches '?:\\\\Windows\\\\System32\\\\*', ps.cwd)"},
		{expr: "foreach(ps._ancestors, $proc, $proc.name = 'svchost.exe', ps.cwd)", err: errors.New(`one of captured field(s) (ps.cwd) not used in predicate "$proc.name = svchost.exe"`)},
		{expr: "foreach(ps._ancestors, $proc, $proc.name = 'svchost.exe' and ps.cwd != ' ')", err: errors.New(`field ps.cwd used in predicate "$proc.name = svchost.exe AND ps.cwd !=  " but not captured`)},
		{expr: "foreach(ps._ancestors, $proc, $proc.name = 'svchost.exe' and ps.cwd = '.' and ps.sid = 'S-1-5-18', ps.cwd, ps.sid)"},
		{expr: "foreach(ps._ancestors, $proc, $proc.name = 'svchost.exe' and ps.cwd = '.' and ps.sid = 'S-1-5-18', ps.cwd)", err: errors.New(`field ps.sid used in predicate "$proc.name = svchost.exe AND ps.cwd = . AND ps.sid = S-1-5-18" but not captured`)},
	}

	for i, tt := range tests {
		p := NewParser(tt.expr)
		_, err := p.ParseExpr()
		if err == nil && tt.err != nil {
			t.Errorf("%d. exp=%s expected error=%v", i, tt.expr, tt.err)
		} else if err != nil && tt.err != nil {
			assert.True(t, strings.Contains(err.Error(), tt.err.Error()), fmt.Sprintf("exp=%v got=%v", tt.err, err))
		} else if err != nil && tt.err == nil {
			t.Errorf("%d. exp=%s got error=%v", i, tt.expr, err)
		}
	}
}

```

`pkg/filter/ql/functions/base.go`:

```go
/*
 * Copyright 2021-2022 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package functions

import (
	"path/filepath"
	"strings"
)

// Base returns the last element of the path.
type Base struct{}

func (f Base) Call(args []interface{}) (interface{}, bool) {
	if len(args) < 1 {
		return false, false
	}
	switch s := args[0].(type) {
	case string:
		return f.trimExt(filepath.Base(s), args), true
	case []string:
		paths := make([]string, len(s))
		for i, path := range s {
			paths[i] = f.trimExt(filepath.Base(path), args)
		}
		return paths, true
	}
	return nil, true
}

func (f Base) Desc() FunctionDesc {
	desc := FunctionDesc{
		Name: BaseFn,
		Args: []FunctionArgDesc{
			{Keyword: "path", Types: []ArgType{Field, BoundField, BoundSegment, BareBoundVariable, Func, String, Slice}, Required: true},
			{Keyword: "ext", Types: []ArgType{Bool}, Required: false},
		},
	}
	return desc
}

func (f Base) Name() Fn { return BaseFn }

func (f Base) trimExt(base string, args []interface{}) string {
	if len(args) > 1 {
		ext, ok := args[1].(bool)
		if !ok {
			return base
		}
		if !ext {
			n := strings.LastIndex(base, ".")
			if n > 0 {
				return base[:n]
			}
		}
	}
	return base
}

```

`pkg/filter/ql/functions/base_test.go`:

```go
/*
 * Copyright 2021-2022 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package functions

import (
	"fmt"
	"github.com/stretchr/testify/assert"
	"testing"
)

func TestBase(t *testing.T) {
	var tests = []struct {
		args     []interface{}
		expected interface{}
	}{
		{
			[]interface{}{"C:\\Windows\\cmd.exe"},
			"cmd.exe",
		},
		{
			[]interface{}{"C:\\Windows\\cmd.exe", false},
			"cmd",
		},
		{
			[]interface{}{[]string{"C:\\Windows\\cmd.exe", "C:\\Windows\\notepad.exe"}},
			[]string{"cmd.exe", "notepad.exe"},
		},
		{
			[]interface{}{[]string{"C:\\Windows\\cmd.exe", "C:\\Windows\\notepad.exe"}, false},
			[]string{"cmd", "notepad"},
		},
	}

	for i, tt := range tests {
		f := Base{}
		res, _ := f.Call(tt.args)
		assert.Equal(t, tt.expected, res, fmt.Sprintf("%d. result mismatch: exp=%v got=%v", i, tt.expected, res))
	}
}

```

`pkg/filter/ql/functions/cidr.go`:

```go
/*
 * Copyright 2020-2021 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package functions

import (
	"net"
)

// CIDRContains determines if the specified IP is contained within
// the block referenced by the given CIDR mask. The first argument
// in the slice represents the IP address and the rest of the args
// represent IP addresses in CIDR notation.
type CIDRContains struct{}

func (f CIDRContains) Call(args []interface{}) (interface{}, bool) {
	if len(args) < 2 {
		return false, false
	}

	var ip net.IP
	switch addr := args[0].(type) {
	case net.IP:
		ip = addr
	case string:
		ip = net.ParseIP(addr)
	}

	// get CIDR ranges
	cidrs := make([]string, len(args)-1)
	for i, arg := range args[1:] {
		cidr, ok := arg.(string)
		if !ok {
			continue
		}
		cidrs[i] = cidr
	}

	// check each CIDR range
	for _, cidr := range cidrs {
		_, ipnet, err := net.ParseCIDR(cidr)
		if err != nil {
			continue
		}
		if ipnet.Contains(ip) {
			return true, true
		}
	}

	return false, true
}

func (f CIDRContains) Desc() FunctionDesc {
	desc := FunctionDesc{
		Name: CIDRContainsFn,
		Args: []FunctionArgDesc{
			{Keyword: "ip", Types: []ArgType{IP, Field, BoundField, BoundSegment, BareBoundVariable}, Required: true},
			{Keyword: "cidr", Types: []ArgType{String}, Required: true},
		},
	}
	offset := len(desc.Args)
	// add optional CIDR arguments
	for i := offset; i < maxArgs; i++ {
		desc.Args = append(desc.Args, FunctionArgDesc{Keyword: "cidr", Types: []ArgType{String, Func}})
	}
	return desc
}

func (f CIDRContains) Name() Fn { return CIDRContainsFn }

```

`pkg/filter/ql/functions/cidr_test.go`:

```go
/*
 * Copyright 2020-2021 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package functions

import (
	"fmt"
	"github.com/stretchr/testify/assert"
	"net"
	"testing"
)

func TestCIDRContainsCall(t *testing.T) {
	var tests = []struct {
		args     []interface{}
		expected interface{}
	}{
		{
			[]interface{}{net.ParseIP("192.168.1.5"), "192.168.1.0/24"},
			true,
		},
		{
			[]interface{}{net.ParseIP("216.58.201.174"), "216.58.201.1/24"},
			true,
		},
		{
			[]interface{}{"192.168.1.5", "192.168.1.0/24"},
			true,
		},
		{
			[]interface{}{net.ParseIP("192.168.1.5"), "172.168.1.0/24"},
			false,
		},
		{
			[]interface{}{net.ParseIP("192.168.1.5"), "172.168.1.0/24", "192.168.1.0/24"},
			true,
		},
		{
			[]interface{}{net.ParseIP("192.168.1.5"), "192.168.1.0"},
			false,
		},
		{
			[]interface{}{net.ParseIP("192.168.1.5")},
			false,
		},
	}

	for i, tt := range tests {
		f := CIDRContains{}
		res, _ := f.Call(tt.args)
		assert.Equal(t, tt.expected, res, fmt.Sprintf("%d. result mismatch: exp=%v got=%v", i, tt.expected, res))
	}
}

func TestCIDRContainsDesc(t *testing.T) {
	call := CIDRContains{}

	desc := call.Desc()

	assert.Equal(t, desc.RequiredArgs(), 2)
	assert.Len(t, desc.Args, maxArgs)
}

```

`pkg/filter/ql/functions/concat.go`:

```go
/*
 * Copyright 2021-2022 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package functions

import (
	"fmt"
	"strconv"
	"strings"
)

// Concat returns a concatenated string of all input arguments.
type Concat struct{}

func (f Concat) Call(args []interface{}) (interface{}, bool) {
	if len(args) < 2 {
		return false, false
	}
	var sb strings.Builder
	for _, arg := range args {
		switch s := arg.(type) {
		case string:
			sb.WriteString(s)
		case int:
			sb.WriteString(strconv.FormatInt(int64(s), 10))
		case uint:
			sb.WriteString(strconv.FormatInt(int64(s), 10))
		case int8:
			sb.WriteString(strconv.FormatInt(int64(s), 10))
		case uint8:
			sb.WriteString(strconv.FormatInt(int64(s), 10))
		case int16:
			sb.WriteString(strconv.FormatInt(int64(s), 10))
		case uint16:
			sb.WriteString(strconv.FormatInt(int64(s), 10))
		case int32:
			sb.WriteString(strconv.FormatInt(int64(s), 10))
		case uint32:
			sb.WriteString(strconv.FormatInt(int64(s), 10))
		case int64:
			sb.WriteString(strconv.FormatInt(s, 10))
		case uint64:
			sb.WriteString(strconv.FormatInt(int64(s), 10))
		}
	}
	return sb.String(), true
}

func (f Concat) Desc() FunctionDesc {
	desc := FunctionDesc{
		Name: ConcatFn,
		Args: []FunctionArgDesc{
			{Keyword: "string1", Types: []ArgType{String, Number, Field, BoundField, BoundSegment, BareBoundVariable, Func}, Required: true},
			{Keyword: "string2", Types: []ArgType{String, Number, Field, BoundField, BoundSegment, BareBoundVariable, Func}, Required: true},
		},
	}
	offset := len(desc.Args)
	// add optional arguments
	for i := offset; i < maxArgs; i++ {
		desc.Args = append(desc.Args, FunctionArgDesc{Keyword: fmt.Sprintf("string%d", i+1), Types: []ArgType{String, Number, Field, Func}})
	}
	return desc
}

func (f Concat) Name() Fn { return ConcatFn }

```

`pkg/filter/ql/functions/concat_test.go`:

```go
/*
 * Copyright 2021-2022 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package functions

import (
	"testing"

	"github.com/stretchr/testify/assert"
)

func TestConcat(t *testing.T) {
	call := Concat{}
	res, _ := call.Call([]interface{}{"hello ", "world", " ", int32(7), 7})
	assert.Equal(t, "hello world 77", res)
}

```

`pkg/filter/ql/functions/count.go`:

```go
/*
 * Copyright 2021-present by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package functions

import (
	"strings"

	"github.com/rabbitstack/fibratus/pkg/util/wildcard"
)

// Count counts the number of items in the slice or substrings
// in the string that is matching a wildcard pattern.
type Count struct{}

func (f Count) Call(args []interface{}) (any, bool) {
	if len(args) < 2 {
		return false, false
	}

	var count int
	var caseInsensitive bool

	pattern := parseString(1, args)

	if len(args) > 2 {
		caseInsensitive, _ = args[2].(bool)
	} else {
		caseInsensitive = true
	}

	switch s := args[0].(type) {
	case string:
		substrings := strings.Fields(s)
		for _, ss := range substrings {
			switch caseInsensitive {
			case true:
				if wildcard.Match(strings.ToLower(pattern), strings.ToLower(ss)) {
					count++
				}
			case false:
				if wildcard.Match(pattern, ss) {
					count++
				}
			}
		}
	case []string:
		for _, i := range s {
			switch caseInsensitive {
			case true:
				if wildcard.Match(strings.ToLower(pattern), strings.ToLower(i)) {
					count++
				}
			case false:
				if wildcard.Match(pattern, i) {
					count++
				}
			}
		}
	}

	return count, true
}

func (f Count) Desc() FunctionDesc {
	desc := FunctionDesc{
		Name: CountFn,
		Args: []FunctionArgDesc{
			{Keyword: "string|slice", Types: []ArgType{Field, BoundField, BoundSegment, BareBoundVariable, Func, String, Slice}, Required: true},
			{Keyword: "pattern", Types: []ArgType{String}, Required: true},
			{Keyword: "case_insensitive", Types: []ArgType{Bool}, Required: false},
		},
	}
	return desc
}

func (f Count) Name() Fn { return CountFn }

```

`pkg/filter/ql/functions/count_test.go`:

```go
/*
 * Copyright 2021-present by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package functions

import (
	"fmt"
	"testing"

	"github.com/stretchr/testify/assert"
)

func TestCount(t *testing.T) {
	var tests = []struct {
		args     []any
		expected int
	}{
		{
			[]any{"hello world", "?orld"},
			1,
		},
		{
			[]any{"hello world", "saturn"},
			0,
		},
		{
			[]any{[]string{"C:\\Windows\\System32\\ntdll.dll", "C:\\Windows\\System32\\NTDLL.dll"}, "*ntdll.dll"},
			2,
		},
		{
			[]any{[]string{"C:\\Windows\\System32\\ntdll.dll", "C:\\Windows\\System32\\NTDLL.dll"}, "*ntdll.dll", false},
			1,
		},
	}

	for i, tt := range tests {
		f := Count{}
		res, _ := f.Call(tt.args)
		assert.Equal(t, tt.expected, res, fmt.Sprintf("%d. result mismatch: exp=%v got=%v", i, tt.expected, res))
	}
}

```

`pkg/filter/ql/functions/dir.go`:

```go
/*
 * Copyright 2021-2022 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package functions

import "path/filepath"

// Dir returns all but the last element of the path, typically the path's directory.
type Dir struct{}

func (f Dir) Call(args []interface{}) (interface{}, bool) {
	if len(args) < 1 {
		return false, false
	}
	switch s := args[0].(type) {
	case string:
		return filepath.Dir(s), true
	case []string:
		dirs := make([]string, len(s))
		for i, path := range s {
			dirs[i] = filepath.Dir(path)
		}
		return dirs, true
	}
	return nil, true
}

func (f Dir) Desc() FunctionDesc {
	desc := FunctionDesc{
		Name: DirFn,
		Args: []FunctionArgDesc{
			{Keyword: "path", Types: []ArgType{Field, BoundField, BoundSegment, BareBoundVariable, Func, String, Slice}, Required: true},
		},
	}
	return desc
}

func (f Dir) Name() Fn { return DirFn }

```

`pkg/filter/ql/functions/dir_test.go`:

```go
/*
 * Copyright 2021-2022 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package functions

import (
	"github.com/stretchr/testify/assert"
	"testing"
)

func TestDir(t *testing.T) {
	call := Dir{}
	res, _ := call.Call([]interface{}{"C:\\Windows\\cmd.exe"})
	assert.Equal(t, "C:\\Windows", res)
}

```

`pkg/filter/ql/functions/entropy.go`:

```go
/*
 * Copyright 2021-2022 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package functions

import (
	"fmt"
	"github.com/rabbitstack/fibratus/pkg/util/entropy"
	"strings"
)

const (
	// Shannon computes the string entropy by employing
	// the Shannon algorithm.
	// https://en.wikipedia.org/wiki/Entropy_(information_theory)
	Shannon = "shannon"
)

// Entropy measures the string entropy
type Entropy struct{}

func (f Entropy) Call(args []interface{}) (interface{}, bool) {
	if len(args) < 1 {
		return false, false
	}
	s := parseString(0, args)
	if len(args) == 1 {
		return entropy.Shannon(s), true
	}
	algo := parseString(1, args)
	switch algo {
	case Shannon:
		return entropy.Shannon(s), true
	default:
		return false, false
	}
}

func (f Entropy) Desc() FunctionDesc {
	desc := FunctionDesc{
		Name: LengthFn,
		Args: []FunctionArgDesc{
			{Keyword: "string", Types: []ArgType{Field, BoundField, BoundSegment, BareBoundVariable, Func}, Required: true},
			{Keyword: "algo", Types: []ArgType{String}},
		},
		ArgsValidationFunc: func(args []string) error {
			if len(args) == 1 {
				return nil
			}
			if len(args) > 1 && args[1] != Shannon {
				return fmt.Errorf("unsupported entropy algorithm: %s. Available algorithms: %s", args[1],
					strings.Join([]string{Shannon}, "|"))
			}
			return nil
		},
	}
	return desc
}

func (f Entropy) Name() Fn { return EntropyFn }

```

`pkg/filter/ql/functions/entropy_test.go`:

```go
/*
 * Copyright 2021-2022 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package functions

import (
	"testing"

	"github.com/stretchr/testify/assert"
)

func TestEntropy(t *testing.T) {
	call := Entropy{}
	res, _ := call.Call([]interface{}{"\\Device\\HarddiskVolume2\\Windows\\system32\\user32.dll"})
	assert.Equal(t, 255, res)
}

```

`pkg/filter/ql/functions/ext.go`:

```go
/*
 * Copyright 2021-2022 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package functions

import "path/filepath"

// Ext returns the file name extension used by the path.
type Ext struct{}

func (f Ext) Call(args []interface{}) (interface{}, bool) {
	if len(args) < 1 {
		return false, false
	}
	path := parseString(0, args)
	ext := filepath.Ext(path)
	if len(args) > 1 {
		dot, ok := args[1].(bool)
		if !ok {
			return ext, true
		}
		if !dot {
			return ext[1:], true
		}
	}
	return ext, true
}

func (f Ext) Desc() FunctionDesc {
	desc := FunctionDesc{
		Name: ExtFn,
		Args: []FunctionArgDesc{
			{Keyword: "path", Types: []ArgType{Field, BoundField, Func, BoundSegment, BareBoundVariable, String}, Required: true},
			{Keyword: "dot", Types: []ArgType{Bool}, Required: false},
		},
	}
	return desc
}

func (f Ext) Name() Fn { return ExtFn }

```

`pkg/filter/ql/functions/ext_test.go`:

```go
/*
 * Copyright 2021-2022 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package functions

import (
	"fmt"
	"github.com/stretchr/testify/assert"
	"testing"
)

func TestExt(t *testing.T) {
	var tests = []struct {
		args     []interface{}
		expected interface{}
	}{
		{
			[]interface{}{"C:\\Windows\\cmd.exe"},
			".exe",
		},
		{
			[]interface{}{"C:\\Windows\\cmd.exe", false},
			"exe",
		},
	}

	for i, tt := range tests {
		f := Ext{}
		res, _ := f.Call(tt.args)
		assert.Equal(t, tt.expected, res, fmt.Sprintf("%d. result mismatch: exp=%v got=%v", i, tt.expected, res))
	}
}

```

`pkg/filter/ql/functions/get_reg_value.go`:

```go
/*
 * Copyright 2021-2022 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package functions

import (
	"golang.org/x/sys/windows/registry"
	"path/filepath"
	"strings"
)

// GetRegValue retrieves the content of the registry value.
type GetRegValue struct{}

func (f GetRegValue) Call(args []interface{}) (interface{}, bool) {
	if len(args) < 1 {
		return false, false
	}
	path := parseString(0, args)
	n := strings.Index(path, "\\")
	if n > 0 {
		rootKey := path[:n]
		subkey, value := filepath.Split(path[n+1:])
		key, err := registry.OpenKey(keyFromString(rootKey), subkey, registry.QUERY_VALUE)
		if err != nil {
			return nil, true
		}
		defer key.Close()
		b := make([]byte, 0)
		_, typ, err := key.GetValue(value, b)
		if err != nil {
			return nil, true
		}
		var val interface{}
		switch typ {
		case registry.SZ, registry.EXPAND_SZ:
			val, _, err = key.GetStringValue(value)
		case registry.MULTI_SZ:
			val, _, err = key.GetStringsValue(value)
		case registry.DWORD:
			val, _, err = key.GetIntegerValue(value)
			if err == nil {
				val = uint32(val.(uint64))
			}
		case registry.QWORD:
			val, _, err = key.GetIntegerValue(value)
		case registry.BINARY:
			val, _, err = key.GetBinaryValue(value)
		}
		if err != nil {
			return nil, true
		}
		return val, true
	}
	return nil, true
}

func (f GetRegValue) Desc() FunctionDesc {
	desc := FunctionDesc{
		Name: GetRegValueFn,
		Args: []FunctionArgDesc{
			{Keyword: "path", Types: []ArgType{Field, BoundField, String, BoundSegment, BareBoundVariable, Func}, Required: true},
		},
	}
	return desc
}

func (f GetRegValue) Name() Fn { return GetRegValueFn }

func keyFromString(k string) registry.Key {
	switch strings.ToUpper(k) {
	case "HKEY_LOCAL_MACHINE", "HKLM":
		return registry.LOCAL_MACHINE
	case "HKEY_CURRENT_USER", "HKCU":
		return registry.CURRENT_USER
	case "HKEY_USERS", "HKU":
		return registry.USERS
	case "HKEY_CLASSES_ROOT", "HKCR":
		return registry.CLASSES_ROOT
	case "HKEY_CURRENT_CONFIG", "HKCC":
		return registry.CURRENT_CONFIG
	case "HKEY_PERFORMANCE_DATA", "HKPD":
		return registry.PERFORMANCE_DATA
	default:
		return registry.Key(0)
	}
}

```

`pkg/filter/ql/functions/get_reg_value_test.go`:

```go
/*
 * Copyright 2021-2022 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package functions

import (
	"fmt"
	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/require"
	"golang.org/x/sys/windows/registry"
	"testing"
)

func TestGetRegValue(t *testing.T) {
	var tests = []struct {
		args     []interface{}
		expected interface{}
	}{
		{
			[]interface{}{"HKCU\\Volatile Environment\\FibratusTestDword"},
			uint32(1),
		},
		{
			[]interface{}{"HKEY_CURRENT_USER\\Volatile Environment\\FibratusTestQword"},
			uint64(1000),
		},
		{
			[]interface{}{"HKCU\\Volatile Environment\\FibratusTestSz"},
			"fibratus",
		},
		{
			[]interface{}{"HKCU\\Volatile Environment\\FibratusTestMultiSz"},
			[]string{"fibratus", "tracing"},
		},
		{
			[]interface{}{"HKCU\\Volatile Environment\\FibratusTestExpandSz"},
			"%SYSTEMROOT%\\fibratus",
		},
	}

	key, err := registry.OpenKey(registry.CURRENT_USER, "Volatile Environment", registry.SET_VALUE)
	require.NoError(t, err)
	defer key.Close()

	defer func() {
		_ = key.DeleteValue("FibratusTestDword")
		_ = key.DeleteValue("FibratusTestQword")
		_ = key.DeleteValue("FibratusTestSz")
		_ = key.DeleteValue("FibratusTestMultiSz")
		_ = key.DeleteValue("FibratusTestExpandSz")
	}()

	require.NoError(t, key.SetDWordValue("FibratusTestDword", 1))
	require.NoError(t, key.SetQWordValue("FibratusTestQword", 1000))
	require.NoError(t, key.SetStringValue("FibratusTestSz", "fibratus"))
	require.NoError(t, key.SetStringsValue("FibratusTestMultiSz", []string{"fibratus", "tracing"}))
	require.NoError(t, key.SetExpandStringValue("FibratusTestExpandSz", "%SYSTEMROOT%\\fibratus"))

	for i, tt := range tests {
		f := GetRegValue{}
		res, _ := f.Call(tt.args)
		assert.Equal(t, tt.expected, res, fmt.Sprintf("%d. result mismatch: exp=%v got=%v", i, tt.expected, res))
	}
}

```

`pkg/filter/ql/functions/glob.go`:

```go
/*
 * Copyright 2021-2022 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package functions

import (
	"path/filepath"
)

// Glob returns the names of all files matching the pattern or an empty list if there is no matching file.
type Glob struct{}

func (f Glob) Call(args []interface{}) (interface{}, bool) {
	if len(args) < 1 {
		return false, false
	}
	pattern := parseString(0, args)
	matches, err := filepath.Glob(pattern)
	if err != nil {
		return nil, true
	}
	return matches, true
}

func (f Glob) Desc() FunctionDesc {
	desc := FunctionDesc{
		Name: GlobFn,
		Args: []FunctionArgDesc{
			{Keyword: "pattern", Types: []ArgType{Field, BoundField, Func, BoundSegment, BareBoundVariable, String}, Required: true},
		},
	}
	return desc
}

func (f Glob) Name() Fn { return GlobFn }

```

`pkg/filter/ql/functions/glob_test.go`:

```go
/*
 * Copyright 2021-2022 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package functions

import (
	"github.com/stretchr/testify/assert"
	"testing"
)

func TestGlob(t *testing.T) {
	call := Glob{}
	res, _ := call.Call([]interface{}{"C:\\Windows\\*.exe"})
	assert.IsType(t, []string{}, res)
	assert.Contains(t, res, "C:\\Windows\\notepad.exe")
}

```

`pkg/filter/ql/functions/indexof.go`:

```go
/*
 * Copyright 2021-2022 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package functions

import (
	"fmt"
	"strings"
)

// IndexPosition is the type alias for the string position search order
type IndexPosition uint8

const (
	UnknownIndex IndexPosition = iota
	FirstIndex                 // Index
	AnyIndex                   // IndexAny
	LastIndex                  // LastIndex
	LastAnyIndex               // LastIndexAny
)

var indexMappings = map[string]IndexPosition{
	"first":   FirstIndex,
	"any":     AnyIndex,
	"last":    LastIndex,
	"lastany": LastAnyIndex,
}

func indexFromString(s string) IndexPosition { return indexMappings[s] }

// IndexOf returns the index of the instance of substring in a given string
// depending on the provided search order.
type IndexOf struct{}

func (f IndexOf) Call(args []interface{}) (interface{}, bool) {
	if len(args) < 2 {
		return false, false
	}
	str := parseString(0, args)
	substr := parseString(1, args)
	if len(args) == 2 {
		return strings.Index(str, substr), true
	}
	// index search order
	switch indexFromString(parseString(2, args)) {
	case FirstIndex:
		return strings.Index(str, substr), true
	case AnyIndex:
		return strings.IndexAny(str, substr), true
	case LastIndex:
		return strings.LastIndex(str, substr), true
	case LastAnyIndex:
		return strings.LastIndexAny(str, substr), true
	default:
		return false, false
	}
}

func (f IndexOf) Desc() FunctionDesc {
	desc := FunctionDesc{
		Name: IndexOfFn,
		Args: []FunctionArgDesc{
			{Keyword: "string", Types: []ArgType{Field, BoundField, BoundSegment, BareBoundVariable, Func}, Required: true},
			{Keyword: "substr", Types: []ArgType{String, Func}, Required: true},
			{Keyword: "index", Types: []ArgType{String}},
		},
		ArgsValidationFunc: func(args []string) error {
			if len(args) == 2 {
				return nil
			}
			if len(args) == 3 && indexFromString(args[2]) == UnknownIndex {
				return fmt.Errorf("%s is not a valid index search order. Available options are: first,any,last,lastany", args[2])
			}
			return nil
		},
	}
	return desc
}

func (f IndexOf) Name() Fn { return IndexOfFn }

```

`pkg/filter/ql/functions/indexof_test.go`:

```go
/*
 * Copyright 2021-2022 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package functions

import (
	"fmt"
	"testing"

	"github.com/stretchr/testify/assert"
)

func TestIndexOf(t *testing.T) {
	var tests = []struct {
		args     []interface{}
		expected interface{}
	}{
		{
			[]interface{}{"hello world", "world"},
			6,
		},
		{
			[]interface{}{"hello world", "brave"},
			-1,
		},
		{
			[]interface{}{"hello world brave world", "world", "last"},
			18,
		},
	}

	for i, tt := range tests {
		f := IndexOf{}
		res, _ := f.Call(tt.args)
		assert.Equal(t, tt.expected, res, fmt.Sprintf("%d. result mismatch: exp=%v got=%v", i, tt.expected, res))
	}
}

```

`pkg/filter/ql/functions/is_abs.go`:

```go
/*
 * Copyright 2021-2022 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package functions

import "path/filepath"

// IsAbs reports whether the path is absolute.
type IsAbs struct{}

func (f IsAbs) Call(args []interface{}) (interface{}, bool) {
	if len(args) < 1 {
		return false, false
	}
	path := parseString(0, args)
	return filepath.IsAbs(path), true
}

func (f IsAbs) Desc() FunctionDesc {
	desc := FunctionDesc{
		Name: IsAbsFn,
		Args: []FunctionArgDesc{
			{Keyword: "path", Types: []ArgType{Field, BoundField, Func, BoundSegment, BareBoundVariable, String}, Required: true},
		},
	}
	return desc
}

func (f IsAbs) Name() Fn { return IsAbsFn }

```

`pkg/filter/ql/functions/is_abs_test.go`:

```go
/*
 * Copyright 2021-2022 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package functions

import (
	"github.com/stretchr/testify/assert"
	"testing"
)

func TestIsAbs(t *testing.T) {
	call := IsAbs{}
	res, _ := call.Call([]interface{}{"C:\\Windows\\cmd.exe"})
	assert.True(t, res.(bool))
	res1, _ := call.Call([]interface{}{"Windows\\cmd.exe"})
	assert.False(t, res1.(bool))
}

```

`pkg/filter/ql/functions/length.go`:

```go
/*
 * Copyright 2021-2022 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package functions

// Length returns the number of characters (runes) for string arguments and
// the size of the slice for slice arguments.
type Length struct{}

func (f Length) Call(args []interface{}) (interface{}, bool) {
	if len(args) < 1 {
		return false, false
	}
	switch s := args[0].(type) {
	case string:
		return len([]rune(s)), true
	case []string:
		return len(s), true
	}
	return -1, false
}

func (f Length) Desc() FunctionDesc {
	desc := FunctionDesc{
		Name: LengthFn,
		Args: []FunctionArgDesc{
			{Keyword: "string|slice", Types: []ArgType{Field, BoundField, BoundSegment, BareBoundVariable, Slice, Func}, Required: true},
		},
	}
	return desc
}

func (f Length) Name() Fn { return LengthFn }

```

`pkg/filter/ql/functions/length_test.go`:

```go
/*
 * Copyright 2021-2022 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package functions

import (
	"fmt"
	"testing"

	"github.com/stretchr/testify/assert"
)

func TestLength(t *testing.T) {
	var tests = []struct {
		args     []interface{}
		expected interface{}
	}{
		{
			[]interface{}{"hello"},
			5,
		},
		{
			[]interface{}{"こんにちは"},
			5,
		},
		{
			[]interface{}{[]string{"hello", "world"}},
			2,
		},
	}

	for i, tt := range tests {
		f := Length{}
		res, _ := f.Call(tt.args)
		assert.Equal(t, tt.expected, res, fmt.Sprintf("%d. result mismatch: exp=%v got=%v", i, tt.expected, res))
	}
}

```

`pkg/filter/ql/functions/lower.go`:

```go
/*
 * Copyright 2021-2022 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package functions

import "strings"

// Lower converts the string with all Unicode letters mapped to their lower case.
type Lower struct{}

func (f Lower) Call(args []interface{}) (interface{}, bool) {
	if len(args) < 1 {
		return false, false
	}
	s := parseString(0, args)
	return strings.ToLower(s), true
}

func (f Lower) Desc() FunctionDesc {
	desc := FunctionDesc{
		Name: LowerFn,
		Args: []FunctionArgDesc{
			{Keyword: "string", Types: []ArgType{String, Field, BoundField, BoundSegment, BareBoundVariable, Func}, Required: true},
		},
	}
	return desc
}

func (f Lower) Name() Fn { return LowerFn }

```

`pkg/filter/ql/functions/lower_test.go`:

```go
/*
 * Copyright 2021-2022 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package functions

import (
	"testing"

	"github.com/stretchr/testify/assert"
)

func TestLower(t *testing.T) {
	call := Lower{}
	res, _ := call.Call([]interface{}{"HellO World"})
	assert.Equal(t, "hello world", res)
}

```

`pkg/filter/ql/functions/ltrim.go`:

```go
/*
 * Copyright 2021-2022 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package functions

import "strings"

// Ltrim trims the specified prefix from a string.
type Ltrim struct{}

func (f Ltrim) Call(args []interface{}) (interface{}, bool) {
	if len(args) < 2 {
		return false, false
	}
	s := parseString(0, args)
	prefix := parseString(1, args)
	return strings.TrimPrefix(s, prefix), true
}

func (f Ltrim) Desc() FunctionDesc {
	desc := FunctionDesc{
		Name: LtrimFn,
		Args: []FunctionArgDesc{
			{Keyword: "string", Types: []ArgType{String, Field, BoundField, BoundSegment, BareBoundVariable, Func}, Required: true},
			{Keyword: "prefix", Types: []ArgType{String, Func}, Required: true},
		},
	}
	return desc
}

func (f Ltrim) Name() Fn { return LtrimFn }

```

`pkg/filter/ql/functions/ltrim_test.go`:

```go
/*
 * Copyright 2021-2022 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package functions

import (
	"testing"

	"github.com/stretchr/testify/assert"
)

func TestLtrim(t *testing.T) {
	call := Ltrim{}
	res, _ := call.Call([]interface{}{"hello world", "hello "})
	assert.Equal(t, "world", res)
}

```

`pkg/filter/ql/functions/md5.go`:

```go
/*
 * Copyright 2020-2021 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package functions

import (
	"crypto/md5"
	"encoding/hex"
)

// MD5 computes the MD5 hash of the given value.
type MD5 struct{}

func (f MD5) Call(args []interface{}) (interface{}, bool) {
	if len(args) != 1 {
		return false, false
	}

	var data []byte
	switch v := args[0].(type) {
	case []byte:
		data = v
	case string:
		data = []byte(v)
	}

	if data == nil {
		return false, false
	}

	hash := md5.Sum(data)
	return hex.EncodeToString(hash[:]), true
}

func (f MD5) Desc() FunctionDesc {
	return FunctionDesc{
		Name: MD5Fn,
		Args: []FunctionArgDesc{
			{Keyword: "data", Types: []ArgType{Field, String, BoundField, BoundSegment, BareBoundVariable, Func}, Required: true},
		},
	}
}

func (f MD5) Name() Fn { return MD5Fn }

```

`pkg/filter/ql/functions/md5_test.go`:

```go
/*
 * Copyright 2020-2021 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package functions

import (
	"github.com/stretchr/testify/assert"
	"testing"
)

func TestMD5Call(t *testing.T) {
	call := MD5{}

	res, _ := call.Call([]interface{}{`HKEY_LOCAL_MACHINE\SYSTEM\Setup\Pid`})
	assert.Equal(t, "eab870b2a516206575d2ffa2b98d8af5", res)
}

func TestMD5Desc(t *testing.T) {
	call := MD5{}
	desc := call.Desc()

	assert.Equal(t, desc.RequiredArgs(), 1)
	assert.Len(t, desc.Args, 1)
}

```

`pkg/filter/ql/functions/minidump.go`:

```go
/*
 * Copyright 2021-2022 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package functions

import (
	"encoding/binary"
	"io"
	"os"
)

// The 4-byte magic number at the start of a minidump file
const minidumpSignature = 1347241037

// IsMinidump determines if the specified file contains the minidump signature.
type IsMinidump struct{}

func (f IsMinidump) Call(args []interface{}) (interface{}, bool) {
	if len(args) < 1 {
		return false, false
	}
	path := parseString(0, args)

	file, err := os.Open(path)
	if err != nil {
		return false, true
	}
	defer file.Close()

	var header [4]byte
	_, err = io.ReadFull(file, header[:])
	if err != nil {
		return false, true
	}
	isMinidumpSignature := binary.LittleEndian.Uint32(header[:]) == minidumpSignature
	return isMinidumpSignature, true
}

func (f IsMinidump) Desc() FunctionDesc {
	desc := FunctionDesc{
		Name: IsMinidumpFn,
		Args: []FunctionArgDesc{
			{Keyword: "path", Types: []ArgType{String, Field, BoundField, BoundSegment, BareBoundVariable, Func}, Required: true},
		},
	}
	return desc
}

func (f IsMinidump) Name() Fn { return IsMinidumpFn }

```

`pkg/filter/ql/functions/regex.go`:

```go
/*
 * Copyright 2021-2022 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package functions

import (
	log "github.com/sirupsen/logrus"
	"regexp"
)

// Regex applies single/multiple regular expressions on the provided string arguments.
type Regex struct {
	rxs map[string]*regexp.Regexp
}

// NewRegex creates a new regex function.
func NewRegex() *Regex {
	return &Regex{rxs: make(map[string]*regexp.Regexp)}
}

func (f *Regex) Call(args []interface{}) (interface{}, bool) {
	if len(args) < 2 {
		return false, false
	}
	s := parseString(0, args)

	// match regular expressions
	for _, arg := range args[1:] {
		expr, ok := arg.(string)
		if !ok {
			continue
		}
		rx, ok := f.rxs[expr]
		if !ok {
			var err error
			rx, err = regexp.Compile(expr)
			if err != nil {
				log.Warnf(
					"invalid %q pattern in "+
						"regex function: %v", expr, err)
				f.rxs[expr] = nil
			} else {
				f.rxs[expr] = rx
			}
		}
		if rx == nil {
			continue
		}
		if rx.MatchString(s) {
			return true, true
		}
	}

	return false, true
}

func (f *Regex) Desc() FunctionDesc {
	desc := FunctionDesc{
		Name: RegexFn,
		Args: []FunctionArgDesc{
			{Keyword: "string", Types: []ArgType{Field, BoundField, String, BoundSegment, BareBoundVariable, Func}, Required: true},
			{Keyword: "regexp", Types: []ArgType{String}, Required: true},
		},
	}
	offset := len(desc.Args)
	// add optional regular expression patterns
	for i := offset; i < maxArgs; i++ {
		desc.Args = append(desc.Args, FunctionArgDesc{Keyword: "regexp", Types: []ArgType{String}})
	}
	return desc
}

func (f *Regex) Name() Fn { return RegexFn }

```

`pkg/filter/ql/functions/regex_test.go`:

```go
/*
 * Copyright 2021-2022 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package functions

import (
	"fmt"
	"testing"

	"github.com/stretchr/testify/assert"
)

func TestRegex(t *testing.T) {
	var tests = []struct {
		args     []interface{}
		expected interface{}
	}{
		{
			[]interface{}{`powershell.exe`, `power.*(shell|hell).exe`},
			true,
		},
		{
			[]interface{}{`powershell.exe`, `power.*(shell|hell).dll`, `.*hell.exe`},
			true,
		},
		{
			[]interface{}{`powershell.exe`, "[`"},
			false,
		},
	}

	for i, tt := range tests {
		f := NewRegex()
		res, _ := f.Call(tt.args)
		assert.Equal(t, tt.expected, res, fmt.Sprintf("%d. result mismatch: exp=%v got=%v", i, tt.expected, res))
	}

	call := NewRegex()
	for i := 0; i < 10; i++ {
		res, _ := call.Call([]interface{}{`powershell.exe`, `power.*(shell|hell).dll`, `.*hell.exe`})
		assert.True(t, res.(bool))
	}
}

```

`pkg/filter/ql/functions/replace.go`:

```go
/*
 * Copyright 2021-2022 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package functions

import (
	"errors"
	"fmt"
	"strings"
)

// Replace replaces occurrences in the string as given by arbitrary old/new replacement pairs.
type Replace struct{}

func (f Replace) Call(args []interface{}) (interface{}, bool) {
	if len(args) < 3 {
		return false, false
	}
	s := parseString(0, args)
	// happy path
	if len(args) == 3 {
		o := parseString(1, args)
		n := parseString(2, args)
		return strings.ReplaceAll(s, o, n), true
	}
	// apply multiple replacements
	repl := s
	for i := 1; i < len(args)-1; i += 2 {
		o, ok := args[i].(string)
		if !ok {
			break
		}
		n, ok := args[i+1].(string)
		if !ok {
			break
		}
		repl = strings.ReplaceAll(repl, o, n)
	}
	return repl, true
}

func (f Replace) Desc() FunctionDesc {
	desc := FunctionDesc{
		Name: ReplaceFn,
		Args: []FunctionArgDesc{
			{Keyword: "string", Types: []ArgType{String, Field, BoundField, BoundSegment, BareBoundVariable, Func}, Required: true},
			{Keyword: "old", Types: []ArgType{String, Field, BoundField, BoundSegment, BareBoundVariable, Func}, Required: true},
			{Keyword: "new", Types: []ArgType{String, Field, BoundField, BoundSegment, BareBoundVariable, Func}, Required: true},
		},
		ArgsValidationFunc: func(args []string) error {
			if len(args) == 3 {
				return nil
			}
			if (len(args)-1)%2 != 0 {
				return errors.New("old/new replacements mismatch")
			}
			return nil
		},
	}
	offset := len(desc.Args)
	// add optional old/new pair arguments
	for i := offset; i < maxArgs; i++ {
		desc.Args = append(desc.Args, FunctionArgDesc{Keyword: fmt.Sprintf("old%d", i+1), Types: []ArgType{String, Field, BoundField, Func}})
		desc.Args = append(desc.Args, FunctionArgDesc{Keyword: fmt.Sprintf("new%d", i+1), Types: []ArgType{String, Field, BoundField, Func}})
	}
	return desc
}

func (f Replace) Name() Fn { return ReplaceFn }

```

`pkg/filter/ql/functions/replace_test.go`:

```go
/*
 * Copyright 2021-2022 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package functions

import (
	"fmt"
	"testing"

	"github.com/stretchr/testify/assert"
)

func TestReplace(t *testing.T) {
	var tests = []struct {
		args     []interface{}
		expected interface{}
	}{
		{
			[]interface{}{"hello world", "hello", "hell"},
			"hell world",
		},
		{
			[]interface{}{"hello world", "hello", "hell", "NO", "REPL"},
			"hell world",
		},
		{
			[]interface{}{"hello world", "hello", "hell", "hell", "heaven", "world", "brave"},
			"heaven brave",
		},
		{
			[]interface{}{"HKEY_LOCAL_MACHINE\\SAM", "HKEY_LOCAL_MACHINE", "HKLM", "HKEY_CURRENT_USER\\Console", "HKCU"},
			"HKLM\\SAM",
		},
		{
			[]interface{}{"HKEY_CURRENT_USER\\Console", "HKEY_LOCAL_MACHINE", "HKLM", "HKEY_CURRENT_USER", "HKCU"},
			"HKCU\\Console",
		},
	}

	for i, tt := range tests {
		f := Replace{}
		res, _ := f.Call(tt.args)
		assert.Equal(t, tt.expected, res, fmt.Sprintf("%d. result mismatch: exp=%v got=%v", i, tt.expected, res))
	}
}

```

`pkg/filter/ql/functions/rtrim.go`:

```go
/*
 * Copyright 2021-2022 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package functions

import "strings"

// Rtrim trims the specified suffix from a string.
type Rtrim struct{}

func (f Rtrim) Call(args []interface{}) (interface{}, bool) {
	if len(args) < 2 {
		return false, false
	}
	s := parseString(0, args)
	suffix := parseString(1, args)
	return strings.TrimSuffix(s, suffix), true
}

func (f Rtrim) Desc() FunctionDesc {
	desc := FunctionDesc{
		Name: LtrimFn,
		Args: []FunctionArgDesc{
			{Keyword: "string", Types: []ArgType{String, Field, BoundField, BoundSegment, BareBoundVariable, Func}, Required: true},
			{Keyword: "suffix", Types: []ArgType{String, Func}, Required: true},
		},
	}
	return desc
}

func (f Rtrim) Name() Fn { return RtrimFn }

```

`pkg/filter/ql/functions/rtrim_test.go`:

```go
/*
 * Copyright 2021-2022 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package functions

import (
	"testing"

	"github.com/stretchr/testify/assert"
)

func TestRtrim(t *testing.T) {
	call := Rtrim{}
	res, _ := call.Call([]interface{}{"hello world", " world"})
	assert.Equal(t, "hello", res)
}

```

`pkg/filter/ql/functions/split.go`:

```go
/*
 * Copyright 2021-2022 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package functions

import (
	"strings"
)

// Split produces a slice of substrings separated by the given delimiter.
type Split struct{}

func (f Split) Call(args []interface{}) (interface{}, bool) {
	if len(args) < 2 {
		return false, false
	}
	s := parseString(0, args)
	sep := parseString(1, args)
	return strings.Split(s, sep), true
}

func (f Split) Desc() FunctionDesc {
	desc := FunctionDesc{
		Name: SplitFn,
		Args: []FunctionArgDesc{
			{Keyword: "string", Types: []ArgType{String, Field, BoundField, BoundSegment, BareBoundVariable, Func}, Required: true},
			{Keyword: "sep", Types: []ArgType{String}, Required: true},
		},
	}
	return desc
}

func (f Split) Name() Fn { return SplitFn }

```

`pkg/filter/ql/functions/split_test.go`:

```go
/*
 * Copyright 2021-2022 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package functions

import (
	"testing"

	"github.com/stretchr/testify/assert"
)

func TestSplit(t *testing.T) {
	call := Split{}
	res, _ := call.Call([]interface{}{"Hello World", " "})
	assert.IsType(t, []string{}, res)
	s := res.([]string)
	assert.Contains(t, s, "World")
}

```

`pkg/filter/ql/functions/substr.go`:

```go
/*
 * Copyright 2021-2022 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package functions

// Substr creates a substring of a given string.
type Substr struct{}

func (f Substr) Call(args []interface{}) (interface{}, bool) {
	if len(args) < 2 {
		return false, false
	}

	s := parseString(0, args)

	var start int
	var end int

	switch v := args[1].(type) {
	case int:
		start = v
	case int64:
		start = int(v)
	default:
		return false, false
	}

	if len(args) > 2 {
		switch v := args[2].(type) {
		case int:
			end = v
		case int64:
			end = int(v)
		default:
			return false, false
		}

		if start >= 0 && (end >= start && end < len(s)) {
			return s[start:end], true
		}
	} else {
		if start >= 0 && start < len(s) {
			return s[start:], true
		}
	}

	return s, true
}

func (f Substr) Desc() FunctionDesc {
	desc := FunctionDesc{
		Name: SubstrFn,
		Args: []FunctionArgDesc{
			{Keyword: "string", Types: []ArgType{Func, Field, BoundField, BoundSegment, BareBoundVariable}, Required: true},
			{Keyword: "start", Types: []ArgType{Func, Number}, Required: true},
			{Keyword: "end", Types: []ArgType{Func, Number}},
		},
	}
	return desc
}

func (f Substr) Name() Fn { return SubstrFn }

```

`pkg/filter/ql/functions/substr_test.go`:

```go
/*
 * Copyright 2021-2022 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package functions

import (
	"fmt"
	"testing"

	"github.com/stretchr/testify/assert"
)

func TestSubstr(t *testing.T) {
	var tests = []struct {
		args     []interface{}
		expected interface{}
	}{
		{
			[]interface{}{"Hello", 0, 4},
			"Hell",
		},
		{
			[]interface{}{"Hello World!", 0, 50},
			"Hello World!",
		},
		{
			[]interface{}{"Hello World!", 4, -1},
			"Hello World!",
		},
		{
			[]interface{}{"Hello World!", -1, 10},
			"Hello World!",
		},
		{
			[]interface{}{"Hello World!", 6, 7},
			"W",
		},
		{
			[]interface{}{"Hello World!", 6},
			"World!",
		},
		{
			[]interface{}{"Hello World!", 20},
			"Hello World!",
		},
	}

	for i, tt := range tests {
		f := Substr{}
		res, _ := f.Call(tt.args)
		assert.Equal(t, tt.expected, res, fmt.Sprintf("%d. result mismatch: exp=%v got=%v", i, tt.expected, res))
	}
}

```

`pkg/filter/ql/functions/symlink.go`:

```go
/*
 * Copyright 2021-2022 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package functions

import "path/filepath"

// Symlink returns the path name after the evaluation of any symbolic links.
type Symlink struct{}

func (f Symlink) Call(args []interface{}) (interface{}, bool) {
	if len(args) < 1 {
		return false, false
	}
	path := parseString(0, args)
	newpath, err := filepath.EvalSymlinks(path)
	if err != nil {
		return path, true
	}
	return newpath, true
}

func (f Symlink) Desc() FunctionDesc {
	desc := FunctionDesc{
		Name: SymlinkFn,
		Args: []FunctionArgDesc{
			{Keyword: "path", Types: []ArgType{Field, BoundField, BoundSegment, BareBoundVariable, Func, String}, Required: true},
		},
	}
	return desc
}

func (f Symlink) Name() Fn { return SymlinkFn }

```

`pkg/filter/ql/functions/symlink_test.go`:

```go
/*
 * Copyright 2021-2022 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package functions

import (
	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/require"
	"os"
	"path/filepath"
	"testing"
)

var testDir = filepath.Join(os.TempDir(), "test")

func TestSymlink(t *testing.T) {
	ln, err := createSymlink()
	require.NoError(t, err)
	call := Symlink{}
	res, _ := call.Call([]interface{}{ln})
	defer func() {
		_ = os.RemoveAll(testDir)
	}()
	assert.Equal(t, "target.txt", filepath.Base(res.(string)))
}

func createSymlink() (string, error) {
	target := "target.txt"
	if err := os.MkdirAll(testDir, 0755); err != nil {
		return "", err
	}
	if err := os.WriteFile(filepath.Join(testDir, "target.txt"), []byte("Test\n"), os.ModePerm); err != nil {
		return "", err
	}
	symlink := filepath.Join(testDir, "symlink.txt")
	return symlink, os.Symlink(target, symlink)
}

```

`pkg/filter/ql/functions/types.go`:

```go
/*
 * Copyright 2020-2021 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package functions

const maxArgs = 1 << 5

// Fn is the type alias for function definitions.
type Fn uint16

const (
	// CIDRContainsFn identifies the CIDR_CONTAINS function
	CIDRContainsFn Fn = iota + 1
	// MD5Fn represents the MD5 function
	MD5Fn
	// ConcatFn represents the CONCAT function
	ConcatFn
	// LtrimFn represents the LTRIM function
	LtrimFn
	// RtrimFn represents the RTRIM function
	RtrimFn
	// LowerFn represents the LOWER function
	LowerFn
	// UpperFn represents the UPPER function
	UpperFn
	// ReplaceFn represents the REPLACE function
	ReplaceFn
	// SplitFn represents the SPLIT function
	SplitFn
	// LengthFn represents the LENGTH function
	LengthFn
	// IndexOfFn represents the INDEXOF function
	IndexOfFn
	// SubstrFn represents the SUBSTR function
	SubstrFn
	// EntropyFn represents the ENTROPY function
	EntropyFn
	// RegexFn represents the REGEX function
	RegexFn
	// IsMinidumpFn represents the ISMINIDUMP function
	IsMinidumpFn
	// BaseFn represents the BASE function
	BaseFn
	// DirFn represents the DIR function
	DirFn
	// SymlinkFn represents the SYMLINK function
	SymlinkFn
	// ExtFn represents the EXT function
	ExtFn
	// GlobFn represents the GLOB function
	GlobFn
	// IsAbsFn represents the IS_ABS function
	IsAbsFn
	// VolumeFn represents the VOLUME function
	VolumeFn
	// GetRegValueFn represents the GET_REG_VALUE function
	GetRegValueFn
	// YaraFn represents the YARA function
	YaraFn
	// ForeachFn represents the FOREACH function
	ForeachFn
	// CountFn reprsents the COUNT function
	CountFn
)

// ArgType is the type alias for the argument value type.
type ArgType uint8

// ArgsValidation is a function for the custom argument validation logic.
type ArgsValidation func(args []string) error

const (
	// String represents the string argument type.
	String ArgType = iota
	// Number represents the scalar argument type.
	Number
	// IP represents the IP argument type.
	IP
	// Field represents the argument type that is derived
	// from the field literal. Field literal values can
	// be simple primitive types.
	Field
	// Func represents the argument type that is derived
	// from the function return value.
	Func
	// Slice represents the string slice argument type.
	Slice
	// Bool represents the boolean argument type.
	Bool
	// Expression represents the raw expression argument type.
	Expression
	// BoundField represents the bound field argument type.
	BoundField
	// BoundSegment represents the bound segment argument type.
	BoundSegment
	// BareBoundVariable represents the bare bound variable argument type.
	BareBoundVariable
	// Unknown is the unknown argument type.
	Unknown
)

// String returns the argument type as a string value.
func (typ ArgType) String() string {
	switch typ {
	case String:
		return "string"
	case Number:
		return "number"
	case IP:
		return "ip"
	case Field:
		return "field"
	case Func:
		return "func"
	case Slice:
		return "slice"
	case Bool:
		return "bool"
	case Expression:
		return "expression"
	case BoundField:
		return "boundfield"
	case BoundSegment:
		return "boundsegment"
	case BareBoundVariable:
		return "bareboundvar"
	}
	return "unknown"
}

// FunctionDesc contains the function signature that
// particular filter function has to satisfy.
type FunctionDesc struct {
	Name               Fn
	Args               []FunctionArgDesc
	ArgsValidationFunc ArgsValidation
}

// RequiredArgs returns the number of the required function args.
func (f FunctionDesc) RequiredArgs() int {
	var nargs int
	for _, arg := range f.Args {
		if arg.Required {
			nargs++
		}
	}
	return nargs
}

// FunctionArgDesc described each function argument.
type FunctionArgDesc struct {
	Keyword  string
	Required bool
	Types    []ArgType
}

// ContainsType returns true if the argument satisfies the given argument type.
func (arg FunctionArgDesc) ContainsType(typ ArgType) bool {
	for _, t := range arg.Types {
		if t == typ {
			return true
		}
	}
	return false
}

// String returns the function name in upper case.
func (f Fn) String() string {
	switch f {
	case CIDRContainsFn:
		return "CIDR_CONTAINS"
	case MD5Fn:
		return "MD5"
	case ConcatFn:
		return "CONCAT"
	case LtrimFn:
		return "LTRIM"
	case RtrimFn:
		return "RTRIM"
	case LowerFn:
		return "LOWER"
	case UpperFn:
		return "UPPER"
	case ReplaceFn:
		return "REPLACE"
	case SplitFn:
		return "SPLIT"
	case LengthFn:
		return "LENGTH"
	case IndexOfFn:
		return "INDEXOF"
	case SubstrFn:
		return "SUBSTR"
	case EntropyFn:
		return "ENTROPY"
	case RegexFn:
		return "REGEX"
	case IsMinidumpFn:
		return "IS_MINIDUMP"
	case BaseFn:
		return "BASE"
	case DirFn:
		return "DIR"
	case ExtFn:
		return "EXT"
	case GlobFn:
		return "GLOB"
	case IsAbsFn:
		return "IS_ABS"
	case VolumeFn:
		return "VOLUME"
	case GetRegValueFn:
		return "GET_REG_VALUE"
	case YaraFn:
		return "YARA"
	case ForeachFn:
		return "FOREACH"
	case CountFn:
		return "COUNT"
	default:
		return "UNDEFINED"
	}
}

// parseString yields a string value from the specific position in the args slice.
func parseString(index int, args []interface{}) string {
	if index > len(args)-1 {
		return ""
	}
	s, ok := args[index].(string)
	if !ok {
		return ""
	}
	return s
}

```

`pkg/filter/ql/functions/upper.go`:

```go
/*
 * Copyright 2021-2022 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package functions

import "strings"

// Upper converts the string with all Unicode letters mapped to their upper case.
type Upper struct{}

func (f Upper) Call(args []interface{}) (interface{}, bool) {
	if len(args) < 1 {
		return false, false
	}
	s := parseString(0, args)
	return strings.ToUpper(s), true
}

func (f Upper) Desc() FunctionDesc {
	desc := FunctionDesc{
		Name: UpperFn,
		Args: []FunctionArgDesc{
			{Keyword: "string", Types: []ArgType{String, Field, BoundField, BoundSegment, BareBoundVariable, Func}, Required: true},
		},
	}
	return desc
}

func (f Upper) Name() Fn { return UpperFn }

```

`pkg/filter/ql/functions/upper_test.go`:

```go
/*
 * Copyright 2021-2022 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package functions

import (
	"testing"

	"github.com/stretchr/testify/assert"
)

func TestUpper(t *testing.T) {
	call := Upper{}
	res, _ := call.Call([]interface{}{"HellO World"})
	assert.Equal(t, "HELLO WORLD", res)
}

```

`pkg/filter/ql/functions/volume.go`:

```go
/*
 * Copyright 2021-2022 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package functions

import "path/filepath"

// Volume returns leading volume name.
type Volume struct{}

func (f Volume) Call(args []interface{}) (interface{}, bool) {
	if len(args) < 1 {
		return false, false
	}
	path := parseString(0, args)
	return filepath.VolumeName(path), true
}

func (f Volume) Desc() FunctionDesc {
	desc := FunctionDesc{
		Name: VolumeFn,
		Args: []FunctionArgDesc{
			{Keyword: "path", Types: []ArgType{Field, BoundField, BoundSegment, BareBoundVariable, Func, String}, Required: true},
		},
	}
	return desc
}

func (f Volume) Name() Fn { return VolumeFn }

```

`pkg/filter/ql/functions/volume_test.go`:

```go
/*
 * Copyright 2021-2022 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package functions

import (
	"github.com/stretchr/testify/assert"
	"testing"
)

func TestVolume(t *testing.T) {
	call := Volume{}
	res, _ := call.Call([]interface{}{"C:\\Windows\\cmd.exe"})
	assert.Equal(t, "C:", res)
	res1, _ := call.Call([]interface{}{`\\host\share\docs`})
	assert.Equal(t, "\\\\host\\share", res1)
}

```

`pkg/filter/ql/functions/yara.go`:

```go
//go:build yara
// +build yara

/*
 * Copyright 2021-2022 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package functions

import (
	"fmt"
	"github.com/hillu/go-yara/v4"
	"github.com/rabbitstack/fibratus/pkg/util/multierror"
	log "github.com/sirupsen/logrus"
	"strings"
	"time"
)

// scanTimeout specifies the timeout interval for the scan operation
var scanTimeout = time.Second * 10

// Yara provides signature-based detection in filters and rules.
// YARA is a tool aimed at (but not limited to) helping malware
// researchers to identify and classify malware samples. With YARA
// you can create descriptions of malware families based on textual
// or binary patterns. Depending on the parameter type supplied to this
// function, the scan can be performed on the process, filename or a
// memory block.
type Yara struct{}

func (f Yara) Call(args []interface{}) (interface{}, bool) {
	if len(args) < 2 {
		return false, false
	}
	var rules string
	var vars map[string]interface{}
	switch r := args[1].(type) {
	case string:
		rules = r
	case []string:
		rules = strings.Join(r, " ")
	}
	if len(args) > 3 {
		vars, _ = args[2].(map[string]interface{})
	}
	scanner, err := f.newScanner(rules, vars)
	if err != nil {
		log.Warnf("erroneous scanner in YARA function: %v: %s", err, rules)
		return false, true
	}

	var cb yara.MatchRules
	switch n := args[0].(type) {
	case uint32: // pid
		err = scanner.SetCallback(&cb).ScanProc(int(n))
	case string: // file
		err = scanner.SetCallback(&cb).ScanFile(n)
	case []byte: // mem block
		err = scanner.SetCallback(&cb).ScanMem(n)
	default: // invalid type
		return false, false
	}
	if err != nil {
		log.Warnf("YARA function scan failed: %v", err)
		return false, true
	}
	if len(cb) > 0 {
		log.Debugf("YARA function produced %d match(es)", len(cb))
		for _, match := range cb {
			log.Debugf("Matched YARA rule: %s", match.Rule)
		}
	}
	return len(cb) > 0, true
}

func (f Yara) Desc() FunctionDesc {
	desc := FunctionDesc{
		Name: YaraFn,
		Args: []FunctionArgDesc{
			{Keyword: "pid|file|bytes", Types: []ArgType{Field, BoundField, BoundSegment, BareBoundVariable, Func, String, Number}, Required: true},
			{Keyword: "rules", Types: []ArgType{Field, BoundField, Func, String}, Required: true},
			{Keyword: "vars", Types: []ArgType{Field, BoundField, Func, String}},
		},
	}
	return desc
}

func (f Yara) Name() Fn { return YaraFn }

func (f Yara) newScanner(rules string, vars map[string]interface{}) (*yara.Scanner, error) {
	c, err := yara.NewCompiler()
	if err != nil {
		return nil, err
	}
	if err := c.AddString(rules, ""); err != nil {
		return nil, err
	}
	for k, v := range vars {
		if err := c.DefineVariable(k, v); err != nil {
			return nil, err
		}
	}
	if len(c.Errors) > 0 {
		return nil, parseCompilerErrors(c.Errors)
	}
	r, err := c.GetRules()
	if err != nil {
		return nil, err
	}
	scanner, err := yara.NewScanner(r)
	if err != nil {
		return nil, err
	}
	scanner.SetFlags(yara.ScanFlagsFastMode)
	scanner.SetTimeout(scanTimeout)
	return scanner, nil
}

func parseCompilerErrors(errors []yara.CompilerMessage) error {
	errs := make([]error, len(errors))
	for i, err := range errors {
		errs[i] = fmt.Errorf("%s, line: %d", err.Text, err.Line)
	}
	return multierror.Wrap(errs...)
}

```

`pkg/filter/ql/functions/yara_test.go`:

```go
//go:build yara
// +build yara

/*
 * Copyright 2021-2022 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package functions

import (
	"fmt"
	"github.com/rabbitstack/fibratus/pkg/sys"
	log "github.com/sirupsen/logrus"
	"github.com/stretchr/testify/assert"
	"golang.org/x/sys/windows"
	"os"
	"path/filepath"
	"testing"
	"time"
)

func init() {
	scanTimeout = time.Minute
}

func TestYara(t *testing.T) {
	pid, proc := runNotepad()
	for {
		if sys.IsProcessRunning(proc) {
			break
		}
		time.Sleep(time.Millisecond * 100)
		log.Infof("%d pid not yet ready", pid)
	}
	defer windows.TerminateProcess(proc, 0)

	var tests = []struct {
		args     []interface{}
		expected bool
	}{
		{
			[]interface{}{pid, `
		rule Notepad : notepad
		{
			meta:
				severity = "Normal"
				date = "2016-07"
			strings:
				$c0 = "Notepad" fullword ascii
			condition:
				$c0
		}
					`},
			true,
		},
		{
			[]interface{}{"_fixtures/yara-test.dll", `
		rule DLL : dll
		{
			meta:
				severity = "Critical"
				date = "2020-07"
			strings:
				$c0 = "Go" fullword ascii
			condition:
				$c0
		}
					`},
			true,
		},
		{
			[]interface{}{readNotepadBytes(), `
rule Notepad : notepad
{
	meta:
		severity = "Normal"
		date = "2016-07"
	strings:
		$c0 = "Notepad" fullword ascii
	condition:
		$c0
}
			`},
			true,
		},
		{
			[]interface{}{pid, `
		rule Notepad : notepad
		{
			meta:
				severity = "Normal"
				date = "2016-07"
			strings:
				$c0 = "Notfound" fullword ascii
			condition:
				$c0
		}
					`},
			false,
		},
	}

	for i, tt := range tests {
		f := Yara{}
		res, _ := f.Call(tt.args)
		assert.Equal(t, tt.expected, res, fmt.Sprintf("%d. result mismatch: exp=%v got=%v", i, tt.expected, res))
	}
}

func runNotepad() (uint32, windows.Handle) {
	var si windows.StartupInfo
	si.Flags = windows.STARTF_USESHOWWINDOW
	si.ShowWindow = windows.SW_HIDE
	var pi windows.ProcessInformation
	argv := windows.StringToUTF16Ptr(filepath.Join(os.Getenv("windir"), "notepad.exe"))
	err := windows.CreateProcess(
		nil,
		argv,
		nil,
		nil,
		false,
		0,
		nil,
		nil,
		&si,
		&pi)
	if err != nil {
		return 0, 0
	}
	return pi.ProcessId, pi.Process
}

func readNotepadBytes() []byte {
	p := filepath.Join(os.Getenv("windir"), "notepad.exe")
	b, err := os.ReadFile(p)
	if err != nil {
		return nil
	}
	return b
}

```

`pkg/filter/ql/functions/yara_unsupported.go`:

```go
//go:build !yara
// +build !yara

/*
 * Copyright 2021-2022 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package functions

import (
	"fmt"
	errs "github.com/rabbitstack/fibratus/pkg/errors"
)

// Yara unsupported function
type Yara struct{}

func (f Yara) Call(args []interface{}) (interface{}, bool) { return false, false }

func (f Yara) Desc() FunctionDesc {
	desc := FunctionDesc{
		Name: YaraFn,
		Args: []FunctionArgDesc{
			{Keyword: "pid|file|bytes", Types: []ArgType{Field, BoundField, Func, String, Number}, Required: true},
			{Keyword: "rules", Types: []ArgType{Field, BoundField, Func, String}, Required: true},
			{Keyword: "vars", Types: []ArgType{Field, BoundField, Func, String}},
		},
		ArgsValidationFunc: func(args []string) error {
			return fmt.Errorf("yara function is not supported. %w", errs.ErrFeatureUnsupported("yara"))
		},
	}
	return desc
}

func (f Yara) Name() Fn { return YaraFn }

```

`pkg/filter/ql/lexer.go`:

```go
/*
 * Copyright 2019-2020 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 *  Copyright (c) 2013-2016 Errplane Inc.
 */

package ql

import (
	"bufio"
	"bytes"
	"errors"
	"io"
	"strconv"
	"strings"
)

// scanner is responsible for splitting up the filter expression into individual tokens. This code is mostly borrowed
// from the influxql repository (https://github.com/influxdata/influxql) with some changes to support the lexing
// of additional tokens such as IP addresses.
type scanner struct {
	r *reader
}

func newScanner(r io.Reader) *scanner {
	return &scanner{r: &reader{r: bufio.NewReader(r)}}
}

// scan returns the next token and position from the underlying reader.
// Also returns the literal text read for strings, numbers, and duration tokens
// since these token types can have different literal representations.
func (s *scanner) scan() (tok token, pos int, lit string) {
	// Read next code point.
	ch0, pos := s.r.read()

	// if we see whitespace then consume all contiguous whitespace.
	// if we see a letter, or certain acceptable special characters, then consume
	// as an ident or reserved word.
	if isWhitespace(ch0) {
		return s.scanWhitespace()
	} else if isLetter(ch0) || ch0 == '_' {
		s.r.unread()
		return s.scanIdent()
	} else if isDigit(ch0) {
		return s.scanNumber()
	}

	// Otherwise, parse individual characters.
	switch ch0 {
	case eof:
		return EOF, pos, ""
	case '"':
		s.r.unread()
		return s.scanIdent()
	case '\'':
		return s.scanString()
	case '.':
		ch1, _ := s.r.read()
		s.r.unread()
		if isDigit(ch1) {
			return s.scanNumber()
		}
		return Dot, pos, ""
	case '=':
		return Eq, pos, ""
	case '~':
		if ch1, _ := s.r.read(); ch1 == '=' {
			return IEq, pos, ""
		}
		s.r.unread()
	case '!':
		if ch1, _ := s.r.read(); ch1 == '=' {
			return Neq, pos, ""
		}
		s.r.unread()
	case '>':
		if ch1, _ := s.r.read(); ch1 == '=' {
			return Gte, pos, ""
		}
		s.r.unread()
		return Gt, pos, ""
	case '<':
		if ch1, _ := s.r.read(); ch1 == '=' {
			return Lte, pos, ""
		} else if ch1 == '>' {
			return Neq, pos, ""
		}
		s.r.unread()
		return Lt, pos, ""
	case '(':
		return Lparen, pos, ""
	case ')':
		return Rparen, pos, ""
	case '|':
		return Pipe, pos, ""
	case ',':
		return Comma, pos, ""
	case '[':
		return LBracket, pos, ""
	case ']':
		return RBracket, pos, ""
	case '$':
		tok, _, lit = s.scanIdent()
		if tok != Ident {
			return tok, pos, "$" + lit
		}
		return BoundVar, pos, "$" + lit
	}
	return Illegal, pos, string(ch0)
}

// scanWhitespace consumes the current rune and all contiguous whitespace.
func (s *scanner) scanWhitespace() (tok token, pos int, lit string) {
	// Create a buffer and read the current character into it.
	var buf bytes.Buffer
	ch, pos := s.r.curr()
	_, _ = buf.WriteRune(ch)

	// Read every subsequent whitespace character into the buffer.
	// Non-whitespace characters and EOF will cause the loop to exit.
	for {
		ch, _ = s.r.read()
		if ch == eof {
			break
		} else if !isWhitespace(ch) {
			s.r.unread()
			break
		} else {
			_, _ = buf.WriteRune(ch)
		}
	}

	return WS, pos, buf.String()
}

func (s *scanner) scanIdent() (tok token, pos int, lit string) {
	// Save the starting position of the identifier.
	_, pos = s.r.read()
	s.r.unread()

	var buf bytes.Buffer
	for {
		if ch, _ := s.r.read(); ch == eof {
			break
		} else if ch == '"' {
			tok0, pos0, lit0 := s.scanString()
			if tok0 == Badstr || tok0 == Badesc {
				return tok0, pos0, lit0
			}
			return Ident, pos, lit0
		} else if isIdentChar(ch) {
			s.r.unread()
			buf.WriteString(scanBareIdent(s.r))
		} else {
			s.r.unread()
			break
		}
	}
	lit = buf.String()

	if tok, lit = lookup(lit); tok != Ident {
		return tok, pos, lit
	}

	return Ident, pos, lit
}

// scanNumber consumes anything that looks like the start of a number.
func (s *scanner) scanNumber() (tok token, pos int, lit string) {
	var buf bytes.Buffer

	// Check if the initial rune is a ".".
	ch, pos := s.r.curr()
	if ch == '.' {
		// Peek and see if the next rune is a digit.
		ch1, _ := s.r.read()
		s.r.unread()
		if !isDigit(ch1) {
			return Illegal, pos, "."
		}
		// Unread the full stop so we can read it later.
		s.r.unread()
	} else {
		s.r.unread()
	}

	// Read as many digits as possible.
	_, _ = buf.WriteString(s.scanDigits())

	// If next code points are a full stop and digit then consume them.
	isDecimal := false
	if ch0, _ := s.r.read(); ch0 == '.' {
		isDecimal = true
		if ch1, _ := s.r.read(); isDigit(ch1) {
			_, _ = buf.WriteRune(ch0)
			_, _ = buf.WriteRune(ch1)
			_, _ = buf.WriteString(s.scanDigits())
		} else {
			s.r.unread()
		}
	} else {
		s.r.unread()
	}

	// Check if next token is a "." and has at least 2 more subsequent "." runes
	// to confirm we have an IP address string
	ch, _ = s.r.read()
	if ch == '.' {
		buf.WriteRune(ch)
		nbDots := 2
		for {
			buf.WriteString(s.scanDigits())
			ch, _ := s.r.read()
			if ch != '.' {
				s.r.unread()
				break
			}
			nbDots++
			_, _ = buf.WriteRune(ch)
		}
		if nbDots != 3 {
			s.r.unread()
			return BadIP, pos, buf.String()
		}
		octets := strings.Split(buf.String(), ".")
		if len(octets) != 4 {
			return BadIP, pos, buf.String()
		}
		// check the range of each octet
		for _, oct := range octets {
			n, err := strconv.Atoi(oct)
			if err != nil {
				return BadIP, pos, buf.String()
			}
			if n < 0 || n > 255 {
				return BadIP, pos, buf.String()
			}
		}
		return IP, pos, buf.String()
	}
	// unread the previously read char
	s.r.unread()

	// Read as a duration or integer if it doesn't have a fractional part.
	if !isDecimal {
		// If the next rune is a letter then this is a duration token.
		if ch0, _ := s.r.read(); isLetter(ch0) || ch0 == 'µ' {
			_, _ = buf.WriteRune(ch0)
			for {
				ch1, _ := s.r.read()
				if !isLetter(ch1) && ch1 != 'µ' {
					s.r.unread()
					break
				}
				_, _ = buf.WriteRune(ch1)
			}

			// Continue reading digits and letters as part of this token.
			for {
				if ch0, _ := s.r.read(); isLetter(ch0) || ch0 == 'µ' || isDigit(ch0) {
					_, _ = buf.WriteRune(ch0)
				} else {
					s.r.unread()
					break
				}
			}
			return Duration, pos, buf.String()
		}
		s.r.unread()
		return Integer, pos, buf.String()
	}

	return Decimal, pos, buf.String()
}

// scanDigits consumes a contiguous series of digits.
func (s *scanner) scanDigits() string {
	var buf bytes.Buffer
	for {
		ch, _ := s.r.read()
		if !isDigit(ch) {
			s.r.unread()
			break
		}
		_, _ = buf.WriteRune(ch)
	}
	return buf.String()
}

// scanBareIdent reads bare identifier from a rune reader.
func scanBareIdent(r io.RuneScanner) string {
	// Read every ident character into the buffer.
	// Non-ident characters and EOF will cause the loop to exit.
	var buf bytes.Buffer
	for {
		ch, _, err := r.ReadRune()
		if err != nil {
			break
		} else if !isIdentChar(ch) {
			_ = r.UnreadRune()
			break
		} else {
			_, _ = buf.WriteRune(ch)
		}
	}
	return buf.String()
}

// scanString consumes a contiguous string of non-quote characters.
// Quote characters can be consumed if they're first escaped with a backslash.
func (s *scanner) scanString() (tok token, pos int, lit string) {
	s.r.unread()
	_, pos = s.r.curr()

	lit, err := ScanString(s.r)
	switch err {
	case errBadString:
		return Badstr, pos, lit
	case errBadEscape:
		_, pos = s.r.curr()
		return Badstr, pos, lit
	default:
		return Str, pos, lit
	}
}

var errBadString = errors.New("bad string")
var errBadEscape = errors.New("bad escape")

// ScanString reads a quoted string from a rune reader.
func ScanString(r io.RuneScanner) (string, error) {
	ending, _, err := r.ReadRune()
	if err != nil {
		return "", errBadString
	}

	var buf bytes.Buffer
	for {
		ch0, _, err := r.ReadRune()
		if ch0 == ending {
			return buf.String(), nil
		} else if err != nil || ch0 == '\n' {
			return buf.String(), errBadString
		} else if ch0 == '\\' {
			// If the next character is an escape then write the escaped char.
			// If it's not a valid escape then return an error.
			ch1, _, _ := r.ReadRune()
			switch ch1 {
			case 'n':
				_, _ = buf.WriteRune('\n')
			case '\\':
				_, _ = buf.WriteRune('\\')
			case '"':
				_, _ = buf.WriteRune('"')
			case '\'':
				_, _ = buf.WriteRune('\'')
			default:
				return string(ch0) + string(ch1), errBadEscape
			}
		} else {
			_, _ = buf.WriteRune(ch0)
		}
	}
}

// bufScanner represents a wrapper for scanner to add a buffer.
// It provides a fixed-length circular buffer that can be unread.
type bufScanner struct {
	s   *scanner
	i   int // buffer index
	n   int // buffer size
	buf [3]struct {
		tok token
		pos int
		lit string
	}
}

// newBufScanner returns a new buffered scanner for a reader.
func newBufScanner(r io.Reader) *bufScanner {
	return &bufScanner{s: newScanner(r)}
}

// scan reads the next token from the scanner.
func (s *bufScanner) scan() (tok token, pos int, lit string) {
	return s.scanFunc(s.s.scan)
}

// scanFunc uses the provided function to scan the next token.
func (s *bufScanner) scanFunc(scan func() (token, int, string)) (tok token, pos int, lit string) {
	// If we have unread tokens then read them off the buffer first.
	if s.n > 0 {
		s.n--
		return s.curr()
	}

	// Move buffer position forward and save the token.
	s.i = (s.i + 1) % len(s.buf)
	buf := &s.buf[s.i]
	buf.tok, buf.pos, buf.lit = scan()

	return s.curr()
}

// unscan pushes the previously token back onto the buffer.
func (s *bufScanner) unscan() { s.n++ }

// curr returns the last read token.
func (s *bufScanner) curr() (tok token, pos int, lit string) {
	buf := &s.buf[(s.i-s.n+len(s.buf))%len(s.buf)]
	return buf.tok, buf.pos, buf.lit
}

type reader struct {
	r   io.RuneScanner
	i   int
	n   int // buffer char count
	pos int // last read rune position
	buf [3]struct {
		ch  rune
		pos int
	}
	eof bool
}

// ReadRune reads the next rune from the reader.
// This is a wrapper function to implement the io.RuneReader interface.
// Note that this function does not return size.
func (r *reader) ReadRune() (ch rune, size int, err error) {
	ch, _ = r.read()
	if ch == eof {
		err = io.EOF
	}
	return
}

// UnreadRune pushes the previously read rune back onto the buffer.
// This is a wrapper function to implement the io.RuneScanner interface.
func (r *reader) UnreadRune() error {
	r.unread()
	return nil
}

var eof = rune(0)

// read reads the next rune from the reader.
func (r *reader) read() (ch rune, pos int) {
	// if we have unread characters then read them off the buffer first.
	if r.n > 0 {
		r.n--
		return r.curr()
	}

	// Read next rune from underlying reader.
	// Any error (including io.EOF) should return as EOF.
	ch, _, err := r.r.ReadRune()
	if err != nil {
		ch = eof
	} else if ch == '\r' {
		if ch, _, err := r.r.ReadRune(); err != nil {
			// nop
		} else if ch != '\n' {
			_ = r.r.UnreadRune()
		}
		ch = '\n'
	}

	// Save character and position to the buffer.
	r.i = (r.i + 1) % len(r.buf)
	buf := &r.buf[r.i]
	buf.ch, buf.pos = ch, r.pos

	// Update position.
	if !r.eof {
		r.pos++
	}

	// Mark the reader as EOF.
	// This is used to avoid doubling the count of EOF characters.
	if ch == eof {
		r.eof = true
	}

	return r.curr()
}

// unread pushes the previously read rune back onto the buffer.
func (r *reader) unread() { r.n++ }

// curr returns the last read character and position.
func (r *reader) curr() (ch rune, pos int) {
	i := (r.i - r.n + len(r.buf)) % len(r.buf)
	buf := &r.buf[i]
	return buf.ch, buf.pos
}

// isWhitespace returns true if the rune is a space, tab, or newline.
func isWhitespace(ch rune) bool { return ch == ' ' || ch == '\t' || ch == '\n' }

// isLetter returns true if the rune is a letter.
func isLetter(ch rune) bool {
	return (ch >= 'a' && ch <= 'z') || (ch >= 'A' && ch <= 'Z')
}

// isDigit returns true if the rune is a digit.
func isDigit(ch rune) bool { return ch >= '0' && ch <= '9' }

// isIdentChar returns true if the rune can be used in an unquoted identifier. $ rune is for special PE section names (e.g. .debug$ | .tls$)
func isIdentChar(ch rune) bool {
	return isLetter(ch) || isDigit(ch) || ch == '_' || ch == '.' || ch == '$'
}

```

`pkg/filter/ql/lexer_test.go`:

```go
/*
 * Copyright 2019-2020 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package ql

import (
	"strings"
	"testing"
)

func TestScanner(t *testing.T) {
	var tests = []struct {
		s   string
		tok token
		lit string
		pos int
	}{
		// special tokens
		{s: ``, tok: EOF},
		{s: `#`, tok: Illegal, lit: `#`},
		{s: ` `, tok: WS, lit: " "},
		{s: "\t", tok: WS, lit: "\t"},

		// logical operators
		{s: `AND`, tok: And},
		{s: `and`, tok: And},
		{s: `OR`, tok: Or},
		{s: `or`, tok: Or},

		{s: `=`, tok: Eq},
		{s: `~=`, tok: IEq},
		{s: `<>`, tok: Neq},
		{s: `! `, tok: Illegal, lit: "!"},
		{s: `<`, tok: Lt},
		{s: `<=`, tok: Lte},
		{s: `>`, tok: Gt},
		{s: `>=`, tok: Gte},
		{s: `IN`, tok: In},
		{s: `in`, tok: In},

		// misc tokens
		{s: `(`, tok: Lparen},
		{s: `)`, tok: Rparen},
		{s: `,`, tok: Comma},
		{s: `|`, tok: Pipe},

		// identifiers
		{s: `foo`, tok: Ident, lit: `foo`},
		{s: `_foo`, tok: Ident, lit: `_foo`},
		{s: `Zx12_3U_-`, tok: Ident, lit: `Zx12_3U_`},
		{s: `"foo\"bar\""`, tok: Ident, lit: `foo"bar"`},

		// IP address
		{s: "172.17.0.1", tok: IP, lit: "172.17.0.1"},
		{s: "172.17.1", tok: BadIP, lit: "172.17.1"},
		{s: "172.317.1.2", tok: BadIP, lit: "172.317.1.2"},
		{s: "172.2.266.2", tok: BadIP, lit: "172.2.266.2"},

		// strings
		{s: `'testing 123!'`, tok: Str, lit: `testing 123!`},
		{s: `'foo\nbar'`, tok: Str, lit: "foo\nbar"},
		{s: `'foo\\bar'`, tok: Str, lit: "foo\\bar"},

		// numbers
		{s: "6.2323", tok: Decimal, lit: "6.2323"},
	}

	for i, tt := range tests {
		s := newScanner(strings.NewReader(tt.s))
		tok, pos, lit := s.scan()
		if tt.tok != tok {
			t.Errorf("%d. %q token mismatch: exp=%q got=%q <%q>", i, tt.s, tt.tok, tok, lit)
		} else if tt.pos != pos {
			t.Errorf("%d. %q pos mismatch: exp=%#v got=%#v", i, tt.s, tt.pos, pos)
		} else if tt.lit != lit {
			t.Errorf("%d. %q literal mismatch: exp=%q got=%q", i, tt.s, tt.lit, lit)
		}
	}
}

```

`pkg/filter/ql/literal.go`:

```go
/*
 * Copyright 2019-2020 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package ql

import (
	"net"
	"reflect"
	"strconv"
	"strings"
	"time"

	"github.com/rabbitstack/fibratus/pkg/event"
	"github.com/rabbitstack/fibratus/pkg/filter/fields"

	"github.com/rabbitstack/fibratus/pkg/filter/ql/functions"
)

// StringLiteral represents a string literal.
type StringLiteral struct {
	Value string
}

// FieldLiteral represents a field literal.
type FieldLiteral struct {
	Value string
	Field fields.Field
	Arg   string
}

// IntegerLiteral represents a signed number literal.
type IntegerLiteral struct {
	Value int64
}

// UnsignedLiteral represents an unsigned number literal.
type UnsignedLiteral struct {
	Value uint64
}

// DecimalLiteral represents an floating point number literal.
type DecimalLiteral struct {
	Value float64
}

// BoolLiteral represents the logical true/false literal.
type BoolLiteral struct {
	Value bool
}

// IPLiteral represents an IP literal.
type IPLiteral struct {
	Value net.IP
}

// BoundFieldLiteral represents the bound field literal.
type BoundFieldLiteral struct {
	Value    string
	BoundVar BareBoundVariableLiteral
	Field    *FieldLiteral
}

// BoundSegmentLiteral represents the bound segment literal.
type BoundSegmentLiteral struct {
	Value    string
	BoundVar BareBoundVariableLiteral
	Segment  fields.Segment
}

type BareBoundVariableLiteral struct {
	Value string
}

func (i IPLiteral) String() string {
	return i.Value.String()
}

func (i IntegerLiteral) String() string {
	return strconv.Itoa(int(i.Value))
}

func (s StringLiteral) String() string {
	return s.Value
}

func (f FieldLiteral) String() string {
	return f.Value
}

func (u UnsignedLiteral) String() string {
	return strconv.Itoa(int(u.Value))
}

func (d DecimalLiteral) String() string {
	return strconv.FormatFloat(d.Value, 'e', -1, 64)
}

func (b BoolLiteral) String() string {
	return strconv.FormatBool(b.Value)
}

func (b BoundFieldLiteral) String() string {
	return b.Value
}

func (b BoundSegmentLiteral) String() string {
	return b.Value
}

func (b BareBoundVariableLiteral) String() string {
	return b.Value
}

// ListLiteral represents a list of tag key literals.
type ListLiteral struct {
	Values []string
}

// String returns a string representation of the literal.
func (s *ListLiteral) String() string {
	var n int
	for _, elem := range s.Values {
		n += len(elem) + 2
	}

	var b strings.Builder
	b.Grow(n + 2)
	b.WriteRune('(')

	for idx, elem := range s.Values {
		if idx != 0 {
			b.WriteString(", ")
		}
		b.WriteString(elem)
	}

	b.WriteRune(')')

	return b.String()
}

// Function represents a function call.
type Function struct {
	Name string
	Args []Expr
}

// ArgsSlice returns arguments as a slice of strings.
func (f *Function) ArgsSlice() []string {
	args := make([]string, 0, len(f.Args))
	for _, arg := range f.Args {
		args = append(args, arg.String())
	}
	return args
}

// String returns a string representation of the call.
func (f *Function) String() string {
	args := strings.Join(f.ArgsSlice(), ", ")

	var b strings.Builder
	b.Grow(len(args) + len(f.Name) + 2)

	b.WriteString(f.Name)
	b.WriteRune('(')
	b.WriteString(args)
	b.WriteRune(')')

	// Write function name and args.
	return b.String()
}

func (f *Function) IsForeach() bool {
	return f.Name == "foreach" || f.Name == "FOREACH"
}

func (f *Function) IsBinaryExprArg(i int) bool {
	_, ok := f.Args[i].(*BinaryExpr)
	return ok
}

func (f *Function) IsNotExprArg(i int) bool {
	_, ok := f.Args[i].(*NotExpr)
	return ok
}

func (f *Function) IsBareBoundVariableArg(i int) bool {
	_, ok := f.Args[i].(*BareBoundVariableLiteral)
	return ok
}

func (f *Function) IsFieldArg(i int) bool {
	_, ok := f.Args[i].(*FieldLiteral)
	return ok
}

// validate ensures that the function name obtained
// from the parser exists within the internal functions
// catalog. It also validates the function signature to
// make sure required arguments are supplied. Finally, it
// checks the type of each argument with the expected one.
func (f *Function) validate() error {
	fn, ok := funcs[strings.ToUpper(f.Name)]
	if !ok {
		return ErrUndefinedFunction(f.Name)
	}

	if len(f.Args) < fn.Desc().RequiredArgs() ||
		len(f.Args) > len(fn.Desc().Args) {
		return ErrFunctionSignature(fn.Desc(), len(f.Args))
	}

	validationFunc := fn.Desc().ArgsValidationFunc
	if validationFunc != nil {
		if err := validationFunc(f.ArgsSlice()); err != nil {
			return err
		}
	}

	for i, expr := range f.Args {
		arg := fn.Desc().Args[i]
		typ := functions.Unknown

		switch reflect.TypeOf(expr) {
		case reflect.TypeOf(&FieldLiteral{}):
			typ = functions.Field
		case reflect.TypeOf(&BoundFieldLiteral{}):
			typ = functions.BoundField
		case reflect.TypeOf(&BoundSegmentLiteral{}):
			typ = functions.BoundSegment
		case reflect.TypeOf(&BareBoundVariableLiteral{}):
			typ = functions.BareBoundVariable
		case reflect.TypeOf(&IPLiteral{}):
			typ = functions.IP
		case reflect.TypeOf(&StringLiteral{}):
			typ = functions.String
		case reflect.TypeOf(&IntegerLiteral{}):
			typ = functions.Number
		case reflect.TypeOf(&Function{}):
			typ = functions.Func
		case reflect.TypeOf(&ListLiteral{}):
			typ = functions.Slice
		case reflect.TypeOf(&BoolLiteral{}):
			typ = functions.Bool
		case reflect.TypeOf(&BinaryExpr{}), reflect.TypeOf(&ParenExpr{}), reflect.TypeOf(&NotExpr{}):
			typ = functions.Expression
		}

		if !arg.ContainsType(typ) {
			return ErrArgumentTypeMismatch(i, arg.Keyword, fn.Name(), arg.Types)
		}
	}

	return nil
}

// SequenceExpr represents a single binary expression within the sequence.
type SequenceExpr struct {
	Expr Expr
	// By contains the expression link if the sequence is constrained.
	By *SequenceLink
	// BoundFields is a group of bound fields referenced in the sequence expression.
	BoundFields []*BoundFieldLiteral
	// Alias represents the sequence expression alias when bound fields are used.
	Alias string

	bitsets event.BitSets
	types   []event.Type
}

func (e *SequenceExpr) init() {
	e.types = make([]event.Type, 0)
	e.BoundFields = make([]*BoundFieldLiteral, 0)
}

func (e *SequenceExpr) walk() {
	stringFields := make(map[fields.Field][]string)
	walk := func(n Node) {
		if expr, ok := n.(*BinaryExpr); ok {
			switch lhs := expr.LHS.(type) {
			case *BoundFieldLiteral:
				e.BoundFields = append(e.BoundFields, lhs)
			case *FieldLiteral:
				field := fields.Field(lhs.Value)
				switch v := expr.RHS.(type) {
				case *StringLiteral:
					stringFields[field] = append(stringFields[field], v.Value)
				case *ListLiteral:
					stringFields[field] = append(stringFields[field], v.Values...)
				}
			}

			switch rhs := expr.RHS.(type) {
			case *BoundFieldLiteral:
				e.BoundFields = append(e.BoundFields, rhs)
			case *FieldLiteral:
				field := fields.Field(rhs.Value)
				switch v := expr.LHS.(type) {
				case *StringLiteral:
					stringFields[field] = append(stringFields[field], v.Value)
				case *ListLiteral:
					stringFields[field] = append(stringFields[field], v.Values...)
				}
			}
		}

		if expr, ok := n.(*Function); ok {
			for _, arg := range expr.Args {
				switch v := arg.(type) {
				case *FieldLiteral:
					field := fields.Field(v.Value)
					stringFields[field] = append(stringFields[field], v.Value)
				case *BoundFieldLiteral:
					e.BoundFields = append(e.BoundFields, v)
				}
			}
		}
	}

	WalkFunc(e.Expr, walk)

	uniqCats := make(map[event.Category]bool)

	// initialize event type/category buckets for every such field
	for name, values := range stringFields {
		for _, v := range values {
			switch name {
			case fields.EvtName:
				for _, typ := range event.NameToTypes(v) {
					if typ == event.UnknownType {
						continue
					}
					e.types = append(e.types, typ)
					uniqCats[event.TypeToEventInfo(typ).Category] = true
				}
			case fields.EvtCategory:
				e.bitsets.SetCategoryBit(event.Category(v))
			}
		}
	}

	for _, t := range e.types {
		switch len(uniqCats) {
		case 0:
			continue
		case 1:
			// happy path can use a single bitmask for all
			// event types pertaining to the same category
			e.bitsets.SetBit(event.TypeBitSet, t)
		default:
			// use map-backed bitmask for event identifiers
			e.bitsets.SetBit(event.BitmaskBitSet, t)
		}
	}
}

// IsEvaluable determines if the expression should be evaluated by inspecting
// the event type filter fields defined in the expression. We permit the expression
// to be evaluated when the incoming event type, ID, or category pertains to the one
// defined in the field literal.
func (e *SequenceExpr) IsEvaluable(evt *event.Event) bool {
	return e.bitsets.IsBitSet(evt)
}

// HasBoundFields determines if this sequence expression references any bound field.
func (e *SequenceExpr) HasBoundFields() bool {
	return len(e.BoundFields) > 0
}

// SequenceLink represents a single or
// a collection of fields that are used to
// build the sequence join link.
type SequenceLink struct {
	Fields []*FieldLiteral
}

// IsCompound indicates if the sequence expression
// uses multiple fields for the join link.
func (l *SequenceLink) IsCompound() bool {
	return len(l.Fields) > 1
}

// First returns the first field if the link is not compound.
func (l *SequenceLink) First() string {
	if len(l.Fields) == 1 {
		return l.Fields[0].Value
	}
	return ""
}

// Sequence is a collection of two or more sequence expressions.
type Sequence struct {
	MaxSpan     time.Duration
	By          *SequenceLink
	Expressions []SequenceExpr
	IsUnordered bool
}

// IsConstrained determines if the sequence has the global or per-expression `BY` statement.
func (s Sequence) IsConstrained() bool {
	return s.By != nil || s.Expressions[0].By != nil
}

func (s *Sequence) init() {
	// determine if the sequence references an event type
	// that can arrive out-of-order. This happens if the
	// expressions in the sequence reference event types
	// from different event sources
	sources := make(map[event.Source]bool)

	for _, expr := range s.Expressions {
		for _, etype := range expr.types {
			sources[etype.Source()] = true
		}
	}

	s.IsUnordered = len(sources) > 1
}

func (s Sequence) impairBy() bool {
	b := make(map[bool]int, len(s.Expressions))
	for _, expr := range s.Expressions {
		b[expr.By != nil]++
	}
	if s.By != nil && (b[true] == len(s.Expressions) || b[false] == len(s.Expressions)) {
		return false
	}
	return b[true] > 0 && b[false] > 0
}

// incompatibleConstraints checks if the sequence has
// both global and per-expression `BY` statements and
// returns true if such condition is satisfied.
func (s Sequence) incompatibleConstraints() bool {
	for _, expr := range s.Expressions {
		if expr.By != nil && s.By != nil {
			return true
		}
	}
	return false
}

```

`pkg/filter/ql/literal_test.go`:

```go
/*
 * Copyright 2021-present by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package ql

import (
	"github.com/rabbitstack/fibratus/pkg/event"
	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/require"
	"testing"
)

func TestSequenceExprIsEvaluable(t *testing.T) {
	var tests = []struct {
		expr       string
		evt        *event.Event
		isEval     bool
		assertions func(t *testing.T, sexpr *SequenceExpr)
	}{
		{"evt.name = 'CreateProcess'", &event.Event{Type: event.CreateProcess, Category: event.Process}, true,
			func(t *testing.T, sexpr *SequenceExpr) {
				assert.True(t, sexpr.bitsets.IsInitialized(event.TypeBitSet))
				assert.False(t, sexpr.bitsets.IsInitialized(event.BitmaskBitSet))
				assert.False(t, sexpr.bitsets.IsInitialized(event.CategoryBitSet))
			},
		},
		{"evt.name = 'CreateProcess'", &event.Event{Type: event.TerminateProcess, Category: event.Process}, false, nil},
		{"evt.name = 'CreateProcess' or evt.name = 'TerminateThread'", &event.Event{Type: event.TerminateProcess, Category: event.Process}, false, nil},
		{"evt.name = 'CreateProcess' or evt.category = 'object'", &event.Event{Type: event.TerminateProcess, Category: event.Process}, false, nil},
		{"evt.name = 'CreateProcess' or evt.name = 'OpenProcess'", &event.Event{Type: event.OpenProcess, Category: event.Process}, true,
			func(t *testing.T, sexpr *SequenceExpr) {
				assert.True(t, sexpr.bitsets.IsInitialized(event.TypeBitSet))
				assert.False(t, sexpr.bitsets.IsInitialized(event.BitmaskBitSet))
				assert.False(t, sexpr.bitsets.IsInitialized(event.CategoryBitSet))
			},
		},
		{"evt.name = 'CreateProcess' or evt.name = 'CreateThread'", &event.Event{Type: event.CreateThread, Category: event.Thread}, true,
			func(t *testing.T, sexpr *SequenceExpr) {
				assert.False(t, sexpr.bitsets.IsInitialized(event.TypeBitSet))
				assert.True(t, sexpr.bitsets.IsInitialized(event.BitmaskBitSet))
				assert.False(t, sexpr.bitsets.IsInitialized(event.CategoryBitSet))
			},
		},
		{"evt.name = 'CreateProcess' or evt.category = 'registry'", &event.Event{Type: event.RegSetValue, Category: event.Registry}, true,
			func(t *testing.T, sexpr *SequenceExpr) {
				assert.True(t, sexpr.bitsets.IsInitialized(event.TypeBitSet))
				assert.False(t, sexpr.bitsets.IsInitialized(event.BitmaskBitSet))
				assert.True(t, sexpr.bitsets.IsInitialized(event.CategoryBitSet))
			},
		},
		{"evt.name = 'CreateProcess' or evt.name = 'OpenProcess' or evt.category = 'registry'", &event.Event{Type: event.OpenProcess, Category: event.Process}, true,
			func(t *testing.T, sexpr *SequenceExpr) {
				assert.True(t, sexpr.bitsets.IsInitialized(event.TypeBitSet))
				assert.False(t, sexpr.bitsets.IsInitialized(event.BitmaskBitSet))
				assert.True(t, sexpr.bitsets.IsInitialized(event.CategoryBitSet))
			},
		},
		{"evt.name = 'CreateProcess' or evt.name = 'SetThreadContext' or evt.category = 'registry'", &event.Event{Type: event.CreateProcess, Category: event.Process}, true,
			func(t *testing.T, sexpr *SequenceExpr) {
				assert.False(t, sexpr.bitsets.IsInitialized(event.TypeBitSet))
				assert.True(t, sexpr.bitsets.IsInitialized(event.BitmaskBitSet))
				assert.True(t, sexpr.bitsets.IsInitialized(event.CategoryBitSet))
			},
		},
	}

	for _, tt := range tests {
		t.Run(tt.expr, func(t *testing.T) {
			p := NewParser(tt.expr)
			expr, err := p.ParseExpr()
			require.NoError(t, err)

			sexpr := &SequenceExpr{Expr: expr}
			sexpr.init()
			sexpr.walk()

			assert.Equal(t, tt.isEval, sexpr.IsEvaluable(tt.evt))
			if tt.assertions != nil {
				tt.assertions(t, sexpr)
			}
		})
	}
}

```

`pkg/filter/ql/parser.go`:

```go
/*
 * Copyright 2019-2020 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 *  Copyright (c) 2013-2016 Errplane Inc.
 */

package ql

import (
	"errors"
	"fmt"
	"net"
	"strconv"
	"strings"
	"time"

	"github.com/rabbitstack/fibratus/pkg/config"
	"github.com/rabbitstack/fibratus/pkg/filter/fields"
	"github.com/rabbitstack/fibratus/pkg/util/multierror"
)

// Parser builds the binary expression tree from the filter string.
type Parser struct {
	s    *bufScanner
	c    *config.Filters
	expr string
}

// NewParser builds a new parser instance from the expression string.
func NewParser(expr string) *Parser {
	return &Parser{s: newBufScanner(strings.NewReader(expr)), expr: expr}
}

// NewParserWithConfig builds a new parser instance with filters config.
func NewParserWithConfig(expr string, config *config.Filters) *Parser {
	return &Parser{s: newBufScanner(strings.NewReader(expr)), expr: expr, c: config}
}

// ParseSequence parses the collection of binary expressions with possible join
// statements and time frame constraints. This method assumes the SEQUENCE token
// has already been consumed.
func (p *Parser) ParseSequence() (*Sequence, error) {
	seq := &Sequence{}
	var exprs []SequenceExpr

	// parse optional max span
	tok, _, _ := p.scanIgnoreWhitespace()
	if tok == MaxSpan {
		var err error
		seq.MaxSpan, err = p.parseDuration()
		if err != nil {
			return nil, err
		}
		if seq.MaxSpan > time.Hour*4 {
			return nil, fmt.Errorf("maximum span %v cannot be greater than 4h", seq.MaxSpan)
		}
	} else {
		p.unscan()
	}

	// parse optional global link
	tok, _, _ = p.scanIgnoreWhitespace()
	if tok == By {
		tok, pos, lit := p.scanIgnoreWhitespace()
		if !fields.IsField(lit) {
			return nil, newParseError(tokstr(tok, lit), []string{"field"}, pos, p.expr)
		}
		var err error
		field, err := p.parseField(lit)
		if err != nil {
			return nil, err
		}

		seqLink := &SequenceLink{Fields: []*FieldLiteral{field}}

		// handle multiple join fields separated by comma
		for {
			if tok, _, _ := p.scanIgnoreWhitespace(); tok != Comma {
				p.unscan()
				break
			}

			tok, pos, lit := p.scanIgnoreWhitespace()
			if !fields.IsField(lit) {
				return nil, newParseError(tokstr(tok, lit), []string{"field"}, pos, p.expr)
			}
			field, err := p.parseField(lit)
			if err != nil {
				return nil, err
			}

			seqLink.Fields = append(seqLink.Fields, field)
		}

		seq.By = seqLink
	} else {
		p.unscan()
	}

	// parse sequence expressions
	for {
		if tok, _, _ := p.scanIgnoreWhitespace(); tok == EOF {
			if len(exprs) < 1 {
				return nil, fmt.Errorf("%s: sequences require at least two expressions", p.expr)
			}

			const maxExpressions = 5
			if len(exprs) > maxExpressions {
				return nil, fmt.Errorf("%s: maximum number of expressions reached", p.expr)
			}
			seq.Expressions = exprs
			if seq.impairBy() {
				return nil, fmt.Errorf("%s: all expressions require the 'by' statement", p.expr)
			}
			if seq.incompatibleConstraints() {
				return nil, fmt.Errorf("%s: sequence mixes global and per-expression 'by' statements", p.expr)
			}

			seq.init()

			return seq, nil
		}
		p.unscan()

		tok, posStart, lit := p.scanIgnoreWhitespace()
		if tok != Pipe {
			return nil, newParseError(tokstr(tok, lit), []string{"|"}, posStart, p.expr)
		}
		expr, err := p.ParseExpr()
		if err != nil {
			return nil, err
		}
		tok, posEnd, lit := p.scanIgnoreWhitespace()
		if tok != Pipe {
			return nil, newParseError(tokstr(tok, lit), []string{"|"}, posEnd, p.expr)
		}

		var seqexpr SequenceExpr

		// parse sequence BY or AS constraints (links)
		tok, _, _ = p.scanIgnoreWhitespace()
		switch tok {
		case By:
			tok, pos, lit := p.scanIgnoreWhitespace()
			if !fields.IsField(lit) {
				return nil, newParseError(tokstr(tok, lit), []string{"field"}, pos, p.expr)
			}
			field, err := p.parseField(lit)
			if err != nil {
				return nil, err
			}

			seqLink := &SequenceLink{Fields: []*FieldLiteral{field}}

			// handle multiple join fields separated by comma
			for {
				if tok, _, _ := p.scanIgnoreWhitespace(); tok != Comma {
					p.unscan()
					break
				}

				tok, pos, lit := p.scanIgnoreWhitespace()
				if !fields.IsField(lit) {
					return nil, newParseError(tokstr(tok, lit), []string{"field"}, pos, p.expr)
				}
				field, err := p.parseField(lit)
				if err != nil {
					return nil, err
				}

				seqLink.Fields = append(seqLink.Fields, field)
			}
			seqexpr = SequenceExpr{Expr: expr, By: seqLink}
		case As:
			tok, pos, lit := p.scanIgnoreWhitespace()
			if tok != Ident {
				return nil, newParseError(tokstr(tok, lit), []string{"identifier"}, pos, p.expr)
			}
			seqexpr = SequenceExpr{Expr: expr, Alias: lit}
		default:
			seqexpr = SequenceExpr{Expr: expr}
			p.unscan()
		}

		seqexpr.init()
		seqexpr.walk()
		exprs = append(exprs, seqexpr)
	}
}

// IsSequence checks whether the expression given to the parser is a sequence.
func (p *Parser) IsSequence() bool {
	tok, _, _ := p.scanIgnoreWhitespace()
	if tok == Seq {
		return true
	}
	p.unscan()
	return false
}

// ParseExpr parses an expression by building the binary expression tree.
func (p *Parser) ParseExpr() (Expr, error) {
	var err error
	root := &BinaryExpr{}
	// parse a non-binary expression type to start. This variable will always be
	// the root of the expression tree.
	root.RHS, err = p.parseUnaryExpr()
	if err != nil {
		return nil, err
	}

	// loop over operations and unary exprs and build a tree based on precedence.
	for {
		// if the next token is NOT an operator then return the expression.
		op, pos, lit := p.scanIgnoreWhitespace()
		if !op.isOperator() {
			p.unscan()
			if op != EOF && op != Rparen && op != Comma && op != Pipe {
				return nil, newParseError(tokstr(op, lit), []string{"operator", "')'", "','", "'|'"}, pos, p.expr)
			}
			return root.RHS, nil
		}

		if op == In || op == IIn {
			// expect LPAREN after in
			tok, pos, lit := p.scanIgnoreWhitespace()
			p.unscan()
			if tok != Lparen && (p.c != nil && !p.c.IsMacroList(lit)) {
				return nil, newParseError(tokstr(op, lit), []string{"'('"}, pos, p.expr)
			}
		}

		var rhs Expr
		switch op {
		case Not:
			// the first variant of the negation operator.
			// The operator that is negated appears immediately
			// after the `not` operator, e.g. ps.name not in ('cmd.exe')
			op1, pos, lit := p.scanIgnoreWhitespace()
			if !op1.isOperator() {
				return nil, newParseError(tokstr(op, lit), []string{"operator"}, pos, p.expr)
			}
			// parse the next expression after operator
			rhs1, err := p.parseUnaryExpr()
			if err != nil {
				return nil, err
			}
			rhs = &BinaryExpr{RHS: rhs1, Op: op1}
		default:
			op1, _, _ := p.scanIgnoreWhitespace()
			// if the negation appears after the operator
			// try to parse an entire binary expr and wrap
			// it inside the `not` expression. This is the
			// second variant of the negating expressions, e.g.
			// ps.name = 'cmd.exe' and not (ps.name in ('powershell.exe'))
			if op1 == Not {
				binaryExpr, err := p.ParseExpr()
				if err != nil {
					return nil, err
				}
				rhs = &NotExpr{binaryExpr}
			} else {
				p.unscan()
				// otherwise, parse the next expression
				rhs, err = p.parseUnaryExpr()
				if err != nil {
					return nil, err
				}
			}
		}

		// find the right spot in the tree to add the new expression by
		// descending the RHS of the expression tree until we reach the last
		// BinaryExpr or a BinaryExpr whose RHS has an operator with
		// precedence >= the operator being added.
		for node := root; ; {
			r, ok := node.RHS.(*BinaryExpr)
			if !ok || r.Op.precedence() >= op.precedence() {
				if op == Not {
					r := rhs.(*BinaryExpr)
					r.LHS = node.RHS
					node.RHS = &NotExpr{Expr: r}
					break
				}
				// Add the new expression here and break.
				node.RHS = &BinaryExpr{LHS: node.RHS, RHS: rhs, Op: op}
				break
			}
			node = r
		}
	}
}

// parseUnaryExpr parses an non-binary expression.
func (p *Parser) parseUnaryExpr() (Expr, error) {
	// If the first token is a LPAREN then parse it as its own grouped expression.
	if tok, _, _ := p.scanIgnoreWhitespace(); tok == Lparen {
		// parse a comma-separated list if this looks like a list
		tagKeys, err := p.parseList()
		if err != nil {
			p.unscan()
			// if it fails, try to parse the grouped expression
			expr, err := p.ParseExpr()
			if err != nil {
				return nil, err
			}
			// Expect an RPAREN at the end.
			if tok, pos, lit := p.scanIgnoreWhitespace(); tok != Rparen {
				return nil, newParseError(tokstr(tok, lit), []string{"')'"}, pos, p.expr)
			}
			return &ParenExpr{Expr: expr}, nil
		}

		// Expect an RPAREN at the end of list
		if tok, pos, lit := p.scanIgnoreWhitespace(); tok != Rparen {
			return nil, newParseError(tokstr(tok, lit), []string{"')'"}, pos, p.expr)
		}

		return &ListLiteral{Values: tagKeys}, nil
	}

	p.unscan()

	tok, pos, lit := p.scanIgnoreWhitespace()
	switch tok {
	case Ident:
		if fields.IsField(lit) {
			return p.parseField(lit)
		}

		if tok0, _, _ := p.scan(); tok0 == Lparen {
			return p.parseFunction(lit)
		}
		// unscan lparen token
		p.unscan()

		// expand macros
		if p.c != nil {
			macro := p.c.GetMacro(lit)
			if macro != nil {
				if macro.Expr != "" {
					p := NewParserWithConfig(macro.Expr, p.c)
					expr, err := p.ParseExpr()
					if err != nil {
						return nil, multierror.WrapWithSeparator("\n", fmt.Errorf("syntax error in %q macro", lit), err)
					}
					return expr, nil
				}
				return &ListLiteral{Values: macro.List}, nil
			}
			// unscan ident
			p.unscan()
		}
	case IP:
		return &IPLiteral{Value: net.ParseIP(lit)}, nil
	case Str:
		return &StringLiteral{Value: lit}, nil
	case BoundVar:
		n := strings.Index(lit, ".")
		if n == -1 {
			return &BareBoundVariableLiteral{Value: lit}, nil
		}

		// for recognized segment return bound segment literal
		s := lit[n+1:]
		if fields.IsSegment(s) {
			return &BoundSegmentLiteral{Value: lit, BoundVar: BareBoundVariableLiteral{lit[1:n]}, Segment: fields.Segment(s)}, nil
		}

		// parse field literal for recognized field
		if fields.IsField(s) {
			field, err := p.parseField(s)
			if err != nil {
				return nil, err
			}
			return &BoundFieldLiteral{Value: lit, BoundVar: BareBoundVariableLiteral{lit[1:n]}, Field: field}, nil
		}

		return nil, newParseError(tokstr(tok, lit), []string{"field/segment after bound ref"}, pos+n, p.expr)
	case True, False:
		return &BoolLiteral{Value: tok == True}, nil
	case Integer:
		v, err := strconv.ParseInt(lit, 10, 64)
		if err != nil {
			// The literal may be too large to fit into an int64. If it is, use an unsigned integer.
			// The check for negative numbers is handled somewhere else so this should always be a positive number.
			if v, err := strconv.ParseUint(lit, 10, 64); err == nil {
				return &UnsignedLiteral{Value: v}, nil
			}
			return nil, &ParseError{Message: "unable to parse integer", Pos: pos}
		}
		return &IntegerLiteral{Value: v}, nil
	case Decimal:
		v, err := strconv.ParseFloat(lit, 64)
		if err != nil {
			return nil, &ParseError{Message: "unable to parse decimal", Pos: pos}
		}
		return &DecimalLiteral{Value: v}, nil
	}

	expectations := []string{"field", "bound field", "string", "number", "bool", "ip", "function"}
	if tok == BadIP {
		expectations = []string{"a valid IP address"}
	}
	if tok == Badesc || tok == Badstr {
		expectations = []string{"a valid string but bad string or escape found"}
	}

	return nil, newParseError(tokstr(tok, lit), expectations, pos, p.expr)
}

// parseField parses the field and its argument. This method
// assumes the field name has been consumed.
func (p *Parser) parseField(name string) (*FieldLiteral, error) {
	argument := fields.ArgumentOf(name)

	// parse field argument
	tok, pos, lit := p.scan()
	if tok == LBracket {
		arg, pos, lit := p.scan()
		if arg != Ident && arg != Integer {
			return nil, newParseError(tokstr(arg, lit), []string{"ident", "integer"}, pos, p.expr)
		}

		// field argument given, but the field doesn't require one
		if argument == nil {
			return nil, newParseError(tokstr(tok, lit), []string{"field without argument"}, pos, p.expr)
		}

		// validate argument
		if argument != nil && !argument.Validate(lit) {
			exp := fmt.Sprintf("a valid field argument matching the pattern %s", argument.Pattern)
			return nil, newParseError(tokstr(arg, lit), []string{exp}, pos, p.expr)
		}

		if tok, pos, lit := p.scan(); tok != RBracket {
			return nil, newParseError(tokstr(tok, lit), []string{"]"}, pos, p.expr)
		}

		return &FieldLiteral{Value: name, Field: fields.Field(name), Arg: lit}, nil
	} else {
		// unscan lbracket
		p.unscan()
		// field argument not given, but it is required
		if argument != nil && !argument.Optional {
			return nil, newParseError(tokstr(tok, lit), []string{"field argument"}, pos, p.expr)
		}

		return &FieldLiteral{Value: name, Field: fields.Field(name)}, nil
	}
}

// parseList parses the list of strings. This method assumes the
// LPAREN token has been consumed.
func (p *Parser) parseList() ([]string, error) {
	tok, pos, lit := p.scanIgnoreWhitespace()
	if tok != Str && tok != IP && tok != Integer {
		return []string{}, newParseError(tokstr(tok, lit), []string{"identifier"}, pos, p.expr)
	}
	idents := []string{lit}

	// parse remaining identifiers
	for {
		if tok, _, _ := p.scanIgnoreWhitespace(); tok != Comma {
			p.unscan()
			return idents, nil
		}

		tok, pos, lit := p.scanIgnoreWhitespace()
		if tok != Str && tok != IP && tok != Integer {
			return []string{}, newParseError(tokstr(tok, lit), []string{"identifier"}, pos, p.expr)
		}

		idents = append(idents, lit)
	}
}

// parseFunction parses a function call. This method assumes
// the function name and LPAREN have been consumed.
func (p *Parser) parseFunction(name string) (*Function, error) {
	name = strings.ToLower(name)
	args := make([]Expr, 0)

	// If there's a right paren then just return immediately.
	// This is the case for functions without arguments
	if tok, _, _ := p.scan(); tok == Rparen {
		fn := &Function{Name: name}
		if err := fn.validate(); err != nil {
			return nil, err
		}
		return fn, nil
	}
	p.unscan()

	arg, err := p.ParseExpr()
	if err != nil {
		return nil, err
	}
	args = append(args, arg)

	// Parse additional function arguments if there is a comma.
	for {
		// If there's not a comma, stop parsing arguments.
		if tok, _, _ := p.scanIgnoreWhitespace(); tok != Comma {
			p.unscan()
			break
		}

		// Parse an expression argument.
		arg, err := p.ParseExpr()
		if err != nil {
			return nil, err
		}
		args = append(args, arg)
	}

	// There should be a right parentheses at the end.
	if tok, pos, lit := p.scan(); tok != Rparen {
		return nil, newParseError(tokstr(tok, lit), []string{")"}, pos, p.expr)
	}

	fn := &Function{Name: name, Args: args}

	if err := fn.validate(); err != nil {
		return nil, err
	}

	return fn, nil
}

// parseDuration parses a string and returns a duration literal.
func (p *Parser) parseDuration() (time.Duration, error) {
	tok, pos, lit := p.scanIgnoreWhitespace()
	if tok != Duration {
		return 0, newParseError(tokstr(tok, lit), []string{"duration"}, pos, p.expr)
	}

	d, err := parseDuration(lit)
	if err != nil {
		return 0, &ParseError{Message: err.Error(), Pos: pos}
	}

	return d, nil
}

// ErrInvalidDuration is returned when parsing a malformed duration.
var ErrInvalidDuration = errors.New("invalid duration")

// parseDuration parses a time duration from a string.
func parseDuration(s string) (time.Duration, error) {
	// Return an error if the string is blank or one character
	if len(s) < 2 {
		return 0, ErrInvalidDuration
	}

	// Split string into individual runes.
	a := []rune(s)

	// Start with a zero duration.
	var d time.Duration
	i := 0

	// Check for a negative.
	isNegative := false
	if a[i] == '-' {
		isNegative = true
		i++
	}

	var measure int64
	var unit string

	// Parsing loop.
	for i < len(a) {
		// Find the number portion.
		start := i
		for ; i < len(a) && isDigit(a[i]); i++ {
			// Scan for the digits.
		}

		// Check if we reached the end of the string prematurely.
		if i >= len(a) || i == start {
			return 0, ErrInvalidDuration
		}

		// Parse the numeric part.
		n, err := strconv.ParseInt(string(a[start:i]), 10, 64)
		if err != nil {
			return 0, ErrInvalidDuration
		}
		measure = n

		// Extract the unit of measure.
		// If the last two characters are "ms" then parse as milliseconds.
		// Otherwise, just use the last character as the unit of measure.
		unit = string(a[i])
		switch a[i] {
		case 'n':
			if i+1 < len(a) && a[i+1] == 's' {
				unit = string(a[i : i+2])
				d += time.Duration(n)
				i += 2
				continue
			}
			return 0, ErrInvalidDuration
		case 'u', 'µ':
			d += time.Duration(n) * time.Microsecond
		case 'm':
			if i+1 < len(a) && a[i+1] == 's' {
				unit = string(a[i : i+2])
				d += time.Duration(n) * time.Millisecond
				i += 2
				continue
			}
			d += time.Duration(n) * time.Minute
		case 's':
			d += time.Duration(n) * time.Second
		case 'h':
			d += time.Duration(n) * time.Hour
		case 'd':
			d += time.Duration(n) * 24 * time.Hour
		case 'w':
			d += time.Duration(n) * 7 * 24 * time.Hour
		default:
			return 0, ErrInvalidDuration
		}
		i++
	}

	// Check to see if we overflowed a duration
	if d < 0 && !isNegative {
		return 0, fmt.Errorf("overflowed duration %d%s: choose a smaller duration or INF", measure, unit)
	}

	if isNegative {
		d = -d
	}
	return d, nil
}

// scan returns the next token from the underlying scanner.
func (p *Parser) scan() (tok token, pos int, lit string) { return p.s.scan() }

// scanIgnoreWhitespace scans the next non-whitespace.
func (p *Parser) scanIgnoreWhitespace() (tok token, pos int, lit string) {
	for {
		tok, pos, lit = p.scan()
		if tok == WS {
			continue
		}
		return
	}
}

// unscan pushes the previously read token back onto the buffer.
func (p *Parser) unscan() { p.s.unscan() }

```

`pkg/filter/ql/parser_test.go`:

```go
/*
 * Copyright 2019-2020 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package ql

import (
	"errors"
	"fmt"
	"strings"
	"testing"
	"time"

	"github.com/rabbitstack/fibratus/pkg/config"
	"github.com/rabbitstack/fibratus/pkg/filter/fields"
	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/require"
)

func TestParser(t *testing.T) {
	var tests = []struct {
		expr string
		err  error
	}{
		{expr: "ps.name = 'cmd.exe'"},
		{expr: "ps.name != 'cmd.exe'"},
		{expr: "ps.name <> 'cmd.exe'"},
		{expr: "ps.name <> 'cmd.exe", err: errors.New("ps.name <> 'cmd.exe\n╭─────────^\n|\n|\n╰─────────────────── expected a valid string but bad string or escape found")},
		{expr: "ps.name = 123"},
		{expr: "net.dip = 172.17.0.9"},
		{expr: "net.dip = 172.17.0.9 and net.dip in ('172.15.9.2')"},
		{expr: "net.dip = 172.17.0.9 and (net.dip not in ('172.15.9.2'))"},

		{expr: "net.dip = 172.17.0", err: errors.New("net.dip = 172.17.0\n╭─────────^\n|\n|\n╰─────────────────── expected a valid IP address")},

		{expr: "ps.name = 'cmd.exe' OR ps.name contains 'svc'"},
		{expr: "ps.name = 'cmd.exe' AND (ps.name contains 'svc' OR ps.name != 'lsass')"},
		{expr: "ps.name = 'cmd.exe' AND (ps.name contains 'svc' OR ps.name != 'lsass'", err: errors.New("ps.name = 'cmd.exe' AND (ps.name contains 'svc' OR ps.name != 'lsass'\n╭─────────────────────────────────────────────────────────────────────^\n|\n|\n╰─────────────────── expected ')'")},

		{expr: "ps.name = 'cmd.exe' OR ((ps.name contains 'svc' AND ps.name != 'lsass') AND ps.ppid != 1)"},

		{expr: "ps.name = 'cmd.exe' OR ((ps.name contains 'svc' AND ps.name != 'lsass' AND ps.ppid != 1)", err: errors.New("ps.name = 'cmd.exe' OR ((ps.name contains 'svc' AND ps.name != 'lsass' AND ps.ppid != 1)\n╭────────────────────────────────────────────────────────────────────────────────────────^\n|\n|\n╰─────────────────── expected ')'")},

		{expr: "ps.name = 'cmd.exe' OR ((ps.name contains 'svc' AND ps.name != 'lsass') AND ps.ppid != 1", err: errors.New("ps.name = 'cmd.exe' OR ((ps.name contains 'svc' AND ps.name != 'lsass') AND ps.ppid != 1\n╭────────────────────────────────────────────────────────────────────────────────────────^\n|\n|\n╰─────────────────── expected ')'")},

		{expr: "ps.none = 'cmd.exe'", err: errors.New("ps.none = 'cmd.exe'\n╭^\n|\n|\n╰─────────────────── expected field, bound field, string, number, bool, ip, function")},

		{expr: "ps.name = 'cmd.exe' AND ps.name IN ('exe') ps.name", err: errors.New("ps.name = 'cmd.exe' AND ps.name IN ('exe') ps.name\n╭──────────────────────────────────────────^\n|\n|\n╰─────────────────── expected operator, ')', ',', '|'")},
		{expr: "ip_cidr(net.dip) = '24'", err: errors.New("ip_cidr function is undefined. Did you mean one of BASE|CIDR_CONTAINS|CONCAT|COUNT|DIR|ENTROPY|EXT|FOREACH|GET_REG_VALUE|GLOB|INDEXOF|IS_ABS|IS_MINIDUMP|LENGTH|LOWER|LTRIM|MD5|REGEX|REPLACE|RTRIM|SPLIT|SUBSTR|UNDEFINED|UPPER|VOLUME|YARA?")},

		{expr: "ps.name = 'cmd.exe' and not cidr_contains(net.sip, '172.14.0.0')"},
		{expr: `ps.envs[ProgramFiles] = 'C:\\Program Files'`},
		{expr: `ps.envs imatches 'C:\\Program Files'`},
		{expr: `ps.pid[1] = 'svchost.exe'`, err: errors.New("ps.pid[1] = 'svchost.exe'\n╭──────^\n|\n|\n╰─────────────────── expected field without argument")},
		{expr: `ps.envs[ProgramFiles = 'svchost.exe'`, err: errors.New("ps.envs[ProgramFiles = 'svchost.exe'\n╭───────────────────^\n|\n|\n╰─────────────────── expected ]")},
		{expr: `evt.arg = 'svchost.exe'`, err: errors.New("evt.arg = 'svchost.exe'\n╭──────^\n|\n|\n╰─────────────────── expected field argument")},
		{expr: `evt.arg[name] = 'svchost.exe'`},
		{expr: `evt.arg[Name$] = 'svchost.exe'`, err: errors.New("evt.arg[Name$] = 'svchost.exe'\n╭───────^\n|\n|\n╰─────────────────── expected a valid field argument matching the pattern [a-z0-9_]+")},
		{expr: `ps.ancestor[0] = 'svchost.exe'`},
		{expr: `ps.ancestor[l0l] = 'svchost.exe'`, err: errors.New("ps.ancestor[l0l] = 'svchost.exe'\n╭───────────^\n|\n|\n╰─────────────────── expected a valid field argument matching the pattern [0-9]+")},
	}

	for i, tt := range tests {
		p := NewParser(tt.expr)
		_, err := p.ParseExpr()
		if err == nil && tt.err != nil {
			t.Errorf("%d. exp=%s expected error=%v", i, tt.expr, tt.err)
		} else if err != nil && tt.err != nil {
			assert.EqualError(t, tt.err, err.Error())
		} else if err != nil && tt.err == nil {
			t.Errorf("%d. exp=%s got error=%v", i, tt.expr, err)
		}
	}
}

func TestParseUnaryExpr(t *testing.T) {
	var tests = []struct {
		expr       string
		ee         Expr
		err        string
		assertions func(t *testing.T, e Expr)
	}{
		{"ps.name", &FieldLiteral{}, "", nil},
		{"ps.name[", &FieldLiteral{}, "expected ident, integer", nil},
		{"ps.name[svchost.exe]", &FieldLiteral{}, "expected field without argument", nil},
		{"ps.ancestor[1]", &FieldLiteral{}, "", func(t *testing.T, e Expr) {
			f := e.(*FieldLiteral)
			assert.Equal(t, "1", f.Arg)
		}},
		{"$entry", &BareBoundVariableLiteral{}, "", nil},
		{"$entry.entropy", &BoundSegmentLiteral{}, "", func(t *testing.T, e Expr) {
			s := e.(*BoundSegmentLiteral)
			assert.Equal(t, fields.EntropySegment, s.Segment)
			assert.Equal(t, "$entry.entropy", s.Value)
		}},
		{"$entry.file.path", &BoundFieldLiteral{}, "", func(t *testing.T, e Expr) {
			f := e.(*BoundFieldLiteral)
			assert.Equal(t, fields.FilePath, f.Field.Field)
			assert.Equal(t, "$entry.file.path", f.Value)
		}},
		{"$entry.foo", nil, "expected field/segment after bound ref", nil},
		{"('a', 'b', 'c')", &ListLiteral{}, "", nil},
		{"('a', 'b', 'c'", nil, "expected ')'", nil},
		{"base(file.path)", &Function{}, "", nil},
		{"base(file.path,", &Function{}, "expected field, bound field, string, number, bool, ip, function", nil},
	}

	for _, tt := range tests {
		t.Run(tt.expr, func(t *testing.T) {
			p := NewParser(tt.expr)

			expr, err := p.parseUnaryExpr()
			if err != nil && tt.err != "" {
				require.ErrorContains(t, err, tt.err)
			}
			if err != nil && tt.err == "" {
				assert.Fail(t, err.Error())
			}

			assert.IsType(t, tt.ee, expr)

			if tt.assertions != nil {
				tt.assertions(t, expr)
			}
		})
	}
}

func TestExpandMacros(t *testing.T) {
	var tests = []struct {
		c            *config.Filters
		expr         string
		expectedExpr string
		err          error
	}{
		{
			config.FiltersWithMacros(map[string]*config.Macro{"spawn_process": {Expr: "evt.name = 'CreateProcess'"}}),
			"spawn_process and ps.name in ('cmd.exe', 'powershell.exe')",
			"evt.name = CreateProcess AND ps.name IN (cmd.exe, powershell.exe)",
			nil,
		},
		{
			config.FiltersWithMacros(map[string]*config.Macro{"span_process": {Expr: "evt.name = 'CreateProcess'"}}),
			"spawn_process and ps.name in ('cmd.exe', 'powershell.exe')",
			"",
			errors.New("expected field, string, number, bool, ip, function, pattern binding"),
		},
		{
			config.FiltersWithMacros(map[string]*config.Macro{"spawn_process": {Expr: "evt.name = 'CreateProcess'"}, "command_clients": {List: []string{"cmd.exe", "pwsh.exe"}}}),
			"spawn_process and ps.name in command_clients",
			"evt.name = CreateProcess AND ps.name IN (cmd.exe, pwsh.exe)",
			nil,
		},
		{
			config.FiltersWithMacros(map[string]*config.Macro{"spawn_process": {Expr: "evt.nnname = 'CreateProcess'"}, "command_clients": {List: []string{"cmd.exe", "pwsh.exe"}}}),
			"spawn_process and ps.name in command_clients",
			"",
			errors.New("syntax error in \"spawn_process\" macro. expected field, string, number, bool, ip, function, pattern binding"),
		},
		{
			config.FiltersWithMacros(map[string]*config.Macro{
				"rename":    {Expr: "evt.name = 'RenameFile'"},
				"remove":    {Expr: "evt.name = 'DeleteFile'"},
				"modify":    {Expr: "rename or remove"},
				"wcm_files": {List: []string{"?:\\Users\\*\\AppData\\*\\Microsoft\\Credentials\\*"}}}),
			"(modify) and file.name imatches wcm_files",
			"(evt.name = RenameFile OR evt.name = DeleteFile) AND file.name IMATCHES (?:\\Users\\*\\AppData\\*\\Microsoft\\Credentials\\*)",
			nil,
		},
		{
			config.FiltersWithMacros(map[string]*config.Macro{
				"rename": {Expr: "evt.name = 'RenameFile'"},
				"remove": {Expr: "evt.name = 'DeleteFile'"},
				"modify": {Expr: "rename or remove"}}),
			"entropy(file.name) > 0.22 and ren",
			"",
			errors.New("expected field, string, number, bool, ip, function, pattern binding"),
		},
		{
			config.FiltersWithMacros(map[string]*config.Macro{
				"rename": {Expr: "evt.name = 'RenameFile'"},
				"remove": {Expr: "evt.name = 'DeleteFile'"},
				"modify": {Expr: "rename or remove"}}),
			"entropy(file.name) > 0.22 and rename",
			"entropy(file.name) > 2.2e-01 AND evt.name = RenameFile",
			nil,
		},
		{
			config.FiltersWithMacros(map[string]*config.Macro{
				"rename":    {Expr: "evt.name = 'RenameFile'"},
				"remove":    {Expr: "evt.name = 'DeleteFile'"},
				"create":    {Expr: "evt.name = 'CreateFile' and file.operation = 'create'"},
				"modify":    {Expr: "rename or remove"},
				"change_fs": {Expr: "modify or (create)"}}),
			"change_fs",
			"evt.name = RenameFile OR evt.name = DeleteFile OR (evt.name = CreateFile AND file.operation = create)",
			nil,
		},
	}

	for i, tt := range tests {
		p := NewParserWithConfig(tt.expr, tt.c)
		expr, err := p.ParseExpr()
		if err == nil && tt.err != nil {
			t.Errorf("%d. exp=%s expected error=\n%v", i, tt.expr, tt.err)
		} else if err != nil && tt.err == nil {
			t.Errorf("%d. exp=%s got error=\n%v", i, tt.expr, err)
		}
		if tt.expectedExpr != "" && expr.String() != tt.expectedExpr {
			t.Errorf("%d. exp=%s expected expr=%v", i, expr.String(), tt.expectedExpr)
		}
	}
}

func TestParseSequence(t *testing.T) {
	var tests = []struct {
		expr          string
		err           error
		maxSpan       time.Duration
		isConstrained bool
	}{
		{
			`evt.name = 'CreateProcess'|
			 |evt.name = 'CreateFile'|
			`,
			errors.New("expected |"),
			time.Duration(0),
			false,
		},
		{
			`|evt.name = 'CreateProcess'
			 evt.name = 'CreateFile'|
			`,
			errors.New("expected operator, ')', ',', '|'"),
			time.Duration(0),
			false,
		},
		{
			`|evt.name = 'CreateProcess'|
			 |evt.name = 'CreateFile'
			`,
			errors.New("expected |"),
			time.Duration(0),
			false,
		},
		{
			`|evt.name = 'CreateProcess'|
			 |evt.name = 'CreateFile'|
			`,
			nil,
			time.Duration(0),
			false,
		},
		{
			`|evt.name = 'CreateProcess'| by ps.exe
			 |evt.name = 'CreateFile'| by file.name
			`,
			nil,
			time.Duration(0),
			true,
		},
		{
			`|evt.name = 'CreateProcess'| by ps.exe, ps.uuid
			 |evt.name = 'CreateFile'| by file.name, ps.uuid
			`,
			nil,
			time.Duration(0),
			true,
		},
		{
			`by ps.exe, ps.uuid
			 |evt.name = 'CreateProcess'|
			 |evt.name = 'CreateFile'|
			`,
			nil,
			time.Duration(0),
			true,
		},
		{
			`|evt.name = 'CreateProcess'| by ps.exe, 
			 |evt.name = 'CreateFile'| by file.name, ps.uuid
			`,
			errors.New("expected field"),
			time.Duration(0),
			true,
		},
		{

			`by ps.pid
			 |evt.name = 'CreateProcess'|
			 |evt.name = 'CreateFile'|
			`,
			nil,
			time.Duration(0),
			true,
		},
		{

			`by ps.pid
			 |evt.name = 'CreateProcess'| by ps.pid
			 |evt.name = 'CreateFile'|
			`,
			errors.New("all expressions require the 'by' statement"),
			time.Duration(0),
			false,
		},
		{

			`|evt.name = 'CreateProcess'| by ps.pid
			 |evt.name = 'CreateFile'|
			`,
			errors.New("all expressions require the 'by' statement"),
			time.Duration(0),
			true,
		},
		{

			`maxspan 20s
			 |evt.name = 'CreateProcess'| by ps.pid
			 |evt.name = 'CreateFile'| by ps.pid
			`,
			nil,
			time.Second * 20,
			true,
		},
		{

			`maxspan 30s
			 |evt.name = 'CreateProcess'|
			 |evt.name = 'CreateFile'|
			`,
			nil,
			time.Second * 30,
			false,
		},
		{

			`maxspan 30s
			 |evt.name = 'CreateProcess'| as e1
			 |evt.name = 'CreateFile' and $e1.ps.name = file.name |
			`,
			nil,
			time.Second * 30,
			false,
		},
		{

			`maxspan 30s
			 |evt.name = 'CreateProcess'| as e1
			 |evt.name = 'CreateFile' and $e1.ps.ame = file.name |
			`,
			errors.New("expected field/segment after bound ref"),
			time.Second * 30,
			false,
		},
		{

			`maxspan 40h
			 |evt.name = 'CreateProcess'| as e1
			 |evt.name = 'CreateFile' and $e1.ps.ame = file.name |
			`,
			errors.New("maximum span 40h0m0s cannot be greater than 4h"),
			time.Hour * 40,
			false,
		},
		{

			`maxspan 2m
			 by ps.uuid
			 |evt.name = 'CreateProcess'| by ps.uuid
			 |evt.name = 'CreateFile'| by ps.uuid
			`,
			errors.New("sequence mixes global and per-expression 'by' statements"),
			time.Minute * 2,
			true,
		},
	}

	for i, tt := range tests {
		p := NewParser(tt.expr)
		seq, err := p.ParseSequence()
		if err == nil && tt.err != nil {
			t.Errorf("%d. exp=%s expected error=\n%v", i, tt.expr, tt.err)
		} else if err != nil && tt.err == nil {
			t.Errorf("%d. exp=%s got error=\n%v", i, tt.expr, err)
		}

		if err != nil && tt.err != nil {
			assert.True(t, strings.Contains(err.Error(), tt.err.Error()), fmt.Sprintf("error '%v' should contain '%v'", err, tt.err))
		}

		if seq != nil {
			if seq.MaxSpan != tt.maxSpan {
				t.Errorf("%d. exp=%s maxspan=%s got maxspan=%v", i, tt.expr, tt.maxSpan, seq.MaxSpan)
			}
			if seq.IsConstrained() != tt.isConstrained {
				t.Errorf("%d. exp=%s isConstrained=%t got isConstrained=%t", i, tt.expr, tt.isConstrained, seq.IsConstrained())
			}
		}
	}
}

func TestIsSequenceUnordered(t *testing.T) {
	var tests = []struct {
		expr        string
		isUnordered bool
	}{
		{
			`|evt.name = 'CreateProcess'| by ps.uuid
			 |evt.name = 'OpenProcess'| by ps.uuid
			`,
			true,
		},
		{
			`|evt.name = 'CreateProcess'|
			 |evt.name = 'CreateFile'|
			`,
			false,
		},
		{
			`|evt.name = 'CreateProcess'|
			 |evt.name = 'UnmapViewFile'|
 			 |evt.name = 'LoadImage'|
			`,
			false,
		},
		{
			`|evt.name = 'CreateProcess'|
			 |evt.name = 'SetThreadContext'|
			`,
			true,
		},
		{
			`|evt.name = 'OpenThread'| by ps.uuid
			 |evt.name = 'OpenProcess'| by ps.uuid
			`,
			false,
		},
		{
			`|evt.name = 'OpenThread' or evt.name = 'OpenProcess'| by ps.uuid
			 |evt.name = 'SetThreadContext'| by ps.uuid
			`,
			false,
		},
		{
			`|evt.name = 'RegSetValue'| by ps.uuid
			 |evt.name = 'SetThreadContext'| by ps.uuid
			`,
			true,
		},
		{
			`|evt.name = 'RegSetValue'| by ps.uuid
			 |evt.name = 'RegDeleteValue'| by ps.uuid
			`,
			false,
		},
		{
			`|evt.name = 'OpenProcess'| by ps.uuid
			 |evt.name = 'QueryDns'| by ps.uuid
			`,
			false,
		},
	}

	for i, tt := range tests {
		p := NewParser(tt.expr)
		seq, err := p.ParseSequence()
		require.NoError(t, err)

		if seq.IsUnordered != tt.isUnordered {
			t.Errorf("%d. exp=%s isUnordered=%t got isUnordered=%t", i, tt.expr, tt.isUnordered, seq.IsUnordered)
		}
	}
}

```

`pkg/filter/ql/token.go`:

```go
/*
 * Copyright 2019-2020 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package ql

import (
	"strings"
)

// token represents the lexical token of the filter expression
type token int

const (
	Illegal token = iota
	WS
	EOF

	BoundVar // $evt1.file.name
	Str      // 'cmd.exe'
	Badstr
	Badesc
	Ident
	Decimal  // 123.3
	Integer  // 123
	Duration // 13h
	IP       // 192.168.1.23
	BadIP    // 192.156.300.12
	True     // true
	False    // false

	opBeg
	And         // and
	Or          // or
	In          // in
	IIn         // iin
	Not         // not
	Contains    // contains
	IContains   // icontains
	IStartswith // istartswith
	Startswith  // startswith
	Endswith    // endswith
	IEndswith   // iendswith
	Matches     // matches
	IMatches    // imatches
	Fuzzy       // fuzzy
	IFuzzy      // ifuzzy
	Fuzzynorm   // fuzzynorm
	IFuzzynorm  // ifuzzynorm
	Intersects  // intersects
	IIntersects // iintersects
	Eq          // =
	IEq         // ~=
	Neq         // !=
	Lt          // <
	Lte         // <=
	Gt          // >
	Gte         // >=
	opEnd

	Lparen   // (
	Rparen   // )
	Comma    // ,
	Dot      // .
	Pipe     // |
	LBracket // [
	RBracket // ]

	Seq     // SEQUENCE
	MaxSpan // MAXSPAN
	By      // BY
	As      // AS
)

var keywords map[string]token

func init() {
	keywords = make(map[string]token)
	for _, tok := range []token{And, Or, Contains, IContains, In,
		IIn, Not, Startswith, IStartswith, Endswith, IEndswith,
		Matches, IMatches, Fuzzy, IFuzzy, Fuzzynorm, IFuzzynorm,
		Intersects, IIntersects, Seq, MaxSpan, By, As} {
		keywords[strings.ToLower(tokens[tok])] = tok
	}
	keywords["true"] = True
	keywords["false"] = False
}

var tokens = [...]string{
	Illegal: "ILLEGAL",
	EOF:     "EOF",
	WS:      "WS",

	Ident:    "IDENT",
	BoundVar: "BOUNDVAR",
	Integer:  "INTEGER",
	Decimal:  "DECIMAL",
	Duration: "DURATION",
	Str:      "STRING",
	Badstr:   "BADSTRING",
	Badesc:   "BADESCAPE",
	IP:       "IPADDRESS",
	BadIP:    "BADIPADDRESS",
	True:     "TRUE",
	False:    "FALSE",

	And:         "AND",
	Or:          "OR",
	Contains:    "CONTAINS",
	IContains:   "ICONTAINS",
	In:          "IN",
	IIn:         "IIN",
	Not:         "NOT",
	Startswith:  "STARTSWITH",
	IStartswith: "ISTARTSWITH",
	Endswith:    "ENDSWITH",
	IEndswith:   "IENDSWITH",
	Matches:     "MATCHES",
	IMatches:    "IMATCHES",
	Fuzzy:       "FUZZY",
	IFuzzy:      "IFUZZY",
	Fuzzynorm:   "FUZZYNORM",
	IFuzzynorm:  "IFUZZYNORM",
	Intersects:  "INTERSECTS",
	IIntersects: "IINTERSECTS",

	Eq:  "=",
	IEq: "~=",
	Neq: "!=",
	Lt:  "<",
	Lte: "<=",
	Gt:  ">",
	Gte: ">=",

	Lparen:   "(",
	Rparen:   ")",
	Comma:    ",",
	Dot:      ".",
	Pipe:     "|",
	LBracket: "[",
	RBracket: "]",

	Seq:     "SEQUENCE",
	MaxSpan: "MAXSPAN",
	By:      "BY",
	As:      "AS",
}

// isOperator determines whether the current token is an operator.
func (tok token) isOperator() bool { return tok > opBeg && tok < opEnd }

// String returns the string representation of the token.
func (tok token) String() string {
	if tok >= 0 && tok < token(len(tokens)) {
		return tokens[tok]
	}
	return ""
}

// precedence returns the operator precedence of the binary operator token.
func (tok token) precedence() int {
	switch tok {
	case Or:
		return 1
	case And:
		return 2
	case Not:
		return 3
	case Eq, IEq, Neq, Lt, Lte, Gt, Gte:
		return 4
	case In, IIn, Contains, IContains, Startswith, IStartswith, Endswith, IEndswith,
		Matches, IMatches, Fuzzy, IFuzzy, Fuzzynorm, IFuzzynorm, Intersects, IIntersects:
		return 5
	}
	return 0
}

func tokstr(tok token, lit string) string {
	if lit != "" {
		return lit
	}
	return tok.String()
}

// lookup returns the token associated with a given string.
func lookup(id string) (token, string) {
	if tok, ok := keywords[strings.ToLower(id)]; ok {
		return tok, ""
	}
	return Ident, id
}

```

`pkg/filter/ql/visitor.go`:

```go
/*
 * Copyright 2019-2020 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package ql

// Visitor can be called by Walk to traverse an AST hierarchy.
// The Visit() function is called once per node.
type Visitor interface {
	Visit(Node) Visitor
}

// Walk traverses a node hierarchy in depth-first order.
func Walk(v Visitor, node Node) {
	if node == nil {
		return
	}
	if v = v.Visit(node); v == nil {
		return
	}
	switch n := node.(type) {
	case *BinaryExpr:
		Walk(v, n.LHS)
		Walk(v, n.RHS)
	case *NotExpr:
		Walk(v, n.Expr)
	case *Function:
		for _, expr := range n.Args {
			Walk(v, expr)
		}
	case *ParenExpr:
		Walk(v, n.Expr)
	}
}

// WalkFunc traverses a node hierarchy in depth-first order.
func WalkFunc(node Node, fn func(Node)) {
	Walk(walkFuncVisitor(fn), node)
}

type walkFuncVisitor func(Node)

func (fn walkFuncVisitor) Visit(n Node) Visitor { fn(n); return fn }

```

`pkg/filter/util.go`:

```go
/*
 * Copyright 2021-present by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package filter

import (
	"encoding/hex"
	"net"
	"path/filepath"
	"strings"

	"github.com/rabbitstack/fibratus/pkg/event"
	"github.com/rabbitstack/fibratus/pkg/event/params"
	"github.com/rabbitstack/fibratus/pkg/filter/fields"
	"github.com/rabbitstack/fibratus/pkg/util/bytes"
	"github.com/rabbitstack/fibratus/pkg/util/loldrivers"
	"github.com/rabbitstack/fibratus/pkg/util/signature"
	"github.com/rabbitstack/fibratus/pkg/util/va"
)

// isLOLDriver interacts with the loldrivers client to determine
// whether the loaded/dropped driver is malicious or vulnerable.
func isLOLDriver(f fields.Field, e *event.Event) (params.Value, error) {
	var filename string

	if e.Category == event.File {
		filename = e.GetParamAsString(params.FilePath)
	} else {
		filename = e.GetParamAsString(params.ImagePath)
	}

	isDriver := filepath.Ext(filename) == ".sys" || e.Params.TryGetBool(params.FileIsDriver)
	if !isDriver {
		return nil, nil
	}
	ok, driver := loldrivers.GetClient().MatchHash(filename)
	if !ok {
		return nil, nil
	}
	if (f == fields.FileIsDriverVulnerable || f == fields.ImageIsDriverVulnerable) && driver.IsVulnerable {
		return true, nil
	}
	if (f == fields.FileIsDriverMalicious || f == fields.ImageIsDriverMalicious) && driver.IsMalicious {
		return true, nil
	}
	return false, nil
}

// initLOLDriversClient initializes the loldrivers client if the filter expression
// contains any of the relevant fields.
func initLOLDriversClient(flds []Field) {
	for _, f := range flds {
		if f.Name == fields.FileIsDriverVulnerable || f.Name == fields.FileIsDriverMalicious ||
			f.Name == fields.ImageIsDriverVulnerable || f.Name == fields.ImageIsDriverMalicious {
			loldrivers.InitClient(loldrivers.WithAsyncDownload())
		}
	}
}

// getSignature tries to find the module signature mapped to the given address.
// If the signature is not found in the cache, then a fresh signature instance
// is created and verified.
func getSignature(addr va.Address, filename string, parseCert bool) *signature.Signature {
	sign := signature.GetSignatures().GetSignature(addr.Uint64())
	if sign != nil {
		if parseCert {
			err := sign.ParseCertificate()
			if err != nil {
				certErrors.Add(1)
			}
		}
		return sign
	}

	var err error
	sign = &signature.Signature{Filename: filename}
	sign.Type, sign.Level, err = sign.Check()
	if err != nil {
		signatureErrors.Add(1)
	}

	if sign.IsSigned() {
		sign.Verify()
	}

	if parseCert {
		err = sign.ParseCertificate()
		if err != nil {
			certErrors.Add(1)
		}
	}

	signature.GetSignatures().PutSignature(addr.Uint64(), sign)

	return sign
}

// framePID returns the pid associated with the stack frame.
func framePID(e *event.Event) uint32 {
	if !e.Callstack.IsEmpty() && e.Callstack.FrameAt(0).PID != 0 {
		return e.Callstack.FrameAt(0).PID
	}
	return e.PID
}

// CompareSeqLink returns true if any value
// in the sequence link slice equals to the
// given LHS value.
func CompareSeqLink(lhs any, rhs []any) bool {
	if lhs == nil || rhs == nil {
		return false
	}
	for _, v := range rhs {
		if compareSeqLink(lhs, v) {
			return true
		}
	}
	return false
}

// CompareSeqLinks returns true any LHS sequence
// link values equal to the RHS sequence link values.
func CompareSeqLinks(lhs []any, rhs []any) bool {
	if lhs == nil || rhs == nil {
		return false
	}
	for _, v1 := range lhs {
		for _, v2 := range rhs {
			if compareSeqLink(v1, v2) {
				return true
			}
		}
	}
	return false
}

func compareSeqLink(lhs any, rhs any) bool {
	if lhs == nil || rhs == nil {
		return false
	}

	switch v := lhs.(type) {
	case string:
		s, ok := rhs.(string)
		if !ok {
			return false
		}
		return strings.EqualFold(v, s)
	case uint8:
		n, ok := rhs.(uint8)
		if !ok {
			return false
		}
		return v == n
	case uint16:
		n, ok := rhs.(uint16)
		if !ok {
			return false
		}
		return v == n
	case uint32:
		n, ok := rhs.(uint32)
		if !ok {
			return false
		}
		return v == n
	case uint64:
		n, ok := rhs.(uint64)
		if !ok {
			return false
		}
		if v == n {
			return true
		}
	case int:
		n, ok := rhs.(int)
		if !ok {
			return false
		}
		return v == n
	case uint:
		n, ok := rhs.(uint)
		if !ok {
			return false
		}
		return v == n
	case net.IP:
		ip, ok := rhs.(net.IP)
		if !ok {
			return false
		}
		return v.Equal(ip)
	}
	return false
}

// hashFields computes the hash of all field values.
func hashFields(values []any) string {
	buf := make([]byte, 0)
	for _, v := range values {
		switch val := v.(type) {
		case uint8:
			buf = append(buf, val)
		case uint16:
			buf = append(buf, bytes.WriteUint16(val)...)
		case uint32:
			buf = append(buf, bytes.WriteUint32(val)...)
		case uint64:
			buf = append(buf, bytes.WriteUint64(val)...)
		case int8:
			buf = append(buf, byte(val))
		case int16:
			buf = append(buf, bytes.WriteUint16(uint16(val))...)
		case int32:
			buf = append(buf, bytes.WriteUint32(uint32(val))...)
		case int64:
			buf = append(buf, bytes.WriteUint64(uint64(val))...)
		case int:
			buf = append(buf, bytes.WriteUint64(uint64(val))...)
		case uint:
			buf = append(buf, bytes.WriteUint64(uint64(val))...)
		case string:
			buf = append(buf, val...)
		case net.IP:
			buf = append(buf, val...)
		}
	}
	return hex.EncodeToString(buf)
}

func joinsEqual(joins []bool) bool {
	for _, j := range joins {
		if !j {
			return false
		}
	}
	return true
}

```

`pkg/fs/dev.go`:

```go
//go:build windows
// +build windows

/*
 * Copyright 2019-2020 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package fs

import (
	"github.com/rabbitstack/fibratus/pkg/sys"
	"os"
	"strings"
)

const deviceOffset = 8
const vmsmbDevice = `\Device\vmsmb`

// DevMapper is the minimal interface for the device converters.
type DevMapper interface {
	// Convert receives the fully qualified file path and replaces the DOS device name with a drive letter.
	Convert(filename string) string
}

type mapper struct {
	cache   map[string]string
	sysroot string
}

// NewDevMapper creates a new instance of the DOS device replacer.
func NewDevMapper() DevMapper {
	m := &mapper{
		cache: make(map[string]string),
	}

	// loop through logical drives and query the DOS device name
	for _, drive := range sys.GetLogicalDrives() {
		device, err := sys.QueryDosDevice(drive)
		if err != nil {
			continue
		}
		m.cache[device] = drive
	}

	// resolve the SystemRoot environment variable
	m.sysroot = os.Getenv("SystemRoot")
	if m.sysroot == "" {
		m.sysroot = os.Getenv("SYSTEMROOT")
	}

	return m
}

func (m *mapper) Convert(filename string) string {
	if filename == "" || len(filename) < deviceOffset {
		return filename
	}

	// find the backslash index
	n := strings.Index(filename[deviceOffset:], "\\")
	if n < 0 {
		if f, ok := m.cache[filename]; ok {
			return f
		}
		return filename
	}

	dev := filename[:n+deviceOffset]
	if drive, ok := m.cache[dev]; ok {
		// the mapping for the DOS device exists
		return strings.Replace(filename, dev, drive, 1)
	}

	switch {
	case dev == vmsmbDevice:
		// convert Windows Sandbox path to native path
		if n := strings.Index(filename, "os"); n > 0 {
			return "C:" + filename[n+2:]
		}
	case strings.HasPrefix(filename, "\\SystemRoot"):
		// normalize paths starting with SystemRoot
		return strings.Replace(filename, "\\SystemRoot", m.sysroot, 1)
	case strings.HasPrefix(filename, "\\SYSTEMROOT"):
		// normalize paths starting with SYSTEMROOT
		return strings.Replace(filename, "\\SYSTEMROOT", m.sysroot, 1)
	}

	return filename
}

```

`pkg/fs/dev_test.go`:

```go
//go:build windows
// +build windows

/*
 * Copyright 2019-2020 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package fs

import (
	"fmt"
	"strings"
	"testing"

	"github.com/stretchr/testify/assert"
)

var drives = []string{
	"A",
	"B",
	"C",
	"D",
	"E",
	"F",
	"G",
	"H",
	"I",
	"J",
	"K",
	"L",
	"M",
	"N",
	"O",
	"P",
	"Q",
	"R",
	"S",
	"T",
	"U",
	"V",
	"W",
	"X",
	"Y",
	"Z"}

func TestConvertDosDevice(t *testing.T) {
	m := NewDevMapper()
	files := make([]string, 0, len(drives))

	for _, drive := range drives {
		files = append(files, fmt.Sprintf("%s:\\Windows\\system32\\kernel32.dll", drive))
	}

	var filename string
	for i := 0; i < len(drives); i++ {
		filename = m.Convert(fmt.Sprintf("\\Device\\HarddiskVolume%d\\Windows\\system32\\kernel32.dll", i))
		if !strings.HasPrefix(filename, "\\Device") {
			break
		}
	}
	assert.Contains(t, files, filename)

	m.(*mapper).cache["\\Device\\HarddiskVolume1"] = "C:"
	m.(*mapper).cache["\\Device\\HarddiskVolume5"] = "\\Device\\HarddiskVolume5"
	m.(*mapper).sysroot = "C:\\Windows"

	var tests = []struct {
		inputFilename    string
		expectedFilename string
	}{
		{"\\Device\\HarddiskVolume1\\Windows\\system32\\kernel32.dll", "C:\\Windows\\system32\\kernel32.dll"},
		{"\\Device\\HarddiskVolume5\\Windows\\system32\\kernel32.dll", "\\Device\\HarddiskVolume5\\Windows\\system32\\kernel32.dll"},
		{"\\Device\\vmsmb\\VSMB-{dcc079ae-60ba-4d07-847c-3493609c0870}\\os\\Windows\\System32\\ntdll.dll", "C:\\Windows\\System32\\ntdll.dll"},
		{"\\SystemRoot\\system32\\drivers\\wd\\WdNisDrv.sys", "C:\\Windows\\system32\\drivers\\wd\\WdNisDrv.sys"},
		{"\\SYSTEMROOT\\system32\\drivers\\wd\\WdNisDrv.sys", "C:\\Windows\\system32\\drivers\\wd\\WdNisDrv.sys"},
		{"\\Device\\Mup", "\\Device\\Mup"},
	}

	for _, tt := range tests {
		t.Run(tt.inputFilename, func(t *testing.T) {
			assert.Equal(t, tt.expectedFilename, m.Convert(tt.inputFilename))
		})
	}
}

```

`pkg/fs/driver.go`:

```go
/*
 * Copyright 2021-2022 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package fs

import (
	"github.com/rabbitstack/fibratus/pkg/sys"
	"path/filepath"
	"strings"
)

// DevPathResolver resolves driver module paths from driver names.
// Prior to loading/unloading the kernel driver, the file object
// associated to it is opened. This gives us the opportunity to record
// the full path of the driver module and use it to augment events
// with this extra parameter.
type DevPathResolver struct {
	paths map[string]string
}

// NewDevPathResolver returns a new instance of driver device path resolver
func NewDevPathResolver() DevPathResolver {
	return DevPathResolver{paths: make(map[string]string)}
}

// AddPath adds the driver module path to the state of opened/created driver files.
func (d *DevPathResolver) AddPath(filename string) {
	isDriver := strings.EqualFold(filepath.Ext(filename), ".sys")
	if isDriver {
		d.paths[strings.ToLower(filepath.Base(filename))] = filename
	}
}

// RemovePath removes driver path from the state.
func (d *DevPathResolver) RemovePath(driver string) {
	delete(d.paths, driver)
}

// GetPath returns the full path to the driver module file. This method
// first perform a lookup in the opened/created driver modules. If the module
// is not found, then we enumerate all drivers and try to find the matching
// driver module path.
func (d *DevPathResolver) GetPath(driver string) string {
	path, ok := d.paths[strings.ToLower(driver)]
	if ok {
		return path
	}
	drivers := sys.EnumDevices()
	for _, drv := range drivers {
		if strings.EqualFold(strings.ToLower(filepath.Base(drv.Filename)), driver) {
			return drv.Filename
		}
	}
	return ""
}

```

`pkg/fs/file.go`:

```go
//go:build windows
// +build windows

/*
 * Copyright 2019-2020 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package fs

import (
	"expvar"
	"github.com/rabbitstack/fibratus/pkg/sys"
	"golang.org/x/sys/windows"
	"os"
	"path/filepath"
	"strings"
	"unsafe"
)

const (
	directoryFile = 0x00000001 // file being created or opened is a directory file

	deviceCDROM      = 0x00000002
	deviceCDROMFs    = 0x00000003
	deviceController = 0x00000004
	deviceDatalink   = 0x00000005
	deviceDFS        = 0x00000006
	deviceDisk       = 0x00000007
	deviceDiskFs     = 0x00000008

	devMailslot  = 0x0000000c
	devNamedPipe = 0x00000011

	devConsole = 0x00000050
)

// queryVolumeCalls represents the number of times the query volume function was called
var queryVolumeCalls = expvar.NewInt("file.query.volume.info.calls")

// GetFileType returns the underlying file type. The opts parameter corresponds to the NtCreateFile CreateOptions argument
// that specifies the options to be applied when creating or opening the file.
func GetFileType(filename string, opts uint32) FileType {
	if filename == "" {
		return Other
	}
	// if the CreateOptions argument of the NtCreateFile syscall has been invoked
	// with the FILE_DIRECTORY_FILE flag, it is likely that the target file object
	// is a directory. We ensure that by calling the API function for checking whether
	// the path name is truly a directory
	if (opts&directoryFile) != 0 && sys.PathIsDirectory(filename) {
		return Directory
	}
	// FILE_DIRECTORY_FILE flag only gives us a hint on the CreateFile op outcome. If this flag is
	// not present in the argument but the file is a directory, we can apply some simple heuristics
	// like checking the extension/suffix, even though they are not bullet-proof
	if filename[:len(filename)-1] == "\\" || filepath.Ext(filename) == "" {
		return Directory
	}
	// non directory file can be a regular file, logical, virtual or physical device or a volume.
	// If the filename doesn't start with a drive letter it's probably not a regular
	// file since we already have mapped the DOS name to drive letter
	if !strings.HasPrefix(filename, "\\Device") {
		return Regular
	}
	// if the filename contains the HardiskVolume string then we assume it is a file. This
	// could happen if we fail to resolve the DOS name
	if strings.HasPrefix(filename, "\\Device\\HarddiskVolume") {
		return Regular
	}
	// logical, virtual, physical device or a volume
	// obtain the device type that is linked to this file object
	return getFileTypeFromVolumeInfo(filename)
}

func getFileTypeFromVolumeInfo(filename string) FileType {
	f, err := os.Open(filename)
	if err != nil {
		return Other
	}
	defer f.Close()

	queryVolumeCalls.Add(1)

	var (
		iosb windows.IO_STATUS_BLOCK
		dev  sys.FileFsDeviceInformation
	)
	err = sys.NtQueryVolumeInformationFile(
		windows.Handle(f.Fd()),
		&iosb,
		uintptr(unsafe.Pointer(&dev)),
		uint32(unsafe.Sizeof(dev)),
		sys.FileFsDeviceInformationClass,
	)
	if err != nil {
		return Other
	}
	switch dev.Type {
	case deviceCDROM, deviceCDROMFs, deviceController,
		deviceDatalink, deviceDFS, deviceDisk, deviceDiskFs:
		if sys.PathIsDirectory(filename) {
			return Directory
		}
		return Regular
	case devConsole:
		return Console
	case devMailslot:
		return Mailslot
	case devNamedPipe:
		return Pipe
	default:
		return Other
	}
}

```

`pkg/fs/file_class.go`:

```go
/*
 * Copyright 2021-2022 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package fs

const (
	DispositionClass uint32 = 13
	AllocationClass  uint32 = 19
	EOFClass         uint32 = 20
)

// FileInfoClasses contains the values that specify which structure to use to query or set information for a file object.
// For more information see https://docs.microsoft.com/en-us/windows-hardware/drivers/ddi/wdm/ne-wdm-_file_information_class
var FileInfoClasses = map[uint32]string{
	1:  "Directory",
	2:  "Full Directory",
	3:  "Both Directory",
	4:  "Basic",
	5:  "Standard",
	6:  "Internal",
	7:  "EA",
	8:  "Access",
	9:  "Name",
	10: "Rename",
	11: "Link",
	12: "Names",
	13: "Disposition",
	14: "Position",
	15: "Full EA",
	16: "Mode",
	17: "Alignment",
	18: "All",
	19: "Allocation",
	20: "EOF",
	21: "Alternative Name",
	22: "Stream",
	23: "Pipe",
	24: "Pipe Local",
	25: "Pipe Remote",
	26: "Mailslot Query",
	27: "Mailslot Set",
	28: "Compression",
	29: "Object ID",
	30: "Completion",
	31: "Move Cluster",
	32: "Quota",
	33: "Reparse Point",
	34: "Network Open",
	35: "Attribute Tag",
	36: "Tracking",
	37: "ID Both Directory",
	38: "ID Full Directory",
	39: "Valid Data Length",
	40: "Short Name",
	41: "IO Completion Notification",
	42: "IO Status Block Range",
	43: "IO Priority Hint",
	44: "Sfio Reserve",
	45: "Sfio Volume",
	46: "Hard Link",
	47: "Process IDS Using File",
	48: "Normalized Name",
	49: "Network Physical Name",
	50: "ID Global Tx Directory",
	51: "Is Remote Device",
	52: "Unused",
	53: "Numa Node",
	54: "Standard Link",
	55: "Remote Protocol",
	56: "Rename Bypass Access Check",
	57: "Link Bypass Access Check",
	58: "Volume Name",
	59: "ID",
	60: "ID Extended Directory",
	61: "Replace Completion",
	62: "Hard Link Full ID",
	63: "ID Extended Both Directory",
	64: "Disposition Extended",
	65: "Rename Extended",
	66: "Rename Extended Bypass Access Check",
	67: "Desired Storage",
	68: "Stat",
	69: "Memory Partition",
	70: "Stat LX",
	71: "Case Sensitive",
	72: "Link Extended",
	73: "Link Extended Bypass Access Check",
	74: "Storage Reserve ID",
	75: "Case Sensitive Force Access Check",
}

```

`pkg/fs/file_test.go`:

```go
//go:build windows
// +build windows

/*
 * Copyright 2019-2020 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package fs

import (
	"github.com/stretchr/testify/assert"
	"testing"
)

func TestGetFileType(t *testing.T) {
	var tests = []struct {
		filename string
		opts     uint32
		wants    FileType
	}{
		{
			`_fixtures`,
			16777249,
			Directory,
		},
		{
			`_fixtures`,
			25165857,
			Directory,
		},
		{
			`C:\Users\bunny\AppData\Local\Mozilla\Firefox\Profiles\profile1.tmp`,
			18874368,
			Regular,
		},
	}

	for _, tt := range tests {
		t.Run(tt.filename, func(t *testing.T) {
			assert.Equal(t, tt.wants, GetFileType(tt.filename, tt.opts))
		})
	}
}

```

`pkg/fs/ntfs/ntfs.go`:

```go
/*
 * Copyright 2021-2022 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package ntfs

import (
	"fmt"
	log "github.com/sirupsen/logrus"
	"os"
	"strings"
	libntfs "www.velocidex.com/golang/go-ntfs/parser"
)

// MaxFullSizeRead specifies the maximum size in bytes for the file data
const MaxFullSizeRead int64 = 1024 * 1024 * 1024 * 50

// FS provides raw access to Master File Table (MFT)
// and file data blobs mounted on the NTFS.
type FS struct {
	dev *os.File
}

// NewFS creates a new instance of the NTFS file system.
func NewFS() *FS {
	return &FS{}
}

// Read reads the file from the raw device at the specified offset and size.
func (fs *FS) Read(path string, offset, size int64) ([]byte, int, error) {
	defer func() {
		if err := recover(); err != nil {
			log.Warnf("unable to read %s from raw device: %v", path, err)
		}
	}()
	ntfs, err := fs.getNTFSContext(path)
	if err != nil {
		return nil, 0, err
	}
	defer ntfs.Close()

	data := make([]byte, size)

	// skip drive letter, semicolon and slash (e.g. C:\)
	filename := strings.ReplaceAll(path[3:], "\\", "/")
	reader, err := libntfs.GetDataForPath(ntfs, filename)
	if err != nil {
		return nil, 0, err
	}
	n, err := reader.ReadAt(data, offset)
	return data, n, err
}

// ReadFull reads the entire content of the file into the byte buffer.
func (fs *FS) ReadFull(path string) ([]byte, int, error) {
	defer func() {
		if err := recover(); err != nil {
			log.Warnf("unable to read %s from raw device: %v", path, err)
		}
	}()
	ntfs, err := fs.getNTFSContext(path)
	if err != nil {
		return nil, 0, err
	}
	defer ntfs.Close()

	// get root MFT entry
	root, err := ntfs.GetMFT(5)
	if err != nil {
		return nil, 0, err
	}
	// get file size
	filename := strings.ReplaceAll(path[3:], "\\", "/")
	f, err := root.Open(ntfs, filename)
	if err != nil {
		return nil, 0, err
	}
	var size int64
	if stats := libntfs.Stat(ntfs, f); len(stats) > 0 {
		size = stats[0].Size
	}
	if size == 0 {
		return nil, 0, nil
	}
	if size > MaxFullSizeRead {
		return nil, 0, nil
	}
	// read file
	data := make([]byte, size)
	reader, err := libntfs.GetDataForPath(ntfs, filename)
	if err != nil {
		return nil, 0, err
	}
	n, err := reader.ReadAt(data, 0)
	return data, n, err
}

// Close disposes all underlying resources.
func (fs *FS) Close() error {
	if fs.dev != nil {
		return fs.dev.Close()
	}
	return nil
}

func (fs *FS) getNTFSContext(path string) (*libntfs.NTFSContext, error) {
	if len(path) < 3 || path[1] != ':' {
		return nil, nil
	}

	// open raw device
	dev := fmt.Sprintf("\\\\.\\%s", path[:2])
	var err error
	fs.dev, err = os.Open(dev)
	if err != nil {
		return nil, err
	}

	const pageSize = 0x1000
	const cacheSize = 1000

	// create reader and NTFS context
	r, err := libntfs.NewPagedReader(fs.dev, pageSize, cacheSize)
	if err != nil {
		return nil, err
	}
	return libntfs.GetNTFSContext(r, 0)
}

```

`pkg/fs/ntfs/ntfs_test.go`:

```go
/*
 * Copyright 2021-2022 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package ntfs

import (
	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/require"
	"os"
	"path/filepath"
	"testing"
)

func TestRead(t *testing.T) {
	file := filepath.Join(os.TempDir(), "ntfs-read.txt")
	err := os.WriteFile(file, []byte("ntfs read"), os.ModePerm)
	require.NoError(t, err)
	defer os.Remove(file)

	stat, err := os.Stat(file)
	require.NoError(t, err)

	fs := NewFS()
	defer fs.Close()

	b, n, err := fs.Read(file, 0, stat.Size())
	assert.NotNil(t, fs)
	require.NoError(t, err)
	require.True(t, n != 0)

	assert.Equal(t, []byte("ntfs read"), b)

	f, err := os.OpenFile(file, os.O_APPEND|os.O_WRONLY|os.O_CREATE, 0600)
	require.NoError(t, err)
	defer f.Close()

	_, err = f.WriteString(" with a bit more of read")
	require.NoError(t, err)

	b, n, err = fs.Read(file, 0, 512)
	require.NoError(t, err)
	require.True(t, n != 0)
	assert.Equal(t, []byte("ntfs read with a bit more of read"), b[:33])
}

func TestReadFull(t *testing.T) {
	file := filepath.Join(os.TempDir(), "ntfs-read-full.txt")
	err := os.WriteFile(file, []byte("ntfs read from mars to sirius where the whales fly into oblivion"), os.ModePerm)
	require.NoError(t, err)
	defer os.Remove(file)

	fs := NewFS()
	defer fs.Close()

	b, n, err := fs.ReadFull(file)
	assert.NotNil(t, fs)
	require.NoError(t, err)
	require.True(t, n != 0)

	assert.Equal(t, []byte("ntfs read from mars to sirius where the whales fly into oblivion"), b)
}

```

`pkg/fs/types.go`:

```go
//go:build windows
// +build windows

/*
 * Copyright 2019-2020 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package fs

import "golang.org/x/sys/windows"

// FileCreateDispositions is the mapping between the file create disposition and its symbolical name.
var FileCreateDispositions = map[uint32]string{
	uint32(windows.FILE_SUPERSEDE):    "SUPERSEDE",
	uint32(windows.FILE_OPEN):         "OPEN",
	uint32(windows.FILE_CREATE):       "CREATE",
	uint32(windows.FILE_OPEN_IF):      "OPEN_IF",
	uint32(windows.FILE_OVERWRITE):    "OVERWRITE",
	uint32(windows.FILE_OVERWRITE_IF): "OVERWRITE_IF",
}

// FileType is the type alias for the file type
type FileType uint8

const (
	// Regular represents the file, volume or hard disk device
	Regular FileType = iota
	// Directory represents the directory
	Directory
	// Pipe represent the pipe
	Pipe
	// Console denotes the standard output stream
	Console
	// Mailslot denotes a mail slot file
	Mailslot
	// Other is the file type different from listed above
	Other
	// Unknown is the unknown file type
	Unknown
)

// String returns the textual representation of the file type.
func (typ FileType) String() string {
	switch typ {
	case Regular:
		return "file"
	case Directory:
		return "directory"
	case Pipe:
		return "pipe"
	case Console:
		return "console"
	case Mailslot:
		return "mailslot"
	case Other:
		return "other"
	default:
		return "unknown"
	}
}

// FileTypes represents the mapping of file type identifiers to their string values.
var FileTypes = map[uint32]string{
	uint32(Regular):   "File",
	uint32(Directory): "Directory",
	uint32(Pipe):      "Pipe",
	uint32(Console):   "Console",
	uint32(Mailslot):  "Mailslot",
	uint32(Other):     "Other",
}

```

`pkg/handle/alpc.go`:

```go
//go:build windows
// +build windows

/*
 * Copyright 2019-2020 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package handle

import (
	htypes "github.com/rabbitstack/fibratus/pkg/handle/types"
	"github.com/rabbitstack/fibratus/pkg/sys"
	"golang.org/x/sys/windows"
	"unsafe"
)

// GetAlpcPort get ALPC port information for the specified ALPC port handle.
func GetAlpcPort(handle windows.Handle) (*htypes.AlpcPortInfo, error) {
	b := make([]byte, 16)
	err := sys.NtAlpcQueryInformation(handle, sys.AlpcBasicPortInformationClass, unsafe.Pointer(&b[0]), uint32(len(b)), nil)
	if err != nil {
		return nil, err
	}
	return (*htypes.AlpcPortInfo)(unsafe.Pointer(&b[0])), nil
}

```

`pkg/handle/mutant.go`:

```go
//go:build windows
// +build windows

/*
 * Copyright 2019-2020 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package handle

import (
	htypes "github.com/rabbitstack/fibratus/pkg/handle/types"
	"github.com/rabbitstack/fibratus/pkg/sys"
	"golang.org/x/sys/windows"
	"unsafe"
)

// GetMutant gets the information about specified mutant handle.
func GetMutant(handle windows.Handle) (*htypes.MutantInfo, error) {
	b := make([]byte, 8)
	err := sys.NtQueryMutant(handle, sys.MutantBasicInformationClass, unsafe.Pointer(&b[0]), uint32(len(b)), nil)
	if err != nil {
		return nil, err
	}
	return (*htypes.MutantInfo)(unsafe.Pointer(&b[0])), nil
}

```

`pkg/handle/object.go`:

```go
//go:build windows
// +build windows

/*
 * Copyright 2019-2020 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package handle

import (
	"errors"
	"fmt"
	"github.com/rabbitstack/fibratus/pkg/fs"
	htypes "github.com/rabbitstack/fibratus/pkg/handle/types"
	"github.com/rabbitstack/fibratus/pkg/sys"
	"github.com/rabbitstack/fibratus/pkg/util/key"
	"golang.org/x/sys/windows"
)

var devMapper = fs.NewDevMapper()

// Duplicate duplicates the handle in the caller process's address space.
func Duplicate(handle windows.Handle, pid uint32, access uint32) (windows.Handle, error) {
	//  handle to the process with the handle to be duplicated.
	source, err := windows.OpenProcess(windows.PROCESS_DUP_HANDLE, false, pid)
	if err != nil {
		return windows.InvalidHandle, err
	}
	//nolint:errcheck
	defer windows.CloseHandle(source)
	// duplicate the remote handle in the current process's address space.
	// Note that for certain handle types this operation might fail
	// as they don't permit duplicate operations
	var dup windows.Handle
	err = windows.DuplicateHandle(source, handle, windows.CurrentProcess(), &dup, access, false, 0)
	if err != nil {
		return windows.InvalidHandle, fmt.Errorf("unable to duplicate handle: %v", err)
	}
	return dup, nil
}

// QueryObjectType returns the type of the specified object.
func QueryObjectType(obj windows.Handle) (string, error) {
	typeInfo, err := sys.QueryObject[sys.ObjectTypeInformation](obj, sys.ObjectTypeInformationClass)
	if err != nil {
		return "", fmt.Errorf("unable to query handle type: %v", err)
	}
	length := typeInfo.TypeName.Length
	if length > 0 {
		return typeInfo.TypeName.String(), nil
	}
	return "", errors.New("zero length handle type name encountered")
}

// QueryObjectName returns the object name of the specified object.
func QueryObjectName(obj windows.Handle) (string, error) {
	nameInfo, err := sys.QueryObject[sys.ObjectNameInformation](obj, sys.ObjectNameInformationClass)
	if err != nil {
		return "", fmt.Errorf("unable to query object name: %v", err)
	}
	length := nameInfo.ObjectName.Length
	if length > 0 {
		return nameInfo.ObjectName.String(), nil
	}
	return "", nil
}

// QueryName gets the name of the underlying handle reference and extra metadata if it is available.
func QueryName(handle windows.Handle, typ string, withTimeout bool) (string, htypes.Meta, error) {
	switch typ {
	case File:
		if !withTimeout {
			return "", nil, nil
		}
		// delegate the name resolution to the deadlock aware handle timeout
		name, err := GetHandleWithTimeout(handle, 500)
		if err != nil {
			return "", nil, err
		}
		name = devMapper.Convert(name)
		fileInfo := &htypes.FileInfo{IsDirectory: sys.PathIsDirectory(name)}
		return name, fileInfo, nil
	case ALPCPort:
		port, err := GetAlpcPort(handle)
		if err != nil {
			return "", nil, nil
		}
		return "", port, nil
	case Process:
		var size uint32 = windows.MAX_PATH
		n := make([]uint16, size)
		err := windows.QueryFullProcessImageName(handle, 0, &n[0], &size)
		if err != nil {
			return "", nil, err
		}
		return windows.UTF16ToString(n), nil, nil
	case Mutant:
		mutant, err := GetMutant(handle)
		if err != nil {
			return "", nil, nil
		}
		return "", mutant, nil
	default:
		name, err := QueryObjectName(handle)
		if err != nil {
			return "", nil, err
		}
		switch typ {
		case Key:
			rootKey, subkey := key.Format(name)
			if rootKey == key.Invalid {
				return name, nil, nil
			}
			if subkey != "" {
				return rootKey.String() + "\\" + subkey, nil, nil
			}
			return rootKey.String(), nil, nil
		default:
			return name, nil, nil
		}
	}
}

```

`pkg/handle/object_test.go`:

```go
//go:build windows
// +build windows

/*
 * Copyright 2019-2020 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package handle

import (
	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/require"
	"golang.org/x/sys/windows"
	"os"
	"path/filepath"
	"syscall"
	"testing"
	"unsafe"
)

var (
	modkernel32 = windows.NewLazyDLL("kernel32.dll")

	procCreateNamedPipeW = modkernel32.NewProc("CreateNamedPipeW")
)

func createNamedPipe(name *uint16, openMode uint32, pipeMode uint32, maxInstances uint32, outBufSize uint32, inBufSize uint32, defaultTimeout uint32, sa *syscall.SecurityAttributes) (handle syscall.Handle, err error) {
	r0, _, e1 := syscall.SyscallN(procCreateNamedPipeW.Addr(), uintptr(unsafe.Pointer(name)), uintptr(openMode), uintptr(pipeMode), uintptr(maxInstances), uintptr(outBufSize), uintptr(inBufSize), uintptr(defaultTimeout), uintptr(unsafe.Pointer(sa)), 0)
	handle = syscall.Handle(r0)
	if handle == syscall.InvalidHandle {
		if e1 != 0 {
			err = error(e1)
		} else {
			err = syscall.EINVAL
		}
	}
	return
}

// createPipe is mainly borrowed from: https://github.com/natefinch/npipe for testing purposes.
func createPipe(address string, first bool) (syscall.Handle, error) {
	n, err := syscall.UTF16PtrFromString(address)
	if err != nil {
		return 0, err
	}
	mode := uint32(0x3 | syscall.FILE_FLAG_OVERLAPPED)
	if first {
		mode |= 0x00080000
	}
	return createNamedPipe(n,
		mode,
		0x0,
		255,
		512, 512, 0, nil)
}

func TestQueryType(t *testing.T) {
	h, err := windows.OpenProcess(windows.PROCESS_QUERY_INFORMATION, false, uint32(os.Getpid()))
	require.NoError(t, err)
	defer windows.CloseHandle(h)
	typeName, err := QueryObjectType(h)
	require.NoError(t, err)
	assert.Equal(t, Process, typeName)
}

func TestQueryNameFileHandle(t *testing.T) {
	f, err := windows.Open("_fixtures/.fibratus", windows.O_RDONLY, windows.S_ISUID)
	require.NoError(t, err)
	defer windows.Close(f)
	handleName, _, err := QueryName(f, File, true)
	require.NoError(t, err)
	assert.Equal(t, ".fibratus", filepath.Base(handleName))
}

func TestQueryNamedPipe(t *testing.T) {
	h, err := createPipe(`\\.\pipe\fibratus`, true)
	require.NoError(t, err)
	defer syscall.Close(h)
	handleName, _, err := QueryName(windows.Handle(h), File, true)
	require.NoError(t, err)
	assert.Equal(t, `\Device\NamedPipe\fibratus`, handleName)
}

```

`pkg/handle/snapshotter.go`:

```go
//go:build windows
// +build windows

/*
 * Copyright 2019-2020 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package handle

import (
	"expvar"
	"fmt"
	"github.com/rabbitstack/fibratus/pkg/sys"
	"golang.org/x/sys/windows"
	"os"
	"strconv"
	"sync"
	"time"
	"unsafe"

	"github.com/rabbitstack/fibratus/pkg/config"
	"github.com/rabbitstack/fibratus/pkg/event"
	"github.com/rabbitstack/fibratus/pkg/event/params"
	htypes "github.com/rabbitstack/fibratus/pkg/handle/types"
	log "github.com/sirupsen/logrus"
)

var (
	globalBufferSize uint32 = 4096

	handleNameQueryFailures = expvar.NewMap("handle.name.query.failures")
	handleSnapshotCount     = expvar.NewInt("handle.snapshot.count")
	handleSnapshotBytes     = expvar.NewInt("handle.snapshot.bytes")
)

const (
	// maxProcHandles determines the maximum number of handles the handle snapshotter can store
	maxProcHandles = 70000
	// maxHandlesPerProc determines the maximum number of handles a particular process state can store
	maxHandlesPerProc = 800
)

// CreateCallback defines the function that is triggered when new handle is conceived
type CreateCallback func(pid uint32, handle htypes.Handle)

// DestroyCallback defines the function signature that is fired upon handle's destruction
type DestroyCallback func(pid uint32, rawHandle windows.Handle)

// SnapshotBuildCompleted is the function type for snapshot completed signal
type SnapshotBuildCompleted func(total uint64, named uint64)

// Snapshotter keeps the system-wide snapshot of allocated handles always when handle kernel events are enabled or
// supported on the target system. It also provides facilities for obtaining a list of handles pertaining to the specific
// process.
type Snapshotter interface {
	// Write updates the snapshotter state by storing a new entry for the inbound create handle event. It also notifies
	// the registered callback that a new handle has been created.
	Write(evt *event.Event) error
	// Remove destroys the handle state for the specified handle object. The removal callback is triggered when an item
	// is deleted from the store.
	Remove(evt *event.Event) error
	// FindHandles returns a list of all known handles for the specified process identifier.
	FindHandles(pid uint32) ([]htypes.Handle, error)
	// FindByObject returns the handle for the given handle object reference.
	FindByObject(object uint64) (htypes.Handle, bool)
	// RegisterCreateCallback registers a function that's triggered when new handle is created.
	RegisterCreateCallback(fn CreateCallback)
	// RegisterDestroyCallback registers a function that's called when existing handle is disposed.
	RegisterDestroyCallback(fn DestroyCallback)
	// GetSnapshot returns all the handles present in the snapshotter state.
	GetSnapshot() []htypes.Handle
	// Close closes snapshotter and disposes all allocated resources.
	Close() error
}

type snapshotter struct {
	mu                     sync.Mutex
	handlesByObject        map[uint64]htypes.Handle
	hc                     chan htypes.Handle
	hdone                  chan struct{}
	config                 *config.Config
	snapshotBuildCompleted SnapshotBuildCompleted
	createCallback         CreateCallback
	destroyCallback        DestroyCallback
	housekeepTick          *time.Ticker
	initSnap               bool
	capture                bool
}

// NewSnapshotter constructs a new instance of the handle snapshotter. If `SnapshotBuildCompleted` function is provided
// it will receive the total number of discovered handles as well as the count of the non-nameless handles.
func NewSnapshotter(config *config.Config, fn SnapshotBuildCompleted) Snapshotter {
	s := &snapshotter{
		hc:                     make(chan htypes.Handle),
		hdone:                  make(chan struct{}, 1),
		handlesByObject:        make(map[uint64]htypes.Handle),
		snapshotBuildCompleted: fn,
		config:                 config,
		housekeepTick:          time.NewTicker(time.Minute),
		initSnap:               config.InitHandleSnapshot,
	}

	if s.initSnap {
		go s.consumeHandles()
		go s.initSnapshot()
		go s.housekeeping()
	} else {
		if fn != nil {
			fn(0, 0)
		}
	}

	return s
}

// NewFromCapture builds the handle snapshotter from the capture state.
func NewFromCapture(handles []htypes.Handle) Snapshotter {
	s := &snapshotter{
		handlesByObject: make(map[uint64]htypes.Handle),
		capture:         true,
	}
	for _, handle := range handles {
		s.handlesByObject[handle.Object] = handle
	}
	return s
}

func (s *snapshotter) FindByObject(object uint64) (htypes.Handle, bool) {
	s.mu.Lock()
	defer s.mu.Unlock()
	if h, ok := s.handlesByObject[object]; ok {
		return h, ok
	}
	return htypes.Handle{}, false
}

func (s *snapshotter) FindHandles(pid uint32) ([]htypes.Handle, error) {
	if !s.config.EnumerateHandles {
		return []htypes.Handle{}, nil
	}
	if pid == uint32(os.Getpid()) || pid == 0 { // ignore current, idle processes
		return []htypes.Handle{}, nil
	}
	if s.capture {
		handles := make([]htypes.Handle, 0)
		s.mu.Lock()
		defer s.mu.Unlock()
		for _, h := range s.handlesByObject {
			if h.Pid == pid {
				handles = append(handles, h)
			}
		}
		return handles, nil
	}
	process, err := windows.OpenProcess(windows.PROCESS_QUERY_INFORMATION, false, pid)
	if err != nil {
		// trying to obtain the handle with `PROCESS_QUERY_INFORMATION` access on a protected
		// process will always fail, so our best effort is to collect handles for those
		// processes in the snapshot's state
		handles := make([]htypes.Handle, 0)
		s.mu.Lock()
		defer s.mu.Unlock()
		for _, h := range s.handlesByObject {
			if h.Pid == pid && h.Type != "" {
				handles = append(handles, h)
			}
		}
		return handles, nil
	}
	//nolint:errcheck
	defer windows.CloseHandle(process)

	snapshot, err := sys.QueryInformationProcess[sys.ProcessHandleSnapshotInformation](process, windows.ProcessHandleInformation)
	if err != nil {
		if err.Error() == "An attempt was made to access an exiting process." {
			return nil, nil
		}
		return nil, fmt.Errorf("unable to query handles for process id %d: %v", pid, err)
	}

	// enumerate process's handles and try to resolve
	// the type and the name of each allocated handle
	handles := make([]htypes.Handle, 0)
	count := snapshot.NumberOfHandles
	if count > maxHandlesPerProc {
		log.Warnf("maximum handle table size reached for %d pid. "+
			"Shrinking table size from %d to %d handles", pid, count, maxHandlesPerProc)
		count = maxHandlesPerProc
	}
	sysHandles := (*[1 << 30]sys.ProcessHandleTableEntryInfo)(unsafe.Pointer(&snapshot.Handles[0]))[:count:count]

	for _, sysHandle := range sysHandles {
		h, err := s.getHandle(sysHandle.Handle, 0, uint16(sysHandle.ObjectTypeIndex), pid, false)
		if err != nil {
			continue
		}
		// ignore file handles since we can't get the
		// file name. Also, only collect named handles
		if h.Type == File && h.Name == "" {
			continue
		}
		handles = append(handles, h)
	}
	return handles, nil
}

// initSnapshot builds the initial snapshot state by enumerating system-wide handles.
func (s *snapshotter) initSnapshot() {
	size := globalBufferSize
	buf := make([]byte, size)
	for {
		err := windows.NtQuerySystemInformation(windows.SystemExtendedHandleInformation, unsafe.Pointer(&buf[0]), size, nil)
		if err == windows.STATUS_INFO_LENGTH_MISMATCH || err == windows.STATUS_BUFFER_TOO_SMALL || err == windows.STATUS_BUFFER_OVERFLOW {
			size *= 2
			buf = make([]byte, size)
		} else if err == nil {
			sysHandleInfo := (*sys.SystemHandleInformationEx)(unsafe.Pointer(&buf[0]))
			count := int(sysHandleInfo.NumberOfHandles)
			if count > maxProcHandles {
				log.Warnf("handle snapshotter size exceeded. Shrinking from %d to %d handles", count, maxProcHandles)
				count = maxProcHandles
			}
			sysHandles := (*[1 << 30]sys.SystemHandleTableEntryInfoEx)(unsafe.Pointer(&sysHandleInfo.Handles[0]))[:count:count]

			// iterate through available handles to get extended info
			// and send handle structure instances to the channel
			for _, sysHandle := range sysHandles {
				pid := sysHandle.ProcessID
				if pid == uintptr(os.Getpid()) {
					continue
				}
				handle, err := s.getHandle(sysHandle.Handle, sysHandle.Object, sysHandle.ObjectTypeIndex, uint32(pid), true)
				if err != nil || handle.Type == "" {
					continue
				}
				s.hc <- handle
			}
			s.hdone <- struct{}{}
			break
		} else {
			log.Warnf("couldn't enumerate system-wide handles: %v", err)
			break
		}
	}
}

func (s *snapshotter) getHandle(rawHandle windows.Handle, obj uint64, typeIndex uint16, pid uint32, withTimeout bool) (htypes.Handle, error) {
	typ := htypes.ConvertTypeIDToName(typeIndex)
	if typ == "" {
		dup, err := Duplicate(rawHandle, pid, windows.GENERIC_ALL)
		if err != nil {
			return htypes.Handle{Num: rawHandle, Object: obj}, nil
		}
		typ, err = QueryObjectType(dup)
		if err != nil {
			return htypes.Handle{Num: rawHandle, Object: obj}, nil
		}
	}
	handle := htypes.Handle{
		Num:    rawHandle,
		Object: obj,
		Type:   typ,
		Pid:    pid,
	}
	// IoCompletion handles shouldn't be duplicated
	if handle.Type == IoCompletion {
		return handle, nil
	}
	// use the required duplicate access to query handle name
	var dupAccess uint32
	switch typ {
	case ALPCPort:
		dupAccess = windows.READ_CONTROL
	case Process:
		dupAccess = windows.PROCESS_QUERY_INFORMATION
	case Mutant:
		dupAccess = windows.SEMAPHORE_ALL_ACCESS
	}
	dup, err := Duplicate(rawHandle, pid, dupAccess)
	if err != nil {
		return handle, err
	}
	//nolint:errcheck
	defer windows.CloseHandle(dup)
	handle.Name, handle.MD, err = QueryName(dup, typ, withTimeout)
	if err != nil {
		// even though we weren't able to query handle name we still
		// return handle info with handle type and other metadata
		handleNameQueryFailures.Add(strconv.Itoa(int(pid)), 1)
		return handle, nil
	}
	return handle, nil
}

func (s *snapshotter) consumeHandles() {
	for {
		select {
		case h := <-s.hc:
			s.mu.Lock()
			handleSnapshotCount.Add(1)
			handleSnapshotBytes.Add(int64(h.Len()))
			s.handlesByObject[h.Object] = h
			s.mu.Unlock()
		case <-s.hdone:
			log.Debug("initial handle enumeration has finalized")
			s.mu.Lock()
			var named uint64
			for _, h := range s.handlesByObject {
				if h.Name != "" {
					named++
				}
				if s.createCallback != nil && h.Type == File {
					// for safety reasons related to deadlocks we are skipping file handles
					// for Rundown/Create process events, we'll send these handles after initial
					// system-wide scan has completed
					if h.Name != "" {
						s.createCallback(h.Pid, h)
					}
				}
			}
			s.mu.Unlock()
			if s.snapshotBuildCompleted != nil {
				s.snapshotBuildCompleted(uint64(len(s.handlesByObject)), named)
			}
			return
		}
	}
}

func (s *snapshotter) housekeeping() {
	for {
		<-s.housekeepTick.C

		size := globalBufferSize
		buf := make([]byte, size)
	loop:
		for {
			err := windows.NtQuerySystemInformation(windows.SystemExtendedHandleInformation, unsafe.Pointer(&buf[0]), size, nil)
			if err == windows.STATUS_INFO_LENGTH_MISMATCH || err == windows.STATUS_BUFFER_TOO_SMALL || err == windows.STATUS_BUFFER_OVERFLOW {
				size *= 2
				buf = make([]byte, size)
			} else if err == nil {
				sysHandleInfo := (*sys.SystemHandleInformationEx)(unsafe.Pointer(&buf[0]))
				count := int(sysHandleInfo.NumberOfHandles)
				if count > maxProcHandles {
					log.Warnf("handle snapshotter size exceeded. Shrinking from %d to %d handles", count, maxProcHandles)
					count = maxProcHandles
				}
				sysHandles := (*[1 << 30]sys.SystemHandleTableEntryInfoEx)(unsafe.Pointer(&sysHandleInfo.Handles[0]))[:count:count]

				s.mu.Lock()
				for _, sysHandle := range sysHandles {
					if handle, ok := s.handlesByObject[sysHandle.Object]; !ok {
						handleSnapshotCount.Add(-1)
						handleSnapshotBytes.Add(-int64(handle.Len()))
						delete(s.handlesByObject, sysHandle.Object)
					}
				}
				s.mu.Unlock()

				break loop
			} else {
				log.Warnf("couldn't get system-wide handles in housekeeping timer: %v", err)
				break loop
			}
		}
	}
}

func (s *snapshotter) RegisterCreateCallback(fn CreateCallback) {
	s.createCallback = fn
}

func (s *snapshotter) RegisterDestroyCallback(fn DestroyCallback) {
	s.destroyCallback = fn
}

func (s *snapshotter) GetSnapshot() []htypes.Handle {
	handles := make([]htypes.Handle, 0, len(s.handlesByObject))
	for _, h := range s.handlesByObject {
		handles = append(handles, h)
	}
	return handles
}

func (s *snapshotter) Write(e *event.Event) error {
	if !e.IsCreateHandle() {
		return fmt.Errorf("expected CreateHandle event but got %s", e.Type)
	}
	h := unwrapHandle(e)
	obj, err := e.Params.GetUint64(params.HandleObject)
	if err != nil {
		return err
	}
	s.mu.Lock()
	s.handlesByObject[obj] = h
	s.mu.Unlock()
	return nil
}

func (s *snapshotter) Remove(e *event.Event) error {
	if !e.IsCloseHandle() {
		return fmt.Errorf("expected CloseHandle event but got %s", e.Type)
	}
	obj, err := e.Params.GetUint64(params.HandleObject)
	if err != nil {
		return err
	}
	s.mu.Lock()
	delete(s.handlesByObject, obj)
	s.mu.Unlock()
	return nil
}

func (s *snapshotter) Close() error {
	if s.housekeepTick != nil {
		s.housekeepTick.Stop()
	}
	return nil
}

func unwrapHandle(e *event.Event) htypes.Handle {
	h := htypes.Handle{}
	h.Type = e.GetParamAsString(params.HandleObjectTypeID)
	h.Object, _ = e.Params.GetUint64(params.HandleObject)
	h.Name, _ = e.Params.GetString(params.HandleObjectName)
	return h
}

```

`pkg/handle/snapshotter_mock.go`:

```go
//go:build windows
// +build windows

/*
 * Copyright 2019-2020 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package handle

import (
	"github.com/rabbitstack/fibratus/pkg/event"
	htypes "github.com/rabbitstack/fibratus/pkg/handle/types"
	"github.com/stretchr/testify/mock"
)

// SnapshotterMock is the mock handle snapshotter used in tests.
type SnapshotterMock struct {
	mock.Mock
}

// Write method
func (s *SnapshotterMock) Write(evt *event.Event) error {
	args := s.Called(evt)
	return args.Error(0)
}

// Remove method
func (s *SnapshotterMock) Remove(evt *event.Event) error {
	args := s.Called(evt)
	return args.Error(0)
}

// FindHandles method
func (s *SnapshotterMock) FindHandles(pid uint32) ([]htypes.Handle, error) {
	args := s.Called(pid)
	return args.Get(0).([]htypes.Handle), args.Error(1)
}

// FindByObject method
func (s *SnapshotterMock) FindByObject(object uint64) (htypes.Handle, bool) {
	args := s.Called(object)
	return args.Get(0).(htypes.Handle), args.Bool(1)
}

// RegisterCreateCallback method
func (s *SnapshotterMock) RegisterCreateCallback(fn CreateCallback) {}

// RegisterDestroyCallback method
func (s *SnapshotterMock) RegisterDestroyCallback(fn DestroyCallback) {}

// GetSnapshot method
func (s *SnapshotterMock) GetSnapshot() []htypes.Handle {
	handles := s.Called()
	return handles.Get(0).([]htypes.Handle)
}

// Close method
func (s *SnapshotterMock) Close() error { return nil }

```

`pkg/handle/snapshotter_test.go`:

```go
//go:build windows
// +build windows

/*
 * Copyright 2019-2020 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package handle

import (
	"github.com/rabbitstack/fibratus/pkg/config"
	"github.com/stretchr/testify/require"
	"os"
	"testing"
	"time"
)

func TestInitSnapshot(t *testing.T) {
	ch := make(chan bool)
	time.AfterFunc(time.Second*40, func() {
		ch <- true
		t.Fatal("snapshot callback was not triggered")
	})
	snap := NewSnapshotter(&config.Config{InitHandleSnapshot: true}, func(total, known uint64) {
		ch <- true
	})
	require.NotNil(t, snap)
	<-ch
}

func TestFindHandles(t *testing.T) {
	snap := NewSnapshotter(&config.Config{InitHandleSnapshot: true, EnumerateHandles: true}, nil)
	handles, err := snap.FindHandles(uint32(os.Getppid()))
	require.NoError(t, err)
	require.NotEmpty(t, handles)

	var hasProcessHandle bool
	for _, h := range handles {
		if h.Type == "Process" {
			hasProcessHandle = true
		}
	}

	require.True(t, hasProcessHandle)
}

```

`pkg/handle/timeout.go`:

```go
//go:build windows
// +build windows

/*
 * Copyright 2019-2020 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package handle

import (
	"errors"
	"expvar"
	"fmt"
	"github.com/rabbitstack/fibratus/pkg/sys"
	"golang.org/x/sys/windows"
)

type timeout struct {
	ini    windows.Handle
	done   windows.Handle
	thread windows.Handle
	in     chan windows.Handle
	out    chan string
}

var tmt timeout

var (
	waitTimeoutCounts = expvar.NewInt("handle.wait.timeouts")
)

func init() {
	tmt.ini, _ = windows.CreateEvent(nil, 0, 0, nil)
	tmt.done, _ = windows.CreateEvent(nil, 0, 0, nil)
	tmt.in = make(chan windows.Handle, 1)
	tmt.out = make(chan string, 1)
}

// GetHandleWithTimeout is in charge of resolving handle names on handle instances that are under the risk
// of producing a deadlock, and thus hanging the caller thread. To prevent this kind of unwanted scenarios,
// deadlock aware timeout calls into `NtQueryObject` in a separate native thread. The thread is blocked waiting
// to be signaled by an event, but the query thread also signals back the main thread after completion of the
// `NtQueryObject` call.
// If the query thread doesn't notify the main thread after a prudent timeout, then the query thread is killed.
// Subsequent calls for handle name resolution will recreate the thread in case of it not being alive.
func GetHandleWithTimeout(handle windows.Handle, timeout uint32) (string, error) {
	if tmt.thread == 0 {
		if err := windows.ResetEvent(tmt.ini); err != nil {
			return "", fmt.Errorf("couldn't reset init event: %v", err)
		}
		if err := windows.ResetEvent(tmt.done); err != nil {
			return "", fmt.Errorf("couldn't reset done event: %v", err)
		}
		tmt.in = make(chan windows.Handle, 1)
		tmt.out = make(chan string, 1)
		tmt.thread = sys.CreateThread(
			nil,
			0,
			windows.NewCallback(timeoutFn),
			0,
			0,
			nil)
		if tmt.thread == 0 {
			return "", fmt.Errorf("cannot create handle query thread: %v", windows.GetLastError())
		}
	}

	tmt.in <- handle
	if err := windows.SetEvent(tmt.ini); err != nil {
		return "", err
	}

	evt, err := windows.WaitForSingleObject(tmt.done, timeout)
	if err != nil || evt == windows.WAIT_FAILED {
		// consume pushed handle
		<-tmt.in
		return "", nil
	}
	if evt == windows.WAIT_OBJECT_0 {
		return <-tmt.out, nil
	}
	if windows.Errno(evt) == windows.WAIT_TIMEOUT {
		waitTimeoutCounts.Add(1)
		// kill the thread and wait for its termination to orderly cleanup resources
		if err := sys.TerminateThread(tmt.thread, 0); err != nil {
			return "", fmt.Errorf("unable tmt terminate timeout thread: %v", err)
		}
		if _, err := windows.WaitForSingleObject(tmt.thread, timeout); err != nil {
			tmt.thread = 0
			return "", fmt.Errorf("failed awaiting timeout thread termination: %v", err)
		}
		_ = windows.CloseHandle(tmt.thread)
		tmt.thread = 0
		return "", errors.New("couldn't resolve handle name due to timeout")
	}
	return "", nil
}

// CloseTimeout releases event and thread handles.
func CloseTimeout() error {
	_ = windows.CloseHandle(tmt.ini)
	_ = windows.CloseHandle(tmt.done)
	if tmt.thread != 0 {
		return sys.TerminateThread(tmt.thread, 0)
	}
	return nil
}

// timeoutFn waits for the initial event signalization and then
// pulls the handle identifier from the input channel. With handle
// identifier inside the callback function, the object is queried.
// If the query is successful, the result is pushed to the output
// channel, and the done event is signaled to indicate the object
// name can be retrieved.
func timeoutFn(ctx uintptr) uintptr {
	for {
		s, err := windows.WaitForSingleObject(tmt.ini, windows.INFINITE)
		if err != nil || s != windows.WAIT_OBJECT_0 {
			break
		}
		obj, err := QueryObjectName(<-tmt.in)
		tmt.out <- obj
		if err != nil {
			if err := windows.SetEvent(tmt.done); err != nil {
				break
			}
			continue
		}
		if err := windows.SetEvent(tmt.done); err != nil {
			break
		}
	}
	return 0
}

```

`pkg/handle/timeout_test.go`:

```go
//go:build windows
// +build windows

/*
 * Copyright 2019-2020 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package handle

import (
	"github.com/stretchr/testify/require"
	"golang.org/x/sys/windows"
	"testing"
)

func TestTimeout(t *testing.T) {
	pipe, err := createPipe(`\\.\pipe\fibratus-timeout`, true)
	require.NoError(t, err)
	objectName, err := GetHandleWithTimeout(windows.Handle(pipe), 150)
	require.NoError(t, err)
	require.Equal(t, "\\Device\\NamedPipe\\fibratus-timeout", objectName)
}

```

`pkg/handle/types.go`:

```go
//go:build windows
// +build windows

/*
 * Copyright 2019-2020 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package handle

const (
	// ALPCPort represents the ALPC (Advanced Local Procedure Call) object ports
	ALPCPort = "ALPC Port"
	// Directory designates directory objects. They exist only within the object manager scope and do not correspond to any directory on the disk.
	Directory = "Directory"
	// EtwRegistration represents the ETW registration object
	EtwRegistration = "EtwRegistration"
	// EtwConsumer represents the ETW consumer object
	EtwConsumer = "EtwConsumer"
	// Event denotest the event object
	Event = "Event"
	// File designates file handles (e.g. pipe, device, mailslot)
	File = "File"
	// Key represents the registry key object
	Key = "Key"
	// Job represents the job object
	Job = "Job"
	// WaitCompletionPacket is the wait completion packet object
	WaitCompletionPacket = "WaitCompletionPacket"
	// IRTimer is the IR timer object
	IRTimer = "IRTimer"
	// TpWorkerFactory represents the thread pool worker factory object
	TpWorkerFactory = "TpWorkerFactory"
	// IoCompletion represents the IO completion object
	IoCompletion = "IoCompletion"
	// Thread is the thread object
	Thread = "Thread"
	// Semaphore represents the semaphore object
	Semaphore = "Semaphore"
	// Section represents the section object
	Section = "Section"
	// Mutant represents the mutant object
	Mutant = "Mutant"
	// Desktop represents the desktop object
	Desktop = "Desktop"
	// WindowStation represents the window station object
	WindowStation = "WindowStation"
	// Token represents the token object
	Token = "Token"
	// UserApcReserve represents the user APC reserve object
	UserApcReserve = "UserApcReserve"
	// Process represents the process object
	Process = "Process"
	// SymbolicLink represents the symbolic link object
	SymbolicLink = "SymbolicLink"
	// Driver represents the device driver object
	Driver = "Driver"
	// Unknown is the unknown handle object
	Unknown = "Unknown"
)

// GetShortName returns the short name for the handle type.
func GetShortName(typ string) string {
	switch typ {
	case ALPCPort:
		return "alpc"
	case Directory:
		return "d"
	case EtwRegistration:
		return "etwr"
	case Event:
		return "e"
	case File:
		return "f"
	case Process:
		return "ps"
	case Section:
		return "sec"
	case Semaphore:
		return "sem"
	case Driver:
		return "drv"
	default:
		return Unknown
	}
}

```

`pkg/handle/types/marshaller.go`:

```go
//go:build windows
// +build windows

/*
 * Copyright 2019-2020 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package types

import (
	"fmt"
	"github.com/rabbitstack/fibratus/pkg/util/bytes"
	"golang.org/x/sys/windows"
	"unsafe"
)

// md is the type alias for the metadata type
type md uint8

const (
	alpcport md = iota + 1
	mutant
	file
	unknown
	none
)

// Offset returns the next offset from which to read the binary data.
func (h Handle) Offset() uint16 {
	offset := 8 + 8 + 4 + 2 + uint16(len(h.Type)) + 2 + uint16(len(h.Name)) + 1
	if h.MD != nil {
		switch h.MD.(type) {
		case *AlpcPortInfo:
			offset += 16
		case *MutantInfo:
			offset += 5
		case *FileInfo:
			offset++
		}
	}
	return offset
}

// Marshal dumps the state of the handle to byte slice that is suitable for serializing to cap file.
func (h *Handle) Marshal() []byte {
	b := make([]byte, 0)

	// write handle id, object address and the pid that owns this handle
	b = append(b, bytes.WriteUint64(uint64(h.Num))...)
	b = append(b, bytes.WriteUint64(h.Object)...)
	b = append(b, bytes.WriteUint32(h.Pid)...)

	// write handle type and name
	b = append(b, bytes.WriteUint16(uint16(len(h.Type)))...)
	b = append(b, h.Type...)

	b = append(b, bytes.WriteUint16(uint16(len(h.Name)))...)
	b = append(b, h.Name...)

	// write handle metadata
	if h.MD != nil {
		switch meta := h.MD.(type) {
		case *AlpcPortInfo:
			b = append(b, byte(alpcport))
			b = append(b, bytes.WriteUint32(meta.Flags)...)
			b = append(b, bytes.WriteUint32(meta.Seqno)...)
			b = append(b, bytes.WriteUint64(uint64(meta.Context))...)
		case *MutantInfo:
			b = append(b, byte(mutant))
			b = append(b, bytes.WriteUint32(uint32(meta.Count))...)
			if meta.IsAbandoned {
				b = append(b, 1)
			} else {
				b = append(b, 0)
			}
		case *FileInfo:
			b = append(b, byte(file))
			if meta.IsDirectory {
				b = append(b, 1)
			} else {
				b = append(b, 0)
			}
		default:
			b = append(b, byte(unknown))
		}
	} else {
		b = append(b, byte(none))
	}

	return b
}

// Unmarshal transforms the byte slice back to handle structure.
func (h *Handle) Unmarshal(b []byte) error {
	if len(b) < 20 {
		return fmt.Errorf("expected at least 20 bytes but got %d bytes", len(b))
	}

	// read handle identifier
	h.Num = windows.Handle(bytes.ReadUint64(b[0:]))
	// read object address
	h.Object = bytes.ReadUint64(b[8:])
	// read pid
	h.Pid = bytes.ReadUint32(b[16:])

	// read handle type and name
	l := bytes.ReadUint16(b[20:])
	buf := b[22:]
	offset := l
	if len(buf) > 0 {
		h.Type = string((*[1<<30 - 1]byte)(unsafe.Pointer(&buf[0]))[:l:l])
	}

	l = bytes.ReadUint16(b[22+offset:])
	buf = b[24+offset:]
	offset += l
	if len(buf) > 0 {
		h.Name = string((*[1<<30 - 1]byte)(unsafe.Pointer(&buf[0]))[:l:l])
	}

	typ := md(b[24+offset])
	if typ == none {
		return nil
	}

	switch typ {
	case alpcport:
		alpcPort := &AlpcPortInfo{
			Flags:   bytes.ReadUint32(b[25+offset:]),
			Seqno:   bytes.ReadUint32(b[29+offset:]),
			Context: uintptr(bytes.ReadUint64(b[33+offset:])),
		}
		h.MD = alpcPort
	case mutant:
		mut := &MutantInfo{
			Count:       int32(bytes.ReadUint32(b[25+offset:])),
			IsAbandoned: utob(b[29+offset]),
		}
		h.MD = mut
	case file:
		f := &FileInfo{
			IsDirectory: utob(b[25+offset]),
		}
		h.MD = f
	}

	return nil
}

func utob(u uint8) bool { return u > 0 }

```

`pkg/handle/types/marshaller_test.go`:

```go
//go:build windows
// +build windows

/*
 * Copyright 2019-2020 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package types

import (
	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/require"
	"golang.org/x/sys/windows"
	"testing"
)

func TestMarshaller(t *testing.T) {
	h := Handle{
		Num:    windows.Handle(0xffffd105e9baaf70),
		Name:   `\REGISTRY\MACHINE\SYSTEM\ControlSet001\Services\Tcpip\Parameters\Interfaces\{b677c565-6ca5-45d3-b618-736b4e09b036}`,
		Type:   "Key",
		Object: 777488883434455544,
		Pid:    uint32(1023),
	}
	buf := h.Marshal()

	clone := Handle{}
	err := clone.Unmarshal(buf)
	require.NoError(t, err)

	assert.Equal(t, windows.Handle(18446692422059208560), clone.Num)
	assert.Equal(t, "Key", clone.Type)
	assert.Equal(t, `\REGISTRY\MACHINE\SYSTEM\ControlSet001\Services\Tcpip\Parameters\Interfaces\{b677c565-6ca5-45d3-b618-736b4e09b036}`, clone.Name)
	assert.Equal(t, uint32(1023), clone.Pid)
	assert.Equal(t, uint64(777488883434455544), clone.Object)

	h = Handle{
		Num:  windows.Handle(0xefffd105e9adaf70),
		Name: `\RPC Control\OLEA61B27E13E028C4EA6C286932E80`,
		Type: "ALPC Port",
		Pid:  uint32(1023),
		MD: &AlpcPortInfo{
			Seqno:   1,
			Context: 0x0,
			Flags:   0x0,
		},
	}
	buf = h.Marshal()

	err = clone.Unmarshal(buf)
	require.NoError(t, err)

	assert.Equal(t, windows.Handle(0xefffd105e9adaf70), clone.Num)
	assert.Equal(t, "ALPC Port", clone.Type)
	assert.Equal(t, `\RPC Control\OLEA61B27E13E028C4EA6C286932E80`, clone.Name)
	assert.Equal(t, uint32(1023), clone.Pid)
	assert.NotNil(t, clone.MD)
	assert.IsType(t, &AlpcPortInfo{}, clone.MD)
	alpcPortInfo := clone.MD.(*AlpcPortInfo)
	assert.Equal(t, uint32(1), alpcPortInfo.Seqno)
}

```

`pkg/handle/types/types.go`:

```go
//go:build windows
// +build windows

/*
 * Copyright 2019-2020 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package types

import (
	"expvar"
	"fmt"
	"github.com/rabbitstack/fibratus/pkg/sys"
	log "github.com/sirupsen/logrus"
	"golang.org/x/sys/windows"
	"strings"
)

// Meta represents the type alias for handle meta information
type Meta interface{}

// Handles represents a collection of handles.
type Handles []Handle

// typeNames maps the object type id to its name
var typeNames = map[uint16]string{}

var (
	// typesCount counts the number of resolved object type names
	typesCount = expvar.NewInt("handle.types.count")
	// typeMisses counts the number of times type name resolution failed
	typeMisses = expvar.NewInt("handle.types.name.misses")
)

func init() {
	findObjectTypes()
}

// Handle stores various metadata specific to the handle allocated by a process.
type Handle struct {
	// Num represents the internal handle identifier.
	Num windows.Handle `json:"id"`
	// Object is the kernel address that this handle references.
	Object uint64 `json:"-"`
	// Pid represents the process's identifier that owns the handle.
	Pid uint32 `json:"-"`
	// Type is the type of this handle (e.g. File, Key, Mutant, Section)
	Type string `json:"type"`
	// Name is the actual value of the handle (e.g. \Device\HarddiskVolume4\Windows\Temp\DPTF)
	Name string `json:"name"`
	// MD is the handle meta information (e.g. ALPC port info)
	MD Meta `json:"meta,omitempty"`
}

// String returns a string representation of the handle.
func (h Handle) String() string {
	return fmt.Sprintf("Num: %d Type: %s, Name: %s, Object: 0x%x, PID: %d", h.Num, h.Type, h.Name, h.Object, h.Pid)
}

// Len returns the length in bytes of the Handle structure.
func (h Handle) Len() int {
	l := 8 + 8 + 4 + len(h.Type) + len(h.Name)
	if h.MD != nil {
		switch h.MD.(type) {
		case *AlpcPortInfo:
			l += 16
		case *MutantInfo:
			l += 5
		case *FileInfo:
			l++
		}
	}
	return l
}

// NewFromCapture restores handle state from the capture buffer.
func NewFromCapture(buf []byte) (Handle, error) {
	h := Handle{}
	err := h.Unmarshal(buf)
	if err != nil {
		return Handle{}, err
	}
	return h, nil
}

// AlpcPortInfo stores ALPC port basic information.
type AlpcPortInfo struct {
	Flags   uint32
	Seqno   uint32
	Context uintptr
}

// MutantInfo stores metadata about particular mutant object.
type MutantInfo struct {
	Count       int32
	_           bool //unused
	IsAbandoned bool
}

// FileInfo contains file handle metadata.
type FileInfo struct {
	IsDirectory bool
}

// String returns the string representation of all handles.
func (handles Handles) String() string {
	var sb strings.Builder
	for _, h := range handles {
		sb.WriteString(h.String() + " | ")
	}
	return strings.TrimSuffix(sb.String(), " | ")
}

// ConvertTypeIDToName converts the object type identifier to its symbolical name.
func ConvertTypeIDToName(id uint16) string {
	typ, ok := typeNames[id]
	if ok {
		return typ
	}
	typeMisses.Add(1)
	return ""
}

func findObjectTypes() {
	objectTypes, err := sys.QueryObject[sys.ObjectTypesInformation](0, sys.ObjectTypesInformationClass)
	if err != nil {
		log.Warnf("unable to query object types: %v", err)
		return
	}
	typesCount.Add(int64(objectTypes.NumberOfTypes))
	objectTypeInfo := objectTypes.First()
	for i := 0; i < int(objectTypes.NumberOfTypes); i++ {
		objectTypeInfo = objectTypes.Next(objectTypeInfo)
		typeNames[uint16(objectTypeInfo.TypeIndex)] = objectTypeInfo.TypeName.String()
	}
}

```

`pkg/handle/types/types_test.go`:

```go
/*
 * Copyright 2021-2022 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package types

import (
	"github.com/stretchr/testify/require"
	"testing"
)

func TestHandleTypes(t *testing.T) {
	names := make([]string, 0)
	dirIdx := uint16(0)
	for i, n := range typeNames {
		names = append(names, n)
		if n == "Directory" {
			dirIdx = i
		}
	}
	require.Contains(t, names, "Directory", "File", "Driver")
	require.Equal(t, "Directory", ConvertTypeIDToName(dirIdx))
}

```

`pkg/network/address.go`:

```go
/*
 * Copyright 2020-2021 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package network

import "net"

// Address is the comparable type-alias for the IP v4/v6 addresses
type Address [16]byte

// ToIP converts the address to net.IP type.
func (addr Address) ToIP() net.IP {
	return net.IP(addr[:])
}

// ToIPString converts the address to IP string representation.
func (addr Address) ToIPString() string {
	return addr.ToIP().String()
}

// AddressFromIP constructs the address from the IP address.
func AddressFromIP(ip net.IP) Address {
	var addr Address
	copy(addr[:], ip)
	return addr
}

```

`pkg/network/dns.go`:

```go
/*
 * Copyright 2020-2021 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package network

import (
	"context"
	"errors"
	"expvar"
	"net"
	"sync"
	"time"
)

// ErrMaxNamesReached is thrown when the capacity of the names map is reached
var ErrMaxNamesReached = errors.New("dns reverse max names reached")

var (
	totalDNSLookups     = expvar.NewInt("dns.reverse.total.lookups")
	failedDNSLookups    = expvar.NewMap("dns.reverse.failed.lookups")
	expiredDNSNames     = expvar.NewInt("dns.reverse.expired.names")
	totalDNSNames       = expvar.NewInt("dns.reverse.total.names")
	cacheFullDNSLookups = expvar.NewInt("dns.reverse.cache.full.lookups")
)

// maxFailedDNSLookups designates the maximum number of failed DNS lookups
// after which the IP address is blacklisted
const maxFailedDNSLookups = 10

// ReverseDNS performs reverse DNS resolutions and keeps the cache of
// resolved IP to domain mappings.
type ReverseDNS struct {
	mux sync.Mutex
	// ttl specifies the time to live for each cache entry
	ttl time.Duration
	// size determines the maximum size of the domains cache
	size int

	domains map[Address]*dnsNames

	// blacklist contains the IP addresses that fail
	// to resolve after a number of attempts. We want to defend
	// ourselves from excessive reverse DNS lookup calls
	blacklist map[Address]int
	close     chan struct{}
}

type dnsNames struct {
	names      []string
	expiration int64
}

var r *ReverseDNS

// GetReverseDNS creates a new singleton instance of DNS reverser with the specified size and TTL period.
func GetReverseDNS(size int, ttl, exp time.Duration) *ReverseDNS {
	if r != nil {
		return r
	}

	r = &ReverseDNS{
		domains:   make(map[Address]*dnsNames),
		blacklist: make(map[Address]int),
		size:      size,
		ttl:       ttl,
		close:     make(chan struct{}, 1),
	}

	tick := time.NewTicker(exp)
	go func() {
		for {
			select {
			case <-tick.C:
				r.Expire()
			case <-r.close:
				tick.Stop()
				return
			}
		}
	}()

	return r
}

// Add performs a reverse lookup for the given address, returning a list
// of names mapping to that address. It assigns a ttl to the names value
// and puts it in the map. If the names map capacity is reached this method
// returns an error and gives up on adding new entries.
func (r *ReverseDNS) Add(addr Address) ([]string, error) {
	r.mux.Lock()
	defer r.mux.Unlock()

	if len(r.domains) > r.size {
		cacheFullDNSLookups.Add(1)
		return nil, ErrMaxNamesReached
	}

	if r.blacklist[addr] > maxFailedDNSLookups {
		return nil, nil
	}

	if names, ok := r.domains[addr]; ok {
		return names.names, nil
	}

	now := time.Now()
	exp := now.Add(r.ttl).UnixNano()
	ctx, cancel := context.WithTimeout(context.Background(), time.Second*10)
	defer cancel()
	names, err := net.DefaultResolver.LookupAddr(ctx, addr.ToIPString())
	if err != nil {
		r.blacklist[addr]++
		failedDNSLookups.Add(addr.ToIPString(), 1)
		return nil, err
	}

	totalDNSLookups.Add(1)
	totalDNSNames.Add(1)

	r.domains[addr] = &dnsNames{names: names, expiration: exp}

	return names, nil
}

// Get returns all the name mappings for the specified address.
func (r *ReverseDNS) Get(addr Address) []string {
	r.mux.Lock()
	defer r.mux.Unlock()

	names, ok := r.domains[addr]
	if !ok {
		return nil
	}

	return names.names
}

// Expire evicts name values that are eligible for expiration.
func (r *ReverseDNS) Expire() {
	deadline := time.Now().UnixNano()
	expired := int64(0)
	r.mux.Lock()

	for addr, val := range r.domains {
		if val.expiration > deadline {
			continue
		}
		expired++
		delete(r.domains, addr)
	}
	r.mux.Unlock()

	expiredDNSNames.Add(expired)
	totalDNSNames.Add(-expired)
}

// Len returns the size of the names map.
func (r *ReverseDNS) Len() int {
	r.mux.Lock()
	defer r.mux.Unlock()
	return len(r.domains)
}

// Close closes the expiration ticker.
func (r *ReverseDNS) Close() {
	r.close <- struct{}{}
}

```

`pkg/network/dns_test.go`:

```go
/*
 * Copyright 2020-2021 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package network

import (
	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/require"
	"net"
	"testing"
	"time"
)

func TestLookupAddr(t *testing.T) {
	reverseDNS := GetReverseDNS(100, time.Minute, time.Minute)
	names, err := reverseDNS.Add(AddressFromIP(net.ParseIP("8.8.8.8")))

	require.NoError(t, err)
	assert.Contains(t, names, "dns.google.")
	assert.Equal(t, reverseDNS.Len(), 1)

	names, err = reverseDNS.Add(AddressFromIP(net.ParseIP("8.8.8.8")))
	require.NoError(t, err)
	assert.Contains(t, names, "dns.google.")
}

func TestLookupAddrBlacklisted(t *testing.T) {
	reverseDNS := GetReverseDNS(100, time.Minute, time.Minute)
	for i := 0; i < maxFailedDNSLookups+1; i++ {
		_, err := reverseDNS.Add(AddressFromIP(net.ParseIP("1.2.3.1")))
		require.Error(t, err)
	}
	_, err := reverseDNS.Add(AddressFromIP(net.ParseIP("1.2.3.1")))
	require.NoError(t, err)
}

func TestLookupAddrExpiration(t *testing.T) {
	r = nil // request a fresh reverse DNS

	reverseDNS := GetReverseDNS(100, time.Millisecond*5, time.Minute)

	names, err := reverseDNS.Add(AddressFromIP(net.ParseIP("8.8.8.8")))

	require.NoError(t, err)
	assert.Contains(t, names, "dns.google.")
	assert.Equal(t, reverseDNS.Len(), 1)

	time.Sleep(time.Millisecond * 10)
	reverseDNS.Expire()
	assert.Equal(t, reverseDNS.Len(), 0)

	names, err = reverseDNS.Add(AddressFromIP(net.ParseIP("8.8.8.8")))
	require.NoError(t, err)
	assert.Contains(t, names, "dns.google.")
}

func TestLookupAddrTickerExpiration(t *testing.T) {
	r = nil // request a fresh reverse DNS

	reverseDNS := GetReverseDNS(100, time.Millisecond*50, time.Millisecond*80)

	names, err := reverseDNS.Add(AddressFromIP(net.ParseIP("8.8.8.8")))
	require.NoError(t, err)
	assert.Contains(t, names, "dns.google.")
	assert.True(t, reverseDNS.Len() == 1)

	time.Sleep(time.Millisecond * 125)

	assert.Empty(t, reverseDNS.Get(AddressFromIP(net.ParseIP("8.8.8.8"))))
	assert.True(t, reverseDNS.Len() == 0)
}

```

`pkg/network/types.go`:

```go
/*
 * Copyright 2019-2020 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package network

// L4Proto is the type alias for the Layer 4 protocol.
type L4Proto uint8

const (
	// TCP identifies TCP Layer 4 protocol.
	TCP L4Proto = iota + 1
	// UDP identifies UDP Layer 4 protocol.
	UDP
)

// ProtoNames maps protocol identifiers to protocol names
var ProtoNames = map[uint32]string{
	uint32(TCP): "TCP",
	uint32(UDP): "UDP",
}

// String returns the string representation of the Layer 4 protocol.
func (proto L4Proto) String() string {
	switch proto {
	case TCP:
		return "tcp"
	case UDP:
		return "udp"
	default:
		return "unknown"
	}
}

```

`pkg/outputs/amqp/_fixtures/garagemq/README.md`:

```md
This is the minimal [GarageMQ](https://github.com/valinurovam/garagemq) server merely used for testing the AMQP output.
```

`pkg/outputs/amqp/_fixtures/garagemq/amqp/constants_generated.go`:

```go
// Package amqp for read, write, parse amqp frames
// Autogenerated code. Do not edit.
package amqp

// FrameMethod identifier
const FrameMethod = 1

// FrameHeader identifier
const FrameHeader = 2

// FrameBody identifier
const FrameBody = 3

// FrameHeartbeat identifier
const FrameHeartbeat = 8

// FrameMinSize identifier
const FrameMinSize = 4096

// FrameEnd identifier
const FrameEnd = 206

// ReplySuccess identifier Indicates that the method completed successfully. This reply code is
// reserved for future use - the current protocol design does not use positive
// confirmation and reply codes are sent only in case of an error.
const ReplySuccess = 200

// ContentTooLarge identifier The client attempted to transfer content larger than the server could accept
// at the present time. The client may retry at a later time.
const ContentTooLarge = 311

// NoConsumers identifier When the exchange cannot deliver to a consumer when the immediate flag is
// set. As a result of pending data on the queue or the absence of any
// consumers of the queue.
const NoConsumers = 313

// ConnectionForced identifier An operator intervened to close the connection for some reason. The client
// may retry at some later date.
const ConnectionForced = 320

// InvalidPath identifier The client tried to work with an unknown virtual host.
const InvalidPath = 402

// AccessRefused identifier The client attempted to work with a server entity to which it has no
// access due to security settings.
const AccessRefused = 403

// NotFound identifier The client attempted to work with a server entity that does not exist.
const NotFound = 404

// ResourceLocked identifier The client attempted to work with a server entity to which it has no
// access because another client is working with it.
const ResourceLocked = 405

// PreconditionFailed identifier The client requested a method that was not allowed because some precondition
// failed.
const PreconditionFailed = 406

// FrameError identifier The sender sent a malformed frame that the recipient could not decode.
// This strongly implies a programming error in the sending peer.
const FrameError = 501

// SyntaxError identifier The sender sent a frame that contained illegal values for one or more
// fields. This strongly implies a programming error in the sending peer.
const SyntaxError = 502

// CommandInvalid identifier The client sent an invalid sequence of frames, attempting to perform an
// operation that was considered invalid by the server. This usually implies
// a programming error in the client.
const CommandInvalid = 503

// ChannelError identifier The client attempted to work with a channel that had not been correctly
// opened. This most likely indicates a fault in the client layer.
const ChannelError = 504

// UnexpectedFrame identifier The peer sent a frame that was not expected, usually in the context of
// a content header and body.  This strongly indicates a fault in the peer's
// content processing.
const UnexpectedFrame = 505

// ResourceError identifier The server could not complete the method because it lacked sufficient
// resources. This may be due to the client creating too many of some type
// of entity.
const ResourceError = 506

// NotAllowed identifier The client tried to work with some entity in a manner that is prohibited
// by the server, due to security settings or by some other criteria.
const NotAllowed = 530

// NotImplemented identifier The client tried to use functionality that is not implemented in the
// server.
const NotImplemented = 540

// InternalError identifier The server could not complete the method because of an internal error.
// The server may require intervention by an operator in order to resume
// normal operations.
const InternalError = 541

// ClassConnection identifier
const ClassConnection = 10

// MethodConnectionStart identifier
const MethodConnectionStart = 10

// MethodConnectionStartOk identifier
const MethodConnectionStartOk = 11

// MethodConnectionSecure identifier
const MethodConnectionSecure = 20

// MethodConnectionSecureOk identifier
const MethodConnectionSecureOk = 21

// MethodConnectionTune identifier
const MethodConnectionTune = 30

// MethodConnectionTuneOk identifier
const MethodConnectionTuneOk = 31

// MethodConnectionOpen identifier
const MethodConnectionOpen = 40

// MethodConnectionOpenOk identifier
const MethodConnectionOpenOk = 41

// MethodConnectionClose identifier
const MethodConnectionClose = 50

// MethodConnectionCloseOk identifier
const MethodConnectionCloseOk = 51

// MethodConnectionBlocked identifier
const MethodConnectionBlocked = 60

// MethodConnectionUnblocked identifier
const MethodConnectionUnblocked = 61

// ClassChannel identifier
const ClassChannel = 20

// MethodChannelOpen identifier
const MethodChannelOpen = 10

// MethodChannelOpenOk identifier
const MethodChannelOpenOk = 11

// MethodChannelFlow identifier
const MethodChannelFlow = 20

// MethodChannelFlowOk identifier
const MethodChannelFlowOk = 21

// MethodChannelClose identifier
const MethodChannelClose = 40

// MethodChannelCloseOk identifier
const MethodChannelCloseOk = 41

// ClassExchange identifier
const ClassExchange = 40

// MethodExchangeDeclare identifier
const MethodExchangeDeclare = 10

// MethodExchangeDeclareOk identifier
const MethodExchangeDeclareOk = 11

// MethodExchangeDelete identifier
const MethodExchangeDelete = 20

// MethodExchangeDeleteOk identifier
const MethodExchangeDeleteOk = 21

// MethodExchangeBind identifier
const MethodExchangeBind = 30

// MethodExchangeBindOk identifier
const MethodExchangeBindOk = 31

// MethodExchangeUnbind identifier
const MethodExchangeUnbind = 40

// MethodExchangeUnbindOk identifier
const MethodExchangeUnbindOk = 51

// ClassQueue identifier
const ClassQueue = 50

// MethodQueueDeclare identifier
const MethodQueueDeclare = 10

// MethodQueueDeclareOk identifier
const MethodQueueDeclareOk = 11

// MethodQueueBind identifier
const MethodQueueBind = 20

// MethodQueueBindOk identifier
const MethodQueueBindOk = 21

// MethodQueueUnbind identifier
const MethodQueueUnbind = 50

// MethodQueueUnbindOk identifier
const MethodQueueUnbindOk = 51

// MethodQueuePurge identifier
const MethodQueuePurge = 30

// MethodQueuePurgeOk identifier
const MethodQueuePurgeOk = 31

// MethodQueueDelete identifier
const MethodQueueDelete = 40

// MethodQueueDeleteOk identifier
const MethodQueueDeleteOk = 41

// ClassBasic identifier
const ClassBasic = 60

// MethodBasicQos identifier
const MethodBasicQos = 10

// MethodBasicQosOk identifier
const MethodBasicQosOk = 11

// MethodBasicConsume identifier
const MethodBasicConsume = 20

// MethodBasicConsumeOk identifier
const MethodBasicConsumeOk = 21

// MethodBasicCancel identifier
const MethodBasicCancel = 30

// MethodBasicCancelOk identifier
const MethodBasicCancelOk = 31

// MethodBasicPublish identifier
const MethodBasicPublish = 40

// MethodBasicReturn identifier
const MethodBasicReturn = 50

// MethodBasicDeliver identifier
const MethodBasicDeliver = 60

// MethodBasicGet identifier
const MethodBasicGet = 70

// MethodBasicGetOk identifier
const MethodBasicGetOk = 71

// MethodBasicGetEmpty identifier
const MethodBasicGetEmpty = 72

// MethodBasicAck identifier
const MethodBasicAck = 80

// MethodBasicReject identifier
const MethodBasicReject = 90

// MethodBasicRecoverAsync identifier
const MethodBasicRecoverAsync = 100

// MethodBasicRecover identifier
const MethodBasicRecover = 110

// MethodBasicRecoverOk identifier
const MethodBasicRecoverOk = 111

// MethodBasicNack identifier
const MethodBasicNack = 120

// ClassTx identifier
const ClassTx = 90

// MethodTxSelect identifier
const MethodTxSelect = 10

// MethodTxSelectOk identifier
const MethodTxSelectOk = 11

// MethodTxCommit identifier
const MethodTxCommit = 20

// MethodTxCommitOk identifier
const MethodTxCommitOk = 21

// MethodTxRollback identifier
const MethodTxRollback = 30

// MethodTxRollbackOk identifier
const MethodTxRollbackOk = 31

// ClassConfirm identifier
const ClassConfirm = 85

// MethodConfirmSelect identifier
const MethodConfirmSelect = 10

// MethodConfirmSelectOk identifier
const MethodConfirmSelectOk = 11

// ConstantsNameMap map for mapping error codes into error messages
var ConstantsNameMap = map[uint16]string{

	1: "FRAME_METHOD",

	2: "FRAME_HEADER",

	3: "FRAME_BODY",

	8: "FRAME_HEARTBEAT",

	4096: "FRAME_MIN_SIZE",

	206: "FRAME_END",

	200: "REPLY_SUCCESS",

	311: "CONTENT_TOO_LARGE",

	313: "NO_CONSUMERS",

	320: "CONNECTION_FORCED",

	402: "INVALID_PATH",

	403: "ACCESS_REFUSED",

	404: "NOT_FOUND",

	405: "RESOURCE_LOCKED",

	406: "PRECONDITION_FAILED",

	501: "FRAME_ERROR",

	502: "SYNTAX_ERROR",

	503: "COMMAND_INVALID",

	504: "CHANNEL_ERROR",

	505: "UNEXPECTED_FRAME",

	506: "RESOURCE_ERROR",

	530: "NOT_ALLOWED",

	540: "NOT_IMPLEMENTED",

	541: "INTERNAL_ERROR",
}

```

`pkg/outputs/amqp/_fixtures/garagemq/amqp/extended_constants.go`:

```go
package amqp

// NoRoute returns when a 'mandatory' message cannot be delivered to any queue.
// @see https://www.rabbitmq.com/amqp-0-9-1-errata.html#section_17
const NoRoute = 312

```

`pkg/outputs/amqp/_fixtures/garagemq/amqp/methods_generated.go`:

```go
// Package amqp for read, write, parse amqp frames
// Autogenerated code. Do not edit.
package amqp

import (
	"fmt"
	"io"
	"time"
)

// Method represents base method interface
type Method interface {
	Name() string
	FrameType() byte
	ClassIdentifier() uint16
	MethodIdentifier() uint16
	Read(reader io.Reader, protoVersion string) (err error)
	Write(writer io.Writer, protoVersion string) (err error)
	Sync() bool
}

// Connection methods

// ConnectionStart This method starts the connection negotiation process by telling the client the
// protocol version that the server proposes, along with a list of security mechanisms
// which the client can use for authentication.
type ConnectionStart struct {
	VersionMajor     byte
	VersionMinor     byte
	ServerProperties *Table
	Mechanisms       []byte
	Locales          []byte
}

// Name returns method name as string, usefully for logging
func (method *ConnectionStart) Name() string {
	return "ConnectionStart"
}

// FrameType returns method frame type
func (method *ConnectionStart) FrameType() byte {
	return 1
}

// ClassIdentifier returns method classID
func (method *ConnectionStart) ClassIdentifier() uint16 {
	return 10
}

// MethodIdentifier returns method methodID
func (method *ConnectionStart) MethodIdentifier() uint16 {
	return 10
}

// Sync is method should me sent synchronous
func (method *ConnectionStart) Sync() bool {
	return true
}

// Read method from io reader
func (method *ConnectionStart) Read(reader io.Reader, protoVersion string) (err error) {

	method.VersionMajor, err = ReadOctet(reader)
	if err != nil {
		return err
	}

	method.VersionMinor, err = ReadOctet(reader)
	if err != nil {
		return err
	}

	method.ServerProperties, err = ReadTable(reader, protoVersion)
	if err != nil {
		return err
	}

	method.Mechanisms, err = ReadLongstr(reader)
	if err != nil {
		return err
	}

	method.Locales, err = ReadLongstr(reader)
	if err != nil {
		return err
	}

	return
}

// Write method from io reader
func (method *ConnectionStart) Write(writer io.Writer, protoVersion string) (err error) {

	if err = WriteOctet(writer, method.VersionMajor); err != nil {
		return err
	}

	if err = WriteOctet(writer, method.VersionMinor); err != nil {
		return err
	}

	if err = WriteTable(writer, method.ServerProperties, protoVersion); err != nil {
		return err
	}

	if err = WriteLongstr(writer, method.Mechanisms); err != nil {
		return err
	}

	if err = WriteLongstr(writer, method.Locales); err != nil {
		return err
	}

	return
}

// ConnectionStartOk This method selects a SASL security mechanism.
type ConnectionStartOk struct {
	ClientProperties *Table
	Mechanism        string
	Response         []byte
	Locale           string
}

// Name returns method name as string, usefully for logging
func (method *ConnectionStartOk) Name() string {
	return "ConnectionStartOk"
}

// FrameType returns method frame type
func (method *ConnectionStartOk) FrameType() byte {
	return 1
}

// ClassIdentifier returns method classID
func (method *ConnectionStartOk) ClassIdentifier() uint16 {
	return 10
}

// MethodIdentifier returns method methodID
func (method *ConnectionStartOk) MethodIdentifier() uint16 {
	return 11
}

// Sync is method should me sent synchronous
func (method *ConnectionStartOk) Sync() bool {
	return true
}

// Read method from io reader
func (method *ConnectionStartOk) Read(reader io.Reader, protoVersion string) (err error) {

	method.ClientProperties, err = ReadTable(reader, protoVersion)
	if err != nil {
		return err
	}

	method.Mechanism, err = ReadShortstr(reader)
	if err != nil {
		return err
	}

	method.Response, err = ReadLongstr(reader)
	if err != nil {
		return err
	}

	method.Locale, err = ReadShortstr(reader)
	if err != nil {
		return err
	}

	return
}

// Write method from io reader
func (method *ConnectionStartOk) Write(writer io.Writer, protoVersion string) (err error) {

	if err = WriteTable(writer, method.ClientProperties, protoVersion); err != nil {
		return err
	}

	if err = WriteShortstr(writer, method.Mechanism); err != nil {
		return err
	}

	if err = WriteLongstr(writer, method.Response); err != nil {
		return err
	}

	if err = WriteShortstr(writer, method.Locale); err != nil {
		return err
	}

	return
}

// ConnectionSecure The SASL protocol works by exchanging challenges and responses until both peers have
// received sufficient information to authenticate each other. This method challenges
// the client to provide more information.
type ConnectionSecure struct {
	Challenge []byte
}

// Name returns method name as string, usefully for logging
func (method *ConnectionSecure) Name() string {
	return "ConnectionSecure"
}

// FrameType returns method frame type
func (method *ConnectionSecure) FrameType() byte {
	return 1
}

// ClassIdentifier returns method classID
func (method *ConnectionSecure) ClassIdentifier() uint16 {
	return 10
}

// MethodIdentifier returns method methodID
func (method *ConnectionSecure) MethodIdentifier() uint16 {
	return 20
}

// Sync is method should me sent synchronous
func (method *ConnectionSecure) Sync() bool {
	return true
}

// Read method from io reader
func (method *ConnectionSecure) Read(reader io.Reader, protoVersion string) (err error) {

	method.Challenge, err = ReadLongstr(reader)
	if err != nil {
		return err
	}

	return
}

// Write method from io reader
func (method *ConnectionSecure) Write(writer io.Writer, protoVersion string) (err error) {

	if err = WriteLongstr(writer, method.Challenge); err != nil {
		return err
	}

	return
}

// ConnectionSecureOk This method attempts to authenticate, passing a block of SASL data for the security
// mechanism at the server side.
type ConnectionSecureOk struct {
	Response []byte
}

// Name returns method name as string, usefully for logging
func (method *ConnectionSecureOk) Name() string {
	return "ConnectionSecureOk"
}

// FrameType returns method frame type
func (method *ConnectionSecureOk) FrameType() byte {
	return 1
}

// ClassIdentifier returns method classID
func (method *ConnectionSecureOk) ClassIdentifier() uint16 {
	return 10
}

// MethodIdentifier returns method methodID
func (method *ConnectionSecureOk) MethodIdentifier() uint16 {
	return 21
}

// Sync is method should me sent synchronous
func (method *ConnectionSecureOk) Sync() bool {
	return true
}

// Read method from io reader
func (method *ConnectionSecureOk) Read(reader io.Reader, protoVersion string) (err error) {

	method.Response, err = ReadLongstr(reader)
	if err != nil {
		return err
	}

	return
}

// Write method from io reader
func (method *ConnectionSecureOk) Write(writer io.Writer, protoVersion string) (err error) {

	if err = WriteLongstr(writer, method.Response); err != nil {
		return err
	}

	return
}

// ConnectionTune This method proposes a set of connection configuration values to the client. The
// client can accept and/or adjust these.
type ConnectionTune struct {
	ChannelMax uint16
	FrameMax   uint32
	Heartbeat  uint16
}

// Name returns method name as string, usefully for logging
func (method *ConnectionTune) Name() string {
	return "ConnectionTune"
}

// FrameType returns method frame type
func (method *ConnectionTune) FrameType() byte {
	return 1
}

// ClassIdentifier returns method classID
func (method *ConnectionTune) ClassIdentifier() uint16 {
	return 10
}

// MethodIdentifier returns method methodID
func (method *ConnectionTune) MethodIdentifier() uint16 {
	return 30
}

// Sync is method should me sent synchronous
func (method *ConnectionTune) Sync() bool {
	return true
}

// Read method from io reader
func (method *ConnectionTune) Read(reader io.Reader, protoVersion string) (err error) {

	method.ChannelMax, err = ReadShort(reader)
	if err != nil {
		return err
	}

	method.FrameMax, err = ReadLong(reader)
	if err != nil {
		return err
	}

	method.Heartbeat, err = ReadShort(reader)
	if err != nil {
		return err
	}

	return
}

// Write method from io reader
func (method *ConnectionTune) Write(writer io.Writer, protoVersion string) (err error) {

	if err = WriteShort(writer, method.ChannelMax); err != nil {
		return err
	}

	if err = WriteLong(writer, method.FrameMax); err != nil {
		return err
	}

	if err = WriteShort(writer, method.Heartbeat); err != nil {
		return err
	}

	return
}

// ConnectionTuneOk This method sends the client's connection tuning parameters to the server.
// Certain fields are negotiated, others provide capability information.
type ConnectionTuneOk struct {
	ChannelMax uint16
	FrameMax   uint32
	Heartbeat  uint16
}

// Name returns method name as string, usefully for logging
func (method *ConnectionTuneOk) Name() string {
	return "ConnectionTuneOk"
}

// FrameType returns method frame type
func (method *ConnectionTuneOk) FrameType() byte {
	return 1
}

// ClassIdentifier returns method classID
func (method *ConnectionTuneOk) ClassIdentifier() uint16 {
	return 10
}

// MethodIdentifier returns method methodID
func (method *ConnectionTuneOk) MethodIdentifier() uint16 {
	return 31
}

// Sync is method should me sent synchronous
func (method *ConnectionTuneOk) Sync() bool {
	return true
}

// Read method from io reader
func (method *ConnectionTuneOk) Read(reader io.Reader, protoVersion string) (err error) {

	method.ChannelMax, err = ReadShort(reader)
	if err != nil {
		return err
	}

	method.FrameMax, err = ReadLong(reader)
	if err != nil {
		return err
	}

	method.Heartbeat, err = ReadShort(reader)
	if err != nil {
		return err
	}

	return
}

// Write method from io reader
func (method *ConnectionTuneOk) Write(writer io.Writer, protoVersion string) (err error) {

	if err = WriteShort(writer, method.ChannelMax); err != nil {
		return err
	}

	if err = WriteLong(writer, method.FrameMax); err != nil {
		return err
	}

	if err = WriteShort(writer, method.Heartbeat); err != nil {
		return err
	}

	return
}

// ConnectionOpen This method opens a connection to a virtual host, which is a collection of
// resources, and acts to separate multiple application domains within a server.
// The server may apply arbitrary limits per virtual host, such as the number
// of each type of entity that may be used, per connection and/or in total.
type ConnectionOpen struct {
	VirtualHost string
	Reserved1   string
	Reserved2   bool
}

// Name returns method name as string, usefully for logging
func (method *ConnectionOpen) Name() string {
	return "ConnectionOpen"
}

// FrameType returns method frame type
func (method *ConnectionOpen) FrameType() byte {
	return 1
}

// ClassIdentifier returns method classID
func (method *ConnectionOpen) ClassIdentifier() uint16 {
	return 10
}

// MethodIdentifier returns method methodID
func (method *ConnectionOpen) MethodIdentifier() uint16 {
	return 40
}

// Sync is method should me sent synchronous
func (method *ConnectionOpen) Sync() bool {
	return true
}

// Read method from io reader
func (method *ConnectionOpen) Read(reader io.Reader, protoVersion string) (err error) {

	method.VirtualHost, err = ReadShortstr(reader)
	if err != nil {
		return err
	}

	method.Reserved1, err = ReadShortstr(reader)
	if err != nil {
		return err
	}

	bits, err := ReadOctet(reader)
	if err != nil {
		return err
	}

	method.Reserved2 = bits&(1<<0) != 0

	return
}

// Write method from io reader
func (method *ConnectionOpen) Write(writer io.Writer, protoVersion string) (err error) {

	if err = WriteShortstr(writer, method.VirtualHost); err != nil {
		return err
	}

	if err = WriteShortstr(writer, method.Reserved1); err != nil {
		return err
	}

	var bits byte

	if method.Reserved2 {
		bits |= 1 << 0
	}

	if err = WriteOctet(writer, bits); err != nil {
		return err
	}

	return
}

// ConnectionOpenOk This method signals to the client that the connection is ready for use.
type ConnectionOpenOk struct {
	Reserved1 string
}

// Name returns method name as string, usefully for logging
func (method *ConnectionOpenOk) Name() string {
	return "ConnectionOpenOk"
}

// FrameType returns method frame type
func (method *ConnectionOpenOk) FrameType() byte {
	return 1
}

// ClassIdentifier returns method classID
func (method *ConnectionOpenOk) ClassIdentifier() uint16 {
	return 10
}

// MethodIdentifier returns method methodID
func (method *ConnectionOpenOk) MethodIdentifier() uint16 {
	return 41
}

// Sync is method should me sent synchronous
func (method *ConnectionOpenOk) Sync() bool {
	return true
}

// Read method from io reader
func (method *ConnectionOpenOk) Read(reader io.Reader, protoVersion string) (err error) {

	method.Reserved1, err = ReadShortstr(reader)
	if err != nil {
		return err
	}

	return
}

// Write method from io reader
func (method *ConnectionOpenOk) Write(writer io.Writer, protoVersion string) (err error) {

	if err = WriteShortstr(writer, method.Reserved1); err != nil {
		return err
	}

	return
}

// ConnectionClose This method indicates that the sender wants to close the connection. This may be
// due to internal conditions (e.g. a forced shut-down) or due to an error handling
// a specific method, i.e. an exception. When a close is due to an exception, the
// sender provides the class and method id of the method which caused the exception.
type ConnectionClose struct {
	ReplyCode uint16
	ReplyText string
	ClassID   uint16
	MethodID  uint16
}

// Name returns method name as string, usefully for logging
func (method *ConnectionClose) Name() string {
	return "ConnectionClose"
}

// FrameType returns method frame type
func (method *ConnectionClose) FrameType() byte {
	return 1
}

// ClassIdentifier returns method classID
func (method *ConnectionClose) ClassIdentifier() uint16 {
	return 10
}

// MethodIdentifier returns method methodID
func (method *ConnectionClose) MethodIdentifier() uint16 {
	return 50
}

// Sync is method should me sent synchronous
func (method *ConnectionClose) Sync() bool {
	return true
}

// Read method from io reader
func (method *ConnectionClose) Read(reader io.Reader, protoVersion string) (err error) {

	method.ReplyCode, err = ReadShort(reader)
	if err != nil {
		return err
	}

	method.ReplyText, err = ReadShortstr(reader)
	if err != nil {
		return err
	}

	method.ClassID, err = ReadShort(reader)
	if err != nil {
		return err
	}

	method.MethodID, err = ReadShort(reader)
	if err != nil {
		return err
	}

	return
}

// Write method from io reader
func (method *ConnectionClose) Write(writer io.Writer, protoVersion string) (err error) {

	if err = WriteShort(writer, method.ReplyCode); err != nil {
		return err
	}

	if err = WriteShortstr(writer, method.ReplyText); err != nil {
		return err
	}

	if err = WriteShort(writer, method.ClassID); err != nil {
		return err
	}

	if err = WriteShort(writer, method.MethodID); err != nil {
		return err
	}

	return
}

// ConnectionCloseOk This method confirms a Connection.Close method and tells the recipient that it is
// safe to release resources for the connection and close the socket.
type ConnectionCloseOk struct {
}

// Name returns method name as string, usefully for logging
func (method *ConnectionCloseOk) Name() string {
	return "ConnectionCloseOk"
}

// FrameType returns method frame type
func (method *ConnectionCloseOk) FrameType() byte {
	return 1
}

// ClassIdentifier returns method classID
func (method *ConnectionCloseOk) ClassIdentifier() uint16 {
	return 10
}

// MethodIdentifier returns method methodID
func (method *ConnectionCloseOk) MethodIdentifier() uint16 {
	return 51
}

// Sync is method should me sent synchronous
func (method *ConnectionCloseOk) Sync() bool {
	return true
}

// Read method from io reader
func (method *ConnectionCloseOk) Read(reader io.Reader, protoVersion string) (err error) {

	return
}

// Write method from io reader
func (method *ConnectionCloseOk) Write(writer io.Writer, protoVersion string) (err error) {

	return
}

// ConnectionBlocked This method indicates that a connection has been blocked
// and does not accept new publishes.
type ConnectionBlocked struct {
	Reason string
}

// Name returns method name as string, usefully for logging
func (method *ConnectionBlocked) Name() string {
	return "ConnectionBlocked"
}

// FrameType returns method frame type
func (method *ConnectionBlocked) FrameType() byte {
	return 1
}

// ClassIdentifier returns method classID
func (method *ConnectionBlocked) ClassIdentifier() uint16 {
	return 10
}

// MethodIdentifier returns method methodID
func (method *ConnectionBlocked) MethodIdentifier() uint16 {
	return 60
}

// Sync is method should me sent synchronous
func (method *ConnectionBlocked) Sync() bool {
	return false
}

// Read method from io reader
func (method *ConnectionBlocked) Read(reader io.Reader, protoVersion string) (err error) {

	method.Reason, err = ReadShortstr(reader)
	if err != nil {
		return err
	}

	return
}

// Write method from io reader
func (method *ConnectionBlocked) Write(writer io.Writer, protoVersion string) (err error) {

	if err = WriteShortstr(writer, method.Reason); err != nil {
		return err
	}

	return
}

// ConnectionUnblocked This method indicates that a connection has been unblocked
// and now accepts publishes.
type ConnectionUnblocked struct {
}

// Name returns method name as string, usefully for logging
func (method *ConnectionUnblocked) Name() string {
	return "ConnectionUnblocked"
}

// FrameType returns method frame type
func (method *ConnectionUnblocked) FrameType() byte {
	return 1
}

// ClassIdentifier returns method classID
func (method *ConnectionUnblocked) ClassIdentifier() uint16 {
	return 10
}

// MethodIdentifier returns method methodID
func (method *ConnectionUnblocked) MethodIdentifier() uint16 {
	return 61
}

// Sync is method should me sent synchronous
func (method *ConnectionUnblocked) Sync() bool {
	return false
}

// Read method from io reader
func (method *ConnectionUnblocked) Read(reader io.Reader, protoVersion string) (err error) {

	return
}

// Write method from io reader
func (method *ConnectionUnblocked) Write(writer io.Writer, protoVersion string) (err error) {

	return
}

// Channel methods

// ChannelOpen This method opens a channel to the server.
type ChannelOpen struct {
	Reserved1 string
}

// Name returns method name as string, usefully for logging
func (method *ChannelOpen) Name() string {
	return "ChannelOpen"
}

// FrameType returns method frame type
func (method *ChannelOpen) FrameType() byte {
	return 1
}

// ClassIdentifier returns method classID
func (method *ChannelOpen) ClassIdentifier() uint16 {
	return 20
}

// MethodIdentifier returns method methodID
func (method *ChannelOpen) MethodIdentifier() uint16 {
	return 10
}

// Sync is method should me sent synchronous
func (method *ChannelOpen) Sync() bool {
	return true
}

// Read method from io reader
func (method *ChannelOpen) Read(reader io.Reader, protoVersion string) (err error) {

	method.Reserved1, err = ReadShortstr(reader)
	if err != nil {
		return err
	}

	return
}

// Write method from io reader
func (method *ChannelOpen) Write(writer io.Writer, protoVersion string) (err error) {

	if err = WriteShortstr(writer, method.Reserved1); err != nil {
		return err
	}

	return
}

// ChannelOpenOk This method signals to the client that the channel is ready for use.
type ChannelOpenOk struct {
	Reserved1 []byte
}

// Name returns method name as string, usefully for logging
func (method *ChannelOpenOk) Name() string {
	return "ChannelOpenOk"
}

// FrameType returns method frame type
func (method *ChannelOpenOk) FrameType() byte {
	return 1
}

// ClassIdentifier returns method classID
func (method *ChannelOpenOk) ClassIdentifier() uint16 {
	return 20
}

// MethodIdentifier returns method methodID
func (method *ChannelOpenOk) MethodIdentifier() uint16 {
	return 11
}

// Sync is method should me sent synchronous
func (method *ChannelOpenOk) Sync() bool {
	return true
}

// Read method from io reader
func (method *ChannelOpenOk) Read(reader io.Reader, protoVersion string) (err error) {

	method.Reserved1, err = ReadLongstr(reader)
	if err != nil {
		return err
	}

	return
}

// Write method from io reader
func (method *ChannelOpenOk) Write(writer io.Writer, protoVersion string) (err error) {

	if err = WriteLongstr(writer, method.Reserved1); err != nil {
		return err
	}

	return
}

// ChannelFlow This method asks the peer to pause or restart the flow of content data sent by
// a consumer. This is a simple flow-control mechanism that a peer can use to avoid
// overflowing its queues or otherwise finding itself receiving more messages than
// it can process. Note that this method is not intended for window control. It does
// not affect contents returned by Basic.Get-Ok methods.
type ChannelFlow struct {
	Active bool
}

// Name returns method name as string, usefully for logging
func (method *ChannelFlow) Name() string {
	return "ChannelFlow"
}

// FrameType returns method frame type
func (method *ChannelFlow) FrameType() byte {
	return 1
}

// ClassIdentifier returns method classID
func (method *ChannelFlow) ClassIdentifier() uint16 {
	return 20
}

// MethodIdentifier returns method methodID
func (method *ChannelFlow) MethodIdentifier() uint16 {
	return 20
}

// Sync is method should me sent synchronous
func (method *ChannelFlow) Sync() bool {
	return true
}

// Read method from io reader
func (method *ChannelFlow) Read(reader io.Reader, protoVersion string) (err error) {

	bits, err := ReadOctet(reader)
	if err != nil {
		return err
	}

	method.Active = bits&(1<<0) != 0

	return
}

// Write method from io reader
func (method *ChannelFlow) Write(writer io.Writer, protoVersion string) (err error) {

	var bits byte

	if method.Active {
		bits |= 1 << 0
	}

	if err = WriteOctet(writer, bits); err != nil {
		return err
	}

	return
}

// ChannelFlowOk Confirms to the peer that a flow command was received and processed.
type ChannelFlowOk struct {
	Active bool
}

// Name returns method name as string, usefully for logging
func (method *ChannelFlowOk) Name() string {
	return "ChannelFlowOk"
}

// FrameType returns method frame type
func (method *ChannelFlowOk) FrameType() byte {
	return 1
}

// ClassIdentifier returns method classID
func (method *ChannelFlowOk) ClassIdentifier() uint16 {
	return 20
}

// MethodIdentifier returns method methodID
func (method *ChannelFlowOk) MethodIdentifier() uint16 {
	return 21
}

// Sync is method should me sent synchronous
func (method *ChannelFlowOk) Sync() bool {
	return false
}

// Read method from io reader
func (method *ChannelFlowOk) Read(reader io.Reader, protoVersion string) (err error) {

	bits, err := ReadOctet(reader)
	if err != nil {
		return err
	}

	method.Active = bits&(1<<0) != 0

	return
}

// Write method from io reader
func (method *ChannelFlowOk) Write(writer io.Writer, protoVersion string) (err error) {

	var bits byte

	if method.Active {
		bits |= 1 << 0
	}

	if err = WriteOctet(writer, bits); err != nil {
		return err
	}

	return
}

// ChannelClose This method indicates that the sender wants to close the channel. This may be due to
// internal conditions (e.g. a forced shut-down) or due to an error handling a specific
// method, i.e. an exception. When a close is due to an exception, the sender provides
// the class and method id of the method which caused the exception.
type ChannelClose struct {
	ReplyCode uint16
	ReplyText string
	ClassID   uint16
	MethodID  uint16
}

// Name returns method name as string, usefully for logging
func (method *ChannelClose) Name() string {
	return "ChannelClose"
}

// FrameType returns method frame type
func (method *ChannelClose) FrameType() byte {
	return 1
}

// ClassIdentifier returns method classID
func (method *ChannelClose) ClassIdentifier() uint16 {
	return 20
}

// MethodIdentifier returns method methodID
func (method *ChannelClose) MethodIdentifier() uint16 {
	return 40
}

// Sync is method should me sent synchronous
func (method *ChannelClose) Sync() bool {
	return true
}

// Read method from io reader
func (method *ChannelClose) Read(reader io.Reader, protoVersion string) (err error) {

	method.ReplyCode, err = ReadShort(reader)
	if err != nil {
		return err
	}

	method.ReplyText, err = ReadShortstr(reader)
	if err != nil {
		return err
	}

	method.ClassID, err = ReadShort(reader)
	if err != nil {
		return err
	}

	method.MethodID, err = ReadShort(reader)
	if err != nil {
		return err
	}

	return
}

// Write method from io reader
func (method *ChannelClose) Write(writer io.Writer, protoVersion string) (err error) {

	if err = WriteShort(writer, method.ReplyCode); err != nil {
		return err
	}

	if err = WriteShortstr(writer, method.ReplyText); err != nil {
		return err
	}

	if err = WriteShort(writer, method.ClassID); err != nil {
		return err
	}

	if err = WriteShort(writer, method.MethodID); err != nil {
		return err
	}

	return
}

// ChannelCloseOk This method confirms a Channel.Close method and tells the recipient that it is safe
// to release resources for the channel.
type ChannelCloseOk struct {
}

// Name returns method name as string, usefully for logging
func (method *ChannelCloseOk) Name() string {
	return "ChannelCloseOk"
}

// FrameType returns method frame type
func (method *ChannelCloseOk) FrameType() byte {
	return 1
}

// ClassIdentifier returns method classID
func (method *ChannelCloseOk) ClassIdentifier() uint16 {
	return 20
}

// MethodIdentifier returns method methodID
func (method *ChannelCloseOk) MethodIdentifier() uint16 {
	return 41
}

// Sync is method should me sent synchronous
func (method *ChannelCloseOk) Sync() bool {
	return true
}

// Read method from io reader
func (method *ChannelCloseOk) Read(reader io.Reader, protoVersion string) (err error) {

	return
}

// Write method from io reader
func (method *ChannelCloseOk) Write(writer io.Writer, protoVersion string) (err error) {

	return
}

// Exchange methods

// ExchangeDeclare This method creates an exchange if it does not already exist, and if the exchange
// exists, verifies that it is of the correct and expected class.
type ExchangeDeclare struct {
	Reserved1  uint16
	Exchange   string
	Type       string
	Passive    bool
	Durable    bool
	AutoDelete bool
	Internal   bool
	NoWait     bool
	Arguments  *Table
}

// Name returns method name as string, usefully for logging
func (method *ExchangeDeclare) Name() string {
	return "ExchangeDeclare"
}

// FrameType returns method frame type
func (method *ExchangeDeclare) FrameType() byte {
	return 1
}

// ClassIdentifier returns method classID
func (method *ExchangeDeclare) ClassIdentifier() uint16 {
	return 40
}

// MethodIdentifier returns method methodID
func (method *ExchangeDeclare) MethodIdentifier() uint16 {
	return 10
}

// Sync is method should me sent synchronous
func (method *ExchangeDeclare) Sync() bool {
	return true
}

// Read method from io reader
func (method *ExchangeDeclare) Read(reader io.Reader, protoVersion string) (err error) {

	method.Reserved1, err = ReadShort(reader)
	if err != nil {
		return err
	}

	method.Exchange, err = ReadShortstr(reader)
	if err != nil {
		return err
	}

	method.Type, err = ReadShortstr(reader)
	if err != nil {
		return err
	}

	bits, err := ReadOctet(reader)
	if err != nil {
		return err
	}

	method.Passive = bits&(1<<0) != 0

	method.Durable = bits&(1<<1) != 0

	method.AutoDelete = bits&(1<<2) != 0

	method.Internal = bits&(1<<3) != 0

	method.NoWait = bits&(1<<4) != 0

	method.Arguments, err = ReadTable(reader, protoVersion)
	if err != nil {
		return err
	}

	return
}

// Write method from io reader
func (method *ExchangeDeclare) Write(writer io.Writer, protoVersion string) (err error) {

	if err = WriteShort(writer, method.Reserved1); err != nil {
		return err
	}

	if err = WriteShortstr(writer, method.Exchange); err != nil {
		return err
	}

	if err = WriteShortstr(writer, method.Type); err != nil {
		return err
	}

	var bits byte

	if method.Passive {
		bits |= 1 << 0
	}

	if method.Durable {
		bits |= 1 << 1
	}

	if method.AutoDelete {
		bits |= 1 << 2
	}

	if method.Internal {
		bits |= 1 << 3
	}

	if method.NoWait {
		bits |= 1 << 4
	}

	if err = WriteOctet(writer, bits); err != nil {
		return err
	}

	if err = WriteTable(writer, method.Arguments, protoVersion); err != nil {
		return err
	}

	return
}

// ExchangeDeclareOk This method confirms a Declare method and confirms the name of the exchange,
// essential for automatically-named exchanges.
type ExchangeDeclareOk struct {
}

// Name returns method name as string, usefully for logging
func (method *ExchangeDeclareOk) Name() string {
	return "ExchangeDeclareOk"
}

// FrameType returns method frame type
func (method *ExchangeDeclareOk) FrameType() byte {
	return 1
}

// ClassIdentifier returns method classID
func (method *ExchangeDeclareOk) ClassIdentifier() uint16 {
	return 40
}

// MethodIdentifier returns method methodID
func (method *ExchangeDeclareOk) MethodIdentifier() uint16 {
	return 11
}

// Sync is method should me sent synchronous
func (method *ExchangeDeclareOk) Sync() bool {
	return true
}

// Read method from io reader
func (method *ExchangeDeclareOk) Read(reader io.Reader, protoVersion string) (err error) {

	return
}

// Write method from io reader
func (method *ExchangeDeclareOk) Write(writer io.Writer, protoVersion string) (err error) {

	return
}

// ExchangeDelete This method deletes an exchange. When an exchange is deleted all queue bindings on
// the exchange are cancelled.
type ExchangeDelete struct {
	Reserved1 uint16
	Exchange  string
	IfUnused  bool
	NoWait    bool
}

// Name returns method name as string, usefully for logging
func (method *ExchangeDelete) Name() string {
	return "ExchangeDelete"
}

// FrameType returns method frame type
func (method *ExchangeDelete) FrameType() byte {
	return 1
}

// ClassIdentifier returns method classID
func (method *ExchangeDelete) ClassIdentifier() uint16 {
	return 40
}

// MethodIdentifier returns method methodID
func (method *ExchangeDelete) MethodIdentifier() uint16 {
	return 20
}

// Sync is method should me sent synchronous
func (method *ExchangeDelete) Sync() bool {
	return true
}

// Read method from io reader
func (method *ExchangeDelete) Read(reader io.Reader, protoVersion string) (err error) {

	method.Reserved1, err = ReadShort(reader)
	if err != nil {
		return err
	}

	method.Exchange, err = ReadShortstr(reader)
	if err != nil {
		return err
	}

	bits, err := ReadOctet(reader)
	if err != nil {
		return err
	}

	method.IfUnused = bits&(1<<0) != 0

	method.NoWait = bits&(1<<1) != 0

	return
}

// Write method from io reader
func (method *ExchangeDelete) Write(writer io.Writer, protoVersion string) (err error) {

	if err = WriteShort(writer, method.Reserved1); err != nil {
		return err
	}

	if err = WriteShortstr(writer, method.Exchange); err != nil {
		return err
	}

	var bits byte

	if method.IfUnused {
		bits |= 1 << 0
	}

	if method.NoWait {
		bits |= 1 << 1
	}

	if err = WriteOctet(writer, bits); err != nil {
		return err
	}

	return
}

// ExchangeDeleteOk This method confirms the deletion of an exchange.
type ExchangeDeleteOk struct {
}

// Name returns method name as string, usefully for logging
func (method *ExchangeDeleteOk) Name() string {
	return "ExchangeDeleteOk"
}

// FrameType returns method frame type
func (method *ExchangeDeleteOk) FrameType() byte {
	return 1
}

// ClassIdentifier returns method classID
func (method *ExchangeDeleteOk) ClassIdentifier() uint16 {
	return 40
}

// MethodIdentifier returns method methodID
func (method *ExchangeDeleteOk) MethodIdentifier() uint16 {
	return 21
}

// Sync is method should me sent synchronous
func (method *ExchangeDeleteOk) Sync() bool {
	return true
}

// Read method from io reader
func (method *ExchangeDeleteOk) Read(reader io.Reader, protoVersion string) (err error) {

	return
}

// Write method from io reader
func (method *ExchangeDeleteOk) Write(writer io.Writer, protoVersion string) (err error) {

	return
}

// ExchangeBind This method binds an exchange to an exchange.
type ExchangeBind struct {
	Reserved1   uint16
	Destination string
	Source      string
	RoutingKey  string
	NoWait      bool
	Arguments   *Table
}

// Name returns method name as string, usefully for logging
func (method *ExchangeBind) Name() string {
	return "ExchangeBind"
}

// FrameType returns method frame type
func (method *ExchangeBind) FrameType() byte {
	return 1
}

// ClassIdentifier returns method classID
func (method *ExchangeBind) ClassIdentifier() uint16 {
	return 40
}

// MethodIdentifier returns method methodID
func (method *ExchangeBind) MethodIdentifier() uint16 {
	return 30
}

// Sync is method should me sent synchronous
func (method *ExchangeBind) Sync() bool {
	return true
}

// Read method from io reader
func (method *ExchangeBind) Read(reader io.Reader, protoVersion string) (err error) {

	method.Reserved1, err = ReadShort(reader)
	if err != nil {
		return err
	}

	method.Destination, err = ReadShortstr(reader)
	if err != nil {
		return err
	}

	method.Source, err = ReadShortstr(reader)
	if err != nil {
		return err
	}

	method.RoutingKey, err = ReadShortstr(reader)
	if err != nil {
		return err
	}

	bits, err := ReadOctet(reader)
	if err != nil {
		return err
	}

	method.NoWait = bits&(1<<0) != 0

	method.Arguments, err = ReadTable(reader, protoVersion)
	if err != nil {
		return err
	}

	return
}

// Write method from io reader
func (method *ExchangeBind) Write(writer io.Writer, protoVersion string) (err error) {

	if err = WriteShort(writer, method.Reserved1); err != nil {
		return err
	}

	if err = WriteShortstr(writer, method.Destination); err != nil {
		return err
	}

	if err = WriteShortstr(writer, method.Source); err != nil {
		return err
	}

	if err = WriteShortstr(writer, method.RoutingKey); err != nil {
		return err
	}

	var bits byte

	if method.NoWait {
		bits |= 1 << 0
	}

	if err = WriteOctet(writer, bits); err != nil {
		return err
	}

	if err = WriteTable(writer, method.Arguments, protoVersion); err != nil {
		return err
	}

	return
}

// ExchangeBindOk This method confirms that the bind was successful.
type ExchangeBindOk struct {
}

// Name returns method name as string, usefully for logging
func (method *ExchangeBindOk) Name() string {
	return "ExchangeBindOk"
}

// FrameType returns method frame type
func (method *ExchangeBindOk) FrameType() byte {
	return 1
}

// ClassIdentifier returns method classID
func (method *ExchangeBindOk) ClassIdentifier() uint16 {
	return 40
}

// MethodIdentifier returns method methodID
func (method *ExchangeBindOk) MethodIdentifier() uint16 {
	return 31
}

// Sync is method should me sent synchronous
func (method *ExchangeBindOk) Sync() bool {
	return true
}

// Read method from io reader
func (method *ExchangeBindOk) Read(reader io.Reader, protoVersion string) (err error) {

	return
}

// Write method from io reader
func (method *ExchangeBindOk) Write(writer io.Writer, protoVersion string) (err error) {

	return
}

// ExchangeUnbind This method unbinds an exchange from an exchange.
type ExchangeUnbind struct {
	Reserved1   uint16
	Destination string
	Source      string
	RoutingKey  string
	NoWait      bool
	Arguments   *Table
}

// Name returns method name as string, usefully for logging
func (method *ExchangeUnbind) Name() string {
	return "ExchangeUnbind"
}

// FrameType returns method frame type
func (method *ExchangeUnbind) FrameType() byte {
	return 1
}

// ClassIdentifier returns method classID
func (method *ExchangeUnbind) ClassIdentifier() uint16 {
	return 40
}

// MethodIdentifier returns method methodID
func (method *ExchangeUnbind) MethodIdentifier() uint16 {
	return 40
}

// Sync is method should me sent synchronous
func (method *ExchangeUnbind) Sync() bool {
	return true
}

// Read method from io reader
func (method *ExchangeUnbind) Read(reader io.Reader, protoVersion string) (err error) {

	method.Reserved1, err = ReadShort(reader)
	if err != nil {
		return err
	}

	method.Destination, err = ReadShortstr(reader)
	if err != nil {
		return err
	}

	method.Source, err = ReadShortstr(reader)
	if err != nil {
		return err
	}

	method.RoutingKey, err = ReadShortstr(reader)
	if err != nil {
		return err
	}

	bits, err := ReadOctet(reader)
	if err != nil {
		return err
	}

	method.NoWait = bits&(1<<0) != 0

	method.Arguments, err = ReadTable(reader, protoVersion)
	if err != nil {
		return err
	}

	return
}

// Write method from io reader
func (method *ExchangeUnbind) Write(writer io.Writer, protoVersion string) (err error) {

	if err = WriteShort(writer, method.Reserved1); err != nil {
		return err
	}

	if err = WriteShortstr(writer, method.Destination); err != nil {
		return err
	}

	if err = WriteShortstr(writer, method.Source); err != nil {
		return err
	}

	if err = WriteShortstr(writer, method.RoutingKey); err != nil {
		return err
	}

	var bits byte

	if method.NoWait {
		bits |= 1 << 0
	}

	if err = WriteOctet(writer, bits); err != nil {
		return err
	}

	if err = WriteTable(writer, method.Arguments, protoVersion); err != nil {
		return err
	}

	return
}

// ExchangeUnbindOk This method confirms that the unbind was successful.
type ExchangeUnbindOk struct {
}

// Name returns method name as string, usefully for logging
func (method *ExchangeUnbindOk) Name() string {
	return "ExchangeUnbindOk"
}

// FrameType returns method frame type
func (method *ExchangeUnbindOk) FrameType() byte {
	return 1
}

// ClassIdentifier returns method classID
func (method *ExchangeUnbindOk) ClassIdentifier() uint16 {
	return 40
}

// MethodIdentifier returns method methodID
func (method *ExchangeUnbindOk) MethodIdentifier() uint16 {
	return 51
}

// Sync is method should me sent synchronous
func (method *ExchangeUnbindOk) Sync() bool {
	return true
}

// Read method from io reader
func (method *ExchangeUnbindOk) Read(reader io.Reader, protoVersion string) (err error) {

	return
}

// Write method from io reader
func (method *ExchangeUnbindOk) Write(writer io.Writer, protoVersion string) (err error) {

	return
}

// Queue methods

// QueueDeclare This method creates or checks a queue. When creating a new queue the client can
// specify various properties that control the durability of the queue and its
// contents, and the level of sharing for the queue.
type QueueDeclare struct {
	Reserved1  uint16
	Queue      string
	Passive    bool
	Durable    bool
	Exclusive  bool
	AutoDelete bool
	NoWait     bool
	Arguments  *Table
}

// Name returns method name as string, usefully for logging
func (method *QueueDeclare) Name() string {
	return "QueueDeclare"
}

// FrameType returns method frame type
func (method *QueueDeclare) FrameType() byte {
	return 1
}

// ClassIdentifier returns method classID
func (method *QueueDeclare) ClassIdentifier() uint16 {
	return 50
}

// MethodIdentifier returns method methodID
func (method *QueueDeclare) MethodIdentifier() uint16 {
	return 10
}

// Sync is method should me sent synchronous
func (method *QueueDeclare) Sync() bool {
	return true
}

// Read method from io reader
func (method *QueueDeclare) Read(reader io.Reader, protoVersion string) (err error) {

	method.Reserved1, err = ReadShort(reader)
	if err != nil {
		return err
	}

	method.Queue, err = ReadShortstr(reader)
	if err != nil {
		return err
	}

	bits, err := ReadOctet(reader)
	if err != nil {
		return err
	}

	method.Passive = bits&(1<<0) != 0

	method.Durable = bits&(1<<1) != 0

	method.Exclusive = bits&(1<<2) != 0

	method.AutoDelete = bits&(1<<3) != 0

	method.NoWait = bits&(1<<4) != 0

	method.Arguments, err = ReadTable(reader, protoVersion)
	if err != nil {
		return err
	}

	return
}

// Write method from io reader
func (method *QueueDeclare) Write(writer io.Writer, protoVersion string) (err error) {

	if err = WriteShort(writer, method.Reserved1); err != nil {
		return err
	}

	if err = WriteShortstr(writer, method.Queue); err != nil {
		return err
	}

	var bits byte

	if method.Passive {
		bits |= 1 << 0
	}

	if method.Durable {
		bits |= 1 << 1
	}

	if method.Exclusive {
		bits |= 1 << 2
	}

	if method.AutoDelete {
		bits |= 1 << 3
	}

	if method.NoWait {
		bits |= 1 << 4
	}

	if err = WriteOctet(writer, bits); err != nil {
		return err
	}

	if err = WriteTable(writer, method.Arguments, protoVersion); err != nil {
		return err
	}

	return
}

// QueueDeclareOk This method confirms a Declare method and confirms the name of the queue, essential
// for automatically-named queues.
type QueueDeclareOk struct {
	Queue         string
	MessageCount  uint32
	ConsumerCount uint32
}

// Name returns method name as string, usefully for logging
func (method *QueueDeclareOk) Name() string {
	return "QueueDeclareOk"
}

// FrameType returns method frame type
func (method *QueueDeclareOk) FrameType() byte {
	return 1
}

// ClassIdentifier returns method classID
func (method *QueueDeclareOk) ClassIdentifier() uint16 {
	return 50
}

// MethodIdentifier returns method methodID
func (method *QueueDeclareOk) MethodIdentifier() uint16 {
	return 11
}

// Sync is method should me sent synchronous
func (method *QueueDeclareOk) Sync() bool {
	return true
}

// Read method from io reader
func (method *QueueDeclareOk) Read(reader io.Reader, protoVersion string) (err error) {

	method.Queue, err = ReadShortstr(reader)
	if err != nil {
		return err
	}

	method.MessageCount, err = ReadLong(reader)
	if err != nil {
		return err
	}

	method.ConsumerCount, err = ReadLong(reader)
	if err != nil {
		return err
	}

	return
}

// Write method from io reader
func (method *QueueDeclareOk) Write(writer io.Writer, protoVersion string) (err error) {

	if err = WriteShortstr(writer, method.Queue); err != nil {
		return err
	}

	if err = WriteLong(writer, method.MessageCount); err != nil {
		return err
	}

	if err = WriteLong(writer, method.ConsumerCount); err != nil {
		return err
	}

	return
}

// QueueBind This method binds a queue to an exchange. Until a queue is bound it will not
// receive any messages. In a classic messaging model, store-and-forward queues
// are bound to a direct exchange and subscription queues are bound to a topic
// exchange.
type QueueBind struct {
	Reserved1  uint16
	Queue      string
	Exchange   string
	RoutingKey string
	NoWait     bool
	Arguments  *Table
}

// Name returns method name as string, usefully for logging
func (method *QueueBind) Name() string {
	return "QueueBind"
}

// FrameType returns method frame type
func (method *QueueBind) FrameType() byte {
	return 1
}

// ClassIdentifier returns method classID
func (method *QueueBind) ClassIdentifier() uint16 {
	return 50
}

// MethodIdentifier returns method methodID
func (method *QueueBind) MethodIdentifier() uint16 {
	return 20
}

// Sync is method should me sent synchronous
func (method *QueueBind) Sync() bool {
	return true
}

// Read method from io reader
func (method *QueueBind) Read(reader io.Reader, protoVersion string) (err error) {

	method.Reserved1, err = ReadShort(reader)
	if err != nil {
		return err
	}

	method.Queue, err = ReadShortstr(reader)
	if err != nil {
		return err
	}

	method.Exchange, err = ReadShortstr(reader)
	if err != nil {
		return err
	}

	method.RoutingKey, err = ReadShortstr(reader)
	if err != nil {
		return err
	}

	bits, err := ReadOctet(reader)
	if err != nil {
		return err
	}

	method.NoWait = bits&(1<<0) != 0

	method.Arguments, err = ReadTable(reader, protoVersion)
	if err != nil {
		return err
	}

	return
}

// Write method from io reader
func (method *QueueBind) Write(writer io.Writer, protoVersion string) (err error) {

	if err = WriteShort(writer, method.Reserved1); err != nil {
		return err
	}

	if err = WriteShortstr(writer, method.Queue); err != nil {
		return err
	}

	if err = WriteShortstr(writer, method.Exchange); err != nil {
		return err
	}

	if err = WriteShortstr(writer, method.RoutingKey); err != nil {
		return err
	}

	var bits byte

	if method.NoWait {
		bits |= 1 << 0
	}

	if err = WriteOctet(writer, bits); err != nil {
		return err
	}

	if err = WriteTable(writer, method.Arguments, protoVersion); err != nil {
		return err
	}

	return
}

// QueueBindOk This method confirms that the bind was successful.
type QueueBindOk struct {
}

// Name returns method name as string, usefully for logging
func (method *QueueBindOk) Name() string {
	return "QueueBindOk"
}

// FrameType returns method frame type
func (method *QueueBindOk) FrameType() byte {
	return 1
}

// ClassIdentifier returns method classID
func (method *QueueBindOk) ClassIdentifier() uint16 {
	return 50
}

// MethodIdentifier returns method methodID
func (method *QueueBindOk) MethodIdentifier() uint16 {
	return 21
}

// Sync is method should me sent synchronous
func (method *QueueBindOk) Sync() bool {
	return true
}

// Read method from io reader
func (method *QueueBindOk) Read(reader io.Reader, protoVersion string) (err error) {

	return
}

// Write method from io reader
func (method *QueueBindOk) Write(writer io.Writer, protoVersion string) (err error) {

	return
}

// QueueUnbind This method unbinds a queue from an exchange.
type QueueUnbind struct {
	Reserved1  uint16
	Queue      string
	Exchange   string
	RoutingKey string
	Arguments  *Table
}

// Name returns method name as string, usefully for logging
func (method *QueueUnbind) Name() string {
	return "QueueUnbind"
}

// FrameType returns method frame type
func (method *QueueUnbind) FrameType() byte {
	return 1
}

// ClassIdentifier returns method classID
func (method *QueueUnbind) ClassIdentifier() uint16 {
	return 50
}

// MethodIdentifier returns method methodID
func (method *QueueUnbind) MethodIdentifier() uint16 {
	return 50
}

// Sync is method should me sent synchronous
func (method *QueueUnbind) Sync() bool {
	return true
}

// Read method from io reader
func (method *QueueUnbind) Read(reader io.Reader, protoVersion string) (err error) {

	method.Reserved1, err = ReadShort(reader)
	if err != nil {
		return err
	}

	method.Queue, err = ReadShortstr(reader)
	if err != nil {
		return err
	}

	method.Exchange, err = ReadShortstr(reader)
	if err != nil {
		return err
	}

	method.RoutingKey, err = ReadShortstr(reader)
	if err != nil {
		return err
	}

	method.Arguments, err = ReadTable(reader, protoVersion)
	if err != nil {
		return err
	}

	return
}

// Write method from io reader
func (method *QueueUnbind) Write(writer io.Writer, protoVersion string) (err error) {

	if err = WriteShort(writer, method.Reserved1); err != nil {
		return err
	}

	if err = WriteShortstr(writer, method.Queue); err != nil {
		return err
	}

	if err = WriteShortstr(writer, method.Exchange); err != nil {
		return err
	}

	if err = WriteShortstr(writer, method.RoutingKey); err != nil {
		return err
	}

	if err = WriteTable(writer, method.Arguments, protoVersion); err != nil {
		return err
	}

	return
}

// QueueUnbindOk This method confirms that the unbind was successful.
type QueueUnbindOk struct {
}

// Name returns method name as string, usefully for logging
func (method *QueueUnbindOk) Name() string {
	return "QueueUnbindOk"
}

// FrameType returns method frame type
func (method *QueueUnbindOk) FrameType() byte {
	return 1
}

// ClassIdentifier returns method classID
func (method *QueueUnbindOk) ClassIdentifier() uint16 {
	return 50
}

// MethodIdentifier returns method methodID
func (method *QueueUnbindOk) MethodIdentifier() uint16 {
	return 51
}

// Sync is method should me sent synchronous
func (method *QueueUnbindOk) Sync() bool {
	return true
}

// Read method from io reader
func (method *QueueUnbindOk) Read(reader io.Reader, protoVersion string) (err error) {

	return
}

// Write method from io reader
func (method *QueueUnbindOk) Write(writer io.Writer, protoVersion string) (err error) {

	return
}

// QueuePurge This method removes all messages from a queue which are not awaiting
// acknowledgment.
type QueuePurge struct {
	Reserved1 uint16
	Queue     string
	NoWait    bool
}

// Name returns method name as string, usefully for logging
func (method *QueuePurge) Name() string {
	return "QueuePurge"
}

// FrameType returns method frame type
func (method *QueuePurge) FrameType() byte {
	return 1
}

// ClassIdentifier returns method classID
func (method *QueuePurge) ClassIdentifier() uint16 {
	return 50
}

// MethodIdentifier returns method methodID
func (method *QueuePurge) MethodIdentifier() uint16 {
	return 30
}

// Sync is method should me sent synchronous
func (method *QueuePurge) Sync() bool {
	return true
}

// Read method from io reader
func (method *QueuePurge) Read(reader io.Reader, protoVersion string) (err error) {

	method.Reserved1, err = ReadShort(reader)
	if err != nil {
		return err
	}

	method.Queue, err = ReadShortstr(reader)
	if err != nil {
		return err
	}

	bits, err := ReadOctet(reader)
	if err != nil {
		return err
	}

	method.NoWait = bits&(1<<0) != 0

	return
}

// Write method from io reader
func (method *QueuePurge) Write(writer io.Writer, protoVersion string) (err error) {

	if err = WriteShort(writer, method.Reserved1); err != nil {
		return err
	}

	if err = WriteShortstr(writer, method.Queue); err != nil {
		return err
	}

	var bits byte

	if method.NoWait {
		bits |= 1 << 0
	}

	if err = WriteOctet(writer, bits); err != nil {
		return err
	}

	return
}

// QueuePurgeOk This method confirms the purge of a queue.
type QueuePurgeOk struct {
	MessageCount uint32
}

// Name returns method name as string, usefully for logging
func (method *QueuePurgeOk) Name() string {
	return "QueuePurgeOk"
}

// FrameType returns method frame type
func (method *QueuePurgeOk) FrameType() byte {
	return 1
}

// ClassIdentifier returns method classID
func (method *QueuePurgeOk) ClassIdentifier() uint16 {
	return 50
}

// MethodIdentifier returns method methodID
func (method *QueuePurgeOk) MethodIdentifier() uint16 {
	return 31
}

// Sync is method should me sent synchronous
func (method *QueuePurgeOk) Sync() bool {
	return true
}

// Read method from io reader
func (method *QueuePurgeOk) Read(reader io.Reader, protoVersion string) (err error) {

	method.MessageCount, err = ReadLong(reader)
	if err != nil {
		return err
	}

	return
}

// Write method from io reader
func (method *QueuePurgeOk) Write(writer io.Writer, protoVersion string) (err error) {

	if err = WriteLong(writer, method.MessageCount); err != nil {
		return err
	}

	return
}

// QueueDelete This method deletes a queue. When a queue is deleted any pending messages are sent
// to a dead-letter queue if this is defined in the server configuration, and all
// consumers on the queue are cancelled.
type QueueDelete struct {
	Reserved1 uint16
	Queue     string
	IfUnused  bool
	IfEmpty   bool
	NoWait    bool
}

// Name returns method name as string, usefully for logging
func (method *QueueDelete) Name() string {
	return "QueueDelete"
}

// FrameType returns method frame type
func (method *QueueDelete) FrameType() byte {
	return 1
}

// ClassIdentifier returns method classID
func (method *QueueDelete) ClassIdentifier() uint16 {
	return 50
}

// MethodIdentifier returns method methodID
func (method *QueueDelete) MethodIdentifier() uint16 {
	return 40
}

// Sync is method should me sent synchronous
func (method *QueueDelete) Sync() bool {
	return true
}

// Read method from io reader
func (method *QueueDelete) Read(reader io.Reader, protoVersion string) (err error) {

	method.Reserved1, err = ReadShort(reader)
	if err != nil {
		return err
	}

	method.Queue, err = ReadShortstr(reader)
	if err != nil {
		return err
	}

	bits, err := ReadOctet(reader)
	if err != nil {
		return err
	}

	method.IfUnused = bits&(1<<0) != 0

	method.IfEmpty = bits&(1<<1) != 0

	method.NoWait = bits&(1<<2) != 0

	return
}

// Write method from io reader
func (method *QueueDelete) Write(writer io.Writer, protoVersion string) (err error) {

	if err = WriteShort(writer, method.Reserved1); err != nil {
		return err
	}

	if err = WriteShortstr(writer, method.Queue); err != nil {
		return err
	}

	var bits byte

	if method.IfUnused {
		bits |= 1 << 0
	}

	if method.IfEmpty {
		bits |= 1 << 1
	}

	if method.NoWait {
		bits |= 1 << 2
	}

	if err = WriteOctet(writer, bits); err != nil {
		return err
	}

	return
}

// QueueDeleteOk This method confirms the deletion of a queue.
type QueueDeleteOk struct {
	MessageCount uint32
}

// Name returns method name as string, usefully for logging
func (method *QueueDeleteOk) Name() string {
	return "QueueDeleteOk"
}

// FrameType returns method frame type
func (method *QueueDeleteOk) FrameType() byte {
	return 1
}

// ClassIdentifier returns method classID
func (method *QueueDeleteOk) ClassIdentifier() uint16 {
	return 50
}

// MethodIdentifier returns method methodID
func (method *QueueDeleteOk) MethodIdentifier() uint16 {
	return 41
}

// Sync is method should me sent synchronous
func (method *QueueDeleteOk) Sync() bool {
	return true
}

// Read method from io reader
func (method *QueueDeleteOk) Read(reader io.Reader, protoVersion string) (err error) {

	method.MessageCount, err = ReadLong(reader)
	if err != nil {
		return err
	}

	return
}

// Write method from io reader
func (method *QueueDeleteOk) Write(writer io.Writer, protoVersion string) (err error) {

	if err = WriteLong(writer, method.MessageCount); err != nil {
		return err
	}

	return
}

// Basic methods

// BasicPropertyList represents properties for Basic method
type BasicPropertyList struct {
	ContentType     *string
	ContentEncoding *string
	Headers         *Table
	DeliveryMode    *byte
	Priority        *byte
	CorrelationID   *string
	ReplyTo         *string
	Expiration      *string
	MessageID       *string
	Timestamp       *time.Time
	Type            *string
	UserID          *string
	AppID           *string
	Reserved        *string
}

// BasicPropertyList reads properties from io reader
func (pList *BasicPropertyList) Read(reader io.Reader, propertyFlags uint16, protoVersion string) (err error) {

	if propertyFlags&(1<<15) != 0 {
		value, err := ReadShortstr(reader)
		if err != nil {
			return err
		}
		pList.ContentType = &value
	}

	if propertyFlags&(1<<14) != 0 {
		value, err := ReadShortstr(reader)
		if err != nil {
			return err
		}
		pList.ContentEncoding = &value
	}

	if propertyFlags&(1<<13) != 0 {
		value, err := ReadTable(reader, protoVersion)
		if err != nil {
			return err
		}
		pList.Headers = value
	}

	if propertyFlags&(1<<12) != 0 {
		value, err := ReadOctet(reader)
		if err != nil {
			return err
		}
		pList.DeliveryMode = &value
	}

	if propertyFlags&(1<<11) != 0 {
		value, err := ReadOctet(reader)
		if err != nil {
			return err
		}
		pList.Priority = &value
	}

	if propertyFlags&(1<<10) != 0 {
		value, err := ReadShortstr(reader)
		if err != nil {
			return err
		}
		pList.CorrelationID = &value
	}

	if propertyFlags&(1<<9) != 0 {
		value, err := ReadShortstr(reader)
		if err != nil {
			return err
		}
		pList.ReplyTo = &value
	}

	if propertyFlags&(1<<8) != 0 {
		value, err := ReadShortstr(reader)
		if err != nil {
			return err
		}
		pList.Expiration = &value
	}

	if propertyFlags&(1<<7) != 0 {
		value, err := ReadShortstr(reader)
		if err != nil {
			return err
		}
		pList.MessageID = &value
	}

	if propertyFlags&(1<<6) != 0 {
		value, err := ReadTimestamp(reader)
		if err != nil {
			return err
		}
		pList.Timestamp = &value
	}

	if propertyFlags&(1<<5) != 0 {
		value, err := ReadShortstr(reader)
		if err != nil {
			return err
		}
		pList.Type = &value
	}

	if propertyFlags&(1<<4) != 0 {
		value, err := ReadShortstr(reader)
		if err != nil {
			return err
		}
		pList.UserID = &value
	}

	if propertyFlags&(1<<3) != 0 {
		value, err := ReadShortstr(reader)
		if err != nil {
			return err
		}
		pList.AppID = &value
	}

	if propertyFlags&(1<<2) != 0 {
		value, err := ReadShortstr(reader)
		if err != nil {
			return err
		}
		pList.Reserved = &value
	}

	return
}

// BasicPropertyList wiretes properties into io writer
func (pList *BasicPropertyList) Write(writer io.Writer, protoVersion string) (propertyFlags uint16, err error) {

	if pList.ContentType != nil {
		propertyFlags |= 1 << 15
		if err = WriteShortstr(writer, *pList.ContentType); err != nil {
			return
		}
	}

	if pList.ContentEncoding != nil {
		propertyFlags |= 1 << 14
		if err = WriteShortstr(writer, *pList.ContentEncoding); err != nil {
			return
		}
	}

	if pList.Headers != nil {
		propertyFlags |= 1 << 13
		if err = WriteTable(writer, pList.Headers, protoVersion); err != nil {
			return
		}
	}

	if pList.DeliveryMode != nil {
		propertyFlags |= 1 << 12
		if err = WriteOctet(writer, *pList.DeliveryMode); err != nil {
			return
		}
	}

	if pList.Priority != nil {
		propertyFlags |= 1 << 11
		if err = WriteOctet(writer, *pList.Priority); err != nil {
			return
		}
	}

	if pList.CorrelationID != nil {
		propertyFlags |= 1 << 10
		if err = WriteShortstr(writer, *pList.CorrelationID); err != nil {
			return
		}
	}

	if pList.ReplyTo != nil {
		propertyFlags |= 1 << 9
		if err = WriteShortstr(writer, *pList.ReplyTo); err != nil {
			return
		}
	}

	if pList.Expiration != nil {
		propertyFlags |= 1 << 8
		if err = WriteShortstr(writer, *pList.Expiration); err != nil {
			return
		}
	}

	if pList.MessageID != nil {
		propertyFlags |= 1 << 7
		if err = WriteShortstr(writer, *pList.MessageID); err != nil {
			return
		}
	}

	if pList.Timestamp != nil {
		propertyFlags |= 1 << 6
		if err = WriteTimestamp(writer, *pList.Timestamp); err != nil {
			return
		}
	}

	if pList.Type != nil {
		propertyFlags |= 1 << 5
		if err = WriteShortstr(writer, *pList.Type); err != nil {
			return
		}
	}

	if pList.UserID != nil {
		propertyFlags |= 1 << 4
		if err = WriteShortstr(writer, *pList.UserID); err != nil {
			return
		}
	}

	if pList.AppID != nil {
		propertyFlags |= 1 << 3
		if err = WriteShortstr(writer, *pList.AppID); err != nil {
			return
		}
	}

	if pList.Reserved != nil {
		propertyFlags |= 1 << 2
		if err = WriteShortstr(writer, *pList.Reserved); err != nil {
			return
		}
	}

	return
}

// BasicQos This method requests a specific quality of service. The QoS can be specified for the
// current channel or for all channels on the connection. The particular properties and
// semantics of a qos method always depend on the content class semantics. Though the
// qos method could in principle apply to both peers, it is currently meaningful only
// for the server.
type BasicQos struct {
	PrefetchSize  uint32
	PrefetchCount uint16
	Global        bool
}

// Name returns method name as string, usefully for logging
func (method *BasicQos) Name() string {
	return "BasicQos"
}

// FrameType returns method frame type
func (method *BasicQos) FrameType() byte {
	return 1
}

// ClassIdentifier returns method classID
func (method *BasicQos) ClassIdentifier() uint16 {
	return 60
}

// MethodIdentifier returns method methodID
func (method *BasicQos) MethodIdentifier() uint16 {
	return 10
}

// Sync is method should me sent synchronous
func (method *BasicQos) Sync() bool {
	return true
}

// Read method from io reader
func (method *BasicQos) Read(reader io.Reader, protoVersion string) (err error) {

	method.PrefetchSize, err = ReadLong(reader)
	if err != nil {
		return err
	}

	method.PrefetchCount, err = ReadShort(reader)
	if err != nil {
		return err
	}

	bits, err := ReadOctet(reader)
	if err != nil {
		return err
	}

	method.Global = bits&(1<<0) != 0

	return
}

// Write method from io reader
func (method *BasicQos) Write(writer io.Writer, protoVersion string) (err error) {

	if err = WriteLong(writer, method.PrefetchSize); err != nil {
		return err
	}

	if err = WriteShort(writer, method.PrefetchCount); err != nil {
		return err
	}

	var bits byte

	if method.Global {
		bits |= 1 << 0
	}

	if err = WriteOctet(writer, bits); err != nil {
		return err
	}

	return
}

// BasicQosOk This method tells the client that the requested QoS levels could be handled by the
// server. The requested QoS applies to all active consumers until a new QoS is
// defined.
type BasicQosOk struct {
}

// Name returns method name as string, usefully for logging
func (method *BasicQosOk) Name() string {
	return "BasicQosOk"
}

// FrameType returns method frame type
func (method *BasicQosOk) FrameType() byte {
	return 1
}

// ClassIdentifier returns method classID
func (method *BasicQosOk) ClassIdentifier() uint16 {
	return 60
}

// MethodIdentifier returns method methodID
func (method *BasicQosOk) MethodIdentifier() uint16 {
	return 11
}

// Sync is method should me sent synchronous
func (method *BasicQosOk) Sync() bool {
	return true
}

// Read method from io reader
func (method *BasicQosOk) Read(reader io.Reader, protoVersion string) (err error) {

	return
}

// Write method from io reader
func (method *BasicQosOk) Write(writer io.Writer, protoVersion string) (err error) {

	return
}

// BasicConsume This method asks the server to start a "consumer", which is a transient request for
// messages from a specific queue. Consumers last as long as the channel they were
// declared on, or until the client cancels them.
type BasicConsume struct {
	Reserved1   uint16
	Queue       string
	ConsumerTag string
	NoLocal     bool
	NoAck       bool
	Exclusive   bool
	NoWait      bool
	Arguments   *Table
}

// Name returns method name as string, usefully for logging
func (method *BasicConsume) Name() string {
	return "BasicConsume"
}

// FrameType returns method frame type
func (method *BasicConsume) FrameType() byte {
	return 1
}

// ClassIdentifier returns method classID
func (method *BasicConsume) ClassIdentifier() uint16 {
	return 60
}

// MethodIdentifier returns method methodID
func (method *BasicConsume) MethodIdentifier() uint16 {
	return 20
}

// Sync is method should me sent synchronous
func (method *BasicConsume) Sync() bool {
	return true
}

// Read method from io reader
func (method *BasicConsume) Read(reader io.Reader, protoVersion string) (err error) {

	method.Reserved1, err = ReadShort(reader)
	if err != nil {
		return err
	}

	method.Queue, err = ReadShortstr(reader)
	if err != nil {
		return err
	}

	method.ConsumerTag, err = ReadShortstr(reader)
	if err != nil {
		return err
	}

	bits, err := ReadOctet(reader)
	if err != nil {
		return err
	}

	method.NoLocal = bits&(1<<0) != 0

	method.NoAck = bits&(1<<1) != 0

	method.Exclusive = bits&(1<<2) != 0

	method.NoWait = bits&(1<<3) != 0

	method.Arguments, err = ReadTable(reader, protoVersion)
	if err != nil {
		return err
	}

	return
}

// Write method from io reader
func (method *BasicConsume) Write(writer io.Writer, protoVersion string) (err error) {

	if err = WriteShort(writer, method.Reserved1); err != nil {
		return err
	}

	if err = WriteShortstr(writer, method.Queue); err != nil {
		return err
	}

	if err = WriteShortstr(writer, method.ConsumerTag); err != nil {
		return err
	}

	var bits byte

	if method.NoLocal {
		bits |= 1 << 0
	}

	if method.NoAck {
		bits |= 1 << 1
	}

	if method.Exclusive {
		bits |= 1 << 2
	}

	if method.NoWait {
		bits |= 1 << 3
	}

	if err = WriteOctet(writer, bits); err != nil {
		return err
	}

	if err = WriteTable(writer, method.Arguments, protoVersion); err != nil {
		return err
	}

	return
}

// BasicConsumeOk The server provides the client with a consumer tag, which is used by the client
// for methods called on the consumer at a later stage.
type BasicConsumeOk struct {
	ConsumerTag string
}

// Name returns method name as string, usefully for logging
func (method *BasicConsumeOk) Name() string {
	return "BasicConsumeOk"
}

// FrameType returns method frame type
func (method *BasicConsumeOk) FrameType() byte {
	return 1
}

// ClassIdentifier returns method classID
func (method *BasicConsumeOk) ClassIdentifier() uint16 {
	return 60
}

// MethodIdentifier returns method methodID
func (method *BasicConsumeOk) MethodIdentifier() uint16 {
	return 21
}

// Sync is method should me sent synchronous
func (method *BasicConsumeOk) Sync() bool {
	return true
}

// Read method from io reader
func (method *BasicConsumeOk) Read(reader io.Reader, protoVersion string) (err error) {

	method.ConsumerTag, err = ReadShortstr(reader)
	if err != nil {
		return err
	}

	return
}

// Write method from io reader
func (method *BasicConsumeOk) Write(writer io.Writer, protoVersion string) (err error) {

	if err = WriteShortstr(writer, method.ConsumerTag); err != nil {
		return err
	}

	return
}

// BasicCancel This method cancels a consumer. This does not affect already delivered
// messages, but it does mean the server will not send any more messages for
// that consumer. The client may receive an arbitrary number of messages in
// between sending the cancel method and receiving the cancel-ok reply.
//
// It may also be sent from the server to the client in the event
// of the consumer being unexpectedly cancelled (i.e. cancelled
// for any reason other than the server receiving the
// corresponding basic.cancel from the client). This allows
// clients to be notified of the loss of consumers due to events
// such as queue deletion. Note that as it is not a MUST for
// clients to accept this method from the client, it is advisable
// for the broker to be able to identify those clients that are
// capable of accepting the method, through some means of
// capability negotiation.
type BasicCancel struct {
	ConsumerTag string
	NoWait      bool
}

// Name returns method name as string, usefully for logging
func (method *BasicCancel) Name() string {
	return "BasicCancel"
}

// FrameType returns method frame type
func (method *BasicCancel) FrameType() byte {
	return 1
}

// ClassIdentifier returns method classID
func (method *BasicCancel) ClassIdentifier() uint16 {
	return 60
}

// MethodIdentifier returns method methodID
func (method *BasicCancel) MethodIdentifier() uint16 {
	return 30
}

// Sync is method should me sent synchronous
func (method *BasicCancel) Sync() bool {
	return true
}

// Read method from io reader
func (method *BasicCancel) Read(reader io.Reader, protoVersion string) (err error) {

	method.ConsumerTag, err = ReadShortstr(reader)
	if err != nil {
		return err
	}

	bits, err := ReadOctet(reader)
	if err != nil {
		return err
	}

	method.NoWait = bits&(1<<0) != 0

	return
}

// Write method from io reader
func (method *BasicCancel) Write(writer io.Writer, protoVersion string) (err error) {

	if err = WriteShortstr(writer, method.ConsumerTag); err != nil {
		return err
	}

	var bits byte

	if method.NoWait {
		bits |= 1 << 0
	}

	if err = WriteOctet(writer, bits); err != nil {
		return err
	}

	return
}

// BasicCancelOk This method confirms that the cancellation was completed.
type BasicCancelOk struct {
	ConsumerTag string
}

// Name returns method name as string, usefully for logging
func (method *BasicCancelOk) Name() string {
	return "BasicCancelOk"
}

// FrameType returns method frame type
func (method *BasicCancelOk) FrameType() byte {
	return 1
}

// ClassIdentifier returns method classID
func (method *BasicCancelOk) ClassIdentifier() uint16 {
	return 60
}

// MethodIdentifier returns method methodID
func (method *BasicCancelOk) MethodIdentifier() uint16 {
	return 31
}

// Sync is method should me sent synchronous
func (method *BasicCancelOk) Sync() bool {
	return true
}

// Read method from io reader
func (method *BasicCancelOk) Read(reader io.Reader, protoVersion string) (err error) {

	method.ConsumerTag, err = ReadShortstr(reader)
	if err != nil {
		return err
	}

	return
}

// Write method from io reader
func (method *BasicCancelOk) Write(writer io.Writer, protoVersion string) (err error) {

	if err = WriteShortstr(writer, method.ConsumerTag); err != nil {
		return err
	}

	return
}

// BasicPublish This method publishes a message to a specific exchange. The message will be routed
// to queues as defined by the exchange configuration and distributed to any active
// consumers when the transaction, if any, is committed.
type BasicPublish struct {
	Reserved1  uint16
	Exchange   string
	RoutingKey string
	Mandatory  bool
	Immediate  bool
}

// Name returns method name as string, usefully for logging
func (method *BasicPublish) Name() string {
	return "BasicPublish"
}

// FrameType returns method frame type
func (method *BasicPublish) FrameType() byte {
	return 1
}

// ClassIdentifier returns method classID
func (method *BasicPublish) ClassIdentifier() uint16 {
	return 60
}

// MethodIdentifier returns method methodID
func (method *BasicPublish) MethodIdentifier() uint16 {
	return 40
}

// Sync is method should me sent synchronous
func (method *BasicPublish) Sync() bool {
	return false
}

// Read method from io reader
func (method *BasicPublish) Read(reader io.Reader, protoVersion string) (err error) {

	method.Reserved1, err = ReadShort(reader)
	if err != nil {
		return err
	}

	method.Exchange, err = ReadShortstr(reader)
	if err != nil {
		return err
	}

	method.RoutingKey, err = ReadShortstr(reader)
	if err != nil {
		return err
	}

	bits, err := ReadOctet(reader)
	if err != nil {
		return err
	}

	method.Mandatory = bits&(1<<0) != 0

	method.Immediate = bits&(1<<1) != 0

	return
}

// Write method from io reader
func (method *BasicPublish) Write(writer io.Writer, protoVersion string) (err error) {

	if err = WriteShort(writer, method.Reserved1); err != nil {
		return err
	}

	if err = WriteShortstr(writer, method.Exchange); err != nil {
		return err
	}

	if err = WriteShortstr(writer, method.RoutingKey); err != nil {
		return err
	}

	var bits byte

	if method.Mandatory {
		bits |= 1 << 0
	}

	if method.Immediate {
		bits |= 1 << 1
	}

	if err = WriteOctet(writer, bits); err != nil {
		return err
	}

	return
}

// BasicReturn This method returns an undeliverable message that was published with the "immediate"
// flag set, or an unroutable message published with the "mandatory" flag set. The
// reply code and text provide information about the reason that the message was
// undeliverable.
type BasicReturn struct {
	ReplyCode  uint16
	ReplyText  string
	Exchange   string
	RoutingKey string
}

// Name returns method name as string, usefully for logging
func (method *BasicReturn) Name() string {
	return "BasicReturn"
}

// FrameType returns method frame type
func (method *BasicReturn) FrameType() byte {
	return 1
}

// ClassIdentifier returns method classID
func (method *BasicReturn) ClassIdentifier() uint16 {
	return 60
}

// MethodIdentifier returns method methodID
func (method *BasicReturn) MethodIdentifier() uint16 {
	return 50
}

// Sync is method should me sent synchronous
func (method *BasicReturn) Sync() bool {
	return false
}

// Read method from io reader
func (method *BasicReturn) Read(reader io.Reader, protoVersion string) (err error) {

	method.ReplyCode, err = ReadShort(reader)
	if err != nil {
		return err
	}

	method.ReplyText, err = ReadShortstr(reader)
	if err != nil {
		return err
	}

	method.Exchange, err = ReadShortstr(reader)
	if err != nil {
		return err
	}

	method.RoutingKey, err = ReadShortstr(reader)
	if err != nil {
		return err
	}

	return
}

// Write method from io reader
func (method *BasicReturn) Write(writer io.Writer, protoVersion string) (err error) {

	if err = WriteShort(writer, method.ReplyCode); err != nil {
		return err
	}

	if err = WriteShortstr(writer, method.ReplyText); err != nil {
		return err
	}

	if err = WriteShortstr(writer, method.Exchange); err != nil {
		return err
	}

	if err = WriteShortstr(writer, method.RoutingKey); err != nil {
		return err
	}

	return
}

// BasicDeliver This method delivers a message to the client, via a consumer. In the asynchronous
// message delivery model, the client starts a consumer using the Consume method, then
// the server responds with Deliver methods as and when messages arrive for that
// consumer.
type BasicDeliver struct {
	ConsumerTag string
	DeliveryTag uint64
	Redelivered bool
	Exchange    string
	RoutingKey  string
}

// Name returns method name as string, usefully for logging
func (method *BasicDeliver) Name() string {
	return "BasicDeliver"
}

// FrameType returns method frame type
func (method *BasicDeliver) FrameType() byte {
	return 1
}

// ClassIdentifier returns method classID
func (method *BasicDeliver) ClassIdentifier() uint16 {
	return 60
}

// MethodIdentifier returns method methodID
func (method *BasicDeliver) MethodIdentifier() uint16 {
	return 60
}

// Sync is method should me sent synchronous
func (method *BasicDeliver) Sync() bool {
	return false
}

// Read method from io reader
func (method *BasicDeliver) Read(reader io.Reader, protoVersion string) (err error) {

	method.ConsumerTag, err = ReadShortstr(reader)
	if err != nil {
		return err
	}

	method.DeliveryTag, err = ReadLonglong(reader)
	if err != nil {
		return err
	}

	bits, err := ReadOctet(reader)
	if err != nil {
		return err
	}

	method.Redelivered = bits&(1<<0) != 0

	method.Exchange, err = ReadShortstr(reader)
	if err != nil {
		return err
	}

	method.RoutingKey, err = ReadShortstr(reader)
	if err != nil {
		return err
	}

	return
}

// Write method from io reader
func (method *BasicDeliver) Write(writer io.Writer, protoVersion string) (err error) {

	if err = WriteShortstr(writer, method.ConsumerTag); err != nil {
		return err
	}

	if err = WriteLonglong(writer, method.DeliveryTag); err != nil {
		return err
	}

	var bits byte

	if method.Redelivered {
		bits |= 1 << 0
	}

	if err = WriteOctet(writer, bits); err != nil {
		return err
	}

	if err = WriteShortstr(writer, method.Exchange); err != nil {
		return err
	}

	if err = WriteShortstr(writer, method.RoutingKey); err != nil {
		return err
	}

	return
}

// BasicGet This method provides a direct access to the messages in a queue using a synchronous
// dialogue that is designed for specific types of application where synchronous
// functionality is more important than performance.
type BasicGet struct {
	Reserved1 uint16
	Queue     string
	NoAck     bool
}

// Name returns method name as string, usefully for logging
func (method *BasicGet) Name() string {
	return "BasicGet"
}

// FrameType returns method frame type
func (method *BasicGet) FrameType() byte {
	return 1
}

// ClassIdentifier returns method classID
func (method *BasicGet) ClassIdentifier() uint16 {
	return 60
}

// MethodIdentifier returns method methodID
func (method *BasicGet) MethodIdentifier() uint16 {
	return 70
}

// Sync is method should me sent synchronous
func (method *BasicGet) Sync() bool {
	return true
}

// Read method from io reader
func (method *BasicGet) Read(reader io.Reader, protoVersion string) (err error) {

	method.Reserved1, err = ReadShort(reader)
	if err != nil {
		return err
	}

	method.Queue, err = ReadShortstr(reader)
	if err != nil {
		return err
	}

	bits, err := ReadOctet(reader)
	if err != nil {
		return err
	}

	method.NoAck = bits&(1<<0) != 0

	return
}

// Write method from io reader
func (method *BasicGet) Write(writer io.Writer, protoVersion string) (err error) {

	if err = WriteShort(writer, method.Reserved1); err != nil {
		return err
	}

	if err = WriteShortstr(writer, method.Queue); err != nil {
		return err
	}

	var bits byte

	if method.NoAck {
		bits |= 1 << 0
	}

	if err = WriteOctet(writer, bits); err != nil {
		return err
	}

	return
}

// BasicGetOk This method delivers a message to the client following a get method. A message
// delivered by 'get-ok' must be acknowledged unless the no-ack option was set in the
// get method.
type BasicGetOk struct {
	DeliveryTag  uint64
	Redelivered  bool
	Exchange     string
	RoutingKey   string
	MessageCount uint32
}

// Name returns method name as string, usefully for logging
func (method *BasicGetOk) Name() string {
	return "BasicGetOk"
}

// FrameType returns method frame type
func (method *BasicGetOk) FrameType() byte {
	return 1
}

// ClassIdentifier returns method classID
func (method *BasicGetOk) ClassIdentifier() uint16 {
	return 60
}

// MethodIdentifier returns method methodID
func (method *BasicGetOk) MethodIdentifier() uint16 {
	return 71
}

// Sync is method should me sent synchronous
func (method *BasicGetOk) Sync() bool {
	return true
}

// Read method from io reader
func (method *BasicGetOk) Read(reader io.Reader, protoVersion string) (err error) {

	method.DeliveryTag, err = ReadLonglong(reader)
	if err != nil {
		return err
	}

	bits, err := ReadOctet(reader)
	if err != nil {
		return err
	}

	method.Redelivered = bits&(1<<0) != 0

	method.Exchange, err = ReadShortstr(reader)
	if err != nil {
		return err
	}

	method.RoutingKey, err = ReadShortstr(reader)
	if err != nil {
		return err
	}

	method.MessageCount, err = ReadLong(reader)
	if err != nil {
		return err
	}

	return
}

// Write method from io reader
func (method *BasicGetOk) Write(writer io.Writer, protoVersion string) (err error) {

	if err = WriteLonglong(writer, method.DeliveryTag); err != nil {
		return err
	}

	var bits byte

	if method.Redelivered {
		bits |= 1 << 0
	}

	if err = WriteOctet(writer, bits); err != nil {
		return err
	}

	if err = WriteShortstr(writer, method.Exchange); err != nil {
		return err
	}

	if err = WriteShortstr(writer, method.RoutingKey); err != nil {
		return err
	}

	if err = WriteLong(writer, method.MessageCount); err != nil {
		return err
	}

	return
}

// BasicGetEmpty This method tells the client that the queue has no messages available for the
// client.
type BasicGetEmpty struct {
	Reserved1 string
}

// Name returns method name as string, usefully for logging
func (method *BasicGetEmpty) Name() string {
	return "BasicGetEmpty"
}

// FrameType returns method frame type
func (method *BasicGetEmpty) FrameType() byte {
	return 1
}

// ClassIdentifier returns method classID
func (method *BasicGetEmpty) ClassIdentifier() uint16 {
	return 60
}

// MethodIdentifier returns method methodID
func (method *BasicGetEmpty) MethodIdentifier() uint16 {
	return 72
}

// Sync is method should me sent synchronous
func (method *BasicGetEmpty) Sync() bool {
	return true
}

// Read method from io reader
func (method *BasicGetEmpty) Read(reader io.Reader, protoVersion string) (err error) {

	method.Reserved1, err = ReadShortstr(reader)
	if err != nil {
		return err
	}

	return
}

// Write method from io reader
func (method *BasicGetEmpty) Write(writer io.Writer, protoVersion string) (err error) {

	if err = WriteShortstr(writer, method.Reserved1); err != nil {
		return err
	}

	return
}

// BasicAck When sent by the client, this method acknowledges one or more
// messages delivered via the Deliver or Get-Ok methods.
//
// When sent by server, this method acknowledges one or more
// messages published with the Publish method on a channel in
// confirm mode.
//
// The acknowledgement can be for a single message or a set of
// messages up to and including a specific message.
type BasicAck struct {
	DeliveryTag uint64
	Multiple    bool
}

// Name returns method name as string, usefully for logging
func (method *BasicAck) Name() string {
	return "BasicAck"
}

// FrameType returns method frame type
func (method *BasicAck) FrameType() byte {
	return 1
}

// ClassIdentifier returns method classID
func (method *BasicAck) ClassIdentifier() uint16 {
	return 60
}

// MethodIdentifier returns method methodID
func (method *BasicAck) MethodIdentifier() uint16 {
	return 80
}

// Sync is method should me sent synchronous
func (method *BasicAck) Sync() bool {
	return false
}

// Read method from io reader
func (method *BasicAck) Read(reader io.Reader, protoVersion string) (err error) {

	method.DeliveryTag, err = ReadLonglong(reader)
	if err != nil {
		return err
	}

	bits, err := ReadOctet(reader)
	if err != nil {
		return err
	}

	method.Multiple = bits&(1<<0) != 0

	return
}

// Write method from io reader
func (method *BasicAck) Write(writer io.Writer, protoVersion string) (err error) {

	if err = WriteLonglong(writer, method.DeliveryTag); err != nil {
		return err
	}

	var bits byte

	if method.Multiple {
		bits |= 1 << 0
	}

	if err = WriteOctet(writer, bits); err != nil {
		return err
	}

	return
}

// BasicReject This method allows a client to reject a message. It can be used to interrupt and
// cancel large incoming messages, or return untreatable messages to their original
// queue.
type BasicReject struct {
	DeliveryTag uint64
	Requeue     bool
}

// Name returns method name as string, usefully for logging
func (method *BasicReject) Name() string {
	return "BasicReject"
}

// FrameType returns method frame type
func (method *BasicReject) FrameType() byte {
	return 1
}

// ClassIdentifier returns method classID
func (method *BasicReject) ClassIdentifier() uint16 {
	return 60
}

// MethodIdentifier returns method methodID
func (method *BasicReject) MethodIdentifier() uint16 {
	return 90
}

// Sync is method should me sent synchronous
func (method *BasicReject) Sync() bool {
	return false
}

// Read method from io reader
func (method *BasicReject) Read(reader io.Reader, protoVersion string) (err error) {

	method.DeliveryTag, err = ReadLonglong(reader)
	if err != nil {
		return err
	}

	bits, err := ReadOctet(reader)
	if err != nil {
		return err
	}

	method.Requeue = bits&(1<<0) != 0

	return
}

// Write method from io reader
func (method *BasicReject) Write(writer io.Writer, protoVersion string) (err error) {

	if err = WriteLonglong(writer, method.DeliveryTag); err != nil {
		return err
	}

	var bits byte

	if method.Requeue {
		bits |= 1 << 0
	}

	if err = WriteOctet(writer, bits); err != nil {
		return err
	}

	return
}

// BasicRecoverAsync This method asks the server to redeliver all unacknowledged messages on a
// specified channel. Zero or more messages may be redelivered.  This method
// is deprecated in favour of the synchronous Recover/Recover-Ok.
type BasicRecoverAsync struct {
	Requeue bool
}

// Name returns method name as string, usefully for logging
func (method *BasicRecoverAsync) Name() string {
	return "BasicRecoverAsync"
}

// FrameType returns method frame type
func (method *BasicRecoverAsync) FrameType() byte {
	return 1
}

// ClassIdentifier returns method classID
func (method *BasicRecoverAsync) ClassIdentifier() uint16 {
	return 60
}

// MethodIdentifier returns method methodID
func (method *BasicRecoverAsync) MethodIdentifier() uint16 {
	return 100
}

// Sync is method should me sent synchronous
func (method *BasicRecoverAsync) Sync() bool {
	return false
}

// Read method from io reader
func (method *BasicRecoverAsync) Read(reader io.Reader, protoVersion string) (err error) {

	bits, err := ReadOctet(reader)
	if err != nil {
		return err
	}

	method.Requeue = bits&(1<<0) != 0

	return
}

// Write method from io reader
func (method *BasicRecoverAsync) Write(writer io.Writer, protoVersion string) (err error) {

	var bits byte

	if method.Requeue {
		bits |= 1 << 0
	}

	if err = WriteOctet(writer, bits); err != nil {
		return err
	}

	return
}

// BasicRecover This method asks the server to redeliver all unacknowledged messages on a
// specified channel. Zero or more messages may be redelivered.  This method
// replaces the asynchronous Recover.
type BasicRecover struct {
	Requeue bool
}

// Name returns method name as string, usefully for logging
func (method *BasicRecover) Name() string {
	return "BasicRecover"
}

// FrameType returns method frame type
func (method *BasicRecover) FrameType() byte {
	return 1
}

// ClassIdentifier returns method classID
func (method *BasicRecover) ClassIdentifier() uint16 {
	return 60
}

// MethodIdentifier returns method methodID
func (method *BasicRecover) MethodIdentifier() uint16 {
	return 110
}

// Sync is method should me sent synchronous
func (method *BasicRecover) Sync() bool {
	return false
}

// Read method from io reader
func (method *BasicRecover) Read(reader io.Reader, protoVersion string) (err error) {

	bits, err := ReadOctet(reader)
	if err != nil {
		return err
	}

	method.Requeue = bits&(1<<0) != 0

	return
}

// Write method from io reader
func (method *BasicRecover) Write(writer io.Writer, protoVersion string) (err error) {

	var bits byte

	if method.Requeue {
		bits |= 1 << 0
	}

	if err = WriteOctet(writer, bits); err != nil {
		return err
	}

	return
}

// BasicRecoverOk This method acknowledges a Basic.Recover method.
type BasicRecoverOk struct {
}

// Name returns method name as string, usefully for logging
func (method *BasicRecoverOk) Name() string {
	return "BasicRecoverOk"
}

// FrameType returns method frame type
func (method *BasicRecoverOk) FrameType() byte {
	return 1
}

// ClassIdentifier returns method classID
func (method *BasicRecoverOk) ClassIdentifier() uint16 {
	return 60
}

// MethodIdentifier returns method methodID
func (method *BasicRecoverOk) MethodIdentifier() uint16 {
	return 111
}

// Sync is method should me sent synchronous
func (method *BasicRecoverOk) Sync() bool {
	return true
}

// Read method from io reader
func (method *BasicRecoverOk) Read(reader io.Reader, protoVersion string) (err error) {

	return
}

// Write method from io reader
func (method *BasicRecoverOk) Write(writer io.Writer, protoVersion string) (err error) {

	return
}

// BasicNack This method allows a client to reject one or more incoming messages. It can be
// used to interrupt and cancel large incoming messages, or return untreatable
// messages to their original queue.
//
// This method is also used by the server to inform publishers on channels in
// confirm mode of unhandled messages.  If a publisher receives this method, it
// probably needs to republish the offending messages.
type BasicNack struct {
	DeliveryTag uint64
	Multiple    bool
	Requeue     bool
}

// Name returns method name as string, usefully for logging
func (method *BasicNack) Name() string {
	return "BasicNack"
}

// FrameType returns method frame type
func (method *BasicNack) FrameType() byte {
	return 1
}

// ClassIdentifier returns method classID
func (method *BasicNack) ClassIdentifier() uint16 {
	return 60
}

// MethodIdentifier returns method methodID
func (method *BasicNack) MethodIdentifier() uint16 {
	return 120
}

// Sync is method should me sent synchronous
func (method *BasicNack) Sync() bool {
	return false
}

// Read method from io reader
func (method *BasicNack) Read(reader io.Reader, protoVersion string) (err error) {

	method.DeliveryTag, err = ReadLonglong(reader)
	if err != nil {
		return err
	}

	bits, err := ReadOctet(reader)
	if err != nil {
		return err
	}

	method.Multiple = bits&(1<<0) != 0

	method.Requeue = bits&(1<<1) != 0

	return
}

// Write method from io reader
func (method *BasicNack) Write(writer io.Writer, protoVersion string) (err error) {

	if err = WriteLonglong(writer, method.DeliveryTag); err != nil {
		return err
	}

	var bits byte

	if method.Multiple {
		bits |= 1 << 0
	}

	if method.Requeue {
		bits |= 1 << 1
	}

	if err = WriteOctet(writer, bits); err != nil {
		return err
	}

	return
}

// Tx methods

// TxSelect This method sets the channel to use standard transactions. The client must use this
// method at least once on a channel before using the Commit or Rollback methods.
type TxSelect struct {
}

// Name returns method name as string, usefully for logging
func (method *TxSelect) Name() string {
	return "TxSelect"
}

// FrameType returns method frame type
func (method *TxSelect) FrameType() byte {
	return 1
}

// ClassIdentifier returns method classID
func (method *TxSelect) ClassIdentifier() uint16 {
	return 90
}

// MethodIdentifier returns method methodID
func (method *TxSelect) MethodIdentifier() uint16 {
	return 10
}

// Sync is method should me sent synchronous
func (method *TxSelect) Sync() bool {
	return true
}

// Read method from io reader
func (method *TxSelect) Read(reader io.Reader, protoVersion string) (err error) {

	return
}

// Write method from io reader
func (method *TxSelect) Write(writer io.Writer, protoVersion string) (err error) {

	return
}

// TxSelectOk This method confirms to the client that the channel was successfully set to use
// standard transactions.
type TxSelectOk struct {
}

// Name returns method name as string, usefully for logging
func (method *TxSelectOk) Name() string {
	return "TxSelectOk"
}

// FrameType returns method frame type
func (method *TxSelectOk) FrameType() byte {
	return 1
}

// ClassIdentifier returns method classID
func (method *TxSelectOk) ClassIdentifier() uint16 {
	return 90
}

// MethodIdentifier returns method methodID
func (method *TxSelectOk) MethodIdentifier() uint16 {
	return 11
}

// Sync is method should me sent synchronous
func (method *TxSelectOk) Sync() bool {
	return true
}

// Read method from io reader
func (method *TxSelectOk) Read(reader io.Reader, protoVersion string) (err error) {

	return
}

// Write method from io reader
func (method *TxSelectOk) Write(writer io.Writer, protoVersion string) (err error) {

	return
}

// TxCommit This method commits all message publications and acknowledgments performed in
// the current transaction.  A new transaction starts immediately after a commit.
type TxCommit struct {
}

// Name returns method name as string, usefully for logging
func (method *TxCommit) Name() string {
	return "TxCommit"
}

// FrameType returns method frame type
func (method *TxCommit) FrameType() byte {
	return 1
}

// ClassIdentifier returns method classID
func (method *TxCommit) ClassIdentifier() uint16 {
	return 90
}

// MethodIdentifier returns method methodID
func (method *TxCommit) MethodIdentifier() uint16 {
	return 20
}

// Sync is method should me sent synchronous
func (method *TxCommit) Sync() bool {
	return true
}

// Read method from io reader
func (method *TxCommit) Read(reader io.Reader, protoVersion string) (err error) {

	return
}

// Write method from io reader
func (method *TxCommit) Write(writer io.Writer, protoVersion string) (err error) {

	return
}

// TxCommitOk This method confirms to the client that the commit succeeded. Note that if a commit
// fails, the server raises a channel exception.
type TxCommitOk struct {
}

// Name returns method name as string, usefully for logging
func (method *TxCommitOk) Name() string {
	return "TxCommitOk"
}

// FrameType returns method frame type
func (method *TxCommitOk) FrameType() byte {
	return 1
}

// ClassIdentifier returns method classID
func (method *TxCommitOk) ClassIdentifier() uint16 {
	return 90
}

// MethodIdentifier returns method methodID
func (method *TxCommitOk) MethodIdentifier() uint16 {
	return 21
}

// Sync is method should me sent synchronous
func (method *TxCommitOk) Sync() bool {
	return true
}

// Read method from io reader
func (method *TxCommitOk) Read(reader io.Reader, protoVersion string) (err error) {

	return
}

// Write method from io reader
func (method *TxCommitOk) Write(writer io.Writer, protoVersion string) (err error) {

	return
}

// TxRollback This method abandons all message publications and acknowledgments performed in
// the current transaction. A new transaction starts immediately after a rollback.
// Note that unacked messages will not be automatically redelivered by rollback;
// if that is required an explicit recover call should be issued.
type TxRollback struct {
}

// Name returns method name as string, usefully for logging
func (method *TxRollback) Name() string {
	return "TxRollback"
}

// FrameType returns method frame type
func (method *TxRollback) FrameType() byte {
	return 1
}

// ClassIdentifier returns method classID
func (method *TxRollback) ClassIdentifier() uint16 {
	return 90
}

// MethodIdentifier returns method methodID
func (method *TxRollback) MethodIdentifier() uint16 {
	return 30
}

// Sync is method should me sent synchronous
func (method *TxRollback) Sync() bool {
	return true
}

// Read method from io reader
func (method *TxRollback) Read(reader io.Reader, protoVersion string) (err error) {

	return
}

// Write method from io reader
func (method *TxRollback) Write(writer io.Writer, protoVersion string) (err error) {

	return
}

// TxRollbackOk This method confirms to the client that the rollback succeeded. Note that if an
// rollback fails, the server raises a channel exception.
type TxRollbackOk struct {
}

// Name returns method name as string, usefully for logging
func (method *TxRollbackOk) Name() string {
	return "TxRollbackOk"
}

// FrameType returns method frame type
func (method *TxRollbackOk) FrameType() byte {
	return 1
}

// ClassIdentifier returns method classID
func (method *TxRollbackOk) ClassIdentifier() uint16 {
	return 90
}

// MethodIdentifier returns method methodID
func (method *TxRollbackOk) MethodIdentifier() uint16 {
	return 31
}

// Sync is method should me sent synchronous
func (method *TxRollbackOk) Sync() bool {
	return true
}

// Read method from io reader
func (method *TxRollbackOk) Read(reader io.Reader, protoVersion string) (err error) {

	return
}

// Write method from io reader
func (method *TxRollbackOk) Write(writer io.Writer, protoVersion string) (err error) {

	return
}

// Confirm methods

// ConfirmSelect This method sets the channel to use publisher acknowledgements.
// The client can only use this method on a non-transactional
// channel.
type ConfirmSelect struct {
	Nowait bool
}

// Name returns method name as string, usefully for logging
func (method *ConfirmSelect) Name() string {
	return "ConfirmSelect"
}

// FrameType returns method frame type
func (method *ConfirmSelect) FrameType() byte {
	return 1
}

// ClassIdentifier returns method classID
func (method *ConfirmSelect) ClassIdentifier() uint16 {
	return 85
}

// MethodIdentifier returns method methodID
func (method *ConfirmSelect) MethodIdentifier() uint16 {
	return 10
}

// Sync is method should me sent synchronous
func (method *ConfirmSelect) Sync() bool {
	return true
}

// Read method from io reader
func (method *ConfirmSelect) Read(reader io.Reader, protoVersion string) (err error) {

	bits, err := ReadOctet(reader)
	if err != nil {
		return err
	}

	method.Nowait = bits&(1<<0) != 0

	return
}

// Write method from io reader
func (method *ConfirmSelect) Write(writer io.Writer, protoVersion string) (err error) {

	var bits byte

	if method.Nowait {
		bits |= 1 << 0
	}

	if err = WriteOctet(writer, bits); err != nil {
		return err
	}

	return
}

// ConfirmSelectOk This method confirms to the client that the channel was successfully
// set to use publisher acknowledgements.
type ConfirmSelectOk struct {
}

// Name returns method name as string, usefully for logging
func (method *ConfirmSelectOk) Name() string {
	return "ConfirmSelectOk"
}

// FrameType returns method frame type
func (method *ConfirmSelectOk) FrameType() byte {
	return 1
}

// ClassIdentifier returns method classID
func (method *ConfirmSelectOk) ClassIdentifier() uint16 {
	return 85
}

// MethodIdentifier returns method methodID
func (method *ConfirmSelectOk) MethodIdentifier() uint16 {
	return 11
}

// Sync is method should me sent synchronous
func (method *ConfirmSelectOk) Sync() bool {
	return true
}

// Read method from io reader
func (method *ConfirmSelectOk) Read(reader io.Reader, protoVersion string) (err error) {

	return
}

// Write method from io reader
func (method *ConfirmSelectOk) Write(writer io.Writer, protoVersion string) (err error) {

	return
}

/*
ReadMethod reads method from frame's payload

Method frames carry the high-level protocol commands (which we call "methods").
One method frame carries one command.  The method frame payload has this format:

	0          2           4
	+----------+-----------+-------------- - -
	| class-id | method-id | arguments...
	+----------+-----------+-------------- - -
	   short      short    ...
*/
func ReadMethod(reader io.Reader, protoVersion string) (Method, error) {
	classID, err := ReadShort(reader)
	if err != nil {
		return nil, err
	}

	methodID, err := ReadShort(reader)
	if err != nil {
		return nil, err
	}
	switch classID {

	case 10:
		switch methodID {

		case 10:
			var method = &ConnectionStart{}
			if err := method.Read(reader, protoVersion); err != nil {
				return nil, err
			}
			return method, nil
		case 11:
			var method = &ConnectionStartOk{}
			if err := method.Read(reader, protoVersion); err != nil {
				return nil, err
			}
			return method, nil
		case 20:
			var method = &ConnectionSecure{}
			if err := method.Read(reader, protoVersion); err != nil {
				return nil, err
			}
			return method, nil
		case 21:
			var method = &ConnectionSecureOk{}
			if err := method.Read(reader, protoVersion); err != nil {
				return nil, err
			}
			return method, nil
		case 30:
			var method = &ConnectionTune{}
			if err := method.Read(reader, protoVersion); err != nil {
				return nil, err
			}
			return method, nil
		case 31:
			var method = &ConnectionTuneOk{}
			if err := method.Read(reader, protoVersion); err != nil {
				return nil, err
			}
			return method, nil
		case 40:
			var method = &ConnectionOpen{}
			if err := method.Read(reader, protoVersion); err != nil {
				return nil, err
			}
			return method, nil
		case 41:
			var method = &ConnectionOpenOk{}
			if err := method.Read(reader, protoVersion); err != nil {
				return nil, err
			}
			return method, nil
		case 50:
			var method = &ConnectionClose{}
			if err := method.Read(reader, protoVersion); err != nil {
				return nil, err
			}
			return method, nil
		case 51:
			var method = &ConnectionCloseOk{}
			if err := method.Read(reader, protoVersion); err != nil {
				return nil, err
			}
			return method, nil
		case 60:
			var method = &ConnectionBlocked{}
			if err := method.Read(reader, protoVersion); err != nil {
				return nil, err
			}
			return method, nil
		case 61:
			var method = &ConnectionUnblocked{}
			if err := method.Read(reader, protoVersion); err != nil {
				return nil, err
			}
			return method, nil
		}
	case 20:
		switch methodID {

		case 10:
			var method = &ChannelOpen{}
			if err := method.Read(reader, protoVersion); err != nil {
				return nil, err
			}
			return method, nil
		case 11:
			var method = &ChannelOpenOk{}
			if err := method.Read(reader, protoVersion); err != nil {
				return nil, err
			}
			return method, nil
		case 20:
			var method = &ChannelFlow{}
			if err := method.Read(reader, protoVersion); err != nil {
				return nil, err
			}
			return method, nil
		case 21:
			var method = &ChannelFlowOk{}
			if err := method.Read(reader, protoVersion); err != nil {
				return nil, err
			}
			return method, nil
		case 40:
			var method = &ChannelClose{}
			if err := method.Read(reader, protoVersion); err != nil {
				return nil, err
			}
			return method, nil
		case 41:
			var method = &ChannelCloseOk{}
			if err := method.Read(reader, protoVersion); err != nil {
				return nil, err
			}
			return method, nil
		}
	case 40:
		switch methodID {

		case 10:
			var method = &ExchangeDeclare{}
			if err := method.Read(reader, protoVersion); err != nil {
				return nil, err
			}
			return method, nil
		case 11:
			var method = &ExchangeDeclareOk{}
			if err := method.Read(reader, protoVersion); err != nil {
				return nil, err
			}
			return method, nil
		case 20:
			var method = &ExchangeDelete{}
			if err := method.Read(reader, protoVersion); err != nil {
				return nil, err
			}
			return method, nil
		case 21:
			var method = &ExchangeDeleteOk{}
			if err := method.Read(reader, protoVersion); err != nil {
				return nil, err
			}
			return method, nil
		case 30:
			var method = &ExchangeBind{}
			if err := method.Read(reader, protoVersion); err != nil {
				return nil, err
			}
			return method, nil
		case 31:
			var method = &ExchangeBindOk{}
			if err := method.Read(reader, protoVersion); err != nil {
				return nil, err
			}
			return method, nil
		case 40:
			var method = &ExchangeUnbind{}
			if err := method.Read(reader, protoVersion); err != nil {
				return nil, err
			}
			return method, nil
		case 51:
			var method = &ExchangeUnbindOk{}
			if err := method.Read(reader, protoVersion); err != nil {
				return nil, err
			}
			return method, nil
		}
	case 50:
		switch methodID {

		case 10:
			var method = &QueueDeclare{}
			if err := method.Read(reader, protoVersion); err != nil {
				return nil, err
			}
			return method, nil
		case 11:
			var method = &QueueDeclareOk{}
			if err := method.Read(reader, protoVersion); err != nil {
				return nil, err
			}
			return method, nil
		case 20:
			var method = &QueueBind{}
			if err := method.Read(reader, protoVersion); err != nil {
				return nil, err
			}
			return method, nil
		case 21:
			var method = &QueueBindOk{}
			if err := method.Read(reader, protoVersion); err != nil {
				return nil, err
			}
			return method, nil
		case 50:
			var method = &QueueUnbind{}
			if err := method.Read(reader, protoVersion); err != nil {
				return nil, err
			}
			return method, nil
		case 51:
			var method = &QueueUnbindOk{}
			if err := method.Read(reader, protoVersion); err != nil {
				return nil, err
			}
			return method, nil
		case 30:
			var method = &QueuePurge{}
			if err := method.Read(reader, protoVersion); err != nil {
				return nil, err
			}
			return method, nil
		case 31:
			var method = &QueuePurgeOk{}
			if err := method.Read(reader, protoVersion); err != nil {
				return nil, err
			}
			return method, nil
		case 40:
			var method = &QueueDelete{}
			if err := method.Read(reader, protoVersion); err != nil {
				return nil, err
			}
			return method, nil
		case 41:
			var method = &QueueDeleteOk{}
			if err := method.Read(reader, protoVersion); err != nil {
				return nil, err
			}
			return method, nil
		}
	case 60:
		switch methodID {

		case 10:
			var method = &BasicQos{}
			if err := method.Read(reader, protoVersion); err != nil {
				return nil, err
			}
			return method, nil
		case 11:
			var method = &BasicQosOk{}
			if err := method.Read(reader, protoVersion); err != nil {
				return nil, err
			}
			return method, nil
		case 20:
			var method = &BasicConsume{}
			if err := method.Read(reader, protoVersion); err != nil {
				return nil, err
			}
			return method, nil
		case 21:
			var method = &BasicConsumeOk{}
			if err := method.Read(reader, protoVersion); err != nil {
				return nil, err
			}
			return method, nil
		case 30:
			var method = &BasicCancel{}
			if err := method.Read(reader, protoVersion); err != nil {
				return nil, err
			}
			return method, nil
		case 31:
			var method = &BasicCancelOk{}
			if err := method.Read(reader, protoVersion); err != nil {
				return nil, err
			}
			return method, nil
		case 40:
			var method = &BasicPublish{}
			if err := method.Read(reader, protoVersion); err != nil {
				return nil, err
			}
			return method, nil
		case 50:
			var method = &BasicReturn{}
			if err := method.Read(reader, protoVersion); err != nil {
				return nil, err
			}
			return method, nil
		case 60:
			var method = &BasicDeliver{}
			if err := method.Read(reader, protoVersion); err != nil {
				return nil, err
			}
			return method, nil
		case 70:
			var method = &BasicGet{}
			if err := method.Read(reader, protoVersion); err != nil {
				return nil, err
			}
			return method, nil
		case 71:
			var method = &BasicGetOk{}
			if err := method.Read(reader, protoVersion); err != nil {
				return nil, err
			}
			return method, nil
		case 72:
			var method = &BasicGetEmpty{}
			if err := method.Read(reader, protoVersion); err != nil {
				return nil, err
			}
			return method, nil
		case 80:
			var method = &BasicAck{}
			if err := method.Read(reader, protoVersion); err != nil {
				return nil, err
			}
			return method, nil
		case 90:
			var method = &BasicReject{}
			if err := method.Read(reader, protoVersion); err != nil {
				return nil, err
			}
			return method, nil
		case 100:
			var method = &BasicRecoverAsync{}
			if err := method.Read(reader, protoVersion); err != nil {
				return nil, err
			}
			return method, nil
		case 110:
			var method = &BasicRecover{}
			if err := method.Read(reader, protoVersion); err != nil {
				return nil, err
			}
			return method, nil
		case 111:
			var method = &BasicRecoverOk{}
			if err := method.Read(reader, protoVersion); err != nil {
				return nil, err
			}
			return method, nil
		case 120:
			var method = &BasicNack{}
			if err := method.Read(reader, protoVersion); err != nil {
				return nil, err
			}
			return method, nil
		}
	case 90:
		switch methodID {

		case 10:
			var method = &TxSelect{}
			if err := method.Read(reader, protoVersion); err != nil {
				return nil, err
			}
			return method, nil
		case 11:
			var method = &TxSelectOk{}
			if err := method.Read(reader, protoVersion); err != nil {
				return nil, err
			}
			return method, nil
		case 20:
			var method = &TxCommit{}
			if err := method.Read(reader, protoVersion); err != nil {
				return nil, err
			}
			return method, nil
		case 21:
			var method = &TxCommitOk{}
			if err := method.Read(reader, protoVersion); err != nil {
				return nil, err
			}
			return method, nil
		case 30:
			var method = &TxRollback{}
			if err := method.Read(reader, protoVersion); err != nil {
				return nil, err
			}
			return method, nil
		case 31:
			var method = &TxRollbackOk{}
			if err := method.Read(reader, protoVersion); err != nil {
				return nil, err
			}
			return method, nil
		}
	case 85:
		switch methodID {

		case 10:
			var method = &ConfirmSelect{}
			if err := method.Read(reader, protoVersion); err != nil {
				return nil, err
			}
			return method, nil
		case 11:
			var method = &ConfirmSelectOk{}
			if err := method.Read(reader, protoVersion); err != nil {
				return nil, err
			}
			return method, nil
		}
	}

	return nil, fmt.Errorf("unknown classID and methodID: [%d. %d]", classID, methodID)
}

// WriteMethod writes method into frame's payload
func WriteMethod(writer io.Writer, method Method, protoVersion string) (err error) {
	if err = WriteShort(writer, method.ClassIdentifier()); err != nil {
		return err
	}
	if err = WriteShort(writer, method.MethodIdentifier()); err != nil {
		return err
	}

	if err = method.Write(writer, protoVersion); err != nil {
		return err
	}

	return
}

```

`pkg/outputs/amqp/_fixtures/garagemq/amqp/readers_writers.go`:

```go
package amqp

import (
	"bytes"
	"encoding/binary"
	"errors"
	"fmt"
	"github.com/rabbitstack/fibratus/pkg/outputs/amqp/_fixtures/garagemq/pool"
	"io"
	"time"
)

var emptyBufferPool = pool.NewBufferPool(0)

// 14 bytes for class-id | weight | body size | property flags
var headerBufferPool = pool.NewBufferPool(14)

// AmqpHeader standard AMQP header
var AmqpHeader = []byte{'A', 'M', 'Q', 'P', 0, 0, 9, 1}

// supported protocol identifiers
const (
	Proto091    = "amqp-0-9-1"
	ProtoRabbit = "amqp-rabbit"
)

func writeSlice(wr io.Writer, data []byte) error {
	_, err := wr.Write(data[:])
	return err
}

/*
ReadFrame reads and parses raw data from conn reader and returns amqp frame

@spec-note
All frames consist of a header (7 octets), a payload of arbitrary size, and a
'frame-end' octet that detects malformed frames:

	0      1         3             7                  size+7 size+8
	+------+---------+-------------+  +------------+  +-----------+
	| type | channel |     size    |  |  payload   |  | frame-end |
	+------+---------+-------------+  +------------+  +-----------+
	 octet   short         long         size octets       octet

To read a frame, we:
 1. Read the header and check the frame type and channel.
 2. Depending on the frame size, we read the payload
 3. Read the frame-end octet.
*/
func ReadFrame(r io.Reader) (frame *Frame, err error) {
	// It does not matter that we call read methods 3 time
	// Because net.TCPConn connection buffered by bufio.NewReader
	frame = &Frame{}
	if frame.Type, err = ReadOctet(r); err != nil {
		return nil, err
	}
	if frame.ChannelID, err = ReadShort(r); err != nil {
		return nil, err
	}
	var payloadSize uint32
	if payloadSize, err = ReadLong(r); err != nil {
		return nil, err
	}

	var payload = make([]byte, payloadSize+1)
	if _, err := io.ReadFull(r, payload); err != nil {
		return nil, err
	}
	frame.Payload = payload[0:payloadSize]

	// check frame end
	if payload[payloadSize] != FrameEnd {
		return nil, fmt.Errorf(
			"the frame-end octet MUST always be the hexadecimal value 'xCE', %x given",
			payload[payloadSize])
	}

	return frame, nil
}

// WriteFrame pack amqp Frame as bytes and write to conn writer
func WriteFrame(wr io.Writer, frame *Frame) (err error) {
	if err = WriteOctet(wr, frame.Type); err != nil {
		return err
	}
	if err = WriteShort(wr, frame.ChannelID); err != nil {
		return err
	}

	// size + payload
	if err = WriteLongstr(wr, frame.Payload); err != nil {
		return err
	}
	// frame end
	if err = WriteOctet(wr, FrameEnd); err != nil {
		return err
	}

	return nil
}

// ReadOctet reads octet (byte)
func ReadOctet(r io.Reader) (data byte, err error) {
	var b [1]byte
	if _, err = io.ReadFull(r, b[:]); err != nil {
		return
	}
	data = b[0]
	return
}

// WriteOctet writes octet (byte)
func WriteOctet(wr io.Writer, data byte) error {
	var b [1]byte
	b[0] = data
	return writeSlice(wr, b[:])
}

// ReadShort reads 2 bytes
func ReadShort(r io.Reader) (data uint16, err error) {
	err = binary.Read(r, binary.BigEndian, &data)
	return
}

// WriteShort writes 2 bytes
func WriteShort(wr io.Writer, data uint16) error {
	var b [2]byte
	binary.BigEndian.PutUint16(b[:], data)
	return writeSlice(wr, b[:])
}

// ReadLong reads 4 bytes
func ReadLong(r io.Reader) (data uint32, err error) {
	err = binary.Read(r, binary.BigEndian, &data)
	return
}

// WriteLong writes 4 bytes
func WriteLong(wr io.Writer, data uint32) error {
	var b [4]byte
	binary.BigEndian.PutUint32(b[:], data)
	return writeSlice(wr, b[:])
}

// ReadLonglong reads 8 bytes
func ReadLonglong(r io.Reader) (data uint64, err error) {
	err = binary.Read(r, binary.BigEndian, &data)
	return
}

// WriteLonglong writes 8 bytes
func WriteLonglong(wr io.Writer, data uint64) error {
	var b [8]byte
	binary.BigEndian.PutUint64(b[:], data)
	return writeSlice(wr, b[:])
}

// ReadTimestamp reads timestamp
// amqp presents timestamp as 8byte int
func ReadTimestamp(r io.Reader) (data time.Time, err error) {
	var seconds uint64
	if seconds, err = ReadLonglong(r); err != nil {
		return
	}
	return time.Unix(int64(seconds), 0), nil
}

// WriteTimestamp writes timestamp
func WriteTimestamp(wr io.Writer, data time.Time) error {
	return WriteLonglong(wr, uint64(data.Unix()))
}

// ReadShortstr reads string
func ReadShortstr(r io.Reader) (data string, err error) {
	var length byte

	length, err = ReadOctet(r)
	if err != nil {
		return "", err
	}

	strBytes := make([]byte, length)

	_, err = io.ReadFull(r, strBytes)
	if err != nil {
		return "", err
	}
	data = string(strBytes)
	return
}

// WriteShortstr writes string
func WriteShortstr(wr io.Writer, data string) error {
	if err := WriteOctet(wr, byte(len(data))); err != nil {
		return err
	}
	if _, err := wr.Write([]byte(data)); err != nil {
		return err
	}

	return nil
}

// ReadLongstr reads long string
// Long string is just array of bytes
func ReadLongstr(r io.Reader) (data []byte, err error) {
	var length uint32

	length, err = ReadLong(r)
	if err != nil {
		return nil, err
	}

	data = make([]byte, length)

	_, err = io.ReadFull(r, data)
	if err != nil {
		return nil, err
	}
	return
}

// WriteLongstr writes long string
func WriteLongstr(wr io.Writer, data []byte) error {
	err := WriteLong(wr, uint32(len(data)))
	if err != nil {
		return err
	}
	_, err = wr.Write(data)
	if err != nil {
		return err
	}
	return nil
}

// ReadTable reads amqp table
// Standard amqp table and rabbitmq table are little different
// So we have second argument protoVersion to handle that issue
func ReadTable(r io.Reader, protoVersion string) (data *Table, err error) {
	tmpData := Table{}
	tableData, err := ReadLongstr(r)
	if err != nil {
		return nil, err
	}

	tableReader := bytes.NewReader(tableData)
	for tableReader.Len() > 0 {
		var key string
		var value interface{}
		if key, err = ReadShortstr(tableReader); err != nil {
			return nil, errors.New("Unable to read key from table: " + err.Error())
		}

		if value, err = readV(tableReader, protoVersion); err != nil {
			return nil, errors.New("Unable to read value from table: " + err.Error())
		}

		tmpData[key] = value
	}

	return &tmpData, nil
}

func readV(r io.Reader, protoVersion string) (data interface{}, err error) {
	switch protoVersion {
	case Proto091:
		return readValue091(r)
	case ProtoRabbit:
		return readValueRabbit(r)
	}

	return nil, fmt.Errorf("unknown proto version [%s]", protoVersion)
}

/*
Standard amqp-0-9-1 table fields

't' bool			boolean
'b' int8			short-short-int
'B' uint8			short-short-uint
'U' int16			short-int
'u' uint16			short-uint
'I' int32			long-int
'i' uint32			long-uint
'L' int64			long-long-int
'l' uint64			long-long-uint
'f' float			float
'd' double			double
'D' Decimal			decimal-value
's' string			short-string
'S'	[]byte			long-string
'A' []interface{} 	field-array
'T' time.Time		timestamp
'F' Table			field-table
'V' nil				no-field
*/
func readValue091(r io.Reader) (data interface{}, err error) {
	vType, err := ReadOctet(r)
	if err != nil {
		return nil, err
	}

	switch vType {
	case 't':
		var rData byte
		rData, err = ReadOctet(r)
		if err != nil {
			return nil, err
		}
		return rData != 0, nil
	case 'b':
		var rData int8
		if err = binary.Read(r, binary.BigEndian, &rData); err != nil {
			return nil, err
		}
		return rData, nil
	case 'B':
		var rData uint8
		if err = binary.Read(r, binary.BigEndian, &rData); err != nil {
			return nil, err
		}
		return rData, nil
	case 'U':
		var rData int16
		if err = binary.Read(r, binary.BigEndian, &rData); err != nil {
			return nil, err
		}
		return rData, nil
	case 'u':
		var rData uint16
		if err = binary.Read(r, binary.BigEndian, &rData); err != nil {
			return nil, err
		}
		return rData, nil
	case 'I':
		var rData int32
		if err = binary.Read(r, binary.BigEndian, &rData); err != nil {
			return nil, err
		}
		return rData, nil
	case 'i':
		var rData uint32
		if err = binary.Read(r, binary.BigEndian, &rData); err != nil {
			return nil, err
		}
		return rData, nil
	case 'L':
		var rData int64
		if err = binary.Read(r, binary.BigEndian, &rData); err != nil {
			return nil, err
		}
		return rData, nil
	case 'l':
		var rData uint64
		if err = binary.Read(r, binary.BigEndian, &rData); err != nil {
			return nil, err
		}
		return rData, nil
	case 'f':
		var rData float32
		if err = binary.Read(r, binary.BigEndian, &rData); err != nil {
			return nil, err
		}
		return rData, nil
	case 'd':
		var rData float64
		if err = binary.Read(r, binary.BigEndian, &rData); err != nil {
			return nil, err
		}
		return rData, nil
	case 'D':
		var rData = Decimal{0, 0}

		if err = binary.Read(r, binary.BigEndian, &rData.Scale); err != nil {
			return nil, err
		}
		if err = binary.Read(r, binary.BigEndian, &rData.Value); err != nil {
			return nil, err
		}
		return rData, nil
	case 's':
		var rData string
		if rData, err = ReadShortstr(r); err == nil {
			return nil, err
		}

		return rData, nil
	case 'S':
		var rData []byte
		if rData, err = ReadLongstr(r); err == nil {
			return nil, err
		}

		return rData, nil
	case 'T':
		var rData time.Time
		if rData, err = ReadTimestamp(r); err == nil {
			return nil, err
		}

		return rData, nil
	case 'A':
		var rData []interface{}
		if rData, err = readArray(r, Proto091); err == nil {
			return nil, err
		}
		return rData, nil
	case 'F':
		var rData *Table
		if rData, err = ReadTable(r, Proto091); err == nil {
			return nil, err
		}
		return rData, nil
	case 'V':
		return nil, nil
	}

	return nil, fmt.Errorf("unsupported type %c (%d) by %s protocol", vType, vType, Proto091)
}

/*
Rabbitmq table fields

't' bool			boolean
'b' int8			short-short-int
's'	int16			short-int
'I' int32			long-int
'l' int64			long-long-int
'f' float			float
'd' double			double
'D' Decimal			decimal-value
'S'	[]byte			long-string
'T' time.Time		timestamp
'F' Table			field-table
'V' nil				no-field
'x' []interface{} 	field-array
*/
func readValueRabbit(r io.Reader) (data interface{}, err error) {
	vType, err := ReadOctet(r)
	if err != nil {
		return nil, err
	}

	switch vType {
	case 't':
		var rData byte
		rData, err = ReadOctet(r)
		if err != nil {
			return nil, err
		}
		return rData != 0, nil
	case 'b':
		var rData int8
		if err = binary.Read(r, binary.BigEndian, &rData); err != nil {
			return nil, err
		}
		return rData, nil
	case 's':
		var rData int16
		if err = binary.Read(r, binary.BigEndian, &rData); err != nil {
			return nil, err
		}
		return rData, nil
	case 'I':
		var rData int32
		if err = binary.Read(r, binary.BigEndian, &rData); err != nil {
			return nil, err
		}
		return rData, nil
	case 'l':
		var rData int64
		if err = binary.Read(r, binary.BigEndian, &rData); err != nil {
			return nil, err
		}
		return rData, nil
	case 'f':
		var rData float32
		if err = binary.Read(r, binary.BigEndian, &rData); err != nil {
			return nil, err
		}
		return rData, nil
	case 'd':
		var rData float64
		if err = binary.Read(r, binary.BigEndian, &rData); err != nil {
			return nil, err
		}
		return rData, nil
	case 'D':
		var rData = Decimal{0, 0}

		if err = binary.Read(r, binary.BigEndian, &rData.Scale); err != nil {
			return nil, err
		}
		if err = binary.Read(r, binary.BigEndian, &rData.Value); err != nil {
			return nil, err
		}
		return rData, nil
	case 'S':
		var rData []byte
		if rData, err = ReadLongstr(r); err != nil {
			return nil, err
		}

		return string(rData), nil
	case 'T':
		var rData time.Time
		if rData, err = ReadTimestamp(r); err != nil {
			return nil, err
		}

		return rData, nil
	case 'x':
		var rData []interface{}
		if rData, err = readArray(r, ProtoRabbit); err != nil {
			return nil, err
		}
		return rData, nil
	case 'F':
		var rData *Table
		if rData, err = ReadTable(r, ProtoRabbit); err != nil {
			return nil, err
		}
		return rData, nil
	case 'V':
		return nil, nil
	}

	return nil, fmt.Errorf("unsupported type %c (%d) by %s protocol", vType, vType, ProtoRabbit)
}

// WriteTable writes amqp table
// Standard amqp table and rabbitmq table are little different
// So we have second argument protoVersion to handle that issue
func WriteTable(writer io.Writer, table *Table, protoVersion string) (err error) {
	var buf = emptyBufferPool.Get()
	defer emptyBufferPool.Put(buf)
	for key, v := range *table {
		if err := WriteShortstr(buf, key); err != nil {
			return err
		}
		if err := writeV(buf, v, protoVersion); err != nil {
			return err
		}
	}
	return WriteLongstr(writer, buf.Bytes())
}

func writeV(writer io.Writer, v interface{}, protoVersion string) (err error) {
	switch protoVersion {
	case Proto091:
		return writeValue091(writer, v)
	case ProtoRabbit:
		return writeValueRabbit(writer, v)
	}

	return fmt.Errorf("unknown proto version [%s]", protoVersion)
}

/*
Standard amqp-0-9-1 table fields

't' bool			boolean
'b' int8			short-short-int
'B' uint8			short-short-uint
'U' int16			short-int
'u' uint16			short-uint
'I' int32			long-int
'i' uint32			long-uint
'L' int64			long-long-int
'l' uint64			long-long-uint
'f' float			float
'd' double			double
'D' Decimal			decimal-value
's' string			short-string
'S'	[]byte			long-string
'A' []interface{} 	field-array
'T' time.Time		timestamp
'F' Table			field-table
'V' nil				no-field
*/
func writeValue091(writer io.Writer, v interface{}) (err error) {
	switch value := v.(type) {
	case bool:
		if err = WriteOctet(writer, byte('t')); err == nil {
			if value {
				err = binary.Write(writer, binary.BigEndian, uint8(1))
			} else {
				err = binary.Write(writer, binary.BigEndian, uint8(0))
			}
		}
	case int8:
		if err = WriteOctet(writer, byte('b')); err == nil {
			err = binary.Write(writer, binary.BigEndian, value)
		}
	case uint8:
		if err = WriteOctet(writer, byte('B')); err == nil {
			err = binary.Write(writer, binary.BigEndian, value)
		}
	case int16:
		if err = WriteOctet(writer, byte('U')); err == nil {
			err = binary.Write(writer, binary.BigEndian, value)
		}
	case uint16:
		if err = binary.Write(writer, binary.BigEndian, byte('u')); err == nil {
			err = binary.Write(writer, binary.BigEndian, value)
		}
	case int32:
		if err = binary.Write(writer, binary.BigEndian, byte('I')); err == nil {
			err = binary.Write(writer, binary.BigEndian, value)
		}
	case uint32:
		if err = binary.Write(writer, binary.BigEndian, byte('i')); err == nil {
			err = binary.Write(writer, binary.BigEndian, value)
		}
	case int64:
		if err = binary.Write(writer, binary.BigEndian, byte('L')); err == nil {
			err = binary.Write(writer, binary.BigEndian, value)
		}
	case uint64:
		if err = binary.Write(writer, binary.BigEndian, byte('l')); err == nil {
			err = binary.Write(writer, binary.BigEndian, value)
		}
	case float32:
		if err = binary.Write(writer, binary.BigEndian, byte('f')); err == nil {
			err = binary.Write(writer, binary.BigEndian, value)
		}
	case float64:
		if err = binary.Write(writer, binary.BigEndian, byte('d')); err == nil {
			err = binary.Write(writer, binary.BigEndian, value)
		}
	case Decimal:
		if err = binary.Write(writer, binary.BigEndian, byte('D')); err == nil {
			if err = binary.Write(writer, binary.BigEndian, byte(value.Scale)); err == nil {
				err = binary.Write(writer, binary.BigEndian, uint32(value.Value))
			}
		}
	case string:
		if err = WriteOctet(writer, byte('s')); err == nil {
			err = WriteShortstr(writer, value)
		}
	case []byte:
		if err = WriteOctet(writer, byte('S')); err == nil {
			err = WriteLongstr(writer, value)
		}
	case time.Time:
		if err = WriteOctet(writer, byte('T')); err == nil {
			err = WriteTimestamp(writer, value)
		}
	case []interface{}:
		if err = WriteOctet(writer, byte('A')); err == nil {
			err = writeArray(writer, value, Proto091)
		}

	case Table:
		if err = WriteOctet(writer, byte('F')); err == nil {
			err = WriteTable(writer, &value, Proto091)
		}
	case nil:
		err = binary.Write(writer, binary.BigEndian, byte('V'))
	default:
		err = fmt.Errorf("unsupported type by %s protocol", Proto091)
	}

	return
}

/*
Rabbitmq table fields

't' bool			boolean
'b' int8			short-short-int
's'	int16			short-int
'I' int32			long-int
'l' int64			long-long-int
'f' float			float
'd' double			double
'D' Decimal			decimal-value
'S'	[]byte			long-string
'T' time.Time		timestamp
'F' Table			field-table
'V' nil				no-field
'x' []interface{} 	field-array
*/
func writeValueRabbit(writer io.Writer, v interface{}) (err error) {
	switch value := v.(type) {
	case bool:
		if err = WriteOctet(writer, byte('t')); err == nil {
			if value {
				err = binary.Write(writer, binary.BigEndian, uint8(1))
			} else {
				err = binary.Write(writer, binary.BigEndian, uint8(0))
			}
		}
	case int8:
		if err = WriteOctet(writer, byte('b')); err == nil {
			err = binary.Write(writer, binary.BigEndian, value)
		}
	case uint8:
		if err = WriteOctet(writer, byte('b')); err == nil {
			err = binary.Write(writer, binary.BigEndian, int8(value))
		}
	case int16:
		if err = WriteOctet(writer, byte('s')); err == nil {
			err = binary.Write(writer, binary.BigEndian, value)
		}
	case uint16:
		if err = binary.Write(writer, binary.BigEndian, byte('s')); err == nil {
			err = binary.Write(writer, binary.BigEndian, int16(value))
		}
	case int32:
		if err = binary.Write(writer, binary.BigEndian, byte('I')); err == nil {
			err = binary.Write(writer, binary.BigEndian, value)
		}
	case uint32:
		if err = binary.Write(writer, binary.BigEndian, byte('I')); err == nil {
			err = binary.Write(writer, binary.BigEndian, int32(value))
		}
	case int64:
		if err = binary.Write(writer, binary.BigEndian, byte('l')); err == nil {
			err = binary.Write(writer, binary.BigEndian, value)
		}
	case uint64:
		if err = binary.Write(writer, binary.BigEndian, byte('l')); err == nil {
			err = binary.Write(writer, binary.BigEndian, int64(value))
		}
	case float32:
		if err = binary.Write(writer, binary.BigEndian, byte('f')); err == nil {
			err = binary.Write(writer, binary.BigEndian, value)
		}
	case float64:
		if err = binary.Write(writer, binary.BigEndian, byte('d')); err == nil {
			err = binary.Write(writer, binary.BigEndian, value)
		}
	case Decimal:
		if err = binary.Write(writer, binary.BigEndian, byte('D')); err == nil {
			if err = binary.Write(writer, binary.BigEndian, byte(value.Scale)); err == nil {
				err = binary.Write(writer, binary.BigEndian, uint32(value.Value))
			}
		}
	case []byte:
		if err = WriteOctet(writer, byte('S')); err == nil {
			err = WriteLongstr(writer, value)
		}
	case string:
		if err = WriteOctet(writer, byte('S')); err == nil {
			err = WriteLongstr(writer, []byte(value))
		}
	case time.Time:
		if err = WriteOctet(writer, byte('T')); err == nil {
			err = WriteTimestamp(writer, value)
		}
	case []interface{}:
		if err = WriteOctet(writer, byte('x')); err == nil {
			err = writeArray(writer, value, ProtoRabbit)
		}
	case Table:
		if err = WriteOctet(writer, byte('F')); err == nil {
			err = WriteTable(writer, &value, ProtoRabbit)
		}
	case nil:
		err = binary.Write(writer, binary.BigEndian, byte('V'))
	default:
		err = fmt.Errorf("unsupported type by %s protocol", Proto091)
	}

	return
}

func writeArray(writer io.Writer, array []interface{}, protoVersion string) error {
	var buf = emptyBufferPool.Get()
	defer emptyBufferPool.Put(buf)

	for _, v := range array {
		if err := writeV(buf, v, protoVersion); err != nil {
			return err
		}
	}
	return WriteLongstr(writer, buf.Bytes())
}

func readArray(r io.Reader, protoVersion string) (data []interface{}, err error) {
	data = make([]interface{}, 0)
	var arrayData []byte
	if arrayData, err = ReadLongstr(r); err != nil {
		return nil, err
	}

	arrayBuffer := bytes.NewBuffer(arrayData)
	for arrayBuffer.Len() > 0 {
		var itemV interface{}
		if itemV, err = readV(arrayBuffer, protoVersion); err != nil {
			return nil, err
		}

		data = append(data, itemV)
	}

	return data, nil
}

/*
ReadContentHeader reads amqp content header

Certain methods (such as Basic.Publish, Basic.Deliver, etc.) are formally
defined as carrying content.  When a peer sends such a method frame, it always
follows it with a content header and zero or more content body frames.

A content header frame has this format:

	0          2        4           12               14
	+----------+--------+-----------+----------------+------------- - -
	| class-id | weight | body size | property flags | property list...
	+----------+--------+-----------+----------------+------------- - -
	  short     short    long long       short        remainder...
*/
func ReadContentHeader(r io.Reader, protoVersion string) (*ContentHeader, error) {
	var err error
	// 14 bytes for class-id | weight | body size | property flags
	headerBuf := headerBufferPool.Get()
	defer headerBufferPool.Put(headerBuf)

	var header [14]byte
	if _, err = io.ReadFull(r, header[:]); err != nil {
		return nil, err
	}
	if _, err = headerBuf.Write(header[:]); err != nil {
		return nil, err
	}

	contentHeader := &ContentHeader{}

	if contentHeader.ClassID, err = ReadShort(headerBuf); err != nil {
		return nil, err
	}
	if contentHeader.Weight, err = ReadShort(headerBuf); err != nil {
		return nil, err
	}
	if contentHeader.BodySize, err = ReadLonglong(headerBuf); err != nil {
		return nil, err
	}
	if contentHeader.propertyFlags, err = ReadShort(headerBuf); err != nil {
		return nil, err
	}

	contentHeader.PropertyList = &BasicPropertyList{}
	if err = contentHeader.PropertyList.Read(r, contentHeader.propertyFlags, protoVersion); err != nil {
		return nil, err
	}

	return contentHeader, nil
}

// WriteContentHeader writes amqp content header
func WriteContentHeader(writer io.Writer, header *ContentHeader, protoVersion string) (err error) {
	if err = WriteShort(writer, header.ClassID); err != nil {
		return err
	}
	if err = WriteShort(writer, header.Weight); err != nil {
		return err
	}
	if err = WriteLonglong(writer, header.BodySize); err != nil {
		return err
	}

	var propertyBuf = emptyBufferPool.Get()
	defer emptyBufferPool.Put(propertyBuf)

	properyFlags, err := header.PropertyList.Write(propertyBuf, protoVersion)
	if err != nil {
		return err
	}

	header.propertyFlags = properyFlags
	if err = WriteShort(writer, header.propertyFlags); err != nil {
		return err
	}
	if _, err = writer.Write(propertyBuf.Bytes()); err != nil {
		return err
	}

	return
}

```

`pkg/outputs/amqp/_fixtures/garagemq/amqp/types.go`:

```go
package amqp

import (
	"bytes"
	"github.com/rabbitstack/fibratus/pkg/outputs/amqp/_fixtures/garagemq/pool"
	"sync/atomic"
	"time"
)

var emptyMessageBufferPool = pool.NewBufferPool(0)

// Table - simple amqp-table implementation
type Table map[string]interface{}

// Decimal represents amqp-decimal data
type Decimal struct {
	Scale uint8
	Value int32
}

// Frame is raw frame
type Frame struct {
	ChannelID  uint16
	Type       byte
	CloseAfter bool
	Sync       bool
	Payload    []byte
}

// ContentHeader represents amqp-message content-header
type ContentHeader struct {
	BodySize      uint64
	ClassID       uint16
	Weight        uint16
	propertyFlags uint16
	PropertyList  *BasicPropertyList
}

// ConfirmMeta store information for check confirms and send confirm-acks
type ConfirmMeta struct {
	ChanID           uint16
	ConnID           uint64
	DeliveryTag      uint64
	ExpectedConfirms int
	ActualConfirms   int
}

// CanConfirm returns is message can be confirmed
func (meta *ConfirmMeta) CanConfirm() bool {
	return meta.ActualConfirms == meta.ExpectedConfirms
}

// Message represents amqp-message and meta-data
type Message struct {
	ID            uint64
	BodySize      uint64
	DeliveryCount uint32
	Mandatory     bool
	Immediate     bool
	Exchange      string
	RoutingKey    string
	ConfirmMeta   *ConfirmMeta
	Header        *ContentHeader
	Body          []*Frame
}

// when server restart we can't start again count messages from 0
var msgID = uint64(time.Now().UnixNano())

// NewMessage returns new message instance
func NewMessage(method *BasicPublish) *Message {
	return &Message{
		Exchange:      method.Exchange,
		RoutingKey:    method.RoutingKey,
		Mandatory:     method.Mandatory,
		Immediate:     method.Immediate,
		BodySize:      0,
		DeliveryCount: 0,
	}
}

// IsPersistent check if message should be persisted
func (m *Message) IsPersistent() bool {
	deliveryMode := m.Header.PropertyList.DeliveryMode
	return deliveryMode != nil && *deliveryMode == 2
}

// GenerateSeq returns next message ID
func (m *Message) GenerateSeq() {
	if m.ID == 0 {
		m.ID = atomic.AddUint64(&msgID, 1)
	}
}

// Append appends new body-frame into message and increase bodySize
func (m *Message) Append(body *Frame) {
	m.Body = append(m.Body, body)
	m.BodySize += uint64(len(body.Payload))
}

// Marshal converts message into bytes to store into db
func (m *Message) Marshal(protoVersion string) (data []byte, err error) {
	buffer := emptyMessageBufferPool.Get()
	defer emptyMessageBufferPool.Put(buffer)

	if err = WriteLonglong(buffer, m.ID); err != nil {
		return nil, err
	}

	if err = WriteContentHeader(buffer, m.Header, protoVersion); err != nil {
		return nil, err
	}
	if err = WriteShortstr(buffer, m.Exchange); err != nil {
		return nil, err
	}
	if err = WriteShortstr(buffer, m.RoutingKey); err != nil {
		return nil, err
	}

	for _, frame := range m.Body {
		if err = WriteFrame(buffer, frame); err != nil {
			return nil, err
		}
	}

	data = make([]byte, buffer.Len())
	copy(data, buffer.Bytes())
	return
}

// Unmarshal restore message entity from bytes
func (m *Message) Unmarshal(buffer []byte, protoVersion string) (err error) {
	reader := bytes.NewReader(buffer)
	if m.ID, err = ReadLonglong(reader); err != nil {
		return err
	}

	if m.Header, err = ReadContentHeader(reader, protoVersion); err != nil {
		return err
	}
	if m.Exchange, err = ReadShortstr(reader); err != nil {
		return err
	}
	if m.RoutingKey, err = ReadShortstr(reader); err != nil {
		return err
	}

	for m.BodySize < m.Header.BodySize {
		body, errFrame := ReadFrame(reader)
		if errFrame != nil {
			return errFrame
		}
		m.Append(body)
	}

	return nil
}

// Constants to detect connection or channel error thrown
const (
	ErrorOnConnection = iota
	ErrorOnChannel
)

// Error represents AMQP-error data
type Error struct {
	ReplyCode uint16
	ReplyText string
	ClassID   uint16
	MethodID  uint16
	ErrorType int
}

// NewConnectionError returns new connection error. If caused - connection should be closed
func NewConnectionError(code uint16, text string, classID uint16, methodID uint16) *Error {
	err := &Error{
		ReplyCode: code,
		ReplyText: ConstantsNameMap[code] + " - " + text,
		ClassID:   classID,
		MethodID:  methodID,
		ErrorType: ErrorOnConnection,
	}

	return err
}

// NewChannelError returns new channel error& If caused - channel should be closed
func NewChannelError(code uint16, text string, classID uint16, methodID uint16) *Error {
	err := &Error{
		ReplyCode: code,
		ReplyText: ConstantsNameMap[code] + " - " + text,
		ClassID:   classID,
		MethodID:  methodID,
		ErrorType: ErrorOnChannel,
	}

	return err
}

```

`pkg/outputs/amqp/_fixtures/garagemq/auth/auth.go`:

```go
package auth

import (
	"bytes"
	"crypto/md5"
	"encoding/hex"
	"errors"
)

// SaslPlain method
const SaslPlain = "PLAIN"

// SaslData represents standard SASL properties
type SaslData struct {
	Identity string
	Username string
	Password string
}

// ParsePlain check and parse SASL-raw data and return SaslData structure
func ParsePlain(response []byte) (SaslData, error) {
	parts := bytes.Split(response, []byte{0})
	if len(parts) != 3 {
		return SaslData{}, errors.New("Unable to parse PLAIN SALS response")
	}

	saslData := SaslData{}
	saslData.Identity = string(parts[0])
	saslData.Username = string(parts[1])
	saslData.Password = string(parts[2])

	return saslData, nil
}

// HashPassword hash raw password and return hash for check
func HashPassword(password string, isMd5 bool) (string, error) {
	h := md5.New()
	h.Write([]byte(password))
	return hex.EncodeToString(h.Sum(nil)), nil
}

// CheckPasswordHash check given password and hash
func CheckPasswordHash(password, hash string, isMd5 bool) bool {

	h := md5.New()
	// digest.Write never return any error, so skip error ckeck
	h.Write([]byte(password))

	return hash == hex.EncodeToString(h.Sum(nil))

}

```

`pkg/outputs/amqp/_fixtures/garagemq/binding/binding.go`:

```go
package binding

import (
	"bytes"
	"fmt"
	"github.com/rabbitstack/fibratus/pkg/outputs/amqp/_fixtures/garagemq/amqp"
	"reflect"
	"regexp"
	"strings"
)

// MatchType is the x-match attribute in a binding argument table
type MatchType int

const (
	// MatchAll requires all registered arguments to match for routing
	MatchAll MatchType = iota
	// MatchAny requires any registered arguments to match for routing
	MatchAny
)

// Binding represents AMQP-binding
type Binding struct {
	Queue      string
	Exchange   string
	RoutingKey string
	Arguments  *amqp.Table
	regexp     *regexp.Regexp
	topic      bool
	MatchType  MatchType
}

// NewBinding returns new instance of Binding
func NewBinding(queue string, exchange string, routingKey string, arguments *amqp.Table, topic bool) (*Binding, error) {
	binding := &Binding{
		Queue:      queue,
		Exchange:   exchange,
		RoutingKey: routingKey,
		Arguments:  arguments,
		topic:      topic,
	}

	if topic {
		var err error
		if binding.regexp, err = buildRegexp(routingKey); err != nil {
			return nil, fmt.Errorf("bad topic routing key %s -- %s",
				routingKey,
				err.Error())
		}
	}

	if arguments == nil {
		return binding, nil
	}

	// @spec-note AMQP 0.9.1
	//
	// Any field starting with 'x-' other than 'x-match' is
	// reserved for future use and will be ignored.
	//
	// * 'all' implies that all the other pairs must match the headers
	// property of a message for that message to be routed (i.e. and AND match)
	// * 'any' implies that the message should be routed if any of the
	// fields in the headers property match one of the fields in the
	// arguments table (i.e. an OR match)
	//
	// We arbitrarily choose `all` as the default if none was provided
	// at binding time.
	xmatch, ok := (*arguments)["x-match"]
	if ok {
		if xmatch == "all" {
			binding.MatchType = MatchAll
		} else if xmatch == "any" {
			binding.MatchType = MatchAny
		} else {
			return nil, fmt.Errorf("Invalid x-match field value %s, expected all or any",
				xmatch)
		}
	} else {
		binding.MatchType = MatchAll
	}

	return binding, nil
}

// @todo may be better will be trie or dfa than regexp
// @see http://www.rabbitmq.com/blog/2010/09/14/very-fast-and-scalable-topic-routing-part-1/
// @see http://www.rabbitmq.com/blog/2011/03/28/very-fast-and-scalable-topic-routing-part-2/
//
// buildRegexp generate regexp from topic-match string
func buildRegexp(routingKey string) (*regexp.Regexp, error) {
	routingKey = strings.TrimSpace(routingKey)
	routingParts := strings.Split(routingKey, ".")

	for idx, routingPart := range routingParts {
		if routingPart == "*" {
			routingParts[idx] = "*"
		} else if routingPart == "#" {
			routingParts[idx] = "#"
		} else {
			routingParts[idx] = regexp.QuoteMeta(routingPart)
		}
	}

	routingKey = strings.Join(routingParts, "\\.")
	routingKey = strings.Replace(routingKey, "*", `([^\.]+)`, -1)

	for strings.HasPrefix(routingKey, "#\\.") {
		routingKey = strings.TrimPrefix(routingKey, "#\\.")
		if strings.HasPrefix(routingKey, "#\\.") {
			continue
		}
		routingKey = `(.*\.?)+` + routingKey
	}

	for strings.HasSuffix(routingKey, "\\.#") {
		routingKey = strings.TrimSuffix(routingKey, "\\.#")
		if strings.HasSuffix(routingKey, "\\.#") {
			continue
		}
		routingKey = routingKey + `(.*\.?)+`
	}
	routingKey = strings.Replace(routingKey, "\\.#\\.", `(.*\.?)+`, -1)
	routingKey = strings.Replace(routingKey, "#", `(.*\.?)+`, -1)
	pattern := "^" + routingKey + "$"

	return regexp.Compile(pattern)
}

// MatchDirect check is message can be routed from direct-exchange to queue
// with compare exchange and routing key
func (b *Binding) MatchDirect(exchange string, routingKey string) bool {
	return b.Exchange == exchange && b.RoutingKey == routingKey
}

// MatchFanout check is message can be routed from fanout-exchange to queue
// with compare only exchange
func (b *Binding) MatchFanout(exchange string) bool {
	return b.Exchange == exchange
}

// MatchTopic check is message can be routed from topic-exchange to queue
// with compare exchange and match topic-pattern with routing key
func (b *Binding) MatchTopic(exchange string, routingKey string) bool {
	return b.Exchange == exchange && b.regexp.MatchString(routingKey)
}

// MatchHeader checks whether the message can be routed on `b` for a
// header exchange type.
func (b *Binding) MatchHeader(exchange string, headers *amqp.Table) bool {
	if b.Exchange != exchange {
		return false
	}

	// If no arguments were declared by the exchange,
	// consider it is an always true route.
	if b.Arguments == nil {
		return true
	}

	if headers == nil {
		return false
	}

	bindingArgTable := *b.Arguments
	cliHeaders := *headers

	matchType := b.MatchType

	// Fallback solution for the x-match any case, and no other
	// argument in the table
	//
	// If no match is found in the loop, and arguments other than
	// x-match were specified, it should not return a positive
	// value in the end.
	hasNonXArgs := false

	for key, value := range bindingArgTable {
		// Any field starting with 'x-' shall be ignored
		if strings.HasPrefix(key, "x-") {
			continue
		}

		hasNonXArgs = true

		val, ok := cliHeaders[key]

		if !ok {
			if matchType == MatchAll {
				return false
			}
			continue
		}

		// @spec-note AMQP 0.9.1
		//
		// A message queue is bound to the exchange with a table of
		// arguments containing the headers to be matched for that
		// binding and optionally the values they should hold
		if value == nil {
			if matchType == MatchAny {
				return true
			}
			continue
		}

		if value == val {
			if matchType == MatchAny {
				return true
			}
			continue
		}

		if matchType == MatchAll {
			return false
		}
	}

	return matchType == MatchAll ||
		!hasNonXArgs && matchType == MatchAny
}

// GetExchange returns binding's exchange
func (b *Binding) GetExchange() string {
	return b.Exchange
}

// GetRoutingKey returns binding's routing key
func (b *Binding) GetRoutingKey() string {
	return b.RoutingKey
}

// GetQueue returns binding's queue
func (b *Binding) GetQueue() string {
	return b.Queue
}

// Equal returns is given binding equal to current
// with compare exchange, routing key and queue
func (b *Binding) Equal(bind *Binding) bool {
	return b.Exchange == bind.GetExchange() &&
		b.Queue == bind.GetQueue() &&
		b.RoutingKey == bind.GetRoutingKey() &&
		reflect.DeepEqual(b.Arguments, bind.Arguments)
}

// GetName generate binding name by concatenating its params
func (b *Binding) GetName() string {
	return strings.Join(
		[]string{b.Queue, b.Exchange, b.RoutingKey},
		"_",
	)
}

// Marshal returns raw representation of binding to store into storage
func (b *Binding) Marshal(protoVersion string) (data []byte, err error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	if err = amqp.WriteShortstr(buf, b.Queue); err != nil {
		return nil, err
	}
	if err = amqp.WriteShortstr(buf, b.Exchange); err != nil {
		return nil, err
	}
	if err = amqp.WriteShortstr(buf, b.RoutingKey); err != nil {
		return nil, err
	}
	// Since marshalling is used for storage only, we can
	// simplify the Marshal/Unmarshal of arguments by
	// writing them in Rabbit format, and reading them as such
	if err = amqp.WriteTable(buf, b.Arguments, protoVersion); err != nil {
		return nil, err
	}
	var topic byte
	if b.topic {
		topic = 1
	}
	if err = amqp.WriteOctet(buf, topic); err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

// Unmarshal returns binding from storage raw bytes data
func (b *Binding) Unmarshal(data []byte, protoVersion string) (err error) {
	buf := bytes.NewReader(data)
	if b.Queue, err = amqp.ReadShortstr(buf); err != nil {
		return err
	}
	if b.Exchange, err = amqp.ReadShortstr(buf); err != nil {
		return err
	}
	if b.RoutingKey, err = amqp.ReadShortstr(buf); err != nil {
		return err
	}
	if b.Arguments, err = amqp.ReadTable(buf, protoVersion); err != nil {
		return err
	}
	var topic byte
	if topic, err = amqp.ReadOctet(buf); err != nil {
		return err
	}
	b.topic = topic == 1

	if b.topic {
		if b.regexp, err = buildRegexp(b.RoutingKey); err != nil {
			return err
		}
	}

	return
}

```

`pkg/outputs/amqp/_fixtures/garagemq/config/config.go`:

```go
package config

import (
	"io/ioutil"

	"gopkg.in/yaml.v3"
)

// Config represents server changeable se
type Config struct {
	Proto      string
	Users      []User
	TCP        TCPConfig
	Queue      Queue
	Db         Db
	Vhost      Vhost
	Security   Security
	Connection Connection
	Admin      AdminConfig
}

// User for auth check
type User struct {
	Username string
	Password string
}

// TCPConfig represents properties for tune network connections
type TCPConfig struct {
	IP           string `yaml:"ip"`
	Port         string
	Nodelay      bool
	ReadBufSize  int `yaml:"readBufSize"`
	WriteBufSize int `yaml:"writeBufSize"`
}

// AdminConfig represents properties for admin server
type AdminConfig struct {
	IP   string `yaml:"ip"`
	Port string
}

// Queue settings
type Queue struct {
	ShardSize        int    `yaml:"shardSize"`
	MaxMessagesInRAM uint64 `yaml:"maxMessagesInRam"`
}

// Db settings, such as path to load/save and engine
type Db struct {
	DefaultPath string `yaml:"defaultPath"`
	Engine      string `yaml:"engine"`
}

// Vhost settings
type Vhost struct {
	DefaultPath string `yaml:"defaultPath"`
}

// Security settings
type Security struct {
	PasswordCheck string `yaml:"passwordCheck"`
}

// Connection settings for AMQP-connection
type Connection struct {
	ChannelsMax  uint16 `yaml:"channelsMax"`
	FrameMaxSize uint32 `yaml:"frameMaxSize"`
}

// CreateFromFile creates config from file
func CreateFromFile(path string) (*Config, error) {
	cfg := &Config{}
	file, err := ioutil.ReadFile(path)
	if err != nil {
		return nil, err
	}
	err = yaml.Unmarshal(file, &cfg)
	if err != nil {
		return nil, err
	}

	return cfg, nil
}

// CreateDefault creates config from default values
func CreateDefault() (*Config, error) {
	return Default(), nil
}

```

`pkg/outputs/amqp/_fixtures/garagemq/config/default.go`:

```go
package config

const (
	dbBuntDB = "buntdb"
	dbBadger = "badger"
)

func Default() *Config {
	return &Config{
		Proto: "amqp-rabbit",
		Users: []User{
			{
				Username: "guest",
				Password: "084e0343a0486ff05530df6c705c8bb4", // guest md5 hash
			},
		},
		TCP: TCPConfig{
			IP:           "0.0.0.0",
			Port:         "5672",
			Nodelay:      false,
			ReadBufSize:  128 << 10, // 128Kb
			WriteBufSize: 128 << 10, // 128Kb
		},
		Admin: AdminConfig{
			IP:   "0.0.0.0",
			Port: "15672",
		},
		Queue: Queue{
			ShardSize:        8 << 10,      // 8k
			MaxMessagesInRAM: 10 * 8 << 10, // 10 buckets
		},
		Db: Db{
			DefaultPath: "db",
			Engine:      dbBadger,
		},
		Vhost: Vhost{
			DefaultPath: "/",
		},
		Security: Security{
			PasswordCheck: "md5",
		},
		Connection: Connection{
			ChannelsMax:  4096,
			FrameMaxSize: 65536,
		},
	}
}

```

`pkg/outputs/amqp/_fixtures/garagemq/consumer/consumer.go`:

```go
package consumer

import (
	"fmt"
	"github.com/rabbitstack/fibratus/pkg/outputs/amqp/_fixtures/garagemq/amqp"
	"github.com/rabbitstack/fibratus/pkg/outputs/amqp/_fixtures/garagemq/interfaces"
	"github.com/rabbitstack/fibratus/pkg/outputs/amqp/_fixtures/garagemq/qos"
	"github.com/rabbitstack/fibratus/pkg/outputs/amqp/_fixtures/garagemq/queue"
	"sync"
	"sync/atomic"
	"time"
)

const (
	started = iota
	stopped
	paused
)

var cid uint64

// Consumer implements AMQP consumer
type Consumer struct {
	ID          uint64
	Queue       string
	ConsumerTag string
	noAck       bool
	channel     interfaces.Channel
	queue       *queue.Queue
	statusLock  sync.RWMutex
	status      int
	qos         []*qos.AmqpQos
	consume     chan struct{}
}

// NewConsumer returns new instance of Consumer
func NewConsumer(queueName string, consumerTag string, noAck bool, channel interfaces.Channel, queue *queue.Queue, qos []*qos.AmqpQos) *Consumer {
	id := atomic.AddUint64(&cid, 1)
	if consumerTag == "" {
		consumerTag = generateTag(id)
	}
	return &Consumer{
		ID:          id,
		Queue:       queueName,
		ConsumerTag: consumerTag,
		noAck:       noAck,
		channel:     channel,
		queue:       queue,
		qos:         qos,
		consume:     make(chan struct{}, 1),
	}
}

func generateTag(id uint64) string {
	return fmt.Sprintf("%d_%d", time.Now().Unix(), id)
}

// Start starting consumer to fetch messages from queue
func (consumer *Consumer) Start() {
	consumer.statusLock.Lock()
	consumer.status = started
	consumer.statusLock.Unlock()
	go consumer.startConsume()
	consumer.Consume()
}

// startConsume waiting a signal from consume channel and try to pop message from queue
// if not set noAck consumer pop message with qos rules and add message to unacked message queue
func (consumer *Consumer) startConsume() {
	for range consumer.consume {
		consumer.retrieveAndSendMessage()
	}
}

func (consumer *Consumer) retrieveAndSendMessage() {
	var message *amqp.Message
	consumer.statusLock.RLock()
	defer consumer.statusLock.RUnlock()
	if consumer.status == stopped {
		return
	}

	if consumer.noAck {
		message = consumer.queue.Pop()
	} else {
		message = consumer.queue.PopQos(consumer.qos)
	}

	if message == nil {
		return
	}

	dTag := consumer.channel.NextDeliveryTag()
	if !consumer.noAck {
		consumer.channel.AddUnackedMessage(dTag, consumer.ConsumerTag, consumer.queue.GetName(), message)
	}

	consumer.channel.SendContent(&amqp.BasicDeliver{
		ConsumerTag: consumer.ConsumerTag,
		DeliveryTag: dTag,
		Redelivered: message.DeliveryCount > 1,
		Exchange:    message.Exchange,
		RoutingKey:  message.RoutingKey,
	}, message)

	consumer.consumeMsg()

	return
}

// Pause pause consumer, used by channel.flow change
func (consumer *Consumer) Pause() {
	consumer.statusLock.Lock()
	defer consumer.statusLock.Unlock()
	consumer.status = paused
}

// UnPause unpause consumer, used by channel.flow change
func (consumer *Consumer) UnPause() {
	consumer.statusLock.Lock()
	defer consumer.statusLock.Unlock()
	consumer.status = started
}

// Consume send signal into consumer channel, than consumer can try to pop message from queue
func (consumer *Consumer) Consume() bool {
	consumer.statusLock.RLock()
	defer consumer.statusLock.RUnlock()

	return consumer.consumeMsg()
}

func (consumer *Consumer) consumeMsg() bool {
	if consumer.status == stopped || consumer.status == paused {
		return false
	}

	select {
	case consumer.consume <- struct{}{}:
		return true
	default:
		return false
	}
}

// Stop stops consumer and remove it from queue consumers list
func (consumer *Consumer) Stop() {
	consumer.statusLock.Lock()
	if consumer.status == stopped {
		consumer.statusLock.Unlock()
		return
	}
	consumer.status = stopped
	consumer.statusLock.Unlock()
	consumer.queue.RemoveConsumer(consumer.ConsumerTag)
	close(consumer.consume)
}

// Cancel stops consumer and send basic.cancel method to the client
func (consumer *Consumer) Cancel() {
	consumer.Stop()
	consumer.channel.SendMethod(&amqp.BasicCancel{ConsumerTag: consumer.ConsumerTag, NoWait: true})
}

// Tag returns consumer tag
func (consumer *Consumer) Tag() string {
	return consumer.ConsumerTag
}

// Qos returns consumer qos rules
func (consumer *Consumer) Qos() []*qos.AmqpQos {
	return consumer.qos
}

```

`pkg/outputs/amqp/_fixtures/garagemq/exchange/exchange.go`:

```go
package exchange

import (
	"bytes"
	"fmt"
	"github.com/rabbitstack/fibratus/pkg/outputs/amqp/_fixtures/garagemq/amqp"
	"github.com/rabbitstack/fibratus/pkg/outputs/amqp/_fixtures/garagemq/binding"
	"sync"
)

// available exchange types
const (
	ExTypeDirect = iota + 1
	ExTypeFanout
	ExTypeTopic
	ExTypeHeaders
)

var exchangeTypeIDAliasMap = map[byte]string{
	ExTypeDirect:  "direct",
	ExTypeFanout:  "fanout",
	ExTypeTopic:   "topic",
	ExTypeHeaders: "headers",
}

var exchangeTypeAliasIDMap = map[string]byte{
	"direct":  ExTypeDirect,
	"fanout":  ExTypeFanout,
	"topic":   ExTypeTopic,
	"headers": ExTypeHeaders,
}

// MetricsState implements exchange's metrics state
type MetricsState struct {
}

// Exchange implements AMQP-exchange
type Exchange struct {
	Name       string
	exType     byte
	durable    bool
	autoDelete bool
	internal   bool
	system     bool
	bindLock   sync.Mutex
	bindings   []*binding.Binding
}

// NewExchange returns new instance of Exchange
func NewExchange(name string, exType byte, durable bool, autoDelete bool, internal bool, system bool) *Exchange {
	return &Exchange{
		Name:       name,
		exType:     exType,
		durable:    durable,
		autoDelete: autoDelete,
		internal:   internal,
		system:     system,
	}
}

// GetExchangeTypeAlias returns exchange type alias by id
func GetExchangeTypeAlias(id byte) (alias string, err error) {
	if alias, ok := exchangeTypeIDAliasMap[id]; ok {
		return alias, nil
	}
	return "", fmt.Errorf("undefined exchange type '%d'", id)
}

// GetExchangeTypeID returns exchange type id by alias
func GetExchangeTypeID(alias string) (id byte, err error) {
	if id, ok := exchangeTypeAliasIDMap[alias]; ok {
		return id, nil
	}
	return 0, fmt.Errorf("undefined exchange alias '%s'", alias)
}

// GetTypeAlias returns exchange type alias by id
func (ex *Exchange) GetTypeAlias() string {
	alias, _ := GetExchangeTypeAlias(ex.exType)

	return alias
}

// AppendBinding check and append binding
// method check if binding already exists and ignore it
func (ex *Exchange) AppendBinding(newBind *binding.Binding) {
	ex.bindLock.Lock()
	defer ex.bindLock.Unlock()

	// @spec-note
	// A server MUST allow ignore duplicate bindings ­ that is, two or more bind methods for a specific queue,
	// with identical arguments ­ without treating these as an error.
	for _, bind := range ex.bindings {
		if bind.Equal(newBind) {
			return
		}
	}
	ex.bindings = append(ex.bindings, newBind)
}

// RemoveBinding remove binding
func (ex *Exchange) RemoveBinding(rmBind *binding.Binding) {
	ex.bindLock.Lock()
	defer ex.bindLock.Unlock()
	for i, bind := range ex.bindings {
		if bind.Equal(rmBind) {
			ex.bindings = append(ex.bindings[:i], ex.bindings[i+1:]...)
			return
		}
	}
}

// RemoveQueueBindings remove bindings for queue and return removed bindings
func (ex *Exchange) RemoveQueueBindings(queueName string) []*binding.Binding {
	var newBindings []*binding.Binding
	var removedBindings []*binding.Binding
	ex.bindLock.Lock()
	defer ex.bindLock.Unlock()
	for _, bind := range ex.bindings {
		if bind.GetQueue() != queueName {
			newBindings = append(newBindings, bind)
		} else {
			removedBindings = append(removedBindings, bind)
		}
	}

	ex.bindings = newBindings
	return removedBindings
}

// GetMatchedQueues returns queues matched for message routing key
func (ex *Exchange) GetMatchedQueues(message *amqp.Message) (matchedQueues map[string]bool) {
	// @spec-note
	// The server MUST implement these standard exchange types: fanout, direct.
	// The server SHOULD implement these standard exchange types: topic, headers.

	// TODO implement "headers" exchange
	matchedQueues = make(map[string]bool)
	switch ex.exType {
	case ExTypeDirect:
		for _, bind := range ex.bindings {
			if bind.MatchDirect(message.Exchange, message.RoutingKey) {
				matchedQueues[bind.GetQueue()] = true
				return
			}
		}
	case ExTypeFanout:
		for _, bind := range ex.bindings {
			if bind.MatchFanout(message.Exchange) {
				matchedQueues[bind.GetQueue()] = true
			}
		}
	case ExTypeTopic:
		for _, bind := range ex.bindings {
			if bind.MatchTopic(message.Exchange, message.RoutingKey) {
				matchedQueues[bind.GetQueue()] = true
			}
		}
	case ExTypeHeaders:
		if message.Header == nil {
			return
		}
		props := message.Header.PropertyList
		if props == nil {
			return
		}
		header := props.Headers
		for _, bind := range ex.bindings {
			if bind.MatchHeader(message.Exchange, header) {
				matchedQueues[bind.GetQueue()] = true
			}
		}
	}
	return
}

// EqualWithErr returns is given exchange equal to current
func (ex *Exchange) EqualWithErr(exB *Exchange) error {
	errTemplate := "inequivalent arg '%s' for exchange '%s': received '%s' but current is '%s'"
	if ex.exType != exB.ExType() {
		aliasA, err := GetExchangeTypeAlias(ex.exType)
		if err != nil {
			return err
		}
		aliasB, err := GetExchangeTypeAlias(exB.ExType())
		if err != nil {
			return err
		}
		return fmt.Errorf(
			errTemplate,
			"type",
			ex.Name,
			aliasB,
			aliasA,
		)
	}
	if ex.durable != exB.IsDurable() {
		return fmt.Errorf(errTemplate, "durable", ex.Name, exB.IsDurable(), ex.durable)
	}
	if ex.autoDelete != exB.IsAutoDelete() {
		return fmt.Errorf(errTemplate, "autoDelete", ex.Name, exB.IsAutoDelete(), ex.autoDelete)
	}
	if ex.internal != exB.IsInternal() {
		return fmt.Errorf(errTemplate, "internal", ex.Name, exB.IsInternal(), ex.internal)
	}
	return nil
}

// GetBindings returns exchange's bindings
func (ex *Exchange) GetBindings() []*binding.Binding {
	ex.bindLock.Lock()
	defer ex.bindLock.Unlock()
	return ex.bindings
}

// IsDurable returns is exchange durable
func (ex *Exchange) IsDurable() bool {
	return ex.durable
}

// IsSystem returns is exchange system
func (ex *Exchange) IsSystem() bool {
	return ex.system
}

// IsAutoDelete returns should be exchange deleted when all queues have finished using it
func (ex *Exchange) IsAutoDelete() bool {
	return ex.autoDelete
}

// IsInternal returns that the exchange may not be used directly by publishers,
// but only when bound to other exchanges
func (ex *Exchange) IsInternal() bool {
	return ex.internal
}

// Marshal returns raw representation of exchange to store into storage
func (ex *Exchange) Marshal(protoVersion string) (data []byte, err error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	if err = amqp.WriteShortstr(buf, ex.Name); err != nil {
		return nil, err
	}
	if err = amqp.WriteOctet(buf, ex.exType); err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

// Unmarshal returns exchange from storage raw bytes data
func (ex *Exchange) Unmarshal(data []byte) (err error) {
	buf := bytes.NewReader(data)
	if ex.Name, err = amqp.ReadShortstr(buf); err != nil {
		return err
	}
	if ex.exType, err = amqp.ReadOctet(buf); err != nil {
		return err
	}
	ex.durable = true
	return
}

// GetName returns exchange name
func (ex *Exchange) GetName() string {
	return ex.Name
}

// ExType returns exchange type
func (ex *Exchange) ExType() byte {
	return ex.exType
}

```

`pkg/outputs/amqp/_fixtures/garagemq/interfaces/interfaces.go`:

```go
package interfaces

import (
	"github.com/rabbitstack/fibratus/pkg/outputs/amqp/_fixtures/garagemq/amqp"
)

// Channel represents base channel public interface
type Channel interface {
	SendContent(method amqp.Method, message *amqp.Message)
	SendMethod(method amqp.Method)
	NextDeliveryTag() uint64
	AddUnackedMessage(dTag uint64, cTag string, queue string, message *amqp.Message)
}

// Consumer represents base consumer public interface
type Consumer interface {
	Consume() bool
	Tag() string
	Cancel()
}

// OpSet identifier for set data into storeage
const OpSet = 1

// OpDel identifier for delete data from storage
const OpDel = 2

// Operation represents structure to set/del from storage
type Operation struct {
	Key   string
	Value []byte
	Op    byte
}

// DbStorage represent base db storage interface
type DbStorage interface {
	Set(key string, value []byte) (err error)
	Del(key string) (err error)
	Get(key string) (value []byte, err error)
	Iterate(fn func(key []byte, value []byte))
	IterateByPrefix(prefix []byte, limit uint64, fn func(key []byte, value []byte)) uint64
	IterateByPrefixFrom(prefix []byte, from []byte, limit uint64, fn func(key []byte, value []byte)) uint64
	DeleteByPrefix(prefix []byte)
	KeysByPrefixCount(prefix []byte) uint64
	ProcessBatch(batch []*Operation) (err error)
	Close() error
}

// MsgStorage represent interface for messages storage
type MsgStorage interface {
	Del(message *amqp.Message, queue string) error
	PurgeQueue(queue string)
	Add(message *amqp.Message, queue string) error
	Update(message *amqp.Message, queue string) error
	IterateByQueueFromMsgID(queue string, msgID uint64, limit uint64, fn func(message *amqp.Message)) uint64
	GetQueueLength(queue string) uint64
}

```

`pkg/outputs/amqp/_fixtures/garagemq/pool/pool.go`:

```go
/*
 * Copyright 2019-2020 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package pool

import (
	"bytes"
	"sync"
)

// BufferPool represents a thread safe buffer pool
type BufferPool struct {
	sync.Pool
}

// NewBufferPool returns a new BufferPool
func NewBufferPool(bufferSize int) *BufferPool {
	return &BufferPool{
		sync.Pool{
			New: func() interface{} {
				return bytes.NewBuffer(make([]byte, 0, bufferSize))
			},
		},
	}
}

// Get gets a Buffer from the pool
func (bp *BufferPool) Get() *bytes.Buffer {
	return bp.Pool.Get().(*bytes.Buffer)
}

// Put returns the given Buffer to the pool.
func (bp *BufferPool) Put(b *bytes.Buffer) {
	b.Reset()
	bp.Pool.Put(b)
}

```

`pkg/outputs/amqp/_fixtures/garagemq/qos/qos.go`:

```go
package qos

import "sync"

// AmqpQos represents qos system
type AmqpQos struct {
	sync.Mutex
	prefetchCount uint16
	currentCount  uint16
	prefetchSize  uint32
	currentSize   uint32
}

// NewAmqpQos returns new instance of AmqpQos
func NewAmqpQos(prefetchCount uint16, prefetchSize uint32) *AmqpQos {
	return &AmqpQos{
		prefetchCount: prefetchCount,
		prefetchSize:  prefetchSize,
		currentCount:  0,
		currentSize:   0,
	}
}

// PrefetchCount returns prefetchCount
func (qos *AmqpQos) PrefetchCount() uint16 {
	return qos.prefetchCount
}

// PrefetchSize returns prefetchSize
func (qos *AmqpQos) PrefetchSize() uint32 {
	return qos.prefetchSize
}

// Update set new prefetchCount and prefetchSize
func (qos *AmqpQos) Update(prefetchCount uint16, prefetchSize uint32) {
	qos.prefetchCount = prefetchCount
	qos.prefetchSize = prefetchSize
}

// IsActive check is qos rules are active
// both prefetchSize and prefetchCount must be 0
func (qos *AmqpQos) IsActive() bool {
	return qos.prefetchCount != 0 || qos.prefetchSize != 0
}

// Inc increment current count and size
// Returns true if increment success
// Returns false if after increment size or count will be more than prefetchCount or prefetchSize
func (qos *AmqpQos) Inc(count uint16, size uint32) bool {
	qos.Lock()
	defer qos.Unlock()

	newCount := qos.currentCount + count
	newSize := qos.currentSize + size

	if (qos.prefetchCount == 0 || newCount <= qos.prefetchCount) && (qos.prefetchSize == 0 || newSize <= qos.prefetchSize) {
		qos.currentCount = newCount
		qos.currentSize = newSize
		return true
	}

	return false
}

// Dec decrement current count and size
func (qos *AmqpQos) Dec(count uint16, size uint32) {
	qos.Lock()
	defer qos.Unlock()

	if qos.currentCount < count {
		qos.currentCount = 0
	} else {
		qos.currentCount = qos.currentCount - count
	}

	if qos.currentSize < size {
		qos.currentSize = 0
	} else {
		qos.currentSize = qos.currentSize - size
	}
}

// Release reset current count and size
func (qos *AmqpQos) Release() {
	qos.Lock()
	defer qos.Unlock()
	qos.currentCount = 0
	qos.currentSize = 0
}

// Copy safe copy current qos instance to new one
func (qos *AmqpQos) Copy() *AmqpQos {
	qos.Lock()
	defer qos.Unlock()
	return &AmqpQos{
		prefetchCount: qos.prefetchCount,
		prefetchSize:  qos.prefetchSize,
		currentCount:  qos.currentCount,
		currentSize:   qos.currentSize,
	}
}

```

`pkg/outputs/amqp/_fixtures/garagemq/queue/queue.go`:

```go
package queue

import (
	"bytes"
	"errors"
	"fmt"
	"github.com/rabbitstack/fibratus/pkg/outputs/amqp/_fixtures/garagemq/amqp"
	"github.com/rabbitstack/fibratus/pkg/outputs/amqp/_fixtures/garagemq/config"
	"github.com/rabbitstack/fibratus/pkg/outputs/amqp/_fixtures/garagemq/interfaces"
	"github.com/rabbitstack/fibratus/pkg/outputs/amqp/_fixtures/garagemq/qos"
	"github.com/rabbitstack/fibratus/pkg/outputs/amqp/_fixtures/garagemq/safequeue"
	"sync"
	"sync/atomic"
)

// Queue is an implementation of the AMQP-queue entity
type Queue struct {
	safequeue.SafeQueue
	name        string
	connID      uint64
	exclusive   bool
	autoDelete  bool
	durable     bool
	cmrLock     sync.RWMutex
	consumers   []interfaces.Consumer
	consumeExcl bool
	call        chan struct{}
	wasConsumed bool
	shardSize   int
	actLock     sync.RWMutex
	active      bool
	// persistent storage
	// transient storage
	currentConsumer int
	autoDeleteQueue chan string
	queueLength     int64

	// lock for sync load swapped-messages from disk
	loadSwapLock           sync.Mutex
	maxMessagesInRAM       uint64
	lastStoredMsgID        uint64
	lastMemMsgID           uint64
	swappedToDisk          bool
	maybeLoadFromStorageCh chan struct{}
	wg                     *sync.WaitGroup
}

// NewQueue returns new instance of Queue
func NewQueue(name string, connID uint64, exclusive bool, autoDelete bool, durable bool, config config.Queue, msgStorageP interfaces.MsgStorage, msgStorageT interfaces.MsgStorage, autoDeleteQueue chan string) *Queue {
	return &Queue{
		SafeQueue:              *safequeue.NewSafeQueue(config.ShardSize),
		name:                   name,
		connID:                 connID,
		exclusive:              exclusive,
		autoDelete:             autoDelete,
		durable:                durable,
		call:                   make(chan struct{}, 1),
		maybeLoadFromStorageCh: make(chan struct{}, 1),
		wasConsumed:            false,
		active:                 false,
		shardSize:              1,
		maxMessagesInRAM:       1500,
		currentConsumer:        0,
		autoDeleteQueue:        autoDeleteQueue,
		swappedToDisk:          false,
		wg:                     &sync.WaitGroup{},
	}

}

// Start starts base queue loop to send events to consumers
// Current consumer to handle message from queue selected by round robin
func (queue *Queue) Start() error {
	queue.actLock.Lock()
	defer queue.actLock.Unlock()

	if queue.active {
		return nil
	}

	queue.active = true
	queue.wg.Add(1)
	go func() {
		defer queue.wg.Done()
		for range queue.call {
			func() {
				queue.cmrLock.RLock()
				defer queue.cmrLock.RUnlock()
				cmrCount := len(queue.consumers)
				for i := 0; i < cmrCount; i++ {
					if !queue.active {
						return
					}
					queue.currentConsumer = (queue.currentConsumer + 1) % cmrCount
					cmr := queue.consumers[queue.currentConsumer]
					if cmr.Consume() {
						return
					}
				}
			}()
		}
	}()

	queue.wg.Add(1)
	go func() {
		defer queue.wg.Done()
		for range queue.maybeLoadFromStorageCh {
			queue.mayBeLoadFromStorage()
		}
	}()

	return nil
}

// Stop stops main queue loop
// After stop no one can send or receive messages from queue
func (queue *Queue) Stop() error {
	queue.actLock.Lock()
	defer queue.actLock.Unlock()

	queue.active = false
	close(queue.maybeLoadFromStorageCh)
	close(queue.call)
	queue.wg.Wait()
	return nil
}

// GetName returns queue name
func (queue *Queue) GetName() string {
	return queue.name
}

// Push append message into queue tail and put it into message storage
// if queue is durable and message's persistent flag is true
func (queue *Queue) Push(message *amqp.Message) {
	queue.actLock.Lock()
	defer queue.actLock.Unlock()

	if !queue.active {
		return
	}

	atomic.AddInt64(&queue.queueLength, 1)

	message.GenerateSeq()

	persisted := false
	if queue.durable && message.IsPersistent() {
		persisted = true
	} else {
		if queue.SafeQueue.Length() > queue.maxMessagesInRAM || queue.swappedToDisk {
			persisted = true
		}

		if message.ConfirmMeta != nil {
			message.ConfirmMeta.ActualConfirms++
		}
	}

	if persisted && !queue.swappedToDisk && queue.SafeQueue.Length() > queue.maxMessagesInRAM {
		queue.swappedToDisk = true
		queue.lastStoredMsgID = message.ID
	}

	if queue.SafeQueue.Length() <= queue.maxMessagesInRAM && !queue.swappedToDisk {
		queue.SafeQueue.Push(message)
		queue.lastMemMsgID = message.ID
	}

	queue.callConsumers()
}

// Pop returns message from queue head without QOS check
func (queue *Queue) Pop() *amqp.Message {
	return queue.PopQos([]*qos.AmqpQos{})
}

// PopQos returns message from queue head with QOS check
func (queue *Queue) PopQos(qosList []*qos.AmqpQos) *amqp.Message {
	queue.actLock.RLock()
	if !queue.active {
		queue.actLock.RUnlock()
		return nil
	}
	queue.actLock.RUnlock()

	select {
	case queue.maybeLoadFromStorageCh <- struct{}{}:
	default:
	}

	queue.SafeQueue.Lock()
	var message *amqp.Message
	if message = queue.SafeQueue.HeadItem(); message != nil {
		allowed := true
		for _, q := range qosList {
			if !q.IsActive() {
				continue
			}
			if !q.Inc(1, uint32(message.BodySize)) {
				allowed = false
				break
			}
		}

		if allowed {
			queue.SafeQueue.DirtyPop()
			atomic.AddInt64(&queue.queueLength, -1)
		} else {
			message = nil
		}
	}
	queue.SafeQueue.Unlock()

	return message
}

func (queue *Queue) mayBeLoadFromStorage() {
	swappedToPersistent := true
	swappedToTransient := true

	currentLength := queue.SafeQueue.Length()
	needle := queue.maxMessagesInRAM - currentLength

	if currentLength >= queue.maxMessagesInRAM/2 || needle <= 0 || !queue.swappedToDisk {
		return
	}

	pMessages := make([]*amqp.Message, 0, needle)
	tMessages := make([]*amqp.Message, 0, needle)

	lastMemMsgID := queue.lastMemMsgID

	var wg sync.WaitGroup
	// 2 - search for transient and persistent
	wg.Add(2)

	go func() {
		wg.Done()
	}()

	go func() {
		wg.Done()
	}()

	wg.Wait()

	sortedMessages := queue.mergeSortedMessageSlices(pMessages, tMessages)
	sortedMessageslength := uint64(len(sortedMessages))

	var pos uint64
	if sortedMessageslength <= needle {
		pos = sortedMessageslength
	} else {
		pos = needle
	}

	for _, message := range sortedMessages[0:pos] {
		if message.ID == lastMemMsgID {
			continue
		}
		queue.SafeQueue.Push(message)
		queue.lastMemMsgID = message.ID
		queue.lastStoredMsgID = message.ID
		queue.callConsumers()
	}

	queue.swappedToDisk = swappedToPersistent || swappedToTransient
}

func (queue *Queue) mergeSortedMessageSlices(A, B []*amqp.Message) []*amqp.Message {
	result := make([]*amqp.Message, len(A)+len(B))

	idxA, idxB := 0, 0

	for i := 0; i < len(result); i++ {
		if idxA >= len(A) {
			result[i] = B[idxB]
			idxB++
			continue
		} else if idxB >= len(B) {
			result[i] = A[idxA]
			idxA++
			continue
		}

		if A[idxA].ID < B[idxB].ID {
			result[i] = A[idxA]
			idxA++
		} else {
			result[i] = B[idxB]
			idxB++
		}
	}

	return result
}

// AckMsg accept ack event for message
func (queue *Queue) AckMsg(message *amqp.Message) {
	queue.actLock.RLock()
	if !queue.active {
		queue.actLock.RUnlock()
		return
	}
	queue.actLock.RUnlock()

	if queue.durable && message.IsPersistent() {
		// TODO handle error
	}

}

// Requeue add message into queue head
func (queue *Queue) Requeue(message *amqp.Message) {
	queue.actLock.RLock()
	if !queue.active {
		queue.actLock.RUnlock()
		return
	}
	queue.actLock.RUnlock()

	message.DeliveryCount++
	queue.SafeQueue.PushHead(message)
	if queue.durable && message.IsPersistent() {
		// TODO handle error
	}

	atomic.AddInt64(&queue.queueLength, 1)

	queue.callConsumers()
}

// Purge clean queue and message storage for durable queues
func (queue *Queue) Purge() (length uint64) {
	queue.SafeQueue.Lock()
	defer queue.SafeQueue.Unlock()
	length = uint64(atomic.LoadInt64(&queue.queueLength))
	queue.SafeQueue.DirtyPurge()

	if queue.durable {
	}

	atomic.StoreInt64(&queue.queueLength, 0)
	return
}

// Delete cancel consumers and delete its messages from storage
func (queue *Queue) Delete(ifUnused bool, ifEmpty bool) (uint64, error) {
	queue.actLock.Lock()
	queue.cmrLock.Lock()
	queue.SafeQueue.Lock()
	defer queue.actLock.Unlock()
	defer queue.cmrLock.Unlock()
	defer queue.SafeQueue.Unlock()

	queue.active = false

	if ifUnused && len(queue.consumers) != 0 {
		return 0, errors.New("queue has consumers")
	}

	if ifEmpty && queue.SafeQueue.DirtyLength() != 0 {
		return 0, errors.New("queue has messages")
	}

	queue.cancelConsumers()
	length := uint64(atomic.LoadInt64(&queue.queueLength))

	if queue.durable {
	}

	return length, nil
}

// AddConsumer add consumer to consumer messages with exclusive check
func (queue *Queue) AddConsumer(consumer interfaces.Consumer, exclusive bool) error {
	queue.cmrLock.Lock()
	defer queue.cmrLock.Unlock()

	if !queue.active {
		return fmt.Errorf("queue is not active")
	}
	queue.wasConsumed = true

	if len(queue.consumers) != 0 && (queue.consumeExcl || exclusive) {
		return fmt.Errorf("queue is busy by %d consumers", len(queue.consumers))
	}

	if exclusive {
		queue.consumeExcl = true
	}

	queue.consumers = append(queue.consumers, consumer)

	queue.callConsumers()
	return nil
}

// RemoveConsumer remove consumer
// If it was last consumer and queue is auto-delete - queue will be removed
func (queue *Queue) RemoveConsumer(cTag string) {
	queue.cmrLock.Lock()
	defer queue.cmrLock.Unlock()

	for i, cmr := range queue.consumers {
		if cmr.Tag() == cTag {
			queue.consumers = append(queue.consumers[:i], queue.consumers[i+1:]...)
			break
		}
	}
	cmrCount := len(queue.consumers)
	if cmrCount == 0 {
		queue.currentConsumer = 0
		queue.consumeExcl = false
	} else {
		queue.currentConsumer = (queue.currentConsumer + 1) % cmrCount
	}

	if cmrCount == 0 && queue.wasConsumed && queue.autoDelete {
		queue.autoDeleteQueue <- queue.name
	}
}

// Send event to call next consumer, that it can receive next message
func (queue *Queue) callConsumers() {
	if !queue.active {
		return
	}
	select {
	case queue.call <- struct{}{}:
	default:
	}
}

func (queue *Queue) cancelConsumers() {
	for _, cmr := range queue.consumers {
		cmr.Cancel()
	}
}

// Length returns queue length
func (queue *Queue) Length() uint64 {
	return uint64(atomic.LoadInt64(&queue.queueLength))
}

// ConsumersCount returns consumers count
func (queue *Queue) ConsumersCount() int {
	queue.cmrLock.RLock()
	defer queue.cmrLock.RUnlock()
	return len(queue.consumers)
}

// EqualWithErr returns is given queue equal to current
func (queue *Queue) EqualWithErr(qB *Queue) error {
	errTemplate := "inequivalent arg '%s' for queue '%s': received '%t' but current is '%t'"
	if queue.durable != qB.IsDurable() {
		return fmt.Errorf(errTemplate, "durable", queue.name, qB.IsDurable(), queue.durable)
	}
	if queue.autoDelete != qB.autoDelete {
		return fmt.Errorf(errTemplate, "autoDelete", queue.name, qB.autoDelete, queue.autoDelete)
	}
	if queue.exclusive != qB.IsExclusive() {
		return fmt.Errorf(errTemplate, "exclusive", queue.name, qB.IsExclusive(), queue.exclusive)
	}
	return nil
}

// Marshal returns raw representation of queue to store into storage
func (queue *Queue) Marshal(protoVersion string) (data []byte, err error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	if err = amqp.WriteShortstr(buf, queue.name); err != nil {
		return nil, err
	}

	var autoDelete byte
	if queue.autoDelete {
		autoDelete = 1
	} else {
		autoDelete = 0
	}

	if err = amqp.WriteOctet(buf, autoDelete); err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

// Unmarshal returns queue from storage raw bytes data
func (queue *Queue) Unmarshal(data []byte, protoVersion string) (err error) {
	buf := bytes.NewReader(data)
	if queue.name, err = amqp.ReadShortstr(buf); err != nil {
		return err
	}

	var autoDelete byte

	if autoDelete, err = amqp.ReadOctet(buf); err != nil {
		return err
	}
	queue.autoDelete = autoDelete > 0
	queue.durable = true
	return
}

// IsDurable returns is queue durable
func (queue *Queue) IsDurable() bool {
	return queue.durable
}

// IsExclusive returns is queue exclusive
func (queue *Queue) IsExclusive() bool {
	return queue.exclusive
}

// IsAutoDelete returns is queue should be deleted automatically
func (queue *Queue) IsAutoDelete() bool {
	return queue.autoDelete
}

// ConnID returns ID of connection that create this queue
func (queue *Queue) ConnID() uint64 {
	return queue.connID
}

// IsActive returns is queue's main loop is active
func (queue *Queue) IsActive() bool {
	return queue.active
}

```

`pkg/outputs/amqp/_fixtures/garagemq/safequeue/safequeue.go`:

```go
package safequeue

import (
	"github.com/rabbitstack/fibratus/pkg/outputs/amqp/_fixtures/garagemq/amqp"
	"sync"
)

// We change item's type from {}interface to *amqp.Message, cause we know that we use safequeue only in AMQP context
// TODO Move safe queue into amqp package

// SafeQueue represents simple FIFO queue
// TODO Is that implementation faster? test simple slice queue
type SafeQueue struct {
	sync.RWMutex
	shards    [][]*amqp.Message
	shardSize int
	tailIdx   int
	tail      []*amqp.Message
	tailPos   int
	headIdx   int
	head      []*amqp.Message
	headPos   int
	length    uint64
}

// NewSafeQueue returns new instance of queue
func NewSafeQueue(shardSize int) *SafeQueue {
	queue := &SafeQueue{
		shardSize: shardSize,
		shards:    [][]*amqp.Message{make([]*amqp.Message, shardSize)},
	}

	queue.tailIdx = 0
	queue.tail = queue.shards[queue.tailIdx]
	queue.headIdx = 0
	queue.head = queue.shards[queue.headIdx]
	return queue
}

// Push adds message into queue tail
func (queue *SafeQueue) Push(item *amqp.Message) {
	queue.Lock()
	defer queue.Unlock()

	queue.tail[queue.tailPos] = item
	queue.tailPos++
	queue.length++

	if queue.tailPos == queue.shardSize {
		queue.tailPos = 0
		queue.tailIdx = len(queue.shards)

		buffer := make([][]*amqp.Message, len(queue.shards)+1)
		buffer[queue.tailIdx] = make([]*amqp.Message, queue.shardSize)
		copy(buffer, queue.shards)

		queue.shards = buffer
		queue.tail = queue.shards[queue.tailIdx]
	}
}

// PushHead adds message into queue head
func (queue *SafeQueue) PushHead(item *amqp.Message) {
	queue.Lock()
	defer queue.Unlock()

	if queue.headPos == 0 {
		buffer := make([][]*amqp.Message, len(queue.shards)+1)
		copy(buffer[1:], queue.shards)
		buffer[queue.headIdx] = make([]*amqp.Message, queue.shardSize)

		queue.shards = buffer
		queue.tailIdx++
		queue.headPos = queue.shardSize
		queue.tail = queue.shards[queue.tailIdx]
		queue.head = queue.shards[queue.headIdx]
	}
	queue.length++
	queue.headPos--
	queue.head[queue.headPos] = item
}

// Pop retrieves message from head
func (queue *SafeQueue) Pop() (item *amqp.Message) {
	queue.Lock()
	item = queue.DirtyPop()
	queue.Unlock()
	return
}

// DirtyPop retrieves message from head
// This method is not thread safe
func (queue *SafeQueue) DirtyPop() (item *amqp.Message) {
	item, queue.head[queue.headPos] = queue.head[queue.headPos], nil
	if item == nil {
		return item
	}
	queue.headPos++
	queue.length--
	if queue.headPos == queue.shardSize {
		buffer := make([][]*amqp.Message, len(queue.shards)-1)
		copy(buffer, queue.shards[queue.headIdx+1:])

		queue.shards = buffer

		queue.headPos = 0
		queue.tailIdx--
		queue.head = queue.shards[queue.headIdx]
	}
	return
}

// Length returns queue length
func (queue *SafeQueue) Length() uint64 {
	queue.RLock()
	defer queue.RUnlock()
	return queue.length
}

// DirtyLength returns queue length
// This method is not thread safe
func (queue *SafeQueue) DirtyLength() uint64 {
	return queue.length
}

// HeadItem returns current head message
// This method is not thread safe
func (queue *SafeQueue) HeadItem() (res *amqp.Message) {
	return queue.head[queue.headPos]
}

// DirtyPurge clear queue
// This method is not thread safe
func (queue *SafeQueue) DirtyPurge() {
	queue.shards = [][]*amqp.Message{make([]*amqp.Message, queue.shardSize)}
	queue.tailIdx = 0
	queue.tail = queue.shards[queue.tailIdx]
	queue.headIdx = 0
	queue.head = queue.shards[queue.headIdx]
	queue.length = 0
}

// Purge clear queue
func (queue *SafeQueue) Purge() {
	queue.Lock()
	defer queue.Unlock()
	queue.DirtyPurge()
}

```

`pkg/outputs/amqp/_fixtures/garagemq/server/basicMethods.go`:

```go
package server

import (
	"github.com/rabbitstack/fibratus/pkg/outputs/amqp/_fixtures/garagemq/amqp"
	"github.com/rabbitstack/fibratus/pkg/outputs/amqp/_fixtures/garagemq/consumer"
	"github.com/rabbitstack/fibratus/pkg/outputs/amqp/_fixtures/garagemq/qos"
	"github.com/rabbitstack/fibratus/pkg/outputs/amqp/_fixtures/garagemq/queue"
)

func (channel *Channel) basicRoute(method amqp.Method) *amqp.Error {
	switch method := method.(type) {
	case *amqp.BasicQos:
		return channel.basicQos(method)
	case *amqp.BasicPublish:
		return channel.basicPublish(method)
	case *amqp.BasicConsume:
		return channel.basicConsume(method)
	case *amqp.BasicAck:
		return channel.basicAck(method)
	case *amqp.BasicNack:
		return channel.basicNack(method)
	case *amqp.BasicReject:
		return channel.basicReject(method)
	case *amqp.BasicCancel:
		return channel.basicCancel(method)
	case *amqp.BasicGet:
		return channel.basicGet(method)
	}

	return amqp.NewConnectionError(amqp.NotImplemented, "unable to route basic method "+method.Name(), method.ClassIdentifier(), method.MethodIdentifier())
}

func (channel *Channel) basicQos(method *amqp.BasicQos) (err *amqp.Error) {
	channel.updateQos(method.PrefetchCount, method.PrefetchSize, method.Global)
	channel.SendMethod(&amqp.BasicQosOk{})

	return nil
}

func (channel *Channel) basicAck(method *amqp.BasicAck) (err *amqp.Error) {
	return channel.handleAck(method)
}

func (channel *Channel) basicNack(method *amqp.BasicNack) (err *amqp.Error) {
	return channel.handleReject(method.DeliveryTag, method.Multiple, method.Requeue, method)
}

func (channel *Channel) basicReject(method *amqp.BasicReject) (err *amqp.Error) {
	return channel.handleReject(method.DeliveryTag, false, method.Requeue, method)
}

func (channel *Channel) basicPublish(method *amqp.BasicPublish) (err *amqp.Error) {
	if method.Immediate {
		return amqp.NewChannelError(amqp.NotImplemented, "Immediate = true", method.ClassIdentifier(), method.MethodIdentifier())
	}

	if _, err = channel.getExchangeWithError(method.Exchange, method); err != nil {
		return err
	}

	channel.currentMessage = amqp.NewMessage(method)
	if channel.confirmMode {
		channel.currentMessage.ConfirmMeta = &amqp.ConfirmMeta{
			ChanID:      channel.id,
			ConnID:      channel.conn.id,
			DeliveryTag: channel.nextConfirmDeliveryTag(),
		}
	}
	return nil
}

func (channel *Channel) basicConsume(method *amqp.BasicConsume) (err *amqp.Error) {
	var cmr *consumer.Consumer
	if cmr, err = channel.addConsumer(method); err != nil {
		return err
	}

	if !method.NoWait {
		channel.SendMethod(&amqp.BasicConsumeOk{ConsumerTag: cmr.Tag()})
	}

	cmr.Start()

	return nil
}

func (channel *Channel) basicCancel(method *amqp.BasicCancel) (err *amqp.Error) {
	if _, ok := channel.consumers[method.ConsumerTag]; !ok {
		return amqp.NewChannelError(amqp.NotFound, "Consumer not found", method.ClassIdentifier(), method.MethodIdentifier())
	}
	channel.removeConsumer(method.ConsumerTag)
	channel.SendMethod(&amqp.BasicCancelOk{ConsumerTag: method.ConsumerTag})
	return nil
}

func (channel *Channel) basicGet(method *amqp.BasicGet) (err *amqp.Error) {
	var qu *queue.Queue
	var message *amqp.Message
	if qu, err = channel.getQueueWithError(method.Queue, method); err != nil {
		return err
	}

	if method.NoAck {
		message = qu.Pop()
	} else {
		message = qu.PopQos([]*qos.AmqpQos{channel.qos, channel.conn.qos})
	}

	// how to handle if queue is not empty, but qos triggered and message is nil
	if message == nil {
		channel.SendMethod(&amqp.BasicGetEmpty{})
		return nil
	}

	dTag := channel.NextDeliveryTag()
	if !method.NoAck {
		channel.AddUnackedMessage(dTag, "", qu.GetName(), message)
	} else {
	}

	channel.SendContent(&amqp.BasicGetOk{
		DeliveryTag:  dTag,
		Redelivered:  false,
		Exchange:     message.Exchange,
		RoutingKey:   message.RoutingKey,
		MessageCount: 1,
	}, message)

	return nil
}

```

`pkg/outputs/amqp/_fixtures/garagemq/server/channel.go`:

```go
package server

import (
	"bytes"
	"fmt"
	"github.com/rabbitstack/fibratus/pkg/outputs/amqp/_fixtures/garagemq/amqp"
	"github.com/rabbitstack/fibratus/pkg/outputs/amqp/_fixtures/garagemq/consumer"
	"github.com/rabbitstack/fibratus/pkg/outputs/amqp/_fixtures/garagemq/exchange"
	"github.com/rabbitstack/fibratus/pkg/outputs/amqp/_fixtures/garagemq/pool"
	"github.com/rabbitstack/fibratus/pkg/outputs/amqp/_fixtures/garagemq/qos"
	"github.com/rabbitstack/fibratus/pkg/outputs/amqp/_fixtures/garagemq/queue"
	"sort"
	"sync"
	"sync/atomic"
	"time"

	"github.com/sirupsen/logrus"
	log "github.com/sirupsen/logrus"
)

const (
	channelNew = iota
	channelOpen
	channelClosing
	channelClosed
	channelDelete
)

// Channel is an implementation of the AMQP-channel entity
// Within a single socket connection, there can be multiple
// independent threads of control, called "channels"
type Channel struct {
	active             bool
	confirmMode        bool
	id                 uint16
	conn               *Connection
	server             *Server
	incoming           chan *amqp.Frame
	outgoing           chan *amqp.Frame
	logger             *log.Entry
	status             int
	protoVersion       string
	currentMessage     *amqp.Message
	cmrLock            sync.RWMutex
	consumers          map[string]*consumer.Consumer
	qos                *qos.AmqpQos
	consumerQos        *qos.AmqpQos
	deliveryTag        uint64
	confirmDeliveryTag uint64
	confirmLock        sync.Mutex
	confirmQueue       []*amqp.ConfirmMeta
	ackLock            sync.Mutex
	ackStore           map[uint64]*UnackedMessage
	statusLock         sync.Mutex

	bufferPool *pool.BufferPool

	closeCh chan bool
}

// UnackedMessage represents the unacknowledged message
type UnackedMessage struct {
	cTag  string
	msg   *amqp.Message
	queue string
}

// NewChannel returns new instance of Channel
func NewChannel(id uint16, conn *Connection) *Channel {
	channel := &Channel{
		active: true,
		id:     id,
		conn:   conn,
		server: conn.server,
		// for incoming channel much capacity is good for performance
		// but it is difficult to implement processing already queued frames on shutdown or connection close
		incoming:     make(chan *amqp.Frame, 128),
		outgoing:     conn.outgoing,
		status:       channelNew,
		protoVersion: conn.server.protoVersion,
		consumers:    make(map[string]*consumer.Consumer),
		qos:          qos.NewAmqpQos(0, 0),
		consumerQos:  qos.NewAmqpQos(0, 0),
		ackStore:     make(map[uint64]*UnackedMessage),
		confirmQueue: make([]*amqp.ConfirmMeta, 0),
		closeCh:      make(chan bool),
		bufferPool:   pool.NewBufferPool(0),
	}

	channel.logger = log.WithFields(log.Fields{
		"connectionId": conn.id,
		"channelId":    id,
	})

	return channel
}

func (channel *Channel) start() {
	if channel.id == 0 {
		go channel.connectionStart()
	}

	go channel.handleIncoming()
}

func (channel *Channel) handleIncoming() {
	buffer := bytes.NewReader([]byte{})

	// TODO
	// @spec-note
	// After sending channel.close, any received methods except Close and Close­OK MUST be discarded.
	// The response to receiving a Close after sending Close must be to send Close­Ok.
	for {
		select {
		case <-channel.closeCh:
			channel.close()
			return
		case frame := <-channel.incoming:
			if frame == nil {
				// channel.incoming closed by connection
				return
			}

			switch frame.Type {
			case amqp.FrameMethod:
				buffer.Reset(frame.Payload)
				method, err := amqp.ReadMethod(buffer, channel.protoVersion)
				channel.logger.Debug("Incoming method <- " + method.Name())
				if err != nil {
					channel.logger.WithError(err).Error("Error on handling frame")
					channel.sendError(amqp.NewConnectionError(amqp.FrameError, err.Error(), 0, 0))
				}

				if err := channel.handleMethod(method); err != nil {
					channel.sendError(err)
				}
			case amqp.FrameHeader:
				if err := channel.handleContentHeader(frame); err != nil {
					channel.sendError(err)
				}
			case amqp.FrameBody:
				if err := channel.handleContentBody(frame); err != nil {
					channel.sendError(err)
				}
			}
		}
	}
}

func (channel *Channel) sendError(err *amqp.Error) {
	channel.logger.Error(err)
	switch err.ErrorType {
	case amqp.ErrorOnChannel:
		channel.status = channelClosing
		channel.SendMethod(&amqp.ChannelClose{
			ReplyCode: err.ReplyCode,
			ReplyText: err.ReplyText,
			ClassID:   err.ClassID,
			MethodID:  err.MethodID,
		})
	case amqp.ErrorOnConnection:
		ch := channel.conn.getChannel(0)
		if ch != nil {
			ch.SendMethod(&amqp.ConnectionClose{
				ReplyCode: err.ReplyCode,
				ReplyText: err.ReplyText,
				ClassID:   err.ClassID,
				MethodID:  err.MethodID,
			})
		}
	}
}

func (channel *Channel) handleMethod(method amqp.Method) *amqp.Error {
	switch method.ClassIdentifier() {
	case amqp.ClassConnection:
		return channel.connectionRoute(method)
	case amqp.ClassChannel:
		return channel.channelRoute(method)
	case amqp.ClassBasic:
		return channel.basicRoute(method)
	case amqp.ClassExchange:
		return channel.exchangeRoute(method)
	case amqp.ClassQueue:
		return channel.queueRoute(method)
	case amqp.ClassConfirm:
		return channel.confirmRoute(method)
	}

	return nil
}

func (channel *Channel) handleContentHeader(headerFrame *amqp.Frame) *amqp.Error {
	reader := bytes.NewReader(headerFrame.Payload)
	var err error
	if channel.currentMessage == nil {
		return amqp.NewConnectionError(amqp.FrameError, "unexpected content header frame", 0, 0)
	}

	if channel.currentMessage.Header != nil {
		return amqp.NewConnectionError(amqp.FrameError, "unexpected content header frame - header already exists", 0, 0)
	}

	if channel.currentMessage.Header, err = amqp.ReadContentHeader(reader, channel.protoVersion); err != nil {
		return amqp.NewConnectionError(amqp.FrameError, "error on parsing content header frame", 0, 0)
	}

	return nil
}

func (channel *Channel) handleContentBody(bodyFrame *amqp.Frame) *amqp.Error {
	if channel.currentMessage == nil {
		return amqp.NewConnectionError(amqp.FrameError, "unexpected content body frame", 0, 0)
	}

	if channel.currentMessage.Header == nil {
		return amqp.NewConnectionError(amqp.FrameError, "unexpected content body frame - no header yet", 0, 0)
	}

	channel.currentMessage.Append(bodyFrame)

	if channel.currentMessage.BodySize < channel.currentMessage.Header.BodySize {
		return nil
	}

	vhost := channel.conn.GetVirtualHost()
	message := channel.currentMessage
	ex := vhost.GetExchange(message.Exchange)
	if ex == nil {
		channel.SendContent(
			&amqp.BasicReturn{ReplyCode: amqp.NoRoute, ReplyText: "No route", Exchange: message.Exchange, RoutingKey: message.RoutingKey},
			message,
		)

		channel.addConfirm(message.ConfirmMeta)

		return nil
	}
	matchedQueues := ex.GetMatchedQueues(message)

	if len(matchedQueues) == 0 {
		if message.Mandatory {
			channel.SendContent(
				&amqp.BasicReturn{ReplyCode: amqp.NoRoute, ReplyText: "No route", Exchange: message.Exchange, RoutingKey: message.RoutingKey},
				message,
			)
		}

		channel.addConfirm(message.ConfirmMeta)

		return nil
	}

	if channel.confirmMode {
		message.ConfirmMeta.ExpectedConfirms = len(matchedQueues)
	}

	for queueName := range matchedQueues {
		qu := channel.conn.GetVirtualHost().GetQueue(queueName)
		if qu == nil {
			if message.Mandatory {
				channel.SendContent(
					&amqp.BasicReturn{ReplyCode: amqp.NoRoute, ReplyText: "No route", Exchange: message.Exchange, RoutingKey: message.RoutingKey},
					message,
				)
			}

			channel.addConfirm(message.ConfirmMeta)

			return nil
		}

		qu.Push(message)

		if channel.confirmMode && message.ConfirmMeta.CanConfirm() && !message.IsPersistent() {
			channel.addConfirm(message.ConfirmMeta)
		}
	}
	return nil
}

// SendMethod send method to client
// Method will be packed into frame and send to outgoing channel
func (channel *Channel) SendMethod(method amqp.Method) {
	var rawMethod = channel.bufferPool.Get()
	if err := amqp.WriteMethod(rawMethod, method, channel.server.protoVersion); err != nil {
		logrus.WithError(err).Error("Error")
	}

	closeAfter := method.ClassIdentifier() == amqp.ClassConnection && method.MethodIdentifier() == amqp.MethodConnectionCloseOk

	channel.logger.Debug("Outgoing -> " + method.Name())

	payload := make([]byte, rawMethod.Len())
	copy(payload, rawMethod.Bytes())
	channel.bufferPool.Put(rawMethod)

	channel.sendOutgoing(&amqp.Frame{Type: byte(amqp.FrameMethod), ChannelID: channel.id, Payload: payload, CloseAfter: closeAfter, Sync: method.Sync()})
}

func (channel *Channel) sendOutgoing(frame *amqp.Frame) {
	select {
	case <-channel.conn.ctx.Done():
		if channel.id == 0 {
			close(channel.outgoing)
		}
	case channel.outgoing <- frame:
	}
}

// SendContent send message to consumers or returns to publishers
func (channel *Channel) SendContent(method amqp.Method, message *amqp.Message) {
	channel.SendMethod(method)

	var rawHeader = channel.bufferPool.Get()
	amqp.WriteContentHeader(rawHeader, message.Header, channel.server.protoVersion)

	payload := make([]byte, rawHeader.Len())
	copy(payload, rawHeader.Bytes())
	channel.bufferPool.Put(rawHeader)

	channel.sendOutgoing(&amqp.Frame{Type: byte(amqp.FrameHeader), ChannelID: channel.id, Payload: payload, CloseAfter: false})

	for _, payload := range message.Body {
		payload.ChannelID = channel.id
		channel.sendOutgoing(payload)
	}

	switch method.(type) {
	case *amqp.BasicDeliver:
	}
}

func (channel *Channel) addConfirm(meta *amqp.ConfirmMeta) {
	if !channel.confirmMode {
		return
	}
	channel.confirmLock.Lock()
	defer channel.confirmLock.Unlock()
	channel.statusLock.Lock()
	defer channel.statusLock.Unlock()

	if channel.status == channelClosed {
		return
	}
	channel.confirmQueue = append(channel.confirmQueue, meta)
}

func (channel *Channel) sendConfirms() {
	tick := time.Tick(20 * time.Millisecond)
	channel.statusLock.Lock()
	defer channel.statusLock.Unlock()
	for range tick {
		if channel.status == channelClosed {
			return
		}
		channel.confirmLock.Lock()
		currentConfirms := channel.confirmQueue
		channel.confirmQueue = make([]*amqp.ConfirmMeta, 0)
		channel.confirmLock.Unlock()

		for _, confirm := range currentConfirms {
			channel.SendMethod(&amqp.BasicAck{
				DeliveryTag: confirm.DeliveryTag,
				Multiple:    false,
			})
		}
	}
}

func (channel *Channel) addConsumer(method *amqp.BasicConsume) (cmr *consumer.Consumer, err *amqp.Error) {
	channel.cmrLock.Lock()
	defer channel.cmrLock.Unlock()

	var qu *queue.Queue
	if qu, err = channel.getQueueWithError(method.Queue, method); err != nil {
		return nil, err
	}

	var consumerQos []*qos.AmqpQos
	if channel.server.protoVersion == amqp.Proto091 {
		consumerQos = []*qos.AmqpQos{channel.qos, channel.conn.qos}
	} else {
		cmrQos := channel.consumerQos.Copy()
		consumerQos = []*qos.AmqpQos{channel.qos, cmrQos}
	}

	cmr = consumer.NewConsumer(method.Queue, method.ConsumerTag, method.NoAck, channel, qu, consumerQos)
	if _, ok := channel.consumers[cmr.Tag()]; ok {
		return nil, amqp.NewChannelError(amqp.NotAllowed, fmt.Sprintf("Consumer with tag '%s' already exists", cmr.Tag()), method.ClassIdentifier(), method.MethodIdentifier())
	}

	if quErr := qu.AddConsumer(cmr, method.Exclusive); quErr != nil {
		return nil, amqp.NewChannelError(amqp.AccessRefused, quErr.Error(), method.ClassIdentifier(), method.MethodIdentifier())
	}
	channel.consumers[cmr.Tag()] = cmr

	return cmr, nil
}

func (channel *Channel) removeConsumer(cTag string) {
	channel.cmrLock.Lock()
	defer channel.cmrLock.Unlock()
	if cmr, ok := channel.consumers[cTag]; ok {
		cmr.Stop()
		delete(channel.consumers, cmr.Tag())
	}
}

func (channel *Channel) close() {
	channel.cmrLock.Lock()
	for _, cmr := range channel.consumers {
		cmr.Stop()
		delete(channel.consumers, cmr.Tag())
		channel.logger.WithFields(log.Fields{
			"consumerTag": cmr.Tag(),
		}).Info("Consumer stopped")
	}
	channel.cmrLock.Unlock()
	if channel.id > 0 {
		channel.handleReject(0, true, true, &amqp.BasicNack{})
	}
	channel.statusLock.Lock()
	defer channel.statusLock.Unlock()
	channel.status = channelClosed
	channel.logger.Info("Channel closed")
}

func (channel *Channel) delete() {
	channel.closeCh <- true
	channel.statusLock.Lock()
	defer channel.statusLock.Unlock()
	channel.status = channelDelete
}

func (channel *Channel) updateQos(prefetchCount uint16, prefetchSize uint32, global bool) {
	if channel.server.protoVersion == amqp.Proto091 {
		if global {
			channel.conn.qos.Update(prefetchCount, prefetchSize)
		} else {
			channel.qos.Update(prefetchCount, prefetchSize)
		}
	} else {
		if global {
			channel.qos.Update(prefetchCount, prefetchSize)
		} else {
			channel.consumerQos.Update(prefetchCount, prefetchSize)
		}
	}
}

func (channel *Channel) GetQos() *qos.AmqpQos {
	return channel.qos
}

// NextDeliveryTag returns next delivery tag for current channel
func (channel *Channel) NextDeliveryTag() uint64 {
	return atomic.AddUint64(&channel.deliveryTag, 1)
}

func (channel *Channel) nextConfirmDeliveryTag() uint64 {
	return atomic.AddUint64(&channel.confirmDeliveryTag, 1)
}

// AddUnackedMessage add message to unacked queue
func (channel *Channel) AddUnackedMessage(dTag uint64, cTag string, queue string, message *amqp.Message) {
	channel.ackLock.Lock()
	defer channel.ackLock.Unlock()
	channel.ackStore[dTag] = &UnackedMessage{
		cTag:  cTag,
		msg:   message,
		queue: queue,
	}
}

func (channel *Channel) handleAck(method *amqp.BasicAck) *amqp.Error {
	channel.ackLock.Lock()
	defer channel.ackLock.Unlock()
	var uMsg *UnackedMessage
	var msgFound bool

	if method.Multiple {
		for tag, uMsg := range channel.ackStore {
			if method.DeliveryTag == 0 || tag <= method.DeliveryTag {
				channel.ackMsg(uMsg, tag)
			}
		}

		return nil
	}

	if uMsg, msgFound = channel.ackStore[method.DeliveryTag]; !msgFound {
		return amqp.NewChannelError(amqp.PreconditionFailed, fmt.Sprintf("Delivery tag [%d] not found", method.DeliveryTag), method.ClassIdentifier(), method.MethodIdentifier())
	}

	channel.ackMsg(uMsg, method.DeliveryTag)

	return nil
}

func (channel *Channel) ackMsg(unackedMessage *UnackedMessage, deliveryTag uint64) {
	delete(channel.ackStore, deliveryTag)
	q := channel.conn.GetVirtualHost().GetQueue(unackedMessage.queue)
	if q != nil {
		q.AckMsg(unackedMessage.msg)
	}

	channel.decQosAndConsumerNext(unackedMessage)
}

func (channel *Channel) handleReject(deliveryTag uint64, multiple bool, requeue bool, method amqp.Method) *amqp.Error {
	channel.ackLock.Lock()
	defer channel.ackLock.Unlock()
	var uMsg *UnackedMessage
	var msgFound bool

	if multiple {
		deliveryTags := make([]uint64, 0)
		for dTag := range channel.ackStore {
			deliveryTags = append(deliveryTags, dTag)
		}
		sort.Slice(
			deliveryTags,
			func(i, j int) bool {
				return deliveryTags[i] > deliveryTags[j]
			},
		)
		for _, tag := range deliveryTags {
			if deliveryTag == 0 || tag <= deliveryTag {
				channel.rejectMsg(channel.ackStore[tag], tag, requeue)
			}
		}

		return nil
	}

	if uMsg, msgFound = channel.ackStore[deliveryTag]; !msgFound {
		return amqp.NewChannelError(amqp.PreconditionFailed, fmt.Sprintf("Delivery tag [%d] not found", deliveryTag), method.ClassIdentifier(), method.MethodIdentifier())
	}

	channel.rejectMsg(uMsg, deliveryTag, requeue)

	return nil
}

func (channel *Channel) rejectMsg(unackedMessage *UnackedMessage, deliveryTag uint64, requeue bool) {
	delete(channel.ackStore, deliveryTag)
	qu := channel.conn.GetVirtualHost().GetQueue(unackedMessage.queue)

	if qu != nil {
		if requeue {
			qu.Requeue(unackedMessage.msg)
		} else {
			qu.AckMsg(unackedMessage.msg)
		}
	} else {
		// TODO When a queue is deleted any pending messages are sent to a dead­letter
	}

	channel.decQosAndConsumerNext(unackedMessage)
}

func (channel *Channel) decQosAndConsumerNext(unackedMessage *UnackedMessage) {
	channel.cmrLock.RLock()
	if cmr, ok := channel.consumers[unackedMessage.cTag]; ok {
		cmr.Consume()

		for _, amqpQos := range cmr.Qos() {
			amqpQos.Dec(1, uint32(unackedMessage.msg.BodySize))
		}
	} else {
		channel.qos.Dec(1, uint32(unackedMessage.msg.BodySize))
		channel.conn.qos.Dec(1, uint32(unackedMessage.msg.BodySize))
	}
	channel.cmrLock.RUnlock()
}

func (channel *Channel) getExchangeWithError(exchangeName string, method amqp.Method) (ex *exchange.Exchange, err *amqp.Error) {
	ex = channel.conn.GetVirtualHost().GetExchange(exchangeName)
	if ex == nil {
		return nil, amqp.NewChannelError(
			amqp.NotFound,
			fmt.Sprintf("exchange '%s' not found", exchangeName),
			method.ClassIdentifier(),
			method.MethodIdentifier(),
		)
	}
	return ex, nil
}

func (channel *Channel) getQueueWithError(queueName string, method amqp.Method) (queue *queue.Queue, err *amqp.Error) {
	qu := channel.conn.GetVirtualHost().GetQueue(queueName)
	if qu == nil || !qu.IsActive() {
		return nil, amqp.NewChannelError(
			amqp.NotFound,
			fmt.Sprintf("queue '%s' not found", queueName),
			method.ClassIdentifier(),
			method.MethodIdentifier(),
		)
	}
	return qu, nil
}

func (channel *Channel) checkQueueLockWithError(qu *queue.Queue, method amqp.Method) *amqp.Error {
	if qu == nil {
		return nil
	}
	if qu.IsExclusive() && qu.ConnID() != channel.conn.id {
		return amqp.NewChannelError(
			amqp.ResourceLocked,
			fmt.Sprintf("queue '%s' is locked to another connection", qu.GetName()),
			method.ClassIdentifier(),
			method.MethodIdentifier(),
		)
	}

	return nil
}

func (channel *Channel) isActive() bool {
	return channel.active
}

func (channel *Channel) changeFlow(active bool) {
	if channel.active == active {
		return
	}
	channel.active = active

	channel.cmrLock.RLock()
	if channel.active {
		for _, cmr := range channel.consumers {
			cmr.UnPause()
			cmr.Consume()
		}
	} else {
		for _, cmr := range channel.consumers {
			cmr.Pause()
		}
	}
	channel.cmrLock.RUnlock()
}

// GetConsumersCount returns consumers count on channel
func (channel *Channel) GetConsumersCount() int {
	return len(channel.consumers)
}

```

`pkg/outputs/amqp/_fixtures/garagemq/server/channelMethods.go`:

```go
package server

import (
	"github.com/rabbitstack/fibratus/pkg/outputs/amqp/_fixtures/garagemq/amqp"
)

func (channel *Channel) channelRoute(method amqp.Method) *amqp.Error {
	switch method := method.(type) {
	case *amqp.ChannelOpen:
		return channel.channelOpen(method)
	case *amqp.ChannelClose:
		return channel.channelClose(method)
	case *amqp.ChannelCloseOk:
		return channel.channelCloseOk(method)
	case *amqp.ChannelFlow:
		return channel.channelFlow(method)
	}

	return amqp.NewConnectionError(amqp.NotImplemented, "unable to route channel method "+method.Name(), method.ClassIdentifier(), method.MethodIdentifier())
}

func (channel *Channel) channelOpen(method *amqp.ChannelOpen) (err *amqp.Error) {
	// @spec-note
	// The client MUST NOT use this method on an already­opened channel.
	if channel.status == channelOpen {
		return amqp.NewConnectionError(amqp.ChannelError, "channel already open", method.ClassIdentifier(), method.MethodIdentifier())
	}

	channel.SendMethod(&amqp.ChannelOpenOk{})
	channel.status = channelOpen

	return nil
}

func (channel *Channel) channelClose(method *amqp.ChannelClose) (err *amqp.Error) {
	channel.status = channelClosed
	channel.SendMethod(&amqp.ChannelCloseOk{})
	channel.close()
	return nil
}

func (channel *Channel) channelCloseOk(method *amqp.ChannelCloseOk) (err *amqp.Error) {
	channel.status = channelClosed
	return nil
}

func (channel *Channel) channelFlow(method *amqp.ChannelFlow) (err *amqp.Error) {
	channel.changeFlow(method.Active)
	channel.SendMethod(&amqp.ChannelFlowOk{Active: method.Active})
	return nil
}

```

`pkg/outputs/amqp/_fixtures/garagemq/server/confirmMethods.go`:

```go
package server

import (
	"github.com/rabbitstack/fibratus/pkg/outputs/amqp/_fixtures/garagemq/amqp"
)

func (channel *Channel) confirmRoute(method amqp.Method) *amqp.Error {
	switch method := method.(type) {
	case *amqp.ConfirmSelect:
		return channel.confirmSelect(method)
	}

	return amqp.NewConnectionError(amqp.NotImplemented, "unable to route channel method "+method.Name(), method.ClassIdentifier(), method.MethodIdentifier())
}

func (channel *Channel) confirmSelect(method *amqp.ConfirmSelect) (err *amqp.Error) {
	channel.confirmMode = true
	go channel.sendConfirms()
	if !method.Nowait {
		channel.SendMethod(&amqp.ConfirmSelectOk{})
	}
	return nil
}

```

`pkg/outputs/amqp/_fixtures/garagemq/server/connection.go`:

```go
package server

import (
	"bufio"
	"bytes"
	"context"
	"github.com/rabbitstack/fibratus/pkg/outputs/amqp/_fixtures/garagemq/amqp"
	"github.com/rabbitstack/fibratus/pkg/outputs/amqp/_fixtures/garagemq/qos"
	"net"
	"sort"
	"strings"
	"sync"
	"sync/atomic"
	"time"

	log "github.com/sirupsen/logrus"
)

// connection status list
const (
	ConnStart = iota
	ConnStartOK
	ConnSecure
	ConnSecureOK
	ConnTune
	ConnTuneOK
	ConnOpen
	ConnOpenOK
	ConnCloseOK
	ConnClosed
)

// From https://github.com/rabbitmq/rabbitmq-common/blob/master/src/rabbit_writer.erl
// When the amount of protocol method data buffered exceeds
// this threshold, a socket flush is performed.
//
// This magic number is the tcp-over-ethernet MSS (1460) minus the
// minimum size of a AMQP 0-9-1 basic.deliver method frame (24) plus basic
// content header (22). The idea is that we want to flush just before
// exceeding the MSS.
const flushThreshold = 1414

// Connection represents AMQP-connection
type Connection struct {
	id               uint64
	server           *Server
	netConn          *net.TCPConn
	logger           *log.Entry
	channelsLock     sync.RWMutex
	channels         map[uint16]*Channel
	outgoing         chan *amqp.Frame
	clientProperties *amqp.Table
	maxChannels      uint16
	maxFrameSize     uint32
	statusLock       sync.RWMutex
	status           int
	qos              *qos.AmqpQos
	virtualHost      *VirtualHost
	vhostName        string
	closeCh          chan bool
	userName         string

	wg        *sync.WaitGroup
	ctx       context.Context
	cancelCtx context.CancelFunc

	heartbeatInterval uint16
	heartbeatTimeout  uint16
	heartbeatTimer    *time.Ticker

	connLock sync.Mutex

	lastOutgoingTS chan time.Time
}

// NewConnection returns new instance of amqp Connection
func NewConnection(server *Server, netConn *net.TCPConn) (connection *Connection) {
	connection = &Connection{
		id:                atomic.AddUint64(&server.connSeq, 1),
		server:            server,
		netConn:           netConn,
		channels:          make(map[uint16]*Channel),
		outgoing:          make(chan *amqp.Frame, 128),
		maxChannels:       server.config.Connection.ChannelsMax,
		maxFrameSize:      server.config.Connection.FrameMaxSize,
		qos:               qos.NewAmqpQos(0, 0),
		closeCh:           make(chan bool, 2),
		wg:                &sync.WaitGroup{},
		lastOutgoingTS:    make(chan time.Time),
		heartbeatInterval: 10,
	}

	connection.logger = log.WithFields(log.Fields{
		"connectionId": connection.id,
	})

	return
}

func (conn *Connection) close() {
	conn.statusLock.Lock()
	if conn.status == ConnClosed {
		conn.statusLock.Unlock()
		return
	}

	if conn.heartbeatTimer != nil {
		conn.heartbeatTimer.Stop()
	}

	conn.status = ConnClosed
	conn.statusLock.Unlock()

	// @todo should we chech for errors here? And what should we do if error occur
	_ = conn.netConn.Close()

	if conn.cancelCtx != nil {
		conn.cancelCtx()
	}

	conn.wg.Wait()

	// channel0 should we be closed at the end
	channelIds := make([]int, 0)
	conn.channelsLock.Lock()
	for chID := range conn.channels {
		channelIds = append(channelIds, int(chID))
	}
	sort.Sort(sort.Reverse(sort.IntSlice(channelIds)))
	for _, chID := range channelIds {
		channel := conn.channels[uint16(chID)]
		channel.delete()
		delete(conn.channels, uint16(chID))
	}
	conn.channelsLock.Unlock()
	conn.clearQueues()

	conn.logger.WithFields(log.Fields{
		"vhost": conn.vhostName,
		"from":  conn.netConn.RemoteAddr(),
	}).Info("Connection closed")
	conn.server.removeConnection(conn.id)

	conn.closeCh <- true
}

func (conn *Connection) getChannel(id uint16) *Channel {
	conn.channelsLock.Lock()
	channel := conn.channels[id]
	conn.channelsLock.Unlock()
	return channel
}

func (conn *Connection) safeClose(wg *sync.WaitGroup) {
	defer wg.Done()

	ch := conn.getChannel(0)
	if ch == nil {
		return
	}
	ch.SendMethod(&amqp.ConnectionClose{
		ReplyCode: amqp.ConnectionForced,
		ReplyText: "Server shutdown",
		ClassID:   0,
		MethodID:  0,
	})

	// let clients proper handle connection closing in 10 sec
	timeOut := time.After(10 * time.Second)

	select {
	case <-timeOut:
		conn.close()
		return
	case <-conn.closeCh:
		return
	}
}

func (conn *Connection) clearQueues() {
	virtualHost := conn.GetVirtualHost()
	if virtualHost == nil {
		// it is possible when conn close before open, for example login failure
		return
	}
	for _, queue := range virtualHost.GetQueues() {
		if queue.IsExclusive() && queue.ConnID() == conn.id {
			virtualHost.DeleteQueue(queue.GetName(), false, false)
		}
	}
}

func (conn *Connection) handleConnection() {
	buf := make([]byte, 8)
	_, err := conn.netConn.Read(buf)
	if err != nil {
		conn.logger.WithError(err).WithFields(log.Fields{
			"read buffer": buf,
		}).Error("Error on read protocol header")
		conn.close()
		return
	}

	// @spec-note
	// If the server cannot support the protocol specified in the protocol header,
	// it MUST respond with a valid protocol header and then close the socket connection.
	// The client MUST start a new connection by sending a protocol header
	if !bytes.Equal(buf, amqp.AmqpHeader) {
		conn.logger.WithFields(log.Fields{
			"given":     buf,
			"supported": amqp.AmqpHeader,
		}).Warn("Unsupported protocol")
		_, _ = conn.netConn.Write(amqp.AmqpHeader)
		conn.close()
		return
	}

	conn.ctx, conn.cancelCtx = context.WithCancel(context.Background())

	channel := NewChannel(0, conn)
	conn.channelsLock.Lock()
	conn.channels[channel.id] = channel
	conn.channelsLock.Unlock()

	channel.start()
	conn.wg.Add(1)
	go conn.handleOutgoing()
	conn.wg.Add(1)
	go conn.handleIncoming()
}

func (conn *Connection) handleOutgoing() {
	defer func() {
		close(conn.lastOutgoingTS)
		conn.wg.Done()
		conn.close()
	}()

	var err error
	buffer := bufio.NewWriterSize(conn.netConn, 128<<10)
	for {
		select {
		case <-conn.ctx.Done():
			return
		case frame := <-conn.outgoing:
			if frame == nil {
				return
			}

			if err = amqp.WriteFrame(buffer, frame); err != nil && !conn.isClosedError(err) {
				conn.logger.WithError(err).Warn("writing frame")
				return
			}

			if frame.CloseAfter {
				if err = buffer.Flush(); err != nil && !conn.isClosedError(err) {
					conn.logger.WithError(err).Warn("writing frame")
				}
				return
			}

			if frame.Sync {
				if err = buffer.Flush(); err != nil && !conn.isClosedError(err) {
					conn.logger.WithError(err).Warn("writing frame")
					return
				}
			} else {
				if err = conn.mayBeFlushBuffer(buffer); err != nil && !conn.isClosedError(err) {
					conn.logger.WithError(err).Warn("writing frame")
					return
				}
			}

			select {
			case conn.lastOutgoingTS <- time.Now():
			default:
			}
		}
	}
}

func (conn *Connection) mayBeFlushBuffer(buffer *bufio.Writer) (err error) {
	if buffer.Buffered() >= flushThreshold {
		if err = buffer.Flush(); err != nil {
			return err
		}
	}

	if len(conn.outgoing) == 0 {
		// outgoing channel is buffered and we can check is here more messages for store into buffer
		// if nothing to store into buffer - we flush
		if err = buffer.Flush(); err != nil {
			return err
		}
	}
	return
}

func (conn *Connection) handleIncoming() {
	defer func() {
		conn.wg.Done()
		conn.close()
	}()

	buffer := bufio.NewReaderSize(conn.netConn, 128<<10)

	for {
		// TODO
		// @spec-note
		// After sending connection.close , any received methods except Close and Close­OK MUST be discarded.
		// The response to receiving a Close after sending Close must be to send Close­Ok.
		frame, err := amqp.ReadFrame(buffer)
		if err != nil {
			if err.Error() != "EOF" && !conn.isClosedError(err) {
				conn.logger.WithError(err).Warn("reading frame")
			}
			return
		}
		conn.statusLock.Lock()
		if conn.status < ConnOpen && frame.ChannelID != 0 {
			conn.statusLock.Unlock()
			conn.logger.WithError(err).Error("Frame not allowed for unopened connection")
			return
		}
		conn.statusLock.Unlock()

		conn.channelsLock.RLock()
		channel, ok := conn.channels[frame.ChannelID]
		conn.channelsLock.RUnlock()

		if !ok {
			channel = NewChannel(frame.ChannelID, conn)

			conn.channelsLock.Lock()
			conn.channels[frame.ChannelID] = channel
			conn.channelsLock.Unlock()

			channel.start()
		}

		if conn.heartbeatTimeout > 0 {
			if err = conn.netConn.SetReadDeadline(time.Now().Add(time.Duration(conn.heartbeatTimeout) * time.Second)); err != nil {
				conn.logger.WithError(err).Warn("reading frame")
				return
			}
		}

		if frame.Type == amqp.FrameHeartbeat && frame.ChannelID != 0 {
			return
		}

		select {
		case <-conn.ctx.Done():
			close(channel.incoming)
			return
		case channel.incoming <- frame:
		}
	}
}

func (conn *Connection) heartBeater() {
	interval := time.Duration(conn.heartbeatInterval) * time.Second
	conn.heartbeatTimer = time.NewTicker(interval)

	var (
		ok     bool
		lastTs = time.Now()
	)

	heartbeatFrame := &amqp.Frame{Type: byte(amqp.FrameHeartbeat), ChannelID: 0, Payload: []byte{}, CloseAfter: false, Sync: true}

	go func() {
		for {
			select {
			case lastTs, ok = <-conn.lastOutgoingTS:
				if !ok {
					return
				}
			}
		}

	}()

	for tickTime := range conn.heartbeatTimer.C {
		if tickTime.Sub(lastTs) >= interval-time.Second {
			conn.outgoing <- heartbeatFrame
		}
	}
}

func (conn *Connection) isClosedError(err error) bool {
	// See: https://github.com/golang/go/issues/4373
	return err != nil && strings.Contains(err.Error(), "use of closed network connection")
}

func (conn *Connection) GetVirtualHost() *VirtualHost {
	return conn.virtualHost
}

func (conn *Connection) GetRemoteAddr() net.Addr {
	return conn.netConn.RemoteAddr()
}

func (conn *Connection) GetChannels() map[uint16]*Channel {
	return conn.channels
}

func (conn *Connection) GetID() uint64 {
	return conn.id
}

func (conn *Connection) GetUsername() string {
	return conn.userName
}

```

`pkg/outputs/amqp/_fixtures/garagemq/server/connectionMethods.go`:

```go
package server

import (
	"github.com/rabbitstack/fibratus/pkg/outputs/amqp/_fixtures/garagemq/amqp"
	"github.com/rabbitstack/fibratus/pkg/outputs/amqp/_fixtures/garagemq/auth"
	"os"
	"runtime"
)

func (channel *Channel) connectionRoute(method amqp.Method) *amqp.Error {
	switch method := method.(type) {
	case *amqp.ConnectionStartOk:
		return channel.connectionStartOk(method)
	case *amqp.ConnectionTuneOk:
		return channel.connectionTuneOk(method)
	case *amqp.ConnectionOpen:
		return channel.connectionOpen(method)
	case *amqp.ConnectionClose:
		return channel.connectionClose(method)
	case *amqp.ConnectionCloseOk:
		return channel.connectionCloseOk(method)
	}

	return amqp.NewConnectionError(amqp.NotImplemented, "unable to route connection method", method.ClassIdentifier(), method.MethodIdentifier())
}

func (channel *Channel) connectionStart() {
	var capabilities = amqp.Table{}
	capabilities["publisher_confirms"] = true
	capabilities["exchange_exchange_bindings"] = false
	capabilities["basic.nack"] = true
	capabilities["consumer_cancel_notify"] = true
	capabilities["connection.blocked"] = false
	capabilities["consumer_priorities"] = false
	capabilities["authentication_failure_close"] = true
	capabilities["per_consumer_qos"] = true

	var serverProps = amqp.Table{}
	serverProps["product"] = "garagemq"
	serverProps["version"] = "0.1"
	serverProps["copyright"] = "Alexander Valinurov, 2018"
	serverProps["platform"] = runtime.GOARCH
	serverProps["capabilities"] = capabilities
	host, err := os.Hostname()
	if err != nil {
		serverProps["host"] = "UnknownHostError"
	} else {
		serverProps["host"] = host
	}

	var method = amqp.ConnectionStart{VersionMajor: 0, VersionMinor: 9, ServerProperties: &serverProps, Mechanisms: []byte("PLAIN"), Locales: []byte("en_US")}
	channel.SendMethod(&method)

	channel.conn.statusLock.Lock()
	defer channel.conn.statusLock.Unlock()
	channel.conn.status = ConnStart
}

func (channel *Channel) connectionStartOk(method *amqp.ConnectionStartOk) *amqp.Error {
	channel.conn.status = ConnStartOK

	var saslData auth.SaslData
	var err error
	if saslData, err = auth.ParsePlain(method.Response); err != nil {
		return amqp.NewConnectionError(amqp.NotAllowed, "login failure", method.ClassIdentifier(), method.MethodIdentifier())
	}

	if method.Mechanism != auth.SaslPlain {
		channel.conn.close()
	}

	if !channel.server.checkAuth(saslData) {
		return amqp.NewConnectionError(amqp.NotAllowed, "login failure", method.ClassIdentifier(), method.MethodIdentifier())
	}
	channel.conn.userName = saslData.Username
	channel.conn.clientProperties = method.ClientProperties

	// @todo Send HeartBeat 0 cause not supported yet
	channel.SendMethod(&amqp.ConnectionTune{
		ChannelMax: channel.conn.maxChannels,
		FrameMax:   channel.conn.maxFrameSize,
		Heartbeat:  channel.conn.heartbeatInterval,
	})
	channel.conn.statusLock.Lock()
	defer channel.conn.statusLock.Unlock()
	channel.conn.status = ConnTune

	return nil
}

func (channel *Channel) connectionTuneOk(method *amqp.ConnectionTuneOk) *amqp.Error {
	channel.conn.statusLock.Lock()
	defer channel.conn.statusLock.Unlock()
	channel.conn.status = ConnTuneOK

	if method.ChannelMax > channel.conn.maxChannels || method.FrameMax > channel.conn.maxFrameSize {
		channel.conn.close()
		return nil
	}

	channel.conn.maxChannels = method.ChannelMax
	channel.conn.maxFrameSize = method.FrameMax

	if method.Heartbeat > 0 {
		if method.Heartbeat < channel.conn.heartbeatInterval {
			channel.conn.heartbeatInterval = method.Heartbeat
		}
		channel.conn.heartbeatTimeout = channel.conn.heartbeatInterval * 3
		go channel.conn.heartBeater()
	}

	return nil
}

func (channel *Channel) connectionOpen(method *amqp.ConnectionOpen) *amqp.Error {
	channel.conn.status = ConnOpen
	var vhostFound bool
	if channel.conn.virtualHost, vhostFound = channel.server.vhosts[method.VirtualHost]; !vhostFound {
		return amqp.NewConnectionError(amqp.InvalidPath, "virtualHost '"+method.VirtualHost+"' does not exist", method.ClassIdentifier(), method.MethodIdentifier())
	}

	channel.conn.vhostName = method.VirtualHost

	channel.SendMethod(&amqp.ConnectionOpenOk{})
	channel.conn.statusLock.Lock()
	defer channel.conn.statusLock.Unlock()
	channel.conn.status = ConnOpenOK

	channel.logger.Info("AMQP connection open")
	return nil
}

func (channel *Channel) connectionClose(method *amqp.ConnectionClose) *amqp.Error {
	channel.logger.Infof("Connection closed by client, reason - [%d] %s", method.ReplyCode, method.ReplyText)
	channel.SendMethod(&amqp.ConnectionCloseOk{})
	return nil
}

func (channel *Channel) connectionCloseOk(method *amqp.ConnectionCloseOk) *amqp.Error {
	go channel.conn.close()
	return nil
}

```

`pkg/outputs/amqp/_fixtures/garagemq/server/exchangeMethods.go`:

```go
package server

import (
	"fmt"
	"github.com/rabbitstack/fibratus/pkg/outputs/amqp/_fixtures/garagemq/amqp"
	"github.com/rabbitstack/fibratus/pkg/outputs/amqp/_fixtures/garagemq/exchange"
	"strings"
)

func (channel *Channel) exchangeRoute(method amqp.Method) *amqp.Error {
	switch method := method.(type) {
	case *amqp.ExchangeDeclare:
		return channel.exchangeDeclare(method)
	case *amqp.ExchangeDelete:
		return channel.exchangeDelete(method)
	}

	return amqp.NewConnectionError(amqp.NotImplemented, "unable to route queue method "+method.Name(), method.ClassIdentifier(), method.MethodIdentifier())
}

func (channel *Channel) exchangeDeclare(method *amqp.ExchangeDeclare) *amqp.Error {
	exTypeId, err := exchange.GetExchangeTypeID(method.Type)
	if err != nil {
		return amqp.NewChannelError(amqp.NotImplemented, err.Error(), method.ClassIdentifier(), method.MethodIdentifier())
	}

	if method.Exchange == "" {
		return amqp.NewChannelError(
			amqp.CommandInvalid,
			"exchange name is required",
			method.ClassIdentifier(),
			method.MethodIdentifier(),
		)
	}

	existingExchange := channel.conn.GetVirtualHost().GetExchange(method.Exchange)
	if method.Passive {
		if method.NoWait {
			return nil
		}

		if existingExchange == nil {
			return amqp.NewChannelError(
				amqp.NotFound,
				fmt.Sprintf("exchange '%s' not found", method.Exchange),
				method.ClassIdentifier(),
				method.MethodIdentifier(),
			)
		}

		channel.SendMethod(&amqp.ExchangeDeclareOk{})

		return nil
	}

	if strings.HasPrefix(method.Exchange, "amq.") {
		return amqp.NewChannelError(
			amqp.AccessRefused,
			fmt.Sprintf("exchange name '%s' contains reserved prefix 'amq.*'", method.Exchange),
			method.ClassIdentifier(),
			method.MethodIdentifier(),
		)
	}

	newExchange := exchange.NewExchange(
		method.Exchange,
		exTypeId,
		method.Durable,
		method.AutoDelete,
		method.Internal,
		false,
	)

	if existingExchange != nil {
		if err := existingExchange.EqualWithErr(newExchange); err != nil {
			return amqp.NewChannelError(
				amqp.PreconditionFailed,
				err.Error(),
				method.ClassIdentifier(),
				method.MethodIdentifier(),
			)
		}
		channel.SendMethod(&amqp.ExchangeDeclareOk{})
		return nil
	}

	channel.conn.GetVirtualHost().AppendExchange(newExchange)
	if !method.NoWait {
		channel.SendMethod(&amqp.ExchangeDeclareOk{})
	}

	return nil
}

func (channel *Channel) exchangeDelete(method *amqp.ExchangeDelete) *amqp.Error {
	return nil
}

```

`pkg/outputs/amqp/_fixtures/garagemq/server/queueMethods.go`:

```go
package server

import (
	"fmt"
	"github.com/rabbitstack/fibratus/pkg/outputs/amqp/_fixtures/garagemq/amqp"
	"github.com/rabbitstack/fibratus/pkg/outputs/amqp/_fixtures/garagemq/binding"
	"github.com/rabbitstack/fibratus/pkg/outputs/amqp/_fixtures/garagemq/exchange"
	"github.com/rabbitstack/fibratus/pkg/outputs/amqp/_fixtures/garagemq/queue"
)

func (channel *Channel) queueRoute(method amqp.Method) *amqp.Error {
	switch method := method.(type) {
	case *amqp.QueueDeclare:
		return channel.queueDeclare(method)
	case *amqp.QueueBind:
		return channel.queueBind(method)
	case *amqp.QueueUnbind:
		return channel.queueUnbind(method)
	case *amqp.QueuePurge:
		return channel.queuePurge(method)
	case *amqp.QueueDelete:
		return channel.queueDelete(method)
	}

	return amqp.NewConnectionError(amqp.NotImplemented, "unable to route queue method "+method.Name(), method.ClassIdentifier(), method.MethodIdentifier())
}

func (channel *Channel) queueDeclare(method *amqp.QueueDeclare) *amqp.Error {
	var existingQueue *queue.Queue
	var notFoundErr, exclusiveErr *amqp.Error

	if method.Queue == "" {
		return amqp.NewChannelError(
			amqp.CommandInvalid,
			"queue name is required",
			method.ClassIdentifier(),
			method.MethodIdentifier(),
		)
	}

	existingQueue, notFoundErr = channel.getQueueWithError(method.Queue, method)
	exclusiveErr = channel.checkQueueLockWithError(existingQueue, method)

	if method.Passive {
		if method.NoWait {
			return nil
		}

		if existingQueue == nil {
			return notFoundErr
		}

		if exclusiveErr != nil {
			return exclusiveErr
		}

		channel.SendMethod(&amqp.QueueDeclareOk{
			Queue:         method.Queue,
			MessageCount:  uint32(existingQueue.Length()),
			ConsumerCount: uint32(existingQueue.ConsumersCount()),
		})

		return nil
	}

	newQueue := channel.conn.GetVirtualHost().NewQueue(
		method.Queue,
		channel.conn.id,
		method.Exclusive,
		method.AutoDelete,
		method.Durable,
		channel.server.config.Queue.ShardSize,
	)

	if existingQueue != nil {
		if exclusiveErr != nil {
			return exclusiveErr
		}

		if err := existingQueue.EqualWithErr(newQueue); err != nil {
			return amqp.NewChannelError(
				amqp.PreconditionFailed,
				err.Error(),
				method.ClassIdentifier(),
				method.MethodIdentifier(),
			)
		}

		channel.SendMethod(&amqp.QueueDeclareOk{
			Queue:         method.Queue,
			MessageCount:  uint32(existingQueue.Length()),
			ConsumerCount: uint32(existingQueue.ConsumersCount()),
		})
		return nil
	}

	newQueue.Start()
	err := channel.conn.GetVirtualHost().AppendQueue(newQueue)
	if err != nil {
		return amqp.NewChannelError(
			amqp.PreconditionFailed,
			err.Error(),
			method.ClassIdentifier(),
			method.MethodIdentifier(),
		)
	}
	channel.SendMethod(&amqp.QueueDeclareOk{
		Queue:         method.Queue,
		MessageCount:  0,
		ConsumerCount: 0,
	})

	return nil
}

func (channel *Channel) queueBind(method *amqp.QueueBind) *amqp.Error {
	var ex *exchange.Exchange
	var qu *queue.Queue
	var err *amqp.Error

	if ex, err = channel.getExchangeWithError(method.Exchange, method); err != nil {
		return err
	}

	// @spec-note
	// The server MUST NOT allow clients to access the default exchange except by specifying an empty exchange name in the Queue.Bind and content Publish methods.
	if ex.GetName() == exDefaultName {
		return amqp.NewChannelError(
			amqp.AccessRefused,
			fmt.Sprintf("operation not permitted on the default exchange"),
			method.ClassIdentifier(),
			method.MethodIdentifier(),
		)
	}

	if qu, err = channel.getQueueWithError(method.Queue, method); err != nil {
		return err
	}

	if err = channel.checkQueueLockWithError(qu, method); err != nil {
		return err
	}

	bind, bindErr := binding.NewBinding(method.Queue, method.Exchange,
		method.RoutingKey, method.Arguments, ex.ExType() == exchange.ExTypeTopic)
	if bindErr != nil {
		return amqp.NewChannelError(
			amqp.PreconditionFailed,
			bindErr.Error(),
			method.ClassIdentifier(),
			method.MethodIdentifier(),
		)

	}

	ex.AppendBinding(bind)

	// @spec-note
	// Bindings of durable queues to durable exchanges are automatically durable and the server MUST restore such bindings after a server restart.
	if ex.IsDurable() && qu.IsDurable() {
		channel.conn.GetVirtualHost().PersistBinding(bind)
	}

	if !method.NoWait {
		channel.SendMethod(&amqp.QueueBindOk{})
	}

	return nil
}

func (channel *Channel) queueUnbind(method *amqp.QueueUnbind) *amqp.Error {
	var ex *exchange.Exchange
	var qu *queue.Queue
	var err *amqp.Error

	if ex, err = channel.getExchangeWithError(method.Exchange, method); err != nil {
		return err
	}

	if qu, err = channel.getQueueWithError(method.Queue, method); err != nil {
		return err
	}

	if err = channel.checkQueueLockWithError(qu, method); err != nil {
		return err
	}

	bind, bindErr := binding.NewBinding(method.Queue, method.Exchange, method.RoutingKey, method.Arguments, ex.ExType() == exchange.ExTypeTopic)

	if bindErr != nil {
		return amqp.NewConnectionError(
			amqp.PreconditionFailed,
			bindErr.Error(),
			method.ClassIdentifier(),
			method.MethodIdentifier(),
		)
	}

	ex.RemoveBinding(bind)
	channel.conn.GetVirtualHost().RemoveBindings([]*binding.Binding{bind})
	channel.SendMethod(&amqp.QueueUnbindOk{})

	return nil
}

func (channel *Channel) queuePurge(method *amqp.QueuePurge) *amqp.Error {
	var qu *queue.Queue
	var err *amqp.Error

	if qu, err = channel.getQueueWithError(method.Queue, method); err != nil {
		return err
	}

	if err = channel.checkQueueLockWithError(qu, method); err != nil {
		return err
	}

	msgCnt := qu.Purge()
	if !method.NoWait {
		channel.SendMethod(&amqp.QueuePurgeOk{MessageCount: uint32(msgCnt)})
	}
	return nil
}

func (channel *Channel) queueDelete(method *amqp.QueueDelete) *amqp.Error {
	var qu *queue.Queue
	var err *amqp.Error

	if qu, err = channel.getQueueWithError(method.Queue, method); err != nil {
		return err
	}

	if err = channel.checkQueueLockWithError(qu, method); err != nil {
		return err
	}

	var length, errDel = channel.conn.GetVirtualHost().DeleteQueue(method.Queue, method.IfUnused, method.IfEmpty)
	if errDel != nil {
		return amqp.NewChannelError(amqp.PreconditionFailed, errDel.Error(), method.ClassIdentifier(), method.MethodIdentifier())
	}

	channel.SendMethod(&amqp.QueueDeleteOk{MessageCount: uint32(length)})
	return nil
}

```

`pkg/outputs/amqp/_fixtures/garagemq/server/server.go`:

```go
package server

import (
	"github.com/rabbitstack/fibratus/pkg/outputs/amqp/_fixtures/garagemq/amqp"
	"github.com/rabbitstack/fibratus/pkg/outputs/amqp/_fixtures/garagemq/auth"
	"github.com/rabbitstack/fibratus/pkg/outputs/amqp/_fixtures/garagemq/config"
	"net"
	"os"
	"os/signal"
	"sync"
	"syscall"

	log "github.com/sirupsen/logrus"
)

type ServerState int

// server state statuses
const (
	Stopped ServerState = iota
	Running
	Stopping
)

// Server implements AMQP server
type Server struct {
	host         string
	port         string
	protoVersion string
	listener     *net.TCPListener
	connSeq      uint64
	connLock     sync.Mutex
	statusLock   sync.Mutex
	connections  map[uint64]*Connection
	config       *config.Config
	users        map[string]string
	vhostsLock   sync.Mutex
	vhosts       map[string]*VirtualHost
	status       ServerState
}

// NewServer returns new instance of AMQP Server
func NewServer(host string, port string, protoVersion string, config *config.Config) (server *Server) {
	server = &Server{
		host:         host,
		port:         port,
		connections:  make(map[uint64]*Connection),
		protoVersion: protoVersion,
		config:       config,
		users:        make(map[string]string),
		vhosts:       make(map[string]*VirtualHost),
		connSeq:      0,
	}

	return
}

// Start start main server loop
func (srv *Server) Start() {
	log.WithFields(log.Fields{
		"pid": os.Getpid(),
	}).Info("Server starting")

	go srv.hookSignals()

	srv.initUsers()
	srv.initDefaultVirtualHosts()

	go srv.listen()
	srv.statusLock.Lock()
	srv.status = Running
	srv.statusLock.Unlock()
	select {}
}

// Stop stop server and all vhosts
func (srv *Server) Stop() {
	srv.vhostsLock.Lock()
	defer srv.vhostsLock.Unlock()
	srv.statusLock.Lock()
	srv.status = Stopping
	srv.statusLock.Unlock()

	// stop accept new connections
	srv.listener.Close()

	var wg sync.WaitGroup
	srv.connLock.Lock()
	for _, conn := range srv.connections {
		wg.Add(1)
		go conn.safeClose(&wg)
	}
	srv.connLock.Unlock()
	wg.Wait()
	log.Info("All connections safe closed")

	// stop exchanges and queues
	for _, virtualHost := range srv.vhosts {
		virtualHost.Stop()
	}
	srv.statusLock.Lock()
	srv.status = Stopped
	srv.statusLock.Unlock()
}

func (srv *Server) getVhost(name string) *VirtualHost {
	srv.vhostsLock.Lock()
	defer srv.vhostsLock.Unlock()

	return srv.vhosts[name]
}

func (srv *Server) listen() {
	address := srv.host + ":" + srv.port
	tcpAddr, err := net.ResolveTCPAddr("tcp4", address)
	srv.listener, err = net.ListenTCP("tcp", tcpAddr)
	if err != nil {
		log.WithError(err).WithFields(log.Fields{
			"address": address,
		}).Error("Error on listener start")
		os.Exit(1)
	}

	log.WithFields(log.Fields{
		"address": address,
	}).Info("Server started")

	for {
		conn, err := srv.listener.AcceptTCP()
		if err != nil {
			srv.statusLock.Lock()
			if srv.status != Running {
				srv.statusLock.Unlock()
				return
			}
			srv.statusLock.Unlock()
			srv.stopWithError(err, "accepting connection")
		}
		log.WithFields(log.Fields{
			"from": conn.RemoteAddr().String(),
			"to":   conn.LocalAddr().String(),
		}).Info("accepting connection")

		conn.SetReadBuffer(srv.config.TCP.ReadBufSize)
		conn.SetWriteBuffer(srv.config.TCP.WriteBufSize)
		conn.SetNoDelay(srv.config.TCP.Nodelay)

		srv.acceptConnection(conn)
	}
}

func (srv *Server) stopWithError(err error, msg string) {
	log.WithError(err).Error(msg)
	srv.Stop()
	os.Exit(1)
}

func (srv *Server) acceptConnection(conn *net.TCPConn) {
	srv.connLock.Lock()
	defer srv.connLock.Unlock()

	connection := NewConnection(srv, conn)
	srv.connections[connection.id] = connection
	go connection.handleConnection()
}

func (srv *Server) removeConnection(connID uint64) {
	srv.connLock.Lock()
	defer srv.connLock.Unlock()

	delete(srv.connections, connID)
}

func (srv *Server) checkAuth(saslData auth.SaslData) bool {
	for userName, passwordHash := range srv.users {
		if userName != saslData.Username {
			continue
		}

		return auth.CheckPasswordHash(
			saslData.Password,
			passwordHash,
			srv.config.Security.PasswordCheck == "md5",
		)
	}
	return false
}

func (srv *Server) initUsers() {
	for _, user := range srv.config.Users {
		srv.users[user.Username] = user.Password
	}
}

func (srv *Server) initDefaultVirtualHosts() {
	log.WithFields(log.Fields{
		"vhost": srv.config.Vhost.DefaultPath,
	}).Info("Initialize default vhost")

	log.Info("Initialize host message msgStorage")

	srv.vhostsLock.Lock()
	defer srv.vhostsLock.Unlock()
	srv.vhosts[srv.config.Vhost.DefaultPath] = NewVhost(srv.config.Vhost.DefaultPath, true, srv)
}

func (srv *Server) onSignal(sig os.Signal) {
	switch sig {
	case syscall.SIGTERM, syscall.SIGINT:
		srv.Stop()
		os.Exit(0)
	}
}

// Special method for calling in tests without os.Exit(0)
func (srv *Server) testOnSignal(sig os.Signal) {
	switch sig {
	case syscall.SIGTERM, syscall.SIGINT:
		srv.Stop()
	}
}

func (srv *Server) hookSignals() {
	c := make(chan os.Signal, 1)
	signal.Notify(c, syscall.SIGINT, syscall.SIGTERM)
	go func() {
		for sig := range c {
			log.Infof("Received [%d:%s] signal from OS", sig, sig.String())
			srv.onSignal(sig)
		}
	}()
}

func (srv *Server) getConfirmChannel(meta *amqp.ConfirmMeta) *Channel {
	srv.connLock.Lock()
	defer srv.connLock.Unlock()
	conn := srv.connections[meta.ConnID]
	if conn == nil {
		return nil
	}

	return conn.getChannel(meta.ChanID)
}

func (srv *Server) GetVhost(name string) *VirtualHost {
	return srv.getVhost(name)
}

func (srv *Server) GetVhosts() map[string]*VirtualHost {
	return srv.vhosts
}

func (srv *Server) GetConnections() map[uint64]*Connection {
	return srv.connections
}

func (srv *Server) GetProtoVersion() string {
	return srv.protoVersion
}

func (srv *Server) GetStatus() ServerState {
	return srv.status
}

```

`pkg/outputs/amqp/_fixtures/garagemq/server/vhost.go`:

```go
package server

import (
	"errors"
	"github.com/rabbitstack/fibratus/pkg/outputs/amqp/_fixtures/garagemq/amqp"
	"github.com/rabbitstack/fibratus/pkg/outputs/amqp/_fixtures/garagemq/binding"
	"github.com/rabbitstack/fibratus/pkg/outputs/amqp/_fixtures/garagemq/config"
	"github.com/rabbitstack/fibratus/pkg/outputs/amqp/_fixtures/garagemq/exchange"
	"github.com/rabbitstack/fibratus/pkg/outputs/amqp/_fixtures/garagemq/queue"
	"sync"

	log "github.com/sirupsen/logrus"
)

const exDefaultName = ""

// VirtualHost represents AMQP virtual host
// Each virtual host is "parent" for its queues and exchanges
type VirtualHost struct {
	name            string
	system          bool
	exLock          sync.RWMutex
	exchanges       map[string]*exchange.Exchange
	quLock          sync.RWMutex
	queues          map[string]*queue.Queue
	srv             *Server
	srvConfig       *config.Config
	logger          *log.Entry
	autoDeleteQueue chan string
}

// NewVhost returns instance of VirtualHost
// When instantiating virtual host we
// 1) init system exchanges
// 2) load durable exchanges, queues and bindings from server storage
// 3) load persisted messages from message store into all initiated queues
// 4) run confirm loop
// Only after that vhost is in state running msgStoragePersistent, msgStorageTransient
func NewVhost(name string, system bool, srv *Server) *VirtualHost {
	vhost := &VirtualHost{
		name:            name,
		system:          system,
		exchanges:       make(map[string]*exchange.Exchange),
		queues:          make(map[string]*queue.Queue),
		srvConfig:       srv.config,
		srv:             srv,
		autoDeleteQueue: make(chan string, 1),
	}

	vhost.logger = log.WithFields(log.Fields{
		"vhost": name,
	})

	vhost.initSystemExchanges()
	vhost.loadExchanges()
	vhost.loadQueues()
	vhost.loadBindings()

	vhost.logger.Info("Load messages into queues")

	vhost.loadMessagesIntoQueues()
	for _, q := range vhost.GetQueues() {
		q.Start()
		vhost.logger.WithFields(log.Fields{
			"name":   q.GetName(),
			"length": q.Length(),
		}).Info("Messages loaded into queue")
	}

	go vhost.handleConfirms()
	go vhost.handleAutoDeleteQueue()

	return vhost
}

func (vhost *VirtualHost) handleAutoDeleteQueue() {
	for queueName := range vhost.autoDeleteQueue {
		//time.Sleep(5 * time.Second)
		vhost.DeleteQueue(queueName, false, false)
	}
}

func (vhost *VirtualHost) handleConfirms() {

}

func (vhost *VirtualHost) initSystemExchanges() {
	// @spec-note
	// The server MUST, in each virtual host, pre­declare an exchange instance for each standard exchange type that it
	// implements, where the name of the exchange instance, if defined, is "amq." followed by the exchange type name.

	// The server MUST, in each virtual host, pre­declare at least two direct exchange instances: one named "amq.direct",
	// the other with no public name that serves as a default exchange for Publish methods.

	// The server MUST pre­declare a direct exchange with no public name to act as the default exchange for content Publish methods and for default queue bindings.

	vhost.logger.Info("Initialize host default exchanges...")
	for _, exType := range []byte{
		exchange.ExTypeDirect,
		exchange.ExTypeFanout,
		exchange.ExTypeTopic,
	} {
		exTypeAlias, _ := exchange.GetExchangeTypeAlias(exType)
		exName := "amq." + exTypeAlias
		vhost.AppendExchange(exchange.NewExchange(exName, exType, true, false, false, true))
	}

	// Special case for exchange.ExTypeHeaders
	//
	// AMQP specifies that the default exchange for headers shall be called
	// amq.match, but RabbitMQ declares it as amq.header
	//
	// To be compatible, we change its name depending on protoVersion
	protoVer := vhost.srv.protoVersion

	exTypeAlias, _ := exchange.GetExchangeTypeAlias(exchange.ExTypeHeaders)
	exName := "amq." + exTypeAlias

	if protoVer == amqp.ProtoRabbit {
		exName = "amq.header"
	}
	vhost.AppendExchange(exchange.NewExchange(exName, exchange.ExTypeHeaders, true, false, false, true))

	systemExchange := exchange.NewExchange(exDefaultName, exchange.ExTypeDirect, true, false, false, true)
	vhost.AppendExchange(systemExchange)
}

// GetQueue returns queue by name or nil if not exists
func (vhost *VirtualHost) GetQueue(name string) *queue.Queue {
	vhost.quLock.RLock()
	defer vhost.quLock.RUnlock()
	return vhost.getQueue(name)
}

// GetQueues return all vhost's queues
func (vhost *VirtualHost) GetQueues() map[string]*queue.Queue {
	vhost.quLock.RLock()
	defer vhost.quLock.RUnlock()
	return vhost.queues
}

func (vhost *VirtualHost) getQueue(name string) *queue.Queue {
	return vhost.queues[name]
}

// GetExchange returns exchange by name or nil if not exists
func (vhost *VirtualHost) GetExchange(name string) *exchange.Exchange {
	vhost.exLock.RLock()
	defer vhost.exLock.RUnlock()
	return vhost.getExchange(name)
}

func (vhost *VirtualHost) getExchange(name string) *exchange.Exchange {
	return vhost.exchanges[name]
}

func (vhost *VirtualHost) GetExchanges() map[string]*exchange.Exchange {
	return vhost.exchanges
}

// GetDefaultExchange returns default exchange
func (vhost *VirtualHost) GetDefaultExchange() *exchange.Exchange {
	return vhost.exchanges[exDefaultName]
}

// AppendExchange append new exchange and persist if it is durable
func (vhost *VirtualHost) AppendExchange(ex *exchange.Exchange) {
	vhost.exLock.Lock()
	defer vhost.exLock.Unlock()
	exTypeAlias, _ := exchange.GetExchangeTypeAlias(ex.ExType())
	vhost.logger.WithFields(log.Fields{
		"name": ex.GetName(),
		"type": exTypeAlias,
	}).Info("Append exchange")
	vhost.exchanges[ex.GetName()] = ex

}

// NewQueue returns new instance of queue by params
// we can't use just queue.NewQueue, cause we need to set msgStorage to queue
func (vhost *VirtualHost) NewQueue(name string, connID uint64, exclusive bool, autoDelete bool, durable bool, shardSize int) *queue.Queue {
	return queue.NewQueue(
		name,
		connID,
		exclusive,
		autoDelete,
		durable,
		vhost.srvConfig.Queue,
		nil,
		nil,
		vhost.autoDeleteQueue,
	)
}

// AppendQueue append new queue and persist if it is durable and
// bindings into default exchange
func (vhost *VirtualHost) AppendQueue(qu *queue.Queue) error {
	vhost.quLock.Lock()
	defer vhost.quLock.Unlock()
	vhost.logger.WithFields(log.Fields{
		"queueName": qu.GetName(),
	}).Info("Append queue")

	vhost.queues[qu.GetName()] = qu

	// @spec-note
	// The server MUST create a default binding for a newly­declared queue to the default exchange,
	// which is an exchange of type 'direct' and use the queue name as the routing key.
	ex := vhost.GetDefaultExchange()
	bind, bindErr := binding.NewBinding(qu.GetName(), exDefaultName,
		qu.GetName(), &amqp.Table{}, false)
	if bindErr != nil {
		// Should not happen since the only error paths are on `topic` and
		// `headers`
		return bindErr
	}

	ex.AppendBinding(bind)

	if qu.IsDurable() {

	}

	return nil
}

// PersistBinding store binding into server storage
func (vhost *VirtualHost) PersistBinding(binding *binding.Binding) {
}

// RemoveBindings remove given bindings from server storage
func (vhost *VirtualHost) RemoveBindings(bindings []*binding.Binding) {
}

func (vhost *VirtualHost) loadQueues() {
}

func (vhost *VirtualHost) loadMessagesIntoQueues() {
	var wg sync.WaitGroup
	for queueName, q := range vhost.queues {
		wg.Add(1)
		go func(queueName string, queue *queue.Queue) {
			wg.Done()
		}(queueName, q)
	}
	wg.Wait()
}

func (vhost *VirtualHost) loadExchanges() {
}

func (vhost *VirtualHost) loadBindings() {
}

// DeleteQueue delete queue from virtual host and all bindings to that queue
// Also queue will be removed from server storage
func (vhost *VirtualHost) DeleteQueue(queueName string, ifUnused bool, ifEmpty bool) (uint64, error) {
	vhost.quLock.Lock()
	defer vhost.quLock.Unlock()

	qu := vhost.getQueue(queueName)
	if qu == nil {
		return 0, errors.New("not found")
	}

	var length, err = qu.Delete(ifUnused, ifEmpty)
	if err != nil {
		return 0, err
	}

	qu.Stop()

	for _, ex := range vhost.exchanges {
		removedBindings := ex.RemoveQueueBindings(queueName)
		vhost.RemoveBindings(removedBindings)
	}
	delete(vhost.queues, queueName)

	return length, nil
}

// Stop properly stop virtual host
// TODO: properly stop confirm loop
func (vhost *VirtualHost) Stop() error {
	vhost.quLock.Lock()
	vhost.exLock.Lock()
	defer vhost.quLock.Unlock()
	defer vhost.exLock.Unlock()
	vhost.logger.Info("Stop virtual host")
	for _, qu := range vhost.queues {
		qu.Stop()
		vhost.logger.WithFields(log.Fields{
			"queueName": qu.GetName(),
		}).Info("Queue stopped")
	}

	vhost.logger.Info("Storage closed")
	close(vhost.autoDeleteQueue)
	return nil
}

func (vhost *VirtualHost) GetName() string {
	return vhost.name
}

```

`pkg/outputs/amqp/amqp.go`:

```go
/*
 * Copyright 2019-2020 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package amqp

import (
	"expvar"

	"github.com/rabbitstack/fibratus/pkg/event"
	"github.com/rabbitstack/fibratus/pkg/outputs"
)

var (
	// amqpErrors counts AMQP delivery errors
	amqpErrors = expvar.NewInt("output.amqp.publish.errors")
	// amqpMessages counts the total number of published messages
	amqpMessages = expvar.NewInt("output.amqp.publish.messages")
)

type rabbitmq struct {
	client *client
}

func init() {
	outputs.Register(outputs.AMQP, initAMQP)
}

func initAMQP(config outputs.Config) (outputs.OutputGroup, error) {
	cfg, ok := config.Output.(Config)
	if !ok {
		return outputs.Fail(outputs.ErrInvalidConfig(outputs.AMQP, config.Output))
	}

	q := &rabbitmq{client: newClient(cfg)}

	return outputs.Success(q), nil
}

func (q *rabbitmq) Connect() error {
	err := q.client.connect(true)
	if err != nil {
		return err
	}
	return q.client.declareExchange()
}

func (q *rabbitmq) Close() error {
	if q.client == nil {
		return nil
	}
	return q.client.close()
}

func (q *rabbitmq) Publish(batch *event.Batch) error {
	body := batch.MarshalJSON()

	err := q.client.publish(body)
	if err != nil {
		amqpErrors.Add(1)
		return err
	}

	amqpMessages.Add(1)

	return nil
}

```

`pkg/outputs/amqp/amqp_test.go`:

```go
/*
 * Copyright 2019-2020 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package amqp

import (
	"encoding/json"
	"fmt"
	"github.com/rabbitstack/fibratus/pkg/util/va"
	"golang.org/x/sys/windows"
	"testing"
	"time"

	"github.com/phayes/freeport"
	"github.com/rabbitstack/fibratus/pkg/event"
	"github.com/rabbitstack/fibratus/pkg/event/params"
	htypes "github.com/rabbitstack/fibratus/pkg/handle/types"
	"github.com/rabbitstack/fibratus/pkg/outputs/amqp/_fixtures/garagemq/config"
	broker "github.com/rabbitstack/fibratus/pkg/outputs/amqp/_fixtures/garagemq/server"
	pstypes "github.com/rabbitstack/fibratus/pkg/ps/types"
	"github.com/streadway/amqp"
	"github.com/stretchr/testify/require"
)

func TestPublishAmqpOutput(t *testing.T) {
	// deadlock occurs somewhere in the garagemq code
	// when tests are executed in the CI platform.
	// Reenable test once we fix the issue
	t.SkipNow()
	port, err := freeport.GetFreePort()
	require.NoError(t, err)
	amqpBroker := broker.NewServer("127.0.0.1", fmt.Sprintf("%d", port), "amqp-rabbit", config.Default())

	done := make(chan struct{})

	go func() {
		amqpBroker.Start()
	}()
	defer amqpBroker.Stop()

	q := rabbitmq{client: newClient(Config{
		URL:          amqpURL(port),
		Exchange:     "fibratus",
		ExchangeType: "topic",
		RoutingKey:   "fibratus",
	})}

	time.AfterFunc(time.Second*4, func() { done <- struct{}{} })

	require.NoError(t, q.Connect())
	defer q.Close()

	err = consumeEvents(t, amqpURL(port), done)
	require.NoError(t, err)

	err = q.Publish(getBatch())
	require.NoError(t, err)

	<-done
}

func TestHealthcheck(t *testing.T) {
	// deadlock occurs somewhere in the garagemq code
	// when tests are executed in the CI platform.
	// Reenable test once we fix the issue
	t.SkipNow()
	port, err := freeport.GetFreePort()
	require.NoError(t, err)
	amqpBroker := broker.NewServer("127.0.0.1", fmt.Sprintf("%d", port), "amqp-rabbit", config.Default())

	go func() {
		amqpBroker.Start()
	}()

	q := rabbitmq{client: newClient(Config{
		URL:          amqpURL(port),
		Exchange:     "fibratus",
		ExchangeType: "topic",
		RoutingKey:   "fibratus",
		Timeout:      time.Second,
	})}
	require.NoError(t, q.Connect())
	defer q.Close()

	time.Sleep(time.Millisecond * 400)

	amqpBroker.Stop()

	err = q.Publish(getBatch())
	require.Error(t, err)

	time.Sleep(time.Millisecond * 100)

	go func() {
		amqpBroker.Start()
	}()

	time.Sleep(time.Millisecond * 2000)
	require.NoError(t, q.client.declareExchange())
	err = q.Publish(getBatch())
	require.NoError(t, err)
}

//nolint:unused
func consumeEvents(t *testing.T, amqpURI string, done chan struct{}) error {
	conn, err := amqp.Dial(amqpURI)
	if err != nil {
		return err
	}

	channel, err := conn.Channel()
	if err != nil {
		return err
	}
	queue, err := channel.QueueDeclare(
		"fibratus", // name of the queue
		true,       // durable
		false,      // delete when unused
		false,      // exclusive
		false,      // noWait
		nil,        // arguments
	)
	if err != nil {
		return err
	}
	if err = channel.QueueBind(
		queue.Name, // name of the queue
		"fibratus", // bindingKey
		"fibratus", // sourceExchange
		false,      // noWait
		nil,        // arguments
	); err != nil {
		return err
	}
	deliveries, err := channel.Consume(
		queue.Name,        // name
		"events-consumer", // consumerTag,
		false,             // noAck
		false,             // exclusive
		false,             // noLocal
		false,             // noWait
		nil,               // arguments
	)
	require.NoError(t, err)

	go func() {
		for d := range deliveries {
			body := d.Body
			if len(body) == 0 {
				done <- struct{}{}
				t.Error("got empty AMQP message")
			}
			var events []*event.Event
			err := json.Unmarshal(body, &events)
			if err != nil {
				done <- struct{}{}
				t.Error(err)
			}
			if len(events) != 3 {
				done <- struct{}{}
				t.Errorf("expected 3 events in body but got %d", len(events))
			}
			err = d.Ack(false)
			if err != nil {
				t.Error(err)
			}
			done <- struct{}{}
		}
	}()

	return nil
}

//nolint:unused
func amqpURL(port int) string {
	return fmt.Sprintf("amqp://localhost:%d", port)
}

//nolint:unused
func getBatch() *event.Batch {
	evt := &event.Event{
		Type:        event.CreateFile,
		Tid:         2484,
		PID:         859,
		CPU:         1,
		Seq:         2,
		Name:        "CreateFile",
		Timestamp:   time.Now(),
		Category:    event.File,
		Host:        "archrabbit",
		Description: "Creates or opens a new file, directory, I/O device, pipe, console",
		Params: event.Params{
			params.FileObject:    {Name: params.FileObject, Type: params.Uint64, Value: uint64(12456738026482168384)},
			params.FilePath:      {Name: params.FilePath, Type: params.UnicodeString, Value: "\\Device\\HarddiskVolume2\\Windows\\system32\\user32.dll"},
			params.FileType:      {Name: params.FileType, Type: params.AnsiString, Value: "file"},
			params.FileOperation: {Name: params.FileOperation, Type: params.AnsiString, Value: "open"},
			params.BasePrio:      {Name: params.BasePrio, Type: params.Int8, Value: int8(2)},
			params.PagePrio:      {Name: params.PagePrio, Type: params.Uint8, Value: uint8(2)},
		},
		Metadata: map[event.MetadataKey]any{"foo": "bar", "fooz": "baarz"},
		PS: &pstypes.PS{
			PID:       2436,
			Ppid:      6304,
			Name:      "firefox.exe",
			Exe:       `C:\Program Files\Mozilla Firefox\firefox.exe`,
			Cmdline:   `C:\Program Files\Mozilla Firefox\firefox.exe -contentproc --channel="6304.3.1055809391\1014207667" -childID 1 -isForBrowser -prefsHandle 2584 -prefMapHandle 2580 -prefsLen 70 -prefMapSize 216993 -parentBuildID 20200107212822 -greomni "C:\Program Files\Mozilla Firefox\omni.ja" -appomni "C:\Program Files\Mozilla Firefox\browser\omni.ja" -appdir "C:\Program Files\Mozilla Firefox\browser" - 6304 "\\.\pipe\gecko-crash-server-pipe.6304" 2596 tab`,
			Cwd:       `C:\Program Files\Mozilla Firefox\`,
			SID:       "S-1-1-18",
			Args:      []string{"-contentproc", `--channel=6304.3.1055809391\1014207667`, "-childID", "1", "-isForBrowser", "-prefsHandle", "2584", "-prefMapHandle", "2580", "-prefsLen", "70", "-prefMapSize", "216993", "-parentBuildID"},
			SessionID: 4,
			Envs:      map[string]string{"ProgramData": "C:\\ProgramData", "COMPUTRENAME": "archrabbit"},
			Threads: map[uint32]pstypes.Thread{
				3453: {Tid: 3453, StartAddress: va.Address(140729524944768), IOPrio: 2, PagePrio: 5, KstackBase: va.Address(18446677035730165760), KstackLimit: va.Address(18446677035730137088), UstackLimit: va.Address(86376448), UstackBase: va.Address(86372352)},
				3455: {Tid: 3455, StartAddress: va.Address(140729524944768), IOPrio: 3, PagePrio: 5, KstackBase: va.Address(18446677035730165760), KstackLimit: va.Address(18446677035730137088), UstackLimit: va.Address(86376448), UstackBase: va.Address(86372352)},
			},
			Handles: []htypes.Handle{
				{Num: windows.Handle(0xffffd105e9baaf70),
					Name:   `\REGISTRY\MACHINE\SYSTEM\ControlSet001\Services\Tcpip\Parameters\Interfaces\{b677c565-6ca5-45d3-b618-736b4e09b036}`,
					Type:   "Key",
					Object: 777488883434455544,
					Pid:    uint32(1023),
				},
				{
					Num:  windows.Handle(0xffffd105e9adaf70),
					Name: `\RPC Control\OLEA61B27E13E028C4EA6C286932E80`,
					Type: "ALPC Port",
					Pid:  uint32(1023),
					MD: &htypes.AlpcPortInfo{
						Seqno:   1,
						Context: 0x0,
						Flags:   0x0,
					},
					Object: 457488883434455544,
				},
				{
					Num:  windows.Handle(0xeaffd105e9adaf30),
					Name: `C:\Users\bunny`,
					Type: "File",
					Pid:  uint32(1023),
					MD: &htypes.FileInfo{
						IsDirectory: true,
					},
					Object: 357488883434455544,
				},
			},
		},
	}

	evt1 := &event.Event{
		Type:        event.CreateFile,
		Tid:         2484,
		PID:         459,
		CPU:         1,
		Seq:         2,
		Name:        "CreateFile",
		Timestamp:   time.Now(),
		Category:    event.File,
		Host:        "archrabbit",
		Description: "Creates or opens a new file, directory, I/O device, pipe, console",
		Params: event.Params{
			params.FileObject:    {Name: params.FileObject, Type: params.Uint64, Value: uint64(12456738026482168384)},
			params.FilePath:      {Name: params.FilePath, Type: params.UnicodeString, Value: "\\Device\\HarddiskVolume2\\Windows\\system32\\user32.dll"},
			params.FileType:      {Name: params.FileType, Type: params.AnsiString, Value: "file"},
			params.FileOperation: {Name: params.FileOperation, Type: params.AnsiString, Value: "open"},
			params.BasePrio:      {Name: params.BasePrio, Type: params.Int8, Value: int8(2)},
			params.PagePrio:      {Name: params.PagePrio, Type: params.Uint8, Value: uint8(2)},
		},
		Metadata: map[event.MetadataKey]any{"foo": "bar", "fooz": "baarz"},
		PS: &pstypes.PS{
			PID:       2436,
			Ppid:      6304,
			Name:      "firefox.exe",
			Exe:       `C:\Program Files\Mozilla Firefox\firefox.exe`,
			Cmdline:   `C:\Program Files\Mozilla Firefox\firefox.exe -contentproc --channel="6304.3.1055809391\1014207667" -childID 1 -isForBrowser -prefsHandle 2584 -prefMapHandle 2580 -prefsLen 70 -prefMapSize 216993 -parentBuildID 20200107212822 -greomni "C:\Program Files\Mozilla Firefox\omni.ja" -appomni "C:\Program Files\Mozilla Firefox\browser\omni.ja" -appdir "C:\Program Files\Mozilla Firefox\browser" - 6304 "\\.\pipe\gecko-crash-server-pipe.6304" 2596 tab`,
			Cwd:       `C:\Program Files\Mozilla Firefox\`,
			SID:       "S-1-1-18",
			Args:      []string{"-contentproc", `--channel=6304.3.1055809391\1014207667`, "-childID", "1", "-isForBrowser", "-prefsHandle", "2584", "-prefMapHandle", "2580", "-prefsLen", "70", "-prefMapSize", "216993", "-parentBuildID"},
			SessionID: 4,
			Envs:      map[string]string{"ProgramData": "C:\\ProgramData", "COMPUTRENAME": "archrabbit"},
			Threads: map[uint32]pstypes.Thread{
				3453: {Tid: 3453, StartAddress: va.Address(140729524944768), IOPrio: 2, PagePrio: 5, KstackBase: va.Address(18446677035730165760), KstackLimit: va.Address(18446677035730137088), UstackLimit: va.Address(86376448), UstackBase: va.Address(86372352)},
				3455: {Tid: 3455, StartAddress: va.Address(140729524944768), IOPrio: 3, PagePrio: 5, KstackBase: va.Address(18446677035730165760), KstackLimit: va.Address(18446677035730137088), UstackLimit: va.Address(86376448), UstackBase: va.Address(86372352)},
			},
			Handles: []htypes.Handle{
				{Num: windows.Handle(0xffffd105e9baaf70),
					Name:   `\REGISTRY\MACHINE\SYSTEM\ControlSet001\Services\Tcpip\Parameters\Interfaces\{b677c565-6ca5-45d3-b618-736b4e09b036}`,
					Type:   "Key",
					Object: 777488883434455544,
					Pid:    uint32(1023),
				},
				{
					Num:  windows.Handle(0xffffd105e9adaf70),
					Name: `\RPC Control\OLEA61B27E13E028C4EA6C286932E80`,
					Type: "ALPC Port",
					Pid:  uint32(1023),
					MD: &htypes.AlpcPortInfo{
						Seqno:   1,
						Context: 0x0,
						Flags:   0x0,
					},
					Object: 457488883434455544,
				},
				{
					Num:  windows.Handle(0xeaffd105e9adaf30),
					Name: `C:\Users\bunny`,
					Type: "File",
					Pid:  uint32(1023),
					MD: &htypes.FileInfo{
						IsDirectory: true,
					},
					Object: 357488883434455544,
				},
			},
		},
	}

	evt2 := &event.Event{
		Type:        event.CreateFile,
		Tid:         2484,
		PID:         829,
		CPU:         1,
		Seq:         2,
		Name:        "CreateFile",
		Timestamp:   time.Now(),
		Category:    event.File,
		Host:        "archrabbit",
		Description: "Creates or opens a new file, directory, I/O device, pipe, console",
		Params: event.Params{
			params.FileObject:    {Name: params.FileObject, Type: params.Uint64, Value: uint64(12456738026482168384)},
			params.FilePath:      {Name: params.FilePath, Type: params.UnicodeString, Value: "\\Device\\HarddiskVolume2\\Windows\\system32\\user32.dll"},
			params.FileType:      {Name: params.FileType, Type: params.AnsiString, Value: "file"},
			params.FileOperation: {Name: params.FileOperation, Type: params.AnsiString, Value: "open"},
			params.BasePrio:      {Name: params.BasePrio, Type: params.Int8, Value: int8(2)},
			params.PagePrio:      {Name: params.PagePrio, Type: params.Uint8, Value: uint8(2)},
		},
		Metadata: map[event.MetadataKey]any{"foo": "bar", "fooz": "baarz"},
		PS: &pstypes.PS{
			PID:       829,
			Ppid:      6304,
			Name:      "firefox.exe",
			Exe:       `C:\Program Files\Mozilla Firefox\firefox.exe`,
			Cmdline:   `C:\Program Files\Mozilla Firefox\firefox.exe -contentproc --channel="6304.3.1055809391\1014207667" -childID 1 -isForBrowser -prefsHandle 2584 -prefMapHandle 2580 -prefsLen 70 -prefMapSize 216993 -parentBuildID 20200107212822 -greomni "C:\Program Files\Mozilla Firefox\omni.ja" -appomni "C:\Program Files\Mozilla Firefox\browser\omni.ja" -appdir "C:\Program Files\Mozilla Firefox\browser" - 6304 "\\.\pipe\gecko-crash-server-pipe.6304" 2596 tab`,
			Cwd:       `C:\Program Files\Mozilla Firefox\`,
			SID:       "S-1-1-18",
			Args:      []string{"-contentproc", `--channel=6304.3.1055809391\1014207667`, "-childID", "1", "-isForBrowser", "-prefsHandle", "2584", "-prefMapHandle", "2580", "-prefsLen", "70", "-prefMapSize", "216993", "-parentBuildID"},
			SessionID: 4,
			Envs:      map[string]string{"ProgramData": "C:\\ProgramData", "COMPUTRENAME": "archrabbit"},
			Threads: map[uint32]pstypes.Thread{
				3453: {Tid: 3453, StartAddress: va.Address(140729524944768), IOPrio: 2, PagePrio: 5, KstackBase: va.Address(18446677035730165760), KstackLimit: va.Address(18446677035730137088), UstackLimit: va.Address(86376448), UstackBase: va.Address(86372352)},
				3455: {Tid: 3455, StartAddress: va.Address(140729524944768), IOPrio: 3, PagePrio: 5, KstackBase: va.Address(18446677035730165760), KstackLimit: va.Address(18446677035730137088), UstackLimit: va.Address(86376448), UstackBase: va.Address(86372352)},
			},
			Handles: []htypes.Handle{
				{Num: windows.Handle(0xffffd105e9baaf70),
					Name:   `\REGISTRY\MACHINE\SYSTEM\ControlSet001\Services\Tcpip\Parameters\Interfaces\{b677c565-6ca5-45d3-b618-736b4e09b036}`,
					Type:   "Key",
					Object: 777488883434455544,
					Pid:    uint32(1023),
				},
				{
					Num:  windows.Handle(0xffffd105e9adaf70),
					Name: `\RPC Control\OLEA61B27E13E028C4EA6C286932E80`,
					Type: "ALPC Port",
					Pid:  uint32(1023),
					MD: &htypes.AlpcPortInfo{
						Seqno:   1,
						Context: 0x0,
						Flags:   0x0,
					},
					Object: 457488883434455544,
				},
				{
					Num:  windows.Handle(0xeaffd105e9adaf30),
					Name: `C:\Users\bunny`,
					Type: "File",
					Pid:  uint32(1023),
					MD: &htypes.FileInfo{
						IsDirectory: true,
					},
					Object: 357488883434455544,
				},
			},
		},
	}

	return event.NewBatch(evt, evt1, evt2)
}

```

`pkg/outputs/amqp/client.go`:

```go
/*
 * Copyright 2019-2020 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package amqp

import (
	"expvar"
	"fmt"
	"net"
	"sync"
	"time"

	"github.com/rabbitstack/fibratus/pkg/util/tls"
	log "github.com/sirupsen/logrus"
	"github.com/streadway/amqp"
)

var (
	connectionFailures = expvar.NewInt("output.amqp.connection.failures")
	channelFailures    = expvar.NewInt("output.amqp.channel.failures")
)

// client encapsulates the AMQP connection/channel and deals with configuring, establishing the connection
// and publishing messages to the exchange.
type client struct {
	conn     *amqp.Connection
	connLock sync.Mutex

	channel *amqp.Channel
	config  Config
	quit    chan struct{}
}

// newClient creates a new AMQP client and setups the connection/channel.
func newClient(config Config) *client {
	return &client{config: config, quit: make(chan struct{})}
}

// connect opens a connection to the AMQP broker honoring the preferences that were passed in the config.
func (c *client) connect(healthcheck bool) error {
	amqpConfig := amqp.Config{
		Vhost: c.config.Vhost,
		Dial: func(network, addr string) (net.Conn, error) {
			//nolint:noctx
			return net.DialTimeout(network, addr, c.config.Timeout)
		},
		SASL: c.config.auth(),
	}
	tlsConfig, err := tls.MakeConfig(c.config.TLSCert, c.config.TLSKey, c.config.TLSCA, c.config.TLSInsecureSkipVerify)
	if err != nil {
		return fmt.Errorf("invalid TLS config: %v", err)
	}
	amqpConfig.TLSClientConfig = tlsConfig

	c.connLock.Lock()
	defer c.connLock.Unlock()
	c.conn, err = amqp.DialConfig(c.config.URL, amqpConfig)
	if err != nil {
		return err
	}
	c.channel, err = c.conn.Channel()
	if err != nil {
		return fmt.Errorf("unable to open AMQP channel: %v", err)
	}

	log.Infof("established connection to AMQP broker on %s", c.config.URL)

	if healthcheck {
		go c.doHealthcheck()
	}

	return nil
}

// declareExchange creates the exchange in the broker where messages are published.
func (c *client) declareExchange() error {
	c.connLock.Lock()
	defer c.connLock.Unlock()
	var err error
	if c.config.Passive {
		err = c.channel.ExchangeDeclarePassive(
			c.config.Exchange,
			c.config.ExchangeType,
			c.config.Durable,
			false,
			false,
			false,
			nil,
		)
	} else {
		err = c.channel.ExchangeDeclare(
			c.config.Exchange,
			c.config.ExchangeType,
			c.config.Durable,
			false,
			false,
			false,
			nil,
		)
	}
	if err != nil {
		return fmt.Errorf("unable to declare %s exchange: %v", c.config.Exchange, err)
	}
	return nil
}

// publish sends the byte stream to the exchange.
func (c *client) publish(body []byte) error {
	return c.channel.Publish(c.config.Exchange, c.config.RoutingKey, false, false, c.msg(body))
}

func (c *client) msg(body []byte) amqp.Publishing {
	return amqp.Publishing{
		Body:         body,
		ContentType:  "text/json",
		Headers:      c.config.amqpHeaders(),
		DeliveryMode: c.config.deliveryMode(),
	}
}

// healthcheck monitors the state of the AMQP connection and its corresponding channel. Since AMQP channel is
// shutdown if an error occurs on it, we'll have to handle this situation properly and try to reopen the channel.
// Similarly, if the connection is lost, the reconnect loop kicks in and tries to reconcile the connection state.
func (c *client) doHealthcheck() {
	notify := c.conn.NotifyClose(make(chan *amqp.Error))
	cnotify := c.channel.NotifyClose(make(chan *amqp.Error))
	go func() {
		for {
			select {
			case err := <-cnotify:
				if err != nil {
					channelFailures.Add(1)
					log.Warnf("channel error: %v. Trying to reopen...", err)
					c.connLock.Lock()
					if c.conn != nil && !c.conn.IsClosed() {
						for {
							var err error
							c.channel, err = c.conn.Channel()
							if err == nil {
								log.Info("channel reopened")
								cnotify = c.channel.NotifyClose(make(chan *amqp.Error))
								break
							}
							// sleep a bit before retrying
							time.Sleep(time.Millisecond * 500)
						}
					}
					c.connLock.Unlock()
				}
			case <-c.quit:
				return
			}
		}
	}()

	for {
		select {
		case err := <-notify:
			if err != nil {
				for {
					connectionFailures.Add(1)
					log.Warnf("connection error: %v. Trying to reconnect...", err)
					e := c.connect(false)
					if e == nil {
						log.Info("connection recovered")
						c.connLock.Lock()
						notify = c.conn.NotifyClose(make(chan *amqp.Error))
						c.connLock.Unlock()
						break
					}
				}
			}
		case <-c.quit:
			return
		}
	}
}

// close tears down the underlying AMQP connection.
func (c *client) close() error {
	if c.conn == nil {
		return nil
	}
	close(c.quit)
	c.connLock.Lock()
	defer c.connLock.Unlock()
	err := c.conn.Close()
	if err != nil && err != amqp.ErrClosed {
		return err
	}
	return nil
}

```

`pkg/outputs/amqp/config.go`:

```go
/*
 * Copyright 2019-2020 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package amqp

import (
	"github.com/rabbitstack/fibratus/pkg/outputs"
	"github.com/spf13/pflag"
	"github.com/streadway/amqp"
	"time"
)

const (
	amqpURI          = "output.amqp.url"
	amqpTimeout      = "output.amqp.timeout"
	amqpVhost        = "output.amqp.vhost"
	amqpExchange     = "output.amqp.exchange"
	amqpRoutingKey   = "output.amqp.routing-key"
	amqpExchangeType = "output.amqp.exchange-type"
	amqpEnabled      = "output.amqp.enabled"
	amqpPassive      = "output.amqp.passive"
	amqpDurable      = "output.amqp.durable"
	amqpDeliveryMode = "output.amqp.delivery-mode"
	amqpUsername     = "output.amqp.username"
	amqpPassword     = "output.amqp.password"
)

// Config contains the tweaks that influence the behaviour of the AMQP output.
type Config struct {
	outputs.TLSConfig
	// Enabled indicates if the AMQP output is enabled
	Enabled bool `mapstructure:"enabled"`
	// URL represents the AMQP connection string.
	URL string `mapstructure:"url"`
	// Timeout specifies the AMQP connection timeout.
	Timeout time.Duration `mapstructure:"timeout"`
	// Exchange is the AMQP exchange for publishing events.
	Exchange string `mapstructure:"exchange"`
	// ExchangeType is the AMQP exchange type.
	ExchangeType string `mapstructure:"exchange-type"`
	// Passive indicates that the server checks whether the exchange already exists and raises an error if it doesn't exist.
	Passive bool `mapstructure:"passive"`
	// Durable indicates that the exchange is marked as durable. Durable exchanges can survive server restarts.
	Durable bool `mapstructure:"durable"`
	// DeliveryMode determines if a published message is persistent or transient.
	DeliveryMode string `mapstructure:"delivery-mode"`
	// RoutingKey represents the static routing key to link exchanges with queues.
	RoutingKey string `mapstructure:"routing-key"`
	// Username is the username for the plain authentication method.
	Username string `mapstructure:"username"`
	// Password is the password for the plain authentication method.
	Password string `mapstructure:"password"`
	// Vhost represents the virtual host name.
	Vhost string `mapstructure:"vhost"`
	// Headers contains a list of headers that are added to AMQP message
	Headers map[string]string `mapstructure:"headers"`
}

// AddFlags registers persistent flags.
func AddFlags(flags *pflag.FlagSet) {
	flags.String(amqpURI, "amqp://localhost:5672", "Represents the AMQP broker address")
	flags.Duration(amqpTimeout, time.Second*5, "Specifies the AMQP connection timeout")
	flags.String(amqpVhost, "/", "The virtual host that provides logical grouping and separation of broker's resources")
	flags.String(amqpExchange, "fibratus", "Specifies the target exchange name")
	flags.String(amqpExchangeType, "topic", "Defines the AMQP exchange type")
	flags.String(amqpRoutingKey, "fibratus", "Specifies the routing key")
	flags.Bool(amqpDurable, false, "Indicates if the exchange is marked as durable. Durable exchanges can survive server restarts.")
	flags.Bool(amqpPassive, false, "Indicates if the server checks whether the exchange already exists and raises an error if it doesn't exist.")
	flags.Bool(amqpEnabled, false, "Indicates if the AMQP output is enabled")
	flags.String(amqpDeliveryMode, "transient", "Determines if a published message is persistent or transient")
	flags.String(amqpUsername, "", "The username for the plain authentication method")
	flags.String(amqpPassword, "", "The password for the plain authentication method")
	outputs.AddTLSFlags(flags, outputs.AMQP)
}

func (c Config) amqpHeaders() amqp.Table {
	headers := make(amqp.Table)
	for k, v := range c.Headers {
		headers[k] = v
	}
	return headers
}

func (c Config) deliveryMode() uint8 {
	switch c.DeliveryMode {
	case "transient":
		return amqp.Transient
	case "persistent":
		return amqp.Persistent
	default:
		return amqp.Transient
	}
}

func (c Config) auth() []amqp.Authentication {
	if c.Username == "" && c.Password == "" {
		return nil
	}
	return []amqp.Authentication{
		&amqp.PlainAuth{
			Username: c.Username,
			Password: c.Password,
		},
	}
}

```

`pkg/outputs/client.go`:

```go
/*
 * Copyright 2019-2020 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package outputs

import (
	"github.com/rabbitstack/fibratus/pkg/event"
)

// Client represents the minimal interface all output implementors have to satisfy.
type Client interface {
	Close() error
	Publish(*event.Batch) error
	Connect() error
}

```

`pkg/outputs/config.go`:

```go
/*
 * Copyright 2019-2020 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package outputs

import (
	"fmt"
	"github.com/spf13/pflag"
)

// Config contains the output configuration.
type Config struct {
	Type   Type
	Output interface{}
}

// TLSConfig stores the client TLS parameters.
type TLSConfig struct {
	// TLSCA represents the path of the certificate file that is associated with the Certification Authority (CA).
	TLSCA string `mapstructure:"tls-ca"`
	// TLSCert is the path to the certificate file.
	TLSCert string `mapstructure:"tls-cert"`
	// TLSKey represents the path to the public/private key file.
	TLSKey string `mapstructure:"tls-key"`
	// TLSInsecureSkipVerify skips the chain and host verification.
	TLSInsecureSkipVerify bool `mapstructure:"tls-insecure-skip-verify"`
}

// AddTLSFlags register the TLS flags for the specified output type.
func AddTLSFlags(flags *pflag.FlagSet, typ Type) {
	flags.String(tlsForOutput("tls-ca", typ), "", "Represents the path of the certificate file that is associated with the Certification Authority (CA)")
	flags.String(tlsForOutput("tls-cert", typ), "", "Path to certificate file")
	flags.String(tlsForOutput("tls-key", typ), "", "Path to the public/private key file")
	flags.Bool(tlsForOutput("tls-insecure-skip-verify", typ), false, "Indicates if the chain and host verification stage is skipped")
}

func tlsForOutput(name string, typ Type) string { return fmt.Sprintf("output.%s.%s", typ, name) }

```

`pkg/outputs/console/config.go`:

```go
/*
 * Copyright 2019-2020 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package console

import "github.com/spf13/pflag"

const (
	frmt             = "output.console.format"
	tmpl             = "output.console.template"
	paramKVDelimiter = "output.console.kv-delimiter"
	enabled          = "output.console.enabled"
)

// Config contains the tweaks that influence the behaviour of the console output.
type Config struct {
	Format           string `mapstructure:"format"`
	Template         string `mapstructure:"template"`
	ParamKVDelimiter string `mapstructure:"kv-delimiter"`
	Enabled          bool   `mapstructure:"enabled"`
}

// AddFlags registers persistent flags.
func AddFlags(flags *pflag.FlagSet) {
	flags.String(frmt, string(pretty), "Specifies the output format. Choose between pretty|json")
	flags.String(paramKVDelimiter, "", "The delimiter symbol for the params key/value pairs")
	flags.String(tmpl, "", "Event formatting template")
	flags.Bool(enabled, true, "Indicates if the console output is enabled")
}

```

`pkg/outputs/console/console.go`:

```go
/*
 * Copyright 2019-2020 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package console

import (
	"bufio"
	"expvar"
	"github.com/rabbitstack/fibratus/pkg/event"
	"github.com/rabbitstack/fibratus/pkg/outputs"
	"os"
)

var (
	consoleErrors = expvar.NewInt("output.console.errors")
)

type format string

const (
	pretty format = "pretty"
	json   format = "json"
	// template represents the default template used in pretty rendering mode
	template = "{{ .Seq }} {{ .Timestamp }} - {{ .CPU }} {{ .Process }} ({{ .Pid }}) - {{ .Type }} ({{ .Params }})"
)

type console struct {
	writer    *bufio.Writer
	formatter *event.Formatter
	format    format
}

func init() {
	outputs.Register(outputs.Console, initConsole)
}

func initConsole(config outputs.Config) (outputs.OutputGroup, error) {
	stdout := os.Stdout
	cfg, ok := config.Output.(Config)
	if !ok {
		return outputs.Fail(outputs.ErrInvalidConfig(outputs.Console, config.Output))
	}
	tmpl := cfg.Template
	if tmpl == "" {
		tmpl = template
	}
	formatter, err := event.NewFormatter(tmpl)
	if err != nil {
		return outputs.Fail(err)
	}
	if cfg.ParamKVDelimiter != "" {
		event.ParamKVDelimiter = cfg.ParamKVDelimiter
	}

	c := &console{
		writer:    bufio.NewWriterSize(stdout, 8*1024),
		formatter: formatter,
		format:    format(cfg.Format),
	}
	return outputs.Success(c), nil
}

func (c *console) Close() error   { return c.writer.Flush() }
func (c *console) Connect() error { return nil }
func (c *console) Publish(batch *event.Batch) error {
	for _, evt := range batch.Events {
		var buf []byte
		switch c.format {
		case json:
			buf = evt.MarshalJSON()
		case pretty:
			buf = c.formatter.Format(evt)
		default:
			return nil
		}

		if err := c.write(buf); err != nil {
			consoleErrors.Add(1)
			continue
		}
		if err := c.write(nl); err != nil {
			consoleErrors.Add(1)
			continue
		}
	}

	if err := c.writer.Flush(); err != nil {
		consoleErrors.Add(1)
		return err
	}

	return nil
}

var nl = []byte("\n")

func (c *console) write(buf []byte) error {
	written := 0
	for written < len(buf) {
		n, err := c.writer.Write(buf[written:])
		if err != nil {
			return err
		}
		written += n
	}
	return nil
}

```

`pkg/outputs/elasticsearch/config.go`:

```go
/*
 * Copyright 2019-2020 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package elasticsearch

import (
	"github.com/rabbitstack/fibratus/pkg/outputs"
	"github.com/spf13/pflag"
	"time"
)

const (
	esEnabled             = "output.elasticsearch.enabled"
	esServers             = "output.elasticsearch.servers"
	esTimeout             = "output.elasticsearch.timeout"
	esFlushPeriod         = "output.elasticsearch.flush-period"
	esHealthcheck         = "output.elasticsearch.healthcheck"
	esBulkWorkers         = "output.elasticsearch.bulk-workers"
	esHealthcheckInterval = "output.elasticsearch.healthcheck-interval"
	esHealthcheckTimeout  = "output.elasticsearch.healthcheck-timeout"
	esUsername            = "output.elasticsearch.username"
	esPassword            = "output.elasticsearch.password"
	esSniff               = "output.elasticsearch.sniff"
	esTraceLog            = "output.elasticsearch.trace-log"
	esIndexName           = "output.elasticsearch.index-name"
	esTemplateName        = "output.elasticsearch.template-name"
	esTemplateConfig      = "output.elasticsearch.template-config"
	esGzipCompression     = "output.elasticsearch.gzip-compression"
)

// Config contains the options for tweaking the output behaviour.
type Config struct {
	outputs.TLSConfig
	// Enabled determines whether ES output is enabled.
	Enabled bool `mapstructure:"enabled"`
	// Servers contains a comma separated list of Elasticsearch instances that comprise the cluster.
	Servers []string `mapstructure:"servers"`
	// Timeout specifies the connection timeout.
	Timeout time.Duration `mapstructure:"timeout"`
	// FlushPeriod specifies when to flush the bulk at the end of the given interval.
	FlushPeriod time.Duration `mapstructure:"flush-period"`
	// BulkWorkers represents the number of workers that commit docs to Elasticserach.
	BulkWorkers int `mapstructure:"bulk-workers"`
	// Healthcheck enables/disables nodes health checking.
	Healthcheck bool `mapstructure:"healthcheck"`
	// HealthCheckInterval specifies the interval for checking if the Elasticsearch nodes are available.
	HealthCheckInterval time.Duration `mapstructure:"healthcheck-interval"`
	// HealthCheckTimeout sets the timeout for periodic health checks.
	HealthCheckTimeout time.Duration `mapstructure:"healthcheck-timeout"`
	// Username is the user name for the basic HTTP authentication.
	Username string `mapstructure:"username"`
	// Password is the password for the basic HTTP authentication.
	Password string `mapstructure:"password"`
	// Sniff enables the discovery of all Elasticsearch nodes in the cluster. This avoids populating the list of available Elasticsearch nodes.
	Sniff bool `mapstructure:"sniff"`
	// TraceLog determines if the Elasticsearch trace log is enabled. Useful for troubleshooting.
	TraceLog bool `mapstructure:"tracelog"`
	// IndexName represents the target index for kernel events. It allows time specifiers to create indices per time frame.
	IndexName string `mapstructure:"index-name"`
	// TemplateName specifies the name of the index template.
	TemplateName string `mapstructure:"template-name"`
	// TemplateConfig contains the full JSON body of the index template.
	TemplateConfig string `mapstructure:"template-config"`
	// GzipCompression specifies if gzip compression is enabled.
	GzipCompression bool `mapstructure:"gzip-compression"`
}

// AddFlags registers persistent flags.
func AddFlags(flags *pflag.FlagSet) {
	flags.Bool(esEnabled, false, "Determines whether ES output is enabled")
	flags.StringSlice(esServers, []string{"http://127.0.0.1:9200"}, "Contains a comma separated list of Elasticsearch instances that comprise the cluster")
	flags.Duration(esTimeout, time.Second*5, "Specifies the output connection timeout")
	flags.Duration(esFlushPeriod, time.Second, "Specifies when to flush the bulk at the end of the given interval")
	flags.Int(esBulkWorkers, 1, "Represents the number of workers that commit docs to Elasticsearch")
	flags.Bool(esHealthcheck, true, "Enables/disables nodes health checking")
	flags.Duration(esHealthcheckInterval, time.Second*10, "Specifies the interval for checking if the Elasticsearch nodes are available")
	flags.Duration(esHealthcheckTimeout, time.Second*5, "Specifies the timeout for periodic health checks")
	flags.String(esUsername, "", "Identifies the user name for the basic HTTP authentication")
	flags.String(esPassword, "", "Specifies the password for the basic HTTP authentication")
	flags.Bool(esSniff, false, "Enables the discovery of all Elasticsearch nodes in the cluster. This avoids populating the list of available Elasticsearch nodes")
	flags.Bool(esTraceLog, false, "Determines if the Elasticsearch trace log is enabled. Useful for troubleshooting")
	flags.String(esTemplateName, "fibratus", "Specifies the name of the index template")
	flags.String(esIndexName, "fibratus", "Represents the target index for kernel events. It allows time specifiers to create indices per time frame")
	flags.String(esTemplateConfig, "", "Contains the full JSON body of the index template")
	flags.Bool(esGzipCompression, false, "Specifies if gzip compression is enabled")
}

```

`pkg/outputs/elasticsearch/elasticsearch.go`:

```go
/*
 * Copyright 2019-2020 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package elasticsearch

import (
	"context"
	"encoding/json"
	"expvar"
	"fmt"
	"github.com/hashicorp/go-version"
	"github.com/olivere/elastic/v7"
	"github.com/rabbitstack/fibratus/pkg/event"
	"github.com/rabbitstack/fibratus/pkg/outputs"
	"github.com/rabbitstack/fibratus/pkg/util/tls"
	log "github.com/sirupsen/logrus"
	"net/http"
)

// minElasticVersion is the minimal supported Elasticsearch version
var minElasticVersion, _ = version.NewVersion("5.5")

var (
	// totalBulkedDocs contains the number of total bulked docs
	totalBulkedDocs = expvar.NewInt("elasticsearch.total.bulked.docs")
	// committedDocs counts the number of docs commited to Elasticsearch
	committedDocs = expvar.NewInt("elasticsearch.committed.docs")
	// failedDocs counts the number of docs that failed to commit to Elasticsearch
	failedDocs = expvar.NewInt("elasticsearch.failed.docs")
)

type elasticsearch struct {
	client        *elastic.Client
	bulkProcessor *elastic.BulkProcessor
	config        Config
	index         index
}

type logger struct{}

func (l logger) Printf(format string, v ...interface{}) {
	log.Infof(format, v...)
}

func init() {
	outputs.Register(outputs.Elasticsearch, initElastic)
}

func initElastic(config outputs.Config) (outputs.OutputGroup, error) {
	cfg, ok := config.Output.(Config)
	if !ok {
		return outputs.Fail(outputs.ErrInvalidConfig(outputs.Elasticsearch, config.Output))
	}

	es := &elasticsearch{config: cfg, index: index{config: cfg}}

	return outputs.Success(es), nil
}

func (e *elasticsearch) Connect() error {
	var opts []elastic.ClientOptionFunc
	var client *elastic.Client
	var err error

	// setup a new HTTP client with optional TLS transport
	tlsConfig, err := tls.MakeConfig(e.config.TLSCert, e.config.TLSKey, e.config.TLSCA, e.config.TLSInsecureSkipVerify)
	if err != nil {
		return fmt.Errorf("invalid TLS config: %v", err)
	}
	httpClient := &http.Client{
		Timeout:   e.config.Timeout,
		Transport: &http.Transport{TLSClientConfig: tlsConfig},
	}

	opts = append(
		opts,
		elastic.SetSniff(e.config.Sniff),
		elastic.SetHttpClient(httpClient),
		elastic.SetURL(e.config.Servers...),
		elastic.SetGzip(e.config.GzipCompression),
		elastic.SetHealthcheck(e.config.Healthcheck),
		elastic.SetHealthcheckTimeout(e.config.HealthCheckTimeout),
		elastic.SetHealthcheckInterval(e.config.HealthCheckInterval),
	)

	if e.config.Username != "" && e.config.Password != "" {
		opts = append(
			opts,
			elastic.SetBasicAuth(e.config.Username, e.config.Password),
		)
	}
	if e.config.TraceLog {
		opts = append(opts, elastic.SetTraceLog(&logger{}))
	}

	client, err = elastic.NewClient(opts...)
	if err != nil {
		return err
	}

	ver, err := client.ElasticsearchVersion(e.config.Servers[0])
	if err != nil {
		return fmt.Errorf("unable to fetch Elasticsearch version: %v", err)
	}

	v, err := version.NewVersion(ver)
	if err != nil {
		return fmt.Errorf("unable to parse Elasticsearch version %s: %v", ver, err)
	}
	if v.LessThan(minElasticVersion) {
		return fmt.Errorf("required at least Elasticsearch %s but found version %s", minElasticVersion.String(), ver)
	}

	e.client = client
	e.index.client = client

	bulkProcessor, err := client.BulkProcessor().
		After(func(executionId int64, requests []elastic.BulkableRequest, response *elastic.BulkResponse, err error) {
			if err != nil {
				log.Errorf("failed to execute bulk: %s", err)
				return
			}

			if response.Errors {
				log.Errorf("failed to insert %d documents", len(response.Failed()))
				for i, fail := range response.Failed() {
					failedDocs.Add(1)
					log.Errorf("failed to insert document %d: %v", i, fail.Error)
				}
				return
			}
			committedDocs.Add(int64(len(requests)))
		}).
		FlushInterval(e.config.FlushPeriod).
		Workers(e.config.BulkWorkers).
		Do(context.Background())
	if err != nil {
		return fmt.Errorf("couldn't create Elasticsearch bulk processor: %v", err)
	}

	err = e.index.putTemplate()
	if err != nil {
		return err
	}

	err = bulkProcessor.Start(context.Background())
	if err != nil {
		return err
	}

	e.bulkProcessor = bulkProcessor

	log.Infof("established connection to Elasticsearch server(s): %v", e.config.Servers)

	return nil
}

func (e *elasticsearch) Publish(batch *event.Batch) error {
	for _, evt := range batch.Events {
		indexName := e.index.getName(evt)
		// create the bulk index request for each event in the batch.
		// We already have a valid JSON body, so just pass the raw
		// JSON message as request document
		e.bulkProcessor.Add(newBulkIndexRequest(indexName, evt))
		totalBulkedDocs.Add(1)
	}
	return nil
}

func newBulkIndexRequest(indexName string, evt *event.Event) *elastic.BulkIndexRequest {
	kjson := evt.MarshalJSON()
	return elastic.NewBulkIndexRequest().Index(indexName).Doc(json.RawMessage(kjson))
}

func (e *elasticsearch) Close() error {
	if e.bulkProcessor != nil {
		// commit outstanding requests before shutdown
		if err := e.bulkProcessor.Flush(); err != nil {
			return err
		}
		return e.bulkProcessor.Close()
	}
	return nil
}

```

`pkg/outputs/elasticsearch/elasticsearch_test.go`:

```go
/*
 * Copyright 2019-2020 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package elasticsearch

import (
	"bytes"
	"encoding/json"
	"github.com/rabbitstack/fibratus/pkg/util/va"
	"golang.org/x/sys/windows"
	"io"
	"net/http"
	"net/http/httptest"
	"strings"
	"testing"
	"time"

	"github.com/olivere/elastic/v7"
	"github.com/rabbitstack/fibratus/pkg/event"
	"github.com/rabbitstack/fibratus/pkg/event/params"
	htypes "github.com/rabbitstack/fibratus/pkg/handle/types"
	pstypes "github.com/rabbitstack/fibratus/pkg/ps/types"
	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/require"
)

func TestElasticsearchConnect(t *testing.T) {
	srv := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		ping := elastic.PingResult{
			Name: "es",
		}
		ping.Version.Number = "5.5.2"
		resp, err := json.Marshal(&ping)
		if err != nil {
			http.Error(w, err.Error(), http.StatusInternalServerError)
		}

		_, err = w.Write(resp)
		if err != nil {
			t.Fatal(err)
		}
	}))
	defer srv.Close()

	es := &elasticsearch{config: Config{Servers: []string{srv.URL}, Healthcheck: false}}

	require.NoError(t, es.Connect())
}

func TestElasticsearchConnectUnsupportedVersion(t *testing.T) {
	srv := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		ping := elastic.PingResult{
			Name: "es",
		}
		ping.Version.Number = "2.4.6"
		resp, err := json.Marshal(&ping)
		if err != nil {
			http.Error(w, err.Error(), http.StatusInternalServerError)
		}

		_, err = w.Write(resp)
		if err != nil {
			t.Fatal(err)
		}
	}))
	defer srv.Close()

	es := &elasticsearch{config: Config{Servers: []string{srv.URL}, Healthcheck: false}}

	require.Error(t, es.Connect())
}

func TestElasticsearchPublish(t *testing.T) {
	srv := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		if strings.Contains(r.URL.Path, "_bulk") {
			body, err := io.ReadAll(r.Body)
			if err != nil {
				http.Error(w, err.Error(), http.StatusInternalServerError)
				return
			}
			defer r.Body.Close()
			// check we have the correct index name
			assert.True(t, bytes.Contains(body, []byte("fibratus-2018-03")))
			// check event name is present
			assert.True(t, bytes.Contains(body, []byte("CreateFile")))

			// create the bulk response
			response := elastic.BulkResponse{
				Took:   1,
				Errors: false,
				Items:  []map[string]*elastic.BulkResponseItem{},
			}
			resp, err := json.Marshal(&response)
			if err != nil {
				http.Error(w, err.Error(), http.StatusInternalServerError)
			}

			_, err = w.Write(resp)
			if err != nil {
				t.Fatal(err)
			}
		} else {
			ping := elastic.PingResult{
				Name: "es",
			}
			ping.Version.Number = "5.5.2"
			resp, err := json.Marshal(&ping)
			if err != nil {
				http.Error(w, err.Error(), http.StatusInternalServerError)
			}

			_, err = w.Write(resp)
			if err != nil {
				t.Fatal(err)
			}
		}
	}))
	defer srv.Close()

	event.SerializeHandles = true

	cfg := Config{
		Servers:      []string{srv.URL},
		Healthcheck:  false,
		FlushPeriod:  time.Millisecond * 250,
		IndexName:    "fibratus-%Y-%d",
		TemplateName: "fibratus",
	}

	es := &elasticsearch{
		config: cfg,
		index:  index{config: cfg},
	}

	require.NoError(t, es.Connect())

	require.NoError(t, es.Publish(getBatch()))

	time.Sleep(time.Millisecond * 450)

	assert.Equal(t, int64(3), committedDocs.Value())
	assert.Equal(t, int64(0), failedDocs.Value())
}

func getBatch() *event.Batch {
	ts, _ := time.Parse(time.RFC3339, "2018-05-03T15:04:05.323Z")

	evt := &event.Event{
		Type:        event.CreateFile,
		Tid:         2484,
		PID:         859,
		CPU:         1,
		Seq:         2,
		Name:        "CreateFile",
		Timestamp:   ts,
		Category:    event.File,
		Host:        "archrabbit",
		Description: "Creates or opens a new file, directory, I/O device, pipe, console",
		Params: event.Params{
			params.FileObject:    {Name: params.FileObject, Type: params.Uint64, Value: uint64(12456738026482168384)},
			params.FilePath:      {Name: params.FilePath, Type: params.UnicodeString, Value: "\\Device\\HarddiskVolume2\\Windows\\system32\\user32.dll"},
			params.FileType:      {Name: params.FileType, Type: params.AnsiString, Value: "file"},
			params.FileOperation: {Name: params.FileOperation, Type: params.AnsiString, Value: "open"},
			params.BasePrio:      {Name: params.BasePrio, Type: params.Int8, Value: int8(2)},
			params.PagePrio:      {Name: params.PagePrio, Type: params.Uint8, Value: uint8(2)},
		},
		Metadata: map[event.MetadataKey]any{"foo": "bar", "fooz": "baarz"},
		PS: &pstypes.PS{
			PID:       2436,
			Ppid:      6304,
			Name:      "firefox.exe",
			Exe:       `C:\Program Files\Mozilla Firefox\firefox.exe`,
			Cmdline:   `C:\Program Files\Mozilla Firefox\firefox.exe -contentproc --channel="6304.3.1055809391\1014207667" -childID 1 -isForBrowser -prefsHandle 2584 -prefMapHandle 2580 -prefsLen 70 -prefMapSize 216993 -parentBuildID 20200107212822 -greomni "C:\Program Files\Mozilla Firefox\omni.ja" -appomni "C:\Program Files\Mozilla Firefox\browser\omni.ja" -appdir "C:\Program Files\Mozilla Firefox\browser" - 6304 "\\.\pipe\gecko-crash-server-pipe.6304" 2596 tab`,
			Cwd:       `C:\Program Files\Mozilla Firefox\`,
			SID:       "S-1-1-18",
			Args:      []string{"-contentproc", `--channel=6304.3.1055809391\1014207667`, "-childID", "1", "-isForBrowser", "-prefsHandle", "2584", "-prefMapHandle", "2580", "-prefsLen", "70", "-prefMapSize", "216993", "-parentBuildID"},
			SessionID: 4,
			Envs:      map[string]string{"ProgramData": "C:\\ProgramData", "COMPUTRENAME": "archrabbit"},
			Threads: map[uint32]pstypes.Thread{
				3453: {Tid: 3453, StartAddress: va.Address(140729524944768), IOPrio: 2, PagePrio: 5, KstackBase: va.Address(18446677035730165760), KstackLimit: va.Address(18446677035730137088), UstackLimit: va.Address(86376448), UstackBase: va.Address(86372352)},
				3455: {Tid: 3455, StartAddress: va.Address(140729524944768), IOPrio: 3, PagePrio: 5, KstackBase: va.Address(18446677035730165760), KstackLimit: va.Address(18446677035730137088), UstackLimit: va.Address(86376448), UstackBase: va.Address(86372352)},
			},
			Handles: []htypes.Handle{
				{Num: windows.Handle(0xffffd105e9baaf70),
					Name:   `\REGISTRY\MACHINE\SYSTEM\ControlSet001\Services\Tcpip\Parameters\Interfaces\{b677c565-6ca5-45d3-b618-736b4e09b036}`,
					Type:   "Key",
					Object: 777488883434455544,
					Pid:    uint32(1023),
				},
				{
					Num:  windows.Handle(0xffffd105e9adaf70),
					Name: `\RPC Control\OLEA61B27E13E028C4EA6C286932E80`,
					Type: "ALPC Port",
					Pid:  uint32(1023),
					MD: &htypes.AlpcPortInfo{
						Seqno:   1,
						Context: 0x0,
						Flags:   0x0,
					},
					Object: 457488883434455544,
				},
				{
					Num:  windows.Handle(0xeaffd105e9adaf30),
					Name: `C:\Users\bunny`,
					Type: "File",
					Pid:  uint32(1023),
					MD: &htypes.FileInfo{
						IsDirectory: true,
					},
					Object: 357488883434455544,
				},
			},
		},
	}

	evt1 := &event.Event{
		Type:        event.CreateFile,
		Tid:         2484,
		PID:         459,
		CPU:         1,
		Seq:         2,
		Name:        "CreateFile",
		Timestamp:   ts,
		Category:    event.File,
		Host:        "archrabbit",
		Description: "Creates or opens a new file, directory, I/O device, pipe, console",
		Params: event.Params{
			params.FileObject:    {Name: params.FileObject, Type: params.Uint64, Value: uint64(12456738026482168384)},
			params.FilePath:      {Name: params.FilePath, Type: params.UnicodeString, Value: "\\Device\\HarddiskVolume2\\Windows\\system32\\user32.dll"},
			params.FileType:      {Name: params.FileType, Type: params.AnsiString, Value: "file"},
			params.FileOperation: {Name: params.FileOperation, Type: params.AnsiString, Value: "open"},
			params.BasePrio:      {Name: params.BasePrio, Type: params.Int8, Value: int8(2)},
			params.PagePrio:      {Name: params.PagePrio, Type: params.Uint8, Value: uint8(2)},
		},
		Metadata: map[event.MetadataKey]any{"foo": "bar", "fooz": "baarz"},
		PS: &pstypes.PS{
			PID:       2436,
			Ppid:      6304,
			Name:      "firefox.exe",
			Exe:       `C:\Program Files\Mozilla Firefox\firefox.exe`,
			Cmdline:   `C:\Program Files\Mozilla Firefox\firefox.exe -contentproc --channel="6304.3.1055809391\1014207667" -childID 1 -isForBrowser -prefsHandle 2584 -prefMapHandle 2580 -prefsLen 70 -prefMapSize 216993 -parentBuildID 20200107212822 -greomni "C:\Program Files\Mozilla Firefox\omni.ja" -appomni "C:\Program Files\Mozilla Firefox\browser\omni.ja" -appdir "C:\Program Files\Mozilla Firefox\browser" - 6304 "\\.\pipe\gecko-crash-server-pipe.6304" 2596 tab`,
			Cwd:       `C:\Program Files\Mozilla Firefox\`,
			SID:       "S-1-1-18",
			Args:      []string{"-contentproc", `--channel=6304.3.1055809391\1014207667`, "-childID", "1", "-isForBrowser", "-prefsHandle", "2584", "-prefMapHandle", "2580", "-prefsLen", "70", "-prefMapSize", "216993", "-parentBuildID"},
			SessionID: 4,
			Envs:      map[string]string{"ProgramData": "C:\\ProgramData", "COMPUTRENAME": "archrabbit"},
			Threads: map[uint32]pstypes.Thread{
				3453: {Tid: 3453, StartAddress: va.Address(140729524944768), IOPrio: 2, PagePrio: 5, KstackBase: va.Address(18446677035730165760), KstackLimit: va.Address(18446677035730137088), UstackLimit: va.Address(86376448), UstackBase: va.Address(86372352)},
				3455: {Tid: 3455, StartAddress: va.Address(140729524944768), IOPrio: 3, PagePrio: 5, KstackBase: va.Address(18446677035730165760), KstackLimit: va.Address(18446677035730137088), UstackLimit: va.Address(86376448), UstackBase: va.Address(86372352)},
			},
			Handles: []htypes.Handle{
				{Num: windows.Handle(0xffffd105e9baaf70),
					Name:   `\REGISTRY\MACHINE\SYSTEM\ControlSet001\Services\Tcpip\Parameters\Interfaces\{b677c565-6ca5-45d3-b618-736b4e09b036}`,
					Type:   "Key",
					Object: 777488883434455544,
					Pid:    uint32(1023),
				},
				{
					Num:  windows.Handle(0xffffd105e9adaf70),
					Name: `\RPC Control\OLEA61B27E13E028C4EA6C286932E80`,
					Type: "ALPC Port",
					Pid:  uint32(1023),
					MD: &htypes.AlpcPortInfo{
						Seqno:   1,
						Context: 0x0,
						Flags:   0x0,
					},
					Object: 457488883434455544,
				},
				{
					Num:  windows.Handle(0xeaffd105e9adaf30),
					Name: `C:\Users\bunny`,
					Type: "File",
					Pid:  uint32(1023),
					MD: &htypes.FileInfo{
						IsDirectory: true,
					},
					Object: 357488883434455544,
				},
			},
		},
	}

	evt2 := &event.Event{
		Type:        event.CreateFile,
		Tid:         2484,
		PID:         829,
		CPU:         1,
		Seq:         2,
		Name:        "CreateFile",
		Timestamp:   ts,
		Category:    event.File,
		Host:        "archrabbit",
		Description: "Creates or opens a new file, directory, I/O device, pipe, console",
		Params: event.Params{
			params.FileObject:    {Name: params.FileObject, Type: params.Uint64, Value: uint64(12456738026482168384)},
			params.FilePath:      {Name: params.FilePath, Type: params.UnicodeString, Value: "\\Device\\HarddiskVolume2\\Windows\\system32\\user32.dll"},
			params.FileType:      {Name: params.FileType, Type: params.AnsiString, Value: "file"},
			params.FileOperation: {Name: params.FileOperation, Type: params.AnsiString, Value: "open"},
			params.BasePrio:      {Name: params.BasePrio, Type: params.Int8, Value: int8(2)},
			params.PagePrio:      {Name: params.PagePrio, Type: params.Uint8, Value: uint8(2)},
		},
		Metadata: map[event.MetadataKey]any{"foo": "bar", "fooz": "baarz"},
		PS: &pstypes.PS{
			PID:       829,
			Ppid:      6304,
			Name:      "firefox.exe",
			Exe:       `C:\Program Files\Mozilla Firefox\firefox.exe`,
			Cmdline:   `C:\Program Files\Mozilla Firefox\firefox.exe -contentproc --channel="6304.3.1055809391\1014207667" -childID 1 -isForBrowser -prefsHandle 2584 -prefMapHandle 2580 -prefsLen 70 -prefMapSize 216993 -parentBuildID 20200107212822 -greomni "C:\Program Files\Mozilla Firefox\omni.ja" -appomni "C:\Program Files\Mozilla Firefox\browser\omni.ja" -appdir "C:\Program Files\Mozilla Firefox\browser" - 6304 "\\.\pipe\gecko-crash-server-pipe.6304" 2596 tab`,
			Cwd:       `C:\Program Files\Mozilla Firefox\`,
			SID:       "S-1-1-18",
			Args:      []string{"-contentproc", `--channel=6304.3.1055809391\1014207667`, "-childID", "1", "-isForBrowser", "-prefsHandle", "2584", "-prefMapHandle", "2580", "-prefsLen", "70", "-prefMapSize", "216993", "-parentBuildID"},
			SessionID: 4,
			Envs:      map[string]string{"ProgramData": "C:\\ProgramData", "COMPUTRENAME": "archrabbit"},
			Threads: map[uint32]pstypes.Thread{
				3453: {Tid: 3453, StartAddress: va.Address(140729524944768), IOPrio: 2, PagePrio: 5, KstackBase: va.Address(18446677035730165760), KstackLimit: va.Address(18446677035730137088), UstackLimit: va.Address(86376448), UstackBase: va.Address(86372352)},
				3455: {Tid: 3455, StartAddress: va.Address(140729524944768), IOPrio: 3, PagePrio: 5, KstackBase: va.Address(18446677035730165760), KstackLimit: va.Address(18446677035730137088), UstackLimit: va.Address(86376448), UstackBase: va.Address(86372352)},
			},
			Handles: []htypes.Handle{
				{Num: windows.Handle(0xffffd105e9baaf70),
					Name:   `\REGISTRY\MACHINE\SYSTEM\ControlSet001\Services\Tcpip\Parameters\Interfaces\{b677c565-6ca5-45d3-b618-736b4e09b036}`,
					Type:   "Key",
					Object: 777488883434455544,
					Pid:    uint32(1023),
				},
				{
					Num:  windows.Handle(0xffffd105e9adaf70),
					Name: `\RPC Control\OLEA61B27E13E028C4EA6C286932E80`,
					Type: "ALPC Port",
					Pid:  uint32(1023),
					MD: &htypes.AlpcPortInfo{
						Seqno:   1,
						Context: 0x0,
						Flags:   0x0,
					},
					Object: 457488883434455544,
				},
				{
					Num:  windows.Handle(0xeaffd105e9adaf30),
					Name: `C:\Users\bunny`,
					Type: "File",
					Pid:  uint32(1023),
					MD: &htypes.FileInfo{
						IsDirectory: true,
					},
					Object: 357488883434455544,
				},
			},
		},
	}

	return event.NewBatch(evt, evt1, evt2)
}

```

`pkg/outputs/elasticsearch/index.go`:

```go
/*
 * Copyright 2019-2020 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package elasticsearch

import (
	"bytes"
	"context"
	"fmt"
	"github.com/olivere/elastic/v7"
	"github.com/rabbitstack/fibratus/pkg/event"
	"html/template"
	"strings"
	"time"
)

type index struct {
	config Config
	client *elastic.Client
}

// putTemplate creates the index template.
func (i index) putTemplate() error {
	if i.config.TemplateName == "" {
		return nil
	}
	// get the index pattern for the template
	indexPattern := i.config.IndexName
	if strings.Contains(indexPattern, "%") {
		indexPattern = indexPattern[0:strings.Index(indexPattern, "%")]
	}

	var b bytes.Buffer
	if i.config.TemplateConfig != "" {
		b.WriteString(i.config.TemplateConfig)
	} else {
		// expand the Go template
		tmpl := template.Must(template.New("template").Parse(indexTemplate))
		err := tmpl.Execute(&b, templateInfo{IndexPattern: indexPattern + "*"})
		if err != nil {
			return err
		}
	}

	ctx := context.Background()

	exists, err := i.client.IndexTemplateExists(i.config.TemplateName).Do(ctx)
	if err != nil {
		return fmt.Errorf("unable to check the existence of the %q template: %v", i.config.TemplateName, err)
	}
	if exists {
		return nil
	}
	// create index template
	_, err = i.client.IndexPutTemplate(i.config.TemplateName).BodyJson(b.String()).Do(ctx)
	if err != nil {
		return fmt.Errorf("unable to create index for the %q template: %v", i.config.TemplateName, err)
	}

	return nil
}

// getName creates an index name by replacing specifiers to create time frame indices. If no time specifiers are
// used this method returns a fixed index name.
func (i index) getName(evt *event.Event) string {
	indexName := i.config.IndexName
	if !strings.Contains(indexName, "%") {
		return indexName
	}
	return i.replace(evt.Timestamp)
}

func (i index) replace(timestamp time.Time) string {
	return strings.NewReplacer(
		"%Y", timestamp.UTC().Format("2006"),
		"%y", timestamp.UTC().Format("06"),
		"%m", timestamp.UTC().Format("01"),
		"%d", timestamp.UTC().Format("02"),
		"%H", timestamp.UTC().Format("15")).Replace(i.config.IndexName)
}

```

`pkg/outputs/elasticsearch/index_test.go`:

```go
/*
 * Copyright 2019-2020 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package elasticsearch

import (
	"github.com/rabbitstack/fibratus/pkg/event"
	"github.com/stretchr/testify/assert"
	"testing"
	"time"
)

func TestProduceIndexName(t *testing.T) {
	i := index{config: Config{IndexName: "fibratus-%Y-%m"}}

	ts, _ := time.Parse(time.RFC3339, "2011-05-03T15:04:05.323Z")

	indexName := i.getName(&event.Event{Timestamp: ts})
	assert.Equal(t, "fibratus-2011-05", indexName)

	i = index{config: Config{IndexName: "fibratus-%y-%d"}}

	indexName = i.getName(&event.Event{Timestamp: ts})
	assert.Equal(t, "fibratus-11-03", indexName)

	i = index{config: Config{IndexName: "fibratus-%d-%H"}}

	indexName = i.getName(&event.Event{Timestamp: ts})
	assert.Equal(t, "fibratus-03-15", indexName)

	i = index{config: Config{IndexName: "fibratus-events"}}

	indexName = i.getName(&event.Event{Timestamp: ts})
	assert.Equal(t, "fibratus-events", indexName)
}

```

`pkg/outputs/elasticsearch/template.go`:

```go
/*
 * Copyright 2019-2020 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package elasticsearch

type templateInfo struct {
	IndexPattern string
}

const indexTemplate = `
{
	"index_patterns": [ "{{ .IndexPattern }}" ],
	"settings": {
		"index": {
			"refresh_interval": "5s",
			"number_of_shards": 1,
			"number_of_replicas": 1
		}
	},
	"mappings": {
		"properties": {
			"seq": { "type": "long" },
			"pid": { "type": "long" },
			"tid": { "type": "long" },
			"cpu": { "type": "short" },

			"name": { "type": "keyword" },
			"category": { "type": "keyword" },
			"description": { "type": "text" },
			"host": { "type": "keyword" },

			"timestamp": { "type": "date" },

			"params": { 
				"type": "nested",
			    "properties": {
					"dip": { "type": "ip" },
					"sip": { "type": "ip" }
				}
			},
			
			"ps": {
				"type": "nested",
			    "properties": {
					"pid": { "type": "long" },
					"ppid": { "type": "long" },
					"name": { "type": "keyword" },
					"comm": { "type": "text" },
					"exe": { "type": "text" },
					"cwd": { "type": "text" },
					"sid": { "type": "keyword" },
					"sessionid": { "type": "short" },
					"handles": {
						"type": "nested",
						"properties": {
							"name": { "type": "text" },
							"type": { "type": "text" },
							"id": 	{ "type": "long" },
							"object": { "type": "keyword" }
						}
					}
				}
			}
			
		}
	}
}
`

```

`pkg/outputs/eventlog/api.go`:

```go
/*
 * Copyright 2012 The Go Authors. All rights reserved.
 * Use of this source code is governed by a BSD-style
 * license that can be found in the LICENSE file.
 *
 * Copyright 2021-2022 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package eventlog

import (
	"bytes"
	"errors"
	"github.com/rabbitstack/fibratus/pkg/util/eventlog"
	"syscall"

	"golang.org/x/sys/windows"
)

// Eventlog provides access to the system log.
type Eventlog struct {
	Handle windows.Handle
}

// Open retrieves a handle to the specified event log.
func Open(source string) (*Eventlog, error) {
	return OpenRemote("", source)
}

// OpenRemote does the same as Open, but on different computer host.
func OpenRemote(host, source string) (*Eventlog, error) {
	if source == "" {
		return nil, errors.New("specify event log source")
	}
	var serverName *uint16
	if host != "" {
		var err error
		serverName, err = syscall.UTF16PtrFromString(host)
		if err != nil {
			return nil, err
		}
	}
	sourceName, err := syscall.UTF16PtrFromString(source)
	if err != nil {
		return nil, err
	}
	h, err := windows.RegisterEventSource(serverName, sourceName)
	if err != nil {
		return nil, err
	}
	return &Eventlog{Handle: h}, nil
}

// Close closes event log.
func (l *Eventlog) Close() error {
	return windows.DeregisterEventSource(l.Handle)
}

func (l *Eventlog) report(etype uint16, eid uint32, category uint16, msg []byte) error {
	lines := bytes.Split(msg, []byte("\n"))
	ss := make([]*uint16, len(lines))
	for i, line := range lines {
		// line breaks
		if len(line) == 0 {
			line = []byte("\n")
		}
		s, err := syscall.UTF16PtrFromString(string(line))
		if err != nil {
			continue
		}
		ss[i] = s
	}
	return windows.ReportEvent(l.Handle, etype, category, eid, 0, uint16(len(ss)), 0, &ss[0], nil)
}

// Info writes an information event msg with event id eid to the end of event log.
func (l *Eventlog) Info(eid uint32, category uint16, msg []byte) error {
	return l.report(uint16(eventlog.Info), eid, category, msg)
}

// Warning writes a warning event msg with event id eid to the end of event log.
func (l *Eventlog) Warning(eid uint32, category uint16, msg []byte) error {
	return l.report(uint16(eventlog.Warn), eid, category, msg)
}

// Error writes an error event msg with event id eid to the end of event log.
func (l *Eventlog) Error(eid uint32, category uint16, msg []byte) error {
	return l.report(uint16(eventlog.Erro), eid, category, msg)
}

```

`pkg/outputs/eventlog/config.go`:

```go
/*
 * Copyright 2021-2022 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package eventlog

import (
	"github.com/rabbitstack/fibratus/pkg/event"
	"text/template"

	"github.com/spf13/pflag"
)

const (
	enabled    = "output.eventlog.enabled"
	level      = "output.eventlog.level"
	remoteHost = "output.eventlog.remote-host"
	tmpl       = "output.eventlog.template"
)

// Config contains configuration properties for fine-tuning the eventlog output.
type Config struct {
	// Enabled determines whether the eventlog output is enabled.
	Enabled bool `mapstructure:"enabled"`
	// Level specifies the eventlog log level.
	Level string `mapstructure:"level"`
	// RemoteHost is the address of the remote eventlog intake.
	RemoteHost string `mapstructure:"remote-host"`
	// Template specifies the Go template for rendering the eventlog message.
	Template string `mapstructure:"template"`
}

func (c Config) parseTemplate() (*template.Template, error) {
	if c.Template == "" {
		// use built-in template
		return template.New("evtlog").Parse(event.Template)
	}
	return template.New("evtlog").Parse(c.Template)
}

// AddFlags registers persistent flags.
func AddFlags(flags *pflag.FlagSet) {
	flags.String(tmpl, "", "Go template for rendering the eventlog message")
	flags.String(level, "info", "Specifies the eventlog level. Deprecated")
	flags.String(remoteHost, "", "Address of the remote eventlog intake")
	flags.Bool(enabled, false, "Indicates if the eventlog output is enabled")
}

```

`pkg/outputs/eventlog/eventlog.go`:

```go
/*
 * Copyright 2021-2022 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

//go:generate go run github.com/rabbitstack/fibratus/pkg/outputs/eventlog/mc

package eventlog

import (
	"errors"
	"github.com/rabbitstack/fibratus/pkg/util/eventlog"
	"golang.org/x/sys/windows"
	"text/template"

	"github.com/rabbitstack/fibratus/pkg/event"
	"github.com/rabbitstack/fibratus/pkg/outputs"
)

const (
	// categoryOffset specifies the start of the event id number space
	categoryOffset = 25
)

// ErrUnknownEventID represents the error for signaling unknown event identifiers. This error
// is raised when we can't get a valid mapping for the existing kernel event type.
var ErrUnknownEventID = errors.New("unknown event id found")

type evtlog struct {
	evtlog *Eventlog // eventlog writer
	config Config
	tmpl   *template.Template
	events []event.Info
	cats   []string
}

func init() {
	outputs.Register(outputs.Eventlog, initEventlog)
}

func initEventlog(config outputs.Config) (outputs.OutputGroup, error) {
	cfg, ok := config.Output.(Config)
	if !ok {
		return outputs.Fail(outputs.ErrInvalidConfig(outputs.Eventlog, config.Output))
	}
	err := eventlog.Install(eventlog.Levels)
	if err != nil {
		// ignore error if the key already exists
		if !errors.Is(err, eventlog.ErrKeyExists) {
			return outputs.Fail(err)
		}
	}
	evtlog := &evtlog{
		config: cfg,
		events: event.GetTypesMetaIndexed(),
		cats:   event.Categories(),
	}
	evtlog.tmpl, err = cfg.parseTemplate()
	if err != nil {
		return outputs.Fail(err)
	}
	return outputs.Success(evtlog), nil
}

func (e *evtlog) Connect() error {
	var (
		evl *Eventlog
		err error
	)
	if e.config.RemoteHost != "" {
		evl, err = OpenRemote(e.config.RemoteHost, eventlog.Source)
	} else {
		evl, err = Open(eventlog.Source)
	}
	if err != nil {
		return err
	}
	e.evtlog = evl
	return nil
}

func (e *evtlog) Close() error {
	if e.evtlog != nil {
		return e.evtlog.Close()
	}
	return nil
}

func (e *evtlog) Publish(batch *event.Batch) error {
	for _, evt := range batch.Events {
		if err := e.publish(evt); err != nil {
			return err
		}
	}
	return nil
}

func (e *evtlog) publish(evt *event.Event) error {
	buf, err := evt.RenderCustomTemplate(e.tmpl)
	if err != nil {
		return err
	}
	categoryID := e.categoryID(evt)
	eventID := eventlog.EventID(windows.EVENTLOG_INFORMATION_TYPE, uint16(e.eventCode(evt)))
	if eventID == 0 {
		return ErrUnknownEventID
	}
	err = e.evtlog.Info(eventID, categoryID, buf)
	if err != nil {
		return err
	}
	return nil
}

// categoryID maps category name to eventlog identifier.
func (e *evtlog) categoryID(evt *event.Event) uint16 {
	for i, cat := range e.cats {
		if cat == string(evt.Category) {
			return uint16(i + 1)
		}
	}
	return 0
}

// eventCode returns the event ID from the event type.
func (e *evtlog) eventCode(evt *event.Event) uint32 {
	for i, e := range e.events {
		if evt.Name == e.Name {
			return uint32(i + categoryOffset)
		}
	}
	return 0
}

```

`pkg/outputs/eventlog/eventlog_test.go`:

```go
/*
 * Copyright 2021-2022 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package eventlog

import (
	"errors"
	"github.com/rabbitstack/fibratus/pkg/util/eventlog"
	"github.com/rabbitstack/fibratus/pkg/util/va"
	"golang.org/x/sys/windows"
	"testing"
	"time"

	"github.com/rabbitstack/fibratus/pkg/event"
	"github.com/rabbitstack/fibratus/pkg/event/params"
	htypes "github.com/rabbitstack/fibratus/pkg/handle/types"
	"github.com/rabbitstack/fibratus/pkg/pe"
	pstypes "github.com/rabbitstack/fibratus/pkg/ps/types"
	"github.com/stretchr/testify/require"
)

func TestEvtlogPublish(t *testing.T) {
	c := Config{
		Level: "INFO",
	}
	tmpl, err := c.parseTemplate()
	require.NoError(t, err)
	el := &evtlog{
		config: c,
		tmpl:   tmpl,
		events: event.GetTypesMetaIndexed(),
		cats:   event.Categories(),
	}
	err = eventlog.Install(eventlog.Levels)
	if err != nil && !errors.Is(err, eventlog.ErrKeyExists) {
		require.NoError(t, err)
	}
	require.NoError(t, el.Connect())
	require.NoError(t, el.Publish(getBatch()))
}

func getBatch() *event.Batch {
	evt := &event.Event{
		Type:        event.CreateFile,
		Tid:         2484,
		PID:         859,
		CPU:         1,
		Seq:         2,
		Name:        "CreateFile",
		Timestamp:   time.Now(),
		Category:    event.File,
		Host:        "archrabbit",
		Description: "Creates or opens a new file, directory, I/O device, pipe, console",
		Params: event.Params{
			params.FileObject:    {Name: params.FileObject, Type: params.Uint64, Value: uint64(12456738026482168384)},
			params.FilePath:      {Name: params.FilePath, Type: params.UnicodeString, Value: "\\Device\\HarddiskVolume2\\Windows\\system32\\user32.dll"},
			params.FileType:      {Name: params.FileType, Type: params.AnsiString, Value: "file"},
			params.FileOperation: {Name: params.FileOperation, Type: params.AnsiString, Value: "open"},
			params.BasePrio:      {Name: params.BasePrio, Type: params.Int8, Value: int8(2)},
			params.PagePrio:      {Name: params.PagePrio, Type: params.Uint8, Value: uint8(2)},
		},
		Metadata: map[event.MetadataKey]any{"foo": "bar", "fooz": "baarz"},
		PS: &pstypes.PS{
			PID:       2436,
			Ppid:      6304,
			Name:      "firefox.exe",
			Exe:       `C:\Program Files\Mozilla Firefox\firefox.exe`,
			Cmdline:   `C:\Program Files\Mozilla Firefox\firefox.exe -contentproc --channel="6304.3.1055809391\1014207667" -childID 1 -isForBrowser -prefsHandle 2584 -prefMapHandle 2580 -prefsLen 70 -prefMapSize 216993 -parentBuildID 20200107212822 -greomni "C:\Program Files\Mozilla Firefox\omni.ja" -appomni "C:\Program Files\Mozilla Firefox\browser\omni.ja" -appdir "C:\Program Files\Mozilla Firefox\browser" - 6304 "\\.\pipe\gecko-crash-server-pipe.6304" 2596 tab`,
			Cwd:       `C:\Program Files\Mozilla Firefox\`,
			SID:       "archrabbit\\SYSTEM",
			Args:      []string{"-contentproc", `--channel=6304.3.1055809391\1014207667`, "-childID", "1", "-isForBrowser", "-prefsHandle", "2584", "-prefMapHandle", "2580", "-prefsLen", "70", "-prefMapSize", "216993", "-parentBuildID"},
			SessionID: 4,
			Envs:      map[string]string{"ProgramData": "C:\\ProgramData", "COMPUTRENAME": "archrabbit"},
			Threads: map[uint32]pstypes.Thread{
				3453: {Tid: 3453, StartAddress: va.Address(140729524944768), IOPrio: 2, PagePrio: 5, KstackBase: va.Address(18446677035730165760), KstackLimit: va.Address(18446677035730137088), UstackLimit: va.Address(86376448), UstackBase: va.Address(86372352)},
				3455: {Tid: 3455, StartAddress: va.Address(140729524944768), IOPrio: 3, PagePrio: 5, KstackBase: va.Address(18446677035730165760), KstackLimit: va.Address(18446677035730137088), UstackLimit: va.Address(86376448), UstackBase: va.Address(86372352)},
			},
			Modules: []pstypes.Module{
				{Name: "kernel32.dll", Size: 12354, Checksum: 23123343, BaseAddress: va.Address(4294066175), DefaultBaseAddress: va.Address(4293993725)},
				{Name: "user32.dll", Size: 212354, Checksum: 33123343, BaseAddress: va.Address(4277288959), DefaultBaseAddress: va.Address(4293993725)},
			},
			Handles: []htypes.Handle{
				{Num: windows.Handle(0xffffd105e9baaf70),
					Name:   `\REGISTRY\MACHINE\SYSTEM\ControlSet001\Services\Tcpip\Parameters\Interfaces\{b677c565-6ca5-45d3-b618-736b4e09b036}`,
					Type:   "Key",
					Object: 777488883434455544,
					Pid:    uint32(1023),
				},
				{
					Num:  windows.Handle(0xffffd105e9adaf70),
					Name: `\RPC Control\OLEA61B27E13E028C4EA6C286932E80`,
					Type: "ALPC Port",
					Pid:  uint32(1023),
					MD: &htypes.AlpcPortInfo{
						Seqno:   1,
						Context: 0x0,
						Flags:   0x0,
					},
					Object: 457488883434455544,
				},
				{
					Num:  windows.Handle(0xeaffd105e9adaf30),
					Name: `C:\Users\bunny`,
					Type: "File",
					Pid:  uint32(1023),
					MD: &htypes.FileInfo{
						IsDirectory: true,
					},
					Object: 357488883434455544,
				},
			},
			PE: &pe.PE{
				NumberOfSections: 2,
				NumberOfSymbols:  10,
				EntryPoint:       "0x20110",
				ImageBase:        "0x140000000",
				LinkTime:         time.Now(),
				Sections: []pe.Sec{
					{Name: ".text", Size: 132608, Entropy: 6.368381, Md5: "db23dce3911a42e987041d98abd4f7cd"},
					{Name: ".rdata", Size: 35840, Entropy: 5.996976, Md5: "ffa5c960b421ca9887e54966588e97e8"},
				},
				Symbols:          []string{"SelectObject", "GetTextFaceW", "EnumFontsW", "TextOutW", "GetProcessHeap"},
				Imports:          []string{"GDI32.dll", "USER32.dll", "msvcrt.dll", "api-ms-win-core-libraryloader-l1-2-0.dl"},
				VersionResources: map[string]string{"CompanyName": "Microsoft Corporation", "FileDescription": "Notepad", "FileVersion": "10.0.18362.693"},
			},
		},
	}

	return event.NewBatch(evt)
}

```

`pkg/outputs/eventlog/mc/gen.go`:

```go
/*
 * Copyright 2021-2022 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package main

import (
	"bytes"
	"fmt"
	"github.com/Masterminds/sprig/v3"
	"github.com/rabbitstack/fibratus/pkg/event"
	"io"
	"log"
	"math"
	"os"
	"text/template"
)

// Source contains the required data for producing the input for the message compiler.
type Source struct {
	Categories []string
	Events     []event.Info
	MaxEvents  uint16
}

func (s *Source) Generate(w io.Writer) error {
	funcmap := sprig.TxtFuncMap()
	funcmap["length"] = func(evts []event.Info) int {
		return len(evts)
	}
	funcmap["N"] = func(start, end int) (stream chan int) {
		stream = make(chan int)
		go func() {
			for i := start; i <= end; i++ {
				stream <- i
			}
			close(stream)
		}()
		return
	}
	t := template.Must(template.New("main").Funcs(funcmap).Parse(srcTemplate))
	err := t.Execute(w, s)
	if err != nil {
		return fmt.Errorf("failed to execute template: %v", err)
	}
	return nil
}

func main() {
	var buf bytes.Buffer

	src := &Source{
		Categories: event.Categories(),
		Events:     event.GetTypesMetaIndexed(),
		MaxEvents:  math.MaxUint16,
	}

	if err := src.Generate(&buf); err != nil {
		log.Fatal(err)
	}
	if err := os.WriteFile("mc/fibratus.mc", buf.Bytes(), 0644); err != nil {
		log.Fatal(err)
	}
}

const srcTemplate = `
;// Code generated by 'go generate'; DO NOT EDIT.
MessageIdTypedef=DWORD

LanguageNames=(English=0x409:MSG00409)

;//************** Event categories ************
{{- range $i, $cat := .Categories }}
MessageId={{ add1 $i }}
SymbolicName={{title $cat}}
Language=English
{{ title $cat }}
.
{{- end }}

{{ $catOffset := 25 }}

;//*********** Event types **************
{{- range $i, $e := .Events }}
MessageId={{ add $i $catOffset }}
SymbolicName={{ $e.Name }}
Language=English
{{ $e.Description }}
.
{{- end }}

{{ $n := length .Events }}
{{ $n = add $n $catOffset | int }}
{{ $e := sub .MaxEvents $n | int }}

{{- range $i, $_ := N $n $e }}
MessageId={{ add $i $n }}
SymbolicName=Reserved{{ add $i $n }}
Language=English
%1
.
{{- end }}
`

```

`pkg/outputs/http/client.go`:

```go
/*
 * Copyright 2021-2022 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package http

import (
	"fmt"
	"net/http"
	"net/url"

	"github.com/rabbitstack/fibratus/pkg/util/tls"
)

// newHTTPClient builds a fresh stdlib HTTP client. The HTTP proxy and TLS config is set
// accordingly if enabled in the HTTP output preferences.
func newHTTPClient(config Config) (*http.Client, error) {
	tlsConfig, err := tls.MakeConfig(config.TLSCert, config.TLSKey, config.TLSCA, config.TLSInsecureSkipVerify)
	if err != nil {
		return nil, fmt.Errorf("invalid TLS config: %v", err)
	}

	proxy := http.ProxyFromEnvironment
	if config.ProxyURL != "" {
		address, err := url.Parse(config.ProxyURL)
		if err != nil {
			return nil, fmt.Errorf("invalid HTTP proxy url %q: %w", config.ProxyURL, err)
		}
		if config.ProxyUsername != "" && config.ProxyPassword != "" {
			proxy = http.ProxyURL(&url.URL{
				Scheme: address.Scheme,
				User:   url.UserPassword(config.ProxyUsername, config.ProxyPassword),
				Host:   config.ProxyURL,
			})
		} else {
			proxy = http.ProxyURL(address)
		}
	}

	transport := &http.Transport{
		TLSClientConfig: tlsConfig,
		Proxy:           proxy,
	}
	httpClient := &http.Client{
		Transport: transport,
		Timeout:   config.Timeout,
	}

	return httpClient, nil
}

```

`pkg/outputs/http/config.go`:

```go
/*
 * Copyright 2021-2022 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package http

import (
	"time"

	"github.com/spf13/pflag"

	"github.com/rabbitstack/fibratus/pkg/outputs"
)

const (
	httpEnabled       = "output.http.enabled"
	httpTimeout       = "output.http.timeout"
	httpProxyURL      = "output.http.proxy-url"
	httpProxyUsername = "output.http.proxy-username"
	httpProxyPassword = "output.http.proxy-password"
	httpMethod        = "output.http.method"
	httpUsername      = "output.http.username"
	httpPassword      = "output.http.password"
	httpEndpoints     = "output.http.endpoints"
	httpEnableGzip    = "output.http.enable-gzip"
	httpSerializer    = "output.http.serializer"
)

// Config contains the options for tweaking the HTTP output behaviour.
type Config struct {
	outputs.TLSConfig
	// Enabled determines whether HTTP output is enabled.
	Enabled bool `mapstructure:"enabled"`
	// Endpoints contains a collection of URLs to which the events are sent.
	Endpoints []string `mapstructure:"endpoints"`
	// Timeout represents the timeout for the HTTP requests.
	Timeout time.Duration `mapstructure:"timeout"`
	// ProxyURL specifies the HTTP proxy URL.
	ProxyURL string `mapstructure:"proxy-url"`
	// ProxyUsername is the username for proxy authentication.
	ProxyUsername string `mapstructure:"proxy-username"`
	// ProxyPassword is the password for proxy authentication.
	ProxyPassword string `mapstructure:"proxy-password"`
	// Method determines the HTTP verb in the requests.
	Method string `mapstructure:"method"`
	// Username is the username for the basic HTTP authentication.
	Username string `mapstructure:"username"`
	// Password is the password for the basic HTTP authentication.
	Password string `mapstructure:"password"`
	// Headers contains a list of additional headers in the HTTP request
	Headers map[string]string `mapstructure:"headers"`
	// EnableGzip specifies whether the gzip compression is enabled.
	EnableGzip bool `mapstructure:"enable-gzip"`
	// Serializer indicates the serializer for the HTTP request body.
	Serializer outputs.Serializer `mapstructure:"serializer"`
}

// AddFlags registers persistent flags for the HTTP output.
func AddFlags(flags *pflag.FlagSet) {
	flags.Bool(httpEnabled, false, "Determines whether the HTTP output is enabled")
	flags.Duration(httpTimeout, time.Second*5, "Represents the timeout for the HTTP requests")
	flags.StringSlice(httpEndpoints, []string{}, "A comma-separated list of endpoints to which the events are sent. Must contain the HTTP/S protocol schema")
	flags.String(httpProxyURL, "", "Specifies the HTTP proxy URL. It overrides the HTTP proxy URL as indicated by the environment variables")
	flags.String(httpProxyUsername, "", "The username for HTTP proxy authentication")
	flags.String(httpProxyPassword, "", "The password for HTTP proxy authentication")
	flags.String(httpMethod, "POST", "Determines the HTTP verb to use in requests")
	flags.String(httpUsername, "", "Username for the basic HTTP authentication")
	flags.String(httpPassword, "", "Password for the basic HTTP authentication")
	flags.Bool(httpEnableGzip, false, "Indicates whether the gzip compression is enabled")
	flags.String(httpSerializer, string(outputs.JSON), "Indicates the event serializer type")
	outputs.AddTLSFlags(flags, outputs.HTTP)
}

```

`pkg/outputs/http/http.go`:

```go
/*
 * Copyright 2021-2022 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package http

import (
	"bytes"
	"compress/gzip"
	"context"
	"fmt"
	"io"
	"net/http"
	"net/url"

	"github.com/rabbitstack/fibratus/pkg/util/version"

	"github.com/rabbitstack/fibratus/pkg/event"
	"github.com/rabbitstack/fibratus/pkg/outputs"
)

// userAgentHeader represents the value of the User-Agent header
var userAgentHeader = version.ProductToken()

// defaultContentType represents the default content type for HTTP requests
const defaultContentType = "application/json"

type _http struct {
	client *http.Client
	config Config
	url    string
}

func init() {
	outputs.Register(outputs.HTTP, initHTTP)
}

func initHTTP(config outputs.Config) (outputs.OutputGroup, error) {
	cfg, ok := config.Output.(Config)
	if !ok {
		return outputs.Fail(outputs.ErrInvalidConfig(outputs.HTTP, config.Output))
	}

	clients := make([]outputs.Client, len(cfg.Endpoints))
	for i, endpoint := range cfg.Endpoints {
		_, err := url.Parse(endpoint)
		if err != nil {
			return outputs.Fail(err)
		}
		client, err := newHTTPClient(cfg)
		if err != nil {
			return outputs.Fail(err)
		}

		clients[i] = &_http{
			client: client,
			config: cfg,
			url:    endpoint,
		}
	}

	return outputs.Success(clients...), nil
}

func (h *_http) Connect() error { return nil }
func (h *_http) Close() error   { return nil }

func (h *_http) Publish(batch *event.Batch) error {
	var buf []byte
	switch h.config.Serializer {
	case outputs.JSON:
		buf = batch.MarshalJSON()
	}

	if h.config.EnableGzip {
		var bb bytes.Buffer
		gz := gzip.NewWriter(&bb)
		if _, err := gz.Write(buf); err != nil {
			return err
		}
		if err := gz.Close(); err != nil {
			return err
		}
		buf = bb.Bytes()
	}

	ctx, cancel := context.WithTimeout(context.Background(), h.config.Timeout)
	defer cancel()
	req, err := http.NewRequestWithContext(ctx, h.config.Method, h.url, bytes.NewBuffer(buf))
	if err != nil {
		return err
	}

	h.setHeaders(req)
	h.setBasicAuth(req)

	resp, err := h.client.Do(req)
	if err != nil {
		return err
	}
	defer resp.Body.Close()

	if resp.StatusCode < 200 || resp.StatusCode >= 300 {
		body, err := io.ReadAll(resp.Body)
		if err != nil {
			return err
		}
		return fmt.Errorf("http request failed with %d status code: %v", resp.StatusCode, string(body))
	}

	return nil
}

// setBasicAuth sets the request's Authorization header to use HTTP
// Basic Authentication with the provided username and password.
func (h *_http) setBasicAuth(req *http.Request) {
	if h.config.Username != "" && h.config.Password != "" {
		req.SetBasicAuth(h.config.Username, h.config.Password)
	}
}

// setHeaders populates required and optional request headers.
func (h *_http) setHeaders(req *http.Request) {
	req.Header.Set("User-Agent", userAgentHeader)
	req.Header.Set("Content-Type", defaultContentType)
	if h.config.EnableGzip {
		req.Header.Set("Content-Encoding", "gzip")
	}
	for k, v := range h.config.Headers {
		req.Header.Set(k, v)
	}
}

```

`pkg/outputs/http/http_test.go`:

```go
/*
 * Copyright 2021-2022 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package http

import (
	"compress/gzip"
	"encoding/json"
	"github.com/rabbitstack/fibratus/pkg/outputs"
	"github.com/rabbitstack/fibratus/pkg/util/va"
	"golang.org/x/sys/windows"
	"io"
	"log"
	"net"
	"net/http"
	"net/http/httptest"
	"testing"
	"time"

	"github.com/stretchr/testify/assert"

	"github.com/rabbitstack/fibratus/pkg/event"
	"github.com/rabbitstack/fibratus/pkg/event/params"
	htypes "github.com/rabbitstack/fibratus/pkg/handle/types"
	pstypes "github.com/rabbitstack/fibratus/pkg/ps/types"
	"github.com/stretchr/testify/require"
)

func TestHttpPublish(t *testing.T) {
	l, err := net.Listen("tcp", "127.0.0.1:8081")
	if err != nil {
		log.Fatal(err)
	}

	mux := http.NewServeMux()
	mux.HandleFunc("/intake", func(w http.ResponseWriter, r *http.Request) {
		body, err := io.ReadAll(r.Body)
		if err != nil {
			http.Error(w, err.Error(), http.StatusInternalServerError)
			return
		}
		var events []*event.Event
		if err := json.Unmarshal(body, &events); err != nil {
			http.Error(w, err.Error(), http.StatusInternalServerError)
			return
		}
		assert.Equal(t, 3, len(events))
		assert.Equal(t, "aaabbbaaa", r.Header.Get("API-Key"))
		assert.Equal(t, "fibratus/", r.Header.Get("User-Agent"))
		assert.Equal(t, "1.1", r.Header.Get("Version"))
		assert.Equal(t, "Basic dXNlcjpwYXNz", r.Header.Get("Authorization"))
		w.WriteHeader(http.StatusOK)
	})

	srv := httptest.NewUnstartedServer(mux)

	srv.Listener.Close()
	srv.Listener = l

	srv.Start()
	defer srv.Close()

	c := Config{
		Timeout: time.Second * 3,
		Headers: map[string]string{
			"API-Key": "aaabbbaaa",
			"Version": "1.1",
		},
		Username:   "user",
		Password:   "pass",
		Serializer: outputs.JSON,
	}

	httpClient, err := newHTTPClient(c)
	require.NoError(t, err)

	h := _http{config: c, client: httpClient, url: "http://127.0.0.1:8081/intake"}

	err = h.Publish(getBatch())
	require.NoError(t, err)
}

func TestHttpGzipPublish(t *testing.T) {
	l, err := net.Listen("tcp", "127.0.0.1:8081")
	if err != nil {
		log.Fatal(err)
	}

	mux := http.NewServeMux()
	mux.HandleFunc("/intake", func(w http.ResponseWriter, r *http.Request) {
		assert.Equal(t, "gzip", r.Header.Get("Content-Encoding"))
		gr, err := gzip.NewReader(r.Body)
		if err != nil {
			http.Error(w, err.Error(), http.StatusInternalServerError)
			return
		}
		body, err := io.ReadAll(gr)
		if err != nil {
			http.Error(w, err.Error(), http.StatusInternalServerError)
			return
		}
		var events []*event.Event
		if err := json.Unmarshal(body, &events); err != nil {
			http.Error(w, err.Error(), http.StatusInternalServerError)
			return
		}
		assert.Equal(t, 3, len(events))
		w.WriteHeader(http.StatusOK)
	})

	srv := httptest.NewUnstartedServer(mux)

	srv.Listener.Close()
	srv.Listener = l

	srv.Start()
	defer srv.Close()

	c := Config{
		Timeout:    time.Second * 3,
		EnableGzip: true,
		Serializer: outputs.JSON,
	}

	httpClient, err := newHTTPClient(c)
	require.NoError(t, err)

	h := _http{config: c, client: httpClient, url: "http://127.0.0.1:8081/intake"}

	err = h.Publish(getBatch())
	require.NoError(t, err)
}

func getBatch() *event.Batch {
	evt := &event.Event{
		Type:        event.CreateFile,
		Tid:         2484,
		PID:         859,
		CPU:         1,
		Seq:         2,
		Name:        "CreateFile",
		Timestamp:   time.Now(),
		Category:    event.File,
		Host:        "archrabbit",
		Description: "Creates or opens a new file, directory, I/O device, pipe, console",
		Params: event.Params{
			params.FileObject:    {Name: params.FileObject, Type: params.Uint64, Value: uint64(12456738026482168384)},
			params.FilePath:      {Name: params.FilePath, Type: params.UnicodeString, Value: "\\Device\\HarddiskVolume2\\Windows\\system32\\user32.dll"},
			params.FileType:      {Name: params.FileType, Type: params.AnsiString, Value: "file"},
			params.FileOperation: {Name: params.FileOperation, Type: params.AnsiString, Value: "open"},
			params.BasePrio:      {Name: params.BasePrio, Type: params.Int8, Value: int8(2)},
			params.PagePrio:      {Name: params.PagePrio, Type: params.Uint8, Value: uint8(2)},
		},
		Metadata: map[event.MetadataKey]any{"foo": "bar", "fooz": "baarz"},
		PS: &pstypes.PS{
			PID:       2436,
			Ppid:      6304,
			Name:      "firefox.exe",
			Exe:       `C:\Program Files\Mozilla Firefox\firefox.exe`,
			Cmdline:   `C:\Program Files\Mozilla Firefox\firefox.exe -contentproc --channel="6304.3.1055809391\1014207667" -childID 1 -isForBrowser -prefsHandle 2584 -prefMapHandle 2580 -prefsLen 70 -prefMapSize 216993 -parentBuildID 20200107212822 -greomni "C:\Program Files\Mozilla Firefox\omni.ja" -appomni "C:\Program Files\Mozilla Firefox\browser\omni.ja" -appdir "C:\Program Files\Mozilla Firefox\browser" - 6304 "\\.\pipe\gecko-crash-server-pipe.6304" 2596 tab`,
			Cwd:       `C:\Program Files\Mozilla Firefox\`,
			SID:       "S-1-1-18",
			Args:      []string{"-contentproc", `--channel=6304.3.1055809391\1014207667`, "-childID", "1", "-isForBrowser", "-prefsHandle", "2584", "-prefMapHandle", "2580", "-prefsLen", "70", "-prefMapSize", "216993", "-parentBuildID"},
			SessionID: 4,
			Envs:      map[string]string{"ProgramData": "C:\\ProgramData", "COMPUTRENAME": "archrabbit"},
			Threads: map[uint32]pstypes.Thread{
				3453: {Tid: 3453, StartAddress: va.Address(140729524944768), IOPrio: 2, PagePrio: 5, KstackBase: va.Address(18446677035730165760), KstackLimit: va.Address(18446677035730137088), UstackLimit: va.Address(86376448), UstackBase: va.Address(86372352)},
				3455: {Tid: 3455, StartAddress: va.Address(140729524944768), IOPrio: 3, PagePrio: 5, KstackBase: va.Address(18446677035730165760), KstackLimit: va.Address(18446677035730137088), UstackLimit: va.Address(86376448), UstackBase: va.Address(86372352)},
			},
			Handles: []htypes.Handle{
				{Num: windows.Handle(0xffffd105e9baaf70),
					Name:   `\REGISTRY\MACHINE\SYSTEM\ControlSet001\Services\Tcpip\Parameters\Interfaces\{b677c565-6ca5-45d3-b618-736b4e09b036}`,
					Type:   "Key",
					Object: 777488883434455544,
					Pid:    uint32(1023),
				},
				{
					Num:  windows.Handle(0xffffd105e9adaf70),
					Name: `\RPC Control\OLEA61B27E13E028C4EA6C286932E80`,
					Type: "ALPC Port",
					Pid:  uint32(1023),
					MD: &htypes.AlpcPortInfo{
						Seqno:   1,
						Context: 0x0,
						Flags:   0x0,
					},
					Object: 457488883434455544,
				},
				{
					Num:  windows.Handle(0xeaffd105e9adaf30),
					Name: `C:\Users\bunny`,
					Type: "File",
					Pid:  uint32(1023),
					MD: &htypes.FileInfo{
						IsDirectory: true,
					},
					Object: 357488883434455544,
				},
			},
		},
	}

	evt1 := &event.Event{
		Type:        event.CreateFile,
		Tid:         2484,
		PID:         459,
		CPU:         1,
		Seq:         2,
		Name:        "CreateFile",
		Timestamp:   time.Now(),
		Category:    event.File,
		Host:        "archrabbit",
		Description: "Creates or opens a new file, directory, I/O device, pipe, console",
		Params: event.Params{
			params.FileObject:    {Name: params.FileObject, Type: params.Uint64, Value: uint64(12456738026482168384)},
			params.FilePath:      {Name: params.FilePath, Type: params.UnicodeString, Value: "\\Device\\HarddiskVolume2\\Windows\\system32\\user32.dll"},
			params.FileType:      {Name: params.FileType, Type: params.AnsiString, Value: "file"},
			params.FileOperation: {Name: params.FileOperation, Type: params.AnsiString, Value: "open"},
			params.BasePrio:      {Name: params.BasePrio, Type: params.Int8, Value: int8(2)},
			params.PagePrio:      {Name: params.PagePrio, Type: params.Uint8, Value: uint8(2)},
		},
		Metadata: map[event.MetadataKey]any{"foo": "bar", "fooz": "baarz"},
		PS: &pstypes.PS{
			PID:       2436,
			Ppid:      6304,
			Name:      "firefox.exe",
			Exe:       `C:\Program Files\Mozilla Firefox\firefox.exe`,
			Cmdline:   `C:\Program Files\Mozilla Firefox\firefox.exe -contentproc --channel="6304.3.1055809391\1014207667" -childID 1 -isForBrowser -prefsHandle 2584 -prefMapHandle 2580 -prefsLen 70 -prefMapSize 216993 -parentBuildID 20200107212822 -greomni "C:\Program Files\Mozilla Firefox\omni.ja" -appomni "C:\Program Files\Mozilla Firefox\browser\omni.ja" -appdir "C:\Program Files\Mozilla Firefox\browser" - 6304 "\\.\pipe\gecko-crash-server-pipe.6304" 2596 tab`,
			Cwd:       `C:\Program Files\Mozilla Firefox\`,
			SID:       "S-1-1-18",
			Args:      []string{"-contentproc", `--channel=6304.3.1055809391\1014207667`, "-childID", "1", "-isForBrowser", "-prefsHandle", "2584", "-prefMapHandle", "2580", "-prefsLen", "70", "-prefMapSize", "216993", "-parentBuildID"},
			SessionID: 4,
			Envs:      map[string]string{"ProgramData": "C:\\ProgramData", "COMPUTRENAME": "archrabbit"},
			Threads: map[uint32]pstypes.Thread{
				3453: {Tid: 3453, StartAddress: va.Address(140729524944768), IOPrio: 2, PagePrio: 5, KstackBase: va.Address(18446677035730165760), KstackLimit: va.Address(18446677035730137088), UstackLimit: va.Address(86376448), UstackBase: va.Address(86372352)},
				3455: {Tid: 3455, StartAddress: va.Address(140729524944768), IOPrio: 3, PagePrio: 5, KstackBase: va.Address(18446677035730165760), KstackLimit: va.Address(18446677035730137088), UstackLimit: va.Address(86376448), UstackBase: va.Address(86372352)},
			},
			Handles: []htypes.Handle{
				{Num: windows.Handle(0xffffd105e9baaf70),
					Name:   `\REGISTRY\MACHINE\SYSTEM\ControlSet001\Services\Tcpip\Parameters\Interfaces\{b677c565-6ca5-45d3-b618-736b4e09b036}`,
					Type:   "Key",
					Object: 777488883434455544,
					Pid:    uint32(1023),
				},
				{
					Num:  windows.Handle(0xffffd105e9adaf70),
					Name: `\RPC Control\OLEA61B27E13E028C4EA6C286932E80`,
					Type: "ALPC Port",
					Pid:  uint32(1023),
					MD: &htypes.AlpcPortInfo{
						Seqno:   1,
						Context: 0x0,
						Flags:   0x0,
					},
					Object: 457488883434455544,
				},
				{
					Num:  windows.Handle(0xeaffd105e9adaf30),
					Name: `C:\Users\bunny`,
					Type: "File",
					Pid:  uint32(1023),
					MD: &htypes.FileInfo{
						IsDirectory: true,
					},
					Object: 357488883434455544,
				},
			},
		},
	}

	evt2 := &event.Event{
		Type:        event.CreateFile,
		Tid:         2484,
		PID:         829,
		CPU:         1,
		Seq:         2,
		Name:        "CreateFile",
		Timestamp:   time.Now(),
		Category:    event.File,
		Host:        "archrabbit",
		Description: "Creates or opens a new file, directory, I/O device, pipe, console",
		Params: event.Params{
			params.FileObject:    {Name: params.FileObject, Type: params.Uint64, Value: uint64(12456738026482168384)},
			params.FilePath:      {Name: params.FilePath, Type: params.UnicodeString, Value: "\\Device\\HarddiskVolume2\\Windows\\system32\\user32.dll"},
			params.FileType:      {Name: params.FileType, Type: params.AnsiString, Value: "file"},
			params.FileOperation: {Name: params.FileOperation, Type: params.AnsiString, Value: "open"},
			params.BasePrio:      {Name: params.BasePrio, Type: params.Int8, Value: int8(2)},
			params.PagePrio:      {Name: params.PagePrio, Type: params.Uint8, Value: uint8(2)},
		},
		Metadata: map[event.MetadataKey]any{"foo": "bar", "fooz": "baarz"},
		PS: &pstypes.PS{
			PID:       829,
			Ppid:      6304,
			Name:      "firefox.exe",
			Exe:       `C:\Program Files\Mozilla Firefox\firefox.exe`,
			Cmdline:   `C:\Program Files\Mozilla Firefox\firefox.exe -contentproc --channel="6304.3.1055809391\1014207667" -childID 1 -isForBrowser -prefsHandle 2584 -prefMapHandle 2580 -prefsLen 70 -prefMapSize 216993 -parentBuildID 20200107212822 -greomni "C:\Program Files\Mozilla Firefox\omni.ja" -appomni "C:\Program Files\Mozilla Firefox\browser\omni.ja" -appdir "C:\Program Files\Mozilla Firefox\browser" - 6304 "\\.\pipe\gecko-crash-server-pipe.6304" 2596 tab`,
			Cwd:       `C:\Program Files\Mozilla Firefox\`,
			SID:       "S-1-1-18",
			Args:      []string{"-contentproc", `--channel=6304.3.1055809391\1014207667`, "-childID", "1", "-isForBrowser", "-prefsHandle", "2584", "-prefMapHandle", "2580", "-prefsLen", "70", "-prefMapSize", "216993", "-parentBuildID"},
			SessionID: 4,
			Envs:      map[string]string{"ProgramData": "C:\\ProgramData", "COMPUTRENAME": "archrabbit"},
			Threads: map[uint32]pstypes.Thread{
				3453: {Tid: 3453, StartAddress: va.Address(140729524944768), IOPrio: 2, PagePrio: 5, KstackBase: va.Address(18446677035730165760), KstackLimit: va.Address(18446677035730137088), UstackLimit: va.Address(86376448), UstackBase: va.Address(86372352)},
				3455: {Tid: 3455, StartAddress: va.Address(140729524944768), IOPrio: 3, PagePrio: 5, KstackBase: va.Address(18446677035730165760), KstackLimit: va.Address(18446677035730137088), UstackLimit: va.Address(86376448), UstackBase: va.Address(86372352)},
			},
			Handles: []htypes.Handle{
				{Num: windows.Handle(0xffffd105e9baaf70),
					Name:   `\REGISTRY\MACHINE\SYSTEM\ControlSet001\Services\Tcpip\Parameters\Interfaces\{b677c565-6ca5-45d3-b618-736b4e09b036}`,
					Type:   "Key",
					Object: 777488883434455544,
					Pid:    uint32(1023),
				},
				{
					Num:  windows.Handle(0xffffd105e9adaf70),
					Name: `\RPC Control\OLEA61B27E13E028C4EA6C286932E80`,
					Type: "ALPC Port",
					Pid:  uint32(1023),
					MD: &htypes.AlpcPortInfo{
						Seqno:   1,
						Context: 0x0,
						Flags:   0x0,
					},
					Object: 457488883434455544,
				},
				{
					Num:  windows.Handle(0xeaffd105e9adaf30),
					Name: `C:\Users\bunny`,
					Type: "File",
					Pid:  uint32(1023),
					MD: &htypes.FileInfo{
						IsDirectory: true,
					},
					Object: 357488883434455544,
				},
			},
		},
	}

	return event.NewBatch(evt, evt1, evt2)
}

```

`pkg/outputs/null/config.go`:

```go
/*
 * Copyright 2019-2020 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package null

// Config contains preferences for the null output.
type Config struct{}

```

`pkg/outputs/null/null.go`:

```go
/*
 * Copyright 2019-2020 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package null

import (
	"expvar"
	"github.com/rabbitstack/fibratus/pkg/event"
	"github.com/rabbitstack/fibratus/pkg/outputs"
)

var blackholeEventsCount = expvar.NewInt("output.null.blackhole.events")

// null output devours kernel events the same way a black hole swallows the light
type null struct{}

func init() {
	outputs.Register(outputs.Null, initNull)
}

func initNull(config outputs.Config) (outputs.OutputGroup, error) {
	return outputs.Success(&null{}), nil
}

func (null) Close() error   { return nil }
func (null) Connect() error { return nil }
func (null) Publish(batch *event.Batch) error {
	blackholeEventsCount.Add(batch.Len())
	return nil
}

```

`pkg/outputs/outputs.go`:

```go
/*
 * Copyright 2019-2020 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package outputs

import (
	"fmt"
	"reflect"
	"strings"
)

var (
	outputs = map[Type]Factory{}
	// ErrInvalidConfig signals an invalid configuration input
	ErrInvalidConfig = func(name Type, c interface{}) error {
		return fmt.Errorf("invalid config for %q output. Got type %v instead of %s.Config", name, reflect.TypeOf(c), strings.ToLower(name.String()))
	}
)

// Factory serves for constructing different output implementations from configuration.
type Factory func(config Config) (OutputGroup, error)

// Type is the alias for the output type.
type Type uint8

const (
	// Console represents the default terminal output.
	Console Type = iota
	// AMQP denotes the AMQP output.
	AMQP
	// Elasticsearch denotes the Elasticsearch output.
	Elasticsearch
	// HTTP denotes the HTTP output.
	HTTP
	// Eventlog denotes the eventlog output.
	Eventlog
	// Null is the null output.
	Null
	// Unknown is an undefined output type.
	Unknown
)

// String returns the string representation of the output type.
func (t Type) String() string {
	switch t {
	case Console:
		return "console"
	case AMQP:
		return "amqp"
	case Elasticsearch:
		return "elasticsearch"
	case HTTP:
		return "http"
	case Eventlog:
		return "eventlog"
	case Null:
		return "null"
	default:
		return "unknown"
	}
}

// TypeFromString parses output type from input string.
func TypeFromString(s string) Type {
	switch s {
	case "console":
		return Console
	case "amqp":
		return AMQP
	case "elasticsearch":
		return Elasticsearch
	case "http":
		return HTTP
	case "eventlog":
		return Eventlog
	case "null":
		return Null
	default:
		return Unknown
	}
}

// OutputGroup is a collection of outputs that can be configured in a load-balanced fashion.
type OutputGroup struct {
	// Clients is the list of clients to which events are forwarded.
	Clients []Client
}

// Success builds the output group from the provided clients.
func Success(clients ...Client) OutputGroup {
	return OutputGroup{Clients: clients}
}

// Fail returns an empty output group and an error signaling the failure that caused the output group initialization.
func Fail(err error) (OutputGroup, error) {
	return OutputGroup{}, err
}

// Register registers a new output implementation. Note this function should be only called once per output.
func Register(typ Type, factory Factory) {
	if _, ok := outputs[typ]; ok {
		panic(fmt.Sprintf("output %q is already registered", typ))
	}
	outputs[typ] = factory
}

// FindFactory locates the output factory.
func FindFactory(typ Type) Factory {
	return outputs[typ]
}

// Load loads the specified output from configuration. The output must have been registered previously.
func Load(typ Type, config Config) (OutputGroup, error) {
	factory := FindFactory(typ)
	if factory == nil {
		return OutputGroup{}, fmt.Errorf("output %q not available in the factory", typ)
	}
	return factory(config)
}

```

`pkg/outputs/serializer.go`:

```go
/*
 * Copyright 2021-2022 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package outputs

// Serializer is the type definition for the output serializers.
type Serializer string

const (
	// JSON represents the JSON serializer type.
	JSON Serializer = "json"
)

```

`pkg/pe/config.go`:

```go
//go:build windows
// +build windows

/*
 * Copyright 2019-2020 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package pe

import (
	"github.com/spf13/pflag"
	"github.com/spf13/viper"
)

const (
	enabled        = "pe.enabled"
	readResources  = "pe.read-resources"
	readSymbols    = "pe.read-symbols"
	readSections   = "pe.read-sections"
	excludedImages = "pe.excluded-images"
)

// Config stores the preferences that dictate the behaviour of the PE reader.
type Config struct {
	Enabled        bool     `json:"pe.enabled" yaml:"pe.enabled"`
	ReadResources  bool     `json:"pe.read-resources" yaml:"pe.read-resources"`
	ReadSymbols    bool     `json:"pe.read-symbols" yaml:"pe.read-symbols"`
	ReadSections   bool     `json:"pe.read-sections" yaml:"pe.read-sections"`
	ExcludedImages []string `json:"pe.excluded-images" yaml:"pe.excluded-images"`
}

// InitFromViper initializes PE config from Viper.
func (c *Config) InitFromViper(v *viper.Viper) {
	c.Enabled = v.GetBool(enabled)
	c.ReadResources = v.GetBool(readResources)
	c.ReadSymbols = v.GetBool(readSymbols)
	c.ReadSections = v.GetBool(readSections)
	c.ExcludedImages = v.GetStringSlice(excludedImages)
}

// AddFlags registers persistent flags.
func AddFlags(flags *pflag.FlagSet) {
	flags.Bool(enabled, false, "Specifies if PE metadata is fetched from the process' image file")
	flags.Bool(readResources, false, "Determines if resources are read from the PE resource directory")
	flags.Bool(readSymbols, false, "Indicates if symbols are read from the PE")
	flags.Bool(readSections, false, "Indicates if full section inspection is allowed")
	flags.StringSlice(excludedImages, []string{}, "Contains a list of comma-separated images names that are excluded from PE parsing")
}

```

`pkg/pe/doc.go`:

```go
/*
 * Copyright 2019-2020 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

// Package pe contains different facilities for dealing with Portable Executable specifics and digging out valuable insights
// from PE.
package pe

```

`pkg/pe/header.go`:

```go
/*
 * Copyright 2021-2022 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package pe

import (
	peparser "github.com/saferwall/pe"
	"reflect"
)

// IsHeaderModified returns true if any of the DOS, NT, or
// section headers located in on-disk PE structure differ
// from their respective in-memory representations.
func (pe *PE) IsHeaderModified(mem *PE) bool {
	var (
		epModified      bool
		archMismatch    bool
		dosHdrModified  bool
		ntHdrModified   bool
		fileHdrModified bool
		secHdrModified  bool
	)

	epModified = pe.EntryPoint != mem.EntryPoint
	archMismatch = pe.ntHeader.FileHeader.Machine != mem.ntHeader.FileHeader.Machine

	dosHdrModified = pe.isDOSHdrModified(mem)
	ntHdrModified = pe.isNTHdrModified(mem)
	fileHdrModified = pe.isFileHdrModified(mem, false)
	secHdrModified = pe.isSectionHdrModified(mem)

	if pe.IsDotnet {
		// some .NET modules overwrite their own headers. Discard them to avoid false positives
		if !secHdrModified && !dosHdrModified && !pe.isFileHdrModified(mem, archMismatch) &&
			(epModified || (archMismatch && ntHdrModified)) {
			return false
		}
	}

	return dosHdrModified || ntHdrModified || fileHdrModified || secHdrModified
}

func (pe *PE) isDOSHdrModified(mem *PE) bool {
	return !reflect.DeepEqual(pe.dosHeader, mem.dosHeader)
}

func (pe *PE) isNTHdrModified(mem *PE) bool {
	if pe.Is64 != mem.Is64 {
		return true
	}
	if pe.ntHeader == (peparser.ImageNtHeader{}) && mem.ntHeader == (peparser.ImageNtHeader{}) {
		return false
	}
	if pe.ntHeader == (peparser.ImageNtHeader{}) || mem.ntHeader == (peparser.ImageNtHeader{}) {
		return true
	}

	// reset image base before comparing
	switch pe.Is64 {
	case true:
		fileOH64 := pe.ntHeader.OptionalHeader.(peparser.ImageOptionalHeader64)
		memOH64 := mem.ntHeader.OptionalHeader.(peparser.ImageOptionalHeader64)
		fileOH64.ImageBase = 0
		memOH64.ImageBase = 0
		pe.ntHeader.OptionalHeader = fileOH64
		mem.ntHeader.OptionalHeader = memOH64
	case false:
		fileOH32 := pe.ntHeader.OptionalHeader.(peparser.ImageOptionalHeader32)
		memOH32 := mem.ntHeader.OptionalHeader.(peparser.ImageOptionalHeader32)
		fileOH32.ImageBase = 0
		memOH32.ImageBase = 0
		pe.ntHeader.OptionalHeader = fileOH32
		mem.ntHeader.OptionalHeader = memOH32
	}
	return !reflect.DeepEqual(pe.ntHeader, mem.ntHeader)
}

func (pe *PE) isFileHdrModified(mem *PE, archMismatch bool) bool {
	fileHeader, memHeader := pe.ntHeader.FileHeader, mem.ntHeader.FileHeader
	if fileHeader == (peparser.ImageFileHeader{}) && memHeader == (peparser.ImageFileHeader{}) {
		return false
	}
	if fileHeader == (peparser.ImageFileHeader{}) || memHeader == (peparser.ImageFileHeader{}) {
		return true
	}
	if !archMismatch {
		return false
	}
	if fileHeader.Machine == memHeader.Machine &&
		fileHeader.Characteristics == memHeader.Characteristics &&
		fileHeader.NumberOfSections == memHeader.NumberOfSections &&
		fileHeader.TimeDateStamp == memHeader.TimeDateStamp &&
		fileHeader.SizeOfOptionalHeader != memHeader.SizeOfOptionalHeader { // SizeOfOptionalHeader differs
		return true
	}
	return false
}

func (pe *PE) isSectionHdrModified(mem *PE) bool {
	if pe.NumberOfSections != mem.NumberOfSections {
		return true
	}
	if len(pe.sectionHeaders) == 0 && len(mem.sectionHeaders) == 0 {
		return false
	}
	if len(pe.sectionHeaders) != len(mem.sectionHeaders) {
		return true
	}

	for n := uint16(0); n < pe.NumberOfSections; n++ {
		fileSecHeader := pe.sectionHeaders[n]
		memSecHeader := mem.sectionHeaders[n]
		if fileSecHeader == (peparser.ImageSectionHeader{}) && memSecHeader == (peparser.ImageSectionHeader{}) {
			continue
		}
		if fileSecHeader == (peparser.ImageSectionHeader{}) || memSecHeader == (peparser.ImageSectionHeader{}) {
			return true
		}
		// normalize unused sections before comparing
		if fileSecHeader.SizeOfRawData == 0 {
			fileSecHeader.PointerToRawData = 0
		}
		if memSecHeader.SizeOfRawData == 0 {
			memSecHeader.PointerToRawData = 0
		}
		if fileSecHeader.VirtualAddress != memSecHeader.VirtualAddress {
			return true
		}
		if fileSecHeader.VirtualSize != memSecHeader.VirtualSize {
			return true
		}
		if fileSecHeader.PointerToRawData != memSecHeader.PointerToRawData {
			return true
		}
	}
	return false
}

```

`pkg/pe/header_test.go`:

```go
/*
 * Copyright 2021-2022 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package pe

import (
	"fmt"
	"github.com/stretchr/testify/require"
	"golang.org/x/sys/windows"
	"os"
	"os/exec"
	"path/filepath"
	"strings"
	"testing"
)

func TestIsHeaderModified(t *testing.T) {
	var tests = []struct {
		executable string
		modified   bool
	}{
		{filepath.Join(os.Getenv("windir"), "explorer.exe"), false},
		{filepath.Join(os.Getenv("windir"), "system32", "calc.exe"), true},
	}

	// perform PE injection on the calc.exe executable with
	// process overwriting technique as explained in the repo
	// https://github.com/hasherezade/process_overwriting
	cmd := exec.Command("_fixtures/process_overwriting.exe", "_fixtures/shellcode.bin")
	require.NoError(t, cmd.Run())

	for _, tt := range tests {
		pid, err := findProcessID(tt.executable)
		require.NoError(t, err)
		addr, err := getModuleBaseAddress(pid)
		if err != nil {
			t.Fatalf("%s: unable to get the base address: %v", tt.executable, err)
		}
		file, err := ParseFile(tt.executable, WithSections())
		if err != nil {
			t.Fatalf("%s: %v", tt.executable, err)
		}
		mem, err := ParseMem(pid, addr, false, WithSections())
		if err != nil {
			t.Fatalf("%s: %v", tt.executable, err)
		}
		if mem == nil {
			t.Fatalf("%s: PE mem data is nil", tt.executable)
		}
		isHdrModified := file.IsHeaderModified(mem)
		if isHdrModified != tt.modified {
			t.Errorf("%s: expected %t, but got: %t", tt.executable, tt.modified, isHdrModified)
		}
		// terminate injected process
		if filepath.Base(tt.executable) == "calc.exe" {
			proc, err := windows.OpenProcess(windows.PROCESS_TERMINATE, false, pid)
			if err != nil {
				continue
			}
			windows.TerminateProcess(proc, 1)
		}
	}
}

func findProcessID(image string) (uint32, error) {
	const processEntrySize = 568
	snap, err := windows.CreateToolhelp32Snapshot(windows.TH32CS_SNAPPROCESS, 0)
	if err != nil {
		return 0, err
	}
	defer windows.Close(snap)
	p := windows.ProcessEntry32{Size: processEntrySize}
	for {
		err := windows.Process32Next(snap, &p)
		if err != nil {
			break
		}
		s := windows.UTF16ToString(p.ExeFile[:])
		if strings.EqualFold(s, filepath.Base(image)) {
			return p.ProcessID, nil
		}
	}
	return 0, fmt.Errorf("no process for %s image", image)
}

```

`pkg/pe/marshaller.go`:

```go
//go:build windows
// +build windows

/*
 * Copyright 2019-2020 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package pe

import (
	"fmt"
	capver "github.com/rabbitstack/fibratus/pkg/cap/version"
	"github.com/rabbitstack/fibratus/pkg/sys"
	"github.com/rabbitstack/fibratus/pkg/util/bytes"
	"github.com/rabbitstack/fibratus/pkg/util/convert"
	"math"
	"time"
	"unsafe"
)

// Marshal dumps the PE metadata to binary stream.
func (pe *PE) Marshal() []byte {
	b := make([]byte, 0)

	// number of sections/symbols
	b = append(b, bytes.WriteUint16(pe.NumberOfSections)...)
	b = append(b, bytes.WriteUint32(pe.NumberOfSymbols)...)

	// image base
	b = append(b, bytes.WriteUint16(uint16(len(pe.ImageBase)))...)
	b = append(b, pe.ImageBase...)

	// entry point
	b = append(b, bytes.WriteUint16(uint16(len(pe.EntryPoint)))...)
	b = append(b, pe.EntryPoint...)

	// link time
	linkTime := make([]byte, 0)
	linkTime = pe.LinkTime.AppendFormat(linkTime, time.RFC3339Nano)
	b = append(b, bytes.WriteUint16(uint16(len(linkTime)))...)
	b = append(b, linkTime...)

	// sections
	b = append(b, bytes.WriteUint16(uint16(len(pe.Sections)))...)
	for _, sec := range pe.Sections {
		// size
		b = append(b, bytes.WriteUint32(sec.Size)...)
		// entropy
		b = append(b, bytes.WriteUint64(math.Float64bits(sec.Entropy))...)
		// name
		b = append(b, bytes.WriteUint16(uint16(len(sec.Name)))...)
		b = append(b, sec.Name...)
		// md5
		b = append(b, bytes.WriteUint16(uint16(len(sec.Md5)))...)
		b = append(b, sec.Md5...)
	}

	// symbols
	b = append(b, bytes.WriteUint16(uint16(len(pe.Symbols)))...)
	for _, sym := range pe.Symbols {
		b = append(b, bytes.WriteUint16(uint16(len(sym)))...)
		b = append(b, sym...)
	}

	// imports
	b = append(b, bytes.WriteUint16(uint16(len(pe.Imports)))...)
	for _, imp := range pe.Imports {
		b = append(b, bytes.WriteUint16(uint16(len(imp)))...)
		b = append(b, imp...)
	}

	// version resources
	b = append(b, bytes.WriteUint16(uint16(len(pe.VersionResources)))...)
	for k, v := range pe.VersionResources {
		b = append(b, bytes.WriteUint16(uint16(len(k)))...)
		b = append(b, k...)
		b = append(b, bytes.WriteUint16(uint16(len(v)))...)
		b = append(b, v...)
	}

	// signature and cert data
	b = append(b, convert.Btoi(pe.IsSigned))
	b = append(b, convert.Btoi(pe.IsTrusted))
	if pe.Cert != nil {
		crt := pe.Cert.Marshal()
		b = append(b, bytes.WriteUint32(uint32(len(crt)))...)
		b = append(b, crt...)
	} else {
		b = append(b, bytes.WriteUint32(0)...)
	}

	// PE binary format
	b = append(b, convert.Btoi(pe.IsDriver))
	b = append(b, convert.Btoi(pe.IsDLL))
	b = append(b, convert.Btoi(pe.IsExecutable))
	b = append(b, convert.Btoi(pe.IsDotnet))

	// imphash
	b = append(b, bytes.WriteUint16(uint16(len(pe.Imphash)))...)
	b = append(b, pe.Imphash...)

	// anomalies
	b = append(b, bytes.WriteUint16(uint16(len(pe.Anomalies)))...)
	for _, s := range pe.Anomalies {
		b = append(b, bytes.WriteUint16(uint16(len(s)))...)
		b = append(b, s...)
	}

	return b
}

// Unmarshal recovers the PE metadata from the byte stream.
func (pe *PE) Unmarshal(b []byte, ver capver.Version) error {
	if len(b) < 6 {
		return fmt.Errorf("expected at least 6 bytes but got %d bytes", len(b))
	}

	pe.NumberOfSections = bytes.ReadUint16(b[0:])
	pe.NumberOfSymbols = bytes.ReadUint32(b[2:])

	// image base
	l := bytes.ReadUint16(b[6:])
	buf := b[8:]
	offset := uint32(l)
	pe.ImageBase = string((*[1<<30 - 1]byte)(unsafe.Pointer(&buf[0]))[:l:l])

	// entry point
	l = bytes.ReadUint16(b[8+offset:])
	buf = b[10+offset:]
	offset += uint32(l)
	pe.EntryPoint = string((*[1<<30 - 1]byte)(unsafe.Pointer(&buf[0]))[:l:l])

	// link time
	l = bytes.ReadUint16(b[10+offset:])
	buf = b[12+offset:]
	offset += uint32(l)
	if len(buf) > 0 {
		pe.LinkTime, _ = time.Parse(time.RFC3339Nano, string((*[1<<30 - 1]byte)(unsafe.Pointer(&buf[0]))[:l:l]))
	}

	// read sections
	nsections := bytes.ReadUint16(b[12+offset:])
	var soffset uint32

	for nsec := 0; nsec < int(nsections); nsec++ {
		// section size
		size := bytes.ReadUint32(b[14+offset+soffset:])
		// entropy
		entropy := bytes.ReadUint64(b[18+offset+soffset:])

		// section name
		l := bytes.ReadUint16(b[26+offset+soffset:])
		buf := b[28+offset+soffset:]
		soffset += uint32(l)
		name := string((*[1<<30 - 1]byte)(unsafe.Pointer(&buf[0]))[:l:l])

		// section md5 hash
		l = bytes.ReadUint16(b[28+offset+soffset:])
		buf = b[30+offset+soffset:]
		soffset += uint32(l)
		md5 := string((*[1<<30 - 1]byte)(unsafe.Pointer(&buf[0]))[:l:l])

		pe.Sections = append(pe.Sections,
			Sec{
				Name:    name,
				Size:    size,
				Entropy: math.Float64frombits(entropy),
				Md5:     md5,
			},
		)

		// increment the offset by summing the byte length of the size + entropy, and the section name length + md5 length encoded as uint16 values
		soffset += 4 + 8 + 2 + 2
	}

	offset += soffset

	// read symbols
	nsyms := bytes.ReadUint16(b[14+offset:])
	var syoffset uint32

	for nsym := 0; nsym < int(nsyms); nsym++ {
		l := bytes.ReadUint16(b[16+offset+syoffset:])
		buf := b[18+offset+syoffset:]
		pe.Symbols = append(pe.Symbols, string((*[1<<30 - 1]byte)(unsafe.Pointer(&buf[0]))[:l:l]))
		syoffset += uint32(l + 2)
	}
	offset += syoffset

	// read imports
	nimports := bytes.ReadUint16(b[16+offset:])
	var ioffset uint32

	for nimp := 0; nimp < int(nimports); nimp++ {
		l := bytes.ReadUint16(b[18+offset+ioffset:])
		buf := b[20+offset+ioffset:]
		pe.Imports = append(pe.Imports, string((*[1<<30 - 1]byte)(unsafe.Pointer(&buf[0]))[:l:l]))
		ioffset += uint32(l + 2)
	}

	offset += ioffset

	// read version resources
	nresources := bytes.ReadUint16(b[18+offset:])
	var roffset uint32

	for nres := 0; nres < int(nresources); nres++ {
		// read key
		klen := bytes.ReadUint16(b[20+offset+roffset:])
		buf := b[22+offset+roffset:]
		key := string((*[1<<30 - 1]byte)(unsafe.Pointer(&buf[0]))[:klen:klen])
		// read value
		vlen := bytes.ReadUint16(b[22+offset+uint32(klen)+roffset:])
		buf = b[24+offset+uint32(klen)+roffset:]
		if vlen == 0 {
			roffset += uint32(klen) + 4
			continue
		}
		value := string((*[1<<30 - 1]byte)(unsafe.Pointer(&buf[0]))[:vlen:vlen])
		// increment the offset by the length of the key + length value + size of uint16 * 2
		// that corresponds to byte patterns storing the lengths of the keys/values
		roffset += uint32(klen) + uint32(vlen) + 4
		if key != "" {
			pe.VersionResources[key] = value
		}
	}

	offset += roffset

	if ver >= capver.PESecV2 {
		pe.IsSigned = convert.Itob(b[20+offset])
		pe.IsTrusted = convert.Itob(b[21+offset])

		certSize := bytes.ReadUint32(b[22+offset:])
		if certSize > 0 {
			pe.Cert = &sys.Cert{}
			err := pe.Cert.Unmarshal(b, offset, certSize)
			if err != nil {
				return err
			}
		}

		offset += certSize

		pe.IsDriver = convert.Itob(b[26+offset])
		pe.IsDLL = convert.Itob(b[27+offset])
		pe.IsExecutable = convert.Itob(b[28+offset])
		pe.IsDotnet = convert.Itob(b[29+offset])

		// read impash
		l = bytes.ReadUint16(b[30+offset:])
		buf = b[32+offset:]
		offset += uint32(l)
		pe.Imphash = string((*[1<<30 - 1]byte)(unsafe.Pointer(&buf[0]))[:l:l])

		// read anomalies
		nanomalies := bytes.ReadUint16(b[32+offset:])
		pe.Anomalies = make([]string, nanomalies)
		var off uint32
		for n := uint16(0); n < nanomalies; n++ {
			l := bytes.ReadUint16(b[34+offset+off:])
			buf := b[36+offset+off:]
			pe.Anomalies[n] = string((*[1<<30 - 1]byte)(unsafe.Pointer(&buf[0]))[:l:l])
			off += 2 + uint32(l)
		}
	}

	return nil
}

// NewFromCapture restores the PE metadata from the byte stream.
func NewFromCapture(b []byte, ver capver.Version) (*PE, error) {
	pe := &PE{
		Sections:         make([]Sec, 0),
		Symbols:          make([]string, 0),
		Imports:          make([]string, 0),
		VersionResources: make(map[string]string),
	}
	if err := pe.Unmarshal(b, ver); err != nil {
		return nil, err
	}
	return pe, nil
}

```

`pkg/pe/marshaller_test.go`:

```go
//go:build windows
// +build windows

/*
 * Copyright 2019-2020 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package pe

import (
	capver "github.com/rabbitstack/fibratus/pkg/cap/version"
	"github.com/rabbitstack/fibratus/pkg/sys"
	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/require"
	"testing"
	"time"
)

func TestPEMarshal(t *testing.T) {
	now := time.Now()

	pe := &PE{
		NumberOfSections: 7,
		NumberOfSymbols:  10,
		EntryPoint:       "20110",
		ImageBase:        "140000000",
		LinkTime:         now,
		Sections: []Sec{
			{Name: ".text", Size: 132608, Entropy: 6.368381, Md5: "db23dce3911a42e987041d98abd4f7cd"},
			{Name: ".rdata", Size: 35840, Entropy: 5.996976, Md5: "ffa5c960b421ca9887e54966588e97e8"},
		},
		Symbols:          []string{"SelectObject", "GetTextFaceW", "EnumFontsW", "TextOutW", "GetProcessHeap"},
		Imports:          []string{"GDI32.dll", "USER32.dll", "msvcrt.dll", "api-ms-win-core-libraryloader-l1-2-0.dl"},
		VersionResources: map[string]string{"CompanyName": "Microsoft Corporation", "FileDescription": "Notepad", "FileVersion": "10.0.18362.693"},
		IsSigned:         true,
		IsTrusted:        true,
		Cert: &sys.Cert{
			Issuer:       "Washington, Redmond, Microsoft Corporation",
			Subject:      "Washington, Redmond, Microsoft Corporation",
			SerialNumber: "330000023241fb59996dcc4dff000000000232",
			NotBefore:    time.Now(),
			NotAfter:     time.Now(),
		},
		IsExecutable: true,
		IsDotnet:     true,
		Imphash:      "5d3861c5c547f8a34e471ba273a732b2",
		Anomalies:    []string{"optional header checksum is invalid", "image base is 0"},
	}

	b := pe.Marshal()

	newPE := &PE{VersionResources: make(map[string]string)}
	err := newPE.Unmarshal(b, capver.PESecV2)
	require.NoError(t, err)

	assert.Equal(t, uint16(7), newPE.NumberOfSections)
	assert.Equal(t, uint32(10), newPE.NumberOfSymbols)
	assert.Equal(t, "20110", newPE.EntryPoint)
	assert.Equal(t, "140000000", newPE.ImageBase)

	assert.Equal(t, now.Day(), newPE.LinkTime.Day())
	assert.Equal(t, now.Minute(), newPE.LinkTime.Minute())

	assert.Len(t, newPE.Sections, 2)

	textSection := newPE.Sections[0]
	assert.Equal(t, ".text", textSection.Name)
	assert.Equal(t, uint32(132608), textSection.Size)
	assert.Equal(t, 6.368381, textSection.Entropy)
	assert.Equal(t, "db23dce3911a42e987041d98abd4f7cd", textSection.Md5)

	assert.Len(t, newPE.Symbols, 5)
	assert.Contains(t, newPE.Symbols, "SelectObject")
	assert.Contains(t, newPE.Symbols, "TextOutW")

	assert.Len(t, newPE.Imports, 4)
	assert.Contains(t, newPE.Imports, "GDI32.dll")
	assert.Contains(t, newPE.Imports, "msvcrt.dll")

	assert.Len(t, newPE.VersionResources, 3)
	assert.Contains(t, newPE.VersionResources, "CompanyName")
	assert.Contains(t, newPE.VersionResources, "FileVersion")

	assert.Equal(t, "10.0.18362.693", newPE.VersionResources["FileVersion"])
	assert.Equal(t, "Microsoft Corporation", newPE.VersionResources["CompanyName"])
	assert.Equal(t, "Notepad", newPE.VersionResources["FileDescription"])

	assert.True(t, newPE.IsSigned)
	assert.True(t, newPE.IsTrusted)

	assert.NotNil(t, newPE.Cert)
	assert.False(t, newPE.Cert.NotBefore.IsZero())
	assert.False(t, newPE.Cert.NotAfter.IsZero())

	assert.Equal(t, pe.Cert.SerialNumber, newPE.Cert.SerialNumber)
	assert.Equal(t, pe.Cert.Subject, newPE.Cert.Subject)
	assert.Equal(t, pe.Cert.Issuer, newPE.Cert.Issuer)

	assert.False(t, newPE.IsDriver)
	assert.False(t, newPE.IsDLL)
	assert.True(t, newPE.IsExecutable)
	assert.True(t, newPE.IsDotnet)
	assert.Equal(t, pe.Imphash, newPE.Imphash)
	assert.Equal(t, len(pe.Anomalies), len(newPE.Anomalies))
	assert.Contains(t, newPE.Anomalies, "image base is 0")
}

```

`pkg/pe/parser.go`:

```go
/*
 * Copyright 2021-2022 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package pe

import (
	"crypto/md5"
	"encoding/hex"
	"errors"
	"expvar"
	"fmt"
	"github.com/rabbitstack/fibratus/pkg/sys"
	"github.com/rabbitstack/fibratus/pkg/util/format"
	"github.com/rabbitstack/fibratus/pkg/util/va"
	peparser "github.com/saferwall/pe"
	peparserlog "github.com/saferwall/pe/log"
	log "github.com/sirupsen/logrus"
	"golang.org/x/sys/windows"
	"os"
	"path/filepath"
	"strings"
	"time"
)

var (
	// MaxHeaderSize specifies the maximum size of the PE header
	MaxHeaderSize = uint(os.Getpagesize())
	// MinHeaderSize denotes the minimal valid PE header size
	MinHeaderSize = uint(0x100)
	// ErrEmptyVArea represents the error which is returned if the VA area couldn't be read
	ErrEmptyVArea = errors.New("va memory area is empty")

	skippedImages               = expvar.NewInt("pe.skipped.images")
	directoryParseErrors        = expvar.NewInt("pe.directory.parse.errors")
	versionResourcesParseErrors = expvar.NewInt("pe.version.resources.parse.errors")
	imphashErrors               = expvar.NewInt("pe.imphash.errors")
)

type opts struct {
	parseSymbols   bool
	parseSections  bool
	parseResources bool
	parseSecurity  bool
	parseCLR       bool
	parseExports   bool
	sectionEntropy bool
	sectionMD5     bool
	calcImphash    bool
	excludedImages []string
}

func (o opts) isImageExcluded(path string) bool {
	for _, img := range o.excludedImages {
		if strings.EqualFold(img, filepath.Base(path)) {
			skippedImages.Add(1)
			return true
		}
	}
	return false
}

// Option represents the option type for the PE parser.
type Option func(o *opts)

// WithExcludedImages provides a list of image paths for
// which the parsing is skipped.
func WithExcludedImages(images []string) Option {
	return func(o *opts) {
		o.excludedImages = images
	}
}

// WithSymbols indicates import directory is parsed for imported symbols.
func WithSymbols() Option {
	return func(o *opts) {
		o.parseSymbols = true
	}
}

// WithSections indicates section header is parsed.
func WithSections() Option {
	return func(o *opts) {
		o.parseSections = true
	}
}

// WithExports indicates if the export directory is parsed.
func WithExports() Option {
	return func(o *opts) {
		o.parseExports = true
	}
}

// WithSectionEntropy indicates if entropy is calculated for available sections.
func WithSectionEntropy() Option {
	return func(o *opts) {
		o.sectionEntropy = true
	}
}

// WithSectionMD5 indicates if MD5 hash is calculated for available sections.
func WithSectionMD5() Option {
	return func(o *opts) {
		o.sectionMD5 = true
	}
}

// WithVersionResources indicates if version resources are parsed from the resource directory.
func WithVersionResources() Option {
	return func(o *opts) {
		o.parseResources = true
	}
}

// WithSecurity indicates if the security directory is parsed to extract signature information
// like certificates or Authenticode hashes.
func WithSecurity() Option {
	return func(o *opts) {
		o.parseSecurity = true
	}
}

// WithImphash indicates if the import hash (imphash) is calculated as part of PE parsing.
func WithImphash() Option {
	return func(o *opts) {
		o.calcImphash = true
	}
}

// WithCLR indicates if CLR (Common Language Runtime) header is parsed.
func WithCLR() Option {
	return func(o *opts) {
		o.parseCLR = true
	}
}

// ParseFile parses the PE given the file system path and parser options.
func ParseFile(path string, opts ...Option) (*PE, error) {
	return parse(path, nil, opts...)
}

// ParseFileWithConfig parses the PE given the file system path and the config
// which is usually read from the YAML file. Config flags are converted to parser
// options.
func ParseFileWithConfig(path string, config Config) (*PE, error) {
	if !config.Enabled {
		return nil, nil
	}
	var opts []Option
	if len(config.ExcludedImages) > 0 {
		opts = append(opts, WithExcludedImages(config.ExcludedImages))
	}
	if config.ReadSections {
		opts = append(opts, WithSections())
	}
	if config.ReadSymbols {
		opts = append(opts, WithSymbols())
	}
	if config.ReadResources {
		opts = append(opts, WithVersionResources())
	}
	return ParseFile(path, opts...)
}

// ParseBytes tries to parse the PE from the given byte slice and parser options.
func ParseBytes(data []byte, opts ...Option) (*PE, error) {
	if len(data) == 0 || va.Zeroed(data) {
		return nil, ErrEmptyVArea
	}
	return parse("", data, opts...)
}

// ParseMem parses the in-memory layout of the PE header for the
// specified process and base address. If change protection parameter
// is set to true, this method will attempt to change region protection
// if the region is marked as inaccessible.
func ParseMem(pid uint32, base uintptr, changeProtection bool, opts ...Option) (*PE, error) {
	access := windows.PROCESS_VM_READ | windows.PROCESS_QUERY_INFORMATION
	if changeProtection {
		access |= windows.PROCESS_VM_OPERATION
	}
	process, err := windows.OpenProcess(uint32(access), false, pid)
	if err != nil {
		return nil, err
	}
	defer windows.Close(process)
	area := va.ReadArea(process, base, MaxHeaderSize, MinHeaderSize, changeProtection)
	return ParseBytes(area, opts...)
}

func newParserOpts(opts opts) *peparser.Options {
	return &peparser.Options{
		DisableCertValidation:     true,
		OmitIATDirectory:          true,
		OmitSecurityDirectory:     !opts.parseSecurity,
		OmitExceptionDirectory:    true,
		OmitTLSDirectory:          true,
		OmitCLRHeaderDirectory:    !opts.parseCLR,
		OmitCLRMetadata:           true,
		OmitDelayImportDirectory:  true,
		OmitBoundImportDirectory:  true,
		OmitArchitectureDirectory: true,
		OmitDebugDirectory:        true,
		OmitRelocDirectory:        true,
		OmitResourceDirectory:     !opts.parseResources,
		OmitImportDirectory:       !opts.parseSymbols && !opts.calcImphash,
		OmitExportDirectory:       !opts.parseExports,
		OmitLoadConfigDirectory:   true,
		OmitGlobalPtrDirectory:    true,
		SectionEntropy:            opts.sectionEntropy,
		Logger:                    &Logger{},
	}
}

// Logger is the adapter for routing PE package logs to logrus.
type Logger struct{}

func (l Logger) Log(level peparserlog.Level, keyvals ...interface{}) error {
	switch level {
	case peparserlog.LevelDebug:
		log.Debug(keyvals[1:]...)
	case peparserlog.LevelInfo:
		log.Info(keyvals[1:]...)
	case peparserlog.LevelWarn:
		log.Warn(keyvals[1:]...)
	case peparserlog.LevelError, peparserlog.LevelFatal:
		log.Error(keyvals[1:]...)
	default:
		log.Info(keyvals[1:]...)
	}
	return nil
}

func parse(path string, data []byte, options ...Option) (*PE, error) {
	var opts opts
	for _, opt := range options {
		opt(&opts)
	}
	if opts.isImageExcluded(path) {
		return nil, nil
	}
	var pe *peparser.File
	var err error
	if data == nil {
		pe, err = peparser.New(path, newParserOpts(opts))
	} else {
		pe, err = peparser.NewBytes(data, newParserOpts(opts))
	}
	if err != nil {
		return nil, err
	}
	defer pe.Close()

	// parse the DOS header
	err = pe.ParseDOSHeader()
	if err != nil {
		return nil, err
	}

	// parse the NT header
	err = pe.ParseNTHeader()
	if err != nil {
		return nil, err
	}

	timestamp := pe.NtHeader.FileHeader.TimeDateStamp
	linkTime := time.Date(1970, 1, 1, 0, 0, 0, 0, time.UTC).Add(time.Second * time.Duration(timestamp))
	p := &PE{
		NumberOfSections: pe.NtHeader.FileHeader.NumberOfSections,
		LinkTime:         linkTime,
		Symbols:          make([]string, 0),
		Imports:          make([]string, 0),
		Sections:         make([]Sec, 0),
		Exports:          make(map[uint32]string, 0),
		VersionResources: make(map[string]string),
		Is64:             pe.Is64,
		filename:         path,
		dosHeader:        pe.DOSHeader,
		ntHeader:         pe.NtHeader,
		sectionHeaders:   make([]peparser.ImageSectionHeader, 0),
	}

	switch pe.Is64 {
	case true:
		oh64 := pe.NtHeader.OptionalHeader.(peparser.ImageOptionalHeader64)
		p.ImageBase = format.UintToHex(oh64.ImageBase)
		p.EntryPoint = format.UintToHex(uint64(oh64.AddressOfEntryPoint))
	case false:
		oh32 := pe.NtHeader.OptionalHeader.(peparser.ImageOptionalHeader32)
		p.ImageBase = format.UintToHex(uint64(oh32.ImageBase))
		p.EntryPoint = format.UintToHex(uint64(oh32.AddressOfEntryPoint))
	}

	// parse section header
	if opts.parseSections || opts.parseResources || opts.parseCLR {
		err = pe.ParseSectionHeader()
		if err != nil {
			return nil, err
		}
	}
	for _, section := range pe.Sections {
		sec := Sec{
			Name: section.String(),
			Size: section.Header.VirtualSize,
		}
		if section.Entropy != nil {
			sec.Entropy = *section.Entropy
		}
		if opts.sectionMD5 {
			sum := md5.Sum(section.Data(0, 0, pe))
			sec.Md5 = hex.EncodeToString(sum[:])
		}
		p.Sections = append(p.Sections, sec)
	}

	// initialize raw section headers
	for _, sec := range pe.Sections {
		p.sectionHeaders = append(p.sectionHeaders, sec.Header)
	}

	if opts.parseSymbols || opts.parseResources || opts.parseSecurity ||
		opts.calcImphash || opts.parseCLR || opts.parseExports {
		// parse data directories
		err = pe.ParseDataDirectories()
		if err != nil {
			directoryParseErrors.Add(1)
		}
	}

	// add imported symbols
	for _, imp := range pe.Imports {
		p.addImport(imp.Name)
		for _, fun := range imp.Functions {
			p.addSymbol(fun.Name)
		}
	}
	p.NumberOfSymbols = uint32(len(p.Symbols))

	// add exports
	for _, exp := range pe.Export.Functions {
		if exp.Name != "" {
			p.Exports[exp.FunctionRVA] = exp.Name
		} else if exp.Forwarder != "" {
			p.Exports[exp.ForwarderRVA] = exp.Forwarder
		} else {
			p.Exports[exp.FunctionRVA] = fmt.Sprintf("Ordinal%d", exp.Ordinal)
		}
	}

	if opts.parseResources {
		// parse version resources
		p.VersionResources, err = pe.ParseVersionResources()
		if err != nil {
			versionResourcesParseErrors.Add(1)
		}
	}

	// parse certificate info
	if opts.parseSecurity {
		p.IsSigned = pe.IsSigned
		if pe.HasCertificate && len(pe.Certificates.Certificates) > 0 {
			cert := pe.Certificates.Certificates[0]
			p.Cert = &sys.Cert{
				Issuer:       cert.Info.Issuer,
				Subject:      cert.Info.Subject,
				NotBefore:    cert.Info.NotBefore,
				NotAfter:     cert.Info.NotAfter,
				SerialNumber: cert.Info.SerialNumber,
			}
		}
	}

	// calculate imphash
	if opts.calcImphash {
		p.Imphash, err = pe.ImpHash()
		if err != nil {
			imphashErrors.Add(1)
		}
	}

	p.IsDLL = pe.IsDLL()
	p.IsDriver = p.isDriver()
	p.IsExecutable = pe.IsEXE()
	p.IsDotnet = pe.HasCLR
	p.Anomalies = pe.Anomalies

	return p, nil
}

// isDriver determines if the PE is a Windows driver. This method is inherited
// from the saferwall parser with the imports defensive check removed as some
// driver samples may not contain an import directory, but section names may
// reveal the PE is a kernel driver.
func (pe *PE) isDriver() bool {
	// Prevent false positives such as ntdll.dll
	// because it has the PAGE section which is
	// driver-typical
	if pe.IsDLL {
		return false
	}
	// DIRECTORY_ENTRY_IMPORT may exist, although it may be empty.
	// If it imports from "ntoskrnl.exe" or other kernel components it should
	// be a driver.
	systemDLLs := []string{"ntoskrnl.exe", "hal.dll", "ndis.sys",
		"bootvid.dll", "kdcom.dll"}
	for _, imp := range pe.Imports {
		for _, dll := range systemDLLs {
			if strings.ToLower(imp) == dll {
				return true
			}
		}
	}

	// If still we couldn't tell, check common driver section with combination
	// of IMAGE_SUBSYSTEM_NATIVE or IMAGE_SUBSYSTEM_NATIVE_WINDOWS.
	subsystem := peparser.ImageOptionalHeaderSubsystemType(0)
	oh32 := peparser.ImageOptionalHeader32{}
	oh64 := peparser.ImageOptionalHeader64{}
	switch pe.Is64 {
	case true:
		oh64 = pe.ntHeader.OptionalHeader.(peparser.ImageOptionalHeader64)
		subsystem = oh64.Subsystem
	case false:
		oh32 = pe.ntHeader.OptionalHeader.(peparser.ImageOptionalHeader32)
		subsystem = oh32.Subsystem
	}
	commonDriverSectionNames := []string{"page", "paged", "nonpage", "init"}
	for _, section := range pe.Sections {
		s := strings.ToLower(section.Name)
		for _, driverSection := range commonDriverSectionNames {
			if s == driverSection &&
				(subsystem&peparser.ImageSubsystemNativeWindows != 0 ||
					subsystem&peparser.ImageSubsystemNative != 0) {
				return true
			}
		}
	}
	return false
}

```

`pkg/pe/parser_test.go`:

```go
/*
 * Copyright 2021-2022 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package pe

import (
	"os"
	"path/filepath"
	"testing"
	"time"

	"github.com/stretchr/testify/require"
	"golang.org/x/sys/windows"
)

func TestParseFile(t *testing.T) {
	var tests = []struct {
		file             string
		hasSymbols       bool
		hasSections      bool
		hasImports       bool
		versionResources map[string]string
	}{
		{filepath.Join(os.Getenv("windir"), "notepad.exe"), true, true, true, map[string]string{"OriginalFilename": "NOTEPAD.EXE", "CompanyName": "Microsoft Corporation"}},
		{filepath.Join(os.Getenv("windir"), "regedit.exe"), true, true, true, nil},
		{filepath.Join(os.Getenv("windir"), "system32", "svchost.exe"), true, true, true, map[string]string{"OriginalFilename": "svchost.exe"}},
		{filepath.Join(os.Getenv("windir"), "system32", "kernel32.dll"), true, true, true, map[string]string{"CompanyName": "Microsoft Corporation"}},
	}

	for _, n := range tests {
		tt := n
		t.Run(tt.file, func(t *testing.T) {
			pe, err := ParseFile(tt.file,
				WithSections(),
				WithSymbols(),
				WithVersionResources(),
				WithSectionEntropy(),
				WithSectionMD5(),
			)
			if err != nil {
				t.Fatalf("%s: %v", tt.file, err)
			}
			if pe == nil {
				t.Fatalf("%s: PE metadata is nil", tt.file)
			}
			if len(pe.Symbols) > 0 != tt.hasSymbols {
				t.Errorf("%s: expected to have symbols", tt.file)
			}
			if len(pe.Sections) > 0 != tt.hasSections {
				t.Errorf("%s: expected to have sections", tt.file)
			}
			if len(pe.Imports) > 0 != tt.hasImports {
				t.Errorf("%s: expected to have imports", tt.file)
			}
			sec := pe.Sections[0]
			if sec.Md5 == "" {
				t.Errorf("%s: section should have MD5 hash", tt.file)
			}
			if sec.Entropy == 0.0 {
				t.Errorf("%s: section should have entropy value", tt.file)
			}
			if tt.versionResources != nil {
				for k, v := range tt.versionResources {
					vers := pe.VersionResources
					val, ok := vers[k]
					if !ok {
						t.Errorf("%s: should have %s version resource", tt.file, k)
					}
					if val != v {
						t.Errorf("%s: expected: %s version resource got: %s. Available resources: %v", tt.file, v, val, vers)
					}
				}
			}
		})
	}
}

func TestIsDotnet(t *testing.T) {
	pe, err := ParseFile("./_fixtures/mscorlib.dll", WithCLR())
	require.NoError(t, err)
	require.True(t, pe.IsDotnet)
}

func TestIsDriver(t *testing.T) {
	pe, err := ParseFile("./_fixtures/054299e09cea38df2b84e6b29348b418.bin", WithSections(), WithSymbols())
	require.NoError(t, err)
	require.True(t, pe.IsDriver)
}

func TestParseMem(t *testing.T) {
	var tests = []struct {
		executable       string
		expectedSections int
	}{
		{filepath.Join(os.Getenv("windir"), "regedit.exe"), 8},
	}

	for _, tt := range tests {
		var si windows.StartupInfo
		var pi windows.ProcessInformation
		argv := windows.StringToUTF16Ptr(tt.executable)
		err := windows.CreateProcess(
			nil,
			argv,
			nil,
			nil,
			true,
			0,
			nil,
			nil,
			&si,
			&pi)
		require.NoError(t, err)
		time.Sleep(time.Millisecond * 300)
		defer func() {
			_ = windows.TerminateProcess(pi.Process, 0)
		}()
		addr, err := getModuleBaseAddress(pi.ProcessId)
		if err != nil {
			t.Fatalf("%s: unable to get the base address: %v", tt.executable, err)
		}

		pe, err := ParseMem(pi.ProcessId, addr, false, WithSections())
		if err != nil {
			t.Fatalf("%s: %v", tt.executable, err)
		}
		if pe == nil {
			t.Fatalf("%s: PE metadata is nil", tt.executable)
		}
		if len(pe.Sections) != tt.expectedSections {
			t.Errorf("%s: expected: %d, got %d sections", tt.executable, tt.expectedSections, len(pe.Sections))
		}
	}
}

func getModuleBaseAddress(pid uint32) (uintptr, error) {
	var moduleHandles [1024]windows.Handle
	var cbNeeded uint32
	proc, err := windows.OpenProcess(windows.PROCESS_QUERY_INFORMATION|windows.PROCESS_VM_READ, false, pid)
	if err != nil {
		return 0, err
	}
	if err := windows.EnumProcessModulesEx(proc, &moduleHandles[0], 1024, &cbNeeded, windows.LIST_MODULES_ALL); err != nil {
		return 0, err
	}
	moduleHandle := moduleHandles[0]
	return uintptr(moduleHandle), nil
}

```

`pkg/pe/types.go`:

```go
//go:build windows
// +build windows

/*
 * Copyright 2019-2020 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package pe

import (
	"fmt"
	"github.com/rabbitstack/fibratus/pkg/sys"
	peparser "github.com/saferwall/pe"
	"runtime"
	"sync"
	"time"
)

const (
	// Company represents the company name string file info entry in the resources table
	Company = "CompanyName"
	// FileDescription represents the file description entry in the resources table
	FileDescription = "FileDescription"
	// FileVersion represents the file version entry in the resources table
	FileVersion = "FileVersion"
	// OriginalFilename the name of the original executable in the resources table
	OriginalFilename = "OriginalFilename"
	// LegalCopyright represents the copyright notice in the resources directory table
	LegalCopyright = "LegalCopyright"
	// ProductName is the product name entry in the resources table
	ProductName = "ProductName"
	// ProductVersion is the product version entry in the resources table
	ProductVersion = "ProductVersion"
)

// Sec contains the section attributes.
type Sec struct {
	Name    string
	Size    uint32
	Entropy float64
	Md5     string
}

// String returns the stirng representation of the section.
func (s Sec) String() string {
	return fmt.Sprintf("Name: %s, Size: %d, Entropy: %f, Md5: %s", s.Name, s.Size, s.Entropy, s.Md5)
}

// PE contains various headers that identifies the format and characteristics of the executable files.
type PE struct {
	// NumberOfSections designates the total number of sections found withing the binary.
	NumberOfSections uint16 `json:"nsections"`
	// NumberOfSymbols represents the total number of symbols.
	NumberOfSymbols uint32 `json:"nsymbols"`
	// ImageBase designates the base address of the process' image.
	ImageBase string `json:"image_base"`
	// Entrypoint is the address of the entry point function.
	EntryPoint string `json:"entry_point"`
	// LinkTime represents the time that the image was created by the linker.
	LinkTime time.Time `json:"link_time"`
	// Sections contains all distinct sections and their metadata.
	Sections []Sec `json:"sections"`
	// Symbols contains the list of imported symbols.
	Symbols []string `json:"symbols"`
	// Imports contains the imported libraries.
	Imports []string `json:"imports"`
	// VersionResources holds the version resources
	VersionResources map[string]string `json:"resources"`
	// IsSigned determines if the PE contains a digital signature.
	IsSigned bool `json:"is_signed"`
	// IsTrusted determines if the PE certificate chain is trusted.
	IsTrusted bool `json:"is_trusted"`
	// Cert contains certificate information.
	Cert *sys.Cert `json:"cert"`
	// IsDriver indicates if the PE contains driver code.
	IsDriver bool `json:"is_driver"`
	// IsDLL indicates if the PE is a DLL.
	IsDLL bool `json:"is_dll"`
	// IsExecutable indicates if the PE is an executable image.
	IsExecutable bool `json:"is_executable"`
	// IsDotnet indicates if the PE contains CLR data.
	IsDotnet bool `json:"is_dotnet"`
	// Imphash represents the PE import hash.
	Imphash string `json:"imphash"`
	// Anomalies contains PE parsing anomalies.
	Anomalies []string `json:"anomalies"`
	// Is64 indicates if the PE was built on the 64 bits machine
	Is64 bool `json:"is_64"`
	// IsModified indicates if PE differs from its in-memory state
	IsModified bool `json:"is_modified"`
	// Exports contains exported function names indexed by RVA
	Exports map[uint32]string `json:"exports"`

	dosHeader      peparser.ImageDOSHeader
	ntHeader       peparser.ImageNtHeader
	sectionHeaders []peparser.ImageSectionHeader

	filename string
	once     sync.Once
}

// VerifySignature checks if the embedded or catalog PE signature is trusted.
func (pe *PE) VerifySignature() {
	pe.once.Do(func() {
		if sys.IsWintrustFound() {
			runtime.LockOSThread()
			trust := sys.NewWintrustData(sys.WtdChoiceFile)
			defer trust.Close()
			defer runtime.UnlockOSThread()
			pe.IsTrusted = trust.VerifyFile(pe.filename)
			// maybe the PE is catalog signed?
			if !pe.IsSigned {
				catalog := sys.NewCatalog()
				err := catalog.Open(pe.filename)
				defer catalog.Close()
				if err != nil {
					return
				}
				pe.IsSigned = catalog.IsCatalogSigned()
				if pe.IsSigned {
					pe.IsTrusted = catalog.Verify(pe.filename)
				}
				if pe.IsSigned && pe.IsTrusted {
					pe.Cert, _ = catalog.ParseCertificate()
				}
			}
		}
	})
}

// String returns the string representation of the PE metadata.
func (pe *PE) String() string {
	return fmt.Sprintf(`
		 Number of sections: %d
		 Number of symbols: %d
		 Image base: %s
		 Entrypoint: %s
		 Link time: %v
		 Sections: %v
		 Symbols: %v
		 Imports: %v
         Version resources: %v
		`,
		pe.NumberOfSections,
		pe.NumberOfSymbols,
		pe.ImageBase,
		pe.EntryPoint,
		pe.LinkTime,
		pe.Sections,
		pe.Symbols,
		pe.Imports,
		pe.VersionResources,
	)
}

// Section returns the section with specified name.
func (pe *PE) Section(s string) *Sec {
	for _, sec := range pe.Sections {
		if sec.Name == s {
			return &sec
		}
	}
	return nil
}

func (pe *PE) addImport(i string) {
	pe.Imports = append(pe.Imports, i)
}

func (pe *PE) addSymbol(s string) {
	pe.Symbols = append(pe.Symbols, s)
}

```

`pkg/ps/doc.go`:

```go
/*
 * Copyright 2019-2020 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

// Package ps contains process's state snapshotter implementation.
package ps

```

`pkg/ps/peb.go`:

```go
//go:build windows
// +build windows

/*
 * Copyright 2019-2020 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package ps

import (
	"github.com/rabbitstack/fibratus/pkg/sys"
	"golang.org/x/sys/windows"
	"strings"
	"unicode/utf16"
	"unsafe"
)

// PEB contains various process's metadata from the Process Environment Block (PEB). PEB is an opaque data structure
// that contains information that apply across a whole process, including global context, startup parameters, data structures
// for the program image loader, the program image base address, and synchronization objects used to provide mutual exclusion
// for process-wide data structures. Although it is not encouraged to access this structure due to its unstable nature, some
// process's information like command line or environments strings are only available through Process Environment Block fields.
type PEB struct {
	peb        *windows.PEB
	procParams *windows.RTL_USER_PROCESS_PARAMETERS
	proc       windows.Handle
}

// ReadPEB queries the process's basic information class structures and copies the PEB into
// the current process's address space.
func ReadPEB(proc windows.Handle) (*PEB, error) {
	peb := &PEB{proc: proc}
	pbi, err := sys.QueryInformationProcess[windows.PROCESS_BASIC_INFORMATION](proc, windows.ProcessBasicInformation)
	if err != nil {
		return nil, err
	}
	// read the PEB to get the process parameters. Because the PEB structure resides
	// in the address space of another process we must read the memory block in order
	// to access the structure's fields.
	peb.peb, err = sys.ReadProcessMemory[windows.PEB](proc, uintptr(unsafe.Pointer(pbi.PebBaseAddress)))
	if err != nil {
		if err == windows.ERROR_ACCESS_DENIED || err == windows.ERROR_NOACCESS ||
			err == windows.ERROR_PARTIAL_COPY {
			return peb, nil
		}
		return nil, err
	}
	// read the `RTL_USER_PROCESS_PARAMETERS` struct which contains the command line
	// and the image name of the process among many other attributes.
	peb.procParams, err = sys.ReadProcessMemory[windows.RTL_USER_PROCESS_PARAMETERS](proc, uintptr(unsafe.Pointer(peb.peb.ProcessParameters)))
	if err != nil {
		return nil, err
	}
	return peb, nil
}

// GetImage inspects the process image name by reading the memory buffer in the PEB.
func (p PEB) GetImage() string {
	if p.procParams == nil {
		return ""
	}
	image := readUTF16(p.proc, uniptr(p.procParams.ImagePathName.Buffer), uint32(p.procParams.ImagePathName.Length))
	return windows.UTF16ToString(image)
}

// GetCommandLine inspects the process command line arguments by reading the memory buffer in the PEB.
func (p PEB) GetCommandLine() string {
	if p.procParams == nil {
		return ""
	}
	cmdline := readUTF16(p.proc, uniptr(p.procParams.CommandLine.Buffer), uint32(p.procParams.CommandLine.Length))
	return windows.UTF16ToString(cmdline)
}

// GetCurrentWorkingDirectory reads the current working directory from the PEB.
func (p PEB) GetCurrentWorkingDirectory() string {
	if p.procParams == nil {
		return ""
	}
	cwd := readUTF16(p.proc, uniptr(p.procParams.CurrentDirectory.DosPath.Buffer), uint32(p.procParams.CurrentDirectory.DosPath.Length))
	return windows.UTF16ToString(cwd)
}

// GetSessionID returns the process session identifier.
func (p PEB) GetSessionID() uint32 {
	if p.peb == nil {
		return 0
	}
	return p.peb.SessionId
}

// GetEnvs returns the map of environment variables that were mapped into the process PEB.
func (p PEB) GetEnvs() map[string]string {
	if p.procParams == nil {
		return nil
	}
	start, end := 0, 0
	envs := make(map[string]string)
	l := uint32(p.procParams.EnvironmentSize)
	s := readUTF16(p.proc, uintptr(p.procParams.Environment), l)
	for i, r := range s {
		// each env variable key/value pair terminates with the NUL character
		if r == 0 {
			end = i
		}
		if end > start {
			// the next token starts with a NUL character
			// which means we have consumed all env variables
			if s[start] == 0 {
				break
			}
			env := string(utf16.Decode(s[start:end]))
			if kv := strings.SplitN(env, "=", 2); len(kv) == 2 {
				envs[kv[0]] = kv[1]
			}
			start = end + 1
		}
	}
	return envs
}

func readUTF16(proc windows.Handle, addr uintptr, size uint32) []uint16 {
	b := make([]byte, size*2+1)
	err := windows.ReadProcessMemory(proc, addr, &b[0], uintptr(len(b)), nil)
	if err != nil {
		return nil
	}
	l := uintptr(len(b)) * unsafe.Sizeof(b[0]) / unsafe.Sizeof(uint16(0))
	s := unsafe.Slice((*uint16)(unsafe.Pointer(&b[0])), l)
	return s
}

func uniptr(b *uint16) uintptr { return uintptr(unsafe.Pointer(b)) }

```

`pkg/ps/peb_test.go`:

```go
//go:build windows
// +build windows

/*
 * Copyright 2019-2020 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package ps

import (
	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/require"
	"golang.org/x/sys/windows"
	"os"
	"path/filepath"
	"strings"
	"testing"
)

func TestReadPEB(t *testing.T) {
	desiredAccess := uint32(windows.PROCESS_QUERY_INFORMATION | windows.PROCESS_VM_READ)
	proc, err := windows.OpenProcess(desiredAccess, false, uint32(os.Getpid()))
	if err != nil {
		t.Fatal(err)
	}
	defer windows.CloseHandle(proc)

	peb, err := ReadPEB(proc)
	require.NoError(t, err)

	assert.Equal(t, "ps.test.exe", filepath.Base(peb.GetImage()))
	assert.Equal(t, "ps", filepath.Base(peb.GetCurrentWorkingDirectory()))

	args := strings.Fields(peb.GetCommandLine())
	assert.True(t, len(args) > 1)
	assert.Contains(t, args, "-test.timeout=10m0s")

	assert.Contains(t, peb.GetEnvs(), "COMPUTERNAME")
}

```

`pkg/ps/snapshotter.go`:

```go
/*
 * Copyright 2020-2021 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package ps

import (
	"github.com/rabbitstack/fibratus/pkg/event"
	pstypes "github.com/rabbitstack/fibratus/pkg/ps/types"
	"github.com/rabbitstack/fibratus/pkg/util/va"
)

// Snapshotter is the interface that exposes a set of methods all process snapshotters have to satisfy. It stores the state
// of all running processes in the system including its threads, dynamically loaded libraries, handles/file descriptors
// and other metadata.
type Snapshotter interface {
	// Write appends a new process state to the snapshotter. It takes as an input the inbound event to fetch
	// the basic data, but also enriches the process' state with extra metadata such as process' env variables, PE
	// metadata for Windows binaries and so on.
	Write(*event.Event) error
	// AddThread builds thread state from the event representation.
	AddThread(*event.Event) error
	// AddModule builds module state from the event representation.
	AddModule(*event.Event) error
	// RemoveThread removes the thread from the given process.
	RemoveThread(pid uint32, tid uint32) error
	// RemoveModule removes the module the given process.
	RemoveModule(pid uint32, addr va.Address) error
	// AddMmap adds a new memory mapping (data memory-mapped file, image, or pagefile) to this process state.
	AddMmap(*event.Event) error
	// RemoveMmap removes memory mapping at the given base address.
	RemoveMmap(pid uint32, addr va.Address) error
	// WriteFromCapture appends a new process state to the snapshotter from the captured event.
	WriteFromCapture(evt *event.Event) error
	// Remove deletes process's state from the snapshotter.
	Remove(evt *event.Event) error
	// Find attempts to retrieve process' state for the specified process identifier. Returns true
	// if the process was find in the state. Otherwise, returns false and constructs a fresh process
	// state by querying the OS via API functions.
	Find(pid uint32) (bool, *pstypes.PS)
	// FindModule traverses loaded modules of all processes in the snapshot and
	// if there is module with the specified base address, it returns its metadata.
	FindModule(addr va.Address) (bool, *pstypes.Module)
	// FindAllModules finds all unique modules across the snapshotter state.
	FindAllModules() map[string]pstypes.Module
	// FindAndPut attempts to retrieve process' state for the specified process identifier.
	// If the process is found, the snapshotter state is updated with the new process.
	FindAndPut(pid uint32) *pstypes.PS
	// Put inserts the process state into snapshotter.
	Put(*pstypes.PS)
	// Size returns the total number of process state items.
	Size() uint32
	// Close closes process snapshotter and disposes all allocated resources.
	Close() error
}

```

`pkg/ps/snapshotter_mock.go`:

```go
/*
 * Copyright 2019-2020 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package ps

import (
	"github.com/rabbitstack/fibratus/pkg/event"
	pstypes "github.com/rabbitstack/fibratus/pkg/ps/types"
	"github.com/rabbitstack/fibratus/pkg/util/va"
	"github.com/stretchr/testify/mock"
)

// SnapshotterMock is the process snapshotter mock used in tests.
type SnapshotterMock struct {
	mock.Mock
}

// Write method
func (s *SnapshotterMock) Write(evt *event.Event) error {
	args := s.Called(evt)
	return args.Error(0)
}

// Remove method
func (s *SnapshotterMock) Remove(evt *event.Event) error {
	args := s.Called(evt)
	return args.Error(0)
}

// Find method
func (s *SnapshotterMock) Find(pid uint32) (bool, *pstypes.PS) {
	args := s.Called(pid)
	return args.Bool(0), args.Get(1).(*pstypes.PS)
}

func (s *SnapshotterMock) FindModule(addr va.Address) (bool, *pstypes.Module) {
	args := s.Called(addr)
	mod := args.Get(1)
	if mod != nil {
		return args.Bool(0), mod.(*pstypes.Module)
	}
	return args.Bool(0), nil
}

func (s *SnapshotterMock) FindAllModules() map[string]pstypes.Module {
	args := s.Called()
	return args.Get(0).(map[string]pstypes.Module)
}

// FindAndPut method
func (s *SnapshotterMock) FindAndPut(pid uint32) *pstypes.PS {
	args := s.Called(pid)
	return args.Get(0).(*pstypes.PS)
}

// Put method
func (s *SnapshotterMock) Put(ps *pstypes.PS) {}

// Size method
func (s *SnapshotterMock) Size() uint32 { args := s.Called(); return uint32(args.Int(0)) }

// Close method
func (s *SnapshotterMock) Close() error { return nil }

// GetSnapshot method
func (s *SnapshotterMock) GetSnapshot() []*pstypes.PS {
	args := s.Called()
	return args.Get(0).([]*pstypes.PS)
}

// AddThread method
func (s *SnapshotterMock) AddThread(evt *event.Event) error {
	args := s.Called(evt)
	return args.Error(0)
}

// AddModule method
func (s *SnapshotterMock) AddModule(evt *event.Event) error {
	args := s.Called(evt)
	return args.Error(0)
}

// RemoveThread method
func (s *SnapshotterMock) RemoveThread(pid uint32, tid uint32) error {
	args := s.Called(pid, tid)
	return args.Error(0)
}

// RemoveModule method
func (s *SnapshotterMock) RemoveModule(pid uint32, addr va.Address) error {
	args := s.Called(pid, addr)
	return args.Error(0)
}

// WriteFromCapture method
func (s *SnapshotterMock) WriteFromCapture(evt *event.Event) error { return nil }

// AddMmap method
func (s *SnapshotterMock) AddMmap(evt *event.Event) error {
	args := s.Called(evt)
	return args.Error(0)
}

// RemoveMmap method
func (s *SnapshotterMock) RemoveMmap(pid uint32, address va.Address) error {
	args := s.Called(pid, address)
	return args.Error(0)
}

```

`pkg/ps/snapshotter_windows.go`:

```go
/*
 * Copyright 2019-2020 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package ps

import (
	"expvar"
	"path/filepath"
	"strconv"
	"strings"
	"sync"
	"time"

	"github.com/rabbitstack/fibratus/pkg/sys"
	"github.com/rabbitstack/fibratus/pkg/util/va"
	"golang.org/x/sys/windows"

	"github.com/rabbitstack/fibratus/pkg/config"
	"github.com/rabbitstack/fibratus/pkg/event"
	"github.com/rabbitstack/fibratus/pkg/event/params"
	"github.com/rabbitstack/fibratus/pkg/handle"
	htypes "github.com/rabbitstack/fibratus/pkg/handle/types"
	"github.com/rabbitstack/fibratus/pkg/pe"
	pstypes "github.com/rabbitstack/fibratus/pkg/ps/types"
	log "github.com/sirupsen/logrus"
)

// SystemPID designates the pid of the system process that acts as the container for system threads
const SystemPID uint32 = 4

var (
	// reapPeriod specifies the interval for triggering the housekeeping of dead processes
	reapPeriod = time.Minute * 2

	processLookupFailureCount = expvar.NewMap("process.lookup.failure.count")
	reapedProcesses           = expvar.NewInt("process.reaped")
	processCount              = expvar.NewInt("process.count")
	threadCount               = expvar.NewInt("process.thread.count")
	moduleCount               = expvar.NewInt("process.module.count")
	mmapCount                 = expvar.NewInt("process.mmap.count")
	pebReadErrors             = expvar.NewInt("process.peb.read.errors")
	processEnrichments        = expvar.NewInt("process.enrichments")
)

type snapshotter struct {
	mu      sync.RWMutex
	procs   map[uint32]*pstypes.PS
	dirty   map[uint32]*pstypes.PS
	dmu     sync.RWMutex
	quit    chan struct{}
	config  *config.Config
	hsnap   handle.Snapshotter
	capture bool
}

// NewSnapshotter returns a new instance of the process snapshotter.
func NewSnapshotter(hsnap handle.Snapshotter, config *config.Config) Snapshotter {
	s := &snapshotter{
		procs:  make(map[uint32]*pstypes.PS),
		dirty:  make(map[uint32]*pstypes.PS),
		quit:   make(chan struct{}, 1),
		config: config,
		hsnap:  hsnap,
	}

	s.mu.Lock()
	defer s.mu.Unlock()

	s.hsnap.RegisterCreateCallback(s.onHandleCreated)
	s.hsnap.RegisterDestroyCallback(s.onHandleDestroyed)

	go s.gcDeadProcesses()

	return s
}

// NewSnapshotterFromCapture restores the snapshotter state from the cap file.
func NewSnapshotterFromCapture(hsnap handle.Snapshotter, config *config.Config) Snapshotter {
	s := &snapshotter{
		procs:   make(map[uint32]*pstypes.PS),
		dirty:   make(map[uint32]*pstypes.PS),
		quit:    make(chan struct{}, 1),
		config:  config,
		hsnap:   hsnap,
		capture: true,
	}

	s.hsnap.RegisterCreateCallback(s.onHandleCreated)
	s.hsnap.RegisterDestroyCallback(s.onHandleDestroyed)

	return s
}

func (s *snapshotter) WriteFromCapture(e *event.Event) error {
	switch e.Type {
	case event.CreateProcess, event.ProcessRundown:
		s.mu.Lock()
		defer s.mu.Unlock()
		proc := e.PS
		if proc == nil {
			return nil
		}
		pid, err := e.Params.GetPid()
		if err != nil {
			return err
		}
		ppid, err := e.Params.GetPpid()
		if err != nil {
			return err
		}
		if proc.PID == proc.Ppid ||
			(e.IsProcessRundown() && pid == sys.InvalidProcessID) {
			return nil
		}
		if e.IsProcessRundown() {
			proc.Parent = s.procs[ppid]
		} else {
			proc, err = s.newProcState(pid, ppid, e)
			if err != nil {
				return err
			}
		}
		s.procs[pid] = proc
	case event.CreateThread, event.ThreadRundown:
		return s.AddThread(e)
	case event.LoadImage, event.ImageRundown:
		return s.AddModule(e)
	}
	return nil
}

func (s *snapshotter) Write(e *event.Event) error {
	s.mu.Lock()
	defer s.mu.Unlock()
	processCount.Add(1)

	pid, err := e.Params.GetPid()
	if err != nil {
		return err
	}
	ppid, err := e.Params.GetPpid()
	if err != nil {
		return err
	}

	proc, err := s.newProcState(pid, ppid, e)
	if ps := s.procs[pid]; ps == nil && (e.IsCreateProcessInternal() || e.IsProcessRundownInternal()) {
		// only modify the state if there is no process derived from the NT kernel logger process events
		s.procs[pid] = proc
	} else if ps, ok := s.procs[pid]; ok && (e.IsCreateProcessInternal() || e.IsProcessRundownInternal()) && ps.IsCreatedFromSystemLogger {
		// process state derived from the core kernel events exists - enrich it
		ps.TokenIntegrityLevel = proc.TokenIntegrityLevel
		ps.TokenElevationType = proc.TokenElevationType
		ps.IsTokenElevated = proc.IsTokenElevated
		if strings.EqualFold(ps.Name, filepath.Base(proc.Exe)) && len(proc.Exe) > len(ps.Exe) {
			// prefer full executable path
			ps.Exe = proc.Exe
		}
		s.procs[pid] = ps
	} else if ps, ok := s.procs[pid]; ok && (e.IsCreateProcess() || e.IsProcessRundown()) && !ps.IsCreatedFromSystemLogger {
		// enrich the existing process state with the newly arrived NT kernel logger process events
		// but obtain the integrity level and executable path from the previous proc state
		processEnrichments.Add(1)
		proc.TokenIntegrityLevel = ps.TokenIntegrityLevel
		proc.TokenElevationType = ps.TokenElevationType
		proc.IsTokenElevated = ps.IsTokenElevated

		if strings.EqualFold(proc.Name, filepath.Base(ps.Exe)) && len(ps.Exe) > len(proc.Exe) {
			// prefer full executable path
			proc.Exe = ps.Exe
			e.AppendParam(params.Exe, params.Path, ps.Exe)
		}

		// if the process UUID has been initialized when
		// the internal event arrived, reassign it to the
		// current process state
		proc.AssignUUID(ps)

		e.AppendParam(params.ProcessTokenIntegrityLevel, params.AnsiString, ps.TokenIntegrityLevel)
		e.AppendParam(params.ProcessTokenElevationType, params.AnsiString, ps.TokenElevationType)
		e.AppendParam(params.ProcessTokenIsElevated, params.Bool, ps.IsTokenElevated)

		s.procs[pid] = proc
	} else {
		// in all other cases append the process state
		s.procs[pid] = proc
	}

	// assign process state to the event
	e.PS = proc

	return err
}

func (s *snapshotter) AddThread(e *event.Event) error {
	pid, err := e.Params.GetPid()
	if err != nil {
		return err
	}
	threadCount.Add(1)

	s.mu.Lock()
	defer s.mu.Unlock()
	proc, ok := s.procs[pid]
	if !ok {
		return nil
	}

	thread := pstypes.Thread{}
	thread.Tid, _ = e.Params.GetTid()
	thread.UstackBase = e.Params.TryGetAddress(params.UstackBase)
	thread.UstackLimit = e.Params.TryGetAddress(params.UstackLimit)
	thread.KstackBase = e.Params.TryGetAddress(params.KstackBase)
	thread.KstackLimit = e.Params.TryGetAddress(params.KstackLimit)
	thread.IOPrio, _ = e.Params.GetUint8(params.IOPrio)
	thread.BasePrio, _ = e.Params.GetUint8(params.BasePrio)
	thread.PagePrio, _ = e.Params.GetUint8(params.PagePrio)
	thread.StartAddress = e.Params.TryGetAddress(params.StartAddress)

	proc.AddThread(thread)

	return nil
}

func (s *snapshotter) AddModule(e *event.Event) error {
	pid, err := e.Params.GetPid()
	if err != nil {
		return err
	}
	s.mu.Lock()
	defer s.mu.Unlock()

	if pid == 0 && e.IsImageRundown() {
		// assume system process if pid is zero
		pid = SystemPID
	}
	proc, ok := s.procs[pid]
	if !ok {
		return nil
	}

	module := pstypes.Module{}
	module.Size, _ = e.Params.GetUint64(params.ImageSize)
	module.Checksum, _ = e.Params.GetUint32(params.ImageCheckSum)
	module.Name = e.GetParamAsString(params.ImagePath)
	module.BaseAddress = e.Params.TryGetAddress(params.ImageBase)
	module.DefaultBaseAddress = e.Params.TryGetAddress(params.ImageDefaultBase)

	if e.IsLoadImageInternal() {
		proc.AddModule(module)
		return nil
	}

	moduleCount.Add(1)

	module.SignatureLevel, _ = e.Params.GetUint32(params.ImageSignatureLevel)
	module.SignatureType, _ = e.Params.GetUint32(params.ImageSignatureType)

	if strings.EqualFold(proc.Name, filepath.Base(module.Name)) && len(proc.Exe) < len(module.Name) {
		// if the module is loaded for the process executable, and
		// we don't have the full executable path, override with
		// the one from the image path
		proc.Exe = module.Name
	}

	proc.AddModule(module)

	return nil
}

func (s *snapshotter) RemoveThread(pid uint32, tid uint32) error {
	s.mu.Lock()
	defer s.mu.Unlock()
	proc, ok := s.procs[pid]
	if !ok {
		return nil
	}
	proc.RemoveThread(tid)
	threadCount.Add(-1)
	return nil
}

func (s *snapshotter) RemoveModule(pid uint32, addr va.Address) error {
	s.mu.Lock()
	defer s.mu.Unlock()
	proc, ok := s.procs[pid]
	if !ok {
		return nil
	}
	proc.RemoveModule(addr)
	moduleCount.Add(-1)
	return nil
}

func (s *snapshotter) FindModule(addr va.Address) (bool, *pstypes.Module) {
	s.mu.RLock()
	defer s.mu.RUnlock()
	for _, proc := range s.procs {
		for _, mod := range proc.Modules {
			if mod.BaseAddress == addr {
				return true, &mod
			}
		}
	}
	return false, nil
}

func (s *snapshotter) FindAllModules() map[string]pstypes.Module {
	s.mu.RLock()
	defer s.mu.RUnlock()
	mods := make(map[string]pstypes.Module)
	for _, proc := range s.procs {
		for _, mod := range proc.Modules {
			if _, ok := mods[mod.Name]; ok {
				continue
			}
			mods[mod.Name] = mod
		}
	}
	return mods
}

func (s *snapshotter) AddMmap(e *event.Event) error {
	s.mu.Lock()
	defer s.mu.Unlock()
	proc, ok := s.procs[e.PID]
	if !ok {
		return nil
	}

	mmapCount.Add(1)

	mmap := pstypes.Mmap{}
	mmap.File = e.GetParamAsString(params.FilePath)
	mmap.BaseAddress = e.Params.TryGetAddress(params.FileViewBase)
	mmap.Size, _ = e.Params.GetUint64(params.FileViewSize)
	mmap.Protection, _ = e.Params.GetUint32(params.MemProtect)
	mmap.Type = e.GetParamAsString(params.FileViewSectionType)

	proc.AddMmap(mmap)

	return nil
}

func (s *snapshotter) RemoveMmap(pid uint32, addr va.Address) error {
	s.mu.Lock()
	defer s.mu.Unlock()
	proc, ok := s.procs[pid]
	if !ok {
		return nil
	}
	mmapCount.Add(-1)
	proc.RemoveMmap(addr)
	return nil
}

func (s *snapshotter) Close() error {
	s.quit <- struct{}{}
	return nil
}

func (s *snapshotter) newProcState(pid, ppid uint32, e *event.Event) (*pstypes.PS, error) {
	if e.IsCreateProcessInternal() || e.IsProcessRundownInternal() {
		proc := &pstypes.PS{
			PID:                 pid,
			Ppid:                ppid,
			Exe:                 e.GetParamAsString(params.Exe),
			Name:                filepath.Base(e.GetParamAsString(params.Exe)),
			TokenIntegrityLevel: e.GetParamAsString(params.ProcessTokenIntegrityLevel),
			TokenElevationType:  e.GetParamAsString(params.ProcessTokenElevationType),
			IsTokenElevated:     e.Params.TryGetBool(params.ProcessTokenIsElevated),
			Threads:             make(map[uint32]pstypes.Thread),
			Modules:             make([]pstypes.Module, 0),
			Handles:             make([]htypes.Handle, 0),
			Mmaps:               make([]pstypes.Mmap, 0),
		}

		return proc, nil
	}

	proc := pstypes.New(
		pid,
		ppid,
		e.GetParamAsString(params.ProcessName),
		e.GetParamAsString(params.Cmdline),
		e.GetParamAsString(params.Exe),
		e.Params.MustGetSID(),
		e.Params.MustGetUint32(params.SessionID),
	)

	proc.Parent = s.procs[ppid]
	proc.StartTime, _ = e.Params.GetTime(params.StartTime)
	proc.IsWOW64 = (e.Params.MustGetUint32(params.ProcessFlags) & event.PsWOW64) != 0
	proc.IsPackaged = (e.Params.MustGetUint32(params.ProcessFlags) & event.PsPackaged) != 0
	proc.IsProtected = (e.Params.MustGetUint32(params.ProcessFlags) & event.PsProtected) != 0
	proc.IsCreatedFromSystemLogger = true

	if !s.capture {
		if proc.Username != "" {
			e.AppendParam(params.Username, params.UnicodeString, proc.Username)
		}
		if proc.Domain != "" {
			e.AppendParam(params.Domain, params.UnicodeString, proc.Domain)
		}
		// retrieve process handles
		var err error
		proc.Handles, err = s.hsnap.FindHandles(pid)
		if err != nil {
			return proc, err
		}
	}

	// return early if we're reading from the capture file
	if s.capture {
		// reset username/domain from captured event parameters
		proc.Domain = e.GetParamAsString(params.Domain)
		proc.Username = e.GetParamAsString(params.Username)
		return proc, nil
	}

	// retrieve Portable Executable data
	var err error
	proc.PE, err = pe.ParseFileWithConfig(proc.Exe, s.config.PE)
	if err != nil {
		return proc, err
	}

	// try to read the PEB (Process Environment Block)
	// to access environment variables and the process
	// current working directory
	access := uint32(windows.PROCESS_QUERY_INFORMATION | windows.PROCESS_VM_READ)
	process, err := windows.OpenProcess(access, false, pid)
	if err != nil {
		process, err = windows.OpenProcess(windows.PROCESS_QUERY_INFORMATION, false, pid)
		if err != nil {
			return proc, nil
		}
	}
	//nolint:errcheck
	defer windows.CloseHandle(process)

	// query token attributes if not enriched by internal event
	if s.procs[pid] == nil {
		var token windows.Token
		err = windows.OpenProcessToken(process, windows.TOKEN_QUERY, &token)
		if err != nil {
			goto readPEB
		}
		defer token.Close()

		// get process token integrity level
		tokenMandatoryLabel, err := sys.GetProcessTokenInformation[windows.Tokenmandatorylabel](token, windows.TokenIntegrityLevel)
		if err != nil {
			goto readPEB
		}

		proc.TokenIntegrityLevel = sys.RidToString(tokenMandatoryLabel.Label.Sid)
		proc.IsTokenElevated = token.IsElevated()

		e.AppendParam(params.ProcessTokenIntegrityLevel, params.AnsiString, proc.TokenIntegrityLevel)
		e.AppendParam(params.ProcessTokenIsElevated, params.Bool, proc.IsTokenElevated)
	}

readPEB:
	// read PEB (Process Environment Block)
	peb, err := ReadPEB(process)
	if err != nil {
		pebReadErrors.Add(1)
		return proc, err
	}
	proc.Envs = peb.GetEnvs()
	proc.Cwd = peb.GetCurrentWorkingDirectory()

	return proc, nil
}

func (s *snapshotter) Remove(e *event.Event) error {
	s.mu.Lock()
	defer s.mu.Unlock()
	pid, err := e.Params.GetPid()
	if err != nil {
		return err
	}
	// remove process from primary map and
	// move to dirty map. This is required
	// to prevent dropping process state from
	// events when TerminateProcess event is
	// emitted before subsequent events
	if proc := s.procs[pid]; proc != nil {
		s.dmu.Lock()
		defer s.dmu.Unlock()
		s.dirty[pid] = proc
		// schedule removal
		remove := func(pid uint32) func() {
			return func() {
				s.dmu.Lock()
				defer s.dmu.Unlock()
				if ps, ok := s.dirty[pid]; ok {
					delete(s.dirty, pid)
					log.Debugf("dirty process removed: %s. Dirty procs: %d", ps.Name, len(s.dirty))
				}
			}
		}
		time.AfterFunc(time.Second*5, remove(pid))
	}
	delete(s.procs, pid)
	processCount.Add(-1)
	// reset parent if it died after spawning a process
	for procID, proc := range s.procs {
		if proc.Ppid == pid {
			s.procs[procID].Parent = nil
		}
	}
	return nil
}

func (s *snapshotter) Put(proc *pstypes.PS) {
	if proc != nil {
		s.mu.Lock()
		defer s.mu.Unlock()
		s.procs[proc.PID] = proc
	}
}

func (s *snapshotter) FindAndPut(pid uint32) *pstypes.PS {
	ok, proc := s.Find(pid)
	if !ok {
		s.Put(proc)
	}
	return proc
}

func (s *snapshotter) Find(pid uint32) (bool, *pstypes.PS) {
	s.mu.RLock()
	defer s.mu.RUnlock()
	ps, ok := s.procs[pid]
	if ok {
		return true, ps
	}
	if s.capture || pid == sys.InvalidProcessID {
		return false, nil
	}

	// check if the process is in dirty map
	s.dmu.RLock()
	defer s.dmu.RUnlock()
	if ps := s.dirty[pid]; ps != nil {
		return true, ps
	}

	processLookupFailureCount.Add(strconv.Itoa(int(pid)), 1)

	proc := &pstypes.PS{
		PID:     pid,
		Ppid:    sys.InvalidProcessID,
		Threads: make(map[uint32]pstypes.Thread),
		Modules: make([]pstypes.Module, 0),
		Handles: make([]htypes.Handle, 0),
	}

	getProcExecutable := func(process windows.Handle) (string, string) {
		var size uint32 = windows.MAX_PATH
		n := make([]uint16, size)
		err := windows.QueryFullProcessImageName(process, 0, &n[0], &size)
		if err != nil {
			return "", ""
		}
		return windows.UTF16ToString(n), filepath.Base(windows.UTF16ToString(n))
	}

	access := uint32(windows.PROCESS_QUERY_INFORMATION | windows.PROCESS_VM_READ)
	process, err := windows.OpenProcess(access, false, pid)
	if err != nil {
		// the access to protected / system process can't be achieved
		// through `PROCESS_VM_READ` or `PROCESS_QUERY_INFORMATION` flags.
		// Try to acquire the process handle again but with restricted access
		// rights to be able to obtain other attributes such as the full process's
		// image executable path or process times
		process, err = windows.OpenProcess(windows.PROCESS_QUERY_LIMITED_INFORMATION, false, pid)
		if err != nil {
			return false, nil
		}
	}
	//nolint:errcheck
	defer windows.CloseHandle(process)

	// get process executable full path and name
	proc.Exe, proc.Name = getProcExecutable(process)

	// consult process parent id
	info, err := sys.QueryInformationProcess[windows.PROCESS_BASIC_INFORMATION](process, windows.ProcessBasicInformation)
	if err != nil {
		return false, proc
	}
	proc.Ppid = uint32(info.InheritedFromUniqueProcessId)

	// retrieve Portable Executable data
	proc.PE, err = pe.ParseFileWithConfig(proc.Exe, s.config.PE)
	if err != nil {
		return false, proc
	}

	// get process times
	var (
		ct windows.Filetime
		xt windows.Filetime
		kt windows.Filetime
		ut windows.Filetime
	)
	err = windows.GetProcessTimes(process, &ct, &xt, &kt, &ut)
	if err != nil {
		return false, proc
	}
	proc.StartTime = time.Unix(0, ct.Nanoseconds())

	// get process creation attributes
	var isWOW64 bool
	if err := windows.IsWow64Process(process, &isWOW64); err == nil && isWOW64 {
		proc.IsWOW64 = true
	}
	if isPackaged, err := sys.IsProcessPackaged(process); err == nil && isPackaged {
		proc.IsPackaged = true
	}
	if prot, err := sys.QueryInformationProcess[sys.PsProtection](process, sys.ProcessProtectionInformation); err == nil && prot != nil {
		proc.IsProtected = prot.IsProtected()
	}

	// get process token attributes
	var (
		token               windows.Token
		tokenUser           *windows.Tokenuser
		tokenMandatoryLabel *windows.Tokenmandatorylabel
	)

	err = windows.OpenProcessToken(process, windows.TOKEN_QUERY, &token)
	if err != nil {
		goto readPEB
	}
	defer token.Close()
	tokenUser, err = token.GetTokenUser()
	if err != nil {
		goto readPEB
	}
	proc.SID = tokenUser.User.Sid.String()
	proc.Username, proc.Domain, _, _ = tokenUser.User.Sid.LookupAccount("")

	// get process token integrity level
	tokenMandatoryLabel, err = sys.GetProcessTokenInformation[windows.Tokenmandatorylabel](token, windows.TokenIntegrityLevel)
	if err != nil {
		goto readPEB
	}

	proc.TokenIntegrityLevel = sys.RidToString(tokenMandatoryLabel.Label.Sid)
	proc.IsTokenElevated = token.IsElevated()

	// retrieve process handles
	proc.Handles, err = s.hsnap.FindHandles(pid)
	if err != nil {
		goto readPEB
	}

readPEB:
	// read PEB (Process Environment Block)
	peb, err := ReadPEB(process)
	if err != nil {
		pebReadErrors.Add(1)
		return false, proc
	}
	proc.Envs = peb.GetEnvs()
	proc.Cmdline = peb.GetCommandLine()
	proc.SessionID = peb.GetSessionID()
	proc.Cwd = peb.GetCurrentWorkingDirectory()

	return false, proc
}

func (s *snapshotter) Size() uint32 {
	s.mu.RLock()
	defer s.mu.RUnlock()
	return uint32(len(s.procs))
}

// gcDeadProcesses periodically scans the map of the snapshot's processes and removes
// any terminated processes from it. This guarantees that any leftovers are cleaned-up
// in case we miss process' terminate events.
func (s *snapshotter) gcDeadProcesses() {
	tick := time.NewTicker(reapPeriod)
	for {
		select {
		case <-tick.C:
			s.mu.Lock()
			ss := len(s.procs)
			log.Debugf("scanning for dead processes on the snapshot of %d items", ss)

			for pid := range s.procs {
				proc, err := windows.OpenProcess(windows.PROCESS_QUERY_LIMITED_INFORMATION, false, pid)
				if err != nil {
					continue
				}
				if !sys.IsProcessRunning(proc) {
					delete(s.procs, pid)
				}
				_ = windows.CloseHandle(proc)
			}

			if ss > len(s.procs) {
				reaped := ss - len(s.procs)
				reapedProcesses.Add(int64(reaped))
				log.Debugf("%d dead process(es) reaped", reaped)
			}
			s.mu.Unlock()
		case <-s.quit:
			tick.Stop()
		}
	}
}

func (s *snapshotter) onHandleCreated(pid uint32, handle htypes.Handle) {
	s.mu.RLock()
	ps, ok := s.procs[pid]
	s.mu.RUnlock()
	if ok {
		s.mu.Lock()
		defer s.mu.Unlock()
		ps.AddHandle(handle)
		s.procs[pid] = ps
	}
}

func (s *snapshotter) onHandleDestroyed(pid uint32, rawHandle windows.Handle) {
	s.mu.RLock()
	ps, ok := s.procs[pid]
	s.mu.RUnlock()
	if ok {
		s.mu.Lock()
		defer s.mu.Unlock()
		ps.RemoveHandle(rawHandle)
		s.procs[pid] = ps
	}
}

```

`pkg/ps/snapshotter_windows_test.go`:

```go
/*
 * Copyright 2019-2020 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package ps

import (
	"os"
	"path/filepath"
	"strings"
	"testing"
	"time"

	"github.com/rabbitstack/fibratus/pkg/config"
	"github.com/rabbitstack/fibratus/pkg/event"
	"github.com/rabbitstack/fibratus/pkg/event/params"
	"github.com/rabbitstack/fibratus/pkg/handle"
	htypes "github.com/rabbitstack/fibratus/pkg/handle/types"
	pstypes "github.com/rabbitstack/fibratus/pkg/ps/types"
	"github.com/rabbitstack/fibratus/pkg/sys"
	"github.com/rabbitstack/fibratus/pkg/util/va"
	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/mock"
	"github.com/stretchr/testify/require"
	"golang.org/x/sys/windows"
)

func TestWrite(t *testing.T) {
	hsnap := new(handle.SnapshotterMock)
	hsnap.On("FindHandles", mock.Anything).Return([]htypes.Handle{}, nil)
	psnap := NewSnapshotter(hsnap, &config.Config{})
	defer psnap.Close()

	var tests = []struct {
		name string
		evt  *event.Event
		want *pstypes.PS
	}{
		{"write state from spawned process",
			&event.Event{
				Type: event.CreateProcess,
				Params: event.Params{
					params.ProcessID:       {Name: params.ProcessID, Type: params.PID, Value: uint32(os.Getpid())},
					params.ProcessParentID: {Name: params.ProcessParentID, Type: params.PID, Value: uint32(os.Getppid())},
					params.ProcessName:     {Name: params.ProcessName, Type: params.UnicodeString, Value: "spotify.exe"},
					params.Cmdline:         {Name: params.Cmdline, Type: params.UnicodeString, Value: `C:\Users\admin\AppData\Roaming\Spotify\Spotify.exe --type=crashpad-handler /prefetch:7 --max-uploads=5 --max-db-size=20 --max-db-age=5 --monitor-self-annotation=ptype=crashpad-handler "--metrics-dir=C:\Users\admin\AppData\Local\Spotify\User Data" --url=https://crashdump.spotify.com:443/ --annotation=platform=win32 --annotation=product=spotify --annotation=version=1.1.4.197 --initial-client-data=0x5a4,0x5a0,0x5a8,0x59c,0x5ac,0x6edcbf60,0x6edcbf70,0x6edcbf7c`},
					params.Exe:             {Name: params.Exe, Type: params.UnicodeString, Value: `C:\Users\admin\AppData\Roaming\Spotify\Spotify.exe --parent`},
					params.UserSID:         {Name: params.UserSID, Type: params.WbemSID, Value: []byte{224, 8, 226, 31, 15, 167, 255, 255, 0, 0, 0, 0, 15, 167, 255, 255, 1, 1, 0, 0, 0, 0, 0, 5, 18, 0, 0, 0}},
					params.StartTime:       {Name: params.StartTime, Type: params.Time, Value: time.Now()},
					params.SessionID:       {Name: params.SessionID, Type: params.Uint32, Value: uint32(1)},
					params.ProcessFlags:    {Name: params.ProcessFlags, Type: params.Flags, Value: uint32(0x00000010)},
				},
			},
			&pstypes.PS{
				PID:         uint32(os.Getpid()),
				Ppid:        uint32(os.Getppid()),
				Name:        "spotify.exe",
				Cmdline:     `C:\Users\admin\AppData\Roaming\Spotify\Spotify.exe --type=crashpad-handler /prefetch:7 --max-uploads=5 --max-db-size=20 --max-db-age=5 --monitor-self-annotation=ptype=crashpad-handler "--metrics-dir=C:\Users\admin\AppData\Local\Spotify\User Data" --url=https://crashdump.spotify.com:443/ --annotation=platform=win32 --annotation=product=spotify --annotation=version=1.1.4.197 --initial-client-data=0x5a4,0x5a0,0x5a8,0x59c,0x5ac,0x6edcbf60,0x6edcbf70,0x6edcbf7c`,
				Exe:         `C:\Users\admin\AppData\Roaming\Spotify\Spotify.exe --parent`,
				Cwd:         "C:\\fibratus\\pkg\\ps",
				SessionID:   1,
				SID:         "S-1-5-18",
				Username:    "SYSTEM",
				Domain:      "NT AUTHORITY",
				IsWOW64:     true,
				IsPackaged:  true,
				IsProtected: false,
			},
		},
		{"write state from spawned process with parent",
			&event.Event{
				Type: event.CreateProcess,
				Params: event.Params{
					params.ProcessID:       {Name: params.ProcessID, Type: params.PID, Value: uint32(os.Getppid())},
					params.ProcessParentID: {Name: params.ProcessParentID, Type: params.PID, Value: uint32(os.Getpid())},
					params.ProcessName:     {Name: params.ProcessName, Type: params.UnicodeString, Value: "spotify.exe"},
					params.Cmdline:         {Name: params.Cmdline, Type: params.UnicodeString, Value: `C:\Users\admin\AppData\Roaming\Spotify\Spotify.exe --type=crashpad-handler /prefetch:7 --max-uploads=5 --max-db-size=20 --max-db-age=5 --monitor-self-annotation=ptype=crashpad-handler "--metrics-dir=C:\Users\admin\AppData\Local\Spotify\User Data" --url=https://crashdump.spotify.com:443/ --annotation=platform=win32 --annotation=product=spotify --annotation=version=1.1.4.197 --initial-client-data=0x5a4,0x5a0,0x5a8,0x59c,0x5ac,0x6edcbf60,0x6edcbf70,0x6edcbf7c`},
					params.Exe:             {Name: params.Exe, Type: params.UnicodeString, Value: `C:\Users\admin\AppData\Roaming\Spotify\Spotify.exe --parent`},
					params.UserSID:         {Name: params.UserSID, Type: params.WbemSID, Value: []byte{224, 8, 226, 31, 15, 167, 255, 255, 0, 0, 0, 0, 15, 167, 255, 255, 1, 1, 0, 0, 0, 0, 0, 5, 18, 0, 0, 0}},
					params.StartTime:       {Name: params.StartTime, Type: params.Time, Value: time.Now()},
					params.SessionID:       {Name: params.SessionID, Type: params.Uint32, Value: uint32(1)},
					params.ProcessFlags:    {Name: params.ProcessFlags, Type: params.Flags, Value: uint32(0x00000010)},
				},
				PID: uint32(os.Getpid()),
			},
			&pstypes.PS{
				PID:     uint32(os.Getppid()),
				Ppid:    uint32(os.Getpid()),
				Name:    "spotify.exe",
				Cmdline: `C:\Users\admin\AppData\Roaming\Spotify\Spotify.exe --type=crashpad-handler /prefetch:7 --max-uploads=5 --max-db-size=20 --max-db-age=5 --monitor-self-annotation=ptype=crashpad-handler "--metrics-dir=C:\Users\admin\AppData\Local\Spotify\User Data" --url=https://crashdump.spotify.com:443/ --annotation=platform=win32 --annotation=product=spotify --annotation=version=1.1.4.197 --initial-client-data=0x5a4,0x5a0,0x5a8,0x59c,0x5ac,0x6edcbf60,0x6edcbf70,0x6edcbf7c`,
				Exe:     `C:\Users\admin\AppData\Roaming\Spotify\Spotify.exe --parent`,
				Cwd:     "C:\\fibratus\\fibratus",
				Parent: &pstypes.PS{
					PID: uint32(os.Getpid()),
				},
				SessionID:   1,
				SID:         "S-1-5-18",
				Username:    "SYSTEM",
				Domain:      "NT AUTHORITY",
				IsWOW64:     true,
				IsPackaged:  true,
				IsProtected: false,
			},
		},
		{"write state from rundown event",
			&event.Event{
				Type: event.ProcessRundown,
				Params: event.Params{
					params.ProcessID:       {Name: params.ProcessID, Type: params.PID, Value: uint32(os.Getpid())},
					params.ProcessParentID: {Name: params.ProcessParentID, Type: params.PID, Value: uint32(8390)},
					params.ProcessName:     {Name: params.ProcessName, Type: params.UnicodeString, Value: "spotify.exe"},
					params.Cmdline:         {Name: params.Cmdline, Type: params.UnicodeString, Value: `C:\Users\admin\AppData\Roaming\Spotify\Spotify.exe --type=crashpad-handler /prefetch:7 --max-uploads=5 --max-db-size=20 --max-db-age=5 --monitor-self-annotation=ptype=crashpad-handler "--metrics-dir=C:\Users\admin\AppData\Local\Spotify\User Data" --url=https://crashdump.spotify.com:443/ --annotation=platform=win32 --annotation=product=spotify --annotation=version=1.1.4.197 --initial-client-data=0x5a4,0x5a0,0x5a8,0x59c,0x5ac,0x6edcbf60,0x6edcbf70,0x6edcbf7c`},
					params.Exe:             {Name: params.Exe, Type: params.UnicodeString, Value: `C:\Users\admin\AppData\Roaming\Spotify\Spotify.exe --parent`},
					params.UserSID:         {Name: params.UserSID, Type: params.WbemSID, Value: []byte{224, 8, 226, 31, 15, 167, 255, 255, 0, 0, 0, 0, 15, 167, 255, 255, 1, 1, 0, 0, 0, 0, 0, 5, 18, 0, 0, 0}},
					params.StartTime:       {Name: params.StartTime, Type: params.Time, Value: time.Now()},
					params.SessionID:       {Name: params.SessionID, Type: params.Uint32, Value: uint32(1)},
					params.ProcessFlags:    {Name: params.ProcessFlags, Type: params.Flags, Value: uint32(0x00000010)},
				},
			},
			&pstypes.PS{
				PID:         uint32(os.Getpid()),
				Ppid:        8390,
				Name:        "spotify.exe",
				Cmdline:     `C:\Users\admin\AppData\Roaming\Spotify\Spotify.exe --type=crashpad-handler /prefetch:7 --max-uploads=5 --max-db-size=20 --max-db-age=5 --monitor-self-annotation=ptype=crashpad-handler "--metrics-dir=C:\Users\admin\AppData\Local\Spotify\User Data" --url=https://crashdump.spotify.com:443/ --annotation=platform=win32 --annotation=product=spotify --annotation=version=1.1.4.197 --initial-client-data=0x5a4,0x5a0,0x5a8,0x59c,0x5ac,0x6edcbf60,0x6edcbf70,0x6edcbf7c`,
				Exe:         `C:\Users\admin\AppData\Roaming\Spotify\Spotify.exe --parent`,
				Cwd:         "C:\\fibratus\\pkg\\ps",
				SessionID:   1,
				SID:         "S-1-5-18",
				Username:    "SYSTEM",
				Domain:      "NT AUTHORITY",
				IsWOW64:     true,
				IsPackaged:  true,
				IsProtected: false,
			},
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			evt := tt.evt
			ps := tt.want

			require.NoError(t, psnap.Write(evt))
			require.True(t, psnap.Size() > 0)

			ok, proc := psnap.Find(evt.Params.MustGetPid())
			require.True(t, ok)
			require.NotNil(t, proc)
			assert.Equal(t, ps.PID, proc.PID)
			assert.Equal(t, ps.Ppid, proc.Ppid)
			assert.Equal(t, ps.Name, proc.Name)
			assert.Equal(t, ps.Cmdline, proc.Cmdline)
			assert.Equal(t, ps.Exe, proc.Exe)
			assert.Equal(t, ps.SessionID, proc.SessionID)
			assert.Equal(t, ps.SID, proc.SID)
			assert.Equal(t, ps.Username, proc.Username)
			assert.Equal(t, ps.Domain, proc.Domain)
			assert.Equal(t, filepath.Base(ps.Cwd), filepath.Base(proc.Cwd))
			assert.Len(t, proc.Args, 13)
			assert.True(t, len(proc.Envs) > 0)

			assert.True(t, (ps.Parent != nil) == (proc.Parent != nil))
			if found, _ := psnap.Find(evt.PID); found {
				assert.NotNil(t, evt.PS)
				assert.Equal(t, ps.PID, evt.PS.PID)
			}
		})
	}
}

func TestWriteInternalEventsEnrichment(t *testing.T) {
	hsnap := new(handle.SnapshotterMock)
	hsnap.On("FindHandles", mock.Anything).Return([]htypes.Handle{}, nil)

	var tests = []struct {
		name       string
		evts       []*event.Event
		psnap      Snapshotter
		assertions func(t *testing.T, psnap Snapshotter)
	}{
		{"write internal event without previous state",
			[]*event.Event{
				{
					Type: event.CreateProcessInternal,
					Params: event.Params{
						params.ProcessID:                  {Name: params.ProcessID, Type: params.PID, Value: uint32(1024)},
						params.ProcessParentID:            {Name: params.ProcessParentID, Type: params.PID, Value: uint32(444)},
						params.Exe:                        {Name: params.Exe, Type: params.UnicodeString, Value: `C:\Windows\System32\svchost.exe`},
						params.ProcessTokenIntegrityLevel: {Name: params.ProcessTokenIntegrityLevel, Type: params.AnsiString, Value: "HIGH"},
						params.ProcessTokenIsElevated:     {Name: params.ProcessTokenIsElevated, Type: params.Bool, Value: true},
						params.ProcessTokenElevationType:  {Name: params.ProcessTokenElevationType, Type: params.AnsiString, Value: "FULL"},
					},
				},
			},
			NewSnapshotter(hsnap, &config.Config{}),
			func(t *testing.T, psnap Snapshotter) {
				ok, proc := psnap.Find(1024)
				assert.True(t, ok)
				assert.Equal(t, "HIGH", proc.TokenIntegrityLevel)
				assert.Equal(t, "FULL", proc.TokenElevationType)
				assert.Equal(t, true, proc.IsTokenElevated)
				assert.Equal(t, `C:\Windows\System32\svchost.exe`, proc.Exe)
			},
		},
		{"enrich existing system provider proc state with internal event",
			[]*event.Event{
				{
					Type: event.CreateProcess,
					Params: event.Params{
						params.ProcessID:       {Name: params.ProcessID, Type: params.PID, Value: uint32(1024)},
						params.ProcessParentID: {Name: params.ProcessParentID, Type: params.PID, Value: uint32(444)},
						params.Exe:             {Name: params.Exe, Type: params.UnicodeString, Value: `svchost.exe`},
						params.ProcessName:     {Name: params.ProcessName, Type: params.UnicodeString, Value: `svchost.exe`},
						params.Cmdline:         {Name: params.Cmdline, Type: params.UnicodeString, Value: `svchost.exe -k LocalSystemNetworkRestricted -p -s NcbService`},
						params.UserSID:         {Name: params.UserSID, Type: params.WbemSID, Value: []byte{224, 8, 226, 31, 15, 167, 255, 255, 0, 0, 0, 0, 15, 167, 255, 255, 1, 1, 0, 0, 0, 0, 0, 5, 18, 0, 0, 0}},
						params.SessionID:       {Name: params.SessionID, Type: params.Uint32, Value: uint32(1)},
						params.ProcessFlags:    {Name: params.ProcessFlags, Type: params.Flags, Value: uint32(0x00000010)},
					},
				},
				{
					Type: event.CreateProcessInternal,
					Params: event.Params{
						params.ProcessID:                  {Name: params.ProcessID, Type: params.PID, Value: uint32(1024)},
						params.ProcessParentID:            {Name: params.ProcessParentID, Type: params.PID, Value: uint32(444)},
						params.Exe:                        {Name: params.Exe, Type: params.UnicodeString, Value: `C:\Windows\System32\svchost.exe`},
						params.ProcessTokenIntegrityLevel: {Name: params.ProcessTokenIntegrityLevel, Type: params.AnsiString, Value: "HIGH"},
						params.ProcessTokenIsElevated:     {Name: params.ProcessTokenIsElevated, Type: params.Bool, Value: true},
						params.ProcessTokenElevationType:  {Name: params.ProcessTokenElevationType, Type: params.AnsiString, Value: "FULL"},
					},
				},
			},
			NewSnapshotter(hsnap, &config.Config{}),
			func(t *testing.T, psnap Snapshotter) {
				ok, proc := psnap.Find(1024)
				assert.True(t, ok)
				assert.Equal(t, "HIGH", proc.TokenIntegrityLevel)
				assert.Equal(t, "FULL", proc.TokenElevationType)
				assert.Equal(t, true, proc.IsTokenElevated)
				assert.Equal(t, `C:\Windows\System32\svchost.exe`, proc.Exe)
				assert.Equal(t, "svchost.exe -k LocalSystemNetworkRestricted -p -s NcbService", proc.Cmdline)
				assert.Equal(t, uint32(1), proc.SessionID)
			},
		},
		{"enrich newly arrived system provider proc with previous internal event state",
			[]*event.Event{
				{
					Type: event.CreateProcessInternal,
					Params: event.Params{
						params.ProcessID:                  {Name: params.ProcessID, Type: params.PID, Value: uint32(1024)},
						params.ProcessParentID:            {Name: params.ProcessParentID, Type: params.PID, Value: uint32(444)},
						params.Exe:                        {Name: params.Exe, Type: params.UnicodeString, Value: `C:\Windows\System32\svchost.exe`},
						params.ProcessName:                {Name: params.ProcessName, Type: params.UnicodeString, Value: `svchost.exe`},
						params.ProcessTokenIntegrityLevel: {Name: params.ProcessTokenIntegrityLevel, Type: params.AnsiString, Value: "HIGH"},
						params.ProcessTokenIsElevated:     {Name: params.ProcessTokenIsElevated, Type: params.Bool, Value: true},
						params.ProcessTokenElevationType:  {Name: params.ProcessTokenElevationType, Type: params.AnsiString, Value: "FULL"},
					},
				},
				{
					Type: event.CreateProcess,
					Params: event.Params{
						params.ProcessID:       {Name: params.ProcessID, Type: params.PID, Value: uint32(1024)},
						params.ProcessParentID: {Name: params.ProcessParentID, Type: params.PID, Value: uint32(444)},
						params.ProcessName:     {Name: params.ProcessName, Type: params.UnicodeString, Value: `svchost.exe`},
						params.Exe:             {Name: params.Exe, Type: params.UnicodeString, Value: `svchost.exe`},
						params.Cmdline:         {Name: params.Cmdline, Type: params.UnicodeString, Value: `svchost.exe -k LocalSystemNetworkRestricted -p -s NcbService`},
						params.UserSID:         {Name: params.UserSID, Type: params.WbemSID, Value: []byte{224, 8, 226, 31, 15, 167, 255, 255, 0, 0, 0, 0, 15, 167, 255, 255, 1, 1, 0, 0, 0, 0, 0, 5, 18, 0, 0, 0}},
						params.SessionID:       {Name: params.SessionID, Type: params.Uint32, Value: uint32(1)},
						params.ProcessFlags:    {Name: params.ProcessFlags, Type: params.Flags, Value: uint32(0x00000010)},
					},
				},
			},
			NewSnapshotter(hsnap, &config.Config{}),
			func(t *testing.T, psnap Snapshotter) {
				ok, proc := psnap.Find(1024)
				assert.True(t, ok)
				assert.Equal(t, "HIGH", proc.TokenIntegrityLevel)
				assert.Equal(t, "FULL", proc.TokenElevationType)
				assert.Equal(t, true, proc.IsTokenElevated)
				assert.Equal(t, `C:\Windows\System32\svchost.exe`, proc.Exe)
				assert.Equal(t, "svchost.exe -k LocalSystemNetworkRestricted -p -s NcbService", proc.Cmdline)
				assert.Equal(t, uint32(1), proc.SessionID)
			},
		},
		{"consult process token integrity level from OS",
			[]*event.Event{
				{
					Type: event.CreateProcess,
					Params: event.Params{
						params.ProcessID:       {Name: params.ProcessID, Type: params.PID, Value: uint32(os.Getpid())},
						params.ProcessParentID: {Name: params.ProcessParentID, Type: params.PID, Value: uint32(444)},
						params.Exe:             {Name: params.Exe, Type: params.UnicodeString, Value: `svchost.exe`},
						params.ProcessName:     {Name: params.ProcessName, Type: params.UnicodeString, Value: `svchost.exe`},
						params.Cmdline:         {Name: params.Cmdline, Type: params.UnicodeString, Value: `svchost.exe -k LocalSystemNetworkRestricted -p -s NcbService`},
						params.UserSID:         {Name: params.UserSID, Type: params.WbemSID, Value: []byte{224, 8, 226, 31, 15, 167, 255, 255, 0, 0, 0, 0, 15, 167, 255, 255, 1, 1, 0, 0, 0, 0, 0, 5, 18, 0, 0, 0}},
						params.SessionID:       {Name: params.SessionID, Type: params.Uint32, Value: uint32(1)},
						params.ProcessFlags:    {Name: params.ProcessFlags, Type: params.Flags, Value: uint32(0x00000010)},
					},
				},
			},
			NewSnapshotter(hsnap, &config.Config{}),
			func(t *testing.T, psnap Snapshotter) {
				ok, proc := psnap.Find(uint32(os.Getpid()))
				assert.True(t, ok)
				assert.Equal(t, "HIGH", proc.TokenIntegrityLevel)
				assert.Equal(t, true, proc.IsTokenElevated)
			},
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			for _, evt := range tt.evts {
				require.NoError(t, tt.psnap.Write(evt))
			}
			if tt.assertions != nil {
				tt.assertions(t, tt.psnap)
			}
			defer tt.psnap.Close()
		})
	}
}

func TestRemove(t *testing.T) {
	hsnap := new(handle.SnapshotterMock)
	hsnap.On("FindHandles", mock.Anything).Return([]htypes.Handle{}, nil)
	psnap := NewSnapshotter(hsnap, &config.Config{})
	defer psnap.Close()

	var tests = []struct {
		name string
		evt  *event.Event
		want bool
	}{
		{"write and remove process state from snapshotter",
			&event.Event{
				Type: event.CreateProcess,
				Params: event.Params{
					params.ProcessID:       {Name: params.ProcessID, Type: params.PID, Value: uint32(os.Getpid())},
					params.ProcessParentID: {Name: params.ProcessParentID, Type: params.PID, Value: uint32(os.Getppid())},
					params.ProcessName:     {Name: params.ProcessName, Type: params.UnicodeString, Value: "spotify.exe"},
					params.Cmdline:         {Name: params.Cmdline, Type: params.UnicodeString, Value: `C:\Users\admin\AppData\Roaming\Spotify\Spotify.exe --type=crashpad-handler /prefetch:7 --max-uploads=5 --max-db-size=20 --max-db-age=5 --monitor-self-annotation=ptype=crashpad-handler "--metrics-dir=C:\Users\admin\AppData\Local\Spotify\User Data" --url=https://crashdump.spotify.com:443/ --annotation=platform=win32 --annotation=product=spotify --annotation=version=1.1.4.197 --initial-client-data=0x5a4,0x5a0,0x5a8,0x59c,0x5ac,0x6edcbf60,0x6edcbf70,0x6edcbf7c`},
					params.Exe:             {Name: params.Exe, Type: params.UnicodeString, Value: `C:\Users\admin\AppData\Roaming\Spotify\Spotify.exe --parent`},
					params.UserSID:         {Name: params.UserSID, Type: params.WbemSID, Value: []byte{224, 8, 226, 31, 15, 167, 255, 255, 0, 0, 0, 0, 15, 167, 255, 255, 1, 1, 0, 0, 0, 0, 0, 5, 18, 0, 0, 0}},
					params.StartTime:       {Name: params.StartTime, Type: params.Time, Value: time.Now()},
					params.SessionID:       {Name: params.SessionID, Type: params.Uint32, Value: uint32(1)},
					params.ProcessFlags:    {Name: params.ProcessFlags, Type: params.Flags, Value: uint32(0x00000010)},
				},
			},
			false,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			evt := tt.evt
			exists := tt.want

			require.NoError(t, psnap.Write(evt))
			require.True(t, psnap.Size() > 0)
			require.NoError(t, psnap.Remove(evt))
			// process in dirty map, wait 6 seconds before lookup
			time.Sleep(time.Second * 6)
			ok, _ := psnap.Find(evt.Params.MustGetPid())
			assert.Equal(t, exists, ok)
		})
	}
}

func TestAddThread(t *testing.T) {
	hsnap := new(handle.SnapshotterMock)
	hsnap.On("FindHandles", mock.Anything).Return([]htypes.Handle{}, nil)
	psnap := NewSnapshotter(hsnap, &config.Config{})
	defer psnap.Close()

	evt := &event.Event{
		Type: event.CreateProcess,
		Params: event.Params{
			params.ProcessID:       {Name: params.ProcessID, Type: params.PID, Value: uint32(os.Getpid())},
			params.ProcessParentID: {Name: params.ProcessParentID, Type: params.PID, Value: uint32(os.Getppid())},
			params.ProcessName:     {Name: params.ProcessName, Type: params.UnicodeString, Value: "spotify.exe"},
			params.Cmdline:         {Name: params.Cmdline, Type: params.UnicodeString, Value: `C:\Users\admin\AppData\Roaming\Spotify\Spotify.exe --type=crashpad-handler /prefetch:7 --max-uploads=5 --max-db-size=20 --max-db-age=5 --monitor-self-annotation=ptype=crashpad-handler "--metrics-dir=C:\Users\admin\AppData\Local\Spotify\User Data" --url=https://crashdump.spotify.com:443/ --annotation=platform=win32 --annotation=product=spotify --annotation=version=1.1.4.197 --initial-client-data=0x5a4,0x5a0,0x5a8,0x59c,0x5ac,0x6edcbf60,0x6edcbf70,0x6edcbf7c`},
			params.Exe:             {Name: params.Exe, Type: params.UnicodeString, Value: `C:\Users\admin\AppData\Roaming\Spotify\Spotify.exe --parent`},
			params.UserSID:         {Name: params.UserSID, Type: params.WbemSID, Value: []byte{224, 8, 226, 31, 15, 167, 255, 255, 0, 0, 0, 0, 15, 167, 255, 255, 1, 1, 0, 0, 0, 0, 0, 5, 18, 0, 0, 0}},
			params.StartTime:       {Name: params.StartTime, Type: params.Time, Value: time.Now()},
			params.SessionID:       {Name: params.SessionID, Type: params.Uint32, Value: uint32(1)},
			params.ProcessFlags:    {Name: params.ProcessFlags, Type: params.Flags, Value: uint32(0x00000010)},
		},
	}
	require.NoError(t, psnap.Write(evt))

	var tests = []struct {
		name string
		evt  *event.Event
		want bool
	}{
		{"add thread to existing process",
			&event.Event{
				Type: event.CreateThread,
				Params: event.Params{
					params.ProcessID:    {Name: params.ProcessID, Type: params.PID, Value: uint32(os.Getpid())},
					params.ThreadID:     {Name: params.ThreadID, Type: params.TID, Value: uint32(3453)},
					params.BasePrio:     {Name: params.BasePrio, Type: params.Uint8, Value: uint8(13)},
					params.StartAddress: {Name: params.StartAddress, Type: params.Address, Value: uint64(140729524944768)},
					params.IOPrio:       {Name: params.IOPrio, Type: params.Uint8, Value: uint8(2)},
					params.KstackBase:   {Name: params.KstackBase, Type: params.Address, Value: uint64(18446677035730165760)},
					params.KstackLimit:  {Name: params.KstackLimit, Type: params.Address, Value: uint64(18446677035730137088)},
					params.PagePrio:     {Name: params.PagePrio, Type: params.Uint8, Value: uint8(5)},
					params.UstackBase:   {Name: params.UstackBase, Type: params.Address, Value: uint64(86376448)},
					params.UstackLimit:  {Name: params.UstackLimit, Type: params.Address, Value: uint64(86372352)},
				},
			},
			true,
		},
		{"add thread to absent process",
			&event.Event{
				Type: event.CreateThread,
				Params: event.Params{
					params.ProcessID:    {Name: params.ProcessID, Type: params.PID, Value: uint32(os.Getpid() + 1)},
					params.ThreadID:     {Name: params.ThreadID, Type: params.TID, Value: uint32(3453)},
					params.BasePrio:     {Name: params.BasePrio, Type: params.Uint8, Value: uint8(13)},
					params.StartAddress: {Name: params.StartAddress, Type: params.Address, Value: uint64(140729524944768)},
					params.IOPrio:       {Name: params.IOPrio, Type: params.Uint8, Value: uint8(2)},
					params.KstackBase:   {Name: params.KstackBase, Type: params.Address, Value: uint64(18446677035730165760)},
					params.KstackLimit:  {Name: params.KstackLimit, Type: params.Address, Value: uint64(18446677035730137088)},
					params.PagePrio:     {Name: params.PagePrio, Type: params.Uint8, Value: uint8(5)},
					params.UstackBase:   {Name: params.UstackBase, Type: params.Address, Value: uint64(86376448)},
					params.UstackLimit:  {Name: params.UstackLimit, Type: params.Address, Value: uint64(86372352)},
				},
			},
			false,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			evt := tt.evt
			exists := tt.want

			require.NoError(t, psnap.AddThread(evt))
			ok, proc := psnap.Find(evt.Params.MustGetPid())
			require.Equal(t, exists, ok)
			if ok {
				assert.Contains(t, proc.Threads, evt.Params.MustGetTid())
				assert.Equal(t, va.Address(140729524944768), proc.Threads[evt.Params.MustGetTid()].StartAddress)
			}
		})
	}
}

func TestRemoveThread(t *testing.T) {
	hsnap := new(handle.SnapshotterMock)
	psnap := NewSnapshotter(hsnap, &config.Config{})
	hsnap.On("FindHandles", mock.Anything).Return([]htypes.Handle{}, nil)
	defer psnap.Close()

	pevt := &event.Event{
		Type: event.CreateProcess,
		Params: event.Params{
			params.ProcessID:       {Name: params.ProcessID, Type: params.PID, Value: uint32(os.Getpid())},
			params.ProcessParentID: {Name: params.ProcessParentID, Type: params.PID, Value: uint32(os.Getppid())},
			params.ProcessName:     {Name: params.ProcessName, Type: params.UnicodeString, Value: "spotify.exe"},
			params.Cmdline:         {Name: params.Cmdline, Type: params.UnicodeString, Value: `C:\Users\admin\AppData\Roaming\Spotify\Spotify.exe --type=crashpad-handler /prefetch:7 --max-uploads=5 --max-db-size=20 --max-db-age=5 --monitor-self-annotation=ptype=crashpad-handler "--metrics-dir=C:\Users\admin\AppData\Local\Spotify\User Data" --url=https://crashdump.spotify.com:443/ --annotation=platform=win32 --annotation=product=spotify --annotation=version=1.1.4.197 --initial-client-data=0x5a4,0x5a0,0x5a8,0x59c,0x5ac,0x6edcbf60,0x6edcbf70,0x6edcbf7c`},
			params.Exe:             {Name: params.Exe, Type: params.UnicodeString, Value: `C:\Users\admin\AppData\Roaming\Spotify\Spotify.exe --parent`},
			params.UserSID:         {Name: params.UserSID, Type: params.WbemSID, Value: []byte{224, 8, 226, 31, 15, 167, 255, 255, 0, 0, 0, 0, 15, 167, 255, 255, 1, 1, 0, 0, 0, 0, 0, 5, 18, 0, 0, 0}},
			params.StartTime:       {Name: params.StartTime, Type: params.Time, Value: time.Now()},
			params.SessionID:       {Name: params.SessionID, Type: params.Uint32, Value: uint32(1)},
			params.ProcessFlags:    {Name: params.ProcessFlags, Type: params.Flags, Value: uint32(0x00000010)},
		},
	}
	require.NoError(t, psnap.Write(pevt))

	tevt := &event.Event{
		Type: event.CreateThread,
		Params: event.Params{
			params.ProcessID:    {Name: params.ProcessID, Type: params.PID, Value: uint32(os.Getpid())},
			params.ThreadID:     {Name: params.ThreadID, Type: params.TID, Value: uint32(3453)},
			params.BasePrio:     {Name: params.BasePrio, Type: params.Uint8, Value: uint8(13)},
			params.StartAddress: {Name: params.StartAddress, Type: params.Address, Value: uint64(140729524944768)},
			params.IOPrio:       {Name: params.IOPrio, Type: params.Uint8, Value: uint8(2)},
			params.KstackBase:   {Name: params.KstackBase, Type: params.Address, Value: uint64(18446677035730165760)},
			params.KstackLimit:  {Name: params.KstackLimit, Type: params.Address, Value: uint64(18446677035730137088)},
			params.PagePrio:     {Name: params.PagePrio, Type: params.Uint8, Value: uint8(5)},
			params.UstackBase:   {Name: params.UstackBase, Type: params.Address, Value: uint64(86376448)},
			params.UstackLimit:  {Name: params.UstackLimit, Type: params.Address, Value: uint64(86372352)},
		},
	}

	require.NoError(t, psnap.AddThread(tevt))

	ok, ps := psnap.Find(uint32(os.Getpid()))
	require.True(t, ok)
	require.NotNil(t, ps)
	require.Len(t, ps.Threads, 1)
	require.NoError(t, psnap.RemoveThread(uint32(os.Getpid()), 3453))
	require.Len(t, ps.Threads, 0)
}

func TestAddModule(t *testing.T) {
	hsnap := new(handle.SnapshotterMock)
	hsnap.On("FindHandles", mock.Anything).Return([]htypes.Handle{}, nil)
	psnap := NewSnapshotter(hsnap, &config.Config{})
	defer psnap.Close()

	evt := &event.Event{
		Type: event.CreateProcess,
		Params: event.Params{
			params.ProcessID:       {Name: params.ProcessID, Type: params.PID, Value: uint32(os.Getpid())},
			params.ProcessParentID: {Name: params.ProcessParentID, Type: params.PID, Value: uint32(os.Getppid())},
			params.ProcessName:     {Name: params.ProcessName, Type: params.UnicodeString, Value: "spotify.exe"},
			params.Cmdline:         {Name: params.Cmdline, Type: params.UnicodeString, Value: `C:\Users\admin\AppData\Roaming\Spotify\Spotify.exe --type=crashpad-handler /prefetch:7 --max-uploads=5 --max-db-size=20 --max-db-age=5 --monitor-self-annotation=ptype=crashpad-handler "--metrics-dir=C:\Users\admin\AppData\Local\Spotify\User Data" --url=https://crashdump.spotify.com:443/ --annotation=platform=win32 --annotation=product=spotify --annotation=version=1.1.4.197 --initial-client-data=0x5a4,0x5a0,0x5a8,0x59c,0x5ac,0x6edcbf60,0x6edcbf70,0x6edcbf7c`},
			params.Exe:             {Name: params.Exe, Type: params.UnicodeString, Value: `Spotify.exe`},
			params.UserSID:         {Name: params.UserSID, Type: params.WbemSID, Value: []byte{224, 8, 226, 31, 15, 167, 255, 255, 0, 0, 0, 0, 15, 167, 255, 255, 1, 1, 0, 0, 0, 0, 0, 5, 18, 0, 0, 0}},
			params.StartTime:       {Name: params.StartTime, Type: params.Time, Value: time.Now()},
			params.SessionID:       {Name: params.SessionID, Type: params.Uint32, Value: uint32(1)},
			params.ProcessFlags:    {Name: params.ProcessFlags, Type: params.Flags, Value: uint32(0x00000010)},
		},
	}
	require.NoError(t, psnap.Write(evt))

	var tests = []struct {
		name string
		evt  *event.Event
		want bool
	}{
		{"add module to existing process",
			&event.Event{
				Type: event.LoadImage,
				Params: event.Params{
					params.ProcessID: {Name: params.ProcessID, Type: params.PID, Value: uint32(os.Getpid())},
					params.ImagePath: {Name: params.ImagePath, Type: params.UnicodeString, Value: "C:\\Users\\admin\\AppData\\Roaming\\Spotify\\Spotify.exe"},
				},
			},
			true,
		},
		{"add module to absent process",
			&event.Event{
				Type: event.LoadImage,
				Params: event.Params{
					params.ProcessID: {Name: params.ProcessID, Type: params.PID, Value: uint32(os.Getpid() + 1)},
					params.ImagePath: {Name: params.ImagePath, Type: params.UnicodeString, Value: "C:\\Windows\\System32\\notepad.exe"},
				},
			},
			false,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			evt := tt.evt
			exists := tt.want

			require.NoError(t, psnap.AddModule(evt))
			ok, proc := psnap.Find(evt.Params.MustGetPid())
			require.Equal(t, exists, ok)
			if ok {
				require.NotNil(t, proc.FindModule(evt.GetParamAsString(params.ImagePath)))
				assert.Equal(t, "C:\\Users\\admin\\AppData\\Roaming\\Spotify\\Spotify.exe", proc.Exe)
			}
		})
	}
}

func TestRemoveModule(t *testing.T) {
	hsnap := new(handle.SnapshotterMock)
	hsnap.On("FindHandles", mock.Anything).Return([]htypes.Handle{}, nil)
	psnap := NewSnapshotter(hsnap, &config.Config{})
	defer psnap.Close()

	pevt := &event.Event{
		Type: event.CreateProcess,
		Params: event.Params{
			params.ProcessID:       {Name: params.ProcessID, Type: params.PID, Value: uint32(os.Getpid())},
			params.ProcessParentID: {Name: params.ProcessParentID, Type: params.PID, Value: uint32(os.Getppid())},
			params.ProcessName:     {Name: params.ProcessName, Type: params.UnicodeString, Value: "spotify.exe"},
			params.Cmdline:         {Name: params.Cmdline, Type: params.UnicodeString, Value: `C:\Users\admin\AppData\Roaming\Spotify\Spotify.exe --type=crashpad-handler /prefetch:7 --max-uploads=5 --max-db-size=20 --max-db-age=5 --monitor-self-annotation=ptype=crashpad-handler "--metrics-dir=C:\Users\admin\AppData\Local\Spotify\User Data" --url=https://crashdump.spotify.com:443/ --annotation=platform=win32 --annotation=product=spotify --annotation=version=1.1.4.197 --initial-client-data=0x5a4,0x5a0,0x5a8,0x59c,0x5ac,0x6edcbf60,0x6edcbf70,0x6edcbf7c`},
			params.Exe:             {Name: params.Exe, Type: params.UnicodeString, Value: `C:\Users\admin\AppData\Roaming\Spotify\Spotify.exe --parent`},
			params.UserSID:         {Name: params.UserSID, Type: params.WbemSID, Value: []byte{224, 8, 226, 31, 15, 167, 255, 255, 0, 0, 0, 0, 15, 167, 255, 255, 1, 1, 0, 0, 0, 0, 0, 5, 18, 0, 0, 0}},
			params.StartTime:       {Name: params.StartTime, Type: params.Time, Value: time.Now()},
			params.SessionID:       {Name: params.SessionID, Type: params.Uint32, Value: uint32(1)},
			params.ProcessFlags:    {Name: params.ProcessFlags, Type: params.Flags, Value: uint32(0x00000010)},
		},
	}
	require.NoError(t, psnap.Write(pevt))

	mevt := &event.Event{
		Type: event.LoadImage,
		Params: event.Params{
			params.ProcessID: {Name: params.ProcessID, Type: params.PID, Value: uint32(os.Getpid())},
			params.ImagePath: {Name: params.ImagePath, Type: params.UnicodeString, Value: "C:\\Windows\\System32\\notepad.exe"},
			params.ImageBase: {Name: params.ImageBase, Type: params.Address, Value: uint64(0xffff7656)},
		},
	}

	require.NoError(t, psnap.AddModule(mevt))

	ok, ps := psnap.Find(uint32(os.Getpid()))
	require.True(t, ok)
	require.NotNil(t, ps)
	require.Len(t, ps.Modules, 1)
	require.NoError(t, psnap.RemoveModule(uint32(os.Getpid()), va.Address(0xffff7656)))
	require.Len(t, ps.Modules, 0)
}

func TestOverrideProcExecutable(t *testing.T) {
	hsnap := new(handle.SnapshotterMock)
	hsnap.On("FindHandles", mock.Anything).Return([]htypes.Handle{}, nil)
	psnap := NewSnapshotter(hsnap, &config.Config{})
	defer psnap.Close()

	evt := &event.Event{
		Type: event.CreateProcess,
		Params: event.Params{
			params.ProcessID:       {Name: params.ProcessID, Type: params.PID, Value: uint32(os.Getpid())},
			params.ProcessParentID: {Name: params.ProcessParentID, Type: params.PID, Value: uint32(os.Getppid())},
			params.ProcessName:     {Name: params.ProcessName, Type: params.UnicodeString, Value: "spotify.exe"},
			params.Cmdline:         {Name: params.Cmdline, Type: params.UnicodeString, Value: `Spotify.exe --type=crashpad-handler /prefetch:7 --max-uploads=5 --max-db-size=20 --max-db-age=5 --monitor-self-annotation=ptype=crashpad-handler "--metrics-dir=C:\Users\admin\AppData\Local\Spotify\User Data" --url=https://crashdump.spotify.com:443/ --annotation=platform=win32 --annotation=product=spotify --annotation=version=1.1.4.197 --initial-client-data=0x5a4,0x5a0,0x5a8,0x59c,0x5ac,0x6edcbf60,0x6edcbf70,0x6edcbf7c`},
			params.Exe:             {Name: params.Exe, Type: params.UnicodeString, Value: `Spotify.exe`},
			params.UserSID:         {Name: params.UserSID, Type: params.WbemSID, Value: []byte{224, 8, 226, 31, 15, 167, 255, 255, 0, 0, 0, 0, 15, 167, 255, 255, 1, 1, 0, 0, 0, 0, 0, 5, 18, 0, 0, 0}},
			params.StartTime:       {Name: params.StartTime, Type: params.Time, Value: time.Now()},
			params.SessionID:       {Name: params.SessionID, Type: params.Uint32, Value: uint32(1)},
			params.ProcessFlags:    {Name: params.ProcessFlags, Type: params.Flags, Value: uint32(0x00000010)},
		},
	}
	require.NoError(t, psnap.Write(evt))

	var tests = []struct {
		expectedExe string
		evt         *event.Event
	}{
		{`Spotify.exe`,
			&event.Event{
				Type: event.LoadImage,
				Params: event.Params{
					params.ProcessID: {Name: params.ProcessID, Type: params.PID, Value: uint32(os.Getpid())},
					params.ImagePath: {Name: params.ImagePath, Type: params.UnicodeString, Value: "C:\\Windows\\assembly\\NativeImages_v4.0.30319_32\\Microsoft.Dee252aac#\\707569faabe821b47fa4f59ecd9eb6ea\\Microsoft.Developer.IdentityService.ni.exe"},
				},
			},
		},
		{`Spotify.exe`,
			&event.Event{
				Type: event.LoadImage,
				Params: event.Params{
					params.ProcessID: {Name: params.ProcessID, Type: params.PID, Value: uint32(os.Getpid())},
					params.ImagePath: {Name: params.ImagePath, Type: params.UnicodeString, Value: "C:\\Windows\\System32\\notepad.exe"},
				},
			},
		},
		{`C:\Users\admin\AppData\Roaming\Spotify\Spotify.exe`,
			&event.Event{
				Type: event.LoadImage,
				Params: event.Params{
					params.ProcessID: {Name: params.ProcessID, Type: params.PID, Value: uint32(os.Getpid())},
					params.ImagePath: {Name: params.ImagePath, Type: params.UnicodeString, Value: "C:\\Users\\admin\\AppData\\Roaming\\Spotify\\Spotify.exe"},
				},
			},
		},
	}

	for _, tt := range tests {
		t.Run(tt.expectedExe, func(t *testing.T) {
			evt := tt.evt
			require.NoError(t, psnap.AddModule(evt))
			ok, ps := psnap.Find(uint32(os.Getpid()))
			require.True(t, ok)
			assert.Equal(t, tt.expectedExe, ps.Exe)
		})
	}
}

func init() {
	reapPeriod = time.Millisecond * 45
}

func TestReapDeadProcesses(t *testing.T) {
	hsnap := new(handle.SnapshotterMock)
	hsnap.On("FindHandles", mock.Anything).Return([]htypes.Handle{}, nil)
	psnap := NewSnapshotter(hsnap, &config.Config{})
	defer psnap.Close()

	notepadHandle, notepadPID := spawnNotepad()
	if notepadHandle == 0 {
		t.Fatal("unable to spawn notepad process")
	}

	evts := []*event.Event{
		{
			Type: event.CreateProcess,
			Params: event.Params{
				params.ProcessID:       {Name: params.ProcessID, Type: params.PID, Value: notepadPID},
				params.ProcessParentID: {Name: params.ProcessParentID, Type: params.PID, Value: uint32(8390)},
				params.ProcessName:     {Name: params.ProcessName, Type: params.UnicodeString, Value: "notepad.exe"},
				params.Cmdline:         {Name: params.Cmdline, Type: params.UnicodeString, Value: `c:\\windows\\system32\\notepad.exe`},
				params.Exe:             {Name: params.Exe, Type: params.UnicodeString, Value: `c:\\windows\\system32\\notepad.exe`},
				params.UserSID:         {Name: params.UserSID, Type: params.WbemSID, Value: []byte{224, 8, 226, 31, 15, 167, 255, 255, 0, 0, 0, 0, 15, 167, 255, 255, 1, 1, 0, 0, 0, 0, 0, 5, 18, 0, 0, 0}},
				params.StartTime:       {Name: params.StartTime, Type: params.Time, Value: time.Now()},
				params.SessionID:       {Name: params.SessionID, Type: params.Uint32, Value: uint32(1)},
				params.ProcessFlags:    {Name: params.ProcessFlags, Type: params.Flags, Value: uint32(0x00000010)},
			},
		},
		{
			Type: event.CreateProcess,
			Params: event.Params{
				params.ProcessID:       {Name: params.ProcessID, Type: params.PID, Value: uint32(os.Getpid())},
				params.ProcessParentID: {Name: params.ProcessParentID, Type: params.PID, Value: uint32(8390)},
				params.ProcessName:     {Name: params.ProcessName, Type: params.UnicodeString, Value: "spotify.exe"},
				params.Cmdline:         {Name: params.Cmdline, Type: params.UnicodeString, Value: `C:\Users\admin\AppData\Roaming\Spotify\Spotify.exe --type=crashpad-handler /prefetch:7 --max-uploads=5 --max-db-size=20 --max-db-age=5 --monitor-self-annotation=ptype=crashpad-handler "--metrics-dir=C:\Users\admin\AppData\Local\Spotify\User Data" --url=https://crashdump.spotify.com:443/ --annotation=platform=win32 --annotation=product=spotify --annotation=version=1.1.4.197 --initial-client-data=0x5a4,0x5a0,0x5a8,0x59c,0x5ac,0x6edcbf60,0x6edcbf70,0x6edcbf7c`},
				params.Exe:             {Name: params.Exe, Type: params.UnicodeString, Value: `C:\Users\admin\AppData\Roaming\Spotify\Spotify.exe`},
				params.UserSID:         {Name: params.UserSID, Type: params.WbemSID, Value: []byte{224, 8, 226, 31, 15, 167, 255, 255, 0, 0, 0, 0, 15, 167, 255, 255, 1, 1, 0, 0, 0, 0, 0, 5, 18, 0, 0, 0}},
				params.StartTime:       {Name: params.StartTime, Type: params.Time, Value: time.Now()},
				params.SessionID:       {Name: params.SessionID, Type: params.Uint32, Value: uint32(1)},
				params.ProcessFlags:    {Name: params.ProcessFlags, Type: params.Flags, Value: uint32(0x00000010)},
			},
		},
	}
	for _, evt := range evts {
		require.NoError(t, psnap.Write(evt))
	}

	require.True(t, psnap.Size() > 1)
	require.NoError(t, windows.TerminateProcess(notepadHandle, 257))
	time.Sleep(time.Millisecond * 100)

	require.True(t, psnap.Size() == 1)
}

func TestFindQueryOS(t *testing.T) {
	hsnap := new(handle.SnapshotterMock)
	hsnap.On("FindHandles", mock.Anything).Return([]htypes.Handle{}, nil)
	psnap := NewSnapshotter(hsnap, &config.Config{})
	defer psnap.Close()

	notepadHandle, notepadPID := spawnNotepad()
	if notepadHandle == 0 {
		t.Fatal("unable to spawn notepad process")
	}
	time.Sleep(time.Second * 1)
	defer windows.TerminateProcess(notepadHandle, 257)
	ok, proc := psnap.Find(notepadPID)
	require.False(t, ok)
	require.NotNil(t, proc)

	assert.Equal(t, notepadPID, proc.PID)
	assert.Equal(t, "notepad.exe", strings.ToLower(proc.Name))
	assert.Equal(t, uint32(os.Getpid()), proc.Ppid)
	assert.True(t, proc.IsPackaged)
	assert.False(t, proc.IsWOW64)
	assert.False(t, proc.IsProtected)
	assert.Equal(t, strings.ToLower(filepath.Join(os.Getenv("windir"), "notepad.exe")), strings.ToLower(proc.Exe))
	assert.Equal(t, filepath.Join(os.Getenv("windir"), "notepad.exe"), proc.Cmdline)
	assert.True(t, len(proc.Envs) > 0)
	assert.Contains(t, proc.Cwd, "fibratus\\pkg\\ps")
	assert.True(t, proc.SessionID > 0)
	assert.Equal(t, "HIGH", proc.TokenIntegrityLevel)

	wts, err := sys.LookupActiveWTS()
	require.NoError(t, err)
	loggedSID, err := wts.SID()
	require.NoError(t, err)
	assert.Equal(t, loggedSID.String(), proc.SID)
	username, domain, _, err := loggedSID.LookupAccount("")
	require.NoError(t, err)
	assert.Equal(t, username, proc.Username)
	assert.Equal(t, domain, proc.Domain)

	// now the proc should exist in snapshotter state
	psnap.Put(proc)
	found, ps := psnap.Find(notepadPID)
	require.True(t, found)
	require.NotNil(t, ps)
}

func spawnNotepad() (windows.Handle, uint32) {
	var si windows.StartupInfo
	var pi windows.ProcessInformation
	argv, err := windows.UTF16PtrFromString(filepath.Join(os.Getenv("windir"), "notepad.exe"))
	if err != nil {
		return 0, 0
	}
	err = windows.CreateProcess(
		nil,
		argv,
		nil,
		nil,
		true,
		0,
		nil,
		nil,
		&si,
		&pi)
	if err != nil {
		return 0, 0
	}
	return pi.Process, pi.ProcessId
}

```

`pkg/ps/types/marshaller_windows.go`:

```go
/*
 * Copyright 2019-2020 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package types

import (
	"fmt"
	"github.com/rabbitstack/fibratus/pkg/cap/section"
	capver "github.com/rabbitstack/fibratus/pkg/cap/version"
	htypes "github.com/rabbitstack/fibratus/pkg/handle/types"
	"github.com/rabbitstack/fibratus/pkg/pe"
	"github.com/rabbitstack/fibratus/pkg/util/bytes"
	"github.com/rabbitstack/fibratus/pkg/util/convert"
	"time"
	"unsafe"
)

// Marshal produces a byte stream of the process state for writing to the capture file.
func (ps *PS) Marshal() []byte {
	b := make([]byte, 0)

	// write pid and ppid
	b = append(b, bytes.WriteUint32(ps.PID)...)
	b = append(b, bytes.WriteUint32(ps.Ppid)...)

	// write process name
	b = append(b, bytes.WriteUint16(uint16(len(ps.Name)))...)
	b = append(b, ps.Name...)
	// write process command line
	b = append(b, bytes.WriteUint16(uint16(len(ps.Cmdline)))...)
	b = append(b, ps.Cmdline...)
	// write full executable path
	b = append(b, bytes.WriteUint16(uint16(len(ps.Exe)))...)
	b = append(b, ps.Exe...)
	// write current working directory
	b = append(b, bytes.WriteUint16(uint16(len(ps.Cwd)))...)
	b = append(b, ps.Cwd...)
	// write SID
	b = append(b, bytes.WriteUint16(uint16(len(ps.SID)))...)
	b = append(b, ps.SID...)

	// write args
	b = append(b, bytes.WriteUint16(uint16(len(ps.Args)))...)
	for _, arg := range ps.Args {
		b = append(b, bytes.WriteUint16(uint16(len(arg)))...)
		b = append(b, arg...)
	}

	// write session ID
	b = append(b, bytes.WriteUint32(ps.SessionID)...)

	// write env vars block
	b = append(b, bytes.WriteUint16(uint16(len(ps.Envs)))...)
	for k, v := range ps.Envs {
		b = append(b, bytes.WriteUint16(uint16(len(k)))...)
		b = append(b, k...)
		b = append(b, bytes.WriteUint16(uint16(len(v)))...)
		b = append(b, v...)
	}

	// write handles
	sec := section.New(section.Handle, capver.HandleSecV1, uint32(len(ps.Handles)), 0)
	b = append(b, sec[:]...)
	for _, handle := range ps.Handles {
		buf := handle.Marshal()
		b = append(b, bytes.WriteUint16(handle.Offset())...)
		b = append(b, buf...)
	}

	// write the PE metadata
	if ps.PE != nil {
		buf := ps.PE.Marshal()
		sec := section.New(section.PE, capver.PESecV2, 0, uint32(len(buf)))
		b = append(b, sec[:]...)
		b = append(b, buf...)
	} else {
		sec := section.New(section.PE, capver.PESecV2, 0, 0)
		b = append(b, sec[:]...)
	}

	// write start time
	timestamp := make([]byte, 0)
	timestamp = ps.StartTime.AppendFormat(timestamp, time.RFC3339Nano)
	b = append(b, bytes.WriteUint16(uint16(len(timestamp)))...)
	b = append(b, timestamp...)

	// write UUID
	b = append(b, bytes.WriteUint64(ps.uuid)...)

	// write username
	b = append(b, bytes.WriteUint16(uint16(len(ps.Username)))...)
	b = append(b, ps.Username...)

	// write domain
	b = append(b, bytes.WriteUint16(uint16(len(ps.Domain)))...)
	b = append(b, ps.Domain...)

	// write process flags
	b = append(b, convert.Btoi(ps.IsWOW64))
	b = append(b, convert.Btoi(ps.IsPackaged))
	b = append(b, convert.Btoi(ps.IsProtected))

	return b
}

// Unmarshal recovers the process' state from the capture file.
func (ps *PS) Unmarshal(b []byte, psec section.Section) error {
	if len(b) < 8 {
		return fmt.Errorf("expected at least 8 bytes but got %d bytes", len(b))
	}
	var offset uint32

	// read pid/ppid
	ps.PID = bytes.ReadUint32(b[0:])
	ps.Ppid = bytes.ReadUint32(b[4:])

	// read process image name
	l := bytes.ReadUint16(b[8:])
	buf := b[10:]
	offset = uint32(l)
	ps.Name = string((*[1<<30 - 1]byte)(unsafe.Pointer(&buf[0]))[:l:l])

	// read process cmdline
	l = bytes.ReadUint16(b[10+offset:])
	buf = b[12+offset:]
	offset += uint32(l)
	ps.Cmdline = string((*[1<<30 - 1]byte)(unsafe.Pointer(&buf[0]))[:l:l])

	// read full image path
	l = bytes.ReadUint16(b[12+offset:])
	buf = b[14+offset:]
	offset += uint32(l)
	ps.Exe = string((*[1<<30 - 1]byte)(unsafe.Pointer(&buf[0]))[:l:l])

	// read current working directory
	l = bytes.ReadUint16(b[14+offset:])
	buf = b[16+offset:]
	offset += uint32(l)
	ps.Cwd = string((*[1<<30 - 1]byte)(unsafe.Pointer(&buf[0]))[:l:l])

	// read the SID
	l = bytes.ReadUint16(b[16+offset:])
	buf = b[18+offset:]
	offset += uint32(l)
	if len(buf) > 0 {
		ps.SID = string((*[1<<30 - 1]byte)(unsafe.Pointer(&buf[0]))[:l:l])
	}

	// read args
	nargs := bytes.ReadUint16(b[18+offset:])
	var aoffset uint16
	for i := 0; i < int(nargs); i++ {
		l := bytes.ReadUint16(b[20+offset+uint32(aoffset):])
		buf = b[22+offset+uint32(aoffset):]
		ps.Args = append(ps.Args, string((*[1<<30 - 1]byte)(unsafe.Pointer(&buf[0]))[:l:l]))
		aoffset += 2 + l
	}

	offset += uint32(aoffset)
	idx := uint32(20)
	// read session ID
	if psec.Version() >= capver.ProcessSecV3 {
		// session identifier was changed from uint8 to uint32
		ps.SessionID = bytes.ReadUint32(b[idx+offset:])
		idx += 4
	} else {
		ps.SessionID = uint32(b[idx+offset])
		idx++
	}

	// read env vars
	nvars := bytes.ReadUint16(b[idx+offset:])
	idx += 2
	var eoffset uint16
	for i := 0; i < int(nvars); i++ {
		klen := bytes.ReadUint16(b[idx+offset+uint32(eoffset):])
		buf = b[idx+2+offset+uint32(eoffset):]
		key := string((*[1<<30 - 1]byte)(unsafe.Pointer(&buf[0]))[:klen:klen])
		vlen := bytes.ReadUint16(b[idx+2+offset+uint32(eoffset)+uint32(klen):])
		buf = b[idx+4+offset+uint32(eoffset)+uint32(klen):]
		value := string((*[1<<30 - 1]byte)(unsafe.Pointer(&buf[0]))[:vlen:vlen])
		ps.Envs[key] = value
		eoffset += klen + vlen + 2 + 2
	}

	offset += uint32(eoffset)

	// read handles
	sec := section.Read(b[idx+offset:])
	offset += 10 // 10 is for the section size in bytes
	var hoffset uint32
	if sec.Len() == 0 {
		goto readpe
	}

	for i := 0; i < int(sec.Len()); i++ {
		// read handle length
		l := uint32(bytes.ReadUint16(b[idx+offset+hoffset:]))
		off := idx + 2 + hoffset + offset
		handle, err := htypes.NewFromCapture(b[off : off+l])
		if err != nil {
			return err
		}
		ps.Handles = append(ps.Handles, handle)
		hoffset += l + 2
	}

readpe:
	offset += hoffset
	// read PE metadata
	sec = section.Read(b[idx+offset:])
	idx += 10
	if sec.Size() == 0 {
		if psec.Version() >= capver.ProcessSecV2 {
			// read start time
			l := uint32(bytes.ReadUint16(b[idx+offset:]))
			idx += 2
			buf := b[idx+offset:]
			offset += l
			if len(buf) > 0 {
				var err error
				t := string((*[1<<30 - 1]byte)(unsafe.Pointer(&buf[0]))[:l:l])
				ps.StartTime, err = time.Parse(time.RFC3339Nano, t)
				if err != nil {
					return err
				}
			}
			// read UUID
			ps.uuid = bytes.ReadUint64(b[idx+offset:])
		}
		if psec.Version() >= capver.ProcessSecV3 {
			idx += 8
			// read username
			l := bytes.ReadUint16(b[idx+offset:])
			idx += 2
			buf := b[:]
			offset += uint32(l)
			ps.Username = string((*[1<<30 - 1]byte)(unsafe.Pointer(&buf[0]))[:l:l])

			// read domain
			l = bytes.ReadUint16(b[idx+offset:])
			buf = b[:]
			idx += 2
			offset += uint32(l)
			ps.Domain = string((*[1<<30 - 1]byte)(unsafe.Pointer(&buf[0]))[:l:l])
		}
		if psec.Version() >= capver.ProcessSecV4 {
			// process flags
			ps.IsWOW64 = convert.Itob(b[idx+offset])
			idx++
			ps.IsPackaged = convert.Itob(b[idx+offset])
			idx++
			ps.IsProtected = convert.Itob(b[idx+offset])
		}

		return nil
	}

	var err error
	ps.PE, err = pe.NewFromCapture(b[idx+offset:], sec.Version())
	if err != nil {
		return err
	}

	offset += sec.Size()
	if psec.Version() >= capver.ProcessSecV2 {
		// read start time
		l := uint32(bytes.ReadUint16(b[idx+offset:]))
		idx += 2
		buf := b[idx+offset:]
		offset += l
		if len(buf) > 0 {
			ps.StartTime, _ = time.Parse(time.RFC3339Nano, string((*[1<<30 - 1]byte)(unsafe.Pointer(&buf[0]))[:l:l]))
		}
		// read UUID
		ps.uuid = bytes.ReadUint64(b[idx+offset:])
	}
	if psec.Version() >= capver.ProcessSecV3 {
		idx += 8
		// read username
		l := bytes.ReadUint16(b[idx+offset:])
		idx += 2
		buf := b[:]
		offset += uint32(l)
		ps.Username = string((*[1<<30 - 1]byte)(unsafe.Pointer(&buf[0]))[:l:l])

		// read domain
		l = bytes.ReadUint16(b[idx+offset:])
		buf = b[:]
		idx += 2
		offset += uint32(l)
		ps.Domain = string((*[1<<30 - 1]byte)(unsafe.Pointer(&buf[0]))[:l:l])
	}
	if psec.Version() >= capver.ProcessSecV4 {
		// process flags
		ps.IsWOW64 = convert.Itob(b[idx+offset])
		idx++
		ps.IsPackaged = convert.Itob(b[idx+offset])
		idx++
		ps.IsProtected = convert.Itob(b[idx+offset])
	}

	return nil
}

```

`pkg/ps/types/marshaller_windows_test.go`:

```go
/*
 * Copyright 2019-2020 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package types

import (
	htypes "github.com/rabbitstack/fibratus/pkg/handle/types"
	"golang.org/x/sys/windows"

	"github.com/rabbitstack/fibratus/pkg/cap/section"
	capver "github.com/rabbitstack/fibratus/pkg/cap/version"
	"github.com/rabbitstack/fibratus/pkg/pe"

	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/require"
	"testing"
	"time"
)

func TestPSMarshaler(t *testing.T) {
	n := time.Now()
	ps := &PS{
		PID:       2436,
		Ppid:      6304,
		Name:      "firefox.exe",
		Exe:       `C:\Program Files\Mozilla Firefox\firefox.exe`,
		Cmdline:   `C:\Program Files\Mozilla Firefox\firefox.exe -contentproc --channel="6304.3.1055809391\1014207667" -childID 1 -isForBrowser -prefsHandle 2584 -prefMapHandle 2580 -prefsLen 70 -prefMapSize 216993 -parentBuildID 20200107212822 -greomni "C:\Program Files\Mozilla Firefox\omni.ja" -appomni "C:\Program Files\Mozilla Firefox\browser\omni.ja" -appdir "C:\Program Files\Mozilla Firefox\browser" - 6304 "\\.\pipe\gecko-crash-server-pipe.6304" 2596 tab`,
		Cwd:       `C:\Program Files\Mozilla Firefox\`,
		SID:       "archrabbit\\SYSTEM",
		Args:      []string{"-contentproc", `--channel="6304.3.1055809391\1014207667`, "-childID", "1", "-isForBrowser", "-prefsHandle", "2584", "-prefMapHandle", "2580", "-prefsLen", "70", "-prefMapSize", "216993", "-parentBuildID"},
		SessionID: 4,
		Envs:      map[string]string{"ProgramData": "C:\\ProgramData", "COMPUTRENAME": "archrabbit"},
		uuid:      123456789,
		StartTime: n,
		Handles: []htypes.Handle{
			{Num: windows.Handle(0xffffd105e9baaf70),
				Name:   `\REGISTRY\MACHINE\SYSTEM\ControlSet001\Services\Tcpip\Parameters\Interfaces\{b677c565-6ca5-45d3-b618-736b4e09b036}`,
				Type:   "Key",
				Object: 777488883434455544,
				Pid:    uint32(1023),
			},
			{
				Num:  windows.Handle(0xffffd105e9adaf70),
				Name: `\RPC Control\OLEA61B27E13E028C4EA6C286932E80`,
				Type: "ALPC Port",
				Pid:  uint32(1023),
				MD: &htypes.AlpcPortInfo{
					Seqno:   1,
					Context: 0x0,
					Flags:   0x0,
				},
				Object: 457488883434455544,
			},
			{
				Num:  windows.Handle(0xeaffd105e9adaf30),
				Name: `C:\Users\bunny`,
				Type: "File",
				Pid:  uint32(1023),
				MD: &htypes.FileInfo{
					IsDirectory: true,
				},
				Object: 357488883434455544,
			},
		},
		IsProtected: true,
		IsWOW64:     true,
		IsPackaged:  false,
	}

	b := ps.Marshal()
	sec := section.New(section.Process, capver.ProcessSecV4, 0, 0)
	clone, err := NewFromCapture(b, sec)
	require.NoError(t, err)

	assert.Equal(t, uint32(2436), clone.PID)
	assert.Equal(t, uint32(6304), clone.Ppid)
	assert.Equal(t, "firefox.exe", clone.Name)
	assert.Equal(t, uint64(123456789), clone.uuid)
	assert.True(t, n.Equal(clone.StartTime))
	assert.Equal(t, `C:\Program Files\Mozilla Firefox\firefox.exe`, clone.Exe)
	assert.Equal(t, `C:\Program Files\Mozilla Firefox\firefox.exe -contentproc --channel="6304.3.1055809391\1014207667" -childID 1 -isForBrowser -prefsHandle 2584 -prefMapHandle 2580 -prefsLen 70 -prefMapSize 216993 -parentBuildID 20200107212822 -greomni "C:\Program Files\Mozilla Firefox\omni.ja" -appomni "C:\Program Files\Mozilla Firefox\browser\omni.ja" -appdir "C:\Program Files\Mozilla Firefox\browser" - 6304 "\\.\pipe\gecko-crash-server-pipe.6304" 2596 tab`, clone.Cmdline)
	assert.Equal(t, `C:\Program Files\Mozilla Firefox\`, clone.Cwd)
	assert.Equal(t, "archrabbit\\SYSTEM", clone.SID)
	assert.Equal(t, []string{"-contentproc", `--channel="6304.3.1055809391\1014207667`, "-childID", "1", "-isForBrowser", "-prefsHandle", "2584", "-prefMapHandle", "2580", "-prefsLen", "70", "-prefMapSize", "216993", "-parentBuildID"}, clone.Args)
	assert.Equal(t, uint32(4), clone.SessionID)
	assert.Equal(t, map[string]string{"ProgramData": "C:\\ProgramData", "COMPUTRENAME": "archrabbit"}, clone.Envs)
	assert.True(t, clone.IsProtected)
	assert.True(t, clone.IsWOW64)
	assert.False(t, clone.IsPackaged)

	require.Len(t, clone.Handles, 3)

	alpc := clone.Handles[1]
	assert.Equal(t, "ALPC Port", alpc.Type)
	assert.Equal(t, `\RPC Control\OLEA61B27E13E028C4EA6C286932E80`, alpc.Name)
	assert.IsType(t, &htypes.AlpcPortInfo{}, alpc.MD)

	md := alpc.MD.(*htypes.AlpcPortInfo)
	assert.Equal(t, uint32(1), md.Seqno)
}

func TestPSMarshalerWithPE(t *testing.T) {
	n := time.Now()
	p := &pe.PE{
		NumberOfSections: 7,
		NumberOfSymbols:  10,
		EntryPoint:       "20110",
		ImageBase:        "140000000",
		LinkTime:         n,
		Sections: []pe.Sec{
			{Name: ".text", Size: 132608, Entropy: 6.368381, Md5: "db23dce3911a42e987041d98abd4f7cd"},
			{Name: ".rdata", Size: 35840, Entropy: 5.996976, Md5: "ffa5c960b421ca9887e54966588e97e8"},
		},
		Symbols:          []string{"SelectObject", "GetTextFaceW", "EnumFontsW", "TextOutW", "GetProcessHeap"},
		Imports:          []string{"GDI32.dll", "USER32.dll", "msvcrt.dll", "api-ms-win-core-libraryloader-l1-2-0.dl"},
		VersionResources: map[string]string{"CompanyName": "Microsoft Corporation", "FileDescription": "Notepad", "FileVersion": "10.0.18362.693"},
	}
	ps := &PS{
		PID:       2436,
		Ppid:      6304,
		Name:      "firefox.exe",
		Exe:       `C:\Program Files\Mozilla Firefox\firefox.exe`,
		Cmdline:   `C:\Program Files\Mozilla Firefox\firefox.exe -contentproc --channel="6304.3.1055809391\1014207667" -childID 1 -isForBrowser -prefsHandle 2584 -prefMapHandle 2580 -prefsLen 70 -prefMapSize 216993 -parentBuildID 20200107212822 -greomni "C:\Program Files\Mozilla Firefox\omni.ja" -appomni "C:\Program Files\Mozilla Firefox\browser\omni.ja" -appdir "C:\Program Files\Mozilla Firefox\browser" - 6304 "\\.\pipe\gecko-crash-server-pipe.6304" 2596 tab`,
		Cwd:       `C:\Program Files\Mozilla Firefox\`,
		SID:       "archrabbit\\SYSTEM",
		Args:      []string{"-contentproc", `--channel="6304.3.1055809391\1014207667`, "-childID", "1", "-isForBrowser", "-prefsHandle", "2584", "-prefMapHandle", "2580", "-prefsLen", "70", "-prefMapSize", "216993", "-parentBuildID"},
		SessionID: 4,
		Envs:      map[string]string{"ProgramData": "C:\\ProgramData", "COMPUTRENAME": "archrabbit"},
		uuid:      123456789,
		StartTime: n,
		PE:        p,
		Handles: []htypes.Handle{
			{Num: windows.Handle(0xffffd105e9baaf70),
				Name:   `\REGISTRY\MACHINE\SYSTEM\ControlSet001\Services\Tcpip\Parameters\Interfaces\{b677c565-6ca5-45d3-b618-736b4e09b036}`,
				Type:   "Key",
				Object: 777488883434455544,
				Pid:    uint32(1023),
			},
			{
				Num:  windows.Handle(0xffffd105e9adaf70),
				Name: `\RPC Control\OLEA61B27E13E028C4EA6C286932E80`,
				Type: "ALPC Port",
				Pid:  uint32(1023),
				MD: &htypes.AlpcPortInfo{
					Seqno:   1,
					Context: 0x0,
					Flags:   0x0,
				},
				Object: 457488883434455544,
			},
			{
				Num:  windows.Handle(0xeaffd105e9adaf30),
				Name: `C:\Users\bunny`,
				Type: "File",
				Pid:  uint32(1023),
				MD: &htypes.FileInfo{
					IsDirectory: true,
				},
				Object: 357488883434455544,
			},
		},
	}

	b := ps.Marshal()
	sec := section.New(section.Process, capver.ProcessSecV3, 0, 0)
	clone, err := NewFromCapture(b, sec)
	require.NoError(t, err)

	assert.Equal(t, uint32(2436), clone.PID)
	assert.Equal(t, uint32(6304), clone.Ppid)
	assert.Equal(t, "firefox.exe", clone.Name)
	assert.Equal(t, uint64(123456789), clone.uuid)
	assert.True(t, n.Equal(clone.StartTime))
	assert.Equal(t, `C:\Program Files\Mozilla Firefox\firefox.exe`, clone.Exe)
	assert.Equal(t, `C:\Program Files\Mozilla Firefox\firefox.exe -contentproc --channel="6304.3.1055809391\1014207667" -childID 1 -isForBrowser -prefsHandle 2584 -prefMapHandle 2580 -prefsLen 70 -prefMapSize 216993 -parentBuildID 20200107212822 -greomni "C:\Program Files\Mozilla Firefox\omni.ja" -appomni "C:\Program Files\Mozilla Firefox\browser\omni.ja" -appdir "C:\Program Files\Mozilla Firefox\browser" - 6304 "\\.\pipe\gecko-crash-server-pipe.6304" 2596 tab`, clone.Cmdline)
	assert.Equal(t, `C:\Program Files\Mozilla Firefox\`, clone.Cwd)
	assert.Equal(t, "archrabbit\\SYSTEM", clone.SID)
	assert.Equal(t, []string{"-contentproc", `--channel="6304.3.1055809391\1014207667`, "-childID", "1", "-isForBrowser", "-prefsHandle", "2584", "-prefMapHandle", "2580", "-prefsLen", "70", "-prefMapSize", "216993", "-parentBuildID"}, clone.Args)
	assert.Equal(t, uint32(4), clone.SessionID)
	assert.Equal(t, map[string]string{"ProgramData": "C:\\ProgramData", "COMPUTRENAME": "archrabbit"}, clone.Envs)

	require.Len(t, clone.Handles, 3)

	alpc := clone.Handles[1]
	assert.Equal(t, "ALPC Port", alpc.Type)
	assert.Equal(t, `\RPC Control\OLEA61B27E13E028C4EA6C286932E80`, alpc.Name)
	assert.IsType(t, &htypes.AlpcPortInfo{}, alpc.MD)

	md := alpc.MD.(*htypes.AlpcPortInfo)
	assert.Equal(t, uint32(1), md.Seqno)
}

```

`pkg/ps/types/types.go`:

```go
/*
 * Copyright 2020-2021 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package types

// Visitor is the type definition for the function that is
// invoked on each ancestor visit walk.
type Visitor func(*PS)

// Walk recursively visits all ancestors of the given process
// and invokes the visitor function on each parent process.
func Walk(v Visitor, ps *PS) {
	if ps == nil {
		return
	}
	if ps.Parent == nil {
		return
	}
	v(ps.Parent)
	if ps.Parent != nil {
		Walk(v, ps.Parent)
	}
}

```

`pkg/ps/types/types_windows.go`:

```go
/*
 * Copyright 2019-2020 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package types

import (
	"encoding/binary"
	"fmt"
	"path/filepath"
	"strings"
	"sync"

	"github.com/rabbitstack/fibratus/pkg/sys"
	"github.com/rabbitstack/fibratus/pkg/util/cmdline"
	"github.com/rabbitstack/fibratus/pkg/util/va"
	"github.com/rabbitstack/fibratus/pkg/util/wildcard"
	"golang.org/x/sys/windows"

	"github.com/rabbitstack/fibratus/pkg/cap/section"
	htypes "github.com/rabbitstack/fibratus/pkg/handle/types"
	"github.com/rabbitstack/fibratus/pkg/pe"

	"time"

	"github.com/rabbitstack/fibratus/pkg/util/bootid"
)

// PS encapsulates process' state such as allocated resources and other metadata.
type PS struct {
	sync.RWMutex
	// PID is the identifier of this process. This value is valid from the time a process is created until it is terminated.
	PID uint32 `json:"pid"`
	// Ppipd represents the parent of this process. Process identifier numbers are reused, so they only identify a process
	// for the lifetime of that process. It is possible that the process identified by `Ppid` is terminated,
	// so `Ppid` may not refer to a running process. It is also possible that `Ppid` incorrectly refers
	// to a process that reuses a process identifier.
	Ppid uint32 `json:"ppid"`
	// Name is the process' image name including file extension (e.g. cmd.exe)
	Name string `json:"name"`
	// Cmdline is the full process' command line (e.g. C:\Windows\system32\cmd.exe /cdir /-C /W)
	Cmdline string `json:"comm"`
	// Exe is the full name of the process' executable (e.g. C:\Windows\system32\cmd.exe)
	Exe string `json:"exe"`
	// Cwd designates the current working directory of the process.
	Cwd string `json:"cwd"`
	// SID is the security identifier under which this process is run. (e.g. S-1-5-32-544)
	SID string `json:"sid"`
	// Args contains process' command line arguments (e.g. /cdir, /-C, /W)
	Args []string `json:"args"`
	// SessionID is the unique identifier for the current session.
	SessionID uint32 `json:"session"`
	// Envs contains process' environment variables indexed by env variable name.
	Envs map[string]string `json:"envs"`
	// Threads contains all the threads running in the address space of this process.
	Threads map[uint32]Thread `json:"-"`
	// Modules contains all the modules loaded by the process.
	Modules []Module `json:"modules"`
	// Mmaps contains all memory mappings.
	Mmaps []Mmap
	// Handles represents the collection of handles allocated by the process.
	Handles htypes.Handles `json:"handles"`
	// PE stores the PE (Portable Executable) metadata.
	PE *pe.PE `json:"pe"`
	// Parent represents the reference to the parent process.
	Parent *PS `json:"parent"`
	// StartTime represents the process start time.
	StartTime time.Time `json:"started"`
	// uuid is a unique process identifier derived from boot ID and process sequence number
	uuid uint64
	// Username represents the username under which the process is run.
	Username string `json:"username"`
	// Domain represents the domain under which the process is run. (e.g. NT AUTHORITY)
	Domain string `json:"domain"`
	// IsWOW64 indicates if this is 32-bit process created in 64-bit Windows system (Windows on Windows)
	IsWOW64 bool `json:"is_wow_64"`
	// IsPackaged denotes that the process is packaged with the MSIX technology and thus has
	// associated package identity.
	IsPackaged bool `json:"is_packaged"`
	// IsProtected denotes a protected process. The system restricts access to protected
	// processes and the threads of protected processes.
	IsProtected bool `json:"is_protected"`
	// TokenIntegrityLevel designates the process token integrity level. (e.g. High)
	// Integrity level defines the trust between the process and a securable object.
	TokenIntegrityLevel string `json:"token_integrity_level"`
	// TokenElevationType designates the process token elevation type. (e.g. Limited)
	TokenElevationType string `json:"token_elevation_type"`
	// IsTokenElevated indicates if the process token is elevated.
	IsTokenElevated bool `json:"is_token_elevated"`
	// IsCreatedFromSystemLogger is the metadata attribute that indicates if the
	// process state is created from the event published by the NT kernel logger.
	IsCreatedFromSystemLogger bool `json:"-"`
}

// UUID is meant to offer a more robust version of process ID that
// is resistant to being repeated. Process start key was introduced
// in Windows 10 1507 and is derived from _KUSER_SHARED_DATA.BootId and
// EPROCESS.SequenceNumber both of which increment and are unlikely to
// overflow. This method uses a combination of process start key and boot id
// to fabric a unique process identifier. If this is not possible, the uuid
// is computed by using the process start time.
func (ps *PS) UUID() uint64 {
	if ps.uuid != 0 {
		return ps.uuid
	}
	// assume the uuid is derived from boot ID and process start time
	ps.uuid = (bootid.Read() << 30) + uint64(ps.PID) | uint64(ps.StartTime.UnixNano())
	maj, _, patch := windows.RtlGetNtVersionNumbers()
	if maj >= 10 && patch >= 1507 {
		seqNum := querySequenceNumber(ps.PID)
		// prefer the most robust variant of the uuid which uses the
		// process sequence number obtained from the process object
		if seqNum != 0 {
			ps.uuid = (bootid.Read() << 30) | seqNum
		}
	}
	return ps.uuid
}

// AssignUUID assigns the UUID from the given
// process if the UUID has been initialized.
func (ps *PS) AssignUUID(proc *PS) {
	if proc.uuid != 0 {
		ps.uuid = proc.uuid
	}
}

// ProcessSequenceNumber contains the unique process sequence number.
type ProcessSequenceNumber struct {
	Seq [8]byte
}

func querySequenceNumber(pid uint32) uint64 {
	proc, err := windows.OpenProcess(windows.PROCESS_QUERY_INFORMATION, false, pid)
	if err != nil {
		return 0
	}
	defer windows.Close(proc)
	seq, err := sys.QueryInformationProcess[ProcessSequenceNumber](proc, windows.ProcessSequenceNumber)
	if err != nil {
		return 0
	}
	return binary.BigEndian.Uint64(seq.Seq[:])
}

// String returns a string representation of the process' state.
func (ps *PS) String() string {
	parent := ps.Parent
	if parent != nil {
		return fmt.Sprintf(`
		Pid:  %d
		Ppid: %d
		Name: %s
		Parent name: %s
		Cmdline: %s
		Parent cmdline: %s
		Exe: %s
		Cwd: %s
		SID: %s
		Integrity level: %s
		Username: %s
		Domain: %s
		Args: %s
		Session ID: %d
		Envs: %v
		`,
			ps.PID,
			ps.Ppid,
			ps.Name,
			parent.Name,
			ps.Cmdline,
			parent.Cmdline,
			ps.Exe,
			ps.Cwd,
			ps.SID,
			ps.TokenIntegrityLevel,
			ps.Username,
			ps.Domain,
			ps.Args,
			ps.SessionID,
			ps.Envs,
		)
	}
	return fmt.Sprintf(`
		Pid:  %d
		Ppid: %d
		Name: %s
		Cmdline: %s
		Exe: %s
		Cwd: %s
		SID: %s
		Integrity level: %s
		Username: %s
		Domain: %s
		Args: %s
		Session ID: %d
		Envs: %v
		`,
		ps.PID,
		ps.Ppid,
		ps.Name,
		ps.Cmdline,
		ps.Exe,
		ps.Cwd,
		ps.SID,
		ps.TokenIntegrityLevel,
		ps.Username,
		ps.Domain,
		ps.Args,
		ps.SessionID,
		ps.Envs,
	)
}

// StringShort returns a string representation of the process' state
// by removing some verbose attributes such as the env variables block.
func (ps *PS) StringShort() string {
	parent := ps.Parent
	if parent != nil {
		return fmt.Sprintf(`
		Pid:  %d
		Ppid: %d
		Name: %s
		Parent name: %s
		Cmdline: %s
		Parent cmdline: %s
		Exe: %s
		Cwd: %s
		SID: %s
		Username: %s
		Domain: %s
		Args: %s
		Session ID: %d
		Ancestors: %s
	`,
			ps.PID,
			ps.Ppid,
			ps.Name,
			parent.Name,
			ps.Cmdline,
			parent.Cmdline,
			ps.Exe,
			ps.Cwd,
			ps.SID,
			ps.Username,
			ps.Domain,
			ps.Args,
			ps.SessionID,
			strings.Join(ps.Ancestors(), " > "),
		)
	}
	return fmt.Sprintf(`
		Pid:  %d
		Ppid: %d
		Name: %s
		Cmdline: %s
		Exe: %s
		Cwd: %s
		SID: %s
		Integrity level: %s
		Username: %s
		Domain: %s
		Args: %s
		Session ID: %d
		Ancestors: %s
	`,
		ps.PID,
		ps.Ppid,
		ps.Name,
		ps.Cmdline,
		ps.Exe,
		ps.Cwd,
		ps.SID,
		ps.TokenIntegrityLevel,
		ps.Username,
		ps.Domain,
		ps.Args,
		ps.SessionID,
		strings.Join(ps.Ancestors(), " > "),
	)
}

// Ancestors returns all ancestors of this process. The string slice contains
// the process image name followed by the process id.
func (ps *PS) Ancestors() []string {
	ancestors := make([]string, 0)
	walk := func(proc *PS) {
		ancestors = append(ancestors, fmt.Sprintf("%s (%d)", proc.Name, proc.PID))
	}
	Walk(walk, ps)
	return ancestors
}

// IsSeclogonSvc returns true if this is the Secondary Logon Service process.
func (ps *PS) IsSeclogonSvc() bool {
	return ps.IsSvchost() && strings.HasSuffix(ps.Cmdline, "-s seclogon")
}

// IsAppinfoSvc returns true if this is the AppInfo Service process.
func (ps *PS) IsAppinfoSvc() bool {
	return ps.IsSvchost() && strings.HasSuffix(ps.Cmdline, "-s Appinfo")
}

// IsSvchost returns true if this is the Service Host process.
func (ps *PS) IsSvchost() bool {
	return wildcard.Match(`?:\windows\system32\svchost.exe`, strings.ToLower(ps.Exe))
}

// Thread stores metadata about a thread that's executing in process's address space.
type Thread struct {
	// Tid is the unique identifier of thread inside the process.
	Tid uint32
	// Pid is the identifier of the process to which this thread pertains.
	Pid uint32
	// IOPrio represents an I/O priority hint for scheduling I/O operations generated by the thread.
	IOPrio uint8
	// BasePrio is the scheduler priority of the thread.
	BasePrio uint8
	// PagePrio is a memory page priority hint for memory pages accessed by the thread.
	PagePrio uint8
	// UstackBase is the base address of the thread's user space stack.
	UstackBase va.Address
	// UstackLimit is the limit of the thread's user space stack.
	UstackLimit va.Address
	// KStackBase is the base address of the thread's kernel space stack.
	KstackBase va.Address
	// KstackLimit is the limit of the thread's kernel space stack.
	KstackLimit va.Address
	// StartAddress is thread start address.
	StartAddress va.Address
}

// String returns the thread as a human-readable string.
func (t Thread) String() string {
	return fmt.Sprintf("ID: %d IO prio: %d, Base prio: %d, Page prio: %d, Ustack base: %s, Ustack limit: %s, Kstack base: %s, Kstack limit: %s, Start address: %s", t.Tid, t.IOPrio, t.BasePrio, t.PagePrio, t.UstackBase, t.UstackLimit, t.KstackBase, t.UstackLimit, t.StartAddress)
}

// Module represents the data for all dynamic libraries/executables that reside in the process' address space.
type Module struct {
	// Size designates the size in bytes of the image file.
	Size uint64
	// Checksum is the checksum of the image file.
	Checksum uint32
	// Name represents the full path of this image.
	Name string
	// BaseAddress is the base address of process in which the image is loaded.
	BaseAddress va.Address
	// DefaultBaseAddress is the default base address.
	DefaultBaseAddress va.Address
	// SignatureLevel designates the image signature level. (e.g. MICROSOFT)
	SignatureLevel uint32
	// SignatureType designates the image signature type (e.g. EMBEDDED)
	SignatureType uint32
}

// String returns the string representation of the module.
func (m Module) String() string {
	return fmt.Sprintf("Name: %s, Size: %d, Checksum: %d, Base address: %s, Default base address: %s", m.Name, m.Size, m.Checksum, m.BaseAddress, m.DefaultBaseAddress)
}

// IsExecutable determines if the loaded module is an executable.
func (m Module) IsExecutable() bool { return strings.ToLower(filepath.Ext(m.Name)) == ".exe" }

// IsNTDLL determines if the module is the native ntdll module.
func (m Module) IsNTDLL() bool { return strings.EqualFold(filepath.Base(m.Name), "ntdll.dll") }

// Mmap stores information related to the memory mapping.
type Mmap struct {
	// BaseAddress represents the address where the view of section is mapped.
	BaseAddress va.Address
	// Size indicates the size of the mapped view of section.
	Size uint64
	// Protection is the bitmask with view protection rights.
	Protection uint32
	// Type represents the type of the view of section (e.g. IMAGE, DATA, PAGEFILE)
	Type string
	// File if the view is backed by the file object, this field indicates
	// the file path of the mapped image/data file.
	File string
}

var mmapProtections = map[uint32]string{
	sys.SectionR:   "R",
	sys.SectionX:   "X",
	sys.SectionRW:  "RW",
	sys.SectionRX:  "RX",
	sys.SectionRWX: "RWX",
	sys.SectionWC:  "WC",
	sys.SectionWXC: "WXC",
	sys.SectionWCB: "WCB",
	sys.SectionNC:  "NC",
}

// ProtectMask returns the view protection in mask notation.
func (m *Mmap) ProtectMask() string {
	var (
		b strings.Builder
		s string
	)

	f := m.Protection

	for protect, mask := range mmapProtections {
		if (f&protect) == protect && protect != 0 {
			b.WriteString(s)
			b.WriteString(mask)
			s = "|"
			f &= ^protect
		}
	}

	return b.String()
}

// New produces a new process state.
func New(pid, ppid uint32, name, cmndline, exe string, sid *windows.SID, sessionID uint32) *PS {
	ps := &PS{
		PID:       pid,
		Ppid:      ppid,
		Name:      name,
		Cmdline:   cmndline,
		Exe:       exe,
		Args:      cmdline.Split(cmndline),
		SID:       sid.String(),
		SessionID: sessionID,
		Threads:   make(map[uint32]Thread),
		Modules:   make([]Module, 0),
		Handles:   make([]htypes.Handle, 0),
		Mmaps:     make([]Mmap, 0),
	}
	ps.Username, ps.Domain, _, _ = sid.LookupAccount("")
	return ps
}

// NewFromCapture reconstructs the state of the process from the capture file.
func NewFromCapture(buf []byte, sec section.Section) (*PS, error) {
	ps := PS{
		Args:    make([]string, 0),
		Envs:    make(map[string]string),
		Handles: make([]htypes.Handle, 0),
		Modules: make([]Module, 0),
		Threads: make(map[uint32]Thread),
		Mmaps:   make([]Mmap, 0),
	}
	if err := ps.Unmarshal(buf, sec); err != nil {
		return nil, err
	}
	return &ps, nil
}

// AddThread adds a thread to process's state descriptor.
func (ps *PS) AddThread(thread Thread) {
	ps.Lock()
	defer ps.Unlock()
	ps.Threads[thread.Tid] = thread
}

// RemoveThread eliminates a thread from the process's state.
func (ps *PS) RemoveThread(tid uint32) {
	ps.Lock()
	defer ps.Unlock()
	delete(ps.Threads, tid)
}

// AddHandle adds a new handle to this process state.
func (ps *PS) AddHandle(handle htypes.Handle) {
	ps.Handles = append(ps.Handles, handle)
}

// RemoveHandle removes a handle with specified identifier from the list of allocated handles.
func (ps *PS) RemoveHandle(handle windows.Handle) {
	for i, h := range ps.Handles {
		if h.Num == handle {
			ps.Handles = append(ps.Handles[:i], ps.Handles[i+1:]...)
			break
		}
	}
}

// AddModule adds a new module to this process state.
func (ps *PS) AddModule(mod Module) {
	m := ps.FindModuleByAddr(mod.BaseAddress)
	if m != nil {
		return
	}
	ps.Modules = append(ps.Modules, mod)
}

// RemoveModule removes a specified module from this process state.
func (ps *PS) RemoveModule(addr va.Address) {
	for i, mod := range ps.Modules {
		if mod.BaseAddress == addr {
			ps.Modules = append(ps.Modules[:i], ps.Modules[i+1:]...)
			break
		}
	}
}

// FindModule finds the module by name.
func (ps *PS) FindModule(path string) *Module {
	for _, mod := range ps.Modules {
		if filepath.Base(mod.Name) == filepath.Base(path) {
			return &mod
		}
	}
	return nil
}

// FindModuleByAddr finds the module by its base address.
func (ps *PS) FindModuleByAddr(addr va.Address) *Module {
	for _, mod := range ps.Modules {
		if mod.BaseAddress == addr {
			return &mod
		}
	}
	return nil
}

// FindModuleByVa finds the module name by
// probing the range of the given virtual address.
func (ps *PS) FindModuleByVa(addr va.Address) *Module {
	for _, mod := range ps.Modules {
		if addr >= mod.BaseAddress && addr <= mod.BaseAddress.Inc(mod.Size) {
			return &mod
		}
	}
	return nil
}

// AddMmap adds a new memory mapping for this process state.
func (ps *PS) AddMmap(mmap Mmap) {
	ps.Mmaps = append(ps.Mmaps, mmap)
}

// RemoveMmap removes the memory mapping at the specified address.
func (ps *PS) RemoveMmap(addr va.Address) {
	for i, mmap := range ps.Mmaps {
		if mmap.BaseAddress == addr {
			ps.Mmaps = append(ps.Mmaps[:i], ps.Mmaps[i+1:]...)
			break
		}
	}
}

// FindMmap returns the memory mapping by the given address.
func (ps *PS) FindMmap(addr va.Address) *Mmap {
	for _, mmap := range ps.Mmaps {
		if mmap.BaseAddress == addr {
			return &mmap
		}
	}
	return nil
}

```

`pkg/ps/types/types_windows_test.go`:

```go
/*
 * Copyright 2020-2021 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package types

import (
	"os"
	"testing"
	"time"

	"github.com/rabbitstack/fibratus/pkg/util/bootid"
	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/require"
	"golang.org/x/sys/windows"
)

func TestVisit(t *testing.T) {
	p1 := &PS{
		Name: "powershell.exe",
		Parent: &PS{
			Name: "cmd.exe",
		},
	}
	p2 := &PS{
		Name: "iexplorer.exe",
		Parent: &PS{
			Name: "winword.exe",
			Parent: &PS{
				Name: "powershell.exe",
				Parent: &PS{
					Name: "cmd.exe",
				},
			},
		},
	}

	var tests = []struct {
		proc *PS
		want []string
	}{
		{&PS{Name: "winword.exe", Parent: p1}, []string{"powershell.exe", "cmd.exe"}},
		{&PS{Name: "dropper.exe", Parent: p2}, []string{"iexplorer.exe", "winword.exe", "powershell.exe", "cmd.exe"}},
	}

	for _, tt := range tests {
		ancestors := make([]string, 0)
		Walk(func(ps *PS) { ancestors = append(ancestors, ps.Name) }, tt.proc)
		assert.Equal(t, ancestors, tt.want)
	}
}

func TestPSArgs(t *testing.T) {
	ps := New(
		233,
		4532,
		"spotify.exe",
		"C:\\Users\\admin\\AppData\\Roaming\\Spotify\\Spotify.exe --type=crashpad-handler /prefetch:7 --max-uploads=5 --max-db-size=20 --max-db-age=5 --monitor-self-annotation=ptype=crashpad-handler \"--metrics-dir=C:\\Users\\admin\\AppData\\Local\\Spotify\\User Data\" --url=https://crashdump.spotify.com:443/ --annotation=platform=win32 --annotation=product=spotify",
		"C:\\Users\\admin\\AppData\\Roaming\\Spotify\\Spotify.exe",
		&windows.SID{},
		1)
	require.Len(t, ps.Args, 11)
	require.Equal(t, "/prefetch:7", ps.Args[2])
}

func TestUUID(t *testing.T) {
	now := time.Now()
	// try to obtain the UUID on a system process
	// will fail to obtain the process handle and thus
	// the UUID is derived from boot ID, process id and
	// process star time
	ps1 := &PS{
		PID:       4,
		StartTime: now,
	}
	uuid := (bootid.Read() << 30) + uint64(4) | uint64(now.UnixNano())
	assert.Equal(t, uuid, ps1.UUID())

	// now use the variant with process start key obtained
	// from the process object
	ps2 := &PS{
		PID: uint32(os.Getpid()),
	}
	tsUUID := (bootid.Read() << 30) + uint64(os.Getpid()) | uint64(now.UnixNano())
	assert.True(t, ps2.UUID() > 0 && ps2.UUID() != tsUUID)
}

func TestIsSeclogonSvc(t *testing.T) {
	var tests = []struct {
		ps *PS
		ok bool
	}{
		{&PS{Name: "svchost.exe", Exe: `C:\WINDOWS\system32\svchost.exe`, Cmdline: `C:\WINDOWS\system32\svchost.exe -k netsvcs -p -s Appinfo`}, false},
		{&PS{Name: "svchost.exe", Exe: `C:\WINDOWS\system32\svchost.exe`, Cmdline: `C:\WINDOWS\system32\svchost.exe -k netsvcs -p -s seclogon`}, true},
	}

	for _, tt := range tests {
		t.Run(tt.ps.Cmdline, func(t *testing.T) {
			assert.Equal(t, tt.ok, tt.ps.IsSeclogonSvc())
		})
	}
}

func TestIsAppinfoSvc(t *testing.T) {
	var tests = []struct {
		ps *PS
		ok bool
	}{
		{&PS{Name: "svchost.exe", Exe: `C:\WINDOWS\system32\svchost.exe`, Cmdline: `C:\WINDOWS\system32\svchost.exe -k netsvcs -p -s Appinfo`}, true},
		{&PS{Name: "svchost.exe", Exe: `C:\WINDOWS\system32\svchost.exe`, Cmdline: `C:\WINDOWS\System32\svchost.exe -k LocalServiceNoNetwork -p -s DPS`}, false},
	}

	for _, tt := range tests {
		t.Run(tt.ps.Cmdline, func(t *testing.T) {
			assert.Equal(t, tt.ok, tt.ps.IsAppinfoSvc())
		})
	}
}

```

`pkg/rules/_fixtures/default/microsoft_edge.yml`:

```yml
name: Microsoft edge
id: c3a50242-7161-43d5-a198-051021056195
version: 1.0.0
condition: evt.name = 'CreateProcess' and ps.comm startswith '\"C:\\Program Files (x86)\\Microsoft\\Edge Dev\\Application\\msedge.exe\" --type='
min-engine-version: 2.0.0

```

`pkg/rules/_fixtures/default/sequence_rule_simple.yml`:

```yml
name: Command shell created a temp file
id: 972902be-76e9-4ee7-a48a-6275fa571cf4
version: 1.0.0
condition: >
  sequence
  maxspan 100ms
  |evt.name = 'CreateProcess' and ps.name = 'cmd.exe'| by ps.exe
  |evt.name = 'CreateFile'
      and
   file.path icontains 'temp'
  | by file.path
min-engine-version: 2.0.0

```

`pkg/rules/_fixtures/default/suspicious_domains.yml`:

```yml
name: Suspicious domains
id: c4cd547f-d64a-4452-abe8-846410617c06
version: 1.0.0
condition: evt.name = 'QueryDns' and dns.name = 'fishy.domain.dot'
min-engine-version: 2.0.0

```

`pkg/rules/_fixtures/default/suspicious_module_loaded.yml`:

```yml
name: Loaded suspicious module
id: 1e4c3fbf-ed3a-4df4-9c54-8693d7397a75
version: 1.0.0
condition: evt.name = 'LoadImage' and image.name = 'svchost.dll'
min-engine-version: 2.0.0

```

`pkg/rules/_fixtures/default/suspicious_network_connecting_binaries.yml`:

```yml
name: Suspicious sources for network-connecting binaries
id: 0a8c6a06-eaf2-48c1-9b05-d0e706142311
version: 1.0.0
condition: evt.name = 'Connect' and ps.exe startswith
  (
    'C:\\Users',
    'C:\\Recycle',
    'C:\\ProgramData',
    'C:\\Windows\\Temp',
    '\\',
    'C:\\perflogs',
    'C:\\intel',
    'C:\\Windows\\fonts',
    'C:\\Windows\\system32\\config'
  )
min-engine-version: 2.0.0

```

`pkg/rules/_fixtures/default/windows_error_reporting_and_wmi_provider_host.yml`:

```yml
name: Windows error reporting/telemetry, WMI provider host
id: 0fe67e44-94e2-44cb-bc40-052bc2e0fdb2
version: 1.0.0
condition: evt.name = 'CreateProcess' and ps.comm startswith
  (
    ' \"C:\\Windows\\system32\\wermgr.exe\\" \"-queuereporting_svc\" ',
    'C:\\Windows\\system32\\DllHost.exe /Processid',
    'C:\\Windows\\system32\\wbem\\wmiprvse.exe -Embedding',
    'C:\\Windows\\system32\\wbem\\wmiprvse.exe -secured -Embedding'
  )
min-engine-version: 2.0.0

```

`pkg/rules/_fixtures/field_values/correct_category_name_field.yml`:

```yml
name: match https connections
id: 8f36f8e0-a5c2-498f-9563-eea306daa586
version: 1.0.0
condition: evt.category = 'net' and net.dport = 443
min-engine-version: 2.0.0

```

`pkg/rules/_fixtures/field_values/correct_event_name_field.yml`:

```yml
name: match https connections
id: 8f36f8e0-a5c2-498f-9563-eea306daa586
version: 1.0.0
condition: evt.name = 'Recv' and net.dport = 443
min-engine-version: 2.0.0

```

`pkg/rules/_fixtures/field_values/incorrect_category_name_field.yml`:

```yml
name: match https connections
id: 8f36f8e0-a5c2-498f-9563-eea306daa586
version: 1.0.0
condition: evt.category = 'network' and net.dport = 443
min-engine-version: 2.0.0

```

`pkg/rules/_fixtures/field_values/incorrect_event_name_field.yml`:

```yml
name: match https connections
id: 8f36f8e0-a5c2-498f-9563-eea306daa586
version: 1.0.0
condition: evt.name = 'RecvTcp4' and net.dport = 443
min-engine-version: 2.0.0

```

`pkg/rules/_fixtures/field_values/incorrect_event_name_in_operator.yml`:

```yml
name: match https connections
id: 8f36f8e0-a5c2-498f-9563-eea306daa586
version: 1.0.0
condition: evt.name in ('Recv', 'Accept', 'CreateProc') and net.dport = 443
min-engine-version: 2.0.0

```

`pkg/rules/_fixtures/kill_action.yml`:

```yml
name: Kill calc.exe process
id: 172902be-76e9-4ee7-a48a-6275fa571cf4
version: 1.0.0
condition: evt.name = 'CreateProcess' and ps.name = 'calc.exe'
severity: critical
action:
- name: kill
min-engine-version: 2.0.0
tags:
  - tag1
  - tag2

```

`pkg/rules/_fixtures/merged_filters/filter1.yml`:

```yml
name: match https connections
id: 8f36f8e0-a5c2-498f-9563-eea306daa586
version: 1.0.0
condition: evt.name = 'Recv' and net.dport = 443
min-engine-version: 2.0.0


```

`pkg/rules/_fixtures/merged_filters/filter2.yml`:

```yml
name: match http connections
id: 7f36f8e0-a5c2-498f-9563-eea306daa586
version: 1.0.0
condition: evt.name = 'Recv' and net.dport = 80
min-engine-version: 2.0.0

```

`pkg/rules/_fixtures/merged_filters/filter3.yml`:

```yml
name: match http connections
id: 6f36f8e0-a5c2-498f-9563-eea306daa586
version: 1.0.0
condition: evt.category = 'net' and net.dport = 80
min-engine-version: 2.0.0

```

`pkg/rules/_fixtures/merged_filters/filter4.yml`:

```yml
name: match ssh connections
id: 5f36f8e0-a5c2-498f-9563-eea306daa586
version: 1.0.0
condition: evt.name = 'Recv' and net.dport = 22
min-engine-version: 2.0.0

```

`pkg/rules/_fixtures/min_engine_version/fail/filter1.yml`:

```yml
name: match https connections
id: 1f36f8e0-a5c2-498f-9563-eea306daa586
version: 1.0.0
condition: evt.name = 'Recv' and net.dport = 443
min-engine-version: 1.0.0

```

`pkg/rules/_fixtures/min_engine_version/fail/filter2.yml`:

```yml
name: accept events where source port = 44123
id: 2f36f8e0-a5c2-498f-9563-eea306daa586
version: 1.0.0
condition: evt.name = 'Recv' and net.sport = 44123
min-engine-version: 2.2.0

```

`pkg/rules/_fixtures/min_engine_version/fail/filter3.yml`:

```yml
name: src ip address is not a loopback address
id: 3f36f8e0-a5c2-498f-9563-eea306daa586
version: 1.0.0
condition:  evt.name = 'Recv' and net.sip != 127.0.0.1
min-engine-version: 1.5.0

```

`pkg/rules/_fixtures/min_engine_version/ok/filter1.yml`:

```yml
name: match https connections
id: a155539d-31bd-429e-81f9-c17ee1c01f93
version: 1.0.0
condition: evt.name = 'Recv' and net.dport = 443
min-engine-version: 2.0.0

```

`pkg/rules/_fixtures/min_engine_version/ok/filter2.yml`:

```yml
name: accept events where source port = 44123
id: 1155539d-31bd-429e-81f9-c17ee1c01f93
version: 1.0.0
condition: evt.name = 'Recv' and net.sport = 44123
min-engine-version: 1.8.0

```

`pkg/rules/_fixtures/min_engine_version/ok/filter3.yml`:

```yml
name: src ip address is not a loopback address
id: 2155539d-31bd-429e-81f9-c17ee1c01f93
version: 1.0.0
condition:  evt.name = 'Recv' and net.sip != 127.0.0.1
min-engine-version: 1.5.0

```

`pkg/rules/_fixtures/sequence_rule_complex.yml`:

```yml
name: Phishing dropper outbound communication
id: 572902be-76e9-4ee7-a48a-6275fa571cf4
version: 1.0.0
condition: >
  sequence
  maxspan 1h
  |evt.name = 'CreateProcess' and ps.name
      in
  ('firefox.exe', 'chrome.exe', 'edge.exe')
  | by ps.pid
  |evt.name = 'CreateFile' and file.operation = 'CREATE'
      and
  file.extension = '.exe'
  | by ps.pid
  |
    evt.name in ('Send', 'Connect')
  | by ps.pid
output: "%2.ps.name process initiated outbound communication to %3.net.dip"
min-engine-version: 2.0.0

```

`pkg/rules/_fixtures/sequence_rule_ps_uuid.yml`:

```yml
name: Unique process id
id: 872902be-76e9-4ee7-a48a-6275fa571cf4
version: 1.0.0
condition: >
  sequence
  maxspan 1h
  by ps.uuid
    |evt.name = 'CreateProcess' and ps.name
        in
    ('firefox.exe', 'chrome.exe', 'edge.exe')
    |
    |evt.name = 'CreateFile' and file.operation = 'CREATE'
        and
    file.extension = '.exe'
    |
min-engine-version: 2.0.0

```

`pkg/rules/_fixtures/simple_and_sequence_rules/command_shell_spawned_chrome_browser.yml`:

```yml
name: Command shell spawned Chrome browser
id: 2155539d-31bd-429e-81f9-c17ee1c01f93
version: 1.0.0
condition: >
  sequence maxspan 1s
  |evt.name = 'CreateProcess' and ps.name = 'powershell.exe'| by ps.pid
  |evt.name = 'CreateProcess' and ps.name = 'chrome.exe'| by ps.pid
min-engine-version: 2.0.0

```

`pkg/rules/_fixtures/simple_and_sequence_rules/powershell_created_temp_file.yml`:

```yml
name: Powershell created a temp file
id: 3155539d-31bd-429e-81f9-c17ee1c01f93
version: 1.0.0
condition: >
  sequence
  maxspan 100ms
  |evt.name = 'CreateProcess' and ps.name = 'powershell.exe'| by ps.pid
  |evt.name = 'CreateFile'
      and
   file.path icontains 'temp'
  | by ps.pid
min-engine-version: 2.0.0

```

`pkg/rules/_fixtures/simple_and_sequence_rules/powershell_process_spawned.yml`:

```yml
name: Powershell process spawned
id: 4155539d-31bd-429e-81f9-c17ee1c01f93
version: 1.0.0
condition: >
  evt.name = 'CreateProcess' and ps.name = 'powershell.exe'
min-engine-version: 2.0.0

```

`pkg/rules/_fixtures/simple_and_sequence_rules/spawn_chrome_browser.yml`:

```yml
name: Spawn Chrome browser
id: 5155539d-31bd-429e-81f9-c17ee1c01f93
version: 1.0.0
condition: >
  evt.name = 'CreateProcess' and ps.name = 'chrome.exe'
min-engine-version: 2.0.0

```

`pkg/rules/_fixtures/simple_emit_alert.yml`:

```yml
name: match https connections
id: 50ffc2a8-0bde-45c4-9e20-46158250fa91
version: 1.0.0
condition: evt.name = 'Recv' and net.dport = 443
output: "%ps.name process received data on port %net.dport"
severity: critical
min-engine-version: 2.0.0
tags:
  - tag1
  - tag2

```

`pkg/rules/_fixtures/simple_matches.yml`:

```yml
name: match https connections
id: 60ffc2a8-0bde-45c4-9e20-46158250fa91
version: 1.0.0
condition: evt.name = 'Recv' and net.dport = 443
min-engine-version: 2.0.0

```

`pkg/rules/_fixtures/simple_matches/filter1.yml`:

```yml
name: match https connections
id: 5155539d-31bd-429e-81f9-c17ee1c01f93
version: 1.0.0
condition: evt.name = 'Recv' and net.dport = 443
min-engine-version: 2.0.0

```

`pkg/rules/_fixtures/simple_matches/filter2.yml`:

```yml
name: accept events where source port = 44123
id: 6155539d-31bd-429e-81f9-c17ee1c01f93
version: 1.0.0
condition: evt.name = 'Recv' and net.sport = 44123
min-engine-version: 2.0.0

```

`pkg/rules/_fixtures/simple_matches/filter3.yml`:

```yml
name: src ip address is not a loopback address
id: 7155539d-31bd-429e-81f9-c17ee1c01f93
version: 1.0.0
condition: evt.name = 'Recv' and net.sip != 127.0.0.1
min-engine-version: 2.0.0

```

`pkg/rules/_fixtures/simple_matches/filter4.yml`:

```yml
name: src ip address is
id: 8155539d-31bd-429e-81f9-c17ee1c01f93
version: 1.0.0
condition: evt.name = 'Recv' and net.sip = 172.0.0.1
min-engine-version: 2.0.0

```

`pkg/rules/action/alert.go`:

```go
/*
 * Copyright 2021-2022 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package action

import (
	"fmt"
	"github.com/rabbitstack/fibratus/pkg/alertsender"
	"github.com/rabbitstack/fibratus/pkg/config"
	"github.com/rabbitstack/fibratus/pkg/util/markdown"
	log "github.com/sirupsen/logrus"
	"strings"
)

// Alert sends the rule alert via all configured alert senders.
func Alert(ctx *config.ActionContext, title string, text string, severity string, tags []string) error {
	var b strings.Builder
	for _, evt := range ctx.Events {
		b.WriteString(evt.String())
		b.WriteByte('\n')
	}
	log.Infof("sending alert: [%s]. Text: %s Event(s): %s", title, text, b.String())

	senders := alertsender.FindAll()
	if len(senders) == 0 {
		return fmt.Errorf("no alertsenders registered. Alert won't be sent")
	}

	for _, sender := range senders {
		alert := alertsender.NewAlert(
			title,
			text,
			tags,
			alertsender.ParseSeverityFromString(severity),
		)

		alert.ID = ctx.Filter.ID
		alert.Events = ctx.Events
		alert.Labels = ctx.Filter.Labels
		alert.Description = ctx.Filter.Description

		// strip markdown if not supported by the sender
		if !sender.SupportsMarkdown() {
			alert.Text = markdown.Strip(alert.Text)
		}

		err := sender.Send(alert)
		if err != nil {
			return fmt.Errorf("unable to emit alert from rule via [%s] sender: %v", sender.Type(), err)
		}
	}

	return nil
}

```

`pkg/rules/action/isolate_windows.go`:

```go
/*
 * Copyright 2021-present by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package action

import (
	"github.com/rabbitstack/fibratus/pkg/util/multierror"
	"github.com/tailscale/wf"
	"golang.org/x/sys/windows"
	"net"
	"net/netip"
	"sync"
)

var (
	inboundAllowRuleID  = wf.RuleID(windows.GUID{Data1: 0xcc2d6ce, Data2: 0xe747, Data3: 0x4480, Data4: [8]byte{0x9b, 0xbd, 0x7f, 0xa8, 0x99, 0xb7, 0xb1, 0x9a}})
	outboundAllowRuleID = wf.RuleID(windows.GUID{Data1: 0x4480ae, Data2: 0x9b7f, Data3: 0xa899, Data4: [8]byte{0xbd, 0x9b, 0xa8, 0xb7, 0x7f, 0x99, 0xe7, 0x1a}})
	inboundDenyRuleID   = wf.RuleID(windows.GUID{Data1: 0x7f9bbc, Data2: 0x99b7, Data3: 0xe747, Data4: [8]byte{0x9a, 0x9b, 0xa8, 0xbd, 0x44, 0x80, 0xcc, 0xc1}})
	outboundDenyRuleID  = wf.RuleID(windows.GUID{Data1: 0xbd9bda, Data2: 0x7fa8, Data3: 0x99b7, Data4: [8]byte{0xcc, 0x44, 0x9a, 0x9b, 0xe7, 0x77, 0x47, 0xd1}})
)

var (
	// inboundAllowRuleName denotes the firewall rule name for allowed inbound traffic
	inboundAllowRuleName = "Fibratus Allow (Inbound)"
	// outboundAllowRuleName denotes the firewall rule name for allowed outbound traffic
	outboundAllowRuleName = "Fibratus Allow (Outbound)"
	// inboundDenyRuleName denotes the firewall rule name for isolated inbound traffic
	inboundDenyRuleName = "Fibratus Isolate (Inbound)"
	// outboundDenyRuleName denotes the firewall rule name for isolated outbound traffic
	outboundDenyRuleName = "Fibratus Isolate (Outbound)"
)

type firewall struct {
	s        *wf.Session
	mu       sync.Mutex
	inbound  *wf.Rule // rule for allowed inbound traffic
	outbound *wf.Rule // rule for allowed outbound traffic
}

func newFirewall() (*firewall, error) {
	opts := &wf.Options{
		Dynamic: true, // remove filters when the process terminates
	}

	sess, err := wf.New(opts)
	if err != nil {
		return nil, err
	}

	return &firewall{s: sess}, nil
}

func (f *firewall) allow(whitelist []net.IP) error {
	f.mu.Lock()
	defer f.mu.Unlock()
	f.inbound = &wf.Rule{
		ID:         inboundAllowRuleID,
		Name:       inboundAllowRuleName,
		Layer:      wf.LayerInboundIPPacketV4,
		Action:     wf.ActionPermit,
		Conditions: make([]*wf.Match, 0),
	}

	f.outbound = &wf.Rule{
		ID:         outboundAllowRuleID,
		Name:       outboundAllowRuleName,
		Layer:      wf.LayerOutboundIPPacketV4,
		Action:     wf.ActionPermit,
		Conditions: make([]*wf.Match, 0),
	}

	// The current limitation of the fw
	// library, makes it impossible to
	// install a filter with multiple IP
	// addresses, so we shrink the list
	// to use a single item
	if len(whitelist) > 0 {
		whitelist = whitelist[:1]
	}

	for _, addr := range whitelist {
		f.addIPCondition(addr)
	}

	return multierror.Wrap(f.s.AddRule(f.inbound), f.s.AddRule(f.outbound))
}

func (f *firewall) deny() error {
	f.mu.Lock()
	defer f.mu.Unlock()
	in := &wf.Rule{
		ID:     inboundDenyRuleID,
		Name:   inboundDenyRuleName,
		Layer:  wf.LayerInboundIPPacketV4,
		Action: wf.ActionBlock,
	}

	out := &wf.Rule{
		ID:     outboundDenyRuleID,
		Name:   outboundDenyRuleName,
		Layer:  wf.LayerOutboundIPPacketV4,
		Action: wf.ActionBlock,
	}

	return multierror.Wrap(f.s.AddRule(in), f.s.AddRule(out))
}

func (f *firewall) findAllowRules() error {
	f.mu.Lock()
	defer f.mu.Unlock()

	if f.inbound != nil && f.outbound != nil {
		return nil
	}
	rules, err := f.s.Rules()
	if err != nil {
		return err
	}

	for _, rule := range rules {
		switch rule.ID {
		case inboundAllowRuleID:
			f.inbound = rule
		case outboundAllowRuleID:
			f.outbound = rule
		}
		if f.inbound != nil && f.outbound != nil {
			break
		}
	}

	return nil
}

//nolint:unused
func (f *firewall) removeAllowRules() error {
	f.mu.Lock()
	defer f.mu.Unlock()
	return multierror.Wrap(f.s.DeleteRule(inboundAllowRuleID), f.s.DeleteRule(outboundAllowRuleID))
}

func (f *firewall) hasAllowRules() bool {
	f.mu.Lock()
	defer f.mu.Unlock()
	return f.inbound != nil && f.outbound != nil
}

func (f *firewall) addIPCondition(addr net.IP) {
	ip, err := netip.ParseAddr(addr.String())
	if err == nil {
		f.inbound.Conditions = append(f.inbound.Conditions, &wf.Match{Field: wf.FieldIPLocalAddress, Op: wf.MatchTypeEqual, Value: ip})
		f.inbound.Conditions = append(f.inbound.Conditions, &wf.Match{Field: wf.FieldIPRemoteAddress, Op: wf.MatchTypeEqual, Value: ip})
		f.outbound.Conditions = append(f.outbound.Conditions, &wf.Match{Field: wf.FieldIPLocalAddress, Op: wf.MatchTypeEqual, Value: ip})
		f.outbound.Conditions = append(f.outbound.Conditions, &wf.Match{Field: wf.FieldIPRemoteAddress, Op: wf.MatchTypeEqual, Value: ip})
	}
}

//nolint:unused
func (f *firewall) hasIPCondition(addr net.IP) bool {
	f.mu.Lock()
	defer f.mu.Unlock()
	for _, c := range f.inbound.Conditions {
		if c.Field != wf.FieldIPLocalAddress && c.Field != wf.FieldIPRemoteAddress {
			continue
		}

		address, ok := c.Value.(netip.Addr)
		if !ok {
			continue
		}

		netaddr, err := netip.ParseAddr(addr.String())
		if err != nil {
			continue
		}

		if netaddr == address {
			return true
		}
	}

	for _, c := range f.outbound.Conditions {
		if c.Field != wf.FieldIPLocalAddress && c.Field != wf.FieldIPRemoteAddress {
			continue
		}

		address, ok := c.Value.(netip.Addr)
		if !ok {
			continue
		}

		netaddr, err := netip.ParseAddr(addr.String())
		if err != nil {
			continue
		}

		if netaddr == address {
			return true
		}
	}

	return false
}

var fw *firewall

// Isolate talks to the WFP (Windows Filtering Platform) engine to
// set up firewall rules that result in complete host isolation.
// The traffic is allowed for the IP addresses specified in the
// permitted parameter.
// If the firewall rules already exist and the whitelist IP addresses
// are given, the rules are first removed and then recreated with the new
// allowed IP set.
func Isolate(whitelist []net.IP) error {
	if fw == nil {
		var err error
		fw, err = newFirewall()
		if err != nil {
			return err
		}
	}

	if err := fw.findAllowRules(); err != nil {
		return err
	}

	switch {
	case fw.hasAllowRules():
		// rules were added and no new permitted
		// addresses are supplied in the action
		return nil
	default:
		// rules were not added, so we set up
		// the rule to allow localhost in/out
		// traffic in addition to permitted
		// IP address.
		// Block the remaining in/out traffic
		if err := fw.allow(whitelist); err != nil {
			return err
		}
		return fw.deny()
	}
}

```

`pkg/rules/action/kill_windows.go`:

```go
/*
 * Copyright 2021-2022 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package action

import (
	"fmt"
	"github.com/rabbitstack/fibratus/pkg/util/multierror"
	"golang.org/x/sys/windows"
	"os"
	"syscall"
)

// Kill terminates all processes with specified pids.
func Kill(pids []uint32) error {
	errs := make([]error, 0)
	for _, pid := range pids {
		err := terminate(pid)
		if err != nil {
			errs = append(errs, err)
		}
	}
	return multierror.Wrap(errs...)
}

func terminate(pid uint32) error {
	proc, err := windows.OpenProcess(syscall.PROCESS_TERMINATE, false, pid)
	if err != nil {
		errno, ok := err.(windows.Errno)
		if ok && (errno.Is(os.ErrNotExist) || err == windows.ERROR_INVALID_PARAMETER) {
			return nil
		}
		return fmt.Errorf("couldn't open pid %d for termination: %v", pid, err)
	}
	defer func() {
		_ = windows.CloseHandle(proc)
	}()
	err = windows.TerminateProcess(proc, uint32(1))
	if err != nil {
		return fmt.Errorf("failed to kill pid %d: %v", pid, err)
	}
	return nil
}

```

`pkg/rules/compiler.go`:

```go
/*
 * Copyright 2021-present by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package rules

import (
	"expvar"
	"fmt"
	semver "github.com/hashicorp/go-version"
	"github.com/rabbitstack/fibratus/pkg/config"
	"github.com/rabbitstack/fibratus/pkg/event"
	"github.com/rabbitstack/fibratus/pkg/filter"
	"github.com/rabbitstack/fibratus/pkg/filter/fields"
	"github.com/rabbitstack/fibratus/pkg/ps"
	"github.com/rabbitstack/fibratus/pkg/util/version"
	log "github.com/sirupsen/logrus"
)

var (
	// filtersCount computes the total number of filters in the ruleset
	filtersCount = expvar.NewInt("filter.filters.count")

	ErrInvalidFilter = func(rule string, err error) error {
		return fmt.Errorf("syntax error in rule %q: \n%v", rule, err)
	}
	ErrIncompatibleFilter = func(rule, v string) error {
		return fmt.Errorf("rule %q needs engine version [%s] but current version is [%s]", rule, v, version.Get())
	}
	ErrMalformedMinEngineVer = func(rule, v string, err error) error {
		return fmt.Errorf("rule %q has a malformed minimum engine version: %s: %v", rule, v, err)
	}
	ErrUnknownEventName = func(rule, name string) error {
		return fmt.Errorf("rule %s references an invalid event name %q in the evt.name field", rule, name)
	}
	ErrUnknownCategoryName = func(rule, name string) error {
		return fmt.Errorf("rule %s references an invalid event category %q in the evt.category field", rule, name)
	}
)

type compiler struct {
	psnap  ps.Snapshotter
	config *config.Config
}

func newCompiler(psnap ps.Snapshotter, config *config.Config) *compiler {
	return &compiler{psnap: psnap, config: config}
}

func (c *compiler) compile() (map[*config.FilterConfig]filter.Filter, *config.RulesCompileResult, error) {
	if err := c.config.Filters.LoadMacros(); err != nil {
		return nil, nil, err
	}
	if err := c.config.Filters.LoadFilters(); err != nil {
		return nil, nil, err
	}

	filters := make(map[*config.FilterConfig]filter.Filter)

	for _, f := range c.config.GetFilters() {
		if f.IsDisabled() {
			log.Warnf("[%s] rule is disabled", f.Name)
			continue
		}

		filtersCount.Add(1)

		// compile the filter
		fltr := filter.New(f.Condition, c.config, filter.WithPSnapshotter(c.psnap))
		err := fltr.Compile()
		if err != nil {
			return nil, nil, ErrInvalidFilter(f.Name, err)
		}
		// check version requirements
		if !version.IsDev() {
			minEngineVer, err := semver.NewSemver(f.MinEngineVersion)
			if err != nil {
				return nil, nil, ErrMalformedMinEngineVer(f.Name, f.MinEngineVersion, err)
			}
			if minEngineVer.GreaterThan(version.Sem()) {
				return nil, nil, ErrIncompatibleFilter(f.Name, f.MinEngineVersion)
			}
		}

		// output warning for deprecated fields
		for _, field := range fltr.GetFields() {
			deprecated, d := fields.IsDeprecated(field.Name)
			if deprecated {
				log.Warnf("%s rule uses the [%s] field which "+
					"was deprecated starting from version %s. "+
					"Please consider migrating to %s field(s) "+
					"because [%s] will be removed in future versions.",
					f.Name, field.Name, d.Since, d.Fields, field.Name)
			}
		}

		// validate the value of the event/category fields
		for field, values := range fltr.GetStringFields() {
			for _, v := range values {
				switch field {
				case fields.EvtName, fields.KevtName:
					if !event.IsKnown(v) {
						return nil, nil, ErrUnknownEventName(f.Name, v)
					}
				case fields.EvtCategory, fields.KevtCategory:
					if !event.IsCategoryKnown(v) {
						return nil, nil, ErrUnknownCategoryName(f.Name, v)
					}
				}
			}
		}

		filters[f] = fltr
	}

	if len(filters) == 0 {
		return filters, nil, nil
	}

	return filters, c.buildCompileResult(filters), nil
}

func (c *compiler) buildCompileResult(filters map[*config.FilterConfig]filter.Filter) *config.RulesCompileResult {
	rs := &config.RulesCompileResult{}

	m := make(map[event.Type]bool)
	events := make([]event.Type, 0)

	for _, f := range filters {
		rs.NumberRules++
		for name, values := range f.GetStringFields() {
			for _, v := range values {
				if name == fields.EvtName || name == fields.EvtCategory {
					types := event.NameToTypes(v)
					for _, typ := range types {
						switch typ.Category() {
						case event.Process:
							rs.HasProcEvents = true
						case event.Thread:
							rs.HasThreadEvents = true
						case event.Image:
							rs.HasImageEvents = true
						case event.File:
							rs.HasFileEvents = true
						case event.Net:
							rs.HasNetworkEvents = true
						case event.Registry:
							rs.HasRegistryEvents = true
						case event.Mem:
							rs.HasMemEvents = true
						case event.Handle:
							rs.HasHandleEvents = true
						case event.Threadpool:
							rs.HasThreadpoolEvents = true
						}
						if typ.Subcategory() == event.DNS {
							rs.HasDNSEvents = true
						}
						if typ == event.MapViewFile || typ == event.UnmapViewFile {
							rs.HasVAMapEvents = true
						}
						if typ == event.OpenProcess || typ == event.OpenThread || typ == event.SetThreadContext ||
							typ == event.CreateSymbolicLinkObject {
							rs.HasAuditAPIEvents = true
						}

						if m[typ] {
							continue
						}

						events = append(events, typ)
						m[typ] = true
					}
				}
			}
		}
	}

	rs.UsedEvents = events

	return rs
}

```

`pkg/rules/compiler_test.go`:

```go
/*
 * Copyright 2021-present by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package rules

import (
	"github.com/rabbitstack/fibratus/pkg/event"
	"github.com/rabbitstack/fibratus/pkg/ps"
	"github.com/rabbitstack/fibratus/pkg/util/version"
	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/require"
	"testing"
)

func TestCompile(t *testing.T) {
	c := newCompiler(new(ps.SnapshotterMock), newConfig("_fixtures/default/*.yml"))
	filters, rs, err := c.compile()
	require.NoError(t, err)
	require.NotNil(t, rs)
	require.Len(t, filters, 6)

	assert.True(t, rs.HasImageEvents)
	assert.True(t, rs.HasProcEvents)
	assert.False(t, rs.HasMemEvents)
	assert.False(t, rs.HasAuditAPIEvents)
	assert.True(t, rs.HasDNSEvents)
	assert.Contains(t, rs.UsedEvents, event.CreateProcess)
	assert.Contains(t, rs.UsedEvents, event.LoadImage)
	assert.Contains(t, rs.UsedEvents, event.QueryDNS)
	assert.Contains(t, rs.UsedEvents, event.ConnectTCPv4)
	assert.Contains(t, rs.UsedEvents, event.ConnectTCPv6)
}

func TestCompileMinEngineVersion(t *testing.T) {
	var tests = []struct {
		rules string
		ver   string
		e     string
	}{
		{"_fixtures/min_engine_version/fail/*.yml", "2.0.0", `rule "accept events where source port = 44123" needs engine version [2.2.0] but current version is [2.0.0]`},
		{"_fixtures/min_engine_version/ok/*.yml", "2.0.0", ""},
	}

	for _, tt := range tests {
		t.Run(tt.rules, func(t *testing.T) {
			c := newCompiler(new(ps.SnapshotterMock), newConfig(tt.rules))
			version.Set(tt.ver)
			_, _, err := c.compile()
			if err != nil && tt.e == "" {
				require.Error(t, err)
			}
			if err != nil {
				require.EqualError(t, err, tt.e)
			}
		})
	}
}

func TestCompileEventCategoryFieldNames(t *testing.T) {
	var tests = []struct {
		rules string
		err   error
	}{
		{"_fixtures/field_values/correct_event_name_field.yml", nil},
		{"_fixtures/field_values/incorrect_event_name_field.yml", ErrUnknownEventName("match https connections", "RecvTcp4")},
		{"_fixtures/field_values/incorrect_event_name_in_operator.yml", ErrUnknownEventName("match https connections", "CreateProc")},
		{"_fixtures/field_values/correct_category_name_field.yml", nil},
		{"_fixtures/field_values/incorrect_category_name_field.yml", ErrUnknownCategoryName("match https connections", "network")},
	}

	for _, tt := range tests {
		t.Run(tt.rules, func(t *testing.T) {
			c := newCompiler(new(ps.SnapshotterMock), newConfig(tt.rules))
			_, _, err := c.compile()
			if err != nil && tt.err != nil {
				require.Error(t, err)
			}
			if err != nil {
				require.EqualError(t, err, tt.err.Error())
			}
		})
	}
}

```

`pkg/rules/doc.go`:

```go
/*
 * Copyright 2021-present by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

// Package rules provides the implementation of the rule engine for both
// simple filter expressions and sequences.
package rules

```

`pkg/rules/engine.go`:

```go
/*
 * Copyright 2021-present by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package rules

import (
	"expvar"
	"fmt"
	"github.com/rabbitstack/fibratus/pkg/config"
	"github.com/rabbitstack/fibratus/pkg/event"
	"github.com/rabbitstack/fibratus/pkg/filter"
	"github.com/rabbitstack/fibratus/pkg/filter/fields"
	"github.com/rabbitstack/fibratus/pkg/ps"
	"github.com/rabbitstack/fibratus/pkg/rules/action"
	log "github.com/sirupsen/logrus"
	"sync"
	"time"
)

// RuleMatchFunc is rule match function definition. It accepts
// the filter (rule) config and the group of events that fired
// the rule
type RuleMatchFunc func(f *config.FilterConfig, evts ...*event.Event)

var (
	// sequenceGcInterval determines how often sequence GC kicks in
	sequenceGcInterval = time.Minute

	filterMatches = expvar.NewMap("filter.matches")

	ErrRuleAction = func(rule string, err error) error {
		return fmt.Errorf("fail to execute action for %q rule: %v", rule, err)
	}
)

// Engine asserts the full-fledged system event against
// the collection of compiled filters that are derived
// from the loaded ruleset.
type Engine struct {
	filters *filterset
	config  *config.Config
	psnap   ps.Snapshotter

	matches   []*ruleMatch
	mmu       sync.Mutex // guards the rule matches slice
	sequences []*sequenceState

	scavenger *time.Ticker

	compiler *compiler

	matchFunc RuleMatchFunc
}

type ruleMatch struct {
	ctx *config.ActionContext
}

type compiledFilter struct {
	filter filter.Filter
	config *config.FilterConfig
	ss     *sequenceState
}

// filterset contains compiled filters indexed by event type and category.
type filterset struct {
	types      map[event.Type][]*compiledFilter
	categories map[uint8][]*compiledFilter
}

func newFilterset() *filterset {
	fs := &filterset{
		types:      make(map[event.Type][]*compiledFilter),
		categories: make(map[uint8][]*compiledFilter),
	}
	return fs
}

func (f *filterset) empty() bool {
	return len(f.types) == 0 && len(f.categories) == 0
}

func (f *filterset) collect(e *event.Event) []*compiledFilter {
	if len(f.categories) == 0 {
		return f.types[e.Type]
	}
	return append(f.types[e.Type], f.categories[e.Category.Index()]...)
}

func newCompiledFilter(f filter.Filter, c *config.FilterConfig, ss *sequenceState) *compiledFilter {
	return &compiledFilter{filter: f, config: c, ss: ss}
}

// isScoped determines if this filter is scoped, i.e. it has the event name or category
// conditions.
func (f *compiledFilter) isScoped() bool {
	for name := range f.filter.GetStringFields() {
		if name == fields.EvtName || name == fields.EvtCategory {
			return true
		}
	}
	return false
}

func (f *compiledFilter) isSequence() bool {
	return f.ss != nil
}

func (f *compiledFilter) run(e *event.Event) bool {
	if f.ss != nil {
		return f.ss.runSequence(e)
	}
	return f.filter.Run(e)
}

// NewEngine builds a fresh rules engine instance.
func NewEngine(psnap ps.Snapshotter, config *config.Config) *Engine {
	e := &Engine{
		filters:   newFilterset(),
		matches:   make([]*ruleMatch, 0),
		sequences: make([]*sequenceState, 0),
		psnap:     psnap,
		config:    config,
		scavenger: time.NewTicker(sequenceGcInterval),
		compiler:  newCompiler(psnap, config),
	}

	go e.gcSequences()

	return e
}

func (e *Engine) gcSequences() {
	for {
		<-e.scavenger.C
		for _, seq := range e.sequences {
			seq.gc()
		}
	}
}

// Compile loads macros/rules and builds an indexable filter set.
// For every rule in the ruleset the condition is compiled and
// converted into a filter. The filter is indexed by either the
// event name or event category.
func (e *Engine) Compile() (*config.RulesCompileResult, error) {
	filters, rs, err := e.compiler.compile()
	if err != nil {
		return nil, err
	}

	for c, f := range filters {
		var ss *sequenceState
		if f.IsSequence() {
			ss = newSequenceState(f, c, e.psnap)
		}
		fltr := newCompiledFilter(f, c, ss)
		if ss != nil {
			// store the sequences in engine
			// for more convenient tracking
			e.sequences = append(e.sequences, ss)
		}

		if !fltr.isScoped() {
			log.Warnf("%q rule doesn't have "+
				"event type or event category condition! "+
				"This rule is being discarded by "+
				"the engine. Please consider narrowing the "+
				"scope of the rule by including the `evt.name` "+
				"or `evt.category` condition",
				c.Name)
			continue
		}

		// traverse all event name or category fields and determine
		// the event type from the filter field name expression.
		// We end up with a map of rules indexed by event type
		// or event category
		for name, values := range f.GetStringFields() {
			for _, v := range values {
				switch name {
				case fields.EvtName:
					for _, typ := range event.NameToTypes(v) {
						e.filters.types[typ] = append(e.filters.types[typ], fltr)
					}
				case fields.EvtCategory:
					category := event.Category(v)
					e.filters.categories[category.Index()] = append(e.filters.categories[category.Index()], fltr)
				}
			}
		}
	}

	return rs, nil
}

func (e *Engine) RegisterMatchFunc(fn RuleMatchFunc) {
	e.matchFunc = fn
}

func (*Engine) CanEnqueue() bool { return true }

// ProcessEvent processes the system event against compiled filters.
// Filter is the internal lingo that designates a rule condition.
// Filters can be simple direct-event matchers or sequence states that
// track an ordered series of events over a short period of time.
func (e *Engine) ProcessEvent(evt *event.Event) (bool, error) {
	if e.filters.empty() {
		return true, nil
	}

	if evt.IsTerminateProcess() {
		// expire all sequences if the
		// process referenced in any
		// partials has terminated
		for _, seq := range e.sequences {
			seq.expire(evt)
		}
	}

	filters := e.filters.collect(evt)

	var matches bool
	for _, f := range filters {
		match := f.run(evt)
		if !match {
			continue
		}
		if f.isSequence() {
			e.appendMatch(f.config, f.ss.events()...)
			f.ss.clearLocked()
		} else {
			e.appendMatch(f.config, evt)
		}
		err := e.processActions()
		if err != nil {
			log.Errorf("unable to execute rule action: %v", err)
		}
		switch {
		case e.config.Filters.MatchAll:
			matches = true
		default:
			return true, nil
		}
	}

	return matches, nil
}

// processActions executes rule actions
// on behalf of rule matches. Actions are
// categorized into implicit and explicit
// actions.
// Sending an alert is an implicit action
// carried out each time there is a rule
// match. Other actions are executed if
// declared in the rule definition.
func (e *Engine) processActions() error {
	defer e.clearMatches()
	e.mmu.Lock()
	defer e.mmu.Unlock()
	for _, m := range e.matches {
		f, evts := m.ctx.Filter, m.ctx.Events
		filterMatches.Add(f.Name, 1)
		log.Debugf("[%s] rule matched", f.Name)
		err := action.Alert(m.ctx, f.Name, filter.InterpolateFields(f.Output, evts), f.Severity, f.Tags)
		if err != nil {
			return ErrRuleAction(f.Name, err)
		}

		actions, err := f.DecodeActions()
		if err != nil {
			return err
		}

		for _, act := range actions {
			switch t := act.(type) {
			case config.KillAction:
				log.Infof("executing kill action: pids=%v rule=%s", m.ctx.UniquePids(), f.Name)
				if err := action.Kill(m.ctx.UniquePids()); err != nil {
					return ErrRuleAction(f.Name, err)
				}
			case config.IsolateAction:
				log.Infof("executing isolate action: rule=%s", f.Name)
				if err := action.Isolate(t.Whitelist); err != nil {
					return ErrRuleAction(f.Name, err)
				}
			}
		}
	}

	return nil
}

func (e *Engine) appendMatch(f *config.FilterConfig, evts ...*event.Event) {
	for _, evt := range evts {
		evt.AddMeta(event.RuleNameKey, f.Name)
		for k, v := range f.Labels {
			evt.AddMeta(event.MetadataKey(k), v)
		}
	}
	ctx := &config.ActionContext{
		Events: evts,
		Filter: f,
	}
	e.mmu.Lock()
	defer e.mmu.Unlock()
	e.matches = append(e.matches, &ruleMatch{ctx: ctx})
	if e.matchFunc != nil {
		e.matchFunc(f, evts...)
	}
}

func (e *Engine) clearMatches() {
	e.mmu.Lock()
	defer e.mmu.Unlock()
	e.matches = make([]*ruleMatch, 0)
}

```

`pkg/rules/engine_test.go`:

```go
/*
 * Copyright 2021-present by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package rules

import (
	"net"
	"os"
	"testing"
	"time"

	"github.com/rabbitstack/fibratus/pkg/alertsender"
	"github.com/rabbitstack/fibratus/pkg/config"
	"github.com/rabbitstack/fibratus/pkg/event"
	"github.com/rabbitstack/fibratus/pkg/event/params"
	"github.com/rabbitstack/fibratus/pkg/fs"
	"github.com/rabbitstack/fibratus/pkg/ps"
	"github.com/rabbitstack/fibratus/pkg/ps/types"
	"github.com/rabbitstack/fibratus/pkg/sys"
	log "github.com/sirupsen/logrus"
	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/require"
	"golang.org/x/sys/windows"
)

type mockNoopSender struct{}
type mockNoneSender struct{}

var emitAlert *alertsender.Alert
var seqAlert *alertsender.Alert

func (s *mockNoopSender) Send(a alertsender.Alert) error {
	emitAlert = &a
	return nil
}

func (s *mockNoopSender) Type() alertsender.Type {
	return alertsender.Noop
}

func (s *mockNoopSender) Shutdown() error        { return nil }
func (s *mockNoopSender) SupportsMarkdown() bool { return true }

func makeNoopSender(config alertsender.Config) (alertsender.Sender, error) {
	return &mockNoopSender{}, nil
}

func (s *mockNoneSender) Send(a alertsender.Alert) error {
	seqAlert = &a
	return nil
}

func (s *mockNoneSender) Type() alertsender.Type {
	return alertsender.None
}

func (s *mockNoneSender) Shutdown() error        { return nil }
func (s *mockNoneSender) SupportsMarkdown() bool { return true }

func makeNoneSender(config alertsender.Config) (alertsender.Sender, error) {
	return &mockNoneSender{}, nil
}

func init() {
	alertsender.Register(alertsender.Noop, makeNoopSender)
	alertsender.Register(alertsender.None, makeNoneSender)
}

func newConfig(fromFiles ...string) *config.Config {
	c := &config.Config{
		EventSource: config.EventSourceConfig{
			EnableHandleEvents:   true,
			EnableNetEvents:      true,
			EnableRegistryEvents: true,
			EnableFileIOEvents:   true,
			EnableImageEvents:    true,
			EnableThreadEvents:   true,
		},
		Filters: &config.Filters{
			Rules: config.Rules{
				FromPaths: fromFiles,
			},
		},
	}
	return c
}

func compileRules(t *testing.T, e *Engine) {
	rs, err := e.Compile()
	require.NoError(t, err)
	require.NotNil(t, rs)
}

func wrapProcessEvent(e *event.Event, fn func(*event.Event) (bool, error)) bool {
	match, err := fn(e)
	if err != nil {
		panic(err)
	}
	return match
}

func fireRules(t *testing.T, c *config.Config) bool {
	e := NewEngine(new(ps.SnapshotterMock), c)
	evt := &event.Event{
		Type:     event.RecvTCPv4,
		Name:     "Recv",
		Tid:      2484,
		PID:      859,
		Category: event.Net,
		Params: event.Params{
			params.NetDport: {Name: params.NetDport, Type: params.Uint16, Value: uint16(443)},
			params.NetSport: {Name: params.NetSport, Type: params.Uint16, Value: uint16(43123)},
			params.NetSIP:   {Name: params.NetSIP, Type: params.IPv4, Value: net.ParseIP("127.0.0.1")},
			params.NetDIP:   {Name: params.NetDIP, Type: params.IPv4, Value: net.ParseIP("216.58.201.174")},
		},
		Metadata: make(map[event.MetadataKey]any),
	}
	compileRules(t, e)
	return wrapProcessEvent(evt, e.ProcessEvent)
}

func TestCompileIndexableFilters(t *testing.T) {
	e := NewEngine(new(ps.SnapshotterMock), newConfig(
		"_fixtures/merged_filters/filter*.yml",
		"_fixtures/default/microsoft_edge.yml",
		"_fixtures/default/windows_error_*.yml"))

	compileRules(t, e)

	assert.Len(t, e.filters.types, 5)
	assert.Len(t, e.filters.categories, 1)

	var tests = []struct {
		evt   *event.Event
		wants int
	}{
		{&event.Event{Type: event.CreateProcess}, 2},
		{&event.Event{Type: event.RecvUDPv6}, 3},
		{&event.Event{Type: event.RecvTCPv4}, 3},
		{&event.Event{Type: event.RecvTCPv4, Category: event.Net}, 4},
		{&event.Event{Category: event.Net}, 1},
	}

	for _, tt := range tests {
		t.Run(tt.evt.Type.String(), func(t *testing.T) {
			assert.Len(t, e.filters.collect(tt.evt), tt.wants)
		})
	}
}

func TestRunSimpleRules(t *testing.T) {
	var tests = []struct {
		config  *config.Config
		matches bool
	}{
		{newConfig("_fixtures/simple_matches.yml"), true},
		{newConfig("_fixtures/simple_matches/filter*.yml"), true},
	}

	for i, tt := range tests {
		matches := fireRules(t, tt.config)
		if matches != tt.matches {
			t.Errorf("%d. %v process rules mismatch: exp=%t got=%t", i, tt.config.Filters, tt.matches, matches)
		}
	}
}

func TestRunSequenceRule(t *testing.T) {
	log.SetLevel(log.DebugLevel)

	e := NewEngine(new(ps.SnapshotterMock), newConfig("_fixtures/sequence_rule_complex.yml"))
	compileRules(t, e)

	e1 := &event.Event{
		Seq:       1,
		Type:      event.CreateProcess,
		Timestamp: time.Now(),
		Category:  event.Process,
		Name:      "CreateProcess",
		Tid:       2484,
		PID:       2243,
		PS: &types.PS{
			Name: "firefox.exe",
			Exe:  "C:\\Program Files\\Firefox\\firefox.exe",
		},
		Params: event.Params{
			params.ProcessID:   {Name: params.ProcessID, Type: params.PID, Value: uint32(2243)},
			params.ProcessName: {Name: params.ProcessName, Type: params.UnicodeString, Value: "firefox.exe"},
		},
		Metadata: map[event.MetadataKey]any{"foo": "bar", "fooz": "barzz"},
	}

	e2 := &event.Event{
		Seq:       2,
		Type:      event.CreateFile,
		Timestamp: time.Now().Add(time.Millisecond * 250),
		Name:      "CreateFile",
		Tid:       2484,
		PID:       2243,
		Category:  event.File,
		PS: &types.PS{
			Name:    "firefox.exe",
			Exe:     "C:\\Program Files\\Mozilla Firefox\\firefox.exe",
			Cmdline: "C:\\Program Files\\Mozilla Firefox\\firefox.exe\" -contentproc --channel=\"10464.7.539748228\\1366525930\" -childID 6 -isF",
		},
		Params: event.Params{
			params.FilePath:      {Name: params.FilePath, Type: params.UnicodeString, Value: "C:\\Temp\\dropper.exe"},
			params.FileOperation: {Name: params.FileOperation, Type: params.Enum, Value: uint32(2), Enum: fs.FileCreateDispositions},
		},
		Metadata: map[event.MetadataKey]any{"foo": "bar", "fooz": "barzz"},
	}

	e3 := &event.Event{
		Seq:       4,
		Type:      event.ConnectTCPv4,
		Timestamp: time.Now().Add(time.Second),
		Category:  event.Net,
		Name:      "Connect",
		Tid:       244,
		PID:       2243,
		PS: &types.PS{
			Name:    "firefox.exe",
			Exe:     "C:\\Program Files\\Mozilla Firefox\\firefox.exe",
			Cmdline: "C:\\Program Files\\Mozilla Firefox\\firefox.exe\" -contentproc --channel=\"10464.7.539748228\\1366525930\" -childID 6 -isF",
		},
		Params: event.Params{
			params.NetDIP: {Name: params.NetDIP, Type: params.IPv4, Value: net.ParseIP("10.0.2.3")},
		},
		Metadata: map[event.MetadataKey]any{"foo": "bar", "fooz": "barzz"},
	}

	// register alert sender
	require.NoError(t, alertsender.LoadAll([]alertsender.Config{{Type: alertsender.None}}))

	require.False(t, wrapProcessEvent(e1, e.ProcessEvent))
	require.False(t, wrapProcessEvent(e2, e.ProcessEvent))

	time.Sleep(time.Millisecond * 30)
	require.True(t, wrapProcessEvent(e3, e.ProcessEvent))

	time.Sleep(time.Millisecond * 50)

	// check the format of the generated alert
	require.NotNil(t, seqAlert)
	assert.Equal(t, "572902be-76e9-4ee7-a48a-6275fa571cf4", seqAlert.ID)
	assert.Len(t, seqAlert.Events, 3)
	assert.Equal(t, "Phishing dropper outbound communication", seqAlert.Title)
	assert.Equal(t, "firefox.exe process initiated outbound communication to 10.0.2.3", seqAlert.Text)
	seqAlert = nil

	// FSM should transition from terminal to initial state
	require.False(t, wrapProcessEvent(e1, e.ProcessEvent))
	require.False(t, wrapProcessEvent(e2, e.ProcessEvent))
	time.Sleep(time.Millisecond * 15)
	require.True(t, wrapProcessEvent(e3, e.ProcessEvent))
}

func TestRunSequenceRuleWithPsUUIDLink(t *testing.T) {
	log.SetLevel(log.DebugLevel)

	e := NewEngine(new(ps.SnapshotterMock), newConfig("_fixtures/sequence_rule_ps_uuid.yml"))
	compileRules(t, e)

	e1 := &event.Event{
		Seq:       1,
		Type:      event.CreateProcess,
		Timestamp: time.Now(),
		Category:  event.Process,
		Name:      "CreateProcess",
		Tid:       2243,
		PID:       uint32(os.Getpid()),
		PS: &types.PS{
			PID:  uint32(os.Getpid()),
			Name: "firefox.exe",
			Exe:  "C:\\Program Files\\Firefox\\firefox.exe",
		},
		Params: event.Params{
			params.ProcessID:   {Name: params.ProcessID, Type: params.PID, Value: uint32(os.Getpid())},
			params.ProcessName: {Name: params.ProcessName, Type: params.UnicodeString, Value: "firefox.exe"},
		},
		Metadata: map[event.MetadataKey]any{"foo": "bar", "fooz": "barzz"},
	}

	e2 := &event.Event{
		Seq:       2,
		Type:      event.CreateFile,
		Timestamp: time.Now().Add(time.Second),
		Name:      "CreateFile",
		Tid:       2484,
		PID:       uint32(os.Getpid()),
		Category:  event.File,
		PS: &types.PS{
			PID:     uint32(os.Getpid()),
			Name:    "firefox.exe",
			Exe:     "C:\\Program Files\\Mozilla Firefox\\firefox.exe",
			Cmdline: "C:\\Program Files\\Mozilla Firefox\\firefox.exe\" -contentproc --channel=\"10464.7.539748228\\1366525930\" -childID 6 -isF",
		},
		Params: event.Params{
			params.FilePath:      {Name: params.FilePath, Type: params.UnicodeString, Value: "C:\\Temp\\dropper.exe"},
			params.FileOperation: {Name: params.FileOperation, Type: params.Enum, Value: uint32(2), Enum: fs.FileCreateDispositions},
		},
		Metadata: map[event.MetadataKey]any{"foo": "bar", "fooz": "barzz"},
	}

	require.False(t, wrapProcessEvent(e1, e.ProcessEvent))
	require.True(t, wrapProcessEvent(e2, e.ProcessEvent))
}

func TestRunSimpleAndSequenceRules(t *testing.T) {
	log.SetLevel(log.DebugLevel)

	expectedMatches := make(map[string][]uint64)
	c := newConfig("_fixtures/simple_and_sequence_rules/*.yml")
	c.Filters.MatchAll = true
	e := NewEngine(new(ps.SnapshotterMock), c)
	e.RegisterMatchFunc(func(f *config.FilterConfig, evts ...*event.Event) {
		ids := make([]uint64, 0)
		for _, evt := range evts {
			ids = append(ids, evt.Seq)
		}
		expectedMatches[f.Name] = ids
	})

	compileRules(t, e)

	evts := []*event.Event{
		{
			Seq:       1,
			Type:      event.CreateProcess,
			Timestamp: time.Now(),
			Category:  event.Process,
			Name:      "CreateProcess",
			Tid:       2484,
			PID:       2243,
			PS: &types.PS{
				Name: "powershell.exe",
				Exe:  "C:\\Windows\\system32\\powershell.exe",
			},
			Params: event.Params{
				params.ProcessID:   {Name: params.ProcessID, Type: params.PID, Value: uint32(2243)},
				params.ProcessName: {Name: params.ProcessName, Type: params.UnicodeString, Value: "powershell.exe"},
			},
			Metadata: map[event.MetadataKey]any{"foo": "bar", "fooz": "barzz"},
		},
		{
			Seq:       2,
			Type:      event.CreateFile,
			Timestamp: time.Now().Add(time.Millisecond * 544),
			Name:      "CreateFile",
			Tid:       2484,
			PID:       2243,
			Category:  event.File,
			PS: &types.PS{
				Name: "cmd.exe",
				Exe:  "C:\\Windows\\system32\\cmd.exe",
			},
			Params: event.Params{
				params.FilePath:      {Name: params.FilePath, Type: params.UnicodeString, Value: "C:\\Temp\\dropper.exe"},
				params.FileOperation: {Name: params.FileOperation, Type: params.Enum, Value: uint32(2)},
			},
			Metadata: map[event.MetadataKey]any{"foo": "bar", "fooz": "barzz"},
		},
		{
			Seq:       10,
			Type:      event.CreateProcess,
			Timestamp: time.Now().Add(time.Second * 2),
			Category:  event.Process,
			Name:      "CreateProcess",
			Tid:       2484,
			PID:       2243,
			PS: &types.PS{
				Name: "chrome.exe",
				Exe:  "C:\\Program Files\\Chrome\\chrome.exe",
				Parent: &types.PS{
					Name: "cmd.exe",
					Exe:  "C:\\Windows\\system32\\cmd.exe",
				},
			},
			Params: event.Params{
				params.ProcessID:   {Name: params.ProcessID, Type: params.PID, Value: uint32(2243)},
				params.ProcessName: {Name: params.ProcessName, Type: params.UnicodeString, Value: "chrome.exe"},
			},
			Metadata: map[event.MetadataKey]any{"foo": "bar", "fooz": "barzz"},
		},
	}

	for _, evt := range evts {
		require.True(t, wrapProcessEvent(evt, e.ProcessEvent))
	}

	assert.Len(t, expectedMatches, 4)

	var tests = []struct {
		rule     string
		eventIDs []uint64
	}{
		{"Powershell process spawned", []uint64{1}},
		{"Powershell created a temp file", []uint64{1, 2}},
		{"Spawn Chrome browser", []uint64{10}},
		{"Command shell spawned Chrome browser", []uint64{1, 10}},
	}

	for _, tt := range tests {
		t.Run(tt.rule, func(t *testing.T) {
			assert.Equal(t, expectedMatches[tt.rule], tt.eventIDs)
		})
	}
}

func TestAlertAction(t *testing.T) {
	require.NoError(t, alertsender.LoadAll([]alertsender.Config{{Type: alertsender.Noop}}))
	e := NewEngine(new(ps.SnapshotterMock), newConfig("_fixtures/simple_emit_alert.yml"))
	compileRules(t, e)

	evt := &event.Event{
		Type:     event.RecvTCPv4,
		Name:     "Recv",
		Tid:      2484,
		PID:      859,
		Category: event.Net,
		PS: &types.PS{
			Name: "cmd.exe",
		},
		Params: event.Params{
			params.NetDport: {Name: params.NetDport, Type: params.Uint16, Value: uint16(443)},
			params.NetSport: {Name: params.NetSport, Type: params.Uint16, Value: uint16(43123)},
			params.NetSIP:   {Name: params.NetSIP, Type: params.IPv4, Value: net.ParseIP("127.0.0.1")},
			params.NetDIP:   {Name: params.NetDIP, Type: params.IPv4, Value: net.ParseIP("216.58.201.174")},
		},
		Metadata: make(map[event.MetadataKey]any),
	}

	require.True(t, wrapProcessEvent(evt, e.ProcessEvent))
	time.Sleep(time.Millisecond * 25)
	require.NotNil(t, emitAlert)
	assert.Equal(t, "match https connections", emitAlert.Title)
	assert.Equal(t, "cmd.exe process received data on port 443", emitAlert.Text)
	assert.Equal(t, alertsender.Critical, emitAlert.Severity)
	assert.Equal(t, []string{"tag1", "tag2"}, emitAlert.Tags)
	emitAlert = nil
}

func TestKillAction(t *testing.T) {
	log.SetLevel(log.DebugLevel)

	e := NewEngine(new(ps.SnapshotterMock), newConfig("_fixtures/kill_action.yml"))
	compileRules(t, e)

	// register alert sender
	require.NoError(t, alertsender.LoadAll([]alertsender.Config{{Type: alertsender.None}}))

	var si windows.StartupInfo
	var pi windows.ProcessInformation
	argv, err := windows.UTF16PtrFromString("calc.exe")
	require.NoError(t, err)
	err = windows.CreateProcess(
		nil,
		argv,
		nil,
		nil,
		true,
		0,
		nil,
		nil,
		&si,
		&pi)
	require.NoError(t, err)

	i := 0
	for !sys.IsProcessRunning(pi.Process) && i < 10 {
		i++
		time.Sleep(time.Millisecond * 100 * time.Duration(i))
	}

	evt := &event.Event{
		Type:      event.CreateProcess,
		Timestamp: time.Now(),
		Name:      "CreateProcess",
		Tid:       2484,
		PID:       pi.ProcessId,
		Category:  event.Process,
		PS: &types.PS{
			Name: "calc.exe",
			Exe:  "C:\\Windows\\system32\\calc.exe",
		},
		Params: event.Params{
			params.ProcessID:   {Name: params.ProcessID, Type: params.PID, Value: pi.ProcessId},
			params.ProcessName: {Name: params.ProcessName, Type: params.UnicodeString, Value: "calc.exe"},
		},
		Metadata: map[event.MetadataKey]any{"foo": "bar", "fooz": "barzz"},
	}

	require.True(t, sys.IsProcessRunning(pi.Process))
	require.True(t, wrapProcessEvent(evt, e.ProcessEvent))
	require.False(t, sys.IsProcessRunning(pi.Process))
}

func BenchmarkRunRules(b *testing.B) {
	b.ReportAllocs()
	e := NewEngine(new(ps.SnapshotterMock), newConfig("_fixtures/default/*.yml"))
	rs, err := e.Compile()
	require.NoError(b, err)
	require.NotNil(b, rs)

	b.ResetTimer()

	evts := []*event.Event{
		{
			Type:     event.ConnectTCPv4,
			Name:     "Recv",
			Tid:      2484,
			PID:      859,
			Category: event.Net,
			PS: &types.PS{
				Name: "cmd.exe",
			},
			Params: event.Params{
				params.NetDport: {Name: params.NetDport, Type: params.Uint16, Value: uint16(443)},
				params.NetSport: {Name: params.NetSport, Type: params.Uint16, Value: uint16(43123)},
				params.NetSIP:   {Name: params.NetSIP, Type: params.IPv4, Value: net.ParseIP("127.0.0.1")},
				params.NetDIP:   {Name: params.NetDIP, Type: params.IPv4, Value: net.ParseIP("216.58.201.174")},
			},
			Metadata: make(map[event.MetadataKey]any),
		},
		{
			Type:     event.CreateProcess,
			Name:     "CreateProcess",
			Category: event.Process,
			Tid:      2484,
			PID:      859,
			PS: &types.PS{
				Name: "powershell.exe",
			},
			Params: event.Params{
				params.ProcessID:       {Name: params.ProcessID, Type: params.PID, Value: 2323},
				params.ProcessParentID: {Name: params.ProcessParentID, Type: params.PID, Value: uint32(8390)},
				params.ProcessName:     {Name: params.ProcessName, Type: params.UnicodeString, Value: "spotify.exe"},
				params.Cmdline:         {Name: params.Cmdline, Type: params.UnicodeString, Value: `C:\Users\admin\AppData\Roaming\Spotify\Spotify.exe --type=crashpad-handler /prefetch:7 --max-uploads=5 --max-db-size=20 --max-db-age=5 --monitor-self-annotation=ptype=crashpad-handler "--metrics-dir=C:\Users\admin\AppData\Local\Spotify\User Data" --url=https://crashdump.spotify.com:443/ --annotation=platform=win32 --annotation=product=spotify --annotation=version=1.1.4.197 --initial-client-data=0x5a4,0x5a0,0x5a8,0x59c,0x5ac,0x6edcbf60,0x6edcbf70,0x6edcbf7c`},
				params.Exe:             {Name: params.Exe, Type: params.UnicodeString, Value: `C:\Users\admin\AppData\Roaming\Spotify\Spotify.exe`},
				params.UserSID:         {Name: params.UserSID, Type: params.UnicodeString, Value: `admin\SYSTEM`},
			},
			Metadata: make(map[event.MetadataKey]any),
		},
		{
			Type:     event.CreateHandle,
			Name:     "CreateHandle",
			Category: event.Handle,
			Tid:      2484,
			PID:      859,
			PS: &types.PS{
				Name: "powershell.exe",
			},
			Params: event.Params{
				params.ProcessID: {Name: params.ProcessID, Type: params.PID, Value: 2323},
			},
			Metadata: make(map[event.MetadataKey]any),
		},
	}

	for i := 0; i < b.N; i++ {
		for _, evt := range evts {
			_, _ = e.ProcessEvent(evt)
		}
	}
}

```

`pkg/rules/sequence.go`:

```go
/*
 * Copyright 2021-present by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package rules

import (
	"context"
	"expvar"
	"sort"
	"sync"
	"sync/atomic"
	"time"

	fsm "github.com/qmuntal/stateless"
	"github.com/rabbitstack/fibratus/pkg/config"
	"github.com/rabbitstack/fibratus/pkg/event"
	"github.com/rabbitstack/fibratus/pkg/event/params"
	"github.com/rabbitstack/fibratus/pkg/filter"
	"github.com/rabbitstack/fibratus/pkg/filter/ql"
	"github.com/rabbitstack/fibratus/pkg/ps"
	log "github.com/sirupsen/logrus"
)

const (
	// maxOutstandingPartials determines the maximum number of partials per sequence index
	maxOutstandingPartials = 1000
)

var (
	partialsPerSequence   = expvar.NewMap("sequence.partials.count")
	partialExpirations    = expvar.NewMap("sequence.partial.expirations")
	partialBreaches       = expvar.NewMap("sequence.partial.breaches")
	matchTransitionErrors = expvar.NewInt("sequence.match.transition.errors")

	// maxSequencePartialLifetime indicates the maximum time for the
	// partial to exist in the sequence state. If the partial has been
	// placed in the sequence state more than allowed, it is removed
	maxSequencePartialLifetime = time.Hour * 4
)

var (
	// sequenceTerminalState represents the final state in the FSM.
	// This state is transitioned when the last rule in the sequence
	// produces a match
	sequenceTerminalState = fsm.State("terminal")
	// sequenceDeadlineState represents the state to which other
	// states transition if the rule's max span is reached
	sequenceDeadlineState = fsm.State("deadline")
	// sequenceExpiredState designates the state to which other
	// states transition when the sequence is expired
	sequenceExpiredState = fsm.State("expired")
	// sequenceInitialState represents the initial sequence state
	sequenceInitialState = fsm.State(0)

	// transitions for match, cancel, reset, and expire triggers
	matchTransition  = fsm.Trigger("match")
	cancelTransition = fsm.Trigger("cancel")
	resetTransition  = fsm.Trigger("reset")
	expireTransition = fsm.Trigger("expire")
)

// sequenceState represents the state of the
// ordered sequence of multiple events that
// may have time-frame constraints. A deterministic
// finite state machine tracks the matching status of
// each expression (state) in the machine.
type sequenceState struct {
	filter  filter.Filter
	seq     *ql.Sequence
	name    string
	maxSpan time.Duration

	// partials keeps the state of all matched events per expression
	partials map[int][]*event.Event
	// mu guards the partials map
	mu sync.RWMutex

	// matches stores only the event that matched
	// the upstream partials. These events will
	// be propagated in the rule action context
	matches map[int]*event.Event
	// mmu guards the matches map
	mmu sync.RWMutex

	fsm *fsm.StateMachine

	// exprs stores the expression index to
	// its respective string representation
	exprs              map[int]string
	spanDeadlines      map[fsm.State]*time.Timer
	inDeadline         atomic.Bool
	inExpired          atomic.Bool
	initialState       fsm.State
	isPartialsBreached atomic.Bool

	// states keeps the mapping between expression
	// index and its matching state. Whenever the expression
	// evaluates to true the state is updated for the index
	// pertaining to the expression sequence slot
	states map[fsm.State]bool
	// smu guards the states map
	smu sync.RWMutex

	// lastMatch is the timestamp of the last matched event.
	// The purpose is to enforce temporal monotonicity
	lastMatch time.Time

	psnap ps.Snapshotter
}

func newSequenceState(f filter.Filter, c *config.FilterConfig, psnap ps.Snapshotter) *sequenceState {
	ss := &sequenceState{
		filter:        f,
		seq:           f.GetSequence(),
		name:          c.Name,
		maxSpan:       f.GetSequence().MaxSpan,
		partials:      make(map[int][]*event.Event),
		states:        make(map[fsm.State]bool),
		matches:       make(map[int]*event.Event),
		exprs:         make(map[int]string),
		spanDeadlines: make(map[fsm.State]*time.Timer),
		initialState:  sequenceInitialState,
		psnap:         psnap,
	}

	ss.initFSM()

	ss.configureFSM()

	return ss
}

func (s *sequenceState) events() []*event.Event {
	s.mmu.RLock()
	defer s.mmu.RUnlock()
	events := make([]*event.Event, 0, len(s.matches))
	for _, e := range s.matches {
		events = append(events, e)
	}
	sort.Slice(events, func(i, j int) bool { return events[i].Timestamp.Before(events[j].Timestamp) })
	return events
}

func (s *sequenceState) isStateSchedulable(state fsm.State) bool {
	return state != s.initialState && state != sequenceTerminalState && state != sequenceExpiredState && state != sequenceDeadlineState
}

// initFSM initializes the state machine and installs transition callbacks
// that are triggered when the expression in the sequence matches, it expires
// or the deadline occurs.
func (s *sequenceState) initFSM() {
	s.fsm = fsm.NewStateMachine(s.initialState)
	s.fsm.OnTransitioned(func(ctx context.Context, transition fsm.Transition) {
		// schedule span deadline for the current state unless initial/meta states
		if s.maxSpan != 0 && s.isStateSchedulable(s.currentState()) {
			log.Debugf("scheduling max span deadline of %v for expression [%s] of sequence [%s]", s.maxSpan, s.expr(s.currentState()), s.name)
			s.scheduleMaxSpanDeadline(s.currentState(), s.maxSpan)
		}
		// if the sequence was deadlined/expired, we can disable the deadline
		// status when the first expression in the sequence is reevaluated
		if transition.Source == s.initialState && s.inDeadline.Load() {
			s.inDeadline.Store(false)
		}
		if transition.Source == s.initialState && s.inExpired.Load() {
			s.inExpired.Store(false)
		}
		// clear state in case of expire/deadline transitions
		if transition.Trigger == expireTransition || transition.Trigger == cancelTransition {
			s.clear()
		}
		if transition.Trigger == matchTransition {
			log.Debugf("state trigger from expression [%s] of sequence [%s]", s.expr(transition.Source), s.name)
			// a match occurred from current to next state.
			// Stop deadline execution for the old current state
			if span, ok := s.spanDeadlines[transition.Source]; ok {
				log.Debugf("stopped max span deadline for expression [%s] of sequence [%s]", s.expr(transition.Source), s.name)
				span.Stop()
				delete(s.spanDeadlines, transition.Source)
			}
			// save expression match
			s.states[transition.Source] = true
		}
	})
}

// configureFSM sets up the states and transitions of the state automata.
// A simplified representation of the constructed automata is better
// visualized in the diagram above
//
//	       +-----+        +-----+        +-----+
//	---->  |  0  | -----> |  1  | -----> |  2  | -----> terminal
//	+      +-----+        +-----+        +-----+
//	+        |               |               |
//	+   +----+----+     +----+----+     +----+----+
//	+   |         |     |         |     |         |
//	+   v         v     v         v     v         v
//	+---------+ +---------+ +---------+ +---------+ +---------+ +---------+
//
// | deadline| | expired | | deadline| | expired | | deadline| | expired |
// +---------+ +---------+ +---------+ +---------+ +---------+ +---------+
//
// The diagram is based on the assumption that there are three expressions
// inside the sequence. In the course of normal circumstances, the initial
// state transitions to the state 1 and the state 1 to the state 2 whenever
// the expression associated to the state is evaluated to true.
// Once the final state is reached, it transitions to the terminal state and
// the sequence is considered to yield a match.
//
// However, it can happen that the maximum time span defined in the sequence
// elapses. In this situation, the sequence is promoted to the deadline state
// and the state machine is reset to the initial state. The similar behaviour
// occurs when the process attributed to any of the pending partials in the
// sequence terminates. In this case, the state machine transitions to the
// expired state.
func (s *sequenceState) configureFSM() {
	for seqID, expr := range s.seq.Expressions {
		// sequence expression index is the state name
		s.exprs[seqID] = expr.Expr.String()
		// is this the last state?
		if seqID >= len(s.seq.Expressions)-1 {
			s.fsm.
				Configure(seqID).
				Permit(matchTransition, sequenceTerminalState).
				Permit(cancelTransition, sequenceDeadlineState).
				Permit(expireTransition, sequenceExpiredState)
		} else {
			// the previous state can transition to the next one
			// via the match transition, or can either go to the
			// deadline or expired states via cancel and expire
			// transitions respectively
			s.fsm.
				Configure(seqID).
				Permit(matchTransition, seqID+1).
				Permit(cancelTransition, sequenceDeadlineState).
				Permit(expireTransition, sequenceExpiredState)
		}
	}
	// configure reset transitions that are triggered
	// when the final state is reached of when a deadline
	// or sequence expiration happens
	s.fsm.
		Configure(sequenceTerminalState).
		Permit(resetTransition, sequenceInitialState)
	s.fsm.
		Configure(sequenceDeadlineState).
		Permit(resetTransition, sequenceInitialState)
	s.fsm.
		Configure(sequenceExpiredState).
		Permit(resetTransition, sequenceInitialState)
}

func (s *sequenceState) matchTransition(seqID int, e *event.Event) error {
	s.smu.Lock()
	defer s.smu.Unlock()
	shouldFire := !s.states[seqID]
	if shouldFire {
		return s.fsm.Fire(matchTransition, e)
	}
	return nil
}

func (s *sequenceState) cancelTransition(seqID fsm.State) error {
	return s.fsm.Fire(cancelTransition, seqID)
}

func (s *sequenceState) expireTransition() error {
	return s.fsm.Fire(expireTransition)
}

func (s *sequenceState) isTerminalState() bool {
	isFinal := s.currentState() == sequenceTerminalState
	if isFinal {
		err := s.fsm.Fire(resetTransition)
		if err != nil {
			log.Warnf("unable to transition to initial state: %v", err)
		}
	}
	return isFinal
}

func (s *sequenceState) isInitialState() bool {
	return s.currentState() == s.initialState
}

func (s *sequenceState) currentState() fsm.State {
	return s.fsm.MustState()
}

func (s *sequenceState) expr(state fsm.State) string {
	seqID, ok := state.(int)
	if !ok {
		return ""
	}
	return s.exprs[seqID]
}

// addPartial appends the event that matched the expression at the
// sequence index. If the event arrived out of order, then the isOOO
// parameter is equal to false.
func (s *sequenceState) addPartial(seqID int, e *event.Event, isOOO bool) {
	s.mu.Lock()
	defer s.mu.Unlock()
	if len(s.partials[seqID]) > maxOutstandingPartials {
		partialBreaches.Add(s.name, 1)
		if !s.isPartialsBreached.Load() {
			log.Warnf("max partials encountered in sequence %s slot [%d]. "+
				"Dropping incoming partial: %s", s.name, seqID, e)
		}
		s.isPartialsBreached.Store(true)
		return
	}
	key := e.PartialKey()
	if key != 0 {
		for _, p := range s.partials[seqID] {
			if key == p.PartialKey() {
				log.Debugf("event %s for tuple %d already in sequence state", e, key)
				return
			}
		}
	}
	if isOOO {
		e.AddMeta(event.RuleSequenceOOOKey, true)
	}
	log.Debugf("adding partial to sequence [%s] slot [%d] for expression %q, ooo: %t: %s", s.name, seqID, s.expr(seqID), isOOO, e)
	partialsPerSequence.Add(s.name, 1)
	s.partials[seqID] = append(s.partials[seqID], e)
	sort.Slice(s.partials[seqID], func(n, m int) bool { return s.partials[seqID][n].Timestamp.Before(s.partials[seqID][m].Timestamp) })
}

// gc prunes the sequence partial if it remained
// more time than specified by max span or if max
// span is omitted, the partial is allowed to remain
// in sequence state for four hours.
func (s *sequenceState) gc() {
	s.mu.Lock()
	defer s.mu.Unlock()
	dur := s.maxSpan
	if dur == 0 {
		dur = maxSequencePartialLifetime
	}
	for idx := range s.exprs {
		for i := len(s.partials[idx]) - 1; i >= 0; i-- {
			if len(s.partials[idx]) > 0 && time.Since(s.partials[idx][i].Timestamp) > dur {
				log.Debugf("garbage collecting partial: [%s] of sequence [%s]", s.partials[idx][i], s.name)
				// remove partial event from the corresponding slot
				s.partials[idx] = append(
					s.partials[idx][:i],
					s.partials[idx][i+1:]...)
				partialsPerSequence.Add(s.name, -1)
			}
		}
	}
}

func (s *sequenceState) clear() {
	s.partials = make(map[int][]*event.Event)
	s.matches = make(map[int]*event.Event)
	s.states = make(map[fsm.State]bool)
	s.spanDeadlines = make(map[fsm.State]*time.Timer)
	s.isPartialsBreached.Store(false)
	partialsPerSequence.Delete(s.name)
	s.lastMatch = time.Time{}
}

func (s *sequenceState) clearLocked() {
	s.mu.Lock()
	defer s.mu.Unlock()
	s.smu.Lock()
	defer s.smu.Unlock()
	s.mmu.Lock()
	defer s.mmu.Unlock()
	s.clear()
}

// next determines whether the next expression in the
// sequence should be evaluated. The expression is evaluated
// if all its upstream sequence expression produced a match and
// the sequence is not stuck in deadline or expired state.
func (s *sequenceState) next(seqID int) bool {
	// always evaluate the first expression in the sequence
	if seqID == 0 {
		return true
	}

	var next bool
	s.smu.RLock()
	defer s.smu.RUnlock()
	for n := range seqID {
		next = s.states[n]
		if !next {
			break
		}
	}

	return next && !s.inDeadline.Load() && !s.inExpired.Load()
}

func (s *sequenceState) scheduleMaxSpanDeadline(seqID fsm.State, maxSpan time.Duration) {
	t := time.AfterFunc(maxSpan, func() {
		inState, _ := s.fsm.IsInState(seqID)
		if inState {
			log.Debugf("max span of %v exceded for expression [%s] of sequence [%s]", maxSpan, s.expr(seqID), s.name)
			s.inDeadline.Store(true)
			s.mu.Lock()
			defer s.mu.Unlock()
			s.smu.Lock()
			defer s.smu.Unlock()
			// transitions to deadline state
			err := s.cancelTransition(seqID)
			if err != nil {
				s.inDeadline.Store(false)
				log.Warnf("deadline transition failed: %v", err)
			}
			// transitions from deadline state to initial state
			err = s.fsm.Fire(resetTransition)
			if err != nil {
				log.Warnf("unable to transition to initial state: %v", err)
			}
		}
	})
	s.spanDeadlines[seqID] = t
}

func (s *sequenceState) runSequence(e *event.Event) bool {
	for i, expr := range s.seq.Expressions {
		// only try to evaluate the expression
		// if upstream expressions have matched
		if !s.next(i) {
			if !s.seq.IsUnordered {
				continue
			}
			// it could be the event arrived out
			// of order because certain provider
			// flushed its buffers first. When this
			// happens the event timestamp serves as
			// a temporal reference.
			// If this sequence expression can evaluate
			// against the current event, mark it as
			// out-of-order and store in partials list
			s.mu.RLock()
			ok := expr.IsEvaluable(e) && s.filter.RunSequence(e, i, s.partials, true)
			s.mu.RUnlock()
			if ok {
				s.addPartial(i, e, true)
			}
			continue
		}

		s.mu.RLock()
		matches := expr.IsEvaluable(e) && s.filter.RunSequence(e, i, s.partials, false)
		s.mu.RUnlock()

		if !matches {
			continue
		}

		// enforce temporal monotonicity check for ordered sequences
		if !s.seq.IsUnordered && !s.lastMatch.IsZero() && !e.Timestamp.After(s.lastMatch) {
			// this event is older than or equal to the previous matched slot
			continue
		}

		// append the partial and transition state machine
		s.addPartial(i, e, false)
		err := s.matchTransition(i, e)
		if err != nil {
			matchTransitionErrors.Add(1)
			log.Warnf("match transition failure: %v", err)
		}
		if !s.seq.IsUnordered {
			s.lastMatch = e.Timestamp
		}
		// now try to match all pending out-of-order
		// events from downstream sequence slots if
		// the previous match hasn't reached terminal
		// state
		if s.seq.IsUnordered && s.currentState() != sequenceTerminalState {
			s.mu.RLock()
			for seqID := range s.partials {
				for _, evt := range s.partials[seqID] {
					if !evt.ContainsMeta(event.RuleSequenceOOOKey) {
						continue
					}
					// try to initialize process state before evaluating the event
					if evt.PS == nil {
						_, evt.PS = s.psnap.Find(evt.PID)
					}
					matches = s.filter.RunSequence(evt, seqID, s.partials, false)
					if !matches {
						continue
					}
					// transition the state machine
					err := s.matchTransition(seqID, evt)
					if err != nil {
						matchTransitionErrors.Add(1)
						log.Warnf("out of order match transition failure: %v", err)
					}
					evt.RemoveMeta(event.RuleSequenceOOOKey)
				}
			}
			s.mu.RUnlock()
		}

		// if both the terminal state is reached and the partials
		// in the sequence state could be joined by the specified
		// field(s) or the sequence is unconstrained, the rule has
		// matched successfully, and we can collect all events involved
		// in the rule match
		isTerminal := s.isTerminalState()
		if isTerminal {
			setMatch := func(seqID int, e *event.Event) {
				s.mmu.Lock()
				defer s.mmu.Unlock()
				if s.matches[seqID] == nil {
					s.matches[seqID] = e
				}
			}

			s.mu.RLock()
			for seqID := 0; seqID < len(s.partials); seqID++ {
				for _, outer := range s.partials[seqID] {
					for _, inner := range s.partials[seqID+1] {
						switch {
						case filter.CompareSeqLinks(outer.SequenceLinks(), inner.SequenceLinks()):
							setMatch(seqID, outer)
							setMatch(seqID+1, inner)
						case !s.seq.IsConstrained() && !outer.ContainsMeta(event.RuleSequenceLinks) && !inner.ContainsMeta(event.RuleSequenceLinks):
							setMatch(seqID, outer)
							setMatch(seqID+1, inner)
						}
					}
				}
			}
			s.mu.RUnlock()

			return true
		}
	}
	return false
}

func (s *sequenceState) expire(e *event.Event) bool {
	if !e.IsTerminateProcess() {
		return false
	}
	canExpire := func(lhs, rhs *event.Event, isFinalSlot bool) bool {
		// if the TerminateProcess event arrives for the
		// process spawned by CreateProcess, and it pertains
		// to the final sequence slot, it is safe to expire
		// the whole sequence
		pid := rhs.Params.MustGetPid()
		if lhs.Type == event.CreateProcess && isFinalSlot {
			return lhs.Params.MustGetPid() == pid
		}
		if lhs.Type == event.CreateThread {
			// if the pids differ, the thread
			// is created in a remote process.
			// Sequence can be expired only if
			// the remote process terminates
			if lhs.PID != lhs.Params.MustGetPid() {
				return lhs.Params.MustGetPid() == pid
			}
		}
		return lhs.PID == pid
	}
	s.mu.Lock()
	defer s.mu.Unlock()
	s.smu.RLock()
	defer s.smu.RUnlock()

	for idx := range s.exprs {
		for i := len(s.partials[idx]) - 1; i >= 0; i-- {
			if len(s.partials[idx]) > 0 && !canExpire(s.partials[idx][i], e, idx == len(s.exprs)-1) {
				continue
			}
			log.Debugf("removing event originated from %s (%d) "+
				"in partials pertaining to sequence [%s] and slot [%d]",
				e.Params.MustGetString(params.ProcessName),
				e.Params.MustGetPid(),
				s.name,
				idx)
			// remove partial event from the corresponding slot
			s.partials[idx] = append(
				s.partials[idx][:i],
				s.partials[idx][i+1:]...)
			partialsPerSequence.Add(s.name, -1)

			if len(s.partials[idx]) == 0 {
				partialExpirations.Add(s.name, 1)
				log.Debugf("%q sequence expired. All partials retracted", s.name)
				s.inExpired.Store(true)
				err := s.expireTransition()
				if err != nil {
					s.inExpired.Store(false)
					log.Warnf("expire transition failed: %v", err)
				}
				// transitions from expired state to initial state
				err = s.fsm.Fire(resetTransition)
				if err != nil {
					log.Warnf("unable to transition to initial state: %v", err)
				}
				return true
			}
		}
	}

	return false
}

```

`pkg/rules/sequence_test.go`:

```go
/*
 * Copyright 2021-present by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package rules

import (
	"net"
	"strconv"
	"testing"
	"time"

	"github.com/rabbitstack/fibratus/pkg/config"
	"github.com/rabbitstack/fibratus/pkg/event"
	"github.com/rabbitstack/fibratus/pkg/event/params"
	"github.com/rabbitstack/fibratus/pkg/filter"
	"github.com/rabbitstack/fibratus/pkg/fs"
	"github.com/rabbitstack/fibratus/pkg/ps"
	pstypes "github.com/rabbitstack/fibratus/pkg/ps/types"
	log "github.com/sirupsen/logrus"
	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/require"
	"golang.org/x/sys/windows/registry"
)

func TestSequenceState(t *testing.T) {
	log.SetLevel(log.DebugLevel)

	c := &config.FilterConfig{Name: "Command shell created and executed by file"}
	f := filter.New(`
	sequence
	maxspan 100ms
  	|evt.name = 'CreateProcess' and ps.name = 'cmd.exe'| by ps.exe
  	|evt.name = 'CreateFile' and file.path icontains 'temp'| by file.path
		|evt.name = 'CreateProcess'| by ps.exe`,
		&config.Config{EventSource: config.EventSourceConfig{}, Filters: &config.Filters{}})

	require.NoError(t, f.Compile())

	ss := newSequenceState(f, c, new(ps.SnapshotterMock))

	assert.Equal(t, 0, ss.currentState())
	assert.True(t, ss.isInitialState())
	assert.Equal(t, "evt.name = CreateProcess AND ps.name = cmd.exe", ss.expr(ss.initialState))

	e1 := &event.Event{
		Type:      event.CreateProcess,
		Name:      "CreateProcess",
		Tid:       2484,
		PID:       859,
		Timestamp: time.Now(),
		PS: &pstypes.PS{
			Name: "cmd.exe",
			Exe:  "C:\\Windows\\system32\\svchost.exe",
		},
		Params: event.Params{
			params.ProcessID:   {Name: params.ProcessID, Type: params.PID, Value: uint32(4143)},
			params.ProcessName: {Name: params.ProcessName, Type: params.AnsiString, Value: "powershell.exe"},
		},
	}

	e2 := &event.Event{
		Type:      event.CreateFile,
		Name:      "CreateFile",
		Tid:       2484,
		PID:       4143,
		Timestamp: time.Now().Add(time.Second * 5),
		PS: &pstypes.PS{
			Name: "cmd.exe",
			Exe:  "C:\\Windows\\system32\\svchost.exe",
		},
		Params: event.Params{
			params.FilePath: {Name: params.FilePath, Type: params.UnicodeString, Value: "C:\\Temp\\dropper"},
		},
	}

	require.True(t, ss.next(0))
	require.False(t, ss.next(1))
	require.NoError(t, ss.matchTransition(0, e1))
	ss.addPartial(0, e1, false)
	require.True(t, ss.next(1))
	assert.True(t, ss.states[0])
	require.False(t, ss.next(2))

	assert.False(t, ss.isInitialState())
	assert.Equal(t, "evt.name = CreateFile AND file.path ICONTAINS temp", ss.expr(ss.currentState()))

	e3 := &event.Event{
		Type:      event.CreateProcess,
		Name:      "CreateProcess",
		Timestamp: time.Now().Add(time.Second * 10),
		Tid:       2484,
		PID:       4143,
		Params: event.Params{
			params.Exe: {Name: params.Exe, Type: params.UnicodeString, Value: "C:\\Temp\\dropper.exe"},
		},
	}

	// can't go to the next transitions as the expr hasn't matched
	require.False(t, ss.next(2))
	require.NoError(t, ss.matchTransition(1, e2))
	ss.addPartial(1, e2, false)
	require.True(t, ss.states[1])
	require.True(t, ss.next(2))

	assert.Len(t, ss.partials[0], 1)
	assert.Len(t, ss.partials[1], 1)

	assert.Equal(t, 2, ss.currentState())
	assert.Equal(t, "evt.name = CreateProcess", ss.expr(ss.currentState()))

	require.NoError(t, ss.matchTransition(2, e3))
	ss.addPartial(2, e3, false)

	assert.Len(t, ss.partials[2], 1)

	assert.Equal(t, sequenceTerminalState, ss.currentState())
	assert.True(t, ss.isTerminalState())

	// reset sequence state
	ss.clear()

	// reset transition leads back to initial state
	assert.Equal(t, 0, ss.currentState())
	assert.Equal(t, "evt.name = CreateProcess AND ps.name = cmd.exe", ss.expr(ss.currentState()))
	// deadline exceeded
	require.NoError(t, ss.matchTransition(0, e1))
	assert.Equal(t, "evt.name = CreateFile AND file.path ICONTAINS temp", ss.expr(ss.currentState()))
	time.Sleep(time.Millisecond * 120)
	// transition to initial state
	assert.True(t, ss.isInitialState())

	// sequence in deadline state
	require.True(t, ss.inDeadline.Load())
	require.True(t, ss.next(0))
	require.False(t, ss.next(1))
	if ss.next(1) {
		// this shouldn't happen
		require.NoError(t, ss.matchTransition(1, e2))
	}

	ss.clear()

	assert.True(t, ss.isInitialState())
	require.NoError(t, ss.matchTransition(0, e1))
	ss.addPartial(0, e1, false)
	ss.addPartial(1, e2, false)
	require.False(t, ss.inDeadline.Load())

	// expire entire sequence
	e4 := &event.Event{
		Type: event.TerminateProcess,
		Name: "TerminateProcess",
		Tid:  2484,
		PID:  859,
		PS: &pstypes.PS{
			Name: "cmd.exe",
			Exe:  "C:\\Windows\\system32\\svchost.exe",
		},
		Params: event.Params{
			params.ProcessID:   {Name: params.ProcessID, Type: params.PID, Value: uint32(4143)},
			params.ProcessName: {Name: params.ProcessName, Type: params.AnsiString, Value: "powershell.exe"},
		},
	}
	require.True(t, ss.expire(e4))
	require.True(t, ss.inExpired.Load())

	require.NoError(t, ss.matchTransition(0, e1))
	require.False(t, ss.inExpired.Load())

	assert.Equal(t, "evt.name = CreateFile AND file.path ICONTAINS temp", ss.expr(ss.currentState()))
}

func TestSimpleSequence(t *testing.T) {
	log.SetLevel(log.DebugLevel)

	c := &config.FilterConfig{Name: "Command shell created a temp file"}
	f := filter.New(`
	sequence
	maxspan 100ms
  	|evt.name = 'CreateProcess' and ps.name = 'cmd.exe'| by ps.exe
  	|evt.name = 'CreateFile' and file.path icontains 'temp'| by file.path
	`, &config.Config{EventSource: config.EventSourceConfig{EnableFileIOEvents: true}, Filters: &config.Filters{}})
	require.NoError(t, f.Compile())

	ss := newSequenceState(f, c, new(ps.SnapshotterMock))

	var tests = []struct {
		evts    []*event.Event
		matches []bool
	}{
		{[]*event.Event{{
			Type:      event.CreateProcess,
			Name:      "CreateProcess",
			Timestamp: time.Now(),
			Tid:       2484,
			PID:       859,
			PS: &pstypes.PS{
				Name: "cmd.exe",
				Exe:  "C:\\Windows\\system32\\svchost-temp.exe",
			},
			Params: event.Params{
				params.ProcessID: {Name: params.ProcessID, Type: params.Uint32, Value: uint32(4143)},
			},
			Metadata: map[event.MetadataKey]any{"foo": "bar", "fooz": "barzz"},
		}, {
			Type:      event.CreateFile,
			Name:      "CreateFile",
			Timestamp: time.Now().Add(time.Second),
			Tid:       2484,
			PID:       859,
			Category:  event.File,
			PS: &pstypes.PS{
				Name: "cmd.exe",
			},
			Params: event.Params{
				params.FilePath: {Name: params.FilePath, Type: params.UnicodeString, Value: "C:\\Windows\\system32\\svchost-temp.exe"},
			},
			Metadata: map[event.MetadataKey]any{"foo": "bar", "fooz": "barzz"}}}, []bool{false, true}},
		{[]*event.Event{{
			Type:      event.CreateProcess,
			Name:      "CreateProcess",
			Timestamp: time.Now(),
			Tid:       2484,
			PID:       859,
			PS: &pstypes.PS{
				Name: "cmd.exe",
				Exe:  "C:\\Windows\\system32\\cmd.exe",
			},
			Params: event.Params{
				params.ProcessID: {Name: params.ProcessID, Type: params.Uint32, Value: uint32(4143)},
			},
			Metadata: map[event.MetadataKey]any{"foo": "bar", "fooz": "barzz"},
		}, {
			Type:      event.CreateFile,
			Name:      "CreateFile",
			Timestamp: time.Now().Add(time.Second),
			Tid:       2484,
			PID:       859,
			Category:  event.File,
			PS: &pstypes.PS{
				Name: "cmd.exe",
			},
			Params: event.Params{
				params.FilePath: {Name: params.FilePath, Type: params.UnicodeString, Value: "C:\\Windows\\system32\\svchost-temp.exe"},
			},
			Metadata: map[event.MetadataKey]any{"foo": "bar", "fooz": "barzz"}}}, []bool{false, false}},
	}

	for i, tt := range tests {
		t.Run(strconv.Itoa(i), func(t *testing.T) {
			for idx, e := range tt.evts {
				assert.Equal(t, tt.matches[idx], ss.runSequence(e))
			}
		})
	}
}

func TestSimpleSequenceMultiplePartials(t *testing.T) {
	log.SetLevel(log.DebugLevel)

	c := &config.FilterConfig{Name: "Command shell created a temp file"}
	f := filter.New(`
	sequence
  maxspan 200ms
  by ps.pid
    |evt.name = 'CreateProcess' and ps.name = 'cmd.exe'|
    |evt.name = 'CreateFile' and file.path icontains 'temp'|
	`, &config.Config{EventSource: config.EventSourceConfig{EnableFileIOEvents: true}, Filters: &config.Filters{}})
	require.NoError(t, f.Compile())

	ss := newSequenceState(f, c, new(ps.SnapshotterMock))

	// create random matches which don't satisfy the sequence link
	for i, pid := range []uint32{2343, 1024, 11122, 3450, 12319} {
		e1 := &event.Event{
			Type:      event.CreateProcess,
			Timestamp: time.Now().Add(time.Duration(i) * time.Millisecond),
			Name:      "CreateProcess",
			Tid:       2484,
			PID:       pid % 2,
			PS: &pstypes.PS{
				Name: "cmd.exe",
				Exe:  "C:\\Windows\\system32\\cmd.exe",
			},
			Params: event.Params{
				params.ProcessID: {Name: params.ProcessID, Type: params.PID, Value: pid % 2},
			},
			Metadata: map[event.MetadataKey]any{"foo": "bar", "fooz": "barzz"},
		}
		e2 := &event.Event{
			Type:      event.CreateFile,
			Timestamp: time.Now().Add(time.Duration(i) * time.Millisecond * 2),
			Name:      "CreateFile",
			Tid:       2484,
			PID:       pid * 2,
			Category:  event.File,
			PS: &pstypes.PS{
				Name: "cmd.exe",
				Exe:  "C:\\Windows\\system32\\cmd.exe",
			},
			Params: event.Params{
				params.FilePath: {Name: params.FilePath, Type: params.UnicodeString, Value: "C:\\Windows\\system32\\svchost-temp.exe"},
			},
			Metadata: map[event.MetadataKey]any{"foo": "bar", "fooz": "barzz"},
		}
		require.False(t, ss.runSequence(e1))
		require.False(t, ss.runSequence(e2))
	}

	// expression matched multiple partials
	assert.Len(t, ss.partials[0], 5)
	assert.Len(t, ss.partials[1], 0)

	e1 := &event.Event{
		Seq:       20,
		Type:      event.CreateProcess,
		Timestamp: time.Now().Add(time.Second),
		Name:      "CreateProcess",
		Tid:       2484,
		PID:       859,
		PS: &pstypes.PS{
			Name: "cmd.exe",
			Exe:  "C:\\Windows\\System32\\cmd.exe",
			PID:  859,
			Parent: &pstypes.PS{
				Name: "WmiPrvSE.exe",
			},
		},
		Params: event.Params{
			params.ProcessID: {Name: params.ProcessID, Type: params.PID, Value: uint32(859)},
		},
		Metadata: map[event.MetadataKey]any{"foo": "bar", "fooz": "barzz"},
	}
	e2 := &event.Event{
		Type:      event.CreateFile,
		Seq:       22,
		Timestamp: time.Now().Add(time.Second * time.Duration(2)),
		Name:      "CreateFile",
		Tid:       2484,
		PID:       859,
		Category:  event.File,
		PS: &pstypes.PS{
			Name: "cmd.exe",
			Exe:  "C:\\Windows\\system32\\cmd.exe",
			PID:  859,
		},
		Params: event.Params{
			params.FilePath: {Name: params.FilePath, Type: params.UnicodeString, Value: "C:\\Temp\\file.tmp"},
		},
		Metadata: map[event.MetadataKey]any{"foo": "bar", "fooz": "barzz"},
	}

	require.False(t, ss.runSequence(e1))
	// expression matched the partial that satisfies the sequence link
	assert.Len(t, ss.partials[0], 6)
	assert.Len(t, ss.partials[1], 0)
	require.True(t, ss.runSequence(e2))
	assert.Len(t, ss.partials[1], 1)

	require.Len(t, ss.matches, 2)
	assert.Equal(t, uint32(859), ss.matches[0].PID)
	assert.Equal(t, "WmiPrvSE.exe", ss.matches[0].PS.Parent.Name)
	assert.Equal(t, uint32(859), ss.matches[1].PID)
	assert.Equal(t, "C:\\Temp\\file.tmp", ss.matches[1].GetParamAsString(params.FilePath))
}

func TestUnconstrainedSequenceMatches(t *testing.T) {
	log.SetLevel(log.DebugLevel)

	c := &config.FilterConfig{Name: "Command shell created a temp file"}
	f := filter.New(`
	sequence
  maxspan 200ms
    |evt.name = 'CreateProcess' and ps.name = 'cmd.exe'|
    |evt.name = 'CreateFile' and file.path icontains 'temp'|
	`, &config.Config{EventSource: config.EventSourceConfig{EnableFileIOEvents: true}, Filters: &config.Filters{}})
	require.NoError(t, f.Compile())

	ss := newSequenceState(f, c, new(ps.SnapshotterMock))

	e1 := &event.Event{
		Seq:       20,
		Type:      event.CreateProcess,
		Timestamp: time.Now().Add(time.Second),
		Name:      "CreateProcess",
		Tid:       2484,
		PID:       859,
		PS: &pstypes.PS{
			Name: "cmd.exe",
			Exe:  "C:\\Windows\\System32\\cmd.exe",
			PID:  859,
			Parent: &pstypes.PS{
				Name: "WmiPrvSE.exe",
			},
		},
		Params: event.Params{
			params.ProcessID: {Name: params.ProcessID, Type: params.PID, Value: uint32(859)},
		},
		Metadata: map[event.MetadataKey]any{"foo": "bar", "fooz": "barzz"},
	}
	e2 := &event.Event{
		Seq:       21,
		Type:      event.CreateProcess,
		Timestamp: time.Now().Add(time.Second * 2),
		Name:      "CreateProcess",
		Tid:       2484,
		PID:       1859,
		PS: &pstypes.PS{
			Name: "cmd.exe",
			Exe:  "C:\\Windows\\System32\\cmd.exe",
			PID:  1859,
			Parent: &pstypes.PS{
				Name: "svchost.exe",
			},
		},
		Params: event.Params{
			params.ProcessID: {Name: params.ProcessID, Type: params.PID, Value: uint32(859)},
		},
		Metadata: map[event.MetadataKey]any{"foo": "bar", "fooz": "barzz"},
	}
	e3 := &event.Event{
		Type:      event.CreateFile,
		Seq:       25,
		Timestamp: time.Now().Add(time.Second * 3),
		Name:      "CreateFile",
		Tid:       2484,
		PID:       3859,
		Category:  event.File,
		PS: &pstypes.PS{
			Name: "cmd.exe",
			Exe:  "C:\\Windows\\system32\\cmd.exe",
			PID:  3859,
		},
		Params: event.Params{
			params.FilePath: {Name: params.FilePath, Type: params.UnicodeString, Value: "C:\\Temp\\file.tmp"},
		},
		Metadata: map[event.MetadataKey]any{"foo": "bar", "fooz": "barzz"},
	}

	require.False(t, ss.runSequence(e1))
	require.False(t, ss.runSequence(e2))
	assert.Len(t, ss.partials[0], 2)
	assert.Len(t, ss.partials[1], 0)
	require.True(t, ss.runSequence(e3))
	assert.Len(t, ss.partials[1], 1)

	require.Len(t, ss.matches, 2)
	assert.Equal(t, uint32(859), ss.matches[0].PID)
	assert.Equal(t, "WmiPrvSE.exe", ss.matches[0].PS.Parent.Name)
	assert.Equal(t, uint32(3859), ss.matches[1].PID)
	assert.Equal(t, "C:\\Temp\\file.tmp", ss.matches[1].GetParamAsString(params.FilePath))
}

func TestSimpleSequenceDeadline(t *testing.T) {
	log.SetLevel(log.DebugLevel)

	c := &config.FilterConfig{Name: "Command shell created a temp file"}
	f := filter.New(`
	sequence
	maxspan 100ms
  	|evt.name = 'CreateProcess' and ps.name = 'cmd.exe'| by ps.exe
  	|evt.name = 'CreateFile' and file.path icontains 'temp'| by file.path
	`, &config.Config{EventSource: config.EventSourceConfig{EnableFileIOEvents: true}, Filters: &config.Filters{}})
	require.NoError(t, f.Compile())

	ss := newSequenceState(f, c, new(ps.SnapshotterMock))

	e1 := &event.Event{
		Type:      event.CreateProcess,
		Timestamp: time.Now(),
		Name:      "CreateProcess",
		Tid:       2484,
		PID:       859,
		PS: &pstypes.PS{
			Name: "cmd.exe",
			Exe:  "C:\\Windows\\system32\\svchost-temp.exe",
		},
		Params: event.Params{
			params.ProcessID: {Name: params.ProcessID, Type: params.Uint32, Value: uint32(4143)},
		},
		Metadata: map[event.MetadataKey]any{"foo": "bar", "fooz": "barzz"},
	}
	require.False(t, ss.runSequence(e1))

	e2 := &event.Event{
		Type:      event.CreateFile,
		Timestamp: time.Now().Add(time.Millisecond * 200),
		Name:      "CreateFile",
		Tid:       2484,
		PID:       859,
		Category:  event.File,
		PS: &pstypes.PS{
			Name: "cmd.exe",
			Exe:  "C:\\Windows\\system32\\svchost.exe",
		},
		Params: event.Params{
			params.FilePath: {Name: params.FilePath, Type: params.UnicodeString, Value: "C:\\Windows\\system32\\svchost-temp.exe"},
		},
		Metadata: map[event.MetadataKey]any{"foo": "bar", "fooz": "barzz"},
	}
	time.Sleep(time.Millisecond * 110)
	require.False(t, ss.runSequence(e2))

	require.Equal(t, sequenceInitialState, ss.currentState())
	assert.Len(t, ss.partials, 0)

	// now the state machine has transitioned
	// to the initial state, which means we should
	// be able to match the sequence if we reinsert
	// the events
	require.False(t, ss.runSequence(e1))
	require.True(t, ss.runSequence(e2))

	ss.clearLocked()
	require.Equal(t, sequenceInitialState, ss.currentState())
	assert.Len(t, ss.partials, 0)

	// assert the events again with the delay less than max span
	require.False(t, ss.runSequence(e1))
	time.Sleep(time.Millisecond * 85)
	require.True(t, ss.runSequence(e2))
}

func TestSequenceMultiLinks(t *testing.T) {
	log.SetLevel(log.DebugLevel)

	c := &config.FilterConfig{Name: "Command shell created a temp file"}
	f := filter.New(`
	sequence
	maxspan 100ms
  	|evt.name = 'CreateProcess' and ps.name = 'cmd.exe'| by ps.exe, ps.pid
  	|evt.name = 'CreateFile' and file.path icontains 'temp'| by file.path, ps.pid
	`, &config.Config{EventSource: config.EventSourceConfig{EnableFileIOEvents: true}, Filters: &config.Filters{}})
	require.NoError(t, f.Compile())

	ss := newSequenceState(f, c, new(ps.SnapshotterMock))

	e1 := &event.Event{
		Type:      event.CreateProcess,
		Timestamp: time.Now(),
		Name:      "CreateProcess",
		Tid:       2484,
		PID:       859,
		PS: &pstypes.PS{
			Name: "cmd.exe",
			Exe:  "C:\\Windows\\system32\\svchost-temp.exe",
		},
		Params: event.Params{
			params.ProcessID: {Name: params.ProcessID, Type: params.Uint32, Value: uint32(4143)},
		},
		Metadata: map[event.MetadataKey]any{"foo": "bar", "fooz": "barzz"},
	}
	require.False(t, ss.runSequence(e1))

	e2 := &event.Event{
		Type:      event.CreateFile,
		Timestamp: time.Now().Add(time.Second),
		Name:      "CreateFile",
		Tid:       2484,
		PID:       859,
		Category:  event.File,
		PS: &pstypes.PS{
			Name: "cmd.exe",
			Exe:  "C:\\Windows\\system32\\svchost.exe",
		},
		Params: event.Params{
			params.FilePath: {Name: params.FilePath, Type: params.UnicodeString, Value: "C:\\Windows\\system32\\svchost-temp.exe"},
		},
		Metadata: map[event.MetadataKey]any{"foo": "bar", "fooz": "barzz"},
	}
	require.True(t, ss.runSequence(e2))
}

func TestComplexSequence(t *testing.T) {
	log.SetLevel(log.DebugLevel)

	c := &config.FilterConfig{Name: "Phishing dropper outbound communication"}
	f := filter.New(`
	sequence
  maxspan 1h
  	|evt.name = 'CreateProcess' and ps.name in ('firefox.exe', 'chrome.exe', 'edge.exe')| by ps.pid
		|evt.name = 'CreateFile' and file.operation = 'CREATE' and file.extension = '.exe'| by ps.pid
  	|evt.name in ('Send', 'Connect')| by ps.pid
	`, &config.Config{EventSource: config.EventSourceConfig{EnableFileIOEvents: true}, Filters: &config.Filters{}})
	require.NoError(t, f.Compile())

	ss := newSequenceState(f, c, new(ps.SnapshotterMock))

	e1 := &event.Event{
		Seq:       1,
		Type:      event.CreateProcess,
		Timestamp: time.Now(),
		Category:  event.Process,
		Name:      "CreateProcess",
		Tid:       2484,
		PID:       2243,
		PS: &pstypes.PS{
			Name: "firefox.exe",
			Exe:  "C:\\Program Files\\Firefox\\firefox.exe",
		},
		Params: event.Params{
			params.ProcessID:   {Name: params.ProcessID, Type: params.PID, Value: uint32(2243)},
			params.ProcessName: {Name: params.ProcessName, Type: params.UnicodeString, Value: "firefox.exe"},
		},
		Metadata: map[event.MetadataKey]any{"foo": "bar", "fooz": "barzz"},
	}
	require.False(t, ss.runSequence(e1))

	e2 := &event.Event{
		Seq:       2,
		Type:      event.CreateFile,
		Timestamp: time.Now().Add(time.Millisecond * 250),
		Name:      "CreateFile",
		Tid:       2484,
		PID:       2243,
		Category:  event.File,
		PS: &pstypes.PS{
			Name:    "firefox.exe",
			Exe:     "C:\\Program Files\\Mozilla Firefox\\firefox.exe",
			Cmdline: "C:\\Program Files\\Mozilla Firefox\\firefox.exe\" -contentproc --channel=\"10464.7.539748228\\1366525930\" -childID 6 -isF",
		},
		Params: event.Params{
			params.FilePath:      {Name: params.FilePath, Type: params.UnicodeString, Value: "C:\\Temp\\dropper.exe"},
			params.FileOperation: {Name: params.FileOperation, Type: params.Enum, Value: uint32(2), Enum: fs.FileCreateDispositions},
		},
		Metadata: map[event.MetadataKey]any{"foo": "bar", "fooz": "barzz"},
	}
	require.False(t, ss.runSequence(e2))

	assert.Len(t, ss.partials[0], 1)
	assert.Len(t, ss.partials[1], 1)

	e3 := &event.Event{
		Seq:       4,
		Type:      event.ConnectTCPv4,
		Timestamp: time.Now().Add(time.Second),
		Category:  event.Net,
		Name:      "Connect",
		Tid:       244,
		PID:       2243,
		PS: &pstypes.PS{
			Name:    "firefox.exe",
			Exe:     "C:\\Program Files\\Mozilla Firefox\\firefox.exe",
			Cmdline: "C:\\Program Files\\Mozilla Firefox\\firefox.exe\" -contentproc --channel=\"10464.7.539748228\\1366525930\" -childID 6 -isF",
		},
		Params: event.Params{
			params.NetDIP: {Name: params.NetDIP, Type: params.IPv4, Value: net.ParseIP("10.0.2.3")},
		},
		Metadata: map[event.MetadataKey]any{"foo": "bar", "fooz": "barzz"},
	}

	time.Sleep(time.Millisecond * 30)
	require.True(t, ss.runSequence(e3))

	time.Sleep(time.Millisecond * 50)

	ss.clearLocked()

	// FSM should transition from terminal to initial state
	require.Equal(t, sequenceInitialState, ss.currentState())

	require.False(t, ss.runSequence(e1))
	require.False(t, ss.runSequence(e2))
	time.Sleep(time.Millisecond * 15)
	require.True(t, ss.runSequence(e3))
}

func TestSequenceOOO(t *testing.T) {
	log.SetLevel(log.DebugLevel)

	c := &config.FilterConfig{Name: "LSASS memory dumping via legitimate or offensive tools"}
	f := filter.New(`
	sequence
  maxspan 2m
  	|evt.name = 'OpenProcess' and evt.arg[exe] imatches '?:\\Windows\\System32\\lsass.exe'| by ps.uuid
		|evt.name = 'CreateFile' and file.operation = 'CREATE' and file.extension = '.dmp'| by ps.uuid
	`, &config.Config{EventSource: config.EventSourceConfig{EnableFileIOEvents: true}, Filters: &config.Filters{}})
	require.NoError(t, f.Compile())

	ss := newSequenceState(f, c, new(ps.SnapshotterMock))

	e1 := &event.Event{
		Type:      event.CreateFile,
		Timestamp: time.Now(),
		Name:      "CreateFile",
		Tid:       2484,
		PID:       859,
		Category:  event.File,
		PS: &pstypes.PS{
			Name: "cmd.exe",
			Exe:  "C:\\Windows\\system32\\rundll32.exe",
		},
		Params: event.Params{
			params.FilePath:      {Name: params.FilePath, Type: params.UnicodeString, Value: "C:\\temp\\lsass.dmp"},
			params.FileOperation: {Name: params.FileOperation, Type: params.UnicodeString, Value: "CREATE"},
		},
		Metadata: map[event.MetadataKey]any{"foo": "bar", "fooz": "barzz"},
	}
	require.False(t, ss.runSequence(e1))
	require.Len(t, ss.partials[1], 1)
	assert.True(t, ss.partials[1][0].ContainsMeta(event.RuleSequenceOOOKey))

	e2 := &event.Event{
		Type:      event.OpenProcess,
		Timestamp: time.Now(),
		Name:      "OpenProcess",
		Tid:       2484,
		PID:       859,
		PS: &pstypes.PS{
			Name: "cmd.exe",
			Exe:  "C:\\Windows\\system32\\rundll32.exe",
		},
		Params: event.Params{
			params.Exe:           {Name: params.Exe, Type: params.UnicodeString, Value: "C:\\Windows\\System32\\lsass.exe"},
			params.ProcessID:     {Name: params.ProcessID, Type: params.PID, Value: uint32(2243)},
			params.DesiredAccess: {Name: params.DesiredAccess, Type: params.Flags, Value: uint32(0x1400), Flags: event.PsAccessRightFlags},
		},
		Metadata: map[event.MetadataKey]any{"foo": "bar", "fooz": "barzz"},
	}

	require.True(t, ss.runSequence(e2))
	assert.Len(t, ss.partials[0], 1)
	assert.False(t, ss.partials[1][0].ContainsMeta(event.RuleSequenceOOOKey))
}

func TestSequenceGC(t *testing.T) {
	log.SetLevel(log.DebugLevel)

	maxSequencePartialLifetime = time.Millisecond * 500

	c := &config.FilterConfig{Name: "LSASS memory dumping via legitimate or offensive tools"}
	f := filter.New(`
	sequence
  by ps.uuid
  	|evt.name = 'OpenProcess' and evt.arg[exe] imatches '?:\\Windows\\System32\\lsass.exe'|
		|evt.name = 'CreateFile' and file.operation = 'CREATE' and file.extension = '.dmp'|
	`, &config.Config{EventSource: config.EventSourceConfig{EnableFileIOEvents: true}, Filters: &config.Filters{}})
	require.NoError(t, f.Compile())

	ss := newSequenceState(f, c, new(ps.SnapshotterMock))

	e := &event.Event{
		Type:      event.OpenProcess,
		Timestamp: time.Now(),
		Name:      "OpenProcess",
		Tid:       2484,
		PID:       859,
		PS: &pstypes.PS{
			Name: "cmd.exe",
			Exe:  "C:\\Windows\\system32\\rundll32.exe",
		},
		Params: event.Params{
			params.Exe:           {Name: params.Exe, Type: params.UnicodeString, Value: "C:\\Windows\\System32\\lsass.exe"},
			params.ProcessID:     {Name: params.ProcessID, Type: params.PID, Value: uint32(2243)},
			params.DesiredAccess: {Name: params.DesiredAccess, Type: params.Flags, Value: uint32(0x1400), Flags: event.PsAccessRightFlags},
		},
		Metadata: map[event.MetadataKey]any{"foo": "bar", "fooz": "barzz"},
	}

	require.False(t, ss.runSequence(e))
	assert.Len(t, ss.partials[0], 1)

	time.Sleep(time.Second)

	ss.gc()

	assert.Len(t, ss.partials[0], 0)
}

func TestSequenceExpire(t *testing.T) {
	log.SetLevel(log.DebugLevel)

	var tests = []struct {
		c     *config.FilterConfig
		expr  string
		evts  []*event.Event
		wants bool
	}{
		{
			&config.FilterConfig{Name: "LSASS memory dumping via legitimate or offensive tools"},
			`sequence
  		 maxspan 2m
  			|evt.name = 'OpenProcess' and evt.arg[exe] imatches '?:\\Windows\\System32\\lsass.exe'| by ps.uuid
				|evt.name = 'CreateFile' and file.operation = 'CREATE' and file.extension = '.dmp'| by ps.uuid
			`,
			[]*event.Event{
				{
					Type:      event.OpenProcess,
					Timestamp: time.Now(),
					Name:      "OpenProcess",
					Tid:       2484,
					PID:       4143,
					PS: &pstypes.PS{
						Name: "cmd.exe",
						Exe:  "C:\\Windows\\system32\\rundll32.exe",
					},
					Params: event.Params{
						params.Exe:           {Name: params.Exe, Type: params.UnicodeString, Value: "C:\\Windows\\System32\\lsass.exe"},
						params.ProcessID:     {Name: params.ProcessID, Type: params.PID, Value: uint32(2243)},
						params.DesiredAccess: {Name: params.DesiredAccess, Type: params.Flags, Value: uint32(0x1400), Flags: event.PsAccessRightFlags},
					},
					Metadata: map[event.MetadataKey]any{"foo": "bar", "fooz": "barzz"},
				},
				{
					Type: event.TerminateProcess,
					Name: "TerminateProcess",
					Tid:  2484,
					PID:  859,
					PS: &pstypes.PS{
						Name: "cmd.exe",
						Exe:  "C:\\Windows\\system32\\svchost.exe",
					},
					Params: event.Params{
						params.ProcessID:   {Name: params.ProcessID, Type: params.PID, Value: uint32(4143)},
						params.ProcessName: {Name: params.ProcessName, Type: params.AnsiString, Value: "powershell.exe"},
					},
				},
			},
			true,
		},
		{
			&config.FilterConfig{Name: "System Binary Proxy Execution via Rundll32"},
			`sequence
  		 maxspan 2m
  			|evt.name = 'CreateProcess' and ps.name = 'rundll32.exe'| by ps.pid
				|evt.name = 'CreateProcess' and ps.name = 'connhost.exe'| by ps.parent.pid
			`,
			[]*event.Event{
				{
					Seq:       1,
					Type:      event.CreateProcess,
					Timestamp: time.Now(),
					Category:  event.Process,
					Name:      "CreateProcess",
					Tid:       2484,
					PID:       2243,
					PS: &pstypes.PS{
						Name: "rundll32.exe",
						Exe:  "C:\\Windows\\system32\\rundll32.exe",
					},
					Params: event.Params{
						params.ProcessID:   {Name: params.ProcessID, Type: params.PID, Value: uint32(2243)},
						params.ProcessName: {Name: params.ProcessName, Type: params.UnicodeString, Value: "rundll32.exe"},
					},
					Metadata: map[event.MetadataKey]any{"foo": "bar", "fooz": "barzz"},
				},
				{
					Seq:       2,
					Type:      event.CreateProcess,
					Timestamp: time.Now().Add(time.Second),
					Category:  event.Process,
					Name:      "CreateProcess",
					Tid:       2484,
					PID:       12243,
					PS: &pstypes.PS{
						Name: "connhost.exe",
						Exe:  "C:\\Windows\\system32\\connhost.exe",
						Parent: &pstypes.PS{
							Name: "rundll32.exe",
							PID:  2243,
						},
					},
					Params: event.Params{
						params.ProcessID:   {Name: params.ProcessID, Type: params.PID, Value: uint32(12243)},
						params.ProcessName: {Name: params.ProcessName, Type: params.UnicodeString, Value: "connhost.exe"},
					},
					Metadata: map[event.MetadataKey]any{"foo": "bar", "fooz": "barzz"},
				},
				{
					Type: event.TerminateProcess,
					Name: "TerminateProcess",
					Tid:  2484,
					PID:  859,
					PS: &pstypes.PS{
						Name: "cmd.exe",
						Exe:  "C:\\Windows\\system32\\svchost.exe",
					},
					Params: event.Params{
						params.ProcessID:   {Name: params.ProcessID, Type: params.PID, Value: uint32(12243)},
						params.ProcessName: {Name: params.ProcessName, Type: params.AnsiString, Value: "powershell.exe"},
					},
				},
			},
			false,
		},
	}

	for _, tt := range tests {
		t.Run(tt.expr, func(t *testing.T) {
			f := filter.New(tt.expr, &config.Config{EventSource: config.EventSourceConfig{EnableFileIOEvents: true}, Filters: &config.Filters{}})
			require.NoError(t, f.Compile())

			ss := newSequenceState(f, tt.c, new(ps.SnapshotterMock))
			for _, evt := range tt.evts {
				if evt.IsTerminateProcess() {
					ss.expire(evt)
				} else {
					ss.runSequence(evt)
				}
			}

			require.Equal(t, tt.wants, ss.inExpired.Load())
			require.Len(t, ss.partials, 0)
			ss.runSequence(tt.evts[0])
			require.False(t, ss.inExpired.Load())
		})
	}
}

func TestSequenceBoundFields(t *testing.T) {
	log.SetLevel(log.DebugLevel)

	maxSequencePartialLifetime = time.Millisecond * 500

	c := &config.FilterConfig{Name: "Command shell created a temp file with network outbound"}
	f := filter.New(`
	sequence
  maxspan 200ms
  	|evt.name = 'CreateProcess' and ps.name = 'cmd.exe'| as e1
  	|evt.name = 'CreateFile' and file.path icontains 'temp' and $e1.ps.sid = ps.sid| as e2
  	|evt.name = 'Connect' and ps.sid != $e2.ps.sid and ps.sid = $e1.ps.sid|
	`, &config.Config{EventSource: config.EventSourceConfig{EnableFileIOEvents: true}, Filters: &config.Filters{}})
	require.NoError(t, f.Compile())

	ss := newSequenceState(f, c, new(ps.SnapshotterMock))

	e1 := &event.Event{
		Type:      event.CreateProcess,
		Timestamp: time.Now(),
		Name:      "CreateProcess",
		Tid:       2484,
		PID:       859,
		PS: &pstypes.PS{
			Name: "cmd.exe",
			Exe:  "C:\\Windows\\system32\\svchost-temp.exe",
			SID:  "zinet",
		},
		Params: event.Params{
			params.ProcessID: {Name: params.ProcessID, Type: params.Uint32, Value: uint32(4143)},
		},
		Metadata: map[event.MetadataKey]any{"foo": "bar", "fooz": "barzz"},
	}

	e2 := &event.Event{
		Type:      event.CreateProcess,
		Timestamp: time.Now().Add(time.Millisecond * 20),
		Name:      "CreateProcess",
		Tid:       2484,
		PID:       859,
		PS: &pstypes.PS{
			Name: "cmd.exe",
			Exe:  "C:\\Windows\\system32\\svchost-temp.exe",
			SID:  "nusret",
		},
		Params: event.Params{
			params.ProcessID: {Name: params.ProcessID, Type: params.Uint32, Value: uint32(4143)},
		},
		Metadata: map[event.MetadataKey]any{"foo": "bar", "fooz": "barzz"},
	}

	e3 := &event.Event{
		Type:      event.CreateFile,
		Timestamp: time.Now().Add(time.Second),
		Name:      "CreateFile",
		Tid:       2484,
		PID:       859,
		Category:  event.File,
		PS: &pstypes.PS{
			Name: "cmd.exe",
			Exe:  "C:\\Windows\\system32\\svchost.exe",
			SID:  "nusret",
		},
		Params: event.Params{
			params.FilePath: {Name: params.FilePath, Type: params.UnicodeString, Value: "C:\\Windows\\system32\\svchost-temp.exe"},
		},
		Metadata: map[event.MetadataKey]any{"foo": "bar", "fooz": "barzz"},
	}

	e4 := &event.Event{
		Type:      event.ConnectTCPv4,
		Timestamp: time.Now().Add(time.Second * 3),
		Name:      "Connect",
		Tid:       2484,
		PID:       859,
		Category:  event.File,
		PS: &pstypes.PS{
			Name: "cmd.exe",
			Exe:  "C:\\Windows\\system32\\svchost.exe",
			SID:  "zinet",
		},
		Params: event.Params{
			params.NetDport: {Name: params.NetDport, Type: params.Uint16, Value: uint16(80)},
			params.NetDIP:   {Name: params.NetDIP, Type: params.IPv4, Value: net.ParseIP("172.1.2.3")},
		},
		Metadata: map[event.MetadataKey]any{"foo": "bar", "fooz": "barzz"},
	}

	require.False(t, ss.runSequence(e1))
	require.False(t, ss.runSequence(e2))
	require.False(t, ss.runSequence(e3))
	require.True(t, ss.runSequence(e4))
}

func TestSequenceBoundFieldsWithFunctions(t *testing.T) {
	log.SetLevel(log.DebugLevel)

	maxSequencePartialLifetime = time.Millisecond * 500

	c := &config.FilterConfig{Name: "Command shell created a temp file with network outbound"}
	f := filter.New(`
 	sequence
  maxspan 5m
    |evt.name = 'CreateFile' and file.path imatches '?:\\Windows\\System32\\*.dll'| as e1
    |evt.name = 'RegSetValue' and registry.path ~= 'HKEY_CURRENT_USER\\Volatile Environment\\Notification Packages' 
			and 
		 get_reg_value(registry.path) iin (base($e1.file.path, false))|
	`, &config.Config{EventSource: config.EventSourceConfig{EnableFileIOEvents: true, EnableRegistryEvents: true}, Filters: &config.Filters{}})
	require.NoError(t, f.Compile())

	ss := newSequenceState(f, c, new(ps.SnapshotterMock))

	e1 := &event.Event{
		Type:      event.CreateFile,
		Name:      "CreateFile",
		Category:  event.File,
		Timestamp: time.Now(),
		Tid:       2484,
		PID:       859,
		PS: &pstypes.PS{
			Name: "cmd.exe",
			Exe:  "C:\\Windows\\system32\\cmd.exe",
		},
		Params: event.Params{
			params.FilePath: {Name: params.FilePath, Type: params.UnicodeString, Value: "C:\\Windows\\System32\\passwdflt.dll"},
		},
		Metadata: map[event.MetadataKey]any{"foo": "bar", "fooz": "barzz"},
	}

	e2 := &event.Event{
		Type:      event.RegSetValue,
		Name:      "RegSetValue",
		Category:  event.Registry,
		Timestamp: time.Now().Add(time.Millisecond * 5),
		Tid:       2484,
		PID:       859,
		PS: &pstypes.PS{
			Name: "cmd.exe",
			Exe:  "C:\\Windows\\system32\\cmd.exe",
		},
		Params: event.Params{
			params.RegPath: {Name: params.RegPath, Type: params.UnicodeString, Value: "HKEY_CURRENT_USER\\Volatile Environment\\Notification Packages"},
		},
		Metadata: map[event.MetadataKey]any{"foo": "bar", "fooz": "barzz"},
	}

	key, err := registry.OpenKey(registry.CURRENT_USER, "Volatile Environment", registry.SET_VALUE)
	require.NoError(t, err)
	defer key.Close()

	defer func() {
		_ = key.DeleteValue("Notification Packages")
	}()

	require.NoError(t, key.SetStringsValue("Notification Packages", []string{"secli", "passwdflt"}))

	require.False(t, ss.runSequence(e1))
	require.True(t, ss.runSequence(e2))
}

func TestIsExpressionEvaluable(t *testing.T) {
	log.SetLevel(log.DebugLevel)

	c := &config.FilterConfig{Name: "Command shell created a temp file"}
	f := filter.New(`
	sequence
	maxspan 100ms
  	|evt.name = 'CreateProcess' and ps.name = 'cmd.exe'| by ps.exe
  	|evt.name = 'CreateFile' and file.path icontains 'temp'| by file.path
	`, &config.Config{EventSource: config.EventSourceConfig{EnableFileIOEvents: true}, Filters: &config.Filters{}})
	require.NoError(t, f.Compile())

	ss := newSequenceState(f, c, new(ps.SnapshotterMock))

	e1 := &event.Event{
		Type: event.CreateProcess,
		Name: "CreateProcess",
		Tid:  2484,
		PID:  859,
		PS: &pstypes.PS{
			Name: "cmd.exe",
			Exe:  "C:\\Windows\\system32\\svchost.exe",
		},
		Params: event.Params{
			params.ProcessID: {Name: params.ProcessID, Type: params.Uint32, Value: uint32(4143)},
		},
		Metadata: map[event.MetadataKey]any{"foo": "bar", "fooz": "barzz"},
	}

	e2 := &event.Event{
		Type: event.RenameFile,
		Name: "RenameFile",
		Tid:  2484,
		PID:  859,
		PS: &pstypes.PS{
			Name: "cmd.exe",
			Exe:  "C:\\Windows\\system32\\svchost.exe",
		},
		Params: event.Params{
			params.FilePath: {Name: params.FilePath, Type: params.UnicodeString, Value: "C:\\Temp\\dropper"},
		},
		Metadata: map[event.MetadataKey]any{"foo": "bar", "fooz": "barzz"},
	}

	assert.False(t, ss.filter.GetSequence().Expressions[0].IsEvaluable(e2))
	assert.True(t, ss.filter.GetSequence().Expressions[0].IsEvaluable(e1))
}

```

`pkg/source/doc.go`:

```go
/*
 * Copyright 2019-2020 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

// Package source defines the contract all event sources have to satisfy.
package source

```

`pkg/source/source.go`:

```go
/*
 * Copyright 2021-2024 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package source

import (
	"github.com/rabbitstack/fibratus/pkg/config"
	"github.com/rabbitstack/fibratus/pkg/event"
	"github.com/rabbitstack/fibratus/pkg/filter"
)

// EventSource defines the contract all event sources have to satisfy.
// ETW, kernel driver, or userspace instrumentation are all examples of
// event sources. The main responsibility of the event source is to capture
// the events emitted by the operating system, parse, enrich, and build
// the state that represents the foundation for the detection engine.
type EventSource interface {
	// Open starts the instrumentation machinery. It receives the global
	// configuration that the event source can utilize to influence how
	// the events are captured. Before opening the event source, it is
	// important to register any event listener that acts on behalf of the
	// received event. Likewise, if any filter must be set to drop unwanted
	// signals, it needs to be set before the event source is opened.
	Open(config *config.Config) error
	// Close performs event source shutdown. Once event source is closed,
	// any buffered or pending events are no longer dispatched to event
	// listeners.
	Close() error
	// Errors returns the channel that receives errors that are side effect
	// of event capture, parsing, or enrichment phase.
	Errors() <-chan error
	// Events return the channel where event source pushes all captured events.
	// At this point, the event has the full state associated with it. For example,
	// the full process state or the event call stack.
	Events() <-chan *event.Event
	// SetFilter attaches the filter to the event source. Only events that match
	// the filter are forwarded to the event source output channel.
	SetFilter(f filter.Filter)
	// RegisterEventListener installs event listener. Event listener represents any
	// component that satisfies the event.Listener interface. Event listener can
	// decide if the event is pushed to the output queue.
	RegisterEventListener(lis event.Listener)
}

```

`pkg/symbolize/exports.go`:

```go
/*
 * Copyright 2021-present by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package symbolize

import (
	"sync"
	"time"

	"github.com/rabbitstack/fibratus/pkg/ps"
	"github.com/rabbitstack/fibratus/pkg/util/va"
	log "github.com/sirupsen/logrus"
)

// ModuleExports contains exports for the specific module
// indexed by RVA (Relative Virtual Address).
type ModuleExports struct {
	exps map[uint32]string
}

// SymbolFromRVA finds the closest export address before RVA.
func (m *ModuleExports) SymbolFromRVA(rva va.Address) string {
	var exp uint32
	for f := range m.exps {
		if uint64(f) <= rva.Uint64() {
			if exp < f {
				exp = f
			}
		}
	}
	if exp != 0 {
		sym, ok := m.exps[exp]
		if ok && sym == "" {
			return "?"
		}
		return sym
	}
	return ""
}

// ExportsDirectoryCache stores the cached module exports extracted
// from the PE export directory.
type ExportsDirectoryCache struct {
	sync.RWMutex
	exports map[string]*ModuleExports

	purger *time.Ticker
	quit   chan struct{}

	psnap ps.Snapshotter
}

// NewExportsDirectoryCache returns a fresh instance of the exports directory cache.
func NewExportsDirectoryCache(psnap ps.Snapshotter) *ExportsDirectoryCache {
	c := &ExportsDirectoryCache{
		exports: make(map[string]*ModuleExports),
		purger:  time.NewTicker(time.Minute * 20),
		quit:    make(chan struct{}, 1),
		psnap:   psnap,
	}
	return c
}

// Exports returns the exports for the given module path. If
// the exports can't be find, then the module PE is parsed
// and the exports cache updated.
func (c *ExportsDirectoryCache) Exports(mod string) (*ModuleExports, bool) {
	c.RLock()
	exports, ok := c.exports[mod]
	c.RUnlock()
	if ok {
		return exports, true
	}
	pe, err := parsePeFile(mod)
	if err != nil {
		return nil, false
	}
	c.Lock()
	defer c.Unlock()
	exports = &ModuleExports{exps: pe.Exports}
	c.exports[mod] = exports
	return exports, true
}

// Clear removes all module exports from the directory cache.
func (c *ExportsDirectoryCache) Clear() {
	c.Lock()
	defer c.Unlock()
	c.exports = make(map[string]*ModuleExports)
}

// RemoveExports removes all exports associated with the module.
func (c *ExportsDirectoryCache) RemoveExports(mod string) {
	c.Lock()
	defer c.Unlock()
	delete(c.exports, mod)
}

func (c *ExportsDirectoryCache) purge() {
	for {
		select {
		case <-c.purger.C:
			c.clearExports()
		case <-c.quit:
			return
		}
	}
}

// clearExports purges all module exports that
// don't exist in the global snapshotter state.
func (c *ExportsDirectoryCache) clearExports() {
	mods := c.psnap.FindAllModules()
	c.Lock()
	defer c.Unlock()
	for exp := range c.exports {
		if _, ok := mods[exp]; !ok {
			log.Debugf("removing stale export %s from directory cache", exp)
			delete(c.exports, exp)
		}
	}
}

```

`pkg/symbolize/exports_test.go`:

```go
/*
 * Copyright 2021-present by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package symbolize

import (
	"testing"

	"github.com/rabbitstack/fibratus/pkg/util/va"
	"github.com/stretchr/testify/assert"
)

func TestSymbolFromRVA(t *testing.T) {
	var tests = []struct {
		rva            va.Address
		exports        map[uint32]string
		expectedSymbol string
	}{
		{va.Address(317949), map[uint32]string{
			9824:   "SHCreateScopeItemFromShellItem",
			23248:  "SHCreateScopeItemFromIDList",
			165392: "DllGetClassObject",
			186368: "SHCreateSearchIDListFromAutoList",
			238048: "DllCanUnloadNow",
			240112: "IsShellItemInSearchIndex",
			240304: "IsMSSearchEnabled",
			272336: "SHSaveBinaryAutoListToStream",
			310672: "DllMain",
			317920: "",
			320864: "",
			434000: "SHCreateAutoList",
			434016: "SHCreateAutoListWithID",
			555040: "CreateDefaultProviderResolver",
			571136: "GetGatherAdmin",
			572592: "SEARCH_RemoteLocationsCscStateCache_IsRemoteLocationInCsc"},
			"?",
		},
		{va.Address(434011), map[uint32]string{
			9824:   "SHCreateScopeItemFromShellItem",
			23248:  "SHCreateScopeItemFromIDList",
			165392: "DllGetClassObject",
			186368: "SHCreateSearchIDListFromAutoList",
			238048: "DllCanUnloadNow",
			240112: "IsShellItemInSearchIndex",
			240304: "IsMSSearchEnabled",
			272336: "SHSaveBinaryAutoListToStream",
			310672: "DllMain",
			317920: "",
			320864: "",
			434000: "SHCreateAutoList",
			434016: "SHCreateAutoListWithID",
			555040: "CreateDefaultProviderResolver",
			571136: "GetGatherAdmin",
			572592: "SEARCH_RemoteLocationsCscStateCache_IsRemoteLocationInCsc"},
			"SHCreateAutoList",
		},
		{va.Address(4532), map[uint32]string{
			9824:   "SHCreateScopeItemFromShellItem",
			23248:  "SHCreateScopeItemFromIDList",
			165392: "DllGetClassObject",
			186368: "SHCreateSearchIDListFromAutoList",
			238048: "DllCanUnloadNow",
			240112: "IsShellItemInSearchIndex",
			240304: "IsMSSearchEnabled",
			572592: "SEARCH_RemoteLocationsCscStateCache_IsRemoteLocationInCsc"},
			"",
		},
	}

	for _, tt := range tests {
		t.Run(tt.expectedSymbol, func(t *testing.T) {
			exps := &ModuleExports{exps: tt.exports}
			assert.Equal(t, tt.expectedSymbol, exps.SymbolFromRVA(tt.rva))
		})
	}
}

```

`pkg/symbolize/resolver.go`:

```go
/*
 * Copyright 2021-2022 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package symbolize

import (
	"github.com/rabbitstack/fibratus/pkg/config"
	"github.com/rabbitstack/fibratus/pkg/sys"
	"github.com/rabbitstack/fibratus/pkg/util/va"
	"golang.org/x/sys/windows"
	"runtime"
)

// Resolver is a minimal interface all symbol resolvers have to satisfy.
type Resolver interface {
	// Initialize performs preparation tasks prior to
	// initiating the symbolization process. This method
	// receives an optional options bitmask that may control
	// the symbol handler initialization.
	Initialize(proc windows.Handle, opts uint32) error
	// GetModuleName retrieves the module name for the given
	// process handle and address.
	GetModuleName(proc windows.Handle, addr va.Address) string
	// GetSymbolNameAndOffset returns the symbol name and
	// its offset for the given process handle and address.
	GetSymbolNameAndOffset(proc windows.Handle, addr va.Address) (string, uint64)
	// LoadModule loads the symbol table.
	LoadModule(proc windows.Handle, module string, addr va.Address) error
	// UnloadModule unloads the symbol table.
	UnloadModule(proc windows.Handle, addr va.Address)
	// Cleanup disposes any allocated resources.
	Cleanup(proc windows.Handle)
}

// DebugHelpResolver is the symbol resolver that
// piggybacks on top of Debug Help API facilities
// to convert raw stack addresses to symbols.
type DebugHelpResolver struct {
	config *config.Config
}

func NewDebugHelpResolver(config *config.Config) *DebugHelpResolver {
	return &DebugHelpResolver{config: config}
}

func (r *DebugHelpResolver) Initialize(proc windows.Handle, opts uint32) error {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()
	sys.SymSetOptions(opts)
	if !sys.SymInitialize(proc, r.config.SymbolPathsUTF16(), true) {
		return windows.GetLastError()
	}
	return nil
}

func (r *DebugHelpResolver) GetModuleName(proc windows.Handle, addr va.Address) string {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()
	return sys.GetSymModuleName(proc, addr.Uint64())
}

func (r *DebugHelpResolver) GetSymbolNameAndOffset(proc windows.Handle, addr va.Address) (string, uint64) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()
	return sys.GetSymName(proc, addr.Uint64())
}

func (r *DebugHelpResolver) LoadModule(proc windows.Handle, module string, addr va.Address) error {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()
	m, err := windows.UTF16PtrFromString(module)
	if err != nil {
		return err
	}
	if sys.SymLoadModule(proc, 0, m, nil, addr.Uint64(), 0, 0, 0) == 0 {
		return windows.GetLastError()
	}
	return nil
}

func (r *DebugHelpResolver) UnloadModule(proc windows.Handle, addr va.Address) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()
	sys.SymUnloadModule(proc, addr.Uint64())
}

func (r *DebugHelpResolver) Cleanup(proc windows.Handle) {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()
	sys.SymCleanup(proc)
}

```

`pkg/symbolize/symbolizer.go`:

```go
/*
 * Copyright 2021-2022 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package symbolize

import (
	"expvar"
	"fmt"
	"path/filepath"
	"slices"
	"strings"
	"sync"
	"time"

	"github.com/rabbitstack/fibratus/pkg/callstack"
	"github.com/rabbitstack/fibratus/pkg/config"
	"github.com/rabbitstack/fibratus/pkg/event"
	"github.com/rabbitstack/fibratus/pkg/event/params"
	"github.com/rabbitstack/fibratus/pkg/pe"
	"github.com/rabbitstack/fibratus/pkg/ps"
	pstypes "github.com/rabbitstack/fibratus/pkg/ps/types"
	"github.com/rabbitstack/fibratus/pkg/sys"
	"github.com/rabbitstack/fibratus/pkg/util/convert"
	"github.com/rabbitstack/fibratus/pkg/util/threadcontext"
	"github.com/rabbitstack/fibratus/pkg/util/va"
	log "github.com/sirupsen/logrus"
	"golang.org/x/sys/windows"
)

// ErrSymInitialize is thrown if the process symbol handler fails to initialize
var ErrSymInitialize = func(pid uint32) error {
	return fmt.Errorf("unable to initialize symbol handler for pid %d", pid)
}

var (
	// callstackProcessErrors counts callstack process errors
	callstackProcessErrors = expvar.NewInt("symbolizer.process.errors")

	// symCleanups counts the number of symbol cleanups
	symCleanups = expvar.NewInt("symbolizer.symbol.cleanups")

	// symCacheHits counts the number of cache hits in the symbols cache
	symCacheHits = expvar.NewInt("symbolizer.cache.hits")

	// symCachedSymbols counts the number of cached symbol infos
	symCachedSymbols = expvar.NewInt("symbolizer.cached.symbols")

	// symModulesCount counts the number of loaded module exports
	symModulesCount = expvar.NewInt("symbolizer.modules.count")

	// symEnumModulesHits counts the number of hits from enumerated modules
	symEnumModulesHits = expvar.NewInt("symbolizer.enum.modules.hits")

	// debugHelpFallbacks counts how many times we Debug Help API was called
	// to resolve symbol information since we fail to do this from process
	// modules and PE export directory data
	debugHelpFallbacks = expvar.NewInt("symbolizer.debughelp.fallbacks")
)

// parsePeFile wraps the PE parsing function to permit
// overriding the function in unit tests.
var parsePeFile = func(name string, option ...pe.Option) (*pe.PE, error) {
	return pe.ParseFile(name, pe.WithSections(), pe.WithExports())
}

// procTTL specifies the number of interval
// a process is allowed to remain in the map before
// its handle and symbol resources are disposed
var procTTL = 15 * time.Second

type process struct {
	pid      uint32
	handle   windows.Handle
	accessed time.Time
	accesses uint64
}

func (p *process) keepalive() {
	p.accessed = time.Now()
	p.accesses++
}

type module struct {
	exports                    *ModuleExports
	minExportRVA, maxExportRVA uint32
	hasExports                 bool
}

func (m *module) isUnexported(rva va.Address) bool {
	if m.minExportRVA == 0 || m.maxExportRVA == 0 {
		return false
	}
	return rva.Uint64() < uint64(m.minExportRVA) || rva.Uint64() > uint64(m.maxExportRVA)
}

type syminfo struct {
	module        string
	symbol        string
	moduleAddress va.Address // base module address
}

// Symbolizer is responsible for converting raw addresses
// into symbol names and modules with the assistance of the
// export directory or symbol resolver.
type Symbolizer struct {
	config *config.Config
	procs  map[uint32]*process
	mods   map[uint32]map[va.Address]*module
	mu     sync.Mutex

	// symbols stores the mapping of stack
	// return address and the symbol information
	// identifying the originated call. It is populated
	// by the Debug Help API function when the module
	// doesn't exist in process state, and in addition
	// it is populated by each export directory symbol
	// resolution
	symbols map[uint32]map[va.Address]syminfo

	// exps stores resolved export directories
	exps *ExportsDirectoryCache

	r     Resolver
	psnap ps.Snapshotter

	cleaner *time.Ticker
	purger  *time.Ticker

	quit chan struct{}

	enqueue bool
}

// NewSymbolizer builds a new instance of address symbolizer.
// It performs the initialization of symbol options, symbols
// handlers and modules for kernel address symbolization.
func NewSymbolizer(r Resolver, psnap ps.Snapshotter, config *config.Config, enqueue bool) *Symbolizer {
	sym := &Symbolizer{
		config:  config,
		procs:   make(map[uint32]*process),
		mods:    make(map[uint32]map[va.Address]*module),
		symbols: make(map[uint32]map[va.Address]syminfo),
		cleaner: time.NewTicker(time.Second * 2),
		purger:  time.NewTicker(time.Minute * 5),
		quit:    make(chan struct{}, 1),
		enqueue: enqueue,
		exps:    NewExportsDirectoryCache(psnap),
		r:       r,
		psnap:   psnap,
	}

	if config.SymbolizeKernelAddresses {
		opts := uint32(sys.SymUndname | sys.SymCaseInsensitive | sys.SymAutoPublics)
		err := r.Initialize(windows.CurrentProcess(), opts)
		if err != nil {
			log.Errorf("unable to initialize symbol handler for the current process: %v", err)
		}
		devs := sys.EnumDevices()
		for _, dev := range devs {
			_ = r.LoadModule(windows.CurrentProcess(), dev.Filename, va.Address(dev.Addr))
		}
	}

	go sym.housekeep()
	go sym.exps.purge()

	return sym
}

func (s *Symbolizer) CanEnqueue() bool { return s.enqueue }

func (s *Symbolizer) Close() {
	s.cleaner.Stop()
	s.purger.Stop()
	s.quit <- struct{}{}
	s.exps.quit <- struct{}{}
	s.cleanAllSyms()
	if s.config.SymbolizeKernelAddresses {
		for _, dev := range sys.EnumDevices() {
			s.r.UnloadModule(windows.CurrentProcess(), va.Address(dev.Addr))
		}
	}
}

func (s *Symbolizer) ProcessEvent(e *event.Event) (bool, error) {
	if e.IsTerminateProcess() {
		// release symbol handler and process handle
		pid := e.Params.MustGetPid()
		s.mu.Lock()
		defer s.mu.Unlock()
		delete(s.mods, pid)
		delete(s.symbols, pid)
		// remove exports for this process
		s.exps.RemoveExports(e.GetParamAsString(params.Exe))
		symCachedSymbols.Add(-int64(len(s.symbols[pid])))
		proc, ok := s.procs[pid]
		if !ok {
			return true, nil
		}
		s.r.Cleanup(proc.handle)
		_ = windows.CloseHandle(proc.handle)
		delete(s.procs, pid)
		return true, nil
	}

	if e.IsLoadImage() || e.IsUnloadImage() {
		filename := e.GetParamAsString(params.ImagePath)
		addr := e.Params.TryGetAddress(params.ImageBase)
		// if the kernel driver is loaded or unloaded,
		// load/unload symbol handlers respectively
		if (strings.ToLower(filepath.Ext(filename)) == ".sys" ||
			e.Params.TryGetBool(params.FileIsDriver)) && s.config.SymbolizeKernelAddresses {
			if e.IsLoadImage() {
				err := s.r.LoadModule(windows.CurrentProcess(), filename, addr)
				if err != nil {
					log.Errorf("unable to load symbol table for %s module: %v", filename, err)
				}
			} else {
				s.r.UnloadModule(windows.CurrentProcess(), addr)
			}
		}

		// remove module if it has been unmapped from the process VAS
		err := s.syncModules(e)
		if err != nil {
			log.Error(err)
		}
	}

	if !e.Params.Contains(params.Callstack) {
		return true, nil
	}
	defer e.Params.Remove(params.Callstack)

	err := s.processCallstack(e)
	if err != nil {
		callstackProcessErrors.Add(1)
	}

	return true, nil
}

// syncModules reconciles the state of loaded modules.
// When the module is unloaded from the process address
// space, its information is pruned from the cache.
// If the new module is loaded and not already present in
// the map, we get its export directory and insert
// into the map.
func (s *Symbolizer) syncModules(e *event.Event) error {
	base := e.Params.TryGetAddress(params.ImageBase)
	size := e.Params.TryGetUint64(params.ImageSize)

	if e.IsUnloadImage() {
		s.mu.Lock()
		defer s.mu.Unlock()
		if _, ok := s.mods[e.PID][base]; ok {
			symModulesCount.Add(-1)
			delete(s.mods[e.PID], base)
			// prune symbol entry from the cache if
			// the symbol address falls within the
			// unmapped module
			syms, ok := s.symbols[e.PID]
			if !ok {
				return nil
			}
			for addr := range syms {
				if addr >= base && addr <= base.Inc(size) {
					delete(s.symbols[e.PID], base)
				}
			}
		}
	}

	return nil
}

func (s *Symbolizer) processCallstack(e *event.Event) error {
	addrs := e.Params.MustGetSliceAddrs(params.Callstack)
	e.Callstack.Init(len(addrs))

	// skip stack enrichment for the events generated by the System process
	// except the LoadImage event which may prove to be useful when the driver
	// is loaded and the kernel address symbolization is enabled
	if e.IsSystemPid() && !e.IsLoadImage() {
		return nil
	}

	s.mu.Lock()
	defer s.mu.Unlock()

	if e.PS != nil {
		var (
			addr va.Address
			pid  uint32
		)

		// get the address that we want to symbolize
		switch e.Type {
		case event.CreateThread:
			pid = e.Params.MustGetPid()
			addr = e.Params.TryGetAddress(params.StartAddress)
		case event.SubmitThreadpoolWork, event.SubmitThreadpoolCallback:
			pid = e.PID
			addr = e.Params.TryGetAddress(params.ThreadpoolCallback)
		}

		// symbolize thread start or thread pool callback address
		// and resolve the module name that contains the function
		if addr != 0 {
			mod := e.PS.FindModuleByVa(addr)
			// perform lookup against parent modules
			if mod == nil && e.PS.Parent != nil {
				mod = e.PS.Parent.FindModuleByVa(addr)
			}
			symbol := s.symbolizeAddress(pid, addr, mod)

			if symbol != "" && symbol != "?" {
				switch e.Type {
				case event.CreateThread:
					e.Params.Append(params.StartAddressSymbol, params.UnicodeString, symbol)
				case event.SubmitThreadpoolWork, event.SubmitThreadpoolCallback:
					e.Params.Append(params.ThreadpoolCallbackSymbol, params.UnicodeString, symbol)

					ctx := e.Params.TryGetAddress(params.ThreadpoolContext)

					// if the callback resolves to one of the functions
					// that receive the CONTEXT structure as a parameter
					// try to read the thread context and resolve the
					// function address stored in the instruction pointer
					if ctx != 0 && threadcontext.IsParamOfFunc(symbol) {
						rip := threadcontext.Rip(pid, ctx)
						if rip != 0 {
							e.Params.Append(params.ThreadpoolContextRip, params.Address, rip.Uint64())

							m := e.PS.FindModuleByVa(rip)
							if m != nil {
								e.Params.Append(params.ThreadpoolContextRipModule, params.UnicodeString, m.Name)
							}

							sym := s.symbolizeAddress(pid, rip, m)
							if sym != "" && sym != "?" {
								e.Params.Append(params.ThreadpoolContextRipSymbol, params.UnicodeString, sym)
							}
						}
					}
				}
			}

			if mod != nil {
				switch e.Type {
				case event.CreateThread:
					e.Params.Append(params.StartAddressModule, params.UnicodeString, mod.Name)
				case event.SubmitThreadpoolWork, event.SubmitThreadpoolCallback:
					e.Params.Append(params.ThreadpoolCallbackModule, params.UnicodeString, mod.Name)
				}
			}
		}

		// try to resolve addresses from process
		// state and PE export directory data
		s.pushFrames(addrs, e)

		return nil
	}

	pid := e.StackPID()
	proc, ok := s.procs[pid]
	if !ok {
		handle, err := windows.OpenProcess(windows.SYNCHRONIZE|windows.PROCESS_QUERY_INFORMATION, false, pid)
		if err != nil {
			s.pushFrames(addrs, e)
			return err
		}
		// initialize symbol handler
		opts := uint32(sys.SymUndname | sys.SymCaseInsensitive | sys.SymAutoPublics | sys.SymOmapFindNearest | sys.SymDeferredLoads)
		err = s.r.Initialize(handle, opts)
		if err != nil {
			s.pushFrames(addrs, e)
			return ErrSymInitialize(pid)
		}
		proc = &process{pid, handle, time.Now(), 1}
		s.procs[pid] = proc
	}

	s.pushFrames(addrs, e)

	proc.keepalive()

	return nil
}

// pushFrames populates the stack frames. The
// addresses slice contains the original return
// addresses where the first element is the
// most recent kernel return address that is
// pushed last into the event callstack.
func (s *Symbolizer) pushFrames(addrs []va.Address, e *event.Event) {
	for i := len(addrs) - 1; i >= 0; i-- {
		e.Callstack.PushFrame(s.produceFrame(addrs[i], e))
	}
}

// produceFrame fabrics a decorated stack frame.
// For return addresses residing in the kernel
// address space, the symbolization is always
// performed. All symbols are resolved from the
// PE export directory entries. If either the
// symbol or module are not resolved, then we
// fall back to Debug API.
func (s *Symbolizer) produceFrame(addr va.Address, e *event.Event) callstack.Frame {
	pid := e.StackPID()
	frame := callstack.Frame{PID: pid, Addr: addr}
	if addr.InSystemRange() {
		if s.config.SymbolizeKernelAddresses {
			frame.Module = s.r.GetModuleName(windows.CurrentProcess(), addr)
			frame.Symbol, frame.Offset = s.r.GetSymbolNameAndOffset(windows.CurrentProcess(), addr)
		}
		return frame
	}

	// did we hit this address previously?
	if sym, ok := s.symbols[pid]; ok {
		if symbol, ok := sym[addr]; ok {
			symCacheHits.Add(1)
			frame.Module, frame.Symbol, frame.ModuleAddress = symbol.module, symbol.symbol, symbol.moduleAddress
			return frame
		}
	}

	ps := e.PS

	// for process creation events initiated by
	// brokered processes, obtain the real parent
	// process state
	if e.IsSurrogateProcess() {
		var ok bool
		ok, ps = s.psnap.Find(e.Params.MustGetUint32(params.ProcessRealParentID))
		if !ok {
			ps = e.PS
		}
	}

	if ps != nil {
		mod := ps.FindModuleByVa(addr)
		// perform lookup against parent modules
		if mod == nil && ps.Parent != nil {
			mod = ps.Parent.FindModuleByVa(addr)
		}
		if mod == nil {
			// our last resort is to enumerate process modules
			modules := sys.EnumProcessModules(pid)
			for _, m := range modules {
				b := va.Address(m.BaseOfDll)
				size := uint64(m.SizeOfImage)
				if addr >= b && addr <= b.Inc(size) {
					mod = &pstypes.Module{
						Name:        m.Name,
						BaseAddress: b,
						Size:        size,
					}
					symEnumModulesHits.Add(1)
					break
				}
			}
		}

		if mod != nil {
			frame.Module = mod.Name
			frame.ModuleAddress = mod.BaseAddress
			m, ok := s.mods[pid][mod.BaseAddress]
			peOK := true
			if !ok {
				var exports *ModuleExports
				exports, peOK = s.exps.Exports(mod.Name)
				m = &module{
					hasExports: true,
					exports:    &ModuleExports{exps: make(map[uint32]string)},
				}
				if exports != nil {
					m.exports = exports
					m.hasExports = len(m.exports.exps) > 0
					exportRVAs := convert.MapKeysToSlice(m.exports.exps)
					if m.hasExports {
						m.minExportRVA, m.maxExportRVA = slices.Min(exportRVAs), slices.Max(exportRVAs)
					}
				} else {
					m.hasExports = false
				}
				symModulesCount.Add(1)
				s.cacheModule(e.PID, mod.BaseAddress, m)
			}
			rva := addr.Dec(mod.BaseAddress.Uint64())
			frame.Symbol = m.exports.SymbolFromRVA(rva)
			// permit unknown symbols for executable modules
			if frame.Symbol == "" && strings.EqualFold(filepath.Ext(mod.Name), ".exe") {
				frame.Symbol = "?"
			}
			// empirical observations revealed that if the syscall
			// is performed within the DLL unexported symbol, its RVA
			// is not in the range of exported symbols RVAs. Mark the
			// symbol as unknown. Likewise, if the module doesn't export
			// any symbols, don't try resolving symbol information with
			// Debug Help API
			if frame.Symbol == "" && (m.isUnexported(rva) || (!m.hasExports && peOK)) {
				frame.Symbol = "?"
			}
		}

		if frame.Module != "" && frame.Symbol != "" {
			// store resolved symbol information in cache
			s.cacheSymbol(pid, addr, &frame)
			return frame
		}
	}

	debugHelpFallbacks.Add(1)

	// fallback to Debug Help API
	proc, ok := s.procs[pid]
	if !ok {
		handle, err := windows.OpenProcess(windows.SYNCHRONIZE|windows.PROCESS_QUERY_INFORMATION, false, pid)
		if err != nil {
			return frame
		}
		// initialize symbol handler
		opts := uint32(sys.SymUndname | sys.SymCaseInsensitive | sys.SymAutoPublics | sys.SymOmapFindNearest | sys.SymDeferredLoads)
		err = s.r.Initialize(handle, opts)
		if err != nil {
			return frame
		}
		proc = &process{pid, handle, time.Now(), 1}
		s.procs[pid] = proc
	}

	proc.keepalive()

	if frame.Module == "" {
		mod := s.r.GetModuleName(proc.handle, addr)
		frame.Module = mod
		if frame.Module == "?" {
			frame.Module = "unbacked"
		}
	}
	if frame.Symbol == "" {
		frame.Symbol, frame.Offset = s.r.GetSymbolNameAndOffset(proc.handle, addr)
	}

	// store resolved symbol information in cache
	s.cacheSymbol(pid, addr, &frame)

	return frame
}

// symbolizeAddress resolves the given address to a symbol. If the symbol
// for this address was resolved previously, we fetch it from the cache.
// On the contrary, the symbol is first consulted in the export directory.
// If not found, the Debug Help API is used to symbolize the address.
func (s *Symbolizer) symbolizeAddress(pid uint32, addr va.Address, mod *pstypes.Module) string {
	if addr.InSystemRange() {
		return ""
	}

	symbol, ok := s.symbols[pid][addr]
	if !ok && mod != nil {
		// resolve symbol from the export directory
		exports, ok := s.exps.Exports(mod.Name)
		if !ok {
			goto fallback
		}
		rva := addr.Dec(mod.BaseAddress.Uint64())
		symbol.symbol = exports.SymbolFromRVA(rva)
	}

fallback:
	// try to get the symbol via Debug Help API
	if symbol.symbol == "" {
		proc, ok := s.procs[pid]
		if !ok {
			handle, err := windows.OpenProcess(windows.SYNCHRONIZE|windows.PROCESS_QUERY_INFORMATION, false, pid)
			if err != nil {
				return ""
			}

			// initialize symbol handler
			opts := uint32(sys.SymUndname | sys.SymCaseInsensitive | sys.SymAutoPublics | sys.SymOmapFindNearest | sys.SymDeferredLoads)
			err = s.r.Initialize(handle, opts)
			if err != nil {
				return ""
			}

			proc = &process{pid, handle, time.Now(), 1}
			s.procs[pid] = proc

			// resolve address to symbol
			symbol.symbol, _ = s.r.GetSymbolNameAndOffset(handle, addr)
			symbol.module = s.r.GetModuleName(handle, addr)
		} else {
			symbol.symbol, _ = s.r.GetSymbolNameAndOffset(proc.handle, addr)
			symbol.module = s.r.GetModuleName(proc.handle, addr)
			proc.keepalive()
		}
	}

	if symbol.module == "" && mod != nil {
		symbol.module = mod.Name
	}

	// cache the resolved symbol
	if sym, ok := s.symbols[pid]; ok {
		if _, ok := sym[addr]; !ok {
			s.symbols[pid][addr] = symbol
		}
	} else {
		s.symbols[pid] = map[va.Address]syminfo{addr: symbol}
	}

	return symbol.symbol
}

func (s *Symbolizer) cacheModule(pid uint32, addr va.Address, m *module) {
	if mod, ok := s.mods[pid]; ok {
		if _, ok := mod[addr]; !ok {
			s.mods[pid][addr] = m
		}
	} else {
		s.mods[pid] = map[va.Address]*module{addr: m}
	}
}

func (s *Symbolizer) cacheSymbol(pid uint32, addr va.Address, frame *callstack.Frame) {
	if sym, ok := s.symbols[pid]; ok {
		if _, ok := sym[addr]; !ok {
			symCachedSymbols.Add(1)
			s.symbols[pid][addr] = syminfo{module: frame.Module, symbol: frame.Symbol, moduleAddress: frame.ModuleAddress}
		}
	} else {
		symCachedSymbols.Add(1)
		s.symbols[pid] = map[va.Address]syminfo{addr: {module: frame.Module, symbol: frame.Symbol, moduleAddress: frame.ModuleAddress}}
	}
}

func (s *Symbolizer) cleanSym() {
	s.mu.Lock()
	defer s.mu.Unlock()
	for _, proc := range s.procs {
		if time.Since(proc.accessed) > procTTL {
			symCleanups.Add(1)
			log.Debugf("deallocating symbol resources for pid %d. Accessed %d time(s)", proc.pid, proc.accesses)
			s.r.Cleanup(proc.handle)
			_ = windows.Close(proc.handle)
			delete(s.procs, proc.pid)
		}
	}
}

func (s *Symbolizer) cleanAllSyms() {
	s.mu.Lock()
	defer s.mu.Unlock()
	for _, proc := range s.procs {
		s.r.Cleanup(proc.handle)
		_ = windows.Close(proc.handle)
	}
	s.procs = make(map[uint32]*process)
}

func (s *Symbolizer) housekeep() {
	for {
		select {
		case <-s.cleaner.C:
			s.cleanSym()
		case <-s.purger.C:
			s.cleanAllSyms()
		case <-s.quit:
			return
		}
	}
}

func (s *Symbolizer) procsSize() int {
	s.mu.Lock()
	defer s.mu.Unlock()
	return len(s.procs)
}

```

`pkg/symbolize/symbolizer_test.go`:

```go
/*
 * Copyright 2021-2022 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package symbolize

import (
	"math/rand"
	"os"
	"testing"
	"time"

	"github.com/rabbitstack/fibratus/pkg/config"
	"github.com/rabbitstack/fibratus/pkg/event"
	"github.com/rabbitstack/fibratus/pkg/event/params"
	"github.com/rabbitstack/fibratus/pkg/fs"
	"github.com/rabbitstack/fibratus/pkg/pe"
	"github.com/rabbitstack/fibratus/pkg/ps"
	pstypes "github.com/rabbitstack/fibratus/pkg/ps/types"
	"github.com/rabbitstack/fibratus/pkg/sys"
	"github.com/rabbitstack/fibratus/pkg/util/va"
	log "github.com/sirupsen/logrus"
	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/mock"
	"github.com/stretchr/testify/require"
	"golang.org/x/sys/windows"
)

// MockResolver for unit testing
type MockResolver struct {
	mock.Mock
}

// Initialize method...
func (r *MockResolver) Initialize(proc windows.Handle, opts uint32) error {
	called := r.Called(proc, opts)
	return called.Error(0)
}

// GetModuleName method...
func (r *MockResolver) GetModuleName(proc windows.Handle, addr va.Address) string {
	called := r.Called(proc, addr)
	return called.String(0)
}

// GetSymbolNameAndOffset method...
func (r *MockResolver) GetSymbolNameAndOffset(proc windows.Handle, addr va.Address) (string, uint64) {
	called := r.Called(proc, addr)
	return called.String(0), uint64(called.Int(1))
}

// LoadModule method...
func (r *MockResolver) LoadModule(proc windows.Handle, module string, addr va.Address) error {
	called := r.Called(proc, module, addr)
	return called.Error(0)
}

// UnloadModule method...
func (r *MockResolver) UnloadModule(proc windows.Handle, addr va.Address) {
	r.Called(proc, addr)
}

// Cleanup method...
func (r *MockResolver) Cleanup(proc windows.Handle) {
	r.Called(proc)
}

func TestLoadKernelModuleSymbolTables(t *testing.T) {
	r := new(MockResolver)
	c := &config.Config{SymbolizeKernelAddresses: true}

	psnap := new(ps.SnapshotterMock)

	opts := uint32(sys.SymUndname | sys.SymCaseInsensitive | sys.SymAutoPublics)
	r.On("Initialize", windows.CurrentProcess(), opts).Return(nil)
	r.On("LoadModule", windows.CurrentProcess(), mock.Anything, mock.Anything).Return(nil)
	r.On("UnloadModule", mock.Anything, mock.Anything)

	s := NewSymbolizer(r, psnap, c, false)
	require.NotNil(t, s)
	defer s.Close()

	r.AssertNumberOfCalls(t, "Initialize", 1)
	r.AssertNumberOfCalls(t, "LoadModule", len(sys.EnumDevices()))
}

func TestProcessCallstackPeExports(t *testing.T) {
	r := new(MockResolver)
	c := &config.Config{}
	log.SetLevel(log.DebugLevel)

	psnap := new(ps.SnapshotterMock)

	r.On("UnloadModule", mock.Anything, mock.Anything)
	opts := uint32(sys.SymUndname | sys.SymCaseInsensitive | sys.SymAutoPublics | sys.SymOmapFindNearest | sys.SymDeferredLoads)
	r.On("Initialize", mock.Anything, opts).Return(nil)
	r.On("Cleanup", mock.Anything)

	r.On("GetModuleName", mock.Anything, mock.Anything).Return("?").Once()
	r.On("GetSymbolNameAndOffset", mock.Anything, mock.Anything).Return("?", 0).Once()
	r.On("GetSymbolNameAndOffset", mock.Anything, mock.Anything).Return("CreateProcessW", 0x54).Once()

	psnap.On("FindModule", mock.Anything).Return(false, nil).Once()

	s := NewSymbolizer(r, psnap, c, false)
	require.NotNil(t, s)
	defer s.Close()

	proc := &pstypes.PS{
		Name:      "notepad.exe",
		PID:       23234,
		Ppid:      2434,
		Exe:       `C:\Windows\notepad.exe`,
		Cmdline:   `C:\Windows\notepad.exe`,
		SID:       "S-1-1-18",
		Cwd:       `C:\Windows\`,
		SessionID: 1,
		Threads: map[uint32]pstypes.Thread{
			3453: {Tid: 3453, StartAddress: va.Address(140729524944768), IOPrio: 2, PagePrio: 5, KstackBase: va.Address(18446677035730165760), KstackLimit: va.Address(18446677035730137088), UstackLimit: va.Address(86376448), UstackBase: va.Address(86372352)},
			3455: {Tid: 3455, StartAddress: va.Address(140729524944768), IOPrio: 3, PagePrio: 5, KstackBase: va.Address(18446677035730165760), KstackLimit: va.Address(18446677035730137088), UstackLimit: va.Address(86376448), UstackBase: va.Address(86372352)},
		},
		Envs: map[string]string{"ProgramData": "C:\\ProgramData", "COMPUTRENAME": "archrabbit"},
		Modules: []pstypes.Module{
			{Name: "C:\\Windows\\System32\\ntdll.dll", Size: 32358, Checksum: 23123343, BaseAddress: va.Address(0x7ffb313833a3), DefaultBaseAddress: va.Address(0x7ffb313833a3)},
			{Name: "C:\\Windows\\System32\\kernel32.dll", Size: 12354, Checksum: 23123343, BaseAddress: va.Address(0x7ffb5c1d0126), DefaultBaseAddress: va.Address(0x7ffb5c1d0126)},
			{Name: "C:\\Windows\\System32\\user32.dll", Size: 212354, Checksum: 33123343, BaseAddress: va.Address(0x7ffb5d8e11c4), DefaultBaseAddress: va.Address(0x7ffb5d8e11c4)},
		},
	}

	e := &event.Event{
		Type:        event.CreateFile,
		Tid:         2484,
		PID:         uint32(os.Getpid()),
		CPU:         1,
		Seq:         2,
		Name:        "CreateFile",
		Timestamp:   time.Now(),
		Category:    event.File,
		Host:        "archrabbit",
		Description: "Creates or opens a new file, directory, I/O device, pipe, console",
		Params: event.Params{
			params.FileObject:    {Name: params.FileObject, Type: params.Uint64, Value: uint64(12456738026482168384)},
			params.FilePath:      {Name: params.FilePath, Type: params.UnicodeString, Value: "C:\\Windows\\system32\\mimi.dll"},
			params.FileType:      {Name: params.FileType, Type: params.AnsiString, Value: "file"},
			params.FileOperation: {Name: params.FileOperation, Type: params.Enum, Value: uint32(2), Enum: fs.FileCreateDispositions},
			params.Callstack:     {Name: params.Callstack, Type: params.Slice, Value: []va.Address{0x7ffb5c1d0396, 0x7ffb5d8e61f4, 0x7ffb3138592e, 0x7ffb313853b2, 0x2638e59e0a5}},
		},
		PS: proc,
	}

	parsePeFile = func(name string, option ...pe.Option) (*pe.PE, error) {
		exports := map[uint32]string{
			8192:  "RtlSetSearchPathMode",
			9344:  "RtlCreateQueryDebugBuffer",
			20352: "LoadKeyboardLayoutW",
		}
		px := &pe.PE{
			Exports: exports,
		}
		return px, nil
	}

	_, err := s.ProcessEvent(e)
	require.NoError(t, err)

	assert.Len(t, e.Callstack, 5)
	assert.Len(t, e.Callstack.Symbols(), 5)
	assert.Len(t, e.Callstack.Modules(), 5)

	assert.Equal(t, "unbacked!?", e.Callstack.Symbols()[0])
	assert.Equal(t, "ntdll.dll!RtlSetSearchPathMode", e.Callstack.Symbols()[1])
	assert.Equal(t, "ntdll.dll!RtlCreateQueryDebugBuffer", e.Callstack.Symbols()[2])
	assert.Equal(t, "user32.dll!LoadKeyboardLayoutW", e.Callstack.Symbols()[3])
	assert.Equal(t, "kernel32.dll!?", e.Callstack.Symbols()[4]) // unexported symbol

	assert.Equal(t, "kernel32.dll|user32.dll|ntdll.dll|unbacked", e.Callstack.Summary())
	assert.True(t, e.Callstack.ContainsUnbacked())

	// check internal state
	assert.Len(t, s.mods, 1)
	assert.Len(t, s.mods[e.PID], 3)

	// should have populated the symbols cache
	assert.Len(t, s.symbols, 1)
	assert.Equal(t, syminfo{module: "unbacked", symbol: "?"}, s.symbols[e.PID][0x2638e59e0a5])

	e3 := &event.Event{
		Type:      event.UnloadImage,
		Tid:       2484,
		PID:       uint32(os.Getpid()),
		CPU:       1,
		Seq:       2,
		Name:      "UnloadImage",
		Timestamp: time.Now(),
		Category:  event.Image,
		Params: event.Params{
			params.ImageBase: {Name: params.ImageBase, Type: params.Address, Value: uint64(0x7ffb5d8e11c4)},
			params.FilePath:  {Name: params.FilePath, Type: params.UnicodeString, Value: `C:\Windows\System32\user32.dll`},
		},
		PS: proc,
	}

	// dll is unloaded, the number of modules should decrement
	_, err = s.ProcessEvent(e3)
	require.NoError(t, err)
	assert.Len(t, s.mods[e.PID], 2)
}

func TestProcessCallstack(t *testing.T) {
	r := new(MockResolver)
	c := &config.Config{}

	psnap := new(ps.SnapshotterMock)

	opts := uint32(sys.SymUndname | sys.SymCaseInsensitive | sys.SymAutoPublics | sys.SymOmapFindNearest | sys.SymDeferredLoads)
	r.On("Initialize", mock.Anything, opts).Return(nil)
	r.On("LoadModule", windows.CurrentProcess(), mock.Anything).Return(nil)

	r.On("GetModuleName", mock.Anything, mock.Anything).Return("C:\\WINDOWS\\System32\\KERNEL32.DLL").Once()
	r.On("GetModuleName", mock.Anything, mock.Anything).Return("C:\\WINDOWS\\System32\\KERNELBASE.dll").Once()
	r.On("GetModuleName", mock.Anything, mock.Anything).Return("C:\\WINDOWS\\System32\\ntdll.dll").Times(3)

	r.On("GetSymbolNameAndOffset", mock.Anything, mock.Anything).Return("CreateProcessW", 0x54).Once()
	r.On("GetSymbolNameAndOffset", mock.Anything, mock.Anything).Return("CreateProcessW", 0x66).Once()
	r.On("GetSymbolNameAndOffset", mock.Anything, mock.Anything).Return("NtCreateProcess", 0x3a2).Once()
	r.On("GetSymbolNameAndOffset", mock.Anything, mock.Anything).Return("NtCreateProcessEx", 0x3a2).Times(2)

	r.On("Cleanup", mock.Anything)

	s := NewSymbolizer(r, psnap, c, false)
	require.NotNil(t, s)

	proc := &pstypes.PS{
		Name:      "notepad.exe",
		PID:       23234,
		Ppid:      2434,
		Exe:       `C:\Windows\notepad.exe`,
		Cmdline:   `C:\Windows\notepad.exe`,
		SID:       "S-1-1-18",
		Cwd:       `C:\Windows\`,
		SessionID: 1,
		Threads: map[uint32]pstypes.Thread{
			3453: {Tid: 3453, StartAddress: va.Address(140729524944768), IOPrio: 2, PagePrio: 5, KstackBase: va.Address(18446677035730165760), KstackLimit: va.Address(18446677035730137088), UstackLimit: va.Address(86376448), UstackBase: va.Address(86372352)},
			3455: {Tid: 3455, StartAddress: va.Address(140729524944768), IOPrio: 3, PagePrio: 5, KstackBase: va.Address(18446677035730165760), KstackLimit: va.Address(18446677035730137088), UstackLimit: va.Address(86376448), UstackBase: va.Address(86372352)},
		},
		Envs: map[string]string{"ProgramData": "C:\\ProgramData", "COMPUTRENAME": "archrabbit"},
	}
	e := &event.Event{
		Type:      event.CreateProcess,
		Tid:       2484,
		PID:       2232,
		CPU:       1,
		Seq:       2,
		Name:      "CreatedProcess",
		Timestamp: time.Now(),
		Category:  event.Process,
		Host:      "archrabbit",
		Params: event.Params{
			params.ProcessParentID:     {Name: params.ProcessParentID, Type: params.PID, Value: (uint32(os.Getpid()))},
			params.ProcessRealParentID: {Name: params.ProcessRealParentID, Type: params.PID, Value: (uint32(os.Getpid()))},
			params.Callstack:           {Name: params.Callstack, Type: params.Slice, Value: []va.Address{0x7ffb5c1d0396, 0x7ffb5d8e61f4, 0x7ffb3138592e, 0x7ffb313853b2, 0x2638e59e0a5}},
		},
		PS: proc,
	}

	_, err := s.ProcessEvent(e)
	require.NoError(t, err)
	assert.Equal(t, 1, s.procsSize())
	assert.Equal(t, "0x7ffb5c1d0396 C:\\WINDOWS\\System32\\ntdll.dll!NtCreateProcessEx+0x3a2|0x7ffb5d8e61f4 C:\\WINDOWS\\System32\\ntdll.dll!NtCreateProcessEx+0x3a2|0x7ffb3138592e C:\\WINDOWS\\System32\\ntdll.dll!NtCreateProcess+0x3a2|0x7ffb313853b2 C:\\WINDOWS\\System32\\KERNELBASE.dll!CreateProcessW+0x66|0x2638e59e0a5 C:\\WINDOWS\\System32\\KERNEL32.DLL!CreateProcessW+0x54", e.Callstack.String())

	e1 := &event.Event{
		Type:      event.TerminateProcess,
		Tid:       2484,
		PID:       12345,
		CPU:       1,
		Seq:       3,
		Name:      "TerminateProcess",
		Timestamp: time.Now(),
		Category:  event.Process,
		Host:      "archrabbit",
		Params: event.Params{
			params.ProcessID: {Name: params.ProcessID, Type: params.PID, Value: uint32(os.Getpid())},
		},
		PS: proc,
	}
	_, err = s.ProcessEvent(e1)
	require.NoError(t, err)

	r.AssertNumberOfCalls(t, "Cleanup", 1)
	assert.Equal(t, 0, s.procsSize())
}

func TestSymbolizeEventParamAddress(t *testing.T) {
	r := new(MockResolver)
	c := &config.Config{}

	psnap := new(ps.SnapshotterMock)

	opts := uint32(sys.SymUndname | sys.SymCaseInsensitive | sys.SymAutoPublics | sys.SymOmapFindNearest | sys.SymDeferredLoads)
	r.On("Initialize", mock.Anything, opts).Return(nil)
	r.On("LoadModule", windows.CurrentProcess(), mock.Anything).Return(nil)

	r.On("GetModuleName", mock.Anything, mock.Anything).Return("C:\\WINDOWS\\System32\\KERNEL32.DLL").Once()
	r.On("GetModuleName", mock.Anything, mock.Anything).Return("C:\\WINDOWS\\System32\\KERNELBASE.dll").Once()
	r.On("GetModuleName", mock.Anything, mock.Anything).Return("C:\\WINDOWS\\System32\\ntdll.dll").Times(3)

	r.On("GetSymbolNameAndOffset", mock.Anything, mock.Anything).Return("CreateProcessW", 0x54).Times(2)
	r.On("GetSymbolNameAndOffset", mock.Anything, mock.Anything).Return("CreateProcessW", 0x66).Once()
	r.On("GetSymbolNameAndOffset", mock.Anything, mock.Anything).Return("NtCreateProcess", 0x3a2).Once()
	r.On("GetSymbolNameAndOffset", mock.Anything, mock.Anything).Return("NtCreateProcessEx", 0x3a2).Times(2)

	r.On("Cleanup", mock.Anything)

	s := NewSymbolizer(r, psnap, c, false)
	require.NotNil(t, s)

	parsePeFile = func(name string, option ...pe.Option) (*pe.PE, error) {
		exports := map[uint32]string{
			8192:  "RtlSetSearchPathMode",
			9344:  "CreateProcessW",
			20352: "LoadKeyboardLayoutW",
		}
		px := &pe.PE{
			Exports: exports,
		}
		return px, nil
	}

	proc := &pstypes.PS{
		Name:      "notepad.exe",
		PID:       23234,
		Ppid:      2434,
		Exe:       `C:\Windows\notepad.exe`,
		Cmdline:   `C:\Windows\notepad.exe`,
		SID:       "S-1-1-18",
		Cwd:       `C:\Windows\`,
		SessionID: 1,
		Threads: map[uint32]pstypes.Thread{
			3453: {Tid: 3453, StartAddress: va.Address(140729524944768), IOPrio: 2, PagePrio: 5, KstackBase: va.Address(18446677035730165760), KstackLimit: va.Address(18446677035730137088), UstackLimit: va.Address(86376448), UstackBase: va.Address(86372352)},
			3455: {Tid: 3455, StartAddress: va.Address(140729524944768), IOPrio: 3, PagePrio: 5, KstackBase: va.Address(18446677035730165760), KstackLimit: va.Address(18446677035730137088), UstackLimit: va.Address(86376448), UstackBase: va.Address(86372352)},
		},
		Envs: map[string]string{"ProgramData": "C:\\ProgramData", "COMPUTRENAME": "archrabbit"},
		Modules: []pstypes.Module{
			{Name: "C:\\Windows\\System32\\ntdll.dll", Size: 32358, Checksum: 23123343, BaseAddress: va.Address(0x7ffb313833a3), DefaultBaseAddress: va.Address(0x7ffb313833a3)},
			{Name: "C:\\Windows\\System32\\kernel32.dll", Size: 12354, Checksum: 23123343, BaseAddress: va.Address(0x7ffb5c1d0126), DefaultBaseAddress: va.Address(0x7ffb5c1d0126)},
			{Name: "C:\\Windows\\System32\\user32.dll", Size: 212354, Checksum: 33123343, BaseAddress: va.Address(0x7ffb5d8e11c4), DefaultBaseAddress: va.Address(0x7ffb5d8e11c4)},
		},
	}
	e := &event.Event{
		Type:      event.CreateThread,
		Tid:       2484,
		PID:       uint32(os.Getpid()),
		CPU:       1,
		Seq:       2,
		Name:      "CreateThread",
		Timestamp: time.Now(),
		Category:  event.Thread,
		Host:      "archrabbit",
		Params: event.Params{
			params.Callstack:    {Name: params.Callstack, Type: params.Slice, Value: []va.Address{0x7ffb5c1d0396, 0x7ffb5d8e61f4, 0x7ffb3138592e, 0x7ffb313853b2, 0x2638e59e0a5}},
			params.StartAddress: {Name: params.StartAddress, Type: params.Address, Value: uint64(0x7ffb3138592e)},
			params.ProcessID:    {Name: params.ProcessID, Type: params.PID, Value: uint32(os.Getpid())},
		},
		PS: proc,
	}

	_, err := s.ProcessEvent(e)
	require.NoError(t, err)

	assert.Equal(t, "CreateProcessW", e.GetParamAsString(params.StartAddressSymbol))
	assert.Equal(t, "C:\\Windows\\System32\\ntdll.dll", e.GetParamAsString(params.StartAddressModule))

	e1 := &event.Event{
		Type:      event.SubmitThreadpoolCallback,
		Tid:       2484,
		PID:       uint32(os.Getpid()),
		CPU:       1,
		Seq:       2,
		Name:      "SubmitThreadpoolCallback",
		Timestamp: time.Now(),
		Category:  event.Threadpool,
		Host:      "archrabbit",
		Params: event.Params{
			params.Callstack:          {Name: params.Callstack, Type: params.Slice, Value: []va.Address{0x7ffb5c1d0396}},
			params.ThreadpoolCallback: {Name: params.ThreadpoolCallback, Type: params.Address, Value: uint64(0x7ffb3138592e)},
			params.ThreadpoolContext:  {Name: params.ThreadpoolContext, Type: params.Address, Value: uint64(0)},
		},
		PS: proc,
	}

	_, err = s.ProcessEvent(e1)
	require.NoError(t, err)

	assert.Equal(t, "CreateProcessW", e1.GetParamAsString(params.ThreadpoolCallbackSymbol))
	assert.Equal(t, "C:\\Windows\\System32\\ntdll.dll", e1.GetParamAsString(params.ThreadpoolCallbackModule))
}

func init() {
	procTTL = time.Second
}

func TestProcessCallstackProcsTTL(t *testing.T) {
	log.SetLevel(log.DebugLevel)
	r := new(MockResolver)
	c := &config.Config{}

	psnap := new(ps.SnapshotterMock)

	opts := uint32(sys.SymUndname | sys.SymCaseInsensitive | sys.SymAutoPublics | sys.SymOmapFindNearest | sys.SymDeferredLoads)
	r.On("Initialize", mock.Anything, opts).Return(nil)
	r.On("LoadModule", windows.CurrentProcess(), mock.Anything).Return(nil)
	r.On("GetModuleName", mock.Anything, mock.Anything).Return("C:\\WINDOWS\\System32\\KERNEL32.DLL")
	r.On("GetSymbolNameAndOffset", mock.Anything, mock.Anything).Return("CreateProcessW", 0x54)
	r.On("Cleanup", mock.Anything)

	s := NewSymbolizer(r, psnap, c, false)
	require.NotNil(t, s)
	defer s.Close()

	n := 10
	for n > 0 {
		e := &event.Event{
			Type:      event.CreateProcess,
			Tid:       2484,
			PID:       1232,
			CPU:       1,
			Seq:       2,
			Name:      "CreatedProcess",
			Timestamp: time.Now().Add(time.Millisecond * time.Duration(n)),
			Category:  event.Process,
			Host:      "archrabbit",
			Params: event.Params{
				params.ProcessParentID:     {Name: params.ProcessParentID, Type: params.PID, Value: (uint32(os.Getpid()))},
				params.ProcessRealParentID: {Name: params.ProcessRealParentID, Type: params.PID, Value: (uint32(os.Getpid()))},
				params.Callstack:           {Name: params.Callstack, Type: params.Slice, Value: []va.Address{0x7ffb5c1d0396, 0x7ffb5d8e61f4, 0x7ffb3138592e, 0x7ffb313853b2, 0x2638e59e0a5}},
			},
		}
		_, _ = s.ProcessEvent(e)
		n--
		time.Sleep(time.Millisecond * time.Duration(rand.Intn(15)*n))
	}
	// process should be present
	assert.Equal(t, 1, s.procsSize())

	time.Sleep(time.Millisecond * 2250)

	// evicted
	r.AssertNumberOfCalls(t, "Cleanup", 1)
	assert.Equal(t, 0, s.procsSize())
}

```

`pkg/sys/dbghelp.go`:

```go
/*
 * Copyright 2021-2022 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package sys

import (
	"github.com/rabbitstack/fibratus/pkg/util/utf16"
	"golang.org/x/sys/windows"
	"unsafe"
)

const (
	// SymCaseInsensitive causes all searches for symbol names to be case-insensitive.
	SymCaseInsensitive = 0x00000001

	// SymUndname specifies the symbol option that causes public symbol names
	// to be undecorated when they are displayed, and causes searches for symbol
	// names to ignore symbol decorations.
	SymUndname = 0x00000002

	// SymDeferredLoads this symbol option is called deferred symbol loading or
	// lazy symbol loading. When it is active, symbols are not actually loaded
	// when the target modules are loaded. Instead, symbols are loaded as they
	// are needed.
	SymDeferredLoads = 0x00000004

	// SymAutoPublics causes DbgHelp to search the public symbol table in a .pdb
	// file only as a last resort. If any matches are found when searching the
	// private symbol data, the public symbols will not be searched. This improves
	// symbol search speed.
	SymAutoPublics = 0x00010000

	// SymOmapFindNearest code has been optimized and there is no symbol at
	// the expected location, this option causes the nearest symbol to be used
	// instead.
	SymOmapFindNearest

	// MaxSymName specifies the maximum length of the symbol name.
	MaxSymName = 2000
)

// SymbolInfo contains symbol information.
type SymbolInfo struct {
	SizeStruct uint32
	TypeIndex  uint32
	Reserved   [2]uint64
	Index      uint32
	Size       uint32
	ModBase    uint64
	Flags      uint32
	Value      uint64
	Addr       uint64
	Register   uint32
	Scope      uint32
	Tag        uint32
	Length     uint32
	MaxLength  uint32
	Name       [1]uint16
}

// NewSymbolInfo creates a new instance of symbol info with pertinent initializations.
func NewSymbolInfo() *SymbolInfo {
	b := make([]byte, int(unsafe.Sizeof(SymbolInfo{}))+MaxSymName*2)
	sym := (*SymbolInfo)(unsafe.Pointer(&b[0]))
	sym.SizeStruct = uint32(unsafe.Sizeof(SymbolInfo{}))
	sym.MaxLength = uint32(MaxSymName)
	return sym
}

// SymbolName returns the symbol name.
func (s *SymbolInfo) SymbolName() string {
	if s.Length == 0 {
		return ""
	}
	return utf16.Decode((*[1 << 30]uint16)(unsafe.Pointer(&s.Name))[:s.Length:s.Length])
}

// ModuleInfo contains module information.
type ModuleInfo struct {
	SizeStruct      uint32
	ImageBase       uint64
	ImageSize       uint32
	TimeDateStamp   uint32
	Checksum        uint32
	NumSymbols      uint32
	SymType         int32
	ModuleName      [32]uint16
	ImageName       [256]uint16
	LoadedImageName [256]uint16
	LoadedPdbName   [256]uint16
	CVSig           uint32
	CVData          [780]uint16
	PdbSig          uint32
	PdbSig70        windows.GUID
	PdbAge          uint32
	PdbUnmatched    uint8
	DbgUnmatched    uint8
	LineNumbers     uint8
	GlobalSymbols   uint8
	TypeInfo        uint8
	SourceIndexed   uint8
	Publics         uint8
	MachineType     uint32
	Reserved        uint32
}

// NewModuleInfo creates a new instance of module info.
func NewModuleInfo() *ModuleInfo {
	return &ModuleInfo{
		SizeStruct: uint32(unsafe.Sizeof(ModuleInfo{})),
	}
}

// Name returns the module name.
func (m *ModuleInfo) Name() string {
	n := windows.UTF16ToString(m.ImageName[:])
	if n == "" {
		n = windows.UTF16ToString(m.ModuleName[:])
	}
	if n == "" {
		n = windows.UTF16ToString(m.LoadedImageName[:])
	}
	return n
}

// GetSymModuleName retrieves the module where the symbol is imported.
func GetSymModuleName(proc windows.Handle, addr uint64) string {
	mod := NewModuleInfo()
	if !SymGetModuleInfo(proc, addr, mod) {
		return "?"
	}
	module := mod.Name()
	if module == "" {
		return "?"
	}
	return module
}

// GetSymName retrieves the symbol name and offset for the given address.
func GetSymName(proc windows.Handle, addr uint64) (string, uint64) {
	sym := NewSymbolInfo()
	var offset uint64
	if !SymFromAddr(proc, addr, &offset, sym) {
		return "?", 0
	}
	symbol := sym.SymbolName()
	if symbol == "" {
		return "?", offset
	}
	return symbol, offset
}

```

`pkg/sys/device.go`:

```go
/*
 * Copyright 2021-2022 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package sys

import (
	"fmt"
	"os"
	"strings"
	"syscall"
	"unsafe"
)

// DevSize specifies the initial size used to allocate the driver base addresses
const DevSize = 1024

// Driver contains device driver metadata for each driver found in
// the system.
type Driver struct {
	Filename string
	Addr     uintptr
}

// String returns the driver string representation.
func (d Driver) String() string {
	return fmt.Sprintf("File: %s", d.Filename)
}

// EnumDevices returns metadata about device drivers encountered in the
// system. If device driver enumeration fails, an empty slice with device
// information is returned.
func EnumDevices() []Driver {
	needed := uint32(0)
	addrs := make([]uintptr, DevSize)
	err := EnumDeviceDrivers(uintptr(unsafe.Pointer(&addrs[0])), DevSize, &needed)
	if err != nil {
		return nil
	}
	// base image size greater than initial allocation
	if needed > uint32(len(addrs)) {
		addrs = make([]uintptr, needed)
		err := EnumDeviceDrivers(uintptr(unsafe.Pointer(&addrs[0])), needed, &needed)
		if err != nil {
			return nil
		}
	}
	// resize to get the number of drivers
	if needed/8 < uint32(len(addrs)) {
		addrs = addrs[:needed/8]
	}
	drivers := make([]Driver, len(addrs))
	for i, addr := range addrs {
		drv := Driver{
			Addr: addr,
		}
		filename := make([]uint16, syscall.MAX_PATH)
		n := GetDeviceDriverFileName(addr, &filename[0], syscall.MAX_PATH)
		if n == 0 {
			continue
		}
		dev := syscall.UTF16ToString(filename)
		drv.Filename = strings.Replace(dev, "\\SystemRoot", os.Getenv("SYSTEMROOT"), 1)
		drivers[i] = drv
	}
	return drivers
}

```

`pkg/sys/device_test.go`:

```go
/*
 * Copyright 2021-2022 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package sys

import (
	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/require"
	"path/filepath"
	"strings"
	"testing"
)

func TestEnumDevices(t *testing.T) {
	drivers := EnumDevices()
	require.True(t, len(drivers) > 0)

	ntoskrnlFound := false
	for _, drv := range drivers {
		if strings.EqualFold(filepath.Base(drv.Filename), "ntoskrnl.exe") {
			ntoskrnlFound = true
			break
		}
	}
	assert.True(t, ntoskrnlFound)
}

```

`pkg/sys/doc.go`:

```go
/*
 * Copyright 2019-2020 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

// Package sys contains the definitions of functions, structures and constants for interacting with the Windows API.
package sys

```

`pkg/sys/etw/etw.go`:

```go
//go:build windows
// +build windows

/*
 * Copyright 2019-2020 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package etw

import (
	"github.com/rabbitstack/fibratus/pkg/errors"
	"golang.org/x/sys/windows"
	"os"
	"unsafe"
)

//go:generate go run golang.org/x/sys/windows/mkwinsyscall -output zsyscall_windows.go etw.go

//sys startTrace(handle *TraceHandle, name string, props *EventTraceProperties) (err error) [failretval!=0] = advapi32.StartTraceW
//sys controlTrace(handle TraceHandle, name string, props *EventTraceProperties, operation TraceOperation) (err error) [failretval!=0] = advapi32.ControlTraceW
//sys closeTrace(handle TraceHandle) (err error) = advapi32.CloseTrace
//sys openTrace(logfile *EventTraceLogfile) (handle TraceHandle) = advapi32.OpenTraceW
//sys processTrace(handle *TraceHandle, count uint32, start *windows.Filetime, end *windows.Filetime) (err error) [failretval!=0] = advapi32.ProcessTrace
//sys traceSetInformation(handle TraceHandle, infoClass uint8, info uintptr, length uint32) (err error) [failretval!=0] = advapi32.TraceSetInformation
//sys traceQueryInformation(handle TraceHandle, infoClass uint8, info uintptr, length uint32, size *uint32) (err error) [failretval!=0] = advapi32.TraceQueryInformation
//sys enableTraceEx2(handle TraceHandle, providerID *windows.GUID, controlCode uint32, level uint8, matchAnyKeyword uint64, matchAllKeyword uint64, timeout uint32, enableParameters *EnableTraceParameters) (err error) [failretval!=0] = advapi32.EnableTraceEx2

// EnableTraceParametersVersion determines the version of the EnableTraceParameters structure.
const EnableTraceParametersVersion = 2

// EnableTraceParameters contains information used to enable a provider via EnableTraceEx2.
type EnableTraceParameters struct {
	// Version represents the version of this struct. Should be set to EnableTraceParametersVersion.
	Version uint32
	// EnableProperty represents optional settings that ETW can include
	// when writing the event. Some settings write extra data to the extended
	// data item section of each event. Other settings control which events
	// will be included in the trace.
	EnableProperty uint32
	// ControlFlags is a reserved field and should be set to 0.
	ControlFlags uint32
	// SourceID denotes a GUID that uniquely identifies the caller that
	// is enabling or disabling the provider.
	SourceID windows.GUID
	// EnableFilterDesc is a  pointer to an array of event filter descriptor structures
	// that points to the filter data. The number of elements in the array is specified
	// in the FilterDescCount member.
	EnableFilterDesc uintptr
	// FilterDescCount is the number of elements (filters) in the event filter descriptor
	// array.
	FilterDescCount uint32
}

// TraceOperation is the type alias for the trace operation.
type TraceOperation uint32

const (
	// Query represents the query trace operation.
	Query TraceOperation = 0
	// Stop represents the stop trace operation.
	Stop TraceOperation = 1
	// Update represents the update trace operation.
	Update TraceOperation = 2
	// Flush represents the flush trace operation.
	Flush TraceOperation = 3
)

// TraceHandle is an alias for trace handle type
type TraceHandle uintptr

// IsValid determines if the trace handle is valid
func (trace TraceHandle) IsValid() bool { return trace != 0 && trace != 0xffffffffffffffff }

// StartTrace registers and starts an event tracing session for the specified provider. The trace assumes there will
// be a real-time event consumer responsible for collecting and processing events. If the function succeeds, it returns
// the handle to the tracing session.
func StartTrace(name string, props EventTraceProperties) (TraceHandle, error) {
	var handle TraceHandle
	err := startTrace(&handle, name, &props)
	if err == nil {
		return handle, nil
	}
	switch err.(windows.Errno) {
	case windows.ERROR_ACCESS_DENIED:
		return TraceHandle(0), errors.ErrTraceAccessDenied
	case windows.ERROR_DISK_FULL:
		return TraceHandle(0), errors.ErrTraceDiskFull
	case windows.ERROR_ALREADY_EXISTS:
		return TraceHandle(0), errors.ErrTraceAlreadyRunning
	case windows.ERROR_INVALID_PARAMETER:
		return TraceHandle(0), errors.ErrTraceInvalidParameter
	case windows.ERROR_BAD_LENGTH:
		return TraceHandle(0), errors.ErrTraceBadLength
	case windows.ERROR_NO_SYSTEM_RESOURCES:
		return TraceHandle(0), errors.ErrTraceNoSysResources
	default:
		return TraceHandle(0), os.NewSyscallError("StartTrace", err)
	}
}

// ControlTrace performs various operation on the specified event tracing session, such as updating, flushing or stopping
// the session.
func ControlTrace(handle TraceHandle, name string, guid windows.GUID, operation TraceOperation) error {
	props := &EventTraceProperties{
		Wnode: WnodeHeader{
			BufferSize: uint32(unsafe.Sizeof(EventTraceProperties{})) + uint32(2*len(name)),
			GUID:       guid,
		},
	}
	err := controlTrace(handle, name, props, operation)
	if err != nil && err != windows.ERROR_MORE_DATA {
		return os.NewSyscallError("ControlTrace", err)
	}
	return nil
}

// StopTrace stops the provided trace.
func StopTrace(name string, guid windows.GUID) error {
	return ControlTrace(TraceHandle(0), name, guid, Stop)
}

// FlushTrace flushes the buffers of the provided trace.
func FlushTrace(name string, guid windows.GUID) error {
	return ControlTrace(TraceHandle(0), name, guid, Flush)
}

// CloseTrace closes a trace. If you call this function before ProcessTrace returns, the CloseTrace function
// returns ErrorCtxClosePending. The ErrorCtxClosePending code indicates that the CloseTrace function call
// was successful; the ProcessTrace function will stop processing events after it processes all events in its buffers.
func CloseTrace(handle TraceHandle) error {
	err := closeTrace(handle)
	if err == nil {
		return nil
	}
	errno := err.(windows.Errno)
	if errno != windows.ERROR_SUCCESS && errno != windows.ERROR_CTX_CLOSE_PENDING {
		return os.NewSyscallError("CloseTrace", err)
	}
	return nil
}

// OpenTrace opens a real-time trace session or log file for consuming.
func OpenTrace(logfile EventTraceLogfile) TraceHandle {
	return openTrace(&logfile)
}

// ProcessTrace function delivers events from one or more event tracing sessions to the consumer. Function sorts the events
// chronologically and delivers all events generated between StartTime and EndTime. The ProcessTrace function blocks the
// thread until it delivers all events, the BufferCallback function returns false, or you call CloseTrace.
func ProcessTrace(handle TraceHandle) error {
	err := processTrace(&handle, 1, nil, nil)
	if err == nil {
		return nil
	}
	switch err.(windows.Errno) {
	case windows.ERROR_WMI_INSTANCE_NOT_FOUND:
		return errors.ErrSessionNotRunning
	case windows.ERROR_NOACCESS:
		return errors.ErrEventCallbackException
	case windows.ERROR_CANCELLED:
		return errors.ErrTraceCancelled
	default:
		return os.NewSyscallError("ProcessTrace", err)
	}
}

// SetTraceSystemFlags enables or disables event tracing session system flags.
func SetTraceSystemFlags(handle TraceHandle, flags []EventTraceFlags) error {
	err := traceSetInformation(handle, TraceSystemTraceEnableFlagsInfo, uintptr(unsafe.Pointer(&flags[0])), uint32(4*len(flags)))
	if err != nil {
		return os.NewSyscallError("TraceSetInformation", err)
	}
	return nil
}

// GetTraceSystemFlags returns enabled event tracing session system flags.
func GetTraceSystemFlags(handle TraceHandle) ([]EventTraceFlags, error) {
	flags := make([]EventTraceFlags, 8)
	err := traceQueryInformation(handle, TraceSystemTraceEnableFlagsInfo, uintptr(unsafe.Pointer(&flags[0])), uint32(4*len(flags)), nil)
	if err != nil {
		return nil, os.NewSyscallError("TraceQueryInformation", err)
	}
	return flags, nil
}

// EventEnablePropertyStacktrace adds a call stack trace to the extended data of events.
// If the stack is longer than the maximum number of frames (192), the frames will be cut
// from the bottom of the stack.
const EventEnablePropertyStacktrace = 0x00000004

const (
	// TraceLevelInformation is the value that indicates the maximum
	// level of events that the provider is susceptible to write.
	TraceLevelInformation = 4
	// ControlCodeEnableProvider updates the session configuration so
	// that the session receives the requested events from the provider.
	ControlCodeEnableProvider = 1
	// ControlCodeCaptureState requests that the provider log its state
	// information, such as rundown events
	ControlCodeCaptureState = 2
)

// EnableTrace influences the behaviour of the specified event trace provider.
func EnableTrace(guid windows.GUID, handle TraceHandle, keywords uint64) error {
	err := enableTraceEx2(handle, &guid, ControlCodeEnableProvider, TraceLevelInformation, keywords, 0, 0, nil)
	if err != nil {
		return os.NewSyscallError("EnableTraceEx2", err)
	}
	return nil
}

// CaptureProviderState requests that the provider log its state information.
func CaptureProviderState(guid windows.GUID, handle TraceHandle) error {
	err := enableTraceEx2(handle, &guid, ControlCodeCaptureState, 0, 0, 0, 0, nil)
	if err != nil {
		return os.NewSyscallError("EnableTraceEx2", err)
	}
	return nil
}

// EnableTraceOpts describes which properties are enabled in the event extended section.
type EnableTraceOpts struct {
	// WithStacktrace indicates call stack trace is added to the extended data of events.
	WithStacktrace bool
	// EventFilterDescriptors defines the filter data that a session passes to the provider's
	// enable callback function.
	EventFilterDescriptors []EventFilterDescriptor
}

// EnableTraceWithOpts influences the behaviour of the specified event trace provider
// by providing extra options to configure how events are writing to the session buffer.
func EnableTraceWithOpts(guid windows.GUID, handle TraceHandle, keywords uint64, opts EnableTraceOpts) error {
	params := &EnableTraceParameters{
		Version:  EnableTraceParametersVersion,
		SourceID: guid,
	}

	if opts.WithStacktrace {
		params.EnableProperty = EventEnablePropertyStacktrace
	}

	if len(opts.EventFilterDescriptors) > 0 {
		params.EnableFilterDesc = uintptr(unsafe.Pointer(&opts.EventFilterDescriptors[0]))
		params.FilterDescCount = uint32(len(opts.EventFilterDescriptors))
	}

	err := enableTraceEx2(handle, &guid, ControlCodeEnableProvider, TraceLevelInformation, keywords, 0, 0, params)
	if err != nil {
		return os.NewSyscallError("EnableTraceEx2", err)
	}
	return nil
}

// EnableStackTracing enables stack tracing for the provided events.
func EnableStackTracing(handle TraceHandle, eventIDs []ClassicEventID) error {
	err := traceSetInformation(handle, TraceStackTracingInfo, uintptr(unsafe.Pointer(&eventIDs[0])), uint32(unsafe.Sizeof(ClassicEventID{})*uintptr(len(eventIDs))))
	if err != nil {
		return os.NewSyscallError("TraceSetInformation", err)
	}
	return nil
}

```

`pkg/sys/etw/types.go`:

```go
//go:build windows
// +build windows

/*
 * Copyright 2019-2020 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package etw

import (
	"github.com/rabbitstack/fibratus/pkg/util/utf16"
	"github.com/rabbitstack/fibratus/pkg/util/va"
	"golang.org/x/sys/windows"
	"strings"
	"unsafe"
)

// EventTraceFlags is the type alias for kernel trace events
type EventTraceFlags uint32

// KernelTraceControlGUID is the GUID for the kernel system logger
var KernelTraceControlGUID = windows.GUID{Data1: 0x9e814aad, Data2: 0x3204, Data3: 0x11d2, Data4: [8]byte{0x9a, 0x82, 0x00, 0x60, 0x08, 0xa8, 0x69, 0x39}}

// KernelAuditAPICallsGUID represents the GUID for the kernel audit API provider
var KernelAuditAPICallsGUID = windows.GUID{Data1: 0xe02a841c, Data2: 0x75a3, Data3: 0x4fa7, Data4: [8]byte{0xaf, 0xc8, 0xae, 0x09, 0xcf, 0x9b, 0x7f, 0x23}}

// DNSClientGUID represents the GUID for the Windows DNS Client provider
var DNSClientGUID = windows.GUID{Data1: 0x1c95126e, Data2: 0x7eea, Data3: 0x49a9, Data4: [8]byte{0xa3, 0xfe, 0xa3, 0x78, 0xb0, 0x3d, 0xdb, 0x4d}}

// ThreadpoolGUID represents the GUID for the thread pool provider
var ThreadpoolGUID = windows.GUID{Data1: 0xc861d0e2, Data2: 0xa2c1, Data3: 0x4d36, Data4: [8]byte{0x9f, 0x9c, 0x97, 0x0b, 0xab, 0x94, 0x3a, 0x12}}

// WindowsKernelProcessGUID represents the GUID for the Microsoft Windows Kernel Process provider
var WindowsKernelProcessGUID = windows.GUID{Data1: 0x22fb2cd6, Data2: 0x0e7b, Data3: 0x422b, Data4: [8]byte{0xa0, 0xc7, 0x2f, 0xad, 0x1f, 0xd0, 0xe7, 0x16}}

// WindowsKernelRegistryGUID represents the GUID for the Microsoft Windows Kernel Registry provider
var WindowsKernelRegistryGUID = windows.GUID{Data1: 0x70eb4f03, Data2: 0xc1de, Data3: 0x4f73, Data4: [8]byte{0xa0, 0x51, 0x33, 0xd1, 0x3d, 0x54, 0x13, 0xbd}}

const (
	// TraceStackTracingInfo controls call stack tracing for kernel events
	TraceStackTracingInfo = uint8(3)
	// TraceSystemTraceEnableFlagsInfo controls system logger event flags
	TraceSystemTraceEnableFlagsInfo = uint8(4)
)

// ProcessKeyword enables process events for Microsoft Windows Kernel Process provider
const ProcessKeyword = 0x10

// ImageKeyword enables images events for Microsoft Windows Kernel Process provider
const ImageKeyword = 0x40

// SetValueKeyword enables registry key value set events for Microsoft Windows Kernel Registry provider
const SetValueKeyword = 0x100

const (
	// EventHeaderExtTypeStackTrace64 indicates that the extended data contains the call stack if the event is captured on a 64-bit host
	EventHeaderExtTypeStackTrace64 uint16 = 0x0006
)

const (
	// KernelLoggerSession represents the default session name for NT kernel logger
	KernelLoggerSession = "NT Kernel Logger"
	// SecurityTelemetrySession represents the session name for all security telemetry
	SecurityTelemetrySession = "Security Telemetry Logger"

	// WnodeTraceFlagGUID indicates that the structure contains event tracing information
	WnodeTraceFlagGUID = 0x00020000
	// ProcessTraceModeRealtime denotes that there will be a real-time consumers for events forwarded from the providers
	ProcessTraceModeRealtime = 0x00000100
	// ProcessTraceModeEventRecord is the mode that enables the "event record" format for kernel events
	ProcessTraceModeEventRecord = 0x10000000
)

const (
	// ALPC flag activates ALPC events
	ALPC EventTraceFlags = 0x00100000
	// Cswitch flag enables context switch events
	Cswitch EventTraceFlags = 0x00000010
	// DbgPrint flag enables stack walk information
	DbgPrint EventTraceFlags = 0x00040000
	// DiskFileIO flag enables file system events
	DiskFileIO EventTraceFlags = 0x00000200
	// DiskIO flag enables disk I/O events
	DiskIO EventTraceFlags = 0x00000100
	// DiskIOInit flag enables start/end disk I/O events
	DiskIOInit EventTraceFlags = 0x00000400
	// Dispatcher flag activates dispatcher events
	Dispatcher EventTraceFlags = 0x00000800
	// DPC flag enables Deferred Procedure Call events
	DPC EventTraceFlags = 0x00000020
	// Driver flag enables driver events
	Driver EventTraceFlags = 0x00800000
	// FileIO enables file I/O events.
	FileIO EventTraceFlags = 0x02000000
	// FileIOInit flag enables file start/end events.
	FileIOInit EventTraceFlags = 0x04000000
	// ImageLoad flag enables image events.
	ImageLoad EventTraceFlags = 0x00000004
	// Handle flag enables handle events.
	Handle EventTraceFlags = 0x80000040
	// IRQ flag enables IRQ events.
	IRQ EventTraceFlags = 0x00000040
	// Job flag enables job events.
	Job EventTraceFlags = 0x00080000
	// NetTCPIP flag enables network events.
	NetTCPIP EventTraceFlags = 0x00010000
	// Process flag enables process events.
	Process EventTraceFlags = 0x00000001
	// Registry flag enable registry events.
	Registry EventTraceFlags = 0x00020000
	// Syscall flag enables syscall enter/exit events.
	Syscall EventTraceFlags = 0x00000080
	// Thread flag enables thread events.
	Thread EventTraceFlags = 0x00000002
	// VaMap enables map and unmap file events.
	VaMap EventTraceFlags = 0x00008000
	// VirtualAlloc enables virtual memory allocation and free events.
	VirtualAlloc EventTraceFlags = 0x00004000
)

// String returns the string representation of enabled event trace flags.
func (f EventTraceFlags) String() string {
	flags := make([]string, 0)
	if f&ALPC == ALPC {
		flags = append(flags, "ALPC")
	}
	if f&Cswitch == Cswitch {
		flags = append(flags, "Cswitch")
	}
	if f&DiskFileIO == DiskFileIO {
		flags = append(flags, "DiskFileIO")
	}
	if f&DiskIO == DiskIO {
		flags = append(flags, "DiskIO")
	}
	if f&FileIO == FileIO {
		flags = append(flags, "FileIO")
	}
	if f&ImageLoad == ImageLoad {
		flags = append(flags, "DLL")
	}
	if f&Handle == Handle {
		flags = append(flags, "Handle")
	}
	if f&NetTCPIP == NetTCPIP {
		flags = append(flags, "TCPIP")
	}
	if f&Process == Process {
		flags = append(flags, "Process")
	}
	if f&Registry == Registry {
		flags = append(flags, "Registry")
	}
	if f&Thread == Thread {
		flags = append(flags, "Thread")
	}
	if f&VaMap == VaMap {
		flags = append(flags, "VaMap")
	}
	if f&VirtualAlloc == VirtualAlloc {
		flags = append(flags, "VirtualAlloc")
	}
	return strings.Join(flags, ", ")
}

// WnodeHeader is a member of `EventTraceProperties` structure. The majority of the fields in this structure are not relevant to us.
type WnodeHeader struct {
	// BufferSize is the total size of memory allocated, in bytes, for the event tracing session properties.
	BufferSize uint32
	// ProviderID is reserved for internal use.
	ProviderID uint32
	// HostricalContext is union field with the following C representation:
	// union {
	//	ULONG64 HistoricalContext;
	//	struct {
	//	  ULONG Version;
	//	  ULONG Linkage;
	//	};
	// };
	// On output, HistoricalContext stores the handle to the event tracing session. Version and Linkage fields are reserved for internal use.
	HistoricalContext [8]byte
	// KernelHandle is union with the following C representation:
	// union {
	//	HANDLE        KernelHandle;
	//	LARGE_INTEGER TimeStamp;
	//  };
	// `KernelHandle` is reserved for internal use. `TimeStamp` designates the instant at which the information of this
	// structure was updated.
	KernelHandle [8]byte
	// GUID that defines the session. For NT Kernel Logger session we have to set this member to `SystemTraceControlGuid`.
	GUID windows.GUID
	// ClientContext represents clock resolution to use when logging the time stamp for each event. The default is Query performance counter (QPC).
	ClientContext uint32
	// Flags must contain `WnodeFlagTracedGUID` to indicate that the structure contains event tracing information.
	Flags uint32
}

// EventTraceProperties contains information about an event tracing session. Each time a new session is created, or an existing session
// is about to be modified, this structure is used to describe session properties.
type EventTraceProperties struct {
	// Wnode structure requires `BufferSize`, `Flags` and `GUID` members to be initialized.
	Wnode WnodeHeader
	// BufferSize represents the amount of memory allocated for each event tracing session buffer, in kilobytes.
	// The maximum buffer size is 1 MB. ETW uses the size of physical memory to calculate this value.
	// If an application expects a relatively low event rate, the buffer size should be set to the memory page size.
	// To get the page memory size, you can invoke GetSystemInfo() function.
	// If the event rate is expected to be relatively high, the application should specify a larger buffer size,
	// and should increase the maximum number of buffers.
	//
	// The buffer size affects the rate at which buffers fill and must be flushed. Although a small buffer size requires
	// less memory, it increases the rate at which buffers must be flushed.
	BufferSize uint32
	// MinimumBuffers specifies the minimum number of buffers allocated for the event tracing session's buffer pool.
	// The minimum number of buffers that you can specify is two buffers per processor. For example, on a single processor machine,
	// the minimum number of buffers is two.
	MinimumBuffers uint32
	// MaximumBuffers is the maximum number of buffers allocated for the event tracing session's buffer pool. Typically, this value is
	// the minimum number of buffers plus twenty. ETW uses the buffer size and the size of physical memory to calculate this value.
	MaximumBuffers uint32
	// MaximumFileSize is the maximum size of the file used to log events, in megabytes.
	MaximumFileSize uint32
	// LogFileMode determines the logging modes for the event tracing session. You use this member to specify that you want events written to a
	// log file, a real-time consumer, or both. In real-time logging mode, if no consumers are available, events will be written
	// to disk, and when consumers begin processing real-time events, the events in the playback file are consumed first.
	LogFileMode uint32
	// FlushTimer specifies how often, in seconds, the trace buffers are forcibly flushed. The minimum flush time is 1 second.
	// This forced flush is in addition to the automatic flush that occurs whenever a buffer is full and when the trace session
	// stops. If zero, ETW flushes buffers as soon as they become full. If nonzero, ETW flushes all buffers that contain events
	// based on the timer value. Typically, you want to flush buffers only when they become full. Forcing the buffers to flush
	// (either by setting this member to a nonzero value or by calling `FlushTrace`) can increase the file size of the log file
	// with unfilled buffer space.
	//
	// If the consumer is consuming events in real time, you may want to set this member to a nonzero value if the event rate is
	// low to force events to be delivered before the buffer is full.
	// For the case of a realtime logger, a value of zero (the default value) means that the flush time will be set to 1 second.
	// A realtime logger is when LogFileMode is set to `EventTraceRealTimeMode`.
	FlushTimer uint32
	// EnableFlags specifies which kernel events are delivered to the consumer when NT Kernel logger session is started.
	// For example, registry events, process, disk IO and so on.
	EnableFlags EventTraceFlags
	// AgeLimit is not used.
	AgeLimit int32
	// NumberOfBuffers indicates the number of buffers allocated for the event tracing session's buffer pool.
	NumberOfBuffers uint32
	// FreeBuffers indicates the number of buffers that are allocated but unused in the event tracing session's buffer pool.
	FreeBuffers uint32
	// EventsLost counts the number of events that were not recorded.
	EventsLost uint32
	// BuffersWritten counts the number of buffers written.
	BuffersWritten uint32
	// LogBuffersLost determines the number of buffers that could not be written to the log file.
	LogBuffersLost uint32
	// RealTimeBuffersLost represents the number of buffers that could not be delivered in real-time to the consumer.
	RealTimeBuffersLost uint32
	// LoggerThreadID is the thread identifier for the event tracing session.
	LoggerThreadID uintptr
	// LogFileNameOffset is the offset from the start of the structure's allocated memory to beginning of the null-terminated
	// string that contains the log file name.
	LogFileNameOffset uint32
	// LoggerNameOffset is the offset from the start of the structure's allocated memory to beginning of the null-terminated
	// string that contains the session name. The session name is limited to 1024 characters. The session name is case-insensitive
	// and must be unique.
	LoggerNameOffset uint32
}

// EventTraceHeader contains standard event tracing information common to all events.
type EventTraceHeader struct {
	// Size represents the total number of bytes of the event. It includes the size of the header structure,
	// plus the size of any event-specific data appended to the header.
	Size uint16
	// FieldTypeFlags is union field represented as follows:
	//  union {
	//	USHORT FieldTypeFlags;
	//	struct {
	//	  UCHAR HeaderType;
	//	  UCHAR MarkerFlags;
	//	};
	// };
	// All memebers of this union are reserved for internal use.
	FieldTypeFlags [2]byte
	// Versions in union field with the following declaration:
	// union {
	//	ULONG  Version;
	//	struct {
	//	  UCHAR  Type;
	//	  UCHAR  Level;
	//	  USHORT Version;
	//	} Class;
	//  };
	// `Type` field indicates the general purpose type of this event (e.g. data collection end/start, checkpoint, etc.)
	// `Level` designates the severity of the generated event and the `Version` tells the consumer which MOF class to use to
	// decipher the event data.
	Version [4]byte
	// ThreadID identifies the thread that generated this event.
	ThreadID uint32
	// ProcessID identifies the process that generated this event.
	ProcessID uint32
	// Timestamp contains the time that the event occurred.
	Timestamp uint64
	// GUID is union:
	// union {
	//	GUID      Guid;
	//	ULONGLONG GuidPtr;
	// };
	// `Guid` identifies a category of events. `GuidPtr` is the pointer to an event trace class GUID.
	GUID [16]byte
	// ProcessorTime is another union type:
	// union {
	//	struct {
	//		ULONG ClientContext;
	//		ULONG Flags;
	//	  };
	//	  struct {
	//		ULONG KernelTime;
	//		ULONG UserTime;
	//	  };
	//	  ULONG64 ProcessorTime;
	// };
	// `ClientContext` is reserved, while `Flags` must be set to `WnodeFlagTracedGuid`. The rest of the members
	// specify elapsed execution time for kernel and user mode instructions respectively.
	ProcessorTime [8]byte
}

// EventTrace stores event information that is delivered to an event trace consumer.
type EventTrace struct {
	// Header contains standard event tracing metadata.
	Header EventTraceHeader
	// InstanceID represents the instance identifier.
	InstanceID uint32
	// ParentInstanceID represents instance identifier for a parent event.
	ParentInstanceID uint32
	// ParentGUID is the class GUID of the parent event.
	ParentGUID windows.GUID
	// MofData is the pointer to the beginning of the event-specific data for this event.
	MofData uintptr
	// MofLength represents the number of bytes to which `MofData` points.
	MofLength uint32
	// Context is union type:
	// union {
	//	ULONG              ClientContext;
	//	ETW_BUFFER_CONTEXT BufferContext;
	// };
	// `ClientContext` field is reserved. `BufferContext` Provides information about the event such as the session identifier
	// and processor number of the CPU on which the provider process ran.
	Context [2]byte
}

// TraceLogfileHeader contains information about an event tracing session and its events.
type TraceLogfileHeader struct {
	// BufferSize is the size of the event tracing session's buffers in bytes.
	BufferSize uint32
	// Version is the union type that represents version number of the operating system.
	Version [4]byte
	// ProviderVersion is the build number of the operating system.
	ProviderVersion uint32
	// NumberOfProcessors indicates the number of processors on the system.
	NumberOfProcessors uint32
	// EndTime is the time at which the event tracing session stopped. This value is 0 for real time event consumers.
	EndTime uint64
	// TimerResolution is the resolution of the hardware timer, in units of 100 nanoseconds.
	TimerResolution uint32
	// MaximumFileSize is the size of the log file, in megabytes.
	MaximumFileSize uint32
	// LogfileMode represents the current logging mode for the event tracing session.
	LogfileMode uint32
	// BuffersWritten is the total number of buffers written by the event tracing session.
	BuffersWritten uint32
	// GUID is union type with the two first field reserved for internal usage. Other fields indicate
	// the number of events lost and the CPU speed in Mhz.
	GUID [16]byte
	// LoggerName is a reserved field.
	LoggerName *uint16
	// LogfileName is a reserved field.
	LogfileName *uint16
	// TimeZone contains time-zone information for `BootTime`, `EndTime` and `StartTime` fields.
	TimeZone windows.Timezoneinformation
	// BootTime is the time at which the system was started, in 100-nanosecond intervals since midnight, January 1, 1601.
	BootTime uint64
	// PerfFreq is the frequency of the high-resolution performance counter, if one exists.
	PerfFreq uint64
	// StartTime is the time at which the event tracing session started, in 100-nanosecond intervals since midnight, January 1, 1601.
	StartTime uint64
	// ReservedFlags specifies the clock type.
	ReservedFlags uint32
	// BuffersLost is the total number of buffers lost during the event tracing session.
	BuffersLost uint32
}

// EventTraceLogfile specifies how the consumer wants to read events (from a log file or in real-time) and the callbacks
// that will receive the events.When ETW flushes a buffer, this structure contains information about the event tracing
// session and the buffer that ETW flushed.
type EventTraceLogfile struct {
	// LogFileName is the name of the log file used by the event tracing session.
	LogFileName *uint16
	// LoggerName is the name of the event tracing session. Only applicable when consuming events in real time.
	LoggerName *uint16
	// CurrentTime on output, the current time, in 100-nanosecond intervals since midnight, January 1, 1601.
	CurrentTime int64
	// BuffersRead represents the number of buffers processed.
	BuffersRead uint32
	// LogFileMode is union type the dictates the processing mode for events.
	LogFileMode [4]byte
	// CurrentEvents contains the last event processed.
	CurrentEvent EventTrace
	// LogfileHeader represents global information about the tracing session.
	LogfileHeader TraceLogfileHeader
	// BufferCallback is a pointer to the function that receives buffer-related statistics for each buffer ETW flushes.
	// ETW calls this callback after it delivers all the events in the buffer.
	BufferCallback uintptr
	// BufferSize contains the size of each buffer, in bytes.
	BufferSize uint32
	// Filled contains the number of bytes in the buffer that contain valid information.
	Filled uint32
	// EventsLost is an unused field.
	EventsLost uint32
	// EventCallback is the union field that contains pointers to callback functions that ETW calls for each buffer.
	EventCallback [8]byte
	// IsKernelTrace specifies whether the event tracing session is the NT kernel logger.
	IsKernelTrace uint32
	// Context is data that a consumer can specify when calling `OpenTrace` function.
	Context uintptr
}

// NewEventTraceLogfile creates a new event trace logfile structure.
func NewEventTraceLogfile(loggerName string) EventTraceLogfile {
	return EventTraceLogfile{
		LoggerName: windows.StringToUTF16Ptr(loggerName),
	}
}

// SetModes sets the event processing modes.
func (e *EventTraceLogfile) SetModes(modes int) {
	*(*uint32)(unsafe.Pointer(&e.LogFileMode[0])) = uint32(modes)
}

// SetEventCallback sets the event processing callback.
func (e *EventTraceLogfile) SetEventCallback(fn uintptr) {
	*(*uintptr)(unsafe.Pointer(&e.EventCallback[4])) = fn
}

// SetBufferCallback sets the session buffer reporting callback.
func (e *EventTraceLogfile) SetBufferCallback(fn uintptr) {
	e.BufferCallback = fn
}

// EventDescriptor contains metadata that defines the event.
type EventDescriptor struct {
	// ID represents event identifier.
	ID uint16
	// Version indicates a revision to the event definition.
	Version uint8
	// Channel is the audience for the event (e.g. administrator or developer).
	Channel uint8
	// Level is the severity or level of detail included in the event.
	Level uint8
	// Opcode is step in a sequence of operations being performed within the `Task` field. For MOF-defined events,
	// the `Opcode` member contains the event type value.
	Opcode uint8
	// Task represents a larger unit of work within an application or component.
	Task uint16
	// Keyword A bitmask that specifies a logical group of related events. Each bit corresponds to one group. An event may belong to one or more groups.
	// The keyword can contain one or more provider-defined keywords, standard keywords, or both.
	Keyword uint64
}

// EventHeader defines information about the event.
type EventHeader struct {
	// Size represents the size of the event, in bytes.
	Size uint16
	// HeaderType is reserved.
	HeaderType uint16
	// Flags provides information about the event such as the type of session it was logged to and if
	// the event contains extended data.
	Flags uint16
	// EventProperty indicates the source to use for parsing the event data.
	EventProperty uint16
	// ThreadID identifies the thread that generated the event.
	ThreadID uint32
	// ProcessID identifies the process that generated the event.
	ProcessID uint32
	// Timestamps contains the time that the event occurred.
	Timestamp uint64
	// ProviderID is the GUID that uniquely identifies the provider that logged the event.
	ProviderID windows.GUID
	// EventDescriptor defines the information about the event such as the event identifier and severity level.
	EventDescriptor EventDescriptor
	// ProcessorTime is the union type that defines elapsed execution time for kernel-mode and user-mode instructions
	// in CPU units.
	ProcessorTime [8]byte
	// ActivityID is the identifier that relates two events.
	ActivityID windows.GUID
}

// BufferContext provides context information about the event.
type BufferContext struct {
	// ProcessorIndex is union type that contains among other fields the number of the CPU on which
	// the provider process was running.
	ProcessorIndex [2]byte
	// LoggerID identifies of the session that logged the event.
	LoggerID uint16
}

// Linkage is the inner struct for EventHeaderExtendedDataItem.
type Linkage struct {
	Linkage uint16
}

// EventHeaderExtendedDataItem defines the extended data that ETW collects as part of the event data.
type EventHeaderExtendedDataItem struct {
	// Reserved1 is a reserved field.
	Reserved1 uint16
	// ExtType defines the type of extended data.
	ExtType uint16
	// Linkage is a reserved field.
	Linkage Linkage
	// DataSize is the size in bytes, of the extended data
	DataSize uint16
	// DataPtr is the pointer to extended data.
	DataPtr uint64
}

// EventRecord defines the layout of an event that ETW delivers.
type EventRecord struct {
	// Header represents information about the event such as the time stamp for when it was written.
	Header EventHeader
	// BufferContext defines information such as the session that logged the event.
	BufferContext BufferContext
	// ExtendedDataCount is the number of extended data structures in the `ExtendedData` field.
	ExtendedDataCount uint16
	// BufferLen represents the size, in bytes, of the event data buffer
	BufferLen uint16
	// ExtendedData designates extended data items that ETW collects. The extended data includes some items, such as the security
	// identifier (SID) of the user that logged the event.
	ExtendedData *EventHeaderExtendedDataItem
	// Buffer represents raw event data that's parsed via TDH API.
	Buffer uintptr
	// UserContext is a pointer to custom user data passed in `EventTraceLogfile` structure.
	UserContext uintptr
}

// ClassicEventID identifies the event for which the call stack is enabled.
type ClassicEventID struct {
	// GUID identifies the event class
	GUID windows.GUID
	// Type is type that identifies the event within the kernel event class to enable
	Type uint8
	_    [7]uint8 // reserved
}

// EventFilterDescriptor defines the filter data that
// a session passes to the provider's enable callback.
type EventFilterDescriptor struct {
	Ptr  uintptr
	Size uint32
	Type uint32
}

// NewClassicEventID creates a new instance of classic event identifier.
func NewClassicEventID(guid windows.GUID, typ uint16) ClassicEventID {
	return ClassicEventID{GUID: guid, Type: uint8(typ)}
}

// Version returns the version of the event schema.
func (e *EventRecord) Version() uint8 {
	return e.Header.EventDescriptor.Version
}

// HookID returns either the opcode or the event ID.
func (e *EventRecord) HookID() uint16 {
	if e.Header.EventDescriptor.Opcode > 0 {
		return uint16(e.Header.EventDescriptor.Opcode)
	}
	return e.Header.EventDescriptor.ID
}

// ID is an unsigned integer that uniquely
// identifies the event. Handy for bitmask
// operations.
func (e *EventRecord) ID() uint {
	d1 := e.Header.ProviderID.Data1
	d2 := e.Header.ProviderID.Data2

	id := uint(byte(d1>>24))<<56 |
		uint(byte(d1>>16))<<48 |
		uint(byte(d1>>8))<<40 |
		uint(byte(d1))<<32 |
		uint(byte(d2>>8))<<24 |
		uint(byte(d2))<<16 |
		uint(e.HookID())

	return id
}

// ReadByte reads the byte from the buffer at the specified offset.
func (e *EventRecord) ReadByte(offset uint16) byte {
	if offset > e.BufferLen {
		return 0
	}
	return *(*byte)(unsafe.Pointer(e.Buffer + uintptr(offset)))
}

// ReadBytes reads a contiguous block of bytes from the buffer.
func (e *EventRecord) ReadBytes(offset uint16, count uint16) []byte {
	if offset > e.BufferLen {
		return nil
	}
	return (*[1<<30 - 1]byte)(unsafe.Pointer(e.Buffer + uintptr(offset)))[:count:count]
}

// ReadUint16 reads the uint16 value from the buffer at the specified offset.
func (e *EventRecord) ReadUint16(offset uint16) uint16 {
	if offset > e.BufferLen {
		return 0
	}
	return *(*uint16)(unsafe.Pointer(e.Buffer + uintptr(offset)))
}

// ReadUint32 reads the uint32 value from the buffer at the specified offset.
func (e *EventRecord) ReadUint32(offset uint16) uint32 {
	if offset > e.BufferLen {
		return 0
	}
	return *(*uint32)(unsafe.Pointer(e.Buffer + uintptr(offset)))
}

// ReadUint64 reads the uint64 value from the buffer at the specified offset.
func (e *EventRecord) ReadUint64(offset uint16) uint64 {
	if offset > e.BufferLen {
		return 0
	}
	return *(*uint64)(unsafe.Pointer(e.Buffer + uintptr(offset)))
}

// ReadAnsiString reads the ANSI string from the buffer at the specified offset.
// Returns the UTF-8 string and the number of bytes read from the string.
func (e *EventRecord) ReadAnsiString(offset uint16) (string, uint16) {
	if offset > e.BufferLen {
		return "", 0
	}

	b := make([]byte, e.BufferLen)
	var i uint16
	for i < e.BufferLen {
		c := *(*byte)(unsafe.Pointer(e.Buffer + uintptr(offset) + uintptr(i)))
		if c == 0 {
			break // null terminator
		}
		b[i] = c
		i++
	}

	if i == 0 {
		return "", offset + 1
	}

	if int(i) > len(b) {
		return string(b[:len(b)-1]), uint16(len(b)) + offset
	}

	return string(b[:i]), i + 1 + offset
}

// ReadUTF16String reads the UTF-16 string from the buffer at the specified offset.
// Returns the UTF-8 string and the number of bytes read from the string + the offset.
func (e *EventRecord) ReadUTF16String(offset uint16) (string, uint16) {
	if offset > e.BufferLen {
		return "", 0
	}

	// we're reading the leading string. First, calculate
	// the length of the null-terminated UTF16 string
	i := offset
	var length uint16
	for i < e.BufferLen {
		c := *(*uint16)(unsafe.Pointer(e.Buffer + uintptr(i)))
		if c == 0 {
			break // null terminator
		}
		length += 2
		i += 2
	}

	if length == 0 {
		return "", offset + 2 // null terminator size
	}

	b := (*[1<<30 - 1]uint16)(unsafe.Pointer(e.Buffer + uintptr(offset)))[:length:length]
	s := b[:len(b)/2]

	return utf16.Decode(s), uint16((len(s)+1)*2) + offset
}

// ReadNTUnicodeString reads the native Unicode string at the given offset.
func (e *EventRecord) ReadNTUnicodeString(offset uint16) (string, uint16) {
	if offset > e.BufferLen {
		return "", 0
	}

	i := offset
	var length uint16
	for i < e.BufferLen {
		c := *(*uint16)(unsafe.Pointer(e.Buffer + uintptr(i)))
		if c == 0 {
			break // null terminator
		}
		length += 2
		i += 2
	}

	if length == 0 {
		return "", offset + 2 // null terminator size
	}

	b := (*[1<<30 - 1]byte)(unsafe.Pointer(e.Buffer + uintptr(offset)))[:length:length]

	s := windows.NTUnicodeString{
		Length:        uint16(len(b)),
		MaximumLength: uint16(len(b)),
		Buffer:        (*uint16)(unsafe.Pointer(&b[0])),
	}

	return s.String(), s.Length + offset
}

// ConsumeUTF16String reads the byte slice with UTF16-encoded string
// when the UTF16 string is located at the end of the buffer.
func (e *EventRecord) ConsumeUTF16String(offset uint16) string {
	if offset > e.BufferLen {
		return ""
	}
	s := (*[1<<30 - 1]uint16)(unsafe.Pointer(e.Buffer + uintptr(offset)))[: e.BufferLen-offset : e.BufferLen-offset]
	return utf16.Decode(s[:len(s)/2-1])
}

// ReadSID reads the security identifier from the event buffer.
func (e *EventRecord) ReadSID(offset uint16, isWbemSid bool) ([]byte, uint16) {
	// this is a Security Token which can be null and takes 4 bytes.
	// Otherwise, it is an 8 byte structure (TOKEN_USER) followed by SID,
	// which is variable size depending on the 2nd byte in the SID
	sid := e.ReadUint32(offset)
	if sid == 0 {
		return nil, offset + 4
	}

	var tokenSize uint16
	if isWbemSid {
		tokenSize = 16 // TOKEN_USER size
	}

	authorities := e.ReadByte(offset + (tokenSize + 1))
	end := offset + tokenSize + 8 + 4*uint16(authorities)
	b := make([]byte, end-offset)
	i := offset
	for i < end {
		b[i-offset] = *(*byte)(unsafe.Pointer(e.Buffer + uintptr(i)))
		i++
	}
	return b, end
}

// EventExtendedItemStackTrace64 defines a call stack on a 64-bit machine.
type EventExtendedItemStackTrace64 struct {
	// MatchID represents the unique identifier that you use to match
	// the kernel-mode calls to the user-mode calls; the kernel-mode
	// calls and user-mode calls are captured in separate events if
	// the environment prevents both from being captured in the same event.
	// If the kernel-mode and user-mode calls were captured in the same event,
	// the value is zero.
	MatchID uint64
	// Address is an array of call addresses on the stack.
	Address [1]uint64
}

// HasStackTrace determines if the event has the stack trace extended item.
func (e *EventRecord) HasStackTrace() bool {
	if e.ExtendedDataCount == 0 {
		return false
	}
	data := (*[1 << 23]EventHeaderExtendedDataItem)(unsafe.Pointer(e.ExtendedData))[:e.ExtendedDataCount:e.ExtendedDataCount]
	for _, n := range data {
		if n.ExtType == EventHeaderExtTypeStackTrace64 {
			return true
		}
	}
	return false
}

// Callstack collects the event stack trace for
// events emitted by non-system logger providers.
func (e *EventRecord) Callstack() []va.Address {
	if e.ExtendedDataCount == 0 {
		return nil
	}
	data := (*[1 << 23]EventHeaderExtendedDataItem)(unsafe.Pointer(e.ExtendedData))[:e.ExtendedDataCount:e.ExtendedDataCount]
	for _, n := range data {
		if n.ExtType != EventHeaderExtTypeStackTrace64 {
			continue
		}
		s := (*EventExtendedItemStackTrace64)(unsafe.Pointer(uintptr(n.DataPtr)))
		if s == nil {
			continue
		}
		// number of return addresses
		length := (n.DataSize - 8) / 8
		addrs := make([]va.Address, length)
		addresses := unsafe.Slice(&s.Address[0], length)
		for i, addr := range addresses {
			addrs[i] = va.Address(addr)
		}
		return addrs
	}
	return nil
}

```

`pkg/sys/etw/types_test.go`:

```go
/*
 * Copyright 2021-2022 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package etw

import (
	"github.com/stretchr/testify/assert"
	"golang.org/x/sys/windows"
	"testing"
	"unsafe"
)

func TestReadBuffer(t *testing.T) {
	var tests = []struct {
		buf        []byte
		assertions func(t *testing.T, ev *EventRecord)
	}{
		{
			[]byte{
				0x70, 0x3B, 0xD1, 0x24, 0x8E, 0xD6, 0xFF, 0xFF, 0x9C, 0x02, 0x00, 0x00, 0x2C, 0x00, 0x5C, 0x00,
				0x52, 0x00, 0x45, 0x00, 0x47, 0x00, 0x49, 0x00, 0x53, 0x00, 0x54, 0x00, 0x52, 0x00, 0x59, 0x00,
				0x5C, 0x00, 0x55, 0x00, 0x53, 0x00, 0x45, 0x00, 0x52, 0x00, 0x5C, 0x00, 0x53, 0x00, 0x2D, 0x00,
				0x31, 0x00, 0x2D, 0x00, 0x35, 0x00, 0x2D, 0x00, 0x32, 0x00, 0x31, 0x00, 0x2D, 0x00, 0x32, 0x00,
				0x32, 0x00, 0x37, 0x00, 0x31, 0x00, 0x30, 0x00, 0x33, 0x00, 0x34, 0x00, 0x34, 0x00, 0x35, 0x00,
				0x32, 0x00, 0x2D, 0x00, 0x32, 0x00, 0x36, 0x00, 0x30, 0x00, 0x36, 0x00, 0x32, 0x00, 0x37, 0x00,
				0x30, 0x00, 0x30, 0x00, 0x39, 0x00, 0x39, 0x00, 0x2D, 0x00, 0x39, 0x00, 0x38, 0x00, 0x34, 0x00,
				0x38, 0x00, 0x37, 0x00, 0x31, 0x00, 0x35, 0x00, 0x36, 0x00, 0x39, 0x00, 0x2D, 0x00, 0x31, 0x00,
				0x30, 0x00, 0x30, 0x00, 0x31, 0x00, 0x00, 0x00},
			func(t *testing.T, ev *EventRecord) {
				assert.Equal(t, uint64(18446698504724233072), ev.ReadUint64(0))
				assert.Equal(t, uint64(0), ev.ReadUint64(ev.BufferLen+20))
				assert.Equal(t, uint32(668), ev.ReadUint32(8))
				assert.Equal(t, uint16(44), ev.ReadUint16(12))
				assert.Equal(t, "\\REGISTRY\\USER\\S-1-5-21-2271034452-2606270099-984871569-1001", ev.ConsumeUTF16String(14))
			},
		},
		{
			[]byte{
				0x80, 0xE0, 0x2E, 0x49, 0x06, 0xC1, 0xFF, 0xFF, 0xE8, 0x30, 0x00, 0x00, 0x78, 0x14, 0x00, 0x00,
				0x00, 0x00, 0x00, 0x00, 0x03, 0x01, 0x00, 0x00, 0x00, 0x50, 0x22, 0x91, 0x03, 0x00, 0x00, 0x00,
				0x00, 0x00, 0x00, 0x00, 0xE0, 0x08, 0xE2, 0x1F, 0x0F, 0xA7, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00,
				0x0F, 0xA7, 0xFF, 0xFF, 0x01, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x05, 0x12, 0x00, 0x00, 0x00,
				0x63, 0x6D, 0x64, 0x2E, 0x65, 0x78, 0x65, 0x00, 0x43, 0x00, 0x3A, 0x00, 0x5C, 0x00, 0x57, 0x00,
				0x49, 0x00, 0x4E, 0x00, 0x44, 0x00, 0x4F, 0x00, 0x57, 0x00, 0x53, 0x00, 0x5C, 0x00, 0x73, 0x00,
				0x79, 0x00, 0x73, 0x00, 0x74, 0x00, 0x65, 0x00, 0x6D, 0x00, 0x33, 0x00, 0x32, 0x00, 0x5C, 0x00,
				0x63, 0x00, 0x6D, 0x00, 0x64, 0x00, 0x2E, 0x00, 0x65, 0x00, 0x78, 0x00, 0x65, 0x00, 0x20, 0x00,
				0x2F, 0x00, 0x63, 0x00, 0x20, 0x00, 0x64, 0x00, 0x69, 0x00, 0x72, 0x00, 0x20, 0x00, 0x2F, 0x00,
				0x2D, 0x00, 0x43, 0x00, 0x20, 0x00, 0x2F, 0x00, 0x57, 0x00, 0x20, 0x00, 0x22, 0x00, 0x5C, 0x00,
				0x5C, 0x00, 0x3F, 0x00, 0x5C, 0x00, 0x63, 0x00, 0x3A, 0x00, 0x5C, 0x00, 0x55, 0x00, 0x73, 0x00,
				0x65, 0x00, 0x72, 0x00, 0x73, 0x00, 0x5C, 0x00, 0x6E, 0x00, 0x65, 0x00, 0x64, 0x00, 0x6F, 0x00,
				0x5C, 0x00, 0x41, 0x00, 0x70, 0x00, 0x70, 0x00, 0x44, 0x00, 0x61, 0x00, 0x74, 0x00, 0x61, 0x00,
				0x5C, 0x00, 0x52, 0x00, 0x6F, 0x00, 0x61, 0x00, 0x6D, 0x00, 0x69, 0x00, 0x6E, 0x00, 0x67, 0x00,
				0x5C, 0x00, 0x52, 0x00, 0x61, 0x00, 0x62, 0x00, 0x62, 0x00, 0x69, 0x00, 0x74, 0x00, 0x4D, 0x00,
				0x51, 0x00, 0x5C, 0x00, 0x64, 0x00, 0x62, 0x00, 0x5C, 0x00, 0x72, 0x00, 0x61, 0x00, 0x62, 0x00,
				0x62, 0x00, 0x69, 0x00, 0x74, 0x00, 0x40, 0x00, 0x61, 0x00, 0x72, 0x00, 0x63, 0x00, 0x68, 0x00,
				0x72, 0x00, 0x61, 0x00, 0x62, 0x00, 0x62, 0x00, 0x69, 0x00, 0x74, 0x00, 0x2D, 0x00, 0x6D, 0x00,
				0x6E, 0x00, 0x65, 0x00, 0x73, 0x00, 0x69, 0x00, 0x61, 0x00, 0x22, 0x00, 0x00, 0x00, 0x00, 0x00,
				0x00, 0x00},
			func(t *testing.T, ev *EventRecord) {
				assert.Equal(t, uint32(12520), ev.ReadUint32(8))
				assert.Equal(t, uint32(5240), ev.ReadUint32(12))

				rawSid, offset := ev.ReadSID(36, true)
				b := uintptr(unsafe.Pointer(&rawSid[0]))
				b += uintptr(8 * 2)

				sid := (*windows.SID)(unsafe.Pointer(b))
				assert.Equal(t, "S-1-5-18", sid.String())

				name, noffset := ev.ReadAnsiString(offset)
				assert.Equal(t, "cmd.exe", name)
				cmdline, _ := ev.ReadUTF16String(noffset)
				assert.Equal(t, "C:\\WINDOWS\\system32\\cmd.exe /c dir /-C /W \"\\\\?\\c:\\Users\\nedo\\AppData\\Roaming\\RabbitMQ\\db\\rabbit@archrabbit-mnesia\"", cmdline)
			},
		},
	}

	for _, tt := range tests {
		ev := &EventRecord{
			BufferLen: uint16(len(tt.buf)),
			Buffer:    uintptr(unsafe.Pointer(&tt.buf[0])),
		}
		tt.assertions(t, ev)
	}
}

func TestID(t *testing.T) {
	ev := &EventRecord{Header: EventHeader{ProviderID: ThreadpoolGUID, EventDescriptor: EventDescriptor{ID: 44}}}
	assert.Equal(t, uint(14439051552138264620), ev.ID())
}

```

`pkg/sys/etw/zsyscall_windows.go`:

```go
// Code generated by 'go generate'; DO NOT EDIT.

package etw

import (
	"syscall"
	"unsafe"

	"golang.org/x/sys/windows"
)

var _ unsafe.Pointer

// Do the interface allocations only once for common
// Errno values.
const (
	errnoERROR_IO_PENDING = 997
)

var (
	errERROR_IO_PENDING error = syscall.Errno(errnoERROR_IO_PENDING)
	errERROR_EINVAL     error = syscall.EINVAL
)

// errnoErr returns common boxed Errno values, to prevent
// allocations at runtime.
func errnoErr(e syscall.Errno) error {
	switch e {
	case 0:
		return errERROR_EINVAL
	case errnoERROR_IO_PENDING:
		return errERROR_IO_PENDING
	}
	// TODO: add more here, after collecting data on the common
	// error values see on Windows. (perhaps when running
	// all.bat?)
	return e
}

var (
	modadvapi32 = windows.NewLazySystemDLL("advapi32.dll")

	procCloseTrace            = modadvapi32.NewProc("CloseTrace")
	procControlTraceW         = modadvapi32.NewProc("ControlTraceW")
	procEnableTraceEx2        = modadvapi32.NewProc("EnableTraceEx2")
	procOpenTraceW            = modadvapi32.NewProc("OpenTraceW")
	procProcessTrace          = modadvapi32.NewProc("ProcessTrace")
	procStartTraceW           = modadvapi32.NewProc("StartTraceW")
	procTraceQueryInformation = modadvapi32.NewProc("TraceQueryInformation")
	procTraceSetInformation   = modadvapi32.NewProc("TraceSetInformation")
)

func closeTrace(handle TraceHandle) (err error) {
	r1, _, e1 := syscall.Syscall(procCloseTrace.Addr(), 1, uintptr(handle), 0, 0)
	if r1 == 0 {
		err = errnoErr(e1)
	}
	return
}

func controlTrace(handle TraceHandle, name string, props *EventTraceProperties, operation TraceOperation) (err error) {
	var _p0 *uint16
	_p0, err = syscall.UTF16PtrFromString(name)
	if err != nil {
		return
	}
	return _controlTrace(handle, _p0, props, operation)
}

func _controlTrace(handle TraceHandle, name *uint16, props *EventTraceProperties, operation TraceOperation) (err error) {
	r1, _, e1 := syscall.Syscall6(procControlTraceW.Addr(), 4, uintptr(handle), uintptr(unsafe.Pointer(name)), uintptr(unsafe.Pointer(props)), uintptr(operation), 0, 0)
	if r1 != 0 {
		err = errnoErr(e1)
	}
	return
}

func enableTraceEx2(handle TraceHandle, providerID *windows.GUID, controlCode uint32, level uint8, matchAnyKeyword uint64, matchAllKeyword uint64, timeout uint32, enableParameters *EnableTraceParameters) (err error) {
	r1, _, e1 := syscall.Syscall9(procEnableTraceEx2.Addr(), 8, uintptr(handle), uintptr(unsafe.Pointer(providerID)), uintptr(controlCode), uintptr(level), uintptr(matchAnyKeyword), uintptr(matchAllKeyword), uintptr(timeout), uintptr(unsafe.Pointer(enableParameters)), 0)
	if r1 != 0 {
		err = errnoErr(e1)
	}
	return
}

func openTrace(logfile *EventTraceLogfile) (handle TraceHandle) {
	r0, _, _ := syscall.Syscall(procOpenTraceW.Addr(), 1, uintptr(unsafe.Pointer(logfile)), 0, 0)
	handle = TraceHandle(r0)
	return
}

func processTrace(handle *TraceHandle, count uint32, start *windows.Filetime, end *windows.Filetime) (err error) {
	r1, _, e1 := syscall.Syscall6(procProcessTrace.Addr(), 4, uintptr(unsafe.Pointer(handle)), uintptr(count), uintptr(unsafe.Pointer(start)), uintptr(unsafe.Pointer(end)), 0, 0)
	if r1 != 0 {
		err = errnoErr(e1)
	}
	return
}

func startTrace(handle *TraceHandle, name string, props *EventTraceProperties) (err error) {
	var _p0 *uint16
	_p0, err = syscall.UTF16PtrFromString(name)
	if err != nil {
		return
	}
	return _startTrace(handle, _p0, props)
}

func _startTrace(handle *TraceHandle, name *uint16, props *EventTraceProperties) (err error) {
	r1, _, e1 := syscall.Syscall(procStartTraceW.Addr(), 3, uintptr(unsafe.Pointer(handle)), uintptr(unsafe.Pointer(name)), uintptr(unsafe.Pointer(props)))
	if r1 != 0 {
		err = errnoErr(e1)
	}
	return
}

func traceQueryInformation(handle TraceHandle, infoClass uint8, info uintptr, length uint32, size *uint32) (err error) {
	r1, _, e1 := syscall.Syscall6(procTraceQueryInformation.Addr(), 5, uintptr(handle), uintptr(infoClass), uintptr(info), uintptr(length), uintptr(unsafe.Pointer(size)), 0)
	if r1 != 0 {
		err = errnoErr(e1)
	}
	return
}

func traceSetInformation(handle TraceHandle, infoClass uint8, info uintptr, length uint32) (err error) {
	r1, _, e1 := syscall.Syscall6(procTraceSetInformation.Addr(), 4, uintptr(handle), uintptr(infoClass), uintptr(info), uintptr(length), 0, 0)
	if r1 != 0 {
		err = errnoErr(e1)
	}
	return
}

```

`pkg/sys/fs.go`:

```go
/*
 * Copyright 2021-2022 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package sys

import (
	"golang.org/x/sys/windows"
)

var drives = []string{
	"A",
	"B",
	"C",
	"D",
	"E",
	"F",
	"G",
	"H",
	"I",
	"J",
	"K",
	"L",
	"M",
	"N",
	"O",
	"P",
	"Q",
	"R",
	"S",
	"T",
	"U",
	"V",
	"W",
	"X",
	"Y",
	"Z"}

const FileFsDeviceInformationClass = 4

// FileFsDeviceInformation provides file system device information about
// the type of device object associated with a file object.
type FileFsDeviceInformation struct {
	// Type designates the type of underlying device.
	Type uint32
	// Characteristics represents device characteristics.
	Characteristics uint32
}

// GetLogicalDrives returns available device drive letters in the system.
func GetLogicalDrives() []string {
	bitmask, err := windows.GetLogicalDrives()
	if err != nil {
		return nil
	}
	devs := make([]string, 0)
	for _, drive := range drives {
		if bitmask&1 == 1 {
			devs = append(devs, drive+":")
		}
		bitmask >>= 1
	}
	return devs
}

// QueryDosDevice translates the DOS device name to hard disk drive letter.
func QueryDosDevice(drive string) (string, error) {
	dev := make([]uint16, windows.MAX_PATH)
	_, err := windows.QueryDosDevice(windows.StringToUTF16Ptr(drive), &dev[0], windows.MAX_PATH)
	if err != nil {
		return "", err
	}
	return windows.UTF16ToString(dev), nil
}

// PathIsDirectory determines if the provided path is a directory.
func PathIsDirectory(path string) bool {
	return pathIsDirectory(windows.StringToUTF16Ptr(path))
}

// GetMappedFile checks whether the specified address is within a memory-mapped file in the address
// space of the specified process. If so, the function returns the name of the memory-mapped file.
func GetMappedFile(process windows.Handle, addr uintptr) string {
	var size uint32 = windows.MAX_PATH
	n := make([]uint16, size)
	if GetMappedFileName(process, addr, &n[0], size) > 0 {
		return windows.UTF16ToString(n)
	}
	return ""
}

```

`pkg/sys/handle.go`:

```go
/*
 * Copyright 2021-2022 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package sys

import "golang.org/x/sys/windows"

// ProcessHandleTableEntryInfo is the structure that describes the process handle entry.
type ProcessHandleTableEntryInfo struct {
	Handle           windows.Handle
	HandleCount      uintptr
	PointerCount     uintptr
	GrantedAccess    uint32
	ObjectTypeIndex  uint32
	HandleAttributes uint32
	Reserved         uint32
}

// ProcessHandleSnapshotInformation is the structure that holds the process handle table.
type ProcessHandleSnapshotInformation struct {
	NumberOfHandles uintptr
	Reserved        uintptr
	Handles         [1]ProcessHandleTableEntryInfo
}

// SystemHandleTableEntryInfoEx is the structure that describes the process handle entry.
type SystemHandleTableEntryInfoEx struct {
	Object                uint64
	ProcessID             uintptr
	Handle                windows.Handle
	GrantedAccess         uint32
	CreatorBackTraceIndex uint16
	ObjectTypeIndex       uint16
	HandleAttributes      uint32
	Reserved              uint32
}

// SystemHandleInformationEx is the structures that holds the process handle table.
type SystemHandleInformationEx struct {
	NumberOfHandles uintptr
	Reserved        uintptr
	Handles         [1]SystemHandleTableEntryInfoEx
}

```

`pkg/sys/mem.go`:

```go
/*
 * Copyright 2021-2022 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package sys

const (
	// SectionR designates section readonly protection
	SectionR = 0x10000
	// SectionX designates section execute protection
	SectionX = 0x20000
	// SectionRW designates section read/write protection
	SectionRW = 0x40000
	// SectionRX designates section read/execute protection
	SectionRX = 0x30000
	// SectionRWX designates section read/write/execute protection
	SectionRWX = 0x60000
	// SectionWC designates section writ/copy protection
	SectionWC = 0x50000
	// SectionWCB designates section write combine protection
	SectionWCB = 0x90000
	// SectionWXC designates section write/execute/writecopy protection
	SectionWXC = 0x70000
	// SectionNC designates section nocache protection
	SectionNC = 0x80000
)

// MemoryWorkingSetExInformation describes the attributes of the memory region.
type MemoryWorkingSetExInformation struct {
	VirtualAddress    uintptr
	VirtualAttributes MemoryWorkingSetExBlock
}

type MemoryWorkingSetExBlock uintptr

// Valid if this bit is 1, the subsequent members are valid. Otherwise, they should be ignored.
func (b MemoryWorkingSetExBlock) Valid() bool {
	return b&1 != 0
}

// ShareCount specifies the number of processes that share this page. The maximum value of this member is 7.
func (b MemoryWorkingSetExBlock) ShareCount() uintptr {
	return (uintptr(b) >> 1) & ((1 << 3) - 1)
}

// Win32Protection specifies the memory protection attributes of the page.
func (b MemoryWorkingSetExBlock) Win32Protection() uintptr {
	return (uintptr(b) >> 4) & ((1 << 11) - 1)
}

// Shared evaluates to true if the page can be shared or false otherwise.
func (b MemoryWorkingSetExBlock) Shared() bool {
	return b&(1<<15) != 0
}

// Node represents the NUMA node. The maximum value of this member is 63.
func (b MemoryWorkingSetExBlock) Node() uintptr {
	return (uintptr(b) >> 16) & ((1 << 6) - 1)
}

// Locked returns true if the virtual page is locked in physical memory.
func (b MemoryWorkingSetExBlock) Locked() bool {
	return b&(1<<15) != 0
}

// LargePage returns true if the page is a large page.
func (b MemoryWorkingSetExBlock) LargePage() bool {
	return b&(1<<16) != 0
}

// SharedOriginal evaluates to true if the page can be shared or false otherwise.
func (b MemoryWorkingSetExBlock) SharedOriginal() bool {
	return b&(1<<30) != 0
}

// Bad indicates the page has been reported as bad.
func (b MemoryWorkingSetExBlock) Bad() bool {
	return b&(1<<31) != 0
}

```

`pkg/sys/object.go`:

```go
/*
 * Copyright 2021-2022 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package sys

import (
	"github.com/rabbitstack/fibratus/pkg/util/typesize"
	"golang.org/x/sys/windows"
	"unsafe"
)

const (
	// ObjectNameInformationClass returns the object name information.
	ObjectNameInformationClass = iota + 1
	// ObjectTypeInformationClass returns the object type information.
	ObjectTypeInformationClass
	// ObjectTypesInformationClass returns handle object types.
	ObjectTypesInformationClass
)

const (
	// AlpcBasicPortInformationClass is the information class for obtaining basic ALPC port information.
	AlpcBasicPortInformationClass = iota
)

const (
	// MutantBasicInformationClass is the information class for getting basic mutant information.
	MutantBasicInformationClass = iota
)

type GenericMapping struct {
	GenericRead    uint32
	GenericWrite   uint32
	GenericExecute uint32
	GenericAll     uint32
}

// ObjectTypeInformation contains object type data.
type ObjectTypeInformation struct {
	TypeName                   windows.NTUnicodeString
	TotalNumberOfObjects       uint32
	TotalNumberOfHandles       uint32
	TotalPagedPoolUsage        uint32
	TotalNonPagedPoolUsage     uint32
	TotalNamePoolUsage         uint32
	TotalHandleTableUsage      uint32
	HighWaterNumberOfObjects   uint32
	HighWaterNumberOfHandles   uint32
	HighWaterPagedPoolUsage    uint32
	HighWaterNonPagedPoolUsage uint32
	HighWaterNamePoolUsage     uint32
	HighWaterHandleTableUsage  uint32
	InvalidAttributes          uint32
	GenericMapping             GenericMapping
	ValidAccessMask            uint32
	SecurityRequired           bool
	MaintainHandleCount        bool
	TypeIndex                  uint8
	ReservedByte               int8
	PoolType                   uint32
	DefaultPagedPoolCharge     uint32
	DefaultNonPagedPoolCharge  uint32
}

// ObjectTypesInformation stores the number of resolved object type names.
type ObjectTypesInformation struct {
	NumberOfTypes uint32
}

// First returns the first object type structure.
func (o *ObjectTypesInformation) First() *ObjectTypeInformation {
	p := unsafe.Pointer(uintptr(unsafe.Pointer(o)) + (unsafe.Sizeof(ObjectTypesInformation{})+typesize.Pointer()-1)&^(typesize.Pointer()-1))
	return (*ObjectTypeInformation)(p)
}

// Next returns the next object type structure given the previous structure pointer.
func (*ObjectTypesInformation) Next(typ *ObjectTypeInformation) *ObjectTypeInformation {
	align := (uintptr(typ.TypeName.MaximumLength) + typesize.Pointer() - 1) &^ (typesize.Pointer() - 1)
	offset := uintptr(unsafe.Pointer(typ)) + unsafe.Sizeof(ObjectTypeInformation{})
	return (*ObjectTypeInformation)(unsafe.Pointer(offset + align))
}

// ObjectNameInformation stores object name information.
type ObjectNameInformation struct {
	ObjectName windows.NTUnicodeString
}

// QueryObject consults the specified object information class and returns
// a pointer to the structure containing object information.
func QueryObject[C any](obj windows.Handle, class int32) (*C, error) {
	var c C
	var s uint32
	n := make([]byte, unsafe.Sizeof(c))
	err := NtQueryObject(obj, class, unsafe.Pointer(&n[0]), uint32(len(n)), &s)
	if err != nil {
		if err == windows.STATUS_INFO_LENGTH_MISMATCH || err == windows.STATUS_BUFFER_TOO_SMALL || err == windows.STATUS_BUFFER_OVERFLOW {
			n = make([]byte, s)
			err := NtQueryObject(obj, class, unsafe.Pointer(&n[0]), uint32(len(n)), &s)
			if err != nil {
				return nil, err
			}
			return (*C)(unsafe.Pointer(&n[0])), nil
		}
		return nil, err
	}
	return (*C)(unsafe.Pointer(&n[0])), nil
}

```

`pkg/sys/privilege.go`:

```go
/*
 * Copyright 2021-2022 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package sys

import (
	"bytes"
	"encoding/binary"
	"github.com/pkg/errors"
	"golang.org/x/sys/windows"
	"unsafe"
)

const (
	// SeDebugPrivilege is the name of the privilege used to debug programs.
	SeDebugPrivilege = "SeDebugPrivilege"
	// SeTcbPrivilege privilege identifies its holder as part of the trusted computer base.
	SeTcbPrivilege = "SeTcbPrivilege"
)

// Errors returned by AdjustTokenPrivileges.
const (
	// ErrorNotAllAsigned specifies that the token does not have one or more of the privileges specified in the state parameter.
	ErrorNotAllAsigned windows.Errno = 1300
)

// Attribute bits for privileges.
const (
	// PrivilegedEnabled enables the privilege.
	PrivilegedEnabled uint32 = 0x00000002
	// PrivilegeRemoved removes the privilege.
	PrivilegeRemoved uint32 = 0x00000004
)

// mapPrivileges maps privilege names to LUID values.
func mapPrivileges(names []string) ([]windows.LUID, error) {
	var privileges []windows.LUID
	for _, name := range names {
		var p windows.LUID
		err := windows.LookupPrivilegeValue(nil, windows.StringToUTF16Ptr(name), &p)
		if err != nil {
			return nil, errors.Wrapf(err, "LookupPrivilegeValue failed on '%v'", name)
		}
		privileges = append(privileges, p)
	}
	return privileges, nil
}

// adjustTokenPrivileges enables/disables the specified privileges in the given
// Token. The token must have TOKEN_ADJUST_PRIVILEGES access. If the token
// does not already contain the privilege it cannot be enabled.
func adjustTokenPrivileges(token windows.Token, state uint32, privileges ...string) error {
	privValues, err := mapPrivileges(privileges)
	if err != nil {
		return err
	}

	var b bytes.Buffer
	if err := binary.Write(&b, binary.LittleEndian, uint32(len(privValues))); err != nil {
		return err
	}
	for _, p := range privValues {
		if err := binary.Write(&b, binary.LittleEndian, p); err != nil {
			continue
		}
		if err := binary.Write(&b, binary.LittleEndian, state); err != nil {
			continue
		}
	}

	privs := (*windows.Tokenprivileges)(unsafe.Pointer(&b.Bytes()[0]))
	err = windows.AdjustTokenPrivileges(token, false, privs, uint32(b.Len()), nil, nil)
	if err != nil {
		return err
	}
	if err == ErrorNotAllAsigned {
		return errors.Wrap(err, "error not all privileges were assigned")
	}
	return nil
}

// SetDebugPrivilege sets the debug privilege in the current process token.
func SetDebugPrivilege() {
	enablePrivileges(SeDebugPrivilege)
}

// SetTcbPrivilege sets the TCB privilege in the current process token.
func SetTcbPrivilege() {
	enablePrivileges(SeTcbPrivilege)
}

// RemoveTcbPrivilege removes the TCB privilege from the access token of the current process.
func RemoveTcbPrivilege() {
	removePrivileges(SeTcbPrivilege)
}

func enablePrivileges(privs ...string) {
	var token windows.Token
	_ = windows.OpenProcessToken(windows.CurrentProcess(), windows.TOKEN_ADJUST_PRIVILEGES|windows.TOKEN_QUERY, &token)
	_ = adjustTokenPrivileges(token, PrivilegedEnabled, privs...)
}

func removePrivileges(privs ...string) {
	var token windows.Token
	_ = windows.OpenProcessToken(windows.CurrentProcess(), windows.TOKEN_ADJUST_PRIVILEGES|windows.TOKEN_QUERY, &token)
	_ = adjustTokenPrivileges(token, PrivilegeRemoved, privs...)
}

```

`pkg/sys/process.go`:

```go
/*
 * Copyright 2021-2022 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package sys

import (
	"unsafe"

	"golang.org/x/sys/windows"
	"golang.org/x/sys/windows/svc"
)

const (
	// InvalidProcessID represents the value of an invalid process identifier
	InvalidProcessID uint32 = 0xffffffff
	// ProcessStatusStillActive represents the status of the running process
	ProcessStatusStillActive uint32 = 259
)

// ModuleHandleFromAddress is the flag of the GetModuleHandleEx
// function parameter that indicates the module handle is obtained
// from the address
const ModuleHandleFromAddress = 0x00000004

// ProcessProtectionInformation is the information class that returns a
// value indicating the type of protected process and the protected process
// signer.
const ProcessProtectionInformation = 61

// PsProtection describes the process protection attributes.
type PsProtection struct {
	// S is the C union field describing protection attributes.
	//	union {
	//		struct {
	//			PS_PROTECTED_TYPE Type : 3;
	//			BOOLEAN Audit : 1;
	//			PS_PROTECTED_SIGNER Signer : 4;
	//	 } s;
	// }
	S     byte
	Level byte
}

// IsProtected determines if the process has the protected flag.
// The protected mask is stored in the bit field comprising the
// bits 1 to 3.
func (pp PsProtection) IsProtected() bool {
	return int((pp.S>>1)&((1<<3)-1)) != 0
}

// QueryInformationProcess consults the specified process information class and returns
// a pointer to the structure containing process information.
func QueryInformationProcess[C any](proc windows.Handle, class int32) (*C, error) {
	var c C
	var s uint32
	n := make([]byte, unsafe.Sizeof(c))
	err := windows.NtQueryInformationProcess(proc, class, unsafe.Pointer(&n[0]), uint32(len(n)), &s)
	if err != nil {
		if err == windows.STATUS_INFO_LENGTH_MISMATCH || err == windows.STATUS_BUFFER_TOO_SMALL || err == windows.STATUS_BUFFER_OVERFLOW {
			n = make([]byte, s)
			err := windows.NtQueryInformationProcess(proc, class, unsafe.Pointer(&n[0]), uint32(len(n)), &s)
			if err != nil {
				return nil, err
			}
			return (*C)(unsafe.Pointer(&n[0])), nil
		}
		return nil, err
	}
	return (*C)(unsafe.Pointer(&n[0])), nil
}

// ReadProcessMemory reads from the process virtual address space starting at specified address.
func ReadProcessMemory[S any](proc windows.Handle, addr uintptr) (*S, error) {
	var s S
	b := make([]byte, unsafe.Sizeof(s))
	err := windows.ReadProcessMemory(proc, addr, &b[0], uintptr(len(b)), nil)
	if err != nil {
		return nil, err
	}
	return (*S)(unsafe.Pointer(&b[0])), nil
}

// IsProcessRunning determines whether the process is in a running state.
func IsProcessRunning(proc windows.Handle) bool {
	var exitcode uint32
	err := windows.GetExitCodeProcess(proc, &exitcode)
	if err != nil {
		return false
	}
	return exitcode == ProcessStatusStillActive
}

// IsProcessPackaged determines if the process is packaged by trying
// to resolve the package identifier.
func IsProcessPackaged(proc windows.Handle) (bool, error) {
	var n uint32
	err := GetPackageID(proc, &n, 0)
	if err == windows.ERROR_INSUFFICIENT_BUFFER {
		b := make([]byte, n)
		err = GetPackageID(proc, &n, uintptr(unsafe.Pointer(&b[0])))
	}
	return err == nil, err
}

// IsWindowsService reports whether the process is currently executing
// as a Windows service.
func IsWindowsService() bool {
	isSvc, err := svc.IsWindowsService()
	return isSvc && err == nil
}

// ProcessModule describes the process loaded module.
type ProcessModule struct {
	windows.ModuleInfo
	Name string
}

// EnumProcessModules returns all loaded modules in the process address space.
func EnumProcessModules(pid uint32) []ProcessModule {
	n := uint32(1024)
	mods := make([]windows.Handle, n)
	proc, err := windows.OpenProcess(windows.PROCESS_QUERY_INFORMATION|windows.PROCESS_VM_READ, false, pid)
	if err != nil {
		return nil
	}
	defer windows.Close(proc)

	if err := windows.EnumProcessModules(proc, &mods[0], 1024, &n); err != nil {
		// needs bigger buffer
		if n > 1024 {
			mods = make([]windows.Handle, n)
			if err := windows.EnumProcessModules(proc, &mods[0], n, &n); err != nil {
				return nil
			}
		}
		return nil
	}

	modules := make([]ProcessModule, 0)
	for _, mod := range mods {
		if mod == 0 {
			continue
		}
		var moduleInfo windows.ModuleInfo
		if err := windows.GetModuleInformation(proc, mod, &moduleInfo, uint32(unsafe.Sizeof(moduleInfo))); err != nil {
			continue
		}
		module := ProcessModule{ModuleInfo: moduleInfo}
		if name, err := getModuleFileName(proc, mod); err == nil {
			module.Name = name
		}
		modules = append(modules, module)
	}

	return modules
}

func getModuleFileName(proc, mod windows.Handle) (string, error) {
	n := uint32(1024)
	buf := make([]uint16, n)
	err := windows.GetModuleFileNameEx(proc, mod, &buf[0], n)
	if err != nil {
		return "", err
	}
	return windows.UTF16ToString(buf), nil
}

// GetProcessTokenInformation returns the specified process token information.
func GetProcessTokenInformation[C any](token windows.Token, class uint32) (*C, error) {
	var n uint32
	// get the buffer size to accommodate the desired token class structure
	if err := windows.GetTokenInformation(token, class, nil, 0, &n); err != nil {
		if err != windows.ERROR_INSUFFICIENT_BUFFER {
			return nil, err
		}
	}

	// allocate the buffer and obtain token information
	b := make([]byte, n)
	err := windows.GetTokenInformation(token, class, &b[0], n, &n)
	if err != nil {
		return nil, err
	}

	return (*C)(unsafe.Pointer(&b[0])), nil
}

```

`pkg/sys/process_test.go`:

```go
/*
 * Copyright 2021-present by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package sys

import (
	"github.com/stretchr/testify/assert"
	"golang.org/x/sys/windows"
	"path/filepath"
	"strings"
	"testing"
)

func TestEnumProcessModules(t *testing.T) {
	mods := EnumProcessModules(windows.GetCurrentProcessId())
	assert.True(t, len(mods) > 0)
	names := make([]string, 0, len(mods))
	for _, mod := range mods {
		names = append(names, filepath.Base(strings.ToLower(mod.Name)))
	}
	assert.Contains(t, names, "ntdll.dll")
}

```

`pkg/sys/rid.go`:

```go
/*
 * Copyright 2021-present by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package sys

import (
	"golang.org/x/sys/windows"
)

const (
	// UntrustedRid designates the integrity level of anonymous
	// logged on processes. Write access is mostly blocked.
	UntrustedRid = 0x00000000

	// LowRid designates low process token integrity. Used for
	// AppContainers, browsers that access the Internet and
	// prevent most write access to objects on the system.
	LowRid = 0x00001000

	// MediumRid designates the token integrity default for most
	// processes. For authenticated users.
	MediumRid = 0x00002000

	// MediumPlusRid is often observed in AppContainer or UWP processes,
	// especially when they require elevated trust compared to a typical
	// Medium-level process but still shouldn't run with full administrative
	// privileges.
	MediumPlusRid = MediumRid | 0x100

	// HighRid is the integrity level for Administrator-level processes.
	// (Elevated) process with UAC.
	HighRid = 0x00003000

	// SystemRid is the integrity level reserved for system services/processes.
	SystemRid = 0x00004000

	// ProtectedProcessRid is not seen to be used by default. Windows Internals
	// book says it can be set by a kernel-mode caller.
	ProtectedProcessRid = 0x00005000
)

// RidToString given the SID representing the token mandatory label
// returns the string representation of the integrity level.
func RidToString(sid *windows.SID) string {
	if sid == nil {
		return "UNKNOWN"
	}
	switch sid.SubAuthority(uint32(sid.SubAuthorityCount() - 1)) {
	case UntrustedRid:
		return "UNTRUSTED"
	case LowRid:
		return "LOW"
	case MediumRid:
		return "MEDIUM"
	case MediumPlusRid:
		return "MEDIUM+"
	case HighRid:
		return "HIGH"
	case SystemRid:
		return "SYSTEM"
	case ProtectedProcessRid:
		return "PROTECTED"
	default:
		return "UNKNOWN"
	}
}

```

`pkg/sys/shell.go`:

```go
/*
 * Copyright 2021-2022 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package sys

import (
	"golang.org/x/sys/windows"
	"unsafe"
)

const (
	NotifyIconGUIDFlag    = 0x00000020
	NotifyIconMessageFlag = 0x00000001
	NotifyIconInfoFlag    = 0x00000010
	NotifyIconIconFlag    = 0x00000002
	NotifyIconTipFlag     = 0x00000004

	// NotifyIconUserFlag specifies the icon identified in
	// the NotifyIconData structure is used as the notification
	// balloon's title icon.
	NotifyIconUserFlag = 0x00000004
	// NotifyIconNosoundFlag indicates not to play the associated
	// sound when the balloon notification is shown.
	NotifyIconNosoundFlag = 0x00000010
	// NotifyIconLargeIconFlag determines the large version of
	// the icon should be used as the notification icon
	NotifyIconLargeIconFlag = 0x00000020
	// NotifyIconRespectQuietTimeFlag instructs not to display
	// the balloon notification if the current user is in "quiet time".
	// During this time, most notifications should not be sent or shown.
	// This lets a user become accustomed to a new computer system without
	// those distractions. Quiet time also occurs for each user after an
	// operating system upgrade or clean installation.
	NotifyIconRespectQuietTimeFlag = 0x00000080
)

// SystrayIconGUID identifies the systray icon
var SystrayIconGUID = windows.GUID{Data1: 0x52cf1171, Data2: 0xfe06, Data3: 0xb859, Data4: [8]byte{0x9d, 0xda, 0x36, 0xc0, 0x4f, 0xd7, 0xba, 0xb9}}

// NotifyIconMessage defines message types that
// can be sent to the taskbar status area.
type NotifyIconMessage uint32

const (
	// ShellAddIcon adds an icon to the status area.
	ShellAddIcon NotifyIconMessage = 0x00000000
	// ShellModifyIcon modifies an icon in the status area.
	ShellModifyIcon NotifyIconMessage = 0x00000001
	// ShellDeleteIcon deletes an icon from the status area.
	ShellDeleteIcon NotifyIconMessage = 0x00000002
)

// NotifyIconData contains information that the system
// needs to display notifications in the notification area.
type NotifyIconData struct {
	Size            uint32
	HWnd            Hwnd
	UID             uint32
	Flags           uint32
	CallbackMessage uint32
	Icon            Hicon
	Tip             [128]uint16
	State           uint32
	StateMask       uint32
	Info            [256]uint16
	Version         uint32
	InfoTitle       [64]uint16
	InfoFlags       uint32
	GUIDItem        windows.GUID
	BalloonIcon     Hicon
}

// SystrayIcon provides the mechanism for
// interacting with the systray icon.
type SystrayIcon struct {
	// wnd is the handle of the window
	// that receives notifications
	// associated with an icon in the
	// notification area
	wnd Hwnd
}

// NewSystrayIcon creates a new systray icon instance.
func NewSystrayIcon(wnd Hwnd) (*SystrayIcon, error) {
	var data NotifyIconData
	data.Size = uint32(unsafe.Sizeof(data))
	data.Flags = NotifyIconGUIDFlag | NotifyIconMessageFlag
	data.GUIDItem = SystrayIconGUID
	data.HWnd = wnd

	err := ShellNotifyIcon(ShellAddIcon, &data)
	si := &SystrayIcon{wnd: wnd}
	if err != nil {
		return nil, err
	}
	return si, nil
}

// SetIcon sets the tray icon.
func (s *SystrayIcon) SetIcon(icon Hicon) error {
	var data NotifyIconData
	data.Size = uint32(unsafe.Sizeof(data))
	data.Flags = NotifyIconGUIDFlag | NotifyIconIconFlag
	data.GUIDItem = SystrayIconGUID
	data.HWnd = s.wnd
	data.Icon = icon
	return ShellNotifyIcon(ShellModifyIcon, &data)
}

// SetTooltip sets the tray icon tooltip.
func (s *SystrayIcon) SetTooltip(tooltip string) error {
	var data NotifyIconData
	data.Size = uint32(unsafe.Sizeof(data))
	data.Flags = NotifyIconGUIDFlag | NotifyIconTipFlag
	data.GUIDItem = SystrayIconGUID
	data.HWnd = s.wnd
	tip := windows.StringToUTF16(tooltip)
	if len(tip) > 128 {
		tip = tip[:128]
	}
	copy(data.Tip[:], tip)
	return ShellNotifyIcon(ShellModifyIcon, &data)
}

// ShowBalloonNotification renders the balloon notification
// in the taskbar area. The icon is a customized notification
// icon provided by the application that should be used independently
// of the notification area icon. The balloon notification title
// appears in a larger font immediately above the text. The text is a
// string that specifies the text to display in a balloon notification.
// To disable playing the sound when the notification is shown, set the
// `sound` parameter to false. Also, to respect user quiet time and prevent
// displaying balloon notifications, set `quietMode` to true.
func (s *SystrayIcon) ShowBalloonNotification(title string, text string, sound, quietMode bool) error {
	var data NotifyIconData
	data.Size = uint32(unsafe.Sizeof(data))
	data.Flags = NotifyIconGUIDFlag | NotifyIconInfoFlag
	data.InfoFlags = NotifyIconUserFlag | NotifyIconLargeIconFlag
	if !sound {
		data.InfoFlags |= NotifyIconNosoundFlag
	}
	if quietMode {
		data.InfoFlags |= NotifyIconRespectQuietTimeFlag
	}
	data.GUIDItem = SystrayIconGUID
	data.HWnd = s.wnd

	s1, s2 := windows.StringToUTF16(title), windows.StringToUTF16(text)
	if len(s1) > 64 {
		s1 = s1[:64]
	}
	if len(s2) > 256 {
		s2 = s2[:256]
	}
	copy(data.Info[:], s2)
	copy(data.InfoTitle[:], s1)

	return ShellNotifyIcon(ShellModifyIcon, &data)
}

// Delete deletes systray icon and disposes all resources.
func (s *SystrayIcon) Delete() error {
	var data NotifyIconData
	data.Size = uint32(unsafe.Sizeof(data))
	data.Flags = NotifyIconGUIDFlag
	data.GUIDItem = SystrayIconGUID
	data.HWnd = s.wnd
	return ShellNotifyIcon(ShellDeleteIcon, &data)
}

// ShStockIcon receives information used to retrieve a stock shell icon.
type ShStockIcon struct {
	Size          uint32
	Icon          Hicon
	SysImageIndex int32
	IconIndex     int32
	Path          [260]uint16
}

```

`pkg/sys/syscall.go`:

```go
/*
 * Copyright 2021-2022 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package sys

//go:generate go run golang.org/x/sys/windows/mkwinsyscall -output zsyscall_windows.go syscall.go

// Native API Functions
//sys NtQueryObject(handle windows.Handle, objectInfoClass int32, objInfo unsafe.Pointer, objInfoLen uint32, retLen *uint32) (ntstatus error) = ntdll.NtQueryObject
//sys NtQueryMutant(handle windows.Handle, mutantInfoClass int32, mutantInfo unsafe.Pointer, mutantInfoLen uint32, retLen *uint32) (ntstatus error) = ntdll.NtQueryMutant
//sys NtAlpcQueryInformation(handle windows.Handle, alpcInfoClass int32, alpcInfo unsafe.Pointer, alpcInfoLen uint32, retLen *uint32) (ntstatus error) = ntdll.NtAlpcQueryInformation
//sys NtQueryVolumeInformationFile(handle windows.Handle, ioStatusBlock *windows.IO_STATUS_BLOCK, fsInfo uintptr, retLen uint32, fsInfoClass int32) (ntstatus error) = ntdll.NtQueryVolumeInformationFile
//sys RtlNtStatusToDosError(status uint32) (code uint32) = ntdll.RtlNtStatusToDosError
//sys NtCreateSection(section *windows.Handle, desiredAccess uint32, objectAttributes uintptr, maxSize uintptr, protection uint32, allocation uint32, file windows.Handle) (ntstatus error) = ntdll.NtCreateSection
//sys NtMapViewOfSection(section windows.Handle, process windows.Handle, sectionBase uintptr, zeroBits uintptr, commitSize uintptr, offset uintptr, size uintptr, inherit uint32, allocation uint32, protect uint32) (ntstatus error) = ntdll.NtMapViewOfSection
//sys NtUnmapViewOfSection(process windows.Handle, addr uintptr) (ntstatus error) = ntdll.NtUnmapViewOfSection

// Thread Functions
//sys GetProcessIdOfThread(handle windows.Handle) (pid uint32) = kernel32.GetProcessIdOfThread
//sys CreateThread(attributes *windows.SecurityAttributes, stackSize uint, startAddress uintptr, param uintptr, creationFlags uint32, threadID *uint32) (handle windows.Handle) = kernel32.CreateThread
//sys TerminateThread(handle windows.Handle, exitCode uint32) (err error) = kernel32.TerminateThread

// File Functions
//sys pathIsDirectory(path *uint16) (isDirectory bool) = shlwapi.PathIsDirectoryW

// Device Functions
//sys EnumDeviceDrivers(imageBase uintptr, size uint32, needed *uint32) (err error) = psapi.EnumDeviceDrivers
//sys GetDeviceDriverFileName(imageBase uintptr, filename *uint16, size uint32) (n uint32) = psapi.GetDeviceDriverFileNameW

// Windows Terminal Server Functions
//sys WTSQuerySessionInformationA(handle windows.Handle, sessionID uint32, klass uint8, buf **uint16, size *uint32) (err error) = wtsapi32.WTSQuerySessionInformationW
//sys WTSGetActiveConsoleSessionID() (n uint32) = kernel32.WTSGetActiveConsoleSessionId
//sys WTSQueryUserToken(sessionID uint32, token *windows.Token) (ok bool) = wtsapi32.WTSQueryUserToken

// Windows Trust Functions
//sys WinVerifyTrust(handle windows.Handle, action *windows.GUID, data *WintrustData) (ret uint32, err error) [failretval!=0] = wintrust.WinVerifyTrust
//sys CryptCatalogAdminAcquireContext(handle *windows.Handle, subsystem *windows.GUID, hashAlgorithm *uint16, hashPolicy uintptr, flags uint32) (err error) = wintrust.CryptCATAdminAcquireContext2
//sys CryptCatalogAdminReleaseContext(handle windows.Handle, flags int32) (ok bool) = wintrust.CryptCATAdminReleaseContext
//sys CryptCatalogAdminCalcHashFromFileHandle(handle windows.Handle, fd uintptr, size *uint32, hash uintptr, flags uint32) (err error) = wintrust.CryptCATAdminCalcHashFromFileHandle2
//sys CryptCatalogAdminEnumCatalogFromHash(handle windows.Handle, hash uintptr, size uint32, flags uint32, prevCatalog *windows.Handle) (catalog windows.Handle) = wintrust.CryptCATAdminEnumCatalogFromHash
//sys CryptCatalogInfoFromContext(handle windows.Handle, catalog *CatalogInfo, flags uint32) (err error) = wintrust.CryptCATCatalogInfoFromContext
//sys CryptCatalogAdminReleaseCatalogContext(handle windows.Handle, info windows.Handle, flags uint32) (err error) = wintrust.CryptCATAdminReleaseCatalogContext

// Process Status API Functions
//sys GetMappedFileName(handle windows.Handle, addr uintptr, filename *uint16, size uint32) (n uint32) = psapi.GetMappedFileNameW
//sys GetPackageID(handle windows.Handle, length *uint32, buf uintptr) (err error) = kernel32.GetPackageId

// Debug Helper API Functions
//sys SymInitialize(handle windows.Handle, searchPath *uint16, invadeProcess bool) (b bool) = dbghelp.SymInitialize
//sys SymFromAddr(handle windows.Handle, addr uint64, offset *uint64, sym *SymbolInfo) (b bool) = dbghelp.SymFromAddrW
//sys SymSetOptions(opts uint32) (options uint32) = dbghelp.SymSetOptions
//sys SymLoadModule(handle windows.Handle, file windows.Handle, imageName *uint16, moduleName *uint16, baseDLL uint64, sizeDLL uint32, data uintptr, flags uint32) (base uint64) = dbghelp.SymLoadModuleExW
//sys SymUnloadModule(handle windows.Handle, baseDLL uint64) = dbghelp.SymUnloadModule64
//sys SymGetModuleInfo(handle windows.Handle, addr uint64, mod *ModuleInfo) (b bool) = dbghelp.SymGetModuleInfoW64
//sys SymCleanup(handle windows.Handle) (b bool) = dbghelp.SymCleanup
//sys SymEnumLoadedModules(handle windows.Handle, callback uintptr, ctx uintptr) (b bool) = dbghelp.EnumerateLoadedModulesW64

// User interface functions
//sys CreateWindowEx(exStyle uint32, className *uint16, windowName *uint16, style uint32, x int32, y int32, w int32, h int32, parent Hwnd, menu uintptr, instance windows.Handle, param uintptr) (hwnd Hwnd, err error) [failretval==0] = user32.CreateWindowExW
//sys DestroyWindow(hwnd Hwnd) = user32.DestroyWindow
//sys RegisterClass(class *WndClassEx) (err error) [failretval==0] = user32.RegisterClassExW
//sys DefWindowProc(hwnd uintptr, msg uint32, wparam uintptr, lparam uintptr) (result uintptr) = user32.DefWindowProcW
//sys LoadImage(inst windows.Handle, name *uint16, typ uint, cx int, cy int, flags uint) (handle windows.Handle, err error) [failretval==0] = user32.LoadImageW
//sys DestroyIcon(icon Hicon) = user32.DestroyIcon

// Shell functions
//sys ShellNotifyIcon(msg NotifyIconMessage, data *NotifyIconData) (err error) [failretval==0]  = shell32.Shell_NotifyIconW
//sys SHGetStockIconInfo(id int32, flags uint32, icon *ShStockIcon) (err error) [failretval!=0] = shell32.SHGetStockIconInfo
//sys FreeConsole() = kernel32.FreeConsole

// Memory functions
//sys QueryWorkingSet(handle windows.Handle, ws *MemoryWorkingSetExInformation, size uint32) (err error) = psapi.QueryWorkingSetEx

```

`pkg/sys/trust.go`:

```go
/*
 * Copyright 2021-2022 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package sys

import (
	"encoding/hex"
	"fmt"
	"github.com/rabbitstack/fibratus/pkg/util/bytes"
	"github.com/rabbitstack/fibratus/pkg/util/format"
	"github.com/rabbitstack/fibratus/pkg/util/multierror"
	log "github.com/sirupsen/logrus"
	"go.mozilla.org/pkcs7"
	"golang.org/x/sys/windows"
	"io"
	"os"
	"reflect"
	"runtime"
	"sync"
	"time"
	"unsafe"
)

const (
	// WtdUIAll display all UI interface.
	WtdUIAll = 1
	// WtdUINone display no UI.
	WtdUINone = 2
	// WtdUINoBad do not display any negative UI
	WtdUINoBad = 3
	// WtdUINoGood do not display any positive UI
	WtdUINoGood = 4
	// WtdRevokeNone dictates that no additional revocation checking
	// will be done when the WtdRevokeNone flag is used in conjunction
	// with the HTTPSPROV_ACTION value set in the action parameter of the
	// WinVerifyTrust function. To ensure the WinVerifyTrust function does
	// not attempt any network retrieval when verifying code signatures,
	// WTD_CACHE_ONLY_URL_RETRIEVAL must be set in the ProviderFlags parameter.
	WtdRevokeNone = 0
	// WtdChoiceFile specifies the file object is verified by the trust provider.
	WtdChoiceFile = 1
	// WtdChoiceCatalog specifies the file object is verified through catalog by the trust provider.
	WtdChoiceCatalog = 2
	// WtdStateActionVerify verifies the trust of the object (typically a file)
	// that is specified by the UnionChoice member. The StateData member will
	// receive a handle to the state data. This handle must be freed by specifying
	// the WtdStateActionClose action in a subsequent call.
	WtdStateActionVerify = 0x00000001
	// WtdStateActionClose frees the StateData member previously allocated with
	// the WtdStateActionVerify action. This action must be specified for every use
	// of the WtdStateActionVerify action.
	WtdStateActionClose = 0x00000002
	// WtdSaferFlag is the trust provider flag
	WtdSaferFlag = 0x100
)

// WintrustActionGenericVerifyV2 is the action that indicates the file or object should be verified by using the Authenticode policy provider.
var WintrustActionGenericVerifyV2 = windows.GUID{Data1: 0xaac56b, Data2: 0xcd44, Data3: 0x11d0, Data4: [8]byte{0x8c, 0xc2, 0x0, 0xc0, 0x4f, 0xc2, 0x95, 0xee}}

// WintrustData structure is used when calling WinVerifyTrust
// to pass necessary information into the trust providers.
type WintrustData struct {
	Size                          uint32
	PolicyCallbackBuffer          uintptr
	SubjectInterfacePackageBuffer uintptr
	UIChoice                      uint32
	RevocationChecks              uint32
	UnionChoice                   uint32
	Union                         uintptr // C union
	StateAction                   uint32
	StateData                     windows.Handle
	URLReference                  uintptr
	ProviderFlags                 uint32
	UIContext                     uint32
	SignatureSettings             *WintrustSignatureSettings
}

// NewWintrustData creates a new instance of WintrustData prepared
// to verify file or catalog trust.
func NewWintrustData(choice uint32) *WintrustData {
	return &WintrustData{
		Size:             uint32(unsafe.Sizeof(WintrustData{})),
		UnionChoice:      choice,
		UIChoice:         WtdUINone,
		RevocationChecks: WtdRevokeNone,
		StateAction:      WtdStateActionVerify,
		ProviderFlags:    WtdSaferFlag,
	}
}

// VerifyFile verifies the provided file trust. The trust provider
// should perform the verification action without the user's assistance.
// This is achieved by providing INVALID_HANDLE_VALUE as a first parameter
// in the WinVerifyTrust call.
func (t *WintrustData) VerifyFile(filename string) bool {
	fileinfo := &WintrustFileInfo{
		Size:     uint32(unsafe.Sizeof(WintrustFileInfo{})),
		FilePath: windows.StringToUTF16Ptr(filename),
	}
	t.Union = uintptr(unsafe.Pointer(fileinfo))
	status, err := WinVerifyTrust(windows.InvalidHandle, &WintrustActionGenericVerifyV2, t)
	if status != 0 || err != nil {
		return false
	}
	return true
}

// VerifyCatalog verifies the provided catalog file.
func (t *WintrustData) VerifyCatalog(
	fd uintptr,
	filename string,
	catalogAdmin windows.Handle,
	catalog CatalogInfo,
	hash []byte,
	hasSize uint32,
) bool {
	// tag is a hexadecimal representation of the hash of the file
	tag := windows.StringToUTF16Ptr(format.BytesToHex(hash[:hasSize]))
	catinfo := &WintrustCatalogInfo{
		Size:            uint32(unsafe.Sizeof(WintrustCatalogInfo{})),
		CatalogFilePath: uintptr(unsafe.Pointer(&catalog.Name[0])),
		MemberFilePath:  uintptr(unsafe.Pointer(windows.StringToUTF16Ptr(filename))),
		MemberFile:      windows.Handle(fd),
		MemberTag:       uintptr(unsafe.Pointer(tag)),
		FileHash:        uintptr(unsafe.Pointer(&hash[0])),
		FileHashSize:    hasSize,
		CatalogAdmin:    catalogAdmin,
	}
	t.Union = uintptr(unsafe.Pointer(catinfo))
	status, err := WinVerifyTrust(windows.InvalidHandle, &WintrustActionGenericVerifyV2, t)
	if status != 0 || err != nil {
		return false
	}
	return true
}

// Close disposes state data by specifying the corresponding action
func (t *WintrustData) Close() error {
	t.StateAction = WtdStateActionClose
	status, err := WinVerifyTrust(windows.InvalidHandle, &WintrustActionGenericVerifyV2, t)
	if err != nil {
		return err
	}
	if status != 0 {
		return windows.GetLastError()
	}
	return nil
}

// WintrustSignatureSettings structure can be used to specify the signatures on a file.
type WintrustSignatureSettings struct {
	Size                uint32
	Index               uint32
	Flags               uint32
	SecondarySignatures uint32
	SignatureIndex      uint32
	CryptoPolicy        uintptr // pointer to CERT_STRONG_SIGN_PARA structure
}

// WintrustFileInfo structure is used when calling WinVerifyTrust to verify an individual file.
type WintrustFileInfo struct {
	Size         uint32
	FilePath     *uint16 // file path to be verified
	FileHandle   uintptr // file handle to open file
	KnownSubject *windows.GUID
}

// WintrustCatalogInfo structure is used when calling WinVerifyTrust to verify a member of a Microsoft catalog.
type WintrustCatalogInfo struct {
	Size            uint32
	CatalogVersion  uint32
	CatalogFilePath uintptr
	MemberTag       uintptr
	MemberFilePath  uintptr
	MemberFile      windows.Handle
	FileHash        uintptr
	FileHashSize    uint32
	CatalogContext  uintptr
	CatalogAdmin    windows.Handle
}

// CatalogInfo structure contains the name of a catalog file. This structure is used by
// the CryptCatalogInfoFromContext function.
type CatalogInfo struct {
	Size uint32
	Name [1024]byte
}

// CatalogFile returns the full path to the catalog file.
func (c CatalogInfo) CatalogFile() string {
	p := (*[unsafe.Sizeof(c.Name) / 2]uint16)(unsafe.Pointer(&c.Name[0]))
	return windows.UTF16ToString(p[:])
}

var isWintrustDLLFound bool
var once sync.Once

// IsWintrustFound indicates if the Wintrust DLL is present in the system.
func IsWintrustFound() bool {
	once.Do(func() {
		isWintrustDLLFound = modwintrust.Load() == nil
		if !isWintrustDLLFound {
			log.Warn("unable to find wintrust.dll library. This will lead to " +
				"PE objects signature verification to be skipped possibly " +
				"causing false positive samples in detection rules relying on " +
				"image signature filter fields")
		}
	})
	return isWintrustDLLFound
}

// Cat represents the catalog that acts as a digital signature
// for an arbitrary collection of files. A catalog file contains
// a collection of cryptographic hashes, or thumbprints. Each thumbprint
// corresponds to a file that is included in the collection.
type Cat struct {
	admin       windows.Handle
	catalog     windows.Handle
	file        *os.File
	catalogInfo CatalogInfo

	hash []byte
	size uint32
}

const hashSize uint32 = 100

// NewCatalog creates an instance of the catalog with default hash size.
func NewCatalog() Cat {
	return Cat{size: hashSize, hash: make([]byte, hashSize)}
}

// Open opens the catalog and acquires the hash for the given file. If the
// file is catalog-signed, a valid catalog handle is stored internally.
func (c *Cat) Open(filename string) error {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()
	// acquire handle to a catalog administrator context
	err := CryptCatalogAdminAcquireContext(&c.admin, nil, nil, 0, 0)
	if err != nil {
		return err
	}
	// calculate file hash
	c.file, err = os.Open(filename)
	if err != nil {
		return err
	}
	err = CryptCatalogAdminCalcHashFromFileHandle(
		c.admin,
		c.file.Fd(),
		&c.size,
		uintptr(unsafe.Pointer(&c.hash[0])), 0,
	)
	if err != nil {
		return err
	}
	// enumerate catalogs that contain the calculated hash.
	// If no catalogs are found, we can deduce the file is
	// not catalog signed
	c.catalog = CryptCatalogAdminEnumCatalogFromHash(
		c.admin,
		uintptr(unsafe.Pointer(&c.hash[0])),
		c.size, 0, nil,
	)
	c.catalogInfo.Size = uint32(unsafe.Sizeof(c.catalogInfo))
	err = CryptCatalogInfoFromContext(c.catalog, &c.catalogInfo, 0)
	if err != nil {
		return err
	}
	return nil
}

// IsCatalogSigned determines if the file is catalog-signed.
func (c *Cat) IsCatalogSigned() bool {
	return c.catalog != 0 && c.catalogInfo.CatalogFile() != ""
}

// Verify verifies the signature of the given file against the catalog.
func (c *Cat) Verify(filename string) bool {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()
	trust := NewWintrustData(WtdChoiceCatalog)
	defer trust.Close()
	if c.file == nil {
		panic("catalog is not opened")
	}
	return trust.VerifyCatalog(c.file.Fd(), filename, c.admin, c.catalogInfo, c.hash, c.size)
}

// ParseCertificate parses the catalog certificate.
func (c *Cat) ParseCertificate() (*Cert, error) {
	f, err := os.Open(c.catalogInfo.CatalogFile())
	if err != nil {
		return nil, err
	}
	defer f.Close()
	crt, err := io.ReadAll(f)
	if err != nil {
		return nil, err
	}
	pkcs, err := pkcs7.Parse(crt)
	if err != nil {
		return nil, err
	}

	certInfo := &Cert{}
	serialNumber := pkcs.Signers[0].IssuerAndSerialNumber.SerialNumber
	for _, cert := range pkcs.Certificates {
		if !reflect.DeepEqual(cert.SerialNumber, serialNumber) {
			continue
		}

		certInfo.SerialNumber = hex.EncodeToString(cert.SerialNumber.Bytes())

		certInfo.NotAfter = cert.NotAfter
		certInfo.NotBefore = cert.NotBefore

		// issuer information
		if len(cert.Issuer.Country) > 0 {
			certInfo.Issuer = cert.Issuer.Country[0]
		}

		if len(cert.Issuer.Province) > 0 {
			certInfo.Issuer += ", " + cert.Issuer.Province[0]
		}

		if len(cert.Issuer.Locality) > 0 {
			certInfo.Issuer += ", " + cert.Issuer.Locality[0]
		}

		certInfo.Issuer += ", " + cert.Issuer.CommonName

		// subject information
		if len(cert.Subject.Country) > 0 {
			certInfo.Subject = cert.Subject.Country[0]
		}

		if len(cert.Subject.Province) > 0 {
			certInfo.Subject += ", " + cert.Subject.Province[0]
		}

		if len(cert.Subject.Locality) > 0 {
			certInfo.Subject += ", " + cert.Subject.Locality[0]
		}

		if len(cert.Subject.Organization) > 0 {
			certInfo.Subject += ", " + cert.Subject.Organization[0]
		}

		certInfo.Subject += ", " + cert.Subject.CommonName

		break
	}
	return certInfo, nil
}

func (c *Cat) Close() error {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()
	if c.admin != 0 {
		defer CryptCatalogAdminReleaseContext(c.admin, 0)
	}
	var err error
	if c.admin != 0 && c.catalog != 0 {
		err = CryptCatalogAdminReleaseCatalogContext(c.admin, c.catalog, 0)
	}
	if c.file != nil {
		return multierror.Wrap(c.file.Close(), err)
	}
	return err
}

// Cert represents certificate information embedded in the PE or catalog.
type Cert struct {
	// NotBefore specifies the certificate won't be valid before this timestamp.
	NotBefore time.Time `json:"not_before"`

	// NotAfter specifies the certificate won't be valid after this timestamp.
	NotAfter time.Time `json:"not_after"`

	// Issuer represents the certificate authority (CA) that charges customers to issue
	// certificates for them.
	Issuer string `json:"issuer"`

	// Subject indicates the subject of the certificate is the entity its public key is associated
	// with (i.e. the "owner" of the certificate).
	Subject string `json:"subject"`

	// SerialNumber represents the serial number MUST be a positive integer assigned
	// by the CA to each certificate. It MUST be unique for each certificate issued by
	// a given CA (i.e., the issuer name and serial number identify a unique certificate).
	// CAs MUST force the serialNumber to be a non-negative integer.
	// For convenience, we convert the big int to string.
	SerialNumber string `json:"serial_number"`
}

// Marshal writes certificate info into a raw buffer.
func (c *Cert) Marshal() []byte {
	b := make([]byte, 0)

	before := make([]byte, 0)
	before = c.NotBefore.AppendFormat(before, time.RFC3339Nano)
	b = append(b, bytes.WriteUint16(uint16(len(before)))...)
	b = append(b, before...)

	after := make([]byte, 0)
	after = c.NotAfter.AppendFormat(after, time.RFC3339Nano)
	b = append(b, bytes.WriteUint16(uint16(len(after)))...)
	b = append(b, after...)

	b = append(b, bytes.WriteUint16(uint16(len(c.SerialNumber)))...)
	b = append(b, c.SerialNumber...)
	b = append(b, bytes.WriteUint16(uint16(len(c.Subject)))...)
	b = append(b, c.Subject...)
	b = append(b, bytes.WriteUint16(uint16(len(c.Issuer)))...)
	b = append(b, c.Issuer...)

	return b
}

// Unmarshal decodes cert info from the raw buffer. This method
// assumes the certificate structure size was already read.
func (c *Cert) Unmarshal(b []byte, offset, certSize uint32) error {
	if certSize > uint32(len(b)) {
		return fmt.Errorf("invalid PE cert size. Got %d but max buffer size is %d", certSize, len(b))
	}

	// read not before
	l := bytes.ReadUint16(b[26+offset:])
	buf := b[28+offset:]
	offset += uint32(l)
	if len(buf) > 0 {
		c.NotBefore, _ = time.Parse(time.RFC3339Nano, string((*[1<<30 - 1]byte)(unsafe.Pointer(&buf[0]))[:l:l]))
	}

	// read not after
	l = bytes.ReadUint16(b[28+offset:])
	buf = b[30+offset:]
	offset += uint32(l)
	if len(buf) > 0 {
		c.NotAfter, _ = time.Parse(time.RFC3339Nano, string((*[1<<30 - 1]byte)(unsafe.Pointer(&buf[0]))[:l:l]))
	}

	// read serial
	l = bytes.ReadUint16(b[30+offset:])
	buf = b[32+offset:]
	offset += uint32(l)
	c.SerialNumber = string((*[1<<30 - 1]byte)(unsafe.Pointer(&buf[0]))[:l:l])

	// read subject
	l = bytes.ReadUint16(b[32+offset:])
	buf = b[34+offset:]
	offset += uint32(l)
	c.Subject = string((*[1<<30 - 1]byte)(unsafe.Pointer(&buf[0]))[:l:l])

	// read issuer
	l = bytes.ReadUint16(b[34+offset:])
	buf = b[36+offset:]
	c.Issuer = string((*[1<<30 - 1]byte)(unsafe.Pointer(&buf[0]))[:l:l])

	return nil
}

```

`pkg/sys/trust_test.go`:

```go
/*
 * Copyright 2021-2022 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package sys

import (
	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/require"
	"os"
	"path/filepath"
	"testing"
)

func TestIsCatalogSigned(t *testing.T) {
	executable, err := os.Executable()
	require.NoError(t, err)

	var tests = []struct {
		filename       string
		want           bool
		hasCertificate bool
		issuer         string
		subject        string
	}{
		{
			executable,
			false,
			false,
			"",
			"",
		},
		{
			filepath.Join(os.Getenv("windir"), "notepad.exe"),
			true,
			true,
			"US, Washington, Redmond, Microsoft Windows Production PCA 2011",
			"US, Washington, Redmond, Microsoft Corporation, Microsoft Windows",
		},
	}

	for _, tt := range tests {
		t.Run(tt.filename, func(t *testing.T) {
			c := NewCatalog()
			err := c.Open(tt.filename)
			defer c.Close()
			assert.Equal(t, tt.want, err == nil && c.IsCatalogSigned())
			cert, err := c.ParseCertificate()
			assert.True(t, tt.hasCertificate == (cert != nil))
			if cert != nil {
				require.NoError(t, err)
				assert.Equal(t, tt.subject, cert.Subject)
				assert.Equal(t, tt.issuer, cert.Issuer)
			}
		})
	}
}

```

`pkg/sys/util.go`:

```go
/*
 * Copyright 2021-2022 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package sys

import "golang.org/x/sys/windows/registry"

// IsInSandbox indicates if the process is running inside an
// isolated environment such as Windows Containers or Windows
// Sandbox.
func IsInSandbox() bool {
	key, err := registry.OpenKey(registry.LOCAL_MACHINE, `SYSTEM\CurrentControlSet\Control`, registry.QUERY_VALUE)
	if err != nil {
		return false
	}
	defer key.Close()
	v, _, err := key.GetIntegerValue("ContainerType")

	return err == nil && v > 0
}

```

`pkg/sys/window.go`:

```go
/*
 * Copyright 2021-2022 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package sys

import "golang.org/x/sys/windows"

// Hwnd defines the window handle type
type Hwnd uintptr

// InvalidHwnd designates an invalid window handle
const InvalidHwnd = 0

// WmClose is the message sent to the window procedure
// when the application is about to shut down
const WmClose = 0x10

// Hicon defines the icon handle type
type Hicon uintptr

// Destroy destroys the window.
func (w Hwnd) Destroy() {
	DestroyWindow(w)
}

// IsValid indicates if the window handle is valid.
func (w Hwnd) IsValid() bool { return w != 0 }

// Destroy destroys an icon and frees any memory the icon occupied.
func (i Hicon) Destroy() {
	DestroyIcon(i)
}

// Atom is an opaque data type. It can be
// used to represent the window class being
// registered with RegisterClass API function
type Atom uint16

// WndClassEx contains window class information.
type WndClassEx struct {
	Size       uint32
	Style      uint32
	WndProc    uintptr
	ClsExtra   int32
	WndExtra   int32
	Instance   windows.Handle
	Icon       uintptr
	Cursor     uintptr
	Background uintptr
	MenuName   *uint16
	ClassName  *uint16
	IconSm     uintptr
}

const (
	// WindowStyleOverlapped window is an overlapped window.
	// An overlapped window has a title bar and a border.
	WindowStyleOverlapped = 0x00000000

	// CwUseDefault  instructs the system selects the default
	// position for the window's upper-left corner.
	CwUseDefault = ^0x7fffffff

	// LoadResourceDefaultSize uses the width or height specified
	// by the system metric values for cursors or icons.
	LoadResourceDefaultSize = 0x00000040
	// LoadResourceFromFile loads the standalone image from the file
	// specified by name (icon, cursor, or bitmap file).
	LoadResourceFromFile = 0x00000010
)

```

`pkg/sys/wts.go`:

```go
/*
 * Copyright 2021-2022 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package sys

import (
	"errors"
	"golang.org/x/sys/windows"
	"unsafe"
)

// ErrNoSession signals that the active Windows Terminal Session is not available
var ErrNoSession = errors.New("no active Windows Terminal Session")

// WTSUserName is the WTS class that returns a null-terminated string
// containing the name of the user associated with the active session.
const WTSUserName = 5

// WTS contains information about the current Windows Terminal Session.
type WTS struct {
	sessionID uint32
}

// LookupActiveWTS finds the active Windows Terminal Session.
func LookupActiveWTS() (*WTS, error) {
	var sess *windows.WTS_SESSION_INFO
	var count uint32
	err := windows.WTSEnumerateSessions(0, 0, 1, &sess, &count)
	if err != nil {
		return nil, err
	}
	sessions := unsafe.Slice(sess, count)
	defer windows.WTSFreeMemory(uintptr(unsafe.Pointer(sess)))
	for _, ses := range sessions {
		if ses.State == windows.WTSActive || ses.State == windows.WTSConnected {
			wts := &WTS{sessionID: ses.SessionID}
			return wts, nil
		}
	}
	return nil, ErrNoSession
}

// Username returns the name of the currently logged-on user.
func (w *WTS) Username() (string, error) {
	var size uint32
	var user *uint16
	err := WTSQuerySessionInformationA(0, w.sessionID, WTSUserName, &user, &size)
	if err != nil {
		return "", err
	}
	defer windows.WTSFreeMemory(uintptr(unsafe.Pointer(user)))
	return windows.UTF16PtrToString(user), nil
}

// SID returns the SID (Security Identifier) of the currently logged-on user.
func (w *WTS) SID() (*windows.SID, error) {
	username, err := w.Username()
	if err != nil {
		return nil, err
	}
	sid, _, _, err := windows.LookupSID("", username)
	if err != nil {
		return nil, err
	}
	return sid, nil
}

```

`pkg/sys/zsyscall_windows.go`:

```go
// Code generated by 'go generate'; DO NOT EDIT.

package sys

import (
	"syscall"
	"unsafe"

	"golang.org/x/sys/windows"
)

var _ unsafe.Pointer

// Do the interface allocations only once for common
// Errno values.
const (
	errnoERROR_IO_PENDING = 997
)

var (
	errERROR_IO_PENDING error = syscall.Errno(errnoERROR_IO_PENDING)
	errERROR_EINVAL     error = syscall.EINVAL
)

// errnoErr returns common boxed Errno values, to prevent
// allocations at runtime.
func errnoErr(e syscall.Errno) error {
	switch e {
	case 0:
		return errERROR_EINVAL
	case errnoERROR_IO_PENDING:
		return errERROR_IO_PENDING
	}
	// TODO: add more here, after collecting data on the common
	// error values see on Windows. (perhaps when running
	// all.bat?)
	return e
}

var (
	moddbghelp  = windows.NewLazySystemDLL("dbghelp.dll")
	modkernel32 = windows.NewLazySystemDLL("kernel32.dll")
	modntdll    = windows.NewLazySystemDLL("ntdll.dll")
	modpsapi    = windows.NewLazySystemDLL("psapi.dll")
	modshell32  = windows.NewLazySystemDLL("shell32.dll")
	modshlwapi  = windows.NewLazySystemDLL("shlwapi.dll")
	moduser32   = windows.NewLazySystemDLL("user32.dll")
	modwintrust = windows.NewLazySystemDLL("wintrust.dll")
	modwtsapi32 = windows.NewLazySystemDLL("wtsapi32.dll")

	procEnumerateLoadedModulesW64            = moddbghelp.NewProc("EnumerateLoadedModulesW64")
	procSymCleanup                           = moddbghelp.NewProc("SymCleanup")
	procSymFromAddrW                         = moddbghelp.NewProc("SymFromAddrW")
	procSymGetModuleInfoW64                  = moddbghelp.NewProc("SymGetModuleInfoW64")
	procSymInitialize                        = moddbghelp.NewProc("SymInitialize")
	procSymLoadModuleExW                     = moddbghelp.NewProc("SymLoadModuleExW")
	procSymSetOptions                        = moddbghelp.NewProc("SymSetOptions")
	procSymUnloadModule64                    = moddbghelp.NewProc("SymUnloadModule64")
	procCreateThread                         = modkernel32.NewProc("CreateThread")
	procFreeConsole                          = modkernel32.NewProc("FreeConsole")
	procGetPackageId                         = modkernel32.NewProc("GetPackageId")
	procGetProcessIdOfThread                 = modkernel32.NewProc("GetProcessIdOfThread")
	procTerminateThread                      = modkernel32.NewProc("TerminateThread")
	procWTSGetActiveConsoleSessionId         = modkernel32.NewProc("WTSGetActiveConsoleSessionId")
	procNtAlpcQueryInformation               = modntdll.NewProc("NtAlpcQueryInformation")
	procNtCreateSection                      = modntdll.NewProc("NtCreateSection")
	procNtMapViewOfSection                   = modntdll.NewProc("NtMapViewOfSection")
	procNtQueryMutant                        = modntdll.NewProc("NtQueryMutant")
	procNtQueryObject                        = modntdll.NewProc("NtQueryObject")
	procNtQueryVolumeInformationFile         = modntdll.NewProc("NtQueryVolumeInformationFile")
	procNtUnmapViewOfSection                 = modntdll.NewProc("NtUnmapViewOfSection")
	procRtlNtStatusToDosError                = modntdll.NewProc("RtlNtStatusToDosError")
	procEnumDeviceDrivers                    = modpsapi.NewProc("EnumDeviceDrivers")
	procGetDeviceDriverFileNameW             = modpsapi.NewProc("GetDeviceDriverFileNameW")
	procGetMappedFileNameW                   = modpsapi.NewProc("GetMappedFileNameW")
	procQueryWorkingSetEx                    = modpsapi.NewProc("QueryWorkingSetEx")
	procSHGetStockIconInfo                   = modshell32.NewProc("SHGetStockIconInfo")
	procShell_NotifyIconW                    = modshell32.NewProc("Shell_NotifyIconW")
	procPathIsDirectoryW                     = modshlwapi.NewProc("PathIsDirectoryW")
	procCreateWindowExW                      = moduser32.NewProc("CreateWindowExW")
	procDefWindowProcW                       = moduser32.NewProc("DefWindowProcW")
	procDestroyIcon                          = moduser32.NewProc("DestroyIcon")
	procDestroyWindow                        = moduser32.NewProc("DestroyWindow")
	procLoadImageW                           = moduser32.NewProc("LoadImageW")
	procRegisterClassExW                     = moduser32.NewProc("RegisterClassExW")
	procCryptCATAdminAcquireContext2         = modwintrust.NewProc("CryptCATAdminAcquireContext2")
	procCryptCATAdminCalcHashFromFileHandle2 = modwintrust.NewProc("CryptCATAdminCalcHashFromFileHandle2")
	procCryptCATAdminEnumCatalogFromHash     = modwintrust.NewProc("CryptCATAdminEnumCatalogFromHash")
	procCryptCATAdminReleaseCatalogContext   = modwintrust.NewProc("CryptCATAdminReleaseCatalogContext")
	procCryptCATAdminReleaseContext          = modwintrust.NewProc("CryptCATAdminReleaseContext")
	procCryptCATCatalogInfoFromContext       = modwintrust.NewProc("CryptCATCatalogInfoFromContext")
	procWinVerifyTrust                       = modwintrust.NewProc("WinVerifyTrust")
	procWTSQuerySessionInformationW          = modwtsapi32.NewProc("WTSQuerySessionInformationW")
	procWTSQueryUserToken                    = modwtsapi32.NewProc("WTSQueryUserToken")
)

func SymEnumLoadedModules(handle windows.Handle, callback uintptr, ctx uintptr) (b bool) {
	r0, _, _ := syscall.Syscall(procEnumerateLoadedModulesW64.Addr(), 3, uintptr(handle), uintptr(callback), uintptr(ctx))
	b = r0 != 0
	return
}

func SymCleanup(handle windows.Handle) (b bool) {
	r0, _, _ := syscall.Syscall(procSymCleanup.Addr(), 1, uintptr(handle), 0, 0)
	b = r0 != 0
	return
}

func SymFromAddr(handle windows.Handle, addr uint64, offset *uint64, sym *SymbolInfo) (b bool) {
	r0, _, _ := syscall.Syscall6(procSymFromAddrW.Addr(), 4, uintptr(handle), uintptr(addr), uintptr(unsafe.Pointer(offset)), uintptr(unsafe.Pointer(sym)), 0, 0)
	b = r0 != 0
	return
}

func SymGetModuleInfo(handle windows.Handle, addr uint64, mod *ModuleInfo) (b bool) {
	r0, _, _ := syscall.Syscall(procSymGetModuleInfoW64.Addr(), 3, uintptr(handle), uintptr(addr), uintptr(unsafe.Pointer(mod)))
	b = r0 != 0
	return
}

func SymInitialize(handle windows.Handle, searchPath *uint16, invadeProcess bool) (b bool) {
	var _p0 uint32
	if invadeProcess {
		_p0 = 1
	}
	r0, _, _ := syscall.Syscall(procSymInitialize.Addr(), 3, uintptr(handle), uintptr(unsafe.Pointer(searchPath)), uintptr(_p0))
	b = r0 != 0
	return
}

func SymLoadModule(handle windows.Handle, file windows.Handle, imageName *uint16, moduleName *uint16, baseDLL uint64, sizeDLL uint32, data uintptr, flags uint32) (base uint64) {
	r0, _, _ := syscall.Syscall9(procSymLoadModuleExW.Addr(), 8, uintptr(handle), uintptr(file), uintptr(unsafe.Pointer(imageName)), uintptr(unsafe.Pointer(moduleName)), uintptr(baseDLL), uintptr(sizeDLL), uintptr(data), uintptr(flags), 0)
	base = uint64(r0)
	return
}

func SymSetOptions(opts uint32) (options uint32) {
	r0, _, _ := syscall.Syscall(procSymSetOptions.Addr(), 1, uintptr(opts), 0, 0)
	options = uint32(r0)
	return
}

func SymUnloadModule(handle windows.Handle, baseDLL uint64) {
	syscall.Syscall(procSymUnloadModule64.Addr(), 2, uintptr(handle), uintptr(baseDLL), 0)
	return
}

func CreateThread(attributes *windows.SecurityAttributes, stackSize uint, startAddress uintptr, param uintptr, creationFlags uint32, threadID *uint32) (handle windows.Handle) {
	r0, _, _ := syscall.Syscall6(procCreateThread.Addr(), 6, uintptr(unsafe.Pointer(attributes)), uintptr(stackSize), uintptr(startAddress), uintptr(param), uintptr(creationFlags), uintptr(unsafe.Pointer(threadID)))
	handle = windows.Handle(r0)
	return
}

func FreeConsole() {
	syscall.Syscall(procFreeConsole.Addr(), 0, 0, 0, 0)
	return
}

func GetPackageID(handle windows.Handle, length *uint32, buf uintptr) (err error) {
	r1, _, e1 := syscall.Syscall(procGetPackageId.Addr(), 3, uintptr(handle), uintptr(unsafe.Pointer(length)), uintptr(buf))
	if r1 == 0 {
		err = errnoErr(e1)
	}
	return
}

func GetProcessIdOfThread(handle windows.Handle) (pid uint32) {
	r0, _, _ := syscall.Syscall(procGetProcessIdOfThread.Addr(), 1, uintptr(handle), 0, 0)
	pid = uint32(r0)
	return
}

func TerminateThread(handle windows.Handle, exitCode uint32) (err error) {
	r1, _, e1 := syscall.Syscall(procTerminateThread.Addr(), 2, uintptr(handle), uintptr(exitCode), 0)
	if r1 == 0 {
		err = errnoErr(e1)
	}
	return
}

func WTSGetActiveConsoleSessionID() (n uint32) {
	r0, _, _ := syscall.Syscall(procWTSGetActiveConsoleSessionId.Addr(), 0, 0, 0, 0)
	n = uint32(r0)
	return
}

func NtAlpcQueryInformation(handle windows.Handle, alpcInfoClass int32, alpcInfo unsafe.Pointer, alpcInfoLen uint32, retLen *uint32) (ntstatus error) {
	r0, _, _ := syscall.Syscall6(procNtAlpcQueryInformation.Addr(), 5, uintptr(handle), uintptr(alpcInfoClass), uintptr(alpcInfo), uintptr(alpcInfoLen), uintptr(unsafe.Pointer(retLen)), 0)
	if r0 != 0 {
		ntstatus = windows.NTStatus(r0)
	}
	return
}

func NtCreateSection(section *windows.Handle, desiredAccess uint32, objectAttributes uintptr, maxSize uintptr, protection uint32, allocation uint32, file windows.Handle) (ntstatus error) {
	r0, _, _ := syscall.Syscall9(procNtCreateSection.Addr(), 7, uintptr(unsafe.Pointer(section)), uintptr(desiredAccess), uintptr(objectAttributes), uintptr(maxSize), uintptr(protection), uintptr(allocation), uintptr(file), 0, 0)
	if r0 != 0 {
		ntstatus = windows.NTStatus(r0)
	}
	return
}

func NtMapViewOfSection(section windows.Handle, process windows.Handle, sectionBase uintptr, zeroBits uintptr, commitSize uintptr, offset uintptr, size uintptr, inherit uint32, allocation uint32, protect uint32) (ntstatus error) {
	r0, _, _ := syscall.Syscall12(procNtMapViewOfSection.Addr(), 10, uintptr(section), uintptr(process), uintptr(sectionBase), uintptr(zeroBits), uintptr(commitSize), uintptr(offset), uintptr(size), uintptr(inherit), uintptr(allocation), uintptr(protect), 0, 0)
	if r0 != 0 {
		ntstatus = windows.NTStatus(r0)
	}
	return
}

func NtQueryMutant(handle windows.Handle, mutantInfoClass int32, mutantInfo unsafe.Pointer, mutantInfoLen uint32, retLen *uint32) (ntstatus error) {
	r0, _, _ := syscall.Syscall6(procNtQueryMutant.Addr(), 5, uintptr(handle), uintptr(mutantInfoClass), uintptr(mutantInfo), uintptr(mutantInfoLen), uintptr(unsafe.Pointer(retLen)), 0)
	if r0 != 0 {
		ntstatus = windows.NTStatus(r0)
	}
	return
}

func NtQueryObject(handle windows.Handle, objectInfoClass int32, objInfo unsafe.Pointer, objInfoLen uint32, retLen *uint32) (ntstatus error) {
	r0, _, _ := syscall.Syscall6(procNtQueryObject.Addr(), 5, uintptr(handle), uintptr(objectInfoClass), uintptr(objInfo), uintptr(objInfoLen), uintptr(unsafe.Pointer(retLen)), 0)
	if r0 != 0 {
		ntstatus = windows.NTStatus(r0)
	}
	return
}

func NtQueryVolumeInformationFile(handle windows.Handle, ioStatusBlock *windows.IO_STATUS_BLOCK, fsInfo uintptr, retLen uint32, fsInfoClass int32) (ntstatus error) {
	r0, _, _ := syscall.Syscall6(procNtQueryVolumeInformationFile.Addr(), 5, uintptr(handle), uintptr(unsafe.Pointer(ioStatusBlock)), uintptr(fsInfo), uintptr(retLen), uintptr(fsInfoClass), 0)
	if r0 != 0 {
		ntstatus = windows.NTStatus(r0)
	}
	return
}

func NtUnmapViewOfSection(process windows.Handle, addr uintptr) (ntstatus error) {
	r0, _, _ := syscall.Syscall(procNtUnmapViewOfSection.Addr(), 2, uintptr(process), uintptr(addr), 0)
	if r0 != 0 {
		ntstatus = windows.NTStatus(r0)
	}
	return
}

func RtlNtStatusToDosError(status uint32) (code uint32) {
	r0, _, _ := syscall.Syscall(procRtlNtStatusToDosError.Addr(), 1, uintptr(status), 0, 0)
	code = uint32(r0)
	return
}

func EnumDeviceDrivers(imageBase uintptr, size uint32, needed *uint32) (err error) {
	r1, _, e1 := syscall.Syscall(procEnumDeviceDrivers.Addr(), 3, uintptr(imageBase), uintptr(size), uintptr(unsafe.Pointer(needed)))
	if r1 == 0 {
		err = errnoErr(e1)
	}
	return
}

func GetDeviceDriverFileName(imageBase uintptr, filename *uint16, size uint32) (n uint32) {
	r0, _, _ := syscall.Syscall(procGetDeviceDriverFileNameW.Addr(), 3, uintptr(imageBase), uintptr(unsafe.Pointer(filename)), uintptr(size))
	n = uint32(r0)
	return
}

func GetMappedFileName(handle windows.Handle, addr uintptr, filename *uint16, size uint32) (n uint32) {
	r0, _, _ := syscall.Syscall6(procGetMappedFileNameW.Addr(), 4, uintptr(handle), uintptr(addr), uintptr(unsafe.Pointer(filename)), uintptr(size), 0, 0)
	n = uint32(r0)
	return
}

func QueryWorkingSet(handle windows.Handle, ws *MemoryWorkingSetExInformation, size uint32) (err error) {
	r1, _, e1 := syscall.Syscall(procQueryWorkingSetEx.Addr(), 3, uintptr(handle), uintptr(unsafe.Pointer(ws)), uintptr(size))
	if r1 == 0 {
		err = errnoErr(e1)
	}
	return
}

func SHGetStockIconInfo(id int32, flags uint32, icon *ShStockIcon) (err error) {
	r1, _, e1 := syscall.Syscall(procSHGetStockIconInfo.Addr(), 3, uintptr(id), uintptr(flags), uintptr(unsafe.Pointer(icon)))
	if r1 != 0 {
		err = errnoErr(e1)
	}
	return
}

func ShellNotifyIcon(msg NotifyIconMessage, data *NotifyIconData) (err error) {
	r1, _, e1 := syscall.Syscall(procShell_NotifyIconW.Addr(), 2, uintptr(msg), uintptr(unsafe.Pointer(data)), 0)
	if r1 == 0 {
		err = errnoErr(e1)
	}
	return
}

func pathIsDirectory(path *uint16) (isDirectory bool) {
	r0, _, _ := syscall.Syscall(procPathIsDirectoryW.Addr(), 1, uintptr(unsafe.Pointer(path)), 0, 0)
	isDirectory = r0 != 0
	return
}

func CreateWindowEx(exStyle uint32, className *uint16, windowName *uint16, style uint32, x int32, y int32, w int32, h int32, parent Hwnd, menu uintptr, instance windows.Handle, param uintptr) (hwnd Hwnd, err error) {
	r0, _, e1 := syscall.Syscall12(procCreateWindowExW.Addr(), 12, uintptr(exStyle), uintptr(unsafe.Pointer(className)), uintptr(unsafe.Pointer(windowName)), uintptr(style), uintptr(x), uintptr(y), uintptr(w), uintptr(h), uintptr(parent), uintptr(menu), uintptr(instance), uintptr(param))
	hwnd = Hwnd(r0)
	if hwnd == 0 {
		err = errnoErr(e1)
	}
	return
}

func DefWindowProc(hwnd uintptr, msg uint32, wparam uintptr, lparam uintptr) (result uintptr) {
	r0, _, _ := syscall.Syscall6(procDefWindowProcW.Addr(), 4, uintptr(hwnd), uintptr(msg), uintptr(wparam), uintptr(lparam), 0, 0)
	result = uintptr(r0)
	return
}

func DestroyIcon(icon Hicon) {
	syscall.Syscall(procDestroyIcon.Addr(), 1, uintptr(icon), 0, 0)
	return
}

func DestroyWindow(hwnd Hwnd) {
	syscall.Syscall(procDestroyWindow.Addr(), 1, uintptr(hwnd), 0, 0)
	return
}

func LoadImage(inst windows.Handle, name *uint16, typ uint, cx int, cy int, flags uint) (handle windows.Handle, err error) {
	r0, _, e1 := syscall.Syscall6(procLoadImageW.Addr(), 6, uintptr(inst), uintptr(unsafe.Pointer(name)), uintptr(typ), uintptr(cx), uintptr(cy), uintptr(flags))
	handle = windows.Handle(r0)
	if handle == 0 {
		err = errnoErr(e1)
	}
	return
}

func RegisterClass(class *WndClassEx) (err error) {
	r1, _, e1 := syscall.Syscall(procRegisterClassExW.Addr(), 1, uintptr(unsafe.Pointer(class)), 0, 0)
	if r1 == 0 {
		err = errnoErr(e1)
	}
	return
}

func CryptCatalogAdminAcquireContext(handle *windows.Handle, subsystem *windows.GUID, hashAlgorithm *uint16, hashPolicy uintptr, flags uint32) (err error) {
	r1, _, e1 := syscall.Syscall6(procCryptCATAdminAcquireContext2.Addr(), 5, uintptr(unsafe.Pointer(handle)), uintptr(unsafe.Pointer(subsystem)), uintptr(unsafe.Pointer(hashAlgorithm)), uintptr(hashPolicy), uintptr(flags), 0)
	if r1 == 0 {
		err = errnoErr(e1)
	}
	return
}

func CryptCatalogAdminCalcHashFromFileHandle(handle windows.Handle, fd uintptr, size *uint32, hash uintptr, flags uint32) (err error) {
	r1, _, e1 := syscall.Syscall6(procCryptCATAdminCalcHashFromFileHandle2.Addr(), 5, uintptr(handle), uintptr(fd), uintptr(unsafe.Pointer(size)), uintptr(hash), uintptr(flags), 0)
	if r1 == 0 {
		err = errnoErr(e1)
	}
	return
}

func CryptCatalogAdminEnumCatalogFromHash(handle windows.Handle, hash uintptr, size uint32, flags uint32, prevCatalog *windows.Handle) (catalog windows.Handle) {
	r0, _, _ := syscall.Syscall6(procCryptCATAdminEnumCatalogFromHash.Addr(), 5, uintptr(handle), uintptr(hash), uintptr(size), uintptr(flags), uintptr(unsafe.Pointer(prevCatalog)), 0)
	catalog = windows.Handle(r0)
	return
}

func CryptCatalogAdminReleaseCatalogContext(handle windows.Handle, info windows.Handle, flags uint32) (err error) {
	r1, _, e1 := syscall.Syscall(procCryptCATAdminReleaseCatalogContext.Addr(), 3, uintptr(handle), uintptr(info), uintptr(flags))
	if r1 == 0 {
		err = errnoErr(e1)
	}
	return
}

func CryptCatalogAdminReleaseContext(handle windows.Handle, flags int32) (ok bool) {
	r0, _, _ := syscall.Syscall(procCryptCATAdminReleaseContext.Addr(), 2, uintptr(handle), uintptr(flags), 0)
	ok = r0 != 0
	return
}

func CryptCatalogInfoFromContext(handle windows.Handle, catalog *CatalogInfo, flags uint32) (err error) {
	r1, _, e1 := syscall.Syscall(procCryptCATCatalogInfoFromContext.Addr(), 3, uintptr(handle), uintptr(unsafe.Pointer(catalog)), uintptr(flags))
	if r1 == 0 {
		err = errnoErr(e1)
	}
	return
}

func WinVerifyTrust(handle windows.Handle, action *windows.GUID, data *WintrustData) (ret uint32, err error) {
	r0, _, e1 := syscall.Syscall(procWinVerifyTrust.Addr(), 3, uintptr(handle), uintptr(unsafe.Pointer(action)), uintptr(unsafe.Pointer(data)))
	ret = uint32(r0)
	if ret != 0 {
		err = errnoErr(e1)
	}
	return
}

func WTSQuerySessionInformationA(handle windows.Handle, sessionID uint32, klass uint8, buf **uint16, size *uint32) (err error) {
	r1, _, e1 := syscall.Syscall6(procWTSQuerySessionInformationW.Addr(), 5, uintptr(handle), uintptr(sessionID), uintptr(klass), uintptr(unsafe.Pointer(buf)), uintptr(unsafe.Pointer(size)), 0)
	if r1 == 0 {
		err = errnoErr(e1)
	}
	return
}

func WTSQueryUserToken(sessionID uint32, token *windows.Token) (ok bool) {
	r0, _, _ := syscall.Syscall(procWTSQueryUserToken.Addr(), 2, uintptr(sessionID), uintptr(unsafe.Pointer(token)), 0)
	ok = r0 != 0
	return
}

```

`pkg/util/bitmask/bitmask.go`:

```go
/*
 * Copyright 2021-present by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package bitmask

// Bitmask is the map-backed bitmask.
// Each bit index i is split into:
//
// wordIdx = i / 64
// bitPos = i % 64
//
// This allows a virtually unbounded sparse bitset over uint64.
type Bitmask struct {
	words map[uint]uint
}

func New() *Bitmask {
	return &Bitmask{
		words: make(map[uint]uint),
	}
}

func (b *Bitmask) Set(i uint) {
	word := i / 64
	bit := i % 64
	b.words[word] |= 1 << bit
}

func (b *Bitmask) Clear(i uint) {
	word := i / 64
	bit := i % 64
	b.words[word] &^= 1 << bit
	if b.words[word] == 0 {
		delete(b.words, word)
	}
}

func (b *Bitmask) IsSet(i uint) bool {
	word := i / 64
	bit := i % 64
	return b.words[word]&(1<<bit) != 0
}

```

`pkg/util/bootid/bootid.go`:

```go
/*
 * Copyright 2021-2022 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package bootid

import "unsafe"

// The KUSER_SHARED_DATA structure defines a data region that the kernel places
// at a static address for access within user-mode. It is important to note that
// this region of memory, when accessed via user-mode, is read only. The read-only
// user-mode address for the shared data is 0x7FFE0000.
const kuserSharedData uintptr = 0x7FFE0000

const offset uintptr = 0x02C4 // BootId field offset

// Read obtains the value of the BootId field in the KUSER_SHARED_DATA structure.
func Read() uint64 {
	return uint64(*(*uint32)(unsafe.Pointer(uintptr(unsafe.Pointer(kuserSharedData)) + offset)))
}

```

`pkg/util/bootid/bootid_test.go`:

```go
/*
 * Copyright 2021-2022 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package bootid

import (
	"github.com/stretchr/testify/require"
	"testing"
)

func TestReadBootId(t *testing.T) {
	require.True(t, Read() > 0)
}

```

`pkg/util/bytes/bytes.go`:

```go
/*
 * Copyright 2019-2020 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package bytes

import (
	"encoding/binary"
	"unsafe"
)

// NativeEndian represents the endianness of the current machine
var NativeEndian binary.ByteOrder

func init() {
	InitNativeEndian(nil)
}

// InitNativeEndian figures out the endianness of the current machine (https://stackoverflow.com/questions/51332658/any-better-way-to-check-endianness-in-go)
func InitNativeEndian(b []byte) {
	buf := [8]byte{}
	if len(b) == 8 {
		copy(buf[:], b[:8])
	} else {
		*(*uint64)(unsafe.Pointer(&buf[0])) = uint64(0x6669627261747573)
	}

	switch buf {
	case [8]byte{0x73, 0x75, 0x74, 0x61, 0x72, 0x62, 0x69, 0x66}:
		NativeEndian = binary.LittleEndian
	case [8]byte{0x66, 0x69, 0x62, 0x72, 0x61, 0x74, 0x75, 0x73}:
		NativeEndian = binary.BigEndian
	default:
		panic("could not determine native endianness")
	}
}

// ReadUint16 reads the uint16 value from the byte slice.
func ReadUint16(b []byte) uint16 {
	return NativeEndian.Uint16(b)
}

// ReadUint32 reads the uint32 value from the byte slice.
func ReadUint32(b []byte) uint32 {
	return NativeEndian.Uint32(b)
}

// ReadUint64 reads the uint64 value from the byte slice.
func ReadUint64(b []byte) uint64 {
	return NativeEndian.Uint64(b)
}

// WriteUint16 writes the provided uint16 value to byte slice.
func WriteUint16(v uint16) (b []byte) {
	b = make([]byte, 2)
	NativeEndian.PutUint16(b, v)
	return
}

// WriteUint16Buffer writes the provided uint16 value to the byte slice.
func WriteUint16Buffer(v uint16, b []byte) {
	NativeEndian.PutUint16(b, v)
}

// WriteUint32 writes the provided uint32 value to byte slice.
func WriteUint32(v uint32) (b []byte) {
	b = make([]byte, 4)
	NativeEndian.PutUint32(b, v)
	return
}

// WriteUint64 writes the provided uint64 value to byte slice.
func WriteUint64(v uint64) (b []byte) {
	b = make([]byte, 8)
	NativeEndian.PutUint64(b, v)
	return
}

```

`pkg/util/cmdline/cmdline.go`:

```go
/*
 * Copyright 2022-2023 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package cmdline

import (
	"os"
	"path/filepath"
	"regexp"
	"strings"
)

var (
	// splitRegexp declares the regular expression for splitting the string
	// by white spaces if the string is not surrounded inside double quotes.
	splitRegexp = regexp.MustCompile(`("[^"]+?"\S*|\S+)`)

	// systemRootRegexp is the regular expression for detecting path with unexpanded SystemRoot environment variable
	systemRootRegexp = regexp.MustCompile(`%SystemRoot%|^\\SystemRoot|%systemroot%`)

	// driveRegexp is used for determining if the command line start with a valid drive letter based path
	driveRegexp = regexp.MustCompile(`^[a-zA-Z]:\\`)
)

var sysProcs = map[string]bool{
	"dwm.exe":         true,
	"wininit.exe":     true,
	"winlogon.exe":    true,
	"fontdrvhost.exe": true,
	"sihost.exe":      true,
	"taskhostw.exe":   true,
	"dashost.exe":     true,
	"ctfmon.exe":      true,
	"svchost.exe":     true,
	"csrss.exe":       true,
	"services.exe":    true,
	"audiodg.exe":     true,
	"kernel32.dll":    true,
}

// Cmdline offers a convenient interface for the process command line manipulation/normalization.
type Cmdline struct {
	cmdline string
	orig    string // original command line
}

func New(cmdline string) *Cmdline {
	return &Cmdline{cmdline: cmdline, orig: cmdline}
}

// Split returns a slice of strings where each element is
// a single argument in the process command line.
func Split(cmdline string) []string { return splitRegexp.FindAllString(cmdline, -1) }

// ExpandSystemRoot replaces all occurrences of the system root environment variable
// with its respective value.
func ExpandSystemRoot(exe string) string {
	return systemRootRegexp.ReplaceAllString(exe, os.Getenv("SystemRoot"))
}

// CleanExe cleans the executable path and rejoins
// the rest of the command line arguments.
func (c *Cmdline) CleanExe() *Cmdline {
	args := Split(c.cmdline)
	if len(args) > 0 {
		exe := args[0]
		// remove quotes from executable path
		if exe[0] == '"' && exe[len(exe)-1] == '"' {
			c.cmdline = strings.Join(append([]string{exe[1 : len(exe)-1]}, args[1:]...), " ")
			return c
		}
		// remove \??\ prefix from executable path
		if len(exe) > 4 && exe[1] == '?' && exe[2] == '?' {
			c.cmdline = strings.Join(append([]string{exe[4:]}, args[1:]...), " ")
			return c
		}
		// remove \\?\ prefix from executable path
		if len(exe) > 4 && exe[2] == '?' && exe[3] == '\\' {
			c.cmdline = strings.Join(append([]string{exe[4:]}, args[1:]...), " ")
			return c
		}
	}
	return c
}

// ExpandSystemRoot expands all variations of the SystemRoot environment variable,
func (c *Cmdline) ExpandSystemRoot() *Cmdline {
	if systemRootRegexp.MatchString(c.cmdline) {
		c.cmdline = systemRootRegexp.ReplaceAllString(c.cmdline, os.Getenv("SystemRoot"))
	}
	return c
}

// CompleteSysProc completes the executable path of the missing system process.
func (c *Cmdline) CompleteSysProc(name string) *Cmdline {
	if !driveRegexp.MatchString(c.cmdline) {
		_, ok := sysProcs[name]
		if ok {
			c.cmdline = filepath.Join(os.Getenv("SystemRoot"), "System32", c.cmdline)
		}
	}
	return c
}

// Exeline returns the normalized executable path from cmdline.
func (c *Cmdline) Exeline() string {
	i := strings.Index(strings.ToLower(c.cmdline), ".exe")
	if i > 0 {
		return c.cmdline[0 : i+4] // dot + exe
	}
	return ""
}

// String returns the original command line string.
func (c *Cmdline) String() string { return c.orig }

```

`pkg/util/cmdline/cmdline_test.go`:

```go
/*
 * Copyright 2021-2022 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package cmdline

import (
	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/require"
	"os"
	"strings"
	"testing"
)

func TestSplit(t *testing.T) {
	var tests = []struct {
		cmdline string
		wantLen int
		wantExe string
	}{
		{
			`C:\Users\admin\AppData\Roaming\Spotify\Spotify.exe --type=crashpad-handler  "--database=Crashpad" "--metrics-dir=User Data" --max-uploads=5`,
			5,
			`C:\Users\admin\AppData\Roaming\Spotify\Spotify.exe`,
		},
		{
			`svchost.exe "-k netsvcs" -s UserManager`,
			4,
			`svchost.exe`,
		},
		{
			`"C:\Program Files\Conexant\SAII\SmartAudio.exe" /c`,
			2,
			`"C:\Program Files\Conexant\SAII\SmartAudio.exe"`,
		},
	}

	for _, tt := range tests {
		t.Run(tt.cmdline, func(t *testing.T) {
			args := Split(tt.cmdline)
			require.Len(t, args, tt.wantLen)
			require.Equal(t, tt.wantExe, args[0])
		})
	}
}

func TestCmdline(t *testing.T) {
	require.NoError(t, os.Setenv("SystemRoot", "C:\\Windows"))
	var tests = []struct {
		cmdline     string
		wantExeline string
		wantCmdline string
	}{
		{
			`\SystemRoot\System32\smss.exe`,
			`C:\Windows\System32\smss.exe`,
			`\SystemRoot\System32\smss.exe`,
		},
		{
			`%SystemRoot%\system32\csrss.exe ObjectDirectory=\Windows SharedSection=1024,20480,768 Windows=On SubSystemType=Windows ServerDll=basesrv,1 ServerDll=winsrv:UserServerDllInitialization,3 ServerDll=sxssrv,4 ProfileControl=Off MaxRequestThreads=16`,
			`C:\Windows\system32\csrss.exe`,
			`%SystemRoot%\system32\csrss.exe ObjectDirectory=\Windows SharedSection=1024,20480,768 Windows=On SubSystemType=Windows ServerDll=basesrv,1 ServerDll=winsrv:UserServerDllInitialization,3 ServerDll=sxssrv,4 ProfileControl=Off MaxRequestThreads=16`,
		},
		{
			`winlogon.exe`,
			`C:\Windows\System32\winlogon.exe`,
			`winlogon.exe`,
		},
		{
			`\??\C:\WINDOWS\system32\lsaiso.exe`,
			`C:\WINDOWS\system32\lsaiso.exe`,
			`\??\C:\WINDOWS\system32\lsaiso.exe`,
		},
		{
			`"fontdrvhost.exe"`,
			`C:\Windows\System32\fontdrvhost.exe`,
			`"fontdrvhost.exe"`,
		},
		{
			`"fontdrvhost"`,
			``,
			`"fontdrvhost"`,
		},
		{
			`"C:\Program Files\WindowsApps\Microsoft.WindowsTerminal_1.16.10261.0_x64__8wekyb3d8bbwe\WindowsTerminal.exe" Microsoft.WindowsTerminal_1.16.10261.0_x64__8wekyb3d8bbweApp`,
			`C:\Program Files\WindowsApps\Microsoft.WindowsTerminal_1.16.10261.0_x64__8wekyb3d8bbwe\WindowsTerminal.exe`,
			`"C:\Program Files\WindowsApps\Microsoft.WindowsTerminal_1.16.10261.0_x64__8wekyb3d8bbwe\WindowsTerminal.exe" Microsoft.WindowsTerminal_1.16.10261.0_x64__8wekyb3d8bbweApp`,
		},
		{
			`C:\WINDOWS\system32\svchost.exe -k RPCSS -p`,
			`C:\WINDOWS\system32\svchost.exe`,
			`C:\WINDOWS\system32\svchost.exe -k RPCSS -p`,
		},
		{
			`\\?\C:\Windows\System32\SecurityHealth\1.0.2402.27001-0\SecurityHealthHost.exe {E041C90B-68BA-42C9-991E-477B73A75C90} -Embedding`,
			`C:\Windows\System32\SecurityHealth\1.0.2402.27001-0\SecurityHealthHost.exe`,
			`\\?\C:\Windows\System32\SecurityHealth\1.0.2402.27001-0\SecurityHealthHost.exe {E041C90B-68BA-42C9-991E-477B73A75C90} -Embedding`,
		},
		{},
	}

	for _, tt := range tests {
		t.Run(tt.cmdline, func(t *testing.T) {
			cmdline := New(tt.cmdline).
				CleanExe().
				ExpandSystemRoot().
				CompleteSysProc(strings.Trim(tt.cmdline, `"`))
			assert.Equal(t, tt.wantCmdline, cmdline.String())
			assert.Equal(t, tt.wantExeline, cmdline.Exeline())
		})
	}
}

```

`pkg/util/convert/convert.go`:

```go
/*
 * Copyright 2021-2022 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package convert

// Btoi converts the provided bool value to uint8 integer.
func Btoi(b bool) uint8 {
	if b {
		return 1
	}
	return 0
}

// Itob converts the provided uint8 integer to a bool value.
func Itob(i uint8) bool {
	return i > 0
}

// MapKeysToSlice given the map, it converts the map keys to a slice.
func MapKeysToSlice[K comparable, V any](m map[K]V) []K {
	s := make([]K, 0, len(m))
	for k := range m {
		s = append(s, k)
	}
	return s
}

```

`pkg/util/convert/convert_test.go`:

```go
/*
 * Copyright 2021-2022 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package convert

import (
	"github.com/stretchr/testify/assert"
	"testing"
)

func TestMapKeysToSlice(t *testing.T) {
	m := map[uint32]bool{1245: true, 2233: false, 341234: true}
	s := MapKeysToSlice(m)
	assert.Len(t, s, 3)
	assert.Contains(t, s, uint32(1245))
	assert.Contains(t, s, uint32(341234))
}

```

`pkg/util/entropy/entropy.go`:

```go
/*
 * Copyright 2021-2022 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package entropy

import "math"

// Shannon measures the Shannon entropy of a string.
func Shannon(value string) int {
	frq := make(map[rune]float64)

	//get frequency of characters
	for _, i := range value {
		frq[i]++
	}

	var sum float64

	for _, v := range frq {
		f := v / float64(len(value))
		sum += f * math.Log2(f)
	}

	return int(math.Ceil(sum*-1)) * len(value)
}

```

`pkg/util/eventlog/eventid.go`:

```go
/*
 * Copyright 2021-2022 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package eventlog

import "golang.org/x/sys/windows"

// EventID produces the eventlog event identifier from the given
// severity and event code. The format of the event id
// integer is described by the next layout:
//
//	3 3 2 2 2 2 2 2 2 2 2 2 1 1 1 1 1 1 1 1 1 1
//	1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0
//
// +---+-+-+-----------------------+-------------------------------+
// |Sev|C|R|     Facility          |               Code            |
// +---+-+-+-----------------------+-------------------------------+
func EventID(etype, code uint16) uint32 {
	var id uint32

	// severity
	switch etype {
	case windows.EVENTLOG_INFORMATION_TYPE:
		id = uint32(0)<<30 | uint32(1)<<29
	case windows.EVENTLOG_WARNING_TYPE:
		id = uint32(1)<<30 | uint32(0)<<29
	case windows.EVENTLOG_ERROR_TYPE:
		id = uint32(1)<<30 | uint32(1)<<29
	default:
		id = uint32(0)<<30 | uint32(1)<<29
	}
	// customer bit
	id |= uint32(0) << 28
	// reserved bit
	id |= uint32(0) << 27
	// facility
	id |= uint32(0) << 15
	// code
	id |= uint32(code)

	return id
}

```

`pkg/util/eventlog/eventid_test.go`:

```go
/*
 * Copyright 2021-2022 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package eventlog

import (
	"fmt"
	"github.com/stretchr/testify/assert"
	"golang.org/x/sys/windows"
	"testing"
)

func TestEventID(t *testing.T) {
	var tests = []struct {
		eid      uint32
		expected uint32
	}{
		{
			EventID(windows.EVENTLOG_INFORMATION_TYPE, 3191),
			0x20000c77,
		},
		{
			EventID(windows.EVENTLOG_WARNING_TYPE, 3191),
			0x40000c77,
		},
		{
			EventID(windows.EVENTLOG_ERROR_TYPE, 3191),
			0x60000c77,
		},
	}

	for _, tt := range tests {
		t.Run(fmt.Sprintf("%d", tt.expected), func(t *testing.T) {
			assert.Equal(t, tt.expected, tt.eid)
		})
	}
}

```

`pkg/util/eventlog/eventlog.go`:

```go
/*
 * Copyright 2021-2022 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package eventlog

import (
	"fmt"
	"github.com/rabbitstack/fibratus/pkg/event"
	"golang.org/x/sys/windows/registry"
)

const (
	// Source represents the event source that generates the alerts
	Source = "Fibratus"
	// Levels designates the supported eventlog levels
	Levels = uint32(Info | Warn | Erro)
	// msgFile specifies the location of the eventlog message DLL
	msgFile = "%ProgramFiles%\\Fibratus\\fibratus.dll"
	// keyName represents the registry key under which the eventlog source is registered
	keyName = `SYSTEM\CurrentControlSet\Services\EventLog\Application`
)

// ErrKeyExists signals that the registry key already exists
var ErrKeyExists = fmt.Errorf("%s\\%s already exists", keyName, Source)

// categoryCount indicates the number of current event categories
var categoryCount = uint32(len(event.Categories()))

// Level is the type definition for the eventlog log level
type Level uint16

const (
	// Info represents the info log level
	Info Level = 4
	// Warn represents the warning info level
	Warn Level = 2
	// Erro represents the error log level
	Erro Level = 1
)

// Install modifies PC registry to allow logging with an event source src.
// It adds all required keys and values to the event log registry key.
// Install uses msgFile as the event message file. If useExpandKey is true,
// the event message file is installed as REG_EXPAND_SZ value,
// otherwise as REG_SZ. Use bitwise of Errr, Warn, and Info to specify events
// supported by the new event source.
func Install(eventsSupported uint32) error {
	key, err := registry.OpenKey(registry.LOCAL_MACHINE, keyName, registry.CREATE_SUB_KEY)
	if err != nil {
		return err
	}
	defer key.Close()

	sk, exists, err := registry.CreateKey(key, Source, registry.SET_VALUE)
	if err != nil {
		return err
	}
	defer sk.Close()
	if exists {
		return ErrKeyExists
	}

	err = sk.SetDWordValue("CustomSource", 1)
	if err != nil {
		return err
	}
	err = sk.SetExpandStringValue("EventMessageFile", msgFile)
	if err != nil {
		return err
	}
	err = sk.SetExpandStringValue("CategoryMessageFile", msgFile)
	if err != nil {
		return err
	}
	err = sk.SetDWordValue("TypesSupported", eventsSupported)
	if err != nil {
		return err
	}
	err = sk.SetDWordValue("CategoryCount", categoryCount)
	if err != nil {
		return err
	}
	return nil
}

```

`pkg/util/fasttemplate/doc.go`:

```go
/*
 * Copyright 2019-2020 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

// Package fasttemplate implements simple and fast template library. Credits goes to: https://github.com/valyala/fasttemplate
//
// Fasttemplate is faster than text/template, strings.Replace
// and strings.Replacer.
//
// Fasttemplate ideally fits for fast and simple placeholders' substitutions.
package fasttemplate

```

`pkg/util/fasttemplate/template.go`:

```go
/*
 *	The MIT License (MIT)
 *
 *	Copyright (c) 2015 Aliaksandr Valialkin
 *  Modifications Copyright (c) 2019-2020 by Nedim Sabic
 *
 *	Permission is hereby granted, free of charge, to any person obtaining a copy
 *	of this software and associated documentation files (the "Software"), to deal
 *	in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *	copies of the Software, and to permit persons to whom the Software is
 */

package fasttemplate

import (
	"bytes"
	"errors"
	"fmt"
	"github.com/valyala/bytebufferpool"
	"io"
)

// Template implements simple template engine, which can be used for fast
// tags' (aka placeholders) substitution.
type Template struct {
	template string
	startTag string
	endTag   string

	texts          [][]byte
	tags           []string
	byteBufferPool bytebufferpool.Pool
}

// NewTemplate parses the given template using the given startTag and endTag
// as tag start and tag end.
//
// The returned template can be executed by concurrently running goroutines
// using Execute* methods.
func NewTemplate(template, startTag, endTag string) (*Template, error) {
	var t Template
	err := t.Reset(template, startTag, endTag)
	if err != nil {
		return nil, err
	}
	return &t, nil
}

// TagFunc can be used as a substitution value in the map passed to Execute*.
// Execute* functions pass tag (placeholder) name in 'tag' argument.
//
// TagFunc must be safe to call from concurrently running goroutines.
//
// TagFunc must write contents to w and return the number of bytes written.
type TagFunc func(w io.Writer, tag string) (int, error)

// Reset resets the template t to new one defined by
// template, startTag and endTag.
//
// Reset allows Template object re-use.
//
// Reset may be called only if no other goroutines call t methods at the moment.
func (t *Template) Reset(template, startTag, endTag string) error {
	// Keep these vars in t, so GC won't collect them and won't break
	// vars derived via unsafe*
	t.template = template
	t.startTag = startTag
	t.endTag = endTag
	t.texts = t.texts[:0]
	t.tags = t.tags[:0]

	if len(startTag) == 0 {
		return errors.New("start tag cannot be empty")
	}
	if len(endTag) == 0 {
		return errors.New("end tag cannot be empty")
	}

	s := stringToBytes(template)
	a := stringToBytes(startTag)
	b := stringToBytes(endTag)

	tagsCount := bytes.Count(s, a)
	if tagsCount == 0 {
		return nil
	}

	if tagsCount+1 > cap(t.texts) {
		t.texts = make([][]byte, 0, tagsCount+1)
	}
	if tagsCount > cap(t.tags) {
		t.tags = make([]string, 0, tagsCount)
	}

	for {
		n := bytes.Index(s, a)
		if n < 0 {
			t.texts = append(t.texts, s)
			break
		}
		t.texts = append(t.texts, s[:n])

		s = s[n+len(a):]
		n = bytes.Index(s, b)
		if n < 0 {
			return fmt.Errorf("cannot find end tag=%q in the template=%q starting from %q", endTag, template, s)
		}

		t.tags = append(t.tags, bytesToString(s[:n]))
		s = s[n+len(b):]
	}

	return nil
}

// ExecuteFunc calls f on each template tag (placeholder) occurrence.
//
// Returns the number of bytes written to w.
//
// This function is optimized for frozen templates.
// Use ExecuteFunc for constantly changing templates.
func (t *Template) ExecuteFunc(w io.Writer, f TagFunc) (int64, error) {
	var nn int64

	n := len(t.texts) - 1
	if n == -1 {
		ni, err := w.Write(stringToBytes(t.template))
		return int64(ni), err
	}

	for i := 0; i < n; i++ {
		ni, err := w.Write(t.texts[i])
		nn += int64(ni)
		if err != nil {
			return nn, err
		}

		ni, err = f(w, t.tags[i])
		nn += int64(ni)
		if err != nil {
			return nn, err
		}
	}
	ni, err := w.Write(t.texts[n])
	nn += int64(ni)
	return nn, err
}

// Execute substitutes template tags (placeholders) with the corresponding
// values from the map m and writes the result to the given writer w.
//
// Substitution map m may contain values with the following types:
//   - []byte - the fastest value type
//   - string - convenient value type
//   - TagFunc - flexible value type
//
// Returns the number of bytes written to w.
func (t *Template) Execute(w io.Writer, m map[string]interface{}) (int64, error) {
	return t.ExecuteFunc(w, func(w io.Writer, tag string) (int, error) { return stdTagFunc(w, tag, m) })
}

// ExecuteFuncString calls f on each template tag (placeholder) occurrence
// and substitutes it with the data written to TagFunc's w.
//
// Returns the resulting string.
//
// This function is optimized for frozen templates.
// Use ExecuteFuncString for constantly changing templates.
func (t *Template) ExecuteFuncString(f TagFunc) []byte {
	bb := t.byteBufferPool.Get()
	if _, err := t.ExecuteFunc(bb, f); err != nil {
		return []byte{}
	}
	s := bb.Bytes()
	bb.Reset()
	t.byteBufferPool.Put(bb)
	return s
}

// ExecuteString substitutes template tags (placeholders) with the corresponding
// values from the map m and returns the result.
//
// Substitution map m may contain values with the following types:
//   - []byte - the fastest value type
//   - string - convenient value type
//   - TagFunc - flexible value type
//
// This function is optimized for frozen templates.
// Use ExecuteString for constantly changing templates.
func (t *Template) ExecuteString(m map[string]interface{}) []byte {
	return t.ExecuteFuncString(func(w io.Writer, tag string) (int, error) { return stdTagFunc(w, tag, m) })
}

func stdTagFunc(w io.Writer, tag string, m map[string]interface{}) (int, error) {
	v := m[tag]
	if v == nil {
		return 0, nil
	}
	switch value := v.(type) {
	case []byte:
		return w.Write(value)
	case string:
		return w.Write([]byte(value))
	case TagFunc:
		return value(w, tag)
	default:
		return 0, fmt.Errorf("tag=%q contains unexpected value type=%#v. Expected []byte, string or TagFunc", tag, v)
	}
}

```

`pkg/util/fasttemplate/unsafe.go`:

```go
/*
 *	The MIT License (MIT)
 *
 *	Copyright (c) 2015 Aliaksandr Valialkin
 *  Modifications Copyright (c) 2019-2020 by Nedim Sabic
 *
 *	Permission is hereby granted, free of charge, to any person obtaining a copy
 *	of this software and associated documentation files (the "Software"), to deal
 *	in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *	copies of the Software, and to permit persons to whom the Software is
 */

package fasttemplate

import (
	"unsafe"
)

func bytesToString(b []byte) string {
	return *(*string)(unsafe.Pointer(&b))
}

func stringToBytes(s string) []byte {
	return unsafe.Slice(unsafe.StringData(s), len(s))
}

```

`pkg/util/filetime/filetime.go`:

```go
//go:build windows
// +build windows

/*
 * Copyright 2019-2020 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package filetime

import (
	"time"
)

// ToEpoch converts file timestamp to Unix time.
func ToEpoch(ts uint64) time.Time { return time.Unix(0, nanoseconds(ts)) }

// nanoseconds returns Filetime ft in nanoseconds
// since Epoch (00:00:00 UTC, January 1, 1970). This
// function is copied from the stdlib to avoid allocating
// the FileTime structure in the `ToEpoch` function.
func nanoseconds(ts uint64) int64 {
	// 100-nanosecond intervals since January 1, 1601
	nsec := int64(uint32(ts>>32))<<32 + int64(uint32(ts))
	// change starting time to the Epoch (00:00:00 UTC, January 1, 1970)
	nsec -= 116444736000000000
	// convert into nanoseconds
	nsec *= 100
	return nsec
}

```

`pkg/util/format/format.go`:

```go
/*
 * Copyright 2021-2022 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package format

import (
	"fmt"
	"strconv"
)

// UintToHex converts an unsigned wide integer to hex string.
func UintToHex(v uint64) string { return strconv.FormatUint(v, 16) }

// BytesToHex converts a byte slice to hex representation
func BytesToHex(b []byte) string { return fmt.Sprintf("%X", b) }

```

`pkg/util/hashers/fnv.go`:

```go
/*
 * Copyright 2021-2022 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package hashers

import "hash/fnv"

// FnvUint32 computes the uint32 FNV hash for the given byte input.
func FnvUint32(b []byte) uint32 {
	h := fnv.New32()
	_, _ = h.Write(b)
	return h.Sum32()
}

// FnvUint64 computes the uint64 FNV hash for the given byte input.
func FnvUint64(b []byte) uint64 {
	h := fnv.New64()
	_, _ = h.Write(b)
	return h.Sum64()
}

```

`pkg/util/hostname/hostname_windows.go`:

```go
/*
 * Copyright 2019-2020 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package hostname

import (
	"expvar"
	"net"
	"os"
	"syscall"
	"unsafe"
)

// hostname is the current host name or FQDN
var hostname string

// hostnameErrors exposes host/fqdn resolution errors
var hostnameErrors = expvar.NewMap("hostname.errors")

const computerNamePhysicalDNSFullyQualified = 7

var (
	kernel32        = syscall.NewLazyDLL("kernel32.dll")
	getComputerName = kernel32.NewProc("GetComputerNameExW")
)

// Get returns the host name or the FQDN of the machine.
func Get() string {
	if hostname != "" {
		return hostname
	}
	var err error
	hostname, err = os.Hostname()
	if err != nil {
		hostnameErrors.Add(err.Error(), 1)
	}

	// get the Fully Qualified Domain Name (FQDN) of this machine
	maxComputerLength := 1024
	buf := make([]uint16, maxComputerLength)
	errno, _, err := getComputerName.Call(
		uintptr(computerNamePhysicalDNSFullyQualified),
		uintptr(unsafe.Pointer(&buf[0])),
		uintptr(unsafe.Pointer(&maxComputerLength)))
	if errno == 0 {
		// we couldn't get the hostname neither the FQDN
		// so we try to fetch the local IP and use as hostname
		if hostname == "" {
			ip := localIP()
			if ip != "" {
				hostname = ip
			} else {
				hostname = "unknown"
			}
		}
		hostnameErrors.Add(err.Error(), 1)
		return hostname
	}

	fqdn := syscall.UTF16ToString(buf)
	if fqdn != "" {
		hostname = fqdn
	}

	return hostname
}

// localIP returns the first non-loopback interface IP address.
func localIP() string {
	ifaces, err := net.Interfaces()
	if err != nil {
		return ""
	}
	for _, i := range ifaces {
		addrs, err := i.Addrs()
		if err != nil {
			continue
		}
		for _, addr := range addrs {
			var ip net.IP
			switch v := addr.(type) {
			case *net.IPNet:
				ip = v.IP
			case *net.IPAddr:
				ip = v.IP
			}
			if !ip.IsLoopback() {
				return ip.String()
			}
		}
	}
	return ""
}

```

`pkg/util/ip/ip.go`:

```go
//go:build windows
// +build windows

/*
 * Copyright 2019-2020 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package ip

import (
	"net"
	"syscall"
	"unsafe"
)

var (
	nt = syscall.NewLazyDLL("ntdll.dll")

	// rtlIpv6AddressToString is the procedure for `RtlIpv6AddressToStringW` API call.
	rtlIpv6AddressToString = nt.NewProc("RtlIpv6AddressToStringW")
)

// ToIPv4 accepts an integer IP address in network byte order and returns an IP-typed address.
func ToIPv4(ip uint32) net.IP {
	return net.IPv4(byte(ip), byte(ip>>8), byte(ip>>16), byte(ip>>24))
}

// ToIPv6 converts the buffer with IPv6 address in network byte order to an IP-typed address.
func ToIPv6(buffer []byte) net.IP {
	ipv6 := make([]uint16, 46)
	if rtlIpv6AddressToString != nil {
		_, _, _ = rtlIpv6AddressToString.Call(uintptr(unsafe.Pointer(&buffer[0])), uintptr(unsafe.Pointer(&ipv6[0])))
	}
	return net.ParseIP(syscall.UTF16ToString(ipv6))
}

```

`pkg/util/ip/ip_test.go`:

```go
//go:build windows
// +build windows

/*
 * Copyright 2019-2020 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package ip

import (
	"github.com/stretchr/testify/assert"
	"testing"
)

func TestToIPv4(t *testing.T) {
	ip := ToIPv4(16777343)
	assert.Equal(t, "127.0.0.1", ip.String())
}

func TestToIPv6(t *testing.T) {
	ip := ToIPv6([]byte{0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x1})
	assert.Equal(t, "::1", ip.String())
}

```

`pkg/util/key/key.go`:

```go
//go:build windows
// +build windows

/*
 * Copyright 2019-2020 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package key

import (
	"github.com/rabbitstack/fibratus/pkg/sys"
	"golang.org/x/sys/windows/registry"
	"path/filepath"
	"regexp"
	"strings"
)

var (
	hklmPrefixes = []string{"\\REGISTRY\\MACHINE", "\\Registry\\Machine", "\\Registry\\MACHINE", "\\registry\\machine"}
	hkcrPrefixes = []string{"\\REGISTRY\\MACHINE\\SOFTWARE\\CLASSES", "\\Registry\\Machine\\Software\\Classes", "\\REGISTRY\\COMROOT\\CLASSES"}
	hkuPrefixes  = []string{"\\REGISTRY\\USER", "\\Registry\\User"}
)

// rx detects a file path starting with a drive letter, e.g. C:\
var rx = regexp.MustCompile(`[A-Za-z]:\\`)

var loggedSID = getLoggedSID()

func getLoggedSID() string {
	wts, err := sys.LookupActiveWTS()
	if err != nil {
		return ""
	}
	sid, err := wts.SID()
	if err != nil {
		return ""
	}
	return sid.String()
}

// Key is the type alias for the registry key
type Key registry.Key

var (
	Users        = Key(registry.USERS)
	CurrentUser  = Key(registry.CURRENT_USER)
	LocalMachine = Key(registry.LOCAL_MACHINE)
	ClassesRoot  = Key(registry.CLASSES_ROOT)
	// Invalid represents an invalid registry key
	Invalid = Key(registry.Key(0))
)

// RegistryValueTypes enumerate all possible registry value types.
var RegistryValueTypes = map[uint32]string{
	registry.DWORD:     "REG_DWORD",
	registry.QWORD:     "REG_QWORD",
	registry.SZ:        "REG_SZ",
	registry.EXPAND_SZ: "REG_EXPAND_SZ",
	registry.MULTI_SZ:  "REG_MULTI_SZ",
	registry.BINARY:    "REG_BINARY",
}

// String converts registry root key identifier to string.
func (key Key) String() string {
	switch key {
	case Users:
		return "HKEY_USERS"
	case ClassesRoot:
		return "HKEY_CLASSES_ROOT"
	case LocalMachine:
		return "HKEY_LOCAL_MACHINE"
	case CurrentUser:
		return "HKEY_CURRENT_USER"
	default:
		return "Unknown"
	}
}

func shiftPath(k, s, v string) (string, string) {
	r := rx.FindString(s)
	if r == "" {
		return s, v
	}
	n := strings.LastIndex(s, r)
	for n > 0 {
		n--
		// find first slash occurrence backwards
		if s[n] == '\\' {
			return k[:n], k[n+1:]
		}
	}
	return s, v
}

// cleanSID returns the SID without trailing identifiers.
// In some circumstances, the SID can contain the `_Classes`
// suffix.
func cleanSID(sid string) string {
	return strings.TrimSuffix(sid, "_Classes")
}

// ReadValue reads the registry value from the specified key path.
func (key Key) ReadValue(k string) (uint32, any, error) {
	// sometimes the value can contain slashes, in which
	// case we use it as a separator between subkey. For
	// example, \Device\HarddiskVolume4\Windows\regedit.exe
	n := strings.Index(k, "\\\\")
	var subkey string
	var value string
	if n > 0 {
		subkey, value = k[0:n], k[n+1:]
	} else {
		subkey, value = filepath.Split(k)
		// here we handle another corner case
		// when the value can contain a file
		// path starting with a drive letter
		subkey, value = shiftPath(k, subkey, value)
	}
	regKey, err := registry.OpenKey(registry.Key(key), subkey, registry.QUERY_VALUE)
	if err != nil {
		return 0, nil, err
	}
	defer regKey.Close()

	b := make([]byte, 0)
	_, typ, err := regKey.GetValue(value, b)
	if err != nil {
		return 0, nil, err
	}
	var val any
	switch typ {
	case registry.SZ, registry.EXPAND_SZ:
		val, _, err = regKey.GetStringValue(value)
	case registry.DWORD, registry.QWORD:
		val, _, err = regKey.GetIntegerValue(value)
	case registry.MULTI_SZ:
		val, _, err = regKey.GetStringsValue(value)
	case registry.BINARY:
		val, _, err = regKey.GetBinaryValue(value)
	}
	if err != nil {
		return 0, nil, err
	}
	return typ, val, nil
}

// Format produces a root,key tuple from registry native key name.
func Format(key string) (Key, string) {
	for _, p := range hklmPrefixes {
		if strings.HasPrefix(key, p) {
			return LocalMachine, subkey(key, p)
		}
	}
	for _, p := range hkcrPrefixes {
		if strings.HasPrefix(key, p) {
			return ClassesRoot, subkey(key, p)
		}
	}
	for _, p := range hkuPrefixes {
		if strings.HasPrefix(key, p) {
			path := subkey(key, p)
			n := strings.Index(path, "\\")
			var sid string
			if n > 0 && path[0] == 'S' {
				sid = path[:n]
			} else if len(path) > 0 && path[0] == 'S' {
				sid = path
			}
			// if the HKEY_USERS hive sid is equal to
			// the sid of the currently logged user, we
			// remap the root key to HKEY_CURRENT_USER
			switch {
			case cleanSID(sid) == loggedSID && strings.Contains(path, "_Classes"):
				if strings.HasSuffix(sid, "_Classes") {
					return CurrentUser, "Software\\Classes\\" + path[n+1:]
				}
				return CurrentUser, strings.Replace(path[n+1:], "_Classes", "Software\\Classes", 1)
			case sid == loggedSID:
				if len(path) == len(loggedSID) {
					return CurrentUser, ""
				}
				return CurrentUser, path[n+1:]
			default:
				return Users, path
			}
		}
	}
	return Invalid, key
}

func subkey(key string, prefix string) string {
	if len(key) > len(prefix) {
		return key[len(prefix)+1:]
	}
	return ""
}

```

`pkg/util/key/key_test.go`:

```go
//go:build windows
// +build windows

/*
 * Copyright 2019-2020 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package key

import (
	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/require"
	"golang.org/x/sys/windows"
	"golang.org/x/sys/windows/registry"
	"testing"
)

func init() {
	loggedSID = "S-1-5-21-2271034452-2606270099-984871569-500"
}

func TestFormatKey(t *testing.T) {
	var tests = []struct {
		nativeKey   string
		wantsKey    Key
		wantsSubkey string
	}{
		{
			`\REGISTRY\MACHINE\SYSTEM\ControlSet001\Services\Windows Workflow Foundation 4.0.0.0\Linkage`,
			windows.HKEY_LOCAL_MACHINE,
			`SYSTEM\ControlSet001\Services\Windows Workflow Foundation 4.0.0.0\Linkage`,
		},
		{
			`\Registry\Machine\SYSTEM\ControlSet001\Services\Windows Workflow Foundation 4.0.0.0\Linkage`,
			windows.HKEY_LOCAL_MACHINE,
			`SYSTEM\ControlSet001\Services\Windows Workflow Foundation 4.0.0.0\Linkage`,
		},
		{
			`\REGISTRY\MACHINE`,
			windows.HKEY_LOCAL_MACHINE,
			``,
		},
		{
			`\REGISTRY\USER\S-1-5-21-2271034452-2606270099-984871569-500\Console`,
			windows.HKEY_CURRENT_USER,
			`Console`,
		},
		{
			`\REGISTRY\USER\S-1-5-21-2271034452-2606270099-984871569-500\_Classes`,
			windows.HKEY_CURRENT_USER,
			`Software\Classes`,
		},
		{
			`\REGISTRY\USER\S-1-5-21-2271034452-2606270099-984871569-500_Classes\Local Settings\Software\Microsoft\Windows\Shell\MuiCache`,
			windows.HKEY_CURRENT_USER,
			`Software\Classes\Local Settings\Software\Microsoft\Windows\Shell\MuiCache`,
		},
		{
			`\REGISTRY\USER\S-1-5-21-2271034452-2606270099-984871569-500\_Classes\.all`,
			windows.HKEY_CURRENT_USER,
			`Software\Classes\.all`,
		},
		{
			`\REGISTRY\USER\S-1-5-21-2271034452-2606270099-984871569-500`,
			windows.HKEY_CURRENT_USER,
			``,
		},
		{
			`\REGISTRY\USER\S-1-5-9\Network`,
			windows.HKEY_USERS,
			`S-1-5-9\Network`,
		},
		{
			`\REGISTRY\USER`,
			windows.HKEY_USERS,
			``,
		},
	}

	for _, tt := range tests {
		t.Run(tt.nativeKey, func(t *testing.T) {
			nativeKey := tt.nativeKey
			k, s := tt.wantsKey, tt.wantsSubkey
			key, subkey := Format(nativeKey)
			assert.Equal(t, k, key)
			assert.Equal(t, s, subkey)
		})
	}
}

func TestReadValue(t *testing.T) {
	var tests = []struct {
		key      Key
		subkey   string
		expected interface{}
	}{
		{
			CurrentUser,
			"Volatile Environment\\FibratusTestDword",
			uint64(1),
		},
		{
			CurrentUser,
			"Volatile Environment\\FibratusTestQword",
			uint64(1000),
		},
		{
			CurrentUser,
			"Volatile Environment\\FibratusTestSz",
			"fibratus",
		},
		{
			CurrentUser,
			"Volatile Environment\\\\FibratusTestSzSlash",
			"slash",
		},
		{
			CurrentUser,
			"Volatile Environment\\FibratusTestMultiSz",
			[]string{"fibratus", "edr"},
		},
		{
			CurrentUser,
			"Volatile Environment\\FibratusTestExpandSz",
			"%SYSTEMROOT%\\fibratus",
		},
		{
			CurrentUser,
			"Volatile Environment\\UDP Query User{108C2D9B-A047-4E78-B337-BAFC7D9273AB}C:\\users\\admin\\appdata\\local\\temp\\go-build49437379\\b001\\kstream.test.exe",
			`path`,
		},
		{
			CurrentUser,
			"Volatile Environment\\C:\\Program Files\\Java\\jre1.8.0_311\\bin\\javaws.exe.FriendlyAppName",
			"javaws.exe",
		},
	}

	key, err := registry.OpenKey(registry.CURRENT_USER, "Volatile Environment", registry.SET_VALUE)
	require.NoError(t, err)
	defer key.Close()

	defer func() {
		_ = key.DeleteValue("FibratusTestDword")
		_ = key.DeleteValue("FibratusTestQword")
		_ = key.DeleteValue("FibratusTestSz")
		_ = key.DeleteValue("\\FibratusTestSzSlash")
		_ = key.DeleteValue("FibratusTestMultiSz")
		_ = key.DeleteValue("FibratusTestExpandSz")
		_ = key.DeleteValue("UDP Query User{108C2D9B-A047-4E78-B337-BAFC7D9273AB}C:\\users\\admin\\appdata\\local\\temp\\go-build49437379\\b001\\kstream.test.exe")
		_ = key.DeleteValue("C:\\Program Files\\Java\\jre1.8.0_311\\bin\\javaws.exe.FriendlyAppName")
	}()

	require.NoError(t, key.SetDWordValue("FibratusTestDword", 1))
	require.NoError(t, key.SetQWordValue("FibratusTestQword", 1000))
	require.NoError(t, key.SetStringValue("FibratusTestSz", "fibratus"))
	require.NoError(t, key.SetStringValue("\\FibratusTestSzSlash", "slash"))
	require.NoError(t, key.SetStringsValue("FibratusTestMultiSz", []string{"fibratus", "edr"}))
	require.NoError(t, key.SetExpandStringValue("FibratusTestExpandSz", "%SYSTEMROOT%\\fibratus"))
	require.NoError(t, key.SetStringValue("UDP Query User{108C2D9B-A047-4E78-B337-BAFC7D9273AB}C:\\users\\admin\\appdata\\local\\temp\\go-build49437379\\b001\\kstream.test.exe", "path"))
	require.NoError(t, key.SetStringValue("C:\\Program Files\\Java\\jre1.8.0_311\\bin\\javaws.exe.FriendlyAppName", "javaws.exe"))

	for _, tt := range tests {
		t.Run(tt.subkey, func(t *testing.T) {
			_, val, err := tt.key.ReadValue(tt.subkey)
			require.NoError(t, err)
			assert.Equal(t, tt.expected, val)
		})
	}
}

```

`pkg/util/log/_fixtures/fibratus.log`:

```log
time="2024-06-08T13:36:28+02:00" level=info msg="fibratus initialized" source="log/logger_test.go:34"

```

`pkg/util/log/config.go`:

```go
/*
 * Copyright 2019-2020 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package log

import (
	"github.com/spf13/pflag"
	"github.com/spf13/viper"
)

const (
	logLevel      = "logging.level"
	logMaxAge     = "logging.max-age"
	logMaxBackups = "logging.max-backups"
	logMaxSize    = "logging.max-size"
	logFormatter  = "logging.formatter"
	logPath       = "logging.path"
	logStdout     = "logging.log-stdout"
)

// Config contains a set of setting that control the behaviour of the logging system.
type Config struct {
	// Level specifies the minimum allowed log level.
	Level string `json:"logging.level" yaml:"logging.level"`
	// MaxAge is the maximum number of days to retain old log files based on the
	// timestamp encoded in their filename.
	MaxAge int `json:"logging.max-age" yaml:"logging.max-age"`
	// MaxBackups is the maximum number of old log files to retain.
	MaxBackups int `json:"logging.max-backups" yaml:"logging.max-backups"`
	// MaxSize is the maximum size in megabytes of the log file before it gets rotated.
	MaxSize int `json:"logging.max-size" yaml:"logging.max-size"`
	// Formatter represents the log formatter (json | text ).
	Formatter string `json:"logging.formatter" yaml:"logging.formatter"`
	// Path represents the alternative paths for storing the logs.
	Path string `json:"logging.path" yaml:"logging.path"`
	// LogStdout indicates whether log lines are written to standard output in addition to writing them
	// to log files.
	LogStdout bool `json:"logging.log-stdout" yaml:"logging.log-stdout"`
}

// InitFromViper initializes logging configuration from Viper.
func (c *Config) InitFromViper(v *viper.Viper) {
	c.Level = v.GetString(logLevel)
	c.MaxAge = v.GetInt(logMaxAge)
	c.MaxBackups = v.GetInt(logMaxBackups)
	c.MaxSize = v.GetInt(logMaxSize)
	c.Formatter = v.GetString(logFormatter)
	c.Path = v.GetString(logPath)
	c.LogStdout = v.GetBool(logStdout)
}

// AddFlags registers persistent logging flags.
func (c *Config) AddFlags(flags *pflag.FlagSet) {
	flags.String(logLevel, "info", "Specifies the minimum allowed log level")
	flags.Int(logMaxAge, 0, "Sets he maximum number of days to retain old log files based on the timestamp encoded in their filename. By default no old log files will be removed")
	flags.Int(logMaxBackups, 15, "Specifies the maximum number of old log files to retain")
	flags.Int(logMaxSize, 100, "Specifies the maximum size in megabytes of the log file before it gets rotated")
	flags.String(logFormatter, "text", "Represents the log formatter (json|text )")
	flags.String(logPath, "", "Specifies the alternative paths for storing the logs")
	flags.Bool(logStdout, false, "Indicates whether log lines are written to standard output in addition to writing them to log files")
}

```

`pkg/util/log/logger.go`:

```go
/*
 * Copyright 2019-2020 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package log

import (
	"errors"
	"expvar"
	"fmt"
	"github.com/rabbitstack/fibratus/pkg/sys"
	"github.com/rabbitstack/fibratus/pkg/util/log/rotate"
	fs "github.com/rifflock/lfshook"
	"github.com/saferwall/pe/log"
	"github.com/sirupsen/logrus"
	"golang.org/x/sys/windows"
	"io"
	"os"
	"path/filepath"
)

var (
	// errEmptyLogsPath contains logger setup errors
	loggerErrors = expvar.NewMap("logger.errors")
)

// InitFromConfig initializes a Logrus instance from config options.
func InitFromConfig(c Config, filename string) error {
	exe, err := os.Executable()
	var path string
	if err != nil {
		path = filepath.Join(os.Getenv("PROGRAMFILES"), "Fibratus", "Logs")
	} else {
		path = filepath.Join(filepath.Dir(exe), "..", "Logs")
	}
	if c.Path != "" {
		path = c.Path
	}
	if path == "" {
		return errors.New("got an empty logs directory path. Please make sure Fibratus is installed properly")
	}
	_, err = os.Stat(path)
	if err != nil {
		// let's create the logs directory since it doesn't exist, even though
		// this should rarely happen because Fibratus installer already creates
		// the logs directory
		if err := os.MkdirAll(path, os.ModePerm); err != nil {
			return fmt.Errorf("unable to create the %s logs directory: %v", path, err)
		}
	}

	file := filepath.Join(path, filename)

	// setup log formatter
	var formatter logrus.Formatter
	switch c.Formatter {
	case "json":
		formatter = &logrus.JSONFormatter{}
	case "text":
		formatter = &logrus.TextFormatter{DisableQuote: true}
	default:
		formatter = &logrus.JSONFormatter{}
	}
	logrus.SetFormatter(formatter)

	level, err := logrus.ParseLevel(c.Level)
	if err != nil {
		return err
	}
	logrus.SetLevel(level)

	// disable writing to stdout
	if !c.LogStdout {
		logrus.SetOutput(io.Discard)
	}

	// initialize log rotate hook
	rhook, err := rotate.NewHook(rotate.Config{
		MaxAge:     c.MaxAge,
		MaxBackups: c.MaxBackups,
		MaxSize:    c.MaxSize,
		Level:      level,
		Formatter:  formatter,
		Filename:   file,
	})

	// redirect stderr to a file if running as Windows Service
	if sys.IsWindowsService() {
		err = redirectStderrToFile(file)
		if err != nil {
			log.Warnf("stderr redirection: %v", err)
		}
	}

	if err != nil {
		loggerErrors.Add(err.Error(), 1)
		// failed to initialize log rotate, so we fallback on simple log hook
		var pathMap fs.PathMap = make(map[logrus.Level]string)
		for _, lvl := range logrus.AllLevels {
			pathMap[lvl] = file
		}
		logrus.AddHook(fs.NewHook(pathMap, formatter))
		logrus.Warnf("unable to initialize rotate file hook: %v", err)
		return nil
	}
	logrus.AddHook(rhook)

	return nil
}

// redirectStderrToFile redirects the standard output stream to a log file.
// Helpful to capture panics and send them to the file.
func redirectStderrToFile(file string) error {
	f, err := os.OpenFile(file, os.O_WRONLY|os.O_CREATE|os.O_SYNC|os.O_APPEND, 0644)
	if err != nil {
		return fmt.Errorf("unable to open %s for stderr redirection: %v", file, err)
	}
	defer f.Close()

	fd, err := dupFD(f.Fd())
	if err != nil {
		return fmt.Errorf("failed to duplicate file handle: %v", err)
	}

	err = windows.SetStdHandle(windows.STD_ERROR_HANDLE, fd)
	if err != nil {
		return fmt.Errorf("failed to redirect stderr to file: %v", err)
	}

	return nil
}

func dupFD(fd uintptr) (windows.Handle, error) {
	proc := windows.CurrentProcess()
	var h windows.Handle
	return h, windows.DuplicateHandle(proc, windows.Handle(fd), proc, &h, 0, true, windows.DUPLICATE_SAME_ACCESS)
}

```

`pkg/util/log/logger_test.go`:

```go
/*
 * Copyright 2019-2020 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package log

import (
	"github.com/sirupsen/logrus"
	"github.com/stretchr/testify/require"
	"os"
	"testing"
)

func TestInitFromConfig(t *testing.T) {
	require.Error(t, InitFromConfig(Config{}, "fibratus.log"))
	require.NoError(t, InitFromConfig(Config{Path: "_fixtures", Level: "info", Formatter: "text"}, "fibratus.log"))

	os.Remove("_fixtures\\fibratus.log")

	logrus.Info("fibratus initialized")

	_, err := os.Stat("_fixtures\\fibratus.log")
	require.NoError(t, err)
}

```

`pkg/util/log/rotate/rotate.go`:

```go
/*
 * Copyright 2019-2020 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package rotate

import (
	"fmt"
	"github.com/sirupsen/logrus"
	"gopkg.in/natefinch/lumberjack.v2"
	"io"
	"runtime"
	"strings"
)

// Config is the configuration for the rotate file hook.
type Config struct {
	Filename   string
	MaxSize    int
	MaxBackups int
	MaxAge     int
	Level      logrus.Level
	Formatter  logrus.Formatter
}

// File represents the rotate file hook.
type File struct {
	config       Config
	w            io.Writer
	depth        int
	skip         int
	formatter    func(file, function string, line int) string
	skipPrefixes []string
}

// NewHook builds a new rotate file hook.
func NewHook(config Config) (logrus.Hook, error) {
	hook := File{
		config:       config,
		depth:        20,
		skip:         5,
		skipPrefixes: []string{"logrus/", "logrus@"},
		formatter: func(file, function string, line int) string {
			return fmt.Sprintf("%s:%d", file, line)
		},
	}
	hook.w = &lumberjack.Logger{
		Filename:   config.Filename,
		MaxSize:    config.MaxSize,
		MaxBackups: config.MaxBackups,
		MaxAge:     config.MaxAge,
	}
	return &hook, nil
}

// Levels determines log levels that for which the logs are written.
func (hook *File) Levels() []logrus.Level {
	return logrus.AllLevels[:hook.config.Level+1]
}

// Fire is called by logrus when it is about to write the log entry.
func (hook *File) Fire(entry *logrus.Entry) (err error) {
	modified := entry.WithField("source", hook.formatter(hook.findCaller()))
	modified.Level = entry.Level
	modified.Message = entry.Message
	b, err := hook.config.Formatter.Format(modified)
	if err != nil {
		return err
	}
	_, err = hook.w.Write(b)
	return err
}

func (hook *File) findCaller() (string, string, int) {
	var (
		pc       uintptr
		file     string
		function string
		line     int
	)
	for i := 0; i < hook.depth; i++ {
		pc, file, line = getCaller(hook.skip + i)
		if !hook.skipFile(file) {
			break
		}
	}
	if pc != 0 {
		frames := runtime.CallersFrames([]uintptr{pc})
		frame, _ := frames.Next()
		function = frame.Function
	}

	return file, function, line
}

func (hook *File) skipFile(file string) bool {
	for i := range hook.skipPrefixes {
		if strings.HasPrefix(file, hook.skipPrefixes[i]) {
			return true
		}
	}
	return false
}

func getCaller(skip int) (uintptr, string, int) {
	pc, file, line, ok := runtime.Caller(skip)
	if !ok {
		return 0, "", 0
	}

	n := 0
	for i := len(file) - 1; i > 0; i-- {
		if file[i] == '/' {
			n++
			if n >= 2 {
				file = file[i+1:]
				break
			}
		}
	}

	return pc, file, line
}

```

`pkg/util/loldrivers/client.go`:

```go
/*
 * Copyright 2021-2022 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package loldrivers

import (
	"bytes"
	"context"
	"crypto"
	"crypto/sha1"
	"crypto/sha256"
	"encoding/hex"
	"encoding/json"
	"fmt"
	libntfs "github.com/rabbitstack/fibratus/pkg/fs/ntfs"
	"github.com/rabbitstack/fibratus/pkg/util/cmdline"
	log "github.com/sirupsen/logrus"
	"hash"
	"io"
	"net/http"
	"path/filepath"
	"strings"
	"sync"
	"time"
)

// apiURL represents the default loldrivers API endpoint
const apiURL = "https://www.loldrivers.io/api/drivers.json"

// Client is responsible for downloading loldrivers dataset.
// Driver dataset is indexed by SHA hash to provide more
// efficient lookups.
type Client struct {
	drivers map[string]Driver
	mu      sync.Mutex
	tick    *time.Ticker
	options opts
}

type opts struct {
	apiURL          string
	refreshInterval time.Duration
	asyncDownload   bool
}

// Option represents the option for the loldrivers client.
type Option func(o *opts)

// WithURL sets the API endpoint.
func WithURL(url string) Option {
	return func(o *opts) {
		o.apiURL = url
	}
}

// WithRefresh sets the refresh interval for loldrivers dataset.
func WithRefresh(interval time.Duration) Option {
	return func(o *opts) {
		o.refreshInterval = interval
	}
}

// WithAsyncDownload indicates if the initial request to loldrivers API
// is performed in a separate goroutine.
func WithAsyncDownload() Option {
	return func(o *opts) {
		o.asyncDownload = true
	}
}

var c *Client

// InitClient initializes the loldrivers by client by fetching the initial dataset.
func InitClient(options ...Option) {
	if c == nil {
		c = initClient(options...)
	}
}

// GetClient constructs a singleton instance of the loldrivers client.
// If the client wasn't initialized, this function creates a new client
// with default sane settings.
func GetClient() *Client {
	if c == nil {
		c = initClient()
	}
	return c
}

func initClient(options ...Option) *Client {
	if c == nil {
		var opts opts
		for _, opt := range options {
			opt(&opts)
		}

		if opts.apiURL == "" {
			opts.apiURL = apiURL
		}
		if opts.refreshInterval == 0 {
			opts.refreshInterval = time.Hour
		}

		c = &Client{
			options: opts,
			drivers: make(map[string]Driver),
			tick:    time.NewTicker(opts.refreshInterval),
		}
		download := func() {
			err := c.download()
			if err != nil {
				log.Warnf("unable to download loldrivers.io dataset: %v", err)
			}
		}
		// if async download is enabled we'll
		// fetch the initial dataset in a new
		// goroutine
		if opts.asyncDownload {
			go download()
		} else {
			download()
		}
		// start refresh goroutine
		go c.refresh()
	}
	return c
}

// MatchHash receives the full path of the driver file and tries to read
// the blob data from the raw device. If it succeeds, then one of the SHA1/SHA256
// hashes are computed for the read data and the calculated hash is evaluated
// against loldrivers dataset. If the driver can't be read from the file system or
// hash calculation fail, then the driver sample name is asserted against the
// dataset to determine if the driver is either malicious or vulnerable.
func (c *Client) MatchHash(path string) (bool, Driver) {
	ntfs := libntfs.NewFS()
	defer ntfs.Close()
	data, _, err := ntfs.ReadFull(cmdline.ExpandSystemRoot(path))
	if err != nil {
		return c.matchPath(path)
	}

	r := bytes.NewReader(data)

	c.mu.Lock()
	defer c.mu.Unlock()
	ok, driver := c.matchHash(crypto.SHA256, r, path)
	if !ok {
		// the driver sample doesn't have SHA256 hash, try with SHA1 hash
		return c.matchHash(crypto.SHA1, r, path)
	}
	return ok, driver
}

func (c *Client) matchHash(h crypto.Hash, r io.Reader, path string) (bool, Driver) {
	checksum, err := c.calculateHash(h, r)
	if err != nil {
		return c.matchPath(path)
	}
	driver, ok := c.drivers[checksum]
	return ok, driver
}

func (c *Client) matchPath(path string) (bool, Driver) {
	c.mu.Lock()
	defer c.mu.Unlock()
	for _, d := range c.drivers {
		if d.Filename == "" {
			continue
		}
		if strings.EqualFold(filepath.Base(path), d.Filename) {
			return true, d
		}
	}
	return false, Driver{}
}

func (c *Client) calculateHash(h crypto.Hash, r io.Reader) (string, error) {
	var w hash.Hash
	switch h {
	case crypto.SHA1:
		w = sha1.New()
	case crypto.SHA256:
		w = sha256.New()
	default:
		return "", fmt.Errorf("%v: invalid hash", h)
	}
	if _, err := io.Copy(w, r); err != nil {
		return "", err
	}
	return strings.ToLower(hex.EncodeToString(w.Sum(nil))), nil
}

// Drivers returns a list of all drivers in the dataset.
func (c *Client) Drivers() []Driver {
	c.mu.Lock()
	defer c.mu.Unlock()
	drivers := make([]Driver, 0, len(c.drivers))
	for _, d := range c.drivers {
		drivers = append(drivers, d)
	}
	return drivers
}

// Clear clears the internal dataset.
func (c *Client) Clear() {
	c.mu.Lock()
	defer c.mu.Unlock()
	c.drivers = make(map[string]Driver)
}

func (c *Client) download() error {
	client := http.Client{
		Timeout: time.Second * 10,
	}
	ctx, cancel := context.WithTimeout(context.Background(), time.Second*10)
	defer cancel()
	req, err := http.NewRequestWithContext(ctx, "GET", c.options.apiURL, nil)
	if err != nil {
		return err
	}
	resp, err := client.Do(req)
	if err != nil {
		return err
	}
	defer resp.Body.Close()
	body, err := io.ReadAll(resp.Body)
	if err != nil {
		return err
	}
	var drivers []RawDriver
	if err := json.Unmarshal(body, &drivers); err != nil {
		return err
	}

	c.mu.Lock()
	defer c.mu.Unlock()
	c.drivers = make(map[string]Driver)

	for _, driver := range drivers {
		for _, sample := range driver.KnownVulnerableSamples {
			sha := sample.SHA256
			if sha == "" {
				sha = sample.SHA1
			}
			c.drivers[strings.ToLower(sha)] = Driver{
				Filename:     sample.Filename,
				SHA1:         strings.ToLower(sample.SHA1),
				SHA256:       strings.ToLower(sample.SHA256),
				IsMalicious:  driver.isMalicious(),
				IsVulnerable: !driver.isMalicious(),
			}
		}
	}

	return nil
}

func (c *Client) refresh() {
	for {
		<-c.tick.C
		log.Debug("refreshing loldrivers dataset...")
		err := c.download()
		if err != nil {
			log.Warnf("unable to refresh loldrivers dataset: %v", err)
		}
	}
}

```

`pkg/util/loldrivers/client_test.go`:

```go
/*
 * Copyright 2021-2022 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package loldrivers

import (
	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/require"
	"path/filepath"
	"testing"
	"time"
)

func TestDownload(t *testing.T) {
	assert.Nil(t, c)
	InitClient()
	require.True(t, len(GetClient().Drivers()) > 0)
	assert.NotNil(t, c)

	var expectedSHA256 = "0440ef40c46fdd2b5d86e7feef8577a8591de862cfd7928cdbcc8f47b8fa3ffc"
	var foundSHA256 string

	for _, driver := range GetClient().Drivers() {
		if driver.Filename == "prokiller64.sys" {
			foundSHA256 = driver.SHA256
			break
		}
	}

	assert.Equal(t, expectedSHA256, foundSHA256)
}

func TestMatchHash(t *testing.T) {
	absPath := func(path string) string {
		abs, err := filepath.Abs(path)
		if err != nil {
			t.Fatal(err)
		}
		return abs
	}

	var tests = []struct {
		driverPath string
		wantsName  string
		ok         bool
	}{
		{
			absPath("_fixtures/d.sys"),
			"d.sys",
			true,
		},
		{
			absPath("_fixtures/iomem.sys"),
			"iomem64.sys",
			true,
		},
	}

	for _, tt := range tests {
		t.Run(tt.driverPath, func(t *testing.T) {
			ok, d := GetClient().MatchHash(tt.driverPath)
			assert.True(t, ok == tt.ok)
			assert.Equal(t, tt.wantsName, d.Filename)
		})
	}
}

func TestRefresh(t *testing.T) {
	c = nil
	InitClient(WithRefresh(time.Second * 2))
	require.True(t, len(GetClient().Drivers()) > 0)
	GetClient().Clear()
	require.True(t, len(GetClient().Drivers()) == 0)
	time.Sleep(time.Second * 3)
	require.True(t, len(GetClient().Drivers()) > 0)
}

```

`pkg/util/loldrivers/types.go`:

```go
/*
 * Copyright 2021-2022 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package loldrivers

// RawDriver contains vulnerable/malicious driver data fetched from loldrivers API endpoint.
type RawDriver struct {
	ID                     string `json:"Id"`
	Category               string `json:"Category"`
	Created                string `json:"Created"`
	MitreID                string `json:"MitreID"`
	KnownVulnerableSamples []struct {
		Filename string `json:"Filename"`
		MD5      string `json:"MD5,omitempty"`
		SHA1     string `json:"SHA1,omitempty"`
		SHA256   string `json:"SHA256,omitempty"`
	} `json:"KnownVulnerableSamples,omitempty"`
}

func (d RawDriver) isMalicious() bool {
	return d.Category == "malicious"
}

// Driver intermediate structure for storing driver data
// relevant for the hash matching.
type Driver struct {
	Filename     string
	SHA1         string
	SHA256       string
	IsMalicious  bool
	IsVulnerable bool
}

```

`pkg/util/markdown/strip.go`:

```go
/*
 * Copyright 2021-2022 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package markdown

import "regexp"

// All credits go to https://github.com/writeas/go-strip-markdown/blob/master/strip.go

var (
	listLeadersReg = regexp.MustCompile(`(?m)^([\s\t]*)([\*\-\+]|\d\.)\s+`)

	headerReg = regexp.MustCompile(`\n={2,}`)
	strikeReg = regexp.MustCompile(`~~`)
	codeReg   = regexp.MustCompile("`{3}" + `.*\n`)

	htmlReg         = regexp.MustCompile("<(.*?)>")
	emphReg         = regexp.MustCompile(`\*\*([^*]+)\*\*`)
	emphReg2        = regexp.MustCompile(`\*([^*]+)\*`)
	emphReg3        = regexp.MustCompile(`__([^_]+)__`)
	emphReg4        = regexp.MustCompile(`_([^_]+)_`)
	setextHeaderReg = regexp.MustCompile(`^[=\-]{2,}\s*$`)
	footnotesReg    = regexp.MustCompile(`\[\^.+?\](\: .*?$)?`)
	footnotes2Reg   = regexp.MustCompile(`\s{0,2}\[.*?\]: .*?$`)
	imagesReg       = regexp.MustCompile(`\!\[(.*?)\]\s?[\[\(].*?[\]\)]`)
	linksReg        = regexp.MustCompile(`\[(.*?)\][\[\(].*?[\]\)]`)
	blockquoteReg   = regexp.MustCompile(`>\s*`)
	refLinkReg      = regexp.MustCompile(`^\s{1,2}\[(.*?)\]: (\S+)( ".*?")?\s*$`)
	atxHeaderReg    = regexp.MustCompile(`(?m)^\#{1,6}\s*([^#]+)\s*(\#{1,6})?$`)
	atxHeaderReg2   = regexp.MustCompile(`([\*_]{1,3})(\S.*?\S)?P1`)
	atxHeaderReg3   = regexp.MustCompile("(?m)(`{3,})" + `(.*?)?P1`)
	atxHeaderReg4   = regexp.MustCompile(`^-{3,}\s*$`)
	atxHeaderReg5   = regexp.MustCompile("`(.+?)`")
	atxHeaderReg6   = regexp.MustCompile(`\n{2,}`)
)

// Strip returns the given string sans any Markdown.
// Where necessary, elements are replaced with their best textual forms, so
// for example, hyperlinks are stripped of their URL and become only the link
// text, and images lose their URL and become only the alt text.
func Strip(md string) string {
	s := md
	s = listLeadersReg.ReplaceAllString(s, "$1")

	s = headerReg.ReplaceAllString(s, "\n")
	s = strikeReg.ReplaceAllString(s, "")
	s = codeReg.ReplaceAllString(s, "")

	s = emphReg.ReplaceAllString(s, "$1")
	s = emphReg2.ReplaceAllString(s, "$1")
	s = emphReg3.ReplaceAllString(s, "$1")
	s = emphReg4.ReplaceAllString(s, "$1")
	s = htmlReg.ReplaceAllString(s, "$1")
	s = setextHeaderReg.ReplaceAllString(s, "")
	s = footnotesReg.ReplaceAllString(s, "")
	s = footnotes2Reg.ReplaceAllString(s, "")

	s = imagesReg.ReplaceAllString(s, "")

	s = linksReg.ReplaceAllString(s, "$1")
	s = blockquoteReg.ReplaceAllString(s, "  ")
	s = refLinkReg.ReplaceAllString(s, "")
	s = atxHeaderReg.ReplaceAllString(s, "$1")
	s = atxHeaderReg2.ReplaceAllString(s, "$2")
	s = atxHeaderReg3.ReplaceAllString(s, "$2")
	s = atxHeaderReg4.ReplaceAllString(s, "")
	s = atxHeaderReg5.ReplaceAllString(s, "$1")
	s = atxHeaderReg6.ReplaceAllString(s, "\n\n")

	return s
}

```

`pkg/util/markdown/strip_test.go`:

```go
/*
 * Copyright 2021-2022 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package markdown

import (
	"github.com/stretchr/testify/assert"
	"testing"
)

func TestStrip(t *testing.T) {
	md := `Detected an attempt by mimikatz.exe process to access and read
         the memory of the **Local Security And Authority Subsystem Service**
         and subsequently write the _C:\\dump.dmp_ dump file to the disk device`
	expected := `Detected an attempt by mimikatz.exe process to access and read
         the memory of the Local Security And Authority Subsystem Service
         and subsequently write the C:\\dump.dmp dump file to the disk device`
	assert.Equal(t, expected, Strip(md))
}

```

`pkg/util/multierror/multierror.go`:

```go
// Copyright (c) 2017 Uber Technologies, Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package multierror

import (
	"strings"
)

var sep = ", "

// Wrap takes a slice of errors and returns a single error that encapsulates
// those underlying errors. If the slice is nil or empty it returns nil.
// If the slice only contains a single element, that error is returned directly.
// When more than one error is wrapped, the Error() string is a concatenation
// of the Error() values of all underlying errors.
func Wrap(errs ...error) error {
	return multiError(errs).flatten()
}

// WrapWithSeparator same as Wrap but uses a custom separator when joining
// error messages.
func WrapWithSeparator(s string, errs ...error) error {
	sep = s
	return multiError(errs).flatten()
}

// multiError bundles several errors together into a single error.
type multiError []error

// flatten returns either: nil, the only error, or the multiError instance itself
// if there are 0, 1, or more errors in the slice respectively.
func (errors multiError) flatten() error {
	switch len(errors) {
	case 0:
		return nil
	default:
		for _, err := range errors {
			if err != nil {
				return errors
			}
		}
		return nil
	}
}

// Error returns a string like "[e1, e2, ...]" where each eN is the Error() of
// each error in the slice.
func (errors multiError) Error() string {
	parts := make([]string, 0)
	for _, err := range errors {
		if err == nil {
			continue
		}
		parts = append(parts, err.Error())
	}
	return strings.Join(parts, sep)
}

```

`pkg/util/ntstatus/status.go`:

```go
/*
 * Copyright 2021-2022 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package ntstatus

import (
	"github.com/rabbitstack/fibratus/pkg/sys"
	"golang.org/x/sys/windows"
	"sync"
	"unicode/utf16"
)

// Success determines the success system message
const Success = "Success"

var statusCache = map[uint32]string{}
var mux sync.Mutex

// isSuccess determines if the status code is in success or information value ranges.
// https://learn.microsoft.com/en-us/windows-hardware/drivers/kernel/using-ntstatus-values
func isSuccess(status uint32) bool {
	return status <= 0x3FFFFFFF || (status >= 0x40000000 && status <= 0x7FFFFFFF)
}

// FormatMessage resolved the NT status code to an error message. The cache of resolved
// messages is kept to speed up status code translation and alleviate the pressure on
// API call invocations.
func FormatMessage(status uint32) string {
	if isSuccess(status) {
		return Success
	}
	mux.Lock()
	defer mux.Unlock()
	if s, ok := statusCache[status]; ok {
		return s
	}
	var flags uint32 = windows.FORMAT_MESSAGE_FROM_SYSTEM
	b := make([]uint16, 300)
	msgID := sys.RtlNtStatusToDosError(status)
	n, err := windows.FormatMessage(flags, 0, msgID, 0, b, nil)
	if err != nil {
		return "Unknown"
	}
	// trim terminating \r and \n
	for ; n > 0 && (b[n-1] == '\n' || b[n-1] == '\r'); n-- {
	}
	statusCache[status] = string(utf16.Decode(b[:n-1]))
	return statusCache[status]
}

```

`pkg/util/ports/iana_ports.go`:

```go
// Copyright 2012 Google, Inc. All rights reserved.
// Borrowed from gopacket. https://github.com/google/gopacket/blob/master/layers/iana_ports.go

package ports

// Created by gen.go, don't edit manually
// Generated at 2017-10-23 09:57:28.214859163 -0600 MDT m=+1.011679290
// Fetched from "http://www.iana.org/assignments/service-names-port-numbers/service-names-port-numbers.xml"

// TCPPortNames contains the port names for all TCP ports.
var TCPPortNames = tcpPortNames

// UDPPortNames contains the port names for all UDP ports.
var UDPPortNames = udpPortNames

// SCTPPortNames contains the port names for all SCTP ports.
var SCTPPortNames = sctpPortNames

var tcpPortNames = map[uint16]string{
	1:     "tcpmux",
	2:     "compressnet",
	3:     "compressnet",
	5:     "rje",
	7:     "echo",
	9:     "discard",
	11:    "systat",
	13:    "daytime",
	17:    "qotd",
	18:    "msp",
	19:    "chargen",
	20:    "ftp-data",
	21:    "ftp",
	22:    "ssh",
	23:    "telnet",
	25:    "smtp",
	27:    "nsw-fe",
	29:    "msg-icp",
	31:    "msg-auth",
	33:    "dsp",
	37:    "time",
	38:    "rap",
	39:    "rlp",
	41:    "graphics",
	42:    "name",
	43:    "nicname",
	44:    "mpm-flags",
	45:    "mpm",
	46:    "mpm-snd",
	48:    "auditd",
	49:    "tacacs",
	50:    "re-mail-ck",
	52:    "xns-time",
	53:    "domain",
	54:    "xns-ch",
	55:    "isi-gl",
	56:    "xns-auth",
	58:    "xns-mail",
	62:    "acas",
	63:    "whoispp",
	64:    "covia",
	65:    "tacacs-ds",
	66:    "sql-net",
	67:    "bootps",
	68:    "bootpc",
	69:    "tftp",
	70:    "gopher",
	71:    "netrjs-1",
	72:    "netrjs-2",
	73:    "netrjs-3",
	74:    "netrjs-4",
	76:    "deos",
	78:    "vettcp",
	79:    "finger",
	80:    "http",
	82:    "xfer",
	83:    "mit-ml-dev",
	84:    "ctf",
	85:    "mit-ml-dev",
	86:    "mfcobol",
	88:    "kerberos",
	89:    "su-mit-tg",
	90:    "dnsix",
	91:    "mit-dov",
	92:    "npp",
	93:    "dcp",
	94:    "objcall",
	95:    "supdup",
	96:    "dixie",
	97:    "swift-rvf",
	98:    "tacnews",
	99:    "metagram",
	101:   "hostname",
	102:   "iso-tsap",
	103:   "gppitnp",
	104:   "acr-nema",
	105:   "cso",
	106:   "3com-tsmux",
	107:   "rtelnet",
	108:   "snagas",
	109:   "pop2",
	110:   "pop3",
	111:   "sunrpc",
	112:   "mcidas",
	113:   "ident",
	115:   "sftp",
	116:   "ansanotify",
	117:   "uucp-path",
	118:   "sqlserv",
	119:   "nntp",
	120:   "cfdptkt",
	121:   "erpc",
	122:   "smakynet",
	123:   "ntp",
	124:   "ansatrader",
	125:   "locus-map",
	126:   "nxedit",
	127:   "locus-con",
	128:   "gss-xlicen",
	129:   "pwdgen",
	130:   "cisco-fna",
	131:   "cisco-tna",
	132:   "cisco-sys",
	133:   "statsrv",
	134:   "ingres-net",
	135:   "epmap",
	136:   "profile",
	137:   "netbios-ns",
	138:   "netbios-dgm",
	139:   "netbios-ssn",
	140:   "emfis-data",
	141:   "emfis-cntl",
	142:   "bl-idm",
	143:   "imap",
	144:   "uma",
	145:   "uaac",
	146:   "iso-tp0",
	147:   "iso-ip",
	148:   "jargon",
	149:   "aed-512",
	150:   "sql-net",
	151:   "hems",
	152:   "bftp",
	153:   "sgmp",
	154:   "netsc-prod",
	155:   "netsc-dev",
	156:   "sqlsrv",
	157:   "knet-cmp",
	158:   "pcmail-srv",
	159:   "nss-routing",
	160:   "sgmp-traps",
	161:   "snmp",
	162:   "snmptrap",
	163:   "cmip-man",
	164:   "cmip-agent",
	165:   "xns-courier",
	166:   "s-net",
	167:   "namp",
	168:   "rsvd",
	169:   "send",
	170:   "print-srv",
	171:   "multiplex",
	172:   "cl-1",
	173:   "xyplex-mux",
	174:   "mailq",
	175:   "vmnet",
	176:   "genrad-mux",
	177:   "xdmcp",
	178:   "nextstep",
	179:   "bgp",
	180:   "ris",
	181:   "unify",
	182:   "audit",
	183:   "ocbinder",
	184:   "ocserver",
	185:   "remote-kis",
	186:   "kis",
	187:   "aci",
	188:   "mumps",
	189:   "qft",
	190:   "gacp",
	191:   "prospero",
	192:   "osu-nms",
	193:   "srmp",
	194:   "irc",
	195:   "dn6-nlm-aud",
	196:   "dn6-smm-red",
	197:   "dls",
	198:   "dls-mon",
	199:   "smux",
	200:   "src",
	201:   "at-rtmp",
	202:   "at-nbp",
	203:   "at-3",
	204:   "at-echo",
	205:   "at-5",
	206:   "at-zis",
	207:   "at-7",
	208:   "at-8",
	209:   "qmtp",
	210:   "z39-50",
	211:   "914c-g",
	212:   "anet",
	213:   "ipx",
	214:   "vmpwscs",
	215:   "softpc",
	216:   "CAIlic",
	217:   "dbase",
	218:   "mpp",
	219:   "uarps",
	220:   "imap3",
	221:   "fln-spx",
	222:   "rsh-spx",
	223:   "cdc",
	224:   "masqdialer",
	242:   "direct",
	243:   "sur-meas",
	244:   "inbusiness",
	245:   "link",
	246:   "dsp3270",
	247:   "subntbcst-tftp",
	248:   "bhfhs",
	256:   "rap",
	257:   "set",
	259:   "esro-gen",
	260:   "openport",
	261:   "nsiiops",
	262:   "arcisdms",
	263:   "hdap",
	264:   "bgmp",
	265:   "x-bone-ctl",
	266:   "sst",
	267:   "td-service",
	268:   "td-replica",
	269:   "manet",
	271:   "pt-tls",
	280:   "http-mgmt",
	281:   "personal-link",
	282:   "cableport-ax",
	283:   "rescap",
	284:   "corerjd",
	286:   "fxp",
	287:   "k-block",
	308:   "novastorbakcup",
	309:   "entrusttime",
	310:   "bhmds",
	311:   "asip-webadmin",
	312:   "vslmp",
	313:   "magenta-logic",
	314:   "opalis-robot",
	315:   "dpsi",
	316:   "decauth",
	317:   "zannet",
	318:   "pkix-timestamp",
	319:   "ptp-event",
	320:   "ptp-general",
	321:   "pip",
	322:   "rtsps",
	323:   "rpki-rtr",
	324:   "rpki-rtr-tls",
	333:   "texar",
	344:   "pdap",
	345:   "pawserv",
	346:   "zserv",
	347:   "fatserv",
	348:   "csi-sgwp",
	349:   "mftp",
	350:   "matip-type-a",
	351:   "matip-type-b",
	352:   "dtag-ste-sb",
	353:   "ndsauth",
	354:   "bh611",
	355:   "datex-asn",
	356:   "cloanto-net-1",
	357:   "bhevent",
	358:   "shrinkwrap",
	359:   "nsrmp",
	360:   "scoi2odialog",
	361:   "semantix",
	362:   "srssend",
	363:   "rsvp-tunnel",
	364:   "aurora-cmgr",
	365:   "dtk",
	366:   "odmr",
	367:   "mortgageware",
	368:   "qbikgdp",
	369:   "rpc2portmap",
	370:   "codaauth2",
	371:   "clearcase",
	372:   "ulistproc",
	373:   "legent-1",
	374:   "legent-2",
	375:   "hassle",
	376:   "nip",
	377:   "tnETOS",
	378:   "dsETOS",
	379:   "is99c",
	380:   "is99s",
	381:   "hp-collector",
	382:   "hp-managed-node",
	383:   "hp-alarm-mgr",
	384:   "arns",
	385:   "ibm-app",
	386:   "asa",
	387:   "aurp",
	388:   "unidata-ldm",
	389:   "ldap",
	390:   "uis",
	391:   "synotics-relay",
	392:   "synotics-broker",
	393:   "meta5",
	394:   "embl-ndt",
	395:   "netcp",
	396:   "netware-ip",
	397:   "mptn",
	398:   "kryptolan",
	399:   "iso-tsap-c2",
	400:   "osb-sd",
	401:   "ups",
	402:   "genie",
	403:   "decap",
	404:   "nced",
	405:   "ncld",
	406:   "imsp",
	407:   "timbuktu",
	408:   "prm-sm",
	409:   "prm-nm",
	410:   "decladebug",
	411:   "rmt",
	412:   "synoptics-trap",
	413:   "smsp",
	414:   "infoseek",
	415:   "bnet",
	416:   "silverplatter",
	417:   "onmux",
	418:   "hyper-g",
	419:   "ariel1",
	420:   "smpte",
	421:   "ariel2",
	422:   "ariel3",
	423:   "opc-job-start",
	424:   "opc-job-track",
	425:   "icad-el",
	426:   "smartsdp",
	427:   "svrloc",
	428:   "ocs-cmu",
	429:   "ocs-amu",
	430:   "utmpsd",
	431:   "utmpcd",
	432:   "iasd",
	433:   "nnsp",
	434:   "mobileip-agent",
	435:   "mobilip-mn",
	436:   "dna-cml",
	437:   "comscm",
	438:   "dsfgw",
	439:   "dasp",
	440:   "sgcp",
	441:   "decvms-sysmgt",
	442:   "cvc-hostd",
	443:   "https",
	444:   "snpp",
	445:   "microsoft-ds",
	446:   "ddm-rdb",
	447:   "ddm-dfm",
	448:   "ddm-ssl",
	449:   "as-servermap",
	450:   "tserver",
	451:   "sfs-smp-net",
	452:   "sfs-config",
	453:   "creativeserver",
	454:   "contentserver",
	455:   "creativepartnr",
	456:   "macon-tcp",
	457:   "scohelp",
	458:   "appleqtc",
	459:   "ampr-rcmd",
	460:   "skronk",
	461:   "datasurfsrv",
	462:   "datasurfsrvsec",
	463:   "alpes",
	464:   "kpasswd",
	465:   "urd",
	466:   "digital-vrc",
	467:   "mylex-mapd",
	468:   "photuris",
	469:   "rcp",
	470:   "scx-proxy",
	471:   "mondex",
	472:   "ljk-login",
	473:   "hybrid-pop",
	474:   "tn-tl-w1",
	475:   "tcpnethaspsrv",
	476:   "tn-tl-fd1",
	477:   "ss7ns",
	478:   "spsc",
	479:   "iafserver",
	480:   "iafdbase",
	481:   "ph",
	482:   "bgs-nsi",
	483:   "ulpnet",
	484:   "integra-sme",
	485:   "powerburst",
	486:   "avian",
	487:   "saft",
	488:   "gss-http",
	489:   "nest-protocol",
	490:   "micom-pfs",
	491:   "go-login",
	492:   "ticf-1",
	493:   "ticf-2",
	494:   "pov-ray",
	495:   "intecourier",
	496:   "pim-rp-disc",
	497:   "retrospect",
	498:   "siam",
	499:   "iso-ill",
	500:   "isakmp",
	501:   "stmf",
	502:   "mbap",
	503:   "intrinsa",
	504:   "citadel",
	505:   "mailbox-lm",
	506:   "ohimsrv",
	507:   "crs",
	508:   "xvttp",
	509:   "snare",
	510:   "fcp",
	511:   "passgo",
	512:   "exec",
	513:   "login",
	514:   "shell",
	515:   "printer",
	516:   "videotex",
	517:   "talk",
	518:   "ntalk",
	519:   "utime",
	520:   "efs",
	521:   "ripng",
	522:   "ulp",
	523:   "ibm-db2",
	524:   "ncp",
	525:   "timed",
	526:   "tempo",
	527:   "stx",
	528:   "custix",
	529:   "irc-serv",
	530:   "courier",
	531:   "conference",
	532:   "netnews",
	533:   "netwall",
	534:   "windream",
	535:   "iiop",
	536:   "opalis-rdv",
	537:   "nmsp",
	538:   "gdomap",
	539:   "apertus-ldp",
	540:   "uucp",
	541:   "uucp-rlogin",
	542:   "commerce",
	543:   "klogin",
	544:   "kshell",
	545:   "appleqtcsrvr",
	546:   "dhcpv6-client",
	547:   "dhcpv6-server",
	548:   "afpovertcp",
	549:   "idfp",
	550:   "new-rwho",
	551:   "cybercash",
	552:   "devshr-nts",
	553:   "pirp",
	554:   "rtsp",
	555:   "dsf",
	556:   "remotefs",
	557:   "openvms-sysipc",
	558:   "sdnskmp",
	559:   "teedtap",
	560:   "rmonitor",
	561:   "monitor",
	562:   "chshell",
	563:   "nntps",
	564:   "9pfs",
	565:   "whoami",
	566:   "streettalk",
	567:   "banyan-rpc",
	568:   "ms-shuttle",
	569:   "ms-rome",
	570:   "meter",
	571:   "meter",
	572:   "sonar",
	573:   "banyan-vip",
	574:   "ftp-agent",
	575:   "vemmi",
	576:   "ipcd",
	577:   "vnas",
	578:   "ipdd",
	579:   "decbsrv",
	580:   "sntp-heartbeat",
	581:   "bdp",
	582:   "scc-security",
	583:   "philips-vc",
	584:   "keyserver",
	586:   "password-chg",
	587:   "submission",
	588:   "cal",
	589:   "eyelink",
	590:   "tns-cml",
	591:   "http-alt",
	592:   "eudora-set",
	593:   "http-rpc-epmap",
	594:   "tpip",
	595:   "cab-protocol",
	596:   "smsd",
	597:   "ptcnameservice",
	598:   "sco-websrvrmg3",
	599:   "acp",
	600:   "ipcserver",
	601:   "syslog-conn",
	602:   "xmlrpc-beep",
	603:   "idxp",
	604:   "tunnel",
	605:   "soap-beep",
	606:   "urm",
	607:   "nqs",
	608:   "sift-uft",
	609:   "npmp-trap",
	610:   "npmp-local",
	611:   "npmp-gui",
	612:   "hmmp-ind",
	613:   "hmmp-op",
	614:   "sshell",
	615:   "sco-inetmgr",
	616:   "sco-sysmgr",
	617:   "sco-dtmgr",
	618:   "dei-icda",
	619:   "compaq-evm",
	620:   "sco-websrvrmgr",
	621:   "escp-ip",
	622:   "collaborator",
	623:   "oob-ws-http",
	624:   "cryptoadmin",
	625:   "dec-dlm",
	626:   "asia",
	627:   "passgo-tivoli",
	628:   "qmqp",
	629:   "3com-amp3",
	630:   "rda",
	631:   "ipp",
	632:   "bmpp",
	633:   "servstat",
	634:   "ginad",
	635:   "rlzdbase",
	636:   "ldaps",
	637:   "lanserver",
	638:   "mcns-sec",
	639:   "msdp",
	640:   "entrust-sps",
	641:   "repcmd",
	642:   "esro-emsdp",
	643:   "sanity",
	644:   "dwr",
	645:   "pssc",
	646:   "ldp",
	647:   "dhcp-failover",
	648:   "rrp",
	649:   "cadview-3d",
	650:   "obex",
	651:   "ieee-mms",
	652:   "hello-port",
	653:   "repscmd",
	654:   "aodv",
	655:   "tinc",
	656:   "spmp",
	657:   "rmc",
	658:   "tenfold",
	660:   "mac-srvr-admin",
	661:   "hap",
	662:   "pftp",
	663:   "purenoise",
	664:   "oob-ws-https",
	665:   "sun-dr",
	666:   "mdqs",
	667:   "disclose",
	668:   "mecomm",
	669:   "meregister",
	670:   "vacdsm-sws",
	671:   "vacdsm-app",
	672:   "vpps-qua",
	673:   "cimplex",
	674:   "acap",
	675:   "dctp",
	676:   "vpps-via",
	677:   "vpp",
	678:   "ggf-ncp",
	679:   "mrm",
	680:   "entrust-aaas",
	681:   "entrust-aams",
	682:   "xfr",
	683:   "corba-iiop",
	684:   "corba-iiop-ssl",
	685:   "mdc-portmapper",
	686:   "hcp-wismar",
	687:   "asipregistry",
	688:   "realm-rusd",
	689:   "nmap",
	690:   "vatp",
	691:   "msexch-routing",
	692:   "hyperwave-isp",
	693:   "connendp",
	694:   "ha-cluster",
	695:   "ieee-mms-ssl",
	696:   "rushd",
	697:   "uuidgen",
	698:   "olsr",
	699:   "accessnetwork",
	700:   "epp",
	701:   "lmp",
	702:   "iris-beep",
	704:   "elcsd",
	705:   "agentx",
	706:   "silc",
	707:   "borland-dsj",
	709:   "entrust-kmsh",
	710:   "entrust-ash",
	711:   "cisco-tdp",
	712:   "tbrpf",
	713:   "iris-xpc",
	714:   "iris-xpcs",
	715:   "iris-lwz",
	729:   "netviewdm1",
	730:   "netviewdm2",
	731:   "netviewdm3",
	741:   "netgw",
	742:   "netrcs",
	744:   "flexlm",
	747:   "fujitsu-dev",
	748:   "ris-cm",
	749:   "kerberos-adm",
	750:   "rfile",
	751:   "pump",
	752:   "qrh",
	753:   "rrh",
	754:   "tell",
	758:   "nlogin",
	759:   "con",
	760:   "ns",
	761:   "rxe",
	762:   "quotad",
	763:   "cycleserv",
	764:   "omserv",
	765:   "webster",
	767:   "phonebook",
	769:   "vid",
	770:   "cadlock",
	771:   "rtip",
	772:   "cycleserv2",
	773:   "submit",
	774:   "rpasswd",
	775:   "entomb",
	776:   "wpages",
	777:   "multiling-http",
	780:   "wpgs",
	800:   "mdbs-daemon",
	801:   "device",
	802:   "mbap-s",
	810:   "fcp-udp",
	828:   "itm-mcell-s",
	829:   "pkix-3-ca-ra",
	830:   "netconf-ssh",
	831:   "netconf-beep",
	832:   "netconfsoaphttp",
	833:   "netconfsoapbeep",
	847:   "dhcp-failover2",
	848:   "gdoi",
	853:   "domain-s",
	854:   "dlep",
	860:   "iscsi",
	861:   "owamp-control",
	862:   "twamp-control",
	873:   "rsync",
	886:   "iclcnet-locate",
	887:   "iclcnet-svinfo",
	888:   "accessbuilder",
	900:   "omginitialrefs",
	901:   "smpnameres",
	902:   "ideafarm-door",
	903:   "ideafarm-panic",
	910:   "kink",
	911:   "xact-backup",
	912:   "apex-mesh",
	913:   "apex-edge",
	953:   "rndc",
	989:   "ftps-data",
	990:   "ftps",
	991:   "nas",
	992:   "telnets",
	993:   "imaps",
	995:   "pop3s",
	996:   "vsinet",
	997:   "maitrd",
	998:   "busboy",
	999:   "garcon",
	1000:  "cadlock2",
	1001:  "webpush",
	1010:  "surf",
	1021:  "exp1",
	1022:  "exp2",
	1025:  "blackjack",
	1026:  "cap",
	1029:  "solid-mux",
	1033:  "netinfo-local",
	1034:  "activesync",
	1035:  "mxxrlogin",
	1036:  "nsstp",
	1037:  "ams",
	1038:  "mtqp",
	1039:  "sbl",
	1040:  "netarx",
	1041:  "danf-ak2",
	1042:  "afrog",
	1043:  "boinc-client",
	1044:  "dcutility",
	1045:  "fpitp",
	1046:  "wfremotertm",
	1047:  "neod1",
	1048:  "neod2",
	1049:  "td-postman",
	1050:  "cma",
	1051:  "optima-vnet",
	1052:  "ddt",
	1053:  "remote-as",
	1054:  "brvread",
	1055:  "ansyslmd",
	1056:  "vfo",
	1057:  "startron",
	1058:  "nim",
	1059:  "nimreg",
	1060:  "polestar",
	1061:  "kiosk",
	1062:  "veracity",
	1063:  "kyoceranetdev",
	1064:  "jstel",
	1065:  "syscomlan",
	1066:  "fpo-fns",
	1067:  "instl-boots",
	1068:  "instl-bootc",
	1069:  "cognex-insight",
	1070:  "gmrupdateserv",
	1071:  "bsquare-voip",
	1072:  "cardax",
	1073:  "bridgecontrol",
	1074:  "warmspotMgmt",
	1075:  "rdrmshc",
	1076:  "dab-sti-c",
	1077:  "imgames",
	1078:  "avocent-proxy",
	1079:  "asprovatalk",
	1080:  "socks",
	1081:  "pvuniwien",
	1082:  "amt-esd-prot",
	1083:  "ansoft-lm-1",
	1084:  "ansoft-lm-2",
	1085:  "webobjects",
	1086:  "cplscrambler-lg",
	1087:  "cplscrambler-in",
	1088:  "cplscrambler-al",
	1089:  "ff-annunc",
	1090:  "ff-fms",
	1091:  "ff-sm",
	1092:  "obrpd",
	1093:  "proofd",
	1094:  "rootd",
	1095:  "nicelink",
	1096:  "cnrprotocol",
	1097:  "sunclustermgr",
	1098:  "rmiactivation",
	1099:  "rmiregistry",
	1100:  "mctp",
	1101:  "pt2-discover",
	1102:  "adobeserver-1",
	1103:  "adobeserver-2",
	1104:  "xrl",
	1105:  "ftranhc",
	1106:  "isoipsigport-1",
	1107:  "isoipsigport-2",
	1108:  "ratio-adp",
	1110:  "webadmstart",
	1111:  "lmsocialserver",
	1112:  "icp",
	1113:  "ltp-deepspace",
	1114:  "mini-sql",
	1115:  "ardus-trns",
	1116:  "ardus-cntl",
	1117:  "ardus-mtrns",
	1118:  "sacred",
	1119:  "bnetgame",
	1120:  "bnetfile",
	1121:  "rmpp",
	1122:  "availant-mgr",
	1123:  "murray",
	1124:  "hpvmmcontrol",
	1125:  "hpvmmagent",
	1126:  "hpvmmdata",
	1127:  "kwdb-commn",
	1128:  "saphostctrl",
	1129:  "saphostctrls",
	1130:  "casp",
	1131:  "caspssl",
	1132:  "kvm-via-ip",
	1133:  "dfn",
	1134:  "aplx",
	1135:  "omnivision",
	1136:  "hhb-gateway",
	1137:  "trim",
	1138:  "encrypted-admin",
	1139:  "evm",
	1140:  "autonoc",
	1141:  "mxomss",
	1142:  "edtools",
	1143:  "imyx",
	1144:  "fuscript",
	1145:  "x9-icue",
	1146:  "audit-transfer",
	1147:  "capioverlan",
	1148:  "elfiq-repl",
	1149:  "bvtsonar",
	1150:  "blaze",
	1151:  "unizensus",
	1152:  "winpoplanmess",
	1153:  "c1222-acse",
	1154:  "resacommunity",
	1155:  "nfa",
	1156:  "iascontrol-oms",
	1157:  "iascontrol",
	1158:  "dbcontrol-oms",
	1159:  "oracle-oms",
	1160:  "olsv",
	1161:  "health-polling",
	1162:  "health-trap",
	1163:  "sddp",
	1164:  "qsm-proxy",
	1165:  "qsm-gui",
	1166:  "qsm-remote",
	1167:  "cisco-ipsla",
	1168:  "vchat",
	1169:  "tripwire",
	1170:  "atc-lm",
	1171:  "atc-appserver",
	1172:  "dnap",
	1173:  "d-cinema-rrp",
	1174:  "fnet-remote-ui",
	1175:  "dossier",
	1176:  "indigo-server",
	1177:  "dkmessenger",
	1178:  "sgi-storman",
	1179:  "b2n",
	1180:  "mc-client",
	1181:  "3comnetman",
	1182:  "accelenet",
	1183:  "llsurfup-http",
	1184:  "llsurfup-https",
	1185:  "catchpole",
	1186:  "mysql-cluster",
	1187:  "alias",
	1188:  "hp-webadmin",
	1189:  "unet",
	1190:  "commlinx-avl",
	1191:  "gpfs",
	1192:  "caids-sensor",
	1193:  "fiveacross",
	1194:  "openvpn",
	1195:  "rsf-1",
	1196:  "netmagic",
	1197:  "carrius-rshell",
	1198:  "cajo-discovery",
	1199:  "dmidi",
	1200:  "scol",
	1201:  "nucleus-sand",
	1202:  "caiccipc",
	1203:  "ssslic-mgr",
	1204:  "ssslog-mgr",
	1205:  "accord-mgc",
	1206:  "anthony-data",
	1207:  "metasage",
	1208:  "seagull-ais",
	1209:  "ipcd3",
	1210:  "eoss",
	1211:  "groove-dpp",
	1212:  "lupa",
	1213:  "mpc-lifenet",
	1214:  "kazaa",
	1215:  "scanstat-1",
	1216:  "etebac5",
	1217:  "hpss-ndapi",
	1218:  "aeroflight-ads",
	1219:  "aeroflight-ret",
	1220:  "qt-serveradmin",
	1221:  "sweetware-apps",
	1222:  "nerv",
	1223:  "tgp",
	1224:  "vpnz",
	1225:  "slinkysearch",
	1226:  "stgxfws",
	1227:  "dns2go",
	1228:  "florence",
	1229:  "zented",
	1230:  "periscope",
	1231:  "menandmice-lpm",
	1232:  "first-defense",
	1233:  "univ-appserver",
	1234:  "search-agent",
	1235:  "mosaicsyssvc1",
	1236:  "bvcontrol",
	1237:  "tsdos390",
	1238:  "hacl-qs",
	1239:  "nmsd",
	1240:  "instantia",
	1241:  "nessus",
	1242:  "nmasoverip",
	1243:  "serialgateway",
	1244:  "isbconference1",
	1245:  "isbconference2",
	1246:  "payrouter",
	1247:  "visionpyramid",
	1248:  "hermes",
	1249:  "mesavistaco",
	1250:  "swldy-sias",
	1251:  "servergraph",
	1252:  "bspne-pcc",
	1253:  "q55-pcc",
	1254:  "de-noc",
	1255:  "de-cache-query",
	1256:  "de-server",
	1257:  "shockwave2",
	1258:  "opennl",
	1259:  "opennl-voice",
	1260:  "ibm-ssd",
	1261:  "mpshrsv",
	1262:  "qnts-orb",
	1263:  "dka",
	1264:  "prat",
	1265:  "dssiapi",
	1266:  "dellpwrappks",
	1267:  "epc",
	1268:  "propel-msgsys",
	1269:  "watilapp",
	1270:  "opsmgr",
	1271:  "excw",
	1272:  "cspmlockmgr",
	1273:  "emc-gateway",
	1274:  "t1distproc",
	1275:  "ivcollector",
	1277:  "miva-mqs",
	1278:  "dellwebadmin-1",
	1279:  "dellwebadmin-2",
	1280:  "pictrography",
	1281:  "healthd",
	1282:  "emperion",
	1283:  "productinfo",
	1284:  "iee-qfx",
	1285:  "neoiface",
	1286:  "netuitive",
	1287:  "routematch",
	1288:  "navbuddy",
	1289:  "jwalkserver",
	1290:  "winjaserver",
	1291:  "seagulllms",
	1292:  "dsdn",
	1293:  "pkt-krb-ipsec",
	1294:  "cmmdriver",
	1295:  "ehtp",
	1296:  "dproxy",
	1297:  "sdproxy",
	1298:  "lpcp",
	1299:  "hp-sci",
	1300:  "h323hostcallsc",
	1301:  "ci3-software-1",
	1302:  "ci3-software-2",
	1303:  "sftsrv",
	1304:  "boomerang",
	1305:  "pe-mike",
	1306:  "re-conn-proto",
	1307:  "pacmand",
	1308:  "odsi",
	1309:  "jtag-server",
	1310:  "husky",
	1311:  "rxmon",
	1312:  "sti-envision",
	1313:  "bmc-patroldb",
	1314:  "pdps",
	1315:  "els",
	1316:  "exbit-escp",
	1317:  "vrts-ipcserver",
	1318:  "krb5gatekeeper",
	1319:  "amx-icsp",
	1320:  "amx-axbnet",
	1321:  "pip",
	1322:  "novation",
	1323:  "brcd",
	1324:  "delta-mcp",
	1325:  "dx-instrument",
	1326:  "wimsic",
	1327:  "ultrex",
	1328:  "ewall",
	1329:  "netdb-export",
	1330:  "streetperfect",
	1331:  "intersan",
	1332:  "pcia-rxp-b",
	1333:  "passwrd-policy",
	1334:  "writesrv",
	1335:  "digital-notary",
	1336:  "ischat",
	1337:  "menandmice-dns",
	1338:  "wmc-log-svc",
	1339:  "kjtsiteserver",
	1340:  "naap",
	1341:  "qubes",
	1342:  "esbroker",
	1343:  "re101",
	1344:  "icap",
	1345:  "vpjp",
	1346:  "alta-ana-lm",
	1347:  "bbn-mmc",
	1348:  "bbn-mmx",
	1349:  "sbook",
	1350:  "editbench",
	1351:  "equationbuilder",
	1352:  "lotusnote",
	1353:  "relief",
	1354:  "XSIP-network",
	1355:  "intuitive-edge",
	1356:  "cuillamartin",
	1357:  "pegboard",
	1358:  "connlcli",
	1359:  "ftsrv",
	1360:  "mimer",
	1361:  "linx",
	1362:  "timeflies",
	1363:  "ndm-requester",
	1364:  "ndm-server",
	1365:  "adapt-sna",
	1366:  "netware-csp",
	1367:  "dcs",
	1368:  "screencast",
	1369:  "gv-us",
	1370:  "us-gv",
	1371:  "fc-cli",
	1372:  "fc-ser",
	1373:  "chromagrafx",
	1374:  "molly",
	1375:  "bytex",
	1376:  "ibm-pps",
	1377:  "cichlid",
	1378:  "elan",
	1379:  "dbreporter",
	1380:  "telesis-licman",
	1381:  "apple-licman",
	1382:  "udt-os",
	1383:  "gwha",
	1384:  "os-licman",
	1385:  "atex-elmd",
	1386:  "checksum",
	1387:  "cadsi-lm",
	1388:  "objective-dbc",
	1389:  "iclpv-dm",
	1390:  "iclpv-sc",
	1391:  "iclpv-sas",
	1392:  "iclpv-pm",
	1393:  "iclpv-nls",
	1394:  "iclpv-nlc",
	1395:  "iclpv-wsm",
	1396:  "dvl-activemail",
	1397:  "audio-activmail",
	1398:  "video-activmail",
	1399:  "cadkey-licman",
	1400:  "cadkey-tablet",
	1401:  "goldleaf-licman",
	1402:  "prm-sm-np",
	1403:  "prm-nm-np",
	1404:  "igi-lm",
	1405:  "ibm-res",
	1406:  "netlabs-lm",
	1407:  "tibet-server",
	1408:  "sophia-lm",
	1409:  "here-lm",
	1410:  "hiq",
	1411:  "af",
	1412:  "innosys",
	1413:  "innosys-acl",
	1414:  "ibm-mqseries",
	1415:  "dbstar",
	1416:  "novell-lu6-2",
	1417:  "timbuktu-srv1",
	1418:  "timbuktu-srv2",
	1419:  "timbuktu-srv3",
	1420:  "timbuktu-srv4",
	1421:  "gandalf-lm",
	1422:  "autodesk-lm",
	1423:  "essbase",
	1424:  "hybrid",
	1425:  "zion-lm",
	1426:  "sais",
	1427:  "mloadd",
	1428:  "informatik-lm",
	1429:  "nms",
	1430:  "tpdu",
	1431:  "rgtp",
	1432:  "blueberry-lm",
	1433:  "ms-sql-s",
	1434:  "ms-sql-m",
	1435:  "ibm-cics",
	1436:  "saism",
	1437:  "tabula",
	1438:  "eicon-server",
	1439:  "eicon-x25",
	1440:  "eicon-slp",
	1441:  "cadis-1",
	1442:  "cadis-2",
	1443:  "ies-lm",
	1444:  "marcam-lm",
	1445:  "proxima-lm",
	1446:  "ora-lm",
	1447:  "apri-lm",
	1448:  "oc-lm",
	1449:  "peport",
	1450:  "dwf",
	1451:  "infoman",
	1452:  "gtegsc-lm",
	1453:  "genie-lm",
	1454:  "interhdl-elmd",
	1455:  "esl-lm",
	1456:  "dca",
	1457:  "valisys-lm",
	1458:  "nrcabq-lm",
	1459:  "proshare1",
	1460:  "proshare2",
	1461:  "ibm-wrless-lan",
	1462:  "world-lm",
	1463:  "nucleus",
	1464:  "msl-lmd",
	1465:  "pipes",
	1466:  "oceansoft-lm",
	1467:  "csdmbase",
	1468:  "csdm",
	1469:  "aal-lm",
	1470:  "uaiact",
	1471:  "csdmbase",
	1472:  "csdm",
	1473:  "openmath",
	1474:  "telefinder",
	1475:  "taligent-lm",
	1476:  "clvm-cfg",
	1477:  "ms-sna-server",
	1478:  "ms-sna-base",
	1479:  "dberegister",
	1480:  "pacerforum",
	1481:  "airs",
	1482:  "miteksys-lm",
	1483:  "afs",
	1484:  "confluent",
	1485:  "lansource",
	1486:  "nms-topo-serv",
	1487:  "localinfosrvr",
	1488:  "docstor",
	1489:  "dmdocbroker",
	1490:  "insitu-conf",
	1492:  "stone-design-1",
	1493:  "netmap-lm",
	1494:  "ica",
	1495:  "cvc",
	1496:  "liberty-lm",
	1497:  "rfx-lm",
	1498:  "sybase-sqlany",
	1499:  "fhc",
	1500:  "vlsi-lm",
	1501:  "saiscm",
	1502:  "shivadiscovery",
	1503:  "imtc-mcs",
	1504:  "evb-elm",
	1505:  "funkproxy",
	1506:  "utcd",
	1507:  "symplex",
	1508:  "diagmond",
	1509:  "robcad-lm",
	1510:  "mvx-lm",
	1511:  "3l-l1",
	1512:  "wins",
	1513:  "fujitsu-dtc",
	1514:  "fujitsu-dtcns",
	1515:  "ifor-protocol",
	1516:  "vpad",
	1517:  "vpac",
	1518:  "vpvd",
	1519:  "vpvc",
	1520:  "atm-zip-office",
	1521:  "ncube-lm",
	1522:  "ricardo-lm",
	1523:  "cichild-lm",
	1524:  "ingreslock",
	1525:  "orasrv",
	1526:  "pdap-np",
	1527:  "tlisrv",
	1529:  "coauthor",
	1530:  "rap-service",
	1531:  "rap-listen",
	1532:  "miroconnect",
	1533:  "virtual-places",
	1534:  "micromuse-lm",
	1535:  "ampr-info",
	1536:  "ampr-inter",
	1537:  "sdsc-lm",
	1538:  "3ds-lm",
	1539:  "intellistor-lm",
	1540:  "rds",
	1541:  "rds2",
	1542:  "gridgen-elmd",
	1543:  "simba-cs",
	1544:  "aspeclmd",
	1545:  "vistium-share",
	1546:  "abbaccuray",
	1547:  "laplink",
	1548:  "axon-lm",
	1549:  "shivahose",
	1550:  "3m-image-lm",
	1551:  "hecmtl-db",
	1552:  "pciarray",
	1553:  "sna-cs",
	1554:  "caci-lm",
	1555:  "livelan",
	1556:  "veritas-pbx",
	1557:  "arbortext-lm",
	1558:  "xingmpeg",
	1559:  "web2host",
	1560:  "asci-val",
	1561:  "facilityview",
	1562:  "pconnectmgr",
	1563:  "cadabra-lm",
	1564:  "pay-per-view",
	1565:  "winddlb",
	1566:  "corelvideo",
	1567:  "jlicelmd",
	1568:  "tsspmap",
	1569:  "ets",
	1570:  "orbixd",
	1571:  "rdb-dbs-disp",
	1572:  "chip-lm",
	1573:  "itscomm-ns",
	1574:  "mvel-lm",
	1575:  "oraclenames",
	1576:  "moldflow-lm",
	1577:  "hypercube-lm",
	1578:  "jacobus-lm",
	1579:  "ioc-sea-lm",
	1580:  "tn-tl-r1",
	1581:  "mil-2045-47001",
	1582:  "msims",
	1583:  "simbaexpress",
	1584:  "tn-tl-fd2",
	1585:  "intv",
	1586:  "ibm-abtact",
	1587:  "pra-elmd",
	1588:  "triquest-lm",
	1589:  "vqp",
	1590:  "gemini-lm",
	1591:  "ncpm-pm",
	1592:  "commonspace",
	1593:  "mainsoft-lm",
	1594:  "sixtrak",
	1595:  "radio",
	1596:  "radio-sm",
	1597:  "orbplus-iiop",
	1598:  "picknfs",
	1599:  "simbaservices",
	1600:  "issd",
	1601:  "aas",
	1602:  "inspect",
	1603:  "picodbc",
	1604:  "icabrowser",
	1605:  "slp",
	1606:  "slm-api",
	1607:  "stt",
	1608:  "smart-lm",
	1609:  "isysg-lm",
	1610:  "taurus-wh",
	1611:  "ill",
	1612:  "netbill-trans",
	1613:  "netbill-keyrep",
	1614:  "netbill-cred",
	1615:  "netbill-auth",
	1616:  "netbill-prod",
	1617:  "nimrod-agent",
	1618:  "skytelnet",
	1619:  "xs-openstorage",
	1620:  "faxportwinport",
	1621:  "softdataphone",
	1622:  "ontime",
	1623:  "jaleosnd",
	1624:  "udp-sr-port",
	1625:  "svs-omagent",
	1626:  "shockwave",
	1627:  "t128-gateway",
	1628:  "lontalk-norm",
	1629:  "lontalk-urgnt",
	1630:  "oraclenet8cman",
	1631:  "visitview",
	1632:  "pammratc",
	1633:  "pammrpc",
	1634:  "loaprobe",
	1635:  "edb-server1",
	1636:  "isdc",
	1637:  "islc",
	1638:  "ismc",
	1639:  "cert-initiator",
	1640:  "cert-responder",
	1641:  "invision",
	1642:  "isis-am",
	1643:  "isis-ambc",
	1644:  "saiseh",
	1645:  "sightline",
	1646:  "sa-msg-port",
	1647:  "rsap",
	1648:  "concurrent-lm",
	1649:  "kermit",
	1650:  "nkd",
	1651:  "shiva-confsrvr",
	1652:  "xnmp",
	1653:  "alphatech-lm",
	1654:  "stargatealerts",
	1655:  "dec-mbadmin",
	1656:  "dec-mbadmin-h",
	1657:  "fujitsu-mmpdc",
	1658:  "sixnetudr",
	1659:  "sg-lm",
	1660:  "skip-mc-gikreq",
	1661:  "netview-aix-1",
	1662:  "netview-aix-2",
	1663:  "netview-aix-3",
	1664:  "netview-aix-4",
	1665:  "netview-aix-5",
	1666:  "netview-aix-6",
	1667:  "netview-aix-7",
	1668:  "netview-aix-8",
	1669:  "netview-aix-9",
	1670:  "netview-aix-10",
	1671:  "netview-aix-11",
	1672:  "netview-aix-12",
	1673:  "proshare-mc-1",
	1674:  "proshare-mc-2",
	1675:  "pdp",
	1676:  "netcomm1",
	1677:  "groupwise",
	1678:  "prolink",
	1679:  "darcorp-lm",
	1680:  "microcom-sbp",
	1681:  "sd-elmd",
	1682:  "lanyon-lantern",
	1683:  "ncpm-hip",
	1684:  "snaresecure",
	1685:  "n2nremote",
	1686:  "cvmon",
	1687:  "nsjtp-ctrl",
	1688:  "nsjtp-data",
	1689:  "firefox",
	1690:  "ng-umds",
	1691:  "empire-empuma",
	1692:  "sstsys-lm",
	1693:  "rrirtr",
	1694:  "rrimwm",
	1695:  "rrilwm",
	1696:  "rrifmm",
	1697:  "rrisat",
	1698:  "rsvp-encap-1",
	1699:  "rsvp-encap-2",
	1700:  "mps-raft",
	1701:  "l2f",
	1702:  "deskshare",
	1703:  "hb-engine",
	1704:  "bcs-broker",
	1705:  "slingshot",
	1706:  "jetform",
	1707:  "vdmplay",
	1708:  "gat-lmd",
	1709:  "centra",
	1710:  "impera",
	1711:  "pptconference",
	1712:  "registrar",
	1713:  "conferencetalk",
	1714:  "sesi-lm",
	1715:  "houdini-lm",
	1716:  "xmsg",
	1717:  "fj-hdnet",
	1718:  "h323gatedisc",
	1719:  "h323gatestat",
	1720:  "h323hostcall",
	1721:  "caicci",
	1722:  "hks-lm",
	1723:  "pptp",
	1724:  "csbphonemaster",
	1725:  "iden-ralp",
	1726:  "iberiagames",
	1727:  "winddx",
	1728:  "telindus",
	1729:  "citynl",
	1730:  "roketz",
	1731:  "msiccp",
	1732:  "proxim",
	1733:  "siipat",
	1734:  "cambertx-lm",
	1735:  "privatechat",
	1736:  "street-stream",
	1737:  "ultimad",
	1738:  "gamegen1",
	1739:  "webaccess",
	1740:  "encore",
	1741:  "cisco-net-mgmt",
	1742:  "3Com-nsd",
	1743:  "cinegrfx-lm",
	1744:  "ncpm-ft",
	1745:  "remote-winsock",
	1746:  "ftrapid-1",
	1747:  "ftrapid-2",
	1748:  "oracle-em1",
	1749:  "aspen-services",
	1750:  "sslp",
	1751:  "swiftnet",
	1752:  "lofr-lm",
	1753:  "predatar-comms",
	1754:  "oracle-em2",
	1755:  "ms-streaming",
	1756:  "capfast-lmd",
	1757:  "cnhrp",
	1758:  "tftp-mcast",
	1759:  "spss-lm",
	1760:  "www-ldap-gw",
	1761:  "cft-0",
	1762:  "cft-1",
	1763:  "cft-2",
	1764:  "cft-3",
	1765:  "cft-4",
	1766:  "cft-5",
	1767:  "cft-6",
	1768:  "cft-7",
	1769:  "bmc-net-adm",
	1770:  "bmc-net-svc",
	1771:  "vaultbase",
	1772:  "essweb-gw",
	1773:  "kmscontrol",
	1774:  "global-dtserv",
	1775:  "vdab",
	1776:  "femis",
	1777:  "powerguardian",
	1778:  "prodigy-intrnet",
	1779:  "pharmasoft",
	1780:  "dpkeyserv",
	1781:  "answersoft-lm",
	1782:  "hp-hcip",
	1784:  "finle-lm",
	1785:  "windlm",
	1786:  "funk-logger",
	1787:  "funk-license",
	1788:  "psmond",
	1789:  "hello",
	1790:  "nmsp",
	1791:  "ea1",
	1792:  "ibm-dt-2",
	1793:  "rsc-robot",
	1794:  "cera-bcm",
	1795:  "dpi-proxy",
	1796:  "vocaltec-admin",
	1797:  "uma",
	1798:  "etp",
	1799:  "netrisk",
	1800:  "ansys-lm",
	1801:  "msmq",
	1802:  "concomp1",
	1803:  "hp-hcip-gwy",
	1804:  "enl",
	1805:  "enl-name",
	1806:  "musiconline",
	1807:  "fhsp",
	1808:  "oracle-vp2",
	1809:  "oracle-vp1",
	1810:  "jerand-lm",
	1811:  "scientia-sdb",
	1812:  "radius",
	1813:  "radius-acct",
	1814:  "tdp-suite",
	1815:  "mmpft",
	1816:  "harp",
	1817:  "rkb-oscs",
	1818:  "etftp",
	1819:  "plato-lm",
	1820:  "mcagent",
	1821:  "donnyworld",
	1822:  "es-elmd",
	1823:  "unisys-lm",
	1824:  "metrics-pas",
	1825:  "direcpc-video",
	1826:  "ardt",
	1827:  "asi",
	1828:  "itm-mcell-u",
	1829:  "optika-emedia",
	1830:  "net8-cman",
	1831:  "myrtle",
	1832:  "tht-treasure",
	1833:  "udpradio",
	1834:  "ardusuni",
	1835:  "ardusmul",
	1836:  "ste-smsc",
	1837:  "csoft1",
	1838:  "talnet",
	1839:  "netopia-vo1",
	1840:  "netopia-vo2",
	1841:  "netopia-vo3",
	1842:  "netopia-vo4",
	1843:  "netopia-vo5",
	1844:  "direcpc-dll",
	1845:  "altalink",
	1846:  "tunstall-pnc",
	1847:  "slp-notify",
	1848:  "fjdocdist",
	1849:  "alpha-sms",
	1850:  "gsi",
	1851:  "ctcd",
	1852:  "virtual-time",
	1853:  "vids-avtp",
	1854:  "buddy-draw",
	1855:  "fiorano-rtrsvc",
	1856:  "fiorano-msgsvc",
	1857:  "datacaptor",
	1858:  "privateark",
	1859:  "gammafetchsvr",
	1860:  "sunscalar-svc",
	1861:  "lecroy-vicp",
	1862:  "mysql-cm-agent",
	1863:  "msnp",
	1864:  "paradym-31port",
	1865:  "entp",
	1866:  "swrmi",
	1867:  "udrive",
	1868:  "viziblebrowser",
	1869:  "transact",
	1870:  "sunscalar-dns",
	1871:  "canocentral0",
	1872:  "canocentral1",
	1873:  "fjmpjps",
	1874:  "fjswapsnp",
	1875:  "westell-stats",
	1876:  "ewcappsrv",
	1877:  "hp-webqosdb",
	1878:  "drmsmc",
	1879:  "nettgain-nms",
	1880:  "vsat-control",
	1881:  "ibm-mqseries2",
	1882:  "ecsqdmn",
	1883:  "mqtt",
	1884:  "idmaps",
	1885:  "vrtstrapserver",
	1886:  "leoip",
	1887:  "filex-lport",
	1888:  "ncconfig",
	1889:  "unify-adapter",
	1890:  "wilkenlistener",
	1891:  "childkey-notif",
	1892:  "childkey-ctrl",
	1893:  "elad",
	1894:  "o2server-port",
	1896:  "b-novative-ls",
	1897:  "metaagent",
	1898:  "cymtec-port",
	1899:  "mc2studios",
	1900:  "ssdp",
	1901:  "fjicl-tep-a",
	1902:  "fjicl-tep-b",
	1903:  "linkname",
	1904:  "fjicl-tep-c",
	1905:  "sugp",
	1906:  "tpmd",
	1907:  "intrastar",
	1908:  "dawn",
	1909:  "global-wlink",
	1910:  "ultrabac",
	1911:  "mtp",
	1912:  "rhp-iibp",
	1913:  "armadp",
	1914:  "elm-momentum",
	1915:  "facelink",
	1916:  "persona",
	1917:  "noagent",
	1918:  "can-nds",
	1919:  "can-dch",
	1920:  "can-ferret",
	1921:  "noadmin",
	1922:  "tapestry",
	1923:  "spice",
	1924:  "xiip",
	1925:  "discovery-port",
	1926:  "egs",
	1927:  "videte-cipc",
	1928:  "emsd-port",
	1929:  "bandwiz-system",
	1930:  "driveappserver",
	1931:  "amdsched",
	1932:  "ctt-broker",
	1933:  "xmapi",
	1934:  "xaapi",
	1935:  "macromedia-fcs",
	1936:  "jetcmeserver",
	1937:  "jwserver",
	1938:  "jwclient",
	1939:  "jvserver",
	1940:  "jvclient",
	1941:  "dic-aida",
	1942:  "res",
	1943:  "beeyond-media",
	1944:  "close-combat",
	1945:  "dialogic-elmd",
	1946:  "tekpls",
	1947:  "sentinelsrm",
	1948:  "eye2eye",
	1949:  "ismaeasdaqlive",
	1950:  "ismaeasdaqtest",
	1951:  "bcs-lmserver",
	1952:  "mpnjsc",
	1953:  "rapidbase",
	1954:  "abr-api",
	1955:  "abr-secure",
	1956:  "vrtl-vmf-ds",
	1957:  "unix-status",
	1958:  "dxadmind",
	1959:  "simp-all",
	1960:  "nasmanager",
	1961:  "bts-appserver",
	1962:  "biap-mp",
	1963:  "webmachine",
	1964:  "solid-e-engine",
	1965:  "tivoli-npm",
	1966:  "slush",
	1967:  "sns-quote",
	1968:  "lipsinc",
	1969:  "lipsinc1",
	1970:  "netop-rc",
	1971:  "netop-school",
	1972:  "intersys-cache",
	1973:  "dlsrap",
	1974:  "drp",
	1975:  "tcoflashagent",
	1976:  "tcoregagent",
	1977:  "tcoaddressbook",
	1978:  "unisql",
	1979:  "unisql-java",
	1980:  "pearldoc-xact",
	1981:  "p2pq",
	1982:  "estamp",
	1983:  "lhtp",
	1984:  "bb",
	1985:  "hsrp",
	1986:  "licensedaemon",
	1987:  "tr-rsrb-p1",
	1988:  "tr-rsrb-p2",
	1989:  "tr-rsrb-p3",
	1990:  "stun-p1",
	1991:  "stun-p2",
	1992:  "stun-p3",
	1993:  "snmp-tcp-port",
	1994:  "stun-port",
	1995:  "perf-port",
	1996:  "tr-rsrb-port",
	1997:  "gdp-port",
	1998:  "x25-svc-port",
	1999:  "tcp-id-port",
	2000:  "cisco-sccp",
	2001:  "dc",
	2002:  "globe",
	2003:  "brutus",
	2004:  "mailbox",
	2005:  "berknet",
	2006:  "invokator",
	2007:  "dectalk",
	2008:  "conf",
	2009:  "news",
	2010:  "search",
	2011:  "raid-cc",
	2012:  "ttyinfo",
	2013:  "raid-am",
	2014:  "troff",
	2015:  "cypress",
	2016:  "bootserver",
	2017:  "cypress-stat",
	2018:  "terminaldb",
	2019:  "whosockami",
	2020:  "xinupageserver",
	2021:  "servexec",
	2022:  "down",
	2023:  "xinuexpansion3",
	2024:  "xinuexpansion4",
	2025:  "ellpack",
	2026:  "scrabble",
	2027:  "shadowserver",
	2028:  "submitserver",
	2029:  "hsrpv6",
	2030:  "device2",
	2031:  "mobrien-chat",
	2032:  "blackboard",
	2033:  "glogger",
	2034:  "scoremgr",
	2035:  "imsldoc",
	2036:  "e-dpnet",
	2037:  "applus",
	2038:  "objectmanager",
	2039:  "prizma",
	2040:  "lam",
	2041:  "interbase",
	2042:  "isis",
	2043:  "isis-bcast",
	2044:  "rimsl",
	2045:  "cdfunc",
	2046:  "sdfunc",
	2047:  "dls",
	2048:  "dls-monitor",
	2049:  "shilp",
	2050:  "av-emb-config",
	2051:  "epnsdp",
	2052:  "clearvisn",
	2053:  "lot105-ds-upd",
	2054:  "weblogin",
	2055:  "iop",
	2056:  "omnisky",
	2057:  "rich-cp",
	2058:  "newwavesearch",
	2059:  "bmc-messaging",
	2060:  "teleniumdaemon",
	2061:  "netmount",
	2062:  "icg-swp",
	2063:  "icg-bridge",
	2064:  "icg-iprelay",
	2065:  "dlsrpn",
	2066:  "aura",
	2067:  "dlswpn",
	2068:  "avauthsrvprtcl",
	2069:  "event-port",
	2070:  "ah-esp-encap",
	2071:  "acp-port",
	2072:  "msync",
	2073:  "gxs-data-port",
	2074:  "vrtl-vmf-sa",
	2075:  "newlixengine",
	2076:  "newlixconfig",
	2077:  "tsrmagt",
	2078:  "tpcsrvr",
	2079:  "idware-router",
	2080:  "autodesk-nlm",
	2081:  "kme-trap-port",
	2082:  "infowave",
	2083:  "radsec",
	2084:  "sunclustergeo",
	2085:  "ada-cip",
	2086:  "gnunet",
	2087:  "eli",
	2088:  "ip-blf",
	2089:  "sep",
	2090:  "lrp",
	2091:  "prp",
	2092:  "descent3",
	2093:  "nbx-cc",
	2094:  "nbx-au",
	2095:  "nbx-ser",
	2096:  "nbx-dir",
	2097:  "jetformpreview",
	2098:  "dialog-port",
	2099:  "h2250-annex-g",
	2100:  "amiganetfs",
	2101:  "rtcm-sc104",
	2102:  "zephyr-srv",
	2103:  "zephyr-clt",
	2104:  "zephyr-hm",
	2105:  "minipay",
	2106:  "mzap",
	2107:  "bintec-admin",
	2108:  "comcam",
	2109:  "ergolight",
	2110:  "umsp",
	2111:  "dsatp",
	2112:  "idonix-metanet",
	2113:  "hsl-storm",
	2114:  "newheights",
	2115:  "kdm",
	2116:  "ccowcmr",
	2117:  "mentaclient",
	2118:  "mentaserver",
	2119:  "gsigatekeeper",
	2120:  "qencp",
	2121:  "scientia-ssdb",
	2122:  "caupc-remote",
	2123:  "gtp-control",
	2124:  "elatelink",
	2125:  "lockstep",
	2126:  "pktcable-cops",
	2127:  "index-pc-wb",
	2128:  "net-steward",
	2129:  "cs-live",
	2130:  "xds",
	2131:  "avantageb2b",
	2132:  "solera-epmap",
	2133:  "zymed-zpp",
	2134:  "avenue",
	2135:  "gris",
	2136:  "appworxsrv",
	2137:  "connect",
	2138:  "unbind-cluster",
	2139:  "ias-auth",
	2140:  "ias-reg",
	2141:  "ias-admind",
	2142:  "tdmoip",
	2143:  "lv-jc",
	2144:  "lv-ffx",
	2145:  "lv-pici",
	2146:  "lv-not",
	2147:  "lv-auth",
	2148:  "veritas-ucl",
	2149:  "acptsys",
	2150:  "dynamic3d",
	2151:  "docent",
	2152:  "gtp-user",
	2153:  "ctlptc",
	2154:  "stdptc",
	2155:  "brdptc",
	2156:  "trp",
	2157:  "xnds",
	2158:  "touchnetplus",
	2159:  "gdbremote",
	2160:  "apc-2160",
	2161:  "apc-2161",
	2162:  "navisphere",
	2163:  "navisphere-sec",
	2164:  "ddns-v3",
	2165:  "x-bone-api",
	2166:  "iwserver",
	2167:  "raw-serial",
	2168:  "easy-soft-mux",
	2169:  "brain",
	2170:  "eyetv",
	2171:  "msfw-storage",
	2172:  "msfw-s-storage",
	2173:  "msfw-replica",
	2174:  "msfw-array",
	2175:  "airsync",
	2176:  "rapi",
	2177:  "qwave",
	2178:  "bitspeer",
	2179:  "vmrdp",
	2180:  "mc-gt-srv",
	2181:  "eforward",
	2182:  "cgn-stat",
	2183:  "cgn-config",
	2184:  "nvd",
	2185:  "onbase-dds",
	2186:  "gtaua",
	2187:  "ssmc",
	2188:  "radware-rpm",
	2189:  "radware-rpm-s",
	2190:  "tivoconnect",
	2191:  "tvbus",
	2192:  "asdis",
	2193:  "drwcs",
	2197:  "mnp-exchange",
	2198:  "onehome-remote",
	2199:  "onehome-help",
	2200:  "ici",
	2201:  "ats",
	2202:  "imtc-map",
	2203:  "b2-runtime",
	2204:  "b2-license",
	2205:  "jps",
	2206:  "hpocbus",
	2207:  "hpssd",
	2208:  "hpiod",
	2209:  "rimf-ps",
	2210:  "noaaport",
	2211:  "emwin",
	2212:  "leecoposserver",
	2213:  "kali",
	2214:  "rpi",
	2215:  "ipcore",
	2216:  "vtu-comms",
	2217:  "gotodevice",
	2218:  "bounzza",
	2219:  "netiq-ncap",
	2220:  "netiq",
	2221:  "ethernet-ip-s",
	2222:  "EtherNet-IP-1",
	2223:  "rockwell-csp2",
	2224:  "efi-mg",
	2225:  "rcip-itu",
	2226:  "di-drm",
	2227:  "di-msg",
	2228:  "ehome-ms",
	2229:  "datalens",
	2230:  "queueadm",
	2231:  "wimaxasncp",
	2232:  "ivs-video",
	2233:  "infocrypt",
	2234:  "directplay",
	2235:  "sercomm-wlink",
	2236:  "nani",
	2237:  "optech-port1-lm",
	2238:  "aviva-sna",
	2239:  "imagequery",
	2240:  "recipe",
	2241:  "ivsd",
	2242:  "foliocorp",
	2243:  "magicom",
	2244:  "nmsserver",
	2245:  "hao",
	2246:  "pc-mta-addrmap",
	2247:  "antidotemgrsvr",
	2248:  "ums",
	2249:  "rfmp",
	2250:  "remote-collab",
	2251:  "dif-port",
	2252:  "njenet-ssl",
	2253:  "dtv-chan-req",
	2254:  "seispoc",
	2255:  "vrtp",
	2256:  "pcc-mfp",
	2257:  "simple-tx-rx",
	2258:  "rcts",
	2260:  "apc-2260",
	2261:  "comotionmaster",
	2262:  "comotionback",
	2263:  "ecwcfg",
	2264:  "apx500api-1",
	2265:  "apx500api-2",
	2266:  "mfserver",
	2267:  "ontobroker",
	2268:  "amt",
	2269:  "mikey",
	2270:  "starschool",
	2271:  "mmcals",
	2272:  "mmcal",
	2273:  "mysql-im",
	2274:  "pcttunnell",
	2275:  "ibridge-data",
	2276:  "ibridge-mgmt",
	2277:  "bluectrlproxy",
	2278:  "s3db",
	2279:  "xmquery",
	2280:  "lnvpoller",
	2281:  "lnvconsole",
	2282:  "lnvalarm",
	2283:  "lnvstatus",
	2284:  "lnvmaps",
	2285:  "lnvmailmon",
	2286:  "nas-metering",
	2287:  "dna",
	2288:  "netml",
	2289:  "dict-lookup",
	2290:  "sonus-logging",
	2291:  "eapsp",
	2292:  "mib-streaming",
	2293:  "npdbgmngr",
	2294:  "konshus-lm",
	2295:  "advant-lm",
	2296:  "theta-lm",
	2297:  "d2k-datamover1",
	2298:  "d2k-datamover2",
	2299:  "pc-telecommute",
	2300:  "cvmmon",
	2301:  "cpq-wbem",
	2302:  "binderysupport",
	2303:  "proxy-gateway",
	2304:  "attachmate-uts",
	2305:  "mt-scaleserver",
	2306:  "tappi-boxnet",
	2307:  "pehelp",
	2308:  "sdhelp",
	2309:  "sdserver",
	2310:  "sdclient",
	2311:  "messageservice",
	2312:  "wanscaler",
	2313:  "iapp",
	2314:  "cr-websystems",
	2315:  "precise-sft",
	2316:  "sent-lm",
	2317:  "attachmate-g32",
	2318:  "cadencecontrol",
	2319:  "infolibria",
	2320:  "siebel-ns",
	2321:  "rdlap",
	2322:  "ofsd",
	2323:  "3d-nfsd",
	2324:  "cosmocall",
	2325:  "ansysli",
	2326:  "idcp",
	2327:  "xingcsm",
	2328:  "netrix-sftm",
	2329:  "nvd",
	2330:  "tscchat",
	2331:  "agentview",
	2332:  "rcc-host",
	2333:  "snapp",
	2334:  "ace-client",
	2335:  "ace-proxy",
	2336:  "appleugcontrol",
	2337:  "ideesrv",
	2338:  "norton-lambert",
	2339:  "3com-webview",
	2340:  "wrs-registry",
	2341:  "xiostatus",
	2342:  "manage-exec",
	2343:  "nati-logos",
	2344:  "fcmsys",
	2345:  "dbm",
	2346:  "redstorm-join",
	2347:  "redstorm-find",
	2348:  "redstorm-info",
	2349:  "redstorm-diag",
	2350:  "psbserver",
	2351:  "psrserver",
	2352:  "pslserver",
	2353:  "pspserver",
	2354:  "psprserver",
	2355:  "psdbserver",
	2356:  "gxtelmd",
	2357:  "unihub-server",
	2358:  "futrix",
	2359:  "flukeserver",
	2360:  "nexstorindltd",
	2361:  "tl1",
	2362:  "digiman",
	2363:  "mediacntrlnfsd",
	2364:  "oi-2000",
	2365:  "dbref",
	2366:  "qip-login",
	2367:  "service-ctrl",
	2368:  "opentable",
	2370:  "l3-hbmon",
	2371:  "hp-rda",
	2372:  "lanmessenger",
	2373:  "remographlm",
	2374:  "hydra",
	2375:  "docker",
	2376:  "docker-s",
	2377:  "swarm",
	2379:  "etcd-client",
	2380:  "etcd-server",
	2381:  "compaq-https",
	2382:  "ms-olap3",
	2383:  "ms-olap4",
	2384:  "sd-request",
	2385:  "sd-data",
	2386:  "virtualtape",
	2387:  "vsamredirector",
	2388:  "mynahautostart",
	2389:  "ovsessionmgr",
	2390:  "rsmtp",
	2391:  "3com-net-mgmt",
	2392:  "tacticalauth",
	2393:  "ms-olap1",
	2394:  "ms-olap2",
	2395:  "lan900-remote",
	2396:  "wusage",
	2397:  "ncl",
	2398:  "orbiter",
	2399:  "fmpro-fdal",
	2400:  "opequus-server",
	2401:  "cvspserver",
	2402:  "taskmaster2000",
	2403:  "taskmaster2000",
	2404:  "iec-104",
	2405:  "trc-netpoll",
	2406:  "jediserver",
	2407:  "orion",
	2408:  "railgun-webaccl",
	2409:  "sns-protocol",
	2410:  "vrts-registry",
	2411:  "netwave-ap-mgmt",
	2412:  "cdn",
	2413:  "orion-rmi-reg",
	2414:  "beeyond",
	2415:  "codima-rtp",
	2416:  "rmtserver",
	2417:  "composit-server",
	2418:  "cas",
	2419:  "attachmate-s2s",
	2420:  "dslremote-mgmt",
	2421:  "g-talk",
	2422:  "crmsbits",
	2423:  "rnrp",
	2424:  "kofax-svr",
	2425:  "fjitsuappmgr",
	2426:  "vcmp",
	2427:  "mgcp-gateway",
	2428:  "ott",
	2429:  "ft-role",
	2430:  "venus",
	2431:  "venus-se",
	2432:  "codasrv",
	2433:  "codasrv-se",
	2434:  "pxc-epmap",
	2435:  "optilogic",
	2436:  "topx",
	2437:  "unicontrol",
	2438:  "msp",
	2439:  "sybasedbsynch",
	2440:  "spearway",
	2441:  "pvsw-inet",
	2442:  "netangel",
	2443:  "powerclientcsf",
	2444:  "btpp2sectrans",
	2445:  "dtn1",
	2446:  "bues-service",
	2447:  "ovwdb",
	2448:  "hpppssvr",
	2449:  "ratl",
	2450:  "netadmin",
	2451:  "netchat",
	2452:  "snifferclient",
	2453:  "madge-ltd",
	2454:  "indx-dds",
	2455:  "wago-io-system",
	2456:  "altav-remmgt",
	2457:  "rapido-ip",
	2458:  "griffin",
	2459:  "community",
	2460:  "ms-theater",
	2461:  "qadmifoper",
	2462:  "qadmifevent",
	2463:  "lsi-raid-mgmt",
	2464:  "direcpc-si",
	2465:  "lbm",
	2466:  "lbf",
	2467:  "high-criteria",
	2468:  "qip-msgd",
	2469:  "mti-tcs-comm",
	2470:  "taskman-port",
	2471:  "seaodbc",
	2472:  "c3",
	2473:  "aker-cdp",
	2474:  "vitalanalysis",
	2475:  "ace-server",
	2476:  "ace-svr-prop",
	2477:  "ssm-cvs",
	2478:  "ssm-cssps",
	2479:  "ssm-els",
	2480:  "powerexchange",
	2481:  "giop",
	2482:  "giop-ssl",
	2483:  "ttc",
	2484:  "ttc-ssl",
	2485:  "netobjects1",
	2486:  "netobjects2",
	2487:  "pns",
	2488:  "moy-corp",
	2489:  "tsilb",
	2490:  "qip-qdhcp",
	2491:  "conclave-cpp",
	2492:  "groove",
	2493:  "talarian-mqs",
	2494:  "bmc-ar",
	2495:  "fast-rem-serv",
	2496:  "dirgis",
	2497:  "quaddb",
	2498:  "odn-castraq",
	2499:  "unicontrol",
	2500:  "rtsserv",
	2501:  "rtsclient",
	2502:  "kentrox-prot",
	2503:  "nms-dpnss",
	2504:  "wlbs",
	2505:  "ppcontrol",
	2506:  "jbroker",
	2507:  "spock",
	2508:  "jdatastore",
	2509:  "fjmpss",
	2510:  "fjappmgrbulk",
	2511:  "metastorm",
	2512:  "citrixima",
	2513:  "citrixadmin",
	2514:  "facsys-ntp",
	2515:  "facsys-router",
	2516:  "maincontrol",
	2517:  "call-sig-trans",
	2518:  "willy",
	2519:  "globmsgsvc",
	2520:  "pvsw",
	2521:  "adaptecmgr",
	2522:  "windb",
	2523:  "qke-llc-v3",
	2524:  "optiwave-lm",
	2525:  "ms-v-worlds",
	2526:  "ema-sent-lm",
	2527:  "iqserver",
	2528:  "ncr-ccl",
	2529:  "utsftp",
	2530:  "vrcommerce",
	2531:  "ito-e-gui",
	2532:  "ovtopmd",
	2533:  "snifferserver",
	2534:  "combox-web-acc",
	2535:  "madcap",
	2536:  "btpp2audctr1",
	2537:  "upgrade",
	2538:  "vnwk-prapi",
	2539:  "vsiadmin",
	2540:  "lonworks",
	2541:  "lonworks2",
	2542:  "udrawgraph",
	2543:  "reftek",
	2544:  "novell-zen",
	2545:  "sis-emt",
	2546:  "vytalvaultbrtp",
	2547:  "vytalvaultvsmp",
	2548:  "vytalvaultpipe",
	2549:  "ipass",
	2550:  "ads",
	2551:  "isg-uda-server",
	2552:  "call-logging",
	2553:  "efidiningport",
	2554:  "vcnet-link-v10",
	2555:  "compaq-wcp",
	2556:  "nicetec-nmsvc",
	2557:  "nicetec-mgmt",
	2558:  "pclemultimedia",
	2559:  "lstp",
	2560:  "labrat",
	2561:  "mosaixcc",
	2562:  "delibo",
	2563:  "cti-redwood",
	2564:  "hp-3000-telnet",
	2565:  "coord-svr",
	2566:  "pcs-pcw",
	2567:  "clp",
	2568:  "spamtrap",
	2569:  "sonuscallsig",
	2570:  "hs-port",
	2571:  "cecsvc",
	2572:  "ibp",
	2573:  "trustestablish",
	2574:  "blockade-bpsp",
	2575:  "hl7",
	2576:  "tclprodebugger",
	2577:  "scipticslsrvr",
	2578:  "rvs-isdn-dcp",
	2579:  "mpfoncl",
	2580:  "tributary",
	2581:  "argis-te",
	2582:  "argis-ds",
	2583:  "mon",
	2584:  "cyaserv",
	2585:  "netx-server",
	2586:  "netx-agent",
	2587:  "masc",
	2588:  "privilege",
	2589:  "quartus-tcl",
	2590:  "idotdist",
	2591:  "maytagshuffle",
	2592:  "netrek",
	2593:  "mns-mail",
	2594:  "dts",
	2595:  "worldfusion1",
	2596:  "worldfusion2",
	2597:  "homesteadglory",
	2598:  "citriximaclient",
	2599:  "snapd",
	2600:  "hpstgmgr",
	2601:  "discp-client",
	2602:  "discp-server",
	2603:  "servicemeter",
	2604:  "nsc-ccs",
	2605:  "nsc-posa",
	2606:  "netmon",
	2607:  "connection",
	2608:  "wag-service",
	2609:  "system-monitor",
	2610:  "versa-tek",
	2611:  "lionhead",
	2612:  "qpasa-agent",
	2613:  "smntubootstrap",
	2614:  "neveroffline",
	2615:  "firepower",
	2616:  "appswitch-emp",
	2617:  "cmadmin",
	2618:  "priority-e-com",
	2619:  "bruce",
	2620:  "lpsrecommender",
	2621:  "miles-apart",
	2622:  "metricadbc",
	2623:  "lmdp",
	2624:  "aria",
	2625:  "blwnkl-port",
	2626:  "gbjd816",
	2627:  "moshebeeri",
	2628:  "dict",
	2629:  "sitaraserver",
	2630:  "sitaramgmt",
	2631:  "sitaradir",
	2632:  "irdg-post",
	2633:  "interintelli",
	2634:  "pk-electronics",
	2635:  "backburner",
	2636:  "solve",
	2637:  "imdocsvc",
	2638:  "sybaseanywhere",
	2639:  "aminet",
	2640:  "ami-control",
	2641:  "hdl-srv",
	2642:  "tragic",
	2643:  "gte-samp",
	2644:  "travsoft-ipx-t",
	2645:  "novell-ipx-cmd",
	2646:  "and-lm",
	2647:  "syncserver",
	2648:  "upsnotifyprot",
	2649:  "vpsipport",
	2650:  "eristwoguns",
	2651:  "ebinsite",
	2652:  "interpathpanel",
	2653:  "sonus",
	2654:  "corel-vncadmin",
	2655:  "unglue",
	2656:  "kana",
	2657:  "sns-dispatcher",
	2658:  "sns-admin",
	2659:  "sns-query",
	2660:  "gcmonitor",
	2661:  "olhost",
	2662:  "bintec-capi",
	2663:  "bintec-tapi",
	2664:  "patrol-mq-gm",
	2665:  "patrol-mq-nm",
	2666:  "extensis",
	2667:  "alarm-clock-s",
	2668:  "alarm-clock-c",
	2669:  "toad",
	2670:  "tve-announce",
	2671:  "newlixreg",
	2672:  "nhserver",
	2673:  "firstcall42",
	2674:  "ewnn",
	2675:  "ttc-etap",
	2676:  "simslink",
	2677:  "gadgetgate1way",
	2678:  "gadgetgate2way",
	2679:  "syncserverssl",
	2680:  "pxc-sapxom",
	2681:  "mpnjsomb",
	2683:  "ncdloadbalance",
	2684:  "mpnjsosv",
	2685:  "mpnjsocl",
	2686:  "mpnjsomg",
	2687:  "pq-lic-mgmt",
	2688:  "md-cg-http",
	2689:  "fastlynx",
	2690:  "hp-nnm-data",
	2691:  "itinternet",
	2692:  "admins-lms",
	2694:  "pwrsevent",
	2695:  "vspread",
	2696:  "unifyadmin",
	2697:  "oce-snmp-trap",
	2698:  "mck-ivpip",
	2699:  "csoft-plusclnt",
	2700:  "tqdata",
	2701:  "sms-rcinfo",
	2702:  "sms-xfer",
	2703:  "sms-chat",
	2704:  "sms-remctrl",
	2705:  "sds-admin",
	2706:  "ncdmirroring",
	2707:  "emcsymapiport",
	2708:  "banyan-net",
	2709:  "supermon",
	2710:  "sso-service",
	2711:  "sso-control",
	2712:  "aocp",
	2713:  "raventbs",
	2714:  "raventdm",
	2715:  "hpstgmgr2",
	2716:  "inova-ip-disco",
	2717:  "pn-requester",
	2718:  "pn-requester2",
	2719:  "scan-change",
	2720:  "wkars",
	2721:  "smart-diagnose",
	2722:  "proactivesrvr",
	2723:  "watchdog-nt",
	2724:  "qotps",
	2725:  "msolap-ptp2",
	2726:  "tams",
	2727:  "mgcp-callagent",
	2728:  "sqdr",
	2729:  "tcim-control",
	2730:  "nec-raidplus",
	2731:  "fyre-messanger",
	2732:  "g5m",
	2733:  "signet-ctf",
	2734:  "ccs-software",
	2735:  "netiq-mc",
	2736:  "radwiz-nms-srv",
	2737:  "srp-feedback",
	2738:  "ndl-tcp-ois-gw",
	2739:  "tn-timing",
	2740:  "alarm",
	2741:  "tsb",
	2742:  "tsb2",
	2743:  "murx",
	2744:  "honyaku",
	2745:  "urbisnet",
	2746:  "cpudpencap",
	2747:  "fjippol-swrly",
	2748:  "fjippol-polsvr",
	2749:  "fjippol-cnsl",
	2750:  "fjippol-port1",
	2751:  "fjippol-port2",
	2752:  "rsisysaccess",
	2753:  "de-spot",
	2754:  "apollo-cc",
	2755:  "expresspay",
	2756:  "simplement-tie",
	2757:  "cnrp",
	2758:  "apollo-status",
	2759:  "apollo-gms",
	2760:  "sabams",
	2761:  "dicom-iscl",
	2762:  "dicom-tls",
	2763:  "desktop-dna",
	2764:  "data-insurance",
	2765:  "qip-audup",
	2766:  "compaq-scp",
	2767:  "uadtc",
	2768:  "uacs",
	2769:  "exce",
	2770:  "veronica",
	2771:  "vergencecm",
	2772:  "auris",
	2773:  "rbakcup1",
	2774:  "rbakcup2",
	2775:  "smpp",
	2776:  "ridgeway1",
	2777:  "ridgeway2",
	2778:  "gwen-sonya",
	2779:  "lbc-sync",
	2780:  "lbc-control",
	2781:  "whosells",
	2782:  "everydayrc",
	2783:  "aises",
	2784:  "www-dev",
	2785:  "aic-np",
	2786:  "aic-oncrpc",
	2787:  "piccolo",
	2788:  "fryeserv",
	2789:  "media-agent",
	2790:  "plgproxy",
	2791:  "mtport-regist",
	2792:  "f5-globalsite",
	2793:  "initlsmsad",
	2795:  "livestats",
	2796:  "ac-tech",
	2797:  "esp-encap",
	2798:  "tmesis-upshot",
	2799:  "icon-discover",
	2800:  "acc-raid",
	2801:  "igcp",
	2802:  "veritas-tcp1",
	2803:  "btprjctrl",
	2804:  "dvr-esm",
	2805:  "wta-wsp-s",
	2806:  "cspuni",
	2807:  "cspmulti",
	2808:  "j-lan-p",
	2809:  "corbaloc",
	2810:  "netsteward",
	2811:  "gsiftp",
	2812:  "atmtcp",
	2813:  "llm-pass",
	2814:  "llm-csv",
	2815:  "lbc-measure",
	2816:  "lbc-watchdog",
	2817:  "nmsigport",
	2818:  "rmlnk",
	2819:  "fc-faultnotify",
	2820:  "univision",
	2821:  "vrts-at-port",
	2822:  "ka0wuc",
	2823:  "cqg-netlan",
	2824:  "cqg-netlan-1",
	2826:  "slc-systemlog",
	2827:  "slc-ctrlrloops",
	2828:  "itm-lm",
	2829:  "silkp1",
	2830:  "silkp2",
	2831:  "silkp3",
	2832:  "silkp4",
	2833:  "glishd",
	2834:  "evtp",
	2835:  "evtp-data",
	2836:  "catalyst",
	2837:  "repliweb",
	2838:  "starbot",
	2839:  "nmsigport",
	2840:  "l3-exprt",
	2841:  "l3-ranger",
	2842:  "l3-hawk",
	2843:  "pdnet",
	2844:  "bpcp-poll",
	2845:  "bpcp-trap",
	2846:  "aimpp-hello",
	2847:  "aimpp-port-req",
	2848:  "amt-blc-port",
	2849:  "fxp",
	2850:  "metaconsole",
	2851:  "webemshttp",
	2852:  "bears-01",
	2853:  "ispipes",
	2854:  "infomover",
	2855:  "msrp",
	2856:  "cesdinv",
	2857:  "simctlp",
	2858:  "ecnp",
	2859:  "activememory",
	2860:  "dialpad-voice1",
	2861:  "dialpad-voice2",
	2862:  "ttg-protocol",
	2863:  "sonardata",
	2864:  "astromed-main",
	2865:  "pit-vpn",
	2866:  "iwlistener",
	2867:  "esps-portal",
	2868:  "npep-messaging",
	2869:  "icslap",
	2870:  "daishi",
	2871:  "msi-selectplay",
	2872:  "radix",
	2874:  "dxmessagebase1",
	2875:  "dxmessagebase2",
	2876:  "sps-tunnel",
	2877:  "bluelance",
	2878:  "aap",
	2879:  "ucentric-ds",
	2880:  "synapse",
	2881:  "ndsp",
	2882:  "ndtp",
	2883:  "ndnp",
	2884:  "flashmsg",
	2885:  "topflow",
	2886:  "responselogic",
	2887:  "aironetddp",
	2888:  "spcsdlobby",
	2889:  "rsom",
	2890:  "cspclmulti",
	2891:  "cinegrfx-elmd",
	2892:  "snifferdata",
	2893:  "vseconnector",
	2894:  "abacus-remote",
	2895:  "natuslink",
	2896:  "ecovisiong6-1",
	2897:  "citrix-rtmp",
	2898:  "appliance-cfg",
	2899:  "powergemplus",
	2900:  "quicksuite",
	2901:  "allstorcns",
	2902:  "netaspi",
	2903:  "suitcase",
	2904:  "m2ua",
	2905:  "m3ua",
	2906:  "caller9",
	2907:  "webmethods-b2b",
	2908:  "mao",
	2909:  "funk-dialout",
	2910:  "tdaccess",
	2911:  "blockade",
	2912:  "epicon",
	2913:  "boosterware",
	2914:  "gamelobby",
	2915:  "tksocket",
	2916:  "elvin-server",
	2917:  "elvin-client",
	2918:  "kastenchasepad",
	2919:  "roboer",
	2920:  "roboeda",
	2921:  "cesdcdman",
	2922:  "cesdcdtrn",
	2923:  "wta-wsp-wtp-s",
	2924:  "precise-vip",
	2926:  "mobile-file-dl",
	2927:  "unimobilectrl",
	2928:  "redstone-cpss",
	2929:  "amx-webadmin",
	2930:  "amx-weblinx",
	2931:  "circle-x",
	2932:  "incp",
	2933:  "4-tieropmgw",
	2934:  "4-tieropmcli",
	2935:  "qtp",
	2936:  "otpatch",
	2937:  "pnaconsult-lm",
	2938:  "sm-pas-1",
	2939:  "sm-pas-2",
	2940:  "sm-pas-3",
	2941:  "sm-pas-4",
	2942:  "sm-pas-5",
	2943:  "ttnrepository",
	2944:  "megaco-h248",
	2945:  "h248-binary",
	2946:  "fjsvmpor",
	2947:  "gpsd",
	2948:  "wap-push",
	2949:  "wap-pushsecure",
	2950:  "esip",
	2951:  "ottp",
	2952:  "mpfwsas",
	2953:  "ovalarmsrv",
	2954:  "ovalarmsrv-cmd",
	2955:  "csnotify",
	2956:  "ovrimosdbman",
	2957:  "jmact5",
	2958:  "jmact6",
	2959:  "rmopagt",
	2960:  "dfoxserver",
	2961:  "boldsoft-lm",
	2962:  "iph-policy-cli",
	2963:  "iph-policy-adm",
	2964:  "bullant-srap",
	2965:  "bullant-rap",
	2966:  "idp-infotrieve",
	2967:  "ssc-agent",
	2968:  "enpp",
	2969:  "essp",
	2970:  "index-net",
	2971:  "netclip",
	2972:  "pmsm-webrctl",
	2973:  "svnetworks",
	2974:  "signal",
	2975:  "fjmpcm",
	2976:  "cns-srv-port",
	2977:  "ttc-etap-ns",
	2978:  "ttc-etap-ds",
	2979:  "h263-video",
	2980:  "wimd",
	2981:  "mylxamport",
	2982:  "iwb-whiteboard",
	2983:  "netplan",
	2984:  "hpidsadmin",
	2985:  "hpidsagent",
	2986:  "stonefalls",
	2987:  "identify",
	2988:  "hippad",
	2989:  "zarkov",
	2990:  "boscap",
	2991:  "wkstn-mon",
	2992:  "avenyo",
	2993:  "veritas-vis1",
	2994:  "veritas-vis2",
	2995:  "idrs",
	2996:  "vsixml",
	2997:  "rebol",
	2998:  "realsecure",
	2999:  "remoteware-un",
	3000:  "hbci",
	3001:  "origo-native",
	3002:  "exlm-agent",
	3003:  "cgms",
	3004:  "csoftragent",
	3005:  "geniuslm",
	3006:  "ii-admin",
	3007:  "lotusmtap",
	3008:  "midnight-tech",
	3009:  "pxc-ntfy",
	3010:  "gw",
	3011:  "trusted-web",
	3012:  "twsdss",
	3013:  "gilatskysurfer",
	3014:  "broker-service",
	3015:  "nati-dstp",
	3016:  "notify-srvr",
	3017:  "event-listener",
	3018:  "srvc-registry",
	3019:  "resource-mgr",
	3020:  "cifs",
	3021:  "agriserver",
	3022:  "csregagent",
	3023:  "magicnotes",
	3024:  "nds-sso",
	3025:  "arepa-raft",
	3026:  "agri-gateway",
	3027:  "LiebDevMgmt-C",
	3028:  "LiebDevMgmt-DM",
	3029:  "LiebDevMgmt-A",
	3030:  "arepa-cas",
	3031:  "eppc",
	3032:  "redwood-chat",
	3033:  "pdb",
	3034:  "osmosis-aeea",
	3035:  "fjsv-gssagt",
	3036:  "hagel-dump",
	3037:  "hp-san-mgmt",
	3038:  "santak-ups",
	3039:  "cogitate",
	3040:  "tomato-springs",
	3041:  "di-traceware",
	3042:  "journee",
	3043:  "brp",
	3044:  "epp",
	3045:  "responsenet",
	3046:  "di-ase",
	3047:  "hlserver",
	3048:  "pctrader",
	3049:  "nsws",
	3050:  "gds-db",
	3051:  "galaxy-server",
	3052:  "apc-3052",
	3053:  "dsom-server",
	3054:  "amt-cnf-prot",
	3055:  "policyserver",
	3056:  "cdl-server",
	3057:  "goahead-fldup",
	3058:  "videobeans",
	3059:  "qsoft",
	3060:  "interserver",
	3061:  "cautcpd",
	3062:  "ncacn-ip-tcp",
	3063:  "ncadg-ip-udp",
	3064:  "rprt",
	3065:  "slinterbase",
	3066:  "netattachsdmp",
	3067:  "fjhpjp",
	3068:  "ls3bcast",
	3069:  "ls3",
	3070:  "mgxswitch",
	3071:  "xplat-replicate",
	3072:  "csd-monitor",
	3073:  "vcrp",
	3074:  "xbox",
	3075:  "orbix-locator",
	3076:  "orbix-config",
	3077:  "orbix-loc-ssl",
	3078:  "orbix-cfg-ssl",
	3079:  "lv-frontpanel",
	3080:  "stm-pproc",
	3081:  "tl1-lv",
	3082:  "tl1-raw",
	3083:  "tl1-telnet",
	3084:  "itm-mccs",
	3085:  "pcihreq",
	3086:  "jdl-dbkitchen",
	3087:  "asoki-sma",
	3088:  "xdtp",
	3089:  "ptk-alink",
	3090:  "stss",
	3091:  "1ci-smcs",
	3093:  "rapidmq-center",
	3094:  "rapidmq-reg",
	3095:  "panasas",
	3096:  "ndl-aps",
	3098:  "umm-port",
	3099:  "chmd",
	3100:  "opcon-xps",
	3101:  "hp-pxpib",
	3102:  "slslavemon",
	3103:  "autocuesmi",
	3104:  "autocuelog",
	3105:  "cardbox",
	3106:  "cardbox-http",
	3107:  "business",
	3108:  "geolocate",
	3109:  "personnel",
	3110:  "sim-control",
	3111:  "wsynch",
	3112:  "ksysguard",
	3113:  "cs-auth-svr",
	3114:  "ccmad",
	3115:  "mctet-master",
	3116:  "mctet-gateway",
	3117:  "mctet-jserv",
	3118:  "pkagent",
	3119:  "d2000kernel",
	3120:  "d2000webserver",
	3121:  "pcmk-remote",
	3122:  "vtr-emulator",
	3123:  "edix",
	3124:  "beacon-port",
	3125:  "a13-an",
	3127:  "ctx-bridge",
	3128:  "ndl-aas",
	3129:  "netport-id",
	3130:  "icpv2",
	3131:  "netbookmark",
	3132:  "ms-rule-engine",
	3133:  "prism-deploy",
	3134:  "ecp",
	3135:  "peerbook-port",
	3136:  "grubd",
	3137:  "rtnt-1",
	3138:  "rtnt-2",
	3139:  "incognitorv",
	3140:  "ariliamulti",
	3141:  "vmodem",
	3142:  "rdc-wh-eos",
	3143:  "seaview",
	3144:  "tarantella",
	3145:  "csi-lfap",
	3146:  "bears-02",
	3147:  "rfio",
	3148:  "nm-game-admin",
	3149:  "nm-game-server",
	3150:  "nm-asses-admin",
	3151:  "nm-assessor",
	3152:  "feitianrockey",
	3153:  "s8-client-port",
	3154:  "ccmrmi",
	3155:  "jpegmpeg",
	3156:  "indura",
	3157:  "e3consultants",
	3158:  "stvp",
	3159:  "navegaweb-port",
	3160:  "tip-app-server",
	3161:  "doc1lm",
	3162:  "sflm",
	3163:  "res-sap",
	3164:  "imprs",
	3165:  "newgenpay",
	3166:  "sossecollector",
	3167:  "nowcontact",
	3168:  "poweronnud",
	3169:  "serverview-as",
	3170:  "serverview-asn",
	3171:  "serverview-gf",
	3172:  "serverview-rm",
	3173:  "serverview-icc",
	3174:  "armi-server",
	3175:  "t1-e1-over-ip",
	3176:  "ars-master",
	3177:  "phonex-port",
	3178:  "radclientport",
	3179:  "h2gf-w-2m",
	3180:  "mc-brk-srv",
	3181:  "bmcpatrolagent",
	3182:  "bmcpatrolrnvu",
	3183:  "cops-tls",
	3184:  "apogeex-port",
	3185:  "smpppd",
	3186:  "iiw-port",
	3187:  "odi-port",
	3188:  "brcm-comm-port",
	3189:  "pcle-infex",
	3190:  "csvr-proxy",
	3191:  "csvr-sslproxy",
	3192:  "firemonrcc",
	3193:  "spandataport",
	3194:  "magbind",
	3195:  "ncu-1",
	3196:  "ncu-2",
	3197:  "embrace-dp-s",
	3198:  "embrace-dp-c",
	3199:  "dmod-workspace",
	3200:  "tick-port",
	3201:  "cpq-tasksmart",
	3202:  "intraintra",
	3203:  "netwatcher-mon",
	3204:  "netwatcher-db",
	3205:  "isns",
	3206:  "ironmail",
	3207:  "vx-auth-port",
	3208:  "pfu-prcallback",
	3209:  "netwkpathengine",
	3210:  "flamenco-proxy",
	3211:  "avsecuremgmt",
	3212:  "surveyinst",
	3213:  "neon24x7",
	3214:  "jmq-daemon-1",
	3215:  "jmq-daemon-2",
	3216:  "ferrari-foam",
	3217:  "unite",
	3218:  "smartpackets",
	3219:  "wms-messenger",
	3220:  "xnm-ssl",
	3221:  "xnm-clear-text",
	3222:  "glbp",
	3223:  "digivote",
	3224:  "aes-discovery",
	3225:  "fcip-port",
	3226:  "isi-irp",
	3227:  "dwnmshttp",
	3228:  "dwmsgserver",
	3229:  "global-cd-port",
	3230:  "sftdst-port",
	3231:  "vidigo",
	3232:  "mdtp",
	3233:  "whisker",
	3234:  "alchemy",
	3235:  "mdap-port",
	3236:  "apparenet-ts",
	3237:  "apparenet-tps",
	3238:  "apparenet-as",
	3239:  "apparenet-ui",
	3240:  "triomotion",
	3241:  "sysorb",
	3242:  "sdp-id-port",
	3243:  "timelot",
	3244:  "onesaf",
	3245:  "vieo-fe",
	3246:  "dvt-system",
	3247:  "dvt-data",
	3248:  "procos-lm",
	3249:  "ssp",
	3250:  "hicp",
	3251:  "sysscanner",
	3252:  "dhe",
	3253:  "pda-data",
	3254:  "pda-sys",
	3255:  "semaphore",
	3256:  "cpqrpm-agent",
	3257:  "cpqrpm-server",
	3258:  "ivecon-port",
	3259:  "epncdp2",
	3260:  "iscsi-target",
	3261:  "winshadow",
	3262:  "necp",
	3263:  "ecolor-imager",
	3264:  "ccmail",
	3265:  "altav-tunnel",
	3266:  "ns-cfg-server",
	3267:  "ibm-dial-out",
	3268:  "msft-gc",
	3269:  "msft-gc-ssl",
	3270:  "verismart",
	3271:  "csoft-prev",
	3272:  "user-manager",
	3273:  "sxmp",
	3274:  "ordinox-server",
	3275:  "samd",
	3276:  "maxim-asics",
	3277:  "awg-proxy",
	3278:  "lkcmserver",
	3279:  "admind",
	3280:  "vs-server",
	3281:  "sysopt",
	3282:  "datusorb",
	3283:  "Apple Remote Desktop (Net Assistant)",
	3284:  "4talk",
	3285:  "plato",
	3286:  "e-net",
	3287:  "directvdata",
	3288:  "cops",
	3289:  "enpc",
	3290:  "caps-lm",
	3291:  "sah-lm",
	3292:  "cart-o-rama",
	3293:  "fg-fps",
	3294:  "fg-gip",
	3295:  "dyniplookup",
	3296:  "rib-slm",
	3297:  "cytel-lm",
	3298:  "deskview",
	3299:  "pdrncs",
	3300:  "ceph",
	3302:  "mcs-fastmail",
	3303:  "opsession-clnt",
	3304:  "opsession-srvr",
	3305:  "odette-ftp",
	3306:  "mysql",
	3307:  "opsession-prxy",
	3308:  "tns-server",
	3309:  "tns-adv",
	3310:  "dyna-access",
	3311:  "mcns-tel-ret",
	3312:  "appman-server",
	3313:  "uorb",
	3314:  "uohost",
	3315:  "cdid",
	3316:  "aicc-cmi",
	3317:  "vsaiport",
	3318:  "ssrip",
	3319:  "sdt-lmd",
	3320:  "officelink2000",
	3321:  "vnsstr",
	3326:  "sftu",
	3327:  "bbars",
	3328:  "egptlm",
	3329:  "hp-device-disc",
	3330:  "mcs-calypsoicf",
	3331:  "mcs-messaging",
	3332:  "mcs-mailsvr",
	3333:  "dec-notes",
	3334:  "directv-web",
	3335:  "directv-soft",
	3336:  "directv-tick",
	3337:  "directv-catlg",
	3338:  "anet-b",
	3339:  "anet-l",
	3340:  "anet-m",
	3341:  "anet-h",
	3342:  "webtie",
	3343:  "ms-cluster-net",
	3344:  "bnt-manager",
	3345:  "influence",
	3346:  "trnsprntproxy",
	3347:  "phoenix-rpc",
	3348:  "pangolin-laser",
	3349:  "chevinservices",
	3350:  "findviatv",
	3351:  "btrieve",
	3352:  "ssql",
	3353:  "fatpipe",
	3354:  "suitjd",
	3355:  "ordinox-dbase",
	3356:  "upnotifyps",
	3357:  "adtech-test",
	3358:  "mpsysrmsvr",
	3359:  "wg-netforce",
	3360:  "kv-server",
	3361:  "kv-agent",
	3362:  "dj-ilm",
	3363:  "nati-vi-server",
	3364:  "creativeserver",
	3365:  "contentserver",
	3366:  "creativepartnr",
	3372:  "tip2",
	3373:  "lavenir-lm",
	3374:  "cluster-disc",
	3375:  "vsnm-agent",
	3376:  "cdbroker",
	3377:  "cogsys-lm",
	3378:  "wsicopy",
	3379:  "socorfs",
	3380:  "sns-channels",
	3381:  "geneous",
	3382:  "fujitsu-neat",
	3383:  "esp-lm",
	3384:  "hp-clic",
	3385:  "qnxnetman",
	3386:  "gprs-data",
	3387:  "backroomnet",
	3388:  "cbserver",
	3389:  "ms-wbt-server",
	3390:  "dsc",
	3391:  "savant",
	3392:  "efi-lm",
	3393:  "d2k-tapestry1",
	3394:  "d2k-tapestry2",
	3395:  "dyna-lm",
	3396:  "printer-agent",
	3397:  "cloanto-lm",
	3398:  "mercantile",
	3399:  "csms",
	3400:  "csms2",
	3401:  "filecast",
	3402:  "fxaengine-net",
	3405:  "nokia-ann-ch1",
	3406:  "nokia-ann-ch2",
	3407:  "ldap-admin",
	3408:  "BESApi",
	3409:  "networklens",
	3410:  "networklenss",
	3411:  "biolink-auth",
	3412:  "xmlblaster",
	3413:  "svnet",
	3414:  "wip-port",
	3415:  "bcinameservice",
	3416:  "commandport",
	3417:  "csvr",
	3418:  "rnmap",
	3419:  "softaudit",
	3420:  "ifcp-port",
	3421:  "bmap",
	3422:  "rusb-sys-port",
	3423:  "xtrm",
	3424:  "xtrms",
	3425:  "agps-port",
	3426:  "arkivio",
	3427:  "websphere-snmp",
	3428:  "twcss",
	3429:  "gcsp",
	3430:  "ssdispatch",
	3431:  "ndl-als",
	3432:  "osdcp",
	3433:  "opnet-smp",
	3434:  "opencm",
	3435:  "pacom",
	3436:  "gc-config",
	3437:  "autocueds",
	3438:  "spiral-admin",
	3439:  "hri-port",
	3440:  "ans-console",
	3441:  "connect-client",
	3442:  "connect-server",
	3443:  "ov-nnm-websrv",
	3444:  "denali-server",
	3445:  "monp",
	3446:  "3comfaxrpc",
	3447:  "directnet",
	3448:  "dnc-port",
	3449:  "hotu-chat",
	3450:  "castorproxy",
	3451:  "asam",
	3452:  "sabp-signal",
	3453:  "pscupd",
	3454:  "mira",
	3455:  "prsvp",
	3456:  "vat",
	3457:  "vat-control",
	3458:  "d3winosfi",
	3459:  "integral",
	3460:  "edm-manager",
	3461:  "edm-stager",
	3462:  "edm-std-notify",
	3463:  "edm-adm-notify",
	3464:  "edm-mgr-sync",
	3465:  "edm-mgr-cntrl",
	3466:  "workflow",
	3467:  "rcst",
	3468:  "ttcmremotectrl",
	3469:  "pluribus",
	3470:  "jt400",
	3471:  "jt400-ssl",
	3472:  "jaugsremotec-1",
	3473:  "jaugsremotec-2",
	3474:  "ttntspauto",
	3475:  "genisar-port",
	3476:  "nppmp",
	3477:  "ecomm",
	3478:  "stun",
	3479:  "twrpc",
	3480:  "plethora",
	3481:  "cleanerliverc",
	3482:  "vulture",
	3483:  "slim-devices",
	3484:  "gbs-stp",
	3485:  "celatalk",
	3486:  "ifsf-hb-port",
	3487:  "ltctcp",
	3488:  "fs-rh-srv",
	3489:  "dtp-dia",
	3490:  "colubris",
	3491:  "swr-port",
	3492:  "tvdumtray-port",
	3493:  "nut",
	3494:  "ibm3494",
	3495:  "seclayer-tcp",
	3496:  "seclayer-tls",
	3497:  "ipether232port",
	3498:  "dashpas-port",
	3499:  "sccip-media",
	3500:  "rtmp-port",
	3501:  "isoft-p2p",
	3502:  "avinstalldisc",
	3503:  "lsp-ping",
	3504:  "ironstorm",
	3505:  "ccmcomm",
	3506:  "apc-3506",
	3507:  "nesh-broker",
	3508:  "interactionweb",
	3509:  "vt-ssl",
	3510:  "xss-port",
	3511:  "webmail-2",
	3512:  "aztec",
	3513:  "arcpd",
	3514:  "must-p2p",
	3515:  "must-backplane",
	3516:  "smartcard-port",
	3517:  "802-11-iapp",
	3518:  "artifact-msg",
	3519:  "nvmsgd",
	3520:  "galileolog",
	3521:  "mc3ss",
	3522:  "nssocketport",
	3523:  "odeumservlink",
	3524:  "ecmport",
	3525:  "eisport",
	3526:  "starquiz-port",
	3527:  "beserver-msg-q",
	3528:  "jboss-iiop",
	3529:  "jboss-iiop-ssl",
	3530:  "gf",
	3531:  "joltid",
	3532:  "raven-rmp",
	3533:  "raven-rdp",
	3534:  "urld-port",
	3535:  "ms-la",
	3536:  "snac",
	3537:  "ni-visa-remote",
	3538:  "ibm-diradm",
	3539:  "ibm-diradm-ssl",
	3540:  "pnrp-port",
	3541:  "voispeed-port",
	3542:  "hacl-monitor",
	3543:  "qftest-lookup",
	3544:  "teredo",
	3545:  "camac",
	3547:  "symantec-sim",
	3548:  "interworld",
	3549:  "tellumat-nms",
	3550:  "ssmpp",
	3551:  "apcupsd",
	3552:  "taserver",
	3553:  "rbr-discovery",
	3554:  "questnotify",
	3555:  "razor",
	3556:  "sky-transport",
	3557:  "personalos-001",
	3558:  "mcp-port",
	3559:  "cctv-port",
	3560:  "iniserve-port",
	3561:  "bmc-onekey",
	3562:  "sdbproxy",
	3563:  "watcomdebug",
	3564:  "esimport",
	3565:  "m2pa",
	3566:  "quest-data-hub",
	3567:  "dof-eps",
	3568:  "dof-tunnel-sec",
	3569:  "mbg-ctrl",
	3570:  "mccwebsvr-port",
	3571:  "megardsvr-port",
	3572:  "megaregsvrport",
	3573:  "tag-ups-1",
	3574:  "dmaf-server",
	3575:  "ccm-port",
	3576:  "cmc-port",
	3577:  "config-port",
	3578:  "data-port",
	3579:  "ttat3lb",
	3580:  "nati-svrloc",
	3581:  "kfxaclicensing",
	3582:  "press",
	3583:  "canex-watch",
	3584:  "u-dbap",
	3585:  "emprise-lls",
	3586:  "emprise-lsc",
	3587:  "p2pgroup",
	3588:  "sentinel",
	3589:  "isomair",
	3590:  "wv-csp-sms",
	3591:  "gtrack-server",
	3592:  "gtrack-ne",
	3593:  "bpmd",
	3594:  "mediaspace",
	3595:  "shareapp",
	3596:  "iw-mmogame",
	3597:  "a14",
	3598:  "a15",
	3599:  "quasar-server",
	3600:  "trap-daemon",
	3601:  "visinet-gui",
	3602:  "infiniswitchcl",
	3603:  "int-rcv-cntrl",
	3604:  "bmc-jmx-port",
	3605:  "comcam-io",
	3606:  "splitlock",
	3607:  "precise-i3",
	3608:  "trendchip-dcp",
	3609:  "cpdi-pidas-cm",
	3610:  "echonet",
	3611:  "six-degrees",
	3612:  "hp-dataprotect",
	3613:  "alaris-disc",
	3614:  "sigma-port",
	3615:  "start-network",
	3616:  "cd3o-protocol",
	3617:  "sharp-server",
	3618:  "aairnet-1",
	3619:  "aairnet-2",
	3620:  "ep-pcp",
	3621:  "ep-nsp",
	3622:  "ff-lr-port",
	3623:  "haipe-discover",
	3624:  "dist-upgrade",
	3625:  "volley",
	3626:  "bvcdaemon-port",
	3627:  "jamserverport",
	3628:  "ept-machine",
	3629:  "escvpnet",
	3630:  "cs-remote-db",
	3631:  "cs-services",
	3632:  "distcc",
	3633:  "wacp",
	3634:  "hlibmgr",
	3635:  "sdo",
	3636:  "servistaitsm",
	3637:  "scservp",
	3638:  "ehp-backup",
	3639:  "xap-ha",
	3640:  "netplay-port1",
	3641:  "netplay-port2",
	3642:  "juxml-port",
	3643:  "audiojuggler",
	3644:  "ssowatch",
	3645:  "cyc",
	3646:  "xss-srv-port",
	3647:  "splitlock-gw",
	3648:  "fjcp",
	3649:  "nmmp",
	3650:  "prismiq-plugin",
	3651:  "xrpc-registry",
	3652:  "vxcrnbuport",
	3653:  "tsp",
	3654:  "vaprtm",
	3655:  "abatemgr",
	3656:  "abatjss",
	3657:  "immedianet-bcn",
	3658:  "ps-ams",
	3659:  "apple-sasl",
	3660:  "can-nds-ssl",
	3661:  "can-ferret-ssl",
	3662:  "pserver",
	3663:  "dtp",
	3664:  "ups-engine",
	3665:  "ent-engine",
	3666:  "eserver-pap",
	3667:  "infoexch",
	3668:  "dell-rm-port",
	3669:  "casanswmgmt",
	3670:  "smile",
	3671:  "efcp",
	3672:  "lispworks-orb",
	3673:  "mediavault-gui",
	3674:  "wininstall-ipc",
	3675:  "calltrax",
	3676:  "va-pacbase",
	3677:  "roverlog",
	3678:  "ipr-dglt",
	3679:  "Escale (Newton Dock)",
	3680:  "npds-tracker",
	3681:  "bts-x73",
	3682:  "cas-mapi",
	3683:  "bmc-ea",
	3684:  "faxstfx-port",
	3685:  "dsx-agent",
	3686:  "tnmpv2",
	3687:  "simple-push",
	3688:  "simple-push-s",
	3689:  "daap",
	3690:  "svn",
	3691:  "magaya-network",
	3692:  "intelsync",
	3693:  "easl",
	3695:  "bmc-data-coll",
	3696:  "telnetcpcd",
	3697:  "nw-license",
	3698:  "sagectlpanel",
	3699:  "kpn-icw",
	3700:  "lrs-paging",
	3701:  "netcelera",
	3702:  "ws-discovery",
	3703:  "adobeserver-3",
	3704:  "adobeserver-4",
	3705:  "adobeserver-5",
	3706:  "rt-event",
	3707:  "rt-event-s",
	3708:  "sun-as-iiops",
	3709:  "ca-idms",
	3710:  "portgate-auth",
	3711:  "edb-server2",
	3712:  "sentinel-ent",
	3713:  "tftps",
	3714:  "delos-dms",
	3715:  "anoto-rendezv",
	3716:  "wv-csp-sms-cir",
	3717:  "wv-csp-udp-cir",
	3718:  "opus-services",
	3719:  "itelserverport",
	3720:  "ufastro-instr",
	3721:  "xsync",
	3722:  "xserveraid",
	3723:  "sychrond",
	3724:  "blizwow",
	3725:  "na-er-tip",
	3726:  "array-manager",
	3727:  "e-mdu",
	3728:  "e-woa",
	3729:  "fksp-audit",
	3730:  "client-ctrl",
	3731:  "smap",
	3732:  "m-wnn",
	3733:  "multip-msg",
	3734:  "synel-data",
	3735:  "pwdis",
	3736:  "rs-rmi",
	3737:  "xpanel",
	3738:  "versatalk",
	3739:  "launchbird-lm",
	3740:  "heartbeat",
	3741:  "wysdma",
	3742:  "cst-port",
	3743:  "ipcs-command",
	3744:  "sasg",
	3745:  "gw-call-port",
	3746:  "linktest",
	3747:  "linktest-s",
	3748:  "webdata",
	3749:  "cimtrak",
	3750:  "cbos-ip-port",
	3751:  "gprs-cube",
	3752:  "vipremoteagent",
	3753:  "nattyserver",
	3754:  "timestenbroker",
	3755:  "sas-remote-hlp",
	3756:  "canon-capt",
	3757:  "grf-port",
	3758:  "apw-registry",
	3759:  "exapt-lmgr",
	3760:  "adtempusclient",
	3761:  "gsakmp",
	3762:  "gbs-smp",
	3763:  "xo-wave",
	3764:  "mni-prot-rout",
	3765:  "rtraceroute",
	3766:  "sitewatch-s",
	3767:  "listmgr-port",
	3768:  "rblcheckd",
	3769:  "haipe-otnk",
	3770:  "cindycollab",
	3771:  "paging-port",
	3772:  "ctp",
	3773:  "ctdhercules",
	3774:  "zicom",
	3775:  "ispmmgr",
	3776:  "dvcprov-port",
	3777:  "jibe-eb",
	3778:  "c-h-it-port",
	3779:  "cognima",
	3780:  "nnp",
	3781:  "abcvoice-port",
	3782:  "iso-tp0s",
	3783:  "bim-pem",
	3784:  "bfd-control",
	3785:  "bfd-echo",
	3786:  "upstriggervsw",
	3787:  "fintrx",
	3788:  "isrp-port",
	3789:  "remotedeploy",
	3790:  "quickbooksrds",
	3791:  "tvnetworkvideo",
	3792:  "sitewatch",
	3793:  "dcsoftware",
	3794:  "jaus",
	3795:  "myblast",
	3796:  "spw-dialer",
	3797:  "idps",
	3798:  "minilock",
	3799:  "radius-dynauth",
	3800:  "pwgpsi",
	3801:  "ibm-mgr",
	3802:  "vhd",
	3803:  "soniqsync",
	3804:  "iqnet-port",
	3805:  "tcpdataserver",
	3806:  "wsmlb",
	3807:  "spugna",
	3808:  "sun-as-iiops-ca",
	3809:  "apocd",
	3810:  "wlanauth",
	3811:  "amp",
	3812:  "neto-wol-server",
	3813:  "rap-ip",
	3814:  "neto-dcs",
	3815:  "lansurveyorxml",
	3816:  "sunlps-http",
	3817:  "tapeware",
	3818:  "crinis-hb",
	3819:  "epl-slp",
	3820:  "scp",
	3821:  "pmcp",
	3822:  "acp-discovery",
	3823:  "acp-conduit",
	3824:  "acp-policy",
	3825:  "ffserver",
	3826:  "warmux",
	3827:  "netmpi",
	3828:  "neteh",
	3829:  "neteh-ext",
	3830:  "cernsysmgmtagt",
	3831:  "dvapps",
	3832:  "xxnetserver",
	3833:  "aipn-auth",
	3834:  "spectardata",
	3835:  "spectardb",
	3836:  "markem-dcp",
	3837:  "mkm-discovery",
	3838:  "sos",
	3839:  "amx-rms",
	3840:  "flirtmitmir",
	3841:  "shiprush-db-svr",
	3842:  "nhci",
	3843:  "quest-agent",
	3844:  "rnm",
	3845:  "v-one-spp",
	3846:  "an-pcp",
	3847:  "msfw-control",
	3848:  "item",
	3849:  "spw-dnspreload",
	3850:  "qtms-bootstrap",
	3851:  "spectraport",
	3852:  "sse-app-config",
	3853:  "sscan",
	3854:  "stryker-com",
	3855:  "opentrac",
	3856:  "informer",
	3857:  "trap-port",
	3858:  "trap-port-mom",
	3859:  "nav-port",
	3860:  "sasp",
	3861:  "winshadow-hd",
	3862:  "giga-pocket",
	3863:  "asap-tcp",
	3864:  "asap-tcp-tls",
	3865:  "xpl",
	3866:  "dzdaemon",
	3867:  "dzoglserver",
	3868:  "diameter",
	3869:  "ovsam-mgmt",
	3870:  "ovsam-d-agent",
	3871:  "avocent-adsap",
	3872:  "oem-agent",
	3873:  "fagordnc",
	3874:  "sixxsconfig",
	3875:  "pnbscada",
	3876:  "dl-agent",
	3877:  "xmpcr-interface",
	3878:  "fotogcad",
	3879:  "appss-lm",
	3880:  "igrs",
	3881:  "idac",
	3882:  "msdts1",
	3883:  "vrpn",
	3884:  "softrack-meter",
	3885:  "topflow-ssl",
	3886:  "nei-management",
	3887:  "ciphire-data",
	3888:  "ciphire-serv",
	3889:  "dandv-tester",
	3890:  "ndsconnect",
	3891:  "rtc-pm-port",
	3892:  "pcc-image-port",
	3893:  "cgi-starapi",
	3894:  "syam-agent",
	3895:  "syam-smc",
	3896:  "sdo-tls",
	3897:  "sdo-ssh",
	3898:  "senip",
	3899:  "itv-control",
	3900:  "udt-os",
	3901:  "nimsh",
	3902:  "nimaux",
	3903:  "charsetmgr",
	3904:  "omnilink-port",
	3905:  "mupdate",
	3906:  "topovista-data",
	3907:  "imoguia-port",
	3908:  "hppronetman",
	3909:  "surfcontrolcpa",
	3910:  "prnrequest",
	3911:  "prnstatus",
	3912:  "gbmt-stars",
	3913:  "listcrt-port",
	3914:  "listcrt-port-2",
	3915:  "agcat",
	3916:  "wysdmc",
	3917:  "aftmux",
	3918:  "pktcablemmcops",
	3919:  "hyperip",
	3920:  "exasoftport1",
	3921:  "herodotus-net",
	3922:  "sor-update",
	3923:  "symb-sb-port",
	3924:  "mpl-gprs-port",
	3925:  "zmp",
	3926:  "winport",
	3927:  "natdataservice",
	3928:  "netboot-pxe",
	3929:  "smauth-port",
	3930:  "syam-webserver",
	3931:  "msr-plugin-port",
	3932:  "dyn-site",
	3933:  "plbserve-port",
	3934:  "sunfm-port",
	3935:  "sdp-portmapper",
	3936:  "mailprox",
	3937:  "dvbservdsc",
	3938:  "dbcontrol-agent",
	3939:  "aamp",
	3940:  "xecp-node",
	3941:  "homeportal-web",
	3942:  "srdp",
	3943:  "tig",
	3944:  "sops",
	3945:  "emcads",
	3946:  "backupedge",
	3947:  "ccp",
	3948:  "apdap",
	3949:  "drip",
	3950:  "namemunge",
	3951:  "pwgippfax",
	3952:  "i3-sessionmgr",
	3953:  "xmlink-connect",
	3954:  "adrep",
	3955:  "p2pcommunity",
	3956:  "gvcp",
	3957:  "mqe-broker",
	3958:  "mqe-agent",
	3959:  "treehopper",
	3960:  "bess",
	3961:  "proaxess",
	3962:  "sbi-agent",
	3963:  "thrp",
	3964:  "sasggprs",
	3965:  "ati-ip-to-ncpe",
	3966:  "bflckmgr",
	3967:  "ppsms",
	3968:  "ianywhere-dbns",
	3969:  "landmarks",
	3970:  "lanrevagent",
	3971:  "lanrevserver",
	3972:  "iconp",
	3973:  "progistics",
	3974:  "citysearch",
	3975:  "airshot",
	3976:  "opswagent",
	3977:  "opswmanager",
	3978:  "secure-cfg-svr",
	3979:  "smwan",
	3980:  "acms",
	3981:  "starfish",
	3982:  "eis",
	3983:  "eisp",
	3984:  "mapper-nodemgr",
	3985:  "mapper-mapethd",
	3986:  "mapper-ws-ethd",
	3987:  "centerline",
	3988:  "dcs-config",
	3989:  "bv-queryengine",
	3990:  "bv-is",
	3991:  "bv-smcsrv",
	3992:  "bv-ds",
	3993:  "bv-agent",
	3995:  "iss-mgmt-ssl",
	3996:  "abcsoftware",
	3997:  "agentsease-db",
	3998:  "dnx",
	3999:  "nvcnet",
	4000:  "terabase",
	4001:  "newoak",
	4002:  "pxc-spvr-ft",
	4003:  "pxc-splr-ft",
	4004:  "pxc-roid",
	4005:  "pxc-pin",
	4006:  "pxc-spvr",
	4007:  "pxc-splr",
	4008:  "netcheque",
	4009:  "chimera-hwm",
	4010:  "samsung-unidex",
	4011:  "altserviceboot",
	4012:  "pda-gate",
	4013:  "acl-manager",
	4014:  "taiclock",
	4015:  "talarian-mcast1",
	4016:  "talarian-mcast2",
	4017:  "talarian-mcast3",
	4018:  "talarian-mcast4",
	4019:  "talarian-mcast5",
	4020:  "trap",
	4021:  "nexus-portal",
	4022:  "dnox",
	4023:  "esnm-zoning",
	4024:  "tnp1-port",
	4025:  "partimage",
	4026:  "as-debug",
	4027:  "bxp",
	4028:  "dtserver-port",
	4029:  "ip-qsig",
	4030:  "jdmn-port",
	4031:  "suucp",
	4032:  "vrts-auth-port",
	4033:  "sanavigator",
	4034:  "ubxd",
	4035:  "wap-push-http",
	4036:  "wap-push-https",
	4037:  "ravehd",
	4038:  "fazzt-ptp",
	4039:  "fazzt-admin",
	4040:  "yo-main",
	4041:  "houston",
	4042:  "ldxp",
	4043:  "nirp",
	4044:  "ltp",
	4045:  "npp",
	4046:  "acp-proto",
	4047:  "ctp-state",
	4049:  "wafs",
	4050:  "cisco-wafs",
	4051:  "cppdp",
	4052:  "interact",
	4053:  "ccu-comm-1",
	4054:  "ccu-comm-2",
	4055:  "ccu-comm-3",
	4056:  "lms",
	4057:  "wfm",
	4058:  "kingfisher",
	4059:  "dlms-cosem",
	4060:  "dsmeter-iatc",
	4061:  "ice-location",
	4062:  "ice-slocation",
	4063:  "ice-router",
	4064:  "ice-srouter",
	4065:  "avanti-cdp",
	4066:  "pmas",
	4067:  "idp",
	4068:  "ipfltbcst",
	4069:  "minger",
	4070:  "tripe",
	4071:  "aibkup",
	4072:  "zieto-sock",
	4073:  "iRAPP",
	4074:  "cequint-cityid",
	4075:  "perimlan",
	4076:  "seraph",
	4078:  "cssp",
	4079:  "santools",
	4080:  "lorica-in",
	4081:  "lorica-in-sec",
	4082:  "lorica-out",
	4083:  "lorica-out-sec",
	4085:  "ezmessagesrv",
	4087:  "applusservice",
	4088:  "npsp",
	4089:  "opencore",
	4090:  "omasgport",
	4091:  "ewinstaller",
	4092:  "ewdgs",
	4093:  "pvxpluscs",
	4094:  "sysrqd",
	4095:  "xtgui",
	4096:  "bre",
	4097:  "patrolview",
	4098:  "drmsfsd",
	4099:  "dpcp",
	4100:  "igo-incognito",
	4101:  "brlp-0",
	4102:  "brlp-1",
	4103:  "brlp-2",
	4104:  "brlp-3",
	4105:  "shofar",
	4106:  "synchronite",
	4107:  "j-ac",
	4108:  "accel",
	4109:  "izm",
	4110:  "g2tag",
	4111:  "xgrid",
	4112:  "apple-vpns-rp",
	4113:  "aipn-reg",
	4114:  "jomamqmonitor",
	4115:  "cds",
	4116:  "smartcard-tls",
	4117:  "hillrserv",
	4118:  "netscript",
	4119:  "assuria-slm",
	4120:  "minirem",
	4121:  "e-builder",
	4122:  "fprams",
	4123:  "z-wave",
	4124:  "tigv2",
	4125:  "opsview-envoy",
	4126:  "ddrepl",
	4127:  "unikeypro",
	4128:  "nufw",
	4129:  "nuauth",
	4130:  "fronet",
	4131:  "stars",
	4132:  "nuts-dem",
	4133:  "nuts-bootp",
	4134:  "nifty-hmi",
	4135:  "cl-db-attach",
	4136:  "cl-db-request",
	4137:  "cl-db-remote",
	4138:  "nettest",
	4139:  "thrtx",
	4140:  "cedros-fds",
	4141:  "oirtgsvc",
	4142:  "oidocsvc",
	4143:  "oidsr",
	4145:  "vvr-control",
	4146:  "tgcconnect",
	4147:  "vrxpservman",
	4148:  "hhb-handheld",
	4149:  "agslb",
	4150:  "PowerAlert-nsa",
	4151:  "menandmice-noh",
	4152:  "idig-mux",
	4153:  "mbl-battd",
	4154:  "atlinks",
	4155:  "bzr",
	4156:  "stat-results",
	4157:  "stat-scanner",
	4158:  "stat-cc",
	4159:  "nss",
	4160:  "jini-discovery",
	4161:  "omscontact",
	4162:  "omstopology",
	4163:  "silverpeakpeer",
	4164:  "silverpeakcomm",
	4165:  "altcp",
	4166:  "joost",
	4167:  "ddgn",
	4168:  "pslicser",
	4169:  "iadt",
	4170:  "d-cinema-csp",
	4171:  "ml-svnet",
	4172:  "pcoip",
	4174:  "smcluster",
	4175:  "bccp",
	4176:  "tl-ipcproxy",
	4177:  "wello",
	4178:  "storman",
	4179:  "MaxumSP",
	4180:  "httpx",
	4181:  "macbak",
	4182:  "pcptcpservice",
	4183:  "cyborgnet",
	4184:  "universe-suite",
	4185:  "wcpp",
	4186:  "boxbackupstore",
	4187:  "csc-proxy",
	4188:  "vatata",
	4189:  "pcep",
	4190:  "sieve",
	4192:  "azeti",
	4193:  "pvxplusio",
	4197:  "hctl",
	4199:  "eims-admin",
	4300:  "corelccam",
	4301:  "d-data",
	4302:  "d-data-control",
	4303:  "srcp",
	4304:  "owserver",
	4305:  "batman",
	4306:  "pinghgl",
	4307:  "trueconf",
	4308:  "compx-lockview",
	4309:  "dserver",
	4310:  "mirrtex",
	4311:  "p6ssmc",
	4312:  "pscl-mgt",
	4313:  "perrla",
	4314:  "choiceview-agt",
	4316:  "choiceview-clt",
	4320:  "fdt-rcatp",
	4321:  "rwhois",
	4322:  "trim-event",
	4323:  "trim-ice",
	4325:  "geognosisman",
	4326:  "geognosis",
	4327:  "jaxer-web",
	4328:  "jaxer-manager",
	4329:  "publiqare-sync",
	4330:  "dey-sapi",
	4331:  "ktickets-rest",
	4333:  "ahsp",
	4334:  "netconf-ch-ssh",
	4335:  "netconf-ch-tls",
	4336:  "restconf-ch-tls",
	4340:  "gaia",
	4341:  "lisp-data",
	4342:  "lisp-cons",
	4343:  "unicall",
	4344:  "vinainstall",
	4345:  "m4-network-as",
	4346:  "elanlm",
	4347:  "lansurveyor",
	4348:  "itose",
	4349:  "fsportmap",
	4350:  "net-device",
	4351:  "plcy-net-svcs",
	4352:  "pjlink",
	4353:  "f5-iquery",
	4354:  "qsnet-trans",
	4355:  "qsnet-workst",
	4356:  "qsnet-assist",
	4357:  "qsnet-cond",
	4358:  "qsnet-nucl",
	4359:  "omabcastltkm",
	4360:  "matrix-vnet",
	4368:  "wxbrief",
	4369:  "epmd",
	4370:  "elpro-tunnel",
	4371:  "l2c-control",
	4372:  "l2c-data",
	4373:  "remctl",
	4374:  "psi-ptt",
	4375:  "tolteces",
	4376:  "bip",
	4377:  "cp-spxsvr",
	4378:  "cp-spxdpy",
	4379:  "ctdb",
	4389:  "xandros-cms",
	4390:  "wiegand",
	4391:  "apwi-imserver",
	4392:  "apwi-rxserver",
	4393:  "apwi-rxspooler",
	4395:  "omnivisionesx",
	4396:  "fly",
	4400:  "ds-srv",
	4401:  "ds-srvr",
	4402:  "ds-clnt",
	4403:  "ds-user",
	4404:  "ds-admin",
	4405:  "ds-mail",
	4406:  "ds-slp",
	4407:  "nacagent",
	4408:  "slscc",
	4409:  "netcabinet-com",
	4410:  "itwo-server",
	4411:  "found",
	4413:  "avi-nms",
	4414:  "updog",
	4415:  "brcd-vr-req",
	4416:  "pjj-player",
	4417:  "workflowdir",
	4419:  "cbp",
	4420:  "nvm-express",
	4421:  "scaleft",
	4422:  "tsepisp",
	4423:  "thingkit",
	4425:  "netrockey6",
	4426:  "beacon-port-2",
	4427:  "drizzle",
	4428:  "omviserver",
	4429:  "omviagent",
	4430:  "rsqlserver",
	4431:  "wspipe",
	4432:  "l-acoustics",
	4433:  "vop",
	4442:  "saris",
	4443:  "pharos",
	4444:  "krb524",
	4445:  "upnotifyp",
	4446:  "n1-fwp",
	4447:  "n1-rmgmt",
	4448:  "asc-slmd",
	4449:  "privatewire",
	4450:  "camp",
	4451:  "ctisystemmsg",
	4452:  "ctiprogramload",
	4453:  "nssalertmgr",
	4454:  "nssagentmgr",
	4455:  "prchat-user",
	4456:  "prchat-server",
	4457:  "prRegister",
	4458:  "mcp",
	4484:  "hpssmgmt",
	4485:  "assyst-dr",
	4486:  "icms",
	4487:  "prex-tcp",
	4488:  "awacs-ice",
	4500:  "ipsec-nat-t",
	4535:  "ehs",
	4536:  "ehs-ssl",
	4537:  "wssauthsvc",
	4538:  "swx-gate",
	4545:  "worldscores",
	4546:  "sf-lm",
	4547:  "lanner-lm",
	4548:  "synchromesh",
	4549:  "aegate",
	4550:  "gds-adppiw-db",
	4551:  "ieee-mih",
	4552:  "menandmice-mon",
	4553:  "icshostsvc",
	4554:  "msfrs",
	4555:  "rsip",
	4556:  "dtn-bundle",
	4559:  "hylafax",
	4563:  "amahi-anywhere",
	4566:  "kwtc",
	4567:  "tram",
	4568:  "bmc-reporting",
	4569:  "iax",
	4570:  "deploymentmap",
	4573:  "cardifftec-back",
	4590:  "rid",
	4591:  "l3t-at-an",
	4593:  "ipt-anri-anri",
	4594:  "ias-session",
	4595:  "ias-paging",
	4596:  "ias-neighbor",
	4597:  "a21-an-1xbs",
	4598:  "a16-an-an",
	4599:  "a17-an-an",
	4600:  "piranha1",
	4601:  "piranha2",
	4602:  "mtsserver",
	4603:  "menandmice-upg",
	4604:  "irp",
	4605:  "sixchat",
	4658:  "playsta2-app",
	4659:  "playsta2-lob",
	4660:  "smaclmgr",
	4661:  "kar2ouche",
	4662:  "oms",
	4663:  "noteit",
	4664:  "ems",
	4665:  "contclientms",
	4666:  "eportcomm",
	4667:  "mmacomm",
	4668:  "mmaeds",
	4669:  "eportcommdata",
	4670:  "light",
	4671:  "acter",
	4672:  "rfa",
	4673:  "cxws",
	4674:  "appiq-mgmt",
	4675:  "dhct-status",
	4676:  "dhct-alerts",
	4677:  "bcs",
	4678:  "traversal",
	4679:  "mgesupervision",
	4680:  "mgemanagement",
	4681:  "parliant",
	4682:  "finisar",
	4683:  "spike",
	4684:  "rfid-rp1",
	4685:  "autopac",
	4686:  "msp-os",
	4687:  "nst",
	4688:  "mobile-p2p",
	4689:  "altovacentral",
	4690:  "prelude",
	4691:  "mtn",
	4692:  "conspiracy",
	4700:  "netxms-agent",
	4701:  "netxms-mgmt",
	4702:  "netxms-sync",
	4703:  "npqes-test",
	4704:  "assuria-ins",
	4711:  "trinity-dist",
	4725:  "truckstar",
	4727:  "fcis",
	4728:  "capmux",
	4730:  "gearman",
	4731:  "remcap",
	4733:  "resorcs",
	4737:  "ipdr-sp",
	4738:  "solera-lpn",
	4739:  "ipfix",
	4740:  "ipfixs",
	4741:  "lumimgrd",
	4742:  "sicct",
	4743:  "openhpid",
	4744:  "ifsp",
	4745:  "fmp",
	4749:  "profilemac",
	4750:  "ssad",
	4751:  "spocp",
	4752:  "snap",
	4753:  "simon",
	4756:  "RDCenter",
	4774:  "converge",
	4784:  "bfd-multi-ctl",
	4786:  "smart-install",
	4787:  "sia-ctrl-plane",
	4788:  "xmcp",
	4800:  "iims",
	4801:  "iwec",
	4802:  "ilss",
	4803:  "notateit",
	4827:  "htcp",
	4837:  "varadero-0",
	4838:  "varadero-1",
	4839:  "varadero-2",
	4840:  "opcua-tcp",
	4841:  "quosa",
	4842:  "gw-asv",
	4843:  "opcua-tls",
	4844:  "gw-log",
	4845:  "wcr-remlib",
	4846:  "contamac-icm",
	4847:  "wfc",
	4848:  "appserv-http",
	4849:  "appserv-https",
	4850:  "sun-as-nodeagt",
	4851:  "derby-repli",
	4867:  "unify-debug",
	4868:  "phrelay",
	4869:  "phrelaydbg",
	4870:  "cc-tracking",
	4871:  "wired",
	4876:  "tritium-can",
	4877:  "lmcs",
	4879:  "wsdl-event",
	4880:  "hislip",
	4883:  "wmlserver",
	4884:  "hivestor",
	4885:  "abbs",
	4894:  "lyskom",
	4899:  "radmin-port",
	4900:  "hfcs",
	4901:  "flr-agent",
	4902:  "magiccontrol",
	4912:  "lutap",
	4913:  "lutcp",
	4914:  "bones",
	4915:  "frcs",
	4940:  "eq-office-4940",
	4941:  "eq-office-4941",
	4942:  "eq-office-4942",
	4949:  "munin",
	4950:  "sybasesrvmon",
	4951:  "pwgwims",
	4952:  "sagxtsds",
	4953:  "dbsyncarbiter",
	4969:  "ccss-qmm",
	4970:  "ccss-qsm",
	4971:  "burp",
	4984:  "webyast",
	4985:  "gerhcs",
	4986:  "mrip",
	4987:  "smar-se-port1",
	4988:  "smar-se-port2",
	4989:  "parallel",
	4990:  "busycal",
	4991:  "vrt",
	4999:  "hfcs-manager",
	5000:  "commplex-main",
	5001:  "commplex-link",
	5002:  "rfe",
	5003:  "fmpro-internal",
	5004:  "avt-profile-1",
	5005:  "avt-profile-2",
	5006:  "wsm-server",
	5007:  "wsm-server-ssl",
	5008:  "synapsis-edge",
	5009:  "winfs",
	5010:  "telelpathstart",
	5011:  "telelpathattack",
	5012:  "nsp",
	5013:  "fmpro-v6",
	5015:  "fmwp",
	5020:  "zenginkyo-1",
	5021:  "zenginkyo-2",
	5022:  "mice",
	5023:  "htuilsrv",
	5024:  "scpi-telnet",
	5025:  "scpi-raw",
	5026:  "strexec-d",
	5027:  "strexec-s",
	5028:  "qvr",
	5029:  "infobright",
	5030:  "surfpass",
	5032:  "signacert-agent",
	5033:  "jtnetd-server",
	5034:  "jtnetd-status",
	5042:  "asnaacceler8db",
	5043:  "swxadmin",
	5044:  "lxi-evntsvc",
	5045:  "osp",
	5048:  "texai",
	5049:  "ivocalize",
	5050:  "mmcc",
	5051:  "ita-agent",
	5052:  "ita-manager",
	5053:  "rlm",
	5054:  "rlm-admin",
	5055:  "unot",
	5056:  "intecom-ps1",
	5057:  "intecom-ps2",
	5059:  "sds",
	5060:  "sip",
	5061:  "sips",
	5062:  "na-localise",
	5063:  "csrpc",
	5064:  "ca-1",
	5065:  "ca-2",
	5066:  "stanag-5066",
	5067:  "authentx",
	5068:  "bitforestsrv",
	5069:  "i-net-2000-npr",
	5070:  "vtsas",
	5071:  "powerschool",
	5072:  "ayiya",
	5073:  "tag-pm",
	5074:  "alesquery",
	5075:  "pvaccess",
	5080:  "onscreen",
	5081:  "sdl-ets",
	5082:  "qcp",
	5083:  "qfp",
	5084:  "llrp",
	5085:  "encrypted-llrp",
	5086:  "aprigo-cs",
	5087:  "biotic",
	5093:  "sentinel-lm",
	5094:  "hart-ip",
	5099:  "sentlm-srv2srv",
	5100:  "socalia",
	5101:  "talarian-tcp",
	5102:  "oms-nonsecure",
	5103:  "actifio-c2c",
	5106:  "actifioudsagent",
	5107:  "actifioreplic",
	5111:  "taep-as-svc",
	5112:  "pm-cmdsvr",
	5114:  "ev-services",
	5115:  "autobuild",
	5117:  "gradecam",
	5120:  "barracuda-bbs",
	5133:  "nbt-pc",
	5134:  "ppactivation",
	5135:  "erp-scale",
	5137:  "ctsd",
	5145:  "rmonitor-secure",
	5146:  "social-alarm",
	5150:  "atmp",
	5151:  "esri-sde",
	5152:  "sde-discovery",
	5153:  "toruxserver",
	5154:  "bzflag",
	5155:  "asctrl-agent",
	5156:  "rugameonline",
	5157:  "mediat",
	5161:  "snmpssh",
	5162:  "snmpssh-trap",
	5163:  "sbackup",
	5164:  "vpa",
	5165:  "ife-icorp",
	5166:  "winpcs",
	5167:  "scte104",
	5168:  "scte30",
	5172:  "pcoip-mgmt",
	5190:  "aol",
	5191:  "aol-1",
	5192:  "aol-2",
	5193:  "aol-3",
	5194:  "cpscomm",
	5195:  "ampl-lic",
	5196:  "ampl-tableproxy",
	5197:  "tunstall-lwp",
	5200:  "targus-getdata",
	5201:  "targus-getdata1",
	5202:  "targus-getdata2",
	5203:  "targus-getdata3",
	5209:  "nomad",
	5215:  "noteza",
	5221:  "3exmp",
	5222:  "xmpp-client",
	5223:  "hpvirtgrp",
	5224:  "hpvirtctrl",
	5225:  "hp-server",
	5226:  "hp-status",
	5227:  "perfd",
	5228:  "hpvroom",
	5229:  "jaxflow",
	5230:  "jaxflow-data",
	5231:  "crusecontrol",
	5232:  "csedaemon",
	5233:  "enfs",
	5234:  "eenet",
	5235:  "galaxy-network",
	5236:  "padl2sim",
	5237:  "mnet-discovery",
	5245:  "downtools",
	5248:  "caacws",
	5249:  "caaclang2",
	5250:  "soagateway",
	5251:  "caevms",
	5252:  "movaz-ssc",
	5253:  "kpdp",
	5254:  "logcabin",
	5264:  "3com-njack-1",
	5265:  "3com-njack-2",
	5269:  "xmpp-server",
	5270:  "cartographerxmp",
	5271:  "cuelink",
	5272:  "pk",
	5280:  "xmpp-bosh",
	5281:  "undo-lm",
	5282:  "transmit-port",
	5298:  "presence",
	5299:  "nlg-data",
	5300:  "hacl-hb",
	5301:  "hacl-gs",
	5302:  "hacl-cfg",
	5303:  "hacl-probe",
	5304:  "hacl-local",
	5305:  "hacl-test",
	5306:  "sun-mc-grp",
	5307:  "sco-aip",
	5308:  "cfengine",
	5309:  "jprinter",
	5310:  "outlaws",
	5312:  "permabit-cs",
	5313:  "rrdp",
	5314:  "opalis-rbt-ipc",
	5315:  "hacl-poll",
	5316:  "hpbladems",
	5317:  "hpdevms",
	5318:  "pkix-cmc",
	5320:  "bsfserver-zn",
	5321:  "bsfsvr-zn-ssl",
	5343:  "kfserver",
	5344:  "xkotodrcp",
	5349:  "stuns",
	5352:  "dns-llq",
	5353:  "mdns",
	5354:  "mdnsresponder",
	5355:  "llmnr",
	5356:  "ms-smlbiz",
	5357:  "wsdapi",
	5358:  "wsdapi-s",
	5359:  "ms-alerter",
	5360:  "ms-sideshow",
	5361:  "ms-s-sideshow",
	5362:  "serverwsd2",
	5363:  "net-projection",
	5397:  "stresstester",
	5398:  "elektron-admin",
	5399:  "securitychase",
	5400:  "excerpt",
	5401:  "excerpts",
	5402:  "mftp",
	5403:  "hpoms-ci-lstn",
	5404:  "hpoms-dps-lstn",
	5405:  "netsupport",
	5406:  "systemics-sox",
	5407:  "foresyte-clear",
	5408:  "foresyte-sec",
	5409:  "salient-dtasrv",
	5410:  "salient-usrmgr",
	5411:  "actnet",
	5412:  "continuus",
	5413:  "wwiotalk",
	5414:  "statusd",
	5415:  "ns-server",
	5416:  "sns-gateway",
	5417:  "sns-agent",
	5418:  "mcntp",
	5419:  "dj-ice",
	5420:  "cylink-c",
	5421:  "netsupport2",
	5422:  "salient-mux",
	5423:  "virtualuser",
	5424:  "beyond-remote",
	5425:  "br-channel",
	5426:  "devbasic",
	5427:  "sco-peer-tta",
	5428:  "telaconsole",
	5429:  "base",
	5430:  "radec-corp",
	5431:  "park-agent",
	5432:  "postgresql",
	5433:  "pyrrho",
	5434:  "sgi-arrayd",
	5435:  "sceanics",
	5443:  "spss",
	5445:  "smbdirect",
	5450:  "tiepie",
	5453:  "surebox",
	5454:  "apc-5454",
	5455:  "apc-5455",
	5456:  "apc-5456",
	5461:  "silkmeter",
	5462:  "ttl-publisher",
	5463:  "ttlpriceproxy",
	5464:  "quailnet",
	5465:  "netops-broker",
	5470:  "apsolab-col",
	5471:  "apsolab-cols",
	5472:  "apsolab-tag",
	5473:  "apsolab-tags",
	5475:  "apsolab-data",
	5500:  "fcp-addr-srvr1",
	5501:  "fcp-addr-srvr2",
	5502:  "fcp-srvr-inst1",
	5503:  "fcp-srvr-inst2",
	5504:  "fcp-cics-gw1",
	5505:  "checkoutdb",
	5506:  "amc",
	5507:  "psl-management",
	5550:  "cbus",
	5553:  "sgi-eventmond",
	5554:  "sgi-esphttp",
	5555:  "personal-agent",
	5556:  "freeciv",
	5557:  "farenet",
	5565:  "hpe-dp-bura",
	5566:  "westec-connect",
	5567:  "dof-dps-mc-sec",
	5568:  "sdt",
	5569:  "rdmnet-ctrl",
	5573:  "sdmmp",
	5574:  "lsi-bobcat",
	5575:  "ora-oap",
	5579:  "fdtracks",
	5580:  "tmosms0",
	5581:  "tmosms1",
	5582:  "fac-restore",
	5583:  "tmo-icon-sync",
	5584:  "bis-web",
	5585:  "bis-sync",
	5586:  "att-mt-sms",
	5597:  "ininmessaging",
	5598:  "mctfeed",
	5599:  "esinstall",
	5600:  "esmmanager",
	5601:  "esmagent",
	5602:  "a1-msc",
	5603:  "a1-bs",
	5604:  "a3-sdunode",
	5605:  "a4-sdunode",
	5618:  "efr",
	5627:  "ninaf",
	5628:  "htrust",
	5629:  "symantec-sfdb",
	5630:  "precise-comm",
	5631:  "pcanywheredata",
	5632:  "pcanywherestat",
	5633:  "beorl",
	5634:  "xprtld",
	5635:  "sfmsso",
	5636:  "sfm-db-server",
	5637:  "cssc",
	5638:  "flcrs",
	5639:  "ics",
	5646:  "vfmobile",
	5666:  "nrpe",
	5670:  "filemq",
	5671:  "amqps",
	5672:  "amqp",
	5673:  "jms",
	5674:  "hyperscsi-port",
	5675:  "v5ua",
	5676:  "raadmin",
	5677:  "questdb2-lnchr",
	5678:  "rrac",
	5679:  "dccm",
	5680:  "auriga-router",
	5681:  "ncxcp",
	5688:  "ggz",
	5689:  "qmvideo",
	5693:  "rbsystem",
	5696:  "kmip",
	5700:  "supportassist",
	5705:  "storageos",
	5713:  "proshareaudio",
	5714:  "prosharevideo",
	5715:  "prosharedata",
	5716:  "prosharerequest",
	5717:  "prosharenotify",
	5718:  "dpm",
	5719:  "dpm-agent",
	5720:  "ms-licensing",
	5721:  "dtpt",
	5722:  "msdfsr",
	5723:  "omhs",
	5724:  "omsdk",
	5725:  "ms-ilm",
	5726:  "ms-ilm-sts",
	5727:  "asgenf",
	5728:  "io-dist-data",
	5729:  "openmail",
	5730:  "unieng",
	5741:  "ida-discover1",
	5742:  "ida-discover2",
	5743:  "watchdoc-pod",
	5744:  "watchdoc",
	5745:  "fcopy-server",
	5746:  "fcopys-server",
	5747:  "tunatic",
	5748:  "tunalyzer",
	5750:  "rscd",
	5755:  "openmailg",
	5757:  "x500ms",
	5766:  "openmailns",
	5767:  "s-openmail",
	5768:  "openmailpxy",
	5769:  "spramsca",
	5770:  "spramsd",
	5771:  "netagent",
	5777:  "dali-port",
	5780:  "vts-rpc",
	5781:  "3par-evts",
	5782:  "3par-mgmt",
	5783:  "3par-mgmt-ssl",
	5785:  "3par-rcopy",
	5793:  "xtreamx",
	5813:  "icmpd",
	5814:  "spt-automation",
	5841:  "shiprush-d-ch",
	5842:  "reversion",
	5859:  "wherehoo",
	5863:  "ppsuitemsg",
	5868:  "diameters",
	5883:  "jute",
	5900:  "rfb",
	5910:  "cm",
	5911:  "cpdlc",
	5912:  "fis",
	5913:  "ads-c",
	5963:  "indy",
	5968:  "mppolicy-v5",
	5969:  "mppolicy-mgr",
	5984:  "couchdb",
	5985:  "wsman",
	5986:  "wsmans",
	5987:  "wbem-rmi",
	5988:  "wbem-http",
	5989:  "wbem-https",
	5990:  "wbem-exp-https",
	5991:  "nuxsl",
	5992:  "consul-insight",
	5993:  "cim-rs",
	5999:  "cvsup",
	6064:  "ndl-ahp-svc",
	6065:  "winpharaoh",
	6066:  "ewctsp",
	6068:  "gsmp-ancp",
	6069:  "trip",
	6070:  "messageasap",
	6071:  "ssdtp",
	6072:  "diagnose-proc",
	6073:  "directplay8",
	6074:  "max",
	6075:  "dpm-acm",
	6076:  "msft-dpm-cert",
	6077:  "iconstructsrv",
	6084:  "reload-config",
	6085:  "konspire2b",
	6086:  "pdtp",
	6087:  "ldss",
	6088:  "doglms",
	6099:  "raxa-mgmt",
	6100:  "synchronet-db",
	6101:  "synchronet-rtc",
	6102:  "synchronet-upd",
	6103:  "rets",
	6104:  "dbdb",
	6105:  "primaserver",
	6106:  "mpsserver",
	6107:  "etc-control",
	6108:  "sercomm-scadmin",
	6109:  "globecast-id",
	6110:  "softcm",
	6111:  "spc",
	6112:  "dtspcd",
	6113:  "dayliteserver",
	6114:  "wrspice",
	6115:  "xic",
	6116:  "xtlserv",
	6117:  "daylitetouch",
	6121:  "spdy",
	6122:  "bex-webadmin",
	6123:  "backup-express",
	6124:  "pnbs",
	6130:  "damewaremobgtwy",
	6133:  "nbt-wol",
	6140:  "pulsonixnls",
	6141:  "meta-corp",
	6142:  "aspentec-lm",
	6143:  "watershed-lm",
	6144:  "statsci1-lm",
	6145:  "statsci2-lm",
	6146:  "lonewolf-lm",
	6147:  "montage-lm",
	6148:  "ricardo-lm",
	6149:  "tal-pod",
	6159:  "efb-aci",
	6160:  "ecmp",
	6161:  "patrol-ism",
	6162:  "patrol-coll",
	6163:  "pscribe",
	6200:  "lm-x",
	6209:  "qmtps",
	6222:  "radmind",
	6241:  "jeol-nsdtp-1",
	6242:  "jeol-nsdtp-2",
	6243:  "jeol-nsdtp-3",
	6244:  "jeol-nsdtp-4",
	6251:  "tl1-raw-ssl",
	6252:  "tl1-ssh",
	6253:  "crip",
	6267:  "gld",
	6268:  "grid",
	6269:  "grid-alt",
	6300:  "bmc-grx",
	6301:  "bmc-ctd-ldap",
	6306:  "ufmp",
	6315:  "scup",
	6316:  "abb-escp",
	6317:  "nav-data-cmd",
	6320:  "repsvc",
	6321:  "emp-server1",
	6322:  "emp-server2",
	6324:  "hrd-ncs",
	6325:  "dt-mgmtsvc",
	6326:  "dt-vra",
	6343:  "sflow",
	6344:  "streletz",
	6346:  "gnutella-svc",
	6347:  "gnutella-rtr",
	6350:  "adap",
	6355:  "pmcs",
	6360:  "metaedit-mu",
	6370:  "metaedit-se",
	6379:  "redis",
	6382:  "metatude-mds",
	6389:  "clariion-evr01",
	6390:  "metaedit-ws",
	6417:  "faxcomservice",
	6418:  "syserverremote",
	6419:  "svdrp",
	6420:  "nim-vdrshell",
	6421:  "nim-wan",
	6432:  "pgbouncer",
	6442:  "tarp",
	6443:  "sun-sr-https",
	6444:  "sge-qmaster",
	6445:  "sge-execd",
	6446:  "mysql-proxy",
	6455:  "skip-cert-recv",
	6456:  "skip-cert-send",
	6464:  "ieee11073-20701",
	6471:  "lvision-lm",
	6480:  "sun-sr-http",
	6481:  "servicetags",
	6482:  "ldoms-mgmt",
	6483:  "SunVTS-RMI",
	6484:  "sun-sr-jms",
	6485:  "sun-sr-iiop",
	6486:  "sun-sr-iiops",
	6487:  "sun-sr-iiop-aut",
	6488:  "sun-sr-jmx",
	6489:  "sun-sr-admin",
	6500:  "boks",
	6501:  "boks-servc",
	6502:  "boks-servm",
	6503:  "boks-clntd",
	6505:  "badm-priv",
	6506:  "badm-pub",
	6507:  "bdir-priv",
	6508:  "bdir-pub",
	6509:  "mgcs-mfp-port",
	6510:  "mcer-port",
	6513:  "netconf-tls",
	6514:  "syslog-tls",
	6515:  "elipse-rec",
	6543:  "lds-distrib",
	6544:  "lds-dump",
	6547:  "apc-6547",
	6548:  "apc-6548",
	6549:  "apc-6549",
	6550:  "fg-sysupdate",
	6551:  "sum",
	6558:  "xdsxdm",
	6566:  "sane-port",
	6568:  "canit-store",
	6579:  "affiliate",
	6580:  "parsec-master",
	6581:  "parsec-peer",
	6582:  "parsec-game",
	6583:  "joaJewelSuite",
	6600:  "mshvlm",
	6601:  "mstmg-sstp",
	6602:  "wsscomfrmwk",
	6619:  "odette-ftps",
	6620:  "kftp-data",
	6621:  "kftp",
	6622:  "mcftp",
	6623:  "ktelnet",
	6624:  "datascaler-db",
	6625:  "datascaler-ctl",
	6626:  "wago-service",
	6627:  "nexgen",
	6628:  "afesc-mc",
	6629:  "nexgen-aux",
	6632:  "mxodbc-connect",
	6640:  "ovsdb",
	6653:  "openflow",
	6655:  "pcs-sf-ui-man",
	6656:  "emgmsg",
	6670:  "vocaltec-gold",
	6671:  "p4p-portal",
	6672:  "vision-server",
	6673:  "vision-elmd",
	6678:  "vfbp",
	6679:  "osaut",
	6687:  "clever-ctrace",
	6688:  "clever-tcpip",
	6689:  "tsa",
	6690:  "cleverdetect",
	6697:  "ircs-u",
	6701:  "kti-icad-srvr",
	6702:  "e-design-net",
	6703:  "e-design-web",
	6714:  "ibprotocol",
	6715:  "fibotrader-com",
	6716:  "princity-agent",
	6767:  "bmc-perf-agent",
	6768:  "bmc-perf-mgrd",
	6769:  "adi-gxp-srvprt",
	6770:  "plysrv-http",
	6771:  "plysrv-https",
	6777:  "ntz-tracker",
	6778:  "ntz-p2p-storage",
	6785:  "dgpf-exchg",
	6786:  "smc-jmx",
	6787:  "smc-admin",
	6788:  "smc-http",
	6789:  "radg",
	6790:  "hnmp",
	6791:  "hnm",
	6801:  "acnet",
	6817:  "pentbox-sim",
	6831:  "ambit-lm",
	6841:  "netmo-default",
	6842:  "netmo-http",
	6850:  "iccrushmore",
	6868:  "acctopus-cc",
	6888:  "muse",
	6900:  "rtimeviewer",
	6901:  "jetstream",
	6935:  "ethoscan",
	6936:  "xsmsvc",
	6946:  "bioserver",
	6951:  "otlp",
	6961:  "jmact3",
	6962:  "jmevt2",
	6963:  "swismgr1",
	6964:  "swismgr2",
	6965:  "swistrap",
	6966:  "swispol",
	6969:  "acmsoda",
	6970:  "conductor",
	6997:  "MobilitySrv",
	6998:  "iatp-highpri",
	6999:  "iatp-normalpri",
	7000:  "afs3-fileserver",
	7001:  "afs3-callback",
	7002:  "afs3-prserver",
	7003:  "afs3-vlserver",
	7004:  "afs3-kaserver",
	7005:  "afs3-volser",
	7006:  "afs3-errors",
	7007:  "afs3-bos",
	7008:  "afs3-update",
	7009:  "afs3-rmtsys",
	7010:  "ups-onlinet",
	7011:  "talon-disc",
	7012:  "talon-engine",
	7013:  "microtalon-dis",
	7014:  "microtalon-com",
	7015:  "talon-webserver",
	7016:  "spg",
	7017:  "grasp",
	7018:  "fisa-svc",
	7019:  "doceri-ctl",
	7020:  "dpserve",
	7021:  "dpserveadmin",
	7022:  "ctdp",
	7023:  "ct2nmcs",
	7024:  "vmsvc",
	7025:  "vmsvc-2",
	7030:  "op-probe",
	7031:  "iposplanet",
	7070:  "arcp",
	7071:  "iwg1",
	7073:  "martalk",
	7080:  "empowerid",
	7099:  "lazy-ptop",
	7100:  "font-service",
	7101:  "elcn",
	7117:  "rothaga",
	7121:  "virprot-lm",
	7128:  "scenidm",
	7129:  "scenccs",
	7161:  "cabsm-comm",
	7162:  "caistoragemgr",
	7163:  "cacsambroker",
	7164:  "fsr",
	7165:  "doc-server",
	7166:  "aruba-server",
	7167:  "casrmagent",
	7168:  "cnckadserver",
	7169:  "ccag-pib",
	7170:  "nsrp",
	7171:  "drm-production",
	7172:  "metalbend",
	7173:  "zsecure",
	7174:  "clutild",
	7200:  "fodms",
	7201:  "dlip",
	7202:  "pon-ictp",
	7215:  "PS-Server",
	7216:  "PS-Capture-Pro",
	7227:  "ramp",
	7228:  "citrixupp",
	7229:  "citrixuppg",
	7236:  "display",
	7237:  "pads",
	7244:  "frc-hicp",
	7262:  "cnap",
	7272:  "watchme-7272",
	7273:  "oma-rlp",
	7274:  "oma-rlp-s",
	7275:  "oma-ulp",
	7276:  "oma-ilp",
	7277:  "oma-ilp-s",
	7278:  "oma-dcdocbs",
	7279:  "ctxlic",
	7280:  "itactionserver1",
	7281:  "itactionserver2",
	7282:  "mzca-action",
	7283:  "genstat",
	7365:  "lcm-server",
	7391:  "mindfilesys",
	7392:  "mrssrendezvous",
	7393:  "nfoldman",
	7394:  "fse",
	7395:  "winqedit",
	7397:  "hexarc",
	7400:  "rtps-discovery",
	7401:  "rtps-dd-ut",
	7402:  "rtps-dd-mt",
	7410:  "ionixnetmon",
	7411:  "daqstream",
	7421:  "mtportmon",
	7426:  "pmdmgr",
	7427:  "oveadmgr",
	7428:  "ovladmgr",
	7429:  "opi-sock",
	7430:  "xmpv7",
	7431:  "pmd",
	7437:  "faximum",
	7443:  "oracleas-https",
	7471:  "sttunnel",
	7473:  "rise",
	7474:  "neo4j",
	7478:  "openit",
	7491:  "telops-lmd",
	7500:  "silhouette",
	7501:  "ovbus",
	7508:  "adcp",
	7509:  "acplt",
	7510:  "ovhpas",
	7511:  "pafec-lm",
	7542:  "saratoga",
	7543:  "atul",
	7544:  "nta-ds",
	7545:  "nta-us",
	7546:  "cfs",
	7547:  "cwmp",
	7548:  "tidp",
	7549:  "nls-tl",
	7551:  "controlone-con",
	7560:  "sncp",
	7563:  "cfw",
	7566:  "vsi-omega",
	7569:  "dell-eql-asm",
	7570:  "aries-kfinder",
	7574:  "coherence",
	7588:  "sun-lm",
	7606:  "mipi-debug",
	7624:  "indi",
	7626:  "simco",
	7627:  "soap-http",
	7628:  "zen-pawn",
	7629:  "xdas",
	7630:  "hawk",
	7631:  "tesla-sys-msg",
	7633:  "pmdfmgt",
	7648:  "cuseeme",
	7672:  "imqstomp",
	7673:  "imqstomps",
	7674:  "imqtunnels",
	7675:  "imqtunnel",
	7676:  "imqbrokerd",
	7677:  "sun-user-https",
	7680:  "pando-pub",
	7683:  "dmt",
	7687:  "bolt",
	7689:  "collaber",
	7697:  "klio",
	7700:  "em7-secom",
	7707:  "sync-em7",
	7708:  "scinet",
	7720:  "medimageportal",
	7724:  "nsdeepfreezectl",
	7725:  "nitrogen",
	7726:  "freezexservice",
	7727:  "trident-data",
	7728:  "osvr",
	7734:  "smip",
	7738:  "aiagent",
	7741:  "scriptview",
	7742:  "msss",
	7743:  "sstp-1",
	7744:  "raqmon-pdu",
	7747:  "prgp",
	7775:  "inetfs",
	7777:  "cbt",
	7778:  "interwise",
	7779:  "vstat",
	7781:  "accu-lmgr",
	7786:  "minivend",
	7787:  "popup-reminders",
	7789:  "office-tools",
	7794:  "q3ade",
	7797:  "pnet-conn",
	7798:  "pnet-enc",
	7799:  "altbsdp",
	7800:  "asr",
	7801:  "ssp-client",
	7810:  "rbt-wanopt",
	7845:  "apc-7845",
	7846:  "apc-7846",
	7847:  "csoauth",
	7869:  "mobileanalyzer",
	7870:  "rbt-smc",
	7871:  "mdm",
	7878:  "owms",
	7880:  "pss",
	7887:  "ubroker",
	7900:  "mevent",
	7901:  "tnos-sp",
	7902:  "tnos-dp",
	7903:  "tnos-dps",
	7913:  "qo-secure",
	7932:  "t2-drm",
	7933:  "t2-brm",
	7962:  "generalsync",
	7967:  "supercell",
	7979:  "micromuse-ncps",
	7980:  "quest-vista",
	7981:  "sossd-collect",
	7982:  "sossd-agent",
	7997:  "pushns",
	7999:  "irdmi2",
	8000:  "irdmi",
	8001:  "vcom-tunnel",
	8002:  "teradataordbms",
	8003:  "mcreport",
	8005:  "mxi",
	8006:  "wpl-analytics",
	8007:  "warppipe",
	8008:  "http-alt",
	8019:  "qbdb",
	8020:  "intu-ec-svcdisc",
	8021:  "intu-ec-client",
	8022:  "oa-system",
	8025:  "ca-audit-da",
	8026:  "ca-audit-ds",
	8032:  "pro-ed",
	8033:  "mindprint",
	8034:  "vantronix-mgmt",
	8040:  "ampify",
	8041:  "enguity-xccetp",
	8042:  "fs-agent",
	8043:  "fs-server",
	8044:  "fs-mgmt",
	8051:  "rocrail",
	8052:  "senomix01",
	8053:  "senomix02",
	8054:  "senomix03",
	8055:  "senomix04",
	8056:  "senomix05",
	8057:  "senomix06",
	8058:  "senomix07",
	8059:  "senomix08",
	8066:  "toad-bi-appsrvr",
	8067:  "infi-async",
	8070:  "ucs-isc",
	8074:  "gadugadu",
	8077:  "mles",
	8080:  "http-alt",
	8081:  "sunproxyadmin",
	8082:  "us-cli",
	8083:  "us-srv",
	8086:  "d-s-n",
	8087:  "simplifymedia",
	8088:  "radan-http",
	8090:  "opsmessaging",
	8091:  "jamlink",
	8097:  "sac",
	8100:  "xprint-server",
	8101:  "ldoms-migr",
	8102:  "kz-migr",
	8115:  "mtl8000-matrix",
	8116:  "cp-cluster",
	8117:  "purityrpc",
	8118:  "privoxy",
	8121:  "apollo-data",
	8122:  "apollo-admin",
	8128:  "paycash-online",
	8129:  "paycash-wbp",
	8130:  "indigo-vrmi",
	8131:  "indigo-vbcp",
	8132:  "dbabble",
	8140:  "puppet",
	8148:  "isdd",
	8153:  "quantastor",
	8160:  "patrol",
	8161:  "patrol-snmp",
	8162:  "lpar2rrd",
	8181:  "intermapper",
	8182:  "vmware-fdm",
	8183:  "proremote",
	8184:  "itach",
	8190:  "gcp-rphy",
	8191:  "limnerpressure",
	8192:  "spytechphone",
	8194:  "blp1",
	8195:  "blp2",
	8199:  "vvr-data",
	8200:  "trivnet1",
	8201:  "trivnet2",
	8204:  "lm-perfworks",
	8205:  "lm-instmgr",
	8206:  "lm-dta",
	8207:  "lm-sserver",
	8208:  "lm-webwatcher",
	8230:  "rexecj",
	8243:  "synapse-nhttps",
	8270:  "robot-remote",
	8276:  "pando-sec",
	8280:  "synapse-nhttp",
	8282:  "libelle",
	8292:  "blp3",
	8293:  "hiperscan-id",
	8294:  "blp4",
	8300:  "tmi",
	8301:  "amberon",
	8313:  "hub-open-net",
	8320:  "tnp-discover",
	8321:  "tnp",
	8322:  "garmin-marine",
	8351:  "server-find",
	8376:  "cruise-enum",
	8377:  "cruise-swroute",
	8378:  "cruise-config",
	8379:  "cruise-diags",
	8380:  "cruise-update",
	8383:  "m2mservices",
	8400:  "cvd",
	8401:  "sabarsd",
	8402:  "abarsd",
	8403:  "admind",
	8404:  "svcloud",
	8405:  "svbackup",
	8415:  "dlpx-sp",
	8416:  "espeech",
	8417:  "espeech-rtp",
	8423:  "aritts",
	8442:  "cybro-a-bus",
	8443:  "pcsync-https",
	8444:  "pcsync-http",
	8445:  "copy",
	8450:  "npmp",
	8457:  "nexentamv",
	8470:  "cisco-avp",
	8471:  "pim-port",
	8472:  "otv",
	8473:  "vp2p",
	8474:  "noteshare",
	8500:  "fmtp",
	8501:  "cmtp-mgt",
	8502:  "ftnmtp",
	8554:  "rtsp-alt",
	8555:  "d-fence",
	8567:  "dof-tunnel",
	8600:  "asterix",
	8610:  "canon-mfnp",
	8611:  "canon-bjnp1",
	8612:  "canon-bjnp2",
	8613:  "canon-bjnp3",
	8614:  "canon-bjnp4",
	8615:  "imink",
	8665:  "monetra",
	8666:  "monetra-admin",
	8675:  "msi-cps-rm",
	8686:  "sun-as-jmxrmi",
	8688:  "openremote-ctrl",
	8699:  "vnyx",
	8711:  "nvc",
	8733:  "ibus",
	8750:  "dey-keyneg",
	8763:  "mc-appserver",
	8764:  "openqueue",
	8765:  "ultraseek-http",
	8766:  "amcs",
	8770:  "dpap",
	8778:  "uec",
	8786:  "msgclnt",
	8787:  "msgsrvr",
	8793:  "acd-pm",
	8800:  "sunwebadmin",
	8804:  "truecm",
	8873:  "dxspider",
	8880:  "cddbp-alt",
	8881:  "galaxy4d",
	8883:  "secure-mqtt",
	8888:  "ddi-tcp-1",
	8889:  "ddi-tcp-2",
	8890:  "ddi-tcp-3",
	8891:  "ddi-tcp-4",
	8892:  "ddi-tcp-5",
	8893:  "ddi-tcp-6",
	8894:  "ddi-tcp-7",
	8899:  "ospf-lite",
	8900:  "jmb-cds1",
	8901:  "jmb-cds2",
	8910:  "manyone-http",
	8911:  "manyone-xml",
	8912:  "wcbackup",
	8913:  "dragonfly",
	8937:  "twds",
	8953:  "ub-dns-control",
	8954:  "cumulus-admin",
	8980:  "nod-provider",
	8989:  "sunwebadmins",
	8990:  "http-wmap",
	8991:  "https-wmap",
	8997:  "oracle-ms-ens",
	8998:  "canto-roboflow",
	8999:  "bctp",
	9000:  "cslistener",
	9001:  "etlservicemgr",
	9002:  "dynamid",
	9005:  "golem",
	9008:  "ogs-server",
	9009:  "pichat",
	9010:  "sdr",
	9020:  "tambora",
	9021:  "panagolin-ident",
	9022:  "paragent",
	9023:  "swa-1",
	9024:  "swa-2",
	9025:  "swa-3",
	9026:  "swa-4",
	9050:  "versiera",
	9051:  "fio-cmgmt",
	9060:  "CardWeb-IO",
	9080:  "glrpc",
	9083:  "emc-pp-mgmtsvc",
	9084:  "aurora",
	9085:  "ibm-rsyscon",
	9086:  "net2display",
	9087:  "classic",
	9088:  "sqlexec",
	9089:  "sqlexec-ssl",
	9090:  "websm",
	9091:  "xmltec-xmlmail",
	9092:  "XmlIpcRegSvc",
	9093:  "copycat",
	9100:  "hp-pdl-datastr",
	9101:  "bacula-dir",
	9102:  "bacula-fd",
	9103:  "bacula-sd",
	9104:  "peerwire",
	9105:  "xadmin",
	9106:  "astergate",
	9107:  "astergatefax",
	9119:  "mxit",
	9122:  "grcmp",
	9123:  "grcp",
	9131:  "dddp",
	9160:  "apani1",
	9161:  "apani2",
	9162:  "apani3",
	9163:  "apani4",
	9164:  "apani5",
	9191:  "sun-as-jpda",
	9200:  "wap-wsp",
	9201:  "wap-wsp-wtp",
	9202:  "wap-wsp-s",
	9203:  "wap-wsp-wtp-s",
	9204:  "wap-vcard",
	9205:  "wap-vcal",
	9206:  "wap-vcard-s",
	9207:  "wap-vcal-s",
	9208:  "rjcdb-vcards",
	9209:  "almobile-system",
	9210:  "oma-mlp",
	9211:  "oma-mlp-s",
	9212:  "serverviewdbms",
	9213:  "serverstart",
	9214:  "ipdcesgbs",
	9215:  "insis",
	9216:  "acme",
	9217:  "fsc-port",
	9222:  "teamcoherence",
	9255:  "mon",
	9278:  "pegasus",
	9279:  "pegasus-ctl",
	9280:  "pgps",
	9281:  "swtp-port1",
	9282:  "swtp-port2",
	9283:  "callwaveiam",
	9284:  "visd",
	9285:  "n2h2server",
	9287:  "cumulus",
	9292:  "armtechdaemon",
	9293:  "storview",
	9294:  "armcenterhttp",
	9295:  "armcenterhttps",
	9300:  "vrace",
	9306:  "sphinxql",
	9312:  "sphinxapi",
	9318:  "secure-ts",
	9321:  "guibase",
	9343:  "mpidcmgr",
	9344:  "mphlpdmc",
	9345:  "rancher",
	9346:  "ctechlicensing",
	9374:  "fjdmimgr",
	9380:  "boxp",
	9387:  "d2dconfig",
	9388:  "d2ddatatrans",
	9389:  "adws",
	9390:  "otp",
	9396:  "fjinvmgr",
	9397:  "mpidcagt",
	9400:  "sec-t4net-srv",
	9401:  "sec-t4net-clt",
	9402:  "sec-pc2fax-srv",
	9418:  "git",
	9443:  "tungsten-https",
	9444:  "wso2esb-console",
	9445:  "mindarray-ca",
	9450:  "sntlkeyssrvr",
	9500:  "ismserver",
	9535:  "mngsuite",
	9536:  "laes-bf",
	9555:  "trispen-sra",
	9592:  "ldgateway",
	9593:  "cba8",
	9594:  "msgsys",
	9595:  "pds",
	9596:  "mercury-disc",
	9597:  "pd-admin",
	9598:  "vscp",
	9599:  "robix",
	9600:  "micromuse-ncpw",
	9612:  "streamcomm-ds",
	9614:  "iadt-tls",
	9616:  "erunbook-agent",
	9617:  "erunbook-server",
	9618:  "condor",
	9628:  "odbcpathway",
	9629:  "uniport",
	9630:  "peoctlr",
	9631:  "peocoll",
	9640:  "pqsflows",
	9666:  "zoomcp",
	9667:  "xmms2",
	9668:  "tec5-sdctp",
	9694:  "client-wakeup",
	9695:  "ccnx",
	9700:  "board-roar",
	9747:  "l5nas-parchan",
	9750:  "board-voip",
	9753:  "rasadv",
	9762:  "tungsten-http",
	9800:  "davsrc",
	9801:  "sstp-2",
	9802:  "davsrcs",
	9875:  "sapv1",
	9876:  "sd",
	9888:  "cyborg-systems",
	9889:  "gt-proxy",
	9898:  "monkeycom",
	9900:  "iua",
	9909:  "domaintime",
	9911:  "sype-transport",
	9925:  "xybrid-cloud",
	9950:  "apc-9950",
	9951:  "apc-9951",
	9952:  "apc-9952",
	9953:  "acis",
	9954:  "hinp",
	9955:  "alljoyn-stm",
	9966:  "odnsp",
	9978:  "xybrid-rt",
	9979:  "visweather",
	9981:  "pumpkindb",
	9987:  "dsm-scm-target",
	9988:  "nsesrvr",
	9990:  "osm-appsrvr",
	9991:  "osm-oev",
	9992:  "palace-1",
	9993:  "palace-2",
	9994:  "palace-3",
	9995:  "palace-4",
	9996:  "palace-5",
	9997:  "palace-6",
	9998:  "distinct32",
	9999:  "distinct",
	10000: "ndmp",
	10001: "scp-config",
	10002: "documentum",
	10003: "documentum-s",
	10004: "emcrmirccd",
	10005: "emcrmird",
	10006: "netapp-sync",
	10007: "mvs-capacity",
	10008: "octopus",
	10009: "swdtp-sv",
	10010: "rxapi",
	10020: "abb-hw",
	10050: "zabbix-agent",
	10051: "zabbix-trapper",
	10055: "qptlmd",
	10080: "amanda",
	10081: "famdc",
	10100: "itap-ddtp",
	10101: "ezmeeting-2",
	10102: "ezproxy-2",
	10103: "ezrelay",
	10104: "swdtp",
	10107: "bctp-server",
	10110: "nmea-0183",
	10113: "netiq-endpoint",
	10114: "netiq-qcheck",
	10115: "netiq-endpt",
	10116: "netiq-voipa",
	10117: "iqrm",
	10125: "cimple",
	10128: "bmc-perf-sd",
	10129: "bmc-gms",
	10160: "qb-db-server",
	10161: "snmptls",
	10162: "snmptls-trap",
	10200: "trisoap",
	10201: "rsms",
	10252: "apollo-relay",
	10260: "axis-wimp-port",
	10261: "tile-ml",
	10288: "blocks",
	10321: "cosir",
	10540: "MOS-lower",
	10541: "MOS-upper",
	10542: "MOS-aux",
	10543: "MOS-soap",
	10544: "MOS-soap-opt",
	10548: "serverdocs",
	10631: "printopia",
	10800: "gap",
	10805: "lpdg",
	10809: "nbd",
	10860: "helix",
	10880: "bveapi",
	10933: "octopustentacle",
	10990: "rmiaux",
	11000: "irisa",
	11001: "metasys",
	11095: "weave",
	11103: "origo-sync",
	11104: "netapp-icmgmt",
	11105: "netapp-icdata",
	11106: "sgi-lk",
	11109: "sgi-dmfmgr",
	11110: "sgi-soap",
	11111: "vce",
	11112: "dicom",
	11161: "suncacao-snmp",
	11162: "suncacao-jmxmp",
	11163: "suncacao-rmi",
	11164: "suncacao-csa",
	11165: "suncacao-websvc",
	11172: "oemcacao-jmxmp",
	11173: "t5-straton",
	11174: "oemcacao-rmi",
	11175: "oemcacao-websvc",
	11201: "smsqp",
	11202: "dcsl-backup",
	11208: "wifree",
	11211: "memcache",
	11319: "imip",
	11320: "imip-channels",
	11321: "arena-server",
	11367: "atm-uhas",
	11371: "hkp",
	11489: "asgcypresstcps",
	11600: "tempest-port",
	11623: "emc-xsw-dconfig",
	11720: "h323callsigalt",
	11723: "emc-xsw-dcache",
	11751: "intrepid-ssl",
	11796: "lanschool",
	11876: "xoraya",
	11967: "sysinfo-sp",
	12000: "entextxid",
	12001: "entextnetwk",
	12002: "entexthigh",
	12003: "entextmed",
	12004: "entextlow",
	12005: "dbisamserver1",
	12006: "dbisamserver2",
	12007: "accuracer",
	12008: "accuracer-dbms",
	12010: "edbsrvr",
	12012: "vipera",
	12013: "vipera-ssl",
	12109: "rets-ssl",
	12121: "nupaper-ss",
	12168: "cawas",
	12172: "hivep",
	12300: "linogridengine",
	12302: "rads",
	12321: "warehouse-sss",
	12322: "warehouse",
	12345: "italk",
	12753: "tsaf",
	12865: "netperf",
	13160: "i-zipqd",
	13216: "bcslogc",
	13217: "rs-pias",
	13218: "emc-vcas-tcp",
	13223: "powwow-client",
	13224: "powwow-server",
	13400: "doip-data",
	13720: "bprd",
	13721: "bpdbm",
	13722: "bpjava-msvc",
	13724: "vnetd",
	13782: "bpcd",
	13783: "vopied",
	13785: "nbdb",
	13786: "nomdb",
	13818: "dsmcc-config",
	13819: "dsmcc-session",
	13820: "dsmcc-passthru",
	13821: "dsmcc-download",
	13822: "dsmcc-ccp",
	13823: "bmdss",
	13894: "ucontrol",
	13929: "dta-systems",
	13930: "medevolve",
	14000: "scotty-ft",
	14001: "sua",
	14033: "sage-best-com1",
	14034: "sage-best-com2",
	14141: "vcs-app",
	14142: "icpp",
	14143: "icpps",
	14145: "gcm-app",
	14149: "vrts-tdd",
	14150: "vcscmd",
	14154: "vad",
	14250: "cps",
	14414: "ca-web-update",
	14500: "xpra",
	14936: "hde-lcesrvr-1",
	14937: "hde-lcesrvr-2",
	15000: "hydap",
	15002: "onep-tls",
	15345: "xpilot",
	15363: "3link",
	15555: "cisco-snat",
	15660: "bex-xr",
	15740: "ptp",
	15999: "programmar",
	16000: "fmsas",
	16001: "fmsascon",
	16002: "gsms",
	16020: "jwpc",
	16021: "jwpc-bin",
	16161: "sun-sea-port",
	16162: "solaris-audit",
	16309: "etb4j",
	16310: "pduncs",
	16311: "pdefmns",
	16360: "netserialext1",
	16361: "netserialext2",
	16367: "netserialext3",
	16368: "netserialext4",
	16384: "connected",
	16385: "rdgs",
	16619: "xoms",
	16665: "axon-tunnel",
	16789: "cadsisvr",
	16900: "newbay-snc-mc",
	16950: "sgcip",
	16991: "intel-rci-mp",
	16992: "amt-soap-http",
	16993: "amt-soap-https",
	16994: "amt-redir-tcp",
	16995: "amt-redir-tls",
	17007: "isode-dua",
	17184: "vestasdlp",
	17185: "soundsvirtual",
	17219: "chipper",
	17220: "avtp",
	17221: "avdecc",
	17223: "isa100-gci",
	17225: "trdp-md",
	17234: "integrius-stp",
	17235: "ssh-mgmt",
	17500: "db-lsp",
	17555: "ailith",
	17729: "ea",
	17754: "zep",
	17755: "zigbee-ip",
	17756: "zigbee-ips",
	17777: "sw-orion",
	18000: "biimenu",
	18104: "radpdf",
	18136: "racf",
	18181: "opsec-cvp",
	18182: "opsec-ufp",
	18183: "opsec-sam",
	18184: "opsec-lea",
	18185: "opsec-omi",
	18186: "ohsc",
	18187: "opsec-ela",
	18241: "checkpoint-rtm",
	18242: "iclid",
	18243: "clusterxl",
	18262: "gv-pf",
	18463: "ac-cluster",
	18634: "rds-ib",
	18635: "rds-ip",
	18668: "vdmmesh",
	18769: "ique",
	18881: "infotos",
	18888: "apc-necmp",
	19000: "igrid",
	19007: "scintilla",
	19020: "j-link",
	19191: "opsec-uaa",
	19194: "ua-secureagent",
	19220: "cora",
	19283: "keysrvr",
	19315: "keyshadow",
	19398: "mtrgtrans",
	19410: "hp-sco",
	19411: "hp-sca",
	19412: "hp-sessmon",
	19539: "fxuptp",
	19540: "sxuptp",
	19541: "jcp",
	19998: "iec-104-sec",
	19999: "dnp-sec",
	20000: "dnp",
	20001: "microsan",
	20002: "commtact-http",
	20003: "commtact-https",
	20005: "openwebnet",
	20013: "ss-idi",
	20014: "opendeploy",
	20034: "nburn-id",
	20046: "tmophl7mts",
	20048: "mountd",
	20049: "nfsrdma",
	20057: "avesterra",
	20167: "tolfab",
	20202: "ipdtp-port",
	20222: "ipulse-ics",
	20480: "emwavemsg",
	20670: "track",
	20999: "athand-mmp",
	21000: "irtrans",
	21010: "notezilla-lan",
	21221: "aigairserver",
	21553: "rdm-tfs",
	21554: "dfserver",
	21590: "vofr-gateway",
	21800: "tvpm",
	21845: "webphone",
	21846: "netspeak-is",
	21847: "netspeak-cs",
	21848: "netspeak-acd",
	21849: "netspeak-cps",
	22000: "snapenetio",
	22001: "optocontrol",
	22002: "optohost002",
	22003: "optohost003",
	22004: "optohost004",
	22005: "optohost004",
	22125: "dcap",
	22128: "gsidcap",
	22222: "easyengine",
	22273: "wnn6",
	22305: "cis",
	22335: "shrewd-control",
	22343: "cis-secure",
	22347: "wibukey",
	22350: "codemeter",
	22351: "codemeter-cmwan",
	22537: "caldsoft-backup",
	22555: "vocaltec-wconf",
	22763: "talikaserver",
	22800: "aws-brf",
	22951: "brf-gw",
	23000: "inovaport1",
	23001: "inovaport2",
	23002: "inovaport3",
	23003: "inovaport4",
	23004: "inovaport5",
	23005: "inovaport6",
	23053: "gntp",
	23294: "5afe-dir",
	23333: "elxmgmt",
	23400: "novar-dbase",
	23401: "novar-alarm",
	23402: "novar-global",
	23456: "aequus",
	23457: "aequus-alt",
	23546: "areaguard-neo",
	24000: "med-ltp",
	24001: "med-fsp-rx",
	24002: "med-fsp-tx",
	24003: "med-supp",
	24004: "med-ovw",
	24005: "med-ci",
	24006: "med-net-svc",
	24242: "filesphere",
	24249: "vista-4gl",
	24321: "ild",
	24386: "intel-rci",
	24465: "tonidods",
	24554: "binkp",
	24577: "bilobit",
	24666: "sdtvwcam",
	24676: "canditv",
	24677: "flashfiler",
	24678: "proactivate",
	24680: "tcc-http",
	24754: "cslg",
	24922: "find",
	25000: "icl-twobase1",
	25001: "icl-twobase2",
	25002: "icl-twobase3",
	25003: "icl-twobase4",
	25004: "icl-twobase5",
	25005: "icl-twobase6",
	25006: "icl-twobase7",
	25007: "icl-twobase8",
	25008: "icl-twobase9",
	25009: "icl-twobase10",
	25576: "sauterdongle",
	25604: "idtp",
	25793: "vocaltec-hos",
	25900: "tasp-net",
	25901: "niobserver",
	25902: "nilinkanalyst",
	25903: "niprobe",
	26000: "quake",
	26133: "scscp",
	26208: "wnn6-ds",
	26257: "cockroach",
	26260: "ezproxy",
	26261: "ezmeeting",
	26262: "k3software-svr",
	26263: "k3software-cli",
	26486: "exoline-tcp",
	26487: "exoconfig",
	26489: "exonet",
	27345: "imagepump",
	27442: "jesmsjc",
	27504: "kopek-httphead",
	27782: "ars-vista",
	27876: "astrolink",
	27999: "tw-auth-key",
	28000: "nxlmd",
	28001: "pqsp",
	28200: "voxelstorm",
	28240: "siemensgsm",
	28589: "bosswave",
	29167: "otmp",
	29999: "bingbang",
	30000: "ndmps",
	30001: "pago-services1",
	30002: "pago-services2",
	30003: "amicon-fpsu-ra",
	30100: "rwp",
	30260: "kingdomsonline",
	30400: "gs-realtime",
	30999: "ovobs",
	31016: "ka-sddp",
	31020: "autotrac-acp",
	31400: "pace-licensed",
	31416: "xqosd",
	31457: "tetrinet",
	31620: "lm-mon",
	31685: "dsx-monitor",
	31765: "gamesmith-port",
	31948: "iceedcp-tx",
	31949: "iceedcp-rx",
	32034: "iracinghelper",
	32249: "t1distproc60",
	32400: "plex",
	32483: "apm-link",
	32635: "sec-ntb-clnt",
	32636: "DMExpress",
	32767: "filenet-powsrm",
	32768: "filenet-tms",
	32769: "filenet-rpc",
	32770: "filenet-nch",
	32771: "filenet-rmi",
	32772: "filenet-pa",
	32773: "filenet-cm",
	32774: "filenet-re",
	32775: "filenet-pch",
	32776: "filenet-peior",
	32777: "filenet-obrok",
	32801: "mlsn",
	32811: "retp",
	32896: "idmgratm",
	33060: "mysqlx",
	33123: "aurora-balaena",
	33331: "diamondport",
	33333: "dgi-serv",
	33334: "speedtrace",
	33434: "traceroute",
	33656: "snip-slave",
	34249: "turbonote-2",
	34378: "p-net-local",
	34379: "p-net-remote",
	34567: "dhanalakshmi",
	34962: "profinet-rt",
	34963: "profinet-rtm",
	34964: "profinet-cm",
	34980: "ethercat",
	35000: "heathview",
	35001: "rt-viewer",
	35002: "rt-sound",
	35003: "rt-devicemapper",
	35004: "rt-classmanager",
	35005: "rt-labtracker",
	35006: "rt-helper",
	35100: "axio-disc",
	35354: "kitim",
	35355: "altova-lm",
	35356: "guttersnex",
	35357: "openstack-id",
	36001: "allpeers",
	36524: "febooti-aw",
	36602: "observium-agent",
	36700: "mapx",
	36865: "kastenxpipe",
	37475: "neckar",
	37483: "gdrive-sync",
	37601: "eftp",
	37654: "unisys-eportal",
	38000: "ivs-database",
	38001: "ivs-insertion",
	38002: "cresco-control",
	38201: "galaxy7-data",
	38202: "fairview",
	38203: "agpolicy",
	38800: "sruth",
	38865: "secrmmsafecopya",
	39681: "turbonote-1",
	40000: "safetynetp",
	40404: "sptx",
	40841: "cscp",
	40842: "csccredir",
	40843: "csccfirewall",
	41111: "fs-qos",
	41121: "tentacle",
	41230: "z-wave-s",
	41794: "crestron-cip",
	41795: "crestron-ctp",
	41796: "crestron-cips",
	41797: "crestron-ctps",
	42508: "candp",
	42509: "candrp",
	42510: "caerpc",
	43000: "recvr-rc",
	43188: "reachout",
	43189: "ndm-agent-port",
	43190: "ip-provision",
	43191: "noit-transport",
	43210: "shaperai",
	43439: "eq3-update",
	43440: "ew-mgmt",
	43441: "ciscocsdb",
	44123: "z-wave-tunnel",
	44321: "pmcd",
	44322: "pmcdproxy",
	44323: "pmwebapi",
	44444: "cognex-dataman",
	44553: "rbr-debug",
	44818: "EtherNet-IP-2",
	44900: "m3da",
	45000: "asmp",
	45001: "asmps",
	45002: "rs-status",
	45045: "synctest",
	45054: "invision-ag",
	45514: "cloudcheck",
	45678: "eba",
	45824: "dai-shell",
	45825: "qdb2service",
	45966: "ssr-servermgr",
	46336: "inedo",
	46998: "spremotetablet",
	46999: "mediabox",
	47000: "mbus",
	47001: "winrm",
	47557: "dbbrowse",
	47624: "directplaysrvr",
	47806: "ap",
	47808: "bacnet",
	48000: "nimcontroller",
	48001: "nimspooler",
	48002: "nimhub",
	48003: "nimgtw",
	48004: "nimbusdb",
	48005: "nimbusdbctrl",
	48049: "3gpp-cbsp",
	48050: "weandsf",
	48128: "isnetserv",
	48129: "blp5",
	48556: "com-bardac-dw",
	48619: "iqobject",
	48653: "robotraconteur",
	49000: "matahari",
	49001: "nusrp",
}
var udpPortNames = map[uint16]string{
	1:     "tcpmux",
	2:     "compressnet",
	3:     "compressnet",
	5:     "rje",
	7:     "echo",
	9:     "discard",
	11:    "systat",
	13:    "daytime",
	17:    "qotd",
	18:    "msp",
	19:    "chargen",
	20:    "ftp-data",
	21:    "ftp",
	22:    "ssh",
	23:    "telnet",
	25:    "smtp",
	27:    "nsw-fe",
	29:    "msg-icp",
	31:    "msg-auth",
	33:    "dsp",
	37:    "time",
	38:    "rap",
	39:    "rlp",
	41:    "graphics",
	42:    "name",
	43:    "nicname",
	44:    "mpm-flags",
	45:    "mpm",
	46:    "mpm-snd",
	48:    "auditd",
	49:    "tacacs",
	50:    "re-mail-ck",
	52:    "xns-time",
	53:    "domain",
	54:    "xns-ch",
	55:    "isi-gl",
	56:    "xns-auth",
	58:    "xns-mail",
	62:    "acas",
	63:    "whoispp",
	64:    "covia",
	65:    "tacacs-ds",
	66:    "sql-net",
	67:    "bootps",
	68:    "bootpc",
	69:    "tftp",
	70:    "gopher",
	71:    "netrjs-1",
	72:    "netrjs-2",
	73:    "netrjs-3",
	74:    "netrjs-4",
	76:    "deos",
	78:    "vettcp",
	79:    "finger",
	80:    "http",
	82:    "xfer",
	83:    "mit-ml-dev",
	84:    "ctf",
	85:    "mit-ml-dev",
	86:    "mfcobol",
	88:    "kerberos",
	89:    "su-mit-tg",
	90:    "dnsix",
	91:    "mit-dov",
	92:    "npp",
	93:    "dcp",
	94:    "objcall",
	95:    "supdup",
	96:    "dixie",
	97:    "swift-rvf",
	98:    "tacnews",
	99:    "metagram",
	101:   "hostname",
	102:   "iso-tsap",
	103:   "gppitnp",
	104:   "acr-nema",
	105:   "cso",
	106:   "3com-tsmux",
	107:   "rtelnet",
	108:   "snagas",
	109:   "pop2",
	110:   "pop3",
	111:   "sunrpc",
	112:   "mcidas",
	113:   "auth",
	115:   "sftp",
	116:   "ansanotify",
	117:   "uucp-path",
	118:   "sqlserv",
	119:   "nntp",
	120:   "cfdptkt",
	121:   "erpc",
	122:   "smakynet",
	123:   "ntp",
	124:   "ansatrader",
	125:   "locus-map",
	126:   "nxedit",
	127:   "locus-con",
	128:   "gss-xlicen",
	129:   "pwdgen",
	130:   "cisco-fna",
	131:   "cisco-tna",
	132:   "cisco-sys",
	133:   "statsrv",
	134:   "ingres-net",
	135:   "epmap",
	136:   "profile",
	137:   "netbios-ns",
	138:   "netbios-dgm",
	139:   "netbios-ssn",
	140:   "emfis-data",
	141:   "emfis-cntl",
	142:   "bl-idm",
	143:   "imap",
	144:   "uma",
	145:   "uaac",
	146:   "iso-tp0",
	147:   "iso-ip",
	148:   "jargon",
	149:   "aed-512",
	150:   "sql-net",
	151:   "hems",
	152:   "bftp",
	153:   "sgmp",
	154:   "netsc-prod",
	155:   "netsc-dev",
	156:   "sqlsrv",
	157:   "knet-cmp",
	158:   "pcmail-srv",
	159:   "nss-routing",
	160:   "sgmp-traps",
	161:   "snmp",
	162:   "snmptrap",
	163:   "cmip-man",
	164:   "cmip-agent",
	165:   "xns-courier",
	166:   "s-net",
	167:   "namp",
	168:   "rsvd",
	169:   "send",
	170:   "print-srv",
	171:   "multiplex",
	172:   "cl-1",
	173:   "xyplex-mux",
	174:   "mailq",
	175:   "vmnet",
	176:   "genrad-mux",
	177:   "xdmcp",
	178:   "nextstep",
	179:   "bgp",
	180:   "ris",
	181:   "unify",
	182:   "audit",
	183:   "ocbinder",
	184:   "ocserver",
	185:   "remote-kis",
	186:   "kis",
	187:   "aci",
	188:   "mumps",
	189:   "qft",
	190:   "gacp",
	191:   "prospero",
	192:   "osu-nms",
	193:   "srmp",
	194:   "irc",
	195:   "dn6-nlm-aud",
	196:   "dn6-smm-red",
	197:   "dls",
	198:   "dls-mon",
	199:   "smux",
	200:   "src",
	201:   "at-rtmp",
	202:   "at-nbp",
	203:   "at-3",
	204:   "at-echo",
	205:   "at-5",
	206:   "at-zis",
	207:   "at-7",
	208:   "at-8",
	209:   "qmtp",
	210:   "z39-50",
	211:   "914c-g",
	212:   "anet",
	213:   "ipx",
	214:   "vmpwscs",
	215:   "softpc",
	216:   "CAIlic",
	217:   "dbase",
	218:   "mpp",
	219:   "uarps",
	220:   "imap3",
	221:   "fln-spx",
	222:   "rsh-spx",
	223:   "cdc",
	224:   "masqdialer",
	242:   "direct",
	243:   "sur-meas",
	244:   "inbusiness",
	245:   "link",
	246:   "dsp3270",
	247:   "subntbcst-tftp",
	248:   "bhfhs",
	256:   "rap",
	257:   "set",
	259:   "esro-gen",
	260:   "openport",
	261:   "nsiiops",
	262:   "arcisdms",
	263:   "hdap",
	264:   "bgmp",
	265:   "x-bone-ctl",
	266:   "sst",
	267:   "td-service",
	268:   "td-replica",
	269:   "manet",
	270:   "gist",
	280:   "http-mgmt",
	281:   "personal-link",
	282:   "cableport-ax",
	283:   "rescap",
	284:   "corerjd",
	286:   "fxp",
	287:   "k-block",
	308:   "novastorbakcup",
	309:   "entrusttime",
	310:   "bhmds",
	311:   "asip-webadmin",
	312:   "vslmp",
	313:   "magenta-logic",
	314:   "opalis-robot",
	315:   "dpsi",
	316:   "decauth",
	317:   "zannet",
	318:   "pkix-timestamp",
	319:   "ptp-event",
	320:   "ptp-general",
	321:   "pip",
	322:   "rtsps",
	333:   "texar",
	344:   "pdap",
	345:   "pawserv",
	346:   "zserv",
	347:   "fatserv",
	348:   "csi-sgwp",
	349:   "mftp",
	350:   "matip-type-a",
	351:   "matip-type-b",
	352:   "dtag-ste-sb",
	353:   "ndsauth",
	354:   "bh611",
	355:   "datex-asn",
	356:   "cloanto-net-1",
	357:   "bhevent",
	358:   "shrinkwrap",
	359:   "nsrmp",
	360:   "scoi2odialog",
	361:   "semantix",
	362:   "srssend",
	363:   "rsvp-tunnel",
	364:   "aurora-cmgr",
	365:   "dtk",
	366:   "odmr",
	367:   "mortgageware",
	368:   "qbikgdp",
	369:   "rpc2portmap",
	370:   "codaauth2",
	371:   "clearcase",
	372:   "ulistproc",
	373:   "legent-1",
	374:   "legent-2",
	375:   "hassle",
	376:   "nip",
	377:   "tnETOS",
	378:   "dsETOS",
	379:   "is99c",
	380:   "is99s",
	381:   "hp-collector",
	382:   "hp-managed-node",
	383:   "hp-alarm-mgr",
	384:   "arns",
	385:   "ibm-app",
	386:   "asa",
	387:   "aurp",
	388:   "unidata-ldm",
	389:   "ldap",
	390:   "uis",
	391:   "synotics-relay",
	392:   "synotics-broker",
	393:   "meta5",
	394:   "embl-ndt",
	395:   "netcp",
	396:   "netware-ip",
	397:   "mptn",
	398:   "kryptolan",
	399:   "iso-tsap-c2",
	400:   "osb-sd",
	401:   "ups",
	402:   "genie",
	403:   "decap",
	404:   "nced",
	405:   "ncld",
	406:   "imsp",
	407:   "timbuktu",
	408:   "prm-sm",
	409:   "prm-nm",
	410:   "decladebug",
	411:   "rmt",
	412:   "synoptics-trap",
	413:   "smsp",
	414:   "infoseek",
	415:   "bnet",
	416:   "silverplatter",
	417:   "onmux",
	418:   "hyper-g",
	419:   "ariel1",
	420:   "smpte",
	421:   "ariel2",
	422:   "ariel3",
	423:   "opc-job-start",
	424:   "opc-job-track",
	425:   "icad-el",
	426:   "smartsdp",
	427:   "svrloc",
	428:   "ocs-cmu",
	429:   "ocs-amu",
	430:   "utmpsd",
	431:   "utmpcd",
	432:   "iasd",
	433:   "nnsp",
	434:   "mobileip-agent",
	435:   "mobilip-mn",
	436:   "dna-cml",
	437:   "comscm",
	438:   "dsfgw",
	439:   "dasp",
	440:   "sgcp",
	441:   "decvms-sysmgt",
	442:   "cvc-hostd",
	443:   "https",
	444:   "snpp",
	445:   "microsoft-ds",
	446:   "ddm-rdb",
	447:   "ddm-dfm",
	448:   "ddm-ssl",
	449:   "as-servermap",
	450:   "tserver",
	451:   "sfs-smp-net",
	452:   "sfs-config",
	453:   "creativeserver",
	454:   "contentserver",
	455:   "creativepartnr",
	456:   "macon-udp",
	457:   "scohelp",
	458:   "appleqtc",
	459:   "ampr-rcmd",
	460:   "skronk",
	461:   "datasurfsrv",
	462:   "datasurfsrvsec",
	463:   "alpes",
	464:   "kpasswd",
	465:   "igmpv3lite",
	466:   "digital-vrc",
	467:   "mylex-mapd",
	468:   "photuris",
	469:   "rcp",
	470:   "scx-proxy",
	471:   "mondex",
	472:   "ljk-login",
	473:   "hybrid-pop",
	474:   "tn-tl-w2",
	475:   "tcpnethaspsrv",
	476:   "tn-tl-fd1",
	477:   "ss7ns",
	478:   "spsc",
	479:   "iafserver",
	480:   "iafdbase",
	481:   "ph",
	482:   "bgs-nsi",
	483:   "ulpnet",
	484:   "integra-sme",
	485:   "powerburst",
	486:   "avian",
	487:   "saft",
	488:   "gss-http",
	489:   "nest-protocol",
	490:   "micom-pfs",
	491:   "go-login",
	492:   "ticf-1",
	493:   "ticf-2",
	494:   "pov-ray",
	495:   "intecourier",
	496:   "pim-rp-disc",
	497:   "retrospect",
	498:   "siam",
	499:   "iso-ill",
	500:   "isakmp",
	501:   "stmf",
	502:   "mbap",
	503:   "intrinsa",
	504:   "citadel",
	505:   "mailbox-lm",
	506:   "ohimsrv",
	507:   "crs",
	508:   "xvttp",
	509:   "snare",
	510:   "fcp",
	511:   "passgo",
	512:   "comsat",
	513:   "who",
	514:   "syslog",
	515:   "printer",
	516:   "videotex",
	517:   "talk",
	518:   "ntalk",
	519:   "utime",
	520:   "router",
	521:   "ripng",
	522:   "ulp",
	523:   "ibm-db2",
	524:   "ncp",
	525:   "timed",
	526:   "tempo",
	527:   "stx",
	528:   "custix",
	529:   "irc-serv",
	530:   "courier",
	531:   "conference",
	532:   "netnews",
	533:   "netwall",
	534:   "windream",
	535:   "iiop",
	536:   "opalis-rdv",
	537:   "nmsp",
	538:   "gdomap",
	539:   "apertus-ldp",
	540:   "uucp",
	541:   "uucp-rlogin",
	542:   "commerce",
	543:   "klogin",
	544:   "kshell",
	545:   "appleqtcsrvr",
	546:   "dhcpv6-client",
	547:   "dhcpv6-server",
	548:   "afpovertcp",
	549:   "idfp",
	550:   "new-rwho",
	551:   "cybercash",
	552:   "devshr-nts",
	553:   "pirp",
	554:   "rtsp",
	555:   "dsf",
	556:   "remotefs",
	557:   "openvms-sysipc",
	558:   "sdnskmp",
	559:   "teedtap",
	560:   "rmonitor",
	561:   "monitor",
	562:   "chshell",
	563:   "nntps",
	564:   "9pfs",
	565:   "whoami",
	566:   "streettalk",
	567:   "banyan-rpc",
	568:   "ms-shuttle",
	569:   "ms-rome",
	570:   "meter",
	571:   "meter",
	572:   "sonar",
	573:   "banyan-vip",
	574:   "ftp-agent",
	575:   "vemmi",
	576:   "ipcd",
	577:   "vnas",
	578:   "ipdd",
	579:   "decbsrv",
	580:   "sntp-heartbeat",
	581:   "bdp",
	582:   "scc-security",
	583:   "philips-vc",
	584:   "keyserver",
	586:   "password-chg",
	587:   "submission",
	588:   "cal",
	589:   "eyelink",
	590:   "tns-cml",
	591:   "http-alt",
	592:   "eudora-set",
	593:   "http-rpc-epmap",
	594:   "tpip",
	595:   "cab-protocol",
	596:   "smsd",
	597:   "ptcnameservice",
	598:   "sco-websrvrmg3",
	599:   "acp",
	600:   "ipcserver",
	601:   "syslog-conn",
	602:   "xmlrpc-beep",
	603:   "idxp",
	604:   "tunnel",
	605:   "soap-beep",
	606:   "urm",
	607:   "nqs",
	608:   "sift-uft",
	609:   "npmp-trap",
	610:   "npmp-local",
	611:   "npmp-gui",
	612:   "hmmp-ind",
	613:   "hmmp-op",
	614:   "sshell",
	615:   "sco-inetmgr",
	616:   "sco-sysmgr",
	617:   "sco-dtmgr",
	618:   "dei-icda",
	619:   "compaq-evm",
	620:   "sco-websrvrmgr",
	621:   "escp-ip",
	622:   "collaborator",
	623:   "asf-rmcp",
	624:   "cryptoadmin",
	625:   "dec-dlm",
	626:   "asia",
	627:   "passgo-tivoli",
	628:   "qmqp",
	629:   "3com-amp3",
	630:   "rda",
	631:   "ipp",
	632:   "bmpp",
	633:   "servstat",
	634:   "ginad",
	635:   "rlzdbase",
	636:   "ldaps",
	637:   "lanserver",
	638:   "mcns-sec",
	639:   "msdp",
	640:   "entrust-sps",
	641:   "repcmd",
	642:   "esro-emsdp",
	643:   "sanity",
	644:   "dwr",
	645:   "pssc",
	646:   "ldp",
	647:   "dhcp-failover",
	648:   "rrp",
	649:   "cadview-3d",
	650:   "obex",
	651:   "ieee-mms",
	652:   "hello-port",
	653:   "repscmd",
	654:   "aodv",
	655:   "tinc",
	656:   "spmp",
	657:   "rmc",
	658:   "tenfold",
	660:   "mac-srvr-admin",
	661:   "hap",
	662:   "pftp",
	663:   "purenoise",
	664:   "asf-secure-rmcp",
	665:   "sun-dr",
	666:   "mdqs",
	667:   "disclose",
	668:   "mecomm",
	669:   "meregister",
	670:   "vacdsm-sws",
	671:   "vacdsm-app",
	672:   "vpps-qua",
	673:   "cimplex",
	674:   "acap",
	675:   "dctp",
	676:   "vpps-via",
	677:   "vpp",
	678:   "ggf-ncp",
	679:   "mrm",
	680:   "entrust-aaas",
	681:   "entrust-aams",
	682:   "xfr",
	683:   "corba-iiop",
	684:   "corba-iiop-ssl",
	685:   "mdc-portmapper",
	686:   "hcp-wismar",
	687:   "asipregistry",
	688:   "realm-rusd",
	689:   "nmap",
	690:   "vatp",
	691:   "msexch-routing",
	692:   "hyperwave-isp",
	693:   "connendp",
	694:   "ha-cluster",
	695:   "ieee-mms-ssl",
	696:   "rushd",
	697:   "uuidgen",
	698:   "olsr",
	699:   "accessnetwork",
	700:   "epp",
	701:   "lmp",
	702:   "iris-beep",
	704:   "elcsd",
	705:   "agentx",
	706:   "silc",
	707:   "borland-dsj",
	709:   "entrust-kmsh",
	710:   "entrust-ash",
	711:   "cisco-tdp",
	712:   "tbrpf",
	713:   "iris-xpc",
	714:   "iris-xpcs",
	715:   "iris-lwz",
	716:   "pana",
	729:   "netviewdm1",
	730:   "netviewdm2",
	731:   "netviewdm3",
	741:   "netgw",
	742:   "netrcs",
	744:   "flexlm",
	747:   "fujitsu-dev",
	748:   "ris-cm",
	749:   "kerberos-adm",
	750:   "loadav",
	751:   "pump",
	752:   "qrh",
	753:   "rrh",
	754:   "tell",
	758:   "nlogin",
	759:   "con",
	760:   "ns",
	761:   "rxe",
	762:   "quotad",
	763:   "cycleserv",
	764:   "omserv",
	765:   "webster",
	767:   "phonebook",
	769:   "vid",
	770:   "cadlock",
	771:   "rtip",
	772:   "cycleserv2",
	773:   "notify",
	774:   "acmaint-dbd",
	775:   "acmaint-transd",
	776:   "wpages",
	777:   "multiling-http",
	780:   "wpgs",
	800:   "mdbs-daemon",
	801:   "device",
	802:   "mbap-s",
	810:   "fcp-udp",
	828:   "itm-mcell-s",
	829:   "pkix-3-ca-ra",
	830:   "netconf-ssh",
	831:   "netconf-beep",
	832:   "netconfsoaphttp",
	833:   "netconfsoapbeep",
	847:   "dhcp-failover2",
	848:   "gdoi",
	853:   "domain-s",
	854:   "dlep",
	860:   "iscsi",
	861:   "owamp-control",
	862:   "twamp-control",
	873:   "rsync",
	886:   "iclcnet-locate",
	887:   "iclcnet-svinfo",
	888:   "accessbuilder",
	900:   "omginitialrefs",
	901:   "smpnameres",
	902:   "ideafarm-door",
	903:   "ideafarm-panic",
	910:   "kink",
	911:   "xact-backup",
	912:   "apex-mesh",
	913:   "apex-edge",
	989:   "ftps-data",
	990:   "ftps",
	991:   "nas",
	992:   "telnets",
	993:   "imaps",
	995:   "pop3s",
	996:   "vsinet",
	997:   "maitrd",
	998:   "puparp",
	999:   "applix",
	1000:  "cadlock2",
	1010:  "surf",
	1021:  "exp1",
	1022:  "exp2",
	1025:  "blackjack",
	1026:  "cap",
	1027:  "6a44",
	1029:  "solid-mux",
	1033:  "netinfo-local",
	1034:  "activesync",
	1035:  "mxxrlogin",
	1036:  "nsstp",
	1037:  "ams",
	1038:  "mtqp",
	1039:  "sbl",
	1040:  "netarx",
	1041:  "danf-ak2",
	1042:  "afrog",
	1043:  "boinc-client",
	1044:  "dcutility",
	1045:  "fpitp",
	1046:  "wfremotertm",
	1047:  "neod1",
	1048:  "neod2",
	1049:  "td-postman",
	1050:  "cma",
	1051:  "optima-vnet",
	1052:  "ddt",
	1053:  "remote-as",
	1054:  "brvread",
	1055:  "ansyslmd",
	1056:  "vfo",
	1057:  "startron",
	1058:  "nim",
	1059:  "nimreg",
	1060:  "polestar",
	1061:  "kiosk",
	1062:  "veracity",
	1063:  "kyoceranetdev",
	1064:  "jstel",
	1065:  "syscomlan",
	1066:  "fpo-fns",
	1067:  "instl-boots",
	1068:  "instl-bootc",
	1069:  "cognex-insight",
	1070:  "gmrupdateserv",
	1071:  "bsquare-voip",
	1072:  "cardax",
	1073:  "bridgecontrol",
	1074:  "warmspotMgmt",
	1075:  "rdrmshc",
	1076:  "dab-sti-c",
	1077:  "imgames",
	1078:  "avocent-proxy",
	1079:  "asprovatalk",
	1080:  "socks",
	1081:  "pvuniwien",
	1082:  "amt-esd-prot",
	1083:  "ansoft-lm-1",
	1084:  "ansoft-lm-2",
	1085:  "webobjects",
	1086:  "cplscrambler-lg",
	1087:  "cplscrambler-in",
	1088:  "cplscrambler-al",
	1089:  "ff-annunc",
	1090:  "ff-fms",
	1091:  "ff-sm",
	1092:  "obrpd",
	1093:  "proofd",
	1094:  "rootd",
	1095:  "nicelink",
	1096:  "cnrprotocol",
	1097:  "sunclustermgr",
	1098:  "rmiactivation",
	1099:  "rmiregistry",
	1100:  "mctp",
	1101:  "pt2-discover",
	1102:  "adobeserver-1",
	1103:  "adobeserver-2",
	1104:  "xrl",
	1105:  "ftranhc",
	1106:  "isoipsigport-1",
	1107:  "isoipsigport-2",
	1108:  "ratio-adp",
	1110:  "nfsd-keepalive",
	1111:  "lmsocialserver",
	1112:  "icp",
	1113:  "ltp-deepspace",
	1114:  "mini-sql",
	1115:  "ardus-trns",
	1116:  "ardus-cntl",
	1117:  "ardus-mtrns",
	1118:  "sacred",
	1119:  "bnetgame",
	1120:  "bnetfile",
	1121:  "rmpp",
	1122:  "availant-mgr",
	1123:  "murray",
	1124:  "hpvmmcontrol",
	1125:  "hpvmmagent",
	1126:  "hpvmmdata",
	1127:  "kwdb-commn",
	1128:  "saphostctrl",
	1129:  "saphostctrls",
	1130:  "casp",
	1131:  "caspssl",
	1132:  "kvm-via-ip",
	1133:  "dfn",
	1134:  "aplx",
	1135:  "omnivision",
	1136:  "hhb-gateway",
	1137:  "trim",
	1138:  "encrypted-admin",
	1139:  "evm",
	1140:  "autonoc",
	1141:  "mxomss",
	1142:  "edtools",
	1143:  "imyx",
	1144:  "fuscript",
	1145:  "x9-icue",
	1146:  "audit-transfer",
	1147:  "capioverlan",
	1148:  "elfiq-repl",
	1149:  "bvtsonar",
	1150:  "blaze",
	1151:  "unizensus",
	1152:  "winpoplanmess",
	1153:  "c1222-acse",
	1154:  "resacommunity",
	1155:  "nfa",
	1156:  "iascontrol-oms",
	1157:  "iascontrol",
	1158:  "dbcontrol-oms",
	1159:  "oracle-oms",
	1160:  "olsv",
	1161:  "health-polling",
	1162:  "health-trap",
	1163:  "sddp",
	1164:  "qsm-proxy",
	1165:  "qsm-gui",
	1166:  "qsm-remote",
	1167:  "cisco-ipsla",
	1168:  "vchat",
	1169:  "tripwire",
	1170:  "atc-lm",
	1171:  "atc-appserver",
	1172:  "dnap",
	1173:  "d-cinema-rrp",
	1174:  "fnet-remote-ui",
	1175:  "dossier",
	1176:  "indigo-server",
	1177:  "dkmessenger",
	1178:  "sgi-storman",
	1179:  "b2n",
	1180:  "mc-client",
	1181:  "3comnetman",
	1182:  "accelenet-data",
	1183:  "llsurfup-http",
	1184:  "llsurfup-https",
	1185:  "catchpole",
	1186:  "mysql-cluster",
	1187:  "alias",
	1188:  "hp-webadmin",
	1189:  "unet",
	1190:  "commlinx-avl",
	1191:  "gpfs",
	1192:  "caids-sensor",
	1193:  "fiveacross",
	1194:  "openvpn",
	1195:  "rsf-1",
	1196:  "netmagic",
	1197:  "carrius-rshell",
	1198:  "cajo-discovery",
	1199:  "dmidi",
	1200:  "scol",
	1201:  "nucleus-sand",
	1202:  "caiccipc",
	1203:  "ssslic-mgr",
	1204:  "ssslog-mgr",
	1205:  "accord-mgc",
	1206:  "anthony-data",
	1207:  "metasage",
	1208:  "seagull-ais",
	1209:  "ipcd3",
	1210:  "eoss",
	1211:  "groove-dpp",
	1212:  "lupa",
	1213:  "mpc-lifenet",
	1214:  "kazaa",
	1215:  "scanstat-1",
	1216:  "etebac5",
	1217:  "hpss-ndapi",
	1218:  "aeroflight-ads",
	1219:  "aeroflight-ret",
	1220:  "qt-serveradmin",
	1221:  "sweetware-apps",
	1222:  "nerv",
	1223:  "tgp",
	1224:  "vpnz",
	1225:  "slinkysearch",
	1226:  "stgxfws",
	1227:  "dns2go",
	1228:  "florence",
	1229:  "zented",
	1230:  "periscope",
	1231:  "menandmice-lpm",
	1232:  "first-defense",
	1233:  "univ-appserver",
	1234:  "search-agent",
	1235:  "mosaicsyssvc1",
	1236:  "bvcontrol",
	1237:  "tsdos390",
	1238:  "hacl-qs",
	1239:  "nmsd",
	1240:  "instantia",
	1241:  "nessus",
	1242:  "nmasoverip",
	1243:  "serialgateway",
	1244:  "isbconference1",
	1245:  "isbconference2",
	1246:  "payrouter",
	1247:  "visionpyramid",
	1248:  "hermes",
	1249:  "mesavistaco",
	1250:  "swldy-sias",
	1251:  "servergraph",
	1252:  "bspne-pcc",
	1253:  "q55-pcc",
	1254:  "de-noc",
	1255:  "de-cache-query",
	1256:  "de-server",
	1257:  "shockwave2",
	1258:  "opennl",
	1259:  "opennl-voice",
	1260:  "ibm-ssd",
	1261:  "mpshrsv",
	1262:  "qnts-orb",
	1263:  "dka",
	1264:  "prat",
	1265:  "dssiapi",
	1266:  "dellpwrappks",
	1267:  "epc",
	1268:  "propel-msgsys",
	1269:  "watilapp",
	1270:  "opsmgr",
	1271:  "excw",
	1272:  "cspmlockmgr",
	1273:  "emc-gateway",
	1274:  "t1distproc",
	1275:  "ivcollector",
	1277:  "miva-mqs",
	1278:  "dellwebadmin-1",
	1279:  "dellwebadmin-2",
	1280:  "pictrography",
	1281:  "healthd",
	1282:  "emperion",
	1283:  "productinfo",
	1284:  "iee-qfx",
	1285:  "neoiface",
	1286:  "netuitive",
	1287:  "routematch",
	1288:  "navbuddy",
	1289:  "jwalkserver",
	1290:  "winjaserver",
	1291:  "seagulllms",
	1292:  "dsdn",
	1293:  "pkt-krb-ipsec",
	1294:  "cmmdriver",
	1295:  "ehtp",
	1296:  "dproxy",
	1297:  "sdproxy",
	1298:  "lpcp",
	1299:  "hp-sci",
	1300:  "h323hostcallsc",
	1301:  "ci3-software-1",
	1302:  "ci3-software-2",
	1303:  "sftsrv",
	1304:  "boomerang",
	1305:  "pe-mike",
	1306:  "re-conn-proto",
	1307:  "pacmand",
	1308:  "odsi",
	1309:  "jtag-server",
	1310:  "husky",
	1311:  "rxmon",
	1312:  "sti-envision",
	1313:  "bmc-patroldb",
	1314:  "pdps",
	1315:  "els",
	1316:  "exbit-escp",
	1317:  "vrts-ipcserver",
	1318:  "krb5gatekeeper",
	1319:  "amx-icsp",
	1320:  "amx-axbnet",
	1321:  "pip",
	1322:  "novation",
	1323:  "brcd",
	1324:  "delta-mcp",
	1325:  "dx-instrument",
	1326:  "wimsic",
	1327:  "ultrex",
	1328:  "ewall",
	1329:  "netdb-export",
	1330:  "streetperfect",
	1331:  "intersan",
	1332:  "pcia-rxp-b",
	1333:  "passwrd-policy",
	1334:  "writesrv",
	1335:  "digital-notary",
	1336:  "ischat",
	1337:  "menandmice-dns",
	1338:  "wmc-log-svc",
	1339:  "kjtsiteserver",
	1340:  "naap",
	1341:  "qubes",
	1342:  "esbroker",
	1343:  "re101",
	1344:  "icap",
	1345:  "vpjp",
	1346:  "alta-ana-lm",
	1347:  "bbn-mmc",
	1348:  "bbn-mmx",
	1349:  "sbook",
	1350:  "editbench",
	1351:  "equationbuilder",
	1352:  "lotusnote",
	1353:  "relief",
	1354:  "XSIP-network",
	1355:  "intuitive-edge",
	1356:  "cuillamartin",
	1357:  "pegboard",
	1358:  "connlcli",
	1359:  "ftsrv",
	1360:  "mimer",
	1361:  "linx",
	1362:  "timeflies",
	1363:  "ndm-requester",
	1364:  "ndm-server",
	1365:  "adapt-sna",
	1366:  "netware-csp",
	1367:  "dcs",
	1368:  "screencast",
	1369:  "gv-us",
	1370:  "us-gv",
	1371:  "fc-cli",
	1372:  "fc-ser",
	1373:  "chromagrafx",
	1374:  "molly",
	1375:  "bytex",
	1376:  "ibm-pps",
	1377:  "cichlid",
	1378:  "elan",
	1379:  "dbreporter",
	1380:  "telesis-licman",
	1381:  "apple-licman",
	1382:  "udt-os",
	1383:  "gwha",
	1384:  "os-licman",
	1385:  "atex-elmd",
	1386:  "checksum",
	1387:  "cadsi-lm",
	1388:  "objective-dbc",
	1389:  "iclpv-dm",
	1390:  "iclpv-sc",
	1391:  "iclpv-sas",
	1392:  "iclpv-pm",
	1393:  "iclpv-nls",
	1394:  "iclpv-nlc",
	1395:  "iclpv-wsm",
	1396:  "dvl-activemail",
	1397:  "audio-activmail",
	1398:  "video-activmail",
	1399:  "cadkey-licman",
	1400:  "cadkey-tablet",
	1401:  "goldleaf-licman",
	1402:  "prm-sm-np",
	1403:  "prm-nm-np",
	1404:  "igi-lm",
	1405:  "ibm-res",
	1406:  "netlabs-lm",
	1408:  "sophia-lm",
	1409:  "here-lm",
	1410:  "hiq",
	1411:  "af",
	1412:  "innosys",
	1413:  "innosys-acl",
	1414:  "ibm-mqseries",
	1415:  "dbstar",
	1416:  "novell-lu6-2",
	1417:  "timbuktu-srv1",
	1418:  "timbuktu-srv2",
	1419:  "timbuktu-srv3",
	1420:  "timbuktu-srv4",
	1421:  "gandalf-lm",
	1422:  "autodesk-lm",
	1423:  "essbase",
	1424:  "hybrid",
	1425:  "zion-lm",
	1426:  "sais",
	1427:  "mloadd",
	1428:  "informatik-lm",
	1429:  "nms",
	1430:  "tpdu",
	1431:  "rgtp",
	1432:  "blueberry-lm",
	1433:  "ms-sql-s",
	1434:  "ms-sql-m",
	1435:  "ibm-cics",
	1436:  "saism",
	1437:  "tabula",
	1438:  "eicon-server",
	1439:  "eicon-x25",
	1440:  "eicon-slp",
	1441:  "cadis-1",
	1442:  "cadis-2",
	1443:  "ies-lm",
	1444:  "marcam-lm",
	1445:  "proxima-lm",
	1446:  "ora-lm",
	1447:  "apri-lm",
	1448:  "oc-lm",
	1449:  "peport",
	1450:  "dwf",
	1451:  "infoman",
	1452:  "gtegsc-lm",
	1453:  "genie-lm",
	1454:  "interhdl-elmd",
	1455:  "esl-lm",
	1456:  "dca",
	1457:  "valisys-lm",
	1458:  "nrcabq-lm",
	1459:  "proshare1",
	1460:  "proshare2",
	1461:  "ibm-wrless-lan",
	1462:  "world-lm",
	1463:  "nucleus",
	1464:  "msl-lmd",
	1465:  "pipes",
	1466:  "oceansoft-lm",
	1467:  "csdmbase",
	1468:  "csdm",
	1469:  "aal-lm",
	1470:  "uaiact",
	1471:  "csdmbase",
	1472:  "csdm",
	1473:  "openmath",
	1474:  "telefinder",
	1475:  "taligent-lm",
	1476:  "clvm-cfg",
	1477:  "ms-sna-server",
	1478:  "ms-sna-base",
	1479:  "dberegister",
	1480:  "pacerforum",
	1481:  "airs",
	1482:  "miteksys-lm",
	1483:  "afs",
	1484:  "confluent",
	1485:  "lansource",
	1486:  "nms-topo-serv",
	1487:  "localinfosrvr",
	1488:  "docstor",
	1489:  "dmdocbroker",
	1490:  "insitu-conf",
	1492:  "stone-design-1",
	1493:  "netmap-lm",
	1494:  "ica",
	1495:  "cvc",
	1496:  "liberty-lm",
	1497:  "rfx-lm",
	1498:  "sybase-sqlany",
	1499:  "fhc",
	1500:  "vlsi-lm",
	1501:  "saiscm",
	1502:  "shivadiscovery",
	1503:  "imtc-mcs",
	1504:  "evb-elm",
	1505:  "funkproxy",
	1506:  "utcd",
	1507:  "symplex",
	1508:  "diagmond",
	1509:  "robcad-lm",
	1510:  "mvx-lm",
	1511:  "3l-l1",
	1512:  "wins",
	1513:  "fujitsu-dtc",
	1514:  "fujitsu-dtcns",
	1515:  "ifor-protocol",
	1516:  "vpad",
	1517:  "vpac",
	1518:  "vpvd",
	1519:  "vpvc",
	1520:  "atm-zip-office",
	1521:  "ncube-lm",
	1522:  "ricardo-lm",
	1523:  "cichild-lm",
	1524:  "ingreslock",
	1525:  "orasrv",
	1526:  "pdap-np",
	1527:  "tlisrv",
	1528:  "ngr-t",
	1529:  "coauthor",
	1530:  "rap-service",
	1531:  "rap-listen",
	1532:  "miroconnect",
	1533:  "virtual-places",
	1534:  "micromuse-lm",
	1535:  "ampr-info",
	1536:  "ampr-inter",
	1537:  "sdsc-lm",
	1538:  "3ds-lm",
	1539:  "intellistor-lm",
	1540:  "rds",
	1541:  "rds2",
	1542:  "gridgen-elmd",
	1543:  "simba-cs",
	1544:  "aspeclmd",
	1545:  "vistium-share",
	1546:  "abbaccuray",
	1547:  "laplink",
	1548:  "axon-lm",
	1549:  "shivasound",
	1550:  "3m-image-lm",
	1551:  "hecmtl-db",
	1552:  "pciarray",
	1553:  "sna-cs",
	1554:  "caci-lm",
	1555:  "livelan",
	1556:  "veritas-pbx",
	1557:  "arbortext-lm",
	1558:  "xingmpeg",
	1559:  "web2host",
	1560:  "asci-val",
	1561:  "facilityview",
	1562:  "pconnectmgr",
	1563:  "cadabra-lm",
	1564:  "pay-per-view",
	1565:  "winddlb",
	1566:  "corelvideo",
	1567:  "jlicelmd",
	1568:  "tsspmap",
	1569:  "ets",
	1570:  "orbixd",
	1571:  "rdb-dbs-disp",
	1572:  "chip-lm",
	1573:  "itscomm-ns",
	1574:  "mvel-lm",
	1575:  "oraclenames",
	1576:  "moldflow-lm",
	1577:  "hypercube-lm",
	1578:  "jacobus-lm",
	1579:  "ioc-sea-lm",
	1580:  "tn-tl-r2",
	1581:  "mil-2045-47001",
	1582:  "msims",
	1583:  "simbaexpress",
	1584:  "tn-tl-fd2",
	1585:  "intv",
	1586:  "ibm-abtact",
	1587:  "pra-elmd",
	1588:  "triquest-lm",
	1589:  "vqp",
	1590:  "gemini-lm",
	1591:  "ncpm-pm",
	1592:  "commonspace",
	1593:  "mainsoft-lm",
	1594:  "sixtrak",
	1595:  "radio",
	1596:  "radio-bc",
	1597:  "orbplus-iiop",
	1598:  "picknfs",
	1599:  "simbaservices",
	1600:  "issd",
	1601:  "aas",
	1602:  "inspect",
	1603:  "picodbc",
	1604:  "icabrowser",
	1605:  "slp",
	1606:  "slm-api",
	1607:  "stt",
	1608:  "smart-lm",
	1609:  "isysg-lm",
	1610:  "taurus-wh",
	1611:  "ill",
	1612:  "netbill-trans",
	1613:  "netbill-keyrep",
	1614:  "netbill-cred",
	1615:  "netbill-auth",
	1616:  "netbill-prod",
	1617:  "nimrod-agent",
	1618:  "skytelnet",
	1619:  "xs-openstorage",
	1620:  "faxportwinport",
	1621:  "softdataphone",
	1622:  "ontime",
	1623:  "jaleosnd",
	1624:  "udp-sr-port",
	1625:  "svs-omagent",
	1626:  "shockwave",
	1627:  "t128-gateway",
	1628:  "lontalk-norm",
	1629:  "lontalk-urgnt",
	1630:  "oraclenet8cman",
	1631:  "visitview",
	1632:  "pammratc",
	1633:  "pammrpc",
	1634:  "loaprobe",
	1635:  "edb-server1",
	1636:  "isdc",
	1637:  "islc",
	1638:  "ismc",
	1639:  "cert-initiator",
	1640:  "cert-responder",
	1641:  "invision",
	1642:  "isis-am",
	1643:  "isis-ambc",
	1644:  "saiseh",
	1645:  "sightline",
	1646:  "sa-msg-port",
	1647:  "rsap",
	1648:  "concurrent-lm",
	1649:  "kermit",
	1650:  "nkd",
	1651:  "shiva-confsrvr",
	1652:  "xnmp",
	1653:  "alphatech-lm",
	1654:  "stargatealerts",
	1655:  "dec-mbadmin",
	1656:  "dec-mbadmin-h",
	1657:  "fujitsu-mmpdc",
	1658:  "sixnetudr",
	1659:  "sg-lm",
	1660:  "skip-mc-gikreq",
	1661:  "netview-aix-1",
	1662:  "netview-aix-2",
	1663:  "netview-aix-3",
	1664:  "netview-aix-4",
	1665:  "netview-aix-5",
	1666:  "netview-aix-6",
	1667:  "netview-aix-7",
	1668:  "netview-aix-8",
	1669:  "netview-aix-9",
	1670:  "netview-aix-10",
	1671:  "netview-aix-11",
	1672:  "netview-aix-12",
	1673:  "proshare-mc-1",
	1674:  "proshare-mc-2",
	1675:  "pdp",
	1676:  "netcomm2",
	1677:  "groupwise",
	1678:  "prolink",
	1679:  "darcorp-lm",
	1680:  "microcom-sbp",
	1681:  "sd-elmd",
	1682:  "lanyon-lantern",
	1683:  "ncpm-hip",
	1684:  "snaresecure",
	1685:  "n2nremote",
	1686:  "cvmon",
	1687:  "nsjtp-ctrl",
	1688:  "nsjtp-data",
	1689:  "firefox",
	1690:  "ng-umds",
	1691:  "empire-empuma",
	1692:  "sstsys-lm",
	1693:  "rrirtr",
	1694:  "rrimwm",
	1695:  "rrilwm",
	1696:  "rrifmm",
	1697:  "rrisat",
	1698:  "rsvp-encap-1",
	1699:  "rsvp-encap-2",
	1700:  "mps-raft",
	1701:  "l2f",
	1702:  "deskshare",
	1703:  "hb-engine",
	1704:  "bcs-broker",
	1705:  "slingshot",
	1706:  "jetform",
	1707:  "vdmplay",
	1708:  "gat-lmd",
	1709:  "centra",
	1710:  "impera",
	1711:  "pptconference",
	1712:  "registrar",
	1713:  "conferencetalk",
	1714:  "sesi-lm",
	1715:  "houdini-lm",
	1716:  "xmsg",
	1717:  "fj-hdnet",
	1718:  "h323gatedisc",
	1719:  "h323gatestat",
	1720:  "h323hostcall",
	1721:  "caicci",
	1722:  "hks-lm",
	1723:  "pptp",
	1724:  "csbphonemaster",
	1725:  "iden-ralp",
	1726:  "iberiagames",
	1727:  "winddx",
	1728:  "telindus",
	1729:  "citynl",
	1730:  "roketz",
	1731:  "msiccp",
	1732:  "proxim",
	1733:  "siipat",
	1734:  "cambertx-lm",
	1735:  "privatechat",
	1736:  "street-stream",
	1737:  "ultimad",
	1738:  "gamegen1",
	1739:  "webaccess",
	1740:  "encore",
	1741:  "cisco-net-mgmt",
	1742:  "3Com-nsd",
	1743:  "cinegrfx-lm",
	1744:  "ncpm-ft",
	1745:  "remote-winsock",
	1746:  "ftrapid-1",
	1747:  "ftrapid-2",
	1748:  "oracle-em1",
	1749:  "aspen-services",
	1750:  "sslp",
	1751:  "swiftnet",
	1752:  "lofr-lm",
	1754:  "oracle-em2",
	1755:  "ms-streaming",
	1756:  "capfast-lmd",
	1757:  "cnhrp",
	1758:  "tftp-mcast",
	1759:  "spss-lm",
	1760:  "www-ldap-gw",
	1761:  "cft-0",
	1762:  "cft-1",
	1763:  "cft-2",
	1764:  "cft-3",
	1765:  "cft-4",
	1766:  "cft-5",
	1767:  "cft-6",
	1768:  "cft-7",
	1769:  "bmc-net-adm",
	1770:  "bmc-net-svc",
	1771:  "vaultbase",
	1772:  "essweb-gw",
	1773:  "kmscontrol",
	1774:  "global-dtserv",
	1776:  "femis",
	1777:  "powerguardian",
	1778:  "prodigy-intrnet",
	1779:  "pharmasoft",
	1780:  "dpkeyserv",
	1781:  "answersoft-lm",
	1782:  "hp-hcip",
	1784:  "finle-lm",
	1785:  "windlm",
	1786:  "funk-logger",
	1787:  "funk-license",
	1788:  "psmond",
	1789:  "hello",
	1790:  "nmsp",
	1791:  "ea1",
	1792:  "ibm-dt-2",
	1793:  "rsc-robot",
	1794:  "cera-bcm",
	1795:  "dpi-proxy",
	1796:  "vocaltec-admin",
	1797:  "uma",
	1798:  "etp",
	1799:  "netrisk",
	1800:  "ansys-lm",
	1801:  "msmq",
	1802:  "concomp1",
	1803:  "hp-hcip-gwy",
	1804:  "enl",
	1805:  "enl-name",
	1806:  "musiconline",
	1807:  "fhsp",
	1808:  "oracle-vp2",
	1809:  "oracle-vp1",
	1810:  "jerand-lm",
	1811:  "scientia-sdb",
	1812:  "radius",
	1813:  "radius-acct",
	1814:  "tdp-suite",
	1815:  "mmpft",
	1816:  "harp",
	1817:  "rkb-oscs",
	1818:  "etftp",
	1819:  "plato-lm",
	1820:  "mcagent",
	1821:  "donnyworld",
	1822:  "es-elmd",
	1823:  "unisys-lm",
	1824:  "metrics-pas",
	1825:  "direcpc-video",
	1826:  "ardt",
	1827:  "asi",
	1828:  "itm-mcell-u",
	1829:  "optika-emedia",
	1830:  "net8-cman",
	1831:  "myrtle",
	1832:  "tht-treasure",
	1833:  "udpradio",
	1834:  "ardusuni",
	1835:  "ardusmul",
	1836:  "ste-smsc",
	1837:  "csoft1",
	1838:  "talnet",
	1839:  "netopia-vo1",
	1840:  "netopia-vo2",
	1841:  "netopia-vo3",
	1842:  "netopia-vo4",
	1843:  "netopia-vo5",
	1844:  "direcpc-dll",
	1845:  "altalink",
	1846:  "tunstall-pnc",
	1847:  "slp-notify",
	1848:  "fjdocdist",
	1849:  "alpha-sms",
	1850:  "gsi",
	1851:  "ctcd",
	1852:  "virtual-time",
	1853:  "vids-avtp",
	1854:  "buddy-draw",
	1855:  "fiorano-rtrsvc",
	1856:  "fiorano-msgsvc",
	1857:  "datacaptor",
	1858:  "privateark",
	1859:  "gammafetchsvr",
	1860:  "sunscalar-svc",
	1861:  "lecroy-vicp",
	1862:  "mysql-cm-agent",
	1863:  "msnp",
	1864:  "paradym-31port",
	1865:  "entp",
	1866:  "swrmi",
	1867:  "udrive",
	1868:  "viziblebrowser",
	1869:  "transact",
	1870:  "sunscalar-dns",
	1871:  "canocentral0",
	1872:  "canocentral1",
	1873:  "fjmpjps",
	1874:  "fjswapsnp",
	1875:  "westell-stats",
	1876:  "ewcappsrv",
	1877:  "hp-webqosdb",
	1878:  "drmsmc",
	1879:  "nettgain-nms",
	1880:  "vsat-control",
	1881:  "ibm-mqseries2",
	1882:  "ecsqdmn",
	1883:  "mqtt",
	1884:  "idmaps",
	1885:  "vrtstrapserver",
	1886:  "leoip",
	1887:  "filex-lport",
	1888:  "ncconfig",
	1889:  "unify-adapter",
	1890:  "wilkenlistener",
	1891:  "childkey-notif",
	1892:  "childkey-ctrl",
	1893:  "elad",
	1894:  "o2server-port",
	1896:  "b-novative-ls",
	1897:  "metaagent",
	1898:  "cymtec-port",
	1899:  "mc2studios",
	1900:  "ssdp",
	1901:  "fjicl-tep-a",
	1902:  "fjicl-tep-b",
	1903:  "linkname",
	1904:  "fjicl-tep-c",
	1905:  "sugp",
	1906:  "tpmd",
	1907:  "intrastar",
	1908:  "dawn",
	1909:  "global-wlink",
	1910:  "ultrabac",
	1911:  "mtp",
	1912:  "rhp-iibp",
	1913:  "armadp",
	1914:  "elm-momentum",
	1915:  "facelink",
	1916:  "persona",
	1917:  "noagent",
	1918:  "can-nds",
	1919:  "can-dch",
	1920:  "can-ferret",
	1921:  "noadmin",
	1922:  "tapestry",
	1923:  "spice",
	1924:  "xiip",
	1925:  "discovery-port",
	1926:  "egs",
	1927:  "videte-cipc",
	1928:  "emsd-port",
	1929:  "bandwiz-system",
	1930:  "driveappserver",
	1931:  "amdsched",
	1932:  "ctt-broker",
	1933:  "xmapi",
	1934:  "xaapi",
	1935:  "macromedia-fcs",
	1936:  "jetcmeserver",
	1937:  "jwserver",
	1938:  "jwclient",
	1939:  "jvserver",
	1940:  "jvclient",
	1941:  "dic-aida",
	1942:  "res",
	1943:  "beeyond-media",
	1944:  "close-combat",
	1945:  "dialogic-elmd",
	1946:  "tekpls",
	1947:  "sentinelsrm",
	1948:  "eye2eye",
	1949:  "ismaeasdaqlive",
	1950:  "ismaeasdaqtest",
	1951:  "bcs-lmserver",
	1952:  "mpnjsc",
	1953:  "rapidbase",
	1954:  "abr-api",
	1955:  "abr-secure",
	1956:  "vrtl-vmf-ds",
	1957:  "unix-status",
	1958:  "dxadmind",
	1959:  "simp-all",
	1960:  "nasmanager",
	1961:  "bts-appserver",
	1962:  "biap-mp",
	1963:  "webmachine",
	1964:  "solid-e-engine",
	1965:  "tivoli-npm",
	1966:  "slush",
	1967:  "sns-quote",
	1968:  "lipsinc",
	1969:  "lipsinc1",
	1970:  "netop-rc",
	1971:  "netop-school",
	1972:  "intersys-cache",
	1973:  "dlsrap",
	1974:  "drp",
	1975:  "tcoflashagent",
	1976:  "tcoregagent",
	1977:  "tcoaddressbook",
	1978:  "unisql",
	1979:  "unisql-java",
	1980:  "pearldoc-xact",
	1981:  "p2pq",
	1982:  "estamp",
	1983:  "lhtp",
	1984:  "bb",
	1985:  "hsrp",
	1986:  "licensedaemon",
	1987:  "tr-rsrb-p1",
	1988:  "tr-rsrb-p2",
	1989:  "tr-rsrb-p3",
	1990:  "stun-p1",
	1991:  "stun-p2",
	1992:  "stun-p3",
	1993:  "snmp-tcp-port",
	1994:  "stun-port",
	1995:  "perf-port",
	1996:  "tr-rsrb-port",
	1997:  "gdp-port",
	1998:  "x25-svc-port",
	1999:  "tcp-id-port",
	2000:  "cisco-sccp",
	2001:  "wizard",
	2002:  "globe",
	2003:  "brutus",
	2004:  "emce",
	2005:  "oracle",
	2006:  "raid-cd",
	2007:  "raid-am",
	2008:  "terminaldb",
	2009:  "whosockami",
	2010:  "pipe-server",
	2011:  "servserv",
	2012:  "raid-ac",
	2013:  "raid-cd",
	2014:  "raid-sf",
	2015:  "raid-cs",
	2016:  "bootserver",
	2017:  "bootclient",
	2018:  "rellpack",
	2019:  "about",
	2020:  "xinupageserver",
	2021:  "xinuexpansion1",
	2022:  "xinuexpansion2",
	2023:  "xinuexpansion3",
	2024:  "xinuexpansion4",
	2025:  "xribs",
	2026:  "scrabble",
	2027:  "shadowserver",
	2028:  "submitserver",
	2029:  "hsrpv6",
	2030:  "device2",
	2031:  "mobrien-chat",
	2032:  "blackboard",
	2033:  "glogger",
	2034:  "scoremgr",
	2035:  "imsldoc",
	2036:  "e-dpnet",
	2037:  "applus",
	2038:  "objectmanager",
	2039:  "prizma",
	2040:  "lam",
	2041:  "interbase",
	2042:  "isis",
	2043:  "isis-bcast",
	2044:  "rimsl",
	2045:  "cdfunc",
	2046:  "sdfunc",
	2047:  "dls",
	2048:  "dls-monitor",
	2049:  "shilp",
	2050:  "av-emb-config",
	2051:  "epnsdp",
	2052:  "clearvisn",
	2053:  "lot105-ds-upd",
	2054:  "weblogin",
	2055:  "iop",
	2056:  "omnisky",
	2057:  "rich-cp",
	2058:  "newwavesearch",
	2059:  "bmc-messaging",
	2060:  "teleniumdaemon",
	2061:  "netmount",
	2062:  "icg-swp",
	2063:  "icg-bridge",
	2064:  "icg-iprelay",
	2065:  "dlsrpn",
	2066:  "aura",
	2067:  "dlswpn",
	2068:  "avauthsrvprtcl",
	2069:  "event-port",
	2070:  "ah-esp-encap",
	2071:  "acp-port",
	2072:  "msync",
	2073:  "gxs-data-port",
	2074:  "vrtl-vmf-sa",
	2075:  "newlixengine",
	2076:  "newlixconfig",
	2077:  "tsrmagt",
	2078:  "tpcsrvr",
	2079:  "idware-router",
	2080:  "autodesk-nlm",
	2081:  "kme-trap-port",
	2082:  "infowave",
	2083:  "radsec",
	2084:  "sunclustergeo",
	2085:  "ada-cip",
	2086:  "gnunet",
	2087:  "eli",
	2088:  "ip-blf",
	2089:  "sep",
	2090:  "lrp",
	2091:  "prp",
	2092:  "descent3",
	2093:  "nbx-cc",
	2094:  "nbx-au",
	2095:  "nbx-ser",
	2096:  "nbx-dir",
	2097:  "jetformpreview",
	2098:  "dialog-port",
	2099:  "h2250-annex-g",
	2100:  "amiganetfs",
	2101:  "rtcm-sc104",
	2102:  "zephyr-srv",
	2103:  "zephyr-clt",
	2104:  "zephyr-hm",
	2105:  "minipay",
	2106:  "mzap",
	2107:  "bintec-admin",
	2108:  "comcam",
	2109:  "ergolight",
	2110:  "umsp",
	2111:  "dsatp",
	2112:  "idonix-metanet",
	2113:  "hsl-storm",
	2114:  "newheights",
	2115:  "kdm",
	2116:  "ccowcmr",
	2117:  "mentaclient",
	2118:  "mentaserver",
	2119:  "gsigatekeeper",
	2120:  "qencp",
	2121:  "scientia-ssdb",
	2122:  "caupc-remote",
	2123:  "gtp-control",
	2124:  "elatelink",
	2125:  "lockstep",
	2126:  "pktcable-cops",
	2127:  "index-pc-wb",
	2128:  "net-steward",
	2129:  "cs-live",
	2130:  "xds",
	2131:  "avantageb2b",
	2132:  "solera-epmap",
	2133:  "zymed-zpp",
	2134:  "avenue",
	2135:  "gris",
	2136:  "appworxsrv",
	2137:  "connect",
	2138:  "unbind-cluster",
	2139:  "ias-auth",
	2140:  "ias-reg",
	2141:  "ias-admind",
	2142:  "tdmoip",
	2143:  "lv-jc",
	2144:  "lv-ffx",
	2145:  "lv-pici",
	2146:  "lv-not",
	2147:  "lv-auth",
	2148:  "veritas-ucl",
	2149:  "acptsys",
	2150:  "dynamic3d",
	2151:  "docent",
	2152:  "gtp-user",
	2153:  "ctlptc",
	2154:  "stdptc",
	2155:  "brdptc",
	2156:  "trp",
	2157:  "xnds",
	2158:  "touchnetplus",
	2159:  "gdbremote",
	2160:  "apc-2160",
	2161:  "apc-2161",
	2162:  "navisphere",
	2163:  "navisphere-sec",
	2164:  "ddns-v3",
	2165:  "x-bone-api",
	2166:  "iwserver",
	2167:  "raw-serial",
	2168:  "easy-soft-mux",
	2169:  "brain",
	2170:  "eyetv",
	2171:  "msfw-storage",
	2172:  "msfw-s-storage",
	2173:  "msfw-replica",
	2174:  "msfw-array",
	2175:  "airsync",
	2176:  "rapi",
	2177:  "qwave",
	2178:  "bitspeer",
	2179:  "vmrdp",
	2180:  "mc-gt-srv",
	2181:  "eforward",
	2182:  "cgn-stat",
	2183:  "cgn-config",
	2184:  "nvd",
	2185:  "onbase-dds",
	2186:  "gtaua",
	2187:  "ssmd",
	2190:  "tivoconnect",
	2191:  "tvbus",
	2192:  "asdis",
	2193:  "drwcs",
	2197:  "mnp-exchange",
	2198:  "onehome-remote",
	2199:  "onehome-help",
	2200:  "ici",
	2201:  "ats",
	2202:  "imtc-map",
	2203:  "b2-runtime",
	2204:  "b2-license",
	2205:  "jps",
	2206:  "hpocbus",
	2207:  "hpssd",
	2208:  "hpiod",
	2209:  "rimf-ps",
	2210:  "noaaport",
	2211:  "emwin",
	2212:  "leecoposserver",
	2213:  "kali",
	2214:  "rpi",
	2215:  "ipcore",
	2216:  "vtu-comms",
	2217:  "gotodevice",
	2218:  "bounzza",
	2219:  "netiq-ncap",
	2220:  "netiq",
	2221:  "ethernet-ip-s",
	2222:  "EtherNet-IP-1",
	2223:  "rockwell-csp2",
	2224:  "efi-mg",
	2226:  "di-drm",
	2227:  "di-msg",
	2228:  "ehome-ms",
	2229:  "datalens",
	2230:  "queueadm",
	2231:  "wimaxasncp",
	2232:  "ivs-video",
	2233:  "infocrypt",
	2234:  "directplay",
	2235:  "sercomm-wlink",
	2236:  "nani",
	2237:  "optech-port1-lm",
	2238:  "aviva-sna",
	2239:  "imagequery",
	2240:  "recipe",
	2241:  "ivsd",
	2242:  "foliocorp",
	2243:  "magicom",
	2244:  "nmsserver",
	2245:  "hao",
	2246:  "pc-mta-addrmap",
	2247:  "antidotemgrsvr",
	2248:  "ums",
	2249:  "rfmp",
	2250:  "remote-collab",
	2251:  "dif-port",
	2252:  "njenet-ssl",
	2253:  "dtv-chan-req",
	2254:  "seispoc",
	2255:  "vrtp",
	2256:  "pcc-mfp",
	2257:  "simple-tx-rx",
	2258:  "rcts",
	2260:  "apc-2260",
	2261:  "comotionmaster",
	2262:  "comotionback",
	2263:  "ecwcfg",
	2264:  "apx500api-1",
	2265:  "apx500api-2",
	2266:  "mfserver",
	2267:  "ontobroker",
	2268:  "amt",
	2269:  "mikey",
	2270:  "starschool",
	2271:  "mmcals",
	2272:  "mmcal",
	2273:  "mysql-im",
	2274:  "pcttunnell",
	2275:  "ibridge-data",
	2276:  "ibridge-mgmt",
	2277:  "bluectrlproxy",
	2278:  "s3db",
	2279:  "xmquery",
	2280:  "lnvpoller",
	2281:  "lnvconsole",
	2282:  "lnvalarm",
	2283:  "lnvstatus",
	2284:  "lnvmaps",
	2285:  "lnvmailmon",
	2286:  "nas-metering",
	2287:  "dna",
	2288:  "netml",
	2289:  "dict-lookup",
	2290:  "sonus-logging",
	2291:  "eapsp",
	2292:  "mib-streaming",
	2293:  "npdbgmngr",
	2294:  "konshus-lm",
	2295:  "advant-lm",
	2296:  "theta-lm",
	2297:  "d2k-datamover1",
	2298:  "d2k-datamover2",
	2299:  "pc-telecommute",
	2300:  "cvmmon",
	2301:  "cpq-wbem",
	2302:  "binderysupport",
	2303:  "proxy-gateway",
	2304:  "attachmate-uts",
	2305:  "mt-scaleserver",
	2306:  "tappi-boxnet",
	2307:  "pehelp",
	2308:  "sdhelp",
	2309:  "sdserver",
	2310:  "sdclient",
	2311:  "messageservice",
	2312:  "wanscaler",
	2313:  "iapp",
	2314:  "cr-websystems",
	2315:  "precise-sft",
	2316:  "sent-lm",
	2317:  "attachmate-g32",
	2318:  "cadencecontrol",
	2319:  "infolibria",
	2320:  "siebel-ns",
	2321:  "rdlap",
	2322:  "ofsd",
	2323:  "3d-nfsd",
	2324:  "cosmocall",
	2325:  "ansysli",
	2326:  "idcp",
	2327:  "xingcsm",
	2328:  "netrix-sftm",
	2329:  "nvd",
	2330:  "tscchat",
	2331:  "agentview",
	2332:  "rcc-host",
	2333:  "snapp",
	2334:  "ace-client",
	2335:  "ace-proxy",
	2336:  "appleugcontrol",
	2337:  "ideesrv",
	2338:  "norton-lambert",
	2339:  "3com-webview",
	2340:  "wrs-registry",
	2341:  "xiostatus",
	2342:  "manage-exec",
	2343:  "nati-logos",
	2344:  "fcmsys",
	2345:  "dbm",
	2346:  "redstorm-join",
	2347:  "redstorm-find",
	2348:  "redstorm-info",
	2349:  "redstorm-diag",
	2350:  "psbserver",
	2351:  "psrserver",
	2352:  "pslserver",
	2353:  "pspserver",
	2354:  "psprserver",
	2355:  "psdbserver",
	2356:  "gxtelmd",
	2357:  "unihub-server",
	2358:  "futrix",
	2359:  "flukeserver",
	2360:  "nexstorindltd",
	2361:  "tl1",
	2362:  "digiman",
	2363:  "mediacntrlnfsd",
	2364:  "oi-2000",
	2365:  "dbref",
	2366:  "qip-login",
	2367:  "service-ctrl",
	2368:  "opentable",
	2370:  "l3-hbmon",
	2372:  "lanmessenger",
	2381:  "compaq-https",
	2382:  "ms-olap3",
	2383:  "ms-olap4",
	2384:  "sd-capacity",
	2385:  "sd-data",
	2386:  "virtualtape",
	2387:  "vsamredirector",
	2388:  "mynahautostart",
	2389:  "ovsessionmgr",
	2390:  "rsmtp",
	2391:  "3com-net-mgmt",
	2392:  "tacticalauth",
	2393:  "ms-olap1",
	2394:  "ms-olap2",
	2395:  "lan900-remote",
	2396:  "wusage",
	2397:  "ncl",
	2398:  "orbiter",
	2399:  "fmpro-fdal",
	2400:  "opequus-server",
	2401:  "cvspserver",
	2402:  "taskmaster2000",
	2403:  "taskmaster2000",
	2404:  "iec-104",
	2405:  "trc-netpoll",
	2406:  "jediserver",
	2407:  "orion",
	2409:  "sns-protocol",
	2410:  "vrts-registry",
	2411:  "netwave-ap-mgmt",
	2412:  "cdn",
	2413:  "orion-rmi-reg",
	2414:  "beeyond",
	2415:  "codima-rtp",
	2416:  "rmtserver",
	2417:  "composit-server",
	2418:  "cas",
	2419:  "attachmate-s2s",
	2420:  "dslremote-mgmt",
	2421:  "g-talk",
	2422:  "crmsbits",
	2423:  "rnrp",
	2424:  "kofax-svr",
	2425:  "fjitsuappmgr",
	2426:  "vcmp",
	2427:  "mgcp-gateway",
	2428:  "ott",
	2429:  "ft-role",
	2430:  "venus",
	2431:  "venus-se",
	2432:  "codasrv",
	2433:  "codasrv-se",
	2434:  "pxc-epmap",
	2435:  "optilogic",
	2436:  "topx",
	2437:  "unicontrol",
	2438:  "msp",
	2439:  "sybasedbsynch",
	2440:  "spearway",
	2441:  "pvsw-inet",
	2442:  "netangel",
	2443:  "powerclientcsf",
	2444:  "btpp2sectrans",
	2445:  "dtn1",
	2446:  "bues-service",
	2447:  "ovwdb",
	2448:  "hpppssvr",
	2449:  "ratl",
	2450:  "netadmin",
	2451:  "netchat",
	2452:  "snifferclient",
	2453:  "madge-ltd",
	2454:  "indx-dds",
	2455:  "wago-io-system",
	2456:  "altav-remmgt",
	2457:  "rapido-ip",
	2458:  "griffin",
	2459:  "community",
	2460:  "ms-theater",
	2461:  "qadmifoper",
	2462:  "qadmifevent",
	2463:  "lsi-raid-mgmt",
	2464:  "direcpc-si",
	2465:  "lbm",
	2466:  "lbf",
	2467:  "high-criteria",
	2468:  "qip-msgd",
	2469:  "mti-tcs-comm",
	2470:  "taskman-port",
	2471:  "seaodbc",
	2472:  "c3",
	2473:  "aker-cdp",
	2474:  "vitalanalysis",
	2475:  "ace-server",
	2476:  "ace-svr-prop",
	2477:  "ssm-cvs",
	2478:  "ssm-cssps",
	2479:  "ssm-els",
	2480:  "powerexchange",
	2481:  "giop",
	2482:  "giop-ssl",
	2483:  "ttc",
	2484:  "ttc-ssl",
	2485:  "netobjects1",
	2486:  "netobjects2",
	2487:  "pns",
	2488:  "moy-corp",
	2489:  "tsilb",
	2490:  "qip-qdhcp",
	2491:  "conclave-cpp",
	2492:  "groove",
	2493:  "talarian-mqs",
	2494:  "bmc-ar",
	2495:  "fast-rem-serv",
	2496:  "dirgis",
	2497:  "quaddb",
	2498:  "odn-castraq",
	2499:  "unicontrol",
	2500:  "rtsserv",
	2501:  "rtsclient",
	2502:  "kentrox-prot",
	2503:  "nms-dpnss",
	2504:  "wlbs",
	2505:  "ppcontrol",
	2506:  "jbroker",
	2507:  "spock",
	2508:  "jdatastore",
	2509:  "fjmpss",
	2510:  "fjappmgrbulk",
	2511:  "metastorm",
	2512:  "citrixima",
	2513:  "citrixadmin",
	2514:  "facsys-ntp",
	2515:  "facsys-router",
	2516:  "maincontrol",
	2517:  "call-sig-trans",
	2518:  "willy",
	2519:  "globmsgsvc",
	2520:  "pvsw",
	2521:  "adaptecmgr",
	2522:  "windb",
	2523:  "qke-llc-v3",
	2524:  "optiwave-lm",
	2525:  "ms-v-worlds",
	2526:  "ema-sent-lm",
	2527:  "iqserver",
	2528:  "ncr-ccl",
	2529:  "utsftp",
	2530:  "vrcommerce",
	2531:  "ito-e-gui",
	2532:  "ovtopmd",
	2533:  "snifferserver",
	2534:  "combox-web-acc",
	2535:  "madcap",
	2536:  "btpp2audctr1",
	2537:  "upgrade",
	2538:  "vnwk-prapi",
	2539:  "vsiadmin",
	2540:  "lonworks",
	2541:  "lonworks2",
	2542:  "udrawgraph",
	2543:  "reftek",
	2544:  "novell-zen",
	2545:  "sis-emt",
	2546:  "vytalvaultbrtp",
	2547:  "vytalvaultvsmp",
	2548:  "vytalvaultpipe",
	2549:  "ipass",
	2550:  "ads",
	2551:  "isg-uda-server",
	2552:  "call-logging",
	2553:  "efidiningport",
	2554:  "vcnet-link-v10",
	2555:  "compaq-wcp",
	2556:  "nicetec-nmsvc",
	2557:  "nicetec-mgmt",
	2558:  "pclemultimedia",
	2559:  "lstp",
	2560:  "labrat",
	2561:  "mosaixcc",
	2562:  "delibo",
	2563:  "cti-redwood",
	2564:  "hp-3000-telnet",
	2565:  "coord-svr",
	2566:  "pcs-pcw",
	2567:  "clp",
	2568:  "spamtrap",
	2569:  "sonuscallsig",
	2570:  "hs-port",
	2571:  "cecsvc",
	2572:  "ibp",
	2573:  "trustestablish",
	2574:  "blockade-bpsp",
	2575:  "hl7",
	2576:  "tclprodebugger",
	2577:  "scipticslsrvr",
	2578:  "rvs-isdn-dcp",
	2579:  "mpfoncl",
	2580:  "tributary",
	2581:  "argis-te",
	2582:  "argis-ds",
	2583:  "mon",
	2584:  "cyaserv",
	2585:  "netx-server",
	2586:  "netx-agent",
	2587:  "masc",
	2588:  "privilege",
	2589:  "quartus-tcl",
	2590:  "idotdist",
	2591:  "maytagshuffle",
	2592:  "netrek",
	2593:  "mns-mail",
	2594:  "dts",
	2595:  "worldfusion1",
	2596:  "worldfusion2",
	2597:  "homesteadglory",
	2598:  "citriximaclient",
	2599:  "snapd",
	2600:  "hpstgmgr",
	2601:  "discp-client",
	2602:  "discp-server",
	2603:  "servicemeter",
	2604:  "nsc-ccs",
	2605:  "nsc-posa",
	2606:  "netmon",
	2607:  "connection",
	2608:  "wag-service",
	2609:  "system-monitor",
	2610:  "versa-tek",
	2611:  "lionhead",
	2612:  "qpasa-agent",
	2613:  "smntubootstrap",
	2614:  "neveroffline",
	2615:  "firepower",
	2616:  "appswitch-emp",
	2617:  "cmadmin",
	2618:  "priority-e-com",
	2619:  "bruce",
	2620:  "lpsrecommender",
	2621:  "miles-apart",
	2622:  "metricadbc",
	2623:  "lmdp",
	2624:  "aria",
	2625:  "blwnkl-port",
	2626:  "gbjd816",
	2627:  "moshebeeri",
	2628:  "dict",
	2629:  "sitaraserver",
	2630:  "sitaramgmt",
	2631:  "sitaradir",
	2632:  "irdg-post",
	2633:  "interintelli",
	2634:  "pk-electronics",
	2635:  "backburner",
	2636:  "solve",
	2637:  "imdocsvc",
	2638:  "sybaseanywhere",
	2639:  "aminet",
	2640:  "ami-control",
	2641:  "hdl-srv",
	2642:  "tragic",
	2643:  "gte-samp",
	2644:  "travsoft-ipx-t",
	2645:  "novell-ipx-cmd",
	2646:  "and-lm",
	2647:  "syncserver",
	2648:  "upsnotifyprot",
	2649:  "vpsipport",
	2650:  "eristwoguns",
	2651:  "ebinsite",
	2652:  "interpathpanel",
	2653:  "sonus",
	2654:  "corel-vncadmin",
	2655:  "unglue",
	2656:  "kana",
	2657:  "sns-dispatcher",
	2658:  "sns-admin",
	2659:  "sns-query",
	2660:  "gcmonitor",
	2661:  "olhost",
	2662:  "bintec-capi",
	2663:  "bintec-tapi",
	2664:  "patrol-mq-gm",
	2665:  "patrol-mq-nm",
	2666:  "extensis",
	2667:  "alarm-clock-s",
	2668:  "alarm-clock-c",
	2669:  "toad",
	2670:  "tve-announce",
	2671:  "newlixreg",
	2672:  "nhserver",
	2673:  "firstcall42",
	2674:  "ewnn",
	2675:  "ttc-etap",
	2676:  "simslink",
	2677:  "gadgetgate1way",
	2678:  "gadgetgate2way",
	2679:  "syncserverssl",
	2680:  "pxc-sapxom",
	2681:  "mpnjsomb",
	2683:  "ncdloadbalance",
	2684:  "mpnjsosv",
	2685:  "mpnjsocl",
	2686:  "mpnjsomg",
	2687:  "pq-lic-mgmt",
	2688:  "md-cg-http",
	2689:  "fastlynx",
	2690:  "hp-nnm-data",
	2691:  "itinternet",
	2692:  "admins-lms",
	2694:  "pwrsevent",
	2695:  "vspread",
	2696:  "unifyadmin",
	2697:  "oce-snmp-trap",
	2698:  "mck-ivpip",
	2699:  "csoft-plusclnt",
	2700:  "tqdata",
	2701:  "sms-rcinfo",
	2702:  "sms-xfer",
	2703:  "sms-chat",
	2704:  "sms-remctrl",
	2705:  "sds-admin",
	2706:  "ncdmirroring",
	2707:  "emcsymapiport",
	2708:  "banyan-net",
	2709:  "supermon",
	2710:  "sso-service",
	2711:  "sso-control",
	2712:  "aocp",
	2713:  "raventbs",
	2714:  "raventdm",
	2715:  "hpstgmgr2",
	2716:  "inova-ip-disco",
	2717:  "pn-requester",
	2718:  "pn-requester2",
	2719:  "scan-change",
	2720:  "wkars",
	2721:  "smart-diagnose",
	2722:  "proactivesrvr",
	2723:  "watchdog-nt",
	2724:  "qotps",
	2725:  "msolap-ptp2",
	2726:  "tams",
	2727:  "mgcp-callagent",
	2728:  "sqdr",
	2729:  "tcim-control",
	2730:  "nec-raidplus",
	2731:  "fyre-messanger",
	2732:  "g5m",
	2733:  "signet-ctf",
	2734:  "ccs-software",
	2735:  "netiq-mc",
	2736:  "radwiz-nms-srv",
	2737:  "srp-feedback",
	2738:  "ndl-tcp-ois-gw",
	2739:  "tn-timing",
	2740:  "alarm",
	2741:  "tsb",
	2742:  "tsb2",
	2743:  "murx",
	2744:  "honyaku",
	2745:  "urbisnet",
	2746:  "cpudpencap",
	2747:  "fjippol-swrly",
	2748:  "fjippol-polsvr",
	2749:  "fjippol-cnsl",
	2750:  "fjippol-port1",
	2751:  "fjippol-port2",
	2752:  "rsisysaccess",
	2753:  "de-spot",
	2754:  "apollo-cc",
	2755:  "expresspay",
	2756:  "simplement-tie",
	2757:  "cnrp",
	2758:  "apollo-status",
	2759:  "apollo-gms",
	2760:  "sabams",
	2761:  "dicom-iscl",
	2762:  "dicom-tls",
	2763:  "desktop-dna",
	2764:  "data-insurance",
	2765:  "qip-audup",
	2766:  "compaq-scp",
	2767:  "uadtc",
	2768:  "uacs",
	2769:  "exce",
	2770:  "veronica",
	2771:  "vergencecm",
	2772:  "auris",
	2773:  "rbakcup1",
	2774:  "rbakcup2",
	2775:  "smpp",
	2776:  "ridgeway1",
	2777:  "ridgeway2",
	2778:  "gwen-sonya",
	2779:  "lbc-sync",
	2780:  "lbc-control",
	2781:  "whosells",
	2782:  "everydayrc",
	2783:  "aises",
	2784:  "www-dev",
	2785:  "aic-np",
	2786:  "aic-oncrpc",
	2787:  "piccolo",
	2788:  "fryeserv",
	2789:  "media-agent",
	2790:  "plgproxy",
	2791:  "mtport-regist",
	2792:  "f5-globalsite",
	2793:  "initlsmsad",
	2795:  "livestats",
	2796:  "ac-tech",
	2797:  "esp-encap",
	2798:  "tmesis-upshot",
	2799:  "icon-discover",
	2800:  "acc-raid",
	2801:  "igcp",
	2802:  "veritas-udp1",
	2803:  "btprjctrl",
	2804:  "dvr-esm",
	2805:  "wta-wsp-s",
	2806:  "cspuni",
	2807:  "cspmulti",
	2808:  "j-lan-p",
	2809:  "corbaloc",
	2810:  "netsteward",
	2811:  "gsiftp",
	2812:  "atmtcp",
	2813:  "llm-pass",
	2814:  "llm-csv",
	2815:  "lbc-measure",
	2816:  "lbc-watchdog",
	2817:  "nmsigport",
	2818:  "rmlnk",
	2819:  "fc-faultnotify",
	2820:  "univision",
	2821:  "vrts-at-port",
	2822:  "ka0wuc",
	2823:  "cqg-netlan",
	2824:  "cqg-netlan-1",
	2826:  "slc-systemlog",
	2827:  "slc-ctrlrloops",
	2828:  "itm-lm",
	2829:  "silkp1",
	2830:  "silkp2",
	2831:  "silkp3",
	2832:  "silkp4",
	2833:  "glishd",
	2834:  "evtp",
	2835:  "evtp-data",
	2836:  "catalyst",
	2837:  "repliweb",
	2838:  "starbot",
	2839:  "nmsigport",
	2840:  "l3-exprt",
	2841:  "l3-ranger",
	2842:  "l3-hawk",
	2843:  "pdnet",
	2844:  "bpcp-poll",
	2845:  "bpcp-trap",
	2846:  "aimpp-hello",
	2847:  "aimpp-port-req",
	2848:  "amt-blc-port",
	2849:  "fxp",
	2850:  "metaconsole",
	2851:  "webemshttp",
	2852:  "bears-01",
	2853:  "ispipes",
	2854:  "infomover",
	2856:  "cesdinv",
	2857:  "simctlp",
	2858:  "ecnp",
	2859:  "activememory",
	2860:  "dialpad-voice1",
	2861:  "dialpad-voice2",
	2862:  "ttg-protocol",
	2863:  "sonardata",
	2864:  "astromed-main",
	2865:  "pit-vpn",
	2866:  "iwlistener",
	2867:  "esps-portal",
	2868:  "npep-messaging",
	2869:  "icslap",
	2870:  "daishi",
	2871:  "msi-selectplay",
	2872:  "radix",
	2874:  "dxmessagebase1",
	2875:  "dxmessagebase2",
	2876:  "sps-tunnel",
	2877:  "bluelance",
	2878:  "aap",
	2879:  "ucentric-ds",
	2880:  "synapse",
	2881:  "ndsp",
	2882:  "ndtp",
	2883:  "ndnp",
	2884:  "flashmsg",
	2885:  "topflow",
	2886:  "responselogic",
	2887:  "aironetddp",
	2888:  "spcsdlobby",
	2889:  "rsom",
	2890:  "cspclmulti",
	2891:  "cinegrfx-elmd",
	2892:  "snifferdata",
	2893:  "vseconnector",
	2894:  "abacus-remote",
	2895:  "natuslink",
	2896:  "ecovisiong6-1",
	2897:  "citrix-rtmp",
	2898:  "appliance-cfg",
	2899:  "powergemplus",
	2900:  "quicksuite",
	2901:  "allstorcns",
	2902:  "netaspi",
	2903:  "suitcase",
	2904:  "m2ua",
	2906:  "caller9",
	2907:  "webmethods-b2b",
	2908:  "mao",
	2909:  "funk-dialout",
	2910:  "tdaccess",
	2911:  "blockade",
	2912:  "epicon",
	2913:  "boosterware",
	2914:  "gamelobby",
	2915:  "tksocket",
	2916:  "elvin-server",
	2917:  "elvin-client",
	2918:  "kastenchasepad",
	2919:  "roboer",
	2920:  "roboeda",
	2921:  "cesdcdman",
	2922:  "cesdcdtrn",
	2923:  "wta-wsp-wtp-s",
	2924:  "precise-vip",
	2926:  "mobile-file-dl",
	2927:  "unimobilectrl",
	2928:  "redstone-cpss",
	2929:  "amx-webadmin",
	2930:  "amx-weblinx",
	2931:  "circle-x",
	2932:  "incp",
	2933:  "4-tieropmgw",
	2934:  "4-tieropmcli",
	2935:  "qtp",
	2936:  "otpatch",
	2937:  "pnaconsult-lm",
	2938:  "sm-pas-1",
	2939:  "sm-pas-2",
	2940:  "sm-pas-3",
	2941:  "sm-pas-4",
	2942:  "sm-pas-5",
	2943:  "ttnrepository",
	2944:  "megaco-h248",
	2945:  "h248-binary",
	2946:  "fjsvmpor",
	2947:  "gpsd",
	2948:  "wap-push",
	2949:  "wap-pushsecure",
	2950:  "esip",
	2951:  "ottp",
	2952:  "mpfwsas",
	2953:  "ovalarmsrv",
	2954:  "ovalarmsrv-cmd",
	2955:  "csnotify",
	2956:  "ovrimosdbman",
	2957:  "jmact5",
	2958:  "jmact6",
	2959:  "rmopagt",
	2960:  "dfoxserver",
	2961:  "boldsoft-lm",
	2962:  "iph-policy-cli",
	2963:  "iph-policy-adm",
	2964:  "bullant-srap",
	2965:  "bullant-rap",
	2966:  "idp-infotrieve",
	2967:  "ssc-agent",
	2968:  "enpp",
	2969:  "essp",
	2970:  "index-net",
	2971:  "netclip",
	2972:  "pmsm-webrctl",
	2973:  "svnetworks",
	2974:  "signal",
	2975:  "fjmpcm",
	2976:  "cns-srv-port",
	2977:  "ttc-etap-ns",
	2978:  "ttc-etap-ds",
	2979:  "h263-video",
	2980:  "wimd",
	2981:  "mylxamport",
	2982:  "iwb-whiteboard",
	2983:  "netplan",
	2984:  "hpidsadmin",
	2985:  "hpidsagent",
	2986:  "stonefalls",
	2987:  "identify",
	2988:  "hippad",
	2989:  "zarkov",
	2990:  "boscap",
	2991:  "wkstn-mon",
	2992:  "avenyo",
	2993:  "veritas-vis1",
	2994:  "veritas-vis2",
	2995:  "idrs",
	2996:  "vsixml",
	2997:  "rebol",
	2998:  "realsecure",
	2999:  "remoteware-un",
	3000:  "hbci",
	3002:  "exlm-agent",
	3003:  "cgms",
	3004:  "csoftragent",
	3005:  "geniuslm",
	3006:  "ii-admin",
	3007:  "lotusmtap",
	3008:  "midnight-tech",
	3009:  "pxc-ntfy",
	3010:  "ping-pong",
	3011:  "trusted-web",
	3012:  "twsdss",
	3013:  "gilatskysurfer",
	3014:  "broker-service",
	3015:  "nati-dstp",
	3016:  "notify-srvr",
	3017:  "event-listener",
	3018:  "srvc-registry",
	3019:  "resource-mgr",
	3020:  "cifs",
	3021:  "agriserver",
	3022:  "csregagent",
	3023:  "magicnotes",
	3024:  "nds-sso",
	3025:  "arepa-raft",
	3026:  "agri-gateway",
	3027:  "LiebDevMgmt-C",
	3028:  "LiebDevMgmt-DM",
	3029:  "LiebDevMgmt-A",
	3030:  "arepa-cas",
	3031:  "eppc",
	3032:  "redwood-chat",
	3033:  "pdb",
	3034:  "osmosis-aeea",
	3035:  "fjsv-gssagt",
	3036:  "hagel-dump",
	3037:  "hp-san-mgmt",
	3038:  "santak-ups",
	3039:  "cogitate",
	3040:  "tomato-springs",
	3041:  "di-traceware",
	3042:  "journee",
	3043:  "brp",
	3044:  "epp",
	3045:  "responsenet",
	3046:  "di-ase",
	3047:  "hlserver",
	3048:  "pctrader",
	3049:  "nsws",
	3050:  "gds-db",
	3051:  "galaxy-server",
	3052:  "apc-3052",
	3053:  "dsom-server",
	3054:  "amt-cnf-prot",
	3055:  "policyserver",
	3056:  "cdl-server",
	3057:  "goahead-fldup",
	3058:  "videobeans",
	3059:  "qsoft",
	3060:  "interserver",
	3061:  "cautcpd",
	3062:  "ncacn-ip-tcp",
	3063:  "ncadg-ip-udp",
	3064:  "rprt",
	3065:  "slinterbase",
	3066:  "netattachsdmp",
	3067:  "fjhpjp",
	3068:  "ls3bcast",
	3069:  "ls3",
	3070:  "mgxswitch",
	3072:  "csd-monitor",
	3073:  "vcrp",
	3074:  "xbox",
	3075:  "orbix-locator",
	3076:  "orbix-config",
	3077:  "orbix-loc-ssl",
	3078:  "orbix-cfg-ssl",
	3079:  "lv-frontpanel",
	3080:  "stm-pproc",
	3081:  "tl1-lv",
	3082:  "tl1-raw",
	3083:  "tl1-telnet",
	3084:  "itm-mccs",
	3085:  "pcihreq",
	3086:  "jdl-dbkitchen",
	3087:  "asoki-sma",
	3088:  "xdtp",
	3089:  "ptk-alink",
	3090:  "stss",
	3091:  "1ci-smcs",
	3093:  "rapidmq-center",
	3094:  "rapidmq-reg",
	3095:  "panasas",
	3096:  "ndl-aps",
	3098:  "umm-port",
	3099:  "chmd",
	3100:  "opcon-xps",
	3101:  "hp-pxpib",
	3102:  "slslavemon",
	3103:  "autocuesmi",
	3104:  "autocuetime",
	3105:  "cardbox",
	3106:  "cardbox-http",
	3107:  "business",
	3108:  "geolocate",
	3109:  "personnel",
	3110:  "sim-control",
	3111:  "wsynch",
	3112:  "ksysguard",
	3113:  "cs-auth-svr",
	3114:  "ccmad",
	3115:  "mctet-master",
	3116:  "mctet-gateway",
	3117:  "mctet-jserv",
	3118:  "pkagent",
	3119:  "d2000kernel",
	3120:  "d2000webserver",
	3122:  "vtr-emulator",
	3123:  "edix",
	3124:  "beacon-port",
	3125:  "a13-an",
	3127:  "ctx-bridge",
	3128:  "ndl-aas",
	3129:  "netport-id",
	3130:  "icpv2",
	3131:  "netbookmark",
	3132:  "ms-rule-engine",
	3133:  "prism-deploy",
	3134:  "ecp",
	3135:  "peerbook-port",
	3136:  "grubd",
	3137:  "rtnt-1",
	3138:  "rtnt-2",
	3139:  "incognitorv",
	3140:  "ariliamulti",
	3141:  "vmodem",
	3142:  "rdc-wh-eos",
	3143:  "seaview",
	3144:  "tarantella",
	3145:  "csi-lfap",
	3146:  "bears-02",
	3147:  "rfio",
	3148:  "nm-game-admin",
	3149:  "nm-game-server",
	3150:  "nm-asses-admin",
	3151:  "nm-assessor",
	3152:  "feitianrockey",
	3153:  "s8-client-port",
	3154:  "ccmrmi",
	3155:  "jpegmpeg",
	3156:  "indura",
	3157:  "e3consultants",
	3158:  "stvp",
	3159:  "navegaweb-port",
	3160:  "tip-app-server",
	3161:  "doc1lm",
	3162:  "sflm",
	3163:  "res-sap",
	3164:  "imprs",
	3165:  "newgenpay",
	3166:  "sossecollector",
	3167:  "nowcontact",
	3168:  "poweronnud",
	3169:  "serverview-as",
	3170:  "serverview-asn",
	3171:  "serverview-gf",
	3172:  "serverview-rm",
	3173:  "serverview-icc",
	3174:  "armi-server",
	3175:  "t1-e1-over-ip",
	3176:  "ars-master",
	3177:  "phonex-port",
	3178:  "radclientport",
	3179:  "h2gf-w-2m",
	3180:  "mc-brk-srv",
	3181:  "bmcpatrolagent",
	3182:  "bmcpatrolrnvu",
	3183:  "cops-tls",
	3184:  "apogeex-port",
	3185:  "smpppd",
	3186:  "iiw-port",
	3187:  "odi-port",
	3188:  "brcm-comm-port",
	3189:  "pcle-infex",
	3190:  "csvr-proxy",
	3191:  "csvr-sslproxy",
	3192:  "firemonrcc",
	3193:  "spandataport",
	3194:  "magbind",
	3195:  "ncu-1",
	3196:  "ncu-2",
	3197:  "embrace-dp-s",
	3198:  "embrace-dp-c",
	3199:  "dmod-workspace",
	3200:  "tick-port",
	3201:  "cpq-tasksmart",
	3202:  "intraintra",
	3203:  "netwatcher-mon",
	3204:  "netwatcher-db",
	3205:  "isns",
	3206:  "ironmail",
	3207:  "vx-auth-port",
	3208:  "pfu-prcallback",
	3209:  "netwkpathengine",
	3210:  "flamenco-proxy",
	3211:  "avsecuremgmt",
	3212:  "surveyinst",
	3213:  "neon24x7",
	3214:  "jmq-daemon-1",
	3215:  "jmq-daemon-2",
	3216:  "ferrari-foam",
	3217:  "unite",
	3218:  "smartpackets",
	3219:  "wms-messenger",
	3220:  "xnm-ssl",
	3221:  "xnm-clear-text",
	3222:  "glbp",
	3223:  "digivote",
	3224:  "aes-discovery",
	3225:  "fcip-port",
	3226:  "isi-irp",
	3227:  "dwnmshttp",
	3228:  "dwmsgserver",
	3229:  "global-cd-port",
	3230:  "sftdst-port",
	3231:  "vidigo",
	3232:  "mdtp",
	3233:  "whisker",
	3234:  "alchemy",
	3235:  "mdap-port",
	3236:  "apparenet-ts",
	3237:  "apparenet-tps",
	3238:  "apparenet-as",
	3239:  "apparenet-ui",
	3240:  "triomotion",
	3241:  "sysorb",
	3242:  "sdp-id-port",
	3243:  "timelot",
	3244:  "onesaf",
	3245:  "vieo-fe",
	3246:  "dvt-system",
	3247:  "dvt-data",
	3248:  "procos-lm",
	3249:  "ssp",
	3250:  "hicp",
	3251:  "sysscanner",
	3252:  "dhe",
	3253:  "pda-data",
	3254:  "pda-sys",
	3255:  "semaphore",
	3256:  "cpqrpm-agent",
	3257:  "cpqrpm-server",
	3258:  "ivecon-port",
	3259:  "epncdp2",
	3260:  "iscsi-target",
	3261:  "winshadow",
	3262:  "necp",
	3263:  "ecolor-imager",
	3264:  "ccmail",
	3265:  "altav-tunnel",
	3266:  "ns-cfg-server",
	3267:  "ibm-dial-out",
	3268:  "msft-gc",
	3269:  "msft-gc-ssl",
	3270:  "verismart",
	3271:  "csoft-prev",
	3272:  "user-manager",
	3273:  "sxmp",
	3274:  "ordinox-server",
	3275:  "samd",
	3276:  "maxim-asics",
	3277:  "awg-proxy",
	3278:  "lkcmserver",
	3279:  "admind",
	3280:  "vs-server",
	3281:  "sysopt",
	3282:  "datusorb",
	3283:  "Apple Remote Desktop (Net Assistant)",
	3284:  "4talk",
	3285:  "plato",
	3286:  "e-net",
	3287:  "directvdata",
	3288:  "cops",
	3289:  "enpc",
	3290:  "caps-lm",
	3291:  "sah-lm",
	3292:  "cart-o-rama",
	3293:  "fg-fps",
	3294:  "fg-gip",
	3295:  "dyniplookup",
	3296:  "rib-slm",
	3297:  "cytel-lm",
	3298:  "deskview",
	3299:  "pdrncs",
	3302:  "mcs-fastmail",
	3303:  "opsession-clnt",
	3304:  "opsession-srvr",
	3305:  "odette-ftp",
	3306:  "mysql",
	3307:  "opsession-prxy",
	3308:  "tns-server",
	3309:  "tns-adv",
	3310:  "dyna-access",
	3311:  "mcns-tel-ret",
	3312:  "appman-server",
	3313:  "uorb",
	3314:  "uohost",
	3315:  "cdid",
	3316:  "aicc-cmi",
	3317:  "vsaiport",
	3318:  "ssrip",
	3319:  "sdt-lmd",
	3320:  "officelink2000",
	3321:  "vnsstr",
	3326:  "sftu",
	3327:  "bbars",
	3328:  "egptlm",
	3329:  "hp-device-disc",
	3330:  "mcs-calypsoicf",
	3331:  "mcs-messaging",
	3332:  "mcs-mailsvr",
	3333:  "dec-notes",
	3334:  "directv-web",
	3335:  "directv-soft",
	3336:  "directv-tick",
	3337:  "directv-catlg",
	3338:  "anet-b",
	3339:  "anet-l",
	3340:  "anet-m",
	3341:  "anet-h",
	3342:  "webtie",
	3343:  "ms-cluster-net",
	3344:  "bnt-manager",
	3345:  "influence",
	3346:  "trnsprntproxy",
	3347:  "phoenix-rpc",
	3348:  "pangolin-laser",
	3349:  "chevinservices",
	3350:  "findviatv",
	3351:  "btrieve",
	3352:  "ssql",
	3353:  "fatpipe",
	3354:  "suitjd",
	3355:  "ordinox-dbase",
	3356:  "upnotifyps",
	3357:  "adtech-test",
	3358:  "mpsysrmsvr",
	3359:  "wg-netforce",
	3360:  "kv-server",
	3361:  "kv-agent",
	3362:  "dj-ilm",
	3363:  "nati-vi-server",
	3364:  "creativeserver",
	3365:  "contentserver",
	3366:  "creativepartnr",
	3372:  "tip2",
	3373:  "lavenir-lm",
	3374:  "cluster-disc",
	3375:  "vsnm-agent",
	3376:  "cdbroker",
	3377:  "cogsys-lm",
	3378:  "wsicopy",
	3379:  "socorfs",
	3380:  "sns-channels",
	3381:  "geneous",
	3382:  "fujitsu-neat",
	3383:  "esp-lm",
	3384:  "hp-clic",
	3385:  "qnxnetman",
	3386:  "gprs-sig",
	3387:  "backroomnet",
	3388:  "cbserver",
	3389:  "ms-wbt-server",
	3390:  "dsc",
	3391:  "savant",
	3392:  "efi-lm",
	3393:  "d2k-tapestry1",
	3394:  "d2k-tapestry2",
	3395:  "dyna-lm",
	3396:  "printer-agent",
	3397:  "cloanto-lm",
	3398:  "mercantile",
	3399:  "csms",
	3400:  "csms2",
	3401:  "filecast",
	3402:  "fxaengine-net",
	3405:  "nokia-ann-ch1",
	3406:  "nokia-ann-ch2",
	3407:  "ldap-admin",
	3408:  "BESApi",
	3409:  "networklens",
	3410:  "networklenss",
	3411:  "biolink-auth",
	3412:  "xmlblaster",
	3413:  "svnet",
	3414:  "wip-port",
	3415:  "bcinameservice",
	3416:  "commandport",
	3417:  "csvr",
	3418:  "rnmap",
	3419:  "softaudit",
	3420:  "ifcp-port",
	3421:  "bmap",
	3422:  "rusb-sys-port",
	3423:  "xtrm",
	3424:  "xtrms",
	3425:  "agps-port",
	3426:  "arkivio",
	3427:  "websphere-snmp",
	3428:  "twcss",
	3429:  "gcsp",
	3430:  "ssdispatch",
	3431:  "ndl-als",
	3432:  "osdcp",
	3433:  "opnet-smp",
	3434:  "opencm",
	3435:  "pacom",
	3436:  "gc-config",
	3437:  "autocueds",
	3438:  "spiral-admin",
	3439:  "hri-port",
	3440:  "ans-console",
	3441:  "connect-client",
	3442:  "connect-server",
	3443:  "ov-nnm-websrv",
	3444:  "denali-server",
	3445:  "monp",
	3446:  "3comfaxrpc",
	3447:  "directnet",
	3448:  "dnc-port",
	3449:  "hotu-chat",
	3450:  "castorproxy",
	3451:  "asam",
	3452:  "sabp-signal",
	3453:  "pscupd",
	3454:  "mira",
	3455:  "prsvp",
	3456:  "vat",
	3457:  "vat-control",
	3458:  "d3winosfi",
	3459:  "integral",
	3460:  "edm-manager",
	3461:  "edm-stager",
	3462:  "edm-std-notify",
	3463:  "edm-adm-notify",
	3464:  "edm-mgr-sync",
	3465:  "edm-mgr-cntrl",
	3466:  "workflow",
	3467:  "rcst",
	3468:  "ttcmremotectrl",
	3469:  "pluribus",
	3470:  "jt400",
	3471:  "jt400-ssl",
	3472:  "jaugsremotec-1",
	3473:  "jaugsremotec-2",
	3474:  "ttntspauto",
	3475:  "genisar-port",
	3476:  "nppmp",
	3477:  "ecomm",
	3478:  "stun",
	3479:  "twrpc",
	3480:  "plethora",
	3481:  "cleanerliverc",
	3482:  "vulture",
	3483:  "slim-devices",
	3484:  "gbs-stp",
	3485:  "celatalk",
	3486:  "ifsf-hb-port",
	3487:  "ltcudp",
	3488:  "fs-rh-srv",
	3489:  "dtp-dia",
	3490:  "colubris",
	3491:  "swr-port",
	3492:  "tvdumtray-port",
	3493:  "nut",
	3494:  "ibm3494",
	3495:  "seclayer-tcp",
	3496:  "seclayer-tls",
	3497:  "ipether232port",
	3498:  "dashpas-port",
	3499:  "sccip-media",
	3500:  "rtmp-port",
	3501:  "isoft-p2p",
	3502:  "avinstalldisc",
	3503:  "lsp-ping",
	3504:  "ironstorm",
	3505:  "ccmcomm",
	3506:  "apc-3506",
	3507:  "nesh-broker",
	3508:  "interactionweb",
	3509:  "vt-ssl",
	3510:  "xss-port",
	3511:  "webmail-2",
	3512:  "aztec",
	3513:  "arcpd",
	3514:  "must-p2p",
	3515:  "must-backplane",
	3516:  "smartcard-port",
	3517:  "802-11-iapp",
	3518:  "artifact-msg",
	3519:  "galileo",
	3520:  "galileolog",
	3521:  "mc3ss",
	3522:  "nssocketport",
	3523:  "odeumservlink",
	3524:  "ecmport",
	3525:  "eisport",
	3526:  "starquiz-port",
	3527:  "beserver-msg-q",
	3528:  "jboss-iiop",
	3529:  "jboss-iiop-ssl",
	3530:  "gf",
	3531:  "joltid",
	3532:  "raven-rmp",
	3533:  "raven-rdp",
	3534:  "urld-port",
	3535:  "ms-la",
	3536:  "snac",
	3537:  "ni-visa-remote",
	3538:  "ibm-diradm",
	3539:  "ibm-diradm-ssl",
	3540:  "pnrp-port",
	3541:  "voispeed-port",
	3542:  "hacl-monitor",
	3543:  "qftest-lookup",
	3544:  "teredo",
	3545:  "camac",
	3547:  "symantec-sim",
	3548:  "interworld",
	3549:  "tellumat-nms",
	3550:  "ssmpp",
	3551:  "apcupsd",
	3552:  "taserver",
	3553:  "rbr-discovery",
	3554:  "questnotify",
	3555:  "razor",
	3556:  "sky-transport",
	3557:  "personalos-001",
	3558:  "mcp-port",
	3559:  "cctv-port",
	3560:  "iniserve-port",
	3561:  "bmc-onekey",
	3562:  "sdbproxy",
	3563:  "watcomdebug",
	3564:  "esimport",
	3567:  "dof-eps",
	3568:  "dof-tunnel-sec",
	3569:  "mbg-ctrl",
	3570:  "mccwebsvr-port",
	3571:  "megardsvr-port",
	3572:  "megaregsvrport",
	3573:  "tag-ups-1",
	3574:  "dmaf-caster",
	3575:  "ccm-port",
	3576:  "cmc-port",
	3577:  "config-port",
	3578:  "data-port",
	3579:  "ttat3lb",
	3580:  "nati-svrloc",
	3581:  "kfxaclicensing",
	3582:  "press",
	3583:  "canex-watch",
	3584:  "u-dbap",
	3585:  "emprise-lls",
	3586:  "emprise-lsc",
	3587:  "p2pgroup",
	3588:  "sentinel",
	3589:  "isomair",
	3590:  "wv-csp-sms",
	3591:  "gtrack-server",
	3592:  "gtrack-ne",
	3593:  "bpmd",
	3594:  "mediaspace",
	3595:  "shareapp",
	3596:  "iw-mmogame",
	3597:  "a14",
	3598:  "a15",
	3599:  "quasar-server",
	3600:  "trap-daemon",
	3601:  "visinet-gui",
	3602:  "infiniswitchcl",
	3603:  "int-rcv-cntrl",
	3604:  "bmc-jmx-port",
	3605:  "comcam-io",
	3606:  "splitlock",
	3607:  "precise-i3",
	3608:  "trendchip-dcp",
	3609:  "cpdi-pidas-cm",
	3610:  "echonet",
	3611:  "six-degrees",
	3612:  "hp-dataprotect",
	3613:  "alaris-disc",
	3614:  "sigma-port",
	3615:  "start-network",
	3616:  "cd3o-protocol",
	3617:  "sharp-server",
	3618:  "aairnet-1",
	3619:  "aairnet-2",
	3620:  "ep-pcp",
	3621:  "ep-nsp",
	3622:  "ff-lr-port",
	3623:  "haipe-discover",
	3624:  "dist-upgrade",
	3625:  "volley",
	3626:  "bvcdaemon-port",
	3627:  "jamserverport",
	3628:  "ept-machine",
	3629:  "escvpnet",
	3630:  "cs-remote-db",
	3631:  "cs-services",
	3632:  "distcc",
	3633:  "wacp",
	3634:  "hlibmgr",
	3635:  "sdo",
	3636:  "servistaitsm",
	3637:  "scservp",
	3638:  "ehp-backup",
	3639:  "xap-ha",
	3640:  "netplay-port1",
	3641:  "netplay-port2",
	3642:  "juxml-port",
	3643:  "audiojuggler",
	3644:  "ssowatch",
	3645:  "cyc",
	3646:  "xss-srv-port",
	3647:  "splitlock-gw",
	3648:  "fjcp",
	3649:  "nmmp",
	3650:  "prismiq-plugin",
	3651:  "xrpc-registry",
	3652:  "vxcrnbuport",
	3653:  "tsp",
	3654:  "vaprtm",
	3655:  "abatemgr",
	3656:  "abatjss",
	3657:  "immedianet-bcn",
	3658:  "ps-ams",
	3659:  "apple-sasl",
	3660:  "can-nds-ssl",
	3661:  "can-ferret-ssl",
	3662:  "pserver",
	3663:  "dtp",
	3664:  "ups-engine",
	3665:  "ent-engine",
	3666:  "eserver-pap",
	3667:  "infoexch",
	3668:  "dell-rm-port",
	3669:  "casanswmgmt",
	3670:  "smile",
	3671:  "efcp",
	3672:  "lispworks-orb",
	3673:  "mediavault-gui",
	3674:  "wininstall-ipc",
	3675:  "calltrax",
	3676:  "va-pacbase",
	3677:  "roverlog",
	3678:  "ipr-dglt",
	3679:  "Escale (Newton Dock)",
	3680:  "npds-tracker",
	3681:  "bts-x73",
	3682:  "cas-mapi",
	3683:  "bmc-ea",
	3684:  "faxstfx-port",
	3685:  "dsx-agent",
	3686:  "tnmpv2",
	3687:  "simple-push",
	3688:  "simple-push-s",
	3689:  "daap",
	3690:  "svn",
	3691:  "magaya-network",
	3692:  "intelsync",
	3695:  "bmc-data-coll",
	3696:  "telnetcpcd",
	3697:  "nw-license",
	3698:  "sagectlpanel",
	3699:  "kpn-icw",
	3700:  "lrs-paging",
	3701:  "netcelera",
	3702:  "ws-discovery",
	3703:  "adobeserver-3",
	3704:  "adobeserver-4",
	3705:  "adobeserver-5",
	3706:  "rt-event",
	3707:  "rt-event-s",
	3708:  "sun-as-iiops",
	3709:  "ca-idms",
	3710:  "portgate-auth",
	3711:  "edb-server2",
	3712:  "sentinel-ent",
	3713:  "tftps",
	3714:  "delos-dms",
	3715:  "anoto-rendezv",
	3716:  "wv-csp-sms-cir",
	3717:  "wv-csp-udp-cir",
	3718:  "opus-services",
	3719:  "itelserverport",
	3720:  "ufastro-instr",
	3721:  "xsync",
	3722:  "xserveraid",
	3723:  "sychrond",
	3724:  "blizwow",
	3725:  "na-er-tip",
	3726:  "array-manager",
	3727:  "e-mdu",
	3728:  "e-woa",
	3729:  "fksp-audit",
	3730:  "client-ctrl",
	3731:  "smap",
	3732:  "m-wnn",
	3733:  "multip-msg",
	3734:  "synel-data",
	3735:  "pwdis",
	3736:  "rs-rmi",
	3738:  "versatalk",
	3739:  "launchbird-lm",
	3740:  "heartbeat",
	3741:  "wysdma",
	3742:  "cst-port",
	3743:  "ipcs-command",
	3744:  "sasg",
	3745:  "gw-call-port",
	3746:  "linktest",
	3747:  "linktest-s",
	3748:  "webdata",
	3749:  "cimtrak",
	3750:  "cbos-ip-port",
	3751:  "gprs-cube",
	3752:  "vipremoteagent",
	3753:  "nattyserver",
	3754:  "timestenbroker",
	3755:  "sas-remote-hlp",
	3756:  "canon-capt",
	3757:  "grf-port",
	3758:  "apw-registry",
	3759:  "exapt-lmgr",
	3760:  "adtempusclient",
	3761:  "gsakmp",
	3762:  "gbs-smp",
	3763:  "xo-wave",
	3764:  "mni-prot-rout",
	3765:  "rtraceroute",
	3767:  "listmgr-port",
	3768:  "rblcheckd",
	3769:  "haipe-otnk",
	3770:  "cindycollab",
	3771:  "paging-port",
	3772:  "ctp",
	3773:  "ctdhercules",
	3774:  "zicom",
	3775:  "ispmmgr",
	3776:  "dvcprov-port",
	3777:  "jibe-eb",
	3778:  "c-h-it-port",
	3779:  "cognima",
	3780:  "nnp",
	3781:  "abcvoice-port",
	3782:  "iso-tp0s",
	3783:  "bim-pem",
	3784:  "bfd-control",
	3785:  "bfd-echo",
	3786:  "upstriggervsw",
	3787:  "fintrx",
	3788:  "isrp-port",
	3789:  "remotedeploy",
	3790:  "quickbooksrds",
	3791:  "tvnetworkvideo",
	3792:  "sitewatch",
	3793:  "dcsoftware",
	3794:  "jaus",
	3795:  "myblast",
	3796:  "spw-dialer",
	3797:  "idps",
	3798:  "minilock",
	3799:  "radius-dynauth",
	3800:  "pwgpsi",
	3801:  "ibm-mgr",
	3802:  "vhd",
	3803:  "soniqsync",
	3804:  "iqnet-port",
	3805:  "tcpdataserver",
	3806:  "wsmlb",
	3807:  "spugna",
	3808:  "sun-as-iiops-ca",
	3809:  "apocd",
	3810:  "wlanauth",
	3811:  "amp",
	3812:  "neto-wol-server",
	3813:  "rap-ip",
	3814:  "neto-dcs",
	3815:  "lansurveyorxml",
	3816:  "sunlps-http",
	3817:  "tapeware",
	3818:  "crinis-hb",
	3819:  "epl-slp",
	3820:  "scp",
	3821:  "pmcp",
	3822:  "acp-discovery",
	3823:  "acp-conduit",
	3824:  "acp-policy",
	3825:  "ffserver",
	3826:  "warmux",
	3827:  "netmpi",
	3828:  "neteh",
	3829:  "neteh-ext",
	3830:  "cernsysmgmtagt",
	3831:  "dvapps",
	3832:  "xxnetserver",
	3833:  "aipn-auth",
	3834:  "spectardata",
	3835:  "spectardb",
	3836:  "markem-dcp",
	3837:  "mkm-discovery",
	3838:  "sos",
	3839:  "amx-rms",
	3840:  "flirtmitmir",
	3842:  "nhci",
	3843:  "quest-agent",
	3844:  "rnm",
	3845:  "v-one-spp",
	3846:  "an-pcp",
	3847:  "msfw-control",
	3848:  "item",
	3849:  "spw-dnspreload",
	3850:  "qtms-bootstrap",
	3851:  "spectraport",
	3852:  "sse-app-config",
	3853:  "sscan",
	3854:  "stryker-com",
	3855:  "opentrac",
	3856:  "informer",
	3857:  "trap-port",
	3858:  "trap-port-mom",
	3859:  "nav-port",
	3860:  "sasp",
	3861:  "winshadow-hd",
	3862:  "giga-pocket",
	3863:  "asap-udp",
	3865:  "xpl",
	3866:  "dzdaemon",
	3867:  "dzoglserver",
	3869:  "ovsam-mgmt",
	3870:  "ovsam-d-agent",
	3871:  "avocent-adsap",
	3872:  "oem-agent",
	3873:  "fagordnc",
	3874:  "sixxsconfig",
	3875:  "pnbscada",
	3876:  "dl-agent",
	3877:  "xmpcr-interface",
	3878:  "fotogcad",
	3879:  "appss-lm",
	3880:  "igrs",
	3881:  "idac",
	3882:  "msdts1",
	3883:  "vrpn",
	3884:  "softrack-meter",
	3885:  "topflow-ssl",
	3886:  "nei-management",
	3887:  "ciphire-data",
	3888:  "ciphire-serv",
	3889:  "dandv-tester",
	3890:  "ndsconnect",
	3891:  "rtc-pm-port",
	3892:  "pcc-image-port",
	3893:  "cgi-starapi",
	3894:  "syam-agent",
	3895:  "syam-smc",
	3896:  "sdo-tls",
	3897:  "sdo-ssh",
	3898:  "senip",
	3899:  "itv-control",
	3900:  "udt-os",
	3901:  "nimsh",
	3902:  "nimaux",
	3903:  "charsetmgr",
	3904:  "omnilink-port",
	3905:  "mupdate",
	3906:  "topovista-data",
	3907:  "imoguia-port",
	3908:  "hppronetman",
	3909:  "surfcontrolcpa",
	3910:  "prnrequest",
	3911:  "prnstatus",
	3912:  "gbmt-stars",
	3913:  "listcrt-port",
	3914:  "listcrt-port-2",
	3915:  "agcat",
	3916:  "wysdmc",
	3917:  "aftmux",
	3918:  "pktcablemmcops",
	3919:  "hyperip",
	3920:  "exasoftport1",
	3921:  "herodotus-net",
	3922:  "sor-update",
	3923:  "symb-sb-port",
	3924:  "mpl-gprs-port",
	3925:  "zmp",
	3926:  "winport",
	3927:  "natdataservice",
	3928:  "netboot-pxe",
	3929:  "smauth-port",
	3930:  "syam-webserver",
	3931:  "msr-plugin-port",
	3932:  "dyn-site",
	3933:  "plbserve-port",
	3934:  "sunfm-port",
	3935:  "sdp-portmapper",
	3936:  "mailprox",
	3937:  "dvbservdsc",
	3938:  "dbcontrol-agent",
	3939:  "aamp",
	3940:  "xecp-node",
	3941:  "homeportal-web",
	3942:  "srdp",
	3943:  "tig",
	3944:  "sops",
	3945:  "emcads",
	3946:  "backupedge",
	3947:  "ccp",
	3948:  "apdap",
	3949:  "drip",
	3950:  "namemunge",
	3951:  "pwgippfax",
	3952:  "i3-sessionmgr",
	3953:  "xmlink-connect",
	3954:  "adrep",
	3955:  "p2pcommunity",
	3956:  "gvcp",
	3957:  "mqe-broker",
	3958:  "mqe-agent",
	3959:  "treehopper",
	3960:  "bess",
	3961:  "proaxess",
	3962:  "sbi-agent",
	3963:  "thrp",
	3964:  "sasggprs",
	3965:  "ati-ip-to-ncpe",
	3966:  "bflckmgr",
	3967:  "ppsms",
	3968:  "ianywhere-dbns",
	3969:  "landmarks",
	3970:  "lanrevagent",
	3971:  "lanrevserver",
	3972:  "iconp",
	3973:  "progistics",
	3974:  "citysearch",
	3975:  "airshot",
	3976:  "opswagent",
	3977:  "opswmanager",
	3978:  "secure-cfg-svr",
	3979:  "smwan",
	3980:  "acms",
	3981:  "starfish",
	3982:  "eis",
	3983:  "eisp",
	3984:  "mapper-nodemgr",
	3985:  "mapper-mapethd",
	3986:  "mapper-ws-ethd",
	3987:  "centerline",
	3988:  "dcs-config",
	3989:  "bv-queryengine",
	3990:  "bv-is",
	3991:  "bv-smcsrv",
	3992:  "bv-ds",
	3993:  "bv-agent",
	3995:  "iss-mgmt-ssl",
	3996:  "abcsoftware",
	3997:  "agentsease-db",
	3998:  "dnx",
	3999:  "nvcnet",
	4000:  "terabase",
	4001:  "newoak",
	4002:  "pxc-spvr-ft",
	4003:  "pxc-splr-ft",
	4004:  "pxc-roid",
	4005:  "pxc-pin",
	4006:  "pxc-spvr",
	4007:  "pxc-splr",
	4008:  "netcheque",
	4009:  "chimera-hwm",
	4010:  "samsung-unidex",
	4011:  "altserviceboot",
	4012:  "pda-gate",
	4013:  "acl-manager",
	4014:  "taiclock",
	4015:  "talarian-mcast1",
	4016:  "talarian-mcast2",
	4017:  "talarian-mcast3",
	4018:  "talarian-mcast4",
	4019:  "talarian-mcast5",
	4020:  "trap",
	4021:  "nexus-portal",
	4022:  "dnox",
	4023:  "esnm-zoning",
	4024:  "tnp1-port",
	4025:  "partimage",
	4026:  "as-debug",
	4027:  "bxp",
	4028:  "dtserver-port",
	4029:  "ip-qsig",
	4030:  "jdmn-port",
	4031:  "suucp",
	4032:  "vrts-auth-port",
	4033:  "sanavigator",
	4034:  "ubxd",
	4035:  "wap-push-http",
	4036:  "wap-push-https",
	4037:  "ravehd",
	4038:  "fazzt-ptp",
	4039:  "fazzt-admin",
	4040:  "yo-main",
	4041:  "houston",
	4042:  "ldxp",
	4043:  "nirp",
	4044:  "ltp",
	4045:  "npp",
	4046:  "acp-proto",
	4047:  "ctp-state",
	4049:  "wafs",
	4050:  "cisco-wafs",
	4051:  "cppdp",
	4052:  "interact",
	4053:  "ccu-comm-1",
	4054:  "ccu-comm-2",
	4055:  "ccu-comm-3",
	4056:  "lms",
	4057:  "wfm",
	4058:  "kingfisher",
	4059:  "dlms-cosem",
	4060:  "dsmeter-iatc",
	4061:  "ice-location",
	4062:  "ice-slocation",
	4063:  "ice-router",
	4064:  "ice-srouter",
	4065:  "avanti-cdp",
	4066:  "pmas",
	4067:  "idp",
	4068:  "ipfltbcst",
	4069:  "minger",
	4070:  "tripe",
	4071:  "aibkup",
	4072:  "zieto-sock",
	4073:  "iRAPP",
	4074:  "cequint-cityid",
	4075:  "perimlan",
	4076:  "seraph",
	4077:  "ascomalarm",
	4079:  "santools",
	4080:  "lorica-in",
	4081:  "lorica-in-sec",
	4082:  "lorica-out",
	4083:  "lorica-out-sec",
	4084:  "fortisphere-vm",
	4086:  "ftsync",
	4089:  "opencore",
	4090:  "omasgport",
	4091:  "ewinstaller",
	4092:  "ewdgs",
	4093:  "pvxpluscs",
	4094:  "sysrqd",
	4095:  "xtgui",
	4096:  "bre",
	4097:  "patrolview",
	4098:  "drmsfsd",
	4099:  "dpcp",
	4100:  "igo-incognito",
	4101:  "brlp-0",
	4102:  "brlp-1",
	4103:  "brlp-2",
	4104:  "brlp-3",
	4105:  "shofar",
	4106:  "synchronite",
	4107:  "j-ac",
	4108:  "accel",
	4109:  "izm",
	4110:  "g2tag",
	4111:  "xgrid",
	4112:  "apple-vpns-rp",
	4113:  "aipn-reg",
	4114:  "jomamqmonitor",
	4115:  "cds",
	4116:  "smartcard-tls",
	4117:  "hillrserv",
	4118:  "netscript",
	4119:  "assuria-slm",
	4121:  "e-builder",
	4122:  "fprams",
	4123:  "z-wave",
	4124:  "tigv2",
	4125:  "opsview-envoy",
	4126:  "ddrepl",
	4127:  "unikeypro",
	4128:  "nufw",
	4129:  "nuauth",
	4130:  "fronet",
	4131:  "stars",
	4132:  "nuts-dem",
	4133:  "nuts-bootp",
	4134:  "nifty-hmi",
	4135:  "cl-db-attach",
	4136:  "cl-db-request",
	4137:  "cl-db-remote",
	4138:  "nettest",
	4139:  "thrtx",
	4140:  "cedros-fds",
	4141:  "oirtgsvc",
	4142:  "oidocsvc",
	4143:  "oidsr",
	4145:  "vvr-control",
	4146:  "tgcconnect",
	4147:  "vrxpservman",
	4148:  "hhb-handheld",
	4149:  "agslb",
	4150:  "PowerAlert-nsa",
	4151:  "menandmice-noh",
	4152:  "idig-mux",
	4153:  "mbl-battd",
	4154:  "atlinks",
	4155:  "bzr",
	4156:  "stat-results",
	4157:  "stat-scanner",
	4158:  "stat-cc",
	4159:  "nss",
	4160:  "jini-discovery",
	4161:  "omscontact",
	4162:  "omstopology",
	4163:  "silverpeakpeer",
	4164:  "silverpeakcomm",
	4165:  "altcp",
	4166:  "joost",
	4167:  "ddgn",
	4168:  "pslicser",
	4169:  "iadt-disc",
	4172:  "pcoip",
	4173:  "mma-discovery",
	4174:  "sm-disc",
	4177:  "wello",
	4178:  "storman",
	4179:  "MaxumSP",
	4180:  "httpx",
	4181:  "macbak",
	4182:  "pcptcpservice",
	4183:  "cyborgnet",
	4184:  "universe-suite",
	4185:  "wcpp",
	4188:  "vatata",
	4191:  "dsmipv6",
	4192:  "azeti-bd",
	4197:  "hctl",
	4199:  "eims-admin",
	4300:  "corelccam",
	4301:  "d-data",
	4302:  "d-data-control",
	4303:  "srcp",
	4304:  "owserver",
	4305:  "batman",
	4306:  "pinghgl",
	4307:  "trueconf",
	4308:  "compx-lockview",
	4309:  "dserver",
	4310:  "mirrtex",
	4320:  "fdt-rcatp",
	4321:  "rwhois",
	4322:  "trim-event",
	4323:  "trim-ice",
	4325:  "geognosisman",
	4326:  "geognosis",
	4327:  "jaxer-web",
	4328:  "jaxer-manager",
	4333:  "ahsp",
	4340:  "gaia",
	4341:  "lisp-data",
	4342:  "lisp-control",
	4343:  "unicall",
	4344:  "vinainstall",
	4345:  "m4-network-as",
	4346:  "elanlm",
	4347:  "lansurveyor",
	4348:  "itose",
	4349:  "fsportmap",
	4350:  "net-device",
	4351:  "plcy-net-svcs",
	4352:  "pjlink",
	4353:  "f5-iquery",
	4354:  "qsnet-trans",
	4355:  "qsnet-workst",
	4356:  "qsnet-assist",
	4357:  "qsnet-cond",
	4358:  "qsnet-nucl",
	4359:  "omabcastltkm",
	4361:  "nacnl",
	4362:  "afore-vdp-disc",
	4366:  "shadowstream",
	4368:  "wxbrief",
	4369:  "epmd",
	4370:  "elpro-tunnel",
	4371:  "l2c-disc",
	4372:  "l2c-data",
	4373:  "remctl",
	4375:  "tolteces",
	4376:  "bip",
	4377:  "cp-spxsvr",
	4378:  "cp-spxdpy",
	4379:  "ctdb",
	4389:  "xandros-cms",
	4390:  "wiegand",
	4394:  "apwi-disc",
	4395:  "omnivisionesx",
	4400:  "ds-srv",
	4401:  "ds-srvr",
	4402:  "ds-clnt",
	4403:  "ds-user",
	4404:  "ds-admin",
	4405:  "ds-mail",
	4406:  "ds-slp",
	4412:  "smallchat",
	4413:  "avi-nms-disc",
	4416:  "pjj-player-disc",
	4418:  "axysbridge",
	4420:  "nvm-express",
	4425:  "netrockey6",
	4426:  "beacon-port-2",
	4430:  "rsqlserver",
	4432:  "l-acoustics",
	4441:  "netblox",
	4442:  "saris",
	4443:  "pharos",
	4444:  "krb524",
	4445:  "upnotifyp",
	4446:  "n1-fwp",
	4447:  "n1-rmgmt",
	4448:  "asc-slmd",
	4449:  "privatewire",
	4450:  "camp",
	4451:  "ctisystemmsg",
	4452:  "ctiprogramload",
	4453:  "nssalertmgr",
	4454:  "nssagentmgr",
	4455:  "prchat-user",
	4456:  "prchat-server",
	4457:  "prRegister",
	4458:  "mcp",
	4484:  "hpssmgmt",
	4486:  "icms",
	4488:  "awacs-ice",
	4500:  "ipsec-nat-t",
	4534:  "armagetronad",
	4535:  "ehs",
	4536:  "ehs-ssl",
	4537:  "wssauthsvc",
	4538:  "swx-gate",
	4545:  "worldscores",
	4546:  "sf-lm",
	4547:  "lanner-lm",
	4548:  "synchromesh",
	4549:  "aegate",
	4550:  "gds-adppiw-db",
	4551:  "ieee-mih",
	4552:  "menandmice-mon",
	4554:  "msfrs",
	4555:  "rsip",
	4556:  "dtn-bundle",
	4557:  "mtcevrunqss",
	4558:  "mtcevrunqman",
	4559:  "hylafax",
	4566:  "kwtc",
	4567:  "tram",
	4568:  "bmc-reporting",
	4569:  "iax",
	4591:  "l3t-at-an",
	4592:  "hrpd-ith-at-an",
	4593:  "ipt-anri-anri",
	4594:  "ias-session",
	4595:  "ias-paging",
	4596:  "ias-neighbor",
	4597:  "a21-an-1xbs",
	4598:  "a16-an-an",
	4599:  "a17-an-an",
	4600:  "piranha1",
	4601:  "piranha2",
	4621:  "ventoso",
	4658:  "playsta2-app",
	4659:  "playsta2-lob",
	4660:  "smaclmgr",
	4661:  "kar2ouche",
	4662:  "oms",
	4663:  "noteit",
	4664:  "ems",
	4665:  "contclientms",
	4666:  "eportcomm",
	4667:  "mmacomm",
	4668:  "mmaeds",
	4669:  "eportcommdata",
	4670:  "light",
	4671:  "acter",
	4672:  "rfa",
	4673:  "cxws",
	4674:  "appiq-mgmt",
	4675:  "dhct-status",
	4676:  "dhct-alerts",
	4677:  "bcs",
	4678:  "traversal",
	4679:  "mgesupervision",
	4680:  "mgemanagement",
	4681:  "parliant",
	4682:  "finisar",
	4683:  "spike",
	4684:  "rfid-rp1",
	4685:  "autopac",
	4686:  "msp-os",
	4687:  "nst",
	4688:  "mobile-p2p",
	4689:  "altovacentral",
	4690:  "prelude",
	4691:  "mtn",
	4692:  "conspiracy",
	4700:  "netxms-agent",
	4701:  "netxms-mgmt",
	4702:  "netxms-sync",
	4711:  "trinity-dist",
	4725:  "truckstar",
	4726:  "a26-fap-fgw",
	4727:  "fcis-disc",
	4728:  "capmux",
	4729:  "gsmtap",
	4730:  "gearman",
	4732:  "ohmtrigger",
	4737:  "ipdr-sp",
	4738:  "solera-lpn",
	4739:  "ipfix",
	4740:  "ipfixs",
	4741:  "lumimgrd",
	4742:  "sicct-sdp",
	4743:  "openhpid",
	4744:  "ifsp",
	4745:  "fmp",
	4746:  "intelliadm-disc",
	4747:  "buschtrommel",
	4749:  "profilemac",
	4750:  "ssad",
	4751:  "spocp",
	4752:  "snap",
	4753:  "simon-disc",
	4754:  "gre-in-udp",
	4755:  "gre-udp-dtls",
	4784:  "bfd-multi-ctl",
	4785:  "cncp",
	4789:  "vxlan",
	4790:  "vxlan-gpe",
	4791:  "roce",
	4800:  "iims",
	4801:  "iwec",
	4802:  "ilss",
	4803:  "notateit-disc",
	4804:  "aja-ntv4-disc",
	4827:  "htcp",
	4837:  "varadero-0",
	4838:  "varadero-1",
	4839:  "varadero-2",
	4840:  "opcua-udp",
	4841:  "quosa",
	4842:  "gw-asv",
	4843:  "opcua-tls",
	4844:  "gw-log",
	4845:  "wcr-remlib",
	4846:  "contamac-icm",
	4847:  "wfc",
	4848:  "appserv-http",
	4849:  "appserv-https",
	4850:  "sun-as-nodeagt",
	4851:  "derby-repli",
	4867:  "unify-debug",
	4868:  "phrelay",
	4869:  "phrelaydbg",
	4870:  "cc-tracking",
	4871:  "wired",
	4876:  "tritium-can",
	4877:  "lmcs",
	4878:  "inst-discovery",
	4881:  "socp-t",
	4882:  "socp-c",
	4884:  "hivestor",
	4885:  "abbs",
	4894:  "lyskom",
	4899:  "radmin-port",
	4900:  "hfcs",
	4914:  "bones",
	4936:  "an-signaling",
	4937:  "atsc-mh-ssc",
	4940:  "eq-office-4940",
	4941:  "eq-office-4941",
	4942:  "eq-office-4942",
	4949:  "munin",
	4950:  "sybasesrvmon",
	4951:  "pwgwims",
	4952:  "sagxtsds",
	4969:  "ccss-qmm",
	4970:  "ccss-qsm",
	4980:  "ctxs-vpp",
	4986:  "mrip",
	4987:  "smar-se-port1",
	4988:  "smar-se-port2",
	4989:  "parallel",
	4990:  "busycal",
	4991:  "vrt",
	4999:  "hfcs-manager",
	5000:  "commplex-main",
	5001:  "commplex-link",
	5002:  "rfe",
	5003:  "fmpro-internal",
	5004:  "avt-profile-1",
	5005:  "avt-profile-2",
	5006:  "wsm-server",
	5007:  "wsm-server-ssl",
	5008:  "synapsis-edge",
	5009:  "winfs",
	5010:  "telelpathstart",
	5011:  "telelpathattack",
	5012:  "nsp",
	5013:  "fmpro-v6",
	5014:  "onpsocket",
	5020:  "zenginkyo-1",
	5021:  "zenginkyo-2",
	5022:  "mice",
	5023:  "htuilsrv",
	5024:  "scpi-telnet",
	5025:  "scpi-raw",
	5026:  "strexec-d",
	5027:  "strexec-s",
	5029:  "infobright",
	5030:  "surfpass",
	5031:  "dmp",
	5042:  "asnaacceler8db",
	5043:  "swxadmin",
	5044:  "lxi-evntsvc",
	5046:  "vpm-udp",
	5047:  "iscape",
	5049:  "ivocalize",
	5050:  "mmcc",
	5051:  "ita-agent",
	5052:  "ita-manager",
	5053:  "rlm-disc",
	5055:  "unot",
	5056:  "intecom-ps1",
	5057:  "intecom-ps2",
	5058:  "locus-disc",
	5059:  "sds",
	5060:  "sip",
	5061:  "sips",
	5062:  "na-localise",
	5064:  "ca-1",
	5065:  "ca-2",
	5066:  "stanag-5066",
	5067:  "authentx",
	5069:  "i-net-2000-npr",
	5070:  "vtsas",
	5071:  "powerschool",
	5072:  "ayiya",
	5073:  "tag-pm",
	5074:  "alesquery",
	5078:  "pixelpusher",
	5079:  "cp-spxrpts",
	5080:  "onscreen",
	5081:  "sdl-ets",
	5082:  "qcp",
	5083:  "qfp",
	5084:  "llrp",
	5085:  "encrypted-llrp",
	5092:  "magpie",
	5093:  "sentinel-lm",
	5094:  "hart-ip",
	5099:  "sentlm-srv2srv",
	5100:  "socalia",
	5101:  "talarian-udp",
	5102:  "oms-nonsecure",
	5104:  "tinymessage",
	5105:  "hughes-ap",
	5111:  "taep-as-svc",
	5112:  "pm-cmdsvr",
	5116:  "emb-proj-cmd",
	5120:  "barracuda-bbs",
	5133:  "nbt-pc",
	5136:  "minotaur-sa",
	5137:  "ctsd",
	5145:  "rmonitor-secure",
	5150:  "atmp",
	5151:  "esri-sde",
	5152:  "sde-discovery",
	5154:  "bzflag",
	5155:  "asctrl-agent",
	5164:  "vpa-disc",
	5165:  "ife-icorp",
	5166:  "winpcs",
	5167:  "scte104",
	5168:  "scte30",
	5190:  "aol",
	5191:  "aol-1",
	5192:  "aol-2",
	5193:  "aol-3",
	5200:  "targus-getdata",
	5201:  "targus-getdata1",
	5202:  "targus-getdata2",
	5203:  "targus-getdata3",
	5223:  "hpvirtgrp",
	5224:  "hpvirtctrl",
	5225:  "hp-server",
	5226:  "hp-status",
	5227:  "perfd",
	5234:  "eenet",
	5235:  "galaxy-network",
	5236:  "padl2sim",
	5237:  "mnet-discovery",
	5245:  "downtools-disc",
	5246:  "capwap-control",
	5247:  "capwap-data",
	5248:  "caacws",
	5249:  "caaclang2",
	5250:  "soagateway",
	5251:  "caevms",
	5252:  "movaz-ssc",
	5264:  "3com-njack-1",
	5265:  "3com-njack-2",
	5270:  "cartographerxmp",
	5271:  "cuelink-disc",
	5272:  "pk",
	5282:  "transmit-port",
	5298:  "presence",
	5299:  "nlg-data",
	5300:  "hacl-hb",
	5301:  "hacl-gs",
	5302:  "hacl-cfg",
	5303:  "hacl-probe",
	5304:  "hacl-local",
	5305:  "hacl-test",
	5306:  "sun-mc-grp",
	5307:  "sco-aip",
	5308:  "cfengine",
	5309:  "jprinter",
	5310:  "outlaws",
	5312:  "permabit-cs",
	5313:  "rrdp",
	5314:  "opalis-rbt-ipc",
	5315:  "hacl-poll",
	5343:  "kfserver",
	5344:  "xkotodrcp",
	5349:  "stuns",
	5350:  "pcp-multicast",
	5351:  "pcp",
	5352:  "dns-llq",
	5353:  "mdns",
	5354:  "mdnsresponder",
	5355:  "llmnr",
	5356:  "ms-smlbiz",
	5357:  "wsdapi",
	5358:  "wsdapi-s",
	5359:  "ms-alerter",
	5360:  "ms-sideshow",
	5361:  "ms-s-sideshow",
	5362:  "serverwsd2",
	5363:  "net-projection",
	5364:  "kdnet",
	5397:  "stresstester",
	5398:  "elektron-admin",
	5399:  "securitychase",
	5400:  "excerpt",
	5401:  "excerpts",
	5402:  "mftp",
	5403:  "hpoms-ci-lstn",
	5404:  "hpoms-dps-lstn",
	5405:  "netsupport",
	5406:  "systemics-sox",
	5407:  "foresyte-clear",
	5408:  "foresyte-sec",
	5409:  "salient-dtasrv",
	5410:  "salient-usrmgr",
	5411:  "actnet",
	5412:  "continuus",
	5413:  "wwiotalk",
	5414:  "statusd",
	5415:  "ns-server",
	5416:  "sns-gateway",
	5417:  "sns-agent",
	5418:  "mcntp",
	5419:  "dj-ice",
	5420:  "cylink-c",
	5421:  "netsupport2",
	5422:  "salient-mux",
	5423:  "virtualuser",
	5424:  "beyond-remote",
	5425:  "br-channel",
	5426:  "devbasic",
	5427:  "sco-peer-tta",
	5428:  "telaconsole",
	5429:  "base",
	5430:  "radec-corp",
	5431:  "park-agent",
	5432:  "postgresql",
	5433:  "pyrrho",
	5434:  "sgi-arrayd",
	5435:  "sceanics",
	5436:  "pmip6-cntl",
	5437:  "pmip6-data",
	5443:  "spss",
	5450:  "tiepie-disc",
	5453:  "surebox",
	5454:  "apc-5454",
	5455:  "apc-5455",
	5456:  "apc-5456",
	5461:  "silkmeter",
	5462:  "ttl-publisher",
	5463:  "ttlpriceproxy",
	5464:  "quailnet",
	5465:  "netops-broker",
	5474:  "apsolab-rpc",
	5500:  "fcp-addr-srvr1",
	5501:  "fcp-addr-srvr2",
	5502:  "fcp-srvr-inst1",
	5503:  "fcp-srvr-inst2",
	5504:  "fcp-cics-gw1",
	5505:  "checkoutdb",
	5506:  "amc",
	5553:  "sgi-eventmond",
	5554:  "sgi-esphttp",
	5555:  "personal-agent",
	5556:  "freeciv",
	5567:  "dof-dps-mc-sec",
	5568:  "sdt",
	5569:  "rdmnet-device",
	5573:  "sdmmp",
	5580:  "tmosms0",
	5581:  "tmosms1",
	5582:  "fac-restore",
	5583:  "tmo-icon-sync",
	5584:  "bis-web",
	5585:  "bis-sync",
	5597:  "ininmessaging",
	5598:  "mctfeed",
	5599:  "esinstall",
	5600:  "esmmanager",
	5601:  "esmagent",
	5602:  "a1-msc",
	5603:  "a1-bs",
	5604:  "a3-sdunode",
	5605:  "a4-sdunode",
	5627:  "ninaf",
	5628:  "htrust",
	5629:  "symantec-sfdb",
	5630:  "precise-comm",
	5631:  "pcanywheredata",
	5632:  "pcanywherestat",
	5633:  "beorl",
	5634:  "xprtld",
	5670:  "zre-disc",
	5671:  "amqps",
	5672:  "amqp",
	5673:  "jms",
	5674:  "hyperscsi-port",
	5675:  "v5ua",
	5676:  "raadmin",
	5677:  "questdb2-lnchr",
	5678:  "rrac",
	5679:  "dccm",
	5680:  "auriga-router",
	5681:  "ncxcp",
	5682:  "brightcore",
	5683:  "coap",
	5684:  "coaps",
	5687:  "gog-multiplayer",
	5688:  "ggz",
	5689:  "qmvideo",
	5713:  "proshareaudio",
	5714:  "prosharevideo",
	5715:  "prosharedata",
	5716:  "prosharerequest",
	5717:  "prosharenotify",
	5718:  "dpm",
	5719:  "dpm-agent",
	5720:  "ms-licensing",
	5721:  "dtpt",
	5722:  "msdfsr",
	5723:  "omhs",
	5724:  "omsdk",
	5728:  "io-dist-group",
	5729:  "openmail",
	5730:  "unieng",
	5741:  "ida-discover1",
	5742:  "ida-discover2",
	5743:  "watchdoc-pod",
	5744:  "watchdoc",
	5745:  "fcopy-server",
	5746:  "fcopys-server",
	5747:  "tunatic",
	5748:  "tunalyzer",
	5750:  "rscd",
	5755:  "openmailg",
	5757:  "x500ms",
	5766:  "openmailns",
	5767:  "s-openmail",
	5768:  "openmailpxy",
	5769:  "spramsca",
	5770:  "spramsd",
	5771:  "netagent",
	5777:  "dali-port",
	5781:  "3par-evts",
	5782:  "3par-mgmt",
	5783:  "3par-mgmt-ssl",
	5784:  "ibar",
	5785:  "3par-rcopy",
	5786:  "cisco-redu",
	5787:  "waascluster",
	5793:  "xtreamx",
	5794:  "spdp",
	5813:  "icmpd",
	5814:  "spt-automation",
	5859:  "wherehoo",
	5863:  "ppsuitemsg",
	5900:  "rfb",
	5910:  "cm",
	5911:  "cpdlc",
	5912:  "fis",
	5913:  "ads-c",
	5963:  "indy",
	5968:  "mppolicy-v5",
	5969:  "mppolicy-mgr",
	5984:  "couchdb",
	5985:  "wsman",
	5986:  "wsmans",
	5987:  "wbem-rmi",
	5988:  "wbem-http",
	5989:  "wbem-https",
	5990:  "wbem-exp-https",
	5991:  "nuxsl",
	5992:  "consul-insight",
	5999:  "cvsup",
	6064:  "ndl-ahp-svc",
	6065:  "winpharaoh",
	6066:  "ewctsp",
	6069:  "trip",
	6070:  "messageasap",
	6071:  "ssdtp",
	6072:  "diagnose-proc",
	6073:  "directplay8",
	6074:  "max",
	6080:  "gue",
	6081:  "geneve",
	6082:  "p25cai",
	6083:  "miami-bcast",
	6085:  "konspire2b",
	6086:  "pdtp",
	6087:  "ldss",
	6088:  "doglms-notify",
	6100:  "synchronet-db",
	6101:  "synchronet-rtc",
	6102:  "synchronet-upd",
	6103:  "rets",
	6104:  "dbdb",
	6105:  "primaserver",
	6106:  "mpsserver",
	6107:  "etc-control",
	6108:  "sercomm-scadmin",
	6109:  "globecast-id",
	6110:  "softcm",
	6111:  "spc",
	6112:  "dtspcd",
	6118:  "tipc",
	6122:  "bex-webadmin",
	6123:  "backup-express",
	6124:  "pnbs",
	6133:  "nbt-wol",
	6140:  "pulsonixnls",
	6141:  "meta-corp",
	6142:  "aspentec-lm",
	6143:  "watershed-lm",
	6144:  "statsci1-lm",
	6145:  "statsci2-lm",
	6146:  "lonewolf-lm",
	6147:  "montage-lm",
	6148:  "ricardo-lm",
	6149:  "tal-pod",
	6160:  "ecmp-data",
	6161:  "patrol-ism",
	6162:  "patrol-coll",
	6163:  "pscribe",
	6200:  "lm-x",
	6201:  "thermo-calc",
	6209:  "qmtps",
	6222:  "radmind",
	6241:  "jeol-nsddp-1",
	6242:  "jeol-nsddp-2",
	6243:  "jeol-nsddp-3",
	6244:  "jeol-nsddp-4",
	6251:  "tl1-raw-ssl",
	6252:  "tl1-ssh",
	6253:  "crip",
	6268:  "grid",
	6269:  "grid-alt",
	6300:  "bmc-grx",
	6301:  "bmc-ctd-ldap",
	6306:  "ufmp",
	6315:  "scup-disc",
	6316:  "abb-escp",
	6317:  "nav-data",
	6320:  "repsvc",
	6321:  "emp-server1",
	6322:  "emp-server2",
	6324:  "hrd-ns-disc",
	6343:  "sflow",
	6346:  "gnutella-svc",
	6347:  "gnutella-rtr",
	6350:  "adap",
	6355:  "pmcs",
	6360:  "metaedit-mu",
	6363:  "ndn",
	6370:  "metaedit-se",
	6382:  "metatude-mds",
	6389:  "clariion-evr01",
	6390:  "metaedit-ws",
	6417:  "faxcomservice",
	6419:  "svdrp-disc",
	6420:  "nim-vdrshell",
	6421:  "nim-wan",
	6443:  "sun-sr-https",
	6444:  "sge-qmaster",
	6445:  "sge-execd",
	6446:  "mysql-proxy",
	6455:  "skip-cert-recv",
	6456:  "skip-cert-send",
	6464:  "ieee11073-20701",
	6471:  "lvision-lm",
	6480:  "sun-sr-http",
	6481:  "servicetags",
	6482:  "ldoms-mgmt",
	6483:  "SunVTS-RMI",
	6484:  "sun-sr-jms",
	6485:  "sun-sr-iiop",
	6486:  "sun-sr-iiops",
	6487:  "sun-sr-iiop-aut",
	6488:  "sun-sr-jmx",
	6489:  "sun-sr-admin",
	6500:  "boks",
	6501:  "boks-servc",
	6502:  "boks-servm",
	6503:  "boks-clntd",
	6505:  "badm-priv",
	6506:  "badm-pub",
	6507:  "bdir-priv",
	6508:  "bdir-pub",
	6509:  "mgcs-mfp-port",
	6510:  "mcer-port",
	6511:  "dccp-udp",
	6514:  "syslog-tls",
	6515:  "elipse-rec",
	6543:  "lds-distrib",
	6544:  "lds-dump",
	6547:  "apc-6547",
	6548:  "apc-6548",
	6549:  "apc-6549",
	6550:  "fg-sysupdate",
	6551:  "sum",
	6558:  "xdsxdm",
	6566:  "sane-port",
	6568:  "rp-reputation",
	6579:  "affiliate",
	6580:  "parsec-master",
	6581:  "parsec-peer",
	6582:  "parsec-game",
	6583:  "joaJewelSuite",
	6619:  "odette-ftps",
	6620:  "kftp-data",
	6621:  "kftp",
	6622:  "mcftp",
	6623:  "ktelnet",
	6626:  "wago-service",
	6627:  "nexgen",
	6628:  "afesc-mc",
	6629:  "nexgen-aux",
	6633:  "cisco-vpath-tun",
	6634:  "mpls-pm",
	6635:  "mpls-udp",
	6636:  "mpls-udp-dtls",
	6653:  "openflow",
	6657:  "palcom-disc",
	6670:  "vocaltec-gold",
	6671:  "p4p-portal",
	6672:  "vision-server",
	6673:  "vision-elmd",
	6678:  "vfbp-disc",
	6679:  "osaut",
	6689:  "tsa",
	6696:  "babel",
	6701:  "kti-icad-srvr",
	6702:  "e-design-net",
	6703:  "e-design-web",
	6714:  "ibprotocol",
	6715:  "fibotrader-com",
	6767:  "bmc-perf-agent",
	6768:  "bmc-perf-mgrd",
	6769:  "adi-gxp-srvprt",
	6770:  "plysrv-http",
	6771:  "plysrv-https",
	6784:  "bfd-lag",
	6785:  "dgpf-exchg",
	6786:  "smc-jmx",
	6787:  "smc-admin",
	6788:  "smc-http",
	6790:  "hnmp",
	6791:  "hnm",
	6801:  "acnet",
	6831:  "ambit-lm",
	6841:  "netmo-default",
	6842:  "netmo-http",
	6850:  "iccrushmore",
	6868:  "acctopus-st",
	6888:  "muse",
	6935:  "ethoscan",
	6936:  "xsmsvc",
	6946:  "bioserver",
	6951:  "otlp",
	6961:  "jmact3",
	6962:  "jmevt2",
	6963:  "swismgr1",
	6964:  "swismgr2",
	6965:  "swistrap",
	6966:  "swispol",
	6969:  "acmsoda",
	6997:  "MobilitySrv",
	6998:  "iatp-highpri",
	6999:  "iatp-normalpri",
	7000:  "afs3-fileserver",
	7001:  "afs3-callback",
	7002:  "afs3-prserver",
	7003:  "afs3-vlserver",
	7004:  "afs3-kaserver",
	7005:  "afs3-volser",
	7006:  "afs3-errors",
	7007:  "afs3-bos",
	7008:  "afs3-update",
	7009:  "afs3-rmtsys",
	7010:  "ups-onlinet",
	7011:  "talon-disc",
	7012:  "talon-engine",
	7013:  "microtalon-dis",
	7014:  "microtalon-com",
	7015:  "talon-webserver",
	7016:  "spg",
	7017:  "grasp",
	7019:  "doceri-view",
	7020:  "dpserve",
	7021:  "dpserveadmin",
	7022:  "ctdp",
	7023:  "ct2nmcs",
	7024:  "vmsvc",
	7025:  "vmsvc-2",
	7030:  "op-probe",
	7040:  "quest-disc",
	7070:  "arcp",
	7071:  "iwg1",
	7080:  "empowerid",
	7088:  "zixi-transport",
	7095:  "jdp-disc",
	7099:  "lazy-ptop",
	7100:  "font-service",
	7101:  "elcn",
	7107:  "aes-x170",
	7121:  "virprot-lm",
	7128:  "scenidm",
	7129:  "scenccs",
	7161:  "cabsm-comm",
	7162:  "caistoragemgr",
	7163:  "cacsambroker",
	7164:  "fsr",
	7165:  "doc-server",
	7166:  "aruba-server",
	7169:  "ccag-pib",
	7170:  "nsrp",
	7171:  "drm-production",
	7174:  "clutild",
	7181:  "janus-disc",
	7200:  "fodms",
	7201:  "dlip",
	7227:  "ramp",
	7235:  "aspcoordination",
	7244:  "frc-hicp-disc",
	7262:  "cnap",
	7272:  "watchme-7272",
	7273:  "oma-rlp",
	7274:  "oma-rlp-s",
	7275:  "oma-ulp",
	7276:  "oma-ilp",
	7277:  "oma-ilp-s",
	7278:  "oma-dcdocbs",
	7279:  "ctxlic",
	7280:  "itactionserver1",
	7281:  "itactionserver2",
	7282:  "mzca-alert",
	7365:  "lcm-server",
	7391:  "mindfilesys",
	7392:  "mrssrendezvous",
	7393:  "nfoldman",
	7394:  "fse",
	7395:  "winqedit",
	7397:  "hexarc",
	7400:  "rtps-discovery",
	7401:  "rtps-dd-ut",
	7402:  "rtps-dd-mt",
	7410:  "ionixnetmon",
	7411:  "daqstream",
	7421:  "mtportmon",
	7426:  "pmdmgr",
	7427:  "oveadmgr",
	7428:  "ovladmgr",
	7429:  "opi-sock",
	7430:  "xmpv7",
	7431:  "pmd",
	7437:  "faximum",
	7443:  "oracleas-https",
	7473:  "rise",
	7491:  "telops-lmd",
	7500:  "silhouette",
	7501:  "ovbus",
	7510:  "ovhpas",
	7511:  "pafec-lm",
	7542:  "saratoga",
	7543:  "atul",
	7544:  "nta-ds",
	7545:  "nta-us",
	7546:  "cfs",
	7547:  "cwmp",
	7548:  "tidp",
	7549:  "nls-tl",
	7550:  "cloudsignaling",
	7560:  "sncp",
	7566:  "vsi-omega",
	7570:  "aries-kfinder",
	7574:  "coherence-disc",
	7588:  "sun-lm",
	7606:  "mipi-debug",
	7624:  "indi",
	7627:  "soap-http",
	7628:  "zen-pawn",
	7629:  "xdas",
	7633:  "pmdfmgt",
	7648:  "cuseeme",
	7674:  "imqtunnels",
	7675:  "imqtunnel",
	7676:  "imqbrokerd",
	7677:  "sun-user-https",
	7680:  "pando-pub",
	7689:  "collaber",
	7697:  "klio",
	7707:  "sync-em7",
	7708:  "scinet",
	7720:  "medimageportal",
	7724:  "nsdeepfreezectl",
	7725:  "nitrogen",
	7726:  "freezexservice",
	7727:  "trident-data",
	7728:  "osvr",
	7734:  "smip",
	7738:  "aiagent",
	7741:  "scriptview",
	7743:  "sstp-1",
	7744:  "raqmon-pdu",
	7747:  "prgp",
	7777:  "cbt",
	7778:  "interwise",
	7779:  "vstat",
	7781:  "accu-lmgr",
	7784:  "s-bfd",
	7786:  "minivend",
	7787:  "popup-reminders",
	7789:  "office-tools",
	7794:  "q3ade",
	7797:  "pnet-conn",
	7798:  "pnet-enc",
	7799:  "altbsdp",
	7800:  "asr",
	7801:  "ssp-client",
	7802:  "vns-tp",
	7810:  "rbt-wanopt",
	7845:  "apc-7845",
	7846:  "apc-7846",
	7872:  "mipv6tls",
	7880:  "pss",
	7887:  "ubroker",
	7900:  "mevent",
	7901:  "tnos-sp",
	7902:  "tnos-dp",
	7903:  "tnos-dps",
	7913:  "qo-secure",
	7932:  "t2-drm",
	7933:  "t2-brm",
	7962:  "generalsync",
	7967:  "supercell",
	7979:  "micromuse-ncps",
	7980:  "quest-vista",
	7982:  "sossd-disc",
	7998:  "usicontentpush",
	7999:  "irdmi2",
	8000:  "irdmi",
	8001:  "vcom-tunnel",
	8002:  "teradataordbms",
	8003:  "mcreport",
	8005:  "mxi",
	8006:  "wpl-disc",
	8007:  "warppipe",
	8008:  "http-alt",
	8019:  "qbdb",
	8020:  "intu-ec-svcdisc",
	8021:  "intu-ec-client",
	8022:  "oa-system",
	8025:  "ca-audit-da",
	8026:  "ca-audit-ds",
	8032:  "pro-ed",
	8033:  "mindprint",
	8034:  "vantronix-mgmt",
	8040:  "ampify",
	8041:  "enguity-xccetp",
	8052:  "senomix01",
	8053:  "senomix02",
	8054:  "senomix03",
	8055:  "senomix04",
	8056:  "senomix05",
	8057:  "senomix06",
	8058:  "senomix07",
	8059:  "senomix08",
	8060:  "aero",
	8074:  "gadugadu",
	8080:  "http-alt",
	8081:  "sunproxyadmin",
	8082:  "us-cli",
	8083:  "us-srv",
	8086:  "d-s-n",
	8087:  "simplifymedia",
	8088:  "radan-http",
	8097:  "sac",
	8100:  "xprint-server",
	8115:  "mtl8000-matrix",
	8116:  "cp-cluster",
	8118:  "privoxy",
	8121:  "apollo-data",
	8122:  "apollo-admin",
	8128:  "paycash-online",
	8129:  "paycash-wbp",
	8130:  "indigo-vrmi",
	8131:  "indigo-vbcp",
	8132:  "dbabble",
	8148:  "isdd",
	8149:  "eor-game",
	8160:  "patrol",
	8161:  "patrol-snmp",
	8182:  "vmware-fdm",
	8184:  "itach",
	8192:  "spytechphone",
	8194:  "blp1",
	8195:  "blp2",
	8199:  "vvr-data",
	8200:  "trivnet1",
	8201:  "trivnet2",
	8202:  "aesop",
	8204:  "lm-perfworks",
	8205:  "lm-instmgr",
	8206:  "lm-dta",
	8207:  "lm-sserver",
	8208:  "lm-webwatcher",
	8230:  "rexecj",
	8231:  "hncp-udp-port",
	8232:  "hncp-dtls-port",
	8243:  "synapse-nhttps",
	8276:  "pando-sec",
	8280:  "synapse-nhttp",
	8282:  "libelle-disc",
	8292:  "blp3",
	8294:  "blp4",
	8300:  "tmi",
	8301:  "amberon",
	8320:  "tnp-discover",
	8321:  "tnp",
	8322:  "garmin-marine",
	8351:  "server-find",
	8376:  "cruise-enum",
	8377:  "cruise-swroute",
	8378:  "cruise-config",
	8379:  "cruise-diags",
	8380:  "cruise-update",
	8383:  "m2mservices",
	8384:  "marathontp",
	8400:  "cvd",
	8401:  "sabarsd",
	8402:  "abarsd",
	8403:  "admind",
	8416:  "espeech",
	8417:  "espeech-rtp",
	8442:  "cybro-a-bus",
	8443:  "pcsync-https",
	8444:  "pcsync-http",
	8445:  "copy-disc",
	8450:  "npmp",
	8472:  "otv",
	8473:  "vp2p",
	8474:  "noteshare",
	8500:  "fmtp",
	8501:  "cmtp-av",
	8503:  "lsp-self-ping",
	8554:  "rtsp-alt",
	8555:  "d-fence",
	8567:  "dof-tunnel",
	8600:  "asterix",
	8609:  "canon-cpp-disc",
	8610:  "canon-mfnp",
	8611:  "canon-bjnp1",
	8612:  "canon-bjnp2",
	8613:  "canon-bjnp3",
	8614:  "canon-bjnp4",
	8675:  "msi-cps-rm-disc",
	8686:  "sun-as-jmxrmi",
	8732:  "dtp-net",
	8733:  "ibus",
	8763:  "mc-appserver",
	8764:  "openqueue",
	8765:  "ultraseek-http",
	8766:  "amcs",
	8770:  "dpap",
	8786:  "msgclnt",
	8787:  "msgsrvr",
	8793:  "acd-pm",
	8800:  "sunwebadmin",
	8804:  "truecm",
	8805:  "pfcp",
	8808:  "ssports-bcast",
	8873:  "dxspider",
	8880:  "cddbp-alt",
	8883:  "secure-mqtt",
	8888:  "ddi-udp-1",
	8889:  "ddi-udp-2",
	8890:  "ddi-udp-3",
	8891:  "ddi-udp-4",
	8892:  "ddi-udp-5",
	8893:  "ddi-udp-6",
	8894:  "ddi-udp-7",
	8899:  "ospf-lite",
	8900:  "jmb-cds1",
	8901:  "jmb-cds2",
	8910:  "manyone-http",
	8911:  "manyone-xml",
	8912:  "wcbackup",
	8913:  "dragonfly",
	8954:  "cumulus-admin",
	8980:  "nod-provider",
	8981:  "nod-client",
	8989:  "sunwebadmins",
	8990:  "http-wmap",
	8991:  "https-wmap",
	8999:  "bctp",
	9000:  "cslistener",
	9001:  "etlservicemgr",
	9002:  "dynamid",
	9007:  "ogs-client",
	9009:  "pichat",
	9020:  "tambora",
	9021:  "panagolin-ident",
	9022:  "paragent",
	9023:  "swa-1",
	9024:  "swa-2",
	9025:  "swa-3",
	9026:  "swa-4",
	9060:  "CardWeb-RT",
	9080:  "glrpc",
	9084:  "aurora",
	9085:  "ibm-rsyscon",
	9086:  "net2display",
	9087:  "classic",
	9088:  "sqlexec",
	9089:  "sqlexec-ssl",
	9090:  "websm",
	9091:  "xmltec-xmlmail",
	9092:  "XmlIpcRegSvc",
	9100:  "hp-pdl-datastr",
	9101:  "bacula-dir",
	9102:  "bacula-fd",
	9103:  "bacula-sd",
	9104:  "peerwire",
	9105:  "xadmin",
	9106:  "astergate-disc",
	9119:  "mxit",
	9131:  "dddp",
	9160:  "apani1",
	9161:  "apani2",
	9162:  "apani3",
	9163:  "apani4",
	9164:  "apani5",
	9191:  "sun-as-jpda",
	9200:  "wap-wsp",
	9201:  "wap-wsp-wtp",
	9202:  "wap-wsp-s",
	9203:  "wap-wsp-wtp-s",
	9204:  "wap-vcard",
	9205:  "wap-vcal",
	9206:  "wap-vcard-s",
	9207:  "wap-vcal-s",
	9208:  "rjcdb-vcards",
	9209:  "almobile-system",
	9210:  "oma-mlp",
	9211:  "oma-mlp-s",
	9212:  "serverviewdbms",
	9213:  "serverstart",
	9214:  "ipdcesgbs",
	9215:  "insis",
	9216:  "acme",
	9217:  "fsc-port",
	9222:  "teamcoherence",
	9255:  "mon",
	9277:  "traingpsdata",
	9278:  "pegasus",
	9279:  "pegasus-ctl",
	9280:  "pgps",
	9281:  "swtp-port1",
	9282:  "swtp-port2",
	9283:  "callwaveiam",
	9284:  "visd",
	9285:  "n2h2server",
	9286:  "n2receive",
	9287:  "cumulus",
	9292:  "armtechdaemon",
	9293:  "storview",
	9294:  "armcenterhttp",
	9295:  "armcenterhttps",
	9300:  "vrace",
	9318:  "secure-ts",
	9321:  "guibase",
	9343:  "mpidcmgr",
	9344:  "mphlpdmc",
	9346:  "ctechlicensing",
	9374:  "fjdmimgr",
	9380:  "boxp",
	9396:  "fjinvmgr",
	9397:  "mpidcagt",
	9400:  "sec-t4net-srv",
	9401:  "sec-t4net-clt",
	9402:  "sec-pc2fax-srv",
	9418:  "git",
	9443:  "tungsten-https",
	9444:  "wso2esb-console",
	9450:  "sntlkeyssrvr",
	9500:  "ismserver",
	9522:  "sma-spw",
	9535:  "mngsuite",
	9536:  "laes-bf",
	9555:  "trispen-sra",
	9592:  "ldgateway",
	9593:  "cba8",
	9594:  "msgsys",
	9595:  "pds",
	9596:  "mercury-disc",
	9597:  "pd-admin",
	9598:  "vscp",
	9599:  "robix",
	9600:  "micromuse-ncpw",
	9612:  "streamcomm-ds",
	9618:  "condor",
	9628:  "odbcpathway",
	9629:  "uniport",
	9632:  "mc-comm",
	9667:  "xmms2",
	9668:  "tec5-sdctp",
	9694:  "client-wakeup",
	9695:  "ccnx",
	9700:  "board-roar",
	9747:  "l5nas-parchan",
	9750:  "board-voip",
	9753:  "rasadv",
	9762:  "tungsten-http",
	9800:  "davsrc",
	9801:  "sstp-2",
	9802:  "davsrcs",
	9875:  "sapv1",
	9878:  "kca-service",
	9888:  "cyborg-systems",
	9889:  "gt-proxy",
	9898:  "monkeycom",
	9899:  "sctp-tunneling",
	9900:  "iua",
	9901:  "enrp",
	9903:  "multicast-ping",
	9909:  "domaintime",
	9911:  "sype-transport",
	9950:  "apc-9950",
	9951:  "apc-9951",
	9952:  "apc-9952",
	9953:  "acis",
	9955:  "alljoyn-mcm",
	9956:  "alljoyn",
	9966:  "odnsp",
	9987:  "dsm-scm-target",
	9990:  "osm-appsrvr",
	9991:  "osm-oev",
	9992:  "palace-1",
	9993:  "palace-2",
	9994:  "palace-3",
	9995:  "palace-4",
	9996:  "palace-5",
	9997:  "palace-6",
	9998:  "distinct32",
	9999:  "distinct",
	10000: "ndmp",
	10001: "scp-config",
	10002: "documentum",
	10003: "documentum-s",
	10007: "mvs-capacity",
	10008: "octopus",
	10009: "swdtp-sv",
	10050: "zabbix-agent",
	10051: "zabbix-trapper",
	10080: "amanda",
	10081: "famdc",
	10100: "itap-ddtp",
	10101: "ezmeeting-2",
	10102: "ezproxy-2",
	10103: "ezrelay",
	10104: "swdtp",
	10107: "bctp-server",
	10110: "nmea-0183",
	10111: "nmea-onenet",
	10113: "netiq-endpoint",
	10114: "netiq-qcheck",
	10115: "netiq-endpt",
	10116: "netiq-voipa",
	10117: "iqrm",
	10128: "bmc-perf-sd",
	10160: "qb-db-server",
	10161: "snmpdtls",
	10162: "snmpdtls-trap",
	10200: "trisoap",
	10201: "rscs",
	10252: "apollo-relay",
	10253: "eapol-relay",
	10260: "axis-wimp-port",
	10288: "blocks",
	10439: "bngsync",
	10500: "hip-nat-t",
	10540: "MOS-lower",
	10541: "MOS-upper",
	10542: "MOS-aux",
	10543: "MOS-soap",
	10544: "MOS-soap-opt",
	10800: "gap",
	10805: "lpdg",
	10810: "nmc-disc",
	10860: "helix",
	10880: "bveapi",
	10990: "rmiaux",
	11000: "irisa",
	11001: "metasys",
	10023: "cefd-vmp",
	11095: "weave",
	11106: "sgi-lk",
	11108: "myq-termlink",
	11111: "vce",
	11112: "dicom",
	11161: "suncacao-snmp",
	11162: "suncacao-jmxmp",
	11163: "suncacao-rmi",
	11164: "suncacao-csa",
	11165: "suncacao-websvc",
	11171: "snss",
	11201: "smsqp",
	11208: "wifree",
	11211: "memcache",
	11319: "imip",
	11320: "imip-channels",
	11321: "arena-server",
	11367: "atm-uhas",
	11371: "hkp",
	11430: "lsdp",
	11600: "tempest-port",
	11720: "h323callsigalt",
	11723: "emc-xsw-dcache",
	11751: "intrepid-ssl",
	11796: "lanschool-mpt",
	11876: "xoraya",
	11877: "x2e-disc",
	11967: "sysinfo-sp",
	12000: "entextxid",
	12001: "entextnetwk",
	12002: "entexthigh",
	12003: "entextmed",
	12004: "entextlow",
	12005: "dbisamserver1",
	12006: "dbisamserver2",
	12007: "accuracer",
	12008: "accuracer-dbms",
	12009: "ghvpn",
	12012: "vipera",
	12013: "vipera-ssl",
	12109: "rets-ssl",
	12121: "nupaper-ss",
	12168: "cawas",
	12172: "hivep",
	12300: "linogridengine",
	12321: "warehouse-sss",
	12322: "warehouse",
	12345: "italk",
	12753: "tsaf",
	13160: "i-zipqd",
	13216: "bcslogc",
	13217: "rs-pias",
	13218: "emc-vcas-udp",
	13223: "powwow-client",
	13224: "powwow-server",
	13400: "doip-disc",
	13720: "bprd",
	13721: "bpdbm",
	13722: "bpjava-msvc",
	13724: "vnetd",
	13782: "bpcd",
	13783: "vopied",
	13785: "nbdb",
	13786: "nomdb",
	13818: "dsmcc-config",
	13819: "dsmcc-session",
	13820: "dsmcc-passthru",
	13821: "dsmcc-download",
	13822: "dsmcc-ccp",
	13894: "ucontrol",
	13929: "dta-systems",
	14000: "scotty-ft",
	14001: "sua",
	14002: "scotty-disc",
	14033: "sage-best-com1",
	14034: "sage-best-com2",
	14141: "vcs-app",
	14142: "icpp",
	14145: "gcm-app",
	14149: "vrts-tdd",
	14154: "vad",
	14250: "cps",
	14414: "ca-web-update",
	14936: "hde-lcesrvr-1",
	14937: "hde-lcesrvr-2",
	15000: "hydap",
	15118: "v2g-secc",
	15345: "xpilot",
	15363: "3link",
	15555: "cisco-snat",
	15660: "bex-xr",
	15740: "ptp",
	15998: "2ping",
	16003: "alfin",
	16161: "sun-sea-port",
	16309: "etb4j",
	16310: "pduncs",
	16311: "pdefmns",
	16360: "netserialext1",
	16361: "netserialext2",
	16367: "netserialext3",
	16368: "netserialext4",
	16384: "connected",
	16666: "vtp",
	16900: "newbay-snc-mc",
	16950: "sgcip",
	16991: "intel-rci-mp",
	16992: "amt-soap-http",
	16993: "amt-soap-https",
	16994: "amt-redir-tcp",
	16995: "amt-redir-tls",
	17007: "isode-dua",
	17185: "soundsvirtual",
	17219: "chipper",
	17220: "avtp",
	17221: "avdecc",
	17222: "cpsp",
	17224: "trdp-pd",
	17225: "trdp-md",
	17234: "integrius-stp",
	17235: "ssh-mgmt",
	17500: "db-lsp-disc",
	17729: "ea",
	17754: "zep",
	17755: "zigbee-ip",
	17756: "zigbee-ips",
	18000: "biimenu",
	18181: "opsec-cvp",
	18182: "opsec-ufp",
	18183: "opsec-sam",
	18184: "opsec-lea",
	18185: "opsec-omi",
	18186: "ohsc",
	18187: "opsec-ela",
	18241: "checkpoint-rtm",
	18262: "gv-pf",
	18463: "ac-cluster",
	18634: "rds-ib",
	18635: "rds-ip",
	18668: "vdmmesh-disc",
	18769: "ique",
	18881: "infotos",
	18888: "apc-necmp",
	19000: "igrid",
	19007: "scintilla",
	19191: "opsec-uaa",
	19194: "ua-secureagent",
	19220: "cora-disc",
	19283: "keysrvr",
	19315: "keyshadow",
	19398: "mtrgtrans",
	19410: "hp-sco",
	19411: "hp-sca",
	19412: "hp-sessmon",
	19539: "fxuptp",
	19540: "sxuptp",
	19541: "jcp",
	19788: "mle",
	19999: "dnp-sec",
	20000: "dnp",
	20001: "microsan",
	20002: "commtact-http",
	20003: "commtact-https",
	20005: "openwebnet",
	20012: "ss-idi-disc",
	20014: "opendeploy",
	20034: "nburn-id",
	20046: "tmophl7mts",
	20048: "mountd",
	20049: "nfsrdma",
	20167: "tolfab",
	20202: "ipdtp-port",
	20222: "ipulse-ics",
	20480: "emwavemsg",
	20670: "track",
	20999: "athand-mmp",
	21000: "irtrans",
	21554: "dfserver",
	21590: "vofr-gateway",
	21800: "tvpm",
	21845: "webphone",
	21846: "netspeak-is",
	21847: "netspeak-cs",
	21848: "netspeak-acd",
	21849: "netspeak-cps",
	22000: "snapenetio",
	22001: "optocontrol",
	22002: "optohost002",
	22003: "optohost003",
	22004: "optohost004",
	22005: "optohost004",
	22273: "wnn6",
	22305: "cis",
	22335: "shrewd-stream",
	22343: "cis-secure",
	22347: "wibukey",
	22350: "codemeter",
	22555: "vocaltec-phone",
	22763: "talikaserver",
	22800: "aws-brf",
	22951: "brf-gw",
	23000: "inovaport1",
	23001: "inovaport2",
	23002: "inovaport3",
	23003: "inovaport4",
	23004: "inovaport5",
	23005: "inovaport6",
	23272: "s102",
	23294: "5afe-disc",
	23333: "elxmgmt",
	23400: "novar-dbase",
	23401: "novar-alarm",
	23402: "novar-global",
	24000: "med-ltp",
	24001: "med-fsp-rx",
	24002: "med-fsp-tx",
	24003: "med-supp",
	24004: "med-ovw",
	24005: "med-ci",
	24006: "med-net-svc",
	24242: "filesphere",
	24249: "vista-4gl",
	24321: "ild",
	24322: "hid",
	24386: "intel-rci",
	24465: "tonidods",
	24554: "binkp",
	24577: "bilobit-update",
	24676: "canditv",
	24677: "flashfiler",
	24678: "proactivate",
	24680: "tcc-http",
	24850: "assoc-disc",
	24922: "find",
	25000: "icl-twobase1",
	25001: "icl-twobase2",
	25002: "icl-twobase3",
	25003: "icl-twobase4",
	25004: "icl-twobase5",
	25005: "icl-twobase6",
	25006: "icl-twobase7",
	25007: "icl-twobase8",
	25008: "icl-twobase9",
	25009: "icl-twobase10",
	25793: "vocaltec-hos",
	25900: "tasp-net",
	25901: "niobserver",
	25902: "nilinkanalyst",
	25903: "niprobe",
	25954: "bf-game",
	25955: "bf-master",
	26000: "quake",
	26133: "scscp",
	26208: "wnn6-ds",
	26260: "ezproxy",
	26261: "ezmeeting",
	26262: "k3software-svr",
	26263: "k3software-cli",
	26486: "exoline-udp",
	26487: "exoconfig",
	26489: "exonet",
	27345: "imagepump",
	27442: "jesmsjc",
	27504: "kopek-httphead",
	27782: "ars-vista",
	27999: "tw-auth-key",
	28000: "nxlmd",
	28119: "a27-ran-ran",
	28200: "voxelstorm",
	28240: "siemensgsm",
	29167: "otmp",
	30001: "pago-services1",
	30002: "pago-services2",
	30003: "amicon-fpsu-ra",
	30004: "amicon-fpsu-s",
	30260: "kingdomsonline",
	30832: "samsung-disc",
	30999: "ovobs",
	31016: "ka-kdp",
	31029: "yawn",
	31416: "xqosd",
	31457: "tetrinet",
	31620: "lm-mon",
	31765: "gamesmith-port",
	31948: "iceedcp-tx",
	31949: "iceedcp-rx",
	32034: "iracinghelper",
	32249: "t1distproc60",
	32483: "apm-link",
	32635: "sec-ntb-clnt",
	32636: "DMExpress",
	32767: "filenet-powsrm",
	32768: "filenet-tms",
	32769: "filenet-rpc",
	32770: "filenet-nch",
	32771: "filenet-rmi",
	32772: "filenet-pa",
	32773: "filenet-cm",
	32774: "filenet-re",
	32775: "filenet-pch",
	32776: "filenet-peior",
	32777: "filenet-obrok",
	32801: "mlsn",
	32896: "idmgratm",
	33123: "aurora-balaena",
	33331: "diamondport",
	33334: "speedtrace-disc",
	33434: "traceroute",
	33656: "snip-slave",
	34249: "turbonote-2",
	34378: "p-net-local",
	34379: "p-net-remote",
	34567: "edi_service",
	34962: "profinet-rt",
	34963: "profinet-rtm",
	34964: "profinet-cm",
	34980: "ethercat",
	35001: "rt-viewer",
	35004: "rt-classmanager",
	35100: "axio-disc",
	35355: "altova-lm-disc",
	36001: "allpeers",
	36411: "wlcp",
	36865: "kastenxpipe",
	37475: "neckar",
	37654: "unisys-eportal",
	38002: "crescoctrl-disc",
	38201: "galaxy7-data",
	38202: "fairview",
	38203: "agpolicy",
	39681: "turbonote-1",
	40000: "safetynetp",
	40023: "k-patentssensor",
	40841: "cscp",
	40842: "csccredir",
	40843: "csccfirewall",
	40853: "ortec-disc",
	41111: "fs-qos",
	41230: "z-wave-s",
	41794: "crestron-cip",
	41795: "crestron-ctp",
	42508: "candp",
	42509: "candrp",
	42510: "caerpc",
	43000: "recvr-rc-disc",
	43188: "reachout",
	43189: "ndm-agent-port",
	43190: "ip-provision",
	43210: "shaperai-disc",
	43439: "eq3-config",
	43440: "ew-disc-cmd",
	43441: "ciscocsdb",
	44321: "pmcd",
	44322: "pmcdproxy",
	44544: "domiq",
	44553: "rbr-debug",
	44600: "asihpi",
	44818: "EtherNet-IP-2",
	44900: "m3da-disc",
	45000: "asmp-mon",
	45054: "invision-ag",
	45514: "cloudcheck-ping",
	45678: "eba",
	45825: "qdb2service",
	45966: "ssr-servermgr",
	46999: "mediabox",
	47000: "mbus",
	47100: "jvl-mactalk",
	47557: "dbbrowse",
	47624: "directplaysrvr",
	47806: "ap",
	47808: "bacnet",
	47809: "presonus-ucnet",
	48000: "nimcontroller",
	48001: "nimspooler",
	48002: "nimhub",
	48003: "nimgtw",
	48128: "isnetserv",
	48129: "blp5",
	48556: "com-bardac-dw",
	48619: "iqobject",
	48653: "robotraconteur",
	49001: "nusdp-disc",
}
var sctpPortNames = map[uint16]string{
	9:     "discard",
	20:    "ftp-data",
	21:    "ftp",
	22:    "ssh",
	80:    "http",
	179:   "bgp",
	443:   "https",
	1021:  "exp1",
	1022:  "exp2",
	1167:  "cisco-ipsla",
	1720:  "h323hostcall",
	2049:  "nfs",
	2225:  "rcip-itu",
	2904:  "m2ua",
	2905:  "m3ua",
	2944:  "megaco-h248",
	2945:  "h248-binary",
	3097:  "itu-bicc-stc",
	3565:  "m2pa",
	3863:  "asap-sctp",
	3864:  "asap-sctp-tls",
	3868:  "diameter",
	4333:  "ahsp",
	4502:  "a25-fap-fgw",
	4711:  "trinity-dist",
	4739:  "ipfix",
	4740:  "ipfixs",
	5060:  "sip",
	5061:  "sips",
	5090:  "car",
	5091:  "cxtp",
	5215:  "noteza",
	5445:  "smbdirect",
	5672:  "amqp",
	5675:  "v5ua",
	5868:  "diameters",
	5910:  "cm",
	5911:  "cpdlc",
	5912:  "fis",
	5913:  "ads-c",
	6704:  "frc-hp",
	6705:  "frc-mp",
	6706:  "frc-lp",
	6970:  "conductor-mpx",
	7626:  "simco",
	7701:  "nfapi",
	7728:  "osvr",
	8471:  "pim-port",
	9082:  "lcs-ap",
	9084:  "aurora",
	9900:  "iua",
	9901:  "enrp-sctp",
	9902:  "enrp-sctp-tls",
	11997: "wmereceiving",
	11998: "wmedistribution",
	11999: "wmereporting",
	14001: "sua",
	20049: "nfsrdma",
	25471: "rna",
	29118: "sgsap",
	29168: "sbcap",
	29169: "iuhsctpassoc",
	30100: "rwp",
	36412: "s1-control",
	36422: "x2-control",
	36423: "slmap",
	36424: "nq-ap",
	36443: "m2ap",
	36444: "m3ap",
	36462: "xw-control",
	38412: "ng-control",
	38422: "xn-control",
	38472: "f1-control",
}

```

`pkg/util/rest/rest.go`:

```go
/*
 * Copyright 2019-2020 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package rest

import (
	"context"
	"errors"
	"github.com/rabbitstack/fibratus/pkg/api"
	"io"
	"net"
	"net/http"
	"path"
	"strings"
	"time"
)

var transport *http.Transport

type opts struct {
	addr        string
	uri         string
	contentType string
	timeout     time.Duration
}

// Option represents the option for the HTTP client.
type Option func(o *opts)

// WithTransport sets the preferred transport for the HTTP client.
func WithTransport(addr string) Option {
	return func(o *opts) {
		o.addr = addr
		if strings.HasPrefix(addr, `npipe:///`) {
			transport = &http.Transport{
				DialContext: api.DialPipe(addr),
			}
		} else {
			transport = &http.Transport{
				DialContext: (&net.Dialer{}).DialContext,
			}
		}
	}
}

// WithURI initializes the URI where the request is sent.
func WithURI(uri string) Option {
	return func(o *opts) {
		o.uri = uri
	}
}

// WithContentType sets the content type header for the HTTP requests.
func WithContentType(contentType string) Option {
	return func(o *opts) {
		o.contentType = contentType
	}
}

// Get performs the GET request.
func Get(opts ...Option) ([]byte, error) {
	return request("GET", opts...)
}

func request(method string, options ...Option) ([]byte, error) {
	var opts opts
	for _, opt := range options {
		opt(&opts)
	}

	if transport == nil {
		return nil, errors.New("transport is not initialized")
	}

	timeout := opts.timeout
	if timeout == 0 {
		timeout = time.Second * 10
	}

	contentType := opts.contentType
	if contentType == "" {
		contentType = "application/json"
	}

	client := http.Client{
		Transport: transport,
		Timeout:   timeout,
	}

	scheme := "http://"
	addr := strings.TrimPrefix(opts.addr, `npipe:///`)

	ctx, cancel := context.WithTimeout(context.Background(), time.Second*10)
	defer cancel()
	req, err := http.NewRequestWithContext(ctx, method, scheme+path.Join(addr, opts.uri), nil)
	if err != nil {
		return nil, err
	}
	req.Header.Add("Content-Type", contentType)
	resp, err := client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()

	body, err := io.ReadAll(resp.Body)
	if err != nil {
		return nil, err
	}
	return body, nil
}

```

`pkg/util/rest/rest_test.go`:

```go
/*
 * Copyright 2019-2020 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package rest

import (
	"fmt"
	"github.com/rabbitstack/fibratus/pkg/api"
	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/require"
	"net/http"
	"net/http/httptest"
	"os/user"
	"strings"
	"testing"
)

func TestGet(t *testing.T) {
	mux := http.NewServeMux()
	mux.HandleFunc("/config", func(w http.ResponseWriter, r *http.Request) {
		if _, err := w.Write([]byte("test")); err != nil {
			t.Fatal(err)
		}
	})

	srv := httptest.NewServer(mux)
	defer srv.Close()

	resp, err := Get(WithURI("config"), WithTransport(fmt.Sprintf("localhost:%s", port(srv.URL))))
	require.NoError(t, err)
	require.NotNil(t, resp)
	assert.Equal(t, "test", string(resp))
}

func TestGetPipe(t *testing.T) {
	usr, err := user.Current()
	require.NoError(t, err)
	descriptor := "D:P(A;;GA;;;" + usr.Uid + ")"
	listener, err := api.MakePipeListener(`npipe:///fibratus`, descriptor)
	require.NoError(t, err)

	mux := http.NewServeMux()

	mux.HandleFunc("/config", func(w http.ResponseWriter, r *http.Request) {
		if _, err := w.Write([]byte("test")); err != nil {
			t.Fatal(err)
		}
	})

	srv := httptest.NewUnstartedServer(mux)
	srv.Listener = listener

	srv.Start()
	defer srv.Close()

	resp, err := Get(WithURI("config"), WithTransport(`npipe:///fibratus`))
	require.NoError(t, err)
	require.NotNil(t, resp)
	assert.Equal(t, "test", string(resp))
}

func port(s string) string {
	i := strings.LastIndex(s, ":")
	if i == 0 {
		return ""
	}
	return s[i+1:]
}

```

`pkg/util/sets/intersection.go`:

```go
/*
 * Copyright 2021-2022 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package sets

import "strings"

// IntersectionStrings computes the intersection of two
// string slices. The boolean argument specifies if the
// string comparison is case-sensitive or not.
func IntersectionStrings(s1, s2 []string, ignoreCase bool) []string {
	inter := make([]string, 0)
	bucket := map[string]bool{}

	for _, i := range s1 {
		for _, j := range s2 {
			var eq bool
			if ignoreCase {
				eq = strings.EqualFold(i, j) && !bucket[i]
			} else {
				eq = i == j && !bucket[i]
			}
			if eq {
				inter = append(inter, i)
				bucket[i] = true
			}
		}
	}

	return inter
}

```

`pkg/util/sets/intersection_test.go`:

```go
/*
 * Copyright 2021-2022 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package sets

import (
	"github.com/stretchr/testify/assert"
	"strings"
	"testing"
)

func TestIntersectionStrings(t *testing.T) {
	var tests = []struct {
		s1         []string
		s2         []string
		ignoreCase bool
		in         []string
	}{
		{
			[]string{"-k", "DcomLaunch", "-p", "-s", "LSM"}, []string{"DcomLaunch", "-s"}, true, []string{"DcomLaunch", "-s"},
		},
		{
			[]string{"-k", "DcomLaunch", "-p", "-s", "LSM"}, []string{"DComLaunch", "-s"}, false, []string{"-s"},
		},
		{
			[]string{"-k", "DcomLaunch", "-p", "-s", "LSM"}, []string{"LocalSystemNetworkRestricted"}, true, []string{},
		},
		{
			[]string{"LSM", "-s"}, []string{"-S", "lsm"}, true, []string{"LSM", "-s"},
		},
	}

	for _, tt := range tests {
		t.Run(strings.Join(tt.in, ","), func(t *testing.T) {
			assert.Equal(t, tt.in, IntersectionStrings(tt.s1, tt.s2, tt.ignoreCase))
		})
	}
}

```

`pkg/util/signals/signals.go`:

```go
/*
 * Copyright 2021-2022 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package signals

import (
	log "github.com/sirupsen/logrus"
	"golang.org/x/sys/windows"
	"os"
	"os/signal"
)

// Install setups the signal handler. Returns a blocking
// channel which receives an input after Interrupt or Term
// signals are triggered.
func Install() chan struct{} {
	sigCh := make(chan os.Signal, 1)
	signal.Notify(sigCh, os.Interrupt, windows.SIGTERM)

	stopCh := make(chan struct{})

	go func() {
		sig := <-sigCh
		log.Infof("got signal %q, shutting down...", sig)
		stopCh <- struct{}{}
	}()

	return stopCh
}

```

`pkg/util/signature/signature.go`:

```go
/*
 * Copyright 2021-2022 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package signature

import (
	"github.com/rabbitstack/fibratus/pkg/pe"
	"github.com/rabbitstack/fibratus/pkg/sys"
	log "github.com/sirupsen/logrus"
	"sync"
	"time"
)

// Signatures manages and caches DLL and executable signatures.
type Signatures struct {
	signatures map[uint64]*Signature
	mux        sync.Mutex
	purger     *time.Ticker
}

var sigs *Signatures

// sigTTL maximum time for the signature to remain in the
// internal store before it is purged.
var sigTTL = 10 * time.Minute

// GetSignatures creates a new signatures singleton.
func GetSignatures() *Signatures {
	if sigs != nil {
		return sigs
	}
	sigs = &Signatures{
		signatures: make(map[uint64]*Signature),
		purger:     time.NewTicker(time.Minute),
	}

	go sigs.gcSignatures()

	return sigs
}

// GetSignature retrieves the signature by base address. If
// the signature exists, its accessed timestamp is updated
// to prevent it being purged by the gc.
func (s *Signatures) GetSignature(addr uint64) *Signature {
	s.mux.Lock()
	defer s.mux.Unlock()
	sign, ok := s.signatures[addr]
	if !ok {
		return nil
	}
	sign.keepalive()
	return sign
}

// PutSignature links the signature data to the specified base address.
func (s *Signatures) PutSignature(addr uint64, sign *Signature) {
	s.mux.Lock()
	defer s.mux.Unlock()
	if s.signatures[addr] == nil {
		s.signatures[addr] = sign
	}
}

func (s *Signatures) gcSignatures() {
	for {
		<-s.purger.C
		s.mux.Lock()
		for addr, sig := range s.signatures {
			if time.Since(sig.accessed) > sigTTL {
				log.Debugf("removing signature info for file %s", sig.Filename)
				delete(s.signatures, addr)
			}
		}
		s.mux.Unlock()
	}
}

// ParseCertificate parses the certificate data for catalog-based
// signatures.
func (s *Signature) ParseCertificate() error {
	// the certificate exists in the PE security directory
	if s.Cert != nil {
		return nil
	}
	if !sys.IsWintrustFound() {
		return ErrWintrustUnavailable
	}
	// parse catalog certificate
	catalog := sys.NewCatalog()
	if err := catalog.Open(s.Filename); err != nil {
		return err
	}
	defer catalog.Close()
	var err error
	s.Cert, err = catalog.ParseCertificate()
	if err != nil {
		return err
	}
	return nil
}

// Check determines if the provided executable image or DLL is signed.
// It first parses the PE security directory to look for the signature
// information. If the certificate is not embedded inside the PE object
// then this method will try to locate the hash in the catalog file. If
// the certificate parsing is successful, this function returns the
// signature structure containing the signature type and certificate info.
// If the signature is not present, this function returns ErrNotSigned error.
// To verify the signature, call the Verify method of the Signature structure.
// On success, this method returns the signature type and the signature level.
// The signature level is either unchecked or unsigned. It is necessary to
// call the Verify method to determine the signature chain trust.
func (s *Signature) Check() (uint32, uint32, error) {
	// check if the signature is embedded in PE
	f, err := pe.ParseFile(s.Filename, pe.WithSecurity())
	if err != nil {
		return None, UncheckedLevel, err
	}
	if f.IsSigned {
		s.Cert = f.Cert
		return Embedded, UncheckedLevel, nil
	}

	if !sys.IsWintrustFound() {
		return None, UncheckedLevel, ErrWintrustUnavailable
	}

	// maybe the signature is in the catalog?
	catalog := sys.NewCatalog()
	if err := catalog.Open(s.Filename); err != nil {
		return None, UncheckedLevel, err
	}
	defer catalog.Close()
	if catalog.IsCatalogSigned() {
		return Catalog, UncheckedLevel, nil
	}
	return None, UnsignedLevel, ErrNotSigned // image not signed
}

// Verify verifies the DLL or executable image signature.
// The signature is verified via Authenticode policy provider.
// Windows must verify the trust chain by following the certificates
// to a trusted root certificate.
// If the verification fails on the PE object, then the attempt to
// verify the signature in the catalog file is made. This method
// returns a bool value indicating if the signature is trusted.
func (s *Signature) Verify() bool {
	if !sys.IsWintrustFound() {
		return false
	}
	s.Level = UnsignedLevel
	isTrusted := s.VerifyEmbedded() || s.VerifyCatalog()
	if isTrusted {
		s.Level = AuthenticodeLevel
		return isTrusted
	}
	return false
}

```

`pkg/util/signature/signature_test.go`:

```go
/*
 * Copyright 2021-2022 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package signature

import (
	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/require"
	"golang.org/x/sys/windows"
	"os"
	"path/filepath"
	"testing"
)

func TestSignature(t *testing.T) {
	executable, err := os.Executable()
	require.NoError(t, err)

	var tests = []struct {
		name     string
		filename string
		sigType  uint32
		sigLevel uint32
		err      error
	}{
		{
			"PE embedded signature",
			filepath.Join(os.Getenv("windir"), "System32", "kernel32.dll"),
			Embedded,
			AuthenticodeLevel,
			nil,
		},
		{
			"catalog signature",
			filepath.Join(os.Getenv("windir"), "notepad.exe"),
			Catalog,
			AuthenticodeLevel,
			nil,
		},
		{
			"unsigned binary",
			executable,
			None,
			UnsignedLevel,
			windows.ERROR_INVALID_PARAMETER,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			sign := &Signature{Filename: tt.filename}
			typ, _, err := sign.Check()
			assert.True(t, err == tt.err)
			sign.Verify()
			assert.Equal(t, tt.sigType, typ)
			assert.Equal(t, tt.sigLevel, sign.Level)
		})
	}
}

```

`pkg/util/signature/types.go`:

```go
/*
 * Copyright 2021-2022 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package signature

import (
	"errors"
	"github.com/rabbitstack/fibratus/pkg/sys"
	"runtime"
	"time"
)

const (
	// UncheckedLevel specifies signature unchecked level
	UncheckedLevel uint32 = 0
	// UnsignedLevel specifies signature unsigned level
	UnsignedLevel uint32 = 1
	// AuthenticodeLevel determines the object is Authenticode signed
	AuthenticodeLevel uint32 = 4

	// None indicates non-existent signature
	None uint32 = 0
	// Embedded indicates the signature is baked into the PE object
	Embedded uint32 = 1
	// Catalog indicates the executable or DLL signature is stored in the catalog
	Catalog uint32 = 3
)

// ErrNotSigned represents the error which is raised when the image lacks the signature
var ErrNotSigned = errors.New("image is not signed")

// ErrWintrustUnavailable represents the error which is raised when wintrust platfrom is not available
var ErrWintrustUnavailable = errors.New("wintrust is not available")

// Types enum defines signature types which verified the image.
var Types = map[uint32]string{
	0: "NONE",             // unsigned or verification hasn't been attempted
	1: "EMBEDDED",         // embedded signature
	2: "CACHED",           // cached signature; presence of a CI EA means the file was previously verified
	3: "CATALOG_CACHED",   // cached catalog verified via Catalog Database or searching catalog directly
	4: "CATALOG_UNCACHED", // uncached catalog verified via Catalog Database or searching catalog directly
	5: "CATALOG_HINT",     // successfully verified using an EA that informs CI that catalog to try first
	6: "PACKAGE_CATALOG",  // AppX / MSIX package catalog verified
	7: "FILE_VERIFIED",    // the file was verified
}

// Levels enum defines all possible image signature levels at which the code was verified.
var Levels = map[uint32]string{
	0:  "UNCHECKED",    // signing level hasn't yet been checked
	1:  "UNSIGNED",     // file is unsigned or has no signature that passes the active policies
	2:  "ENTERPRISE",   // trusted by Windows Defender Application Control policy
	3:  "DEVELOPER",    // developer signed code
	4:  "AUTHENTICODE", // Authenticode signed
	5:  "STORE_PPL",    // Microsoft Store signed app PPL (Protected Process Light)
	6:  "STORE",        // Microsoft Store-signed
	7:  "ANTIMALWARE",  // signed by an Antimalware vendor whose product is using AMPPL
	8:  "MICROSOFT",    // Microsoft signed
	9:  "CUSTOM_4",
	10: "CUSTOM_5",
	11: "DYNAMIC_CODEGEN", // only used for signing of the .NET NGEN compiler
	12: "WINDOWS",         // Windows signed
	13: "CUSTOM_7",
	14: "WINDOWS_TCB", // Windows Trusted Computing Base signed
	15: "CUSTOM_6",
}

// Signature represents the signature status.
type Signature struct {
	// Type specifies the signature type. If the image is not signed, the
	// type is equal to None.
	Type uint32
	// Level specifies the signature level at which the code was signed.
	Level uint32
	// Cert represents certificate information for the particular signature.
	Cert *sys.Cert
	// Filename represents the name of the executable image/DLL/driver
	Filename string
	// accessed the timestamp of the signature access by field extractor
	accessed time.Time
}

func (s *Signature) keepalive() {
	s.accessed = time.Now()
}

func (s *Signature) IsSigned() bool       { return s.Type != None }
func (s *Signature) IsTrusted() bool      { return s.Level != UncheckedLevel && s.Level != UnsignedLevel }
func (s *Signature) HasCertificate() bool { return s.Cert != nil }

// VerifyEmbedded performs a trust verification action on the PE file
// by passing the inquiry to a trust provider that supports the action
// identifier.
func (s *Signature) VerifyEmbedded() bool {
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()
	trust := sys.NewWintrustData(sys.WtdChoiceFile)
	defer trust.Close()
	return trust.VerifyFile(s.Filename)
}

// VerifyCatalog verifies the catalog-based file signature.
func (s *Signature) VerifyCatalog() bool {
	catalog := sys.NewCatalog()
	err := catalog.Open(s.Filename)
	if err != nil {
		return false
	}
	defer catalog.Close()
	return catalog.Verify(s.Filename)
}

```

`pkg/util/spinner/spinner.go`:

```go
/*
 * Copyright 2019-2020 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package spinner

import (
	"github.com/briandowns/spinner"
	"time"
)

// Show creates a new spinner and starts it.
func Show(prefix string) *spinner.Spinner {
	s := spinner.New(spinner.CharSets[14], 100*time.Millisecond) // Build our spinner
	s.Prefix = "> " + prefix + " "
	s.HideCursor = true
	s.Start()
	return s
}

```

`pkg/util/stringcase/camel.go`:

```go
/*
 * Credits to: https://github.com/iancoleman/strcase/blob/master/camel.go
 *
 * The MIT License (MIT)
 *
 * Copyright (c) 2015 Ian Coleman
 * Copyright (c) 2018 Ma_124, <github.com/Ma124>
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, Subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or Substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */

package stringcase

import "strings"

// Camel a string to CamelCase.
func Camel(s string) string {
	s = strings.TrimSpace(s)
	if s == "" {
		return s
	}

	var n strings.Builder
	n.Grow(len(s))
	capNext := true
	for i, v := range []byte(s) {
		vIsCap := v >= 'A' && v <= 'Z'
		vIsLow := v >= 'a' && v <= 'z'
		if capNext {
			if vIsLow {
				v += 'A'
				v -= 'a'
			}
		} else if i == 0 {
			if vIsCap {
				v += 'a'
				v -= 'A'
			}
		}
		if vIsCap || vIsLow {
			n.WriteByte(v)
			capNext = false
		} else if vIsNum := v >= '0' && v <= '9'; vIsNum {
			n.WriteByte(v)
			capNext = true
		} else {
			capNext = v == '_' || v == ' ' || v == '-' || v == '.'
		}
	}
	return n.String()
}

```

`pkg/util/stringcase/camel_test.go`:

```go
/*
 * Copyright 2021-2022 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package stringcase

import (
	"testing"

	"github.com/stretchr/testify/assert"
)

func TestCamel(t *testing.T) {
	assert.Equal(t, "CamelCase", Camel("camel_case"))
	assert.Equal(t, "FileNameOp", Camel("file_name_op"))
}

```

`pkg/util/term/fb.go`:

```go
//go:build windows
// +build windows

/*
 * Copyright 2019-2020 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package term

import (
	"fmt"
	"io"
	"syscall"
	"unicode/utf16"
	"unsafe"
)

var (
	createConsoleScreenBuffer    = kernel32.NewProc("CreateConsoleScreenBuffer")
	setConsoleActiveScreenBuffer = kernel32.NewProc("SetConsoleActiveScreenBuffer")
)

const consoleTextModeBuffer = 0x1

// FrameBuffer is a special type of the I/O writer that outputs the character stream to the
// active console screen buffer.
type FrameBuffer struct {
	handle syscall.Handle
}

// NewFrameBuffer builds a fresh frame buffer.
func NewFrameBuffer() (io.Writer, error) {
	handle, _, err := createConsoleScreenBuffer.Call(
		uintptr(syscall.GENERIC_READ|syscall.GENERIC_WRITE),
		uintptr(0),
		uintptr(0),
		uintptr(consoleTextModeBuffer),
		uintptr(0),
		uintptr(0),
	)
	if handle == 0 {
		return nil, fmt.Errorf("unable to create screen buffer: %v", err)
	}
	fb := &FrameBuffer{
		handle: syscall.Handle(handle),
	}
	errno, _, err := setConsoleActiveScreenBuffer.Call(handle)
	if errno == 0 {
		return nil, fmt.Errorf("couldn't activate console screen buffer: %v", err)
	}
	showCursor(fb.handle, false)
	return fb, nil
}

// Write draws the character buffer to the screen frame buffer.
func (fb FrameBuffer) Write(p []byte) (int, error) {
	bufferInfo, err := getScreenBufferInfo(fb.handle)
	if err != nil {
		return 0, err
	}
	if len(p) == 1 {
		return 0, nil
	}

	rows := int(bufferInfo.rect.bottom)
	cols := int(bufferInfo.rect.right)

	chars := make([]charInfo, cols*rows)

	var x int
	var y int
	var newLine bool

	for _, char := range string(p) {
		c := char
		if c == '\n' || c == '\r' {
			newLine = true
		}
		r, c := utf16.EncodeRune(c)
		if r == 0xFFFD {
			c = char
		}
		y++
		// if the last column has been reached and a new line was encountered at
		// that position then we'll stop the iteration and reset the column number
		if y == cols {
			y = 0
			if newLine {
				newLine = false
				continue
			}
		}
		if newLine {
			newLine = false
			space := y
			// keep filling the rectangle with spaces until we reach the last column. Then
			// we'll reset the column and stop the current iteration
			for space <= cols {
				if space-1 > len(chars)-1 {
					continue
				}
				chars[space-1].char = uint16(' ')
				space++
				x++
			}
			y = 0
			continue
		}

		if x > len(chars)-1 {
			continue
		}

		chars[x].char = uint16(c)
		chars[x].attr = bufferInfo.attributes
		x++
	}

	// clear the current frame buffer screen
	fb.cls(bufferInfo)

	// the following block of code does the heavy lifting of writing the
	// character buffer to the screen frame buffer that we previously created
	cord := point{}
	size := point{x: int16(cols), y: int16(rows)}
	rect := rect{left: 0, top: 0, right: int16(cols) - 1, bottom: int16(rows) - 1}
	_, _, _ = writeConsoleOutput.Call(
		uintptr(fb.handle),
		uintptr(unsafe.Pointer(&chars[0])),
		size.uintptr(),
		cord.uintptr(),
		uintptr(unsafe.Pointer(&rect)),
	)

	return len(p), nil
}

// Close closes this frame buffer.
func (fb *FrameBuffer) Close() error {
	return syscall.Close(fb.handle)
}

// cls clears the frame buffer content.
func (fb *FrameBuffer) cls(bufferInfo *consoleScreenBufferInfo) {
	var w uint16
	var cursor point
	rows := bufferInfo.size.x
	cols := bufferInfo.size.y

	_, _, _ = fillConsoleOutputCharacter.Call(
		uintptr(fb.handle),
		uintptr(' '),
		uintptr(rows*cols),
		*(*uintptr)(unsafe.Pointer(&cursor)),
		uintptr(unsafe.Pointer(&w)),
	)

	_, _, _ = fillConsoleOutputAttribute.Call(
		uintptr(fb.handle),
		uintptr(bufferInfo.attributes),
		uintptr(rows*cols),
		*(*uintptr)(unsafe.Pointer(&cursor)),
		uintptr(unsafe.Pointer(&w)),
	)
}

```

`pkg/util/term/term.go`:

```go
//go:build windows
// +build windows

/*
 * Copyright 2019-2020 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package term

import (
	"os"
	"syscall"
	"unsafe"
)

var (
	kernel32 = syscall.NewLazyDLL("kernel32.dll")

	setConsoleCursorInfo       = kernel32.NewProc("SetConsoleCursorInfo")
	getConsoleScreenBufferInfo = kernel32.NewProc("GetConsoleScreenBufferInfo")
	writeConsoleOutput         = kernel32.NewProc("WriteConsoleOutputW")

	fillConsoleOutputCharacter = kernel32.NewProc("FillConsoleOutputCharacterW")
	fillConsoleOutputAttribute = kernel32.NewProc("FillConsoleOutputAttribute")
)

type point struct {
	x int16
	y int16
}

func (p point) uintptr() uintptr { return uintptr(*(*int32)(unsafe.Pointer(&p))) }

type rect struct {
	left, top     int16
	right, bottom int16
}

//nolint:unused
func (r *rect) uintptr() uintptr { return uintptr(unsafe.Pointer(r)) }

type charInfo struct {
	char uint16
	attr uint16
}

type consoleScreenBufferInfo struct {
	size       point
	_          point
	attributes uint16
	rect       rect
	_          point
}

type consoleCursorInfo struct {
	size    uint32
	visible bool
}

// getScreenBufferInfo retrieves information about the specified console screen buffer.
func getScreenBufferInfo(cons syscall.Handle) (*consoleScreenBufferInfo, error) {
	var bi consoleScreenBufferInfo
	errno, _, err := getConsoleScreenBufferInfo.Call(uintptr(cons), uintptr(unsafe.Pointer(&bi)))
	if errno == 0 {
		return nil, err
	}
	return &bi, nil
}

// GetColumns gets the number of character columns.
func GetColumns() int {
	bufferInfo, err := getScreenBufferInfo(syscall.Handle(os.Stdout.Fd()))
	if err != nil {
		return 0
	}
	return int(bufferInfo.rect.right)
}

// showCursor shows/hides the cursor.
func showCursor(cons syscall.Handle, visible bool) {
	var ci consoleCursorInfo
	ci.size = 100
	ci.visible = visible
	_, _, _ = setConsoleCursorInfo.Call(uintptr(cons), uintptr(unsafe.Pointer(&ci)))
}

```

`pkg/util/threadcontext/context.go`:

```go
/*
 * Copyright 2021-present by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package threadcontext

import (
	"github.com/rabbitstack/fibratus/pkg/util/va"
	"golang.org/x/sys/windows"
	"unsafe"
)

// Context contains processor-specific register data.
type Context struct {
	P1           uint64
	P2           uint64
	P3           uint64
	P4           uint64
	P5           uint64
	P6           uint64
	ContextFlags uint32
	MxCsr        uint32
	SegCs        uint16
	SegDs        uint16
	SegEs        uint16
	SegFs        uint16
	SegGs        uint16
	SegSs        uint16
	EFlags       uint32
	Dr0          uint64
	Dr1          uint64
	Dr2          uint64
	Dr3          uint64
	Dr6          uint64
	Dr7          uint64
	Rax          uint64
	Rcx          uint64
	Rdx          uint64
	Rbx          uint64
	Rsp          uint64
	Rbp          uint64
	Rsi          uint64
	Rdi          uint64
	R8           uint64
	R9           uint64
	R10          uint64
	R11          uint64
	R12          uint64
	R13          uint64
	R14          uint64
	R15          uint64
	Rip          uint64
}

// Decode reads the thread context structure from
// the given process memory and at the specified
// base address. Returns the decoded Context struct
// or nil if the data cannot be read from the remote
// process address space.
func Decode(pid uint32, addr va.Address) *Context {
	proc, err := windows.OpenProcess(windows.PROCESS_QUERY_INFORMATION|windows.PROCESS_VM_READ, false, pid)
	if err != nil {
		return nil
	}
	defer windows.Close(proc)

	size := uint(unsafe.Sizeof(Context{}))
	ctx := va.ReadArea(proc, addr.Uintptr(), size, size, false)
	if !va.Zeroed(ctx) {
		return (*Context)(unsafe.Pointer(&ctx[0]))
	}

	return nil
}

// Rip returns the address stored in the instruction pointer register.
func Rip(pid uint32, addr va.Address) va.Address {
	ctx := Decode(pid, addr)
	if ctx != nil {
		return va.Address(ctx.Rip)
	}
	return 0
}

// IsParamOfFunc returns true if the CONTEXT
// structure is supplied as a single parameter
// to the well-known API functions.
func IsParamOfFunc(f string) bool {
	return f == "NtContinue" || f == "ZwContinue" || f == "RtlCaptureContext"
}

```

`pkg/util/threadcontext/context_test.go`:

```go
/*
 * Copyright 2021-present by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package threadcontext

import (
	"github.com/rabbitstack/fibratus/pkg/util/va"
	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/require"
	"golang.org/x/sys/windows"
	"os"
	"testing"
	"unsafe"
)

func TestDecode(t *testing.T) {
	ntdll, err := windows.LoadLibrary("kernel32.dll")
	require.NoError(t, err)

	fn, err := windows.GetProcAddress(ntdll, "VirtualProtect")
	require.NoError(t, err)

	ctx := Context{
		Rip: uint64(fn),
	}

	const sz = int(unsafe.Sizeof(Context{}))
	b := (*(*[sz]byte)(unsafe.Pointer(&ctx)))[:]

	addr, err := windows.VirtualAlloc(0, uintptr(sz), windows.MEM_COMMIT, windows.PAGE_EXECUTE_READWRITE)
	require.NoError(t, err)

	var n uintptr
	require.NoError(t, windows.WriteProcessMemory(windows.CurrentProcess(), addr, &b[0], uintptr(sz), &n))

	c := Decode(uint32(os.Getpid()), va.Address(addr))

	require.NotNil(t, c)
	require.Equal(t, fn, uintptr(c.Rip))
}

func TestIsParamOfFunc(t *testing.T) {
	var tests = []struct {
		f  string
		ok bool
	}{
		{"ZwContinue", true},
		{"RtlCaptureContext", true},
		{"CreateFile", false},
		{"CreateThread", false},
	}

	for _, tt := range tests {
		t.Run(tt.f, func(t *testing.T) {
			assert.Equal(t, tt.ok, IsParamOfFunc(tt.f))
		})
	}
}

```

`pkg/util/tls/tls.go`:

```go
/*
 * Copyright 2019-2020 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package tls

import (
	"crypto/tls"
	"crypto/x509"
	"fmt"
	"os"
)

// MakeConfig builds a TLS config from the certificate, private/public key and the CA cert files.
func MakeConfig(certFile, keyFile, caFile string, insecureSkipVerify bool) (*tls.Config, error) {
	if certFile == "" && keyFile == "" && caFile == "" {
		return nil, nil
	}

	var cert tls.Certificate
	tlsConfig := &tls.Config{
		InsecureSkipVerify: insecureSkipVerify,
	}

	// load certificate/key
	if certFile != "" && keyFile == "" {
		var err error
		cert, err = tls.LoadX509KeyPair(certFile, keyFile)
		if err != nil {
			return nil, err
		}
		tlsConfig.Certificates = []tls.Certificate{cert}
	}
	// load certificate issuing authority
	if caFile != "" {
		cpool := x509.NewCertPool()
		caCert, err := os.ReadFile(caFile)
		if err != nil {
			return nil, err
		}
		ok := cpool.AppendCertsFromPEM(caCert)
		if !ok {
			return nil, fmt.Errorf("fail to load certificate authority: %s", caFile)
		}
		tlsConfig.RootCAs = cpool
	}

	return tlsConfig, nil
}

```

`pkg/util/typesize/typesize.go`:

```go
/*
 * Copyright 2019-2020 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package typesize

import "unsafe"

var ptr uintptr

// Pointer returns the pointer size on this machine.
func Pointer() uintptr { return unsafe.Sizeof(ptr) }

```

`pkg/util/utf16/utf16.go`:

```go
//go:build windows
// +build windows

/*
 * Copyright 2019-2020 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package utf16

import (
	"encoding/binary"
	"unicode/utf8"
)

const (
	// 0xd800-0xdc00 encodes the high 10 bits of a pair.
	surr1 = 0xd800
	// 0xdc00-0xe000 encodes the low 10 bits of a pair.
	surr2 = 0xdc00
)

func isHighSurrogate(r rune) bool { return r >= surr1 && r <= 0xdbff }
func isLowSurrogate(r rune) bool  { return r >= surr2 && r <= 0xdfff }

// Decode decodes the UTF16-encoded string to UTF-8 string using fast ASCII path.
// This function exhibits much better performance than the standard library counterpart.
func Decode(p []uint16) string {
	n := len(p)
	if n == 0 {
		return ""
	}

	s := make([]byte, 0, n*2)

	for i := 0; i < len(p); i++ {
		// ascii fast-path (0x0000–0x007F)
		if p[i] <= 0x7F {
			s = append(s, byte(p[i]))
			continue
		}

		r1 := rune(p[i])

		// surrogate pair handling
		if isHighSurrogate(r1) && i+1 < n {
			r2 := rune(p[i+1])
			if isLowSurrogate(r2) {
				i++
				r := 0x10000 + (r1-surr1)<<10 + (r2 - surr2)
				s = utf8.AppendRune(s, r)
				continue
			}
		}

		// non-surrogate BMP code point or malformed surrogate
		if !isLowSurrogate(r1) {
			s = utf8.AppendRune(s, r1)
		} else {
			// lone low surrogate to replacement char
			s = utf8.AppendRune(s, utf8.RuneError)
		}
	}

	return string(s)
}

// BytesToString converts the UTF16-encoded byte buffer to string.
func BytesToString(b []byte, o binary.ByteOrder) string {
	utf := make([]uint16, 0, len(b)/2)
	for i := 0; i+1 < len(b); i += 2 {
		u := o.Uint16(b[i:])
		if u == 0 {
			break // stop at null terminator
		}
		utf = append(utf, u)
	}
	return Decode(utf)
}

```

`pkg/util/utf16/utf16_test.go`:

```go
/*
 * Copyright 2021-2022 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package utf16

import (
	"github.com/stretchr/testify/require"
	"math/rand"
	"testing"
	"unicode/utf16"
)

func TestDecode(t *testing.T) {
	for i := 0; i < 24; i++ {
		buf := genbuf(1 << i)
		w := string(utf16.Decode(buf))
		g := Decode(buf)
		if w != g {
			t.Errorf("mismatch on 1<<%d", i)
		}
	}
	s := []rune("Do you want café?")
	encoded := utf16.Encode(s)
	require.Equal(t, "Do you want café?", Decode(encoded))
}

func BenchmarkStdlibDecode(b *testing.B) {
	b.ReportAllocs()
	b.StopTimer()
	buf := genbuf(b.N)
	b.StartTimer()
	_ = string(utf16.Decode(buf))
}

func BenchmarkDecode(b *testing.B) {
	b.ReportAllocs()
	b.StopTimer()
	buf := genbuf(b.N)
	b.StartTimer()
	_ = Decode(buf)
}

func genbuf(n int) []uint16 {
	r := rand.New(rand.NewSource(int64(n)))
	buf := make([]rune, n)
	for i := 0; i < n; i++ {
		// simulate mostly-ASCII
		if r.Intn(100) == 0 {
			buf[i] = rune(r.Intn(0x10ffff + 1))
		} else {
			buf[i] = rune(r.Intn(1 << 7))
		}
	}
	return utf16.Encode(buf)
}

```

`pkg/util/va/address.go`:

```go
/*
 * Copyright 2021-2022 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package va

import "strconv"

// Address represents the memory address
type Address uint64

// Hex returns the hexadecimal representation of the memory address.
func (a Address) String() string   { return strconv.FormatUint(uint64(a), 16) }
func (a Address) Uint64() uint64   { return uint64(a) }
func (a Address) Uintptr() uintptr { return uintptr(a) }
func (a Address) IsZero() bool     { return a == 0 }

// Inc increments the address by given offset.
func (a Address) Inc(offset uint64) Address {
	a += Address(offset)
	return a
}

// Dec decrements the address by given offset.
func (a Address) Dec(offset uint64) Address {
	a -= Address(offset)
	return a
}

// InSystemRange determines if this address is in the system address space range.
// The kernel preferentially uses these two ranges to load DLLs at shared addresses.
func (a Address) InSystemRange() bool { return a >= 0xfffff80000000000 && a < 0xffffffffffffffff }

```

`pkg/util/va/address_test.go`:

```go
/*
 * Copyright 2021-2022 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package va

import (
	"github.com/stretchr/testify/assert"
	"strconv"
	"testing"
)

func TestAddressRanges(t *testing.T) {
	var tests = []struct {
		addr       Address
		inSysRange bool
	}{
		{0xfffff8036710ad28, true},
		{0x7ffd38e326e4, false},
		{0xfffff803672274e5, true},
	}

	for _, tt := range tests {
		t.Run(strconv.FormatUint(tt.addr.Uint64(), 16), func(t *testing.T) {
			assert.Equal(t, tt.inSysRange, tt.addr.InSystemRange())
		})
	}
}

```

`pkg/util/va/region.go`:

```go
/*
 * Copyright 2021-2022 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package va

import (
	"expvar"
	"github.com/rabbitstack/fibratus/pkg/sys"
	"golang.org/x/sys/windows"
	"golang.org/x/time/rate"
	"strconv"
	"sync"
	"unsafe"
)

const (
	// MemImage indicates that the memory pages within the region are mapped
	// into the view of an image section.
	MemImage uint32 = 0x1000000
	// MemMapped indicates that the memory pages within the region are mapped
	// into the view of a section.
	MemMapped uint32 = 0x40000
	// MemPrivate Indicates that the memory pages within the region are private
	// that is, not shared by other processes.
	MemPrivate uint32 = 0x20000
)

const (
	// SectionData indicates a mapped view of a data file.
	SectionData = 0x0
	// SectionImage indicates a mapped view of an executable image.
	SectionImage = 0x4
	// SectionImageNoExecute indicates a mapped view an executable image file that will not be executed.
	SectionImageNoExecute = 0x8
	// SectionPagefile indicates a mapped view of pagefile-backed section.
	SectionPagefile = 0xC
	// SectionPhysical indicates that the allocation is a view of the \Device\PhysicalMemory section.
	SectionPhysical = 0xD
)

// RegionInfo  describes the allocated region page properties.
type RegionInfo struct {
	Type     uint32
	Protect  uint32
	BaseAddr uint64
	Size     uint64
	proc     windows.Handle
	State    uint32
}

// IsMapped determines if the region is backed by the section object.
func (r RegionInfo) IsMapped() bool {
	return r.Type == MemImage || r.Type == MemMapped
}

// GetMappedFile checks whether the specified address is within
// a memory-mapped file in the address space of the specified process.
// If so, it returns the name of the memory-mapped file.
func (r RegionInfo) GetMappedFile() string {
	return sys.GetMappedFile(r.proc, uintptr(r.BaseAddr))
}

// ProtectMask returns protection in mask notation.
func (r RegionInfo) ProtectMask() string {
	switch r.Protect {
	case windows.PAGE_READONLY:
		return "R"
	case windows.PAGE_READWRITE:
		return "RW"
	case windows.PAGE_EXECUTE_READ:
		return "RX"
	case windows.PAGE_EXECUTE_READWRITE:
		return "RWX"
	case windows.PAGE_EXECUTE_WRITECOPY:
		return "RWXC"
	case windows.PAGE_EXECUTE:
		return "X"
	case windows.PAGE_WRITECOPY:
		return "WC"
	case windows.PAGE_NOACCESS:
		return "NA"
	case windows.PAGE_WRITECOMBINE:
		return "WCB"
	case windows.PAGE_GUARD, windows.PAGE_GUARD | windows.PAGE_READWRITE:
		return "PG"
	case windows.PAGE_NOCACHE:
		return "NC"
	case 0:
		return "-"
	default:
		return "?"
	}
}

// RegionProber examines metadata about the range of pages
// within the process virtual address space. It keeps the
// state of opened process handles for which VA spaces are
// consulted. To avoid noisy processes putting too much pressure
// on the `VirtualQueryEx` calls, the prober employs a set of
// limiters with token bucket strategy.
type RegionProber struct {
	// procs contains opened process handles for
	// which virtual address query was performed
	procs map[uint32]windows.Handle
	// lims contains token bucket limiters per pid
	lims map[uint32]*rate.Limiter
	mu   sync.Mutex
}

const (
	burst = 500 // limiter initial bucket size
	limit = 300 // rate of 300 region queries per second
)

// proberRateLimits accounts probe rate limits per process id
var proberRateLimits = expvar.NewMap("va.region.prober.rate.limits")

// NewRegionProber creates a fresh instance of the region prober.
func NewRegionProber() *RegionProber {
	return &RegionProber{procs: make(map[uint32]windows.Handle), lims: make(map[uint32]*rate.Limiter)}
}

// Query fetches region information for the specified process id and the
// base address. It keeps a cache of opened process handles and reuses
// them for subsequent calls to VirtualQueryEx. To defend against noisy
// processes, the throttling mechanism is implemented with token bucket
// limiters. If successful, this method returns the region info. Otherwise,
// it returns nil.
func (p *RegionProber) Query(pid uint32, addr uint64) *RegionInfo {
	p.mu.Lock()
	defer p.mu.Unlock()
	lim, ok := p.lims[pid]
	if !ok {
		lim = rate.NewLimiter(limit, burst)
		p.lims[pid] = lim
	}
	// check rate limit for the calling process
	if !lim.Allow() {
		proberRateLimits.Add(strconv.Itoa(int(pid)), 1)
		return nil
	}
	process, ok := p.procs[pid]
	if !ok {
		var err error
		process, err = windows.OpenProcess(windows.PROCESS_QUERY_INFORMATION, false, pid)
		if err != nil {
			return nil
		}
		p.procs[pid] = process
	}
	return VirtualQuery(process, addr)
}

// VirtualQuery queries the virtual address region info.
func VirtualQuery(process windows.Handle, addr uint64) *RegionInfo {
	var mem windows.MemoryBasicInformation
	err := windows.VirtualQueryEx(process, uintptr(addr), &mem, unsafe.Sizeof(mem))
	if err != nil {
		return nil
	}
	return &RegionInfo{
		Type:     mem.Type,
		Protect:  mem.AllocationProtect,
		BaseAddr: addr,
		Size:     uint64(mem.RegionSize),
		proc:     process,
		State:    mem.State,
	}
}

// QueryWorkingSet retrieves extended information about
// the pages at specific virtual addresses in the address
// space of the specified process.
func QueryWorkingSet(process windows.Handle, addr uint64) *sys.MemoryWorkingSetExBlock {
	var ws sys.MemoryWorkingSetExInformation
	ws.VirtualAddress = uintptr(addr)
	err := sys.QueryWorkingSet(process, &ws, uint32(unsafe.Sizeof(sys.MemoryWorkingSetExInformation{})))
	if err != nil {
		return nil
	}
	return &ws.VirtualAttributes
}

// Remove removes the process handle from cache and closes it.
// It returns true if the handle was closed successfully.
func (p *RegionProber) Remove(pid uint32) bool {
	p.mu.Lock()
	defer p.mu.Unlock()
	process, ok := p.procs[pid]
	if !ok {
		return false
	}
	delete(p.procs, pid)
	delete(p.lims, pid)
	return windows.Close(process) == nil
}

// Close closes all opened process handles.
func (p *RegionProber) Close() {
	p.mu.Lock()
	defer p.mu.Unlock()
	for _, process := range p.procs {
		windows.Close(process)
	}
}

// Region describes the state of a range of pages in the
// process virtual address space and offers convenient
// methods for reading and accessing region memory.
// This code is inspired by libpeconv library:
// https://github.com/hasherezade/libpeconv
type Region struct {
	base    uintptr        // base address of the region of pages
	size    uintptr        // size of the region in bytes beginning at the base address
	typ     uint32         // type of pages in the region
	state   uint32         // state of the pages in the region
	protect uint32         // access protection of the pages in the region
	process windows.Handle // process handle for which the region is read
}

// ReadArea reads a full memory area within a given process, starting at the base
// address and reading up to the buffer size.
// The memory area can consist of multiple regions with various access rights.
// If the region is inaccessible and protection changing flag is enabled,
// this function tries to change the region protection to read-only access.
// If the request to change region protection is granted, upon completion,
// the original access permissions are restored.
// On read failure the region is skipped, and the read is moving to the
// next one leaving in the output buffer an empty space of the region size.
func ReadArea(process windows.Handle, base uintptr, bufSize, minSize uint, forceAccess bool) []byte {
	if bufSize == 0 || base == 0 {
		return nil
	}
	i := uint(0)
	buf := make([]byte, 0)
	for i < bufSize {
		chunk := base + uintptr(i)
		region, err := NewRegion(process, chunk)
		if err != nil {
			break
		}
		if region.Size(chunk) == 0 {
			break
		}
		n, b := region.Read(chunk, bufSize-i, minSize, forceAccess)
		if n == 0 {
			// skip the region that could not be read
			// and fill it with zeros of region size
			i += region.Size(chunk)
			zeros := make([]byte, region.Size(chunk))
			buf = append(buf, zeros...)
			continue
		}
		i += n
		buf = append(buf, b...)
	}
	return buf
}

// Zeroed determines if all bytes in the area are zeroed.
func Zeroed(area []byte) bool {
	for _, b := range area {
		if b != 0 {
			return false
		}
	}
	return true
}

// NewRegion creates a new region for the specified process and base address.
func NewRegion(process windows.Handle, base uintptr) (*Region, error) {
	var m windows.MemoryBasicInformation
	err := windows.VirtualQueryEx(process, base, &m, unsafe.Sizeof(m))
	if err != nil {
		return nil, err
	}
	r := &Region{
		process: process,
		typ:     m.Type,
		state:   m.State,
		protect: m.Protect,
		size:    m.RegionSize,
		base:    m.BaseAddress,
	}
	return r, nil
}

// Size returns the size of the region starting from the base address.
func (r Region) Size(base uintptr) uint {
	if r.typ == 0 { // ignore invalid type
		return 0
	}
	if r.size > base {
		return 0
	}
	offset := base - r.base
	return uint(r.size - offset)
}

// Read reads a single memory region within a given process
// starting at supplied base address. In case region is inaccessible
// and the force access flag is enabled, it tries to force the access
// by temporarily changing the permissions of the memory region.
func (r Region) Read(addr uintptr, bufSize, minSize uint, forceAccess bool) (uint, []byte) {
	if bufSize == 0 {
		return 0, nil
	}
	if r.state&windows.MEM_COMMIT == 0 {
		// no committed pages in the region
		return 0, nil
	}
	if r.Size(addr) == 0 {
		return 0, nil
	}
	// size to read
	size := r.Size(addr)
	if size > bufSize {
		size = bufSize
	}
	var prevProtection uint32
	isAccessChanged := false
	isAccessible := r.protect&windows.PAGE_NOACCESS == 0
	if forceAccess && !isAccessible {
		// change page access right
		err := windows.VirtualProtectEx(r.process, addr, uintptr(r.Size(addr)), windows.PAGE_READONLY, &prevProtection)
		if err == nil {
			isAccessChanged = true
		}
		defer func() {
			// restore page access right
			if isAccessChanged {
				_ = windows.VirtualProtectEx(r.process, addr, uintptr(r.Size(addr)), prevProtection, &prevProtection)
			}
		}()
	}
	if isAccessible || isAccessChanged {
		n, b, err := r.read(addr, size, minSize)
		if n == 0 && (r.protect&windows.PAGE_GUARD) != 0 {
			// guarded page. Try to read again
			n, b, err = r.read(addr, size, minSize)
		}
		if n == 0 || err != nil {
			return 0, nil
		}
		return n, b
	}
	return 0, nil
}

// read allocates a buffer with maximum buffer size and attempts to
// read the memory chunk from the specified base address.
// If reading of the full buffer size was not possible, it will keep
// trying to read a smaller chunk, decreasing requested size on each
// attempt, until the minimal size is reached. This is a workaround for
// errors such as FAULTY_HARDWARE_CORRUPTED_PAGE. It returns how many
// bytes were successfully read, the memory buffer and an error in case
// of unrecoverable errors have occurred.
func (r Region) read(addr uintptr, bufSize, minSize uint) (uint, []byte, error) {
	size := uintptr(0)
	b := make([]byte, bufSize)
	err := windows.ReadProcessMemory(r.process, addr, &b[0], uintptr(bufSize), &size)
	if err == nil {
		// the entire memory chunk was read
		return uint(size), b, nil
	}
	if size == 0 && err != windows.ERROR_PARTIAL_COPY {
		// no data was read
		return 0, nil, err
	}
	if err == windows.ERROR_PARTIAL_COPY {
		// data partially read. Get readable size
		size = uintptr(r.seek(addr, b, bufSize, minSize))
	}
	if size > 0 {
		// have minimal readable size
		b = make([]byte, size)
		err := windows.ReadProcessMemory(r.process, addr, &b[0], size, &size)
		if err != nil {
			return 0, nil, err
		}
		return uint(size), b, nil
	}
	return 0, nil, nil
}

// seek performs a binary search via ReadProcessMemory, trying to find
// the biggest size of memory chunk within the buffer size that can be
// read. The search stops when the minimal size is reached. The given
// minimal size must be non-zero, and smaller than the buffer size.
func (r Region) seek(addr uintptr, buf []byte, bufSize, minSize uint) uint {
	if buf == nil || bufSize == 0 {
		return 0
	}
	if bufSize < minSize || minSize == 0 {
		return 0
	}
	size := uintptr(0)
	err := windows.ReadProcessMemory(r.process, addr, &buf[0], uintptr(minSize), &size)
	if err != nil {
		return uint(size)
	}
	n := bufSize / 2
	successSize := minSize
	failedSize := bufSize
	for n > minSize && n < bufSize {
		size = 0
		err := windows.ReadProcessMemory(r.process, addr, &buf[0], uintptr(n), &size)
		if err != nil {
			failedSize = n
		} else {
			successSize = n
		}
		delta := (failedSize - successSize) / 2
		if delta == 0 {
			break
		}
		n = delta + successSize
	}
	return successSize
}

```

`pkg/util/va/region_test.go`:

```go
/*
 * Copyright 2021-2022 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package va

import (
	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/require"
	"golang.org/x/sys/windows"
	"os"
	"testing"
	"time"
	"unsafe"
)

func TestRegionProber(t *testing.T) {
	base, err := windows.VirtualAlloc(0, 1024, windows.MEM_COMMIT|windows.MEM_RESERVE, windows.PAGE_READONLY)
	require.NoError(t, err)
	defer func() {
		_ = windows.VirtualFree(base, 1024, windows.MEM_DECOMMIT)
	}()
	pid := uint32(os.Getpid())

	regionProber := NewRegionProber()
	region := regionProber.Query(pid, uint64(base))

	require.NotNil(t, region)
	regionProber.mu.Lock()
	require.True(t, regionProber.procs[pid] != windows.InvalidHandle)
	regionProber.mu.Unlock()

	assert.Equal(t, uint32(windows.PAGE_READONLY), region.Protect)
	assert.Equal(t, "R", region.ProtectMask())
	assert.False(t, region.IsMapped())
	assert.Equal(t, MemPrivate, region.Type)

	// test limiter
	for i := 0; i < 499; i++ {
		assert.NotNil(t, regionProber.Query(pid, uint64(base)))
	}
	// all buckets consumed
	assert.Nil(t, regionProber.Query(pid, uint64(base)))

	// wait for the buckets to get refilled
	time.Sleep(time.Second)
	for i := 0; i < 300; i++ {
		assert.NotNil(t, regionProber.Query(pid, uint64(base)))
	}

	require.True(t, regionProber.Remove(pid))
}

func TestReadRegion(t *testing.T) {
	addr, err := getModuleBaseAddress(uint32(os.Getpid()))
	require.NoError(t, err)
	rgn, err := NewRegion(windows.CurrentProcess(), addr)
	require.NoError(t, err)
	require.True(t, rgn.Size(addr) > 0)

	size, b := rgn.Read(addr, uint(os.Getpagesize()), 0x100, false)
	require.True(t, size > 0)
	require.Len(t, b, os.Getpagesize())
	// verify it is the DOS header
	require.Equal(t, 'M', rune(b[0]))
	require.Equal(t, 'Z', rune(b[1]))

	var oldProtect uint32
	_ = windows.VirtualProtectEx(windows.CurrentProcess(), addr, uintptr(rgn.Size(addr)), windows.PAGE_NOACCESS, &oldProtect)

	size, b = rgn.Read(addr, uint(os.Getpagesize()), 0x100, false)
	// shouldn't be able to read the region
	require.True(t, size == 0)
	require.Len(t, b, 0)
	_ = windows.VirtualProtectEx(windows.CurrentProcess(), addr, uintptr(rgn.Size(addr)), oldProtect, &oldProtect)

	_ = windows.VirtualProtectEx(windows.CurrentProcess(), addr, 4096, windows.PAGE_NOACCESS, &oldProtect)
	defer func() {
		_ = windows.VirtualProtectEx(windows.CurrentProcess(), addr, 4096, oldProtect, &oldProtect)
	}()

	noAccessRgn, err := NewRegion(windows.CurrentProcess(), addr)
	require.NoError(t, err)

	size, b = noAccessRgn.Read(addr, uint(os.Getpagesize()), 0x100, true)
	// force protection changing, so should be able to read the region
	require.True(t, size > 0)
	require.Len(t, b, os.Getpagesize())
}

func TestReadArea(t *testing.T) {
	addr, err := getModuleBaseAddress(uint32(os.Getpid()))
	require.NoError(t, err)

	area := ReadArea(windows.CurrentProcess(), addr, uint(os.Getpagesize()), 0x100, false)
	require.Len(t, area, os.Getpagesize())
	require.False(t, Zeroed(area))

	// allocate region with no access protection
	base, err := windows.VirtualAlloc(0, 1024, windows.MEM_COMMIT|windows.MEM_RESERVE, windows.PAGE_NOACCESS)
	require.NoError(t, err)
	defer func() {
		_ = windows.VirtualFree(base, 1024, windows.MEM_DECOMMIT)
	}()
	var oldProtect uint32
	_ = windows.VirtualProtectEx(windows.CurrentProcess(), base, 16, windows.PAGE_NOACCESS, &oldProtect)

	// it should read all bytes set to zero
	zeroArea := ReadArea(windows.CurrentProcess(), base, 4096, 0x100, false)
	require.Len(t, zeroArea, 4096)
	require.True(t, Zeroed(zeroArea))
}

func TestQueryWorkingSet(t *testing.T) {
	addr, err := getModuleBaseAddress(uint32(os.Getpid()))
	require.NoError(t, err)

	b := QueryWorkingSet(windows.CurrentProcess(), uint64(addr))
	require.NotNil(t, b)

	require.True(t, b.Valid())
	require.False(t, b.Bad())
	require.True(t, b.SharedOriginal())
	require.True(t, (b.Win32Protection()&windows.PAGE_READONLY) != 0)
}

func getModuleBaseAddress(pid uint32) (uintptr, error) {
	var moduleHandles [1024]windows.Handle
	var cbNeeded uint32
	proc, err := windows.OpenProcess(windows.PROCESS_QUERY_INFORMATION|windows.PROCESS_VM_READ, false, pid)
	if err != nil {
		return 0, err
	}
	if err := windows.EnumProcessModules(proc, &moduleHandles[0], 1024, &cbNeeded); err != nil {
		return 0, err
	}
	moduleHandle := moduleHandles[0]
	var moduleInfo windows.ModuleInfo
	if err := windows.GetModuleInformation(proc, moduleHandle, &moduleInfo, uint32(unsafe.Sizeof(moduleInfo))); err != nil {
		return 0, err
	}
	return moduleInfo.BaseOfDll, nil
}

```

`pkg/util/version/version.go`:

```go
/*
 * Copyright 2020-2021 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package version

import (
	"fmt"
	semver "github.com/hashicorp/go-version"
	"os"
	"regexp"
	"runtime"
	"strconv"
	"strings"
	"sync"

	"github.com/jedib0t/go-pretty/v6/table"
)

// Version stores the SemVer release information along with the
// commit that produced the release and other useful information.
type Version struct {
	Major  int64
	Minor  int64
	Patch  int64
	Commit string
	Date   string
}

var versionRegexp = regexp.MustCompile(`(\d+\.\d+\.\d+)`)

var version string

var once sync.Once
var sem *semver.Version

// Set initializes the version string as global variable.
func Set(v string) { version = v }

// Get returns the version string.
func Get() string {
	if IsDev() {
		return "dev"
	}
	return version
}

// IsDev determines if this is a dev version.
func IsDev() bool { return version == "0.0.0" || version == "" }

// Sem returns a semver spec.
func Sem() *semver.Version {
	once.Do(func() {
		var err error
		sem, err = semver.NewSemver(version)
		if err != nil {
			panic(err)
		}
	})
	return sem
}

// ProductToken returns a tag to be poked in User Agent headers.
func ProductToken() string { return fmt.Sprintf("fibratus/%s", version) }

// New parses the version string and return the version instance.
func New(version, commit, date string) Version {
	if version == "" {
		return Version{Commit: commit, Date: date}
	}

	toks := versionRegexp.FindStringSubmatch(version)
	if len(toks) == 0 || toks[0] != version {
		panic(fmt.Sprintf("invalid semver release: %s", version))
	}

	// split version info
	parts := strings.Split(toks[1], ".")
	major, _ := strconv.ParseInt(parts[0], 10, 64)
	minor, _ := strconv.ParseInt(parts[1], 10, 64)
	patch, _ := strconv.ParseInt(parts[2], 10, 64)

	v := Version{
		Major:  major,
		Minor:  minor,
		Patch:  patch,
		Commit: commit,
		Date:   date,
	}

	return v
}

// Render dumps the version information to stdout.
func (v Version) Render() {
	t := table.NewWriter()
	t.SetOutputMirror(os.Stdout)
	t.SetStyle(table.StyleLight)

	var version string
	if v.Major == 0 && v.Minor == 0 && v.Patch == 0 {
		version = "dev"
	} else {
		version = fmt.Sprintf("%d.%d.%d", v.Major, v.Minor, v.Patch)
	}

	t.AppendRow(table.Row{"Version", version})
	t.AppendRow(table.Row{"Commit", v.Commit})
	t.AppendRow(table.Row{"Build date", v.Date})

	t.AppendSeparator()

	t.AppendRow(table.Row{"Go compiler", runtime.Version()})

	t.Render()
}

```

`pkg/util/wildcard/wildcard.go`:

```go
/*
 *	Copyright 2019-present by Nedim Sabic
 *	http://rabbitstack.github.io
 *	All Rights Reserved.
 *
 *	Licensed under the Apache License, Version 2.0 (the "License"); you may
 *	not use this file except in compliance with the License. You may obtain
 *	a copy of the License at
 *
 *	http://www.apache.org/licenses/LICENSE-2.0
 */

package wildcard

import "unicode/utf8"

// Match performs ASCII-first, iterative wildcard matching with UTF-8 fallback.
// It supports  '*' and '?' wildcards in the pattern string.
func Match(pattern, str string) bool {
	slen := len(str)
	plen := len(pattern)

	var p, s int
	wildcardIdx, matchIdx := -1, 0

	for s < slen {
		if p < plen {
			pb := pattern[p]

			switch pb {
			case '?':
				// match exactly one character
				if str[s] < utf8.RuneSelf && pb < utf8.RuneSelf {
					p++
					s++
				} else {
					_, psize := utf8.DecodeRuneInString(pattern[p:])
					_, ssize := utf8.DecodeRuneInString(str[s:])
					p += psize
					s += ssize
				}
				continue

			case '*':
				// record wildcard position
				wildcardIdx = p
				matchIdx = s
				p++
				continue

			default:
				// literal match
				if pb < utf8.RuneSelf && str[s] < utf8.RuneSelf {
					if pb == str[s] {
						p++
						s++
						continue
					}
				} else {
					pr, psize := utf8.DecodeRuneInString(pattern[p:])
					sr, ssize := utf8.DecodeRuneInString(str[s:])
					if pr == sr {
						p += psize
						s += ssize
						continue
					}
				}
			}
		}

		// backtrack if there was a previous '*'
		if wildcardIdx != -1 {
			p = wildcardIdx + 1
			matchIdx++
			s = matchIdx
			continue
		}

		// previous '*', and mismatch
		return false
	}

	// Skip remaining stars in pattern
	for p < plen && pattern[p] == '*' {
		p++
	}

	return p == plen
}

```

`pkg/util/wildcard/wildcard_test.go`:

```go
/*
 *	Copyright 2019-present by Nedim Sabic
 *	http://rabbitstack.github.io
 *	All Rights Reserved.
 *
 *	Licensed under the Apache License, Version 2.0 (the "License"); you may
 *	not use this file except in compliance with the License. You may obtain
 *	a copy of the License at
 *
 *	http://www.apache.org/licenses/LICENSE-2.0
 */

package wildcard

import (
	"testing"

	"github.com/stretchr/testify/assert"
)

func TestMatch(t *testing.T) {
	var tests = []struct {
		p     string
		s     string
		match bool
	}{
		{"C:\\*\\lsass?.dmp", "C:\\Windows\\System32\\lsass2.dmp", true},
		{"?:\\*\\lsass?.dmp", "C:\\Windows\\System32\\lsass2.dmp", true},
		{"?:\\*\\lsass?.dmp", "C:\\Windows\\System32\\cmd.exe", false},
		{"C:\\*\\ActionList.x?l", "C:\\Windows\\Setup\\LatentAcquisition\\ActionList.xml", true},
		{"C:\\ProgramData\\*.dll", "C:\\ProgramData\\Directory\\OneMoreDirectory\\mal.dll", true},
		{"HKEY_USERS\\*\\Environment\\windir", "HKEY_USERS\\S-1-5-21-2271034452-2606270099-984871569-1001\\Environment\\windir", true},
		{"C:\\Windows\\SoftwareDistribution\\*", "C:\\Windows\\SoftwareDistribution\\SLS\\7971F918-A847-4430-9279-4A52D1EFE18D\\sls.rar", true},
		{"HKEY_USERS\\S-1-5-21-*_CLASSES\\MS-SETTINGS\\CURVER", "HKEY_USERS\\S-1-5-21-2271034452-1207270099-244871569-1021_CLASSES\\MS-SETTINGS\\CURVER", true},
		{"ntdll.dll|KernelBase.dll|advapi32.dll|*", "ntdll.dll|KernelBase.dll|advapi32.dll|pe386.dll|com.dll|clr.dll|mmc.exe", true},
	}

	for _, tt := range tests {
		t.Run(tt.p, func(t *testing.T) {
			assert.Equal(t, tt.match, Match(tt.p, tt.s))
		})
	}
}

```

`pkg/yara/_fixtures/rules/notepad.yar`:

```yar
rule Np : T1 T2
{
	meta:
		severity = 50
		date = "2016-07"
		threat_name = "Notepad.Shell"
		id = "babf9101-1e6e-4268-a530-e99e2c905b0d"
	strings:
		$c1 = "Notepad" fullword ascii
	condition:
		$c1
}

```

`pkg/yara/_fixtures/rules/regedit.yar`:

```yar
rule Regedit : T1
{
	meta:
		severity = 50
		date = "2016-07"
		threat_name = "Regedit"
		id = "1abf9101-1e6e-4268-a530-e99e2c905b0d"
	strings:
		$c1 = "Regedit" nocase fullword ascii
	condition:
		$c1
}

```

`pkg/yara/config/config.go`:

```go
/*
 * Copyright 2019-2020 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package config

import (
	"bytes"
	"fmt"
	"github.com/mitchellh/mapstructure"
	"github.com/rabbitstack/fibratus/pkg/event"
	"github.com/rabbitstack/fibratus/pkg/event/params"
	"github.com/rabbitstack/fibratus/pkg/util/wildcard"
	ytypes "github.com/rabbitstack/fibratus/pkg/yara/types"
	"github.com/spf13/pflag"
	"github.com/spf13/viper"
	"strings"
	"text/template"
	"time"
)

const (
	enabled           = "yara.enabled"
	alertTemplate     = "yara.alert-template"
	fastScanMode      = "yara.fastscan"
	scanTimeout       = "yara.scan-timeout"
	skipFiles         = "yara.skip-files"
	skipAllocs        = "yara.skip-allocs"
	skipMmaps         = "yara.skip-mmaps"
	skipRegistry      = "yara.skip-registry"
	excludedProcesses = "yara.excluded-procs"
	excludedFiles     = "yara.excluded-files"
)

const (
	FileThreatAlertTitle   = "File Threat Detected"
	MemoryThreatAlertTitle = "Memory Threat Detected"
)

// RulePath contains the rule path information.
type RulePath struct {
	Path      string `json:"path" yaml:"path" mapstructure:"path"`
	Namespace string `json:"namespace" yaml:"namespace" mapstructure:"namespace"`
}

// RuleString contains the in-place strings for the rule definition.
type RuleString struct {
	String    string `json:"string" yaml:"string" mapstructure:"string"`
	Namespace string `json:"namespace" yaml:"namespace" mapstructure:"namespace"`
}

// Rule contains rule-specific settings.
type Rule struct {
	// Paths defines the location of the yara rules
	Paths []RulePath `json:"yara.rule.paths" yaml:"yara.rule.paths" mapstructure:"paths"`
	// Strings contains the raw rule definitions
	Strings []RuleString `json:"yara.rule.strings" yaml:"yara.rule.strings" mapstructure:"strings"`
}

// Config stores YARA scanner specific configuration.
type Config struct {
	// Enabled indicates if YARA watcher is enabled.
	Enabled bool `json:"yara.enabled" yaml:"yara.enabled"`
	// Rule contains rule-specific settings.
	Rule Rule `json:"yara.rule" yaml:"yara.rule" mapstructure:"rule"`
	// AlertTemplate represents the template for the alert title
	AlertTemplate string `json:"yara.alert-template" yaml:"yara.alert-template"`
	// FastScanMode avoids multiple matches of the same string when not necessary.
	FastScanMode bool `json:"yara.fastscan" yaml:"yara.fastscan"`
	// ScanTimeout sets the timeout for the scanner. If the timeout is reached, the scan operation is cancelled.
	ScanTimeout time.Duration `json:"yara.scan-timeout" yaml:"yara.scan-timeout"`
	// SkipFiles indicates whether file scanning is disabled.
	SkipFiles bool `json:"yara.skip-files" yaml:"yara.skip-files"`
	// SkipAllocs indicates whether scanning on suspicious memory allocations is disabled.
	SkipAllocs bool `json:"yara.skip-allocs" yaml:"yara.skip-allocs"`
	// SkipMmaps indicates whether scanning on suspicious mappings of sections is disabled.
	SkipMmaps bool `json:"yara.skip-mmaps" yaml:"yara.skip-mmaps"`
	// SkipRegistry indicates whether registry value scanning is disabled.
	SkipRegistry bool `json:"yara.skip-registry" yaml:"yara.skip-registry"`
	// ExcludedProcesses contains the list of the comma-separated process image paths that shouldn't be scanned.
	// Wildcard matching is possible.
	ExcludedProcesses []string `json:"yara.excluded-procs" yaml:"yara.excluded-procs"`
	// ExcludedProcesses contains the list of the comma-separated file paths that shouldn't be scanned.
	// Wildcard matching is possible.
	ExcludedFiles []string `json:"yara.excluded-files" yaml:"yara.excluded-files"`
}

// InitFromViper initializes Yara config from Viper.
func (c *Config) InitFromViper(v *viper.Viper) {
	c.Enabled = v.GetBool(enabled)
	c.AlertTemplate = v.GetString(alertTemplate)
	c.FastScanMode = v.GetBool(fastScanMode)
	c.ScanTimeout = v.GetDuration(scanTimeout)
	c.SkipFiles = v.GetBool(skipFiles)
	c.SkipAllocs = v.GetBool(skipAllocs)
	c.SkipMmaps = v.GetBool(skipMmaps)
	c.SkipRegistry = v.GetBool(skipRegistry)
	c.ExcludedFiles = v.GetStringSlice(excludedFiles)
	c.ExcludedProcesses = v.GetStringSlice(excludedProcesses)

	all := v.AllSettings()
	if _, ok := all["yara"]; !ok {
		return
	}
	if _, ok := all["yara"].(map[string]interface{}); !ok {
		return
	}

	var r Rule
	_ = decode(all["yara"].(map[string]interface{})["rule"], &r)
	c.Rule = r
}

// AddFlags registers persistent flags.
func AddFlags(flags *pflag.FlagSet) {
	flags.Bool(enabled, false, "Specifies if Yara scanner is enabled")
	flags.String(alertTemplate, "", "Defines the template that is used to render the alert. By default only the threat/rule name is rendered")
	flags.Bool(fastScanMode, true, "Avoids multiple matches of the same string when not necessary")
	flags.Duration(scanTimeout, time.Second*10, "Specifies the timeout for the scanner. If the timeout is reached, the scan operation is cancelled")
	flags.Bool(skipFiles, false, "Indicates whether file scanning is disabled")
	flags.Bool(skipAllocs, false, "Indicates whether scanning on suspicious memory allocations is disabled")
	flags.Bool(skipMmaps, false, "Indicates whether scanning on suspicious mappings of sections is disabled")
	flags.Bool(skipRegistry, false, "Indicates whether registry value scanning is disabled")
	flags.StringSlice(excludedFiles, []string{}, "Contains the list of the comma-separated file paths that shouldn't be scanned. Wildcard matching is possible")
	flags.StringSlice(excludedProcesses, []string{}, "Contains the list of the comma-separated process image paths that shouldn't be scanned. Wildcard matching is possible")
}

// ShouldSkipProcess determines whether the specified full process image path is rejected by the scanner.
// Wildcard matching is possible.
func (c Config) ShouldSkipProcess(proc string) bool {
	for _, p := range c.ExcludedProcesses {
		if wildcard.Match(strings.ToLower(p), strings.ToLower(proc)) {
			return true
		}
	}
	return false
}

// ShouldSkipFile determines whether the specified full file path is rejected by the scanner.
func (c Config) ShouldSkipFile(file string) bool {
	for _, f := range c.ExcludedFiles {
		if wildcard.Match(strings.ToLower(f), strings.ToLower(file)) {
			return true
		}
	}
	return false
}

// AlertTitle returns the brief alert title depending on
// whether the process scan took place or a file/registry
// key was scanned.
func (c Config) AlertTitle(e *event.Event) string {
	if (e.Category == event.File && e.GetParamAsString(params.FilePath) != "") || e.Category == event.Registry {
		return FileThreatAlertTitle
	}
	return MemoryThreatAlertTitle
}

// AlertText returns the short alert text if the Go template is
// not specified. On the contrary, the provided Go template is
// parsed and executing yielding the alert text.
func (c Config) AlertText(e *event.Event, match ytypes.MatchRule) (string, error) {
	if c.AlertTemplate == "" {
		threat := match.ThreatName()
		if threat == "" {
			threat = match.Rule
		}
		return fmt.Sprintf("Threat detected %s", threat), nil
	}

	var writer bytes.Buffer
	var data = struct {
		Match ytypes.MatchRule
		Event *event.Event
	}{
		match,
		e,
	}

	tmpl, err := template.New("yara").Parse(c.AlertTemplate)
	if err != nil {
		return "", fmt.Errorf("yara alert template syntax error: %v", err)
	}
	err = tmpl.Execute(&writer, data)
	if err != nil {
		return "", fmt.Errorf("couldn't execute yara alert template: %v", err)
	}

	return writer.String(), nil
}

func decode(input, output interface{}) error {
	var decoderConfig = &mapstructure.DecoderConfig{
		Metadata:         nil,
		Result:           output,
		WeaklyTypedInput: true,
		DecodeHook: mapstructure.ComposeDecodeHookFunc(
			mapstructure.StringToTimeDurationHookFunc(),
			mapstructure.StringToSliceHookFunc(","),
		),
	}
	decoder, err := mapstructure.NewDecoder(decoderConfig)
	if err != nil {
		return err
	}
	return decoder.Decode(input)
}

```

`pkg/yara/config/config_test.go`:

```go
/*
 * Copyright 2021-2022 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package config

import (
	"errors"
	"github.com/rabbitstack/fibratus/pkg/event"
	"github.com/rabbitstack/fibratus/pkg/event/params"
	ytypes "github.com/rabbitstack/fibratus/pkg/yara/types"
	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/require"
	"testing"
)

func TestShouldSkipProcess(t *testing.T) {
	var tests = []struct {
		c    Config
		proc string
		skip bool
	}{
		{
			Config{ExcludedProcesses: []string{"C:\\Windows\\System32\\svchost.exe"}},
			"C:\\Windows\\System32\\svchost.exe",
			true,
		},
		{
			Config{ExcludedProcesses: []string{"?:\\Windows\\System32\\svchost.exe"}},
			"C:\\Windows\\System32\\svchost.exe",
			true,
		},
		{
			Config{ExcludedProcesses: []string{"?:\\Windows\\*\\svchost.exe"}},
			"C:\\WINDOWS\\System32\\svchost.exe",
			true,
		},
		{
			Config{ExcludedProcesses: []string{"?:\\Windows\\*\\*.exe"}},
			"C:\\Windows\\System32\\svchost.exe",
			true,
		},
		{
			Config{ExcludedProcesses: []string{"?:\\Windows\\*\\*.exe"}},
			"C:\\Windows\\hh.exe",
			false,
		},
	}

	for _, tt := range tests {
		t.Run(tt.proc, func(t *testing.T) {
			assert.Equal(t, tt.skip, tt.c.ShouldSkipProcess(tt.proc))
		})
	}
}

func TestShouldSkipFile(t *testing.T) {
	var tests = []struct {
		c    Config
		file string
		skip bool
	}{
		{
			Config{ExcludedFiles: []string{"C:\\Windows\\System32\\svchost.exe"}},
			"C:\\Windows\\System32\\svchost.exe",
			true,
		},
		{
			Config{ExcludedFiles: []string{"?:\\Windows\\System32\\svchost.exe", "?:\\Program Files\\*\\*.exe"}},
			"C:\\Program Files\\dotnet\\dotnet.exe",
			true,
		},
		{
			Config{ExcludedFiles: []string{"?:\\Windows\\*\\svchost.exe"}},
			"C:\\Program Files\\dotnet\\dotnet.exe",
			false,
		},
		{
			Config{ExcludedFiles: []string{"?:\\Windows\\*\\*.exe", "C:\\Program Files\\Logs\\*\\*.dll"}},
			"C:\\Program Files\\dotnet\\sdk\\8.0.300\\Microsoft.build.dll",
			false,
		},
	}

	for _, tt := range tests {
		t.Run(tt.file, func(t *testing.T) {
			assert.Equal(t, tt.skip, tt.c.ShouldSkipFile(tt.file))
		})
	}
}

func TestAlertTitle(t *testing.T) {
	var tests = []struct {
		e *event.Event
		t string
	}{
		{
			&event.Event{Type: event.MapViewFile, Category: event.File},
			MemoryThreatAlertTitle,
		},
		{
			&event.Event{Type: event.MapViewFile, Category: event.File,
				Params: event.Params{params.FilePath: {Name: params.FilePath, Type: params.UnicodeString, Value: "C:\\Windows\\System32\\wusa.exe"}},
			},
			FileThreatAlertTitle,
		},
		{
			&event.Event{Type: event.RegSetValue, Category: event.Registry},
			FileThreatAlertTitle,
		},
		{
			&event.Event{Type: event.LoadImage, Category: event.Image},
			MemoryThreatAlertTitle,
		},
	}

	for _, tt := range tests {
		t.Run(tt.t, func(t *testing.T) {
			c := Config{}
			assert.Equal(t, tt.t, c.AlertTitle(tt.e))
		})
	}
}

func TestAlertText(t *testing.T) {
	var tests = []struct {
		name string
		c    Config
		e    *event.Event
		m    ytypes.MatchRule
		text string
		err  error
	}{
		{
			"empty template and no threat_name meta",
			Config{},
			&event.Event{Type: event.LoadImage, Category: event.Image},
			ytypes.MatchRule{Rule: "Badlands Trojan"},
			"Threat detected Badlands Trojan",
			nil,
		},
		{
			"empty template and threat_name meta",
			Config{},
			&event.Event{Type: event.LoadImage, Category: event.Image},
			ytypes.MatchRule{Rule: "Badlands Trojan", Metas: []ytypes.Meta{{Identifier: "threat_name", Value: "Gravity Trojan"}}},
			"Threat detected Gravity Trojan",
			nil,
		},
		{
			"template given in config",
			Config{
				AlertTemplate: `
				Rule name: {{ .Match.Rule }}
				Event name: {{ .Event.Name -}}
				`,
			},
			&event.Event{Type: event.LoadImage, Name: "LoadImage", Category: event.Image},
			ytypes.MatchRule{Rule: "Badlands Trojan", Metas: []ytypes.Meta{{Identifier: "threat_name", Value: "Gravity Trojan"}}},
			`
				Rule name: Badlands Trojan
				Event name: LoadImage`,
			nil,
		},
		{
			"invalid template given in config",
			Config{
				AlertTemplate: `
				Rule name: {{ .....Match.Rule }}
				Event name: {{ .Evet.Name -}}
				`,
			},
			&event.Event{Type: event.LoadImage, Name: "LoadImage", Category: event.Image},
			ytypes.MatchRule{Rule: "Badlands Trojan", Metas: []ytypes.Meta{{Identifier: "threat_name", Value: "Gravity Trojan"}}},
			"",
			errors.New("yara alert template syntax error"),
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			text, err := tt.c.AlertText(tt.e, tt.m)
			if tt.err != nil && err == nil {
				require.Error(t, tt.err)
			}
			assert.Equal(t, tt.text, text)
		})
	}
}

```

`pkg/yara/scanner.go`:

```go
//go:build yara
// +build yara

/*
 * Copyright 2019-2020 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package yara

import (
	"encoding/json"
	"expvar"
	"fmt"
	"github.com/google/uuid"
	"github.com/rabbitstack/fibratus/pkg/alertsender"
	"github.com/rabbitstack/fibratus/pkg/event/params"
	libntfs "github.com/rabbitstack/fibratus/pkg/fs/ntfs"
	"github.com/rabbitstack/fibratus/pkg/sys"
	"github.com/rabbitstack/fibratus/pkg/util/signature"
	"github.com/rabbitstack/fibratus/pkg/util/va"
	"golang.org/x/sys/windows"
	"golang.org/x/sys/windows/registry"
	"os"
	"path/filepath"
	"strings"

	"github.com/hillu/go-yara/v4"
	"github.com/rabbitstack/fibratus/pkg/event"
	"github.com/rabbitstack/fibratus/pkg/ps"
	"github.com/rabbitstack/fibratus/pkg/util/multierror"
	"github.com/rabbitstack/fibratus/pkg/yara/config"
	ytypes "github.com/rabbitstack/fibratus/pkg/yara/types"
	log "github.com/sirupsen/logrus"
)

var (
	// ruleMatches computes all the rule matches
	ruleMatches = expvar.NewInt("yara.rule.matches")
	// rulesInCompiler keeps the counter of the number of rules in the compiler
	rulesInCompiler = expvar.NewInt("yara.rules.in.compiler")
	// totalScans computes the number of process/file scans
	totalScans = expvar.NewInt("yara.total.scans")

	procScans     = expvar.NewInt("yara.proc.spawned.scans")
	moduleScans   = expvar.NewInt("yara.module.loaded.scans")
	fileScans     = expvar.NewInt("yara.file.created.scans")
	streamScans   = expvar.NewInt("yara.ads.created.scans")
	allocScans    = expvar.NewInt("yara.alloc.scans")
	mmapScans     = expvar.NewInt("yara.mmap.scans")
	registryScans = expvar.NewInt("yara.registry.value.set.scans")
)

type scanner struct {
	c      *yara.Compiler
	rules  *yara.Rules
	config config.Config

	psnap ps.Snapshotter

	rwxs  map[uint32]va.Address // contains scanned and matched RWX process allocations
	mmaps map[uint32]va.Address // contains scanned and matched suspicious memory mappings
}

// NewScanner creates a new YARA scanner.
func NewScanner(psnap ps.Snapshotter, config config.Config) (Scanner, error) {
	c, err := yara.NewCompiler()
	if err != nil {
		return nil, fmt.Errorf("unable to create yara compiler: %v", err)
	}
	// add yara rules from file system paths by walking the dirs recursively
	for _, dir := range config.Rule.Paths {
		f, err := os.Stat(dir.Path)
		if err != nil {
			log.Warnf("cannot access %q rule path: %v", dir.Path, err)
			continue
		}
		if !f.IsDir() {
			continue
		}
		err = filepath.Walk(dir.Path, func(path string, fi os.FileInfo, err error) error {
			if filepath.Ext(path) != ".yar" {
				return nil
			}
			f, err := os.Open(path)
			if err != nil {
				log.Warnf("cannot open the rule %q: %v", path, err)
				return nil
			}
			err = c.AddFile(f, dir.Namespace)
			_ = f.Close()
			if err != nil {
				log.Warnf("couldn't add %s rule: %v", fi.Name(), err)
				return nil
			}
			rulesInCompiler.Add(1)
			log.Infof("loading yara rule(s) from %s", path)

			return nil
		})
		if err != nil {
			log.Warnf("couldn't walk %s path: %v", dir.Path, err)
		}
	}

	// add yara rules from config strings
	for _, s := range config.Rule.Strings {
		err := c.AddString(s.String, s.Namespace)
		if err != nil {
			log.Warnf("couldn't add %s rule string: %v", s.String, err)
			continue
		}
		rulesInCompiler.Add(1)
	}

	if len(c.Errors) > 0 {
		return nil, parseCompilerErrors(c.Errors)
	}

	rules, err := c.GetRules()
	if err != nil {
		return nil, fmt.Errorf("couldn't compile yara rules: %v", err)
	}

	return &scanner{
		c:      c,
		rules:  rules,
		config: config,
		psnap:  psnap,
		rwxs:   make(map[uint32]va.Address),
		mmaps:  make(map[uint32]va.Address),
	}, nil
}

// newInternalScanner creates a new instance of the go-yara scanner.
func (s scanner) newInternalScanner() (*yara.Scanner, error) {
	sn, err := yara.NewScanner(s.rules)
	if err != nil {
		return nil, fmt.Errorf("fail to create yara scanner: %v", err)
	}
	// set scan flags
	var flags yara.ScanFlags
	if s.config.FastScanMode {
		flags |= yara.ScanFlagsFastMode
	}
	sn.SetFlags(flags)
	sn.SetTimeout(s.config.ScanTimeout)
	return sn, nil
}

func parseCompilerErrors(errors []yara.CompilerMessage) error {
	errs := make([]error, len(errors))
	for i, err := range errors {
		errs[i] = fmt.Errorf("%s, filename: %s line: %d", err.Text, err.Filename, err.Line)
	}
	return multierror.Wrap(errs...)
}

func (s scanner) CanEnqueue() bool { return false }

func (s *scanner) ProcessEvent(evt *event.Event) (bool, error) {
	if evt.IsTerminateProcess() {
		// cleanup
		pid := evt.Params.MustGetPid()
		delete(s.rwxs, pid)
		delete(s.mmaps, pid)
	}
	return s.Scan(evt)
}

func (s scanner) Scan(e *event.Event) (bool, error) {
	var matches yara.MatchRules
	var isScanned bool
	var err error

	switch e.Type {
	case event.CreateProcess:
		// scan the created child process
		pid := e.Params.MustGetPid()
		log.Debugf("scanning child process. pid: %d, exe: %s", pid, e.GetParamAsString(params.Exe))
		matches, err = s.scan(pid)
		procScans.Add(1)
		isScanned = true
	case event.LoadImage:
		// scan the process loading unsigned/untrusted module
		// or loading the module from unbacked memory region
		pid := e.PID
		addr := e.Params.MustGetUint64(params.ImageBase)
		typ := e.Params.MustGetUint32(params.ImageSignatureType)
		if typ != signature.None {
			return false, nil
		}
		filename := e.GetParamAsString(params.ImagePath)
		if s.config.ShouldSkipFile(filename) {
			return false, nil
		}

		// get module signature
		sign := signature.GetSignatures().GetSignature(addr)
		if sign == nil {
			sign = &signature.Signature{Filename: filename}
			sign.Type, sign.Level, err = sign.Check()
			if sign.IsSigned() {
				sign.Verify()
			}
		}

		if !sign.IsSigned() || !sign.IsTrusted() || (!e.Callstack.IsEmpty() && e.Callstack.ContainsUnbacked()) {
			log.Debugf("scanning suspicious module loading. pid: %d, module: %s", pid, filename)
			matches, err = s.scan(pid)
			moduleScans.Add(1)
			isScanned = true
		}
	case event.CreateFile:
		if s.config.SkipFiles {
			return false, nil
		}
		if e.IsOpenDisposition() {
			return false, nil
		}

		filename := e.GetParamAsString(params.FilePath)
		if s.config.ShouldSkipFile(filename) || (e.PS != nil && s.config.ShouldSkipProcess(e.PS.Exe)) {
			return false, nil
		}

		// scan dropped PE files
		isDLL := strings.ToLower(filepath.Ext(filename)) == ".dll" || e.Params.TryGetBool(params.FileIsDLL)
		isDriver := strings.ToLower(filepath.Ext(filename)) == ".sys" || e.Params.TryGetBool(params.FileIsDriver)
		isExe := strings.ToLower(filepath.Ext(filename)) == ".exe" || e.Params.TryGetBool(params.FileIsExecutable)

		if isExe || isDLL || isDriver {
			log.Debugf("scanning PE file %s. pid: %d", filename, e.PID)
			matches, err = s.scan(filename)
			fileScans.Add(1)
			isScanned = true
			break
		}

		// scan dropped ADS (Alternate Data Stream)
		n := strings.LastIndex(filename, ":")
		ads := n > 2 && n+1 <= len(filename)
		if !ads {
			return false, nil
		}
		// read ADS data
		ntfs := libntfs.NewFS()
		data, n, err := ntfs.Read(filename, 0, 1024*1024)
		defer ntfs.Close()
		if err != nil {
			return false, nil
		}
		if n > 0 {
			data = data[:n]
			log.Debugf("scanning ADS %s. pid: %d", filename, e.PID)
			matches, err = s.scan(data)
			streamScans.Add(1)
			isScanned = true
		}
	case event.VirtualAlloc:
		if s.config.SkipAllocs {
			return false, nil
		}
		// scan process allocating RWX memory region
		pid := e.Params.MustGetPid()
		addr := e.Params.TryGetAddress(params.MemBaseAddress)
		if e.PID != 4 && e.Params.TryGetUint32(params.MemProtect) == windows.PAGE_EXECUTE_READWRITE && !s.isRwxMatched(pid) {
			log.Debugf("scanning RWX allocation. pid: %d, exe: %s, addr: %s", pid, e.GetParamAsString(params.Exe),
				e.GetParamAsString(params.MemBaseAddress))
			matches, err = s.scan(pid)
			allocScans.Add(1)
			isScanned = true
			if len(matches) > 0 {
				s.rwxs[pid] = addr
			}
		}
	case event.MapViewFile:
		if s.config.SkipMmaps {
			return false, nil
		}
		// scan process mapping a suspicious RX/RWX section view
		pid := e.Params.MustGetPid()
		prot := e.Params.MustGetUint32(params.MemProtect)
		size := e.Params.MustGetUint64(params.FileViewSize)
		if e.PID != 4 && size >= 4096 && ((prot&sys.SectionRX) != 0 && (prot&sys.SectionRWX) != 0) && !s.isMmapMatched(pid) {
			filename := e.GetParamAsString(params.FilePath)
			// skip mappings of signed images
			addr := e.Params.MustGetUint64(params.FileViewBase)
			sign := signature.GetSignatures().GetSignature(addr)
			if sign != nil && sign.IsSigned() && sign.IsTrusted() {
				return false, nil
			}
			// data/image file was mapped?
			if filename != "" {
				if s.config.ShouldSkipFile(filename) {
					return false, nil
				}
				log.Debugf("scanning %s section view mapping. filename: %s pid: %d, addr: %s", e.GetParamAsString(params.MemProtect),
					filename, pid, e.GetParamAsString(params.FileViewBase))
				matches, err = s.scan(filename)
			} else {
				// otherwise, scan the process
				log.Debugf("scanning %s section view mapping. pid: %d, addr: %s", e.GetParamAsString(params.MemProtect), pid,
					e.GetParamAsString(params.FileViewBase))
				matches, err = s.scan(pid)
			}
			if len(matches) > 0 {
				s.mmaps[pid] = va.Address(addr)
			}
			mmapScans.Add(1)
			isScanned = true
		}
	case event.RegSetValue:
		if s.config.SkipRegistry {
			return false, nil
		}
		if e.PS != nil && s.config.ShouldSkipProcess(e.PS.Exe) {
			return false, nil
		}
		// scan registry binary values
		if typ := e.Params.TryGetUint32(params.RegValueType); typ != registry.BINARY {
			return false, nil
		}
		v, err := e.Params.Get(params.RegData)
		if err != nil {
			// value not attached to the event
			return false, nil
		}
		if b, ok := v.Value.([]byte); ok && len(b) > 0 {
			log.Debugf("scanning registry binary value %s. pid: %d", e.GetParamAsString(params.RegPath), e.PID)
			matches, err = s.scan(b)
			registryScans.Add(1)
			isScanned = true
		}
	}

	if err != nil {
		return false, err
	}
	if len(matches) == 0 || !isScanned {
		return false, nil
	}

	totalScans.Add(1)
	ruleMatches.Add(int64(len(matches)))

	return len(matches) > 0, s.emit(matches, e)
}

func (s scanner) scan(target any) (yara.MatchRules, error) {
	var matches yara.MatchRules
	sn, err := s.newInternalScanner()
	if err != nil {
		return nil, err
	}

	switch n := target.(type) {
	case uint32: // pid
		// skip the scan for this process?
		ok, proc := s.psnap.Find(n)
		if ok && s.config.ShouldSkipProcess(proc.Exe) {
			return matches, nil
		}
		err = sn.SetCallback(&matches).ScanProc(int(n))
	case string: // file
		err = sn.SetCallback(&matches).ScanFile(n)
	case []byte: // mem
		err = sn.SetCallback(&matches).ScanMem(n)
	}

	if err != nil {
		return nil, err
	}

	return matches, nil
}

func (s scanner) emit(matches yara.MatchRules, e *event.Event) error {
	senders := alertsender.FindAll()
	if len(senders) == 0 {
		return fmt.Errorf("no alertsenders registered. Alert won't be sent")
	}

	ymatches := make([]ytypes.MatchRule, 0)

	for _, match := range matches {
		// encode rule matches as JSON and append to event metadata
		m := ytypes.MatchRule{
			Rule:      match.Rule,
			Namespace: match.Namespace,
			Tags:      match.Tags,
			Metas:     make([]ytypes.Meta, 0),
			Strings:   make([]ytypes.MatchString, 0),
		}
		for _, meta := range match.Metas {
			m.Metas = append(m.Metas, ytypes.Meta{Value: meta.Value, Identifier: meta.Identifier})
		}
		for _, s := range match.Strings {
			m.Strings = append(m.Strings, ytypes.MatchString{Name: s.Name, Base: s.Base, Data: s.Data, Offset: s.Offset})
		}
		ymatches = append(ymatches, m)

		b, err := json.Marshal(ymatches)
		if err != nil {
			return err
		}
		e.AddMeta(event.YaraMatchesKey, string(b))

		// render alert title and text
		title := s.config.AlertTitle(e)
		text, err := s.config.AlertText(e, m)
		if err != nil {
			return err
		}

		// send alert via all registered alert senders
		for _, sender := range senders {
			log.Infof("sending alert: [%s]. Text: %s Event: %s", title, text, e.String())

			alert := alertsender.NewAlert(
				title,
				text,
				m.Tags,
				m.SeverityFromScore(),
			)

			id := m.ID()
			// generate id if it doesn't exist in meta fields
			if id == "" {
				id = uuid.New().String()
			}
			alert.ID = id
			alert.Events = []*event.Event{e}
			alert.Labels = m.Labels()
			alert.Description = m.Description()

			err := sender.Send(alert)
			if err != nil {
				return fmt.Errorf("unable to emit YARA alert via [%s] sender: %v", sender.Type(), err)
			}
		}
	}

	return nil
}

func (s scanner) Close() {
	if s.c != nil {
		s.c.Destroy()
	}
}

// isRwxMatched returns true if the process already triggered RWX allocation rule match.
func (s *scanner) isRwxMatched(pid uint32) (ok bool) {
	_, ok = s.rwxs[pid]
	return ok
}

// isMmapMatched returns true if the process already triggered suspicious mmap rule match.
func (s *scanner) isMmapMatched(pid uint32) (ok bool) {
	_, ok = s.mmaps[pid]
	return ok
}

```

`pkg/yara/scanner_test.go`:

```go
//go:build yara
// +build yara

/*
 * Copyright 2019-2020 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package yara

import (
	"github.com/rabbitstack/fibratus/pkg/event"
	"github.com/rabbitstack/fibratus/pkg/ps"
	pstypes "github.com/rabbitstack/fibratus/pkg/ps/types"
	"github.com/rabbitstack/fibratus/pkg/sys"
	"github.com/rabbitstack/fibratus/pkg/util/signature"
	"github.com/rabbitstack/fibratus/pkg/yara/config"
	log "github.com/sirupsen/logrus"
	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/require"
	"golang.org/x/sys/windows/registry"
	"os"
	"path/filepath"
	"testing"
	"time"

	"github.com/rabbitstack/fibratus/pkg/alertsender"
	"github.com/rabbitstack/fibratus/pkg/event/params"
	"golang.org/x/sys/windows"
)

var yaraAlert *alertsender.Alert

type mockSender struct{}

func (s *mockSender) Send(a alertsender.Alert) error {
	yaraAlert = &a
	return nil
}

func (s *mockSender) Type() alertsender.Type {
	return alertsender.Noop
}

func (s *mockSender) Shutdown() error        { return nil }
func (s *mockSender) SupportsMarkdown() bool { return true }

func makeSender(config alertsender.Config) (alertsender.Sender, error) {
	return &mockSender{}, nil
}

func init() {
	alertsender.Register(alertsender.Noop, makeSender)
}

func TestScan(t *testing.T) {
	log.SetLevel(log.DebugLevel)
	psnap := new(ps.SnapshotterMock)
	require.NoError(t, alertsender.LoadAll([]alertsender.Config{{Type: alertsender.Noop}}))

	var tests = []struct {
		name          string
		setup         func() (*event.Event, error)
		newScanner    func() (Scanner, error)
		expectedAlert alertsender.Alert
		matches       bool
	}{
		{
			"scan spawned process",
			func() (*event.Event, error) {
				var si windows.StartupInfo
				si.Flags = windows.STARTF_USESHOWWINDOW
				var pi windows.ProcessInformation

				argv := windows.StringToUTF16Ptr(filepath.Join(os.Getenv("windir"), "notepad.exe"))

				err := windows.CreateProcess(
					nil,
					argv,
					nil,
					nil,
					true,
					0,
					nil,
					nil,
					&si,
					&pi)
				if err != nil {
					return nil, err
				}

				for {
					if sys.IsProcessRunning(pi.Process) {
						break
					}
					time.Sleep(time.Millisecond * 100)
					log.Infof("%d pid not yet ready", pi.Process)
				}

				proc := &pstypes.PS{
					Name:      "notepad.exe",
					PID:       11,
					Ppid:      2434,
					Exe:       `C:\Windows\notepad.exe`,
					Cmdline:   `C:\Windows\notepad.exe`,
					SID:       "S-1-1-18",
					Cwd:       `C:\Windows\`,
					SessionID: 1,
				}
				psnap.On("Find", pi.ProcessId).Return(true, proc)

				e := &event.Event{
					Type: event.CreateProcess,
					Name: "CreateProcess",
					Tid:  2484,
					PID:  859,
					Params: event.Params{
						params.ProcessName: {Name: params.ProcessName, Type: params.UnicodeString, Value: "notepad.exe"},
						params.ProcessID:   {Name: params.ProcessID, Type: params.PID, Value: pi.ProcessId},
					},
					Metadata: make(map[event.MetadataKey]any),
					PS:       proc,
				}
				return e, nil
			},
			func() (Scanner, error) {
				return NewScanner(psnap, config.Config{
					Enabled:     true,
					ScanTimeout: time.Minute,
					Rule: config.Rule{
						Paths: []config.RulePath{
							{
								Namespace: "default",
								Path:      "_fixtures/rules",
							},
						},
					},
				})
			},
			alertsender.Alert{
				Title: "Memory Threat Detected",
				Text:  "Threat detected Notepad.Shell",
				ID:    "babf9101-1e6e-4268-a530-e99e2c905b0d",
				Tags:  []string{"T1", "T2"},
			},
			true,
		},
		{
			"scan spawned process excluded by config",
			func() (*event.Event, error) {
				var si windows.StartupInfo
				si.Flags = windows.STARTF_USESHOWWINDOW
				si.ShowWindow = windows.SW_HIDE
				var pi windows.ProcessInformation

				argv := windows.StringToUTF16Ptr(filepath.Join(os.Getenv("windir"), "notepad.exe"))

				err := windows.CreateProcess(
					nil,
					argv,
					nil,
					nil,
					true,
					0,
					nil,
					nil,
					&si,
					&pi)
				if err != nil {
					return nil, err
				}

				for {
					if sys.IsProcessRunning(pi.Process) {
						break
					}
					time.Sleep(time.Millisecond * 100)
					log.Infof("%d pid not yet ready", pi.Process)
				}

				proc := &pstypes.PS{
					Name:      "notepad.exe",
					PID:       11,
					Ppid:      2434,
					Exe:       `C:\Windows\notepad.exe`,
					Cmdline:   `C:\Windows\notepad.exe`,
					SID:       "S-1-1-18",
					Cwd:       `C:\Windows\`,
					SessionID: 1,
				}
				psnap.On("Find", pi.ProcessId).Return(true, proc)

				e := &event.Event{
					Type: event.CreateProcess,
					Name: "CreateProcess",
					Tid:  2484,
					PID:  859,
					Params: event.Params{
						params.ProcessName: {Name: params.ProcessName, Type: params.UnicodeString, Value: "notepad.exe"},
						params.ProcessID:   {Name: params.ProcessID, Type: params.PID, Value: pi.ProcessId},
					},
					Metadata: make(map[event.MetadataKey]any),
					PS:       proc,
				}
				return e, nil
			},
			func() (Scanner, error) {
				return NewScanner(psnap, config.Config{
					Enabled:     true,
					ScanTimeout: time.Minute,
					Rule: config.Rule{
						Paths: []config.RulePath{
							{
								Namespace: "default",
								Path:      "_fixtures/rules",
							},
						},
					},
					ExcludedProcesses: []string{"?:\\*\\notepad.exe"},
				})
			},
			alertsender.Alert{},
			false,
		},
		{
			"scan unsigned module loading",
			func() (*event.Event, error) {
				var si windows.StartupInfo
				si.Flags = windows.STARTF_USESHOWWINDOW
				var pi windows.ProcessInformation

				argv := windows.StringToUTF16Ptr(filepath.Join(os.Getenv("windir"), "regedit.exe"))

				err := windows.CreateProcess(
					nil,
					argv,
					nil,
					nil,
					true,
					0,
					nil,
					nil,
					&si,
					&pi)
				if err != nil {
					return nil, err
				}

				for {
					if sys.IsProcessRunning(pi.Process) {
						break
					}
					time.Sleep(time.Millisecond * 100)
					log.Infof("%d pid not yet ready", pi.Process)
				}

				pid := pi.ProcessId
				proc := &pstypes.PS{
					Name:      "tests.exe",
					PID:       pid,
					Ppid:      uint32(os.Getppid()),
					Exe:       `C:\ProgramData\tests.exe`,
					Cmdline:   `C:\ProgramData\tests.exe`,
					SID:       "S-1-1-18",
					Cwd:       `C:\ProgramData\`,
					SessionID: 1,
				}
				psnap.On("Find", pid).Return(true, proc)

				e := &event.Event{
					Type: event.LoadImage,
					Name: "LoadImage",
					Tid:  2484,
					PID:  pid,
					Params: event.Params{
						params.FilePath:           {Name: params.FilePath, Type: params.UnicodeString, Value: "tests.exe"},
						params.ImageBase:          {Name: params.ImageBase, Type: params.Uint64, Value: uint64(0x74888fd99)},
						params.ImageSignatureType: {Name: params.ImageSignatureType, Type: params.Uint32, Value: signature.None},
						params.ProcessID:          {Name: params.ProcessID, Type: params.PID, Value: pid},
					},
					Metadata: make(map[event.MetadataKey]any),
					PS:       proc,
				}
				return e, nil
			},
			func() (Scanner, error) {
				return NewScanner(psnap, config.Config{
					Enabled:     true,
					ScanTimeout: time.Minute,
					Rule: config.Rule{
						Paths: []config.RulePath{
							{
								Namespace: "default",
								Path:      "_fixtures/rules",
							},
						},
					},
				})
			},
			alertsender.Alert{
				Title: "Memory Threat Detected",
				Text:  "Threat detected Regedit",
				ID:    "1abf9101-1e6e-4268-a530-e99e2c905b0d",
				Tags:  []string{"T1"},
			},
			true,
		},
		{
			"scan pe file created in the file system",
			func() (*event.Event, error) {

				proc := &pstypes.PS{
					Name:      "tests.exe",
					PID:       565,
					Ppid:      uint32(os.Getppid()),
					Exe:       `C:\ProgramData\tests.exe`,
					Cmdline:   `C:\ProgramData\tests.exe`,
					SID:       "S-1-1-18",
					Cwd:       `C:\ProgramData\`,
					SessionID: 1,
				}
				psnap.On("Find", 565).Return(true, proc)

				e := &event.Event{
					Type:     event.CreateFile,
					Name:     "CreateFile",
					Category: event.File,
					Tid:      2484,
					PID:      565,
					Params: event.Params{
						params.FilePath:      {Name: params.FilePath, Type: params.UnicodeString, Value: filepath.Join(os.Getenv("windir"), "notepad.exe")},
						params.FileOperation: {Name: params.FileOperation, Type: params.Uint32, Value: uint32(windows.FILE_CREATE)},
					},
					Metadata: make(map[event.MetadataKey]any),
					PS:       proc,
				}
				return e, nil
			},
			func() (Scanner, error) {
				return NewScanner(psnap, config.Config{
					Enabled:     true,
					ScanTimeout: time.Minute,
					Rule: config.Rule{
						Paths: []config.RulePath{
							{
								Namespace: "default",
								Path:      "_fixtures/rules",
							},
						},
					},
				})
			},
			alertsender.Alert{
				Title: "File Threat Detected",
				Text:  "Threat detected Notepad.Shell",
				ID:    "babf9101-1e6e-4268-a530-e99e2c905b0d",
				Tags:  []string{"T1", "T2"},
			},
			true,
		},
		{
			"scan pe file excluded by config",
			func() (*event.Event, error) {

				proc := &pstypes.PS{
					Name:      "tests.exe",
					PID:       565,
					Ppid:      uint32(os.Getppid()),
					Exe:       `C:\ProgramData\tests.exe`,
					Cmdline:   `C:\ProgramData\tests.exe`,
					SID:       "S-1-1-18",
					Cwd:       `C:\ProgramData\`,
					SessionID: 1,
				}
				psnap.On("Find", 565).Return(true, proc)

				e := &event.Event{
					Type:     event.CreateFile,
					Name:     "CreateFile",
					Category: event.File,
					Tid:      2484,
					PID:      565,
					Params: event.Params{
						params.FilePath:      {Name: params.FilePath, Type: params.UnicodeString, Value: filepath.Join(os.Getenv("windir"), "System32", "cmd.exe")},
						params.FileOperation: {Name: params.FileOperation, Type: params.Uint32, Value: uint32(windows.FILE_CREATE)},
					},
					Metadata: make(map[event.MetadataKey]any),
					PS:       proc,
				}
				return e, nil
			},
			func() (Scanner, error) {
				return NewScanner(psnap, config.Config{
					Enabled:     true,
					ScanTimeout: time.Minute,
					Rule: config.Rule{
						Paths: []config.RulePath{
							{
								Namespace: "default",
								Path:      "_fixtures/rules",
							},
						},
					},
					ExcludedFiles: []string{
						`?:\WINDOWS\*\*.exe`,
					},
				})
			},
			alertsender.Alert{},
			false,
		},
		{
			"scan non-pe file created in the file system",
			func() (*event.Event, error) {

				proc := &pstypes.PS{
					Name:      "tests.exe",
					PID:       565,
					Ppid:      uint32(os.Getppid()),
					Exe:       `C:\ProgramData\tests.exe`,
					Cmdline:   `C:\ProgramData\tests.exe`,
					SID:       "S-1-1-18",
					Cwd:       `C:\ProgramData\`,
					SessionID: 1,
				}
				psnap.On("Find", 565).Return(true, proc)

				e := &event.Event{
					Type:     event.CreateFile,
					Name:     "CreateFile",
					Category: event.File,
					Tid:      2484,
					PID:      565,
					Params: event.Params{
						params.FilePath:      {Name: params.FilePath, Type: params.UnicodeString, Value: filepath.Join(os.Getenv("windir"), "splwow64.xml")},
						params.FileOperation: {Name: params.FileOperation, Type: params.Uint32, Value: uint32(windows.FILE_CREATE)},
					},
					Metadata: make(map[event.MetadataKey]any),
					PS:       proc,
				}
				return e, nil
			},
			func() (Scanner, error) {
				return NewScanner(psnap, config.Config{
					Enabled:     true,
					ScanTimeout: time.Minute,
					Rule: config.Rule{
						Paths: []config.RulePath{
							{
								Namespace: "default",
								Path:      "_fixtures/rules",
							},
						},
					},
				})
			},
			alertsender.Alert{},
			false,
		},
		{
			"scan pe file excluded by generating process name",
			func() (*event.Event, error) {

				proc := &pstypes.PS{
					Name:      "tests.exe",
					PID:       565,
					Ppid:      uint32(os.Getppid()),
					Exe:       `C:\ProgramData\tests.exe`,
					Cmdline:   `C:\ProgramData\tests.exe`,
					SID:       "S-1-1-18",
					Cwd:       `C:\ProgramData\`,
					SessionID: 1,
				}
				psnap.On("Find", 565).Return(true, proc)

				e := &event.Event{
					Type:     event.CreateFile,
					Name:     "CreateFile",
					Category: event.File,
					Tid:      2484,
					PID:      565,
					Params: event.Params{
						params.FilePath:      {Name: params.FilePath, Type: params.UnicodeString, Value: filepath.Join(os.Getenv("windir"), "System32", "cmd.exe")},
						params.FileOperation: {Name: params.FileOperation, Type: params.Uint32, Value: uint32(windows.FILE_CREATE)},
					},
					Metadata: make(map[event.MetadataKey]any),
					PS:       proc,
				}
				return e, nil
			},
			func() (Scanner, error) {
				return NewScanner(psnap, config.Config{
					Enabled:     true,
					ScanTimeout: time.Minute,
					Rule: config.Rule{
						Paths: []config.RulePath{
							{
								Namespace: "default",
								Path:      "_fixtures/rules",
							},
						},
					},
					ExcludedFiles: []string{
						`tests.exe`,
					},
				})
			},
			alertsender.Alert{},
			false,
		},
		{
			"scan ads created in the file system",
			func() (*event.Event, error) {
				ads := filepath.Join(os.TempDir(), "suspicious-ads.txt:mal")
				f, err := os.Create(ads)
				if err != nil {
					return nil, err
				}
				data := []byte{0x6F, 0x66, 0x74, 0x2E, 0x4E, 0x6F, 0x74, 0x65, 0x70, 0x61, 0x64, 0x00, 0x13, 0x00, 0x01, 0x1A}
				if err := os.WriteFile(ads, data, os.ModePerm); err != nil {
					return nil, err
				}
				defer f.Close()
				defer os.Remove(ads)

				proc := &pstypes.PS{
					Name:      "tests.exe",
					PID:       565,
					Ppid:      uint32(os.Getppid()),
					Exe:       `C:\ProgramData\tests.exe`,
					Cmdline:   `C:\ProgramData\tests.exe`,
					SID:       "S-1-1-18",
					Cwd:       `C:\ProgramData\`,
					SessionID: 1,
				}
				psnap.On("Find", 565).Return(true, proc)

				e := &event.Event{
					Type:     event.CreateFile,
					Name:     "CreateFile",
					Category: event.File,
					Tid:      2484,
					PID:      565,
					Params: event.Params{
						params.FilePath:      {Name: params.FilePath, Type: params.UnicodeString, Value: ads},
						params.FileOperation: {Name: params.FileOperation, Type: params.Uint32, Value: uint32(windows.FILE_CREATE)},
					},
					Metadata: make(map[event.MetadataKey]any),
					PS:       proc,
				}
				return e, nil
			},
			func() (Scanner, error) {
				return NewScanner(psnap, config.Config{
					Enabled:     true,
					ScanTimeout: time.Minute,
					Rule: config.Rule{
						Paths: []config.RulePath{
							{
								Namespace: "default",
								Path:      "_fixtures/rules",
							},
						},
					},
				})
			},
			alertsender.Alert{
				Title: "File Threat Detected",
				Text:  "Threat detected Notepad.Shell",
				ID:    "babf9101-1e6e-4268-a530-e99e2c905b0d",
				Tags:  []string{"T1", "T2"},
			},
			true,
		},
		{
			"scan rwx memory region allocation",
			func() (*event.Event, error) {
				var si windows.StartupInfo
				si.Flags = windows.STARTF_USESHOWWINDOW
				var pi windows.ProcessInformation

				argv := windows.StringToUTF16Ptr(filepath.Join(os.Getenv("windir"), "regedit.exe"))

				err := windows.CreateProcess(
					nil,
					argv,
					nil,
					nil,
					true,
					0,
					nil,
					nil,
					&si,
					&pi)
				if err != nil {
					return nil, err
				}

				for {
					if sys.IsProcessRunning(pi.Process) {
						break
					}
					time.Sleep(time.Millisecond * 100)
					log.Infof("%d pid not yet ready", pi.Process)
				}

				pid := pi.ProcessId

				proc := &pstypes.PS{
					Name:      "tests.exe",
					PID:       565,
					Ppid:      uint32(os.Getppid()),
					Exe:       `C:\ProgramData\tests.exe`,
					Cmdline:   `C:\ProgramData\tests.exe`,
					SID:       "S-1-1-18",
					Cwd:       `C:\ProgramData\`,
					SessionID: 1,
				}
				psnap.On("Find", pid).Return(true, proc)

				e := &event.Event{
					Type:     event.VirtualAlloc,
					Name:     "VirtualAlloc",
					Category: event.Mem,
					Tid:      2484,
					PID:      565,
					Params: event.Params{
						params.ProcessID:      {Name: params.ProcessID, Type: params.PID, Value: pid},
						params.MemBaseAddress: {Name: params.MemBaseAddress, Type: params.Address, Value: uint64(0x7ffe0000)},
						params.MemProtect:     {Name: params.MemProtect, Type: params.Flags, Value: uint32(windows.PAGE_EXECUTE_READWRITE), Flags: event.MemProtectionFlags},
					},
					Metadata: make(map[event.MetadataKey]any),
					PS:       proc,
				}
				return e, nil
			},
			func() (Scanner, error) {
				return NewScanner(psnap, config.Config{
					Enabled:     true,
					ScanTimeout: time.Minute,
					Rule: config.Rule{
						Paths: []config.RulePath{
							{
								Namespace: "default",
								Path:      "_fixtures/rules",
							},
						},
					},
				})
			},
			alertsender.Alert{
				Title: "Memory Threat Detected",
				Text:  "Threat detected Regedit",
				ID:    "1abf9101-1e6e-4268-a530-e99e2c905b0d",
				Tags:  []string{"T1"},
			},
			true,
		},
		{
			"scan rx pagefile mmap",
			func() (*event.Event, error) {
				var si windows.StartupInfo
				si.Flags = windows.STARTF_USESHOWWINDOW
				var pi windows.ProcessInformation

				argv := windows.StringToUTF16Ptr(filepath.Join(os.Getenv("windir"), "regedit.exe"))

				err := windows.CreateProcess(
					nil,
					argv,
					nil,
					nil,
					true,
					0,
					nil,
					nil,
					&si,
					&pi)
				if err != nil {
					return nil, err
				}

				for {
					if sys.IsProcessRunning(pi.Process) {
						break
					}
					time.Sleep(time.Millisecond * 100)
					log.Infof("%d pid not yet ready", pi.Process)
				}

				pid := pi.ProcessId

				proc := &pstypes.PS{
					Name:      "tests.exe",
					PID:       pid,
					Ppid:      uint32(os.Getppid()),
					Exe:       `C:\ProgramData\tests.exe`,
					Cmdline:   `C:\ProgramData\tests.exe`,
					SID:       "S-1-1-18",
					Cwd:       `C:\ProgramData\`,
					SessionID: 1,
				}
				psnap.On("Find", pid).Return(true, proc)

				e := &event.Event{
					Type:     event.MapViewFile,
					Name:     "MapViewFile",
					Category: event.File,
					Tid:      2484,
					PID:      565,
					Params: event.Params{
						params.ProcessID:    {Name: params.ProcessID, Type: params.PID, Value: pid},
						params.FileViewBase: {Name: params.FileViewBase, Type: params.Address, Value: uint64(0x7ffe0000)},
						params.FileViewSize: {Name: params.FileViewSize, Type: params.Uint64, Value: uint64(12333)},
						params.MemProtect:   {Name: params.MemProtect, Type: params.Flags, Value: uint32(sys.SectionRX), Flags: event.ViewProtectionFlags},
					},
					Metadata: make(map[event.MetadataKey]any),
					PS:       proc,
				}
				return e, nil
			},
			func() (Scanner, error) {
				return NewScanner(psnap, config.Config{
					Enabled:     true,
					ScanTimeout: time.Minute,
					Rule: config.Rule{
						Paths: []config.RulePath{
							{
								Namespace: "default",
								Path:      "_fixtures/rules",
							},
						},
					},
				})
			},
			alertsender.Alert{
				Title: "Memory Threat Detected",
				Text:  "Threat detected Regedit",
				ID:    "1abf9101-1e6e-4268-a530-e99e2c905b0d",
				Tags:  []string{"T1"},
			},
			true,
		},
		{
			"scan rx pagefile mmap address for signed module",
			func() (*event.Event, error) {
				proc := &pstypes.PS{
					Name:      "tests.exe",
					PID:       1123,
					Ppid:      uint32(os.Getppid()),
					Exe:       `C:\ProgramData\tests.exe`,
					Cmdline:   `C:\ProgramData\tests.exe`,
					SID:       "S-1-1-18",
					Cwd:       `C:\ProgramData\`,
					SessionID: 1,
				}
				psnap.On("Find", 1123).Return(true, proc)

				signature.GetSignatures().PutSignature(uint64(0x7f3e1000), &signature.Signature{Level: signature.AuthenticodeLevel, Type: signature.Catalog})

				e := &event.Event{
					Type:     event.MapViewFile,
					Name:     "MapViewFile",
					Category: event.File,
					Tid:      2484,
					PID:      565,
					Params: event.Params{
						params.ProcessID:    {Name: params.ProcessID, Type: params.PID, Value: uint32(1123)},
						params.FileViewBase: {Name: params.FileViewBase, Type: params.Address, Value: uint64(0x7f3e1000)},
						params.FileViewSize: {Name: params.FileViewSize, Type: params.Uint64, Value: uint64(12333)},
						params.MemProtect:   {Name: params.MemProtect, Type: params.Flags, Value: uint32(sys.SectionRX), Flags: event.ViewProtectionFlags},
					},
					Metadata: make(map[event.MetadataKey]any),
					PS:       proc,
				}
				return e, nil
			},
			func() (Scanner, error) {
				return NewScanner(psnap, config.Config{
					Enabled:     true,
					ScanTimeout: time.Minute,
					Rule: config.Rule{
						Paths: []config.RulePath{
							{
								Namespace: "default",
								Path:      "_fixtures/rules",
							},
						},
					},
				})
			},
			alertsender.Alert{},
			false,
		},
		{
			"scan rx pagefile readonly mmap",
			func() (*event.Event, error) {
				proc := &pstypes.PS{
					Name:      "tests.exe",
					PID:       321321,
					Ppid:      uint32(os.Getppid()),
					Exe:       `C:\ProgramData\tests.exe`,
					Cmdline:   `C:\ProgramData\tests.exe`,
					SID:       "S-1-1-18",
					Cwd:       `C:\ProgramData\`,
					SessionID: 1,
				}
				psnap.On("Find", uint32(321321)).Return(true, proc)

				e := &event.Event{
					Type:     event.MapViewFile,
					Name:     "MapViewFile",
					Category: event.File,
					Tid:      2484,
					PID:      321321,
					Params: event.Params{
						params.ProcessID:    {Name: params.ProcessID, Type: params.PID, Value: uint32(321321)},
						params.FileViewBase: {Name: params.FileViewBase, Type: params.Address, Value: uint64(0x7ffe0000)},
						params.FileViewSize: {Name: params.FileViewSize, Type: params.Uint64, Value: uint64(12333)},
						params.MemProtect:   {Name: params.MemProtect, Type: params.Flags, Value: uint32(0x10000), Flags: event.ViewProtectionFlags},
					},
					Metadata: make(map[event.MetadataKey]any),
					PS:       proc,
				}
				return e, nil
			},
			func() (Scanner, error) {
				return NewScanner(psnap, config.Config{
					Enabled:     true,
					ScanTimeout: time.Minute,
					Rule: config.Rule{
						Paths: []config.RulePath{
							{
								Namespace: "default",
								Path:      "_fixtures/rules",
							},
						},
					},
				})
			},
			alertsender.Alert{},
			false,
		},
		{
			"scan rwx image file mmap",
			func() (*event.Event, error) {
				proc := &pstypes.PS{
					Name:      "tests.exe",
					PID:       1123,
					Ppid:      uint32(os.Getppid()),
					Exe:       `C:\ProgramData\tests.exe`,
					Cmdline:   `C:\ProgramData\tests.exe`,
					SID:       "S-1-1-18",
					Cwd:       `C:\ProgramData\`,
					SessionID: 1,
				}
				psnap.On("Find", 1123).Return(true, proc)

				e := &event.Event{
					Type:     event.MapViewFile,
					Name:     "MapViewFile",
					Category: event.File,
					Tid:      2484,
					PID:      565,
					Params: event.Params{
						params.ProcessID:    {Name: params.ProcessID, Type: params.PID, Value: uint32(1123)},
						params.FilePath:     {Name: params.FilePath, Type: params.UnicodeString, Value: filepath.Join(os.Getenv("windir"), "regedit.exe")},
						params.FileViewBase: {Name: params.FileViewBase, Type: params.Address, Value: uint64(0x7ffe0000)},
						params.FileViewSize: {Name: params.FileViewSize, Type: params.Uint64, Value: uint64(12333)},
						params.MemProtect:   {Name: params.MemProtect, Type: params.Flags, Value: uint32(sys.SectionRWX), Flags: event.ViewProtectionFlags},
					},
					Metadata: make(map[event.MetadataKey]any),
					PS:       proc,
				}
				return e, nil
			},
			func() (Scanner, error) {
				return NewScanner(psnap, config.Config{
					Enabled:     true,
					ScanTimeout: time.Minute,
					Rule: config.Rule{
						Paths: []config.RulePath{
							{
								Namespace: "default",
								Path:      "_fixtures/rules",
							},
						},
					},
				})
			},
			alertsender.Alert{
				Title: "File Threat Detected",
				Text:  "Threat detected Regedit",
				ID:    "1abf9101-1e6e-4268-a530-e99e2c905b0d",
				Tags:  []string{"T1"},
			},
			true,
		},
		{
			"scan registry binary value",
			func() (*event.Event, error) {
				proc := &pstypes.PS{
					Name:      "tests.exe",
					PID:       1123,
					Ppid:      uint32(os.Getppid()),
					Exe:       `C:\ProgramData\tests.exe`,
					Cmdline:   `C:\ProgramData\tests.exe`,
					SID:       "S-1-1-18",
					Cwd:       `C:\ProgramData\`,
					SessionID: 1,
				}
				psnap.On("Find", 1123).Return(true, proc)

				data := []byte{0x6F, 0x66, 0x74, 0x2E, 0x4E, 0x6F, 0x74, 0x65, 0x70, 0x61, 0x64, 0x00, 0x13, 0x00, 0x01, 0x1A}
				e := &event.Event{
					Type:     event.RegSetValue,
					Name:     "RegSetValue",
					Category: event.Registry,
					Tid:      2484,
					PID:      565,
					Params: event.Params{
						params.RegValueType: {Name: params.RegValueType, Type: params.Uint32, Value: uint32(registry.BINARY)},
						params.RegData:      {Name: params.RegValue, Type: params.Binary, Value: data},
						params.RegPath:      {Name: params.RegPath, Type: params.UnicodeString, Value: `HKEY_LOCAL_MACHINE\CurrentControlSet\Control\DeviceGuard\Mal`},
					},
					Metadata: make(map[event.MetadataKey]any),
					PS:       proc,
				}
				return e, nil
			},
			func() (Scanner, error) {
				return NewScanner(psnap, config.Config{
					Enabled:     true,
					ScanTimeout: time.Minute,
					Rule: config.Rule{
						Paths: []config.RulePath{
							{
								Namespace: "default",
								Path:      "_fixtures/rules",
							},
						},
					},
				})
			},
			alertsender.Alert{
				Title: "File Threat Detected",
				Text:  "Threat detected Notepad.Shell",
				ID:    "babf9101-1e6e-4268-a530-e99e2c905b0d",
				Tags:  []string{"T1", "T2"},
			},
			true,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			e, err := tt.setup()
			require.NoError(t, err)

			// initialize scanner
			s, err := tt.newScanner()
			require.NoError(t, err)
			defer s.Close()

			matches, err := s.Scan(e)
			require.NoError(t, err)
			require.Equal(t, matches, tt.matches)

			if matches {
				// compare alert content
				require.NotNil(t, yaraAlert)
				assert.Equal(t, tt.expectedAlert.Title, yaraAlert.Title)
				assert.Equal(t, tt.expectedAlert.Text, yaraAlert.Text)
				assert.Equal(t, tt.expectedAlert.ID, yaraAlert.ID)
				assert.Equal(t, tt.expectedAlert.Tags, yaraAlert.Tags)
				assert.True(t, len(yaraAlert.Labels) > 0)
				assert.Len(t, yaraAlert.Events, 1)
				assert.NotEmpty(t, e.Metadata)
				assert.Contains(t, e.Metadata, event.YaraMatchesKey)
			}

			if e.IsCreateProcess() || e.IsLoadImage() || e.IsVirtualAlloc() || e.IsMapViewFile() {
				// cleanup
				proc, err := windows.OpenProcess(windows.PROCESS_TERMINATE, false, e.Params.MustGetPid())
				if err == nil {
					windows.TerminateProcess(proc, uint32(257))
					windows.Close(proc)
				}
			}
		})
	}
}

```

`pkg/yara/scanner_unsupported.go`:

```go
//go:build !yara
// +build !yara

/*
 * Copyright 2019-2020 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package yara

import (
	errs "github.com/rabbitstack/fibratus/pkg/errors"
	"github.com/rabbitstack/fibratus/pkg/ps"
	"github.com/rabbitstack/fibratus/pkg/yara/config"
)

// NewScanner returns unsupported scanner error.
func NewScanner(psnap ps.Snapshotter, config config.Config) (Scanner, error) {
	return nil, errs.ErrFeatureUnsupported("yara")
}

```

`pkg/yara/types.go`:

```go
/*
 * Copyright 2019-2020 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package yara

import "github.com/rabbitstack/fibratus/pkg/event"

// Scanner watches for certain events such as process creation or image loading and
// triggers the scanning either on the process memory or on-disk file. If matches occur,
// an alert is emitted via registered alert senders.
type Scanner interface {
	event.Listener
	// Scan runs a scan when the specified signal is observed. The signal
	// can be the creation of a new process, image loading, writing the PE
	// file or ADS to the file system, or a suspicious memory allocation.
	Scan(*event.Event) (bool, error)
	// Close disposes any resources allocated by the scanner.
	Close()
}

```

`pkg/yara/types/types.go`:

```go
/*
 * Copyright 2021-2022 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package types

import (
	"fmt"
	"github.com/rabbitstack/fibratus/pkg/alertsender"
	"strconv"
)

const (
	id          = "id"
	threat      = "threat_name"
	severity    = "severity"
	score       = "score"
	description = "description"
)

// A MatchRule represents a rule successfully matched against a block
// of data.
type MatchRule struct {
	Rule      string        `json:"rule"`
	Namespace string        `json:"namespace"`
	Tags      []string      `json:"tags"`
	Metas     []Meta        `json:"metas"`
	Strings   []MatchString `json:"strings"`
}

// ID returns the identifier from the rule metadata fields.
func (m MatchRule) ID() string {
	return m.getMetaString(id)
}

// Description returns the rule description from the metadata fields.
func (m MatchRule) Description() string {
	return m.getMetaString(description)
}

// ThreatName returns the threat matching the rule signature.
func (m MatchRule) ThreatName() string {
	return m.getMetaString(threat)
}

// SeverityFromScore returns the alert severity from the numerical score
// defined in the rule meta tags. If the score tag is not defined, the
// high severity is returned.
func (m MatchRule) SeverityFromScore() alertsender.Severity {
	s := m.getMetaInt(score)
	if s == 0 {
		s = m.getMetaInt(severity)
	}
	switch {
	case s > 0 && s <= 39:
		return alertsender.Normal
	case s >= 40 && s <= 59:
		return alertsender.Medium
	case s >= 60 && s <= 79:
		return alertsender.High
	case s >= 80:
		return alertsender.Critical
	default:
		return alertsender.High
	}
}

// Labels returns all meta tags as alert labels.
func (m MatchRule) Labels() map[string]string {
	labels := make(map[string]string)
	for _, meta := range m.Metas {
		switch v := meta.Value.(type) {
		case string:
			labels[meta.Identifier] = v
		case int:
			labels[meta.Identifier] = strconv.Itoa(v)
		case bool:
			labels[meta.Identifier] = strconv.FormatBool(v)
		default:
			labels[meta.Identifier] = fmt.Sprintf("%s", v)
		}
	}
	return labels
}

func (m MatchRule) getMetaString(id string) string {
	for _, meta := range m.Metas {
		if meta.Identifier == id {
			if i, ok := meta.Value.(string); ok {
				return i
			}
		}
	}
	return ""
}

func (m MatchRule) getMetaInt(id string) int {
	for _, meta := range m.Metas {
		if meta.Identifier == id {
			if i, ok := meta.Value.(int); ok {
				return i
			}
		}
	}
	return 0
}

// A MatchString represents a string declared and matched in a rule.
type MatchString struct {
	Name   string `json:"name"`
	Base   uint64 `json:"base"`
	Offset uint64 `json:"offset"`
	Data   []byte `json:"data"`
}

// Meta represents a rule meta variable. Value can be of type string,
// int, boolean, or nil.
type Meta struct {
	Identifier string      `json:"identifier"`
	Value      interface{} `json:"value"`
}

```

`pkg/yara/types/types_test.go`:

```go
/*
 * Copyright 2021-2022 by Nedim Sabic Sabic
 * https://www.fibratus.io
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package types

import (
	"github.com/rabbitstack/fibratus/pkg/alertsender"
	"github.com/stretchr/testify/assert"
	"testing"
)

func TestSeverityFromScore(t *testing.T) {
	var tests = []struct {
		m MatchRule
		s alertsender.Severity
	}{
		{
			MatchRule{
				Metas: []Meta{{Identifier: "score", Value: 20}},
			},
			alertsender.Normal,
		},
		{
			MatchRule{
				Metas: []Meta{{Identifier: "score", Value: 43}},
			},
			alertsender.Medium,
		},
		{
			MatchRule{
				Metas: []Meta{{Identifier: "score", Value: 70}},
			},
			alertsender.High,
		},
		{
			MatchRule{
				Metas: []Meta{{Identifier: "severity", Value: 90}},
			},
			alertsender.Critical,
		},
		{
			MatchRule{},
			alertsender.High,
		},
	}

	for _, tt := range tests {
		t.Run(tt.s.String(), func(t *testing.T) {
			assert.Equal(t, tt.s, tt.m.SeverityFromScore())
		})
	}
}

```

`rules/README.md`:

```md
# Detection Rules

<p align="center" >
  <a href="https://www.fibratus.io" >
    <img src="rule-alert.png" alt="Email rule alert">
  </a>
</p>

This directory contains a catalog of detection rules modeled around the prominent [MITRE ATT&CK](https://attack.mitre.org/) framework. The goal is to provide a direct mapping of tactics, techniques, and sub-techniques for each rule. The following sections introduce the general structure, design guidelines, and best practices to keep in mind when creating new rules.

## Structure

Detection rules are organized in `yaml` files. Rules can live in different directories and there is no strict naming convention.
However, the recommended practice is to follow the `tactic_name_rule_name.yml` naming nomenclature. By default, all rules reside within
the `rules` directory of this repository.

The CLI provides a command to create a new rule from the template. For example, if you want to create the `Potential Process Doppelganging`
rule that belongs to the `Defense Evasion` MITRE tactic, you would use the following command.

```
$ fibratus rules create "Potential Process Doppelganging Injection" -t TA0005
```

The `-t` flag specifies the MITRE tactic id. The end result is the `defense_evasion_potential_process_doppelganging_injection.yml` file with the most
required attributes such as rule identifier, name, and the minimum engine version, filled out automatically.

## Guidelines

### Read the docs

This should be your starting point. Before trying to write new rules, explore the [docs](https://www.fibratus.io/#/filters/introduction) to learn about [filter expressions](https://www.fibratus.io/#/filters/filtering) fundamentals, [operators](https://www.fibratus.io/#/filters/operators), [functions](https://www.fibratus.io/#/filters/functions), [filter fields](https://www.fibratus.io/#/filters/fields) reference, and [rule engine](https://www.fibratus.io/#/filters/rules) specifics. 

### Stick to naming nomenclature

It is highly recommended to name the rule files after the pattern explained in the above section. This facilitates the organization and searching through the detection rules catalog and fosters standardization.

### Include descriptions and labels

Rules should have a meaningful description.
For example, `Potential process injection via tainted memory section`.

Additionally, there should exist labels attached to every rule describing the MITRE tactic, technique, and sub-technique. This information is used when rendering email rule alert templates as depicted in the image above.

### Rules should have a narrowed event scope

If a rule is declared without the scoped event conditions, you'll get a warning message in `Fibratus` logs informing you about unwanted side effects. **This always lead to the rule being utterly discarded by the engine!**

### Pay attention to the condition arrangement

As highlighted in the previous paragraph, all rules should have the event type condition. Additionally, condition arrangement may have important runtime performance impact because the rule engine can lazily evaluate binary expressions that comprise a rule. In general, costly evaluations or functions such as `get_reg_value` should go last to make sure they are evaluated after all other expressions have been visited.

### Prefer macros over raw conditions

Fibratus comes with a [macros](https://www.fibratus.io/#/filters/rules?id=macros) library to promote the reusability and modularization of rule conditions and lists. Before trying to spell out a raw rule condition, explore the library to check if there's already a macro you can pull into the rule. For example, detecting file accesses could be accomplished by declaring the `evt.name = 'CreateFile' and file.operation = 'open'` expression. However, the macro library comes with the `open_file` macro that you can directly call in any rule. If you can't encounter a particular macro in the library, please consider creating it. Future detection engineers and rule writers could profit from those macros.

### Formatting styles

Pay attention to rule condition/action formatting style. If the rule consists of multiple or large expressions, it is desirable to split each spanning expression on a new line and properly indent the `and`, `or`, or `not` operators. By default, we use 1 space tab for indenting operators and rule actions. This notably improves readability and prevents formatting inconsistencies.

```

`rules/credentail_access_file_access_to_sam_database.yml`:

```yml
name: File access to SAM database
id: e3dace20-4962-4381-884e-40dcdde66626
version: 1.0.5
description: |
  Identifies access to the Security Account Manager on-disk database.
labels:
  tactic.id: TA0006
  tactic.name: Credential Access
  tactic.ref: https://attack.mitre.org/tactics/TA0006/
  technique.id: T1003
  technique.name: OS Credential Dumping
  technique.ref: https://attack.mitre.org/techniques/T1003/
  subtechnique.id: T1003.002
  subtechnique.name: Security Account Manager
  subtechnique.ref: https://attack.mitre.org/techniques/T1003/002/

condition: >
  open_file and
  file.path imatches
            (
              '?:\\WINDOWS\\SYSTEM32\\CONFIG\\SAM',
              '\\Device\\HarddiskVolumeShadowCopy*\\WINDOWS\\SYSTEM32\\CONFIG\\SAM',
              '\\??\\GLOBALROOT\\Device\\HarddiskVolumeShadowCopy*\\WINDOWS\\SYSTEM32\\CONFIG\\SAM'
            ) and
  ps.exe not imatches
            (
              '?:\\Program Files\\*',
              '?:\\Program Files (x86)\\*',
              '?:\\Windows\\System32\\lsass.exe',
              '?:\\Windows\\System32\\srtasks.exe'
            )

min-engine-version: 3.0.0

```

`rules/credential_access_credential_manager_access_via_known_tools.yml`:

```yml
name: Credential Manager access via known tools
id: 5b4130f8-bc73-4890-b5f6-b03cddc75a52
version: 1.0.0
description: |
  Detects access to the Windows Credential Manager using built-in
  utilities such as vaultcmd.exe, cmdkey.exe, rundll32.exe, and
  control.exe. Adversaries can abuse these native tools to enumerate
  or interact with stored credentials.
labels:
  tactic.id: TA0006
  tactic.name: Credential Access
  tactic.ref: https://attack.mitre.org/tactics/TA0006/
  technique.id: T1003
  technique.name: OS Credential Dumping
  technique.ref: https://attack.mitre.org/techniques/T1003/
  subtechnique.id: T1003.002
  subtechnique.name: Security Account Manager
  subtechnique.ref: https://attack.mitre.org/techniques/T1003/002/

condition: >
  spawn_process and
  ((ps.name ~= 'VaultCmd.exe' or ps.pe.file.name ~= 'vaultcmd.exe') and ps.cmdline imatches '*/list*') or
  ((ps.name ~= 'rundll32.exe' or ps.pe.file.name ~= 'rundll32.exe') and ps.cmdline imatches '*keymgr.dll*KRShowKeyMgr*') or
  ((ps.name ~= 'cmdkey.exe' or ps.pe.file.name ~= 'cmdkey.exe') and ps.cmdline imatches '*/list*') or
  ((ps.name ~= 'control.exe' or ps.pe.file.name ~= 'control.exe') and ps.cmdline imatches '*keymgr.dll*')

severity: medium

min-engine-version: 3.0.0

```

`rules/credential_access_lsass_access_from_unsigned_executable.yml`:

```yml
name: LSASS access from unsigned executable
id: 348bf896-2201-444f-b1c9-e957a1f063bf
version: 1.0.2
description: |
  Detects attempts by an unsigned process to access the Local Security Authority Subsystem Service (LSASS). 
  Adversaries may try to dump credential information stored in the process memory of LSASS.
labels:
  tactic.id: TA0006
  tactic.name: Credential Access
  tactic.ref: https://attack.mitre.org/tactics/TA0006/
  technique.name: OS Credential Dumping
  technique.ref: https://attack.mitre.org/techniques/T1003/
  subtechnique.id: T1003.001
  subtechnique.name: LSASS Memory
  subtechnique.ref: https://attack.mitre.org/techniques/T1003/001/
references:
  - https://redcanary.com/threat-detection-report/techniques/lsass-memory/

condition: >
  sequence
  maxspan 7m
  by ps.uuid
    |load_unsigned_executable|
    |((open_process) or (open_thread)) and evt.arg[exe] imatches '?:\\Windows\\System32\\lsass.exe'|
action:
  - name: kill

output: >
  Unsigned executable %1.module.path attempted to access Local Security Authority Subsystem Service
severity: high

min-engine-version: 3.0.0

```

`rules/credential_access_lsass_handle_leak_via_seclogon.yml`:

```yml
name: LSASS handle leak via Seclogon
id: 5d55c938-875e-49e1-ae53-fa196d4445eb
version: 1.0.2
description: |
  Identifies suspicious access to LSASS process from a callstack pointing to seclogon.dll that
  may indicate an attempt to leak an LSASS handle via abusing the Secondary Logon service in 
  preparation for credential access.
labels:
  tactic.id: TA0006
  tactic.name: Credential Access
  tactic.ref: https://attack.mitre.org/tactics/TA0006/
  technique.name: OS Credential Dumping
  technique.ref: https://attack.mitre.org/techniques/T1003/
  subtechnique.id: T1003.001
  subtechnique.name: LSASS Memory
  subtechnique.ref: https://attack.mitre.org/techniques/T1003/001/
references:
  - https://github.com/antonioCoco/MalSeclogon
  - https://splintercod3.blogspot.com/p/the-hidden-side-of-seclogon-part-3.html

condition: >
  open_process and 
  evt.arg[exe] imatches '?:\\Windows\\System32\\lsass.exe' and ps.name ~= 'svchost.exe' and
  ps.access.mask.names in ('CREATE_PROCESS', 'DUP_HANDLE') and thread.callstack.modules imatches ('*seclogon.dll')

severity: high

min-engine-version: 3.0.0

```

`rules/credential_access_lsass_memory_dump_preparation_via_silent_process_exit.yml`:

```yml
name: LSASS memory dump preparation via SilentProcessExit
id: d325e426-f89a-4f7c-b655-3874dad07986
version: 1.0.3
description: |
  Adversaries may exploit the SilentProcessExit debugging technique to conduct
  LSASS memory dump via WerFault.exe (Windows Error Reporting) binary by creating
  specific registry keys/values.
  WerFault.exe is a process known for dumping every crashing process. Attackers may
  exploit the WER service to evade defense mechanisms.
  This method relies on a mechanism introduced in Windows 7 called Silent Process Exit,
  which provides the ability to trigger specific actions for a monitored process
  either when process terminates itself by calling ExitProcess(), or another process
  terminates it via the TerminateProcess() API.
labels:
  tactic.id: TA0006
  tactic.name: Credential Access
  tactic.ref: https://attack.mitre.org/tactics/TA0006/
  technique.id: T1003
  technique.name: OS Credential Dumping
  technique.ref: https://attack.mitre.org/techniques/T1003/
  subtechnique.id: T1003.001
  subtechnique.name: LSASS Memory
  subtechnique.ref: https://attack.mitre.org/techniques/T1003/001/
references:
  - https://www.deepinstinct.com/blog/lsass-memory-dumps-are-stealthier-than-ever-before-part-2

condition: >
  modify_registry and registry.path imatches 'HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\SilentProcessExit\\lsass*'

min-engine-version: 3.0.0

```

`rules/credential_access_lsass_memory_dump_via_minidumpwritedump.yml`:

```yml
name: LSASS memory dump via MiniDumpWriteDump
id: fd7ced77-4a95-4658-80f6-6b9d7b5e3777
version: 1.0.2
description: |
  Identifies access to the Local Security Authority Subsystem Service (LSASS) process to dump the
  memory via MiniDumpWriteDump API.
labels:
  tactic.id: TA0006
  tactic.name: Credential Access
  tactic.ref: https://attack.mitre.org/tactics/TA0006/
  technique.id: T1003
  technique.name: OS Credential Dumping
  technique.ref: https://attack.mitre.org/techniques/T1003/
  subtechnique.id: T1003.001
  subtechnique.name: LSASS Memory
  subtechnique.ref: https://attack.mitre.org/techniques/T1003/001/
references:
  - https://redcanary.com/threat-detection-report/techniques/lsass-memory/
  - https://modexp.wordpress.com/2019/08/30/minidumpwritedump-via-com-services-dll/
  - https://www.ired.team/offensive-security/credential-access-and-credential-dumping/dumping-lsass-passwords-without-mimikatz-minidumpwritedump-av-signature-bypass

condition: >
  ((open_process) or (open_thread)) and 
  evt.arg[exe] imatches '?:\\Windows\\System32\\lsass.exe' and
  (thread.callstack.modules imatches ('*dbgcore.dll', '*comsvcs.dll') or thread.callstack.symbols imatches ('*MiniDumpWriteDump'))
action:
  - name: kill

output: >
  LSASS memory dump attempt by process %ps.exe via MiniDumpWriteDump
severity: high

min-engine-version: 3.0.0

```

`rules/credential_access_lsass_memory_dump_via_wer.yml`:

```yml
name: LSASS memory dump via Windows Error Reporting
id: 7b4a74e2-c7a7-4c1f-b2ce-0e0273c3add7
version: 1.0.5
description: |
  Adversaries may abuse Windows Error Reporting service to dump LSASS memory.
  The ALPC protocol can send a message to report an exception on LSASS and
  consequently cause WER to dump the memory of the LSASS process.
labels:
  tactic.id: TA0006
  tactic.name: Credential Access
  tactic.ref: https://attack.mitre.org/tactics/TA0006/
  technique.id: T1003
  technique.name: OS Credential Dumping
  technique.ref: https://attack.mitre.org/techniques/T1003/
  subtechnique.id: T1003.001
  subtechnique.name: LSASS Memory
  subtechnique.ref: https://attack.mitre.org/techniques/T1003/001/
references:
  - https://github.com/deepinstinct/Lsass-Shtinkering

condition: >
  sequence
  maxspan 2m
  by ps.uuid
    |spawn_process and ps.name iin ('WerFault.exe', 'WerFaultSecure.exe')|
    |create_file and file.path icontains 'lsass'|

min-engine-version: 3.0.0

```

`rules/credential_access_lsass_memory_dumping.yml`:

```yml
name: LSASS memory dumping via legitimate or offensive tools
id: 335795af-246b-483e-8657-09a30c102e63
version: 1.2.0
description: |
  Detects an attempt to dump the LSAAS memory to the disk by employing legitimate
  tools such as procdump, Task Manager, Process Explorer or built-in Windows tools
  such as comsvcs.dll.
labels:
  tactic.id: TA0006
  tactic.name: Credential Access
  tactic.ref: https://attack.mitre.org/tactics/TA0006/
  technique.id: T1003
  technique.name: OS Credential Dumping
  technique.ref: https://attack.mitre.org/techniques/T1003/
  subtechnique.id: T1003.001
  subtechnique.name: LSASS Memory
  subtechnique.ref: https://attack.mitre.org/techniques/T1003/001/
references:
  - https://redcanary.com/threat-detection-report/techniques/lsass-memory/
  - https://www.deepinstinct.com/blog/lsass-memory-dumps-are-stealthier-than-ever-before

condition: >
  sequence
  maxspan 2m
  by ps.uuid
    |open_process and
     ps.access.mask.names in ('ALL_ACCESS', 'CREATE_PROCESS', 'VM_READ', 'DUP_HANDLE') and
     evt.arg[exe] imatches '?:\\Windows\\System32\\lsass.exe' and
     ps.exe not imatches
                (
                  '?:\\Windows\\System32\\svchost.exe',
                  '?:\\ProgramData\\Microsoft\\Windows Defender\\*\\MsMpEng.exe'
                )
    |
    |create_file and (file.extension iin ('.dmp', '.mdmp', '.dump') or is_minidump(file.path))|

output: >
  Detected an attempt by `%1.ps.name` process to access and read
  the memory of the **Local Security And Authority Subsystem Service**
  and subsequently write the `%2.file.path` dump file to the disk device
severity: critical

min-engine-version: 3.0.0

```

`rules/credential_access_lsass_process_clone_creation_via_reflection.yml`:

```yml
name: LSASS process clone creation via reflection
id: cdf3810a-4832-446a-ac9d-d108cf2e313c
version: 1.0.3
description: |
  Identifies the creation of an LSASS clone process via RtlCreateProcessReflection API function.
  Adversaries can use this technique to dump credentials material from the LSASS fork and evade
  defenses.
labels:
  tactic.id: TA0006
  tactic.name: Credential Access
  tactic.ref: https://attack.mitre.org/tactics/TA0006/
  technique.id: T1003
  technique.name: OS Credential Dumping
  technique.ref: https://attack.mitre.org/techniques/T1003/
  subtechnique.id: T1003.001
  subtechnique.name: LSASS Memory
  subtechnique.ref: https://attack.mitre.org/techniques/T1003/001/
references:
  - https://github.com/Offensive-Panda/LsassReflectDumping
  - https://s3cur3th1ssh1t.github.io/Reflective-Dump-Tools/

condition: >
  spawn_process and 
  ps.name ~= 'lsass.exe' and ps.parent.name ~= 'lsass.exe' and
  thread.callstack.symbols imatches ('ntdll.dll!RtlCloneUserProcess', 'ntdll.dll!RtlCreateProcessReflection')
action:
  - name: kill

severity: high

min-engine-version: 3.0.0

```

`rules/credential_access_potential_sam_hive_dumping.yml`:

```yml
name: Potential SAM hive dumping
id: 2f326557-0291-4eb1-a87a-7a17b7d941cb
version: 1.0.7
description:
  Identifies access to the Security Account Manager registry hives.
labels:
  tactic.id: TA0006
  tactic.name: Credential Access
  tactic.ref: https://attack.mitre.org/tactics/TA0006/
  technique.id: T1003
  technique.name: OS Credential Dumping
  technique.ref: https://attack.mitre.org/techniques/T1003/
  subtechnique.id: T1003.002
  subtechnique.name: Security Account Manager
  subtechnique.ref: https://attack.mitre.org/techniques/T1003/002/
references:
  - https://www.ired.team/offensive-security/credential-access-and-credential-dumping/dumping-hashes-from-sam-registry

condition: >
  sequence
  maxspan 10m
  by ps.uuid
    |spawn_process and
     not (ps.parent.exe imatches
                (
                  '?:\\Program Files\\*.exe',
                  '?:\\Program Files (x86)\\*.exe',
                  '?:\\Windows\\System32\\svchost.exe'
                ) or
      (ps.cmdline imatches '"?:\\Windows\\Microsoft.NET\\Framework\\*\\ngen.exe" ExecuteQueuedItems /LegacyServiceBehavior')
     )
    |
    |open_registry and
     registry.path imatches 'HKEY_LOCAL_MACHINE\\SAM\\SAM\\Domains\\Account\\*' and
     registry.path not imatches
                (
                  'HKEY_LOCAL_MACHINE\\SAM\\SAM\\Domains\\Account\\Users',
                  'HKEY_LOCAL_MACHINE\\SAM\\SAM\\Domains\\Account\\Users\\Names',
                  'HKEY_LOCAL_MACHINE\\SAM\\SAM\\Domains\\Account',
                  'HKEY_LOCAL_MACHINE\\SAM\\SAM\\Account\\Aliases\\*'
                ) and
     ps.exe not imatches
                (
                  '?:\\Windows\\System32\\lsass.exe',
                  '?:\\Windows\\System32\\RuntimeBroker.exe',
                  '?:\\Windows\\explorer.exe',
                  '?:\\Windows\\System32\\Taskmgr.exe',
                  '?:\\Windows\\System32\\sihost.exe',
                  '?:\\Windows\\System32\\SearchIndexer.exe',
                  '?:\\Windows\\System32\\SearchProtocolHost.exe',
                  '?:\\Windows\\System32\\svchost.exe',
                  '?:\\Windows\\System32\\services.exe',
                  '?:\\Windows\\System32\\taskhostw.exe',
                  '?:\\Windows\\System32\\backgroundTaskHost.exe',
                  '?:\\Windows\\System32\\WerFault.exe',
                  '?:\\Windows\\System32\\ctfmon.exe',
                  '?:\\Windows\\System32\\Wbem\\WmiPrvSE.exe',
                  '?:\\Windows\\System32\\CompatTelRunner.exe',
                  '?:\\Windows\\System32\\cleanmgr.exe',
                  '?:\\Windows\\System32\\MoUsoCoreWorker.exe',
                  '?:\\Windows\\System32\\lpremove.exe',
                  '?:\\Windows\\System32\\LogonUI.exe',
                  '?:\\ProgramData\\Microsoft\\Windows Defender\\*\\MsMpEng.exe',
                  '?:\\ProgramData\\Microsoft\\Windows Defender\\*\\MpDefenderCoreService.exe',
                  '?:\\Windows\\System32\\ApplicationFrameHost.exe',
                  '?:\\Windows\\System32\\wbem\\WMIADAP.exe',
                  '?:\\Windows\\System32\\cleanmgr.exe'
                )
      |

min-engine-version: 3.0.0

```

`rules/credential_access_remote_thread_creation_into_lsass.yml`:

```yml
name: Remote thread creation into LSASS
id: e3ce8d6f-c260-48d6-9398-3c1c71726297
version: 1.0.4
description: |
  Identifies the creation of a remote thread in LSASS (Local Security And Authority Subsystem Service)
  by untrusted or suspicious processes. This may indicate attempts to execute code inside the LSASS process
  in preparation for credential stealing.
labels:
   tactic.id: TA0006
   tactic.name: Credential Access
   tactic.ref: https://attack.mitre.org/tactics/TA0006/
   technique.id: T1003
   technique.name: OS Credential Dumping
   technique.ref: https://attack.mitre.org/techniques/T1003/
   subtechnique.id: T1003.001
   subtechnique.name: LSASS Memory
   subtechnique.ref: https://attack.mitre.org/techniques/T1003/001/

condition: >
  create_remote_thread and
  evt.arg[exe] imatches '?:\\Windows\\System32\\lsass.exe' and
  (ps.name iin script_interpreters or ps.name ~= 'rundll32.exe' or ps.signature.exists = false or ps.signature.trusted = false)

min-engine-version: 3.0.0

```

`rules/credential_access_suspicious_access_to_active_directory_domain_database.yml`:

```yml
name: Suspicious access to Active Directory domain database
id: a30c100e-28d0-4aa0-b98d-0d38025c2c29
version: 1.0.4
description: |
  Detects suspicious access to the Active Directory domain database.
  Adversaries may attempt to access or create a copy of the Active Directory
  domain database in order to steal credential information.
labels:
  tactic.id: TA0006
  tactic.name: Credential Access
  tactic.ref: https://attack.mitre.org/tactics/TA0006/
  technique.id: T1003
  technique.name: OS Credential Dumping
  technique.ref: https://attack.mitre.org/techniques/T1003/
  subtechnique.id: T1003.003
  subtechnique.name: NTDS
  subtechnique.ref: https://attack.mitre.org/techniques/T1003/003/

condition: >
  open_file and
  file.path imatches
            (
              '\\Device\\HarddiskVolumeShadowCopy*\\WINDOWS\\NTDS\\ntds.dit',
              '?:\\WINDOWS\\NTDS\\ntds.dit'
            ) and
  ps.exe not imatches
            (
              '?:\\Windows\\System32\\lsass.exe',
              '?:\\ProgramData\\Microsoft\\Windows Defender\\*\\MsMpEng.exe'
            )

min-engine-version: 3.0.0

```

`rules/credential_access_suspicious_access_to_unattended_panther_files.yml`:

```yml
name: Suspicious access to Unattended Panther files
id: d305fb15-6ad1-4d61-a84b-ada462f23a55
version: 1.0.4
description: |
  Identifies suspicious to access to unattend.xml files where credentials
  are commonly stored within the Panther directory. Adversaries may search local
  file systems and remote file shares for files containing insecurely stored credentials.
labels:
  tactic.id: TA0006
  tactic.name: Credential Access
  tactic.ref: https://attack.mitre.org/tactics/TA0006/
  technique.id: T1552
  technique.name: Unsecured credentials
  technique.ref: https://attack.mitre.org/techniques/T1552/
  subtechnique.id: T1552.001
  subtechnique.name: Credentials In Files
  subtechnique.ref: https://attack.mitre.org/techniques/T1552/001/

condition: >
  open_file and
  file.path imatches
            (
              '?:\\Windows\\Panther\\Unattend\\Unattended.xml',
              '?:\\Windows\\Panther\\Unattend\\Unattend.xml',
              '?:\\Windows\\Panther\\Unattended.xml',
              '?:\\Windows\\Panther\\Unattend.xml'
            ) and
  ps.exe not imatches
            (
              '?:\\Program Files\\*',
              '?:\\Program Files(x86)\\*',
              '?:\\ProgramData\\Microsoft\\Windows Defender\\*\\MsMpEng.exe'
            )

min-engine-version: 3.0.0

```

`rules/credential_access_suspicious_access_to_windows_dpapi_master_keys.yml`:

```yml
name: Suspicious access to Windows DPAPI Master Keys
id: b1d5732a-5ad4-4cdd-8791-c22e34c591e5
version: 1.0.4
description: |
  Detects suspicious processes accessing the Windows Data Protection API Master keys
  which is a sign of potential credential stealing.
  DPAPI master keys are responsible for symmetric encryption of asymmetric private keys,
  using a user or system secret as a significant contribution of entropy.
  DPAPI allows developers to encrypt keys using a symmetric key derived from the
  user's logon secrets, or in the case of system encryption, using the system's
  domain authentication secrets.
labels:
  tactic.id: TA0006
  tactic.name: Credential Access
  tactic.ref: https://attack.mitre.org/tactics/TA0006/
  technique.id: T1555
  technique.name: Credentials from Password Stores
  technique.ref: https://attack.mitre.org/techniques/T1555/
  subtechnique.id: T1555.004
  subtechnique.name: Windows Credential Manager
  subtechnique.ref: https://attack.mitre.org/techniques/T1555/004/
references:
  - https://www.sygnia.co/blog/the-downfall-of-dpapis-top-secret-weapon/
  - https://book.hacktricks.xyz/windows-hardening/windows-local-privilege-escalation/dpapi-extracting-passwords

condition: >
  open_file and
  file.path imatches
            (
              '?:\\Windows\\System32\\Microsoft\\Protect\\S-1-5-18\\Users\\*',
              '?:\\Users\\*\\AppData\\*\\Microsoft\\Protect\\S-1-5-21*\\*',
              '?:\\Users\\*\\AppData\\*\\Microsoft\\Protect\\S-1-12-1-*\\*'
            ) and
  ps.exe not imatches
            (
              '?:\\Program Files\\*',
              '?:\\Program Files(x86)\\*',
              '?:\\Windows\\System32\\*',
              '?:\\Windows\\SysWOW64\\*'
            )

min-engine-version: 3.0.0

```

`rules/credential_access_suspicious_access_to_windows_manager_files.yml`:

```yml
name: Suspicious access to Windows Credential Manager files
id: 4ab688f7-94e2-481b-9c7f-c49f3a79a379
version: 1.0.4
description: |
  Identifies suspicious processes trying to acquire credentials from the Windows Credential Manager.
labels:
  tactic.id: TA0006
  tactic.name: Credential Access
  tactic.ref: https://attack.mitre.org/tactics/TA0006/
  technique.id: T1555
  technique.name: Credentials from Password Stores
  technique.ref: https://attack.mitre.org/techniques/T1555/
  subtechnique.id: T1555.004
  subtechnique.name: Windows Credential Manager
  subtechnique.ref: https://attack.mitre.org/techniques/T1555/004/

condition: >
  open_file and
  file.path imatches
            (
              '?:\\Users\\*\\AppData\\*\\Microsoft\\Credentials\\*',
              '?:\\Windows\\System32\\config\\systemprofile\\AppData\\*\\Microsoft\\Credentials\\*'
            ) and
  ps.exe not imatches
            (
              '?:\\Program Files\\*',
              '?:\\Program Files(x86)\\*',
              '?:\\Windows\\System32\\lsass.exe'
            )

min-engine-version: 3.0.0

```

`rules/credential_access_suspicious_access_to_windows_vault_files.yml`:

```yml
name: Suspicious access to Windows Vault files
id: 44400221-f98d-424a-9388-497c75b18924
version: 1.0.4
description: |
  Identifies attempts from adversaries to acquire credentials from Vault files.
labels:
  tactic.id: TA0006
  tactic.name: Credential Access
  tactic.ref: https://attack.mitre.org/tactics/TA0006/
  technique.id: T1555
  technique.name: Credentials from Password Stores
  technique.ref: https://attack.mitre.org/techniques/T1555/
  subtechnique.id: T1555.004
  subtechnique.name: Windows Credential Manager
  subtechnique.ref: https://attack.mitre.org/techniques/T1555/004/

condition: >
  open_file and
  file.path imatches
            (
              '?:\\Users\\*\\AppData\\*\\Microsoft\\Vault\\*\\*',
              '?:\\ProgramData\\Microsoft\\Vault\\*'
            ) and
  file.extension in vault_extensions and
  ps.exe not imatches
            (
              '?:\\Program Files\\*',
              '?:\\Program Files(x86)\\*',
              '?:\\Windows\\System32\\lsass.exe',
              '?:\\Windows\\System32\\svchost.exe'
            )

min-engine-version: 3.0.0

```

`rules/credential_access_suspicious_security_package_loaded_by_lsass.yml`:

```yml
name: Suspicious security package DLL loaded
id: 2c74f176-9a95-4344-a1aa-15aa06e16919
version: 1.1.3
description: |
  Attackers can abuse Windows Security Support Provider and Authentication Packages to
  dynamically inject a Security Package into the Local Security Authority Subsystem Service
  process to intercept all logon passwords.
labels:
  tactic.id: TA0006
  tactic.name: Credential Access
  tactic.ref: https://attack.mitre.org/tactics/TA0006/
  technique.id: T1003
  technique.name: OS Credential Dumping
  technique.ref: https://attack.mitre.org/techniques/T1003/
  subtechnique.id: T1003.001
  subtechnique.name: LSASS Memory
  subtechnique.ref: https://attack.mitre.org/techniques/T1003/001/
references:
  - https://www.sentinelone.com/labs/operation-tainted-love-chinese-apts-target-telcos-in-new-attacks/
  - https://www.ired.team/offensive-security/credential-access-and-credential-dumping/intercepting-logon-credentials-via-custom-security-support-provider-and-authentication-package

condition: >
  ps.name ~= 'lsass.exe' and thread.callstack.modules imatches ('?:\\Windows\\System32\\sspisrv.dll') and
  (load_unsigned_or_untrusted_module)

min-engine-version: 3.0.0

```

`rules/credential_access_suspicious_vault_client_dll_load.yml`:

```yml
name: Suspicious Vault client DLL load
id: 64af2e2e-2309-4079-9c0f-985f1dd930f5
version: 1.0.5
description: |
  Identifies loading of the Vault client DLL by an unusual process. Adversaries can abuse the functions provided 
  by the Credential Vault Client Library to enumerate or harvest saved credentials.
labels:
  tactic.id: TA0006
  tactic.name: Credential Access
  tactic.ref: https://attack.mitre.org/tactics/TA0006/
  technique.id: T1555
  technique.name: Credentials from Password Stores
  technique.ref: https://attack.mitre.org/techniques/T1555/
  subtechnique.id: T1555.004
  subtechnique.name: Windows Credential Manager
  subtechnique.ref: https://attack.mitre.org/techniques/T1555/004/
references:
  - https://redcanary.com/blog/incident-response/active-breach-evading-defenses/
  - https://medium.com/threatpunter/detecting-adversary-tradecraft-with-image-load-event-logging-and-eql-8de93338c16

condition: >
  sequence
  maxspan 2m
  by ps.uuid
    |spawn_process and
     ps.exe != '' and
     not
      (
        ps.exe imatches
                    (
                      '?:\\Windows\\System32\\MDMAppInstaller.exe',
                      '?:\\Windows\\uus\\*\\MoUsoCoreWorker.exe',
                      '?:\\Windows\\Microsoft.NET\\Framework64\\*\\dfsvc.exe',
                      '?:\\Windows\\Microsoft.NET\\Framework64\\*\\mscorsvw.exe',
                      '?:\\Program Files\\*.exe', 
                      '?:\\Program Files (x86)\\*.exe',
                      '?:\\Windows\\winsxs\\*\\TiWorker.exe'
                    ) or
        (ps.exe imatches '?:\\WINDOWS\\System32\\taskhostw.exe' and ps.parent.args intersects ('-k', 'netsvcs', '-p', '-s', 'Schedule')) or
        (ps.exe imatches '?:\\Windows\\System32\\RuntimeBroker.exe') or
        (ps.exe imatches ('?:\\Program Files\\WindowsApps\\Microsoft.*.exe', '?:\\Windows\\Microsoft.NET\\Framework*\\NGenTask.exe')) or
        (ps.exe imatches '?:\\WINDOWS\\system32\\BackgroundTaskHost.exe' and ps.args imatches ('-ServerName:*')) or
        (ps.exe imatches '?:\\Windows\\System32\\SecurityHealth\\*\\SecurityHealthHost.exe') or
        (ps.exe imatches '?:\\WINDOWS\\uus\\*\\MoUsoCoreWorker.exe') or
        (ps.parent.exe imatches '?:\\Windows\\System32\\services.exe') or
        (ps.parent.exe imatches '?:\\Program Files\\Microsoft OneDrive\\OneDriveStandaloneUpdater.exe')
      )
    |
    |load_dll and dll.name ~= 'vaultcli.dll'|

output: >
  Suspicious process %2.ps.exe loaded the Credential Vault Client DLL for potential credentials harvesting
severity: high

min-engine-version: 3.0.0

```

`rules/credential_access_unusual_access_to_ssh_keys.yml`:

```yml
name: Unusual access to SSH keys
id: 90f5c1bd-abd6-4d1b-94e0-229f04473d60
version: 1.0.5
description: |
  Identifies access by unusual process to saved SSH keys.
labels:
  tactic.id: TA0006
  tactic.name: Credential Access
  tactic.ref: https://attack.mitre.org/tactics/TA0006/
  technique.id: T1552
  technique.name: Unsecured credentials
  technique.ref: https://attack.mitre.org/techniques/T1552/
  subtechnique.id: T1552.001
  subtechnique.name: Credentials In Files
  subtechnique.ref: https://attack.mitre.org/techniques/T1552/001/

condition: >
  open_file and
  file.path imatches '?:\\Users\\*\\.ssh\\known_hosts' and
  ps.exe not imatches
            (
              '?:\\Program Files\\*',
              '?:\\Program Files(x86)\\*',
              '?:\\ProgramData\\Microsoft\\Windows Defender\\*\\MsMpEng.exe',
              '?:\\Windows\\System32\\svchost.exe'
            ) and
  ps.name not imatches
            (
              'PuTTYNG.exe',
              'putty*.exe',
              'ssh.exe',
              'WinSCP.exe'
            )

min-engine-version: 3.0.0

```

`rules/credential_access_unusual_access_to_web_browser_credential_stores.yml`:

```yml
name: Unusual access to Web Browser Credential stores
id: 9d889b2b-ca13-4a04-8919-ff1151f23a71
version: 1.0.4
description: |
  Identifies access to Web Browser Credential stores by unusual processes.
labels:
  tactic.id: TA0006
  tactic.name: Credential Access
  tactic.ref: https://attack.mitre.org/tactics/TA0006/
  technique.id: T1555
  technique.name: Credentials from Password Stores
  technique.ref: https://attack.mitre.org/techniques/T1555/
  subtechnique.id: T1555.003
  subtechnique.name: Credentials from Web Browsers
  subtechnique.ref: https://attack.mitre.org/techniques/T1555/003/

condition: >
  open_file and
  file.path imatches web_browser_cred_stores and
  ps.name not iin web_browser_binaries and
  ps.exe not imatches
            (
              '?:\\Program Files\\*',
              '?:\\Program Files(x86)\\*',
              '*\\Windows\\System32\\SearchProtocolHost.exe',
              '*\\Windows\\explorer.exe',
              '?:\\ProgramData\\Microsoft\\Windows Defender\\*\\MsMpEng.exe',
              '?:\\ProgramData\\Microsoft\\Windows Defender\\*\\MpCopyAccelerator.exe'
            )

min-engine-version: 3.0.0

```

`rules/credential_access_unusual_access_to_windows_credential_history.yml`:

```yml
name: Unusual access to Windows Credential history files
id: 9d94062f-2cf3-407c-bd65-4072fe4b167f
version: 1.0.5
description: |
  Detects unusual accesses to the Windows Credential history file.
  The CREDHIST file contains all previous password-linked master key hashes used by
  DPAPI to protect secrets on the device. Adversaries may obtain credentials
  from the Windows Credentials Manager.
labels:
  tactic.id: TA0006
  tactic.name: Credential Access
  tactic.ref: https://attack.mitre.org/tactics/TA0006/
  technique.id: T1555
  technique.name: Credentials from Password Stores
  technique.ref: https://attack.mitre.org/techniques/T1555/
  subtechnique.id: T1555.004
  subtechnique.name: Windows Credential Manager
  subtechnique.ref: https://attack.mitre.org/techniques/T1555/004/

condition: >
  open_file and
  file.path imatches '?:\\Users\\*\\AppData\\*\\Microsoft\\Protect\\CREDHIST' and
  ps.exe not imatches
            (
              '?:\\Program Files\\*',
              '?:\\Windows\\System32\\lsass.exe',
              '?:\\Windows\\System32\\svchost.exe',
              '?:\\Windows\\ccmcache\\*.exe'
            )

min-engine-version: 3.0.0

```

`rules/defense_evasion_appdomain_manager_injection_via_clr_search_order_hijacking.yml`:

```yml
name: AppDomain Manager injection via CLR search order hijacking
id: 9319fafd-b7dc-4d85-b41a-54a8d4f1ab18
version: 1.0.7
description: |
  Adversaries may execute their own malicious payloads by hijacking how the .NET AppDomainManager loads assemblies. 
  The .NET framework uses the AppDomainManager class to create and manage one or more isolated runtime environments 
  (called application domains) inside a process to host the execution of .NET applications. Assemblies may be loaded 
  into an application domain as executable code.
 
  Adversaries can abuse the CLR search order to load the malicious assembly from a writable directory by
  simply following the assembly file naming conventions and ensuring the .NET LOBIN is executed with the
  right environment variables set.
labels:
   tactic.id: TA0005
   tactic.name: Defense Evasion
   tactic.ref: https://attack.mitre.org/tactics/TA0005/
   technique.id: T1574
   technique.name: Hijack Execution Flow
   technique.ref: https://attack.mitre.org/techniques/T1574/
   subtechnique.id: T1574.014
   subtechnique.name: AppDomainManager
   subtechnique.ref: https://attack.mitre.org/techniques/T1574/014/
references:
  - https://ipslav.github.io/2023-12-12-let-me-manage-your-appdomain/
  - https://www.rapid7.com/blog/post/2023/05/05/appdomain-manager-injection-new-techniques-for-red-teams/

condition: >
  (load_unsigned_or_untrusted_module) and
  ps.exe != '' and ((base(dir(module.path)) ~= base(module.path, false)) or (ps.envs[APPDOMAIN_MANAGER_ASM] istartswith module.name)) and
  ps.pe.is_dotnet and (module.pe.is_dotnet or thread.callstack.symbols imatches ('clr.dll!ParseManifest*'))

output: >
  Process %ps.exe loaded untrusted .NET assembly %module.path from suspicious location
severity: high

min-engine-version: 3.0.0

```

`rules/defense_evasion_clear_eventlog.yml`:

```yml
name: Clear Eventlog
id: 692d3143-e1fb-4dab-8c9c-3109ff80ec85
version: 1.0.3
description: |
  Identifies attempts to clear Windows event log stores. Adversaries attempt to evade detection or 
  destroy forensic evidence on a system to cover their trails and slow down incident response.
labels:
  tactic.id: TA0005
  tactic.name: Defense Evasion
  tactic.ref: https://attack.mitre.org/tactics/TA0005/
  technique.id: T1070
  technique.name: Indicator Removal
  technique.ref: https://attack.mitre.org/techniques/T1070/
  subtechnique.id: T1070.001
  subtechnique.name: Clear Windows Event Logs
  subtechnique.ref: https://attack.mitre.org/techniques/T1070/001/

condition: >
  sequence
  maxspan 1m
  by file.object
    |set_file_information and evt.pid != 4 and file.info_class = 'EOF' and file.info.eof_size > 50000 and file.path imatches '?:\\Windows\\System32\\winevt\\Logs\\*.evtx'|
    |set_file_information and file.info_class = 'Allocation' and file.info.allocation_size > 50000|

output: >
  Windows Eventlog store %1.file.path was cleared
severity: medium

min-engine-version: 3.0.0

```

`rules/defense_evasion_dll_loaded_via_apc_queue.yml`:

```yml
name: DLL loaded via APC queue
id: e1ee3912-ad7c-4acb-80f4-84db87e54d5e
version: 1.0.4
description: |
  Identifies loading of a DLL with a callstack originating from the thread
  alertable state that led to the execution of an APC routine. This may be
  indicative of sleep obfuscation or process injection attempt.
labels:
  tactic.id: TA0005
  tactic.name: Defense Evasion
  tactic.ref: https://attack.mitre.org/tactics/TA0005/
  technique.name: Process Injection
  technique.ref: https://attack.mitre.org/techniques/T1055/
  subtechnique.id: T1055.003
references:
  - https://github.com/Idov31/Cronos

condition: >
  load_dll and dll.name iin
              (
                'winhttp.dll', 'clr.dll', 'bcrypt.dll', 'bcryptprimitives.dll',
                'wininet.dll', 'taskschd.dll', 'dnsapi.dll', 'coreclr.dll', 'ws2_32.dll',
                'wmiutils.dll', 'vaultcli.dll', 'System.Management.Automation.dll', 'psapi.dll',
                'mstscax.dll', 'dsquery.dll', 'mstask.dll', 'bitsproxy.dll'
              ) and
  thread.callstack.symbols imatches ('ntdll.dll!KiUserApcDispatcher') and
  thread.callstack.symbols imatches ('ntdll.dll!ZwDelayExecution') and
  thread.callstack.symbols imatches ('KernelBase.dll!Sleep*')

min-engine-version: 3.0.0

```

`rules/defense_evasion_dll_loaded_via_callback_function.yml`:

```yml
name: DLL loaded via a callback function
id: c7f46d0a-10b2-421a-b33c-f4df79599f2e
version: 1.0.6
description: |
  Identifies module proxying as a method to conceal suspicious callstacks. Adversaries use module proxying
  the hide the origin of the LoadLibrary call from the callstack by loading the library from the callback
  function.
labels:
   tactic.id: TA0005
   tactic.name: Defense Evasion
   tactic.ref: https://attack.mitre.org/tactics/TA0005/
   technique.id: T1055
   technique.name: Process Injection
   technique.ref: https://attack.mitre.org/techniques/T1055/
tags:
  - https://github.com/hlldz/misc/tree/main/proxy_calls
  - https://0xdarkvortex.dev/proxying-dll-loads-for-hiding-etwti-stack-tracing/

condition: >
  sequence
  maxspan 2m
  by ps.uuid
   |spawn_process|
   |load_dll and dll.name iin
                (
                  'winhttp.dll', 'clr.dll', 'bcrypt.dll', 'bcryptprimitives.dll',
                  'wininet.dll', 'taskschd.dll', 'dnsapi.dll', 'coreclr.dll', 'ws2_32.dll',
                  'wmiutils.dll', 'vaultcli.dll', 'System.Management.Automation.dll', 'psapi.dll',
                  'mstscax.dll', 'dsquery.dll', 'mstask.dll', 'bitsproxy.dll'
                ) and 
    thread.callstack.summary imatches
                (
                  'ntdll.dll|kernelbase.dll|ntdll.dll|kernel32.dll|ntdll.dll',
                  'ntdll.dll|wow64.dll|wow64cpu.dll|wow64.dll|ntdll.dll|kernelbase.dll|ntdll.dll|kernel32.dll|ntdll.dll'
                )
   |

output: >
  %2.module.path loaded from callback function by process %ps.exe
severity: high

min-engine-version: 3.0.0

```

`rules/defense_evasion_dll_loaded_via_ldrpkernel32_overwrite.yml`:

```yml
name: DLL loaded via LdrpKernel32 overwrite
id: 56739eda-210f-4a30-a114-d55ca60976df
version: 1.0.4
description: |
  Detects attempts to bypass the standard NTDLL bootstrap process by loading a malicious DLL early through hijacking. 
  The malicious DLL, containing attacker-controlled code, is loaded in place of the legitimate kernel32 DLL.
labels:
  tactic.id: TA0005
  tactic.name: Defense Evasion
  tactic.ref: https://attack.mitre.org/tactics/TA0005/
  technique.name: Hijack Execution Flow
  technique.ref: https://attack.mitre.org/techniques/T1574/
  subtechnique.id: T1574.001
  subtechnique.name: DLL Search Order Hijacking
  subtechnique.ref: https://attack.mitre.org/techniques/T1574/001/
references:
  - https://github.com/rbmm/LdrpKernel32DllName
  - https://www.elastic.co/security-labs/peeling-back-the-curtain-with-call-stacks

condition: >
  (load_unsigned_or_untrusted_dll) and
  thread.callstack.symbols imatches ('*!BaseThreadInitThunk*') and
  dll.path not imatches '?:\\Windows\\assembly\\NativeImages_*\\System.Numerics.ni.dll' and
  not foreach(thread._callstack, $frame,
              $frame.symbol imatches ('?:\\Windows\\System32\\kernel32.dll!BaseThreadInitThunk*',
                                      '?:\\Windows\\SysWOW64\\kernel32.dll!BaseThreadInitThunk*',
                                      '?:\\Windows\\WinSxS\\*\\kernel32.dll!BaseThreadInitThunk*',
                                      '?:\\Windows\\WinSxS\\Temp\\PendingDeletes\\*!BaseThreadInitThunk*',
                                      '\\Device\\*\\Windows\\*\\kernel32.dll!BaseThreadInitThunk*'))
action:
  - name: kill

output: >
  DLL %dll.path loaded via LdrpKernel32 overwrite evasion by process %ps.exe
severity: high

min-engine-version: 3.0.0

```

`rules/defense_evasion_dll_sideloading_via_copied_binary.yml`:

```yml
name: DLL Side-Loading via a copied binary
id: 80798e2c-6c37-472b-936c-1d2d6b95ff3c
version: 1.0.6
description: |
  Identifies when a binary is copied to a directory and shortly followed
  by the loading of an unsigned DLL from the same directory. Adversaries may
  opt for moving legitimate signed binaries to a random directory and use them
  to side-load a malicious library.
labels:
  tactic.id: TA0005
  tactic.name: Defense Evasion
  tactic.ref: https://attack.mitre.org/tactics/TA0005/
  technique.id: T1574
  technique.name: Hijack Execution Flow
  technique.ref: https://attack.mitre.org/techniques/T1574/
  subtechnique.id: T1574.002
  subtechnique.name: DLL Side-Loading
  subtechnique.ref: https://attack.mitre.org/techniques/T1574/002/

condition: >
  sequence
  maxspan 8m
    |create_file and
     file.is_exec and ps.sid not in ('S-1-5-18', 'S-1-5-19', 'S-1-5-20') and
     thread.callstack.symbols imatches ('*CopyFile*', '*MoveFile*')
    | by file.path
    |(load_dll) and
     dir(image.path) ~= dir(ps.exe) and
     ps.signature.subject icontains 'Microsoft' and ps.signature.trusted and
     (dll.signature.exists = false or dll.signature.trusted = false)
    | by ps.exe

min-engine-version: 3.0.0

```

`rules/defense_evasion_dll_sideloading_via_microsoft_office_dropped_file.yml`:

```yml
name: DLL Side-Loading via Microsoft Office dropped file
id: d808175d-c4f8-459d-b17f-ca9a88890c04
version: 1.0.4
description: |
  Identifies Microsoft Office process creating a DLL or other variant of an executable object which
  is later loaded by a trusted binary. Adversaries may exploit this behavior by delivering malicious 
  modules via Microsoft Office documents.
labels:
  tactic.id: TA0005
  tactic.name: Defense Evasion
  tactic.ref: https://attack.mitre.org/tactics/TA0005/
  technique.id: T1574
  technique.name: Hijack Execution Flow
  technique.ref: https://attack.mitre.org/techniques/T1574/
  subtechnique.id: T1574.002
  subtechnique.name: DLL Side-Loading
  subtechnique.ref: https://attack.mitre.org/techniques/T1574/002/

condition: >
  sequence
  maxspan 6m
    |create_file and
     (file.extension iin ('.dll', '.cpl', '.ocx') or file.is_dll) and
     ps.name iin msoffice_binaries
    | by file.path
    |(load_unsigned_or_untrusted_dll) and
     ps.name not iin msoffice_binaries and ps.signature.trusted = true and
     dll.path not imatches '?:\\Windows\\assembly\\NativeImages_*' and
     ps.exe not imatches
                (
                  '?:\\Windows\\System32\\msiexec.exe',
                  '?:\\Windows\\SysWOW64\\msiexec.exe',
                  '?:\\Windows\\System32\\spoolsv.exe'
                )
    | by dll.path

output: >
  Suspicious DLL %1.file.path dropped by Microsoft Office process %1.ps.exe and subsequently loaded by process %2.ps.exe
severity: high

min-engine-version: 3.0.0

```

`rules/defense_evasion_dotnet_assembly_loaded_by_unmanaged_process.yml`:

```yml
name: .NET assembly loaded by unmanaged process
id: 34be8bd1-1143-4fa8-bed4-ae2566b1394a
version: 1.0.10
description: |
  Identifies the loading of the .NET assembly by an unmanaged process. Adversaries can load the CLR runtime
  inside unmanaged process and execute the assembly via the ICLRRuntimeHost::ExecuteInDefaultAppDomain method.
labels:
   tactic.id: TA0005
   tactic.name: Defense Evasion
   tactic.ref: https://attack.mitre.org/tactics/TA0005/
   technique.id: T1055
   technique.name: Process Injection
   technique.ref: https://attack.mitre.org/techniques/T1055/
references:
  - https://detect.fyi/exploring-execute-assembly-a-deep-dive-into-in-memory-threat-execution-60adc61aef8
  - https://www.ired.team/offensive-security/code-injection-process-injection/injecting-and-executing-.net-assemblies-to-unmanaged-process

condition: >
  (load_unsigned_or_untrusted_module) and
  ps.exe != '' and ps.pe.is_dotnet = false and
  (dll.pe.is_dotnet or thread.callstack.modules imatches ('*clr.dll')) and
  dll.path not imatches
                (
                  '?:\\Windows\\assembly\\*\\*.ni.dll',
                  '?:\\Program Files\\WindowsPowerShell\\Modules\\*\\*.dll',
                  '?:\\Windows\\Microsoft.NET\\assembly\\*\\*.dll'
                ) and
  ps.exe not imatches
                (
                  '?:\\Program Files\\WindowsApps\\*\\CrossDeviceService.exe',
                  '?:\\Program Files\\WindowsApps\\*\\WidgetService.exe',
                  '?:\\Program Files\\WindowsApps\\*\\PhoneExperienceHost.exe',
                  '?:\\Program Files\\WindowsApps\\*\\WindowsSandboxServer.exe',
                  '?:\\Program Files\\Conexant\\SAII\\SmartAudio.exe',
                  '?:\\Windows\\Microsoft.NET\\Framework*\\mscorsvw.exe'
                )

output: >
  .NET assembly %dll.path loaded by unmanaged process %ps.exe
severity: high

min-engine-version: 3.0.0

```

`rules/defense_evasion_hidden_registry_key_creation.yml`:

```yml
name: Hidden registry key creation
id: 65deda38-9b1d-42a0-9f40-a68903e81b49
version: 1.1.6
description: |
  Identifies the creation of a hidden registry key. Adversaries can utilize the
  native NtSetValueKey API to create a hidden registry key and conceal payloads
  or commands used to maintain persistence.
labels:
  tactic.id: TA0005
  tactic.name: Defense Evasion
  tactic.ref: https://attack.mitre.org/tactics/TA0005/
  technique.id: T1112
  technique.name: Modify Registry
  technique.ref: https://attack.mitre.org/techniques/T1112/
references:
  - https://github.com/outflanknl/SharpHide

condition: >
  set_value and
  evt.pid != 4 and registry.path endswith '\\' and
  thread.callstack.symbols imatches ('ntdll.dll!NtSetValueKey', 'ntdll.dll!ZwSetValueKey') and
  thread.callstack.symbols not imatches ('KernelBase.dll!RegSetValue*', 'KernelBase.dll!RegLoadAppKey*', 'KernelBase.dll!GetFileAttributes*') and
  ps.exe not imatches
            (
              '?:\\Program Files (x86)\\Microsoft\\EdgeUpdate\\MicrosoftEdgeUpdate.exe',
              '?:\\Program Files\\Microsoft\\EdgeUpdate\\MicrosoftEdgeUpdate.exe',
              '?:\\Windows\\System32\\sppsvc.exe',
              '?:\\Windows\\System32\\compattelrunner.exe',
              '?:\\Windows\\explorer.exe',
              '?:\\Windows\\System32\\lsass.exe',
              '?:\\Windows\\System32\\svchost.exe'
            ) and
  ps.parent.exe not imatches
            (
              '?:\\WINDOWS\\uus\\*\\wuaucltcore.exe',
              '?:\\WINDOWS\\System32\\svchost.exe'
            )

output: >
  Hidden registry key %registry.path created by process %ps.exe
severity: high

min-engine-version: 3.0.0

```

`rules/defense_evasion_image_load_via_ntfs_transaction.yml`:

```yml
name: Image load via NTFS transaction
id: ce8de3d0-0768-41a7-bab9-4eca27ed1e3c
version: 1.0.2
description: |
  Identifies image loading of a file written to disk via NTFS transaction. Adversaries may exploit 
  the transactional API to execute code in the address space of the running process without committing 
  the code to disk.
labels:
  tactic.id: TA0005
  tactic.name: Defense Evasion
  tactic.ref: https://attack.mitre.org/tactics/TA0005/
  technique.id: T1055
  technique.name: Process Injection
  technique.ref: https://attack.mitre.org/techniques/T1055/
references:
  - https://learn.microsoft.com/en-us/windows/win32/fileio/about-transactional-ntfs

condition: >
  sequence
  maxspan 2m
    |create_file and thread.callstack.symbols imatches ('kernel32.dll!CreateFileTransacted*', 'ntdll.dll!RtlSetCurrentTransaction')| by file.name
    |load_module and evt.pid != 4| by module.name

output: >
  Image %2.module.name written via transactional NTFS and loaded afterward
severity: high

min-engine-version: 3.0.0

```

`rules/defense_evasion_potential_injection_via_dotnet_debugging.yml`:

```yml
name: Potential injection via .NET debugging
id: 193ebf2f-e365-4f57-a639-275b7cdf0319
version: 1.0.6
description: |
  Identifies creation of a process on behalf of the CLR debugging facility which may
  be indicative of code injection. The CLR interface utilizes the OpenVirtualProcess
  method to attach the debugger to the remote process.
labels:
  tactic.id: TA0005
  tactic.name: Defense Evasion
  tactic.ref: https://attack.mitre.org/tactics/TA0005/
  technique.id: T1055
  technique.name: Process Injection
  technique.ref: https://attack.mitre.org/techniques/T1055/
references:
  - https://blog.xpnsec.com/debugging-into-net/
  - https://learn.microsoft.com/en-us/dotnet/framework/unmanaged-api/debugging/iclrdebugging-openvirtualprocess-method

condition: >
  spawn_process and
  ps.parent.exe != '' and thread.callstack.symbols imatches ('mscordbi.dll!OpenVirtualProcess') and
  ps.exe not imatches
            (
              '?:\\Visual Studio\\Common?\\IDE\\devenv.exe',
              '?:\\Program Files\\Microsoft Visual Studio\\*.exe',
              '?:\\Program Files (x86)\\Microsoft Visual Studio\\*.exe',
              '?:\\Program Files\\IIS Express\\iisexpress.exe',
              '?:\\Program Files (x86)\\IIS Express\\iisexpress.exe'
            ) and 
  ps.parent.exe not imatches '?:\\Program Files (x86)\\Microsoft Visual Studio\\*.exe'

output: >
  Process %ps.parent.exe attached the .NET debugger to process %ps.exe for potential code injection
severity: high

min-engine-version: 3.0.0

```

`rules/defense_evasion_potential_process_creation_via_shellcode.yml`:

```yml
name: Potential process creation via shellcode
id: 7a918532-12d1-4aa2-8c46-8769c67cac07
version: 1.0.3
description: |
  Identifies the creation of a process with stack frames originating from floating memory area while 
  invoking commonly used Windows API functions like WinExec. This behavior is a typical indicator of 
  code injection employing offensive shellcode maneuvering.
labels:
  tactic.id: TA0005
  tactic.name: Defense Evasion
  tactic.ref: https://attack.mitre.org/tactics/TA0005/
  technique.id: T1055
  technique.name: Process Injection
  technique.ref: https://attack.mitre.org/techniques/T1055/
references:
  - https://learn.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-winexec

condition: >
  spawn_process and
  thread.callstack.is_unbacked = true and thread.callstack.summary imatches '*kernel32.dll|unbacked*' and
  thread.callstack.symbols imatches ('kernel32.dll!WinExec*')

output: >
  Process %ps.exe created via potential shellcode injection by process %ps.parent.exe
severity: high

min-engine-version: 3.0.0

```

`rules/defense_evasion_potential_process_injection_via_tainted_memory_section.yml`:

```yml
name: Potential process injection via tainted memory section
id: 8e4182f3-02e7-4e95-afc3-93d18c9a9c09
version: 1.0.5
description: |
  Identifies potential process injection when the adversary creates and maps a memory
  section with RW protection rights followed by mapping of the same memory section in
  the remote process with RX protection.
  By definition, the mapped view in the target process mirrors the content of the local
  process address space. The attacker can poison the local section memory with shellcode
  and execute it in the context of the remote process.
labels:
  tactic.id: TA0005
  tactic.name: Defense Evasion
  tactic.ref: https://attack.mitre.org/tactics/TA0005/
  technique.id: T1055
  technique.name: Process Injection
  technique.ref: https://attack.mitre.org/techniques/T1055/
references:
  - https://www.elastic.co/security-labs/dissecting-remcos-rat-part-four
  - https://www.ired.team/offensive-security/code-injection-process-injection/ntcreatesection-+-ntmapviewofsection-code-injection

condition: >
  sequence
  maxspan 1m
    |map_view_of_section and
     file.view.protection = 'READWRITE' and evt.pid != 4 and file.view.size >= 4096 and
     ps.exe not imatches
                (
                  '?:\\Program Files\\*.exe',
                  '?:\\Program Files (x86)\\*.exe',
                  '?:\\ProgramData\\Microsoft\\Windows Defender\\*\\MsMpEng.exe',
                  '?:\\ProgramData\\Microsoft\\Windows Defender\\*\\NisSrv.exe',
                  '?:\\ProgramData\\Microsoft\\Windows Defender\\*\\MpDefenderCoreService.exe',
                  '?:\\WINDOWS\\System32\\csrss.exe',
                  '?:\\WINDOWS\\Explorer.exe',
                  '?:\\WINDOWS\\System32\\svchost.exe',
                  '?:\\WINDOWS\\System32\\lsass.exe',
                  '?:\\WINDOWS\\System32\\SecurityHealthService.exe',
                  '?:\\WINDOWS\\System32\\services.exe'
                )
    | as e1
    |map_view_of_section and
     file.view.protection = 'READONLY|EXECUTE' and file.key = $e1.file.key and evt.pid != $e1.evt.pid and
     ps.exe not imatches
                (
                  '?:\\Program Files\\Mozilla Firefox\\firefox.exe',
                  '?:\\Program Files (x86)\\Mozilla Firefox\\firefox.exe'
                )
    |
action:
  - name: kill

min-engine-version: 3.0.0

```

`rules/defense_evasion_potential_shellcode_execution_via_etw_logger_thread.yml`:

```yml
name: Potential shellcode execution via ETW logger thread
id: 3e915273-5ea0-4576-afc9-b018e2d53545
version: 1.0.2
description: |
  Adversaries may employ the undocumented EtwpCreateEtwThread function to execute shellcode 
  within the local process address space.
labels:
  tactic.id: TA0005
  tactic.name: Defense Evasion
  tactic.ref: https://attack.mitre.org/tactics/TA0005/
  technique.id: T1055
  technique.name: Process Injection
  technique.ref: https://attack.mitre.org/techniques/T1055/
references:
  - https://www.geoffchappell.com/studies/windows/win32/ntdll/api/etw/index.htm
  - https://github.com/Ne0nd0g/go-shellcode/tree/master?tab=readme-ov-file#EtwpCreateEtwThread

condition: >
  create_thread and
  evt.pid != 4 and thread.callstack.symbols iin ('ntdll.dll!EtwpCreateEtwThread') and
  not (ps.exe imatches
              (
                '?:\\WINDOWS\\System32\\ProvTool.exe',
                '?:\\Windows\\System32\\LogonUI.exe'
              ) or
       thread.callstack.symbols imatches ('ntdll.dll!EtwProcessPrivateLoggerRequest', 'sechost.dll!ControlTrace*'))

output: >
  Potential shellcode execution via EtwpCreateEtwThread API initiated by process %ps.exe
severity: high

min-engine-version: 3.0.0

```

`rules/defense_evasion_potential_shellcode_injection_via_windows_debugging_api.yml`:

```yml
name: Potential shellcode injection via Windows Debugging API
id: 0100c5ce-3cdf-4701-8253-6c33bb48eabf
version: 1.0.0
description: |
  Identifies shellcode injection using the Windows Debugging API and shared memory section.
  Attackers avoid writing and reading remote memory directly, instead employ context manipulation
  to force the target process to load and execute the payload itself via shared file mapping.
labels:
  tactic.id: TA0005
  tactic.name: Defense Evasion
  tactic.ref: https://attack.mitre.org/tactics/TA0005/
  technique.id: T1055
  technique.name: Process Injection
  technique.ref: https://attack.mitre.org/techniques/T1055/
references:
  - https://github.com/dis0rder0x00/DbgNexum

condition: >
  sequence
  maxspan 1m
    |create_remote_thread and
     thread.callstack.symbols imatches ('ntdll.dll!DbgUiDebugActiveProcess', 'ntdll.dll!DbgUiIssueRemoteBreakin', 'KernelBase.dll!DebugActiveProcess') and
     ps.exe not imatches
                (
                  '?:\\Program Files\\*.exe',
                  '?:\\Program Files(x86)\\*.exe',
                  '?:\\Windows\\System32\\wermgr.exe',
                  '?:\\Windows\\System32\\WerFault.exe'
                )
    | by thread.pid
    |map_view_of_section and
     file.view.protection = 'READONLY|EXECUTE' and file.view.size >= 4096
    | by ps.pid
action:
  - name: kill

severity: high

min-engine-version: 3.0.0

```

`rules/defense_evasion_potential_thread_execution_hijacking.yml`:

```yml
name: Potential thread execution hijacking
id: 8b9f6d47-e9ba-4b3a-9da2-d7bf27e08ca9
version: 1.0.3
description: |
  Adversaries may inject malicious code into hijacked processes in order to evade process-based
  defenses as well as possibly elevate privileges. Thread Execution Hijacking is a method of
  executing arbitrary code in the address space of a separate live process.

  This is very similar to Process Hollowing but targets an existing process rather than creating
  a process in a suspended state.

  Running code in the context of another process may allow access to the process's memory,
  system/network resources, and possibly elevated privileges. Execution via Thread Execution
  Hijacking may also evade detection from security products since the execution is masked under
  a legitimate process.
labels:
  tactic.id: TA0005
  tactic.name: Defense Evasion
  tactic.ref: https://attack.mitre.org/tactics/TA0005/
  technique.id: T1055
  technique.name: Process Injection
  technique.ref: https://attack.mitre.org/techniques/T1055/
  subtechnique.id: T1055.003
  subtechnique.name: Thread Execution Hijacking
  subtechnique.ref: https://attack.mitre.org/techniques/T1055/003/
references:
  - https://www.ired.team/offensive-security/code-injection-process-injection/injecting-to-remote-process-via-thread-hijacking

condition: >
  sequence
  maxspan 2m
  by ps.uuid
    |open_remote_thread and
     thread.access.mask.names in ('ALL_ACCESS', 'SUSPEND_THREAD') and
     ps.exe not imatches
                (
                  '?:\\Program Files\\*',
                  '?:\\Program Files (x86)\\*'
                )
    |
    |set_thread_context|
action:
  - name: kill

min-engine-version: 3.0.0

```

`rules/defense_evasion_process_creation_via_direct_syscall.yml`:

```yml
name: Process creation via direct syscall
id: 79627d37-0796-4fe9-afc2-06b9b41563e3
version: 1.0.0
description: |
  Identifies process creation initiated via direct system call, a technique
  commonly used by malware to bypass user-mode API hooks and evade security
  monitoring.
labels:
  tactic.id: TA0005
  tactic.name: Defense Evasion
  tactic.ref: https://attack.mitre.org/tactics/TA0005/
  technique.id: T1055
  technique.name: Process Injection
  technique.ref: https://attack.mitre.org/techniques/T1055/
references:
  - https://github.com/jthuraisamy/SysWhispers
  - https://github.com/klezVirus/SysWhispers3

condition: >
  spawn_process and
  direct_syscall and
  (thread.callstack.summary not imatches 'unbacked|embeddedbrowserwebview.dll|unbacked' and
   thread.callstack.modules not imatches ('?:\\Program Files*\\Microsoft\\EdgeWebView\\*\\EmbeddedBrowserWebView.dll')))
action:
  - name: kill

severity: high

min-engine-version: 3.0.0

```

`rules/defense_evasion_process_creation_via_ntfs_transaction.yml`:

```yml
name: Process creation via NTFS transaction
id: eb34cf6e-ccc3-4bce-bbcf-013720640a28
version: 2.0.0
description: |
  Adversaries may inject malicious code into process by abusing NTFS transactions
  to avoid writing the final executable image to disk. Attackers exploit TxF API
  and low-level process creation internals to evade traditional file-based detection.
labels:
  tactic.id: TA0005
  tactic.name: Defense Evasion
  tactic.ref: https://attack.mitre.org/tactics/TA0005/
  technique.id: T1055
  technique.name: Process Injection
  technique.ref: https://attack.mitre.org/techniques/T1055/
  subtechnique.id: T1055.013
  subtechnique.name: Process Doppelganging
  subtechnique.ref: https://attack.mitre.org/techniques/T1055/013/
references:
  - https://www.ired.team/offensive-security/code-injection-process-injection/process-doppelganging
  - https://www.malwarebytes.com/blog/news/2018/08/process-doppelganging-meets-process-hollowing_osiris

condition: >
  sequence
  maxspan 2m
    |create_file and
     evt.pid != 4 and thread.callstack.symbols imatches
                    (
                      'kernel32.dll!CreateFileTransacted*',
                      'ntdll.dll!RtlSetCurrentTransaction'
                    )
    | by file.name
    |spawn_process and
     ps.name != base(ps.exe) and
     thread.callstack.symbols not imatches ('ntdll.dll!*CreateUserProcess')
    | by ps.name
action:
  - name: kill

min-engine-version: 3.0.0

```

`rules/defense_evasion_process_execution_from_hollowed_memory_section.yml`:

```yml
name: Process execution from hollowed memory section
id: 2a3fbae8-5e8c-4b71-b9da-56c3958c0d53
version: 2.1.1
description: |
  Adversaries may inject malicious code into suspended and hollowed processes in order to
  evade process-based defenses. Process hollowing is a method of executing arbitrary code
  in the address space of a separate live process.
labels:
  tactic.id: TA0005
  tactic.name: Defense Evasion
  tactic.ref: https://attack.mitre.org/tactics/TA0005/
  technique.id: T1055
  technique.name: Process Injection
  technique.ref: https://attack.mitre.org/techniques/T1055/
  subtechnique.id: T1055.012
  subtechnique.name: Process Hollowing
  subtechnique.ref: https://attack.mitre.org/techniques/T1055/012/
references:
  - https://www.ired.team/offensive-security/code-injection-process-injection/process-hollowing-and-pe-image-relocations

condition: >
  sequence
  maxspan 40s
    |unmap_view_of_section and
     evt.pid != 4 and ps.sid not in ('S-1-5-18', 'S-1-5-19', 'S-1-5-20') and
     file.view.size > 20000 and file.view.protection != 'READONLY' and
     (file.name = '' or file.extension != '.dll') and
     ps.parent.exe not imatches
                    (
                      '?:\\Windows\\System32\\dwm.exe',
                      '?:\\Windows\\System32\\svchost.exe',
                      '?:\\Windows\\System32\\services.exe',
                      '?:\\Windows\\Microsoft.NET\\Framework*\\ngen.exe',
                      '?:\\Windows\\Microsoft.NET\\Framework*\\mscorsvw.exe'
                    )
    | by ps.uuid, file.view.base
    |load_executable and
     module.path not imatches '?:\\Windows\\SoftwareDistribution\\Download\\*\\Package_for_RollupFix*\\*.exe'
    | by ps.uuid, module.base
action:
  - name: kill

output: >
  Process %2.ps.exe executed from hollowed memory section
severity: high

min-engine-version: 3.0.0

```

`rules/defense_evasion_process_execution_from_self_deleting_binary.yml`:

```yml
name: Process execution from a self-deleting binary
id: 0f0da517-b22c-4d14-9adc-36baeb621cf7
version: 1.0.5
description: |
  Identifies the execution of the process from a self-deleting binary. The attackers can
  abuse undocumented API functions to create a process from a file-backed section. The file 
  is put into a delete-pending state allowing the attacker to bypass kernel callback controls
  by closing the handle to the file before the main thread is spawned.
labels:
  tactic.id: TA0005
  tactic.name: Defense Evasion
  tactic.ref: https://attack.mitre.org/tactics/TA0005/
  technique.id: T1055
  technique.name: Process Injection
  technique.ref: https://attack.mitre.org/techniques/T1055/
references:
  - https://github.com/hasherezade/process_ghosting
  - https://www.elastic.co/es/blog/process-ghosting-a-new-executable-image-tampering-attack

condition: >
  sequence
  maxspan 1m 
    |delete_file and
     file.info.is_disposition_delete_file and
     ps.exe not imatches
                (
                  '?:\\$WINDOWS.~BT\\Sources\\SetupHost.exe',
                  '?:\\WINDOWS\\uus\\packages\\preview\\*\\wuaucltcore.exe',
                  '?:\\WINDOWS\\uus\\packages\\preview\\*\\MoUsoCoreWorker.exe',
                  '?:\\WINDOWS\\System32\\svchost.exe',
                  '?:\\WINDOWS\\winsxs\\*\\TiWorker.exe'
                ) and
     file.path not imatches
                (
                  '?:\\Windows\\SoftwareDistribution\\Download\\*',
                  '?:\\Windows\\uus\\packages\\preview\\*'
                )
    | by file.name
    |load_module and ext(module.path) != '.dll'| by module.name

output: >
  Process %2.module.path spawned from self-deleting binary
severity: high

min-engine-version: 3.0.0

```

`rules/defense_evasion_process_spawned_via_remote_thread.yml`:

```yml
name: Process spawned via remote thread
id: 9a2c7b40-4e5f-4edf-b02e-79cd33c9a137
version: 1.0.4
description: |
  Identifies the creation of a process with the parent call stack not
  revealing normal API functions for process creation. This may be a
  sign of process injection.
labels:
  tactic.id: TA0005
  tactic.name: Defense Evasion
  tactic.ref: https://attack.mitre.org/tactics/TA0005/
  technique.id: T1055
  technique.name: Process Injection
  technique.ref: https://attack.mitre.org/techniques/T1055/

condition: >
  spawn_process and
  thread.callstack.symbols imatches ('ntdll.dll!ZwCreateThreadEx*', 'ntdll.dll!NtCreateThreadEx*', 'ntdll.dll!RtlCreateUserThread') and
  thread.callstack.symbols not imatches ('*CreateProcess*', '*CreateUserProcess*')
action:
  - name: kill

min-engine-version: 3.0.0

```

`rules/defense_evasion_regsvr32_scriptlet_execution.yml`:

```yml
name: Regsvr32 scriptlet execution
id: 128f5254-67c9-43ac-b901-18b3731b1d0b
version: 1.0.5
description: |
  Identifies the execution of a scriptlet file by regsvr32.exe process. regsvr32.exe
  allows attackers to run arbitrary scripts to proxy execution of malicious code.
labels:
  tactic.id: TA0005
  tactic.name: Defense Evasion
  tactic.ref: https://attack.mitre.org/tactics/TA0005/
  technique.id: T1218
  technique.name: System Binary Proxy Execution
  technique.ref: https://attack.mitre.org/techniques/T1218/
  subtechnique.id: T1218.010
  subtechnique.name: Regsvr32
  subtechnique.ref: https://attack.mitre.org/techniques/T1218/010/

condition: >
  spawn_process and
  (ps.name ~= 'regsvr32.exe' or ps.pe.file.name ~= 'regsvr32.exe') and
    (
      (ps.cmdline imatches '*scrobj*' and
       ps.cmdline imatches
                  (
                    '*/i:*',
                    '*-i:*',
                    '*.sct*'
                  )
      ) or
      (ps.cmdline imatches '* /u*' and
       ps.cmdline imatches
                  (
                    '* -i:*http*',
                    '* /i:*http*',
                    '* -i:*ftp*',
                    '* /i:*ftp*',
                    '* -i:C:\\*',
                    '* /i:\"C:\\*',
                    '* /i:C:\\*',
                    '* -i:\"C:\\*'
                  )
      ) or
      (ps.cmdline imatches
                  (
                    '* /i:*',
                    '* -i:*'
                  ) and
      ps.cmdline not imatches
                  (
                    '* /n*',
                    '* -n*'
                  )
      )
    ) and
  ps.exe not imatches
                  (
                    '?:\\Program Files\\*.exe',
                    '?:\\Program Files (x86)\\*.exe'
                  )

min-engine-version: 3.0.0

```

`rules/defense_evasion_suspicious_access_to_the_hosts_file.yml`:

```yml
name: Suspicious access to the hosts file
id: f7b2c9d3-99e7-41d5-bb4a-6ea1a5f7f9e2
version: 1.0.6
description: >
  Identifies suspicious process accessing the Windows hosts file for potential tampering.
  Adversaries can hijack the hosts files to block traffic to download/update servers or redirect the
  traffic to arbitrary servers under their control.
labels:
  tactic.id: TA0005
  tactic.name: Defense Evasion
  tactic.ref: https://attack.mitre.org/tactics/TA0005/
  technique.id: T1562.001
  technique.name: Impair Defenses - Disable or Modify Tools
  technique.ref: https://attack.mitre.org/techniques/T1562/001/
references:
  - https://www.malwarebytes.com/blog/news/2016/09/hosts-file-hijacks

condition: >
  sequence
  maxspan 5m
  by ps.uuid
    |spawn_process and ps.exe not imatches
                                        (
                                          '?:\\Windows\\servicing\\TrustedInstaller.exe',
                                          '?:\\Windows\\System32\\svchost.exe',
                                          '?:\\Windows\\System32\\MicrosoftEdgeUpdate.exe',
                                          '?:\\Program Files (x86)\\Microsoft\\Edge\\Application\\msedge.exe',
                                          '?:\\Program Files\\Mozilla Firefox\\firefox.exe',
                                          '?:\\Program Files (x86)\\Mozilla Firefox\\firefox.exe'
                                        )
    |
    |open_file and file.path imatches '?:\\Windows\\System32\\drivers\\etc\\hosts'|
action:
  - name: kill

output: >
  Suspicious process %1.ps.exe accessed the hosts file for potential tampering
severity: medium

min-engine-version: 3.0.0

```

`rules/defense_evasion_suspicious_dll_loaded_via_memory_section_mapping.yml`:

```yml
name: Suspicious DLL loaded via memory section mapping
id: b06653fb-227e-4e63-9a69-55a5a90c79e5
version: 1.0.3
description: |
  Identifies the mapping of a memory section with RX protection followed by unsigned DLL loading.
  Adversaries may inject dynamic-link libraries (DLLs) into processes in order to evade process-based defenses
  as well as possibly elevate privileges. DLL injection is a method of executing arbitrary code in the address
  space of a separate live process.
labels:
  tactic.id: TA0005
  tactic.name: Defense Evasion
  tactic.ref: https://attack.mitre.org/tactics/TA0005/
  technique.id: T1055
  technique.name: Process Injection
  technique.ref: https://attack.mitre.org/techniques/T1055/
  subtechnique.id: T1055.001
  subtechnique.name: Dynamic-link Library Injection
  subtechnique.ref: https://attack.mitre.org/techniques/T1055/001/

condition: >
  sequence
  maxspan 2m
  by ps.uuid
    |map_view_of_section and
     file.view.protection = 'READONLY|EXECUTE' and evt.pid != 4 and file.view.size >= 4096 and
     ps.exe not imatches
                (
                  '?:\\Program Files\\Mozilla Firefox\\firefox.exe'
                )
    |
    |(load_unsigned_or_untrusted_dll)|
action:
  - name: kill

min-engine-version: 3.0.0

```

`rules/defense_evasion_suspicious_html_application_script_execution.yml`:

```yml
name: Suspicious HTML Application script execution
id: 4ec64ac2-851d-41b4-b7d2-910c21de334d
version: 1.0.7
description: |
  Identifies the execution of scripts via Microsoft HTML Application Host interpreter. Adversaries 
  can proxy the execution of arbitrary script code through a trusted, signed utility to evade defenses.
labels:
  tactic.id: TA0005
  tactic.name: Defense Evasion
  tactic.ref: https://attack.mitre.org/tactics/TA0005/
  technique.id: T1218
  technique.name: System Binary Proxy Execution
  technique.ref: https://attack.mitre.org/techniques/T1218/
  subtechnique.id: T1218.005
  subtechnique.name: Mshta
  subtechnique.ref: https://attack.mitre.org/techniques/T1218/005/
references:
  - https://redcanary.com/threat-detection-report/techniques/mshta/
  - https://www.ired.team/offensive-security/code-execution/t1170-mshta-code-execution

condition: >
  spawn_process and
  (ps.name ~= 'mshta.exe' or ps.pe.file.name ~= 'mshta.exe') and
  ps.cmdline imatches
            (
              '*WScript.Shell*',
              '*mshtml*RunHTMLApplication*',
              '*http*',
              '*https*',
              '*hXXps',
              '*ftp*',
              '*.run*',
              '*window.close*',
              '*mshta*',
              '*mshtml*',
              '*).Exec()*',
              '*script*eval(*',
              '*script*GetObject*',
              '*vbscript*',
              '*\\Users\\*\\Downloads\\*.hta*',
              '*.rtf*',
              '*.bat*',
              '*.dll*',
              '*.zip*',
              '*.jpg*',
              '*.png*',
              '*.lnk*',
              '*.doc*',
              '*.xls*'
            ) and
  ps.parent.exe not imatches '?:\\Program Files (x86)\\Microsoft Office\\Office*\\MSACCESS.EXE'

action:
  - name: kill

output: >
  Suspicious HTML Application script execution by mshta process with command line arguments %ps.cmdline
severity: high

min-engine-version: 3.0.0

```

`rules/defense_evasion_suspicious_object_symbolic_link_creation.yml`:

```yml
name: Suspicious object symbolic link creation
id: f9306355-1f5f-4a06-9779-195aa681db80
version: 1.0.5
description: |
  Identifies the creation of the object symbolic link inside the object manager namespace
  by untrusted or unusual processes.
  Adversaries may exploit object symbolic links to trick system processes into executing
  malicious payloads.
labels:
  tactic.id: TA0005
  tactic.name: Defense Evasion
  tactic.ref: https://attack.mitre.org/tactics/TA0005/
  technique.id: T1211
  technique.name: Exploitation for Defense Evasion
  technique.ref: https://attack.mitre.org/techniques/T1211/
references:
  - https://www.cyberark.com/resources/threat-research-blog/follow-the-link-exploiting-symbolic-links-with-ease
  - https://www.elastic.co/kr/blog/detect-block-unknown-knowndlls-windows-acl-hardening-attacks-cache-poisoning-escalation

condition: >
  create_symbolic_link_object and evt.pid != 4 and
  (ps.signature.exists = false or ps.signature.trusted = false or
   ps.exe not imatches
              (
                '?:\\ProgramData\\Microsoft\\Windows Defender\\*\\MsMpEng.exe',
                '?:\\WINDOWS\\system32\\svchost.exe',
                '?:\\Program Files\\*',
                '?:\\Program Files (x86)\\*',
                '?:\\Windows\\System32\\vmwp.exe',
                '?:\\Windows\\System32\\spoolsv.exe',
                '?:\\Windows\\System32\\csrss.exe'
              )
  ) and
  evt.arg[target] not imatches '\\Sessions\\*\\AppContainerNamedObjects\\*'

output: >
  Suspicious object symbolic link %evt.arg[target] created by process %ps.exe
severity: high

min-engine-version: 3.0.0

```

`rules/defense_evasion_suspicious_protected_process_execution.yml`:

```yml
name: Suspicious protected process execution
id: a778295a-02f1-42d9-9c20-78346a7bc2c6
version: 1.0.0
description: |
  Identifies unprivileged process spawning a child with protected integrity level. This 
  indicates an unusual behavior that is often associated with attempts to tamper with or 
  freeze endpoint protection components.
labels:
  tactic.id: TA0005
  tactic.name: Defense Evasion
  tactic.ref: https://attack.mitre.org/tactics/TA0005/
  technique.id: T1562
  technique.name: Impair Defenses
  technique.ref: https://attack.mitre.org/techniques/T1562/
  subtechnique.id: T1562.001
  subtechnique.name: Disable or Modify Tools
  subtechnique.ref: https://attack.mitre.org/techniques/T1562/001
references:
  - https://github.com/TwoSevenOneT/EDR-Freeze

condition: >
  sequence
  maxspan 1m30s
    |spawn_process and
     ps.token.integrity_level != 'SYSTEM' and
     ps.exe not imatches
                (
                  '?:\\Program Files\\*',
                  '?:\\Program Files(x86)\\*'
                )
    | by ps.uuid
    |spawn_process and ps.is_protected| by ps.parent.uuid
action:
  - name: kill

output: >
  Suspicious protected process %2.ps.exe spawned by process %2.ps.parent.exe
severity: high

min-engine-version: 3.0.0

```

`rules/defense_evasion_suspicious_windows_defender_exclusions_registry_modification.yml`:

```yml
name: Suspicious Windows Defender exclusions registry modification
id: 92fdbbea-e177-494e-8a6a-d8b055daf0e9
version: 1.0.3
description: |
  Identifies the modification of the Windows Defender process, path, or IP address registry key exclusions 
  by suspicious processes. Adversaries may alter the Windows Defender exclusions to bypass defenses.
labels:
  tactic.id: TA0005
  tactic.name: Defense Evasion
  tactic.ref: https://attack.mitre.org/tactics/TA0005/
  technique.id: T1562
  technique.name: Impair Defenses
  technique.ref: https://attack.mitre.org/techniques/T1562/
  subtechnique.id: T1562.001
  subtechnique.name: Disable or Modify Tools
  subtechnique.ref: https://attack.mitre.org/techniques/T1562/001

condition: >
  set_value and
  registry.path imatches 'HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows Defender\\Exclusions\\*' and
  (
    ps.exe imatches
          (
            '?:\\Users\\*\\AppData\\*',
            '?:\\Users\\Public\\*',
            '?:\\Windows\\Microsoft.NET\\*',
            '?:\\ProgramData\\*'
          ) or
    ps.name iin ('pwsh.exe', 'rundll32.exe', 'regsvr32.exe', 'cscript.exe', 'reg.exe', 'wscript.exe', 'mshta.exe', 'msbuild.exe', 'powershell.exe', 'cmd.exe') or
    ps.signature.exists = false or ps.signature.trusted = false
  ) and
  ps.exe not imatches
          (
            '?:\\ProgramData\\Microsoft\\Windows Defender\\Platform\\*\\ConfigSecurityPolicy.exe',
            '?:\\ProgramData\\Microsoft\\Windows Defender\\Platform\\*\\MsMpEng.exe',
            '?:\\ProgramData\\Microsoft\\Windows Defender\\*\\NisSrv.exe'
          )
action:
  - name: kill

output: >
  Windows Defender exclusion %registry.path added by suspicious process %ps.exe
severity: high

min-engine-version: 3.0.0

```

`rules/defense_evasion_suspicious_xsl_script_execution.yml`:

```yml
name: Suspicious XSL script execution
id: 65136b30-14ae-46dd-b8e5-9dfa99690d74
version: 1.0.7
description: |
  Identifies a suspicious execution of XSL script via Windows Management Instrumentation command line tool or XSL
  transformation utility. Adversaries may bypass application control and obscure the execution of code by embedding 
  scripts inside XSL files. Extensible Stylesheet Language (XSL) files are commonly used to describe the processing 
  and rendering of data within XML files.
labels:
  tactic.id: TA0005
  tactic.name: Defense Evasion
  tactic.ref: https://attack.mitre.org/tactics/TA0005/
  technique.id: T1220
  technique.name: XSL Script Processing
  technique.ref: https://attack.mitre.org/techniques/T1220/
references:
  - https://www.ired.team/offensive-security/code-execution/application-whitelisting-bypass-with-wmic-and-xsl

condition: >
  sequence
  maxspan 3m
  by ps.uuid
    |spawn_process and
     (((ps.name ~= 'wmic.exe' or ps.pe.file.name ~= 'wmic.exe') and
     ps.cmdline imatches ('* format*:*', '*/format*:*', '*-format*:*') and
     ps.cmdline not imatches
                    (
                      '*format:list*',
                      '*format:htable*',
                      '*format:hform*',
                      '*format:table*',
                      '*format:mof*',
                      '*format:value*',
                      '*format:rawxml*',
                      '*format:xml*',
                      '*format:csv*'
                    )
      ) or
      ps.name ~= 'msxsl.exe' or ps.pe.file.name ~= 'msxsl.exe'
     )
    |
    |load_dll and dll.name iin ('scrobj.dll', 'vbscript.dll', 'jscript.dll', 'jscript9.dll')|

output: >
  Suspicious XSL script executed by process %1.ps.name with command line arguments %1.ps.args
severity: high

min-engine-version: 3.0.0

```

`rules/defense_evasion_system_binary_proxy_execution_via_rundll32.yml`:

```yml
name: System Binary Proxy Execution via Rundll32
id: 43d76718-cc46-485e-8f47-996eb7a9f83b
version: 1.0.5
description: |
  Detects the execution of rundll32.exe process with suspicious command line
  followed by the creation of a possibly malicious child process.
  Adversaries may abuse rundll32.exe to proxy execution of malicious code.
  Using rundll32.exe, vice executing directly may avoid triggering security
  tools that may not monitor execution of the rundll32.exe process because of
  allowlists or false positives from normal operations.
labels:
  tactic.id: TA0005
  tactic.name: Defense Evasion
  tactic.ref: https://attack.mitre.org/tactics/TA0005/
  technique.id: T1218
  technique.name: System Binary Proxy Execution
  technique.ref: https://attack.mitre.org/techniques/T1218/
  subtechnique.id: T1218.011
  subtechnique.name: Rundll32
  subtechnique.ref: https://attack.mitre.org/techniques/T1218/011/
references:
  - https://redcanary.com/threat-detection-report/techniques/rundll32/

condition: >
  sequence
  maxspan 1m
    |spawn_process and
     (ps.name ~= 'rundll32.exe' or ps.pe.file.name ~= 'rundll32.exe') and
      (
        ps.cmdline imatches
                  (
                    '*javascript:*',
                    '*vbscript:*',
                    '*shell32.dll*ShellExec_RunDLL*',
                    '*shell32*WaitForExplorerRestart*',
                    '*-sta*',
                    '*ActiveXObject*',
                    '*WScript.Shell*',
                    '*RunHTMLApplication*',
                    '*advpack*#12*',
                    '*advpack*RegisterOCX*',
                    '*advpack*LaunchINFSection*',
                    '*url.dll*FileProtocolHandler*file://*',
                    '*url.dll*FileProtocolHandler*.exe*',
                    '*zipfldr*RouteTheCall*',
                    '*pcwutl*LaunchApplication*',
                    '*pcwutl*#1*',
                    '*desk*InstallScreenSaver*',
                    '*PointFunctionCall*'
                  ) or
        regex(ps.cmdline, '(?i)[A-Z]:\\\\.+:.+$')
      )
    | by ps.uuid
    |spawn_process and ps.exe not imatches
                  (
                    '?:\\Program Files\\*.exe',
                    '?:\\Program Files (x86)\\*.exe'
                  )
    | by ps.parent.uuid
action:
  - name: kill

min-engine-version: 3.0.0

```

`rules/defense_evasion_thread_context_set_from_unbacked_memory.yml`:

```yml
name: Thread context set from unbacked memory
id: f8219274-ee68-416b-8489-4d2e635c7844
version: 1.0.5
description: |
  Identifies manipulation of the thread context from unbacked memory region. This may be
  indicative of process injection.
labels:
  tactic.id: TA0005
  tactic.name: Defense Evasion
  tactic.ref: https://attack.mitre.org/tactics/TA0005/
  technique.id: T1055
  technique.name: Process Injection
  technique.ref: https://attack.mitre.org/techniques/T1055/

condition: >
  set_thread_context and
  thread.callstack.summary imatches ('ntdll.dll|kernelbase.dll|unbacked') and
  ps.exe not imatches
            (
              '?:\\Program Files\\Git\\mingw64\\bin\\git.exe',
              '?:\\Program Files (x86)\\Microsoft\\Edge\\Application\\msedge.exe',
              '?:\\Program Files\\Microsoft\\Edge\\Application\\msedge.exe',
              '?:\\Windows\\System32\\taskhostw.exe'
            )

min-engine-version: 3.0.0

```

`rules/defense_evasion_unsigned_dll_injection_via_remote_thread.yml`:

```yml
name: Unsigned DLL injection via remote thread
id: 21bdd944-3bda-464b-9a72-58fd37ba9163
version: 1.1.5
description: |
  Identifies unsigned DLL injection via remote thread creation.
  Adversaries may inject dynamic-link libraries (DLLs) into processes in order to evade process-based defenses
  as well as possibly elevate privileges. DLL injection is a method of executing arbitrary code in the address
  space of a separate live process.
labels:
  tactic.id: TA0005
  tactic.name: Defense Evasion
  tactic.ref: https://attack.mitre.org/tactics/TA0005/
  technique.id: T1055
  technique.name: Process Injection
  technique.ref: https://attack.mitre.org/techniques/T1055/
  subtechnique.id: T1055.001
  subtechnique.name: Dynamic-link Library Injection
  subtechnique.ref: https://attack.mitre.org/techniques/T1055/001/
references:
  - https://www.ired.team/offensive-security/code-injection-process-injection/dll-injection

condition: >
  sequence
  maxspan 1m
    |create_remote_thread and
     thread.start_address.symbol imatches ('LoadLibrary*', 'LdrLoadDLL*') and
     not (ps.exe imatches
                (
                  '?:\\Program Files\\*.exe',
                  '?:\\Program Files (x86)\\*.exe'
                ) or
          (ps.exe imatches '?:\\Windows\\System32\\svchost.exe' and ps.args intersects ('-k', 'DcomLaunch')) or
          (ps.cmdline imatches '"?:\\Windows\\Microsoft.NET\\Framework\\*\\ngen.exe" ExecuteQueuedItems /LegacyServiceBehavior'))
    | by thread.pid
    |(load_unsigned_or_untrusted_dll) and
     dll.path not imatches
                    (
                      '?:\\Program Files\\Git\\mingw64\\bin\\*.dll',
                      '?:\\Windows\\assembly\\*\\*.ni.dll',
                      '?:\\Program Files\\WindowsPowerShell\\Modules\\*\\*.dll',
                      '?:\\Windows\\Microsoft.NET\\assembly\\*\\*.dll'
                    ) and
     ps.exe not imatches '?:\\Program Files\\Common Files\\microsoft shared\\ClickToRun\\Updates\\*\\OfficeClickToRun.exe'
    | by ps.pid

min-engine-version: 3.0.0

```

`rules/defense_evasion_windows_defender_driver_unloading.yml`:

```yml
name: Windows Defender driver unloading
id: c9b93fbc-8845-4f39-a74b-26862615432c
version: 1.0.1
description: |
  Detects the unloading of Windows Defender kernel-mode drivers, such as WdFilter.sys or WdBoot.sys,
  which may indicate an attempt to impair or disable antivirus protections. 
  Adversaries may unload these drivers to bypass or disable real-time scanning, file system filtering, 
  or ELAM (Early Launch Anti-Malware) protections. Legitimate driver unloads are rare and should be 
  investigated to rule out malicious tampering or post-exploitation activity.
labels:
  tactic.id: TA0005
  tactic.name: Defense Evasion
  tactic.ref: https://attack.mitre.org/tactics/TA0005/
  technique.id: T1562
  technique.name: Impair Defenses
  technique.ref: https://attack.mitre.org/techniques/T1562/
  subtechnique.id: T1562.001
  subtechnique.name: Disable or Modify Tools
  subtechnique.ref: https://attack.mitre.org/techniques/T1562/001

condition: >
  unload_driver and module.path imatches ('?:\\Windows\\System32\\drivers\\wd\\*.sys', '?:\\Windows\\System32\\drivers\\Wd*.sys')

output: >
  Windows Defender driver %module.path unloaded by process %ps.exe
severity: high

min-engine-version: 3.0.0

```

`rules/defense_evasion_windows_defender_protection_tampering_via_registry.yml`:

```yml
name: Windows Defender protection tampering via registry
id: 47ad962b-be0f-44f8-9467-34109f41e5ff
version: 1.0.2
description: |
  Detects suspicious processes modifying Windows Defender configuration settings via registry 
  to disable protection features.
labels:
  tactic.id: TA0005
  tactic.name: Defense Evasion
  tactic.ref: https://attack.mitre.org/tactics/TA0005/
  technique.id: T1562
  technique.name: Impair Defenses
  technique.ref: https://attack.mitre.org/techniques/T1562/
  subtechnique.id: T1562.001
  subtechnique.name: Disable or Modify Tools
  subtechnique.ref: https://attack.mitre.org/techniques/T1562/001
references:
  - https://symantec-enterprise-blogs.security.com/blogs/threat-intelligence/ransomware-hive-conti-avoslocker

condition: >
  set_value and
  ((base(registry.path) iin
                        (
                          'DisableAntiSpyware',
                          'DisableAntiVirus',
                          'DisableBehaviorMonitoring',
                          'DisableBlockAtFirstSeen',
                          'DisableEnhancedNotifications',
                          'DisableIntrusionPreventionSystem',
                          'DisableIOAVProtection',
                          'DisableOnAccessProtection',
                          'DisableRealtimeMonitoring',
                          'DisableScanOnRealtimeEnable',
                          'DisableScriptScanning',
                          'DisableArchiveScanning',
                          'DisableRawWriteNotification'
                        ) and registry.data = '1') or
    (registry.path imatches
                        (
                          '*\\Windows Defender\\Spynet\\SpyNetReporting',
                          '*\\Windows Defender\\Spynet\\SubmitSamplesConsent',
                          '*\\DisallowExploitProtectionOverride',
                          '*\\Windows Defender\\Features\\TamperProtection',
                          '*\\Windows Defender\\MpEngine\\MpEnablePus'
                        ) and registry.data = '0'
    )
  ) and
  ps.exe not imatches
            (
              '?:\\Program Files\\Symantec\\Symantec Endpoint Protection\\sepWscSvc64.exe',
              '?:\\ProgramData\\Microsoft\\Windows Defender\\Platform\\*\\ConfigSecurityPolicy.exe',
              '?:\\ProgramData\\Microsoft\\Windows Defender\\Platform\\*\\MsMpEng.exe',
              '?:\\ProgramData\\Microsoft\\Windows Defender\\*\\NisSrv.exe'
            )
action:
  - name: kill

output: >
  Suspicious process %ps.exe tampered Windows Defender security settings in registry value %registry.path
severity: high

min-engine-version: 3.0.0

```

`rules/initial_access_executable_file_creation_from_macro_enabled_microsoft_office_document.yml`:

```yml
name: Executable file creation from a macro-enabled Microsoft Office document
id: fffcce75-2427-406e-9597-1f49b0c9ad5b
version: 1.0.3
description: |
  Identifies the Microsoft Office process writing an executable file type and
  the call stack reveals the file creation was originated from the Microsoft
  Visual Basic for Applications module. This may be an indicator of initial
  access using malicious macro-enabled documents.
labels:
  tactic.id: TA0001
  tactic.name: Initial Access
  tactic.ref: https://attack.mitre.org/tactics/TA0001/
  technique.id: T1566
  technique.name: Phishing
  technique.ref: https://attack.mitre.org/techniques/T1566/
  subtechnique.id: T1566.001
  subtechnique.name: Spearphishing Attachment
  subtechnique.ref: https://attack.mitre.org/techniques/T1566/001/

condition: >
  create_file and
  ps.name in msoffice_binaries and
  thread.callstack.modules imatches 'vbe?.dll' and
  (
    file.extension iin ('.vbs', '.js', '.jar', '.exe', '.dll', '.com',
                        '.ps1', '.hta', '.cmd', '.vbe', '.rar.', '.zip',
                        '.iso', '.img', '.wsh', '.bat', '.cpl', '.7z'
                        ) or
    (file.is_exec or file.is_dll)
  )

min-engine-version: 3.0.0

```

`rules/initial_access_execution_via_microsoft_office_process.yml`:

```yml
name: Execution via Microsoft Office process
id: a10ebe66-1b55-4005-a374-840f1e2933a3
version: 1.0.3
description:
  Identifies the execution of the file dropped by Microsoft Office process.
labels:
  tactic.id: TA0001
  tactic.name: Initial Access
  tactic.ref: https://attack.mitre.org/tactics/TA0001/
  technique.id: T1566
  technique.name: Phishing
  technique.ref: https://attack.mitre.org/techniques/T1566/
  subtechnique.id: T1566.001
  subtechnique.name: Spearphishing Attachment
  subtechnique.ref: https://attack.mitre.org/techniques/T1566/001/

condition: >
  sequence
  maxspan 1h
    |create_file and (file.extension iin executable_extensions or file.is_exec) and ps.name iin msoffice_binaries| by file.path
    |spawn_process and ps.parent.name iin msoffice_binaries| by ps.exe

min-engine-version: 3.0.0

```

`rules/initial_access_macro_execution_via_script_interpreter.yml`:

```yml
name: Macro execution via script interpreter
id: 845404de-df6f-472f-bd74-72148a7f5166
version: 1.0.7
description: |
  Identifies the execution of the Windows scripting interpreter spawning
  a Microsoft Office process to execute suspicious Visual Basic macro.
labels:
  tactic.id: TA0001
  tactic.name: Initial Access
  tactic.ref: https://attack.mitre.org/tactics/TA0001/
  technique.id: T1566
  technique.name: Phishing
  technique.ref: https://attack.mitre.org/techniques/T1566/
  subtechnique.id: T1566.001
  subtechnique.name: Spearphishing Attachment
  subtechnique.ref: https://attack.mitre.org/techniques/T1566/001/

condition: >
  sequence
  maxspan 5m
  by ps.uuid
    |spawn_process and ps.parent.name iin script_interpreters and ps.name iin msoffice_binaries|
    |ps.name iin msoffice_binaries and thread.callstack.modules imatches '*vbe?.dll' and
     (spawn_process or (create_remote_thread) or (modify_registry) or (create_file) or
     (load_module and module.path not imatches ('?:\\Program Files\\*', '?:\\Program Files (x86)\\*')))
    |

min-engine-version: 3.0.0

```

`rules/initial_access_microsoft_office_file_execution_via_script_interpreter.yml`:

```yml
name: Microsoft Office file execution via script interpreter
id: bf3ea547-1470-4bcc-9945-3b495d962c2c
version: 1.0.3
description: |
  Identifies the execution via Windows script interpreter of the executable file written 
  by the Microsoft Office process.
labels:
  tactic.id: TA0001
  tactic.name: Initial Access
  tactic.ref: https://attack.mitre.org/tactics/TA0001/
  technique.id: T1566
  technique.name: Phishing
  technique.ref: https://attack.mitre.org/techniques/T1566/
  subtechnique.id: T1566.001
  subtechnique.name: Spearphishing Attachment
  subtechnique.ref: https://attack.mitre.org/techniques/T1566/001/

condition: >
  sequence
  maxspan 2m
    |create_file and
     ps.name iin msoffice_binaries and (file.extension iin ('.exe', '.com', '.scr', '.pif', '.bat') or file.is_exec = true)
    | by file.path
    |spawn_process and
     ps.parent.name iin script_interpreters and
     ps.exe not imatches
                      (
                        '?:\\Program Files\\*.exe',
                        '?:\\Program Files (x86)\\*.exe'
                      )
    | by ps.exe
action:
  - name: kill

output: >
  Microsoft Office process %1.ps.exe wrote the file %1.file.path and subsequently executed it via script interpreter %2.ps.exe
severity: high

min-engine-version: 3.0.0

```

`rules/initial_access_microsoft_office_file_execution_via_wmi.yml`:

```yml
name: Microsoft Office file execution via WMI
id: 50f6efa2-4d7b-4fb7-b1a9-65c3a24d9152
version: 1.0.4
description: |
  Identifies the execution via Windows Management Instrumentation (WMI) of the binary file written 
  by the Microsoft Office process. Attackers can exploit WMI to silently execute malicious code.
labels:
  tactic.id: TA0001
  tactic.name: Initial Access
  tactic.ref: https://attack.mitre.org/tactics/TA0001/
  technique.id: T1566
  technique.name: Phishing
  technique.ref: https://attack.mitre.org/techniques/T1566/
  subtechnique.id: T1566.001
  subtechnique.name: Spearphishing Attachment
  subtechnique.ref: https://attack.mitre.org/techniques/T1566/001/
references:
  - https://redcanary.com/threat-detection-report/techniques/windows-management-instrumentation/

condition: >
  sequence
  maxspan 2m
    |create_file and
     ps.name iin msoffice_binaries and (file.extension iin ('.exe', '.com') or file.is_exec = true)
    | by file.path
    |spawn_process and ps.parent.name ~= 'wmiprvse.exe'| by ps.exe
action:
  - name: kill

output: >
  Microsoft Office process %1.ps.exe wrote the file %1.file.path and subsequently executed it via WMI
severity: high

min-engine-version: 3.0.0

```

`rules/initial_access_potential_clickfix_infection_chain.yml`:

```yml
name: Potential ClickFix infection chain
id: ffe1fc54-2893-4760-ab50-51a83bd71d13
version: 2.0.1
description: |
  Identifies the execution of the process via the Run command dialog box, Windows Console shortuct, or Explorer address bar
  followed by spawning of the potential infostealer process.
  This could be indicative of the ClickFix deceptive tactic used by attackers to lure victims into executing
  malicious commands under the guise of meeting pages or CAPTCHAs.
labels:
  tactic.id: TA0001
  tactic.name: Initial Access
  tactic.ref: https://attack.mitre.org/tactics/TA0001/
  technique.id: T1566
  technique.name: Phishing
  technique.ref: https://attack.mitre.org/techniques/T1566/
references:
  - https://blog.sekoia.io/clickfix-tactic-the-phantom-meet/
  - https://blog.sekoia.io/clickfix-tactic-revenge-of-detection/
  - https://detect.fyi/hunting-clickfix-initial-access-techniques-8c1b38d5ef9b

condition: >
  sequence
  maxspan 2m
    |spawn_process and
     ps.parent.name ~= 'explorer.exe' and length(ps.args) >= 2 and
     ps.name iin ('cmd.exe', 'powershell.exe', 'pwsh.exe', 'wget.exe', 'curl.exe', 'msiexec.exe', 'mshta.exe', 'wscript.exe', 'cscript.exe', 'msbuild.exe') and
     (thread.callstack.summary imatches
                              (
                                'ntdll.dll|KernelBase.dll|kernel32.dll|windows.storage.dll|shell32.dll|user32.dll|shell32.dll|explorer.exe|SHCore.dll|*',
                                'ntdll.dll|KernelBase.dll|kernel32.dll|windows.storage.dll|shell32.dll|windows.storage.dll|shell32.dll|user32.dll|shell32.dll|explorer.exe|SHCore.dll|*',
                                'ntdll.dll|KernelBase.dll|kernel32.dll|windows.storage.dll|shell32.dll|windows.storage.dll|SHCore.dll|*'
                              ) or
      (thread.callstack.summary imatches '*shell32.dll|explorer.exe|*' and thread.callstack.symbols imatches ('*shell32.dll!GetFileNameFromBrowse*'))
     )
    | by ps.uuid
    |spawn_process and ps.exe not imatches
                              (
                                '?:\\Program Files\\*.exe',
                                '?:\\Program Files (x86)\\*.exe'
                              )
    | by ps.parent.uuid
action:
  - name: kill

output: >
  Potential infostealer process %2.ps.exe delivered via ClickFix infection chain
severity: high

min-engine-version: 3.0.0

```

`rules/initial_access_process_spawned_from_macro_enabled_microsoft_office_document.yml`:

```yml
name: Process spawned from macro-enabled Microsoft Office document
id: 47521206-e19d-4608-9dbc-dc3a1df99db5
version: 1.0.5
description: |
  Identifies the execution of the child process spawned by Microsoft
  Office parent process where the call stack contains the Visual Basic
  for Applications modules or suspicious symbols. This is a strong
  indicative of the presence of a weaponized macro-enabled document.
labels:
  tactic.id: TA0001
  tactic.name: Initial Access
  tactic.ref: https://attack.mitre.org/tactics/TA0001/
  technique.id: T1566
  technique.name: Phishing
  technique.ref: https://attack.mitre.org/techniques/T1566/
  subtechnique.id: T1566.001
  subtechnique.name: Spearphishing Attachment
  subtechnique.ref: https://attack.mitre.org/techniques/T1566/001/

condition: >
  spawn_process and
  ps.parent.name iin msoffice_binaries and
  (
    thread.callstack.modules imatches ('*vbe?.dll') or
    thread.callstack.symbols imatches
                            (
                              '*!xlAutoOpen*',
                              '*!wlAutoOpen*',
                              '*!wdAutoOpen*',
                              'kernel32.dll!WinExec*',
                              'shell32.dll!ShellExecute*'
                            )
  ) and
  ps.exe not imatches
                  (
                    '?:\\Windows\\explorer.exe',
                    '?:\\Windows\\hh.exe',
                    '?:\\Windows\\System32\\spool\\drivers\\*',
                    '?:\\Program Files (x86)\\Microsoft\\Edge\\Application\\msedge.exe'
                  )

min-engine-version: 3.0.0

```

`rules/initial_access_suspicious_dll_loaded_by_microsoft_office_process.yml`:

```yml
name: Suspicious DLL loaded by Microsoft Office process
id: 5868518c-2a83-4b26-ad4b-f14f0b85e744
version: 1.0.4
description:
  Identifies loading of recently dropped DLL by Microsoft Office process.
labels:
  tactic.id: TA0001
  tactic.name: Initial Access
  tactic.ref: https://attack.mitre.org/tactics/TA0001/
  technique.id: T1566
  technique.name: Phishing
  technique.ref: https://attack.mitre.org/techniques/T1566/
  subtechnique.id: T1566.001
  subtechnique.name: Spearphishing Attachment
  subtechnique.ref: https://attack.mitre.org/techniques/T1566/001/

condition: >
  sequence
  maxspan 1h
    |create_file and
     (file.extension iin module_extensions or file.is_dll) and ps.name iin msoffice_binaries and
     file.path not imatches '?:\\Program Files\\Microsoft Office\\Root\\Office*\\*.dll'
    | by file.name
    |load_module and ps.name iin msoffice_binaries| by module.name

min-engine-version: 3.0.0

```

`rules/initial_access_suspicious_execution_via_wmi_from_microsoft_office_process.yml`:

```yml
name: Suspicious execution via WMI from a Microsoft Office process
id: cc3f0bbe-ec53-40a7-9eed-f0a8a3f7d7fa
version: 1.0.6
description: |
  Identifies a suspicious process execution via Windows Management Instrumentation (WMI)
  originated from the Microsoft Office process loading an unusual WMI DLL. This technique
  can indicate code execution evading traditional parent/child processes spawned from Microsoft 
  Office products.
labels:
  tactic.id: TA0001
  tactic.name: Initial Access
  tactic.ref: https://attack.mitre.org/tactics/TA0001/
  technique.id: T1566
  technique.name: Phishing
  technique.ref: https://attack.mitre.org/techniques/T1566/
  subtechnique.id: T1566.001
  subtechnique.name: Spearphishing Attachment
  subtechnique.ref: https://attack.mitre.org/techniques/T1566/001/
references:
  - https://threathunterplaybook.com/hunts/windows/190811-WMIModuleLoad/notebook.html
  - https://medium.com/threatpunter/detecting-adversary-tradecraft-with-image-load-event-logging-and-eql-8de93338c16

condition: >
  sequence
  maxspan 1m
  by ps.sid
    |load_dll and
     dll.name iin ('wmiclnt.dll', 'wbemcomn.dll', 'wmiprov.dll', 'wbemprox.dll', 'wmutils.dll', 'fastprox.dll', 'WMINet_Utils.dll')  and
     (ps.name iin msoffice_binaries or thread.callstack.modules imatches ('*vbe?.dll'))
    |
    |spawn_process and
     ps.parent.name iin ('wmiprvse.exe', 'wmiapsrv.exe') and (ps.exe imatches ('?:\\Users\\*.exe', '?:\\ProgramData\\*.exe') or
     ps.name iin 
             (
               'rundll32.exe',
               'regsvr32.exe',
               'hh.exe',
               'cmd.exe',
               'pwsh.exe',
               'powershell.exe',
               'mshta.exe',
               'certutil.exe',
               'bitsadmin.exe',
               'cscript.exe',
               'wscript.exe',
               'jsc.exe',
               'vssadmin.exe',
               'curl.exe',
               'wget.exe',
               'sc.exe',
               'reg.exe',
               'schtasks.exe',
               'msxsl.exe',
               'msbuild.exe',
               'regasm.exe',
               'regsvcs.exe',
               'wmic.exe',
               'msiexec.exe'
             ) or
    ps.pe.file.name iin
            (
              'rundll32.exe',
              'regsvr32.exe',
              'hh.exe',
              'cmd.exe',
              'pwsh.exe',
              'powershell.exe',
              'mshta.exe',
              'certutil.exe',
              'bitsadmin.exe',
              'cscript.exe',
              'wscript.exe',
              'jsc.exe',
              'vssadmin.exe',
              'curl.exe',
              'wget.exe',
              'sc.exe',
              'reg.exe',
              'schtasks.exe',
              'msxsl.exe',
              'msbuild.exe',
              'regasm.exe',
              'regsvcs.exe',
              'wmic.exe',
              'msiexec.exe'
            ))|

output: >
  Suspicious process %2.ps.exe launched via WMI from Microsoft Office process %1.ps.parent.cmdline
severity: high

min-engine-version: 3.0.0

```

`rules/initial_access_suspicious_microsoft_office_embedded_object.yml`:

```yml
name: Suspicious Microsoft Office embedded object
id: 47368d49-1192-4059-9c55-6bbc4fd1a73a
version: 1.0.3
description: |
  Identifies Microsoft Office processes dropping a file with suspicious
  extension and with the call stack indicating operations to save or load
  the file from an embedded OLE object.
labels:
  tactic.id: TA0001
  tactic.name: Initial Access
  tactic.ref: https://attack.mitre.org/tactics/TA0001/
  technique.id: T1566
  technique.name: Phishing
  technique.ref: https://attack.mitre.org/techniques/T1566/
  subtechnique.id: T1566.001
  subtechnique.name: Spearphishing Attachment
  subtechnique.ref: https://attack.mitre.org/techniques/T1566/001/

condition: >
  create_file and
  ps.name iin msoffice_binaries and
  thread.callstack.symbols imatches ('*!OleSaveStream*', '*!OleLoad*', '*!OleCreate*') and
  (
    file.extension iin ('.exe', '.dll', '.js', '.vbs', '.vbe', '.jse', '.url', '.chm', '.bat', '.mht', '.hta', '.search-ms') or (file.is_exec or file.is_dll)
  )

min-engine-version: 3.0.0

```

`rules/macros/macros.yml`:

```yml
- macro: spawn_process
  expr: evt.name = 'CreateProcess'

- macro: create_thread
  expr: evt.name = 'CreateThread'

- macro: create_remote_thread
  expr: create_thread and evt.pid != 4 and evt.pid != thread.pid

- macro: open_process
  expr: evt.name = 'OpenProcess' and ps.access.status = 'Success'

- macro: open_thread
  expr: evt.name = 'OpenThread' and thread.access.status = 'Success'

- macro: open_remote_thread
  expr: open_thread and evt.pid != 4 and evt.pid != evt.arg[pid]

- macro: write_file
  expr: evt.name = 'WriteFile'

- macro: open_file
  expr: evt.name = 'CreateFile' and file.operation = 'OPEN' and file.status = 'Success'

- macro: create_file
  expr: evt.name = 'CreateFile' and file.operation != 'OPEN' and file.status = 'Success'

- macro: rename_file
  expr: evt.name = 'RenameFile'

- macro: read_file
  expr: evt.name = 'ReadFile'

- macro: delete_file
  expr: evt.name = 'DeleteFile'

- macro: set_file_information
  expr: evt.name = 'SetFileInformation'

- macro: query_registry
  expr: evt.name in ('RegQueryKey', 'RegQueryValue') and registry.status = 'Success'

- macro: open_registry
  expr: evt.name = 'RegOpenKey' and registry.status = 'Success'

- macro: load_module
  expr: evt.name = 'LoadImage'

- macro: unload_module
  expr: evt.name = 'UnloadImage'

- macro: set_value
  expr: evt.name = 'RegSetValue' and registry.status = 'Success'

- macro: create_key
  expr: evt.name = 'RegCreateKey' and registry.status = 'Success'

- macro: modify_registry
  expr: ((set_value) or (create_key))

- macro: send_socket
  expr: evt.name = 'Send'

- macro: recv_socket
  expr: evt.name = 'Recv'

- macro: connect_socket
  expr: evt.name = 'Connect'

- macro: accept_socket
  expr: evt.name = 'Accept'

- macro: set_thread_context
  expr: evt.name = 'SetThreadContext' and evt.arg[status] = 'Success'

- macro: virtual_alloc
  expr: evt.name = 'VirtualAlloc'

- macro: virtual_free
  expr: evt.name = 'VirtualFree'

- macro: map_view_file
  expr: evt.name = 'MapViewFile'

- macro: unmap_view_file
  expr: evt.name = 'UnmapViewFile'

- macro: map_view_of_section
  expr: map_view_file and file.view.type in ('IMAGE', 'IMAGE_NO_EXECUTE', 'PAGEFILE')

- macro: unmap_view_of_section
  expr: unmap_view_file and file.view.type in ('IMAGE', 'IMAGE_NO_EXECUTE')

- macro: duplicate_handle
  expr: evt.name = 'DuplicateHandle'

- macro: create_handle
  expr: evt.name = 'CreateHandle'

- macro: query_dns
  expr: evt.name = 'QueryDns'

- macro: reply_dns
  expr: evt.name = 'ReplyDns'

- macro: create_symbolic_link_object
  expr: evt.name = 'CreateSymbolicLinkObject' and evt.arg[status] = 'Success'

- macro: direct_syscall
  expr: evt.is_direct_syscall
  description: Indicates if the event has been triggered via direct syscall.

- macro: inbound_network
  expr: >
    (recv_socket or accept_socket) and
    ((net.sip != 0.0.0.0 or net.dip != 0.0.0.0) and (net.sip not in ('0:0:0:0:0:0:0:1', '::1') or net.dip not in ('0:0:0:0:0:0:0:1', '::1')) and not (cidr_contains(net.sip, '127.0.0.0/8') or cidr_contains(net.dip, '127.0.0.0/8')))
  description: |
    Detects inbound network traffic excluding source/destination loopback addresses/address spaces.

- macro: outbound_network
  expr: >
    (send_socket or connect_socket) and
    (net.dip != 0.0.0.0 and net.dip not in ('0:0:0:0:0:0:0:1', '::1') and not cidr_contains(net.dip, '127.0.0.0/8', '10.0.0.0/8', '172.16.0.0/12', '192.168.0.0/16'))
  description: |
    Detects outbound network traffic excluding unspecified destination IP addresses,
    loopback addresses, and IP addresses pertaining to the RFC1918 address space.

- macro: load_driver
  expr: >
    (load_module and (module.name iendswith '.sys' or module.is_driver))
  description: |
    Detects the loading of the kernel driver. Image load events are published when
    executable images, DLLs, or driver PE objects are loaded.

- macro: unload_driver
  expr: unload_module and (module.name iendswith '.sys' or module.is_driver)

- macro: load_unsigned_module
  expr: >
    load_module and module.signature.exists = false
  description: |
    Detects when unsigned executable or DLL is loaded into process address space.
    The module is considered as unsigned if it lacks the cert in the PE security
    directory or the Authenticode hash is not present in any of the catalogs.

- macro: load_executable
  expr: >
    load_module and (module.name iendswith '.exe' or module.is_exec)

- macro: load_dll
  expr: >
    load_module and (module.name iendswith '.dll' or module.is_dll)

- macro: load_unsigned_executable
  expr: >
    load_executable and module.signature.exists = false

- macro: load_untrusted_executable
  expr: >
    load_executable and module.signature.trusted = false
  description:
    Detects when untrusted executable is loaded into process address space.

- macro: load_untrusted_dll
  expr: >
    load_dll and dll.signature.trusted = false
  description:
    Detects when untrusted DLL is loaded into process address space.

- macro: load_unsigned_module
  expr: >
    load_module and module.signature.exists = false
  description: |
    Detects when unsigned executable or DLL is loaded into process address space.
    The module is considered as unsigned if it lacks the cert in the PE security
    directory or the Authenticode hash is not present in any of the catalogs.

- macro: load_unsigned_dll
  expr: >
    load_dll and dll.signature.exists = false
  description: |
    Detects when unsigned executable DLL is loaded into process address space.

- macro: load_untrusted_module
  expr: >
    load_module and module.signature.trusted = false
  description: |
    Detects when untrusted executable or DLL is loaded into process address space.
    Windows must verify the trust chain by following the certificates to a trusted
    root certificate. If the trust chain is not satisfied, the module is considered
    untrusted.

- macro: load_unsigned_or_untrusted_module
  expr: (load_unsigned_module) or (load_untrusted_module)
  description: >
    Detects when either unsigned or untrusted module is loaded into process address space.

- macro: load_unsigned_or_untrusted_dll
  expr: (load_unsigned_dll) or (load_untrusted_dll)
  description: >
    Detects when either unsigned or untrusted DLL is loaded into process address space.

- macro: msoffice_binaries
  list: [EXCEL.EXE, WINWORD.EXE, MSACCESS.EXE, POWERPNT.EXE, visio.exe, mspub.exe, fltldr.exe, eqnedt32.exe]

- macro: web_browser_binaries
  list: [
    chrome.exe, firefox.exe, msedge.exe, iexplore.exe, opera.exe,
    brave.exe, microsoftedge.exe, chromium.exe, safari.exe
    ]

- macro: web_browser_cred_stores
  list: [
    "?:\\Users\\*\\AppData\\Local\\Google\\Chrome\\User Data\\Default\\Network\\Cookies",
    "?:\\Users\\*\\AppData\\Local\\Chrome\\User Data\\Default\\Login Data",
    "?:\\Users\\*\\AppData\\Local\\Google\\Chrome\\User Data\\Local State",
    "?:\\Users\\*\\Appdata\\Local\\Microsoft\\Windows\\WebCache\\WebCacheV0?.dat",
    "?:\\Users\\*\\AppData\\Roaming\\Mozilla\\Firefox\\Profiles\\*\\cookies.sqlite",
    "?:\\Users\\*\\AppData\\Roaming\\Mozilla\\Firefox\\Profiles\\*\\sigons.sqlite",
    "?:\\Users\\*\\AppData\\Roaming\\Mozilla\\Firefox\\Profiles\\*\\logins.json",
    "?:\\Users\\*\\AppData\\Roaming\\Mozilla\\Firefox\\Profiles\\*\\key?.db",
    ]

- macro: executable_extensions
  list: [.exe, .com, .scr]

- macro: module_extensions
  list: [.dll, .ocx, .cpl]

- macro: vault_extensions
  list: [.vcrd, .vpol]

- macro: startup_locations
  list: [
    "?:\\Users\\*\\AppData\\Roaming\\Microsoft\\Windows\\Start Menu\\Programs\\Startup\\*",
    "?:\\ProgramData\\Microsoft\\Windows\\Start Menu\\Programs\\StartUp\\*",
    ]
  description: |
    Contains default Startup folder paths. Adversaries exploit the Startup folder
    to maintain persistence on the endpoint.

- macro: registry_run_keys
  list: [
    "*\\Software\\Microsoft\\Windows\\CurrentVersion\\Run\\*",
    "*\\Software\\Microsoft\\Windows\\CurrentVersion\\RunOnce\\*",
    "*\\Software\\Microsoft\\Windows\\CurrentVersion\\RunOnceEx\\*",
    "*\\Software\\Microsoft\\Windows\\CurrentVersion\\RunServices\\*",
    "*\\Software\\Microsoft\\Windows\\CurrentVersion\\RunServicesOnce\\*",
    "*\\Software\\WOW6432Node\\Microsoft\\Windows\\CurrentVersion\\Run\\*",
    "*\\Software\\Microsoft\\Windows\\CurrentVersion\\Policies\\Explorer\\Run\\*",
    "*\\Software\\WOW6432Node\\Microsoft\\Windows\\CurrentVersion\\Policies\\Explorer\\Run\\*",
    ]
  description: |
    Contains wildcard patterns of commonly abused registry run keys.

- macro: registry_persistence_keys
  list: [
    "HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Winlogon\\Userinit",
    "HKEY_USERS\\*\\SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Windows\\Load",
    "HKEY_USERS\\*\\SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Windows\\Run",
    "HKEY_CURRENT_USER\\SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Windows\\Load",
    "HKEY_CURRENT_USER\\SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Windows\\Run",
    "HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Winlogon\\Shell",
    "HKEY_CURRENT_USER\\SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Winlogon\\Shell",
    "HKEY_USERS\\*\\SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Winlogon\\Shell",
    "HKEY_USERS\\*\\Environment\\UserInitMprLogonScript",
    "HKEY_USERS\\*\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Policies\\System\\Shell",
    "HKEY_USERS\\*\\SOFTWARE\\Policies\\Microsoft\\Windows\\System\\Scripts\\Logoff\\Script",
    "HKEY_USERS\\*\\SOFTWARE\\Policies\\Microsoft\\Windows\\System\\Scripts\\Logon\\Script",
    "HKEY_USERS\\*\\SOFTWARE\\Policies\\Microsoft\\Windows\\System\\Scripts\\Shutdown\\Script",
    "HKEY_USERS\\*\\SOFTWARE\\Policies\\Microsoft\\Windows\\System\\Scripts\\Startup\\Script",
    "HKEY_USERS\\*\\SOFTWARE\\Microsoft\\Ctf\\LangBarAddin\\*\\FilePath",
    "HKEY_USERS\\*\\SOFTWARE\\Microsoft\\Internet Explorer\\Extensions\\*\\Exec",
    "HKEY_USERS\\*\\SOFTWARE\\Microsoft\\Command Processor\\Autorun",
    "HKEY_CURRENT_USER\\SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Winlogon\\Shell",
    "HKEY_CURRENT_USER\\Environment\\UserInitMprLogonScript",
    "HKEY_CURRENT_USER\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Policies\\System\\Shell",
    "HKEY_CURRENT_USER\\SOFTWARE\\Policies\\Microsoft\\Windows\\System\\Scripts\\Logoff\\Script",
    "HKEY_CURRENT_USER\\SOFTWARE\\Policies\\Microsoft\\Windows\\System\\Scripts\\Logon\\Script",
    "HKEY_CURRENT_USER\\SOFTWARE\\Policies\\Microsoft\\Windows\\System\\Scripts\\Shutdown\\Script",
    "HKEY_CURRENT_USER\\SOFTWARE\\Policies\\Microsoft\\Windows\\System\\Scripts\\Startup\\Script",
    "HKEY_CURRENT_USER\\SOFTWARE\\Microsoft\\Ctf\\LangBarAddin\\*\\FilePath",
    "HKEY_CURRENT_USER\\SOFTWARE\\Microsoft\\Internet Explorer\\Extensions\\*\\Exec",
    "HKEY_CURRENT_USER\\SOFTWARE\\Microsoft\\Command Processor\\Autorun",
    "HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Control\\Session Manager\\BootExecute",
    "HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Control\\Session Manager\\SetupExecute",
    "HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Control\\Session Manager\\Execute",
    "HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Control\\Session Manager\\S0InitialCommand"
   ]
  description: |
    Contains the patterns for the registry keys which are commonly abused for
    gaining persistence on the compromised endpoint.

- macro: script_interpreters
  list: ["powershell.exe", "pwsh.exe", "cscript.exe", "wscript.exe", "mshta.exe", "cmd.exe"]

- macro: startup_shell_folder_registry_keys
  list: [
    "HKEY_USERS\\*\\Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\User Shell Folders\\Startup",
    "HKEY_USERS\\*\\Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\Shell Folders\\Startup",
    "HKEY_CURRENT_USER\\Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\Shell Folders\\Startup",
    "HKEY_CURRENT_USER\\Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\Shell Folders\\Startup",
    "HKEY_LOCAL_MACHINE\\Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\User Shell Folders\\Common Startup",
    "HKEY_LOCAL_MACHINE\\Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\Shell Folders\\Common Startup"
   ]
  description: |
    Registry keys that permit setting up alternative Startup folder locations.

```

`rules/persistence_executable_file_dropped_by_unsigned_service_dll.yml`:

```yml
name: Executable file dropped by an unsigned service DLL
id: 3e29da58-0fc4-44c0-91c0-0dfc6af87e9d
version: 1.0.3
description: |
  Identifies the loading of an unsigned DLL by svchost process followed by creating an
  executable file. Adversaries may rely on Windows Services to repeatedly execute malicious 
  payloads as part of persistence.
labels:
  tactic.id: TA0003
  tactic.name: Persistence
  tactic.ref: https://attack.mitre.org/tactics/TA0003/
  technique.id: T1543
  technique.name: Create or Modify System Process
  technique.ref: https://attack.mitre.org/techniques/T1543/
  subtechnique.id: T1543.003
  subtechnique.name: Windows Service
  subtechnique.ref: https://attack.mitre.org/techniques/T1543/003/
references:
  - https://grzegorztworek.medium.com/persistence-with-windows-services-1b21579f0ff3
  - https://www.ired.team/offensive-security/persistence/persisting-in-svchost.exe-with-a-service-dll-servicemain

condition: >
  sequence
  maxspan 3m
    |load_unsigned_dll and ps.exe imatches ('?:\\Windows\\System32\\svchost.exe', '?:\\Windows\\SysWOW64\\svchost.exe')| as e1
    |create_file and
     evt.pid != 4 and ps.exe imatches ('?:\\Windows\\System32\\svchost.exe', '?:\\Windows\\SysWOW64\\svchost.exe') and
     (file.extension iin ('.exe', '.dll', '.com', '.js', '.vbs', '.cmd', '.bat', '.vbe') or file.is_exec or file.is_dll or file.is_driver) and
      thread.callstack.symbols iin (concat($e1.module.name, '!ServiceMain'))
    |

output: >
  Service %1.ps.cmdline loaded an unsigned DLL %1.dll.path and subsequently dropped an executable file %2.file.path
severity: high

min-engine-version: 3.0.0

```

`rules/persistence_hidden_local_account_creation.yml`:

```yml
name: Hidden local account creation
id: bfa83754-3730-4c46-a0fd-cc71365f64df
version: 1.0.3
description: |
  Identifies the creation of a hidden local account. Adversaries can create hidden accounts by
  appending the dollar sign to the account name. This technique renders the account name hidden
  to user enumeration tools such as `net user` and effectively bypasses detections.
labels:
  tactic.id: TA0003
  tactic.name: Persistence
  tactic.ref: https://attack.mitre.org/tactics/TA0003/
  technique.id: T1136
  technique.name: Create Account
  technique.ref: https://attack.mitre.org/techniques/T1136/
  subtechnique.id: T1136.001
  subtechnique.name: Local Account
  subtechnique.ref: https://attack.mitre.org/techniques/T1136/001/

condition: >
  modify_registry and
  registry.path imatches
                (
                  'HKEY_LOCAL_MACHINE\\SAM\\SAM\\Domains\\Account\\Users\\Names\\*$',
                  'HKEY_LOCAL_MACHINE\\SAM\\SAM\\Domains\\Account\\Users\\*$'
                )

severity: high

min-engine-version: 3.0.0

```

`rules/persistence_network_connection_via_startup_folder_executable_or_script.yml`:

```yml
name: Network connection via startup folder executable or script
id: 09b7278d-42e3-4792-9f00-dee38baecfad
version: 1.1.0
description: |
  Identifies the execution of unsigned binary or script from the
  Startup folder followed by network inbound or outbound connection.
labels:
  tactic.id: TA0006
  tactic.name: Persistence
  tactic.ref: https://attack.mitre.org/tactics/TA0006/
  technique.id: T1547
  technique.name: Boot or Logon Autostart Execution
  technique.ref: https://attack.mitre.org/techniques/T1547/
  subtechnique.id: T1547.001
  subtechnique.name: Registry Run Keys / Startup Folder
  subtechnique.ref: https://attack.mitre.org/techniques/T1547/001/

condition: >
  sequence
  maxspan 5m
  by ps.uuid
    |(load_untrusted_executable and module.path imatches startup_locations) or
     (load_executable and ps.name in script_interpreters and ps.cmdline imatches startup_locations)
    |
    |connect_socket and
     ps.cmdline imatches startup_locations and
     net.dip != 0.0.0.0 and net.dip not in ('0:0:0:0:0:0:0:1', '::1') and
     not cidr_contains(net.dip, '127.0.0.0/8', '10.0.0.0/8', '172.16.0.0/12', '192.168.0.0/16')
    |

min-engine-version: 3.0.0

```

`rules/persistence_potential_port_monitor_or_print_processor_persistence_via_registry_modification.yml`:

```yml
name: Potential port monitor or print processor persistence via registry modification
id: de04ae6b-8141-41af-9baa-15630b5954cc
version: 1.0.2
description: |
  Identifies port monitor or print process registry modifications that would allow
  adversaries to run malicious DLLs during system boot.
labels:
  tactic.id: TA0003
  tactic.name: Persistence
  tactic.ref: https://attack.mitre.org/tactics/TA0003/
  technique.name: Boot or Logon Autostart Execution
  technique.ref: https://attack.mitre.org/techniques/T1547/
  subtechnique.id: T1547.010
  subtechnique.name: Port Monitors
  subtechnique.ref: https://attack.mitre.org/techniques/T1547/010/
references:
  - https://stmxcsr.com/persistence/print-processor.html
  - https://www.ired.team/offensive-security/persistence/t1013-addmonitor

condition: >
  (modify_registry) and
  ps.sid != 'S-1-5-18' and
  registry.path imatches
                (
                  'HKEY_LOCAL_MACHINE\\SYSTEM\\*ControlSet*\\Control\\Print\\Monitors\\*',
                  'HKEY_LOCAL_MACHINE\\SYSTEM\\*ControlSet*\\Control\\Print\\Environments\\Windows*\\Print Processors\\*'
                )

output: >
  Port monitor or print processor DLL registered under registry key %registry.path by process %ps.exe
severity: high

min-engine-version: 3.0.0

```

`rules/persistence_rid_hijacking.yml`:

```yml
name: RID Hijacking
id: 5c25666a-4a9f-4b7c-b02f-db0b5cdbde83
version: 1.0.4
description: |
  RID (Relative ID part of security identifier) hijacking allows an attacker with SYSTEM
  level privileges to covertly replace the RID of a low privileged account effectively making
  the low privileged account assume Administrator privileges on the next logon.
labels:
  tactic.id: TA0006
  tactic.name: Persistence
  tactic.ref: https://attack.mitre.org/tactics/TA0006/
  technique.id: T1547
  technique.name: Boot or Logon Autostart Execution
  technique.ref: https://attack.mitre.org/techniques/T1547/
references:
  - https://github.com/r4wd3r/RID-Hijacking
  - https://www.ired.team/offensive-security/persistence/rid-hijacking

condition: >
  set_value and
  registry.path imatches 'HKEY_LOCAL_MACHINE\\SAM\\SAM\\Domains\\Account\\Users\\*\\F' and
  ps.sid in ('S-1-5-18', 'S-1-5-19', 'S-1-5-20') and
  ps.exe not imatches '?:\\Windows\\System32\\lsass.exe'

min-engine-version: 3.0.0

```

`rules/persistence_script_interpreter_or_untrusted_process_persistence.yml`:

```yml
name: Script interpreter host or untrusted process persistence
id: cc41ee3a-6e44-4903-85a4-0147ec6a7eea
version: 1.1.3
description: |
  Identifies the script interpreter or untrusted process writing to commonly 
  abused run keys or the Startup folder locations.
labels:
  tactic.id: TA0006
  tactic.name: Persistence
  tactic.ref: https://attack.mitre.org/tactics/TA0006/
  technique.id: T1547
  technique.name: Boot or Logon Autostart Execution
  technique.ref: https://attack.mitre.org/techniques/T1547/
  subtechnique.id: T1547.001
  subtechnique.name: Registry Run Keys / Startup Folder
  subtechnique.ref: https://attack.mitre.org/techniques/T1547/001/

condition: >
  (((modify_registry) or (create_file)) and evt.pid != 4) and
  (ps.name in script_interpreters or ps.parent.name in script_interpreters or ps.signature.trusted = false) and
  (registry.path imatches registry_run_keys or file.path imatches startup_locations) and
  not (ps.exe imatches
              (
                '?:\\Windows\\explorer.exe',
                '?:\\Windows\\System32\\services.exe',
                '?:\\Windows\\System32\\svchost.exe',
                '?:\\Windows\\System32\\msiexec.exe',
                '?:\\Program Files*\\Google\\Chrome\\Application\\chrome.exe',
                '?:\\Program Files*\\Mozilla Firefox\\firefox.exe',
                '?:\\Program Files*\\Opera\\*\\opera.exe',
                '?:\\Program Files*\\Microsoft\\Edge\\Application\\msedge.exe',
                '?:\\Program Files\\Microsoft\\Edge\\Application\\*\\msedge.exe',
                '?:\\Program Files (x86)\\Microsoft\\Edge\\Application\\*\\msedge.exe',
                '?:\\Users\\*\\AppData\\Local\\Microsoft\\OneDrive\\OneDrive.exe',
                '?:\\Program Files\\Google\\Drive File Stream\\*\\GoogleDriveFS.exe',
                '?:\\Users\\*\\AppData\\Local\\Dropbox\\Dropbox.exe'
              ) or
       (ps.signature.exists = true and ps.signature.subject imatches '*Microsoft*'))
action:
  - name: kill

min-engine-version: 3.0.0

```

`rules/persistence_suspicious_microsoft_office_addin_loaded.yml`:

```yml
name: Suspicious Microsoft Office add-in loaded
id: fe4daff8-d8aa-48d3-bf09-a9d868375a3c
version: 1.0.3
description: |
  Identifies attempts to load unsigned executables from known Microsoft Office 
  add-ins directories, which adversaries may exploit to maintain persistence.
labels:
  tactic.id: TA0003
  tactic.name: Persistence
  tactic.ref: https://attack.mitre.org/tactics/TA0003/
  technique.id: T1137
  technique.name: Office Application Startup
  technique.ref: https://attack.mitre.org/techniques/T1137/
references:
  - https://github.com/3gstudent/Office-Persistence/blob/master/OfficePersistence.ps1

condition: >
  (load_unsigned_or_untrusted_module) and
  ps.name iin ('excel.exe', 'winword.exe', 'outlook.exe', 'powerpnt.exe') and
  module.path imatches
            (
              '?:\\Users\\*\\AppData\\Roaming\\Microsoft\\AddIns\\*',
              '?:\\Users\\*\\AppData\\Roaming\\Microsoft\\Excel\\XLSTART\\*',
              '?:\\Users\\*\\AppData\\Roaming\\Microsoft\\Word\\Startup\\*',
              '?:\\Users\\*\\AppData\\Roaming\\Microsoft\\Outlook\\*'
            )

output:
  Microsoft Office process %ps.name loaded a suspicious add-in %module.path
severity: high

min-engine-version: 3.0.0

```

`rules/persistence_suspicious_microsoft_office_template.yml`:

```yml
name: Suspicious Microsoft Office template
id: c4be3b30-9d23-4a33-b974-fb12e17487a2
version: 1.0.4
description: |
  Detects when attackers drop macro-enabled files in specific
  folders to trigger their execution every time the victim user
  opens an Office application.
labels:
  tactic.id: TA0006
  tactic.name: Persistence
  tactic.ref: https://attack.mitre.org/tactics/TA0006/
  technique.id: T1137
  technique.name: Office Application Startup
  technique.ref: https://attack.mitre.org/techniques/T1137/
  subtechnique.id: T1137.001
  subtechnique.name: Office Template Macros
  subtechnique.ref: https://attack.mitre.org/techniques/T1137/001/
references:
  - https://cyberint.com/blog/research/office-templates-and-globaldotname-a-stealthy-office-persistence-technique/

condition: >
  create_file and
  file.path imatches
            (
              '?:\\Users\\*\\AppData\\Roaming\\Microsoft\\Word\\Startup\\*',
              '?:\\Users\\*\\AppData\\Roaming\\Microsoft\\Templates\\*.dotm',
              '?:\\Users\\*\\AppData\\Roaming\\Microsoft\\Excel\\XLSTART\\*',
              '?:\\Users\\*\\AppData\\Roaming\\Microsoft\\AddIns\\*',
              '?:\\Users\\*\\AppData\\Roaming\\Microsoft\\Outlook\\*.otm'
            ) and
  ps.name not iin msoffice_binaries and
  ps.exe not imatches
            (
              '?:\\Program Files\\*.exe',
              '?:\\Program Files (x86)\\*.exe'
            )

output: >
  Office template %file.path created by suspicious process %ps.exe

min-engine-version: 3.0.0

```

`rules/persistence_suspicious_netsh_helper_dll_execution.yml`:

```yml
name: Suspicious Netsh Helper DLL execution
id: bd17781d-38ca-4b9a-a12a-f807a1eb45e0
version: 1.0.5
description: |
  Identifies the execution of a suspicious Netsh Helper DLL. Adversaries may establish persistence 
  by executing malicious content triggered by Netsh Helper DLLs. Netsh.exe is a command-line scripting 
  utility used to interact with the network configuration of a system. It supports the addition of 
  custom DLLs to extend its functionality that attackers can weaponize.
labels:
  tactic.id: TA0003
  tactic.name: Persistence
  tactic.ref: https://attack.mitre.org/tactics/TA0003/
  technique.id: T1546
  technique.name: Event Triggered Execution
  technique.ref: https://attack.mitre.org/techniques/T1546/
  subtechnique.id: T1546.007
  subtechnique.name: Netsh Helper DLL
  subtechnique.ref: https://attack.mitre.org/techniques/T1546/007/
references:
  - https://github.com/outflanknl/NetshHelperBeacon
  - https://www.ired.team/offensive-security/persistence/t1128-netsh-helper-dll

condition: >
  sequence
  maxspan 1m
  by ps.uuid
    |spawn_process and
     (ps.name ~= 'netsh.exe' or ps.pe.file.name ~= 'netsh.exe')
    |
    |create_thread and
     foreach(thread._callstack, $frame, $frame.symbol imatches '*!InitHelperDll' and ($frame.module.signature.exists = false or $frame.module.signature.trusted = false))
    |

output: >
  Suspicious Netsh Helper DLL %2.thread.start_address.module executed
severity: high

min-engine-version: 3.0.0

```

`rules/persistence_suspicious_persistence_via_registry_modification.yml`:

```yml
name: Suspicious persistence via registry modification
id: 1f496a17-4f0c-491a-823b-7a70adb9919c
version: 1.0.5
description: |
  Adversaries may abuse the registry to achieve persistence
  by modifying the keys that are unlikely modified by legitimate
  processes.
labels:
  tactic.id: TA0006
  tactic.name: Persistence
  tactic.ref: https://attack.mitre.org/tactics/TA0006/
  technique.id: T1547
  technique.name: Boot or Logon Autostart Execution
  technique.ref: https://attack.mitre.org/techniques/T1547/
  subtechnique.id: T1547.001
  subtechnique.name: Registry Run Keys / Startup Folder
  subtechnique.ref: https://attack.mitre.org/techniques/T1547/001/

condition: >
  modify_registry and
  (
    (ps.name in script_interpreters or ps.name in ('reg.exe', 'rundll32.exe', 'regsvr32.exe')) or
     ps.exe imatches '?:\\Users\\Public\\*' or
     ps.signature.exists = false or ps.signature.trusted = false
  ) and
  registry.path imatches registry_persistence_keys

min-engine-version: 3.0.0

```

`rules/persistence_suspicious_port_monitor_loaded.yml`:

```yml
name: Suspicious port monitor loaded
id: d6ab6bfa-1a97-46cb-a69a-7a6c98a699f1
version: 1.0.3
description: |
  Identifies the loading of an unsigned DLL by the print spool service. Adversaries may use port
  monitors to run an adversary supplied DLL during system boot for persistence or privilege escalation.
labels:
   tactic.id: TA0003
   tactic.name: Persistence
   tactic.ref: https://attack.mitre.org/tactics/TA0003/
   technique.id: T1547
   technique.name: Boot or Logon Autostart Execution
   technique.ref: https://attack.mitre.org/techniques/T1547/
   subtechnique.id: T1547.010
   subtechnique.name: Port Monitors
   subtechnique.ref: https://attack.mitre.org/techniques/T1547/010/
references:
  - https://www.ired.team/offensive-security/persistence/t1013-addmonitor

condition: >
  (load_unsigned_or_untrusted_dll) and
  ps.name ~= 'spoolsv.exe' and
  thread.callstack.symbols imatches ('localspl.dll!SplAddMonitor*', 'spoolsv.exe!PrvAddMonitor*')

min-engine-version: 3.0.0

```

`rules/persistence_suspicious_print_processor_loaded.yml`:

```yml
name: Suspicious print processor loaded
id: 3e0f5ef7-8a0a-4604-b2bf-d09606f45483
version: 1.0.3
description: |
  Identifies when the print spooler service loads unsigned or untrusted DLL and the callstack pattern
  indicates the print processor is loaded. Adversaries may abuse print processors to run malicious DLLs 
  during system boot for persistence and/or privilege escalation.
labels:
  tactic.id: TA0003
  tactic.name: Persistence
  tactic.ref: https://attack.mitre.org/tactics/TA0003/
  technique.id: T1547
  technique.name: Boot or Logon Autostart Execution
  technique.ref: https://attack.mitre.org/techniques/T1547/
  subtechnique.id: T1547.012
  subtechnique.name: Print Processors
  subtechnique.ref: https://attack.mitre.org/techniques/T1547/012/
references:
  - https://stmxcsr.com/persistence/print-processor.html

condition: >
  (load_unsigned_or_untrusted_dll) and
  ps.name ~= 'spoolsv.exe' and
  thread.callstack.summary imatches 'ntdll.dll|KernelBase.dll|localspl.dll|spoolsv.exe|kernel32.dll|ntdll.dll' and
  thread.callstack.symbols imatches ('localspl.dll!SplSetPrinterData') and thread.callstack.symbols not imatches ('KernelBase.dll!RegisterGPNotificationInternal')

output: >
  Print spooler service loaded suspicious print processor DLL %module.path
severity: high

min-engine-version: 3.0.0

```

`rules/persistence_suspicious_startup_shell_folder_modification.yml`:

```yml
name: Suspicious Startup shell folder modification
id: 7a4082f6-f7e3-49bd-9514-dbc8dd4e68ad
version: 1.0.4
description: |
  Detects when adversaries attempt to modify the default Startup
  folder path to to circumvent runtime rules that hunt for file
  creations in the default Startup folder.
labels:
  tactic.id: TA0006
  tactic.name: Persistence
  tactic.ref: https://attack.mitre.org/tactics/TA0006/
  technique.id: T1547
  technique.name: Boot or Logon Autostart Execution
  technique.ref: https://attack.mitre.org/techniques/T1547/
  subtechnique.id: T1547.001
  subtechnique.name: Registry Run Keys / Startup Folder
  subtechnique.ref: https://attack.mitre.org/techniques/T1547/001/

condition: >
  modify_registry and
  registry.path imatches startup_shell_folder_registry_keys and
  not (registry.data imatches startup_locations or
       registry.data imatches ('%ProgramData%\\Microsoft\\Windows\\Start Menu\\Programs\\Startup'))

min-engine-version: 3.0.0

```

`rules/persistence_unusual_file_written_in_startup_folder.yml`:

```yml
name: Unusual file written in Startup folder
id: c5ffe15c-d94f-416b-bec7-c47f89843267
version: 1.0.4
description: |
  Identifies suspicious files written to the startup folder that would
  allow adversaries to maintain persistence on the endpoint.
labels:
  tactic.id: TA0006
  tactic.name: Persistence
  tactic.ref: https://attack.mitre.org/tactics/TA0006/
  technique.id: T1547
  technique.name: Boot or Logon Autostart Execution
  technique.ref: https://attack.mitre.org/techniques/T1547/
  subtechnique.id: T1547.001
  subtechnique.name: Registry Run Keys / Startup Folder
  subtechnique.ref: https://attack.mitre.org/techniques/T1547/001/

condition: >
  create_file and
  (file.extension in ('.vbs', '.js', '.jar', '.exe', '.dll', '.com', '.ps1', '.hta', '.cmd', '.vbe') or (file.is_exec or file.is_dll)) and
  file.path imatches startup_locations and
  ps.exe not imatches
            (
              '?:\\Windows\\System32\\wuauclt.exe',
              '?:\\Windows\\System32\\msiexec.exe',
              '?:\\Windows\\SysWOW64\\msiexec.exe',
              '?:\\Windows\\System32\\svchost.exe',
              '?:\\ProgramData\\Microsoft\\Windows Defender\\Platform\\*.exe'
            )

min-engine-version: 3.0.0

```

`rules/persistence_unusual_process_modified_registry_run_key.yml`:

```yml
name: Unusual process modified registry run key
id: 921508a5-b627-4c02-a295-6c6863c0897b
version: 1.0.6
description: |
  Identifies an attempt by unusual Windows native processes to modify
  the run key and gain persistence on users logons or machine reboots.
labels:
  tactic.id: TA0006
  tactic.name: Persistence
  tactic.ref: https://attack.mitre.org/tactics/TA0006/
  technique.id: T1547
  technique.name: Boot or Logon Autostart Execution
  technique.ref: https://attack.mitre.org/techniques/T1547/
  subtechnique.id: T1547.001
  subtechnique.name: Registry Run Keys / Startup Folder
  subtechnique.ref: https://attack.mitre.org/techniques/T1547/001/

condition: >
  modify_registry and
  ps.exe imatches '?:\\Windows\\*' and
  registry.path imatches registry_run_keys and
  ps.exe not imatches
            (
              '?:\\Windows\\System32\\svchost.exe',
              '?:\\Windows\\SysWOW64\\msiexec.exe',
              '?:\\Windows\\System32\\msiexec.exe',
              '?:\\Windows\\System32\\drvinst.exe',
              '?:\\Windows\\System32\\WinSAT.exe',
              '?:\\Windows\\System32\\reg.exe',
              '?:\\Windows\\regedit.exe',
              '?:\\Windows\\SysWOW64\\reg.exe',
              '?:\\Windows\\System32\\csrss.exe',
              '?:\\Windows\\SysWOW64\\DriverStore\\*.exe',
              '?:\\Windows\\System32\\DriverStore\\*.exe',
              '?:\\Windows\\Installer\\*.exe',
              '?:\\Windows\\explorer.exe',
              '?:\\Windows\\IMECache\\*.exe',
              '?:\\Windows\\System32\\sihost.exe',
              '?:\\Windows\\SysWOW64\\prevhost.exe',
              '?:\\Windows\\System32\\conhost.exe',
              '?:\\Windows\\System32\\taskhostw.exe',
              '?:\\Windows\\System32\\backgroundTaskHost.exe',
              '?:\\Windows\\System32\\CompatTelRunner.exe'
            )

min-engine-version: 3.0.0

```

`rules/privilege_escalation_potential_privilege_escalation_via_phantom_dll_hijacking.yml`:

```yml
name: Potential privilege escalation via phantom DLL hijacking
id: 5ccdb5c2-3a30-4e14-87d2-d7aeb4c45fad
version: 1.0.6
description: |
  Identifies the loading of the phantom DLL that was previously dropped
  to the System directory. Adversaries may exploit this flow to escalate
  privileges by placing a custom version of the DLL and initiating the
  execution of an auto-elevated high integrity Windows native process.
labels:
   tactic.id: TA0004
   tactic.name: Privilege Escalation
   tactic.ref: https://attack.mitre.org/tactics/TA0004/
   technique.id: T1574
   technique.name: Hijack Execution Flow
   technique.ref: https://attack.mitre.org/techniques/T1574/
   subtechnique.id: T1574.001
   subtechnique.name: DLL Search Order Hijacking
   subtechnique.ref: https://attack.mitre.org/techniques/T1574/001/
references:
  - http://waleedassar.blogspot.com/2013/01/wow64logdll.html
  - http://www.hexacorn.com/blog/2013/12/08/beyond-good-ol-run-key-part-5/
  - https://www.sentinelone.com/blog/deep-hooks-monitoring-native-execution-wow64-applications-part-1/
  - https://shellz.club/posts/edgegdi-dll-for-persistence-and-lateral-movement/
  - https://www.mdsec.co.uk/2020/10/i-live-to-move-it-windows-lateral-movement-part-3-dll-hijacking/
  - https://posts.specterops.io/lateral-movement-scm-and-dll-hijacking-primer-d2f61e8ab992

condition: >
  sequence
  maxspan 10m
    |create_file and evt.pid != 4 and
     file.path imatches
              (
                '?:\\Windows\\System32\\wow64log.dll',
                '?:\\Windows\\wbemcomn.dll',
                '?:\\Windows\\System\\Ualapi.dll',
                '?:\\Windows\\System32\\EdgeGdi.dll',
                '?:\\Windows\\*\\wbem\\wbemcomn.dll',
                '?:\\Windows\\System32\\WindowsPowerShell\\*\\wbemcomn.dll',
                '?:\\Windows\\*\\Ualapi.dll',
                '?:\\Windows\\System32\\spool\\drivers\\x64\\PrintConfig.dll',
                '?:\\Windows\\System32\\wlbsctrl.dll',
                '?:\\Windows\\System32\\Tsmsisrv.dll',
                '?:\\Windows\\System32\\TSVIPSrv.dll',
                '?:\\Windows\\System32\\fveapi.dll',
                '?:\\Windows\\System32\\Speech\\Engines\\TTS\\MSTTSLocEnUS.dll',
                '?:\\Windows\\System32\\DXGIDebug.dll'
              ) and  
     ps.exe not imatches
              (
                '?:\\Windows\\System32\\RuntimeBroker.exe',
                '?:\\Windows\\System32\\svchost.exe',
                '?:\\Windows\\System32\\services.exe',
                '?:\\Windows\\System32\\smss.exe',
                '?:\\Windows\\System32\\csrss.exe',
                '?:\\Windows\\System32\\wininit.exe',
                '?:\\Windows\\System32\\winlogon.exe'
              )
    | by file.path
    |load_dll| by module.path

min-engine-version: 3.0.0

```

`rules/privilege_escalation_vulnerable_or_malicious_driver_dropped.yml`:

```yml
name: Vulnerable or malicious driver dropped
id: d4742163-cf68-4ebd-b9a2-3ad17bbf63d5
version: 1.0.3
description: |
  Detects when adversaries drop a vulnerable/malicious driver
  onto a compromised system as a preparation for vulnerability
  exploitation that leads to code execution in kernel mode.
labels:
  tactic.id: TA0004
  tactic.name: Privilege Escalation
  tactic.ref: https://attack.mitre.org/tactics/TA0004/
  technique.id: T1068
  technique.name: Exploitation for Privilege Escalation
  technique.ref: https://attack.mitre.org/techniques/T1068/
references:
  - https://www.loldrivers.io/

condition: >
  create_file and file.is_driver and (file.is_driver_vulnerable or file.is_driver_malicious)

output: >
  Vulnerable or malicious %file.path driver dropped

min-engine-version: 3.0.0

```

`rules/privilege_escalation_vulnerable_or_malicious_driver_loaded.yml`:

```yml
name: Vulnerable or malicious driver loaded
id: e8005f1d-b4ec-45ee-a3ea-4247eac123db
version: 1.0.4
description: |
  Detects when adversaries load a vulnerable/malicious driver
  into the compromised system to exploit the vulnerability and
  execute code in kernel mode to bypass security controls.
labels:
  tactic.id: TA0004
  tactic.name: Privilege Escalation
  tactic.ref: https://attack.mitre.org/tactics/TA0004/
  technique.id: T1068
  technique.name: Exploitation for Privilege Escalation
  technique.ref: https://attack.mitre.org/techniques/T1068/
references:
  - https://www.loldrivers.io/

condition: >
  (load_driver) and (module.is_driver_vulnerable or module.is_driver_malicious)

output: >
  Vulnerable or malicious %module.path driver loaded

min-engine-version: 3.0.0

```