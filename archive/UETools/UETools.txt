Project Path: arc_UETools_UETools_t6jl42k5

Source Tree:

```txt
arc_UETools_UETools_t6jl42k5
├── LICENSE
├── README.md
├── src
│   ├── Directory.Build.props
│   ├── UETools.Assets
│   │   ├── AssetRegistry.cs
│   │   ├── Enums
│   │   │   ├── AssetDependencies.EAssetRegistryDependency.cs
│   │   │   ├── AssetIdentifier.IdentifierField.cs
│   │   │   ├── EAssetRegistryVersion.cs
│   │   │   ├── ELocMetaVersion.cs
│   │   │   ├── ELocResVersion.cs
│   │   │   └── LocMetadataValue.ELocMetadataType.cs
│   │   ├── Interfaces
│   │   │   ├── Generic
│   │   │   │   └── IAssetData.cs
│   │   │   ├── IAssetData.cs
│   │   │   └── IAssetFile.cs
│   │   ├── Internal
│   │   │   ├── Asset
│   │   │   │   ├── CompressedChunk.cs
│   │   │   │   ├── EngineVersion.cs
│   │   │   │   ├── GatherableTextData.cs
│   │   │   │   ├── GenerationInfo.cs
│   │   │   │   ├── LocMetadataObject.cs
│   │   │   │   ├── LocMetadataValue.cs
│   │   │   │   ├── PackageFileSummary.cs
│   │   │   │   ├── TextSourceData.cs
│   │   │   │   └── TextSourceSiteContext.cs
│   │   │   ├── Localization
│   │   │   │   ├── DictionaryExtensions.cs
│   │   │   │   ├── LocalizationKey.cs
│   │   │   │   ├── LocalizationString.cs
│   │   │   │   ├── LocalizationTable.cs
│   │   │   │   └── LocalizedEntry.cs
│   │   │   └── Registry
│   │   │       ├── AssetData.cs
│   │   │       ├── AssetDataOldFormat.cs
│   │   │       ├── AssetDependencies.cs
│   │   │       ├── AssetIdentifier.cs
│   │   │       └── AssetPackageData.cs
│   │   ├── LocMetaAsset.cs
│   │   ├── LocResAsset.cs
│   │   ├── README.md
│   │   ├── TextAsset.cs
│   │   ├── UAssetAsset.cs
│   │   ├── UETools.Assets.csproj
│   │   └── VorbisBankAsset.cs
│   ├── UETools.Core
│   │   ├── AutomaticVersionProvider.cs
│   │   ├── Collections
│   │   │   ├── TArray.cs
│   │   │   ├── TMap.cs
│   │   │   └── TRange.cs
│   │   ├── CustomVersionContainer.CustomVersion.cs
│   │   ├── CustomVersionContainer.EnumCustomVersion.cs
│   │   ├── CustomVersionContainer.GuidCustomVersion.cs
│   │   ├── CustomVersionContainer.cs
│   │   ├── DataSegment.cs
│   │   ├── EPackageFlags.cs
│   │   ├── EnumAttributesExtensions.cs
│   │   ├── Enums
│   │   │   ├── CustomVersionSerializationFormat.cs
│   │   │   ├── DateTimeStyle.cs
│   │   │   ├── FormatArgumentType.cs
│   │   │   ├── RoundingMode.cs
│   │   │   ├── TextFlag.cs
│   │   │   ├── TextGender.cs
│   │   │   ├── TextHistoryType.cs
│   │   │   ├── TransformType.cs
│   │   │   └── UE4Version.cs
│   │   ├── FArchive.CodeGen.cs
│   │   ├── FArchive.Readers.cs
│   │   ├── FArchive.Tables.cs
│   │   ├── FArchive.cs
│   │   ├── FName.cs
│   │   ├── FString.Boilerplate.cs
│   │   ├── FString.cs
│   │   ├── FText.cs
│   │   ├── HexString.cs
│   │   ├── HistoryTypes
│   │   │   ├── ArgumentFormat.cs
│   │   │   ├── AsCurrency.cs
│   │   │   ├── AsDate.cs
│   │   │   ├── AsDateTime.cs
│   │   │   ├── AsNumber.cs
│   │   │   ├── AsPercent.cs
│   │   │   ├── AsTime.cs
│   │   │   ├── Base.cs
│   │   │   ├── FFormatArgumentData.cs
│   │   │   ├── FFormatArgumentValue.cs
│   │   │   ├── FNumberFormattingOptions.cs
│   │   │   ├── FTextHistory.cs
│   │   │   ├── FormatNumber.cs
│   │   │   ├── NamedFormat.cs
│   │   │   ├── None.cs
│   │   │   ├── OrderedFormat.cs
│   │   │   ├── StringTableEntry.cs
│   │   │   └── Transform.cs
│   │   ├── Interfaces
│   │   │   ├── Generic
│   │   │   │   ├── IUnrealReadable.cs
│   │   │   │   └── IUnrealTable.cs
│   │   │   ├── IUnrealLocalizationProvider.cs
│   │   │   ├── IUnrealReadable.cs
│   │   │   ├── IUnrealSerializable.cs
│   │   │   ├── IUnrealTable.cs
│   │   │   ├── IUnrealValueReader.cs
│   │   │   └── IVersionProvider.cs
│   │   ├── LinkedTypeAttribute.cs
│   │   ├── MD5Hash.cs
│   │   ├── MemoryReader.cs
│   │   ├── NameEntrySerialized.cs
│   │   ├── NameTable.cs
│   │   ├── NotDeserializedException.cs
│   │   ├── README.md
│   │   ├── SHA1Hash.cs
│   │   ├── StreamExtensions.Copyrighted.cs
│   │   ├── StreamExtensions.cs
│   │   ├── StringHelper.cs
│   │   ├── UETools.Core.csproj
│   │   ├── UnrealAssetFileAttribute.cs
│   │   ├── UnrealException.cs
│   │   ├── UnrealTable.cs
│   │   └── UnrealTableAttribute.cs
│   ├── UETools.Objects
│   │   ├── Classes
│   │   │   ├── AssetImportData.cs
│   │   │   ├── DataTable.cs
│   │   │   ├── Internal
│   │   │   │   ├── ByteBulkData.cs
│   │   │   │   ├── StripDataFlags.cs
│   │   │   │   ├── UClass.cs
│   │   │   │   ├── UField.cs
│   │   │   │   ├── UFunction.cs
│   │   │   │   ├── UObject.cs
│   │   │   │   └── UStruct.cs
│   │   │   ├── LevelSequence.cs
│   │   │   ├── Material.cs
│   │   │   ├── StringTable.cs
│   │   │   ├── TaggedObject.cs
│   │   │   ├── Texture.cs
│   │   │   ├── Texture2D.TexturePlatformData.Texture2DMipMap.cs
│   │   │   ├── Texture2D.TexturePlatformData.cs
│   │   │   └── Texture2D.cs
│   │   ├── Enums
│   │   │   ├── EBulkDataFlags.cs
│   │   │   ├── EClassFlags.cs
│   │   │   ├── EFontHinting.cs
│   │   │   ├── EFontLoadingPolicy.cs
│   │   │   ├── EFunctionFlags.cs
│   │   │   ├── EObjectFlags.cs
│   │   │   ├── EPixelFormat.cs
│   │   │   ├── RichCurveKey.InterpMode.cs
│   │   │   ├── RichCurveKey.TangentMode.cs
│   │   │   └── RichCurveKey.TangentWeightMode.cs
│   │   ├── Interfaces
│   │   │   ├── IProperty.cs
│   │   │   └── IUnrealStruct.cs
│   │   ├── KismetVM
│   │   │   ├── BlueprintReader.cs
│   │   │   ├── CodeSkipSize.cs
│   │   │   ├── Enums
│   │   │   │   ├── EBlueprintTextLiteralType.cs
│   │   │   │   ├── ECastToken.cs
│   │   │   │   ├── EEventType.cs
│   │   │   │   └── EExprToken.cs
│   │   │   ├── Instructions
│   │   │   │   ├── ArrayGetByRef.cs
│   │   │   │   ├── Assignments
│   │   │   │   │   ├── Let.cs
│   │   │   │   │   ├── LetBool.cs
│   │   │   │   │   ├── LetDelegate.cs
│   │   │   │   │   ├── LetMulticastDelegate.cs
│   │   │   │   │   ├── LetObj.cs
│   │   │   │   │   ├── LetToken.cs
│   │   │   │   │   ├── LetValueOnPersistentFrame.cs
│   │   │   │   │   └── LetWeakObjPtr.cs
│   │   │   │   ├── Casts
│   │   │   │   │   ├── CastToken.cs
│   │   │   │   │   ├── CrossInterfaceCast.cs
│   │   │   │   │   ├── DynamicCast.cs
│   │   │   │   │   ├── InterfaceToObjCast.cs
│   │   │   │   │   ├── MetaCast.cs
│   │   │   │   │   ├── ObjToInterfaceCast.cs
│   │   │   │   │   └── PrimitiveCast.cs
│   │   │   │   ├── Constants
│   │   │   │   │   ├── ByteConst.cs
│   │   │   │   │   ├── ConstToken.cs
│   │   │   │   │   ├── False.cs
│   │   │   │   │   ├── FloatConst.cs
│   │   │   │   │   ├── InstanceDelegate.cs
│   │   │   │   │   ├── Int64Const.cs
│   │   │   │   │   ├── IntConst.cs
│   │   │   │   │   ├── IntConstByte.cs
│   │   │   │   │   ├── IntOne.cs
│   │   │   │   │   ├── IntZero.cs
│   │   │   │   │   ├── NameConst.cs
│   │   │   │   │   ├── NoInterface.cs
│   │   │   │   │   ├── NoObject.cs
│   │   │   │   │   ├── ObjectConst.cs
│   │   │   │   │   ├── RotationConst.cs
│   │   │   │   │   ├── SkipOffsetConst.cs
│   │   │   │   │   ├── SoftObjectConst.cs
│   │   │   │   │   ├── StringConst.cs
│   │   │   │   │   ├── TextConst.cs
│   │   │   │   │   ├── TransformConst.cs
│   │   │   │   │   ├── True.cs
│   │   │   │   │   ├── UInt64Const.cs
│   │   │   │   │   ├── UnicodeStringConst.cs
│   │   │   │   │   └── VectorConst.cs
│   │   │   │   ├── ControlFlow
│   │   │   │   │   ├── Calls
│   │   │   │   │   │   ├── CallMath.cs
│   │   │   │   │   │   ├── CallToken.cs
│   │   │   │   │   │   ├── Contexts
│   │   │   │   │   │   │   ├── ClassContext.cs
│   │   │   │   │   │   │   ├── Context.cs
│   │   │   │   │   │   │   ├── ContextToken.cs
│   │   │   │   │   │   │   ├── Context_FailSilent.cs
│   │   │   │   │   │   │   ├── InterfaceContext.cs
│   │   │   │   │   │   │   └── StructMemberContext.cs
│   │   │   │   │   │   ├── FinalFunction.cs
│   │   │   │   │   │   ├── LocalFinalFunction.cs
│   │   │   │   │   │   ├── LocalVirtualFunction.cs
│   │   │   │   │   │   └── VirtualFunction.cs
│   │   │   │   │   ├── ComputedJump.cs
│   │   │   │   │   ├── Delegate
│   │   │   │   │   │   ├── AddMulticastDelegate.cs
│   │   │   │   │   │   ├── BindDelegate.cs
│   │   │   │   │   │   ├── CallMulticastDelegate.cs
│   │   │   │   │   │   ├── ClearMulticastDelegate.cs
│   │   │   │   │   │   └── RemoveMulticastDelegate.cs
│   │   │   │   │   ├── Jump.cs
│   │   │   │   │   ├── JumpIfNot.cs
│   │   │   │   │   ├── PopExecutionFlow.cs
│   │   │   │   │   ├── PopExecutionFlowIfNot.cs
│   │   │   │   │   ├── PushExecutionFlow.cs
│   │   │   │   │   ├── Return.cs
│   │   │   │   │   ├── Skip.cs
│   │   │   │   │   └── SwitchValue.cs
│   │   │   │   ├── DeprecatedOp4A.cs
│   │   │   │   ├── Editor
│   │   │   │   │   ├── Assert.cs
│   │   │   │   │   ├── Breakpoint.cs
│   │   │   │   │   ├── InstrumentationEvent.cs
│   │   │   │   │   ├── Tracepoint.cs
│   │   │   │   │   └── WireTracepoint.cs
│   │   │   │   ├── EndOfScript.cs
│   │   │   │   ├── ItemList
│   │   │   │   │   ├── ArrayConst.cs
│   │   │   │   │   ├── CollectionToken.cs
│   │   │   │   │   ├── Ends
│   │   │   │   │   │   ├── EndArray.cs
│   │   │   │   │   │   ├── EndArrayConst.cs
│   │   │   │   │   │   ├── EndFunctionParms.cs
│   │   │   │   │   │   ├── EndMap.cs
│   │   │   │   │   │   ├── EndMapConst.cs
│   │   │   │   │   │   ├── EndParmValue.cs
│   │   │   │   │   │   ├── EndSet.cs
│   │   │   │   │   │   ├── EndSetConst.cs
│   │   │   │   │   │   ├── EndStructConst.cs
│   │   │   │   │   │   └── EndToken.cs
│   │   │   │   │   ├── MapConst.cs
│   │   │   │   │   ├── SetArray.cs
│   │   │   │   │   ├── SetConst.cs
│   │   │   │   │   ├── SetMap.cs
│   │   │   │   │   ├── SetSet.cs
│   │   │   │   │   └── StructConst.cs
│   │   │   │   ├── Nothing.cs
│   │   │   │   ├── Self.cs
│   │   │   │   ├── Transform.cs
│   │   │   │   └── Variables
│   │   │   │       ├── DefaultVariable.cs
│   │   │   │       ├── InstanceVariable.cs
│   │   │   │       ├── LocalOutVariable.cs
│   │   │   │       ├── LocalVariable.cs
│   │   │   │       └── VariableToken.cs
│   │   │   ├── Token.cs
│   │   │   ├── TokenFactory.cs
│   │   │   └── TokenList.cs
│   │   ├── Package
│   │   │   ├── ExportTable.cs
│   │   │   ├── Extensions.cs
│   │   │   ├── ImportTable.cs
│   │   │   ├── ObjectExport.cs
│   │   │   ├── ObjectImport.cs
│   │   │   ├── ObjectReference.cs
│   │   │   ├── ObjectResource.cs
│   │   │   ├── PackageIndex.cs
│   │   │   └── ResolvedObjectReference.cs
│   │   ├── Property
│   │   │   ├── ArrayProperty.cs
│   │   │   ├── BoolProperty.cs
│   │   │   ├── ByteProperty.cs
│   │   │   ├── ClassProperty.cs
│   │   │   ├── DelegateProperty.cs
│   │   │   ├── DoubleProperty.cs
│   │   │   ├── EnumProperty.cs
│   │   │   ├── FieldPathProperty.cs
│   │   │   ├── FloatProperty.cs
│   │   │   ├── Int16Property.cs
│   │   │   ├── Int64Property.cs
│   │   │   ├── Int8Property.cs
│   │   │   ├── IntProperty.cs
│   │   │   ├── InterfaceProperty.cs
│   │   │   ├── LazyObjectProperty.cs
│   │   │   ├── MapProperty.cs
│   │   │   ├── MulticastDelegateProperty.cs
│   │   │   ├── MulticastInlineDelegateProperty.cs
│   │   │   ├── MulticastSparseDelegateProperty.cs
│   │   │   ├── NameProperty.cs
│   │   │   ├── ObjectProperty.cs
│   │   │   ├── PropertyCollectionBase.cs
│   │   │   ├── SetProperty.cs
│   │   │   ├── SoftClassProperty.cs
│   │   │   ├── SoftObjectProperty.cs
│   │   │   ├── StrProperty.cs
│   │   │   ├── StructProperty.cs
│   │   │   ├── TextProperty.cs
│   │   │   ├── UInt16Property.cs
│   │   │   ├── UInt32Property.cs
│   │   │   ├── UInt64Property.cs
│   │   │   └── UProperty.cs
│   │   ├── PropertyFactory.cs
│   │   ├── PropertyTag.EPropertyType.cs
│   │   ├── PropertyTag.cs
│   │   ├── README.md
│   │   ├── Structures
│   │   │   ├── Box.cs
│   │   │   ├── Box2D.cs
│   │   │   ├── ClothLODData.cs
│   │   │   ├── Color.cs
│   │   │   ├── ColorMaterialInput.cs
│   │   │   ├── DateTime.cs
│   │   │   ├── ExpressionInput.cs
│   │   │   ├── FieldPath.cs
│   │   │   ├── FontCharacter.cs
│   │   │   ├── FontData.cs
│   │   │   ├── FrameNumber.cs
│   │   │   ├── GameplayTagContainer.cs
│   │   │   ├── Guid.cs
│   │   │   ├── IntPoint.cs
│   │   │   ├── IntVector.cs
│   │   │   ├── LevelSequenceBindingReferences.cs
│   │   │   ├── LevelSequenceObjectReferenceMap.cs
│   │   │   ├── LinearColor.cs
│   │   │   ├── MaterialAttributesInput.cs
│   │   │   ├── MaterialInput.cs
│   │   │   ├── MaterialInputType.cs
│   │   │   ├── Matrix.cs
│   │   │   ├── MeshToMeshVertData.cs
│   │   │   ├── MovieSceneFrameRange.cs
│   │   │   ├── PerPlatformProperty.cs
│   │   │   ├── Plane.cs
│   │   │   ├── PointerToUberGraphFrame.cs
│   │   │   ├── Quat.cs
│   │   │   ├── RichCurveKey.cs
│   │   │   ├── Rotator.cs
│   │   │   ├── ScalarMaterialInput.cs
│   │   │   ├── SkeletalMeshSamplingLODBuiltData.cs
│   │   │   ├── SmartName.cs
│   │   │   ├── SoftClassPath.cs
│   │   │   ├── SoftObjectPath.cs
│   │   │   ├── TwoVectors.cs
│   │   │   ├── Vector.cs
│   │   │   ├── Vector2D.cs
│   │   │   ├── Vector2MaterialInput.cs
│   │   │   ├── Vector4.cs
│   │   │   └── VectorMaterialInput.cs
│   │   └── UETools.Objects.csproj
│   ├── UETools.Pak
│   │   ├── AesPakCryptoProvider.cs
│   │   ├── CompressedBlocksExtension.cs
│   │   ├── DirectoryReader.cs
│   │   ├── Enums
│   │   │   ├── ECompressionFlags.cs
│   │   │   ├── EPakEntryFlags.cs
│   │   │   ├── PakInfoSize.cs
│   │   │   └── PakVersion.cs
│   │   ├── FileSystemEntry.cs
│   │   ├── Interfaces
│   │   │   ├── IAesKeyProvider.cs
│   │   │   └── IEntry.cs
│   │   ├── NotPakFileException.cs
│   │   ├── PakCompressedBlock.cs
│   │   ├── PakEncryptedException.cs
│   │   ├── PakEntry.cs
│   │   ├── PakFile.cs
│   │   ├── PakFileIndex.cs
│   │   ├── PakInfo.cs
│   │   ├── PakMemoryPool.PakMemoryArrayOwner.cs
│   │   ├── PakMemoryPool.cs
│   │   ├── PakVFS.cs
│   │   ├── README.md
│   │   ├── UETools.Pak.csproj
│   │   └── UnrealCompression.cs
│   ├── UETools.TypeFactory
│   │   ├── Factory.cs
│   │   ├── Generic
│   │   │   └── Factory.cs
│   │   ├── README.md
│   │   ├── TypeCollector.cs
│   │   ├── TypeFactory.cs
│   │   └── UETools.TypeFactory.csproj
│   └── UETools.sln
└── version.json

```

`LICENSE`:

```
                   GNU LESSER GENERAL PUBLIC LICENSE
                       Version 3, 29 June 2007

 Copyright (C) 2007 Free Software Foundation, Inc. <https://fsf.org/>
 Everyone is permitted to copy and distribute verbatim copies
 of this license document, but changing it is not allowed.


  This version of the GNU Lesser General Public License incorporates
the terms and conditions of version 3 of the GNU General Public
License, supplemented by the additional permissions listed below.

  0. Additional Definitions.

  As used herein, "this License" refers to version 3 of the GNU Lesser
General Public License, and the "GNU GPL" refers to version 3 of the GNU
General Public License.

  "The Library" refers to a covered work governed by this License,
other than an Application or a Combined Work as defined below.

  An "Application" is any work that makes use of an interface provided
by the Library, but which is not otherwise based on the Library.
Defining a subclass of a class defined by the Library is deemed a mode
of using an interface provided by the Library.

  A "Combined Work" is a work produced by combining or linking an
Application with the Library.  The particular version of the Library
with which the Combined Work was made is also called the "Linked
Version".

  The "Minimal Corresponding Source" for a Combined Work means the
Corresponding Source for the Combined Work, excluding any source code
for portions of the Combined Work that, considered in isolation, are
based on the Application, and not on the Linked Version.

  The "Corresponding Application Code" for a Combined Work means the
object code and/or source code for the Application, including any data
and utility programs needed for reproducing the Combined Work from the
Application, but excluding the System Libraries of the Combined Work.

  1. Exception to Section 3 of the GNU GPL.

  You may convey a covered work under sections 3 and 4 of this License
without being bound by section 3 of the GNU GPL.

  2. Conveying Modified Versions.

  If you modify a copy of the Library, and, in your modifications, a
facility refers to a function or data to be supplied by an Application
that uses the facility (other than as an argument passed when the
facility is invoked), then you may convey a copy of the modified
version:

   a) under this License, provided that you make a good faith effort to
   ensure that, in the event an Application does not supply the
   function or data, the facility still operates, and performs
   whatever part of its purpose remains meaningful, or

   b) under the GNU GPL, with none of the additional permissions of
   this License applicable to that copy.

  3. Object Code Incorporating Material from Library Header Files.

  The object code form of an Application may incorporate material from
a header file that is part of the Library.  You may convey such object
code under terms of your choice, provided that, if the incorporated
material is not limited to numerical parameters, data structure
layouts and accessors, or small macros, inline functions and templates
(ten or fewer lines in length), you do both of the following:

   a) Give prominent notice with each copy of the object code that the
   Library is used in it and that the Library and its use are
   covered by this License.

   b) Accompany the object code with a copy of the GNU GPL and this license
   document.

  4. Combined Works.

  You may convey a Combined Work under terms of your choice that,
taken together, effectively do not restrict modification of the
portions of the Library contained in the Combined Work and reverse
engineering for debugging such modifications, if you also do each of
the following:

   a) Give prominent notice with each copy of the Combined Work that
   the Library is used in it and that the Library and its use are
   covered by this License.

   b) Accompany the Combined Work with a copy of the GNU GPL and this license
   document.

   c) For a Combined Work that displays copyright notices during
   execution, include the copyright notice for the Library among
   these notices, as well as a reference directing the user to the
   copies of the GNU GPL and this license document.

   d) Do one of the following:

       0) Convey the Minimal Corresponding Source under the terms of this
       License, and the Corresponding Application Code in a form
       suitable for, and under terms that permit, the user to
       recombine or relink the Application with a modified version of
       the Linked Version to produce a modified Combined Work, in the
       manner specified by section 6 of the GNU GPL for conveying
       Corresponding Source.

       1) Use a suitable shared library mechanism for linking with the
       Library.  A suitable mechanism is one that (a) uses at run time
       a copy of the Library already present on the user's computer
       system, and (b) will operate properly with a modified version
       of the Library that is interface-compatible with the Linked
       Version.

   e) Provide Installation Information, but only if you would otherwise
   be required to provide such information under section 6 of the
   GNU GPL, and only to the extent that such information is
   necessary to install and execute a modified version of the
   Combined Work produced by recombining or relinking the
   Application with a modified version of the Linked Version. (If
   you use option 4d0, the Installation Information must accompany
   the Minimal Corresponding Source and Corresponding Application
   Code. If you use option 4d1, you must provide the Installation
   Information in the manner specified by section 6 of the GNU GPL
   for conveying Corresponding Source.)

  5. Combined Libraries.

  You may place library facilities that are a work based on the
Library side by side in a single library together with other library
facilities that are not Applications and are not covered by this
License, and convey such a combined library under terms of your
choice, if you do both of the following:

   a) Accompany the combined library with a copy of the same work based
   on the Library, uncombined with any other library facilities,
   conveyed under the terms of this License.

   b) Give prominent notice with the combined library that part of it
   is a work based on the Library, and explaining where to find the
   accompanying uncombined form of the same work.

  6. Revised Versions of the GNU Lesser General Public License.

  The Free Software Foundation may publish revised and/or new versions
of the GNU Lesser General Public License from time to time. Such new
versions will be similar in spirit to the present version, but may
differ in detail to address new problems or concerns.

  Each version is given a distinguishing version number. If the
Library as you received it specifies that a certain numbered version
of the GNU Lesser General Public License "or any later version"
applies to it, you have the option of following the terms and
conditions either of that published version or of any later version
published by the Free Software Foundation. If the Library as you
received it does not specify a version number of the GNU Lesser
General Public License, you may choose any version of the GNU Lesser
General Public License ever published by the Free Software Foundation.

  If the Library as you received it specifies that a proxy can decide
whether future versions of the GNU Lesser General Public License shall
apply, that proxy's public statement of acceptance of any version is
permanent authorization for you to choose that version for the
Library.

```

`README.md`:

```md
# UETools

Set of libraries for reading the Unreal Engine 4 binary asset format.

Example usage:
```cs
using UETools.Core.Enums;
using UETools.Pak;
using UETools.Assets;

class Program
{
    static void Main(string[] args)
    {
        using (var reader = PakVFS.OpenAt(path))
        {
            foreach (var (name, entry) in reader.AbsoluteIndex)
            {
                using (var data = entry.Read())
                {
                    data.Version = UE4Version.VER_UE4_AUTOMATIC_VERSION;
                    UAssetAsset? asset = default;
                    data.Read(ref asset);
                    if(asset.IsValid)
                    {

                    }
                }
            }
        }
    }
}
```

```

`src/Directory.Build.props`:

```props
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="15.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <PropertyGroup>
    <RepoRootPath>$([System.IO.Path]::GetFullPath('$(MSBuildThisFileDirectory)..\'))</RepoRootPath>
    <BaseIntermediateOutputPath>$(RepoRootPath)obj\$(MSBuildProjectName)\</BaseIntermediateOutputPath>
    <BaseOutputPath Condition=" '$(BaseOutputPath)' == '' ">$(RepoRootPath)bin\$(MSBuildProjectName)\</BaseOutputPath>

    <LangVersion>preview</LangVersion>
    <GenerateDocumentationFile>true</GenerateDocumentationFile>
 
    <Company>UETools</Company>
    <Authors>UETools</Authors>
    <RepositoryUrl>https://github.com/UETools/UETools</RepositoryUrl>
    <PackageLicenseExpression>LGPL-3.0-or-later</PackageLicenseExpression>
    <PublishRepositoryUrl>true</PublishRepositoryUrl>
    <EmbedUntrackedSources>true</EmbedUntrackedSources>

    <IncludeSymbols>true</IncludeSymbols>
    <SymbolPackageFormat>snupkg</SymbolPackageFormat>

    <NoWarn>1591</NoWarn>
  </PropertyGroup>

  <ItemGroup>
    <!-- All projects use nullability attributes. File itself had ifdefs for specific versions. -->
    <PackageReference Include="Nullable" Version="*" PrivateAssets="all" />

    <PackageReference Include="Nerdbank.GitVersioning" Version="*" PrivateAssets="all" />
    <!--<PackageReference Include="Microsoft.CodeAnalysis.FxCopAnalyzers" Version="*" PrivateAssets="all" />-->
    <!--<PackageReference Include="ClrHeapAllocationAnalyzer" Version="2.0.0" PrivateAssets="all" />-->
    <!--<PackageReference Include="ErrorProne.NET.Structs" Version="0.2.0-beta.7" PrivateAssets="all" />-->
  </ItemGroup>
</Project>

```

`src/UETools.Assets/AssetRegistry.cs`:

```cs
using System;
using System.Collections.Generic;
using UETools.Assets.Enums;
using UETools.Assets.Interfaces;
using UETools.Assets.Internal.Registry;
using UETools.Core;
using UETools.Core.Interfaces;

namespace UETools.Assets
{
    [UnrealAssetFile(FileName, false)]
    public sealed class AssetRegistry : IUnrealSerializable
    {
        private static Guid AssetRegistryVersionGuid = new Guid(0x717F9EE7, 0x493A, 0xE9B0, 0x32, 0x91, 0xB3, 0x88, 0x07, 0x81, 0x38, 0x1B);

        public const string FileName = "AssetRegistry.bin";

        public List<IAssetData> Assets => _assets; 
        public Dictionary<FName, AssetPackageData> PackageData => _packageData;
        public Dictionary<AssetIdentifier, AssetDependencies> Dependencies => _assetDependencies;

        /// <inheritdoc />
        /// <exception cref="UnrealException">Thrown when <see cref="FArchive.Version"/> is not set.</exception>
        public FArchive Serialize(FArchive archive)
        {
            if (archive.Version == 0)
                throw new UnrealException($"{nameof(FArchive.Version)} is uninitialized, needs to be set for cooked assets.");

            ReadVersion(archive);

            // AssetData format was changed from FStrings to FNames
            if (_version >= EAssetRegistryVersion.ChangedAssetData)
            {
                long stringTableOffset = 0;
                archive.Read(ref stringTableOffset);
                var currentOffset = archive.Tell();
                archive.Seek(stringTableOffset);
                NameTable? names = default;
                archive.Read(ref names);
                archive.Seek(currentOffset);
                List<AssetData>? assets = default;
                archive.Read(ref assets);
                _assets = new List<IAssetData>(assets);
            }
            else
            {
                List<AssetDataOldFormat>? assets = default;
                archive.Read(ref assets);
                _assets = new List<IAssetData>(assets);
            }

            // TODO: Fixup the dependencies indexes into the references to actual dependency
            archive.Read(ref _assetDependencies)
                   .Read(ref _packageData);
            return archive;
        }

        private void ReadVersion(FArchive reader)
        {
            Guid guid = default;
            reader.Read(ref guid);
            if (guid == AssetRegistryVersionGuid)
            {
                reader.ReadUnsafe(ref _version);
            }
            else
            {
                _version = EAssetRegistryVersion.PreVersioning;
                reader.Seek(0);
            }
            reader.AssetVersion = (int)_version;
        }

        private EAssetRegistryVersion _version;
        private List<IAssetData> _assets = null!;
        private Dictionary<AssetIdentifier, AssetDependencies> _assetDependencies = null!;
        private Dictionary<FName, AssetPackageData> _packageData = null!;
    }
}

```

`src/UETools.Assets/Enums/AssetDependencies.EAssetRegistryDependency.cs`:

```cs
namespace UETools.Assets.Internal.Registry
{
    public partial class AssetDependencies
    {
        enum EAssetRegistryDependency
        {
            /// <summary>
            /// Dependencies which are required for correct usage of the source asset, and must be loaded at the same time.
            /// </summary>
            Hard = 0,
            /// <summary>
            /// Dependencies which don't need to be loaded for the object to be used (i.e. soft object paths).
            /// </summary>
            Soft = 1,
            /// <summary>
            /// References to specific SearchableNames inside a package.
            /// </summary>
            SearchableName = 2,
            /// <summary>
            /// Indirect management references, these are set through recursion for Primary Assets that manage packages or other primary assets.
            /// </summary>
            SoftManage = 3,
            /// <summary>
            /// Reference that says one object directly manages another object, set when Primary Assets manage things explicitly.
            /// </summary>
            HardManage = 4,
            /// <summary>
            /// 
            /// </summary>
            None = 5,

            MaxCount = 6
        }
    }
}

```

`src/UETools.Assets/Enums/AssetIdentifier.IdentifierField.cs`:

```cs
using System;

namespace UETools.Assets.Internal.Registry
{
    partial class AssetIdentifier
    {
        [Flags]
        private enum IdentifierField : byte
        {
            None = 0,
            PackageName = 1,
            AssetType = 2,
            ObjectName = 4,
            ValueName = 8
        }
    }
}

```

`src/UETools.Assets/Enums/EAssetRegistryVersion.cs`:

```cs
//using UnrealTools.CodeGen.Attributes;

namespace UETools.Assets.Enums
{
    //[EnumUpdater("https://docs.unrealengine.com/en-US/API/Runtime/AssetRegistry/FAssetRegistryVersion/Type/index.html")]
    public enum EAssetRegistryVersion : int
    {
        /// <summary>
        /// From before file versioning was implemented.
        /// </summary>
        PreVersioning = 0,
        /// <summary>
        /// The first version of the runtime asset registry to include file versioning.
        /// </summary>
        HardSoftDependencies,
        /// <summary>
        /// Added FAssetRegistryState and support for piecemeal serialization.
        /// </summary>
        AddAssetRegistryState,
        /// <summary>
        /// AssetData serialization format changed, versions before this are not readable.
        /// </summary>
        ChangedAssetData,
        /// <summary>
        /// Removed MD5 hash from package data.
        /// </summary>
        RemovedMD5Hash,
        /// <summary>
        /// Added hard/soft manage references.
        /// </summary>
        AddedHardManage,
        /// <summary>
        /// Added MD5 hash of cooked package to package data.
        /// </summary>
        AddedCookedMD5Hash,

        /// <summary>
        /// Last version implemented.
        /// </summary>
        VersionPlusOne,
        /// <summary>
        /// Latest version implemented.
        /// </summary>
        LatestVersion = VersionPlusOne - 1
    }
}

```

`src/UETools.Assets/Enums/ELocMetaVersion.cs`:

```cs
namespace UETools.Assets.Enums
{
    /// <summary>
    /// Data versions for <see cref="LocMetaAsset">LocMeta</see> files.
    /// </summary>
    internal enum ELocMetaVersion : byte
    {
        /// <summary>
        /// Initial format.
        /// </summary>
        Initial = 0,

        LatestPlusOne,
        Latest = LatestPlusOne - 1
    }
}

```

`src/UETools.Assets/Enums/ELocResVersion.cs`:

```cs
namespace UETools.Assets.Enums
{
    /// <summary>
    /// Data versions for <see cref="LocResAsset">LocRes</see> files.
    /// </summary>
    internal enum ELocResVersion : byte
    {
        /// <summary>
        /// Legacy format file.
        /// </summary>
        /// <remarks>Will be missing the magic number.</remarks>
        Legacy = 0,
        /// <summary>
        /// Compact format file.
        /// </summary>
        /// <remarks>Strings are stored in a LUT to avoid duplication.</remarks>
        Compact = 1,
        /// <summary>
        /// Namespaces/keys are pre-hashed, we know the number of elements up-front, and the number of references for each string in the LUT (to allow stealing).
        /// </summary>
        Optimized = 2,

        LatestPlusOne,
        Latest = LatestPlusOne - 1
    }
}

```

`src/UETools.Assets/Enums/LocMetadataValue.ELocMetadataType.cs`:

```cs
namespace UETools.Assets.Internal.Asset
{
    internal partial class LocMetadataValue
    {
        internal enum ELocMetadataType : int
        {
            None,
            Boolean,
            String,
            Array,
            Object,
        }
    }
}
```

`src/UETools.Assets/Interfaces/Generic/IAssetData.cs`:

```cs
using System.Collections.Generic;
using UETools.Core;

namespace UETools.Assets.Interfaces.Generic
{
    public interface IAssetData<T> where T : notnull
    {
        T ObjectPath { get; }
        T PackagePath { get; }
        T AssetClass { get; }
        T PackageName { get; }
        T AssetName { get; }
        Dictionary<T, FString> TagsAndValues { get; }

        List<int> ChunkIDs { get; }
        EPackageFlags PackageFlags { get; }
    }
}

```

`src/UETools.Assets/Interfaces/IAssetData.cs`:

```cs
using UETools.Assets.Interfaces.Generic;
using UETools.Core;

namespace UETools.Assets.Interfaces
{
    public interface IAssetData : IAssetData<FName>
    {
    }
}

```

`src/UETools.Assets/Interfaces/IAssetFile.cs`:

```cs
using System.Text.RegularExpressions;
using UETools.Core;

namespace UETools.Assets.Interfaces
{
    internal interface IAssetFile
    {
        public Regex Filename { get; }

        bool IsValidMagic(FArchive reader);
    }
}
```

`src/UETools.Assets/Internal/Asset/CompressedChunk.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Text;
using UETools.Core;
using UETools.Core.Interfaces;

namespace UETools.Assets.Internal.Asset
{
    internal class CompressedChunk : IUnrealSerializable
    {
        public int UncompressedOffset { get => _uncompressedOffset; set => _uncompressedOffset = value; }
        public int UncompressedSize { get => _uncompressedSize; set => _uncompressedSize = value; }
        public int CompressedOffset { get => _compressedOffset; set => _compressedOffset = value; }
        public int CompressedSize { get => _compressedSize; set => _compressedSize = value; }

        public FArchive Serialize(FArchive archive)
            => archive.Read(ref _uncompressedOffset)
                      .Read(ref _uncompressedSize)
                      .Read(ref _compressedOffset)
                      .Read(ref _compressedSize);

        private int _uncompressedOffset;
        private int _uncompressedSize;
        private int _compressedOffset;
        private int _compressedSize;
    }
}

```

`src/UETools.Assets/Internal/Asset/EngineVersion.cs`:

```cs
using UETools.Core;
using UETools.Core.Interfaces;

namespace UETools.Assets.Internal.Asset
{
    public class EngineVersion : IUnrealSerializable
    {
        public EngineVersion() { }
        public EngineVersion(ushort major, ushort minor, ushort patch, uint changelist, string branch)
        {
            _major = major;
            _minor = minor;
            _patch = patch;
            _changelist = changelist;
            _branch = branch;
        }

        public FArchive Serialize(FArchive archive)
            => archive.Read(ref _major)
                      .Read(ref _minor)
                      .Read(ref _patch)
                      .Read(ref _changelist)
                      .Read(ref _branch);

        private ushort _major;
        private ushort _minor;
        private ushort _patch;
        private uint _changelist;
        private FString _branch = null!;
    }
}

```

`src/UETools.Assets/Internal/Asset/GatherableTextData.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Text;
using UETools.Core;
using UETools.Core.Interfaces;

namespace UETools.Assets.Internal.Asset
{
    internal class GatherableTextData : IUnrealSerializable
    {
        // TODO: Verify! GatherableTextData might not be implemented properly since I didn't have any samples using it.
        public FArchive Serialize(FArchive archive)
            => archive.Read(ref _namespaceName)
                      .Read(ref _sourceData)
                      .Read(ref _sourceSiteContexts);

        private FString _namespaceName = null!;
        private TextSourceData _sourceData = null!;
        private List<TextSourceSiteContext> _sourceSiteContexts = null!;
    }
}

```

`src/UETools.Assets/Internal/Asset/GenerationInfo.cs`:

```cs
using UETools.Core;
using UETools.Core.Interfaces;

namespace UETools.Assets.Internal.Asset
{
    internal struct GenerationInfo : IUnrealSerializable
    {
        public FArchive Serialize(FArchive archive)
            => archive.Read(ref _exportCount)
                      .Read(ref _nameCount);

        private int _exportCount;
        private int _nameCount;
    }
}

```

`src/UETools.Assets/Internal/Asset/LocMetadataObject.cs`:

```cs
using System.Collections.Generic;
using UETools.Core;
using UETools.Core.Interfaces;

namespace UETools.Assets.Internal.Asset
{
    internal class LocMetadataObject : IUnrealSerializable
    {
        public FArchive Serialize(FArchive archive) => archive.Read(ref _values);

        private Dictionary<FString, LocMetadataValue> _values = null!;
    }
}
```

`src/UETools.Assets/Internal/Asset/LocMetadataValue.cs`:

```cs
using System;
using System.Collections.Generic;
using UETools.Core;
using UETools.Core.Interfaces;

namespace UETools.Assets.Internal.Asset
{
    internal partial class LocMetadataValue : IUnrealSerializable
    {
        // TODO: FIX
        public FArchive Serialize(FArchive archive)
        {
            archive.ReadUnsafe(ref _metaDataType);
            switch (_metaDataType)
            {
                case ELocMetadataType.Boolean:
                    {
                        bool b = false;
                        archive.Read(ref b);
                    }
                    break;
                case ELocMetadataType.String:
                    {
                        FString? b = default;
                        archive.Read(ref b);
                    }
                    break;
                case ELocMetadataType.Array:
                    {
                        List<LocMetadataValue>? ar = default;
                        archive.Read(ref ar);
                    }
                    break;
                case ELocMetadataType.Object:
                    {
                        LocMetadataObject? b = default;
                        archive.Read(ref b);
                    }
                    break;
                default:
                    throw new NotImplementedException($"{_metaDataType} not implemented.");
            }
            return archive;
        }

        ELocMetadataType _metaDataType;
    }
}
```

`src/UETools.Assets/Internal/Asset/PackageFileSummary.cs`:

```cs
using System;
using System.Collections.Generic;
using UETools.Core;
using UETools.Core.Enums;
using UETools.Core.Interfaces;

namespace UETools.Assets.Internal.Asset
{
    internal partial class PackageFileSummary : IUnrealSerializable
    {
        private const long PACKAGE_TAG_MAGIC = 0x9E2A83C1;
        private const long PACKAGE_TAG_MAGIC_SWAPPED = 0xC1832A9E;

        public CustomVersionContainer CustomVersionContainer { get; private set; } = null!;

        public bool IsUnversioned { get; private set; }
        public bool IsAssetFile => _tag == PACKAGE_TAG_MAGIC;

        public int NameCount => _nameCount;
        public int NameOffset => _nameOffset;
        public int GatherableTextDataCount => _gatherableTextDataCount;
        public int GatherableTextDataOffset => _gatherableTextDataOffset;
        public int ExportCount => _exportCount;
        public int ExportOffset => _exportOffset;
        public int ImportCount => _importCount;
        public int ImportOffset => _importOffset;
        public int DependsOffset => _dependsOffset;
        public int SoftPackageReferencesCount => _softPackageReferencesCount;
        public int SoftPackageReferencesOffset => _softPackageReferencesOffset;

        public FArchive Serialize(FArchive archive)
        {
            const long MinimumPackageSize = 32;
            if (archive.Length() < MinimumPackageSize)
                return archive;

            archive.Read(ref _tag);
            if (!IsAssetFile)
                return archive;

            const int CurrentLegacyFileVersion = -7;
            int LegacyFileVersion = 0;
            archive.Read(ref LegacyFileVersion);
            if (LegacyFileVersion < 0)
            {
                if (LegacyFileVersion < CurrentLegacyFileVersion)
                {
                    _fileVersionUE4 = 0;
                    _fileVersionLicenseeUE4 = 0;
                    return archive;
                }

                if (LegacyFileVersion != -4)
                {
                    int LegacyUE3Version = 0;
                    // skip legacy ue3 version
                    archive.Read(ref LegacyUE3Version);
                }

                archive.ReadUnsafe(ref _fileVersionUE4);
                archive.Read(ref _fileVersionLicenseeUE4);

                if (LegacyFileVersion <= -2)
                {
                    CustomVersionContainer = new CustomVersionContainer(CustomVersionFormatForArchive(LegacyFileVersion));
                    CustomVersionContainer.Serialize(archive);
                }

                if (_fileVersionUE4 == 0 && _fileVersionLicenseeUE4 == 0)
                {
                    IsUnversioned = true;
                    if (archive.Version == 0)
                    {
                        // Set latest
                        archive.Version = _fileVersionUE4 = UE4Version.VER_UE4_AUTOMATIC_VERSION;
                        _fileVersionLicenseeUE4 = 0;
                    }
                    else
                        _fileVersionUE4 = archive.Version; // version read from config file
                }
            }
            else
            {
                _fileVersionUE4 = 0;
                _fileVersionLicenseeUE4 = 0;
            }

            archive.Read(ref _totalHeaderSize)
                   .Read(ref _folderName)
                   .ReadUnsafe(ref _packageFlags)
                   .Read(ref _nameCount)
                   .Read(ref _nameOffset);

            if ((_packageFlags & EPackageFlags.FilterEditorOnly) == 0 && _fileVersionUE4 >= UE4Version.VER_UE4_ADDED_PACKAGE_SUMMARY_LOCALIZATION_ID)
                archive.Read(ref _localizationId);

            if (_fileVersionUE4 >= UE4Version.VER_UE4_SERIALIZE_TEXT_IN_PACKAGES)
            {
                archive.Read(ref _gatherableTextDataCount)
                       .Read(ref _gatherableTextDataOffset);
            }

            archive.Read(ref _exportCount)
                   .Read(ref _exportOffset)
                   .Read(ref _importCount)
                   .Read(ref _importOffset)
                   .Read(ref _dependsOffset);

            if (_fileVersionUE4 < UE4Version.VER_UE4_OLDEST_LOADABLE_PACKAGE)
                return archive;

            if (_fileVersionUE4 >= UE4Version.VER_UE4_ADD_STRING_ASSET_REFERENCES_MAP)
            {
                archive.Read(ref _softPackageReferencesCount)
                       .Read(ref _softPackageReferencesOffset);
            }

            if (_fileVersionUE4 >= UE4Version.VER_UE4_ADDED_SEARCHABLE_NAMES)
                archive.Read(ref _searchableNamesOffset);

            archive.Read(ref _thumbnailTableOffset)
                   .Read(ref _guid)
                   .Read(ref _generations);

            if (_fileVersionUE4 >= UE4Version.VER_UE4_ENGINE_VERSION_OBJECT)
                archive.Read(ref _savedByEngineVersion);
            else
            {
                uint changelist = 0;
                archive.Read(ref changelist);
                _savedByEngineVersion = new EngineVersion(4, 0, 0, changelist, string.Empty);
            }

            if (_fileVersionUE4 >= UE4Version.VER_UE4_PACKAGE_SUMMARY_HAS_COMPATIBLE_ENGINE_VERSION)
                archive.Read(ref _compatibleWithEngineVersion);
            else
                _compatibleWithEngineVersion = _savedByEngineVersion;

            archive.Read(ref _compressionFlags)
                   .Read(ref _compressedChunks);
            if (_compressedChunks.Count > 0)
                throw new NotSupportedException("Package Level Compression is not supported by UE4 anymore.");

            archive.Read(ref _packageSource);

            // No longer used: List of additional packages that are needed to be cooked for this package (ie streaming levels)
            // Keeping the serialization code for backwards compatibility without bumping the package version
            List<FString>? _additionalPackagesToCook = default;
            archive.Read(ref _additionalPackagesToCook);

            if (LegacyFileVersion > -7)
            {
                // Texture allocations no longer supported.
                int NumTextureAllocations = 0;
                archive.Read(ref NumTextureAllocations);
            }

            archive.Read(ref _assetRegistryDataOffset)
                   .Read(ref _bulkDataStartOffset);

            if (_fileVersionUE4 >= UE4Version.VER_UE4_WORLD_LEVEL_INFO)
                archive.Read(ref _worldTileInfoDataOffset);

            if (_fileVersionUE4 >= UE4Version.VER_UE4_CHANGED_CHUNKID_TO_BE_AN_ARRAY_OF_CHUNKIDS)
                archive.Read(ref _chunkIDs);
            else if (_fileVersionUE4 >= UE4Version.VER_UE4_ADDED_CHUNKID_TO_ASSETDATA_AND_UPACKAGE)
                archive.Read(ref _chunkIDs, 1);

            if (_fileVersionUE4 >= UE4Version.VER_UE4_PRELOAD_DEPENDENCIES_IN_COOKED_EXPORTS)
            {
                archive.Read(ref _preloadDependencyCount)
                       .Read(ref _preloadDependencyOffset);
            }

            return archive;
        }

        private CustomVersionSerializationFormat CustomVersionFormatForArchive(int LegacyVersion)
        {
            var CustomVersionFormat = CustomVersionSerializationFormat.Unknown;
            if (LegacyVersion == -2)
            {
                CustomVersionFormat = CustomVersionSerializationFormat.Enums;
            }
            else if (LegacyVersion < -2 && LegacyVersion >= -5)
            {
                CustomVersionFormat = CustomVersionSerializationFormat.Guids;
            }
            else if (LegacyVersion < -5)
            {
                CustomVersionFormat = CustomVersionSerializationFormat.Optimized;
            }

            if (CustomVersionFormat == CustomVersionSerializationFormat.Unknown)
                throw new UnrealException("Unknown CustomVersionFormat encountered.");

            return CustomVersionFormat;
        }

        private uint _tag;
        private UE4Version _fileVersionUE4;
        private int _fileVersionLicenseeUE4;
        private int _totalHeaderSize;
        private EPackageFlags _packageFlags;
        private FString _folderName = null!;
        private int _nameCount;
        private int _nameOffset;
        private int _gatherableTextDataCount;
        private int _gatherableTextDataOffset;
        private int _exportCount;
        private int _exportOffset;
        private int _importCount;
        private int _importOffset;
        private int _dependsOffset;
        private int _softPackageReferencesCount;
        private int _softPackageReferencesOffset;
        private int _searchableNamesOffset;
        private int _thumbnailTableOffset;
        private Guid _guid;
        private List<GenerationInfo> _generations = null!;
        private EngineVersion _savedByEngineVersion = null!;
        private EngineVersion _compatibleWithEngineVersion = null!;
        private uint _compressionFlags;
        private List<CompressedChunk> _compressedChunks = null!;
        private uint _packageSource;
        private int _assetRegistryDataOffset;
        private long _bulkDataStartOffset;
        private int _worldTileInfoDataOffset;
        private List<int> _chunkIDs = null!;
        private int _preloadDependencyCount;
        private int _preloadDependencyOffset;

        private FString _localizationId = null!;
    }
}

```

`src/UETools.Assets/Internal/Asset/TextSourceData.cs`:

```cs
using UETools.Core;
using UETools.Core.Interfaces;

namespace UETools.Assets.Internal.Asset
{
    internal class TextSourceData : IUnrealSerializable
    {
        public FArchive Serialize(FArchive archive)
            => archive.Read(ref _sourceString)
                      .Read(ref _sourceStringMetaData);

        private FString _sourceString = null!;
        private LocMetadataObject _sourceStringMetaData = null!;
    }
}
```

`src/UETools.Assets/Internal/Asset/TextSourceSiteContext.cs`:

```cs
using UETools.Core;
using UETools.Core.Interfaces;

namespace UETools.Assets.Internal.Asset
{
    internal class TextSourceSiteContext : IUnrealSerializable
    {
        public FArchive Serialize(FArchive archive)
            => archive.Read(ref _keyName)
                      .Read(ref _siteDescription)
                      .Read(ref _isEditorOnly)
                      .Read(ref _isOptional)
                      .Read(ref _infoMetaData)
                      .Read(ref _keyMetaData);

        private bool _isOptional;
        private bool _isEditorOnly;
        private FString _keyName = null!;
        private FString _siteDescription = null!;
        private LocMetadataObject _infoMetaData = null!;
        private LocMetadataObject _keyMetaData = null!;
    }
}
```

`src/UETools.Assets/Internal/Localization/DictionaryExtensions.cs`:

```cs
using System.Collections.Generic;
using System.Diagnostics.CodeAnalysis;
using UETools.TypeFactory;

namespace UETools.Assets.Internal.Localization
{
    internal static class DictionaryExtensions
    {
        [return: NotNull]
        internal static TValue FindOrAdd<TKey, TValue>(this IDictionary<TKey, TValue> dict, TKey key)
            where TValue : class, new()
            where TKey : notnull
        {
            if (!dict.TryGetValue(key, out var val))
            {
                val = Factory<TValue>.CreateInstance();
                dict.Add(key, val);
            }
            return val;
        }
    }
}
```

`src/UETools.Assets/Internal/Localization/LocalizationKey.cs`:

```cs
using System;
using System.Diagnostics.CodeAnalysis;
using UETools.Assets.Enums;
using UETools.Core;
using UETools.Core.Interfaces;

namespace UETools.Assets.Internal.Localization
{
    internal class LocalizationKey : IUnrealSerializable, IEquatable<string>, IEquatable<LocalizationKey>
    {
        public static implicit operator LocalizationKey(string value) => new LocalizationKey(value);

        public LocalizationKey() { }
        public LocalizationKey(FString value) => _value = value;

        public FArchive Serialize(FArchive archive)
        {
            if (archive.AssetVersion >= (int)ELocResVersion.Optimized)
                archive.Read(ref _hash);

            return archive.Read(ref _value);
        }

        public override string ToString() => _value.ToString();
        public override int GetHashCode() => _value.GetHashCode();

        public bool Equals([AllowNull] string other)
        {
            if (other is null) return false;
            if (_value is null) NotDeserializedException.Throw();

            return _value.ToString() == other;
        }

        public bool Equals([AllowNull] LocalizationKey other)
        {
            if (other is null) return false;
            if (_value is null) NotDeserializedException.Throw();

            return _value == other._value;
        }

        private int _hash;
        private FString _value = null!;
    }
}

```

`src/UETools.Assets/Internal/Localization/LocalizationString.cs`:

```cs
using UETools.Core;
using UETools.Core.Interfaces;

namespace UETools.Assets.Internal.Localization
{
    internal class LocalizationString : IUnrealSerializable
    {
        public FString Value => _value;
        public LocalizationString() : this(null!) { }
        public LocalizationString(FString value) => _value = value;

        public FArchive Serialize(FArchive archive)
            => archive.Read(ref _value)
                      .Read(ref _refCount);

        private FString _value;
        private int _refCount;
    }
}
```

`src/UETools.Assets/Internal/Localization/LocalizationTable.cs`:

```cs
using System;
using System.CodeDom.Compiler;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using UETools.Assets.Enums;
using UETools.Core;
using UETools.Core.Interfaces;

namespace UETools.Assets.Internal.Localization
{
    internal class LocalizationTable : IUnrealSerializable, IUnrealReadable
    {
        public FArchive Serialize(FArchive archive)
        {
            var VersionNumber = (ELocResVersion)archive.AssetVersion;
            var IsCompact = VersionNumber >= ELocResVersion.Compact;
            List<LocalizationString> LocalizedStringArray = new List<LocalizationString>();
            if (IsCompact)
            {
                long localizedStringArrayOffset = 0;
                archive.Read(ref localizedStringArrayOffset);
                if (localizedStringArrayOffset != -1)
                {
                    var offset = archive.Tell();
                    archive.Seek(localizedStringArrayOffset);
                    if (VersionNumber >= ELocResVersion.Optimized)
                    {
                        archive.Read(ref LocalizedStringArray!);
                    }
                    else
                    {
                        List<FString>? tempStringArray = default;
                        archive.Read(ref tempStringArray);
                        LocalizedStringArray.AddRange(tempStringArray.Select(t => new LocalizationString(t)));
                    }
                    archive.Seek(offset);
                }
            }

            if (VersionNumber >= ELocResVersion.Optimized)
            {
                uint entryCount = 0;
                archive.Read(ref entryCount);
            }
            int namespaceCount = 0;
            archive.Read(ref namespaceCount);
            for (var i = 0; i < namespaceCount; i++)
            {
                LocalizationKey? _namespace = default;
                archive.Read(ref _namespace);
                var KeyTable = _namespaces.FindOrAdd(_namespace);
                int keyCount = 0;
                archive.Read(ref keyCount);
                for (var j = 0; j < keyCount; j++)
                {
                    LocalizationKey? _key = default;
                    archive.Read(ref _key);
                    var Entry = KeyTable.FindOrAdd(_key);

                    int hash = 0;
                    archive.Read(ref hash);
                    Entry.SourceStringHash = hash;
                    if (IsCompact)
                    {
                        int localizedStringIndex = 0;
                        archive.Read(ref localizedStringIndex);
                        if (localizedStringIndex > -1 && localizedStringIndex < LocalizedStringArray.Count)
                        {
                            Entry.LocalizedString = LocalizedStringArray[localizedStringIndex].Value;
                        }
                    }
                    else
                    {
                        FString? localizedString = default;
                        archive.Read(ref localizedString);
                        Entry.LocalizedString = localizedString;
                    }
                }
            }
            return archive;
        }

        public void ReadTo(IndentedTextWriter writer)
        {
            foreach (var name in _namespaces.OrderBy(kv => kv.Key.ToString()))
            {
                writer.WriteLine($"BEGIN {name.Key}");
                writer.Indent++;
                foreach (var key in name.Value.OrderBy(kv => kv.Key.ToString()))
                {
                    writer.WriteLine(key.Value.ToString());
                }
                writer.Indent--;
                writer.WriteLine($"END {name.Key}");
                writer.WriteLine();
            }
        }

        public LocalizedEntry? Get(string key, string id)
        {
            if (key is null) throw new ArgumentNullException(nameof(key));
            if (id is null) throw new ArgumentNullException(nameof(id));

            return _namespaces.TryGetValue(key, out var value) && value.TryGetValue(id, out var entry) ? entry : null;
        }

        private Dictionary<LocalizationKey, Dictionary<LocalizationKey, LocalizedEntry>> _namespaces = new Dictionary<LocalizationKey, Dictionary<LocalizationKey, LocalizedEntry>>();
    }
}

```

`src/UETools.Assets/Internal/Localization/LocalizedEntry.cs`:

```cs
using UETools.Core;

namespace UETools.Assets.Internal.Localization
{
    public class LocalizedEntry
    {
        public FString LocResID { get; internal set; } = null!;
        public int SourceStringHash { get; internal set; }
        public FString LocalizedString { get; internal set; } = null!;

        public override string ToString() => LocalizedString.ToString();
    }
}

```

`src/UETools.Assets/Internal/Registry/AssetData.cs`:

```cs
using System.Collections.Generic;
using UETools.Assets.Interfaces;
using UETools.Core;
using UETools.Core.Enums;
using UETools.Core.Interfaces;

namespace UETools.Assets.Internal.Registry
{
    public class AssetData : IAssetData, IUnrealSerializable
    {
        public FName ObjectPath => _objectPath;
        public FName PackagePath => _packagePath;
        public FName AssetClass => _assetClass;
        public FName PackageName => _packageName;
        public FName AssetName => _assetName;
        public Dictionary<FName, FString> TagsAndValues => _tagsAndValues;
        public List<int> ChunkIDs => _chunkIDs;
        public EPackageFlags PackageFlags => _packageFlags;

        public FArchive Serialize(FArchive archive)
        {
            archive.Read(ref _objectPath)
                   .Read(ref _packagePath)
                   .Read(ref _assetClass)
                   .Read(ref _packageName)
                   .Read(ref _assetName)
                   .Read(ref _tagsAndValues);

            if (archive.Version >= UE4Version.VER_UE4_CHANGED_CHUNKID_TO_BE_AN_ARRAY_OF_CHUNKIDS)
                archive.Read(ref _chunkIDs);
            else if (archive.Version >= UE4Version.VER_UE4_ADDED_CHUNKID_TO_ASSETDATA_AND_UPACKAGE)
                archive.Read(ref _chunkIDs, 1);
            else
                _chunkIDs = new List<int>();

            if (archive.Version >= UE4Version.VER_UE4_COOKED_ASSETS_IN_EDITOR_SUPPORT)
                archive.ReadUnsafe(ref _packageFlags);

            return archive;
        }

        private FName _objectPath = null!;
        private FName _packagePath = null!;
        private FName _assetClass = null!;
        private FName _packageName = null!;
        private FName _assetName = null!;
        private Dictionary<FName, FString> _tagsAndValues = null!;

        private List<int> _chunkIDs = null!;
        private EPackageFlags _packageFlags;
    }
}

```

`src/UETools.Assets/Internal/Registry/AssetDataOldFormat.cs`:

```cs
using System.Collections.Generic;
using System.Linq;
using UETools.Assets.Interfaces;
using UETools.Assets.Interfaces.Generic;
using UETools.Core;
using UETools.Core.Enums;
using UETools.Core.Interfaces;

namespace UETools.Assets.Internal.Registry
{
    public class AssetDataOldFormat : IAssetData, IAssetData<FString>, IUnrealSerializable
    {
        public FName ObjectPath { get => _objectPath; set => _objectPath = value.Name; }
        public FName PackagePath { get => _packagePath; set => _packagePath = value.Name; }
        public FName AssetClass { get => _assetClass; set => _assetClass = value.Name; }
        public FName PackageName { get => _packageName; set => _packageName = value.Name; }
        public FName AssetName { get => _assetName; set => _assetName = value.Name; }
        public Dictionary<FName, FString> TagsAndValues { get => _tagsAndValues.ToDictionary(kv => new FName(kv.Key), kv => kv.Value); set => _tagsAndValues = value.ToDictionary(kv => kv.Key.Name, kv => kv.Value); }

        public FString GroupNames { get => _groupNames; set => _groupNames = value; }

        FString IAssetData<FString>.ObjectPath => _objectPath;
        FString IAssetData<FString>.PackagePath => _packagePath;
        FString IAssetData<FString>.AssetClass => _assetClass;
        FString IAssetData<FString>.PackageName => _packageName;
        FString IAssetData<FString>.AssetName => _assetName;
        Dictionary<FString, FString> IAssetData<FString>.TagsAndValues => _tagsAndValues;

        public List<int> ChunkIDs => _chunkIDs;
        public EPackageFlags PackageFlags => _packageFlags;

        public FArchive Serialize(FArchive archive)
        {
            archive.Read(ref _objectPath)
                   .Read(ref _packagePath)
                   .Read(ref _assetClass)
                   .Read(ref _groupNames)
                   .Read(ref _packageName)
                   .Read(ref _assetName)
                   .Read(ref _tagsAndValues);

            if (archive.Version >= UE4Version.VER_UE4_CHANGED_CHUNKID_TO_BE_AN_ARRAY_OF_CHUNKIDS)
                archive.Read(ref _chunkIDs);
            else if (archive.Version >= UE4Version.VER_UE4_ADDED_CHUNKID_TO_ASSETDATA_AND_UPACKAGE)
                archive.Read(ref _chunkIDs, 1);
            else
                _chunkIDs = new List<int>();

            if (archive.Version >= UE4Version.VER_UE4_COOKED_ASSETS_IN_EDITOR_SUPPORT)
                archive.ReadUnsafe(ref _packageFlags);

            return archive;
        }

        private FString _objectPath = null!;
        private FString _packagePath = null!;
        private FString _assetClass = null!;
        private FString _packageName = null!;
        private FString _assetName = null!;
        private Dictionary<FString, FString> _tagsAndValues = null!;

        private List<int> _chunkIDs = null!;
        private EPackageFlags _packageFlags;

        private FString _groupNames = null!;
    }
}

```

`src/UETools.Assets/Internal/Registry/AssetDependencies.cs`:

```cs
using System.Collections.Generic;
using UETools.Core;
using UETools.Core.Interfaces;

namespace UETools.Assets.Internal.Registry
{
    public partial class AssetDependencies : IUnrealSerializable
    {
        public FArchive Serialize(FArchive archive)
        {
            List<int>? depCounts = default;
            return archive.Read(ref depCounts, (int)EAssetRegistryDependency.MaxCount)
                
                  .Read(ref _hardDependencies, depCounts[(int)EAssetRegistryDependency.Hard])
                  .Read(ref _softDependencies, depCounts[(int)EAssetRegistryDependency.Soft])
                  .Read(ref _searchableNameDependencies, depCounts[(int)EAssetRegistryDependency.SearchableName])
                  .Read(ref _softManageDependencies, depCounts[(int)EAssetRegistryDependency.SoftManage])
                  .Read(ref _hardManageDependencies, depCounts[(int)EAssetRegistryDependency.HardManage])
                  .Read(ref _noneDependencies, depCounts[(int)EAssetRegistryDependency.None]);
        }

        private List<int> _hardDependencies = null!;
        private List<int> _softDependencies = null!;
        private List<int> _searchableNameDependencies = null!;
        private List<int> _softManageDependencies = null!;
        private List<int> _hardManageDependencies = null!;
        private List<int> _noneDependencies = null!;
    }
}

```

`src/UETools.Assets/Internal/Registry/AssetIdentifier.cs`:

```cs
using System.Diagnostics;
using System.Diagnostics.CodeAnalysis;
using UETools.Core;
using UETools.Core.Interfaces;

namespace UETools.Assets.Internal.Registry
{
    [DebuggerDisplay("{PackageName.Name.ToString()}")]
    public partial class AssetIdentifier : IUnrealSerializable
    {
        [DisallowNull]
        public FName? PackageName
        {
            get => _packageName;
            set
            {
                _packageName = value;
                _fieldBits |= IdentifierField.PackageName;
            }
        }
        [DisallowNull]
        public FName? PrimaryAssetType
        {
            get => _primaryAssetType;
            set
            {
                _primaryAssetType = value;
                _fieldBits |= IdentifierField.AssetType;
            }
        }
        [DisallowNull]
        public FName? ObjectName
        {
            get => _objectName;
            set
            {
                _objectName = value;
                _fieldBits |= IdentifierField.ObjectName;
            }
        }
        [DisallowNull]
        public FName? ValueName
        {
            get => _valueName;
            set
            {
                _valueName = value;
                _fieldBits |= IdentifierField.ValueName;
            }
        }

        public FArchive Serialize(FArchive archive)
        {
            archive.ReadUnsafe(ref _fieldBits);

            if ((_fieldBits & IdentifierField.PackageName) != 0)
                archive.Read(ref _packageName);
            if ((_fieldBits & IdentifierField.AssetType) != 0)
                archive.Read(ref _primaryAssetType);
            if ((_fieldBits & IdentifierField.ObjectName) != 0)
                archive.Read(ref _objectName);
            if ((_fieldBits & IdentifierField.ValueName) != 0)
                archive.Read(ref _valueName);

            return archive;
        }

        private IdentifierField _fieldBits;
        private FName? _packageName;
        private FName? _primaryAssetType;
        private FName? _objectName;
        private FName? _valueName;
    }
}

```

`src/UETools.Assets/Internal/Registry/AssetPackageData.cs`:

```cs
using System;
using UETools.Assets.Enums;
using UETools.Core;
using UETools.Core.Interfaces;

namespace UETools.Assets.Internal.Registry
{
    public sealed class AssetPackageData : IUnrealSerializable
    {
        public FArchive Serialize(FArchive archive)
        {
            var ver = (EAssetRegistryVersion)archive.AssetVersion;
            archive.Read(ref _diskSize)
                   .Read(ref _packageGuid);
            if (ver >= EAssetRegistryVersion.AddedCookedMD5Hash || ver < EAssetRegistryVersion.RemovedMD5Hash)
                archive.Read(ref _hash);

            return archive;
        }

        private long _diskSize;
        private Guid _packageGuid;
        private MD5Hash _hash;
    }
}

```

`src/UETools.Assets/LocMetaAsset.cs`:

```cs
using System;
using UETools.Assets.Enums;
using UETools.Core;
using UETools.Core.Interfaces;

namespace UETools.Assets
{
    [UnrealAssetFile(".locmeta")]
    public sealed class LocMetaAsset : IUnrealSerializable
    {
        static Guid LocMetaMagic = new Guid(0xA14CEE4F, 0x4868, 0x8355, 0x6C, 0x4C, 0x46, 0xBD, 0x70, 0xDA, 0x50, 0x7C);

        private bool ReadVersion(FArchive reader, out ELocMetaVersion version)
        {
            Guid MagicNumber = default;
            reader.Read(ref MagicNumber);
            version = ELocMetaVersion.Initial;
            if (MagicNumber == LocMetaMagic)
            {
                reader.ReadUnsafe(ref version);
                reader.AssetVersion = (int)version;
                return true;
            }
            return false;
        }

        public FArchive Serialize(FArchive archive)
        {
            if (ReadVersion(archive, out var version))
            {
                archive.Read(ref _nativeCulture)
                       .Read(ref _nativeLocRes);
            }
            return archive;
        }

        private FString _nativeCulture = null!;
        private FString _nativeLocRes = null!;
    }
}

```

`src/UETools.Assets/LocResAsset.cs`:

```cs
using System;
using System.CodeDom.Compiler;
using System.IO;
using UETools.Assets.Enums;
using UETools.Assets.Internal.Localization;
using UETools.Core;
using UETools.Core.Interfaces;

namespace UETools.Assets
{
    [UnrealAssetFile(".locres")]
    public sealed class LocResAsset : IUnrealSerializable, IUnrealReadable, IUnrealLocalizationProvider
    {
        static Guid LocResMagic = new Guid(0x7574140E, 0x4A67, 0xFC03, 0x4A, 0x15, 0x90, 0x9D, 0xC3, 0x37, 0x7F, 0x1B);

        public FArchive Serialize(FArchive archive)
        {
            ReadVersion(archive);
            return archive.Read(ref _localizationTable);
        }

        private ELocResVersion ReadVersion(FArchive archive)
        {
            Guid MagicNumber = default;
            archive.Read(ref MagicNumber);
            var VersionNumber = ELocResVersion.Legacy;
            if (MagicNumber == LocResMagic)
                archive.ReadUnsafe(ref VersionNumber);
            else
                archive.Seek(0); // legacy LocRes

            archive.AssetVersion = (int)VersionNumber;
            return VersionNumber;
        }

        public void ReadTo(IndentedTextWriter writer)
        {
            if (_localizationTable is null)
                NotDeserializedException.Throw();

            _localizationTable.ReadTo(writer);
        }

        public string? Get(string key, string id) => _localizationTable.Get(key, id)?.LocalizedString?.ToString();

        public static LocResAsset English { get; } = new LocResAsset();

        LocalizationTable _localizationTable = null!;
    }
}

```

`src/UETools.Assets/README.md`:

```md
# UETools.Assets

Implements deserialization of specific asset types.

```

`src/UETools.Assets/TextAsset.cs`:

```cs
using System;
using System.CodeDom.Compiler;
using System.Collections.Generic;
using System.IO;
using System.Runtime.InteropServices;
using System.Text;
using UETools.Core;
using UETools.Core.Interfaces;

namespace UETools.Assets
{
    [UnrealAssetFile(".bin")]
    [UnrealAssetFile(".h")]
    [UnrealAssetFile(".txt")]
    [UnrealAssetFile(".ini")]
    [UnrealAssetFile(".json")]
    [UnrealAssetFile(".uplugin")]
    [UnrealAssetFile(".uproject")]
    [UnrealAssetFile(".upluginmanifest")]
    public sealed class TextAsset : IUnrealSerializable, IUnrealReadable
    {
        public FArchive Serialize(FArchive archive) => archive.Read(ref _content, (int)archive.Length());

        public void ReadTo(IndentedTextWriter writer)
        {
            throw new NotImplementedException();
        }

        private Memory<byte> _content;
    }
}

```

`src/UETools.Assets/UAssetAsset.cs`:

```cs
using System;
using System.CodeDom.Compiler;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using UETools.Assets.Internal.Asset;
using UETools.Core;
using UETools.Core.Interfaces;
using UETools.Objects.Classes;
using UETools.Objects.Package;

namespace UETools.Assets
{
    [UnrealAssetFile(".uasset")]
    public sealed class UAssetAsset : IUnrealSerializable, IUnrealReadable
    {
        public bool IsValid => _summary.IsAssetFile;

        public IEnumerable<T> GetExportsOfType<T>() where T : TaggedObject => _exports.Items.Select(x => x.Object as T).OfType<T>();

        public FArchive Serialize(FArchive archive)
        {
            archive.Read(ref _summary);
            if (!IsValid)
                return archive;

            archive.Seek(_summary.NameOffset);
            _nameMap = new NameTable(_summary.NameCount);
            _nameMap.Serialize(archive);

            archive.Seek(_summary.ImportOffset);
            _imports = new ImportTable(_summary.ImportCount);
            _imports.Serialize(archive);

            archive.Seek(_summary.ExportOffset);
            _exports = new ExportTable(_summary.ExportCount);
            _exports.Serialize(archive);

            archive.Seek(_summary.SoftPackageReferencesOffset);
            archive.Read(ref _stringAssetReferences, _summary.SoftPackageReferencesCount);

            archive.Seek(_summary.GatherableTextDataOffset);
            archive.Read(ref _gatherableTextDataMap, _summary.GatherableTextDataCount);

            foreach (var imp in _imports.Items)
                imp.Fix(archive);
            foreach (var exp in _exports.Items)
                exp.Fix(archive);

            return archive;
        }

        private IEnumerable<ObjectExport> GetAssets() => _exports.GetAssets();

        public ObjectExport? GetClass() => _exports.GetClass();

        public void ReadTo(IndentedTextWriter writer)
        {
            var main = _exports.GetClass();
            if (main is null)
            {
                var assets = _exports.GetAssets();
                foreach(var asset in assets)
                {
                    writer.WriteLine($"Asset: {asset.FullName}");
                    asset.Object?.ReadTo(writer);
                }
            }
            else
                main.Object?.ReadTo(writer);

            var cdo = _exports.GetCDO();
            if (cdo is null)
                return;
            writer.WriteLine("<--- CDO --->");
            cdo.Object?.ReadTo(writer);
            return;
        }

        PackageFileSummary _summary = null!;
        NameTable _nameMap = null!;
        ImportTable _imports = null!;
        ExportTable _exports = null!;
        List<FString> _stringAssetReferences = null!;
        List<GatherableTextData> _gatherableTextDataMap = null!;
    }
}

```

`src/UETools.Assets/UETools.Assets.csproj`:

```csproj
<Project Sdk="Microsoft.NET.Sdk">

  <PropertyGroup>
    <TargetFrameworks>netstandard2.0;netstandard2.1;net5.0</TargetFrameworks>
    <Nullable>enable</Nullable>
    <PackageDescription>Implementation of serializers for specific Unreal Engine 4 asset types.</PackageDescription>
  </PropertyGroup>

  <ItemGroup>
    <ProjectReference Include="..\UETools.Core\UETools.Core.csproj" />
    <ProjectReference Include="..\UETools.Objects\UETools.Objects.csproj" />
  </ItemGroup>

  <ItemGroup>
    <Folder Include="Internal\VorbisBank\" />
  </ItemGroup>

</Project>

```

`src/UETools.Assets/VorbisBankAsset.cs`:

```cs
using System;
using System.CodeDom.Compiler;
using System.Collections.Generic;
using System.IO;
using System.Text;
using UETools.Core;
using UETools.Core.Interfaces;

namespace UETools.Assets
{
    // TODO: Implement
    [UnrealAssetFile(".bnk")]
    class VorbisBankAsset : IUnrealSerializable, IUnrealReadable
    {
        public FArchive Serialize(FArchive archive) => archive;

        public void ReadTo(IndentedTextWriter writer)
        {
        }
    }
}

```

`src/UETools.Core/AutomaticVersionProvider.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Text;
using UETools.Core.Enums;
using UETools.Core.Interfaces;

namespace UETools.Core
{
    public class AutomaticVersionProvider : IVersionProvider
    {
        public readonly static AutomaticVersionProvider Instance = new AutomaticVersionProvider();
        public UE4Version Version => UE4Version.VER_UE4_AUTOMATIC_VERSION;
        public CustomVersionContainer CustomVersion { get; } = new CustomVersionContainer(CustomVersionSerializationFormat.Latest);
        public int LicenseeVersion => 0;
    }
}

```

`src/UETools.Core/Collections/TArray.cs`:

```cs
using System;
using System.Collections.Generic;
using UETools.Core.Interfaces;

namespace UETools.Core.Collections
{
    class TArray<T> : List<T>, IUnrealSerializable
    {
        public FArchive Serialize(FArchive archive)
        {
            throw new NotImplementedException();
        }
    }
}

```

`src/UETools.Core/Collections/TMap.cs`:

```cs
using System;
using System.Collections.Generic;
using UETools.Core.Interfaces;

namespace UETools.Core.Collections
{
    class TMap<TKey, TValue> : Dictionary<TKey, TValue>, IUnrealSerializable where TKey : notnull
    {
        public FArchive Serialize(FArchive archive)
        {
            throw new NotImplementedException();
        }
    }
}

```

`src/UETools.Core/Collections/TRange.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Text;
using UETools.Core.Interfaces;

namespace UETools.Core.Collections
{
    public struct TRange<T> : IUnrealSerializable where T : IUnrealSerializable?, new()
    {
        public FArchive Serialize(FArchive archive)
            => archive.Read(ref _lowerBound)
                      .Read(ref _upperBound);

        TRangeBound _lowerBound;
        TRangeBound _upperBound;

        enum ERangeBoundTypes : byte
        {
            Exclusive,
            Inclusive,
            Open,
        }

        struct TRangeBound : IUnrealSerializable
        {
            public FArchive Serialize(FArchive archive)
                => archive.ReadUnsafe(ref _type)
                          .Read(ref _value);

            ERangeBoundTypes _type;
            T _value;
        }
    }
}

```

`src/UETools.Core/CustomVersionContainer.CustomVersion.cs`:

```cs
using System;
using UETools.Core.Interfaces;

namespace UETools.Core
{
    public partial class CustomVersionContainer
    {
        public class CustomVersion : IUnrealSerializable
        {
            public Guid Key => _key;
            public int Version => _version;
            public int ReferenceCount => 1;
            public FString FriendlyName { get; } = null!;

            public CustomVersion()
            {
            }
            public CustomVersion(Guid key, int version, string friendlyName)
            {
                _key = key;
                _version = version;
                FriendlyName = friendlyName;
            }
            public FArchive Serialize(FArchive archive)
                => archive.Read(ref _key)
                          .Read(ref _version);

            private Guid _key;
            private int _version;
        }
    }
}

```

`src/UETools.Core/CustomVersionContainer.EnumCustomVersion.cs`:

```cs
using System;
using System.Runtime.InteropServices;
using UETools.Core.Interfaces;

namespace UETools.Core
{
    public partial class CustomVersionContainer
    {
        class EnumCustomVersion : IUnrealSerializable
        {
            private Guid TagGuid
            {
                get
                {
                    Span<byte> bytes = stackalloc byte[16];
                    BitConverter.GetBytes(Tag).CopyTo(bytes.Slice(12));
                    return MemoryMarshal.Cast<byte, Guid>(bytes)[0];
                }
            }
            public int Tag => _tag;
            public int Version => _version;
            public FArchive Serialize(FArchive archive)
                => archive.Read(ref _tag)
                          .Read(ref _version);

            public static implicit operator CustomVersion(EnumCustomVersion ver) => new CustomVersion(ver.TagGuid, ver.Version, "EnumTag" + ver.Tag);

            private int _tag;
            private int _version;
        }
    }
}

```

`src/UETools.Core/CustomVersionContainer.GuidCustomVersion.cs`:

```cs
using System;
using UETools.Core.Interfaces;

namespace UETools.Core
{
    public partial class CustomVersionContainer
    {
        class GuidCustomVersion : IUnrealSerializable
        {
            public Guid Key => _key;
            public int Version => _version;
            public FString FriendlyName => _friendlyName;

            public FArchive Serialize(FArchive archive)
                => archive.Read(ref _key)
                          .Read(ref _version)
                          .Read(ref _friendlyName);

            public static implicit operator CustomVersion(GuidCustomVersion ver) => new CustomVersion(ver.Key, ver.Version, ver.FriendlyName);

            private Guid _key;
            private int _version;
            private FString _friendlyName = null!;
        }
    }
}

```

`src/UETools.Core/CustomVersionContainer.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using UETools.Core;
using UETools.Core.Enums;
using UETools.Core.Interfaces;

namespace UETools.Core
{
    public partial class CustomVersionContainer : IUnrealSerializable
    {
        public CustomVersionContainer(CustomVersionSerializationFormat format) => _type = format;

        internal List<CustomVersion?> Versions { get; set; } = null!;
        public FArchive Serialize(FArchive archive)
        {
            switch (_type)
            {
                case CustomVersionSerializationFormat.Guids:
                    {
                        List<GuidCustomVersion> _versions = default!;
                        archive.Read(ref _versions);
                        Versions = new List<CustomVersion?>(_versions.Cast<CustomVersion>());
                        break;
                    }
                case CustomVersionSerializationFormat.Enums:
                    {
                        List<EnumCustomVersion> _versions = default!;
                        archive.Read(ref _versions);
                        Versions = new List<CustomVersion?>(_versions.Cast<CustomVersion>());
                        break;
                    }
                case CustomVersionSerializationFormat.Optimized:
                    {
                        List<CustomVersion?> _versions = default!;
                        archive.Read(ref _versions);
                        Versions = _versions;
                        break;
                    }
                default:
                    throw new UnrealException($"{_type} custom version not implemented");
            }
            return archive;
        }

        private CustomVersionSerializationFormat _type;
    }
}

```

`src/UETools.Core/DataSegment.cs`:

```cs
using System;
using System.Buffers;
using System.Collections.Generic;

namespace UETools.Core
{
    public sealed class DataSegment : IDisposable
    {
        public DataSegment(IMemoryOwner<byte> data) : this(data, 0) { }
        private DataSegment(IMemoryOwner<byte> data, long runningIndex)
        {
            MemoryOwner = data;
            RunningIndex = runningIndex;
        }
        internal DataSegment(Memory<byte> data) : this(new NotOwnedOwner(data)) { }

        public IMemoryOwner<byte> MemoryOwner { get; }
        public long RunningIndex { get; private set; }
        public long Length => RunningIndex + MemoryOwner.Memory.Length;
        internal DataSegment? NextElement { get; private set; }

        public DataSegment Append(IMemoryOwner<byte> next) => NextElement is not null
                ? throw new InvalidOperationException("Can't append to segment already containing next element.")
                : (NextElement = new DataSegment(next, Length));
        public DataSegment Append(IEnumerable<IMemoryOwner<byte>> elements)
        {
            var segment = this;
            var enumerator = elements.GetEnumerator();
            while (enumerator.MoveNext())
            {
                var it = enumerator.Current;
                segment = segment.Append(it);
            }
            return segment;
        }

        public void Dispose()
        {
            MemoryOwner.Dispose();
            NextElement?.Dispose();
        }

        public byte[] ToArray() => ToArray(0, GetLastSegment().Length);
        public byte[] ToArray(long start) => ToArray(start, GetLastSegment().Length - start);
        public byte[] ToArray(long start, long length)
        {
            var dstOffset = 0;
            var data = new byte[length];
            var element = this;
            while (element is not null)
            {
                if (element.RunningIndex < start)
                {
                    if (element.Length > start)
                    {
                        dstOffset += element.CopyTo(data, dstOffset, (int)(start - element.RunningIndex));
                    }
                }
                else
                {
                    dstOffset += element.CopyTo(data, dstOffset);
                }
                element = element.NextElement;
            }
            return data;
        }

        private int CopyTo(byte[] data, int dstOffset) => CopyTo(data, dstOffset, 0);
        private int CopyTo(byte[] data, int dstOffset, int start)
        {
            var mem = MemoryOwner.Memory.Slice(start);
            mem.Span.CopyTo(new Span<byte>(data, dstOffset, mem.Length));
            return mem.Length;
        }
        internal DataSegment GetLastSegment() => NextElement?.GetLastSegment() ?? this;

        public void Tag(string tag) => Tags.Add(tag);
        public bool HasTag(string tag) => Tags.Contains(tag);

        internal List<string> Tags { get; } = new List<string>();

        private class NotOwnedOwner : IMemoryOwner<byte>
        {
            public NotOwnedOwner(Memory<byte> data) => Memory = data;

            public Memory<byte> Memory { get; }

            public void Dispose() { }
        }
    }
}

```

`src/UETools.Core/EPackageFlags.cs`:

```cs
using System;
//using UnrealTools.Core.CodeGeneration.Attributes;

namespace UETools.Core
{
    /// <summary>
    /// Flags of the package.
    /// </summary>
    /// <remarks>Should be kept in sync with <see href="https://github.com/EpicGames/UnrealEngine/blob/master/Engine/Source/Runtime/CoreUObject/Public/UObject/ObjectMacros.h#L102">EPackageFlags</see>.</remarks>
    [Flags]
    //[EnumUpdater("https://docs.unrealengine.com/en-US/API/Runtime/CoreUObject/UObject/EPackageFlags/index.html")]
    public enum EPackageFlags : uint
    {
        /// <summary>
        /// No flags.
        /// </summary>
        None = 0x00000000,
        /// <summary>
        /// Newly created package, not saved yet. In editor only.
        /// </summary>
        NewlyCreated = 0x00000001,
        /// <summary>
        /// Purely optional for clients.
        /// </summary>
        ClientOptional = 0x00000002,
        /// <summary>
        /// Only needed on the server side.
        /// </summary>
        ServerSideOnly = 0x00000004,
        /// <summary>
        /// This package is from "compiled in" classes.
        /// </summary>
        CompiledIn = 0x00000010,
        /// <summary>
        /// This package was loaded just for the purposes of diffing.
        /// </summary>
        ForDiffing = 0x00000020,
        /// <summary>
        /// This is editor-only package (for example: editor module script package).
        /// </summary>
        EditorOnly = 0x00000040,
        /// <summary>
        /// Developer module.
        /// </summary>
        Developer = 0x00000080,
        /// <summary>
        /// Contains map data (UObjects only referenced by a single ULevel) but is stored in a different package.
        /// </summary>
        ContainsMapData = 0x00004000,
        /// <summary>
        /// Client needs to download this package.
        /// </summary>
        Need = 0x00008000,
        /// <summary>
        /// Package is currently being compiled.
        /// </summary>
        Compiling = 0x00010000,
        /// <summary>
        /// Set if the package contains a ULevel / UWorld object.
        /// </summary>
        ContainsMap = 0x00020000,
        /// <summary>
        /// Set if the package contains any data to be gathered by localization.
        /// </summary>
        RequiresLocalizationGather = 0x00040000,
        /// <summary>
        /// Set if the archive serializing this package cannot use lazy loading.
        /// </summary>
        DisallowLazyLoading = 0x00080000,
        /// <summary>
        /// Set if the package was created for the purpose of PIE.
        /// </summary>
        PlayInEditor = 0x00100000,
        /// <summary>
        /// Package is allowed to contain UClass objects.
        /// </summary>
        ContainsScript = 0x00200000,
        /// <summary>
        /// Editor should not export asset in this package.
        /// </summary>
        DisallowExport = 0x00400000,
        /// <summary>
        /// This package is reloading in the cooker, try to avoid getting data we will never need. We won't save this package.
        /// </summary>
        ReloadingForCooker = 0x40000000,
        /// <summary>
        /// Package has editor-only data filtered.
        /// </summary>
        FilterEditorOnly = 0x80000000,

        /// <summary>
        /// Flag mask that indicates if this package is a package that exists in memory only.
        /// </summary>
        InMemoryOnly = CompiledIn | NewlyCreated
    }
}

```

`src/UETools.Core/EnumAttributesExtensions.cs`:

```cs
using System;
using System.Diagnostics.CodeAnalysis;
using System.Linq;
using System.Reflection;

namespace UETools.Core
{
    public static class EnumAttributesExtensions
    {
        public static TAttrib? GetAttribute<TAttrib, TEnum>(this TEnum value)
            where TAttrib : notnull, Attribute
            where TEnum : notnull, Enum
        {
            var enumType = typeof(TEnum);
            var fields = enumType.GetMember(value.ToString());
            return fields.FirstOrDefault()?.GetCustomAttribute<TAttrib>();
        }

        public static bool TryGetAttribute<TAttrib, TEnum>(this TEnum value, [NotNullWhen(true)] out TAttrib? attribute)
            where TAttrib : notnull, Attribute
            where TEnum : notnull, Enum
        {
            var enumType = typeof(TEnum);
            var fields = enumType.GetMember(value.ToString());
            attribute = fields.FirstOrDefault()?.GetCustomAttribute<TAttrib>();
            return attribute != null;
        }
    }
}

```

`src/UETools.Core/Enums/CustomVersionSerializationFormat.cs`:

```cs
namespace UETools.Core.Enums
{
    public enum CustomVersionSerializationFormat
    {
        Unknown,
        Guids,
        Enums,
        Optimized,

        // Add new versions above this comment
        CustomVersion_Automatic_Plus_One,
        Latest = CustomVersion_Automatic_Plus_One - 1
    }
}

```

`src/UETools.Core/Enums/DateTimeStyle.cs`:

```cs
namespace UETools.Core.Enums
{
    internal enum DateTimeStyle : byte
    {
        Default,
        Short,
        Medium,
        Long,
        Full,
        // Add new enum types at the end only! They are serialized by index.
    }
}
```

`src/UETools.Core/Enums/FormatArgumentType.cs`:

```cs
namespace UETools.Core.Enums
{
    internal enum FormatArgumentType : byte
    {
        Int,
        UInt,
        Float,
        Double,
        Text,
        Gender,

        // Add new enum types at the end only! They are serialized by index.
    };
}
```

`src/UETools.Core/Enums/RoundingMode.cs`:

```cs
namespace UETools.Core.Enums
{
    internal enum RoundingMode : byte
    {
        /** Rounds to the nearest place, equidistant ties go to the value which is closest to an even value: 1.5 becomes 2, 0.5 becomes 0 */
        HalfToEven,
        /** Rounds to nearest place, equidistant ties go to the value which is further from zero: -0.5 becomes -1.0, 0.5 becomes 1.0 */
        HalfFromZero,
        /** Rounds to nearest place, equidistant ties go to the value which is closer to zero: -0.5 becomes 0, 0.5 becomes 0. */
        HalfToZero,
        /** Rounds to the value which is further from zero, "larger" in absolute value: 0.1 becomes 1, -0.1 becomes -1 */
        FromZero,
        /** Rounds to the value which is closer to zero, "smaller" in absolute value: 0.1 becomes 0, -0.1 becomes 0 */
        ToZero,
        /** Rounds to the value which is more negative: 0.1 becomes 0, -0.1 becomes -1 */
        ToNegativeInfinity,
        /** Rounds to the value which is more positive: 0.1 becomes 1, -0.1 becomes 0 */
        ToPositiveInfinity,


        // Add new enum types at the end only! They are serialized by index.
    };
}
```

`src/UETools.Core/Enums/TextFlag.cs`:

```cs
namespace UETools.Core.Enums
{
    internal enum TextFlag
    {
        Transient = (1 << 0),
        CultureInvariant = (1 << 1),
        ConvertedProperty = (1 << 2),
        Immutable = (1 << 3),
        InitializedFromString = (1 << 4),
    }
}
```

`src/UETools.Core/Enums/TextGender.cs`:

```cs
namespace UETools.Core.Enums
{
    internal enum TextGender : byte
    {
        Masculine,
        Feminine,
        Neuter,
        // Add new enum types at the end only! They are serialized by index.
    }
}
```

`src/UETools.Core/Enums/TextHistoryType.cs`:

```cs
using UETools.Core.HistoryTypes;

namespace UETools.Core.Enums
{
    public enum TextHistoryType : sbyte
    {
        [LinkedType(typeof(FTextHistory.None))]
        None = -1,
        [LinkedType(typeof(FTextHistory.Base))]
        Base = 0,
        [LinkedType(typeof(FTextHistory.NamedFormat))]
        NamedFormat,
        [LinkedType(typeof(FTextHistory.OrderedFormat))]
        OrderedFormat,
        [LinkedType(typeof(FTextHistory.ArgumentFormat))]
        ArgumentFormat,
        [LinkedType(typeof(FTextHistory.AsNumber))]
        AsNumber,
        [LinkedType(typeof(FTextHistory.AsPercent))]
        AsPercent,
        [LinkedType(typeof(FTextHistory.AsCurrency))]
        AsCurrency,
        [LinkedType(typeof(FTextHistory.AsDate))]
        AsDate,
        [LinkedType(typeof(FTextHistory.AsTime))]
        AsTime,
        [LinkedType(typeof(FTextHistory.AsDateTime))]
        AsDateTime,
        [LinkedType(typeof(FTextHistory.Transform))]
        Transform,
        [LinkedType(typeof(FTextHistory.StringTableEntry))]
        StringTableEntry,

        // Add new enum types at the end only! They are serialized by index.
    };
}
```

`src/UETools.Core/Enums/TransformType.cs`:

```cs
namespace UETools.Core.Enums
{
    internal enum TransformType : byte
    {
        ToLower = 0,
        ToUpper,

        // Add new enum types at the end only! They are serialized by index.
    }
}
```

`src/UETools.Core/Enums/UE4Version.cs`:

```cs
namespace UETools.Core.Enums
{
    /// <summary>
    /// Enumeration representing the version of package.
    /// </summary>
    /// <remarks>Should be kept in sync with <see href="https://github.com/EpicGames/UnrealEngine/blob/release/Engine/Source/Runtime/Core/Public/UObject/ObjectVersion.h">ObjectVersion enum</see>.</remarks>
    //[EnumUpdater("https://docs.unrealengine.com/en-US/API/Runtime/Core/UObject/EUnrealEngineObjectUE4Version/index.html")]
    public enum UE4Version : int
    {
        /// <summary>
        /// The oldest package version we're able to load.
        /// </summary>
        VER_UE4_OLDEST_LOADABLE_PACKAGE = 214,

        /// <summary>
        /// Removed restriction on blueprint-exposed variables from being read-only.
        /// </summary>
        VER_UE4_BLUEPRINT_VARS_NOT_READ_ONLY,
        /// <summary>
        /// Added manually serialized element to UStaticMesh (precalculated nav collision).
        /// </summary>
        VER_UE4_STATIC_MESH_STORE_NAV_COLLISION,
        /// <summary>
        /// Changed property name for atmospheric fog.
        /// </summary>
        VER_UE4_ATMOSPHERIC_FOG_DECAY_NAME_CHANGE,
        /// <summary>
        /// Change many properties/functions from Translation to Location.
        /// </summary>
        VER_UE4_SCENECOMP_TRANSLATION_TO_LOCATION,
        /// <summary>
        /// Material attributes reordering.
        /// </summary>
        VER_UE4_MATERIAL_ATTRIBUTES_REORDERING,
        /// <summary>
        /// Collision Profile setting has been added, and all components that exists has to be properly upgraded.
        /// </summary>
        VER_UE4_COLLISION_PROFILE_SETTING,
        /// <summary>
        /// Making the blueprint's skeleton class transient.
        /// </summary>
        VER_UE4_BLUEPRINT_SKEL_TEMPORARY_TRANSIENT,
        /// <summary>
        /// Making the blueprint's skeleton class serialized again.
        /// </summary>
        VER_UE4_BLUEPRINT_SKEL_SERIALIZED_AGAIN,
        /// <summary>
        /// Blueprint now controls replication settings again.
        /// </summary>
        VER_UE4_BLUEPRINT_SETS_REPLICATION,
        /// <summary>
        /// Added level info used by World browser.
        /// </summary>
        VER_UE4_WORLD_LEVEL_INFO,
        /// <summary>
        /// Changed capsule height to capsule half-height (afterwards).
        /// </summary>
        VER_UE4_AFTER_CAPSULE_HALF_HEIGHT_CHANGE,
        /// <summary>
        /// Added Namepace, GUID (Key) and Flags to FText.
        /// </summary>
        VER_UE4_ADDED_NAMESPACE_AND_KEY_DATA_TO_FTEXT,
        /// <summary>
        /// Attenuation shapes.
        /// </summary>
        VER_UE4_ATTENUATION_SHAPES,
        /// <summary>
        /// Use IES texture multiplier even when IES brightness is not being used.
        /// </summary>
        VER_UE4_LIGHTCOMPONENT_USE_IES_TEXTURE_MULTIPLIER_ON_NON_IES_BRIGHTNESS,
        /// <summary>
        /// Removed InputComponent as a blueprint addable component.
        /// </summary>
        VER_UE4_REMOVE_INPUT_COMPONENTS_FROM_BLUEPRINTS,
        /// <summary>
        /// Use an FMemberReference struct in UK2Node_Variable.
        /// </summary>
        VER_UE4_VARK2NODE_USE_MEMBERREFSTRUCT,
        /// <summary>
        /// Refactored material expression inputs for UMaterialExpressionSceneColor and UMaterialExpressionSceneDepth.
        /// </summary>
        VER_UE4_REFACTOR_MATERIAL_EXPRESSION_SCENECOLOR_AND_SCENEDEPTH_INPUTS,
        /// <summary>
        /// Spline meshes changed from Z forwards to configurable.
        /// </summary>
        VER_UE4_SPLINE_MESH_ORIENTATION,
        /// <summary>
        /// Added ReverbEffect asset type.
        /// </summary>
        VER_UE4_REVERB_EFFECT_ASSET_TYPE,
        /// <summary>
        /// Changed max texcoords from 4 to 8.
        /// </summary>
        VER_UE4_MAX_TEXCOORD_INCREASED,
        /// <summary>
        /// Static meshes changed to support SpeedTrees.
        /// </summary>
        VER_UE4_SPEEDTREE_STATICMESH,
        /// <summary>
        /// Landscape component reference between landscape component and collision component.
        /// </summary>
        VER_UE4_LANDSCAPE_COMPONENT_LAZY_REFERENCES,
        /// <summary>
        /// Refactored UK2Node_CallFunction to use FMemberReference.
        /// </summary>
        VER_UE4_SWITCH_CALL_NODE_TO_USE_MEMBER_REFERENCE,
        /// <summary>
        /// Added fixup step to remove skeleton class references from blueprint objects.
        /// </summary>
        VER_UE4_ADDED_SKELETON_ARCHIVER_REMOVAL,
        /// <summary>
        /// See above, take 2.
        /// </summary>
        VER_UE4_ADDED_SKELETON_ARCHIVER_REMOVAL_SECOND_TIME,
        /// <summary>
        /// Making the skeleton class on blueprints transient.
        /// </summary>
        VER_UE4_BLUEPRINT_SKEL_CLASS_TRANSIENT_AGAIN,
        /// <summary>
        /// UClass knows if it's been cooked.
        /// </summary>
        VER_UE4_ADD_COOKED_TO_UCLASS,
        /// <summary>
        /// Deprecated static mesh thumbnail properties were removed.
        /// </summary>
        VER_UE4_DEPRECATED_STATIC_MESH_THUMBNAIL_PROPERTIES_REMOVED,
        /// <summary>
        /// Added collections in material shader map ids.
        /// </summary>
        VER_UE4_COLLECTIONS_IN_SHADERMAPID,
        /// <summary>
        /// Renamed some Movement Component properties, added PawnMovementComponent.
        /// </summary>
        VER_UE4_REFACTOR_MOVEMENT_COMPONENT_HIERARCHY,
        /// <summary>
        /// Swap UMaterialExpressionTerrainLayerSwitch::LayerUsed/LayerNotUsed the correct way round.
        /// </summary>
        VER_UE4_FIX_TERRAIN_LAYER_SWITCH_ORDER,
        /// <summary>
        /// Remove URB_ConstraintSetup.
        /// </summary>
        VER_UE4_ALL_PROPS_TO_CONSTRAINTINSTANCE,
        /// <summary>
        /// Low quality directional lightmaps.
        /// </summary>
        VER_UE4_LOW_QUALITY_DIRECTIONAL_LIGHTMAPS,
        /// <summary>
        /// Added NoiseEmitterComponent and removed related Pawn properties.
        /// </summary>
        VER_UE4_ADDED_NOISE_EMITTER_COMPONENT,
        /// <summary>
        /// Add text component vertical alignment.
        /// </summary>
        VER_UE4_ADD_TEXT_COMPONENT_VERTICAL_ALIGNMENT,
        /// <summary>
        /// Added AssetImportData for FBX asset types, deprecating SourceFilePath and SourceFileTimestamp.
        /// </summary>
        VER_UE4_ADDED_FBX_ASSET_IMPORT_DATA,
        /// <summary>
        /// Remove LevelBodySetup from ULevel.
        /// </summary>
        VER_UE4_REMOVE_LEVELBODYSETUP,
        /// <summary>
        /// Refactor character crouching.
        /// </summary>
        VER_UE4_REFACTOR_CHARACTER_CROUCH,
        /// <summary>
        /// Trimmed down material shader debug information.
        /// </summary>
        VER_UE4_SMALLER_DEBUG_MATERIALSHADER_UNIFORM_EXPRESSIONS,
        /// <summary>
        /// APEX Clothing.
        /// </summary>
        VER_UE4_APEX_CLOTH,
        /// <summary>
        /// Change Collision Channel to save only modified ones than all of them
        /// @note!!! once we pass this CL, we can rename FCollisionResponseContainer enum values
        /// we should rename to match ECollisionChannel.
        /// </summary>
        VER_UE4_SAVE_COLLISIONRESPONSE_PER_CHANNEL,
        /// <summary>
        /// Added Landscape Spline editor meshes.
        /// </summary>
        VER_UE4_ADDED_LANDSCAPE_SPLINE_EDITOR_MESH,
        /// <summary>
        /// Fixup input expressions for reading from refraction material attributes.
        /// </summary>
        VER_UE4_CHANGED_MATERIAL_REFACTION_TYPE,
        /// <summary>
        /// Refactor projectile movement, along with some other movement component work.
        /// </summary>
        VER_UE4_REFACTOR_PROJECTILE_MOVEMENT,
        /// <summary>
        /// Remove PhysicalMaterialProperty and replace with user defined enum.
        /// </summary>
        VER_UE4_REMOVE_PHYSICALMATERIALPROPERTY,
        /// <summary>
        /// Removed all compile outputs from FMaterial.
        /// </summary>
        VER_UE4_PURGED_FMATERIAL_COMPILE_OUTPUTS,
        /// <summary>
        /// Ability to save cooked PhysX meshes to Landscape.
        /// </summary>
        VER_UE4_ADD_COOKED_TO_LANDSCAPE,
        /// <summary>
        /// Change how input component consumption works.
        /// </summary>
        VER_UE4_CONSUME_INPUT_PER_BIND,
        /// <summary>
        /// Added new Graph based SoundClass Editor.
        /// </summary>
        VER_UE4_SOUND_CLASS_GRAPH_EDITOR,
        /// <summary>
        /// Fixed terrain layer node guids which was causing artifacts.
        /// </summary>
        VER_UE4_FIXUP_TERRAIN_LAYER_NODES,
        /// <summary>
        /// Added clamp min/max swap check to catch older materials.
        /// </summary>
        VER_UE4_RETROFIT_CLAMP_EXPRESSIONS_SWAP,
        /// <summary>
        /// Remove static/movable/stationary light classes.
        /// </summary>
        VER_UE4_REMOVE_LIGHT_MOBILITY_CLASSES,
        /// <summary>
        /// Refactor the way physics blending works to allow partial blending.
        /// </summary>
        VER_UE4_REFACTOR_PHYSICS_BLENDING,
        /// <summary>
        /// WorldLevelInfo: Added reference to parent level and streaming distance.
        /// </summary>
        VER_UE4_WORLD_LEVEL_INFO_UPDATED,
        /// <summary>
        /// Fixed cooking of skeletal/static meshes due to bad serialization logic.
        /// </summary>
        VER_UE4_STATIC_SKELETAL_MESH_SERIALIZATION_FIX,
        /// <summary>
        /// Removal of InterpActor and PhysicsActor.
        /// </summary>
        VER_UE4_REMOVE_STATICMESH_MOBILITY_CLASSES,
        /// <summary>
        /// Refactor physics transforms.
        /// </summary>
        VER_UE4_REFACTOR_PHYSICS_TRANSFORMS,
        /// <summary>
        /// Remove zero triangle sections from static meshes and compact material indices.
        /// </summary>
        VER_UE4_REMOVE_ZERO_TRIANGLE_SECTIONS,
        /// <summary>
        /// Add param for deceleration in character movement instead of using acceleration.
        /// </summary>
        VER_UE4_CHARACTER_MOVEMENT_DECELERATION,
        /// <summary>
        /// Made ACameraActor use a UCameraComponent for parameter storage, etc...
        /// </summary>
        VER_UE4_CAMERA_ACTOR_USING_CAMERA_COMPONENT,
        /// <summary>
        /// Deprecated some pitch/roll properties in CharacterMovementComponent.
        /// </summary>
        VER_UE4_CHARACTER_MOVEMENT_DEPRECATE_PITCH_ROLL,
        /// <summary>
        /// Rebuild texture streaming data on load for uncooked builds
        /// </summary>
        VER_UE4_REBUILD_TEXTURE_STREAMING_DATA_ON_LOAD,
        /// <summary>
        /// Add support for 32 bit index buffers for static meshes.
        /// </summary>
        VER_UE4_SUPPORT_32BIT_STATIC_MESH_INDICES,
        /// <summary>
        /// Added streaming install ChunkID to AssetData and UPackage.
        /// </summary>
        VER_UE4_ADDED_CHUNKID_TO_ASSETDATA_AND_UPACKAGE,
        /// <summary>
        /// Add flag to control whether Character blueprints receive default movement bindings.
        /// </summary>
        VER_UE4_CHARACTER_DEFAULT_MOVEMENT_BINDINGS,
        /// <summary>
        /// APEX Clothing LOD Info.
        /// </summary>
        VER_UE4_APEX_CLOTH_LOD,
        /// <summary>
        /// Added atmospheric fog texture data to be general
        /// </summary>
        VER_UE4_ATMOSPHERIC_FOG_CACHE_DATA,
        /// <summary>
        /// Arrays serialize their inner's tags.
        /// </summary>
        VAR_UE4_ARRAY_PROPERTY_INNER_TAGS,
        /// <summary>
        /// Skeletal mesh index data is kept in memory in game to support mesh merging.
        /// </summary>
        VER_UE4_KEEP_SKEL_MESH_INDEX_DATA,
        /// <summary>
        /// Added compatibility for the body instance collision change.
        /// </summary>
        VER_UE4_BODYSETUP_COLLISION_CONVERSION,
        /// <summary>
        /// Reflection capture cooking.
        /// </summary>
        VER_UE4_REFLECTION_CAPTURE_COOKING,
        /// <summary>
        /// Removal of DynamicTriggerVolume, DynamicBlockingVolume, DynamicPhysicsVolume.
        /// </summary>
        VER_UE4_REMOVE_DYNAMIC_VOLUME_CLASSES,
        /// <summary>
        /// Store an additional flag in the BodySetup to indicate whether there is any cooked data to load.
        /// </summary>
        VER_UE4_STORE_HASCOOKEDDATA_FOR_BODYSETUP,
        /// <summary>
        /// Changed name of RefractionBias to RefractionDepthBias.
        /// </summary>
        VER_UE4_REFRACTION_BIAS_TO_REFRACTION_DEPTH_BIAS,
        /// <summary>
        /// Removal of SkeletalPhysicsActor.
        /// </summary>
        VER_UE4_REMOVE_SKELETALPHYSICSACTOR,
        /// <summary>
        /// PlayerController rotation input refactor.
        /// </summary>
        VER_UE4_PC_ROTATION_INPUT_REFACTOR,
        /// <summary>
        /// Landscape Platform Data cooking.
        /// </summary>
        VER_UE4_LANDSCAPE_PLATFORMDATA_COOKING,
        /// <summary>
        /// Added call for linking classes in CreateExport to ensure memory is initialized properly.
        /// </summary>
        VER_UE4_CREATEEXPORTS_CLASS_LINKING_FOR_BLUEPRINTS,
        /// <summary>
        /// Remove native component nodes from the blueprint SimpleConstructionScript.
        /// </summary>
        VER_UE4_REMOVE_NATIVE_COMPONENTS_FROM_BLUEPRINT_SCS,
        /// <summary>
        /// Removal of Single Node Instance.
        /// </summary>
        VER_UE4_REMOVE_SINGLENODEINSTANCE,
        /// <summary>
        /// Character movement braking changes.
        /// </summary>
        VER_UE4_CHARACTER_BRAKING_REFACTOR,
        /// <summary>
        /// Supported low quality lightmaps in volume samples.
        /// </summary>
        VER_UE4_VOLUME_SAMPLE_LOW_QUALITY_SUPPORT,
        /// <summary>
        /// Split bEnableTouchEvents out from bEnableClickEvents.
        /// </summary>
        VER_UE4_SPLIT_TOUCH_AND_CLICK_ENABLES,
        /// <summary>
        /// Health/Death refactor.
        /// </summary>
        VER_UE4_HEALTH_DEATH_REFACTOR,
        /// <summary>
        /// Moving USoundNodeEnveloper from UDistributionFloatConstantCurve to FRichCurve.
        /// </summary>
        VER_UE4_SOUND_NODE_ENVELOPER_CURVE_CHANGE,
        /// <summary>
        /// Moved SourceRadius to UPointLightComponent.
        /// </summary>
        VER_UE4_POINT_LIGHT_SOURCE_RADIUS,
        /// <summary>
        /// Scene capture actors based on camera actors.
        /// </summary>
        VER_UE4_SCENE_CAPTURE_CAMERA_CHANGE,
        /// <summary>
        /// Moving SkeletalMesh shadow casting flag from LoD details to material.
        /// </summary>
        VER_UE4_MOVE_SKELETALMESH_SHADOWCASTING,
        /// <summary>
        /// Changing bytecode operators for creating arrays.
        /// </summary>
        VER_UE4_CHANGE_SETARRAY_BYTECODE,
        /// <summary>
        /// Material Instances overriding base material properties.
        /// </summary>
        VER_UE4_MATERIAL_INSTANCE_BASE_PROPERTY_OVERRIDES,
        /// <summary>
        /// Combined top/bottom lightmap textures.
        /// </summary>
        VER_UE4_COMBINED_LIGHTMAP_TEXTURES,
        /// <summary>
        /// Forced material lightmass guids to be regenerated.
        /// </summary>
        VER_UE4_BUMPED_MATERIAL_EXPORT_GUIDS,
        /// <summary>
        /// Allow overriding of parent class input bindings.
        /// </summary>
        VER_UE4_BLUEPRINT_INPUT_BINDING_OVERRIDES,
        /// <summary>
        /// Fix up convex invalid transform.
        /// </summary>
        VER_UE4_FIXUP_BODYSETUP_INVALID_CONVEX_TRANSFORM,
        /// <summary>
        /// Fix up scale of physics stiffness and damping value.
        /// </summary>
        VER_UE4_FIXUP_STIFFNESS_AND_DAMPING_SCALE,
        /// <summary>
        /// Convert USkeleton and FBoneContrainer to using FReferenceSkeleton.
        /// </summary>
        VER_UE4_REFERENCE_SKELETON_REFACTOR,
        /// <summary>
        /// Adding references to variable, function, and macro nodes to be able to update to renamed values.
        /// </summary>
        VER_UE4_K2NODE_REFERENCEGUIDS,
        /// <summary>
        /// Fix up the 0th bone's parent bone index.
        /// </summary>
        VER_UE4_FIXUP_ROOTBONE_PARENT,
        /// <summary>
        ///Allow setting of TextRenderComponents size in world space.
        /// </summary>
        VER_UE4_TEXT_RENDER_COMPONENTS_WORLD_SPACE_SIZING,
        /// <summary>
        /// Material Instances overriding base material properties #2.
        /// </summary>
        VER_UE4_MATERIAL_INSTANCE_BASE_PROPERTY_OVERRIDES_PHASE_2,
        /// <summary>
        /// CLASS_Placeable becomes CLASS_NotPlaceable.
        /// </summary>
        VER_UE4_CLASS_NOTPLACEABLE_ADDED,
        /// <summary>
        /// Added LOD info list to a world tile description.
        /// </summary>
        VER_UE4_WORLD_LEVEL_INFO_LOD_LIST,
        /// <summary>
        /// CharacterMovement variable naming refactor.
        /// </summary>
        VER_UE4_CHARACTER_MOVEMENT_VARIABLE_RENAMING_1,
        /// <summary>
        /// FName properties containing sound names converted to FSlateSound properties.
        /// </summary>
        VER_UE4_FSLATESOUND_CONVERSION,
        /// <summary>
        /// Added ZOrder to a world tile description.
        /// </summary>
        VER_UE4_WORLD_LEVEL_INFO_ZORDER,
        /// <summary>
        /// Added flagging of localization gather requirement to packages.
        /// </summary>
        VER_UE4_PACKAGE_REQUIRES_LOCALIZATION_GATHER_FLAGGING,
        /// <summary>
        /// Preventing Blueprint Actor variables from having default values.
        /// </summary>
        VER_UE4_BP_ACTOR_VARIABLE_DEFAULT_PREVENTING,
        /// <summary>
        /// Preventing Blueprint Actor variables from having default values.
        /// </summary>
        VER_UE4_TEST_ANIMCOMP_CHANGE,
        /// <summary>
        /// Class as primary asset, name convention changed.
        /// </summary>
        VER_UE4_EDITORONLY_BLUEPRINTS,
        /// <summary>
        /// Custom serialization for FEdGraphPinType.
        /// </summary>
        VER_UE4_EDGRAPHPINTYPE_SERIALIZATION,
        /// <summary>
        /// Stop generating 'mirrored' cooked mesh for Brush and Model components.
        /// </summary>
        VER_UE4_NO_MIRROR_BRUSH_MODEL_COLLISION,
        /// <summary>
        /// Changed ChunkID to be an array of IDs.
        /// </summary>
        VER_UE4_CHANGED_CHUNKID_TO_BE_AN_ARRAY_OF_CHUNKIDS,
        /// <summary>
        /// Worlds have been renamed from "TheWorld" to be named after the package containing them.
        /// </summary>
        VER_UE4_WORLD_NAMED_AFTER_PACKAGE,
        /// <summary>
        /// Added sky light component.
        /// </summary>
        VER_UE4_SKY_LIGHT_COMPONENT,
        /// <summary>
        /// Added Enable distance streaming flag to FWorldTileLayer.
        /// </summary>
        VER_UE4_WORLD_LAYER_ENABLE_DISTANCE_STREAMING,
        /// <summary>
        /// Remove visibility/zone information from UModel.
        /// </summary>
        VER_UE4_REMOVE_ZONES_FROM_MODEL,
        /// <summary>
        /// Fix base pose serialization .
        /// </summary>
        VER_UE4_FIX_ANIMATIONBASEPOSE_SERIALIZATION,
        /// <summary>
        /// Support for up to 8 skinning influences per vertex on skeletal meshes (on non-gpu vertices).
        /// </summary>
        VER_UE4_SUPPORT_8_BONE_INFLUENCES_SKELETAL_MESHES,
        /// <summary>
        /// Add explicit bOverrideGravity to world settings.
        /// </summary>
        VER_UE4_ADD_OVERRIDE_GRAVITY_FLAG,
        /// <summary>
        /// Support for up to 8 skinning influences per vertex on skeletal meshes (on gpu vertices).
        /// </summary>
        VER_UE4_SUPPORT_GPUSKINNING_8_BONE_INFLUENCES,
        /// <summary>
        /// Supporting nonuniform scale animation.
        /// </summary>
        VER_UE4_ANIM_SUPPORT_NONUNIFORM_SCALE_ANIMATION,
        /// <summary>
        /// Engine version is stored as a FEngineVersion object rather than changelist number.
        /// </summary>
        VER_UE4_ENGINE_VERSION_OBJECT,
        /// <summary>
        /// World assets now have RF_Public.
        /// </summary>
        VER_UE4_PUBLIC_WORLDS,
        /// <summary>
        /// Skeleton Guid.
        /// </summary>
        VER_UE4_SKELETON_GUID_SERIALIZATION,
        /// <summary>
        /// Character movement WalkableFloor refactor.
        /// </summary>
        VER_UE4_CHARACTER_MOVEMENT_WALKABLE_FLOOR_REFACTOR,
        /// <summary>
        /// Lights default to inverse squared.
        /// </summary>
        VER_UE4_INVERSE_SQUARED_LIGHTS_DEFAULT,
        /// <summary>
        /// Disabled SCRIPT_LIMIT_BYTECODE_TO_64KB.
        /// </summary>
        VER_UE4_DISABLED_SCRIPT_LIMIT_BYTECODE,
        /// <summary>
        /// Made remote role private, exposed bReplicates.
        /// </summary>
        VER_UE4_PRIVATE_REMOTE_ROLE,
        /// <summary>
        /// Fix up old foliage components to have static mobility (superseded by VER_UE4_FOLIAGE_MOVABLE_MOBILITY).
        /// </summary>
        VER_UE4_FOLIAGE_STATIC_MOBILITY,
        /// <summary>
        /// Change BuildScale from a float to a vector.
        /// </summary>
        VER_UE4_BUILD_SCALE_VECTOR,
        /// <summary>
        /// After implementing foliage collision, need to disable collision on old foliage instances.
        /// </summary>
        VER_UE4_FOLIAGE_COLLISION,
        /// <summary>
        /// Added sky bent normal to indirect lighting cache.
        /// </summary>
        VER_UE4_SKY_BENT_NORMAL,
        /// <summary>
        /// Added cooking for landscape collision data.
        /// </summary>
        VER_UE4_LANDSCAPE_COLLISION_DATA_COOKING,
        /// <summary>
        /// Convert CPU tangent Z delta to vector from PackedNormal since we don't get any benefit other than memory
        /// we still convert all to FVector in CPU time whenever any calculation
        /// </summary>
        VER_UE4_MORPHTARGET_CPU_TANGENTZDELTA_FORMATCHANGE,
        /// <summary>
        /// Soft constraint limits will implicitly use the mass of the bodies.
        /// </summary>
        VER_UE4_SOFT_CONSTRAINTS_USE_MASS,
        /// <summary>
        /// Reflection capture data saved in packages.
        /// </summary>
        VER_UE4_REFLECTION_DATA_IN_PACKAGES,
        /// <summary>
        /// Fix up old foliage components to have movable mobility (superseded by VER_UE4_FOLIAGE_STATIC_LIGHTING_SUPPORT).
        /// </summary>
        VER_UE4_FOLIAGE_MOVABLE_MOBILITY,
        /// <summary>
        /// Undo BreakMaterialAttributes changes as it broke old content.
        /// </summary>
        VER_UE4_UNDO_BREAK_MATERIALATTRIBUTES_CHANGE,
        /// <summary>
        /// Now Default custom profile name isn't NONE anymore due to copy/paste not working properly with it.
        /// </summary>
        VER_UE4_ADD_CUSTOMPROFILENAME_CHANGE,
        /// <summary>
        /// Permanently flip and scale material expression coordinates.
        /// </summary>
        VER_UE4_FLIP_MATERIAL_COORDS,
        /// <summary>
        /// PinSubCategoryMemberReference added to FEdGraphPinType.
        /// </summary>
        VER_UE4_MEMBERREFERENCE_IN_PINTYPE,
        /// <summary>
        /// Vehicles use Nm for Torque instead of cm and RPM instead of rad/s.
        /// </summary>
        VER_UE4_VEHICLES_UNIT_CHANGE,
        /// <summary>
        /// removes NANs from all animations when loaded
        /// now importing should detect NaNs, so we should not have NaNs in source data
        /// </summary>
        VER_UE4_ANIMATION_REMOVE_NANS,
        /// <summary>
        /// Change skeleton preview attached assets property type.
        /// </summary>
        VER_UE4_SKELETON_ASSET_PROPERTY_TYPE_CHANGE,
        /// <summary>
        /// Fix some blueprint variables that have the CPF_DisableEditOnTemplate flag set
        /// when they shouldn't
        /// </summary>
        VER_UE4_FIX_BLUEPRINT_VARIABLE_FLAGS,
        /// <summary>
        /// Vehicles use Nm for Torque instead of cm and RPM instead of rad/s part two (missed conversion for some variables.
        /// </summary>
        VER_UE4_VEHICLES_UNIT_CHANGE2,
        /// <summary>
        /// Changed order of interface class serialization.
        /// </summary>
        VER_UE4_UCLASS_SERIALIZE_INTERFACES_AFTER_LINKING,
        /// <summary>
        /// Change from LOD distances to display factors.
        /// </summary>
        VER_UE4_STATIC_MESH_SCREEN_SIZE_LODS,
        /// <summary>
        /// Requires test of material coords to ensure they're saved correctly.
        /// </summary>
        VER_UE4_FIX_MATERIAL_COORDS,
        /// <summary>
        /// Changed SpeedTree wind presets to v7.
        /// </summary>
        VER_UE4_SPEEDTREE_WIND_V7,
        /// <summary>
        /// NeedsLoadForEditorGame added.
        /// </summary>
        VER_UE4_LOAD_FOR_EDITOR_GAME,
        /// <summary>
        /// Manual serialization of FRichCurveKey to save space.
        /// </summary>
        VER_UE4_SERIALIZE_RICH_CURVE_KEY,
        /// <summary>
        /// Change the outer of ULandscapeMaterialInstanceConstants and Landscape-related textures to the level in which they reside.
        /// </summary>
        VER_UE4_MOVE_LANDSCAPE_MICS_AND_TEXTURES_WITHIN_LEVEL,
        /// <summary>
        /// FTexts have creation history data, removed Key, Namespaces, and SourceString.
        /// </summary>
        VER_UE4_FTEXT_HISTORY,
        /// <summary>
        /// Shift comments to the left to contain expressions properly.
        /// </summary>
        VER_UE4_FIX_MATERIAL_COMMENTS,
        /// <summary>
        /// Bone names stored as FName means that we can't guarantee the correct case on export, now we store a separate string for export purposes only.
        /// </summary>
        VER_UE4_STORE_BONE_EXPORT_NAMES,
        /// <summary>
        /// changed mesh emitter initial orientation to distribution.
        /// </summary>
        VER_UE4_MESH_EMITTER_INITIAL_ORIENTATION_DISTRIBUTION,
        /// <summary>
        /// Foliage on blueprints causes crashes.
        /// </summary>
        VER_UE4_DISALLOW_FOLIAGE_ON_BLUEPRINTS,
        /// <summary>
        /// change motors to use revolutions per second instead of rads/second.
        /// </summary>
        VER_UE4_FIXUP_MOTOR_UNITS,
        /// <summary>
        /// deprecated MovementComponent functions including "ModifiedMaxSpeed" et al.
        /// </summary>
        VER_UE4_DEPRECATED_MOVEMENTCOMPONENT_MODIFIED_SPEEDS,
        /// <summary>
        /// rename CanBeCharacterBase.
        /// </summary>
        VER_UE4_RENAME_CANBECHARACTERBASE,
        /// <summary>
        /// Change GameplayTagContainers to have FGameplayTags instead of FNames; Required to fix-up native serialization.
        /// </summary>
        VER_UE4_GAMEPLAY_TAG_CONTAINER_TAG_TYPE_CHANGE,
        /// <summary>
        /// Change from UInstancedFoliageSettings to UFoliageType, and change the api from being keyed on UStaticMesh* to UFoliageType*.
        /// </summary>
        VER_UE4_FOLIAGE_SETTINGS_TYPE,
        /// <summary>
        /// Lights serialize static shadow depth maps.
        /// </summary>
        VER_UE4_STATIC_SHADOW_DEPTH_MAPS,
        /// <summary>
        /// Add RF_Transactional to data assets, fixing undo problems when editing them.
        /// </summary>
        VER_UE4_ADD_TRANSACTIONAL_TO_DATA_ASSETS,
        /// <summary>
        /// Change LB_AlphaBlend to LB_WeightBlend in ELandscapeLayerBlendType.
        /// </summary>
        VER_UE4_ADD_LB_WEIGHTBLEND,
        /// <summary>
        /// Add root component to an foliage actor, all foliage cluster components will be attached to a root.
        /// </summary>
        VER_UE4_ADD_ROOTCOMPONENT_TO_FOLIAGEACTOR,
        /// <summary>
        /// FMaterialInstanceBasePropertyOverrides didn't use proper UObject serialize.
        /// </summary>
        VER_UE4_FIX_MATERIAL_PROPERTY_OVERRIDE_SERIALIZE,
        /// <summary>
        /// Addition of linear color sampler. color sample type is changed to linear sampler if source texture !sRGB.
        /// </summary>
        VER_UE4_ADD_LINEAR_COLOR_SAMPLER,
        /// <summary>
        /// Added StringAssetReferencesMap to support renames of FStringAssetReference properties.
        /// </summary>
        VER_UE4_ADD_STRING_ASSET_REFERENCES_MAP,
        /// <summary>
        /// Apply scale from SCS RootComponent details in the Blueprint Editor to new actor instances at construction time.
        /// </summary>
        VER_UE4_BLUEPRINT_USE_SCS_ROOTCOMPONENT_SCALE,
        /// <summary>
        /// Changed level streaming to have a linear color since the visualization doesn't gamma correct.
        /// </summary>
        VER_UE4_LEVEL_STREAMING_DRAW_COLOR_TYPE_CHANGE,
        /// <summary>
        /// Cleared end triggers from non-state anim notifies.
        /// </summary>
        VER_UE4_CLEAR_NOTIFY_TRIGGERS,
        /// <summary>
        /// Convert old curve names stored in anim assets into skeleton smartnames.
        /// </summary>
        VER_UE4_SKELETON_ADD_SMARTNAMES,
        /// <summary>
        /// Added the currency code field to FTextHistory_AsCurrency.
        /// </summary>
        VER_UE4_ADDED_CURRENCY_CODE_TO_FTEXT,
        /// <summary>
        /// Added support for C++11 enum classes.
        /// </summary>
        VER_UE4_ENUM_CLASS_SUPPORT,
        /// <summary>
        /// Fixup widget animation class.
        /// </summary>
        VER_UE4_FIXUP_WIDGET_ANIMATION_CLASS,
        /// <summary>
        /// USoundWave objects now contain details about compression scheme used.
        /// </summary>
        VER_UE4_SOUND_COMPRESSION_TYPE_ADDED,
        /// <summary>
        /// Bodies will automatically weld when attached.
        /// </summary>
        VER_UE4_AUTO_WELDING,
        /// <summary>
        /// Rename UCharacterMovementComponent::bCrouchMovesCharacterDown.
        /// </summary>
        VER_UE4_RENAME_CROUCHMOVESCHARACTERDOWN,
        /// <summary>
        /// Lightmap parameters in FMeshBuildSettings.
        /// </summary>
        VER_UE4_LIGHTMAP_MESH_BUILD_SETTINGS,
        /// <summary>
        /// Rename SM3 to ES3_1 and updates featurelevel material node selector.
        /// </summary>
        VER_UE4_RENAME_SM3_TO_ES3_1,
        /// <summary>
        /// Deprecated separate style assets for use in UMG.
        /// </summary>
        VER_UE4_DEPRECATE_UMG_STYLE_ASSETS,
        /// <summary>
        /// Duplicating Blueprints will regenerate NodeGuids after this version.
        /// </summary>
        VER_UE4_POST_DUPLICATE_NODE_GUID,
        /// <summary>
        /// Rename USpringArmComponent::bUseControllerViewRotation to bUsePawnViewRotation,
        /// Rename UCameraComponent::bUseControllerViewRotation to bUsePawnViewRotation (and change the default value).
        /// </summary>
        VER_UE4_RENAME_CAMERA_COMPONENT_VIEW_ROTATION,
        /// <summary>
        /// Changed FName to be case preserving.
        /// </summary>
        VER_UE4_CASE_PRESERVING_FNAME,
        /// <summary>
        /// Rename USpringArmComponent::bUsePawnViewRotation to bUsePawnControlRotation,
        /// Rename UCameraComponent::bUsePawnViewRotation to bUsePawnControlRotation.
        /// </summary>
        VER_UE4_RENAME_CAMERA_COMPONENT_CONTROL_ROTATION,
        /// <summary>
        /// Fix bad refraction material attribute masks.
        /// </summary>
        VER_UE4_FIX_REFRACTION_INPUT_MASKING,
        /// <summary>
        /// A global spawn rate for emitters.
        /// </summary>
        VER_UE4_GLOBAL_EMITTER_SPAWN_RATE_SCALE,
        /// <summary>
        /// Cleanup destructible mesh settings.
        /// </summary>
        VER_UE4_CLEAN_DESTRUCTIBLE_SETTINGS,
        /// <summary>
        /// CharacterMovementComponent refactor of AdjustUpperHemisphereImpact and deprecation of some associated vars.
        /// </summary>
        VER_UE4_CHARACTER_MOVEMENT_UPPER_IMPACT_BEHAVIOR,
        /// <summary>
        /// Changed Blueprint math equality functions for vectors and rotators to operate as a "nearly" equals rather than "exact".
        /// </summary>
        VER_UE4_BP_MATH_VECTOR_EQUALITY_USES_EPSILON,
        /// <summary>
        /// Static lighting support was re-added to foliage, and mobility was returned to static.
        /// </summary>
        VER_UE4_FOLIAGE_STATIC_LIGHTING_SUPPORT,
        /// <summary>
        /// Added composite fonts to Slate font info.
        /// </summary>
        VER_UE4_SLATE_COMPOSITE_FONTS,
        /// <summary>
        /// Remove UDEPRECATED_SaveGameSummary, required for UWorld::Serialize.
        /// </summary>
        VER_UE4_REMOVE_SAVEGAMESUMMARY,
        /// <summary>
        ///Remove bodyseutp serialization from skeletal mesh component.
        /// </summary>
        VER_UE4_REMOVE_SKELETALMESH_COMPONENT_BODYSETUP_SERIALIZATION,
        /// <summary>
        /// Made Slate font data use bulk data to store the embedded font data.
        /// </summary>
        VER_UE4_SLATE_BULK_FONT_DATA,
        /// <summary>
        /// Add new friction behavior in ProjectileMovementComponent.
        /// </summary>
        VER_UE4_ADD_PROJECTILE_FRICTION_BEHAVIOR,
        /// <summary>
        /// Add axis settings enum to MovementComponent.
        /// </summary>
        VER_UE4_MOVEMENTCOMPONENT_AXIS_SETTINGS,
        /// <summary>
        /// Switch to new interactive comments, requires boundry conversion to preserve previous states.
        /// </summary>
        VER_UE4_GRAPH_INTERACTIVE_COMMENTBUBBLES,
        /// <summary>
        /// Landscape serializes physical materials for collision objects.
        /// </summary>
        VER_UE4_LANDSCAPE_SERIALIZE_PHYSICS_MATERIALS,
        /// <summary>
        /// Rename Visiblity on widgets to Visibility.
        /// </summary>
        VER_UE4_RENAME_WIDGET_VISIBILITY,
        /// <summary>
        /// add track curves for animation.
        /// </summary>
        VER_UE4_ANIMATION_ADD_TRACKCURVES,
        /// <summary>
        /// Removed BranchingPoints from AnimMontages and converted them to regular AnimNotifies.
        /// </summary>
        VER_UE4_MONTAGE_BRANCHING_POINT_REMOVAL,
        /// <summary>
        /// Enforce const-correctness in Blueprint implementations of native C++ const class methods.
        /// </summary>
        VER_UE4_BLUEPRINT_ENFORCE_CONST_IN_FUNCTION_OVERRIDES,
        /// <summary>
        /// Added pivot to widget components, need to load old versions as a 0,0 pivot, new default is 0.5,0.5.
        /// </summary>
        VER_UE4_ADD_PIVOT_TO_WIDGET_COMPONENT,
        /// <summary>
        /// Added finer control over when AI Pawns are automatically possessed. Also renamed Pawn.AutoPossess to Pawn.AutoPossessPlayer indicate this was a setting for players and not AI.
        /// </summary>
        VER_UE4_PAWN_AUTO_POSSESS_AI,
        /// <summary>
        /// Added serialization of timezone to FTextHistory for AsDate operations.
        /// </summary>
        VER_UE4_FTEXT_HISTORY_DATE_TIMEZONE,
        /// <summary>
        /// Sort ActiveBoneIndices on lods so that we can avoid doing it at run time.
        /// </summary>
        VER_UE4_SORT_ACTIVE_BONE_INDICES,
        /// <summary>
        /// Added per-frame material uniform expressions.
        /// </summary>
        VER_UE4_PERFRAME_MATERIAL_UNIFORM_EXPRESSIONS,
        /// <summary>
        /// Make MikkTSpace the default tangent space calculation method for static meshes.
        /// </summary>
        VER_UE4_MIKKTSPACE_IS_DEFAULT,
        /// <summary>
        /// Only applies to cooked files, grass cooking support.
        /// </summary>
        VER_UE4_LANDSCAPE_GRASS_COOKING,
        /// <summary>
        /// Fixed code for using the bOrientMeshEmitters property.
        /// </summary>
        VER_UE4_FIX_SKEL_VERT_ORIENT_MESH_PARTICLES,
        /// <summary>
        /// Do not change landscape section offset on load under world composition.
        /// </summary>
        VER_UE4_LANDSCAPE_STATIC_SECTION_OFFSET,
        /// <summary>
        /// New options for navigation data runtime generation (static, modifiers only, dynamic).
        /// </summary>
        VER_UE4_ADD_MODIFIERS_RUNTIME_GENERATION,
        /// <summary>
        /// Tidied up material's handling of masked blend mode.
        /// </summary>
        VER_UE4_MATERIAL_MASKED_BLENDMODE_TIDY,
        /// <summary>
        /// Original version of VER_UE4_MERGED_ADD_MODIFIERS_RUNTIME_GENERATION_TO_4_7; renumbered to prevent blocking promotion in main.
        /// </summary>
        VER_UE4_MERGED_ADD_MODIFIERS_RUNTIME_GENERATION_TO_4_7_DEPRECATED,
        /// <summary>
        /// Original version of VER_UE4_AFTER_MERGED_ADD_MODIFIERS_RUNTIME_GENERATION_TO_4_7; renumbered to prevent blocking promotion in main.
        /// </summary>
        VER_UE4_AFTER_MERGED_ADD_MODIFIERS_RUNTIME_GENERATION_TO_4_7_DEPRECATED,
        /// <summary>
        /// After merging VER_UE4_ADD_MODIFIERS_RUNTIME_GENERATION into 4.7 branch.
        /// </summary>
        VER_UE4_MERGED_ADD_MODIFIERS_RUNTIME_GENERATION_TO_4_7,
        /// <summary>
        /// After merging VER_UE4_ADD_MODIFIERS_RUNTIME_GENERATION into 4.7 branch.
        /// </summary>
        VER_UE4_AFTER_MERGING_ADD_MODIFIERS_RUNTIME_GENERATION_TO_4_7,
        /// <summary>
        /// Landscape grass weightmap data is now generated in the editor and serialized.
        /// </summary>
        VER_UE4_SERIALIZE_LANDSCAPE_GRASS_DATA,
        /// <summary>
        /// New property to optionally prevent gpu emitters clearing existing particles on Init().
        /// </summary>
        VER_UE4_OPTIONALLY_CLEAR_GPU_EMITTERS_ON_INIT,
        /// <summary>
        /// Also store the Material guid with the landscape grass data.
        /// </summary>
        VER_UE4_SERIALIZE_LANDSCAPE_GRASS_DATA_MATERIAL_GUID,
        /// <summary>
        /// Make sure that all template components from blueprint generated classes are flagged as public.
        /// </summary>
        VER_UE4_BLUEPRINT_GENERATED_CLASS_COMPONENT_TEMPLATES_PUBLIC,
        /// <summary>
        /// Split out creation method on ActorComponents to distinguish between native, instance, and simple or user construction script.
        /// </summary>
        VER_UE4_ACTOR_COMPONENT_CREATION_METHOD,
        /// <summary>
        /// K2Node_Event now uses FMemberReference for handling references.
        /// </summary>
        VER_UE4_K2NODE_EVENT_MEMBER_REFERENCE,
        /// <summary>
        /// FPropertyTag stores GUID of struct.
        /// </summary>
        VER_UE4_STRUCT_GUID_IN_PROPERTY_TAG,
        /// <summary>
        /// Remove unused UPolys from UModel cooked content.
        /// </summary>
        VER_UE4_REMOVE_UNUSED_UPOLYS_FROM_UMODEL,
        /// <summary>
        /// This doesn't do anything except trigger a rebuild on HISMC cluster trees, in this case to get a good "occlusion query" level.
        /// </summary>
        VER_UE4_REBUILD_HIERARCHICAL_INSTANCE_TREES,
        /// <summary>
        /// Package summary includes an CompatibleWithEngineVersion field, separately to the version it's saved with.
        /// </summary>
        VER_UE4_PACKAGE_SUMMARY_HAS_COMPATIBLE_ENGINE_VERSION,
        /// <summary>
        /// Track UCS modified properties on Actor Components.
        /// </summary>
        VER_UE4_TRACK_UCS_MODIFIED_PROPERTIES,
        /// <summary>
        /// Allowed landscape spline meshes to be stored into landscape streaming levels rather than the spline's level.
        /// </summary>
        VER_UE4_LANDSCAPE_SPLINE_CROSS_LEVEL_MESHES,
        /// <summary>
        /// Deprecate the variables used for sizing in the designer on UUserWidget.
        /// </summary>
        VER_UE4_DEPRECATE_USER_WIDGET_DESIGN_SIZE,
        /// <summary>
        /// Make the editor views array dynamically sized.
        /// </summary>
        VER_UE4_ADD_EDITOR_VIEWS,
        /// <summary>
        /// Updated foliage to work with either FoliageType assets or blueprint classes.
        /// </summary>
        VER_UE4_FOLIAGE_WITH_ASSET_OR_CLASS,
        /// <summary>
        /// Allows PhysicsSerializer to serialize shapes and actors for faster load times.
        /// </summary>
        VER_UE4_BODYINSTANCE_BINARY_SERIALIZATION,
        /// <summary>
        /// Added fastcall data serialization directly in UFunction.
        /// </summary>
        VER_UE4_SERIALIZE_BLUEPRINT_EVENTGRAPH_FASTCALLS_IN_UFUNCTION,
        /// <summary>
        /// Changes to USplineComponent and FInterpCurve.
        /// </summary>
        VER_UE4_INTERPCURVE_SUPPORTS_LOOPING,
        /// <summary>
        /// Material Instances overriding base material LOD transitions.
        /// </summary>
        VER_UE4_MATERIAL_INSTANCE_BASE_PROPERTY_OVERRIDES_DITHERED_LOD_TRANSITION,
        /// <summary>
        /// Serialize ES2 textures separately rather than overwriting the properties used on other platforms.
        /// </summary>
        VER_UE4_SERIALIZE_LANDSCAPE_ES2_TEXTURES,
        /// <summary>
        /// Constraint motor velocity is broken into per-component.
        /// </summary>
        VER_UE4_CONSTRAINT_INSTANCE_MOTOR_FLAGS,
        /// <summary>
        /// Serialize bIsConst in FEdGraphPinType.
        /// </summary>
        VER_UE4_SERIALIZE_PINTYPE_CONST,
        /// <summary>
        /// Change UMaterialFunction::LibraryCategories to LibraryCategoriesText (old assets were saved before auto-conversion of UArrayProperty was possible).
        /// </summary>
        VER_UE4_LIBRARY_CATEGORIES_AS_FTEXT,
        /// <summary>
        /// Check for duplicate exports while saving packages.
        /// </summary>
        VER_UE4_SKIP_DUPLICATE_EXPORTS_ON_SAVE_PACKAGE,
        /// <summary>
        /// Pre-gathering of gatherable, localizable text in packages to optimize text gathering operation times.
        /// </summary>
        VER_UE4_SERIALIZE_TEXT_IN_PACKAGES,
        /// <summary>
        /// Added pivot to widget components, need to load old versions as a 0,0 pivot, new default is 0.5,0.5.
        /// </summary>
        VER_UE4_ADD_BLEND_MODE_TO_WIDGET_COMPONENT,
        /// <summary>
        /// Added lightmass primitive setting.
        /// </summary>
        VER_UE4_NEW_LIGHTMASS_PRIMITIVE_SETTING,
        /// <summary>
        /// Deprecate NoZSpring property on spring nodes to be replaced with TranslateZ property.
        /// </summary>
        VER_UE4_REPLACE_SPRING_NOZ_PROPERTY,
        /// <summary>
        /// Keep enums tight and serialize their values as pairs of FName and value. Don't insert dummy values.
        /// </summary>
        VER_UE4_TIGHTLY_PACKED_ENUMS,
        /// <summary>
        /// Changed Asset import data to serialize file meta data as JSON.
        /// </summary>
        VER_UE4_ASSET_IMPORT_DATA_AS_JSON,
        /// <summary>
        /// Legacy gamma support for textures.
        /// </summary>
        VER_UE4_TEXTURE_LEGACY_GAMMA,
        /// <summary>
        /// Added WithSerializer for basic native structures like FVector, FColor etc to improve serialization performance.
        /// </summary>
        VER_UE4_ADDED_NATIVE_SERIALIZATION_FOR_IMMUTABLE_STRUCTURES,
        /// <summary>
        /// Deprecated attributes that override the style on UMG widgets.
        /// </summary>
        VER_UE4_DEPRECATE_UMG_STYLE_OVERRIDES,
        /// <summary>
        /// Shadowmap penumbra size stored.
        /// </summary>
        VER_UE4_STATIC_SHADOWMAP_PENUMBRA_SIZE,
        /// <summary>
        /// Fix BC on Niagara effects from the data object and dev UI changes.
        /// </summary>
        VER_UE4_NIAGARA_DATA_OBJECT_DEV_UI_FIX,
        /// <summary>
        /// Fixed the default orientation of widget component so it faces down +x.
        /// </summary>
        VER_UE4_FIXED_DEFAULT_ORIENTATION_OF_WIDGET_COMPONENT,
        /// <summary>
        /// Removed bUsedWithUI flag from UMaterial and replaced it with a new material domain for UI.
        /// </summary>
        VER_UE4_REMOVED_MATERIAL_USED_WITH_UI_FLAG,
        /// <summary>
        /// Added braking friction separate from turning friction.
        /// </summary>
        VER_UE4_CHARACTER_MOVEMENT_ADD_BRAKING_FRICTION,
        /// <summary>
        /// Removed TTransArrays from UModel.
        /// </summary>
        VER_UE4_BSP_UNDO_FIX,
        /// <summary>
        /// Added default value to dynamic parameter.
        /// </summary>
        VER_UE4_DYNAMIC_PARAMETER_DEFAULT_VALUE,
        /// <summary>
        /// Added ExtendedBounds to StaticMesh.
        /// </summary>
        VER_UE4_STATIC_MESH_EXTENDED_BOUNDS,
        /// <summary>
        /// Added non-linear blending to anim transitions, deprecating old types.
        /// </summary>
        VER_UE4_ADDED_NON_LINEAR_TRANSITION_BLENDS,
        /// <summary>
        /// AO Material Mask texture.
        /// </summary>
        VER_UE4_AO_MATERIAL_MASK,
        /// <summary>
        /// Replaced navigation agents selection with single structure.
        /// </summary>
        VER_UE4_NAVIGATION_AGENT_SELECTOR,
        /// <summary>
        /// Mesh particle collisions consider particle size.
        /// </summary>
        VER_UE4_MESH_PARTICLE_COLLISIONS_CONSIDER_PARTICLE_SIZE,
        /// <summary>
        /// Adjacency buffer building no longer automatically handled based on triangle count, user-controlled.
        /// </summary>
        VER_UE4_BUILD_MESH_ADJ_BUFFER_FLAG_EXPOSED,
        /// <summary>
        /// Change the default max angular velocity.
        /// </summary>
        VER_UE4_MAX_ANGULAR_VELOCITY_DEFAULT,
        /// <summary>
        /// Build Adjacency index buffer for clothing tessellation.
        /// </summary>
        VER_UE4_APEX_CLOTH_TESSELLATION,
        /// <summary>
        /// Added DecalSize member, solved backward compatibility.
        /// </summary>
        VER_UE4_DECAL_SIZE,
        /// <summary>
        /// Keep only package names in StringAssetReferencesMap.
        /// </summary>
        VER_UE4_KEEP_ONLY_PACKAGE_NAMES_IN_STRING_ASSET_REFERENCES_MAP,
        /// <summary>
        /// Support sound cue not saving out editor only data.
        /// </summary>
        VER_UE4_COOKED_ASSETS_IN_EDITOR_SUPPORT,
        /// <summary>
        /// Updated dialogue wave localization gathering logic.
        /// </summary>
        VER_UE4_DIALOGUE_WAVE_NAMESPACE_AND_CONTEXT_CHANGES,
        /// <summary>
        /// Renamed MakeRot MakeRotator and rearranged parameters.
        /// </summary>
        VER_UE4_MAKE_ROT_RENAME_AND_REORDER,
        /// <summary>
        /// K2Node_Variable will properly have the VariableReference Guid set if available.
        /// </summary>
        VER_UE4_K2NODE_VAR_REFERENCEGUIDS,
        /// <summary>
        /// Added support for sound concurrency settings structure and overrides.
        /// </summary>
        VER_UE4_SOUND_CONCURRENCY_PACKAGE,
        /// <summary>
        /// Changing the default value for focusable user widgets to false.
        /// </summary>
        VER_UE4_USERWIDGET_DEFAULT_FOCUSABLE_FALSE,
        /// <summary>
        /// Custom event nodes implicitly set 'const' on array and non-array pass-by-reference input params.
        /// </summary>
        VER_UE4_BLUEPRINT_CUSTOM_EVENT_CONST_INPUT,
        /// <summary>
        /// Renamed HighFrequencyGain to LowPassFilterFrequency.
        /// </summary>
        VER_UE4_USE_LOW_PASS_FILTER_FREQ,
        /// <summary>
        /// UAnimBlueprintGeneratedClass can be replaced by a dynamic class.
        /// </summary>
        VER_UE4_NO_ANIM_BP_CLASS_IN_GAMEPLAY_CODE,
        /// <summary>
        /// The SCS keeps a list of all nodes in its hierarchy rather than recursively building it each time it is requested.
        /// </summary>
        VER_UE4_SCS_STORES_ALLNODES_ARRAY,
        /// <summary>
        /// Moved StartRange and EndRange in UFbxAnimSequenceImportData to use FInt32Interval.
        /// </summary>
        VER_UE4_FBX_IMPORT_DATA_RANGE_ENCAPSULATION,
        /// <summary>
        /// Adding a new root scene component to camera component.
        /// </summary>
        VER_UE4_CAMERA_COMPONENT_ATTACH_TO_ROOT,
        /// <summary>
        /// Updating custom material expression nodes for instanced stereo implementation.
        /// </summary>
        VER_UE4_INSTANCED_STEREO_UNIFORM_UPDATE,
        /// <summary>
        /// Texture streaming min and max distance to handle HLOD.
        /// </summary>
        VER_UE4_STREAMABLE_TEXTURE_MIN_MAX_DISTANCE,
        /// <summary>
        /// Fixing up invalid struct-to-struct pin connections by injecting available conversion nodes.
        /// </summary>
        VER_UE4_INJECT_BLUEPRINT_STRUCT_PIN_CONVERSION_NODES,
        /// <summary>
        /// Saving tag data for Array Property's inner property.
        /// </summary>
        VER_UE4_INNER_ARRAY_TAG_INFO,
        /// <summary>
        /// Fixed duplicating slot node names in skeleton due to skeleton preload on compile.
        /// </summary>
        VER_UE4_FIX_SLOT_NAME_DUPLICATION,
        /// <summary>
        /// Texture streaming using AABBs instead of Spheres.
        /// </summary>
        VER_UE4_STREAMABLE_TEXTURE_AABB,
        /// <summary>
        /// FPropertyTag stores GUID of property.
        /// </summary>
        VER_UE4_PROPERTY_GUID_IN_PROPERTY_TAG,
        /// <summary>
        /// Name table hashes are calculated and saved out rather than at load time.
        /// </summary>
        VER_UE4_NAME_HASHES_SERIALIZED,
        /// <summary>
        /// Updating custom material expression nodes for instanced stereo implementation refactor.
        /// </summary>
        VER_UE4_INSTANCED_STEREO_UNIFORM_REFACTOR,
        /// <summary>
        /// Added compression to the shader resource for memory savings.
        /// </summary>
        VER_UE4_COMPRESSED_SHADER_RESOURCES,
        /// <summary>
        /// Cooked files contain the dependency graph for the event driven loader (the serialization is largely independent of the use of the new loader).
        /// </summary>
        VER_UE4_PRELOAD_DEPENDENCIES_IN_COOKED_EXPORTS,
        /// <summary>
        /// Cooked files contain the TemplateIndex used by the event driven loader (the serialization is largely independent of the use of the new loader, i.e. this will be null if cooking for the old loader).
        /// </summary>
        VER_UE4_TemplateIndex_IN_COOKED_EXPORTS,
        /// <summary>
        /// FPropertyTag includes contained type(s) for Set and Map properties.
        /// </summary>
        VER_UE4_PROPERTY_TAG_SET_MAP_SUPPORT,
        /// <summary>
        /// Added SearchableNames to the package summary and asset registry.
        /// </summary>
        VER_UE4_ADDED_SEARCHABLE_NAMES,
        /// <summary>
        /// Increased size of SerialSize and SerialOffset in export map entries to 64 bit, allow support for bigger files.
        /// </summary>
        VER_UE4_64BIT_EXPORTMAP_SERIALSIZES,
        /// <summary>
        /// Sky light stores IrradianceMap for mobile renderer.
        /// </summary>
        VER_UE4_SKYLIGHT_MOBILE_IRRADIANCE_MAP,
        /// <summary>
        /// Added flag to control sweep behavior while walking in UCharacterMovementComponent.
        /// </summary>
        VER_UE4_ADDED_SWEEP_WHILE_WALKING_FLAG,
        /// <summary>
        /// StringAssetReference changed to SoftObjectPath and swapped to serialize as a name+string instead of a string.
        /// </summary>
        VER_UE4_ADDED_SOFT_OBJECT_PATH,
        /// <summary>
        /// Changed the source orientation of point lights to match spot lights (z axis).
        /// </summary>
        VER_UE4_POINTLIGHT_SOURCE_ORIENTATION,
        /// <summary>
        /// LocalizationId has been added to the package summary (editor-only).
        /// </summary>
        VER_UE4_ADDED_PACKAGE_SUMMARY_LOCALIZATION_ID,
        /// <summary>
        /// Fixed case insensitive hashes of wide strings containing character values from 128-255.
        /// </summary>
        VER_UE4_FIX_WIDE_STRING_CRC,

        // -----<new versions can be added before this line>-------------------------------------------------
        // - this needs to be the last line (see note below)
        /// <summary>
        /// Last version implemented.
        /// </summary>
        VER_UE4_AUTOMATIC_VERSION_PLUS_ONE,
        /// <summary>
        /// Latest version implemented.
        /// </summary>
        VER_UE4_AUTOMATIC_VERSION = VER_UE4_AUTOMATIC_VERSION_PLUS_ONE - 1
    }
}

```

`src/UETools.Core/FArchive.CodeGen.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Diagnostics.CodeAnalysis;
using System.Linq;
//using UnrealTools.CodeGen.Attributes;
using UETools.Core.Interfaces;

namespace UETools.Core
{
    public partial class FArchive
    {
        /// <summary>
        /// Deserializes array of elements to the <paramref name="item"/> <see cref="List{T}"/>.
        /// </summary>
        /// <param name="item">List of deserialized elements.</param>
        //[SpecializeMethod(typeof(bool), typeof(sbyte), typeof(byte), typeof(short), typeof(ushort), typeof(int), typeof(uint), typeof(long), typeof(ulong), typeof(float), typeof(double), typeof(Guid), typeof(decimal))]//, typeof(string))]
        public FArchive Read<T>([AllowNull] ref List<T> item)
            where T : IUnrealSerializable?, new() 
            => Read(ref item, Read<int>());
        /// <summary>
        /// Deserializes array of elements to the <paramref name="item"/> <see cref="List{T}"/>, using declared <paramref name="length"/>.
        /// </summary>
        /// <param name="item">List of deserialized elements.</param>
        /// <param name="length">Count of elements.</param>
        //[SpecializeMethod(typeof(bool), typeof(sbyte), typeof(byte), typeof(short), typeof(ushort), typeof(int), typeof(uint), typeof(long), typeof(ulong), typeof(float), typeof(double), typeof(Guid), typeof(decimal))]//, typeof(string))]
        public FArchive Read<T>([AllowNull] ref List<T> item, int length) where T : IUnrealSerializable?, new()
        {
            var it = new List<T>(length);
            for (var i = 0; i < length; i++)
            {
                T x = default!;
                Read(ref x);
                it.Add(x);
            }
            item = it;
            return this;
        }

        public FArchive Read([AllowNull] ref List<int> item) => Read(ref item, Read<int>());
        public FArchive Read([AllowNull] ref List<int> item, int length)
        {
            var it = new List<int>(length);
            for (var i = 0; i < length; i++)
            {
                int x = 0;
                Read(ref x);
                it.Add(x);
            }
            item = it;
            return this;
        }
        public FArchive Read([AllowNull] ref List<uint> item) => Read(ref item, Read<int>());
        public FArchive Read([AllowNull] ref List<uint> item, int length)
        {
            var it = new List<uint>(length);
            for (var i = 0; i < length; i++)
            {
                uint x = 0;
                Read(ref x);
                it.Add(x);
            }
            item = it;
            return this;
        }
        public FArchive Read([AllowNull] ref List<ushort> item) => Read(ref item, Read<int>());
        public FArchive Read([AllowNull] ref List<ushort> item, int length)
        {
            var it = new List<ushort>(length);
            for (var i = 0; i < length; i++)
            {
                ushort x = 0;
                Read(ref x);
                it.Add(x);
            }
            item = it;
            return this;
        }
        public FArchive Read([AllowNull] ref List<float> item) => Read(ref item, Read<int>());
        public FArchive Read([AllowNull] ref List<float> item, int length)
        {
            var it = new List<float>(length);
            for (var i = 0; i < length; i++)
            {
                float x = 0;
                Read(ref x);
                it.Add(x);
            }
            item = it;
            return this;
        }

        /// <summary>
        /// Deserializes array of elements to the <paramref name="item"/> <see cref="Dictionary{TKey, TValue}"/>.
        /// </summary>
        /// <param name="item">Dictionary of deserialized elements.</param>
        //[SpecializeMethod(typeof(bool), typeof(sbyte), typeof(byte), typeof(short), typeof(ushort), typeof(int), typeof(uint), typeof(long), typeof(ulong), typeof(float), typeof(double), typeof(Guid), typeof(decimal))]//, typeof(string))]
        public FArchive Read<TKey, TValue>([AllowNull] ref Dictionary<TKey, TValue> item)
            where TKey : notnull, IUnrealSerializable, new()
            where TValue : IUnrealSerializable?, new()
            => Read(ref item, Read<int>());

        /// <summary>
        /// Deserializes array of elements to the <paramref name="item"/> <see cref="Dictionary{TKey, TValue}"/>, using declared <paramref name="length"/>.
        /// </summary>
        /// <param name="item">Dictionary of deserialized elements.</param>
        /// <param name="length">Count of elements.</param>
        //[SpecializeMethod(typeof(bool), typeof(sbyte), typeof(byte), typeof(short), typeof(ushort), typeof(int), typeof(uint), typeof(long), typeof(ulong), typeof(float), typeof(double), typeof(Guid), typeof(decimal))]//, typeof(string))]
        public FArchive Read<TKey, TValue>([AllowNull] ref Dictionary<TKey, TValue> item, int length)
            where TKey : notnull, IUnrealSerializable, new()
            where TValue : IUnrealSerializable?, new()
        {
            var it = new Dictionary<TKey, TValue>(length);
            for (var i = 0; i < length; i++)
            {
                TKey x = default!; 
                TValue y = default!;
                Read(ref x);
                Read(ref y);
                it.Add(x, y);
            }
            item = it;
            return this;
        }

        public FArchive Read([AllowNull] ref Dictionary<ushort, ushort> item)
            => Read(ref item, Read<int>());
        public FArchive Read([AllowNull] ref Dictionary<ushort, ushort> item, int length)
        {
            var it = new Dictionary<ushort, ushort>(length);
            for (var i = 0; i < length; i++)
            {
                ushort x = 0, y = 0;
                Read(ref x);
                Read(ref y);
                it.Add(x, y);
            }
            item = it;
            return this;
        }
    }
}

```

`src/UETools.Core/FArchive.Readers.cs`:

```cs
using System;
using System.Diagnostics.CodeAnalysis;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
using UETools.Core.Interfaces;
using UETools.TypeFactory;

namespace UETools.Core
{
    public partial class FArchive
    {
        /// <summary>
        /// Read value of type <typeparamref name="T"/> from stream.
        /// </summary>
        /// <typeparam name="T">Value type to read from the stream.</typeparam>
        /// <returns>Value read from stream.</returns>
        public T Read<T>() where T : unmanaged
            => MemoryMarshal.Read<T>(Stream.ReadSpanBytes(Unsafe.SizeOf<T>()));

        /// <summary>
        /// Reads instance of the unmanaged type <typeparamref name="T"/> from the data stream.
        /// </summary>
        /// <typeparam name="T">Value type to read from the stream.</typeparam>
        /// <param name="item">Object to initialize.</param>
        public FArchive ReadUnsafe<T>(ref T item) where T : unmanaged
        {
            item = MemoryMarshal.Read<T>(Stream.ReadSpanBytes(Unsafe.SizeOf<T>()));
            return this;
        }
        /// <summary>
        /// Creates new instance of the object and deserializes it from the data stream.
        /// </summary>
        /// <typeparam name="T">Any type implementing <see cref="IUnrealSerializable"/> and has parameterless constructor.</typeparam>
        /// <param name="item">Object to initialize.</param>
        public FArchive Read<T>([NotNull] ref T item) where T : IUnrealSerializable?, new()
        {
            item = Factory<T>.CreateInstance();
            item.Serialize(this);
            return this;
        }

        /// <summary>
        /// Reads <see langword="bool"/> out of data stream.
        /// </summary>
        /// <param name="item">Value to read.</param>
        public FArchive Read(ref bool item)
        {
            item = Stream.ReadBoolean();
            return this;
        }
        /// <summary>
        /// Reads <see langword="sbyte"/> out of data stream.
        /// </summary>
        /// <param name="item">Value to read.</param>
        public FArchive Read(ref sbyte item)
        {
            item = Stream.ReadSByte();
            return this;
        }
        /// <summary>
        /// Reads <see langword="short"/> out of data stream.
        /// </summary>
        /// <param name="item">Value to read.</param>
        public FArchive Read(ref short item)
        {
            item = Stream.ReadInt16();
            return this;
        }
        /// <summary>
        /// Reads <see langword="int"/> out of data stream.
        /// </summary>
        /// <param name="item">Value to read.</param>
        public FArchive Read(ref int item)
        {
            item = Stream.ReadInt32();
            return this;
        }
        /// <summary>
        /// Reads <see langword="long"/> out of data stream.
        /// </summary>
        /// <param name="item">Value to read.</param>
        public FArchive Read(ref long item)
        {
            item = Stream.ReadInt64();
            return this;
        }
        /// <summary>
        /// Reads <see langword="byte"/> out of data stream.
        /// </summary>
        /// <param name="item">Value to read.</param>
        public FArchive Read(ref byte item)
        {
            item = Stream.ReadByte();
            return this;
        }
        /// <summary>
        /// Reads <see langword="ushort"/> out of data stream.
        /// </summary>
        /// <param name="item">Value to read.</param>
        public FArchive Read(ref ushort item)
        {
            item = Stream.ReadUInt16();
            return this;
        }
        /// <summary>
        /// Reads <see langword="uint"/> out of data stream.
        /// </summary>
        /// <param name="item">Value to read.</param>
        public FArchive Read(ref uint item)
        {
            item = Stream.ReadUInt32();
            return this;
        }
        /// <summary>
        /// Reads <see langword="ulong"/> out of data stream.
        /// </summary>
        /// <param name="item">Value to read.</param>
        public FArchive Read(ref ulong item)
        {
            item = Stream.ReadUInt64();
            return this;
        }
        /// <summary>
        /// Reads <see langword="Guid"/> out of data stream.
        /// </summary>
        /// <param name="item">Value to read.</param>
        public FArchive Read(ref Guid item)
        {
            item = MemoryMarshal.Read<Guid>(Stream.ReadSpanBytes(16));
            return this;
        }
        /// <summary>
        /// Reads <see langword="float"/> out of data stream.
        /// </summary>
        /// <param name="item">Value to read.</param>
        public FArchive Read(ref float item)
        {
            item = Stream.ReadSingle();
            return this;
        }
        /// <summary>
        /// Reads <see langword="double"/> out of data stream.
        /// </summary>
        /// <param name="item">Value to read.</param>
        public FArchive Read(ref double item)
        {
            item = Stream.ReadDouble();
            return this;
        }
        /// <summary>
        /// Reads <see langword="decimal"/> out of data stream.
        /// </summary>
        /// <param name="item">Value to read.</param>
        public FArchive Read(ref decimal item)
        {
            item = Stream.ReadDecimal();
            return this;
        }
        /// <summary>
        /// Reads <see langword="string"/> out of data stream.
        /// </summary>
        /// <param name="item">Value to read.</param>
        /// <param name="length"></param>
        internal FArchive Read([AllowNull] ref string item, int length)
        {
            item = Stream.ReadUnrealString(length);
            return this;
        }
        /// <summary>
        /// Reads <see cref="Array"/> of <see langword="byte"/> out of data stream.
        /// </summary>
        /// <param name="item">Value to read.</param>
        public FArchive Read([AllowNull] ref byte[]?item) => Read(ref item, Read<int>());
        /// <summary>
        /// Reads <see cref="Array"/> of <see langword="byte"/> out of data stream, using declared <paramref name="length"/>.
        /// </summary>
        /// <param name="item">Value to read.</param>
        /// <param name="length">Number of bytes to read.</param>
        public FArchive Read([AllowNull] ref byte[] item, int length)
        {
            item = Stream.ReadBytes(length).ToArray();
            return this;
        }
        /// <summary>
        /// Reads <see cref="Span{T}"/> of <see langword="byte"/> out of data stream.
        /// </summary>
        /// <param name="item">Value to read.</param>
        public FArchive Read(ref Span<byte> item) => Read(ref item, Read<int>());
        /// <summary>
        /// Reads <see cref="Span{T}"/> of <see langword="byte"/> out of data stream, using declared <paramref name="length"/>.
        /// </summary>
        /// <param name="item">Value to read.</param>
        /// <param name="length">Number of bytes to read.</param>
        public FArchive Read(ref Span<byte> item, int length)
        {
            item = Stream.ReadSpanBytes(length);
            return this;
        }
        /// <summary>
        /// Reads <see cref="Memory{T}"/> of <see langword="byte"/> out of data stream.
        /// </summary>
        /// <param name="item">Value to read.</param>
        public FArchive Read(ref Memory<byte> item) => Read(ref item, Read<int>());
        /// <summary>
        /// Reads <see cref="Memory{T}"/> of <see langword="byte"/> out of data stream, using declared <paramref name="length"/>.
        /// </summary>
        /// <param name="item">Value to read.</param>
        /// <param name="length">Number of bytes to read.</param>
        public FArchive Read(ref Memory<byte> item, int length)
        {
            item = Stream.ReadBytes(length);
            return this;
        }
    }
}

```

`src/UETools.Core/FArchive.Tables.cs`:

```cs
using System;
using System.Collections.Concurrent;
using System.Diagnostics.CodeAnalysis;
using System.Linq;
using System.Runtime.CompilerServices;
using UETools.Core.Interfaces;

namespace UETools.Core
{
    public partial class FArchive
    {
        /// <summary>
        /// Gets instance of <see cref="UnrealTable{T}"/> that has been added with name <paramref name="tableName"/> and has entries of type <typeparamref name="T"/>.
        /// </summary>
        /// <typeparam name="T">Type of keys the found instance stores.</typeparam>
        /// <param name="tableName">Name of instance in the tables dictionary.</param>
        /// <returns>Instance of the type deriving from <see cref="UnrealTable{T}"/> with specified name, or null.</returns>
        public UnrealTable<T>? GetTable<T>(string tableName) where T : notnull
            => Tables.TryGetValue(tableName, out var table) ? table as UnrealTable<T> : default;

        /// <summary>
        /// Searches for first table that stores entries of type <typeparamref name="T"/>, and returns its instance on success.
        /// </summary>
        /// <typeparam name="T">Type of keys the found instance stores.</typeparam>
        /// <param name="table">Found instance</param>
        /// <returns><see langword="true"/> if instance has been found; otherwise <see langword="false"/>.</returns>
        public bool FindTableOfType<T>([NotNullWhen(true)] out UnrealTable<T>? table) where T : notnull
        {
            var kv = Tables.FirstOrDefault(t => t.Value is UnrealTable<T>);
            table = kv.Value as UnrealTable<T>;
            return table != null;
        }

        public bool FindTagSubstream(string tag, [NotNullWhen(true)] out FArchive? tagData) 
        => (tagData = Stream.FindElement(tag, out var segment) switch
        {
            true => Slice(segment!.RunningIndex),
            false => null
        }) is not null;

        internal ConcurrentDictionary<string, IUnrealTable> Tables { get; private set; } = new ConcurrentDictionary<string, IUnrealTable>();
        public IUnrealLocalizationProvider? Localization { get; set; }
    }
}

```

`src/UETools.Core/FArchive.cs`:

```cs
using System;
using System.Buffers;
using System.IO;
using System.Threading.Tasks;
using UETools.Core.Enums;
using UETools.Core.Interfaces;

namespace UETools.Core
{
    /// <summary>
    /// Representation of Unreal Engine 4 binary data stream reader/writer
    /// </summary>
    public partial class FArchive : IDisposable
    {
        public FArchive FindParent() => Parent is null ? this : Parent.FindParent();
        private FArchive? Parent { get; set; }
        /// <summary>
        /// Version of the asset, separate from serialized UObject <see cref="Version"/>.
        /// </summary>
        public int AssetVersion { get; set; }
        /// <summary>
        /// Subversion of the asset.
        /// </summary>
        /// <remarks>Use only for backwards incompatible changes checks.</remarks>
        public int AssetSubversion { get; set; }
        /// <summary>
        /// Version of the package being read.
        /// </summary>
        public UE4Version Version { get; set; }
        /// <summary>
        /// Licensee specific version of the package being read.
        /// </summary>
        public int LicenseeVersion { get; set; }

        // Some constructors?
        public FArchive(Memory<byte> memory) : this(new MemoryReader(memory)) { }
        public FArchive(IMemoryOwner<byte> memory) : this(new MemoryReader(memory)) { }
        public FArchive(DataSegment memory) : this(new MemoryReader(memory)) { }
        public FArchive(IUnrealValueReader reader) : this(reader, true) { }

        private FArchive(Memory<byte> memory, bool ownsStream) : this(new MemoryReader(memory), ownsStream) { }
        private FArchive(IUnrealValueReader reader, bool ownsStream)
        {
            Stream = reader;
            OwnsStream = ownsStream;
        }

        /// <summary>
        /// Sets the position within the current stream counting from <see cref="SeekOrigin.Current"/> by <paramref name="len"/> bytes.
        /// </summary>
        /// <param name="len">Count of bytes to move stream forward.</param>
        /// <returns>The new position within the current stream.</returns>
        public long Skip(long len) => Stream.Seek(len, SeekOrigin.Current);
        /// <summary>
        /// Sets the position within the current stream.
        /// </summary>
        /// <param name="offset">A byte offset relative to the <paramref name="origin"/> parameter.</param>
        /// <param name="origin">A value of type <see cref="SeekOrigin"/> indicating the reference point used to obtain the new position.</param>
        /// <returns>The new position within the current stream.</returns>
        public long Seek(long offset, SeekOrigin origin) => Stream.Seek(offset, origin);
        /// <summary>
        /// Sets the position within the current stream counting from <see cref="SeekOrigin.Begin"/>.
        /// </summary>
        /// <param name="offset">A byte offset relative to the start of the stream.</param>
        /// <returns>The new position within the current stream.</returns>
        public long Seek(long offset) => Seek(offset, SeekOrigin.Begin);
        /// <summary>
        /// Gets current position in the data stream.
        /// </summary>
        /// <returns>Current position in the data stream.</returns>
        public long Tell() => Stream.Position;
        /// <summary>
        /// Gets the length of the stream in bytes.
        /// </summary>
        /// <returns>Length of the stream in bytes.</returns>
        public long Length() => Stream.Length;
        /// <summary>
        /// Checks whether we've reached the end of the stream.
        /// </summary>
        /// <returns><see langword="true"/> if <see cref="Length()"/> is greater than current stream position; otherwise <see langword="false"/>.</returns>
        public bool EOF() => Tell() >= Length();

        public FArchive Slice(long offset) => new FArchive(Stream.Slice(offset), false)
        {
            Parent = this,
            Tables = this.Tables,
            Version = this.Version,
            AssetVersion = this.AssetVersion,
            AssetSubversion = this.AssetSubversion,
            Localization = this.Localization,
        };
        public FArchive SubStream(int length) => new FArchive(Stream.ReadBytes(length))
        {
            Parent = this,
            Tables = this.Tables,
            Version = this.Version,
            AssetVersion = this.AssetVersion,
            AssetSubversion = this.AssetSubversion,
            Localization = this.Localization,
        };
        public FArchive SubStream(long offset, int length)
        {
            Stream.Seek(offset, SeekOrigin.Begin);
            return SubStream(length);
        }

        /// <summary>
        /// Disposes underlying data stream.
        /// </summary>
        public void Dispose()
        {
            if (OwnsStream)
            {
                Stream.Dispose();
            }
        }

        private IUnrealValueReader Stream { get; set; }
        private bool OwnsStream { get; }
    }
}

```

`src/UETools.Core/FName.cs`:

```cs
using System;
using System.Diagnostics;
using System.Diagnostics.CodeAnalysis;
using UETools.Core.Interfaces;

namespace UETools.Core
{
    [DebuggerDisplay("{Name.ToString()}")]
    public class FName : IUnrealSerializable, IEquatable<FName>, IEquatable<FString>, IEquatable<string>
    {
        /// <summary>
        /// Invalid index, signifies uninitialized FName.
        /// </summary>
        public const int INDEX_NONE = -1;

        public static implicit operator string(FName name) => name.Name.ToString();
        public static implicit operator FName(string str) => new FName(str);
        public static implicit operator FName(FString str) => new FName(str);
        public static bool operator ==(FName first, FName second) => first.Equals(second);
        public static bool operator !=(FName first, FName second) => !first.Equals(second);

        public FString Name { get; private set; }
        private int Index => _displayId;

        public FName(FString name) => Name = name;
        public FName(string name) : this(new FString(name)) { }
        public FName() : this(new FString()) { }

        public FArchive Serialize(FArchive archive)
        {
            archive.Read(ref _displayId)
                   .Read(ref _comparisionId);
            if (archive.GetTable<FString>("Names") is NameTable table)
            {
                var items = table.Items;
                if (items.Count > Index && Index >= 0)
                    Name = items[Index];
                else
                    throw new ArgumentOutOfRangeException(nameof(Index), $"{Index} not in GNames({items.Count} elements).");
            }
            else
                throw new UnrealException($"{nameof(NameTable)} not serialized before {nameof(FName)} access.");

            return archive;
        }
        public bool IsNone() => IsIndexNone() || IsStringNone();
        private bool IsIndexNone() => Index == INDEX_NONE;
        private bool IsStringNone() => Name == string.Empty || Name == "None";

        public override int GetHashCode() => HashCode.Combine(Name, Index);
        public bool Equals([AllowNull] FName other)
        {
            if (other is null)
                return false;

            return IsIndexNone() || other.IsIndexNone() ? other.Equals(Name) : Index == other.Index && _comparisionId == other._comparisionId;
        }
        public bool Equals([AllowNull] FString other) => Name.Equals(other);
        public bool Equals([AllowNull] string other) => Name.Equals(other);
        public override bool Equals(object? obj) => obj switch
        {
            FName other => Equals(other),
            FString other => Equals(other),
            string other => Equals(other),
            _ => base.Equals(obj)
        };

        public override string ToString() => Name.ToString();


        private int _displayId = INDEX_NONE;
        private int _comparisionId;
    }
}

```

`src/UETools.Core/FString.Boilerplate.cs`:

```cs
using System;
using System.Collections;
using System.Collections.Generic;
using System.Diagnostics.CodeAnalysis;
using System.Text;

namespace UETools.Core
{
    public partial class FString
    {
        /// <summary>
        /// Implicit conversion from Unreal <see cref="FString"/> instance to <see langword="string"/>.
        /// </summary>
        /// <param name="value">Instance to get string from.</param>
        public static implicit operator string(FString value) => value.ToString();
        /// <summary>
        /// Implicit conversion from <see langword="string"/> to Unreal <see cref="FString"/> instance.
        /// </summary>
        /// <param name="value"></param>
        public static implicit operator FString(string value) => new FString(value);

        /// <summary>
        /// Gets underlying <see langword="string"/> value.
        /// </summary>
        /// <returns>Underlying <see langword="string"/>.</returns>
        public override string ToString()
        {
            if (Value is null)
                NotDeserializedException.Throw();

            return Value;
        }
        /// <summary>
        /// Gets combined hash of underlying <see langword="string"/> and its <see cref="Encoding"/>.
        /// </summary>
        /// <returns>Combined hash of underlying <see langword="string"/> and recognized <see cref="Encoding"/></returns>
        public override int GetHashCode() => HashCode.Combine(Value.GetHashCode(), UsedEncoding.GetHashCode()); // Strings might be the same, but with different encoding? not sure if I should differentiate that

        /// <summary>
        /// Determines whether the this instance and another specified <see langword="object"/> are equal, trying to use specialized comparer when possible.
        /// </summary>
        /// <param name="obj">The <see langword="object"/> to compare with the current <see langword="object"/>.</param>
        /// <returns><see langword="true"/> if the specified object is equal to the current object; otherwise, <see langword="false"/>.</returns>
        public override bool Equals(object? obj) =>
            obj switch
            {
                FString str => Equals(str),
                string str => Equals(str),
                _ => base.Equals(obj)
            };
        /// <summary>
        /// Determines whether this instance and another specified <see langword="string"/> object have the same value.
        /// </summary>
        /// <param name="other">The <see langword="string"/> to compare to this instance.</param>
        /// <returns><see langword="true"/> if the value of the value parameter is the same as the value of this instance; otherwise, <see langword="false"/>. If value is <see langword="null"/>, the method returns <see langword="false"/>.</returns>
        public bool Equals([AllowNull] string other) => Value.Equals(other);
        /// <summary>
        /// Determines whether this instance and another specified <see cref="FString"/> object have the same underlying <see langword="string"/> value.
        /// </summary>
        /// <param name="other">The instance to compare with.</param>
        /// <returns><see langword="true"/> if the value of the value parameter is the same as the value of this instance; otherwise, <see langword="false"/>. If value is <see langword="null"/>, the method returns <see langword="false"/>.</returns>
        public bool Equals([AllowNull] FString other) => Value.Equals(other?.Value);

        /// <summary>
        /// Retrieves an object that can iterate through the individual characters in the underlying string.
        /// </summary>
        /// <returns>An enumerator object of the underlying string.</returns>
        public CharEnumerator GetEnumerator() => Value.GetEnumerator();
        IEnumerator<char> IEnumerable<char>.GetEnumerator() => GetEnumerator();
        IEnumerator IEnumerable.GetEnumerator() => GetEnumerator();

        /// <summary>
        /// Compares this instance with a specified <see langword="string"/> and indicates whether this instance precedes, follows, or appears in the same position in the sort order as the specified <see langword="string"/>.
        /// </summary>
        /// <param name="other">The <see langword="string"/> to compare with this instance.</param> 
        /// <returns>A 32-bit signed integer that indicates whether this instance precedes, follows, or appears in the same position in the sort order as the <paramref name="other"/> parameter.</returns>
        public int CompareTo(string? other) => Value.CompareTo(other);
        /// <summary>
        /// Compares this instance with a specified <see langword="object"/> and indicates whether this instance precedes, follows, or appears in the same position in the sort order as the specified <see langword="object"/>.
        /// </summary>
        /// <param name="obj">An <see langword="object"/> that evaluates to a <see langword="string"/>.</param> 
        /// <returns>A 32-bit signed integer that indicates whether this instance precedes, follows, or appears in the same position in the sort order as the <paramref name="obj"/> parameter.</returns>
        public int CompareTo(object? obj) => Value.CompareTo(obj);

        /// <summary>
        /// Determines whether two specified <see cref="FString"/> instances have the same value.
        /// </summary>
        /// <param name="first">First instance to use for comparision.</param>
        /// <param name="second">Second instance to use for comparision.</param>
        /// <returns><see langword="true"/> if parameters are equal; otherwise <see langword="false"/>.</returns>
        public static bool operator ==(FString first, FString second) => first.Equals(second);
        /// <summary>
        /// Determines whether two specified <see cref="FString"/> instances have the different value.
        /// </summary>
        /// <param name="first">First instance to use for comparision.</param>
        /// <param name="second">Second instance to use for comparision.</param>
        /// <returns><see langword="true"/> if parameters are not equal; otherwise <see langword="false"/>.</returns>
        public static bool operator !=(FString first, FString second) => !first.Equals(second);
        /// <summary>
        /// Determines whether <see langword="string"/> and <see cref="Value"/> have the same value.
        /// </summary>
        /// <param name="first"><see langword="string"/> to use for comparision.</param>
        /// <param name="second"><see cref="FString"/> instance to use for comparision.</param>
        /// <returns><see langword="true"/> if parameters are equal; otherwise <see langword="false"/>.</returns>
        public static bool operator ==(string first, FString second) => first.Equals(second.Value);
        /// <summary>
        /// Determines whether <see langword="string"/> and <see cref="Value"/> have the different value.
        /// </summary>
        /// <param name="first"><see langword="string"/> to use for comparision.</param>
        /// <param name="second"><see cref="FString"/> instance to use for comparision.</param>
        /// <returns><see langword="true"/> if parameters are not equal; otherwise <see langword="false"/>.</returns>
        public static bool operator !=(string first, FString second) => !first.Equals(second.Value);
        /// <summary>
        /// Determines whether <see cref="Value"/> and <see langword="string"/> have the same value.
        /// </summary>
        /// <param name="first"><see cref="FString"/> instance to use for comparision.</param>
        /// <param name="second"><see langword="string"/> to use for comparision.</param>
        /// <returns><see langword="true"/> if parameters are equal; otherwise <see langword="false"/>.</returns>
        public static bool operator ==(FString first, string second) => first.Equals(second);
        /// <summary>
        /// Determines whether <see cref="Value"/> and <see langword="string"/> have the different value.
        /// </summary>
        /// <param name="first"><see cref="FString"/> instance to use for comparision.</param>
        /// <param name="second"><see langword="string"/> to use for comparision.</param>
        /// <returns><see langword="true"/> if parameters are not equal; otherwise <see langword="false"/>.</returns>
        public static bool operator !=(FString first, string second) => !first.Equals(second);
    }
}

```

`src/UETools.Core/FString.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Text;
using UETools.Core.Interfaces;

namespace UETools.Core
{
    /// <summary>
    /// Unreal Engine 4 FString implementation.
    /// </summary>
    /// <remarks><see langword="string"/> class implementation doesn't contain parameterless constructor, which made this class necessary.</remarks>
    [DebuggerDisplay("{Value}")]
    public sealed partial class FString : IUnrealSerializable, IEnumerable<char>, IEquatable<FString>, IEquatable<string>, IComparable<string>, IComparable
    {
        /// <summary>
        /// Deserialized value of the string instance.
        /// </summary>
        public string Value { get => _value; private set => _value = value; }
        /// <summary>
        /// Length of the string, as serialized.
        /// </summary>
        /// <remarks>Negative length denotes UTF16</remarks>
        public int Length => IsWide ? -_length : _length;
        /// <summary>
        /// Returns whether strings is using <see cref="UTF8Encoding"/> or <see cref="UnicodeEncoding"/>
        /// </summary>
        /// <value><see langword="true"/> if <see langword="string"/> is encoded using <see cref="UnicodeEncoding"/> or <see langword="false"/> if <see cref="UTF8Encoding"/></value>
        /// <remarks>Negative length denotes UTF16</remarks>
        public bool IsWide => _length < 0;

        /// <summary>
        /// Creates new string with <see cref="string.Empty"/> as value.
        /// </summary>
        public FString() : this(string.Empty) { }
        /// <summary>
        /// Creates new string using <paramref name="value"/>.
        /// </summary>
        /// <param name="value">Value to assign to the underlying string.</param>
        public FString(string value) => _value = value;

        /// <inheritdoc />
        public FArchive Serialize(FArchive archive)
            => archive.Read(ref _length)
                      .Read(ref _value, _length);

        private int ByteCount => Length * CharSize;
        private int CharSize
        {
            get
            {
                if (!_charSize.HasValue)
                    _charSize = UsedEncoding.GetByteCount(" ");

                return _charSize.Value;
            }
        }
        private Encoding UsedEncoding => IsWide ? Encoding.Unicode : Encoding.UTF8;

        private int _length;
        private int? _charSize;
        private string _value = null!;
    }
}

```

`src/UETools.Core/FText.cs`:

```cs
using System;
using System.Diagnostics;
using UETools.Core.Enums;
using UETools.Core.HistoryTypes;
using UETools.Core.Interfaces;

namespace UETools.Core
{
    [DebuggerDisplay("FText: {ToString()}")]
    public sealed class FText : IUnrealSerializable
    {
        public FText() : this(null!) { }
        private FText(FTextHistory history) => _history = history;

        public FArchive Serialize(FArchive archive)
        {
            archive.ReadUnsafe(ref _flags);
            if (archive.Version < UE4Version.VER_UE4_FTEXT_HISTORY)
            {
                var baseHistory = (FTextHistory.Base)_history;
                FString? _value = baseHistory.Value;
                archive.Read(ref _value);
                if (archive.Version >= UE4Version.VER_UE4_ADDED_NAMESPACE_AND_KEY_DATA_TO_FTEXT)
                    _history = new FTextHistory.Base(_value);
                else
                {
                    FString? _namespace = baseHistory.Namespace, _key = baseHistory.Key;
                    archive.Read(ref _namespace)
                          .Read(ref _key);
                    _history = new FTextHistory.Base(_value, _namespace, _key);
                }
            }
            else
            {
                TextHistoryType HistoryType = TextHistoryType.None;
                archive.ReadUnsafe(ref HistoryType);
                if (FTextHistory.HistoryTypes.TryGetValue(HistoryType, out var init))
                {
                    _history = init();
                    _history.Serialize(archive);
                }
                else
                    Debug.WriteLine($"HistoryType unrecognized: {HistoryType}");
            }
            return archive;
        }
        public override string ToString()
        {
            if (_history is null)
                NotDeserializedException.Throw();

            return _history.ToString();
        }

        // TODO: Static methods for history types
        public static FText GetEmpty() => new FText();
        public static FText FromString(FString value)
        {
            var history = new FTextHistory.Base(value);
            return new FText(history);
        }
        public static FText FromDate(DateTime date)
        {
            var history = new FTextHistory.AsDate(date);
            return new FText(history);
        }
        public static FText FromStringTable()
        {
            var history = new FTextHistory.StringTableEntry();
            return new FText(history);
        }
        public static FText AsCultureInvariant(FString value)
        {
            return new FText();
        }

        private TextFlag _flags;
        private FTextHistory _history;
    }
}
```

`src/UETools.Core/HexString.cs`:

```cs
using System;
using System.Linq;
using System.Runtime.InteropServices;

namespace UETools.Core
{
    public static class HexString
    {
        static readonly uint[] _lookup32 = Enumerable.Range(0, 256).Select(i =>
        {
            string s = i.ToString("X2");
            if (BitConverter.IsLittleEndian)
                return s[0] + ((uint)s[1] << 16);
            else
                return s[1] + ((uint)s[0] << 16);
        }).ToArray();

        public static string FromByteArray(ReadOnlyMemory<byte> bytes) => StringHelper.Create(bytes.Length * 2, bytes, (chars, b) =>
        {
            var span = bytes.Span;
            var x = MemoryMarshal.Cast<char, uint>(chars);
            for (var i = bytes.Length - 1; i >= 0; i--)
            {
                x[i] = _lookup32[span[i]];
            }
        });
    }
}

```

`src/UETools.Core/HistoryTypes/ArgumentFormat.cs`:

```cs
using System.Collections.Generic;

namespace UETools.Core.HistoryTypes
{
    internal partial class FTextHistory
    {
        internal sealed class ArgumentFormat : FTextHistory
        {
            public override FArchive Serialize(FArchive archive)
                => archive.Read(ref _format)
                          .Read(ref _arguments);

            public override string ToString()
            {
                if (_format is null || _arguments is null)
                    NotDeserializedException.Throw();

                var EndValue = _format.ToString();
                foreach (var arg in _arguments)
                    EndValue = arg.Replace(EndValue);

                return EndValue;
            }

            private FText _format = null!;
            private List<FFormatArgumentData> _arguments = null!;
        }
    }
}

```

`src/UETools.Core/HistoryTypes/AsCurrency.cs`:

```cs
using UETools.Core.Enums;

namespace UETools.Core.HistoryTypes
{
    internal partial class FTextHistory
    {
        internal sealed class AsCurrency : FormatNumber
        {
            public override FArchive Serialize(FArchive archive)
            {
                if (archive.Version >= UE4Version.VER_UE4_ADDED_CURRENCY_CODE_TO_FTEXT)
                    archive.Read(ref _currencyCode);

                return base.Serialize(archive);
            }
            public override string ToString() => _currencyCode is null
                ? base.ToString()
                : $"{base.ToString()} {_currencyCode.ToString()}";

            private FString? _currencyCode;
        }
    }
}

```

`src/UETools.Core/HistoryTypes/AsDate.cs`:

```cs
using System;
using UETools.Core.Enums;

namespace UETools.Core.HistoryTypes
{
    internal partial class FTextHistory
    {
        internal sealed class AsDate : FTextHistory
        {
            public AsDate() { }
            public AsDate(DateTime date)
            {
                _sourceDateTime = (ulong)date.ToUniversalTime().Date.Ticks;
                _dateStyle = DateTimeStyle.Default;
            }
            public override FArchive Serialize(FArchive archive)
            {
                archive.Read(ref _sourceDateTime)
                      .ReadUnsafe(ref _dateStyle);
                if (archive.Version >= UE4Version.VER_UE4_FTEXT_HISTORY_DATE_TIMEZONE)
                    archive.Read(ref _timeZone);

                return archive.Read(ref _cultureName);
            }

            public override string ToString()
            {
                return new DateTime((long)_sourceDateTime).Date.ToString();
            }

            private ulong _sourceDateTime;
            private DateTimeStyle _dateStyle;
            private FString? _timeZone;
            private FString _cultureName = null!;
        }
    }
}

```

`src/UETools.Core/HistoryTypes/AsDateTime.cs`:

```cs
using System;
using UETools.Core.Enums;

namespace UETools.Core.HistoryTypes
{
    internal partial class FTextHistory
    {
        internal sealed class AsDateTime : FTextHistory
        {
            public override FArchive Serialize(FArchive archive)
                => archive.Read(ref _sourceDateTime)
                          .ReadUnsafe(ref _dateStyle)
                          .ReadUnsafe(ref _timeStyle)
                          .Read(ref _timeZone)
                          .Read(ref _cultureName);

            public override string ToString()
            {
                return new DateTime((long)_sourceDateTime).ToString();
            }

            private ulong _sourceDateTime;
            private DateTimeStyle _dateStyle;
            private DateTimeStyle _timeStyle;
            private FString _timeZone = null!;
            private FString _cultureName = null!;
        }
    }
}

```

`src/UETools.Core/HistoryTypes/AsNumber.cs`:

```cs
using static UETools.Core.HistoryTypes.FTextHistory;

namespace UETools.Core.HistoryTypes
{
    internal partial class FTextHistory
    {
        internal sealed class AsNumber : FormatNumber
        {
            public override string ToString()
            {
                return base.ToString();
            }
        }
    }
}

```

`src/UETools.Core/HistoryTypes/AsPercent.cs`:

```cs
using static UETools.Core.HistoryTypes.FTextHistory;

namespace UETools.Core.HistoryTypes
{
    internal partial class FTextHistory
    {
        internal sealed class AsPercent : FormatNumber
        {
            public override string ToString()
            {
                return base.ToString();
            }
        }
    }
}

```

`src/UETools.Core/HistoryTypes/AsTime.cs`:

```cs
using System;
using UETools.Core.Enums;

namespace UETools.Core.HistoryTypes
{
    internal partial class FTextHistory
    {
        internal sealed class AsTime : FTextHistory
        {
            public override FArchive Serialize(FArchive archive)
                => archive.Read(ref _sourceDateTime)
                          .ReadUnsafe(ref _timeStyle)
                          .Read(ref _timeZone)
                          .Read(ref _cultureName);

            public override string ToString()
            {
                if (_timeZone is null || _cultureName is null)
                    NotDeserializedException.Throw();

                return new DateTime((long)_sourceDateTime).TimeOfDay.ToString();
            }

            private ulong _sourceDateTime;
            private DateTimeStyle _timeStyle;
            private FString _timeZone = null!;
            private FString _cultureName = null!;
        }
    }
}

```

`src/UETools.Core/HistoryTypes/Base.cs`:

```cs
using UETools.Core.Interfaces;

namespace UETools.Core.HistoryTypes
{
    internal partial class FTextHistory
    {
        internal sealed class Base : FTextHistory
        {
            public FString? Value { get => _value; set => _value = value; }
            public FString? Key { get => _key; set => _key = value; }
            public FString? Namespace { get => _namespace; set => _namespace = value; }

            public Base() { }
            public Base(FString value) : this(value, null!, null!) { }
            public Base(FString value, FString localizationNamespace, FString localizationKey) => (_namespace, _key, _value) = (localizationNamespace, localizationKey, value);

            public override FArchive Serialize(FArchive archive)
            {
                archive.Read(ref _namespace)
                       .Read(ref _key)
                       .Read(ref _value);

                _localizedString = archive.Localization?.Get(_namespace, _key);

                return archive;
            }

            public override string ToString()
            {
                if (_value is null)
                    NotDeserializedException.Throw();

                return _localizedString ?? _value.ToString();
            }

            private FString? _namespace;
            private FString? _key;
            private FString? _value;
            private string? _localizedString;
        }
    }
}

```

`src/UETools.Core/HistoryTypes/FFormatArgumentData.cs`:

```cs
using System.Diagnostics;
using UETools.Core.Enums;
using UETools.Core.Interfaces;

namespace UETools.Core.HistoryTypes
{
    [DebuggerDisplay("{_argumentName.ToString()}: {_argumentValue.ToString()}")]
    class FFormatArgumentData : IUnrealSerializable
    {
        public FArchive Serialize(FArchive archive)
        {
            if (archive.Version >= UE4Version.VER_UE4_K2NODE_VAR_REFERENCEGUIDS)
            {
                FString? _arg = default;
                archive.Read(ref _arg);
                _argumentName = FText.FromString(_arg);
            }
            else
                archive.Read(ref _argumentName);

            return archive.Read(ref _argumentValue);
        }

        public string Replace(string sourceValue)
        {
            if (_argumentName is null || _argumentValue is null)
                NotDeserializedException.Throw();

            return sourceValue.Replace(_argumentName.ToString(), _argumentValue.ToString());
        }

        private FText _argumentName = null!;
        private FFormatArgumentValue _argumentValue = null!;
    }
}
```

`src/UETools.Core/HistoryTypes/FFormatArgumentValue.cs`:

```cs
using System;
using UETools.Core.Enums;
using UETools.Core.Interfaces;

namespace UETools.Core.HistoryTypes
{
    class FFormatArgumentValue : IUnrealSerializable
    {
        public object Value { get; private set; } = null!;

        public FArchive Serialize(FArchive archive)
        {
            archive.ReadUnsafe(ref _type);
            switch (_type)
            {
                case FormatArgumentType.Int:
                    {
                        long value = default!;
                        archive.Read(ref value);
                        Value = value;
                        break;
                    }
                case FormatArgumentType.UInt:
                    {
                        ulong value = default!;
                        archive.Read(ref value);
                        Value = value;
                        break;
                    }
                case FormatArgumentType.Float:
                    {
                        float value = default!;
                        archive.Read(ref value);
                        Value = value;
                        break;
                    }
                case FormatArgumentType.Double:
                    {
                        double value = default!;
                        archive.Read(ref value);
                        Value = value;
                        break;
                    }
                case FormatArgumentType.Text:
                    {
                        FText value = default!;
                        archive.Read(ref value);
                        Value = value;
                        break;
                    }
                case FormatArgumentType.Gender:
                    {
                        TextGender value = default!;
                        archive.ReadUnsafe(ref value);
                        Value = value;
                        break;
                    }
                default:
                    throw new NotImplementedException();
            }
            return archive;
        }

        public override string ToString()
        { 
            if (Value is null) 
                NotDeserializedException.Throw(); 
            return Value.ToString()!; 
        }

        private FormatArgumentType _type;
    }
}
```

`src/UETools.Core/HistoryTypes/FNumberFormattingOptions.cs`:

```cs
using UETools.Core.Enums;
using UETools.Core.Interfaces;

namespace UETools.Core.HistoryTypes
{
    class FNumberFormattingOptions : IUnrealSerializable
    {
        public bool AlwaysSign { get => _alwaysSign; set => _alwaysSign = value; }
        public bool UseGrouping { get => _useGrouping; set => _useGrouping = value; }
        internal RoundingMode RoundingMode { get => _roundingMode; set => _roundingMode = value; }
        public int MinimumIntegralDigits { get => _minimumIntegralDigits; set => _minimumIntegralDigits = value; }
        public int MaximumIntegralDigits { get => _maximumIntegralDigits; set => _maximumIntegralDigits = value; }
        public int MinimumFractionalDigits { get => _minimumFractionalDigits; set => _minimumFractionalDigits = value; }
        public int MaximumFractionalDigits { get => _maximumFractionalDigits; set => _maximumFractionalDigits = value; }

        public FArchive Serialize(FArchive archive) =>
            // TODO: Dependent on custom versions
            //archive.Read(ref _alwaysSign);
            archive.Read(ref _useGrouping)
                   .ReadUnsafe(ref _roundingMode)
                   .Read(ref _minimumIntegralDigits)
                   .Read(ref _maximumIntegralDigits)
                   .Read(ref _minimumFractionalDigits)
                   .Read(ref _maximumFractionalDigits);

        private bool _alwaysSign;
        private bool _useGrouping;
        private RoundingMode _roundingMode;
        private int _minimumIntegralDigits;
        private int _maximumIntegralDigits;
        private int _minimumFractionalDigits;
        private int _maximumFractionalDigits;

    }
}
```

`src/UETools.Core/HistoryTypes/FTextHistory.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Linq;
using UETools.Core.Enums;
using UETools.Core.Interfaces;
using UETools.TypeFactory;

namespace UETools.Core.HistoryTypes
{
    internal abstract partial class FTextHistory : IUnrealSerializable
    {
        public abstract FArchive Serialize(FArchive archive);

        internal static IReadOnlyDictionary<TextHistoryType, Func<FTextHistory>> HistoryTypes { get; } = new ReadOnlyDictionary<TextHistoryType, Func<FTextHistory>>(
            Enum.GetValues(typeof(TextHistoryType))
            .Cast<TextHistoryType>()
            .ToDictionary(
                x => x,
                x => Factory.CreateInstanceFunction<FTextHistory>(
                    x.GetAttribute<LinkedTypeAttribute, TextHistoryType>()!.LinkedType
                    )
                )
            );

        public override string ToString() => string.Empty;
    }
}

```

`src/UETools.Core/HistoryTypes/FormatNumber.cs`:

```cs
using System.Globalization;
using UETools.Core;

namespace UETools.Core.HistoryTypes
{
    internal partial class FTextHistory
    {
        internal class FormatNumber : FTextHistory
        {
            protected FFormatArgumentValue SourceValue => _sourceValue;
            protected CultureInfo Culture { get; private set; } = null!;

            public override FArchive Serialize(FArchive archive)
            {
                var hasFormatOptions = false;
                archive.Read(ref _sourceValue)
                      .Read(ref hasFormatOptions);

                if (hasFormatOptions)
                    archive.Read(ref _formatting);

                archive.Read(ref _cultureName);
                Culture = CultureInfo.GetCultureInfoByIetfLanguageTag(_cultureName);
                return archive;
            }

            protected string BuildDisplayString()
            {
                // TODO: Formatting
                if (_sourceValue is null)
                    NotDeserializedException.Throw();

                switch (SourceValue.Value)
                {
                    case long value:
                        break;
                    case ulong value:
                        break;
                    case float value:
                        break;
                    case double value:
                        break;
                }
                return base.ToString();
            }

            public override string ToString() => BuildDisplayString();


            private FString _cultureName = null!;
            private FFormatArgumentValue _sourceValue = null!;
            private FNumberFormattingOptions? _formatting;
        }
    }
}
```

`src/UETools.Core/HistoryTypes/NamedFormat.cs`:

```cs
namespace UETools.Core.HistoryTypes
{
    internal partial class FTextHistory
    {
        internal sealed class NamedFormat : FTextHistory
        {
            public override FArchive Serialize(FArchive archive)
                => archive.Read(ref _format)
                          .Read(ref _argument);

            public override string ToString()
            {
                if (_format is null || _argument is null)
                    NotDeserializedException.Throw();

                return _argument.Replace(_format.ToString());
            }

            private FText _format = null!;
            private FFormatArgumentData _argument = null!;
        }
    }
}

```

`src/UETools.Core/HistoryTypes/None.cs`:

```cs
namespace UETools.Core.HistoryTypes
{
    internal partial class FTextHistory
    {
        internal sealed class None : FTextHistory
        {
            public override FArchive Serialize(FArchive archive) => archive;
            public override string ToString() => string.Empty;
        }
    }
}

```

`src/UETools.Core/HistoryTypes/OrderedFormat.cs`:

```cs
using System.Collections.Generic;

namespace UETools.Core.HistoryTypes
{
    internal partial class FTextHistory
    {
        internal sealed class OrderedFormat : FTextHistory
        {
            public override FArchive Serialize(FArchive archive)
                => archive.Read(ref _format)
                          .Read(ref _arguments);

            public override string ToString()
            {
                if (_format is null || _arguments is null)
                    NotDeserializedException.Throw();

                return string.Format(_format.ToString(), _arguments.ToArray());
            }

            private FText _format = null!;
            private List<FFormatArgumentValue> _arguments = null!;
        }
    }
}

```

`src/UETools.Core/HistoryTypes/StringTableEntry.cs`:

```cs
using System;

namespace UETools.Core.HistoryTypes
{
    internal partial class FTextHistory
    {
        internal sealed class StringTableEntry : FTextHistory
        {
            public override FArchive Serialize(FArchive archive)
            {
                archive.Read(ref _tableId).Read(ref _key);
                // TODO: Read object 'TableID' as StringTable, get value for 'Key'
                throw new NotImplementedException($"{nameof(StringTableEntry)} parsing not implemented.");
                return archive;
            }

            public override string ToString()
            {
                return base.ToString();
            }

            private FName _tableId = null!;
            private FString _key = null!;
        }
    }
}

```

`src/UETools.Core/HistoryTypes/Transform.cs`:

```cs
using System;
using UETools.Core.Enums;

namespace UETools.Core.HistoryTypes
{
    internal partial class FTextHistory
    {
        internal sealed class Transform : FTextHistory
        {
            public override FArchive Serialize(FArchive archive)
                => archive.Read(ref _text)
                          .ReadUnsafe(ref _transform);
            
            public override string ToString()
            {
                if (_text is null)
                    NotDeserializedException.Throw();

                return _transform switch
                {
                    TransformType.ToLower => _text.ToString().ToLowerInvariant(),
                    TransformType.ToUpper => _text.ToString().ToUpperInvariant(),
                    _ => throw new NotImplementedException($"TransformType {_transform} not implemented")
                };
            }

            private TransformType _transform;
            private FText _text = null!;
        }
    }
}

```

`src/UETools.Core/Interfaces/Generic/IUnrealReadable.cs`:

```cs
using System.IO;

namespace UETools.Core.Interfaces
{
    /// <summary>
    /// Provides an interface for serializing object data as readable text.
    /// </summary>
    public interface IUnrealReadable<T> where T : TextWriter
    {
        /// <summary>
        /// Read object into the <paramref name="writer"/>.
        /// </summary>
        /// <param name="writer">Buffer to write to.</param>
        void ReadTo(T writer);
    }
}

```

`src/UETools.Core/Interfaces/Generic/IUnrealTable.cs`:

```cs
using System.Collections.Generic;

namespace UETools.Core.Interfaces.Generic
{
    internal interface IUnrealTable<T> : IUnrealTable where T : notnull
    {
        List<T> Items { get; }
    }
}

```

`src/UETools.Core/Interfaces/IUnrealLocalizationProvider.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Text;

namespace UETools.Core.Interfaces
{
    /// <summary>
    /// Interface for providing localized strings by their namespace/uid pair.
    /// </summary>
    public interface IUnrealLocalizationProvider
    {
        /// <summary>
        /// Attempts to find localized string using its <paramref name="key"/>/<paramref name="id"/> pair.
        /// </summary>
        /// <param name="key">Namespace of localized string.</param>
        /// <param name="id">UID of localized string.</param>
        /// <returns>Localized string if found; otherwise <see langword="null"/></returns>
        string? Get(string key, string id);
    }
}

```

`src/UETools.Core/Interfaces/IUnrealReadable.cs`:

```cs
using System.CodeDom.Compiler;

namespace UETools.Core.Interfaces
{
    /// <inheritdoc />
    public interface IUnrealReadable : IUnrealReadable<IndentedTextWriter>
    {
    }
}

```

`src/UETools.Core/Interfaces/IUnrealSerializable.cs`:

```cs
namespace UETools.Core.Interfaces
{
    /// <summary>
    /// Provides an interface for deserialization of the Unreal Engine binary data to implementing object.
    /// </summary>
    public interface IUnrealSerializable
    {
        /// <summary>
        /// Serialize  object with specified <paramref name="archive"/>.
        /// </summary>
        /// <param name="archive">Stream of binary data.</param>
        FArchive Serialize(FArchive archive);
    }
}

```

`src/UETools.Core/Interfaces/IUnrealTable.cs`:

```cs
namespace UETools.Core.Interfaces
{
    internal interface IUnrealTable
    {
    }
}

```

`src/UETools.Core/Interfaces/IUnrealValueReader.cs`:

```cs
using System;
using System.Diagnostics.CodeAnalysis;
using System.IO;
using System.Text;

namespace UETools.Core.Interfaces
{
    /// <summary>
    /// <see cref="BinaryReader"/> like implementation of deserializing data from its binary form.
    /// </summary>
    public interface IUnrealValueReader : IDisposable
    {
        /// <summary>
        /// Length of the underlying binary data stream.
        /// </summary>
        long Length { get; }
        /// <summary>
        /// Byte offset position in the stream.
        /// </summary>
        long Position { get; set; }

        /// <summary>
        /// Sets the position within the current stream.
        /// </summary>
        /// <param name="offset">A byte offset relative to the <paramref name="origin"/> parameter.</param>
        /// <param name="origin">A value of type <see cref="SeekOrigin"/> indicating the reference point used to obtain the new position.</param>
        /// <returns>The new position within the current stream.</returns>
        long Seek(long offset, SeekOrigin origin);

        /// <summary>
        /// Reads <see cref="Memory{T}"/> of bytes out of the underlying data stream.
        /// </summary>
        /// <param name="count">Number of bytes to read.</param>
        /// <returns>Deserialized <see cref="Memory{T}"/> of bytes.</returns>
        Memory<byte> ReadBytes(int count);
        /// <summary>
        /// Reads <see cref="Span{T}"/> of bytes out of the underlying data stream.
        /// </summary>
        /// <param name="count">Number of bytes to read.</param>
        /// <returns>Deserialized <see cref="Span{T}"/> of bytes.</returns>
        Span<byte> ReadSpanBytes(int count);
        /// <summary>
        /// Reads <see langword="bool"/> value out of the underlying data stream.
        /// </summary>
        /// <returns>Deserialized <see langword="bool"/> value.</returns>
        bool ReadBoolean();
        /// <summary>
        /// Reads <see langword="sbyte"/> value out of the underlying data stream.
        /// </summary>
        /// <returns>Deserialized <see langword="sbyte"/> value.</returns>
        sbyte ReadSByte();
        /// <summary>
        /// Reads <see langword="short"/> value out of the underlying data stream.
        /// </summary>
        /// <returns>Deserialized <see langword="short"/> value.</returns>
        short ReadInt16();
        /// <summary>
        /// Reads <see langword="int"/> value out of the underlying data stream.
        /// </summary>
        /// <returns>Deserialized <see langword="int"/> value.</returns>
        int ReadInt32();
        /// <summary>
        /// Reads <see langword="long"/> value out of the underlying data stream.
        /// </summary>
        /// <returns>Deserialized <see langword="long"/> value.</returns>
        long ReadInt64();
        /// <summary>
        /// Reads <see langword="byte"/> value out of the underlying data stream.
        /// </summary>
        /// <returns>Deserialized <see langword="byte"/> value.</returns>
        byte ReadByte();
        /// <summary>
        /// Reads <see langword="ushort"/> value out of the underlying data stream.
        /// </summary>
        /// <returns>Deserialized <see langword="ushort"/> value.</returns>
        ushort ReadUInt16();
        /// <summary>
        /// Reads <see langword="uint"/> value out of the underlying data stream.
        /// </summary>
        /// <returns>Deserialized <see langword="uint"/> value.</returns>
        uint ReadUInt32();
        /// <summary>
        /// Get reader starting at specific <paramref name="start"/> offset.
        /// </summary>
        /// <param name="start">Offset at which the stream should start from the original stream.</param>
        /// <returns>Reader of the selected part of the stream.</returns>
        IUnrealValueReader Slice(long start);
        /// <summary>
        /// Get reader starting at specific <paramref name="start"/> offset, with specified <paramref name="length"/>.
        /// </summary>
        /// <param name="start">Offset at which the stream should start from the original stream.</param>
        /// <param name="length">Length of the sliced stream from the original stream.</param>
        /// <returns>Reader of the selected part of the stream.</returns>
        IUnrealValueReader Slice(long start, long length);

        /// <summary>
        /// Reads <see langword="ulong"/> value out of the underlying data stream.
        /// </summary>
        /// <returns>Deserialized <see langword="ulong"/> value.</returns>
        ulong ReadUInt64();
        /// <summary>
        /// Reads <see langword="float"/> value out of the underlying data stream.
        /// </summary>
        /// <returns>Deserialized <see langword="float"/> value.</returns>
        float ReadSingle();
        /// <summary>
        /// Reads <see langword="double"/> value out of the underlying data stream.
        /// </summary>
        /// <returns>Deserialized <see langword="double"/> value.</returns>
        double ReadDouble();
        /// <summary>
        /// Reads <see langword="decimal"/> value out of the underlying data stream.
        /// </summary>
        /// <returns>Deserialized <see langword="decimal"/> value.</returns>
        decimal ReadDecimal();
        /// <summary>
        /// Reads <see langword="string"/> value out of the underlying data stream, prefixed with single byte of length.
        /// </summary>
        /// <returns>Deserialized <see langword="string"/> value.</returns>
        string ReadByteString();
        /// <summary>
        /// Reads underlying <see langword="string"/> value of <see cref="FString"/> instance out of the underlying data stream.
        /// </summary>
        /// <param name="length">Negative length denotes <see cref="UnicodeEncoding"/>, positive <see cref="UTF8Encoding"/>.</param>
        /// <returns></returns>
        string ReadUnrealString(int length);

        bool FindElement(string tag, [NotNullWhen(true)] out DataSegment? element);
    }
}

```

`src/UETools.Core/Interfaces/IVersionProvider.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Text;
using UETools.Core.Enums;

namespace UETools.Core.Interfaces
{
    public interface IVersionProvider
    {
        UE4Version Version { get; }
        int LicenseeVersion { get; }
        CustomVersionContainer CustomVersion { get; }
    }
}

```

`src/UETools.Core/LinkedTypeAttribute.cs`:

```cs
using System;

namespace UETools.Core
{
    [AttributeUsage(AttributeTargets.Field | AttributeTargets.Property, AllowMultiple = true, Inherited = false)]
    public class LinkedTypeAttribute : Attribute
    {
        public Type LinkedType { get; }

        public LinkedTypeAttribute(Type linkedType) => LinkedType = linkedType;
    }
}

```

`src/UETools.Core/MD5Hash.cs`:

```cs
using System;
using UETools.Core.Interfaces;

namespace UETools.Core
{
    /// <summary>
    /// Unreal Engine 4 serialization of MD5 hash
    /// </summary>
    public struct MD5Hash : IUnrealSerializable
    {
        /// <summary>
        /// Deserializes hash data from the stream.
        /// </summary>
        /// <param name="archive">Stream of binary data to read from.</param>
        public FArchive Serialize(FArchive archive)
        {
            var isValid = !_bytes.IsEmpty;
            archive.Read(ref isValid);
            if (isValid)
                archive.Read(ref _bytes, 16);

            return archive;
        }
        /// <summary>
        /// Get <see cref="System.Security.Cryptography.MD5"/> as a bytestring.
        /// </summary>
        /// <returns>MD5 in its <see cref="string"/> representation, or empty string if the hash is invalid.</returns>
        public override string ToString() => HexString.FromByteArray(_bytes);

        private Memory<byte> _bytes;
    }
}

```

`src/UETools.Core/MemoryReader.cs`:

```cs
using System;
using System.Buffers;
using System.Diagnostics.CodeAnalysis;
using System.IO;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
using System.Text;
using System.Threading.Tasks;
using UETools.Core.Interfaces;

namespace UETools.Core
{
    /// <summary>
    /// 
    /// </summary>
    public class MemoryReader : IUnrealValueReader
    {
        private Memory<byte> CurrentBuffer => CurrentSegment.MemoryOwner.Memory;
        private int CurrentBufferPosition => (int)(Position - CurrentSegment.RunningIndex);

        public long Length => _lastSegment.Length;
        public long Position
        {
            get => _position;
            set
            {
                _position = value;
                UpdateBuffer();
            }
        }

        private DataSegment CurrentSegment { get; set; }

        private void UpdateBuffer()
        {
            if (CurrentSegment.Length > _position)
                return;
            else if (CurrentSegment.NextElement is not null)
            {
                CurrentSegment = CurrentSegment.NextElement;
                UpdateBuffer();
            }
        }

        public MemoryReader(IMemoryOwner<byte> owner) : this(new DataSegment(owner)) { }
        public MemoryReader(Memory<byte> memory) : this(new DataSegment(memory)) { }
        public MemoryReader(DataSegment firstSegment)
        {
            CurrentSegment = _firstSegment = firstSegment;
            _lastSegment = _firstSegment.GetLastSegment();
        }

        private MemoryReader(DataSegment firstSegment, long startOffset) : this(firstSegment) => Position = startOffset;
        private MemoryReader(DataSegment firstSegment, long startOffset, long length) : this(firstSegment, startOffset)
        {
            var segment = CurrentSegment;
            while (segment is not null)
            {
                if(segment.Length < length)
                    segment = segment.NextElement;
                else
                {
                    // TODO: Slice of original segment instead of whole
                    _lastSegment = segment;
                    break;
                }
            }
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="offset"></param>
        /// <param name="origin"></param>
        /// <returns></returns>
        public long Seek(long offset, SeekOrigin origin) => origin switch
        {
            SeekOrigin.Begin => Position = offset,
            SeekOrigin.Current => Position += offset,
            SeekOrigin.End => Position = Length - offset,
            _ => throw new NotImplementedException()
        };

        public Memory<byte> ReadBytes(int count)
        {
            var buf = CurrentBuffer;
            var pos = CurrentBufferPosition;
            if (buf.Length < pos + count)
                ThrowOutOfRange(nameof(count), Length - pos, "Requested amount of bytes exceeds the current segment size.");

            var data = buf.Slice(pos, count);
            Position += count;
            return data;
        }
        public Span<byte> ReadSpanBytes(int count) => ReadBytes(count).Span;

        public bool ReadBoolean() => ReadInt32() != 0;
        public sbyte ReadSByte() => ReadValue<sbyte>();
        public short ReadInt16() => ReadValue<short>();
        public int ReadInt32() => ReadValue<int>();
        public long ReadInt64() => ReadValue<long>();
        public byte ReadByte() => ReadValue<byte>();
        public ushort ReadUInt16() => ReadValue<ushort>();
        public uint ReadUInt32() => ReadValue<uint>();
        public ulong ReadUInt64() => ReadValue<ulong>();
        public float ReadSingle() => ReadValue<float>();
        public double ReadDouble() => ReadValue<double>();
        public decimal ReadDecimal() => ReadValue<decimal>();
        public string ReadByteString() => ReadUnrealString(ReadByte());

        public IUnrealValueReader Slice(long start)
        {
            return new MemoryReader(_firstSegment, start);
        }
        public IUnrealValueReader Slice(long start, long length)
        {
            return new MemoryReader(_firstSegment, start, length);
        }


        private string BytesToString(Encoding encoding, int length, ReadOnlyMemory<byte> memory)
        {
#if NETSTANDARD2_0
            var result = new string((char)0, length);
            using var x = memory.Pin();
            unsafe
            {
                fixed (char* chars = result)
                {
                    encoding.GetChars((byte*)x.Pointer, memory.Length, chars, length);
                }
            }
            return result;
#else
            return string.Create(length, (Memory: memory, Encoding: encoding), (buffer, state) 
                => state.Encoding.GetChars(state.Memory.Span, buffer));
#endif
        }
        public string ReadUnrealString(int length)
        {
            var pos = CurrentBufferPosition;
            if (length > 0)
            {
                Position += length;
                return BytesToString(Encoding.UTF8, length - 1, CurrentBuffer.Slice(pos, length - 1));
            }
            else if (length < 0)
            {
                var len = -length * 2;
                Position += len;
                return BytesToString(Encoding.Unicode, -length - 1, CurrentBuffer.Slice(pos, len - 2));
            }
            else
                return string.Empty;
        }

        private T ReadValue<T>() where T : struct => MemoryMarshal.Read<T>(ReadSpanBytes(Unsafe.SizeOf<T>()));

        public void Dispose() => _firstSegment?.Dispose();

        [DoesNotReturn]
        private static void ThrowOutOfRange(string argument, object actualValue, string message) => throw new ArgumentOutOfRangeException(argument, actualValue, message);


        public bool FindElement(string tag, [NotNullWhen(true)] out DataSegment? element) => (element = FindTagSegment(tag)) is not null;

        private DataSegment? FindTagSegment(string tag)
        {
            for (var segment = _firstSegment; segment is not null; segment = segment.NextElement)
            {
                if (segment.HasTag(tag))
                    return segment;
            }
            return null;
        }

        private readonly DataSegment _firstSegment;
        private readonly DataSegment _lastSegment;
        private long _position;
    }
}

```

`src/UETools.Core/NameEntrySerialized.cs`:

```cs
using UETools.Core.Enums;
using UETools.Core.Interfaces;

namespace UETools.Core
{
    internal class NameEntrySerialized : IUnrealSerializable
    {
        public FString Name { get => _name; set => _name = value; }

        public FArchive Serialize(FArchive archive)
        {
            archive.Read(ref _name);
            if (archive.Version >= UE4Version.VER_UE4_NAME_HASHES_SERIALIZED)
            {
                archive.Read(ref _nonCasePreservingHash)
                       .Read(ref _casePreservingHash);
            }
            return archive;
        }

        private FString _name = null!;
        private ushort _nonCasePreservingHash;
        private ushort _casePreservingHash;
    }
}

```

`src/UETools.Core/NameTable.cs`:

```cs
using System.Collections.Generic;
using System.Linq;
using UETools.Core.Interfaces;

namespace UETools.Core
{
    [UnrealTable("Names")]
    public sealed class NameTable : UnrealTable<FString>
    {
        public NameTable() { }
        public NameTable(int length) : base(length) { }

        public override FArchive Serialize(FArchive archive)
        {
            if (ItemCount.HasValue)
                archive.Read(ref _nameEntries, ItemCount.Value);
            else
                archive.Read(ref _nameEntries);

            Items.AddRange(_nameEntries.Select(entry => entry.Name));

            // Add table to dictionary after it's filled
            return base.Serialize(archive);
        }

        private List<NameEntrySerialized> _nameEntries = null!;
    }
}

```

`src/UETools.Core/NotDeserializedException.cs`:

```cs
using System;
using System.Diagnostics.CodeAnalysis;

namespace UETools.Core
{
    public class NotDeserializedException : UnrealException
    {
        [DoesNotReturn]
        public static void Throw() => throw new NotDeserializedException();

        public NotDeserializedException()
        {
        }

        public NotDeserializedException(string message) : base(message)
        {
        }

        public NotDeserializedException(string message, Exception innerException) : base(message, innerException)
        {
        }
    }
}

```

`src/UETools.Core/README.md`:

```md
# UETools.Core

Base of reading of UE4 files.
```

`src/UETools.Core/SHA1Hash.cs`:

```cs
using System;
using UETools.Core.Interfaces;

namespace UETools.Core
{
    /// <summary>
    /// Unreal Engine 4 serialization of SHA1 hash
    /// </summary>
    public struct SHA1Hash : IUnrealSerializable
    {
        /// <summary>
        /// Deserializes hash data from the stream.
        /// </summary>
        /// <param name="archive">Stream of binary data to read from.</param>
        public FArchive Serialize(FArchive archive) => archive.Read(ref _bytes, 20);

        /// <summary>
        /// Get <see cref="System.Security.Cryptography.SHA1"/> as a bytestring.
        /// </summary>
        /// <returns>SHA1 in its <see cref="string"/> representation.</returns>
        public override string ToString() => HexString.FromByteArray(_bytes);

        private Memory<byte> _bytes;
    }
}

```

`src/UETools.Core/StreamExtensions.Copyrighted.cs`:

```cs
// Licensed to the .NET Foundation under one or more agreements.
// The .NET Foundation licenses this file to you under the MIT license.

using System;
using System.Buffers;
using System.IO;
using System.Runtime.InteropServices;
using System.Threading;
using System.Threading.Tasks;

namespace UETools.Core
{
    // Source: https://github.com/dotnet/runtime/blob/master/src/libraries/System.IO.Pipelines/src/System/IO/Pipelines/StreamExtensions.netstandard.cs
    public static partial class StreamExtensions
    {
        public static void Write(this Stream stream, ReadOnlyMemory<byte> buffer)
        {
            if (MemoryMarshal.TryGetArray(buffer, out var array))
            {
                stream.Write(array.Array!, array.Offset, array.Count);
            }
            else
            {
                var sharedBuffer = ArrayPool<byte>.Shared.Rent(buffer.Length);
                try
                {
                    buffer.Span.CopyTo(sharedBuffer);
                    stream.Write(sharedBuffer, 0, buffer.Length);
                }
                finally
                {
                    ArrayPool<byte>.Shared.Return(sharedBuffer);
                }
            }
        }

#if NETSTANDARD2_0
        public static ValueTask<int> ReadAsync(this Stream stream, Memory<byte> buffer, CancellationToken cancellationToken = default)
        {
            if (MemoryMarshal.TryGetArray<byte>(buffer, out var array))
            {
                return new ValueTask<int>(stream.ReadAsync(array.Array, array.Offset, array.Count, cancellationToken));
            }
            else
            {
                var sharedBuffer = ArrayPool<byte>.Shared.Rent(buffer.Length);
                return FinishReadAsync(stream.ReadAsync(sharedBuffer, 0, buffer.Length, cancellationToken), sharedBuffer, buffer);

                async ValueTask<int> FinishReadAsync(Task<int> readTask, byte[] localBuffer, Memory<byte> localDestination)
                {
                    try
                    {
                        var result = await readTask.ConfigureAwait(false);
                        new Span<byte>(localBuffer, 0, result).CopyTo(localDestination.Span);
                        return result;
                    }
                    finally
                    {
                        ArrayPool<byte>.Shared.Return(localBuffer);
                    }
                }
            }
        }
        public static ValueTask WriteAsync(this Stream stream, ReadOnlyMemory<byte> buffer, CancellationToken cancellationToken = default)
        {
            if (MemoryMarshal.TryGetArray(buffer, out var array))
            {
                return new ValueTask(stream.WriteAsync(array.Array, array.Offset, array.Count, cancellationToken));
            }
            else
            {
                var sharedBuffer = ArrayPool<byte>.Shared.Rent(buffer.Length);
                buffer.Span.CopyTo(sharedBuffer);
                return new ValueTask(FinishWriteAsync(stream.WriteAsync(sharedBuffer, 0, buffer.Length, cancellationToken), sharedBuffer));
            }
        }
        private static async Task FinishWriteAsync(Task writeTask, byte[] localBuffer)
        {
            try
            {
                await writeTask.ConfigureAwait(false);
            }
            finally
            {
                ArrayPool<byte>.Shared.Return(localBuffer);
            }
        }
#endif
    }
}

```

`src/UETools.Core/StreamExtensions.cs`:

```cs
using System;
using System.Buffers;
using System.IO;
using System.Runtime.InteropServices;
using System.Threading;
using System.Threading.Tasks;

namespace UETools.Core
{
    public static partial class StreamExtensions
    {

        public static void ReadWholeBuf(this Stream stream, byte[] buf) => stream.ReadCount(buf, buf.Length);
        public static void ReadCount(this Stream stream, byte[] buf, int count) => stream.ReadCount(buf, 0, buf.Length, count);
        public static void ReadCount(this Stream stream, byte[] buf, int bufOffset, int bufCount, int count)
        {
            if (count > bufCount)
                throw new ArgumentOutOfRangeException(nameof(count));

            var remaining = count;
            var offset = bufOffset;
            while (remaining > 0)
            {
                var read = stream.Read(buf, offset, remaining);
                if (read <= 0)
                    throw new EndOfStreamException($"End of stream reached, {remaining} bytes left to read");

                remaining -= read;
                offset += read;
            }
        }
        #region Read whole buffer to Span<T>
        public static void ReadWholeBuf(this Stream stream, Span<byte> buf)
        {
            var remaining = buf.Length;
            var offset = 0;
            while (remaining > 0)
            {
                var read = stream.Read(buf.Slice(offset));
                if (read <= 0)
                    throw new EndOfStreamException($"End of stream reached, {remaining} bytes left to read");

                remaining -= read;
                offset += read;
            }
        }
        public static void ReadWholeBuf(this Stream stream, long offset, Span<byte> buf) => stream.ReadWholeBuf(offset, SeekOrigin.Begin, buf);
        public static void ReadWholeBuf(this Stream stream, long offset, SeekOrigin origin, Span<byte> buf)
        {
            stream.Seek(offset, origin);
            stream.ReadWholeBuf(buf);
        }
        #endregion
        #region Read whole buffer to Memory<T>
        public static void ReadWholeBuf(this Stream stream, Memory<byte> buf)
        {
            if (MemoryMarshal.TryGetArray<byte>(buf, out var array))
            {
                stream.ReadCount(array.Array!, array.Offset, array.Count, buf.Length);
            }
            else
            {
                var sharedBuffer = ArrayPool<byte>.Shared.Rent(buf.Length);
                try
                {
                    stream.ReadCount(sharedBuffer, buf.Length);
                    sharedBuffer.AsSpan(0, buf.Length).CopyTo(buf.Span);
                }
                finally
                {
                    ArrayPool<byte>.Shared.Return(sharedBuffer);
                }
            }
        }
        public static void ReadWholeBuf(this Stream stream, long offset, Memory<byte> buf) => stream.ReadWholeBuf(offset, SeekOrigin.Begin, buf);
        public static void ReadWholeBuf(this Stream stream, long offset, SeekOrigin origin, Memory<byte> buf)
        {
            stream.Seek(offset, origin);
            stream.ReadWholeBuf(buf);
        }
        #endregion

        public static async ValueTask ReadWholeBufAsync(this Stream stream, Memory<byte> buf, CancellationToken cancellationToken = default)
        {
            var remaining = buf.Length;
            var offset = 0;
            while (remaining > 0)
            {
                var read = await stream.ReadAsync(buf.Slice(offset), cancellationToken).ConfigureAwait(false);
                if (read <= 0)
                    throw new EndOfStreamException($"End of stream reached, {remaining} bytes left to read");

                remaining -= read;
                offset += read;

            }
        }
        public static ValueTask ReadWholeBufAsync(this Stream stream, long offset, Memory<byte> buf, CancellationToken cancellationToken = default) => stream.ReadWholeBufAsync(offset, SeekOrigin.Begin, buf, cancellationToken);
        public static ValueTask ReadWholeBufAsync(this Stream stream, long offset, SeekOrigin origin, Memory<byte> buf, CancellationToken cancellationToken = default)
        {
            stream.Seek(offset, SeekOrigin.Begin);
            return stream.ReadWholeBufAsync(buf, cancellationToken);
        }
        public static ValueTask ReadCountAsync(this Stream stream, byte[] buf, int count, CancellationToken cancellationToken = default) => stream.ReadCountAsync(buf, 0, buf.Length, count, cancellationToken);
        public static async ValueTask ReadCountAsync(this Stream stream, byte[] buf, int bufOffset, int bufCount, int count, CancellationToken cancellationToken = default)
        {
            if (count > bufCount || count > bufCount - bufOffset)
                throw new ArgumentOutOfRangeException(nameof(count));

            var remaining = count;
            var offset = bufOffset;
            while (remaining > 0)
            {
                var read = await stream.ReadAsync(buf, offset, remaining, cancellationToken).ConfigureAwait(false);
                if (read <= 0)
                    throw new EndOfStreamException($"End of stream reached, {remaining} bytes left to read");

                remaining -= read;
                offset += read;
            }
        }

        public static int Read(this Stream stream, Memory<byte> buffer)
        {
            if (MemoryMarshal.TryGetArray<byte>(buffer, out var array))
            {
                return stream.Read(array.Array!, array.Offset, array.Count);
            }
            else
            {
                var sharedBuffer = ArrayPool<byte>.Shared.Rent(buffer.Length);
                try
                {
                    var result = stream.Read(sharedBuffer, 0, buffer.Length);
                    new Span<byte>(sharedBuffer, 0, result).CopyTo(buffer.Span);
                    return result;
                }
                finally
                {
                    ArrayPool<byte>.Shared.Return(sharedBuffer);
                }
            }
        }
#if NETSTANDARD2_0
        public static int Read(this Stream stream, Span<byte> buffer)
        {
            var sharedBuffer = ArrayPool<byte>.Shared.Rent(buffer.Length);
            try
            {
                var result = stream.Read(sharedBuffer, 0, buffer.Length);
                new Span<byte>(sharedBuffer, 0, result).CopyTo(buffer);
                return result;
            }
            finally
            {
                ArrayPool<byte>.Shared.Return(sharedBuffer);
            }
        }
        public static void Write(this Stream stream, ReadOnlySpan<byte> buffer)
        {
            var sharedBuffer = ArrayPool<byte>.Shared.Rent(buffer.Length);
            try
            {
                buffer.CopyTo(sharedBuffer);
                stream.Write(sharedBuffer, 0, buffer.Length);
            }
            finally
            {
                ArrayPool<byte>.Shared.Return(sharedBuffer);
            }
        }
#endif
    }
}
```

`src/UETools.Core/StringHelper.cs`:

```cs
using System;
using System.Buffers;

namespace UETools.Core
{
    public static class StringHelper
    {
#if NETSTANDARD2_0
        public delegate void SpanAction<T, in TArg>(Span<T> span, TArg arg);
#endif
        public static string Create<T>(int length, T state, SpanAction<char, T> action)
        {
#if NETSTANDARD2_0
            unsafe
            {
                var str = new string((char)0, length);
                fixed(char* chars = str)
                {
                    var span = new Span<char>(chars, length);
                    action(span, state);
                }
                return str;
            }
#else
            return string.Create(length, state, action);
#endif
        }
    }
}

```

`src/UETools.Core/UETools.Core.csproj`:

```csproj
<Project Sdk="Microsoft.NET.Sdk">

  <PropertyGroup>
    <TargetFrameworks>netstandard2.0;netstandard2.1;net5.0</TargetFrameworks>
    <Nullable>enable</Nullable>
    <PackageDescription>Base blocks for reading Unreal Engine 4 serialized data.</PackageDescription>
  </PropertyGroup>

  <PropertyGroup Condition="'$(TargetFramework)' == 'netstandard2.0'">
    <AllowUnsafeBlocks>true</AllowUnsafeBlocks>
  </PropertyGroup>

  <ItemGroup Condition="'$(TargetFramework)' == 'netstandard2.0' Or '$(TargetFramework)' == 'netstandard2.1'">
    <PackageReference Include="System.Runtime.CompilerServices.Unsafe" Version="4.7.1" />
  </ItemGroup>
  
  <ItemGroup Condition="'$(TargetFramework)' == 'netstandard2.0'">
    <PackageReference Include="Microsoft.Bcl.AsyncInterfaces" Version="1.1.1" />
    <PackageReference Include="Microsoft.Bcl.HashCode" Version="1.1.0" />
    <PackageReference Include="System.Memory" Version="4.5.4" />
    <PackageReference Include="System.Threading.Tasks.Extensions" Version="4.5.4" />
  </ItemGroup>

  <ItemGroup>
    <ProjectReference Include="..\UETools.TypeFactory\UETools.TypeFactory.csproj" />
  </ItemGroup>

</Project>

```

`src/UETools.Core/UnrealAssetFileAttribute.cs`:

```cs
using System;
using System.IO;

namespace UETools.Core
{
    [AttributeUsage(AttributeTargets.Class | AttributeTargets.Struct, AllowMultiple = true, Inherited = true)]
    public class UnrealAssetFileAttribute : Attribute
    {
        public string Extension { get; }
        public string FileName { get; }
        public bool HasWildcard { get; }

        public UnrealAssetFileAttribute(string extension) : this("*", extension, true) { }
        public UnrealAssetFileAttribute(string fileName, bool hasWildcard) : this(Path.GetFileNameWithoutExtension(fileName), Path.GetExtension(fileName), hasWildcard) { }
        private UnrealAssetFileAttribute(string fileName, string extension, bool hasWildcard)
        {
            FileName = fileName;
            Extension = extension;
            HasWildcard = hasWildcard;
        }
    }
}

```

`src/UETools.Core/UnrealException.cs`:

```cs
using System;
using System.Runtime.Serialization;

namespace UETools.Core
{
    /// <summary>
    /// Base exception type for the libraries.
    /// </summary>
    public class UnrealException : Exception
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="UnrealException"/> class.
        /// </summary>
        public UnrealException() : base() { }
        /// <summary>
        /// Initializes a new instance of the <see cref="UnrealException"/> class with a specified error message.
        /// </summary>
        /// <param name="message">The message that describes the error.</param>
        public UnrealException(string message) : base(message) { }
        /// <summary>
        /// Initializes a new instance of the <see cref="UnrealException"/> class with a specified error message and a reference to the inner exception that is the cause of this exception.
        /// </summary>
        /// <param name="message">The error message that explains the reason for the exception.</param>
        /// <param name="innerException">The exception that is the cause of the current exception, or a <see langword="null"/> reference if no inner exception is specified.</param>
        public UnrealException(string message, Exception innerException) : base(message, innerException) { }
        /// <summary>
        /// Initializes a new instance of the <see cref="UnrealException"/> class with serialized data.
        /// </summary>
        /// <param name="info">The <see cref="SerializationInfo"/> that holds the serialized object data about the exception being thrown.</param>
        /// <param name="context">The <see cref="StreamingContext"/> that contains contextual information about the source or destination.</param>
        /// <exception cref="ArgumentNullException"><paramref name="info"/> is <see langword="null"/>.</exception>
        /// <exception cref="SerializationException">The class name is <see langword="null"/> or <see cref="Exception.HResult"/> is zero.</exception>
        protected UnrealException(SerializationInfo info, StreamingContext context) : base(info, context) { }
    }
}

```

`src/UETools.Core/UnrealTable.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Linq;
using UETools.Core.Interfaces;
using UETools.Core.Interfaces.Generic;

namespace UETools.Core
{
    /// <summary>
    /// Base class of every table type that's supposed to be added to internal FArchive storage.
    /// </summary>
    /// <remarks>
    /// Deriving class is expected to be sealed and define UnrealTableAttribute, otherwise constructor throws NotImplementedException.
    /// </remarks>
    /// <typeparam name="T">Type of items stored in the table.</typeparam>
    [DebuggerDisplay("{Items.Count} items")]
    public abstract class UnrealTable<T> : IUnrealSerializable, IUnrealTable<T> where T : notnull
    {
        /// <summary>
        /// <see cref="List{T}"/> of elements exposed by the table.
        /// </summary>
        public List<T> Items => _entries;
        /// <summary>
        /// Support for predefined amount of entries in the table. Should be used if the array doesn't have its count serialized before other elements.
        /// </summary>
        protected int? ItemCount { get; set; }

        /// <summary>
        /// Checks if class implements UnrealTableAttribute and is sealed.
        /// </summary>
        /// <exception cref="NotImplementedException">
        /// Thrown when class doesn't define <see cref="UnrealTableAttribute"/>, or isn't marked <see langword="sealed"/>.
        /// </exception>
        protected UnrealTable()
        {
            var t = GetType();
            if (!t.IsDefined(typeof(UnrealTableAttribute), false) && t.IsSealed)
                ThrowNotImplemented(t.Name);
        }

        /// <summary>
        /// Sets predefined length of the list.
        /// </summary>
        /// <param name="length">Value to assign to <see cref="ItemCount"/></param>
        public UnrealTable(int length) : this() => ItemCount = length;

        /// <summary>
        /// Adds class instance to <see cref="FArchive.Tables"/> with the <see cref="UnrealTableAttribute.Name"/> as key.
        /// </summary>
        /// <remarks>
        /// Should be called in derived class as it adds the class instance to <see cref="FArchive.Tables"/>.
        /// </remarks>
        /// <param name="archive">Stream of binary data to read from.</param>
        public virtual FArchive Serialize(FArchive archive)
        {
            if (GetType().GetCustomAttributes(typeof(UnrealTableAttribute), false).First() is UnrealTableAttribute attr)
                archive.Tables.TryAdd(attr.Name, this);

            return archive;
        }

        private static void ThrowNotImplemented(string className)
            => throw new NotImplementedException($"UnrealTable deriving class {className} is not defining {nameof(UnrealTableAttribute)}, or isn't marked sealed.");

        /// <summary>
        /// Field to support deserialization by <see cref="FArchive.Read{T}(ref List{T})"/> calls in deriving classes.
        /// </summary>
        protected List<T> _entries = new List<T>();
    }
}

```

`src/UETools.Core/UnrealTableAttribute.cs`:

```cs
using System;

namespace UETools.Core
{
    /// <summary>
    /// Determines the name that instance of a class will be added as in the table dictionary.
    /// </summary>
    [AttributeUsage(AttributeTargets.Class, AllowMultiple = false, Inherited = false)]
    public sealed class UnrealTableAttribute : Attribute
    {
        /// <summary>
        /// Gets or sets the name associated with instances of the class.
        /// </summary>
        public string Name { get; private set; }

        /// <summary>
        /// Initializes attribute with the specified name.
        /// </summary>
        /// <param name="name">Name to associate with the instance of this class.</param>
        public UnrealTableAttribute(string name) => Name = name;
    }
}

```

`src/UETools.Objects/Classes/AssetImportData.cs`:

```cs
using UETools.Core;
using UETools.Objects.Classes.Internal;

namespace UETools.Objects.Classes
{
    class AssetImportData : UObject
    {
        public override FArchive Serialize(FArchive archive)
        {
            FString? str = default;
            archive.Read(ref str);
            return base.Serialize(archive);
        }
    }
}

```

`src/UETools.Objects/Classes/DataTable.cs`:

```cs
using System.CodeDom.Compiler;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using UETools.Core;
using UETools.Core.Interfaces;
using UETools.Objects.Classes.Internal;

namespace UETools.Objects.Classes
{
    using TableItems = List<KeyValuePair<string, TaggedObject>>;
    public sealed class DataTable : UObject, IUnrealSerializable, IUnrealReadable
    {
        public TableItems Rows { get; } = new TableItems();

        public override FArchive Serialize(FArchive archive)
        {
            base.Serialize(archive);
            ReadRows(archive);
            return archive;
        }

        private void ReadRows(FArchive reader)
        {
            if (base["RowStruct"] is null)
                return;
            int rowCount = 0;
            reader.Read(ref rowCount);
            for (var i = 0; i < rowCount; i++)
                ReadDataTableRow(reader);
        }

        private void ReadDataTableRow(FArchive archive)
        {
            FName? RowName = default;
            archive.Read(ref RowName);
            Rows.Add(new KeyValuePair<string, TaggedObject>(RowName, new TaggedObject(archive)));
        }

        public override void ReadTo(IndentedTextWriter writer)
        {
            base.ReadTo(writer);
            foreach (var row in Rows)
            {
                writer.WriteLine();
                writer.WriteLine($"Row {row.Key}:");
                row.Value.ReadTo(writer);
            }
        }
    }
}

```

`src/UETools.Objects/Classes/Internal/ByteBulkData.cs`:

```cs
using System;
using System.Diagnostics;
using System.IO;
using UETools.Core;
using UETools.Core.Interfaces;
using UETools.Objects.Enums;

namespace UETools.Objects.Classes
{
    internal class ByteBulkData : IUnrealSerializable
    {
        public byte[] Bytes => BulkData ?? Array.Empty<byte>();

        private FArchive SerializeHeader(FArchive archive) => archive.ReadUnsafe(ref _bulkDataFlags)
                                                                     .Read(ref _elementCount)
                                                                     .Read(ref _bulkDataSizeOnDisk)
                                                                     .Read(ref _bulkDataOffsetInFile);
        public FArchive Serialize(FArchive archive)
        {
            SerializeHeader(archive);
            if ((_bulkDataFlags & EBulkDataFlags.Unused) != 0 || _elementCount == 0)
            {
                BulkData = Array.Empty<byte>();
            }
            else
            {
                if ((_bulkDataFlags & (EBulkDataFlags.OptionalPayload | EBulkDataFlags.PayloadInSeperateFile)) != 0 && archive.FindTagSubstream((_bulkDataFlags & EBulkDataFlags.OptionalPayload) != 0 ? ".uptnl" : ".ubulk", out var tagData))
                {
                    tagData.Seek(_bulkDataOffsetInFile, SeekOrigin.Current);
                    SerializeData(tagData);
                }
                else if ((_bulkDataFlags & EBulkDataFlags.PayloadAtEndOfFile) != 0)
                {
                    throw new NotImplementedException($"{nameof(EBulkDataFlags.PayloadAtEndOfFile)} is not implemented yet!");
                }
                else if ((_bulkDataFlags & EBulkDataFlags.ForceInlinePayload) != 0)
                {
                    SerializeData(archive);
                }
            }
            return archive;
        }
        private void SerializeData(FArchive archive)
        {
            if ((_bulkDataFlags & EBulkDataFlags.SerializeCompressed) != 0)
            {
                throw new NotImplementedException("Texture compression is not supported yet!");
            }
            else
            {
                archive.Read(ref BulkData, _elementCount);
            }
        }

        EBulkDataFlags _bulkDataFlags;
        int _elementCount;
        long _bulkDataOffsetInFile;
        int _bulkDataSizeOnDisk;
        byte[] BulkData = null!; 
    }
}
```

`src/UETools.Objects/Classes/Internal/StripDataFlags.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Text;
using UETools.Core;
using UETools.Core.Interfaces;

namespace UETools.Objects.Classes.Internal
{
    internal class StripDataFlags : IUnrealSerializable
    {
        public StripDataFlags() { }
        public StripDataFlags(FArchive archive) => Serialize(archive);

        public FArchive Serialize(FArchive archive) => archive.Read(ref _globalStripFlags).Read(ref _classStripFlags);

        private byte _classStripFlags;
        private byte _globalStripFlags;
    }
}

```

`src/UETools.Objects/Classes/Internal/UClass.cs`:

```cs
using System.Collections.Generic;
using UETools.Core;
using UETools.Core.Enums;
using UETools.Core.Interfaces;
using UETools.Objects.Enums;
using UETools.Objects.Package;

namespace UETools.Objects.Classes.Internal
{
    internal class UClass : UStruct
    {
        class ImplementedInterface : IUnrealSerializable
        {
            public FArchive Serialize(FArchive archive)
                => archive.Read(ref _class)
                          .Read(ref _pointerOffset)
                          .Read(ref _implementedByK2);

            private ObjectReference _class = null!;
            private int _pointerOffset;
            private bool _implementedByK2;
        }

        public override FArchive Serialize(FArchive archive)
        {
            base.Serialize(archive)
                .Read(ref _funcMap)
                .ReadUnsafe(ref _flags);

            if (archive.Version < UE4Version.VER_UE4_CLASS_NOTPLACEABLE_ADDED)
            {
                _flags ^= EClassFlags.NotPlaceable;
                if ((_flags & EClassFlags.NotPlaceable) == 0)
                    _flags |= EClassFlags.NotPlaceable;
            }

            archive.Read(ref _classWithin)
                   .Read(ref _classConfigName);

            if (archive.Version < UE4Version.VER_UE4_UCLASS_SERIALIZE_INTERFACES_AFTER_LINKING)
                archive.Read(ref _serializedInterface);

            archive.Read(ref _deprecatedForceScriptOrder)
                   .Read(ref _dummy);

            if (archive.Version >= UE4Version.VER_UE4_ADD_COOKED_TO_UCLASS)
                archive.Read(ref _cooked);

            return archive;
        }

        private Dictionary<FName, ResolvedObjectReference<UFunction>> _funcMap = null!;
        private EClassFlags _flags;
        private ObjectReference _classWithin = null!;
        private FName _classConfigName = null!;
        private List<ImplementedInterface>? _serializedInterface;
        private bool _deprecatedForceScriptOrder;
        private FName _dummy = null!;
        private bool _cooked;
    }
}

```

`src/UETools.Objects/Classes/Internal/UField.cs`:

```cs
using UETools.Core;
using UETools.Core.Enums;
using UETools.Objects.Package;

namespace UETools.Objects.Classes.Internal
{
    // TODO: Fix
    class UField : UObject
    {
        public override FArchive Serialize(FArchive archive)
        {
            base.Serialize(archive);
            if (archive.Version > UE4Version.VER_UE4_AUTOMATIC_VERSION)
            {
                archive.Read(ref _next);
            }
            return archive;
        }

        private ObjectReference? _next;
    }
}

```

`src/UETools.Objects/Classes/Internal/UFunction.cs`:

```cs
using UETools.Core;
using UETools.Core.Enums;
using UETools.Objects.Enums;
using UETools.Objects.Package;

namespace UETools.Objects.Classes.Internal
{
    internal class UFunction : UStruct
    {
        public override FArchive Serialize(FArchive archive)
        {
            base.Serialize(archive)
                .ReadUnsafe(ref _functionFlags);

            if ((_functionFlags & EFunctionFlags.Net) != 0)
                archive.Read(ref _repOffset);

            if (archive.Version >= UE4Version.VER_UE4_SERIALIZE_BLUEPRINT_EVENTGRAPH_FASTCALLS_IN_UFUNCTION)
            {
                archive.Read(ref _eventGraphFunction)
                       .Read(ref _eventGraphCallOffset);
            }
            return archive;
        }


        private EFunctionFlags _functionFlags;
        private ResolvedObjectReference<UFunction> _eventGraphFunction = null!;
        private int _eventGraphCallOffset;
        private short _repOffset;
    }
}

```

`src/UETools.Objects/Classes/Internal/UObject.cs`:

```cs
using UETools.Core;

namespace UETools.Objects.Classes.Internal
{
    public class UObject : TaggedObject
    {
        public override FArchive Serialize(FArchive archive) => base.Serialize(archive)
                                                                    .Read(ref _wasKill);

        private bool _wasKill;
    }
}

```

`src/UETools.Objects/Classes/Internal/UStruct.cs`:

```cs
using System.Linq;
using UETools.Core;
using UETools.Objects.KismetVM;
using UETools.Objects.Package;

namespace UETools.Objects.Classes.Internal
{
    internal class UStruct : UField
    {
        public override FArchive Serialize(FArchive archive)
        {
            base.Serialize(archive)
                .Read(ref _superStruct);

            int _childCount = 0;
            archive.Read(ref _childCount);
            for (var i = 0; i < _childCount; i++)
            {
                ObjectReference? ChildRef = default;
                archive.Read(ref ChildRef);
            }

            archive.Read(ref _scriptByteCodeSize)
                  .Read(ref _scriptByteCodeOnDiskSize);
            if (_scriptByteCodeSize > 0)
            {
                var xxx = new BlueprintReader();
                xxx.Serialize(archive);
            }
            return archive;
        }

        private ResolvedObjectReference<UStruct>? _superStruct;
        private ResolvedObjectReference<UField>? _children;
        private int _scriptByteCodeSize;
        private int _scriptByteCodeOnDiskSize;
    }
}

```

`src/UETools.Objects/Classes/LevelSequence.cs`:

```cs
using UETools.Core;
using UETools.Objects.Classes.Internal;

namespace UETools.Objects.Classes
{
    sealed class LevelSequence : UObject
    {
        public override FArchive Serialize(FArchive archive)
        {
            return archive;
            base.Serialize(archive);
        }
    }
}

```

`src/UETools.Objects/Classes/Material.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Text;
using UETools.Core;
using UETools.Objects.Classes.Internal;

namespace UETools.Objects.Classes
{
    sealed class Material : UObject
    {
        public override FArchive Serialize(FArchive archive)
        {
            base.Serialize(archive);
            // TODO: Material data
            return archive;
        }
    }
}

```

`src/UETools.Objects/Classes/StringTable.cs`:

```cs
using System.CodeDom.Compiler;
using System.Collections.Generic;
using UETools.Core;
using UETools.Core.Interfaces;
using UETools.Objects.Classes.Internal;

namespace UETools.Objects.Classes
{
    sealed class StringTable : UObject
    {
        class MetaDataMap : IUnrealSerializable
        {
            public Dictionary<FName, FString> Meta { get => _meta; set => _meta = value; }

            public FArchive Serialize(FArchive archive) => archive.Read(ref _meta);

            private Dictionary<FName, FString> _meta = null!;
        }

        public override FArchive Serialize(FArchive archive)
            => base.Serialize(archive)
                   .Read(ref _namespace)
                   .Read(ref _keySourceStringMap)
                   .Read(ref _keysToMetaData);

        public override void ReadTo(IndentedTextWriter writer)
        {
            if (_namespace is null || _keySourceStringMap is null || _keysToMetaData is null)
                NotDeserializedException.Throw();

            base.ReadTo(writer);
            writer.WriteLine();
            writer.WriteLine($"{nameof(StringTable)} content");
            writer.WriteLine();


            writer.WriteLine($"BEGIN {_namespace}");
            writer.Indent++;
            foreach (var kv in _keySourceStringMap)
            {
                writer.WriteLine($"{kv.Key}: {kv.Value}");
            }
            writer.Indent--;
            writer.WriteLine($"END {_namespace}");
        }

        private FString _namespace = null!;
        private Dictionary<FString, FString> _keySourceStringMap = null!;
        private Dictionary<FString, MetaDataMap> _keysToMetaData = null!;
    }
}

```

`src/UETools.Objects/Classes/TaggedObject.cs`:

```cs
using System;
using System.CodeDom.Compiler;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Diagnostics;
using System.IO;
using System.Reflection;
using System.Text;
using UETools.Core;
using UETools.Core.Interfaces;
using UETools.Objects.Interfaces;
using UETools.TypeFactory;
using TaggedItem = System.Collections.Generic.KeyValuePair<string, UETools.Objects.Interfaces.IProperty>;
namespace UETools.Objects.Classes
{
    using TaggedItemsList = List<TaggedItem>;
    public class TaggedObject : IUnrealSerializable, IUnrealReadable
    {
        public TaggedObject() { }
        public TaggedObject(FArchive reader) => Serialize(reader);
        public TaggedItemsList Vars { get; } = new TaggedItemsList();
        public IProperty this[string key] => Vars.Find(kv => kv.Key == key).Value;
        public virtual FArchive Serialize(FArchive archive)
        {
            foreach (var tag in PropertyTag.ReadToEnd(archive))
            {
                Vars.Add(new TaggedItem(tag.Name, PropertyFactory.Get(archive.SubStream(tag.Size), tag)));
                if(archive.Tell() != tag.PropertyEnd)
                {
                    Debug.WriteLine($"Needed to move by {tag.PropertyEnd - archive.Tell()} for {tag.Name} {(tag.TypeEnum == PropertyTag.PropertyType.StructProperty ? tag.StructName : tag.Type)}");
                    archive.Seek(tag.PropertyEnd);
                }
            }
            return archive;
        }

        public virtual void ReadTo(IndentedTextWriter writer)
        {
            writer.WriteLine('{');
            writer.Indent++;
            foreach (var kv in Vars)
            {
                writer.Write($"{kv.Key}: ");
                switch (kv.Value)
                {
                    case IUnrealReadable indent:
                        indent.ReadTo(writer);
                        break;
                    default:
                        writer.WriteLine(kv.Value);
                        break;
                }
            }
            writer.Indent--;
            writer.WriteLine('}');
        }

        internal static TaggedObject? Create(FArchive reader, string typename)
        {
            try
            {
                if (Classes.TryGetValue(typename, out var func))
                {
                    var x = func();
                    x.Serialize(reader);
                    return x;
                }
                else
                {
                    var obj = new TaggedObject();
                    obj.Serialize(reader);
                    return obj;
                }
            }
            catch(Exception ex)
            {
                Debug.WriteLine($"Class {typename}");
            }
            return null;
        }


        private static IReadOnlyDictionary<string, Func<TaggedObject>> Classes { get; } = new ReadOnlyDictionary<string, Func<TaggedObject>>(
            new TypeCollector<TaggedObject>(Path.GetDirectoryName(Assembly.GetCallingAssembly().Location)!).ToFactory().factories
            );
    }
}

```

`src/UETools.Objects/Classes/Texture.cs`:

```cs
using System.Collections.Generic;
using UETools.Core;
using UETools.Objects.Classes.Internal;

namespace UETools.Objects.Classes
{
    public class Texture : UObject
    {
        public override FArchive Serialize(FArchive archive) => base.Serialize(archive).Read(ref _stripDataFlags);

        private StripDataFlags? _stripDataFlags;
    }
}
```

`src/UETools.Objects/Classes/Texture2D.TexturePlatformData.Texture2DMipMap.cs`:

```cs
using UETools.Core;
using UETools.Core.Interfaces;

namespace UETools.Objects.Classes
{
    public partial class Texture2D
    {
        public partial class TexturePlatformData
        {
            public class Texture2DMipMap : IUnrealSerializable
            {
                public byte[] Data => _data.Bytes;

                public FArchive Serialize(FArchive archive) => archive.Read(ref isCooked)
                                                                      .Read(ref _data)
                                                                      .Read(ref SizeX)
                                                                      .Read(ref SizeY)
                                                                      .Read(ref SizeZ);

                bool isCooked;
                ByteBulkData _data = null!;
                int SizeX;
                int SizeY;
                int SizeZ;

            }

        }
    }

}

```

`src/UETools.Objects/Classes/Texture2D.TexturePlatformData.cs`:

```cs
using System;
using System.Collections.Generic;
using UETools.Core;
using UETools.Core.Interfaces;
using UETools.Objects.Enums;

namespace UETools.Objects.Classes
{
    public partial class Texture2D
    {
        public partial class TexturePlatformData : IUnrealSerializable
        {
            public int SizeX => _sizeX;
            public int SizeY => _sizeY;
            public Texture2DMipMap FirstMip => Mips[_firstMip];
            public List<Texture2DMipMap> Mips => _mips;
            public EPixelFormat PixelFormat { get; private set; }
            
            public FArchive Serialize(FArchive archive)
            {
                archive.Read(ref _sizeX)
                       .Read(ref _sizeY)
                       .Read(ref _numSlices)
                       .Read(ref _pixelFormat)
                       .Read(ref _firstMip)
                       .Read(ref _mips)
                       .Read(ref _isVirtual);

                if(Enum.TryParse<EPixelFormat>(_pixelFormat.ToString(), out var format))
                {
                    PixelFormat = format;
                }

                return archive;
            }

            int _sizeX;
            int _sizeY;
            int _numSlices;
            int _firstMip;
            FString _pixelFormat;
            List<Texture2DMipMap> _mips;
            bool _isVirtual;
        }
    }
}

```

`src/UETools.Objects/Classes/Texture2D.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Text;
using UETools.Core;
using UETools.Core.Interfaces;
using UETools.Objects.Classes.Internal;

namespace UETools.Objects.Classes
{
    public partial class Texture2D : Texture
    {
        public TexturePlatformData PlatformData => _platformData;

        public override FArchive Serialize(FArchive archive)
        {
            base.Serialize(archive);

            var dataFlags = new StripDataFlags(archive);

            archive.Read(ref _isCooked);
            if (_isCooked is not 0)
            {
                FName? _pixelFormatEnum = null;
                archive.Read(ref _pixelFormatEnum);
                while (!_pixelFormatEnum.IsNone())
                {
                    long skipOffset = 0;
                    archive.Read(ref skipOffset);
                    archive.Read(ref _platformData);
                    archive.Read(ref _pixelFormatEnum);
                    continue;
                }
            }

            return archive;
        }

        private int _isCooked;
        private TexturePlatformData _platformData = null!;
    }

}

```

`src/UETools.Objects/Enums/EBulkDataFlags.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Text;

namespace UETools.Objects.Enums
{
    [Flags]
    internal enum EBulkDataFlags
    {
        None = 0,
        PayloadAtEndOfFile = 1 << 0,
        SerializeCompressedZLIB = 1 << 1,
        ForceSingleElementSerialization = 1 << 2,
        SingleUse = 1 << 3,
        Unused = 1 << 5,
        ForceInlinePayload = 1 << 6,
        SerializeCompressed = (SerializeCompressedZLIB),
        ForceStreamPayload = 1 << 7,
        PayloadInSeperateFile = 1 << 8,
        SerializeCompressedBitWindow = 1 << 9,
        Force_NOT_InlinePayload = 1 << 10,
        OptionalPayload = 1 << 11,
        MemoryMappedPayload = 1 << 12,
        Size64Bit = 1 << 13,
        DuplicateNonOptionalPayload = 1 << 14,
        BadDataVersion = 1 << 15,
        UsesIoDispatcher = 1 << 16,
        DataIsMemoryMapped = 1 << 17
    }
}

```

`src/UETools.Objects/Enums/EClassFlags.cs`:

```cs
using System;

namespace UETools.Objects.Enums
{
    [Flags]
    internal enum EClassFlags : uint
    {
        None = 0x00000000u,
        Abstract = 0x00000001u,
        DefaultConfig = 0x00000002u,
        Config = 0x00000004u,
        Transient = 0x00000008u,
        Parsed = 0x00000010u,
        MatchedSerializers = 0x00000020u,
        AdvancedDisplay = 0x00000040u,
        Native = 0x00000080u,
        NoExport = 0x00000100u,
        NotPlaceable = 0x00000200u,
        PerObjectConfig = 0x00000400u,
        ReplicationDataIsSetUp = 0x00000800u,
        EditInlineNew = 0x00001000u,
        CollapseCategories = 0x00002000u,
        Interface = 0x00004000u,
        CustomConstructor = 0x00008000u,
        Const = 0x00010000u,
        LayoutChanging = 0x00020000u,
        CompiledFromBlueprint = 0x00040000u,
        MinimalAPI = 0x00080000u,
        RequiredAPI = 0x00100000u,
        DefaultToInstanced = 0x00200000u,
        TokenStreamAssembled = 0x00400000u,
        HasInstancedReference = 0x00800000u,
        Hidden = 0x01000000u,
        Deprecated = 0x02000000u,
        HideDropDown = 0x04000000u,
        GlobalUserConfig = 0x08000000u,
        Intrinsic = 0x10000000u,
        ucted = 0x20000000u,
        ConfigDoNotCheckDefaults = 0x40000000u,
        NewerVersionExists = 0x80000000u,

        /// <summary>
        /// Flags to inherit from base class.
        /// </summary>
        Inherit = Transient | DefaultConfig | Config | PerObjectConfig | ConfigDoNotCheckDefaults | NotPlaceable | Const | HasInstancedReference | Deprecated | DefaultToInstanced | GlobalUserConfig,
        /// <summary>
        /// These flags will be cleared by the compiler when the class is parsed during script compilation.
        /// </summary>
        RecompilerClear = Inherit | Abstract | NoExport | Native | Intrinsic | TokenStreamAssembled,
        /// <summary>
        /// These flags will be cleared by the compiler when the class is parsed during script compilation.
        /// </summary>
        ShouldNeverBeLoaded = Native | Intrinsic | TokenStreamAssembled,
        /// <summary>
        /// These flags will be inherited from the base class only for non-intrinsic classes.
        /// </summary>
        ScriptInherit = Inherit | EditInlineNew | CollapseCategories,
        /// <summary>
        /// This is used as a mask for the flags put into generated code for "compiled in" classes.
        /// </summary>
        SaveInCompiledInClasses = Abstract | DefaultConfig | GlobalUserConfig | Config | Transient | Native | NotPlaceable | PerObjectConfig | ConfigDoNotCheckDefaults | EditInlineNew | CollapseCategories | Interface | DefaultToInstanced | HasInstancedReference | Hidden | Deprecated | HideDropDown | Intrinsic | AdvancedDisplay | Const | MinimalAPI | RequiredAPI | MatchedSerializers

    }
}

```

`src/UETools.Objects/Enums/EFontHinting.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Text;

namespace UETools.Objects.Enums
{
    enum EFontHinting : byte
    {
        /** Use the default hinting specified in the font. */
        Default,
        /** Force the use of an automatic hinting algorithm. */
        Auto,
        /** Force the use of an automatic light hinting algorithm, optimized for non-monochrome displays. */
        AutoLight,
        /** Force the use of an automatic hinting algorithm optimized for monochrome displays. */
        Monochrome,
        /** Do not use hinting. */
        None,
    }
}

```

`src/UETools.Objects/Enums/EFontLoadingPolicy.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Text;

namespace UETools.Objects.Enums
{
    enum EFontLoadingPolicy : byte
    {
        /** Lazy load the entire font into memory. This will consume more memory than Streaming, however there will be zero file-IO when rendering glyphs within the font, although the initial load may cause a hitch. */
        LazyLoad,
        /** Stream the font from disk. This will consume less memory than LazyLoad or Inline, however there will be file-IO when rendering glyphs, which may cause hitches under certain circumstances or on certain platforms. */
        Stream,
        /** Embed the font data within the asset. This will consume more memory than Streaming, however it is guaranteed to be hitch free (only valid for font data within a Font Face asset). */
        Inline,
    }
}

```

`src/UETools.Objects/Enums/EFunctionFlags.cs`:

```cs
using System;

namespace UETools.Objects.Enums
{
    [Flags]
    internal enum EFunctionFlags : uint
    {
        // Function flags.
        None = 0x00000000,

        Final = 0x00000001,    // Function is final (prebindable, non-overridable function).
        RequiredAPI = 0x00000002,  // Indicates this function is DLL exported/imported.
        BlueprintAuthorityOnly = 0x00000004,   // Function will only run if the object has network authority
        BlueprintCosmetic = 0x00000008,   // Function is cosmetic in nature and should not be invoked on dedicated servers
        // FUNC_ = 0x00000010,   // unused.
        // FUNC_ = 0x00000020,   // unused.
        Net = 0x00000040,   // Function is network-replicated.
        NetReliable = 0x00000080,   // Function should be sent reliably on the network.
        NetRequest = 0x00000100,   // Function is sent to a net service
        Exec = 0x00000200, // Executable from command line.
        Native = 0x00000400,   // Native function.
        Event = 0x00000800,   // Event function.
        NetResponse = 0x00001000,   // Function response from a net service
        Static = 0x00002000,   // Static function.
        NetMulticast = 0x00004000, // Function is networked multicast Server -> All Clients
        UbergraphFunction = 0x00008000,
        MulticastDelegate = 0x00010000,    // Function is a multi-cast delegate signature (also requires FUNC_Delegate to be set!)
        Public = 0x00020000,   // Function is accessible in all classes (if overridden, parameters must remain unchanged).
        Private = 0x00040000,  // Function is accessible only in the class it is defined in (cannot be overridden, but function name may be reused in subclasses.  IOW: if overridden, parameters don't need to match, and Super.Func() cannot be accessed since it's private.)
        Protected = 0x00080000,    // Function is accessible only in the class it is defined in and subclasses (if overridden, parameters much remain unchanged).
        Delegate = 0x00100000, // Function is delegate signature (either single-cast or multi-cast, depending on whether FUNC_MulticastDelegate is set.)
        NetServer = 0x00200000,    // Function is executed on servers (set by replication code if passes check)
        HasOutParms = 0x00400000,  // function has out (pass by reference) parameters
        HasDefaults = 0x00800000,  // function has structs that contain defaults
        NetClient = 0x01000000,    // function is executed on clients
        DLLImport = 0x02000000,    // function is imported from a DLL
        BlueprintCallable = 0x04000000,    // function can be called from blueprint code
        BlueprintEvent = 0x08000000,   // function can be overridden/implemented from a blueprint
        BlueprintPure = 0x10000000,    // function can be called from blueprint code, and is also pure (produces no side effects). If you set this, you should set FUNC_BlueprintCallable as well.
        EditorOnly = 0x20000000,   // function can only be called from an editor scrippt.
        Const = 0x40000000,    // function can be called from blueprint code, and only reads state (never writes state)
        NetValidate = 0x80000000,  // function must supply a _Validate implementation

        AllFlags = 0xFFFFFFFF
    }
}

```

`src/UETools.Objects/Enums/EObjectFlags.cs`:

```cs
using System;

namespace UETools.Objects.Enums
{
    /// <summary>Flags describing an object instance</summary>
    [Flags]
    internal enum EObjectFlags : uint
    {
        /// <summary>
        /// No flags, used to avoid a cast.
        /// </summary>
        RF_NoFlags = 0x00000000,

        // This first group of flags mostly has to do with what kind of object it is. Other than transient, these are the persistent object flags.
        // The garbage collector also tends to look at these.
        /// <summary>
        /// Object is visible outside its package.
        /// </summary>
        RF_Public = 0x00000001,
        /// <summary>
        /// Keep object around for editing even if unreferenced.
        /// </summary>
        RF_Standalone = 0x00000002,
        /// <summary>
        /// Object (UField) will be marked as native on construction (DO NOT USE THIS FLAG in HasAnyFlags() etc)
        /// </summary>
        RF_MarkAsNative = 0x00000004,
        /// <summary>
        /// Object is transactional.
        /// </summary>
        RF_Transactional = 0x00000008,
        /// <summary>
        /// This object is its class's default object.
        /// </summary>
        RF_ClassDefaultObject = 0x00000010,
        /// <summary>
        /// This object is a template for another object - treat like a class default object.
        /// </summary>
        RF_ArchetypeObject = 0x00000020,
        /// <summary>
        /// Don't save object.
        /// </summary>
        RF_Transient = 0x00000040,

        // This group of flags is primarily concerned with garbage collection.
        /// <summary>
        /// Object will be marked as root set on construction and not be garbage collected, even if unreferenced (DO NOT USE THIS FLAG in HasAnyFlags() etc)
        /// </summary>
        RF_MarkAsRootSet = 0x00000080,
        /// <summary>
        /// This is a temp user flag for various utilities that need to use the garbage collector. The garbage collector itself does not interpret it.
        /// </summary>
        RF_TagGarbageTemp = 0x00000100,

        // The group of flags tracks the stages of the lifetime of a uobject
        /// <summary>
        /// This object has not completed its initialization process. Cleared when ~FObjectInitializer completes.
        /// </summary>
        RF_NeedInitialization = 0x00000200,
        /// <summary>
        /// During load, indicates object needs loading.
        /// </summary>
        RF_NeedLoad = 0x00000400,
        /// <summary>
        /// Keep this object during garbage collection because it's still being used by the cooker.
        /// </summary>
        RF_KeepForCooker = 0x00000800,
        /// <summary>
        /// Object needs to be postloaded.
        /// </summary>
        RF_NeedPostLoad = 0x00001000,
        /// <summary>
        /// During load, indicates that the object still needs to instance subobjects and fixup serialized component references.
        /// </summary>
        RF_NeedPostLoadSubobjects = 0x00002000,
        /// <summary>
        /// Object has been consigned to oblivion due to its owner package being reloaded, and a newer version currently exists.
        /// </summary>
        RF_NewerVersionExists = 0x00004000,
        /// <summary>
        /// BeginDestroy has been called on the object.
        /// </summary>
        RF_BeginDestroyed = 0x00008000,
        /// <summary>
        /// FinishDestroy has been called on the object.
        /// </summary>
        RF_FinishDestroyed = 0x00010000,

        // Misc. Flags
        /// <summary>
        /// Flagged on UObjects that are used to create UClasses (e.g. Blueprints) while they are regenerating their UClass on load (See FLinkerLoad::CreateExport())
        /// </summary>
        RF_BeingRegenerated = 0x00020000,
        /// <summary>
        /// Flagged on subobjects that are defaults.
        /// </summary>
        RF_DefaultSubObject = 0x00040000,
        /// <summary>
        /// Flagged on UObjects that were loaded.
        /// </summary>
        RF_WasLoaded = 0x00080000,
        /// <summary>
        /// Do not export object to text form (e.g. copy/paste). Generally used for sub-objects that can be regenerated from data in their parent object.
        /// </summary>
        RF_TextExportTransient = 0x00100000,
        /// <summary>
        /// Object has been completely serialized by linkerload at least once. DO NOT USE THIS FLAG, It should be replaced with RF_WasLoaded.
        /// </summary>
        RF_LoadCompleted = 0x00200000,
        /// <summary>
        /// Archetype of the object can be in its super class.
        /// </summary>
        RF_InheritableComponentTemplate = 0x00400000,
        /// <summary>
        /// Object should not be included in any type of duplication (copy/paste, binary duplication, etc).
        /// </summary>
        RF_DuplicateTransient = 0x00800000,
        /// <summary>
        /// References to this object from persistent function frame are handled as strong ones.
        /// </summary>
        RF_StrongRefOnFrame = 0x01000000,
        /// <summary>
        /// Object should not be included for duplication unless it's being duplicated for a PIE session.
        /// </summary>
        RF_NonPIEDuplicateTransient = 0x02000000,
        /// <summary>
        /// Field Only. Dynamic field - doesn't get constructed during static initialization, can be constructed multiple times.
        /// </summary>
        RF_Dynamic = 0x04000000,
        /// <summary>
        /// This object was constructed during load and will be loaded shortly.
        /// </summary>
        RF_WillBeLoaded = 0x08000000,

        /// <summary>
        /// Flags to load from Unrealfiles.
        /// </summary>
        RF_Load = RF_Public | RF_Standalone | RF_Transactional | RF_ClassDefaultObject | RF_ArchetypeObject | RF_DefaultSubObject | RF_TextExportTransient | RF_InheritableComponentTemplate | RF_DuplicateTransient | RF_NonPIEDuplicateTransient,
        /// <summary>
        /// Sub-objects will inherit these flags from their SuperObject.
        /// </summary>
        RF_PropagateToSubObjects = RF_Public | RF_ArchetypeObject | RF_Transactional | RF_Transient,
        /// <summary>
        /// All flags, used mainly for error checking.
        /// </summary>
        RF_AllFlags = 0x0fffffff,
    }
}

```

`src/UETools.Objects/Enums/EPixelFormat.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Text;

namespace UETools.Objects.Enums
{
    public enum EPixelFormat
    {
        PF_Unknown = 0,
        PF_A32B32G32R32F = 1,
        PF_B8G8R8A8 = 2,
        PF_G8 = 3,
        PF_G16 = 4,
        PF_DXT1 = 5,
        PF_DXT3 = 6,
        PF_DXT5 = 7,
        PF_UYVY = 8,
        PF_FloatRGB = 9,
        PF_FloatRGBA = 10,
        PF_DepthStencil = 11,
        PF_ShadowDepth = 12,
        PF_R32_FLOAT = 13,
        PF_G16R16 = 14,
        PF_G16R16F = 15,
        PF_G16R16F_FILTER = 16,
        PF_G32R32F = 17,
        PF_A2B10G10R10 = 18,
        PF_A16B16G16R16 = 19,
        PF_D24 = 20,
        PF_R16F = 21,
        PF_R16F_FILTER = 22,
        PF_BC5 = 23,
        PF_V8U8 = 24,
        PF_A1 = 25,
        PF_FloatR11G11B10 = 26,
        PF_A8 = 27,
        PF_R32_UINT = 28,
        PF_R32_SINT = 29,
        PF_PVRTC2 = 30,
        PF_PVRTC4 = 31,
        PF_R16_UINT = 32,
        PF_R16_SINT = 33,
        PF_R16G16B16A16_UINT = 34,
        PF_R16G16B16A16_SINT = 35,
        PF_R5G6B5_UNORM = 36,
        PF_R8G8B8A8 = 37,
        PF_A8R8G8B8 = 38,
        PF_BC4 = 39,
        PF_R8G8 = 40,
        PF_ATC_RGB = 41,
        PF_ATC_RGBA_E = 42,
        PF_ATC_RGBA_I = 43,
        PF_X24_G8 = 44,
        PF_ETC1 = 45,
        PF_ETC2_RGB = 46,
        PF_ETC2_RGBA = 47,
        PF_R32G32B32A32_UINT = 48,
        PF_R16G16_UINT = 49,
        PF_ASTC_4x4 = 50,
        PF_ASTC_6x6 = 51,
        PF_ASTC_8x8 = 52,
        PF_ASTC_10x10 = 53,
        PF_ASTC_12x12 = 54,
        PF_BC6H = 55,
        PF_BC7 = 56,
        PF_R8_UINT = 57,
        PF_L8 = 58,
        PF_XGXR8 = 59,
        PF_R8G8B8A8_UINT = 60,
        PF_R8G8B8A8_SNORM = 61,
        PF_R16G16B16A16_UNORM = 62,
        PF_R16G16B16A16_SNORM = 63,
        PF_PLATFORM_HDR_0 = 64,
        PF_PLATFORM_HDR_1 = 65,
        PF_PLATFORM_HDR_2 = 66,
        PF_NV12 = 67,
        PF_R32G32_UINT = 68,
        PF_ETC2_R11_EAC = 69,
        PF_ETC2_RG11_EAC = 70,
        PF_MAX = 71,
    }
}

```

`src/UETools.Objects/Enums/RichCurveKey.InterpMode.cs`:

```cs
namespace UETools.Objects.Structures
{
    partial struct RichCurveKey
    {
        /// <summary>
        /// Method of interpolation between this key and the next.
        /// </summary>
        enum InterpMode : byte
        {
            /// <summary>
            /// Use linear interpolation between values.
            /// </summary>
            Linear,
            /// <summary>
            /// Use a constant value. Represents stepped values.
            /// </summary>
            Constant,
            /// <summary>
            /// Cubic interpolation. See TangentMode for different cubic interpolation options.
            /// </summary>
            Cubic,
            /// <summary>
            /// No interpolation.
            /// </summary>
            None,
        }
    }
}

```

`src/UETools.Objects/Enums/RichCurveKey.TangentMode.cs`:

```cs
namespace UETools.Objects.Structures
{
    partial struct RichCurveKey
    {
        /// <summary>Used only if using RCIM_Cubic.</summary>
        /// <remarks>
        /// If using RCIM_Cubic, this enum describes how the tangents should be controlled in editor.
        /// </remarks>
        enum TangentMode : byte
        {
            /// <summary>
            /// Automatically calculates tangents to create smooth curves between values.
            /// </summary>
            Auto,
            /// <summary>
            /// User specifies the tangent as a unified tangent where the two tangents are locked to each other, presenting a consistent curve before and after.
            /// </summary>
            User,
            /// <summary>
            /// User specifies the tangent as two separate broken tangents on each side of the key which can allow a sharp change in evaluation before or after.
            /// </summary>
            Break,
            /// <summary>
            /// No tangents.
            /// </summary>
            None,
        }
    }
}

```

`src/UETools.Objects/Enums/RichCurveKey.TangentWeightMode.cs`:

```cs
namespace UETools.Objects.Structures
{
    partial struct RichCurveKey
    {
        /// <summary>
        /// Enumerates tangent weight modes.
        /// </summary>
        enum TangentWeightMode : byte
        {
            /// <summary>
            /// Don't take tangent weights into account.
            /// </summary>
            WeightedNone,
            /// <summary>
            /// Only take the arrival tangent weight into account for evaluation.
            /// </summary>
            WeightedArrive,
            /// <summary>
            /// Only take the leaving tangent weight into account for evaluation.
            /// </summary>
            WeightedLeave,
            /// <summary>
            /// Take both the arrival and leaving tangent weights into account for evaluation.
            /// </summary>
            WeightedBoth,
        }
    }
}

```

`src/UETools.Objects/Interfaces/IProperty.cs`:

```cs
using System.IO;
using UETools.Core;

namespace UETools.Objects.Interfaces
{
    public interface IProperty
    {
        object Value { get; set; }

        FArchive Serialize(FArchive reader, PropertyTag tag);
    }
}

```

`src/UETools.Objects/Interfaces/IUnrealStruct.cs`:

```cs
using UETools.Core.Interfaces;

namespace UETools.Objects.Interfaces
{
    interface IUnrealStruct : IUnrealSerializable
    {
    }
}

```

`src/UETools.Objects/KismetVM/BlueprintReader.cs`:

```cs
using UETools.Core;
using UETools.Core.Interfaces;

namespace UETools.Objects.KismetVM
{
    public sealed class BlueprintReader : IUnrealSerializable
    {
        public TokenList Code { get; } = new TokenList();
        public long CodeLength => _codeEnd - _codeStart;

        public FArchive Serialize(FArchive archive)
        {
            _codeStart = archive.Tell();
            Code.ReadUntil(archive, EExprToken.EX_EndOfScript);
            _codeEnd = archive.Tell();
            return archive;
        }

        private long _codeStart;
        private long _codeEnd;
    }
}

```

`src/UETools.Objects/KismetVM/CodeSkipSize.cs`:

```cs
using UETools.Core;
using UETools.Core.Enums;
using UETools.Core.Interfaces;

namespace UETools.Objects.KismetVM
{
    public struct CodeSkipSize : IUnrealSerializable
    {
        public static implicit operator int(CodeSkipSize size) => size.SkipValue;
        public static implicit operator CodeSkipSize(int size) => new CodeSkipSize()
        {
            SkipValue = size
        };

        public int SkipValue { get; private set; }

        public FArchive Serialize(FArchive archive)
        {
            if (archive.Version < UE4Version.VER_UE4_DISABLED_SCRIPT_LIMIT_BYTECODE)
            {
                short skip = 0;
                archive.Read(ref skip);
                SkipValue = skip;
            }
            else
            {
                int skip = 0;
                archive.Read(ref skip);
                SkipValue = skip;
            }
            return archive;
        }

        public override string ToString() => SkipValue.ToString();
    }
}

```

`src/UETools.Objects/KismetVM/Enums/EBlueprintTextLiteralType.cs`:

```cs
using UETools.Core;

namespace UETools.Objects.KismetVM.Enums
{
    internal enum EBlueprintTextLiteralType : byte
    {
        /// <summary>
        /// Text is an empty string.
        /// </summary>
        /// <remarks>The bytecode contains no strings, and you should use <see cref="FText.GetEmpty"/> to initialize the <see cref="FText"/> instance.</remarks>
        Empty,
        /// <summary>
        /// Text is localized.
        /// </summary>
        /// <remarks>The bytecode will contain three strings - source, key, and namespace - and should be loaded via FInternationalization</remarks>
        LocalizedText,
        /// <summary>
        /// Text is culture invariant.
        /// </summary>
        /// <remarks>The bytecode will contain one string, and you should use <see cref="FText.AsCultureInvariant"/> to initialize the <see cref="FText"/> instance.</remarks>
        InvariantText,
        /// <summary>
        /// Text is a literal FString.
        /// </summary>
        /// <remarks>The bytecode will contain one string, and you should use <see cref="FText.FromString"/> to initialize the <see cref="FText"/> instance.</remarks>
        LiteralString,
        /// <summary>
        /// Text is from a string table.
        /// </summary>
        /// <remarks>The bytecode will contain an object pointer (not used) and two strings - the table ID, and key - and should be found via <see cref="FText.FromStringTable"/>.</remarks>
        StringTableEntry,
    }
}

```

`src/UETools.Objects/KismetVM/Enums/ECastToken.cs`:

```cs
namespace UETools.Objects.KismetVM
{
    /// <summary>
    /// Bytecode instruction values for casting.
    /// </summary>
    /// <remarks>Should be kept in sync with <see href="https://github.com/EpicGames/UnrealEngine/blob/master/Engine/Source/Runtime/CoreUObject/Public/UObject/Script.h#L162">EExprToken enum</see></remarks>
    //[EnumChecker("https://docs.unrealengine.com/en-US/API/Runtime/CoreUObject/UObject/ECastToken/index.html")]
    public enum ECastToken : byte
    {
        /// <summary>
        /// Cast object expression to interface.
        /// </summary>
        CST_ObjectToInterface = 0x46,
        /// <summary>
        /// Casts object expression to boolean.
        /// </summary>
        CST_ObjectToBool = 0x47,
        /// <summary>
        /// Casts interface expression to boolean
        /// </summary>
        CST_InterfaceToBool = 0x49,
    }
}
```

`src/UETools.Objects/KismetVM/Enums/EEventType.cs`:

```cs
namespace UETools.Objects.KismetVM.Instructions
{
    public enum EScriptInstrumentation : byte
    {
        Class = 0,
        ClassScope,
        Instance,
        Event,
        InlineEvent,
        ResumeEvent,
        PureNodeEntry,
        NodeDebugSite,
        NodeEntry,
        NodeExit,
        PushState,
        RestoreState,
        ResetState,
        SuspendState,
        PopState,
        TunnelEndOfThread,
        Stop
    }
}

```

`src/UETools.Objects/KismetVM/Enums/EExprToken.cs`:

```cs
//using UnrealTools.CodeGen.Attributes;

namespace UETools.Objects.KismetVM
{
    /// <summary>
    /// Values represent specific Kismet bytecode instructions.
    /// </summary>
    /// <remarks>Should be kept in sync with <see href="https://github.com/EpicGames/UnrealEngine/blob/master/Engine/Source/Runtime/CoreUObject/Public/UObject/Script.h#L162">EExprToken enum</see></remarks>
    //[EnumUpdater("https://docs.unrealengine.com/en-US/API/Runtime/CoreUObject/UObject/EExprToken/index.html")]
    public enum EExprToken : byte
    {
        /// <summary>
        /// A local variable.
        /// </summary>
        EX_LocalVariable = 0x00,
        /// <summary>
        /// An object variable.
        /// </summary>
        EX_InstanceVariable = 0x01,
        /// <summary>
        /// Default variable for a class context.
        /// </summary>
        EX_DefaultVariable = 0x02,
        /// <summary>
        /// Return from function.
        /// </summary>
        EX_Return = 0x04,
        /// <summary>
        /// Goto a local address in code.
        /// </summary>
        EX_Jump = 0x06,
        /// <summary>
        /// Goto if not expression.
        /// </summary>
        EX_JumpIfNot = 0x07,
        /// <summary>
        /// Assertion.
        /// </summary>
        EX_Assert = 0x09,
        /// <summary>
        /// No operation.
        /// </summary>
        EX_Nothing = 0x0B,
        /// <summary>
        /// Assign an arbitrary size value to a variable.
        /// </summary>
        EX_Let = 0x0F,
        /// <summary>
        /// Class default object context.
        /// </summary>
        EX_ClassContext = 0x12,
        /// <summary>
        /// Metaclass cast.
        /// </summary>
        EX_MetaCast = 0x13,
        /// <summary>
        /// Let boolean variable.
        /// </summary>
        EX_LetBool = 0x14,
        /// <summary>
        /// End of default value for optional function parameter.
        /// </summary>
        EX_EndParmValue = 0x15,
        /// <summary>
        /// End of function call parameters.
        /// </summary>
        EX_EndFunctionParms = 0x16,
        /// <summary>
        /// Self object.
        /// </summary>
        EX_Self = 0x17,
        /// <summary>
        /// Skippable expression.
        /// </summary>
        EX_Skip = 0x18,
        /// <summary>
        /// Call a function through an object context.
        /// </summary>
        EX_Context = 0x19,
        /// <summary>
        /// Call a function through an object context (can fail silently if the context is NULL; only generated for functions that don't have output or return values).
        /// </summary>
        EX_Context_FailSilent = 0x1A,
        /// <summary>
        /// A function call with parameters.
        /// </summary>
        EX_VirtualFunction = 0x1B,
        /// <summary>
        /// A prebound function call with parameters.
        /// </summary>
        EX_FinalFunction = 0x1C,
        /// <summary>
        /// Int constant.
        /// </summary>
        EX_IntConst = 0x1D,
        /// <summary>
        /// Floating point constant.
        /// </summary>
        EX_FloatConst = 0x1E,
        /// <summary>
        /// String constant.
        /// </summary>
        EX_StringConst = 0x1F,
        /// <summary>
        /// An object constant.
        /// </summary>
        EX_ObjectConst = 0x20,
        /// <summary>
        /// A name constant.
        /// </summary>
        EX_NameConst = 0x21,
        /// <summary>
        /// A rotation constant.
        /// </summary>
        EX_RotationConst = 0x22,
        /// <summary>
        /// A vector constant.
        /// </summary>
        EX_VectorConst = 0x23,
        /// <summary>
        /// A byte constant.
        /// </summary>
        EX_ByteConst = 0x24,
        /// <summary>
        /// Zero.
        /// </summary>
        EX_IntZero = 0x25,
        /// <summary>
        /// One.
        /// </summary>
        EX_IntOne = 0x26,
        /// <summary>
        /// Bool True.
        /// </summary>
        EX_True = 0x27,
        /// <summary>
        /// Bool False.
        /// </summary>
        EX_False = 0x28,
        /// <summary>
        /// FText constant.
        /// </summary>
        EX_TextConst = 0x29,
        /// <summary>
        /// NoObject, <see langword="null"/> value.
        /// </summary>
        EX_NoObject = 0x2A,
        /// <summary>
        /// A transform constant.
        /// </summary>
        EX_TransformConst = 0x2B,
        /// <summary>
        /// Int constant that requires 1 byte.
        /// </summary>
        EX_IntConstByte = 0x2C,
        /// <summary>
        /// A <see langword="null"/> interface (similar to <seealso cref="EX_NoObject"/>, but for interfaces).
        /// </summary>
        EX_NoInterface = 0x2D,
        /// <summary>
        /// Safe dynamic class casting.
        /// </summary>
        EX_DynamicCast = 0x2E,
        /// <summary>
        /// An arbitrary UStruct constant.
        /// </summary>
        EX_StructConst = 0x2F,
        /// <summary>
        /// End of UStruct constant.
        /// </summary>
        EX_EndStructConst = 0x30,
        /// <summary>
        /// Set the value of arbitrary array.
        /// </summary>
        EX_SetArray = 0x31,
        /// <summary>
        /// End of the value list of arbitrary array
        /// </summary>
        EX_EndArray = 0x32,
        /// <summary>
        /// Unicode string constant.
        /// </summary>
        EX_UnicodeStringConst = 0x34,
        /// <summary>
        /// 64-bit integer constant.
        /// </summary>
        EX_Int64Const = 0x35,
        /// <summary>
        /// 64-bit unsigned integer constant.
        /// </summary>
        EX_UInt64Const = 0x36,
        /// <summary>
        /// A casting operator for primitives which reads the type as the subsequent byte of <see cref="ECastToken"/>.
        /// </summary>
        EX_PrimitiveCast = 0x38,
        /// <summary>
        /// Initialization of set elements.
        /// </summary>
        EX_SetSet = 0x39,
        /// <summary>
        /// End of set elements initialization.
        /// </summary>
        EX_EndSet = 0x3A,
        /// <summary>
        /// Initialization of map elements.
        /// </summary>
        EX_SetMap = 0x3B,
        /// <summary>
        /// End of map elements initialization.
        /// </summary>
        EX_EndMap = 0x3C,
        /// <summary>
        /// Initialization of set with constant arguments.
        /// </summary>
        EX_SetConst = 0x3D,
        /// <summary>
        /// End of set constants elements.
        /// </summary>
        EX_EndSetConst = 0x3E,
        /// <summary>
        /// Initialization of map with constant arguments.
        /// </summary>
        EX_MapConst = 0x3F,
        /// <summary>
        /// End of map constants elements.
        /// </summary>
        EX_EndMapConst = 0x40,
        /// <summary>
        /// Context expression to address a property within a struct.
        /// </summary>
        EX_StructMemberContext = 0x42,
        /// <summary>
        /// Assignment to a multi-cast delegate.
        /// </summary>
        EX_LetMulticastDelegate = 0x43,
        /// <summary>
        /// Assignment to a delegate.
        /// </summary>
        EX_LetDelegate = 0x44,
        /// <summary>
        /// Special instructions to quickly call a virtual function that we know is going to run only locally.
        /// </summary>
        EX_LocalVirtualFunction = 0x45,
        /// <summary>
        /// Special instructions to quickly call a final function that we know is going to run only locally.
        /// </summary>
        EX_LocalFinalFunction = 0x46,
        /// <summary>
        /// Local out (pass by reference) function parameter.
        /// </summary>
        EX_LocalOutVariable = 0x48,
        /// <summary>
        /// Deprecated opcode.
        /// </summary>
        EX_DeprecatedOp4A = 0x4A,
        /// <summary>
        /// Const reference to a delegate or normal function object.
        /// </summary>
        EX_InstanceDelegate = 0x4B,
        /// <summary>
        /// Push an address on to the execution flow stack for future execution when a <see cref="EX_PopExecutionFlow"/> is executed. Execution continues on normally and doesn't change to the pushed address.
        /// </summary>
        EX_PushExecutionFlow = 0x4C,
        /// <summary>
        /// Continue execution at the last address previously pushed onto the execution flow stack.
        /// </summary>
        EX_PopExecutionFlow = 0x4D,
        /// <summary>
        /// Goto a local address in code, specified by an integer value.
        /// </summary>
        EX_ComputedJump = 0x4E,
        /// <summary>
        /// Continue execution at the last address previously pushed onto the execution flow stack, if the condition is not true.
        /// </summary>
        EX_PopExecutionFlowIfNot = 0x4F,
        /// <summary>
        /// Breakpoint. Only observed in the editor, otherwise it behaves like <see cref="EX_Nothing"/>.
        /// </summary>
        EX_Breakpoint = 0x50,
        /// <summary>
        /// Call a function through a native interface variable.
        /// </summary>
        EX_InterfaceContext = 0x51,
        /// <summary>
        /// Converting an object reference to native interface variable.
        /// </summary>
        EX_ObjToInterfaceCast = 0x52,
        /// <summary>
        /// Last byte in script code.
        /// </summary>
        EX_EndOfScript = 0x53,
        /// <summary>
        /// Converting an interface variable reference to native interface variable.
        /// </summary>
        EX_CrossInterfaceCast = 0x54,
        /// <summary>
        /// Converting an interface variable reference to an object.
        /// </summary>
        EX_InterfaceToObjCast = 0x55,
        /// <summary>
        /// Trace point. Only observed in the editor, otherwise it behaves like <see cref="EX_Nothing"/>.
        /// </summary>
        EX_WireTracepoint = 0x5A,
        /// <summary>
        /// A CodeSizeSkipOffset constant
        /// </summary>
        EX_SkipOffsetConst = 0x5B,
        /// <summary>
        /// Adds a delegate to a multicast delegate's targets.
        /// </summary>
        EX_AddMulticastDelegate = 0x5C,
        /// <summary>
        /// Clears all delegates in a multicast target.
        /// </summary>
        EX_ClearMulticastDelegate = 0x5D,
        /// <summary>
        /// Trace point. Only observed in the editor, otherwise it behaves like <see cref="EX_Nothing"/>.
        /// </summary>
        EX_Tracepoint = 0x5E,
        /// <summary>
        /// Assign to any object ref pointer.
        /// </summary>
        EX_LetObj = 0x5F,
        /// <summary>
        /// Assign to a weak object pointer
        /// </summary>
        EX_LetWeakObjPtr = 0x60,
        /// <summary>
        /// Bind object and name to delegate
        /// </summary>
        EX_BindDelegate = 0x61,
        /// <summary>
        /// Remove a delegate from a multicast delegate's targets.
        /// </summary>
        EX_RemoveMulticastDelegate = 0x62,
        /// <summary>
        /// Call multicast delegate.
        /// </summary>
        EX_CallMulticastDelegate = 0x63,
        /// <summary>
        /// Assign to value on persistent frame.
        /// </summary>
        EX_LetValueOnPersistentFrame = 0x64,
        /// <summary>
        /// Initialization of array with constant elements.
        /// </summary>
        EX_ArrayConst = 0x65,
        /// <summary>
        /// End of constant array element list.
        /// </summary>
        EX_EndArrayConst = 0x66,
        /// <summary>
        /// SoftObject instance, initialized with a constant.
        /// </summary>
        EX_SoftObjectConst = 0x67,
        /// <summary>
        /// Static pure function from on local call space.
        /// </summary>
        EX_CallMath = 0x68,
        /// <summary>
        /// Switch expression.
        /// </summary>
        EX_SwitchValue = 0x69,
        /// <summary>
        /// Instrumentation event.
        /// </summary>
        EX_InstrumentationEvent = 0x6A,
        /// <summary>
        /// Get array element reference.
        /// </summary>
        EX_ArrayGetByRef = 0x6B
    };
}

```

`src/UETools.Objects/KismetVM/Instructions/ArrayGetByRef.cs`:

```cs
using System.IO;
using UETools.Core;

namespace UETools.Objects.KismetVM.Instructions
{
    internal sealed class ArrayGetByRef : Token
    {
        public override EExprToken Expr => EExprToken.EX_ArrayGetByRef;

        public Token ArrayExpr { get; private set; } = null!;
        public Token IndexExpr { get; private set; } = null!;

        public override FArchive Serialize(FArchive archive)
        {
            base.Serialize(archive);
            ArrayExpr = Token.Read(archive);
            IndexExpr = Token.Read(archive);
            return archive;
        }

        public override void ReadTo(TextWriter writer)
        {
            ArrayExpr.ReadTo(writer);
            writer.Write('[');
            IndexExpr.ReadTo(writer);
            writer.Write(']');
        }
    }
}

```

`src/UETools.Objects/KismetVM/Instructions/Assignments/Let.cs`:

```cs
using UETools.Core;
using UETools.Objects.Package;

namespace UETools.Objects.KismetVM.Instructions
{
    internal sealed class Let : LetToken
    {
        public override EExprToken Expr => EExprToken.EX_Let;

        public override FArchive Serialize(FArchive archive)
        {
            archive.Read(ref _property);
            return base.Serialize(archive);
        }

        ObjectReference _property = null!;
    }
}

```

`src/UETools.Objects/KismetVM/Instructions/Assignments/LetBool.cs`:

```cs
namespace UETools.Objects.KismetVM.Instructions
{
    internal sealed class LetBool : LetToken
    {
        public override EExprToken Expr => EExprToken.EX_LetBool;
    }
}

```

`src/UETools.Objects/KismetVM/Instructions/Assignments/LetDelegate.cs`:

```cs
namespace UETools.Objects.KismetVM.Instructions
{
    internal sealed class LetDelegate : LetToken
    {
        public override EExprToken Expr => EExprToken.EX_LetDelegate;
    }
}

```

`src/UETools.Objects/KismetVM/Instructions/Assignments/LetMulticastDelegate.cs`:

```cs
namespace UETools.Objects.KismetVM.Instructions
{
    internal sealed class LetMulticastDelegate : LetToken
    {
        public override EExprToken Expr => EExprToken.EX_LetMulticastDelegate;
    }
}

```

`src/UETools.Objects/KismetVM/Instructions/Assignments/LetObj.cs`:

```cs
namespace UETools.Objects.KismetVM.Instructions
{
    internal sealed class LetObj : LetToken
    {
        public override EExprToken Expr => EExprToken.EX_LetObj;
    }
}

```

`src/UETools.Objects/KismetVM/Instructions/Assignments/LetToken.cs`:

```cs
using System.IO;
using UETools.Core;

namespace UETools.Objects.KismetVM.Instructions
{
    internal abstract class LetToken : Token
    {
        public Token To { get; private set; } = null!;
        public Token From { get; private set; } = null!;
        public override FArchive Serialize(FArchive archive)
        {
            base.Serialize(archive);
            To = Token.Read(archive);
            From = Token.Read(archive);
            return archive;
        }

        public override void ReadTo(TextWriter writer)
        {
            To.ReadTo(writer);
            writer.Write(" = ");
            From.ReadTo(writer);
        }
    }
}

```

`src/UETools.Objects/KismetVM/Instructions/Assignments/LetValueOnPersistentFrame.cs`:

```cs
using System;
using System.IO;
using UETools.Core;
using UETools.Objects.Package;

namespace UETools.Objects.KismetVM.Instructions
{
    internal sealed class LetValueOnPersistentFrame : Token
    {
        public override EExprToken Expr => EExprToken.EX_LetValueOnPersistentFrame;

        public Token Expression { get; private set; } = null!;

        public override FArchive Serialize(FArchive archive)
        {
            base.Serialize(archive)
                .Read(ref _prop);
            Expression = Token.Read(archive);
            return archive;
        }

        public override void ReadTo(TextWriter writer)
        {
            throw new NotImplementedException();
        }

        private ObjectReference _prop = null!;
    }
}

```

`src/UETools.Objects/KismetVM/Instructions/Assignments/LetWeakObjPtr.cs`:

```cs
namespace UETools.Objects.KismetVM.Instructions
{
    internal sealed class LetWeakObjPtr : LetToken
    {
        public override EExprToken Expr => EExprToken.EX_LetWeakObjPtr;
    }
}

```

`src/UETools.Objects/KismetVM/Instructions/Casts/CastToken.cs`:

```cs
using System.IO;
using UETools.Core;
using UETools.Objects.Package;

namespace UETools.Objects.KismetVM.Instructions
{
    internal abstract class CastToken : Token
    {
        public ObjectReference Variable { get => _variable; set => _variable = value; }
        public Token CastExpr { get; private set; } = null!;

        public override FArchive Serialize(FArchive archive)
        {
            base.Serialize(archive)
                .Read(ref _variable);
            CastExpr = Token.Read(archive);
            return archive;
        }

        public override void ReadTo(TextWriter writer)
        {
            CastExpr.ReadTo(writer);
            writer.Write($"var({Variable.Resource?.FullName})");
        }

        // TODO: Should be UClass ?
        private ObjectReference _variable = null!;
    }
}

```

`src/UETools.Objects/KismetVM/Instructions/Casts/CrossInterfaceCast.cs`:

```cs
namespace UETools.Objects.KismetVM.Instructions
{
    internal sealed class CrossInterfaceCast : CastToken
    {
        public override EExprToken Expr => EExprToken.EX_CrossInterfaceCast;
    }
}

```

`src/UETools.Objects/KismetVM/Instructions/Casts/DynamicCast.cs`:

```cs
namespace UETools.Objects.KismetVM.Instructions
{
    internal sealed class DynamicCast : CastToken
    {
        public override EExprToken Expr => EExprToken.EX_DynamicCast;
    }
}

```

`src/UETools.Objects/KismetVM/Instructions/Casts/InterfaceToObjCast.cs`:

```cs
namespace UETools.Objects.KismetVM.Instructions
{
    internal sealed class InterfaceToObjCast : CastToken
    {
        public override EExprToken Expr => EExprToken.EX_InterfaceToObjCast;
    }
}

```

`src/UETools.Objects/KismetVM/Instructions/Casts/MetaCast.cs`:

```cs
namespace UETools.Objects.KismetVM.Instructions
{
    internal sealed class MetaCast : CastToken
    {
        public override EExprToken Expr => EExprToken.EX_MetaCast;
    }
}

```

`src/UETools.Objects/KismetVM/Instructions/Casts/ObjToInterfaceCast.cs`:

```cs
namespace UETools.Objects.KismetVM.Instructions
{
    internal sealed class ObjToInterfaceCast : CastToken
    {
        public override EExprToken Expr => EExprToken.EX_ObjToInterfaceCast;
    }
}

```

`src/UETools.Objects/KismetVM/Instructions/Casts/PrimitiveCast.cs`:

```cs
using System;
using System.IO;
using UETools.Core;

namespace UETools.Objects.KismetVM.Instructions
{
    internal sealed class PrimitiveCast : Token
    {
        public override EExprToken Expr => EExprToken.EX_PrimitiveCast;
        public ECastToken CastTo { get => _castTo; set => _castTo = value; }
        public Token CastExpression { get; private set; } = null!;

        public override FArchive Serialize(FArchive archive)
        {
            base.Serialize(archive)
                .ReadUnsafe(ref _castTo);
            CastExpression = Token.Read(archive);
            return archive;
        }

        public override void ReadTo(TextWriter writer)
        {
            throw new NotImplementedException();
        }

        private ECastToken _castTo;
    }
}

```

`src/UETools.Objects/KismetVM/Instructions/Constants/ByteConst.cs`:

```cs
using UETools.Core;

namespace UETools.Objects.KismetVM.Instructions
{
    internal sealed class ByteConst : ConstToken<byte>
    {
        public override EExprToken Expr => EExprToken.EX_ByteConst;

        public override FArchive Serialize(FArchive archive)
            => base.Serialize(archive)
                   .Read(ref _value);
    }
}

```

`src/UETools.Objects/KismetVM/Instructions/Constants/ConstToken.cs`:

```cs
using System.IO;

namespace UETools.Objects.KismetVM.Instructions
{
    internal abstract class ConstToken<T> : Token
    {
        public T Value { get => _value; set => _value = value; }

        public override void ReadTo(TextWriter writer) => writer.Write(_value);

        protected T _value = default!;
    }
}

```

`src/UETools.Objects/KismetVM/Instructions/Constants/False.cs`:

```cs
using UETools.Core;

namespace UETools.Objects.KismetVM.Instructions
{
    internal sealed class False : ConstToken<bool>
    {
        public override EExprToken Expr => EExprToken.EX_False;

        public override FArchive Serialize(FArchive archive)
        {
            _value = false;
            return base.Serialize(archive);
        }
    }
}

```

`src/UETools.Objects/KismetVM/Instructions/Constants/FloatConst.cs`:

```cs
using UETools.Core;

namespace UETools.Objects.KismetVM.Instructions
{
    internal sealed class FloatConst : ConstToken<float>
    {
        public override EExprToken Expr => EExprToken.EX_FloatConst;

        public override FArchive Serialize(FArchive archive)
            => base.Serialize(archive)
                   .Read(ref _value);
    }
}

```

`src/UETools.Objects/KismetVM/Instructions/Constants/InstanceDelegate.cs`:

```cs
using UETools.Core;

namespace UETools.Objects.KismetVM.Instructions
{
    internal sealed class InstanceDelegate : ConstToken<FName>
    {
        public override EExprToken Expr => EExprToken.EX_InstanceDelegate;

        public override FArchive Serialize(FArchive archive)
            => base.Serialize(archive)
                   .Read(ref _value);
    }
}

```

`src/UETools.Objects/KismetVM/Instructions/Constants/Int64Const.cs`:

```cs
using UETools.Core;

namespace UETools.Objects.KismetVM.Instructions
{
    internal sealed class Int64Const : ConstToken<long>
    {
        public override EExprToken Expr => EExprToken.EX_Int64Const;

        public override FArchive Serialize(FArchive archive)
            => base.Serialize(archive)
                   .Read(ref _value);
    }
}

```

`src/UETools.Objects/KismetVM/Instructions/Constants/IntConst.cs`:

```cs
using UETools.Core;

namespace UETools.Objects.KismetVM.Instructions
{
    internal sealed class IntConst : ConstToken<int>
    {
        public override EExprToken Expr => EExprToken.EX_IntConst;

        public override FArchive Serialize(FArchive archive)
            => base.Serialize(archive)
                   .Read(ref _value);
    }
}

```

`src/UETools.Objects/KismetVM/Instructions/Constants/IntConstByte.cs`:

```cs
using UETools.Core;

namespace UETools.Objects.KismetVM.Instructions
{
    internal sealed class IntConstByte : ConstToken<int>
    {
        public override EExprToken Expr => EExprToken.EX_IntConstByte;

        public override FArchive Serialize(FArchive archive)
        {
            base.Serialize(archive);
            byte val = 0;
            archive.Read(ref val);
            _value = val;
            return archive;
        }
    }
}

```

`src/UETools.Objects/KismetVM/Instructions/Constants/IntOne.cs`:

```cs
using UETools.Core;

namespace UETools.Objects.KismetVM.Instructions
{
    internal sealed class IntOne : ConstToken<int>
    {
        public override EExprToken Expr => EExprToken.EX_IntOne;

        public override FArchive Serialize(FArchive archive)
        {
            _value = 1;
            return base.Serialize(archive);
        }
    }
}

```

`src/UETools.Objects/KismetVM/Instructions/Constants/IntZero.cs`:

```cs
using UETools.Core;

namespace UETools.Objects.KismetVM.Instructions
{
    internal sealed class IntZero : ConstToken<int>
    {
        public override EExprToken Expr => EExprToken.EX_IntZero;

        public override FArchive Serialize(FArchive archive)
        {
            _value = 0;
            return base.Serialize(archive);
        }
    }
}

```

`src/UETools.Objects/KismetVM/Instructions/Constants/NameConst.cs`:

```cs
using UETools.Core;

namespace UETools.Objects.KismetVM.Instructions
{
    internal sealed class NameConst : ConstToken<FName>
    {
        public override EExprToken Expr => EExprToken.EX_NameConst;

        public override FArchive Serialize(FArchive archive)
            => base.Serialize(archive)
                   .Read(ref _value);
    }
}

```

`src/UETools.Objects/KismetVM/Instructions/Constants/NoInterface.cs`:

```cs
using UETools.Core;

namespace UETools.Objects.KismetVM.Instructions
{
    internal sealed class NoInterface : ConstToken<object?>
    {
        public override EExprToken Expr => EExprToken.EX_NoInterface;

        public override FArchive Serialize(FArchive archive) => base.Serialize(archive);
    }
}

```

`src/UETools.Objects/KismetVM/Instructions/Constants/NoObject.cs`:

```cs
using UETools.Core;

namespace UETools.Objects.KismetVM.Instructions
{
    internal sealed class NoObject : ConstToken<object?>
    {
        public override EExprToken Expr => EExprToken.EX_NoObject;

        public override FArchive Serialize(FArchive archive) => base.Serialize(archive);
    }
}

```

`src/UETools.Objects/KismetVM/Instructions/Constants/ObjectConst.cs`:

```cs
using UETools.Core;
using UETools.Objects.Package;

namespace UETools.Objects.KismetVM.Instructions
{
    internal sealed class ObjectConst : ConstToken<ObjectReference>
    {
        public override EExprToken Expr => EExprToken.EX_ObjectConst;

        public override FArchive Serialize(FArchive archive)
            => base.Serialize(archive)
                   .Read(ref _value);
    }
}

```

`src/UETools.Objects/KismetVM/Instructions/Constants/RotationConst.cs`:

```cs
using UETools.Core;
using UETools.Objects.Structures;

namespace UETools.Objects.KismetVM.Instructions
{
    internal sealed class RotationConst : ConstToken<Rotator>
    {
        public override EExprToken Expr => EExprToken.EX_RotationConst;

        public override FArchive Serialize(FArchive archive)
            => base.Serialize(archive)
                   .Read(ref _value);
    }
}

```

`src/UETools.Objects/KismetVM/Instructions/Constants/SkipOffsetConst.cs`:

```cs
using System;
using System.IO;
using UETools.Core;

namespace UETools.Objects.KismetVM.Instructions
{
    internal sealed class SkipOffsetConst : Token
    {
        public override EExprToken Expr => EExprToken.EX_SkipOffsetConst;

        public CodeSkipSize Skip => _skip;

        public override FArchive Serialize(FArchive archive)
            => base.Serialize(archive)
                   .Read(ref _skip);

        public override void ReadTo(TextWriter writer)
        {
            throw new NotImplementedException();
        }

        private CodeSkipSize _skip;
    }
}

```

`src/UETools.Objects/KismetVM/Instructions/Constants/SoftObjectConst.cs`:

```cs
using UETools.Core;

namespace UETools.Objects.KismetVM.Instructions
{
    internal sealed class SoftObjectConst : ConstToken<Token>
    {
        public override EExprToken Expr => EExprToken.EX_SoftObjectConst;

        public override FArchive Serialize(FArchive archive)
        {
            base.Serialize(archive);
            _value = Token.Read(archive);
            return archive;
        }
    }
}

```

`src/UETools.Objects/KismetVM/Instructions/Constants/StringConst.cs`:

```cs
using System.Collections.Generic;
using System.Linq;
using UETools.Core;

namespace UETools.Objects.KismetVM.Instructions
{
    internal sealed class StringConst : ConstToken<string>
    {
        public override EExprToken Expr => EExprToken.EX_StringConst;
        private void ReadString8(FArchive reader, out string str)
        {
            var bytes = new List<byte>();
            do
            {
                bytes.Add(reader.Read<byte>());
            } while (bytes.Last() != 0);
            str = StringHelper.Create(bytes.Count - 1, bytes, (chars, b) =>
            {
                for (var i = 0; i < chars.Length; i++)
                {
                    chars[i] = (char)b[i];
                }
            });
        }

        public override FArchive Serialize(FArchive archive)
        {
            base.Serialize(archive);
            ReadString8(archive, out _value);
            return archive;
        }
    }
}

```

`src/UETools.Objects/KismetVM/Instructions/Constants/TextConst.cs`:

```cs
using UETools.Core;
using UETools.Objects.KismetVM.Enums;

namespace UETools.Objects.KismetVM.Instructions
{
    internal sealed partial class TextConst : ConstToken<FText>
    {
        public override EExprToken Expr => EExprToken.EX_TextConst;

        internal EBlueprintTextLiteralType TextLiteralType { get => _textLiteralType; set => _textLiteralType = value; }

        public override FArchive Serialize(FArchive archive)
        {
            base.Serialize(archive)
                .ReadUnsafe(ref _textLiteralType);
            switch (TextLiteralType)
            {
                case EBlueprintTextLiteralType.Empty:
                    _value = FText.GetEmpty();
                    break;
                case EBlueprintTextLiteralType.LocalizedText:
                    break;
                case EBlueprintTextLiteralType.InvariantText:
                    break;
                case EBlueprintTextLiteralType.LiteralString:
                    break;
                case EBlueprintTextLiteralType.StringTableEntry:
                    break;
                default:
                    break;
            }
            // TODO: Implement
            //reader.Read(ref _value);
            return archive;
        }

        private EBlueprintTextLiteralType _textLiteralType;
    }
}

```

`src/UETools.Objects/KismetVM/Instructions/Constants/TransformConst.cs`:

```cs
using UETools.Core;
using UETools.Core.Interfaces;
using UETools.Objects.Structures;

namespace UETools.Objects.KismetVM.Instructions
{
    internal sealed class TransformConst : ConstToken<Transform>
    {
        public override EExprToken Expr => EExprToken.EX_TransformConst;

        public override FArchive Serialize(FArchive archive)
            => base.Serialize(archive)
                   .Read(ref _value);
    }
}

```

`src/UETools.Objects/KismetVM/Instructions/Constants/True.cs`:

```cs
using UETools.Core;

namespace UETools.Objects.KismetVM.Instructions
{
    internal sealed class True : ConstToken<bool>
    {
        public override EExprToken Expr => EExprToken.EX_True;

        public override FArchive Serialize(FArchive archive)
        {
            _value = true;
            return base.Serialize(archive);
        }
    }
}

```

`src/UETools.Objects/KismetVM/Instructions/Constants/UInt64Const.cs`:

```cs
using UETools.Core;

namespace UETools.Objects.KismetVM.Instructions
{
    internal sealed class UInt64Const : ConstToken<ulong>
    {
        public override EExprToken Expr => EExprToken.EX_UInt64Const;

        public override FArchive Serialize(FArchive archive)
            => base.Serialize(archive)
                   .Read(ref _value);
    }
}

```

`src/UETools.Objects/KismetVM/Instructions/Constants/UnicodeStringConst.cs`:

```cs
using System.Collections.Generic;
using System.Linq;
using UETools.Core;

namespace UETools.Objects.KismetVM.Instructions
{
    internal sealed class UnicodeStringConst : ConstToken<string>
    {
        public override EExprToken Expr => EExprToken.EX_UnicodeStringConst;
        private void ReadString16(FArchive reader, out string str)
        {
            var bytes = new List<short>();
            do
            {
                bytes.Add(reader.Read<short>());
            } while (bytes.Last() != 0);
            str = StringHelper.Create(bytes.Count - 1, bytes, (chars, b) =>
            {
                for (var i = 0; i < chars.Length; i++)
                {
                    chars[i] = (char)b[i];
                }
            });

        }

        public override FArchive Serialize(FArchive archive)
        {
            base.Serialize(archive);
            ReadString16(archive, out _value);
            return archive;
        }
    }
}

```

`src/UETools.Objects/KismetVM/Instructions/Constants/VectorConst.cs`:

```cs
using UETools.Core;
using UETools.Objects.Structures;

namespace UETools.Objects.KismetVM.Instructions
{
    internal sealed class VectorConst : ConstToken<Vector>
    {
        public override EExprToken Expr => EExprToken.EX_VectorConst;

        public override FArchive Serialize(FArchive archive)
            => base.Serialize(archive)
                   .Read(ref _value);
    }
}

```

`src/UETools.Objects/KismetVM/Instructions/ControlFlow/Calls/CallMath.cs`:

```cs
using UETools.Objects.Package;

namespace UETools.Objects.KismetVM.Instructions
{
    internal sealed class CallMath : CallToken<ObjectReference>
    {
        public override EExprToken Expr => EExprToken.EX_CallMath;
    }
}

```

`src/UETools.Objects/KismetVM/Instructions/ControlFlow/Calls/CallToken.cs`:

```cs
using System.IO;
using UETools.Core;
using UETools.Core.Interfaces;

namespace UETools.Objects.KismetVM.Instructions
{
    internal abstract class CallToken<T> : Token where T : notnull, IUnrealSerializable, new()
    {
        public T CallTo => _callTo;
        public TokenList Params { get; } = new TokenList();

        public override FArchive Serialize(FArchive archive)
        {
            base.Serialize(archive)
                .Read(ref _callTo);
            Params.ReadUntil(archive, EExprToken.EX_EndFunctionParms);
            return archive;
        }
        public override void ReadTo(TextWriter writer)
        {
            writer.Write($"{Expr} {CallTo} (");
            var i = 0;
            foreach (var item in Params.Items)
            {
                if (i++ != 0)
                    writer.Write(", ");

                item.ReadTo(writer);
            }
            writer.WriteLine(")");
        }

        private T _callTo = default!;
    }
}

```

`src/UETools.Objects/KismetVM/Instructions/ControlFlow/Calls/Contexts/ClassContext.cs`:

```cs
namespace UETools.Objects.KismetVM.Instructions
{
    internal sealed class ClassContext : ContextToken
    {
        public override EExprToken Expr => EExprToken.EX_ClassContext;
    }
}

```

`src/UETools.Objects/KismetVM/Instructions/ControlFlow/Calls/Contexts/Context.cs`:

```cs
namespace UETools.Objects.KismetVM.Instructions
{
    internal sealed class Context : ContextToken
    {
        public override EExprToken Expr => EExprToken.EX_Context;
    }
}

```

`src/UETools.Objects/KismetVM/Instructions/ControlFlow/Calls/Contexts/ContextToken.cs`:

```cs
using System.IO;
using UETools.Core;
using UETools.Objects.Package;

namespace UETools.Objects.KismetVM.Instructions
{
    internal abstract class ContextToken : Token
    {
        public Token ObjectExpression { get; private set; } = null!;
        public CodeSkipSize SkipCount { get => _skipCount; set => _skipCount = value; }
        public ObjectReference Field { get => _field; set => _field = value; }
        public Token ContextExpression { get; private set; } = null!;

        public override FArchive Serialize(FArchive archive)
        {
            base.Serialize(archive);
            ObjectExpression = Token.Read(archive);
            archive.Read(ref _skipCount)
                   .Read(ref _field);
            ContextExpression = Token.Read(archive);
            return archive;
        }
        public override void ReadTo(TextWriter writer)
        {
            writer.Write("Context call ");
            ContextExpression.ReadTo(writer);
            writer.Write(" ");
            ObjectExpression.ReadTo(writer);
        }

        private ObjectReference _field = null!;
        private CodeSkipSize _skipCount;
    }
}

```

`src/UETools.Objects/KismetVM/Instructions/ControlFlow/Calls/Contexts/Context_FailSilent.cs`:

```cs
namespace UETools.Objects.KismetVM.Instructions
{
    internal sealed class Context_FailSilent : ContextToken
    {
        public override EExprToken Expr => EExprToken.EX_Context_FailSilent;
    }
}

```

`src/UETools.Objects/KismetVM/Instructions/ControlFlow/Calls/Contexts/InterfaceContext.cs`:

```cs
using System;
using System.IO;
using UETools.Core;

namespace UETools.Objects.KismetVM.Instructions
{
    internal sealed class InterfaceContext : Token
    {
        public override EExprToken Expr => EExprToken.EX_InterfaceContext;

        public Token InterfaceExpression { get; private set; } = null!;

        public override FArchive Serialize(FArchive archive)
        {
            base.Serialize(archive);
            InterfaceExpression = Token.Read(archive);
            return archive;
        }

        public override void ReadTo(TextWriter writer)
        {
            throw new NotImplementedException();
        }
    }
}

```

`src/UETools.Objects/KismetVM/Instructions/ControlFlow/Calls/Contexts/StructMemberContext.cs`:

```cs
using System;
using System.IO;
using UETools.Core;
using UETools.Objects.Package;

namespace UETools.Objects.KismetVM.Instructions
{
    internal sealed class StructMemberContext : Token
    {
        public override EExprToken Expr => EExprToken.EX_StructMemberContext;

        public ObjectReference Property => _property;
        public Token StructExpression { get; private set; } = null!;

        public override FArchive Serialize(FArchive archive)
        {
            base.Serialize(archive)
                .Read(ref _property);
            StructExpression = Token.Read(archive);
            return archive;
        }

        public override void ReadTo(TextWriter writer)
        {
            throw new NotImplementedException();
        }

        private ObjectReference _property = null!;
    }
}

```

`src/UETools.Objects/KismetVM/Instructions/ControlFlow/Calls/FinalFunction.cs`:

```cs
using UETools.Objects.Package;

namespace UETools.Objects.KismetVM.Instructions
{
    internal sealed class FinalFunction : CallToken<ObjectReference>
    {
        public override EExprToken Expr => EExprToken.EX_FinalFunction;
    }
}

```

`src/UETools.Objects/KismetVM/Instructions/ControlFlow/Calls/LocalFinalFunction.cs`:

```cs
using UETools.Objects.Package;

namespace UETools.Objects.KismetVM.Instructions
{
    internal sealed class LocalFinalFunction : CallToken<ObjectReference>
    {
        public override EExprToken Expr => EExprToken.EX_LocalFinalFunction;
    }
}

```

`src/UETools.Objects/KismetVM/Instructions/ControlFlow/Calls/LocalVirtualFunction.cs`:

```cs
using UETools.Core;

namespace UETools.Objects.KismetVM.Instructions
{
    internal sealed class LocalVirtualFunction : CallToken<FName>
    {
        public override EExprToken Expr => EExprToken.EX_LocalVirtualFunction;
    }
}

```

`src/UETools.Objects/KismetVM/Instructions/ControlFlow/Calls/VirtualFunction.cs`:

```cs
using UETools.Core;

namespace UETools.Objects.KismetVM.Instructions
{
    internal sealed class VirtualFunction : CallToken<FName>
    {
        public override EExprToken Expr => EExprToken.EX_VirtualFunction;
    }
}

```

`src/UETools.Objects/KismetVM/Instructions/ControlFlow/ComputedJump.cs`:

```cs
using System.IO;
using UETools.Core;

namespace UETools.Objects.KismetVM.Instructions
{
    internal sealed class ComputedJump : Token
    {
        public override EExprToken Expr => EExprToken.EX_ComputedJump;

        public Token Offset { get; private set; } = null!;

        public override FArchive Serialize(FArchive archive)
        {
            base.Serialize(archive);
            Offset = Token.Read(archive);
            return archive;
        }

        public override void ReadTo(TextWriter writer)
        {
            writer.Write("jump ");
            Offset.ReadTo(writer);
        }
    }
}

```

`src/UETools.Objects/KismetVM/Instructions/ControlFlow/Delegate/AddMulticastDelegate.cs`:

```cs
using System;
using System.IO;
using UETools.Core;

namespace UETools.Objects.KismetVM.Instructions
{
    public sealed class AddMulticastDelegate : Token
    {
        public override EExprToken Expr => EExprToken.EX_AddMulticastDelegate;

        public Token FirstExpr { get; private set; } = null!;
        public Token SecondExpr { get; private set; } = null!;

        public override FArchive Serialize(FArchive archive)
        {
            base.Serialize(archive);
            FirstExpr = Token.Read(archive);
            SecondExpr = Token.Read(archive);
            return archive;
        }

        public override void ReadTo(TextWriter writer)
        {
            throw new NotImplementedException();
        }
    }
}

```

`src/UETools.Objects/KismetVM/Instructions/ControlFlow/Delegate/BindDelegate.cs`:

```cs
using System;
using System.IO;
using UETools.Core;

namespace UETools.Objects.KismetVM.Instructions
{
    internal sealed class BindDelegate : Token
    {
        public override EExprToken Expr => EExprToken.EX_BindDelegate;

        public FName FuncName => _funcName;
        public Token FirstExpr { get; private set; } = null!;
        public Token SecondExpr { get; private set; } = null!;

        public override FArchive Serialize(FArchive archive)
        {
            base.Serialize(archive)
                .Read(ref _funcName);
            FirstExpr = Token.Read(archive);
            SecondExpr = Token.Read(archive);
            return archive;
        }

        public override void ReadTo(TextWriter writer)
        {
            throw new NotImplementedException();
        }

        private FName _funcName = null!;
    }
}

```

`src/UETools.Objects/KismetVM/Instructions/ControlFlow/Delegate/CallMulticastDelegate.cs`:

```cs
using System;
using System.IO;
using UETools.Core;
using UETools.Objects.Package;

namespace UETools.Objects.KismetVM.Instructions
{
    public sealed class CallMulticastDelegate : Token
    {
        public override EExprToken Expr => EExprToken.EX_CallMulticastDelegate;

        public ObjectReference CallTo { get => _callTo; set => _callTo = value; }
        public Token FirstExpr { get; set; } = null!;
        public TokenList Params { get; } = new TokenList();

        public override FArchive Serialize(FArchive archive)
        {
            base.Serialize(archive)
                .Read(ref _callTo);
            FirstExpr = Token.Read(archive);
            Params.ReadUntil(archive, EExprToken.EX_EndFunctionParms);
            return archive;
        }

        public override void ReadTo(TextWriter writer)
        {
            throw new NotImplementedException();
        }

        private ObjectReference _callTo = null!;
    }
}

```

`src/UETools.Objects/KismetVM/Instructions/ControlFlow/Delegate/ClearMulticastDelegate.cs`:

```cs
using System;
using System.IO;
using UETools.Core;

namespace UETools.Objects.KismetVM.Instructions
{
    public sealed class ClearMulticastDelegate : Token
    {
        public override EExprToken Expr => EExprToken.EX_ClearMulticastDelegate;

        public Token FirstExpr { get; private set; } = null!;

        public override FArchive Serialize(FArchive archive)
        {
            base.Serialize(archive);
            FirstExpr = Token.Read(archive);
            return archive;
        }

        public override void ReadTo(TextWriter writer)
        {
            throw new NotImplementedException();
        }
    }
}

```

`src/UETools.Objects/KismetVM/Instructions/ControlFlow/Delegate/RemoveMulticastDelegate.cs`:

```cs
using System;
using System.IO;
using UETools.Core;

namespace UETools.Objects.KismetVM.Instructions
{
    internal sealed class RemoveMulticastDelegate : Token
    {
        public override EExprToken Expr => EExprToken.EX_RemoveMulticastDelegate;

        public Token FirstExpr { get; private set; } = null!;
        public Token SecondExpr { get; private set; } = null!;

        public override FArchive Serialize(FArchive archive)
        {
            base.Serialize(archive);
            FirstExpr = Token.Read(archive);
            SecondExpr = Token.Read(archive);
            return archive;
        }

        public override void ReadTo(TextWriter writer)
        {
            throw new NotImplementedException();
        }
    }
}

```

`src/UETools.Objects/KismetVM/Instructions/ControlFlow/Jump.cs`:

```cs
using System.IO;
using UETools.Core;

namespace UETools.Objects.KismetVM.Instructions
{
    internal sealed class Jump : Token
    {
        public override EExprToken Expr => EExprToken.EX_Jump;

        public CodeSkipSize SkipCount { get => _skipCount; set => _skipCount = value; }

        public override FArchive Serialize(FArchive archive)
            => base.Serialize(archive)
                   .Read(ref _skipCount);

        public override void ReadTo(TextWriter writer) => writer.Write("Jump to {0}", SkipCount);

        private CodeSkipSize _skipCount;
    }
}

```

`src/UETools.Objects/KismetVM/Instructions/ControlFlow/JumpIfNot.cs`:

```cs
using System.IO;
using UETools.Core;

namespace UETools.Objects.KismetVM.Instructions
{
    internal sealed class JumpIfNot : Token
    {
        public override EExprToken Expr => EExprToken.EX_JumpIfNot;

        public CodeSkipSize Size => _size;
        public Token Expression { get; private set; } = null!;

        public override FArchive Serialize(FArchive archive)
        {
            base.Serialize(archive)
                .Read(ref _size);
            Expression = Token.Read(archive);
            return archive;
        }

        public override void ReadTo(TextWriter writer)
        {
            writer.Write("if not ");
            if (Expression != null)
                Expression.ReadTo(writer);
            writer.Write("jump to {0}", Size);
        }

        private CodeSkipSize _size;
    }
}

```

`src/UETools.Objects/KismetVM/Instructions/ControlFlow/PopExecutionFlow.cs`:

```cs
using System;
using System.IO;
using UETools.Core;

namespace UETools.Objects.KismetVM.Instructions
{
    internal sealed class PopExecutionFlow : Token
    {
        public override EExprToken Expr => EExprToken.EX_PopExecutionFlow;

        public override FArchive Serialize(FArchive archive) => base.Serialize(archive);

        public override void ReadTo(TextWriter writer)
        {
            throw new NotImplementedException();
        }
    }
}

```

`src/UETools.Objects/KismetVM/Instructions/ControlFlow/PopExecutionFlowIfNot.cs`:

```cs
using System;
using System.IO;
using UETools.Core;

namespace UETools.Objects.KismetVM.Instructions
{
    internal sealed class PopExecutionFlowIfNot : Token
    {
        public override EExprToken Expr => EExprToken.EX_PopExecutionFlowIfNot;

        public Token NotExpression { get; private set; } = null!;

        public override FArchive Serialize(FArchive archive)
        {
            base.Serialize(archive);
            NotExpression = Token.Read(archive);
            return archive;
        }

        public override void ReadTo(TextWriter writer)
        {
            throw new NotImplementedException();
        }
    }
}

```

`src/UETools.Objects/KismetVM/Instructions/ControlFlow/PushExecutionFlow.cs`:

```cs
using System.IO;
using UETools.Core;

namespace UETools.Objects.KismetVM.Instructions
{
    internal sealed class PushExecutionFlow : Token
    {
        public override EExprToken Expr => EExprToken.EX_PushExecutionFlow;

        public CodeSkipSize Size { get => _size; set => _size = value; }

        public override FArchive Serialize(FArchive archive)
            => base.Serialize(archive)
                   .Read(ref _size);

        public override void ReadTo(TextWriter writer) => writer.WriteLine($"push flowstack {Size}");

        private CodeSkipSize _size;
    }
}

```

`src/UETools.Objects/KismetVM/Instructions/ControlFlow/Return.cs`:

```cs
using System.IO;
using UETools.Core;

namespace UETools.Objects.KismetVM.Instructions
{
    internal sealed class Return : Token
    {
        public override EExprToken Expr => EExprToken.EX_Return;
        public Token RetVal { get; private set; } = null!;

        public override FArchive Serialize(FArchive archive)
        {
            base.Serialize(archive);
            RetVal = Token.Read(archive);
            return archive;
        }

        public override void ReadTo(TextWriter writer)
        {
            writer.Write("return ");
            if (RetVal != null)
                RetVal.ReadTo(writer);

            writer.WriteLine();
        }
    }
}

```

`src/UETools.Objects/KismetVM/Instructions/ControlFlow/Skip.cs`:

```cs
using System.IO;
using UETools.Core;

namespace UETools.Objects.KismetVM.Instructions
{
    internal sealed class Skip : Token
    {
        public override EExprToken Expr => EExprToken.EX_Skip;

        public CodeSkipSize Size { get => _size; set => _size = value; }
        public Token SkipExpression { get; private set; } = null!;

        public override FArchive Serialize(FArchive archive)
        {
            base.Serialize(archive)
                .Read(ref _size);
            SkipExpression = Token.Read(archive);
            return archive;
        }

        public override void ReadTo(TextWriter writer)
        {
            writer.Write($"Skip {Size} bytes of ");
            if (SkipExpression != null)
                SkipExpression.ReadTo(writer);
        }

        private CodeSkipSize _size;
    }
}

```

`src/UETools.Objects/KismetVM/Instructions/ControlFlow/SwitchValue.cs`:

```cs
using System;
using System.IO;
using UETools.Core;

namespace UETools.Objects.KismetVM.Instructions
{
    internal sealed class SwitchValue : Token
    {
        public override EExprToken Expr => EExprToken.EX_SwitchValue;
        public ushort NumCases { get => _numCases; set => _numCases = value; }
        public CodeSkipSize AfterSkip { get => _afterSkip; set => _afterSkip = value; }
        public Token IndexExpression { get; private set; } = null!;

        public override FArchive Serialize(FArchive archive)
        {
            base.Serialize(archive)
                .Read(ref _numCases)
                .Read(ref _afterSkip);
            IndexExpression = Token.Read(archive);
            for (int i = 0; i < NumCases; i++)
            {
                var label = Token.Read(archive);
                CodeSkipSize _nextCaseOffset = default;
                archive.Read(ref _nextCaseOffset);
                var term = Token.Read(archive);
            }
            var defaultCase = Token.Read(archive);
            return archive;
        }

        public override void ReadTo(TextWriter writer)
        {
            throw new NotImplementedException();
        }

        private ushort _numCases;
        private CodeSkipSize _afterSkip;
    }
}

```

`src/UETools.Objects/KismetVM/Instructions/DeprecatedOp4A.cs`:

```cs
using System.IO;
using UETools.Core;

namespace UETools.Objects.KismetVM.Instructions
{
    internal sealed class DeprecatedOp4A : Token
    {
        public override EExprToken Expr => EExprToken.EX_DeprecatedOp4A;

        public override FArchive Serialize(FArchive archive) => base.Serialize(archive);

        public override void ReadTo(TextWriter writer) => writer.WriteLine(Expr);
    }
}

```

`src/UETools.Objects/KismetVM/Instructions/Editor/Assert.cs`:

```cs
using System;
using System.IO;
using UETools.Core;

namespace UETools.Objects.KismetVM.Instructions
{
    internal sealed class Assert : Token
    {
        public override EExprToken Expr => EExprToken.EX_Assert;

        public ushort LineNumber { get => _lineNumber; set => _lineNumber = value; }
        public byte InDebugMode { get => _inDebugMode; set => _inDebugMode = value; }
        public Token Test { get; private set; } = null!;

        public override FArchive Serialize(FArchive archive)
        {
            base.Serialize(archive)
                .Read(ref _lineNumber)
                .Read(ref _inDebugMode);
            Test = Token.Read(archive);
            return archive;
        }

        public override void ReadTo(TextWriter writer)
        {
            throw new NotImplementedException();
        }

        private ushort _lineNumber;
        private byte _inDebugMode;
    }
}

```

`src/UETools.Objects/KismetVM/Instructions/Editor/Breakpoint.cs`:

```cs
using System.IO;
using UETools.Core;

namespace UETools.Objects.KismetVM.Instructions
{
    internal sealed class Breakpoint : Token
    {
        public override EExprToken Expr => EExprToken.EX_Breakpoint;

        public override FArchive Serialize(FArchive archive) => base.Serialize(archive);

        public override void ReadTo(TextWriter writer) => writer.WriteLine("Breakpoint");
    }
}

```

`src/UETools.Objects/KismetVM/Instructions/Editor/InstrumentationEvent.cs`:

```cs
using System.IO;
using UETools.Core;

namespace UETools.Objects.KismetVM.Instructions
{
    internal sealed partial class InstrumentationEvent : Token
    {
        public override EExprToken Expr => EExprToken.EX_InstrumentationEvent;

        public EScriptInstrumentation EventType => _eventType;

        public override FArchive Serialize(FArchive archive)
            => base.Serialize(archive)
                   .ReadUnsafe(ref _eventType);

        public override void ReadTo(TextWriter writer) => writer.WriteLine(EventType);

        private EScriptInstrumentation _eventType;
    }
}

```

`src/UETools.Objects/KismetVM/Instructions/Editor/Tracepoint.cs`:

```cs
using System.IO;
using UETools.Core;

namespace UETools.Objects.KismetVM.Instructions
{
    internal sealed class Tracepoint : Token
    {
        public override EExprToken Expr => EExprToken.EX_Tracepoint;

        public override FArchive Serialize(FArchive archive) => base.Serialize(archive);

        public override void ReadTo(TextWriter writer) => writer.WriteLine("Tracepoint");
    }
}

```

`src/UETools.Objects/KismetVM/Instructions/Editor/WireTracepoint.cs`:

```cs
using System.IO;
using UETools.Core;

namespace UETools.Objects.KismetVM.Instructions
{
    internal sealed class WireTracepoint : Token
    {
        public override EExprToken Expr => EExprToken.EX_WireTracepoint;

        public override FArchive Serialize(FArchive archive) => base.Serialize(archive);

        public override void ReadTo(TextWriter writer) => writer.WriteLine("WireTracepoint");
    }
}

```

`src/UETools.Objects/KismetVM/Instructions/EndOfScript.cs`:

```cs
using System.IO;

namespace UETools.Objects.KismetVM.Instructions
{
    internal sealed class EndOfScript : Token
    {
        public override EExprToken Expr => EExprToken.EX_EndOfScript;

        public override void ReadTo(TextWriter writer) => writer.WriteLine("EOF"); 
    }
}

```

`src/UETools.Objects/KismetVM/Instructions/ItemList/ArrayConst.cs`:

```cs
using System;
using System.IO;
using UETools.Core;
using UETools.Objects.Package;

namespace UETools.Objects.KismetVM.Instructions
{
    internal sealed class ArrayConst : CollectionToken
    {
        public override EExprToken Expr => EExprToken.EX_ArrayConst;

        public ObjectReference InnerProp => _innerProp;
        public int Count => _count;
        public TokenList Items { get; } = new TokenList();

        public override FArchive Serialize(FArchive archive)
        {
            base.Serialize(archive)
                .Read(ref _innerProp)
                .Read(ref _count);

            Items.ReadUntil(archive, EExprToken.EX_EndArrayConst);
            return archive;
        }

        public override void ReadTo(TextWriter writer)
        {
            throw new NotImplementedException();
        }

        private ObjectReference _innerProp = null!;
        private int _count;
    }
}

```

`src/UETools.Objects/KismetVM/Instructions/ItemList/CollectionToken.cs`:

```cs
namespace UETools.Objects.KismetVM.Instructions
{
    internal abstract class CollectionToken : Token
    {
    }
}

```

`src/UETools.Objects/KismetVM/Instructions/ItemList/Ends/EndArray.cs`:

```cs
namespace UETools.Objects.KismetVM.Instructions
{
    internal sealed class EndArray : EndToken
    {
        public override EExprToken Expr => EExprToken.EX_EndArray;
    }
}

```

`src/UETools.Objects/KismetVM/Instructions/ItemList/Ends/EndArrayConst.cs`:

```cs
namespace UETools.Objects.KismetVM.Instructions
{
    internal sealed class EndArrayConst : EndToken
    {
        public override EExprToken Expr => EExprToken.EX_EndArrayConst;
    }
}

```

`src/UETools.Objects/KismetVM/Instructions/ItemList/Ends/EndFunctionParms.cs`:

```cs
namespace UETools.Objects.KismetVM.Instructions
{
    internal sealed class EndFunctionParms : EndToken
    {
        public override EExprToken Expr => EExprToken.EX_EndFunctionParms;
    }
}

```

`src/UETools.Objects/KismetVM/Instructions/ItemList/Ends/EndMap.cs`:

```cs
namespace UETools.Objects.KismetVM.Instructions
{
    internal sealed class EndMap : EndToken
    {
        public override EExprToken Expr => EExprToken.EX_EndMap;
    }
}

```

`src/UETools.Objects/KismetVM/Instructions/ItemList/Ends/EndMapConst.cs`:

```cs
namespace UETools.Objects.KismetVM.Instructions
{
    internal sealed class EndMapConst : EndToken
    {
        public override EExprToken Expr => EExprToken.EX_EndMapConst;
    }
}

```

`src/UETools.Objects/KismetVM/Instructions/ItemList/Ends/EndParmValue.cs`:

```cs
namespace UETools.Objects.KismetVM.Instructions
{
    internal sealed class EndParmValue : EndToken
    {
        public override EExprToken Expr => EExprToken.EX_EndParmValue;
    }
}

```

`src/UETools.Objects/KismetVM/Instructions/ItemList/Ends/EndSet.cs`:

```cs
namespace UETools.Objects.KismetVM.Instructions
{
    internal sealed class EndSet : EndToken
    {
        public override EExprToken Expr => EExprToken.EX_EndSet;
    }
}

```

`src/UETools.Objects/KismetVM/Instructions/ItemList/Ends/EndSetConst.cs`:

```cs
namespace UETools.Objects.KismetVM.Instructions
{
    internal sealed class EndSetConst : EndToken
    {
        public override EExprToken Expr => EExprToken.EX_EndSetConst;
    }
}

```

`src/UETools.Objects/KismetVM/Instructions/ItemList/Ends/EndStructConst.cs`:

```cs
namespace UETools.Objects.KismetVM.Instructions
{
    internal sealed class EndStructConst : EndToken
    {
        public override EExprToken Expr => EExprToken.EX_EndStructConst;
    }
}

```

`src/UETools.Objects/KismetVM/Instructions/ItemList/Ends/EndToken.cs`:

```cs
using System.IO;
using UETools.Core;

namespace UETools.Objects.KismetVM.Instructions
{
    internal abstract class EndToken : Token
    {
        public override FArchive Serialize(FArchive archive) => base.Serialize(archive);

        public override void ReadTo(TextWriter writer) => writer.Write(']');
    }
}

```

`src/UETools.Objects/KismetVM/Instructions/ItemList/MapConst.cs`:

```cs
using System;
using System.IO;
using UETools.Core;
using UETools.Objects.Package;

namespace UETools.Objects.KismetVM.Instructions
{
    internal sealed class MapConst : CollectionToken
    {
        public override EExprToken Expr => EExprToken.EX_MapConst;

        public ObjectReference KeyProperty => _keyProperty;
        public ObjectReference ValueProperty => _valueProperty;
        public int Count => _count;
        public TokenList Items { get; } = new TokenList();

        public override FArchive Serialize(FArchive archive)
        {
            base.Serialize(archive)
                .Read(ref _keyProperty)
                .Read(ref _valueProperty)
                .Read(ref _count);
            Items.ReadUntil(archive, EExprToken.EX_EndMapConst);
            return archive;
        }

        public override void ReadTo(TextWriter writer)
        {
            throw new NotImplementedException();
        }

        private ObjectReference _keyProperty = null!;
        private ObjectReference _valueProperty = null!;
        private int _count;
    }
}

```

`src/UETools.Objects/KismetVM/Instructions/ItemList/SetArray.cs`:

```cs
using System;
using System.IO;
using UETools.Core;

namespace UETools.Objects.KismetVM.Instructions
{
    internal sealed class SetArray : CollectionToken
    {
        public override EExprToken Expr => EExprToken.EX_SetArray;

        public Token ArrayToken { get; private set; } = null!;
        public TokenList Items { get; } = new TokenList();

        public override FArchive Serialize(FArchive archive)
        {
            base.Serialize(archive);
            ArrayToken = Token.Read(archive);
            Items.ReadUntil(archive, EExprToken.EX_EndArray);
            return archive;
        }

        public override void ReadTo(TextWriter writer)
        {
            throw new NotImplementedException();
        }
    }
}

```

`src/UETools.Objects/KismetVM/Instructions/ItemList/SetConst.cs`:

```cs
using System;
using System.IO;
using UETools.Core;
using UETools.Objects.Package;

namespace UETools.Objects.KismetVM.Instructions
{
    internal sealed class SetConst : CollectionToken
    {
        public override EExprToken Expr => EExprToken.EX_SetConst;

        public ObjectReference InnerProp => _innerProp;
        public int Count => _count;
        public TokenList Items { get; } = new TokenList();

        public override FArchive Serialize(FArchive archive)
        {
            base.Serialize(archive)
                .Read(ref _innerProp)
                .Read(ref _count);
            Items.ReadUntil(archive, EExprToken.EX_EndSetConst);
            return archive;
        }

        public override void ReadTo(TextWriter writer)
        {
            throw new NotImplementedException();
        }

        private ObjectReference _innerProp = null!;
        private int _count;
    }
}

```

`src/UETools.Objects/KismetVM/Instructions/ItemList/SetMap.cs`:

```cs
using System;
using System.IO;
using UETools.Core;

namespace UETools.Objects.KismetVM.Instructions
{
    internal sealed class SetMap : CollectionToken
    {
        public override EExprToken Expr => EExprToken.EX_SetMap;

        public Token MapToken { get; private set; } = null!;
        public int Count => _count;
        public TokenList Items { get; } = new TokenList();

        public override FArchive Serialize(FArchive archive)
        {
            base.Serialize(archive);
            MapToken = Token.Read(archive);
            archive.Read(ref _count);
            Items.ReadUntil(archive, EExprToken.EX_EndMap);
            return archive;
        }

        public override void ReadTo(TextWriter writer)
        {
            throw new NotImplementedException();
        }

        private int _count;
    }
}

```

`src/UETools.Objects/KismetVM/Instructions/ItemList/SetSet.cs`:

```cs
using System;
using System.IO;
using UETools.Core;

namespace UETools.Objects.KismetVM.Instructions
{
    internal sealed class SetSet : CollectionToken
    {
        public override EExprToken Expr => EExprToken.EX_SetSet;

        public Token SetToken { get; private set; } = null!;
        public int Count => _count;
        public TokenList Items { get; } = new TokenList();

        public override FArchive Serialize(FArchive archive)
        {
            base.Serialize(archive);
            SetToken = Token.Read(archive);
            archive.Read(ref _count);
            Items.ReadUntil(archive, EExprToken.EX_EndSet);
            return archive;
        }

        public override void ReadTo(TextWriter writer)
        {
            throw new NotImplementedException();
        }

        private int _count;
    }
}

```

`src/UETools.Objects/KismetVM/Instructions/ItemList/StructConst.cs`:

```cs
using System;
using System.IO;
using UETools.Core;
using UETools.Objects.Package;

namespace UETools.Objects.KismetVM.Instructions
{
    internal sealed class StructConst : CollectionToken
    {
        public override EExprToken Expr => EExprToken.EX_StructConst;

        public ObjectReference InnerProp => _innerProp;
        public int SerializedSize => _serializedSize;
        public TokenList Items { get; } = new TokenList();

        public override FArchive Serialize(FArchive archive)
        {
            base.Serialize(archive)
                .Read(ref _innerProp)
                .Read(ref _serializedSize);
            Items.ReadUntil(archive, EExprToken.EX_EndStructConst);
            return archive;
        }

        public override void ReadTo(TextWriter writer) => throw new NotImplementedException();

        private ObjectReference _innerProp = null!;
        private int _serializedSize;
    }
}

```

`src/UETools.Objects/KismetVM/Instructions/Nothing.cs`:

```cs
using System.IO;
using UETools.Core;

namespace UETools.Objects.KismetVM.Instructions
{
    internal sealed class Nothing : Token
    {
        public override EExprToken Expr => EExprToken.EX_Nothing;

        public override FArchive Serialize(FArchive archive) => base.Serialize(archive);

        public override void ReadTo(TextWriter writer) => writer.Write("NOP");
    }
}

```

`src/UETools.Objects/KismetVM/Instructions/Self.cs`:

```cs
using System.IO;
using UETools.Core;

namespace UETools.Objects.KismetVM.Instructions
{
    internal sealed class Self : Token
    {
        public override EExprToken Expr => EExprToken.EX_Self;

        public override FArchive Serialize(FArchive archive) => base.Serialize(archive);

        public override void ReadTo(TextWriter writer) => writer.Write("this");
    }
}

```

`src/UETools.Objects/KismetVM/Instructions/Transform.cs`:

```cs
using UETools.Core;
using UETools.Core.Interfaces;
using UETools.Objects.Structures;

namespace UETools.Objects.KismetVM.Instructions
{
    internal struct Transform : IUnrealSerializable
    {
        public FArchive Serialize(FArchive archive)
            => archive.Read(ref _rot)
                      .Read(ref _trans)
                      .Read(ref _scale);

        Vector4 _rot;
        Vector _trans;
        Vector _scale;
    }
}

```

`src/UETools.Objects/KismetVM/Instructions/Variables/DefaultVariable.cs`:

```cs
namespace UETools.Objects.KismetVM.Instructions
{
    internal sealed class DefaultVariable : VariableToken
    {
        public override EExprToken Expr => EExprToken.EX_DefaultVariable;
    }
}

```

`src/UETools.Objects/KismetVM/Instructions/Variables/InstanceVariable.cs`:

```cs
namespace UETools.Objects.KismetVM.Instructions
{
    internal sealed class InstanceVariable : VariableToken
    {
        public override EExprToken Expr => EExprToken.EX_InstanceVariable;
    }
}

```

`src/UETools.Objects/KismetVM/Instructions/Variables/LocalOutVariable.cs`:

```cs
namespace UETools.Objects.KismetVM.Instructions
{
    internal sealed class LocalOutVariable : VariableToken
    {
        public override EExprToken Expr => EExprToken.EX_LocalOutVariable;
    }
}

```

`src/UETools.Objects/KismetVM/Instructions/Variables/LocalVariable.cs`:

```cs
namespace UETools.Objects.KismetVM.Instructions
{
    internal sealed class LocalVariable : VariableToken
    {
        public override EExprToken Expr => EExprToken.EX_LocalVariable;
    }
}

```

`src/UETools.Objects/KismetVM/Instructions/Variables/VariableToken.cs`:

```cs
using System.IO;
using UETools.Core;
using UETools.Objects.Package;

namespace UETools.Objects.KismetVM.Instructions
{
    internal abstract class VariableToken : Token
    {
        //public ResolvedObjectReference<TaggedObject> Variable { get => _variable; set => _variable = value; }
        public ObjectReference Variable => _variable;

        public override FArchive Serialize(FArchive archive)
            => base.Serialize(archive)
                   .Read(ref _variable);

        public override void ReadTo(TextWriter writer)
        {
            if (Variable?.Resource != null)
            {
                writer.Write("{0} {1} = ", GetType().Name, Variable.Resource.FullName);
            }
            //Variable.Value.Read(writer);
        }

        //private ResolvedObjectReference<TaggedObject> _variable;
        private ObjectReference _variable = null!;
    }
}

```

`src/UETools.Objects/KismetVM/Token.cs`:

```cs
using System.CodeDom.Compiler;
using System.IO;
using UETools.Core;
using UETools.Core.Interfaces;

namespace UETools.Objects.KismetVM
{
    public abstract class Token : IUnrealSerializable, IUnrealReadable
    {
        public abstract EExprToken Expr { get; }
        public long TokenOffset { get; private set; }

        public virtual FArchive Serialize(FArchive archive)
        {
            TokenOffset = archive.Tell();
            return archive;
        }

        protected static Token Read(FArchive reader) => TokenFactory.Read(reader);

        public abstract void ReadTo(TextWriter writer);

        public void ReadTo(IndentedTextWriter writer)
        {
            throw new System.NotImplementedException();
        }
    }
}

```

`src/UETools.Objects/KismetVM/TokenFactory.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Diagnostics;
using System.Linq;
using UETools.Core;
using UETools.TypeFactory;

namespace UETools.Objects.KismetVM
{
    public sealed class TokenFactory
    {
        public static Token Read(FArchive reader)
        {
            EExprToken currentToken = default;
            reader.ReadUnsafe(ref currentToken);
            if (EnumTypes.TryGetValue(currentToken, out var type))
            {
                var tok = type();
                tok.Serialize(reader);
                return tok;
            }
            throw new NotImplementedException($"Unknown opcode {currentToken}");
        }

        public static List<Type> Types { get; } = typeof(Token).Assembly.GetTypes()
            .Where(t => t.IsSealed && t.IsSubclassOf(typeof(Token)))
            .ToList();

        public static IReadOnlyDictionary<EExprToken, Func<Token>> EnumTypes { get; } = new ReadOnlyDictionary<EExprToken, Func<Token>>(
            Enum.GetValues(typeof(EExprToken))
                .Cast<EExprToken>()
                .ToDictionary(
                    t => t,
                    v => Factory.CreateInstanceFunction<Token>(Types.First(t => v.ToString().AsSpan().Slice(3).SequenceEqual(t.Name.AsSpan())))
                    )
                );
    }
}

```

`src/UETools.Objects/KismetVM/TokenList.cs`:

```cs
using System.Collections.Generic;
using UETools.Core;

namespace UETools.Objects.KismetVM
{
    public class TokenList
    {
        public List<Token> Items { get; } = new List<Token>();

        public void ReadUntil(FArchive reader, EExprToken token)
        {
            Token tok;
            do
            {
                tok = TokenFactory.Read(reader);
                Items.Add(tok);
            } while (tok.Expr != token);
        }

        public void ReadCount(FArchive reader, int count)
        {
            for (int i = 0; i < count; i++)
            {
                if (TokenFactory.Read(reader) is Token tok)
                {
                    Items.Add(tok);
                }
            }
        }
    }
}

```

`src/UETools.Objects/Package/ExportTable.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Linq;
using UETools.Core;
using UETools.Core.Interfaces;
using UETools.Objects.Enums;

namespace UETools.Objects.Package
{
    [UnrealTable(TableName)]
    public sealed class ExportTable : UnrealTable<ObjectExport>
    {
        internal const string TableName = "Exports";
        public ExportTable() : base() { }
        public ExportTable(int length) : base(length) { }

        public override FArchive Serialize(FArchive archive)
        {
            base.Serialize(archive);
            if (ItemCount.HasValue)
                archive.Read(ref _entries, ItemCount.Value);
            else
                archive.Read(ref _entries);

            return archive;
        }


        public ObjectExport? GetClass() => GetCDO()?.Class as ObjectExport;
        public IEnumerable<ObjectExport> GetStandalone() => Items.Where(ex => ex.ObjectFlags.HasFlag(EObjectFlags.RF_Standalone));
        public IEnumerable<ObjectExport> GetAssets() => Items.Where(ex => ex.IsAsset);
        public ObjectExport? GetCDO() => Items.FirstOrDefault(ex => ex.ObjectFlags.HasFlag(EObjectFlags.RF_ClassDefaultObject));
    }
}

```

`src/UETools.Objects/Package/Extensions.cs`:

```cs
using UETools.Core;

namespace UETools.Objects.Package
{
    public static class Extensions
    {
        /// <summary>
        /// Resolves <paramref name="index"/> to either import or export 
        /// </summary>
        /// <param name="reader"></param>
        /// <param name="index">Index of resource. Negative value notates imports, positive exports.</param>
        /// <returns>Resolved resource, or <see langword="null"/>.</returns>
        public static ObjectResource? ImpExp(this FArchive reader, PackageIndex index) => index.Resolve(reader);
    }
}

```

`src/UETools.Objects/Package/ImportTable.cs`:

```cs
using UETools.Core;
using UETools.Core.Interfaces;

namespace UETools.Objects.Package
{
    [UnrealTable(TableName)]
    public sealed class ImportTable : UnrealTable<ObjectImport>
    {
        internal const string TableName = "Imports";
        public ImportTable() : base() { }
        public ImportTable(int length) : base(length) { }

        public override FArchive Serialize(FArchive archive)
        {
            base.Serialize(archive);
            if (ItemCount.HasValue)
                archive.Read(ref _entries, ItemCount.Value);
            else
                archive.Read(ref _entries);

            return archive;
        }
    }
}

```

`src/UETools.Objects/Package/ObjectExport.cs`:

```cs
using System;
using System.IO;
using UETools.Core;
using UETools.Core.Enums;
using UETools.Core.Interfaces;
using UETools.Objects.Classes;
using UETools.Objects.Enums;

namespace UETools.Objects.Package
{
    public partial class ObjectExport : ObjectResource, IUnrealSerializable
    {
        public ObjectResource? DefaultObject { get; private set; }
        public ObjectResource? Class { get; private set; }
        public ObjectResource? Super { get; private set; }
        public bool IsDefaultObject { get; private set; }
        public bool IsArchetypeObject { get; private set; }
        public TaggedObject? Object => _deserialized;
        internal EObjectFlags ObjectFlags => _objectFlags;
        internal bool IsAsset => _bIsAsset;
        internal bool WasPrinted { get; set; }

        public FArchive Serialize(FArchive archive)
        {
            var version = archive.Version;

            archive.Read(ref _classIndex)
                   .Read(ref _superIndex);

            if (version >= UE4Version.VER_UE4_TemplateIndex_IN_COOKED_EXPORTS)
                archive.Read(ref _templateIndex);

            archive.Read(ref _outerIndex)
                   .Read(ref _objectName)
                   .ReadUnsafe(ref _objectFlags);
            IsDefaultObject = (_objectFlags & EObjectFlags.RF_Standalone) != 0 && (_objectFlags & EObjectFlags.RF_Public) != 0;
            IsArchetypeObject = (_objectFlags & EObjectFlags.RF_ArchetypeObject) != 0;

            if (version < UE4Version.VER_UE4_64BIT_EXPORTMAP_SERIALSIZES)
            {
                int size = 0, offset = 0;
                archive.Read(ref size)
                       .Read(ref offset);
                _serialSize = size;
                _serialOffset = offset;
            }
            else
            {
                archive.Read(ref _serialSize)
                       .Read(ref _serialOffset);
            }

            archive.Read(ref _bForcedExport)
                   .Read(ref _bNotForClient)
                   .Read(ref _bNotForServer)
                   .Read(ref _packageGuid)
                   .ReadUnsafe(ref _packageFlags);

            if (version >= UE4Version.VER_UE4_LOAD_FOR_EDITOR_GAME)
                archive.Read(ref _bNotAlwaysLoadedForEditorGame);

            if (version >= UE4Version.VER_UE4_COOKED_ASSETS_IN_EDITOR_SUPPORT)
                archive.Read(ref _bIsAsset);

            if (version >= UE4Version.VER_UE4_PRELOAD_DEPENDENCIES_IN_COOKED_EXPORTS)
            {
                archive.Read(ref _firstExportDependency)
                       .Read(ref _serializationBeforeSerializationDependencies)
                       .Read(ref _createBeforeSerializationDependencies)
                       .Read(ref _serializationBeforeCreateDependencies)
                       .Read(ref _createBeforeCreateDependencies);
            }

            return archive;
        }

        public override void Fix(FArchive reader)
        {
            Class = reader.ImpExp(_classIndex);
            if (Class is null)
                _fullNameBuilder.Append("<Unknown Class>");
            else
                _fullNameBuilder.Append(GetClassName());

            _fullNameBuilder.Append(" ");
            Outer = reader.ImpExp(_outerIndex);
            GetOuter(Outer, reader);
            _fullNameBuilder.Append(_objectName);

            Super = reader.ImpExp(_superIndex);
            DefaultObject = reader.ImpExp(_templateIndex);

             _deserialized = Read(reader);
        }
        public override TaggedObject? Read(FArchive? reader)
        {
            if (_deserialized is null && reader is { })
            {
                _deserialized = TaggedObject.Create(reader.Slice(_serialOffset), GetClassName());
            }

            return _deserialized;
        }
        public override string GetClassName() => Class is null ? string.Empty : Class.ObjectName.Name.Value;

        private PackageIndex _classIndex;
        private PackageIndex _superIndex;
        private PackageIndex _templateIndex;
        private EObjectFlags _objectFlags;
        private long _serialSize;
        private long _serialOffset;
        private bool _bForcedExport;
        private bool _bNotForClient;
        private bool _bNotForServer;
        private Guid _packageGuid;
        private EPackageFlags _packageFlags;
        private bool _bNotAlwaysLoadedForEditorGame;
        private bool _bIsAsset;
        private int _firstExportDependency;
        private int _serializationBeforeSerializationDependencies;
        private int _createBeforeSerializationDependencies;
        private int _serializationBeforeCreateDependencies;
        private int _createBeforeCreateDependencies;

        private TaggedObject? _deserialized;
    }
}

```

`src/UETools.Objects/Package/ObjectImport.cs`:

```cs
using UETools.Core;
using UETools.Core.Interfaces;
using UETools.Objects.Classes;

namespace UETools.Objects.Package
{
    public sealed class ObjectImport : ObjectResource, IUnrealSerializable
    {
        public FArchive Serialize(FArchive archive)
            => archive.Read(ref _classPackage)
                      .Read(ref _className)
                      .Read(ref _outerIndex)
                      .Read(ref _objectName);

        public override void Fix(FArchive reader)
        {
            _fullNameBuilder.Append(_className);
            _fullNameBuilder.Append(" ");
            Outer = _outerIndex.Resolve(reader);
            GetOuter(Outer, reader);
            _fullNameBuilder.Append(ObjectName);
        }
        public override TaggedObject? Read(FArchive? reader) => null;
        public override string GetClassName() => _className;


        private FName _classPackage = null!;
        private FName _className = null!;
    }
}
```

`src/UETools.Objects/Package/ObjectReference.cs`:

```cs
using System.Diagnostics;
using UETools.Core;
using UETools.Core.Interfaces;

namespace UETools.Objects.Package
{
    [DebuggerDisplay("{Resource?.FullName}")]
    public class ObjectReference : IUnrealSerializable
    {
        public ObjectResource? Resource { get; private set; }

        public virtual FArchive Serialize(FArchive archive)
        {
            archive.Read(ref _objectIndex);
            Resource = _objectIndex.Resolve(archive);
            return archive;
        }

        public override string ToString() => Resource is null ? "null" : Resource.FullName;

        private PackageIndex _objectIndex;
    }
}

```

`src/UETools.Objects/Package/ObjectResource.cs`:

```cs
using System.Diagnostics;
using System.Text;
using UETools.Core;
using UETools.Objects.Classes;

namespace UETools.Objects.Package
{
    [DebuggerDisplay("{FullName}")]
    public abstract class ObjectResource
    {
        public ObjectResource? Outer { get; protected set; }
        public FName ObjectName { get => _objectName; set => _objectName = value; }
        public string FullName => _fullNameBuilder.ToString();

        protected void GetOuter(ObjectResource? res, FArchive asset)
        {
            if (res is null)
                return;

            GetOuter(asset.ImpExp(res._outerIndex), asset);
            _fullNameBuilder.Append(res._objectName).Append(".");
        }

        public ObjectResource GetOutermost(FArchive asset) => asset.ImpExp(_outerIndex)?.GetOutermost(asset) ?? this;

        public abstract void Fix(FArchive reader);
        public abstract TaggedObject? Read(FArchive? reader);
        public abstract string GetClassName();

        protected PackageIndex _outerIndex;
        protected FName _objectName = null!;
        protected StringBuilder _fullNameBuilder = new StringBuilder(256);
    }
}

```

`src/UETools.Objects/Package/PackageIndex.cs`:

```cs
using System;
using UETools.Core;
using UETools.Core.Interfaces;

namespace UETools.Objects.Package
{
    public struct PackageIndex : IUnrealSerializable, IEquatable<PackageIndex>, IEquatable<int>
    {
        public FArchive Serialize(FArchive archive) => archive.Read(ref _value);

        internal ObjectResource? Resolve(FArchive reader)
        {
            if (_value > 0)
                return Export(reader, _value);
            else if (_value < 0)
                return Import(reader, _value);

            return null;
        }
        private static ObjectExport? Export(FArchive reader, int index)
        {
            if (reader.GetTable<ObjectExport>(ExportTable.TableName) is ExportTable Exports)
            {
                var i = index - 1;
                if (i < Exports.Items.Count)
                    return Exports.Items[i];
            }
            return null;
        }
        private static ObjectImport? Import(FArchive reader, int index)
        {
            if (reader.GetTable<ObjectImport>(ImportTable.TableName) is ImportTable Imports)
            {
                var i = -index - 1;
                if (i < Imports.Items.Count)
                    return Imports.Items[i];
            }
            return null;
        }

        public override bool Equals(object? obj) => obj switch
        {
            PackageIndex val => Equals(val),
            int val => Equals(val),
            _ => false
        };
        public bool Equals(int other) => other == _value;
        public bool Equals(PackageIndex other) => other.Equals(_value);

        public override int GetHashCode() => HashCode.Combine(_value);
        public static bool operator ==(PackageIndex left, PackageIndex right) => left.Equals(right);
        public static bool operator !=(PackageIndex left, PackageIndex right) => !(left == right);

        private int _value;
    }
}

```

`src/UETools.Objects/Package/ResolvedObjectReference.cs`:

```cs
using System.Diagnostics;
using UETools.Core;
using UETools.Objects.Classes;

namespace UETools.Objects.Package
{
    [DebuggerDisplay("Ref: {Value}")]
    public sealed class ResolvedObjectReference<T> : ObjectReference where T : TaggedObject
    {
        public T? Value => Resource?.Read(null) as T;
    }
}

```

`src/UETools.Objects/Property/ArrayProperty.cs`:

```cs
#if NETSTANDARD2_0
using CoreExtensions;
#endif
using System;
using System.CodeDom.Compiler;
using System.Collections;
using System.Collections.Generic;
using System.Diagnostics;
using System.IO;
using System.Linq;
using System.Text;
using UETools.Core;
using UETools.Core.Interfaces;
using UETools.Objects.Interfaces;
using UETools.TypeFactory;

namespace UETools.Objects.Property
{
    internal sealed class ArrayProperty : PropertyCollectionBase<IList>
    {
        public override FArchive Serialize(FArchive reader, PropertyTag tag)
        {
            base.Serialize(reader, tag);
            var info = tag;
            if (tag.InnerTypeEnum == PropertyTag.PropertyType.StructProperty)
                reader.Read(ref info);

            if ((tag.InnerTypeEnum == PropertyTag.PropertyType.ByteProperty && tag.EnumName is null) || tag.InnerTypeEnum == PropertyTag.PropertyType.BoolProperty)
            {
                byte[]? bytes = default;
                reader.Read(ref bytes, Count);
                _value = bytes.ToArray();
            }
            else
            {
                if (tag.InnerTypeEnum.TryGetAttribute(out LinkedTypeAttribute? attrib))
                {
                    var array = new List<IProperty>(Count);
                    var func = PropertyFactory.Get(attrib.LinkedType);
                    for (var i = 0; i < Count; i++)
                    {
                        var prop = func();
                        prop.Serialize(reader, info);
                        array.Add(prop);
                    }
                    _value = array;
                }
            }
            return reader;
        }

        public override void ReadTo(IndentedTextWriter writer)
        {
            if (_value is byte[] bytes)
                writer.WriteLine(new StringBuilder().Append("[ ").AppendJoin(", ", bytes).Append(" ]"));
            else
                base.ReadTo(writer);
        }
    }
}
```

`src/UETools.Objects/Property/BoolProperty.cs`:

```cs
using UETools.Core;
using UETools.Objects.Interfaces;

namespace UETools.Objects.Property
{
    internal sealed class BoolProperty : UProperty<bool>
    {
        public override FArchive Serialize(FArchive reader, PropertyTag tag)
        {
            _value = tag.BoolValue;
            return reader;
        }
    }
}

```

`src/UETools.Objects/Property/ByteProperty.cs`:

```cs
using UETools.Core;
using UETools.Objects.Interfaces;

namespace UETools.Objects.Property
{
    internal sealed class ByteProperty : UProperty<object>
    {
        public override FArchive Serialize(FArchive reader, PropertyTag tag)
        {
            if (tag.EnumName!.IsNone())
            {
                byte underlying = 0;
                reader.Read(ref underlying);
                _value = underlying;
            }
            else
            {
                FName? name = default;
                reader.Read(ref name);
                _value = name;
            }
            return reader;
        }
    }
}

```

`src/UETools.Objects/Property/ClassProperty.cs`:

```cs
using UETools.Core;
using UETools.Objects.Interfaces;
using UETools.Objects.Package;

namespace UETools.Objects.Property
{
    internal sealed class ClassProperty : UProperty<ObjectReference>
    {
        public override FArchive Serialize(FArchive reader, PropertyTag tag) => reader.Read(ref _value);
    }
}
```

`src/UETools.Objects/Property/DelegateProperty.cs`:

```cs
using System.Diagnostics;
using UETools.Core;
using UETools.Objects.Enums;
using UETools.Objects.Interfaces;
using UETools.Objects.Package;

namespace UETools.Objects.Property
{
    internal sealed class DelegateProperty : UProperty<FName>
    {
        public override FArchive Serialize(FArchive reader, PropertyTag tag)
        {
            ObjectReference? declaredIn = default;
            reader.Read(ref declaredIn);
            if (tag.Size > 4)
                reader.Read(ref _value);
            else 
                Debugger.Break();
            return reader;
        }
    }
}
```

`src/UETools.Objects/Property/DoubleProperty.cs`:

```cs
using UETools.Core;
using UETools.Objects.Interfaces;

namespace UETools.Objects.Property
{
    internal sealed class DoubleProperty : UProperty<double>
    {
        public override FArchive Serialize(FArchive reader, PropertyTag tag) => reader.Read(ref _value);
    }
}
```

`src/UETools.Objects/Property/EnumProperty.cs`:

```cs
using UETools.Core;
using UETools.Objects.Interfaces;

namespace UETools.Objects.Property
{
    internal sealed class EnumProperty : UProperty<FName>
    {
        public override FArchive Serialize(FArchive reader, PropertyTag tag) => reader.Read(ref _value);
    }
}

```

`src/UETools.Objects/Property/FieldPathProperty.cs`:

```cs
using UETools.Core;
using UETools.Objects.Interfaces;

namespace UETools.Objects.Property
{
    internal sealed class FieldPathProperty : UProperty<FieldPath>
    {
        public override FArchive Serialize(FArchive reader, PropertyTag tag) => reader.Read(ref _value);
    }
}
```

`src/UETools.Objects/Property/FloatProperty.cs`:

```cs
using UETools.Core;
using UETools.Objects.Interfaces;

namespace UETools.Objects.Property
{
    internal sealed class FloatProperty : UProperty<float>
    {
        public override FArchive Serialize(FArchive reader, PropertyTag tag) => reader.Read(ref _value);
    }
}
```

`src/UETools.Objects/Property/Int16Property.cs`:

```cs
using UETools.Core;
using UETools.Objects.Interfaces;

namespace UETools.Objects.Property
{
    internal sealed class Int16Property : UProperty<short>
    {
        public override FArchive Serialize(FArchive reader, PropertyTag tag) => reader.Read(ref _value);
    }
}
```

`src/UETools.Objects/Property/Int64Property.cs`:

```cs
using UETools.Core;
using UETools.Objects.Interfaces;

namespace UETools.Objects.Property
{
    internal sealed class Int64Property : UProperty<long>
    {
        public override FArchive Serialize(FArchive reader, PropertyTag tag) => reader.Read(ref _value);
    }
}
```

`src/UETools.Objects/Property/Int8Property.cs`:

```cs
using UETools.Core;
using UETools.Objects.Interfaces;

namespace UETools.Objects.Property
{
    internal sealed class Int8Property : UProperty<sbyte>
    {
        public override FArchive Serialize(FArchive reader, PropertyTag tag) => reader.Read(ref _value);
    }
}
```

`src/UETools.Objects/Property/IntProperty.cs`:

```cs
using UETools.Core;
using UETools.Objects.Interfaces;

namespace UETools.Objects.Property
{
    internal sealed class IntProperty : UProperty<int>
    {
        public override FArchive Serialize(FArchive reader, PropertyTag tag) => reader.Read(ref _value);
    }
}
```

`src/UETools.Objects/Property/InterfaceProperty.cs`:

```cs
using UETools.Core;
using UETools.Objects.Interfaces;
using UETools.Objects.Package;

namespace UETools.Objects.Property
{
    internal sealed class InterfaceProperty : UProperty<ObjectReference>
    {
        public override FArchive Serialize(FArchive reader, PropertyTag tag) => reader.Read(ref _value);
    }
}
```

`src/UETools.Objects/Property/LazyObjectProperty.cs`:

```cs
using UETools.Core;
using UETools.Objects.Interfaces;

namespace UETools.Objects.Property
{
    internal sealed class LazyObjectProperty : UProperty<int>
    {
        public override FArchive Serialize(FArchive reader, PropertyTag tag) => reader.Read(ref _value);
    }
}

```

`src/UETools.Objects/Property/MapProperty.cs`:

```cs
using System;
using System.CodeDom.Compiler;
using System.Collections;
using System.Collections.Generic;
using System.Diagnostics;
using System.IO;
using System.Linq;
using System.Text;
using UETools.Core;
using UETools.Core.Interfaces;
using UETools.Objects.Interfaces;
using UETools.TypeFactory;

namespace UETools.Objects.Property
{
    internal sealed class MapProperty : PropertyCollectionBase<Dictionary<IProperty, IProperty>>
    {
        public override FArchive Serialize(FArchive reader, PropertyTag tag)
        {
            if (tag.InnerTypeEnum.TryGetAttribute(out LinkedTypeAttribute? innerType) && tag.ValueTypeEnum.TryGetAttribute(out LinkedTypeAttribute? valueType))
            {
                int unknown = 0;
                reader.Read(ref unknown);
                base.Serialize(reader, tag);
                var dict = new Dictionary<IProperty, IProperty>(Count);
                var funcKey = PropertyFactory.Get(innerType.LinkedType);
                var valueKey = PropertyFactory.Get(valueType.LinkedType);
                for(int i = 0; i < Count; i++)
                {
                    var key = funcKey();
                    key.Serialize(reader, tag);
                    var value = valueKey();
                    value.Serialize(reader, tag);
                    dict.Add(key, value);
                }
                _value = dict;
            }
            return reader;
        }

        protected override void WriteInnerItems(IndentedTextWriter writer)
        {
            var it = _value.GetEnumerator();
            for (var i = 0; it.MoveNext(); i++)
            {
                var obj = it.Current;
                writer.Write("[ ");
                ReadObject(writer, obj.Key);
                writer.WriteLine(" => ");
                ReadObject(writer, obj.Value);
                writer.Write("]");
                if (i != Count - 1)
                    writer.WriteLine(", ");
            }
        }
    }
}
```

`src/UETools.Objects/Property/MulticastDelegateProperty.cs`:

```cs
using UETools.Core;
using UETools.Objects.Enums;
using UETools.Objects.Interfaces;
using UETools.Objects.Package;

namespace UETools.Objects.Property
{
    internal sealed class MulticastDelegateProperty : UProperty<FName>
    {
        public override FArchive Serialize(FArchive reader, PropertyTag tag)
        {
            ObjectReference? declaredIn = default;
            reader.Read(ref declaredIn);
            if (declaredIn.Resource != null)
            {
                EFunctionFlags flags = default;
                reader.ReadUnsafe(ref flags);
                reader.Read(ref _value);
            }
            return reader;
        }
    }
}
```

`src/UETools.Objects/Property/MulticastInlineDelegateProperty.cs`:

```cs
using UETools.Core;
using UETools.Objects.Enums;
using UETools.Objects.Interfaces;
using UETools.Objects.Package;

namespace UETools.Objects.Property
{
    internal sealed class MulticastInlineDelegateProperty : UProperty<FName>
    {
        public override FArchive Serialize(FArchive reader, PropertyTag tag)
        {
            ObjectReference? declaredIn = default;
            EFunctionFlags flags = default;
            return reader.Read(ref declaredIn)
                         .ReadUnsafe(ref flags)
                         .Read(ref _value);
        }
    }
}
```

`src/UETools.Objects/Property/MulticastSparseDelegateProperty.cs`:

```cs
using UETools.Core;
using UETools.Objects.Enums;
using UETools.Objects.Interfaces;
using UETools.Objects.Package;

namespace UETools.Objects.Property
{
    internal sealed class MulticastSparseDelegateProperty : UProperty<FName>
    {
        public override FArchive Serialize(FArchive reader, PropertyTag tag)
        {
            ObjectReference? declaredIn = default;
            EFunctionFlags flags = default;
            return reader.Read(ref declaredIn)
                         .ReadUnsafe(ref flags)
                         .Read(ref _value);
        }
    }
}
```

`src/UETools.Objects/Property/NameProperty.cs`:

```cs
using UETools.Core;
using UETools.Objects.Interfaces;

namespace UETools.Objects.Property
{
    internal sealed class NameProperty : UProperty<FName>
    {
        public override FArchive Serialize(FArchive reader, PropertyTag tag) => reader.Read(ref _value);
    }
}

```

`src/UETools.Objects/Property/ObjectProperty.cs`:

```cs
using System.CodeDom.Compiler;
using UETools.Core;
using UETools.Objects.Classes;
using UETools.Objects.Interfaces;
using UETools.Objects.Package;

namespace UETools.Objects.Property
{
    internal sealed class ObjectProperty : UProperty<ObjectReference>
    {
        public override FArchive Serialize(FArchive reader, PropertyTag tag) => reader.Read(ref _value);

        public override void ReadTo(IndentedTextWriter writer)
        {
            if(_value is null)
                NotDeserializedException.Throw();

            if(_value.Resource is ObjectExport exp && !exp.WasPrinted && (exp.IsDefaultObject || exp.IsArchetypeObject))
            {
                exp.WasPrinted = true;
                writer.Indent++;
                ReadObject(writer, exp.Read(null));
                writer.Indent--;
            }
            else 
                writer.WriteLine(_value.ToString());
        }
    }
}
```

`src/UETools.Objects/Property/PropertyCollectionBase.cs`:

```cs
using System;
using System.CodeDom.Compiler;
using System.Collections;
using System.Collections.Generic;
using System.Text;
using UETools.Core;
using UETools.Core.Interfaces;
using UETools.Objects.Interfaces;

namespace UETools.Objects.Property
{
    abstract class PropertyCollectionBase<T> : UProperty<T> where T : notnull, IEnumerable
    {
        public int Count => _count;

        public override FArchive Serialize(FArchive reader, PropertyTag tag) => reader.Read(ref _count);
        protected virtual void WriteInnerItems(IndentedTextWriter writer)
        {
            var it = _value.GetEnumerator();
            for (var i = 0; it.MoveNext(); i++)
            {
                ReadObject(writer, it.Current);

                if (i != _count - 1)
                    writer.WriteLine(", ");
            }
        }
        public override void ReadTo(IndentedTextWriter writer)
        {
            if (_count == 0)
            {
                writer.WriteLine("[ ]");
                return;
            }

            writer.WriteLine('[');
            writer.Indent++;
            WriteInnerItems(writer);
            writer.Indent--;
            writer.WriteLine(']');
        }

        private int _count;
    }
}

```

`src/UETools.Objects/Property/SetProperty.cs`:

```cs
using System.CodeDom.Compiler;
using System.Collections;
using System.Collections.Generic;
using System.Diagnostics;
using System.IO;
using System.Text;
using UETools.Core;
using UETools.Core.Interfaces;
using UETools.Objects.Interfaces;
using UETools.TypeFactory;

namespace UETools.Objects.Property
{
    internal sealed class SetProperty : PropertyCollectionBase<HashSet<IProperty>>
    {
        public override FArchive Serialize(FArchive reader, PropertyTag tag)
        {
            int unknown = 0;
            reader.Read(ref unknown);
            base.Serialize(reader, tag);
            if (tag.InnerTypeEnum.TryGetAttribute(out LinkedTypeAttribute? attrib))
            {
                _value = new HashSet<IProperty>();
                var func = PropertyFactory.Get(attrib.LinkedType);
                for (int i = 0; i < Count; i++)
                {
                    var prop = func();
                    prop.Serialize(reader, tag);
                    _value.Add(prop);
                }
            }
            return reader;
        }
    }
}
```

`src/UETools.Objects/Property/SoftClassProperty.cs`:

```cs
using UETools.Core;
using UETools.Objects.Interfaces;
using UETools.Objects.Structures;

namespace UETools.Objects.Property
{
    internal sealed class SoftClassProperty : UProperty<SoftClassPath>
    {
        public override FArchive Serialize(FArchive reader, PropertyTag tag) => reader.Read(ref _value);
    }
}
```

`src/UETools.Objects/Property/SoftObjectProperty.cs`:

```cs
using UETools.Core;
using UETools.Objects.Interfaces;
using UETools.Objects.Structures;

namespace UETools.Objects.Property
{
    internal sealed class SoftObjectProperty : UProperty<SoftObjectPath>
    {
        public override FArchive Serialize(FArchive reader, PropertyTag tag) => reader.Read(ref _value);
    }
}
```

`src/UETools.Objects/Property/StrProperty.cs`:

```cs
using UETools.Core;
using UETools.Objects.Interfaces;

namespace UETools.Objects.Property
{
    internal sealed class StrProperty : UProperty<FString>
    {
        public override FArchive Serialize(FArchive reader, PropertyTag tag) => reader.Read(ref _value);
    }
}
```

`src/UETools.Objects/Property/StructProperty.cs`:

```cs
using System;
using System.CodeDom.Compiler;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Diagnostics;
using System.IO;
using System.Reflection;
using UETools.Core;
using UETools.Core.Interfaces;
using UETools.Objects.Classes;
using UETools.Objects.Interfaces;
using UETools.Objects.Structures;
using UETools.TypeFactory;

namespace UETools.Objects.Property
{
    internal sealed class StructProperty : UProperty<object>
    {
        private static IReadOnlyDictionary<string, Func<IUnrealStruct>> Structures { get; } = new ReadOnlyDictionary<string, Func<IUnrealStruct>>(new TypeCollector<IUnrealStruct>(Path.GetDirectoryName(Assembly.GetCallingAssembly().Location)!).ToFactory().factories);

        private string? _unsuccessfulStruct;
        public override FArchive Serialize(FArchive reader, PropertyTag tag)
        {
            var structType = tag.StructName?.ToString();
            if (structType != null && Structures.TryGetValue(structType, out var factory))
            {
                var val = factory();
                val.Serialize(reader);
                _value = val;
            }
            else if (tag.Size <= 8)
            {
                byte[]? bytes = default;
                reader.Read(ref bytes, tag.Size);
                _unsuccessfulStruct = $"{structType}: {BitConverter.ToString(bytes)}";
            }
            else
            {
                var obj = new TaggedObject();
                try
                {
                    _value = obj;
                    obj.Serialize(reader);

                }
                catch
                {
                    _unsuccessfulStruct = $"{{ {structType} needs native deserialization }}";
                    Debug.WriteLine(_unsuccessfulStruct);
                }
            }
            return reader;
        }

        public override void ReadTo(IndentedTextWriter writer)
        {
            if(_unsuccessfulStruct != null)
            {
                writer.WriteLine(_unsuccessfulStruct);
            }
            else
            {
                switch(_value)
                {
                    case IUnrealReadable indent:
                        indent.ReadTo(writer);
                        break;
                    default:
                        writer.WriteLine(_value);
                        break;
                }
            }
        }
    }
}
```

`src/UETools.Objects/Property/TextProperty.cs`:

```cs
using UETools.Core;
using UETools.Objects.Interfaces;

namespace UETools.Objects.Property
{
    internal sealed class TextProperty : UProperty<FText>
    {
        public override FArchive Serialize(FArchive reader, PropertyTag tag) => reader.Read(ref _value);
    }
}
```

`src/UETools.Objects/Property/UInt16Property.cs`:

```cs
using UETools.Core;
using UETools.Objects.Interfaces;

namespace UETools.Objects.Property
{
    internal sealed class UInt16Property : UProperty<ushort>
    {
        public override FArchive Serialize(FArchive reader, PropertyTag tag) => reader.Read(ref _value);
    }
}

```

`src/UETools.Objects/Property/UInt32Property.cs`:

```cs
using UETools.Core;
using UETools.Objects.Interfaces;

namespace UETools.Objects.Property
{
    internal sealed class UInt32Property : UProperty<uint>
    {
        public override FArchive Serialize(FArchive reader, PropertyTag tag) => reader.Read(ref _value);
    }
}

```

`src/UETools.Objects/Property/UInt64Property.cs`:

```cs
using UETools.Core;
using UETools.Objects.Interfaces;

namespace UETools.Objects.Property
{
    internal sealed class UInt64Property : UProperty<ulong>
    {
        public override FArchive Serialize(FArchive reader, PropertyTag tag) => reader.Read(ref _value);
    }
}

```

`src/UETools.Objects/Property/UProperty.cs`:

```cs
using System.CodeDom.Compiler;
using System.Diagnostics;
using UETools.Core;
using UETools.Core.Interfaces;
using UETools.Objects.Interfaces;

namespace UETools.Objects.Property
{
    [DebuggerDisplay("{_value}", Type = "Property")]
    abstract class UProperty<T> : IProperty, IUnrealReadable where T : notnull
    {
        object IProperty.Value { get => _value; set => _value = (T)value; }

        public abstract FArchive Serialize(FArchive reader, PropertyTag tag);

        public virtual void ReadTo(IndentedTextWriter writer) => ReadObject(writer, _value);

        protected static void ReadObject<TValue>(IndentedTextWriter writer, TValue obj)
        {
            switch (obj)
            {
                case IUnrealReadable indent:
                    indent.ReadTo(writer);
                    break;
                default:
                    writer.WriteLine(obj);
                    break;
            }
        }

        protected T _value = default!;
    }
}

```

`src/UETools.Objects/PropertyFactory.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Diagnostics.CodeAnalysis;
using System.IO;
using System.Reflection;
using UETools.Core;
using UETools.Objects.Interfaces;
using UETools.TypeFactory;

namespace UETools.Objects
{
    public static class PropertyFactory
    {
        private static TypeCollector<IProperty> TypeCollector = new TypeCollector<IProperty>(Path.GetDirectoryName(Assembly.GetCallingAssembly().Location)!, true);
        private static TypeFactory<IProperty> TypeFactory = TypeCollector.ToFactory();
        
        public static IProperty Get(FArchive reader, PropertyTag tag)
        {
            var factory = TypeFactory.factories;
            var it = factory[tag.Type.ToString()]();
            it.Serialize(reader, tag);
            return it;
        }

        internal static Func<IProperty> Get(Type type)
        {
            if (TypeFactory.factories.TryGetValue(type.Name, out var func))
                return func;
            else
                return Factory.CreateInstanceFunction<IProperty>(type);
        }
    }
}

```

`src/UETools.Objects/PropertyTag.EPropertyType.cs`:

```cs
using UETools.Core;
using UETools.Objects.Property;

namespace UETools.Objects
{
    public partial class PropertyTag
    {
        public enum PropertyType : byte
        {
            None = 0,
            [LinkedType(typeof(ByteProperty))]
            ByteProperty = 1,
            [LinkedType(typeof(Int8Property))]
            Int8Property = 2,
            [LinkedType(typeof(Int16Property))]
            Int16Property = 3,
            [LinkedType(typeof(UInt16Property))]
            UInt16Property = 4,
            [LinkedType(typeof(IntProperty))]
            IntProperty = 5,
            [LinkedType(typeof(UInt32Property))]
            UInt32Property = 6,
            [LinkedType(typeof(Int64Property))]
            Int64Property = 7,
            [LinkedType(typeof(UInt64Property))]
            UInt64Property = 8,
            [LinkedType(typeof(FloatProperty))]
            FloatProperty = 9,
            [LinkedType(typeof(BoolProperty))]
            BoolProperty = 10,

            [LinkedType(typeof(NameProperty))]
            NameProperty = 11,
            [LinkedType(typeof(EnumProperty))]
            EnumProperty = 12,
            [LinkedType(typeof(StrProperty))]
            StrProperty = 13,
            [LinkedType(typeof(TextProperty))]
            TextProperty = 14,

            [LinkedType(typeof(InterfaceProperty))]
            InterfaceProperty = 15,
            [LinkedType(typeof(ObjectProperty))]
            ObjectProperty = 16,
            [LinkedType(typeof(StructProperty))]
            StructProperty = 17,

            [LinkedType(typeof(ArrayProperty))]
            ArrayProperty = 18,
            [LinkedType(typeof(SetProperty))]
            SetProperty = 19,
            [LinkedType(typeof(MapProperty))]
            MapProperty = 20,

            [LinkedType(typeof(SoftObjectProperty))]
            SoftObjectProperty = 21,
            [LinkedType(typeof(SoftClassProperty))]
            SoftClassProperty = 22,

            [LinkedType(typeof(DelegateProperty))]
            DelegateProperty = 23,
            [LinkedType(typeof(MulticastDelegateProperty))]
            MulticastDelegateProperty = 24,
            [LinkedType(typeof(MulticastInlineDelegateProperty))]
            MulticastInlineDelegateProperty = 25,
            [LinkedType(typeof(MulticastSparseDelegateProperty))]
            MulticastSparseDelegateProperty = 26,

            [LinkedType(typeof(FieldPathProperty))]
            FieldPathProperty = 27,
        }
    }
}

```

`src/UETools.Objects/PropertyTag.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Diagnostics.CodeAnalysis;
using UETools.Core;
using UETools.Core.Enums;
using UETools.Core.Interfaces;

namespace UETools.Objects
{
    [DebuggerDisplay("{TypeEnum} {Name}")]
    public partial class PropertyTag : IUnrealSerializable
    {
        public FName Name { get => _name; set => _name = value; }
        public FName Type { get => _type; set => _type = value; }

        public int Size { get => _size; set => _size = value; }
        public int ArrayIndex { get => _arrayIndex; set => _arrayIndex = value; }

        public bool BoolValue { get => _boolVal != 0; set => _boolVal = (byte)(value ? 1 : 0); }
        public FName? StructName { get => _structName; set => _structName = value; }
        public FName? EnumName { get => _enumName; set => _enumName = value; }
        public FName? InnerType { get => _innerType; set => _innerType = value; }
        public FName? ValueType { get => _valueType; set => _valueType = value; }

        public PropertyType TypeEnum => _typeEnum;
        public PropertyType InnerTypeEnum => _innerTypeEnum;
        public PropertyType ValueTypeEnum => _valueTypeEnum;

        public long PropertyEnd { get; private set; }

        public FArchive Serialize(FArchive archive)
        {
            var version = archive.Version;
            archive.Read(ref _name);
            if (Name.IsNone())
                return archive;

            archive.Read(ref _type);

            var foundType = Enum.TryParse(Type, out _typeEnum);
            Debug.WriteLineIf(!foundType, $"Unimplemented property type: {_type}");

            archive.Read(ref _size)
                   .Read(ref _arrayIndex);

            switch (TypeEnum)
            {
                case PropertyType.StructProperty:
                    archive.Read(ref _structName);
                    if (version >= UE4Version.VER_UE4_STRUCT_GUID_IN_PROPERTY_TAG)
                    {
                        archive.Read(ref _structGuid);
                    }
                    break;
                case PropertyType.BoolProperty:
                    archive.Read(ref _boolVal);
                    break;
                case PropertyType.ByteProperty:
                case PropertyType.EnumProperty:
                    archive.Read(ref _enumName);
                    break;
                case PropertyType.ArrayProperty when version >= UE4Version.VAR_UE4_ARRAY_PROPERTY_INNER_TAGS:
                case PropertyType.SetProperty when version >= UE4Version.VER_UE4_PROPERTY_TAG_SET_MAP_SUPPORT:
                    archive.Read(ref _innerType);
                    break;
                case PropertyType.MapProperty when version >= UE4Version.VER_UE4_PROPERTY_TAG_SET_MAP_SUPPORT:
                    archive.Read(ref _innerType)
                           .Read(ref _valueType);
                    break;
            }

            if (version >= UE4Version.VER_UE4_PROPERTY_GUID_IN_PROPERTY_TAG)
            {
                archive.Read(ref _hasPropertyGuid);
                if (_hasPropertyGuid != 0)
                {
                    archive.Read(ref _propertyGuid);
                }
            }

            PropertyEnd = archive.Tell() + Size;

            if (_innerType is null)
                return archive;
            var foundInner = Enum.TryParse(_innerType, out _innerTypeEnum);
            Debug.WriteLineIf(!foundInner, $"Unimplemented inner type: {_innerType}");
            if (_valueType is null)
                return archive;
            var foundValue = Enum.TryParse(_valueType, out _valueTypeEnum);
            Debug.WriteLineIf(!foundValue, $"Unimplemented value type: {_valueType}");

            return archive;
        }

        public static IEnumerable<PropertyTag> ReadToEnd(FArchive reader)
        {
            while (true)
            {
                PropertyTag? tag = default;
                reader.Read(ref tag);
                if (tag.Name.IsNone())
                    break;

                yield return tag;
            }
        }

        private FName _name = null!;
        private FName _type = null!;
        private byte _boolVal;
        private FName? _structName;
        private FName? _enumName;
        private FName? _innerType;
        private FName? _valueType;
        private int _size;
        private int _arrayIndex;
        private Guid _structGuid;
        private byte _hasPropertyGuid;
        private Guid _propertyGuid;

        private PropertyType _typeEnum;
        private PropertyType _innerTypeEnum;
        private PropertyType _valueTypeEnum;
    }
}

```

`src/UETools.Objects/README.md`:

```md
# UETools.Objects

Implements deserialization of UE4 object system.
```

`src/UETools.Objects/Structures/Box.cs`:

```cs
using UETools.Core;
using UETools.Objects.Interfaces;

namespace UETools.Objects.Structures
{
    public struct Box : IUnrealStruct
    {
        public bool IsValid => _isValid != 0;
        public Vector Min => _min;
        public Vector Max => _max;


        public FArchive Serialize(FArchive archive)
            => archive.Read(ref _min)
                      .Read(ref _max)
                      .Read(ref _isValid);

        public override string ToString() => IsValid ? $"{{ Min: {_min}, Max: {_max} }}" : $"{{ Invalid {nameof(Box)} }}";

        private Vector _min;
        private Vector _max;
        private byte _isValid;
    }
}

```

`src/UETools.Objects/Structures/Box2D.cs`:

```cs
using UETools.Core;
using UETools.Objects.Interfaces;

namespace UETools.Objects.Structures
{
    public struct Box2D : IUnrealStruct
    {
        private bool IsValid => _isValid != 0;

        public FArchive Serialize(FArchive archive)
            => archive.Read(ref _min)
                      .Read(ref _max)
                      .Read(ref _isValid);

        public override string ToString() => IsValid ? $"{{ Min: {_min}, Max: {_max} }}" : $"{{ Invalid {nameof(Box2D)} }}";

        private Vector2D _min;
        private Vector2D _max;
        private byte _isValid;
    }
}

```

`src/UETools.Objects/Structures/ClothLODData.cs`:

```cs
using System.Collections.Generic;
using System.Text;
using UETools.Core;
using UETools.Objects.Classes;
using UETools.Objects.Interfaces;

namespace UETools.Objects.Structures
{
    class ClothLODDataCommon : ClothLODData 
    { 
    }
    class ClothLODData : TaggedObject, IUnrealStruct
    {
        public override FArchive Serialize(FArchive archive)
            => base.Serialize(archive)
                   .Read(ref _transitionUpSkinData)
                   .Read(ref _transitionDownSkinData);

        private List<MeshToMeshVertData> _transitionUpSkinData = null!;
        private List<MeshToMeshVertData> _transitionDownSkinData = null!;
    }
}

```

`src/UETools.Objects/Structures/Color.cs`:

```cs
using System.Runtime.InteropServices;
using UETools.Core;
using UETools.Objects.Interfaces;

namespace UETools.Objects.Structures
{
    public struct Color : IUnrealStruct
    {
        public FArchive Serialize(FArchive archive)
            => archive.Read(ref _b)
                      .Read(ref _g)
                      .Read(ref _r)
                      .Read(ref _a);
        public override string ToString() => $"{{ R: {_r}, G: {_g}, B: {_b}, A: {_a} }}";

        private byte _b;
        private byte _g;
        private byte _r;
        private byte _a;
    }
}

```

`src/UETools.Objects/Structures/ColorMaterialInput.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Text;

namespace UETools.Objects.Structures
{
    class ColorMaterialInput : MaterialInputType<Color>
    {
    }
}

```

`src/UETools.Objects/Structures/DateTime.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Text;
using UETools.Core;
using UETools.Objects.Interfaces;

namespace UETools.Objects.Structures
{
    struct DateTime : IUnrealStruct
    {
        public FArchive Serialize(FArchive archive)
        {
            long ticks = _value.Ticks;
            archive.Read(ref ticks);
            _value = new System.DateTime(ticks);
            return archive;
        }

        public override string ToString() => _value.ToString();

        System.DateTime _value;

    }
}

```

`src/UETools.Objects/Structures/ExpressionInput.cs`:

```cs
using UETools.Core;

namespace UETools.Objects.Structures
{
    class ExpressionInput : MaterialInput
    {
        public override FArchive Serialize(FArchive archive) => base.Serialize(archive.Read(ref _outputIndex));

        private int _outputIndex;
    }
}

```

`src/UETools.Objects/Structures/FieldPath.cs`:

```cs
using System.Collections.Generic;
using UETools.Core;
using UETools.Objects.Interfaces;
using UETools.Objects.Package;

namespace UETools.Objects.Property
{
    internal struct FieldPath : IUnrealStruct
    {
        public FArchive Serialize(FArchive archive)
            => archive.Read(ref _path)
                      .Read(ref _reference);


        List<FName> _path; 
        ObjectReference _reference;
    }
}
```

`src/UETools.Objects/Structures/FontCharacter.cs`:

```cs
using UETools.Core;
using UETools.Objects.Interfaces;

namespace UETools.Objects.Structures
{
    public struct FontCharacter : IUnrealStruct
    {
        public FArchive Serialize(FArchive archive)
            => archive.Read(ref _startU)
                      .Read(ref _startV)
                      .Read(ref _uSize)
                      .Read(ref _vSize)
                      .Read(ref _textureIndex)
                      .Read(ref _verticalOffset);

        public override string? ToString()
        {
            return base.ToString();
        }

        private int _startU;
        private int _startV;
        private int _uSize;
        private int _vSize;
        private byte _textureIndex;
        private int _verticalOffset;
    }
}

```

`src/UETools.Objects/Structures/FontData.cs`:

```cs
using System.Diagnostics;
using UETools.Core;
using UETools.Objects.Enums;
using UETools.Objects.Interfaces;
using UETools.Objects.Package;

namespace UETools.Objects.Structures
{
    public struct FontData : IUnrealStruct
    {
        public FArchive Serialize(FArchive archive)
        {
            archive.Read(ref _bIsCooked);
            if (_bIsCooked)
            {
                archive.Read(ref _fontFaceAsset);

                if(_fontFaceAsset.Resource is null)
                {
                    archive.Read(ref _fontFileName)
                           .ReadUnsafe(ref _hinting)
                           .ReadUnsafe(ref _loadingPolicy);
                }

                archive.Read(ref _subFaceIndex);
            }

            Debug.WriteLineIf(!_bIsCooked, "FontData is not cooked.");

            return archive;
        }

        private bool _bIsCooked;
        private FString _fontFileName;
        private EFontHinting _hinting;
        private EFontLoadingPolicy _loadingPolicy;
        private ObjectReference _fontFaceAsset;
        private int _subFaceIndex;
    }
}

```

`src/UETools.Objects/Structures/FrameNumber.cs`:

```cs
using UETools.Core;
using UETools.Objects.Interfaces;

namespace UETools.Objects.Structures
{
    public struct FrameNumber : IUnrealStruct
    {
        public FArchive Serialize(FArchive archive) => archive.Read(ref _value);

        int _value;
    }
}

```

`src/UETools.Objects/Structures/GameplayTagContainer.cs`:

```cs
#if NETSTANDARD2_0
using CoreExtensions;
#endif
using System.Collections.Generic;
using System.Linq;
using System.Text;
using UETools.Core;
using UETools.Objects.Interfaces;

namespace UETools.Objects.Structures
{
    struct GameplayTagContainer : IUnrealStruct
    {
        public FArchive Serialize(FArchive archive) => archive.Read(ref _tags);

        public override string ToString() => new StringBuilder()
            .Append("{ ")
            .AppendJoin(", ", _tags.AsEnumerable())
            .Append(" }")
            .ToString();

        List<FName> _tags;
    }
}

```

`src/UETools.Objects/Structures/Guid.cs`:

```cs
using System.Diagnostics.CodeAnalysis;
using UETools.Core;
using UETools.Objects.Interfaces;

namespace UETools.Objects.Structures
{
    public struct Guid : IUnrealStruct, System.IEquatable<Guid>, System.IEquatable<System.Guid>
    {
        public FArchive Serialize(FArchive archive) => archive.Read(ref _guid);

        public override string ToString() => _guid.ToString();

        public bool Equals(Guid other) => other._guid == _guid;

        public bool Equals([AllowNull] System.Guid other) => _guid == other;

        private System.Guid _guid;
    }
}

```

`src/UETools.Objects/Structures/IntPoint.cs`:

```cs
using System;
using UETools.Core;
using UETools.Objects.Interfaces;

namespace UETools.Objects.Structures
{
    public struct IntPoint : IUnrealStruct, IEquatable<IntPoint>
    {
        public FArchive Serialize(FArchive archive)
            => archive.Read(ref _x)
                      .Read(ref _y);

        public override string ToString() => $"{{ X: {_x}, Y: {_y} }}";
        public override bool Equals(object? obj) => obj switch
        {
            IntPoint vec => Equals(vec),
            _ => false
        };
        public bool Equals(IntPoint other) => other._x == _x && other._y == _y;
        public override int GetHashCode() => HashCode.Combine(_x, _y);
        public static bool operator ==(IntPoint left, IntPoint right) => left.Equals(right);
        public static bool operator !=(IntPoint left, IntPoint right) => !(left == right);

        private int _x;
        private int _y;
    }
}

```

`src/UETools.Objects/Structures/IntVector.cs`:

```cs
using System;
using UETools.Core;
using UETools.Objects.Interfaces;

namespace UETools.Objects.Structures
{
    public struct IntVector : IUnrealStruct, IEquatable<IntVector>
    {
        public FArchive Serialize(FArchive archive)
            => archive.Read(ref _x)
                      .Read(ref _y)
                      .Read(ref _z);

        public override string ToString() => $"{{ X: {_x}, Y: {_y}, Z: {_z} }}";
        public override bool Equals(object? obj) => obj switch
        {
            IntVector vec => Equals(vec),
            _ => false
        };
        public bool Equals(IntVector other) => other._x == _x && other._y == _y && other._z == _z;
        public override int GetHashCode() => HashCode.Combine(_x, _y, _z);
        public static bool operator ==(IntVector left, IntVector right) => left.Equals(right);
        public static bool operator !=(IntVector left, IntVector right) => !(left == right);

        private int _x;
        private int _y;
        private int _z;
    }
}

```

`src/UETools.Objects/Structures/LevelSequenceBindingReferences.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Text;
using UETools.Core;
using UETools.Objects.Classes;
using UETools.Objects.Interfaces;

namespace UETools.Objects.Structures
{
    class LevelSequenceBindingReferences : IUnrealStruct
    {
        public FArchive Serialize(FArchive archive)
        {
            foreach (var tag in PropertyTag.ReadToEnd(archive))
            {
                // TODO: Implement overriding processing?
                if (tag.Name.ToString() == "BindingIdToReferences")
                {
                    int x = 0;
                    archive.Read(ref x);
                    archive.Read(ref BindingIdToReferences);
                }
            }
            return archive;
        }

        Dictionary<Guid, TaggedObject>? BindingIdToReferences;
    }
}

```

`src/UETools.Objects/Structures/LevelSequenceObjectReferenceMap.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Text;
using UETools.Core;
using UETools.Objects.Interfaces;

namespace UETools.Objects.Structures
{
    class LevelSequenceObjectReferenceMap : IUnrealStruct
    {
        struct LevelSequenceLegacyObjectReference : IUnrealStruct
        {
            public FArchive Serialize(FArchive archive)
                => archive.Read(ref _objectId)
                          .Read(ref _objectPath);

            Guid _objectId;
            FString _objectPath;
        }
        public FArchive Serialize(FArchive archive) => archive.Read(ref _map);

        Dictionary<Guid, LevelSequenceLegacyObjectReference>? _map;
    }
}

```

`src/UETools.Objects/Structures/LinearColor.cs`:

```cs
using UETools.Core;
using UETools.Objects.Interfaces;

namespace UETools.Objects.Structures
{
    public struct LinearColor : IUnrealStruct
    {
        public FArchive Serialize(FArchive archive)
            => archive.Read(ref _b)
                      .Read(ref _g)
                      .Read(ref _r)
                      .Read(ref _a);
        public override string ToString() => $"{{ R: {_r}, G: {_g}, B: {_b}, A: {_a} }}";

        private float _b;
        private float _g;
        private float _r;
        private float _a;
    }
}

```

`src/UETools.Objects/Structures/MaterialAttributesInput.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Text;
using UETools.Core;
using UETools.Objects.Interfaces;

namespace UETools.Objects.Structures
{
    sealed class MaterialAttributesInput : ExpressionInput, IUnrealStruct
    {
    }
}

```

`src/UETools.Objects/Structures/MaterialInput.cs`:

```cs
using UETools.Core;
using UETools.Objects.Interfaces;

namespace UETools.Objects.Structures
{
    class MaterialInput : IUnrealStruct
    {
        public virtual FArchive Serialize(FArchive archive)
            => archive.Read(ref _inputName)
                      .Read(ref _mask)
                      .Read(ref _maskR)
                      .Read(ref _maskG)
                      .Read(ref _maskB)
                      .Read(ref _maskA)
                      .Read(ref _expressionName);

        public override string ToString() => $"{_expressionName}: {_inputName}";

        private FName _inputName = null!;
        private int _mask;
        private int _maskR;
        private int _maskG;
        private int _maskB;
        private int _maskA;
        private FName _expressionName = null!;
    }
}
```

`src/UETools.Objects/Structures/MaterialInputType.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Text;
using UETools.Core;
using UETools.Core.Interfaces;

namespace UETools.Objects.Structures
{
    class MaterialInputType<T> : ExpressionInput where T : unmanaged
    {
        public override FArchive Serialize(FArchive archive)
            => base.Serialize(archive)
                   .Read(ref _useConst)
                   .ReadUnsafe(ref _const);

        public override string ToString() => (_useConst ? _const.ToString() : base.ToString())!;

        private bool _useConst;
        private T _const;
    }
}

```

`src/UETools.Objects/Structures/Matrix.cs`:

```cs
using UETools.Core;
using UETools.Objects.Interfaces;

namespace UETools.Objects.Structures
{
    public struct Matrix : IUnrealStruct
    {
        public FArchive Serialize(FArchive archive)
            => archive.Read(ref _x)
                      .Read(ref _y)
                      .Read(ref _z)
                      .Read(ref _w);
        public override string ToString() => $"{{ X: {_x}, Y: {_y}, Z: {_z}, W: {_w} }}";

        private Plane _x;
        private Plane _y;
        private Plane _z;
        private Plane _w;
    }
}

```

`src/UETools.Objects/Structures/MeshToMeshVertData.cs`:

```cs
using System;
using System.Collections.Generic;
using UETools.Core;
using UETools.Objects.Interfaces;

namespace UETools.Objects.Structures
{
    struct MeshToMeshVertData : IUnrealStruct
    {
        public FArchive Serialize(FArchive archive)
            => archive.Read(ref _positionBaryCordsAndDist)
                      .Read(ref _normalBaryCordsAndDist)
                      .Read(ref _tangentBaryCordsAndDist)
                      .Read(ref _sourceMeshVertIndices, 4)
                      .Read(ref _padding, 2);

        Vector4 _positionBaryCordsAndDist;
        Vector4 _normalBaryCordsAndDist;
        Vector4 _tangentBaryCordsAndDist;
        List<ushort> _sourceMeshVertIndices;
        List<uint> _padding;
    }
}

```

`src/UETools.Objects/Structures/MovieSceneFrameRange.cs`:

```cs
using UETools.Core;
using UETools.Core.Collections;
using UETools.Objects.Interfaces;

namespace UETools.Objects.Structures
{
    public struct MovieSceneFrameRange : IUnrealStruct
    {
        public FArchive Serialize(FArchive archive) => archive.Read(ref _range);

        private TRange<FrameNumber> _range;
    } 
}

```

`src/UETools.Objects/Structures/PerPlatformProperty.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Text;
using UETools.Core;
using UETools.Objects.Interfaces;

namespace UETools.Objects.Structures
{
    // TODO: Consider IProperty being IUnrealSerializable with FArchive wrapper
    abstract class PerPlatformProperty<T> : IUnrealStruct where T : struct
    {
        public virtual FArchive Serialize(FArchive archive) => archive.Read(ref _isCooked);

        public override string ToString() => _value.ToString()!;


        bool _isCooked;
        protected T _value;
    }
    sealed class PerPlatformInt : PerPlatformProperty<int>
    {
        public override FArchive Serialize(FArchive archive) => base.Serialize(archive).Read(ref _value);
    }
    sealed class FreezablePerPlatformInt : PerPlatformProperty<int>
    {
        public override FArchive Serialize(FArchive archive) => base.Serialize(archive).Read(ref _value);
    }
    sealed class PerPlatformFloat : PerPlatformProperty<float>
    {
        public override FArchive Serialize(FArchive archive) => base.Serialize(archive).Read(ref _value);
    }
    sealed class FFreezablePerPlatformFloat : PerPlatformProperty<float>
    {
        public override FArchive Serialize(FArchive archive) => base.Serialize(archive).Read(ref _value);
    }
    sealed class PerPlatformBool : PerPlatformProperty<bool>
    {
        public override FArchive Serialize(FArchive archive) => base.Serialize(archive).Read(ref _value);
    }
}

```

`src/UETools.Objects/Structures/Plane.cs`:

```cs
using UETools.Core;
using UETools.Objects.Interfaces;

namespace UETools.Objects.Structures
{
    public struct Plane : IUnrealStruct
    {
        public FArchive Serialize(FArchive archive)
            => archive.Read(ref _x)
                      .Read(ref _y)
                      .Read(ref _z)
                      .Read(ref _w);

        public override string ToString() => $"{{ X: {_x}, Y: {_y}, Z: {_z}, W: {_w} }}";

        private float _x;
        private float _y;
        private float _z;
        private float _w;
    }
}

```

`src/UETools.Objects/Structures/PointerToUberGraphFrame.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Text;
using UETools.Core;
using UETools.Objects.Interfaces;

namespace UETools.Objects.Structures
{
    struct PointerToUberGraphFrame : IUnrealStruct
    {
        public FArchive Serialize(FArchive archive) => archive.Read(ref _name);

        public override string ToString() => _name.ToString();
        private FName _name;
    }
}

```

`src/UETools.Objects/Structures/Quat.cs`:

```cs
using UETools.Core;
using UETools.Objects.Interfaces;

namespace UETools.Objects.Structures
{
    public struct Quat : IUnrealStruct
    {
        public FArchive Serialize(FArchive archive)
            => archive.Read(ref _x)
                      .Read(ref _y)
                      .Read(ref _z)
                      .Read(ref _w);
        public override string ToString() => $"{{ X: {_x}, Y: {_y}, Z: {_z}, W: {_w} }}";

        private float _x;
        private float _y;
        private float _z;
        private float _w;
    }
}

```

`src/UETools.Objects/Structures/RichCurveKey.cs`:

```cs
using UETools.Core;
using UETools.Objects.Interfaces;

namespace UETools.Objects.Structures
{
    partial struct RichCurveKey : IUnrealStruct
    {
        public FArchive Serialize(FArchive archive)
            => archive.ReadUnsafe(ref _interpMode)
                      .ReadUnsafe(ref _tangentMode)
                      .ReadUnsafe(ref _tangentWeightMode)
                      .Read(ref _time)
                      .Read(ref _value)
                      .Read(ref _arriveTangent)
                      .Read(ref _arriveTangentWeight)
                      .Read(ref _leaveTangent)
                      .Read(ref _leaveTangentWeight);

        public override string ToString() => $"{{ Time: {_time}, Value: {_value}, InterpMode: {_interpMode} }}";

        private InterpMode _interpMode;
        private TangentMode _tangentMode;
        private TangentWeightMode _tangentWeightMode;
        private float _time;
        private float _value;
        private float _arriveTangent;
        private float _arriveTangentWeight;
        private float _leaveTangent;
        private float _leaveTangentWeight;
    }
}

```

`src/UETools.Objects/Structures/Rotator.cs`:

```cs
using System;
using UETools.Core;
using UETools.Objects.Interfaces;

namespace UETools.Objects.Structures
{
    public struct Rotator : IUnrealStruct, IEquatable<Rotator>
    {
        public FArchive Serialize(FArchive archive)
            => archive.Read(ref _pitch)
                      .Read(ref _roll)
                      .Read(ref _yaw);
        public override string ToString() => $"{{ Pitch: {_pitch}, Roll: {_roll}, Yaw: {_yaw} }}";

        public override bool Equals(object? obj) => obj switch
        {
            Rotator rot => Equals(rot),
            _ => false
        };
        public bool Equals(Rotator other) => other._pitch == _pitch && other._yaw == _yaw && other._roll == _roll;
        public override int GetHashCode() => HashCode.Combine(_pitch, _roll, _yaw);
        public static bool operator ==(Rotator left, Rotator right) => left.Equals(right);
        public static bool operator !=(Rotator left, Rotator right) => !(left == right);

        private float _pitch;
        private float _roll;
        private float _yaw;
    }
}

```

`src/UETools.Objects/Structures/ScalarMaterialInput.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Text;
using UETools.Core;

namespace UETools.Objects.Structures
{
    sealed class ScalarMaterialInput : MaterialInputType<float>
    {
    }
}

```

`src/UETools.Objects/Structures/SkeletalMeshSamplingLODBuiltData.cs`:

```cs
using System;
using System.Collections.Generic;
using UETools.Core;
using UETools.Core.Interfaces;
using UETools.Objects.Classes;
using UETools.Objects.Interfaces;

namespace UETools.Objects.Structures
{
    struct SkeletalMeshSamplingLODBuiltData : IUnrealStruct
    {
        private class WeighterRandomSampler : IUnrealSerializable
        {
            public FArchive Serialize(FArchive archive)
                => archive.Read(ref _prob)
                          .Read(ref _alias)
                          .Read(ref _totalWeight);

            List<float> _prob = null!;
            List<int> _alias = null!;
            float _totalWeight;
        }
        private class SkeletalMeshAreaWeightedTriangleSampler : WeighterRandomSampler
        {

        }

        public FArchive Serialize(FArchive archive) => archive.Read(ref _skeletalMeshArea);

        private SkeletalMeshAreaWeightedTriangleSampler _skeletalMeshArea;
    }
}

```

`src/UETools.Objects/Structures/SmartName.cs`:

```cs
using UETools.Core;
using UETools.Objects.Interfaces;

namespace UETools.Objects.Structures
{
    public struct SmartName : IUnrealStruct
    {
        public FArchive Serialize(FArchive archive)
        {
            archive.Read(ref _value);
            if (!archive.EOF())
                archive.Read(ref _uid);
            if (!archive.EOF())
                archive.Read(ref _guid);

            return archive;
        }
        public override string ToString() => _value.ToString();

        private FName _value;
        private short _uid;
        private System.Guid _guid;
    }
}

```

`src/UETools.Objects/Structures/SoftClassPath.cs`:

```cs
using UETools.Core;
using UETools.Core.Enums;
using UETools.Objects.Interfaces;

namespace UETools.Objects.Structures
{
    struct SoftClassPath : IUnrealStruct
    {
        public FArchive Serialize(FArchive archive)
        {
            if (archive.Version < UE4Version.VER_UE4_ADDED_SOFT_OBJECT_PATH)
            {
                archive.Read(ref _path);
                _value = _path;

                // TODO: Convert path to FName value

                //if (Ar.UE4Ver() < VER_UE4_KEEP_ONLY_PACKAGE_NAMES_IN_STRING_ASSET_REFERENCES_MAP)
                //{
                //    Path = FPackageName::GetNormalizedObjectPath(Path);
                //}

                //SetPath(MoveTemp(Path));
            }
            else
            {
                archive.Read(ref _value)
                       .Read(ref _subPathString);
            }
            return archive;
        }

        public override string ToString() => _value.ToString();

        FString _path;
        FString _subPathString;
        FName _value;
    }
}

```

`src/UETools.Objects/Structures/SoftObjectPath.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Text;
using UETools.Core;
using UETools.Core.Enums;
using UETools.Objects.Interfaces;

namespace UETools.Objects.Structures
{
    struct SoftObjectPath : IUnrealStruct
    {
        public FArchive Serialize(FArchive archive)
        {
            if (archive.Version < UE4Version.VER_UE4_ADDED_SOFT_OBJECT_PATH)
            {
                archive.Read(ref _path);
                _value = _path;

                // TODO: Convert path to FName value

                //if (Ar.UE4Ver() < VER_UE4_KEEP_ONLY_PACKAGE_NAMES_IN_STRING_ASSET_REFERENCES_MAP)
                //{
                //    Path = FPackageName::GetNormalizedObjectPath(Path);
                //}

                //SetPath(MoveTemp(Path));
            }
            else
            {
                archive.Read(ref _value)
                       .Read(ref _subPathString);
            }
            return archive;
        }
        public override string ToString() => _value.ToString();

        FString _path;
        FString _subPathString;
        FName _value;
    }
}

```

`src/UETools.Objects/Structures/TwoVectors.cs`:

```cs
using System;
using UETools.Core;
using UETools.Objects.Interfaces;

namespace UETools.Objects.Structures
{
    public struct TwoVectors : IUnrealStruct, IEquatable<TwoVectors>
    {
        public FArchive Serialize(FArchive archive)
            => archive.Read(ref _v1)
                      .Read(ref _v2);

        public override string ToString() => $"{{ V1: {_v1}, V2: {_v2} }}";
        public override bool Equals(object? obj) => obj switch
        {
            TwoVectors vec => Equals(vec),
            _ => false
        };
        public bool Equals(TwoVectors other) => other._v1 == _v1 && other._v2 == _v2;
        public override int GetHashCode() => HashCode.Combine(_v1, _v2);
        public static bool operator ==(TwoVectors left, TwoVectors right) => left.Equals(right);
        public static bool operator !=(TwoVectors left, TwoVectors right) => !(left == right);

        private Vector _v1;
        private Vector _v2;
    }
}

```

`src/UETools.Objects/Structures/Vector.cs`:

```cs
using System;
using System.Runtime.InteropServices;
using UETools.Core;
using UETools.Objects.Interfaces;

namespace UETools.Objects.Structures
{
    [StructLayout(LayoutKind.Explicit)]
    public struct Vector : IUnrealStruct, IEquatable<Vector>
    {
        public FArchive Serialize(FArchive archive)
            => archive.Read(ref _x)
                      .Read(ref _y)
                      .Read(ref _z);
        
        public override string ToString() => $"{{ X: {_x}, Y: {_y}, Z: {_z} }}";
        public override bool Equals(object? obj) => obj switch
        {
            Vector vec => Equals(vec),
            _ => false
        };
        public bool Equals(Vector other) => other._x == _x && other._y == _y && other._z == _z;
        public override int GetHashCode() => HashCode.Combine(_x, _y, _z);
        public static bool operator ==(Vector left, Vector right) => left.Equals(right);
        public static bool operator !=(Vector left, Vector right) => !(left == right);

        [FieldOffset(0)]
        private float _x;
        [FieldOffset(4)]
        private float _y;
        [FieldOffset(8)]
        private float _z;
    }
}

```

`src/UETools.Objects/Structures/Vector2D.cs`:

```cs
using System;
using System.Runtime.InteropServices;
using UETools.Core;
using UETools.Objects.Interfaces;

namespace UETools.Objects.Structures
{
    [StructLayout(LayoutKind.Explicit)]
    public struct Vector2D : IUnrealStruct, IEquatable<Vector2D>
    {
        public FArchive Serialize(FArchive archive)
            => archive.Read(ref _x)
                      .Read(ref _y);

        public override string ToString() => $"{{ X: {_x}, Y: {_y} }}";
        public override bool Equals(object? obj) => obj switch
        {
            Vector2D vec => Equals(vec),
            _ => false
        };
        public bool Equals(Vector2D other) => other._x == _x && other._y == _y;
        public override int GetHashCode() => HashCode.Combine(_x, _y);
        public static bool operator ==(Vector2D left, Vector2D right) => left.Equals(right);
        public static bool operator !=(Vector2D left, Vector2D right) => !(left == right);

        [FieldOffset(0)]
        private float _x;
        [FieldOffset(4)]
        private float _y;
    }
}

```

`src/UETools.Objects/Structures/Vector2MaterialInput.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Text;

namespace UETools.Objects.Structures
{
    class Vector2MaterialInput : MaterialInputType<Vector2D>
    {
    }
}

```

`src/UETools.Objects/Structures/Vector4.cs`:

```cs
using UETools.Core;
using UETools.Objects.Interfaces;

namespace UETools.Objects.Structures
{
    public struct Vector4 : IUnrealStruct
    {
        public FArchive Serialize(FArchive archive)
            => archive.Read(ref _x)
                      .Read(ref _y)
                      .Read(ref _z)
                      .Read(ref _w);
        public override string ToString() => $"{{ X: {_x}, Y: {_y}, Z: {_z}, W: {_w} }}";

        private float _x;
        private float _y;
        private float _z;
        private float _w;
    }
}

```

`src/UETools.Objects/Structures/VectorMaterialInput.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Text;

namespace UETools.Objects.Structures
{
    class VectorMaterialInput : MaterialInputType<Vector>
    {
    }
}

```

`src/UETools.Objects/UETools.Objects.csproj`:

```csproj
<Project Sdk="Microsoft.NET.Sdk">

  <PropertyGroup>
    <TargetFrameworks>netstandard2.0;netstandard2.1;net5.0</TargetFrameworks>
    <Nullable>enable</Nullable>
    <PackageDescription>Implementation of serializers Unreal Engine 4 object model, encoded data, Blueprint code, etc.</PackageDescription>
  </PropertyGroup>

  <ItemGroup>
    <ProjectReference Include="..\UETools.Core\UETools.Core.csproj" />
  </ItemGroup>
  
  <ItemGroup Condition="'$(TargetFramework)' == 'netstandard2.0'">
    <!-- StringBuilder AppendJoin methods -->
    <PackageReference Include="CoreExtensions.StringBuilder" Version="1.0.0" />
  </ItemGroup>

</Project>

```

`src/UETools.Pak/AesPakCryptoProvider.cs`:

```cs
using System;
using System.Buffers;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Runtime.InteropServices;
using System.Security.Cryptography;
using System.Text;
using UETools.Pak.Interfaces;

namespace UETools.Pak
{
    internal sealed class AesPakCryptoProvider : IDisposable
    {
        private ICryptoTransform _decryptor;
        private ICryptoTransform _encryptor;
        public AesPakCryptoProvider(IAesKeyProvider keyProvider)
        {
            if (keyProvider is null) 
                throw new ArgumentNullException(nameof(keyProvider));

            using var _aesProvider = new AesCryptoServiceProvider();
            _aesProvider.IV = new byte[16];
            _aesProvider.Mode = CipherMode.ECB;
            _aesProvider.Padding = PaddingMode.Zeros;
            _aesProvider.Key = Convert.FromBase64String(keyProvider.DecryptionKey);
            _decryptor = _aesProvider.CreateDecryptor();
            _encryptor = _aesProvider.CreateEncryptor();
        }

        public void Decrypt(Memory<byte> buffer)
        {
            if (MemoryMarshal.TryGetArray<byte>(buffer, out var segment))
            {
                Decrypt(segment.Array!, segment.Offset, segment.Count);
            }
            else
            {
                var pool = ArrayPool<byte>.Shared.Rent(buffer.Length);
                buffer.CopyTo(pool);
                Decrypt(pool, 0, buffer.Length);
                pool.CopyTo(buffer);
                ArrayPool<byte>.Shared.Return(pool);
            }
        }
        public void Decrypt(byte[] array, int offset, int count)
        {
            // Aes implementation doesn't need TransformFinalBlock, where it actually allocates array to return
            var blockSize = _decryptor.InputBlockSize;
            while (count > 0)
            {
                var read = _decryptor.TransformBlock(array, offset, Math.Min(blockSize, count), array, offset);
                count -= read;
                offset += read;
            }
        }
        public void Encrypt(Memory<byte> buffer)
        {
            if (MemoryMarshal.TryGetArray<byte>(buffer, out var segment))
            {
                Encrypt(segment.Array!, segment.Offset, segment.Count);
            }
            else
            {
                var pool = ArrayPool<byte>.Shared.Rent(buffer.Length);
                buffer.CopyTo(pool);
                Encrypt(pool, 0, buffer.Length);
                pool.CopyTo(buffer);
                ArrayPool<byte>.Shared.Return(pool);
            }
        }
        public void Encrypt(byte[] array, int offset, int count)
        {
            // Aes implementation doesn't need TransformFinalBlock, where it actually allocates array to return
            var blockSize = _encryptor.OutputBlockSize;
            while (count > 0)
            {
                var read = _encryptor.TransformBlock(array, offset, Math.Min(blockSize, count), array, offset);
                count -= read;
                offset += read;
            }
        }

        public void Dispose()
        {
            _decryptor.Dispose();
            _encryptor.Dispose();
        }
    }
}

```

`src/UETools.Pak/CompressedBlocksExtension.cs`:

```cs
using System;
using System.Collections.Generic;

namespace UETools.Pak
{
    static class CompressedBlocksExtension
    {
        public static void OffsetBy(this List<PakCompressedBlock> blocks, int offset)
        {
            if (blocks is null)
                throw new ArgumentNullException(nameof(blocks));

            for (var i = 0; i < blocks.Count; i++)
                blocks[i] = blocks[i].OffsetBy(offset);
        }
    }
}

```

`src/UETools.Pak/DirectoryReader.cs`:

```cs
namespace UETools.Pak
{
    class DirectoryReader
    {
    }
}

```

`src/UETools.Pak/Enums/ECompressionFlags.cs`:

```cs
using System;

namespace UETools.Pak.Enums
{
    /// <summary>
    /// Flags controlling compression and decompression.
    /// </summary>
    [Flags]
    internal enum ECompressionFlags : int
    {
        /// <summary>
        /// No compression.
        /// </summary>
        COMPRESS_None = 0x00,
        /// <summary>
        /// Compress with ZLIB.
        /// </summary>
        COMPRESS_ZLIB = 0x01,
        /// <summary>
        /// Compress with GZIP.
        /// </summary>
        COMPRESS_GZIP = 0x02,
        /// <summary>
        /// Compress with user defined callbacks.
        /// </summary>
        COMPRESS_Custom = 0x04,
        /// <summary>
        /// Prefer compression that compresses smaller.
        /// </summary>
        /// <remarks>Only valid for compression.</remarks>
        COMPRESS_BiasMemory = 0x10,
        /// <summary>
        /// Prefer compression that compresses faster.
        /// </summary>
        /// <remarks>Only valid for compression.</remarks>
        COMPRESS_BiasSpeed = 0x20,
    };
}
```

`src/UETools.Pak/Enums/EPakEntryFlags.cs`:

```cs
namespace UETools.Pak.Enums
{
    enum EPakEntryFlags : byte
    {
        None = 0,
        Encrypted = 1,
        Deleted = 2
    }
}

```

`src/UETools.Pak/Enums/PakInfoSize.cs`:

```cs
namespace UETools.Pak.Enums
{
    internal enum PakInfoSize
    {
        // sizeof(Magic) + sizeof(Version) + sizeof(IndexOffset) + sizeof(IndexSize) + sizeof(IndexHash) + sizeof(EncryptedIndex) + sizeof(Guid)
        Size = sizeof(uint) + sizeof(PakVersion) + sizeof(long) + sizeof(long) + 20 + sizeof(byte) + 16,
        // UE4.21
        Sizev8 = Size + (32 * 4),
        // UE4.23 pak version was not incremented with backwards incompatible change
        Sizev8a = Size + (32 * 5),
        // UE4.25
        Sizev9 = Sizev8a + sizeof(byte),
    }
}

```

`src/UETools.Pak/Enums/PakVersion.cs`:

```cs
namespace UETools.Pak.Enums
{
    internal enum PakVersion : int
    {
        Initial = 1,
        NoTimestamps = 2,
        CompressionEncryption = 3,
        IndexEncryption = 4,
        RelativeChunkOffsets = 5,
        DeleteRecords = 6,
        EncryptionKeyGuid = 7,
        FNameBasedCompressionMethod = 8,
        FrozenIndex = 9,

        Last,
        Latest = Last - 1,
    };
}

```

`src/UETools.Pak/FileSystemEntry.cs`:

```cs
using System;
using System.Buffers;
using System.IO;
using System.Security.Cryptography;
using System.Threading;
using System.Threading.Tasks;
using UETools.Core;
using UETools.Pak.Interfaces;

namespace UETools.Pak
{
    public sealed class FileSystemEntry : IAsyncDisposable, IDisposable, IEntry
    {
        public FileSystemEntry(string path)
            : this(new FileStream(path, FileMode.Open, FileAccess.Read, FileShare.Read, PakFile.BufferSize))
        {

        }
        private FileSystemEntry(FileStream fileStream)
            => _fileStream = fileStream;

        public FArchive Read() => new FArchive(ReadBuf());
        public async ValueTask<FArchive> ReadAsync(CancellationToken cancellationToken = default) => new FArchive(await ReadBufAsync(cancellationToken).ConfigureAwait(false));

        private IMemoryOwner<byte> ReadBuf()
        {
            var data = PakMemoryPool.Shared.Rent((int)_fileStream.Length);
            _fileStream.ReadWholeBuf(data.Memory.Span);
            return data;
        }
        private async ValueTask<IMemoryOwner<byte>> ReadBufAsync(CancellationToken cancellationToken = default)
        {
            var data = PakMemoryPool.Shared.Rent((int)_fileStream.Length);
            await _fileStream.ReadWholeBufAsync(data.Memory, cancellationToken).ConfigureAwait(false);
            return data;
        }

        public void Dispose() => _fileStream.Dispose();
        public ValueTask DisposeAsync()
        {
#if NETSTANDARD2_0
            _fileStream.Dispose();
            return default;
#else
            return _fileStream.DisposeAsync();
#endif
        }


        private FileStream _fileStream;
    }
}

```

`src/UETools.Pak/Interfaces/IAesKeyProvider.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Text;

namespace UETools.Pak.Interfaces
{
    /// <summary>
    /// Interface for providing AES encryption/decryption key.
    /// </summary>
    public interface IAesKeyProvider
    {
        /// <summary>
        /// Base64 encoded encryption key.
        /// </summary>
        public string DecryptionKey { get; }
    }
}
```

`src/UETools.Pak/Interfaces/IEntry.cs`:

```cs
using System.Threading;
using System.Threading.Tasks;
using UETools.Core;

namespace UETools.Pak.Interfaces
{
    public interface IEntry
    {
        FArchive Read();
        ValueTask<FArchive> ReadAsync(CancellationToken cancellationToken = default);
    }
}

```

`src/UETools.Pak/NotPakFileException.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Runtime.Serialization;
using System.Text;
using UETools.Core;

namespace UETools.Pak
{
    public sealed class NotPakFileException : UnrealException
    {
        public NotPakFileException() { }

        public NotPakFileException(string message) : base(message) { }

        public NotPakFileException(string message, Exception innerException) : base(message, innerException) { }

        private NotPakFileException(SerializationInfo info, StreamingContext context) : base(info, context) { }
    }
}

```

`src/UETools.Pak/PakCompressedBlock.cs`:

```cs
using System;
using System.Diagnostics;
using UETools.Core;
using UETools.Core.Interfaces;

namespace UETools.Pak
{
    [DebuggerDisplay("{(int)_compressionStart}..{(int)_compressionEnd}")]
    public struct PakCompressedBlock : IUnrealSerializable, IEquatable<PakCompressedBlock>
    {
        public PakCompressedBlock(long start, long end)
        {
            _compressionStart = start;
            _compressionEnd = end;
        }

        public long Start => _compressionStart;
        public long End => _compressionEnd;
        public FArchive Serialize(FArchive archive)
            => archive.Read(ref _compressionStart)
                      .Read(ref _compressionEnd);

        internal readonly PakCompressedBlock OffsetBy(long offset) 
            => new PakCompressedBlock(_compressionStart - offset, _compressionEnd - offset);

        private long _compressionStart;
        private long _compressionEnd;

        public readonly override bool Equals(object? obj) => obj switch
        {
            PakCompressedBlock block => Equals(block),
            _ => false
        };
        public readonly override int GetHashCode() => HashCode.Combine(_compressionStart, _compressionEnd);
        public readonly bool Equals(PakCompressedBlock other) => other._compressionStart == _compressionStart && other._compressionEnd == _compressionEnd;
        public static bool operator ==(PakCompressedBlock left, PakCompressedBlock right) => left.Equals(right);
        public static bool operator !=(PakCompressedBlock left, PakCompressedBlock right) => !(left == right);
    }
}

```

`src/UETools.Pak/PakEncryptedException.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Runtime.Serialization;
using System.Text;
using UETools.Core;

namespace UETools.Pak
{
    class PakEncryptedException : UnrealException
    {
        public PakEncryptedException()
        {
        }

        public PakEncryptedException(string message) : base(message)
        {
        }

        public PakEncryptedException(string message, Exception innerException) : base(message, innerException)
        {
        }

        protected PakEncryptedException(SerializationInfo info, StreamingContext context) : base(info, context)
        {
        }
    }
}

```

`src/UETools.Pak/PakEntry.cs`:

```cs
using System;
using System.Buffers;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Threading;
using System.Threading.Tasks;
using UETools.Core;
using UETools.Core.Interfaces;
using UETools.Pak.Enums;
using UETools.Pak.Interfaces;

namespace UETools.Pak
{
    /// <summary>
    /// Virtual file system entry in pak file.
    /// </summary>
    public class PakEntry : IUnrealSerializable, IEntry
    {
        public string FileName { get; }
        private PakFile Owner { get; }
        internal PakEntry LinkedEntry { get; set; } = null!;
        internal long EntryHeaderSize { get; private set; }

        public long Size => _size;
        public long Offset => _offset;
        public bool IsEncrypted => _flags == EPakEntryFlags.Encrypted;
        public bool IsCompressed => _compressionIndex != 0;

        public int CompressionMethod => _compressionIndex;
        public long UncompressedSize => _uncompressedSize;
        private uint CompressionBlockSize => _compressionBlockSize;

        public List<PakCompressedBlock> CompressionBlocks => _compressionBlocks;

        public PakEntry(PakFile pakFile, string fileName)
        {
            Owner = pakFile;
            FileName = fileName;
        }

        public FArchive Serialize(FArchive archive)
        {
            var start = archive.Tell();
            var pakVersion = (PakVersion)archive.AssetVersion;
            archive.Read(ref _offset)
                   .Read(ref _size)
                   .Read(ref _uncompressedSize);
            if (pakVersion >= PakVersion.FNameBasedCompressionMethod)
            {
                // backwards incompatible 4.22
                if (archive.AssetSubversion == 1)
                {
                    var index = (byte)_compressionIndex;
                    archive.Read(ref index);
                    _compressionIndex = index;
                }
                else
                    archive.Read(ref _compressionIndex);
            }
            else
            {
                ECompressionFlags legacyFlags = default;
                archive.ReadUnsafe(ref legacyFlags);
                if (legacyFlags == ECompressionFlags.COMPRESS_None)
                    _compressionIndex = 0;
                else if ((legacyFlags & ECompressionFlags.COMPRESS_ZLIB) != 0)
                    _compressionIndex = 1;
                else if ((legacyFlags & ECompressionFlags.COMPRESS_GZIP) != 0)
                    _compressionIndex = 2;
                else if ((legacyFlags & ECompressionFlags.COMPRESS_Custom) != 0)
                    _compressionIndex = 3;
                else
                    throw new NotImplementedException();
            }

            if (pakVersion < PakVersion.NoTimestamps)
            {
                long timestamp = 0;
                archive.Read(ref timestamp); // FDateTime Timestamp
            }

            archive.Read(ref _hash);
            if (pakVersion >= PakVersion.CompressionEncryption)
            {
                if (_compressionIndex != 0)
                    archive.Read(ref _compressionBlocks!);

                archive.ReadUnsafe(ref _flags)
                       .Read(ref _compressionBlockSize);
            }
            EntryHeaderSize = archive.Tell() - start;

            return archive;
        }

        public FArchive Read() => new FArchive(Owner.ReadEntry(this));
        public DataSegment ReadBytes() => Owner.ReadEntry(this);
        public async ValueTask<FArchive> ReadAsync(CancellationToken cancellationToken = default) => new FArchive(await Owner.ReadEntryAsync(this, cancellationToken).ConfigureAwait(false));

        internal IMemoryOwner<byte> Read(Stream source)
        {
            var mem = PakMemoryPool.Shared.Rent((int)Size);
            source.ReadWholeBuf(Offset + EntryHeaderSize, mem.Memory);
            return mem;
        }
        internal async ValueTask<IMemoryOwner<byte>> ReadAsync(Stream source, CancellationToken cancellationToken = default)
        {
            var mem = PakMemoryPool.Shared.Rent((int)Size);
            await source.ReadWholeBufAsync(Offset + EntryHeaderSize, mem.Memory, cancellationToken).ConfigureAwait(false);
            return mem;
        }

        private long _offset;
        private long _size;
        private long _uncompressedSize;

        private int _compressionIndex;

        private List<PakCompressedBlock> _compressionBlocks = new List<PakCompressedBlock>();
        private uint _compressionBlockSize;
        private EPakEntryFlags _flags;
        private SHA1Hash _hash;
    }
}

```

`src/UETools.Pak/PakFile.cs`:

```cs
using System;
using System.Buffers;
using System.Collections.Generic;
using System.Diagnostics;
using System.Diagnostics.CodeAnalysis;
using System.IO;
using System.Linq;
using System.Security.Cryptography;
using System.Threading;
using System.Threading.Tasks;
using UETools.Core;
using UETools.Core.Interfaces;
using UETools.Pak.Enums;
using UETools.Pak.Interfaces;

namespace UETools.Pak
{
    [DebuggerDisplay("{FileName}, {AbsoluteIndex.Count} files", Name = "PakFile {FileName}")]
    public sealed class PakFile : IDisposable, IAsyncDisposable
    {
        public const uint Magic = 0x5A6F12E1;
        public const int BufferSize = 32 * 1024;
        private readonly IVersionProvider _versionProvider;
        private readonly AesPakCryptoProvider? _aesProvider;

        public Dictionary<string, PakEntry> AbsoluteIndex { get; private set; } = null!;
        public int FileCount => AbsoluteIndex.Count;
        private string MountPoint { get; set; } = null!;
        private string FileName { get; }
        private long Size { get; }
        private Stream SourceStream { get; }

        private PakFile(string fileName, long size, Stream sourceStream, IVersionProvider? versionProvider = null, AesPakCryptoProvider? aesProvider = null)
        {
            FileName = fileName;
            Size = size;
            SourceStream = sourceStream;
            _aesProvider = aesProvider;
            _versionProvider = versionProvider ?? AutomaticVersionProvider.Instance;
        }

        private IMemoryOwner<byte> ProcessEntry(PakEntry entry)
        {
            var data = entry.Read(SourceStream);
            if (entry.IsEncrypted)
            {
                if (_aesProvider is null)
                    throw new PakEncryptedException("Pak file contains encrypted entries. AES encryption key is necessary for reading this asset.");

                // decrypts data inplace
                _aesProvider.Decrypt(data.Memory);
            }
            return entry.IsCompressed ? UnrealCompression.Decompress(data, entry) : data;
        }
        private async ValueTask<IMemoryOwner<byte>> ProcessEntryAsync(PakEntry entry, CancellationToken cancellationToken = default)
        {
            var data = await entry.ReadAsync(SourceStream, cancellationToken);
            if (entry.IsEncrypted)
            {
                if (_aesProvider is null)
                    throw new PakEncryptedException("Pak file contains encrypted entries. AES encryption key is necessary for reading this asset.");

                _aesProvider.Decrypt(data.Memory);
            }
            return entry.IsCompressed ? await UnrealCompression.DecompressAsync(data, entry) : data;
        }

        public DataSegment ReadEntry(PakEntry entry)
        {
            DataSegment firstSegment = null!, segments = null;
            for (var ent = entry; ent is not null; ent = ent.LinkedEntry)
            {
                var entryData = ProcessEntry(ent);
                if (segments is null)
                {
                    segments = firstSegment = new DataSegment(entryData);
                }
                else
                {
                    segments = segments.Append(entryData);
                }
                segments.Tag(Path.GetExtension(ent.FileName));
            }
            return firstSegment;
        }
        public async ValueTask<DataSegment> ReadEntryAsync(PakEntry entry, CancellationToken cancellationToken = default)
        {
            var firstSegment = new DataSegment(await ProcessEntryAsync(entry).ConfigureAwait(false));
            var segments = firstSegment;
            for (var ent = entry.LinkedEntry; ent is not null; ent = ent.LinkedEntry)
            {
                segments = segments.Append(await ProcessEntryAsync(ent).ConfigureAwait(false));
            }
            return firstSegment;
        }

        private static bool ReadPakInfo(Stream stream, long size, AesPakCryptoProvider? _aesProvider, [NotNullWhen(true)] out PakInfo? info)
        {
            var values = Enum.GetValues(typeof(PakInfoSize)).Cast<int>().Where(x => size > x);
            // check only versions that can actually be pak files
            if (values.Any())
            {
                var maxSize = values.Max();
                using var data = PakMemoryPool.Shared.Rent(maxSize);
                stream.ReadWholeBuf(-maxSize, SeekOrigin.End, data.Memory);
                foreach (var value in values)
                {
                    if (value > size)
                        continue;

                    var z = data.Memory.Slice(data.Memory.Length - value);
                    var pak = new PakInfo(z, _aesProvider);
                    if (pak.IsUnrealPak)
                    {
                        info = pak;
                        return true;
                    }
                }
            }
            info = null;
            return false;
        }
        private void Initialize(PakInfo info) => ProcessIndex(info.ReadIndex(SourceStream));
        private async ValueTask InitializeAsync(PakInfo info, CancellationToken cancellationToken = default) => ProcessIndex(await info.ReadIndexAsync(SourceStream, cancellationToken: cancellationToken).ConfigureAwait(false));
        private void ProcessIndex(FArchive reader)
        {
            FString? mountPoint = default;
            int entryCount = 0;
            reader.Read(ref mountPoint)
                  .Read(ref entryCount);
            MountPoint = mountPoint.ToString().Replace("../../../", null);
            AbsoluteIndex = new Dictionary<string, PakEntry>(entryCount);

            for (var i = 0; i < entryCount; i++)
            {
                FString? fileName = default;
                reader.Read(ref fileName);
                var filePath = Path.Combine(MountPoint, fileName.ToString());
                var entry = new PakEntry(this, Path.GetFileName(filePath));
                entry.Serialize(reader);
                AbsoluteIndex.Add(filePath, entry);
            }

            // TODO: Change this to something working better
            foreach(var kv in AbsoluteIndex)
            {
                var val = kv.Value;
                if (kv.Value.IsCompressed)
                    val.CompressionBlocks.OffsetBy((int)val.EntryHeaderSize);

                if (kv.Key.EndsWith(".uasset"))
                {
                    var expPath = Path.ChangeExtension(kv.Key, ".uexp");
                    if (AbsoluteIndex.TryGetValue(expPath, out var exports))
                    {
                        val.LinkedEntry = exports;
                        var bulkPath = Path.ChangeExtension(kv.Key, ".ubulk");
                        if (AbsoluteIndex.TryGetValue(bulkPath, out var bulk))
                        {
                            exports.LinkedEntry = bulk;
                        }
                    }
                }
            }
        }

        public static PakFile? Open(FileInfo fileInfo, IVersionProvider? versionProvider = null, IAesKeyProvider? keyProvider = null)
        {
            if (fileInfo is null) throw new ArgumentNullException(nameof(fileInfo));
            if (!fileInfo.Exists) throw new FileNotFoundException();
            var aesProvider = keyProvider is null ? null : new AesPakCryptoProvider(keyProvider);

            var fileStream = new FileStream(fileInfo.FullName, FileMode.Open, FileAccess.Read, FileShare.Read, BufferSize);

            if (ReadPakInfo(fileStream, fileStream.Length, aesProvider, out var info))
            {
                var file = new PakFile(fileInfo.Name, fileStream.Length, fileStream, versionProvider, aesProvider);
                file.Initialize(info);
                return file;
            }
            else
            {
                fileStream.Dispose();
                throw new NotPakFileException();
            }
        }
        public async static Task<PakFile?> OpenAsync(FileInfo fileInfo, IVersionProvider? versionProvider = null, IAesKeyProvider? keyProvider = null, CancellationToken cancellationToken = default)
        {
            if (fileInfo is null) throw new ArgumentNullException(nameof(fileInfo));
            if (!fileInfo.Exists) throw new FileNotFoundException();
            var aesProvider = keyProvider is null ? null : new AesPakCryptoProvider(keyProvider);

            var fileStream = new FileStream(fileInfo.FullName, FileMode.Open, FileAccess.Read, FileShare.Read, BufferSize);
            if (ReadPakInfo(fileStream, fileStream.Length, aesProvider, out var info))
            {
                var file = new PakFile(fileInfo.Name, fileStream.Length, fileStream, versionProvider, aesProvider);
                await file.InitializeAsync(info, cancellationToken).ConfigureAwait(false);
                return file;
            }

            return null;
        }

        public void Dispose() => SourceStream.Dispose();
        public ValueTask DisposeAsync()
        {
#if NETSTANDARD2_0
            SourceStream.Dispose();
            return default;
#else
            return SourceStream.DisposeAsync();
#endif
        }
    }
}

```

`src/UETools.Pak/PakFileIndex.cs`:

```cs
using System;
using System.Collections.Concurrent;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Text;
using UETools.Core;
using UETools.Pak.Interfaces;

namespace UETools.Pak
{
    public class PakFileIndex<T> where T : IEntry
    {
        private ConcurrentDictionary<string, PakFileIndex<T>> _directories = new ConcurrentDictionary<string, PakFileIndex<T>>();
        private Dictionary<string, T> _files = new Dictionary<string, T>();
        private string _parentDir;

        private PakFileIndex() : this(string.Empty) { }
        private PakFileIndex(string parentDir) => _parentDir = parentDir;

        public void Add(string path, T entry)
        {
            var parts = path.Split(new[] {
                Path.DirectorySeparatorChar,
                Path.AltDirectorySeparatorChar
            }, StringSplitOptions.RemoveEmptyEntries)
                .AsEnumerable()
                .GetEnumerator();
            if (parts.MoveNext())
                Add(parts, entry);
            else
                throw new UnrealException("Invalid path.");
        }

        void Add(IEnumerator<string> parts, T entry)
        {
            var first = parts.Current;
            if (parts.MoveNext())
            {
                var dir = _directories.GetOrAdd(first, new PakFileIndex<T>(first));
                dir.Add(parts, entry);
            }
            else
                _files.Add(first, entry);
        }

        public static PakFileIndex<T> Parse(Dictionary<string, T> entries)
        {
            var index = new PakFileIndex<T>();

            foreach (var kv in entries)
                index.Add(kv.Key, kv.Value);

            return index;
        }
    }
}

```

`src/UETools.Pak/PakInfo.cs`:

```cs
using System;
using System.Collections.Generic;
using System.IO;
using System.Runtime.InteropServices;
using System.Threading;
using System.Threading.Tasks;
using UETools.Core;
using UETools.Core.Interfaces;
using UETools.Pak.Enums;

namespace UETools.Pak
{
    internal sealed partial class PakInfo : IUnrealSerializable
    {
        public bool IsUnrealPak => _magic == PakFile.Magic;
        public bool IsEncrypted => _encryptedIndex != 0;
        public FArchive ReadIndex(Stream stream)
        {
            var memory = PakMemoryPool.Shared.Rent((int)_indexSize);
            stream.ReadWholeBuf(_indexOffset, memory.Memory.Span);

            if (IsEncrypted && _aesProvider != null)
                _aesProvider.Decrypt(memory.Memory);

            return new FArchive(memory)
            {
                AssetVersion = (int)_version,
                AssetSubversion = GetPakSubversion(),
            };
        }
        public async ValueTask<FArchive> ReadIndexAsync(Stream stream, CancellationToken cancellationToken = default)
        {
            var memory = PakMemoryPool.Shared.Rent((int)_indexSize);
            await stream.ReadWholeBufAsync(_indexOffset, memory.Memory, cancellationToken).ConfigureAwait(false);

            if (IsEncrypted && _aesProvider != null)
                _aesProvider.Decrypt(memory.Memory);

            return new FArchive(memory)
            {
                AssetVersion = (int)_version,
                AssetSubversion = GetPakSubversion(),
            };
        }

        // TODO: Add stuff based on the backwards incompatible changes to pak format
        private int GetPakSubversion() => _infoSize switch
        {
            PakInfoSize.Sizev8 => 1,
            _ => 0
        };

        private PakInfo(PakInfoSize infoSize) => _infoSize = infoSize;
        internal PakInfo(Memory<byte> data, AesPakCryptoProvider? aesProvider) : this((PakInfoSize)data.Length)
        {
            _aesProvider = aesProvider;
            using var ar = new FArchive(data);
            Serialize(ar);
        }

        public FArchive Serialize(FArchive archive)
        {
            archive.Read(ref _encryptionIndexGuid)
                   .Read(ref _encryptedIndex)
                   .Read(ref _magic);

            if (!IsUnrealPak)
                return archive;

            archive.ReadUnsafe(ref _version)
                   .Read(ref _indexOffset)
                   .Read(ref _indexSize)
                   .Read(ref _indexHash);
            if (_version < PakVersion.IndexEncryption)
                _encryptedIndex = 0;
            if (_version < PakVersion.EncryptionKeyGuid)
                _encryptionIndexGuid = default;

            if (_version >= PakVersion.FrozenIndex)
                archive.Read(ref _indexIsFrozen);

            if (_version < PakVersion.FNameBasedCompressionMethod)
            {
                _compressionMethods.Add("Zlib");
                _compressionMethods.Add("Gzip");
                _compressionMethods.Add("Oodle");
            }
            else
            {
                var remainingBytes = (int)(archive.Length() - archive.Tell());
                Span<byte> shit = default;
                archive.Read(ref shit, remainingBytes);
                for (int Index = 0, start = 0; start < shit.Length; start = ++Index * CompressionMethodNameLen)
                {
                    var MethodString = shit.Slice(start, CompressionMethodNameLen);
                    if (MethodString[0] != 0)
                    {
                        var chars = MemoryMarshal.Cast<byte, char>(MethodString.Slice(0, MethodString.IndexOf((byte)0)));
                        _compressionMethods.Add(chars.ToString());
                    }
                }
            }

            return archive;
        }

        private uint _magic;
        private PakVersion _version;
        private long _indexOffset;
        private long _indexSize;
        private SHA1Hash _indexHash;
        private byte _encryptedIndex;
        private Guid _encryptionIndexGuid;
        private byte _indexIsFrozen;
        private List<FName> _compressionMethods = new List<FName>();

        private PakInfoSize _infoSize;
        private AesPakCryptoProvider? _aesProvider;
        private const int CompressionMethodNameLen = 32;
    }
}
```

`src/UETools.Pak/PakMemoryPool.PakMemoryArrayOwner.cs`:

```cs
using System;
using System.Buffers;
using System.Diagnostics.CodeAnalysis;

namespace UETools.Pak
{
    public sealed partial class PakMemoryPool
    {
        private class PakMemoryArrayOwner : IMemoryOwner<byte>
        {
            private readonly static ArrayPool<byte> _arrayPool = ArrayPool<byte>.Create(_bufferSize, 50);

            public Memory<byte> Memory { get; }

            public PakMemoryArrayOwner(int size)
            {
                _array = _arrayPool.Rent(size);
                Memory = new Memory<byte>(_array, 0, size);
            }


            public void Dispose() => _arrayPool.Return(_array);

            private readonly byte[] _array;
        }
    }
}

```

`src/UETools.Pak/PakMemoryPool.cs`:

```cs
using System;
using System.Buffers;
using System.Collections.Generic;
using System.Diagnostics.CodeAnalysis;
using System.Text;

namespace UETools.Pak
{
    public sealed partial class PakMemoryPool : MemoryPool<byte>
    {
        private PakMemoryPool() { }
        private const int _bufferSize = 1024 * 1024 * 256;
        public override int MaxBufferSize => _bufferSize;
        public override IMemoryOwner<byte> Rent(int minBufferSize = -1)
        {
            if (minBufferSize == -1)
                minBufferSize = 65536;

            return new PakMemoryArrayOwner(minBufferSize);
        }
        protected override void Dispose(bool disposing)
        {
        }

        [DoesNotReturn]
        private void ThrowOutOfRange(string paramName) => throw new ArgumentOutOfRangeException(paramName);
        public static new PakMemoryPool Shared { get; } = new PakMemoryPool();
    }
}

```

`src/UETools.Pak/PakVFS.cs`:

```cs
using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Threading;
using System.Threading.Tasks;
using UETools.Core;
using UETools.Core.Interfaces;
using UETools.Pak.Interfaces;

namespace UETools.Pak
{
    public sealed class PakVFS : IDisposable, IAsyncDisposable
    {
        public Dictionary<string, PakEntry> AbsoluteIndex { get; }
        public PakFileIndex<PakEntry> Index 
        { 
            get
            {
                if(_index is null)
                    _index = PakFileIndex<PakEntry>.Parse(AbsoluteIndex);

                return _index;
            }
        }

        private PakVFS(IEnumerable<PakFile> files)
        {
            _pakFiles = new List<PakFile>(files);
            AbsoluteIndex = _pakFiles.SelectMany(f => f.AbsoluteIndex).ToDictionary(x => x.Key, x => x.Value);
        }

        public static PakVFS OpenAt(string path, IVersionProvider? versionProvider = null, IAesKeyProvider? keyProvider = null)
        {
            if (path is null) 
                throw new ArgumentNullException(nameof(path));
            var dir = new DirectoryInfo(path);
            if (!dir.Exists)
                throw new DirectoryNotFoundException();

            var paks = dir.GetFiles(PakExtensionPattern).Select(f => PakFile.Open(f, versionProvider, keyProvider)).OfType<PakFile>();
            return new PakVFS(paks);
        }
        public async static ValueTask<PakVFS> OpenAtAsync(string path, IVersionProvider? versionProvider = null, IAesKeyProvider? keyProvider = null, CancellationToken cancellationToken = default)
        {
            if (path is null) throw new ArgumentNullException(nameof(path));
            var dir = new DirectoryInfo(path);
            if (!dir.Exists)
                throw new DirectoryNotFoundException();

            var files = dir.GetFiles(PakExtensionPattern);
            var tasks = files.Select(f => PakFile.OpenAsync(f, versionProvider, cancellationToken: cancellationToken));
            var paks = await Task.WhenAll(tasks).ConfigureAwait(false);
            return new PakVFS(paks.OfType<PakFile>());
        }

        public void Dispose()
        {
            foreach (var pak in _pakFiles)
                pak.Dispose();
        }
        public async ValueTask DisposeAsync()
        {
            foreach (var pak in _pakFiles)
                await pak.DisposeAsync().ConfigureAwait(false);
        }

        private const string PakExtensionPattern = "*.pak";

        private readonly List<PakFile> _pakFiles;
        private PakFileIndex<PakEntry>? _index;
    }
}

```

`src/UETools.Pak/README.md`:

```md
# UETools.Pak

Implements deserialization of UE4 Pak files and accessing its entries.
```

`src/UETools.Pak/UETools.Pak.csproj`:

```csproj
<Project Sdk="Microsoft.NET.Sdk">

  <PropertyGroup>
    <TargetFrameworks>netstandard2.0;netstandard2.1;net5.0</TargetFrameworks>
    <Nullable>enable</Nullable>
    <PackageDescription>Implementation of PAK virtual file system access, asset extraction, decryption and decompression.</PackageDescription>
  </PropertyGroup>

  <ItemGroup>
    <PackageReference Include="Ionic.Zlib.Core" Version="1.0.0" />
  </ItemGroup>
	
  <ItemGroup>
    <ProjectReference Include="..\UETools.Core\UETools.Core.csproj" />
  </ItemGroup>

</Project>

```

`src/UETools.Pak/UnrealCompression.cs`:

```cs
using System;
using System.Buffers;
using System.Collections.Generic;
using System.Diagnostics.CodeAnalysis;
using System.IO;
using System.IO.Compression;
using System.Runtime.InteropServices;
using System.Text;
using System.Threading;
using System.Threading.Tasks;
using UETools.Core;
using UETools.Pak.Interfaces;

namespace UETools.Pak
{
    internal class UnrealCompression
    {
        public static IMemoryOwner<byte> Decompress(IMemoryOwner<byte> compressedData, PakEntry entry)
        {
            using var data = compressedData;
            return Decompress(data.Memory, entry);
        }
        public static IMemoryOwner<byte> Decompress(Memory<byte> compressed, PakEntry entry)
        {
            var decompressed = PakMemoryPool.Shared.Rent((int)entry.UncompressedSize);
            if (MemoryMarshal.TryGetArray<byte>(compressed, out var src) && MemoryMarshal.TryGetArray<byte>(decompressed.Memory, out var dst))
                Decompress(src.Array!, src.Offset, src.Count, dst.Array!, dst.Offset, dst.Count, entry);
            else
            {
                decompressed.Dispose();
                throw new NotImplementedException();
                //Decompress(data.Memory.ToArray(), 0, data.Memory.Length, buffer, compressionBlocks);
            }
            return decompressed;
        }
        public static void Decompress(byte[] source, byte[] destination, PakEntry entry) => Decompress(source, 0, source.Length, destination, 0, destination.Length, entry);
        public static void Decompress(byte[] source, int srcOffset, int srcCount, byte[] destination, int dstOffset, int dstCount, PakEntry entry)
        {
            using var mem = new MemoryStream(source, srcOffset, srcCount);
            DecompressEntry(mem, destination, dstOffset, dstCount, entry);
        }
        private static void DecompressEntry(MemoryStream mem, byte[] destination, int dstOffset, int dstCount, PakEntry entry, int progress = 0)
        {
            foreach (var block in entry.CompressionBlocks)
            {
                mem.Seek(block.Start, SeekOrigin.Begin);
                using var stream = GetDecompressStream(mem, entry.CompressionMethod);
                var read = 0;
                do
                {
                    read = stream.Read(destination, dstOffset + progress, dstCount - progress);
                    progress += read;
                } while (read > 0);
            }
        }

        public static async ValueTask<IMemoryOwner<byte>> DecompressAsync(IMemoryOwner<byte> compressedData, PakEntry entry)
        {
            using var data = compressedData;
            return await DecompressAsync(data.Memory, entry);
        }
        public static async ValueTask<IMemoryOwner<byte>> DecompressAsync(Memory<byte> compressed, PakEntry entry, CancellationToken cancellationToken = default)
        {
            var decompressed = PakMemoryPool.Shared.Rent((int)entry.UncompressedSize);
            if (MemoryMarshal.TryGetArray<byte>(compressed, out var src) && MemoryMarshal.TryGetArray<byte>(decompressed.Memory, out var dst))
            {
                await DecompressAsync(src.Array!, src.Offset, src.Count, dst.Array!, dst.Offset, dst.Count, entry, cancellationToken).ConfigureAwait(false);
            }
            else
            {
                decompressed.Dispose();
                throw new NotImplementedException();
            }
            return decompressed;
        }
        public static async ValueTask DecompressAsync(byte[] source, int srcOffset, int srcCount, byte[] destination, int dstOffset, int dstCount, PakEntry entry, CancellationToken cancellationToken = default)
        {
            using var mem = new MemoryStream(source, srcOffset, srcCount);
            await DecompressEntryAsync(mem, destination, dstOffset, dstCount, entry, cancellationToken: cancellationToken).ConfigureAwait(false);
        }
        private static async ValueTask DecompressEntryAsync(MemoryStream mem, byte[] destination, int dstOffset, int dstCount, PakEntry entry, int progress = 0, CancellationToken cancellationToken = default)
        {
            foreach (var block in entry.CompressionBlocks)
            {
                mem.Seek(block.Start, SeekOrigin.Begin);
                using var stream = GetDecompressStream(mem, entry.CompressionMethod);
                var read = 0;
                do
                {
                    read = await stream.ReadAsync(destination, dstOffset + progress, dstCount - progress, cancellationToken).ConfigureAwait(false);
                    progress += read;
                } while (read > 0);
            }
        }

        internal static Stream GetDecompressStream(MemoryStream mem, int compressionMethod) => compressionMethod switch
        {
            1 => new Ionic.Zlib.ZlibStream(mem, Ionic.Zlib.CompressionMode.Decompress, true),
            2 => new GZipStream(mem, CompressionMode.Decompress, true),
            _ => throw new NotImplementedException($"CompressionMethod '{compressionMethod}' not implemented")
        };
    }
}

```

`src/UETools.TypeFactory/Factory.cs`:

```cs
using System;
using System.Diagnostics.CodeAnalysis;
using System.Linq;
using System.Linq.Expressions;

namespace UETools.TypeFactory
{
    /// <summary>
    /// Represents class for generating delegates instantiating passed type.
    /// </summary>
    public static class Factory
    {
        [DoesNotReturn]
        private static void ExceptionHelper(string message, Type type) => throw new TypeInitializationException(type.FullName, new Exception(message));
        /// <summary>
        /// Creates a delegate instantiating <paramref name="actualType"/>, making necessary checks to be sure it is of type <typeparamref name="T"/>.
        /// </summary>
        /// <typeparam name="T">The return type of compiled lambda.</typeparam>
        /// <param name="actualType"><see cref="Type"/> to instantiate.</param>
        /// <returns>Delegate instantiating <paramref name="actualType"/>.</returns>
        /// <remarks>Function makes necessary checks to ensure <paramref name="actualType"/> is actually instantiable</remarks>
        /// <exception cref="TypeInitializationException">Thrown if type is unsuitable for construction as <typeparamref name="T"/>. <see cref="Exception.InnerException"/> for message about error.</exception>
        /// <exception cref="ArgumentNullException">Thrown if <paramref name="actualType"/> is null</exception>
        public static Func<T> CreateInstanceFunction<T>(Type actualType)
        {
            if (actualType is null)
                throw new ArgumentNullException(nameof(actualType));

            var type = typeof(T);
            if (actualType.IsInterface)
                ExceptionHelper($"{actualType.FullName} is an interface.", actualType);

            if (actualType.IsAbstract)
                ExceptionHelper($"{actualType.FullName} is marked abstract.", actualType);

            if (actualType.IsGenericType && !actualType.IsConstructedGenericType)
                ExceptionHelper($"{actualType.FullName} is generic type, but not all generic type arguments were supplied.", actualType);

            if (!type.IsAssignableFrom(actualType))
                ExceptionHelper($"{actualType.FullName} is not assignable from {type.FullName}.", actualType);

            var constructorForParams = actualType.GetConstructor(Type.EmptyTypes);
            if (constructorForParams is null && !actualType.IsValueType)
                ExceptionHelper($"{actualType.FullName} can't be constructed.", actualType);

            if (actualType.IsValueType && type.IsInterface)
                return Expression.Lambda<Func<T>>(Expression.Convert(Expression.Default(actualType), type), true, Enumerable.Empty<ParameterExpression>()).Compile();
            else
                return Expression.Lambda<Func<T>>(Expression.New(constructorForParams!), true, Enumerable.Empty<ParameterExpression>()).Compile();
        }
    }
}
```

`src/UETools.TypeFactory/Generic/Factory.cs`:

```cs
using System;
using System.Diagnostics.CodeAnalysis;
using System.Linq;
using System.Linq.Expressions;

namespace UETools.TypeFactory
{
    /// <summary>
    /// Creates instances of type <typeparamref name="T"/>.
    /// </summary>
    /// <typeparam name="T">The type with a parameterless constructor.</typeparam>
    public static class Factory<T> where T : new()
    {
        private static readonly Func<T> _createInstanceFunc = Expression.Lambda<Func<T>>(Expression.New(typeof(T)), true, Enumerable.Empty<ParameterExpression>()).Compile();

        /// <summary>
        /// Creates an instance of type <typeparamref name="T"/> by calling it's parameterless constructor.
        /// </summary>
        /// <returns>An instance of type <typeparamref name="T"/>.</returns>
        [return: NotNull]
#pragma warning disable CA1000 // Do not declare static members on generic types
        public static T CreateInstance() => _createInstanceFunc()!;

        public static Func<T> GetFactoryFunc() => _createInstanceFunc;
#pragma warning restore CA1000 // Do not declare static members on generic types
    }
}

```

`src/UETools.TypeFactory/README.md`:

```md
# UETools.TypeFactory

Implements framework for reflecting and creating types.
```

`src/UETools.TypeFactory/TypeCollector.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Diagnostics.CodeAnalysis;
using System.IO;
using System.Linq;
using System.Reflection;

namespace UETools.TypeFactory
{
    public class TypeCollector<T>
    {
        private const string _searchPattern = "*.dll";
        public TypeCollector(Assembly fromAssembly) : this(fromAssembly, false) { }
        public TypeCollector(Assembly fromAssembly, bool collectGenerics) => GetAssemblyTypes(fromAssembly, collectGenerics);
        public TypeCollector(DirectoryInfo fromDirectory) : this(fromDirectory, false) { }
        public TypeCollector(DirectoryInfo fromDirectory, bool collectGenerics)
        {
            var files = fromDirectory.GetFiles(_searchPattern);
            foreach (var file in files)
            {
                try
                {
                    var assembly = Assembly.LoadFrom(file.FullName);
                    GetAssemblyTypes(assembly, collectGenerics);
                }
                catch (Exception)
                {

                }
            }
        }

        public TypeCollector(string path) : this(path, false) { }
        public TypeCollector(string path, bool collectGenerics) : this(new DirectoryInfo(path), collectGenerics) { }

        public TypeFactory<T> ToFactory()
        {
            try
            {
                return new TypeFactory<T>(typesCollection);
            }
            catch (Exception ex)
            {
                Debug.WriteLine(ex);
                throw;
            }
        }

        private void GetAssemblyTypes(Assembly assembly, bool collectGenerics) => typesCollection.AddRange(assembly.GetTypes()
            .Where(t =>
                typeof(T).IsAssignableFrom(t)
                && !t.IsAbstract
                && !t.IsInterface
                // && t.IsVisible
                && (collectGenerics || !t.IsGenericType)
            ));

        public List<Type> typesCollection = new List<Type>();
    }
}

```

`src/UETools.TypeFactory/TypeFactory.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Linq;

namespace UETools.TypeFactory
{
    public class TypeFactory<T>
    {
        public Dictionary<string, Func<T>> factories = new Dictionary<string, Func<T>>();
        internal TypeFactory(List<Type> types)
        {
            foreach (var type in types)
            {
                try
                {
                    factories.Add(type.Name, Factory.CreateInstanceFunction<T>(type));
                }
                catch (Exception ex)
                {
                    Debug.WriteLine(ex);
                }
            }
        }


        T GetInstance()
        {
            return GetFactory()();
        }

        Func<T> GetFactory() => factories.First().Value;
    }
}

```

`src/UETools.TypeFactory/UETools.TypeFactory.csproj`:

```csproj
<Project Sdk="Microsoft.NET.Sdk">

  <PropertyGroup>
    <TargetFrameworks>netstandard2.0;netstandard2.1;net5.0</TargetFrameworks>
    <Nullable>enable</Nullable>
    <PackageDescription>Internal object factory and type collection.</PackageDescription>
  </PropertyGroup>
</Project>

```

`src/UETools.sln`:

```sln
Microsoft Visual Studio Solution File, Format Version 12.00
# Visual Studio Version 16
VisualStudioVersion = 16.0.28711.60
MinimumVisualStudioVersion = 10.0.40219.1
Project("{9A19103F-16F7-4668-BE54-9A1E7A4F7556}") = "UETools.Core", "UETools.Core\UETools.Core.csproj", "{9239FE7A-CF78-49E3-B229-DCAFCC2AE436}"
EndProject
Project("{2150E333-8FDC-42A3-9474-1A3956D46DE8}") = "Solution Items", "Solution Items", "{56FC2EBF-4884-42EF-A12A-F8E906FE5438}"
	ProjectSection(SolutionItems) = preProject
		.editorconfig = .editorconfig
		..\.github\workflows\dotnetcore.yml = ..\.github\workflows\dotnetcore.yml
	EndProjectSection
EndProject
Project("{9A19103F-16F7-4668-BE54-9A1E7A4F7556}") = "UETools.Pak", "UETools.Pak\UETools.Pak.csproj", "{8B490C69-4B13-4544-B69C-26FD071868EF}"
EndProject
Project("{9A19103F-16F7-4668-BE54-9A1E7A4F7556}") = "UETools.TypeFactory", "UETools.TypeFactory\UETools.TypeFactory.csproj", "{025698CB-9753-4DF6-B1F0-DF1979247B9A}"
EndProject
Project("{9A19103F-16F7-4668-BE54-9A1E7A4F7556}") = "UETools.Objects", "UETools.Objects\UETools.Objects.csproj", "{BAB3504B-86A3-4C90-97C0-D95B323830AA}"
EndProject
Project("{9A19103F-16F7-4668-BE54-9A1E7A4F7556}") = "UETools.Assets", "UETools.Assets\UETools.Assets.csproj", "{C7884944-AAEC-49EB-888C-7031F02DFEA1}"
EndProject
Global
	GlobalSection(SolutionConfigurationPlatforms) = preSolution
		Debug|Any CPU = Debug|Any CPU
		Debug|ARM = Debug|ARM
		Debug|ARM64 = Debug|ARM64
		Release|Any CPU = Release|Any CPU
		Release|ARM = Release|ARM
		Release|ARM64 = Release|ARM64
	EndGlobalSection
	GlobalSection(ProjectConfigurationPlatforms) = postSolution
		{9239FE7A-CF78-49E3-B229-DCAFCC2AE436}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
		{9239FE7A-CF78-49E3-B229-DCAFCC2AE436}.Debug|Any CPU.Build.0 = Debug|Any CPU
		{9239FE7A-CF78-49E3-B229-DCAFCC2AE436}.Debug|ARM.ActiveCfg = Debug|Any CPU
		{9239FE7A-CF78-49E3-B229-DCAFCC2AE436}.Debug|ARM.Build.0 = Debug|Any CPU
		{9239FE7A-CF78-49E3-B229-DCAFCC2AE436}.Debug|ARM64.ActiveCfg = Debug|Any CPU
		{9239FE7A-CF78-49E3-B229-DCAFCC2AE436}.Debug|ARM64.Build.0 = Debug|Any CPU
		{9239FE7A-CF78-49E3-B229-DCAFCC2AE436}.Release|Any CPU.ActiveCfg = Release|Any CPU
		{9239FE7A-CF78-49E3-B229-DCAFCC2AE436}.Release|Any CPU.Build.0 = Release|Any CPU
		{9239FE7A-CF78-49E3-B229-DCAFCC2AE436}.Release|ARM.ActiveCfg = Release|Any CPU
		{9239FE7A-CF78-49E3-B229-DCAFCC2AE436}.Release|ARM.Build.0 = Release|Any CPU
		{9239FE7A-CF78-49E3-B229-DCAFCC2AE436}.Release|ARM64.ActiveCfg = Release|Any CPU
		{9239FE7A-CF78-49E3-B229-DCAFCC2AE436}.Release|ARM64.Build.0 = Release|Any CPU
		{8B490C69-4B13-4544-B69C-26FD071868EF}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
		{8B490C69-4B13-4544-B69C-26FD071868EF}.Debug|Any CPU.Build.0 = Debug|Any CPU
		{8B490C69-4B13-4544-B69C-26FD071868EF}.Debug|ARM.ActiveCfg = Debug|Any CPU
		{8B490C69-4B13-4544-B69C-26FD071868EF}.Debug|ARM.Build.0 = Debug|Any CPU
		{8B490C69-4B13-4544-B69C-26FD071868EF}.Debug|ARM64.ActiveCfg = Debug|Any CPU
		{8B490C69-4B13-4544-B69C-26FD071868EF}.Debug|ARM64.Build.0 = Debug|Any CPU
		{8B490C69-4B13-4544-B69C-26FD071868EF}.Release|Any CPU.ActiveCfg = Release|Any CPU
		{8B490C69-4B13-4544-B69C-26FD071868EF}.Release|Any CPU.Build.0 = Release|Any CPU
		{8B490C69-4B13-4544-B69C-26FD071868EF}.Release|ARM.ActiveCfg = Release|Any CPU
		{8B490C69-4B13-4544-B69C-26FD071868EF}.Release|ARM.Build.0 = Release|Any CPU
		{8B490C69-4B13-4544-B69C-26FD071868EF}.Release|ARM64.ActiveCfg = Release|Any CPU
		{8B490C69-4B13-4544-B69C-26FD071868EF}.Release|ARM64.Build.0 = Release|Any CPU
		{418B7F9B-E235-424A-B559-C5EA7F8DA5DC}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
		{418B7F9B-E235-424A-B559-C5EA7F8DA5DC}.Debug|Any CPU.Build.0 = Debug|Any CPU
		{418B7F9B-E235-424A-B559-C5EA7F8DA5DC}.Debug|ARM.ActiveCfg = Debug|Any CPU
		{418B7F9B-E235-424A-B559-C5EA7F8DA5DC}.Debug|ARM.Build.0 = Debug|Any CPU
		{418B7F9B-E235-424A-B559-C5EA7F8DA5DC}.Debug|ARM64.ActiveCfg = Debug|Any CPU
		{418B7F9B-E235-424A-B559-C5EA7F8DA5DC}.Debug|ARM64.Build.0 = Debug|Any CPU
		{418B7F9B-E235-424A-B559-C5EA7F8DA5DC}.Release|Any CPU.ActiveCfg = Release|Any CPU
		{418B7F9B-E235-424A-B559-C5EA7F8DA5DC}.Release|Any CPU.Build.0 = Release|Any CPU
		{418B7F9B-E235-424A-B559-C5EA7F8DA5DC}.Release|ARM.ActiveCfg = Release|Any CPU
		{418B7F9B-E235-424A-B559-C5EA7F8DA5DC}.Release|ARM.Build.0 = Release|Any CPU
		{418B7F9B-E235-424A-B559-C5EA7F8DA5DC}.Release|ARM64.ActiveCfg = Release|Any CPU
		{418B7F9B-E235-424A-B559-C5EA7F8DA5DC}.Release|ARM64.Build.0 = Release|Any CPU
		{72868066-6E14-4E02-8D4E-076B5E1BEBD0}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
		{72868066-6E14-4E02-8D4E-076B5E1BEBD0}.Debug|Any CPU.Build.0 = Debug|Any CPU
		{72868066-6E14-4E02-8D4E-076B5E1BEBD0}.Debug|ARM.ActiveCfg = Debug|Any CPU
		{72868066-6E14-4E02-8D4E-076B5E1BEBD0}.Debug|ARM.Build.0 = Debug|Any CPU
		{72868066-6E14-4E02-8D4E-076B5E1BEBD0}.Debug|ARM64.ActiveCfg = Debug|Any CPU
		{72868066-6E14-4E02-8D4E-076B5E1BEBD0}.Debug|ARM64.Build.0 = Debug|Any CPU
		{72868066-6E14-4E02-8D4E-076B5E1BEBD0}.Release|Any CPU.ActiveCfg = Release|Any CPU
		{72868066-6E14-4E02-8D4E-076B5E1BEBD0}.Release|Any CPU.Build.0 = Release|Any CPU
		{72868066-6E14-4E02-8D4E-076B5E1BEBD0}.Release|ARM.ActiveCfg = Release|Any CPU
		{72868066-6E14-4E02-8D4E-076B5E1BEBD0}.Release|ARM.Build.0 = Release|Any CPU
		{72868066-6E14-4E02-8D4E-076B5E1BEBD0}.Release|ARM64.ActiveCfg = Release|Any CPU
		{72868066-6E14-4E02-8D4E-076B5E1BEBD0}.Release|ARM64.Build.0 = Release|Any CPU		
		{025698CB-9753-4DF6-B1F0-DF1979247B9A}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
		{025698CB-9753-4DF6-B1F0-DF1979247B9A}.Debug|Any CPU.Build.0 = Debug|Any CPU
		{025698CB-9753-4DF6-B1F0-DF1979247B9A}.Debug|ARM.ActiveCfg = Debug|Any CPU
		{025698CB-9753-4DF6-B1F0-DF1979247B9A}.Debug|ARM.Build.0 = Debug|Any CPU
		{025698CB-9753-4DF6-B1F0-DF1979247B9A}.Debug|ARM64.ActiveCfg = Debug|Any CPU
		{025698CB-9753-4DF6-B1F0-DF1979247B9A}.Debug|ARM64.Build.0 = Debug|Any CPU
		{025698CB-9753-4DF6-B1F0-DF1979247B9A}.Release|Any CPU.ActiveCfg = Release|Any CPU
		{025698CB-9753-4DF6-B1F0-DF1979247B9A}.Release|Any CPU.Build.0 = Release|Any CPU
		{025698CB-9753-4DF6-B1F0-DF1979247B9A}.Release|ARM.ActiveCfg = Release|Any CPU
		{025698CB-9753-4DF6-B1F0-DF1979247B9A}.Release|ARM.Build.0 = Release|Any CPU
		{025698CB-9753-4DF6-B1F0-DF1979247B9A}.Release|ARM64.ActiveCfg = Release|Any CPU
		{025698CB-9753-4DF6-B1F0-DF1979247B9A}.Release|ARM64.Build.0 = Release|Any CPU
		{BAB3504B-86A3-4C90-97C0-D95B323830AA}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
		{BAB3504B-86A3-4C90-97C0-D95B323830AA}.Debug|Any CPU.Build.0 = Debug|Any CPU
		{BAB3504B-86A3-4C90-97C0-D95B323830AA}.Debug|ARM.ActiveCfg = Debug|Any CPU
		{BAB3504B-86A3-4C90-97C0-D95B323830AA}.Debug|ARM.Build.0 = Debug|Any CPU
		{BAB3504B-86A3-4C90-97C0-D95B323830AA}.Debug|ARM64.ActiveCfg = Debug|Any CPU
		{BAB3504B-86A3-4C90-97C0-D95B323830AA}.Debug|ARM64.Build.0 = Debug|Any CPU
		{BAB3504B-86A3-4C90-97C0-D95B323830AA}.Release|Any CPU.ActiveCfg = Release|Any CPU
		{BAB3504B-86A3-4C90-97C0-D95B323830AA}.Release|Any CPU.Build.0 = Release|Any CPU
		{BAB3504B-86A3-4C90-97C0-D95B323830AA}.Release|ARM.ActiveCfg = Release|Any CPU
		{BAB3504B-86A3-4C90-97C0-D95B323830AA}.Release|ARM.Build.0 = Release|Any CPU
		{BAB3504B-86A3-4C90-97C0-D95B323830AA}.Release|ARM64.ActiveCfg = Release|Any CPU
		{BAB3504B-86A3-4C90-97C0-D95B323830AA}.Release|ARM64.Build.0 = Release|Any CPU
		{C7884944-AAEC-49EB-888C-7031F02DFEA1}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
		{C7884944-AAEC-49EB-888C-7031F02DFEA1}.Debug|Any CPU.Build.0 = Debug|Any CPU
		{C7884944-AAEC-49EB-888C-7031F02DFEA1}.Debug|ARM.ActiveCfg = Debug|Any CPU
		{C7884944-AAEC-49EB-888C-7031F02DFEA1}.Debug|ARM.Build.0 = Debug|Any CPU
		{C7884944-AAEC-49EB-888C-7031F02DFEA1}.Debug|ARM64.ActiveCfg = Debug|Any CPU
		{C7884944-AAEC-49EB-888C-7031F02DFEA1}.Debug|ARM64.Build.0 = Debug|Any CPU
		{C7884944-AAEC-49EB-888C-7031F02DFEA1}.Release|Any CPU.ActiveCfg = Release|Any CPU
		{C7884944-AAEC-49EB-888C-7031F02DFEA1}.Release|Any CPU.Build.0 = Release|Any CPU
		{C7884944-AAEC-49EB-888C-7031F02DFEA1}.Release|ARM.ActiveCfg = Release|Any CPU
		{C7884944-AAEC-49EB-888C-7031F02DFEA1}.Release|ARM.Build.0 = Release|Any CPU
		{C7884944-AAEC-49EB-888C-7031F02DFEA1}.Release|ARM64.ActiveCfg = Release|Any CPU
		{C7884944-AAEC-49EB-888C-7031F02DFEA1}.Release|ARM64.Build.0 = Release|Any CPU
	EndGlobalSection
	GlobalSection(SolutionProperties) = preSolution
		HideSolutionNode = FALSE
	EndGlobalSection
	GlobalSection(ExtensibilityGlobals) = postSolution
		SolutionGuid = {5DF68AF7-ABA4-4100-9340-3E170E73E7C3}
	EndGlobalSection
EndGlobal

```

`version.json`:

```json
{
  "$schema": "https://raw.githubusercontent.com/AArnott/Nerdbank.GitVersioning/master/src/NerdBank.GitVersioning/version.schema.json",
  "version": "0.4",
  "publicReleaseRefSpec": [
    "^refs/heads/master$",
    "^refs/heads/v\\d+(?:\\.\\d+)?$"
  ],
  "cloudBuild": {
    "buildNumber": {
      "enabled": true
    }
  }
}

```